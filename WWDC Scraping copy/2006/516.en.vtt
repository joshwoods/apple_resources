WEBVTT

00:00:10.450 --> 00:00:11.820
Scripting for admins.

00:00:11.840 --> 00:00:13.300
Thanks for coming.

00:00:13.300 --> 00:00:15.400
We got a lot of good stuff,
a lot of good people,

00:00:15.400 --> 00:00:18.900
a lot of good projects to hopefully
get you excited about doing some

00:00:18.900 --> 00:00:20.830
scripting things and going out there.

00:00:20.840 --> 00:00:22.880
So I'm Joel Rennich.

00:00:22.880 --> 00:00:25.280
I'm a dude from middle of nowhere,
Illinois.

00:00:25.280 --> 00:00:27.610
I've done some, woo, Illinois!

00:00:29.220 --> 00:00:30.780
Savoy!

00:00:31.190 --> 00:00:31.320
Woo!

00:00:31.330 --> 00:00:36.000
I've done some scripting in my time,
but we got some other great people

00:00:36.000 --> 00:00:38.440
that we're bringing up today to
talk about some very cool projects.

00:00:38.440 --> 00:00:42.460
Cool projects to get you motivated,
cool projects that will show

00:00:42.460 --> 00:00:46.120
you a little bit how a little
bit of work can go a long way.

00:00:46.120 --> 00:00:48.630
This is the third year
we've done this session,

00:00:48.630 --> 00:00:52.580
and that's what we like to show,
that scripting is very easy to get into,

00:00:52.580 --> 00:00:55.040
and hopefully we show you a bit
of some sexy stuff that you can

00:00:55.080 --> 00:00:57.880
get excited about and hopefully
bring back to where you were.

00:00:58.520 --> 00:01:01.770
What you won't learn, though,
is how to script.

00:01:01.780 --> 00:01:04.160
So if you came here to
learn how to script,

00:01:04.300 --> 00:01:05.190
just leave.

00:01:05.220 --> 00:01:07.740
It might be easier at that point.

00:01:07.740 --> 00:01:11.300
We thought about how we could
do it in 45 minutes to an hour,

00:01:11.300 --> 00:01:13.380
and we just couldn't
come up with anything.

00:01:13.380 --> 00:01:15.800
So they wouldn't give us any more space.

00:01:15.800 --> 00:01:17.820
Anyway, so a little bit of recap.

00:01:17.820 --> 00:01:23.780
In 2004, we talked about AppleScript,
shell, and Perl there, the camel.

00:01:23.780 --> 00:01:26.110
Then in 2005,
we came back to this session,

00:01:26.170 --> 00:01:28.840
we talked about AppleScript,
we talked about Shell,

00:01:28.950 --> 00:01:31.840
and we also had this thing,
which I didn't realize

00:01:31.840 --> 00:01:32.940
was the Python logo.

00:01:32.940 --> 00:01:37.220
It looks kind of snaky,
I guess is what they're going for.

00:01:37.240 --> 00:01:39.380
And Python,
so a couple things added Python in

00:01:39.400 --> 00:01:41.640
the new hotness at the time,
and good stuff.

00:01:42.070 --> 00:01:47.940
Well, this year, AppleScript, Shell,
Perl, Java, PHP, Python,

00:01:47.940 --> 00:01:50.080
expect didn't have a logo.

00:01:50.080 --> 00:01:55.280
It hasn't changed in a little while,
and so we tried to do as best we could.

00:01:55.280 --> 00:01:57.740
But so a lot more things
coming together here.

00:01:57.740 --> 00:02:00.580
We're talking a lot today about
how we get multiple scripting

00:02:00.580 --> 00:02:01.740
languages to work together.

00:02:01.770 --> 00:02:03.940
Dogs and cats living in harmony.

00:02:04.260 --> 00:02:09.150
Python and Perl and camels and
coffee cups all working together.

00:02:09.160 --> 00:02:10.720
So hopefully some good stuff.

00:02:10.740 --> 00:02:14.040
Sometimes we pick on Perl,
but there's a lot of

00:02:14.040 --> 00:02:17.050
Perl coders out there,
and they're usually bigger than I am.

00:02:17.060 --> 00:02:21.190
So today we'll pick on assembly coders,
all right, because I don't think too many

00:02:21.190 --> 00:02:22.440
people code in assembly anymore.

00:02:22.440 --> 00:02:24.810
They're usually older and
can't run as fast as I can.

00:02:24.820 --> 00:02:27.640
So hopefully this session,
we'll get to that.

00:02:27.640 --> 00:02:29.720
So this session is more fun
than coding in assembly,

00:02:29.840 --> 00:02:32.240
all right, so that you get an idea of
how to do some scripting,

00:02:32.240 --> 00:02:35.140
some cool stuff, using technologies that
we already have in place.

00:02:35.140 --> 00:02:39.140
So we got three different kind of
projects that we're talking about.

00:02:39.140 --> 00:02:43.360
The first one is going to be an
automated self-service method for

00:02:43.430 --> 00:02:46.640
imaging a large group of machines,
all right.

00:02:46.640 --> 00:02:50.140
This leverages Netboot, ASR,
and some other stuff with a very,

00:02:50.140 --> 00:02:51.140
very cool web front end.

00:02:51.140 --> 00:02:53.140
All right, and this is Brian James that's
going to be doing this.

00:02:53.140 --> 00:02:55.140
It's something that we
use internally at Apple.

00:02:55.140 --> 00:02:56.140
It's not really a product.

00:02:56.140 --> 00:02:57.540
It's not something we can give you.

00:02:57.540 --> 00:03:00.360
But certainly we can give you an idea
of what you could do by gluing all

00:03:00.360 --> 00:03:03.540
these things together because none of
the individual pieces are proprietary

00:03:03.540 --> 00:03:05.040
or secret or anything else like that.

00:03:05.230 --> 00:03:06.740
Then we've got Nigel Kirsten coming up.

00:03:06.740 --> 00:03:08.620
He's going to talk
about log-in hook magic,

00:03:08.620 --> 00:03:09.240
all right.

00:03:09.240 --> 00:03:12.040
A lot of times when we talk about
different administration topics,

00:03:12.040 --> 00:03:14.930
we talk about fixing things that
are in there or customizing your

00:03:14.930 --> 00:03:18.340
environment or doing some stuff that's
a little bit beyond what anybody

00:03:18.340 --> 00:03:19.470
ever thought you should be doing.

00:03:21.070 --> 00:03:22.280
Sometimes good, sometimes bad.

00:03:22.310 --> 00:03:24.260
Those are typically
done with login hooks.

00:03:24.260 --> 00:03:25.740
Nigel's going to talk about that.

00:03:25.760 --> 00:03:28.170
And then finally,
Tim Perfit's going to come up and

00:03:28.180 --> 00:03:31.360
talk about manipulating boot camp.

00:03:31.360 --> 00:03:33.670
So you can actually go ahead
and clone your images and

00:03:33.670 --> 00:03:35.140
do some fun stuff with that.

00:03:35.170 --> 00:03:38.380
So with that aside,
let me introduce Brian James,

00:03:38.390 --> 00:03:40.860
a dude from Cupertino,
who's going to come up here and

00:03:40.860 --> 00:03:44.480
talk to you about some projects.

00:03:53.700 --> 00:03:55.440
Hi, everybody.

00:03:55.440 --> 00:03:58.320
My name is Brian James,
and I'm going to be talking to

00:03:58.380 --> 00:04:01.600
you about autorestore.apple.com.

00:04:01.630 --> 00:04:07.420
It's a web application that I wrote
to simplify OS installation.

00:04:08.200 --> 00:04:11.750
So everyone out here has probably
installed Mac OS X more times

00:04:11.770 --> 00:04:14.170
than they care to remember.

00:04:14.300 --> 00:04:16.950
You know doing so
involves making choices,

00:04:17.030 --> 00:04:22.060
making a couple selections,
you then wait, wait, wait, wait, wait.

00:04:22.130 --> 00:04:27.890
You hear our little jingle and then
you have to answer more questions.

00:04:28.900 --> 00:04:32.460
It's a pretty manual process,
but if you're only doing one machine,

00:04:32.460 --> 00:04:34.300
it's not a big deal.

00:04:35.450 --> 00:04:38.950
If you're doing a couple
machines every once in a while,

00:04:39.000 --> 00:04:39.620
it's not a big deal.

00:04:39.670 --> 00:04:44.380
But if you're like me and you're
stuck doing it to hundreds of

00:04:44.380 --> 00:04:48.880
machines almost every other day,
sticking CDs in drives

00:04:48.880 --> 00:04:50.580
gets a little bit old.

00:04:50.760 --> 00:04:56.260
So after doing that a couple times,
I couldn't help but feel that

00:04:56.830 --> 00:05:04.310
There had to be an easier way to install
an OS on a whole bunch of machines.

00:05:04.900 --> 00:05:07.590
The very first optimization,
the obvious one,

00:05:07.590 --> 00:05:10.950
is to use this tool called
Apple Software Restore,

00:05:10.950 --> 00:05:11.580
or ASR.

00:05:11.580 --> 00:05:16.220
It's a command line tool that
efficiently lets you clone two volumes.

00:05:16.220 --> 00:05:18.290
I'm sure everybody's probably
heard of it and used it.

00:05:18.360 --> 00:05:23.740
So the very first optimization I did
was to install and configure once,

00:05:23.740 --> 00:05:26.900
set up one machine just how I wanted it,
and create disk images.

00:05:26.900 --> 00:05:31.920
You can do that using Disk Utility,
and you can basically preserve one user.

00:05:31.920 --> 00:05:35.220
So I stuck all those disk
images on a FireWire hard drive,

00:05:35.220 --> 00:05:38.250
and I would walk from machine
to machine doing the restore.

00:05:38.260 --> 00:05:41.880
So it was a good optimization,
but I still had to pick

00:05:41.880 --> 00:05:43.570
a new startup disk.

00:05:43.620 --> 00:05:46.180
I still had to come back
and reboot the machine.

00:05:46.180 --> 00:05:49.810
So it was still a manual process that
involved me walking up to each machine.

00:05:49.820 --> 00:05:53.260
So I figured there had
to be an even easier way.

00:05:53.260 --> 00:05:55.200
So enter scripting.

00:05:55.200 --> 00:05:58.280
Scripting is a great way to
perform repetitive operations.

00:05:58.280 --> 00:06:00.120
I'm sure everybody knows that.

00:06:00.240 --> 00:06:03.180
So I made my situation
a little bit better.

00:06:03.180 --> 00:06:05.980
I took all my ASR images,
and I put them up on a server.

00:06:05.980 --> 00:06:10.120
And I wrote a simple script
which mounted that server,

00:06:10.120 --> 00:06:12.570
performed the restore, blessed,
and rebooted.

00:06:13.920 --> 00:06:16.130
A script might look like this to do that.

00:06:16.180 --> 00:06:18.080
Basically,
it would take the volume in the image,

00:06:18.090 --> 00:06:22.090
and it would mount an AFP volume,
do the restore, bless the volume,

00:06:22.100 --> 00:06:22.580
and reboot.

00:06:22.580 --> 00:06:23.940
Pretty basic.

00:06:23.940 --> 00:06:27.000
So, it saved me lots of time.

00:06:27.000 --> 00:06:29.320
I could walk up to each machine,
run a single script,

00:06:29.390 --> 00:06:31.020
and the whole process would be done.

00:06:31.020 --> 00:06:34.010
When I came back, the machine would be
rebooted from the new image.

00:06:34.060 --> 00:06:38.530
So, better but still annoying,
because I really prefer sitting

00:06:38.530 --> 00:06:40.390
in my office and the lab.

00:06:40.400 --> 00:06:42.220
So, SSH.

00:06:42.220 --> 00:06:48.130
Why not sit in my office and SSH to the
machine and run the exact same script?

00:06:48.140 --> 00:06:52.290
So, I took the script,
and I put it up on the server,

00:06:52.290 --> 00:06:55.820
and I stuck it in the document root,
the web document root,

00:06:55.820 --> 00:06:56.840
and I turned on the web server.

00:06:56.840 --> 00:06:59.230
I would then SSH in to
the remote machines,

00:06:59.230 --> 00:07:02.090
and I would download the
script and run it that way,

00:07:02.320 --> 00:07:03.970
just like I was sitting at it.

00:07:04.050 --> 00:07:05.340
So, I could now sit at my office.

00:07:05.360 --> 00:07:08.240
An example SSH session might
look something like this.

00:07:08.280 --> 00:07:09.880
SSH in is a local user.

00:07:10.320 --> 00:07:12.320
I would go to my server,
at the remote host,

00:07:12.320 --> 00:07:17.320
curl down the script from my server,
save it in /temp, make it executable,

00:07:17.320 --> 00:07:21.090
run it just like I did before,
passing volume and image arguments.

00:07:21.860 --> 00:07:23.260
That made things better.

00:07:23.300 --> 00:07:25.560
One shot per machine, one,
and they were done.

00:07:25.560 --> 00:07:26.340
I could do it remotely.

00:07:26.410 --> 00:07:27.720
But what about passwords?

00:07:27.870 --> 00:07:31.300
It was kind of annoying that I had
to enter a password each time.

00:07:31.300 --> 00:07:34.450
It kind of prevented me
getting any more efficient.

00:07:34.630 --> 00:07:39.460
Well, lucky for me, I'm not the first one
that's had this problem.

00:07:39.560 --> 00:07:43.210
So all of your Macs out there come with
this really cool tool called Expect.

00:07:43.310 --> 00:07:46.230
Expect is a program that
talks to other interactive

00:07:46.370 --> 00:07:48.120
programs according to a script.

00:07:48.160 --> 00:07:51.760
So when SSH expects you to be
sitting there entering passwords,

00:07:51.780 --> 00:07:53.890
Expect can be there in your place.

00:07:53.950 --> 00:07:55.560
Expect has a man page.

00:07:55.560 --> 00:07:57.030
You can read it right now.

00:07:57.070 --> 00:07:59.700
O'Reilly even wrote a book on the topic.

00:07:59.700 --> 00:08:03.120
Good news for everybody here
is that the Expect script to

00:08:03.160 --> 00:08:04.910
talk to SSH is really simple.

00:08:05.030 --> 00:08:07.840
This is actually the only
working piece of code,

00:08:07.860 --> 00:08:11.710
and it's the actual
Expect script I use for my tool.

00:08:11.740 --> 00:08:15.080
You pass it the host, user password,
and the command you want to

00:08:15.090 --> 00:08:16.300
run on the remote machine.

00:08:16.380 --> 00:08:19.440
It does the SSH, and it even checks for
potential error cases,

00:08:19.440 --> 00:08:20.150
like wrong username and password.

00:08:20.230 --> 00:08:23.330
So don't try to write it down.

00:08:23.600 --> 00:08:28.590
A quick Google search of Expect and
SSH will yield a result very similar.

00:08:28.690 --> 00:08:32.090
So given this Expect script,
I can make my life even easier.

00:08:32.100 --> 00:08:34.600
I write another shell script,
takes the same volume

00:08:34.600 --> 00:08:37.670
and image arguments,
and a host, user, and password.

00:08:37.900 --> 00:08:41.560
I wrap the three commands I would
do interactively-- the curl,

00:08:41.760 --> 00:08:47.490
make it executable, reboot,
and I pass those to the Expect script.

00:08:48.160 --> 00:08:52.160
With that script, I can now just write a
simple Perl looping script.

00:08:52.160 --> 00:08:54.770
Assume that you're past
arrays of machines and all

00:08:54.780 --> 00:08:56.040
the associated information.

00:08:56.040 --> 00:08:59.910
You can now run a single command,
which can loop and fork off one

00:08:59.910 --> 00:09:01.980
of those processes each time.

00:09:01.980 --> 00:09:06.050
So, I'm now able to SSH into my
server and run one command,

00:09:06.050 --> 00:09:10.560
and I can restore a whole bunch
of machines simultaneously.

00:09:10.560 --> 00:09:13.280
So, I was really proud of myself,
and I walked into my

00:09:13.320 --> 00:09:16.540
boss's office and I said,
hey, I've totally solved the problem.

00:09:16.540 --> 00:09:20.200
I can now restore one machine, five, ten,
a hundred in the time it

00:09:20.200 --> 00:09:21.900
basically takes to do one.

00:09:21.900 --> 00:09:25.250
And he said, oh, great, you know,
let me see how it works,

00:09:25.250 --> 00:09:27.760
because if it's good enough,
I'm going to fire all of

00:09:27.760 --> 00:09:28.760
you and just do it myself.

00:09:28.760 --> 00:09:30.760
So,

00:09:32.550 --> 00:09:35.250
I opened up Terminal and I SSH'd
into my server and I said,

00:09:35.260 --> 00:09:38.780
"Oh, you run this command,
you pass it these 5, these 10, these 15,

00:09:38.780 --> 00:09:41.390
these 25 arguments," you know,
and his eyes just kind of

00:09:41.390 --> 00:09:42.490
rolled back in his head.

00:09:42.500 --> 00:09:46.450
And he said, "That works for you,
but don't expect I can't use this.

00:09:46.510 --> 00:09:51.210
I feel much better with text fields,
buttons, pull-down menus." And really,

00:09:51.340 --> 00:09:52.000
this did.

00:09:52.000 --> 00:09:54.120
This worked for me,
but it would have been too

00:09:54.120 --> 00:09:56.110
complicated for anyone else to use it.

00:09:56.500 --> 00:09:58.630
It took way too many arguments
in a required terminal.

00:09:58.640 --> 00:10:02.940
Well, wouldn't it be great if
it had a nice interface?

00:10:03.200 --> 00:10:07.140
So I sort of stood back and
looked at what I'd done so far.

00:10:07.140 --> 00:10:09.130
So I'd written all these great scripts.

00:10:09.140 --> 00:10:11.440
I had totally solved the problem
from the server standpoint,

00:10:11.440 --> 00:10:14.120
but I just had a tool that
was really too hard to use.

00:10:14.160 --> 00:10:18.760
So embracing scripting,
I decided to keep what I had,

00:10:18.760 --> 00:10:21.840
keep this core part the same,
and just figure out a nice way to

00:10:21.840 --> 00:10:24.300
put a clever interface on top of it.

00:10:24.300 --> 00:10:27.890
And what I really wanted was something
easy enough for anyone to use so that

00:10:28.000 --> 00:10:29.200
you didn't have to read a manual.

00:10:29.200 --> 00:10:33.640
You could just go to this website,
and it would be intuitive.

00:10:33.640 --> 00:10:36.800
I wanted it to work from anywhere,
and I wanted it to scale just as

00:10:36.820 --> 00:10:38.440
well as the server version did.

00:10:38.440 --> 00:10:42.910
And in addition,
I needed a management interface because

00:10:42.910 --> 00:10:48.040
we were making tons of these ASR images,
and I wanted other teams to be able

00:10:48.040 --> 00:10:50.700
to -- I didn't want to have to get
involved if anyone else wanted to use it.

00:10:50.700 --> 00:10:54.300
So I built a little interface
so that people could,

00:10:54.330 --> 00:10:57.830
could keep track of their ASR images.

00:10:58.020 --> 00:11:01.080
So the complete solution
that I ended up with does an

00:11:01.170 --> 00:11:03.970
interface in HTML and JavaScript.

00:11:03.980 --> 00:11:07.770
The server runs PHP,
which kind of acts as the glue between

00:11:07.770 --> 00:11:09.870
the web and the shell commands.

00:11:09.940 --> 00:11:13.390
MySQL is used to store
data about the images.

00:11:13.440 --> 00:11:18.500
And the SSH expect and shell script
pieces pretty much remain the same.

00:11:19.230 --> 00:11:24.410
So this is sort of what I ended up with,
or this is the current working version.

00:11:24.470 --> 00:11:27.660
And I'm going to take you through a
basic usage scenario of how someone

00:11:27.660 --> 00:11:29.780
would use it to put an OS on a machine.

00:11:29.780 --> 00:11:33.220
So first thing you do
is type a host name.

00:11:33.220 --> 00:11:37.460
In this case, I'm going to do bjames8,
which is a machine in my office.

00:11:37.590 --> 00:11:39.330
And press the Add Target button.

00:11:39.330 --> 00:11:41.640
It's going to send that
stuff to the server.

00:11:41.670 --> 00:11:44.300
And the server's going to
send me back a little piece

00:11:44.300 --> 00:11:48.160
of UI with an image selection,
a volume, username, and password.

00:11:48.160 --> 00:11:50.280
The same fields,
or the same arguments that

00:11:50.280 --> 00:11:51.580
the shell script took.

00:11:51.600 --> 00:11:53.230
You'll notice the red dot.

00:11:53.250 --> 00:11:55.650
And if you can read that text,
the red dot says that

00:11:55.650 --> 00:11:57.160
that machine is sleeping.

00:11:57.160 --> 00:11:59.780
So you might ask, well,
how does this website know

00:11:59.840 --> 00:12:01.400
that machine's sleeping?

00:12:01.410 --> 00:12:04.550
There's the red dot, sorry.

00:12:04.560 --> 00:12:06.200
So how do I know that?

00:12:06.200 --> 00:12:07.330
Pretty easy.

00:12:07.330 --> 00:12:10.280
PHP can easily execute shell scripts.

00:12:10.310 --> 00:12:13.750
So web browser submits
the data to the server.

00:12:13.760 --> 00:12:17.420
PHP gets it,
executes a simple ping command.

00:12:17.420 --> 00:12:19.560
Back and forth,
we have the state of the machine.

00:12:19.580 --> 00:12:21.860
In PHP, this code is really simple.

00:12:21.860 --> 00:12:23.900
You've got your host,
you've got your command.

00:12:23.900 --> 00:12:26.390
You just executed three lines of code.

00:12:26.390 --> 00:12:27.350
You know the state.

00:12:27.440 --> 00:12:29.360
Well, in addition to ping,
we also need to know

00:12:29.360 --> 00:12:31.160
whether SSH is turned on,
because that's a

00:12:31.160 --> 00:12:32.460
requirement for this tool.

00:12:32.460 --> 00:12:35.530
So also, there's this tool called NC.

00:12:35.540 --> 00:12:39.090
It's just like ping, but instead,
you can just ask for a specific port.

00:12:39.240 --> 00:12:41.140
So SSH runs on port 22.

00:12:41.140 --> 00:12:46.070
So I'm going to run NC, ping 22,
and if I get a response, SSH is enabled.

00:12:48.240 --> 00:12:50.040
That kind of sucks that
the machine's asleep,

00:12:50.100 --> 00:12:51.510
because the whole point of
this tool is I don't want to

00:12:51.510 --> 00:12:52.520
walk up to those machines.

00:12:52.630 --> 00:12:55.200
Well, using the existing
infrastructure that I have,

00:12:55.310 --> 00:12:56.640
why not try to wake the machine?

00:12:56.640 --> 00:13:00.880
Waking an Ethernet-connected
machine over on connected to a,

00:13:00.880 --> 00:13:02.640
you know, Ethernet port is pretty easy.

00:13:02.640 --> 00:13:04.640
If you do a Google search
for wake on LAN,

00:13:04.640 --> 00:13:08.500
you'll get 50 Perl scripts that all send
the magic packet to wake the machine.

00:13:08.500 --> 00:13:10.470
So why not offer the user a wake service?

00:13:11.380 --> 00:13:12.640
Easy enough?

00:13:12.670 --> 00:13:13.240
So, same process.

00:13:13.240 --> 00:13:17.110
Send the data back to the server,
this time execute the wake on LAN script.

00:13:17.180 --> 00:13:18.740
So, what do you know?

00:13:18.890 --> 00:13:20.090
It responded, B.

00:13:20.090 --> 00:13:23.420
James 8 is now awake and
ready to be restored.

00:13:25.090 --> 00:13:26.600
Next, image selection.

00:13:26.600 --> 00:13:30.980
So my database on my server keeps
track of the URL to the image.

00:13:31.080 --> 00:13:32.130
It's completely distributed.

00:13:32.140 --> 00:13:35.820
The images can live on an NFS server,
AFP server, wherever you want them.

00:13:36.030 --> 00:13:38.400
And my database just
keeps track of that URL,

00:13:38.460 --> 00:13:44.190
along with a nice user-readable string,
so you can decide which image you'd like.

00:13:44.620 --> 00:13:47.620
So you pick your image,
gonna pick a volume.

00:13:47.660 --> 00:13:50.290
Well,
how do you know valid volumes if you're

00:13:50.480 --> 00:13:52.320
physically nowhere near the machine?

00:13:52.450 --> 00:13:56.410
So again, using the same infrastructure,
let's give the user some

00:13:56.410 --> 00:13:58.460
UI to make volume selection.

00:13:58.560 --> 00:14:00.870
So I've got a
Collect Volume Information button.

00:14:00.910 --> 00:14:03.690
To do this,
we're actually gonna have to SSH to

00:14:03.690 --> 00:14:05.620
the machine using our expect script.

00:14:05.880 --> 00:14:08.430
So you need a user and a password.

00:14:08.540 --> 00:14:10.840
So fill in those fields,
press the button.

00:14:10.840 --> 00:14:14.860
I'm gonna show the user a
nice little Aqua progress bar,

00:14:14.910 --> 00:14:17.130
compliments of the Apple online store.

00:14:17.270 --> 00:14:19.310
And--

00:14:20.760 --> 00:14:25.310
And so that process is
running and browser's waiting.

00:14:25.380 --> 00:14:27.160
Exact same procedure.

00:14:27.210 --> 00:14:29.860
Submit the values,
execute the shell script.

00:14:29.920 --> 00:14:32.520
The shell script SSHs to the machine.

00:14:32.550 --> 00:14:35.720
And a script is run locally on the
target machine to collect volumes.

00:14:35.840 --> 00:14:37.380
Volume information is easy to get.

00:14:37.380 --> 00:14:41.570
The mount command, HDI util command,
system profiler,

00:14:41.690 --> 00:14:43.570
there's any number of commands.

00:14:43.790 --> 00:14:47.700
That data's collected,
back to the server, stuck in my database,

00:14:47.700 --> 00:14:50.260
and a response is sent.

00:14:50.620 --> 00:14:52.620
Again, PHP, executing shell scripts.

00:14:52.620 --> 00:14:56.740
This is an example of how you would
run that command on the remote machine.

00:14:56.740 --> 00:14:59.000
You have your host user password.

00:14:59.010 --> 00:15:02.730
The command curls the script down,
makes it executable, runs it.

00:15:02.880 --> 00:15:06.260
We do a shell exec,
passing those four variables

00:15:07.040 --> 00:15:08.330
to our expect script.

00:15:08.460 --> 00:15:10.260
And that's really all it takes.

00:15:10.260 --> 00:15:13.140
So we return with a
nice list of pull-down,

00:15:13.140 --> 00:15:15.400
a pull-down menu with
a nice list of volumes.

00:15:15.550 --> 00:15:18.140
User can select their volume.

00:15:18.400 --> 00:15:20.000
Basically, the sky's the limit.

00:15:20.000 --> 00:15:22.380
On that target machine,
I can run whatever commands I want.

00:15:22.380 --> 00:15:25.950
So as another convenience,
why not collect hardware information?

00:15:26.030 --> 00:15:29.520
So a dump assistant profiler
lets me know that BJames8

00:15:29.520 --> 00:15:31.080
happens to be an iMac core duo.

00:15:31.370 --> 00:15:33.910
So you can do all sorts of fun stuff.

00:15:34.000 --> 00:17:12.700
[Transcript missing]

00:17:14.200 --> 00:17:18.670
And when it's done,
the machine tells the server, I'm done.

00:17:18.680 --> 00:17:22.490
The next time the browser
updates the status for BJames8,

00:17:22.530 --> 00:17:23.840
you know it's done.

00:17:24.080 --> 00:17:25.480
So a word about Ajax.

00:17:25.480 --> 00:17:29.010
I'm sure Ajax is asynchronous
JavaScript and XML.

00:17:29.150 --> 00:17:33.670
I'm sure everybody's heard it,
heard the hype, heard the buzz.

00:17:33.730 --> 00:17:35.080
I didn't pick it for that reason.

00:17:35.080 --> 00:17:38.530
Like way back when,
it was a standard submit-based page.

00:17:38.540 --> 00:17:41.200
Ajax actually made my life a lot easier.

00:17:41.240 --> 00:17:45.610
And if you have web-based tools that
you'd like to put nice interfaces on,

00:17:45.610 --> 00:17:46.540
Ajax is a great way to do that.

00:17:46.560 --> 00:17:47.660
It's really easy to learn.

00:17:47.870 --> 00:17:51.320
There's great, powerful frameworks,
Prototype Dojo.

00:17:51.340 --> 00:17:54.780
They wrap some of the basic functionality
and make it even more powerful.

00:17:54.790 --> 00:17:57.600
Most importantly for me was the
fact that it was asynchronous,

00:17:57.810 --> 00:18:01.840
which means I could submit a
request independently of any other.

00:18:01.850 --> 00:18:05.400
And all these machines,
I might have a G3 900

00:18:05.400 --> 00:18:08.410
megahertz iMac or a quad G5.

00:18:08.510 --> 00:18:10.440
They're going to respond
at different times.

00:18:10.500 --> 00:18:16.490
So Ajax allowed me to basically thread
everything starting at the browser.

00:18:16.890 --> 00:18:19.340
And everything can respond independently.

00:18:19.420 --> 00:18:21.870
So my server code is really simple.

00:18:22.150 --> 00:18:26.800
It only needs to know how to perform
those actions on one machine.

00:18:26.870 --> 00:18:30.800
And when all these web requests,
web submits hit the server,

00:18:30.800 --> 00:18:32.950
these are all executed
basically simultaneously.

00:18:32.950 --> 00:18:41.110
So JavaScript sort of made my,
or Ajax made my life really easy.

00:18:41.350 --> 00:18:43.700
That's auto restore,
and that's basically what it

00:18:43.700 --> 00:18:44.580
looks like to restore one.

00:18:44.580 --> 00:18:46.700
And because of Ajax,

00:18:47.370 --> 00:18:50.780
The work it takes to restore one
is the same amount of work it

00:18:50.810 --> 00:18:52.890
takes to restore as many as I want.

00:18:52.940 --> 00:18:56.330
Code on the server doesn't need
to know anything about many.

00:18:56.330 --> 00:18:57.620
It knows just about one.

00:18:57.620 --> 00:19:00.900
You may look at this and say, whoa,
but I still have to fill

00:19:00.900 --> 00:19:02.940
in all these text fields,
pull down menus.

00:19:02.940 --> 00:19:06.120
Well, because it's HTML, JavaScript,
I can do all this cool UI stuff.

00:19:06.240 --> 00:19:07.900
Like, for instance,
if you have host names

00:19:07.900 --> 00:19:10.040
that have numeric ranges,
which is typical if you have a

00:19:10.040 --> 00:19:12.360
large group of test machines,
you can enter a prefix

00:19:12.360 --> 00:19:15.180
followed by a numeric range,
and it'll add all the

00:19:15.180 --> 00:19:17.060
numeric values in between.

00:19:17.300 --> 00:19:18.430
That's one example.

00:19:18.480 --> 00:19:21.420
Another example is what
I call a default row,

00:19:21.420 --> 00:19:24.800
and that basically means
you can give an image value,

00:19:24.800 --> 00:19:28.450
a volume value, user password,
and any targets that are added will

00:19:28.450 --> 00:19:30.160
automatically assume those values.

00:19:30.160 --> 00:19:33.100
So you can do all these tricky things
to reduce the amount of typing.

00:19:33.100 --> 00:19:37.220
So that's my tool,
and that's a basic recap.

00:19:37.220 --> 00:19:40.080
It does lots of other stuff
because the basic infrastructure of

00:19:40.080 --> 00:19:43.060
submitting things from a browser,
executing shell scripts,

00:19:43.060 --> 00:19:45.080
you can do all kinds
of really cool stuff.

00:19:45.100 --> 00:19:46.760
Sorry.

00:19:47.520 --> 00:19:50.530
So in closing,
it was really important for me to

00:19:50.530 --> 00:19:52.420
pick the right language for the job.

00:19:52.420 --> 00:19:55.600
So I let shells do what shells do best,
and I let JavaScript do

00:19:55.620 --> 00:19:57.060
what JavaScript does best.

00:19:57.100 --> 00:19:59.640
And I was guaranteed that, like,
you know,

00:19:59.640 --> 00:20:03.790
shell scripts can execute scripts
in other languages and vice versa.

00:20:03.800 --> 00:20:06.800
So do the pieces in the
languages that make sense,

00:20:06.800 --> 00:20:09.760
and you're guaranteed they're going
to integrate well down the road.

00:20:09.760 --> 00:20:14.560
And just in closing, for me,
this project started three and a

00:20:14.560 --> 00:20:17.280
half years ago and really isn't
something I've done full time.

00:20:17.300 --> 00:20:20.620
It's just something that
evolved over time based on need.

00:20:20.640 --> 00:20:23.990
So if I tried to think of the problem,
like, all at once,

00:20:24.070 --> 00:20:27.140
I probably would have never,
it would have just overwhelmed me.

00:20:27.140 --> 00:20:31.960
But I started small,
and I optimized the pieces that I could,

00:20:31.960 --> 00:20:35.920
and it just,
my solution just progressed over time.

00:20:35.920 --> 00:20:38.740
And that's kind of, you know,
people call it the Unix philosophy.

00:20:38.740 --> 00:20:41.540
Small pieces solve one
small problem at a time,

00:20:41.620 --> 00:20:45.900
and you chain those pieces together
to solve more complex problems.

00:20:45.900 --> 00:20:47.280
So it's not, I didn't read.

00:20:47.300 --> 00:20:48.260
I didn't read this before I started.

00:20:48.260 --> 00:20:50.290
It just ended up that way.

00:20:50.320 --> 00:20:56.190
So, and now to talk about login
hooks is Nigel Kirsten.

00:21:05.900 --> 00:21:09.280
Okay, so I'm a sysadmin at a
university in Australia,

00:21:09.280 --> 00:21:11.590
as you might be able to tell.

00:21:11.760 --> 00:21:15.040
And I'm going to be
talking about login hooks.

00:21:15.050 --> 00:21:18.190
Login hooks are really,
really useful to kind of fill in

00:21:18.190 --> 00:21:21.620
the gaps that we might have from
MCX management or whatever we want

00:21:21.620 --> 00:21:22.700
to put in our directory service.

00:21:22.700 --> 00:21:25.500
They're really useful for
managing parts of our SOE,

00:21:25.500 --> 00:21:29.020
and I kind of feel that they don't get
the publicity that they really deserve.

00:21:29.020 --> 00:21:31.330
So what I'm going to cover
is what login hooks are,

00:21:31.390 --> 00:21:34.900
how they work, how we implement them,
and then I'm going to go through some of

00:21:34.900 --> 00:21:36.820
the login hooks that I use day to day.

00:21:36.820 --> 00:21:39.760
I was sort of thinking
about doing a demo,

00:21:39.760 --> 00:21:43.700
but a login hook being an invisible
script that runs when someone logs in at

00:21:43.700 --> 00:21:48.750
the login window isn't really compelling.

00:21:49.620 --> 00:21:51.060
They're pretty simple.

00:21:51.080 --> 00:21:54.060
They're a script that runs whenever
a user logs in at the login window.

00:21:54.270 --> 00:21:55.980
So remember, it doesn't happen over SSH.

00:21:55.980 --> 00:21:58.690
It doesn't happen over AFP, SMB,
any other method.

00:21:58.960 --> 00:22:01.000
Whenever any user logs
in at the login window,

00:22:01.000 --> 00:22:04.300
if a login hook has been
defined for that computer,

00:22:04.300 --> 00:22:05.220
it'll run.

00:22:05.220 --> 00:22:07.590
They get executed after
authentication is successful,

00:22:07.620 --> 00:22:10.030
but before the finder
appears to the user.

00:22:10.220 --> 00:22:13.280
So they're pretty much transparent
as far as the user's concerned.

00:22:13.290 --> 00:22:15.120
And they run as the local root user.

00:22:15.260 --> 00:22:17.910
So this allows you to do
local privileged operations.

00:22:18.020 --> 00:22:21.480
And you can also use sudo
to run commands as the user.

00:22:21.480 --> 00:22:23.060
You can write them in
any scripting language.

00:22:23.060 --> 00:22:24.080
I don't really care what you use.

00:22:24.080 --> 00:22:26.080
I'm pretty language agnostic.

00:22:26.090 --> 00:22:30.280
But whatever you're happiest with,
write your login hooks in that.

00:22:30.280 --> 00:22:32.200
Technical details are pretty minimal.

00:22:32.210 --> 00:22:35.120
The first argument passed to
the script is the short name

00:22:35.120 --> 00:22:36.340
of the user who's logging in.

00:22:36.340 --> 00:22:37.760
If you're using bash, it's $1.

00:22:37.830 --> 00:22:41.580
If you're using Perl, PHP,
it's the first item of the argv arrays.

00:22:41.740 --> 00:22:44.940
One thing a few people used to do
was use return codes to deny login,

00:22:44.940 --> 00:22:48.020
but that kind of stopped working,
I think, around 10.2 or something.

00:22:48.020 --> 00:22:49.750
So you can't actually do that.

00:22:49.860 --> 00:22:51.700
As we'll see, though,
there's a few ways you can be a

00:22:51.700 --> 00:22:55.410
little bit more brutal and just
kill the whole login window session.

00:22:56.150 --> 00:22:58.090
I should mention that logout hooks exist.

00:22:58.270 --> 00:22:59.860
They work pretty much
exactly the same way.

00:22:59.860 --> 00:23:01.720
The only difference is
when a user logs out,

00:23:01.720 --> 00:23:05.210
the script runs, and when it finishes,
then the login window

00:23:05.210 --> 00:23:06.620
appears for the next user.

00:23:06.620 --> 00:23:07.900
They're simple.

00:23:07.900 --> 00:23:10.980
If you can enter the terminal,
type a couple of commands,

00:23:10.990 --> 00:23:12.670
you can write a login hook.

00:23:19.900 --> 00:23:21.300
What are they good for?

00:23:21.300 --> 00:23:24.890
Well, a word that seems to have come
into pretty much semi-official

00:23:24.890 --> 00:23:27.040
terminology is crappy apps.

00:23:27.040 --> 00:23:31.770
I think that's the Mac Enterprise crowd
laughing in the crowd there.

00:23:31.970 --> 00:23:34.260
I don't know about you guys,
but I have a lot of applications

00:23:34.260 --> 00:23:36.390
that are per seat licensed,
per seat licensed.

00:23:36.560 --> 00:23:40.820
But they put all this crap in
application support in the users folder,

00:23:40.880 --> 00:23:41.720
preferences.

00:23:41.860 --> 00:23:43.740
And if that stuff's not there,
the app doesn't run.

00:23:44.050 --> 00:23:47.320
So log-in hooks are pretty good
for copying all that stuff in.

00:23:47.390 --> 00:23:49.550
They're good for enforcing
templates or preferences that

00:23:49.550 --> 00:23:51.000
might not fit into the MCX model.

00:23:51.000 --> 00:23:52.700
Maybe you don't have a directory service.

00:23:52.700 --> 00:23:54.080
You can work that way.

00:23:54.080 --> 00:23:56.260
They're good for
enforcing stuff at log-in.

00:23:56.260 --> 00:24:00.290
And I find they're really useful
for modifying the SOE for a

00:24:00.290 --> 00:24:03.880
certain conjunction of this kind
of user on this kind of machine.

00:24:03.880 --> 00:24:07.420
Stuff that the MCX user group
model doesn't always fit in nicely,

00:24:07.420 --> 00:24:07.960
too.

00:24:07.960 --> 00:24:10.440
And finally,
what I use them for quite a lot is

00:24:10.440 --> 00:24:13.600
redirecting parts of a network home
directory to the local machine.

00:24:13.600 --> 00:24:16.020
I know there's a bunch of people out
there who do the other way as well.

00:24:16.200 --> 00:24:19.250
They run as a local user,
they mount a network drive drive on

00:24:19.250 --> 00:24:23.690
login and they might redirect parts of
the network drive to the local account.

00:24:26.660 --> 00:24:30.500
So, setting them up.

00:24:30.500 --> 00:24:32.490
You've got three main
methods we can set them up.

00:24:32.650 --> 00:24:35.000
Two modern and one kind of legacy.

00:24:35.080 --> 00:24:37.550
So we can set them up locally
using the defaults domain,

00:24:37.680 --> 00:24:40.280
we can put them in the
directory using MCX,

00:24:40.430 --> 00:24:43.810
or we can go and edit the etc.tty.s file.

00:24:44.350 --> 00:24:46.160
Setting them up locally is pretty simple.

00:24:46.170 --> 00:24:49.810
We just use the defaults command
to write to the login window

00:24:49.810 --> 00:24:51.650
domain for the root user.

00:24:51.830 --> 00:24:54.330
And we just specify a login
hook and the path to the script.

00:24:54.360 --> 00:24:56.780
So long as it's executable
and it's a valid script,

00:24:56.780 --> 00:24:58.840
that'll run whenever a user logs in.

00:24:58.860 --> 00:25:02.580
Those of you doing image maintenance,
it modifies login window plist

00:25:02.580 --> 00:25:06.080
in the root user's home folder
and just puts that stuff in.

00:25:06.230 --> 00:25:10.630
So if you just need to edit it by hand,
you can define them that way as well.

00:25:11.480 --> 00:25:14.190
You can also put them in MCX,
which is something I've only just

00:25:14.190 --> 00:25:15.470
sort of started doing recently.

00:25:15.660 --> 00:25:17.970
You can only define them
for your computer lists,

00:25:17.970 --> 00:25:19.900
so not for your user groups.

00:25:19.930 --> 00:25:23.700
But one thing I was kind of thinking
was that in the last couple of days,

00:25:23.700 --> 00:25:27.100
we found out about how we can now
have nested groups for computer lists.

00:25:27.120 --> 00:25:30.690
And there's sort of no reason
why we shouldn't be able to,

00:25:30.690 --> 00:25:33.010
not that I've tried this,
but have multiple nested

00:25:33.020 --> 00:25:36.050
groups of computer lists
defining different login hooks.

00:25:36.230 --> 00:25:38.360
So you might have a
generic lab login hook.

00:25:38.450 --> 00:25:41.070
You might have a specific one
for these kinds of lab machines.

00:25:41.110 --> 00:25:44.220
You might have a specific one for
the teacher's machine in the lab.

00:25:44.300 --> 00:25:46.770
So we should be able to get a
hierarchy of login hooks going.

00:25:47.030 --> 00:25:48.890
And if we can't,
and it's not working in 10.5,

00:25:48.890 --> 00:25:52.480
we should probably test
that and file some bugs.

00:25:54.210 --> 00:25:58.240
We define them in Workgroup Manager,
in the Scripts tab, in Login Preferences.

00:25:58.260 --> 00:26:00.660
And as you see,
we just fill in where the script is.

00:26:00.660 --> 00:26:01.660
It's actually pretty good.

00:26:01.660 --> 00:26:02.160
It'll warn you.

00:26:02.160 --> 00:26:04.540
It'll go, hey, this isn't executable.

00:26:04.550 --> 00:26:07.540
And we can also choose to execute
the computer's login hook script.

00:26:07.560 --> 00:26:08.540
So that was the first method.

00:26:08.740 --> 00:26:12.140
So really, the first two methods that I'm
showing aren't a case of either/or.

00:26:12.290 --> 00:26:13.620
You can define a local login hook.

00:26:13.680 --> 00:26:15.290
You can define a network login hook.

00:26:15.430 --> 00:26:17.450
And they will both run quite happily.

00:26:17.660 --> 00:26:20.910
You probably can't read that from here,
huh, maybe?

00:26:21.040 --> 00:26:23.340
There's a couple of caveats.

00:26:24.390 --> 00:26:28.050
If we're defining the MCX,
we need to tell the client machine how

00:26:28.110 --> 00:26:31.880
you're allowed to run MCX login scripts,
which is pretty simple.

00:26:31.880 --> 00:26:35.480
We just write to the login
window domain again and just say,

00:26:35.480 --> 00:26:37.380
yes, we want to enable login scripts.

00:26:40.270 --> 00:26:42.180
Then we need to do one
of two other things.

00:26:42.250 --> 00:26:45.420
We can either bind the client to
the directory using trusted binding,

00:26:45.640 --> 00:26:47.500
so not just setting it
up in directory access,

00:26:47.500 --> 00:26:50.240
but actually binding with
a username and password.

00:26:50.290 --> 00:26:52.690
Or alternatively,
we can modify the client so

00:26:52.690 --> 00:26:56.190
that it doesn't actually require
that sort of level of trust.

00:26:56.250 --> 00:26:59.820
So what we're doing here is we're
changing the MCX script trust

00:27:00.240 --> 00:27:02.100
level so that it'll trust anything.

00:27:02.140 --> 00:27:03.690
Obviously, this isn't quite as secure.

00:27:03.820 --> 00:27:05.660
You might have clients
connect to other directories.

00:27:05.700 --> 00:27:07.550
You might not want other stuff to run.

00:27:07.620 --> 00:27:11.640
So binding's probably the way to go,
but depending on your environment,

00:27:11.700 --> 00:27:13.280
that might not be the case.

00:27:14.420 --> 00:27:17.050
Finally, we've got the old-school method.

00:27:17.060 --> 00:27:19.690
The first two methods,
using defaults and using MCX,

00:27:19.800 --> 00:27:26.500
they only work in 10.3 and 10.4 and 10.5,
I assume.

00:27:26.530 --> 00:27:31.660
This method, however, works in 10.2,
but it didn't work in 10.4.0 or 10.4.1,

00:27:31.820 --> 00:27:34.020
but Apple fixed it again for 10.4.2.

00:27:34.210 --> 00:27:36.670
So I can actually think of many good
reasons you'd want to do it this way.

00:27:36.680 --> 00:27:40.510
Maybe if you're supporting 10.2,
you poor, poor, poor people,

00:27:40.510 --> 00:27:43.500
you might still want to have to do this.

00:27:43.530 --> 00:27:46.580
Edit, et cetera, TTYs,
change the console line,

00:27:46.780 --> 00:27:49.240
and just add the login hook.

00:27:49.920 --> 00:27:51.640
Again,
we're just adding the path to the hook.

00:27:51.640 --> 00:27:54.470
If you need more info about
doing things in this way,

00:27:54.470 --> 00:27:55.900
have a look at this
Apple Tech Info article.

00:27:59.750 --> 00:28:02.400
So what kind of stuff
do I do in Login Hooks?

00:28:02.440 --> 00:28:03.880
Well, this is what we're going
to run through today.

00:28:03.880 --> 00:28:07.080
We want to work out a way to tell
whether a user who's logging in is local,

00:28:07.080 --> 00:28:09.480
whether they're mobile,
whether they're a network user.

00:28:09.480 --> 00:28:12.230
We want to set up an alert
for local non-mobile users,

00:28:12.230 --> 00:28:15.640
because in my environment,
we try to avoid them completely.

00:28:15.640 --> 00:28:18.790
And if someone's logging in that way,
we want to try and work it out and go and

00:28:18.790 --> 00:28:20.560
migrate them to something more modern.

00:28:21.280 --> 00:28:24.990
For the mobile users,
we set up our SOE so that

00:28:24.990 --> 00:28:29.250
all user home directories are
sitting on a secondary partition,

00:28:29.540 --> 00:28:32.090
because we like to be able to just
blow away the whole system drive and

00:28:32.100 --> 00:28:33.480
not worry about backing up user data.

00:28:33.480 --> 00:28:36.720
The trouble with new mobile accounts
is they get created in users.

00:28:36.760 --> 00:28:40.680
So I'm going to go through how we
have a Login Hook that on first login

00:28:40.680 --> 00:28:45.030
for a mobile account moves the home
directory to the second partition.

00:28:45.380 --> 00:28:48.900
And I'm going to go through modifying
Kerberos environment for specific users.

00:28:49.070 --> 00:28:51.370
That'll make a bit more
sense when we get to it.

00:28:51.650 --> 00:28:53.130
For network users,
the only thing I'm going to

00:28:53.210 --> 00:28:56.380
cover is redirecting library
caches to the local hard drive,

00:28:56.450 --> 00:28:59.130
because we found that makes a really,
really big difference for performance

00:28:59.140 --> 00:29:00.780
on network home directories.

00:29:00.820 --> 00:29:04.490
And we're going to set up some
preferences for all of the user accounts.

00:29:06.030 --> 00:29:09.220
So, you know,
I wrote this in the last week or two,

00:29:09.220 --> 00:29:10.440
and it's already legacy code.

00:29:10.440 --> 00:29:14.580
This is how we tell whether
someone's a local user or not.

00:29:14.620 --> 00:29:19.500
And if you guys were at
Dave O'Rourke's talk yesterday,

00:29:19.500 --> 00:29:22.720
not that I'm unhappy about NetInfo going,
you know,

00:29:22.720 --> 00:29:23.940
I wouldn't want to give that impression.

00:29:23.940 --> 00:29:26.300
So we're going to have
to rewrite this script.

00:29:26.300 --> 00:29:27.980
This will have to use DSCL.

00:29:27.980 --> 00:29:29.280
The syntax is the same.

00:29:29.280 --> 00:29:30.980
Open up both main pages, look at them.

00:29:30.980 --> 00:29:31.880
It'll be simple.

00:29:31.880 --> 00:29:33.580
So we just have a look.

00:29:33.750 --> 00:29:35.540
Does the user exist in the local domain?

00:29:35.660 --> 00:29:37.080
What now gets called DSLocal.

00:29:37.080 --> 00:29:40.110
If they do, we're setting the variable
to say they're a local user.

00:29:41.720 --> 00:29:45.030
If they're a local user,
we go and see if they're a mobile user.

00:29:45.040 --> 00:29:49.500
Remember that mobile users are
just a specific type of local user.

00:29:49.520 --> 00:29:52.460
So again, we're using NRUtil, legacy.

00:29:52.470 --> 00:29:55.040
We're reading their
authentication authority.

00:29:55.040 --> 00:29:57.200
If you've ever looked
at a mobile user record,

00:29:57.200 --> 00:30:00.550
they have the local cached user in
their authentication authority so that

00:30:00.580 --> 00:30:02.300
the OS can treat them differently.

00:30:02.350 --> 00:30:04.060
So we're just looking for that string.

00:30:04.070 --> 00:30:08.000
If they're a mobile user,
the grep c command's going to return 1.

00:30:08.000 --> 00:30:09.540
If they're not, it'll return 0.

00:30:09.540 --> 00:30:12.430
And so now we've worked out
whether someone's local or mobile.

00:30:12.460 --> 00:30:15.000
If they're not local, they network.

00:30:16.890 --> 00:30:20.620
So, setting up an alert
for non-mobile logins,

00:30:20.710 --> 00:30:21.700
local non-mobile.

00:30:21.800 --> 00:30:23.210
It's pretty simple.

00:30:23.320 --> 00:30:27.800
We're just setting up an email script so
that we can alert the IT support staff.

00:30:27.950 --> 00:30:31.020
This is the user, this is the machine,
this was the date,

00:30:31.190 --> 00:30:33.370
and we can go and fix it.

00:30:34.730 --> 00:30:36.990
You'll see that I've
commented out of line there,

00:30:37.070 --> 00:30:38.760
kill all login window.

00:30:38.780 --> 00:30:40.980
That's kind of the brutal approach
I was talking about earlier.

00:30:40.980 --> 00:30:43.100
So as soon as you hit
that in your script,

00:30:43.170 --> 00:30:47.410
the login hook stops, everything stops,
you get a blue screen for five,

00:30:47.590 --> 00:30:50.740
ten seconds, and login window appears.

00:30:50.740 --> 00:30:53.940
You might want to actually let
the user know something's going

00:30:53.940 --> 00:30:57.300
on if you're going to go killing
their login window sessions.

00:30:57.300 --> 00:30:59.620
And I'll mention at the end,
but have a look at Growl,

00:30:59.680 --> 00:31:01.580
have a look at iHook,
both of them are really

00:31:01.580 --> 00:31:02.820
excellent products.

00:31:03.560 --> 00:31:06.910
pop up some kind of dialogue and just go,
no.

00:31:09.440 --> 00:31:12.390
So this is really dense looking,
but so you can stop

00:31:12.500 --> 00:31:14.230
copying it down about now.

00:31:14.240 --> 00:31:17.370
But it's pretty simple.

00:31:17.380 --> 00:31:20.540
If you go through it line by line,
it either consists of logger statements.

00:31:20.540 --> 00:31:22.560
Logger's a really useful
tool for scripting.

00:31:22.560 --> 00:31:26.330
If you guys aren't using it,
just by default, pass it a string and

00:31:26.550 --> 00:31:27.980
logs it to system log.

00:31:27.980 --> 00:31:30.440
You can set your different log
levels you want to log it for,

00:31:30.440 --> 00:31:33.030
so you can redirect things
to different log files.

00:31:33.040 --> 00:31:34.960
Incredibly useful.

00:31:34.960 --> 00:31:37.900
Again, we're using an IUTIL,
and we'll have to change that.

00:31:38.640 --> 00:31:41.430
So what we're doing is we're
going through mobile account.

00:31:41.440 --> 00:31:44.480
User logs in,
prompts them if you've set it that way.

00:31:44.480 --> 00:31:46.450
Do you want to create a mobile account?

00:31:46.480 --> 00:31:47.620
It logs in.

00:31:47.620 --> 00:31:51.240
The login hook goes and looks and says,
okay, so what's their home directory?

00:31:51.240 --> 00:31:53.320
It's set to users, whatever.

00:31:53.320 --> 00:31:55.100
We don't actually want it to be there.

00:31:55.100 --> 00:31:58.780
So we set up the system log to say
we're moving their home directory,

00:31:58.780 --> 00:32:01.780
make the new home directory,
set the permissions.

00:32:01.780 --> 00:32:05.270
All the magic kind of happens here.

00:32:05.280 --> 00:32:07.940
And apparently this might be going too.

00:32:07.980 --> 00:32:10.980
But at least we'll have
it for all of 10.4.

00:32:11.100 --> 00:32:12.980
And somehow, we're going to have to be
able to do this somehow.

00:32:12.980 --> 00:32:14.980
This is kind of an
undocumented tool by Apple.

00:32:14.980 --> 00:32:17.770
If you Google around for it,
you'll come across a couple of

00:32:17.770 --> 00:32:19.980
posts by people explaining what
all the different commands do.

00:32:19.980 --> 00:32:24.980
What we're using it here for is it'll
go create a mobile user with $1,

00:32:24.980 --> 00:32:27.980
which remember is the username
of the user logging in,

00:32:27.980 --> 00:32:29.980
with this home directory.

00:32:29.980 --> 00:32:33.650
With the mobile home's location,
again $1.

00:32:33.980 --> 00:32:36.980
You might wonder why I didn't just use an
IUTIL to just modify the home directory.

00:32:36.980 --> 00:32:37.980
I'm not.

00:32:37.980 --> 00:32:38.980
I'm using a new home directory.

00:32:38.980 --> 00:32:40.970
I kind of found I had
really mixed results.

00:32:40.980 --> 00:32:42.980
Some applications would pick
up the new home directory.

00:32:42.980 --> 00:32:44.970
Some applications would
pick up the old one.

00:32:44.980 --> 00:32:45.980
It seemed a bit flaky.

00:32:45.980 --> 00:32:47.980
And this seemed to work a lot better.

00:32:48.010 --> 00:32:50.980
Just overwrite the whole record
with a new home directory.

00:32:50.980 --> 00:32:54.980
And then flush the lookup dcache,
which is now another dead technology.

00:32:54.980 --> 00:32:56.980
But we're going to have
to flush caches somehow.

00:32:56.980 --> 00:32:57.970
Bye.

00:32:58.900 --> 00:33:00.200
So that's kind of pretty simple.

00:33:00.200 --> 00:33:02.510
We're just checking for the disk,
checking whether the

00:33:02.540 --> 00:33:04.460
directory is already there.

00:33:04.480 --> 00:33:07.800
In my environment where I run this,
I kind of have a few more dialogues.

00:33:07.800 --> 00:33:08.520
I use iHook.

00:33:08.660 --> 00:33:12.340
I sort of pop up a few things saying,
hey, I'm moving the home directory here.

00:33:12.340 --> 00:33:14.790
I might have a staff member
with 8 gig on the server.

00:33:14.870 --> 00:33:17.060
And they might be going, hey,
so this login's taking a while

00:33:17.610 --> 00:33:20.770
because it'll sync it all down,
copy it all to another partition.

00:33:21.060 --> 00:33:22.900
And we might want to get alerted.

00:33:23.000 --> 00:33:27.840
So say we do wipe the system drive,
the local mobile user account disappears.

00:33:27.840 --> 00:33:30.990
We want to make sure we don't create
a blank user folder and then overwrite

00:33:31.240 --> 00:33:33.710
all 8 gig of their data with it.

00:33:36.200 --> 00:33:37.500
We run Pro Tools in a lab.

00:33:37.500 --> 00:33:43.770
There must be some of you who do this.

00:33:46.820 --> 00:33:48.540
Apparently DigiDesign have now fixed it.

00:33:48.610 --> 00:33:54.740
The 7.0 R C 6 1 bug report
patch has been fixed.

00:33:54.740 --> 00:33:59.650
It wouldn't launch if your library
preferences was on a network volume.

00:33:59.720 --> 00:34:03.830
So we kind of had this big problem
deploying Pro Tools 7 in our labs,

00:34:03.830 --> 00:34:06.620
and we decided that we were just going
to create a dedicated mobile account

00:34:06.620 --> 00:34:10.480
and forget about the whole thing.

00:34:10.490 --> 00:34:12.760
Then we realized, you know,
we're in this really nice,

00:34:12.760 --> 00:34:14.450
Kerberized OS X server environment.

00:34:14.460 --> 00:34:17.290
My users log in and they
never put a password in again

00:34:17.290 --> 00:34:18.900
as far as file servers go.

00:34:18.900 --> 00:34:21.130
But they'd log in as Pro Tools and the
students would go and connect to their

00:34:21.130 --> 00:34:25.080
home directory server and suddenly be,
"Hey, why can't I get to my home folder?"

00:34:26.380 --> 00:34:29.380
And we were thinking of just sort
of getting rid of the whole Cobros

00:34:29.380 --> 00:34:33.670
ticket for the Pro Tools user,
but it ended up being easiest to just

00:34:33.670 --> 00:34:35.330
do this as part of our login hook.

00:34:35.340 --> 00:34:39.880
If the user's Pro Tools,
we trash their Cobros ticket as them.

00:34:39.880 --> 00:34:42.900
So remember, this is how you execute
a command as the user.

00:34:42.900 --> 00:34:46.780
Remember, everything's running with the
privileges of the local root user.

00:34:46.780 --> 00:34:49.420
If you actually want to
execute stuff as the user,

00:34:49.420 --> 00:34:53.480
sudo u $1, because the root user may
have no privileges whatsoever

00:34:53.480 --> 00:34:55.020
over your network file shares.

00:34:55.500 --> 00:34:57.800
So we use kdestroy,
trash their Cobros ticket,

00:34:57.800 --> 00:35:00.080
and then we rewrite
their Cobros preferences.

00:35:00.080 --> 00:35:02.440
So the Cobros dialog that pops up,
rather than saying

00:35:02.440 --> 00:35:05.260
Pro Tools where the username is,
says your student number here.

00:35:05.350 --> 00:35:08.220
So the students log in,
they get a Cobros ticket,

00:35:08.220 --> 00:35:11.880
it trashes the Cobros ticket,
rewrites their preferences,

00:35:11.880 --> 00:35:15.230
and then we have their home directory
SharePoint and their classwork resources

00:35:15.230 --> 00:35:16.780
set to automount on the desktop.

00:35:16.780 --> 00:35:18.990
And as soon as that happens,
pops up the Cobros dialog,

00:35:18.990 --> 00:35:21.340
they put in their student
number and their password,

00:35:21.340 --> 00:35:24.300
so they're logged into the local
machine as the Pro Tools user,

00:35:24.500 --> 00:35:26.480
but they kind of get all
the advantages of Cobros.

00:35:26.510 --> 00:35:29.880
Everything from that point on,
they are their student identity,

00:35:29.880 --> 00:35:31.580
which has worked pretty well for us.

00:35:31.660 --> 00:35:34.320
I'm not even actually sure if we'll go
back to network homes for Pro Tools,

00:35:34.320 --> 00:35:36.610
seeing as every major point
release seems to break it.

00:35:39.890 --> 00:35:41.220
This makes a really big difference.

00:35:41.220 --> 00:35:43.280
If you're not doing
this with network homes,

00:35:43.280 --> 00:35:45.190
you should try it out.

00:35:45.220 --> 00:35:46.920
If you can't go to
mobile home directories,

00:35:46.920 --> 00:35:49.420
this gives you a really
big boost in performance.

00:35:49.420 --> 00:35:53.140
Move your whole caches folder from
the network onto the local machine.

00:35:53.140 --> 00:35:54.860
It makes such a difference.

00:35:54.860 --> 00:35:57.970
All these tiny little read
and writes that are going on,

00:35:58.520 --> 00:36:02.680
Well, all we're doing is, again,
we're reading the--

00:36:02.680 --> 00:36:04.300
we're using DSCL here.

00:36:04.310 --> 00:36:06.300
We're reading their home directory path.

00:36:06.300 --> 00:36:15.710
We're making a local directory in
library caches username for their caches,

00:36:15.710 --> 00:36:15.710
getting rid of the one on the network,
and making a symbolic link between them.

00:36:18.700 --> 00:36:20.600
And then finally,
the last thing that we really

00:36:20.600 --> 00:36:23.610
do is put in all the preferences
for all those crappy apps.

00:36:23.790 --> 00:36:27.560
We keep a folder, Library Login Data,
on all our machines.

00:36:27.590 --> 00:36:30.600
We have preferences in there,
application support in there.

00:36:30.610 --> 00:36:33.240
And every time anyone logs in,
it copies all the stuff from

00:36:33.240 --> 00:36:34.880
there into their home folder.

00:36:34.890 --> 00:36:37.580
These tend to be pretty specific
apps that people aren't often

00:36:37.580 --> 00:36:39.320
running on their own machines.

00:36:39.330 --> 00:36:43.850
Or if they are, we're managing that as
part of our imaging system.

00:36:43.930 --> 00:36:46.270
Because this just copies over them,
you might want to actually think

00:36:46.270 --> 00:36:47.420
about backing up this stuff.

00:36:47.430 --> 00:36:50.100
And this is where a logout
hook would come into play.

00:36:50.100 --> 00:36:52.490
You'd log in,
back up any preferences that

00:36:52.500 --> 00:36:56.420
exist inside the Login Data folder
that are in their home folder,

00:36:56.420 --> 00:36:58.660
move them somewhere,
copy the login data ones in,

00:36:58.660 --> 00:37:01.320
and then on logout,
restore their preferences.

00:37:01.360 --> 00:37:03.820
We tend to not do that,
because we kind of like managing

00:37:03.820 --> 00:37:06.700
the preferences for all these apps.

00:37:06.740 --> 00:37:11.070
Well, maybe like is the wrong word.

00:37:12.130 --> 00:37:14.580
So why do I use Bash?

00:37:14.590 --> 00:37:16.160
I don't love Bash.

00:37:16.260 --> 00:37:18.490
So it's installed on all Macs.

00:37:18.570 --> 00:37:19.930
It's the default shell.

00:37:19.970 --> 00:37:21.630
It's good enough for these kind of tasks.

00:37:21.810 --> 00:37:23.630
Login hooks,
like if you've looked at this code,

00:37:23.700 --> 00:37:25.390
this isn't complicated stuff.

00:37:25.560 --> 00:37:27.770
This is the sort of stuff
you'd launch the terminal,

00:37:27.800 --> 00:37:29.520
you'd type a couple of commands.

00:37:29.530 --> 00:37:33.280
All you're doing is just whacking
those together in a shell script,

00:37:33.540 --> 00:37:36.300
putting the shebang at the top so that
you know what kind of script it is,

00:37:36.300 --> 00:37:38.040
and making it executable.

00:37:38.070 --> 00:37:40.160
This really isn't rocket science.

00:37:40.230 --> 00:37:41.860
So Joel said we weren't going
to teach you how to script,

00:37:41.860 --> 00:37:43.640
but that's it.

00:37:43.670 --> 00:37:48.600
Hash, $, bin, bash, put some commands in,
make it executable.

00:37:48.600 --> 00:37:51.550
You said we couldn't do it.

00:37:55.990 --> 00:37:59.900
I wouldn't use it for everything.

00:37:59.910 --> 00:38:02.160
The language you choose
is pretty unimportant,

00:38:02.380 --> 00:38:06.040
but I wouldn't sit there executing
SQL queries with MySQL from the

00:38:06.040 --> 00:38:11.040
command line and parsing it with sed
and grep and filtering it all out.

00:38:11.040 --> 00:38:15.120
If I was having to do SQL stuff,
raw LDAP stuff, anything like that,

00:38:15.120 --> 00:38:17.240
I'd move to PHP, Perl, or Python.

00:38:17.240 --> 00:38:19.860
Pick something with a rich
API in the stuff that you do.

00:38:19.930 --> 00:38:24.780
I use PHP a lot for that sort of
command line scripting these days.

00:38:24.780 --> 00:38:28.320
We have a Perl proponent coming up soon.

00:38:28.320 --> 00:38:31.810
But whatever you use,
whatever you're comfortable with,

00:38:31.810 --> 00:38:33.330
use it for login hooks.

00:38:35.160 --> 00:38:37.640
So as I said,
you only need a really basic knowledge.

00:38:37.640 --> 00:38:40.060
We're talking about the
simplest commands-- copy,

00:38:40.060 --> 00:38:43.820
move, link, sudo, defaults.

00:38:43.820 --> 00:38:45.380
These are not complicated things.

00:38:45.380 --> 00:38:48.380
You'll have a couple of
Apple-specific things you want to use.

00:38:48.380 --> 00:38:51.540
You're just gluing them all together,
and you're making a script.

00:38:51.570 --> 00:38:54.510
If you're performing repetitive
tasks to set up your environment,

00:38:54.690 --> 00:38:56.100
just use your login hooks.

00:38:56.100 --> 00:38:57.740
They really make things a lot simpler.

00:38:57.740 --> 00:39:00.150
I really think of them as
they fill in the gaps that

00:39:00.270 --> 00:39:02.790
the MCX model doesn't cover.

00:39:02.830 --> 00:39:05.690
So they're always there
in the background.

00:39:06.670 --> 00:39:09.300
As far as final tips,
remember your login hooks

00:39:09.300 --> 00:39:10.590
run as the local root user.

00:39:10.660 --> 00:39:13.060
If you start trying to do stuff
on your network home directories,

00:39:13.060 --> 00:39:14.600
that user has no privileges there.

00:39:14.600 --> 00:39:19.600
Use sudo u $1 to perform stuff
as the user who's logging in.

00:39:19.600 --> 00:39:21.530
Use logger a lot.

00:39:21.530 --> 00:39:24.100
Even use logger to redirect
all output from your scripts

00:39:24.230 --> 00:39:25.700
when you're developing them.

00:39:25.920 --> 00:39:28.400
Just dump it all somewhere.

00:39:28.400 --> 00:39:29.450
It'll make your life a lot easier.

00:39:29.930 --> 00:39:35.670
Learn how to use just DSCL these days to
retrieve information from your directory.

00:39:35.770 --> 00:39:38.870
Remember you can always use the
search domain with DSCL if you

00:39:38.950 --> 00:39:40.900
don't know where a user exists.

00:39:42.830 --> 00:39:45.940
It's really not that hard to use DSCL.

00:39:45.940 --> 00:39:46.810
Protect your scripts.

00:39:47.000 --> 00:39:47.990
This stuff runs as root.

00:39:48.060 --> 00:39:51.950
If you leave these scripts open
with privileges for anyone to edit,

00:39:52.060 --> 00:39:54.380
they can just add stuff to it
every time someone logs in that

00:39:54.380 --> 00:39:55.860
executes with root privileges.

00:39:55.860 --> 00:40:01.100
Give read-write execute
privileges to root.

00:40:01.100 --> 00:40:01.100
Don't let anyone else touch it.

00:40:01.210 --> 00:40:03.550
GUI Dialogues,
I really suggest you guys look at iHook

00:40:03.550 --> 00:40:05.670
and Growl if that's what you want to do.

00:40:05.850 --> 00:40:08.440
Growl's really,
really good for just notifications.

00:40:08.620 --> 00:40:09.670
They're nice and pretty.

00:40:09.770 --> 00:40:12.540
If you keep changing the styles,
your students actually

00:40:12.540 --> 00:40:13.990
might keep reading them.

00:40:15.100 --> 00:40:20.570
We find we have to rotate styles,
maybe every day, once a week.

00:40:20.610 --> 00:40:25.360
You need to move them around the screen,
move them when they click on them.

00:40:27.390 --> 00:40:29.130
iHook is really cool.

00:40:29.130 --> 00:40:30.660
If you want a little
bit more interactivity,

00:40:30.770 --> 00:40:32.400
iHook is really, really simple.

00:40:32.400 --> 00:40:34.490
Have a look at how simple it is.

00:40:34.580 --> 00:40:36.530
You just send echo text to it.

00:40:36.530 --> 00:40:39.520
It lets you create buttons, timers,
progress bars.

00:40:39.520 --> 00:40:43.460
Our labs are moving to 24 hours
in the next couple of months,

00:40:43.460 --> 00:40:45.690
so we're going to be using
iHook so that we can tell users,

00:40:45.690 --> 00:40:46.850
hey, get out of the lab now.

00:40:46.850 --> 00:40:47.580
It's imaging.

00:40:49.720 --> 00:40:50.700
But that's kind of it.

00:40:50.700 --> 00:40:52.820
Use whatever language you're
most comfortable with.

00:40:52.820 --> 00:40:55.840
Logging hooks are really easy to do.

00:40:55.840 --> 00:40:59.000
And now I'm going to
introduce Tim from Socap.

00:41:03.500 --> 00:41:07.480
All right, I'm Tim Perfit.

00:41:07.480 --> 00:41:11.120
I'm an SE in Southern California,
and I've made the career-limiting

00:41:11.120 --> 00:41:13.570
decision of talking about how
to make getting Windows really

00:41:13.580 --> 00:41:15.110
easy onto your Macintosh.

00:41:15.120 --> 00:41:17.580
So I'm kind of,
I have this sickness whenever

00:41:17.600 --> 00:41:20.600
I see a new technology,
I think not only how do I use it,

00:41:20.630 --> 00:41:23.600
but how do I script it,
and then how do I deploy it?

00:41:23.600 --> 00:41:27.060
So when I saw Boot Camp, I thought, wow,
I can play Microsoft Flight Simulator,

00:41:27.060 --> 00:41:29.600
and then I thought,
how does that work in the terminal?

00:41:29.700 --> 00:41:31.990
And then I thought,
how do I put it on a lab of 30 machines?

00:41:32.020 --> 00:41:34.660
So that's kind of what we're
going to walk through with this.

00:41:34.660 --> 00:41:38.000
That's what I spend my nights doing,
and I have a two-and-a-half-year-old.

00:41:38.050 --> 00:41:39.900
Okay, what this, I want to,
and we've already

00:41:39.910 --> 00:41:41.750
covered it a little bit,
but I want to talk about

00:41:41.750 --> 00:41:43.570
what this session will not
make you into when you leave.

00:41:43.580 --> 00:41:46.740
You will not become Larry Perl,
the creator of Perl.

00:41:46.740 --> 00:41:49.300
They'll be able to buy his shirt.

00:41:49.300 --> 00:41:50.920
I have one kind of like that.

00:41:50.960 --> 00:41:54.190
So don't expect to actually
be him when you leave here.

00:41:54.200 --> 00:41:57.370
But what we will talk about is actually
how to go ahead and look at the

00:41:57.440 --> 00:41:59.680
interesting pieces to integrate between.

00:41:59.680 --> 00:42:02.180
Perl and AppleScript Studio.

00:42:02.180 --> 00:42:04.640
So we'll talk about a
couple of technologies.

00:42:04.640 --> 00:42:08.990
I use signal catching and PIDs
to be able to communicate between

00:42:09.020 --> 00:42:11.320
AppleScript Studio and Perl.

00:42:11.320 --> 00:42:16.670
Perl doesn't have, how do you say it,
a rich API to talk with Shell Scripts,

00:42:16.670 --> 00:42:19.790
so we have to do some
contortions to do it.

00:42:19.840 --> 00:42:22.390
We're talking about some
parsing options to be able to

00:42:22.390 --> 00:42:24.930
go through and get the output,
as well as some wrapping

00:42:25.040 --> 00:42:27.410
in AppleScript Studio,
so we can make a nice GUI app

00:42:27.410 --> 00:42:28.750
at the end of all this.

00:42:30.350 --> 00:42:32.200
Alright,
so let's first talk about why Perl.

00:42:32.200 --> 00:42:35.720
I know that Nigel has talked about how
you should love all languages equally.

00:42:35.720 --> 00:42:37.980
Well,
I chose Perl for some specific reasons.

00:42:37.980 --> 00:42:39.020
I want to parse things.

00:42:39.020 --> 00:42:40.580
It has great regular expressions.

00:42:40.580 --> 00:42:42.770
I don't do a ton of that,
but I knew that going forward,

00:42:42.880 --> 00:42:45.280
if I'm going to run a command,
I want to be able to pull the pieces out.

00:42:45.310 --> 00:42:47.870
It has signal catching and
allows me to be able to,

00:42:47.870 --> 00:42:50.630
well, we'll talk more about
signal catching later,

00:42:50.690 --> 00:42:53.480
but it's important that
it's part of the language.

00:42:54.380 --> 00:42:56.810
Modules,
I don't necessarily like to code a lot.

00:42:56.810 --> 00:42:59.380
I like to just have a module
that does stuff for me.

00:42:59.380 --> 00:43:02.180
I didn't know what modules I was
going to use from the get-go,

00:43:02.180 --> 00:43:05.050
but I knew that Perl pretty much has
a gazillion modules and I could do

00:43:05.050 --> 00:43:06.940
pretty much everything that I wanted to.

00:43:06.940 --> 00:43:10.420
And it's installed on Mac OS X,
so I didn't want to have to bundle Perl

00:43:10.430 --> 00:43:13.440
inside an AppleScript Studio bundle,
which would make my

00:43:13.440 --> 00:43:15.130
application pretty huge.

00:43:15.140 --> 00:43:19.520
So it's installed on
every Mac OS X deployment.

00:43:19.520 --> 00:43:23.660
I don't really want to get into religious
wars about whether what's better.

00:43:23.940 --> 00:43:25.940
I don't want to get into
this PHP or Ruby or whatever,

00:43:25.940 --> 00:43:28.500
but I think the one thing we
can agree on is that every other

00:43:28.500 --> 00:43:32.700
scripting language is worse than Perl,
so we should go ahead and... Alright,

00:43:32.700 --> 00:43:38.340
so we actually talk about what,
before we look at the script,

00:43:38.340 --> 00:43:41.540
let's talk about what happens
when you install BootCamp.

00:43:41.540 --> 00:43:44.690
So when you have this nice
journaled HFS+ volume,

00:43:44.820 --> 00:43:49.140
represented by this upstanding
young citizen that's sitting

00:43:49.140 --> 00:43:53.500
there computing very nicely,
and you go ahead and run BootCamp,

00:43:53.500 --> 00:43:53.500
and BootCamp partitions off your drive.

00:43:53.500 --> 00:43:58.090
It puts an MS-DOS partition on it,
which is represented,

00:43:58.100 --> 00:44:00.950
and then NTFS is put on there,
represented by this

00:44:00.950 --> 00:44:03.500
kind of shady looking,
geeky sort of guy.

00:44:03.590 --> 00:44:07.800
And then NTFS has this nice thing
where it has to write down where it's

00:44:07.800 --> 00:44:10.500
located on the drive in its partition.

00:44:10.640 --> 00:44:13.580
And that's not just fun to know,
but it is required to

00:44:13.620 --> 00:44:16.500
actually boot Windows,
because otherwise it won't start up,

00:44:16.500 --> 00:44:19.500
and you get this black screen
with a little flashing cursor.

00:44:19.500 --> 00:44:23.060
And you have to do this whole
master boot record junk.

00:44:23.060 --> 00:44:26.060
Because BootCamp puts
the whole BIOS emulation,

00:44:26.060 --> 00:44:29.040
and so you've got to replicate
that in order to boot up Windows.

00:44:29.060 --> 00:44:30.630
So that's what we've got
to kind of replicate,

00:44:30.630 --> 00:44:33.060
and that's what we've got to kind
of understand to be able to do this.

00:44:33.060 --> 00:44:34.780
So before we actually
go ahead and script it,

00:44:34.780 --> 00:44:37.060
let's actually see how do we
do it from the command line.

00:44:37.060 --> 00:44:39.060
How do we actually script it?

00:44:39.060 --> 00:44:40.950
Or how do we actually run it?

00:44:41.060 --> 00:44:44.030
I'm going to do this really fast,
I'm going to do it in 10 seconds.

00:44:44.060 --> 00:44:45.920
Alright, I don't want to,
it's not important.

00:44:46.080 --> 00:44:49.000
So the first thing that we do is
we actually take your DiskUtil,

00:44:49.000 --> 00:44:51.810
resize the volume,
we take up the master boot record,

00:44:51.820 --> 00:44:52.610
we clone it.

00:44:52.670 --> 00:44:56.620
Then we restore it by unzipping it,
reversing some crazy hex numbers,

00:44:56.620 --> 00:44:59.610
putting it to NPS, and then marking the
partition as bootable.

00:44:59.620 --> 00:45:01.760
Not important,
I'm going to post the script,

00:45:01.760 --> 00:45:02.620
you can see it.

00:45:02.620 --> 00:45:04.620
But this is kind of the lines
that if you wanted to go up,

00:45:04.620 --> 00:45:08.620
and instead of running that really
difficult BootCamp application,

00:45:08.620 --> 00:45:10.620
you could run these easy
commands on the command line,

00:45:10.620 --> 00:45:12.620
and it would be much easier.

00:45:12.620 --> 00:45:16.600
In fact, Brian James probably could write
a nice Ajax wrapper around it

00:45:16.720 --> 00:45:18.620
to be able to do these scripts.

00:45:18.620 --> 00:45:20.620
But instead, I chose Perl.

00:45:20.620 --> 00:45:22.180
Before we get that,
I want to get to the next part.

00:45:22.180 --> 00:45:24.060
I want to give a warning for my mom.

00:45:24.230 --> 00:45:28.180
So she told me when I got here that
anytime you're programming in Perl,

00:45:28.180 --> 00:45:31.180
make sure you use the
-w in the shebang line.

00:45:31.180 --> 00:45:34.800
I'm being a little flippant,
but it's important because Perl will

00:45:34.810 --> 00:45:40.180
ignore things like if you're using a
variable that has not been defined yet,

00:45:40.180 --> 00:45:43.580
or not been populated yet,
and it'll cause you some

00:45:43.610 --> 00:45:45.040
debugging nightmares.

00:45:45.180 --> 00:45:47.150
So anytime you use this first
line of your script that tells

00:45:47.150 --> 00:45:49.320
where the interpreter is,
just put -w on there,

00:45:49.320 --> 00:45:51.170
and you'll make my mom happy.

00:45:51.210 --> 00:45:51.720
So that's important.

00:45:51.740 --> 00:45:53.730
Alright, so let's get to the script.

00:45:53.740 --> 00:45:55.720
Let's see what actually happens.

00:45:55.840 --> 00:45:57.740
So the first part is
when we actually run it.

00:45:57.740 --> 00:45:59.730
So this is the completed script.

00:45:59.770 --> 00:46:01.680
I called it WinClone.

00:46:01.770 --> 00:46:04.150
And that's if you do a Google search,
you'll actually find

00:46:04.150 --> 00:46:06.330
there's a wrapper around it,
as well as the Perl scripts

00:46:06.330 --> 00:46:07.740
contained within it.

00:46:07.870 --> 00:46:10.180
And the first thing we want to do
in the Perl script is go through and

00:46:10.180 --> 00:46:11.740
parse out the command line options.

00:46:11.740 --> 00:46:14.420
So the worst way to do this, I mean,
I've seen this,

00:46:14.430 --> 00:46:15.740
and a lot of computer science
students will do this,

00:46:15.740 --> 00:46:18.740
is they'll try and parse out
all your different options,

00:46:18.740 --> 00:46:20.730
and they'll do is they'll say, "Okay,
the first thing is a space.

00:46:20.740 --> 00:46:21.290
We don't need that.

00:46:21.300 --> 00:46:22.300
Then a dash.

00:46:22.300 --> 00:46:24.300
Oh, it's an option." And then
it gets the letter.

00:46:24.300 --> 00:46:25.300
It's a lot of work.

00:46:25.300 --> 00:46:28.390
If you don't see it all,
there's a get-op library function

00:46:28.390 --> 00:46:30.220
that allows you to do this loop.

00:46:30.300 --> 00:46:31.730
But Perl,
one of the cool things about all

00:46:31.730 --> 00:46:35.300
these modules is they're constantly
trying to find easier ways to do it.

00:46:35.300 --> 00:46:38.560
So within this,
I can specify -- so for this example,

00:46:38.560 --> 00:46:39.300
I have -v.

00:46:39.300 --> 00:46:42.300
So that's a common one for verboseness.

00:46:42.300 --> 00:46:46.300
And what this does is just basically
say if the user has put -v on it,

00:46:46.330 --> 00:46:49.300
set this flag in the verbose variable.

00:46:49.300 --> 00:46:50.230
Okay, so it's very simple to do.

00:46:50.300 --> 00:46:50.860
I don't have to loop around it.

00:46:50.860 --> 00:46:52.860
It's basically one line, and it's done.

00:46:52.860 --> 00:46:54.860
We can pass it strings as well.

00:46:54.860 --> 00:46:56.780
So this one example is
the source partition.

00:46:56.860 --> 00:46:58.550
So with one line,
I can basically take what

00:46:58.550 --> 00:47:00.830
the source partition is
specified on the command line,

00:47:00.900 --> 00:47:02.860
populate this variable, and move on.

00:47:02.860 --> 00:47:08.800
Now, the other important thing after this
is to populate your defaults afterwards

00:47:08.900 --> 00:47:12.130
because it doesn't touch any of the
variables that it doesn't know about,

00:47:12.130 --> 00:47:12.800
obviously.

00:47:12.860 --> 00:47:13.750
So you want to set that.

00:47:13.870 --> 00:47:17.070
Bootcamp's really nice because it always
does it in kind of the same place,

00:47:17.070 --> 00:47:20.420
and things are pretty standard.

00:47:20.420 --> 00:47:22.420
So you can see that it's kind of in
the same place as the source partition.

00:47:22.440 --> 00:47:24.400
So that's kind of when
we start processing it.

00:47:24.440 --> 00:47:26.620
So let's actually talk about
when we have a GUI wrapper and

00:47:26.620 --> 00:47:28.420
how to integrate between it.

00:47:28.420 --> 00:47:33.080
So we have an AppleScript app,
or an AppleScript Studio app.

00:47:33.410 --> 00:47:34.690
That's the button I'm
not supposed to press?

00:47:34.690 --> 00:47:35.200
Okay.

00:47:35.200 --> 00:47:36.820
AppleScript Studio app.

00:47:36.840 --> 00:47:39.560
There's another one on here
I'm not supposed to press,

00:47:39.570 --> 00:47:40.340
so I won't do that either.

00:47:40.340 --> 00:47:42.440
It calls a Perl script,
and this Perl script goes

00:47:42.520 --> 00:47:45.240
ahead and it spawns off all
these command line utilities.

00:47:45.240 --> 00:47:48.340
Disk util,
I use a bunch of open source tools, NTFS,

00:47:48.390 --> 00:47:51.210
clone, NTFS, label, those kind of things.

00:47:51.240 --> 00:47:53.960
And then those do funky
things to your hard drive,

00:47:54.070 --> 00:47:57.550
like reformat or partitioning
it and copying file systems.

00:47:57.560 --> 00:47:58.250
And that's great.

00:47:58.250 --> 00:47:59.940
I mean, that's like,
you saw the lines of code.

00:47:59.940 --> 00:48:01.150
There's eight lines of code.

00:48:01.160 --> 00:48:02.660
So the Perl script is trivial.

00:48:02.660 --> 00:48:05.440
But then what happens if the user
clicks cancel in the middle of this?

00:48:05.530 --> 00:48:05.950
What do we do?

00:48:05.960 --> 00:48:09.160
Well, okay, do we stop the Perl script?

00:48:09.160 --> 00:48:10.080
That sounds like a good thing.

00:48:10.080 --> 00:48:10.900
We just kill out the Perl script.

00:48:10.900 --> 00:48:13.780
But what happens if it's in the
middle of repartitioning your disk?

00:48:13.820 --> 00:48:15.510
Your disk is unmounted.

00:48:15.510 --> 00:48:17.320
It's moving data around.

00:48:17.320 --> 00:48:18.900
You don't really want to
kill off the Perl script.

00:48:18.900 --> 00:48:19.520
So that's fine.

00:48:19.550 --> 00:48:20.460
Let's leave it alone.

00:48:20.460 --> 00:48:23.940
Well, if we leave it alone,
then it'll continue cloning your drive,

00:48:23.940 --> 00:48:28.010
and your CPU usage will go up
to 100%, 200%, 400%. And then

00:48:28.180 --> 00:48:29.600
you'll clone it again.

00:48:29.600 --> 00:48:31.140
And you got two clones.

00:48:31.140 --> 00:48:32.850
And then you'll have the
same type of operation.

00:48:32.960 --> 00:48:34.400
You'll have the same type of operation.

00:48:34.460 --> 00:48:35.840
And then you'll have the
same type of operation.

00:48:35.840 --> 00:48:37.290
And then you'll have the
same type of operation.

00:48:37.470 --> 00:48:39.580
So we want to be able to
do some sanity with this.

00:48:39.580 --> 00:48:42.460
So be able to have the user feedback
and do things that make sense.

00:48:42.460 --> 00:48:45.480
But as you can see,
these arrows are shaded.

00:48:45.480 --> 00:48:47.640
That means there's no direct
connection between them.

00:48:47.640 --> 00:48:48.760
We're not controlling them.

00:48:48.820 --> 00:48:52.880
AppleScript Studio has this kind
of laissez-faire attitude towards

00:48:52.890 --> 00:48:55.060
dealing with command line scripts.

00:48:55.100 --> 00:48:56.640
So let's actually look how we do it.

00:48:56.690 --> 00:48:58.880
So the way I did it is
with signal catching.

00:48:58.940 --> 00:49:00.900
So let's talk a little
bit about death and dying,

00:49:00.900 --> 00:49:05.580
which you didn't think today you'd
call a little counseling session.

00:49:05.600 --> 00:49:08.040
So we have this Perl script,
and the user clicks cancel.

00:49:08.040 --> 00:49:10.230
We wanted to have some way
for the AppleScript Studio to

00:49:10.240 --> 00:49:12.360
communicate and say,
OK, I want you to go away.

00:49:12.360 --> 00:49:13.140
I want you to die.

00:49:13.140 --> 00:49:16.740
I want the parent to kill off the child,
the grandparents to kill off the parents.

00:49:16.740 --> 00:49:20.190
Let's have a little nasty
death and dying type thing.

00:49:20.200 --> 00:49:24.440
So the simple way to do it is just
have the AppleScript Studio app

00:49:24.480 --> 00:49:25.440
send it a signal.

00:49:25.490 --> 00:49:27.140
Signals are all the rage in Unix.

00:49:27.140 --> 00:49:28.560
You send it a termination signal.

00:49:28.560 --> 00:49:29.480
You hit Control-C.

00:49:29.480 --> 00:49:31.290
You do an interrupt,
those kind of things.

00:49:31.500 --> 00:49:34.340
But in Perl,
normally what it does is it just dies.

00:49:34.480 --> 00:49:35.440
But we want to catch that.

00:49:35.440 --> 00:49:38.760
And so these first two lines, basically,
we have sigterm.

00:49:38.760 --> 00:49:42.610
It'll catch the termination signal,
which is--

00:49:42.810 --> 00:49:45.430
and I'm sorry,
the two of the termination signals as

00:49:45.470 --> 00:49:49.560
well as the interrupt signal and it'll
set that to call the catch function.

00:49:49.560 --> 00:49:53.390
So anytime, no matter what you're doing,
when the signal gets caught,

00:49:53.390 --> 00:49:55.140
it'll go ahead and run the subroutine.

00:49:55.140 --> 00:49:57.640
So term is usually sent
when you do a kill command,

00:49:57.650 --> 00:50:00.380
but then if somebody runs
this from a command line,

00:50:00.380 --> 00:50:02.720
they'll do a control C,
that's the interrupt signal.

00:50:02.720 --> 00:50:04.910
I don't deal with HUP,
so there is a way to

00:50:04.910 --> 00:50:07.250
get around my script,
but if you're doing that,

00:50:07.250 --> 00:50:09.730
then you already know about it
and you can do something else.

00:50:11.820 --> 00:50:14.500
The next one is a really important
piece and this I thought was really

00:50:14.500 --> 00:50:18.580
interesting because if you don't
want to have to keep track of

00:50:18.580 --> 00:50:21.100
what current scripts are running,
right?

00:50:21.100 --> 00:50:22.640
The Perl scripts is
running other scripts,

00:50:22.640 --> 00:50:25.370
but a good way to do it is to put
them in their own process group.

00:50:25.500 --> 00:50:28.860
So Perl has this great
command set process group,

00:50:28.860 --> 00:50:29.910
set P group.

00:50:29.920 --> 00:50:32.080
I don't know the cool
UNIX way to say that,

00:50:32.090 --> 00:50:34.490
set per group, set P group, I don't know.

00:50:34.520 --> 00:50:37.180
But anyways,
Joel probably has one that says that

00:50:37.250 --> 00:50:40.380
he was sitting there correcting me
on all the different UNIX commands,

00:50:40.380 --> 00:50:44.930
but... What this does, and this is,
I love saying this because it

00:50:44.930 --> 00:50:46.180
sounds so cool at dinner parties.

00:50:46.180 --> 00:50:49.900
When Perl spawns off
another UNIX process,

00:50:49.900 --> 00:50:54.790
it will set the process group of
that process to the process group,

00:50:54.790 --> 00:50:57.590
the process ID of the Perl script.

00:50:57.680 --> 00:50:59.930
Okay, I didn't even understand that.

00:51:00.030 --> 00:51:03.250
Okay, so anything it spawns off,
so it spawns off,

00:51:03.280 --> 00:51:07.180
let's say it spawns off DiskUtil,
it'll set the process group

00:51:07.190 --> 00:51:10.550
to the process ID of the Perl
script that's its parent.

00:51:10.940 --> 00:51:12.300
And so that's kind of cool.

00:51:12.300 --> 00:51:14.960
Anything I spawn off,
I can now easily keep track of,

00:51:15.040 --> 00:51:16.100
and I can kill off.

00:51:16.180 --> 00:51:18.380
So in my catch,
there's two different ways.

00:51:18.380 --> 00:51:22.560
If I'm doing a critical operation,
I do $CS, a critical section,

00:51:22.640 --> 00:51:23.480
I don't do anything.

00:51:23.480 --> 00:51:26.180
I basically say, "Oh, okay,
let's just set a global variable

00:51:26.180 --> 00:51:28.820
and move along." And whenever
this critical operation is done,

00:51:28.900 --> 00:51:30.800
it can go ahead and clean up
and figure out what to do.

00:51:30.880 --> 00:51:34.110
If we're not in a critical section,
it can go ahead and just kill off it.

00:51:34.180 --> 00:51:37.050
And I could keep track of all
these little UNIX utilities,

00:51:37.120 --> 00:51:39.990
but the better way to do is now
that since the process group is set,

00:51:40.060 --> 00:51:43.840
I can just send... I can send the
kill signal to the negative of

00:51:43.840 --> 00:51:46.430
the process ID of the Perl script.

00:51:46.570 --> 00:51:49.040
Process ID of the Perl script is $$.

00:51:49.060 --> 00:51:50.890
If you put a negative
sign in front of it,

00:51:50.960 --> 00:51:53.040
it makes it to the process group.

00:51:53.090 --> 00:51:54.080
And that's what's great about Perl.

00:51:54.080 --> 00:51:54.750
It's simple.

00:51:54.760 --> 00:51:55.550
I mean, you can just read it.

00:51:55.560 --> 00:51:58.180
It's a very legible language.

00:52:00.810 --> 00:52:02.650
Alright,
so let's talk a little bit about,

00:52:02.650 --> 00:52:05.930
so now we actually want to be able to
communicate back to the AppleScript.

00:52:05.970 --> 00:52:08.890
So the AppleScript communicates
to us by sending us kill signals.

00:52:08.990 --> 00:52:10.620
We want to talk back to our parents.

00:52:10.620 --> 00:52:12.390
And the way we do that
is I use PID files.

00:52:12.390 --> 00:52:14.330
So if you ever go into
var run on your system,

00:52:14.330 --> 00:52:16.190
you'll sign all these little PID files.

00:52:16.190 --> 00:52:19.760
And all they are is it's saying that this
daemon's running with this process ID.

00:52:19.840 --> 00:52:21.910
And a lot of Unix daemons
use it to communicate.

00:52:21.910 --> 00:52:23.170
So we communicate with it.

00:52:23.170 --> 00:52:25.870
And you can see here it has the
echo dollar sign dollar sign.

00:52:25.870 --> 00:52:27.930
Again,
that's the process ID of the parent.

00:52:27.930 --> 00:52:30.680
And it shoves us into the process ID.

00:52:31.750 --> 00:52:34.870
And I put it in var run because
that's where it's supposed to be.

00:52:34.880 --> 00:52:36.880
And I called it winclone.pid.

00:52:36.940 --> 00:52:40.240
The cool thing about this now is
that the AppleScript Studio app can

00:52:40.240 --> 00:52:43.260
just look in that directory and say,
is it running?

00:52:43.280 --> 00:52:46.640
And if it is running,
it can find out what the process ID is.

00:52:46.690 --> 00:52:49.470
So it doesn't have to go through
and like look at the process table

00:52:49.470 --> 00:52:52.090
and figure out what process ID I am.

00:52:52.120 --> 00:52:55.220
It communicates that back
just to this one file.

00:52:55.380 --> 00:52:58.190
And so once we actually want
to clean all this mess up,

00:52:58.190 --> 00:53:01.800
we basically do some operations,
then we remove that PID file.

00:53:01.800 --> 00:53:03.460
And as soon as that
PID file gets removed,

00:53:03.500 --> 00:53:06.430
the AppleScript Studio goes, oh,
it must be done.

00:53:06.440 --> 00:53:08.630
So then it does it.

00:53:08.670 --> 00:53:10.960
The nice thing about var
run is that when you reboot,

00:53:10.960 --> 00:53:11.820
it clears it out.

00:53:11.860 --> 00:53:13.730
So you don't have to worry
about stale PID files.

00:53:13.750 --> 00:53:17.160
And so that's probably why if
you've ever used an app before that

00:53:17.230 --> 00:53:20.590
wasn't wrote as awesomely as my app,
and it leaves this PID file

00:53:20.590 --> 00:53:22.700
when it's not supposed to,
like somebody force quits it,

00:53:22.740 --> 00:53:25.250
and it doesn't work, and you reboot,
then it all works great.

00:53:25.260 --> 00:53:28.190
Well, that's one of the reasons
it clears the PID files out.

00:53:28.220 --> 00:53:32.900
So now let's talk about wrapping
in PerlScript and AppleScript.

00:53:32.900 --> 00:53:34.080
AppleScript.

00:53:34.080 --> 00:53:36.160
Ah, ah, ah.

00:53:36.160 --> 00:53:37.170
AppleScript.

00:53:37.200 --> 00:53:38.580
AppleScript.

00:53:38.580 --> 00:53:39.820
Yahoo, Yahoo.

00:53:39.820 --> 00:53:41.800
All right.

00:53:41.800 --> 00:53:46.190
So GarageBand is a great program,
but it's not for everybody,

00:53:46.290 --> 00:53:47.540
as you can see.

00:53:50.700 --> 00:56:25.300
[Transcript missing]

00:56:25.550 --> 00:56:27.400
And finally,
if we want to actually run this,

00:56:27.420 --> 00:56:30.040
we use the do shell script
with administrator privileges.

00:56:30.040 --> 00:56:31.980
And this is really cool
because if you do this,

00:56:32.250 --> 00:56:35.220
it will prompt the user for
their username and password,

00:56:35.350 --> 00:56:39.210
and then it'll cache it for whatever
is set in your Etsy authorization,

00:56:39.470 --> 00:56:41.730
which is usually, I believe,
five minutes.

00:56:41.790 --> 00:56:44.060
So that means if you're
running a series of,

00:56:44.130 --> 00:56:47.580
like I am, six or seven commands,
the user puts their username

00:56:47.580 --> 00:56:50.600
and password in once,
and then it'll go ahead and just be

00:56:50.600 --> 00:56:55.220
able to run these scripts as root,
basically, or administrator privileges.

00:56:55.530 --> 00:56:58.160
All right, so let's look at how do we get
out from Apple Script Studio.

00:56:58.160 --> 00:57:01.390
So now we have this Perl script running,
and I talked about on the other end

00:57:01.390 --> 00:57:04.040
when the Perl script gets killed,
it goes to this catch routine.

00:57:04.040 --> 00:57:06.880
What do we do in Apple Script Studio when
the user clicks cancel?

00:57:06.880 --> 00:57:09.120
Well,
we just send it the unix command kill,

00:57:09.120 --> 00:57:10.840
and we send it the dash term signal.

00:57:10.840 --> 00:57:13.300
Not necessarily needed,
but it's kind of explicit,

00:57:13.320 --> 00:57:14.220
so it's nice to see.

00:57:14.220 --> 00:57:17.360
And we have to know the
process ID of the Perl script.

00:57:17.380 --> 00:57:21.420
Well, you could do all this set and
grep and awk of the process table,

00:57:21.420 --> 00:57:24.400
or you could remember that in
var run we had that pid file,

00:57:24.780 --> 00:57:27.230
and all we need to do is find out
what the process ID is in there.

00:57:27.240 --> 00:57:30.560
Of course, you want to wrap this code
with does the pid file exist.

00:57:30.580 --> 00:57:34.720
So the pid file exists, you just grab it,
the back text basically takes the result,

00:57:34.720 --> 00:57:37.440
puts it in this command,
so we have kill dash term some number.

00:57:37.440 --> 00:57:39.710
And we run it with administrative
privileges because our Perl

00:57:39.730 --> 00:57:40.840
scripts can be running as root.

00:57:42.300 --> 00:57:44.480
So this will do that,
and then the Perl script won't

00:57:44.480 --> 00:57:46.940
necessarily die right away,
because it might be in the middle of

00:57:46.940 --> 00:57:50.530
a critical operation that might take
30 seconds to 5 minutes to clean up.

00:57:50.640 --> 00:57:54.460
So what we want to do is set a state,
set some global variable so

00:57:54.470 --> 00:57:56.260
we know that it's quitting.

00:57:56.260 --> 00:57:59.040
Then we have to do something with the UI,
because how many people have had

00:57:59.050 --> 00:58:01.000
an app where they have cancel,
and they click cancel,

00:58:01.000 --> 00:58:01.690
and nothing happens?

00:58:01.700 --> 00:58:03.240
They click cancel, cancel, cancel,
cancel.

00:58:03.240 --> 00:58:05.270
What's that, mail app?

00:58:05.370 --> 00:58:06.040
Okay, thanks.

00:58:06.040 --> 00:58:08.240
No comment, no comment.

00:58:08.240 --> 00:58:09.780
It's all fixed in Leopard.

00:58:09.780 --> 00:58:10.790
Everything's fixed in Leopard.

00:58:14.940 --> 00:58:19.960
and then so you want to set the title
of the button to change it to give the

00:58:19.970 --> 00:58:22.850
state and then make it disabled so you
sit there you don't click on it get your

00:58:22.850 --> 00:58:26.040
credit card charged 15 times because
you press the button more than once.

00:58:26.040 --> 00:58:30.990
So give the user feedback but then
you're left with this state that's

00:58:31.050 --> 00:58:34.130
kind of stopping kind of starting
and what we want to do is be able

00:58:34.130 --> 00:58:37.950
to go back and figure out when do we
clean up and the way we do that is an

00:58:38.010 --> 00:58:39.960
idle handler in AppleScript Studio.

00:58:39.960 --> 00:58:43.490
So there's a great handler in
AppleScript Studio called idle that

00:58:43.490 --> 00:58:47.830
gets called whenever it's idle,
whenever it's not doing anything.

00:58:47.840 --> 00:58:51.190
And you return at the end of it
how much how many seconds before

00:58:51.190 --> 00:58:54.400
you want it to be called again
or that's not technically true.

00:58:54.450 --> 00:58:57.240
Don't call me before this
many seconds have passed.

00:58:57.240 --> 00:58:59.140
So you can't guarantee it'll
be the amount of time but you

00:58:59.140 --> 00:59:00.240
know I'll do it occasionally.

00:59:00.240 --> 00:59:02.370
So it's great for
cleanup tasks like this.

00:59:02.380 --> 00:59:06.480
So what we do is we ask the system
events does this file exist?

00:59:06.480 --> 00:59:07.480
This is our PID file.

00:59:07.480 --> 00:59:09.960
If the file exists we know that
our Perl script is still running.

00:59:09.960 --> 00:59:13.500
If the Perl script or if the
PID file disappears we know that we

00:59:13.500 --> 00:59:14.940
can go ahead and do some cleanup.

00:59:14.960 --> 00:59:16.960
So this idle handle will do it for us.

00:59:16.960 --> 00:59:18.960
And so we don't really have to
have any tight coupling of these

00:59:18.960 --> 00:59:20.840
the GUI with the command line.

00:59:20.840 --> 00:59:23.420
It just needs to look and
see if a file exists on disk.
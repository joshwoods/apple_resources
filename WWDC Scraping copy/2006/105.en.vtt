WEBVTT

00:00:10.270 --> 00:00:10.790
Hello.

00:00:10.940 --> 00:00:15.310
Welcome to the HIToolbox
State of the Union session.

00:00:15.450 --> 00:00:16.340
My name is Guy Fullerton.

00:00:16.340 --> 00:00:19.250
As they said, I'm the manager of the
high-level toolbox team,

00:00:19.250 --> 00:00:23.040
and I'll be joined a little
bit later on by Eric Schlegel,

00:00:23.040 --> 00:00:27.860
one of our engineers that I'm sure
you've seen over email a bunch.

00:00:27.960 --> 00:00:32.580
So the reason I'm up here first is I want
to talk a little bit about the future

00:00:32.580 --> 00:00:37.660
of Carbon UI programming on Mac OS X,
specifically the HIToolbox APIs.

00:00:37.660 --> 00:00:42.130
In short,
the future of the HIToolbox is Cocoa,

00:00:42.130 --> 00:00:43.790
integration.

00:00:44.610 --> 00:00:48.880
We are adding a lot of features
to Leopard to make HIToolbox

00:00:48.880 --> 00:00:52.750
and the Carbon interface
layers play well with Cocoa.

00:00:54.260 --> 00:01:00.280
Our plan is to put no new large-scale
HIToolbox features in place where

00:01:00.280 --> 00:01:03.200
those features already exist in Cocoa.

00:01:03.200 --> 00:01:08.170
What we want Carbon developers to do
is start using the various Cocoa views

00:01:08.450 --> 00:01:12.010
in their Carbon applications,
start using the various Cocoa windows

00:01:12.010 --> 00:01:14.100
in their Carbon applications,
and so on.

00:01:14.250 --> 00:01:17.940
So my team is focusing most of
our energy on doing things like

00:01:17.940 --> 00:01:22.300
64-bit resolution independence,
but also on putting bridging

00:01:22.300 --> 00:01:25.490
technologies in place so that
you can use these awesome

00:01:25.540 --> 00:01:28.170
Cocoa features in your Carbon apps.

00:01:28.420 --> 00:01:33.070
The most important detail is that we're
not putting C wrapper APIs out there.

00:01:33.230 --> 00:01:35.790
You have to use Objective-C to
get at this functionality.

00:01:35.930 --> 00:01:38.540
We're not going to be in the
business of wrapping these

00:01:38.540 --> 00:01:40.400
APIs and having to maintain them.

00:01:42.780 --> 00:01:45.770
It's also important to note
that we're not completely

00:01:45.770 --> 00:01:47.110
stopping development on Toolbox.

00:01:47.150 --> 00:01:48.870
We're not deprecating it.

00:01:49.110 --> 00:01:52.460
We will put features in
place where they make sense.

00:01:52.580 --> 00:01:54.940
We will continue to put bridges in place.

00:01:55.130 --> 00:01:57.570
We will fix bugs where we need to.

00:01:57.650 --> 00:02:01.380
And where we already have a view in
HiToolbox that Cocoa has a view for,

00:02:01.380 --> 00:02:04.270
and where our view lags a
little bit behind that view,

00:02:04.270 --> 00:02:07.240
we'll probably put those
mini features in place.

00:02:07.280 --> 00:02:09.840
A great example of this
would be the segmented view.

00:02:09.900 --> 00:02:12.640
The Cocoa segmented view
supports menus in a segment.

00:02:12.670 --> 00:02:13.680
The Carbon one does not.

00:02:13.890 --> 00:02:17.320
That's something we would
enhance in the Toolbox.

00:02:21.390 --> 00:02:24.780
So there's a lot of great reasons
to do the Cocoa integration.

00:02:24.950 --> 00:02:27.340
The main reason is a user level reason.

00:02:27.400 --> 00:02:31.180
Every time we have parallel
implementations of a feature,

00:02:31.230 --> 00:02:33.150
we get details wrong here and there.

00:02:33.250 --> 00:02:35.980
The different implementations
have different sets of bugs.

00:02:36.090 --> 00:02:39.080
Sometimes their features work a little
bit differently or react a little

00:02:39.080 --> 00:02:42.220
bit differently to user interaction,
and that's a big pain, right?

00:02:42.310 --> 00:02:45.320
It's a pain as a user because you're used
to using a control that works one way,

00:02:45.380 --> 00:02:48.050
you go into another app and it
doesn't quite work the same way.

00:02:48.100 --> 00:02:52.050
Worse yet, you've got something like
Navigation Services in

00:02:52.050 --> 00:02:55.880
Carbon and NSOpenSave in Cocoa,
and there are some fairly glaring

00:02:55.920 --> 00:03:00.290
behavioral differences between those two,
which makes navigating around

00:03:00.290 --> 00:03:01.930
the system just a pain.

00:03:03.270 --> 00:03:07.280
So the other benefit of pushing
Cocoa integration is to improve your

00:03:07.280 --> 00:03:11.610
applications and improve the experience
for all users that use your applications.

00:03:11.700 --> 00:03:15.610
Clearly, by allowing Cocoa integration,
your apps can now offer all of

00:03:15.610 --> 00:03:17.380
this cool Cocoa value to users.

00:03:17.380 --> 00:03:19.750
You can take advantage
of all these features the

00:03:19.750 --> 00:03:21.350
Cocoa teams have been adding.

00:03:21.450 --> 00:03:24.910
But more importantly,
we now reduce the number of engineers

00:03:24.960 --> 00:03:28.100
that we have working on parallel
features between the two stacks.

00:03:28.150 --> 00:03:31.160
And we can spend those engineering
resources doing other cool

00:03:31.290 --> 00:03:34.440
things in one place that your
application can get for free.

00:03:34.470 --> 00:03:40.380
And I'll talk a little bit more
about some specifics very soon.

00:03:41.970 --> 00:03:46.130
To find out about using
Cocoa in Carbon applications,

00:03:46.420 --> 00:03:48.740
there are a couple points
you need to realize,

00:03:48.740 --> 00:03:51.290
a couple basic things you need
to do in your applications.

00:03:51.440 --> 00:03:53.280
We're going to cover this in
more detail in a particular

00:03:53.280 --> 00:03:54.710
session later in the week.

00:03:54.810 --> 00:03:57.070
But essentially you need to make
sure that the NS application

00:03:57.070 --> 00:03:58.620
is instantiated properly.

00:03:58.630 --> 00:04:01.740
You need to set up an auto-release
pool in certain situations,

00:04:01.740 --> 00:04:06.020
and in very rare but
well-defined situations,

00:04:06.020 --> 00:04:08.360
you need to set up an
NS graphics context.

00:04:08.470 --> 00:04:10.700
Sometimes the graphics context
will get set up implicitly

00:04:10.700 --> 00:04:11.450
based on what you're doing.

00:04:11.500 --> 00:04:14.340
But we talk about that
more in another session.

00:04:16.730 --> 00:04:20.640
So the first big way we are pushing
Cocoa integration in the Leper Toolbox

00:04:20.730 --> 00:04:23.760
is by what we call the HICocoa view.

00:04:24.190 --> 00:04:25.850
The HICoco view is an HIView.

00:04:25.850 --> 00:04:30.040
It's a Carbon HIView that allows
you to embed basically any

00:04:30.120 --> 00:04:33.100
NSView into your Carbon hierarchy.

00:04:33.100 --> 00:04:37.580
We've done this a little bit
before with the HiWebView,

00:04:37.580 --> 00:04:40.100
but the HiWebView really
wasn't good enough.

00:04:40.100 --> 00:04:42.820
It was a standalone view that
sort of wrapped the WebKit view,

00:04:42.910 --> 00:04:44.060
but it wasn't very good.

00:04:44.350 --> 00:04:48.100
Well, the HICoco view is tied directly
to the Carbon and Cocoa frameworks.

00:04:48.100 --> 00:04:51.310
We're making changes to both frameworks
to make them play well together,

00:04:51.310 --> 00:04:54.100
and the Cocoa view is that bridge.

00:04:55.090 --> 00:04:58.570
It's important to note that the
CocoaView supports compositing windows.

00:04:58.690 --> 00:05:00.830
We might support non-compositing windows.

00:05:00.850 --> 00:05:02.320
It's not currently a goal.

00:05:02.460 --> 00:05:06.390
Supporting non-compositing is
often asked for by developers,

00:05:06.390 --> 00:05:10.760
but we're pushing so much technology
out at you this year that requires you

00:05:10.760 --> 00:05:13.930
to get off of non-compositing mode that
I'm not sure I really want to support

00:05:13.930 --> 00:05:16.000
non-compositing mode in the HICocoaView.

00:05:16.000 --> 00:05:18.440
For example, 64-bit, no compositing mode.

00:05:18.450 --> 00:05:20.990
Resolution independence,
no compositing mode.

00:05:21.000 --> 00:05:23.840
So we really would love to avoid
having to support compositing

00:05:23.840 --> 00:05:26.350
mode in the HICocoaView.

00:05:27.880 --> 00:05:30.940
So let me show you the Hikoku
view in action and give you

00:05:30.950 --> 00:05:32.250
an idea of what it can do.

00:05:32.260 --> 00:05:34.830
Can we switch over to the demo machine?

00:05:43.750 --> 00:05:47.870
Okay,
so this is one of our test applications

00:05:47.980 --> 00:05:52.040
that we are using on Leopard to test
the implementation of the HICocoView.

00:05:52.040 --> 00:05:56.200
Let's go ahead and run this.

00:06:05.930 --> 00:06:07.660
And any day now.

00:06:07.710 --> 00:06:09.100
Sorry, I should have built it in advance.

00:06:09.190 --> 00:06:13.800
So what you get is a Carbon composited
window with a bunch of Carbon controls

00:06:13.880 --> 00:06:18.890
in it that allow you to choose and
manipulate various Cocoa views.

00:06:19.040 --> 00:06:22.650
So there is an HICoco view up here in
the top left-hand corner of the window,

00:06:22.670 --> 00:06:28.400
and I put it into editing mode so I can
actually change the HICoco view size.

00:06:28.400 --> 00:06:30.140
And that will become useful
as I choose different views.

00:06:30.140 --> 00:06:32.630
So I've got this HICoco
view in the window,

00:06:32.630 --> 00:06:36.700
and I'm going to tell it to embed a
Cocoa push button in the HICoco view.

00:06:36.700 --> 00:06:38.600
Now you have a Cocoa push
button in the window.

00:06:38.600 --> 00:06:41.480
That's a real live Cocoa push
button reacting with COCO's event

00:06:41.500 --> 00:06:42.810
handling logic and so forth.

00:06:42.980 --> 00:06:45.770
There's a little bit of a
bridge layer with our HIView,

00:06:45.770 --> 00:06:47.500
but it's basically working.

00:06:47.530 --> 00:06:50.320
And of course, you can do various
other sorts of controls,

00:06:50.320 --> 00:06:51.430
the basic controls.

00:06:51.560 --> 00:06:53.590
But most importantly,
you can do controls that

00:06:53.650 --> 00:06:55.000
we don't have in Carbon.

00:06:55.120 --> 00:06:57.940
We have a token field editor in Cocoa.

00:06:58.220 --> 00:06:59.640
We don't have one in Carbon.

00:06:59.800 --> 00:07:05.370
We had a feature saying we should
implement a token field editor in Carbon,

00:07:05.370 --> 00:07:07.530
but what we found is that the
token field editor for Cocoa just

00:07:07.530 --> 00:07:09.040
works in our HICoco view.

00:07:09.150 --> 00:07:12.500
So that's how we're going to give
Carbon developers a token field.

00:07:12.500 --> 00:07:15.140
You're going to adopt the Cocoa one.

00:07:15.140 --> 00:07:19.050
You can also, let's see,

00:07:20.920 --> 00:07:25.660
You can throw a web view into a
Carbon window and it's a fully functional

00:07:25.660 --> 00:07:31.650
web view that works better than the

00:07:32.400 --> 00:07:50.200
[Transcript missing]

00:07:50.360 --> 00:07:55.060
QtKit is the only way to get
QuickTime content in 64-bit.

00:07:55.100 --> 00:07:57.340
There is no Carbon-based movie control.

00:07:57.590 --> 00:08:01.960
The old Carbon-based QuickTime APIs that
can draw a movie into a port don't exist.

00:08:02.030 --> 00:08:05.760
So the only way you can get
QuickTime content in a 64-bit

00:08:05.760 --> 00:08:13.010
Carbon app is by using the QtMovie view,
and HICocoView facilitates that.

00:08:13.010 --> 00:08:13.010
So I've got...

00:08:13.170 --> 00:08:16.040
A movie playing in the Qt
movie view sitting inside a

00:08:16.130 --> 00:08:17.280
Carbon window and it just works.

00:08:17.300 --> 00:08:19.900
And the audio works too,
we just haven't turned it

00:08:19.910 --> 00:08:21.990
on on the demo machine.

00:08:22.870 --> 00:08:24.440
Let's see what else is we're showing.

00:08:24.440 --> 00:08:25.140
That's probably about it.

00:08:25.140 --> 00:08:26.040
Okay, so let's go back to slides.

00:08:26.130 --> 00:08:27.760
So you can see that this works.

00:08:28.090 --> 00:08:30.370
There are a few rough edges,
but we're going to make sure

00:08:30.370 --> 00:08:32.890
all those rough edges are sanded
off by the time we ship Leopard.

00:08:32.960 --> 00:08:36.240
We want this to be basically
a perfect experience.

00:08:36.240 --> 00:08:39.690
So can we switch back to slides?

00:08:47.320 --> 00:08:49.690
So the CocoaView is
really easy to deal with.

00:08:49.900 --> 00:08:51.060
It's just an HIView.

00:08:51.060 --> 00:08:53.570
If you're used to using HIViews,
you're going to be used

00:08:53.570 --> 00:08:54.920
to using the HICocoaView.

00:08:54.980 --> 00:08:58.450
We've got a creation API,
and we've got a way for you to

00:08:58.450 --> 00:09:02.970
get and set the NSView associated
with that CocoaView.

00:09:03.190 --> 00:09:05.680
So there's a little bit of a
terminology strangeness here.

00:09:05.850 --> 00:09:09.720
When I refer to the CocoaView,
I'm talking about the HICocoaView,

00:09:09.770 --> 00:09:12.260
the Carbon view that wraps an NSView.

00:09:12.360 --> 00:09:16.050
And other times I'll be
referring to an NSView,

00:09:16.050 --> 00:09:19.410
which is the actual AppKit-based view.

00:09:20.930 --> 00:09:25.460
So once you have an HICocoView,
if you need to manipulate various

00:09:25.460 --> 00:09:29.930
pieces of state on the NSView at wraps,
it's generally best to use the

00:09:29.930 --> 00:09:33.340
HIView and call various APIs on
it to set things like activation,

00:09:33.340 --> 00:09:35.190
visibility, and bounds, and so forth.

00:09:35.290 --> 00:09:39.370
And the HICocoView automatically
propagates those changes to

00:09:39.370 --> 00:09:41.440
the NSView as appropriate.

00:09:42.590 --> 00:09:47.760
If you need to actually deal with
the NSViews specific functionality,

00:09:47.790 --> 00:09:50.660
you'll have to use the
Objective-C APIs with that

00:09:50.660 --> 00:09:53.120
NSViews API set as appropriate.

00:09:56.710 --> 00:09:59.720
In order to create an HICocoView in
IB in the leopard seed,

00:09:59.720 --> 00:10:05.110
you need to drag out a custom
HIView and set its HIView ID.

00:10:05.460 --> 00:10:10.300
And once you do that at runtime,
you can load your NSView into it.

00:10:10.330 --> 00:10:13.060
We want to expand the IB support
by the time Leopard ships,

00:10:13.130 --> 00:10:14.780
but this is as far as
we've gotten in the seed,

00:10:14.800 --> 00:10:16.910
so just be aware of that.

00:10:19.340 --> 00:10:24.320
Our initial goal for the HICocoView was
to support three or four different views.

00:10:24.460 --> 00:10:26.960
Specifically,
we wanted a replacement for the

00:10:26.980 --> 00:10:29.200
HiWebView because it wasn't very good.

00:10:29.200 --> 00:10:31.920
We wanted to support the PDFView,
we knew we needed to

00:10:31.920 --> 00:10:35.700
support the QTMovieView,
and we knew we wanted the token field.

00:10:35.870 --> 00:10:38.450
And so that's what we were
basing our engineering around,

00:10:38.450 --> 00:10:40.700
is making these four
views work rock solid.

00:10:40.700 --> 00:10:44.000
So as we were doing our work,
we found that, wow, look,

00:10:44.080 --> 00:10:46.690
basically all the other CocoViews work.

00:10:46.700 --> 00:10:49.070
Now it's possible you'll
find some that don't.

00:10:49.070 --> 00:10:51.560
If you do, please let us know,
write up bugs,

00:10:51.570 --> 00:10:53.700
we'll try our best to make those work.

00:10:53.770 --> 00:10:56.700
It's also possible we won't quite
be able to make all of them work.

00:10:56.860 --> 00:11:01.560
There could potentially be some problems
that we just can't solve in our bridge,

00:11:01.560 --> 00:11:06.700
and what we may have to do in those
cases is make some of those NSViews rev

00:11:06.700 --> 00:11:10.070
to know that they're in a Carbon window
and behave a little bit differently,

00:11:10.070 --> 00:11:10.700
potentially.

00:11:10.700 --> 00:11:13.350
So if you do find problems,
let us know and we can take

00:11:13.350 --> 00:11:14.810
those steps if we need to.

00:11:17.890 --> 00:11:21.140
So there's a couple usage
limitations you need to know about.

00:11:21.210 --> 00:11:25.130
The first is that once
you have an HICoco view,

00:11:25.180 --> 00:11:28.400
the only thing that should be
embedded inside of it is an NSView.

00:11:28.520 --> 00:11:30.020
Don't put any other HIViews in it.

00:11:30.040 --> 00:11:30.850
It just won't work.

00:11:31.040 --> 00:11:34.990
That HICoco view and the
Carbon compositing draw pipeline expect

00:11:34.990 --> 00:11:37.000
there to just be an NSView inside.

00:11:37.000 --> 00:11:40.300
Of course, that NSView could be a
hierarchy of other NSViews.

00:11:40.300 --> 00:11:43.260
In fact, that's exactly what happens
in the WebKit view case,

00:11:43.270 --> 00:11:43.880
right?

00:11:44.010 --> 00:11:46.810
The WebKit view is potentially
other views and cells for text

00:11:46.860 --> 00:11:48.600
editing and buttons and so forth.

00:11:48.600 --> 00:11:49.360
So that's fine.

00:11:49.480 --> 00:11:54.400
Just make sure that you don't put any
other HIViews in your HICoco view.

00:11:54.790 --> 00:11:58.020
Now, Cocoa allows you to do a certain
amount of multi-threaded drawing,

00:11:58.020 --> 00:12:02.130
but Carbon's drawing model is
inherently single-threaded.

00:12:02.190 --> 00:12:04.930
Carbon cannot handle
drawing on multiple threads.

00:12:05.020 --> 00:12:08.150
So if your Cocoa view that you want
to use draws on multiple threads,

00:12:08.150 --> 00:12:09.510
that would be a usage limitation.

00:12:09.640 --> 00:12:14.040
You won't be able to use
that with an HI Cocoa view,

00:12:14.040 --> 00:12:15.400
and that's not something we can fix.

00:12:15.440 --> 00:12:19.950
We have no plans to take Carbon's
entire compositing draw model

00:12:19.950 --> 00:12:22.600
and making it multi-thread safe.

00:12:24.390 --> 00:12:28.940
So before when I said if you want
to do state changes to the NSView,

00:12:28.940 --> 00:12:32.400
you should call some of the state
change APIs in the HIView set,

00:12:32.400 --> 00:12:34.300
and we propagate those as appropriate.

00:12:34.430 --> 00:12:35.940
Don't do the reverse.

00:12:36.040 --> 00:12:41.690
If you set the bounds on your NSView,
it's not pushed back up to the HIView.

00:12:41.800 --> 00:12:44.300
It's still respected at the NSView level,
right?

00:12:44.300 --> 00:12:47.370
You can make your NSView bigger,
just the HICocoView will be smaller

00:12:47.370 --> 00:12:49.300
and therefore will clip your NSView.

00:12:49.300 --> 00:12:52.870
So generally for those kinds
of state changes like bounds,

00:12:52.870 --> 00:12:54.220
call the HIView API.

00:12:54.350 --> 00:12:56.300
Don't call the NSView API.

00:12:58.070 --> 00:13:00.020
We haven't wired up
accessibility yet in the seed.

00:13:00.090 --> 00:13:03.610
This is something we definitely want
to do by the time Leopard ships.

00:13:03.700 --> 00:13:07.190
In fact, we want to make the Carbon-Cocoa
accessibility integration story

00:13:07.190 --> 00:13:09.940
a lot better in a lot of ways,
not just at the view level.

00:13:10.020 --> 00:13:13.440
There are a lot of window integration
bugs as a result of bringing up

00:13:13.440 --> 00:13:16.870
font panels and color pickers in
a Carbon app where it just doesn't

00:13:16.870 --> 00:13:19.050
quite work right in accessibility.

00:13:19.150 --> 00:13:22.380
So we want to smooth over
all those rough edges.

00:13:24.390 --> 00:13:29.040
Another way we're really pushing the
Cocoa Carbon integration in Leopard is by

00:13:29.550 --> 00:13:32.210
essentially gutting navigation services.

00:13:32.460 --> 00:13:34.150
We scraped out all the
code underneath it,

00:13:34.320 --> 00:13:38.770
kept the APIs in place,
and just rewrote those APIs on top

00:13:38.770 --> 00:13:41.890
of the Cocoa NSOpenSavePanel APIs.

00:13:44.440 --> 00:13:46.580
We did this mainly for two reasons.

00:13:46.780 --> 00:13:50.160
One, it's going to make our own lives
easier in the long term because we

00:13:50.170 --> 00:13:52.240
only have one code base to maintain.

00:13:52.310 --> 00:13:55.550
But from a user perspective,
we get rid of all those horrible

00:13:56.050 --> 00:13:59.250
interaction and parity problems between
the two different implementations

00:13:59.250 --> 00:14:00.660
that behave very differently.

00:14:00.660 --> 00:14:03.100
So we get rid of a lot
of bugs in the process.

00:14:03.210 --> 00:14:06.360
And that lets our engineers
spend more time on doing

00:14:06.360 --> 00:14:09.200
cool things in OpenSave like,
I don't know,

00:14:09.200 --> 00:14:12.170
adding icon view and various other things
that are widely requested features.

00:14:15.930 --> 00:14:20.800
So, since we basically reimplemented
the Nav Services APIs,

00:14:20.810 --> 00:14:24.850
your apps, when they run on Leopard,
get the Cocoa OpenSave implementation

00:14:24.930 --> 00:14:25.430
for free.

00:14:25.580 --> 00:14:27.740
It just happens.

00:14:27.740 --> 00:14:31.740
Now, that's the default,
but there are some caveats.

00:14:31.800 --> 00:14:35.210
There are some ill-behaved
applications that make bad assumptions

00:14:35.340 --> 00:14:37.530
about Nav Services dialogs.

00:14:37.570 --> 00:14:40.910
They may assume that the
Nav Services dialog has a diddle and

00:14:40.910 --> 00:14:43.920
the fourth item is the OK button,
and they try to

00:14:43.920 --> 00:14:45.740
manipulate that OK button.

00:14:45.740 --> 00:14:48.180
And in stranger situations,
they try to navigate down the

00:14:48.190 --> 00:14:50.980
hierarchy to find the data browser
to change the way the data browser

00:14:50.980 --> 00:14:52.700
acts and various other weird things.

00:14:52.810 --> 00:14:56.400
Those apps already have a number of
different compatibility workarounds

00:14:56.400 --> 00:15:00.050
put in place for them on the system
to maintain those legacy behaviors.

00:15:00.180 --> 00:15:03.420
If your app has some of
those workarounds in place,

00:15:03.420 --> 00:15:07.670
you're going to get the old
Navigation Services implementation.

00:15:09.600 --> 00:15:14.100
So, if you are one of those apps,
what you want to do is - our

00:15:14.100 --> 00:15:18.300
developer relations folks have tried
to contact you and let you know what

00:15:18.300 --> 00:15:19.600
you need to change in your code.

00:15:19.770 --> 00:15:22.360
Change that in your code,
deploy with a new version

00:15:22.550 --> 00:15:26.030
in your application,
and you will get the Cocoa-based

00:15:26.040 --> 00:15:28.550
OpenSave implementation for free.

00:15:28.610 --> 00:15:32.700
Now, that said, even though you get the
Cocoa version for free,

00:15:32.850 --> 00:15:35.570
you may want to do
some explicit adoption.

00:15:35.600 --> 00:15:38.490
One cool thing we did is take
the NavDialog ref address.

00:15:38.620 --> 00:15:42.550
That address really is just a pointer
to an NSA panel or an NSOpenPanel.

00:15:42.600 --> 00:15:45.600
You can cast that to one of
those two types and start calling

00:15:45.860 --> 00:15:49.540
Objective-C methods on it if you
want to trigger Cocoa functionality.

00:15:49.600 --> 00:15:52.620
So that's one possible way you could
do the kinds of things you used to be

00:15:52.740 --> 00:15:54.550
doing by hacking the Carbon version.

00:15:54.610 --> 00:15:57.590
You can just now do it in a
clean way using the Cocoa APIs.

00:16:01.080 --> 00:16:04.000
So I already talked a little bit
about application compatibility,

00:16:04.000 --> 00:16:06.230
but there's a few more details.

00:16:06.370 --> 00:16:10.410
We are going to add an opt-out
mechanism for the automatic usage of

00:16:10.430 --> 00:16:12.600
the Cocoa OpenSave panel for Leopard.

00:16:12.650 --> 00:16:15.380
So your application will be able to put
something into its bundle that says,

00:16:15.380 --> 00:16:17.840
"I want the Carbon version for
compatibility." So you'll be

00:16:17.840 --> 00:16:20.480
able to let us know if you find
problems that we haven't found.

00:16:20.570 --> 00:16:23.000
If you do opt out, however,
you miss some big

00:16:23.050 --> 00:16:24.590
pieces of functionality.

00:16:24.740 --> 00:16:27.740
The Cocoa OpenSave panel is being
revved to support icon view.

00:16:27.740 --> 00:16:31.670
It's being revved to support better
searching and various other cool things.

00:16:31.750 --> 00:16:34.220
And we're not revving the
Carbon implementation and navigation

00:16:34.220 --> 00:16:35.390
services to support those.

00:16:35.520 --> 00:16:38.020
So if you opt out,
your users don't get any

00:16:38.020 --> 00:16:39.710
of those cool features.

00:16:43.640 --> 00:16:47.500
So, just to restate our
Cocoa integration story,

00:16:47.670 --> 00:16:49.470
this is not a deprecation.

00:16:49.730 --> 00:16:53.700
Your application will need to use
Objective-C to get at this functionality.

00:16:53.700 --> 00:16:57.490
But the benefit is you'll get all
this cool stuff that's in Cocoa.

00:16:57.730 --> 00:17:00.760
Now we know there's a little
bit of a religious war,

00:17:00.760 --> 00:17:04.320
Carbon versus Cocoa,
on the mailing list and so forth.

00:17:04.650 --> 00:17:07.490
Our stance internally - we work
right next door to the Cocoa team.

00:17:07.500 --> 00:17:10.030
We're great friends with them,
we hang out with them in

00:17:10.030 --> 00:17:11.500
social events and so forth.

00:17:11.530 --> 00:17:13.500
And there's no animosity at our level.

00:17:13.500 --> 00:17:15.480
We don't want there to be
animosity on the developer level.

00:17:15.500 --> 00:17:17.890
What we want developers to
think of is that there aren't

00:17:17.940 --> 00:17:19.500
Cocoa and Carbon applications.

00:17:19.500 --> 00:17:21.500
There are Mac OS X applications.

00:17:21.500 --> 00:17:24.890
And the best Mac OS X applications
are going to take advantage

00:17:24.980 --> 00:17:28.500
of all the APIs on the system
wherever there are great APIs.

00:17:28.500 --> 00:17:31.750
Don't artificially limit yourself
to one API set because you want to

00:17:31.750 --> 00:17:33.500
be Cocoa or you want to be Carbon.

00:17:33.500 --> 00:17:37.500
Just use the best APIs you can and
deliver the best user experience.

00:17:37.500 --> 00:17:41.650
So one way you can start doing
that now in your applications is

00:17:41.650 --> 00:17:46.000
if you're already on the path to
deliver a partially Cocoa-based

00:17:46.120 --> 00:17:48.950
Carbon application in the future,
one thing you might start doing

00:17:49.060 --> 00:17:52.040
is implement your custom content
as an NSView instead of an

00:17:52.040 --> 00:17:54.500
HIView and leverage HICocoaView.

00:17:54.520 --> 00:17:56.800
Embed your NSView in an
HICocoaView and deliver that

00:17:56.800 --> 00:17:58.490
in your application on Leopard.

00:17:58.490 --> 00:18:00.490
And that gives you a
leg up for the future.

00:18:00.500 --> 00:18:03.070
Now you have an NSView in your
hands for when you eventually

00:18:03.070 --> 00:18:04.490
do move that window to Cocoa.

00:18:04.500 --> 00:18:06.500
So you'll be in great shape.

00:18:07.950 --> 00:18:10.860
It's also very important to note that
this is a high priority task for us.

00:18:10.910 --> 00:18:13.800
We need to make this rock solid in
order for there to be any adoption.

00:18:13.880 --> 00:18:16.780
So any bugs you find,
even the most trivial bug that you

00:18:16.780 --> 00:18:19.520
think we probably already know about,
file it anyway.

00:18:19.620 --> 00:18:21.430
I don't mind getting
hundreds of duplicates.

00:18:21.490 --> 00:18:25.650
What I want to make sure happens is we
deliver a rock solid implementation,

00:18:25.710 --> 00:18:29.170
not something that was a little
flaky like the HIMovieView.

00:18:29.170 --> 00:18:31.000
So please file those bugs.

00:18:32.400 --> 00:18:39.300
[Transcript missing]

00:18:46.640 --> 00:18:48.840
Thank you, Guy.

00:18:48.840 --> 00:18:49.300
All right.

00:18:49.500 --> 00:18:54.240
So that covers some of our
Cocoa integration technologies.

00:18:54.240 --> 00:18:57.470
But we have been busy with a lot
of other changes in the toolbox

00:18:57.480 --> 00:18:59.600
in the past year and a half or so.

00:18:59.600 --> 00:19:02.720
And I'm going to go over some of
the big ticket items here that we've

00:19:02.720 --> 00:19:05.900
been working on that we'd really
like you to take advantage of and be

00:19:05.900 --> 00:19:07.900
able to adopt in your applications.

00:19:07.900 --> 00:19:11.170
Here's a quick list of the
topics I'm going to cover here.

00:19:11.170 --> 00:19:14.220
64-bit, of course,
is one of our really big

00:19:14.220 --> 00:19:16.540
changes in the Leopard HI20.

00:19:16.610 --> 00:19:19.090
We have a new API that we've provided
in the toolbox that's been covered

00:19:19.180 --> 00:19:20.600
widely in the conference already so far.

00:19:20.600 --> 00:19:26.100
And we do have 64-bit implementations
of all the HI Toolbox frameworks.

00:19:26.100 --> 00:19:27.920
Resolution independence,
a technology that we

00:19:27.940 --> 00:19:31.600
introduced first in Tiger,
and we're completing that in Leopard.

00:19:31.600 --> 00:19:34.740
We have a new capability to
be able to handle Apple events

00:19:34.760 --> 00:19:36.980
using Carbon event handlers,
which can be handy in

00:19:36.980 --> 00:19:44.900
certain circumstances.

00:19:44.900 --> 00:19:44.900
There's a new API that we provided
in the HI Object Manager called

00:19:44.900 --> 00:19:44.900
HI Object Delegates.

00:19:45.130 --> 00:19:48.850
We're enabling you to
embed HIViews inside menus,

00:19:48.850 --> 00:19:51.570
which is something that's already been
used in a few places in the system,

00:19:51.570 --> 00:19:55.540
and we're going to make it easier for
you to do that in your own applications.

00:19:55.550 --> 00:20:00.130
We have new support for using
files to show image content

00:20:00.130 --> 00:20:03.420
inside some of the standard views.

00:20:03.460 --> 00:20:07.460
And finally, there's a new API called
TextInputSources that the

00:20:07.460 --> 00:20:10.870
Text and Graphics group has done,
and that's going to be a replacement

00:20:10.950 --> 00:20:13.770
for a number of deprecated APIs.

00:20:14.350 --> 00:20:17.300
So the 64-bit HIToolbox.

00:20:17.300 --> 00:20:19.800
I think you've probably heard a
lot of this if you've been going to

00:20:19.800 --> 00:20:21.350
the other keynote sessions already.

00:20:21.370 --> 00:20:24.080
But some of the reasons
why we're going to 64-bit,

00:20:24.190 --> 00:20:26.700
obviously the industry as
a whole is going that way.

00:20:26.700 --> 00:20:30.230
Windows Vista,
Windows XP have 64-bit versions, Linux,

00:20:30.280 --> 00:20:30.640
Alaris.

00:20:30.640 --> 00:20:33.430
The hardware is continuing to evolve.

00:20:33.490 --> 00:20:36.340
We are shipping more and more memory
in our baseline configurations.

00:20:36.340 --> 00:20:40.480
The new Xeon machines can go
up to 16 gigabytes of memory,

00:20:40.540 --> 00:20:41.240
I think.

00:20:41.240 --> 00:20:44.170
And there are performance advantages.

00:20:44.230 --> 00:20:50.100
Especially in the x86 ABI,
if you compile your Intel application

00:20:50.120 --> 00:20:54.350
using the 64-bit x86 ABI,
you can get improved

00:20:54.430 --> 00:20:55.750
performance for your code.

00:20:55.960 --> 00:20:57.930
And also just user demand.

00:20:57.960 --> 00:21:01.790
As your users try to use
larger and larger data sets,

00:21:01.790 --> 00:21:05.470
you are going to find some performance
advantages and your users are going to

00:21:05.470 --> 00:21:10.710
want your applications to be 64-bit in
order to deal with those large data sets.

00:21:11.300 --> 00:21:16.800
So we're going to be taking out a lot of
old legacy API in the 64-bit HIToolbox.

00:21:16.800 --> 00:21:21.700
We're really using this as an opportunity
to clean up a lot of this old API that

00:21:21.700 --> 00:21:24.190
came across from classic Mac OS.

00:21:24.210 --> 00:21:29.200
So non-compositing mode is not
available at all in 64-bit HIToolbox.

00:21:29.200 --> 00:21:31.220
Quick draw,
as has already been mentioned,

00:21:31.220 --> 00:21:32.190
has been removed.

00:21:32.200 --> 00:21:36.180
There's no support for CDEFs, for MDEFs,
or for WDEFs.

00:21:36.200 --> 00:21:41.200
The FS spec type in the file
manager is no longer supported.

00:21:41.210 --> 00:21:43.200
Pascal strings are also gone.

00:21:43.200 --> 00:21:46.200
That's really, you know,
very legacy technology there.

00:21:46.200 --> 00:21:50.190
And using Quick Draw Text or
the TextEditManager to draw

00:21:50.280 --> 00:21:55.290
or edit your text are also not
supported in the 64-bit version.

00:21:55.500 --> 00:22:00.200
So we're really focusing very tightly
on supporting those modern APIs that

00:22:00.290 --> 00:22:03.100
we've been talking to you about
probably for the last five years

00:22:03.110 --> 00:22:08.390
or so to get you moving on to these
modern set of programming interfaces.

00:22:08.500 --> 00:22:12.400
So compositing mode is the
most significant example here,

00:22:12.400 --> 00:22:13.400
and Quartz.

00:22:13.410 --> 00:22:16.910
Your 64-bit toolbox application
must use compositing mode and

00:22:16.910 --> 00:22:18.400
it must use Quartz to draw.

00:22:18.400 --> 00:22:20.400
That's the only interface
we're going to support.

00:22:20.400 --> 00:22:23.970
You must use custom HIViews
to draw your content.

00:22:23.970 --> 00:22:27.400
That goes right along
with compositing mode.

00:22:27.570 --> 00:22:33.400
You must use FSRefs or you can also
use CFURLRefs to identify your files.

00:22:33.400 --> 00:22:38.690
You must use CFStrings or some other
similar type of Unicode-based string

00:22:38.690 --> 00:22:43.650
API to contain your strings whenever
you're passing a string into the

00:22:43.650 --> 00:22:48.400
toolbox to change the title of a window
or a control or anything like that.

00:22:48.400 --> 00:22:53.390
The only text editing APIs would be MLTE.

00:22:53.410 --> 00:22:58.740
The text drawing APIs would be ATSUI or
the new core text and core font APIs that

00:22:58.740 --> 00:23:01.400
we're introducing here this year.

00:23:01.400 --> 00:23:04.650
And we're also providing a number
of new APIs to replace some of

00:23:04.650 --> 00:23:06.400
the APIs that we've removed.

00:23:06.400 --> 00:23:09.400
So I'll talk briefly about some
of those a little bit later,

00:23:09.400 --> 00:23:12.210
and we're going to have more
APIs introduced after the

00:23:12.210 --> 00:23:15.460
developers conference that we
didn't have time to do yet.

00:23:15.880 --> 00:23:20.400
I'll touch briefly on a few legacy
APIs that we are still providing.

00:23:20.450 --> 00:23:23.510
The point here basically to
provide these is just to make your

00:23:23.510 --> 00:23:27.800
lives easier when you're trying to
port your applications to 64-bit.

00:23:27.800 --> 00:23:32.680
We're getting rid of a lot of things
that really don't make any sense at all,

00:23:32.780 --> 00:23:36.770
but we are keeping some just
because we want to make your path

00:23:36.860 --> 00:23:41.010
easier to get over to 64-bit,
and we don't want to throw up

00:23:41.070 --> 00:23:43.800
arbitrary roadblocks in your path.

00:23:43.800 --> 00:23:44.790
So here are some examples.

00:23:44.790 --> 00:23:48.400
The classic event manager,
the event record type, wait next event,

00:23:48.400 --> 00:23:48.760
etc.

00:23:48.760 --> 00:23:50.720
are still supported if you need them.

00:23:50.850 --> 00:23:52.800
Of course, we don't recommend that
you use any of these.

00:23:52.800 --> 00:23:55.490
We highly recommend that you
use Carbon Events and not

00:23:55.530 --> 00:23:58.800
the classic event manager,
but it's there if you need it.

00:23:58.800 --> 00:24:01.100
The dialog manager is still supported.

00:24:01.100 --> 00:24:04.720
Note that the dialog manager
only creates compositing windows,

00:24:04.720 --> 00:24:08.800
though, in 64-bit since there are
no non-compositing windows.

00:24:08.800 --> 00:24:11.800
The scrap manager is still supported.

00:24:11.800 --> 00:24:15.160
We have a replacement for
that since Tiger or Panther,

00:24:15.160 --> 00:24:17.790
I can't remember which,
Brian will tell me.

00:24:17.900 --> 00:24:20.630
The pasteboard manager,
so we recommend you use

00:24:20.630 --> 00:24:23.390
the pasteboard manager,
but the scrap manager

00:24:23.390 --> 00:24:24.800
API is there as well.

00:24:26.680 --> 00:24:31.190
So developer adoption for
64-bit is really pretty similar

00:24:31.190 --> 00:24:33.820
to the original Carbon story.

00:24:33.820 --> 00:24:36.540
The original Carbon story was if
you've been keeping up with us,

00:24:36.540 --> 00:24:40.240
if you're using the Appearance Manager,
if you're using more modern APIs,

00:24:40.240 --> 00:24:41.290
then it's easier.

00:24:41.490 --> 00:24:43.670
If you're using Nav Services,
if you've already

00:24:43.670 --> 00:24:45.800
converted to Nav Services,
then you don't have to get rid of

00:24:45.800 --> 00:24:48.600
standard file in your application,
for example.

00:24:48.600 --> 00:24:50.920
The 64-bit story is very similar.

00:24:50.950 --> 00:24:53.760
If you've been keeping up with all
the APIs that we've been talking

00:24:53.760 --> 00:24:58.520
about over the last few years,
then 64-bit is actually not that bad.

00:24:58.530 --> 00:25:02.130
It's pretty easy to get a modern
application running in 64-bit mode.

00:25:02.130 --> 00:25:05.500
We've done this with several apps,
and it's not too hard.

00:25:05.500 --> 00:25:08.840
If you've got a lot of old
API usage in your application still,

00:25:08.840 --> 00:25:12.920
if you're using non-compositing mode,
if you're using Quick Draw to draw,

00:25:12.920 --> 00:25:16.690
if you're using FS Specs still,
which I hope you're not, but if you are,

00:25:16.690 --> 00:25:20.070
you're going to have a lot of
work to do because all those old

00:25:20.070 --> 00:25:25.020
APIs you have to take out first and
replace with the more modern APIs.

00:25:25.020 --> 00:25:25.020
So,
I'm going to go ahead and get started.

00:25:26.880 --> 00:25:31.700
So we've got some common types,
things defined in MacTypes.h

00:25:31.700 --> 00:25:34.200
that are now 64-bit compatible.

00:25:34.200 --> 00:25:37.020
Byte count, byte offset,
some other things.

00:25:37.020 --> 00:25:41.520
Some of the core foundation types
have been made 64 bits wide.

00:25:41.520 --> 00:25:44.700
So as you go through your code
to think about what do I need to

00:25:44.700 --> 00:25:49.020
change to become 64-bit compatible,
think about using these

00:25:49.040 --> 00:25:50.500
types in your code.

00:25:50.500 --> 00:25:54.420
So, for example, don't use an int to
represent a byte count.

00:25:54.450 --> 00:25:59.040
Declare your variable as type byte
count and then you'll automatically

00:25:59.070 --> 00:26:03.120
go up to 64 bits when you're
compiling for a 64-bit target.

00:26:03.120 --> 00:26:07.570
Some of the other standard types, UN32,
SN32, the obvious ones, well,

00:26:07.780 --> 00:26:12.180
they say right there in the name,
I'm 32-bit, so that's where it still is.

00:26:12.180 --> 00:26:14.420
Those are still 32 bits wide.

00:26:14.420 --> 00:26:16.560
So that's another case where
you might want to think about.

00:26:16.560 --> 00:26:20.830
I have a UN32 value here and
I'm using it to represent...

00:26:20.840 --> 00:26:23.000
The size of this block of memory.

00:26:23.130 --> 00:26:25.280
Well,
that might not be the right type to use.

00:26:25.370 --> 00:26:29.460
If you're compiling for 64-bit,
you might want to change a UN32

00:26:29.460 --> 00:26:33.080
variable into a byte count variable,
for example.

00:26:33.080 --> 00:26:35.600
We've also declared a few new types.

00:26:35.600 --> 00:26:41.550
Briefly, URefCon and SRefCon are two new
types that we've declared for use

00:26:41.550 --> 00:26:46.230
with APIs and callback functions
that take RefCon parameters.

00:26:46.230 --> 00:26:50.180
And the reason why we're doing
that is that in 32-bit mode...

00:26:50.180 --> 00:26:56.410
Often these APIs and callback
functions took RefCon parameters

00:26:56.460 --> 00:27:01.560
that were typed as maybe a long or an
unsigned long or something like that.

00:27:01.560 --> 00:27:04.360
Or maybe they were even typed as a UN32.

00:27:04.360 --> 00:27:06.430
Well, obviously,
if they're typed as a UN32,

00:27:06.430 --> 00:27:10.660
that's not going to work in 64-bit mode
because a UN32 is still 32 bits wide.

00:27:10.660 --> 00:27:14.640
And frequently with a RefCon,
you want to pass a pointer, let's say,

00:27:14.640 --> 00:27:17.580
and the pointer needs
to scale up to 64 bits.

00:27:17.600 --> 00:27:22.240
So we've defined some new types for
things that are RefCon parameters and

00:27:22.240 --> 00:27:25.240
used them widely across the Toolbox API.

00:27:25.240 --> 00:27:30.130
And that may cause you some compilation
issues when you go to adopt 64-bit

00:27:30.130 --> 00:27:34.410
in your application because you may
need to change places where you are,

00:27:34.410 --> 00:27:37.590
for example,
casting a pointer to a UN32 before

00:27:37.690 --> 00:27:40.280
you pass it into an API as a RefCon.

00:27:40.280 --> 00:27:44.520
You might want to change that
cast to a URefCon instead.

00:27:44.520 --> 00:27:48.760
And that way you'll avoid truncating
the top 32 bits of your pointer.

00:27:48.760 --> 00:27:52.520
Another type mentioned on this
slide is the CGFloat type.

00:27:52.520 --> 00:27:56.520
And that is a type that is provided
by the Core Graphics framework.

00:27:56.780 --> 00:28:00.590
In Core Graphics,
a lot of the APIs that take a

00:28:00.590 --> 00:28:05.130
floating point value were previously
typed to take a float parameter.

00:28:05.220 --> 00:28:08.850
And in 64 bits,
those parameters are all changed to take

00:28:08.850 --> 00:28:14.320
a double parameter so that we get some
extra precision and resolution there.

00:28:14.320 --> 00:28:17.430
So instead of going through and putting
ifdef's everywhere through the headers,

00:28:17.580 --> 00:28:20.170
CoreGraphics is just
using the CGFloat type,

00:28:20.170 --> 00:28:25.560
which in 32-bit mode is a float,
and in 64-bit mode is a double.

00:28:25.560 --> 00:28:29.580
And you'll probably want to make
a similar change in your code.

00:28:29.620 --> 00:28:33.050
Frequently, for example,
you might declare an array of

00:28:33.050 --> 00:28:37.260
floating point values and then pass
that array into a Core Graphics API.

00:28:37.260 --> 00:28:41.350
And you want to make sure that you
change the base type of that array to a

00:28:41.350 --> 00:28:46.340
CGFloat instead of just a float because
when you pass that into Core Graphics,

00:28:46.340 --> 00:28:50.820
CGFloat is going to be expecting
an array of doubles in 64-bit mode.

00:28:50.930 --> 00:28:53.120
And that's what you better provide
or you're going to have some trouble.

00:28:55.150 --> 00:28:59.660
So I'll go through some of the common
managers and point out a few gotchas

00:28:59.660 --> 00:29:03.610
and some of the API changes that
we've made for each one of these.

00:29:03.760 --> 00:29:07.520
And the Appearance Manager,
there is no Quick Draw, as we said.

00:29:07.650 --> 00:29:11.100
So all of the Appearance
Manager APIs that used to draw into

00:29:11.100 --> 00:29:15.570
a Quick Draw port or in some other
way depend on the presence of a port,

00:29:15.590 --> 00:29:18.390
like the ones that would change
the background color of a port,

00:29:18.390 --> 00:29:19.800
for example.

00:29:19.800 --> 00:29:20.800
Those have gone.

00:29:20.800 --> 00:29:22.880
There's no replacement for those.

00:29:22.950 --> 00:29:27.010
There's no Quick Draw based
Appearance Manager drawing anymore.

00:29:27.210 --> 00:29:31.300
But we do have the HITHeme API,
which we introduced a few releases ago.

00:29:31.350 --> 00:29:34.300
And the HITHeme API uses
CGContext for everything.

00:29:34.300 --> 00:29:38.310
So that's the one you want to use and
that's what you can adopt in both your

00:29:38.310 --> 00:29:41.240
32-bit and your 64-bit applications.

00:29:41.400 --> 00:29:45.200
One place where we don't have a
replacement yet that I'd like to

00:29:45.230 --> 00:29:49.080
point out is KThemeCurrentPortFont.

00:29:49.150 --> 00:29:49.780
It says right there in the
case that we're going to use

00:29:49.780 --> 00:29:49.780
the KThemeCurrentPortFont.

00:29:49.790 --> 00:29:50.480
It's a constant.

00:29:50.490 --> 00:29:51.690
It depends on the current port.

00:29:51.780 --> 00:29:53.660
Well, there is no current port.

00:29:53.790 --> 00:29:57.730
So we're going to be introducing a
replacement for this concept that

00:29:57.730 --> 00:30:02.470
probably passes in maybe a Cortext
font or something like that explicitly.

00:30:02.560 --> 00:30:04.810
That's something that
we have not done yet,

00:30:04.810 --> 00:30:08.270
but we will be doing it after the
seed and after the conference.

00:30:09.500 --> 00:30:11.880
The Carbon Event Manager.

00:30:12.110 --> 00:30:16.450
Back in 10.0,
we had this API called ToolboxObjects

00:30:16.580 --> 00:30:21.080
that we provided to let you use
Carbon Events to subclass some of

00:30:21.080 --> 00:30:23.400
the standard controls and windows.

00:30:23.400 --> 00:30:27.750
And then around 10.2,
we came out with the HIObjectManager as

00:30:27.750 --> 00:30:30.400
sort of a replacement for ToolboxObjects.

00:30:30.400 --> 00:30:34.400
And in 64-bit mode, we're just taking out
ToolboxObjects entirely,

00:30:34.400 --> 00:30:38.880
and the HIObject API is the
preferred and only way to create

00:30:38.910 --> 00:30:43.400
custom Carbon Event-based objects
and to subclass existing objects.

00:30:43.400 --> 00:30:46.840
So you want to use HIObjectRegister
subclass instead of using

00:30:46.840 --> 00:30:48.400
the ToolboxObject API.

00:30:48.400 --> 00:30:52.780
Another set of Carbon Events that's been
removed from 64-bit mode that I'll just

00:30:52.850 --> 00:30:57.610
call out is the various KEventWindowClick
something or other region,

00:30:57.770 --> 00:31:00.400
like KEventWindowClickDragRegion,
for example.

00:31:00.400 --> 00:31:06.400
Those Carbon Events were all originally
designed for non-compositing mode.

00:31:06.540 --> 00:31:09.400
And in fact, they've never been sent
for compositing windows.

00:31:09.400 --> 00:31:12.190
So if you've moved your
application to compositing mode,

00:31:12.190 --> 00:31:16.370
you've probably already figured this out,
that these event handlers for these

00:31:16.370 --> 00:31:18.400
events just aren't being called.

00:31:18.400 --> 00:31:23.360
In 64-bit, since there is no
non-compositing mode at all,

00:31:23.420 --> 00:31:25.830
we're just taking these constants
out of the headers when you

00:31:25.920 --> 00:31:27.350
compile for 64-bit targets.

00:31:27.400 --> 00:31:30.400
So you may have previously been getting
by with the KEventWindowClickDrag.

00:31:30.400 --> 00:31:32.190
You may have previously been getting
by with installing handlers for

00:31:32.190 --> 00:31:35.400
them that were never called if
you were using compositing mode.

00:31:35.400 --> 00:31:38.160
In 64-bit mode,
you'll actually get compilation

00:31:38.160 --> 00:31:41.400
errors if you try to install an
event handler for one of these.

00:31:41.970 --> 00:31:46.170
The Dialog Manager, as I mentioned,
is still there for compatibility

00:31:46.250 --> 00:31:50.060
and make it a little bit easier
to port your applications over.

00:31:50.060 --> 00:31:52.380
But it does always create
compositing windows.

00:31:52.400 --> 00:31:55.890
Now this has some interesting
implications for your application.

00:31:55.890 --> 00:32:00.900
Compositing windows are also going to
use the standard window event handler.

00:32:00.900 --> 00:32:05.450
That means that the window event handler
is going to grab all the Carbon events

00:32:05.490 --> 00:32:10.400
that go to that window before they
get passed back to the Dialog Manager.

00:32:10.400 --> 00:32:14.810
So if you're passing in a modal
filter event to a modal dialog,

00:32:14.880 --> 00:32:17.990
you're not going to see any of
the mouse downs or key downs or

00:32:17.990 --> 00:32:20.400
any other events that you might
have expected to see there.

00:32:20.400 --> 00:32:24.400
Those are all going to get picked up
by the standard window event handler.

00:32:24.490 --> 00:32:27.390
Instead, your modal filter will
only get null events.

00:32:27.400 --> 00:32:31.460
So if you need to actually handle
specific events in your dialog,

00:32:31.460 --> 00:32:34.540
specific user input events,
you want to do that by installing

00:32:34.540 --> 00:32:37.400
Carbon event handlers instead
of using a modal filter.

00:32:37.400 --> 00:32:39.890
And that will work just
fine in 32-bit mode as well.

00:32:39.900 --> 00:32:41.290
Thank you.

00:32:41.520 --> 00:32:46.740
Another option that we're providing
here is a new flag that you can put

00:32:46.750 --> 00:32:51.580
in your DLGX resource to specify
that you should get a compositing

00:32:51.580 --> 00:32:54.500
dialog window even in 32-bit mode.

00:32:54.740 --> 00:32:58.500
Previously, in 32-bit mode,
there was no way to create

00:32:58.550 --> 00:33:00.660
a compositing dialog window.

00:33:00.660 --> 00:33:03.290
And we're now providing that
capability so that if you want to

00:33:03.290 --> 00:33:07.500
have the same source space that
works in both 32-bit and 64-bit,

00:33:07.500 --> 00:33:10.460
we don't want to have to make you
branch your code and handle the

00:33:10.460 --> 00:33:14.500
non-compositing case for 32-bit and
the compositing case for 64-bit.

00:33:14.500 --> 00:33:17.850
So we're going to let you create
compositing dialog windows on both

00:33:17.850 --> 00:33:19.500
sides if that's useful to you.

00:33:21.700 --> 00:34:36.000
[Transcript missing]

00:34:36.940 --> 00:34:41.760
The Tech Services Manager,
going all the way back to pre-Mac OS X,

00:34:41.760 --> 00:34:45.360
the Tech Services Manager used to
send Apple events to communicate

00:34:45.360 --> 00:34:47.800
between input methods and applications.

00:34:47.820 --> 00:34:52.800
Starting in Mac OS X,
we introduced a suite of Carbon events,

00:34:52.800 --> 00:34:56.800
which was the preferred way for
TSM to communicate with applications.

00:34:56.800 --> 00:35:00.800
In 64-bit mode, that's the only way.

00:35:00.800 --> 00:35:02.800
The Apple events are no longer sent.

00:35:02.800 --> 00:35:05.950
So if you're using the TSM Apple events,
you need to switch off them and

00:35:05.950 --> 00:35:08.410
use the Carbon events instead.

00:35:09.650 --> 00:35:12.310
I mentioned we were introducing
some new API to replace some

00:35:12.320 --> 00:35:14.650
of the API that we've removed.

00:35:14.670 --> 00:35:17.970
A big chunk of the API that's gone,
of course, is Quickdraw.

00:35:18.020 --> 00:35:22.100
And that includes some other
things such as the display

00:35:22.280 --> 00:35:25.620
manager and the GD handle type.

00:35:25.620 --> 00:35:30.610
So the modern replacement for all the
display manager and GD handle interfaces

00:35:30.820 --> 00:35:34.230
is the Core Graphics Direct Display API.

00:35:34.330 --> 00:35:39.180
So we've introduced a new
Carbon Event parameter type

00:35:39.370 --> 00:35:42.320
called type CGDisplayID,
which is a CGDirectDisplayID.

00:35:42.320 --> 00:35:47.260
And we're using that in a
number of Carbon Events that

00:35:47.260 --> 00:35:49.820
used to take a GD handle.

00:35:49.820 --> 00:35:52.200
Now you might think that this
could cause problems for existing

00:35:52.200 --> 00:35:56.150
applications that are expecting to see
a GD handle in those Carbon Events,

00:35:56.180 --> 00:35:59.300
but we have an automatic
coercion facility in 32-bit mode.

00:35:59.300 --> 00:36:00.410
So that even though the
Carbon Event really contains

00:36:00.410 --> 00:36:01.040
a CGDirectDisplayID,
if you add a new Carbon Event parameter

00:36:01.040 --> 00:36:01.040
to the GD handle,
you can see that the GD handle

00:36:01.040 --> 00:36:01.040
is not going to be a problem.

00:36:01.040 --> 00:36:01.040
So we've introduced a new
Carbon Event parameter type

00:36:01.040 --> 00:36:01.040
called type CGDisplayID,
which is a CGDirectDisplayID.

00:36:01.040 --> 00:36:01.040
And we're using that in a
number of Carbon Events that

00:36:01.040 --> 00:36:01.040
used to take a GD handle.

00:36:01.040 --> 00:36:01.190
Now you might think that this
could cause problems for existing

00:36:01.190 --> 00:36:02.040
applications that are expecting to see
a GD handle in those Carbon Events.

00:36:02.040 --> 00:36:05.270
But even though the Carbon Event really
contains a CGDirectDisplayID,

00:36:05.270 --> 00:36:09.060
if you ask for a GD handle,
we'll convert it to a GD handle

00:36:09.060 --> 00:36:10.820
and give you that back.

00:36:10.820 --> 00:36:14.920
So that's the compatibility
mode for 32-bit mode.

00:36:14.970 --> 00:36:18.400
But for 64-bit mode,
there is no GD handle at all.

00:36:18.400 --> 00:36:24.780
So for best compatibility with 64-bit,
you will want to make your application

00:36:24.780 --> 00:36:28.980
use this type CGDisplayID explicitly
and explicitly be able to handle

00:36:28.980 --> 00:36:28.980
getting a CGDirectDisplayID.

00:36:28.980 --> 00:36:28.980
So that's the compatibility
mode for 32-bit.

00:36:28.980 --> 00:36:29.530
So that's the compatibility
mode for 32-bit mode.

00:36:29.530 --> 00:36:29.980
So that's the compatibility
mode for 32-bit mode.

00:36:29.980 --> 00:36:29.980
So that's the compatibility
mode for 32-bit mode.

00:36:29.980 --> 00:36:29.980
So that's the compatibility
mode for 32-bit mode.

00:36:29.980 --> 00:36:29.980
So that's the compatibility
mode for 32-bit mode.

00:36:29.980 --> 00:36:34.290
So that's the compatibility mode for
display ID back from these Carbon events.

00:36:34.320 --> 00:36:39.170
Display Manager also provided an
API for registering notifications when

00:36:39.170 --> 00:36:41.590
the display configuration changed.

00:36:41.750 --> 00:36:46.320
And we are now providing a Carbon event,
which kind of wraps that functionality.

00:36:46.530 --> 00:36:50.000
That's available in both
32-bit mode and 64-bit mode.

00:36:50.080 --> 00:36:52.280
So that's
KEventSystemDisplayReconfigured,

00:36:52.280 --> 00:36:55.860
and that'll be sent whenever
you get a display change.

00:36:55.930 --> 00:37:00.500
There was also some Window Manager API,
which used to take a GD handle

00:37:00.500 --> 00:37:04.980
or return a GD handle,
things like finding out which device

00:37:04.980 --> 00:37:09.410
contained the largest portion of
a window or what the positioning

00:37:09.410 --> 00:37:13.000
bounds on a particular display were
in which you could put a window.

00:37:13.140 --> 00:37:18.620
And we have some new API that now
take a CD direct display ID instead.

00:37:19.100 --> 00:37:24.760
A few other APIs here that kind of go
along with the removal of QuickDraw.

00:37:24.820 --> 00:37:30.590
The old GetMouse API was return
coordinates relative to the current port.

00:37:30.600 --> 00:37:33.090
Since there's no current port anymore,
we can't return

00:37:33.090 --> 00:37:34.600
coordinates relative to it.

00:37:34.600 --> 00:37:39.050
So we have a HIGetMousePosition API,
which explicitly takes a

00:37:39.130 --> 00:37:41.100
coordinate space parameter.

00:37:41.100 --> 00:37:45.750
So you can request the current mouse
position in the coordinate space

00:37:45.750 --> 00:37:50.500
of a view or of a window or in two
types of global coordinate spaces.

00:37:50.500 --> 00:37:55.630
And also TrackMouseLocation
used to return coordinates in

00:37:55.630 --> 00:37:58.500
the space of the current port.

00:37:58.500 --> 00:38:02.650
So again, we have a new HIView
TrackMouseLocation API,

00:38:02.650 --> 00:38:05.980
and that will return you
coordinates in the coordinate

00:38:05.990 --> 00:38:07.500
space of a particular view.

00:38:07.500 --> 00:38:11.000
And it's specifically designed to be
used with HIView and compositing windows.

00:38:11.000 --> 00:38:12.500
years.

00:38:13.270 --> 00:38:17.390
So that finishes up my 64-bit
presentation and I'm going to hop

00:38:17.390 --> 00:38:19.880
over to resolution independence.

00:38:19.880 --> 00:38:22.290
If you were here just an
hour ago for Guy's session,

00:38:22.320 --> 00:38:24.800
some of this will probably
be a bit of a review,

00:38:24.800 --> 00:38:27.350
but I'm going to go over
it just for anyone else who

00:38:27.350 --> 00:38:30.120
hasn't been here for that.

00:38:30.120 --> 00:38:33.020
So resolution independence,
as hopefully you know,

00:38:33.020 --> 00:38:36.060
is something that we introduced
in Tiger originally as a

00:38:36.070 --> 00:38:39.040
developer-only feature,
just a way for you to start playing

00:38:39.200 --> 00:38:42.850
around with it and to see how
well your applications worked.

00:38:42.940 --> 00:38:47.210
We're finishing it off in Leopard and we
have some significant changes in Leopard.

00:38:47.210 --> 00:38:50.190
We're at places where we're
improving the feature.

00:38:50.220 --> 00:38:53.110
Most of the standard controls
are now using high resolution art

00:38:53.240 --> 00:38:55.840
instead of the old bit mapped art.

00:38:55.840 --> 00:38:57.630
We haven't finished this
with all the controls yet,

00:38:57.630 --> 00:39:01.370
so certainly you'll see many places
where the standard controls still look

00:39:01.370 --> 00:39:06.010
a bit blocky when you scale things up,
but we will have those done by

00:39:06.080 --> 00:39:09.030
the time we finish with Leopard.

00:39:09.150 --> 00:39:13.730
We do have some resolution
independent specific APIs.

00:39:13.760 --> 00:39:18.170
The HIGetMousePosition API that I just
mentioned a minute ago is one of them.

00:39:18.220 --> 00:39:21.240
That API lets you choose the
coordinate space in which you

00:39:21.240 --> 00:39:24.190
get back the mouse position,
so you could get back a mouse

00:39:24.190 --> 00:39:27.870
position either in pixels,
if you need absolute

00:39:27.880 --> 00:39:30.920
pixel-specific coordinates,
or you can also get back the

00:39:30.980 --> 00:39:34.690
mouse position in points,
which is basically pixels divided

00:39:34.810 --> 00:39:37.320
through by the scaling factor.

00:39:37.970 --> 00:39:41.900
We will,
after the seed and after the conference,

00:39:42.010 --> 00:39:48.040
be introducing new APIs that allow
you to position and size windows and

00:39:48.040 --> 00:39:53.480
other objects at the global level
using explicit HIRect parameters,

00:39:53.500 --> 00:39:56.900
for example,
that have floating point coordinates.

00:39:56.900 --> 00:40:01.310
All the existing
WindowManager APIs in Carbon,

00:40:01.310 --> 00:40:05.860
unlike Cocoa,
in Carbon the APIs all assume that the

00:40:05.860 --> 00:40:08.900
coordinates are specified in points,
basically.

00:40:08.900 --> 00:40:11.900
So that's going to be the default no
matter what mode you're running in,

00:40:11.900 --> 00:40:15.030
and we'll have new APIs that if
you need to explicitly specify

00:40:15.110 --> 00:40:18.900
window coordinates in pixels,
you'll need to adopt those new APIs.

00:40:18.900 --> 00:40:24.900
I'm also going to talk a little bit
about policies for art and cursors.

00:40:24.900 --> 00:40:26.900
And finally,
something that Guy mentioned,

00:40:26.900 --> 00:40:30.900
last session,
is that the application scaled mode

00:40:30.900 --> 00:40:33.800
that we talked about last year,
we've realized it just

00:40:33.980 --> 00:40:34.900
doesn't make much sense.

00:40:34.900 --> 00:40:36.990
It's too hard for us
to implement properly,

00:40:36.990 --> 00:40:39.750
and it doesn't fit in with the
whole direction that we want you

00:40:39.750 --> 00:40:41.890
all to go of using compositing mode.

00:40:41.900 --> 00:40:45.940
So this application scaled mode,
which allowed QuickDraw-based

00:40:45.980 --> 00:40:49.990
applications to scale
their own window content,

00:40:49.990 --> 00:40:53.480
is no longer supported in Leopard,
and after the developers' conference,

00:40:53.480 --> 00:40:56.900
we're actually just going to remove the
constants from the header files entirely.

00:40:56.900 --> 00:41:00.190
So you'll still see them there right now,
but that's going to be

00:41:00.230 --> 00:41:01.900
gone by the time we ship.

00:41:03.900 --> 00:41:07.900
So that leads me into the scaling
modes that we do still support.

00:41:07.960 --> 00:41:10.040
And there are two.

00:41:10.040 --> 00:41:12.510
The first and the preferred one,
the one that we really

00:41:12.510 --> 00:41:15.670
want you all to adopt,
is called framework scaled mode.

00:41:15.830 --> 00:41:18.190
And this is the mode that
you can get if you're using

00:41:18.190 --> 00:41:21.180
compositing mode in your Windows.

00:41:21.180 --> 00:41:25.080
In this mode, the toolbox automatically
provides a transform,

00:41:25.080 --> 00:41:30.370
a core graphics FEN transform on
your CG context that's passed to your

00:41:30.370 --> 00:41:34.140
drawing event so that when you draw,
your drawing automatically

00:41:34.140 --> 00:41:37.740
gets scaled up according to the
user interface scaling factor.

00:41:37.740 --> 00:41:41.030
So this gives you really nice,
crisp text because your text is being

00:41:41.040 --> 00:41:43.100
scaled up by the Windows server.

00:41:43.270 --> 00:41:48.000
And if you can revise your artwork,
your content to have

00:41:48.030 --> 00:41:51.780
multiple resolutions,
then this will also give you nice,

00:41:51.870 --> 00:41:53.580
crisp artwork as well.

00:41:53.630 --> 00:41:56.640
It does require compositing
mode and quartz drawing.

00:41:56.640 --> 00:41:59.920
So in case you haven't figured it out,
please use compositing mode.

00:41:59.920 --> 00:42:00.890
Please draw with quartz.

00:42:01.900 --> 00:42:01.900
So this is the framework
that we do still support.

00:42:01.900 --> 00:42:04.300
And the other mode is magnified mode.

00:42:04.300 --> 00:42:11.620
And this is the default that you will
get running an unmodified application.

00:42:11.620 --> 00:42:16.080
And this includes unmodified
compositing mode applications.

00:42:16.080 --> 00:42:18.420
So even if you're already
using compositing mode,

00:42:18.420 --> 00:42:21.490
you still get magnified by default
because there might be cases where

00:42:21.490 --> 00:42:25.710
you still need to make changes to
your application to really work well.

00:42:26.250 --> 00:42:30.260
So in the magnified mode,
the window buffer that your

00:42:30.540 --> 00:42:34.850
windows draw into is just exactly
the same size as the coordinates

00:42:34.850 --> 00:42:36.960
in points that you're passing in.

00:42:37.020 --> 00:42:40.930
And then the Windows server just
magnifies that content up on the

00:42:40.930 --> 00:42:43.520
screen when it actually gets displayed.

00:42:43.520 --> 00:42:46.130
So this gives you blurry
text and blurry graphics,

00:42:46.130 --> 00:42:49.390
but it does maintain compatibility
with all the applications

00:42:49.390 --> 00:42:51.870
that are already out there,
especially those that

00:42:51.870 --> 00:42:53.100
are using Quick Draw.

00:42:53.770 --> 00:42:57.490
Another important point to note
is that you can mix both of

00:42:57.500 --> 00:42:59.100
these modes in your application.

00:42:59.100 --> 00:43:01.140
You don't have to convert
everything all at once.

00:43:01.140 --> 00:43:03.000
You can do this one window at a time.

00:43:03.000 --> 00:43:06.560
You can take an easy window and
convert it to compositing mode,

00:43:06.720 --> 00:43:10.310
try it out, see how that goes,
turn on framework scaling for that mode,

00:43:10.310 --> 00:43:14.120
and then as you gain more experience with
compositing mode and framework scaling,

00:43:14.120 --> 00:43:16.630
you can gradually move up
to the more complex windows

00:43:16.650 --> 00:43:18.650
and convert those as well.

00:43:20.720 --> 00:43:26.100
So the steps to move to a framework
scaled window user interface.

00:43:26.180 --> 00:43:31.320
Compositing mode is the very first one,
of course, and also using courts.

00:43:31.320 --> 00:43:33.970
And then once you've done that,
it's pretty simple.

00:43:33.990 --> 00:43:37.360
There's just a pop-up menu in IB when
you create your window in your Nib that

00:43:37.520 --> 00:43:40.250
specifies use this framework scale mode.

00:43:40.250 --> 00:43:44.610
You can also do this explicitly by
passing in the framework scaled window

00:43:44.610 --> 00:43:46.900
attribute when you create the window.

00:43:47.410 --> 00:43:50.960
And then once you've done that,
something to think about as you

00:43:51.190 --> 00:43:55.570
work through your application code
is that we define two different

00:43:56.010 --> 00:43:58.300
coordinate spaces in the toolbox.

00:43:58.300 --> 00:44:02.190
One of them is pixel-based,
and the other one is what we're

00:44:02.250 --> 00:44:05.980
calling a 72 DPI coordinate space,
although that's a bit of a

00:44:05.980 --> 00:44:10.260
misnomer because it isn't really
a 72 DPI coordinate space.

00:44:10.320 --> 00:44:13.290
But think of it as a
virtual coordinate space.

00:44:13.300 --> 00:44:17.050
It's the coordinate space that you get if
you take screen pixels and you divide it

00:44:17.060 --> 00:44:20.290
through by the resolution scaling factor.

00:44:20.360 --> 00:44:26.190
So this is the compatibility coordinate
space that all the existing APIs expect.

00:44:26.290 --> 00:44:30.920
If you have an API that doesn't take
an explicit parameter to specify

00:44:30.920 --> 00:44:33.720
which coordinate space you want,
then it's going to expect

00:44:33.780 --> 00:44:35.300
virtual coordinates.

00:44:35.570 --> 00:44:39.330
That maintains compatibility
with all of your existing code.

00:44:40.220 --> 00:44:44.260
You also have a screen pixel coordinate
space which you will be able to adopt

00:44:44.260 --> 00:44:46.100
explicitly if that's appropriate.

00:44:46.100 --> 00:44:49.560
And you can go back and forth between
these two coordinate spaces using

00:44:49.560 --> 00:44:52.100
several APIs that we introduced in Tiger.

00:44:52.100 --> 00:44:56.670
We have APIs for converting points,
sizes, and rectangles back and forth

00:44:56.670 --> 00:44:59.100
between different coordinate spaces.

00:44:59.100 --> 00:45:03.530
And finally,
there are a number of Carbon Events that

00:45:03.540 --> 00:45:10.100
have parameters that represent
global sizes or positions.

00:45:10.100 --> 00:45:12.700
Something like a K event
window bounds change,

00:45:12.700 --> 00:45:15.100
for example, as the bounds of a window.

00:45:15.100 --> 00:45:19.190
Now we have not fully resolved
this issue in the toolbox yet,

00:45:19.190 --> 00:45:22.090
but this is something we're
going to be moving towards

00:45:22.090 --> 00:45:24.100
after the developers conference.

00:45:24.100 --> 00:45:27.350
We have some new Carbon Event parameters
which explicitly specify the

00:45:27.350 --> 00:45:29.100
semantics that we're going
to be using in the toolbox.

00:45:29.100 --> 00:45:30.970
And we're going to be using
the same parameters that are

00:45:30.980 --> 00:45:32.030
defined by that parameter.

00:45:32.110 --> 00:45:36.270
So, for example, if we have an HIRect,
that HIRect could

00:45:36.290 --> 00:45:39.080
represent screen pixels,
or it could represent

00:45:39.430 --> 00:45:41.100
virtual coordinates.

00:45:41.150 --> 00:45:45.080
And you don't know a priori
which one it's going to be.

00:45:45.100 --> 00:45:49.060
So the policy that we've
defined is that by default,

00:45:49.060 --> 00:45:53.100
all the existing constants for
specifying event parameter types

00:45:53.100 --> 00:45:56.100
represent virtual coordinates.

00:45:56.100 --> 00:45:58.250
But you will also be able to explicitly
ask the Carbon Event Manager to

00:45:58.250 --> 00:46:02.720
translate from virtual coordinates
to pixel coordinates by using

00:46:02.730 --> 00:46:05.100
some new event parameter types.

00:46:05.100 --> 00:46:08.100
For example, type HIRectScreenPixel.

00:46:08.100 --> 00:46:12.330
If you pass that into GetEventParameter,
then the Carbon Event Manager will

00:46:12.350 --> 00:46:16.640
automatically translate the coordinates
from virtual coordinates to screen pixel

00:46:16.640 --> 00:46:19.090
coordinates and pass them out to you.

00:46:19.150 --> 00:46:21.100
And in fact,
probably what we'll wind up doing is

00:46:21.100 --> 00:46:24.110
we'll put the highest resolution data,
which is basically the screen

00:46:24.120 --> 00:46:27.100
pixel coordinate values,
into the Carbon Event,

00:46:27.100 --> 00:46:29.860
and then we'll translate the other
direction for the compatibility case.

00:46:33.760 --> 00:46:37.410
One of the issues that you will
definitely need to deal with to

00:46:37.410 --> 00:46:41.730
make your application resolution
independent is creating a lot of

00:46:41.730 --> 00:46:46.490
new artwork that is scaled up to
either a 2x or a 4x scale factor

00:46:46.490 --> 00:46:49.440
and using that in your application.

00:46:49.440 --> 00:46:51.520
So there are a couple
of ways you can do it.

00:46:51.670 --> 00:46:54.940
This slide talks about two of the
harder ways and I'm going to talk

00:46:55.000 --> 00:46:58.100
about an easier way a little bit later.

00:46:58.100 --> 00:47:01.580
So if you are explicitly
passing a CG image ref,

00:47:01.580 --> 00:47:04.760
for example,
into a standard view to specify the

00:47:04.790 --> 00:47:07.800
image that that view should display,
well,

00:47:07.800 --> 00:47:12.600
you can use ImageIO to get a CG image
source ref from your file on disk that

00:47:12.600 --> 00:47:16.470
has your multiple resolutions of artwork,
parse through the various

00:47:16.470 --> 00:47:19.770
resolutions that are available,
compare it to the scaling mode for

00:47:19.770 --> 00:47:22.880
the window and the scale factor,
and figure out which resolution

00:47:22.880 --> 00:47:27.370
is the best one for you to use,
and then you can send that particular

00:47:27.370 --> 00:47:29.580
CG image ref into the view.

00:47:29.580 --> 00:47:31.200
That's a little complicated.

00:47:31.320 --> 00:47:33.620
But it's perfectly straightforward.

00:47:33.630 --> 00:47:38.000
Another option, and going along with our
Cocoa integration capabilities,

00:47:38.000 --> 00:47:41.520
is that you will in the future,
before we ship Leopard,

00:47:41.700 --> 00:47:45.230
be able to pass an NSImage into
the standard views and use that

00:47:45.290 --> 00:47:47.120
to specify the image content.

00:47:47.120 --> 00:47:49.820
And in that case,
NSImage is going to automatically

00:47:49.820 --> 00:47:54.150
figure out which particular resolution
you're going to be able to support.

00:47:54.150 --> 00:47:56.990
That's not provided
yet in the seed build,

00:47:57.050 --> 00:47:59.760
but that's something we're
going to be working on.

00:47:59.850 --> 00:48:01.510
The third option,
which is going to be a little bit easier,

00:48:01.510 --> 00:48:03.980
which is going to be the easiest one,
and which I'll talk about in a

00:48:03.980 --> 00:48:08.140
little bit more detail later,
is that we are providing new

00:48:08.340 --> 00:48:13.260
capabilities to pass the path or just
the name of a file in your resources

00:48:13.330 --> 00:48:16.380
directory right into a view and say,
you know,

00:48:16.380 --> 00:48:20.560
grab the file from this location on
disk and just do the right thing.

00:48:20.560 --> 00:48:23.380
And that's probably going to be the best
solution for the vast majority of people.

00:48:23.610 --> 00:48:26.980
You'll just create your content,
stick it in your resources directory,

00:48:27.000 --> 00:48:29.790
pass in the path or the file name,
and we'll figure out the right

00:48:29.790 --> 00:48:30.740
resolution to use automatically.

00:48:30.740 --> 00:48:32.440
automatically.

00:48:33.570 --> 00:48:36.670
Another issue that comes up pretty
frequently is resolution independent

00:48:36.730 --> 00:48:40.690
cursors and how do you specify
different types of cursor data.

00:48:40.690 --> 00:48:44.840
Our preferred solution
here is to use NSCursor.

00:48:44.940 --> 00:48:47.900
NSCursor already has the
right support for this.

00:48:47.900 --> 00:48:50.690
There isn't really a lot
of value in us creating yet

00:48:50.700 --> 00:48:53.400
another API to wrap a Cocoa API.

00:48:53.400 --> 00:48:56.590
So we are going to point you
right at NSCursor and just suggest

00:48:56.590 --> 00:48:58.400
that you use NSCursor itself.

00:48:58.400 --> 00:49:00.630
NSCursor also supports 64-bit.

00:49:00.640 --> 00:49:04.340
We have a sample up on
developer.apple.com for

00:49:04.340 --> 00:49:08.180
showing how to use NSCursor in
a Carbon application already.

00:49:08.180 --> 00:49:12.630
We will be talking about this more in
the Cocoa for Carbon Developer session.

00:49:12.670 --> 00:49:19.730
Please do attend that one as well.

00:49:26.760 --> 00:49:33.160
So those were our two biggest features
for Leopard and the Toolbox that was

00:49:33.230 --> 00:49:35.790
64-bit and resolution independence.

00:49:35.860 --> 00:49:38.340
I'm going to run over a few
smaller features that we've

00:49:38.420 --> 00:49:39.800
added as well along the way.

00:49:39.820 --> 00:49:44.490
And the first one is handling
Apple events using Carbon Event Handlers.

00:49:45.040 --> 00:49:48.400
This is actually something that
I think it's come up several times

00:49:48.400 --> 00:49:50.240
on the Carbon development list.

00:49:50.240 --> 00:49:52.700
Someone will post, "Well,
I installed my Apple Event Handler

00:49:52.700 --> 00:49:55.640
using GetEventHandler,
but it's never being called.

00:49:55.710 --> 00:49:58.800
Why's that?" That's
because it doesn't work.

00:49:58.950 --> 00:50:00.000
But now it does.

00:50:00.000 --> 00:50:04.180
We've hooked up some interfaces
into the Apple Event Manager so

00:50:04.180 --> 00:50:09.470
that you can actually call the
regular InstallEventHandler

00:50:09.620 --> 00:50:11.000
API in the Carbon Event Manager.

00:50:11.000 --> 00:50:15.990
And you can pass in a regular
Carbon Event Handler callback function

00:50:15.990 --> 00:50:19.000
and use that to receive Apple events.

00:50:19.040 --> 00:50:20.900
In this case,
you would be installing your

00:50:20.900 --> 00:50:23.000
Event Handler on the application target.

00:50:23.000 --> 00:50:26.530
That's the only place that
the event is going to be sent.

00:50:26.730 --> 00:50:30.330
And when your application or
when run application event loop

00:50:30.360 --> 00:50:34.700
calls a process Apple event,
the Apple event manager will dispatch

00:50:34.780 --> 00:50:38.370
the Apple event through the normal
Apple event dispatching handlers,

00:50:38.370 --> 00:50:42.140
but before it does that,
it gives it back to the toolbox to

00:50:42.140 --> 00:50:46.720
give us a chance to send it through
the Carbon event dispatching chain.

00:50:46.720 --> 00:50:51.480
So that's when your handler is going to
be called inside AEProcess Apple event.

00:50:51.480 --> 00:50:56.120
And all you need to do is just pass
the Apple event class and kind into

00:50:56.120 --> 00:51:00.080
install event handler when you're
registering your Carbon event handler,

00:51:00.080 --> 00:51:03.110
and from then on it's basically
like you just have a regular

00:51:03.110 --> 00:51:04.800
Carbon event to handle.

00:51:05.230 --> 00:51:09.160
So for example,
you can use getEvent parameter

00:51:09.200 --> 00:51:12.580
on the event ref that your
Carbon event handler receives,

00:51:12.580 --> 00:51:15.470
and that will actually pull event
parameters out of the Apple event

00:51:15.480 --> 00:51:18.440
that is backing up the Carbon event.

00:51:18.500 --> 00:51:20.420
There are some caveats here.

00:51:20.440 --> 00:51:24.550
If you are accessing an array
parameter from the Apple event,

00:51:24.560 --> 00:51:28.660
let's say you are handling
the Open Document Apple event,

00:51:28.660 --> 00:51:31.160
and that has a parameter
that is an AE list.

00:51:31.160 --> 00:51:35.400
It's a list of AE desks,
and each one contains an FSRef,

00:51:35.400 --> 00:51:36.460
let's say.

00:51:36.470 --> 00:51:39.500
In that case,
what you really want to do is you

00:51:39.500 --> 00:51:43.690
want to pass typeAelist in your
first call to getEvent parameter

00:51:43.860 --> 00:51:47.540
to get out an AE desk list,
and then you can use the Apple event

00:51:47.660 --> 00:51:51.180
manager APIs to pull out each
AE desk from that AE list.

00:51:51.210 --> 00:51:53.480
And in that case,
you also need to release

00:51:53.530 --> 00:51:55.270
the AE desk list afterwards.

00:51:55.920 --> 00:51:58.260
There are probably cases where
you're going to need to get

00:51:58.260 --> 00:52:01.800
the original Apple event or
the original reply Apple event.

00:52:01.820 --> 00:52:06.400
So we do also provide some special
event parameters to allow you

00:52:06.400 --> 00:52:07.800
to get that information out.

00:52:07.800 --> 00:52:12.470
I mentioned here the event
parameter name AEVT together with

00:52:12.470 --> 00:52:16.200
parameter type AppleEvent will get
you the original Apple event that

00:52:16.200 --> 00:52:18.800
was backing up the Carbon event.

00:52:18.800 --> 00:52:20.800
And you can do the same
thing for the reply.

00:52:20.810 --> 00:52:25.870
And if you need to put data back
into the reply Apple event right now,

00:52:25.940 --> 00:52:27.800
you cannot use setEvent parameter.

00:52:27.800 --> 00:52:29.630
That's something I'm
going to implement later,

00:52:29.760 --> 00:52:30.770
but it's not hooked up yet.

00:52:30.800 --> 00:52:33.780
So in that case,
you want to get the reply Apple event

00:52:33.780 --> 00:52:38.780
out of the Carbon event and then just
set data directly into the reply.

00:52:38.800 --> 00:52:43.980
So we're going to put a sample app up
on developer.apple.com after the seed

00:52:43.990 --> 00:52:46.870
that shows how to use some of this stuff.

00:52:48.090 --> 00:52:51.830
HiObjectDelegates is another
API that we've added that's

00:52:51.830 --> 00:52:54.090
part of the HiObjectManager.

00:52:54.110 --> 00:52:57.160
And it's a little bit reminiscent
of some other frameworks.

00:52:57.250 --> 00:53:03.410
It's a way to add extra behavior
onto an existing HiObject without

00:53:03.410 --> 00:53:07.960
actually subclassing it or installing
a bunch of event handlers yourself.

00:53:07.960 --> 00:53:12.120
So essentially the idea is
that you have one HiObject,

00:53:12.150 --> 00:53:16.260
which we call the target HiObject,
and a second HiObject,

00:53:16.260 --> 00:53:17.940
which we call the delegate.

00:53:17.940 --> 00:53:20.960
You install the delegate onto the target.

00:53:20.960 --> 00:53:25.080
And then the delegate HiObject
receives all the Carbon events that

00:53:25.170 --> 00:53:27.460
are sent to the target HiObject.

00:53:27.460 --> 00:53:32.540
And so this has some nice advantages
over some of the older ways of doing it.

00:53:32.800 --> 00:53:38.400
Obviously the delegate HI object
being an object itself combines all

00:53:38.400 --> 00:53:43.770
of its data and handlers in one place,
provides a nice bit of packaging there.

00:53:44.220 --> 00:53:47.200
If you are a client of a delegate,
you don't have to know

00:53:47.200 --> 00:53:50.480
exactly which event handlers
the delegate is installing.

00:53:50.580 --> 00:53:54.630
All you need to do is install
the delegate and you're done.

00:53:54.700 --> 00:53:57.760
Finally,
the delegate has the ability to have

00:53:57.880 --> 00:54:02.160
some control over which order its
event handlers are called relative to

00:54:02.160 --> 00:54:04.600
the target object's event handlers.

00:54:04.710 --> 00:54:08.430
So you can install the delegate
either before or after the handlers

00:54:08.530 --> 00:54:10.300
that are on the target object.

00:54:10.300 --> 00:54:13.620
And that guarantees, for example,
that the delegate's handlers

00:54:13.690 --> 00:54:16.770
will always be called before
the target object's handlers.

00:54:17.130 --> 00:54:22.590
So we're going to use this
capability to try to provide some

00:54:22.790 --> 00:54:27.400
standard delegate objects for
you to use in your application.

00:54:27.590 --> 00:54:31.260
We know that a lot of you would
like to bring some degree of

00:54:31.320 --> 00:54:35.130
Cocoa technology into your application,
but we don't want to make you rewrite

00:54:35.130 --> 00:54:37.160
your entire application in Cocoa.

00:54:37.160 --> 00:54:41.830
So what we would like to do is allow
you to sort of drop little bits of

00:54:41.830 --> 00:54:46.840
functionality into your app very
simply without having to make you

00:54:46.850 --> 00:54:49.540
modify the entire application to do it.

00:54:49.710 --> 00:54:53.470
So we're going to use this
specifically for some bridges

00:54:53.470 --> 00:54:55.550
between Carbon and Cocoa.

00:54:55.670 --> 00:54:59.530
Before I go into that,
I'm going to run briefly over the API.

00:54:59.560 --> 00:55:01.560
It's really a very simple API.

00:55:01.560 --> 00:55:05.560
There's just an add delegate
API to install the delegate

00:55:05.560 --> 00:55:10.460
on the target object,
a removal API to remove it, and finally,

00:55:10.460 --> 00:55:15.040
if you are writing code that's inside
the delegate event handler and you

00:55:15.040 --> 00:55:19.590
want to know what the target object is,
there's an HI object get event

00:55:19.590 --> 00:55:24.550
handler object API which will return
you the original target object.

00:55:24.560 --> 00:55:25.610
Thank you.

00:55:25.960 --> 00:55:28.200
So let's see here.

00:55:28.200 --> 00:55:30.940
I'm going to do a quick little
demo of how this capability

00:55:30.940 --> 00:55:32.400
is used in the toolbox.

00:55:32.400 --> 00:55:37.900
And we have a demo machine
with the Intel up here.

00:55:37.900 --> 00:55:43.690
Let's see, we can close this project.

00:55:47.350 --> 00:55:52.440
So I have a basic little
Carbon application here.

00:55:52.440 --> 00:55:58.110
And when I run this Carbon application,

00:55:58.870 --> 00:56:02.700
Here we have just a little field,
a little edit Unicode text field,

00:56:02.700 --> 00:56:04.600
and nothing special about it.

00:56:04.600 --> 00:56:07.700
It accepts all sorts of
characters being typed into it.

00:56:07.700 --> 00:56:11.940
But maybe I want to modify my
application so that this field

00:56:12.020 --> 00:56:14.700
only accepts numeric text input.

00:56:14.700 --> 00:56:16.670
Well, I could do that.

00:56:16.700 --> 00:56:19.700
I could write some Carbon Event Handlers
to handle the various Carbon Events that

00:56:19.840 --> 00:56:23.040
allow you to filter text input
and write all the necessary

00:56:23.170 --> 00:56:24.700
formatting and analysis code.

00:56:24.700 --> 00:56:28.810
But it turns out that Cocoa already
has this really handy little

00:56:28.810 --> 00:56:30.700
NSNumericFormatter class.

00:56:30.700 --> 00:56:35.920
And so what we've done in the toolbox
is we've implemented a delegate that

00:56:36.210 --> 00:56:42.700
can be installed on a text field that
uses the NSNumericFormatter class.

00:56:42.810 --> 00:56:46.340
And it uses it to determine
whether the text being edited

00:56:46.340 --> 00:56:48.700
is actually in a numeric format.

00:56:48.700 --> 00:56:52.580
So I'm going to enable a
little bit of code here.

00:56:53.410 --> 00:56:55.330
What we're doing here,
first we're just finding the

00:56:55.330 --> 00:56:57.320
Edit Text field right there.

00:56:57.360 --> 00:57:01.300
I'm going to create the delegate
object using this class ID here.

00:57:01.300 --> 00:57:03.610
Currently we don't have any
header files that define the

00:57:03.610 --> 00:57:05.950
delegates we're providing,
but we will be providing

00:57:05.950 --> 00:57:07.290
those header files later.

00:57:07.300 --> 00:57:11.300
I'll add the delegate
to the Edit Text field,

00:57:11.490 --> 00:57:15.300
release the delegate since it's been
retained by HIObjectAddDelegate,

00:57:15.300 --> 00:57:17.610
rebuild.

00:57:18.020 --> 00:57:22.000
Thank you.

00:57:22.000 --> 00:57:23.000
I need #F1.

00:57:23.000 --> 00:57:25.000
All right.

00:57:25.000 --> 00:57:27.000
F1.

00:57:27.000 --> 00:57:29.660
Rebuild again.

00:57:29.660 --> 00:57:31.500
Let's try this now.

00:57:32.920 --> 00:57:36.340
Now we can see that I'm typing
on the ASCII characters here.

00:57:36.340 --> 00:57:39.400
There's nothing coming in,
but if I type on the numeric ones,

00:57:39.400 --> 00:57:40.750
then we can get that.

00:57:40.760 --> 00:57:45.650
I can only insert a single period
because otherwise it would not

00:57:45.650 --> 00:57:47.580
be using the correct format.

00:57:47.580 --> 00:57:51.420
So that's an easy way to introduce
some Cocoa technology right into your

00:57:51.420 --> 00:57:56.280
application without having to modify your
application to use Cocoa in a big way.

00:57:56.280 --> 00:58:00.410
Now let's go back to the slides.

00:58:01.170 --> 00:58:04.540
So the next thing I want to talk
about here is menu item views.

00:58:04.540 --> 00:58:08.590
This is the ability to embed
an HIView directly into a menu.

00:58:08.670 --> 00:58:12.330
You're already seeing this in the
operating system in a number of places.

00:58:12.370 --> 00:58:15.950
You see it in the finder where
it has its label color picker.

00:58:16.130 --> 00:58:20.740
You see it in the new spotlight help menu
where we have an edit field right in the

00:58:20.740 --> 00:58:22.890
help menu that lets you type into it.

00:58:22.960 --> 00:58:27.460
And this is also being provided via
AppKit via a similar AppKit API.

00:58:28.420 --> 00:58:32.400
So the menu manager in this case is going
to automatically create your HIView.

00:58:32.400 --> 00:58:35.300
It's going to automatically
position and resize it.

00:58:35.300 --> 00:58:37.900
It will forward accessibility
requests into your view,

00:58:37.900 --> 00:58:41.370
so your view is considered to be
an accessible child of the menu.

00:58:41.370 --> 00:58:44.060
And it automatically handles
keyboard focus as well.

00:58:44.190 --> 00:58:46.860
And in this case it's really
simple to adopt this because you

00:58:46.930 --> 00:58:49.870
don't have to do anything special
in your HIView to enable it.

00:58:49.960 --> 00:58:53.140
You basically just implement the
getOptimalBounds Carbon event

00:58:53.140 --> 00:58:56.410
if you aren't already,
so that the menu manager knows

00:58:56.460 --> 00:58:58.300
how big your view wants to be.

00:58:58.380 --> 00:59:00.280
And then the menu manager
takes care of the rest.

00:59:00.280 --> 00:59:04.300
Finally, if your view needs to resize
while the menu is open,

00:59:04.300 --> 00:59:07.300
you can also send this new
Carbon event we've defined,

00:59:07.300 --> 00:59:11.910
kEventControlOptimalBoundsChanged,
and the menu manager will pick that

00:59:11.990 --> 00:59:14.300
up and resize the menu automatically.

00:59:14.360 --> 00:59:17.890
Again, this is a pretty simple API.

00:59:18.320 --> 00:59:22.090
The interesting thing here is
that you don't actually pass

00:59:22.090 --> 00:59:26.300
an HIView instance itself in to
specify the HIView for a menu.

00:59:26.470 --> 00:59:28.260
You pass the HIView.

00:59:28.400 --> 00:59:30.250
And then you can see that
the view is not visible.

00:59:30.320 --> 00:59:33.890
And that's because the menu manager may
need to create multiple instances of

00:59:33.890 --> 00:59:36.270
your view if the menu gets displayed,
say,

00:59:36.360 --> 00:59:39.300
as both a pulldown menu and a popup menu.

00:59:39.300 --> 00:59:43.100
You might need to find the
view -- find the menu item that

00:59:43.100 --> 00:59:45.300
contains a view at runtime.

00:59:45.300 --> 00:59:49.300
You can do that with HIView
getting closing menu item.

00:59:49.300 --> 00:59:52.290
And you might need to cancel
menu tracking explicitly.

00:59:52.300 --> 00:59:56.280
And we have HIView cancel
menu tracking for that case.

00:59:56.400 --> 00:59:58.300
So let's do another
quick demo of this one.

00:59:58.300 --> 01:00:00.580
Back to the Intel machine.

01:00:11.300 --> 01:00:15.440
So again, this is a very simple
standard Carbon application.

01:00:15.570 --> 01:00:19.200
Looking in the File menu here,
note that there's nothing unusual

01:00:19.200 --> 01:00:20.290
about this particular menu.

01:00:20.290 --> 01:00:24.640
It's just exactly as it
would be in a basic template.

01:00:24.750 --> 01:00:27.950
This time, let's do this first.

01:00:28.030 --> 01:00:30.700
Here's a little bit of code to
enable using a menu item view

01:00:30.700 --> 01:00:33.090
for the Page Setup menu item.

01:00:33.220 --> 01:00:36.190
First, I'll find the Page Setup item.

01:00:36.530 --> 01:00:38.910
Now I'm going to create the
initialization event that's

01:00:38.910 --> 01:00:41.790
going to be used by the view
I'm going to put in the menu.

01:00:41.860 --> 01:00:46.000
And in this case I'm just going to set an
event parameter in there that specifies

01:00:46.030 --> 01:00:48.740
the title for that particular view.

01:00:48.890 --> 01:00:52.440
Then I'm going to make
that view use the checkbox.

01:00:52.570 --> 01:00:55.160
Make that menu item
use the checkbox view.

01:00:55.160 --> 01:00:58.990
So now, when I run this application,

01:00:59.450 --> 01:01:02.590
The menu manager will
automatically replace the page

01:01:02.590 --> 01:01:04.300
setup item with a checkbox.

01:01:04.300 --> 01:01:05.840
And this is fully enabled.

01:01:05.910 --> 01:01:07.280
You can click on it.

01:01:07.280 --> 01:01:10.910
You can also use the arrow keys to go
up and down and that will put focus

01:01:10.910 --> 01:01:15.260
on it and then I can use the keyboard
to enable and disable that particular

01:01:15.260 --> 01:01:17.820
check and uncheck that particular item.

01:01:17.820 --> 01:01:21.270
So that is something that you may find
useful in your applications as well.

01:01:21.270 --> 01:01:24.350
Okay, back to slides.

01:01:26.150 --> 01:01:30.060
Something I touched on
earlier is the ability to have

01:01:30.060 --> 01:01:32.740
file-based image view content.

01:01:32.740 --> 01:01:38.630
That's the capability to pass in
the path or the name of a particular

01:01:38.860 --> 01:01:42.390
file on disk and then the toolbox
will automatically load that file

01:01:42.390 --> 01:01:44.100
and display it in a standard view.

01:01:44.100 --> 01:01:46.810
So this is supported by a
bunch of the standard views

01:01:46.810 --> 01:01:51.100
already such as the push button,
the bevel button, and quite a few others.

01:01:51.100 --> 01:01:54.100
It's not supported in all of
them but we're getting there.

01:01:54.100 --> 01:01:58.190
It's also important for resolution
independence because you'll be able

01:01:58.190 --> 01:02:02.270
to pass in the path to a file that
has multiple resolutions inside it and

01:02:02.270 --> 01:02:06.100
then the toolbox will automatically
pick the best resolution for display

01:02:06.100 --> 01:02:08.100
given the current scaling factor.

01:02:08.100 --> 01:02:11.480
That particular aspect of this
feature is not yet supported in

01:02:11.480 --> 01:02:14.640
the developer's conference seed
but we will be implementing that

01:02:14.640 --> 01:02:17.100
after the developer's conference.

01:02:17.100 --> 01:02:21.770
And we're also planning some support
here for passing in NSImages.

01:02:22.530 --> 01:02:26.400
Finally, a brief mention of the
Text Input Sources API.

01:02:26.400 --> 01:02:31.170
This is a new API that is meant
for handling various types of input

01:02:31.170 --> 01:02:35.900
sources such as text input methods,
palettes such as character palette,

01:02:35.900 --> 01:02:37.180
and also ink.

01:02:37.450 --> 01:02:42.090
And there's a bunch of APIs that
are being deprecated in Leopard

01:02:42.220 --> 01:02:46.400
including parts of the script manager,
the keyboard layout manager,

01:02:46.400 --> 01:02:48.400
and parts of the text services manager.

01:02:48.400 --> 01:02:52.390
And the Text Input Sources API is
designed to replace all of those.

01:02:52.400 --> 01:02:55.400
So there's an entire
session talking about this.

01:02:55.400 --> 01:03:00.370
If you deal with text input in your
application in a very detailed fashion

01:03:00.450 --> 01:03:03.500
or if you write text input methods,
you definitely want to

01:03:03.500 --> 01:03:04.400
go see this session.
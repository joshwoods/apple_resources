WEBVTT

00:00:10.550 --> 00:00:12.250
Good afternoon.

00:00:12.270 --> 00:00:18.690
Last year at WWDC, if you remember,
we had a little surprise for you.

00:00:18.700 --> 00:00:23.700
That's, of course, when we announced our
switch to Intel processors.

00:00:23.700 --> 00:00:28.330
And after the conference,
all my colleagues at Apple went

00:00:28.330 --> 00:00:33.000
back to Cupertino and worked really
hard for a number of months to

00:00:33.030 --> 00:00:35.360
be able to surprise you again.

00:00:35.360 --> 00:00:40.920
And that was at Macworld,
when Paul Ottolini, the CEO of Intel,

00:00:40.920 --> 00:00:44.490
came on stage to hand the
symbolic wafer to Steve.

00:00:44.500 --> 00:00:47.480
And after that, back to work.

00:00:47.580 --> 00:00:53.140
And in the months that followed,
with pretty good regularity,

00:00:53.140 --> 00:00:58.120
we turned the entire line,
so that as of this morning,

00:00:58.120 --> 00:00:59.750
the transition is complete.

00:00:59.820 --> 00:01:04.760
Now, we could not have done such
transition in so little time if

00:01:04.760 --> 00:01:05.250
Paul Ottolini had not been there.

00:01:05.380 --> 00:01:10.380
We didn't have a vertically integrated
company where hardware and software

00:01:10.380 --> 00:01:13.160
work hand-in-hand to make it happen.

00:01:13.160 --> 00:01:20.770
So we design the hardware,
we design the software, and all together,

00:01:20.770 --> 00:01:24.610
that brings a tremendous user experience.

00:01:24.640 --> 00:01:25.550
That's our goal.

00:01:25.550 --> 00:01:26.650
That's our mission.

00:01:26.660 --> 00:01:33.160
So this integration of hardware and
software is going to drive the agenda

00:01:33.440 --> 00:01:35.320
today for the State of the Union.

00:01:35.320 --> 00:01:41.340
We'll start with hardware topics,
things like the CPU, memories, GPU,

00:01:41.340 --> 00:01:42.240
all those things.

00:01:42.260 --> 00:01:44.870
And from those topics,
we'll move on to the

00:01:44.870 --> 00:01:46.660
software implications.

00:01:46.660 --> 00:01:52.380
So, at the heart of a computer...

00:01:54.440 --> 00:01:57.400
You have, of course, the CPU.

00:01:57.530 --> 00:02:01.180
And our latest addition is a 64-bit CPU.

00:02:01.180 --> 00:02:06.100
So to talk about the CPU,
I'd like to welcome on

00:02:06.260 --> 00:02:11.190
stage Simon Patience,
who is VP of CoreOS.

00:02:17.790 --> 00:02:19.230
Good afternoon.

00:02:19.360 --> 00:02:22.570
Well, it seems appropriate that somebody
from the core of the software

00:02:22.570 --> 00:02:26.210
operating system should be coming
here to talk to you about the CPU,

00:02:26.210 --> 00:02:29.730
which is the core of the
hardware of the machine.

00:02:29.980 --> 00:02:34.140
So I'd like to start this talk with
a little trip down memory lane.

00:02:34.160 --> 00:02:39.440
And processors originally had
a word width of four bits,

00:02:39.440 --> 00:02:41.420
which was clearly not enough.

00:02:41.440 --> 00:02:45.370
And so fairly quickly we moved
through the 8-bit processors.

00:02:45.480 --> 00:02:49.450
16 seemed to be a reasonable amount,
but that didn't last for that long

00:02:49.460 --> 00:02:51.050
until finally we settled on 32.

00:02:51.060 --> 00:02:56.580
And 32-bit processors have been in use
now for 20 years and have done us well.

00:02:56.820 --> 00:02:59.950
But more recently,
we've moved ahead and to 64-bit

00:02:59.950 --> 00:03:05.240
processors with the introduction
of the G5 and of the Xeon,

00:03:05.240 --> 00:03:07.450
as you heard this morning.

00:03:08.150 --> 00:03:10.430
So why would we want to go to 64-bit?

00:03:10.790 --> 00:03:13.240
Well, there's a number of reasons.

00:03:13.340 --> 00:03:15.320
The first is computational speed.

00:03:15.550 --> 00:03:17.890
We have an instruction
set that's optimized,

00:03:17.920 --> 00:03:20.440
that doesn't have the legacy
baggage that it has to carry on,

00:03:20.440 --> 00:03:24.960
and so can be highly performant and fast.

00:03:25.010 --> 00:03:28.680
On Intel,
we also have many more registers

00:03:29.100 --> 00:03:32.380
than we had previously,
and that means fewer memory references,

00:03:32.420 --> 00:03:35.960
and that in itself is a major
performance improvement.

00:03:36.440 --> 00:03:40.800
The second reason is that we have a
much larger virtual address space.

00:03:40.800 --> 00:03:44.000
Now, for people who have large data sets,
that's very important.

00:03:44.000 --> 00:03:46.480
There's no data window
moving across your data set,

00:03:46.480 --> 00:03:49.800
which makes it more efficient
because there's no remapping,

00:03:49.800 --> 00:03:51.470
but also it's a lot simpler.

00:03:53.380 --> 00:03:56.190
In addition,
with a large virtual address space

00:03:56.270 --> 00:04:00.230
comes a large physical address space,
lots of RAM in our machines.

00:04:00.240 --> 00:04:03.740
And if we look at the historical
trends of our machines,

00:04:03.740 --> 00:04:07.680
this is the maximal configuration that
you can buy from Apple over the years.

00:04:07.680 --> 00:04:09.810
You can see we've been stuck
underneath that red line.

00:04:09.820 --> 00:04:14.340
That's the 4 gigabyte or 32-bit physical
boundary until we had the introduction

00:04:14.380 --> 00:04:19.660
of the G5 and now suddenly our physical
memory configurations have leapt up.

00:04:20.800 --> 00:04:21.440
So where are we?

00:04:21.570 --> 00:04:26.920
So in Tiger on PowerPC 64-bit,
we have a 64-bit virtual

00:04:26.920 --> 00:04:28.700
address space for applications.

00:04:28.780 --> 00:04:32.020
We use the industry standard
programming model LP64,

00:04:32.100 --> 00:04:35.020
that's 64-bit longs and pointers.

00:04:35.100 --> 00:04:38.660
And we introduced a single binary
package that allowed you to take a 32-bit

00:04:38.660 --> 00:04:42.710
executable and a 64-bit executable,
put them in the same package,

00:04:42.800 --> 00:04:45.780
which you could then install
anywhere and it would run.

00:04:46.130 --> 00:04:50.980
And we were targeting the Unix
application or command line for 64 bits.

00:04:51.000 --> 00:04:56.410
So if we look at our software stack,
then for Tiger, this is the target,

00:04:56.600 --> 00:04:57.990
it was Unix.

00:04:58.000 --> 00:04:59.800
Now that was for PowerPC.

00:05:00.200 --> 00:05:03.030
Now today we've announced the
Intel Xeon in the Mac Pro,

00:05:03.030 --> 00:05:05.000
and we have the exact same functionality.

00:05:05.020 --> 00:05:10.330
We have the Unix functionality,
64-bit libraries for

00:05:10.330 --> 00:05:12.890
Intel and for the PowerPC.

00:05:15.220 --> 00:05:18.020
So that's Tiger.

00:05:18.020 --> 00:05:20.340
So what about Leopard?

00:05:20.360 --> 00:05:23.760
Well,
we go look at our software stack again.

00:05:23.760 --> 00:05:27.890
This is the software stack and
we've extended the 64-bit support

00:05:28.430 --> 00:05:30.060
all the way up the software stack.

00:05:30.090 --> 00:05:36.310
So we now have full 64-bit application
support including Carbon and Cocoa.

00:05:36.540 --> 00:05:40.750
Now just like the 64-bit processors
have managed to lose a little bit

00:05:40.750 --> 00:05:43.790
of legacy in their instructions
when they went to 64-bit,

00:05:43.880 --> 00:05:45.780
we're losing a little bit of legacy also.

00:05:45.880 --> 00:05:49.710
So there's no 64-bit quick draw,
but we do have the

00:05:49.720 --> 00:05:51.760
modern courts framework.

00:05:52.170 --> 00:05:55.920
There's no 64-bit
low-level QuickTime APIs,

00:05:55.970 --> 00:05:59.700
but we have QtKit providing
that functionality.

00:05:59.700 --> 00:06:01.800
No 64-bit sound manager?

00:06:01.900 --> 00:06:03.980
Core Audio does that for you.

00:06:03.980 --> 00:06:09.740
And finally, there's no 64-bit CFM,
and we have no replacement,

00:06:09.740 --> 00:06:12.570
and we don't believe that's a problem.

00:06:18.890 --> 00:06:24.660
So I'd like to dispel a little myth
that is that 64-bit is always faster.

00:06:24.860 --> 00:06:27.900
Now, 32-bit has smaller
fundamental data types.

00:06:27.900 --> 00:06:31.090
And so sometimes it can be faster
because you have a smaller heap,

00:06:31.160 --> 00:06:33.960
a smaller footprint,
less memory pressure on the system.

00:06:34.060 --> 00:06:37.740
So it's a trade-off,
and you have to work out what is correct.

00:06:38.410 --> 00:06:43.140
But we have tools for 64-bit ready
to go for both PowerPC and for Intel.

00:06:43.280 --> 00:06:46.360
We have this new little
pull-down panel here,

00:06:46.360 --> 00:06:49.140
which allows you to specify whether
you want to build for a 64-bit

00:06:49.140 --> 00:06:52.540
or a 32-bit or both application.

00:06:52.700 --> 00:06:56.110
And so what I'd like to do now is to
show you a little bit about what a

00:06:56.110 --> 00:06:58.710
64-bit application could do for you.

00:07:03.540 --> 00:07:05.500
Okay, I have this project here.

00:07:05.500 --> 00:07:09.140
Let's quickly look at the targets.

00:07:09.250 --> 00:07:15.080
You can see actually we're building both
a 32-bit version and a 64-bit version.

00:07:15.080 --> 00:07:17.450
This is the new pull-down panel.

00:07:19.320 --> 00:07:25.790
So what I'll do now is I'll launch the
32-bit version of this application.

00:07:26.620 --> 00:07:29.940
So what this application does is
it processes a four gigabyte file

00:07:29.940 --> 00:07:34.210
of DNA data and is actually using
that data to render an image of the

00:07:34.210 --> 00:07:37.730
helix or various images of the helix.

00:07:37.850 --> 00:07:40.720
Now this file is too big to fit
into a 32-bit address space,

00:07:40.750 --> 00:07:44.610
so we're having to move an
address window across it.

00:07:45.130 --> 00:07:48.500
And it's also very compute
intensive and very memory intensive.

00:07:48.550 --> 00:07:52.000
So you can see it's pretty slow.

00:07:52.050 --> 00:07:55.810
So let's launch the 64-bit
version of the same app.

00:07:58.370 --> 00:08:03.550
So the 64-bit version,
the entire file is able

00:08:03.560 --> 00:08:06.140
to be mapped into memory,
so there's no remapping of a window.

00:08:06.140 --> 00:08:10.740
We're running on the Mac Pro on
this with 8 gigabytes of memory,

00:08:10.740 --> 00:08:14.000
so we can actually put all of
the file into physical memory,

00:08:14.000 --> 00:08:17.080
which is helping the 64-bit application,
but doesn't appear to be

00:08:17.090 --> 00:08:18.780
helping the 32-bit version.

00:08:18.780 --> 00:08:22.580
And the compiler is taking full
advantage of the additional registers

00:08:22.590 --> 00:08:24.420
to help speed the operations.

00:08:25.160 --> 00:08:29.990
So this will take about 47
seconds to do all the frames,

00:08:29.990 --> 00:08:34.750
all 27 frames, and the 32-bit version
might get through two,

00:08:34.750 --> 00:08:37.360
if we're lucky, in the same time frame.

00:08:38.710 --> 00:08:42.530
So the 64-bit version is benefiting
from the optimized instruction set,

00:08:42.880 --> 00:08:46.370
from the large virtual address
space being able to map the file,

00:08:46.370 --> 00:08:52.290
and the large physical address space
to get the file into memory in one go.

00:08:52.810 --> 00:08:53.920
So there's the authors.

00:08:54.030 --> 00:08:55.580
We're not even past number two yet.

00:08:55.580 --> 00:08:58.200
OK, so there's 64 bits.

00:09:02.160 --> 00:09:04.640
So does this mean that you all
want to rush out and convert

00:09:04.640 --> 00:09:06.560
your applications to 64 bits?

00:09:06.580 --> 00:09:09.760
Well, you really

00:09:10.620 --> 00:09:15.550
want to only consider 64-bit if you have
a computationally intensive application

00:09:16.270 --> 00:09:21.750
and you have a large data set that you
need to work on and you're targeting

00:09:21.750 --> 00:09:25.060
one of the 64-bit capable machines.

00:09:25.240 --> 00:09:29.470
So that's a relatively small set
of people that really need the

00:09:29.630 --> 00:09:33.880
64-bit capabilities and you have
to remember that we have a lot

00:09:33.880 --> 00:09:36.410
of 32-bit machines to target.

00:09:38.600 --> 00:09:40.560
So that's 64-bit.

00:09:40.600 --> 00:09:44.660
We have the 64-bit hardware
in the Mac Pro available.

00:09:44.700 --> 00:09:47.020
We have 64-bit tools available.

00:09:47.050 --> 00:09:52.160
And we have the full 64-bit
software stack available.

00:09:52.340 --> 00:09:58.650
And so now it's for you to get
your 64-bit apps onto the platform.

00:10:01.100 --> 00:10:05.140
So we move on to the
next aspect of the CPU.

00:10:05.170 --> 00:10:09.310
This is also a revolutionary
change in the industry.

00:10:11.430 --> 00:10:14.060
So now I'd like to talk about multicores.

00:10:14.110 --> 00:10:19.240
So this morning we announced the Mac Pro.

00:10:19.240 --> 00:10:21.900
This has a multicore Xeon processor.

00:10:21.950 --> 00:10:26.210
Now, multicore is an industry-wide trend,
and so I'd like to talk a little bit

00:10:26.210 --> 00:10:31.710
about why we're doing this and what
it means to us as software developers.

00:10:32.130 --> 00:10:35.040
So, looking back,
what we've been doing with

00:10:35.050 --> 00:10:39.000
single cores is just relying
on increasing clock speed.

00:10:39.100 --> 00:10:41.290
Now this has been great for
application developers because

00:10:41.320 --> 00:10:43.000
you don't have to do anything,
right?

00:10:43.000 --> 00:10:44.910
You wait for the next
processor to come along,

00:10:45.070 --> 00:10:48.000
the clock speeds faster,
your application,

00:10:48.000 --> 00:10:51.130
no change to the binary,
just runs faster too.

00:10:51.680 --> 00:10:53.670
Unfortunately,
in order to be able to increase

00:10:53.670 --> 00:10:57.070
the clock speed like this,
there are some ramifications to that.

00:10:57.140 --> 00:11:01.370
So the way that we've been increasing the
clock speed is through miniaturization.

00:11:01.420 --> 00:11:05.050
When you miniaturize, unfortunately,
you increase the amount

00:11:05.100 --> 00:11:07.450
of power consumption,
and when you increase

00:11:07.450 --> 00:11:11.000
the power consumption,
you also increase the generation of heat,

00:11:11.150 --> 00:11:12.600
which you then have to
get out of the machine.

00:11:12.600 --> 00:11:16.670
And this is going up exponentially
and is causing significant problems.

00:11:16.680 --> 00:11:18.920
So what's the solution?

00:11:19.780 --> 00:11:23.800
So if we look at a single processor,
this is a single-chord processor,

00:11:23.800 --> 00:11:27.130
fully clocked,
the performance meter is set at 100,

00:11:27.130 --> 00:11:30.020
and our power consumption
meter is also set at 100.

00:11:30.020 --> 00:11:36.000
So what we'll do is we'll increase the
clock speed by 20% and see what happens.

00:11:37.780 --> 00:11:41.410
So we've got a nice 13%
increase in performance.

00:11:41.540 --> 00:11:42.160
That's good.

00:11:42.170 --> 00:11:44.240
We like increasing performance.

00:11:44.280 --> 00:11:48.900
But it comes at a cost of a 73%
increase in power consumption,

00:11:49.100 --> 00:11:52.170
which is not good because there's
all the heat that goes with that,

00:11:52.170 --> 00:11:52.760
too.

00:11:52.810 --> 00:11:55.410
So instead of doing that,
instead of increasing

00:11:55.600 --> 00:12:00.290
the clock frequency,
let's decrease it and see what happens.

00:12:01.820 --> 00:12:06.180
So we've lost that 13% performance gain,
and in fact we've lost more compared

00:12:06.220 --> 00:12:09.260
to the single cord processor.

00:12:09.320 --> 00:12:11.160
So that's bad,
but look at the power consumption.

00:12:11.160 --> 00:12:15.370
Our power consumption has
dropped to 49% of what the fully

00:12:15.450 --> 00:12:17.570
clocked processor would be.

00:12:17.830 --> 00:12:21.240
So what we'll do is we'll take this core,
we'll add another one,

00:12:21.240 --> 00:12:23.080
and we'll make it a dual
core and see what happens.

00:12:23.080 --> 00:12:28.930
So now we have a 73% increase in
computing throughput on a dual core

00:12:28.990 --> 00:12:33.240
processor with that clocked down chip
compared to the fully clocked processor.

00:12:33.240 --> 00:12:36.020
And only a 2% increase in power.

00:12:36.020 --> 00:12:38.600
And this is ignoring any advances
in microprocessor technology,

00:12:38.600 --> 00:12:39.920
which of course is happening.

00:12:39.920 --> 00:12:42.370
And so this is why we're going dual core.

00:12:42.380 --> 00:12:46.770
For small power changes, if any,
we can get significant increases

00:12:46.840 --> 00:12:48.720
in computing throughput.

00:12:51.500 --> 00:12:52.870
So how do we use this performance?

00:12:53.060 --> 00:12:56.250
I mean,
it was simple in the single-chord world,

00:12:56.250 --> 00:13:00.050
where we just do nothing and wait
for the processor to speed us up.

00:13:00.220 --> 00:13:02.840
But this is a second processor in here.

00:13:02.900 --> 00:13:04.900
Well, we have options.

00:13:05.970 --> 00:13:08.460
We can do nothing, again.

00:13:08.510 --> 00:13:10.660
We can use threads.

00:13:10.690 --> 00:13:12.700
Or we can adopt some new APIs.

00:13:12.870 --> 00:13:14.280
So let's talk through those.

00:13:14.350 --> 00:13:17.080
First of all,
let's talk about doing nothing.

00:13:17.120 --> 00:13:18.180
But how can you do nothing?

00:13:18.180 --> 00:13:20.040
We've got an extra core.

00:13:20.100 --> 00:13:22.400
Well,
the reason you can do nothing is because

00:13:22.400 --> 00:13:25.090
the OS has done the hard work for you.

00:13:25.500 --> 00:13:28.130
During Tiger,
we went through the whole of the kernel,

00:13:28.130 --> 00:13:30.680
we put fine-grain locking
throughout the kernel,

00:13:30.680 --> 00:13:33.880
so the kernel is now highly
concurrent and parallel.

00:13:33.880 --> 00:13:39.570
And at the heart of Mac OS X,
we have a fully SMP-capable Unix system.

00:13:42.080 --> 00:13:44.380
In addition,
while your application is running,

00:13:44.380 --> 00:13:46.960
there's some other system activity that,
on a single processor,

00:13:46.960 --> 00:13:49.440
you are having to compete for.

00:13:49.590 --> 00:13:53.520
So there's various daemons and other
utilities going on in the system.

00:13:53.760 --> 00:13:56.730
With a dual core,
these can be going on in the second core,

00:13:56.730 --> 00:14:00.300
while your application now has
the full core at its disposal.

00:14:00.700 --> 00:14:03.600
Mac OS X also has a client
server architecture.

00:14:03.720 --> 00:14:06.830
So services that you're requesting
from the operating system are

00:14:06.920 --> 00:14:10.590
frequently done by daemons or
other processes in the system.

00:14:10.600 --> 00:14:13.740
These can now run on the other
core while your application is

00:14:13.740 --> 00:14:15.890
still making forward progress.

00:14:16.490 --> 00:14:18.160
We also have some threaded frameworks.

00:14:18.200 --> 00:14:22.790
So some of the APIs that you use are

00:14:22.900 --> 00:14:29.900
[Transcript missing]

00:14:31.020 --> 00:14:33.240
So even if you do nothing,
you get an automatic

00:14:33.320 --> 00:14:35.060
performance improvement.

00:14:35.060 --> 00:14:37.100
It's not great,
but it's good for nothing.

00:14:37.210 --> 00:14:40.490
It's good for doing nothing,
I should say.

00:14:42.240 --> 00:14:43.310
I knew I had to make one mistake.

00:14:43.360 --> 00:14:46.820
So that's the do-nothing option.

00:14:46.820 --> 00:14:49.710
The second option is to use threads.

00:14:49.760 --> 00:14:52.060
Many of you already have
threaded applications,

00:14:52.060 --> 00:14:55.950
and many of you may be going
towards threaded applications,

00:14:55.980 --> 00:14:57.480
so we'll talk about
that for a little bit.

00:14:57.520 --> 00:15:03.220
But there's an art to multi-threading,
and it's not a simple thing to do.

00:15:03.220 --> 00:15:07.340
A lot of applications are broken
down using functional decomposition.

00:15:07.340 --> 00:15:09.700
You use one thread to perform
one part of the activity,

00:15:09.770 --> 00:15:11.300
another thread to do something different.

00:15:11.680 --> 00:15:14.420
But much of the concurrency is
actually around access to data.

00:15:14.420 --> 00:15:17.920
And, of course,
access to data in a multi-processor

00:15:17.920 --> 00:15:19.290
world is all about locks.

00:15:19.300 --> 00:15:23.090
And the big question is,
how many locks do you use?

00:15:23.210 --> 00:15:25.490
Do you use a few big locks,
a lot of small locks?

00:15:25.620 --> 00:15:29.000
And the answer is,
there is no single answer.

00:15:29.000 --> 00:15:34.570
So it's all about profiling your
application and looking to see

00:15:34.570 --> 00:15:38.250
where you're getting concurrency,
where there's contention on the locks,

00:15:38.250 --> 00:15:38.990
and so forth.

00:15:39.060 --> 00:15:40.350
And it's a lot of work.

00:15:41.790 --> 00:15:44.020
You also have to worry about deadlocks.

00:15:44.060 --> 00:15:46.190
You don't want deadlocks in your system,
so you have to start

00:15:46.310 --> 00:15:47.450
planning lock hierarchies.

00:15:47.480 --> 00:15:51.840
And being able to debug those
is also incredibly difficult.

00:15:51.860 --> 00:15:54.860
Other complexities include cancellation.

00:15:54.860 --> 00:15:57.470
If your thread is cancelled,
you have to clean up.

00:15:57.540 --> 00:15:59.810
You have to release any
resources that were allocated.

00:15:59.890 --> 00:16:01.770
You have to free any
locks that it was holding.

00:16:01.780 --> 00:16:03.460
And cleanup's easy to get wrong.

00:16:03.480 --> 00:16:05.820
There's also thread management.

00:16:05.820 --> 00:16:09.650
You have to work out how many threads
you need to create in your application.

00:16:09.780 --> 00:16:11.190
If you create too many, it's inefficient.

00:16:11.190 --> 00:16:13.210
They're fighting with each
other for the CPU resources.

00:16:13.220 --> 00:16:15.950
If you create too few of them,
then you've wasted the concurrency

00:16:16.040 --> 00:16:17.580
that's available in the machine.

00:16:19.380 --> 00:16:21.980
Now, we haven't actually solved any of
these problems in a threaded world.

00:16:21.980 --> 00:16:23.070
That's very difficult to do.

00:16:23.080 --> 00:16:26.580
But what we have done is help
you identify the work in your

00:16:26.580 --> 00:16:28.440
threads through prioritization.

00:16:28.500 --> 00:16:32.240
Now, we've had CPU prioritization
for a long time now,

00:16:32.240 --> 00:16:34.870
but in Leopard,
we've added two new interfaces

00:16:34.980 --> 00:16:40.120
to be able to control file system
activity and networking activity.

00:16:40.160 --> 00:16:43.490
So you can mark your thread
as being a background thread,

00:16:43.490 --> 00:16:47.800
and all file system activity will take
lower priority compared to other threads,

00:16:47.800 --> 00:16:50.800
and all your networking activity
will take lower priority also.

00:16:50.800 --> 00:16:54.630
This allows you to distinguish
between your foreground threads,

00:16:54.630 --> 00:16:57.840
which are doing, for example,
the user interface,

00:16:57.860 --> 00:17:00.670
and the background threads,
which are doing downloads or cache

00:17:00.740 --> 00:17:03.600
management or other housekeeping
things in the background.

00:17:06.190 --> 00:17:07.180
So that's using threads.

00:17:07.180 --> 00:17:08.140
It's a manual process.

00:17:08.140 --> 00:17:09.900
You will get the performance out.

00:17:09.960 --> 00:17:12.070
It depends on how much work
you want to put into it.

00:17:12.070 --> 00:17:18.600
But that's how you get that performance
out of multicores using threads.

00:17:22.110 --> 00:17:25.430
So the last one is adopt new APIs.

00:17:25.670 --> 00:17:29.160
So we thought a lot about how we
could make this process easier to

00:17:29.170 --> 00:17:32.520
get concurrency in your applications
without you having to deal with all

00:17:32.520 --> 00:17:34.760
the complexities of using threads.

00:17:34.790 --> 00:17:39.700
And we looked around at what were
successful patterns in life to

00:17:39.700 --> 00:17:44.620
be able to increase the workflow
and be able to get things moving.

00:17:44.650 --> 00:17:46.400
And we discovered the queues.

00:17:46.540 --> 00:17:49.240
We were already using queues
in things like run loops.

00:17:49.260 --> 00:17:52.390
And it's a very effective mechanism.

00:17:52.620 --> 00:17:54.840
So what you need to do
is to take your program,

00:17:54.840 --> 00:17:58.380
your application,
and basically do top-down design

00:17:58.380 --> 00:18:03.460
kinds of approaches where you take
your long operations and you break

00:18:03.590 --> 00:18:07.190
them down into smaller operations
and queue them up to be done.

00:18:07.220 --> 00:18:10.150
Now, these work elements can also
generate more work elements

00:18:10.160 --> 00:18:13.020
and queue those up as well,
so it's an iterative process.

00:18:13.020 --> 00:18:17.050
And we have two new APIs in
Leopard to help you do this,

00:18:17.050 --> 00:18:20.000
NSOperation and NSOperationQueue.

00:18:20.040 --> 00:18:22.140
So what do these two guys do?

00:18:22.500 --> 00:18:25.810
So NSOperation actually
manages your work element.

00:18:25.820 --> 00:18:28.000
It gives you information
such as the status,

00:18:28.000 --> 00:18:29.660
is this work element running?

00:18:29.660 --> 00:18:33.610
And it allows you to specify to
the operating system things like

00:18:33.610 --> 00:18:38.000
how parallel this work element is
with the rest of your application,

00:18:38.000 --> 00:18:40.400
what the priority of
this work element is,

00:18:40.400 --> 00:18:42.720
and what its dependencies are
in case there are several that

00:18:42.720 --> 00:18:43.980
you have to do sequentially.

00:18:47.900 --> 00:18:51.570
NS Operation Queue is the actual queue
management itself and takes the work

00:18:51.570 --> 00:18:53.580
elements and applies them onto a queue.

00:18:53.580 --> 00:18:57.720
And this will automatically
fork the threads for you,

00:18:57.720 --> 00:19:00.660
the appropriate number of threads,
depending on the hardware configuration

00:19:00.660 --> 00:19:03.340
that you're running on and also
the amount of concurrency that

00:19:03.350 --> 00:19:05.200
you've specified in your application.

00:19:05.210 --> 00:19:08.020
And because this is queue-based,
it fits in with the run loop.

00:19:08.040 --> 00:19:10.740
And therefore,
it's a very familiar kind of model.

00:19:10.750 --> 00:19:14.910
And so what I'd like to do now is
to show you a little demo about

00:19:15.320 --> 00:19:17.660
what you can do with NS Operation.

00:19:24.540 --> 00:19:26.200
Okay, this is a demo program.

00:19:26.200 --> 00:19:28.840
Basically,
there are two activities going on here,

00:19:29.310 --> 00:19:31.700
one of which is drawing a
yellow picture in activity one,

00:19:31.700 --> 00:19:34.080
and the other one is drawing a
blue picture in activity two.

00:19:34.080 --> 00:19:38.560
And each of these activities has been
broken down into seven work elements.

00:19:38.560 --> 00:19:42.900
So let's just start it
and see what goes on.

00:19:42.900 --> 00:19:45.790
Now you can see this is just
going on in a strict FIFO order.

00:19:45.790 --> 00:19:48.500
We put the work elements on the
queue and they're just being

00:19:48.630 --> 00:19:51.870
pulled off and executed one by one,
because we've specified nothing

00:19:51.960 --> 00:19:53.580
about the work elements.

00:19:55.970 --> 00:19:59.050
So this is a dual core machine,
this iMac.

00:19:59.210 --> 00:20:06.650
And so we can specify that actually these
elements can be executed concurrently.

00:20:07.520 --> 00:20:09.340
So let's do that.

00:20:09.370 --> 00:20:12.280
And of course,
you can now do them two at a time.

00:20:12.290 --> 00:20:14.470
Now, you have to remember that
there's nothing changed about

00:20:14.490 --> 00:20:17.600
this program from the first one,
except for the fact we've added a bit

00:20:17.740 --> 00:20:21.920
in each work element that says that
they can be executed concurrently.

00:20:24.730 --> 00:20:27.400
Now I personally think that the
yellow flower should be drawn first.

00:20:27.530 --> 00:20:31.640
So what I'm going to do is I'm going
to set this priority on all the yellow

00:20:31.640 --> 00:20:35.670
work elements to say that they're
more important than the blue ones.

00:20:36.330 --> 00:20:38.420
So let's run that.

00:20:38.420 --> 00:20:42.100
And now you can see that we pull
the yellow work elements off

00:20:42.100 --> 00:20:43.860
in preference to the blue ones.

00:20:43.860 --> 00:20:46.140
And again,
there's been no change to this program

00:20:46.140 --> 00:20:49.010
other than the fact that as I put
each work element onto the queue,

00:20:49.010 --> 00:20:53.450
we've specified a higher priority
than the blue work elements.

00:20:55.710 --> 00:20:57.780
So that's NS Operation Q.

00:20:57.860 --> 00:21:02.980
It's a new way of getting concurrency
without all the hard work of threads.

00:21:05.130 --> 00:21:08.640
So NS Operations,
you let the OS do the hard part.

00:21:08.690 --> 00:21:11.840
And because we're putting all the
concurrency management in the library,

00:21:11.860 --> 00:21:14.140
it's applicable across all applications.

00:21:14.190 --> 00:21:16.260
And because we're working
with the hardware,

00:21:16.310 --> 00:21:19.560
we can future-proof your application
to take advantage of more and more

00:21:19.630 --> 00:21:22.490
concurrency as it becomes available,
as long as you specified

00:21:22.560 --> 00:21:24.100
that in your work elements.

00:21:24.150 --> 00:21:27.080
All you need to do for your
applications is break the work down

00:21:27.190 --> 00:21:32.470
into units and hint the OS the amount
of parallelism you can tolerate,

00:21:32.580 --> 00:21:35.970
the priority,
and any dependencies that you have.

00:21:37.770 --> 00:21:39.420
So that's adopting new APIs.

00:21:39.420 --> 00:21:42.130
And we'd really encourage you to
go off and look at NS operation

00:21:42.130 --> 00:21:43.900
and NS operation queue.

00:21:45.400 --> 00:21:49.340
So it doesn't matter which one
of these options that you choose,

00:21:49.370 --> 00:21:53.350
Mac OS X is the best software
platform for being able to take

00:21:53.350 --> 00:21:59.700
advantage of multi-cores as
they develop in the industry.

00:21:59.770 --> 00:22:04.610
And so I'd like to return to
Bertrand to talk about the next

00:22:04.610 --> 00:22:06.990
item of hardware in the system.

00:22:13.500 --> 00:22:14.730
Thanks, Simon.

00:22:14.840 --> 00:22:18.420
So Simon talked about the CPU,
two aspects that are really

00:22:18.420 --> 00:22:22.320
important nowadays for the CPU,
64-bit and multi-core.

00:22:22.390 --> 00:22:25.620
But to have a computer,
you need something more than a CPU.

00:22:25.620 --> 00:22:29.810
You need at least memory.

00:22:30.700 --> 00:25:01.000
[Transcript missing]

00:25:02.560 --> 00:25:10.720
So in Leopard,
we are adding garbage collection

00:25:10.840 --> 00:25:13.180
to the Objective-C runtime.

00:25:21.090 --> 00:25:25.000
What that means is that all
Objective-C objects are collected.

00:25:25.060 --> 00:25:27.810
The old release method does nothing.

00:25:27.920 --> 00:25:29.720
You can still have it in your code.

00:25:29.730 --> 00:25:32.940
And it really integrates well
with kind of the other heaps,

00:25:32.940 --> 00:25:37.060
the malloc heap, or even the CF object,
core foundation object,

00:25:37.090 --> 00:25:40.120
where you have done
CF retain and CF release.

00:25:40.180 --> 00:25:44.280
We use a very modern garbage collector,
one that's generational.

00:25:44.280 --> 00:25:48.580
It's not your granddad's kind
of trace and sweep collector.

00:25:48.740 --> 00:25:51.970
So generational means that
we take advantage of the

00:25:52.120 --> 00:25:55.200
fact that a young object,
when created recently,

00:25:55.340 --> 00:25:59.330
tends to go away faster than
the old objects that tend to

00:25:59.370 --> 00:26:01.260
sit there pretty much forever.

00:26:01.390 --> 00:26:04.710
So very modern garbage collector.

00:26:04.770 --> 00:26:08.100
Now, I heard a little bit of clapping.

00:26:08.100 --> 00:26:11.390
And so I know that at least
a number of you are really

00:26:11.460 --> 00:26:17.340
excited by the convenience,
not having to worry about deallocation,

00:26:17.340 --> 00:26:18.560
and that especially.

00:26:18.700 --> 00:26:22.000
If you are creating a new application,
that can be great.

00:26:22.100 --> 00:26:23.920
OK, forget all these codes.

00:26:23.920 --> 00:26:25.580
That's error prone.

00:26:25.590 --> 00:26:29.330
But in the back over there,
I saw some folks who

00:26:29.610 --> 00:26:31.350
are a little worried.

00:26:31.360 --> 00:26:34.820
What is this going to do
to my existing application?

00:26:34.820 --> 00:26:37.360
Maybe you've worked with a
garbage collector in the past,

00:26:37.360 --> 00:26:40.140
and that wasn't kind of
the best performance.

00:26:40.140 --> 00:26:44.690
Maybe you have a real-time application
where you want to very carefully

00:26:44.690 --> 00:26:48.040
control the lifetime of your buffers.

00:26:48.080 --> 00:26:50.440
So-- Relax.

00:26:50.450 --> 00:26:52.300
You can have it both ways.

00:26:52.330 --> 00:26:54.920
Garbage collection is opt-in.

00:26:54.950 --> 00:26:59.070
We're not changing the
meaning of your existing code.

00:26:59.190 --> 00:27:00.600
So what does opt-in mean?

00:27:00.630 --> 00:27:04.440
It means that per application,
you can specify with just a flag

00:27:04.550 --> 00:27:08.520
whether you want your application
to be garbage collected or not.

00:27:08.570 --> 00:27:14.400
And we've made sure all our stack,
all our frameworks, work both ways,

00:27:14.400 --> 00:27:22.590
collected or not, which is, I think,
a first from a technology perspective.

00:27:27.760 --> 00:27:32.280
So this is a brand new
feature in Objective-C.

00:27:32.280 --> 00:27:33.830
And actually, there will be others.

00:27:33.930 --> 00:27:36.570
But for that,
you need to go to the next session,

00:27:36.580 --> 00:27:39.390
the one after this one.

00:27:39.510 --> 00:27:44.880
So that was garbage collection,
Objective-C, a better way to fill

00:27:44.880 --> 00:27:47.790
all those memory chips.

00:27:48.520 --> 00:27:53.080
Now,
let's move on to a new part of computers.

00:27:53.080 --> 00:27:55.440
Actually,
this is something that all modern

00:27:55.440 --> 00:28:00.990
computers have and that contributes to
creating an exceptional user experience.

00:28:00.990 --> 00:28:03.430
And that's...

00:28:04.600 --> 00:28:15.300
[Transcript missing]

00:28:15.500 --> 00:28:18.660
Thank you.

00:28:18.670 --> 00:28:20.350
Thanks, everybody.

00:28:20.580 --> 00:28:24.820
We're using the GPU today as kind
of a metaphor for things we do in

00:28:24.820 --> 00:28:28.550
the computer to create cinematic
experiences for our users.

00:28:28.560 --> 00:28:33.410
Cinematic experiences are when
the user uses your application

00:28:33.500 --> 00:28:38.300
or turns on the computer,
just have a really nice greeting for

00:28:38.430 --> 00:28:41.920
them just that they feel right at home
when they're using your application.

00:28:42.180 --> 00:28:46.080
My analogy for this is kind of like going
out for a nice meal at a nice restaurant.

00:28:46.080 --> 00:28:49.410
You sit down, the lights are right,
the tablecloth is pressed,

00:28:49.420 --> 00:28:50.750
the napkin's pressed.

00:28:51.100 --> 00:28:55.320
Everything feels great,
even before the meal hits your table.

00:28:55.320 --> 00:28:58.160
And so that's really the kind of
impressions you want to create

00:28:58.160 --> 00:28:59.650
with a cinematic experience.

00:28:59.680 --> 00:29:02.540
And there's a bunch of
ingredients to that experience

00:29:02.720 --> 00:29:04.590
that we're going to talk about.

00:29:04.700 --> 00:29:06.500
We're going to talk
about computing power.

00:29:06.510 --> 00:29:08.800
We've got a lot of computing
power in the platform.

00:29:08.800 --> 00:29:10.110
How do we take advantage of that?

00:29:10.230 --> 00:29:12.030
We're going to talk
about better algorithms.

00:29:12.180 --> 00:29:14.400
As you can tell,
the computing power is coming in

00:29:14.440 --> 00:29:16.630
some sort of funky ways at us,
and we've got to figure

00:29:16.630 --> 00:29:17.290
out how to use that.

00:29:17.420 --> 00:29:20.300
We're going to talk about making
everything easier to program so that

00:29:20.330 --> 00:29:24.120
you can take your application to
the next level without kind of going

00:29:24.250 --> 00:29:25.940
all the way back to square one.

00:29:26.060 --> 00:29:30.430
And we're going to
talk about more pixels,

00:29:30.430 --> 00:29:33.060
both in space and time.

00:29:33.180 --> 00:29:34.860
Let's talk about more computing power.

00:29:34.860 --> 00:29:42.660
So we heard about our new four
burner processors this morning.

00:29:42.760 --> 00:29:46.540
But there's another processor
in your box called the GPU.

00:29:46.640 --> 00:29:54.940
And the GPU is increasing at a rate of
performance even faster than the CPUs.

00:29:55.130 --> 00:30:00.640
In fact, the latest engines are capable
of 10 gigapixels or more

00:30:00.640 --> 00:30:03.120
in processing per second.

00:30:03.280 --> 00:30:07.230
And it's not just about gigaflops
for the graphics processor.

00:30:07.330 --> 00:30:09.720
The graphics processors are
becoming more programmable,

00:30:09.750 --> 00:30:12.180
so they're starting to
feel more like a CPU.

00:30:12.230 --> 00:30:14.950
They're having more precision,
so they're up to a

00:30:15.000 --> 00:30:16.640
floating point precision.

00:30:16.700 --> 00:30:19.420
And also a lot more memory bandwidth,
because the memory systems

00:30:19.420 --> 00:30:22.580
are closed and not necessarily
expandable on the graphics cards,

00:30:22.730 --> 00:30:25.720
they typically have
much greater bandwidth,

00:30:25.800 --> 00:30:28.770
50, 60 gigabytes per second even.

00:30:29.260 --> 00:30:32.230
But as we saw this morning again,
the multi-core CPUs are

00:30:32.230 --> 00:30:34.440
giving it a run for the money,
and they're not going to

00:30:34.540 --> 00:30:35.640
go down without a fight.

00:30:35.820 --> 00:30:38.730
And so the great thing about this is
this creates this embarrassment of

00:30:38.850 --> 00:30:42.470
riches of all this computing power
that we can take advantage to great

00:30:42.470 --> 00:30:44.780
cinematic experiences for users.

00:30:47.570 --> 00:30:51.180
So the next thing that we want to
talk about is how to take advantage

00:30:51.220 --> 00:30:53.220
of all of those processing engines.

00:30:53.220 --> 00:30:55.440
As we heard, it's about parallelism.

00:30:55.440 --> 00:30:59.800
And one way to think about
parallelism is task parallelism.

00:30:59.800 --> 00:31:03.110
Task parallelism is where you
divide work into chunks where,

00:31:03.240 --> 00:31:06.870
say, you might have a line chef and an
expediter and someone doing the

00:31:06.890 --> 00:31:11.570
appetizers to try to get the throughput
through the kitchen as much as possible.

00:31:11.880 --> 00:31:16.030
And so that's a common way to break
down problems on the computer as well.

00:31:16.030 --> 00:31:18.120
And we've done that with OpenGL.

00:31:18.120 --> 00:31:23.340
And we've even done more
in Leopard with that.

00:31:23.380 --> 00:31:27.970
Conventional OpenGL is already a
multi-threaded kind of task parallel

00:31:27.970 --> 00:31:32.510
architecture because you've got the CPU,
the application running on

00:31:32.510 --> 00:31:36.430
the CPU creating commands,
then being executed by the GPU,

00:31:36.430 --> 00:31:40.180
which is actually its own
processing engine as well.

00:31:40.180 --> 00:31:41.750
You can think of it as running a thread.

00:31:41.880 --> 00:31:43.810
And receiving commands
from the application.

00:31:43.910 --> 00:31:48.340
So you already have some concurrency
going with conventional OpenGL.

00:31:48.690 --> 00:31:52.440
And what we've done is gone to a
multi-threaded OpenGL engine to

00:31:52.640 --> 00:31:54.720
add an extra thread in the middle.

00:31:54.720 --> 00:31:58.060
So the application thread can
have a processor all to itself,

00:31:58.060 --> 00:32:01.630
call OpenGL, record that,
return immediately,

00:32:01.730 --> 00:32:05.460
and then there's one thread whose sole
job it is to take those commands from

00:32:05.470 --> 00:32:07.550
the application and keep the GPU fed.

00:32:07.720 --> 00:32:11.050
And this results in
tremendous gains for us.

00:32:12.000 --> 00:32:17.560
So here's a graph that we made of Doom 3
and World of Warcraft running on the

00:32:17.690 --> 00:32:19.960
new machines we announced this morning.

00:32:19.960 --> 00:32:21.000
You can see Windows XP.

00:32:21.000 --> 00:32:24.260
We can boot it to XP on the left there.

00:32:24.640 --> 00:32:29.570
And you can see Mac OS X in the middle
without the multi-threaded engine.

00:32:29.720 --> 00:32:31.920
And then on the right,
we have Mac OS X with the

00:32:31.920 --> 00:32:33.340
multi-threaded engine.

00:32:33.450 --> 00:32:38.170
And you can see we get over a
factor of two in some cases.

00:32:38.180 --> 00:32:41.680
And in fact,
World of Warcraft is now faster.

00:32:41.990 --> 00:32:46.000
It's a much faster machine on
Mac OS X booted into -- on a Xeon machine

00:32:46.000 --> 00:32:48.700
booted into Mac OS X than it is Windows.

00:32:48.850 --> 00:32:51.000
And we think that's pretty cool.

00:32:51.090 --> 00:32:53.800
So World of Warcraft.

00:32:53.810 --> 00:32:58.050
Factor of two faster by
using multi-threaded.

00:32:58.410 --> 00:33:03.280
and I've asked Jeff Stahl to come up on
stage and run World of Warcraft for us.

00:33:03.300 --> 00:33:07.970
You never know what you're going to see
when you go live into World of Warcraft,

00:33:08.000 --> 00:33:09.300
but let's see where we're at.

00:33:09.630 --> 00:33:11.240
There's Jeff running around.

00:33:11.340 --> 00:33:15.300
You can see we've got a frame meter up on
the right showing the frames per second.

00:33:15.300 --> 00:33:18.300
We've got a CPU meter there.

00:33:18.300 --> 00:33:21.920
It's taking a little bit over one
CPU right now because World of

00:33:21.920 --> 00:33:25.090
Warcraft has some networking,
some audio threads that it's

00:33:25.090 --> 00:33:27.040
doing to spread the load as well.

00:33:27.340 --> 00:33:30.290
Right now we're in a common
area called the Iron Forge,

00:33:30.390 --> 00:33:32.300
which is kind of a meeting area.

00:33:32.300 --> 00:33:35.500
You can see a bunch of
characters running around.

00:33:35.500 --> 00:33:38.300
And there's Jeff looking
pretty spiffy there.

00:33:38.300 --> 00:33:41.380
We've got the world
appearance set to maximum.

00:33:41.450 --> 00:33:43.580
And right now with a
multi-threaded engine off,

00:33:43.700 --> 00:33:46.300
we're at about 40, 43 frames per second.

00:33:46.300 --> 00:33:50.150
Jeff is going to flip a switch,
turn on the multi-threaded engine,

00:33:50.290 --> 00:33:52.300
and we'll see what happens.

00:33:52.590 --> 00:33:56.300
Frame rate goes up about a
factor of two in frame rate.

00:33:56.490 --> 00:34:01.110
And you can see we're using
over two CPUs worth of load,

00:34:01.300 --> 00:34:03.280
one three-quarters, two.

00:34:03.310 --> 00:34:05.300
So that's really pretty incredible.

00:34:05.300 --> 00:34:07.240
Why does frames per
second matter in a game?

00:34:07.310 --> 00:34:09.600
Well, you know,
in this scene you're going

00:34:09.600 --> 00:34:13.300
faster than monitor refresh,
so it doesn't matter all that much.

00:34:13.300 --> 00:34:16.660
But if you get to a more complicated
scene where you've got a high-level

00:34:16.660 --> 00:34:20.290
encounter with a lot of folks,
the action's real fast.

00:34:20.470 --> 00:34:23.710
You need to be able to respond quickly,
and that's exactly the last time

00:34:23.710 --> 00:34:25.300
you want the machine to bog down.

00:34:25.300 --> 00:34:30.300
So having a lot of headroom is real
important as the levels get harder.

00:34:30.390 --> 00:34:35.090
So I think it's really cool that
we are able to show you this.

00:34:35.300 --> 00:34:38.300
To do this in your application,
it's only one line of code.

00:34:38.300 --> 00:34:41.030
You just opt in to the
multi-threaded engine,

00:34:41.140 --> 00:34:43.200
and you just turn it on real simple.

00:34:43.300 --> 00:34:45.990
So, Jeff, why don't you show us what
you think about beating XP on

00:34:45.990 --> 00:34:47.280
a multi-threaded machine?

00:34:47.340 --> 00:34:49.590
Yeah.

00:34:52.800 --> 00:34:54.800
Wait a minute, wait a minute.

00:34:54.800 --> 00:34:59.040
Jeff, Jeff, what do you really
think about beating XP?

00:34:59.040 --> 00:34:59.840
Yeah, there you go.

00:34:59.840 --> 00:35:02.160
All right, say goodbye, Jeff.

00:35:02.320 --> 00:35:04.440
All right, thanks.

00:35:04.440 --> 00:35:05.930
That's great.

00:35:15.100 --> 00:35:16.860
So that's OpenGL running multi-threaded.

00:35:17.040 --> 00:35:20.540
There is actually a version of this that
is shipping with the new Xeon machines,

00:35:20.590 --> 00:35:21.950
and we'll continue to improve it.

00:35:22.090 --> 00:35:24.270
And it's going to be in
Leopard as a standard feature.

00:35:24.380 --> 00:35:25.930
So that's great.

00:35:25.960 --> 00:35:28.460
So let's talk about another
kind of parallelism,

00:35:28.530 --> 00:35:29.480
data parallelism.

00:35:29.600 --> 00:35:32.580
So again, back to my food analogy,
you can cook 100 French fries

00:35:32.580 --> 00:35:33.780
the same time you cook one.

00:35:33.780 --> 00:35:35.920
If you cook each one serially,
it would probably take

00:35:36.080 --> 00:35:37.350
a little bit of time.

00:35:37.500 --> 00:35:42.440
So French fries to me are like pixels,
so I think of Core Image.

00:35:42.440 --> 00:35:45.740
So Core Image is an engine that
does the same thing to a bunch

00:35:45.880 --> 00:35:49.080
of pixels at the same time,
and that's exactly what

00:35:49.080 --> 00:35:50.240
data parallelism is.

00:35:50.460 --> 00:35:54.260
And so Coreism is actually a fairly
general data parallel API for

00:35:54.360 --> 00:35:59.510
constructing little kernels of code and
tying them together in order to create

00:35:59.520 --> 00:36:04.510
a tree of operations that has to occur
over an image or a bunch of images.

00:36:04.830 --> 00:36:08.480
So it's ready for these highly
parallel architectures like GPUs,

00:36:08.610 --> 00:36:11.010
multi-core CPUs, et cetera.

00:36:11.340 --> 00:36:16.440
And there is-- the capability of running
it both on the CPU or the GPU in order

00:36:16.440 --> 00:36:18.320
to take advantage of the parallelism.

00:36:18.340 --> 00:36:21.100
It's fully floating point precision,
again,

00:36:21.120 --> 00:36:24.940
taking advantage of vector units running
on the CPU and taking advantage of

00:36:24.940 --> 00:36:27.100
the floating point GPU capabilities.

00:36:27.250 --> 00:36:30.080
And it also has a really important
feature called lazy evaluation.

00:36:30.080 --> 00:36:34.930
It doesn't produce pixels
until you really need them.

00:36:35.110 --> 00:36:38.840
and Core Image is actually a perfect
match for the explosion in digital

00:36:38.840 --> 00:36:40.740
photography that's going on right now.

00:36:41.240 --> 00:36:44.530
These cameras generate
megapixels of data,

00:36:44.530 --> 00:36:48.300
10, 20 megapixels of data,
a lot of data to process.

00:36:48.300 --> 00:36:52.390
And in fact, there's an explosion that
goes on when dealing with raw

00:36:52.390 --> 00:36:53.900
camera images in particular.

00:36:54.100 --> 00:36:57.380
So if you take a 24
megabyte sensor image,

00:36:57.570 --> 00:37:02.500
that's just a 16-bit sample per pixel.

00:37:02.500 --> 00:37:06.720
Then you have to reconstruct that and
build the other two channels per pixel,

00:37:06.720 --> 00:37:10.300
which is going to explode
that data out to 96 megabytes.

00:37:10.300 --> 00:37:13.400
And then if you wanted to adjust that
maybe and save a floating point result,

00:37:13.400 --> 00:37:16.500
for example,
that image could be 192 megabytes.

00:37:16.560 --> 00:37:18.930
And you probably want to save all
of these because you may want to

00:37:18.930 --> 00:37:20.260
go back and you may want to undo.

00:37:20.380 --> 00:37:22.500
Of course,
you want to save your original.

00:37:22.500 --> 00:37:24.500
So that's a lot of data.

00:37:24.500 --> 00:37:28.450
And so the beauty of Core Image when
combined with this kind of

00:37:28.450 --> 00:37:32.300
imagery is that you can really
save the rest of the data.

00:37:32.300 --> 00:37:34.100
And that's the beauty of Core Image.

00:37:34.100 --> 00:37:38.560
So I can create a recipe to create
that purple tinted images and just save

00:37:38.560 --> 00:37:40.500
that along with my raw sensor data.

00:37:40.500 --> 00:37:45.200
And I've basically got that version of
the image with very little extra cost.

00:37:45.240 --> 00:37:47.980
So you could imagine doing this to
a bunch of different variations,

00:37:48.000 --> 00:37:50.590
a sepia tone,
a black and white version again.

00:37:50.600 --> 00:37:54.200
And I've only paid incrementally for
another recipe for each of these.

00:37:54.280 --> 00:37:59.350
So that's a real powerful concept
about how to use parallel processing

00:37:59.410 --> 00:38:05.110
to kind of do things on the fly and not
have to always save out intermediates.

00:38:05.270 --> 00:38:08.490
And we use this in the Aperture product,
which was released at

00:38:08.490 --> 00:38:11.630
the end of last year,
redefining kind of how to do

00:38:11.990 --> 00:38:17.180
digital photography by creating
these variations of images very

00:38:17.250 --> 00:38:22.150
cheaply by just sort of saving the
recipe rather than the actual bits.

00:38:23.420 --> 00:38:29.420
So Nu and Leopard were exposing the raw
reconstruction via a core image filter.

00:38:29.550 --> 00:38:32.400
So raw is totally integrated
with the core image pipeline.

00:38:32.450 --> 00:38:35.990
You have control over the details
of taking that sensor data and

00:38:35.990 --> 00:38:39.140
converting it into an exposed image.

00:38:39.490 --> 00:38:43.360
You can control the exposure,
the temperature, and the tint.

00:38:43.520 --> 00:38:46.780
And I'm going to give you
a demo of that right now.

00:38:51.610 --> 00:38:56.010
So here I have an image that's
shot a little bit overexposed,

00:38:56.100 --> 00:38:57.440
as you can see.

00:38:57.810 --> 00:39:00.450
And so up here on the right-hand side,
I've got two blocks.

00:39:00.580 --> 00:39:05.520
I've got an imagery construction block,
which is controlling the sensor decoding.

00:39:05.580 --> 00:39:10.890
And I've got an image effects block to
add some additional artistic effects.

00:39:11.200 --> 00:39:12.860
So let's try to get this image to expose.

00:39:12.860 --> 00:39:14.860
So I'm going to move the
exposure slider down.

00:39:14.920 --> 00:39:17.750
So a core image is--

00:39:17.950 --> 00:39:21.840
working to reconstruct the image with
a little bit less of an exposure.

00:39:21.840 --> 00:39:24.000
You can see since it's
dealing with the raw,

00:39:24.020 --> 00:39:27.320
it's getting some detail back
in from the highlights where the

00:39:27.460 --> 00:39:30.220
sensors were getting saturated.

00:39:30.300 --> 00:39:32.460
So we're able to pull detail
down in from the highlights

00:39:32.820 --> 00:39:35.880
by using the raw sensor data.

00:39:35.880 --> 00:39:39.310
I can also change the color temperature
or I can pick an area from the

00:39:39.310 --> 00:39:42.080
image that I want to be neutral.

00:39:42.170 --> 00:39:44.040
So I get the image
exposed the way I want it,

00:39:44.080 --> 00:39:47.460
then I can enable artistic
effects like this is an Edgework

00:39:47.460 --> 00:39:52.820
filter that's in core image where
I can change the radius of that.

00:39:52.890 --> 00:39:58.430
So this whole processing pipeline,
both the reconstruction and

00:39:58.430 --> 00:40:01.860
the effect is all put together,
globally optimized as one big

00:40:01.900 --> 00:40:04.480
GPU thing and GPU expression.

00:40:04.560 --> 00:40:08.620
And I'm going all the way from
the sensor data to the final

00:40:08.620 --> 00:40:11.960
image in one computation.

00:40:12.000 --> 00:40:16.260
And I can turn everything
off and see where I get to.

00:40:17.740 --> 00:40:22.740
So that's the new raw
features in core image.

00:40:29.330 --> 00:40:33.920
So the next thing I want to talk about
is making things easier to program.

00:40:33.960 --> 00:40:36.440
Ease of use is kind of about
quality and convenience.

00:40:36.440 --> 00:40:38.760
I mean, you wouldn't necessarily
go bake your own bread,

00:40:38.760 --> 00:40:41.420
but you're glad there are people
that know how to do that really well.

00:40:41.420 --> 00:40:44.320
And so you can buy nice bread
and you can buy nice greens.

00:40:44.370 --> 00:40:48.930
And so as we develop APIs,
we really want to have them out of the

00:40:48.930 --> 00:40:54.060
box be very useful for you and something
you can build your solutions on top of.

00:40:54.240 --> 00:40:57.840
And so core animation,
something we're introducing this year,

00:40:57.840 --> 00:41:02.370
something we're talking about
as a very easy to use API.

00:41:02.400 --> 00:41:05.720
And one thing we've found while
working with the development teams,

00:41:05.750 --> 00:41:08.220
both you guys and people
internal at Apple,

00:41:08.260 --> 00:41:11.130
is developing layered animated
user interfaces and user

00:41:11.150 --> 00:41:15.160
experiences is really very hard.

00:41:15.270 --> 00:41:18.790
Usually the first thing you
need to do is learn OpenGL.

00:41:18.850 --> 00:41:22.290
OpenGL is a great API,
but it is fairly low

00:41:22.300 --> 00:41:23.820
level and sophisticated.

00:41:23.860 --> 00:41:25.870
And if you just want to
draw an image on the screen,

00:41:25.980 --> 00:41:29.260
perhaps not the best API to use for that.

00:41:29.280 --> 00:41:31.940
Then you need to go manage
some timers and threads.

00:41:32.020 --> 00:41:35.170
Maybe you start out doing your animation
in your main run loop and you realize

00:41:35.170 --> 00:41:36.320
that doesn't really work very well.

00:41:36.410 --> 00:41:37.400
So you spawn off a thread.

00:41:37.400 --> 00:41:40.150
Now you've got all these concurrency
issues that Simon was talking

00:41:40.150 --> 00:41:42.160
about that you have to deal with.

00:41:42.200 --> 00:41:44.310
And now you have another
problem with when you're

00:41:44.320 --> 00:41:47.660
animating the user presentation,
you have to decide what's

00:41:47.660 --> 00:41:50.500
the truth as far as the
application logic is concerned.

00:41:50.500 --> 00:41:53.900
If I say, is an item in the scene
or not in the scene?

00:41:53.900 --> 00:41:57.430
And that's kind of a binary thing as
far as an application is concerned.

00:41:57.510 --> 00:41:59.140
That object's there or it's not.

00:41:59.280 --> 00:42:02.540
But in the view,
that may be in the process of animating

00:42:02.540 --> 00:42:04.230
off because you told it to go away.

00:42:04.430 --> 00:42:06.980
Maybe in the process of animating
on because you told it to come on.

00:42:07.200 --> 00:42:10.250
And so you need to manage this
discrepancy between the data

00:42:10.280 --> 00:42:13.790
structures representing what the user
is seeing at any instant and what

00:42:13.790 --> 00:42:15.260
the application logic is thinking.

00:42:15.260 --> 00:42:16.200
What menu am I on?

00:42:16.200 --> 00:42:17.790
What images are in the scene?

00:42:17.990 --> 00:42:19.200
And so that can be really hard.

00:42:19.200 --> 00:42:22.980
And there's usually replicated data
structures with lots of concurrency

00:42:22.980 --> 00:42:25.200
and locking going on to handle that.

00:42:25.250 --> 00:42:28.260
And then usually you have to manage
layout for different sizes if you're

00:42:28.260 --> 00:42:32.540
different size of display or different
size of final rendered image,

00:42:32.540 --> 00:42:37.300
like 4 by 3 for TV or 16 by 9 for HD.

00:42:37.300 --> 00:42:40.050
You want to make sure things stay on
the left where they need to and stay

00:42:40.090 --> 00:42:42.480
on the right in the top and the bottom,
et cetera.

00:42:42.510 --> 00:42:46.300
And that layout code is just
something that you have to write.

00:42:46.380 --> 00:42:49.420
And if you're starting from OpenGL,
from the baseline,

00:42:49.430 --> 00:42:54.990
you don't have the tool kits necessary
like Cocoa to handle layout for you.

00:42:55.390 --> 00:42:57.220
And then you have to fix all
the bugs in all that code.

00:42:57.220 --> 00:42:59.580
And this is usually where my
team gets a phone call just

00:42:59.670 --> 00:43:03.690
before some big keynote saying,
we're using OpenGL.

00:43:03.700 --> 00:43:04.720
We've got multiple threads going.

00:43:04.720 --> 00:43:06.000
And how do we get out of it?

00:43:06.100 --> 00:43:07.480
And it's really tricky.

00:43:07.530 --> 00:43:09.320
It's really tricky.

00:43:09.370 --> 00:43:14.500
And so core animation-- and again,
this is just the rendering code.

00:43:14.500 --> 00:43:17.990
You haven't even written
any application code yet.

00:43:18.030 --> 00:43:20.900
So we really want you guys to
worry about your application code.

00:43:20.950 --> 00:43:26.240
And so core animation is the answer
to get you to have dynamic user

00:43:26.240 --> 00:43:28.040
interfaces with very little work.

00:43:28.180 --> 00:43:30.420
So behind the scenes,
this is a dynamic layering engine

00:43:30.710 --> 00:43:32.400
with automatic property animation.

00:43:32.400 --> 00:43:34.920
You can just set a property,
and it will animate to it.

00:43:35.060 --> 00:43:36.020
It's media agnostic.

00:43:36.100 --> 00:43:40.340
You can have 2D, 3D, graphics, video,
whatever you want on a layer.

00:43:40.350 --> 00:43:44.740
It has an asynchronous rendering
thread that's actually running

00:43:44.740 --> 00:43:49.290
at vertical retrace intervals
and drawing the scene for you.

00:43:49.390 --> 00:43:50.520
So you don't have to worry about that.

00:43:50.520 --> 00:43:50.880
It's always ready.

00:43:50.880 --> 00:43:52.640
responsive.

00:43:52.700 --> 00:44:42.200
[Transcript missing]

00:44:43.900 --> 00:44:49.560
So you just need to specify the goal
state in your application logic,

00:44:49.710 --> 00:44:51.480
and the animation will
begin asynchronously and

00:44:51.480 --> 00:44:52.570
attain your target goal.

00:44:52.690 --> 00:44:56.860
Now, if you need to change your mind
because the user pressed another key,

00:44:56.860 --> 00:45:01.410
you can still change the model state,
and the animation engine will

00:45:01.410 --> 00:45:06.090
then reacquire that new goal and
start animating towards that.

00:45:06.290 --> 00:45:09.200
There's also a batched transaction
model if you want to do multiple things.

00:45:09.260 --> 00:45:12.080
I don't show transaction here
because there's an implicit

00:45:12.110 --> 00:45:13.680
transaction around every event.

00:45:13.710 --> 00:45:19.080
So suppose I wanted to do things,
set the opacity to zero of both

00:45:19.250 --> 00:45:20.800
the blue and the green layers.

00:45:20.800 --> 00:45:24.980
I can do that once through my run loop,
then things will start to animate away.

00:45:24.980 --> 00:45:28.290
If I want to do something
a little more complicated,

00:45:28.300 --> 00:45:33.910
like say, take the blue layer and set its
opacity to zero so it fades out,

00:45:34.360 --> 00:45:37.450
set its size to zero so it shrinks,
and take the green layer and

00:45:37.450 --> 00:45:40.440
send it off to the right,
I can do that just by

00:45:40.440 --> 00:45:42.700
executing that code.

00:45:42.700 --> 00:45:44.660
So let me give you a demo.

00:45:44.660 --> 00:45:46.020
You saw one this morning.

00:45:46.020 --> 00:45:50.610
I will give you a little
bit of a different one.

00:45:52.500 --> 00:45:54.260
It's going to be in the same app, though.

00:45:54.300 --> 00:45:58.090
I have the executive version.

00:45:58.520 --> 00:46:03.840
So we'll go through the first couple
of camera moves here until we get here.

00:46:03.840 --> 00:46:07.360
And I'll bring up my little menuing
system that I happen to have.

00:46:07.410 --> 00:46:10.520
And this menuing system is all
done in core animation as well.

00:46:10.550 --> 00:46:13.110
I can move forward and backwards.

00:46:15.530 --> 00:46:19.220
I'll show you a little bit about
the acquiring new goal states.

00:46:19.240 --> 00:46:24.520
If I hold down the infamous
Shift key and move to the next menu,

00:46:24.570 --> 00:46:27.740
you can see if I change
my mind halfway through,

00:46:27.750 --> 00:46:30.720
it will acquire the new
state kind of on the fly.

00:46:30.760 --> 00:46:31.750
And that's just automatic.

00:46:31.840 --> 00:46:34.400
The application code is just
setting which menu is current.

00:46:34.440 --> 00:46:38.340
So what did I want to show you here?

00:46:38.340 --> 00:46:43.270
Well, I wanted to show you the cityscape.

00:46:44.590 --> 00:46:50.400
and I've got some preset camera
views that I can show here.

00:46:50.430 --> 00:46:52.790
So here's the city all built.

00:46:52.970 --> 00:46:55.570
The city actually builds

00:46:56.300 --> 00:47:23.200
[Transcript missing]

00:47:23.830 --> 00:47:25.790
Another one is the folding building.

00:47:25.790 --> 00:47:28.690
The folding building is over here.

00:47:28.790 --> 00:47:31.700
He builds like that,
which is kind of cool.

00:47:32.040 --> 00:47:35.480
Again,
if I move back a little and run that,

00:47:35.480 --> 00:47:40.700
I can show you the city while
the folding building builds.

00:47:40.700 --> 00:47:44.690
You can see the guys
come in here at the end.

00:47:46.460 --> 00:47:48.760
What else did I want to show?

00:47:48.760 --> 00:47:54.570
We said we could show video on a plane,
but no one's actually proven that yet,

00:47:54.580 --> 00:47:56.490
so let me prove that to you.

00:47:56.500 --> 00:48:01.160
I'll go back to one of the outtake modes
we didn't use in this morning's demo,

00:48:01.160 --> 00:48:02.210
but it's called Huge.

00:48:02.220 --> 00:48:05.180
It's just like a big
plane of your album art,

00:48:05.180 --> 00:48:07.640
and you can select in,
and you can see now I do have

00:48:07.760 --> 00:48:09.680
some video on some layers here.

00:48:09.680 --> 00:48:13.520
There should be audio on this,
but I don't know if they've turned it up.

00:48:15.420 --> 00:48:18.010
You can see I can move around.

00:48:18.960 --> 00:48:21.540
Take control of the camera,
kind of show it zooming out.

00:48:21.560 --> 00:48:25.210
Another view we had was the panel's view.

00:48:25.220 --> 00:48:28.930
The panel's view was like
a bunch of playlists in 3D,

00:48:28.940 --> 00:48:32.940
kind of each with a little
screen saver running on them,

00:48:32.960 --> 00:48:35.660
and that's kind of fun
to move around as well.

00:48:35.690 --> 00:48:40.020
And then finally,
I'll show you the city back with the

00:48:40.020 --> 00:48:43.700
... some video on some textures here.

00:48:43.700 --> 00:48:48.830
That's kind of fun.

00:48:52.800 --> 00:48:56.350
So that's a little bit behind
the scenes on the core animation

00:48:56.360 --> 00:48:58.260
demo from this morning.

00:49:04.480 --> 00:49:07.890
So there's going to be sessions on that,
so I think in the big hall here,

00:49:07.970 --> 00:49:09.840
so please go to those
and get much more detail.

00:49:09.840 --> 00:49:12.040
The other thing we're
doing with core animation,

00:49:12.050 --> 00:49:14.880
which is really important to us,
is doing full integration

00:49:14.900 --> 00:49:16.040
up the Cocoa stack.

00:49:16.230 --> 00:49:19.760
So core animation is backed
by a layering engine,

00:49:19.760 --> 00:49:24.440
which actually is hierarchical in
the same way NSView hierarchy is.

00:49:24.440 --> 00:49:28.150
And so in Leopard,
you're able to back an NSView hierarchy

00:49:28.200 --> 00:49:32.370
by a hierarchy of layers that
are built with core animation.

00:49:32.380 --> 00:49:33.840
So that's really exciting.

00:49:34.270 --> 00:49:37.570
And that allows you not only to have 2D,
3D graphics and video on layers,

00:49:37.580 --> 00:49:40.960
but Aqua controls as well
with full interactivity,

00:49:40.960 --> 00:49:41.660
and that's great.

00:49:41.680 --> 00:49:45.380
And it's all built into
the new interface builder.

00:49:45.380 --> 00:49:49.800
And to give you a look at that,
I'd like to invite Andreas Wendker

00:49:50.040 --> 00:49:52.700
up to the stage to give you a demo.

00:49:52.700 --> 00:49:53.200
Thanks.

00:49:53.200 --> 00:49:53.900
Thank you.

00:50:00.000 --> 00:50:02.140
As Peter just explained,
we are building core animation

00:50:02.190 --> 00:50:04.710
capabilities right in our
Cocoa frameworks into the

00:50:04.710 --> 00:50:07.750
new Leopard interface builder,
so that you can easily take

00:50:07.750 --> 00:50:11.010
advantage of hardware acceleration
and implicit animations.

00:50:11.060 --> 00:50:13.680
I'd like to show you an example of that.

00:50:17.520 --> 00:50:20.700
What you see here is a very
simple photo viewer application.

00:50:20.810 --> 00:50:24.280
This application is hooked up to a core
data database that contains the pictures

00:50:24.350 --> 00:50:26.610
you currently see here in the window.

00:50:26.750 --> 00:50:29.460
The pictures themselves are displayed
in a new class of view that we are

00:50:29.460 --> 00:50:30.860
adding to the Cocoa frameworks.

00:50:30.940 --> 00:50:32.450
The end is grid view.

00:50:32.570 --> 00:50:36.320
And the content of this grid view is
populated through a binding to the array

00:50:36.320 --> 00:50:38.660
of pictures loaded from the database.

00:50:38.660 --> 00:50:41.850
So since it's using a binding,
the grid view will automatically reflect

00:50:41.850 --> 00:50:43.640
any changes in the underlying array.

00:50:43.640 --> 00:50:46.300
For example, if you reorder the pictures.

00:50:46.300 --> 00:50:48.900
To demonstrate that to you,
I added a button to my application

00:50:48.920 --> 00:50:51.670
that will randomly reshuffle
the pictures in the array.

00:50:51.700 --> 00:50:54.340
Let me show you how the
grid view reacts to that.

00:50:56.780 --> 00:50:59.410
So as you can see, instead of immediately
jumping to the new state,

00:50:59.620 --> 00:51:02.840
the GridView will actually react with
an implicit animation to it and smoothly

00:51:02.840 --> 00:51:04.720
slide the pictures into the new space.

00:51:04.720 --> 00:51:07.170
Let me do this again,
this time sorting by

00:51:07.170 --> 00:51:08.620
name of the pictures.

00:51:08.620 --> 00:51:10.850
And I added a button to slow down
the animations just so that you

00:51:10.850 --> 00:51:12.770
can see better what's going on.

00:51:13.020 --> 00:51:15.830
And let me turn around the order
of the pictures in the array.

00:51:16.980 --> 00:51:18.860
Oh, and of course,
since this is a core data application,

00:51:18.860 --> 00:51:20.740
I can also undo this change.

00:51:20.740 --> 00:51:23.420
Actually, I can't.

00:51:24.570 --> 00:51:25.780
That's because I didn't
make a change here.

00:51:25.860 --> 00:51:26.830
Sorry.

00:51:26.900 --> 00:51:29.620
Of course,
I can go ahead and rename a picture

00:51:29.630 --> 00:51:31.120
just by clicking here in the grid view.

00:51:31.120 --> 00:51:38.000
And as you can see,
since we're using bindings again,

00:51:44.400 --> 00:51:46.990
Since we're using bindings again,
the name change will result

00:51:47.010 --> 00:51:49.400
in an automatic reordering
of the pictures in the array.

00:51:49.570 --> 00:51:51.360
And again,
the grid will react with animation.

00:51:51.380 --> 00:51:54.630
And now I can undo.

00:51:54.690 --> 00:51:55.250
There we go.

00:51:55.320 --> 00:51:58.090
So let me show you how
this application is built.

00:52:04.310 --> 00:52:06.200
Here's the project in Xcode.

00:52:06.230 --> 00:52:08.840
All you find in this project is
a very simple core data model,

00:52:08.840 --> 00:52:11.860
which as you can see just
contains a simple entity.

00:52:11.900 --> 00:52:14.660
And you also find about
100 lines of code.

00:52:17.950 --> 00:52:20.600
This code deals directly with any
of the view animations you saw.

00:52:20.600 --> 00:52:23.040
This is just the standard code
you pretty much find in any

00:52:23.100 --> 00:52:24.380
Core Data Template application.

00:52:24.410 --> 00:52:26.390
It's just the code to
set up the database,

00:52:26.390 --> 00:52:29.050
to configure the undo manager,
and other things.

00:52:29.190 --> 00:52:32.700
The only code I had to add myself to this
application is the code that randomly

00:52:32.700 --> 00:52:35.300
reshuffles the pictures in the array.

00:52:35.400 --> 00:52:39.240
So the entire behavior of the user
interface is defined in the Nib file.

00:52:39.350 --> 00:52:42.410
Let me open that up for you
in the new interface builder.

00:52:45.190 --> 00:52:47.520
The large black area you see
here is the Andes grid view,

00:52:47.520 --> 00:52:50.410
which of course is empty
here in interface builder.

00:52:50.660 --> 00:52:52.860
Now the grid view is a
completely generic type of view.

00:52:52.880 --> 00:52:54.770
It's not specialized
in displaying photos.

00:52:54.960 --> 00:52:57.780
In fact, it can display arbitrary
types of objects.

00:52:57.860 --> 00:53:00.460
And to tell the grid view
how to display these objects,

00:53:00.510 --> 00:53:02.770
it allows you to combine
regular NS controls,

00:53:02.780 --> 00:53:06.660
things like text fields, buttons,
sliders, and little compound views that

00:53:06.770 --> 00:53:11.390
become the prototype for each of the
elements displayed in the grid view.

00:53:12.000 --> 00:53:14.920
I know it's going to be hard to see
here on the screen because of the color

00:53:14.920 --> 00:53:17.830
and transparency settings I'm using,
but here's the little compound view

00:53:17.840 --> 00:53:22.110
that becomes the prototype for all
the little pictures in my view.

00:53:23.430 --> 00:53:26.010
Now let me go ahead and extend the
functionality of my application

00:53:26.110 --> 00:53:28.180
by adding filtering to it.

00:53:28.310 --> 00:53:29.710
For that,
I'm going to go into the library

00:53:29.710 --> 00:53:32.380
window of Interface Builder.

00:53:34.550 --> 00:53:37.440
The library window contains all the
objects I can add to my Nib file,

00:53:37.450 --> 00:53:40.900
and it's one of the cool new features
we added to the new interface builder.

00:53:40.900 --> 00:53:43.870
As you can see,
it's organized in a hierarchy of groups.

00:53:44.140 --> 00:53:46.180
Right now I have the entire
Cocoa group selected,

00:53:46.340 --> 00:53:49.500
but I can also drill down and
just look at the comment controls,

00:53:49.500 --> 00:53:52.340
or maybe what we call the extra controls,
or maybe look at both of

00:53:52.340 --> 00:53:53.500
them at the same time.

00:53:53.560 --> 00:53:55.930
And yes, you might have guessed it,
we are using a grid view here

00:53:55.930 --> 00:53:57.500
in the library window too.

00:53:59.700 --> 00:54:02.610
Another great feature we added to the
new interface builder is the ability

00:54:02.610 --> 00:54:05.290
to edit toolbars right in the Nib file.

00:54:10.410 --> 00:54:13.440
So I can just take a search
field out of my library,

00:54:13.470 --> 00:54:16.590
drag it into my toolbar,
make it part of the default

00:54:16.590 --> 00:54:18.940
set of items in the toolbar.

00:54:18.950 --> 00:54:21.610
Now all I have to do is set up
a binding from the search field

00:54:21.930 --> 00:54:25.390
to the array controller in my
Nib file to configure the filter.

00:54:25.440 --> 00:54:27.480
Let me go ahead and do that.

00:54:37.900 --> 00:54:41.560
I'm going to configure the bindings
so that it filters in a case-intensive

00:54:41.560 --> 00:54:43.290
way on the name of the picture.

00:54:43.340 --> 00:54:44.490
That's all I have to do.

00:54:44.530 --> 00:54:45.250
So I'm done here.

00:54:45.260 --> 00:54:46.840
Save the Nib file.

00:54:46.920 --> 00:54:49.670
Go back to Xcode, build and run.

00:54:50.070 --> 00:54:51.210
So here's my application again.

00:54:51.340 --> 00:54:53.440
I can still reorder the pictures,
of course.

00:54:53.550 --> 00:54:57.030
Now I can also filter, for example,
everything with an S.

00:54:57.090 --> 00:54:59.400
Let me slow this down for you.

00:55:12.900 --> 00:55:15.640
So that's just one simple example
of how you can make use of core

00:55:15.640 --> 00:55:18.140
animation when it's built right
into Cocoa and interface builder.

00:55:18.140 --> 00:55:20.140
We hope that you will make
extensive use of this.

00:55:20.150 --> 00:55:21.140
Thank you.

00:55:21.140 --> 00:55:22.140
Great.

00:55:22.140 --> 00:55:23.140
Thanks, Andreas.

00:55:30.810 --> 00:55:31.470
Very cool stuff.

00:55:31.580 --> 00:55:34.840
The thing I like about that
demo is it really doesn't have

00:55:34.840 --> 00:55:35.850
anything to do with animation.

00:55:35.850 --> 00:55:39.190
I mean, it's really just about the
data and about the application,

00:55:39.200 --> 00:55:43.290
and the fluid user experience
just happens implicitly.

00:55:43.390 --> 00:55:45.480
So I think that's really cool.

00:55:46.470 --> 00:55:49.820
So let's talk about pixels, more pixels.

00:55:50.170 --> 00:55:52.860
So we've got these great
big 30-inch displays now,

00:55:52.860 --> 00:55:53.700
which is great.

00:55:53.700 --> 00:55:55.460
And so there's kind of a
real estate boom going on,

00:55:55.460 --> 00:55:55.900
right?

00:55:55.900 --> 00:55:58.450
We've got lots of windows open.

00:55:58.460 --> 00:56:01.450
We can be real productive
in our big screens.

00:56:01.640 --> 00:56:06.490
But what happens if we were to increase
the density to 200 DPI on these displays?

00:56:06.600 --> 00:56:08.800
Well, maybe it's a little bit
too much of a good thing.

00:56:09.100 --> 00:56:10.580
Can't quite see what I'm doing.

00:56:10.580 --> 00:56:11.980
My icons are real small.

00:56:11.980 --> 00:56:13.710
My text is real small.

00:56:13.890 --> 00:56:15.700
So what are we going to do about that?

00:56:16.300 --> 00:56:22.650
The solution is pretty obvious--
resolution-independent user interface.

00:56:28.700 --> 00:56:31.760
So more pixels can provide more detail.

00:56:31.930 --> 00:56:35.120
So if you have a 200 DPI monitor,
wouldn't it be great if it looked

00:56:35.440 --> 00:56:38.850
just like the 100 DPI monitor,
except if you zoom in,

00:56:39.250 --> 00:56:42.020
instead of being faced
with this at 100 DPI,

00:56:42.130 --> 00:56:44.790
you could have something like that.

00:56:46.400 --> 00:59:30.400
[Transcript missing]

00:59:30.790 --> 00:59:32.010
So what do you have to do?

00:59:32.120 --> 00:59:33.500
Well, avoid Quick Draw.

00:59:33.500 --> 00:59:36.710
We've been saying it for a while.

00:59:36.760 --> 00:59:40.620
This is now a great time to go
get rid of those last vestiges of

00:59:40.730 --> 00:59:42.640
Quick Draw in your applications.

00:59:42.740 --> 00:59:44.160
Provide high resolution artwork.

00:59:44.160 --> 00:59:47.700
Again, those 512 by 512 icons.

00:59:48.060 --> 00:59:51.840
Or consider using, say,
PDF for some icons if they're fairly

00:59:51.840 --> 00:59:54.460
easily represented by vectors.

00:59:54.460 --> 00:59:55.570
Test with Quartz debug.

00:59:55.620 --> 00:59:57.920
This has been in the
release for a little while.

00:59:57.920 --> 01:00:01.100
Be able to set the user interface
resolution and run your app.

01:00:01.110 --> 01:00:03.860
And we're asking applications
to be ready by 2008.

01:00:03.860 --> 01:00:06.280
That's when we expect to be ready.

01:00:07.920 --> 01:00:10.290
So that's more pixels.

01:00:10.410 --> 01:00:13.840
So these are the ingredients
of our cinematic experience.

01:00:13.860 --> 01:00:15.480
But why do we sort of do all of this?

01:00:15.570 --> 01:00:18.600
Well, the answer is, again,
in the nice restaurant,

01:00:18.600 --> 01:00:19.700
the food is presented to you.

01:00:19.700 --> 01:00:22.500
If it looks great,
before you even take a bite of it,

01:00:22.500 --> 01:00:24.000
you know it's going to be good.

01:00:24.030 --> 01:00:29.540
And so we have a lot of tools that
we've presented to you for doing great,

01:00:29.550 --> 01:00:31.170
gorgeous user interfaces.

01:00:31.390 --> 01:00:34.060
So even before the user
starts typing in your app,

01:00:34.080 --> 01:00:36.120
or when they pick up that
icon and drag it around,

01:00:36.120 --> 01:00:40.540
everything just looks and feels
like you spent a lot of time.

01:00:40.620 --> 01:00:43.140
Each attention to detail is a
little message to your user,

01:00:43.160 --> 01:00:45.880
saying that you care about them,
and you're going to give

01:00:45.880 --> 01:00:47.680
them a great experience.

01:00:47.740 --> 01:00:51.880
So that's our trip through GPU land,
using cinematic

01:00:52.040 --> 01:00:53.820
experiences as a metaphor.

01:00:53.820 --> 01:00:56.570
And we're going to go back to
our tour of hardware and software

01:00:56.570 --> 01:00:58.600
integration with Scott Forstall.

01:00:58.690 --> 01:01:00.590
Thanks very much.

01:01:07.630 --> 01:01:10.900
Okay, let's see what I get to talk about.

01:01:10.920 --> 01:01:15.620
The magical mosaic says cameras.

01:01:15.910 --> 01:01:19.130
So as you know,
we've been building cameras into

01:01:19.150 --> 01:01:21.900
almost all of our new machines.

01:01:21.950 --> 01:01:24.950
And for the machines where
we don't build a camera in,

01:01:24.950 --> 01:01:28.980
we provide the EyeSight,
which you can go ahead and add as well.

01:01:32.360 --> 01:01:34.000
One of the first things we
do when you get your new

01:01:34.100 --> 01:01:37.680
machine is take your mug shot.

01:01:37.720 --> 01:01:43.230
And we use this picture as
your login window picture.

01:01:43.300 --> 01:01:47.590
Once you've logged in,
we use it in the address book.

01:01:48.250 --> 01:01:51.000
Now let's say you don't
like your mugshot.

01:01:51.060 --> 01:01:55.000
We have a picture taker panel
where you can take a new picture.

01:01:55.000 --> 01:01:58.180
Much better.

01:01:59.790 --> 01:02:03.900
So we're using this picture taker panel,
both in the address book.

01:02:03.920 --> 01:02:06.100
We're using it in system preferences.

01:02:06.280 --> 01:02:08.980
We're using it in iChat
for your buddy list.

01:02:09.050 --> 01:02:10.520
So we're using it all over the place.

01:02:10.520 --> 01:02:14.160
So we decided to make it
a public API for Leopard.

01:02:18.520 --> 01:02:21.660
This does not come
complete with Nick Nolte.

01:02:21.720 --> 01:02:26.860
So the Picture Taker panel allows
you to take picture snapshots.

01:02:26.870 --> 01:02:29.220
It's a consistent UI throughout the OS.

01:02:29.220 --> 01:02:31.520
You can use it everywhere.

01:02:31.520 --> 01:02:35.230
It has the automatic flash
to fill in highlights.

01:02:35.340 --> 01:02:37.640
Once you take your picture,
you can zoom it, you can crop it,

01:02:37.640 --> 01:02:38.880
you can rotate it.

01:02:38.910 --> 01:02:42.880
And really importantly,
we handle the camera state for you.

01:02:43.010 --> 01:02:45.990
This is especially important
for an external eyesight.

01:02:46.100 --> 01:02:48.450
We handle whether or not
the iris is open or closed.

01:02:48.460 --> 01:02:50.960
We handle whether or not the
person unplugs the cable.

01:02:51.190 --> 01:02:52.480
So you just call the panel.

01:02:52.570 --> 01:02:55.080
We return you a picture
once they're happy with it.

01:02:55.090 --> 01:02:57.280
That's the Picture Taker panel.

01:02:57.500 --> 01:03:02.080
Next, of course the most fun way to
take pictures is with Photo Booth.

01:03:02.160 --> 01:03:05.320
We are bundling Photo Booth in Leopard.

01:03:05.390 --> 01:03:07.270
It's fun because of all
these crazy effects.

01:03:07.420 --> 01:03:11.110
I know my kids play with it for hours.

01:03:11.270 --> 01:03:15.050
In Leopard we're actually opening
it up so you can create your own

01:03:15.160 --> 01:03:18.460
effects which Photo Booth will
pick up and you can use as well.

01:03:18.530 --> 01:03:21.230
Just create a quartz composition,
put it on the system

01:03:21.320 --> 01:03:22.800
and we'll pick it up.

01:03:22.840 --> 01:03:24.720
That's Photo Booth.

01:03:25.310 --> 01:03:28.100
Now our cameras are really
good not just for still photos,

01:03:28.170 --> 01:03:30.840
but also for capturing video.

01:03:30.940 --> 01:03:34.050
We use this in QuickTime Player,
so with QuickTime Pro you

01:03:34.140 --> 01:03:35.940
can capture video.

01:03:36.040 --> 01:03:40.300
Of course iMovie allows you to capture
video straight from the eyesight.

01:03:40.400 --> 01:03:44.280
And we use it in iChats,
video conferencing to capture video,

01:03:44.280 --> 01:03:48.390
and now in Leopard we also apply
fun effects to those as well.

01:03:48.540 --> 01:03:52.740
So to make it as easy as possible
for all of you to take advantage

01:03:52.830 --> 01:03:55.640
of all the built-in cameras,
we're going to make it easy,

01:03:55.730 --> 01:03:59.880
we're adding a new API called
the QtKit Capture APIs.

01:04:04.510 --> 01:04:08.480
The Qt Kit Capture APIs are an
absolute pro-grade solution.

01:04:08.560 --> 01:04:12.900
They are meant to support everything from
the highest end professional applications

01:04:13.260 --> 01:04:15.020
down to a consumer application.

01:04:15.090 --> 01:04:17.220
They give you frame accurate AV sync.

01:04:17.230 --> 01:04:20.660
So it syncs the frame
with the audio perfectly.

01:04:20.730 --> 01:04:24.370
We support both the internal and
the external eye sights and a

01:04:24.370 --> 01:04:27.180
host of other cameras as well.

01:04:28.120 --> 01:04:30.750
We allow you to capture
directly to a file.

01:04:30.970 --> 01:04:32.640
You can capture to a stream.

01:04:32.780 --> 01:04:35.450
We have a really nice on-screen preview,
so you can see the video

01:04:35.450 --> 01:04:36.690
as it's being captured.

01:04:36.920 --> 01:04:41.300
And this whole thing integrates
in with the OpenGL pipeline,

01:04:41.420 --> 01:04:44.180
so you can do what you want
with the video as it comes in.

01:04:44.370 --> 01:04:47.320
So that's the Qticket Capture APIs.

01:04:52.490 --> 01:04:55.720
Now in Leopard,
we took iChat one step further and

01:04:55.720 --> 01:05:00.520
added sort of a virtual camera in
this thing we call iChat Theater.

01:05:00.580 --> 01:05:05.110
And iChat Theater allows you to plug
an application in to a video conference

01:05:05.440 --> 01:05:08.000
and present it across the conference.

01:05:08.000 --> 01:05:10.630
So in this case,
we've already plugged in iPhoto,

01:05:10.730 --> 01:05:14.600
so you can do an iPhoto
slideshow across the web.

01:05:14.890 --> 01:05:17.010
We've plugged in Keynote,
so you can do Keynote

01:05:17.130 --> 01:05:20.290
presentations as well,
and even QuickTime Player.

01:05:20.300 --> 01:05:23.360
But we've done iChat
Theater in a public way.

01:05:23.360 --> 01:05:25.430
There's a set of APIs,
so you can plug your

01:05:25.430 --> 01:05:27.080
applications into it as well.

01:05:32.960 --> 01:05:36.080
The way you do this is you
take and register with the

01:05:36.080 --> 01:05:37.400
instant message framework.

01:05:37.440 --> 01:05:39.820
That is the iChat framework.

01:05:39.880 --> 01:05:42.400
Your application
controls all the content.

01:05:42.460 --> 01:05:45.520
So you control when you start playing,
when you stop, any transitions.

01:05:45.580 --> 01:05:48.130
You control all the content.

01:05:48.290 --> 01:05:50.260
You'll get a series of callbacks.

01:05:50.310 --> 01:05:53.160
In each callback,
you render a single frame of the

01:05:53.160 --> 01:05:56.260
animation into a core video buffer,
and there's several of those.

01:05:56.340 --> 01:06:00.880
You use core audio to provide the audio,
and then you're done.

01:06:00.960 --> 01:06:06.010
We'll go ahead, we'll 264 encode it,
we'll worry about latency issues,

01:06:06.010 --> 01:06:10.240
we'll get it across the wire,
and display it on the other side.

01:06:10.240 --> 01:06:13.270
So you just get a series of callbacks,
provide the content, and you're done.

01:06:13.280 --> 01:06:15.070
That is iChat Theater.

01:06:22.350 --> 01:06:24.950
We're doing a lot with cameras,
but when I look at it,

01:06:24.950 --> 01:06:28.770
I think we're just still scratching
the surface of what we can do.

01:06:28.780 --> 01:06:33.290
Cameras to me are a lot
like a keyboard or a mouse.

01:06:33.320 --> 01:06:35.090
It's just another input device.

01:06:35.100 --> 01:06:38.200
And the camera's becoming a more
and more ubiquitous input device,

01:06:38.200 --> 01:06:39.840
and it's really high bandwidth.

01:06:39.840 --> 01:06:41.020
There's a lot we can do.

01:06:41.040 --> 01:06:44.220
So I actually have been looking at a
number of applications that you've been

01:06:44.220 --> 01:06:46.000
writing that I think are really cool.

01:06:46.000 --> 01:06:46.840
Here's one.

01:06:46.840 --> 01:06:48.180
It's called EvoCam.

01:06:48.180 --> 01:06:49.980
It's a video baby monitor.

01:06:51.050 --> 01:06:55.400
There's a Delicious Library.

01:06:55.400 --> 01:07:00.120
Delicious Library uses the camera
to scan the barcodes of books

01:07:00.210 --> 01:07:04.040
and DVDs and movies and CDs and
automatically add it to your library.

01:07:06.440 --> 01:07:09.540
There's this thing called I Alert You.

01:07:09.540 --> 01:07:12.990
It's a security device for your computer.

01:07:13.080 --> 01:07:16.900
So let's say you have your MacBook,
you're at the cafe,

01:07:16.900 --> 01:07:20.450
you walk away to get some more coffee,
and some criminal comes and

01:07:20.550 --> 01:07:21.920
screws with your machine.

01:07:27.990 --> 01:07:29.400
You could light his breath on fire.

01:07:29.400 --> 01:07:33.940
It'll actually take a picture of them.

01:07:34.010 --> 01:07:36.800
And so you come back,
you find out who screwed with it.

01:07:36.800 --> 01:07:39.120
If he steals your machine,
it actually in the future is

01:07:39.120 --> 01:07:43.510
going to email you his picture,
so you can go track him down in Malibu.

01:07:43.760 --> 01:07:46.250
So that's iAlertU.

01:07:46.680 --> 01:07:48.260
There's iStopMotion.

01:07:48.300 --> 01:07:50.770
iStopMotion will let you
be the next Nick Park.

01:07:50.840 --> 01:07:52.890
You can create Wallace and Gromit.

01:07:52.920 --> 01:07:53.540
It's great.

01:07:53.540 --> 01:07:57.660
It allows you to create stop motion
movies by sort of translucently putting

01:07:57.660 --> 01:07:59.110
the last frame over the next one.

01:07:59.120 --> 01:08:01.760
You can watch it as you
do your manipulations.

01:08:01.820 --> 01:08:04.560
And there's this thing called ToySight.

01:08:04.650 --> 01:08:10.830
ToySight's the best way to have fun
and exercise and look very silly.

01:08:10.910 --> 01:08:14.490
The camera watches where your
hands are and basically puts

01:08:14.730 --> 01:08:16.480
virtual controls into the air.

01:08:16.750 --> 01:08:19.800
And as you move your hands around,
it tracks them and you're

01:08:19.800 --> 01:08:21.660
actually controlling the game.

01:08:21.780 --> 01:08:23.140
So that's ToySight.

01:08:23.370 --> 01:08:28.020
So we're bringing the cameras
to almost all of our machines.

01:08:28.100 --> 01:08:30.840
We're bringing more and more APIs,
especially in Leopard,

01:08:30.940 --> 01:08:34.900
to make it really easy for you to
take advantage of these cameras.

01:08:34.960 --> 01:08:37.690
I can't wait to see more and
more applications of yours that

01:08:37.770 --> 01:08:39.240
take advantage of the camera.

01:08:39.300 --> 01:08:40.340
And that is the camera.

01:08:42.030 --> 01:08:43.820
Next.

01:08:48.370 --> 01:08:49.540
OhMysteriousMosaic.

01:08:49.540 --> 01:08:54.780
Hard drive, sweet.

01:08:55.080 --> 01:08:57.700
Not for the sexiest part of the demo.

01:08:57.830 --> 01:08:59.820
The hard drive.

01:09:00.340 --> 01:09:04.480
A few days ago,
I was comparing the original Mac to

01:09:04.480 --> 01:09:08.420
our current standard 20-inch iMac.

01:09:08.470 --> 01:09:11.040
And I was comparing it on
three different aspects:

01:09:11.050 --> 01:09:15.270
the CPU speed, the amount of RAM,
and the size of the hard drive.

01:09:16.340 --> 01:09:17.370
You look at CPU speed.

01:09:17.540 --> 01:09:20.340
The original one was
an 8 megahertz 68,000.

01:09:20.750 --> 01:09:21.960
Currently we're at 2 gigahertz.

01:09:22.100 --> 01:09:27.390
So just on clock speed alone,
it's 250 times faster, right?

01:09:27.450 --> 01:09:29.680
There's a lot of other things,
but on clock speed alone.

01:09:29.680 --> 01:09:33.800
You look at RAM, it was 128 kilobytes,
non-upgradable.

01:09:33.930 --> 01:09:35.270
It was an appliance.

01:09:35.370 --> 01:09:36.440
It was perfect.

01:09:39.260 --> 01:09:43.710
And the new one ships
512 megabytes standard.

01:09:43.810 --> 01:09:47.560
So that's 4,000 times larger.

01:09:47.600 --> 01:09:51.360
But if you look at the hard drive size,
it actually blows all this away.

01:09:51.390 --> 01:09:58.220
We go from a 400 kilobyte removable
disk to a standard 250 gigabyte drive,

01:09:58.260 --> 01:10:03.020
which is 625,000 times larger.

01:10:03.050 --> 01:10:06.910
And yet it's still full.

01:10:12.420 --> 01:10:15.470
So with these large drives,
we are filling it up with

01:10:15.470 --> 01:10:17.290
lots and lots of content.

01:10:17.290 --> 01:10:20.280
And once you have all this content,
there's two things you want to do.

01:10:20.370 --> 01:10:23.020
The first thing you want to do
is find what you're looking for,

01:10:23.210 --> 01:10:24.760
and that's what Spotlight's about.

01:10:24.760 --> 01:10:27.540
And the second thing you want
to do is preserve what you have,

01:10:27.540 --> 01:10:29.630
and that's what Time Machine's all about.

01:10:29.650 --> 01:10:31.940
So let's start with Spotlight.

01:10:32.900 --> 01:10:37.280
Spotlight's great because it allows you
to very quickly search and find anything

01:10:37.280 --> 01:10:38.630
you're looking for on your machine.

01:10:38.650 --> 01:10:42.680
You can search by both file name,
but also metadata and contents.

01:10:42.760 --> 01:10:47.710
And the way we do that is we provide a
whole set of Spotlight importer plug-ins.

01:10:47.820 --> 01:10:50.900
These understand the file types,
they read it in,

01:10:50.900 --> 01:10:53.620
and they hand the metadata
and the contents to Spotlight,

01:10:53.620 --> 01:10:54.680
which does an index of it.

01:10:54.760 --> 01:10:58.300
But we still hear from people that
there are certain file types where

01:10:58.480 --> 01:11:02.290
you can't search them in Spotlight
based on metadata or contents.

01:11:02.760 --> 01:11:05.870
And that's because it's a proprietary
file format that we don't have access to.

01:11:05.880 --> 01:11:09.010
So if you're creating those,
please write a Spotlight

01:11:09.160 --> 01:11:10.310
importer plug-in.

01:11:10.380 --> 01:11:12.840
We try to make this
as simple as possible.

01:11:12.860 --> 01:11:14.000
There's one API.

01:11:14.000 --> 01:11:17.100
You already have the code
that parses your file.

01:11:17.100 --> 01:11:18.700
We even give you an Xcode project.

01:11:18.700 --> 01:11:21.240
So please write in
Spotlight importer plug-in,

01:11:21.240 --> 01:11:24.230
and then people will be able
to search for your files.

01:11:24.260 --> 01:11:28.360
Once you've written the plug-in,
the best place to distribute it is

01:11:28.380 --> 01:11:31.060
right inside your application package.

01:11:31.120 --> 01:11:32.600
If you put it in the application,
you can search for your files.

01:11:32.600 --> 01:11:34.500
So you can see that you've
got the same package that when

01:11:34.760 --> 01:11:37.110
people get your application,
they can immediately search for all

01:11:37.230 --> 01:11:38.780
of your file types on their machine.

01:11:39.150 --> 01:11:41.320
Also, tell us about it.

01:11:41.320 --> 01:11:42.300
We'll put it on our website.

01:11:42.420 --> 01:11:44.990
We have over 50 Spotlight
importer plug-ins on our website

01:11:44.990 --> 01:11:46.310
that people can download.

01:11:46.410 --> 01:11:48.310
So tell us about it as well.

01:11:48.320 --> 01:11:51.660
So once you've done that,
now we want to make sure that

01:11:51.670 --> 01:11:54.270
we're preserving all this metadata.

01:11:55.200 --> 01:11:58.440
When you have a file that
has all this great metadata,

01:11:58.530 --> 01:12:01.110
and we're getting more
and more as time goes by,

01:12:01.110 --> 01:12:03.430
you want to make sure
when you save the file,

01:12:03.430 --> 01:12:05.270
you don't lose the metadata.

01:12:05.280 --> 01:12:08.110
There's some metadata that
you don't even know about.

01:12:08.120 --> 01:12:10.560
It's Finder contents, ACLs,
there's a bunch of things on there

01:12:10.650 --> 01:12:12.180
that you might not even know about.

01:12:12.180 --> 01:12:14.920
So we asked you this last year,
but now we're going to

01:12:14.930 --> 01:12:16.200
make it easy for you.

01:12:16.220 --> 01:12:17.760
We're adding a new API.

01:12:17.760 --> 01:12:20.110
It's called the Replace Object API.

01:12:20.110 --> 01:12:21.620
It is a safe save API.

01:12:21.620 --> 01:12:24.920
What you do is take,
save your new file on the side,

01:12:24.920 --> 01:12:29.150
call Replace Object, it will replace it
with the original file,

01:12:29.150 --> 01:12:33.060
preserving exactly the
metadata you want to preserve.

01:12:33.060 --> 01:12:36.600
So when you change the file and save it,
you'll preserve all the metadata.

01:12:36.640 --> 01:12:39.540
It's the Replace Object API.

01:12:39.540 --> 01:12:40.790
Thank you.

01:12:44.930 --> 01:12:48.880
Okay, this next spotlight feature is
for the excessively lazy of us,

01:12:49.110 --> 01:12:51.450
myself included.

01:12:52.010 --> 01:12:57.800
Let's say you're sitting at home,
in the living room, on the couch,

01:12:57.830 --> 01:12:58.620
working on your MacBook.

01:12:58.620 --> 01:13:02.720
And you're looking for a file,
but it's not on that machine.

01:13:02.720 --> 01:13:04.500
It might be on the
machine that's upstairs.

01:13:04.500 --> 01:13:09.560
It might be on the machine
that's over in the den.

01:13:09.560 --> 01:13:16.640
But you don't want the owner's burden of
walking upstairs to look for the file.

01:13:16.640 --> 01:13:19.900
You'd like to sit on your
butt and do the search of the

01:13:20.010 --> 01:13:21.810
other machines in the house.

01:13:21.960 --> 01:13:24.800
And in Leopard,
we are encouraging couch potatoes.

01:13:24.800 --> 01:13:26.090
We are providing that.

01:13:26.120 --> 01:13:30.080
So you can sit with
Spotlight on the couch,

01:13:30.110 --> 01:13:33.550
do this search with Spotlight of all
the other machines in your house.

01:13:33.660 --> 01:13:35.120
It'll find it.

01:13:35.240 --> 01:13:38.430
And then using personal file sharing,
you can open it up,

01:13:38.430 --> 01:13:39.980
never leaving your butt.

01:13:40.050 --> 01:13:43.360
So that's our feature,
searching other machines.

01:13:43.380 --> 01:13:45.770
Next, quick look.

01:13:46.650 --> 01:13:48.630
Quick look does a few
things for us in Leopard.

01:13:48.640 --> 01:13:53.640
When you look in icon view in the finder,
you find a bunch of generic icons.

01:13:53.640 --> 01:13:57.670
The icon tells you what
type of file it is,

01:13:57.670 --> 01:13:59.580
but tells you nothing about the contents.

01:13:59.640 --> 01:14:02.790
We actually have a feature
called show icon previews,

01:14:02.790 --> 01:14:06.510
and that will turn a few of
those icons into rich previews.

01:14:06.670 --> 01:14:11.500
The quick look APIs in Leopard allow
you to write a plug-in to support

01:14:11.510 --> 01:14:14.570
rich icon previews for everything.

01:14:14.640 --> 01:14:16.620
So please write one of these.

01:14:16.640 --> 01:14:18.240
for your file types.

01:14:21.880 --> 01:14:24.080
Now we took it a step
beyond this as well.

01:14:24.750 --> 01:14:27.950
When you're in Spotlight,
you can also use Quick Look to show a

01:14:27.970 --> 01:14:30.050
quick preview of the entire document.

01:14:30.060 --> 01:14:33.240
So you can quickly see,
is that the photo I'm looking for?

01:14:33.240 --> 01:14:36.180
It works for other things like movies,
so you can quickly look

01:14:36.180 --> 01:14:37.400
at a quick time movie.

01:14:37.400 --> 01:14:39.340
You can even look at presentations.

01:14:39.340 --> 01:14:43.080
So you can pull up, quickly look,
see if that's the right presentation,

01:14:43.080 --> 01:14:44.130
and then open it.

01:14:45.000 --> 01:14:49.140
It works both for Spotlight
and it works in the Finder.

01:14:49.140 --> 01:14:51.240
So if you're in the Finder,
you can quickly get a preview.

01:14:51.240 --> 01:14:54.050
But most importantly,
this is the way you can get

01:14:54.130 --> 01:14:55.920
previews in Time Machine.

01:14:55.920 --> 01:14:59.910
So again, if you have a document type,
write one of these plug-ins so we

01:14:59.910 --> 01:15:04.290
can look and see your document when
going through time with Time Machine.

01:15:04.300 --> 01:15:05.960
That is Quick Look.

01:15:06.020 --> 01:15:07.170
Thank you.

01:15:13.610 --> 01:15:18.320
So another thing we've done for
Spotlight is added Spotlight to Help.

01:15:18.370 --> 01:15:21.060
When you look at Spotlight,
one of the really good things about

01:15:21.150 --> 01:15:23.540
it is there's this menu right there.

01:15:23.800 --> 01:15:27.320
You can type into a search field
and quickly see your results.

01:15:27.370 --> 01:15:32.420
And we've decided to do that exact same
thing for the Help system in Leopard.

01:15:32.510 --> 01:15:36.090
So let's say I'm in text edit
working on some document.

01:15:37.840 --> 01:15:45.780
And I want to set what the default
font size is of a new document.

01:15:45.800 --> 01:15:49.460
I can go up, click on the Help menu,
and there's a search field.

01:15:49.580 --> 01:15:51.300
Zoom that in.

01:15:52.840 --> 01:15:56.030
type of search in there and it shows
you the help topics right there.

01:15:56.080 --> 01:16:01.700
You can choose one, it pops open,
help you right to the right spot.

01:16:01.950 --> 01:16:04.660
But you know,
once we did this we realized

01:16:04.700 --> 01:16:08.790
we can spotlight search more
than just the help contents,

01:16:09.110 --> 01:16:11.870
but we can spotlight
index part of your UI,

01:16:11.870 --> 01:16:14.460
your menus and other parts of your app.

01:16:14.700 --> 01:16:17.720
So let me go ahead and show you that now.

01:16:20.000 --> 01:16:20.590
So here we are.

01:16:20.600 --> 01:16:22.700
Let me bring up a Pages document.

01:16:22.730 --> 01:16:27.280
And I have a delicious
cookie in the document,

01:16:27.280 --> 01:16:28.780
which I'd like to center.

01:16:28.800 --> 01:16:32.830
And I don't remember how
to center items in Pages.

01:16:32.930 --> 01:16:37.040
So I can click on the Help menu,
just type Center, and boom,

01:16:37.120 --> 01:16:39.340
here's Aligning Objects.

01:16:39.360 --> 01:16:43.020
It's a really quick way to find exactly
the help topic you're looking for.

01:16:43.050 --> 01:16:46.620
But better than that, I can actually

01:16:47.880 --> 01:16:50.960
Arrow through these menu items,
we pop up the menu,

01:16:50.960 --> 01:16:54.950
even if it's a submenu,
telling you exactly the item you want.

01:16:55.020 --> 01:16:57.330
I find a line object center,
I hit return, boom,

01:16:57.440 --> 01:16:58.650
the cookie's centered.

01:17:08.120 --> 01:17:10.940
This is especially useful
with pro applications that

01:17:10.940 --> 01:17:12.600
have lots and lots of menus.

01:17:12.670 --> 01:17:14.800
So this is an unchanged Photoshop.

01:17:14.810 --> 01:17:18.680
I go up here, and I want to change the
contrast of this image.

01:17:18.720 --> 01:17:20.220
Type contrast.

01:17:20.230 --> 01:17:20.670
Boom.

01:17:20.960 --> 01:17:21.760
Go through here.

01:17:21.900 --> 01:17:22.400
Yep.

01:17:22.400 --> 01:17:22.930
Here we turn.

01:17:23.010 --> 01:17:24.720
Brings up the panel.

01:17:24.790 --> 01:17:26.840
Change my contrast.

01:17:26.840 --> 01:17:28.000
Much better.

01:17:28.010 --> 01:17:28.500
Done.

01:17:28.500 --> 01:17:30.240
Just like that.

01:17:37.200 --> 01:17:38.090
So that's Spotlight.

01:17:38.110 --> 01:17:40.060
We're doing a lot with
Spotlight in Leopard.

01:17:40.060 --> 01:17:43.550
Once you have the contents,
let's preserve it.

01:17:43.660 --> 01:17:45.240
That's what Time Machine is all about.

01:17:45.240 --> 01:17:49.810
As you heard this morning,
Time Machine is absolutely the best

01:17:50.140 --> 01:17:52.880
way to automatically backup your Mac.

01:17:52.950 --> 01:17:56.370
If you change a file,
we automatically backup the file.

01:17:56.960 --> 01:17:58.430
We backup everything.

01:17:58.430 --> 01:17:59.970
We backup all the files.

01:17:59.970 --> 01:18:04.930
We backup your photos, your music,
everything, applications, the entire OS.

01:18:05.040 --> 01:18:07.360
We allow you to restore everything.

01:18:07.360 --> 01:18:10.760
So if you lose your hard drive,
someone even steals your

01:18:10.760 --> 01:18:14.190
machine or the hard drive dies,
you can buy a new hard drive,

01:18:14.230 --> 01:18:16.600
replace it in there,
and be exactly where you were

01:18:16.600 --> 01:18:18.190
before that hard drive died.

01:18:19.710 --> 01:18:21.890
You can restore a la carte,
so you can go and restore a

01:18:22.110 --> 01:18:24.740
single file if you'd like.

01:18:24.850 --> 01:18:27.810
You can back up to a
hard drive or a server.

01:18:27.930 --> 01:18:30.940
And of course,
it allows you to go back in time.

01:18:31.030 --> 01:18:32.980
So I've had a lot of
questions since this morning.

01:18:32.980 --> 01:18:35.360
How the heck do we go back in time?

01:18:35.550 --> 01:18:39.880
So let me go ahead and show
you how time and space work.

01:18:45.080 --> 01:18:52.400
We start with the entire file tree,
the entire file hierarchy of your volume.

01:18:52.470 --> 01:18:58.720
And conceptually, as changes are made,
we make a complete backup of that

01:18:58.720 --> 01:19:02.540
entire file tree for all the changes.

01:19:02.540 --> 01:19:04.040
Conceptually this is what we do.

01:19:04.040 --> 01:19:07.190
We don't actually copy every
file every few minutes,

01:19:07.400 --> 01:19:13.790
but conceptually we have complete file
tree hierarchies for every snapshot.

01:19:14.070 --> 01:19:17.680
These snapshots are all read-only,
so you don't accidentally delete it.

01:19:17.730 --> 01:19:23.160
And in fact, they all just use journaled
HFS+. So we haven't created a

01:19:23.160 --> 01:19:24.740
whole new file system format.

01:19:24.790 --> 01:19:28.500
We use the standard one that
we already use and invest in.

01:19:28.750 --> 01:19:30.270
And in fact,
you can look at these snapshots

01:19:30.360 --> 01:19:33.090
all the way back to Jaguar.

01:19:33.140 --> 01:19:35.020
Of course,
Leopard has a really nice UI on it,

01:19:35.210 --> 01:19:38.510
but it's a standard file system.

01:19:38.750 --> 01:19:43.200
So for each of these snapshots,
the way it works is like when

01:19:43.200 --> 01:19:47.670
the finder wants to show today,
we point the finder at the entire file

01:19:47.670 --> 01:19:50.080
system hierarchy as it stands today.

01:19:50.100 --> 01:19:52.460
So it shows you exactly
what you have today.

01:19:52.460 --> 01:19:55.220
When we take the finder
back in time one day,

01:19:55.220 --> 01:20:00.140
we just point it to the root of the tree
of the file system as it stood yesterday.

01:20:00.140 --> 01:20:03.440
Because we have an entire file
system tree as it stood yesterday.

01:20:03.440 --> 01:20:04.920
So it shows the files there.

01:20:05.290 --> 01:20:07.580
Now,
that file is an image that I imported two

01:20:07.580 --> 01:20:09.880
days ago and hadn't rotated two days ago.

01:20:09.880 --> 01:20:12.890
So when I go back two days,
the finder shows it not yet

01:20:13.520 --> 01:20:16.720
rotated because it's just
looking at that file system.

01:20:16.720 --> 01:20:17.900
It's not doing anything magic.

01:20:17.900 --> 01:20:21.540
We just point it at the entire file
system as it stood two days ago.

01:20:21.540 --> 01:20:24.520
Now, this works with more
than just the finder.

01:20:24.520 --> 01:20:25.370
It works with your apps.

01:20:25.520 --> 01:20:27.940
It also works with things
like the address book.

01:20:27.940 --> 01:20:31.230
So the way this works with the
address book is the address

01:20:31.230 --> 01:20:35.220
book points exactly at its own
database within this file system.

01:20:35.380 --> 01:20:38.600
So when the address book is
asked to go back to yesterday,

01:20:38.600 --> 01:20:42.070
when I think I hadn't
entered Sonia's address,

01:20:43.720 --> 01:20:46.900
The address disappears from the card
because the address book is merely

01:20:46.900 --> 01:20:51.750
showing us its database that it knows how
to read exactly as it stood yesterday.

01:20:51.760 --> 01:20:55.140
And if we go back two days
before that card even existed,

01:20:55.140 --> 01:20:57.180
again, it doesn't appear in the
address book because it's

01:20:57.180 --> 01:20:58.400
just looking at its database.

01:20:58.400 --> 01:21:02.810
So the app doesn't need to know about
how we do snapshots or anything else.

01:21:02.880 --> 01:21:07.850
It just needs to know about how it
reads its own database or its own files,

01:21:07.850 --> 01:21:12.940
and we point it exactly to a
snapshot of that as it stood in time.

01:21:13.600 --> 01:21:17.390
Now here's the way we
actually do the snapshots.

01:21:17.860 --> 01:21:22.480
We start with the entire file system
and the first backup is complete.

01:21:22.510 --> 01:21:24.360
The first backup to the
hard drive of the server,

01:21:24.420 --> 01:21:25.910
we copy every single file over.

01:21:26.020 --> 01:21:28.880
So now you have a complete snapshot.

01:21:28.880 --> 01:21:31.830
We have a low priority daemon,
backup daemon,

01:21:31.830 --> 01:21:34.060
which is listening for changes.

01:21:34.060 --> 01:21:36.540
When a change happens,
like this file here rotates,

01:21:36.540 --> 01:21:37.500
an event goes out.

01:21:37.640 --> 01:21:42.200
It's called an FS event and it's a new
file system notification in Leopard.

01:21:42.200 --> 01:21:44.500
Our daemon listens to these changes.

01:21:44.500 --> 01:21:48.340
Now every once in a while,
and right now it's about every hour,

01:21:48.340 --> 01:21:53.570
the daemon will coalesce all the changes
that have happened and make a snapshot.

01:21:54.860 --> 01:21:58.230
It takes everything which hasn't
changed at all and it creates

01:21:58.300 --> 01:22:00.900
a series of hard links to it,
which takes virtually

01:22:00.900 --> 01:22:02.100
no space whatsoever.

01:22:02.230 --> 01:22:04.050
In fact,
we have even tricks on top of the

01:22:04.050 --> 01:22:07.800
normal hard links to make it so
it takes hardly any space at all.

01:22:07.840 --> 01:22:12.670
And then for the file that has changed,
that gets copied over to the backup.

01:22:12.800 --> 01:22:16.900
So now you add a file again, an hour,
you know, a few minutes later,

01:22:16.900 --> 01:22:18.200
an hour goes by.

01:22:18.230 --> 01:22:23.710
We go ahead and copy that file
into a new backup where all

01:22:23.780 --> 01:22:26.790
the rest of that backup tree is

01:22:27.420 --> 01:22:30.300
is just a series of hard
links taking no space.

01:22:30.330 --> 01:22:33.780
Now once a day, we coalesce all of
those backups into one,

01:22:33.780 --> 01:22:37.360
and so you have a snapshot
per day going back in time.

01:22:37.430 --> 01:22:39.520
So that's the way it works.

01:22:40.990 --> 01:22:44.880
So one way we're saving space
here is by using hard links.

01:22:45.040 --> 01:22:48.600
Another way we save space is
by just not backing up things

01:22:48.730 --> 01:22:50.620
that don't need to be backed up.

01:22:50.670 --> 01:22:52.350
For instance--

01:22:52.590 --> 01:22:56.950
If we're in Safari browsing the web,
this is what our file system looks like.

01:22:56.960 --> 01:22:59.580
We have a cache for the
current page you're on.

01:22:59.580 --> 01:23:01.120
Actually,
we have a cache for a number of pages.

01:23:01.120 --> 01:23:04.010
If you're in Google, you do a search,
you go to another page,

01:23:04.080 --> 01:23:06.200
we have another cache page there.

01:23:06.200 --> 01:23:08.760
You download a file,
it goes to your desktop,

01:23:08.760 --> 01:23:10.150
we have a file for that.

01:23:10.160 --> 01:23:15.250
So instead of just taking
and backing up all of this,

01:23:15.300 --> 01:23:18.970
there's no reason for us to back up
any of these cache files over here.

01:23:19.340 --> 01:23:22.510
And so we have ways,
there's an API for you to

01:23:22.510 --> 01:23:26.930
mark things as cache files or
as not-to-be-backed-up files,

01:23:26.940 --> 01:23:29.960
and then we won't back them up,
saving a lot of space.

01:23:30.000 --> 01:23:33.180
So there's really two
ways for you to do this.

01:23:33.290 --> 01:23:37.030
One is to use the API and mark
files not to be backed up.

01:23:37.140 --> 01:23:39.770
The other is to put files
into standard locations.

01:23:39.820 --> 01:23:42.510
So if it's a temporary file,
put it in the slash temp.

01:23:42.560 --> 01:23:45.620
If it's a cache file, we actually have a
standard cache location.

01:23:45.620 --> 01:23:48.010
So please put it into
the standard location.

01:23:48.100 --> 01:23:49.280
If you get only one.

01:23:49.380 --> 01:23:51.960
So if you get only one thing out of this
part of the talk about Time Machine,

01:23:51.960 --> 01:23:55.390
mark your files that don't
need to be backed up as such,

01:23:55.400 --> 01:23:59.130
which will enable backup devices to
store farther and farther back in time.

01:23:59.140 --> 01:24:02.830
There's another type of file that you
should mark as not-to-be-backed-up.

01:24:02.900 --> 01:24:06.620
And those are, if you have an index file,
it's not a cache,

01:24:06.700 --> 01:24:09.150
it's not a temporary file,
but it's an index file that

01:24:09.460 --> 01:24:13.350
can be regenerated by the
other data files that you have.

01:24:13.420 --> 01:24:15.500
Mark that as well, not-to-be-backed-up.

01:24:15.670 --> 01:24:18.100
Because if we went back in time,
you could just regenerate it instead.

01:24:19.210 --> 01:24:19.460
All right.

01:24:19.520 --> 01:24:22.000
That is Time Machine.

01:24:22.000 --> 01:24:25.680
We think it's absolutely the
best way to preserve your data,

01:24:25.680 --> 01:24:28.250
to go back in time, and grab it back.

01:24:28.340 --> 01:24:31.830
And we think in Leopard,
with all the great content

01:24:31.830 --> 01:24:34.810
we have on our machines,
we have really good solutions for

01:24:34.980 --> 01:24:38.970
both finding that content and for
preserving that content on these

01:24:38.970 --> 01:24:40.840
increasingly large hard drives.

01:24:40.880 --> 01:24:44.140
For the next section,
I'd like to turn it back to Bertrand.

01:24:53.300 --> 01:24:56.840
So we've talked about lots of
different parts of a computer.

01:24:56.840 --> 01:24:59.990
Now let's talk about entire computers.

01:25:00.230 --> 01:25:03.500
Let's talk about the server.

01:25:04.150 --> 01:25:07.940
Our servers find their way
in a lot of different places.

01:25:07.940 --> 01:25:12.450
They are present in some
of the top supercomputers.

01:25:12.450 --> 01:25:17.380
You find them in small department
servers or small enterprises.

01:25:17.380 --> 01:25:23.860
You find them on the campus of higher
ed or in some elementary schools.

01:25:23.920 --> 01:25:33.420
To span this really broad use of servers,
we need to make our server easy to use,

01:25:33.810 --> 01:25:37.820
powerful, and we need to provide a
rich collection of services.

01:25:37.920 --> 01:25:41.880
So let me go in a turn on
each of those three aspects.

01:25:41.910 --> 01:25:43.920
Ease of use, of course, right?

01:25:43.920 --> 01:25:47.920
And we've made the Leopard
server even easier to use.

01:25:47.920 --> 01:25:52.920
We're adding a number of applications and
polishing the applications that we have.

01:25:52.920 --> 01:25:53.460
So we're adding a number of
applications and polishing

01:25:53.500 --> 01:25:53.910
the applications that we have.

01:25:54.050 --> 01:25:57.730
So two I want to mention is one is a
server assistant that right off the

01:25:57.730 --> 01:26:01.920
bat will ask a few questions on how
you want your server to be set up.

01:26:01.940 --> 01:26:05.920
And it will set up your server
just based on those few questions.

01:26:05.920 --> 01:26:10.030
It will also set up the network so
that when you bring in a new machine,

01:26:10.050 --> 01:26:13.820
automatically your machine will
participate into the network.

01:26:13.920 --> 01:26:19.430
We also have a new server preferences
that's very similar to the system

01:26:19.430 --> 01:26:22.820
preferences that you find on the client.

01:26:22.940 --> 01:26:25.950
So the big difference is that
it sets up the settings for a

01:26:25.950 --> 01:26:27.920
whole bunch of machines at once.

01:26:29.050 --> 01:26:33.110
Now, in terms of the power, of course,
the power derives from Unix.

01:26:33.300 --> 01:26:34.740
Unix powers the internet.

01:26:34.740 --> 01:26:39.500
It powers most of the servers
that you find on the internet.

01:26:39.570 --> 01:26:43.900
And all the benefits that we talked
about for the client are present,

01:26:43.900 --> 01:26:46.820
obviously, on the server because we
are using the same kernel.

01:26:46.970 --> 01:26:49.280
So you have 64-bit processes.

01:26:49.380 --> 01:26:51.180
You have SMP processes.

01:26:51.250 --> 01:26:55.790
And we will recompile all the
server services in 64-bit mode

01:26:56.130 --> 01:27:00.900
as well as tune them for SMP in
the Leopard Server product.

01:27:00.990 --> 01:27:05.980
Now, another important aspect of
Unix is that it's open source.

01:27:05.990 --> 01:27:09.270
Everything we do at the
Unix layer is open source.

01:27:09.320 --> 01:27:12.440
And by the way,
we'll be posting the sources of our

01:27:12.550 --> 01:27:16.550
kernel both for PowerPC and for Intel.

01:27:21.200 --> 01:27:26.020
Now, at the same time,
OpenShorts is kind of a two-way

01:27:26.020 --> 01:27:30.480
thing with the community,
and we are selecting the best

01:27:30.680 --> 01:27:33.200
packages that are available,
whether it's commands, libraries,

01:27:33.200 --> 01:27:36.300
services, whatever,
and adding them to the server.

01:27:36.300 --> 01:27:38.540
We have a couple hundred
of those services.

01:27:38.540 --> 01:27:42.320
Now, with those kind of bricks,
we make high-level services,

01:27:42.320 --> 01:27:45.890
which brings me to my third point,
which is a rich collection

01:27:45.890 --> 01:27:47.560
of high-level services.

01:27:48.140 --> 01:27:51.040
We have a pretty good
collection in Tiger.

01:27:51.040 --> 01:27:53.910
All the basic high-level
services are covered,

01:27:53.910 --> 01:27:56.100
but we're adding more for Leopard.

01:27:56.100 --> 01:28:02.060
We're adding a calendar server that,
of course, matches iCal.

01:28:06.300 --> 01:28:11.800
It's based on the CalDAF protocol,
all industry standard protocols.

01:28:11.930 --> 01:28:14.900
We're adding a server that
corresponds to Time Machine,

01:28:14.900 --> 01:28:16.680
a backup server.

01:28:16.770 --> 01:28:18.840
We're adding, of course,
the Spotlight server that

01:28:18.920 --> 01:28:20.540
Scott just mentioned.

01:28:20.660 --> 01:28:24.210
We're adding a number of
collaboration servers to do wikis,

01:28:24.390 --> 01:28:26.800
blogs, to produce podcasts.

01:28:26.830 --> 01:28:29.010
And we are bundling Ruby on Rails.

01:28:29.190 --> 01:28:32.920
Ruby is a very trending language.

01:28:35.290 --> 01:28:40.900
So the way we conceive of the server is
that it complements nicely the client.

01:28:40.970 --> 01:28:44.260
Now we don't do that by any
kind of monopolistic tie-in.

01:28:44.260 --> 01:28:50.920
We do that by just using standards,
just open standards, industry standards.

01:28:50.990 --> 01:28:54.550
So this is the basic
strategy for the server.

01:28:54.660 --> 01:28:59.100
This will be talked, of course,
a lot more in the session after this.

01:28:59.100 --> 01:29:05.480
It's about ease of use, about power,
and about a rich collection of services.

01:29:05.530 --> 01:29:08.640
All this you will find in Leopard Server.

01:29:08.700 --> 01:29:12.470
And of course, Leopard Server runs great
on the latest machines that

01:29:12.570 --> 01:29:17.820
we've announced this morning,
whether it's a Mac Pro or the new XServe.

01:29:19.120 --> 01:29:25.920
So this concludes the little promenade
we've had through hardware and software

01:29:26.130 --> 01:29:28.040
and the integration of the two.

01:29:28.110 --> 01:29:32.640
Now, why do we do integration
of hardware and software?

01:29:32.640 --> 01:29:35.400
And of course,
it's to bring the ultimate user

01:29:35.400 --> 01:29:38.150
experience to our collective users.

01:29:38.260 --> 01:29:40.920
But it has another important aspect.

01:29:40.980 --> 01:29:46.760
It lets us create an ideal development
platform for you guys to build upon.

01:29:46.860 --> 01:29:47.160
Why?

01:29:47.160 --> 01:29:50.520
Because by integrating
together hardware and software,

01:29:50.520 --> 01:29:53.590
we can bring technologies
to market faster.

01:29:53.710 --> 01:29:58.440
We also insulate you from all
the details of the hardware.

01:29:58.440 --> 01:30:01.640
So for example, you don't have to learn
how to program a GPU.

01:30:01.640 --> 01:30:03.120
And it's tricky.

01:30:03.120 --> 01:30:05.160
There's a lot of tricky stuff there.

01:30:05.310 --> 01:30:08.560
And we protect you from
all that with low-level

01:30:08.560 --> 01:30:12.440
frameworks and even higher-level
frameworks like Core Animation.

01:30:12.460 --> 01:30:16.610
We also provide a dependable baseline,
both software and the hardware.

01:30:16.720 --> 01:30:19.750
So you can count on having
a camera on most Macs,

01:30:19.750 --> 01:30:23.420
and you can have innovative
applications that use that.

01:30:23.560 --> 01:30:28.880
So we believe that Leopard is the
ideal platform for innovation.

01:30:28.880 --> 01:30:31.120
This is a theme that we've
had in previous years.

01:30:31.250 --> 01:30:34.500
This is a part of our mission,
and that doesn't change.

01:30:34.550 --> 01:30:39.280
We want to create this great
platform on which you can develop

01:30:39.300 --> 01:30:42.070
great applications like these ones.

01:30:43.150 --> 01:30:46.240
Now, one final thought.

01:30:46.310 --> 01:30:50.700
Over the years, what makes a great
application has changed.

01:30:50.760 --> 01:30:56.170
It used to be that all you needed is this
idea of doing something that was useful,

01:30:56.170 --> 01:30:57.740
that hadn't been done before.

01:30:57.910 --> 01:31:00.760
It was all based on function.

01:31:01.170 --> 01:31:04.300
And with the advent of the Macintosh,
of course, things changed.

01:31:04.400 --> 01:31:06.930
Now you had to think in
terms of ease of use.

01:31:07.180 --> 01:31:09.660
It was no longer sufficient
to have a useful application.

01:31:09.660 --> 01:31:11.740
It had to be easy to use.

01:31:12.160 --> 01:31:17.540
You had to think in terms of
making it fun for the end users

01:31:17.740 --> 01:31:20.290
to interact with the application.

01:31:20.660 --> 01:31:23.250
I think what has happened over
the last few years is that

01:31:23.370 --> 01:31:26.240
we've entered into a new stage.

01:31:26.290 --> 01:31:30.640
Now you must provide a wow factor.

01:31:30.710 --> 01:31:32.840
You must amaze your users.

01:31:32.910 --> 01:31:36.800
And I think you'll agree that this
is something we've done with backup.

01:31:36.910 --> 01:31:38.240
I think this is really important.

01:31:38.390 --> 01:31:40.090
I think this is the future.

01:31:40.420 --> 01:31:44.800
And I look forward to lots of
your innovative applications.

01:31:44.910 --> 01:31:46.390
Thank you.
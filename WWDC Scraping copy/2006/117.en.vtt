WEBVTT

00:00:10.580 --> 00:00:12.340
Good morning, everyone.

00:00:12.390 --> 00:00:15.980
I want to welcome you this
morning to 64-bit In-Depth,

00:00:15.990 --> 00:00:18.850
where we're going to try and answer
some of the questions we deferred

00:00:18.980 --> 00:00:20.470
from yesterday's presentation.

00:00:20.500 --> 00:00:25.490
There is a variety of 64-bit content
in other sessions through the week,

00:00:25.490 --> 00:00:28.290
so I'll try and point
out to those as well.

00:00:28.500 --> 00:00:31.500
As the voice of God said,
I'm Matthew Formica.

00:00:31.500 --> 00:00:34.500
I'm the 64-bit software
evangelist at Apple.

00:00:34.500 --> 00:00:40.500
So feel free to email me through
the week and post this week with

00:00:40.620 --> 00:00:42.810
any 64-bit questions you may have,
and I'll try and get

00:00:42.810 --> 00:00:44.500
those answered for you.

00:00:46.380 --> 00:00:48.290
So, why are we here?

00:00:48.300 --> 00:00:53.060
We're here because we completed
our transition to Intel hardware

00:00:53.060 --> 00:00:57.180
this week with the announcement of
the Mac Pro 64-bit Intel hardware.

00:00:57.300 --> 00:01:03.450
And we are transitioning in Leopard
to provide a full 64-bit API stack

00:01:03.450 --> 00:01:06.300
to you in the operating system.

00:01:06.300 --> 00:01:09.300
So we want to show you
how to use all of that.

00:01:09.410 --> 00:01:12.210
And as you saw yesterday
in the 64-bit overview,

00:01:12.630 --> 00:01:17.300
64-bit as an architecture is really
just another part of going universal.

00:01:17.300 --> 00:01:20.210
It's another architecture that
gets built into your binary,

00:01:20.430 --> 00:01:23.160
similar to going to Intel.

00:01:23.690 --> 00:01:28.950
And in Leopard, we have, unlike Tiger,
we have just about the whole

00:01:28.950 --> 00:01:32.100
API stack available to you for 64-bit.

00:01:32.100 --> 00:01:36.910
And we'll talk about today
some of the exceptions to that.

00:01:37.120 --> 00:01:38.690
And what does this mean to you?

00:01:38.700 --> 00:01:42.400
Well, you should start thinking
about migrating to 64-bit.

00:01:42.400 --> 00:01:45.250
For some of you who have
very performance-critical

00:01:45.310 --> 00:01:49.070
applications or memory space needs,
now will be the right

00:01:49.070 --> 00:01:50.750
time to move to 64-bit.

00:01:50.860 --> 00:01:55.460
For others, it might be a little
longer transition time.

00:01:56.920 --> 00:01:59.040
So, what are you going to learn today?

00:01:59.090 --> 00:02:03.760
I'm going to walk you through the various
API changes for 64-bit and Leopard

00:02:03.790 --> 00:02:06.890
to help you understand what's there,
what's not there,

00:02:06.890 --> 00:02:09.880
what are good replacement
APIs for things.

00:02:09.880 --> 00:02:14.390
And then I'll hand off to
Eric Albert to talk about some of

00:02:14.440 --> 00:02:18.890
the other things that you might need
to be aware of when moving to 64-bit,

00:02:18.890 --> 00:02:23.870
including how to handle tiger and
leopard differences and understanding

00:02:23.880 --> 00:02:26.780
the actual 64-bit Intel architecture.

00:02:26.800 --> 00:02:26.950
Thank you.

00:02:29.970 --> 00:02:35.000
So, speaking of APIs changing,
why do our APIs need changing?

00:02:35.020 --> 00:02:38.180
Well, the first reason is just
a fallout of being 64-bit.

00:02:38.330 --> 00:02:43.340
We are an LP64 64-bit model,
which means longs, pointers,

00:02:43.340 --> 00:02:44.800
and size T change size.

00:02:44.800 --> 00:02:48.410
So, some of the fundamental data
types are changing size,

00:02:48.410 --> 00:02:50.950
and thus our APIs need to adapt to that.

00:02:51.490 --> 00:02:55.780
The 64-bit also means
applications can access more data.

00:02:55.870 --> 00:02:59.610
So we need to change some of our
APIs to make sure that they can actually

00:02:59.610 --> 00:03:03.300
reference those larger amounts of data.

00:03:04.810 --> 00:03:07.960
And we want to do this in a way
that doesn't break compatibility

00:03:08.510 --> 00:03:10.660
for existing 32-bit applications.

00:03:10.760 --> 00:03:15.300
And so there are certain data types,
certain file formats on

00:03:15.390 --> 00:03:19.760
disk that by statement or by
convention are fixed in size,

00:03:19.760 --> 00:03:25.620
and we need to make sure that those
stay the same size for 64-bit.

00:03:26.550 --> 00:03:30.290
And finally,
we need to make some changes through

00:03:30.360 --> 00:03:34.580
our APIs because there's no mixed mode,
which means that your entire

00:03:34.580 --> 00:03:37.780
process must be 32-bit or 64-bit.

00:03:37.860 --> 00:03:39.900
And if you want to build
a 64-bit application,

00:03:39.900 --> 00:03:43.010
everything you link against
must also be 64-bit.

00:03:43.150 --> 00:03:46.350
And so there is no piecemeal solution.

00:03:46.360 --> 00:03:49.730
The entire stack is going to go 64-bit.

00:03:51.020 --> 00:03:55.900
We have a few principles that we
applied as we were changing the APIs.

00:03:55.900 --> 00:03:58.190
One of them was consistency,
where we had to change

00:03:58.190 --> 00:04:00.000
things in one framework.

00:04:00.140 --> 00:04:03.260
We looked at making a similar
change in another framework

00:04:03.260 --> 00:04:05.290
that might do something similar.

00:04:05.710 --> 00:04:09.900
Secondly, we wanted good impedance match,
which is our way of saying we want

00:04:09.900 --> 00:04:13.330
you to be able to take the results
of one routine and easily pass them

00:04:13.330 --> 00:04:17.500
off to another without having to
do a lot of conversions in between.

00:04:17.820 --> 00:04:20.760
And finally,
going to 64-bit is a good chance

00:04:20.850 --> 00:04:25.400
for us to clean up our APIs and
help you modernize your application.

00:04:25.400 --> 00:04:29.000
We don't have the same binary
compatibility restraints,

00:04:29.020 --> 00:04:35.140
and so we can clear away some of the old
cruft that's in the Mac OS X API set.

00:04:38.910 --> 00:04:42.230
This is something I want to emphasize
right here as we get started.

00:04:42.360 --> 00:04:45.970
I'm going to be spending a lot of time
talking about the things that don't

00:04:45.970 --> 00:04:49.350
work or work slightly differently,
but they're really just a small

00:04:49.350 --> 00:04:52.950
subset of the thousands of APIs that
make up Carbon and Cocoa and the

00:04:52.950 --> 00:04:54.840
other frameworks on the system.

00:04:54.960 --> 00:04:56.750
Most APIs just work.

00:04:57.060 --> 00:05:02.560
The transition is mostly about
those edge cases in the APIs and,

00:05:02.560 --> 00:05:08.360
of course, 64-bit goof-ups like
truncating your pointers.

00:05:09.680 --> 00:05:13.040
So we're going to walk through the
different frameworks on the system.

00:05:13.040 --> 00:05:16.380
Let's start with API changes for Cocoa.

00:05:17.400 --> 00:05:20.020
And if we start actually at
the very bottom of Cocoa,

00:05:20.020 --> 00:05:23.970
which is the Objective-C language,
if you were at the Objective-C 2

00:05:23.970 --> 00:05:27.280
sessions yesterday,
you heard that for 64-bit,

00:05:27.280 --> 00:05:29.420
the runtime has been rewritten.

00:05:29.520 --> 00:05:34.010
Certain low-level data
structures are now opaque,

00:05:34.010 --> 00:05:37.790
and we have accessors to get
at what you previously just

00:05:37.850 --> 00:05:40.380
got to by accessing structures.

00:05:40.460 --> 00:05:43.920
And we have some new features that
are going to be coming to 64-bit

00:05:44.160 --> 00:05:47.120
Objective-C applications only.

00:05:50.320 --> 00:05:53.530
Moving up to the basic
data types in Cocoa,

00:05:53.580 --> 00:05:59.200
nearly all ints have been replaced
with NSInteger or NSUInteger.

00:05:59.290 --> 00:06:02.940
And these are data types,
type defs that can now

00:06:03.300 --> 00:06:07.800
change to be long for 64-bit.

00:06:07.920 --> 00:06:09.500
That way we aren't artificially hampered.

00:06:09.500 --> 00:06:15.410
You can see the basic type def that we
use in the system headers to handle this.

00:06:17.250 --> 00:06:22.060
Secondly, enumerations are not
predictably unsigned int.

00:06:22.220 --> 00:06:27.170
The compiler actually looks at the
values in the enumeration and makes a

00:06:27.230 --> 00:06:29.040
call as to what size things should be.

00:06:29.040 --> 00:06:33.930
And that wasn't good enough for us,
and so we have now declared some

00:06:34.060 --> 00:06:38.750
of the enumerations as NSInteger,
NSUInteger to make sure that

00:06:38.750 --> 00:06:41.510
the base type is 64-bit capable.

00:06:45.420 --> 00:06:50.120
And thirdly, a change that was mentioned
yesterday in the 64-bit overview,

00:06:50.220 --> 00:06:54.440
all graphics-related floating
point quantities are now doubles.

00:06:54.540 --> 00:06:58.730
CGFloat has grown in size,
and this was motivated by the

00:06:58.730 --> 00:07:02.750
opportunity that moving to 64-bit
provided to make some changes that will

00:07:02.760 --> 00:07:06.990
prepare us for the future when greater
precision is going to be needed.

00:07:07.270 --> 00:07:10.450
I should mention that this
change permeates through

00:07:10.720 --> 00:07:13.040
Carbon graphics calls as well.

00:07:15.180 --> 00:07:19.380
There's a few classes that did
not make the cut to 64-bit.

00:07:19.380 --> 00:07:22.840
The first couple are
NSMovieView and NSMovie.

00:07:23.030 --> 00:07:24.890
And this should be no surprise.

00:07:25.000 --> 00:07:30.690
QtKit is a great Cocoa API for
accessing QuickTime functionality.

00:07:30.740 --> 00:07:35.470
And so the NSMovieView and NSMovie
classes have been on their way out,

00:07:35.470 --> 00:07:37.300
actually, for a while.

00:07:37.620 --> 00:07:43.010
Secondly, NS Quickdraw view is not
available to 64-bit applications,

00:07:43.040 --> 00:07:46.250
and that's because Quickdraw
itself is not available,

00:07:46.260 --> 00:07:49.490
and I'm going to go into that in a
lot more detail in a few minutes.

00:07:49.800 --> 00:07:54.400
Instead, you'll want to use the
Cocoa Drawing system or go right

00:07:54.480 --> 00:07:57.010
to the Quartz APIs directly.

00:08:01.050 --> 00:08:04.900
NSMenuView is probably a class
that not a lot of you used,

00:08:05.220 --> 00:08:08.640
which is good because
it's not there for 64-bit.

00:08:08.670 --> 00:08:13.550
Instead, if you do need to do custom
view or custom drawing support

00:08:13.640 --> 00:08:19.160
of menus or in your menus,
you can use the NSMenuItem class.

00:08:19.410 --> 00:08:22.620
And I want to emphasize a
point that Ali made yesterday,

00:08:22.620 --> 00:08:25.990
which is don't use unkeyed archiving.

00:08:26.270 --> 00:08:29.900
You really want to use the
keyed archiving system.

00:08:29.900 --> 00:08:34.270
Hopefully you've already ripped out
that old code from your application.

00:08:37.150 --> 00:08:40.940
There's a script to help your
conversion if you are a 64-bit,

00:08:40.970 --> 00:08:44.100
if you are a Cocoa application
wanting to move to 64-bit.

00:08:44.100 --> 00:08:45.320
It's in developer extras.

00:08:45.390 --> 00:08:46.700
It's a top script.

00:08:46.770 --> 00:08:48.290
It automates some of the work.

00:08:48.300 --> 00:08:52.040
It puts little comments and flags
things in your code to help you

00:08:52.050 --> 00:08:55.830
find the things that need to change.

00:08:55.890 --> 00:08:58.050
If you look at our documentation,
it gives you all the details

00:08:58.050 --> 00:09:01.100
for how to actually run the
script against your code.

00:09:01.100 --> 00:09:03.230
And then after you run it,
you run file merge to

00:09:03.230 --> 00:09:06.540
see what it actually did,
to make sure that the changes it made

00:09:06.540 --> 00:09:08.980
are what you actually want to happen.

00:09:08.980 --> 00:09:12.340
The script will warn of a
variety of conversion problems.

00:09:12.340 --> 00:09:16.400
Some of them are strictly
required by 64-bit.

00:09:16.400 --> 00:09:22.460
Others are changes that are suggested to
help your APIs and your data structures

00:09:22.470 --> 00:09:25.150
be able to handle larger amounts of data.

00:09:29.090 --> 00:09:32.420
And that's pretty much the
summary of changes for Cocoa.

00:09:32.530 --> 00:09:34.510
It's pretty straightforward.

00:09:34.610 --> 00:09:36.990
There's new runtime
changes to Objective-C,

00:09:37.060 --> 00:09:38.540
a few key types change.

00:09:38.820 --> 00:09:41.510
There's this great script
to help you convert.

00:09:41.560 --> 00:09:45.110
And the script is going to help you see
that you really want to be end-to-end

00:09:45.110 --> 00:09:47.120
64-bit compatible in your application.

00:09:47.170 --> 00:09:51.790
Just because your application
builds using PPC64 or

00:09:51.790 --> 00:09:55.730
x86-64 as your architecture,
that does not mean that

00:09:55.740 --> 00:09:56.680
you're actually done.

00:09:56.680 --> 00:09:59.990
You want to make sure that you
can handle 64-bits worth of

00:10:00.040 --> 00:10:02.980
data and do it efficiently.

00:10:05.750 --> 00:10:08.690
Changes for Carbon are
a little more extensive.

00:10:08.720 --> 00:10:11.070
Let's go through those now.

00:10:12.800 --> 00:10:18.370
The first change we made was to
make SN32 and UN32 actually be

00:10:18.500 --> 00:10:23.260
fixed to stay 32-bit in 64-bit.

00:10:23.310 --> 00:10:27.190
They were actually defined such they
would have become 64-bit values.

00:10:27.330 --> 00:10:31.230
Core Foundation has also had
several types redefined so that

00:10:31.280 --> 00:10:35.830
they grow in size for 64-bit,
the basic CF index type

00:10:35.830 --> 00:10:37.950
as well as a few others.

00:10:40.270 --> 00:10:43.510
There are now new standard types
for consistent representation

00:10:43.590 --> 00:10:46.010
of user-specified data.

00:10:46.020 --> 00:10:50.020
And these keep their old
definition for 32-bit applications,

00:10:50.040 --> 00:10:52.490
so your code doesn't have
to change if you're 32-bit,

00:10:52.490 --> 00:10:54.940
but they become void stars for 64-bit.

00:10:56.400 --> 00:10:59.850
And types that represent
offsets in the memory,

00:10:59.860 --> 00:11:05.160
like byte count and byte offset,
are now longs for 64-bit applications

00:11:05.160 --> 00:11:09.710
so that they can actually
reference all areas of memory.

00:11:12.250 --> 00:11:15.430
Let's talk about a few pitfalls with
some of these common data types.

00:11:15.540 --> 00:11:19.830
You really want to try and adopt these
standard types throughout your code base,

00:11:19.850 --> 00:11:26.080
not just when interfacing
with the Carbon APIs.

00:11:26.290 --> 00:11:31.500
One common problem is casting a pointer
to an SN32 that worked in 32-bit.

00:11:31.500 --> 00:11:35.220
Of course, that's going to truncate
things in 64-bit.

00:11:35.930 --> 00:11:40.980
Secondly, don't assume that a CF index
is the same size as an S32.

00:11:41.290 --> 00:11:47.440
Here's an example of a call that
would not be correct for 64-bit.

00:11:48.630 --> 00:11:53.320
And thirdly, on the flip side,
don't assume that all parameters scale

00:11:53.320 --> 00:11:57.840
to 64-bits in 64-bit applications.

00:11:57.840 --> 00:12:00.250
The collection manager, for example,
some of its parameters like

00:12:00.330 --> 00:12:04.690
item size don't actually
grow to be 64-bits in size.

00:12:04.690 --> 00:12:10.190
And if you assume they do,
you'll get a different set of crashes.

00:12:12.530 --> 00:12:15.710
Pascal strings,
they've been around for a long

00:12:15.710 --> 00:12:19.150
time since the very beginning,
but we've made a concerted effort

00:12:19.450 --> 00:12:26.390
for our 64-bit applications to
actually remove them from the headers.

00:12:26.400 --> 00:12:29.390
So wherever there were routines
that took a Pascal string,

00:12:29.400 --> 00:12:34.730
there should now be replacements
that take a C string.

00:12:35.200 --> 00:12:38.940
This doesn't mean that the compiler
doesn't support Pascal strings.

00:12:38.940 --> 00:12:41.260
It still will,
so you don't have to instantly

00:12:41.260 --> 00:12:43.090
change all your own code.

00:12:43.100 --> 00:12:48.090
But this is just a steady migration
path that we've been on for some time.

00:12:50.040 --> 00:12:53.180
Moving up the Carbon stack
to the file manager,

00:12:53.210 --> 00:12:56.900
the FS spec data type
is finally going away.

00:12:56.900 --> 00:12:59.990
And this type has had drawbacks
that we all know well.

00:13:00.120 --> 00:13:04.760
It can only handle
31-character file names.

00:13:04.760 --> 00:13:09.370
And so FS refs are what you
should be using for all of

00:13:09.380 --> 00:13:13.140
your 64-bit file manager needs.

00:13:13.140 --> 00:13:18.360
There are a few places in the file
manager APIs where an FS spec is still

00:13:18.390 --> 00:13:20.720
needed just to be kind of passed in.

00:13:20.810 --> 00:13:22.590
You can just pass null there now.

00:13:22.630 --> 00:13:25.410
It doesn't really use it for anything.

00:13:25.640 --> 00:13:29.160
But in general,
wherever you need a real object there,

00:13:29.160 --> 00:13:31.640
you should be using FSRef.

00:13:35.330 --> 00:13:39.960
A few other low-level managers that
we should talk about some changes for.

00:13:39.960 --> 00:13:42.680
The memory manager has had a few changes.

00:13:42.680 --> 00:13:44.180
There are routines
that are not available:

00:13:44.180 --> 00:13:47.300
block move, block data, and block zero.

00:13:47.480 --> 00:13:53.980
Instead, you should use the standard
memmove or B0 calls.

00:13:54.740 --> 00:13:58.020
And believe it or not,
the resource manager

00:13:58.020 --> 00:14:01.410
is moving on to 64-bit.

00:14:01.410 --> 00:14:06.660
This is despite the fact that RezEdit
hasn't been revved since 1994.

00:14:06.660 --> 00:14:08.810
There are a few new types
and some things going away.

00:14:09.140 --> 00:14:11.700
The standard icon formats
are not available.

00:14:11.700 --> 00:14:15.880
So no more color icons,
no more icon suites.

00:14:16.180 --> 00:14:19.940
Instead,
you'll want to use icon refs or go right

00:14:19.940 --> 00:14:23.200
to core graphics and use CG image refs.

00:14:25.260 --> 00:14:29.620
64-bit Quickdraw is not available.

00:14:29.640 --> 00:14:32.100
There is no 64-bit Quickdraw.

00:14:32.130 --> 00:14:36.040
And Quickdraw has made a lot of
migrations through the years.

00:14:36.180 --> 00:14:39.480
This is what it looked
like in the early days.

00:14:39.510 --> 00:14:44.100
And we've revved it over
time to support color,

00:14:44.130 --> 00:14:45.680
amongst other things.

00:14:45.680 --> 00:14:49.320
But there's really a limit to how
far we could take the Quickdraw

00:14:49.440 --> 00:14:51.490
APIs and underlying implementation.

00:14:51.650 --> 00:14:55.910
And so on Mac OS X today,
we have a situation where

00:14:55.920 --> 00:14:59.050
displays have gotten bigger,
transparency is used more,

00:14:59.230 --> 00:15:01.640
and the technologies that
are available on Mac OS X,

00:15:01.640 --> 00:15:07.870
like Core Image, Quartz Composer,
and the new Core Animation framework,

00:15:07.910 --> 00:15:11.270
really don't speak the
language of Quickdraw.

00:15:11.290 --> 00:15:13.310
They speak the language of Quartz.

00:15:13.470 --> 00:15:17.370
And so now is a good time for you to
remove the last vestiges of Quickdraw

00:15:17.370 --> 00:15:19.870
from your code and move over to Quartz.

00:15:20.220 --> 00:15:23.270
Just for my own interest-- if
I could see a show of hands-- how

00:15:23.270 --> 00:15:27.210
many of you think you still have
Quickdraw calls in your code?

00:15:28.270 --> 00:15:30.590
Okay, that's a fair number of you.

00:15:30.850 --> 00:15:34.110
So hopefully we can help make
the transition pretty smooth.

00:15:34.310 --> 00:15:37.500
We've been talking about
this for a couple of years.

00:15:37.500 --> 00:15:40.980
In Tiger, of course,
the Quickdraw APIs were deprecated.

00:15:41.070 --> 00:15:45.060
For 32-bit applications in Leopard,
Quickdraw's still there,

00:15:45.140 --> 00:15:49.250
but to move to 64-bit,
you'll need to make this change.

00:15:50.090 --> 00:15:52.750
Let's talk about a few
more details of this.

00:15:52.760 --> 00:15:56.550
There's some good reasons why
we're getting rid of QuickDraw.

00:15:56.800 --> 00:15:58.120
It's not thread-safe.

00:15:58.270 --> 00:16:02.610
It's got a fixed resolution,
so it's not resolution

00:16:02.630 --> 00:16:04.990
independence ready.

00:16:05.040 --> 00:16:08.200
And internal data structures
of QuickDraw are limited to

00:16:08.200 --> 00:16:10.300
16-bit integer coordinates.

00:16:10.300 --> 00:16:15.100
So you've probably noticed that
when you get larger images,

00:16:15.200 --> 00:16:19.500
things start going wrong
above about 4K resolution.

00:16:21.270 --> 00:16:26.980
So instead you'll need to transition,
and here's a short list of steps

00:16:26.980 --> 00:16:29.840
that you'll need to take a look at,
one approach to moving to Quartz.

00:16:29.920 --> 00:16:35.410
You'll want to start separating out your
UI code from your basic business logic.

00:16:35.420 --> 00:16:41.340
A lot of old Carbon code intermingles
calls to the drawing routines with

00:16:41.340 --> 00:16:44.490
calls for event handling and doing
other things in their application.

00:16:44.500 --> 00:16:50.230
And because Quartz is a whole new
paradigm for how graphics are done,

00:16:50.230 --> 00:16:52.550
you're going to want to try
and separate out your logic to

00:16:52.550 --> 00:16:54.620
make the rewriting more easy.

00:16:54.980 --> 00:16:58.180
Secondly, if you haven't already done so,
you should move to HIView

00:16:58.180 --> 00:16:59.500
as a Carbon application.

00:16:59.500 --> 00:17:04.280
And this will give you the right
foundation to start building

00:17:04.350 --> 00:17:06.790
new graphics code on top of.

00:17:11.690 --> 00:17:16.810
You'll want to start rethinking how you
approach drawing things with Quartz.

00:17:16.930 --> 00:17:20.950
It's not a simple one-to-one
mapping between Quick Draw calls

00:17:21.280 --> 00:17:22.600
and equivalent Quartz calls.

00:17:22.600 --> 00:17:24.190
It's a different way of working.

00:17:24.200 --> 00:17:29.300
Instead of working with shapes and
pens and transfer modes and pics,

00:17:29.360 --> 00:17:35.830
you're going to be working with PDFs
and transparency paths and gradients.

00:17:35.970 --> 00:17:38.220
Hopefully, step four is profit.

00:17:41.070 --> 00:17:43.550
If we dive down into this
a little bit further,

00:17:43.550 --> 00:17:48.000
you'll see that Quickdraw was built
around a basic set of primitives.

00:17:48.060 --> 00:17:50.500
And all those primitives
were pixel-based,

00:17:50.560 --> 00:17:54.840
so right in the calls you were
specifying exactly how many

00:17:54.920 --> 00:17:56.910
pixels something should be.

00:17:56.980 --> 00:18:00.510
Quartz 2D instead is based around paths.

00:18:00.620 --> 00:18:05.520
So you describe a path which
builds up a set of geometry,

00:18:05.590 --> 00:18:08.370
and that can easily scale to
whatever the resolution of

00:18:08.430 --> 00:18:14.980
the final display actually is,
whether that be a monitor or a printer.

00:18:17.120 --> 00:18:19.890
Quartz, unlike Quickdraw,
doesn't have any built-in

00:18:19.940 --> 00:18:21.470
automatic redraw machinery.

00:18:21.500 --> 00:18:25.790
It doesn't know anything about
visible regions and so on.

00:18:25.980 --> 00:18:32.020
Instead, you should set up any clipping
manually for your CG context.

00:18:32.150 --> 00:18:36.450
And there are some routines that do some
similar things in terms of clipping to

00:18:36.510 --> 00:18:41.160
what you're familiar with with Quickdraw,
but the basic model is different.

00:18:43.320 --> 00:18:46.070
When it comes to moving pixels around,
this is a big one.

00:18:46.080 --> 00:18:52.400
There's no exact copy bits
functionality replacement in Quartz 2D.

00:18:52.800 --> 00:18:57.080
Quartz doesn't know anything
about bits or pixels,

00:18:57.080 --> 00:19:02.520
so ultimately it can't allow you
to do a copy bit sort of routine.

00:19:03.520 --> 00:19:07.780
And it uses the alpha channel, actually,
instead of needing a specific mask.

00:19:07.820 --> 00:19:12.950
So if you want to do the sort of thing
you've been doing with copy bits,

00:19:12.950 --> 00:19:16.190
you should look at using
CG Context Draw Image.

00:19:17.660 --> 00:19:20.920
We do have a bitmap context,
a bitmap backing store that is

00:19:21.080 --> 00:19:24.470
available for core graphics,
and then you can use CG Context

00:19:24.470 --> 00:19:26.000
Draw Image and friends.

00:19:26.080 --> 00:19:29.980
There are a variety of other
similar APIs that can be used to

00:19:30.020 --> 00:19:34.080
get similar functionality in Quartz.

00:19:45.820 --> 00:19:49.160
You should come by our labs
if you actually want some help

00:19:49.770 --> 00:19:55.490
converting from Quickdraw to Quartz,
and we can help you do that.

00:19:55.940 --> 00:19:59.890
Because Quickdraw is going away,
this has a lot of impact to other

00:19:59.890 --> 00:20:02.400
APIs that are part of Carbon,
because Quickdraw

00:20:02.420 --> 00:20:04.300
spreads its fingers wide.

00:20:04.310 --> 00:20:06.070
The Appearance Manager is going away.

00:20:06.210 --> 00:20:08.560
It was mostly Quickdraw-based.

00:20:08.630 --> 00:20:11.590
Instead,
you should use the HIFeam API that's

00:20:11.650 --> 00:20:13.480
been available for a while.

00:20:13.690 --> 00:20:16.600
Custom menu, window,
and control definitions

00:20:16.600 --> 00:20:18.150
are no longer available.

00:20:18.360 --> 00:20:21.810
You need to use custom HIVs instead.

00:20:22.520 --> 00:20:25.010
Most of the routines in the font
manager are not available because

00:20:25.010 --> 00:20:26.830
they're mostly Quickdraw based.

00:20:26.920 --> 00:20:31.560
So instead, you should use the
Core Text font API that we have.

00:20:31.560 --> 00:20:34.320
There are a few new routines we've
introduced in Leopard to help

00:20:34.320 --> 00:20:39.670
you convert from font manager
data structures over to Core Text.

00:20:39.760 --> 00:20:43.380
And as I mentioned earlier,
most of ICON services and

00:20:43.380 --> 00:20:46.330
ICON utilities is no longer available.

00:20:48.430 --> 00:20:52.430
Following in the same vein,
the drag manager has certain

00:20:52.430 --> 00:20:57.960
routines that are not available,
the ones that take quick draw structures.

00:20:57.960 --> 00:21:02.220
And when it comes to the event manager,
probably one of the biggest

00:21:02.220 --> 00:21:05.150
ones that goes away is getMouse.

00:21:05.160 --> 00:21:08.590
And I still remember some of my early
Macintosh programming being so excited

00:21:08.620 --> 00:21:12.910
to call getMouse and do basic drawing
on the screen just following the mouse.

00:21:13.020 --> 00:21:16.460
But getMouse returns coordinates
in the current graphics port.

00:21:16.640 --> 00:21:20.890
And for 64-bit applications,
there is no current graphics port.

00:21:21.040 --> 00:21:23.160
So instead, we've introduced a new
routine in Leopard,

00:21:23.160 --> 00:21:28.650
HIGetMousePosition, that will let you do
equivalent functionality.

00:21:31.620 --> 00:21:33.190
Let's talk about the Window Manager.

00:21:33.290 --> 00:21:37.430
It's another big one that has some
changes that affect other APIs.

00:21:37.670 --> 00:21:42.630
Carbon Windows must use compositing
mode to draw their content in 64-bit.

00:21:42.990 --> 00:21:45.920
And compositing mode is something
that's been around for a while,

00:21:45.920 --> 00:21:48.970
for a couple versions now in Mac OS X.

00:21:49.050 --> 00:21:51.330
Hopefully most of you have
converted to that already.

00:21:51.410 --> 00:21:54.920
How many of you are using composited
drawing mode for your Carbon apps?

00:21:54.920 --> 00:22:00.650
How many of you know you're not
using composited drawing mode?

00:22:01.840 --> 00:22:04.400
Okay,
for those of you who are not using it,

00:22:04.400 --> 00:22:06.080
now will be the time to convert over.

00:22:06.080 --> 00:22:11.370
You can do this in 32-bit as well,
so there's nothing special about it.

00:22:11.380 --> 00:22:13.820
And as I say,
it's been around for a while,

00:22:13.820 --> 00:22:16.820
so there's nothing new
to leopard with that.

00:22:16.820 --> 00:22:20.850
So you must pass kWindowCompositing
attribute to the create

00:22:20.890 --> 00:22:23.790
new window call in 64-bit,
or you will get an error

00:22:23.800 --> 00:22:24.840
back from create new window.

00:22:26.710 --> 00:22:34.590
So this brings up another
interesting issue.

00:22:34.590 --> 00:22:34.590
If you need a, you can no longer use

00:22:34.750 --> 00:22:41.100
Get CG Context from
Port or its ilk in 64-bit.

00:22:41.100 --> 00:22:45.150
If you need a CG context for a window,
you'll need to pay attention to the

00:22:45.150 --> 00:22:51.270
K event control draw Carbon event
and get the CG context through that.

00:22:52.150 --> 00:22:57.040
The Dialog Manager just transparently
switches over to compositing mode

00:22:57.040 --> 00:23:02.270
without any changes that you need
to make to your code in 64-bit.

00:23:05.680 --> 00:23:07.840
The Carbon Event Manager has
some changes.

00:23:07.910 --> 00:23:11.420
Non-compositing window
events are not available.

00:23:11.530 --> 00:23:14.880
Instead, you'll want to use events
that operate on HI objects,

00:23:14.990 --> 00:23:18.340
HI views, and CG contacts.

00:23:18.340 --> 00:23:21.860
And there are a few new standard
types that are introduced as well.

00:23:26.290 --> 00:23:29.020
We've got some other grab
bag Carbon API changes.

00:23:29.170 --> 00:23:33.900
Basically, any APIs that were deprecated
prior to 10.5 are not available

00:23:33.900 --> 00:23:36.910
to 64-bit applications on Leopard.

00:23:37.000 --> 00:23:39.200
And there are a few others
that are not available.

00:23:39.200 --> 00:23:41.410
The Code Fragment
Manager is not available.

00:23:41.590 --> 00:23:43.950
The Device Manager is not available.

00:23:43.980 --> 00:23:47.460
The Language Analysis Manager has
been replaced by the

00:23:47.460 --> 00:23:49.670
Natural Language Processing API.

00:23:49.930 --> 00:23:55.740
And the Desktop Manager functionality
can be obtained through a combination

00:23:55.740 --> 00:23:58.710
of icon services and launch services.

00:24:01.640 --> 00:24:03.420
The Sound Manager.

00:24:03.420 --> 00:24:06.740
Simple to use API,
not very powerful compared

00:24:06.740 --> 00:24:09.500
to today's core audio APIs.

00:24:09.500 --> 00:24:13.500
The Sound Manager has been on
its way out for a while as well.

00:24:13.520 --> 00:24:16.460
So it's not available
to 64-bit applications.

00:24:16.460 --> 00:24:19.390
You'll want to take a look at core audio.

00:24:19.500 --> 00:24:25.370
The List Manager is also biting
the dust for 64-bit applications.

00:24:25.520 --> 00:24:28.100
That should be no surprise to you.

00:24:28.100 --> 00:24:30.500
Use the data browser instead.

00:24:30.500 --> 00:24:35.500
And some of the really old school text
processing APIs are also not available.

00:24:35.500 --> 00:24:37.500
TextEdit and the Text Services Manager.

00:24:37.500 --> 00:24:43.500
Instead, for 64-bit applications,
you'll want to use an HI TextView or,

00:24:43.500 --> 00:24:47.140
new in Leopard,
we've got an HICocoView that allows you

00:24:47.140 --> 00:24:51.500
to embed CocoView inside a Carbon window.

00:24:51.500 --> 00:24:55.560
So you could put an NSTextView inside
an HICocoView and use that

00:24:55.560 --> 00:24:57.690
in your Carbon application.

00:24:59.460 --> 00:25:02.440
Hopefully you're getting the picture
here that most of the changes

00:25:02.510 --> 00:25:08.050
we're making are pretty obvious,
what you would have expected,

00:25:08.130 --> 00:25:11.760
and we're getting rid of APIs that
we've been encouraging you

00:25:11.760 --> 00:25:14.240
to move off of for some time.

00:25:16.480 --> 00:25:19.720
The Translation Manager has been
replaced by Translation Services in

00:25:19.720 --> 00:25:22.160
the HI Services framework.

00:25:22.160 --> 00:25:26.000
The Scrap Manager has been
replaced by the Pasteboard Manager.

00:25:26.000 --> 00:25:29.550
And if you need to enumerate displays,
you'll no longer be able

00:25:29.550 --> 00:25:32.800
to use the Display Manager,
including GD handles,

00:25:33.000 --> 00:25:36.230
but you'll want to use
CG Direct Display and the Quartz

00:25:36.310 --> 00:25:40.770
Display Services APIs to walk
through the list of what displays

00:25:40.770 --> 00:25:43.790
are actually connected to a machine.

00:25:46.900 --> 00:25:50.230
So in summary for Carbon,
you'll want to adopt the new

00:25:50.240 --> 00:25:53.640
standard Carbon types in your code,
which means you'll need to go through

00:25:53.640 --> 00:25:57.780
all of your old code to make sure
that not only are you interfacing

00:25:57.780 --> 00:26:01.730
correctly with our routines,
but you are actually able to handle

00:26:01.730 --> 00:26:03.510
large amounts of data in your code.

00:26:03.520 --> 00:26:07.020
You're not truncating
things along the way.

00:26:07.130 --> 00:26:10.620
You'll need to transition
from Quick Draw to Quartz.

00:26:10.680 --> 00:26:14.360
And thirdly, you'll need to use
compositing window mode.

00:26:14.610 --> 00:26:16.560
Hopefully most of you
are already doing that.

00:26:16.620 --> 00:26:19.360
And good replacement
APIs are generally available.

00:26:19.390 --> 00:26:23.250
We're getting rid of APIs that
we've deprecated for a while now,

00:26:23.250 --> 00:26:26.280
and we've got pretty
good replacements there.

00:26:28.920 --> 00:26:32.740
Carbon and Cocoa are two big buckets,
but there's kind of a other bucket

00:26:32.790 --> 00:26:35.790
that I also wanted to talk about,
which is a variety of other

00:26:35.800 --> 00:26:41.500
changes that you should be aware of
throughout the frameworks on Mac OS X.

00:26:42.580 --> 00:26:47.460
And the first one is a basic new
way in CFBundle to allow you to

00:26:47.540 --> 00:26:52.490
check the architectures that are
available for a given bundle.

00:26:52.590 --> 00:26:56.500
This allows you to replace the sample
code that we've had out for a while

00:26:56.500 --> 00:26:59.970
where you've got to actually kind
of munch through the Mako header

00:27:00.450 --> 00:27:04.100
for a given binary to figure out
what architectures are in there.

00:27:04.130 --> 00:27:07.770
So, nice new clean API to do that.

00:27:08.340 --> 00:27:12.260
Second of all, the message framework,
a little-known framework that allowed

00:27:12.260 --> 00:27:17.950
you to send emails through mail,
is not available to 64-bit applications.

00:27:18.100 --> 00:27:22.340
Its functionality can be
easily duplicated through basic

00:27:22.340 --> 00:27:24.510
Apple events sent to mail.

00:27:27.320 --> 00:27:31.170
Open Transport is not
available to 64-bit apps.

00:27:31.240 --> 00:27:33.240
How many of you are
relying on Open Transport?

00:27:33.240 --> 00:27:35.170
Hopefully not many.

00:27:35.460 --> 00:27:36.270
Just a couple of you.

00:27:36.510 --> 00:27:37.120
Good.

00:27:37.270 --> 00:27:41.640
CF Network is a good,
newer replacement API,

00:27:41.640 --> 00:27:46.020
and BSD Sockets are a great,
really old replacement API.

00:27:46.420 --> 00:27:49.740
AppleTalk is not available
to 64-bit applications.

00:27:49.870 --> 00:27:54.810
There are other good ways of doing what
it did that have been around for a while.

00:27:58.130 --> 00:28:01.890
When it comes to printing,
there's just a few notes on that.

00:28:02.000 --> 00:28:09.560
PDEs that are 32-bit PDEs,
they're CF plugin-based,

00:28:09.560 --> 00:28:12.400
will not load in 64-bit applications.

00:28:12.400 --> 00:28:14.800
They will not show up
in the print dialog.

00:28:14.800 --> 00:28:19.680
Instead,
there are new Cocoa-based PDE APIs that

00:28:19.680 --> 00:28:22.490
you should take a look at.

00:28:22.550 --> 00:28:26.380
You can check out the PDE plugin
interface dot h header to get

00:28:26.380 --> 00:28:28.780
more information on using those.

00:28:30.320 --> 00:28:32.900
And secondly,
the other bit of information you should

00:28:32.900 --> 00:28:37.300
know about is that if you want to get
information from the PPD in a 64-bit app,

00:28:37.390 --> 00:28:40.950
you'll need to use
CUPS instead of PPDlib.

00:28:45.250 --> 00:28:47.060
Let's talk about QuickTime.

00:28:47.170 --> 00:28:51.050
And this is going to be covered
in even more depth in one of the

00:28:51.150 --> 00:28:54.790
QuickTime sessions this afternoon
by the QuickTime engineering team,

00:28:54.800 --> 00:28:57.090
but I just wanted to give
you a little bit here.

00:28:57.180 --> 00:29:04.100
The QuickTime C APIs are not available
to 64-bit applications on Leopard.

00:29:04.100 --> 00:29:07.100
The code base is very old and crufty.

00:29:07.100 --> 00:29:10.080
It's a little bit like
QuickDraw in some ways.

00:29:10.180 --> 00:29:14.870
However, there are Carbon and
Cocoa ways of continuing to

00:29:14.870 --> 00:29:20.030
access QuickTime content and
QuickTime functionality for 64-bit apps.

00:29:20.190 --> 00:29:27.100
The biggest is QTKit, which is a new,
well, even not so new now,

00:29:27.100 --> 00:29:31.210
QuickTime Objective-C API that's modern,
powerful, and functional,

00:29:31.230 --> 00:29:35.330
and it's available to 64-bit
applications in Leopard.

00:29:35.660 --> 00:29:37.360
A couple implications of this.

00:29:37.390 --> 00:29:40.640
Since there's no QuickTime C APIs,
you can't get native

00:29:40.640 --> 00:29:44.200
QuickTime identifiers out of
QtKit if you're a 64-bit app.

00:29:44.200 --> 00:29:51.080
So you can't ask a Qt movie for its
QuickTime movie is the biggest example.

00:29:53.070 --> 00:29:57.900
A bug in the Leopard preview that you
have right now is you can't actually

00:29:57.900 --> 00:30:01.520
use a Qt movie view from a nib.

00:30:01.520 --> 00:30:03.190
That's actually just broken right now.

00:30:03.190 --> 00:30:06.340
But you can create one in code,
add it to your view,

00:30:06.340 --> 00:30:07.200
and that will work fine.

00:30:07.200 --> 00:30:11.300
This is something we'll fix pretty soon.

00:30:12.630 --> 00:30:17.020
And the new capture classes that we've
just introduced in Leopard are not

00:30:17.020 --> 00:30:20.300
yet available to 64-bit applications.

00:30:21.860 --> 00:30:27.570
One other bit of detail is that nav
create preview depends on QuickTime,

00:30:27.590 --> 00:30:31.700
so it's also not available
to 64-bit applications.

00:30:31.720 --> 00:30:35.220
There are a variety of new
QuickLook preview facilities

00:30:35.660 --> 00:30:39.330
that we've rolled out that are
going to be a part of Leopard.

00:30:42.700 --> 00:30:48.740
Java on Mac OS X Leopard is available to,
natively, for 64-bit Intel only.

00:30:48.760 --> 00:30:53.060
There is no PowerPC 64 Java.

00:30:53.170 --> 00:30:56.840
And that's simply because
we license the JVM from Sun,

00:30:56.850 --> 00:31:01.100
and they don't have a 64-bit
PowerPC implementation.

00:31:01.100 --> 00:31:03.770
Speaking of Java,
Cocoa Java is not available as

00:31:03.770 --> 00:31:06.530
well to 64-bit applications.

00:31:11.520 --> 00:31:14.680
If we dive real low level in
the system to the driver level,

00:31:14.680 --> 00:31:18.670
I have up here on the slide what
they told me to say about it,

00:31:18.710 --> 00:31:23.200
which is basically that if you
are a driver that wants to access

00:31:23.260 --> 00:31:26.400
more than 4 gigs of memory,
there are some changes

00:31:26.410 --> 00:31:27.860
you'll need to make.

00:31:27.860 --> 00:31:32.940
The kernel is staying 32 bit for Leopard.

00:31:32.980 --> 00:31:34.940
That should be of help to you.

00:31:34.940 --> 00:31:38.960
There's a session right after
this one that's going to be all

00:31:38.990 --> 00:31:43.170
about I/O Kit related changes
for 64 bit computing as well as

00:31:43.170 --> 00:31:48.940
there will be a discussion of some
Intel EFI related stuff in that session.

00:31:52.250 --> 00:31:56.220
Let me talk for just a minute or
two about the state of 64-bit in

00:31:56.220 --> 00:31:58.810
the Leopard preview that you have,
because we've talked to some

00:31:58.810 --> 00:32:03.060
degree about what we plan to
do for Leopard for 64-bit,

00:32:03.060 --> 00:32:07.940
but not everything's working in the
preview that you have available to you.

00:32:08.190 --> 00:32:11.610
In the preview that you have,
nearly all the frameworks are available,

00:32:11.610 --> 00:32:13.600
as I've described.

00:32:13.760 --> 00:32:16.140
Nearly all the developer
tools are also available.

00:32:16.170 --> 00:32:22.080
Xcode, Shark, Crash Reporter,
all of those have been 64-bit enabled.

00:32:23.580 --> 00:32:27.530
Basic language interpreters, however,
are still 32-bit on the system.

00:32:27.540 --> 00:32:30.900
That's something that we're
going to correct soon.

00:32:30.900 --> 00:32:36.630
And there's still some performance work,
some basic structural work

00:32:36.740 --> 00:32:39.830
that we do for 32-bit that we
haven't yet done for 64-bit.

00:32:39.940 --> 00:32:45.360
Prebinding at the system framework level
is not something that we've done yet.

00:32:45.360 --> 00:32:47.080
Of course,
you don't need to pay attention

00:32:47.110 --> 00:32:48.430
to that for applications.

00:32:48.560 --> 00:32:52.410
There's no system shared
region in 64-bit yet either.

00:32:55.830 --> 00:33:00.040
There are some frameworks and
APIs that are not yet available

00:33:00.100 --> 00:33:04.220
to 64-bit that we plan to make
available by the time Leopard GMs.

00:33:04.220 --> 00:33:06.840
Let me just go over some of those here.

00:33:06.840 --> 00:33:09.520
Of course,
scripting languages I've mentioned.

00:33:09.520 --> 00:33:12.880
Parts of DO are not
working in this preview,

00:33:13.270 --> 00:33:17.160
which means that spell checking and
sync services are also not working.

00:33:17.160 --> 00:33:21.840
Objective C2 garbage collection
in this preview is not enabled

00:33:21.840 --> 00:33:24.310
for 64-bit applications.

00:33:24.320 --> 00:33:27.420
That's something we're
going to change by GM.

00:33:27.420 --> 00:33:32.520
DVD playback is available only
to PowerPC 64-bit applications,

00:33:32.520 --> 00:33:34.460
not on Intel 64.

00:33:34.660 --> 00:33:38.160
And X11,
if I have my information correct,

00:33:38.380 --> 00:33:44.080
is available to PowerPC 64 applications,
but not Intel.

00:33:47.140 --> 00:33:48.460
There's a bug as well.

00:33:48.540 --> 00:33:51.760
If you are a sophisticated
C++ application,

00:33:51.760 --> 00:33:56.350
you use templates,
and you use the -f visibility inlines

00:33:56.480 --> 00:34:02.290
hidden flag to help reduce the amount
of symbols that are in your application

00:34:02.300 --> 00:34:05.990
and thus improve launch times,
you're going to get a linker error

00:34:06.390 --> 00:34:08.100
when trying to build for 64-bit.

00:34:08.100 --> 00:34:11.700
The error is code gen problem
can't use rel 32 to external

00:34:11.700 --> 00:34:13.950
symbol or message similar to that.

00:34:13.950 --> 00:34:16.980
If you get that, that's just a bug that
we're going to fix.

00:34:17.010 --> 00:34:21.100
The easy work around
is don't use that flag.

00:34:23.900 --> 00:34:25.340
And with that,
I'd like to turn things over to

00:34:25.340 --> 00:34:32.240
Eric Albert to talk about the 64-bit
architecture at the lower levels.

00:34:37.940 --> 00:34:38.450
Hey, there.

00:34:38.490 --> 00:34:42.730
So to go back to the slide that
Matt showed at the beginning,

00:34:42.770 --> 00:34:45.810
so he's covered now our
API changes for 64-bit.

00:34:45.820 --> 00:34:49.770
And I'm going to talk about how to
find your application's dependencies

00:34:49.820 --> 00:34:53.290
to make sure that everything that
you need is 64-bit before you

00:34:53.290 --> 00:34:54.940
actually move your own application.

00:34:54.940 --> 00:34:57.750
Because well, if the frameworks that
you need aren't there,

00:34:57.760 --> 00:35:00.540
then building your application in
64-bit won't work all that well,

00:35:00.540 --> 00:35:02.380
because you won't be able to run it.

00:35:02.380 --> 00:35:05.840
Then 64-bit in Leopard and Tiger,
which can sometimes be a little

00:35:05.840 --> 00:35:09.390
bit complicated to think about,
how the two operating systems interact,

00:35:09.390 --> 00:35:10.370
and I'll explain why.

00:35:10.610 --> 00:35:13.710
And finally, what's new in our latest
and greatest architecture,

00:35:13.710 --> 00:35:15.140
64-bit on Intel.

00:35:15.760 --> 00:35:18.830
So first, finding 64-bit dependencies.

00:35:18.980 --> 00:35:22.040
The reason why this is important
is that even though almost

00:35:22.040 --> 00:35:26.150
all of our system frameworks,
and nearly all the ones that

00:35:26.150 --> 00:35:31.230
we're going to support for
64-bit are built 64-bit today,

00:35:31.330 --> 00:35:34.290
there are obviously a lot of applications
out there that are dependent on

00:35:34.290 --> 00:35:36.230
third party libraries and frameworks.

00:35:36.390 --> 00:35:39.060
It's good to figure out which
ones of those you'll need

00:35:39.140 --> 00:35:42.360
before you do that transition,
much as you had to do for Intel.

00:35:42.450 --> 00:35:47.070
So the way to do that is to run
OTool-L to point that at the actual

00:35:47.070 --> 00:35:49.140
application binary that you have.

00:35:49.160 --> 00:35:53.550
So in this case, I picked Transmit,
which is a nifty FTP client

00:35:53.550 --> 00:35:56.720
from the folks at Panic.

00:35:56.720 --> 00:36:01.490
And you can see here that actually three
of the frameworks that Transmit pulls in,

00:36:01.580 --> 00:36:05.440
FTP Kit, Growl, and Neon,
are not Apple frameworks.

00:36:05.440 --> 00:36:08.890
So this means that in the
Leopard preview today,

00:36:08.900 --> 00:36:12.280
obviously these three frameworks, well,
they're not part of the operating system.

00:36:12.280 --> 00:36:15.230
So they aren't 64-bit today,
unless the Panic folks

00:36:15.270 --> 00:36:17.390
have worked really,
really hard over the past

00:36:17.390 --> 00:36:19.680
two days to port them.

00:36:19.680 --> 00:36:23.760
So those three would then have to move
to 64-bit before Transmit itself could

00:36:23.760 --> 00:36:25.910
actually link as a 64-bit application.

00:36:27.740 --> 00:36:33.010
Now, how do you actually check those
to see if they have 64-bit slices?

00:36:33.370 --> 00:36:35.830
You run the file command
from the command line.

00:36:35.840 --> 00:36:38.940
So here I've run it on core
foundation on the Leopard preview,

00:36:39.080 --> 00:36:41.140
and you see that it has
all four architectures.

00:36:41.140 --> 00:36:44.190
Of course,
if it only reports PPC and I3D6,

00:36:44.190 --> 00:36:47.180
then that framework isn't 64-bit yet.

00:36:48.970 --> 00:36:52.240
How about 32-bit versus
64-bit in Leopard and Tiger?

00:36:52.240 --> 00:36:54.600
And basically,
how to go about running the right

00:36:54.600 --> 00:36:56.360
application at the right time.

00:36:56.500 --> 00:37:00.730
This is a little bit tricky,
but I'll try to explain it.

00:37:01.240 --> 00:37:06.180
Mac OS X will choose to run the
64-bit slice of a binary when

00:37:06.180 --> 00:37:07.840
you're running on a 64-bit Mac.

00:37:07.900 --> 00:37:12.110
And so what we've always tried to
do in Mac OS X is to run the right

00:37:12.110 --> 00:37:14.400
application when the user goes
ahead and double-clicks something.

00:37:14.400 --> 00:37:19.470
This is why, for example, on Intel,
when we introduced the Intel systems,

00:37:19.470 --> 00:37:21.300
then when you built your
application universal,

00:37:21.300 --> 00:37:24.170
the user double-clicks it and
the Intel side launches because,

00:37:24.290 --> 00:37:26.060
of course, that's what you'd want.

00:37:26.100 --> 00:37:29.620
The idea here is if you've built
your application for 64-bit,

00:37:29.700 --> 00:37:32.740
that's because you probably actually
want folks to use the 64-bit side.

00:37:32.900 --> 00:37:36.420
And so we'll run that by default.

00:37:36.850 --> 00:37:42.640
But sometimes 32-bit is the right choice,
even for an application that

00:37:42.650 --> 00:37:45.250
has both 32- and 64-bit slices.

00:37:45.320 --> 00:37:49.840
So some examples of this are
32-bit plug-ins in browsers.

00:37:49.840 --> 00:37:53.280
So for example,
if Safari was 64-bit today,

00:37:53.320 --> 00:37:58.680
but say the Windows Media plug-in
was still 32-bit and you needed to

00:37:58.680 --> 00:38:02.690
view something in Windows Media,
then you'd want to be able to run that as

00:38:02.690 --> 00:38:06.940
a-- you'd want to be able to run Safari,
perhaps, as a 32-bit application.

00:38:06.970 --> 00:38:09.180
This applies to any
applications that have plug-ins,

00:38:09.250 --> 00:38:11.300
a variety of pro applications do.

00:38:11.330 --> 00:38:14.260
And also,
32-bit native libraries for Java, Perl,

00:38:14.300 --> 00:38:18.160
and other command line--
I don't want to call them

00:38:18.160 --> 00:38:25.820
interpreters because Java isn't,
but things like this that--

00:38:26.180 --> 00:38:30.230
You can't determine at launch
time whether the application,

00:38:30.240 --> 00:38:32.470
whether the libraries that
you're going to try to load

00:38:32.470 --> 00:38:34.900
later are 32-bit or 64-bit.

00:38:34.960 --> 00:38:38.380
If you have a Java application
with 32-bit JNI libraries,

00:38:38.460 --> 00:38:41.320
then when you run user bin Java,
we don't know that that's what

00:38:41.360 --> 00:38:42.690
you're going to try to load.

00:38:42.700 --> 00:38:49.010
So we'll have to provide some way for
you to run a 32-bit Java in that case.

00:38:50.100 --> 00:38:54.080
The way to do that is to
use the new POSIX Spawn API,

00:38:54.120 --> 00:38:55.760
which was introduced in Leopard.

00:38:55.770 --> 00:38:58.770
Unfortunately,
the flags that you need to pass

00:38:58.810 --> 00:39:02.630
to POSIX Spawn to get it to choose
between 32-bit and 64-bit are not

00:39:02.630 --> 00:39:04.630
currently in your Leopard preview.

00:39:04.690 --> 00:39:06.910
That will, of course,
be added before Leopard ships.

00:39:06.990 --> 00:39:10.820
So this will be the interface,
but you can't quite use it today.

00:39:10.840 --> 00:39:13.980
The way to do this today, then,
the workaround for you while you're

00:39:13.980 --> 00:39:19.380
doing development is to use lipo-thin to
remove the 64-bit slice of your binary.

00:39:19.420 --> 00:39:23.400
And yes, it's kind of inconvenient,
but we will make this better.

00:39:24.300 --> 00:40:06.600
[Transcript missing]

00:40:06.920 --> 00:40:11.760
So the answer to that is to build
the 64-bit side of your binary,

00:40:11.760 --> 00:40:16.400
so to build your PPC64 and x8664
architectures with a deployment

00:40:16.490 --> 00:40:19.470
target of Mac OS X 10.5.

00:40:19.540 --> 00:40:22.760
Now, unfortunately, today,
this doesn't actually have a

00:40:22.760 --> 00:40:28.440
material impact on what launches,
but before Leopard ships,

00:40:28.440 --> 00:40:29.600
then this will actually be fixed.

00:40:29.600 --> 00:40:32.700
And when you set this deployment target,
then the right thing will happen.

00:40:32.700 --> 00:40:36.880
By that, I mean that if you set a
deployment target of 10.5 for

00:40:36.880 --> 00:40:39.660
the 64-bit slice of your binary,
then when you launch that

00:40:39.740 --> 00:40:42.460
binary on a tiger system,
the 32-bit side will run,

00:40:42.460 --> 00:40:45.100
and when you launch that
binary on a Leopard system,

00:40:45.100 --> 00:40:46.790
the 64-bit side will run.

00:40:49.300 --> 00:43:14.300
[Transcript missing]

00:43:17.710 --> 00:43:20.850
So what do these changes
actually mean for running code

00:43:20.850 --> 00:43:22.240
and for the performance of code?

00:43:22.320 --> 00:43:25.740
Well, more registers, as I mentioned,
means that more things are possible,

00:43:25.740 --> 00:43:28.870
that we can do interesting things
with the calling convention and

00:43:28.870 --> 00:43:33.340
with code generation that just
simply couldn't be done for 32-bit.

00:43:33.420 --> 00:43:35.830
Again, the most noticeable one is
the better calling convention,

00:43:35.840 --> 00:43:39.090
the fact that we can actually
pass arguments and registers and

00:43:39.090 --> 00:43:42.560
do the right thing with passing
floating-point arguments to functions.

00:43:42.850 --> 00:43:46.500
So I'll talk a little bit more
about that in a minute or two.

00:43:46.640 --> 00:43:47.980
Faster compute-intensive code.

00:43:48.210 --> 00:43:50.160
When you have more registers available,
then you don't have to

00:43:50.160 --> 00:43:51.150
spill things onto the stack.

00:43:51.250 --> 00:43:52.490
You don't have to go out to memory.

00:43:52.650 --> 00:43:57.980
You can keep more data in registers
and manipulate more values faster.

00:43:58.430 --> 00:44:02.140
Faster access to external
functions and global variables.

00:44:02.140 --> 00:44:04.460
This comes about because we
have PC relative addressing,

00:44:04.460 --> 00:44:08.060
so we can actually reference
these things much more directly

00:44:08.060 --> 00:44:09.060
than we otherwise could.

00:44:09.060 --> 00:44:12.370
We don't have to go through
little funks in the code.

00:44:13.350 --> 00:44:17.100
and faster floating point code because,
actually, first of all,

00:44:17.100 --> 00:44:18.900
the better calling convention
helps out floating point,

00:44:18.900 --> 00:44:21.120
and secondly, again,
doubling the number of registers

00:44:21.200 --> 00:44:22.580
helps that out as well.

00:44:22.750 --> 00:44:26.790
So overall, you look at this and you say,
hey, that sounds pretty good.

00:44:26.800 --> 00:44:28.080
There's one caveat.

00:44:28.160 --> 00:44:31.360
Of course,
this is a shift from 32-bits to 64-bits,

00:44:31.360 --> 00:44:35.320
so larger longs and pointers means
that fewer items fit in the cache.

00:44:35.360 --> 00:44:39.100
It's not like your Mac Pro, say,
has an 8-megabyte L2 cache

00:44:39.150 --> 00:44:41.540
when you're dealing with 64-bit
code and a 32-megabyte one

00:44:41.540 --> 00:44:47.510
when dealing with 32-bit code.

00:44:47.990 --> 00:44:50.290
You get the same cache size
no matter what you're running,

00:44:50.300 --> 00:44:54.660
so you can fit more longs and
pointers in the cache when

00:44:54.660 --> 00:44:57.570
you're running a 32-bit code.

00:44:57.890 --> 00:45:02.400
But the change here that gives us
more registers and that changes the

00:45:02.440 --> 00:45:05.440
calling convention and so on and so
forth means that many applications

00:45:05.510 --> 00:45:10.210
will actually end up running
slightly faster on 64-bit Intel,

00:45:10.210 --> 00:45:13.200
regardless of whether they
need the larger address space.

00:45:13.210 --> 00:45:15.290
Now,
this isn't -- I have to be very clear

00:45:15.290 --> 00:45:18.930
here -- this is not a reason in and
of itself to go out and move all

00:45:18.930 --> 00:45:21.450
of your code to 64-bit right away.

00:45:21.530 --> 00:45:24.290
So as we mentioned at the
64-bit overview yesterday,

00:45:24.300 --> 00:45:27.240
when you run the first 64-bit
application in the system,

00:45:27.240 --> 00:45:30.120
that brings in a 64-bit framework stack,
so that has additional

00:45:30.120 --> 00:45:31.560
memory requirements.

00:45:31.770 --> 00:45:35.460
But the reason why I mention this
is that if you happen to have a

00:45:35.460 --> 00:45:39.780
compute-intensive application,
in particular folks in scientific

00:45:39.780 --> 00:45:41.960
computing or anyone who's just
really trying to use the computer

00:45:41.960 --> 00:45:41.960
to do the work that you're doing,
you're going to have to

00:45:41.960 --> 00:45:41.960
have a lot of memory.

00:45:41.960 --> 00:45:41.960
So if you happen to have a computer
that's really trying to use the computer

00:45:41.960 --> 00:45:41.960
to do the work that you're doing,
you're going to have to

00:45:41.960 --> 00:45:41.960
have a lot of memory.

00:45:41.960 --> 00:45:45.660
just really trying to eke every
last cycle out of the CPU,

00:45:45.890 --> 00:45:50.630
then 64-bit on Intel in particular is
something that you may want to look at.

00:45:50.970 --> 00:45:53.580
Now some applications actually
end up running a little bit slower

00:45:53.670 --> 00:45:56.840
with this because of that trade
off that if you have a lot of

00:45:56.910 --> 00:46:00.070
longs and pointers in your code,
then that may more than offset

00:46:00.140 --> 00:46:05.380
the performance boost that you
get from the register changes.

00:46:05.410 --> 00:46:06.970
But if you do have a
compute intensive app,

00:46:07.010 --> 00:46:09.070
then I encourage you to take
a look at this and try it.

00:46:09.160 --> 00:46:12.190
And if it's an application
where that additional,

00:46:12.190 --> 00:46:15.280
say, 10% or so may make a
significant difference,

00:46:15.280 --> 00:46:18.890
then great,
this may turn out really well for you.

00:46:21.200 --> 00:47:52.200
[Transcript missing]

00:47:52.890 --> 00:47:54.850
How does that calling
convention actually work?

00:47:55.080 --> 00:47:58.770
Well,
we decided that compatibility was good.

00:47:59.060 --> 00:48:02.420
And so our calling convention
is as much like Linux and other

00:48:02.420 --> 00:48:04.250
Unix-like platforms as possible.

00:48:04.310 --> 00:48:07.580
So this means that if you have
assembly code or developer tools

00:48:07.580 --> 00:48:11.820
or whatnot that were built for
Linux or FreeBSD for x86-64,

00:48:11.820 --> 00:48:16.650
then bringing them over to 64-bit
Intel and Mac OS X should actually

00:48:17.070 --> 00:48:19.260
be reasonably straightforward.

00:48:19.460 --> 00:48:23.130
So we pass six arguments,
six integer arguments and registers.

00:48:23.180 --> 00:48:27.280
We start with RDI and then RSI, RDX, RCX,
R8, and R9.

00:48:27.280 --> 00:48:29.200
After that, we spell onto the stack.

00:48:29.440 --> 00:48:33.460
Floating point arguments are
passed in XMM0 through XMM7.

00:48:33.610 --> 00:48:35.530
The return value comes back in RAX.

00:48:35.560 --> 00:48:37.520
That's a lot like 32-bit, at least.

00:48:37.550 --> 00:48:40.460
And what all of this adds up to is that,
at least conceptually,

00:48:40.460 --> 00:48:43.520
this is pretty similar to PowerPC,
where we're passing arguments and

00:48:43.520 --> 00:48:45.760
registers up to a certain number
and then spelling out the stack

00:48:45.830 --> 00:48:48.000
and returning values and registers.

00:48:48.030 --> 00:48:52.600
It's a lot more like PowerPC, certainly,
than 32-bit Intel was.

00:48:52.730 --> 00:48:58.780
Documentation for this calling
convention is up at x86-64.org.

00:48:58.800 --> 00:49:01.690
This is one of the great things about
being as much like Linux and other Unix

00:49:01.810 --> 00:49:05.040
as possible is that we can actually say,
you know what?

00:49:05.040 --> 00:49:09.260
The documentation that's out there,
that's been out there for a while now,

00:49:09.260 --> 00:49:11.190
works great for us.

00:49:13.320 --> 00:49:15.900
So I'll give you a quick example
of how this calling convention

00:49:15.900 --> 00:49:19.240
actually works and how you would
go about using it in debugging.

00:49:19.240 --> 00:49:23.320
So let's say that you wanted to
print out all of the file names

00:49:23.530 --> 00:49:26.930
that an application was opening
as it went about opening them.

00:49:27.030 --> 00:49:30.500
So you set a breakpoint on open,
and then you can set a breakpoint command

00:49:30.620 --> 00:49:35.570
that will just print out the first
argument and then continue and end,

00:49:35.680 --> 00:49:37.140
which means that when
you run your application,

00:49:37.140 --> 00:49:40.600
you'll just get this continuous stream
of all of the file names that get opened.

00:49:40.600 --> 00:49:42.600
So you can see, say,
where it's looking for preference

00:49:42.600 --> 00:49:44.940
files and things like that.

00:49:45.530 --> 00:49:48.290
Here's how you would have
done that for 32-bit Intel.

00:49:48.380 --> 00:49:52.820
Star, car star star, ESP plus four,
and you'd have to know that that's

00:49:52.930 --> 00:49:56.120
ESP because open is a frameless function,
and to do that you'd

00:49:56.140 --> 00:49:57.730
have to disassemble open.

00:49:57.900 --> 00:50:00.820
That's really not very much fun at all.

00:50:01.300 --> 00:50:04.460
Here's how you do it for 64-bit Intel.

00:50:04.570 --> 00:50:06.200
First argument's an RDI.

00:50:06.280 --> 00:50:07.810
Print RDI.

00:50:07.860 --> 00:50:08.740
Nice and simple.

00:50:08.790 --> 00:50:11.210
And when you run that,
you get all of the file names here

00:50:11.220 --> 00:50:14.120
from a 64-bit version of TextEdit.

00:50:15.330 --> 00:50:16.980
How about Objective-C?

00:50:16.990 --> 00:50:21.720
Now Objective-C, of course,
the first argument is self,

00:50:21.720 --> 00:50:23.390
and the second argument is the selector.

00:50:23.520 --> 00:50:27.780
So the first argument to a function is
actually the third argument that really

00:50:27.780 --> 00:50:29.910
gets passed in the calling convention.

00:50:29.920 --> 00:50:31.610
So here,
if we wanted to print out the title

00:50:31.610 --> 00:50:36.820
of every window as that was changed,
then we set a breakpoint

00:50:36.820 --> 00:50:38.880
on NSWindowSetTitle.

00:50:38.900 --> 00:50:41.120
And then what are we going
to hand over to print object?

00:50:41.190 --> 00:50:43.940
Well, for 32-bit on Intel, again,
this is really messy.

00:50:43.940 --> 00:50:48.420
You have to know that actually
NSWindowSetTitle does have a frame,

00:50:48.420 --> 00:50:52.290
and therefore you reference your
arguments off of EBP instead of ESP.

00:50:52.420 --> 00:50:54.610
And you have to dereference things.

00:50:54.800 --> 00:50:55.930
It's just kind of nasty.

00:50:56.080 --> 00:50:58.550
So 64-bit, it's a lot easier.

00:50:58.750 --> 00:50:59.810
It's the third argument.

00:50:59.870 --> 00:51:01.240
That's an RDX.

00:51:01.340 --> 00:51:03.920
Pass that straight to print object,
and so you can get all

00:51:03.920 --> 00:51:05.530
of your window titles.

00:51:07.910 --> 00:51:11.150
How does this compare to Windows?

00:51:11.150 --> 00:51:13.530
If you already have
64-bit code for Windows,

00:51:13.530 --> 00:51:15.800
then you'll find that a few
things are different here.

00:51:15.800 --> 00:51:20.800
And again, here, Mac OS X is a lot like
Linux and other Unixes,

00:51:21.170 --> 00:51:22.770
but Windows is just the odd one out.

00:51:23.280 --> 00:51:26.500
Microsoft went with the LLP64 data model.

00:51:26.500 --> 00:51:29.230
That means that long,
longs and pointers are 64-bit.

00:51:29.320 --> 00:51:32.040
For us, longs and pointers are 64-bit.

00:51:32.040 --> 00:51:36.430
What that means is that if you have
C code that you want to be cross-platform

00:51:36.550 --> 00:51:41.210
for 64-bit between Windows and Mac OS X,
then you may want to avoid the

00:51:41.210 --> 00:51:45.940
long type altogether and use ints
for your 32-bit values and long

00:51:45.940 --> 00:51:47.480
longs for your 64-bit values.

00:51:47.480 --> 00:51:49.440
And then that'll be
compatible back and forth.

00:51:49.630 --> 00:51:55.860
Or, of course, use explicitly sized
types like UN32T and N64T.

00:51:56.070 --> 00:51:58.820
How about passing arguments and
registers for the calling convention?

00:51:58.820 --> 00:52:01.240
We passed the first six
arguments and registers.

00:52:01.260 --> 00:52:03.950
They passed the first four
arguments and registers.

00:52:04.000 --> 00:52:07.950
And just to make that
much more interesting,

00:52:08.140 --> 00:52:12.290
their first four are our last four.

00:52:12.290 --> 00:52:17.000
So that makes porting assembly
code kind of difficult.

00:52:17.000 --> 00:52:20.390
Volatile registers,
all of the argument registers plus R10

00:52:20.390 --> 00:52:22.990
and R11 are volatile for both platforms.

00:52:23.000 --> 00:52:25.070
But again, since the argument
registers are different,

00:52:25.070 --> 00:52:26.900
that means that you have
different volatile registers.

00:52:27.000 --> 00:52:30.980
And volatile XMM registers,
all of them are volatile on Mac OS X.

00:52:30.990 --> 00:52:34.160
On Windows,
only XMM0 through XMM5 are volatile

00:52:34.160 --> 00:52:35.860
and the rest are preserved.

00:52:36.000 --> 00:52:39.000
So if you're bringing code over that
assumes that those will be preserved,

00:52:39.040 --> 00:52:40.980
then you'll have to
update that for Mac OS X.

00:52:41.000 --> 00:52:43.870
What all of this adds up to
is that for the most part,

00:52:44.040 --> 00:52:47.000
most 64-bit Intel assembly
code will be preserved.

00:52:47.000 --> 00:52:49.900
So it's going to be different
between Mac OS X and Windows.

00:52:50.000 --> 00:52:55.320
And that's unfortunate, but in this case,
Microsoft went one direction,

00:52:55.360 --> 00:52:57.000
the rest of the world went the other.

00:52:57.000 --> 00:53:00.680
So again, if you have Linux or
FreeBSD assembly code,

00:53:00.680 --> 00:53:04.000
then that should come
over reasonably easily.

00:53:04.000 --> 00:53:07.870
But if you have code from Windows,
you'll have to change it a bit.

00:53:10.280 --> 00:53:12.860
How about our memory
layout for 64-bit systems?

00:53:12.860 --> 00:53:15.030
Since we have gobs and
gobs and gobs of memory,

00:53:15.140 --> 00:53:16.770
what do we do with all of it?

00:53:16.890 --> 00:53:22.410
Well, 0 to 4 gigabytes is used for the
kernel and the 32-bit address space.

00:53:22.600 --> 00:53:27.510
Our kernel is still 32-bit in Leopard,
and so it has to sit down there.

00:53:27.630 --> 00:53:34.120
From 4 gigs to 128 terabytes are
64-bit applications and libraries.

00:53:34.240 --> 00:53:37.770
It's pretty unlikely that you'll
write an application that actually

00:53:37.770 --> 00:53:40.480
uses all of that right now.

00:53:40.490 --> 00:53:44.750
I mean, the Mac Pro can only fit
up to 16 gigabytes of RAM.

00:53:44.760 --> 00:53:47.120
So if you actually tried
to use 128 terabytes,

00:53:47.130 --> 00:53:49.330
you'd be paging for a long time.

00:53:49.590 --> 00:53:52.250
But you can try, if you'd like.

00:53:52.310 --> 00:53:54.930
Now,
from 128 terabytes to some very large

00:53:54.930 --> 00:53:58.930
number that I couldn't do the math for,
this is not addressable.

00:53:58.970 --> 00:54:00.400
This is a hole in the address space.

00:54:00.400 --> 00:54:04.060
This isn't some special feature of
Mac OS X where we just decide to stamp

00:54:04.060 --> 00:54:06.380
out the middle of the address space.

00:54:06.420 --> 00:54:10.850
Instead, this is due to the architecture
of Intel 64-bit chips right now.

00:54:11.120 --> 00:54:16.110
But you're probably not missing this,
because again, you really can't touch 128

00:54:16.110 --> 00:54:17.380
terabytes of pages today.

00:54:17.400 --> 00:54:21.400
So that hole itself wouldn't
help you all that much.

00:54:21.560 --> 00:54:25.200
And from that address and up,
what we actually refer to as

00:54:25.200 --> 00:54:27.840
the negative address space,
because it's easier to think

00:54:27.840 --> 00:54:31.780
about if you go backwards from 0,
that's reserved for future kernel usage.

00:54:31.780 --> 00:54:34.990
So you can't allocate
memory in that space today.

00:54:36.870 --> 00:54:40.020
I'd like to talk a bit about
that 0 to 4-gigabyte range.

00:54:40.070 --> 00:54:47.030
This is particularly interesting as you
migrate code from 32-bits to 64-bits,

00:54:47.030 --> 00:54:51.720
because as Matt mentioned and
as Ali mentioned yesterday,

00:54:51.750 --> 00:54:54.670
we see a lot of bugs in code
that migrates to 64-bits,

00:54:54.670 --> 00:54:55.990
where people are truncating pointers.

00:54:56.040 --> 00:54:57.940
And of course,
if your code is still running

00:54:57.950 --> 00:55:00.550
within the low 4 gigs,
then a truncated pointer will

00:55:00.550 --> 00:55:02.090
continue to work just fine.

00:55:02.170 --> 00:55:07.040
So to reach the 64-bit apprentice
level that Ali described yesterday,

00:55:07.040 --> 00:55:09.520
you want to make sure that your
application runs above 4 gigs,

00:55:09.520 --> 00:55:11.930
and so all of your pointers are up high.

00:55:12.150 --> 00:55:15.980
Now, the linker defaults to a
4-gigabyte page zero size when

00:55:15.980 --> 00:55:17.410
building for 10.5 or later.

00:55:17.500 --> 00:55:21.170
This means that it'll simply
carve out the low 4 gigabytes of

00:55:21.220 --> 00:55:25.160
your address space that isn't,
say, malloc-allocated memory.

00:55:25.160 --> 00:55:28.360
It's just mapped out of your space,
and none of your code will

00:55:28.450 --> 00:55:30.210
end up running in there.

00:55:30.690 --> 00:55:34.520
But if you're running
64-bit PowerPC code,

00:55:34.780 --> 00:55:38.600
there are a couple of ways to
get your PowerPC 64 application

00:55:38.600 --> 00:55:39.760
to load in the low 4 gigs.

00:55:39.760 --> 00:55:44.600
And one, which is actually on by default,
is to build with -m dynamic no-pick.

00:55:45.000 --> 00:55:48.160
This is good for performance reasons,
so it'll make your PPC 64

00:55:48.240 --> 00:55:49.760
code run a little bit faster.

00:55:49.900 --> 00:55:53.510
But when you turn this on,
your application will actually

00:55:53.510 --> 00:55:56.110
load in the low 2 gigs,
and the rest of that space up

00:55:56.110 --> 00:55:59.760
to 4 gigs will be blocked out,
so no shared libraries will load there.

00:55:59.760 --> 00:56:02.760
But your application,
if it's truncating pointers,

00:56:02.890 --> 00:56:04.760
will still be able to do that.

00:56:04.760 --> 00:56:07.740
So if you want to make sure
that you can get to that 64-bit

00:56:07.820 --> 00:56:10.760
apprentice level and that you
are not truncating your pointers,

00:56:10.760 --> 00:56:12.620
then you want to turn
off m dynamic no-pick,

00:56:12.660 --> 00:56:13.670
at least for testing.

00:56:13.790 --> 00:56:16.760
And once you're sure
that you're 64-bit clean,

00:56:16.760 --> 00:56:19.600
then you can turn that on and get the
performance boost back for PPC 64.

00:56:20.020 --> 00:56:23.120
Another way to do this is
to use a Mac OS X deployment

00:56:23.120 --> 00:56:25.760
target of 10.4 or earlier.

00:56:25.760 --> 00:56:28.920
And the third way is to
explicitly set the pay zero size,

00:56:28.920 --> 00:56:30.920
to say, "Really, trust me,
you don't want the 4 gig page zero.

00:56:30.920 --> 00:56:34.080
I just want, say, one page."

00:56:34.720 --> 00:56:36.760
This is somewhat different on Intel.

00:56:36.880 --> 00:56:40.230
The only way to get an Intel application
to load in the low 4 gigs is to

00:56:40.270 --> 00:56:42.000
explicitly set the page zero size.

00:56:42.000 --> 00:56:44.890
So regardless of your deployment target,
regardless of the value

00:56:44.890 --> 00:56:47.730
of Mdynamic no-pick,
your Intel application

00:56:47.800 --> 00:56:49.510
will load above 4 gigs.

00:56:49.660 --> 00:56:54.180
This means that if you move to PPC64
first and then move to 64-bit Intel,

00:56:54.260 --> 00:56:57.710
then you may not notice your
pointer truncation errors until

00:56:57.710 --> 00:56:59.430
you move to the Intel side.

00:56:59.600 --> 00:57:01.400
Now, why did we do it this way?

00:57:01.960 --> 00:57:07.340
First, 64-bitness, to really enforce,
to ensure that you don't have

00:57:07.470 --> 00:57:09.600
pointer truncation problems.

00:57:09.600 --> 00:57:11.600
But secondly, actually for performance.

00:57:11.600 --> 00:57:16.450
Due to the architecture of the virtual
memory system on the Intel systems,

00:57:16.490 --> 00:57:19.720
if we have your application
not overlap with the kernel,

00:57:19.720 --> 00:57:22.650
then kernel user space, and again,
the kernel is in the low 4 gigs,

00:57:22.760 --> 00:57:25.600
then kernel user space
transitions are that much faster.

00:57:25.600 --> 00:57:28.600
We can actually special case
applications that have a 4-gig page zero.

00:57:28.600 --> 00:57:31.600
And make all of your system
calls that much faster.

00:57:31.600 --> 00:57:35.600
So another thing that's
nice about 64-bit on Intel.

00:57:37.150 --> 00:57:41.150
So a summary about everything
about 64-bit In-Debt.

00:57:41.370 --> 00:57:44.220
API migration,
Matt talked an awful lot about this,

00:57:44.220 --> 00:57:45.580
and there's lots and lots to know.

00:57:45.750 --> 00:57:50.080
Basically, what this comes down to is
that we've modernized our APIs.

00:57:50.190 --> 00:57:53.370
The things that we've been telling
you for years are sort of the

00:57:53.380 --> 00:57:56.110
future direction of the platform,
are the things that are

00:57:56.110 --> 00:57:59.240
available for 64-bit,
and the things that we've been

00:57:59.240 --> 00:58:03.300
deprecating or trying to move away
from are generally not available.

00:58:03.300 --> 00:58:07.400
Again, the most important one there is to
migrate from Quick Draw over to Quartz.

00:58:07.560 --> 00:58:11.920
For 64-bit on Intel,
it's also a modernization,

00:58:11.920 --> 00:58:13.870
but in this case,
a modernization of the architecture

00:58:13.880 --> 00:58:16.210
rather than of the APIs.

00:58:16.530 --> 00:58:18.560
The quick summary is that it's simpler,
faster, and better.

00:58:18.560 --> 00:58:19.780
We love this architecture.

00:58:19.780 --> 00:58:23.720
It's going to be great
for us in the future,

00:58:23.740 --> 00:58:27.590
and we hope that your applications
can take advantage of it.

00:58:28.260 --> 00:58:30.660
We have three 64-bit
labs throughout the show.

00:58:30.660 --> 00:58:33.100
The first one starts at 2 o'clock today.

00:58:33.200 --> 00:58:34.980
They're all in Mac OS X Lab B.

00:58:35.310 --> 00:58:38.680
And I encourage you to bring your code
by and start the process of moving

00:58:38.680 --> 00:58:40.200
your application over to 64-bit.

00:58:40.200 --> 00:58:43.030
I think we have a bunch
of Mac pros there.

00:58:43.120 --> 00:58:44.770
And you can give it a shot.
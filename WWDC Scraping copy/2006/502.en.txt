---
Title:  Java on Mac OS X Overview
Year:   2006
Web:    https://nonstrict.eu/wwdcindex/wwdc2006/502/

[!] This transcript was generated using Whisper, it has known transcription errors.
---

Welcome everybody. Well, if even the voice of God can't botch my name, I really have to change it. I am Francois Jouaux. I'm the Java Technologies Engineering Manager and we have a fun-packed session this morning, so we'll start right along. The agenda we are going to cover today is the state of the art of Java on Mac OS X. Answer some common Java questions. talk about Java SE 6 which is fast coming, and finally cover IDE support on the platform.

What I would like you to do by the end of this session is to keep on attending the Java sessions. They are mostly bright and early at 9:00 AM in the morning, so why not take a little, put a little bit of Java in your morning routine so Cocoa can wait for later. Use new Java SE technologies on IDEs. And after leaving W3C, keep telling the world how strong the Java community is on Mac OS X.

So to keep you awake, I have this new button popping up here and there that will indicate that we have exciting features on almost every slide. Exciting new features on almost every slide. And I used to have a jingle, but I guess no sound. Who is it for? Let's have a show of hands here. We have students in this room.

A few researchers, scientists, seasoned Java developers, that makes the bulk of it. And we're all striving to build consumer products, whether you are all consumers and you're building either websites for consumers or shrink-wrapped Java applications. But the consumer is always in your mind. Why is Mac OS X the best Java platform?

We believe this is the most tightly integrated Java in any OS. We keep the Java lean and fit. Java on Mac OS X is very tight to the underlying OS, the core frameworks. And we like it this way, and that's what this session will be about. On the contrary, on Windows, I think you see where I'm getting there, Java is bloated and inconsistent.

You have to carry your Java version with you. If you want to shrink wrap an application, you have to instruct your customer to go and download the latest security fixes or the latest packages from Sun. Otherwise, your application will not work. We don't like this and we won't follow this model.

So as a summary, every consumer has the right version of Java in their OS. It's bundled, pre-installed, and continually updated through the automated software update system. Every developer also has integrated SDK tools that work with Java and excellent documentation at their fingertips. Other bundle extensions are JAI on Java 3D, Live Connect, and Web Start, which is fast becoming the best way to deploy applications on other platforms. And we support it as well on Mac OS X.

In the enterprise, I want you to check out the new Java server options that are coming with Leopard, and we'll talk more about them later. And for development and deployment, we include a set of very powerful tools, WebObjects, which is our own application server, Apache Tomcat, and JBoss. These are all pure Java project tools.

Ease of use and flexibility. Again, your system is pre-configured with a default Java, but it also has legacy versions of Java bundled. And through a preferences application, you can switch back and forth. You will never be able to override the developer's choice in the application, but for your applets and for your Java command line, you can do so. To paraphrase someone well known, this is Unix Java with taste. We make all the Java command line tools available at their correct Unix location.

and I forgot we have bundled IDEs and tools, Xcode, Shark, and new X-Ray and D-Trace from Sun. X-Ray from Apple, D-Trace from Sun. Quality, compatibility, and performance. The Java team has fixed more than 1,800 bugs this year. So I'd like to applaud the Java team and their manager, but they deserve some credit.

This is much more than last year and we're running out of bugs fast, so we need your help. We go beyond the Java compatibility kit. We are in constant discussion with SANS engineers regarding unwritten specs. We are always striving to make Mac OS X Java behave as well as, behave much like Windows Java, but keeping all look and feel. And this is a very, very tight line to work on.

We have an enhanced in-house regression test suite based on JUnit. And the reason I mentioned this is that if you provide your own JUnit test in your bug reports, you have good chances that we will incorporate them. And we will never regress on any of your bug files.

The number of critical applications that are based on Java on Mac OS X keeps increasing. With Leopard, we expect to have more than 72 of them. And this is a great progress, and it shows that Java on the desktop is alive and strong. Performance. Is it fast enough? Well, when Tiger shipped, this was the fastest Java we had ever shipped.

When Leopard will ship, it will still be true. We are making great progress in performance. And we now have really a good apples-to-apples way of comparing Java. We can run Windows on Bootcamp, run Java on Mac OS X and on Bootcamp, and we can really see the exact performance of our frameworks.

Let's take an example. This is straight out of our labs. The SciMark scientific benchmark is well known in the industry. It's used to benchmark the Java performance for both software and hardware. And you can see that we've been making progress on our hardware since Java 5. Java SE 6 client is already much faster than a J2 SE 5 client.

What's interesting is the server version. It's now much, much faster than anything we have had in the past, and it's 20% better than the currently published number. Mac OS X has never been better than rank number 10. If we were to ship today, it would be rank number 1 with a 20% margin. So imagine what's going to happen when we ship tomorrow.

Similarly, startup times are improving. Two very large applications that take a very long time to start up are IntelliJ IDEA and Eclipse. They both used to start between 12 and 20 seconds, depending whether you were running with the client compiler or the server compiler. Today on the new hardware, they are at five seconds. And the gap between the client compiler and the server compiler is shrinking. And this goes in the direction that we're taking to try to merge the two technologies together. And this is a goal that Sun is working on.

We have always lagged in alias drawing. On Mac OS X, everything is anti-aliased and we are very performant there. But on Windows, Java is drawn with alias graphics. And when we compare all drawing on Windows, Windows drawing to all drawing, if we are fair, we should compare graphics alias and we are lagging. With the new OpenGL pipeline, we've made great progress. The OpenGL pipeline will be available in Java SE 6 and it's coming from Sun on leveraging the OpenGL libraries available on Mac OS X.

Let's answer some common Java questions. So these are questions that are recurring on our Java dev mailing list, and I'd like to close them once and for all. I'd like to prove that we are listening to you. Very often we get, well, every time we have a new release, we get asked, can we get Java previews on a shipping OS?

This year we've listened to you, and Java SE 6 previews have been made available on Mac OS X Tiger as soon as we started working on them. Today I'm happy to announce that we'll have a new developer preview. If it's not available yet, yes it is, live, at this minute.

Go ahead and download it. It's packed with the OpenGL pipeline and all the goodies from Sun. And it's also available on the Leopard DVD. I'd like to take this opportunity to thank you because your testing and your feedback has provided us more than 180 great bugs to work on.

How long will it take to fix the bugs I just filed? For a lot of us, the Apple bug reporting process is a lot like a black hole, a lot of you. We know this is not true. All bugs are screened within 48 hours. And out of these 1,800 bugs that we have fixed last year, a third were developer-originated and were fixed. And that represents 75% of the bugs that were originated by you last year.

So some bugs may take longer than others, but on average, we do not sit more than 100 days on a bug. And it used to be like 200 days in the previous year. So we are making great progress there. Our time to release, or at least to developer release, is much faster.

When is the next Java coming? So as soon as Sun comes up with their pre-alpha version of Java SE 20, we are asked to provide it. And we are following, indeed, some releases of Java IC6 Beta and other Java updates very closely. We cannot worry just about the latest Java. We have to go back on 1.3, 1.4, 1.5, and on all the OS we still support.

The state of the art on Tiger is that Java 1.3.1 is duplicated, and for Java 1.4 and J2SE5, we are very close to the latest updates available from Sun. And Java ICC 6 previews are at beta 88, which is as well a few points behind the latest beta.

How do I make the latest Java the default on my system? So this question accompanies-- is always coming after developers install a developer preview. They want to take advantage of it or stop taking advantage of it. And again, I talked about this earlier, we have an updated Java preferences application that lets you specify the default Java for applets, command lines, and applications. There is no more mucking around with symlink, copying around current JDK directories, and so on. It's clean, easy, and it's foolproof. And the UI hasn't changed, it still has the same location, so it's just more powerful.

Why isn't Apple's Java as stable as Sun's? We're working hard to correct this misconception. Only 35 bugs were filed on J2SE 5 since the April 2006 release. In April 2006, J2SE 5 became the default Java on Mac OS X. It's been four months, 35 bugs have been filed. Anybody wants to guess how many downloads we had? 6.5 million downloads. 6.5 million people suffered through 45 megabyte download on a slow connection. They used Java and didn't find anything to report.

It's very cool. Everything I've tried has worked very well. Congratulations to the team. Someone we really liked sent us an email about J2SE 6 DP1s. And all indication is that even our first DP was very stable. And this person is James Gosling. And I'd like to welcome him on stage to say this by himself.

Hi, Francois. Thanks for inviting me up. He also asked me to show off a few things in NetBeans. And so if we can get my screen up here. Can I have my screen up? Hello. Thank you. So this is NetBeans. This is the tool that I've been helping out with for the last several years. I'm sort of the CTO of the Java organization, which means I kind of get to kibitz a lot. I don't actually get to work. I just get to kibitz.

But this is my favorite toy to play with these days. And it's a very nice little IDE. It's got all kinds of little eye candy. And one of my favorite little hacks from lately is this little navigator, which is kind of a scroll bar that gives you a fisheye lens version. And the interesting thing about this is that various people have done sort of fisheye lens viewers, where they sort of Greek the text by drawing little lines.

This one doesn't do that. This one actually draws the text. All the little gray things you see are the text drawn really small. And so this is actually drawing the entire text document over and over again. And so you can see how unbelievably fast text rendering is on this thing, because it's repainting the whole document at every slide of the mouse. And it's actually quite smooth. It lets me get around very quickly.

uh...

[Transcript missing]

You know, it's got all the sort of inline help. It even has inline Java doc that sort of pops up. You can do things like, you know, as your-- you know, you can set breakpoints, and you can run things. One of the things that we do-- is, is, is, we actually bundle all the, all the enterprise facilities together at the same time. So this is actually just deploying to Tomcat, starting up Tomcat, and thank you very much.

and the Tomcat Ghost Blat. Oh no, sorry. I got a brain of a duck. It hit the breakpoint. So you see all the displays of the HTTP requests, and I can... I'll delete the breakpoint. I'd forgotten that I had started this guy a little bit strangely. So let's just sort of continue out of that and get back.

and you can see how it was, you know, it's actually been, you know, booted this thing up. The ability to do remote debugging in NetBeans is a really nice feature, particularly of deployed app servers. Right now I'm using Tomcat, but there's about half a dozen different app servers that it supports that you can deploy and control and all the rest of it. One of the demos that I wanted to be able to show was doing remote debugging on cell phones.

There's a lot of facilities in NetBeans that are all about developing stuff on cell phones, doing remote debugging of them. Unfortunately, the remote debugging stuff doesn't work from OS X. It works great on Windows, but it actually does work. It's just a little too shaky for me to be comfortable with. All right, there you are. - Yeah.

All right, so here's another little thing. Here's an app. One of the nice features that NetBeans has got is a bunch of stuff for profiling. And I apologize, I've got a lot of stuff loaded on this thing, and it's spending a lot of time paging. So you can profile all kinds of stuff.

Here I'm just going to do some relatively generic profiling, and I'm going to run the app. And this app actually is the slide program that I use whenever I'm doing slides. Page, page, page, page, page. I can get a little disk drive going. I've only got two gigs of RAM on this thing.

Yeah, actually, most of the memory is the app that I'll show at the end. And it, unfortunately, has a timer task. So now it's instrumenting it and starting up anytime soon. Yes. and I'm not using JDK 6. JDK 6 actually makes a real difference. So this is my little slide app.

So I'll just sort of play around with it for a little bit. All kinds of fun statistics in the Java world. We did 240 million JRE downloads last year, 8 million downloads of the JDK. That's for developers and that counts like Morgan Stanley or Lehman Brothers as one. One of the nice things we do on Windows is we've got bundling deals with almost all of the manufacturers so your customers don't have to download.

You know, they announced the 64-bit support in the Mac OS, in the Mac JVM just recently. And it's actually been out for a while, so don't worry about it. It's actually very solid, very mission critical. And we actually qualify it all to about 500 gigabytes. One of the fun things that I've been involved with is all the real-time work.

This is a really great chart. You see here, there's a, this is two app servers, the real-time and the non-real-time server. The blue is the non-real-time, and the horizontal axis is kind of the response time. And you can see that the real-time app server completes almost all requests in 2.4 milliseconds. And there's actually two peaks here, you can't really see it.

The other one's at 11 milliseconds, which turns out to be a TCP bug. But, you know, getting those things all sort of down there has been a really fun thing for us. And of course, you know, this stuff all works a lot better in Mustang. Now let's do a little bit of typing to warm up our performance stats.

All right, so let's call that done. Save before exiting. No, I don't want to save that slide set. And yes, I do want to see the profile. So now we've seen what the profiling has spit out for us. There's the main thread. There's a bunch of stuff that spends doing initialization. Here's actually where things like painting happen. And you can sort of do all kinds of breakdown. You can get an amazing amount of detail to really see where all your performance is going. Um... and others. Thank you. There you go.

The next thing I want to show you is the Matisse editor. This is the Matisse editor that you've probably heard about. One of the nice things that it does is it doesn't use absolute positioning. It gives you all the advantages of all the dynamic positioning, but it gives you a user experience that's a lot like an absolute positioning thing. And if you can see, I don't know how well it's showing up on the projectors, but there's all these little sort of vertical bars where it's showing you the constraints that it's deriving. It's deriving the constraints from all the little bits and pieces that you drag.

This has the advantage that you get this really easy experience, and yet all of this responds correctly when you do internationalization, when you change labels from Chinese to German, or when you resize things. It all works really smoothly. Now, there are actually a few slides I wanted to go through, and we'll get back to that slide deck.

I wanted to talk a little bit about the About some real-world applications, I mean, Java is used out there for just billions and billions of things. You know, my favorite one these days is still the Brazilian national healthcare system. You know, 120 million people, every patient-caregiver interaction from, you know, from proctoscopies to taking your temperature to filing a prescription.

You know, giant telescopes. Most of the world's giant telescopes are controlled by Java apps. You know, the JPL guys use it really heavily for, like, the Mars Rover stuff. You know, the protein-folding world uses it. All of eBay and Orbitz, you know, they're giant Java apps. And there are a lot of desktop apps that have been showing up. This is a few that I sort of gleaned off the web in the last week or so. Blurb.com is a fun one. It's kind of like the book publishing thing in iPhoto.

Except that it also works on Windows. One of the nice things about doing Java desktop apps is that you get all the fun of developing and so forth on Apple. But you're not cutting yourself off from the Windows market. Here's another one, Spring Medical. They're a nice sort of charting company. And here's a couple of screenshots from there. They do everything that you need to run a hospital. And this is basically the Brazilian healthcare.

Healthcare system design. Sort of, except that it's done for the U.S. So it does all the right U.S. stuff. And they very nicely support, you know, both Windows and the Macintosh. So you find doctor's offices using this on the Mac as well as on Windows. It's kind of whatever the doctor's office wants to do.

It does things like patient charts. One of the nice things that's been happening in the Java world because, you know, we do both, you know, interesting desktop apps, cell phone apps, and infrastructure stuff, is that you find a lot of companies are kind of changing the way that they're doing business around their software. And one of my favorite examples is my brother's company. It's called Dirt. Doing it right this time. My brother's an industrial designer. And they do furniture and wall systems. And they started this company a couple of years ago.

And they had the lovely advantage of being able to design the product, the business, and all the processes. And software together. So what they build is walls kind of like this. They're the only people around that can build truly curved walls. And not custom. Just, you know, using standard parts. And they have this app, which I'll... I'll try to bring up here. So their app is right here.

So their app looks kind of boring. It's one where you can pick different kinds of structures. You can pick walls and you can draw walls and it just puts the wall in. Now what's going on here is actually pretty interesting because there's actually an expert system behind this that has done all the figuring out of how all the clips and connectors have to go, how all of the structure of the wall has to be put together.

If you draw walls at strange angles, the expert system figures out how the posts work. And if you're running this on Windows, unfortunately, because they did something I really didn't like, which is that they tied their, they do real-time pricing. So you can get real-time pricing but only on Windows because they use Internet Explorer and I've been beating the crap out of them to get rid of that.

They don't need to do that. Why they did it is beyond me. So this looks vaguely like a lot of the interior design apps that you see. This has got a couple of things that are different. So is that the first time these apps work on Mac OS? Is that the first time these apps work on Mac OS X?

In that design community, finding people who use Macs is actually pretty hard. So the really interesting thing I wanted to show is that they actually use all of the OpenGL stuff, all the Joggle support. They use a 3D API called Zith, which is one that was designed for video games. So now if I do something like that. I think we have to cut this here. Yeah, I just want to put a door in.

And, you know, it does all the AI stuff, and it's really cool. And they actually, you know, there's a build button on this thing that causes giant robot arms and laser cutters to go into action. They actually control all the robots from it. So thanks. Thank you, James.

Great, great. We stay in the trenches and we sometimes forget about these great applications being developed. Let's move on to Java SE 6 and start with Sun's feature. For Java C6. As you've heard, Java C6 is a codename Mustang, and a Mustang can be a lot of different things for different people. Here it's a plane for Duke.

And I'd like to welcome another person from Sun, Scott Violet. He's a client lead architect and he has a demo. He will demo IRIS, a showcase of Java 6 features. Thank you, Francois. All right, so a while back when I had contacted Francois about speaking at WWDC, I offered to speak about all the wonderful and amazing client features we've done to really reinvigorate the client.

But you know what, Francois is much better speaker. He has that sexy Frenchman accent that I can't compare with, so I'm just going to focus on a demo. So, you know, if you went to the keynote like I suspect all of you did, if you're like me, you were blown away by the visuals that the Time Machine app had. It was just amazing to see sort of dropping into this 3D view and, you know, looping through things. Wonderful use of 3D technology to convey the point. I suspect this is a good indication of where, you know, all desktop applications are going to go.

And, you know, the demo that I'm going to show nicely fits in with that insofar as you can do those effects with Java today. Now, I don't have a lot of time, so I'm just going to show you a small portion of IRIS. This IRIS demo is one that we actually created at Java 1. And you'll notice a lot of use of these sort of 3D, these animation effects, sort of you'll get nice hover effects, these subtle animation in and out.

You can go ahead and type in and log in here. Now, this application actually does a number of things. It's a sort of photo viewer, but it's meant to be one. That you can map out a particular vacation that you went along or a trip that you went along and assign photos to that.

So, again, you can see, you know, these nice transitions that are going everywhere. I mouse over, I get these really nice effects. And I just want to show one aspect of this. And, again, you know, mouse over here, you get these nice zoom in, zoom out, all extensive use of effects all throughout this application.

But the one aspect I just want to show here is the photo aspect of it. And this is an application that will allow me to put together a trip report with photos going along the way, but a key part of that is photo albums. And this is actually pulling data from Flickr right now, so that's why in certain aspects of it, it's a little chuggy, just because we're sucking all this data down from the web right now. So one of the interesting things, again, that I should mention about this application, it's a complete swing application. The things that you have going on here, you have JList up there, you have labels, text areas, buttons, they've all been customized, but nonetheless, they're just swing widgets.

So if I click on the Show button here, I'll be dropped into a nice photo viewer. And the photo viewer is making extensive use of Joggle, Java bindings for GL. So I can go ahead and click, and I can navigate through these, zoom in to some particular photos, go back and forth between them, and et cetera.

So I think if you've seen how cool the Time Machine application is, there's no reason we can't do those sort of things in Java applications. And this is sort of a small example of that. If you're interested, the source for this code, the source for this application has all been made on a Java.net application. So if you are interested, I'd encourage you to take a look there. So I think at this point, I'm going to hand it over to Francois, who I'm sure will be happy that I'm done early. FRANCOIS CHOLLET: Oh, great.

Thank you. Well, Mustang. All the features you see on these screens are covered in Scott's application, or almost, hopefully. And I'm going to go, I don't understand half of them, I'm just going to go through a few of them. On the desktop, core libraries features, security and networking, enterprise and XML, VM and serviceability. These are the five main areas.

The main desktop features, I believe, is improved layout experience. You also have a new swing worker and drag-and-drop enhancements, desktop APIs. A lot of things have been going on there. Core libraries improvements include refinements to the concurrent package for locking mechanisms, compiler APIs and annotation processing. This is for IDE developers mainly. Scripting language APIs. And Rhino JavaScript engine was in and is now out of the betas.

On the security front, a great improvement there is our XML digital signatures for web services. Smartcard I/O API. Native JSS Kerberos integration is something we've had in J2SE 5 and Mac OS X, and it's now included by Sun in Java SE 6. And an HTTP cookie manager, we have had this in WebObjects for a while, and it's now part of J2SE 6. So we'll make sure for these APIs we will align to Sun's way of doing things.

On the enterprise front, the XML parsing packages, the database connectivity package, and the Java management extensions have been revved up. And there is a new database, a pure Java database called Derby that has been added to the latest betas. And it's coming from the open source world, and we will try to take advantage of it in WebObjects.

VM features, last but not least, VM features. Performance improvements through faster class verification and compilers. VM Attach and Demand for debugging systems in production. You do not need to have special options, to type special options when you start your production system to be able to attach to the VM. And new VM tools: Remote Stack Analysis, Java Heap Analysis, and very important, DTrace.

Now, these were some features improvement for Java SE 6. On top of that, we have a lot of Leopard changes, and we want to take advantage of them in Java SE 6. As always, Java is built on top of Core OS frameworks. There is pretty much a one-to-one mapping between Mac OS X core frameworks or core libraries and Java's feature set. For example, Print Services is used for Java printing, Cocoa is used for AWT, Quartz for Java 2D, and so on.

Cocoa Component. If you're tired of the look of Sun's color picker, why not use and Mac OS X look and feel and our own color chooser. If you do not want to implement your own font picker, why not use Mac OS X font picker? You do not have to type any code, you just embed it in your Java application through the embedded Cocoa components system. And here you go.

Bundling applications. So there's a correct way to bundle an application and a messy way to distribute an application. The messy way is on Windows. The correct application bundle is on Mac OS X. If you do this, you will be able to drop your application in the dock, keep it nice and clean, and it will bounce and have all the Genie effects that you want. You'll be able to drag and drop to it. Please use Jarbundler. It's your friend.

New Aqua support. There's the new and the not so new. For a while, we've had Aqua everywhere in Java. This means that you get for free screen menu bars, AWT widgets, and swing Aqua look and feel. And again, as I said earlier, anti-aliasing is a default for text rendering. It just works.

Extended AWT, there are many hot Mac OS X features that cannot be implemented in pure Java. So we have extended AWT to give you access to a set of Mac OS X application events. And this is mostly for Doc on Finder, Drag on Drop, also to intercept application menu callbacks, such as quit, preferences, about events.

You can intercept them and put your own Java code in your Java applications. New this year is Extended Swing. You now have alternate window styles at your disposition. There's a handful of them and also small and mini Aqua controls to populate them. And as well, we added sheets. I'd like to welcome Mike Swingle on stage to demo these features.

Thank you Francois. So for my demo here, I've constructed a small little application that represents like a palette for a document window for something that you'd see in pages. And I've launched this in Java 1.5 without our extended swing features that we're working on. And it's okay. It's Java. Just, you know, little Aqua controls, standard size and stuff.

But to really make it look right, what we want to do is actually make it look like a real palette. We'll enable the small title bar for the window that most palettes have. We'll change the size variant of the controls to miniature style. And just for fun, I want to show you the sheets as well.

So this is what the new Aqua look and feel looks like. This is what the new Aqua look and feel looks like with mini controls in Java 1.6. There's a world of difference. We automatically set the font for you and the preferred size. All the pop-ups just automatically scale. And something that you've wanted for a long time, sheets. So we look forward to seeing some new and exciting swing applications that look more at home on Mac OS X. Francois?

Thank you, Mike. This is great. I think I'll call you back on stage later. Clive? OK, let's move on to graphics improvements. You now have the choice on Mac OS X Java SE 6. You have a choice of different graphics engines. Forever we've had the Quartz graphics engine. We have added last year the Sun 2D renderer, which is another software graphics engine. And this year, we're adding the OpenGL graphics engine, which is taking advantage of the OpenGL hardware acceleration.

This is an effort that was spearheaded by Sun. And since we have a great OpenGL library on Mac OS X, we have been able to leverage it. You're going to see great performance improvement from this. But as always, your mileage may vary. So I encourage you to go to the Java graphics and performance session at 9:00 AM on Thursday.

Java 3D on Joggle, what's behind there? Java 3D used to be a very thin layer of Java on top of a lot of native drawing code. This is changing with Java 3D 1.5. It is now based on Joggle. And since Joggle is also available on Mac OS X and Java 3D is now pure Java, Java 3D on Joggle will be available on Sun's website.

Resolution Independence Support. It will not be in Java SE until version 7, and that's a statement. But we have to do something for Leopard. You will have great default layout behavior: sharp text, sharp controls, and sharp AWT drawing. Since we cannot add developer APIs for resolution independence, your images and your layout will be scaled accordingly. And I think demo speaks better than text here. So I'll call Mike again.

Thanks, Francois. Thank you, Francois. So what I'm doing with-- So to come up with a demo here, I thought, well, you know, I could make something kind of contrived, or I could just take a real-world, unmodified application and bring it up with our resolution independence and see how it works. So what we're doing here, we're just going to go to Quartz Debug and just ratchet it up to 2.0 and see what happens.

So it's launching right now. The window positioning and coordinate stuff is still something that we're working on. But as you can see, in high res, all of the text is crisp and clear and sharp. All of the rounded rectangles for these tabs here, all the Java 2D drawing for the code collapse, it's sharp and crystal clear when we have a screen that actually has a lot more pixels. Unfortunately, I can't show you because our monitors are only fixed resolution here.

You'll notice that the images are scaled, but they're not any different than what you would normally see at a 1.0 scale factor, 72 DPI, on a regular screen. The real story here is it just works. You know, and you shouldn't have to change a single line of code.

Well, it's going to be great to have so many pixels to play with. Back when I started tinkering with computers, we were building icons with 8 bytes. And now in 8 bytes, we're putting a pointer. This is 64-bit programming, and with Java, it just works. I am able to reuse a slide from last year. We use this slide for the transition to Intel, and we're using it this year for Java 64-bit.

There is a little asterisk here, and the little asterisk stands for the usual disclaimer. It's only for Intel processors. You have to run your Java applications with the Java SE6 server 64-bit VM. And of course, if you have JNI libraries, you have to recompile them for Intel 64-bit.

But mostly, everything works. And you can trust us. You've heard James Gosling saying how far this had been tested. It works. So what does this give you? It blows away the 4GB heap barrier. It allows more larger objects in multidimensional arrays. And with Java, you get the full Java stack, including the graphics. This means that you do not have to divide your application between a client 32-bit to draw the results of your simulation and your actual simulator. You can put everything in one process and have both drawing and simulation going simultaneously.

Who is this for? Well, they are consumers of huge data sets, like the iTunes music store that want to have the database of all of its songs in memory, and other examples are gene sequencing applications. You also have the producers of huge datasets like NASA, NOAA, petroleum engineering simulations, and so on. For you, if you're not in these categories, you need to evaluate on a per application basis. So there's a possible performance cost.

If I go back to the benchmark that I showed earlier, you will see that Java 64-bit is trailing slightly behind Java 32-bit. And this is still-- this is very early. We just got it running within the last month. And it is still among the best performers of all the industry in 64-bit.

If I drill down in this particular benchmark to the sub-benchmark, you will see that there are some of the mathematical operations like fast Fourier transforms that are much faster, other ones that are slower, and it really depends on whether your algorithm is able to take advantage of the increased number of registers. There are also fixes coming in from both Sun and Apple that should improve these numbers. I'd like to welcome on stage people from Agilent Technologies, Peter Eastman and Mihailo Despotovic, to show us GinSpring.

Thank you. So we want to talk about GeneSpring GX, which is an application for analyzing data from gene expression microarray experiments. So this is a technology that has become very popular in the last decade. And what it allows you to do is to take some kind of a biological sample, like a blood sample or a tissue sample or maybe a cell culture, and you can take a snapshot of what every single gene is doing in that sample at one moment.

And then you can repeat this for a lot of different samples. Like maybe you want to look at a lot of different individuals, or maybe some people who have a disease and others who are healthy, or people who have been given a drug and other people who haven't been. And so you then take all of this data from all these microarrays, and this can produce really a lot of data, easily hundreds of millions of numbers.

And if you just look at it, it's just sort of this mess of lines on a graph. And so the goal of GeneSpring GX is to help you analyze this data in many different ways and try to figure out what it means and get to some sort of understanding of the biology. Now just to make things worse, the microarray technology is advancing very, very quickly.

So this data set that you see up here was generated with a kind of microarray that measures about 55,000 genes. And about two years ago, that was considered a really big microarray. But today, there are already ones on the market that measure hundreds of thousands of gene transcripts, and that number is just going to be increasing in the future.

All right, thanks Peter. And as Peter already implied, the GeneSpring, our application, has to deal with huge data sets. Unfortunately, sometimes when you deal with huge data sets, we run into problems. So some of our algorithms try to compensate for the barriers imposed by 32-bit JVMs by swapping data to disk and swapping it back, which then slows down the computation.

And sometimes you can't even execute the computation because you really need to have some chunk of data in the memory. And if you can't have that in memory, you'll just pop up an error message saying, sorry, we cannot execute. Some of these algorithms are not designed to swap in data for various reasons. And in that case... This is something you might see in our program.

And in this particular case, user tried to calculate and construct the gene tree with this same data set, so it's more than 50,000 genes. Unfortunately, the user didn't have enough memory for this, and we cannot just let this algorithm run. We cannot just throw out of memory exception because JVM will be in an inconsistent state.

User might not save some data. It might be very bad. So we actually tried to estimate how much memory the algorithm is going to need to finish the calculation. In this particular case, unfortunately, that amount of memory was about 6 gigabytes, which is over the 4 gigabyte limit. And the user had about 2 gigabytes on this machine.

And this is an unfortunate message, but however, When we ran this in 64-bit JVM, the message didn't show up, the calculation started, and the user eventually will get its results. So, an important thing to emphasize here is that the difference between program running in the 64-bit JVM on this slide and the program running on this slide inside 32 JVM really doesn't exist. So, it's the same jar, as a matter of fact, same classes, no recompilation, nothing. Of course, it's Java, and it just confirms what Francois said, that it just works.

It works better, actually. So, there are only two things which are done to produce this slide. First of all, 64-bit JVM was started, so it was given a hint to JVM that it should start in 64-bit mode. And we, of course, had to adjust the heap size for the application, because the original heap size was still less than required by this algorithm. So, this is just one small data point. We consider this as a tip of an iceberg.

It's, GeneSpring is also just one of our applications we produce, and we are expecting more applications coming on the very similar engine, and eventually they are all going to benefit from 64-bit JVM on Apple. So, which will eventually make our customers happy, and that's eventually our goal. So, with this I would conclude, and thank you very much. Now back to the main presentation.

Thank you, Mihailo. So as a summary, here are the restrictions for VM flavors on both architectures. Java EC6 previews. The server 32 and 64-bit will only be available on Intel. J2SE 5, the 32-bit VM, will only be available on Intel. And Java 1.4 is for client only. For more details, go to the Java VM session, which is Thursday at 10:30 AM. Java 1.3, let's not spend much time on Java 1.3 because it's dead. It's gone. It's not on your Leopard CD. Rest in peace, Java 1.3.

Java 1.4, well, it's following very closely the sad story of Java 1.3. Move to Java 5 now. You've been warned. The Java bridge, it served its purpose over its 10 years lifespan. It's time to retire it. All the Cocoa Java APIs have been deprecated. Use JNI. And the Xcode templates have been removed from Lepl.

Let's move on to IDE support on the platform. The three main third-party tools are Eclipse, NetBeans, and IntelliJ IDEA. We have already seen NetBeans. Eclipse has its own session. I have a couple slides on Eclipse though. The important thing this quarter is that Eclipse 3.2 was released on Mac OS X, and with it we had a joint effort to fix and improve the AWT/SWT interoperability. This means that plugins can embed AWT components in SWT windows, and there shouldn't be any pure Java plugin that does not work out of the box on Mac OS X.

The cave-out is that there are still some remaining AWT threading combinations that may deadlock, and we are chasing them. Some plugins with native code are not yet available on Mac OS X, so you should put pressure on your plugin provider to support our platform. There's no reason not to do so. Let's have a demo of IDEA. I'd like to welcome Ben Galbraith, who is a member of the IntelliJ advisory board. Yes, sorry. You don't need that.

[Transcript missing]

You guys don't mind, do you? Five minutes and 30 seconds, let's do that. Okay, so what I want to do in the next five minutes and 25 seconds is actually show you coding this timer application from scratch in my code editor. And actually, I did a couple of rehearsals--oops, sorry.

That was stupid. I'll set it to 550. I did a couple of rehearsals, and I can't do the entire thing from scratch in five minutes and 15 seconds. But I can do a little bit of it, and as I do that, I want to show you the experience of coding in IntelliJ.

So let's start a new class file. I'll call it My Timer. And let's get going. The first feature I want to show you is what we call live templates. With live templates, you just type an abbreviation and hit the tab key, and it expands some code out from that.

Now, this was a simple static code insertion. It's actually fairly sophisticated, where you can have parameters. It can actually look at the surrounding state of your code and figure out what possible parameter values are and things. But I'm just doing a simple one there. And now, I need to create a J frame to actually display.

I'm going to display my timer. And if you notice--sorry, I'm not used to this keyboard. I'm fat fingering all over the place. IntelliJ automatically handled the import of the J frame. And in fact, if I get rid of it, it can automatically get rid of the J frame import.

and others. Thank you for watching. - Well, it turns out there's an exception here that I need to handle. If you notice to the left, you see the little light bulb here, IDEA also has a feature called intention actions, where we try and figure out what you're trying to do in a given context and just do it for you. In this case, we have a number of options that we figure you might wanna do here, and one of these options is adding the exception to the method definition, to the method signature.

I also want to assign the result of this invocation to a variable. IDEA supports what are called refactoring. Refactoring is a big trend in our industry right now. In fact, Xcode just got support for it, which is great. Refactorings are automated changes across your code base. One refactoring that IDEA supports is just inserting a variable where there wasn't one previously.

And so I can insert a variable and IntelliJ automatically looks at the return type and figures out that I might wanna call it model. I could also call it form model if I like a little bit more verbosity, and it automatically inserts that for me. This feature is so effective that I actually find that I don't even write the left-hand side of my code a lot, I just rely on this and just insert the variable.

And now that I have my variable, I want to go ahead and create the top level panel. Notice actually when I do the code completion here, I just type in C and hit the code completion shortcut. And that time it actually didn't work, but typically it will highlight the last method that you invoked because it keeps track of all the methods you invoke and just tries to figure out which one you're likely to want to do.

And now I'm gonna go ahead and get my content pane and add this panel definition. And so now I have a GUI, but I'm not really done yet because I need to add some behaviors to it. And so let me go ahead and do that. And I'm gonna get references to a couple of components that are in my UI. And I can just type some abbreviations of these methods and IntelliJ will automatically expand those out for me.

So you can actually find when you use all these features, the number of keystrokes that you use, goes down tremendously. I'm getting pretty old in years and this is useful for me because I actually have a lot of repetitive stress symptoms. And so I find when I use IntelliJ, I can actually code a lot less in terms of number of keystrokes, which for me is kind of important.

Now I want to add a listener to my button for my behaviors. IntelliJ has another feature where we actually will list all the different classes in your class leader domain that implement the listener contract that you're currently trying to implement. So these are all the action listeners in my application. Here I'm gonna choose one.

And now that I have my action listener, I need to prevent reentry in my timer. So I'm gonna set the button to enable. It marks a squiggly line because, as you probably know, I need to have references inside of inner classes marked as final. It does that for me with an intention action. And now I need to do a couple of other things. I need to get the text that the user entered from that field.

And I'm gonna have to mark that text field final. I'm gonna use my refactoring to get the text. And I'm also going to auto-import my timer utils class, which is a shortcut that lets me cheat because it's a bunch of pre-written code that I just didn't have time to do live in front of you.

And I'm gonna introduce a variable here, countdown seconds. And I'm not gonna make it, am I? Let's see. Start long equals system current utils milliseconds. And I just have a couple more lines left. So now I need to do the loop where we actually count down the seconds. Start long.

How am I doing, Francois? Do I got a couple more seconds? Can you give me a couple more seconds? And let's see. I need the label here. I'm gonna have to mark that as final. And ooh, at the very end, I need to set my button back enabled. True. All right. So that's basically all I wanted to do. Are there any obvious problems here?

One obvious problem is that I have this loop on the UI thread. So before I wrap up, I just need to put that onto a background thread. I'm gonna use the surround with feature. It's another feature of IntelliJ. Oops, I didn't mean to access that feature. I was turning to mark this as final. And the right keystroke, yeah. And now new thread, runnable. Start. And OK. So we've got-- and there's just one tiny little additional thing that I'm not gonna have time to fix.

I have to put this back on the AWT thread. But I wanted to show you that IntelliJ actually keeps track of all your to-dos in a central location. So you can go back and look at it and see that you need to solve this. And now I can just right click on my main method. And with any luck, the demo will actually work. So that's ideal.

Thank you. Any closing statement? No, I'll do it. Thanks, Ben. Great. Let's not let this eclipse Xcode. It's our own Java development tool. It's the one we're using in my team. And the reason we're using it is because it's the best tool to do cross-language development if you're doing Java, C, Objective-C, C++ side by side.

It has all the goodies of a modern IDE, including integrated debugging, code sense, no-call power edit. What we added this year are new end templates, and I encourage new developers, students to start here. Teams can now use multiple IDEs and build in harmony. You could have half of your team using Eclipse, half of your team using Xcode, and half of your team using IDEA.

and the other way around. Other Mac OS X tools available on the platform. Well, you have Terminal, Emacs, VI. For building and deploying, I already talked about JAR bundler. Shark will be demoed in our performance session, or Java graphics and performance session. Quartz Debug as well will be showcased there. What I'd like to show you now is X-Ray. X-Ray is our new profiling tool. I'd like to welcome Lynn on stage. She needs a few more minutes to showcase X-Ray support for Java.

In our Java VM session, we will also show you the new command line profiling tool called Dtrace. It's coming from Sun and it's working great on Mac OS X and Leopard. So I really encourage you to go see it. And I'm off, so Lynn is here. Thank you, Francois. So I'm going to show you, yesterday you've probably seen how X-Ray works in profiling your tools. So I'm going to show you today how to use it to profile Java.

So right here I have X-Ray and as you can see I have my instruments down here at the bottom. So I'm going to select my CPU load tool and drag it up here and my Java thread tool. And in order to start it, I'm going to click play. And, okay, I'm probably going to have to run this again.

Okay, once again, I'm going to start with dragging the CPU load up here. and then my Java Thread tool. And I'm going to get rid of the UI recorder, so just going to minimize it. and I'm going to click play. And I'm going to select a Java demo application, which is Java 2D, and I'm going to open it. And as you can see, I can view the results of my sampling at the same time.

[Transcript missing]

All right, it seems to be stuck on something, so let me just try this again.

So, yeah, once again, let me just put in my CPU load and my Java thread. I'll click Play. All right, so it seems that all the fooling around with the number of processors and other demos have sort of messed up the setup that I had before. But anyway, I'm just going to return this back to Francois. Sorry.

Keep going, I have a few more slides you can... Alright. Keep trying. I'll move on to the next slide, please. We have a few more minutes, so we're fine on time. Hopefully you can get back to this. For more information on Java, please attend the sessions we have this week. We have seven, I'd say five more sessions on Java, four more sessions on Java, two more sessions on WebObjects, and a feedback forum joined for both of them.

Documentation, sample code, you should get all your information for this URL. We want your feedback. Please follow us after this session to the labs. We have a feedback forum. And emails, send your emails to Alan Samuel, not to me. Even though I'm listed, you can talk to me afterwards.

And Lynn is still trying. - Oh, it works. - Coming, okay. Back to demo? - Yeah.

[Transcript missing]

It actually shows me the threads that are running at the same time that I'm actually playing around with my Java 2D demo application. And so my thread instrument's right here, and I'm going to stop sampling right now. I mean, I'm going to stop running the profiling.

and zoom out a little bit so you can see the threads. And as you can see, we have all the threads that were currently running up here. And the names are up here and threads that are running are green. Threads that are waiting are in yellow and threads that are blocked, I'm going to zoom in a little bit, you can see are red.

And you can see in this situation, the main thread and the AWT event queue are blocked in some cases. So I'm going to scrub over here to see this interesting region and I'm going to click on the info button right here. So as you can see, my more detailed view shows me the names of the threads that are currently running. And it tells me their priorities, whether they're daemon or not, and their state.

And the most interesting threads are the main thread, which is blocked, and the event queue. And I could click on those threads and look at more extended detail, which actually shows me the stack trace of those threads. And the monitors that they own, so you could actually tell what they're blocked on.

And I could also go back to the Java Threads view and as I change the time, it actually scrubs along. So I'm just going to go back to where it's blocked and click the info button. And you could actually scrub along this way and your stack trace actually changes at the same time. So I hope you all use this tool to profile your Java applications. And back to you, Francois. Thank you Lynn. This is the first, but hopefully just the first, plugin we will develop for Java profiling on X-Ray.

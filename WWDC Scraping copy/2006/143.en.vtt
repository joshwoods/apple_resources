WEBVTT

00:00:16.460 --> 00:00:20.130
So welcome to Cocoa from Ruby and Python.

00:00:20.310 --> 00:00:23.230
We've got some pretty exciting
stuff to talk about here.

00:00:23.260 --> 00:00:24.040
I'm Bill Baumgartner.

00:00:24.040 --> 00:00:28.330
I'm the manager of the sort of
chewy middle layers in Xcode,

00:00:28.330 --> 00:00:29.690
build system, things like that.

00:00:29.740 --> 00:00:33.140
And, you know, scripting languages
have become really hot.

00:00:33.140 --> 00:00:37.460
I mean, they've been hot for a while,
but they're really getting out there.

00:00:37.460 --> 00:00:38.620
They're becoming very popular.

00:00:39.400 --> 00:00:43.370
And people are using them to build
larger and larger things as well.

00:00:43.390 --> 00:00:47.360
Now, some of the reasons for this
popularity is that they really offer

00:00:47.390 --> 00:00:51.430
a rapid application development
methodology or patterns that you just

00:00:51.430 --> 00:00:52.820
can't do with compiled languages.

00:00:52.820 --> 00:00:56.770
Likewise, scripting languages are often
considered to be batteries included,

00:00:56.770 --> 00:01:00.400
meaning that the scripting languages
come with these huge libraries.

00:01:00.400 --> 00:01:04.040
They're really easy to use,
and they do some very powerful things.

00:01:04.040 --> 00:01:06.020
Or you can pick up libraries
from third parties.

00:01:06.020 --> 00:01:08.410
And I am.

00:01:08.420 --> 00:01:09.400
I asked the O'Reilly.

00:01:09.400 --> 00:01:13.600
O'Reilly folks for some numbers,
and they were very kind to give it to me.

00:01:13.600 --> 00:01:17.020
These are book sales in the
last year and changes over time.

00:01:17.110 --> 00:01:19.550
And as you can see,
Pearl's off a little bit,

00:01:19.550 --> 00:01:21.990
but still a pretty good-sized chunk.

00:01:22.000 --> 00:01:25.120
Ruby's up 700%, largely because of Rails.

00:01:25.120 --> 00:01:28.180
Python's climbing,
even though nothing's really

00:01:28.180 --> 00:01:30.000
happened in the last year.

00:01:30.000 --> 00:01:34.790
So, yeah, scripting languages,
they're here, and everyone's using them.

00:01:34.900 --> 00:01:38.760
And Cocoa developers really
shouldn't be left out of this fun.

00:01:39.720 --> 00:01:41.560
So why?

00:01:41.600 --> 00:01:43.100
Why bother?

00:01:43.350 --> 00:01:45.800
Well, it gets down to the rapid
application development thing.

00:01:45.840 --> 00:01:48.020
Thanks for the demo machine.

00:01:48.130 --> 00:01:52.120
When we were doing Core Data,
one of the biggest challenges when

00:01:52.120 --> 00:01:55.220
you're coming up with a new API is,
can you use it?

00:01:55.440 --> 00:01:57.180
Does it feel comfortable?

00:01:57.400 --> 00:02:00.860
So literally within the first, oh,
I don't know,

00:02:00.860 --> 00:02:05.480
week or so of having an Xcode project
that was the Core Data framework,

00:02:05.500 --> 00:02:09.130
I was able to bring up my Python shell.

00:02:09.500 --> 00:02:13.730
import the foundation because well you
always have to have a foundation and

00:02:13.730 --> 00:02:20.910
then i could um let me grab objective
c too i could then just load bundle

00:02:21.090 --> 00:02:33.990
I don't remember how to use Load Bundle.

00:02:33.990 --> 00:02:33.990
It's another great
Rapid App development feature.

00:02:33.990 --> 00:02:33.990
I can actually get help.

00:02:33.990 --> 00:02:33.990
Oh, I need to see the help though.

00:02:35.140 --> 00:02:42.010
So if I do, obviously, load bundle,
core data,

00:02:42.230 --> 00:02:44.720
I'm going to just throw it right
into my interpreter because,

00:02:44.770 --> 00:02:47.380
well, that's a useful place for it.

00:02:48.440 --> 00:02:54.530
I can now go off and I could, you know,
create a managed object model.

00:02:54.600 --> 00:02:56.200
I could work with the APIs.

00:02:56.200 --> 00:02:57.390
I could do whatever.

00:02:57.470 --> 00:03:00.300
And then because of what
I'm going to show you next,

00:03:00.550 --> 00:03:02.640
I could then turn around and
turn these into unit tests.

00:03:02.640 --> 00:03:04.020
I could turn them into a full-blown app.

00:03:04.020 --> 00:03:05.400
I could do all my prototyping.

00:03:05.400 --> 00:03:08.700
So you're going straight from
interacting with your live objects

00:03:08.700 --> 00:03:10.800
through to building production apps.

00:03:10.800 --> 00:03:12.970
Can I have the slides, please?

00:03:15.560 --> 00:03:17.190
So this is our commitment.

00:03:17.230 --> 00:03:21.210
We, Apple, are embracing scripting
languages as first-class

00:03:21.250 --> 00:03:23.180
application development tools.

00:03:23.220 --> 00:03:25.740
This includes binary
compatibility across releases.

00:03:25.790 --> 00:03:27.530
So...

00:03:30.900 --> 00:03:33.860
If you build an app with Ruby,
Cocoa or PyOpc as shipped with Leopard

00:03:33.860 --> 00:03:38.860
and drag and drop that onto 10.whatever,
11.whatever, whatever the next OS is,

00:03:38.860 --> 00:03:40.260
it should work.

00:03:40.430 --> 00:03:42.860
And if it doesn't, it's our bug.

00:03:44.160 --> 00:03:45.620
So what do we have today?

00:03:45.770 --> 00:03:48.780
Well, right now,
most of your scripting languages out

00:03:48.780 --> 00:03:50.810
there already do a lot of bridging.

00:03:51.030 --> 00:03:53.250
And in particular,
they bridge to the system layers.

00:03:53.260 --> 00:03:56.370
So you have all the BSD,
BSD-like APIs are wrapped up

00:03:56.370 --> 00:03:58.340
in the scripting languages.

00:03:58.340 --> 00:04:05.130
Many of them provide GUI toolkits,
WX Python, there's Ruby TK or something,

00:04:05.140 --> 00:04:08.100
I can't remember which one it is,
but there's a bunch of different ones.

00:04:08.260 --> 00:04:13.250
The problem though is that they don't
support building truly native apps.

00:04:13.380 --> 00:04:16.200
You build one of these,
an app with like WX Python and

00:04:16.200 --> 00:04:18.250
it looks like lipstick on a pig.

00:04:18.250 --> 00:04:24.220
It just does not look and feel like a
real Cocoa app or a real Carbon app.

00:04:24.350 --> 00:04:29.640
So, then comes the question of
which languages to support.

00:04:29.680 --> 00:04:32.130
And, well, which language is better?

00:04:32.190 --> 00:04:34.790
It's not interesting,
and since this is only a half day,

00:04:34.790 --> 00:04:37.730
we don't have the hours to discuss it.

00:04:38.300 --> 00:04:41.690
However, what you want, though,
is a language with a strong

00:04:41.690 --> 00:04:43.290
object-oriented theme.

00:04:43.360 --> 00:04:46.770
And you really want ones
for us that already have

00:04:46.770 --> 00:04:49.540
high-quality bridges because,
well,

00:04:49.540 --> 00:04:54.300
that's less work and we already know the
community is adopting and has momentum.

00:04:54.310 --> 00:04:57.370
And for Leopard,
we're committing to Ruby and Python.

00:04:57.900 --> 00:04:59.660
So, why Ruby?

00:04:59.660 --> 00:05:02.590
Well,
it's object-oriented from the ground up.

00:05:02.600 --> 00:05:06.410
It's obviously a very popular
language and it's growing.

00:05:06.520 --> 00:05:11.120
And beyond everything being an object,
it also has a very dynamic

00:05:11.180 --> 00:05:14.750
philosophy of implementation
that's close to the Cocoa model.

00:05:14.850 --> 00:05:17.350
And there's the Ruby Cocoa Bridge,
which is excellent and

00:05:17.350 --> 00:05:21.340
getting much better,
and it's been in development since 2001.

00:05:22.900 --> 00:05:25.990
Similarly, why Python?

00:05:26.060 --> 00:05:28.740
Well, Python has a very mature
object-oriented model.

00:05:28.780 --> 00:05:30.890
It has a few warts, but not too bad.

00:05:30.890 --> 00:05:33.900
Though it also supports
functional and procedural,

00:05:33.900 --> 00:05:35.460
it's a very flexible language.

00:05:35.460 --> 00:05:38.570
It is designed to be
embedded and bridged,

00:05:38.580 --> 00:05:39.130
etc.

00:05:39.130 --> 00:05:42.340
And there's lots and lots of
modules out there that demonstrate

00:05:42.500 --> 00:05:44.160
how to do this kind of thing.

00:05:44.160 --> 00:05:47.590
But there's also the PyOpsy Bridge,
which has actually been

00:05:47.590 --> 00:05:51.230
in development since 1994,
came up on Next Step.

00:05:52.900 --> 00:05:56.900
Well,
it was forged in hell of Wall Street.

00:05:56.900 --> 00:05:59.580
I don't know how many of you
have ever done financial apps,

00:05:59.610 --> 00:06:02.000
but when you go to a trader
and you tell them that,

00:06:02.060 --> 00:06:05.080
well, you're $150 million,
don't know where it is.

00:06:05.080 --> 00:06:06.380
They get really irritated.

00:06:06.380 --> 00:06:10.540
So PyOpsy was developed in that
kind of an environment and has a

00:06:10.540 --> 00:06:15.340
real focus on producing the right
answer and doing so consistently.

00:06:17.000 --> 00:06:19.010
So why not some of these other languages?

00:06:19.070 --> 00:06:23.140
Well, Perl, we asked a lot of people and
there wasn't a lot of interest in

00:06:23.150 --> 00:06:25.400
developing Cocoa apps with Perl.

00:06:25.400 --> 00:06:29.890
And there's CamelBones,
which is an excellent third-party bridge.

00:06:30.010 --> 00:06:33.340
So if you want to use Perl,
go use CamelBones.

00:06:33.690 --> 00:06:36.660
There's the Cocoa Java bridge,
while it's being deprecated.

00:06:36.710 --> 00:06:39.440
And is this going to happen
to the scripting languages?

00:06:39.550 --> 00:06:39.980
No.

00:06:40.130 --> 00:06:43.000
The Cocoa Java bridge was, um...

00:06:43.340 --> 00:06:46.350
Not the most easily
maintained implementation.

00:06:46.400 --> 00:06:48.410
There was a lot of manual mapping.

00:06:48.450 --> 00:06:52.160
There was a lot of trying to
make Cocoa feel like Java.

00:06:52.160 --> 00:06:56.200
And because of that, it was just a really
hard bridge to maintain.

00:06:56.200 --> 00:06:58.900
And because of the impedance
mismatch between Java,

00:06:58.900 --> 00:07:02.510
Java wants really strong typing and
it wants to know things up front.

00:07:02.510 --> 00:07:05.300
And Cocoa Objective-C,
which tends to be very

00:07:05.300 --> 00:07:08.580
late-binding and dynamic,
just didn't fit well.

00:07:09.300 --> 00:07:12.990
There's also Fscript,
which as you saw in the design awards,

00:07:12.990 --> 00:07:14.300
did quite nicely.

00:07:14.300 --> 00:07:18.820
Fscript is an incredibly powerful tool,
but it's not really for

00:07:18.870 --> 00:07:20.270
building full-blown apps.

00:07:20.270 --> 00:07:23.770
It's much more something
you might use to embed as a

00:07:23.790 --> 00:07:28.000
scripting language for your app,
or you can use it as an

00:07:28.000 --> 00:07:30.300
amazing debugging tool.

00:07:31.310 --> 00:07:34.180
So with that,
I'd like to ask Laurent to come up

00:07:34.180 --> 00:07:37.120
and show a little bit of Ruby Cocoa.

00:07:43.400 --> 00:07:45.360
Good morning, everyone.

00:07:45.360 --> 00:07:46.840
So my name is Laurent Sansonetti.

00:07:46.840 --> 00:07:51.410
I work for the CodeOS group inside Apple,
and I'm here to show you a

00:07:51.410 --> 00:07:54.080
quick demo of the Ruby bridge.

00:07:56.300 --> 00:08:02.530
So in the part,
we intend to provide a nice integration.

00:08:02.610 --> 00:08:05.970
We intend to nicely integrate
the scripting bridges with

00:08:05.970 --> 00:08:09.810
the Apple developer tools like
Xcode and Interface Builder.

00:08:09.910 --> 00:08:14.270
And in the seeds you have in hands,
there is already some preliminary

00:08:14.270 --> 00:08:16.690
support for Ruby Cocoa.

00:08:16.750 --> 00:08:19.970
So let's just open our demo project.

00:08:20.820 --> 00:08:26.230
So most of the files in this
project has been generated by Xcode.

00:08:27.090 --> 00:08:31.000
You have this main.m file
that you should be used to.

00:08:31.100 --> 00:08:38.000
This main.m file is mostly the same as
you see in regular Cocoa applications.

00:08:38.090 --> 00:08:41.430
It's just that instead of
calling NSApplicationMain,

00:08:41.430 --> 00:08:44.120
we call RBApplicationMain,
which will initialize the

00:08:44.120 --> 00:08:46.900
Ruby Cocoa runtime environment.

00:08:47.210 --> 00:08:51.370
This Ruby script will be executed
just after the initialization.

00:08:51.370 --> 00:08:55.690
We load all the Ruby scripts
present in the resource directory

00:08:55.690 --> 00:08:58.100
of your application vendor.

00:08:58.100 --> 00:09:01.100
And then we call the
regular NSApplicationMate.

00:09:01.100 --> 00:09:06.100
So let's have a quick look
at the user interface.

00:09:06.100 --> 00:09:08.100
So it's pretty simple in fact.

00:09:08.150 --> 00:09:11.220
We just have a text field here,
here we have a slider,

00:09:11.220 --> 00:09:15.100
and the main view is from a new
framework in Leopard called ImageKit.

00:09:15.100 --> 00:09:20.150
ImageKit is a new framework,
so a meme to be used to browse and

00:09:20.150 --> 00:09:23.100
display images and stuff like that.

00:09:23.100 --> 00:09:27.100
And here we're just using the image
browser view of this framework.

00:09:29.810 --> 00:09:36.610
We have here a class that inherits from
NSWindowController and we made all the

00:09:36.630 --> 00:09:41.220
specific connections and stuff like that.

00:09:41.220 --> 00:09:45.150
The Ruby implementation of
this class is pretty simple.

00:09:49.840 --> 00:09:53.450
So as you can see,
we just inherit from NSWindowController,

00:09:53.520 --> 00:09:55.120
as we would do in Objective-C.

00:09:55.130 --> 00:09:56.600
It's pretty trivial.

00:09:56.630 --> 00:09:58.560
Here we declare the only outlet we have.

00:09:58.670 --> 00:10:01.660
So this is the image with a view.

00:10:01.690 --> 00:10:04.580
So this is initialization stuff.

00:10:05.900 --> 00:10:08.200
Here we have the two actions we have.

00:10:08.200 --> 00:10:11.910
The first one is for the slider,
and the second one will be

00:10:11.940 --> 00:10:15.060
activated when you enter
something in the URL text field.

00:10:15.080 --> 00:10:20.160
We just parse the contents of the URL,
and then we parse using

00:10:20.160 --> 00:10:24.920
the RSS library from Ruby,
in fact, from the Ruby standard library.

00:10:24.930 --> 00:10:27.360
So we just parse the
contents of the given URL,

00:10:27.360 --> 00:10:30.650
and we keep that in the cache.

00:10:30.700 --> 00:10:33.920
Oops.

00:10:33.950 --> 00:10:36.210
Here, oh, but in addition.

00:10:36.220 --> 00:10:38.880
Oh.

00:10:38.880 --> 00:10:41.020
Anyway.

00:10:47.800 --> 00:10:53.700
[Transcript missing]

00:10:54.200 --> 00:10:56.060
- More or less, okay.

00:10:56.090 --> 00:11:01.830
So this is the data source
implementation of the ImageBrowserView.

00:11:02.010 --> 00:11:05.200
The first method just returns
the number of items in the view,

00:11:05.210 --> 00:11:09.110
and the second one,
you need to return an object,

00:11:09.340 --> 00:11:12.680
For a specific index in the view,
this object has to conform

00:11:12.680 --> 00:11:14.060
to a certain protocol.

00:11:14.110 --> 00:11:18.300
Here we return an instance
of the RSS photo class,

00:11:18.300 --> 00:11:20.690
and I will come to that later.

00:11:22.730 --> 00:11:25.220
So here is the RSS photo class.

00:11:25.310 --> 00:11:26.770
So this is the magic stuff here.

00:11:26.780 --> 00:11:28.600
This class is a pure Ruby class.

00:11:28.600 --> 00:11:31.610
It doesn't iterate for
NSObject or stuff like that.

00:11:31.630 --> 00:11:34.410
So it's a pure Ruby class,
and the magic is that we're going to

00:11:34.510 --> 00:11:39.850
pass instance of that class across
the bridge to the ImageKit framework.

00:11:40.110 --> 00:11:43.920
And the bridge is going to create
proxy objects for each instance of

00:11:44.020 --> 00:11:48.860
that class and pass proxy objects
back to the Objective-C underlying

00:11:48.860 --> 00:11:51.650
stuff like ImageKit.

00:11:51.830 --> 00:11:55.900
And ImageKit is going sometimes to
call back methods of the proxy object,

00:11:55.900 --> 00:12:00.700
and the bridge is just going to forward
everything back to the Ruby class.

00:12:00.800 --> 00:12:03.610
So here these are...

00:12:04.610 --> 00:12:08.090
These are three callbacks that
will be called by ImageKit.

00:12:08.090 --> 00:12:10.940
And here we just returned
an NSImage class,

00:12:11.020 --> 00:12:14.500
an NSImage object based on
the contents of the URL.

00:12:14.500 --> 00:12:17.490
So let's see if it works.

00:12:17.500 --> 00:12:25.810
There we go.

00:12:33.230 --> 00:12:38.230
So I'm just using the
Flickr feed for WWDC tag,

00:12:38.230 --> 00:12:43.920
so all the image tagged with WWDC.

00:12:43.920 --> 00:12:46.190
And it works.

00:12:52.010 --> 00:12:56.380
So we can use a slider to zoom,
stuff like that.

00:12:56.430 --> 00:12:59.670
And it's pretty simple.

00:12:59.670 --> 00:12:59.670
In fact, it's

00:12:59.870 --> 00:13:04.800
I don't have the number of lines,
but I think it's just 18 lines of code,

00:13:04.800 --> 00:13:05.800
so pretty simple.

00:13:05.800 --> 00:13:10.610
So as you can see,
it's pretty easy to glue existing pure

00:13:10.610 --> 00:13:13.960
Ruby code with Objective-C frameworks.

00:13:14.000 --> 00:13:22.060
So in that case, we used the RSS library,
part of the Santa Ruby distribution,

00:13:22.090 --> 00:13:26.350
and we used this new
ImageKit framework and Cocoa,

00:13:26.350 --> 00:13:26.350
of course.

00:13:26.350 --> 00:13:26.350
Thank you.

00:13:30.000 --> 00:13:31.700
Thank you, Laurent.

00:13:31.790 --> 00:13:35.480
So as Laurent demonstrated, I mean,
it feels like building a Cocoa app

00:13:35.480 --> 00:13:37.670
only with a scripting language.

00:13:38.870 --> 00:13:40.790
So the state of the bridges.

00:13:40.930 --> 00:13:44.090
This is kind of where are they,
where are we going.

00:13:44.180 --> 00:13:47.920
So the bridges, they all allow mixing of
Objective-C and scripted code.

00:13:47.920 --> 00:13:52.290
And this really gives you the freedom to
prototype and implement in the scripting

00:13:52.290 --> 00:13:55.680
language using the rapid application
development patterns that I mentioned,

00:13:55.680 --> 00:13:59.760
and then turn around and optimize
performance-critical pieces by porting

00:13:59.760 --> 00:14:02.340
those pieces to Objective-C if necessary.

00:14:03.080 --> 00:14:05.480
And you can use these to
build production quality apps.

00:14:05.560 --> 00:14:09.540
There's applications today that
ship written with Python against

00:14:09.540 --> 00:14:12.280
Cocoa that you could buy in
a box at the Apple Store,

00:14:12.280 --> 00:14:14.580
and you'll never know the difference.

00:14:14.580 --> 00:14:17.600
Same thing with Ruby Cocoa.

00:14:17.600 --> 00:14:21.680
And the PyOpC bridge at least,
and I'm now getting reports

00:14:21.680 --> 00:14:24.610
about Ruby Cocoa as well,
has been used in a lot

00:14:24.610 --> 00:14:25.420
of research facilities.

00:14:25.420 --> 00:14:28.940
Lawrence Livermore,
Sandia Labs both use it.

00:14:29.000 --> 00:14:35.050
Trading houses, like I mentioned before,
engineering groups, both Pixar and Apple,

00:14:35.080 --> 00:14:38.510
have used PyOpC quite a bit.

00:14:38.660 --> 00:14:42.840
And the unfortunate part about the
state of these bridges on Tiger is

00:14:42.840 --> 00:14:46.350
that to maintain compatibility and
make sure that a software update or

00:14:46.350 --> 00:14:50.230
something else doesn't break you,
you have to embed the runtime,

00:14:50.280 --> 00:14:53.080
the bridge and the language
interpreter in your dot app.

00:14:53.080 --> 00:14:56.900
It's about a, I think, what, six,
eight meg penalty, something like that.

00:14:56.960 --> 00:14:59.310
And that's really what we're focusing on.

00:14:59.320 --> 00:15:00.120
We want to fix that.

00:15:00.180 --> 00:15:02.150
We don't want you to have
to drag that garbage along.

00:15:02.160 --> 00:15:04.750
And we want to make sure that if
we ship a software update with,

00:15:04.780 --> 00:15:08.550
say, a security fix for something,
then your app takes advantage of it.

00:15:12.140 --> 00:15:17.080
So Cocoa and Objective-C really
provide the most natural point

00:15:17.260 --> 00:15:19.070
for doing this kind of bridging.

00:15:19.070 --> 00:15:22.600
And that's largely because most
of your scripting languages,

00:15:22.610 --> 00:15:24.900
even if they're not object-oriented,
they have a very

00:15:24.910 --> 00:15:26.790
object-oriented feel about them.

00:15:26.980 --> 00:15:30.800
You're always dealing with some
random thing that you put a dot

00:15:30.800 --> 00:15:33.020
and then tell it to do something.

00:15:33.280 --> 00:15:37.660
And on the other end of the bridge,
the Objective-C runtime provides

00:15:37.670 --> 00:15:40.940
all this metadata at runtime,
live metadata,

00:15:41.160 --> 00:15:45.710
that describes all the APIs on
all the classes and the instance

00:15:45.710 --> 00:15:47.320
variables and everything else.

00:15:47.320 --> 00:15:50.970
And now with Objective-C 2.0,
there's actually a lot more

00:15:50.970 --> 00:15:55.150
metadata available about things
like properties and stuff like that.

00:15:55.430 --> 00:15:59.770
And this metadata is rich enough
that we can handle most of the

00:15:59.830 --> 00:16:04.550
APIs provided in the frameworks
automatically in the bridges themselves.

00:16:05.980 --> 00:16:10.030
The one key point and the first
thing you run into is method names.

00:16:10.150 --> 00:16:12.850
How do you map a method name,
which has a bunch of colons in it,

00:16:12.890 --> 00:16:15.900
into a language that doesn't
allow colons and names?

00:16:15.900 --> 00:16:18.820
We choose a very simple rule.

00:16:19.040 --> 00:16:21.560
This is what PyOpc's
been doing for 14 years,

00:16:21.620 --> 00:16:23.900
12 years, 12 years, whatever.

00:16:23.900 --> 00:16:27.030
And that's every colon
in the method name,

00:16:27.030 --> 00:16:30.510
in the selector name,
you simply substitute an

00:16:30.510 --> 00:16:32.630
underscore and you're done.

00:16:33.900 --> 00:16:35.900
There's no ambiguity,
there's no exceptions.

00:16:35.900 --> 00:16:39.900
We don't have any magic mapping files,
which the Java Bridge did,

00:16:39.900 --> 00:16:41.900
or special cases.

00:16:41.900 --> 00:16:45.810
Actually, in Laurent's demo,
he demonstrated a version of

00:16:45.810 --> 00:16:49.200
Ruby Cocoa that has a convenience
mapping in it where you can

00:16:49.200 --> 00:16:49.900
drop the last underscore.

00:16:49.900 --> 00:16:52.660
That won't be supported out
of the box in Leopard because,

00:16:52.660 --> 00:16:55.070
again,
this is about forward compatibility and

00:16:55.140 --> 00:16:57.900
really ensuring a consistent environment.

00:16:57.900 --> 00:16:59.980
At the same time,
we're not going to actively

00:16:59.980 --> 00:17:02.840
prevent anyone from adding
those kinds of dispatchers in.

00:17:05.960 --> 00:17:10.170
So when you talk about methods,
there's more to them than just the name.

00:17:10.200 --> 00:17:11.890
There's also the signature.

00:17:11.950 --> 00:17:16.420
And the signature-- well,
in a scripting language,

00:17:16.450 --> 00:17:20.500
typically there's no types
that are really declared.

00:17:20.520 --> 00:17:24.140
I mean, sure, there's types when you
get under the covers.

00:17:24.250 --> 00:17:26.190
But you don't say, hey,
I'm going to take a string

00:17:26.200 --> 00:17:30.600
argument and then an integer
argument and then an NS table view.

00:17:30.960 --> 00:17:33.800
Which is problematic
because in Objective-C,

00:17:33.860 --> 00:17:37.270
method arguments very
much have explicit types.

00:17:37.520 --> 00:17:39.670
Now the bridge,
what it generally does is it will

00:17:39.670 --> 00:17:44.840
try to derive the typing information
from the superclass or from context.

00:17:44.930 --> 00:17:48.190
And what that means is that if you
override a method in subclasses,

00:17:48.200 --> 00:17:51.040
because we support
subclassing in both bridges,

00:17:51.100 --> 00:17:56.840
then the fact that that method takes
an integer and an ID will be grabbed

00:17:56.850 --> 00:17:59.900
from the superclass if at all possible.

00:17:59.970 --> 00:18:04.750
Or if it's a delegate method or protocol,
it'll grab it from that.

00:18:05.410 --> 00:18:08.950
The problem though is that
that's not always enough.

00:18:09.010 --> 00:18:11.930
So this is the one area where
things on the script side of the

00:18:11.950 --> 00:18:14.190
bridge get a little different.

00:18:14.800 --> 00:18:21.000
The bridges provide hints for
specifying this additional metadata.

00:18:21.060 --> 00:18:25.460
In the Python bridge, PyOpc,
you have @ decorators.

00:18:25.480 --> 00:18:27.740
We're using the decorators
from Python 2.4.

00:18:27.880 --> 00:18:32.820
So if you say @ typed accessor with an i,
that's going to make a method

00:18:32.820 --> 00:18:36.080
on the Objective-C side that
takes an integer as an argument,

00:18:36.110 --> 00:18:37.680
and it's a true integer.

00:18:37.960 --> 00:18:44.180
Or it's going to return an integer
if you wanted to just have quantity.

00:18:45.200 --> 00:18:48.780
At class method is used to declare
class methods on the Python side,

00:18:48.780 --> 00:18:51.700
because Python doesn't
have class methods.

00:18:51.830 --> 00:18:55.920
Likewise in Ruby, Ruby has the,
can't remember the name,

00:18:55.970 --> 00:18:58.510
these decorators for the declarations.

00:18:58.590 --> 00:19:04.730
So you can say flag auto update
enabled is a KVC/KVO compatible

00:19:05.000 --> 00:19:07.620
attribute of this class.

00:19:08.710 --> 00:19:13.410
So now there are still some obstacles,
because really Objective-C is just

00:19:13.410 --> 00:19:15.910
ANSI C with a bunch of extensions.

00:19:16.060 --> 00:19:18.240
And the C bits are really hard.

00:19:18.330 --> 00:19:21.920
Effectively, C is a macro assembler,
so you get to deal with

00:19:21.920 --> 00:19:24.020
grunging through memory.

00:19:25.760 --> 00:19:29.050
Yes, yay, except for when it bites you.

00:19:29.270 --> 00:19:31.890
So things like NSErrorPointerPointer.

00:19:32.000 --> 00:19:34.210
Well, that in and of itself
isn't that hard to handle,

00:19:34.250 --> 00:19:36.650
except for the fact that
in some cases it goes out.

00:19:36.660 --> 00:19:38.700
Some cases, the things like that go in.

00:19:38.700 --> 00:19:40.110
Sometimes they go in and out.

00:19:40.130 --> 00:19:44.750
And there's not a consistent amount of
metadata in the runtime to know that.

00:19:45.200 --> 00:19:48.240
Likewise,
you have sometimes paired arguments

00:19:48.710 --> 00:19:52.280
where one argument tells you how to
properly deal with the other one.

00:19:52.280 --> 00:19:54.990
If you have, like, say,
a float pointer with a count and you

00:19:55.100 --> 00:19:58.030
run off the end of that or make a guess,
your program's going to blow up.

00:19:58.040 --> 00:19:59.400
Memory management.

00:19:59.400 --> 00:20:02.800
So Objective-C has retained release,
auto-release.

00:20:02.800 --> 00:20:06.480
The scripting languages are
typically garbage collected.

00:20:06.490 --> 00:20:08.510
Python has reference counting.

00:20:08.550 --> 00:20:10.660
Ruby has a garbage collector.

00:20:10.660 --> 00:20:13.800
And that can be a challenge.

00:20:14.420 --> 00:20:15.970
And so are exceptions.

00:20:16.180 --> 00:20:20.180
Every language seems to feel the
need to invent a new exception model.

00:20:20.270 --> 00:20:23.360
And as we cross the bridge,
what we actually do is convert the

00:20:23.360 --> 00:20:25.580
exceptions between the two languages.

00:20:25.580 --> 00:20:29.640
So if you have an NSException raised in
Objective-C and it passes through Ruby,

00:20:29.680 --> 00:20:31.580
it's going to be a Ruby exception.

00:20:31.580 --> 00:20:34.470
Then as it goes back into Objective-C,
it'll be turned back into the

00:20:34.470 --> 00:20:35.970
same NSException as before.

00:20:35.980 --> 00:20:39.980
On the memory management front,
conveniently reference

00:20:40.060 --> 00:20:42.180
counting is a natural match.

00:20:42.180 --> 00:20:43.360
So the bridges actually take care
of all the rest of the stuff.

00:20:43.360 --> 00:20:44.730
So it's a nice little feature
that you can actually take care

00:20:44.730 --> 00:20:46.050
of all the retained release,
auto-release for you.

00:20:46.160 --> 00:20:51.220
Frankly, programming in Python against
Objective-C or Ruby against

00:20:51.220 --> 00:20:55.550
Objective-C feels a lot
like using Objective-C 2.0.

00:20:55.940 --> 00:21:00.900
There's also other kinds of arguments
that the metadata won't describe.

00:21:00.900 --> 00:21:03.770
And of course,
what about garbage collection?

00:21:04.070 --> 00:21:08.940
Well, neither bridge uses the
garbage collector at this time.

00:21:08.990 --> 00:21:12.450
We're investigating ways
of integrating that.

00:21:12.700 --> 00:21:15.180
But frankly, because the bridge has
managed routine release,

00:21:15.180 --> 00:21:17.870
auto-release for you,
when you're on the scripting

00:21:17.870 --> 00:21:21.020
language side of the bridge,
you really don't miss it.

00:21:21.120 --> 00:21:22.290
When you're on the other
side of the bridge,

00:21:22.340 --> 00:21:25.160
of course, writing your own code,
you will need to deal with retain,

00:21:25.160 --> 00:21:26.980
release, auto-release for now.

00:21:28.300 --> 00:21:31.610
So clearing out these obstacles,
what we're adding is a big

00:21:31.920 --> 00:21:35.970
chunk of metadata to describe
all these difficult bits.

00:21:36.250 --> 00:21:39.520
And the metadata will be loaded
by the bridges at runtime.

00:21:39.590 --> 00:21:42.820
So we're moving away from some of
the static wrapping methodologies

00:21:42.820 --> 00:21:47.660
that were used in PyOpc and moving
to an automatic system that will

00:21:47.660 --> 00:21:51.540
allow the metadata to describe,
for example, which methods return a

00:21:51.540 --> 00:21:54.420
Boolean versus a character,
which is critical to Ruby and

00:21:54.420 --> 00:21:55.800
very convenient for Python.

00:21:55.800 --> 00:21:59.510
It'll also include other information,
because there's a bunch of symbols in

00:21:59.510 --> 00:22:02.830
your frameworks that don't get exported,
like your sharp defines,

00:22:02.830 --> 00:22:04.160
your type def and nums.

00:22:04.880 --> 00:22:08.240
Functions,
they'll be exported as a symbol,

00:22:08.240 --> 00:22:10.050
but they don't have a
signature for knowing what

00:22:10.050 --> 00:22:11.220
types of arguments they take.

00:22:11.280 --> 00:22:14.780
Sharp defines,
this is again going to be read when your

00:22:14.790 --> 00:22:16.810
script or your application starts up.

00:22:16.840 --> 00:22:20.530
We are, of course,
looking to make that as fast as possible.

00:22:22.930 --> 00:22:27.260
So there's some additional
features to these bridges.

00:22:27.290 --> 00:22:30.150
There's native types in
all of the languages,

00:22:30.150 --> 00:22:35.580
Objective-C, in Python and in Ruby,
that really are the same basic

00:22:35.580 --> 00:22:37.380
underlying data structure,
even if they have a

00:22:37.390 --> 00:22:38.420
little bit different APIs.

00:22:38.420 --> 00:22:43.500
And to really make the languages usable,
you want the Objective-C types

00:22:43.500 --> 00:22:45.140
to fit well with that.

00:22:45.300 --> 00:22:50.310
So the bridges do a no-cost or a
very low-cost sort of bridging-like

00:22:50.410 --> 00:22:53.420
core foundation to the foundation.

00:22:53.420 --> 00:22:57.130
And what this results in is that
you can write code like this,

00:22:57.130 --> 00:23:00.840
where you're saying,
"For some bundle..." I see

00:23:00.840 --> 00:23:03.360
my "for" was capitalized.

00:23:03.450 --> 00:23:04.420
Don't do that.

00:23:04.420 --> 00:23:07.380
So, "For a bundle in
NSFramework.allFrameworks."

00:23:07.440 --> 00:23:08.420
That will enable you to do that.

00:23:08.420 --> 00:23:12.420
So you can enumerate the array,
the NSArray returned by all frameworks,

00:23:12.420 --> 00:23:16.420
and the second line is just going to
print out the bundle path of each one.

00:23:16.700 --> 00:23:20.420
Likewise in Ruby, using the block syntax,
there's enumeration of arrays.

00:23:20.420 --> 00:23:25.100
And this extends also
for some other types.

00:23:25.400 --> 00:23:30.300
nd we'll talk about the key
value coding and observing.

00:23:30.610 --> 00:23:37.280
Supporting key value coding and observing
is critical to making a high-fidelity

00:23:37.280 --> 00:23:40.370
Cocoa development experience.

00:23:40.370 --> 00:23:43.250
It's the only way that
Cocoa bindings will work,

00:23:43.360 --> 00:23:44.400
for example.

00:23:44.400 --> 00:23:49.400
Both of the bridges support automatic
key value coding and observing,

00:23:49.400 --> 00:23:53.540
and they do so at assignment as
opposed to having to call the methods,

00:23:53.540 --> 00:23:56.400
so again, very Objective-C 2.0-like.

00:23:56.630 --> 00:24:01.230
These lines of code are all equivalent,
so if you just do

00:24:01.230 --> 00:24:05.640
myManagedObject.someAttribute
= something,

00:24:05.640 --> 00:24:08.590
that's going to trigger KVC/KVO.

00:24:09.320 --> 00:24:13.000
Likewise, KVO is automatic,
so even in a non-managed object,

00:24:13.000 --> 00:24:16.530
making an assignment to an
instance variable is going to cause

00:24:16.700 --> 00:24:18.760
the KVO notifications to fire.

00:24:18.760 --> 00:24:23.790
This actually greatly reduces the number
of lines of code you end up writing too.

00:24:25.330 --> 00:24:28.560
So, there's also declaring
instance variables.

00:24:28.750 --> 00:24:31.280
You saw earlier how Ruby you
could declare an instance

00:24:31.280 --> 00:24:33.200
variable to be a KVC variable.

00:24:33.200 --> 00:24:38.540
In PyOpc Python,
there's a function on the Opc

00:24:38.590 --> 00:24:41.300
module which allows you to
create an instance variable,

00:24:41.300 --> 00:24:44.420
and this actually,
when the class is dynamically created,

00:24:44.420 --> 00:24:48.620
will create a slot for
a float named count.

00:24:49.270 --> 00:24:53.390
And this will behave the same
as using a typed accessor,

00:24:53.450 --> 00:24:55.400
if that's the way you want to go.

00:24:56.510 --> 00:25:00.660
Of course, a lot fewer lines of code.

00:25:00.660 --> 00:25:01.910
So performance.

00:25:01.960 --> 00:25:03.640
You know,
one of the things that always comes

00:25:03.740 --> 00:25:07.220
up whenever I've wanted to use
a bridge on a project is someone

00:25:07.220 --> 00:25:09.930
starts whining about the performance.

00:25:10.310 --> 00:25:13.060
And the reality is that
in most of our apps,

00:25:13.160 --> 00:25:17.900
Cocoa is what's really doing
the heavy lifting for us.

00:25:17.930 --> 00:25:22.670
Your code generally is not going
to be the one that's being executed

00:25:22.670 --> 00:25:26.640
all the time when you're doing like
Core Data filling in an S table view.

00:25:26.930 --> 00:25:31.540
Now, there is of course going to be
random algorithms or whatever

00:25:31.540 --> 00:25:35.420
other performance-intensive
code you might write,

00:25:35.420 --> 00:25:39.560
and you can easily port that
to Objective-C as needed,

00:25:39.560 --> 00:25:43.320
with the caveat being of course that you
did the performance analysis first to

00:25:43.320 --> 00:25:45.480
make sure you're not wasting your time.

00:25:46.170 --> 00:25:49.800
There is a cost associated
with crossing the bridge.

00:25:49.800 --> 00:25:53.420
Like I said before, exception bridging,
it exists, it happens.

00:25:53.450 --> 00:25:57.730
It's expensive simply because setting up
and tearing down Objective-C exception

00:25:57.730 --> 00:25:59.650
handling blocks is expensive.

00:25:59.800 --> 00:26:03.000
The argument return values
are boxed or converted,

00:26:03.000 --> 00:26:07.030
meaning that you can't just
pass a random integer into,

00:26:07.090 --> 00:26:09.800
say, Python because it's gonna blow up.

00:26:09.800 --> 00:26:13.160
So it needs to be turned into a
Python integer or a Ruby integer,

00:26:13.190 --> 00:26:14.310
et cetera.

00:26:14.390 --> 00:26:18.020
And you really just want to avoid
tight performance-sensitive loops that

00:26:18.020 --> 00:26:19.910
are constantly crossing the bridge.

00:26:20.130 --> 00:26:24.020
If you just kind of keep that in mind,
I don't think you're going to have a lot

00:26:24.020 --> 00:26:25.900
of problems with performance on these.

00:26:25.900 --> 00:26:27.900
It just really isn't that big of a deal.

00:26:27.900 --> 00:26:33.810
So I wanted to do a quick tour of PyEbc.

00:26:39.480 --> 00:26:46.170
So this is actually a project that
I started not terribly long ago.

00:26:46.290 --> 00:26:48.660
We have the dedicated network builds,
and we're playing with

00:26:48.660 --> 00:26:49.680
visualization ideas.

00:26:49.780 --> 00:26:54.270
And I'm going to run it just so you can
see the god-awful hideous colors that

00:26:54.280 --> 00:26:57.120
I have right now for testing purposes.

00:26:57.170 --> 00:27:02.250
So you can see it's doing stuff, yay.

00:27:02.540 --> 00:27:05.650
But what this is doing under the
covers is actually pretty interesting,

00:27:05.690 --> 00:27:10.220
because it's listening on a UDP port,
waiting for notifications to

00:27:10.220 --> 00:27:11.810
come in from random machines.

00:27:11.940 --> 00:27:15.060
Then it's taking that data,
tearing it apart into a dictionary,

00:27:15.060 --> 00:27:18.780
throwing the dictionary over the
wall to a Core Data in-memory store,

00:27:18.930 --> 00:27:21.100
saving everything in that,
which then triggers a

00:27:21.100 --> 00:27:24.370
context-did-save notification,
which gets listened to,

00:27:24.370 --> 00:27:26.150
which then updates the view.

00:27:27.800 --> 00:27:34.870
So the reason why I actually did
this as a PyOpc app is because

00:27:34.870 --> 00:27:36.400
I could take advantage of Twisted.

00:27:36.450 --> 00:27:40.720
Twisted is a third-party network
application development environment.

00:27:40.890 --> 00:27:43.450
It's like the AppKit for network apps.

00:27:43.560 --> 00:27:45.140
It's amazing.

00:27:45.220 --> 00:27:47.560
And it saved me a huge amount of code.

00:27:47.560 --> 00:27:50.600
I don't know how many of you have
ever done network programming,

00:27:50.610 --> 00:27:56.720
but dealing with TCP sockets and
UDP datagrams is usually a real pain.

00:27:57.580 --> 00:28:03.190
But this right here is all the code
it took to set that listener up.

00:28:03.900 --> 00:28:11.640
And this is using a subclass
of a visualization protocol.

00:28:12.320 --> 00:28:19.540
This is the entire code for... Well,
here, let me just delete the

00:28:19.760 --> 00:28:21.380
code we don't need.

00:28:23.190 --> 00:28:25.510
Yeah, my tab width is hosed,
so I'm not going to edit

00:28:25.510 --> 00:28:27.100
anything or else it blows up.

00:28:27.170 --> 00:28:28.320
Yeah, here's a hint.

00:28:28.400 --> 00:28:29.400
You saw it in Laurent's demo.

00:28:29.400 --> 00:28:30.720
You've seen it now in mine.

00:28:30.810 --> 00:28:34.340
Turn off tabs in Xcode before you
start dealing with scripting languages.

00:28:34.400 --> 00:28:36.330
And somebody please
file a bug against that,

00:28:36.410 --> 00:28:38.900
because I need to make that a default.

00:28:39.010 --> 00:28:43.120
That's the biggest source
of problem with all this.

00:28:43.160 --> 00:28:48.050
So, you know, this is really hard in C.

00:28:48.520 --> 00:28:50.790
This is hard in CF socket,
but you see how much code

00:28:50.790 --> 00:28:52.100
I've reduced by using this.

00:28:52.100 --> 00:28:55.930
And then you'll see in my project,
I'm mixing and matching

00:28:55.930 --> 00:28:59.130
Objective-C and Python at whim.

00:28:59.140 --> 00:29:03.090
For example, I've got one managed object
as an Objective-C object,

00:29:03.090 --> 00:29:05.860
another managed object
as a Python object.

00:29:05.860 --> 00:29:09.620
My app delegate is a random Python class.

00:29:09.620 --> 00:29:12.360
And let me show you a couple of
interesting features in here.

00:29:13.620 --> 00:29:16.310
This right here

00:29:16.510 --> 00:29:18.570
What's actually happening
is when Python comes up,

00:29:18.620 --> 00:29:21.030
because we've got this wonderful
dynamic runtime that likes

00:29:21.070 --> 00:29:24.240
to compose things on the fly,
I'm going and I'm reading the

00:29:24.240 --> 00:29:28.380
specification of the class
AppDelegate from the nib file.

00:29:28.380 --> 00:29:31.830
It's figuring out the superclass,
the outlets, the actions,

00:29:31.850 --> 00:29:36.060
and then Objective-C or PyOpC,
using this auto-base class notation,

00:29:36.060 --> 00:29:39.050
is actually defining that class on
the fly with all the appropriate

00:29:39.050 --> 00:29:40.750
outlets and instance variables.

00:29:40.760 --> 00:29:43.700
So if I go into Interface Builder
and I make a change there,

00:29:43.700 --> 00:29:45.900
I don't have to sync anything in my code.

00:29:46.600 --> 00:29:48.520
It just works.

00:29:49.410 --> 00:29:55.010
You'll also see things like this where,
you know, on the one hand,

00:29:55.080 --> 00:29:57.380
I wanted to put a
debugging thing in here,

00:29:57.380 --> 00:30:01.300
fake it, man,
and I wanted to run an external program.

00:30:01.530 --> 00:30:05.610
Well, the fastest way to check for
a program is to use this,

00:30:05.850 --> 00:30:10.260
but the fastest way to
launch one was to use nstask.

00:30:10.480 --> 00:30:13.490
So you really get to mix
and match whatever tools you

00:30:13.490 --> 00:30:15.190
need to get your job done.

00:30:16.030 --> 00:30:18.940
Let's see.

00:30:19.040 --> 00:30:22.900
This is interesting just
in that if we go down here,

00:30:23.340 --> 00:30:27.480
yes, this line right here.

00:30:28.520 --> 00:30:30.640
This code here.

00:30:30.710 --> 00:30:36.720
So whenever a machine notifies my
computer and it goes off and it says,

00:30:36.780 --> 00:30:40.390
hey, I've just started a job,
I need to create a new job entity

00:30:40.420 --> 00:30:42.500
in a managed object context.

00:30:42.630 --> 00:30:48.230
And it's just a matter of doing the
typical Objective-C thing of this.

00:30:48.400 --> 00:30:52.470
I'll admit an entity,
shove it in a managed object context,

00:30:52.470 --> 00:30:56.110
but then I can turn around and
do basic assignments to do all

00:30:56.120 --> 00:30:58.250
the setting of the attributes.

00:30:58.450 --> 00:31:03.190
And I can use this little
chunk of code to do basically

00:31:03.340 --> 00:31:05.770
components joined by string,
like on an NSString,

00:31:05.780 --> 00:31:06.930
just a lot less code.

00:31:06.940 --> 00:31:12.380
You'll also see things like, you know,
mutable set value for key,

00:31:12.380 --> 00:31:15.050
all the proxying there works correctly,
everything else.

00:31:15.140 --> 00:31:19.140
So in cases where there's
an NSError pointer pointer,

00:31:19.140 --> 00:31:26.060
what PyOpc actually does is it
returns the error as a tuple.

00:31:26.060 --> 00:31:28.940
So you get the return value and
the error as one return value.

00:31:28.940 --> 00:31:33.730
There's a notation so you can have
it not generate the error at all

00:31:33.820 --> 00:31:36.690
as an optimization if necessary.

00:31:37.820 --> 00:31:40.770
Things like perform selector, you know,
it just works.

00:31:40.770 --> 00:31:42.130
And that's the whole point of this.

00:31:42.140 --> 00:31:45.970
And, you know, I estimate that this,
using this really probably shaved about

00:31:45.970 --> 00:31:49.570
half my development time off this and
freed me up to really experiment with it,

00:31:49.580 --> 00:31:51.250
as you can see in my color scheme.

00:31:51.250 --> 00:31:53.780
So back to slides, please.

00:31:59.500 --> 00:32:03.160
So Apple has really embraced the Ruby,
Cocoa and the PyOpc projects to

00:32:03.160 --> 00:32:08.260
make Ruby and Python first-class
development languages for Cocoa.

00:32:09.830 --> 00:32:13.000
And we are working very
closely with the community.

00:32:13.000 --> 00:32:15.960
The primary developers are actually
here in the audience today.

00:32:15.970 --> 00:32:19.260
And I wanted to get through this fairly
quickly because I imagine there's

00:32:19.310 --> 00:32:20.970
going to be a handful of questions.

00:32:21.200 --> 00:32:23.820
We've already posted some changes back.

00:32:23.930 --> 00:32:26.780
The changes to the PyOpC bridge
are being hosted in a private

00:32:26.790 --> 00:32:30.510
repository right now until we can
get permission to open it up a bit.

00:32:30.620 --> 00:32:33.410
The Ruby Cocoa changes have actually
been changes that haven't really been,

00:32:33.570 --> 00:32:36.190
you know,
in violation of the Leopard NDA.

00:32:36.280 --> 00:32:40.390
So you've seen a lot of activity in
the public community on that front.

00:32:41.290 --> 00:32:46.310
On the Leopard DVD,
most of the batteries are there.

00:32:46.490 --> 00:32:50.600
For Ruby Cocoa, the bridge,
the interpreter is included.

00:32:50.740 --> 00:32:52.510
You get the Xcode templates,
there's some examples,

00:32:52.510 --> 00:32:53.390
there's documentation.

00:32:53.400 --> 00:32:57.280
For PyObc,
we got the bridge and the interpreter in,

00:32:57.400 --> 00:32:59.400
but the templates,
examples and documentation

00:32:59.400 --> 00:33:01.400
is not included yet,
just because of the way

00:33:01.400 --> 00:33:03.400
the project was structured.

00:33:03.400 --> 00:33:04.350
It's being cleaned up.

00:33:04.410 --> 00:33:09.340
However, you can find all those online,
and they work fine on Leopard.

00:33:09.400 --> 00:33:15.290
That project I just showed there was
just a standard Xcode PyObc project

00:33:15.540 --> 00:33:21.210
template that I instantiated from the,
grabbing the template from the website.

00:33:22.010 --> 00:33:27.620
And for more information,
you've got pyobc.sourceforge.net,

00:33:27.740 --> 00:33:29.550
you've got the
Ruby Cocoa Source Forge Project,

00:33:29.630 --> 00:33:32.140
you've got rubycocoa.com,
which is awesome.

00:33:32.140 --> 00:33:36.030
It has a huge write-up of
Ruby Cocoa and sort of the philosophy

00:33:36.100 --> 00:33:40.450
of implementation behind it,
history of Next Step and AppKit and

00:33:40.450 --> 00:33:44.090
all kinds of great information,
including even some Pyobc stuff.
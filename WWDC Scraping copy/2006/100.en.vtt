WEBVTT

00:00:10.220 --> 00:00:10.660
Good morning.

00:00:10.660 --> 00:00:13.780
Welcome to the Resolution
Independence on Mac OS X session.

00:00:13.780 --> 00:00:17.700
I like to call this feature
Resolution Independence,

00:00:17.700 --> 00:00:20.440
but you'll probably catch me
calling it High DPI occasionally.

00:00:20.440 --> 00:00:23.450
So if you hear High DPI,
I'm talking Resolution Independence.

00:00:23.460 --> 00:00:25.830
It just often gets confused
in my head as I say it.

00:00:25.890 --> 00:00:30.180
So the purpose of this session is
to tell you everything you need

00:00:30.330 --> 00:00:35.240
to do to make your application
resolution independent on Mac OS X.

00:00:35.240 --> 00:00:39.490
But before I go into those details,
I want to tell you why this is important.

00:00:42.010 --> 00:00:46.730
So lots of the technology industries
that we're used to constantly make

00:00:46.890 --> 00:00:50.400
products that are bigger and better.

00:00:50.560 --> 00:00:55.320
Your TVs are moving towards HDTV,
DVDs moving towards Blu-ray,

00:00:55.430 --> 00:00:59.840
mass storage went from megabytes to
gigabytes and terabytes and beyond.

00:00:59.860 --> 00:01:03.210
And displays really aren't any different.

00:01:03.480 --> 00:01:05.720
Every couple of years,
Apple ships another machine

00:01:05.830 --> 00:01:09.400
with a higher resolution
display than it has in the past.

00:01:09.490 --> 00:01:11.400
And we expect this trend to continue.

00:01:11.430 --> 00:01:14.140
And therefore,
we are telling you this year that

00:01:14.140 --> 00:01:18.500
we need your applications to be
resolution independent by 2008.

00:01:21.170 --> 00:01:24.230
So let's talk a little bit about
what resolution independence means.

00:01:24.350 --> 00:01:27.920
So this is a screenshot
from a 23-inch display.

00:01:27.930 --> 00:01:31.410
I don't remember the actual pixel
resolution on each dimension.

00:01:31.480 --> 00:01:33.280
But when you use this
23-inch display today,

00:01:33.280 --> 00:01:35.020
it's running at 100 dots per inch.

00:01:35.150 --> 00:01:37.600
Looks pretty darn good, very usable.

00:01:37.620 --> 00:01:40.470
If Apple decided to
ship a 23-inch display,

00:01:40.470 --> 00:01:45.280
however, that used 200 dots per inch,
you'd get something like this.

00:01:45.300 --> 00:01:48.490
And that may look like a lot of
awesome screen real estate to you,

00:01:48.590 --> 00:01:50.920
but in reality, it's not very usable.

00:01:50.930 --> 00:01:51.090
Right?

00:01:51.160 --> 00:01:52.510
The text is way too small.

00:01:52.520 --> 00:01:54.100
The graphics are way too small.

00:01:54.100 --> 00:01:57.960
It's just impossible to get
done what you need to get done.

00:01:59.000 --> 00:02:04.540
So what we really want to do is
make this text on the display

00:02:04.540 --> 00:02:06.870
and the images on the display,
instead of being smaller,

00:02:06.870 --> 00:02:09.450
we want to use those added
pixels to make them crisper.

00:02:09.540 --> 00:02:12.780
So let's zoom in on this top left corner.

00:02:13.000 --> 00:02:15.650
of the display and take a
look at how it looks today.

00:02:15.800 --> 00:02:18.060
So this is a screenshot of text edit.

00:02:18.060 --> 00:02:22.870
This was an actual screenshot of a
very small portion of the display.

00:02:23.040 --> 00:02:24.950
And as you can see, it's kind of grainy,
right?

00:02:25.030 --> 00:02:26.800
At a normal viewing distance,
it looks pretty good.

00:02:26.800 --> 00:02:29.600
But when you scrutinize the text,
you can see that it's anti-aliased.

00:02:29.700 --> 00:02:31.940
You can tell we're using
bitmap artwork for the various

00:02:31.960 --> 00:02:33.650
system controls and so forth.

00:02:33.760 --> 00:02:37.290
And if we actually applied
more pixels to this image,

00:02:37.290 --> 00:02:40.330
we can make a much crisper and
sharper looking user interface,

00:02:40.330 --> 00:02:41.490
something like this.

00:02:41.490 --> 00:02:41.970
Right?

00:02:41.970 --> 00:02:45.790
So you can see we've got crisper text,
we've got crisper system controls,

00:02:45.910 --> 00:02:47.920
and it looks just generally really,
really good.

00:02:48.060 --> 00:02:49.400
So again, this is now.

00:02:50.870 --> 00:02:54.010
This is how it is today,
and this is how it

00:02:54.110 --> 00:02:54.700
could be in the future.

00:02:58.290 --> 00:03:01.740
So let me show you resolution
independence in action.

00:03:01.780 --> 00:03:05.870
Can we switch over to the
Intel demo machine real quick?

00:03:09.980 --> 00:03:14.370
Okay, so this is the leopard seed
with nothing special on it.

00:03:14.530 --> 00:03:20.200
Now, we don't actually have a
high resolution display here.

00:03:20.300 --> 00:03:25.160
In order to demo resolution independence,
you have to deal with a little bit of,

00:03:25.290 --> 00:03:26.800
I don't want to call
it smoke and mirrors,

00:03:26.800 --> 00:03:28.000
but it's essentially smoke and mirrors.

00:03:28.000 --> 00:03:30.200
I'm not going to give you
a high resolution display,

00:03:30.200 --> 00:03:32.010
but I'm going to make the
system act as though you've

00:03:32.080 --> 00:03:33.400
got a high resolution display.

00:03:33.400 --> 00:03:37.010
In order to make crisper text
and graphics in a given window,

00:03:37.010 --> 00:03:39.840
we need to put more
pixels in those windows.

00:03:39.840 --> 00:03:43.430
So we've got this concept
of a scale factor.

00:03:43.440 --> 00:03:47.500
The scale factor is the ratio of the
pixels across a certain dimension

00:03:47.500 --> 00:03:52.000
of a window on a high-res display
relative to a normal resolution display.

00:03:52.000 --> 00:03:55.840
So if your display has twice as many
pixels horizontally and vertically,

00:03:55.860 --> 00:03:58.200
we'd call that a 2.0 scale factor.

00:03:58.200 --> 00:04:04.600
So Leopards allows you to set a
scale factor via Quartz Debug.

00:04:04.620 --> 00:04:07.860
For those of you that have
used Quartz Debug before,

00:04:07.860 --> 00:04:11.130
this is generally a graphics
test tool that allows you

00:04:11.190 --> 00:04:14.680
to detect redundant drawing,
flushing behaviors that

00:04:14.680 --> 00:04:16.050
are strange and so forth.

00:04:16.080 --> 00:04:19.780
But they added something specific
for resolution independence for us.

00:04:19.780 --> 00:04:22.590
In the Tools menu,
there's this Show User Interface

00:04:22.680 --> 00:04:23.860
Resolution item.

00:04:23.860 --> 00:04:27.220
You choose that,
and you get another panel.

00:04:27.220 --> 00:04:31.670
This allows you to set the scale
factor for your Leopard boot.

00:04:31.700 --> 00:04:34.260
So right now we're at 1.

00:04:34.260 --> 00:04:35.860
1 is the default scale.

00:04:35.860 --> 00:04:38.020
That's what Mac OS has
traditionally been.

00:04:38.020 --> 00:04:42.260
We can increase the scale factor,
let's say, to something like 3.0,

00:04:42.260 --> 00:04:43.380
and immediately you see a change.

00:04:43.450 --> 00:04:45.040
It might have been kind of
hard to see because it was down

00:04:45.040 --> 00:04:46.560
at the bottom of the screen,
so let's do it again.

00:04:46.640 --> 00:04:48.060
So look at the bottom of the screen.

00:04:48.150 --> 00:04:48.820
We're at 1.

00:04:48.980 --> 00:04:50.150
The dock is normal sized.

00:04:50.240 --> 00:04:54.300
If we choose scale factor 3.0,
you see the dock immediately gets bigger.

00:04:54.400 --> 00:04:57.500
The dock is one of the few places
on the system that actually react

00:04:57.500 --> 00:04:59.150
live to a scale factor change.

00:04:59.240 --> 00:05:01.880
The dock knows it's trying to
make each of its dock items three

00:05:01.910 --> 00:05:03.330
times as big in height and width.

00:05:03.440 --> 00:05:05.590
It just so happens that there's
not enough space to actually

00:05:05.590 --> 00:05:08.240
make them three times as big,
so the dock shrinks it down a little bit.

00:05:08.320 --> 00:05:12.640
So once we've set the
user interface resolution,

00:05:13.440 --> 00:05:17.960
any application we launch after that
fact adopts that higher scale factor.

00:05:18.080 --> 00:05:23.640
So if I fire up TextEdit,
you can see TextEdit gets really big,

00:05:23.640 --> 00:05:24.320
right?

00:05:24.320 --> 00:05:27.590
The window takes three times as
many pixels in the backing buffer,

00:05:27.590 --> 00:05:30.400
both horizontally and vertically,
that it would have normally.

00:05:30.480 --> 00:05:32.880
And it's still a fully
functional TextEdit.

00:05:32.880 --> 00:05:35.280
You can move through the menus,
choose commands.

00:05:35.280 --> 00:05:39.420
I can copy and paste text and
delete stuff and interact with

00:05:39.420 --> 00:05:42.090
the various controls and so forth.

00:05:42.920 --> 00:05:44.720
Although strangely,
it's not actually working.

00:05:44.720 --> 00:05:48.960
Huh, okay, well,
I'll chalk that up to a leopard bug.

00:05:49.050 --> 00:05:49.460
Um...

00:05:51.620 --> 00:05:53.530
Anyway, otherwise it is a live text edit.

00:05:53.670 --> 00:05:55.180
So clearly we're seeing
some benefit here.

00:05:55.180 --> 00:05:58.290
We've got much crisper,
sharper system controls.

00:05:58.450 --> 00:06:00.080
We've got great looking text.

00:06:00.110 --> 00:06:01.320
Now there are a few bugs.

00:06:01.430 --> 00:06:04.280
If you look over on the right
hand side of the monitor,

00:06:04.290 --> 00:06:06.750
you can see that that scroll bar-- well,
it may be kind of hard to tell

00:06:06.750 --> 00:06:09.430
on this display on the projection
screen-- but that scroll bar is

00:06:09.430 --> 00:06:11.760
still using old low res artwork.

00:06:11.820 --> 00:06:15.060
It's because we're not finished
making Leopard resolution independent.

00:06:15.100 --> 00:06:17.060
So there are a few rough
edges here and there.

00:06:17.060 --> 00:06:22.910
Another example that is hard to see
are these markers in text edit's ruler.

00:06:23.060 --> 00:06:24.960
A few of them are still
a little bit jaggy.

00:06:24.960 --> 00:06:27.960
Again, that's because we don't
have the high res art.

00:06:27.960 --> 00:06:28.940
OK, so that's text edit.

00:06:28.940 --> 00:06:31.490
Let me launch another app.

00:06:34.400 --> 00:06:36.190
OK, so we're looking at Safari.

00:06:36.330 --> 00:06:39.200
And Safari is a little mixed here.

00:06:39.580 --> 00:06:42.980
So you can see that Safari has these
really nice looking window widgets.

00:06:42.980 --> 00:06:44.900
And it's got great looking menu text.

00:06:45.100 --> 00:06:49.440
And it has great looking window
title bar text and so forth.

00:06:49.470 --> 00:06:51.820
But when you actually start
looking at the web content,

00:06:51.840 --> 00:06:54.140
you can see that it's a little bit jaggy.

00:06:54.180 --> 00:06:56.070
And that's because it's web content.

00:06:56.090 --> 00:06:58.770
The system can scale up
all the art in the system,

00:06:58.780 --> 00:07:02.340
but we can't scale up-- or sorry,
we can't actually generate higher

00:07:02.340 --> 00:07:05.750
resolution art for content that's
out there on the web someplace.

00:07:05.790 --> 00:07:08.310
So Safari is taking that
art and literally scaling

00:07:08.310 --> 00:07:09.400
it up and interpolating it.

00:07:09.400 --> 00:07:11.600
So it's going to look a
little jaggy and grainy.

00:07:11.610 --> 00:07:14.590
Now, that's just the--

00:07:14.760 --> 00:07:15.630
images on the page.

00:07:15.680 --> 00:07:17.920
The text on the page
still looks fantastic,

00:07:17.920 --> 00:07:17.920
right?

00:07:17.930 --> 00:07:20.870
Because it's still rendered with Quartz,
and it respects the scale

00:07:20.870 --> 00:07:22.570
factor and looks great.

00:07:24.410 --> 00:07:26.160
OK, so let's see.

00:07:26.160 --> 00:07:30.230
Let's launch another app here.

00:07:30.260 --> 00:07:31.530
Get rid of TextEdit.

00:07:31.650 --> 00:07:34.850
So these are both Cocoa apps.

00:07:34.950 --> 00:07:37.960
Cocoa does a ton of the
resolution independence work

00:07:38.340 --> 00:07:40.670
on your app's behalf for free.

00:07:40.730 --> 00:07:44.610
But Cocoa was clearly not the
only app flavor that needs

00:07:44.640 --> 00:07:46.200
to be resolution independent.

00:07:46.310 --> 00:07:47.930
Carbon, Java apps,
and various other sorts

00:07:47.970 --> 00:07:50.450
of apps also need to be,
and they can be as well.

00:07:50.540 --> 00:07:52.820
So Finder is a Carbon app.

00:07:52.820 --> 00:07:57.230
Let me quit Finder now and relaunch it.

00:07:57.280 --> 00:08:00.220
And you can see that Finder
also respects the scale factor.

00:08:00.240 --> 00:08:01.860
And again,
Finder's a little bit of a mixed bag,

00:08:01.860 --> 00:08:02.770
much like Safari.

00:08:02.780 --> 00:08:05.710
It's got great looking text,
fantastic looking icons.

00:08:05.910 --> 00:08:09.100
But there's a few system controls
in Carbon that haven't revved yet

00:08:09.100 --> 00:08:11.540
to use the high resolution artwork.

00:08:11.740 --> 00:08:15.880
And you can see that tool tip that
came up is also still drawing low res.

00:08:15.910 --> 00:08:20.870
But we have a Carbon app here that's
also become resolution independent.

00:08:25.120 --> 00:08:28.300
OK, so one note about Finder.

00:08:28.370 --> 00:08:30.950
Finder is what we call
a modern Carbon app.

00:08:31.090 --> 00:08:32.680
They have gotten off of Quick Draw.

00:08:32.770 --> 00:08:34.760
They're using Quartz to
do all their drawing.

00:08:34.830 --> 00:08:37.010
And they use HIV Compositing Mode.

00:08:37.060 --> 00:08:42.020
That's the only way Finder could get the
crisp text and graphics that they have.

00:08:42.050 --> 00:08:46.620
Applications that have not adopted
HIV Compositing Mode and that still use

00:08:46.650 --> 00:08:51.170
Quick Draw can't be truly resolution
independent and truly look great.

00:08:51.240 --> 00:08:55.100
But we do have a little bit of
a fallback solution for them.

00:08:55.100 --> 00:08:58.690
OK, let me make finder
usable here real quick.

00:09:00.010 --> 00:09:01.550
Bring it back at a 1.0 scale factor.

00:09:01.560 --> 00:09:03.880
Let's crank the scale factor up to 3.

00:09:03.990 --> 00:09:05.120
And we'll launch Appearance Sample.

00:09:05.120 --> 00:09:08.040
So Appearance Sample is one of
our Carbon sample applications

00:09:08.040 --> 00:09:12.450
that shows off a lot of the
Carbon controls and so forth.

00:09:12.560 --> 00:09:15.760
It's an unmodified Carbon app that
continues to use Quick Draw and that

00:09:15.760 --> 00:09:18.510
does not use HIV compositing mode.

00:09:18.630 --> 00:09:19.610
It's still big.

00:09:19.680 --> 00:09:21.110
We still make it fit in.

00:09:21.240 --> 00:09:24.960
But we make it fit in with resolution
independence by magnifying a normal

00:09:24.960 --> 00:09:27.580
old-sized window backing buffer up.

00:09:27.690 --> 00:09:30.740
So your text is a little
blurry and your controls and

00:09:30.770 --> 00:09:32.580
so forth are a little blurry.

00:09:32.590 --> 00:09:35.780
And again, this is because we've got a
normal resolution window backing

00:09:35.780 --> 00:09:39.330
buffer that's being scaled up and
interpolated by the Windows Server.

00:09:39.420 --> 00:09:42.220
So at least this allows unmodified
Carbon applications to fit in.

00:09:42.340 --> 00:09:45.220
But clearly,
Carbon applications want to rev to

00:09:45.220 --> 00:09:46.980
be truly resolution independent.

00:09:47.040 --> 00:09:50.840
There are some Carbon apps
whose clients expect to actually

00:09:50.840 --> 00:09:52.420
see and manipulate the pixels.

00:09:52.420 --> 00:09:54.420
Every popular graphics app is this way.

00:09:54.420 --> 00:09:56.410
A lot of the drawing apps are this way.

00:09:56.520 --> 00:10:00.820
A magnifier modified drawing
app isn't really usable.

00:10:00.840 --> 00:10:01.780
I mean, you can use it.

00:10:01.860 --> 00:10:02.850
It's functional.

00:10:02.970 --> 00:10:07.080
But if an HI designer or an
artist can't see pixel perfection,

00:10:07.080 --> 00:10:08.170
it's not going to work.

00:10:08.300 --> 00:10:12.000
So those Carbon apps need to
either-- they can rewrite for Cocoa,

00:10:12.000 --> 00:10:14.410
certainly, and then they'll get
resolution independence easily.

00:10:14.500 --> 00:10:16.680
But the other option is to get
rid of their Quick Draw drawing

00:10:16.760 --> 00:10:18.680
and move to HIV compositing mode.

00:10:18.780 --> 00:10:21.150
And then it's just as easy to
adopt resolution independence

00:10:21.190 --> 00:10:23.410
as it is with Cocoa.

00:10:25.100 --> 00:10:26.740
OK, so somebody asked about the menus.

00:10:26.850 --> 00:10:29.050
The menus still look fantastic.

00:10:29.060 --> 00:10:31.670
The menus,
because they're drawn by the system-- oh,

00:10:31.670 --> 00:10:32.880
I see, the clipping.

00:10:32.880 --> 00:10:35.380
That's a bug in the toolbox.

00:10:35.380 --> 00:10:38.110
We'll fix that before we ship.

00:10:38.110 --> 00:10:38.110
Actually,

00:10:40.150 --> 00:10:41.910
So I'm not sure whether you're
talking about the truncation

00:10:41.980 --> 00:10:43.840
or the menu at the top right.

00:10:43.840 --> 00:10:47.500
So the truncation is just a
factor of the fact that we're

00:10:47.500 --> 00:10:50.880
running at a 3.0 scale factor,
and Appearance Samples menus

00:10:51.190 --> 00:10:52.700
take up a lot of space.

00:10:52.860 --> 00:10:57.380
So a 3.0 scale factor probably isn't
something a user would run at on a

00:10:57.530 --> 00:11:00.640
display with this physical resolution.

00:11:00.650 --> 00:11:06.340
Typically, when I test and so forth,
I will run at a 1.5 or

00:11:06.340 --> 00:11:08.180
a 1.25 scale factor.

00:11:08.180 --> 00:11:12.350
I can tell the interface is scaled up,
but it's still usable.

00:11:12.380 --> 00:11:15.100
I don't get my menus
clipped and so forth.

00:11:19.100 --> 00:11:22.320
OK, so that's it for the demo.

00:11:22.320 --> 00:11:24.730
Let's kick back over to slides.

00:11:30.970 --> 00:11:33.770
So I mentioned two kinds of windows.

00:11:33.820 --> 00:11:35.250
There were the nice
looking Cocoa windows,

00:11:35.340 --> 00:11:37.650
the nice looking Carbon windows,
and there were those not so

00:11:37.650 --> 00:11:39.090
nice looking Carbon windows.

00:11:39.220 --> 00:11:43.050
So let's go through those and one other,
what we call a scale mode.

00:11:43.520 --> 00:11:46.090
Framework scaled mode is how we got
those nice looking Cocoa windows

00:11:46.160 --> 00:11:47.700
and nice looking Carbon windows.

00:11:47.700 --> 00:11:50.990
This is where your applications need
to be for resolution independence.

00:11:51.010 --> 00:11:53.470
It allows you to get the
great looking user interface.

00:11:53.500 --> 00:11:57.580
We take your Windows request
for its size,

00:11:57.640 --> 00:12:02.710
multiply that times the scale factor,
and we build its backing buffer

00:12:02.710 --> 00:12:05.500
out of that many pixels in the
horizontal and vertical dimensions.

00:12:05.500 --> 00:12:08.220
So we've got more pixels that
we're using to render the content,

00:12:08.240 --> 00:12:09.990
and that's how we make it look great.

00:12:12.320 --> 00:12:12.940
So that's framework scaled mode.

00:12:12.940 --> 00:12:13.540
That's where you want to be.

00:12:13.570 --> 00:12:16.790
What Appearance Sample used was
what we call magnified mode.

00:12:16.830 --> 00:12:19.250
And like I said,
this was the compatibility mode to

00:12:19.260 --> 00:12:21.300
make unmodified Carbon apps fit in.

00:12:21.550 --> 00:12:24.990
The way this works is we take
a normal window backing buffer

00:12:25.260 --> 00:12:27.730
and have the Windows server
scale that up interpolating.

00:12:27.820 --> 00:12:30.250
So it doesn't look great,
but it's certainly usable.

00:12:31.020 --> 00:12:34.460
We have a third mode which I didn't
show off because it's not implemented,

00:12:34.460 --> 00:12:36.300
and that's what we call small mode.

00:12:36.300 --> 00:12:37.300
This is our contingency plan.

00:12:37.300 --> 00:12:42.300
We found that a number of
applications simply don't work

00:12:42.300 --> 00:12:45.070
in resolution independence mode,
either in framework scaled

00:12:45.070 --> 00:12:46.290
mode or magnified mode.

00:12:46.300 --> 00:12:50.200
They do a number of things that
aren't legal or just aren't compatible

00:12:50.200 --> 00:12:54.250
with resolution independence,
and we can't fix that in the system.

00:12:54.300 --> 00:12:58.360
Apps are making potentially bad
assumptions about the coordinate systems

00:12:58.360 --> 00:13:00.300
that APIs are using and so forth.

00:13:00.300 --> 00:13:02.270
We can't break those assumptions.

00:13:02.280 --> 00:13:06.300
So what we may have to do instead
is put this small mode in place.

00:13:06.300 --> 00:13:10.280
So in our testing as we're
implementing resolution independence,

00:13:10.360 --> 00:13:12.310
if we find an application
that just can't work,

00:13:12.340 --> 00:13:15.800
we'll probably put an app-specific
workaround in place for that app

00:13:15.800 --> 00:13:17.290
so it comes up in this small mode.

00:13:17.300 --> 00:13:22.740
Small mode uses the same window backing
buffer pixel dimensions as it always has,

00:13:22.740 --> 00:13:25.080
but leaves the image small as well.

00:13:25.300 --> 00:13:26.300
Hence the name small mode.

00:13:26.300 --> 00:13:28.160
So it allows the apps to
actually be functional,

00:13:28.300 --> 00:13:30.300
but it looks pretty dull.

00:13:30.300 --> 00:13:31.300
It's pretty jarring, right?

00:13:31.300 --> 00:13:34.010
If you were on a display that used
a 2.0 scale factor and you launched

00:13:34.030 --> 00:13:36.300
an app that's in small mode,
the windows are really tiny

00:13:36.300 --> 00:13:38.800
and potentially unusable,
depending on how high your

00:13:38.800 --> 00:13:40.300
scale factor needs to be.

00:13:41.560 --> 00:13:46.010
So not only will we have
app-specific workarounds in place

00:13:46.010 --> 00:13:48.960
for certain ill-behaved apps,
but we will probably also need

00:13:48.960 --> 00:13:52.640
to make small mode a user option,
much the same way the launch in Rosetta

00:13:52.640 --> 00:13:54.960
checkbox is a user option in Finder,
right?

00:13:55.390 --> 00:13:58.870
Certainly Apple can't test every
application that's out there.

00:13:58.880 --> 00:14:02.000
A user may be running an app
and find some problem running

00:14:02.120 --> 00:14:06.060
in resolution independence mode
that they just can't work around.

00:14:06.060 --> 00:14:09.500
And so they need a way to request to
run this application in small mode

00:14:09.500 --> 00:14:11.310
so they can get their work done.

00:14:11.500 --> 00:14:13.460
But we don't have that
switch in place yet,

00:14:13.460 --> 00:14:16.250
but we'll have something for Leopard GM.

00:14:18.300 --> 00:15:54.700
[Transcript missing]

00:15:57.150 --> 00:16:02.990
OK, so let's talk about how Leopard
supports resolution independence.

00:16:03.300 --> 00:16:05.220
So as I showed off--

00:16:05.700 --> 00:16:09.520
A lot of the system controls
support high res content in Leopard.

00:16:09.520 --> 00:16:10.100
Not all of them.

00:16:10.200 --> 00:16:13.250
There's a few rough edges,
but we're working hard to replace

00:16:13.290 --> 00:16:16.200
the artwork for all of our system
controls with artwork that can

00:16:16.200 --> 00:16:17.880
draw at virtually any resolution.

00:16:17.880 --> 00:16:20.250
It'll look fantastic at any resolution.

00:16:20.350 --> 00:16:24.390
We're also adding a few system
controls and a few variants of

00:16:24.410 --> 00:16:27.780
system controls to give applications
standard versions of things that they

00:16:27.780 --> 00:16:29.700
were currently coding up themselves.

00:16:29.850 --> 00:16:32.210
And we'll make sure to put
high resolution artwork to back

00:16:32.210 --> 00:16:34.820
those pieces of art so that
your app can look fantastic.

00:16:35.700 --> 00:16:39.850
We've also added another size
of icon data to icon services.

00:16:39.850 --> 00:16:43.620
So it now supports up
to 512 by 512 icons.

00:16:43.620 --> 00:16:47.550
I think the previous
limit was 256 by 256.

00:16:47.890 --> 00:16:50.280
But most importantly,
we're revving system applications

00:16:50.450 --> 00:16:52.460
to be high DPI savvy.

00:16:52.460 --> 00:16:55.680
We've chosen a few key applications
that stress various parts of the

00:16:55.690 --> 00:16:59.080
system so that we can make sure
our resolution independent strategy

00:16:59.160 --> 00:17:00.800
works and is actually adoptable.

00:17:00.800 --> 00:17:03.560
So as I showed,
Finder and TextEdit and Safari work,

00:17:03.590 --> 00:17:06.390
but we also have a few other
apps that I listed up here,

00:17:06.440 --> 00:17:09.620
and there will be more to come
by the time LepreGM ships.

00:17:09.730 --> 00:17:13.400
We're also adding some new
standard art that's accessible

00:17:13.400 --> 00:17:18.160
via an existing mechanism,
but-- well, it's an existing API,

00:17:18.160 --> 00:17:19.430
but it's a new mechanism.

00:17:19.500 --> 00:17:25.220
NSImage has supported the notion of named
images for as long as I can remember.

00:17:25.260 --> 00:17:28.880
And generally what this is used
for is to fetch an image out

00:17:28.880 --> 00:17:31.580
of your application's bundle.

00:17:31.890 --> 00:17:36.770
So you put foo.jpg in your bundle and
you can instantiate an NS image with

00:17:36.770 --> 00:17:40.600
name foo.jpg and then you'll have an
NS image that can render that file.

00:17:40.600 --> 00:17:43.420
So we're extending that
to support system artwork.

00:17:43.450 --> 00:17:49.170
NS image now supports a number of
standard pieces of artwork and this

00:17:49.170 --> 00:17:53.550
will grow over time until Leopard ships.

00:17:57.250 --> 00:18:01.520
So the Cocoa framework makes it really
easy to get to resolution independence.

00:18:01.540 --> 00:18:04.480
Cocoa Windows are
automatically framework scaled.

00:18:04.480 --> 00:18:08.710
You can take an unmodified Cocoa app,
launch it, the window will get bigger.

00:18:08.710 --> 00:18:09.910
And it mostly works.

00:18:09.920 --> 00:18:12.640
All your system text drawing,
system controls are

00:18:12.640 --> 00:18:14.110
going to look fantastic.

00:18:14.110 --> 00:18:16.890
Your custom drawing,
it's going to be a mixed bag.

00:18:16.890 --> 00:18:20.000
Your custom text drawing will
probably look good so long as

00:18:20.000 --> 00:18:23.910
you're using any modern API,
Quartz API, to render that text.

00:18:24.960 --> 00:18:28.020
Your graphics, however, well,
we're going to scale those

00:18:28.020 --> 00:18:30.540
up the same way Safari scaled
up the art in the web case,

00:18:30.540 --> 00:18:30.910
right?

00:18:30.920 --> 00:18:33.020
We only have the low resolution
artwork that's in your

00:18:33.020 --> 00:18:34.460
application bundles to work with.

00:18:34.480 --> 00:18:36.040
So we scale it up so
that it looks bigger,

00:18:36.040 --> 00:18:37.250
but it's interpolated.

00:18:37.250 --> 00:18:39.960
So you have some work to do there
to generate higher resolution

00:18:39.980 --> 00:18:41.270
art if you're a Cocoa app.

00:18:41.270 --> 00:18:44.520
But the important thing to note
is Cocoa apps basically just work

00:18:44.520 --> 00:18:46.380
in resolution independence mode.

00:18:46.380 --> 00:18:49.920
There are a few bugs and gotchas,
but we'll talk about those in a bit.

00:18:49.920 --> 00:18:52.720
One important caveat is that
NS Quickdraw View doesn't work in Cocoa.

00:18:52.780 --> 00:18:54.840
But the important caveat is that
NS Quickdraw View doesn't work

00:18:54.840 --> 00:18:57.770
in resolution independence mode,
mainly because Quickdraw doesn't

00:18:57.890 --> 00:18:59.430
work for resolution independence.

00:18:59.620 --> 00:19:01.210
So if you're relying
on NS Quickdraw View,

00:19:01.220 --> 00:19:03.870
you have to rethink that strategy
and come up with a different

00:19:03.870 --> 00:19:06.690
implementation mechanism for
whatever it is you're doing.

00:19:08.120 --> 00:19:11.990
. Carbon applications,
they have a little bit more work to do.

00:19:11.990 --> 00:19:15.380
By default, as I showed,
they come up in magnified mode,

00:19:15.380 --> 00:19:18.770
which allows them to fit in,
but they don't look perfect.

00:19:18.880 --> 00:19:22.970
So in order for a Carbon application
to get to framework scaling mode,

00:19:22.970 --> 00:19:27.010
they have to get off of Quick Draw and
get on to HIV compositing mode.

00:19:27.010 --> 00:19:30.180
Once you do that,
you can go into interface builder and

00:19:30.220 --> 00:19:32.660
click the framework scaling check box.

00:19:32.660 --> 00:19:34.850
Actually, I think it's in a pop-up.

00:19:34.850 --> 00:19:35.290
And that Carbon window
will be framework scaled.

00:19:45.390 --> 00:19:45.400
And once you get to that point,
the story is essentially

00:19:45.400 --> 00:19:45.400
the same as Cocoa.

00:19:45.400 --> 00:19:45.400
Everything's going to look great except
for your custom content and artwork.

00:19:45.400 --> 00:19:45.400
You'll need to rev your custom
art to make it look fantastic.

00:19:45.570 --> 00:19:49.320
For those of you who tried out the
resolution independent support on Tiger,

00:19:49.320 --> 00:19:53.530
we used to offer a mode called
application scaled mode,

00:19:53.530 --> 00:19:56.290
which was a way that
Quick Draw based apps could be

00:19:56.310 --> 00:19:58.400
resolution independent savvy.

00:19:58.530 --> 00:20:02.330
We did some investigation here and we
found out that not only was that very

00:20:02.330 --> 00:20:05.580
challenging for Apple to make work,
but it turns out that it forces

00:20:05.740 --> 00:20:12.030
an application to do more work
to react to that than it did to

00:20:12.030 --> 00:20:14.400
just get rid of Quick Draw drawing
and adopt HIV compositing mode.

00:20:14.400 --> 00:20:16.400
So we're scrapping application
scaled mode altogether.

00:20:16.400 --> 00:20:19.430
It does not work on Leopard.

00:20:22.760 --> 00:20:26.580
Java also supports framework scaled mode.

00:20:26.710 --> 00:20:29.260
So in general,
a Java app looks fantastic.

00:20:29.470 --> 00:20:30.980
Again,
it comes down to the custom artwork.

00:20:31.200 --> 00:20:34.020
Custom artwork gets scaled up as usual.

00:20:34.420 --> 00:20:40.420
It's important to note that all
Java APIs operate in terms of points.

00:20:40.650 --> 00:20:44.740
Every existing Java API that passes a
point or a rectangle or other sort of

00:20:44.740 --> 00:20:48.410
coordinate interprets that coordinate
in the point space and will scale that

00:20:48.410 --> 00:20:49.830
up if it needs to deal with pixels.

00:20:51.300 --> 00:20:56.890
So our Apple's Java team is working
with Sun to put new APIs in place

00:20:56.920 --> 00:21:01.690
in an upcoming version of Java such
that it's got direct resolution

00:21:01.690 --> 00:21:05.260
independent support to allow your
Java applications to tweak their

00:21:05.260 --> 00:21:09.810
UI a little bit to take advantage of
resolution independence in various ways.

00:21:10.610 --> 00:21:14.120
So a fourth flavor of application
is a dashboard widget.

00:21:14.120 --> 00:21:17.230
Dashboard widgets are
kind of web content,

00:21:17.280 --> 00:21:18.020
JavaScript.

00:21:18.020 --> 00:21:21.100
It's a little bit of a hybrid.

00:21:21.120 --> 00:21:23.420
And dashboard widgets are kind of tricky.

00:21:23.460 --> 00:21:25.900
So ostensibly,
they support framework scaling.

00:21:26.010 --> 00:21:28.660
But we don't have a full
story in place for artwork.

00:21:28.770 --> 00:21:32.300
So if you increase your scale factor,
log out, log in,

00:21:32.300 --> 00:21:36.020
and bring up dashboard widgets,
they will be bigger for the most part.

00:21:36.340 --> 00:21:38.580
But the artwork will be
scaled up and interpolated,

00:21:38.580 --> 00:21:39.740
and they don't look great.

00:21:39.940 --> 00:21:42.690
And unfortunately,
there's not a really good way

00:21:42.750 --> 00:21:47.440
for a dashboard widget to put in
higher resolution artwork yet.

00:21:47.670 --> 00:21:49.920
We're working really closely
with the dashboard team,

00:21:49.920 --> 00:21:52.910
the Safari team,
and the WebKit team to establish

00:21:52.970 --> 00:21:56.500
web standards and standards for
dashboard widgets so that they can

00:21:56.500 --> 00:21:57.790
put high-res artwork out there.

00:21:57.900 --> 00:22:00.050
Because we want to make sure
dashboard widgets looks absolutely

00:22:00.050 --> 00:22:01.670
fantastic in high resolution.

00:22:07.020 --> 00:22:08.110
OK.

00:22:08.170 --> 00:22:12.360
So there are a number of steps you need
to take to adopt resolution independence.

00:22:12.370 --> 00:22:15.220
The first thing you need to do,
look in your applications

00:22:15.310 --> 00:22:17.130
bundle and find all your art.

00:22:17.390 --> 00:22:21.330
Find all your PNG files, JPEGs, TIFFs,
whatever you're using to render

00:22:21.330 --> 00:22:22.790
the art in your application.

00:22:22.960 --> 00:22:23.940
Find it.

00:22:24.030 --> 00:22:24.780
Make a list of it.

00:22:24.910 --> 00:22:25.660
Keep it handy.

00:22:25.740 --> 00:22:27.510
You're going to go through
each piece one by one.

00:22:27.640 --> 00:22:29.940
Ask yourself some questions.

00:22:29.960 --> 00:22:32.970
If you're using that piece of art
to replicate a standard control,

00:22:32.970 --> 00:22:34.350
get off that art.

00:22:34.360 --> 00:22:36.040
Adopt the standard control.

00:22:36.060 --> 00:22:38.390
The standard controls will be
rev to support high res art,

00:22:38.420 --> 00:22:40.790
so you might as well leverage that.

00:22:43.360 --> 00:22:46.400
Maybe your piece of standalone art
is something that we now provide via

00:22:46.400 --> 00:22:49.980
NSImages named image mechanism or via
icon services or something like that,

00:22:49.980 --> 00:22:51.740
or maybe even HITheme.

00:22:52.060 --> 00:22:56.100
If so, try to get off of your custom art
and adopt that other API instead.

00:22:56.200 --> 00:22:59.410
Again, we're going to rev those APIs such
that they've got the high res art,

00:22:59.470 --> 00:23:02.300
and you want to leverage
the system wherever you can.

00:23:03.240 --> 00:23:04.830
A third category of art
is kind of interesting.

00:23:04.860 --> 00:23:10.240
As we went through our own applications,
we found a lot of apps have

00:23:10.240 --> 00:23:14.100
bitmap art for things like
rectangle fills or a frame,

00:23:14.120 --> 00:23:15.810
just a rectangular
frame around something,

00:23:15.840 --> 00:23:16.730
or a simple gradient.

00:23:16.730 --> 00:23:20.440
And all of these things can be
represented via procedural code.

00:23:20.440 --> 00:23:23.050
So in some of these cases,
we've decided to just

00:23:23.050 --> 00:23:24.930
tell those applications,
look,

00:23:24.960 --> 00:23:27.510
start rendering this via procedural code.

00:23:27.510 --> 00:23:30.250
The procedural code uses quarts,
therefore it's inherently

00:23:30.290 --> 00:23:33.180
scalable and it looks fantastic
in resolution independence mode.

00:23:33.200 --> 00:23:36.790
So you should take a look and
see if you can do that as well.

00:23:38.310 --> 00:23:42.220
So once you've made all the code changes,
everything left in your pile of art

00:23:42.280 --> 00:23:45.530
is art that needs to be scaled up,
is art that you need to generate

00:23:45.530 --> 00:23:47.750
higher resolution content for.

00:23:47.760 --> 00:23:48.310
Oh, sorry.

00:23:48.410 --> 00:23:49.080
Forgot to do this.

00:23:49.080 --> 00:23:53.110
The other benefit of going
through your art is that you get

00:23:53.180 --> 00:23:55.880
to toss all of that old art aside
and make your bundle smaller,

00:23:55.880 --> 00:23:57.990
which is important,
because pretty soon I'm going to ask you

00:23:57.990 --> 00:23:59.990
to make your bundle a little bit bigger.

00:24:00.120 --> 00:24:04.000
So everything that's left in this
pile is artwork you need to revise

00:24:04.060 --> 00:24:06.350
for resolution independence.

00:24:07.010 --> 00:24:10.460
So what we're asking for is
your application art to support

00:24:10.470 --> 00:24:13.420
scale factors up to 4.0.

00:24:14.150 --> 00:24:19.220
or for icons, use the 512 by 512 version,
which isn't quite 4.0, it's 2.0,

00:24:19.220 --> 00:24:20.600
but it still leaves
you a lot of headroom.

00:24:20.740 --> 00:24:24.010
So the reason we want 4.0 or
4X is because it gives you a

00:24:24.050 --> 00:24:25.290
lot of room for the future.

00:24:25.300 --> 00:24:29.650
If you generate 4X artwork now,
you're going to save yourselves

00:24:29.650 --> 00:24:32.600
a lot of time when the displays
actually catch up to that resolution.

00:24:32.600 --> 00:24:35.910
So you need to ship your
application with versions of the

00:24:35.920 --> 00:24:38.640
art that work at 1.0 and 4.0.

00:24:40.080 --> 00:24:43.100
If this ends up being a problem
for apps with a lot of art that

00:24:43.150 --> 00:24:46.760
are downloadable or so forth,
what you can do for the short term is

00:24:46.760 --> 00:24:50.610
just ship your app with the 1X version
of the art and some lower resolution

00:24:50.610 --> 00:24:52.220
that doesn't take up as much space.

00:24:55.700 --> 00:24:57.830
So when you're making
your high resolution art,

00:24:57.830 --> 00:25:00.850
the first piece of advice
I have-- and this is just advice,

00:25:00.850 --> 00:25:05.770
this is not any kind of requirement--
is to avoid the use of bitmaps.

00:25:06.090 --> 00:25:10.720
If I'm telling you to use a 1x version
of a bitmap and a 4x version of your

00:25:10.720 --> 00:25:14.900
bitmap and put that in your bundle,
you've just spent 17 or up to 17

00:25:14.900 --> 00:25:17.920
times as much space for that one
piece of art in your application.

00:25:18.060 --> 00:25:20.850
If you multiply that times 100
or 200 pieces of art that we see

00:25:20.850 --> 00:25:23.700
in the big apps-- and in fact,
the big apps often have thousands--

00:25:23.780 --> 00:25:26.950
that's a huge increase in disk footprint.

00:25:27.080 --> 00:25:32.160
So if you can get off of bitmaps,
you're going to remove this huge disk

00:25:32.160 --> 00:25:35.180
footprint increase from your application.

00:25:35.200 --> 00:25:39.970
The other problem with bitmaps is you
need multiple versions to represent

00:25:40.340 --> 00:25:44.370
both the low res look of your app
and the high res look of your app.

00:25:44.500 --> 00:25:46.500
Both of those versions
need to be maintained.

00:25:46.540 --> 00:25:49.200
In the future,
you may need to add an even higher one.

00:25:49.380 --> 00:25:51.940
And this is a time expense
that the HI designers would

00:25:52.030 --> 00:25:53.460
love to avoid if they can.

00:25:53.480 --> 00:25:56.070
If they can give you a single
piece of art today that will

00:25:56.070 --> 00:25:59.120
work at any scale factor,
they'd love to do it.

00:25:59.270 --> 00:26:04.200
So if you can,
use vector formats to represent your art.

00:26:04.560 --> 00:26:05.640
PDF is a great example.

00:26:05.850 --> 00:26:08.360
We're using PDF for a lot
of the system art below.

00:26:08.360 --> 00:26:11.360
I've got a little screenshot of six
of the different pieces of system art

00:26:11.360 --> 00:26:13.880
that we're now using PDFs to render.

00:26:13.890 --> 00:26:15.600
Obviously, they're much smaller.

00:26:15.710 --> 00:26:18.120
They scale up to any
arbitrary resolution.

00:26:18.150 --> 00:26:20.750
And it works really
great for monocolor art,

00:26:20.750 --> 00:26:25.030
or art that has slight color
transformations to it and so forth.

00:26:25.170 --> 00:26:28.210
Hopefully this goes without saying,
but we've run into a few people

00:26:28.210 --> 00:26:29.460
that didn't quite get this.

00:26:29.460 --> 00:26:33.100
A lot of vector formats
allow you to embed bitmaps.

00:26:33.120 --> 00:26:33.670
Don't do that.

00:26:33.810 --> 00:26:35.940
That completely defeats
the purpose of the vector.

00:26:36.000 --> 00:26:37.950
The whole point of the vector
is that it's not a bitmap.

00:26:37.990 --> 00:26:40.350
So if you store a bitmap in there,
it's essentially a bitmap,

00:26:40.350 --> 00:26:41.790
and you've lost the whole advantage.

00:26:41.810 --> 00:26:43.040
So don't do that.

00:26:45.010 --> 00:26:49.110
Now, we know from experience that we
can't represent everything as

00:26:49.110 --> 00:26:52.210
vectors and have it look as great
as we want it to on the system.

00:26:52.330 --> 00:26:53.970
We can do a lot of stuff,
just not everything.

00:26:54.140 --> 00:26:58.180
So there are a few pieces of art that
we know we need to ship as bitmaps.

00:26:58.430 --> 00:27:00.560
I'm sure you're going to find yourself
in the same sort of situation.

00:27:00.560 --> 00:27:03.730
And if you do need to create bitmaps,
here's what you need to do.

00:27:03.810 --> 00:27:07.040
Create your 1x version of your bitmap,
which you already have.

00:27:07.210 --> 00:27:10.870
Have your designers create
your 4x version of your bitmap.

00:27:11.090 --> 00:27:15.220
Make sure you turn on compression so that
your 4X version is not monstrously huge.

00:27:17.070 --> 00:27:19.820
And then merge them into a single file.

00:27:19.860 --> 00:27:24.340
Multi-image TIFF is what we're using
internally in a lot of our applications.

00:27:24.380 --> 00:27:28.590
We have the user bin TIFF util tool,
which I'll show in a little bit,

00:27:28.590 --> 00:27:30.750
that allows you to take two

00:27:31.330 --> 00:27:34.700
TIF files that have a single
resolution image in them and

00:27:34.700 --> 00:27:41.360
merge them together into one file,
two images, two different resolutions.

00:27:41.360 --> 00:27:43.460
But your application code,
most importantly,

00:27:43.480 --> 00:27:48.150
gets to interact with this one
file as if it's just one image.

00:27:48.180 --> 00:27:49.820
You don't even need to worry
about the fact that there's two

00:27:49.820 --> 00:27:51.100
different representations in there.

00:27:51.100 --> 00:27:52.930
It just works.

00:27:55.520 --> 00:27:58.130
Another option that's very popular,
obviously, is PNG.

00:27:58.330 --> 00:28:01.260
If you need to use PNG,
it does not support multiple

00:28:01.260 --> 00:28:03.140
representations in a given file.

00:28:03.320 --> 00:28:06.550
So your application will need to come
up with some kind of naming scheme.

00:28:06.570 --> 00:28:13.040
You might want to have your existing
foo.png and a new foo for PNG,

00:28:13.040 --> 00:28:14.100
perhaps.

00:28:14.180 --> 00:28:17.050
And you need to rev your application
code to load the right one,

00:28:17.050 --> 00:28:20.010
depending on what scale
factor you're using.

00:28:23.320 --> 00:28:24.930
So I already mentioned
TIFF Util as one of the artwork

00:28:25.050 --> 00:28:26.730
tools we have on the system.

00:28:26.810 --> 00:28:30.480
Preview App has also revved so
that it can show the multiple

00:28:30.520 --> 00:28:34.860
representations in a multi-rep TIFF file.

00:28:34.860 --> 00:28:39.870
And we've also revved the icon composer
tool so that it supports the 512 by 512

00:28:39.870 --> 00:28:43.770
ICNS data for your file system icons.

00:28:43.800 --> 00:28:47.640
On TIFF Util as well,
there's a flag you can pass to it

00:28:48.120 --> 00:28:51.960
that asks it to validate your art
to make sure it's going to work

00:28:52.080 --> 00:28:53.820
properly in resolution independence.

00:28:53.820 --> 00:28:55.680
And that's called the CAT High DPI check.

00:28:55.740 --> 00:28:59.190
There is NS Images code
that iterates the multiple

00:28:59.560 --> 00:29:03.900
representations in an image file,
relies on certain pieces of

00:29:03.900 --> 00:29:06.400
metadata being set properly.

00:29:06.400 --> 00:29:10.160
And CAT High DPI check makes sure
that metadata is set properly.

00:29:10.160 --> 00:29:12.890
And it'll log to the console if it's not.

00:29:12.900 --> 00:29:14.040
so you can make revs.

00:29:16.610 --> 00:29:19.200
So once you have all this new art,
it's time to adopt it

00:29:19.200 --> 00:29:21.080
in your application.

00:29:21.300 --> 00:29:23.800
Your file system icons,
your application icon

00:29:23.800 --> 00:29:25.640
and your document icons,
they're trivial.

00:29:25.690 --> 00:29:28.080
Just drop them in your bundle.

00:29:28.410 --> 00:29:30.560
For the most part,
adopting your other revised

00:29:30.560 --> 00:29:31.800
artwork is pretty easy.

00:29:31.880 --> 00:29:35.500
If you already were an NSImage
client or an ImageIO client,

00:29:35.530 --> 00:29:37.670
you just drop the new file in,
replace the old file,

00:29:37.670 --> 00:29:39.450
and it just works with
your existing code.

00:29:39.460 --> 00:29:42.800
Some of you may need to rev to
adopt NSImage or ImageIO in order

00:29:42.800 --> 00:29:44.660
to get this high-res artwork.

00:29:44.660 --> 00:29:48.690
One thing I don't have mentioned
here that we're going to mention

00:29:48.690 --> 00:29:53.120
in the toolbox session next is that
we've revved the Leopard Toolbox to

00:29:53.120 --> 00:29:57.840
allow you to associate artwork by
path with various system controls.

00:29:57.840 --> 00:30:00.170
So you can have a bevel
button that displays an image,

00:30:00.270 --> 00:30:03.740
and you can just tell that bevel button,
"Go find the image at this path."

00:30:03.770 --> 00:30:06.940
So that's a great way to make it work
with a multi-representation TIFF file,

00:30:06.940 --> 00:30:07.530
for example.

00:30:07.540 --> 00:30:09.860
You can just give it
the path of a TIFF file,

00:30:09.860 --> 00:30:13.730
and the Carbon bevel button will
find the right image to use in there.

00:30:15.070 --> 00:30:21.260
For those of you that want really
fine-grained control over your artwork,

00:30:21.260 --> 00:30:22.980
Image.io is a great way to do it.

00:30:23.030 --> 00:30:25.160
It doesn't give you
as much out-of-the-box

00:30:25.160 --> 00:30:27.020
functionality as NSImage does.

00:30:27.020 --> 00:30:29.860
If you want to use Image.io,
you can do all kinds of cool things,

00:30:29.860 --> 00:30:33.310
having to deal with caching and so forth,
but you need to manually iterate

00:30:33.310 --> 00:30:37.480
the images in the given file,
find the right one for the scale factor,

00:30:37.480 --> 00:30:40.750
generate a CG image ref from that,
and draw that.

00:30:40.860 --> 00:30:43.630
So it gives you finer-grained control,
but you have to go through

00:30:43.630 --> 00:30:44.720
a little bit more work.

00:30:44.900 --> 00:30:45.590
to make that work.

00:30:49.080 --> 00:30:52.610
So I have this as step four,
but this is really an iterative process,

00:30:52.690 --> 00:30:54.380
the whole testing part.

00:30:54.390 --> 00:30:57.230
In theory, we test as we're developing.

00:30:57.330 --> 00:31:01.740
So the whole point of the testing is
try a bunch of different scale factors.

00:31:01.760 --> 00:31:07.520
1.0 is going to get tried implicitly
by thousands and millions of users.

00:31:07.530 --> 00:31:10.280
But we have other key scale
factors we want you to try.

00:31:10.280 --> 00:31:14.670
Quartz Debug has five
scale factors for you.

00:31:14.680 --> 00:31:18.100
There's a 1.0, a 1.25, a 1.5, 2, and 3.

00:31:18.100 --> 00:31:19.860
And we'd like you to test at all those.

00:31:19.860 --> 00:31:23.800
In particular,
the 1.25 and 1.5 scale factors

00:31:23.800 --> 00:31:27.220
are interesting because they
expose a whole new set of bugs

00:31:27.250 --> 00:31:31.680
in applications and in the system
than the integral scale factors do.

00:31:31.680 --> 00:31:33.540
And I'll talk about some of those later.

00:31:33.540 --> 00:31:36.680
Now, even though Tiger had support
for resolution independence,

00:31:36.680 --> 00:31:39.080
the support is not nearly
as rich as it is in Leopard,

00:31:39.090 --> 00:31:42.340
and we've also fixed a bunch of
bugs in the Tiger implementation.

00:31:42.340 --> 00:31:43.820
So don't test on Tiger.

00:31:43.820 --> 00:31:45.370
It's kind of pointless.

00:31:45.370 --> 00:31:47.040
Please test on Leopard.

00:31:48.280 --> 00:31:51.960
And when you find bugs,
either fix them if they're your app bugs.

00:31:51.970 --> 00:31:53.900
But if they're the system bugs,
let us know.

00:31:53.900 --> 00:31:56.940
We know there's thousands of applications
out there and more every day.

00:31:56.970 --> 00:31:58.240
We can't test them all.

00:31:58.280 --> 00:32:00.950
So if you run across some system bug,
write it up in Radar,

00:32:00.950 --> 00:32:03.300
and we'll try to take care
of it as soon as we can.

00:32:03.300 --> 00:32:06.260
We really want the resolution
independence experience

00:32:06.260 --> 00:32:07.770
in Leopard to be awesome.

00:32:11.830 --> 00:32:16.600
So to fix a lot of these bugs,
sometimes you need to find

00:32:16.600 --> 00:32:17.540
out what the scale factor is.

00:32:17.690 --> 00:32:19.990
We have a couple
different ways to do that.

00:32:20.330 --> 00:32:22.940
The preferred way is finding
out what the scale factor is

00:32:22.940 --> 00:32:24.000
associated with the window.

00:32:24.000 --> 00:32:27.460
The reason for this is you can
have an application whose windows,

00:32:27.460 --> 00:32:30.720
it can have multiple windows,
and each of those windows can be

00:32:30.720 --> 00:32:32.930
operating in a different scale mode.

00:32:32.930 --> 00:32:37.800
The hairiest example is probably a
Carbon app that uses some Cocoa windows,

00:32:38.110 --> 00:32:40.710
say for the color picker
or the font panel,

00:32:40.710 --> 00:32:44.930
because those are Cocoa windows
that come up in a Carbon app.

00:32:44.980 --> 00:32:48.610
And that Carbon app has
Rev to support resolution

00:32:48.610 --> 00:32:50.180
independence in its main window.

00:32:50.200 --> 00:32:51.720
So that's framework scaled.

00:32:51.720 --> 00:32:56.230
But there's some other windows in that
application that haven't been revved yet.

00:32:56.230 --> 00:32:58.790
And so those will come
up in magnified mode.

00:32:58.790 --> 00:33:02.990
And the Cocoa window will also be
framework scaled because it's Cocoa.

00:33:03.010 --> 00:33:06.290
And so you'll have these three flavors
of windows in your application,

00:33:06.290 --> 00:33:09.520
and each of them could potentially
have a different scale factor.

00:33:09.520 --> 00:33:11.660
In reality, they will only be up to two.

00:33:11.660 --> 00:33:16.020
The magnified mode windows will be
operating at a 1.0 scale factor because

00:33:16.020 --> 00:33:19.950
that's what the size of the backing
buffer is relative to the old size.

00:33:20.200 --> 00:33:23.200
And the Carbon framework scaled and
Cocoa framework scaled will be running

00:33:23.200 --> 00:33:25.160
at some higher than 1.0 scale factor.

00:33:25.160 --> 00:33:27.840
So that's why we prefer for
you to ask for the scale factor

00:33:27.840 --> 00:33:29.510
on a window-by-window basis.

00:33:29.520 --> 00:33:35.400
If for some reason you need to find
out the global screen scale factor,

00:33:35.400 --> 00:33:38.910
we've got accessors for that as well.

00:33:40.920 --> 00:33:43.110
OK, so as you're testing,
you're going to run into a bunch of

00:33:43.110 --> 00:33:46.010
stuff that we've already run into,
and so we have some advice

00:33:46.010 --> 00:33:47.000
for how to deal with.

00:33:47.250 --> 00:33:49.260
Clearly,
there are bugs in the leopard seed.

00:33:49.260 --> 00:33:52.670
I already showed off that the scroll
bar doesn't have high-res artwork yet,

00:33:52.670 --> 00:33:55.220
and the segmented views
don't have high-res art.

00:33:55.250 --> 00:33:59.580
Another thing you'll probably run
into that happens more in Carbon apps

00:33:59.670 --> 00:34:03.780
than in Cocoa apps is window
jitteriness or menu jitteriness.

00:34:03.780 --> 00:34:07.070
There are some of our APIs that
have not yet been revved to

00:34:07.070 --> 00:34:09.480
support floating point coordinates.

00:34:09.780 --> 00:34:12.480
And floating point coordinates
are pretty critical to making

00:34:12.480 --> 00:34:14.000
resolution independence work.

00:34:14.050 --> 00:34:16.550
So you get various rounding
errors that compound,

00:34:16.550 --> 00:34:19.150
and sometimes windows grow
a little bit more than they

00:34:19.150 --> 00:34:22.460
should during a grow operation,
or sometimes when windows animate

00:34:22.460 --> 00:34:26.330
in and out of showing a toolbar,
they'll jitter size-wise and so forth.

00:34:26.400 --> 00:34:28.370
And you can see similar kinds
of things in the menu bar.

00:34:28.370 --> 00:34:31.090
So these are all things we plan to
fix by the time we ship the seed,

00:34:31.090 --> 00:34:33.980
but just be aware that you may
run into these as you're testing.

00:34:35.480 --> 00:34:39.400
There's another bug in
Carbon Windows where we did not correctly

00:34:39.400 --> 00:34:43.860
scale up the drag region for Windows,
for framework scaled Windows.

00:34:43.860 --> 00:34:46.930
I don't remember whether it happens
in magnified mode Windows as well.

00:34:46.930 --> 00:34:52.090
So if you have a Carbon app and you
flipped on framework scaling for that

00:34:52.100 --> 00:34:55.860
window and it's not dragging right,
just drag from the top left corner

00:34:55.920 --> 00:34:57.860
someplace and it should work.

00:34:58.470 --> 00:35:00.440
Another sort of annoying thing
that we haven't quite worked

00:35:00.440 --> 00:35:02.260
out are a few of our metrics.

00:35:02.300 --> 00:35:05.020
We have some text positioning
problems in high res.

00:35:05.020 --> 00:35:08.690
The push buttons and check boxes in
particular are the troubling ones.

00:35:08.700 --> 00:35:10.510
I think the text is
positioned a pixel too low.

00:35:10.510 --> 00:35:11.720
That's something we'll fix.

00:35:11.720 --> 00:35:13.930
Clearly that means as you're
laying out your applications,

00:35:13.930 --> 00:35:16.340
the text will look a little off
between various types of controls,

00:35:16.350 --> 00:35:17.210
but just ignore that.

00:35:17.210 --> 00:35:18.680
We'll get that fixed when we can.

00:35:22.020 --> 00:35:24.670
So the first sort of application
bug that you'll run into is

00:35:24.700 --> 00:35:26.250
a coordinate system mismatch.

00:35:26.370 --> 00:35:30.200
So before when I was talking about points
and pixels and applications generally

00:35:30.250 --> 00:35:33.580
not needing to know about pixels,
just needing about points, well,

00:35:33.720 --> 00:35:36.340
there are a few APIs that
already talked in point space,

00:35:36.420 --> 00:35:38.660
and your applications
need to be aware of that.

00:35:38.700 --> 00:35:41.330
Unfortunately,
on all previous operating systems,

00:35:41.450 --> 00:35:43.730
points mapped to pixels
at a one-to-one ratio.

00:35:43.730 --> 00:35:46.430
So you could get away with
passing points to these APIs,

00:35:46.430 --> 00:35:47.180
and it worked.

00:35:47.230 --> 00:35:49.400
Well,
when you're running in high res mode,

00:35:49.400 --> 00:35:51.920
it doesn't work in high res mode.

00:35:52.000 --> 00:35:52.770
It doesn't work anymore.

00:35:52.850 --> 00:35:56.090
So what you will see for some apps
or some windows in some apps is that

00:35:56.090 --> 00:35:59.410
the windows come up too small or clip
portions of the text and so forth.

00:35:59.410 --> 00:36:02.660
So in these cases,
you need to find out whether the API in

00:36:02.780 --> 00:36:07.060
particular you're using to size that
window is expecting points or pixels

00:36:07.060 --> 00:36:09.660
and pass the appropriate coordinates.

00:36:09.660 --> 00:36:14.560
And we have APIs that you can use to
convert between the point space and the

00:36:14.560 --> 00:36:17.430
pixel space for both Cocoa and Carbon.

00:36:21.890 --> 00:36:25.750
Now we know your applications
can't deploy on Leopard and later,

00:36:25.760 --> 00:36:27.800
particularly since we
haven't shipped Leopard.

00:36:27.860 --> 00:36:31.210
So as you're adopting some of the
new system controls and artwork,

00:36:31.250 --> 00:36:34.490
you're going to need probably to
do runtime checks for your adoption

00:36:34.680 --> 00:36:36.610
for some of the brand new things.

00:36:36.760 --> 00:36:41.110
But I think what you'll find is a lot
of the new system controls have actually

00:36:41.110 --> 00:36:43.570
been around for three or four releases.

00:36:43.570 --> 00:36:47.010
So you can probably get on board
those right away and deploy

00:36:47.010 --> 00:36:50.080
them with your existing apps,
because they're supported even pre-Tiger.

00:36:51.260 --> 00:36:53.300
Let's see.

00:36:53.300 --> 00:36:53.800
Oh, right.

00:36:53.800 --> 00:37:00.210
So NSImage has had multi-representation
TIFF file support for quite a long time.

00:37:00.370 --> 00:37:01.760
So you can rely on that.

00:37:01.760 --> 00:37:04.710
You can actually deploy
multi-representation

00:37:04.740 --> 00:37:06.700
TIFF files in your apps today.

00:37:06.850 --> 00:37:11.920
And it will work with NSImage so long
as you make sure that all the sizes

00:37:12.140 --> 00:37:14.940
of the individual reps are the same.

00:37:15.480 --> 00:37:18.820
But the pixel dimensions
are what's different.

00:37:19.010 --> 00:37:24.890
And that's what the Cat High DPI check
that you pass into Tiff Util validates.

00:37:24.960 --> 00:37:27.110
So if that's not true for your
two Tiff files that you're

00:37:27.130 --> 00:37:30.680
trying to merge into one,
Tiff Util will log to the console saying,

00:37:30.680 --> 00:37:32.590
hey,
you need to adjust this particular file

00:37:32.590 --> 00:37:35.550
because it's got the wrong resolution,
or so forth.

00:37:38.080 --> 00:37:40.700
OK, so another thing we have that
I think they mentioned at the

00:37:40.840 --> 00:37:43.990
State of the Union yesterday
is the notion of pixel cracks.

00:37:44.010 --> 00:37:46.060
This is another fairly common problem.

00:37:46.120 --> 00:37:51.670
Pixel cracks occur when you have a
bunch of smaller bitmaps that you

00:37:51.670 --> 00:37:55.240
use to assemble some larger control.

00:37:55.240 --> 00:37:59.620
You want to make sure those smaller
bitmaps align exactly together so

00:37:59.710 --> 00:38:01.870
you don't see gaps in the image.

00:38:02.530 --> 00:38:06.360
And generally, that works fantastic
at a 1.0 scale factor.

00:38:06.380 --> 00:38:08.640
But at non-integral scale
factors-- and it's kind of

00:38:08.640 --> 00:38:10.900
hard to see on that screenshot,
so I've got a bigger one-- at

00:38:10.900 --> 00:38:15.220
non-integral scale factors,
those integral pixel boundaries

00:38:15.710 --> 00:38:20.470
don't necessarily map-- sorry,
those integral point boundaries don't

00:38:20.470 --> 00:38:22.700
necessarily map to pixel boundaries.

00:38:22.870 --> 00:38:24.960
And therefore,
you get a little bit of anti-aliasing

00:38:24.960 --> 00:38:27.580
on the edges of your image draw,
which cause these lines--

00:38:27.660 --> 00:38:29.420
I don't know how visible it
is from the back of the room,

00:38:29.420 --> 00:38:35.300
but there's a couple vertical lines that
cut down the screenshot here because

00:38:35.300 --> 00:38:37.790
those images didn't quite line up right.

00:38:39.010 --> 00:38:42.290
So the way you fix this is
actually kind of challenging.

00:38:42.410 --> 00:38:45.480
I wanted to show this in the demo,
but it's so hard that we

00:38:45.690 --> 00:38:46.730
couldn't show it in the demo.

00:38:46.770 --> 00:38:49.930
The way you fix this is going to
be adopting some new APIs that we

00:38:49.930 --> 00:38:52.530
put out after the leopard seed.

00:38:52.600 --> 00:38:55.680
But essentially, conceptually,
what you do is when you're about

00:38:55.700 --> 00:38:58.040
to draw these two images and
you want to draw them aligned,

00:38:58.210 --> 00:39:00.780
you already have your
point-based rectangles that

00:39:00.780 --> 00:39:02.110
you're using to draw them.

00:39:02.220 --> 00:39:06.810
You need to convert those point-based
rectangles to pixel-based rectangles.

00:39:06.880 --> 00:39:11.000
Round the coordinates appropriately so
they fall on integral pixel boundaries.

00:39:11.100 --> 00:39:16.460
And then convert that rectangle back to
point space and draw into that rectangle.

00:39:16.490 --> 00:39:18.000
And that's how you fix these cracks.

00:39:18.050 --> 00:39:19.800
We've got a little bit of
sample code in the documentation

00:39:19.800 --> 00:39:21.240
that works for trivial cases.

00:39:21.350 --> 00:39:24.460
But as we found, it doesn't work for a
lot of the common cases,

00:39:24.460 --> 00:39:27.210
so we'll get that revved when we can.

00:39:29.310 --> 00:39:33.730
Apps that use OpenGL have a
unique problem to deal with.

00:39:33.800 --> 00:39:37.800
OpenGL is one of those
API sets that really wants to

00:39:37.810 --> 00:39:39.000
operate in terms of pixels.

00:39:39.000 --> 00:39:40.920
That's its API contract.

00:39:40.920 --> 00:39:44.860
So if you are taking your view,
and it's potentially an

00:39:44.860 --> 00:39:49.090
OpenGL view subclass,
or maybe you're a CarbonGL client,

00:39:49.090 --> 00:39:53.170
and you're taking your point
coordinates and saying,

00:39:53.180 --> 00:39:55.430
OpenGL,
please make me a surface this big.

00:39:55.460 --> 00:40:00.350
Well, if those point coordinates
map to more pixels,

00:40:00.350 --> 00:40:02.460
OpenGL doesn't know that.

00:40:02.700 --> 00:40:06.820
OpenGL just saw a request to
make a 100 by 100 rectangle.

00:40:06.820 --> 00:40:09.210
So it's going to make a 100
pixel by 100 pixel rectangle,

00:40:09.210 --> 00:40:10.470
which is going to look too small.

00:40:12.060 --> 00:40:16.510
So generally what you need to do is,
again, take the size of your rectangle,

00:40:16.660 --> 00:40:19.790
translate it from the point
space to the pixel space

00:40:19.810 --> 00:40:22.170
before calling the OpenGL APIs.

00:40:22.240 --> 00:40:26.550
And so this is a little bit of sample
code that would work in an NSOpenGL view

00:40:26.550 --> 00:40:29.110
subclasses reshape method to do that.

00:40:31.070 --> 00:40:36.170
In a few rare cases,
we've found that our bitmap art does not

00:40:36.220 --> 00:40:40.910
look as good as we want it to when it's
displayed at any arbitrary scale factor.

00:40:40.920 --> 00:40:44.120
So we're shipping bitmap art
in an application that's got

00:40:44.120 --> 00:40:46.240
a 1x version and a 4x version.

00:40:46.240 --> 00:40:49.400
When we're running at a
scale factor higher than 1.0,

00:40:49.400 --> 00:40:52.180
we take that 4x version
and we scale it down.

00:40:52.180 --> 00:40:55.580
So Core Graphics, of course,
does some interpolation on the image,

00:40:55.580 --> 00:40:58.520
and occasionally you
get some jaggy effects.

00:40:59.340 --> 00:41:02.480
To fix this, you need to switch on, well,
you can do two things.

00:41:02.480 --> 00:41:07.000
The easy way is to switch on higher
quality interpolation with Quartz.

00:41:07.000 --> 00:41:10.810
There's APIs from both the C-side
and the Objective C-side to do that.

00:41:10.860 --> 00:41:14.520
But the thing you need to realize is
that there is a performance overhead.

00:41:14.520 --> 00:41:16.410
Anytime Quartz does something
that's higher quality,

00:41:16.410 --> 00:41:18.000
it's going to take more processing power.

00:41:18.000 --> 00:41:20.130
So there's a little bit
of a tradeoff there.

00:41:20.140 --> 00:41:25.480
You may find that if you're using this
art in a very performance sensitive area,

00:41:25.480 --> 00:41:29.320
that you can't just ship a
1x version and a 4x version.

00:41:29.320 --> 00:41:32.990
You may need to ship other smaller
versions that match the particular

00:41:32.990 --> 00:41:34.750
scale factors you care about.

00:41:34.780 --> 00:41:38.460
So you might want to ship a 1x, a 2x,
and a 4x, for example.

00:41:38.460 --> 00:41:43.370
And that will allow you to make
pixel-perfect art for any scale factor.

00:41:47.800 --> 00:41:49.620
applications that use off-screens.

00:41:49.620 --> 00:41:51.540
Not a whole lot of them these days,
but a few do.

00:41:51.540 --> 00:41:54.990
Often you'll see it for apps that
magnify other portions of other

00:41:54.990 --> 00:41:57.300
applications or things of that nature.

00:41:57.300 --> 00:42:02.040
Applications that use off-screens
need to realize that your generation

00:42:02.070 --> 00:42:06.000
of an off-screen buffer doesn't
have any automatic framework

00:42:06.080 --> 00:42:08.740
support for the scale factor in it.

00:42:08.810 --> 00:42:09.470
It's your code.

00:42:09.470 --> 00:42:12.390
You're saying,
give me a buffer that's exactly this

00:42:12.390 --> 00:42:15.180
many pixels by this other pixel size.

00:42:15.180 --> 00:42:19.400
So it's up to your application code to
make sure you increase the dimensions

00:42:19.400 --> 00:42:22.550
you're requesting for your off-screen
buffer based on the scale factor.

00:42:24.120 --> 00:42:27.200
So this is one of the other places
on the system where you need to think

00:42:27.210 --> 00:42:31.330
in terms of pixels because that's
what the API contract already is.

00:42:33.130 --> 00:42:36.320
We've also found a few applications
that draw directly to the screen

00:42:36.320 --> 00:42:37.790
in various nefarious ways.

00:42:37.850 --> 00:42:39.040
And we don't like it.

00:42:39.140 --> 00:42:41.800
So stop doing it.

00:42:42.260 --> 00:42:46.330
There are lots of different ways you can
achieve the same kinds of effects from

00:42:46.340 --> 00:42:48.740
overlay windows and various other things.

00:42:48.740 --> 00:42:53.680
The ramification of drawing to the
screen is that your application

00:42:53.740 --> 00:42:57.920
will probably get thrown into
that small mode bucket by default.

00:42:57.920 --> 00:43:00.210
So that's not where you want to be.

00:43:00.230 --> 00:43:03.700
You really want to be scaled up like
everyone else because it looks good.

00:43:03.700 --> 00:43:06.390
So please stop drawing directly
to the screen if you're doing it.

00:43:07.320 --> 00:43:12.910
The classic example are applications
that do XORing as part of like

00:43:12.970 --> 00:43:16.180
a window resize operation.

00:43:16.200 --> 00:43:18.350
You know,
it may be an old Carbon application

00:43:18.510 --> 00:43:20.840
that isn't using our
normal window resize code,

00:43:20.840 --> 00:43:22.860
but they're still trying to
get the gray outline and it's

00:43:22.920 --> 00:43:24.110
doing screen-based XORing.

00:43:24.120 --> 00:43:26.540
You might find that when you're
running at a higher scale factor,

00:43:26.540 --> 00:43:29.940
the XOR is generating a much
smaller rectangle than you'd expect

00:43:29.960 --> 00:43:32.640
because that rectangle is being
actually interpreted in pixels,

00:43:32.640 --> 00:43:33.280
not points.

00:43:36.650 --> 00:43:43.190
Applications that support plugins
are a potential challenge.

00:43:43.320 --> 00:43:47.090
I don't have any super
concrete advice here other than

00:43:47.090 --> 00:43:48.580
offering a general approach.

00:43:48.750 --> 00:43:54.370
If you have a plugin API that
supports any notion of coordinates,

00:43:54.370 --> 00:43:58.430
you know, maybe it allows your plugin to
find out where the last mouse

00:43:58.500 --> 00:44:01.480
click was or it tells the plugin
to draw on a given rectangle,

00:44:01.480 --> 00:44:05.100
you need to define to your plugin
developers what coordinate space

00:44:05.100 --> 00:44:06.920
those points and rectangles are in.

00:44:06.990 --> 00:44:08.670
Are they in points or are they in pixels?

00:44:08.910 --> 00:44:11.390
It doesn't matter to me,
it matters to your plugin developers,

00:44:11.390 --> 00:44:13.320
so document that,
let them know so they can

00:44:13.480 --> 00:44:16.870
do the right thing in the
resolution independence modes.

00:44:16.920 --> 00:44:20.380
A harder case is plugin models
that support Quick Draw.

00:44:20.380 --> 00:44:22.790
Quick Draw can't be
resolution independent,

00:44:22.790 --> 00:44:24.850
so you need to rethink that plugin model.

00:44:24.850 --> 00:44:28.320
Maybe this is a great opportunity to
come up with a new plugin model that's

00:44:28.330 --> 00:44:32.820
more modern and you can get your plugin
developers migrated over to that path.

00:44:32.820 --> 00:44:36.030
If you absolutely have to support
these Quick Draw based plugins,

00:44:36.080 --> 00:44:39.170
that portion of your application
probably can't be resolution independent.

00:44:39.240 --> 00:44:41.820
There may be a few other ways.

00:44:41.890 --> 00:44:44.110
If you're really in this boat,
I'd love to hear from you if you can

00:44:44.110 --> 00:44:47.050
come up afterwards and let me know who
you are and what your plugin API is.

00:44:47.090 --> 00:44:49.640
I might have a few other ideas.

00:44:49.640 --> 00:44:54.070
We do something kind of similar
to this in the menu manager.

00:44:54.070 --> 00:44:58.140
We have some,
we support older menu definitions that

00:44:58.340 --> 00:45:03.040
are entirely Quick Draw based and we
can allow them to render into an off

00:45:03.040 --> 00:45:06.500
screen instead of actually rendering
to the window that's on screen.

00:45:06.570 --> 00:45:09.680
And then we scale up that off screen
image when we blit it to the screen.

00:45:09.680 --> 00:45:10.650
So this slows down menus.

00:45:10.650 --> 00:45:13.960
It doesn't get particularly great looking
menus and it propagates an older API that

00:45:13.960 --> 00:45:15.740
we'd love to get developers off of.

00:45:15.740 --> 00:45:17.880
So you may find yourselves
in a similar boat.

00:45:17.880 --> 00:45:21.770
It may just be time to come up with a new
plugin model for your plugin developers.

00:45:23.470 --> 00:45:28.240
OK, so I want to do two quick demos
of how you can adopt resolution

00:45:28.240 --> 00:45:30.160
independence in some apps.

00:45:30.160 --> 00:45:33.300
So if we could switch
over to the demo machine,

00:45:33.300 --> 00:45:35.170
that'd be great.

00:45:45.590 --> 00:45:50.190
So I have a little application we've
been working on here called Airport.

00:45:50.390 --> 00:45:54.390
Shows you the airport status for
a number of different airports.

00:45:55.330 --> 00:45:58.800
And it is a Cocoa application,
and I'm running in 1.0 scale factor,

00:45:58.800 --> 00:46:00.760
normal leopard, so it looks just fine.

00:46:00.760 --> 00:46:05.220
This application has two things
to pay attention to real quickly.

00:46:05.220 --> 00:46:09.500
It's got this custom view up at
the top that says airport status.

00:46:09.500 --> 00:46:12.960
You know, you can think of that as the
application's logo or maybe my

00:46:12.960 --> 00:46:14.770
company's logo or something like that.

00:46:14.800 --> 00:46:16.280
And it has the list of airports.

00:46:16.280 --> 00:46:20.200
That list of airports is supposed
to automatically size so that you

00:46:20.200 --> 00:46:22.440
can see all the airports on launch.

00:46:22.440 --> 00:46:24.130
So let me quit this app.

00:46:25.020 --> 00:46:27.510
crank up the scale factor.

00:46:28.730 --> 00:46:31.280
And rerun.

00:46:31.280 --> 00:46:34.420
OK, so I can immediately see one problem.

00:46:34.420 --> 00:46:36.700
The window is not sized properly.

00:46:36.700 --> 00:46:39.780
The scroll bar is showing-- so I can
still get to the content of the airports,

00:46:39.780 --> 00:46:43.060
but really I wanted that window to
show all the airports by default.

00:46:43.060 --> 00:46:47.080
So this is a classic case
of a coordinate mismatch,

00:46:47.080 --> 00:46:51.060
where my application is sizing
a window based on points,

00:46:51.060 --> 00:46:54.650
but the window sizing API I'm
using actually wants to

00:46:54.650 --> 00:46:55.740
operate in terms of pixels.

00:46:55.810 --> 00:46:59.420
So let's fix that real quick.

00:46:59.440 --> 00:47:02.320
Go into my Xcode project.

00:47:03.600 --> 00:47:06.140
And OK,
so I've got a method here called set

00:47:06.150 --> 00:47:10.170
ideal window frame where I calculate
the appropriate height for the list,

00:47:10.290 --> 00:47:13.200
figure out a delta,
and then apply that delta

00:47:13.260 --> 00:47:15.570
to the window frame size.

00:47:15.840 --> 00:47:17.220
Ignore the commented out code for now.

00:47:17.220 --> 00:47:17.800
That's the fix.

00:47:17.840 --> 00:47:21.520
So what I was doing is I was
getting the window frame,

00:47:21.540 --> 00:47:25.350
increasing the height of the
window frame by the delta

00:47:25.350 --> 00:47:27.690
that the list needed to grow.

00:47:28.100 --> 00:47:30.270
And then I set the Windows frame to that.

00:47:30.410 --> 00:47:33.300
Well,
it just so happens that the set frame

00:47:33.420 --> 00:47:39.150
API expects the size to be in pixels,
not in points,

00:47:39.240 --> 00:47:41.780
whereas my list height delta
was actually in points.

00:47:41.780 --> 00:47:44.440
So I can do a fairly simple
conversion to fix that.

00:47:44.440 --> 00:47:49.460
The first thing I do after getting
the window frame from the window,

00:47:49.460 --> 00:47:54.120
I convert that frame from window
coordinates to my views coordinates.

00:47:54.120 --> 00:47:56.740
And then I apply the delta.

00:47:58.200 --> 00:48:00.630
And then I convert back
to window coordinates,

00:48:00.630 --> 00:48:01.820
which are pixels.

00:48:02.090 --> 00:48:04.730
So if I run that now,

00:48:06.430 --> 00:48:07.860
The list comes up sized properly.

00:48:07.940 --> 00:48:10.800
So this is probably the most common
problem you'll see in your applications,

00:48:10.800 --> 00:48:12.770
is your windows don't show
up the right size initially.

00:48:12.910 --> 00:48:14.680
So those are usually really easy to fix.

00:48:14.810 --> 00:48:17.490
Now one thing that's harder to see--

00:48:17.740 --> 00:48:19.540
are some pixel cracks.

00:48:19.590 --> 00:48:21.370
Well, let's do first things first.

00:48:21.450 --> 00:48:25.970
So on Pixie,
I'm zoomed in on the artwork for

00:48:25.980 --> 00:48:27.900
this image behind the airport status.

00:48:28.040 --> 00:48:29.830
And I can see two problems.

00:48:30.110 --> 00:48:33.500
One, I can see I have old artwork
that's being scaled up.

00:48:33.500 --> 00:48:35.300
And so it's a little anti-aliased.

00:48:35.310 --> 00:48:38.570
It's somewhat hard to tell from
both the screen up there in Pixie.

00:48:38.610 --> 00:48:39.960
But as I stand here and
look at the monitor,

00:48:39.960 --> 00:48:41.080
I can see it pretty clearly.

00:48:41.080 --> 00:48:42.560
It's scaling up old art.

00:48:42.660 --> 00:48:43.780
And I don't really want that.

00:48:43.780 --> 00:48:45.360
I'd much rather have crisp art.

00:48:45.380 --> 00:48:48.300
Now in Pixie,
one thing you can see is that there is

00:48:48.300 --> 00:48:54.620
a vertical line cutting down just to
the right of the curve on the placard.

00:48:54.880 --> 00:48:57.420
And that's a classic
example of a pixel crack.

00:48:57.420 --> 00:49:00.360
It's also happening on the right
side of the widget as well.

00:49:00.460 --> 00:49:03.330
So that's because I'm drawing this--

00:49:07.390 --> 00:49:10.110
So, first things first.

00:49:10.150 --> 00:49:16.080
Let's go ahead and fix the
art so we have high res art.

00:49:16.310 --> 00:49:21.750
I'll crank the scale factor down real
quick so the other apps are usable.

00:49:21.860 --> 00:49:24.390
So, I go through my applications bundle.

00:49:24.400 --> 00:49:25.360
I find the art.

00:49:25.380 --> 00:49:28.600
I either rev it myself
or I talk to an H.I.

00:49:28.600 --> 00:49:29.900
design company or my own H.I.

00:49:29.900 --> 00:49:32.400
designers and say, please give me higher
resolution versions of this art.

00:49:32.400 --> 00:49:34.400
And let's see.

00:49:34.400 --> 00:49:37.390
They give me back this.

00:49:37.480 --> 00:49:42.880
They give me back a set
of six pieces of art with

00:49:43.230 --> 00:49:47.320
One X version for a given piece
and the four X version for a

00:49:47.320 --> 00:49:51.090
given piece for both the left,
the middle,

00:49:51.370 --> 00:49:57.090
So, what I need to do is I need to
run UserBin TiffUtil on this

00:49:57.350 --> 00:50:02.520
to take these multiple Tiffs
and merge them into -- sorry,

00:50:02.520 --> 00:50:05.250
multiple Tiffs for just one piece.

00:50:05.270 --> 00:50:07.720
So, I'm going to take the two left
pieces and merge them into a

00:50:07.720 --> 00:50:09.300
single file using TiffUtil.

00:50:09.300 --> 00:50:11.500
I'm going to do the same thing
for the middle and the right.

00:50:11.570 --> 00:50:14.330
So, let me show you how that works.

00:50:19.300 --> 00:50:20.060
Oh, you know what?

00:50:20.060 --> 00:50:23.340
Let's relaunch terminal with a higher
scale factor so you can actually read it.

00:50:23.340 --> 00:50:29.180
Is that readable?

00:50:29.180 --> 00:50:30.620
OK.

00:50:33.900 --> 00:50:39.500
[Transcript missing]

00:50:41.440 --> 00:50:43.180
Okay, what am I doing wrong here?

00:50:43.370 --> 00:50:46.180
Why is that not-- there we go.

00:50:46.190 --> 00:50:49.580
Okay,
so I have these six different pieces.

00:50:49.660 --> 00:50:53.250
What I'm going to do is I'm going to
merge the 1x version of the left slice

00:50:53.280 --> 00:50:55.560
with the 4x version of the left slice.

00:50:55.630 --> 00:51:05.180
So call tiffytil with cat high DPI check,
pass in the two pieces that

00:51:05.210 --> 00:51:08.150
I want to merge together.

00:51:09.400 --> 00:51:16.740
I just want it to be called slices
left TIFF because that's the name

00:51:16.740 --> 00:51:19.080
of the file I already had in my
bundle and I just want to be able

00:51:19.080 --> 00:51:22.590
to take this multi-ref TIFF file and
replace the old file in my bundle.

00:51:22.600 --> 00:51:26.670
And so I run it and it tells me
two images were written to slices

00:51:26.680 --> 00:51:29.100
left.TIFF and I'm glad it said that.

00:51:29.100 --> 00:51:33.590
It didn't tell me any errors so I know
my HI designers did the artwork right.

00:51:33.940 --> 00:51:35.760
And so I would do that
for the other two pieces,

00:51:35.860 --> 00:51:38.500
but I'm going to save the typing because,
as you can see,

00:51:38.500 --> 00:51:41.040
I'm not a great typist when I'm miked.

00:51:41.200 --> 00:51:47.980
So I already pre-merged the multi-rep
TIFF files into single files.

00:51:48.040 --> 00:51:52.490
I'm going to copy them into my
images that's part of the project.

00:51:52.650 --> 00:51:53.930
Let me make sure I copied all three.

00:51:54.020 --> 00:51:58.020
This has got-- oops.

00:51:58.070 --> 00:52:00.450
And we get to use Finder in high res.

00:52:02.370 --> 00:52:05.820
had problems not actually
replacing everything.

00:52:05.830 --> 00:52:07.110
So let's replace them.

00:52:07.240 --> 00:52:09.720
Go back into Xcode.

00:52:11.800 --> 00:52:14.940
Clean out all the objects.

00:52:15.010 --> 00:52:16.810
Rebuild.

00:52:19.610 --> 00:52:20.860
And oh, you know what?

00:52:20.880 --> 00:52:21.870
It did not replace it.

00:52:21.920 --> 00:52:22.960
So I had my copy bug.

00:52:22.960 --> 00:52:25.650
Well, let's ignore that bad looking art
on the right side of the status bar.

00:52:25.760 --> 00:52:28.680
So I've clearly got higher
res art that I'm using now,

00:52:28.680 --> 00:52:30.540
and that's fantastic.

00:52:30.790 --> 00:52:33.000
Now, there were also those pixel
cracks that I showed you.

00:52:33.000 --> 00:52:34.470
And like I said,
fixing some of these pixel

00:52:34.570 --> 00:52:35.610
cracks are non-trivial.

00:52:35.760 --> 00:52:38.570
So I'm just going to wait for
the new APIs that come out in a

00:52:38.570 --> 00:52:41.190
later Leopard Seed to fix that.

00:52:41.580 --> 00:52:42.480
So that's that app.

00:52:42.560 --> 00:52:46.700
So it actually is pretty easy to
get most application content working

00:52:46.710 --> 00:52:48.130
in resolution independence mode.

00:52:48.250 --> 00:52:50.660
Let's look at another interesting case.

00:52:50.700 --> 00:52:52.850
Close this.

00:52:53.050 --> 00:52:59.610
There is a piece of existing Cocoa sample
code that can run a full screen--

00:53:02.090 --> 00:53:04.970
OpenGL animation.

00:53:05.010 --> 00:53:08.710
Let's run it at 1.0 so you
can see what it looks like.

00:53:12.470 --> 00:53:15.050
So it's a spinning globe,
and you can change the light source

00:53:15.050 --> 00:53:18.290
and move the globe around a little bit.

00:53:18.320 --> 00:53:20.580
And it's just showing off some
various OpenGL functionality

00:53:20.580 --> 00:53:21.860
and full screen mode.

00:53:21.860 --> 00:53:23.380
We're not concerned about
the full screen mode.

00:53:23.380 --> 00:53:26.000
I just want to show you what happens when
you run this at a higher scale factor.

00:53:26.000 --> 00:53:31.180
So we'll quit it,
set the scale factor to 2, and run.

00:53:31.260 --> 00:53:33.020
And you get that.

00:53:33.030 --> 00:53:35.200
Your animation did not
actually increase in size,

00:53:35.290 --> 00:53:36.940
and it's in the wrong
place in your window.

00:53:37.010 --> 00:53:39.280
This is the classic OpenGL problem.

00:53:39.310 --> 00:53:41.740
This tells me I need to
change the coordinates I'm

00:53:41.740 --> 00:53:43.920
passing to the OpenGL APIs.

00:53:44.000 --> 00:53:47.400
And as it turns out,
that's actually really simple.

00:53:49.100 --> 00:53:56.640
Let's go to... Okay,
so that's not the one I want.

00:53:58.600 --> 00:54:01.540
I have my OpenGL subclass.

00:54:01.540 --> 00:54:07.700
I have a reshape method that
currently calls setViewportRect,

00:54:07.720 --> 00:54:12.740
which is a method on another class
that I've got that wraps OpenGL.

00:54:14.110 --> 00:54:16.240
with-- sorry,
let's look at this a little bit closely.

00:54:16.260 --> 00:54:19.570
I get the views bounds,
and I pass that directly

00:54:20.180 --> 00:54:22.380
to setViewportRect.

00:54:24.140 --> 00:54:29.350
takes that rectangle and calls
GL viewport with that rectangle.

00:54:29.400 --> 00:54:33.990
Just so happens that GL viewport is one
of the OpenGL APIs that expects pixel

00:54:33.990 --> 00:54:35.670
coordinates for the height and width.

00:54:35.750 --> 00:54:38.710
So I need to fix that in my call site.

00:54:38.790 --> 00:54:42.210
So what I'm going to do
is I'm going to fetch--

00:54:42.340 --> 00:54:43.940
GUY FALLEN:
So I'm going to set my view's bounds.

00:54:43.980 --> 00:54:47.860
And then I'm going to convert
those bounds from my own view's

00:54:47.880 --> 00:54:51.240
coordinate system to the nil view,
or to the Windows coordinate system.

00:54:51.240 --> 00:54:53.580
And the Windows coordinate
system is inherently pixels.

00:54:53.850 --> 00:54:57.160
Sorry, and I'm actually just
converting the size.

00:54:57.210 --> 00:55:02.130
And then I'm going to pass that
converted rectangle to set viewport rect.

00:55:03.700 --> 00:55:30.200
[Transcript missing]

00:55:37.170 --> 00:55:39.160
So this is pretty straightforward stuff.

00:55:39.260 --> 00:55:42.260
I mean, yes, it is some effort,
but it's going to have some big payoff.

00:55:42.380 --> 00:55:44.940
Like we said, in the State of the Union,
we want your apps to be

00:55:44.940 --> 00:55:47.400
resolution independent by 2008.

00:55:47.490 --> 00:55:50.370
So start working on it now.

00:55:50.450 --> 00:55:53.940
When you're revving your artwork,
stick to the vector formats when you can.

00:55:53.980 --> 00:55:56.120
If you have to use bitmaps,
make sure you've got multiple

00:55:56.120 --> 00:55:58.080
resolutions of those bitmaps.

00:55:58.180 --> 00:56:02.460
For Carbon developers,
we have the requirement that

00:56:02.530 --> 00:56:06.190
you get off of Quick Draw,
get on to compositing mode,

00:56:06.190 --> 00:56:09.790
and we also have a few other
Carbon sessions dealing with

00:56:09.790 --> 00:56:11.720
some of those subjects in detail.

00:56:11.720 --> 00:56:15.170
I don't list them all here.

00:56:15.530 --> 00:56:16.330
Well, let's just start from the top.

00:56:16.400 --> 00:56:20.640
We've got an awesome document that talks
in more detail about how your application

00:56:20.640 --> 00:56:22.680
can adopt resolution independence.

00:56:22.680 --> 00:56:24.880
It's on the attendee website.

00:56:24.950 --> 00:56:27.740
It goes into more detail on a lot
of the subjects I only glossed over.

00:56:27.740 --> 00:56:35.570
The Cocoa Session 106 talks about more
high DPI adoption stuff for Cocoa apps.

00:56:35.570 --> 00:56:40.360
The session immediately following this
in this room is a Carbon session on,

00:56:40.670 --> 00:56:44.100
among other things,
how to take advantage of resolution

00:56:44.100 --> 00:56:45.150
independence in a Carbon app.

00:56:45.500 --> 00:56:48.070
And for Java, there's another session
on performance tuning,

00:56:48.070 --> 00:56:49.930
your Java application,
where they talk about

00:56:49.930 --> 00:56:51.280
resolution independence.

00:56:51.280 --> 00:56:56.600
We also have some carbon-based
sessions for integrating with Cocoa,

00:56:56.600 --> 00:57:00.000
and particularly NS Cursor and NS Image.

00:57:00.000 --> 00:57:02.320
And those will be useful for
Carbon apps that want to become

00:57:02.360 --> 00:57:05.150
resolution independent and take
advantage of NS Image and NS Cursor.

00:57:05.150 --> 00:57:08.130
So make sure you check those out as
well if you're a Carbon developer.
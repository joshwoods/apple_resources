WEBVTT

00:00:10.230 --> 00:00:11.380
- Good afternoon.

00:00:11.500 --> 00:00:12.990
Thank you so much for coming today.

00:00:13.000 --> 00:00:15.070
I really appreciate seeing you all here.

00:00:15.130 --> 00:00:16.880
It's really great.

00:00:16.880 --> 00:00:19.850
I hope to keep the momentum
of what has really,

00:00:19.900 --> 00:00:22.660
I think,
been just a spectacular WWDC so far.

00:00:22.720 --> 00:00:24.470
Do you agree?

00:00:28.610 --> 00:00:31.640
What I'm going to talk about
is all the tools you need,

00:00:31.640 --> 00:00:36.260
all the tools you need to make great
applications worthy of Mac OS X.

00:00:36.260 --> 00:00:39.380
And we've been working very hard
to make Mac OS X worthy for your

00:00:39.380 --> 00:00:41.200
creativity and your innovation.

00:00:41.240 --> 00:00:44.940
And I think you'll find that we
have had really just a fabulous

00:00:44.940 --> 00:00:48.200
time and really enjoy doing it,
creating applications,

00:00:48.240 --> 00:00:52.250
creating the tools that you're going
to use to create the next generation

00:00:52.250 --> 00:00:54.180
of wonderful Mac OS X applications.

00:00:55.120 --> 00:00:59.350
And to do that, I've been thinking about
what makes a good metaphor.

00:00:59.490 --> 00:01:02.360
And we build on a great heritage,
a wonderful heritage of

00:01:02.360 --> 00:01:05.970
terrific development tools,
terrific development environments.

00:01:06.000 --> 00:01:08.600
Going back to Smalltalk and
Xerox PARC and Cedar and all

00:01:08.710 --> 00:01:11.910
kinds of really great programming
languages and environments.

00:01:11.920 --> 00:01:16.320
And really when I break it down,
I break it down into about five columns,

00:01:16.320 --> 00:01:18.770
five pillars of development tools.

00:01:18.800 --> 00:01:20.950
The first one, I think of is scalability.

00:01:20.950 --> 00:01:22.740
Do the tools scale to meet your needs?

00:01:22.740 --> 00:01:24.800
And then the second, productivity.

00:01:25.120 --> 00:01:28.700
Are you actually
productive using the tools?

00:01:28.700 --> 00:01:32.870
Do you get and feel that you're maximally
that your time is well spent using

00:01:32.870 --> 00:01:35.340
these kinds of tools and environments?

00:01:36.840 --> 00:01:38.390
The third one is performance.

00:01:38.650 --> 00:01:40.790
Thinking about the performance
of your application,

00:01:40.790 --> 00:01:43.240
the performance of what you get
out of the processor and out of

00:01:43.240 --> 00:01:46.960
all the other systems that go in
to creating great applications.

00:01:46.960 --> 00:01:49.970
Performance is an
ongoing thought process.

00:01:49.970 --> 00:01:53.730
It starts at the architectural
phase and continues right through to

00:01:53.730 --> 00:01:56.090
completion and finishing your product.

00:01:56.180 --> 00:01:58.230
And then interoperability.

00:01:58.290 --> 00:02:01.360
Does your application interoperate well?

00:02:01.480 --> 00:02:04.460
We provide many APIs and frameworks
so that your application can play

00:02:04.460 --> 00:02:06.370
well with all the other applications.

00:02:06.620 --> 00:02:09.980
Your application exists in an
ecosystem of many applications.

00:02:09.980 --> 00:02:13.500
And the payoff is that your users,
the customers,

00:02:13.500 --> 00:02:16.950
have many applications they are
going to use to get their work

00:02:16.950 --> 00:02:18.690
done or enjoy what they do.

00:02:18.700 --> 00:02:21.270
And so you have to think about
the interoperability and the

00:02:21.390 --> 00:02:22.860
tools have a role to play there.

00:02:22.920 --> 00:02:27.520
The final one I'm going to
hold for later because it's,

00:02:27.520 --> 00:02:29.400
keep it for the end.

00:02:31.740 --> 00:02:32.870
So, scalability.

00:02:32.970 --> 00:02:35.130
Scalability, well, two parts to that.

00:02:35.180 --> 00:02:36.780
Xcode scalability.

00:02:36.780 --> 00:02:38.440
Does Xcode scale for your needs?

00:02:38.440 --> 00:02:40.120
Let's take a look at
where we've come from.

00:02:40.120 --> 00:02:42.060
And data scalability.

00:02:42.060 --> 00:02:44.340
And we've already
spoken a bit about that.

00:02:44.370 --> 00:02:45.460
Let's jump right in.

00:02:45.580 --> 00:02:51.940
So, last year when we met at WWDC 2005,
we introduced Xcode 2.1,

00:02:51.940 --> 00:02:53.520
the Universal IDE.

00:02:53.520 --> 00:02:56.890
And this was a development environment,
of course,

00:02:56.890 --> 00:03:01.690
that could scale to two architectures,
to PowerPC and to the Intel CPUs.

00:03:01.730 --> 00:03:05.720
And these architectures and making it
easy and simple to do was a big part of,

00:03:05.740 --> 00:03:07.640
of course, the mission there.

00:03:07.640 --> 00:03:10.730
And we've been working a number of years
to create tools that made it simple.

00:03:10.740 --> 00:03:13.480
And the whole universal architecture,
universal binaries,

00:03:13.610 --> 00:03:15.400
all the other products and technologies.

00:03:15.580 --> 00:03:18.890
to make that as convenient as possible.

00:03:19.300 --> 00:03:55.300
[Transcript missing]

00:03:56.760 --> 00:04:00.010
We also in Xcode 2.3,
actually in previous versions of Xcode,

00:04:00.140 --> 00:04:01.690
we had distributed builds.

00:04:01.720 --> 00:04:07.380
Now, the primary purpose of distributed
builds prior to Xcode 2.3 was to make

00:04:07.380 --> 00:04:11.340
use of ad hoc networks of computers
that you might have around you and your

00:04:11.340 --> 00:04:13.660
colleagues around the local area network.

00:04:14.020 --> 00:04:18.710
But we had a lot of requests for being
able to use dedicated forms of machines.

00:04:18.720 --> 00:04:21.680
And really,
this CC-based technologies that the

00:04:21.800 --> 00:04:26.600
distributed build mechanism was based
on only scaled to about six machines.

00:04:26.600 --> 00:04:28.480
And after that,
adding additional computers

00:04:28.480 --> 00:04:29.470
really didn't help.

00:04:29.480 --> 00:04:32.680
Well, we broke through that with
Xcode 2.3 with a feature we

00:04:32.680 --> 00:04:34.360
call dedicated network builds.

00:04:34.360 --> 00:04:36.930
And it really more than doubled,
even quadrupled.

00:04:36.950 --> 00:04:39.140
In fact, it really scales linearly.

00:04:39.140 --> 00:04:41.400
So there's no limit to the
number of machines you can add.

00:04:41.450 --> 00:04:43.960
It really depends upon the
scale and the amount of code.

00:04:43.960 --> 00:04:45.590
you have.

00:04:46.600 --> 00:04:49.760
and today,
today of course we heard the count.

00:04:49.790 --> 00:04:52.740
And we're very pleased to say that there
are over 3,000 universal applications

00:04:52.740 --> 00:04:54.330
and I want to thank you for that.

00:04:54.410 --> 00:04:59.000
And it's really been a tremendous work
you've done to make this possible.

00:04:59.000 --> 00:05:05.690
And so to thank you for that,
I've got a surprise for you at

00:05:05.690 --> 00:05:05.690
the end of the presentation.

00:05:08.470 --> 00:05:11.850
We also are releasing Xcode
2.4 with 64-bit tool support.

00:05:11.880 --> 00:05:15.840
And this, of course,
completes for the Intel processor,

00:05:15.840 --> 00:05:20.160
completes and does it really just
as we've done for Tiger last year to

00:05:20.260 --> 00:05:23.290
provide 64-bit support for the G5.

00:05:23.290 --> 00:05:26.310
We now provide it for Intel as well.

00:05:27.170 --> 00:05:30.560
I want to actually reflect
how build times have improved

00:05:30.790 --> 00:05:32.000
since we started with Xcode.

00:05:32.000 --> 00:05:33.520
And we use Finder.

00:05:33.520 --> 00:05:36.310
It's a large C++ Carbon application,
like a lot of large

00:05:36.320 --> 00:05:37.430
applications out there.

00:05:37.440 --> 00:05:42.700
And really what we've seen is
a nice steady shrink of the

00:05:42.710 --> 00:05:46.140
amount of time it takes to build.

00:05:46.140 --> 00:05:51.060
On laptops, for example,
it went from 809 seconds to 113 seconds.

00:05:51.530 --> 00:05:55.500
And a lot of this is because Xcode is
using an architecture that's really

00:05:55.500 --> 00:05:58.710
well designed for multiprocessors
and scales extremely well.

00:05:58.760 --> 00:06:01.130
And of course, as you would expect,
that works even better

00:06:01.130 --> 00:06:02.200
for quad processors.

00:06:02.200 --> 00:06:06.480
And so going from Xcode 1 to
Xcode 2.4 today on the Mac Pro,

00:06:06.480 --> 00:06:09.970
really we've seen between
a 7 and 8 load improvement.

00:06:10.030 --> 00:06:14.110
So it's been a wonderful experience
in having the architecture and

00:06:14.110 --> 00:06:17.910
the hardware and the software
really mate very well for it.

00:06:18.010 --> 00:06:20.600
And Xcode takes advantage
of the processors.

00:06:21.340 --> 00:06:24.050
And much of, as I think,
your applications need to be

00:06:24.050 --> 00:06:27.260
designed with the multiprocessor
architectures in mind.

00:06:27.260 --> 00:06:29.200
Xcode has had that since the beginning.

00:06:31.100 --> 00:06:31.860
So what's next?

00:06:31.890 --> 00:06:36.300
How do we follow this great run
of technologies and services and

00:06:36.300 --> 00:06:38.620
applications that have come along?

00:06:38.620 --> 00:06:41.040
Well, of course, Leopard is next.

00:06:41.040 --> 00:06:42.080
Leopard is next.

00:06:42.130 --> 00:06:45.480
And with Leopard, of course,
comes the fruition of a full,

00:06:45.490 --> 00:06:47.310
complete 64-bit stack.

00:06:47.330 --> 00:06:51.570
And we've designed a lot of the features
into the next generation of Xcode,

00:06:51.570 --> 00:06:54.030
which we, of course, call Xcode 3.

00:06:54.580 --> 00:06:57.250
Xcode 3 is on the DVDs you have.

00:06:57.300 --> 00:07:01.670
And it's a really great technology
and has so many important features.

00:07:01.710 --> 00:07:04.830
I'm only going to be able to,
I only have time today to

00:07:04.830 --> 00:07:08.260
tell you about a few of them,
but the sessions really will

00:07:08.260 --> 00:07:10.550
detail and go into great detail.

00:07:10.560 --> 00:07:14.780
Of course, we give you the checkbox,
so simple to build for 32-bit and

00:07:14.780 --> 00:07:17.200
64-bit universal applications.

00:07:17.200 --> 00:07:21.800
And we provide you with all the
languages to be 64-bit compatible.

00:07:21.800 --> 00:07:26.670
So that this is a very,
another great new capability for

00:07:26.780 --> 00:07:27.840
you to add to your applications.

00:07:27.860 --> 00:07:31.460
As you also have heard,
all the frameworks.

00:07:31.460 --> 00:07:37.200
So really,
a big part of the data scalability that

00:07:37.340 --> 00:07:41.290
I think is extremely important that you
need to use to make your applications

00:07:41.290 --> 00:07:44.520
take full advantage of the processor
are going to be in these frameworks.

00:07:44.520 --> 00:07:47.790
And one I'd like to mention and
call out that probably doesn't get

00:07:47.790 --> 00:07:49.590
a lot of attention is Core Data.

00:07:49.620 --> 00:07:53.270
Core Data is extremely simple to use,
and it scales to exabytes of data.

00:07:53.280 --> 00:07:54.560
It provides you with a lot of data.

00:07:54.580 --> 00:07:56.960
It's a tremendous capabilities,
both on 32-bit,

00:07:57.130 --> 00:07:58.960
but even better on 64-bit architectures.

00:08:00.440 --> 00:08:04.160
One application,
which since we brought Java up,

00:08:04.190 --> 00:08:07.310
it comes right up,
and since Java is designed

00:08:07.310 --> 00:08:09.700
to use a portable bytecode,
it doesn't encode any of

00:08:09.700 --> 00:08:11.080
the processes inside of it.

00:08:11.270 --> 00:08:14.000
Some applications that
make use of a lot of data,

00:08:14.000 --> 00:08:18.270
like GeneSpring,
which is a 64-bit application in

00:08:18.450 --> 00:08:23.110
Java that runs well in 32-bit as well,
but in fact in Java, of course,

00:08:23.150 --> 00:08:26.090
we don't even think
about the address size.

00:08:26.140 --> 00:08:29.310
It just came right up and works,
and I think you'll find that your

00:08:29.550 --> 00:08:33.780
Java applications will be able to make
use of 64-bit right out of the box.

00:08:36.900 --> 00:08:38.840
Now let's turn to productivity.

00:08:39.020 --> 00:08:39.850
Productivity.

00:08:39.850 --> 00:08:43.370
So productivity, of course,
is a big part of why you're here,

00:08:43.370 --> 00:08:47.820
to hear about the productivity
improvements in development environments.

00:08:47.820 --> 00:08:50.360
And really,
we want to provide you with tools

00:08:50.370 --> 00:08:52.320
that streamline your workflow.

00:08:52.320 --> 00:08:53.970
Streamline your workflow.

00:08:54.000 --> 00:08:57.210
And I think the very important
part of that is really a more

00:08:57.210 --> 00:08:59.380
productive programming language.

00:08:59.380 --> 00:09:02.530
And really,
it means about solving problems faster.

00:09:02.530 --> 00:09:06.400
So it's the tools and the
programming language together.

00:09:06.400 --> 00:09:07.750
Working extremely well.

00:09:07.860 --> 00:09:10.700
And of course, when we talk about a more
productive programming language,

00:09:10.700 --> 00:09:11.790
you know what we have in mind.

00:09:11.820 --> 00:09:20.670
We face, Apple faces Goliath competition.

00:09:21.370 --> 00:09:25.390
And in facing that Goliath competition,
we really need to do that

00:09:25.470 --> 00:09:28.540
with a better technology.

00:09:28.540 --> 00:09:32.050
And the better technology is Objective C.

00:09:37.790 --> 00:09:42.310
Now, what is it about Objective-C that
makes it so great?

00:09:42.510 --> 00:09:44.190
It partly, it's dynamism.

00:09:44.470 --> 00:09:49.440
It's partly that it does interact
extremely well with C and C++.

00:09:49.450 --> 00:09:53.240
And partly that it mates
very well with tools.

00:09:53.290 --> 00:09:56.380
Because of the metadata model
that is part of the class

00:09:56.380 --> 00:09:58.360
hierarchy and the structures,
the fact that it has

00:09:58.360 --> 00:10:00.970
a runtime type system,
the fact that all these technologies

00:10:00.980 --> 00:10:05.210
mate extremely well together,
it really does make Objective-C really

00:10:05.210 --> 00:10:07.370
into an incredibly powerful weapon.

00:10:07.510 --> 00:10:12.730
And it allows us to get work done
to beat competition that's really an

00:10:12.730 --> 00:10:16.660
order of magnitude larger than us,
and to do it by writing less code,

00:10:16.660 --> 00:10:18.860
writing less code,
so that small teams can

00:10:18.860 --> 00:10:22.790
be extremely effective,
extremely effective in getting

00:10:22.790 --> 00:10:26.080
the same amount of functionality,
or in many cases more functionality,

00:10:26.110 --> 00:10:27.230
with fewer people.

00:10:27.340 --> 00:10:30.370
And that really is, of course,
a big part of what technology is about.

00:10:30.440 --> 00:10:34.480
And so Objective-C really has
served Apple extremely well.

00:10:34.480 --> 00:10:37.310
And so in thinking about it,
there's a lot of tech-- a

00:10:37.500 --> 00:10:40.180
lot of capabilities here,
which I believe that if you

00:10:40.200 --> 00:10:42.830
haven't used Objective-C yet,
it's a great opportunity here

00:10:42.830 --> 00:10:43.920
at the conference to learn.

00:10:44.130 --> 00:10:47.330
And of course, we're improving this.

00:10:47.460 --> 00:10:50.640
You heard Bertrand talk this
morning about garbage collection.

00:10:50.680 --> 00:10:52.770
There's two other important features
I'm going to talk about today,

00:10:52.860 --> 00:10:54.280
properties and iteration.

00:10:54.280 --> 00:10:58.130
Garbage collection, though,
is a key factor.

00:10:58.130 --> 00:11:03.430
But of course, I don't think you should
just hear it from me.

00:11:03.430 --> 00:11:06.760
I'd also like to invite up
someone else to tell you about

00:11:06.760 --> 00:11:08.840
Objective-C and its virtues.

00:11:08.840 --> 00:11:12.400
This is Ken Case from the Omni Group.

00:11:12.400 --> 00:11:14.180
Please welcome.

00:11:14.180 --> 00:11:15.950
Thank you, Ted.

00:11:15.950 --> 00:11:16.770
Hi, there.

00:11:19.300 --> 00:11:21.830
Thank you, everyone.

00:11:21.940 --> 00:11:23.640
Small teams.

00:11:23.680 --> 00:11:26.530
It's amazing what you can
accomplish with small teams when

00:11:26.530 --> 00:11:28.890
you give them the right tools.

00:11:30.500 --> 00:11:35.410
At the Omni Group, we have 12 developers
and we have six products.

00:11:35.600 --> 00:11:40.340
You may have heard of some of them,
OmniWeb, OmniOutliner, OmniGraffle,

00:11:40.340 --> 00:11:46.010
and this summer we introduced two more,
OmniDazzle and our latest OmniPlan.

00:11:46.770 --> 00:11:48.900
12 developers and 6 products.

00:11:48.900 --> 00:11:50.270
That's easy math.

00:11:50.600 --> 00:11:53.780
We have two developers per product
and that's some pretty small teams.

00:11:53.990 --> 00:11:57.260
The only way we can accomplish
that is through really great tools.

00:11:57.280 --> 00:12:02.370
And one of the best tools in
our toolbox is Objective-C.

00:12:03.420 --> 00:12:07.720
I first discovered
Objective-C 17 years ago.

00:12:07.730 --> 00:12:10.300
And my first reaction is, well,
what's going on with this language?

00:12:10.300 --> 00:12:12.410
What are all these
brackets doing in here?

00:12:12.450 --> 00:12:15.100
What are these extra words in
between my parameter lists?

00:12:15.100 --> 00:12:16.220
I just didn't quite get it.

00:12:16.220 --> 00:12:19.620
But as I started to use it,
I discovered that this was a

00:12:19.620 --> 00:12:23.420
really powerful language that
made me incredibly productive.

00:12:23.420 --> 00:12:26.250
I could work at the highest levels
of abstraction with these nice

00:12:26.250 --> 00:12:29.680
object-oriented frameworks and with
our own objects that we were creating.

00:12:29.690 --> 00:12:34.160
Or I could dive all the way down and do
straight C code with all the existing

00:12:34.340 --> 00:12:37.110
C code that's available for Unix.

00:12:37.190 --> 00:12:39.050
And it just made us
incredibly productive.

00:12:39.150 --> 00:12:43.390
So Objective-C for the last
17 years has been really core

00:12:43.540 --> 00:12:45.950
to our development at Omni.

00:12:47.400 --> 00:12:50.220
12 developers, 6 products,
and they're not just

00:12:50.290 --> 00:12:51.660
tiny little products.

00:12:52.510 --> 00:12:54.490
They're actually serious
productivity applications.

00:12:54.570 --> 00:12:58.750
So I'd like to take a moment and
show you our latest Omni plan.

00:13:01.200 --> 00:13:03.600
Demo screen, please.

00:13:03.620 --> 00:13:04.160
Thank you.

00:13:04.160 --> 00:13:07.790
OmniPlan is a product that we wrote for
ourselves because even with small teams,

00:13:07.980 --> 00:13:11.050
software development is
a complicated process.

00:13:11.140 --> 00:13:13.520
And so it takes a lot of organization.

00:13:13.520 --> 00:13:21.210
You start out by listing, of course,
all of the tasks that you want to do.

00:13:21.210 --> 00:13:25.770
And we do that in an outline
over on the left here.

00:13:25.770 --> 00:13:25.770
And then on the right,
you'll see that we have

00:13:26.180 --> 00:13:30.770
A timeline that displays all of those
same tasks and their relationships,

00:13:30.780 --> 00:13:33.390
their dependencies in
Gantt chart notation.

00:13:34.300 --> 00:13:37.900
Good product plans, of course,
need to be, first of all,

00:13:37.900 --> 00:13:40.830
easy to create in the first place,
but also malleable and

00:13:40.830 --> 00:13:42.210
easy to change later.

00:13:42.230 --> 00:13:45.480
They need to be flexible because you
can't just create a plan at the very

00:13:45.480 --> 00:13:50.010
beginning of a product cycle and hope
that it will magically work out all

00:13:50.010 --> 00:13:52.410
the way to the end of the process.

00:13:52.640 --> 00:13:57.810
So let me show you what it's
like to edit a project plan here.

00:13:59.020 --> 00:14:05.320
Here we are at the end of our beta
feedback cycle and we've discovered

00:14:06.380 --> 00:14:08.620
that we have a few changes to make.

00:14:08.890 --> 00:14:11.700
Our beta testers have told us that
we need to fix some memory leaks.

00:14:11.700 --> 00:14:14.080
We've got some memory tuning work to do.

00:14:14.120 --> 00:14:17.840
And we have some new features
that we'd like to add.

00:14:17.840 --> 00:14:21.400
The beta testers thought of a killer
feature that just hadn't occurred to us.

00:14:21.400 --> 00:14:23.020
And it wouldn't take very long to add.

00:14:23.130 --> 00:14:24.240
So let's put that in there.

00:14:24.240 --> 00:14:26.070
And of course, we have some bugs to fix.

00:14:26.320 --> 00:14:32.680
So to integrate this into our process,
we just hook them up, we connect them,

00:14:32.710 --> 00:14:35.700
and we level out the work
because we do have a small team.

00:14:35.700 --> 00:14:38.180
We can't do all those things at once.

00:14:38.260 --> 00:14:40.930
So there, as you can see,
our final release is already adjusted.

00:14:40.940 --> 00:14:44.860
We can look at the split schedule here,
see where the final release was,

00:14:44.980 --> 00:14:46.560
where the final release is now.

00:14:46.940 --> 00:14:48.920
And of course,
our next step would be to then

00:14:48.970 --> 00:14:51.630
publish this to a web page and
share it with the rest of the team

00:14:51.690 --> 00:14:55.490
so they can all see the task list,
the project list, the resource list,

00:14:55.490 --> 00:14:57.240
and the Gantt chart itself.

00:14:57.240 --> 00:14:59.740
And from that web page,
you can also download calendar files

00:14:59.740 --> 00:15:01.970
that have to-do lists and so on.

00:15:03.410 --> 00:15:06.400
But let's take a deeper look
at this extra time in here.

00:15:06.400 --> 00:15:10.480
We said four weeks spent
doing this memory tuning,

00:15:10.480 --> 00:15:13.360
two weeks spent fixing memory leaks,
and then two weeks fixing crashes.

00:15:13.360 --> 00:15:14.380
Why does that take so long?

00:15:14.440 --> 00:15:17.050
Well, first,
to track down the memory leaks,

00:15:17.090 --> 00:15:18.640
you have to reproduce the conditions.

00:15:18.660 --> 00:15:22.140
You have to do it with some sort of
tool like on the object meter that

00:15:22.230 --> 00:15:25.000
sits there and tracks where all of
your memory allocations are going

00:15:25.000 --> 00:15:27.750
and where you did all these retains
and release and matches them up.

00:15:27.890 --> 00:15:30.540
And then once you've fixed your leaks,
you have to go back around and fix

00:15:30.590 --> 00:15:33.040
the crashes that you've introduced
because the leaks are masking them.

00:15:33.050 --> 00:15:37.830
So you have to go find all the
zombies and fix those as well.

00:15:38.400 --> 00:15:40.860
Wouldn't it be nice if,
I'm sure you can see

00:15:40.860 --> 00:15:42.760
where I'm going with this.

00:15:42.930 --> 00:15:45.210
Wouldn't it be nice if we didn't
have to worry about doing all

00:15:45.210 --> 00:15:46.210
those memory leaks all the time?

00:15:46.220 --> 00:15:51.980
Now, when I saw Bertrand's talk there,
his picture there just spoke to me,

00:15:51.980 --> 00:15:52.800
right?

00:15:52.850 --> 00:15:55.400
I was the person in the audience
going like this when I first

00:15:55.520 --> 00:15:58.460
heard that Apple was considering
doing garbage collection.

00:15:58.460 --> 00:16:02.020
I said, garbage collection is great
for these scripting languages,

00:16:02.020 --> 00:16:05.190
but I don't really want it in
our serious productivity apps.

00:16:05.260 --> 00:16:06.310
It's not going to work for us, is it?

00:16:08.830 --> 00:16:10.960
That's just,
that doesn't sound good to me.

00:16:11.080 --> 00:16:14.630
So my first piece of
feedback to Apple was,

00:16:14.660 --> 00:16:15.270
well, that's great.

00:16:15.460 --> 00:16:17.220
You put it in Objective-C if you need to.

00:16:17.220 --> 00:16:20.180
Just make sure that we can opt out so
we don't have to have it in our apps.

00:16:22.420 --> 00:16:26.860
But then I think about these four weeks,
and this isn't the first time we've spent

00:16:26.910 --> 00:16:28.190
fixing memory leaks in this project.

00:16:28.370 --> 00:16:31.180
So four weeks is a lot of time.

00:16:31.180 --> 00:16:34.440
We could spend that time doing
performance tuning in other

00:16:34.440 --> 00:16:35.400
places in the application.

00:16:35.400 --> 00:16:37.040
We could add some more killer features.

00:16:37.040 --> 00:16:37.660
We could fix bugs.

00:16:37.660 --> 00:16:39.310
We could just ship sooner,
and that would be great.

00:16:40.870 --> 00:16:42.850
So--

00:16:43.770 --> 00:16:46.660
The only question is,
is Garbage Collection really fast

00:16:46.660 --> 00:16:49.100
enough to use in our application?

00:16:49.100 --> 00:16:51.320
And I have some great
news to share with you.

00:16:51.320 --> 00:16:56.660
This copy of Omni plan was actually
built with Garbage Collection.

00:16:56.660 --> 00:17:01.610
And as you can see,
it performs quite well.

00:17:03.790 --> 00:17:06.670
So I'm really looking forward to
shipping garbage collecting applications

00:17:07.100 --> 00:17:10.360
on Leopard as soon as it's available
and enabling our small teams to do

00:17:10.360 --> 00:17:11.790
even more with even better tools.

00:17:11.800 --> 00:17:12.880
Thank you, Ken.

00:17:20.690 --> 00:17:21.840
Garbage collection.

00:17:22.000 --> 00:17:23.080
Essentially, there are two issues.

00:17:23.080 --> 00:17:29.940
One, are you actually freeing up all the
objects that you're no longer needing?

00:17:29.940 --> 00:17:32.440
And number two,
have you accidentally deleted

00:17:32.440 --> 00:17:34.800
objects that you might still need?

00:17:34.970 --> 00:17:37.120
Without garbage collection,
you have to worry about this.

00:17:37.120 --> 00:17:39.780
Bugs creep into your
application without this.

00:17:39.780 --> 00:17:43.130
Now, obviously,
garbage collection is not every possible

00:17:43.390 --> 00:17:45.890
benefit for just simply removing bugs.

00:17:45.890 --> 00:17:46.940
But let's take a look.

00:17:46.940 --> 00:17:49.840
So this is a simple setter and getter.

00:17:49.860 --> 00:17:52.550
Implementation,
the kind of thing you write pretty

00:17:52.560 --> 00:17:54.680
frequently in object-oriented languages.

00:17:54.680 --> 00:17:59.290
And one of the great things about garbage
collection is we just make that go away,

00:17:59.300 --> 00:18:01.130
make away all the retained release count.

00:18:01.170 --> 00:18:05.130
And it all just disappears,
and the code becomes much more beautiful,

00:18:05.240 --> 00:18:08.260
really just the essential
assignments and returns.

00:18:08.260 --> 00:18:12.060
And so GC really is going to
simplify a big part of the retained

00:18:12.240 --> 00:18:14.330
count part of your programming.

00:18:14.330 --> 00:18:17.980
Now, you can still leave in
the retains and releases,

00:18:17.980 --> 00:18:19.840
but in the end,
you're going to have to do a lot more.

00:18:19.860 --> 00:18:23.550
In a garbage-collected application,
they will be ignored,

00:18:23.660 --> 00:18:25.270
or in the application code.

00:18:25.410 --> 00:18:26.940
So you can remove them.

00:18:26.940 --> 00:18:30.500
So it's still very convenient
to write frameworks that are

00:18:30.500 --> 00:18:32.520
both GC-enabled and GC-safe.

00:18:34.760 --> 00:18:39.180
Of course, this code,
since setters and getters are

00:18:39.350 --> 00:18:43.200
a typical part of what we do,
let's make that easier.

00:18:43.200 --> 00:18:45.450
And so we've added
properties to the language,

00:18:45.560 --> 00:18:50.130
and this retains the four object-oriented
properties that you can override it,

00:18:50.420 --> 00:18:53.490
either the setter or the
getter in the implementation.

00:18:53.710 --> 00:18:58.050
The compiler will generate the
code for you to make that possible.

00:18:58.740 --> 00:19:01.780
One great thing about that is
that with properties we can

00:19:01.780 --> 00:19:06.330
now have the dot notation,
typical dot notation, so that,

00:19:06.380 --> 00:19:11.720
and it calls the methods call
invocation still in Objective C.

00:19:11.800 --> 00:19:14.050
And that works both on the
left and the right hand side

00:19:14.050 --> 00:19:15.680
of the assignment statement.

00:19:16.360 --> 00:19:19.060
Now using that, what do we typically do?

00:19:19.150 --> 00:19:21.540
What do we typically do with this?

00:19:21.740 --> 00:19:26.000
So, oftentimes we write for iteration.

00:19:26.000 --> 00:19:28.170
And with iteration,
we have to write an induction

00:19:28.170 --> 00:19:29.400
variable and count it along.

00:19:29.630 --> 00:19:32.210
But of course, again,
since we have the built-in data

00:19:32.210 --> 00:19:34.680
types of NS enumeration and so on,
we can, in fact,

00:19:34.680 --> 00:19:36.770
make that part of the language as well.

00:19:36.770 --> 00:19:40.000
So we've added in iteration
into the language,

00:19:40.000 --> 00:19:42.600
and it has the very simple for loops.

00:19:49.100 --> 00:19:53.440
These three features,
these three features,

00:19:53.450 --> 00:19:57.080
I think are going to make Objective-C 2
on Leopard really terrific for you and

00:19:57.160 --> 00:19:59.400
really improve programmer productivity.

00:19:59.690 --> 00:20:06.540
So if Objective-C is the rock,
what's the sling?

00:20:06.640 --> 00:20:07.720
What's the sling there?

00:20:07.830 --> 00:20:10.430
And I think the sling, of course,
is Xcode.

00:20:10.550 --> 00:20:12.640
And I could tell you about all
the great features in Xcode,

00:20:12.640 --> 00:20:14.620
but I really think
I just want to show you.

00:20:14.720 --> 00:20:19.340
So the big part about Xcode is we've
streamlined the editing process,

00:20:19.450 --> 00:20:23.460
the building, and the debugging process,
and really to make your workflow

00:20:23.460 --> 00:20:27.090
in using Xcode incredibly more
productive so that you can write the

00:20:27.090 --> 00:20:29.270
greatest applications in the world.

00:20:29.350 --> 00:20:33.220
So I'd like to invite Andreas Wendker up,
the Xcode ID manager,

00:20:33.260 --> 00:20:35.180
up to give us a demo.

00:20:42.600 --> 00:20:44.300
So good afternoon.

00:20:44.300 --> 00:20:46.950
Over the last couple of years,
more and more of you have started

00:20:46.950 --> 00:20:48.480
using Xcode for the development.

00:20:48.510 --> 00:20:50.800
And we've been listening very
carefully to your feedback.

00:20:50.840 --> 00:20:53.130
One of the things we've heard
loud and clear is that you want

00:20:53.130 --> 00:20:54.680
a faster and better text editor.

00:20:54.680 --> 00:20:57.900
And I'm here to tell you today that
we've been working very hard on that.

00:20:58.040 --> 00:21:00.260
And already in the leopard's
seat you hold in your hands,

00:21:00.260 --> 00:21:02.960
our text editor is up to five
times faster than opening

00:21:02.960 --> 00:21:05.090
and scrolling through files.

00:21:08.670 --> 00:21:09.800
Let me show that to you.

00:21:09.860 --> 00:21:12.570
To demonstrate, I brought an open source
project called Osiris.

00:21:12.810 --> 00:21:14.430
It has about 1,000 source files.

00:21:14.640 --> 00:21:18.770
And the largest file I could
find in it is a C++ file.

00:21:18.870 --> 00:21:21.990
It's not quite a megabyte large,
and it has about 20,000 lines of code.

00:21:22.090 --> 00:21:24.340
So let me open that up for you.

00:21:25.620 --> 00:21:26.330
Here it is.

00:21:26.340 --> 00:21:28.970
So as you can see,
no more significant delay when opening

00:21:28.970 --> 00:21:31.130
files and scrolling through them.

00:21:35.200 --> 00:21:36.040
Let me show you another one.

00:21:36.040 --> 00:21:37.540
This is an Objective-C class.

00:21:37.550 --> 00:21:40.930
It's about 400 kilobytes large,
12,000 lines of code, and again,

00:21:40.930 --> 00:21:41.970
no significant delay.

00:21:42.070 --> 00:21:45.640
Another thing you might notice while
I scroll through the file here is

00:21:45.640 --> 00:21:49.340
that we've also made significant
improvements to our syntax coloring.

00:21:49.340 --> 00:21:51.880
In Xcode 3, we've identified many
more types of symbols,

00:21:51.900 --> 00:21:55.100
and we give you more
options to color them.

00:21:56.990 --> 00:22:00.560
Now let me close this project and
go to another one which I'm going

00:22:00.610 --> 00:22:01.830
to use for the rest of my demo.

00:22:01.920 --> 00:22:05.130
This is a variation of the
Core Recipes application and

00:22:05.130 --> 00:22:07.010
a sample code for a core data.

00:22:09.470 --> 00:22:12.410
The next feature I want to show you
is also very commonly requested,

00:22:12.410 --> 00:22:13.680
and it's code folding.

00:22:13.930 --> 00:22:17.070
Code folding is the ability to
collapse blocks of your code together

00:22:17.090 --> 00:22:20.530
in the source editor so that you
get a better overview of your source.

00:22:20.530 --> 00:22:20.530
Thank you.

00:22:25.800 --> 00:22:28.100
And so if you just concentrate on
the pieces you're interested in,

00:22:28.100 --> 00:22:31.560
let me use a keyboard command to just
collapse all the methods in this file.

00:22:31.610 --> 00:22:34.320
So as you can see,
I now get a much better overview.

00:22:34.350 --> 00:22:38.270
And I can just decide to just look at
the methods I'm currently interested in.

00:22:42.010 --> 00:22:44.190
Now some people like to use
the keyboard as I just did,

00:22:44.190 --> 00:22:46.280
and other people like to use the mouse.

00:22:46.340 --> 00:22:51.340
So let me show you a new
preference we added to turn on the

00:22:51.340 --> 00:22:53.900
so-called code forwarding sidebar.

00:22:54.550 --> 00:22:56.810
The code folding sidebar has two modes.

00:22:57.020 --> 00:22:59.140
The first one that you see right now,
the default one,

00:22:59.140 --> 00:23:02.710
is just that it uses a color
gradient to show you the depth of the

00:23:02.710 --> 00:23:04.080
nesting level you are in right now.

00:23:04.080 --> 00:23:05.820
So just by scrolling
through the source file,

00:23:05.820 --> 00:23:09.140
you can kind of get an idea for
where you are in the method bodies,

00:23:09.230 --> 00:23:11.100
how deep you are in them.

00:23:16.050 --> 00:23:19.780
The other mode gets activated
when you mouse over the sidebar.

00:23:19.920 --> 00:23:22.380
At this moment,
the sidebar turns into what we

00:23:22.380 --> 00:23:23.500
call the code focus control.

00:23:23.500 --> 00:23:25.630
It allows you to collapse
blocks of code with a mouse.

00:23:25.720 --> 00:23:27.880
And also, as you can see,
when I scroll over it,

00:23:27.880 --> 00:23:31.150
it kind of gives you a very clear
indication for where you are in your code

00:23:31.150 --> 00:23:33.050
and which block is going to be affected.

00:23:33.050 --> 00:23:36.120
So you can just go ahead and
collapse that and open it up again.

00:23:43.070 --> 00:23:45.710
The next thing we wanted to
do is make documentation more

00:23:45.720 --> 00:23:47.210
easily accessible for you.

00:23:47.320 --> 00:23:49.430
For that purpose,
we added the Research Assistant.

00:23:49.500 --> 00:23:51.400
You can activate it in the Help menu.

00:23:51.400 --> 00:23:54.000
And the Research Assistant is a
small window that you can place

00:23:54.030 --> 00:23:56.460
on the side of your editor,
and it will follow around your

00:23:56.460 --> 00:23:58.820
selection in the editor and show
you relevant information about the

00:23:58.820 --> 00:24:00.510
methods you're working with right now.

00:24:00.670 --> 00:24:03.040
Most of you are probably familiar
with the object and index methods.

00:24:03.040 --> 00:24:05.020
Let me just select that.

00:24:05.070 --> 00:24:07.290
And as you can see,
the Research Assistant just follows

00:24:07.290 --> 00:24:08.920
me around and shows me information.

00:24:09.040 --> 00:24:11.230
At the top of the window,
you have just some links to

00:24:11.270 --> 00:24:13.720
take you to the header or
to the documentation window.

00:24:13.800 --> 00:24:16.560
And below it, you find the information
you would expect,

00:24:16.600 --> 00:24:18.680
the declaration and abstract description.

00:24:18.860 --> 00:24:23.640
But it also shows you more things like
related APIs or related documents,

00:24:23.640 --> 00:24:25.800
or even sample code if you have
it available for these methods.

00:24:25.820 --> 00:24:29.590
So the Research Assistant gives you
documentation right at your fingertips.

00:24:38.120 --> 00:24:40.760
The next feature I want to show you is
a feature that will become handy when

00:24:40.760 --> 00:24:42.440
you work with build errors and warnings.

00:24:42.470 --> 00:24:44.780
So far,
Xcode displayed errors and warnings

00:24:44.780 --> 00:24:49.020
either in the build window or in
the errors and warnings smart group.

00:24:49.090 --> 00:24:51.660
So let me start building my project.

00:24:52.150 --> 00:24:54.600
And as you can see in the status bar,
it failed with an error.

00:24:54.600 --> 00:24:57.230
But wouldn't it be nice if it
would show me this error right

00:24:57.380 --> 00:24:58.890
in context in my source code?

00:24:59.050 --> 00:25:01.950
Let me use the keyboard
command to jump to the error.

00:25:02.910 --> 00:25:03.520
Here it is.

00:25:03.600 --> 00:25:06.100
And now we can turn on what we
call message bubbles for errors,

00:25:06.100 --> 00:25:07.960
warnings, and breakpoints.

00:25:07.960 --> 00:25:09.820
And then as you can see,
we are embedding the

00:25:09.820 --> 00:25:10.680
information right here.

00:25:10.790 --> 00:25:12.850
So it's very easy for me,
without switching context

00:25:12.910 --> 00:25:15.240
between different windows,
to go through my errors and warnings,

00:25:15.350 --> 00:25:17.420
correct them,
which in this case is very easy.

00:25:17.420 --> 00:25:24.900
Save and-- --and build again.

00:25:24.920 --> 00:25:26.990
And then the error is gone.

00:25:30.520 --> 00:25:34.870
Now let's take a look at something
beyond the source editor.

00:25:34.930 --> 00:25:37.660
Let me go to another header file.

00:25:39.150 --> 00:25:42.860
This is the header file for the
recipe objects in my database.

00:25:42.860 --> 00:25:45.650
As you can see,
it has instance variables for

00:25:45.650 --> 00:25:50.060
all the properties of a recipe,
a name, and the number of servings,

00:25:50.070 --> 00:25:51.620
and things like that.

00:25:51.620 --> 00:25:54.510
But if you look closely,
you might notice that I've had somewhat

00:25:54.510 --> 00:25:56.800
of a whimsical moment a while ago.

00:25:56.820 --> 00:25:59.180
And I actually called an
instance variable yummies.

00:25:59.280 --> 00:26:01.940
Well, being here on stage,
I'm kind of embarrassed by that.

00:26:01.960 --> 00:26:03.860
And I'd like to use a
more professional name,

00:26:04.020 --> 00:26:05.280
like ingredients.

00:26:05.410 --> 00:26:07.860
So typically,
what I would do right now is go into

00:26:07.860 --> 00:26:11.400
the Find panel and start searching
for all the occurrences of yummies,

00:26:11.400 --> 00:26:13.110
and then start replacing them one by one.

00:26:13.220 --> 00:26:14.830
And we all know that
this is very tedious,

00:26:14.910 --> 00:26:17.240
time consuming,
and it's also error prone because

00:26:17.240 --> 00:26:19.140
it's very easy to miss a spot.

00:26:19.140 --> 00:26:22.880
And wouldn't it be nice if the IDE would
help me with these kind of mass changes?

00:26:22.970 --> 00:26:25.150
So there's a technology
that is called refactoring.

00:26:25.340 --> 00:26:27.200
And I'm happy to
announce that in Xcode 3,

00:26:27.200 --> 00:26:31.510
we are adding refactoring capabilities
for Objective-C to the IDE.

00:26:38.720 --> 00:26:41.760
Refactoring means that you can make
structural changes to your source code

00:26:41.940 --> 00:26:43.320
without changing the behavior at all.

00:26:43.390 --> 00:26:45.690
And let me just show this to you.

00:26:45.760 --> 00:26:48.000
So I'm going to select my
instance variable here,

00:26:48.000 --> 00:26:50.410
and I'm going to bring up
the refactoring window.

00:26:53.530 --> 00:26:57.010
And this window just gives me a
few options of-- gives me all the

00:26:57.170 --> 00:26:59.710
options that I can use to work
on my instance failure right now.

00:26:59.800 --> 00:27:02.130
Just this pop-up here at the top.

00:27:02.350 --> 00:27:05.110
There are a few options to
move up and down the instance

00:27:05.110 --> 00:27:06.360
variable in the class hierarchy.

00:27:06.370 --> 00:27:08.450
The most common one is
the first one selected,

00:27:08.450 --> 00:27:09.560
the rename operation.

00:27:09.700 --> 00:27:12.500
So let me just go ahead
and enter the new name.

00:27:14.530 --> 00:27:17.100
And let me also point out
this checkbox here at the end,

00:27:17.230 --> 00:27:18.650
the related KVC members.

00:27:18.750 --> 00:27:21.480
One of the great things about our
refactoring engine is that we are

00:27:21.480 --> 00:27:24.400
building in specific knowledge
about the Cocoa conventions.

00:27:24.400 --> 00:27:27.820
If you've ever worked
with key value coding,

00:27:27.820 --> 00:27:32.040
you know that you have to keep
a lot of method names in sync

00:27:32.050 --> 00:27:34.480
with your instance variable.

00:27:34.480 --> 00:27:35.960
And there's lots of stuff
that is related to each other.

00:27:35.960 --> 00:27:35.960
And we are building in this knowledge
right to the refactoring engine.

00:27:41.810 --> 00:27:46.880
So once I end up all the
parameters of my transformation,

00:27:46.920 --> 00:27:48.180
I can press the Preview button.

00:27:48.260 --> 00:27:51.720
And then Xcode goes and analyzes
the project and will find all the

00:27:51.720 --> 00:27:53.570
files that need to be changed.

00:27:55.940 --> 00:27:59.260
and then comes back
with a list of changes.

00:27:59.290 --> 00:28:02.580
Once it comes back with this list,
I can go ahead and preview the

00:28:02.580 --> 00:28:04.750
changes just by clicking on it.

00:28:04.880 --> 00:28:07.770
And as you can see,
we integrated fine merge-like

00:28:07.770 --> 00:28:11.000
functionality right here
in Xcode in the workflow.

00:28:17.250 --> 00:28:18.950
Now let's take a look at what we found.

00:28:19.010 --> 00:28:21.300
The first one you would kind
of expect because that's the

00:28:21.310 --> 00:28:23.040
instance variable where we started.

00:28:23.070 --> 00:28:25.710
But if you go down the list of changes,

00:28:26.720 --> 00:28:29.130
You can see that it found
all the related methods too,

00:28:29.130 --> 00:28:31.970
like the add and remove objects.

00:28:33.730 --> 00:28:35.180
And this is now the implementation file.

00:28:35.180 --> 00:28:36.800
There's the instance variable again.

00:28:36.920 --> 00:28:38.680
And already here,
you can start seeing that we

00:28:38.680 --> 00:28:41.390
not only find occurrences of the
variable and the method names,

00:28:41.500 --> 00:28:45.600
we even find invocations through
string that are done through

00:28:45.710 --> 00:28:49.070
indirect key value coding calls,
like you can see here.

00:28:49.100 --> 00:28:52.220
Let me just go down,
show you a few more of those.

00:28:52.800 --> 00:28:55.600
And if you go on to the next file,
you can see that we are also not

00:28:55.660 --> 00:28:58.050
limiting our changes to the source files.

00:28:58.180 --> 00:28:59.460
We're even going into your Nib files.

00:28:59.510 --> 00:29:03.180
We're going to keep actions, outlets,
and binding names in your Nib files

00:29:03.180 --> 00:29:05.300
in sync with your code changes.

00:29:10.600 --> 00:29:13.450
So in this case, for example,
we found a binding name that was using

00:29:13.510 --> 00:29:15.840
yummies and now is using ingredients.

00:29:16.000 --> 00:29:17.600
So let me go ahead and apply this change.

00:29:17.600 --> 00:29:22.370
Just going to take a moment.

00:29:24.820 --> 00:29:26.160
And let me go and save all the files.

00:29:26.160 --> 00:29:31.120
And then let me show you
another refactoring operation.

00:29:31.120 --> 00:29:33.180
A few minutes ago,
you had Ted talking about the

00:29:33.250 --> 00:29:35.560
new features of Objective-C 2.0.

00:29:35.590 --> 00:29:38.460
And wouldn't it be nice if you could
just start making use of these great

00:29:38.540 --> 00:29:40.410
new features without doing much work?

00:29:40.470 --> 00:29:44.700
For that purpose,
we added a menu item to convert

00:29:44.700 --> 00:29:47.610
your code over to Objective-C 2.0.

00:29:51.000 --> 00:29:54.490
So let me just go ahead
and start previewing this.

00:29:54.570 --> 00:29:57.870
As you can see at the top of the window,
we give you a few options for which

00:29:57.880 --> 00:30:00.420
features you want to start using,
modernizing the for

00:30:00.420 --> 00:30:03.430
loops with the iterators,
starting to use properties, et cetera.

00:30:03.590 --> 00:30:06.580
In this case,
I just limited it to using the for loops,

00:30:06.580 --> 00:30:08.080
to using the new loop iterators.

00:30:08.240 --> 00:30:10.380
Before I show you the difference,
I also want to show you this

00:30:10.380 --> 00:30:13.140
little checkbox up here,
which is called Snapshot.

00:30:13.250 --> 00:30:14.900
Behind this checkbox,
there hides another really

00:30:14.900 --> 00:30:17.800
great feature of Xcode 3,
which we call Snapshotting.

00:30:17.910 --> 00:30:21.040
Snapshotting is the ability
to capture and preserve the

00:30:21.040 --> 00:30:24.920
state of your entire project,
to review how your project changed over

00:30:24.920 --> 00:30:29.960
time in comparing the snapshots and
the current version of the project,

00:30:29.960 --> 00:30:33.100
and to also go back to a snapshot
in case anything went wrong.

00:30:33.160 --> 00:30:36.720
So it's a very lightweight-- Thank you.

00:30:40.400 --> 00:30:44.110
So it's kind of a very lightweight--
it's not really an SCM system,

00:30:44.110 --> 00:30:45.790
but it's lightweight on the local disk.

00:30:45.850 --> 00:30:48.170
And you can use it in addition
to the SCM system that you

00:30:48.170 --> 00:30:49.600
share with your coworkers.

00:30:49.600 --> 00:30:53.640
I'll show you a little more
about snapshots in a moment.

00:30:53.640 --> 00:30:58.440
Let me now just preview the changes
here for the modernized loops.

00:30:58.440 --> 00:31:02.830
So here, for example,
you found a loop with an enumerator.

00:31:02.830 --> 00:31:04.590
And we just replaced that
with a new for each iterators.

00:31:04.590 --> 00:31:04.590
So let me also go ahead
and apply this change.

00:31:09.630 --> 00:31:11.270
And now let me bring
up the snapshot window.

00:31:11.320 --> 00:31:16.440
So this is the snapshot window
that just lists all the snapshots

00:31:16.440 --> 00:31:18.100
I took for this project over time.

00:31:18.100 --> 00:31:19.780
As you can see,
it has a short description

00:31:19.980 --> 00:31:22.010
and a timestamp.

00:31:22.310 --> 00:31:24.190
and even better than that,
I can expand the window

00:31:24.250 --> 00:31:26.700
to show me more details.

00:31:26.710 --> 00:31:28.780
And here, as you can see,
is the diff now of my project.

00:31:28.950 --> 00:31:30.740
And again,
I can look at the differences in detail.

00:31:30.740 --> 00:31:33.240
You might remember that we just
renamed yummies to ingredients.

00:31:33.330 --> 00:31:35.440
So here's my snapshot.

00:31:35.520 --> 00:31:40.370
So refactoring together the snapshotting,
we believe, will allow you to become

00:31:40.530 --> 00:31:44.100
much more experimental and
more playful with your code.

00:31:44.100 --> 00:31:47.900
Because first of all,
you can make changes much more fast now.

00:31:47.900 --> 00:31:49.010
And also, you have a safety net in
case anything goes wrong.

00:31:58.800 --> 00:32:01.530
We talked about Nib files just a minute
ago during the refactoring operation,

00:32:01.600 --> 00:32:04.040
so I think it's time for me to show
you the new interface with NLeopard.

00:32:04.040 --> 00:32:07.120
You might have already seen
it in the previous session.

00:32:07.120 --> 00:32:10.570
Let me just go ahead and open it,
a Nib file here.

00:32:15.500 --> 00:32:18.260
Interface Builder in Leopard is a
major refresh of Interface Builder.

00:32:18.530 --> 00:32:21.430
It has a fresh new workflow
that is much more efficient.

00:32:21.500 --> 00:32:24.430
It also has a fresh architecture that
makes it easier for you to extend

00:32:24.490 --> 00:32:26.240
Interface Builder with your own objects.

00:32:26.280 --> 00:32:28.060
I'm going to show you why in a moment.

00:32:28.260 --> 00:32:30.300
Let me start by walking you
through the application.

00:32:30.340 --> 00:32:32.020
Here's a new file window
of Interface Builder.

00:32:32.020 --> 00:32:35.950
As you can see,
it has different views now, an icon view,

00:32:35.960 --> 00:32:38.660
an outline view, or a browser view.

00:32:38.890 --> 00:32:41.940
And then also we added a search
field so that you can filter on

00:32:41.940 --> 00:32:44.980
the objects and more quickly reach
the objects you want to work with.

00:32:45.120 --> 00:32:48.390
For example, you can find all the
text fields very easily.

00:32:53.180 --> 00:32:57.540
Let me open up a window here and
start adding objects to my Nib file.

00:32:57.570 --> 00:32:59.660
For that, I bring up the library window.

00:32:59.660 --> 00:33:03.320
So the library window contains all
the objects I can add to my Nib file.

00:33:03.320 --> 00:33:06.720
And it replaces the previous palette
mechanism that we used with a more

00:33:06.720 --> 00:33:08.710
efficient and more flexible way.

00:33:09.040 --> 00:33:11.780
First thing you will notice is
that the library is organized

00:33:11.850 --> 00:33:12.910
in a hierarchy of groups.

00:33:12.970 --> 00:33:15.440
Right now I have the entire
Cocoa group selected.

00:33:15.530 --> 00:33:18.000
You can look at just the common controls,
the controllers.

00:33:18.000 --> 00:33:20.810
Or I can select multiple groups
at the same time to reach all

00:33:20.940 --> 00:33:23.140
the objects in both groups.

00:33:23.200 --> 00:33:26.280
The library window also allows you
to create your own favorite groups.

00:33:26.380 --> 00:33:29.310
So if you want to just put the same-- if
you commonly work with the same objects,

00:33:29.370 --> 00:33:32.040
you can create your own groups
and just drag the objects in there

00:33:32.040 --> 00:33:35.200
and then bring up those groups.

00:33:35.210 --> 00:33:38.160
Let me add the text field to
my new profile and just play

00:33:38.160 --> 00:33:39.780
around with it a little bit.

00:33:46.100 --> 00:33:48.840
and of course if I want to
customize this text field,

00:33:48.840 --> 00:33:50.540
I will go into the inspector.

00:33:50.540 --> 00:33:52.810
So let me bring up the inspector.

00:33:53.430 --> 00:33:54.150
Here it is.

00:33:54.210 --> 00:33:55.760
If you've worked with
Interface Builder before,

00:33:55.760 --> 00:33:57.640
you will immediately
recognize this window again.

00:33:57.820 --> 00:34:01.650
It contains all the controls you need to
customize the objects in your Nib file.

00:34:01.790 --> 00:34:05.400
For example, I could go ahead and
change the alignment,

00:34:05.510 --> 00:34:07.120
or I can change the border type.

00:34:07.150 --> 00:34:09.080
Just the usual stuff.

00:34:09.100 --> 00:34:11.720
Now, what you might notice is
that the inspector is now

00:34:11.720 --> 00:34:13.440
organized by class hierarchy.

00:34:13.440 --> 00:34:17.600
It has individual slices for each of
the classes in the class hierarchy.

00:34:17.660 --> 00:34:20.560
And that is one of the reasons why
it's so much easier now to customize

00:34:20.560 --> 00:34:22.380
Interface Builder for your own purposes.

00:34:22.530 --> 00:34:25.280
In the past, when you added an object
to Interface Builder,

00:34:25.320 --> 00:34:27.990
you had to replace the entire
inspector infrastructure with it.

00:34:28.060 --> 00:34:30.060
You couldn't reuse any of
the work that we've done.

00:34:30.240 --> 00:34:32.270
Well, in the new Interface Builder,
it's enough for you to

00:34:32.270 --> 00:34:34.900
just add a new slice,
and you can reuse all the work that we've

00:34:34.900 --> 00:34:36.720
already done for the object classes.

00:34:36.770 --> 00:34:39.950
So it's going to be a lot faster for
you to write your own inspectors.

00:34:45.600 --> 00:34:49.820
Another thing our inspector
can now do is inspect multiple

00:34:49.820 --> 00:34:51.990
objects at the same time.

00:34:57.820 --> 00:34:59.920
So yeah, I just changed both
objects at the same time.

00:34:59.920 --> 00:35:03.080
And even better than that,
we can now handle selections

00:35:03.220 --> 00:35:05.240
of different types of objects.

00:35:05.240 --> 00:35:08.040
So this is another advantage of working
with these slices because we can

00:35:08.040 --> 00:35:11.270
still show you all the common slices
that apply to all selected objects.

00:35:11.370 --> 00:35:14.210
So for example,
I can go and change the control size

00:35:14.210 --> 00:35:16.350
of all controls at the same moment.

00:35:23.400 --> 00:35:25.360
Now, interface builder wouldn't be
interface builder if I couldn't make

00:35:25.420 --> 00:35:26.600
connections between the objects.

00:35:26.600 --> 00:35:29.340
So like in the past,
I can just control click an object,

00:35:29.340 --> 00:35:31.420
drag from the source to the destination.

00:35:31.420 --> 00:35:33.370
But now,
instead of having to drop into the

00:35:33.370 --> 00:35:36.060
inspector to complete my operation,
I get a little heads-up

00:35:36.110 --> 00:35:37.530
display right here in place.

00:35:37.530 --> 00:35:40.900
And I can just choose, for example,
to set the next key view outlet.

00:35:40.900 --> 00:35:43.770
Even better than that,
if I control click without dragging,

00:35:43.820 --> 00:35:47.230
I get another more extended version
of this heads-up display that shows me

00:35:47.230 --> 00:35:51.110
more detail about all the incoming and
outgoing connections at the same time.

00:35:51.170 --> 00:35:53.380
And again,
I can start creating new connections.

00:35:53.400 --> 00:35:57.050
And as you can see,
it nicely fades out so that

00:35:57.100 --> 00:35:58.120
I can still reach objects.

00:36:09.170 --> 00:36:10.630
So as you can see,
I reach and see objects

00:36:10.660 --> 00:36:11.640
right underneath the HUD.

00:36:11.640 --> 00:36:14.660
And as you can see,
I just completed my connection here.

00:36:19.900 --> 00:36:25.780
So let me drop out of interface
builder and go back into Xcode.

00:36:25.800 --> 00:36:29.600
And let me start building
and running my project.

00:36:29.660 --> 00:36:32.500
Since we just refactored a few files,
it's just taking a moment.

00:36:32.620 --> 00:36:34.290
And here it is.

00:36:36.710 --> 00:36:42.580
So let me drop out of interface
builder and go back into Xcode.

00:36:42.580 --> 00:36:46.420
And let me start building
and running my project.

00:36:46.420 --> 00:36:49.400
Since we just refactored a few files,
it's just taking a moment.

00:36:49.400 --> 00:36:51.030
And here it is.

00:37:05.000 --> 00:37:11.270
Um, actually, what did I do?

00:37:11.280 --> 00:37:14.270
Let me just give me a second to
just figure out what I just did.

00:37:23.270 --> 00:37:27.220
If it's possible, I'd like to switch over
to the other machine.

00:37:27.250 --> 00:37:30.100
Yeah, this is where I invite
you into the time machine.

00:37:30.100 --> 00:37:32.350
And we just go back in time.

00:37:48.570 --> 00:37:50.800
Just one second, I just need to bring
up the project again.

00:37:50.820 --> 00:37:52.800
But there's one more feature
I really want to show you.

00:37:52.800 --> 00:37:58.620
And of course,
now what I have to do is I have

00:37:58.720 --> 00:38:02.470
to go and refactor one more time,
because otherwise my project won't work.

00:38:02.480 --> 00:38:14.290
But now you can see how
fast it actually is.

00:38:25.400 --> 00:38:44.800
[Transcript missing]

00:38:57.410 --> 00:38:59.300
Yeah, it's not my fault.

00:38:59.300 --> 00:39:05.290
Anyway, let's just pretend there's
some data in this window.

00:39:06.500 --> 00:39:10.430
So what I really wanted to show you
is that there are some directions.

00:39:10.610 --> 00:39:13.960
And what I wanted to do is go and
prepare my recipe in the kitchen.

00:39:13.960 --> 00:39:16.230
Of course, I have to step away from
the computer for that.

00:39:16.330 --> 00:39:20.520
So to see it in more detail,
I added an enlarge button to my window.

00:39:20.670 --> 00:39:22.440
Let me drop my window
into the full screen mode.

00:39:22.550 --> 00:39:25.440
Unfortunately, it's empty right now.

00:39:26.600 --> 00:39:29.190
This is, by the way,
using one of the new Cocoa APIs to

00:39:29.190 --> 00:39:30.740
go into full screen mode.

00:39:30.810 --> 00:39:33.440
Now, what if I want to debug this?

00:39:33.940 --> 00:39:34.730
All right.

00:39:34.930 --> 00:39:37.660
That allows me to show you
another feature that we use to

00:39:37.730 --> 00:39:39.300
streamline the workflow in Xcode.

00:39:39.350 --> 00:39:41.380
As you can see,
when we launched the application,

00:39:41.380 --> 00:39:43.710
we added a small toolbar
to the editor window.

00:39:43.720 --> 00:39:46.390
And this toolbar contains all
the buttons that I need for

00:39:46.390 --> 00:39:48.490
most of the common operations.

00:39:49.690 --> 00:39:53.060
For example, there's a button to just
turn on breakpoints.

00:39:53.060 --> 00:39:55.700
And I've already set a breakpoint
in my application that drops

00:39:55.740 --> 00:39:57.000
it into the full screen mode.

00:39:57.100 --> 00:39:59.710
So let me just go back to it and run it.

00:40:00.440 --> 00:40:04.060
And now, as you would expect,
Xcode will go into the debugger.

00:40:04.060 --> 00:40:06.680
And here, I can use the toolbar to,
for example,

00:40:06.680 --> 00:40:08.350
switch between the different threads.

00:40:08.490 --> 00:40:10.230
I can look at the stack trace.

00:40:10.290 --> 00:40:12.530
I can step over the different lines.

00:40:12.590 --> 00:40:15.320
And what I can also do in Xcode 3
now is I can just hover over the

00:40:15.320 --> 00:40:18.600
instance variables and get data tips.

00:40:26.700 --> 00:40:29.120
And I can use these data
tips right in line here in my

00:40:29.120 --> 00:40:30.780
editor to continue debugging.

00:40:30.780 --> 00:40:33.890
So with the toolbar and the data tips,
you can now do most of the common

00:40:33.890 --> 00:40:39.490
debugging operations right in the
editor without having to switch back

00:40:39.490 --> 00:40:39.490
and forth between the different windows.

00:40:40.230 --> 00:40:42.870
So let me continue.

00:40:43.000 --> 00:40:46.010
And now, what if I want to debug
the opposite scenario,

00:40:46.010 --> 00:40:47.620
where I drop out of the full screen mode?

00:40:47.620 --> 00:40:48.960
Well,
I'm a little bit out of luck right now,

00:40:48.960 --> 00:40:52.560
because there's no way for me to reach
Xcode unless I have a second screen.

00:40:52.780 --> 00:40:55.540
Well, there's a solution for that, too,
in Xcode 3.

00:40:55.730 --> 00:40:59.460
Let me go back into the code,
remove the old breakpoint.

00:41:00.280 --> 00:41:02.630
and so the new one here,
which is the place that drops

00:41:02.640 --> 00:41:03.530
out of full screen mode.

00:41:03.620 --> 00:41:06.240
And let me also bring up the
debugger heads up display.

00:41:06.240 --> 00:41:09.260
So this is a little window that
just have us here on the screen.

00:41:09.420 --> 00:41:12.100
And when I go back into my application,

00:41:16.910 --> 00:41:19.660
Okay, well, I can't show you that.

00:41:19.960 --> 00:41:23.560
The idea behind the debugger hat here is
that it hovers on top of your screen and

00:41:23.560 --> 00:41:27.130
even when you're in full screen mode,
you'll be able to debug scenarios

00:41:27.130 --> 00:41:29.620
because it's on top of your
application without you having

00:41:29.620 --> 00:41:30.900
to drop back into the Xcode app.

00:41:30.900 --> 00:41:32.700
So it allows you to debug
different scenarios that you

00:41:32.740 --> 00:41:34.880
won't be able to debug before.

00:41:34.880 --> 00:41:38.550
And of course,
I can't show that to you right now.

00:41:38.550 --> 00:41:38.550
Anyway,

00:41:39.200 --> 00:41:41.380
I hope what you saw is that
we are keeping up a very

00:41:41.380 --> 00:41:42.870
strong momentum in our tools.

00:41:42.960 --> 00:41:44.740
There are lots of new great features.

00:41:44.740 --> 00:41:51.400
And of course,
we implement all that so that

00:41:51.400 --> 00:41:53.590
you can keep up a strong momentum
in your own applications.

00:41:53.590 --> 00:41:53.590
So please start using Xcode 3.

00:41:53.590 --> 00:41:53.590
Thanks, Andreas.

00:41:58.480 --> 00:41:59.240
Thank you, Andreas.

00:41:59.410 --> 00:42:01.820
I think that there's something wrong with
the mirroring in the heads-up display.

00:42:01.820 --> 00:42:05.310
It's interesting how many bugs you
discover here on stage that you

00:42:05.310 --> 00:42:06.680
never see in the development lab.

00:42:06.950 --> 00:42:12.560
So, summary of some of the top features.

00:42:12.560 --> 00:42:16.760
Faster editor, code focus,
message bubbles, snapshots.

00:42:16.760 --> 00:42:20.830
Really what we're trying to do here is
create a fearless style of programming,

00:42:20.830 --> 00:42:24.690
right, where you can try out different
things and really debug them.

00:42:26.720 --> 00:42:29.210
Integrating file merge,
a feature I heard a lot of applause

00:42:29.210 --> 00:42:30.450
for and I knew you'd love it.

00:42:30.530 --> 00:42:34.200
All these things, I think,
are going to make Xcode an incredibly,

00:42:34.200 --> 00:42:36.070
incredibly productive environment.

00:42:36.080 --> 00:42:39.440
One of the parts about how
all this fits together,

00:42:39.440 --> 00:42:44.080
of course, is a lot of you, of course,
are developing applications

00:42:44.080 --> 00:42:49.000
that you want to ship using
Xcode 2 and Xcode 3 on Leopard.

00:42:49.000 --> 00:42:51.190
And so,
one of the things which we've been

00:42:51.190 --> 00:42:54.280
thinking about and gotten kind
of a bunch of feedback is that

00:42:54.350 --> 00:42:56.340
you want to use these two tastes.

00:42:56.600 --> 00:42:58.240
You want to use these two
great tastes together.

00:42:58.260 --> 00:43:00.920
But, of course, in the past, you can't.

00:43:00.920 --> 00:43:02.350
You can only have one
installed at a time.

00:43:02.360 --> 00:43:05.530
So, today I'm going to make a commitment.

00:43:05.530 --> 00:43:11.340
And, yes, we're going to, at Leopard GM,
we will have Xcode 2 and Xcode 3 be

00:43:11.340 --> 00:43:14.600
able to coexist on your Leopard system.

00:43:14.600 --> 00:43:15.830
Thank you.

00:43:21.670 --> 00:43:25.840
Now, let's switch gears and
talk about performance.

00:43:25.840 --> 00:43:28.940
And performance is two
great important parts.

00:43:28.940 --> 00:43:31.800
First part is a 64-bit compiler.

00:43:31.800 --> 00:43:34.160
And the second part is tools.

00:43:34.170 --> 00:43:41.600
You heard Simon talk about that
64-bit doesn't improve everything.

00:43:41.600 --> 00:43:46.550
So you need tools as well to understand
when to use 64-bit and whether 64-bit

00:43:46.710 --> 00:43:48.810
is good for your application or not.

00:43:48.880 --> 00:43:51.990
But let's first focus on the compilers.

00:43:52.330 --> 00:43:58.180
So of course we give you GCC4 and
GCC4 is already a 64-bit compiler.

00:43:58.330 --> 00:44:01.760
We've measured and seen
between 15% and 20% faster code

00:44:01.760 --> 00:44:03.640
generation on 64-bit Intel.

00:44:03.640 --> 00:44:06.660
And as well,
we also see that Dwarf is giving

00:44:06.660 --> 00:44:11.420
us much faster build times just
by switching from Stabs to Dwarf.

00:44:11.490 --> 00:44:13.720
So if you haven't switched,
I highly recommend that you do.

00:44:14.860 --> 00:44:19.460
The better code generation in
part is because of the registers

00:44:19.460 --> 00:44:21.660
and new addressing modes.

00:44:21.660 --> 00:44:24.860
And in fact, it doesn't affect every
application equally.

00:44:24.860 --> 00:44:27.530
When we use spec just as
kind of a benchmark comparing

00:44:27.590 --> 00:44:31.740
32-bit and 64-bit performance,
we see very different behavior.

00:44:31.740 --> 00:44:38.190
Some of the kernels degrade,
but most improve.

00:44:38.370 --> 00:44:40.640
And in fact,
some improve quite dramatically.

00:44:40.640 --> 00:44:44.700
If you have an application
which uses 64-bit data types,

00:44:44.700 --> 00:44:44.800
you're going to see a lot
of different behavior.

00:44:44.910 --> 00:44:46.640
It's going to love 64-bit, obviously.

00:44:46.640 --> 00:44:51.860
But really,
even parsers and crunching applications

00:44:51.860 --> 00:44:55.570
like the various compressions,
BZIP and GZIP,

00:44:55.570 --> 00:44:58.630
both have significant improvement.

00:44:58.640 --> 00:45:02.290
So you have to understand whether
or not your application is going to

00:45:02.290 --> 00:45:06.530
be able to take advantage of 64-bit
if all you're doing is performance.

00:45:06.590 --> 00:45:08.960
Obviously,
if you're going to want the scalability,

00:45:08.960 --> 00:45:11.100
you're going to move
for that purpose alone.

00:45:11.100 --> 00:45:14.800
But for performance purposes,
I think 64-bit is going to be the best.

00:45:14.820 --> 00:45:17.380
64-bit can be a great improvement.

00:45:18.110 --> 00:45:21.390
Now, how do you know whether or
not 64-bit is good for you?

00:45:21.450 --> 00:45:24.330
Well, of course,
you need great performance tools.

00:45:24.330 --> 00:45:27.280
And performance tools are
a bit like being a juggler.

00:45:27.280 --> 00:45:30.030
One moment you start up Chud,
another moment you're

00:45:30.260 --> 00:45:33.070
starting up an object Alec,
and another moment you're in

00:45:33.090 --> 00:45:34.990
all the other performance tools.

00:45:34.990 --> 00:45:37.420
And it's kind of a problem, right?

00:45:38.420 --> 00:45:39.780
So, what do you do?

00:45:39.790 --> 00:45:40.920
What do you do?

00:45:40.920 --> 00:45:43.710
You're never in the right tool because
you want to look at one part and then

00:45:43.800 --> 00:45:46.490
another part is under investigation.

00:45:46.490 --> 00:45:49.140
And oftentimes, you're going to see, aha,
we need to look at the

00:45:49.190 --> 00:45:51.740
multiple threads and the way
it interacts across the system.

00:45:51.740 --> 00:45:54.390
And so, in thinking about this,
and of course,

00:45:54.390 --> 00:45:56.880
the multi-core architectures
we live in now,

00:45:56.920 --> 00:45:59.480
really we wanted to provide
you with a new tool,

00:45:59.480 --> 00:46:02.770
something that brings all
the functionality together.

00:46:02.770 --> 00:46:06.240
And so, to do that,
we've created something called X-Ray.

00:46:06.240 --> 00:46:08.120
X-Ray is a new tool.

00:46:08.420 --> 00:46:10.420
It's a new tool that's been
released on the XO Tools DVD.

00:46:10.420 --> 00:46:13.020
And really,
I believe that it's going to be a

00:46:13.020 --> 00:46:17.120
revolution because it's a framework that
brings together all the different kinds

00:46:17.220 --> 00:46:19.420
of tools and instruments into one place.

00:46:19.420 --> 00:46:22.440
And, well,
I could tell you more about it again,

00:46:22.440 --> 00:46:25.910
but really,
a better demo is worth a thousand words.

00:46:25.910 --> 00:46:29.080
I'll bring up Jeff Glasson,
manager of performance tools.

00:46:29.080 --> 00:46:30.650
Thanks, Ted.

00:46:30.660 --> 00:46:31.910
Thank you.

00:46:33.800 --> 00:46:35.290
Hope you're having a great day.

00:46:35.290 --> 00:46:37.900
You've gotten a lot
of information so far.

00:46:38.080 --> 00:46:41.550
I have the honor and privilege to
be the first to introduce to you a

00:46:41.550 --> 00:46:44.400
brand new application called XRay.

00:46:44.420 --> 00:46:50.110
Now what XRay is, is it is a unified
performance analysis tool.

00:46:50.280 --> 00:46:54.550
It allows you to analyze the behavior
of your program and how it affects

00:46:54.550 --> 00:46:59.100
system performance and how it interacts
with other things on the system.

00:46:59.170 --> 00:47:03.360
I think the best way to show you more
about it is to actually show it to you.

00:47:08.310 --> 00:47:10.200
Let's hope the demo gods are appeased.

00:47:10.220 --> 00:47:16.790
So the first thing you see when you
launch X-Ray is you see actually kind

00:47:16.830 --> 00:47:18.520
of a somewhat familiar user interface.

00:47:18.520 --> 00:47:21.160
It is reminiscent of a garage band.

00:47:21.160 --> 00:47:24.320
And we have instruments.

00:47:24.320 --> 00:47:25.090
They have instruments.

00:47:25.130 --> 00:47:25.890
They're a little different.

00:47:25.900 --> 00:47:30.320
The top of the screen is the area
where you can put your instruments.

00:47:30.320 --> 00:47:31.890
There is a master track.

00:47:31.900 --> 00:47:35.460
One thing that's very common
between music and performance

00:47:35.460 --> 00:47:37.380
analysis is the concept of time.

00:47:38.100 --> 00:47:40.600
And I'll explain that a
little bit more later.

00:47:40.600 --> 00:47:43.970
And down at the bottom,
you've got a set of pre-built

00:47:43.970 --> 00:47:46.140
instruments that we supply.

00:47:46.140 --> 00:47:49.880
Probably by the time we ship this,
there'll be a lot more in that.

00:47:49.960 --> 00:47:52.200
But this is what we have for you today.

00:47:52.200 --> 00:47:56.320
You also have the capability of
creating your own instruments through

00:47:56.380 --> 00:47:58.550
customization and new instrumentation.

00:47:58.560 --> 00:48:01.660
So let's see how this works.

00:48:03.540 --> 00:48:07.840
I'm going to drag a couple
instruments up to the instrument bar.

00:48:07.850 --> 00:48:12.490
Object ALEC and network traffic monitor.

00:48:12.490 --> 00:48:16.310
And actually,
let's make some more room here.

00:48:16.310 --> 00:48:20.390
Make the window a little bigger.

00:48:20.390 --> 00:48:20.390
Oops.

00:48:20.910 --> 00:48:23.610
And also,
let's put something else up there,

00:48:23.720 --> 00:48:25.920
File Activity Monitor.

00:48:25.960 --> 00:48:29.260
And now,
I'm going to hit the Play button and

00:48:29.260 --> 00:48:33.920
select an application we use every day,
which is Safari.

00:48:33.920 --> 00:48:35.830
And we're going to run it.

00:48:36.360 --> 00:48:39.540
So as Safari comes up under X-Ray,
you're going to see data starting

00:48:39.540 --> 00:48:43.100
to be collected and displayed in the
graphical user interface up above.

00:48:43.140 --> 00:48:48.130
And instruments can display information
in a number of different ways.

00:48:48.200 --> 00:48:48.970
Let's stop that.

00:48:48.980 --> 00:48:51.690
We have enough data to show you.

00:48:52.020 --> 00:48:55.740
The object instrument is configured
to show you a graph of memory

00:48:55.750 --> 00:48:57.050
being used by your program.

00:48:57.190 --> 00:49:01.040
The network traffic instrument is showing
traffic for your network in and out.

00:49:01.080 --> 00:49:06.200
And the little blips are showing
different file system events.

00:49:06.200 --> 00:49:11.050
And if you scroll, you can get detailed
views with tool tips.

00:49:11.140 --> 00:49:15.800
You can actually drop down here
and see a very extended view.

00:49:15.870 --> 00:49:19.990
And you get stack traces
whenever an event occurs.

00:49:20.150 --> 00:49:25.250
So you can use this-- a
little bit of applause.

00:49:28.010 --> 00:49:32.770
So this is, I think,
the first time Apple has given you a

00:49:32.970 --> 00:49:38.320
tool that shows you multiple different
views of different aspects of the system.

00:49:38.430 --> 00:49:41.010
But what about that master
track I mentioned earlier?

00:49:41.120 --> 00:49:42.800
So let me show you that.

00:49:42.800 --> 00:49:47.510
Create a new document.

00:49:47.930 --> 00:49:54.050
Earlier in the day,
you heard Steve mention accessibility.

00:49:54.210 --> 00:49:57.930
And one of the benefits,
one of the other features

00:49:57.940 --> 00:50:01.680
of accessibility in making
your apps accessible is this,

00:50:01.680 --> 00:50:04.760
because we tie into the same
accessibility frameworks.

00:50:04.930 --> 00:50:10.400
All I need to do is click Record,
and I'm going to launch an application

00:50:10.400 --> 00:50:14.970
that is actually a modified version of
the AppKit TextEdit example that I've

00:50:15.050 --> 00:50:17.920
modified to use Garbage Collection.

00:50:18.000 --> 00:50:23.080
And I'm going to run it while
I'm recording what I do.

00:50:23.160 --> 00:50:24.280
The app launches.

00:50:24.280 --> 00:50:26.710
I can open a file.

00:50:29.400 --> 00:50:32.350
Select some text.

00:50:32.480 --> 00:50:35.280
Open up the text menu.

00:50:36.070 --> 00:50:40.080
Change the color and then stop.

00:50:40.220 --> 00:50:43.530
So what you see on the master track
is an actual recording of all the

00:50:43.530 --> 00:50:47.390
user interface events that I did.

00:50:53.310 --> 00:50:55.690
And there's actually a couple
different ways to look at that also.

00:50:55.760 --> 00:50:57.370
This is just showing
them strung together,

00:50:57.580 --> 00:51:03.130
but you can also look at them
in time as seconds or minutes.

00:51:03.130 --> 00:51:05.760
And that's scalable,
and you can see exactly when

00:51:05.760 --> 00:51:07.460
the event occurred in time.

00:51:07.770 --> 00:51:10.880
Now, we didn't stop there.

00:51:11.160 --> 00:51:16.410
We actually added the capability of
saving these recordings as templates

00:51:16.410 --> 00:51:18.160
and integrated that into Xcode.

00:51:18.280 --> 00:51:20.200
So let me show you that.

00:51:20.870 --> 00:51:25.060
I've actually saved a little
bit longer script of a template.

00:51:25.420 --> 00:51:28.790
And so I'm going to open the
TextEdit project in Xcode.

00:51:29.500 --> 00:51:32.310
And under the debug menu,
I think those of you that have

00:51:32.310 --> 00:51:35.560
used Xcode before have seen the
launch using Performance Tool.

00:51:35.560 --> 00:51:38.870
And you might see a few things
you haven't seen before.

00:51:39.020 --> 00:51:42.940
File System Monitor and below,
those are all actual X-ray templates.

00:51:43.040 --> 00:51:48.120
And TextEdit is the one that I've
created myself to help me monitor

00:51:48.120 --> 00:51:49.970
and performance tune TextEdit.

00:51:50.090 --> 00:51:51.270
So let me open that up.

00:51:51.430 --> 00:51:54.140
So I'm away from the keyboard.

00:51:54.190 --> 00:51:56.090
No tricks, nothing up my sleeve.

00:51:56.230 --> 00:51:59.640
It's actually going and running
the workflow that I've created.

00:51:59.640 --> 00:52:06.900
Doing a little bit more
than I saved last time.

00:52:11.000 --> 00:52:12.780
That's the end.

00:52:12.860 --> 00:52:14.760
And this time,
the template that I created actually

00:52:14.850 --> 00:52:18.960
contained a couple instruments to
monitor the garbage collector running.

00:52:18.960 --> 00:52:21.420
The top graph is actually
showing bytes of memory in use.

00:52:21.420 --> 00:52:23.600
And you can, again,
go through the detail view

00:52:23.600 --> 00:52:25.920
and scroll and see events.

00:52:26.250 --> 00:52:28.850
And then down here,
these are actual times when a

00:52:28.850 --> 00:52:32.330
garbage collection event occurs,
and you can see the bytes collected.

00:52:32.460 --> 00:52:36.620
So what you can do with this is
you can create a saved workflow.

00:52:36.630 --> 00:52:39.930
You can then run it over and over again
as you change your application and

00:52:39.940 --> 00:52:42.610
watch how it changes the performance.

00:52:50.310 --> 00:52:53.300
So I've only scratched
the surface of this tool.

00:52:53.300 --> 00:52:56.200
In fact,
we're actually not quite sure the

00:52:56.200 --> 00:52:57.800
real uses of this tool is so powerful.

00:52:57.800 --> 00:52:59.620
And that's up to you guys.

00:52:59.620 --> 00:53:01.660
And if you really want
to learn more about this,

00:53:01.660 --> 00:53:04.430
there's a whole hour dedicated
to X-Ray on Thursday afternoon.

00:53:04.430 --> 00:53:05.780
I believe it's at 2 o'clock.

00:53:05.780 --> 00:53:07.230
And I hope you guys are all there.

00:53:07.230 --> 00:53:08.120
Thanks, Ted.

00:53:08.120 --> 00:53:08.930
Thanks, Jeff.

00:53:14.210 --> 00:53:16.440
I think this is an incredible new tool.

00:53:16.580 --> 00:53:21.120
It pulls together a number of different
technologies and instrumentation,

00:53:21.120 --> 00:53:24.650
has its own plug-in interface,
and as well it uses the

00:53:24.690 --> 00:53:27.590
D-Trace scripting language,
event monitoring language,

00:53:27.600 --> 00:53:32.010
to be able to monitor and very rapidly
create ad hoc instruments as well.

00:53:32.280 --> 00:53:35.760
So we think this is a tool with
an incredible amount of potential.

00:53:35.760 --> 00:53:38.880
And given that so many performance
problems sometimes are the

00:53:38.880 --> 00:53:42.940
interactions of many systems,
databases, web servers, and applications,

00:53:42.940 --> 00:53:46.620
we really believe this is going
to be a very powerful tool in your

00:53:46.940 --> 00:53:49.120
toolbox to understand and do things.

00:53:49.120 --> 00:53:52.920
And to really help figure out how to
make use of all that compute power,

00:53:52.920 --> 00:53:57.460
all those CPUs and network capabilities
and other frameworks that we provide.

00:53:57.460 --> 00:53:59.770
Of course,
it captures the events you need.

00:53:59.790 --> 00:54:02.050
The instruments operate independently.

00:54:02.280 --> 00:54:03.280
They're all in parallel.

00:54:03.280 --> 00:54:08.220
And very importantly,
this concept of a master track to record

00:54:08.220 --> 00:54:11.820
the events for repeatable debugging runs
so that you can actually inject a little

00:54:11.820 --> 00:54:13.560
bit of science into performance tuning.

00:54:13.560 --> 00:54:15.420
And I think that's going
to be a big help to you.

00:54:15.480 --> 00:54:17.800
So that's X-Ray.

00:54:25.400 --> 00:54:26.270
What's next?

00:54:26.370 --> 00:54:27.700
Interoperability.

00:54:27.700 --> 00:54:29.020
Interoperability.

00:54:29.020 --> 00:54:31.510
Well,
now you've heard Jeff and Steve talk

00:54:31.650 --> 00:54:35.360
to you about the importance
of making your app accessible.

00:54:35.360 --> 00:54:37.290
Well, it doesn't stop there.

00:54:37.290 --> 00:54:41.110
We also want you to make your
app scriptable and automatable.

00:54:41.130 --> 00:54:42.690
I know it's a lot of work.

00:54:42.690 --> 00:54:44.270
But the payoff is great.

00:54:44.270 --> 00:54:44.930
Here it is.

00:54:45.060 --> 00:54:49.390
If you can make your app accessible,
all these kinds of applications,

00:54:49.390 --> 00:54:52.770
and another one you'll see in a minute,
become part of the

00:54:52.910 --> 00:54:55.370
interoperability of your app.

00:54:55.410 --> 00:54:58.290
The interoperability
story of your application.

00:54:58.290 --> 00:55:01.260
Making it scriptable, of course,
has been a great,

00:55:01.260 --> 00:55:03.560
great benefit of Mac OS X for many years.

00:55:03.560 --> 00:55:06.590
And of course, with Tiger,
we released Automator.

00:55:06.590 --> 00:55:09.690
And Automator, very powerful,
wonderful feature.

00:55:09.690 --> 00:55:11.700
Let's talk about Automator.

00:55:11.700 --> 00:55:14.630
This little guy has been a big success.

00:55:14.690 --> 00:55:16.020
People love him.

00:55:16.130 --> 00:55:17.560
He's kind of cute.

00:55:17.560 --> 00:55:21.640
And on top of that,
it really is part of the way people use

00:55:21.640 --> 00:55:27.570
a desktop productivity system to use it
in this ecosystem of many applications.

00:55:27.820 --> 00:55:29.920
There are thousands of actions now.

00:55:29.920 --> 00:55:34.010
And your end users can use that
to combine together to create

00:55:34.010 --> 00:55:37.000
functionality that has better lock-in.

00:55:37.010 --> 00:55:40.470
And so, really,
I believe that Automator is a way

00:55:40.470 --> 00:55:45.220
to extend the functionality and
capabilities of your applications

00:55:45.390 --> 00:55:51.680
so that it is part of a very rich
system of great applications.

00:55:51.720 --> 00:55:55.360
And of course,
we're not going to stop there.

00:55:55.360 --> 00:55:55.360
We've been thinking about, now,
how can we improve this?

00:55:55.360 --> 00:55:55.360
How can we improve this?

00:55:55.370 --> 00:55:57.880
How can we improve on what has
been already a fabulous run?

00:55:57.880 --> 00:56:01.080
And we're thinking about Automator 2.

00:56:01.300 --> 00:56:05.460
And so,
Automator 2 is going to be easier to use,

00:56:05.460 --> 00:56:09.690
using accessibility,
and more efficient to make it

00:56:09.690 --> 00:56:12.520
even more powerful and faster.

00:56:12.520 --> 00:56:15.140
And everywhere,
we're going to give you the capability

00:56:15.140 --> 00:56:18.370
to take Automator functionality
and embed it in your application.

00:56:18.370 --> 00:56:20.610
Big feature request
that you've asked for.

00:56:21.970 --> 00:56:26.140
So let's give you a show and
show you what that looks like.

00:56:26.330 --> 00:56:28.240
I'm going to invite Todd Fernandez up.

00:56:28.260 --> 00:56:30.180
Todd.

00:56:30.180 --> 00:56:33.160
Automation Tools Manager, give us a demo.

00:56:35.140 --> 00:56:35.970
Thank you, Ted.

00:56:36.020 --> 00:56:37.610
Good afternoon, developers.

00:56:37.650 --> 00:56:40.710
Ted has just called upon you to
make your applications accessible,

00:56:40.880 --> 00:56:42.620
scriptable, and automatable.

00:56:42.690 --> 00:56:45.320
So to demonstrate how important
we really think that is,

00:56:45.340 --> 00:56:47.480
I'd like to show you what
we've done with Xcode,

00:56:47.500 --> 00:56:52.690
both as an example of the benefits
that we think you'll see by doing so,

00:56:55.730 --> 00:56:58.000
What's that?

00:56:58.070 --> 00:57:00.480
So Xcode is scriptable
in its initial release,

00:57:00.500 --> 00:57:03.160
and we continue to expand and
improve upon its scripting

00:57:03.160 --> 00:57:05.700
interface in subsequent releases.

00:57:06.060 --> 00:57:08.260
Automator also has a number
of Automator actions,

00:57:08.360 --> 00:57:09.880
so it's already automatable.

00:57:09.930 --> 00:57:12.880
But we wanted to make it even easier
for developers like you to take

00:57:12.900 --> 00:57:14.660
advantage of workflow automation.

00:57:14.840 --> 00:57:17.530
So as Ted has said,
we've integrated Automator

00:57:17.530 --> 00:57:18.780
right into Xcode.

00:57:18.860 --> 00:57:22.900
But before I show you what we've done,
I want to set the stage a little bit.

00:57:22.970 --> 00:57:25.260
Can I have the demo machine, please?

00:57:25.930 --> 00:57:28.760
So let's imagine that you've been
hard at work all weekend adding a

00:57:28.760 --> 00:57:30.400
new feature to your application.

00:57:30.610 --> 00:57:36.190
In my case here,
the ubiquitous text edit.

00:57:36.940 --> 00:57:39.790
And you really want to make it
look nice when you send it out

00:57:39.910 --> 00:57:42.530
for some wider testing and maybe
to your boss so that he knows how

00:57:42.530 --> 00:57:44.900
hard you were working all weekend.

00:57:45.020 --> 00:57:48.510
But there's no easy way within Xcode
to create a package and maybe add

00:57:48.580 --> 00:57:52.680
it to a disk image so it's easy to
distribute or send out as an email.

00:57:52.760 --> 00:57:55.730
This cries out for a workflow.

00:57:55.830 --> 00:57:58.110
So let me show you what we've done.

00:58:03.830 --> 00:58:07.060
We've added a Workflows menu
to Xcode's Application menu.

00:58:07.080 --> 00:58:10.190
As we can see, the first option--

00:58:10.530 --> 00:58:12.200
is the workflow that I've described.

00:58:12.220 --> 00:58:15.440
I want to create a package and add it
to a disk image so I can distribute

00:58:15.440 --> 00:58:17.660
my great new version of TextEdit.

00:58:18.270 --> 00:58:23.430
Now this is within Xcode,
and the three AM workflow model

00:58:23.440 --> 00:58:26.060
view controller classes we used
to create it have been added to

00:58:26.060 --> 00:58:29.170
the Automator framework so that
you can use them within your own

00:58:29.170 --> 00:58:32.000
applications to do the same integration.

00:58:32.060 --> 00:58:35.540
Now those of you with good eyes
may be able to determine another

00:58:35.540 --> 00:58:39.060
great new Automator 2 feature,
workflow variables.

00:58:39.270 --> 00:58:42.680
Those blue tokens in the text
fields in both actions are

00:58:42.760 --> 00:58:45.040
in fact workflow variables.

00:58:45.040 --> 00:58:49.710
Variables are an efficient way to
avoid repetitive data entry and pass

00:58:50.360 --> 00:58:54.780
information into and between actions
outside of the normal data flow.

00:58:55.320 --> 00:58:58.140
And they're even more powerful
when combined with application

00:58:58.140 --> 00:58:59.510
integration as they are here.

00:59:00.030 --> 00:59:03.130
Because the two variables I'm using,
product name and product version,

00:59:03.130 --> 00:59:06.050
are defined and set by Xcode
based on information that it

00:59:06.150 --> 00:59:07.720
possesses about my project.

00:59:07.810 --> 00:59:11.080
So I don't need to reconfigure this
workflow when I want to run it against

00:59:11.080 --> 00:59:13.260
some other great application I'm writing.

00:59:15.060 --> 00:59:17.560
And in fact,
your applications can define new

00:59:17.560 --> 00:59:20.950
variables that make sense within
your application so that your users

00:59:20.950 --> 00:59:22.880
can create more powerful workflows.

00:59:22.940 --> 00:59:25.530
And what we found is when you make
it easier for customers to integrate

00:59:25.580 --> 00:59:28.850
your application into automation,
you've made loyal customers.

00:59:29.010 --> 00:59:32.150
They will not want to go
back to doing things by hand.

00:59:32.360 --> 00:59:35.000
So let me show you how this works.

00:59:35.050 --> 00:59:38.270
Well, in fact,
I think my title in my package should

00:59:38.270 --> 00:59:39.840
really have the product version as well.

00:59:39.870 --> 00:59:44.580
So I can use type completion
to add it into my title.

00:59:45.220 --> 00:59:47.440
and let's go ahead and run it.

00:59:47.520 --> 00:59:51.240
So we'll see the workflow run and if all
goes well and the demo gods are with me,

00:59:51.290 --> 00:59:56.170
the package and the disk image appear on
my desktop and the disk image is mounted.

00:59:56.620 --> 00:59:59.680
So let's go ahead and
open that disk image up.

00:59:59.750 --> 01:00:02.720
And as you can see,
all the name and version information

01:00:02.720 --> 01:00:05.650
are on my package and disk image.

01:00:05.780 --> 01:00:08.060
And when I open my
package up in installer,

01:00:08.110 --> 01:00:11.800
I see that the name and
version are there as well.

01:00:11.960 --> 01:00:15.710
So the combination of application
integration and variables give

01:00:15.940 --> 01:00:20.670
me a powerful solution to make my
boss aware of all my hard work.

01:00:22.800 --> 01:00:26.520
Let me clean this up a
bit before moving on.

01:00:26.590 --> 01:00:31.540
So far I've talked about variables
making your workflows more efficient.

01:00:31.560 --> 01:00:34.280
And I've talked about the new
AM workflow classes making it

01:00:34.370 --> 01:00:36.680
possible to have Automator everywhere.

01:00:36.710 --> 01:00:40.390
But I haven't talked about
making workflows easier.

01:00:40.870 --> 01:00:44.850
Well, I'm glad that you liked what
Jeff showed you in X-Ray's master

01:00:44.850 --> 01:00:48.390
track in terms of UI recording,
because we think it's great.

01:00:48.400 --> 01:00:49.420
We agree with that.

01:00:49.500 --> 01:00:53.340
We thought it was so cool that we wanted
to build it into Automator as well.

01:00:53.450 --> 01:00:55.900
So let me show you what that looks like.

01:01:02.900 --> 01:01:06.100
You might be able to see the new
record button in Automator's toolbar.

01:01:06.110 --> 01:01:09.110
And when I click that button,
Automator will begin recording my

01:01:09.110 --> 01:01:13.130
interactions with the OS and its
applications and encapsulating them in a

01:01:13.130 --> 01:01:15.560
new Automator action called Watch Me Do.

01:01:15.560 --> 01:01:17.810
And I'd love to show it to you.

01:01:20.450 --> 01:01:24.270
So let me just make a simple
recording using our friend Xcode.

01:01:24.420 --> 01:01:27.620
I'm going to switch the
build configuration.

01:01:27.640 --> 01:01:30.250
Build and go, text edit.

01:01:33.170 --> 01:01:36.940
Type something in and then
quit and dismiss the dialogue

01:01:36.940 --> 01:01:37.870
and then stop my recording.

01:01:39.880 --> 01:01:42.150
Let me zoom in so you can
see that a little bit better.

01:01:42.280 --> 01:01:47.180
You can see within Watch Me Do,
each event is recorded separately in a

01:01:47.950 --> 01:01:51.200
nicely graphical way so you'll be able to
tell what the heck this recording is six

01:01:51.200 --> 01:01:53.870
months later when you look at it again.

01:01:56.300 --> 01:01:58.620
And let me show you the playback.

01:01:58.620 --> 01:02:04.510
Let me reset our state here just so I can
also do my no hands on the keyboard.

01:02:04.880 --> 01:02:08.980
So I've already talked about
scriptability and automatability,

01:02:08.980 --> 01:02:11.840
but I haven't talked about
accessibility any further.

01:02:11.900 --> 01:02:16.590
And as has already been mentioned today,
as Steve's Leopard feature number seven,

01:02:16.590 --> 01:02:21.420
the new Universal Access features,
as well as the spotlight within

01:02:21.420 --> 01:02:24.430
your application to find and help
users find what they're looking

01:02:24.430 --> 01:02:28.780
for to control your application,
X-Ray's Master Track and Watch Me Do all

01:02:28.780 --> 01:02:31.940
depend on your applications
being thoroughly accessible.

01:02:31.960 --> 01:02:35.840
There's now a huge payoff beyond
the obvious benefits for making your

01:02:35.840 --> 01:02:38.090
application thoroughly accessible.

01:02:39.050 --> 01:02:42.950
So, Otto is jumping for joy,
the workflow is completed.

01:02:43.420 --> 01:02:46.810
And also to remind me that there's
one more cool thing about Watch Me Do.

01:02:46.900 --> 01:02:50.790
If I select all my events,
I can copy and paste these into

01:02:50.790 --> 01:02:56.200
Script Editor or simply drag them out
into Automator and translate them into

01:02:56.420 --> 01:03:00.530
the equivalent GUI scripting code.

01:03:07.340 --> 01:03:08.110
I'm glad you like it.

01:03:08.280 --> 01:03:11.900
So then you can configure them
further to your heart's content.

01:03:12.050 --> 01:03:15.160
So now that I've motivated you to
make your applications accessible,

01:03:15.160 --> 01:03:18.320
scriptable, and automatable,
I hope to see all of you in the sessions

01:03:18.410 --> 01:03:22.220
later this week that will help you
do just that with your applications.

01:03:22.300 --> 01:03:22.840
Thanks very much.

01:03:23.030 --> 01:03:25.020
Thanks, Todd.

01:03:27.890 --> 01:03:29.180
Automator 2.

01:03:29.210 --> 01:03:30.820
Watch me do, make it easier.

01:03:30.820 --> 01:03:32.460
Anyone now can use Automator.

01:03:32.460 --> 01:03:35.860
Workflow variables for
the more professional,

01:03:35.860 --> 01:03:37.980
more experienced users and workflow.

01:03:37.980 --> 01:03:42.310
This is for developers so you can
embed Automator in your application,

01:03:42.430 --> 01:03:44.640
a framework that's accessible.

01:03:44.640 --> 01:03:48.080
And workflow view and workflow
controller and workflow model.

01:03:48.080 --> 01:03:49.140
Nice Cocoa Apps.

01:03:51.050 --> 01:03:52.190
Scriptability.

01:03:52.190 --> 01:03:54.800
We've talked a lot about scriptability.

01:03:54.940 --> 01:03:58.530
And one of the big parts here is
how can we make it easier for you

01:03:58.530 --> 01:04:00.330
to use all these capabilities?

01:04:00.330 --> 01:04:03.910
Obviously, you could write Apple Script,
but can you actually use

01:04:03.910 --> 01:04:05.680
scripts from other applications?

01:04:05.720 --> 01:04:09.420
Applications like FrontRow, for example,
use Scriptability.

01:04:09.420 --> 01:04:13.740
And so we've developed a feature
we call Scripting Bridge to make it

01:04:13.740 --> 01:04:19.560
even easier to develop applications
that drive other applications.

01:04:19.560 --> 01:04:20.570
So what's the model here?

01:04:20.570 --> 01:04:23.820
Well, here it is, your application,
and you want to talk to iTunes

01:04:23.820 --> 01:04:25.320
and get the current song.

01:04:25.330 --> 01:04:28.580
Well, you could write Apple Script,
very straightforward,

01:04:28.720 --> 01:04:32.820
and you simply tell app iTunes to
get the name of the current track.

01:04:32.930 --> 01:04:34.360
It's that simple.

01:04:34.370 --> 01:04:37.550
Now, learning Apple Script, of course,
yeah, well, it looks a little weird.

01:04:37.550 --> 01:04:39.110
It doesn't look like a
programming language.

01:04:39.110 --> 01:04:41.420
It's supposed to be kind of English-like,
and it is.

01:04:41.540 --> 01:04:42.230
And it's very simple.

01:04:42.230 --> 01:04:46.620
You can actually take this code and
you can embed it into your application

01:04:46.620 --> 01:04:49.370
using Common Class and as Apple Script.

01:04:49.370 --> 01:04:51.040
And it's just that easy to do.

01:04:51.210 --> 01:04:53.200
But this is not very popular.

01:04:53.200 --> 01:04:56.340
And one of the big reasons why it's not
very popular is now you have to know both

01:04:56.400 --> 01:04:59.240
Apple Script and Objective-C to do it.

01:04:59.240 --> 01:05:01.340
And as well, it's kind of slow.

01:05:01.440 --> 01:05:02.680
It's kind of slow.

01:05:02.680 --> 01:05:06.280
It takes about a second for the
Apple Script interpreter to start

01:05:06.320 --> 01:05:08.120
up and for that machinery to work.

01:05:08.130 --> 01:05:09.820
Now, there is a faster way.

01:05:09.820 --> 01:05:13.220
Very experienced people know about this.

01:05:13.220 --> 01:05:15.600
And it's called NSApple Event

01:05:16.330 --> 01:05:19.570
And it's kind of hard and ugly
to use because you have to know

01:05:19.570 --> 01:05:22.330
all the four character codes
and you write them like that.

01:05:22.360 --> 01:05:24.370
And people actually do
this because it's faster.

01:05:24.380 --> 01:05:26.660
But you're generating
the raw Apple events.

01:05:26.660 --> 01:05:29.510
And that's a straightforward
way to do it.

01:05:29.530 --> 01:05:32.120
But even though this is faster,
people don't often do

01:05:32.120 --> 01:05:34.750
it because it's kind of,
well, obvious reasons.

01:05:37.370 --> 01:05:40.630
There is a third way,
and we call it Scripting Bridge.

01:05:40.750 --> 01:05:43.200
And what Scripting Bridge is,
we're going to give you a

01:05:43.200 --> 01:05:46.620
tool to simply run it against
any Apple script dictionary,

01:05:46.620 --> 01:05:50.000
against any application that has
an Apple script capabilities.

01:05:50.000 --> 01:05:55.500
And it's going to generate for
you a set of Cocoa classes,

01:05:55.500 --> 01:05:57.560
and it's just that.

01:05:57.560 --> 01:05:59.020
That's the code there to get
the current song from iTunes.

01:05:59.020 --> 01:05:59.020
It's that simple, those two lines.

01:06:05.040 --> 01:06:06.720
But the best part is the performance.

01:06:06.730 --> 01:06:07.700
It's not just simple.

01:06:07.720 --> 01:06:09.000
It's also extremely performant.

01:06:09.060 --> 01:06:12.290
It's 80 times faster than Apple script.

01:06:16.810 --> 01:06:17.640
That's Scripting Bridge.

01:06:17.640 --> 01:06:18.460
I think you're going to love it.

01:06:18.600 --> 01:06:20.260
And I really encourage you to use this.

01:06:20.280 --> 01:06:23.510
I think it makes every application
that's scriptable into part

01:06:23.520 --> 01:06:25.180
of a service that you can use.

01:06:25.180 --> 01:06:27.440
And I think you're
going to really like it.

01:06:27.460 --> 01:06:30.740
Switching gears slightly,
let's talk about a couple of open source

01:06:30.740 --> 01:06:34.520
projects and a little bit of things
that we've been doing on the horizon.

01:06:34.540 --> 01:06:37.400
And many people have heard
about this technology we're

01:06:37.430 --> 01:06:39.400
working on in-house called LLVM.

01:06:39.400 --> 01:06:40.720
It's a compiler framework.

01:06:40.720 --> 01:06:42.420
It's a new back end for GCC.

01:06:42.420 --> 01:06:44.080
It uses the same front end as GCC.

01:06:44.280 --> 01:06:45.650
And we're using it in ourselves.

01:06:45.650 --> 01:06:47.770
We're exploring different
capabilities of it.

01:06:47.870 --> 01:06:51.220
It has a just-in-time compiler,
kind of like Java does,

01:06:51.320 --> 01:06:54.980
but for the C class of languages,
C-flavored languages.

01:06:54.980 --> 01:06:57.140
And we've used this with OpenGL.

01:06:57.190 --> 01:07:00.660
It's part of the OpenGL pipeline
that's in Leopard.

01:07:00.660 --> 01:07:03.800
And it's been extremely wonderful to use.

01:07:03.800 --> 01:07:07.530
Essentially,
as part of the pipeline for a given

01:07:07.530 --> 01:07:12.490
scene that pulls together a number
of different functions and raster

01:07:12.490 --> 01:07:14.000
operations and vector operations.

01:07:14.280 --> 01:07:14.290
And we've been working
on this for a long time.

01:07:14.290 --> 01:07:14.300
And we're working on
this for a long time.

01:07:14.300 --> 01:07:14.310
And we're working on
this for a long time.

01:07:14.310 --> 01:07:14.560
And we're working on
this for a long time.

01:07:14.560 --> 01:07:14.570
And we're working on
this for a long time.

01:07:14.570 --> 01:07:14.580
And we're working on
this for a long time.

01:07:14.580 --> 01:07:14.670
And we're working on
this for a long time.

01:07:14.790 --> 01:07:17.420
They get specialized
dynamically on the fly.

01:07:17.470 --> 01:07:21.620
What that means is, so for example,
if there's a feature like fog, right,

01:07:21.700 --> 01:07:24.490
fog, that your image doesn't use,
that is often a very

01:07:24.780 --> 01:07:26.760
computationally intensive.

01:07:26.760 --> 01:07:29.680
And there's a lot of places
in the pipeline code where

01:07:29.680 --> 01:07:32.810
that would be executed,
where the scene generation and

01:07:32.810 --> 01:07:35.260
utility actually would leverage that.

01:07:35.310 --> 01:07:39.590
And what LLVM does is it takes the
bytecodes that assemble this compiler

01:07:39.750 --> 01:07:44.090
representation intermediate form
at runtime and optimizes it away.

01:07:44.280 --> 01:07:47.690
So essentially, we're making a bit of the
compiler part of the runtime.

01:07:47.700 --> 01:07:50.170
And we're going to be exploring
different uses of this technology.

01:07:50.180 --> 01:07:53.810
So that's LLVM,
and it's available as well for you to

01:07:53.880 --> 01:07:56.820
explore on the website at LLVM.org.

01:07:56.820 --> 01:07:59.080
A bit of interesting
open source technology.

01:08:01.220 --> 01:08:03.000
Another technology that
I know you're going to love.

01:08:03.050 --> 01:08:07.100
Well,
another bit of interesting technology,

01:08:07.160 --> 01:08:07.890
Spotlight.

01:08:08.030 --> 01:08:09.640
Now,
there are many programming languages,

01:08:09.720 --> 01:08:11.660
not just the ones that Apple supports.

01:08:11.660 --> 01:08:14.440
And we provide you with a number
of importers for Spotlight,

01:08:14.440 --> 01:08:15.890
but not for every language.

01:08:15.910 --> 01:08:19.140
And we've been looking around
for some better indexing

01:08:19.140 --> 01:08:21.030
technology to use with Xcode.

01:08:21.160 --> 01:08:25.180
So we've been looking around,
and we found one.

01:08:25.180 --> 01:08:27.090
It's called Doxygen.

01:08:27.100 --> 01:08:28.100
Doxygen is an open
source indexing package.

01:08:30.160 --> 01:08:34.140
And we found a number of incredible
and important benefits to it,

01:08:34.210 --> 01:08:37.980
which I think the best way to look
at it is just for a demo again,

01:08:37.980 --> 01:08:40.410
to see the spotlight integration.

01:08:40.540 --> 01:08:42.670
So I'd like to invite
Brent Shank up to give us a demo.

01:08:42.680 --> 01:08:44.240
Thanks, Ted.

01:08:49.690 --> 01:08:52.080
As Ted said,
we're using Doxygen to power the new

01:08:52.260 --> 01:08:56.960
Spotlight source code importer that
will ship with Leopard GM and Xcode 3.0.

01:08:57.190 --> 01:08:58.490
Why are we using Doxygen?

01:08:58.670 --> 01:09:01.400
Well, we're using it because it supports
all your favorite languages.

01:09:01.400 --> 01:09:03.980
It supports C++, Objective-C,
and your favorite

01:09:03.980 --> 01:09:06.590
scripting languages too,
like Perl and Ruby.

01:09:06.600 --> 01:09:09.600
And we've been working really
closely with the Doxygen developer

01:09:09.600 --> 01:09:11.980
to get this feature off the ground,
so we'd like to thank

01:09:12.050 --> 01:09:13.450
him for all his help.

01:09:13.600 --> 01:09:16.540
So what benefit does this
give you as a user of Xcode?

01:09:16.590 --> 01:09:18.570
Well,
I'll be happy to show you right now.

01:09:22.210 --> 01:09:26.720
I'm going to launch Xcode
and I'm going to open Osiris.

01:09:26.750 --> 01:09:28.520
Andreas showed you this project before.

01:09:28.520 --> 01:09:30.440
It's a large open source project.

01:09:30.440 --> 01:09:32.700
It has thousands of source files.

01:09:32.740 --> 01:09:37.900
I'll show you it has over 700 CC files.

01:09:38.200 --> 01:09:44.140
If I have the right thing selected,
it has a number of Objective-C files.

01:09:44.230 --> 01:09:46.250
So this is a fairly big project.

01:09:46.320 --> 01:09:49.490
And if I were to perform a
full text search in Xcode,

01:09:49.720 --> 01:09:51.680
it would probably take
longer than I wanted to.

01:09:51.680 --> 01:09:55.220
And I'd go get a cup of coffee,
which is OK, because I love coffee.

01:09:55.250 --> 01:09:58.210
But you'll notice there's a
fourth search option here.

01:09:58.220 --> 01:10:01.220
It's called Spotlight Symbol Find.

01:10:01.260 --> 01:10:03.630
And I'm going to enter
a search string here.

01:10:04.500 --> 01:10:20.000
[Transcript missing]

01:10:22.440 --> 01:10:23.640
I click on the search results.

01:10:23.640 --> 01:10:26.670
They look just like search results
from doing a full text search do.

01:10:26.680 --> 01:10:30.740
They take me right to the place in the
source file where that symbol exists.

01:10:30.750 --> 01:10:33.400
I can search for some other things.

01:10:34.260 --> 01:10:37.340
And again, it's a super fast search.

01:10:37.530 --> 01:10:39.780
As we like to say,
searching for symbols in Xcode

01:10:39.780 --> 01:10:42.260
now is not just going to be fast,
it's going to be spotlight fast.

01:10:42.390 --> 01:10:44.530
We think you're really going to love it.

01:10:45.470 --> 01:10:48.600
And again, it's a super fast search.

01:10:48.740 --> 01:10:50.980
As we like to say,
searching for symbols in Xcode

01:10:50.980 --> 01:10:53.430
now is not just going to be fast,
it's going to be spotlight fast.

01:10:53.560 --> 01:10:55.740
We think you're really going to love it.

01:11:15.370 --> 01:11:18.510
The search will actually
be performed on--

01:11:18.600 --> 01:11:27.600
[Transcript missing]

01:11:30.710 --> 01:11:34.180
So what I'm showing you now is not on
the Leopard seed that you got today,

01:11:34.180 --> 01:11:36.140
but it's something we're
going to ship with Leopard GM.

01:11:36.210 --> 01:11:39.610
There's one more thing, one surprise,
that's also not on the developer seed,

01:11:39.620 --> 01:11:40.560
but we know you're going to love it.

01:11:40.770 --> 01:11:42.690
I'd like to show it to you now.

01:11:43.280 --> 01:11:46.380
and we call it Workspace.

01:11:46.400 --> 01:11:49.180
And what this is, this is a really,
I'll close my project here,

01:11:49.180 --> 01:11:51.890
this is a really lightweight
way to use Xcode.

01:11:52.010 --> 01:11:55.270
So when you don't want all the
complexity of an Xcode project,

01:11:55.270 --> 01:11:58.950
and you want to organize
arbitrary kinds of files,

01:11:58.950 --> 01:12:00.590
this is a really great feature.

01:12:00.600 --> 01:12:03.220
So I'm going to add the drag and
drop outline view example since I've

01:12:03.220 --> 01:12:04.690
been doing a lot with outline views.

01:12:04.690 --> 01:12:07.870
And you can see it shows me all
the source files in the project.

01:12:07.880 --> 01:12:09.200
I can load them over here.

01:12:09.200 --> 01:12:13.080
And now I get all the benefits of
Xcode's full featured source code editor.

01:12:13.100 --> 01:12:16.560
But without the overhead
and complexity of a project.

01:12:16.560 --> 01:12:19.340
And I can also display and
edit other types of files too.

01:12:19.340 --> 01:12:22.590
So this is another feature that
we're really excited to provide

01:12:22.590 --> 01:12:25.560
to you in the GM version of
Xcode that ships with Leopard.

01:12:25.560 --> 01:12:26.290
Thank you.

01:12:33.480 --> 01:12:38.830
So spotlight integration, Doxygen,
really working to improve the speed

01:12:39.220 --> 01:12:46.320
and fidelity and capabilities really
of Xcode in a project-less session.

01:12:47.240 --> 01:12:50.420
I've been holding out on you,
the fifth column here.

01:12:50.420 --> 01:12:52.010
What is that fifth column?

01:12:52.210 --> 01:12:54.490
And that fifth column is fun, right?

01:12:55.400 --> 01:12:57.570
So how can we have fun?

01:12:57.580 --> 01:13:00.770
I mean, programming isn't just about
improving our productivity,

01:13:00.770 --> 01:13:02.480
but it's also about enjoying what we do.

01:13:02.490 --> 01:13:07.570
And you saw a demo, you saw a quick,
Scott introduced it this morning,

01:13:07.630 --> 01:13:10.290
a great new tool we call Dashcode.

01:13:10.290 --> 01:13:12.290
And I want to demo for you now.

01:13:12.290 --> 01:13:16.670
Dashcode is Apple's own complete
widget development environment.

01:13:16.670 --> 01:13:19.780
It really is an incredible, fun way,
I think,

01:13:19.970 --> 01:13:23.560
to introduce people to programming,
but as well to get

01:13:23.560 --> 01:13:25.270
interesting things done.

01:13:25.300 --> 01:13:26.500
And I think it's going to be a great
tool for you to use in no time at all.

01:13:26.740 --> 01:13:31.200
It has some great templates,
as Scott said, a visual designer,

01:13:31.200 --> 01:13:36.130
a reusable parts library, a code editor,
and a JavaScript debugger.

01:13:36.210 --> 01:13:38.280
And I think you're going
to really enjoy it.

01:13:38.280 --> 01:13:42.460
So let's give you a demo of Dashcode.

01:13:45.700 --> 01:13:55.700
[Transcript missing]

01:13:57.510 --> 01:14:00.040
So as you can see,
there's a number of templates.

01:14:00.080 --> 01:14:02.640
Wish I had time to show
them all to you today.

01:14:02.640 --> 01:14:07.000
Maybe to create RSS widgets is what
I'm going to show you right now.

01:14:07.000 --> 01:14:10.740
But you can create a countdown
timer and use photo casts.

01:14:10.740 --> 01:14:13.490
Great way to link into
Quartz Composer and so on.

01:14:13.560 --> 01:14:15.830
So let's just do that right now.

01:14:15.980 --> 01:14:18.380
And what you see here
is a visual designer.

01:14:18.440 --> 01:14:22.840
On the left-hand side is
the document object model.

01:14:22.840 --> 01:14:24.000
Expand that down.

01:14:24.070 --> 01:14:24.800
Different attributes.

01:14:24.800 --> 01:14:30.710
On the lower left here are little
guides just to walk you through.

01:14:30.860 --> 01:14:34.000
And what it's telling me
is to provide an RSS feed.

01:14:34.500 --> 01:14:37.660
So let's start up Safari.

01:14:37.660 --> 01:14:40.060
I'm just going to drag it over.

01:14:41.000 --> 01:14:42.240
And really, no typing.

01:14:42.500 --> 01:14:44.350
Vice presidents can't
be expected to type.

01:14:44.560 --> 01:14:47.330
Bam,
I've got myself a little RSS feed widget.

01:14:47.330 --> 01:14:48.370
It's that simple.

01:14:50.900 --> 01:14:52.300
Now you say, OK, Ted, that's great.

01:14:52.300 --> 01:14:55.860
You know, wonderful that you can
build widgets pre-canned.

01:14:55.860 --> 01:14:59.580
What can you do that
doesn't look like it?

01:14:59.600 --> 01:15:02.610
So let's modify things.

01:15:03.150 --> 01:15:04.160
Clean things up a little bit.

01:15:04.280 --> 01:15:09.800
And I'm going to throw away
some of these nice components.

01:15:10.080 --> 01:15:15.130
And just leave up the
image and content area.

01:15:15.410 --> 01:15:18.460
Now I'm going to select and open
up in the inspector and just

01:15:18.460 --> 01:15:20.090
tell it to hide the content.

01:15:20.100 --> 01:15:22.490
Okay, so now I've got a kind
of an empty canvas here.

01:15:22.530 --> 01:15:26.880
Make it a little bit bigger
and bring up my parts library.

01:15:26.900 --> 01:15:31.140
And...

01:15:36.950 --> 01:15:41.620
And let's scroll down and see all
the familiar kinds of components.

01:15:41.650 --> 01:15:45.410
And I'm going to pick a gauge
up and just drop it there.

01:15:45.430 --> 01:15:48.660
And now let's resize the gauge out.

01:15:51.200 --> 01:16:14.600
[Transcript missing]

01:16:15.000 --> 01:16:18.500
And here it is, kind of Xcode-like,
simple pop-up of all the functions.

01:16:18.500 --> 01:16:26.730
And now let's look up and move that.

01:16:29.650 --> 01:16:31.430
And I'm going to drop
a few lines of code,

01:16:31.540 --> 01:16:35.770
something that just searches
through the different RSS entries,

01:16:35.770 --> 01:16:41.530
looking for the words
iPod and Mac and counting.

01:16:43.100 --> 01:16:46.020
Let's run it, see what happens.

01:16:46.160 --> 01:16:49.200
And it hit an exception, a null value.

01:16:49.220 --> 01:16:50.860
Let's take a look at the run log.

01:16:50.860 --> 01:16:57.560
And it brings me, of course,
right to the error line.

01:16:59.560 --> 01:17:01.460
And I noticed that in fact,
Document Get there,

01:17:01.580 --> 01:17:03.860
there's no Document Get,
it's Document Get Element.

01:17:03.860 --> 01:17:06.480
So let's go and I don't want to type.

01:17:06.550 --> 01:17:07.740
Type the one letter E.

01:17:07.740 --> 01:17:11.430
Element by ID, complete that.

01:17:11.430 --> 01:17:14.790
Let's stop and run it again.

01:17:19.410 --> 01:17:22.060
Did I lose my network feed?

01:17:22.080 --> 01:17:24.900
Oh, Pod Mac.

01:17:30.540 --> 01:17:31.500
Well, you know what?

01:17:31.500 --> 01:17:35.770
I'm going to hard code in
which one's better today.

01:17:35.810 --> 01:17:38.490
Since demo gods don't love me.

01:17:41.600 --> 01:17:47.160
and David Davis.

01:17:47.160 --> 01:17:50.680
Just so that you can see some
pretty colors because nobody

01:17:50.680 --> 01:17:50.680
likes to see a gray dial.

01:17:56.010 --> 01:18:01.320
Go, stop, run.

01:18:01.470 --> 01:18:02.180
Ha ha.

01:18:02.200 --> 01:18:04.120
No, still doesn't love me.

01:18:04.150 --> 01:18:05.400
View, run log.

01:18:05.400 --> 01:18:10.230
I'm going to debug this right on the fly.

01:18:10.230 --> 01:18:16.540
It's going to make everybody necessary.

01:18:16.540 --> 01:18:18.460
Ha ha ha ha.

01:18:18.460 --> 01:18:20.310
I notice.

01:18:27.410 --> 01:18:28.400
Mac is better.

01:18:28.400 --> 01:18:35.820
So you can see very simple,
straightforward way,

01:18:35.860 --> 01:18:38.160
lots of capabilities.

01:18:38.160 --> 01:18:41.200
Bugger very powerful
and lots of great stuff.

01:18:41.200 --> 01:18:42.140
So that's Xcode.

01:18:42.140 --> 01:18:43.260
I think you're going to love it.

01:18:43.260 --> 01:18:47.960
It's great to build widgets and
I think other interesting things.

01:18:47.960 --> 01:18:53.440
Let's go back to

01:18:54.570 --> 01:18:55.900
All the tools you need.

01:18:55.930 --> 01:18:59.630
Scalability, productivity,
interoperability, performance,

01:18:59.660 --> 01:19:01.680
and to have fun.

01:19:01.680 --> 01:19:08.500
All the way from Xcode,
interface builder, automator, X-ray,

01:19:08.500 --> 01:19:09.700
dash code.

01:19:09.760 --> 01:19:14.110
Lots and lots of other capabilities I've
barely begun to scratch the surface on.

01:19:14.450 --> 01:19:18.290
And really,
I think the innovation that the

01:19:18.290 --> 01:19:22.710
Mac OS X developers and developer
teams has really is unique and

01:19:22.950 --> 01:19:25.910
really pushing the envelope of
what I think the capabilities are.

01:19:25.930 --> 01:19:26.910
And I think you're going to love it.

01:19:27.010 --> 01:19:32.190
So that's our developer
tool lineup for Positron.

01:19:32.500 --> 01:19:35.230
And as they're setting up,
what's our surprise?

01:19:35.350 --> 01:19:37.810
What's our surprise?

01:19:38.600 --> 01:19:45.590
So, given how heroic you've all
been in these difficult,

01:19:45.600 --> 01:19:49.000
making the Intel transition and creating
all these wonderful applications,

01:19:49.100 --> 01:19:49.930
we thought we would thank you.

01:19:50.000 --> 01:19:53.150
And of course, the best way to thank
a hero is with a song.

01:19:53.150 --> 01:19:57.280
So I'd like to invite up
James Dempsey and the Breakpoints Up.

01:20:08.990 --> 01:20:10.730
- Thank you, Ted.

01:20:10.870 --> 01:20:14.780
So in the past,
I've done a song or two at WWDC,

01:20:14.780 --> 01:20:18.120
and this year I brought
along some reinforcements.

01:20:18.380 --> 01:20:21.910
So I'd like to introduce to you
the breakpoints on guitar is Mr.

01:20:21.910 --> 01:20:23.360
Gordy Friedman.

01:20:27.860 --> 01:20:32.310
and as always on keyboard, Mr.

01:20:32.310 --> 01:20:34.800
Victor Alexander.

01:20:34.920 --> 01:20:40.540
So, over the past year there's been an
amazing transition to Universal Binaries

01:20:40.600 --> 01:20:45.420
and I was thinking a little bit about
some of the technical nuances involved.

01:20:45.450 --> 01:20:48.520
I wrote a little song
that I hope you all enjoy.

01:20:48.570 --> 01:20:55.310
It's a little tune called
"Indian Reservations."

01:21:03.570 --> 01:21:09.740
♪ Well you might have some
Indian reservations over bit flipping,

01:21:09.740 --> 01:21:15.980
head tripping complications
♪ ♪ Getting it right however

01:21:15.980 --> 01:21:19.300
everybody's interpreted ♪

01:21:20.450 --> 01:21:25.630
♪ 'Cause if your processor changed ♪
♪ You might not keep things arranged

01:21:25.630 --> 01:21:31.620
like the last one did ♪ ♪ Well,
eight bits make up a byte ♪ ♪ Each bit

01:21:31.620 --> 01:21:36.740
is active or it slumbers ♪ ♪ But eight
is not enough to represent the larger

01:21:36.740 --> 01:21:41.180
numbers ♪ ♪ So bytes are strung
together now in twos and fours and

01:21:41.180 --> 01:21:47.470
eights ♪ ♪ Each byte contains a
portion of the represented state ♪

01:21:50.700 --> 01:22:08.600
[Transcript missing]

01:22:10.800 --> 01:22:15.490
♪ I said you might have
some Indian reservations

01:22:15.490 --> 01:22:18.030
over network of byte order ♪

01:22:18.100 --> 01:22:25.400
[Transcript missing]

01:22:27.270 --> 01:22:32.390
Your code could give up the
ghosts without them network

01:22:32.390 --> 01:22:34.620
to host type utilities.

01:22:34.790 --> 01:22:40.620
Oh, my processor says potato,
yours says potato.

01:22:40.620 --> 01:22:44.270
Oh, two different patterns
represent the same data.

01:22:44.270 --> 01:22:48.080
One puts significance first,
the other saves it for later.

01:22:48.080 --> 01:22:54.660
The most annoying switcheroo
since Anakin became Vader.

01:22:56.800 --> 01:23:02.930
♪ Well you might have some
Indian reservations over file or

01:23:02.930 --> 01:23:09.360
format specifications ♪ ♪ What is
the risk dealing with files on

01:23:09.460 --> 01:23:12.280
disk is what you want to know ♪

01:23:13.400 --> 01:23:18.770
The file header should mention
or it's simply convention

01:23:18.850 --> 01:23:21.010
how the bytes should go.

01:23:21.800 --> 01:23:26.400
Well do you have to break this code
or has someone else cracked it?

01:23:26.400 --> 01:23:30.410
You can use an API that's
already abstracted.

01:23:30.410 --> 01:23:34.550
Your development schedule
won't be greatly impacted.

01:23:34.570 --> 01:23:39.270
Then you can blog about it
like some guy on .macdiv.

01:23:42.200 --> 01:23:47.060
Well,
you dealt with your Andean reservations.

01:23:47.060 --> 01:23:51.430
All the byte swapping,
flip-flopping permutations.

01:23:51.430 --> 01:23:54.740
Fixed every goof,
made your code bulletproof.

01:23:55.400 --> 01:24:01.000
[Transcript missing]

01:24:01.300 --> 01:24:37.700
[Transcript missing]
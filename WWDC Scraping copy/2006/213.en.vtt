WEBVTT

00:00:10.530 --> 00:00:14.790
And welcome to the session
Optimal 2D Graphics,

00:00:14.840 --> 00:00:17.370
which will conclude our evening.

00:00:18.000 --> 00:00:19.420
So my name is Ralph Bruhner.

00:00:19.420 --> 00:00:22.690
I manage Quartz 2D Graphics.

00:00:22.690 --> 00:00:25.560
And here's the entertainment
for the coming hour.

00:00:25.560 --> 00:00:30.460
So we will talk a bit about core graphics
architectural changes in Leopard.

00:00:30.460 --> 00:00:33.280
We'll talk about how to
do performance tuning.

00:00:33.280 --> 00:00:38.200
That's going to be a bit about power
consumption and why that matters.

00:00:38.240 --> 00:00:41.930
And we also talk a bit about
color matching and then a bunch

00:00:41.950 --> 00:00:44.040
of pointers to other places.

00:00:44.940 --> 00:00:47.430
So first topic I have is 64-bit.

00:00:47.460 --> 00:00:51.950
Essentially,
you heard that Leopard essentially has

00:00:51.950 --> 00:00:54.900
all the frameworks in 64-bit available.

00:00:54.900 --> 00:00:59.430
And as a core graphics client,
what 64-bit mainly gives you

00:00:59.470 --> 00:01:01.800
is a really big address space.

00:01:01.800 --> 00:01:06.530
And one of the things you can do with
that is to render to large bitmaps.

00:01:06.540 --> 00:01:10.320
Now there's an interesting problem
that if you have really large bitmaps,

00:01:10.330 --> 00:01:13.980
let's say more than half a
million pixels wide or tall,

00:01:14.580 --> 00:01:18.510
that a single precision float is
actually not sufficient to describe

00:01:18.560 --> 00:01:22.600
the coordinates accurately enough
to do anti-aliased rendering.

00:01:22.710 --> 00:01:29.470
So to address that problem,
we introduce a CG float type in our API,

00:01:29.480 --> 00:01:33.040
which replaces the previous version,
which was just a single precision float.

00:01:33.040 --> 00:01:37.840
And CG float in a 32-bit process is a
single precision floating point number,

00:01:37.840 --> 00:01:40.040
while in a 64-bit process,
it's a double precision

00:01:40.110 --> 00:01:41.220
floating point number.

00:01:41.300 --> 00:01:43.780
So not only can your
pointer address more memory,

00:01:43.780 --> 00:01:46.990
the actual coordinates you use
can address the same memory.

00:01:46.990 --> 00:01:49.470
That's essentially the idea.

00:01:50.360 --> 00:01:53.460
So if your app is building
for a pre-Leopard OS,

00:01:53.570 --> 00:01:57.620
just use float because it's
naturally forward compatible.

00:01:59.600 --> 00:02:00.840
Excuse me.

00:02:00.860 --> 00:02:01.700
So one point.

00:02:01.700 --> 00:02:04.230
Somebody's talking behind me.

00:02:04.230 --> 00:02:05.000
Okay.

00:02:06.600 --> 00:02:10.400
So one point I would like to make
is about performance with 64-bit.

00:02:10.470 --> 00:02:14.360
On PowerPC, 64-bit performance-wise
is pretty much a wash.

00:02:14.360 --> 00:02:18.400
So your 32-bit application in
regards to CG will run about as

00:02:18.410 --> 00:02:21.020
fast as the 64-bit application.

00:02:21.550 --> 00:02:24.440
However, on Intel,
there's actually a performance gain.

00:02:24.440 --> 00:02:29.280
And the main reason is on Intel 64-bit,
you have twice as many registers so that

00:02:29.340 --> 00:02:32.140
the compiler can produce better code gen.

00:02:32.140 --> 00:02:37.040
And you have slightly modernized ABI,
which makes function calls cheaper.

00:02:37.040 --> 00:02:41.170
So we have measured up to 10%
speed improvement just going from

00:02:41.190 --> 00:02:46.600
Intel 32-bit to Intel 64-bit by doing
things like rendering PDFs and so on.

00:02:46.780 --> 00:02:51.040
So you might want to consider
going to 64-bit if that helps you.

00:02:51.200 --> 00:02:55.110
But the summary of a 64-bit
is that it's pretty much a

00:02:55.110 --> 00:02:57.430
non-event for core graphics.

00:02:57.480 --> 00:03:01.200
Everything just continues
to work as you would expect.

00:03:01.250 --> 00:03:03.770
And there is very little
work for you to do.

00:03:05.540 --> 00:03:10.580
So the second topic I have is, well,
we made the bitmaps bigger by

00:03:10.580 --> 00:03:11.840
having a bigger address space.

00:03:11.840 --> 00:03:14.780
We also made the pixels deeper.

00:03:14.990 --> 00:03:19.730
So before Leopard,
you had the ability to have a CG image,

00:03:19.730 --> 00:03:22.380
which references 16-bit
per component images,

00:03:22.440 --> 00:03:25.580
among the all other formats
that were supported.

00:03:25.710 --> 00:03:29.740
In Leopard, you now also have the ability
to create a bitmap context that

00:03:29.740 --> 00:03:33.740
renders into 16-bit per component.

00:03:33.790 --> 00:03:37.560
And the main clients for these
kind of operations are scientific

00:03:37.560 --> 00:03:41.040
visualization and pro photography
are using 16-bit a lot.

00:03:41.040 --> 00:03:45.820
So now in Leopard you actually are
able to take a 16-bit image that comes

00:03:45.820 --> 00:03:50.550
from a high-end camera and scale it,
render it into a 16-bit context

00:03:50.550 --> 00:03:52.660
and not lose any fidelity there.

00:03:55.100 --> 00:03:58.200
So now let me talk about
the bigger changes.

00:03:58.200 --> 00:04:04.980
So every now and then we go and
essentially replace a subsystem

00:04:04.980 --> 00:04:08.340
of the operating system with
kind of a new implementation.

00:04:08.340 --> 00:04:11.920
And that's usually kind
of a disruptive change,

00:04:12.030 --> 00:04:15.660
lots of bugs that come
out of these operations.

00:04:15.660 --> 00:04:19.370
And what that does,
it kind of changes the performance

00:04:19.370 --> 00:04:23.530
characteristics of that
subsystem in a more radical way.

00:04:23.540 --> 00:04:26.280
And of course the hope is that all
the things that are going to be

00:04:26.280 --> 00:04:29.890
important in the next five years get,
you know, performance gain.

00:04:29.900 --> 00:04:32.590
Well,
we don't really want to break anything,

00:04:32.590 --> 00:04:35.620
but everything that used to
work stays more or less the

00:04:35.620 --> 00:04:37.590
same and nothing bad happens.

00:04:37.620 --> 00:04:38.210
That's the hope.

00:04:38.220 --> 00:04:41.260
Well, if chosen right,
this is kind of the gift

00:04:41.340 --> 00:04:42.980
that keeps on giving.

00:04:42.980 --> 00:04:46.040
And as an example,
I would like to point out Quartz Extreme.

00:04:46.040 --> 00:04:52.980
So a long time ago, it was, well,
just after the discovery of FHIR.

00:04:53.100 --> 00:04:55.920
But before that, you know,
invention of that wheel contraption,

00:04:55.920 --> 00:05:00.730
we introduced Quartz Extreme in, well,
Jaguar 2002.

00:05:00.740 --> 00:05:04.630
And the idea was to take
the software composite that

00:05:04.680 --> 00:05:08.070
we had before and put that,
all the compositing work that

00:05:08.070 --> 00:05:10.170
the Windows server is doing,
onto the graphics chip.

00:05:12.600 --> 00:05:17.050
And well, it was so great that today they
even sell you ice cream extreme,

00:05:17.170 --> 00:05:19.200
so that's kind of validation there.

00:05:19.200 --> 00:05:23.400
I guess we will have to have a
MaxiBond product at one point.

00:05:26.530 --> 00:05:30.600
So as an example, a year later,
I've introduced Expose.

00:05:30.600 --> 00:05:34.600
And Expose kind of made use of the
ability that you have all these windows

00:05:34.600 --> 00:05:37.800
as textures on the graphics card,
and now scaling them and moving

00:05:37.800 --> 00:05:40.920
them around is much cheaper.

00:05:42.630 --> 00:05:46.610
Well, two years later with Tiger we
introduced Dashboard and it kind

00:05:46.610 --> 00:05:49.510
of uses the same capabilities.

00:05:49.510 --> 00:05:53.330
So it now uses more translucency because,
well, it's kind of translucency is almost

00:05:53.330 --> 00:05:55.020
free from the client's perspective.

00:05:55.020 --> 00:05:59.840
And, well, having windows with arbitrary
shapes and complex alpha channels

00:05:59.840 --> 00:06:01.620
and so on is just working.

00:06:04.400 --> 00:06:06.450
And in LabBird,
we are kind of milking that

00:06:06.590 --> 00:06:09.930
feature again with Spaces,
where we now have several

00:06:09.980 --> 00:06:14.630
desktops full of windows,
and we can seamlessly move those around.

00:06:15.220 --> 00:06:17.600
So with that,
I would like to ask Assana Fard up

00:06:17.600 --> 00:06:20.790
on stage to give us a demo of Spaces.

00:06:26.180 --> 00:06:30.230
So Spaces was designed to increase
your display real estate without

00:06:30.230 --> 00:06:32.020
really discombobulating your desktop.

00:06:32.020 --> 00:06:35.170
So I'll go over some of the
features we have and a little bit

00:06:35.170 --> 00:06:37.140
about navigation and preferences.

00:06:37.140 --> 00:06:40.880
So the general view is
great for arrangement.

00:06:40.880 --> 00:06:43.430
You can pick your windows around,
you can reorganize them,

00:06:43.430 --> 00:06:44.350
move them around.

00:06:44.360 --> 00:06:48.980
ExposÃ© works if you need
to see more of your spaces.

00:06:48.980 --> 00:06:52.520
You can pick one, again,
move between spaces.

00:06:52.520 --> 00:06:56.030
One of the nice things is you can pick
up an entire app and move it around.

00:06:56.060 --> 00:06:59.720
You control click and we move it.

00:06:59.780 --> 00:07:02.310
We actually snap the windows back to
where they used to be so you don't

00:07:02.310 --> 00:07:03.890
have to rearrange again afterwards.

00:07:03.900 --> 00:07:07.680
You can arrange the spaces themselves.

00:07:07.680 --> 00:07:10.040
Just pick one up and put
it wherever you want to be.

00:07:10.150 --> 00:07:12.390
I'm going to move this guy back there.

00:07:12.430 --> 00:07:14.460
A little bit about navigation.

00:07:14.460 --> 00:07:17.040
This is, of course,
a great mode to navigate.

00:07:17.040 --> 00:07:19.000
Tap moves around your spaces.

00:07:19.000 --> 00:07:22.000
Arrow keys work, so on and so forth.

00:07:22.000 --> 00:07:24.500
And you can just unzoom to
wherever you want to be.

00:07:25.500 --> 00:07:28.270
At your desktop view,
it would be nicer to

00:07:28.270 --> 00:07:29.700
navigate a little bit faster.

00:07:29.700 --> 00:07:33.310
So we have programmed the
arrow keys to spatially move

00:07:33.310 --> 00:07:35.440
over your matrix of spaces.

00:07:35.440 --> 00:07:38.520
Your modify key is programmable.

00:07:38.520 --> 00:07:41.050
I have mine to control,
so control arrow just

00:07:41.200 --> 00:07:42.800
moves around your spaces.

00:07:42.800 --> 00:07:45.040
And similarly, your number keys work.

00:07:45.100 --> 00:07:47.440
So if you know exactly
where your Xcode project is,

00:07:47.440 --> 00:07:48.720
you just go control one.

00:07:48.720 --> 00:07:49.660
Oops, it's not there.

00:07:49.660 --> 00:07:50.880
It's right there.

00:07:50.970 --> 00:07:51.560
Or four.

00:07:51.560 --> 00:07:53.660
And you can just kind of
jump between the spaces.

00:07:55.350 --> 00:08:02.930
Another way to actually invoke
a space switch or space change

00:08:03.000 --> 00:08:04.020
is by dragging your window.

00:08:04.020 --> 00:08:07.270
You just drag the window
to the other side.

00:08:07.270 --> 00:08:10.060
I guess I'm not in the right place.

00:08:10.140 --> 00:08:10.610
There we go.

00:08:10.620 --> 00:08:11.790
Let's see.

00:08:11.790 --> 00:08:12.540
Oops.

00:08:12.540 --> 00:08:17.540
I guess my dragging doesn't
seem to be cooperating.

00:08:18.660 --> 00:08:22.560
But anyways,
you could pick up a window and basically

00:08:22.560 --> 00:08:25.620
move it to your space and see if
these guys work a little bit better.

00:08:27.030 --> 00:08:27.760
There we go.

00:08:27.830 --> 00:08:32.310
So we switch the space and
we bring the window with you.

00:08:32.610 --> 00:08:34.350
And you can also actually
on that same note,

00:08:34.440 --> 00:08:37.760
you can hold down your window
and just go somewhere else and

00:08:37.760 --> 00:08:39.110
your window comes with you.

00:08:39.120 --> 00:08:46.350
Now, a couple other things I want to
mention are about the preferences.

00:08:46.580 --> 00:08:50.500
We have a preference
pane in Exposian Spaces.

00:08:50.510 --> 00:08:55.160
And you can add rows and
add columns and remove them.

00:08:55.160 --> 00:08:58.380
And of course,
everything as usual is live.

00:08:58.480 --> 00:09:01.900
The other thing I wanted to mention is
if you remove a space with apps in it,

00:09:02.030 --> 00:09:03.490
don't worry about cleaning it up.

00:09:03.560 --> 00:09:04.610
We move everything over.

00:09:04.620 --> 00:09:07.230
We always remove the right
column and the bottom row.

00:09:07.430 --> 00:09:11.050
So we roll things up and
roll things over for you.

00:09:11.110 --> 00:09:13.550
The other thing I wanted to
mention is this concept of binding

00:09:13.550 --> 00:09:17.050
your application to Workspace,
which means at launch time or

00:09:17.060 --> 00:09:20.470
every time you open a new window,
your application will open

00:09:20.470 --> 00:09:22.100
in that particular space.

00:09:22.100 --> 00:09:23.640
So you can do that a couple of ways.

00:09:23.640 --> 00:09:25.300
You can either add an application.

00:09:25.340 --> 00:09:30.850
Let's see, let's say I wanna add my,
gosh, let's say iChat.

00:09:30.880 --> 00:09:34.960
You open it and then you can just
go in here and decide wherever

00:09:34.960 --> 00:09:37.480
you wanna put your application,
Workspace 3.

00:09:37.510 --> 00:09:42.880
The other way is by command
dragging out of your dock.

00:09:42.880 --> 00:09:46.060
So here I wanna put my
Safari in Workspace 1.

00:09:46.060 --> 00:09:48.120
and as we go, everything is there.

00:09:49.520 --> 00:09:52.980
One of the things I wanted to mention is,
again, let me go back in this mode,

00:09:52.980 --> 00:09:55.940
everything we do is live,
and our windows are alive,

00:09:55.940 --> 00:09:58.550
and the apps are rendering,
and we're drawing, and everyone's happily

00:09:58.640 --> 00:10:01.370
going about their business,
which is something that we can

00:10:01.490 --> 00:10:03.280
do because of Course Extreme.

00:10:03.280 --> 00:10:05.830
It really wouldn't have
been possible without it.

00:10:05.870 --> 00:10:08.820
So with that,
I'd like to introduce Andrew Barnes,

00:10:08.900 --> 00:10:13.170
who's going to talk about Course GL,
our next generation acceleration.

00:10:13.170 --> 00:10:14.700
Andrew.

00:10:14.700 --> 00:10:18.100
Thanks, Assana.

00:10:22.300 --> 00:10:25.480
So what we're really going to talk about
at this part of the section is about

00:10:25.540 --> 00:10:29.600
QuartzGL and just general optimizations
that you can do with your 2D graphics.

00:10:29.620 --> 00:10:31.860
And as my title suggests,
I'm the person who makes

00:10:31.950 --> 00:10:33.480
pixels show up on the screen.

00:10:33.720 --> 00:10:35.840
So anyway,
let's just start right away because

00:10:35.840 --> 00:10:37.880
we've got a fair amount of material.

00:10:38.070 --> 00:10:40.910
You've seen this architecture
slide many times before.

00:10:41.110 --> 00:10:43.960
Basically,
your applications draw either into

00:10:43.960 --> 00:10:49.200
DRAM via the window backing store or
via surfaces with 3D or video content.

00:10:49.220 --> 00:10:51.680
They all get mixed together
by the Quartz compositor and

00:10:51.780 --> 00:10:56.580
displayed onto the frame buffer,
which gets scanned out to the display.

00:10:56.670 --> 00:10:58.530
So obviously,
this session we're not going to

00:10:58.530 --> 00:11:02.520
talk about 3D and video because
this is 2D graphics and Quartz.

00:11:02.690 --> 00:11:04.520
The second thing we're not going
to talk about is Quickdraw.

00:11:04.520 --> 00:11:07.920
So hopefully you went to the
Quickdraw session last year where

00:11:07.920 --> 00:11:10.940
they basically told you to use Quartz.

00:11:10.970 --> 00:11:12.960
So we're not going to
talk about that either.

00:11:12.960 --> 00:11:16.060
What we are going to talk about
is a little bit about QuartzGL.

00:11:16.060 --> 00:11:19.180
QuartzGL basically
draws into VRAM instead.

00:11:19.310 --> 00:11:21.100
It's a very simple version of VRAM.

00:11:21.200 --> 00:11:23.190
It's a very simple version of VRAM.

00:11:23.200 --> 00:11:25.200
And everything happens like
you think it should happen.

00:11:25.200 --> 00:11:27.200
So what's QuartzGL?

00:11:27.200 --> 00:11:29.240
Well,
QuartzGL is an implementation on top

00:11:29.240 --> 00:11:31.220
of OpenGL of the entire Quartz 2D API.

00:11:31.220 --> 00:11:33.730
And its main goal is to
offload all the rendering onto

00:11:33.730 --> 00:11:35.210
the GPU where it should be.

00:11:35.220 --> 00:11:39.220
And as a side effect,
it also minimizes your DMA transfers

00:11:39.220 --> 00:11:41.220
that you go back and forth between your
window backing stores and your GPU.

00:11:41.220 --> 00:11:44.420
In addition to that,
it also allows you to have a

00:11:44.420 --> 00:11:48.540
more efficient or more integrated
model when you're dealing

00:11:48.540 --> 00:11:49.200
with a lot of the graphics.

00:11:49.330 --> 00:11:52.230
So it's not just about rendering,
it's about rendering with other

00:11:52.230 --> 00:11:53.200
hardware accelerated systems.

00:11:53.200 --> 00:11:55.200
For instance, Core Animation, Core Image,
OpenGL.

00:11:55.200 --> 00:11:59.200
Those stories slightly change as soon
as we start using the GPU all the time.

00:11:59.290 --> 00:12:01.220
So yeah, we went off and did this.

00:12:01.220 --> 00:12:03.220
We took some time to do it.

00:12:03.220 --> 00:12:05.220
And we learned a bunch
of lessons along the way.

00:12:05.270 --> 00:12:09.220
Basically, a lot of applications,
the majority of applications,

00:12:09.220 --> 00:12:11.220
rendering is not the bottom line.

00:12:11.220 --> 00:12:14.120
You do samples of applications and
they're spending time touching a disk

00:12:14.120 --> 00:12:15.170
updating preferences and stuff like that.

00:12:15.250 --> 00:12:17.210
So that's one thing we really did notice.

00:12:17.220 --> 00:12:19.200
We also noticed that people
didn't use the Quartz 2D API.

00:12:19.210 --> 00:12:21.200
They used the Quartz 2D
API in a very efficient way.

00:12:21.410 --> 00:12:24.480
And that, unfortunately,
turns out to be a little bit

00:12:24.480 --> 00:12:26.710
more costly for the GPU scenario.

00:12:26.850 --> 00:12:30.960
And the third and last thing that we
did learn is that once you start doing

00:12:30.960 --> 00:12:33.720
efficient programming using Quartz,
you can really fly.

00:12:33.740 --> 00:12:38.370
So let's take a look
at some of the details.

00:12:38.470 --> 00:12:42.410
So basically with a 2D guy,
you're drawing into your backing

00:12:42.410 --> 00:12:46.790
store at system memory speeds,
and we do that at 5 gigabytes a second.

00:12:46.800 --> 00:12:49.320
Once it's in DRAM,
the DRAM gets uploaded to

00:12:49.350 --> 00:12:51.330
VRAM at 2 gigabytes a second.

00:12:51.360 --> 00:12:53.910
With Quartz GL,
the formula change is slightly different.

00:12:54.530 --> 00:12:57.090
You're actually packing command
buffers at 2 gigabytes a second,

00:12:57.100 --> 00:12:59.530
which are much smaller than the
actual data that you're actually

00:12:59.620 --> 00:13:01.680
blitting if you were to use Quartz 2D.

00:13:01.680 --> 00:13:05.930
And your actual blitting speeds
are like 30 gigabytes a second.

00:13:05.940 --> 00:13:10.020
So, you know, it's all really basically
about the bandwidth.

00:13:10.020 --> 00:13:14.150
So here I had a scenario where basically,
you know, I wanted to show some numbers

00:13:14.150 --> 00:13:15.550
of how fast it could be.

00:13:15.560 --> 00:13:20.520
And this chart shows basically the
cycle of I want to draw a rectangle,

00:13:20.520 --> 00:13:23.270
256 by 256 rectangle.

00:13:23.300 --> 00:13:25.490
And then I want to tell the... I want
the Windows server to flush it.

00:13:25.500 --> 00:13:27.980
We've put the Windows server
and everybody in benchmark mode,

00:13:27.980 --> 00:13:30.400
so we try to minimize any kind
of blocking that you would see.

00:13:30.420 --> 00:13:34.820
So in their example, in this example,
you see the MacBook Pro and the

00:13:34.820 --> 00:13:39.670
Mac Pro using Quartz 2D would basically
start uploading huge amounts of data,

00:13:39.700 --> 00:13:42.430
DMAing via the backing store,
whereas Quartz GL,

00:13:42.490 --> 00:13:44.860
there's no backing store, so it's zero.

00:13:44.860 --> 00:13:49.760
Command buffers in Quartz 2D,
they're smaller than with Quartz GL.

00:13:49.760 --> 00:13:54.110
That's because we've translated
all of the hard work of that 3,300,

00:13:54.120 --> 00:14:00.100
500, gigabytes a second into, you know,
16 megabytes per second, right?

00:14:00.170 --> 00:14:02.140
So a lot of things has changed.

00:14:02.140 --> 00:14:07.020
And as a side effect also,
you also end up using less CPU.

00:14:07.020 --> 00:14:09.980
Quartz 2D uses a lot of CPU.

00:14:09.980 --> 00:14:12.460
Quartz GL uses less because
all it has to do is pack quads.

00:14:12.520 --> 00:14:15.760
And the grand total at the
end is basically a 2X for your

00:14:15.840 --> 00:14:19.060
MacBook Pro and for your Mac Pro,
you know, 4X.

00:14:19.100 --> 00:14:22.160
These numbers are obviously
pretty preliminary.

00:14:22.160 --> 00:14:24.260
But basically, that's the bottom line.

00:14:24.280 --> 00:14:27.180
Use QuartzGL,
you can get to the display faster.

00:14:27.730 --> 00:14:31.150
So now we're actually starting
to look at the nitty gritty.

00:14:31.170 --> 00:14:33.170
What we're trying to do is we're
trying to draw a bunch of images,

00:14:33.170 --> 00:14:33.580
right?

00:14:33.580 --> 00:14:37.900
Same size images, you know,
a whole range of images.

00:14:37.900 --> 00:14:39.500
And we say, okay, great.

00:14:39.500 --> 00:14:42.450
What we're going to do is we're
going to give you your application

00:14:42.450 --> 00:14:45.330
100% of the CPU and what can
you get done in that time?

00:14:45.330 --> 00:14:48.670
So obviously, as we can suspect,
the software just gets slower and

00:14:48.760 --> 00:14:52.790
slower because you're actually just
ending up filling more and more memory.

00:14:53.060 --> 00:14:56.570
Whereas in the hardware case, well,
it takes constant time to pack a quad.

00:14:56.570 --> 00:14:57.500
And that's it.

00:14:57.600 --> 00:15:00.280
So that's all great.

00:15:00.280 --> 00:15:01.750
And I'm sure a lot of
surfer dudes out there,

00:15:01.760 --> 00:15:03.420
developer surfer dudes
are probably thinking,

00:15:03.530 --> 00:15:04.880
dude, you know, what are you thinking?

00:15:04.880 --> 00:15:06.380
The GPU doesn't have infinite bandwidth.

00:15:06.470 --> 00:15:07.450
How does this really work out?

00:15:07.450 --> 00:15:09.270
You know,
I'm going to have to block some ways.

00:15:09.270 --> 00:15:11.270
Well, that's kind of true.

00:15:11.270 --> 00:15:12.750
You do have to block.

00:15:12.800 --> 00:15:16.150
And for the software cases,
which is the yellow and red,

00:15:16.160 --> 00:15:17.700
you see the usual curve.

00:15:17.700 --> 00:15:19.170
You start going down.

00:15:19.190 --> 00:15:22.840
But, you know, the GPU,
depending on how fast your GPU, i.e.

00:15:22.880 --> 00:15:26.700
the faster GPU being the blue line,
it actually takes a constant time.

00:15:26.700 --> 00:15:28.960
that it starts to end
up stalling on the GPU.

00:15:28.960 --> 00:15:33.110
And the faster your GPU,
the more that line, like, let's say,

00:15:33.110 --> 00:15:35.860
take the blue line,
would continue out and bulge over,

00:15:35.880 --> 00:15:38.300
you know,
to overlap and become faster in software.

00:15:38.300 --> 00:15:40.160
And then, of course,
some of you are actually

00:15:40.160 --> 00:15:41.420
thinking and looking,
well, you know,

00:15:41.420 --> 00:15:44.750
on the slightly less capable GPU,
it looks as if the GPU is

00:15:44.850 --> 00:15:47.140
kind of slower than the CPU.

00:15:47.140 --> 00:15:51.340
Well, that's... Sometimes that
can be unfortunate,

00:15:51.340 --> 00:15:52.530
but it's not always true.

00:15:52.540 --> 00:15:54.540
Here you have to look at
the other perspective.

00:15:54.540 --> 00:15:57.840
The other perspective is that even
though you've consumed all this

00:15:57.940 --> 00:16:00.940
time on your CPU and you're getting
more or less the same work done,

00:16:00.940 --> 00:16:02.720
how much CPU are you consuming?

00:16:02.720 --> 00:16:05.790
The software case consumes 100% of
the CPU in order to do those blitz,

00:16:05.860 --> 00:16:07.900
whereas a hardware case,
it gets less and less.

00:16:07.900 --> 00:16:09.020
So guess what?

00:16:09.060 --> 00:16:11.650
Use QuartzGL and you get
back all your CPU again.

00:16:11.720 --> 00:16:14.000
You can start going and touching the
disk and flying off and doing all the

00:16:14.030 --> 00:16:15.010
strange things that you want to do.

00:16:15.100 --> 00:16:16.480
So that's the advantage.

00:16:16.480 --> 00:16:22.750
So now let's basically say
what's going to happen.

00:16:22.760 --> 00:16:23.740
Enough with the silly benchmarks.

00:16:23.860 --> 00:16:25.300
What's really going to
happen with my application?

00:16:25.840 --> 00:16:28.680
Here we see a bunch of examples
of resizing because live resize is

00:16:28.680 --> 00:16:35.400
probably a very taxing scenario,
and you will get good exercise

00:16:35.400 --> 00:16:37.130
of your API by doing it.

00:16:37.220 --> 00:16:40.390
So there's a bunch of scenarios
where you're resizing mail

00:16:40.400 --> 00:16:44.000
and resizing text edit,
Xcode, scrolling, stuff like that,

00:16:44.000 --> 00:16:45.380
and we're seeing pretty decent gains.

00:16:45.380 --> 00:16:47.640
Personally, I'd like to see those
numbers a bit larger,

00:16:47.640 --> 00:16:50.610
and probably they'll end up being
larger at the time Leopard ships.

00:16:50.660 --> 00:16:53.940
But that's basically what happens.

00:16:53.940 --> 00:16:54.620
Okay, so great.

00:16:54.620 --> 00:16:55.460
That's one application.

00:16:55.460 --> 00:16:55.590
That's one application.

00:16:55.620 --> 00:16:55.820
Cool.

00:16:55.820 --> 00:16:59.280
Let's add a little bit
more complicated scenarios.

00:16:59.420 --> 00:17:01.060
Here I have a simple test where,
you know,

00:17:01.060 --> 00:17:04.540
we got Atlantis spinning away at
800 frames per second or whatever,

00:17:04.570 --> 00:17:07.520
and we got, you know,
four PDF documents all

00:17:07.520 --> 00:17:08.830
scrolling with transparency.

00:17:08.840 --> 00:17:10.860
We got a bunch of
different things going on,

00:17:10.860 --> 00:17:12.800
and this is what this really looks like.

00:17:12.820 --> 00:17:16.270
On your MacBook Pro,
you can see the DMAs are pretty large,

00:17:16.280 --> 00:17:19.420
and you see your CPU usage
across all the board,

00:17:19.420 --> 00:17:22.860
both with Quartz GL and Quartz
TD being pretty much constant time.

00:17:22.930 --> 00:17:23.910
But guess what happens?

00:17:23.930 --> 00:17:26.900
You're actually updating almost to,
you know, 1.5x, or 1.5x.

00:17:26.900 --> 00:17:28.760
So you're actually
getting more frames out.

00:17:28.790 --> 00:17:30.450
Of course, this is in benchmark mode,
of course.

00:17:30.480 --> 00:17:34.970
And, you know, as you see, as usual,
the DMA command data slightly goes up,

00:17:35.080 --> 00:17:37.790
but, you know,
but you get rid of all of that

00:17:37.850 --> 00:17:39.520
backing store DMA going up also.

00:17:39.540 --> 00:17:42.060
So that's good.

00:17:42.120 --> 00:17:46.280
So now what we're going to do
is sort of move into little

00:17:46.710 --> 00:17:50.260
practices that you can do to play
nice with Quartz GL and Quartz.

00:17:50.260 --> 00:17:54.600
And these optimizations that I'm talking
about basically apply to both systems.

00:17:54.600 --> 00:17:55.260
They're good.

00:17:55.310 --> 00:17:57.400
Once you start practicing these,
using these tips,

00:17:57.400 --> 00:18:00.920
you basically go a lot faster on
both the hardware and the software.

00:18:00.920 --> 00:18:04.280
So let's start off
with some fundamentals.

00:18:04.830 --> 00:18:07.000
Basically,
it doesn't matter what system you're on,

00:18:07.000 --> 00:18:09.850
graphics system or otherwise,
minimizing your state changes

00:18:09.870 --> 00:18:10.930
is always a good thing.

00:18:10.940 --> 00:18:13.980
It basically amortizes the
cost of a state change with

00:18:13.980 --> 00:18:14.980
respect to your operation.

00:18:14.980 --> 00:18:17.030
So you can set your black color,
and then draw a whole

00:18:17.030 --> 00:18:17.800
bunch of black text.

00:18:17.800 --> 00:18:19.840
You set your blue color as
opposed to going ping pong,

00:18:19.840 --> 00:18:20.240
ping pong.

00:18:20.280 --> 00:18:24.530
The second thing that you also
need to consider is drawing less,

00:18:24.530 --> 00:18:25.140
right?

00:18:25.140 --> 00:18:27.760
I mean,
you guys know what is going to be shown,

00:18:27.760 --> 00:18:28.800
what is going to be there.

00:18:28.800 --> 00:18:30.600
So discarding things is a good thing.

00:18:30.620 --> 00:18:33.410
Don't just say, oh,
I've got a scene of 50,000 things

00:18:33.420 --> 00:18:36.840
and just draw it and expect
us to do really fast stuff.

00:18:36.840 --> 00:18:39.510
And second thing, you know,
you always have to be very

00:18:39.510 --> 00:18:41.350
cautious about memory consumption.

00:18:41.360 --> 00:18:42.580
Memory consumption is a big thing.

00:18:42.580 --> 00:18:45.040
And the point underneath there
is basically that every page

00:18:45.040 --> 00:18:47.090
you make is potentially a page
that needs to be paged out.

00:18:47.100 --> 00:18:49.440
So yes,
you developers might have two gigabytes

00:18:49.500 --> 00:18:53.010
or four gigabytes in your system,
but for people, you know, your usual app,

00:18:53.010 --> 00:18:56.440
your usual mom and pop shop,
it's going to be, you know, 512K,

00:18:56.530 --> 00:18:57.560
512 meg.

00:18:57.560 --> 00:18:59.230
So, you know,
you have to be cautious about

00:18:59.230 --> 00:19:00.150
how much memory you consume.

00:19:00.160 --> 00:19:02.470
And the second two
points are more global.

00:19:02.480 --> 00:19:04.280
They're about knowing
what you're dealing with.

00:19:04.450 --> 00:19:06.530
Are you dealing with lots of images,
small images?

00:19:06.700 --> 00:19:08.380
You know, how complicated are the images?

00:19:08.460 --> 00:19:11.300
Are they all, you know,
raw camera images, stuff like that?

00:19:11.300 --> 00:19:13.520
You have to understand the type
of data that you're dealing with.

00:19:13.520 --> 00:19:17.150
And the last point is, you know,
as usual software is an

00:19:17.280 --> 00:19:19.260
evolutionary process and,
you know,

00:19:19.260 --> 00:19:22.090
you shouldn't be afraid to evaluate
something today and move on to the next,

00:19:22.090 --> 00:19:23.390
you know, because things have changed.

00:19:23.420 --> 00:19:24.800
So.

00:19:25.070 --> 00:19:30.920
First key goal, key point, key tenant,
key everything is reuse your objects.

00:19:30.960 --> 00:19:31.750
You've heard this before.

00:19:32.500 --> 00:19:36.880
Basically, your object refs are keys into
internal caches that CG uses.

00:19:37.040 --> 00:19:38.590
You just have to hold
onto them and we will,

00:19:38.590 --> 00:19:41.110
you know, end up,
if we need to draw something or color

00:19:41.110 --> 00:19:44.120
match an image or any of those things,
we'll just do all the usual stuff.

00:19:44.160 --> 00:19:47.080
And it, you know, you don't have to do
anything except hold onto it.

00:19:47.120 --> 00:19:51.120
It also has a bonus point of
if you have an example of,

00:19:51.170 --> 00:19:53.380
you know, 100 images that you're
trying to put in a PDF file,

00:19:53.380 --> 00:19:54.660
there's actually only one image.

00:19:54.660 --> 00:19:57.360
If you give us a new image ref,
we're just going to write out that image

00:19:57.360 --> 00:19:59.250
100 times as opposed to just using one.

00:19:59.260 --> 00:20:03.710
So, you know, in all those cases it,
you know, basically cuts down on overhead

00:20:04.280 --> 00:20:08.710
and doing complicated work if
you hold onto these image refs.

00:20:08.720 --> 00:20:11.820
So we can go back and look at, you know,
cached entries when you

00:20:11.840 --> 00:20:12.760
give us the image ref again.

00:20:12.760 --> 00:20:17.700
And, of course, using the tenant of,
you know, reserve your,

00:20:17.800 --> 00:20:19.440
be cautious about your
memory consumption.

00:20:19.440 --> 00:20:21.710
If you don't need something,
just let it go.

00:20:21.720 --> 00:20:23.530
We'll delete all the
entries in the cache,

00:20:23.530 --> 00:20:27.080
you know, so,
and you can reload it later on.

00:20:27.360 --> 00:20:29.520
So now let's jump into the type
of objects that you're going to

00:20:29.610 --> 00:20:32.430
be caching or potentially using
or which will give you a benefit.

00:20:32.440 --> 00:20:33.420
Path refs.

00:20:33.580 --> 00:20:34.350
Always use path refs.

00:20:34.360 --> 00:20:36.760
Path refs are much faster than
constructing your path all

00:20:36.760 --> 00:20:38.070
the time over and over again.

00:20:38.100 --> 00:20:39.670
Just hold on to the path and use it.

00:20:39.720 --> 00:20:42.680
The other thing about path refs is that
if we've already scan converted the data,

00:20:42.680 --> 00:20:44.340
we already know that we don't
have to do this work again.

00:20:44.340 --> 00:20:47.390
So you give us a path ref,
we translate to our cached entry,

00:20:47.390 --> 00:20:48.860
bing bang, you go fast.

00:20:48.860 --> 00:20:52.640
Last point about paths is that you
have to be cautious about using very,

00:20:52.640 --> 00:20:54.670
very large, complicated paths.

00:20:54.940 --> 00:20:58.170
If you have a path that consists
of many subpaths and the subpaths

00:20:58.200 --> 00:21:01.220
are geometrically disjoint,
it might be more efficient

00:21:01.220 --> 00:21:04.130
for you to render the disjoint
subpaths independently.

00:21:04.180 --> 00:21:05.650
So watch out for that.

00:21:05.660 --> 00:21:08.380
So lines and rectangles.

00:21:08.380 --> 00:21:10.000
Like paths,
but we're going to concentrate

00:21:10.020 --> 00:21:12.570
more on stroking lines and filling
rectangles because a lot of people

00:21:12.570 --> 00:21:13.660
actually fall into that class.

00:21:13.740 --> 00:21:16.360
They've got a CAD application or
they've got some wireframe thing.

00:21:16.380 --> 00:21:17.540
Use this API.

00:21:17.540 --> 00:21:18.400
It's much better.

00:21:18.400 --> 00:21:23.520
It is the fastest way to draw lines
and rectangles on the display.

00:21:24.300 --> 00:21:28.620
The second thing for those of you who do
would find this method more efficient,

00:21:28.620 --> 00:21:31.040
you also have to be concerned
about what you're dealing with.

00:21:31.180 --> 00:21:32.640
Are you dealing with massive wireframes?

00:21:32.640 --> 00:21:35.700
Are you dealing with massive scenes?

00:21:35.700 --> 00:21:38.440
Get rid of the objects
you don't need to draw.

00:21:38.440 --> 00:21:40.000
Get rid of the objects that
are not going to be seen.

00:21:40.000 --> 00:21:42.740
If you're standing at 60,000 feet,
you're not going to see a fire hydrant,

00:21:42.740 --> 00:21:43.380
so don't draw it.

00:21:43.480 --> 00:21:44.880
I mean, that's basically.

00:21:44.880 --> 00:21:47.310
Other things, too,
you might want to reorganize your

00:21:47.310 --> 00:21:50.200
data structures to maybe help you
on your way of deducing whether

00:21:50.200 --> 00:21:51.860
or not you need to draw something.

00:21:51.860 --> 00:21:53.560
Quad trees, octrees, they're all there.

00:21:53.660 --> 00:21:54.210
They're known stuff.

00:21:54.320 --> 00:21:55.300
You can look it up on the web.

00:21:55.300 --> 00:21:56.220
You can Google it.

00:21:56.240 --> 00:21:59.680
So, yeah,
there's lots of different algorithms

00:21:59.680 --> 00:22:00.700
that people have been using.

00:22:02.230 --> 00:22:05.800
The next thing is a little bit more
about trying to cut down what you draw.

00:22:05.950 --> 00:22:08.400
You really, you know, as I said before,
you really don't want to

00:22:08.400 --> 00:22:10.400
throw a whole bunch of stuff
at something thinking that,

00:22:10.400 --> 00:22:12.520
"Oh, somebody's going to do all
this clipping." If you can

00:22:12.600 --> 00:22:15.300
pre-clip ahead of time,
like for instance that text block,

00:22:15.420 --> 00:22:18.000
you know that that text block is the
only thing that needs to be updated.

00:22:18.060 --> 00:22:19.600
Then just, you know, draw the text.

00:22:19.730 --> 00:22:21.420
Why bother, you know,
draw the whole diagram

00:22:21.430 --> 00:22:22.400
with all the images?

00:22:22.510 --> 00:22:24.680
So definitely if you have things,
you can do trivial

00:22:24.680 --> 00:22:26.130
culling of your objects,
you can do trivial

00:22:26.210 --> 00:22:27.700
clipping of your objects,
all those things,

00:22:27.700 --> 00:22:31.920
just trying to minimize what
you end up giving to us to draw.

00:22:32.460 --> 00:22:35.270
The second thing that you want to also
do when it's with respect to minimize

00:22:35.270 --> 00:22:37.940
clipping is that we have lots of
clipping primitives that you actually,

00:22:37.940 --> 00:22:41.310
you can use, and you can use CG clipping
to do the clipping for you.

00:22:41.500 --> 00:22:43.870
But as I said,
the less data you give us to clip,

00:22:43.950 --> 00:22:47.670
if you know this stuff ahead of time,
you know, the better it is for everybody.

00:22:47.710 --> 00:22:50.970
So that's all cool,
but what happens if you want to do

00:22:51.010 --> 00:22:53.920
something a little bit more complicated?

00:22:53.920 --> 00:22:56.510
You can't actually specify a clip path,
right?

00:22:56.520 --> 00:22:58.320
You actually have per-pixel clipping.

00:22:58.990 --> 00:23:01.230
Well, the method of doing this,
which dodges a whole bunch

00:23:01.230 --> 00:23:03.680
of complicated clips,
even if you have complicated geometry,

00:23:03.740 --> 00:23:06.140
as well as per-pixel clips,
you can use this method.

00:23:06.140 --> 00:23:08.820
You basically create an alpha context,
and you draw what you want to draw,

00:23:08.820 --> 00:23:10.040
which is going to be your clip.

00:23:10.230 --> 00:23:11.220
That represents a stencil.

00:23:11.220 --> 00:23:13.660
You take that stencil,
and you have two choices.

00:23:13.660 --> 00:23:15.780
Either you can take an
image that you want to draw,

00:23:15.780 --> 00:23:18.520
in this case it's a wood texture,
and you can mask the image,

00:23:18.520 --> 00:23:20.650
or you can just set the
clip to be the clip,

00:23:20.650 --> 00:23:23.350
you know, set, you know,
CG context clip to mask,

00:23:23.530 --> 00:23:25.530
and that becomes,
that gets integrated with your clip.

00:23:25.670 --> 00:23:27.590
And for a silly thing like that,
where I have a mask and a

00:23:27.590 --> 00:23:30.450
texture and a little highlight,
we end up getting something

00:23:30.450 --> 00:23:31.770
that looks like that.

00:23:31.930 --> 00:23:32.850
Well, that's pretty cool for 2D.

00:23:32.860 --> 00:23:34.580
Yeah, okay, great,
the ball doesn't actually,

00:23:34.580 --> 00:23:36.460
the texture isn't actually
wrapping around the ball,

00:23:36.460 --> 00:23:37.330
but you get my point.

00:23:37.340 --> 00:23:42.390
So now, let's talk about things where,
which you can provide color.

00:23:42.430 --> 00:23:46.330
Well, CG color refs,
always use CG color refs.

00:23:46.340 --> 00:23:49.750
They're faster than actually saying,
CG context set RGB fill color, blah,

00:23:49.850 --> 00:23:50.700
blah, blah.

00:23:50.700 --> 00:23:52.700
Those color refs you can
use and reuse them again.

00:23:52.700 --> 00:23:53.460
You hold on to them.

00:23:53.460 --> 00:23:54.780
We know the color is there.

00:23:54.780 --> 00:23:56.400
We don't have to rematch, et cetera,
et cetera.

00:23:56.400 --> 00:23:58.960
One other point about it is, actually,
you should have a color ref,

00:23:58.980 --> 00:24:02.390
but you should probably attempt to
use the color that is appropriate.

00:24:02.400 --> 00:24:05.430
It's not always true that red, green,
and blue equals the actual gray.

00:24:05.440 --> 00:24:08.880
There are lots of situations
where that is actually not true.

00:24:08.900 --> 00:24:10.320
Pattern refs.

00:24:10.640 --> 00:24:13.410
Pattern refs are much faster
than tiling drawing yourself.

00:24:13.460 --> 00:24:16.580
You set up a pattern ref, and we go in,
we want to fill something

00:24:16.660 --> 00:24:18.420
with your pattern ref,
we execute one tile,

00:24:18.530 --> 00:24:20.760
and then we get that tile,
and we rasterize that tile,

00:24:20.860 --> 00:24:24.070
color match it, put it in a cache,
and whenever you reuse that,

00:24:24.070 --> 00:24:26.700
fill an object with that pattern,
we just use the cache to

00:24:26.710 --> 00:24:27.750
entry and replicate it.

00:24:27.760 --> 00:24:30.020
So it's always faster than,
just continually to draw, draw,

00:24:30.080 --> 00:24:30.970
and over and over again.

00:24:30.980 --> 00:24:31.580
Shadings.

00:24:31.580 --> 00:24:33.270
Shadings are also another thing.

00:24:33.340 --> 00:24:35.260
The star in the middle is a
shading from white to blue,

00:24:35.340 --> 00:24:38.750
or a darker blue, and if you, you know,
it would be much better for

00:24:38.760 --> 00:24:39.760
you to use shading APIs.

00:24:39.840 --> 00:24:43.360
A single call, you just draw it,
instead of actually going and trying

00:24:43.380 --> 00:24:46.720
to put those pixels one by one,
or creating some image or something.

00:24:46.780 --> 00:24:47.680
So shading refs are good.

00:24:47.830 --> 00:24:49.780
They're also a more efficient
representation in PDF and PostScript.

00:24:49.780 --> 00:24:51.780
So, you know,
that's a big win for using shadings.

00:24:51.780 --> 00:24:54.780
But more specifically,
about shadings and caching.

00:24:54.780 --> 00:24:57.780
The shading isn't really the
entry that's actually cached.

00:24:57.780 --> 00:24:58.780
It's your function.

00:24:58.780 --> 00:25:01.900
Shadings are basically a
geometric transformation of

00:25:01.900 --> 00:25:03.780
your function to your display.

00:25:03.780 --> 00:25:05.780
So, yes,
if you hold onto your shading refs,

00:25:05.780 --> 00:25:08.770
we'll keep and say, "Yes,
we've rendered this rendition before."

00:25:08.780 --> 00:25:11.780
But what's really more important for
you to hold on is your function ref.

00:25:11.780 --> 00:25:15.780
That function has to get sampled and
color matched to the correct color,

00:25:15.810 --> 00:25:16.720
and then used.

00:25:16.840 --> 00:25:19.610
If you hold onto your function refs,
and you reuse your function

00:25:19.610 --> 00:25:22.260
refs across multiple shadings,
you get a benefit because you

00:25:22.300 --> 00:25:24.780
more or less would be hitting
the cached entries all the time.

00:25:24.780 --> 00:25:26.760
The last point on here is about alpha.

00:25:26.780 --> 00:25:28.580
Yes, alpha can sometimes be consistent.

00:25:28.580 --> 00:25:30.580
It can be considered to be
free in the hardware case,

00:25:30.580 --> 00:25:33.580
but it's a little bit more
expensive in the software case.

00:25:33.580 --> 00:25:35.850
You should try to, you know,
if you have situations where

00:25:35.850 --> 00:25:37.580
you have a color and you're
trying to change the color,

00:25:37.580 --> 00:25:40.810
do a gradient or something like that,
setting the alpha is a much,

00:25:40.810 --> 00:25:41.580
much cheaper way of doing it.

00:25:41.580 --> 00:25:45.580
You got your simple black color,
you're drawing a gradation, just say,

00:25:45.580 --> 00:25:48.500
"Set alpha, set alpha, set alpha,
set alpha." And you'll get

00:25:48.530 --> 00:25:49.890
the same effect without us
having to go through and,

00:25:49.890 --> 00:25:51.580
you know,
get conniption fits about trying to match

00:25:51.580 --> 00:25:53.580
colors and do all these different things.

00:25:53.580 --> 00:25:55.580
So definitely, you know,
that's a little technique to do.

00:25:55.580 --> 00:25:57.570
Similarly, you can do it for any object.

00:25:57.580 --> 00:26:01.580
You can do it for any object, you know,
if you have a color that's alpha,

00:26:01.580 --> 00:26:03.550
you draw an image,
it'll come out 50% shaded.

00:26:03.580 --> 00:26:05.580
Okay,
so let's talk a little bit about images.

00:26:05.580 --> 00:26:07.570
This is the other source of data, right?

00:26:07.840 --> 00:26:09.490
Things you should know about images.

00:26:09.620 --> 00:26:11.580
What are good component sizes?

00:26:11.580 --> 00:26:13.580
Component sizes, well, bytes, shorts,
and floats.

00:26:13.580 --> 00:26:16.560
Ralph did mention that we added
a new 16-bit bitmap context,

00:26:16.580 --> 00:26:18.580
but what he also didn't
say that for Leopard,

00:26:18.650 --> 00:26:21.550
we've actually increased
the actual pipelines.

00:26:21.590 --> 00:26:24.910
The pipelines are now byte pipelines,
and they're also short

00:26:24.960 --> 00:26:25.580
pipelines and float pipelines.

00:26:25.580 --> 00:26:27.380
So once they go through,
they get color matched,

00:26:27.380 --> 00:26:30.380
interpolated if you have a float image,
it gets color matched, interpolated,

00:26:30.380 --> 00:26:32.270
masking,
everything happens all in floats.

00:26:32.400 --> 00:26:34.380
So the final image that
comes out on the other end,

00:26:34.400 --> 00:26:37.370
which you see in your bitmap context,
is the actual closest representation

00:26:37.460 --> 00:26:39.380
to this source that you provided.

00:26:39.520 --> 00:26:43.260
Other things that you should notice
about images is people always ask,

00:26:43.410 --> 00:26:45.600
"Well,
what's a good bytes per row value?" Well,

00:26:45.600 --> 00:26:48.240
you should probably use pixel multiples,
start there.

00:26:48.400 --> 00:26:49.380
Vector multiples are also good.

00:26:49.380 --> 00:26:51.380
Scanline alignment, that's also good,
too.

00:26:51.380 --> 00:26:53.270
So you can pad things out or not.

00:26:53.380 --> 00:26:56.370
Color spaces, if you don't know what
your color space is,

00:26:56.380 --> 00:26:58.380
you should just use generic RGB.

00:26:58.380 --> 00:27:00.380
Don't try and get funky on us.

00:27:01.940 --> 00:27:05.000
And the second thing
about just let us do that,

00:27:05.000 --> 00:27:07.450
and we'll do it for you with ease.

00:27:07.570 --> 00:27:09.450
That's all we do.

00:27:09.780 --> 00:27:14.440
Also, as I said,
avoid needless coercions of your data.

00:27:14.440 --> 00:27:17.320
Don't coerce data from
gray to CMYK or whatever.

00:27:17.370 --> 00:27:18.250
Just leave it as it is.

00:27:18.290 --> 00:27:20.430
Tell us what the color space is
and we'll do all the hard work.

00:27:20.440 --> 00:27:25.400
The last thing, point on the slide,
is about good image performance.

00:27:25.400 --> 00:27:29.240
It's always good to use the destination
color space for best image performance.

00:27:29.260 --> 00:27:31.470
We look at it, we say the source image
is this color space,

00:27:31.550 --> 00:27:33.040
destination is this color space.

00:27:33.110 --> 00:27:34.040
Oh, nothing needs to be done.

00:27:34.040 --> 00:27:36.060
We can just blast that data
straight into the destination.

00:27:36.060 --> 00:27:39.280
So, find your destination color
spaces and you'll go faster.

00:27:39.700 --> 00:27:43.360
More about images,
what you should watch out for.

00:27:43.380 --> 00:27:48.060
In Tiger, we actually introduced a new
constant for to handle little

00:27:48.060 --> 00:27:49.680
Indian data versus big Indian data.

00:27:49.680 --> 00:27:51.900
You really should use these cautiously.

00:27:51.900 --> 00:27:53.760
Use it for what makes sense.

00:27:53.760 --> 00:27:56.400
If you actually have some kind of pixel
loop running over your data and you're

00:27:56.480 --> 00:27:59.640
looking at things in terms of words,
like 32-byte quantities, then yes,

00:27:59.640 --> 00:28:00.660
turn on the flag.

00:28:00.660 --> 00:28:03.150
But if you already have big Indian data,
meaning just red followed

00:28:03.150 --> 00:28:05.150
by green followed by blue,
just leave it at that.

00:28:05.250 --> 00:28:05.930
We'll do all the work.

00:28:05.940 --> 00:28:08.140
The second thing you want to be
cautious about when you're dealing

00:28:08.140 --> 00:28:11.400
with these constants is you want
to set up your byte order constant

00:28:11.540 --> 00:28:13.130
sizes to be a multiple of row bytes.

00:28:13.140 --> 00:28:15.620
You don't want a swap unit
that crosses a scan line.

00:28:15.620 --> 00:28:17.310
That just causes us to do more work.

00:28:17.400 --> 00:28:19.340
So, if you could just pad it out and say,
"Okay, great.

00:28:19.340 --> 00:28:21.910
I've got something that's got to
be a multiple of 32 bits," then

00:28:22.030 --> 00:28:23.930
just use that constant instead.

00:28:24.710 --> 00:28:27.520
More about alpha.

00:28:27.640 --> 00:28:30.240
Basically, alpha, anytime you have alpha,
you imply blending.

00:28:30.280 --> 00:28:32.360
Blending basically cuts
your throughput in half,

00:28:32.360 --> 00:28:34.540
no matter whether it's a GPU or a CPU.

00:28:34.540 --> 00:28:37.290
You have to read the source,
read the destination, combine them,

00:28:37.290 --> 00:28:39.990
and put them back in the destination,
as opposed to just an opaque copy.

00:28:40.080 --> 00:28:42.950
So, watch out for alpha,
or use it sparingly.

00:28:42.960 --> 00:28:45.350
Don't create images that have
FFF in the alpha channel.

00:28:45.550 --> 00:28:47.910
Just say,
"Skip alpha," and we'll do the rest.

00:28:48.030 --> 00:28:49.920
Premultiply.

00:28:49.920 --> 00:28:50.690
That's also another one.

00:28:50.720 --> 00:28:52.480
Premultiply when you need to.

00:28:52.720 --> 00:28:54.690
If you need to premultiply,
do premultiply.

00:28:54.730 --> 00:28:57.720
If you don't need to look at the data,
don't bother premultiplying for us.

00:28:57.720 --> 00:28:59.620
We know how to do that.

00:28:59.880 --> 00:29:02.720
It has performance penalties when
you're dealing with color matching.

00:29:03.020 --> 00:29:05.820
Basically, we have to un-premultiply the
data in order to match it and

00:29:05.820 --> 00:29:06.720
then apply it to the blitters.

00:29:06.720 --> 00:29:06.720
So, if you have a problem
with color matching,

00:29:06.720 --> 00:29:06.720
you can do that.

00:29:06.720 --> 00:29:06.720
If you have a problem
with color matching,

00:29:06.720 --> 00:29:06.720
you can do that.

00:29:06.720 --> 00:29:08.060
If you have a problem
with color matching,

00:29:08.070 --> 00:29:08.720
you can do that.

00:29:08.720 --> 00:29:11.720
If you do it more than you need to,
it's going to be a little

00:29:11.720 --> 00:29:12.720
bit more expensive.

00:29:12.720 --> 00:29:15.940
Yes, okay, things are cached,
so you only do it once,

00:29:15.940 --> 00:29:17.570
but avoid it when possible.

00:29:17.660 --> 00:29:19.350
The last point is about
image interpolation.

00:29:19.360 --> 00:29:23.660
Image interpolation is basically
used to control what you see,

00:29:23.660 --> 00:29:25.340
how well it does its work.

00:29:25.340 --> 00:29:25.880
You want to use it.

00:29:25.960 --> 00:29:30.970
They have very different quality versus
speed performance characteristics,

00:29:30.980 --> 00:29:32.740
and you should probably choose
the one that's appropriate.

00:29:32.740 --> 00:29:37.840
High, medium, none, low, default.

00:29:37.840 --> 00:29:39.800
All of those things.

00:29:39.800 --> 00:29:39.800
You find them in the headers
and in the documentation.

00:29:39.990 --> 00:29:40.750
So, okay, great.

00:29:40.760 --> 00:29:41.940
We have images.

00:29:41.940 --> 00:29:44.980
We told you what to do about
doing things with images.

00:29:44.980 --> 00:29:48.660
Well, what happens if I'm bumping
into some scenario where I know

00:29:48.660 --> 00:29:50.680
I'm going to blow CG's cache,
or I know I'm going to have

00:29:50.850 --> 00:29:52.000
really complicated things?

00:29:52.000 --> 00:29:53.390
You might want to consider caching.

00:29:53.420 --> 00:29:56.210
Now, caching, you have to be very
cautious about caching,

00:29:56.210 --> 00:29:56.740
right?

00:29:56.740 --> 00:30:01.900
You have to make sure that you've
measured all the effects of your caching.

00:30:01.900 --> 00:30:04.630
You don't want to have a situation
where you're allocating tons

00:30:04.630 --> 00:30:07.360
and tons and tons of images,
and they're basically

00:30:07.360 --> 00:30:08.990
hanging out in memory.

00:30:09.460 --> 00:30:13.040
So, measure the performance,
measure the memory footprint,

00:30:13.040 --> 00:30:15.530
and try to be,
if you're going to go down this path,

00:30:15.620 --> 00:30:17.340
be committed to managing
your cache efficiently.

00:30:17.340 --> 00:30:20.140
Don't say, I'm caching,
and then just call it a stash,

00:30:20.140 --> 00:30:21.870
where you just create images
and keep them as memory,

00:30:21.880 --> 00:30:23.720
expecting the system to
page out your memory.

00:30:23.720 --> 00:30:25.530
Manage it effectively.

00:30:25.540 --> 00:30:27.100
Things that aren't being used,
evict them.

00:30:27.100 --> 00:30:32.530
One last point about using this
type of approach and managing

00:30:32.530 --> 00:30:35.310
your own cache is that you can use
data providers to your advantage.

00:30:35.320 --> 00:30:38.700
They somehow decouple.

00:30:39.020 --> 00:30:43.030
You can do VM tricks and stuff like that,
where when you first get the draw,

00:30:43.040 --> 00:30:44.400
you get the notification,
access the data provider,

00:30:44.400 --> 00:30:45.320
you make the memory.

00:30:45.320 --> 00:30:47.320
After the image is used,
you get a notification,

00:30:47.320 --> 00:30:49.320
and you can basically tell the VM system
to kill those pages when appropriate,

00:30:49.340 --> 00:30:51.320
make them volatile.

00:30:51.320 --> 00:30:53.320
And somebody draws it again.

00:30:53.320 --> 00:30:55.320
You go back, we see it,
you can use a VM trick and say,

00:30:55.320 --> 00:30:59.250
"Have any of these pages been
evicted?" If the answer is no,

00:30:59.310 --> 00:30:59.320
you've got the pointer.

00:30:59.510 --> 00:31:01.200
There you go.

00:31:01.200 --> 00:31:01.320
Otherwise,
you go and do your decompression.

00:31:01.320 --> 00:31:03.320
So, if you guys have any of these,
you know,

00:31:03.370 --> 00:31:05.320
want to get into any of these things,
come and talk to us in the lab.

00:31:05.360 --> 00:31:07.320
We're going to be doing
a lot of work on that.

00:31:07.320 --> 00:31:09.480
So, if you guys have any questions,
you can come to the

00:31:09.480 --> 00:31:11.490
lab after the session,
and we'll be sure to help

00:31:11.500 --> 00:31:12.580
you with these things.

00:31:12.580 --> 00:31:15.580
The next source, images,
we're moving on to layers.

00:31:15.580 --> 00:31:17.570
Layers are another source of data.

00:31:17.580 --> 00:31:21.580
And they're basically device-dependent
representations of your drawing.

00:31:21.580 --> 00:31:24.580
We really, really would like you to use
it for complicated drawing,

00:31:24.580 --> 00:31:26.580
not for simple images.

00:31:26.580 --> 00:31:29.580
Don't just create a layer and draw
an image into it and then use that.

00:31:29.580 --> 00:31:31.580
If you draw the image,
the actual correct thing will happen.

00:31:31.580 --> 00:31:34.570
We'll rasterize it,
put it in the correct form,

00:31:34.580 --> 00:31:36.580
upload it to Texture,
and you just use that,

00:31:36.590 --> 00:31:39.210
as opposed to using a layer,
because we have this memory,

00:31:39.210 --> 00:31:40.140
and it's a hard allocation.

00:31:40.140 --> 00:31:42.140
You tell us to allocate the stuff.

00:31:42.140 --> 00:31:44.140
We have to keep it around.

00:31:44.140 --> 00:31:46.140
So, definitely use it for
complicated drawings.

00:31:46.140 --> 00:31:48.820
Also, layer rests are kind of
convenient because it hides

00:31:48.820 --> 00:31:50.140
all the destination details,
right?

00:31:50.140 --> 00:31:52.550
If you're looking at a bitmap context
that's floating point or a window

00:31:52.550 --> 00:31:56.030
context that's a floating point window,
right, and you draw into it,

00:31:56.150 --> 00:31:59.250
you ask the context for a layer,
you'll get back a layer that

00:31:59.250 --> 00:32:00.140
appropriately matches that device.

00:32:00.140 --> 00:32:02.140
Instead of you having to dick
around with trying to find out,

00:32:02.170 --> 00:32:03.120
"Oh, is it a float component?

00:32:03.170 --> 00:32:06.070
Is it reverse-Indian?"
What's the problem?

00:32:06.180 --> 00:32:08.580
So,
just definitely use layer rests whenever

00:32:08.580 --> 00:32:11.700
you have things like that to do.

00:32:11.700 --> 00:32:15.210
The other last point about layers
I wanted to mention was that I've

00:32:15.210 --> 00:32:18.700
bumped into a bunch of different
scenarios where developers are actually

00:32:18.700 --> 00:32:20.700
creating layers that are really large.

00:32:20.700 --> 00:32:21.680
They have this scene.

00:32:21.790 --> 00:32:27.020
They're zooming in to, like, what,
10,000%, and automatically the spinning

00:32:27.100 --> 00:32:31.700
beach ball of death comes up because
basically you've told us to allocate,

00:32:31.700 --> 00:32:33.700
you know, two gigabytes of memory.

00:32:33.700 --> 00:32:37.260
So, be cautious about what
you're actually doing.

00:32:37.360 --> 00:32:40.250
In terms of when you use layers
and what you're allocating.

00:32:40.260 --> 00:32:42.230
So, try to be cautious.

00:32:42.370 --> 00:32:43.160
Memory consumption.

00:32:43.350 --> 00:32:46.010
Always keep in your mind.

00:32:46.210 --> 00:32:49.990
So the last point about
layers is that we've,

00:32:50.080 --> 00:32:54.500
for Leopard, snapshot a sheet of acetate
where you can just pop a layer,

00:32:54.500 --> 00:32:56.810
you draw it,
and then you can get the entire thing,

00:32:56.810 --> 00:33:00.150
like let's say you call end,
and you can fade everything at 50% or

00:33:00.150 --> 00:33:02.190
you can add a shadow style or whatever.

00:33:02.280 --> 00:33:04.480
If you have situations like
that where you're actually

00:33:04.480 --> 00:33:08.220
just drawing transient data,
you have one of two choices.

00:33:08.220 --> 00:33:10.930
You create an off-screen layer,
you draw into it, and then you draw your

00:33:10.930 --> 00:33:13.880
layer with your effect,
or you just say begin transparency layer,

00:33:13.880 --> 00:33:16.320
draw your content,
and then end transparency layer,

00:33:16.330 --> 00:33:18.430
then it gets composited as a destination.

00:33:18.440 --> 00:33:21.610
So you want to try and look at those
APIs and use those APIs when that's

00:33:21.610 --> 00:33:23.280
the type of scenario you're in.

00:33:23.300 --> 00:33:25.580
One last point,
set your clip path before you

00:33:25.580 --> 00:33:27.350
begin your transparency layer.

00:33:27.360 --> 00:33:28.880
If you don't tell us what
you're going to draw,

00:33:28.880 --> 00:33:31.070
we're just going to create a
layer the size of the destination.

00:33:31.080 --> 00:33:32.250
So setting your clip path before
you begin your transparency layer.

00:33:32.280 --> 00:33:35.890
the path restricts basically
how much data we actually make.

00:33:38.290 --> 00:33:41.350
Okay, so now we've sort of looked at
all the different objects that

00:33:41.360 --> 00:33:44.410
will help you go fast both in
the 2D and in the 3D environment,

00:33:44.410 --> 00:33:46.340
or 2D and QuartzGL environment.

00:33:46.340 --> 00:33:52.090
Now we're going to take a look at some
other meta-level type optimizations.

00:33:52.100 --> 00:33:56.610
Drawing on pixel boundaries, you know,
sometimes they can give you good results.

00:33:56.620 --> 00:33:59.300
You draw a rectangle,
you don't want the rectangle

00:33:59.300 --> 00:34:02.700
to be on a fuzzy edge,
you want it to be a solid edge, you know,

00:34:02.700 --> 00:34:03.910
a nice clean line.

00:34:04.700 --> 00:34:08.340
You basically take your,
get the context's user space

00:34:08.430 --> 00:34:11.680
to device space transform,
you get your array of points

00:34:11.730 --> 00:34:13.060
or whatever rectangles.

00:34:13.060 --> 00:34:16.960
You transform them to your device space,
and then you do whatever you want to do,

00:34:16.960 --> 00:34:19.660
round them, seal them,
whatever you're fancy.

00:34:19.660 --> 00:34:22.680
And then you inverse transform
them back to user space.

00:34:22.680 --> 00:34:25.850
And those will be the coordinates
that if you use those coordinates,

00:34:25.850 --> 00:34:28.400
they will actually end up
hitting the pixel cracks.

00:34:28.400 --> 00:34:30.200
So that's how you get
to find these things.

00:34:30.220 --> 00:34:32.870
Another thing that makes things
slightly more complicated is that,

00:34:32.870 --> 00:34:36.160
you know, people normally think, one,
one user space point is equal

00:34:36.190 --> 00:34:37.740
to one device space point.

00:34:37.740 --> 00:34:40.670
With high DPI,
that's a very different scenario.

00:34:40.680 --> 00:34:43.820
So as high DPI comes online,
you may want to do these things so

00:34:43.840 --> 00:34:46.950
that you can get your things to snap
on grids close to each other without,

00:34:47.030 --> 00:34:51.980
you know, having us do these partial
pixel coverage calculations.

00:34:52.910 --> 00:34:55.430
So the second thing,
which is the last thing

00:34:55.750 --> 00:34:58.310
about having demands,
library size.

00:34:58.400 --> 00:35:01.390
Library size is probably the most taxing
thing your application can probably

00:35:01.420 --> 00:35:02.970
do when it comes to user interfaces.

00:35:03.000 --> 00:35:06.630
There's several scenarios where
you can try to give a user a better

00:35:06.750 --> 00:35:10.870
experience during library size,
and one of the points is basically

00:35:10.880 --> 00:35:12.860
consider periodic updates.

00:35:12.860 --> 00:35:15.640
Periodic updates,
an example of that would be mail.

00:35:15.640 --> 00:35:18.160
When you resize the mail,
the mail window,

00:35:18.160 --> 00:35:20.680
what happens is they take a
snapshot of what's on the screen,

00:35:20.680 --> 00:35:24.540
and they fill in all the exposed area,
and then when the user drops the mouse,

00:35:24.670 --> 00:35:27.010
then they actually do the full layout,
right?

00:35:27.020 --> 00:35:27.840
Text layout.

00:35:27.840 --> 00:35:31.190
If you have a large document and
you're resizing the document,

00:35:31.190 --> 00:35:32.820
yes, layout is expensive.

00:35:32.860 --> 00:35:36.290
You might want to either cache
your layout or just hold on to

00:35:36.340 --> 00:35:40.200
the current layout and wait until
the user releases the mouse.

00:35:40.200 --> 00:35:41.650
An example of that would be text edit.

00:35:41.650 --> 00:35:44.700
Really large documents in text edit,
instead of relaying out the

00:35:44.740 --> 00:35:48.240
document at the new page size,
it basically takes a snapshot

00:35:48.380 --> 00:35:50.380
or keeps the same layout.

00:35:50.730 --> 00:35:53.340
Resize as you wish,
and then when you drop the mouse,

00:35:53.370 --> 00:35:54.980
it does the full layout at the end.

00:35:56.640 --> 00:35:59.610
Another example would be to
draw lower quality results.

00:35:59.610 --> 00:36:03.400
Lower quality results
in some applications,

00:36:03.400 --> 00:36:08.020
for instance, text edit and mail,
you don't want your text to look fuzzy.

00:36:08.020 --> 00:36:11.470
But with preview,
preview is an example of using

00:36:11.470 --> 00:36:14.380
lower quality results during resize.

00:36:14.410 --> 00:36:17.690
When you live resize a preview window,
what actually happens is that

00:36:17.690 --> 00:36:20.280
the image itself is being drawn
with a low quality result.

00:36:20.280 --> 00:36:23.840
So we're just sort of giving the user,
oh, this is what it's going to look like

00:36:23.840 --> 00:36:27.230
without actually doing the correct
color matching and calculation.

00:36:27.250 --> 00:36:30.320
Well, not color matching,
but all of the extra work involved in

00:36:30.320 --> 00:36:32.480
down sampling it to the exact right size.

00:36:32.520 --> 00:36:34.760
When you release the mouse,
you see a clean version of

00:36:34.770 --> 00:36:36.240
the image at that resolution.

00:36:36.240 --> 00:36:39.590
Last point on here is even though
you do all these optimizations,

00:36:39.590 --> 00:36:43.170
one killer is always blocking your
UI because you're touching the disk

00:36:43.180 --> 00:36:45.330
or running off and doing something.

00:36:45.340 --> 00:36:47.730
During a live resize session,
you probably don't want to

00:36:47.780 --> 00:36:50.260
do those expensive things
like updating preferences.

00:36:50.280 --> 00:36:52.500
You know,
and touching the disk and getting

00:36:52.500 --> 00:36:54.260
network I/O and stuff like that.

00:36:54.330 --> 00:36:58.010
So you defer that until the user
releases the mouse and says,

00:36:58.010 --> 00:37:00.280
yes, this is what I want you to do.

00:37:00.390 --> 00:37:05.060
So I'll say, how fast can I give the user
the feedback that they want from

00:37:05.150 --> 00:37:08.220
the live resize without actually
doing really expensive work?

00:37:08.280 --> 00:37:12.650
So that's what this is really about.

00:37:14.000 --> 00:37:18.040
That was sort of like the
conclusion of the optimizations.

00:37:18.040 --> 00:37:21.080
And now, probably thinking, well, geez,
how do I turn this thing on?

00:37:21.080 --> 00:37:25.240
You can use course debug to turn it on,
or you can actually turn

00:37:25.240 --> 00:37:27.750
it on on your application,
right?

00:37:27.760 --> 00:37:31.750
One of the methods is to basically
put an entry into your info P list,

00:37:31.960 --> 00:37:33.720
which says enable or disable.

00:37:33.720 --> 00:37:37.010
You want to be explicitly sure
that that's what you want to do.

00:37:37.010 --> 00:37:40.100
You want to either disable it,
or you want to enable it.

00:37:40.100 --> 00:37:42.830
If you don't know what you want to do,
just leave it alone.

00:37:42.840 --> 00:37:43.620
Don't put the entry.

00:37:44.000 --> 00:37:48.030
The other method of getting
hardware acceleration is to use the

00:37:48.030 --> 00:37:50.580
context set allows acceleration.

00:37:50.580 --> 00:37:54.480
You can use it on a per context level,
but you have to be sort of cautious

00:37:54.510 --> 00:37:58.020
about using multiple contexts,
because you can have one context

00:37:58.020 --> 00:38:00.750
trying to draw something with
acceleration set to false,

00:38:00.790 --> 00:38:03.730
and another context set
with acceleration to true.

00:38:03.740 --> 00:38:07.490
What actually happens is that when
the acceleration false guy draws,

00:38:07.590 --> 00:38:10.260
we basically say, oh,
somebody wants software

00:38:10.260 --> 00:38:11.540
access to the bits.

00:38:11.540 --> 00:38:13.440
We pull the data off of the GPU.

00:38:14.000 --> 00:38:18.040
We pull the data back to the CPU,
and the application continues to draw.

00:38:18.250 --> 00:38:22.480
At that point,
the window remains in that mode

00:38:22.690 --> 00:38:24.700
until you do the next flush.

00:38:24.800 --> 00:38:27.580
When you do the flush,
the data gets pulled back on the GPU,

00:38:27.650 --> 00:38:28.500
and we use it.

00:38:28.570 --> 00:38:30.550
So basically, that's why we took out
that quick draw thing,

00:38:30.590 --> 00:38:34.000
because the moment you use quick draw,
you basically decelerate your window,

00:38:34.000 --> 00:38:37.190
right?

00:38:37.350 --> 00:38:37.950
Great.

00:38:37.990 --> 00:38:42.600
So what I want you guys to do when you
go home or when you leave the session

00:38:42.600 --> 00:38:48.060
is try and look at where the situations
are where you're not using the Quartz

00:38:48.110 --> 00:38:51.300
API efficiently or optimally and see
if you can make improvements to try and

00:38:51.300 --> 00:38:52.910
change it such that that's what happens.

00:38:52.960 --> 00:38:55.890
You can use Quartz Debug to turn
it on or you can turn it on in your

00:38:55.890 --> 00:38:57.980
application if you've done this stuff.

00:38:58.040 --> 00:39:01.270
But basically the bottom line
is if you see an advantage,

00:39:01.270 --> 00:39:03.580
yes, great, my application flies.

00:39:03.580 --> 00:39:07.280
I get 30% more, 50% more live results.

00:39:07.300 --> 00:39:08.820
I get 30% more live results.

00:39:08.840 --> 00:39:11.710
If you see a scenario where
things aren't quite working out,

00:39:11.710 --> 00:39:14.020
go in, dive into the details and say, oh,
yeah,

00:39:14.020 --> 00:39:15.810
I forgot to hold on to my image refs.

00:39:15.840 --> 00:39:17.330
I'm always uploading, stuff like that.

00:39:17.490 --> 00:39:20.850
Go in, optimize your code, retest it,
try and find out whether

00:39:20.850 --> 00:39:22.400
or not you can turn it on.

00:39:22.400 --> 00:39:26.320
If you're in a lose situation,
just disable it and the software

00:39:26.360 --> 00:39:28.180
guy would be just as good.

00:39:30.690 --> 00:39:32.230
So,
and the last point basically is if you

00:39:32.260 --> 00:39:34.950
don't see an advantage or a disadvantage,
just leave it alone.

00:39:34.960 --> 00:39:35.890
Don't put an entry in it.

00:39:36.020 --> 00:39:38.170
You know,
we might do something about that.

00:39:39.840 --> 00:39:45.280
And also, don't forget to test on
various VRAM configurations.

00:39:45.280 --> 00:39:49.870
Just because you have a machine that's
got two gig in it with 512 megabytes

00:39:49.900 --> 00:39:53.720
of video RAM doesn't mean it's going to
run the same on something like a laptop.

00:39:53.720 --> 00:39:56.480
So be cautious about the type
of considerations that you're

00:39:56.480 --> 00:39:59.350
going to do when you say,
yes, I want to enable it.

00:39:59.490 --> 00:40:04.140
So what I'm going to
do now is bring Ken up.

00:40:04.250 --> 00:40:13.920
and Ken will talk about Quartz
compositing and co-release updates.

00:40:20.740 --> 00:40:21.060
Yes, sure.

00:40:21.060 --> 00:40:21.620
There we go.

00:40:21.670 --> 00:40:22.000
Okay.

00:40:22.000 --> 00:40:23.700
So as it says, I'm the guy to blame.

00:40:23.700 --> 00:40:25.820
This was my idea and partly Andrew's.

00:40:25.820 --> 00:40:28.840
So if this is causing you problems,
you can scream at me afterwards.

00:40:28.840 --> 00:40:31.260
I'm not going to spend
a lot of time on it.

00:40:31.420 --> 00:40:34.140
Andrew went over it in
gory detail last year.

00:40:34.140 --> 00:40:37.320
But I want to make a couple of points.

00:40:37.320 --> 00:40:41.640
Basic idea here is that the
Windows server for various performance,

00:40:41.640 --> 00:40:44.770
power, pick a reason,
wants to limit the number of

00:40:44.850 --> 00:40:46.960
updates that hit the display.

00:40:46.960 --> 00:40:48.600
The user,
if you're on like a regular flat

00:40:48.600 --> 00:40:50.370
panel and it's only 60 hertz,
that's how you're going

00:40:50.390 --> 00:40:50.680
to get a lot of updates.

00:40:50.700 --> 00:40:52.490
That's how fast the user can see stuff.

00:40:52.540 --> 00:40:54.810
So if you've got some app
that's trying to pond away

00:40:55.000 --> 00:40:57.350
and flush 400 times a second,
that's bad.

00:40:57.350 --> 00:40:58.440
The user can't see it.

00:40:58.490 --> 00:41:01.350
You're wasting resources,
wasting GPU power or CPU power,

00:41:01.350 --> 00:41:03.340
wasting battery life, whatever.

00:41:03.340 --> 00:41:07.370
So basically the Windows server will
try and coalesce as many updates

00:41:07.390 --> 00:41:11.340
that happen in a single VBL period
down to just one single update.

00:41:11.360 --> 00:41:14.590
So if you've got video playing
on one window and the little

00:41:14.590 --> 00:41:18.440
spotlight icon is in the upper
right-hand corner flickering away,

00:41:18.440 --> 00:41:20.680
those basically hit the screen together.

00:41:20.700 --> 00:41:24.310
at the same time.

00:41:24.700 --> 00:43:20.600
[Transcript missing]

00:43:22.610 --> 00:43:23.290
Some stuff here.

00:43:23.540 --> 00:43:31.120
So, these tools over here were
put in last year so that you

00:43:31.190 --> 00:43:34.350
can basically see how your app
reacts under different scenarios.

00:43:34.350 --> 00:43:36.620
So one of the things I'm going
to do is actually run Xbench.

00:43:36.630 --> 00:43:38.620
So you run it in a normal scenario.

00:43:38.690 --> 00:43:41.170
I'll just start and let
it fly through here.

00:43:41.170 --> 00:43:43.040
This will take just a minute.

00:43:43.040 --> 00:43:45.020
It looks like it's running pretty fast.

00:43:45.020 --> 00:43:46.260
You know, no problems.

00:43:46.260 --> 00:43:47.380
It's flying along.

00:43:47.380 --> 00:43:50.340
I wish I could do just
lines or something.

00:43:50.340 --> 00:43:52.020
By the way,
is the Xbench developer guy here?

00:43:52.600 --> 00:43:55.870
Drag, okay.

00:43:58.200 --> 00:43:59.460
So then we'll have the numbers here.

00:43:59.460 --> 00:44:01.170
So, come on, one more test.

00:44:01.350 --> 00:44:02.750
Okay, so not bad.

00:44:02.750 --> 00:44:04.600
This is a 17-inch MacBook Pro.

00:44:04.600 --> 00:44:05.380
Okay, numbers.

00:44:05.380 --> 00:44:08.230
So, but what happens if
we turn off Beam Sync?

00:44:08.230 --> 00:44:10.530
What kind of numbers do we get?

00:44:10.540 --> 00:44:12.910
So I'll run this one more time.

00:44:13.990 --> 00:44:16.730
And you can see now that there's
tearing going on up there.

00:44:16.740 --> 00:44:18.580
I should be able to anyway.

00:44:18.580 --> 00:44:23.210
And you can see that the numbers are
already popping out about twice as fast.

00:44:23.220 --> 00:44:24.810
So you're like, well, wait a minute.

00:44:24.830 --> 00:44:25.950
Like, what am I doing wrong?

00:44:25.960 --> 00:44:28.100
And I know there was a
change made to XBench.

00:44:28.100 --> 00:44:29.450
It was in one of the
release notes that said,

00:44:29.490 --> 00:44:31.440
well, you know,
stick in a timer to basically deal

00:44:31.550 --> 00:44:33.030
with this coalesced updates thing.

00:44:33.040 --> 00:44:35.430
One of the things now
you can do is if you,

00:44:35.430 --> 00:44:39.800
in Quartz debug,
if you force beam synchronization

00:44:39.800 --> 00:44:42.630
on and request the good old,
you know,

00:44:42.640 --> 00:44:44.980
see all the screen update flashing stuff,

00:44:48.830 --> 00:44:52.080
Quit this, there's a bug I'm working
around here real quick.

00:44:52.080 --> 00:44:57.150
Now, if you set up Quartz Debug
in this particular mode,

00:44:57.380 --> 00:45:01.400
we'll flash the screen blue any time
the app basically tried to get a lock on

00:45:01.400 --> 00:45:04.680
the backing store and couldn't because
coalesced updates were in the way.

00:45:04.700 --> 00:45:08.340
We kind of do this little trick behind
the scenes and let you continue anyway.

00:45:08.460 --> 00:45:10.780
But then that flush that
goes out will flash blue.

00:45:10.830 --> 00:45:14.270
So that's a good way to tell you,
by the way, you're basically hitting

00:45:14.270 --> 00:45:16.210
the Windows server limit.

00:45:16.230 --> 00:45:18.460
You guys should be able to see all
the blue that's happening up there,

00:45:18.520 --> 00:45:21.520
saying, hey, wait a minute,
you're trying to flush and coalesced

00:45:21.520 --> 00:45:22.720
updates are slowing you down.

00:45:22.890 --> 00:45:26.310
So this is something that
was added for Leopard.

00:45:26.320 --> 00:45:28.980
You can try it out,
give us some feedback on it

00:45:29.070 --> 00:45:30.840
and see if you like it or not.

00:45:30.860 --> 00:45:35.420
The other interesting thing I'll
point out is there's been some

00:45:35.660 --> 00:45:38.340
hubbub on the net on why are all
the Intel machines running so slow

00:45:38.340 --> 00:45:40.130
when we do the UI test in XBench?

00:45:40.230 --> 00:45:42.780
Well, it's hitting deferred updates.

00:45:42.780 --> 00:45:46.740
If you leave it in the normal mode
because it got opted in and you run it,

00:45:46.740 --> 00:45:48.220
it's just kind of do, do, do.

00:45:48.250 --> 00:45:50.390
Not the--

00:45:50.500 --> 00:46:07.500
[Transcript missing]

00:46:16.850 --> 00:46:22.910
You can-- so I guess that the
summary from Ken's part is really,

00:46:22.910 --> 00:46:30.880
if you're writing a benchmark
that measures drawing throughput,

00:46:30.880 --> 00:46:31.960
make sure you don't
have a weight in there.

00:46:31.960 --> 00:46:31.960
But waiting for VBL is kind of in play,
an implicit weight.

00:46:32.610 --> 00:46:36.030
Okay, so let me talk about a
few remaining topics.

00:46:36.030 --> 00:46:37.260
Power.

00:46:37.260 --> 00:46:42.550
So when you think about optimization,
power consumption is usually not the

00:46:42.550 --> 00:46:46.360
first thing that comes to your mind,
but I would like to just point it

00:46:46.360 --> 00:46:48.540
out and make sure you remember.

00:46:48.540 --> 00:46:50.000
So why you should care?

00:46:50.190 --> 00:46:54.020
Well, the majority of Macs sold,
actually for the last few years,

00:46:54.020 --> 00:46:56.620
are notebooks,
and most people in this room

00:46:56.620 --> 00:46:59.690
have a portable computer,
and to all those people,

00:46:59.730 --> 00:47:01.380
battery life matters.

00:47:02.390 --> 00:47:04.670
Now, the good news is,
general performance optimization

00:47:04.680 --> 00:47:06.090
is good for battery life,
too.

00:47:06.110 --> 00:47:08.450
If you finish quicker, well,
you use less power.

00:47:12.010 --> 00:47:15.680
So I would, however,
also like to point out that

00:47:15.740 --> 00:47:19.260
QuartzGL actually has an advantage
in terms of power consumption.

00:47:19.260 --> 00:47:21.760
So the numbers I'm
having here is scrolling.

00:47:21.760 --> 00:47:26.320
In Safari,
I used the Slashdot website on a MacBook,

00:47:26.320 --> 00:47:29.130
and I used the power meter,
essentially took the battery out

00:47:29.250 --> 00:47:32.780
and used the power meter at the core
to measure how much power it pulls.

00:47:32.780 --> 00:47:37.540
And the MacBook, when it's idle,
it pulls 16 watts.

00:47:38.890 --> 00:47:43.550
And then, during the scrolling test,
without QuartzGL, it runs at 22 watts,

00:47:43.550 --> 00:47:45.820
and with QuartzGL, it's 20 watts.

00:47:45.820 --> 00:47:49.510
Now, 2 watts there,
that's about 10%, and you might think,

00:47:49.580 --> 00:47:54.320
"Well, 10% isn't that impressive." Well,
10% on that MacBook is 25

00:47:54.370 --> 00:47:56.060
minutes of battery life.

00:47:56.060 --> 00:47:58.280
And so, this stuff matters.

00:47:58.280 --> 00:48:00.410
And...

00:48:01.830 --> 00:48:04.160
So if you have a
long-running application,

00:48:04.160 --> 00:48:07.840
you might want to consider opting
into QuartzGL just for that reason.

00:48:07.850 --> 00:48:11.340
Long-running application, I mean,
is something that draws a lot,

00:48:11.430 --> 00:48:13.760
and typically it's something
that's in the background.

00:48:13.760 --> 00:48:16.800
One example is you have a little
clock that you put on your desktop.

00:48:18.230 --> 00:48:21.300
So the point is,
if you're building a clock,

00:48:21.440 --> 00:48:24.940
you probably don't run
into responsiveness issues.

00:48:24.940 --> 00:48:29.480
You know, however complex your clock is,
you probably are able to re-draw

00:48:29.480 --> 00:48:33.480
the entire clock in a second that
you need to update secondhand.

00:48:33.480 --> 00:48:37.620
However, if that clock needs 5% of
the CPU or 1% of the CPU,

00:48:37.870 --> 00:48:40.880
it will make a difference
for laptop users.

00:48:40.880 --> 00:48:42.590
So please keep that in mind.

00:48:45.390 --> 00:48:48.810
The next topic I would like
to mention is color matching.

00:48:48.820 --> 00:48:55.310
So a lot of images today get drawn to
the screen not tagged with a color space.

00:48:55.320 --> 00:48:57.980
And what Core Graphics is doing,
it just says, well, if it's not tagged,

00:48:57.980 --> 00:48:59.130
it's probably the display.

00:48:59.140 --> 00:49:02.990
And you kind of get away with that
because most of the displays that

00:49:02.990 --> 00:49:05.050
Apple sells are very consistent.

00:49:05.130 --> 00:49:07.310
They all have very close
color characteristics.

00:49:07.320 --> 00:49:09.680
But that is kind of changing.

00:49:10.140 --> 00:49:13.460
So people today are
attaching a Mac Mini to a TV,

00:49:13.460 --> 00:49:16.420
or you have third parties that
sell you wide gamut displays.

00:49:16.420 --> 00:49:19.510
And if you draw untagged
images to these displays,

00:49:19.610 --> 00:49:21.530
well, funny things happen.

00:49:21.540 --> 00:49:23.900
Like if wide gamut displays,
all your colors are neon.

00:49:23.900 --> 00:49:28.240
So make sure that when you draw images,
they're actually tagged with

00:49:28.240 --> 00:49:30.360
some reasonable color space.

00:49:30.360 --> 00:49:33.170
And as Andrew said,
if you can't really figure anything out,

00:49:33.250 --> 00:49:36.480
generic RGB is a good choice because
at least it's consistent and it's

00:49:36.500 --> 00:49:37.860
close to what your Mac display is.

00:49:37.860 --> 00:49:39.970
And there's actually a new mode.

00:49:40.160 --> 00:49:42.530
It's called the Quartz
debug that you can turn on.

00:49:42.540 --> 00:49:45.470
And it will essentially mark
every image that gets drawn

00:49:45.470 --> 00:49:46.960
that is not tagged in red.

00:49:47.050 --> 00:49:50.090
So you can easily find out where in
your application you're doing that.

00:49:51.440 --> 00:49:53.490
And yeah, if you're doing that,
you will find out quite a bit

00:49:53.600 --> 00:49:56.490
of the Aqua UI is not tagged,
so that's going to

00:49:56.490 --> 00:49:59.010
change by the ship time.

00:49:59.790 --> 00:50:00.820
Okay, other changes.

00:50:00.860 --> 00:50:06.210
So 256 colors and thousands of colors
modes for desktop use is going away.

00:50:06.210 --> 00:50:10.100
So in Leopard, millions of colors only.

00:50:10.100 --> 00:50:12.590
And for most of you,
that probably doesn't make

00:50:12.590 --> 00:50:15.920
any difference because you
don't have dependencies there.

00:50:15.920 --> 00:50:18.310
In fact,
it might reduce your testing burden

00:50:18.380 --> 00:50:23.070
because you no longer have to test your
app in thousands and 256 colors of mode.

00:50:23.880 --> 00:50:27.360
Those modes are still available if
you're actually using the display

00:50:27.360 --> 00:50:29.980
APIs to change mode in full screen mode.

00:50:31.950 --> 00:50:36.540
If you so desire and your game would like
to go full screen and run in 256 colors,

00:50:36.540 --> 00:50:38.420
you can still do that,
even though I don't really

00:50:38.420 --> 00:50:39.670
understand why you want to do that.

00:50:39.800 --> 00:50:44.650
But for the desktop,
these modes are disabled.

00:50:44.660 --> 00:50:49.880
And last, and probably least, quick draw.

00:50:52.400 --> 00:50:55.710
So the message here, the API has been
deprecated for three years.

00:50:55.710 --> 00:50:58.860
There is no 64-bit version of Quick Draw.

00:50:58.860 --> 00:51:02.040
So if you want to compile
your application to 64-bit,

00:51:02.040 --> 00:51:04.140
you will have to get off Quick Draw.

00:51:04.140 --> 00:51:06.730
It's also not compatible with QuartzGL.

00:51:06.730 --> 00:51:10.400
So as soon as a Quick Draw window
that is QuartzGL accelerated

00:51:10.400 --> 00:51:14.370
gets drawn to with Quick Draw,
we have to pull that off the graphics

00:51:14.380 --> 00:51:18.440
card because Quick Draw cannot send
its commands to the graphics card.

00:51:19.470 --> 00:51:21.640
So this includes QuickTime clients.

00:51:21.640 --> 00:51:25.020
QuickTime has a lot of old
APIs which use G-Worlds.

00:51:25.090 --> 00:51:29.180
So you should use off those
and use QtKit instead.

00:51:29.180 --> 00:51:32.930
You can visit session 220,
High Performance QuickTime Video Process

00:51:33.020 --> 00:51:34.390
ing,
where they tell you a lot

00:51:34.390 --> 00:51:35.740
about how to use QtKit.

00:51:38.450 --> 00:51:41.380
Okay, with that I would like to
point out where to go next.

00:51:41.410 --> 00:51:44.560
So there's the Graphics
and Imaging Evening Lab,

00:51:44.560 --> 00:51:46.800
which starts at 6 today
to 10 in the evening.

00:51:46.800 --> 00:51:50.140
And tomorrow there's the
Core Image Lab if you're interested in

00:51:50.140 --> 00:51:52.840
how Core Image fits into Core Graphics.

00:51:54.650 --> 00:51:57.390
And with that,
these are the contact information for

00:51:57.390 --> 00:52:01.220
our 2D and 3D graphics evangelist,
Alan Schaffer, who will be...
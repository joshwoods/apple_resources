WEBVTT

00:00:10.300 --> 00:00:12.030
Hi, everybody.

00:00:12.050 --> 00:00:16.470
I'm here today to talk about a technology
preview of application signing.

00:00:16.520 --> 00:00:20.880
It's a new feature for Leopard
that we've never had before.

00:00:25.610 --> 00:00:28.260
So, wide cone signing.

00:00:28.260 --> 00:00:31.440
We're actually beginning to get
a growing number of requests,

00:00:31.470 --> 00:00:36.500
both internally and externally,
to identify client processes.

00:00:36.500 --> 00:00:41.610
Not just by what user they're running as,
but actually what application

00:00:41.660 --> 00:00:43.400
it is that's actually running.

00:00:43.500 --> 00:00:48.800
Also, we're getting requests to be able
to validate application integrity.

00:00:48.800 --> 00:00:51.500
Has this application been messed with?

00:00:51.500 --> 00:00:52.840
Has it been changed?

00:00:53.130 --> 00:00:59.800
Has somehow something within its bundle
or within its code actually been altered?

00:01:01.180 --> 00:01:04.620
The requests have come
both from outside parties,

00:01:04.620 --> 00:01:09.720
vendors, and also from internal parties
that have a need to know who

00:01:09.720 --> 00:01:13.640
the client is that's asking them
for a particular piece of data.

00:01:13.780 --> 00:01:16.300
Also,
customers are becoming very interested

00:01:16.340 --> 00:01:21.510
in this as they want to tell whether or
not their systems still have maintained

00:01:21.510 --> 00:01:24.200
integrity and are still secure.

00:01:27.250 --> 00:01:30.580
So there's a little bit of
history of actually identifying

00:01:30.830 --> 00:01:32.410
apps with the system.

00:01:32.530 --> 00:01:37.440
Keychains have always tried to
actually identify their client apps.

00:01:37.690 --> 00:01:42.130
Anybody that's ever updated a
system and ended up with dialogue

00:01:42.130 --> 00:01:47.800
saying mail.app is trying to access
this particular keychain item.

00:01:48.050 --> 00:01:50.500
perhaps it's been updated,
do you approve?

00:01:50.520 --> 00:01:55.060
Has actually seen the keychain
subsystem trying to re-identify

00:01:55.120 --> 00:01:58.670
an application that it knew once.

00:01:59.280 --> 00:02:03.520
The problem was that back in that scheme,
we were always running live

00:02:03.520 --> 00:02:07.200
hashes on applications as they
were delivered on the system.

00:02:07.310 --> 00:02:13.030
And then we were involving users in
trying to make the relationship of,

00:02:13.030 --> 00:02:17.210
"Hey, this is actually an application
that Apple gave to me.

00:02:17.210 --> 00:02:19.610
Yeah, I really want to trust it."

00:02:19.830 --> 00:02:24.230
MCX for a long time,
Managed Desktop and Parental Controls,

00:02:24.230 --> 00:02:26.910
tried using the CFBundle name
for a while to say,

00:02:27.040 --> 00:02:33.050
"Do you want to allow your children
or kids in a lab or people within

00:02:33.060 --> 00:02:37.710
an organization to run particular
applications?" That was actually ended up

00:02:37.710 --> 00:02:41.260
getting thwarted by eight-year-olds that
were smart enough to understand they just

00:02:41.260 --> 00:02:45.670
needed to change CFBundle names of their
WOW application or something like that,

00:02:45.710 --> 00:02:48.690
and they could actually run it anyways.

00:02:49.600 --> 00:02:52.340
Some people have tried using paths.

00:02:52.350 --> 00:02:55.930
Everybody's trying to do various things,
and really what we decided to

00:02:55.930 --> 00:03:00.210
do was try to solve this problem
in a more generic fashion.

00:03:01.700 --> 00:03:08.540
So PKI use, or X.509 certificates,
have quite a history here at Apple,

00:03:08.540 --> 00:03:13.980
or a history over the Mac OS X timeframe,
of being an actual system

00:03:13.980 --> 00:03:17.100
provided piece of functionality.

00:03:17.240 --> 00:03:20.970
In Jaguar,
the keychain subsystem included basic

00:03:20.970 --> 00:03:26.390
PKI and SSL functionality through
our secure transport libraries.

00:03:26.600 --> 00:03:29.030
That was actually used
later in our first client,

00:03:29.030 --> 00:03:33.500
which was Safari,
to actually provide its SSL capabilities.

00:03:33.600 --> 00:03:38.740
In Panther, we enhanced things by
including S/MIME capabilities.

00:03:38.820 --> 00:03:40.140
We were fairly rudimentary.

00:03:40.140 --> 00:03:45.000
They basically only allow access
of S/MIME to one identity for

00:03:45.000 --> 00:03:46.660
a particular mail account.

00:03:46.740 --> 00:03:50.830
But basically, it all just plain worked,
and it worked within the framework

00:03:50.830 --> 00:03:53.570
of our X.509 and PKI subsystem.

00:03:54.210 --> 00:03:57.760
In Tiger, we started off with
smart card integration.

00:03:57.880 --> 00:04:04.230
We'd actually been supporting smart cards
since Jaguar or so through our PCSC stack

00:04:04.390 --> 00:04:06.600
and the muscle card subsystems.

00:04:06.710 --> 00:04:09.280
But in Tiger,
we decided what our feature would

00:04:09.280 --> 00:04:12.960
be is to actually support them as if
they're keychains so they actually

00:04:13.200 --> 00:04:18.990
fit into the way that we manage
PKI capabilities on the system itself.

00:04:19.550 --> 00:04:22.930
Other things that happened during Tiger,
actually mid-release,

00:04:22.980 --> 00:04:28.150
the iChat folks included the capabilities
for encrypted iChat that once again

00:04:28.360 --> 00:04:32.500
exploited mostly our CMS libraries
that were developed by SMIME.

00:04:32.500 --> 00:04:36.530
VPN and AirPort also work
with our PKI capabilities,

00:04:36.630 --> 00:04:40.500
and since of course we're enabled
through smart cards as keychains,

00:04:40.500 --> 00:04:44.130
that functionality was there as well.

00:04:44.400 --> 00:04:50.360
So now, the next step for us is to
include signed applications.

00:04:50.360 --> 00:04:54.200
The ability to actually sign
applications here at Apple,

00:04:54.200 --> 00:04:59.840
deliver them to a customer system,
and when you or your mom are

00:04:59.840 --> 00:05:03.570
actually running Mail.App,
the application, when it asks,

00:05:03.720 --> 00:05:07.920
for instance, for a keychain item,
will be able to say, can Mail.App,

00:05:07.920 --> 00:05:12.410
actually signed by Apple,
actually get this keychain item?

00:05:12.420 --> 00:05:18.520
And when we update that application,
it'll still be Mail.App, signed by Apple,

00:05:18.560 --> 00:05:21.760
and the user won't be
bugged for another question.

00:05:21.760 --> 00:05:25.060
We'll be able to springboard
this into other technologies,

00:05:25.060 --> 00:05:28.870
like I said, MCX and parental controls,
we'll be able to actually

00:05:28.870 --> 00:05:30.980
solidly identify applications.

00:05:30.990 --> 00:05:37.120
And we have a lot of ideas for future
use of this technology as well.

00:05:38.720 --> 00:05:42.700
So,
my lead architect for the security group,

00:05:42.880 --> 00:05:46.250
Perry 'the Cynic' Kiehtreiber,
will be doing a presentation

00:05:46.250 --> 00:05:50.460
now on signed applications,
how we did it, and everything else.

00:05:50.680 --> 00:05:52.290
Perry.

00:05:54.000 --> 00:05:55.970
Give me that thing.

00:05:56.350 --> 00:05:56.750
Live?

00:05:56.960 --> 00:05:58.440
Good.

00:05:58.440 --> 00:06:00.030
OK.

00:06:00.190 --> 00:06:03.200
I just put up the big
picture to scare you all.

00:06:03.240 --> 00:06:03.990
Don't worry about it.

00:06:04.040 --> 00:06:06.970
I'll talk you through
it a little bit later.

00:06:07.210 --> 00:06:08.320
What am I going to tell you?

00:06:08.320 --> 00:06:10.690
I'm going to tell you
what this is all about.

00:06:10.760 --> 00:06:14.300
I'm going to tell you what it can
do for you and for the system.

00:06:14.470 --> 00:06:16.830
I'll tell you what it won't
do for you in the system,

00:06:16.920 --> 00:06:19.150
which is probably just as important.

00:06:19.280 --> 00:06:24.710
I'll let you know what we expect
you to do for Leopard and what

00:06:24.710 --> 00:06:30.050
you could get out of this,
depending on your situation.

00:06:30.180 --> 00:06:33.670
So what does it do?

00:06:34.550 --> 00:06:40.070
It essentially takes your code,
your application, your bundles,

00:06:40.150 --> 00:06:45.530
your tools,
and puts a digital seal on them that

00:06:45.600 --> 00:06:48.270
allows modifications to be detected.

00:06:48.340 --> 00:06:54.590
So think of it as sort of freezing your
application in a container of sorts.

00:06:55.010 --> 00:06:58.660
It says here,
"Provably seal it," because the system

00:06:58.660 --> 00:07:03.430
can figure out when the seal's broken,
when your code has been modified.

00:07:03.550 --> 00:07:08.780
Then,
we bind the seal to a digital identity.

00:07:09.420 --> 00:07:13.690
That's your digital identity or the
identity of whoever made the program.

00:07:13.800 --> 00:07:18.310
In addition,
what the code signing system allows

00:07:18.450 --> 00:07:25.480
you to do or anybody else to do is
to express requirements of various

00:07:25.490 --> 00:07:30.000
nature that can be placed on code.

00:07:30.530 --> 00:07:32.430
Basically,
a set of conditions that need to be

00:07:32.550 --> 00:07:36.720
satisfied before the code is allowed
to do something or get something or

00:07:36.720 --> 00:07:38.800
otherwise proceed with its operation.

00:07:39.420 --> 00:07:44.070
Now, on the other side of the game,
of course, we have the functionality

00:07:44.070 --> 00:07:48.210
to verify the seal,
to identify the digital

00:07:48.210 --> 00:07:52.500
identity that did the signing,
and to evaluate these constraints,

00:07:52.500 --> 00:07:54.410
these conditions.

00:07:54.960 --> 00:07:56.580
What doesn't it do?

00:07:56.710 --> 00:07:58.780
This is an identification facility.

00:07:58.790 --> 00:08:05.560
It helps everybody involved figuring
out the identity of a piece of code and

00:08:05.560 --> 00:08:10.800
whether it is still intact or whether it
has been modified or otherwise subverted.

00:08:10.800 --> 00:08:15.390
Using this API or signing your
applications by itself doesn't give

00:08:15.740 --> 00:08:20.800
your code the ability to do anything
that it isn't already able to do.

00:08:20.800 --> 00:08:23.360
In that, it's very much like
the authorization APIs,

00:08:23.360 --> 00:08:24.800
if you've ever used those.

00:08:24.800 --> 00:08:29.800
They are not there to give you
the capability to do something.

00:08:29.800 --> 00:08:34.430
They are there to validate
whether a piece of code has

00:08:34.430 --> 00:08:37.030
the right to do something.

00:08:37.620 --> 00:08:38.420
CodeSign Inc.

00:08:38.420 --> 00:08:42.820
won't do anything about the bugs that
are in the code because it doesn't

00:08:42.820 --> 00:08:44.500
actually watch your code running.

00:08:44.500 --> 00:08:49.600
It just tells you whether that's
the code that the manufacturer made.

00:08:49.740 --> 00:08:52.100
So just because something's
signed doesn't mean that

00:08:52.100 --> 00:08:53.490
there aren't any bugs in it.

00:08:53.510 --> 00:08:55.160
I know that's a horrible surprise.

00:08:55.160 --> 00:08:56.590
And CodeSign Inc.

00:08:57.200 --> 00:09:02.090
doesn't actually protect you
against trusting the wrong code or

00:09:02.090 --> 00:09:05.130
trusting the wrong manufacturer.

00:09:05.240 --> 00:09:12.190
If you tell the system that you are
willing to run this Mail.app made by

00:09:12.190 --> 00:09:16.350
Hacker Inc., then the system will go,
"Okay, I'll run it for you.

00:09:16.630 --> 00:09:18.650
You said so."

00:09:19.790 --> 00:09:24.160
I've been told to tell you that this
is not a copy protection solution,

00:09:24.160 --> 00:09:26.700
and in fact it isn't, sort of.

00:09:26.970 --> 00:09:30.630
It does help you protect
the integrity of your code.

00:09:30.870 --> 00:09:33.700
So if your worry is that
somebody will go in,

00:09:33.700 --> 00:09:36.380
crawl into your code,
and hack it around to turn

00:09:36.450 --> 00:09:39.690
off stuff you put in there,
code signing will help you.

00:09:39.700 --> 00:09:42.300
It doesn't do anything about
people taking that code,

00:09:42.300 --> 00:09:44.700
taking it elsewhere,
and running it elsewhere.

00:09:44.700 --> 00:09:47.700
That's not its job,
that's not what it's for.

00:09:47.700 --> 00:09:50.660
So if there is stuff in your
code that you're worrying

00:09:50.660 --> 00:09:54.700
about people hacking around on,
this is great for you.

00:09:54.700 --> 00:09:56.700
But copy protection, this isn't.

00:09:56.700 --> 00:10:01.700
And just like anything else we're doing,
unfortunately, it's not bloody magic.

00:10:01.700 --> 00:10:04.650
It's not going to solve
all of your problems.

00:10:04.720 --> 00:10:08.700
It's just one little piece, well, okay,
one medium-sized piece,

00:10:09.170 --> 00:10:13.260
that's going to help
make the world safer.

00:10:13.790 --> 00:10:16.350
So let me walk you through
the basic scenario.

00:10:16.520 --> 00:10:18.260
Here's what's happening.

00:10:18.280 --> 00:10:20.710
You take your code.

00:10:21.070 --> 00:10:23.920
Nobody cares whether this is Xcode,
except, of course, Apple.

00:10:23.920 --> 00:10:25.980
You're supposed to use Xcode.

00:10:25.980 --> 00:10:27.510
But make files will work.

00:10:27.700 --> 00:10:28.600
Doesn't matter.

00:10:28.650 --> 00:10:33.000
And if you're making an application,
you have an Info.plist.

00:10:33.130 --> 00:10:34.290
You have resources.

00:10:34.300 --> 00:10:36.520
You put them all together
with your build tool.

00:10:36.580 --> 00:10:39.100
And eventually,
you arrive at this beautifully

00:10:39.100 --> 00:10:42.800
bundled up application with the right
icon and the right configuration

00:10:42.800 --> 00:10:44.130
and all the localizations.

00:10:44.190 --> 00:10:45.380
And it's beautiful.

00:10:45.380 --> 00:10:47.420
That's what you'd normally ship.

00:10:47.420 --> 00:10:51.280
Well, actually, in addition,
you're going to take a digital

00:10:51.280 --> 00:10:55.380
identity in a keychain,
because that's where they go.

00:10:55.390 --> 00:10:59.140
And you're going to feed this
final code of yours and the

00:10:59.140 --> 00:11:01.200
identity into the codesign command.

00:11:01.270 --> 00:11:02.340
That's a new command.

00:11:02.540 --> 00:11:05.440
It's in your seed,
so you can play around with it.

00:11:05.440 --> 00:11:06.740
It's a command line tool.

00:11:06.740 --> 00:11:09.260
I hope that doesn't scare you too much.

00:11:09.270 --> 00:11:12.900
What codesign does is it adds
information to your bundle.

00:11:12.900 --> 00:11:14.380
It creates a couple of files.

00:11:14.410 --> 00:11:17.050
It will also,
at least in the final version,

00:11:17.060 --> 00:11:19.900
rewrite your executable somewhat.

00:11:19.900 --> 00:11:23.400
And the result is very much
an application or a tool

00:11:23.400 --> 00:11:25.400
or a bundle as the input.

00:11:25.400 --> 00:11:28.890
It behaves exactly the same as
far as the system is concerned.

00:11:28.900 --> 00:11:30.400
But it's now signed.

00:11:30.400 --> 00:11:32.390
So there is extra stuff in it.

00:11:32.400 --> 00:11:36.880
Then you take that and you ship it
pretty much the way you've always done.

00:11:36.900 --> 00:11:39.810
And the codesigning machine absolutely
does not care how you ship this.

00:11:39.920 --> 00:11:41.000
You can, you know, just do it.

00:11:41.000 --> 00:11:43.680
You can ship installers.

00:11:43.720 --> 00:11:46.160
You can use online software updaters.

00:11:46.160 --> 00:11:50.010
You can use binary diffs and put
it back together at the other end.

00:11:50.070 --> 00:11:53.580
The only thing we care about is
that when you're done doing your

00:11:53.580 --> 00:11:57.110
delivery at the user system,
it's exactly the same thing

00:11:57.170 --> 00:11:58.970
that you started with.

00:12:00.860 --> 00:12:04.520
And then somebody, you hope,
will run this on the user system.

00:12:04.600 --> 00:12:06.250
Now this is a really important point.

00:12:06.410 --> 00:12:08.800
Code signing is about running code.

00:12:08.970 --> 00:12:11.800
This is not about stuff
sitting on the hard drive.

00:12:12.030 --> 00:12:15.210
Code signing will help you
verify things on the disk,

00:12:15.210 --> 00:12:17.660
but that's not its primary function.

00:12:17.850 --> 00:12:21.220
The primary function of code
signing functionality is to work

00:12:21.220 --> 00:12:23.390
with code that's actually running.

00:12:25.100 --> 00:12:30.580
You make calls into a verification API,
give it handles for the running code,

00:12:30.700 --> 00:12:34.900
the process, whatever else it is,
and out pops an outcome

00:12:34.900 --> 00:12:38.500
which is pretty much either,
yep, it's there,

00:12:38.500 --> 00:12:41.070
this is really its identity,
and these are the conditions

00:12:41.070 --> 00:12:43.540
that you placed in it,
and they're fine,

00:12:43.540 --> 00:12:47.200
or you get an astonishing
variety of error codes that

00:12:47.290 --> 00:12:51.850
tell you that things aren't so,
and that something means that this piece

00:12:51.850 --> 00:12:54.940
of code really can't be identified.

00:12:55.000 --> 00:12:56.290
Amen.

00:13:00.030 --> 00:13:04.680
I'll try to show you
what this really means.

00:13:04.680 --> 00:13:10.220
I hope nobody here is scared of
terminal and the command line.

00:13:10.280 --> 00:13:11.720
Demo system, please.

00:13:11.730 --> 00:13:13.290
Thank you.

00:13:14.410 --> 00:13:16.240
All right.

00:13:16.370 --> 00:13:20.060
So as I said,
there's a new command called code sign.

00:13:20.060 --> 00:13:25.320
It has a man page,
so if you don't mind that kind of thing,

00:13:25.320 --> 00:13:26.240
go read it.

00:13:26.360 --> 00:13:27.640
It'll explain everything to you.

00:13:28.460 --> 00:13:33.740
And I made a little
program called CSTest,

00:13:33.800 --> 00:13:36.910
one of those things that only lives
to demonstrate what's going on here.

00:13:38.790 --> 00:13:43.360
Right now, since I just built it,
CSTest isn't signed.

00:13:43.510 --> 00:13:47.800
So code sign dash v does a
verification of the code signature,

00:13:47.800 --> 00:13:48.940
and well, it's not signed.

00:13:48.940 --> 00:13:53.800
So just for the few of you who have
never been annoyed by keychain calls,

00:13:53.880 --> 00:13:57.180
let me show you what happens
when a program isn't signed.

00:13:57.180 --> 00:14:02.210
Let's make a little keychain item here,
call it foo, doesn't much matter.

00:14:02.210 --> 00:14:05.900
And one of the few things that
CSTest knows how to do is it

00:14:05.900 --> 00:14:08.130
can retrieve a keychain item.

00:14:08.700 --> 00:14:10.310
You've all seen this dialogue.

00:14:10.480 --> 00:14:14.220
This is the, hey, no,
this CSTest program has never

00:14:14.220 --> 00:14:16.040
tried to access this item before.

00:14:16.040 --> 00:14:17.420
Do you really want to give it access?

00:14:17.420 --> 00:14:20.660
And if you click on always allow,
then the system remembers

00:14:20.660 --> 00:14:23.100
that from now on,
CSTest is allowed access

00:14:23.130 --> 00:14:24.600
to the keychain item.

00:14:24.600 --> 00:14:27.330
And if you do this again,
then you don't get the dialogue again,

00:14:27.330 --> 00:14:28.100
thankfully.

00:14:28.100 --> 00:14:30.440
And everything's cool.

00:14:30.440 --> 00:14:34.850
That is,
until you want to change something.

00:14:36.910 --> 00:14:38.730
I mean, we all have been through this.

00:14:38.800 --> 00:14:40.660
This is the source of CSTest.

00:14:40.770 --> 00:14:43.700
And somebody just told you
to change the program to,

00:14:43.700 --> 00:14:47.710
I don't know, put a disclaimer in.

00:14:49.690 --> 00:14:52.140
So we've rebuilt CSTest.

00:14:52.220 --> 00:14:56.510
It now puts the disclaimer out.

00:14:57.320 --> 00:14:59.940
Well, isn't that a beautiful dialogue?

00:14:59.940 --> 00:15:04.810
This is the best the system can
do in Tiger to tell you that,

00:15:04.810 --> 00:15:07.160
well, CSTest has changed.

00:15:07.160 --> 00:15:11.120
It's the same name that it used to have,
but it's not the same program anymore,

00:15:11.120 --> 00:15:12.640
and what do you want to do about this?

00:15:12.640 --> 00:15:15.430
And there is this change all
button that basically says,

00:15:15.440 --> 00:15:16.480
I know what I'm doing.

00:15:16.480 --> 00:15:17.600
It's still the same program.

00:15:17.600 --> 00:15:22.000
And that tells the system to remember
that the old one and the new one are sort

00:15:22.000 --> 00:15:25.550
of the same as far as you're concerned,
and now we're okay again until

00:15:25.550 --> 00:15:26.900
we change the program again.

00:15:27.200 --> 00:15:30.880
Which is very annoying,
particularly when it happens to 25

00:15:30.880 --> 00:15:32.920
keychain items in your keychain.

00:15:34.570 --> 00:15:35.400
Not good.

00:15:35.560 --> 00:15:36.750
So, what can we do?

00:15:37.190 --> 00:15:41.720
Well, we can sign CSTest.

00:15:42.180 --> 00:15:48.510
The -s takes an argument that is the
identity that you're going to use.

00:15:48.550 --> 00:15:50.890
Since it's in the keychain,
we have to unlock the keychain

00:15:50.890 --> 00:15:52.520
that happens to contain this.

00:15:52.580 --> 00:15:55.310
And now we can verify it.

00:15:55.400 --> 00:15:58.220
This is a Unix style command,
so if it doesn't say anything,

00:15:58.230 --> 00:15:58.770
that's good.

00:15:58.870 --> 00:16:02.580
If that bothers you,
add more -v options and it starts

00:16:02.580 --> 00:16:05.720
saying lots of things that just
tell you that the world is good.

00:16:05.720 --> 00:16:09.520
So, let's try this again now with,
just to be fair,

00:16:09.520 --> 00:16:11.760
a different keychain item.

00:16:11.760 --> 00:16:14.710
Let's call it test.

00:16:16.820 --> 00:16:22.040
And now we're trying to access test.

00:16:22.040 --> 00:16:23.120
Yes, it's okay.

00:16:23.200 --> 00:16:23.990
Take access.

00:16:23.990 --> 00:16:26.030
So here.

00:16:26.040 --> 00:16:27.700
And you know how these marketeers are.

00:16:27.700 --> 00:16:30.430
The disclaimer wasn't
really disclaiming enough.

00:16:30.980 --> 00:16:34.070
They need a strict disclaimer.

00:16:35.410 --> 00:16:40.430
Okay, so here is CSTest,
which now has the strict disclaimer.

00:16:40.430 --> 00:16:43.240
And since we're now living
in the code signing world,

00:16:43.370 --> 00:16:45.280
let's sign it again.

00:16:45.770 --> 00:16:47.570
New version of your program.

00:16:47.570 --> 00:16:49.850
New signed version of your program.

00:16:49.910 --> 00:16:54.080
So let's access test and oh, no dialogue.

00:16:58.240 --> 00:17:01.830
Let me tell you what really changed here.

00:17:02.120 --> 00:17:04.600
I mean, the dialogue went away
and the user is happy.

00:17:04.600 --> 00:17:07.100
You don't get tech support
calls from users saying,

00:17:07.100 --> 00:17:09.630
"What is that dialogue and does
this mean that you are attacking my

00:17:09.630 --> 00:17:14.100
system?" But what really changed here
under the hood in the system as a

00:17:14.100 --> 00:17:17.030
whole is something really fundamental.

00:17:17.230 --> 00:17:20.090
In the old version,
the system looked at the program

00:17:20.090 --> 00:17:23.980
on the user's system using a hash,
but that's sort of an

00:17:23.980 --> 00:17:25.090
implementation detail.

00:17:25.110 --> 00:17:27.100
But it basically looked at the
program on the user's system

00:17:27.100 --> 00:17:29.100
and remembered that program.

00:17:29.100 --> 00:17:33.100
And when you shipped an update,
it was just a different program.

00:17:33.100 --> 00:17:35.100
It sort of kind of knows
that it's the same name,

00:17:35.100 --> 00:17:38.100
but that, of course, can be faked easily,
so it can't rely on this.

00:17:38.100 --> 00:17:41.660
So in order to figure out whether
that new program is really supposed

00:17:41.660 --> 00:17:44.970
to behave like the old program
as far as security is concerned,

00:17:44.970 --> 00:17:46.100
it has to ask you.

00:17:46.100 --> 00:17:47.100
It doesn't know any better.

00:17:47.100 --> 00:17:52.430
In the new universe, with code signing,
the signing is done

00:17:52.890 --> 00:17:55.500
When you make your program
before you ship it.

00:17:55.500 --> 00:17:58.950
So rather than comparing the
programs on the user's system,

00:17:58.950 --> 00:18:02.100
what it's really doing is
it's taking your word for it.

00:18:02.100 --> 00:18:04.900
When you sign a program
and you say this is CSTest,

00:18:04.900 --> 00:18:07.190
okay,
so what we remember is that a program

00:18:07.390 --> 00:18:11.290
called CSTest signed by you is
allowed to access this keychain item.

00:18:11.290 --> 00:18:14.160
If you make an update and
you sign it and you ship it,

00:18:14.160 --> 00:18:17.040
it's still a program signed
by you called CSTest.

00:18:17.040 --> 00:18:19.000
There's no question about here.

00:18:19.000 --> 00:18:20.560
There's no uncertainty.

00:18:20.560 --> 00:18:22.780
It's the same thing.

00:18:22.800 --> 00:18:26.330
It's the same program because you
said so and you're the manufacturer.

00:18:26.430 --> 00:18:29.080
So this is really what's going on here.

00:18:29.440 --> 00:18:32.760
Okay, well, we're Apple,
so let's do something with an actual

00:18:32.760 --> 00:18:34.630
application that looks graphical.

00:18:34.770 --> 00:18:36.830
Again,
this thing really doesn't do anything

00:18:36.830 --> 00:18:39.530
other than demonstrate things.

00:18:39.940 --> 00:18:43.640
This is freshly built,
so of course it's not signed.

00:18:43.640 --> 00:18:47.220
But, you know,
just like you can sign a tool,

00:18:47.350 --> 00:18:50.220
you can sign an application.

00:18:52.540 --> 00:18:56.120
The checkboxes here are
simply the program calling

00:18:56.120 --> 00:18:58.820
the verification API itself.

00:18:59.050 --> 00:19:01.520
Normally you don't do this
because you generally assume

00:19:01.520 --> 00:19:04.400
that you yourself are okay,
and if you aren't okay,

00:19:04.400 --> 00:19:07.840
you can't trust yourself
figuring out whether you're okay.

00:19:07.840 --> 00:19:10.900
So in reality,
you call this on other people's code.

00:19:10.900 --> 00:19:14.640
But for demonstration purposes,
this is easy.

00:19:14.640 --> 00:19:18.700
What you have here is we signed it,
it's validly signed, and well,

00:19:18.850 --> 00:19:22.090
this button here basically
just does the same thing that

00:19:22.090 --> 00:19:23.810
the command line tool did.

00:19:23.810 --> 00:19:25.590
It fetches a keychain item.

00:19:25.590 --> 00:19:28.060
And of course,
since the CS test application

00:19:28.340 --> 00:19:31.950
is a different program,
we get the always allow, and okay,

00:19:31.950 --> 00:19:35.230
it worked, and well,
it still works because now we're

00:19:35.230 --> 00:19:37.480
on the access control list.

00:19:37.530 --> 00:19:41.130
So one of the things that happens,
remember,

00:19:41.130 --> 00:19:44.190
code signing is about running code.

00:19:44.730 --> 00:19:49.460
In addition to the files on the disk,
there's a dynamic state of

00:19:49.460 --> 00:19:51.350
validity that can be cleared.

00:19:51.360 --> 00:19:55.300
A program can lose its identity
when it does certain things.

00:19:55.450 --> 00:19:57.770
The kernel keeps track
of this for processes,

00:19:57.870 --> 00:20:00.430
and the idea is that once
you've lost your identity,

00:20:00.430 --> 00:20:01.990
you can't ever get it back.

00:20:02.110 --> 00:20:03.820
It's sticky.

00:20:04.000 --> 00:20:06.870
Most of the time a program will
actually do this to itself.

00:20:07.040 --> 00:20:08.790
"Hmm, I'm not sure if I should load this.

00:20:08.800 --> 00:20:12.100
I'm not quite sure if I'm still
going to be myself when I load this,

00:20:12.140 --> 00:20:14.590
but okay, I'll tell the kernel
that I'm no longer me,

00:20:14.600 --> 00:20:18.670
and then I can load this and run off,
but the rest of the system will

00:20:18.670 --> 00:20:21.100
now know that I've lost it.

00:20:21.150 --> 00:20:24.110
If you quit me and relaunch me,
I'll be myself again until I do

00:20:24.120 --> 00:20:28.470
something questionable." So we
can turn the valid bit off,

00:20:28.470 --> 00:20:33.900
which behind the scenes is making this,
you know, "I'm no longer me" call.

00:20:34.060 --> 00:20:37.900
And at that point, well,
you're back to this dialogue,

00:20:37.900 --> 00:20:42.560
because the system now doesn't think
that CSTest really is CSTest anymore.

00:20:42.720 --> 00:20:45.430
It might be, but we're not sure.

00:20:46.630 --> 00:20:50.320
And as I said, you can't get your dynamic
validity back except by,

00:20:50.320 --> 00:20:54.590
well, relaunching yourself,
at which point you're fine again.

00:20:54.650 --> 00:20:56.840
Now,
what is it that we're protecting here?

00:20:56.840 --> 00:20:59.970
We're protecting against
modification of the code itself.

00:21:00.180 --> 00:21:01.760
You've seen that in
the command line tool.

00:21:01.760 --> 00:21:04.900
I could do the same disclaimer thing,
of course, here.

00:21:04.970 --> 00:21:07.520
I could show you that
I can modify the nib,

00:21:07.540 --> 00:21:09.000
and it would change the program.

00:21:09.020 --> 00:21:11.180
The nib's part of what's protected.

00:21:11.240 --> 00:21:16.300
But let's look at something perhaps
a little bit more interesting.

00:21:16.620 --> 00:21:19.660
The Info.plist is
protected by code signing.

00:21:19.740 --> 00:21:22.560
So if you're going into--

00:21:22.700 --> 00:21:25.980
This info.p list here,
and you are maliciously

00:21:25.980 --> 00:21:29.200
trying to change something,
like I'm going to make

00:21:29.200 --> 00:21:32.320
this thing accept...

00:21:32.930 --> 00:21:34.950
The application signatures
that it shouldn't,

00:21:35.510 --> 00:21:40.370
see here, the verification API figured
out that the code's changed.

00:21:40.470 --> 00:21:43.110
It's still signed,
but it's not validly signed, and again,

00:21:43.220 --> 00:21:45.800
well, system knows you're
not really you anymore.

00:21:45.800 --> 00:21:50.800
The sort of cool thing is that it really
doesn't much care how you got there,

00:21:50.800 --> 00:21:57.800
so if you change the Info.plist back,
then it's valid again.

00:21:58.110 --> 00:21:59.930
Everything's fine.

00:22:02.790 --> 00:22:08.390
Another thing that you are
being protected is resources.

00:22:08.600 --> 00:22:09.840
Come on.

00:22:09.900 --> 00:22:11.930
Do what I mean.

00:22:12.010 --> 00:22:13.730
There's not much resources in here.

00:22:13.940 --> 00:22:17.480
Let's say I am adding a resource.

00:22:17.620 --> 00:22:19.440
It notices.

00:22:20.330 --> 00:22:22.670
Same thing happens if
you remove a resource.

00:22:22.750 --> 00:22:26.580
You know, if I took the icon away,
if I modified it.

00:22:26.630 --> 00:22:28.840
Basically,
your resources have to be exactly

00:22:28.840 --> 00:22:31.430
the resources that were there
when the program was signed

00:22:31.750 --> 00:22:34.000
or the signature's invalid.

00:22:34.180 --> 00:22:38.670
Okay, this is the basic integrity thing,
and if you don't care about any of

00:22:38.670 --> 00:22:42.450
that other identification stuff,
the one thing to take home is

00:22:42.850 --> 00:22:46.190
once you sign your programs,
you'll never have to worry about

00:22:46.270 --> 00:22:49.230
people hacking around with your
program and you not having any way

00:22:49.230 --> 00:22:51.060
of figuring out that that happened.

00:22:51.100 --> 00:22:54.360
If you sign it, and somebody gives you a
tech support call and says,

00:22:54.360 --> 00:22:59.100
"Your program's misbehaving," tell
them to code-sign -v your program,

00:22:59.100 --> 00:23:03.070
and if that gives an error message,
it was modified.

00:23:03.100 --> 00:23:05.610
You won't necessarily
know who modified it,

00:23:05.610 --> 00:23:09.100
whether it's the user himself or somebody
made a hacked version of your program,

00:23:09.100 --> 00:23:12.100
but at least you know it isn't
your program that's misbehaving,

00:23:12.100 --> 00:23:15.100
it's some mutant offspring of it.

00:23:15.100 --> 00:23:21.580
Okay, let me show you one more thing.

00:23:22.950 --> 00:23:28.560
Here's the .mac preferences,
which we all know and love.

00:23:28.560 --> 00:23:34.520
I'm showing you .mac because the .mac
password is such a loved password.

00:23:34.710 --> 00:23:36.270
Everybody wants to use it.

00:23:36.450 --> 00:23:39.400
There's like 16 different
Apple applications now that all

00:23:39.400 --> 00:23:41.080
want to use your .mac password.

00:23:41.080 --> 00:23:42.550
Mail wants to.

00:23:42.670 --> 00:23:44.360
iChat wants to.

00:23:44.530 --> 00:23:47.610
And half of those have little
demons in the background.

00:23:47.710 --> 00:23:52.170
So what really happens when you are
creating a .mac password with one of

00:23:52.170 --> 00:23:59.760
the Apple applications is there's a
little SPI call that makes a really,

00:23:59.760 --> 00:24:02.720
really big access control list.

00:24:02.800 --> 00:24:05.280
It takes a little while
because it's a really,

00:24:05.280 --> 00:24:07.530
really big access control list here.

00:24:08.460 --> 00:24:11.980
And you can just tell this is a
who's who of Apple applications.

00:24:12.050 --> 00:24:16.890
Now, all of these know that they want
to work with your .Mac password,

00:24:16.890 --> 00:24:20.400
and there's basically this list
of all of these applications.

00:24:20.430 --> 00:24:24.390
And if Apple ever makes a new one,
and God knows we do all the time,

00:24:24.390 --> 00:24:27.390
it gets added to this list eventually.

00:24:27.400 --> 00:24:29.940
Meantime,
you get one of those nice dialogues

00:24:30.180 --> 00:24:34.480
that says the Frobos background super
app wants access to your .Mac password,

00:24:34.480 --> 00:24:36.800
and you're kind of going,
"What is that?" Well,

00:24:36.800 --> 00:24:39.560
Apple invented that in
the last software update.

00:24:40.160 --> 00:24:42.000
Oh, and here's a new one.

00:24:42.120 --> 00:24:45.260
This is something that we
added with code signing.

00:24:45.430 --> 00:24:48.450
Rather than just having
a list of applications,

00:24:48.510 --> 00:24:52.420
each of them separately enumerated,
we now have application groups.

00:24:52.560 --> 00:24:57.570
And any application in this group
automatically has access to this item.

00:24:58.050 --> 00:25:03.790
So what I can actually do, if I want to,
is I can take this list here

00:25:04.000 --> 00:25:07.490
and just take them all off the--

00:25:09.400 --> 00:25:16.100
[Transcript missing]

00:25:16.670 --> 00:25:19.080
How about mail?

00:25:19.080 --> 00:25:23.540
This is my .mac account and I, no,
I don't really,

00:25:23.590 --> 00:25:29.390
I haven't actually checked my email there
for a while so it's probably a long list.

00:25:30.430 --> 00:25:32.960
Syndication agent.

00:25:33.010 --> 00:25:33.750
That's exciting.

00:25:33.750 --> 00:25:38.800
But the idea is we're online here.

00:25:38.800 --> 00:25:40.230
It's still chewing through my email.

00:25:40.240 --> 00:25:42.220
As I said,
I haven't checked this in a while,

00:25:42.220 --> 00:25:43.420
and it's full of spam.

00:25:43.460 --> 00:25:50.750
But Mail.app has access to this password,
not because it's on some explicit list,

00:25:50.750 --> 00:25:54.550
but because it's in the
.mac application group.

00:25:57.960 --> 00:26:01.200
So, how do you add something
to an application group?

00:26:01.410 --> 00:26:02.700
Good question.

00:26:03.050 --> 00:26:06.080
Let's put CSTest into the
.mac application group.

00:26:06.130 --> 00:26:09.600
Actually, we're almost in here.

00:26:09.650 --> 00:26:14.680
What you do is you edit the Info.plist,
which you've all done before,

00:26:14.720 --> 00:26:17.300
and it's really quite simple.

00:26:17.310 --> 00:26:21.000
You add an application group.

00:26:21.690 --> 00:26:23.360
entry.

00:26:23.400 --> 00:26:26.480
And in the case of .Mac,
the name of the application

00:26:26.530 --> 00:26:28.700
group happens to be .Mac.

00:26:30.010 --> 00:26:33.330
Of course,
editing the Info.plist invalidated

00:26:33.330 --> 00:26:36.760
the signatures,
so if we now went and

00:26:36.760 --> 00:26:41.380
tried to access Perry,
which happens to be my password,

00:26:41.460 --> 00:26:42.960
that doesn't work.

00:26:43.200 --> 00:26:45.000
You're not really you, are you?

00:26:45.000 --> 00:26:48.490
So let's sign it.

00:26:55.450 --> 00:26:57.920
I haven't used that
keychain for five minutes.

00:26:57.920 --> 00:27:01.090
The dash F, incidentally,
just-- if you're trying to sign an

00:27:01.090 --> 00:27:04.690
application that's already signed,
it won't let you unless you say,

00:27:04.690 --> 00:27:06.390
I know what I'm doing here.

00:27:06.500 --> 00:27:14.080
So that has regenerated the signature.

00:27:14.110 --> 00:27:16.130
And if we now try to access
the dot Mac password,

00:27:16.130 --> 00:27:16.130
it worked.

00:27:21.300 --> 00:27:22.300
slides, please.

00:27:22.300 --> 00:27:31.080
And I know, this isn't quite as good
as pulsing Aqua buttons.

00:27:32.180 --> 00:27:34.280
But we're the infrastructure group.

00:27:34.490 --> 00:27:36.210
OK.

00:27:36.460 --> 00:27:41.160
We're calling this code signing
even though the session is called

00:27:41.210 --> 00:27:46.140
application signing because this is
more than just application signing.

00:27:46.160 --> 00:27:50.140
We've already talked about tools.

00:27:50.580 --> 00:27:55.500
What we're planning to do is include
in this notion of code you can

00:27:55.500 --> 00:27:59.620
sign pretty much anything that you
intuitively think might be code.

00:27:59.810 --> 00:28:05.730
Single executables, application bundles,
but also plugin bundles, frameworks,

00:28:05.820 --> 00:28:09.890
libraries, scripts, applets, widgets.

00:28:10.290 --> 00:28:14.590
Pretty much anything you think is code,
anything that gets run

00:28:14.590 --> 00:28:16.320
or runs on the system.

00:28:16.380 --> 00:28:20.500
Now, it's going to take time to get all
of that covered under the umbrella,

00:28:20.500 --> 00:28:24.250
but the architecture is
there to cover it all.

00:28:24.310 --> 00:28:26.960
So that's why we call it code signing.

00:28:29.300 --> 00:28:32.140
If you're making universal binaries,
and you all do I hope,

00:28:32.560 --> 00:28:36.860
signing happens on a
per-architecture basis.

00:28:36.860 --> 00:28:41.330
So if you make something
that's four-way universal,

00:28:41.600 --> 00:28:45.190
then you'll basically get four
code signatures embedded there.

00:28:45.440 --> 00:28:50.850
The advantage is that if you run
around and you thin the executable,

00:28:50.850 --> 00:28:55.220
every single architecture that
you pull out and stick somewhere

00:28:55.320 --> 00:28:57.200
will still be validly signed.

00:28:57.200 --> 00:29:00.940
So if you have installers that
take a universal binary and,

00:29:00.940 --> 00:29:04.990
you know, just pull out the right
architecture for some reason,

00:29:05.250 --> 00:29:06.200
that's okay.

00:29:06.290 --> 00:29:08.750
Code signing will still work.

00:29:09.070 --> 00:29:11.000
Now here's one really important point.

00:29:11.210 --> 00:29:15.000
I'm going to tell you this three
times throughout the presentation

00:29:15.000 --> 00:29:17.160
because it's really important.

00:29:17.230 --> 00:29:19.650
Your code needs to be immutable.

00:29:19.770 --> 00:29:22.870
It can't change on the user system.

00:29:22.870 --> 00:29:24.540
And I don't care how it changes.

00:29:24.630 --> 00:29:28.040
You can't have configuration files in
there that the user is supposed to edit.

00:29:28.040 --> 00:29:31.510
You can't stick any preferences
of any kind into your app.

00:29:31.600 --> 00:29:36.510
You can't ask the user to stuff
new icons into your application,

00:29:36.510 --> 00:29:38.680
whether directly or
through some UI of yours.

00:29:38.790 --> 00:29:40.680
It needs to be immutable.

00:29:41.000 --> 00:29:45.660
Anything that changes on the user
system needs to be somewhere else.

00:29:45.800 --> 00:29:48.700
And if you read the rules
and regulations of Mac OS X,

00:29:48.700 --> 00:29:51.570
it'll tell you pretty explicitly
where that somewhere else is.

00:29:51.760 --> 00:29:54.780
Preferences go into library preferences.

00:29:54.880 --> 00:29:58.940
Support files go into library
application support and so on.

00:29:59.020 --> 00:30:05.690
So your code needs to be immutable or
you're going to have trouble with this.

00:30:05.770 --> 00:30:08.480
It just won't work for you.

00:30:08.480 --> 00:30:08.480
Bad things will happen to you.

00:30:08.480 --> 00:30:10.400
You'll be unhappy.

00:30:10.400 --> 00:30:13.570
Your customers will be unhappy.

00:30:13.570 --> 00:30:13.570
Don't do that.

00:30:15.220 --> 00:30:16.420
So how do you sign code?

00:30:16.500 --> 00:30:18.790
Because that is what we ask you to do.

00:30:19.010 --> 00:30:21.210
Come Leopard,
we want you to just have this

00:30:21.210 --> 00:30:26.180
extra step when you make your code,
your program, your applications,

00:30:26.250 --> 00:30:29.620
before you ship them,
we want you to sign them.

00:30:30.010 --> 00:30:30.760
And it's really easy.

00:30:30.900 --> 00:30:31.840
You saw.

00:30:31.880 --> 00:30:32.930
You run code sign.

00:30:33.080 --> 00:30:35.360
You say, over there, you say, what with?

00:30:35.360 --> 00:30:39.020
And there's a couple of other
optional stuff you can stuff in

00:30:39.230 --> 00:30:43.770
if the circumstances warrant it,
but that's basically it.

00:30:43.900 --> 00:30:47.880
It will modify your application,
your code, you take the result,

00:30:48.070 --> 00:30:53.620
and you shove it into your, excuse me,
you insert it into your packaging

00:30:53.620 --> 00:30:56.270
process just like you always do.

00:30:58.560 --> 00:31:00.250
I told you I will tell you again.

00:31:00.380 --> 00:31:06.040
So, it's okay to thin your
code after signing it,

00:31:06.040 --> 00:31:09.500
and conversely you can use lipo
if you've ever heard of that to,

00:31:09.500 --> 00:31:13.500
you know,
bunch more architectures into one file.

00:31:13.500 --> 00:31:16.740
Since we're signing in things
individually per architecture,

00:31:16.740 --> 00:31:18.490
the system really doesn't care.

00:31:18.500 --> 00:31:24.020
And once you've signed your code,
you can do pretty much anything you

00:31:24.020 --> 00:31:25.500
want with it that doesn't change it.

00:31:25.500 --> 00:31:28.500
You can copy it, you can move it,
you can stick it on a file server,

00:31:28.500 --> 00:31:31.400
you can put it in an installer,
and we don't care if it's

00:31:31.530 --> 00:31:33.500
the Apple installer or
a third party installer.

00:31:33.500 --> 00:31:36.260
You can cut it down the middle,
ship one half online and

00:31:36.260 --> 00:31:39.430
the other half on a CD,
stick it back together on the other side.

00:31:39.500 --> 00:31:43.660
It doesn't matter as long as when
you're done on the user system,

00:31:43.660 --> 00:31:47.650
it's the same files in the
same order as you started with.

00:31:48.280 --> 00:31:53.130
It's not okay to change your code,
and that includes our excellent

00:31:53.290 --> 00:31:57.700
link edit commands like strip and
nm edit and all of the other ones.

00:31:57.700 --> 00:32:02.200
And it is not okay to play with
the resources after you sign.

00:32:02.200 --> 00:32:04.190
The resources are all sealed.

00:32:04.200 --> 00:32:09.670
So if you have some kind of
post-production arrangement with some

00:32:09.670 --> 00:32:14.700
other department or some other company,
get that done before you sign.

00:32:14.700 --> 00:32:19.130
In particular, it also means you can't
take resources out.

00:32:19.200 --> 00:32:24.340
It means that if you are doing
localization for some core language

00:32:24.340 --> 00:32:30.200
set and then send it off to some
other company to add Korean and

00:32:30.200 --> 00:32:34.440
South Vietnamese and whatever else,
when you get it back and

00:32:34.610 --> 00:32:38.110
they've added their resources,
you need to resign.

00:32:39.310 --> 00:32:40.650
When should you sign?

00:32:40.910 --> 00:32:44.150
Well, obviously,
after you're done modifying it.

00:32:44.160 --> 00:32:47.040
I've already told you three times now.

00:32:47.450 --> 00:32:50.590
After you've gotten the
resources exactly right,

00:32:50.590 --> 00:32:56.590
and this is sort of an important point,
after you've decided that this is good,

00:32:56.710 --> 00:32:59.880
you can go off and sign almost anything.

00:33:00.130 --> 00:33:01.260
The machinery doesn't care.

00:33:01.430 --> 00:33:06.200
I mean, you use your digital identity as
long as you have it right there.

00:33:06.200 --> 00:33:07.660
You can sign your program.

00:33:07.660 --> 00:33:09.040
You can sign somebody else's program.

00:33:09.040 --> 00:33:12.120
You can sign something
that erases the hard drive.

00:33:12.160 --> 00:33:15.720
You wouldn't want something
that erases the hard drive

00:33:15.720 --> 00:33:17.380
to go out after you sign it.

00:33:17.400 --> 00:33:21.340
Because the signature basically says,
"Yeah, we like this.

00:33:21.340 --> 00:33:26.130
This is us." No.

00:33:26.870 --> 00:33:30.960
You may want to have an extra
step designed in there where after

00:33:31.160 --> 00:33:33.760
you build something you test it.

00:33:34.040 --> 00:33:34.800
Yeah, that's the word.

00:33:34.800 --> 00:33:39.990
You test it and you actually make sure
it behaves like something that you are

00:33:39.990 --> 00:33:42.760
proud of shipping and then you sign it.

00:33:42.880 --> 00:33:44.250
That's probably the best way to do it.

00:33:44.300 --> 00:33:48.250
Now that doesn't mean that you can't
sign stuff as part of your build

00:33:48.250 --> 00:33:53.000
process if verifying signature is
something that is routinely done to you.

00:33:53.000 --> 00:33:57.200
In which case, you might want to set up
two digital identities,

00:33:57.200 --> 00:33:59.800
one for testing and one for shipment.

00:33:59.920 --> 00:34:03.510
And obviously you want to sign
before you package it and ship it.

00:34:03.650 --> 00:34:07.340
There's nothing again that
keeps people from signing

00:34:07.450 --> 00:34:09.660
stuff on the end user system.

00:34:09.660 --> 00:34:11.600
That's perfectly okay.

00:34:11.600 --> 00:34:14.000
But it's not as good as
signing it in the system.

00:34:14.000 --> 00:34:16.680
So, you're missing out on the point
where you make your applications.

00:34:16.680 --> 00:34:22.090
Because the ceiling basically protects
against modification from the point where

00:34:22.090 --> 00:34:25.080
you sign to the point where you verify.

00:34:25.080 --> 00:34:28.180
If you sign on the end user system,
you're not protected against

00:34:28.180 --> 00:34:31.530
modifications during shipment,
people hacking your installers,

00:34:31.620 --> 00:34:34.920
people misdirecting software updaters,
that kind of thing.

00:34:34.920 --> 00:34:39.340
So, you're sort of missing on
half of this immutability gig.

00:34:39.340 --> 00:34:42.180
Also,
anybody who signs anything on the end

00:34:42.180 --> 00:34:44.700
user system is going to have to have
the same key on the end user system.

00:34:44.700 --> 00:34:49.580
And another important point about
using these digital identity

00:34:49.580 --> 00:34:55.670
things is that you keep those
on your computer where you work.

00:34:55.800 --> 00:34:57.700
The end user never gets to see those.

00:34:57.700 --> 00:35:03.240
The end user couldn't sign those with
your key because he's never got it.

00:35:03.240 --> 00:35:05.160
This is important.

00:35:06.120 --> 00:35:08.890
So we've been talking about
these identity things,

00:35:08.890 --> 00:35:14.750
and while those of you who know what
X.509 means vaguely will probably

00:35:14.800 --> 00:35:18.130
have figured out what this is by now.

00:35:18.360 --> 00:35:21.170
For those of you who have no idea
what a digital certificate is,

00:35:21.230 --> 00:35:24.000
let me just give you the
three-sentence summary.

00:35:24.090 --> 00:35:28.930
It's a cryptographic key,
which is sort of a binary bit bucket,

00:35:28.940 --> 00:35:32.090
and a digital certificate,
which is another binary bit bucket

00:35:32.210 --> 00:35:37.200
that you either make with something
called a certificate assistant,

00:35:37.310 --> 00:35:40.800
something we ship with the system,
or if you are big in corporate,

00:35:40.800 --> 00:35:45.010
you can ask VeriSign or other
companies to make you one.

00:35:45.180 --> 00:35:47.760
You stick those into a keychain,
or you import them into a

00:35:47.760 --> 00:35:49.920
keychain if you already have them.

00:35:49.920 --> 00:35:52.580
And from that moment on,
it just shows up as an identity,

00:35:52.670 --> 00:35:54.980
or if you prefer, my certificates.

00:35:55.160 --> 00:35:59.410
And as long as you carry that keychain
around and you have the password for the

00:35:59.410 --> 00:36:02.890
keychain handy when you try to use it,
it'll just work.

00:36:04.610 --> 00:36:10.250
You can make your own
code signing certificates.

00:36:11.420 --> 00:36:15.790
We don't insist that you get
certificates from big companies

00:36:15.840 --> 00:36:17.670
that want lots of money from you.

00:36:17.780 --> 00:36:20.000
So that's your choice.

00:36:22.170 --> 00:36:27.200
Hey, we think of you, folks, we do.

00:36:27.230 --> 00:36:31.660
If you have a code signing certificate,
say, from VeriSign,

00:36:31.670 --> 00:36:34.600
one of those things that work
with Microsoft Authenticode that

00:36:34.600 --> 00:36:36.130
happens to also work with our stuff.

00:36:36.250 --> 00:36:39.630
So if you've already invested
the Big Moolah for just the

00:36:39.630 --> 00:36:43.270
right kind of code signing cert,
you don't need a separate one for us.

00:36:43.340 --> 00:36:44.100
Just use it.

00:36:44.180 --> 00:36:46.290
It's OK, we don't mind.

00:36:46.510 --> 00:36:48.120
We don't sell these things to you.

00:36:48.120 --> 00:36:49.820
We're not planning on
selling them to you.

00:36:49.820 --> 00:36:51.920
It's not really our business.

00:36:52.000 --> 00:36:53.580
Why bother?

00:36:54.420 --> 00:36:57.200
Do think a little bit,
particularly if you're more than

00:36:57.430 --> 00:37:00.950
one employee in your company,
think a little bit about who's got the

00:37:00.950 --> 00:37:03.130
authority to actually do the signing.

00:37:03.140 --> 00:37:08.570
Just as I said,
only sign what you're proud of.

00:37:08.780 --> 00:37:13.740
You may want to make sure that if
you've got 2,000 employees that not

00:37:13.740 --> 00:37:15.690
anybody can just go and sign anything.

00:37:15.700 --> 00:37:20.700
How paranoid you want to be about
this is really not for me to say.

00:37:20.700 --> 00:37:23.700
It's sort of a corporate decision.

00:37:23.700 --> 00:37:26.200
So if you actually have
departments that worry about

00:37:26.200 --> 00:37:29.560
the legal side of these things,
you may want to give them a ring

00:37:29.800 --> 00:37:32.700
and tell them that this is coming
and tell them to think about it.

00:37:32.700 --> 00:37:36.700
Usually the legal folks think
about these things for months.

00:37:36.700 --> 00:37:40.700
So if you think you might run into this,
start talking to them now.

00:37:40.700 --> 00:37:45.700
Usually this takes way longer than
fixing bugs or implementing features.

00:37:46.800 --> 00:37:49.770
Okay, code requirements.

00:37:49.770 --> 00:37:54.680
If you remember at the start,
one of the pieces of functionality

00:37:54.680 --> 00:37:58.870
that code signing has is it
lets you express restrictions,

00:37:58.930 --> 00:38:02.770
constraints, conditions,
requirements on code.

00:38:02.800 --> 00:38:07.390
It lets you say things like,
"Must be called mail.app" and

00:38:07.390 --> 00:38:10.850
"Can be signed by" "Must be signed
by Apple." As a matter of fact,

00:38:10.850 --> 00:38:13.860
you know,
if you're talking about Apple's mail.app,

00:38:13.860 --> 00:38:16.800
that's pretty much the
requirement you're going to use.

00:38:16.850 --> 00:38:19.800
"Must be called mail.app and must be
signed by Apple." Or if you prefer,

00:38:19.800 --> 00:38:23.340
"Apple must say that
this is called mail.app."

00:38:23.780 --> 00:38:26.540
Now,
what we've done is we've invented this

00:38:26.540 --> 00:38:30.390
thing called a code signing requirement,
or just requirement.

00:38:30.400 --> 00:38:36.990
And we've given it a generic
form that you can use using an

00:38:37.060 --> 00:38:40.990
API pretty much in all situations.

00:38:41.540 --> 00:38:44.810
There's a binary form,
which is just a binary blob with

00:38:44.980 --> 00:38:46.800
no pointers or anything inside.

00:38:46.870 --> 00:38:48.610
So you can store this anywhere you want.

00:38:48.820 --> 00:38:51.500
You can stick it in the database,
put it in your own data structures,

00:38:51.550 --> 00:38:55.050
you know, wrap a CFData or NSData around
it and stick it in a dictionary.

00:38:55.220 --> 00:38:57.560
We don't care,
just as long as you keep that

00:38:57.560 --> 00:39:01.060
blob from being modified until
you feed it back into the API.

00:39:01.200 --> 00:39:07.000
There's a text form for it, which,
as you'd expect, is a little bit geekish.

00:39:07.000 --> 00:39:08.800
It's a little programming
language of sorts,

00:39:08.800 --> 00:39:10.640
a really simple,
trivial programming language.

00:39:10.700 --> 00:39:13.940
And, you know,
you can convert between the two,

00:39:13.940 --> 00:39:14.730
of course.

00:39:16.950 --> 00:39:19.370
So, remember this picture?

00:39:19.620 --> 00:39:21.580
Let's go through it again,
but this time let's talk

00:39:21.580 --> 00:39:23.200
about what requirements are.

00:39:23.330 --> 00:39:26.800
So we have the signed code
on the end user system,

00:39:27.070 --> 00:39:33.270
and there is a way to derive
requirements from the code.

00:39:33.300 --> 00:39:36.800
I'll talk a little bit
later about how this works.

00:39:36.800 --> 00:39:38.800
It's called the designated requirement.

00:39:38.800 --> 00:39:42.560
If you happen to want to derive
a requirement from the code

00:39:42.560 --> 00:39:44.800
back home where you made it,
that's fine too.

00:39:44.800 --> 00:39:47.350
Remember, it's the same code,
so you'll get the same

00:39:47.360 --> 00:39:51.350
requirement out of it anyway.

00:39:51.780 --> 00:39:54.690
Usually,
you want to store these somewhere

00:39:54.700 --> 00:39:59.390
in some configuration database,
in some preferences file,

00:39:59.390 --> 00:40:00.950
configuration file of some sort.

00:40:01.030 --> 00:40:03.700
And as I said, you're supposed to store
it as a binary blob,

00:40:03.760 --> 00:40:06.820
so it doesn't really
matter how you do that.

00:40:06.910 --> 00:40:10.680
NSData, database entries, we don't care.

00:40:10.890 --> 00:40:13.580
Turn a requirement into a binary blob,
store it anywhere you want,

00:40:13.800 --> 00:40:17.680
get it back when you need it,
turn it back into an API type,

00:40:17.680 --> 00:40:19.180
and off you go.

00:40:19.520 --> 00:40:23.390
And, well, the code gets run,
as it always does,

00:40:23.410 --> 00:40:26.970
and I sort of half cheated,
because when you are actually

00:40:26.970 --> 00:40:31.550
feeding it to the verification API,
usually you also feed a requirement in.

00:40:31.560 --> 00:40:38.110
What you are verifying then is,
as before, that the identity of the

00:40:38.120 --> 00:40:42.400
running code is still intact,
that it hasn't been violated in some way,

00:40:42.400 --> 00:40:47.740
but also that the requirements that
you pass to the API are satisfied.

00:40:47.740 --> 00:40:52.440
So, you know, the difference is that if
there weren't any requirements,

00:40:52.440 --> 00:40:56.740
then feeding, say,
a running Mail.app to the verification

00:40:56.740 --> 00:41:00.220
machinery would just verify that
it's a properly signed application,

00:41:00.220 --> 00:41:01.950
which you could make.

00:41:02.040 --> 00:41:05.240
You could call it Mail.app,
nobody would know,

00:41:05.360 --> 00:41:09.630
but if you add a requirement that says,
"Must be signed by Apple,"

00:41:09.630 --> 00:41:13.900
and it's called Mail.app,
then now you can't fake it anymore,

00:41:13.900 --> 00:41:15.680
because Apple won't give
you their signing key,

00:41:15.680 --> 00:41:16.080
I hope.

00:41:16.310 --> 00:41:17.760
I hope.

00:41:18.000 --> 00:41:23.850
Outcome,
which now can include "doesn't satisfy

00:41:23.850 --> 00:41:23.850
requirements", and there you go.

00:41:24.850 --> 00:41:29.540
Just to give you sort of an
overview of what you can do

00:41:29.540 --> 00:41:33.740
with the requirements language,
the most important one is

00:41:33.740 --> 00:41:37.690
constraints on the signing chain,
the certificate chain.

00:41:37.700 --> 00:41:41.820
And most of the time what you
do is you constrain the anchor

00:41:41.820 --> 00:41:45.790
of the certificate chain,
which is essentially a constraint on

00:41:45.870 --> 00:41:52.700
the authority that built the digital
identity that ended up signing this.

00:41:52.700 --> 00:41:54.610
There's a special one for Apple,
of course.

00:41:54.700 --> 00:41:55.700
Hey, we're Apple.

00:41:55.700 --> 00:42:01.700
But any certificate can be expressed
in the requirement language internally.

00:42:01.700 --> 00:42:03.700
It's stored as a hash of the certificate.

00:42:03.700 --> 00:42:07.060
So if you made your own,
it'll just end up in there as a

00:42:07.060 --> 00:42:09.530
hash of the certificate authority.

00:42:09.700 --> 00:42:11.170
Identifier.

00:42:11.260 --> 00:42:17.400
I didn't talk about this before,
but when CodeSign goes off and

00:42:17.490 --> 00:42:22.990
builds the code signature data,
it embeds as an identifier

00:42:23.070 --> 00:42:25.700
string in the signature data.

00:42:25.700 --> 00:42:30.700
This identifier string is by default
derived from the bundle identifiers.

00:42:30.700 --> 00:42:34.700
So if you are following the rules and
you're making an application bundle

00:42:34.700 --> 00:42:38.560
or a plug-in bundle or something,
then you'll automatically

00:42:38.560 --> 00:42:43.700
get something reasonable like
com.yourcompanyname.something.

00:42:43.700 --> 00:42:47.110
If you are signing tools,
by default what you'll

00:42:47.110 --> 00:42:48.700
get is the file name,
which is usually not what you want.

00:42:48.700 --> 00:42:53.550
And there is an option to CodeSign
to make up your own identifier,

00:42:53.710 --> 00:42:56.700
com.yourcompany.whateveryouwant,
and feed that in.

00:42:56.700 --> 00:43:02.540
So the identifier is the other
element of typical code constraints.

00:43:02.700 --> 00:43:08.700
As I said, signed by Apple,
and identifier is com.apple.mail,

00:43:08.800 --> 00:43:13.700
would be the canonical code signing
constraint for the mail application.

00:43:13.700 --> 00:43:16.700
Or in your case, it would be signing
anchor is your anchor,

00:43:16.700 --> 00:43:19.690
and name is whatever you said it is.

00:43:19.700 --> 00:43:25.700
You can check arbitrary contents of
the Info.plist for anything you want,

00:43:25.740 --> 00:43:29.840
either something that's
always in the Info.plist,

00:43:29.840 --> 00:43:33.700
like the NSBundle identifier,
CFBundle identifier these days,

00:43:33.700 --> 00:43:37.650
or something that you decide
to add to your Info.plist.

00:43:37.700 --> 00:43:39.500
And as a matter of fact,
that's how application

00:43:39.560 --> 00:43:40.700
groups are implemented.

00:43:40.700 --> 00:43:44.700
If you remember what I did
editing the Info.plist,

00:43:44.700 --> 00:43:47.700
I just added an entry called,
application group,

00:43:47.700 --> 00:43:49.700
and said the value must be .mac.

00:43:49.700 --> 00:43:56.680
And that's all that you do when you
check for application group membership.

00:43:56.700 --> 00:43:59.900
You check that there's an
application group entry,

00:43:59.900 --> 00:44:02.200
and its value is .mac.

00:44:02.530 --> 00:44:07.170
And you can of course combine them with
logical operators like 'and'. We are

00:44:07.290 --> 00:44:14.800
going to add more elements to this
language and if you feel like there is

00:44:14.800 --> 00:44:18.390
one that you think would be really cool,
then let us know.

00:44:18.400 --> 00:44:23.390
Now is a good time because, well,
we're still defining this.

00:44:24.310 --> 00:44:31.650
So these are requirements that
typically the caller of an API imposes

00:44:31.760 --> 00:44:35.340
on running code by someone else.

00:44:35.380 --> 00:44:38.780
We tend to call them external
requirements because the guy who

00:44:38.860 --> 00:44:43.100
imposes the requirement is different
from the guy who made the application.

00:44:43.240 --> 00:44:46.690
It's you want to check somebody
else's application or somebody else

00:44:46.690 --> 00:44:48.730
is trying to check your application.

00:44:48.840 --> 00:44:52.720
Now there are situations where you,
the application maker,

00:44:52.810 --> 00:44:57.310
actually have requirements that
you want to embed in your code.

00:44:57.410 --> 00:45:01.620
A very typical example is if
you can't trust your libraries,

00:45:01.640 --> 00:45:03.140
who can you trust?

00:45:03.200 --> 00:45:06.390
So you may want to say,
"I really only want to be linked

00:45:06.430 --> 00:45:11.610
against genuine Apple libraries." Or,
"I think I should only

00:45:11.610 --> 00:45:16.300
load my own plugins,
the ones made by myself,

00:45:16.300 --> 00:45:18.570
because who knows what the
other ones will do to me."

00:45:21.160 --> 00:45:25.930
These are called internal requirements
because they are directly embedded

00:45:26.420 --> 00:45:28.540
in your code signing information.

00:45:28.560 --> 00:45:33.080
They are automatically sealed by
the same mechanism that seals the

00:45:33.120 --> 00:45:35.760
code and the info peelers and the
resources and everything else.

00:45:35.820 --> 00:45:38.590
If you have those,
you feed them as one of those

00:45:38.590 --> 00:45:42.700
optional arguments to the code
sign command and read the man page.

00:45:42.770 --> 00:45:44.420
That explains how you can do it.

00:45:46.490 --> 00:45:51.350
Another form of internal requirement
that's just sort of hovering here

00:45:51.350 --> 00:45:54.690
as a teaser is hosts and guests.

00:45:55.260 --> 00:45:57.520
Well, let me tell you that much.

00:45:57.560 --> 00:46:02.360
Remember how I said that code can be,
you know, not just executables,

00:46:02.360 --> 00:46:07.340
macho binaries, applications,
but it can be scripts, other stuff that's

00:46:07.440 --> 00:46:08.580
being run by other code?

00:46:08.640 --> 00:46:12.140
There is a part of the code
signing architecture is a model

00:46:12.140 --> 00:46:15.890
called the host and guest model,
where you're basically having one

00:46:16.110 --> 00:46:20.080
set of code running or interpreting
or supervising another set of code.

00:46:20.080 --> 00:46:23.710
The supervisor is called a host,
the code that's being

00:46:23.790 --> 00:46:25.440
supervised is a guest.

00:46:25.440 --> 00:46:33.680
This mechanism allows you, us, together,
to extend the notion of code dynamically.

00:46:34.090 --> 00:46:40.020
Anytime we want to add code as
defined by a particular interpreter

00:46:40.020 --> 00:46:45.600
to also be code signable,
all we have to do is add, we hope,

00:46:45.600 --> 00:46:48.880
a few little things to the
interpreter or supervisor.

00:46:48.880 --> 00:46:54.390
And the script becomes code signable,
and the entire machinery that I've

00:46:54.390 --> 00:46:57.600
described so far becomes available.

00:46:57.640 --> 00:47:03.390
Keychain items could directly be
linked not just to the interpreter,

00:47:03.390 --> 00:47:06.080
but to the interpreted code.

00:47:06.110 --> 00:47:10.290
And all the other applications
that use the code signing

00:47:10.350 --> 00:47:15.830
APIs automatically extend to now
be able to identify these scripts.

00:47:16.750 --> 00:47:20.100
Resources don't get handled
by internal requirements.

00:47:20.100 --> 00:47:25.330
Resources are directly sealed
with the signing identity that

00:47:25.330 --> 00:47:27.970
signs the rest of the code,
because generally you don't

00:47:27.970 --> 00:47:33.600
want to be able to dynamically
change your resources on the fly.

00:47:33.670 --> 00:47:36.940
Besides,
it's a heck of a lot more efficient.

00:47:38.680 --> 00:47:41.680
And there's this very,
very special requirement that we

00:47:41.810 --> 00:47:44.650
call the designated requirement.

00:47:44.850 --> 00:47:50.870
One of the most common gestures
in practice is the user pointing a

00:47:50.870 --> 00:47:54.510
program at something on disk and say,
"That program there." Now,

00:47:54.510 --> 00:47:57.800
if you're thinking of, say,
parental controls where the

00:47:57.800 --> 00:48:00.780
user is browsing through the
application folder and going,

00:48:00.930 --> 00:48:02.080
"Oh, mail's okay.

00:48:02.280 --> 00:48:04.590
Safari is, eh, okay.

00:48:04.720 --> 00:48:09.380
Disk utility,
eh." So when the user points an

00:48:09.440 --> 00:48:15.900
application on disk and the API caller
wants to remember that application,

00:48:16.060 --> 00:48:19.830
that thing, that mail here,
what it needs is a code

00:48:19.830 --> 00:48:24.600
requirement that will later,
when passed to the verification API,

00:48:24.600 --> 00:48:28.980
can verify whether this is the same
thing that we're looking at right now.

00:48:29.060 --> 00:48:31.720
That's called a designated
requirement because from the

00:48:31.800 --> 00:48:35.170
point of view of the application,
it's designating this

00:48:35.240 --> 00:48:36.490
particular requirement as,
"This is how you can sign a

00:48:36.490 --> 00:48:38.080
program." how you can tell me again.

00:48:38.080 --> 00:48:39.800
This is how you can identify me again.

00:48:39.800 --> 00:48:41.570
This is me.

00:48:42.270 --> 00:48:45.370
And there is an API call,
SecCopy Designated Requirement

00:48:45.370 --> 00:48:52.980
happens to be what it's called,
that produces an API requirement

00:48:52.980 --> 00:48:56.700
object based on a code identifier.

00:48:56.700 --> 00:48:59.590
The system will make one up on the fly,
and the current form,

00:48:59.590 --> 00:49:02.750
which we don't promise
will stay the same exactly,

00:49:02.760 --> 00:49:06.570
is simply signed by the guy
who signed the application,

00:49:06.570 --> 00:49:10.080
and the identifier is what
the identifier of the code is.

00:49:10.080 --> 00:49:12.100
Which again,
in the case of Apple's Mail.App,

00:49:12.100 --> 00:49:17.640
leads us to the anchor is Apple,
and the identifier is com.apple.mail.

00:49:17.800 --> 00:49:21.470
If for some reason you don't like that,
and you want a different

00:49:21.510 --> 00:49:24.370
designated requirement,
you can just explicitly

00:49:24.370 --> 00:49:27.060
stick one into your code,
again as an optional

00:49:27.060 --> 00:49:30.510
argument to code sign,
and that's what will be returned.

00:49:32.950 --> 00:49:37.150
This is a really,
really short glimpse into

00:49:37.150 --> 00:49:38.680
what the API looks like.

00:49:38.820 --> 00:49:43.660
If you are desperately scrambling
through the system headers at this point,

00:49:43.660 --> 00:49:47.320
you won't find the code signing
headers in your WWDC preview

00:49:47.320 --> 00:49:53.740
because we haven't decided whether
to actually make them public yet.

00:49:53.740 --> 00:49:57.480
We are not sure how many of you will
actually want to call the API as

00:49:57.850 --> 00:49:59.860
opposed to just sign your applications.

00:49:59.880 --> 00:50:01.440
Don't misunderstand me here.

00:50:01.550 --> 00:50:04.100
You are all expected to
sign your applications,

00:50:04.100 --> 00:50:05.690
no exceptions.

00:50:05.710 --> 00:50:09.280
But some of you may actually want
to be on the other side of this gig.

00:50:09.280 --> 00:50:12.950
Some of you may want to
identify applications,

00:50:13.320 --> 00:50:16.360
remember the identity of applications.

00:50:16.370 --> 00:50:18.800
If you want to do that,
you need to call the API.

00:50:20.100 --> 00:51:20.600
[Transcript missing]

00:51:20.960 --> 00:51:24.540
We have, well,
let's get to the next slide.

00:51:24.890 --> 00:51:28.480
The APIs are very much
based on core foundation.

00:51:28.480 --> 00:51:31.830
As a matter of fact, our API handles are
core foundation objects.

00:51:31.830 --> 00:51:35.500
So you can use CF retain and
CF release and stick them in

00:51:35.500 --> 00:51:38.210
CFDictionary's and all of this stuff.

00:51:38.330 --> 00:51:41.140
And just, you know, they behave normal.

00:51:41.140 --> 00:51:43.750
They behave as by now you
should expect them to behave.

00:51:43.750 --> 00:51:46.930
The code is part of
the security framework.

00:51:47.170 --> 00:51:49.360
So you'd be linking
against security framework.

00:51:50.900 --> 00:51:55.770
We have three API object types,
a SecCodeRef for

00:51:55.960 --> 00:51:57.270
identifying running code.

00:51:57.400 --> 00:51:58.810
That's what you usually use.

00:51:58.890 --> 00:52:02.860
A SecStaticCodeRef is
for code on the disk,

00:52:03.050 --> 00:52:05.520
sort of like a bundle,
but includes things that

00:52:05.520 --> 00:52:08.200
aren't bundles like,
you know, tools and scripts and

00:52:08.200 --> 00:52:09.440
other single file things.

00:52:09.830 --> 00:52:12.660
And a SecRequirementRef,
which is a code requirement.

00:52:12.660 --> 00:52:15.900
And that's all I'm really going
to tell you about the API.

00:52:15.900 --> 00:52:20.260
So if you want to know more, go ask,
please.

00:52:23.290 --> 00:52:26.080
A couple of notes on what's in the seed.

00:52:26.350 --> 00:52:29.320
This is a big thing.

00:52:29.320 --> 00:52:31.560
We're still implementing it.

00:52:31.620 --> 00:52:32.700
We're not done implementing it.

00:52:32.700 --> 00:52:35.200
We probably won't be done
implementing it for a long time.

00:52:35.200 --> 00:52:41.200
But what you have on your
DVDs is something that works.

00:52:41.200 --> 00:52:42.200
It's self-consistent.

00:52:42.200 --> 00:52:47.100
I mean, that was a WWDC seed that
I was demonstrating on.

00:52:47.200 --> 00:52:52.650
The data format is going to change,
so something you sign today will not

00:52:52.650 --> 00:52:55.900
work to be verified when Leper chips.

00:52:56.200 --> 00:52:57.130
So don't worry about it.

00:52:57.210 --> 00:53:01.200
Just sign it again when you're
getting ready to get real about this.

00:53:01.200 --> 00:53:05.640
One little warning: If you are signing
individual single files,

00:53:05.730 --> 00:53:09.200
don't do this to files
that have resource forks,

00:53:09.200 --> 00:53:12.200
because right now we're sort
of stealing the resource fork

00:53:12.200 --> 00:53:13.200
to store the signing data.

00:53:13.200 --> 00:53:15.200
That's not a permanent condition.

00:53:15.200 --> 00:53:17.200
We're...

00:53:17.760 --> 00:53:19.110
That will be fixed soon.

00:53:19.290 --> 00:53:21.700
Just until then, don't do that.

00:53:21.700 --> 00:53:28.580
One difference to the final Leopard
version is that in the seed,

00:53:28.620 --> 00:53:32.090
and only in the seed,
you can use any digital identity that

00:53:32.090 --> 00:53:34.690
can sign anything at all to sign code.

00:53:34.710 --> 00:53:38.550
We're basically not checking the
marker that says "is valid for

00:53:38.550 --> 00:53:42.700
code signing." Primarily so you
have an easier time playing around.

00:53:42.700 --> 00:53:44.940
If you don't have a
code signing identity,

00:53:44.940 --> 00:53:46.830
well,
if you've got one for signing emails,

00:53:47.000 --> 00:53:47.700
it'll work.

00:53:50.930 --> 00:53:56.640
And one other caveat for reasons of
we're not quite done implementing it,

00:53:56.640 --> 00:53:59.440
if you're calling the
dynamic verification API,

00:53:59.440 --> 00:54:01.000
you have to be rude.

00:54:01.040 --> 00:54:02.430
Sorry, that'll get fixed.

00:54:02.480 --> 00:54:06.990
And the API is not there, officially.

00:54:07.930 --> 00:54:10.740
What will we have in Leopard?

00:54:10.960 --> 00:54:12.190
What you've seen, obviously.

00:54:12.300 --> 00:54:18.160
We already have the keychain machinery
hooked up to the code signing APIs,

00:54:18.300 --> 00:54:25.660
so keychain items created or added to an
application that is signed will remember

00:54:25.660 --> 00:54:29.480
the application by its code signature,
which means that you're going to

00:54:29.480 --> 00:54:33.530
lose all of those precious dialogues
you've been coming to expect.

00:54:33.560 --> 00:54:40.350
MCX and other parental control
features will use this,

00:54:40.430 --> 00:54:44.700
and they intend to restrict
what can launch based on this.

00:54:44.770 --> 00:54:49.280
So one of the better reasons to get
serious about signing your applications

00:54:49.280 --> 00:54:55.020
for Leopard is that you may otherwise
run into situations where grandma

00:54:55.020 --> 00:55:00.150
or the IT manager simply won't allow
anything to launch that isn't signed.

00:55:00.520 --> 00:55:02.560
So keep that in mind.

00:55:02.560 --> 00:55:08.720
There's also a firewall feature that
assigns essentially port configurations

00:55:08.840 --> 00:55:11.080
based on an application's identity.

00:55:11.290 --> 00:55:16.520
That too is probably going to be much
more painful if you are not signed.

00:55:17.940 --> 00:55:21.170
Recognizing code, either your own code or
somebody else's code,

00:55:21.270 --> 00:55:22.840
that's the other side of the game.

00:55:22.840 --> 00:55:24.780
That's where you would
be calling the API.

00:55:25.190 --> 00:55:29.740
As I said,
it's not currently decided whether

00:55:29.740 --> 00:55:34.250
the API will be officially released
as an API for Leopard or not.

00:55:34.350 --> 00:55:39.380
If you're interested,
talk to your developer evangelist.

00:55:39.380 --> 00:55:41.450
Hi, Craig.

00:55:43.110 --> 00:55:46.040
So what do you do now?

00:55:46.340 --> 00:55:51.360
Well, let me tell you one last time,
make sure your code is immutable.

00:55:51.360 --> 00:55:54.430
If your code doesn't work right,
if it's stuck in a read-only

00:55:54.430 --> 00:55:58.810
disk image or on a CD-ROM,
then it's not right.

00:55:58.910 --> 00:55:59.590
Fix it.

00:55:59.590 --> 00:56:01.300
And that's not just for code signing.

00:56:01.400 --> 00:56:05.960
There is a raftload of other
applications that don't take easily and

00:56:05.960 --> 00:56:08.990
happily to application self-modifying.

00:56:11.050 --> 00:56:14.000
I'm not the first one to tell you,
I'm sure you've heard it before,

00:56:14.070 --> 00:56:17.340
if you're still sort of kind
of dragging around and going,

00:56:17.340 --> 00:56:20.940
"Yeah, we'll get around to it,
maybe next year," that would be a

00:56:20.940 --> 00:56:23.510
really good time to get around to it.

00:56:24.530 --> 00:56:28.210
And in particular, configurations,
preferences,

00:56:28.290 --> 00:56:33.640
and other configuration data really
has well-defined good places to go.

00:56:33.640 --> 00:56:36.200
Just, you know,
read the good documentation.

00:56:36.200 --> 00:56:37.400
It'll tell you where to put them.

00:56:37.400 --> 00:56:40.940
There are even functions all over
the place in Core Foundation and

00:56:40.940 --> 00:56:44.270
in Cocoa that make it very easy
to put them in the right spot.

00:56:44.410 --> 00:56:47.050
So please do.

00:56:47.880 --> 00:56:52.750
If you feel like it,
make yourself a digital identity.

00:56:52.840 --> 00:56:56.970
Go around, sign your programs, and,
you know, just have fun.

00:56:57.300 --> 00:57:01.320
A signed program shouldn't behave any
different from an unsigned program,

00:57:01.320 --> 00:57:04.370
except when it's making keychain calls,
and it should behave somewhat

00:57:04.480 --> 00:57:06.800
better than an unsigned program.

00:57:06.890 --> 00:57:10.290
So, in particular,
if you are calling the keychain APIs,

00:57:10.380 --> 00:57:13.160
go sign your programs and see
if something weird happens.

00:57:13.160 --> 00:57:15.510
And I'm not talking
about missing dialogues.

00:57:15.570 --> 00:57:17.560
I'm talking about stuff
that isn't working.

00:57:17.620 --> 00:57:18.670
Let us know.

00:57:18.720 --> 00:57:20.220
You know, it's new.

00:57:20.530 --> 00:57:24.990
And absolutely do plan to sign
your code in the Leopard timeframe.

00:57:25.210 --> 00:57:26.730
There's no big bang here.

00:57:26.860 --> 00:57:30.290
We're going to let you know in the
release notes of some developer

00:57:30.290 --> 00:57:32.420
seed when the former change happens.

00:57:32.580 --> 00:57:35.140
After that,
you can go off and ship signed

00:57:35.140 --> 00:57:39.930
applications before Leopard ships,
and Tiger just won't notice.

00:57:39.980 --> 00:57:43.400
It'll ignore the signatures,
and it's a little bit bigger.

00:57:43.560 --> 00:57:45.470
It's about half a percent bigger.

00:57:45.600 --> 00:57:49.440
But there's no reason why you have to
wait until Leopard's in the stores and

00:57:49.510 --> 00:57:53.760
people salivate before you can actually
go off and sign your applications.

00:57:53.870 --> 00:57:56.650
And, well,
let me tell you that one again.

00:57:56.730 --> 00:58:00.380
If you are a medium or large-sized
company with departments

00:58:00.380 --> 00:58:03.940
that have responsibilities,
then you probably want to find

00:58:03.940 --> 00:58:07.200
out what department has the
responsibility for digital identities

00:58:07.420 --> 00:58:12.080
and tell them that they need
to make a decision here or there.

00:58:12.140 --> 00:58:15.380
Because they'll probably go into kind
of a shell-shocked state for a moment.

00:58:15.380 --> 00:58:18.850
And then they'll ask
you a lot of questions.

00:58:19.110 --> 00:58:22.020
And then time passes,
and then eventually you'll

00:58:22.020 --> 00:58:23.730
get your signing identity.

00:58:25.610 --> 00:58:27.740
That's Leopard.

00:58:27.740 --> 00:58:29.990
This is a big feature.

00:58:30.040 --> 00:58:31.930
It's a really big feature.

00:58:31.990 --> 00:58:34.740
It's one of those features we
could never do if we'd had to

00:58:34.740 --> 00:58:38.360
get it done in one release,
so we won't.

00:58:38.570 --> 00:58:41.840
What are we planning to do going forward?

00:58:41.940 --> 00:58:45.730
What's sort of the bigger idea here?

00:58:46.400 --> 00:58:50.300
Again, we're trying to extend the
notion of code to everything that

00:58:50.470 --> 00:58:52.180
reasonably could be considered code.

00:58:52.180 --> 00:58:54.290
And it's a wavy line,
it's a blurred line.

00:58:54.310 --> 00:58:58.490
Is an Emacs initialization file code?

00:58:58.750 --> 00:59:01.260
Turns out yes,
because it's a Lisp interpreter.

00:59:01.300 --> 00:59:07.300
Is your application's configuration file,
is your application's preference code?

00:59:07.300 --> 00:59:09.300
Probably not, but what do I know?

00:59:09.300 --> 00:59:10.280
It's your application.

00:59:10.300 --> 00:59:12.550
If it happens to have a
language interpreter in it,

00:59:12.580 --> 00:59:13.220
maybe it is.

00:59:13.300 --> 00:59:20.790
But what we will do is push that
notion of code outwards and include

00:59:20.790 --> 00:59:27.240
more and more different kinds of code
as the requirements are coming up.

00:59:27.410 --> 00:59:30.290
Obviously,
the ones that are bigger security holes

00:59:30.290 --> 00:59:34.300
and the ones that are more interesting
will get their codeness first.

00:59:34.300 --> 00:59:37.900
And maybe others, you know,
will take five years,

00:59:38.170 --> 00:59:41.400
but we're definitely
going in that direction.

00:59:43.260 --> 00:59:46.400
Crunchy shell and chewy inside, yeah.

00:59:46.740 --> 00:59:50.220
Traditionally, security has been done
with crunchy shells.

00:59:50.360 --> 00:59:55.180
You put sort of a layer out around your
code and you defend yourself vigorously

00:59:55.180 --> 00:59:57.240
against the evil that comes through.

00:59:57.240 --> 00:59:59.560
You check all of your
arguments at the APIs.

00:59:59.560 --> 01:00:03.120
And then in the rest of your code,
you sort of assume that it's OK,

01:00:03.120 --> 01:00:06.560
because it went through
the crunchy shell intact.

01:00:06.630 --> 01:00:10.500
And that works decently well.

01:00:10.500 --> 01:00:13.600
It works better than not checking at all,
obviously.

01:00:13.630 --> 01:00:17.180
But it means that you only
need to get one hole in the

01:00:17.180 --> 01:00:19.670
shell and then in the inside,
and ooh,

01:00:19.790 --> 01:00:23.310
I can do whatever I want in here.

01:00:23.660 --> 01:00:31.630
We'd like, going forward,
to instead have program systems be

01:00:31.630 --> 01:00:37.660
sort of groups of subsystems that
actually identify and defend themselves,

01:00:37.660 --> 01:00:41.740
not just from the evil outside,
but also from each other.

01:00:41.810 --> 01:00:47.620
So the chewy inside means that once
you've actually intruded successfully

01:00:47.740 --> 01:00:52.090
into some piece of the whole puzzle,
you don't automatically just bounce

01:00:52.130 --> 01:00:54.980
around and take the rest of them,
because there's multiple

01:00:54.980 --> 01:00:58.180
sort of membranes between the
different pieces of the system.

01:00:58.180 --> 01:01:03.490
And code signing actually helps you
in that modifications of one piece can

01:01:03.490 --> 01:01:05.920
be detected by the next piece over.

01:01:06.070 --> 01:01:08.580
So the classic attack of, great,
I'm inside.

01:01:08.580 --> 01:01:10.460
I'm going to buffer overflow,
and I'm going to modify,

01:01:10.460 --> 01:01:11.960
and I'm going to modify the code,
and it'll just do something

01:01:12.000 --> 01:01:15.100
completely different.

01:01:15.100 --> 01:01:17.210
That'll be a bit harder.

01:01:17.300 --> 01:02:26.700
[Transcript missing]

01:02:27.290 --> 01:02:29.000
There's always more information.

01:02:29.110 --> 01:02:30.060
Here's Craig.

01:02:30.160 --> 01:02:33.710
He's waving his hand at me and
telling me that I'm slightly

01:02:33.710 --> 01:02:36.790
exceeding my allotted time.

01:02:37.810 --> 01:02:41.020
In case you're wondering what those
code signing certificates are,

01:02:41.140 --> 01:02:44.740
RFC 2459 explains it to
you in excruciating detail.

01:02:45.690 --> 01:02:53.440
There is one URL, the second one here,
that explains how you can put info.plists

01:02:53.440 --> 01:02:55.600
into your single file executables.

01:02:55.600 --> 01:02:57.870
In case you didn't know that,
you can do that.

01:02:58.110 --> 01:02:58.790
Yes, you can.

01:02:58.900 --> 01:03:03.340
And since code signing is based on
things found in your Info.plist,

01:03:03.440 --> 01:03:05.750
you may want to do that,
even if you don't right now.
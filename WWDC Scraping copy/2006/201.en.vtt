WEBVTT

00:00:10.780 --> 00:00:13.000
Hello and welcome to the last
session of the day where we'll

00:00:13.000 --> 00:00:15.910
be talking about advanced image
handling with Image I/O Framework.

00:00:16.070 --> 00:00:19.550
And just a reminder,
just because the slide up here says

00:00:19.550 --> 00:00:23.500
to refrain from taking pictures,
that just refers to the presentation.

00:00:23.580 --> 00:00:25.440
Other than that,
we really want you to take pictures

00:00:25.520 --> 00:00:28.400
because we have some great imaging
in our system and we want to make

00:00:28.400 --> 00:00:30.270
sure you take advantage of it.

00:00:30.360 --> 00:00:32.000
So, first of all,
my name is David Hayward.

00:00:32.000 --> 00:00:34.630
I'm an engineer and manager
in the graphics and imaging

00:00:34.630 --> 00:00:38.500
group at Apple and I work on
Image I/O and RAW imaging as well.

00:00:38.550 --> 00:00:40.350
And we have a lot to talk about today.

00:00:40.470 --> 00:00:44.310
We'll be giving an architectural
overview of image handling in the system,

00:00:44.480 --> 00:00:47.490
talking about opening images,
displaying images,

00:00:47.600 --> 00:00:49.500
adjusting RAW images in particular.

00:00:49.500 --> 00:00:52.280
There's lots of exciting new
features that we have there.

00:00:52.430 --> 00:00:55.050
And last but not least,
you've got to save your work,

00:00:55.050 --> 00:00:56.200
so saving images.

00:00:56.900 --> 00:00:59.700
So first off, the architectural overview.

00:00:59.780 --> 00:01:04.000
When we first added Image I/O Framework
in Tiger in the last release,

00:01:04.050 --> 00:01:06.070
we had several key features
we wanted to achieve,

00:01:06.160 --> 00:01:07.740
and these are still true today.

00:01:07.800 --> 00:01:10.390
We wanted to be able to
write many file formats,

00:01:10.390 --> 00:01:13.090
read many file formats,
support reading and

00:01:13.090 --> 00:01:16.790
writing of key metadata,
support automatic color management

00:01:16.790 --> 00:01:18.680
through ICC profiles and the like.

00:01:18.800 --> 00:01:21.370
We also want to support
processing RAW images,

00:01:21.370 --> 00:01:24.390
which is an emerging field that
has all sorts of interesting

00:01:24.610 --> 00:01:26.800
ramifications on image processing.

00:01:26.800 --> 00:01:30.460
Also, we wanted to be able to support
other features such as incremental

00:01:30.460 --> 00:01:34.610
loading for web browsers and
advanced image formats such as

00:01:34.610 --> 00:01:37.820
floating point pixel file formats.

00:01:38.300 --> 00:01:41.200
One of the first questions people
ask me about Image I/O is often,

00:01:41.200 --> 00:01:44.000
"Well,
what file formats do you support?" Well,

00:01:44.000 --> 00:01:47.170
we support all the common web
standard file formats such as TIFF,

00:01:47.170 --> 00:01:50.200
JPEG, PING, GIF, JPEG 2000.

00:01:50.240 --> 00:01:54.200
We actually have a new version of
JPEG 2000 in the seed that you have.

00:01:54.460 --> 00:01:57.190
Also, we support several
advanced floating-point,

00:01:57.250 --> 00:01:59.960
high-dynamic range file
formats such as OpenEXR,

00:02:00.280 --> 00:02:03.140
Radiance,
and varieties of TIFFs such as FloatTIFF,

00:02:03.180 --> 00:02:06.190
LogLuvTIFF, and PixartTIFF encodings.

00:02:06.200 --> 00:02:09.200
And of course, we support a whole bunch
of RAW file formats,

00:02:09.200 --> 00:02:13.200
and this is something we've been spending
a lot of time on in the last year or so,

00:02:13.200 --> 00:02:16.120
from a wide variety of camera vendors.

00:02:16.200 --> 00:02:22.580
There's also a wide variety of legacy
file formats that we all use frequently,

00:02:22.580 --> 00:02:28.200
which is BMP formats,
Photoshop documents, QTIF, you name it.

00:02:28.200 --> 00:02:32.270
And in the subject of metadata,
there's a wide variety of metadata

00:02:32.270 --> 00:02:34.200
standards that are in wide use.

00:02:34.220 --> 00:02:40.250
And we support many of those,
such as EXIF, IPTC, GPS metadata,

00:02:40.250 --> 00:02:43.670
and some vendor-specific maker notes.

00:02:44.300 --> 00:02:45.580
And of course,
this is something that's going to

00:02:45.640 --> 00:02:47.670
be continuing to grow in the future,
especially in the area

00:02:47.670 --> 00:02:48.610
of RAW file formats.

00:02:48.640 --> 00:02:52.420
We've been adding support in every
major release and also a lot of

00:02:52.420 --> 00:02:54.370
the software updates as well.

00:02:55.180 --> 00:02:56.910
So how does all this fit
into the overall system?

00:02:57.000 --> 00:03:00.860
Well, first we start with wherever
possible open source implementations,

00:03:00.930 --> 00:03:03.610
such as libTIFF and libJPEG and libPNG.

00:03:03.890 --> 00:03:05.860
Other file formats we
have our own code for.

00:03:05.980 --> 00:03:10.190
And all of these file formats
we wrap in an API we refer to

00:03:10.190 --> 00:03:12.630
as the Image I/O Framework.

00:03:12.870 --> 00:03:15.480
And this allows your application
to have a single common interface

00:03:15.480 --> 00:03:19.940
for reading and writing file
formats across all these varieties.

00:03:20.050 --> 00:03:22.370
These are built on the
foundation of Darwin,

00:03:22.570 --> 00:03:27.880
and on top of the Image I/O layer,
we have higher-level graphics APIs,

00:03:27.880 --> 00:03:31.430
such as Core Image and Quartz,
which make use of Image I/O.

00:03:31.490 --> 00:03:34.850
Above that in the stack,
we have Carbon and Cocoa frameworks,

00:03:34.930 --> 00:03:37.560
which also make use of
Image I/O indirectly.

00:03:37.770 --> 00:03:40.520
And last but not least,
we have applications,

00:03:40.520 --> 00:03:44.880
many of which in the system are using
Image I/O either directly or implicitly

00:03:44.950 --> 00:03:47.340
through the higher-level frameworks.

00:03:47.490 --> 00:03:49.890
So as you might guess by this stack,
that there is a variety of

00:03:50.000 --> 00:03:53.200
APIs that we have on our
system for accessing Image I/O.

00:03:53.240 --> 00:03:59.500
And some of the key data types that keep
in mind are that a modern graphic system

00:03:59.500 --> 00:04:03.430
needs to have data types for color space,
a way of representing bitmap images,

00:04:03.590 --> 00:04:06.660
a way of representing individual
colors for vector artwork,

00:04:06.710 --> 00:04:08.900
and also a context of some sort.

00:04:08.940 --> 00:04:11.610
And of course,
we have a whole stack of APIs,

00:04:11.780 --> 00:04:15.260
and your choice as to
which one you want to use,

00:04:15.310 --> 00:04:17.670
all of these have these basic constructs.

00:04:17.930 --> 00:04:21.220
What we'll be talking about
today are the core image and

00:04:21.600 --> 00:04:23.620
quartz data types in particular.

00:04:23.650 --> 00:04:26.800
I should mention that in many cases,
there are very easy ways of

00:04:26.800 --> 00:04:28.900
converting between these data types.

00:04:28.900 --> 00:04:31.710
We'll talk more about that later.

00:04:32.620 --> 00:04:36.360
So before I go into more detail about
Image I/O and how it's implemented,

00:04:36.360 --> 00:04:40.600
let's just briefly get a discussion of
what's actually in a typical image file.

00:04:40.650 --> 00:04:44.210
Well, the key requirements for
an image are its geometry,

00:04:44.260 --> 00:04:44.540
i.e.

00:04:44.540 --> 00:04:47.960
its height and its width and its pixel
depth and other information like that,

00:04:48.110 --> 00:04:50.280
its color space,
which describes the color

00:04:50.330 --> 00:04:54.600
characteristics of the pixel values,
and the actual pixel data.

00:04:54.650 --> 00:04:58.270
Then there's some optional information,
which is nice to have where possible,

00:04:58.270 --> 00:05:01.420
which is embedded
thumbnails and metadata.

00:05:02.030 --> 00:05:04.680
Some file formats also support
multiple images per file,

00:05:04.810 --> 00:05:06.460
and that's important to keep in mind.

00:05:06.750 --> 00:05:10.380
Formats such as GIF and
TIFF come to mind.

00:05:10.660 --> 00:05:12.780
Because there can be
multiple images in a file,

00:05:12.920 --> 00:05:16.500
there are some properties that actually
transcend any individual image.

00:05:16.770 --> 00:05:19.670
These are properties such as
the actual file format itself

00:05:19.980 --> 00:05:21.600
and other file properties.

00:05:21.600 --> 00:05:24.890
For example,
GIF has some properties that apply

00:05:24.890 --> 00:05:29.150
to the entire animation rather
than to any one single frame.

00:05:29.880 --> 00:05:32.430
So how do we expose this
in the Image I/O API?

00:05:32.560 --> 00:05:36.250
Well, the file type of the file is
represented as a CFStringRef,

00:05:36.270 --> 00:05:38.160
which is a UTI.

00:05:38.200 --> 00:05:41.740
The file properties is a dictionary,
CFDictionary.

00:05:41.790 --> 00:05:44.970
The image attributes,
such as the geometry, color space,

00:05:44.990 --> 00:05:49.220
and pixel data, are well encapsulated by
the CGImageRef description.

00:05:49.310 --> 00:05:52.500
It can describe a wide
variety of pixel formats.

00:05:52.560 --> 00:05:55.300
Thumbnails and others,
optional CGImageRef.

00:05:55.330 --> 00:05:58.080
And the metadata is, again, a dictionary.

00:05:59.240 --> 00:06:02.100
So those are the basics of
what makes up an image and

00:06:02.100 --> 00:06:03.560
the basic ideas of Image I/O.

00:06:03.560 --> 00:06:07.350
Let's talk first about how to
open images with Image I/O.

00:06:08.230 --> 00:06:12.240
So the basic steps involved with reading
an image involve parsing the file and

00:06:12.240 --> 00:06:17.090
getting key information from that file,
such as decompressing the pixel data,

00:06:17.130 --> 00:06:19.710
determining what the color
space of that file is,

00:06:19.710 --> 00:06:21.470
and extracting the metadata.

00:06:22.390 --> 00:06:26.030
So this can be provided via a
small set of APIs in Image I/O.

00:06:26.060 --> 00:06:27.380
It's very simple.

00:06:27.450 --> 00:06:33.500
First off is you should get a list of
what file formats Image I/O can read.

00:06:33.520 --> 00:06:37.260
This is provided by returning
a UTI array using the

00:06:37.260 --> 00:06:41.460
API CG Image Source Copy Type Identifiers
.

00:06:41.460 --> 00:06:43.310
And this is a good thing
for your application to take

00:06:43.310 --> 00:06:45.810
advantage of because we are,
as I mentioned earlier,

00:06:45.810 --> 00:06:48.000
constantly adding new file formats.

00:06:48.000 --> 00:06:51.200
And if you make use of this API,
your application can grow to use

00:06:51.200 --> 00:06:53.240
those formats without having to rev.

00:06:53.240 --> 00:06:56.160
I should also mention at this point
that in the seed that you have,

00:06:56.160 --> 00:06:58.160
some of the file formats
are not supported,

00:06:58.170 --> 00:07:00.710
especially the legacy formats,
are not supported on 64,

00:07:00.710 --> 00:07:03.720
just a few of them, 64-bit.

00:07:03.720 --> 00:07:06.860
So again, it's a good idea to call this
API because it will tell you

00:07:06.860 --> 00:07:10.810
what formats are supported under
your current instruction set.

00:07:12.180 --> 00:07:13.990
Once you know what kind
of files you can open,

00:07:14.000 --> 00:07:16.050
you can open a file
using CG Image Source,

00:07:16.110 --> 00:07:19.540
Create with URL, or Create with Data,
or Create with Data Provider.

00:07:19.670 --> 00:07:23.040
This returns an opaque object from
which you can get critical information

00:07:23.040 --> 00:07:26.830
such as the type of the file that the
image actually is and the number of

00:07:26.950 --> 00:07:29.820
images that are contained within it.

00:07:30.190 --> 00:07:32.440
Then for each image
within that image source,

00:07:32.530 --> 00:07:35.280
you can get the actual image
by calling CGImageSource,

00:07:35.510 --> 00:07:38.810
CreateImageAtIndex, get the metadata by
calling CGImageSource,

00:07:38.810 --> 00:07:41.140
CopyPropertiesAtIndex,
and you guessed it,

00:07:41.200 --> 00:07:44.260
you can get the thumbnail
by calling CGImageSource,

00:07:44.310 --> 00:07:46.540
CreateThumbnailAtIndex.

00:07:47.610 --> 00:07:49.670
So this is a minimal code
snippet that just shows how

00:07:49.670 --> 00:07:51.300
easy it is to use Image I/O.

00:07:51.480 --> 00:07:55.890
This function, the idea behind it is to,
given a URL, return a CG image ref.

00:07:56.030 --> 00:08:00.350
And all we do is, given that URL,
we call CG image source, create with URL.

00:08:00.600 --> 00:08:03.430
Then we call CG image source,
create image and index,

00:08:03.450 --> 00:08:04.900
passing in the index 0.

00:08:05.030 --> 00:08:05.540
That's it.

00:08:05.540 --> 00:08:07.330
It's very simple.

00:08:08.230 --> 00:08:11.740
One thing to be aware of, however,
is that file formats come

00:08:11.740 --> 00:08:14.680
in a variety of flavors,
and some file formats

00:08:14.800 --> 00:08:16.110
support only one pixel depth.

00:08:16.240 --> 00:08:19.580
For example,
JPEG is always eight bits per sample.

00:08:19.600 --> 00:08:22.240
Other file formats support
a variety of pixel depths,

00:08:22.400 --> 00:08:26.000
such as TIFF,
which can be arbitrarily depth.

00:08:26.060 --> 00:08:28.720
One thing to keep in
mind is that as a rule,

00:08:28.720 --> 00:08:33.790
Image I/O will return a CG image ref
with the same depth as the original file.

00:08:35.000 --> 00:08:37.970
However, in the case of high dynamic
range or floating point formats,

00:08:38.140 --> 00:08:40.080
things are slightly more complicated.

00:08:40.330 --> 00:08:42.820
In this case,
the data that's in the file is

00:08:42.820 --> 00:08:45.400
often specially encoded or packed.

00:08:45.570 --> 00:08:50.970
And the open source code that's available
to decompress that data often has several

00:08:51.000 --> 00:08:53.890
options for how to interpret that data.

00:08:54.040 --> 00:08:57.270
Often the data can either be
unpacked as floats or integers,

00:08:57.270 --> 00:09:01.800
and also with different depths,
either half floats or full floats,

00:09:01.900 --> 00:09:04.850
or 8-bit integers or 16-bit integers.

00:09:05.000 --> 00:09:10.130
Also, the data can be either returned as
extended range or tone compressed

00:09:10.130 --> 00:09:12.900
into the logical range of 0 to 1.

00:09:13.060 --> 00:09:17.630
So there's already a lot of options
for floating point images that we

00:09:17.640 --> 00:09:21.900
didn't have to deal with for some of
the more traditional file formats.

00:09:22.120 --> 00:09:26.100
And our choice with Image I/O was to
always return a CG image ref that's

00:09:26.100 --> 00:09:28.760
tone compressed into 16-bit images.

00:09:28.900 --> 00:09:33.900
This produces good results for
a wide variety of applications.

00:09:34.190 --> 00:09:35.550
However,
if your application wants to get direct

00:09:35.630 --> 00:09:39.870
access to the floating point data,
you can opt into this by request,

00:09:39.910 --> 00:09:41.890
and you can get extended range floats.

00:09:41.900 --> 00:09:45.900
This is a simple code snippet that
shows how easy it is to do this.

00:09:45.900 --> 00:09:47.890
Again, it's very similar to the
previous code snippet.

00:09:47.940 --> 00:09:51.130
The only difference is that we're
passing in an options dictionary to

00:09:51.130 --> 00:09:52.790
Image I/O to change the behavior.

00:09:52.970 --> 00:09:55.310
In this case,
we're passing an option dictionary

00:09:55.310 --> 00:09:56.860
that contains one key value.

00:09:56.930 --> 00:10:01.140
The CG image source should allow float,
and the Boolean true

00:10:01.140 --> 00:10:02.900
is the value for that.

00:10:02.900 --> 00:10:05.460
So if we want to get the image back,
we can test to see if it actually

00:10:05.460 --> 00:10:09.300
is float by calling cgimage,
get bitmap info, and seeing if the float

00:10:09.300 --> 00:10:10.900
attribute is set on it.

00:10:13.080 --> 00:10:16.680
So next I'd like to talk a
little bit more about metadata.

00:10:16.700 --> 00:10:19.590
When Image I/O returns metadata,
it returns it as a dictionary.

00:10:19.600 --> 00:10:22.930
And this dictionary contains,
at the root level of the dictionary,

00:10:22.930 --> 00:10:25.230
general properties,
which are common to a wide

00:10:25.230 --> 00:10:26.680
variety of file formats.

00:10:26.740 --> 00:10:30.860
These are properties such as height,
width, orientation, and color space.

00:10:30.870 --> 00:10:36.160
This provides easy access
for applications to get

00:10:36.160 --> 00:10:36.160
this general information.

00:10:36.550 --> 00:10:38.980
The metadata dictionary also
contains sub-dictionaries,

00:10:38.980 --> 00:10:41.070
however,
and these are sub-dictionaries for

00:10:41.100 --> 00:10:46.870
metadata file formats such as TIFF,
EXIF, IPTC, and GPS.

00:10:47.270 --> 00:10:50.090
And these are grouped
into sub-dictionaries.

00:10:50.530 --> 00:10:53.540
One thing we did when we designed
these dictionaries is we tried wherever

00:10:53.540 --> 00:10:57.600
possible to keep the keys and values in
these dictionaries as close as possible

00:10:57.600 --> 00:11:00.310
to what's actually in the specification.

00:11:00.400 --> 00:11:03.400
This means, for example,
when you get the TIFF properties,

00:11:03.400 --> 00:11:05.540
there'll be a property
called Resolution Unit,

00:11:05.540 --> 00:11:08.600
and the values for that
will be a number such as 1,

00:11:08.600 --> 00:11:11.370
2, or 3,
which is consistent with the TIFF spec.

00:11:11.400 --> 00:11:15.920
Or, in another little crazier example,
the compression value can be

00:11:15.920 --> 00:11:18.400
arbitrary values such as 1,
5,

00:11:18.400 --> 00:11:22.970
or even seemingly random numbers like 3,
2, 7, 7, 3.

00:11:23.210 --> 00:11:26.500
It is up to your application
or the client to localize the

00:11:26.500 --> 00:11:29.300
keys and the values as you
see fit in your application.

00:11:29.470 --> 00:11:32.540
For example,
your application might want to display

00:11:32.540 --> 00:11:37.010
the resolution unit in the more human
understandable values such as none,

00:11:37.010 --> 00:11:38.070
inch, or cm.

00:11:38.280 --> 00:11:42.370
Or in the case of compression,
in this example, no compression,

00:11:42.420 --> 00:11:45.360
LCW compression, or packed bits.

00:11:47.170 --> 00:11:49.280
So again,
here's a very simple code snippet

00:11:49.350 --> 00:11:52.300
for how to get metadata out
of an image using Image I/O.

00:11:52.300 --> 00:11:54.540
We can call CGImageSource
create with URL,

00:11:54.540 --> 00:11:55.560
as we did before.

00:11:55.800 --> 00:11:59.200
And now we call CGImageSource
copy properties at index.

00:11:59.230 --> 00:12:00.920
And this returns a dictionary.

00:12:00.950 --> 00:12:04.290
In this sample,
all we're doing is getting some of the

00:12:04.290 --> 00:12:08.650
general properties out of the file,
such as the property DPI width,

00:12:08.650 --> 00:12:10.920
DPI height, and orientation.

00:12:10.930 --> 00:12:13.260
These three properties are
actually critical for the

00:12:13.360 --> 00:12:14.680
proper display of your image.

00:12:14.680 --> 00:12:16.060
I'll talk more about that in a bit.

00:12:19.860 --> 00:12:22.860
Back to the subject of
thumbnails for a bit.

00:12:23.040 --> 00:12:26.600
Image I/O has some very flexible support
for providing thumbnails for images.

00:12:26.790 --> 00:12:29.960
And the reason we provided this is
that there's a wide variety of needs

00:12:29.960 --> 00:12:32.050
that applications have for thumbnails.

00:12:32.180 --> 00:12:34.630
Some applications want
something that's very quick.

00:12:34.770 --> 00:12:37.540
Other applications might want something
that's better quality for thumbnails.

00:12:37.580 --> 00:12:41.040
And there's no one right
answer for all applications.

00:12:41.120 --> 00:12:43.150
There's sort of a hierarchy
of needs for thumbnails.

00:12:43.350 --> 00:12:48.110
Sometimes all an application wants
is just a generic icon for the file.

00:12:48.290 --> 00:12:52.190
That's very fast, it's small size,
but it's not at all representative

00:12:52.190 --> 00:12:54.290
of the actual content in the file.

00:12:54.870 --> 00:12:57.170
In between,
there is some image file formats

00:12:57.230 --> 00:12:59.100
support embedded thumbnails.

00:12:59.130 --> 00:13:01.540
These are fast,
and typically it only requires

00:13:01.540 --> 00:13:05.500
reading the first fraction of the
file to find the embedded thumbnail.

00:13:05.560 --> 00:13:11.040
They're small size, which can be good,
typically 160 by 120 pixels.

00:13:11.100 --> 00:13:14.040
But they may look different
than the actual image content,

00:13:14.040 --> 00:13:15.980
so that's something to be aware of.

00:13:16.340 --> 00:13:20.710
Lastly, the best level of thumbnail is
to actually ask for a reduced

00:13:20.710 --> 00:13:23.780
representation of the full image.

00:13:24.540 --> 00:13:28.160
This may be slower than in
any of the previous methods,

00:13:28.160 --> 00:13:31.650
but they can be arbitrary size,
and they will look very

00:13:31.750 --> 00:13:33.160
close to the actual image.

00:13:33.310 --> 00:13:36.080
And when thumbnail-ing in this mode,
Image I/O takes whatever tricks

00:13:36.110 --> 00:13:40.040
are possible to try to return an
image that's sufficiently good

00:13:40.040 --> 00:13:42.510
quality for the size it's requested.

00:13:43.280 --> 00:13:47.900
So here's a short example for how
your application can get thumbnails.

00:13:48.080 --> 00:13:50.530
And in one call,
you can kind of get some of the

00:13:50.530 --> 00:13:52.860
best of both worlds in this example.

00:13:52.920 --> 00:13:57.870
We again create an image source with URL,
and we're passing in two key values.

00:13:58.120 --> 00:14:03.610
The first is the property CGImageSource
createThumbnailFromImageIfAbsent.

00:14:03.820 --> 00:14:06.570
What this means is that an image
will be returned quickly from the

00:14:06.570 --> 00:14:10.650
embedded thumbnail if it's present,
but if not, it will return it from

00:14:10.760 --> 00:14:11.910
the full-size image.

00:14:12.030 --> 00:14:16.250
So this is useful for
a lot of quick cases.

00:14:16.610 --> 00:14:20.890
Second, we specify that we want the image
to be no bigger than 160 pixels.

00:14:21.230 --> 00:14:24.300
Again, this is useful because a lot of
applications want to limit the size of

00:14:24.300 --> 00:14:26.340
their thumbnails to something reasonable.

00:14:26.400 --> 00:14:28.900
Once we create the option
dictionary with these two keys,

00:14:28.900 --> 00:14:32.690
we call CG Image Source Create Thumbnail
at index.

00:14:33.620 --> 00:14:36.600
So I'm going to give a quick
demo of this in practice.

00:14:36.680 --> 00:14:40.130
So if you've been to any
other graphic sessions here,

00:14:40.130 --> 00:14:46.140
there's been a lot of examples showing
arrays of images in thumbnail browsers.

00:14:46.340 --> 00:14:50.590
And one of the great features in
Leopard is ImageKit's new icon browser,

00:14:50.790 --> 00:14:53.300
which does such a great
job of doing thumbnails.

00:14:53.380 --> 00:14:57.100
It actually uses Image I/O to look
for the embedded thumbnails first,

00:14:57.100 --> 00:15:00.060
and then on a separate thread,
it brings in the higher quality images.

00:15:00.220 --> 00:15:01.720
It does a great job.

00:15:01.760 --> 00:15:04.800
But for purposes of demonstration
of how things work internally,

00:15:04.800 --> 00:15:08.780
it actually does too good a job,
because it all does it transparently.

00:15:09.020 --> 00:15:11.970
So what I'd like to have here is a
little sample application that can

00:15:11.970 --> 00:15:16.430
show the different levels of quality
of thumbnails with some control

00:15:16.620 --> 00:15:19.390
that's given to me via sliders.

00:15:19.480 --> 00:15:22.770
What I have here is a folder
of a whole bunch of images.

00:15:23.290 --> 00:15:25.540
And this application
is doing a lightweight,

00:15:25.550 --> 00:15:30.740
lazy loading of icons and showing some
basic metadata information as well.

00:15:31.100 --> 00:15:33.490
One thing we can do is
we can adjust the size,

00:15:33.490 --> 00:15:34.180
obviously.

00:15:34.420 --> 00:15:36.940
But this is just a very crude
representation of the file.

00:15:36.940 --> 00:15:40.800
This is just the generic icon,
which is very fast,

00:15:40.830 --> 00:15:43.400
but not very indicative of the content.

00:15:43.490 --> 00:15:46.960
So what we can do here is adjust
the quality of the thumbnail.

00:15:47.000 --> 00:15:49.580
And what you'll see here is I said
that I would like to use the

00:15:49.620 --> 00:15:51.500
embedded thumbnail if present.

00:15:51.540 --> 00:15:54.420
And what you'll see here is now
things look a little better.

00:15:54.530 --> 00:15:55.900
It's not the best resolution.

00:15:55.900 --> 00:15:59.610
You can see some pixelization
on this thumbnail.

00:15:59.870 --> 00:16:02.330
And you'll also see that
oftentimes with thumbnails,

00:16:02.330 --> 00:16:04.170
there's black bars at the top and bottom.

00:16:04.490 --> 00:16:06.450
So this is pretty good, and it's fast.

00:16:06.530 --> 00:16:09.830
You can see as we scroll
through the image,

00:16:09.860 --> 00:16:12.680
they peel in very quickly.

00:16:13.020 --> 00:16:15.340
It's not ideal.

00:16:15.340 --> 00:16:17.520
And so what this application also
does is allows you to turn it up

00:16:17.620 --> 00:16:21.690
to render a reduced representation
of the full-size image.

00:16:21.690 --> 00:16:26.790
And now you can see what's happened
here is as we go to larger sizes,

00:16:26.800 --> 00:16:29.900
we see the full quality of the image.

00:16:29.900 --> 00:16:32.010
And again,
things are pretty quick because

00:16:32.010 --> 00:16:34.900
we can take tricks wherever
possible to produce images.

00:16:35.100 --> 00:16:39.770
You can see here it's slightly blurry,
and when I let go,

00:16:39.770 --> 00:16:39.770
it'll come in a little sharper.

00:16:40.190 --> 00:16:41.680
So we used whatever tricks possible.

00:16:41.680 --> 00:16:44.480
In the case of JPEGs,
we can ask for reduced size JPEGs and

00:16:44.580 --> 00:16:47.900
reduce the computation considerably.

00:16:48.200 --> 00:16:52.170
Again, on the subject of metadata,
if I select one of these images,

00:16:52.170 --> 00:16:55.280
this view over here shows all
the metadata that's in that file.

00:16:55.350 --> 00:16:59.560
And this is a good illustration of the
hierarchical dictionaries that we return.

00:16:59.710 --> 00:17:02.050
These are all the general
properties such as height,

00:17:02.120 --> 00:17:07.580
width, orientation-- this one's
rotated-- and the DPI.

00:17:07.750 --> 00:17:11.630
And then we have sub-dictionaries
for all the separate subgroups

00:17:11.630 --> 00:17:15.800
of metadata such as EXIF,
TIFF properties,

00:17:15.920 --> 00:17:18.100
and some Canon Maker notes.

00:17:18.510 --> 00:17:20.400
In the code, this is very simple.

00:17:20.400 --> 00:17:23.830
This code is not yet on the CD,
but we'll make it available.

00:17:23.970 --> 00:17:27.500
In this function here,
we have a very simple function to get

00:17:27.590 --> 00:17:29.430
the embedded thumbnail of a given size.

00:17:29.460 --> 00:17:32.800
Again, all we're doing is calling
CG Image Source Create Thumbnail

00:17:32.920 --> 00:17:37.400
at index,
and we're passing in a couple properties.

00:17:37.400 --> 00:17:39.930
One is we're specifying the size
that we want it returned at.

00:17:39.960 --> 00:17:45.280
And also, we're saying we want the image
auto-rotated if possible.

00:17:45.500 --> 00:17:47.320
This is another nice
feature of Thumbnailing,

00:17:47.320 --> 00:17:49.720
which is if you pass in the
CG Image Source Create Thumbnail

00:17:49.720 --> 00:17:52.850
with Transform,
it'll automatically rotate the image

00:17:52.850 --> 00:17:55.130
so it looks the right orientation.

00:17:56.540 --> 00:18:00.670
The higher fidelity image that we return,
I refer to it as main image with size.

00:18:00.670 --> 00:18:02.600
And again, it's very similar.

00:18:02.650 --> 00:18:04.240
Again, we pass in an options dictionary.

00:18:04.240 --> 00:18:07.530
In this case,
we say that we want to pass in

00:18:07.530 --> 00:18:10.840
the property CG image source,
create thumbnail from image always.

00:18:10.840 --> 00:18:13.360
That's about it.

00:18:13.440 --> 00:18:16.230
So back to the slides.

00:18:19.650 --> 00:18:22.500
So now that we know how to open
images and get metadata from them,

00:18:22.500 --> 00:18:26.060
the next thing I'd like to talk
about is displaying images.

00:18:26.980 --> 00:18:29.640
So these are the general steps that
are involved with displaying an image.

00:18:29.640 --> 00:18:31.250
It is actually quite complex.

00:18:31.390 --> 00:18:34.520
It involves actions such
as color conversion,

00:18:34.560 --> 00:18:38.980
bit depth conversion, geometry mapping,
and then compositing on the existing

00:18:39.130 --> 00:18:41.680
background if transparency is available.

00:18:42.060 --> 00:18:44.790
The good thing is all of this
complex functionality is provided

00:18:44.800 --> 00:18:49.510
via a single API in Core Graphics,
which is CG Context Draw Image.

00:18:50.090 --> 00:18:55.040
Now, one of the things about CG Context
Draw Image is that it takes a CG image,

00:18:55.240 --> 00:19:00.800
but that doesn't mean Cocoa Apps can't
use this API or use CG images directly.

00:19:00.860 --> 00:19:04.760
It's possible from an NSViewDrawRack
method to get the CG context

00:19:04.890 --> 00:19:06.920
from the NSGraphics context.

00:19:07.080 --> 00:19:09.620
So this is a great thing because it
allows Cocoa applications like the

00:19:09.620 --> 00:19:14.600
one I just showed to directly call
CG image sources and get all the

00:19:14.700 --> 00:19:18.350
flexibility that's available to those.

00:19:19.710 --> 00:19:22.280
So here's a brief code snippet
that shows how we do this.

00:19:22.360 --> 00:19:23.770
We have a draw rec call.

00:19:23.890 --> 00:19:29.710
We get the current CG context by calling
NSGraphicsContextCurrentContextGraphicsP

00:19:29.710 --> 00:19:30.360
ort.

00:19:30.400 --> 00:19:32.660
The next thing we're doing
is we're getting the height

00:19:32.740 --> 00:19:35.560
and width of the image,
and then we're going to get an image

00:19:35.710 --> 00:19:37.860
transform for the current view.

00:19:37.860 --> 00:19:40.400
I'll talk a little bit
more about that later.

00:19:40.480 --> 00:19:44.520
We then concatenate that image transform,
which is a CG affine transform,

00:19:44.600 --> 00:19:49.230
to the current context,
and then we draw the image in the view.

00:19:50.320 --> 00:19:52.500
One of the things we really
don't want our users to see,

00:19:52.500 --> 00:19:55.160
however, is what we see here,
which is-- and we've all seen

00:19:55.270 --> 00:19:58.960
this before-- where the images
are not rotated correctly.

00:19:58.990 --> 00:20:02.530
And often this is the case because
the image has metadata in it

00:20:02.530 --> 00:20:05.950
that says it needs to be rotated,
but the application is not

00:20:06.030 --> 00:20:07.920
respecting that metadata.

00:20:08.340 --> 00:20:10.960
Similarly,
this is a slightly less common case.

00:20:11.010 --> 00:20:13.540
There are image formats
that have non-square pixels.

00:20:13.570 --> 00:20:17.200
Again, these formats have metadata that
say what the DPI and the vertical

00:20:17.200 --> 00:20:19.060
and horizontal direction are.

00:20:19.100 --> 00:20:21.830
But if your application
doesn't respect that metadata,

00:20:21.830 --> 00:20:23.950
then you won't get the image you expect.

00:20:24.030 --> 00:20:26.500
And that's bad for our users.

00:20:27.170 --> 00:20:30.240
So there's a very small amount
of code that you can write that

00:20:30.240 --> 00:20:34.380
will correctly create a CGA-fine
transform from the metadata.

00:20:34.390 --> 00:20:37.520
The three pieces of metadata that
are critical are the DPI and the

00:20:37.520 --> 00:20:40.920
horizontal and vertical direction,
and the orientation value.

00:20:40.930 --> 00:20:43.880
These orientation values
are values between 1 and 8,

00:20:43.890 --> 00:20:45.580
and they're defined in the TIFF spec.

00:20:45.580 --> 00:20:48.990
They're very hard to predict
what they actually mean.

00:20:49.130 --> 00:20:51.290
There's no rhyme or reason
to it as far as I can tell.

00:20:51.590 --> 00:20:55.820
But the key is that 1 means normal,
and 2 means flip horizontal,

00:20:55.820 --> 00:20:56.850
and so forth.

00:20:57.160 --> 00:21:02.910
And the idea is to convert these
values along with the DPI into a CTM.

00:21:03.070 --> 00:21:05.370
So this is a very handy function.

00:21:06.450 --> 00:21:08.920
There's a couple other advanced
techniques that I'd like to talk about

00:21:08.950 --> 00:21:11.460
as far as drawing images are concerned.

00:21:11.480 --> 00:21:14.350
One of the common questions I have is,
well, how do I just get the

00:21:14.390 --> 00:21:15.980
RGB data out of an image?

00:21:16.020 --> 00:21:19.410
And that's a little bit
tricky because in CG,

00:21:19.420 --> 00:21:22.980
CG image refs are opaque,
immutable types.

00:21:23.150 --> 00:21:26.200
So the way to get data out
of them is to actually render

00:21:26.200 --> 00:21:28.100
them into a bitmap context.

00:21:28.130 --> 00:21:31.950
This is actually a good thing because
it forces the application to decide,

00:21:32.060 --> 00:21:34.800
well, I don't just want RGB data,
but I want RGB data in

00:21:34.800 --> 00:21:36.300
a specific color space.

00:21:36.960 --> 00:21:40.030
So in this case, we create a color space.

00:21:40.260 --> 00:21:44.250
In this case, we are asking for a
generic RGB coordinates.

00:21:44.430 --> 00:21:48.060
We create a context with the
appropriate size and a buffer

00:21:48.060 --> 00:21:50.220
of data and that color space.

00:21:50.290 --> 00:21:56.190
And we call the CG context Draw Image to
draw the image into that context.

00:21:56.410 --> 00:22:00.510
So now once that draw is complete,
we can release some stuff and the data

00:22:00.540 --> 00:22:05.190
is now available for the application to
get the pixel data out of that image.

00:22:08.350 --> 00:22:12.400
Another common subject for a more
advanced rendering of images is

00:22:12.450 --> 00:22:16.290
what to deal with images that
don't have embedded profiles.

00:22:16.520 --> 00:22:19.440
Often times there are legacy
files that are still around that

00:22:19.470 --> 00:22:20.690
don't have embedded profiles.

00:22:20.690 --> 00:22:22.400
It's becoming increasingly rare.

00:22:22.630 --> 00:22:25.900
But there's no one right answer
as far as how to render images

00:22:25.900 --> 00:22:27.400
without embedded profiles.

00:22:27.400 --> 00:22:30.400
And usually the best solution
is to give your user the choice

00:22:30.400 --> 00:22:32.400
of how to handle this situation.

00:22:32.400 --> 00:22:36.390
So this shows you how to write the
code to assign default profiles.

00:22:36.400 --> 00:22:39.590
First of all, we have an image,
and we need to determine whether

00:22:39.790 --> 00:22:41.260
it doesn't have a profile in it.

00:22:41.450 --> 00:22:43.730
And the way this code does this
is to get the current color space

00:22:43.830 --> 00:22:47.400
from the image and see if the color
space is one of the following:

00:22:47.400 --> 00:22:51.880
if it's either device gray, device RGB,
or device CMYK.

00:22:52.530 --> 00:22:55.220
If it's equal to any of these,
then we're going to use a

00:22:55.220 --> 00:22:56.400
default color space instead.

00:22:56.400 --> 00:23:01.400
This code doesn't show how to ask
the user and provide user interface,

00:23:01.400 --> 00:23:03.340
but we can leave that as an exercise.

00:23:03.400 --> 00:23:07.380
Once we have the default color space
that we want to replace it with,

00:23:07.450 --> 00:23:11.400
we call CGImageCreateCopy
with color space.

00:23:11.400 --> 00:23:13.400
And that's all there is to it.

00:23:16.490 --> 00:23:20.000
Another important thing to keep in
mind in terms of color management of

00:23:20.000 --> 00:23:24.590
images is to make sure that your images
are matched correctly across displays.

00:23:24.760 --> 00:23:27.960
There's one line you can add
to your NSView that will make

00:23:27.960 --> 00:23:32.630
this happen automatically,
and that is tell the window that it

00:23:32.630 --> 00:23:38.100
wants to receive redraw events when the
window's profile has changed or when

00:23:38.100 --> 00:23:40.540
the window moves to a different display.

00:23:40.660 --> 00:23:44.770
This is done with set displays
when screen profile changes.

00:23:44.970 --> 00:23:46.670
This is all you need to do.

00:23:46.810 --> 00:23:49.800
What happens then is whenever the
profile changes or the window moves,

00:23:49.950 --> 00:23:54.200
your application will automatically
receive an event that needs

00:23:54.200 --> 00:23:56.000
to redraw that content.

00:23:58.520 --> 00:24:01.790
The next thing I'd like to talk
about today is a subject that's

00:24:01.790 --> 00:24:06.100
now near and dear to my heart,
which is adjusting RAW images.

00:24:06.220 --> 00:24:09.410
RAW images are one of the interesting
areas that have been growing

00:24:09.410 --> 00:24:12.070
up in the last couple years,
and I'd like to talk about the

00:24:12.070 --> 00:24:15.390
fundamentals of RAW images,
the architectural overview,

00:24:15.400 --> 00:24:19.320
and how you can use a new filter
that we've provided in Leopard.

00:24:20.110 --> 00:24:24.560
So here's a crash course on RAW images,
some of the fundamentals.

00:24:24.680 --> 00:24:28.980
So a RAW image, a camera RAW file,
contains minimally processed data

00:24:29.120 --> 00:24:31.770
from the actual sensor of a camera.

00:24:31.940 --> 00:24:36.640
What this means is that it's required
to have special image processing

00:24:36.640 --> 00:24:41.330
in order to produce an image that's
suitable for display or print.

00:24:42.400 --> 00:24:44.540
There are several things
involved in this process.

00:24:44.660 --> 00:24:46.790
First of all,
the file needs to be decoded

00:24:46.790 --> 00:24:50.100
in order to get the actual bare
sensor data out of the file.

00:24:50.210 --> 00:24:52.890
We need to extract critical
metadata from the file in order to

00:24:52.890 --> 00:24:54.600
know how to process it correctly.

00:24:54.780 --> 00:24:58.590
And then there's a series of
spatial reconstruction methods,

00:24:58.610 --> 00:25:01.000
such as debaring and
compensating for noise and

00:25:01.300 --> 00:25:04.360
chroma blur and luma sharpening,
and color processing,

00:25:04.390 --> 00:25:08.500
such as highlight recovery,
adjusting exposure and temperature tint,

00:25:08.640 --> 00:25:13.850
converting from the scene-referred
data to an output-referred color space.

00:25:13.830 --> 00:25:17.300
And as always,
there's subjective aspects of this,

00:25:17.360 --> 00:25:21.050
and so there's a certain amount
of subjective seasoning that can

00:25:21.050 --> 00:25:25.380
be added to this recipe as well to
produce an image that's pleasing.

00:25:26.930 --> 00:25:30.140
So all of this requires
dozens of parameters.

00:25:30.480 --> 00:25:35.830
And in order to produce these images,
Image I/O will maintain these dozens

00:25:35.880 --> 00:25:40.720
of parameters for all the camera
models that have been qualified.

00:25:41.730 --> 00:25:45.180
We're also continuously improving
our RAW processing methods,

00:25:45.200 --> 00:25:48.150
and what this means is that
Image I/O maintains multiple

00:25:48.380 --> 00:25:49.910
method versions as well.

00:25:50.520 --> 00:25:54.770
One thing to keep in mind is by default,
Image I/O will return a CG image

00:25:54.770 --> 00:25:58.010
ref that's rendered according
to the default parameters and

00:25:58.010 --> 00:25:59.830
according to the latest version.

00:25:59.960 --> 00:26:03.240
So this is great for most
typical applications.

00:26:03.360 --> 00:26:06.520
However, the default parameters--

00:26:06.670 --> 00:26:09.530
Cannot be perfect for all
photographs or all photographers.

00:26:09.640 --> 00:26:12.380
Everyone's got different
opinions and different images

00:26:12.380 --> 00:26:14.970
require different processing.

00:26:16.270 --> 00:26:19.660
And this is one of the great
things about RAW file formats,

00:26:19.660 --> 00:26:24.080
is that the user can have high-fidelity
control over how the image is developed.

00:26:24.140 --> 00:26:25.900
This is the whole benefit.

00:26:26.020 --> 00:26:29.150
So to provide this benefit,
we provided a new filter in

00:26:29.270 --> 00:26:32.630
Core Image called the CIRAW filter,
which is designed to give your

00:26:32.630 --> 00:26:37.900
application and your users easy control
over the RAW processing parameters.

00:26:37.940 --> 00:26:40.420
And also,
we wanted to make sure it was fast and

00:26:40.420 --> 00:26:42.750
interactive and had high performance.

00:26:43.400 --> 00:26:45.060
So here's roughly how this works.

00:26:45.120 --> 00:26:47.120
We start with a RAW image,
which can be provided

00:26:47.120 --> 00:26:49.200
either as a URL or data.

00:26:49.480 --> 00:26:53.360
And we provide this as an input
parameter into the CI RAW filter.

00:26:53.430 --> 00:26:57.510
Also into the CI RAW filter,
we provide user adjustments,

00:26:57.530 --> 00:26:59.250
such as exposure and temperature tint.

00:26:59.430 --> 00:27:03.010
If these aren't provided,
then the default values are used.

00:27:03.300 --> 00:27:08.380
Once these are provided,
from the CI RAW filter,

00:27:08.380 --> 00:27:08.380
you can extract a CI image.

00:27:08.710 --> 00:27:10.930
This CI image can be
rendered to the display,

00:27:10.930 --> 00:27:14.160
and then based on the user feedback,
the user can provide new slider

00:27:14.450 --> 00:27:17.430
positions for adjustments
such as exposure and tint,

00:27:17.430 --> 00:27:19.170
and the process can repeat itself.

00:27:19.240 --> 00:27:23.100
There's another output, however,
which is from a CI image,

00:27:23.110 --> 00:27:24.800
you can also create a CG image.

00:27:24.800 --> 00:27:29.330
And from that CG image,
we can then produce a new file on disk.

00:27:29.360 --> 00:27:32.660
So both for interactive use
on the display and also for

00:27:32.660 --> 00:27:36.600
final rendering to files,
you can use this new CI RAW filter

00:27:36.600 --> 00:27:40.200
to provide user control over
adjustments to the RAW processing.

00:27:42.400 --> 00:27:45.410
This is a very, very brief code snippet
that shows how this works.

00:27:45.560 --> 00:27:47.930
What we have as a function here,
that instead of just returning

00:27:48.060 --> 00:27:50.690
the default RAW image,
we'll provide an adjusted

00:27:50.690 --> 00:27:52.010
RAW image instead.

00:27:52.210 --> 00:27:56.840
We start with calling a CI filter,
saying we want the filter with

00:27:56.930 --> 00:27:59.440
a URL and no options by default.

00:27:59.550 --> 00:28:02.200
Then we want to provide a
default exposure value to

00:28:02.210 --> 00:28:04.060
override the normal exposure.

00:28:04.210 --> 00:28:06.600
In this case,
we're specifying a value of -1 to

00:28:06.600 --> 00:28:08.100
make the image a little darker.

00:28:08.410 --> 00:28:10.440
Once we've provided the
inputs to the filter,

00:28:10.480 --> 00:28:14.240
we can now ask for a CI image
to get for the output.

00:28:14.310 --> 00:28:20.090
And that we call just calling value
for key and saying CI output image key.

00:28:20.190 --> 00:28:21.500
That's it.

00:28:21.600 --> 00:28:24.260
However, it's much better to show this
in person because there's a

00:28:24.260 --> 00:28:25.240
lot more you can do with this.

00:28:25.240 --> 00:28:28.890
And I'd like to bring up Stan Jirman
who will show it in my action.

00:28:44.740 --> 00:28:45.600
Okay.

00:28:45.600 --> 00:28:46.840
Can you hear me now?

00:28:46.840 --> 00:28:48.720
I guess I can hear myself.

00:28:49.010 --> 00:28:52.000
So this is a demo app that you
probably have seen in some other

00:28:52.000 --> 00:28:54.100
Core Image and other demos.

00:28:54.100 --> 00:28:57.350
I'll go into a little
bit more detail here.

00:28:57.520 --> 00:29:01.590
It shows the capabilities of
the CIRROW filter as it ships in

00:29:01.590 --> 00:29:04.360
your current developer preview.

00:29:04.490 --> 00:29:07.600
Here we have an image of
astronaut Alan Poindexter,

00:29:07.680 --> 00:29:12.500
who's showing me the inside of one of
his two engines on his training jet.

00:29:12.900 --> 00:29:15.900
It's overexposed, which is why it ended
up in the trash can,

00:29:15.970 --> 00:29:20.270
but it's really great for the
demo because with a RAW filter,

00:29:20.270 --> 00:29:25.130
you can adjust the highlights in
such a way that the sky retains

00:29:25.130 --> 00:29:27.770
the details in the clouds.

00:29:28.370 --> 00:29:30.460
At the same time, you could,
for instance,

00:29:30.490 --> 00:29:35.490
append a gamma filter that would
allow you to reclaim some of

00:29:35.490 --> 00:29:37.250
the detail in the jet engine.

00:29:37.260 --> 00:29:39.240
Now, I don't know how much you
can see on the projector,

00:29:39.340 --> 00:29:42.820
but if I overdo it a little bit,
you see that you get the detail

00:29:42.820 --> 00:29:46.270
in the clouds at the same time
as the detail in the engine.

00:29:46.280 --> 00:29:51.740
You cannot do that with a non-RAW image,
which is when you take the same image,

00:29:51.860 --> 00:29:55.150
convert it into TIFF in
the default configuration,

00:29:55.210 --> 00:29:57.740
you can decrease the
brightness all you want,

00:29:57.800 --> 00:30:01.550
or the exposure,
and the clouds just will never come back.

00:30:01.560 --> 00:30:06.350
This also shows that you can use the
CI RAW filter not just for RAW files.

00:30:06.420 --> 00:30:11.920
You can use the CI RAW filter as
the first pass for input for any

00:30:11.920 --> 00:30:13.530
images coming into your application.

00:30:13.540 --> 00:30:18.510
Just in the case of a non-RAW file,
we will do the best we can with

00:30:18.860 --> 00:30:22.520
retaining or making the image
behave as close as possible as

00:30:22.600 --> 00:30:25.100
what the equivalent RAW file would.

00:30:25.100 --> 00:30:30.600
To go back,
to a better example about white balance,

00:30:31.070 --> 00:30:37.290
everybody meet Rachel,
you can click on any point in the image,

00:30:37.430 --> 00:30:41.640
for instance, and like her white shirt,
and then the image will be adjusted

00:30:41.640 --> 00:30:43.280
to the appropriate white balance.

00:30:43.340 --> 00:30:48.290
You could not do that quite the same way
if this image was a JPEG as an input.

00:30:48.480 --> 00:30:53.570
You can also use Temptant sliders,
which are always a little bit more

00:30:53.570 --> 00:30:56.700
nervous on the bottom end of the scale
than on the high end of the scale,

00:30:56.800 --> 00:30:58.240
for temperature and tint.

00:30:58.300 --> 00:31:00.840
Now how does this work
inside the application?

00:31:00.880 --> 00:31:05.940
Is this more or less legible to change
the resolution at the last moment?

00:31:06.110 --> 00:31:09.480
Let me make it a little bit bigger.

00:31:10.910 --> 00:31:12.840
Yeah.

00:31:13.020 --> 00:31:17.100
So how does this look in code?

00:31:17.540 --> 00:31:21.300
First of all, we load the image.

00:31:21.330 --> 00:31:24.380
We create a CI filter with
the contents of that URL.

00:31:24.440 --> 00:31:31.510
And then I go and I query the default
white balance settings for that image,

00:31:31.510 --> 00:31:36.810
which typically a camera will report
the white balance information,

00:31:36.850 --> 00:31:39.680
what it thought it was
when the picture was taken.

00:31:39.680 --> 00:31:41.680
And that's how you get
the default settings,

00:31:41.760 --> 00:31:42.730
which are not always right.

00:31:42.760 --> 00:31:50.510
Then later on, you can go and tweak it
with changing the exposure.

00:31:50.870 --> 00:31:53.440
This is my filter,
and I set it to the value

00:31:53.440 --> 00:31:56.160
of whatever the sender was,
either the text field or the slider.

00:31:56.160 --> 00:31:58.520
The same applies for the white balance.

00:31:58.520 --> 00:32:04.160
I just create a CI vector with X and Y.

00:32:04.160 --> 00:32:06.000
I'll get to that a little bit later.

00:32:06.000 --> 00:32:09.260
And I set it on the image.

00:32:09.280 --> 00:32:12.760
There's also a way to go and click,
which is also shown in this example.

00:32:12.760 --> 00:32:16.750
And I'm not going to
get too much into that.

00:32:16.800 --> 00:32:19.690
In the UI, you have seen two ways of
setting the white balance.

00:32:19.830 --> 00:32:23.660
There is the clicking,
and there's the temp/tense slider.

00:32:23.660 --> 00:32:26.320
That's the two things that most
people are really familiar with.

00:32:26.470 --> 00:32:28.290
If you want a little bit
more scientific approach,

00:32:28.320 --> 00:32:31.000
you can also set the
X and Y color values,

00:32:31.000 --> 00:32:37.070
which is what we're actually
using in this particular example.

00:32:41.180 --> 00:32:44.030
I think that's it for the reading demo.

00:32:44.090 --> 00:32:47.050
There's going to be another
one later for writing.

00:32:53.770 --> 00:32:56.100
So now that we've produced
these great results on screen,

00:32:56.100 --> 00:32:57.840
the last thing we want
to do is save images.

00:32:57.840 --> 00:32:59.590
And this can also be done with Image I/O.

00:32:59.600 --> 00:33:01.100
It's very simple.

00:33:01.170 --> 00:33:03.650
First of all, these are the general steps
that are involved with

00:33:03.650 --> 00:33:04.790
saving images with Image I/O.

00:33:05.070 --> 00:33:07.870
The application needs to
provide the framework with the

00:33:08.180 --> 00:33:12.400
image and optional metadata,
and then also a couple other things,

00:33:12.400 --> 00:33:15.790
such as various options that
are used when saving the image,

00:33:15.790 --> 00:33:19.740
such as compression type
or compression quality.

00:33:20.700 --> 00:33:24.170
They also specify what file
format it should be saved as.

00:33:24.310 --> 00:33:28.430
Once these inputs are provided,
then the file format code

00:33:28.430 --> 00:33:33.590
will compress the pixel data,
embed the profile, and embed the metadata

00:33:33.590 --> 00:33:35.100
and produce a file.

00:33:35.210 --> 00:33:38.570
So this is how this is
done in Image I/O with the

00:33:38.570 --> 00:33:40.840
CG Image Destination API.

00:33:40.980 --> 00:33:42.910
First off,
there's a way of getting the list of what

00:33:43.050 --> 00:33:45.600
file formats are supported by Image I/O.

00:33:45.840 --> 00:33:49.600
You can call CG Image Destination
Copy Type Identifiers.

00:33:49.600 --> 00:33:51.940
Again, this is very important for
your application to call.

00:33:52.100 --> 00:33:55.100
Not all formats that are readable
by Image I/O are writable,

00:33:55.100 --> 00:34:00.030
and that list of writable formats
is likely to improve in the future.

00:34:00.160 --> 00:34:04.100
So it's a great thing for your
application to make use of this API.

00:34:04.580 --> 00:34:07.200
Once you know that your
file can be written,

00:34:07.200 --> 00:34:10.910
you can create a CG image
destination type by calling CG image

00:34:11.090 --> 00:34:13.830
destination create with URL,
create with data,

00:34:13.870 --> 00:34:15.470
or create with data consumer.

00:34:15.530 --> 00:34:18.170
At the time that you
create the destination,

00:34:18.170 --> 00:34:21.940
you also specify the file format
in the form of a UTI string.

00:34:21.960 --> 00:34:26.190
You specify the number of images
that will be written into that file.

00:34:27.790 --> 00:34:31.200
Next, for each image that you want
to write into that file,

00:34:31.200 --> 00:34:35.450
which may be one or maybe more than one,
you can set the image, options,

00:34:35.500 --> 00:34:39.500
and metadata all at the same time by
calling CG Image Destination Add Image.

00:34:39.500 --> 00:34:44.910
Then when you're done,
you call CG Image Destination Finalize.

00:34:45.800 --> 00:34:47.790
So let me show you how
that looks in code.

00:34:47.920 --> 00:34:50.930
Here's a function that's
called WriteJPEGImage that

00:34:50.930 --> 00:34:55.270
does exactly what it says,
which is to write a JPEG data into a

00:34:55.340 --> 00:34:58.990
URL with one small piece of metadata,
in this case,

00:34:58.990 --> 00:35:00.720
which is the DPI of the file.

00:35:00.990 --> 00:35:04.030
First thing we do is we call
CGImageDestinationCreateWithURL.

00:35:04.170 --> 00:35:10.140
We specify that the UTI is public.jpeg,
and that will be providing one image.

00:35:10.630 --> 00:35:13.380
The next thing we'll be doing
is providing this dictionary.

00:35:13.510 --> 00:35:15.810
And again, the dictionary that we provide
is used for two things.

00:35:15.900 --> 00:35:19.000
One is for metadata,
and the other are options for saving.

00:35:19.100 --> 00:35:21.690
So in this case,
we have the first property in the

00:35:21.700 --> 00:35:24.470
dictionary is CG Image Destination
Compression Quality,

00:35:24.500 --> 00:35:26.500
which we're setting to 0.8.

00:35:26.660 --> 00:35:31.500
So the libjpg code will be passed
the value from this dictionary.

00:35:31.660 --> 00:35:35.490
The other values in this
dictionary are metadata properties,

00:35:35.520 --> 00:35:37.440
such as in this case,
we're going to be specifying

00:35:37.510 --> 00:35:41.300
the DPI width and DPI height
based on the input parameter.

00:35:41.530 --> 00:35:44.450
So given this combined dictionary,
we will call

00:35:44.570 --> 00:35:48.500
CG Image Destination Add Image,
and specifying the image destination,

00:35:48.500 --> 00:35:51.500
the image, and the options and
properties that we specified.

00:35:51.630 --> 00:35:54.970
Lastly,
we call CG Image Destination Finalize.

00:35:55.640 --> 00:35:58.760
Here's a similar example for TIFFs,
slightly more complicated because

00:35:58.760 --> 00:36:01.500
there's some TIFF-specific
attributes that we need to set.

00:36:01.690 --> 00:36:04.400
Again, we call cgimage-destination
create with URL,

00:36:04.570 --> 00:36:07.500
this time specifying public.TIFF.

00:36:07.500 --> 00:36:11.500
And what we want to do is we want
to specify a TIFF compression type.

00:36:11.500 --> 00:36:14.040
And in this code example,
what we want to do is if the bits

00:36:14.040 --> 00:36:17.500
per sample is greater than 8,
we want to use no compression.

00:36:17.500 --> 00:36:20.490
And if it's less than or equal to 8,
then we'll use LZW compression.

00:36:20.500 --> 00:36:23.500
So the magic values for this are 1 and 5.

00:36:23.530 --> 00:36:27.500
You could include the libTIFF
headers and get these values,

00:36:27.560 --> 00:36:29.730
or define your own constants.

00:36:30.370 --> 00:36:32.220
The important thing to remember
is you don't want to specify

00:36:32.220 --> 00:36:34.830
LZW if it's greater than 8,
because you'll actually produce

00:36:34.830 --> 00:36:36.420
files that are slower and bigger.

00:36:36.490 --> 00:36:38.810
It's unfortunate, but true.

00:36:39.060 --> 00:36:41.930
So we put this property inside
a dictionary which we're

00:36:41.960 --> 00:36:43.140
calling the TIFF properties.

00:36:43.140 --> 00:36:47.020
This is a sub-dictionary that we're going
to be putting these TIFF attributes in.

00:36:47.390 --> 00:36:50.890
Then we're going to be creating
the main property dictionary,

00:36:50.890 --> 00:36:54.780
which is going to contain, as before,
the DPI height and width and the

00:36:54.780 --> 00:36:57.150
TIFF dictionary that we just created.

00:36:57.720 --> 00:37:02.050
We then pass this combined dictionary
to CG Image Destination Add Image,

00:37:02.050 --> 00:37:05.090
specifying the image and the
destination in this hierarchical

00:37:05.140 --> 00:37:08.070
dictionary of metadata and options.

00:37:08.200 --> 00:37:11.550
And then we call
CG Image Destination Finalize.

00:37:11.720 --> 00:37:15.050
So one thing you might have
noticed is that we weren't doing

00:37:15.050 --> 00:37:17.110
anything here to preserve metadata.

00:37:17.150 --> 00:37:20.470
Ideally your application,
if it reads an image, should make note of

00:37:20.470 --> 00:37:21.860
the original metadata.

00:37:21.880 --> 00:37:24.550
And then when it comes time to write,
start with that metadata,

00:37:24.710 --> 00:37:27.530
and then specify the
options on top of that.

00:37:27.680 --> 00:37:29.680
So that code wasn't shown.

00:37:29.690 --> 00:37:32.830
Also you'll notice from this code
that there is stuff that needs to

00:37:32.830 --> 00:37:34.430
be done that's file format specific.

00:37:34.510 --> 00:37:35.440
It should be expected.

00:37:35.610 --> 00:37:37.960
File formats have different features,
and you need to be able to take

00:37:37.960 --> 00:37:39.720
advantage of those features.

00:37:39.820 --> 00:37:42.760
So there's a little bit of work on
the case of an application if they

00:37:42.760 --> 00:37:44.920
want to know how to write TIFF files.

00:37:44.920 --> 00:37:46.120
There's stuff they need
to know about TIFFs,

00:37:46.120 --> 00:37:47.520
and if they need to
know about JPEG files,

00:37:47.520 --> 00:37:50.120
they need to know about JPEG files.

00:37:50.360 --> 00:37:55.040
This can be made a lot easier, however,
given a new feature we have in ImageKit,

00:37:55.060 --> 00:37:58.000
which provides an accessory
view to an NSSavePanel.

00:37:58.120 --> 00:38:01.070
And the idea behind this is to make
a lot of this work and drudgery very,

00:38:01.070 --> 00:38:05.000
very simple for a typical application
that just wants to put up a save panel.

00:38:05.100 --> 00:38:07.590
So to show this in action, again,
I'll be bringing up Stan,

00:38:07.690 --> 00:38:09.390
who will show this.

00:38:11.440 --> 00:38:16.240
Sounds like this time
the microphone works.

00:38:16.560 --> 00:38:18.590
So let me go back to my demo.

00:38:18.670 --> 00:38:24.100
And let's say we have made
our image adjusted to taste.

00:38:24.330 --> 00:38:28.080
The white balance here
is a little bit off.

00:38:28.110 --> 00:38:31.900
This is in nearby Santa Clara,
south of here.

00:38:31.900 --> 00:38:36.290
I live there and I could
not believe my eyes.

00:38:36.900 --> 00:38:40.330
So I now just adjusted
this image to taste,

00:38:40.330 --> 00:38:41.200
and I want to save it.

00:38:41.200 --> 00:38:44.830
Now, you saw the dictionaries
that David was showing.

00:38:45.030 --> 00:38:49.340
And that is pretty complex about
all the settings that you need

00:38:49.390 --> 00:38:50.640
to put into those dictionaries.

00:38:50.640 --> 00:38:54.710
You need to know a lot of stuff
about public.jpeg and all that.

00:38:54.900 --> 00:38:58.000
And this image kit,
new image kit feature,

00:38:58.170 --> 00:39:01.650
is this accessory view that
can be added to your save panel

00:39:01.650 --> 00:39:03.740
pretty much automatically.

00:39:03.740 --> 00:39:06.780
And now I can go and I say, for instance,
I want to save this image.

00:39:06.800 --> 00:39:08.640
I'm going to save this image as jpeg.

00:39:08.660 --> 00:39:10.840
And you see automatically,
I did not have to write

00:39:10.840 --> 00:39:12.530
any code for that.

00:39:12.540 --> 00:39:15.440
The secondary view,
when I go switch again,

00:39:15.440 --> 00:39:18.740
you see it changes,
has come with the appropriate further

00:39:18.740 --> 00:39:20.790
controls for that given format.

00:39:20.980 --> 00:39:24.800
So I can now save the image as best.

00:39:24.880 --> 00:39:27.150
Let's say Facility 1.

00:39:27.350 --> 00:39:30.400
Personally, I don't like hide extension.

00:39:30.470 --> 00:39:32.260
So now it goes and saves it.

00:39:32.290 --> 00:39:36.510
And I will go and--

00:39:37.150 --> 00:39:40.260
First I did a save as,
so let me load the raw

00:39:40.260 --> 00:39:44.100
image again and save that.

00:39:44.100 --> 00:39:48.920
Again as JPEG,
this time as low-quality Facility 2.

00:39:49.100 --> 00:39:54.370
And when we go to the finder,

00:39:55.590 --> 00:39:57.770
Desktop demo.

00:39:57.830 --> 00:40:00.920
Here I should have--
this one is 3 megabytes,

00:40:00.920 --> 00:40:02.890
and that one is 144 kilobytes.

00:40:02.930 --> 00:40:05.540
So you see that the slider
immediately took effect.

00:40:05.540 --> 00:40:11.810
And I'll show you the code behind it,
that there really wasn't one of that.

00:40:12.300 --> 00:41:26.400
[Transcript missing]

00:41:27.460 --> 00:41:31.610
The first step, however,
Image I/O saves images, CG images,

00:41:31.610 --> 00:41:35.730
and for all the adjustments,
we had a CI image because we're using

00:41:35.730 --> 00:41:38.290
a CI filter or a series of CI filters.

00:41:38.390 --> 00:41:43.960
So in our demo application,
we also have a utility method, CG image,

00:41:44.010 --> 00:41:50.770
that converts the current CI image that's
being shown to the user into a CG image.

00:41:51.080 --> 00:41:53.870
There's a number of ways of doing this.

00:41:54.230 --> 00:41:55.540
This is one of those.

00:41:55.600 --> 00:41:58.940
Basically, I use an sRGB format.

00:41:59.010 --> 00:42:04.420
All of my files in this particular demo
are with the embedded sRGB profile.

00:42:04.610 --> 00:42:09.900
And I render that image into a bitmap,
and then I can save that CG image

00:42:10.000 --> 00:42:12.220
that was represented by that bitmap.

00:42:12.410 --> 00:42:19.810
This is necessary because a CI image
doesn't really exist until you render it.

00:42:20.190 --> 00:42:22.620
At this time,
I would like to use the opportunity

00:42:22.620 --> 00:42:26.070
to point out another thing that
David has mentioned before,

00:42:26.210 --> 00:42:28.920
which has to do with color profiles.

00:42:29.350 --> 00:42:34.210
It's actually quite frightening how
many people don't use color profiles

00:42:34.270 --> 00:42:38.910
every single time when they draw
something or when they save an image.

00:42:39.130 --> 00:42:42.410
It's really important to do that,
when you go and surf the web,

00:42:42.410 --> 00:42:44.610
especially when you're on a Macintosh.

00:42:44.700 --> 00:42:48.800
A lot of people post pictures from
a PC without embedding a profile,

00:42:48.800 --> 00:42:51.650
and then on the Mac,
which is a different default gamma value,

00:42:51.830 --> 00:42:53.600
it looks kind of washed out.

00:42:53.730 --> 00:42:56.380
And this will be getting more
and more important to maintain

00:42:56.380 --> 00:42:59.030
that you always have a profile
embedded so that the computer

00:42:59.040 --> 00:43:00.940
knows how to interpret those bits.

00:43:01.240 --> 00:43:04.700
And in order to ensure that
you can find out if your

00:43:04.700 --> 00:43:07.540
application is behaving correctly,
that all of its drawing is

00:43:07.720 --> 00:43:10.560
done with color matching,
we have added a new

00:43:10.560 --> 00:43:17.390
feature to Quartz Debug,
which helps with that particular problem.

00:43:17.440 --> 00:43:20.390
I opened the-- window
listing Quartz Debug.

00:43:20.550 --> 00:43:23.710
And here I can go and
select my application.

00:43:23.840 --> 00:43:29.010
And when I right click,
you get a pop-up that allows me to turn

00:43:29.010 --> 00:43:34.530
on one or both of the different warnings
that the system can issue for you,

00:43:34.580 --> 00:43:39.250
for a device profile warning
and a screen profile warning.

00:43:39.530 --> 00:43:43.110
If you load an image into your
computer without an embedded profile,

00:43:43.300 --> 00:43:46.920
it will be by default
get the device profile,

00:43:47.070 --> 00:43:50.200
which is-- dependent
from device to device.

00:43:50.210 --> 00:43:54.730
And if you turn on that warning,
any time that that image is being drawn,

00:43:54.730 --> 00:43:56.900
it will be drawn in a very funny way.

00:43:56.900 --> 00:44:02.470
We invert some channels and stuff
like that to make it visible.

00:44:02.580 --> 00:44:07.670
Similarly, sometimes the application will
load untagged images and convert

00:44:07.670 --> 00:44:09.140
them to the screen profile.

00:44:09.300 --> 00:44:13.040
And you can turn on the screen
profile warning as well.

00:44:13.060 --> 00:44:14.800
On the other hand,
the screen profile warning might not

00:44:14.860 --> 00:44:20.440
be always appropriate because you might
have-- just pre-profiled it for faster

00:44:20.440 --> 00:44:24.490
rendering for the screen so that at the
time that the image is being rendered,

00:44:24.670 --> 00:44:26.780
it doesn't take up any more time.

00:44:26.940 --> 00:44:28.580
So we keep those two separate.

00:44:28.600 --> 00:44:30.690
Now what's going to
happen if you turn it on?

00:44:30.860 --> 00:44:34.500
Currently we have a bug in the seed
that you received that it actually

00:44:34.610 --> 00:44:36.680
turns it on for the whole system,
not just for that one

00:44:36.680 --> 00:44:38.090
application that you chose.

00:44:38.240 --> 00:44:41.840
So the whole system is probably
going to go a little bit haywire.

00:44:42.140 --> 00:44:47.460
What happens is you see this image did
not get inverted or in any other way.

00:44:47.460 --> 00:44:49.880
It's just dramatically changed.

00:44:49.880 --> 00:44:52.830
That has to do with the fact
that our sample application

00:44:53.110 --> 00:44:54.860
treats color profiles correctly.

00:44:54.970 --> 00:44:59.950
But I would encourage you to try that
feature on your own imaging application,

00:44:59.950 --> 00:45:02.890
or any application for that matter,
because this will be getting

00:45:02.890 --> 00:45:04.490
an increasingly bigger problem.

00:45:04.620 --> 00:45:06.880
And you might find, for instance,
Cocoa Widgets turning

00:45:06.940 --> 00:45:08.460
purple and stuff like that.

00:45:08.480 --> 00:45:10.000
We're still working on our bugs.

00:45:10.170 --> 00:45:15.240
But make sure that your components of
the UI work correctly in this sense.

00:45:15.370 --> 00:45:17.180
And with that, back to David.

00:45:17.240 --> 00:45:18.420
DAVID CHANDLER: Thank you.

00:45:18.420 --> 00:45:26.460
So that was the last thing we
wanted to talk about today.
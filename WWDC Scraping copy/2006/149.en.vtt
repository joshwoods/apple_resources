WEBVTT

00:00:13.780 --> 00:00:15.460
Again, my name is Ron Lu Saing.

00:00:15.460 --> 00:00:19.580
I work on, among other things,
Cocoa bindings.

00:00:19.580 --> 00:00:21.700
Our agenda today looks like this.

00:00:21.700 --> 00:00:25.680
We'll start off with a conceptual
overview of Cocoa bindings,

00:00:25.720 --> 00:00:27.300
a really brief overview.

00:00:27.450 --> 00:00:31.470
Then we'll jump into some details
about the most commonly used bindings,

00:00:31.470 --> 00:00:35.260
things that just about everybody
is going to use at some point.

00:00:35.450 --> 00:00:37.150
After that,
I'll introduce some of the things that

00:00:37.150 --> 00:00:41.560
we've added to Leopard in Cocoa Bindings,
and we'll wrap up with some practical

00:00:41.560 --> 00:00:48.000
information about using the controllers
and bindings in Cocoa Bindings.

00:00:48.080 --> 00:00:51.140
So we'll start off with the basics.

00:00:53.030 --> 00:00:58.200
When we talk about a binding,
we're really talking about two things.

00:00:58.220 --> 00:00:59.980
Cocoa bindings is really two things.

00:01:00.080 --> 00:01:03.920
First,
a collection of reasonable controllers,

00:01:03.960 --> 00:01:07.450
and an API for establishing a binding.

00:01:07.620 --> 00:01:09.320
And what is a binding?

00:01:09.330 --> 00:01:12.380
A binding is really a
contract between two objects.

00:01:12.590 --> 00:01:16.020
And the idea is that you want to keep
the property of one object in sync

00:01:16.070 --> 00:01:19.230
with some property in another object.

00:01:19.290 --> 00:01:23.330
And if you write GUI applications today,
without Cocoa bindings especially,

00:01:23.500 --> 00:01:26.350
you're probably spending a lot
of time doing exactly this,

00:01:26.480 --> 00:01:31.120
trying to keep some property in
your view layer objects in sync with

00:01:31.220 --> 00:01:34.360
another property in your model objects.

00:01:34.420 --> 00:01:37.950
The idea behind Cocoa bindings
is to provide a set of reusable

00:01:37.950 --> 00:01:42.960
controllers that manage the model
objects that you're dealing with,

00:01:43.010 --> 00:01:48.520
and also a set of reusable-- so the other
thing about the reasonable controllers is

00:01:48.520 --> 00:01:51.450
managing the notion of a user selection.

00:01:51.630 --> 00:01:56.700
And that way,
when the user changes what's selected,

00:01:56.740 --> 00:02:01.150
it can also be shown in
your view layer objects.

00:02:04.800 --> 00:02:08.580
First though,
let's take a look at the reusable

00:02:08.580 --> 00:02:11.190
controllers and Cocoa bindings.

00:02:12.790 --> 00:02:14.860
Male function.

00:02:14.880 --> 00:02:16.000
Okay.

00:02:16.110 --> 00:02:21.380
If you've ever used Cocoa bindings,
chances are you've seen these little

00:02:21.380 --> 00:02:23.700
green boxes in Interface Builder.

00:02:23.850 --> 00:02:27.040
Everybody who's used Cocoa bindings at
some point has probably used Interface

00:02:27.040 --> 00:02:28.700
Builder to set up their bindings.

00:02:28.860 --> 00:02:31.630
They've seen controllers as this.

00:02:31.630 --> 00:02:34.010
Cool little green squares.

00:02:34.730 --> 00:02:37.590
And likewise,
in order to actually set up a binding,

00:02:37.750 --> 00:02:41.600
you've probably also used the bindings
inspector in Interface Builder.

00:02:41.600 --> 00:02:45.030
I want to make sure that everyone
realizes that even though it makes it

00:02:45.070 --> 00:02:49.600
really easy to set up bindings and use
controllers by using Interface Builder,

00:02:49.600 --> 00:02:52.720
it's possible to set up all of
these bindings and all of these

00:02:52.730 --> 00:02:54.600
controllers directly in code.

00:02:54.600 --> 00:02:58.950
There's no magic going on in
Interface Builder to do these,

00:02:58.950 --> 00:03:00.600
to set up bindings.

00:03:01.020 --> 00:03:07.600
There's one core method called that's
bind to object with keypath options.

00:03:07.600 --> 00:03:08.600
And that's it.

00:03:08.600 --> 00:03:11.550
That's what's going on behind
the scenes in Interface Builder

00:03:11.620 --> 00:03:14.600
to set up these bindings.

00:03:18.770 --> 00:03:22.140
And if you were to look at how to
set up a binding for a text field

00:03:22.530 --> 00:03:27.280
that you're interested in keeping in
sync with some user default value,

00:03:27.280 --> 00:03:29.080
this is the kind of code you would write.

00:03:29.250 --> 00:03:33.320
You would take your text field instance,
bind its value to our

00:03:33.320 --> 00:03:37.630
user defaults controller,
one of our reusable controller classes,

00:03:37.750 --> 00:03:41.180
and use a key path like values.petname,
whatever you want to keep in

00:03:41.180 --> 00:03:43.420
sync with the user defaults.

00:03:43.670 --> 00:03:45.300
And that's the call.

00:03:45.300 --> 00:03:49.090
That's exactly what Interface
Builder is doing behind the scenes.

00:03:52.400 --> 00:03:55.900
So I want to make sure that nobody
thinks that there's any special magic.

00:03:55.910 --> 00:03:58.310
It's all available to everybody.

00:04:01.850 --> 00:04:04.800
Because this is just a method,
there is work going on

00:04:04.800 --> 00:04:07.480
behind this method call,
right?

00:04:07.540 --> 00:04:11.640
The object that you send this
message to has to do some work.

00:04:11.700 --> 00:04:14.980
And the main obligation is--

00:04:15.270 --> 00:04:16.610
To implement the binding, right?

00:04:16.780 --> 00:04:20.150
To actually do the work
of keeping its value,

00:04:20.290 --> 00:04:23.050
its whatever property is
represented by its binding,

00:04:23.050 --> 00:04:28.310
in sync with whatever you bind it to and
the key path of the thing you bind it to.

00:04:30.680 --> 00:04:35.940
And it's also up to that object to
interpret any of the options that are

00:04:35.940 --> 00:04:41.060
passed in in the bind method as the
options dictionary that might affect

00:04:41.150 --> 00:04:42.980
how the synchronization happens.

00:04:43.090 --> 00:04:46.290
So a lot of the options that you
might see in Interface Builder really

00:04:46.300 --> 00:04:50.070
come along as just dictionaries,
and it's up to whatever object implements

00:04:50.150 --> 00:04:56.260
this bind method to interpret how
these options affect the binding.

00:04:59.080 --> 00:05:03.670
And to actually do the work,
typically the object that you are

00:05:03.670 --> 00:05:09.470
binding will listen for notifications,
key value observing notifications,

00:05:09.510 --> 00:05:11.930
from the object that you're binding to.

00:05:12.030 --> 00:05:14.440
So whatever controller you
bound your text field to,

00:05:14.440 --> 00:05:16.060
for instance.

00:05:16.270 --> 00:05:21.150
And making the synchronization
possible is key value coding.

00:05:21.350 --> 00:05:23.960
Typically,
whatever is implementing the bind

00:05:23.960 --> 00:05:28.040
method uses key value coding to
get values from its controller.

00:05:28.110 --> 00:05:31.300
And also, when the user changes a
value in the user interface,

00:05:31.370 --> 00:05:35.730
key value coding is used to set
the value in the controller.

00:05:36.810 --> 00:05:38.960
So those are the obligations
of the bound object,

00:05:39.070 --> 00:05:42.330
the object that you send
the bind message to.

00:05:44.470 --> 00:05:48.300
Now the reusable controllers
that you would normally bind to,

00:05:48.330 --> 00:05:52.820
they're there to implement some of
the logic that you would probably

00:05:52.820 --> 00:05:57.340
have to implement yourself,
again, in any GUI-based app.

00:05:57.740 --> 00:06:02.700
They do things for you like managing
the creation or deletion of objects or

00:06:02.700 --> 00:06:05.500
handling the notion of user selection.

00:06:05.610 --> 00:06:08.610
And the reusable
controllers that we ship,

00:06:08.860 --> 00:06:12.280
Go along the lines of the common
classes that you would have,

00:06:12.330 --> 00:06:15.350
the common data structures you
would have in your application.

00:06:15.440 --> 00:06:18.360
So if there's a single object that
you're interested in handling,

00:06:18.360 --> 00:06:22.390
one object at a time,
we have the NSObjectController.

00:06:22.520 --> 00:06:25.280
For arrays of objects and
dealing with the notion of

00:06:25.290 --> 00:06:29.550
sorting or filtering arrays,
handling selection in the array,

00:06:29.680 --> 00:06:32.090
we have the ArrayController.

00:06:32.780 --> 00:06:36.210
If you have a graph of objects
where each object has a relationship

00:06:36.210 --> 00:06:39.460
to a set of child objects,
we offer the Tree Controller,

00:06:39.460 --> 00:06:43.320
which keeps track of the
relationships between the objects.

00:06:44.050 --> 00:06:47.030
And if you have just some
soup of key value pairs,

00:06:47.240 --> 00:06:48.900
we offer two controllers.

00:06:48.980 --> 00:06:53.370
First, the user defaults controller,
which deals with the key value pairs

00:06:53.370 --> 00:06:55.900
you'll get from NS user defaults.

00:06:55.940 --> 00:06:59.120
And new in Leopard,
we've added a dictionary controller,

00:06:59.120 --> 00:07:03.670
which actually will take a dictionary
of key value pairs and convert it

00:07:03.670 --> 00:07:08.100
into an array of key value pairs,
which makes it really useful for hooking

00:07:08.260 --> 00:07:11.610
up table views for editing user info,
for instance.

00:07:14.490 --> 00:07:17.340
Okay, so that was the brief overview.

00:07:17.390 --> 00:07:19.040
I hope I made that brief enough.

00:07:19.040 --> 00:07:22.380
Next, the commonly used bindings.

00:07:22.460 --> 00:07:25.060
These are all the things that just
about everybody will end up using

00:07:25.060 --> 00:07:26.540
if they're using bindings at all.

00:07:29.230 --> 00:07:33.100
The format I'd like to take for this
part of the talk is I'll describe some

00:07:33.100 --> 00:07:39.260
user interface and we'll go from there
with a certain binding and figure out

00:07:39.320 --> 00:07:45.320
which controller and key path to use
in order to get to that user interface.

00:07:45.960 --> 00:07:48.160
We'll start off with something simple.

00:07:48.300 --> 00:07:49.350
User defaults.

00:07:49.450 --> 00:07:51.770
Building a preferences panel.

00:07:51.980 --> 00:07:53.920
In a simple example,
we just have a few text

00:07:53.940 --> 00:07:56.700
fields and some check boxes,
and we're really just interested

00:07:56.700 --> 00:07:59.400
in keeping whatever's in
the text field in sync with

00:07:59.480 --> 00:08:02.620
whatever's in the user defaults.

00:08:02.720 --> 00:08:07.700
So since we're interested in values,
we'll use the value binding.

00:08:08.950 --> 00:08:12.020
And since we're interested in
synchronizing with the user defaults,

00:08:12.100 --> 00:08:14.900
we'll use the NSUserDefaultsController.

00:08:15.020 --> 00:08:18.700
So we'd simply set up a binding from
every text field we're interested

00:08:18.930 --> 00:08:20.900
in to the UserDefaultsController.

00:08:20.960 --> 00:08:22.920
It would look like this
in Interface Builder.

00:08:22.990 --> 00:08:25.830
You would choose the
SharedUserDefaultsController

00:08:26.050 --> 00:08:31.360
and use a controller key values,
which is a special key in the controller.

00:08:31.590 --> 00:08:35.780
And then the model key path that we
would set is simply the value of whatever

00:08:36.170 --> 00:08:41.130
user default key we're interested in,
the key of the user default key.

00:08:41.220 --> 00:08:43.130
So in code, it would look like this.

00:08:43.350 --> 00:08:47.080
We'd bind the text field's value
binding to the user defaults

00:08:47.080 --> 00:08:53.380
controller with a key path,
values.authorName in this example.

00:08:53.660 --> 00:08:56.590
So pretty simple, pretty straightforward.

00:08:56.890 --> 00:08:59.810
And going along,
most of the other interfaces that

00:08:59.830 --> 00:09:04.500
we'd be setting up with the value
binding look pretty much the same.

00:09:04.650 --> 00:09:08.500
If we had an inspector instead
of a preferences panel,

00:09:08.500 --> 00:09:12.500
we're still interested in
binding the value of a checkbox,

00:09:12.500 --> 00:09:12.500
let's say.

00:09:12.710 --> 00:09:15.130
But instead of a user
defaults controller,

00:09:15.130 --> 00:09:19.730
we would bind to an object controller,
which holds the model object values.

00:09:20.400 --> 00:09:21.900
But the binding looks
pretty much the same.

00:09:21.990 --> 00:09:24.220
You're binding to a different controller,
and you're using a

00:09:24.220 --> 00:09:28.460
different controller key,
using selection instead of values.

00:09:28.570 --> 00:09:32.770
But you choose a key that you
want to store in the object,

00:09:32.900 --> 00:09:35.540
and that's being held by
the object controller.

00:09:35.660 --> 00:09:39.000
So in our example,
you would write a binding like this

00:09:39.000 --> 00:09:44.140
to bind the checkbox value binding
to an object controller using the

00:09:44.140 --> 00:09:46.980
keypath selection dot shadow enabled.

00:09:49.650 --> 00:09:54.750
If you're interested in dealing with
a table view and an array of objects,

00:09:54.910 --> 00:09:57.300
an array of model objects,
the natural choice would be

00:09:57.420 --> 00:09:59.280
to use an array controller.

00:09:59.560 --> 00:10:03.690
We're still using the value binding,
but now we can bind each

00:10:03.700 --> 00:10:06.110
column in our table view.

00:10:06.700 --> 00:10:11.040
We establish a value binding from
each column to the array controller

00:10:11.130 --> 00:10:14.930
using a key path that represents
the value in the column we want to

00:10:14.930 --> 00:10:17.600
display from each of the model objects.

00:10:17.620 --> 00:10:21.600
So in our case here,
we bind our object column,

00:10:21.600 --> 00:10:27.030
we bind its value binding to our
array controller using a key path

00:10:27.030 --> 00:10:31.170
arranged objects dot object name,
some key.

00:10:33.730 --> 00:10:38.080
And it's a similar
process for outline views.

00:10:38.080 --> 00:10:40.550
Since outline views deal
with hierarchies of objects,

00:10:40.690 --> 00:10:46.160
we would bind to a tree controller
and we would bind its column again

00:10:46.290 --> 00:10:48.840
to a ranged objects dot sum key.

00:10:48.840 --> 00:10:50.450
So it's a simple process.

00:10:50.450 --> 00:10:53.750
They all look pretty much the
same for the value binding.

00:11:02.630 --> 00:11:06.340
If instead of worrying about
the value held in a view,

00:11:06.400 --> 00:11:11.490
we're interested in making sure that its
enabled state is kept in sync with some

00:11:11.580 --> 00:11:17.020
other state or some other object value,
we can use the enabled binding.

00:11:18.150 --> 00:11:21.100
If we were to look at an example
of enabling or disabling user

00:11:21.100 --> 00:11:25.010
interface elements based on
some value in the user defaults,

00:11:25.010 --> 00:11:27.370
we could establish-- oh, OK.

00:11:27.530 --> 00:11:30.340
Imagine you don't want to be
able to edit the attributes of

00:11:30.340 --> 00:11:34.160
the shadow unless you've said,
turn on shadows, right?

00:11:34.260 --> 00:11:37.410
So we want this kind of user interface.

00:11:37.420 --> 00:11:38.890
Whoops.

00:11:40.550 --> 00:11:42.380
Everybody remember this slide?

00:11:42.400 --> 00:11:44.400
Okay.

00:11:44.680 --> 00:11:47.400
So we can bind to something like
the user defaults controller.

00:11:47.400 --> 00:11:49.400
It doesn't really matter.

00:11:49.420 --> 00:11:53.580
And the binding we would
establish is the enabled binding.

00:11:54.140 --> 00:11:56.040
But the key path looks
pretty much the same.

00:11:56.160 --> 00:11:58.380
Values.shadowEnabled.

00:11:58.520 --> 00:12:02.120
So we'd establish a binding from
the text field or whatever control

00:12:02.490 --> 00:12:03.780
to the user defaults controller.

00:12:03.780 --> 00:12:06.950
And remember that we had already bound,
in an example,

00:12:06.950 --> 00:12:10.980
the value of the checkbox for
whether or not the shadow is enabled.

00:12:10.980 --> 00:12:14.560
So we're actually binding the value
binding and the enabled binding to the

00:12:14.560 --> 00:12:16.500
exact same controller and key path.

00:12:16.600 --> 00:12:20.500
So that way when the checkbox is toggled,
the related binding for the

00:12:20.500 --> 00:12:22.680
enabled binding is also updated.

00:12:24.560 --> 00:12:26.190
Straightforward?

00:12:30.420 --> 00:12:34.760
So it's pretty common to bind to
some value in your model objects.

00:12:34.780 --> 00:12:37.070
But don't forget that there are
other things that you can bind to.

00:12:37.120 --> 00:12:42.520
Anything that's key value observing
compliant and key value coding compliant.

00:12:42.560 --> 00:12:45.590
So there's lots of state
that's held in your application

00:12:45.690 --> 00:12:47.810
as well as the controllers.

00:12:47.930 --> 00:12:52.240
So actually, I'm getting ahead of myself.

00:12:52.240 --> 00:12:55.100
I just want to show an example of
binding to the controller selection.

00:12:55.250 --> 00:12:58.450
Again,
we set up a value binding going back.

00:12:58.610 --> 00:13:05.860
We set up a value binding for the shadow
checkbox and the enabled binding to the

00:13:05.860 --> 00:13:08.260
same key path and controller combination.

00:13:15.430 --> 00:13:18.920
Something to consider,
you can actually set up multiple

00:13:18.920 --> 00:13:21.740
enabled bindings on the same object.

00:13:21.830 --> 00:13:25.080
So imagine that there's
more than just one state,

00:13:25.180 --> 00:13:28.930
more than just one reason for
something to be enabled or disabled.

00:13:29.230 --> 00:13:33.650
Instead of having to create some
accessor for it that aggregates all

00:13:33.650 --> 00:13:37.340
of the information that's required
to figure out is it enabled or not,

00:13:37.340 --> 00:13:41.480
you can set up multiple enabled
bindings to different controllers,

00:13:41.490 --> 00:13:42.900
different keypads.

00:13:42.930 --> 00:13:49.240
And the result of each individual
enabled binding is added together

00:13:49.240 --> 00:13:54.550
so that you're only enabled if all
of the enabled bindings say yes.

00:13:55.890 --> 00:13:58.970
And this is one of a class of-- oh, OK,
here we go.

00:13:59.020 --> 00:14:01.230
So this is what it looks
like in Interface Builder,

00:14:01.230 --> 00:14:01.640
right?

00:14:01.810 --> 00:14:04.180
We've established one enabled binding.

00:14:04.230 --> 00:14:06.700
And I don't know if you can
see at the bottom there,

00:14:06.750 --> 00:14:10.150
we have enabled two
automatically pops up for us.

00:14:10.350 --> 00:14:13.200
If we set up a second enabled binding,

00:14:13.910 --> 00:14:15.550
So now I'll do enabled two.

00:14:15.780 --> 00:14:17.980
We see down at the bottom,
enabled three pops up.

00:14:18.000 --> 00:14:20.760
And it goes on and on like this.

00:14:20.790 --> 00:14:22.160
There is a limit.

00:14:22.200 --> 00:14:23.910
I'm not telling you.

00:14:27.290 --> 00:14:31.890
And the enabled binding is actually one
of three bindings that we describe as

00:14:31.960 --> 00:14:37.120
availability bindings because they deal
with whether or not a control is enabled,

00:14:37.120 --> 00:14:38.500
editable, or hidden.

00:14:38.560 --> 00:14:41.580
And the bindings are
actually called enabled,

00:14:41.780 --> 00:14:43.140
editable, and hidden.

00:14:43.380 --> 00:14:44.620
Pretty straightforward.

00:14:44.690 --> 00:14:47.930
And they all support
that enumeration feature,

00:14:47.930 --> 00:14:51.190
multiple bindings of the same name.

00:14:53.910 --> 00:14:55.860
Okay,
this is where I'd wanted to go before.

00:14:55.860 --> 00:15:00.800
So remember that you can bind to anything
that is key value observing compliant.

00:15:00.800 --> 00:15:05.310
So not only does your application
have a lot of interesting state

00:15:05.320 --> 00:15:08.280
that might drive whether or not
something is enabled in the UI,

00:15:08.280 --> 00:15:11.430
but the controllers actually
keep some state themselves based

00:15:11.530 --> 00:15:13.980
on what the user has selected,
some other state,

00:15:13.980 --> 00:15:16.080
some other values in the controller.

00:15:16.520 --> 00:15:20.400
So you could actually bind to whether
or not there are any changes in,

00:15:20.690 --> 00:15:23.280
unsafe changes in the
user defaults controller,

00:15:23.280 --> 00:15:27.700
or whether or not an array controller
considers itself editable at all.

00:15:27.740 --> 00:15:30.210
Also,
whether or not we should be able to add

00:15:30.210 --> 00:15:32.800
or remove objects to an array controller.

00:15:32.800 --> 00:15:36.530
And you can also do funny things
like figuring out whether or not

00:15:36.530 --> 00:15:40.340
there are any objects available
to display at all using a key path

00:15:40.340 --> 00:15:42.740
like arranged objects dot at count.

00:15:42.740 --> 00:15:45.450
And you can play the same
trick with the selection.

00:15:45.460 --> 00:15:46.500
So that, you know,
you can actually bind to whether

00:15:46.500 --> 00:15:46.500
or not there are any changes in
the user defaults controller.

00:15:46.500 --> 00:15:48.810
But you might not want to
enable removing an object,

00:15:48.840 --> 00:15:52.270
any,
might not want to enable a remove button

00:15:52.270 --> 00:15:56.190
if there's nothing selected to remove.

00:16:00.900 --> 00:16:05.540
So we've gone over the value binding,
we've gone over the enabled binding.

00:16:05.540 --> 00:16:09.460
This section on pop-up buttons
isn't about any particular binding,

00:16:09.460 --> 00:16:13.960
it's about setting up bindings
for the pop-up buttons.

00:16:13.960 --> 00:16:16.040
One of the things about the pop-up
button that makes it so great

00:16:16.040 --> 00:16:17.520
is it's really configurable.

00:16:17.520 --> 00:16:20.750
You can set it up in many different
ways and you can figure out what's

00:16:20.750 --> 00:16:22.920
selected in many different ways.

00:16:22.920 --> 00:16:25.330
What that means though is that there
are lots of different ways to set

00:16:25.380 --> 00:16:27.320
up the bindings for pop-up buttons.

00:16:27.430 --> 00:16:32.890
I want to try and walk you you all
through setting up these bindings.

00:16:39.240 --> 00:16:43.230
We can look at all the bindings for
the pop-up button in two classes.

00:16:43.340 --> 00:16:48.090
First, there are the set of bindings
that deal with what's selected.

00:16:48.720 --> 00:16:49.600
On that side.

00:16:49.600 --> 00:16:53.400
And then there are the set of bindings
that deal with what objects are actually

00:16:53.400 --> 00:16:55.590
put into the pop-up dynamically.

00:16:55.600 --> 00:17:01.390
I'll look first at all of the
bindings that deal with the selection.

00:17:04.480 --> 00:17:06.260
So for this, let's imagine a simple case.

00:17:06.320 --> 00:17:10.440
We've set up a pop-up button,
NIB probably, by hand.

00:17:10.510 --> 00:17:14.250
So it has all of its menu
items set up statically.

00:17:17.090 --> 00:17:20.880
There are four bindings for dealing with
what's selected in that pop-up button.

00:17:20.970 --> 00:17:25.890
Selected value, selected tag,
selected index, and selected object.

00:17:26.610 --> 00:17:29.590
They're all mutually exclusive,
so you can only bind one.

00:17:29.750 --> 00:17:33.630
So you have to know what you're
interested in in the pop-up first.

00:17:33.660 --> 00:17:39.070
But keep in mind that you can set
up a pop-up that has just a title,

00:17:39.070 --> 00:17:43.160
or you can set the tag of
each menu item in the pop-up.

00:17:43.190 --> 00:17:47.780
Or you might only care about the
index of the item that's selected.

00:17:47.970 --> 00:17:51.560
And likewise, you can set a represented
object for each menu item.

00:17:51.770 --> 00:17:56.600
So for each of those cases where
you've set up your menu item by hand,

00:17:56.630 --> 00:18:02.220
you can use any of these
selected bindings to figure out

00:18:02.590 --> 00:18:04.500
which menu item is selected.

00:18:06.370 --> 00:18:09.140
Let's take a quick look at each of them.

00:18:09.190 --> 00:18:12.620
Again, imagine that you've set up the
menu items for your pop-up,

00:18:12.700 --> 00:18:14.020
probably statically.

00:18:14.270 --> 00:18:17.240
And you're only interested
in the selected value,

00:18:17.310 --> 00:18:20.670
so whatever label,
whatever title is selected

00:18:20.680 --> 00:18:22.170
in the menu items.

00:18:22.560 --> 00:18:24.050
You can set up a binding like this.

00:18:24.340 --> 00:18:28.960
You bind the selected value of
the pop-up to some controller

00:18:29.830 --> 00:18:33.940
using the key path that you want
to be set in the controller.

00:18:34.040 --> 00:18:37.300
So if you're interested in
the name of the last user,

00:18:37.300 --> 00:18:41.570
you'll get Miguel set in your
user defaults controller.

00:18:43.420 --> 00:18:47.340
And just an aside,
this is what it would look like

00:18:47.340 --> 00:18:49.670
if you were to set it up in code.

00:18:51.410 --> 00:18:56.810
And for each of the other things that
you can check in the selected menu item,

00:18:56.820 --> 00:18:57.740
there's a binding, right?

00:18:57.740 --> 00:18:59.300
There's the selected tag binding.

00:18:59.300 --> 00:19:01.680
If you've set tags on
each of your menu items,

00:19:01.680 --> 00:19:06.970
it looks pretty much the same,
but it takes a tag value, an integer.

00:19:07.610 --> 00:19:10.640
And if you're only interested in
the index of the selected item,

00:19:10.840 --> 00:19:15.490
then we have a binding for that,
the selected index binding.

00:19:15.650 --> 00:19:17.930
And if you've set up the
represented object and you're

00:19:17.930 --> 00:19:22.250
interested in the actual object
that backs your menu items--

00:19:23.430 --> 00:19:26.010
You can use the selected object binding.

00:19:26.100 --> 00:19:30.010
So that's what the four
selection bindings are about.

00:19:37.870 --> 00:19:43.350
Now, you might set up your menu items,
your pop-up buttons menu items by hand

00:19:43.350 --> 00:19:47.260
in IB or even in code by yourself,
but we can give you some help if

00:19:47.280 --> 00:19:51.400
you just have an array that you want
to be shown in your pop-up button.

00:19:51.500 --> 00:19:54.500
And that's what these
content bindings are for.

00:19:56.600 --> 00:19:59.440
There are three bindings for
setting up the content of a pop-up,

00:19:59.550 --> 00:20:02.180
and only two of them can
be used on their own.

00:20:02.250 --> 00:20:06.860
Those are the content values
binding and the content binding.

00:20:08.430 --> 00:20:11.230
The idea behind the content values
binding is we'll take an array of

00:20:11.230 --> 00:20:17.350
strings and turn each string in the
array into a menu item with that title.

00:20:17.820 --> 00:20:22.810
And we'll also set the represented object
of each menu item to be that string.

00:20:22.860 --> 00:20:25.940
So we figure out,
you probably want the string

00:20:25.940 --> 00:20:26.920
as a represented object.

00:20:26.920 --> 00:20:29.210
You don't have to do anything else.

00:20:31.660 --> 00:20:35.340
The content binding takes
an array of just ID objects.

00:20:35.510 --> 00:20:38.480
And what we'll do there is we'll
assume each object in that array

00:20:38.540 --> 00:20:43.310
should be the represented object
for the menu items we create.

00:20:44.080 --> 00:20:47.180
In order to figure out what titles
should be in the menu items,

00:20:47.180 --> 00:20:51.870
we turn around and we ask each object
you handed us for its description.

00:20:52.320 --> 00:20:57.700
So there are two ways to set up these
bindings that automatically figure

00:20:57.700 --> 00:21:01.920
out what the title and the represented
object for each menu item should be.

00:21:04.430 --> 00:21:10.320
Oh, and there's no way to tell us
what tag to put in each menu item.

00:21:10.590 --> 00:21:13.990
We just figure that the same
value as the index would be fine.

00:21:13.990 --> 00:21:18.850
So we automatically set the tag of each
menu item to be its index in the menu.

00:21:22.060 --> 00:21:26.320
So if we were to use the content
values binding to set up some pop-up,

00:21:26.340 --> 00:21:31.800
we might bind to an array in our
document that returns a string.

00:21:31.990 --> 00:21:36.200
And we'll directly create a
pop-up with those menu items.

00:21:39.790 --> 00:21:43.870
And again, we'll create tags for each of
those menu items that corresponds

00:21:43.870 --> 00:21:46.090
to its index in the menu.

00:21:47.820 --> 00:21:53.800
Using the content binding,
you return just an array of objects.

00:21:53.850 --> 00:21:58.650
And for each of those objects,
you'll get its description,

00:21:58.650 --> 00:22:02.390
and that will become the menu item title.

00:22:02.520 --> 00:22:06.320
So that's the recap of
content values and content.

00:22:07.050 --> 00:22:09.520
And keep in mind that all
the selected bindings,

00:22:09.550 --> 00:22:14.180
the selection star bindings,
are available still with those cases.

00:22:20.480 --> 00:22:23.200
If you've used the content binding,
like I showed you,

00:22:23.200 --> 00:22:26.060
we'll just figure the represented
object should be the object

00:22:26.160 --> 00:22:28.960
that you handed us in the array,
and the title should be

00:22:28.960 --> 00:22:30.760
the object's description.

00:22:30.890 --> 00:22:35.070
If you want to fine tune that and
customize what's shown in each

00:22:35.070 --> 00:22:38.560
menu item or what the represented
object for each menu item is,

00:22:38.630 --> 00:22:43.040
you can use the content binding in
combination with either the content

00:22:43.040 --> 00:22:46.190
values or the content objects binding.

00:22:47.330 --> 00:22:52.030
In all cases, though,
we'll infer which-- we'll infer the tag

00:22:52.030 --> 00:22:54.860
for each menu item should be its index.

00:22:54.990 --> 00:23:00.500
So again, if you want to customize the
way the title is created,

00:23:00.740 --> 00:23:06.520
you can use the content values binding
in concert with the content binding.

00:23:07.170 --> 00:23:10.920
And the content objects binding
will be using with the content

00:23:10.980 --> 00:23:14.020
binding to customize what the
represented object should be.

00:23:14.080 --> 00:23:16.820
And in both of these cases,
they should have pretty much the

00:23:16.820 --> 00:23:19.540
same settings as the content binding.

00:23:19.600 --> 00:23:25.370
That means bind to the same
controller and the same key path

00:23:25.890 --> 00:23:28.000
up to the last key component.

00:23:28.070 --> 00:23:31.300
So you can add one extra
key to the content values or

00:23:31.300 --> 00:23:32.610
the content objects binding.

00:23:32.830 --> 00:23:35.190
I'll show you what I mean in a second.

00:23:37.510 --> 00:23:41.810
So here we've bound,
if you look at the bottom left,

00:23:42.000 --> 00:23:46.640
bottom right,
we've bound to the same array controller

00:23:46.640 --> 00:23:51.820
that we bound our content binding
to and almost the same key path.

00:23:51.940 --> 00:23:56.700
It starts off with arranged objects
just like our content binding does,

00:23:56.930 --> 00:23:59.680
but in addition we add
the model key name.

00:24:00.470 --> 00:24:02.620
So this way,
using the content and content

00:24:02.620 --> 00:24:07.210
values binding together,
we get an array of objects,

00:24:07.500 --> 00:24:11.890
put those objects as the represented
objects in our menu items,

00:24:12.170 --> 00:24:16.470
And then take the name of each of
those represented objects and put that

00:24:16.470 --> 00:24:18.060
in as the title of each menu item.

00:24:20.320 --> 00:24:24.400
Okay, lots of text, sorry.

00:24:24.450 --> 00:24:29.210
But you can also bind with the content
and content objects bindings together.

00:24:29.210 --> 00:24:31.990
And it's the same effect,
except now you're customizing

00:24:32.280 --> 00:24:35.460
what the represented object
is instead of the title.

00:24:36.530 --> 00:24:38.900
And you can actually bind all three.

00:24:39.190 --> 00:24:43.400
Oh, if you're going to bind the
content objects binding,

00:24:43.510 --> 00:24:46.270
keep in mind that that only really
makes sense if you're interested

00:24:46.320 --> 00:24:48.550
in what the selected object is.

00:24:48.710 --> 00:24:52.460
Remembering that selected object
binding keeps track of what

00:24:52.500 --> 00:24:57.000
the represented object of the
menu item that's selected is.

00:24:57.360 --> 00:24:59.790
And again, like I said,
you can bind all three together.

00:24:59.860 --> 00:25:04.330
So you can start off with a base array
that we get from the content binding.

00:25:04.620 --> 00:25:08.620
And then we'll customize the titles
of each menu item we generate based

00:25:08.620 --> 00:25:10.800
on the content values binding.

00:25:10.880 --> 00:25:13.980
And the represented object for each
of those menu items is customized

00:25:14.080 --> 00:25:15.530
by the content objects binding.

00:25:15.600 --> 00:25:17.180
You can use all three together.

00:25:17.330 --> 00:25:20.230
But again, if you're using the
content objects binding,

00:25:20.440 --> 00:25:24.300
you're probably most interested in
the selected object binding later on,

00:25:24.300 --> 00:25:26.160
just to keep that in mind.

00:25:27.990 --> 00:25:29.530
Yeah, so lots of options.

00:25:29.760 --> 00:25:32.260
I swear it's easier to
use than to explain.

00:25:32.310 --> 00:25:34.680
But OK.

00:25:35.200 --> 00:25:39.290
So common bindings,
we're on to binding controllers

00:25:39.360 --> 00:25:40.510
to other controllers.

00:25:40.650 --> 00:25:44.670
Up till now we've talked mostly
about binding views to controllers.

00:25:44.790 --> 00:25:47.800
You can actually bind one
controller to another.

00:25:50.110 --> 00:25:52.230
Typically you would do this
to set up what we describe

00:25:52.260 --> 00:25:55.430
as a master detail interface.

00:25:55.620 --> 00:26:00.360
The idea behind a master detail interface
is you're given some object and you're

00:26:00.360 --> 00:26:01.940
not really interested in that object.

00:26:01.940 --> 00:26:05.820
You're really interested in something
that's related to that object.

00:26:05.970 --> 00:26:13.740
So if you were to have an array of
people and each person has a picture,

00:26:13.820 --> 00:26:17.950
you're really interested in the pictures,
but you have to navigate through

00:26:18.380 --> 00:26:23.010
every person in your array in
order to find the pictures.

00:26:24.460 --> 00:26:28.060
So the UI would typically
look something like this,

00:26:28.060 --> 00:26:28.650
right?

00:26:28.650 --> 00:26:33.070
Where we have an array
of people on the left,

00:26:33.070 --> 00:26:38.430
and the selection in that table
view of people drives what is shown

00:26:38.440 --> 00:26:41.290
in the detail view on the right.

00:26:46.140 --> 00:26:50.880
In order to set this up, again,
we're binding one controller to another.

00:26:50.980 --> 00:26:53.980
The idea is we'll take a master
controller that deals with selection.

00:26:54.060 --> 00:26:55.620
It doesn't matter
whether it's the object,

00:26:55.740 --> 00:26:57.870
array, or tree controller.

00:26:58.110 --> 00:27:04.230
And that's what drives the master
side of our user interface.

00:27:05.690 --> 00:27:09.820
And then we take whatever controller is
necessary to build our detail interface

00:27:10.280 --> 00:27:12.090
and we bind it to the master controller.

00:27:12.100 --> 00:27:18.400
So again, we take the detail controller,
in this case our array

00:27:18.400 --> 00:27:22.490
controller for pictures,
and bind its content array

00:27:22.490 --> 00:27:28.180
binding to the master controller
using the keypath selection dot,

00:27:28.210 --> 00:27:29.240
in our case, pictures.

00:27:29.240 --> 00:27:32.590
So we're basing the content of
the detail controller on what's

00:27:32.590 --> 00:27:34.440
selected in the master controller.

00:27:34.780 --> 00:27:37.390
That's all it is, very simple concept.

00:27:41.530 --> 00:27:45.130
Now though, imagine that we're dealing
with multiple objects selected

00:27:45.130 --> 00:27:47.410
in the master controller.

00:27:48.240 --> 00:27:51.560
Something that might not be
obvious initially is what happens

00:27:51.600 --> 00:27:55.110
when you have multiple objects
selected in the master controller.

00:27:55.110 --> 00:27:59.100
Because now you have multiple choices
for what to display in the detail.

00:27:59.430 --> 00:28:04.200
Should you display only the first set of
pictures from the first selected person?

00:28:04.200 --> 00:28:08.150
Dealing with this might not be
obvious how to deal with this.

00:28:08.150 --> 00:28:11.100
You might want all of the pictures
of all the selected people.

00:28:11.100 --> 00:28:14.830
But using just the content array
binding doesn't give you that.

00:28:14.940 --> 00:28:17.630
But we do have,
and also if you're dealing

00:28:17.940 --> 00:28:22.740
with multiple selected people,
you probably aren't going to use the

00:28:22.740 --> 00:28:25.940
content binding or the object controller.

00:28:25.940 --> 00:28:29.040
So we'll focus on just the
array and the tree controller.

00:28:31.900 --> 00:29:16.000
[Transcript missing]

00:29:19.540 --> 00:29:24.580
Okay,
actually that's the summary of all the

00:29:24.580 --> 00:29:28.630
common bindings that people will use,
well some of the common bindings.

00:29:28.990 --> 00:29:32.530
Now this is, I'll talk about some of the
new things we've added to

00:29:32.560 --> 00:29:34.200
Cocoa Bindings for Leopard.

00:29:34.260 --> 00:29:37.850
The first thing is you can now
do drag and drop with an outline

00:29:37.850 --> 00:29:39.850
view bound to a tree controller.

00:29:41.230 --> 00:29:47.700
The magic that happened-- no, wait,
there's no magic.

00:29:48.000 --> 00:29:51.490
All that we do is now we actually
have a real object that can

00:29:51.660 --> 00:29:56.480
represent each node in the tree
that the tree controller manages.

00:29:56.520 --> 00:29:58.300
That's the NSTree node.

00:29:58.470 --> 00:30:00.550
It's a really simple object.

00:30:00.550 --> 00:30:03.420
It has three core properties, right?

00:30:03.450 --> 00:30:06.260
There's a represented
object that it handles,

00:30:06.270 --> 00:30:10.600
and that's the model object that you're
handing it from your tree of objects.

00:30:10.950 --> 00:30:15.750
It also keeps a notion of a parent
object and an array of child objects.

00:30:15.800 --> 00:30:20.200
So that way you don't have to manage
a back pointer in your model objects.

00:30:22.200 --> 00:30:29.900
And it also knows where it is
in the tree of other tree nodes.

00:30:30.090 --> 00:30:32.700
So you can get to that
using an index path,

00:30:32.810 --> 00:30:37.400
which is a class we also introduced
in Tiger to represent exactly this,

00:30:37.400 --> 00:30:39.220
a path through a tree.

00:30:39.510 --> 00:30:45.150
So now that we have a real class
to describe each node in the tree,

00:30:45.150 --> 00:30:46.660
we can use it.

00:30:49.620 --> 00:30:53.120
In Leopard,
and in the seed that you guys got,

00:30:53.410 --> 00:30:57.620
the tree controller will vend
NSTree nodes through two methods.

00:30:57.750 --> 00:31:02.270
The selected nodes,
which returns just an array of nodes

00:31:02.270 --> 00:31:05.300
that represent what objects are selected.

00:31:05.400 --> 00:31:10.180
And arranged objects on the tree
controller returns a proxy that lets

00:31:10.230 --> 00:31:14.840
you navigate through the entire arranged
tree as just going node by node.

00:31:14.840 --> 00:31:19.500
And you can use tree node API on
that proxy to start descending

00:31:19.790 --> 00:31:22.330
through all of the arranged nodes.

00:31:22.340 --> 00:31:25.270
And the API looks roughly like this.

00:31:25.320 --> 00:31:28.170
You can either use descendant
node at index path if you already

00:31:28.250 --> 00:31:29.770
know where you're going to go.

00:31:30.550 --> 00:31:36.160
Or you can go one child node at a time
and just get the array of immediate

00:31:36.170 --> 00:31:38.280
child nodes and traverse down from that.

00:31:43.300 --> 00:31:47.170
Going back to the drag and
drop with outline view thing,

00:31:47.170 --> 00:31:52.550
the real API that enables drag and drop
makes it really easy is the move node

00:31:52.550 --> 00:31:55.760
API that we've added to Tree Controller.

00:31:55.760 --> 00:31:58.200
And this is a consumer for tree nodes.

00:31:58.200 --> 00:32:01.720
You pass it an array of tree
nodes or a single tree node and

00:32:01.720 --> 00:32:06.770
we'll take that and put it in,
we'll place it in the

00:32:06.770 --> 00:32:09.580
index path you describe.

00:32:09.600 --> 00:32:12.090
So using this,
it's really easy to set up drag

00:32:12.090 --> 00:32:15.930
and drop in an outline view
bound to a Tree Controller.

00:32:19.170 --> 00:32:21.860
The process is pretty straightforward.

00:32:21.860 --> 00:32:26.430
You set up a tree controller the way you
normally would given a children key path,

00:32:26.430 --> 00:32:29.340
a way to navigate through
your model objects.

00:32:29.350 --> 00:32:33.900
And you bind the columns of your
outline view to the tree controller.

00:32:34.180 --> 00:32:38.220
And you would set a custom class
like either your files owner or

00:32:38.240 --> 00:32:44.310
subclass of NS tree controller as
the data source for the outline view.

00:32:44.840 --> 00:32:47.640
You only have to implement the
drag and drop data source methods.

00:32:47.640 --> 00:32:51.290
You don't have to implement any
of the others you might be used to

00:32:51.290 --> 00:32:53.780
for the outline view data source.

00:32:54.810 --> 00:32:58.280
And in these drag and drop methods,
you're passed items

00:32:58.360 --> 00:33:00.000
from the outline view,
right?

00:33:00.070 --> 00:33:04.510
These items are now NS tree nodes
in the bound outline view case.

00:33:04.630 --> 00:33:07.470
And so now you can take a
look at all the represented

00:33:07.500 --> 00:33:11.700
objects that item in the tree.

00:33:11.750 --> 00:33:16.530
And you can take a look at where the item
is in the arranged tree by index path.

00:33:16.630 --> 00:33:19.080
So you can call represented
object on the item.

00:33:19.300 --> 00:33:22.530
You can also call index path on the item.

00:33:22.810 --> 00:33:26.980
And then once you're ready to
actually do the move of nodes or

00:33:26.980 --> 00:33:31.980
drop a node into a new location,
you can use TreeController

00:33:31.980 --> 00:33:35.300
move node to index path.

00:33:35.490 --> 00:33:41.990
You can also directly mutate
the child nodes of each item.

00:33:42.570 --> 00:33:45.710
You can get access to that using
the mutable child nodes method

00:33:46.270 --> 00:33:47.920
and treat it just like an array.

00:33:48.090 --> 00:33:52.090
This is a key value observing
compliant array that you'll get.

00:33:54.390 --> 00:33:58.840
And something about mutating these nodes,
adding new nodes to the array,

00:33:59.020 --> 00:34:02.440
to the mutable child nodes,
will fix up the relationships

00:34:02.440 --> 00:34:05.900
between the represented objects
in each of those nodes as well.

00:34:06.000 --> 00:34:11.110
So this works great for the case
of core data in your outline views,

00:34:11.110 --> 00:34:14.200
right, using core data managed objects.

00:34:16.940 --> 00:34:19.620
And something to note,
NSTreeNode is a useful class

00:34:19.620 --> 00:34:21.240
outside of NSTreeController as well.

00:34:21.240 --> 00:34:26.870
You can use it just to build ad hoc trees
on your own just using TreeNode API.

00:34:27.090 --> 00:34:30.590
It doesn't depend on bindings
or the TreeController at all.

00:34:31.960 --> 00:34:35.140
Okay,
so that's new tree controller stuff.

00:34:35.200 --> 00:34:40.470
The other controller information we have
is we've added a dictionary controller.

00:34:40.800 --> 00:34:44.450
So why did we add a
dictionary controller?

00:34:44.570 --> 00:34:47.830
Commonly, well, at least a lot of people
claim it's common.

00:34:47.830 --> 00:34:48.540
Is it true?

00:34:48.540 --> 00:34:51.440
That you want to edit dictionaries
in your user interface,

00:34:51.440 --> 00:34:55.320
something like you have a user info
dictionary or anything like that,

00:34:55.340 --> 00:35:03.410
and you want to show the dictionary's
keys and values in a table view.

00:35:03.630 --> 00:35:06.560
It's typically difficult,
it's challenging at least,

00:35:06.700 --> 00:35:10.870
to set up an array controller to
transmogrify a dictionary into an

00:35:10.870 --> 00:35:14.960
array and show it in the table view
and then actually handle the editing

00:35:14.960 --> 00:35:16.840
and everything all on your own.

00:35:17.030 --> 00:35:21.370
Well, the dictionary controller is
there to handle that for you.

00:35:21.370 --> 00:35:24.640
It's a simplification of that process.

00:35:24.670 --> 00:35:28.820
It's a subclass of the array controller,
which means it's really easy

00:35:29.030 --> 00:35:30.920
to set up with a table view.

00:35:31.120 --> 00:35:33.060
And it does everything
that you would expect,

00:35:33.060 --> 00:35:34.910
stuff that you would have to do yourself.

00:35:34.990 --> 00:35:39.000
Converting the dictionary into
an array of key value pairs,

00:35:39.000 --> 00:35:43.340
making sure that certain keys are
always visible or maybe never visible.

00:35:43.340 --> 00:35:48.210
And it even supports localization
using a set dictionary,

00:35:48.210 --> 00:35:51.420
localization dictionary method,
or using a strings file.

00:35:52.080 --> 00:35:54.080
And typically,
you don't want to show the raw

00:35:54.080 --> 00:35:56.140
keys in your dictionary to users,
right?

00:35:56.150 --> 00:36:02.180
You could actually set up a pretty
UI with pretty keys in your table view.

00:36:02.180 --> 00:36:05.890
And there's more information
on this in the documentation.

00:36:10.000 --> 00:36:15.180
Setting up a dictionary controller with
a table view looks just like setting up

00:36:15.180 --> 00:36:17.860
an array controller with a table view.

00:36:21.910 --> 00:36:24.930
When you get the arranged objects
from a dictionary controller though,

00:36:25.000 --> 00:36:27.560
they only have two keys,
a key and a value.

00:36:27.760 --> 00:36:29.250
That's pretty much it.

00:36:29.430 --> 00:36:32.670
You get keys and values out
of the dictionary as keys

00:36:32.670 --> 00:36:34.590
and values in your array.

00:36:35.300 --> 00:36:38.640
And like I mentioned,
you can make sure that certain

00:36:38.720 --> 00:36:41.840
keys are always visible so that
your user isn't presented with

00:36:41.840 --> 00:36:44.900
just an empty array the first time,
an empty table view the first

00:36:44.900 --> 00:36:47.300
time they see your editor.

00:36:47.410 --> 00:36:51.210
So you can use the set
included key method,

00:36:51.300 --> 00:36:52.660
this included keys method.

00:36:52.660 --> 00:36:56.570
But slides are boring.

00:36:56.950 --> 00:36:58.930
Let's do a demo.

00:37:03.510 --> 00:37:05.700
Were they that boring?

00:37:05.700 --> 00:37:07.330
Sorry.

00:37:07.350 --> 00:37:07.810
OK.

00:37:08.130 --> 00:37:10.740
We have a simple application here.

00:37:10.910 --> 00:37:16.380
I used Core Data just because it was
faster to set up the demo that way.

00:37:16.420 --> 00:37:20.340
We have just a person
entity and a photo entity.

00:37:20.370 --> 00:37:25.620
Every person has an array
or a collection of photos,

00:37:25.620 --> 00:37:26.600
right?

00:37:27.730 --> 00:37:31.170
Let's take a look at our nib.

00:37:31.600 --> 00:37:33.480
This is our nib.

00:37:34.860 --> 00:37:41.470
We'll build a simple editor UI just
for looking at people and their photos.

00:37:41.590 --> 00:37:47.150
We'll start off with a window.

00:37:51.450 --> 00:37:57.600
So we have a few outlets in our .h.

00:37:57.640 --> 00:38:01.830
So we'll set up the outline view
and the tree controller in our nib.

00:38:12.830 --> 00:38:16.030
So we'll have names and favorite drinks.

00:38:16.110 --> 00:38:20.480
Do multiple selection.

00:38:20.990 --> 00:38:22.890
Drag over a tree controller.

00:38:22.910 --> 00:38:26.960
The first thing we'll set up before
we forget is the children key path.

00:38:26.960 --> 00:38:30.000
This tells the tree controller
how to traverse from one

00:38:30.000 --> 00:38:31.830
object to its related object.

00:38:32.040 --> 00:38:35.450
And in our case,
every person has a photo.

00:38:35.580 --> 00:38:57.830
Photos.

00:38:57.830 --> 00:38:57.830
And if we look at our model,
we've also set up a special

00:38:57.830 --> 00:38:57.830
attribute on each entity,
the notion of isLeaf.

00:38:57.830 --> 00:38:57.830
We could name it whatever we want,
but it's useful for us to know that

00:38:57.830 --> 00:38:57.830
a person can contain other objects,
but photos can't.

00:38:58.650 --> 00:39:03.860
is leaf is yes for photos and is
leaf is no for person objects.

00:39:03.920 --> 00:39:08.250
So we'll tell the tree controller to take
a look at that before it tries to go off

00:39:08.250 --> 00:39:10.570
and get any photos for photo objects.

00:39:12.690 --> 00:39:14.700
We're using Core Data,
so we'll switch to entity

00:39:14.700 --> 00:39:18.170
mode in this inspector.

00:39:18.250 --> 00:39:21.800
And the Tree Controller will
fetch person objects.

00:39:21.910 --> 00:39:24.550
And it should fetch it automatically,
so I'll turn on the prepares

00:39:24.620 --> 00:39:28.080
content setting here.

00:39:29.700 --> 00:39:34.070
Since we can't fetch objects
in the TreeController without

00:39:34.100 --> 00:39:36.670
a managed object context,
we'll go over here and bind the

00:39:36.680 --> 00:39:40.460
TreeController's managed object context.

00:39:40.460 --> 00:39:46.640
You might have noticed here our files
owner is a persistent document subclass.

00:39:46.650 --> 00:39:50.460
That comes with its own
managed object context.

00:39:50.460 --> 00:39:56.570
So we'll just bind to the files
owner managed object context.

00:39:56.770 --> 00:39:59.160
Okay, you guys need to check to make
sure that I spelled that right.

00:39:59.160 --> 00:40:02.010
That looks okay.

00:40:02.380 --> 00:40:03.300
Okay.

00:40:03.380 --> 00:40:08.500
Let's add some buttons.

00:40:08.500 --> 00:40:08.500
I like buttons.

00:40:10.440 --> 00:40:14.740
Since we're dealing with hierarchies,
we can do more than just add, right?

00:40:14.980 --> 00:40:17.720
We can do add child.

00:40:22.330 --> 00:40:28.680
We can wire these actions up to
the tree controller directly.

00:40:28.790 --> 00:40:31.410
So we have add actions.

00:40:32.120 --> 00:40:40.630
Add child and if we look
at the received actions,

00:40:40.630 --> 00:40:40.630
I also have remove.

00:40:42.980 --> 00:40:46.700
And now we'll set up the
bindings for the columns.

00:40:46.770 --> 00:40:49.820
For the name column,
we go to the value binding,

00:40:49.870 --> 00:40:53.980
the tree controllers,
arranged objects dot name.

00:40:54.050 --> 00:40:56.590
And for the drink,

00:40:57.060 --> 00:41:00.650
Now, in this outline view,
since we're dealing with

00:41:00.670 --> 00:41:04.460
a tree of objects again,
we'll start off with person objects,

00:41:04.560 --> 00:41:09.320
which all have a name and a drink,
a favorite drink associated with them.

00:41:09.320 --> 00:41:12.130
But then we'll also show photo objects.

00:41:12.130 --> 00:41:14.540
And photos don't have drinks.

00:41:14.920 --> 00:41:17.610
And we don't want our
app to tell us that,

00:41:17.610 --> 00:41:19.130
you know, we already know that.

00:41:19.130 --> 00:41:22.380
So we'll turn off the raises
for not applicable keys.

00:41:22.380 --> 00:41:25.800
That means that when we get
a key value coding exception

00:41:25.800 --> 00:41:30.910
that photos don't have drinks,
we'll ignore it and we'll keep running,

00:41:30.910 --> 00:41:30.910
right?

00:41:31.290 --> 00:41:34.700
We'll also turn off creating sort
descriptors since we're not going

00:41:34.700 --> 00:41:43.570
to be able to sort on drinks if
photos don't have a drink attribute.

00:41:44.790 --> 00:41:51.030
Now we'll set ourself as the
data source for the outline view.

00:41:51.200 --> 00:41:55.980
We also have the outlet to the
outline view that we're interested in.

00:41:56.080 --> 00:41:59.350
And we also want to know
about the tree controller.

00:42:00.390 --> 00:42:04.240
So with those things set,
we can take a look at the .m.

00:42:04.380 --> 00:42:07.300
The first thing we do,
window controller did load nib,

00:42:07.690 --> 00:42:09.340
we'll register for drag types.

00:42:09.520 --> 00:42:11.640
This is part of the setting
up the outline view to be

00:42:11.840 --> 00:42:14.430
able to support drag and drop.

00:42:14.530 --> 00:42:17.570
Just come up with a key, nodes.

00:42:18.030 --> 00:42:23.430
And all we're really interested in is
knowing that we're about to start a drag.

00:42:23.510 --> 00:42:27.630
So in order to do the right
items to the pasteboard,

00:42:27.630 --> 00:42:31.540
we just put an empty array,
an empty string up there,

00:42:31.540 --> 00:42:37.160
but we hang on to the array that's
passed to the right items method.

00:42:37.220 --> 00:42:41.990
This array is just an array of tree nodes
that's been selected to start the drag.

00:42:44.020 --> 00:42:47.920
The rest of the methods that
you're used to for drag and drop,

00:42:47.960 --> 00:42:51.100
the validate drop method,
will just make sure that,

00:42:51.240 --> 00:42:54.860
among other things,
you can't drop into an object like,

00:42:55.030 --> 00:42:57.000
you can't drag photos inside of photos.

00:42:57.000 --> 00:43:03.440
Make sure that you're not trying
to drag within the same parent.

00:43:03.440 --> 00:43:10.590
And always drag into a person,
not just photo on top of photo.

00:43:10.590 --> 00:43:13.640
And it's always a move operation.

00:43:15.570 --> 00:43:19.300
So most of this is just
general type checking,

00:43:19.300 --> 00:43:21.740
information checking that you
would normally have to do with

00:43:22.110 --> 00:43:24.710
implementing drag and drop anyway.

00:43:26.110 --> 00:43:31.340
And here is the real meat of the
drag and drop implementation.

00:43:31.340 --> 00:43:34.410
That's actually performing the drop,
accepting the drop.

00:43:34.670 --> 00:43:36.920
We've cached away the dragged nodes,
as you saw earlier.

00:43:36.990 --> 00:43:41.600
We're just going to move those
nodes to the new location.

00:43:41.600 --> 00:43:46.050
So item is the tree node that's going
to be the destination for the drop.

00:43:46.100 --> 00:43:51.370
And the child index is the child
index in that item's child nodes.

00:43:51.450 --> 00:43:55.980
So we can create an index path,
starting with that item's index path.

00:43:56.000 --> 00:43:59.340
and just adding its child index.

00:44:00.540 --> 00:44:02.860
And the move is done.

00:44:02.960 --> 00:44:07.310
So let's try it.

00:44:09.750 --> 00:44:13.820
Okay, add, add, add.

00:44:13.870 --> 00:44:17.120
Let's see, Bill likes gin.

00:44:18.270 --> 00:44:21.720
Kind of a rum guy myself.

00:44:22.340 --> 00:44:23.880
So we're adding some photos.

00:44:24.080 --> 00:44:26.070
We can just name them.

00:44:28.730 --> 00:44:32.140
So you can see we've created the
disclosure triangle for things that

00:44:32.140 --> 00:44:39.380
are person objects since those have
child objects and photos don't.

00:44:39.550 --> 00:44:41.630
We can sort on name, drink.

00:44:41.940 --> 00:44:45.770
We've disabled sorting when we
turned off create sort descriptors.

00:44:45.860 --> 00:44:48.870
And we can do drag and drop.

00:44:50.030 --> 00:44:54.800
One of the things about
using the move nodes API,

00:44:54.800 --> 00:44:59.290
it's much better for the tree
controller as far as being able

00:44:59.390 --> 00:45:01.620
to keep track of the selection.

00:45:01.620 --> 00:45:04.580
If you were to simply mutate
the relationships underneath

00:45:04.580 --> 00:45:06.930
the tree controller,
we'd try our best to keep

00:45:06.930 --> 00:45:11.560
track of the selection,
but it's really much better to do this.

00:45:12.710 --> 00:45:15.900
So that's drag and drop.

00:45:15.990 --> 00:45:22.260
Let's take a look though at
the dictionary controller.

00:45:22.320 --> 00:45:24.370
Let's add a tab.

00:45:26.370 --> 00:45:28.120
So I don't have that much screen space.

00:45:28.120 --> 00:45:36.260
I want an editor for both the user
info and for the picture data.

00:45:36.320 --> 00:45:40.050
Let's see.

00:45:40.590 --> 00:45:44.280
The user info will need a table view.

00:45:46.470 --> 00:45:47.700
Kind of getting ahead of myself, though.

00:45:47.700 --> 00:45:50.850
We're going to need a dictionary
controller to feed the table view.

00:45:51.290 --> 00:45:55.440
And since we want this to be a
detail of whatever's selected

00:45:55.560 --> 00:45:59.740
in the person outline view,
we'll bind the content dictionary

00:45:59.740 --> 00:46:05.400
of the dictionary controller to
the tree controller's selection

00:46:05.460 --> 00:46:09.310
and the user info dictionary.

00:46:10.670 --> 00:46:28.000
of that selection.

00:46:28.000 --> 00:46:28.000
And again,
since not all objects have a user info,

00:46:28.000 --> 00:46:28.000
only person objects have user info,
not photos, we'll turn off the raises for

00:46:28.000 --> 00:46:28.000
not applicable keys here too.

00:46:28.000 --> 00:46:28.000
We can add some buttons.

00:46:29.550 --> 00:46:32.900
Set those up to add in the
dictionary controller and remove

00:46:32.900 --> 00:46:35.190
in the dictionary controller.

00:46:37.550 --> 00:46:41.200
Let's see,
remember about the enabled bindings?

00:46:41.210 --> 00:46:43.140
Let's take a look at using them here.

00:46:43.180 --> 00:46:51.000
We only want to be able to add or
remove when a user is selected.

00:46:51.000 --> 00:46:51.000
So if the user is selected,

00:46:51.630 --> 00:46:57.050
The dictionary controller has any
content via the user info binding,

00:46:57.120 --> 00:46:59.440
the content binding here.

00:46:59.440 --> 00:47:02.790
It'll actually set itself as editable.

00:47:03.450 --> 00:47:06.820
Otherwise,
it will consider itself not editable.

00:47:06.910 --> 00:47:10.280
So if the dictionary
controller is non-editable,

00:47:10.360 --> 00:47:12.940
then we shouldn't allow
adding or removing.

00:47:13.040 --> 00:47:19.200
So we'll just bind the
add and remove buttons.

00:47:21.820 --> 00:47:23.880
But see,
we don't want to enable them just

00:47:23.880 --> 00:47:27.870
because the controller is editable.

00:47:28.090 --> 00:47:32.580
We'd also want to make sure that
you can remove things that the

00:47:32.660 --> 00:47:35.870
dictionary controller's notion
of can remove is also satisfied.

00:47:35.870 --> 00:47:41.630
So here's that using multiple
enabled bindings also.

00:47:46.010 --> 00:47:50.220
Okay, we'll go off and set up the
dictionary controller to provide

00:47:50.220 --> 00:47:52.810
data in the form of a key.

00:47:53.560 --> 00:48:06.170
And a value to each of these columns.

00:48:06.170 --> 00:48:06.170
Let's name them.

00:48:06.170 --> 00:48:06.170
And if I set this up correctly,

00:48:11.340 --> 00:48:16.750
So we add some person objects.

00:48:16.750 --> 00:48:19.320
We add a photo for each person.

00:48:19.600 --> 00:48:22.720
Sure enough.

00:48:22.720 --> 00:48:25.640
So we've selected a photo
which doesn't have user info,

00:48:25.640 --> 00:48:28.780
so we've disabled this part of the UI.

00:48:28.780 --> 00:48:32.600
And now we can add,
since we've selected Bill.

00:48:32.690 --> 00:48:38.600
So session, I think he's 248, 249.

00:48:38.600 --> 00:48:41.360
Then we can remove.

00:48:41.360 --> 00:48:43.400
Pretty cool.

00:48:43.880 --> 00:48:47.510
Oh, but actually we always want the
session information to show up.

00:48:47.620 --> 00:48:48.960
We're at WWDC.

00:48:49.080 --> 00:48:50.440
Somebody's got to give a session.

00:48:50.550 --> 00:48:54.290
Let's go back to the dictionary
controller and under the attributes

00:48:54.320 --> 00:48:56.350
we can set the included keys.

00:48:56.530 --> 00:48:59.340
These are keys that
will always be present.

00:48:59.490 --> 00:49:01.460
So session name.

00:49:02.480 --> 00:49:07.360
And then also, we don't want the UI for
the table view to be enabled

00:49:07.360 --> 00:49:10.150
unless absolutely necessary.

00:49:10.240 --> 00:49:16.090
So we'll do the same trick here,
binding to isEditable.

00:49:16.200 --> 00:49:20.120
And let's take a look at the photo.

00:49:25.210 --> 00:49:29.240
We combine the data of the image
well to the tree controller's

00:49:29.280 --> 00:49:34.300
selection and its image data,
and it will directly create an image from

00:49:34.300 --> 00:49:37.870
the NSData that's in our managed objects.

00:49:38.330 --> 00:49:42.430
And I actually don't like
switching between tabs like this.

00:49:42.750 --> 00:49:44.910
I'll use a pop-up button.

00:49:46.100 --> 00:50:05.500
[Transcript missing]

00:50:06.520 --> 00:50:14.390
Then we can bind the selected index of
the tab view to the exact same thing.

00:50:14.460 --> 00:50:15.840
Selected index.

00:50:15.940 --> 00:50:18.590
So now when we change the
selection in this pop-up,

00:50:18.700 --> 00:50:21.830
it'll change the selection
for us in the tab view.

00:50:22.030 --> 00:50:25.340
So then we can go with
a tabless tab view.

00:50:29.000 --> 00:50:32.890
Now that I think of it,
we should only be editable when

00:50:32.900 --> 00:50:34.650
we can actually drag in a photo.

00:50:34.650 --> 00:50:39.770
So when the tree controller has selected,
has a photo selected.

00:50:48.360 --> 00:50:52.770
Okay, so user info, photo,
that didn't work.

00:50:52.880 --> 00:50:54.600
There we go.

00:50:54.670 --> 00:50:55.660
Let's try this.

00:50:55.860 --> 00:50:58.980
Let's open up an existing file.

00:51:01.610 --> 00:51:03.500
Yep, cool, sweet.

00:51:03.500 --> 00:51:08.110
And yeah, we still have drag and drop.

00:51:08.230 --> 00:51:10.390
We didn't break that.

00:51:10.390 --> 00:51:10.390
Cool.

00:51:12.270 --> 00:51:18.790
But actually,
I don't like the pop-up either.

00:51:20.300 --> 00:51:25.880
The selected tab should really track
what's selected in the outline view.

00:51:25.930 --> 00:51:28.190
We only have two things
that could be selected.

00:51:28.310 --> 00:51:31.410
We have isLeaf as a property
on each of the two things.

00:51:31.660 --> 00:51:33.260
They return different values.

00:51:33.340 --> 00:51:34.930
We could use a little trick here.

00:51:35.100 --> 00:51:40.670
We bind to the controller's
selection.isLeaf.

00:51:46.790 --> 00:51:52.380
The selected tab should really track
what's selected in the outline view.

00:51:52.380 --> 00:51:54.630
We only have two things
that could be selected.

00:51:54.750 --> 00:51:58.100
We have isLeaf as a property
on each of the two things.

00:51:58.100 --> 00:51:59.650
They return different values.

00:51:59.770 --> 00:52:01.540
We could use a little trick here.

00:52:01.540 --> 00:52:07.180
We bind to the controller's
selection.isLeaf.

00:52:16.730 --> 00:52:18.180
Thanks a lot.

00:52:25.040 --> 00:52:29.580
So I have a few minutes
in which to wrap up.

00:52:30.010 --> 00:52:32.000
The wrap up is practical
information about,

00:52:32.000 --> 00:52:35.490
first, some of the reusable
controllers that we ship.

00:52:37.420 --> 00:52:42.860
As you might have seen with the example,
your interaction with the controllers

00:52:42.860 --> 00:52:44.580
should look something like this.

00:52:44.600 --> 00:52:48.730
You provide it with content,
either using a binding or by specifically

00:52:48.770 --> 00:52:51.890
calling setContent on the binding.

00:52:52.120 --> 00:52:56.790
And then you set the object
class name for the controller.

00:52:57.260 --> 00:53:05.700
So that affects which class of object is
created whenever you hit the new or new

00:53:05.700 --> 00:53:09.740
button that's attached to a controller.

00:53:10.980 --> 00:53:13.840
So once you've set the content and
set up the controller properly,

00:53:14.030 --> 00:53:16.900
then the controller just
manages everything for you.

00:53:17.130 --> 00:53:19.590
It deals with arranging the objects.

00:53:19.840 --> 00:53:22.890
For like the array controller,
you could imagine it automatically

00:53:22.900 --> 00:53:26.320
deals with filtering or
sorting the objects for you.

00:53:26.320 --> 00:53:29.090
It also deals with the
notion of the user selection,

00:53:29.090 --> 00:53:31.470
keeping track of which
object is selected,

00:53:31.470 --> 00:53:37.620
and dealing with what happens
when the add button is pressed,

00:53:37.620 --> 00:53:42.950
creating new objects,
or the delete button is pressed,

00:53:42.950 --> 00:53:44.890
deleting the objects.

00:53:44.980 --> 00:53:50.620
The object life cycle
of your model objects.

00:53:50.640 --> 00:53:52.940
I love managed objects.

00:53:54.410 --> 00:53:57.600
And when you're binding
to these controllers,

00:53:57.650 --> 00:54:00.700
there's a certain pattern you'll get
into with each of the controllers.

00:54:00.810 --> 00:54:03.240
When you're binding to a
user defaults controller,

00:54:03.300 --> 00:54:06.480
you'll almost always be
interested in using the values

00:54:06.540 --> 00:54:08.300
key as the controller key.

00:54:08.480 --> 00:54:12.410
Some key path like values.name.

00:54:13.980 --> 00:54:16.130
With the object controller,
it's a little different.

00:54:16.210 --> 00:54:20.730
You're normally going to bind to the
selection in the object controller,

00:54:20.750 --> 00:54:24.580
which is always one object,
but still pretty useful.

00:54:25.870 --> 00:54:30.000
With the array, tree,
and dictionary controllers,

00:54:30.080 --> 00:54:34.180
since you can use these to populate
UI like table views and outline views,

00:54:34.220 --> 00:54:37.340
you'll either be binding
to the arranged objects dot

00:54:37.340 --> 00:54:40.960
something of these controllers,
if you're populating

00:54:40.960 --> 00:54:44.230
the columns of a view,
or if you're dealing

00:54:44.230 --> 00:54:46.670
with a single object,
a single control,

00:54:46.670 --> 00:54:50.380
like a checkbox or a single
text field outside of a table,

00:54:50.380 --> 00:54:55.750
then you're probably going to bind to a
key path like selection dot something.

00:54:56.300 --> 00:55:39.000
[Transcript missing]

00:55:39.740 --> 00:55:42.790
So multiple objects in the selection,
for example.

00:55:42.900 --> 00:55:45.700
But the accessors,
selected objects and content,

00:55:45.730 --> 00:55:46.290
are just that.

00:55:46.370 --> 00:55:47.480
They're accessors.

00:55:47.620 --> 00:55:48.380
They're not proxies.

00:55:48.380 --> 00:55:50.280
They don't have any special behavior.

00:55:50.300 --> 00:55:53.510
They don't do anything special
that's useful for some of these other

00:55:53.510 --> 00:55:55.900
bindings that we just showed you.

00:55:55.950 --> 00:55:57.140
They're really just arrays.

00:55:57.160 --> 00:56:00.740
And they're interesting from the
standpoint of getting information out of

00:56:00.740 --> 00:56:04.330
the controller in just the array form.

00:56:09.150 --> 00:56:12.670
And when you subclass these controllers,
you're probably interested in a

00:56:12.670 --> 00:56:15.140
few things when you're subclassing.

00:56:15.300 --> 00:56:18.140
If you're subclassing any of the
object controller subclasses,

00:56:18.260 --> 00:56:20.330
meaning array controller,
tree controller,

00:56:20.340 --> 00:56:24.780
or dictionary controller,
you're probably interested in handling

00:56:24.780 --> 00:56:27.260
the new object creation especially.

00:56:27.370 --> 00:56:30.890
So you can override the method
new object that deals with how new

00:56:30.890 --> 00:56:35.400
objects are added or created when
they're added to the controller.

00:56:35.850 --> 00:56:39.130
Another reason for subclassing
the array controller is you're

00:56:39.130 --> 00:56:43.260
interested in tweaking the way
filtering or sorting works by default.

00:56:43.340 --> 00:56:46.140
So you can override the
method arrange objects,

00:56:46.210 --> 00:56:50.080
which takes an array,
and you return an array

00:56:50.230 --> 00:56:51.990
of arranged objects.

00:56:52.550 --> 00:56:55.060
And for the dictionary controller,
you're probably going to

00:56:55.060 --> 00:56:56.710
want to override both.

00:56:56.830 --> 00:57:00.450
The new object method is where the
new key value pairs are created

00:57:00.510 --> 00:57:02.480
that are added to the array.

00:57:02.630 --> 00:57:06.160
And arrange objects is also
available if you want to do custom

00:57:06.170 --> 00:57:08.170
filtering and sorting again.

00:57:09.730 --> 00:57:13.260
Subclassing the Tree Controller got
more interesting with Leopard.

00:57:13.270 --> 00:57:18.950
We added some methods for navigating
the model objects in a special way.

00:57:19.090 --> 00:57:22.940
Normally, in Tiger,
you only had one option as far

00:57:22.940 --> 00:57:27.220
as key paths for navigating
through your model objects.

00:57:27.250 --> 00:57:32.050
And you usually had to create
extra accessors or categories

00:57:32.050 --> 00:57:34.400
in order to make this work.

00:57:34.440 --> 00:57:38.410
Now you can subclass the
Tree Controller and have some

00:57:38.620 --> 00:57:41.930
say on a per-object basis,
getting the represented object

00:57:42.030 --> 00:57:46.250
out of a node and figure out what
the correct children or leaf or

00:57:46.250 --> 00:57:49.950
count key path for that object is.

00:57:52.170 --> 00:57:55.720
And I've said it before,
I want to make sure everybody's heard it.

00:57:55.720 --> 00:58:00.850
The actions that we hooked up to
these buttons in Interface Builder,

00:58:00.850 --> 00:58:03.610
they're meant for being
used in Interface Builder,

00:58:03.620 --> 00:58:03.930
right?

00:58:03.940 --> 00:58:06.580
If you send an array
controller an add message,

00:58:06.590 --> 00:58:09.220
like the one you have here,
the action method,

00:58:09.220 --> 00:58:12.880
then you're going to be surprised
when you immediately ask for the

00:58:12.880 --> 00:58:15.200
count of objects in the controller.

00:58:15.200 --> 00:58:16.540
They won't have changed.

00:58:16.540 --> 00:58:21.790
These methods do their work delayed,
so you'll have to wait.

00:58:22.100 --> 00:58:26.120
There are methods, though,
there are analogs for each of these

00:58:26.240 --> 00:58:28.480
that do their work immediately.

00:58:28.480 --> 00:58:32.540
So instead of add,
you can use the add object method

00:58:32.540 --> 00:58:36.670
and add an object directly,
similar to the remove object at

00:58:36.670 --> 00:58:40.540
index sort of methods that are
available on all the controllers.

00:58:40.540 --> 00:58:43.860
Basically, anything that takes a
sender on the controllers,

00:58:43.860 --> 00:58:46.160
you won't see the effects immediately.

00:58:46.160 --> 00:58:52.080
That's done so that we can, by default,
produce some UI in Sheets.

00:58:52.100 --> 00:58:56.030
Sheets displaying any errors that
happened while we tried to do the work.

00:58:59.650 --> 00:59:05.440
So wrapping up the final bits,
some practical info about using bindings.

00:59:05.440 --> 00:59:09.450
If you ever see an error
like this in your log,

00:59:09.970 --> 00:59:13.170
Well, it doesn't really tell you anything
other than something didn't have a

00:59:13.240 --> 00:59:17.020
key value coding key for something.

00:59:17.030 --> 00:59:20.260
If you turn on a default though,
and it's binding debug log level

00:59:20.620 --> 00:59:22.560
to anything greater than one,
there's really only one

00:59:22.560 --> 00:59:23.380
log level right now.

00:59:23.500 --> 00:59:27.150
Then we'll log a little
bit more information that

00:59:27.190 --> 00:59:30.900
describes like which key path,
which object,

00:59:30.930 --> 00:59:35.560
and which object you were trying to bind,
which object was involved,

00:59:35.580 --> 00:59:38.480
like the text field that
was involved in the binding.

00:59:38.500 --> 00:59:40.500
Like what failed.

00:59:40.500 --> 00:59:42.970
So you'll get a little bit more
information to try and track

00:59:42.970 --> 00:59:44.690
down where your bad key is.

00:59:48.550 --> 00:59:53.000
You might also see some errors like
this where an observer isn't key

00:59:53.000 --> 00:59:58.200
value coding or key value observing
compliant for some key path.

00:59:58.310 --> 01:00:00.190
And the same thing applies here.

01:00:00.190 --> 01:00:02.520
If you turn on the debug logging,
then we'll show you a

01:00:02.520 --> 01:00:05.650
little bit more information,
which key path was involved,

01:00:05.750 --> 01:00:09.700
the object that you were binding to,
and the object that was bound.

01:00:09.840 --> 01:00:15.210
So this might help in tracking down
any bad key paths or bad bindings.

01:00:16.020 --> 01:00:21.470
And remember that trying to observe
directly like key or name on an

01:00:21.470 --> 01:00:23.970
array or a set isn't supported.

01:00:24.120 --> 01:00:25.870
Don't observe the collection.

01:00:25.920 --> 01:00:27.900
Try and observe the relationship.

01:00:27.900 --> 01:00:30.870
So the owning object is what
you should be observing.

01:00:30.960 --> 01:00:36.380
So observe a person's photos,
not the array of photos directly.

01:00:40.270 --> 01:00:45.700
And another thing that you might see is
that while trying to dealloc an object,

01:00:45.750 --> 01:00:48.750
there were still key value observing
observers registered with it.

01:00:48.900 --> 01:00:53.220
Remember that trying to unbind or
unregister observers in dealloc

01:00:53.540 --> 01:00:55.090
of your object is too late.

01:00:55.260 --> 01:00:59.670
You actually need to have some cleanup
code like commonly in your Windows,

01:00:59.670 --> 01:01:03.260
window will close or your
window controller methods.

01:01:03.310 --> 01:01:08.350
You can tear down all of the
bindings using the unbind method.

01:01:09.860 --> 01:01:12.630
A note about circular references.

01:01:12.720 --> 01:01:18.760
So in bindings, the bound object retains
the object it's bound to.

01:01:18.760 --> 01:01:22.930
So that means that for our text field
with a value binding that's bound to

01:01:22.930 --> 01:01:28.530
an object or user defaults controller,
then the text field will

01:01:28.530 --> 01:01:29.760
retain the controller.

01:01:29.760 --> 01:01:33.740
And going down,
if you bound the content of

01:01:33.740 --> 01:01:39.280
the controller to file's owner,
hypothetically, the object controller

01:01:39.280 --> 01:01:39.780
will retain the object.

01:01:39.800 --> 01:01:40.800
And that's what we call a bound
object retains the object.

01:01:40.800 --> 01:01:45.160
So if you have a setter,
you have an outlet to

01:01:45.160 --> 01:01:49.480
the object controller,
and your setter retains the controller.

01:01:49.480 --> 01:01:50.520
I mean, what else would it do?

01:01:50.520 --> 01:01:53.170
You've suddenly got a retain cycle.

01:01:53.170 --> 01:01:57.550
So that means you'll be leaking parts
of your UI if you close this window,

01:01:57.570 --> 01:01:58.200
right?

01:01:58.220 --> 01:02:02.400
Or you could get spurious messages,
key value observing messages.

01:02:02.400 --> 01:02:06.570
It's important that you break this
retain cycle using something like

01:02:06.600 --> 01:02:11.750
unbind or setting the content of the
controller to nil before trying to

01:02:11.800 --> 01:02:14.630
get rid of the rest of your UI here.

01:02:14.930 --> 01:02:20.380
Something to note,
on applications linked on or after Tiger,

01:02:20.380 --> 01:02:23.470
if files owner is a window
controller subclass,

01:02:23.470 --> 01:02:24.850
this should just work.

01:02:24.850 --> 01:02:28.350
And also, this should just work if
you use garbage collection,

01:02:28.350 --> 01:02:28.890
right?

01:02:32.370 --> 01:02:33.150
Okay.

01:02:33.330 --> 01:02:37.680
And please, in order for bindings to
do its work efficiently,

01:02:37.680 --> 01:02:39.930
it uses key value observing a lot.

01:02:39.970 --> 01:02:43.900
So if you make changes in a non-key
value observing compliant manner,

01:02:43.900 --> 01:02:47.830
we're probably not going to get the
notification that anything changed.

01:02:47.830 --> 01:02:50.940
And so suddenly you'll see
your UI has stopped updating.

01:02:50.940 --> 01:02:54.150
So make sure that all of the
changes in your objects that you're

01:02:54.150 --> 01:02:57.860
interested in putting into your view,
those changes have to be done in a

01:02:57.880 --> 01:03:00.200
key value observing compliant manner.

01:03:00.840 --> 01:03:02.920
There's lots of documentation
on what that means.

01:03:02.930 --> 01:03:03.930
Please take a look.

01:03:05.300 --> 01:03:09.980
So I mentioned that bindings,
a binding is a contract between two

01:03:09.980 --> 01:03:13.520
objects where you're keeping the
property of one object in sync with

01:03:13.560 --> 01:03:15.500
the property of another object.

01:03:15.530 --> 01:03:18.000
And that's the core concept
behind Cocoa bindings,

01:03:18.000 --> 01:03:18.330
right?

01:03:18.410 --> 01:03:19.580
That's what we're trying to achieve.

01:03:20.360 --> 01:03:24.660
But you have,
you as the owner of these UIs have a part

01:03:24.660 --> 01:03:28.140
of that contract to uphold yourselves.

01:03:28.170 --> 01:03:31.970
That is,
make changes in the right places.

01:03:31.980 --> 01:03:36.570
So it'd be breaking the contract
to try and change the value of

01:03:36.750 --> 01:03:41.740
your model objects by going through
the setter in your text field and

01:03:41.740 --> 01:03:47.340
hoping that the binding will push
the value down to your model object.

01:03:47.360 --> 01:03:50.080
The text field takes user events.

01:03:50.260 --> 01:03:53.020
The binding pushes the resulting
values down to the model objects.

01:03:53.020 --> 01:03:55.990
If you want to make changes
to values in your controller,

01:03:55.990 --> 01:03:58.130
make changes there in the controller.

01:03:58.130 --> 01:04:01.030
Or you can make changes
directly on the model objects.

01:04:01.240 --> 01:04:05.600
Don't try and go in a circular route
through your user interface elements.

01:04:07.400 --> 01:04:10.740
There's some important information
that you can check the documentation

01:04:10.740 --> 01:04:14.060
about the other bindings methods,
the other key value binding methods.

01:04:14.060 --> 01:04:16.160
Bind is an important one.

01:04:16.160 --> 01:04:18.400
Equally important is unbind.

01:04:18.400 --> 01:04:22.420
There's also the info for binding method,
which gives you some information

01:04:22.430 --> 01:04:26.570
about established bindings,
which is great for being able to validate

01:04:26.580 --> 01:04:29.120
parts of your UI are actually hooked up.

01:04:29.120 --> 01:04:31.020
You can use this programmatically.

01:04:31.240 --> 01:04:35.710
And please take a look at the
NS Editor and NS Editor Registration

01:04:35.710 --> 01:04:39.290
informal protocols,
which bindings use a lot to make

01:04:39.290 --> 01:04:43.490
sure that things like changes in your
text fields are actually sent down

01:04:43.600 --> 01:04:46.900
to your controllers and your model
objects when you close a window,

01:04:46.900 --> 01:04:47.620
for example.

01:04:49.510 --> 01:04:55.180
So the summary,
Cocoa Bindings is at its core two things.

01:04:55.180 --> 01:04:58.360
A collection of reusable
controller classes and an

01:04:58.400 --> 01:05:03.170
API for establishing bindings,
keeping the property of one object in

01:05:03.170 --> 01:05:05.600
sync with the property of another object.

01:05:05.670 --> 01:05:06.690
That's the core concept.

01:05:07.720 --> 01:05:11.200
And I want everybody to take a look at
some of the new features in Leopard.

01:05:11.200 --> 01:05:13.880
The NS Tree node,
NS Tree controller changes,

01:05:13.930 --> 01:05:15.940
the new dictionary controller.

01:05:15.940 --> 01:05:19.100
We've also added a new binding
option to the pop-up button that

01:05:19.100 --> 01:05:20.960
I didn't get a chance to show you.

01:05:20.960 --> 01:05:23.180
All this stuff is well documented.

01:05:23.230 --> 01:05:27.320
And for more information, see Derek.

01:05:27.350 --> 01:05:28.830
Actually, where is Derek?

01:05:30.710 --> 01:05:32.840
Well, find Derek.

01:05:32.880 --> 01:05:38.540
There's plenty of sample code
for these things as well,

01:05:38.540 --> 01:05:39.520
good documentation.

01:05:39.520 --> 01:05:43.100
And if you want to ask
more questions about it,

01:05:43.100 --> 01:05:46.050
there's a practice lab,
Cocoa Bindings and

01:05:46.110 --> 01:05:49.840
Practice Lab on Thursday,
Core Data Lab on Thursday as well.

01:05:49.840 --> 01:05:51.430
There's an AppKit lab.

01:05:51.430 --> 01:05:53.270
Wow, all the labs are on Thursday.

01:05:53.270 --> 01:05:53.870
Good Lord.

01:05:53.900 --> 01:05:56.500
So live in the lab on Thursday.
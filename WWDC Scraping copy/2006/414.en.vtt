WEBVTT

00:00:11.130 --> 00:00:12.600
Welcome, everybody.

00:00:12.600 --> 00:00:17.100
This is the last session of the day,
Daemon Wrangling with Launchd.

00:00:17.610 --> 00:00:19.260
It's actually more generic than that.

00:00:19.400 --> 00:00:22.440
We're going to be talking about
process management in general.

00:00:22.440 --> 00:00:25.390
So first, what is launchd?

00:00:25.550 --> 00:00:26.870
It's a rocket launcher.

00:00:27.870 --> 00:00:30.340
Catapult, now.

00:00:30.350 --> 00:00:34.260
It's a program to bootstrap
and manage other programs.

00:00:34.280 --> 00:00:39.870
Now, I'd like to know,
before we get too deep into the session,

00:00:40.570 --> 00:00:46.460
are you a developer or
are you a sysaadmin?

00:00:46.610 --> 00:00:48.940
Let's do developers first.

00:00:48.950 --> 00:00:49.780
All right.

00:00:49.810 --> 00:00:52.120
Now let's do sysaadmins.

00:00:52.120 --> 00:00:53.940
OK, so some of you do both daemon.

00:00:54.020 --> 00:00:55.750
Awesome.

00:00:56.090 --> 00:00:58.880
Like I said, we're going to cover
issues for both of you.

00:00:58.890 --> 00:01:02.520
Launchd is both technologies.

00:01:03.010 --> 00:01:06.200
Now, why did we do launchd?

00:01:06.370 --> 00:01:09.200
Isn't this just another
reinvention of the wheel?

00:01:09.240 --> 00:01:10.720
We had extensions.

00:01:10.980 --> 00:01:15.180
We had Unix's etc.rc.d directory.

00:01:15.200 --> 00:01:18.320
And we had Mac OS X startup items.

00:01:18.810 --> 00:01:21.040
What are the advantages?

00:01:21.090 --> 00:01:23.390
Well, I'd like to bring
Kevin Van Vechten on stage.

00:01:23.450 --> 00:01:27.690
He worked on System Starter in
the Mac OS X days beforehand,

00:01:27.690 --> 00:01:29.940
and he's had a lot of experience
with other operating systems.

00:01:29.940 --> 00:01:35.000
He's my sounding board and my manager,
and he will explain the big picture.

00:01:35.210 --> 00:01:36.810
Welcome, Kevin.

00:01:41.230 --> 00:01:42.820
Thank you.

00:01:42.820 --> 00:01:48.170
So remember about five years ago now,
there was a huge push for Mac OS X.

00:01:48.170 --> 00:01:51.670
And Mac OS X was billed as
Unix for the rest of us.

00:01:51.700 --> 00:01:53.160
It had a lot of great features.

00:01:53.160 --> 00:01:57.710
It had a lot of things that made
it modern compared to Mac OS 9.

00:01:57.730 --> 00:02:00.720
Virtualized address space,
protected memory,

00:02:00.720 --> 00:02:04.670
inter-process communication between
those protected address spaces.

00:02:04.670 --> 00:02:06.750
Preemptive multitasking was a big one.

00:02:06.760 --> 00:02:09.610
And then, of course,
we pushed to a callback model

00:02:09.610 --> 00:02:11.120
as opposed to a polling model.

00:02:11.200 --> 00:02:13.450
for event delivery.

00:02:13.890 --> 00:02:18.510
So it was, all these things are true and
it was a very modern system.

00:02:18.510 --> 00:02:21.650
But a couple years ago,
I remember we had Year of the Notebook.

00:02:21.650 --> 00:02:24.450
And an interesting thing happened
in the Year of the Notebook.

00:02:24.520 --> 00:02:28.920
It really made it obvious that hardware
had become more modern than Unix was.

00:02:28.920 --> 00:02:32.720
Hardware had a lot of hot
plug devices like FireWire,

00:02:32.720 --> 00:02:35.780
USB, Ethernet, AirPort, even SATA.

00:02:35.790 --> 00:02:38.680
So devices can come and go all the time.

00:02:38.680 --> 00:02:45.150
You have dynamic protocols, DHCP, LDAP,
so a user group that might have been

00:02:45.150 --> 00:02:48.500
defined a moment ago on your system,
could have just been revoked,

00:02:48.510 --> 00:02:50.170
or perhaps somebody new was added.

00:02:50.170 --> 00:02:54.470
Or your IP address could get changed
because your DHCP lease expired.

00:02:54.570 --> 00:02:59.680
And these were things that Unix is not
accustomed to dealing with historically.

00:03:00.170 --> 00:03:03.420
So there were a lot of historical
artifacts that were really no longer

00:03:03.420 --> 00:03:09.580
applicable in this new world of
completely dynamic mobile computers.

00:03:09.880 --> 00:03:13.520
Taking, for example,
the etsy.fs.tab file.

00:03:13.700 --> 00:03:18.920
This is a text file that describes what
disks should be mounted on your system.

00:03:18.970 --> 00:03:21.760
Well, this really doesn't make very much
sense when you have FireWire disks

00:03:21.760 --> 00:03:25.860
and USB disks that can be plugged
and unplugged at a moment's notice.

00:03:25.930 --> 00:03:30.570
Applications like the Finder, the system,
they really need to adapt dynamically

00:03:30.970 --> 00:03:34.570
to look for files that are on
these disks when they appear and

00:03:34.620 --> 00:03:37.860
to gracefully forget about these
files when the disks disappear.

00:03:37.870 --> 00:03:42.670
Or ask the user to reattach a disk that
was attached not a moment ago so you can

00:03:42.840 --> 00:03:45.530
finish doing whatever you needed to do.

00:03:45.870 --> 00:03:50.260
So if fstab wasn't really
applicable in this new world,

00:03:50.490 --> 00:03:52.060
is etcrc any different?

00:03:52.060 --> 00:03:54.850
I mean,
this is a script that choreographed

00:03:54.970 --> 00:03:56.230
the startup of the system.

00:03:56.230 --> 00:03:59.810
But if disks come and go, well,
you can't really assume that

00:03:59.810 --> 00:04:03.350
they're going to be the same
disks there when you start up.

00:04:03.580 --> 00:04:05.790
Then 10 minutes later,
why assume that they're

00:04:05.790 --> 00:04:07.040
there at startup at all?

00:04:08.230 --> 00:04:12.170
And another big difference with
Mac OS X is unlike other Unix systems,

00:04:12.170 --> 00:04:16.960
there really isn't a dedicated system
administrator for most Mac OS X systems.

00:04:17.000 --> 00:04:19.670
Most Mac OS X systems are
used by a single user,

00:04:19.670 --> 00:04:21.320
no administrator, really.

00:04:21.320 --> 00:04:24.760
There's nobody who can go in
and edit etcrc to adapt to

00:04:24.890 --> 00:04:26.790
whatever needs to be done.

00:04:26.790 --> 00:04:29.460
It's something that we
need to do dynamically.

00:04:29.500 --> 00:04:32.090
So launchd comes into the picture.

00:04:32.100 --> 00:04:37.320
What launchd provides is an unambiguous
way to declare dependencies.

00:04:38.040 --> 00:04:41.560
It's based on the actual
primitives that processes need

00:04:41.560 --> 00:04:43.920
to communicate with one another.

00:04:43.920 --> 00:04:46.230
If there's a dependency
between two processes,

00:04:46.230 --> 00:04:49.380
they must be doing something
that allows them to collaborate.

00:04:49.380 --> 00:04:52.220
Maybe they're sending
information across a socket.

00:04:52.230 --> 00:04:55.680
Maybe they're both looking for
the existence of a common file.

00:04:55.680 --> 00:04:58.220
Maybe they're sending
Mach messages over Mach ports.

00:04:58.220 --> 00:05:01.790
But the fundamental idea here is
it's not good enough to just say this

00:05:01.790 --> 00:05:04.140
process depends on that other process.

00:05:04.140 --> 00:05:06.920
You really need to think about why
does it depend on that process?

00:05:06.920 --> 00:05:08.020
What is the OS?

00:05:08.020 --> 00:05:10.010
What is the Mac OS 10's
best mechanism that's using?

00:05:10.010 --> 00:05:11.650
What is the manifestation
of the dependency?

00:05:11.760 --> 00:05:14.320
And if you can describe the
dependencies in those terms,

00:05:14.320 --> 00:05:17.390
then they're not ambiguous and you
can be very certain about when that

00:05:17.390 --> 00:05:19.220
dependency has been fulfilled or not.

00:05:20.980 --> 00:05:24.320
In a sense,
launchd is really kind of like

00:05:24.490 --> 00:05:28.680
a process factory for processes,
if you're used to

00:05:28.680 --> 00:05:29.890
object-oriented programming.

00:05:29.900 --> 00:05:36.070
You issue requests either by sending
data to a socket or creating a file,

00:05:36.070 --> 00:05:40.780
and launchd will notice this
activity and then automatically

00:05:40.930 --> 00:05:43.900
launch on demand a program for you.

00:05:43.900 --> 00:05:46.750
It's a factory for these processes.

00:05:47.930 --> 00:05:51.880
So this means that we can
now virtualize our processes.

00:05:51.950 --> 00:05:54.630
You don't actually have to
have this MySQL daemon running

00:05:54.630 --> 00:05:56.250
or the X11 server running.

00:05:56.250 --> 00:05:59.240
You just have to have a socket
there that could be written to.

00:05:59.350 --> 00:06:02.160
And as soon as an application
writes to it for the first time,

00:06:02.160 --> 00:06:05.070
launchd can notice and launch
that application on demand.

00:06:05.120 --> 00:06:07.990
This means that you're using
less resources at idle time.

00:06:07.990 --> 00:06:11.580
And only when you're actually using
a service does it become available.

00:06:11.580 --> 00:06:14.150
But it also means that you
don't have to worry about the

00:06:14.150 --> 00:06:16.520
service not being available.

00:06:16.570 --> 00:06:18.260
Because it's always there virtually.

00:06:18.360 --> 00:06:23.700
It just may or not be backed by an
actual process at any given time.

00:06:24.100 --> 00:06:26.720
In this respect,
launchd is really a process superclass.

00:06:26.720 --> 00:06:30.400
It takes care of a lot of the things
that background processes need to do.

00:06:30.400 --> 00:06:32.100
No longer do you need to daemonize.

00:06:32.100 --> 00:06:37.160
It can take care of all the steps
of changing your standard out,

00:06:37.160 --> 00:06:38.900
standard error, standard in.

00:06:38.900 --> 00:06:41.210
And really,
you just go right out the gate

00:06:41.210 --> 00:06:44.310
from the main function in your
program and you're ready to be run

00:06:44.320 --> 00:06:48.120
as a background process and you've
been launched on demand by launchd.

00:06:48.410 --> 00:06:51.440
And launchd manages all these processes.

00:06:51.440 --> 00:06:53.840
It can keep them alive if that's
what you've requested to do,

00:06:53.840 --> 00:06:56.010
so if your process exits,
maybe it'll get launched

00:06:56.070 --> 00:06:56.840
again automatically.

00:06:56.840 --> 00:06:59.220
Or maybe it's only supposed
to run once and exit,

00:06:59.220 --> 00:07:02.680
and that's fine,
launchd won't run it again.

00:07:02.890 --> 00:07:05.560
It's taken a very
central role in Mac OS X.

00:07:05.560 --> 00:07:09.880
Launchd is not just a process
manager like iNetD or xInetD

00:07:09.880 --> 00:07:13.620
for which it has compatibility,
but it's actually PID1 in Mac OS X.

00:07:13.620 --> 00:07:15.380
We don't have init anymore.

00:07:15.380 --> 00:07:18.120
Launchd has subsumed all
the functionality that init

00:07:18.120 --> 00:07:19.880
provides on other Unix systems.

00:07:20.000 --> 00:07:23.700
And now in Leopard,
we've really enhanced the integration so

00:07:23.700 --> 00:07:28.630
much that there's at least 100 different
jobs in launchd for the different

00:07:28.820 --> 00:07:30.880
services that the system provides.

00:07:31.070 --> 00:07:34.950
Things like the
Windows server or SSH daemon,

00:07:35.230 --> 00:07:36.840
that type of thing.

00:07:36.860 --> 00:07:39.960
And we're growing this list every week.

00:07:40.070 --> 00:07:43.640
More and more services within Apple are
being converted over to using launchd.

00:07:43.640 --> 00:07:46.070
So it's becoming very
pervasive in the system,

00:07:46.070 --> 00:07:49.680
and we think it really makes sense
for you to use launchd when deciding

00:07:49.820 --> 00:07:53.230
how and when your applications
should be launched automatically.

00:07:55.470 --> 00:07:57.380
So launchd is open source.

00:07:57.520 --> 00:07:59.780
It does play a very
pivotal role in Mac OS X.

00:07:59.780 --> 00:08:01.160
We want you to see how it works.

00:08:01.160 --> 00:08:04.000
We want you to be very
familiar with launchd.

00:08:04.040 --> 00:08:07.140
And we're also very pleased to
announce now that launchd is available

00:08:07.270 --> 00:08:09.180
under the Apache 2.0 license.

00:08:09.220 --> 00:08:12.100
And we would love to see launchd--

00:08:13.260 --> 00:08:16.510
We would love to see launchd be
adopted by other operating systems,

00:08:16.510 --> 00:08:21.320
whether it be FreeBSD or Linux or
anyone else who's interested.

00:08:21.370 --> 00:08:24.650
And of course,
we would love to see standard system

00:08:24.670 --> 00:08:28.400
daemons that are found on all these
various platforms adopt launchd

00:08:28.400 --> 00:08:30.800
for their process management needs.

00:08:30.800 --> 00:08:36.200
And there's a new project page,
launchd.macosforge.org.

00:08:36.240 --> 00:08:37.420
There's a blog there.

00:08:37.420 --> 00:08:40.630
That's where we'll be posting
links to updated sources to

00:08:40.660 --> 00:08:42.500
launchd and news about launchd.

00:08:42.500 --> 00:08:45.040
And hopefully,
if any other systems are interested,

00:08:45.040 --> 00:08:48.480
that's where you can find resources
about porting it to other systems.

00:08:50.570 --> 00:08:52.940
So again, why launchd?

00:08:53.010 --> 00:08:57.130
Well, previously, OS designs were really
kind of a house of cards.

00:08:57.140 --> 00:09:01.980
You were either relying
on handcrafted ordering.

00:09:01.990 --> 00:09:04.640
So some administrator had
to think in their head,

00:09:04.640 --> 00:09:07.060
OK, what's the order all these
things should happen,

00:09:07.080 --> 00:09:08.260
encode that in a file.

00:09:08.260 --> 00:09:10.090
And if anything changed,
you'd have to remember to go into

00:09:10.180 --> 00:09:11.720
the file and edit it and update it.

00:09:11.950 --> 00:09:15.810
And so that's a bit tedious.

00:09:15.990 --> 00:09:19.740
It also means that if one step got wrong,
then that failure could cascade quickly,

00:09:19.740 --> 00:09:22.460
and you might end up in a completely
different place than you wanted to be

00:09:22.460 --> 00:09:25.120
just because you forgot about one step.

00:09:25.130 --> 00:09:26.640
So Apple had some goals.

00:09:26.640 --> 00:09:28.240
We needed resiliency.

00:09:28.240 --> 00:09:30.180
We needed recovery from failure.

00:09:30.180 --> 00:09:33.510
We needed to not rely on assumptions
about what the hardware would look like,

00:09:33.560 --> 00:09:38.420
because with FireWire and
USB and 802.11 wireless,

00:09:38.420 --> 00:09:40.930
we really don't have much we can assume.

00:09:41.190 --> 00:09:44.880
Things can look very, very different from
one minute to the next.

00:09:44.890 --> 00:09:48.610
So we're really encouraging a model
where applications are robust,

00:09:48.610 --> 00:09:52.540
they respond to errors gracefully,
they try to perform some action.

00:09:52.540 --> 00:09:55.620
And if it doesn't work at the time,
they have to deal with that.

00:09:55.620 --> 00:09:59.290
And hopefully,
you can try again later and succeed.

00:10:00.400 --> 00:10:04.150
Also, as I've mentioned before,
we really encourage a model of

00:10:04.150 --> 00:10:07.600
using callbacks for notifications
of when services and events happen.

00:10:07.600 --> 00:10:11.300
We really don't want polling
to occur on the system.

00:10:12.040 --> 00:10:15.400
So, again, you may be thinking, well,
what was wrong with System Starter?

00:10:15.400 --> 00:10:18.600
System Starter didn't require
you to edit a net CRC file,

00:10:18.600 --> 00:10:20.380
and you could just
install your startup item,

00:10:20.380 --> 00:10:21.520
and that worked, right?

00:10:21.520 --> 00:10:22.960
Well, it kind of worked.

00:10:23.040 --> 00:10:25.630
There were some problems with it, though.

00:10:25.640 --> 00:10:30.820
One is that System Starter used what we
call explicit out-of-band dependencies.

00:10:30.820 --> 00:10:33.810
There was a list of strings
in a startup item that said,

00:10:34.000 --> 00:10:36.970
here's what I require,
and here's what I provide.

00:10:36.980 --> 00:10:39.700
And System Starter would order
those in a reasonable fashion.

00:10:40.600 --> 00:10:43.870
But this is error-prone,
because the dependency strings, well,

00:10:43.870 --> 00:10:45.410
they could be overstated.

00:10:45.420 --> 00:10:49.190
So, perhaps somebody in
their startup item says,

00:10:49.190 --> 00:10:53.060
I depend on the network,
I depend on the LDAP server,

00:10:53.060 --> 00:10:55.360
I depend on the X11 server.

00:10:55.360 --> 00:10:56.340
And guess what?

00:10:56.460 --> 00:10:58.840
They didn't really depend
on the LDAP server.

00:10:58.840 --> 00:11:00.600
But it's listed there.

00:11:00.600 --> 00:11:03.340
System Starter has no way to
know that that's a false entry.

00:11:03.340 --> 00:11:06.280
So,
it'll affect the ordering of the items.

00:11:06.280 --> 00:11:08.660
Sometimes dependencies were understated.

00:11:09.300 --> 00:11:12.300
Sometimes somebody would say, well,
I depend on the web server.

00:11:12.300 --> 00:11:17.540
And at that time, the web server also
depended on the network.

00:11:17.660 --> 00:11:21.170
So, the network would be up when
the web server item launched,

00:11:21.240 --> 00:11:22.670
and then eventually your
item would get launched,

00:11:22.670 --> 00:11:23.720
and everything would be happy.

00:11:23.720 --> 00:11:26.120
But if we ever changed that,
if we ever said, oh, well,

00:11:26.120 --> 00:11:29.040
we can go ahead and launch the web
server before the network comes up,

00:11:29.180 --> 00:11:32.200
because it'll be accessible
on the local host IP,

00:11:32.200 --> 00:11:32.840
right?

00:11:32.840 --> 00:11:36.440
Well, you don't have that network
dependency captured anymore.

00:11:36.440 --> 00:11:38.750
So, maybe that's not really what
you wanted to have happen.

00:11:39.300 --> 00:11:41.750
So,
assuming dependencies by virtue of other

00:11:41.750 --> 00:11:45.530
dependencies is really error-prone,
and it really tied our hands in

00:11:45.540 --> 00:11:49.080
changing what the startup items did,
because we didn't know what

00:11:49.150 --> 00:11:52.240
parts of the startup item people
were really depending on or not.

00:11:52.280 --> 00:11:55.030
And, believe it or not,
System Starter actually had

00:11:55.100 --> 00:11:56.940
some pretty bad race conditions.

00:11:57.020 --> 00:11:59.160
What do I mean by this?

00:11:59.160 --> 00:12:02.880
Well, historically,
most Unix background processes called

00:12:03.140 --> 00:12:05.940
the daemon call to background themselves.

00:12:07.820 --> 00:12:11.040
If we show a little timeline,
this could cause a problem.

00:12:11.090 --> 00:12:14.010
If you have System Starter running,
and you go ahead and

00:12:14.130 --> 00:12:17.080
launch a startup item,
then the example daemon's

00:12:17.080 --> 00:12:18.380
in its main routine.

00:12:18.420 --> 00:12:21.780
And that is a child directly
of that startup item.

00:12:21.830 --> 00:12:24.940
However,
if it goes ahead and calls daemon,

00:12:24.970 --> 00:12:27.900
System Starter's waiting
for the child process.

00:12:28.160 --> 00:12:30.190
But now the child process
is just about to exit,

00:12:30.220 --> 00:12:32.660
and it's the daemon that's
going to continue living.

00:12:32.700 --> 00:12:37.080
Which means, at the same time the
child starts running,

00:12:37.200 --> 00:12:40.460
the parent reclaims the process.

00:12:40.460 --> 00:12:43.980
And so now what you have is
System Starter possibly concurrently

00:12:44.010 --> 00:12:47.670
spawning the next startup item,
at the same instant that the actual

00:12:47.910 --> 00:12:50.240
previous startup item started running.

00:12:50.380 --> 00:12:52.060
Which means the dependency
really wasn't fulfilled.

00:12:52.180 --> 00:12:55.570
Now, through a bit of luck and the
fact that usually on Unix,

00:12:55.610 --> 00:12:58.260
the child process is the
first one to get scheduled,

00:12:58.290 --> 00:13:00.500
things tended to work,
but it really is coincidence

00:13:00.530 --> 00:13:01.870
that things worked at all.

00:13:01.930 --> 00:13:05.900
Launchd on the other hand,
doesn't want you to use daemon.

00:13:05.900 --> 00:13:08.890
It'll launch your process,
it's already backgrounded,

00:13:08.950 --> 00:13:11.700
all of the daemonization has
been taken care of for you.

00:13:11.760 --> 00:13:15.640
So Launchd can keep track of
when your process is ready,

00:13:15.650 --> 00:13:18.430
when your process is alive,
relaunch it if necessary.

00:13:18.670 --> 00:13:21.910
It's much more explicit,
it's much more controlled.

00:13:22.060 --> 00:13:24.800
So, like I said, these are possibly
running at the same time,

00:13:24.840 --> 00:13:30.710
which was not necessarily
the results that you wanted.

00:13:30.840 --> 00:13:32.460
So, I'll hand it back to Dave to
talk about the daemon.

00:13:32.460 --> 00:13:35.570
about the details of using LaunchD.

00:13:41.000 --> 00:13:42.380
All right, thank you, Kevin.

00:13:42.380 --> 00:13:44.120
All right,
now to get into the meat of things.

00:13:44.120 --> 00:13:46.420
I'm going to start with the big picture.

00:13:46.470 --> 00:13:47.920
What are we going to cover?

00:13:47.960 --> 00:13:51.640
For developers,
we're going to first talk about where

00:13:51.640 --> 00:13:56.500
your code fits in to the system,
because you've got to start somewhere.

00:13:56.600 --> 00:13:59.360
When does your code get involved?

00:13:59.690 --> 00:14:03.700
How does your code resolve dependencies
at a real nitty gritty level?

00:14:03.740 --> 00:14:06.970
And how does your code and your
daemon check in with launchd to

00:14:07.010 --> 00:14:08.980
solve the other end of the equation?

00:14:09.400 --> 00:14:14.380
For system administrators,
why launchd adoption is good for you?

00:14:15.410 --> 00:14:18.400
Now fitting into Mac OS X.

00:14:18.440 --> 00:14:21.300
We're cleaning the
OS up into basic layers.

00:14:21.300 --> 00:14:23.100
We were a little bit
fast and loose before.

00:14:23.100 --> 00:14:25.890
We're going to try and push people
into some very concrete layers.

00:14:25.900 --> 00:14:28.840
These are the layers
you're familiar with today.

00:14:28.840 --> 00:14:32.320
We kind of have per machine
things and per session things.

00:14:32.320 --> 00:14:36.480
You might find Safari, iTunes,
System UI Server running in your session.

00:14:36.480 --> 00:14:42.180
And you might find, you know, diskRBD,
kexD, configD running as a daemon.

00:14:43.060 --> 00:14:46.260
These are pretty defined buckets, but,
you know, through code,

00:14:46.260 --> 00:14:47.760
you can kind of blur the layers.

00:14:47.760 --> 00:14:50.860
And we're trying to actually begin
to enforce them and make sure

00:14:51.060 --> 00:14:53.060
people cleanly design their code.

00:14:53.060 --> 00:14:56.760
We're also investigating in Leopard,
but it isn't there yet,

00:14:56.820 --> 00:14:59.360
but we're investigating
it per user layer,

00:14:59.360 --> 00:15:01.100
which you may see someday.

00:15:01.100 --> 00:15:04.000
We expect things like iTunes agent,
iChat agent,

00:15:04.000 --> 00:15:06.100
Spotlight plugins to live there.

00:15:06.600 --> 00:15:10.010
Essentially, these programs would
transcend login sessions.

00:15:10.540 --> 00:15:12.930
So, you know,
just because you've logged out

00:15:12.930 --> 00:15:15.990
doesn't mean that some programs
running in the background changing

00:15:15.990 --> 00:15:19.770
disk stuff and we need your plugins
to analyze them for Spotlight or,

00:15:19.770 --> 00:15:23.730
you know, you might want to share your
iTunes songs after you log out.

00:15:23.870 --> 00:15:26.700
These are all, you know,
ideas we're experimenting with,

00:15:26.710 --> 00:15:28.470
but it's a layer that makes sense.

00:15:28.580 --> 00:15:31.220
And we hope we can help
you fit into that someday.

00:15:31.280 --> 00:15:35.060
Now, the relationship between the layers.

00:15:36.930 --> 00:15:39.560
Peer-to-peer or downward
inter-process communication is

00:15:39.560 --> 00:15:42.900
what we're encouraging to help
you create better design products.

00:15:42.930 --> 00:15:44.060
What does that look like?

00:15:44.080 --> 00:15:45.520
We have three basic layers.

00:15:45.610 --> 00:15:49.160
Recession at the top,
per user and per machine.

00:15:49.250 --> 00:15:50.810
So you have apps running at the top.

00:15:50.820 --> 00:15:54.860
You might have agents running in the
middle and daemons running on the bottom.

00:15:54.890 --> 00:15:56.480
And yeah, side to side, that's fine.

00:15:56.590 --> 00:15:57.500
You're in the same layer.

00:15:57.500 --> 00:16:00.960
Everybody's all friendly, buddy-buddy,
good stuff.

00:16:01.040 --> 00:16:05.180
But what we only want to see
is downward communication.

00:16:05.420 --> 00:16:08.490
You know,
an app can talk all the way to a daemon,

00:16:08.490 --> 00:16:10.640
or it can talk to an agent,
and the agent can talk to a daemon.

00:16:10.640 --> 00:16:13.400
The important part is it's down.

00:16:13.540 --> 00:16:14.980
Well, why is that?

00:16:15.100 --> 00:16:17.200
Why only downward?

00:16:17.500 --> 00:16:20.230
Well, we have a machine-wide context.

00:16:20.280 --> 00:16:21.840
There's one of those.

00:16:21.840 --> 00:16:23.300
Uh-oh.

00:16:23.400 --> 00:16:26.560
We have more than one user on the system,
possibly at the same time.

00:16:26.700 --> 00:16:30.900
We can have Bob's background problems
and Sally's background programs.

00:16:31.520 --> 00:16:33.260
There are many layers above a program.

00:16:33.290 --> 00:16:35.770
Knowing which one to
talk to is a problem.

00:16:35.990 --> 00:16:37.780
Whereas if you go downward,
it's implicit.

00:16:37.830 --> 00:16:39.490
You only have one per user context.

00:16:39.500 --> 00:16:42.690
You only have one machine-wide
context beneath you.

00:16:42.900 --> 00:16:45.700
In fact, if we look,
we have GUI sessions,

00:16:45.700 --> 00:16:47.800
we have command line sessions,
and we may have other

00:16:47.800 --> 00:16:49.200
sessions in the future.

00:16:49.290 --> 00:16:53.520
So trying to deal with the scenarios
where a new session is created

00:16:53.520 --> 00:16:57.440
above you that you may have never
heard of might throw you for a loop.

00:16:57.450 --> 00:17:01.080
And it's best if you can just push
as much code as possible up into the

00:17:01.210 --> 00:17:03.040
top so everything becomes implicit.

00:17:03.140 --> 00:17:06.170
If you need to draw UI,
have code running in a session.

00:17:06.230 --> 00:17:09.930
If you don't, maybe move it down a level.

00:17:11.320 --> 00:17:12.540
Exactly.

00:17:12.730 --> 00:17:16.020
Downward IPC encourages good design.

00:17:16.100 --> 00:17:18.640
So what are the purpose
of these containers?

00:17:18.660 --> 00:17:20.200
The per session?

00:17:20.360 --> 00:17:22.790
Thank you, interaction.

00:17:22.880 --> 00:17:25.320
Or programs that need to
come and go with the session.

00:17:25.320 --> 00:17:27.900
They just don't make sense otherwise.

00:17:27.950 --> 00:17:29.810
The per user?

00:17:29.950 --> 00:17:31.660
don't need UI at all.

00:17:31.690 --> 00:17:34.990
And if you need to transcend
a log in or log out,

00:17:35.040 --> 00:17:36.700
this is the perfect container for you.

00:17:36.740 --> 00:17:39.420
But you're still running as
the user in the user's context.

00:17:39.420 --> 00:17:42.420
A lot of things are still implicit
when it comes to permissions and

00:17:42.440 --> 00:17:46.160
access control and access to resources.

00:17:46.470 --> 00:17:47.770
And finally, per machine.

00:17:47.970 --> 00:17:50.260
This is one thing I'd
really like to stress.

00:17:50.410 --> 00:17:54.040
We're really trying to push people,
as they evolve their code bases,

00:17:54.120 --> 00:17:56.790
to keep the minimal code
required to arbitrate or

00:17:56.790 --> 00:17:58.530
share hardware in this layer.

00:17:58.800 --> 00:18:04.010
If it's doing anything more,
consider moving it up a level.

00:18:04.800 --> 00:18:09.260
This will be the best for security in
the long run for the product because

00:18:09.260 --> 00:18:11.990
that's the most risky container of all.

00:18:12.340 --> 00:18:14.020
So getting started.

00:18:14.020 --> 00:18:16.800
All right, that's great and all that
there's this high level vision.

00:18:16.800 --> 00:18:18.700
Let's get started.

00:18:18.700 --> 00:18:20.930
We need to install a property
list describing our job

00:18:20.940 --> 00:18:22.720
into the right location.

00:18:22.720 --> 00:18:24.860
Well, which location?

00:18:24.860 --> 00:18:28.430
If you went to the Unix talk before this,
you may have heard us talk about

00:18:28.470 --> 00:18:30.030
the Next style directories.

00:18:30.040 --> 00:18:31.920
One of them, for example, is /library.

00:18:31.920 --> 00:18:34.920
That's a local machine configuration.

00:18:34.920 --> 00:18:42.060
You can put per machine jobs
in library launch daemons.

00:18:42.060 --> 00:18:50.130
You can also put per user jobs or
per session jobs in network library

00:18:50.180 --> 00:18:54.180
if you want to put it across all
your machines out on the network.

00:18:54.180 --> 00:18:57.900
And you can put it in the local
machine if you only want the agents

00:18:57.900 --> 00:19:00.580
to apply to the users on that system.

00:19:00.580 --> 00:19:05.280
Or as a user yourself,
you can give yourself per user or per

00:19:05.280 --> 00:19:08.960
session agents that only apply to you.

00:19:09.030 --> 00:19:11.810
Think like cron jobs and whatnot,
all these little jobs

00:19:11.870 --> 00:19:13.500
that just apply to you.

00:19:13.500 --> 00:19:15.090
You can put them in your
home directory and launch,

00:19:15.120 --> 00:19:16.870
and it'll pick them up.

00:19:17.530 --> 00:19:19.600
Well,
what does a property list look like?

00:19:19.600 --> 00:19:22.620
It looks like this yummy XML goodness.

00:19:22.650 --> 00:19:25.820
But we're not going to dwell
on that slide for a second.

00:19:25.820 --> 00:19:29.710
The real meat of that is you
need three keys and three values.

00:19:29.740 --> 00:19:32.160
You need a label,
which uniquely identifies the job

00:19:32.160 --> 00:19:35.740
to launchd and a string that we can
actually print out on the command line.

00:19:35.740 --> 00:19:38.820
And it's just better for everyone
if we can actually give it a name.

00:19:38.820 --> 00:19:40.570
We have program arguments.

00:19:40.570 --> 00:19:43.130
It's the pre-tokenized array of strings.

00:19:43.170 --> 00:19:46.620
It corresponds exactly to
that second argument of main.

00:19:46.620 --> 00:19:48.680
This trips people up occasionally.

00:19:48.680 --> 00:19:52.110
So they might,
in one of the array arguments,

00:19:52.110 --> 00:19:56.510
say dash c space some file,
not realizing it needs to be dash

00:19:56.510 --> 00:19:59.020
c is one element in the array.

00:19:59.020 --> 00:20:01.180
And then the actual next
argument is the next one.

00:20:01.200 --> 00:20:04.220
So you've got to map how you
think about things in your head

00:20:04.220 --> 00:20:07.980
as arguments to how they actually
come out in the argument vector.

00:20:09.980 --> 00:20:11.650
And finally, on demand.

00:20:11.710 --> 00:20:14.010
The most simplest case of
a launchd job just keeps a

00:20:14.090 --> 00:20:15.380
program running all the time.

00:20:15.550 --> 00:20:17.230
There's no on demand-ness to it.

00:20:17.320 --> 00:20:19.240
So you need to actually
tell launchd that,

00:20:19.280 --> 00:20:21.950
because the default is to
have jobs be on demand.

00:20:22.020 --> 00:20:23.600
So set it to false.

00:20:23.610 --> 00:20:25.080
Launchd goes, OK.

00:20:25.110 --> 00:20:29.610
And just keeps the job alive as
long as it's loaded into launchd.

00:20:31.200 --> 00:21:58.200
[Transcript missing]

00:21:58.550 --> 00:21:59.480
Net dependencies.

00:21:59.510 --> 00:22:01.400
Kevin talked about them
at a big picture level.

00:22:01.400 --> 00:22:02.860
Let's talk about them at the low level.

00:22:02.860 --> 00:22:05.510
Forget everything you
knew about Bootstrap.

00:22:05.540 --> 00:22:07.440
System starter and all that?

00:22:07.520 --> 00:22:07.900
No.

00:22:07.900 --> 00:22:09.310
We're doing it differently.

00:22:09.310 --> 00:22:11.490
Programmers work with contracts.

00:22:11.490 --> 00:22:13.340
That's our bread and butter.

00:22:13.340 --> 00:22:16.330
Contracts define expectations
and promises between the

00:22:16.330 --> 00:22:18.060
producers and the consumers.

00:22:18.060 --> 00:22:20.700
There are two kinds of
contracts when programming.

00:22:20.700 --> 00:22:24.050
There's programmatic,
what most people are familiar with,

00:22:24.050 --> 00:22:26.340
and it's every API you've ever used.

00:22:26.350 --> 00:22:28.150
There's also data-driven.

00:22:28.400 --> 00:22:29.400
There's a lot of data.

00:22:29.400 --> 00:22:32.370
And all the P lists we're talking about,
that's the contract you have

00:22:32.370 --> 00:22:34.160
with launchd about your job.

00:22:34.160 --> 00:22:37.730
What you're doing is you're telling
launchd whatever you want about yourself,

00:22:37.730 --> 00:22:41.860
be it the multitude of keys that
are available in the launchd P list,

00:22:41.860 --> 00:22:43.620
or maybe what you're not.

00:22:43.760 --> 00:22:46.280
Maybe you're going to let
launchd implicit some things.

00:22:46.420 --> 00:22:48.760
So for example,
if you don't set standard out or

00:22:48.760 --> 00:22:52.330
standard error in your P list,
you'll just inherit it from launchd.

00:22:52.340 --> 00:22:54.660
Again, think object-oriented.

00:22:54.660 --> 00:22:58.260
And that can be really powerful
if you're working with launchd.

00:22:58.260 --> 00:23:01.630
You can you can do some
neat inheritance tricks.

00:23:01.780 --> 00:23:04.380
But those are the two contracts
we're going to be dealing with.

00:23:04.450 --> 00:23:06.940
And how do they pertain to dependencies?

00:23:09.220 --> 00:23:11.750
For networking changes,
we'll tell you to use the

00:23:11.760 --> 00:23:13.410
system configuration framework.

00:23:13.630 --> 00:23:16.080
For disk changes,
the disk arbitration framework.

00:23:16.140 --> 00:23:18.660
For device discovery,
the I/O Kit framework.

00:23:18.760 --> 00:23:20.620
There's a pattern here.

00:23:20.640 --> 00:23:24.200
Other changes require
other API frameworks.

00:23:24.340 --> 00:23:28.140
APIs are in fact fluid.

00:23:28.180 --> 00:23:29.220
Let's give an example.

00:23:29.260 --> 00:23:32.100
Goes all the way back to the 1970s.

00:23:32.570 --> 00:23:34.020
Get PWNAM.

00:23:34.020 --> 00:23:36.640
Not a pretty name, but it works.

00:23:36.920 --> 00:23:40.200
Takes a login name,
returns a structure representing

00:23:40.200 --> 00:23:42.890
the account in a Unix system.

00:23:44.140 --> 00:23:46.820
It previously read
ETSI password directly.

00:23:46.830 --> 00:23:47.480
That's fine.

00:23:47.480 --> 00:23:48.450
An API is allowed to do that.

00:23:48.520 --> 00:23:49.260
That was the contract.

00:23:49.260 --> 00:23:53.460
But later,
we changed it to talk to lookupd via IPC.

00:23:53.460 --> 00:23:57.650
Okay, well,
how did we avoid a race between getpwnam

00:23:57.700 --> 00:24:03.310
being called and lookupd vending
the backend information via IPC?

00:24:03.320 --> 00:24:06.300
All right, time to rewind.

00:24:06.390 --> 00:24:07.890
Back to the launchd plist.

00:24:07.970 --> 00:24:11.000
If you notice here,
we've added something to

00:24:11.030 --> 00:24:12.030
the job describing it.

00:24:12.080 --> 00:24:15.000
Lookupd, in fact,
was implemented using Mach.

00:24:15.000 --> 00:24:16.450
And we told launchd about it.

00:24:16.640 --> 00:24:18.270
Hey, we vend a Mach service.

00:24:18.270 --> 00:24:21.180
The name in the Mach namespace
is lookupdaemonv2.

00:24:21.180 --> 00:24:24.020
And well,
because dictionaries are key value based,

00:24:24.020 --> 00:24:26.650
we need some values,
so we stuck true in there.

00:24:26.690 --> 00:24:30.740
But the important thing is this
ended up telling launchd to create

00:24:30.740 --> 00:24:32.660
a Mach port that can be found.

00:24:33.570 --> 00:24:39.800
So later, when

00:24:40.430 --> 00:24:43.240
When getpwnam was implemented,
it went out,

00:24:43.450 --> 00:24:48.690
found the communication for lookupd,
and started sending it a message.

00:24:48.690 --> 00:24:51.350
It really didn't matter whether
lookupd was running or not.

00:24:51.450 --> 00:24:53.090
The communication was prepped.

00:24:55.780 --> 00:25:01.030
So what launchd promises you
in the race-free IPC setup?

00:25:01.440 --> 00:25:03.520
We're going to make sure all
the communication handles are

00:25:03.570 --> 00:25:07.890
set up before any program beyond
launchd itself starts running.

00:25:08.000 --> 00:25:10.750
And the nice thing about that is
that when they do start running,

00:25:10.750 --> 00:25:15.100
all the possible services that can be
vended on the system are all known.

00:25:15.120 --> 00:25:18.960
All per-machine jobs will be
loaded before any of them start.

00:25:18.970 --> 00:25:22.670
Again, for the per-user context,
per session, it's all the same.

00:25:22.760 --> 00:25:25.300
We load the handles up,
then open the floodgates and

00:25:25.310 --> 00:25:27.500
let program start running.

00:25:28.500 --> 00:25:31.660
But we don't promise you some things.

00:25:31.740 --> 00:25:34.400
We don't promise networking
interfaces are found.

00:25:34.430 --> 00:25:37.400
We don't promise that auxiliary
file systems are mounted.

00:25:37.440 --> 00:25:41.260
We don't even promise that
hardware is done being probed yet.

00:25:41.920 --> 00:25:45.520
Any detail about the configuration
besides what's necessary to bootstrap

00:25:45.640 --> 00:25:49.610
communication between processes,
we don't promise that.

00:25:49.860 --> 00:25:52.260
So yeah,
talk amongst yourselves as processes,

00:25:52.370 --> 00:25:55.190
have a blast,
but it's between you and the

00:25:55.190 --> 00:25:59.390
various API frameworks to
negotiate your dependencies.

00:26:00.920 --> 00:26:04.100
And best of all,
if you can make fewer assumptions,

00:26:04.100 --> 00:26:05.980
this will all just work.

00:26:07.110 --> 00:26:10.350
Now talking to launchd,
well how does that work?

00:26:10.610 --> 00:26:11.690
We have some APIs.

00:26:11.820 --> 00:26:12.540
They're pretty simple.

00:26:12.680 --> 00:26:15.610
If you've used core
foundation or foundation,

00:26:15.630 --> 00:26:16.490
things will look familiar.

00:26:16.640 --> 00:26:18.760
We're dealing with boxed objects.

00:26:18.800 --> 00:26:22.210
Here we're allocating a new
string into a boxed object

00:26:22.210 --> 00:26:24.400
and then we're extracting it.

00:26:24.730 --> 00:26:27.240
Real simple container APIs.

00:26:27.250 --> 00:26:29.040
They're not meant to be high performance.

00:26:29.040 --> 00:26:33.240
I wouldn't recommend actually writing
your app around these container APIs.

00:26:33.240 --> 00:26:35.990
They're just meant for IPC with launchd.

00:26:37.240 --> 00:26:42.340
So the other side of the XML contract
when it comes to these APIs,

00:26:42.350 --> 00:26:44.240
you need to get your
IPC handles from launchd.

00:26:44.270 --> 00:26:45.640
Well, how do you do that?

00:26:45.670 --> 00:26:47.890
Again, we have this boxed objects.

00:26:47.970 --> 00:26:50.320
We're going to allocate a string,
particularly known string.

00:26:50.320 --> 00:26:52.470
And we're going to check in with launchd.

00:26:52.610 --> 00:26:54.640
So hey, launchd, I want to check it.

00:26:54.700 --> 00:26:56.450
That's what that launch message does.

00:26:56.610 --> 00:27:01.990
It takes an arbitrary object graph in and
returns an arbitrary object graph back.

00:27:01.990 --> 00:27:04.760
Here we're checking for failures.

00:27:04.760 --> 00:27:09.410
If it actually doesn't return something,
the communication apparently

00:27:09.540 --> 00:27:11.390
failed for something.

00:27:12.000 --> 00:27:16.570
But part two,
checking for secondary failures.

00:27:16.940 --> 00:27:19.380
We can actually extract
the type of the object.

00:27:19.380 --> 00:27:22.150
In this case,
we're checking to see if it was an error.

00:27:22.180 --> 00:27:25.830
Just because you could talk to launchd,
doesn't necessarily mean what

00:27:26.250 --> 00:27:27.930
you asked it to do worked.

00:27:28.020 --> 00:27:29.940
So here,
we're trying to see if there's an error.

00:27:29.940 --> 00:27:32.500
We extract it.

00:27:32.740 --> 00:27:36.050
You can review the slides later,
but the important part is there's

00:27:36.090 --> 00:27:37.660
some sample code in launchd project.

00:27:37.660 --> 00:27:40.020
You can see this in action.

00:27:41.100 --> 00:27:42.180
Pass the error checking.

00:27:42.190 --> 00:27:44.800
Let's actually see something interesting.

00:27:44.870 --> 00:27:48.280
Here's how to iterate
results using the APIs.

00:27:48.290 --> 00:27:51.600
We have a dictionary lookup,
much like you have in core

00:27:51.660 --> 00:27:53.220
foundation and foundation.

00:27:53.220 --> 00:27:54.600
We take the response.

00:27:54.680 --> 00:27:59.500
Here we're looking to see if launchd
provided us an advisory timeout.

00:27:59.500 --> 00:28:04.210
Again, we like launch on demand,
and the next bonus points, gravy,

00:28:04.210 --> 00:28:07.700
extra credit, if you will,
is to actually idle exit

00:28:07.700 --> 00:28:09.340
when you're not needed.

00:28:09.360 --> 00:28:12.260
So here we can extract
an advisory idle timeout.

00:28:12.260 --> 00:28:15.280
Don't have to,
but if that key exists and if we care,

00:28:15.280 --> 00:28:16.840
we can use it.

00:28:16.840 --> 00:28:20.110
The next thing that we're checking
for here is if any Mach services

00:28:20.330 --> 00:28:23.160
are to be vended by this job.

00:28:23.160 --> 00:28:26.500
The neat thing about this, too,
is you can actually compare your

00:28:26.500 --> 00:28:31.680
own program's notion of what it
does versus what the plist said.

00:28:31.680 --> 00:28:35.910
It allows for some interesting
potential for adding things after

00:28:35.910 --> 00:28:39.050
the fact into the plist that the
original program wasn't expecting.

00:28:39.160 --> 00:28:42.550
That can be to your advantage sometimes.

00:28:42.560 --> 00:28:44.980
And then the next one we're
looking up are sockets.

00:28:44.980 --> 00:28:47.070
And again, may or may not be there.

00:28:47.120 --> 00:28:48.500
It's good to check.

00:28:48.550 --> 00:28:50.060
But let's say you did get some sockets.

00:28:50.060 --> 00:28:54.560
We've got to do something with the
result of that particular case.

00:28:54.580 --> 00:29:00.660
Well, sockets come back as a dictionary,
and we want to iterate them.

00:29:00.660 --> 00:29:04.640
You can provide a callback for
the dictionary iterate API.

00:29:04.660 --> 00:29:05.670
It looks like this.

00:29:05.680 --> 00:29:07.960
It's your standard iteration API.

00:29:08.080 --> 00:29:08.910
You have the key.

00:29:09.000 --> 00:29:09.510
You have the value.

00:29:09.520 --> 00:29:11.280
And you have a little
cookie you can pass through.

00:29:11.290 --> 00:29:15.810
Here we're just going to
print out the results.

00:29:16.820 --> 00:29:20.730
And once you iterate the full
results coming back from launchd,

00:29:20.730 --> 00:29:24.120
you will have the descriptors right
there as a part of your message payload.

00:29:24.160 --> 00:29:28.920
And you can add that to your event
loop and carry on just as normal.

00:29:29.190 --> 00:29:31.510
Now, we actually made a demo.

00:29:31.610 --> 00:29:33.860
This is actually in the
stock Leopard system.

00:29:33.900 --> 00:29:36.690
And with a small little tweak,
you can enable this.

00:29:36.860 --> 00:29:40.840
But we made SSH agent launch on
demand within your GUI session.

00:29:40.890 --> 00:29:43.110
That means every one of your
Leopard systems right now,

00:29:43.200 --> 00:29:45.530
if you make the small
little config tweak,

00:29:45.790 --> 00:29:50.490
can just type SSH add without any
prep work and have an SSH agent

00:29:50.560 --> 00:29:52.010
launched for your session.

00:29:52.320 --> 00:29:55.020
And that's really neat
because then all the GUI apps,

00:29:55.220 --> 00:30:01.040
again through inheritance,
can get the SSH agent values from it.

00:30:01.090 --> 00:30:04.490
So if we can switch to the demo machine,
I'll show how this works.

00:30:05.940 --> 00:30:07.860
So we made a small tweak.

00:30:07.860 --> 00:30:12.760
Essentially, we did this,
sudo touch var db use ls.

00:30:12.760 --> 00:30:16.760
This enables some code that
wasn't quite ready for WWDC,

00:30:16.760 --> 00:30:20.620
but it's where we're trending in the OS.

00:30:20.620 --> 00:30:24.960
And what this did was actually
make all the GUI apps launch

00:30:25.180 --> 00:30:28.200
via the per session launchd.

00:30:28.270 --> 00:30:31.940
So if we look at all the programs
running around on the system,

00:30:32.030 --> 00:30:35.450
we have the per session
launchd here at the bottom.

00:30:35.460 --> 00:30:37.660
It's PID 192.

00:30:37.670 --> 00:30:40.500
It's parent PID is 34.

00:30:40.520 --> 00:30:46.620
34, if we look at the list, is-- oh,
right above it-- it's login window.

00:30:46.620 --> 00:30:48.260
That's our session.

00:30:48.260 --> 00:30:52.280
And if we look at all the apps
running within the session,

00:30:52.280 --> 00:30:56.080
this block right here,
notice that Spotlight's running as

00:30:56.080 --> 00:30:59.850
a child of the per session launchd.

00:30:59.940 --> 00:31:02.460
The dock is a child.

00:31:02.460 --> 00:31:03.800
The finder's a child.

00:31:04.070 --> 00:31:06.500
Everything running within
the session is a child.

00:31:06.510 --> 00:31:07.640
Well, that's great.

00:31:07.650 --> 00:31:10.640
Now it's inheriting things from launchd.

00:31:10.750 --> 00:31:17.250
Environment variables, standard I/O,
inheritance is good.

00:31:17.310 --> 00:31:18.860
How does this actually affect things?

00:31:18.970 --> 00:31:23.930
Well, if we look at the list closely
and grep for the SSH agent,

00:31:23.930 --> 00:31:25.940
we see that it's not running.

00:31:25.960 --> 00:31:30.820
But if we talk to launchd and say,
list your jobs, we actually see that the

00:31:30.890 --> 00:31:32.710
SSH agent is loaded into launchd.

00:31:32.740 --> 00:31:36.610
It doesn't have a PID assigned to it yet,
because it's not running.

00:31:36.700 --> 00:31:40.590
If we actually look at some of the
configuration details about it--

00:31:44.970 --> 00:31:46.380
So you remember the check-in
I was talking about?

00:31:46.490 --> 00:31:47.800
You'll get a socket back.

00:31:47.800 --> 00:31:48.610
It's a dictionary.

00:31:48.750 --> 00:31:52.610
In this case, it's using listeners as its
own key for its protocol.

00:31:52.620 --> 00:31:55.370
And then it has a descriptor
that it'll get back.

00:31:55.640 --> 00:32:00.360
But what you don't see here is that,
again, due to inheritance,

00:32:00.650 --> 00:32:04.330
every process launched from launchd
is getting this environment variable.

00:32:04.480 --> 00:32:08.750
In fact, we can ask launchd to export
its list of environment

00:32:09.010 --> 00:32:10.180
variables that it's exporting.

00:32:10.180 --> 00:32:12.920
And what do you know?

00:32:12.920 --> 00:32:15.290
Oops.

00:32:17.730 --> 00:32:19.870
All right, well, there's a bug.

00:32:19.990 --> 00:32:23.420
But it did work because
terminal did get the variable.

00:32:25.830 --> 00:32:30.040
And because we got it,
we can now say ssh add.

00:32:30.040 --> 00:32:33.280
Oh, and probably it should
generate a key first.

00:32:40.300 --> 00:32:43.340
And now when we say ssh add, we added it.

00:32:43.350 --> 00:32:47.680
And if we look, it's now running.

00:32:47.680 --> 00:32:51.810
And if we check the
parent-child relationship,

00:32:54.580 --> 00:32:56.600
We noticed again 192.

00:32:56.630 --> 00:33:02.090
192 was, if we scroll all the way back,
the per session launchd.

00:33:02.250 --> 00:33:06.280
So now we can open new terminal windows,
say SSH add.

00:33:06.280 --> 00:33:08.740
And what this means is
we can SSH to systems.

00:33:08.740 --> 00:33:11.830
And in the case of Xcode,
which has support for CVS,

00:33:11.830 --> 00:33:14.910
it means that when it does
a CVS check in or check out,

00:33:14.910 --> 00:33:18.620
it can use your SSH keys now as
far as talking to your CVS server,

00:33:18.620 --> 00:33:22.450
which some of you, I would imagine,
might actually use.

00:33:23.020 --> 00:33:24.540
So this is a nice feature.

00:33:24.560 --> 00:33:28.750
We'd like to actually see more processes
adopt launch on demand so they can

00:33:28.750 --> 00:33:31.320
vend their services as they're needed.

00:33:31.320 --> 00:33:33.300
And that is our demo.

00:33:33.300 --> 00:33:36.160
If we can go back to the slides.

00:33:36.160 --> 00:33:37.370
Thank you.

00:33:43.540 --> 00:33:47.260
So this concludes our talk.

00:33:47.610 --> 00:33:49.080
I am putting my email up here.

00:33:49.080 --> 00:33:51.330
I can't promise that
I'll get back to you,

00:33:51.450 --> 00:33:55.830
but I do try very hard to help
people in their questions.

00:33:55.890 --> 00:33:58.540
Launchd is the bootstrap daemon,
so it would be in my best

00:33:58.660 --> 00:34:02.840
interest to help bootstrap
people with their questions.

00:34:02.840 --> 00:34:06.000
So if you need, you can try and email me.

00:34:06.000 --> 00:34:09.230
But if that doesn't work and you find
a bug and you just want to report it,

00:34:09.230 --> 00:34:12.600
we have a mailing list you can
send messages to and that's another

00:34:12.600 --> 00:34:14.440
way you can get a hold of us.

00:34:14.440 --> 00:34:18.080
Also, there's documentation in the
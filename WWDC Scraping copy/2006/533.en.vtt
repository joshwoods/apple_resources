WEBVTT

00:00:10.450 --> 00:00:14.030
My name is Wilfredo Sanchez
Vega and I am here to talk about

00:00:14.140 --> 00:00:17.840
the Darwin Calendar Server which
is also known as the iCal Server.

00:00:17.900 --> 00:00:20.440
And I'm pretty jazzed up to be
up here in WWC talking about new

00:00:20.440 --> 00:00:26.890
products again and open source things
so hope you're as excited as I am.

00:00:27.040 --> 00:00:30.540
The Darwin Calendar Server is
Apple's calendar sharing solution.

00:00:30.570 --> 00:00:34.310
So we've been getting a lot of requests
for years and years now about why it is

00:00:34.340 --> 00:00:38.690
that Mac OS X Server fills almost every
need that you've got and wouldn't it be

00:00:38.690 --> 00:00:43.580
swell if it had some kind of calendar
solution and finally we've got something.

00:00:43.670 --> 00:00:45.980
Thank you.

00:00:48.500 --> 00:03:56.600
[Transcript missing]

00:03:57.620 --> 00:04:01.260
So to speak about CalDAV and
iCalendar and so on is Cyrus Daboo

00:04:01.260 --> 00:04:03.800
who is a colleague of mine
on the Mac OS X server team.

00:04:03.800 --> 00:04:07.110
And Cyrus is one of the authors of
CalDAV specifications so he's pretty

00:04:07.110 --> 00:04:09.820
well suited to take it from here.

00:04:14.160 --> 00:04:15.230
Okay, thank you Wilfredo.

00:04:15.270 --> 00:04:19.800
I'm Cyrus Daboo and I'm here to talk
to you about two main topics today.

00:04:19.810 --> 00:04:22.860
The first of these is going to be a
brief introduction to the calendaring

00:04:22.860 --> 00:04:27.480
and scheduling standards that
Wilfredo mentioned a short while ago.

00:04:27.480 --> 00:04:30.530
And then I'm going to go on and
give you a little bit more detail

00:04:30.530 --> 00:04:32.460
about the CalDAV specification.

00:04:32.670 --> 00:04:34.450
So first of all, iCalendar.

00:04:34.520 --> 00:04:37.720
Well, iCalendar is a data format
that's defined by the

00:04:37.720 --> 00:04:42.340
Internet Engineering Task Force RFC 2445
specification.

00:04:42.480 --> 00:04:45.050
This was actually originally
published back in 1998,

00:04:45.050 --> 00:04:47.400
so it's been around
for quite a while now.

00:04:47.400 --> 00:04:50.060
And there are many products that
actually implement this standard

00:04:50.060 --> 00:04:53.390
and they allow you to import and
export data in iCalendar format,

00:04:53.400 --> 00:04:53.870
etc.

00:04:53.870 --> 00:04:57.870
And of course, iCal has been able to
do that since day one.

00:04:58.270 --> 00:05:00.840
The ITIP specification,
ITIP stands for iCalendar

00:05:00.850 --> 00:05:04.700
Transport Independent Protocol,
is a specification that defines how you

00:05:04.780 --> 00:05:08.730
can use the iCalendar data to actually
carry out scheduling operations between

00:05:08.730 --> 00:05:10.990
multiple parties in a calendaring system.

00:05:11.000 --> 00:05:16.270
So ITIP defines a set of methods
and types that define how people

00:05:16.340 --> 00:05:19.540
actually do scheduling processes.

00:05:19.540 --> 00:05:23.520
So it defines certain roles for people,
an organizer, an attendees and actions

00:05:23.750 --> 00:05:25.120
that they can perform.

00:05:25.250 --> 00:05:28.820
So an organizer can send out
a request to the attendees,

00:05:28.820 --> 00:05:30.340
it's an invitation.

00:05:30.340 --> 00:05:33.950
The attendees can look at that,
can decide whether they want to attend or

00:05:33.950 --> 00:05:37.260
not and they can send back their replies
to the organizer who can then aggregate

00:05:37.330 --> 00:05:40.420
and update all of that information
for the other attendees as well.

00:05:40.420 --> 00:05:44.690
Together, these two standards basically
provide the overall standard

00:05:44.690 --> 00:05:46.880
for calendaring and scheduling.

00:05:46.880 --> 00:05:49.550
And again,
a number of other products already

00:05:49.550 --> 00:05:53.660
support ITIP through the email
mechanism that Wilfredo mentioned,

00:05:53.660 --> 00:05:55.080
which is the IMIP profile.

00:05:55.240 --> 00:05:56.240
So it's a very simple way to do that.

00:05:56.240 --> 00:06:00.740
But what has been lacking until
now has really been a formal way to

00:06:00.810 --> 00:06:05.700
do an access protocol to actually
access the data from the client in a

00:06:05.790 --> 00:06:07.840
typical client-server architecture.

00:06:07.840 --> 00:06:12.720
So that's going to be CalDAV,
which I'll talk about a little later on.

00:06:13.030 --> 00:06:16.100
So let's look a little bit
at what iCalendar gives us.

00:06:16.100 --> 00:06:19.210
So iCalendar basically
defines a set of events,

00:06:19.210 --> 00:06:23.170
tasks, and journal entries in
the iCalendar data format.

00:06:23.480 --> 00:06:27.090
The start and end times which you
need in any calendaring specification

00:06:27.180 --> 00:06:28.820
can be specified in various formats.

00:06:28.900 --> 00:06:34.210
So you can have floating time events,
you can have times that are fixed

00:06:34.330 --> 00:06:38.530
to UDC and you can have times
that have full time zone support.

00:06:38.880 --> 00:06:41.710
And since a lot of us these days
travel across multiple time zones,

00:06:41.780 --> 00:06:45.230
having full time zone support in your
product is actually very important.

00:06:45.230 --> 00:06:48.840
And we also need to take care of
things like daylight savings times,

00:06:48.850 --> 00:06:50.460
transitions and so forth.

00:06:50.560 --> 00:06:53.560
So time zone information encodes
all of that for us in iCalendar.

00:06:53.560 --> 00:06:57.340
Another thing we need to be able
to do with calendaring data is

00:06:57.370 --> 00:07:01.130
to be able to have events that
recur over a period of time.

00:07:01.140 --> 00:07:04.520
So in iCalendar you can actually
define a set of recurrence rules which

00:07:04.520 --> 00:07:06.600
actually can be very sophisticated.

00:07:07.600 --> 00:07:11.370
And what you also need to be able to do
with recurrences and recurrence patterns

00:07:11.370 --> 00:07:13.230
is to define exceptions to those.

00:07:13.230 --> 00:07:16.930
So sometimes you may have a meeting which
normally takes place on a Wednesday but

00:07:16.930 --> 00:07:20.370
then one particular week you may
need to cancel that for some reason.

00:07:20.380 --> 00:07:23.990
Or another week you may need to
actually move it to the Thursday.

00:07:23.990 --> 00:07:27.660
So the iCalendar data format needs
to be able to allow you to specify

00:07:27.660 --> 00:07:29.910
exceptions to recurrences as well.

00:07:29.920 --> 00:07:34.280
Since we want to do scheduling,
we also need a way to specify attendee

00:07:34.280 --> 00:07:36.620
data so that we can invite people.

00:07:36.620 --> 00:07:37.580
We can determine the time zone.

00:07:37.580 --> 00:07:39.390
We can determine what their status is.

00:07:39.390 --> 00:07:41.690
So an attendee will be able
to specify whether they've

00:07:41.820 --> 00:07:45.410
accepted a particular invitation,
whether they've declined that invitation,

00:07:45.450 --> 00:07:48.040
or they may want to delegate
their presence in a particular

00:07:48.050 --> 00:07:49.860
meeting to another attendee.

00:07:49.860 --> 00:07:53.310
So all of that can be done
within the iCalendar data format.

00:07:54.250 --> 00:07:57.500
So let's look at iCalendar
in a little bit more detail.

00:07:57.500 --> 00:08:01.600
I'm going to show some of the syntax
that you will see in an iCalendar file.

00:08:01.600 --> 00:08:05.460
So iCalendar defines a set
of top level component types.

00:08:05.460 --> 00:08:08.200
So there's a VEVENT component
which defines events.

00:08:08.200 --> 00:08:10.780
There's a VTODO component for tasks.

00:08:10.780 --> 00:08:14.720
There's a VTIMEZONE component that
encodes time zone information for the

00:08:14.720 --> 00:08:16.280
different time zones across the world.

00:08:16.280 --> 00:08:19.420
And that also includes
daylight savings times rules.

00:08:19.440 --> 00:08:22.500
And don't forget that those are
changing next year in the US,

00:08:22.500 --> 00:08:23.670
so be careful of that.

00:08:24.200 --> 00:08:27.810
We also have VALARM components
which are usually embedded and

00:08:27.810 --> 00:08:29.850
attached to VEVENTS and VTODOS.

00:08:29.880 --> 00:08:34.460
And these let you specify alarms that
can be triggered a certain time before

00:08:34.460 --> 00:08:36.600
or after an event is due to start.

00:08:36.640 --> 00:08:40.630
The VJOURNAL component,
well back in 1998,

00:08:40.630 --> 00:08:44.470
blogs were not being used
or were not really around.

00:08:44.480 --> 00:08:48.040
And VJOURNAL was kind of
designed as an equivalent to a

00:08:48.150 --> 00:08:50.280
kind of a blogging mechanism.

00:08:50.280 --> 00:08:53.000
It's just a way, you know,
typically if you have your, you know,

00:08:53.000 --> 00:08:55.770
the old days when you had, you know,
your diary that you'd scribble in,

00:08:55.770 --> 00:08:57.700
this is what the journal
entry was supposed to be.

00:08:57.700 --> 00:09:00.260
It's a way of taking notes during
a meeting and just putting those

00:09:00.260 --> 00:09:02.550
on your calendar and tagging
them with a date and time.

00:09:02.620 --> 00:09:07.600
Journals have not been particularly
implemented widely in products,

00:09:07.600 --> 00:09:12.520
so that particular aspect of
iCalendar hasn't been used very much.

00:09:12.710 --> 00:09:15.260
Though there are some specialized
uses of it that are actually

00:09:15.260 --> 00:09:16.730
beginning to appear recently.

00:09:16.820 --> 00:09:22.470
The VFREE BUSY component is a way for
you to specify busy time information

00:09:22.470 --> 00:09:26.930
or to block out time on your calendar
without actually specifying exactly what

00:09:26.940 --> 00:09:28.570
it is you're doing during that time.

00:09:28.620 --> 00:09:32.520
It's also a way for you to transport
free and busy information to other

00:09:32.520 --> 00:09:35.460
people just to let them know that you're
busy for a particular block of time,

00:09:35.460 --> 00:09:38.070
again without actually giving
away information about what it

00:09:38.070 --> 00:09:40.620
is that you might actually be
doing at that particular time.

00:09:42.510 --> 00:09:44.600
So let's take a look at iCalendar syntax.

00:09:44.600 --> 00:09:48.020
I mean, these days you can pretty much
go to the Internet and pull

00:09:48.020 --> 00:09:51.360
down an iCalendar file from many
different calendar sharing sites.

00:09:51.360 --> 00:09:55.280
So you'll pull down a file which will
typically have this .ics extension.

00:09:55.280 --> 00:09:58.170
And if you open that up in a
text editor and look at it,

00:09:58.240 --> 00:10:01.210
you're going to see something
that looks a little bit like this.

00:10:01.220 --> 00:10:05.130
So usually at the top of the file,
you're going to have this

00:10:05.130 --> 00:10:06.140
begin vCalendar statement.

00:10:06.140 --> 00:10:07.580
And at the very end,
you're going to have an

00:10:07.590 --> 00:10:08.620
end vCalendar statement.

00:10:09.340 --> 00:10:11.660
Within that,
you're going to have begin vEvent,

00:10:11.680 --> 00:10:14.320
end vEvent, begin vToDo, end vToDo.

00:10:14.320 --> 00:10:17.460
So the top-level object,
the vCalendar object,

00:10:17.460 --> 00:10:21.360
can contain many of these
different component objects,

00:10:21.360 --> 00:10:23.560
vEvents, vToDos, vJournals, et cetera.

00:10:23.560 --> 00:10:26.700
Within each of the actual
components themselves,

00:10:26.700 --> 00:10:30.280
there are a set of properties that
actually define the specific information

00:10:30.280 --> 00:10:31.580
about that particular component.

00:10:31.580 --> 00:10:36.460
And properties have a name,
a set of parameters, which are optional,

00:10:36.470 --> 00:10:37.280
and a value.

00:10:37.280 --> 00:10:39.240
So there's an example of a property.

00:10:39.240 --> 00:10:41.260
Here, which is actually the
start time property.

00:10:41.260 --> 00:10:45.240
And the name of this one is dtStart.

00:10:45.240 --> 00:10:48.660
It has a parameter which
includes a name and a value,

00:10:48.660 --> 00:10:52.920
the name being tzId and the value
of that parameter being usEastern.

00:10:52.920 --> 00:10:56.440
This happens to be the time zone that
this particular time is relative to.

00:10:56.440 --> 00:10:59.760
And then there's a value
for this property as well.

00:10:59.760 --> 00:11:04.220
So if we take a look at an
entire iCalendar file example,

00:11:04.220 --> 00:11:06.060
this is what you would typically see.

00:11:06.060 --> 00:11:10.560
So the entire iCalendar object
is specified between the

00:11:10.560 --> 00:11:12.460
begin vCalendar and vCalendar.

00:11:12.460 --> 00:11:15.570
Within that, in this case,
we have two components

00:11:15.580 --> 00:11:16.500
in this particular file.

00:11:16.500 --> 00:11:19.270
One is a vTimeZone,
the other is a vEvent.

00:11:19.300 --> 00:11:22.640
And within each of those components,
we have the properties that actually

00:11:22.650 --> 00:11:24.420
describe the component information.

00:11:26.640 --> 00:11:30.660
So let's go on and take a little
bit detailed look at recurrences

00:11:30.660 --> 00:11:34.890
because recurrence is usually
the biggest problem that people

00:11:34.890 --> 00:11:38.520
run into when they're actually
looking at the iCal specification.

00:11:38.520 --> 00:11:42.500
It's one of the harder aspects and has
been an area where interoperability

00:11:42.510 --> 00:11:44.580
has been somewhat dubious of late.

00:11:44.620 --> 00:11:48.480
But there are efforts underway to
actually clarify the standards and fix

00:11:48.480 --> 00:11:52.320
some of the problems that have actually
been observed in the wild between

00:11:52.320 --> 00:11:54.500
products interoperating and so on.

00:11:55.160 --> 00:11:59.410
And right now the IETF actually has a
Calcify working group that is actually

00:11:59.410 --> 00:12:03.320
looking at revising these standards
that have been around for quite a

00:12:03.410 --> 00:12:06.910
while and producing updated versions
of these documents that fix most of

00:12:06.930 --> 00:12:08.850
the known interoperability problems.

00:12:10.520 --> 00:12:15.100
So you can make events occur more than
once through the use of recurrence rules.

00:12:15.100 --> 00:12:18.160
There are two ways of typically
specifying recurrences.

00:12:18.160 --> 00:12:21.720
One is as basically a set of
fixed dates and the other is

00:12:21.900 --> 00:12:23.670
through a use of a pattern.

00:12:23.680 --> 00:12:27.460
Now patterns can either be bounded,
so I can have a fixed set of dates

00:12:27.520 --> 00:12:30.890
set to occur for five times or
they can be unbounded as you would

00:12:30.980 --> 00:12:35.470
typically want to do for anniversaries,
your birthday or holidays, etc.

00:12:36.540 --> 00:12:40.770
Simple patterns might be every
Monday or every day for five times.

00:12:41.080 --> 00:12:44.820
There are examples of the
iCalendar syntax for both of those.

00:12:44.820 --> 00:12:47.820
But let's look at some
examples in more detail.

00:12:47.820 --> 00:12:50.360
So let's say I want to specify
a recurrence pattern which

00:12:50.360 --> 00:12:51.760
is every day for five times.

00:12:51.820 --> 00:12:55.820
The way we do that in iCalendar
is we have this RRule property.

00:12:55.820 --> 00:12:58.820
Within that we specify a
frequency that says daily,

00:12:58.820 --> 00:12:59.820
so that's our interval.

00:12:59.820 --> 00:13:04.770
And then we limit that to five
instances with this count property.

00:13:05.010 --> 00:13:08.530
Another example, every Monday in March.

00:13:08.530 --> 00:13:13.390
Again, we're going to specify this
as a daily recurring meeting,

00:13:13.400 --> 00:13:16.960
but now we're going to say only
on Mondays and additionally

00:13:16.960 --> 00:13:18.840
we're going to say only in March.

00:13:18.840 --> 00:13:22.370
So that gives us every Monday in March.

00:13:23.350 --> 00:13:26.110
Now with recurrences,
you usually need to specify a start time,

00:13:26.120 --> 00:13:28.700
which is the very first
instance of the recurrence set.

00:13:28.700 --> 00:13:31.590
So in this case,
I'm going to specify a birthday.

00:13:31.600 --> 00:13:36.140
So the actual start time is going to be
the very first birthday you might have.

00:13:36.290 --> 00:13:40.540
And the R rule is just going
to say repeat this every year.

00:13:40.700 --> 00:13:43.880
The other way of specifying
recurrences is as a set of fixed dates.

00:13:43.880 --> 00:13:50.600
So if you have a recurring event
that's maybe too complex for the actual

00:13:50.600 --> 00:13:53.650
recurrence rules that iCal specifies,
you may need to set that up

00:13:53.650 --> 00:13:55.080
as a specific set of dates.

00:13:55.080 --> 00:13:57.490
So an example of this would
be the Easter holiday,

00:13:57.490 --> 00:14:01.740
which has a very complicated set of rules
for determining when it actually occurs.

00:14:01.740 --> 00:14:04.770
And the iCalendar R rule syntax
isn't actually able to cover

00:14:04.770 --> 00:14:06.390
all of those possibilities.

00:14:06.900 --> 00:14:09.400
So in that case,
you could actually use R dates.

00:14:09.560 --> 00:14:13.240
And in this particular example,
we have just a simple set of three dates,

00:14:13.410 --> 00:14:17.390
which are three days during
August that we wanted to specify.

00:14:17.860 --> 00:14:21.060
Now you can do more complex
things with iCalendar recurrences.

00:14:21.060 --> 00:14:25.960
So this is an example of a complex
pattern that iCalendar enables.

00:14:25.960 --> 00:14:28.580
So I'm going to use
the example of payday,

00:14:28.600 --> 00:14:31.430
which I'm going to define as
the last weekday of the month.

00:14:31.510 --> 00:14:34.480
And hopefully everybody has at least one
of these on their calendar every month.

00:14:35.220 --> 00:14:39.400
So with this particular rule,
we're going to let it occur monthly.

00:14:39.400 --> 00:14:42.670
But what we're going to do
is specify that the rule only

00:14:42.670 --> 00:14:45.760
occurs on the last Monday,
Tuesday, Wednesday,

00:14:45.810 --> 00:14:48.880
Thursday and Friday in
any particular month.

00:14:48.940 --> 00:14:52.940
And then we're going to use this
by set pos element to actually pick

00:14:52.940 --> 00:14:57.380
the last one of those in the set
that's generated by those instances.

00:14:57.380 --> 00:15:02.600
So the recurrence rule expansion
process is actually quite complicated.

00:15:02.600 --> 00:15:05.200
There are a whole set of
elements that can occur.

00:15:05.200 --> 00:15:08.200
Within a rule, in some cases,
those elements can actually

00:15:08.200 --> 00:15:11.700
expand the set of recurrences for
a particular frequency interval.

00:15:11.780 --> 00:15:14.170
In other cases,
they can actually restrict

00:15:14.170 --> 00:15:17.060
the set of occurrences,
as we saw with the by set pos,

00:15:17.100 --> 00:15:20.680
which restricts you from a possibility
of the five weekdays down to

00:15:20.680 --> 00:15:24.180
the one that actually matches
the recurrence that you want.

00:15:24.310 --> 00:15:29.330
So actually calculating these is not
a trivial process and actually takes a

00:15:29.330 --> 00:15:31.990
fair bit of CPU power and effort to do.

00:15:32.080 --> 00:15:36.260
It's good to know that there are
quite a lot of There are a number of

00:15:36.260 --> 00:15:40.280
open source iCalendar libraries out
there that actually let you parse and

00:15:40.280 --> 00:15:42.740
generate and interpret iCalendar data.

00:15:42.930 --> 00:15:47.100
So if you need to incorporate this
technology in your own products,

00:15:47.100 --> 00:15:49.380
you can certainly look at those.

00:15:50.330 --> 00:15:54.440
In addition to being able to specify
just the plain recurrence patterns,

00:15:54.450 --> 00:15:56.080
as I mentioned before,
you also need to be able

00:15:56.080 --> 00:15:57.140
to specify exceptions.

00:15:57.160 --> 00:15:59.530
One type of exception is an exclusion.

00:15:59.540 --> 00:16:02.630
So in this example,
we're going to specify every

00:16:02.630 --> 00:16:06.040
week on Monday for five weeks,
except that we're going to eliminate

00:16:06.040 --> 00:16:07.170
the third instance of that.

00:16:07.200 --> 00:16:09.540
So in this case,
we just specify the starting

00:16:09.540 --> 00:16:11.260
Monday for the recurrence set.

00:16:11.460 --> 00:16:15.000
We have an R rule which
specifies weekly for five times,

00:16:15.000 --> 00:16:18.470
then we use a special X state
property to exclude the third

00:16:18.610 --> 00:16:20.340
one of those from that set.

00:16:22.380 --> 00:16:27.980
Another type of overridden
recurrence is the exception.

00:16:28.140 --> 00:16:30.150
This is a situation where
we actually going to,

00:16:30.480 --> 00:16:32.010
rather than eliminate
a particular meeting,

00:16:32.020 --> 00:16:34.160
we're actually going to change
it from one time to another.

00:16:34.160 --> 00:16:36.640
So in this case,
I have an example where I've got a

00:16:36.640 --> 00:16:40.120
meeting that's taking place on Monday,
Wednesday and Friday.

00:16:40.120 --> 00:16:43.220
Now what I want to do is move
the Wednesday meeting to a

00:16:43.220 --> 00:16:45.180
different time on Thursday.

00:16:46.880 --> 00:16:50.870
Now in iCalendar,
the way we do this is to actually add a

00:16:50.870 --> 00:16:56.430
new VEvent component that defines this
overridden instance on Thursday and link

00:16:56.430 --> 00:17:01.260
it back to the original component that
defines the original set of occurrences.

00:17:01.600 --> 00:17:05.320
And with the iCalendar semantics
defined by the specification,

00:17:05.320 --> 00:17:09.420
the iCalendar clients will know that
that overridden instance overrides the

00:17:09.420 --> 00:17:13.680
original one from the master instance
and will give you the correct view

00:17:13.700 --> 00:17:18.350
of your events with that overridden
instance in the appropriate place.

00:17:18.560 --> 00:17:21.710
But it's worth noting that
particularly when it comes to CalDAV,

00:17:21.850 --> 00:17:26.280
a CalDAV server, as we're going to see,
needs to understand recurrences

00:17:26.300 --> 00:17:28.930
and iCalendar data because it
has to do a certain amount of

00:17:28.930 --> 00:17:30.740
iCalendar processing on the server.

00:17:30.740 --> 00:17:34.240
So in addition to the client having
to understand this information,

00:17:34.240 --> 00:17:35.880
the server needs to do so too.

00:17:35.880 --> 00:17:39.740
So let's actually move on
and take a look at CalDAV.

00:17:39.760 --> 00:17:40.890
CalDAV

00:17:43.170 --> 00:17:44.680
So why did we need CalDAV?

00:17:44.760 --> 00:17:47.570
Well,
there were previous attempts to define a

00:17:47.630 --> 00:17:49.570
calendar access protocol within the IETF.

00:17:49.700 --> 00:17:53.280
The original CAP protocol,
which stood for Calendar Access Protocol,

00:17:53.290 --> 00:17:57.270
was a completely new protocol
that was designed to do as much of

00:17:57.340 --> 00:17:58.960
calendaring and scheduling as possible.

00:17:58.960 --> 00:18:01.250
As a result,
it actually turned out to be way too

00:18:01.250 --> 00:18:04.820
complex and way too difficult for
most people to want to implement.

00:18:04.820 --> 00:18:07.760
So there was very little interest
and buy-in from vendors to actually

00:18:07.760 --> 00:18:09.340
implement this specification.

00:18:09.700 --> 00:18:12.640
And of course, if you have a standard
that no one implements,

00:18:12.640 --> 00:18:15.210
well,
it's not really useful to anyone at all.

00:18:16.970 --> 00:18:19.480
The other problem with this is of
course calendaring and scheduling

00:18:19.480 --> 00:18:21.010
itself is actually complex.

00:18:21.010 --> 00:18:26.260
I'm only touching on a very limited
view of what's actually here.

00:18:26.260 --> 00:18:28.180
If you actually go and
read the specifications,

00:18:28.190 --> 00:18:30.300
you'll see the level of
complexity that's there.

00:18:30.300 --> 00:18:33.840
Particularly things get very complex
when you start dealing with multi-party

00:18:33.840 --> 00:18:37.200
scheduling where you do have recurring
meetings over a period of time.

00:18:37.200 --> 00:18:39.080
You do have exceptions to those meetings.

00:18:39.080 --> 00:18:41.500
You need to invite different
people to certain instances of a

00:18:41.500 --> 00:18:42.960
recurring event and not others.

00:18:42.990 --> 00:18:44.660
There's a lot of complexity there.

00:18:44.680 --> 00:18:48.250
What we wanted to do was to
try and remove from the access

00:18:48.660 --> 00:18:53.690
protocol the complexity of the
protocol or transport layer itself.

00:18:53.690 --> 00:18:56.700
Why not build on an
existing transport protocol?

00:18:56.700 --> 00:19:00.180
Obviously,
HTTP is a good transport protocol.

00:19:00.180 --> 00:19:03.940
It's used for a number of
different applications.

00:19:03.940 --> 00:19:07.260
HTTP was a good choice,
but we needed to be able to do

00:19:07.420 --> 00:19:09.420
a little bit more with that.

00:19:09.440 --> 00:19:11.650
As Wilfredo mentioned,
we need to be able to author

00:19:11.650 --> 00:19:12.940
calendar events online.

00:19:12.980 --> 00:19:15.920
We wanted to be able to do a lot
of that on the server as well as

00:19:15.920 --> 00:19:17.840
just retrieve them from the server.

00:19:17.870 --> 00:19:21.560
WebDAV is the authoring specification,
and we wanted to utilize that.

00:19:21.560 --> 00:19:24.080
Then, of course,
we want to stick with iCalendar

00:19:24.080 --> 00:19:27.080
and iTIP itself so that we can
leverage the knowledge and the

00:19:27.080 --> 00:19:30.940
libraries that people have already
developed for iCalendar and iTIP.

00:19:31.430 --> 00:19:34.980
So HTTP, again an ITF standard.

00:19:34.980 --> 00:19:39.050
Most people will see HTTP because
that's the way you browse the internet.

00:19:39.140 --> 00:19:40.760
But it's also used in other applications.

00:19:40.760 --> 00:19:45.280
Web dev, as I said, SOAP, XMLRPC,
et cetera.

00:19:45.350 --> 00:19:49.900
WebDAV adds a structured and editable
data model to HTTP specifically

00:19:49.900 --> 00:19:53.990
to enable collaborative authoring
of documents on an HTTP server.

00:19:54.000 --> 00:19:57.620
So one of the key things that it
adds is this concept of collections,

00:19:57.620 --> 00:20:00.450
which is the equivalent of a
directory in your file system.

00:20:00.460 --> 00:20:05.410
It allows you to group resources
or documents into subfolders on the

00:20:05.410 --> 00:20:10.220
server and organize the hierarchy
of resources on the server.

00:20:10.780 --> 00:20:14.860
So WebDAV added this MKCOL method to
allow you to actually create collections.

00:20:14.860 --> 00:20:19.550
It provides a way for managing resources
by adding copy and move methods,

00:20:19.560 --> 00:20:23.180
which lets you move or copy resources
between different collections.

00:20:23.180 --> 00:20:27.050
It adds a mechanism of allowing
you to add metadata to resources

00:20:27.060 --> 00:20:28.700
that are on the server.

00:20:28.700 --> 00:20:33.070
So typically the server will
store metadata on resources

00:20:33.070 --> 00:20:38.200
such as the last modified time,
the creation stamp, the owner,

00:20:38.200 --> 00:20:40.700
HTTP specific information
such as the email.

00:20:40.810 --> 00:20:42.780
It adds a way for you to
add tags to a resource,

00:20:42.780 --> 00:20:43.400
which is the e-tag of the resource,
which is a synchronization token

00:20:43.400 --> 00:20:45.780
that you can use with HTTP.

00:20:45.780 --> 00:20:48.690
But clients can also define
their own properties,

00:20:48.720 --> 00:20:53.070
which they can store on the
server for information that they

00:20:53.070 --> 00:20:55.160
need for their own purposes.

00:20:55.160 --> 00:20:58.780
So if you need to have a property
that adds tags to a resource,

00:20:58.870 --> 00:21:02.160
you can add that through
a WebDAV property.

00:21:02.420 --> 00:21:07.340
In addition to allow multi-authoring
of resources on the server,

00:21:07.340 --> 00:21:12.020
you need a way for one user to
lock a resource to prevent another

00:21:12.020 --> 00:21:15.560
user from coming on and coming
in and trying to edit that and

00:21:15.560 --> 00:21:17.440
maybe overwriting their changes.

00:21:17.460 --> 00:21:22.580
So again, WebDAV defined new lock and
unlock methods to help with that.

00:21:22.830 --> 00:21:25.630
In addition,
there's another specification that

00:21:25.630 --> 00:21:27.620
adds access control to WebDAV.

00:21:27.620 --> 00:21:30.800
And access control is really
the key to allowing end users

00:21:30.800 --> 00:21:32.670
to manage their own documents.

00:21:32.730 --> 00:21:36.350
Now, typically with an Apache server,
you can manage access control

00:21:36.390 --> 00:21:39.790
by going into the server and
editing your .htaccess file and

00:21:39.790 --> 00:21:40.700
giving people privileges that way.

00:21:40.700 --> 00:21:43.170
But typically,
it's only the system admin who's

00:21:43.170 --> 00:21:44.700
going to be able to do that.

00:21:44.700 --> 00:21:49.800
What we want is a way for users through
the HTTP protocol to actually manage

00:21:49.800 --> 00:21:52.630
sharing of the documents themselves.

00:21:52.700 --> 00:21:54.880
So that way,
I can go in and grant Wilfredo

00:21:54.880 --> 00:21:57.700
access to a particular
document I have on the server.

00:21:57.700 --> 00:22:01.620
And I can do that directly
through the WebDAV HTTP protocol.

00:22:01.700 --> 00:22:05.690
So that's what the WebDAV access
control protocol gives us.

00:22:05.740 --> 00:22:08.830
There's also the version
control specification,

00:22:08.830 --> 00:22:11.760
which allows resources that
are stored on the server to

00:22:11.760 --> 00:22:12.700
be put under version control.

00:22:12.700 --> 00:22:15.690
So a full history of all of those
resources is stored on the server.

00:22:15.710 --> 00:22:19.610
You can look at previous versions
of a particular resource.

00:22:19.750 --> 00:22:22.700
You can update resources and do merge.

00:22:22.700 --> 00:22:24.700
You can do merge and so on.

00:22:24.700 --> 00:22:26.940
And in fact,
the version control features are used

00:22:26.960 --> 00:22:30.980
by some source code control systems,
such as Subversion today.

00:22:32.150 --> 00:22:33.820
So let's actually look at CalDAV itself.

00:22:33.850 --> 00:22:36.640
So CalDAV is a calendar access protocol.

00:22:36.640 --> 00:22:39.530
It's designed to address real
calendaring requirements.

00:22:39.580 --> 00:22:44.800
So one of our primary goals when
going into the process of writing

00:22:44.810 --> 00:22:47.940
a specification is to actually
take a look at how people are

00:22:47.940 --> 00:22:51.440
using calendaring and scheduling
today in the proprietary products,

00:22:51.440 --> 00:22:54.860
custom systems that have been built
and to try and leverage some of that

00:22:54.860 --> 00:22:58.190
knowledge to build the specification
in a way that's actually going

00:22:58.190 --> 00:23:01.920
to address a lot of the use cases
and requirements that people have.

00:23:02.100 --> 00:23:04.220
in the real world.

00:23:04.360 --> 00:23:06.180
Right now we have two specifications.

00:23:06.370 --> 00:23:09.750
There's the calendar access
protocol which allows you to read,

00:23:09.750 --> 00:23:13.660
write and search calendar
data on the server.

00:23:13.660 --> 00:23:16.970
This particular specification is in
the final IETF approval process and

00:23:16.970 --> 00:23:21.570
we expect to see it published as
an RFC in a couple of months or so.

00:23:21.830 --> 00:23:24.330
Then we have the calendar
schedule specification.

00:23:24.550 --> 00:23:29.140
This enables the process of
scheduling on a CalDAV server.

00:23:29.190 --> 00:23:31.700
So it allows you to exchange
scheduling messages between

00:23:31.700 --> 00:23:33.700
users on the same server.

00:23:33.900 --> 00:23:38.090
This particular document is close
to IETF last call and again we

00:23:38.300 --> 00:23:43.840
don't expect there to be any major
changes in this and in fact we,

00:23:43.840 --> 00:23:47.570
our server and the iCal product
have both implemented the current

00:23:47.570 --> 00:23:49.280
version of that specification.

00:23:49.480 --> 00:23:51.970
In addition to this,
we're expecting to have another

00:23:52.020 --> 00:23:56.810
specification that defines how you do
server-to-server scheduling operations.

00:23:56.840 --> 00:24:00.570
So we need a way to be able to schedule
between different organizations

00:24:00.570 --> 00:24:05.040
that may have different servers,
different types of servers even.

00:24:05.040 --> 00:24:08.820
So the third document in this
series will be a document

00:24:08.870 --> 00:24:10.940
that defines how to do that.

00:24:11.010 --> 00:24:13.990
One of the things we have to be very
careful of with the server-to-server

00:24:14.070 --> 00:24:16.940
protocol is ensuring that we do
this in a secure and safe manner.

00:24:17.370 --> 00:24:20.840
Obviously, we want to avoid the horrible
threat of having calendar spam

00:24:20.840 --> 00:24:22.680
appearing on people's calendars.

00:24:22.880 --> 00:24:25.010
Unfortunately, in this day and age,
it's more than likely that

00:24:25.010 --> 00:24:26.100
that's going to happen.

00:24:26.100 --> 00:24:29.870
So we need to take precautions up front
to help prevent that type of thing.

00:24:29.880 --> 00:24:33.490
A lot of the work on
CalDAV and the requirements

00:24:33.490 --> 00:24:38.150
for server-to-server protocol,
etc., is actually being carried

00:24:38.150 --> 00:24:41.320
out under the auspices of the
Calendaring and Scheduling Consortium,

00:24:41.320 --> 00:24:43.900
which you've heard a fair
bit about this week already.

00:24:43.900 --> 00:24:46.440
So if you're interested
in a lot of this work,

00:24:46.540 --> 00:24:49.550
you know,
please try and join in in the CalConnect

00:24:49.630 --> 00:24:53.880
Consortium and help us define the
requirements and needs that you may have.

00:24:54.000 --> 00:24:56.860
And in particular, we're not just looking
for developers here.

00:24:56.860 --> 00:25:01.270
We actually want end users who have their
own requirements and needs to actually

00:25:01.270 --> 00:25:05.060
come and give us input as to what
they need in a protocol such as this.

00:25:08.000 --> 00:25:10.000
So who's actually doing CalDAV right now?

00:25:10.000 --> 00:25:14.940
Well obviously apart from Apple,
there are a bunch of other vendors,

00:25:14.940 --> 00:25:19.850
both commercial, open source,
and education sites that have

00:25:19.860 --> 00:25:23.950
been developing and have released
CalDAV products in various forms.

00:25:23.960 --> 00:25:29.090
These range from clients and servers
to a free busy aggregator that sits

00:25:29.150 --> 00:25:31.640
on top of a proprietary system.

00:25:32.980 --> 00:25:35.820
So let's look at CalDAV in
a little bit more detail.

00:25:35.910 --> 00:25:41.070
So in CalDAV, calendars are actually
represented by WebDAV collections.

00:25:41.150 --> 00:25:44.870
CalDAV actually defines a new
MK calendar method that actually allows

00:25:44.880 --> 00:25:49.580
a calendar client to create a special
calendar collection on the server.

00:25:49.690 --> 00:25:52.840
The events and tasks in the
calendar are stored as individual

00:25:52.900 --> 00:25:56.540
resources within that calendar,
with the exception that any events that

00:25:56.590 --> 00:26:00.190
represent a set of recurring events--
so in that previous example I had of

00:26:00.200 --> 00:26:03.870
exceptions where you added a particular
event that was related to the master

00:26:03.950 --> 00:26:07.780
recurrent set-- those two events,
the master and this exception,

00:26:07.780 --> 00:26:11.720
would actually be stored in a single
resource on the CalDAV server.

00:26:11.720 --> 00:26:14.410
And that's just there for convenience,
because typically you're going to want

00:26:14.460 --> 00:26:18.910
to download both of those together when
you actually want to process that event.

00:26:19.600 --> 00:26:23.590
So let's look at a typical
server repository layout.

00:26:23.670 --> 00:26:26.860
So on a WebDAV server,
in this case a CalDAV server

00:26:26.860 --> 00:26:29.500
that we have here,
we're going to have two

00:26:29.500 --> 00:26:31.200
main areas on the server.

00:26:31.370 --> 00:26:34.910
The first of these is going to
be the principles hierarchy.

00:26:34.910 --> 00:26:38.750
This is the location where
accounting information about users,

00:26:38.750 --> 00:26:41.030
groups and resources
is going to be stored.

00:26:41.130 --> 00:26:44.390
Then we're going to have a calendars
portion of the hierarchy which is

00:26:44.390 --> 00:26:46.790
where the actual calendar data lives.

00:26:47.020 --> 00:26:50.540
So with the
WebDAV Access Control Extension,

00:26:50.540 --> 00:26:54.690
every user on the system is
represented by a principal resource.

00:26:54.800 --> 00:26:57.970
So in this case,
we have principal resources for Cyrus,

00:26:57.970 --> 00:26:59.240
Chris and Wilfredo.

00:26:59.340 --> 00:27:03.550
These principal resources are the
identifiers that you actually use

00:27:03.550 --> 00:27:07.300
in the Access Control Extension to
specify who gets access to

00:27:07.420 --> 00:27:09.490
which particular resources.

00:27:09.870 --> 00:27:12.910
In addition to be able to
specifying individual users,

00:27:12.910 --> 00:27:15.020
of course you want to be able
to specify groups of users.

00:27:15.040 --> 00:27:18.110
And again,
the principal resources that define

00:27:18.110 --> 00:27:23.070
groups allow you to use those in access
control so you can grant rights for

00:27:23.070 --> 00:27:24.960
a particular group to read a resource.

00:27:24.960 --> 00:27:30.030
And all of the users who are members of
that group obviously inherit the ability

00:27:30.030 --> 00:27:32.640
to read or write based on the privileges.

00:27:33.680 --> 00:27:37.520
Now in calendaring,
we also need to include non-human

00:27:37.520 --> 00:27:40.300
resources in the calendaring process.

00:27:40.300 --> 00:27:43.550
So rooms, printers,
all of these need to be bookable

00:27:43.590 --> 00:27:45.420
as part of the invitation.

00:27:45.420 --> 00:27:48.080
So again,
we will have principles related to

00:27:48.080 --> 00:27:50.490
those particular types of resources.

00:27:52.660 --> 00:27:55.840
Within the calendar data hierarchy,
again,

00:27:55.840 --> 00:27:59.660
we will have three subgroups for users,
groups and resources.

00:27:59.660 --> 00:28:04.400
Within a particular subgroup,
we're going to have the calendar home

00:28:04.400 --> 00:28:07.160
directory for each particular principle.

00:28:07.160 --> 00:28:12.040
Here we have calendar homes for Cyrus,
Chris and Wilfredo.

00:28:12.040 --> 00:28:15.070
In this example,
Chris has actually got two calendars

00:28:15.070 --> 00:28:16.760
within his calendar collection.

00:28:16.780 --> 00:28:20.650
CalDAV does allow you to have as many
different calendars as you want under

00:28:20.650 --> 00:28:24.360
your own calendar home directory or
you can create calendars in public

00:28:24.360 --> 00:28:26.620
hierarchies if they're set up as well.

00:28:26.810 --> 00:28:31.200
In this example, Chris has two events
in his work calendar.

00:28:31.200 --> 00:28:35.620
It's worth remembering here that we're
still dealing with an HTTP server.

00:28:36.110 --> 00:28:39.630
So every one of these resources
and collections is individually

00:28:39.630 --> 00:28:41.850
addressable by an HTTP URL.

00:28:41.980 --> 00:28:44.680
So at any time,
you can just even pull up a web

00:28:44.680 --> 00:28:48.550
browser and just browse this entire
CalDAV hierarchy assuming you

00:28:48.550 --> 00:28:52.720
have permissions to look at the
various portions of that hierarchy.

00:28:53.390 --> 00:28:57.300
One of the key components of the
CalDAV protocol is the other reports.

00:28:57.300 --> 00:29:00.730
The reports are the way that
you actually get access to the

00:29:00.730 --> 00:29:02.590
calendar data in a smart way.

00:29:02.600 --> 00:29:07.010
So for reports,
we use the WebDAV report method and this

00:29:07.020 --> 00:29:11.260
gives us a way to do calendar specific
queries on the data on the server.

00:29:11.260 --> 00:29:16.320
Reports typically take an XML request
body and return an XML response.

00:29:17.160 --> 00:29:19.030
CalDAV defines three types of reports.

00:29:19.110 --> 00:29:22.150
There's the calendar query report,
which allows you to query

00:29:22.150 --> 00:29:24.920
calendar objects on the server
that match certain criteria.

00:29:24.920 --> 00:29:26.720
And I'm going to go into this
in more detail in a minute.

00:29:26.720 --> 00:29:32.470
There's the calendar multi-get report,
which allows you to get a whole

00:29:32.700 --> 00:29:37.600
set of events or tasks from the
server in one single request.

00:29:37.600 --> 00:29:40.150
So rather than having to do
multiple requests for each

00:29:40.170 --> 00:29:43.320
of the individual events in a
particular calendar collection,

00:29:43.320 --> 00:29:45.700
you can ask the server to give
you all of those in one go.

00:29:45.700 --> 00:29:47.000
And that just saves you.

00:29:47.020 --> 00:29:49.430
So you can do a little bit
of bandwidth and round trips,

00:29:49.450 --> 00:29:52.040
which is particularly
important for mobile devices.

00:29:52.060 --> 00:29:55.040
Another report is the free busy query.

00:29:55.040 --> 00:29:58.990
With the free busy query,
it's possible to grant someone the

00:29:58.990 --> 00:30:03.620
right to get free busy information
about your particular calendar without

00:30:03.920 --> 00:30:06.790
giving them the right to actually
see the data in that calendar.

00:30:06.800 --> 00:30:11.520
So I can grant Wilfredo the right to run
a free busy report on my work calendar,

00:30:11.520 --> 00:30:13.700
but he won't be able to,
if I don't give him the right

00:30:13.700 --> 00:30:16.540
to actually read that calendar,
he won't be able to see.

00:30:17.030 --> 00:30:19.300
The details of the events,
he will just get information that says,

00:30:19.310 --> 00:30:21.740
I'm busy from this start
time to this end time,

00:30:21.740 --> 00:30:22.510
et cetera.

00:30:25.080 --> 00:30:27.520
So let's look at the query report
in a little bit more detail because

00:30:27.520 --> 00:30:29.740
this is the report that most
clients are going to want to use for

00:30:29.740 --> 00:30:33.120
their day-to-day usage of CalDAV.

00:30:33.300 --> 00:30:35.300
So with the query report,
clients can specify a

00:30:35.300 --> 00:30:36.520
set of search criteria.

00:30:36.520 --> 00:30:42.700
You can match the text in a particular
value in the calendar data on the server.

00:30:42.700 --> 00:30:47.620
So you can find events, for example,
that contain WWDC in their description.

00:30:47.620 --> 00:30:50.470
You can match by a time range,
so you can find all events that

00:30:50.470 --> 00:30:52.240
are on your calendar this week.

00:30:52.240 --> 00:30:55.230
You can match by
particular component types,

00:30:55.420 --> 00:30:59.020
so you can find just events
or just to-dos or events that

00:30:59.060 --> 00:31:01.300
only contain alarms and so on.

00:31:02.210 --> 00:31:04.520
In addition,
the client can actually specify

00:31:04.520 --> 00:31:06.330
what gets returned by the server.

00:31:06.330 --> 00:31:09.180
So the client can
request that the server,

00:31:09.220 --> 00:31:11.610
in addition to returning
the calendar data,

00:31:11.610 --> 00:31:14.940
it also returns WebDAV properties
that may be necessary to help

00:31:14.940 --> 00:31:16.860
interpret that information.

00:31:16.860 --> 00:31:21.250
The client can also request either
the entire calendar data be returned

00:31:21.250 --> 00:31:23.590
or only parts of the calendar data.

00:31:23.590 --> 00:31:27.200
Now, it's worth remembering that with
the iCalendar specification,

00:31:27.200 --> 00:31:29.960
you can include attachments
in your calendar data that

00:31:29.960 --> 00:31:31.340
you store on the server.

00:31:31.660 --> 00:31:33.660
Of course,
these attachments these days can be

00:31:33.660 --> 00:31:36.750
very large if you're storing large
keynote presentations or pages,

00:31:36.750 --> 00:31:37.920
documents, and so on.

00:31:38.000 --> 00:31:41.180
So from an efficiency standpoint,
you don't want to have to keep

00:31:41.210 --> 00:31:44.440
downloading attachment data when
all you really want is the start

00:31:44.490 --> 00:31:46.270
and end time of a particular event.

00:31:46.280 --> 00:31:51.340
And CalNav allows you to do partial
fetches of the data on the server.

00:31:51.340 --> 00:31:54.130
In addition,
it's possible for the client to

00:31:54.130 --> 00:31:58.530
ask the CalNav server to actually
expand recurrences on its behalf.

00:31:58.650 --> 00:32:00.050
So again, we might have mobile devices
that are on the server,

00:32:00.050 --> 00:32:01.080
but we don't want to have to do that.

00:32:01.080 --> 00:32:16.450
So again, we might have mobile devices
that are on the server,

00:32:16.450 --> 00:32:25.580
but we don't want to have to do that.

00:32:26.680 --> 00:32:30.880
Let's actually look at what one of these
reports might look like over the wire.

00:32:30.920 --> 00:32:36.880
So this is again a typical
HTTP request response type process.

00:32:36.900 --> 00:32:41.870
So here we're going to be
sending an HTTP report request.

00:32:41.980 --> 00:32:45.020
The report, as I said before,
is going to take XML data

00:32:45.020 --> 00:32:47.330
in the request body.

00:32:47.550 --> 00:32:53.060
The request itself is going to include
XML that says find events on my calendar.

00:32:53.110 --> 00:32:54.910
And in this particular case,
we're looking for events

00:32:55.050 --> 00:32:59.270
that occur between a specific
start and end time range.

00:32:59.560 --> 00:33:02.810
So the response from the server,
this is going to be a

00:33:02.810 --> 00:33:04.180
multi-status response.

00:33:04.200 --> 00:33:07.760
Multi-status is a special response
defined in WebDAV that allows the

00:33:07.760 --> 00:33:12.740
server to return information about
multiple resources in a single response.

00:33:12.740 --> 00:33:14.860
So in this case,
we actually have a single matching

00:33:14.860 --> 00:33:18.050
component where we have XML data
being returned and within that

00:33:18.050 --> 00:33:21.500
we have the actual iCalendar data
that the client requested and

00:33:21.500 --> 00:33:23.490
that matched the search criteria.

00:33:23.650 --> 00:33:26.180
In this case, one event was found.

00:33:27.220 --> 00:33:30.980
Let's look at the second part of CalDAV,
which is the scheduling portion.

00:33:30.980 --> 00:33:35.020
What we wanted to do with
CalDAV scheduling is support all of

00:33:35.020 --> 00:33:39.280
the modes that the ITIP specification
defines for carrying out scheduling.

00:33:39.280 --> 00:33:42.750
This requires, amongst other things,
this requires the server to

00:33:42.750 --> 00:33:45.960
really understand the concept
of calendar user addresses,

00:33:45.960 --> 00:33:49.210
which is the means that you
actually use to identify users on

00:33:49.210 --> 00:33:53.530
the calendaring system and target
invitations at those particular users.

00:33:54.390 --> 00:33:57.400
In addition,
iCalendar and ITIP define the roles

00:33:57.420 --> 00:33:59.560
of an organizer and attendees.

00:33:59.640 --> 00:34:02.480
So there's going to be a certain
amount of asymmetry in the protocol

00:34:02.480 --> 00:34:03.990
depending on what your role is.

00:34:04.050 --> 00:34:06.950
If you're an organizer,
there are certain processes you need

00:34:06.950 --> 00:34:10.120
to go through and tasks you need
to do to initiate an invitation.

00:34:10.200 --> 00:34:13.190
If you're an attendee,
there are certain steps you need

00:34:13.190 --> 00:34:15.350
to take to process that invitation.

00:34:15.500 --> 00:34:17.920
In addition to this,
we definitely need access control

00:34:17.920 --> 00:34:19.900
and access privileges for scheduling.

00:34:19.900 --> 00:34:22.100
You want to be able to control
who is able to invite you

00:34:22.100 --> 00:34:26.300
to a particular meeting,
whether you reject invitations

00:34:26.300 --> 00:34:28.980
from certain people.

00:34:28.980 --> 00:34:32.960
You also want to be able to
delegate the ability for someone to

00:34:33.020 --> 00:34:35.180
schedule meetings on your behalf.

00:34:35.180 --> 00:34:39.090
So if you have an assistant who is
able to book meetings on your behalf,

00:34:39.090 --> 00:34:43.300
you want to be able to grant them the
right to do that through the protocol.

00:34:43.300 --> 00:34:48.540
And again, we've leveraged WebDAV access
control to allow you to do that.

00:34:48.540 --> 00:34:50.740
So let's look at this in
a little bit more detail.

00:34:50.740 --> 00:34:54.230
The CalDAV scheduling specification
defines for each user on the

00:34:54.230 --> 00:34:58.260
CalDAV server an inbox and an
outbox collection that are actually

00:34:58.260 --> 00:35:00.190
used during the scheduling process.

00:35:00.250 --> 00:35:03.520
And to set the access control
privileges for determining who

00:35:03.550 --> 00:35:07.270
can schedule with you and who's
able to schedule on your behalf,

00:35:07.400 --> 00:35:11.290
you actually set access privileges on
the inbox and the outbox resources.

00:35:11.360 --> 00:35:11.360
In addition to this,
we have a lot of different

00:35:11.360 --> 00:35:11.360
ways to schedule meetings.

00:35:11.360 --> 00:35:11.360
We have a lot of different
ways to schedule meetings.

00:35:11.360 --> 00:35:11.360
We have a lot of different
ways to schedule meetings.

00:35:11.360 --> 00:35:11.360
We have a lot of different
ways to schedule meetings.

00:35:11.360 --> 00:35:11.360
You can schedule meetings
with your friends,

00:35:11.360 --> 00:35:11.360
you can schedule meetings
with your family,

00:35:11.360 --> 00:35:11.430
you can schedule meetings
with your friends,

00:35:11.430 --> 00:35:11.630
you can schedule meetings
with your family,

00:35:11.630 --> 00:35:11.860
you can schedule meetings
with your friends.

00:35:11.860 --> 00:35:15.900
So scheduling requests or
replies are deposited by the

00:35:15.900 --> 00:35:17.860
organizer into their own outbox.

00:35:17.860 --> 00:35:22.630
That triggers the server to actually
send the requests or invitations

00:35:22.900 --> 00:35:23.860
to the intended recipients.

00:35:23.860 --> 00:35:27.920
The organizer gets back an immediate
response from the server that says,

00:35:27.920 --> 00:35:32.220
this particular invitation was delivered
successfully to the recipient's inbox.

00:35:32.240 --> 00:35:35.810
The recipients themselves will
actually see those invitations

00:35:35.810 --> 00:35:37.660
delivered to their own inboxes.

00:35:37.660 --> 00:35:40.750
And in their own time,
they can pick up those invitations,

00:35:40.760 --> 00:35:42.620
they can look at them,
they can process them,

00:35:42.620 --> 00:35:46.320
they can determine how to respond,
and they can respond by depositing

00:35:46.320 --> 00:35:50.030
their response in their own outbox,
and that gets routed

00:35:50.030 --> 00:35:51.820
back to the organizer.

00:35:51.820 --> 00:35:55.070
There is one exception to this,
and that is the case of

00:35:55.070 --> 00:35:56.880
free/busy information.

00:35:56.880 --> 00:35:59.160
When we were looking at the
calendar in the scheduling,

00:35:59.160 --> 00:36:02.540
it was very clear that one of the biggest
pain points in the whole scheduling

00:36:02.540 --> 00:36:05.780
process is actually determining free/busy
information because that's really the

00:36:05.950 --> 00:36:09.320
first thing that people do when they're
actually putting together an invitation.

00:36:09.320 --> 00:36:11.870
You need to know, you know,
when can I actually book this meeting?

00:36:11.870 --> 00:36:13.050
What is a suitable time?

00:36:13.180 --> 00:36:16.840
And the ability to look at people's
free/busy information in almost real time

00:36:17.030 --> 00:36:19.330
was a very important key requirement.

00:36:19.410 --> 00:36:24.480
So in order to enable that,
we defined the CalDAV scheduling

00:36:24.480 --> 00:36:28.840
specification to return free/busy
information immediately to the end user.

00:36:28.840 --> 00:36:31.940
So the server calculates this on
behalf of the organizer and returns

00:36:32.030 --> 00:36:33.480
that information immediately.

00:36:33.630 --> 00:36:35.430
And we'll see an example
of this in a minute.

00:36:37.300 --> 00:36:40.890
So just graphically to represent
what happens in this process,

00:36:40.890 --> 00:36:42.790
we have an organizer and an attendee.

00:36:42.790 --> 00:36:46.450
The organizer adds the scheduling
request to their outbox.

00:36:46.550 --> 00:36:51.090
The server sees this being delivered
to the outbox and takes copies of that

00:36:51.270 --> 00:36:53.920
and puts that in each attendee's inbox.

00:36:53.960 --> 00:36:56.100
At some later point,
the attendee will see

00:36:56.100 --> 00:36:57.100
that in their inbox.

00:36:57.270 --> 00:36:58.800
They'll be able to pick it up.

00:36:58.800 --> 00:37:00.420
They'll be able to process it.

00:37:00.420 --> 00:37:03.180
And if they need to send a reply,
they can add that reply

00:37:03.180 --> 00:37:04.560
to their own outbox.

00:37:05.050 --> 00:37:08.200
Again, the server spots this
new reply in the outbox,

00:37:08.200 --> 00:37:11.700
picks it up and delivers it
to the organizer's inbox.

00:37:11.770 --> 00:37:14.800
And the organizer can pick up that
reply and update their local copy

00:37:14.800 --> 00:37:18.040
of the event with the new attendee
information that was provided.

00:37:18.040 --> 00:37:21.070
Another way to look at this
is what happens when you

00:37:21.370 --> 00:37:23.170
have more than one attendee.

00:37:24.490 --> 00:37:26.240
So again,
we have an organizer that's sending

00:37:26.240 --> 00:37:27.610
an invitation to the server.

00:37:27.750 --> 00:37:29.980
In this case,
the invitation actually lists

00:37:29.980 --> 00:37:31.570
four different attendees.

00:37:31.700 --> 00:37:34.230
So again,
the server is going to pick that

00:37:34.230 --> 00:37:38.920
up and deliver four copies of it to
each attendee's inbox on the server.

00:37:39.380 --> 00:37:41.910
Each attendee in their own time
is going to be able to see those

00:37:41.950 --> 00:37:45.230
invitations and they're going to be
able to send them back to the organizer.

00:37:45.240 --> 00:37:49.000
And the organizer will get
four copies or four status,

00:37:49.000 --> 00:37:50.970
four replies from each of the attendees.

00:37:50.980 --> 00:37:53.330
They'll be able to update
their own copy of that.

00:37:53.580 --> 00:37:56.530
They'll be able to push out updates
to other attendees to notify them

00:37:56.540 --> 00:37:59.820
of the status change of other
participants in the event and so on.

00:37:59.820 --> 00:38:02.840
This whole process is typically
called fan out in the calendaring

00:38:02.910 --> 00:38:04.450
and scheduling terminology.

00:38:06.670 --> 00:38:09.310
So let's take a quick look at our
scheduling request on the wire again.

00:38:09.320 --> 00:38:13.520
So for schedule requests,
we actually use the HTTP post method.

00:38:13.520 --> 00:38:15.070
And in this case, again,
we're targeting the

00:38:15.130 --> 00:38:16.180
outbox of the organizer.

00:38:16.180 --> 00:38:20.210
The request itself is
actually iCalendar data.

00:38:20.210 --> 00:38:24.460
In the HTTP headers,
we include addressing information.

00:38:24.460 --> 00:38:27.450
So this is the information about who
is the originator of the message,

00:38:27.460 --> 00:38:30.420
which may differ from the person
who's organizing the message.

00:38:31.120 --> 00:38:33.760
So if you have a delegate,
someone who's acting on your behalf,

00:38:33.760 --> 00:38:36.600
they will be listed as the originator,
though you as the organizer

00:38:36.600 --> 00:38:39.490
will be listed in the iCalendar
information as the organizer.

00:38:39.500 --> 00:38:41.460
So in email terms,
you know that there's a

00:38:41.510 --> 00:38:44.500
difference between the from
address and the sender address,

00:38:44.500 --> 00:38:45.300
et cetera.

00:38:45.300 --> 00:38:47.320
This is an equivalent type mechanism.

00:38:49.370 --> 00:38:52.140
Within the actual iCalendar data,
we have an ITIP request.

00:38:52.140 --> 00:38:54.330
In this case,
it's an ITIP event invitation.

00:38:54.430 --> 00:38:59.400
And the invitation itself is
for dinner on August the 9th.

00:38:59.500 --> 00:39:02.680
The reply that the organizer
gets back from the server,

00:39:02.680 --> 00:39:05.950
again, it's going to be hopefully
an okay response.

00:39:05.970 --> 00:39:07.560
Again, it's going to be XML data.

00:39:07.560 --> 00:39:11.380
And encoded within that response is
going to be information about whether

00:39:11.380 --> 00:39:15.150
the event was successfully delivered
to the attendee's inbox or not.

00:39:15.200 --> 00:39:18.100
If the attendee had disabled
my right to schedule with them,

00:39:18.100 --> 00:39:20.710
I would get a negative
response back at this point.

00:39:20.780 --> 00:39:23.290
Luckily, in this case,
it was successfully delivered,

00:39:23.290 --> 00:39:24.770
so you get a success response.

00:39:24.820 --> 00:39:30.250
Let's take a look at the FreeBusy case,
which differs from the

00:39:30.700 --> 00:39:32.570
invitation process.

00:39:32.580 --> 00:39:36.940
So again, with FreeBusy,
we do a post request on the HTTP server.

00:39:36.940 --> 00:39:39.020
Again, we provide iCalendar data.

00:39:39.020 --> 00:39:41.240
Again,
we provide the addressing information.

00:39:41.240 --> 00:39:44.820
This time, however,
we have an ITIP FreeBusy request.

00:39:45.290 --> 00:39:48.750
And we're going to be asking the server
for the response to the freeBusy request.

00:39:49.000 --> 00:39:50.930
And we're going to be asking the server
for the response to the freeBusy request.

00:39:50.960 --> 00:39:53.840
Now,
the response we get back from the server

00:39:53.840 --> 00:39:57.610
looks similar to what we got back before,
except that now the actual

00:39:57.640 --> 00:40:01.060
iCalendar FreeBusy information
is included in that response.

00:40:01.060 --> 00:40:05.380
So we don't need to wait for the
attendee to hit reply in their client.

00:40:05.460 --> 00:40:08.540
The server automatically determines
the FreeBusy information for

00:40:08.540 --> 00:40:13.260
that attendee and returns it in
virtually real time to the organizer.

00:40:15.000 --> 00:40:17.420
And in this case,
the attendee was just busy for an hour.

00:40:17.420 --> 00:40:20.820
So where are we with CalDAV today?

00:40:20.820 --> 00:40:23.940
Well,
there's been a lot of interoperability

00:40:23.940 --> 00:40:28.680
testing carried out between the various
people that have CalDAV products.

00:40:28.680 --> 00:40:31.440
This actually started
back in January 2005,

00:40:31.440 --> 00:40:34.810
and we've been holding about three
interrupts a year since then.

00:40:34.820 --> 00:40:38.060
Again, it's been carried out under
the auspices of the Calendaring

00:40:38.060 --> 00:40:39.760
and Scheduling Consortium.

00:40:40.680 --> 00:40:42.650
The next event, interop event,
by the way,

00:40:42.650 --> 00:40:46.200
is actually being hosted by Apple at
the end of September down in Cupertino.

00:40:47.600 --> 00:40:50.700
There was a recent free busy
demonstration that was done,

00:40:50.700 --> 00:40:53.800
again, put together by the
CalConnect organization.

00:40:53.800 --> 00:40:56.200
And that actually showed
several different,

00:40:56.250 --> 00:40:58.680
in some cases,
proprietary calendaring and

00:40:58.680 --> 00:41:03.430
scheduling systems actually leveraging
CalDAV to do cross-organizational

00:41:03.440 --> 00:41:04.960
free and busy lookups.

00:41:05.590 --> 00:41:10.080
So CalDAV was effectively acting as
an aggregator for proprietary systems,

00:41:10.080 --> 00:41:13.830
aggregating free busy information
from these and providing a standard

00:41:13.830 --> 00:41:18.060
CalDAV interface for clients to actually
access that free busy information.

00:41:18.060 --> 00:41:24.480
That demonstration was done about a month
and a half ago and was very successful.

00:41:24.480 --> 00:41:26.760
And again,
we're going to be building on that

00:41:26.760 --> 00:41:30.140
in terms of the server-to-server
protocol to actually build out this

00:41:30.140 --> 00:41:32.440
new server-to-server specification.

00:41:32.440 --> 00:41:35.440
Now, it's fair to say that
CalDAV is interesting.

00:41:35.540 --> 00:41:36.860
It's really still in its infancy.

00:41:36.860 --> 00:41:40.150
And there are certain key elements
of a true calendaring scheduling

00:41:40.150 --> 00:41:43.580
system that are missing right now
that still need to be specified.

00:41:43.580 --> 00:41:45.930
Obviously, as I discussed before,
we need to do this

00:41:45.930 --> 00:41:47.440
server-to-server protocol.

00:41:47.440 --> 00:41:50.570
In addition,
HTTP does not really have a way

00:41:50.570 --> 00:41:55.040
for the server to notify the
client of changes on the server.

00:41:55.040 --> 00:41:58.080
So we need a way to do asynchronous
notifications so that the client

00:41:58.210 --> 00:42:01.300
doesn't have to continually poll
the server to look for changes.

00:42:01.300 --> 00:42:03.440
So that's another element
that we need to specify.

00:42:03.440 --> 00:42:05.440
And that's more important.

00:42:05.540 --> 00:42:07.100
And we're going to be looking at
more of an HTTP issue as well.

00:42:07.100 --> 00:42:09.900
So it's going to be done within
the HTTP community rather than

00:42:09.910 --> 00:42:11.360
just the CalDAV community.

00:42:11.360 --> 00:42:16.070
We also need a way to do smart and
efficient collection synchronization.

00:42:16.080 --> 00:42:18.000
So again,
trying to minimize the bandwidth

00:42:18.020 --> 00:42:20.650
and the data that clients need
to exchange with the server so

00:42:20.650 --> 00:42:22.270
that we can be efficient on that.

00:42:22.320 --> 00:42:24.800
And again,
this is looking at not just to benefit

00:42:24.800 --> 00:42:27.120
desktop clients but also mobile clients.

00:42:27.120 --> 00:42:32.330
But we really want to see a good adoption
of CalDAV in the mobile arena as well.

00:42:32.340 --> 00:42:35.460
And the other thing that
we would like to see.

00:42:35.540 --> 00:42:38.080
Is the ability to do partial
updates of resources.

00:42:38.080 --> 00:42:41.800
Before when I described the
partial fetching of resources.

00:42:41.800 --> 00:42:46.940
You could download part of an event and
avoid having to download the attachment.

00:42:46.940 --> 00:42:49.660
But one thing we're lacking
is the ability to change,

00:42:49.660 --> 00:42:52.970
say, just the start time of an event
without actually having to upload

00:42:52.970 --> 00:42:54.550
the entire attachment along with it.

00:42:54.660 --> 00:42:56.820
So again,
a way to do partial updates on an

00:42:56.820 --> 00:42:58.590
HTTP server will be good as well.

00:42:58.720 --> 00:43:02.650
So with that,
I would like to actually turn back to

00:43:02.740 --> 00:43:04.540
Wilfredo and have him come up here.

00:43:04.540 --> 00:43:05.460
And give you a.

00:43:05.670 --> 00:43:07.560
an in-depth look at our CalDAV server.

00:43:14.100 --> 00:43:15.720
Thanks Cyrus.

00:43:15.810 --> 00:43:19.750
So now that we know all about how
to implement a calendar server,

00:43:19.830 --> 00:43:23.070
fortunately you don't have to
go off and do it because we did

00:43:23.070 --> 00:43:24.850
one for you and you can use it.

00:43:24.860 --> 00:43:29.600
Again, the Darwin Calendar Server is
an HTTP server because you

00:43:29.600 --> 00:43:33.580
have to be an HTTP server in
order to be a WebDAV server,

00:43:33.580 --> 00:43:36.360
which it is also,
and you've got to be that in

00:43:36.360 --> 00:43:39.380
order to be a CalDAV server,
which of course is the end goal.

00:43:40.140 --> 00:43:41.960
Our server is written in Python.

00:43:41.960 --> 00:43:47.660
It is based on the Twisted Framework and
it's configurable using Open Directory.

00:43:47.660 --> 00:43:49.670
So let's get into some detail here.

00:43:49.670 --> 00:43:52.080
Again, the server is written in Python.

00:43:52.080 --> 00:43:55.460
It's a dynamic, flexible,
object-oriented programming language.

00:43:55.460 --> 00:43:58.700
It's been very convenient for us to
code in this and hopefully you'll

00:43:58.700 --> 00:44:02.540
be hearing a little more about that
tomorrow when Bill talks about how

00:44:02.540 --> 00:44:07.730
you can write Cocoa applications
using Python and so on.

00:44:08.810 --> 00:44:12.880
Leopard includes Python version 2.4,
which we're actually using in our server,

00:44:12.880 --> 00:44:15.980
although it probably wouldn't be
too hard to backport it to 2.3.

00:44:15.980 --> 00:44:19.520
A common question I'm getting when
I mention Python is what's the

00:44:19.520 --> 00:44:22.530
performance of this scripting language,
right?

00:44:22.540 --> 00:44:25.380
It's not C,
so it's not going to be super fast,

00:44:25.490 --> 00:44:26.090
right?

00:44:26.100 --> 00:44:29.480
And it turns out that actually
Python's not a bottleneck.

00:44:29.520 --> 00:44:33.500
There are plenty of examples of
high-scale Python implementation,

00:44:33.500 --> 00:44:37.930
such as like eGroups from way back
when and a bunch of things like that.

00:44:38.460 --> 00:44:41.780
The particularly CPU-intensive
work is actually still done in C,

00:44:41.780 --> 00:44:44.770
such as SSL handling,
which talks to the OpenSSL framework.

00:44:44.780 --> 00:44:52.140
But we fully expect our server to scale
to moderate to large organizations.

00:44:52.140 --> 00:44:56.790
We are not building something that you
could deploy as a Yahoo or a Google,

00:44:56.790 --> 00:44:58.930
because, wow, that's hard.

00:44:58.940 --> 00:45:04.320
But for your business,
we should be just fine.

00:45:07.020 --> 00:45:10.930
Again, this is built using
the Twisted framework.

00:45:11.070 --> 00:45:14.400
Twisted is an open source
networking framework and that's

00:45:14.400 --> 00:45:17.450
of course written in Python.

00:45:17.910 --> 00:45:21.540
It provides for us a lot of
functionality that we already

00:45:21.540 --> 00:45:22.900
needed in order to get started.

00:45:22.900 --> 00:45:29.630
And it implements a bunch of protocols
such as IMAP and POP3 and NetNews and

00:45:29.630 --> 00:45:32.560
SSH and particularly of interest to us,
HTTP.

00:45:32.560 --> 00:45:35.960
It's got a very active
development community.

00:45:35.960 --> 00:45:38.430
What's interesting about
Twisted is that it's,

00:45:38.430 --> 00:45:40.900
again, asynchronous,
but it does this without

00:45:40.900 --> 00:45:42.020
using any threads.

00:45:42.620 --> 00:45:47.270
So all the headaches of thread
management and the bugs and the endless

00:45:47.430 --> 00:45:50.550
debugging that you do with threads,
we don't have to worry about

00:45:50.550 --> 00:45:52.470
because we're not using threads.

00:45:52.520 --> 00:45:54.460
But at the same time,
it can field multiple

00:45:54.460 --> 00:45:55.860
requests at the same time.

00:45:55.860 --> 00:45:58.950
So when you have a blocking operation,
such as you're going to write to

00:45:58.950 --> 00:46:01.210
the network or you're going to read
from a file or you're going to do

00:46:01.210 --> 00:46:05.090
something that's going to take a while,
rather than writing a method that

00:46:05.090 --> 00:46:10.150
does that and then returns an answer,
what you do is you schedule that

00:46:10.150 --> 00:46:14.300
operation and then you return a
promise to give the caller an answer.

00:46:14.300 --> 00:46:15.890
So that's called a deferred object.

00:46:15.960 --> 00:46:20.090
And a deferred object doesn't
necessarily know what data you

00:46:20.090 --> 00:46:22.300
are going to read right away.

00:46:22.300 --> 00:46:25.070
So as the caller,
you get back this object and then

00:46:25.300 --> 00:46:29.190
you chain onto it a callback,
which once the answer is available,

00:46:29.190 --> 00:46:32.780
that callback gets called and then you
can continue your processing from there.

00:46:32.780 --> 00:46:36.300
So it's a somewhat different
way to write your software,

00:46:36.300 --> 00:46:40.320
but it's actually fairly effective
at doing this asynchronous operation

00:46:40.320 --> 00:46:42.060
without a whole lot of grief.

00:46:42.260 --> 00:46:43.460
- Yeah.

00:46:44.750 --> 00:46:45.900
It's actually pretty cool.

00:46:45.900 --> 00:46:51.150
So Twisted Web 2 is a submodule
within Twisted that implements HTTP.

00:46:51.200 --> 00:46:57.580
In particular,
it does it by modeling a resource as

00:46:57.580 --> 00:47:01.390
an instantiated object so that whenever
you're going to field a request,

00:47:01.390 --> 00:47:03.440
the server gets a request for some URL.

00:47:03.440 --> 00:47:06.740
It figures out which resource is
responsible for handling that URL.

00:47:06.740 --> 00:47:10.510
It instantiates that resource and then
it calls a method on that resource

00:47:10.510 --> 00:47:14.320
which corresponds to the HTTP method
which was called in the request.

00:47:14.700 --> 00:47:17.690
So in a typical GET request,
you're going to create some resource

00:47:17.690 --> 00:47:23.050
and that resource is going to get called
with a method called HTTP_GET and that

00:47:23.160 --> 00:47:28.420
method will get a request object with
it and it's going to do some processing,

00:47:28.420 --> 00:47:33.160
probably read a file and render out some
HTML and then it's going to return a

00:47:33.160 --> 00:47:38.810
response object or very likely a deferred
response object that then the server,

00:47:38.860 --> 00:47:41.810
once that deferred fires,
will actually give a

00:47:41.840 --> 00:47:43.890
response back to the client.

00:47:45.500 --> 00:47:49.900
Twisted WebDAV is a submodule of Twisted
Web 2 and that implements WebDAV.

00:47:49.970 --> 00:47:55.590
This was actually written by Apple,
me mostly, and contributed to the Twisted

00:47:55.610 --> 00:47:57.590
project as part of open source stuff.

00:47:57.630 --> 00:48:02.210
What's cool about Twisted WebDAV is that
it leverages all of the stuff that was

00:48:02.210 --> 00:48:06.960
in Web 2 to do all the HTTP stuff and
then it adds in WebDAV functionality.

00:48:07.120 --> 00:48:11.360
It supports WebDAV level 1,
which is all of your typical get, copy,

00:48:11.450 --> 00:48:14.820
move methods, put,
which is actually an HTTP method,

00:48:14.830 --> 00:48:18.390
but only WebDAV client
servers tend to implement it,

00:48:18.390 --> 00:48:20.890
and all your regular WebDAV methods.

00:48:20.900 --> 00:48:23.950
It supports WebDAV ACLs,
which is important for

00:48:23.950 --> 00:48:27.460
the scheduling stuff,
as Cyrus was talking about.

00:48:27.460 --> 00:48:30.640
You need to be able to grant
permissions to have certain kinds

00:48:30.640 --> 00:48:34.680
of access on specific resources and
it implements that specification.

00:48:34.680 --> 00:48:38.260
We're starting some work
on... WebDAV level 3,

00:48:38.260 --> 00:48:44.140
which is the next revision of WebDAV is
actually in... being written right

00:48:44.140 --> 00:48:49.010
now in its final forms and it's just
a small update to WebDAV level 1.

00:48:49.080 --> 00:48:54.140
It does not support WebDAV level 2,
which is the lock and unlock methods.

00:48:54.140 --> 00:48:57.500
So it's not really suitable for, say,
mounting in Finder,

00:48:57.500 --> 00:49:01.630
but lock and unlock are
not required for CalDAV,

00:49:01.630 --> 00:49:04.440
so we kind of skipped over that for
the time being in order to get the

00:49:04.440 --> 00:49:06.020
calendaring implementation done.

00:49:07.220 --> 00:49:11.080
And it does not support
all of WebDAV versioning.

00:49:11.080 --> 00:49:14.560
It does support the report method,
which is specified in the versioning spec

00:49:14.610 --> 00:49:17.070
because CalDAV needs a report method.

00:49:20.600 --> 00:49:25.710
So Twisted CalDAV is a module that
builds on top of Twisted WebDAV,

00:49:25.710 --> 00:49:27.300
which builds on Web2.

00:49:27.300 --> 00:49:29.580
So you can see how this stuff
starts to layer fairly nicely.

00:49:29.580 --> 00:49:31.400
You just start subclassing a lot.

00:49:31.440 --> 00:49:35.040
And in this case,
we add all of the CalDAV functionality.

00:49:35.040 --> 00:49:37.200
In particular,
we're implementing CalDAV access,

00:49:37.200 --> 00:49:40.620
which means we have to implement
the make calendar method in order to

00:49:40.620 --> 00:49:43.830
let you create calendar collections,
which are somewhat unique from

00:49:43.830 --> 00:49:45.080
regular WebDAV collections.

00:49:46.900 --> 00:49:51.160
It has a lot of business logic behind
it for doing calendaring operations.

00:49:51.160 --> 00:49:53.870
So it has, of course,
an iCalendar parser and an iCalendar

00:49:53.870 --> 00:49:57.460
generator so that when you edit stuff,
it can send you back useful data.

00:49:57.460 --> 00:50:00.330
It supports all of the
CalDAV reports that Cyrus was

00:50:00.330 --> 00:50:02.300
going through in his examples.

00:50:02.300 --> 00:50:05.600
It supports the
read-free-busy ACL privilege,

00:50:05.600 --> 00:50:09.340
which says that on a calendar collection,
I can grant somebody permission

00:50:09.340 --> 00:50:12.420
to see whether I'm busy,
but without giving them permission

00:50:12.460 --> 00:50:14.310
to actually read why I'm busy.

00:50:14.320 --> 00:50:16.880
And that might be particularly important.

00:50:16.880 --> 00:50:17.730
For a lot of us.

00:50:17.740 --> 00:50:21.850
And it enforces good
behavior from clients.

00:50:21.890 --> 00:50:26.210
So you can't like have some Yahoo crazy,
not Yahoo the website,

00:50:26.220 --> 00:50:30.470
but some crazy client come in and
then start writing random data that

00:50:30.470 --> 00:50:35.680
then confuses iCal or whatever other
clients that are well-behaved out there.

00:50:35.680 --> 00:50:38.310
So if you try to write
JPEG information into what you're

00:50:38.310 --> 00:50:41.430
claiming is an iCalendar file,
it's going to say, well, hold on,

00:50:41.430 --> 00:50:43.620
that's not iCalendar data
and refuse the request.

00:50:43.640 --> 00:50:46.660
It also implements CalDAV scares.

00:50:46.900 --> 00:50:50.140
So it's a great tool for scheduling,
which means it does all of this inbox and

00:50:50.140 --> 00:50:52.200
outbox fan out that Cyrus is describing.

00:50:52.200 --> 00:50:53.400
You can park data into it.

00:50:53.400 --> 00:50:56.220
It'll automatically forward it
along to other users and then

00:50:56.220 --> 00:50:57.660
they can pick it up from there.

00:50:57.760 --> 00:51:02.010
It supports all of the scheduling
requests and it knows about

00:51:02.010 --> 00:51:03.540
itip and some of this logic.

00:51:03.540 --> 00:51:05.320
Again,
it's all calendar and business logic.

00:51:05.320 --> 00:51:09.080
So it's not just webDAV,
it's webDAV with some calendaring smarts.

00:51:09.100 --> 00:51:13.230
It returns free busy
responses right away.

00:51:13.270 --> 00:51:16.680
So it actually will when you schedule
and I want to know whether Skip is busy.

00:51:16.900 --> 00:51:18.280
I look at his calendar.

00:51:18.280 --> 00:51:21.860
The server actually reads all
of his scheduling information,

00:51:21.860 --> 00:51:24.760
aggregates that into a free
busy response that's useful.

00:51:24.850 --> 00:51:27.400
Again, if you have that privilege
and it shuttles it back to the

00:51:27.400 --> 00:51:29.100
client that's requesting it.

00:51:29.220 --> 00:51:32.560
And it has scheduling specific
access control privileges.

00:51:32.580 --> 00:51:35.810
So you can, again,
the concern being that you

00:51:35.810 --> 00:51:36.920
don't want calendar spam.

00:51:36.920 --> 00:51:39.840
You don't want anybody to be able
to propose meetings with you.

00:51:39.840 --> 00:51:43.360
You want to restrict that to some
subset of people that you know are sane.

00:51:43.480 --> 00:51:46.720
So you can do that with ACLs.

00:51:49.170 --> 00:51:53.850
So looking at the implementation,
you'll see that our data storage

00:51:53.850 --> 00:51:55.140
is actually all file based.

00:51:55.140 --> 00:51:59.780
There's no SQL massive database that
stores all this calendar information.

00:51:59.780 --> 00:52:01.570
We're just writing
information out to file.

00:52:01.610 --> 00:52:05.920
So the resource layout that you see in
your web server is actually what you see

00:52:05.920 --> 00:52:08.350
on disk when you look at the data store.

00:52:08.370 --> 00:52:13.090
And so it's a lot like managing a typical
Apache install or regular web server.

00:52:13.090 --> 00:52:16.260
What's nice about that
is that it's simple.

00:52:16.260 --> 00:52:19.320
If you want to just see what's going on,
you can see the into

00:52:19.370 --> 00:52:20.990
the documents directory.

00:52:21.000 --> 00:52:25.730
You can kind of poke around in there and
use tools like CAT and CP to manipulate

00:52:25.730 --> 00:52:28.450
the data in there if you need to do that.

00:52:28.450 --> 00:52:32.300
And you don't need special
database specific tools.

00:52:33.960 --> 00:52:38.820
and that also has the advantage of giving
you like some flexibility in how you do

00:52:38.820 --> 00:52:40.540
your backups and restores and the like.

00:52:40.540 --> 00:52:44.520
Properties are stored in files as well.

00:52:44.520 --> 00:52:45.900
They're stored as extended attributes.

00:52:45.900 --> 00:52:50.860
So if you think webdap properties kind of
look and smell like extended attributes,

00:52:50.950 --> 00:52:53.880
well, in our implementation, actually,
they are.

00:52:53.880 --> 00:52:58.760
Now,
in order for the performance to be good,

00:52:58.760 --> 00:53:00.720
because, again,
we want this to scale to a

00:53:00.740 --> 00:53:05.150
fairly large organizational size,
we use SQLite databases to index that

00:53:05.150 --> 00:53:09.360
information so that when we do a lookup,
rather than having to open 1,000

00:53:09.360 --> 00:53:12.580
files that might be in your calendar,
we just say, well,

00:53:12.580 --> 00:53:15.560
let's look up where the event
with this given UID lives.

00:53:15.560 --> 00:53:18.690
And then we can just go straight
to that file or actually keeps

00:53:18.690 --> 00:53:20.440
all of the time spans in there.

00:53:20.440 --> 00:53:23.430
So if I want to find out all of the
events that are happening this month,

00:53:23.510 --> 00:53:27.670
I can actually use a SQLite database
to kind of find which data is likely to

00:53:27.770 --> 00:53:31.410
have that and narrow my search down and
then go straight to that set of files.

00:53:32.300 --> 00:53:33.730
Um...

00:53:34.560 --> 00:53:37.390
Account information,
that is which users exist,

00:53:37.390 --> 00:53:40.000
which groups exist and which
resources such as rooms and

00:53:40.060 --> 00:53:43.120
projectors and the like exist,
that all lives in open directory.

00:53:43.120 --> 00:53:46.110
So you manage that using
regular open directory tools,

00:53:46.140 --> 00:53:49.200
your work group manager,
your team's directory and all

00:53:49.200 --> 00:53:52.630
of the great tools that come
out of the open directory team.

00:53:52.630 --> 00:53:57.210
And that of course has the advantage of
being able to integrate with the rest of

00:53:57.210 --> 00:54:02.050
your authentication and user management
systems throughout your business.

00:54:03.580 --> 00:54:05.550
Again,
we use SQLite to cache some information

00:54:05.550 --> 00:54:08.770
off of open directory so that we're not
making quite so many network requests

00:54:08.770 --> 00:54:11.690
every time somebody comes in and says,
oh, I'd like to schedule with

00:54:11.690 --> 00:54:14.400
somebody and I have to figure out,
oh, I don't know who that is,

00:54:14.400 --> 00:54:15.920
let me go to open directory.

00:54:15.920 --> 00:54:17.870
Well,
we remember some of that information

00:54:17.880 --> 00:54:20.800
for a while so that we don't
have to keep doing these lookups.

00:54:20.800 --> 00:54:24.100
Again, the SQLite databases are there
only for performance reasons.

00:54:24.100 --> 00:54:26.120
So if for some reason
they're annoying you,

00:54:26.120 --> 00:54:29.430
you think there might be a corrupt file,
you don't know what's going on,

00:54:29.430 --> 00:54:33.000
you can just delete the file and next
time around it'll get regenerated.

00:54:33.430 --> 00:54:38.060
These are all things that we can do.

00:54:38.060 --> 00:54:46.380
And if you're not familiar with them,
you can just delete them.

00:54:46.380 --> 00:54:47.710
And if you're not familiar with them,
you can just delete them.

00:54:47.710 --> 00:54:47.710
And if you're not familiar with them,
you can just delete them.

00:54:49.840 --> 00:54:54.000
Again, the server is configured using
open directory so you can use your

00:54:54.000 --> 00:54:55.880
standard open directory tools.

00:54:55.990 --> 00:55:00.340
The way this works is if you remember
the diagram that Cyrus had where you have

00:55:00.460 --> 00:55:04.850
principles and then you have calendars,
the principles that are HTTP resources

00:55:04.880 --> 00:55:10.570
that are actually backed by open
directory and not really primary on disk.

00:55:10.660 --> 00:55:14.500
So we look up which users are
around on your directory system and

00:55:14.610 --> 00:55:18.390
that's how we populate the users,
groups and resources parts

00:55:18.390 --> 00:55:20.460
of the principle hierarchy.

00:55:20.460 --> 00:55:22.840
But at the same time,
we figure that any user who's

00:55:22.840 --> 00:55:25.620
got an account on the calendar
server also needs a calendar

00:55:25.620 --> 00:55:29.040
collection so we also provision
out the calendaring information.

00:55:29.040 --> 00:55:31.870
And again,
not all of your users in open directory

00:55:31.870 --> 00:55:33.950
have to have calendar accounts.

00:55:34.000 --> 00:55:36.220
You might want to only
have some subset of users.

00:55:36.220 --> 00:55:38.120
You might create some users
that don't need calendaring.

00:55:38.120 --> 00:55:40.410
And you can enable or disable that in.

00:55:40.660 --> 00:55:42.650
So you can do that in the open directory
using one of the properties there.

00:55:42.660 --> 00:55:47.200
Again, user authentication is done
via open directory so your

00:55:47.200 --> 00:55:51.360
regular HTTP authentication
mechanism is hooked into that.

00:55:51.460 --> 00:55:56.450
There's no crazy forms
based authentication,

00:55:56.520 --> 00:55:57.980
fortunately.

00:55:58.360 --> 00:56:00.590
And Kerberos authentication
is in progress.

00:56:00.600 --> 00:56:03.640
iCal and the Leopard seed
doesn't support Kerberos auth,

00:56:03.650 --> 00:56:08.440
but we plan to have that for Leopard and
so that'll fit into your single sign-on

00:56:08.440 --> 00:56:10.460
strategy if you're using Kerberos.

00:56:12.480 --> 00:56:17.970
So let's talk about the
actual implementation a bit.

00:56:18.050 --> 00:56:20.720
First thing is you're going to
probably want to get some source code.

00:56:20.780 --> 00:56:24.020
And the way you do
that is use Subversion.

00:56:24.020 --> 00:56:25.810
In the Leopard Seed,
Subversion is built in.

00:56:25.940 --> 00:56:29.100
Yay.

00:56:31.000 --> 00:56:34.490
If you're using Tiger,
you can download it from some websites.

00:56:34.500 --> 00:56:36.800
We have some information on
our site on how to do that.

00:56:36.920 --> 00:56:39.470
But once you've got Subversion,
you can just do Subversion

00:56:39.490 --> 00:56:42.840
Checkout of that URL there,
which is on Mac OS Forge,

00:56:42.960 --> 00:56:48.440
and get your own handy dandy copy of the
calendar server as it is in development.

00:56:48.510 --> 00:56:50.770
Once you've got the source code,
you can change the

00:56:50.770 --> 00:56:54.620
directories into there,
copy one of the example

00:56:55.090 --> 00:56:58.690
Director of Configuration Files
in your development environment.

00:56:58.690 --> 00:57:00.980
In this case,
we're going to suggest you use

00:57:00.990 --> 00:57:04.240
a static one so that you don't
have to also set up open directory

00:57:04.240 --> 00:57:05.860
in order to test your server.

00:57:05.860 --> 00:57:09.230
You can actually, in XML,
specify a set of users and just create

00:57:09.230 --> 00:57:11.480
an admin account with the test password.

00:57:11.480 --> 00:57:14.800
And then you run this shell
script that's in there called run.

00:57:14.800 --> 00:57:18.060
And that will actually finish
up the rest of your downloads.

00:57:18.060 --> 00:57:21.090
It's got to download a few
dependent libraries that we use.

00:57:21.250 --> 00:57:26.660
And it knows whether to fetch the
right ones on Tiger versus Leopard.

00:57:26.700 --> 00:57:28.470
And then it should get you started.

00:57:28.490 --> 00:57:32.110
Now we've got a couple of kinks in
this I'm finding out from emails,

00:57:32.110 --> 00:57:37.560
but this will be that easy by
the time I get home next week.

00:57:39.300 --> 00:57:42.550
And then you've got a running
server so you can get Safari out,

00:57:42.580 --> 00:57:47.140
you can connect to local host port
8008 which is the default HTTP port

00:57:47.140 --> 00:57:49.960
we're using and then you can actually
poke around in it using your web

00:57:49.960 --> 00:57:54.940
browser or you can launch iCal and
you can poke around at it using that.

00:57:56.710 --> 00:57:59.870
So I mentioned that we're
dependent on some other software.

00:57:59.870 --> 00:58:03.980
If there's anything you take home
from all of the stuff that Cyrus was

00:58:04.120 --> 00:58:08.120
telling you about iCalendar and so
on is that it's pretty complicated to

00:58:08.120 --> 00:58:11.500
implement all of the iCalendar logic
and you probably don't want to build

00:58:11.500 --> 00:58:14.120
that yourself and neither did we,
so we stole a lot of code.

00:58:14.420 --> 00:58:18.690
First of all, like I mentioned,
we use Twisted for our core

00:58:18.910 --> 00:58:21.220
engine that drives the server.

00:58:21.220 --> 00:58:24.390
We use a library called VObject,
which is written by one of the fellows

00:58:24.500 --> 00:58:27.340
at the Open Source Applications
Foundation named Jeffrey,

00:58:27.370 --> 00:58:30.720
and that deals with all of this
iCalendar parsing and generating,

00:58:30.720 --> 00:58:33.560
which we fortunately don't
have to build ourselves.

00:58:33.580 --> 00:58:36.980
Twisted requires a small bit
of the ZOAP framework called

00:58:36.980 --> 00:58:41.240
ZOAP Interface in order to do some,
declare programming interfaces,

00:58:41.300 --> 00:58:44.400
which is a feature that
Python doesn't provide.

00:58:44.400 --> 00:58:47.310
We use PyXML to do all
of our XML generation.

00:58:47.310 --> 00:58:51.540
If you're a web dev person,
you're doing a lot of XML processing,

00:58:51.540 --> 00:58:53.860
so that's our engine for that.

00:58:53.930 --> 00:58:59.370
We use DateUtil to do a lot of the
recurrence and date processing magic,

00:58:59.370 --> 00:59:01.850
and VObject depends on that.

00:59:01.880 --> 00:59:05.610
We use PyOpenSSL, which is a thin shim on
top of the OpenSSL library,

00:59:05.610 --> 00:59:08.610
as I mentioned before,
which of course is written in C,

00:59:08.640 --> 00:59:10.740
so we're actually binding to that.

00:59:10.760 --> 00:59:14.400
Bobby Pulido wrote a small shim
to the extended application.

00:59:14.400 --> 00:59:18.670
We use Attributes API that's in
Mac OS X and on Linux and on FreeBSD,

00:59:18.860 --> 00:59:22.040
and so we use that to store
our web dev properties.

00:59:22.200 --> 00:59:26.700
And we use PySQLite to store those
SQLite databases I was talking about.

00:59:26.900 --> 00:59:31.560
So we're kind of a player
in a lot of little buckets.

00:59:31.660 --> 00:59:34.360
And in order to implement
our open directory magic,

00:59:34.360 --> 00:59:36.560
which stores all the
data in LDAP and so on,

00:59:36.560 --> 00:59:40.900
and to do the Kerberos authentication,
we had to write a couple of more modules,

00:59:40.960 --> 00:59:43.360
and that's PyKerberos
and PyOpenDirectory.

00:59:43.760 --> 00:59:48.590
both also on the same source
repository as the calendar server.

00:59:49.920 --> 00:59:53.800
Hopefully they're useful for things
outside of the calendar server as well.

00:59:53.820 --> 00:59:58.200
So just briefly I'm going to go
over some of the classes that are

00:59:58.200 --> 01:00:00.410
in the source code so that you
don't quite have to figure out

01:00:00.480 --> 01:00:03.600
the architecture of it from zero.

01:00:03.810 --> 01:00:06.460
This is actually a fairly
simplified version of what's

01:00:06.460 --> 01:00:09.800
going on but it should give you an
idea of how we built the server.

01:00:09.800 --> 01:00:13.530
So again,
Twisted Web 2 implements HTTP as

01:00:13.560 --> 01:00:17.800
a collection of resources
which are instantiated.

01:00:17.800 --> 01:00:22.210
So you've got a resource class
that's kind of a generic class and

01:00:22.280 --> 01:00:24.480
knows how to do some basic HTTP.

01:00:24.900 --> 01:00:26.360
operations.

01:00:26.380 --> 01:00:30.830
And we have a static derivative of
that which knows how to do things

01:00:30.840 --> 01:00:34.540
like generate an e-tag on the fly,
get you the last modified time,

01:00:34.540 --> 01:00:39.280
just for resources that are not like
your CGI type dynamic resources.

01:00:39.280 --> 01:00:42.800
And from that,
there's a file implementation.

01:00:42.800 --> 01:00:45.470
So the file implementation, of course,
you send it a get request and

01:00:45.530 --> 01:00:47.820
it's going to read some data
off of the disk and just shuttle

01:00:47.820 --> 01:00:49.260
that back up to the protocol.

01:00:49.260 --> 01:00:54.600
And that's a fairly simple,
typical web server right there.

01:00:54.800 --> 01:00:59.040
In order to implement WebDAV,
we subclassed the static resource

01:00:59.040 --> 01:01:02.990
into a DAV resource class and
that knows how to do a couple more

01:01:03.000 --> 01:01:05.800
things that are specific to WebDAV.

01:01:05.800 --> 01:01:09.300
In particular, it has a property store.

01:01:09.300 --> 01:01:11.490
And that property store is
where the WebDAV property

01:01:11.550 --> 01:01:12.960
information is going to live.

01:01:13.000 --> 01:01:16.610
And our implementation of
that uses extended attributes,

01:01:16.610 --> 01:01:17.790
as I mentioned.

01:01:18.860 --> 01:01:21.490
That in turn is subclassed
in a class called DAV file.

01:01:21.500 --> 01:01:24.600
Now you notice here there's
multiple inheritance.

01:01:24.600 --> 01:01:27.580
So if you're terrified of that,
close your eyes.

01:01:27.690 --> 01:01:29.050
But it's actually fairly straightforward.

01:01:29.080 --> 01:01:32.540
We derive from the file class because
we want to read data off of the disk

01:01:32.540 --> 01:01:36.570
and the file implementation does that
and we derive from DAV resource in

01:01:36.570 --> 01:01:39.620
order to get some common web DAV logic.

01:01:39.930 --> 01:01:44.030
And then of course, subclassing that for
CalDAV resource and CalDAV file,

01:01:44.040 --> 01:01:46.100
we get the calendaring logic in there.

01:01:46.100 --> 01:01:49.710
So you can see how this stuff kind
of layers very nicely from regular

01:01:49.760 --> 01:01:54.140
HTTP processing down to WebDAV processing
and down to calendaring processing.

01:01:54.140 --> 01:01:57.820
And there's some other classes in
there which do some WebDAV things

01:01:57.830 --> 01:02:02.570
such as like there's a DAV principle
resource which knows how to instantiate

01:02:02.570 --> 01:02:06.120
a principle and what that means and
you can authenticate against it.

01:02:06.240 --> 01:02:08.740
And there's a file-based
implementation of that as well.

01:02:08.840 --> 01:02:12.310
So you can see how all this
stuff kind of ties in together.

01:02:12.540 --> 01:02:16.050
So hopefully like you guys are
excited about some of this stuff

01:02:16.140 --> 01:02:18.200
and might want to tie it into
something that you're doing.

01:02:18.200 --> 01:02:20.890
You might want to tie it to
some calendaring backends

01:02:20.890 --> 01:02:22.560
that you've got already.

01:02:22.560 --> 01:02:24.930
You might want to implement it
to control some other stuff.

01:02:25.000 --> 01:02:27.780
Maybe you want to implement
a public event system,

01:02:27.780 --> 01:02:30.250
some Evite type thing
without all the ads.

01:02:32.580 --> 01:02:36.260
Or you want to run your sprinklers
at home or change your thermostat

01:02:36.630 --> 01:02:38.420
settings while you're at work.

01:02:38.480 --> 01:02:41.170
You can imagine that a calendar
server can kind of just bind

01:02:41.180 --> 01:02:44.100
to these information systems
and kind of drive that stuff.

01:02:44.190 --> 01:02:46.290
And so there's some cool stuff
that I think could be done there.

01:02:46.300 --> 01:02:50.680
But also you can extend the
protocol which there's a lot of

01:02:50.680 --> 01:02:55.890
interest in Atom right now because
Google Calendar is doing Atom for

01:02:55.890 --> 01:02:59.300
subscribing to calendar information.

01:02:59.300 --> 01:03:02.560
So you can imagine that we could just
put an Atom front end on top of that.

01:03:02.560 --> 01:03:05.330
And then you can put a calendar
on top of the server in addition

01:03:05.330 --> 01:03:08.290
to CalDAF so that you can use
those tools to talk to it as well.

01:03:08.340 --> 01:03:12.450
We've obviously been getting a lot
of questions about legacy systems

01:03:12.450 --> 01:03:16.460
and how you're going to tie into
those because it's open source.

01:03:16.460 --> 01:03:19.800
You can actually replace the file
classes that I was showing you there.

01:03:19.800 --> 01:03:23.720
Just swap those out with some data
store that instead stores to some

01:03:23.720 --> 01:03:27.430
database or an existing database
or speaks network protocol to

01:03:27.430 --> 01:03:29.500
some other calendaring system.

01:03:29.540 --> 01:03:32.540
You can imagine a map back end that,
for example, speaks to Exchange.

01:03:32.580 --> 01:03:34.120
change.

01:03:34.370 --> 01:03:39.540
And then you might have other directory
systems that are not in open directory.

01:03:39.540 --> 01:03:42.130
You're porting to Linux, for example,
and you don't have open

01:03:42.200 --> 01:03:43.390
directory deployed.

01:03:43.390 --> 01:03:47.540
So maybe you want to replace the
directory back end to use your

01:03:47.600 --> 01:03:50.490
particular single sign-on strategy.

01:03:51.140 --> 01:03:53.500
and the source code hopefully enables
you to do all of these things.

01:03:53.510 --> 01:03:56.110
So if you want to learn more about this,
the website is

01:03:56.180 --> 01:03:58.900
collaboration.macosforge.org.

01:03:58.900 --> 01:04:03.490
That's a track installation so you
can actually file bugs in there.

01:04:03.490 --> 01:04:05.830
You can kind of browse around
some documentation that we're

01:04:05.830 --> 01:04:06.980
starting to bring online.

01:04:06.980 --> 01:04:09.940
Hopefully the server is
a little happier now.

01:04:09.940 --> 01:04:13.350
We were on Slashdot a couple
days ago and had the associated

01:04:13.390 --> 01:04:15.650
downtime that comes along with that.

01:04:15.700 --> 01:04:18.530
But the server seems to be behaving
pretty well lately so you should

01:04:18.550 --> 01:04:22.190
be able to connect to this and
get some information out of there.

01:04:22.200 --> 01:04:25.410
If you register on the thing
you can actually file bugs.

01:04:25.410 --> 01:04:28.790
If you do not register you cannot
file bugs and that's because we want

01:04:28.790 --> 01:04:30.930
a little less spam in our mailboxes.

01:04:31.000 --> 01:04:34.280
And you can actually browse
the source code in there and

01:04:34.280 --> 01:04:36.170
see how we're progressing.

01:04:36.180 --> 01:04:40.420
There's a cool timeline feature
in track that lets you actually

01:04:40.420 --> 01:04:44.660
see what wiki pages got edited,
which source commits changed.

01:04:45.240 --> 01:04:47.190
And what tickets have been filed.

01:04:47.260 --> 01:04:51.480
So you can actually see our
progress in a very useful view.

01:04:51.480 --> 01:04:55.590
So if you want to learn more
about all of this information,

01:04:55.590 --> 01:04:58.150
again if you want to learn about
the calendar server in particular,

01:04:58.150 --> 01:05:01.000
you want to go to
collaboration.macosforge.org.

01:05:01.000 --> 01:05:03.830
If you want to learn about Chandler,
which is OSAF's client,

01:05:03.830 --> 01:05:06.140
you can go to chandler.osafoundation.org.

01:05:06.140 --> 01:05:11.100
There's another CalDAV implementation
which is open source called Cosmo,

01:05:11.130 --> 01:05:13.130
also from the OSA foundation.

01:05:14.780 --> 01:05:20.120
Learn more about Twisted
at twistedmatrix.com.

01:05:20.120 --> 01:05:23.480
And of course if you want
to learn about Python,

01:05:23.610 --> 01:05:25.750
go to docs.python.org.

01:05:26.600 --> 01:05:29.720
There's a lot of
specifications in play here.

01:05:29.930 --> 01:05:35.040
Again, iCalendar's got some RFCs up
in there right now and there's

01:05:35.040 --> 01:05:37.150
edits going on to updated drafts.

01:05:37.160 --> 01:05:38.960
If you want to learn
about HTTP and WebDAV,

01:05:38.960 --> 01:05:40.830
there are other RFCs to check out there.

01:05:40.840 --> 01:05:46.420
And CalDAV is, if you go to CalDAV.org,
that'll redirect you to the proper

01:05:46.420 --> 01:05:49.460
website for some CalDAV information.

01:05:49.460 --> 01:05:52.460
Also, if you go to WebDAV.org,
you can learn about WebDAV.

01:05:53.160 --> 01:05:55.310
And then, of course,
if you're at all interested in

01:05:55.310 --> 01:05:58.160
this space and you want to be able
to drive some of these standards,

01:05:58.160 --> 01:06:00.920
get involved with the calendaring
and scheduling consortium.

01:06:00.920 --> 01:06:03.890
Again,
Apple's hosting the next interoperability

01:06:03.890 --> 01:06:06.000
event in September on our campus.

01:06:06.000 --> 01:06:08.110
Hopefully,
that's a sign that we're pretty

01:06:08.460 --> 01:06:13.540
committed to the standards
process and take it from there.

01:06:13.540 --> 01:06:17.030
And all of these URLs are
on the Mac OS Forge site,

01:06:17.090 --> 01:06:20.080
so you don't have to keep scribbling.
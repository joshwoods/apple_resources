WEBVTT

00:00:17.620 --> 00:00:21.820
What is this Core Data thing?

00:00:21.820 --> 00:00:24.180
So we tried to come up with
a one-sentence description

00:00:24.180 --> 00:00:25.490
for what is Core Data.

00:00:25.490 --> 00:00:27.790
And it actually took my team a
little bit of time to come up

00:00:27.790 --> 00:00:30.540
with something that's succinct,
not really really long,

00:00:30.610 --> 00:00:34.410
end up with arguments about
is persistency really a word?

00:00:34.410 --> 00:00:38.700
But this is what we ended up with:
model-driven object graph management

00:00:38.700 --> 00:00:40.600
and persistency framework.

00:00:42.630 --> 00:00:44.780
Exactly.

00:00:44.810 --> 00:00:47.580
We actually ended up,
we asked a couple people this question,

00:00:47.580 --> 00:00:48.240
what is Core Data?

00:00:48.240 --> 00:00:51.000
And usually when we give a response,
we get one of two reactions.

00:00:51.010 --> 00:00:56.000
We either got the okay nod,
or we got the 90-minute whiteboard,

00:00:56.000 --> 00:00:59.280
scratch paper, textbook,
all kinds of big long

00:00:59.280 --> 00:01:01.180
conversations version.

00:01:01.180 --> 00:01:04.320
That's not actually because
Core Data is complicated.

00:01:04.320 --> 00:01:05.920
How many of you people
have read the docs?

00:01:05.920 --> 00:01:09.600
Come on, lie to me, raise your hands.

00:01:10.800 --> 00:01:13.190
Okay, if you've read the docs,
you'll see that our

00:01:13.200 --> 00:01:14.500
API is relatively small.

00:01:14.500 --> 00:01:17.420
It's somewhat minimal for
working with this problem set.

00:01:17.510 --> 00:01:20.640
So the conversations take a while,
not because Core Data is complicated,

00:01:20.640 --> 00:01:22.480
but the problem space is complicated.

00:01:22.480 --> 00:01:25.290
Dealing with all the different
issues of data management,

00:01:25.290 --> 00:01:27.690
persistency, undo, redo,
and all sorts of stuff

00:01:27.690 --> 00:01:29.070
is pretty complicated.

00:01:29.070 --> 00:01:31.740
And a lot of times you'll be working
on your application and realize,

00:01:31.740 --> 00:01:33.880
I didn't really know this
was going to be a problem.

00:01:33.880 --> 00:01:36.350
The fact is that Core Data provides
solutions for a lot of

00:01:36.350 --> 00:01:37.670
these different problems.

00:01:37.670 --> 00:01:39.770
So usually when you're
working with Core Data,

00:01:39.770 --> 00:01:40.780
it takes some time to
explore the problem.

00:01:40.780 --> 00:01:40.780
But if you're working with Core Data,
it's going to be a lot of fun.

00:01:40.800 --> 00:01:45.430
So let's take a look at some
applications that are in

00:01:45.480 --> 00:01:51.560
Mac OS X that use Core Data as kind
of a sample of what's possible.

00:01:51.560 --> 00:01:54.880
So if you were to log into
Mac OS X and start up an application,

00:01:54.940 --> 00:01:58.520
the first thing you might see
is something called Aperture.

00:01:58.520 --> 00:02:02.160
Aperture is Apple's leading
photographic management application.

00:02:02.160 --> 00:02:03.560
And this is a behemoth.

00:02:03.560 --> 00:02:04.620
This is a pro app.

00:02:04.620 --> 00:02:07.510
And much like a pro apps,
this is one that's adopted

00:02:07.510 --> 00:02:10.780
Core Data exclusively for all of
its data management applications.

00:02:10.800 --> 00:02:13.700
This is an application that
deals not just with hundreds

00:02:13.790 --> 00:02:17.090
of thousands of photos,
but with potentially hundreds of pieces

00:02:17.100 --> 00:02:20.480
of metadata for every single photo,
hundreds of pieces of keywords,

00:02:20.480 --> 00:02:23.320
all sorts of kind of different
data for this application.

00:02:23.320 --> 00:02:27.670
This application has high data,
but also has low latency requirements.

00:02:27.670 --> 00:02:30.500
And because it has lots of
data and lots of complex data,

00:02:30.500 --> 00:02:32.080
they want complex queries.

00:02:32.080 --> 00:02:34.480
They want to be able to funnel it
down to keep their working set very,

00:02:34.480 --> 00:02:34.980
very small.

00:02:34.990 --> 00:02:36.450
And they can do that with Core Data.

00:02:36.460 --> 00:02:40.660
They're actually able to use it as well
for something we call data replication.

00:02:40.800 --> 00:02:43.150
Which is actually saving off
pieces of their data so that

00:02:43.150 --> 00:02:45.910
any time something happens,
they can reconstruct their project.

00:02:45.940 --> 00:02:48.010
And Core Data makes that
really easy for them to do.

00:02:48.020 --> 00:02:50.400
But it's not just about the big apps.

00:02:50.400 --> 00:02:53.150
Let's take a look at a couple
of their small applications.

00:02:53.160 --> 00:02:55.020
AddressBook and iCal.

00:02:55.020 --> 00:02:57.800
And you might be thinking,
I've seen these applications before.

00:02:57.800 --> 00:02:59.220
I didn't know they were using Core Data.

00:02:59.220 --> 00:03:01.200
In Leopard, they are.

00:03:01.200 --> 00:03:04.140
And they're not actually interesting
for their application space,

00:03:04.140 --> 00:03:06.200
but because they're both frameworks.

00:03:06.200 --> 00:03:10.460
Both AddressBook and iCal have adopted
Core Data for their persistency.

00:03:10.850 --> 00:03:12.770
And they're able to use it in
Leopard for framework implementation.

00:03:12.800 --> 00:03:15.480
And this is actually interesting
for a number of reasons.

00:03:15.510 --> 00:03:18.180
The first is when you
think about AddressBook,

00:03:18.180 --> 00:03:19.680
you think about an API that's
been around for a while.

00:03:19.680 --> 00:03:23.450
So in order for them to adopt Core Data,
they needed to find a way to fit it

00:03:23.450 --> 00:03:25.920
into existing API to make sure that
customers didn't have to change.

00:03:25.920 --> 00:03:28.300
And they were able to
do that very easily.

00:03:28.300 --> 00:03:30.960
They also had a legacy schema that
they needed to pull over and to put

00:03:30.960 --> 00:03:32.480
into Core Data to make this work.

00:03:32.520 --> 00:03:34.920
And that's possible too.

00:03:34.920 --> 00:03:36.940
iCal is in a little different situation.

00:03:37.090 --> 00:03:40.400
They have their calendar store framework
now that they're publishing in Leopard.

00:03:40.800 --> 00:03:42.800
They don't actually have an
existing API to worry about,

00:03:42.800 --> 00:03:44.770
but they do have file formats.

00:03:44.850 --> 00:03:47.980
If you look in the ICS file,
there's the V-Cal standard in there that

00:03:47.980 --> 00:03:49.800
they need to maintain for compatibility.

00:03:49.800 --> 00:03:51.790
And Core Data makes that possible.

00:03:51.800 --> 00:03:54.930
But what's most interesting about these
two is not that they're frameworks,

00:03:54.930 --> 00:03:57.800
but also that they have
multi-process access.

00:03:57.800 --> 00:03:59.800
They have high concurrency needs.

00:03:59.800 --> 00:04:02.220
You think about applications,
just about every application uses one of

00:04:02.220 --> 00:04:03.800
these frameworks in one way or the other.

00:04:03.800 --> 00:04:07.800
Whether it's the new AddressBook or
the new iCal functionality.

00:04:07.800 --> 00:04:10.300
So these people have really
strong requirements for iCal.

00:04:10.300 --> 00:04:13.250
They have high requirements for lots
of people accessing the same framework

00:04:13.390 --> 00:04:15.300
and dealing with multiple access.

00:04:15.300 --> 00:04:17.300
And Core Data provides
a solution for them.

00:04:17.300 --> 00:04:21.480
Talking about other apps that
you might think that might

00:04:21.480 --> 00:04:23.300
not be able to use Core Data,
you think Mail.

00:04:23.490 --> 00:04:24.300
Well, okay.

00:04:24.300 --> 00:04:26.890
Mail has a very long
tradition of having a very,

00:04:26.890 --> 00:04:29.300
very good schema for
their data management.

00:04:29.370 --> 00:04:31.280
And frankly,
they don't really need Core Data.

00:04:31.380 --> 00:04:33.180
Core Data works,
or their existing schema works

00:04:33.180 --> 00:04:34.290
great for what they have.

00:04:34.300 --> 00:04:37.300
But they have some auxiliary data needs.

00:04:37.380 --> 00:04:39.800
Storing the pop message counts and
tracking what you've downloaded.

00:04:39.800 --> 00:04:42.000
That's something that they
had to do themselves and

00:04:42.000 --> 00:04:43.800
realized there's a solution.

00:04:43.800 --> 00:04:44.760
It's Core Data.

00:04:44.900 --> 00:04:47.800
So you don't need to use it for the
entire breadth of your application.

00:04:47.800 --> 00:04:49.800
You can use it just for a small piece.

00:04:49.800 --> 00:04:52.800
They're also something that
has just a moderate data set.

00:04:52.800 --> 00:04:53.790
You don't need something large.

00:04:53.800 --> 00:04:56.240
It's just a small amount of
data that you can still get a

00:04:56.240 --> 00:04:57.800
lot of benefit from Core Data.

00:04:57.800 --> 00:05:00.800
How many of you people in here
have actually done AppleScript?

00:05:00.980 --> 00:05:01.780
Currently do AppleScript?

00:05:01.810 --> 00:05:02.790
Ah, quite a few.

00:05:02.800 --> 00:05:05.800
How many of you have used System Events?

00:05:05.810 --> 00:05:06.800
Not many.

00:05:06.800 --> 00:05:09.300
There's actually a functionality that we
produced in Tiger called System Events.

00:05:09.300 --> 00:05:12.300
And in there is something
called Database Events.

00:05:12.300 --> 00:05:15.300
The AppleScript team put
together a background process,

00:05:15.300 --> 00:05:19.250
no UI at all, to allow people to use
databases in AppleScript.

00:05:19.300 --> 00:05:22.730
And they were able to use Core Data as
a way to develop a generic schema

00:05:22.790 --> 00:05:25.460
backend so that you could store
lots of different data types and

00:05:25.460 --> 00:05:27.250
use it seamlessly with AppleScript.

00:05:27.300 --> 00:05:29.240
So it's an example of something
that doesn't have a lot of

00:05:29.240 --> 00:05:30.160
application logic in it.

00:05:30.300 --> 00:05:32.300
It's just something that manages data.

00:05:32.400 --> 00:05:33.210
It has no UI for it.

00:05:33.320 --> 00:05:35.280
It's just something that's
done by AppleScript.

00:05:35.310 --> 00:05:38.530
But that gets a lot of benefit
from something like Core Data.

00:05:40.780 --> 00:05:43.160
Then we talk about something like Xcode.

00:05:43.320 --> 00:05:45.850
And I put Xcode in a category of its own,
and I'm going to call

00:05:45.850 --> 00:05:47.110
it the kitchen sink.

00:05:47.190 --> 00:05:51.380
And this is because they have a lot of
different needs for data management,

00:05:51.460 --> 00:05:52.810
and they're all very, very different.

00:05:52.950 --> 00:05:56.390
For example, the documentation window is
now using Core Data for its

00:05:56.390 --> 00:05:58.300
API and its full-text searches.

00:05:58.410 --> 00:06:03.160
We're also using Core Data-- we eat our
own dog food-- as our management for--

00:06:03.330 --> 00:06:06.680
our management for all
of our design models.

00:06:06.680 --> 00:06:10.700
So the migration model is done using
the persistent document implementation.

00:06:10.700 --> 00:06:14.720
And Xcode is also very unique in
that it's using Core Data underlying

00:06:14.720 --> 00:06:18.160
for managing how their modules are
related to one another and what

00:06:18.160 --> 00:06:19.500
kind of functionality they provide.

00:06:19.520 --> 00:06:22.200
It has really nothing to do with
the project file or the source

00:06:22.200 --> 00:06:24.180
code file or anything else,
but it's a really good way to

00:06:24.180 --> 00:06:26.880
structure how the modules are
related to one another and how

00:06:26.900 --> 00:06:28.000
they all fit in at runtime.

00:06:28.000 --> 00:06:31.270
So you don't necessarily need to
have large data needs or a specific

00:06:31.270 --> 00:06:32.900
data set in order to use Core Data.

00:06:33.260 --> 00:06:34.780
You can use it in some
very interesting ways.

00:06:34.780 --> 00:06:37.660
So after looking at all
these different examples,

00:06:37.660 --> 00:06:40.640
you still might be thinking, okay,
I'm still not sure.

00:06:40.640 --> 00:06:42.530
Is Core Data right for me or not?

00:06:42.540 --> 00:06:44.510
So let's take a look at that.

00:06:45.880 --> 00:06:49.790
Let's go back to our original definition,
this one that you all kind of laughed at,

00:06:49.800 --> 00:06:51.800
and let's break it down into
some more fundamental pieces.

00:06:51.800 --> 00:06:56.300
So let's break it down into four
or five different areas that we'll

00:06:56.300 --> 00:06:57.800
go into a little more detail.

00:06:57.800 --> 00:07:00.800
So the first one is modeling.

00:07:00.800 --> 00:07:02.800
It's defining a structure for your data.

00:07:02.800 --> 00:07:04.800
And this might be something
you're sitting there thinking,

00:07:04.800 --> 00:07:06.750
"You know,
I don't really need this right now.

00:07:06.800 --> 00:07:09.100
I've got all my classes,
I've got all my data management,

00:07:09.100 --> 00:07:11.720
this is not really important to
me." This is actually something

00:07:11.720 --> 00:07:13.930
that you probably don't need,
but it's probably something you want,

00:07:13.930 --> 00:07:15.800
whether you realize it or not.

00:07:15.880 --> 00:07:18.770
This is something where defining
the way your data is structured

00:07:18.810 --> 00:07:21.800
gives you the ability to do things
like provide default values,

00:07:21.920 --> 00:07:24.080
provide validation and
constraints to say,

00:07:24.080 --> 00:07:27.080
"My data has to exist this way."
It may not seem like a lot,

00:07:27.090 --> 00:07:29.180
but it becomes very,
very useful when dealing

00:07:29.180 --> 00:07:31.790
with user interface and user
workflow kind of things.

00:07:31.800 --> 00:07:35.750
But what's further important is by
defining a structure of your data,

00:07:35.800 --> 00:07:38.770
by modeling your data,
you get really large benefits from

00:07:38.770 --> 00:07:40.790
like versioning and migration.

00:07:40.800 --> 00:07:43.790
What does it mean to have this version
of my application and this version?

00:07:43.800 --> 00:07:44.800
What changed?

00:07:44.800 --> 00:07:45.800
By having a structure of your data,
you can model your data.

00:07:45.800 --> 00:07:48.110
By having a defined schema,
you can actually see and the

00:07:48.240 --> 00:07:51.800
framework might actually help you
deal with some of those things.

00:07:52.950 --> 00:07:54.840
Object Graph Management is
probably what you guys think of

00:07:54.840 --> 00:07:57.300
as the hallmark of a framework,
I guess.

00:07:57.300 --> 00:08:00.380
This is something where this is really
the nuts and bolts or the details

00:08:00.440 --> 00:08:02.800
of using a persistence framework.

00:08:02.800 --> 00:08:05.720
And there's a lot of things we do:
object manipulation, more validation,

00:08:05.760 --> 00:08:07.500
all those kinds of things.

00:08:07.500 --> 00:08:10.670
But I would actually be willing to bet
that for the second bullet up there,

00:08:10.670 --> 00:08:13.890
for undo and redo,
Core Data is absolutely worth it,

00:08:14.020 --> 00:08:15.620
if for no other reason.

00:08:15.620 --> 00:08:16.610
We've all been there.

00:08:16.680 --> 00:08:18.980
We've all had an application
where you've started up and

00:08:18.980 --> 00:08:20.830
you did something and you went,
"Ooh,

00:08:20.830 --> 00:08:22.260
that wasn't right." And we all do it.

00:08:22.260 --> 00:08:24.850
We all look down and see
Command-Z and you're like,

00:08:24.850 --> 00:08:28.440
"I'm not really sure if that's
going to work." But you tried

00:08:28.440 --> 00:08:32.380
anyway and you do and you're like,
"Ah, that didn't happen."

00:08:32.380 --> 00:08:33.580
That's just not right.

00:08:33.580 --> 00:08:35.440
Because undo should work.

00:08:35.440 --> 00:08:37.490
It's a fundamental thing,
but we all know it's very,

00:08:37.500 --> 00:08:39.760
very difficult to do and to get it right.

00:08:39.760 --> 00:08:40.880
What does it mean to roll back changes?

00:08:40.880 --> 00:08:41.860
What about after saves?

00:08:41.880 --> 00:08:43.160
And to do all those things.

00:08:43.160 --> 00:08:45.380
But if every application
had undo for free,

00:08:45.380 --> 00:08:48.140
I think we'd all be a little
more whimsical with things

00:08:48.140 --> 00:08:49.610
that we do inside our apps.

00:08:49.620 --> 00:08:52.400
But there's also things like
dealing with... There's things like

00:08:52.410 --> 00:08:55.330
dealing with references and inverse
relationships and delete rules.

00:08:55.340 --> 00:08:57.240
What happens if I delete
this other thing?

00:08:57.240 --> 00:08:58.230
Should that go away?

00:08:58.240 --> 00:09:00.580
These are all things that you
shouldn't have to worry about.

00:09:00.810 --> 00:09:03.650
You should really be thinking about
how your application is structured,

00:09:03.730 --> 00:09:06.870
how the data is related to one another,
and getting on with the

00:09:06.870 --> 00:09:08.480
core of your application.

00:09:10.100 --> 00:09:13.540
Structured access is something
that I think is very important.

00:09:13.540 --> 00:09:16.450
We all have probably had large data
files of some kind and realized,

00:09:16.500 --> 00:09:19.820
I need to find something,
I need to get into something.

00:09:19.820 --> 00:09:22.550
You go to your top shelf and you pull
off your dusty CS manual and you're

00:09:22.550 --> 00:09:25.390
flipping through to try to figure
out what's the best way to sort this?

00:09:25.390 --> 00:09:27.420
What's the best algorithm to find this?

00:09:27.420 --> 00:09:28.780
You shouldn't have to do that.

00:09:28.780 --> 00:09:31.990
There should be a really nice
structured way of defining your queries.

00:09:31.990 --> 00:09:33.850
In fact,
it would be even better if you could

00:09:33.850 --> 00:09:37.100
define queries in a templatized way that
you could come back to later and say,

00:09:37.100 --> 00:09:39.540
this is my query,
just apply it over and over again.

00:09:39.790 --> 00:09:41.500
Things like filtering and sorting.

00:09:41.500 --> 00:09:43.100
Again,
you shouldn't have to worry about this.

00:09:43.100 --> 00:09:44.920
There should be a
structured way to do this.

00:09:44.920 --> 00:09:47.990
And Core Data,
along with the Foundation Framework,

00:09:47.990 --> 00:09:49.450
provides that for you.

00:09:50.590 --> 00:09:52.210
Data persistency is probably
the thing that you think

00:09:52.210 --> 00:09:54.580
of as one of the hallmarks,
the foundations.

00:09:54.580 --> 00:09:57.200
I need to load my data,
I need to save my data,

00:09:57.370 --> 00:09:59.000
validate that it looks right.

00:09:59.000 --> 00:10:00.770
These are all things
that are very important.

00:10:00.790 --> 00:10:02.100
But what about formats?

00:10:02.100 --> 00:10:04.990
Do you have options to save your
files out in different formats?

00:10:05.070 --> 00:10:05.730
Could it be one?

00:10:05.730 --> 00:10:06.790
Could it move to another?

00:10:06.790 --> 00:10:08.640
Could it start from
one and become another?

00:10:08.640 --> 00:10:10.940
What about different options
like read-write capability?

00:10:11.010 --> 00:10:13.600
Can you mark things as read-only and
not have to worry about it through

00:10:13.600 --> 00:10:15.260
any other piece of your application?

00:10:15.260 --> 00:10:18.370
These are little nuanced details
that the framework also provides.

00:10:19.180 --> 00:10:23.380
But I also think that one of the really
important things are opt-in initiatives.

00:10:23.550 --> 00:10:25.780
You guys are here all week to
find out about the brand new

00:10:25.880 --> 00:10:28.350
things that are in Leopard and all
the other different frameworks.

00:10:28.350 --> 00:10:30.680
And these are things that are
really fundamental to the way

00:10:30.690 --> 00:10:33.110
you do things or opportunities
that you'll have later that,

00:10:33.110 --> 00:10:35.540
again, you guys really shouldn't
have to worry about.

00:10:35.540 --> 00:10:38.150
Things like key-value coding
and key-value observation,

00:10:38.150 --> 00:10:41.680
making sure that your objects play nicely
with Cocoa bindings and interfaces.

00:10:41.680 --> 00:10:44.160
But what about the new things
that we've heard about this week?

00:10:44.160 --> 00:10:47.140
The new 64-bit stuff,
the garbage collection, property support.

00:10:47.160 --> 00:10:47.860
These are all things that a framework
really should be able to do.

00:10:47.860 --> 00:10:47.860
And I think that's a
really important thing.

00:10:47.860 --> 00:10:49.950
These are all things that a framework
really should provide for you.

00:10:49.950 --> 00:10:52.150
So again, you don't have to worry
about these little details.

00:10:52.340 --> 00:10:54.860
You can just get on with the
core of your application.

00:10:54.870 --> 00:10:57.820
And these are things that
Core Data does for you as well.

00:10:57.990 --> 00:11:01.250
So we've heard a lot
about what Core Data is,

00:11:01.280 --> 00:11:03.070
and we have a moment of honesty here.

00:11:03.140 --> 00:11:04.690
Core Data is not for everyone.

00:11:04.820 --> 00:11:06.870
Sometimes, honestly,
Core Data is not an option.

00:11:06.880 --> 00:11:09.980
And there are three specific
instances that we should cover,

00:11:10.130 --> 00:11:12.040
just to be completely on the up and up.

00:11:12.060 --> 00:11:15.120
The first is if you can't
link the Foundation Framework.

00:11:15.120 --> 00:11:17.360
We do a lot with the
Foundation Framework,

00:11:17.360 --> 00:11:20.050
both with key value coding,
key value observing,

00:11:20.050 --> 00:11:22.920
all sorts of different
stuff with Objective-C.

00:11:22.920 --> 00:11:25.720
If you're not able to link Foundation,
unfortunately Core Data is

00:11:25.720 --> 00:11:27.050
not going to be right for you.

00:11:29.140 --> 00:11:34.230
The second is if you require what we
call an infinitely malleable schema.

00:11:34.320 --> 00:11:37.430
If you have an application where
users need to be able to provide

00:11:37.620 --> 00:11:43.310
the most flexible schema possible,
or they need to be able to make changes,

00:11:43.360 --> 00:11:46.120
add their own properties,
change relationships at runtime,

00:11:46.270 --> 00:11:48.040
do all sorts of different things.

00:11:48.140 --> 00:11:51.220
If you can't define that in a
way that's kind of abstracted,

00:11:51.240 --> 00:11:53.400
Core Data is unfortunately
not going to be right either.

00:11:53.570 --> 00:11:55.340
We like to have a very
well defined schema,

00:11:55.340 --> 00:11:58.750
because we make a lot of our
functionality based on the

00:11:58.830 --> 00:12:00.540
fact that that doesn't change.

00:12:00.540 --> 00:12:03.210
So if you need an malleable schema,
unfortunately Core Data is

00:12:03.210 --> 00:12:04.280
not going to be right for you

00:12:06.150 --> 00:12:07.780
And the last one,
and I know this might be

00:12:07.780 --> 00:12:10.650
near and dear to some of you,
but if you need true client-server

00:12:10.650 --> 00:12:12.860
access at this point in time,
Core Data is not going to

00:12:12.860 --> 00:12:13.840
be the solution for you.

00:12:14.000 --> 00:12:17.230
Now that's not to say that you can't
provide an application that does

00:12:17.260 --> 00:12:21.120
some kind of distributed notification
stuff and all access the same store,

00:12:21.120 --> 00:12:24.490
but if you need something that's
truly client-server oriented,

00:12:24.730 --> 00:12:27.430
Core Data is not going to
be the solution for you.

00:12:27.860 --> 00:12:31.370
So we covered what Core Data is
and some of the things it's not.

00:12:31.540 --> 00:12:33.920
For the rest of this presentation
we're going to go through two

00:12:33.920 --> 00:12:37.300
of the more fundamental pieces:
the modeling and persistence side,

00:12:37.300 --> 00:12:40.970
the object graph management side,
and then for all of you who

00:12:41.060 --> 00:12:46.120
are familiar with Core Data,
we're going to go through the

00:12:46.120 --> 00:12:49.680
new features that we have a
lot of other sessions this

00:12:49.680 --> 00:12:49.680
week to cover in more detail.

00:12:49.680 --> 00:12:49.680
So let's get on to
modeling and persistence.

00:12:53.180 --> 00:12:55.780
Modeling is, as we said before,
it's kind of the formalization

00:12:55.780 --> 00:12:57.500
of your application's data model.

00:12:57.660 --> 00:13:00.030
And it defines two
major functional things.

00:13:00.090 --> 00:13:03.430
It defines the type and
structure of your data,

00:13:03.490 --> 00:13:06.600
and it defines the interrelationships
between pieces of data.

00:13:06.600 --> 00:13:09.160
Now,
a model for us has a major component,

00:13:09.160 --> 00:13:10.490
which are entities.

00:13:10.560 --> 00:13:14.870
And entities, in turn, have properties,
and properties can be either

00:13:14.880 --> 00:13:17.120
attributes or relationships.

00:13:17.790 --> 00:13:20.320
So if you look at the diagram over here,
you'll see that we have

00:13:20.320 --> 00:13:21.470
recipe and we have chef.

00:13:21.470 --> 00:13:23.820
Recipe and chef are both entities.

00:13:23.820 --> 00:13:25.330
They both have properties.

00:13:25.380 --> 00:13:28.950
The recipe has attributes like name,
cuisine, and directions.

00:13:28.950 --> 00:13:30.140
So does the chef.

00:13:30.160 --> 00:13:31.220
Different kinds of attributes.

00:13:31.290 --> 00:13:32.590
And they also have relationships.

00:13:32.590 --> 00:13:35.040
So you can see that
recipe is related to chef.

00:13:35.040 --> 00:13:36.990
Recipe has a single chef, in this case.

00:13:36.990 --> 00:13:39.270
And a chef has many recipes.

00:13:39.270 --> 00:13:41.730
So we've created two entities,
some properties,

00:13:41.730 --> 00:13:43.750
and some relationships between them.

00:13:43.760 --> 00:13:46.210
This defines the structure of our data.

00:13:46.220 --> 00:13:47.600
This defines how our data is structured.

00:13:47.720 --> 00:13:49.930
is going to look at runtime.

00:13:50.300 --> 00:13:54.260
Now actually using that data at runtime,
we're going to have objects.

00:13:54.350 --> 00:13:56.940
So manage objects are the data workhorse.

00:13:57.000 --> 00:13:59.460
These are the things
that contain the values.

00:13:59.500 --> 00:14:01.990
They also contain the
relationships to other objects.

00:14:02.080 --> 00:14:05.080
These are the things on which we've
implemented key value coding and key

00:14:05.080 --> 00:14:08.870
value observing to do a lot of the things
that you need to get your work done.

00:14:08.990 --> 00:14:11.040
And this is going to be your
main element of subclassing.

00:14:11.040 --> 00:14:14.570
When you want to go and add custom
logic or add custom functionality,

00:14:14.610 --> 00:14:16.830
extend some attributes,
do some interesting things

00:14:16.830 --> 00:14:19.530
with the relationship,
this is going to be your unit of work.

00:14:19.630 --> 00:14:23.770
So this is kind of the noun for most
of Core Data is the managed object.

00:14:23.800 --> 00:14:27.690
Now it's really important to be clear,
though, what's the difference between

00:14:27.690 --> 00:14:29.060
an entity versus objects?

00:14:29.060 --> 00:14:31.060
Because a lot of people
use these interchangeably,

00:14:31.060 --> 00:14:33.030
and it can cause some confusion.

00:14:33.100 --> 00:14:35.790
So consider that entities
are the metadata.

00:14:35.820 --> 00:14:39.260
They're the structure behind
things and how things are laid out,

00:14:39.510 --> 00:14:43.790
while the managed objects are the actual
data implementation and representation.

00:14:43.940 --> 00:14:46.930
Managed objects refer to a single entity.

00:14:47.150 --> 00:14:51.100
So when you have a managed object,
it is only one kind of entity.

00:14:51.100 --> 00:14:54.880
But to be a little bit more clear,
I have a chart here that's very simple.

00:14:54.930 --> 00:15:02.000
An entity description is to a managed
object as a class is to an s object.

00:15:02.190 --> 00:15:04.120
Everybody read that carefully.

00:15:04.120 --> 00:15:06.510
So an entity description,
or actually an easier way to

00:15:06.510 --> 00:15:10.880
say it is a managed object is an
instance of an entity description.

00:15:11.070 --> 00:15:13.160
Is everyone clear on that?

00:15:13.350 --> 00:15:14.620
Come on.

00:15:14.700 --> 00:15:15.490
Thank you.

00:15:15.620 --> 00:15:17.040
All right.

00:15:17.720 --> 00:15:20.440
Once you have data,
we have stores to put them in,

00:15:20.440 --> 00:15:21.600
you want to put them somewhere.

00:15:21.600 --> 00:15:23.530
And we have different kinds
of stores that have different

00:15:23.530 --> 00:15:24.570
kind of characteristics.

00:15:24.600 --> 00:15:27.580
Different stores are better
for different things.

00:15:27.580 --> 00:15:29.700
So you see we have four
different store options.

00:15:29.800 --> 00:15:32.600
We have two atomic stores,
our XML and our binary store.

00:15:32.600 --> 00:15:35.410
By atomic store,
we mean they need to be read in all

00:15:35.410 --> 00:15:37.600
at once and written out all at once.

00:15:37.600 --> 00:15:39.800
We also have our SQL store,
which has different

00:15:39.800 --> 00:15:42.350
performance characteristics,
because we don't need

00:15:42.350 --> 00:15:43.440
to read in all the data.

00:15:43.610 --> 00:15:46.490
So you need to pick and choose
a store that's right for you,

00:15:46.660 --> 00:15:48.600
and we have lots of different options.

00:15:51.220 --> 00:15:54.140
That's kind of the basic of
the persistency of the models,

00:15:54.140 --> 00:15:55.820
stores, and stuff like that.

00:15:55.830 --> 00:15:58.330
For all of you who have
really read the documentation,

00:15:58.390 --> 00:16:00.900
there's actually some hidden
features in there that,

00:16:00.940 --> 00:16:03.660
well, they're not really hidden,
but they're sometimes overlooked

00:16:03.660 --> 00:16:06.660
features that we really wanted to cover
to get the most out of Core Data for

00:16:06.670 --> 00:16:09.250
all the times that you use it.

00:16:09.260 --> 00:16:12.300
The first feature we want to
cover is transient properties.

00:16:12.300 --> 00:16:14.960
How many of you have used
transient properties?

00:16:14.960 --> 00:16:15.470
Not many.

00:16:15.470 --> 00:16:18.100
So the idea of a transient
property is something that's

00:16:18.100 --> 00:16:22.400
managed just like everything else,
but it's not persisted.

00:16:22.400 --> 00:16:25.320
And you might be thinking, "Well,
why would I ever want to do

00:16:25.320 --> 00:16:28.390
that?" Consider something
like your own custom class,

00:16:28.390 --> 00:16:30.080
or something like an NSColor.

00:16:30.080 --> 00:16:31.930
We don't have a native
data type for that.

00:16:31.930 --> 00:16:35.730
I can't just go into my model and say,
"Oh, this is a color." Now,

00:16:35.730 --> 00:16:38.380
we do have a binary attribute
that would allow you to serialize

00:16:38.380 --> 00:16:41.630
it out as an archive or something
like that and read it back in.

00:16:41.710 --> 00:16:44.230
That's code that you have to write,
but it's kind of a pain to think of,

00:16:44.310 --> 00:16:47.350
"Every time I deal with a color,
it's not really a color.

00:16:47.390 --> 00:16:50.250
It's a data blob,
and I need to convert it back and forth."

00:16:50.300 --> 00:16:53.050
A transient property gives you the
ability to define something that says,

00:16:53.050 --> 00:16:54.520
"It is this type.

00:16:54.520 --> 00:16:56.700
Add a little code behind it
that does the transformation,

00:16:56.700 --> 00:16:58.560
and it looks just like
any other attribute.

00:16:58.660 --> 00:17:01.710
It feels like any other attribute,
but you don't have to worry about

00:17:01.710 --> 00:17:05.560
actually figuring out some way to save
a color natively as its actual format."

00:17:06.940 --> 00:17:09.480
But while most people think
of transients as properties,

00:17:09.480 --> 00:17:12.200
there's also the other side which
is a transient relationship,

00:17:12.200 --> 00:17:15.550
which is also a little bit heady,
but it's actually very, very interesting.

00:17:15.560 --> 00:17:18.490
A transient relationship is
one that exists at runtime,

00:17:18.610 --> 00:17:20.040
but that's not persisted.

00:17:20.040 --> 00:17:22.360
Now, why would you want to
do something like this?

00:17:22.480 --> 00:17:25.540
Consider if you have two
stores of data with two objects

00:17:25.540 --> 00:17:27.240
that are actually related.

00:17:27.450 --> 00:17:29.080
Well, they're in two separate stores.

00:17:29.080 --> 00:17:32.220
I can't actually bind them together
in a way that's going to be

00:17:32.220 --> 00:17:33.800
meaningful if I just open one store.

00:17:33.800 --> 00:17:35.760
I can't create a hard relationship.

00:17:35.920 --> 00:17:39.110
But if I could create a transient
relationship such that when both stores

00:17:39.110 --> 00:17:42.450
are opened and that relationship exists,
so I could ask one object

00:17:42.450 --> 00:17:45.300
for the other or vice versa,
and it works just like

00:17:45.300 --> 00:17:48.130
any other relationship,
it provides a really powerful way to do

00:17:48.190 --> 00:17:51.320
what we call cross-store relationships,
or bind two schemas,

00:17:51.350 --> 00:17:54.700
or take two graphs and connect
them in a way that really doesn't

00:17:54.700 --> 00:17:57.140
exist in a persisted world,
but really needs to

00:17:57.140 --> 00:17:58.320
exist in your runtime.

00:17:58.320 --> 00:18:01.830
So transient properties can be very,
very useful.

00:18:03.370 --> 00:18:06.110
But to be honest, you don't actually need
to model all of your data.

00:18:06.110 --> 00:18:08.320
A lot of people have said, "Well,
I've got all these instance

00:18:08.320 --> 00:18:09.180
variables and stuff like that.

00:18:09.180 --> 00:18:13.060
What do I do with them?" In some cases,
you do nothing with them.

00:18:13.090 --> 00:18:15.620
If your properties are not modeled,
if they don't exist in

00:18:15.620 --> 00:18:17.790
one of our data models,
Core Data ignores them.

00:18:18.030 --> 00:18:19.670
They're not managed at all.

00:18:19.790 --> 00:18:21.200
Now, of course,
you need to be careful when you do this,

00:18:21.270 --> 00:18:23.970
because when we say that they're ignored,
we really mean it.

00:18:24.100 --> 00:18:28.190
There's no undo, there's no redo,
there's no validation, there's nothing.

00:18:28.250 --> 00:18:31.770
But it provides a very easy way for you
to take a schema that already exists and

00:18:31.770 --> 00:18:35.410
start to move it to use managed objects,
start to use properties and use the

00:18:35.410 --> 00:18:39.350
attributes and relationships over time,
but not have to move it all at once.

00:18:39.430 --> 00:18:42.400
So you can actually have unmodeled data.

00:18:43.470 --> 00:18:47.560
Another thing about the modeling tools it
provides is the fetch request templates.

00:18:47.560 --> 00:18:50.330
This is kind of the templatized
queries that I was mentioning before.

00:18:50.400 --> 00:18:53.880
And it provides a way to create
pre-canned requests that you

00:18:54.000 --> 00:18:57.290
can refer to by name at runtime,
and provide your own

00:18:57.290 --> 00:18:58.400
variables for replacement.

00:18:58.400 --> 00:19:02.760
This may not seem to be very useful,
except that it includes a really easy to

00:19:02.760 --> 00:19:05.400
use visual development for your queries.

00:19:05.400 --> 00:19:07.200
It's all sorts of nesting,
ands and ors and

00:19:07.200 --> 00:19:08.400
everything else like that.

00:19:08.400 --> 00:19:10.480
And when you have a
really complicated query,

00:19:10.530 --> 00:19:13.120
something that takes a lot of
details to look at and figure

00:19:13.120 --> 00:19:15.380
out how to get it just right,
this becomes a really useful

00:19:15.390 --> 00:19:16.400
tool for creating those.

00:19:16.400 --> 00:19:18.670
And again,
you can just go ahead and use the dollar

00:19:18.670 --> 00:19:21.400
sign notation to provide variables,
and then at runtime you say,

00:19:21.400 --> 00:19:23.710
"This is my query,
these are my variables,

00:19:23.780 --> 00:19:26.390
go and perform this query."
So it makes it really,

00:19:26.390 --> 00:19:29.400
really easy to create complex
queries and refer to them later.

00:19:33.950 --> 00:19:36.050
When creating models,
there's the whole concept of

00:19:36.100 --> 00:19:38.460
combining and targeting models.

00:19:38.460 --> 00:19:41.890
The Core Data runtime likes to
have one model to work from.

00:19:41.900 --> 00:19:44.890
Now for us,
models are just collections of entities.

00:19:44.900 --> 00:19:46.890
They're really no more
sophisticated than that.

00:19:46.900 --> 00:19:49.610
So you can take two models,
and with different pieces of API,

00:19:49.610 --> 00:19:50.900
you can merge them together.

00:19:50.900 --> 00:19:54.000
It effectively just puts all
the entities into one model,

00:19:54.010 --> 00:19:56.900
and the result looks just like any other,
as if you had created it yourself.

00:19:56.900 --> 00:20:00.900
So this becomes a really easy way to
take two separate and distinct things,

00:20:00.900 --> 00:20:02.900
and to put them all into one.

00:20:03.080 --> 00:20:07.000
But what's probably a hidden feature
is something we call configurations,

00:20:07.150 --> 00:20:11.900
which is the ability to take a model and
define collections of entities by name,

00:20:11.900 --> 00:20:15.130
and say, "This is a collection,
and this is a collection," and

00:20:15.340 --> 00:20:19.740
then to use those collections
to target specific stores.

00:20:19.950 --> 00:20:23.890
Now, why you might want to do that is,
consider you may have a store that says,

00:20:23.890 --> 00:20:27.890
"Well, my application data is over here,
and my user data is over here,

00:20:27.900 --> 00:20:31.900
and I want to make sure that
it's actually split up that way.

00:20:31.900 --> 00:20:31.900
I want to make sure that the data
doesn't actually get mixed up,

00:20:31.900 --> 00:20:35.900
or go to the wrong place." Or you
may have an application that says,

00:20:35.900 --> 00:20:38.660
"Well, I have all sorts of data,
but depending on the type

00:20:38.660 --> 00:20:41.630
of user that logs in,
I really don't want to give them

00:20:41.630 --> 00:20:45.390
access to a certain set of entities."
So by using configurations,

00:20:45.450 --> 00:20:47.960
you can define specific
collections of entities,

00:20:47.960 --> 00:20:50.490
either targeted to a specific store,
or they're only accessible

00:20:50.580 --> 00:20:51.900
to the application.

00:20:51.900 --> 00:20:53.900
So it's a very handy feature.

00:20:54.010 --> 00:20:56.310
You can do this with the API,
and you can also define

00:20:56.590 --> 00:20:58.690
them in the modeling tools.

00:21:00.710 --> 00:21:04.860
Talking about picking specific tours and
stores and targeting specific stores,

00:21:05.000 --> 00:21:06.940
we listed the in-memory
store as one of our options,

00:21:06.940 --> 00:21:08.600
and it's kind of the unsung hero.

00:21:08.600 --> 00:21:12.020
Having an in-memory store is an
exceptionally useful thing to do when,

00:21:12.020 --> 00:21:15.050
well, you want to use managed objects,
but you don't want to save them.

00:21:15.060 --> 00:21:18.020
So reasons you might want to do this are,
for example,

00:21:18.080 --> 00:21:20.820
you have your own file format,
and you just want to read in,

00:21:20.820 --> 00:21:22.720
do some managed object stuff,
but you don't want to

00:21:22.720 --> 00:21:23.650
actually save it out.

00:21:23.670 --> 00:21:26.080
But you still want to use managed
objects to work with them.

00:21:26.820 --> 00:21:29.220
As we talked about before,
if you have multiple stores,

00:21:29.220 --> 00:21:31.830
you may actually want to use
an in-memory store to represent

00:21:31.830 --> 00:21:34.700
things that go across them,
or relationships that go across them,

00:21:34.710 --> 00:21:37.540
that again don't exist at runtime,
or things that are calculated.

00:21:37.540 --> 00:21:40.850
It's a really easy way to get all
the same benefits of Core Data,

00:21:40.850 --> 00:21:44.980
but not have to worry about persistence
or where the information goes to.

00:21:46.980 --> 00:21:49.960
But we've talked a lot
about having lots of stores,

00:21:49.960 --> 00:21:51.480
and this is an important
point to point out,

00:21:51.590 --> 00:21:54.000
that you can use as many as you want.

00:21:54.260 --> 00:21:56.600
By default,
Core Data's API works across all the

00:21:56.660 --> 00:21:59.510
stores that are added to our coordinator.

00:21:59.590 --> 00:22:02.410
So all of your fetches work
across all of your stores.

00:22:02.570 --> 00:22:05.530
When you create new objects,
we find the right store for it,

00:22:05.650 --> 00:22:08.180
figuring out which stores
can support which entities,

00:22:08.180 --> 00:22:10.990
or where it's related to
and where it has to go.

00:22:11.170 --> 00:22:14.140
And it makes it really easy to have
lots of different pieces of data in your

00:22:14.140 --> 00:22:16.750
application with many different backings.

00:22:16.810 --> 00:22:19.130
Now it's kind of interesting to think
about the fact that there's two ways

00:22:19.140 --> 00:22:20.560
you could really structure this.

00:22:20.680 --> 00:22:25.840
You could do something like iTunes,
where every iTunes library has

00:22:25.840 --> 00:22:27.120
the same kind of information.

00:22:27.200 --> 00:22:29.650
We all have songs and
playlists in the same manner.

00:22:29.830 --> 00:22:33.090
So every store has the same schema,
and we just add multiple

00:22:33.150 --> 00:22:34.610
stores so you can look at it.

00:22:34.770 --> 00:22:35.990
But again,
you may want to structure it so

00:22:35.990 --> 00:22:39.020
that some data lives in one store,
and some data lives in another.

00:22:39.210 --> 00:22:40.510
And it all just works with Core Data.

00:22:40.540 --> 00:22:43.320
You really don't have to think
about how many stores you have,

00:22:43.320 --> 00:22:46.620
or where it needs to go,
unless that's really important to you.

00:22:46.620 --> 00:22:49.270
So it provides a really good
flexible way to structure where

00:22:49.270 --> 00:22:51.090
your data comes and goes to.

00:22:52.150 --> 00:22:54.060
But of course you don't
always have to pick one.

00:22:54.100 --> 00:22:56.540
As we said before,
we have lots of different store options,

00:22:56.540 --> 00:22:58.950
and the framework is
mostly store agnostic.

00:22:59.040 --> 00:23:01.110
When you start with one
store and end with another,

00:23:01.220 --> 00:23:02.440
the framework just works.

00:23:02.510 --> 00:23:05.440
Your application logic just works,
regardless of what kind

00:23:05.440 --> 00:23:06.660
of store you're saving to.

00:23:06.720 --> 00:23:09.890
And it makes it really easy to,
for example, start with the XML store

00:23:09.940 --> 00:23:12.060
at development time,
so that you can open up your

00:23:12.120 --> 00:23:14.180
store and look at the content,
figure out,

00:23:14.180 --> 00:23:15.660
did I really save that correctly?

00:23:15.660 --> 00:23:17.470
Is it the value I was really expecting?

00:23:17.610 --> 00:23:20.540
And then later convert it to the
SQL store to get all the benefits

00:23:20.540 --> 00:23:23.660
of performance and only pulling
in the data set that you need.

00:23:23.680 --> 00:23:26.590
And I'm not joking,
it is really one piece of code,

00:23:26.600 --> 00:23:30.150
one line of code to migrate a
store from one version to another.

00:23:30.390 --> 00:23:32.680
So just because you start
with one doesn't mean you

00:23:32.710 --> 00:23:34.080
need to end with that one.

00:23:36.810 --> 00:23:39.360
And finally, NS Persistent Document.

00:23:39.400 --> 00:23:42.300
For all you people who've had to
write document-based applications,

00:23:42.300 --> 00:23:44.450
there's the read from URL,
write from URL.

00:23:44.460 --> 00:23:47.890
There's all the different pieces
of API you need to implement

00:23:47.890 --> 00:23:50.600
in order to figure out where
your data comes and goes to.

00:23:50.700 --> 00:23:53.210
We've provided a subclass,
NS Persistent Document,

00:23:53.330 --> 00:23:55.040
that handles that for you.

00:23:55.150 --> 00:23:57.250
It provides all of the
basic core data stack,

00:23:57.250 --> 00:23:59.490
all the basic stuff that we
need to go ahead and pull in

00:23:59.490 --> 00:24:01.960
your data and persist your data,
and all you really need to

00:24:01.960 --> 00:24:03.600
do is provide a model file.

00:24:03.760 --> 00:24:06.080
Just need to tell us what the structure
of your data looks like and get on

00:24:06.120 --> 00:24:07.930
with developing your application.

00:24:08.050 --> 00:24:11.260
And it's a really, really easy way to get
started with core data.

00:24:11.330 --> 00:24:13.260
So actually,
let's go ahead and show you a

00:24:13.260 --> 00:24:17.140
demonstration of that and take
a look at what that looks like.

00:24:25.970 --> 00:24:28.780
I'm going to go into Xcode here,
and I'm just going to go ahead

00:24:28.800 --> 00:24:30.800
and create a brand new project.

00:24:30.800 --> 00:24:33.740
And I'm going to go ahead and
select the Core Data document-based

00:24:33.760 --> 00:24:38.820
application here,
and give it a name.

00:24:38.820 --> 00:24:38.820
We'll call this Xcode.

00:24:39.400 --> 00:24:42.600
Let's call it Photos 2006.

00:24:42.600 --> 00:24:46.370
And I'm just going to go ahead
and create my application.

00:24:46.450 --> 00:24:48.370
And there are a couple
pieces of interesting

00:24:49.300 --> 00:24:50.710
information in my project here.

00:24:50.800 --> 00:24:53.110
There's a model it
created for me by default.

00:24:53.140 --> 00:24:55.140
It added some classes for me.

00:24:55.140 --> 00:24:58.560
There's my document class,
and it added some resources for me.

00:24:58.560 --> 00:25:02.080
I can show you the code that it
put in for your document class,

00:25:02.080 --> 00:25:03.830
and as you can see, it's minimal.

00:25:03.860 --> 00:25:06.590
And that's mostly because
of the fact that this is a

00:25:06.640 --> 00:25:08.520
persistent document subclass.

00:25:08.580 --> 00:25:11.940
And all the nitty-gritty details about
being a persistent document and figuring

00:25:11.940 --> 00:25:16.610
out where the data comes from and goes
to is all in the persistent document.

00:25:16.870 --> 00:25:18.550
So it's not code you have to worry about.

00:25:20.170 --> 00:25:22.890
Let's go and take a
look at the data model.

00:25:23.050 --> 00:25:24.910
This is the data modeling tool,
where you're going to go ahead

00:25:24.920 --> 00:25:26.480
and create your data models.

00:25:26.620 --> 00:25:29.900
And I'll up the resolution here so
you guys in the back can see it.

00:25:29.960 --> 00:25:32.170
And we just want to go
ahead and create a model,

00:25:32.270 --> 00:25:34.650
create something to structure our data,
and allow us to create

00:25:34.650 --> 00:25:35.640
something on top of it.

00:25:35.740 --> 00:25:37.550
So I'm going to click the
little plus button here,

00:25:37.550 --> 00:25:39.520
and it's going to add an entity.

00:25:39.560 --> 00:25:41.820
And I'm going to call this photo.

00:25:42.130 --> 00:25:46.320
We're going to replicate the Photo class
that you probably saw yesterday in the

00:25:46.320 --> 00:25:50.000
keynote where we had the grid view and
saw different information about Photo.

00:25:50.000 --> 00:25:51.810
So here's my Photo entity.

00:25:52.060 --> 00:25:54.430
I'm going to use a little
keyboard shortcut here to

00:25:54.440 --> 00:25:56.000
quickly add three attributes.

00:25:56.000 --> 00:25:59.000
So you can see my attributes here,
and I can go ahead and rename them.

00:25:59.000 --> 00:26:01.800
We're going to want a
Data attribute to store the

00:26:01.900 --> 00:26:04.000
actual binary data for our Photo.

00:26:04.000 --> 00:26:07.650
We're going to go ahead and
add a rating so that we can

00:26:07.660 --> 00:26:10.000
rate how we like the Photos.

00:26:10.000 --> 00:26:11.990
And we'll give each Photo a name.

00:26:12.000 --> 00:26:15.000
So I've defined three
properties and I've named them.

00:26:15.000 --> 00:26:17.390
But I need to go ahead and
actually define the types behind

00:26:17.500 --> 00:26:18.960
these different attributes.

00:26:19.000 --> 00:26:22.000
So for the Data attribute,
I'm going to go up on the pop-up here

00:26:22.000 --> 00:26:25.830
and select Binary Data and set that.

00:26:26.000 --> 00:26:27.990
I'm going to go and select the name.

00:26:27.990 --> 00:26:28.930
I'm going to do the same thing.

00:26:29.190 --> 00:26:30.000
Select the string.

00:26:30.000 --> 00:26:33.000
And you'll note that the inspector on the
right gives me some different options.

00:26:33.000 --> 00:26:35.000
I can provide a min and
a max length for string.

00:26:35.000 --> 00:26:38.000
I can provide a regular
expression for validation.

00:26:38.000 --> 00:26:41.000
But I can also define a default value.

00:26:41.000 --> 00:26:44.570
In this case, we'll define Untitled as
the default value for all

00:26:44.570 --> 00:26:47.000
of our names for our Photos.

00:26:47.000 --> 00:26:48.980
And I can also define a rating.

00:26:48.980 --> 00:26:51.000
And we'll make this an integer.

00:26:51.000 --> 00:26:52.950
And much in the same way,
I can define some constraints.

00:26:53.000 --> 00:26:59.000
We'll say our ratings are from 0 to 5,
and every Photo has a default value of 2.

00:26:59.000 --> 00:27:03.000
So I've just defined an entity
with a couple attributes.

00:27:03.150 --> 00:27:06.000
Now, let's do something a
little more interesting.

00:27:06.000 --> 00:27:11.000
We can add another entity here,
and we'll call this Person.

00:27:11.000 --> 00:27:14.000
And we could go ahead and
again add a couple attributes.

00:27:14.070 --> 00:27:18.890
Maybe this is First Name and Last Name.

00:27:19.060 --> 00:27:20.890
The modeling tool is really
good about providing you

00:27:20.900 --> 00:27:24.170
things like multiple selection,
so I can select both of those

00:27:24.310 --> 00:27:26.540
and say they're both strings.

00:27:26.540 --> 00:27:30.930
So now I have person and photos,
and I want to relate them in some way.

00:27:31.020 --> 00:27:32.630
I can actually pull
down here at the bottom,

00:27:32.630 --> 00:27:34.840
and there's a little tool
for creating relationships,

00:27:34.840 --> 00:27:38.930
and really all it's going to take is
for me to drag from one to the other.

00:27:38.940 --> 00:27:40.900
It's going to create a line,
and when I let go,

00:27:40.900 --> 00:27:44.440
you'll see it added the
relationship to the person entity.

00:27:44.440 --> 00:27:48.080
And I can come over here and
call this relationship photos,

00:27:48.080 --> 00:27:51.710
so that I can ask every person
object for its list of photos

00:27:51.730 --> 00:27:53.460
and get the actual photo.

00:27:53.540 --> 00:27:55.630
Of course,
we note that here that this little

00:27:55.630 --> 00:27:57.500
arrow has only got one little end to it.

00:27:57.580 --> 00:28:00.320
I really want to click
the too many relationship,

00:28:00.320 --> 00:28:03.280
because a person should
really have many photos.

00:28:03.620 --> 00:28:06.010
Well, let's actually create
the inverse relationship.

00:28:06.240 --> 00:28:08.630
What about going from
a photo to a person?

00:28:08.720 --> 00:28:10.980
I can just drag backwards,
and you'll see that, again,

00:28:10.980 --> 00:28:12.900
it creates the relationship for me.

00:28:12.980 --> 00:28:16.970
And I could name this
maybe "Photographer."

00:28:17.410 --> 00:28:21.530
and you'll see that now a photo has
a 2-1 relationship to a photographer,

00:28:21.570 --> 00:28:25.070
but there's also this nice little
pop-up here called an inverse,

00:28:25.070 --> 00:28:27.190
and that functionally these
relationships are an inverse.

00:28:27.350 --> 00:28:30.620
If I go from a person to a photo,
going backwards from the photo to the

00:28:30.620 --> 00:28:32.290
person is really kind of the inverse.

00:28:32.310 --> 00:28:35.090
So by defining those as an inverse,
you'll see that my

00:28:35.090 --> 00:28:38.390
model is now structured,
that person and photo are related,

00:28:38.390 --> 00:28:41.280
but it collapses those relationships
into one to help you think about

00:28:41.390 --> 00:28:43.300
how your data is structured.

00:28:43.580 --> 00:28:45.230
So there we go.

00:28:45.310 --> 00:28:46.300
Not too difficult to define a model.

00:28:46.460 --> 00:28:48.300
Let's do something interesting with it.

00:28:48.300 --> 00:28:50.620
So in as much as we want to
talk about how you can use

00:28:50.620 --> 00:28:53.820
Core Data in your applications,
I think it's also interesting

00:28:53.820 --> 00:28:57.300
to talk about how Core Data is
integrated into the development tools.

00:28:57.300 --> 00:28:59.880
We take this very seriously and
provide the fact that because

00:29:00.020 --> 00:29:02.300
Core Data is so easy to use,
by making it more integrated,

00:29:02.300 --> 00:29:05.300
by making it a better part of
the development experience,

00:29:05.330 --> 00:29:07.300
you guys can get a lot more work done.

00:29:07.300 --> 00:29:10.300
So I'm going to go into
my document class here,

00:29:10.300 --> 00:29:13.300
and you'll see it was brought
up in Interface Builder.

00:29:13.400 --> 00:29:15.260
And I want to add
something interesting here.

00:29:15.300 --> 00:29:18.220
So let's go ahead and just
delete this item here.

00:29:18.380 --> 00:29:21.090
And how many of you have seen the
Interface Builder demo so far,

00:29:21.090 --> 00:29:22.300
seen the new library?

00:29:22.780 --> 00:29:24.490
You like it?

00:29:25.100 --> 00:29:26.960
Come on, do you like it?

00:29:26.960 --> 00:29:28.460
Thank you.

00:29:28.460 --> 00:29:33.170
All right, so in the library now you'll
find a new Core Data item.

00:29:33.410 --> 00:29:35.650
So you see this little item here,
I'm going to drag it into

00:29:35.650 --> 00:29:36.820
my window and drop it.

00:29:36.950 --> 00:29:39.520
And what this is going to do is
it's going to go and ask Xcode,

00:29:39.520 --> 00:29:43.970
"Okay, what's the project for this nib?"
and show me all its data models.

00:29:44.200 --> 00:29:46.200
So there are the two
entities I just created,

00:29:46.230 --> 00:29:47.320
photo and person.

00:29:47.320 --> 00:29:49.760
So I'm going to go
ahead and select photo,

00:29:49.820 --> 00:29:53.310
and it's going to bring up this nice
little window just to show me the kinds

00:29:53.310 --> 00:29:55.400
of interfaces it can help me create.

00:29:55.570 --> 00:29:57.380
Now this is just going to go
ahead and lay some widgets out

00:29:57.530 --> 00:29:58.800
for me and set up some bindings.

00:29:58.800 --> 00:30:01.670
It's not going to do anything magical,
it's just going to take care of a little

00:30:01.670 --> 00:30:05.470
bit of minutiae details that it would
have taken me a while to do on my own.

00:30:05.520 --> 00:30:08.810
So I can go ahead and pick different
checkboxes here to see a live

00:30:08.980 --> 00:30:12.400
preview of what it's going to create,
and I want it to create the search fields

00:30:12.400 --> 00:30:14.620
and the table views and everything else.

00:30:14.790 --> 00:30:17.850
And I can actually pick and
choose which pieces of information

00:30:17.850 --> 00:30:19.330
I can put into my interface.

00:30:19.430 --> 00:30:21.180
And at this point in time
I really don't want to deal with

00:30:21.180 --> 00:30:23.130
the photographer information,
I just want to deal with the photos.

00:30:23.140 --> 00:30:27.420
So we'll click finish,
and there's my interface.

00:30:27.570 --> 00:30:30.080
And you'll note that if I look
over here in my document window,

00:30:30.090 --> 00:30:33.520
you'll see that it added
an array controller for me.

00:30:33.540 --> 00:30:37.360
And you'll note that it set up the
binding to the manage object context.

00:30:37.360 --> 00:30:41.020
And the context is on the files owner,
which is the persistent document.

00:30:41.040 --> 00:30:44.020
So you see it's just binding up
things that have existed for me,

00:30:44.050 --> 00:30:46.760
things that it's taken advantage
of that exist in the classes

00:30:46.760 --> 00:30:48.760
like the persistent document.

00:30:48.890 --> 00:30:51.760
So really at this point
there's nothing I need to do.

00:30:51.820 --> 00:30:53.140
I'm just going to go
ahead and save my nib,

00:30:53.140 --> 00:30:55.480
and I'm going to go ahead and
create a new interface builder.

00:30:55.480 --> 00:30:57.440
And I'm going to go ahead and
create a new interface builder.

00:30:57.470 --> 00:30:59.080
There's a great new feature
of Interface Builder,

00:30:59.080 --> 00:31:00.500
build and go in Xcode.

00:31:00.580 --> 00:31:02.220
So I'm not going to
leave Interface Builder,

00:31:02.220 --> 00:31:03.580
I'm just going to click the button.

00:31:03.580 --> 00:31:05.660
You'll see that the little,
you can see it over there,

00:31:05.660 --> 00:31:07.480
it's going to precompile and go ahead,
build it,

00:31:08.890 --> 00:31:10.690
So here's my application.

00:31:10.790 --> 00:31:12.650
Let's go ahead and do
something with this.

00:31:12.800 --> 00:31:15.850
I have a nice little folder of photos
here that I just want to go ahead

00:31:15.850 --> 00:31:19.180
and now that I've defined a model,
let's put stuff into the store for this.

00:31:19.180 --> 00:31:21.690
So we can go ahead and
just add a new record,

00:31:21.720 --> 00:31:24.480
and you see that there
are my default values,

00:31:24.480 --> 00:31:26.380
the rating of 2 and the untitled.

00:31:26.380 --> 00:31:30.200
So I can drag in the beach,
and we'll put that in.

00:31:30.200 --> 00:31:31.740
We'll call it beach.

00:31:31.740 --> 00:31:35.760
And I'm a city guy,
so we'll make that a 4 out of 5.

00:31:36.540 --> 00:31:38.870
I'm more of a...
Anyone from Chicago here?

00:31:40.240 --> 00:31:40.640
Excellent.

00:31:40.710 --> 00:31:43.870
So I'm more of a city guy,
so we'll put in city here.

00:31:43.890 --> 00:31:48.000
I know it's not a picture of Chicago,
but we'll give that a five.

00:31:48.000 --> 00:31:49.710
And I could just go ahead
and add more pictures.

00:31:49.720 --> 00:31:52.220
I'm just dragging the image
into the views that Interface

00:31:52.240 --> 00:31:53.260
Builder created for me.

00:31:53.400 --> 00:31:54.440
We'll call this fall.

00:31:54.440 --> 00:31:57.280
We'll give it a rating of four,
because I like the colors.

00:31:57.280 --> 00:31:58.920
And we'll drag in the tower.

00:31:58.960 --> 00:32:02.610
And I'm scared of heights,
so we're going to leave that as two.

00:32:02.640 --> 00:32:05.850
So all I've done is used all the
bindings that were set up for

00:32:05.850 --> 00:32:09.840
me in the persistent document,
and it's now put this into my graph.

00:32:10.290 --> 00:32:12.890
And all I'm going to do is hit Save,
and it's going to give me a

00:32:12.890 --> 00:32:14.820
list of places I can save that.

00:32:14.820 --> 00:32:16.160
I'll pick my desktop.

00:32:16.160 --> 00:32:17.960
And they're my format options.

00:32:18.210 --> 00:32:20.850
These are the store options that were
provided for you by the persistent

00:32:20.850 --> 00:32:22.850
document set up in the project template.

00:32:22.950 --> 00:32:25.490
And so I'm just going to
pick the binary store,

00:32:25.490 --> 00:32:27.610
and we'll just call this demo.

00:32:27.670 --> 00:32:31.030
And if we look at the desktop,
there's the store file.

00:32:31.170 --> 00:32:33.730
Just to prove to you that it's real,
I'm going to close that.

00:32:33.800 --> 00:32:35.590
We'll go and reopen it.

00:32:35.880 --> 00:32:37.350
And there it is.

00:32:37.360 --> 00:32:38.940
There's my store file.

00:32:39.010 --> 00:32:41.560
Again, I can go through and things
like multiple selection,

00:32:41.560 --> 00:32:44.660
I can go ahead and change the
ratings on things like that.

00:32:44.660 --> 00:32:48.100
I could go ahead and change
them to something different.

00:32:48.250 --> 00:32:49.910
Actually, I can go ahead and save it.

00:32:50.060 --> 00:32:53.220
Now watch, I'll go ahead and change
all the way back to two,

00:32:53.360 --> 00:32:55.740
maybe change this one back to one,
and realize, you know,

00:32:55.740 --> 00:32:57.600
this is not really what I want.

00:32:57.680 --> 00:33:02.460
Let's just hit Command-Z and
undo all the way past the save.

00:33:02.520 --> 00:33:04.320
And it all just works.

00:33:04.390 --> 00:33:06.380
So oh, wait.

00:33:06.420 --> 00:33:07.700
Oh, oh.

00:33:07.740 --> 00:33:10.090
But wait, there's more.

00:33:10.160 --> 00:33:11.900
So that's interesting.

00:33:12.090 --> 00:33:13.890
That's getting data
into your application.

00:33:14.070 --> 00:33:17.000
Let's do something a little bit more,
well, Apple-like.

00:33:17.110 --> 00:33:18.810
So let's go back into the interface here.

00:33:19.020 --> 00:33:21.540
Actually, let's quit the app first.

00:33:21.620 --> 00:33:23.590
No, really, I said quit.

00:33:23.860 --> 00:33:26.620
And go back into the app here,
delete the interface,

00:33:26.640 --> 00:33:29.580
and let's actually just run
that little assistant again,

00:33:29.770 --> 00:33:32.080
and we're going to pick the photos.

00:33:32.080 --> 00:33:34.550
And this time I'm actually
going to do the grid view,

00:33:34.730 --> 00:33:36.720
that nice little thing you saw yesterday.

00:33:36.780 --> 00:33:38.390
There's a little preview
of the grid view,

00:33:38.390 --> 00:33:40.760
and we'll add a little
search field at the bottom.

00:33:40.920 --> 00:33:43.970
And in this case,
all I really want is the data

00:33:43.980 --> 00:33:45.770
and the rating for the photo.

00:33:45.870 --> 00:33:48.580
We won't worry about the
other details for right now.

00:33:48.650 --> 00:33:50.070
And we'll say Finish.

00:33:50.170 --> 00:33:52.360
And now here's the grid view interface.

00:33:52.430 --> 00:33:54.880
In this case, it doesn't have the black
background it had yesterday.

00:33:54.880 --> 00:33:56.740
It's just transparent.

00:33:56.740 --> 00:34:00.100
But you can see that it also
added this other little view here.

00:34:00.100 --> 00:34:02.190
And the view is the one that's
going to be replicated over

00:34:02.190 --> 00:34:04.280
and over again inside the grid.

00:34:04.280 --> 00:34:06.550
And just to show you that it's real,
I can click on this here,

00:34:06.550 --> 00:34:09.230
and we'll see that it was set
up the binding for me to the

00:34:09.240 --> 00:34:11.070
represented object dot data.

00:34:11.080 --> 00:34:13.480
So that's going to be the
managed object for the photo,

00:34:13.480 --> 00:34:16.130
and it's going to use the data attribute.

00:34:16.200 --> 00:34:19.260
I can actually go ahead and
come down here to the tool tip,

00:34:19.260 --> 00:34:22.340
and we'll make the tool
tip for this the name.

00:34:22.340 --> 00:34:24.830
And we'll say, OK,
this is the name of the photo.

00:34:24.840 --> 00:34:27.840
So as you go over, you can see the name.

00:34:27.840 --> 00:34:30.740
We can go ahead and change
different attributes of IB.

00:34:30.740 --> 00:34:32.580
This is all just real stuff.

00:34:32.580 --> 00:34:35.660
Now, rating-- text is boring.

00:34:35.660 --> 00:34:38.530
So we can go and see that
this is still bound to,

00:34:38.550 --> 00:34:41.220
again, represented object dot rating.

00:34:41.340 --> 00:34:46.570
So let's just go ahead and delete
this over here from the view.

00:34:46.620 --> 00:34:48.440
And let's go and do something
a little more interesting.

00:34:48.740 --> 00:34:52.300
Let's take a-- oh,
let's take a level indicator.

00:34:52.300 --> 00:34:54.060
Doesn't make any sense.

00:34:54.060 --> 00:34:57.920
But it actually does when you note
that it has a rating property.

00:34:57.920 --> 00:35:01.440
So I can go ahead and change the
max-- set the min and max value to the

00:35:01.440 --> 00:35:03.760
same thing that we had in our model.

00:35:03.760 --> 00:35:06.920
Set the default value right now
to 5 so that I can easily size

00:35:06.920 --> 00:35:09.470
it and get it fitting right here.

00:35:09.680 --> 00:35:12.150
We need to make sure that it's
structured correctly so that it

00:35:12.250 --> 00:35:13.940
fits at the bottom of my view.

00:35:13.940 --> 00:35:16.060
So we'll set our springs
and struts correctly.

00:35:16.060 --> 00:35:18.780
And we also need to make sure
that it's bound correctly.

00:35:18.780 --> 00:35:22.250
And I need to remember that it's bound
to the layout item and the rating.

00:35:22.260 --> 00:35:24.020
So there you go.

00:35:24.020 --> 00:35:25.020
Some simple changes.

00:35:25.020 --> 00:35:27.980
IB is going to make sure
that I wanted to save this.

00:35:27.980 --> 00:35:29.930
So we'll go ahead and save that.

00:35:29.940 --> 00:35:33.690
And now let's just go ahead
and run the application again.

00:35:33.730 --> 00:35:34.640
Don't panic.

00:35:34.730 --> 00:35:36.920
It's just the default
document that comes up.

00:35:36.920 --> 00:35:39.020
We'll go back and open the demo.

00:35:39.020 --> 00:35:42.260
And there are my images now with nice
little ratings and nice little pictures.

00:35:53.200 --> 00:35:54.800
Not a single line of code.

00:35:54.800 --> 00:35:57.750
Now, that's not to say that any of
you will write a completely

00:35:57.750 --> 00:36:00.230
codeless application and ship it.

00:36:00.410 --> 00:36:03.320
If you do, call me first.

00:36:03.340 --> 00:36:05.400
But it shows you that it's really,
really easy to go ahead

00:36:05.400 --> 00:36:07.680
and create a data model,
create an application,

00:36:07.680 --> 00:36:10.250
or create an interface to go ahead
and see what your data looks like,

00:36:10.250 --> 00:36:13.360
try out some different things,
and wait till later to figure out,

00:36:13.450 --> 00:36:15.820
all right, now I've got to figure out,
how do I sort this?

00:36:15.820 --> 00:36:17.820
How do I figure out how
to rearrange the objects?

00:36:17.820 --> 00:36:19.080
I want the different sizes.

00:36:19.080 --> 00:36:20.360
I want different widgets.

00:36:20.360 --> 00:36:23.770
It just provides you a really easy way
to not even think about the fact that

00:36:23.770 --> 00:36:27.980
you have data and data management needs
until it's really important to you.

00:36:28.020 --> 00:36:33.640
So a really, really easy example of using
Core Data to write applications.

00:36:33.720 --> 00:36:36.860
So now what I'd like to do is turn
the presentation over to Ben Trumbull,

00:36:36.980 --> 00:36:39.040
senior engineer and
architect on Core Data,

00:36:39.050 --> 00:36:41.840
to talk more about object
graph management and some of

00:36:41.910 --> 00:36:43.790
the new features in Core Data.

00:36:49.900 --> 00:36:53.630
Good evening everyone, I'm Ben Trumbull,
and thank you Matt.

00:36:53.780 --> 00:36:57.810
Alright, so I'm going to first talk
about object graph management,

00:36:57.810 --> 00:37:01.520
the next section that Matt outlined
for you at the beginning.

00:37:01.520 --> 00:37:03.690
And what exactly is an object graph?

00:37:03.760 --> 00:37:06.760
It's an excellent question,
I get it all the time,

00:37:06.760 --> 00:37:10.480
I really don't know other than
what someone before me told me.

00:37:10.480 --> 00:37:13.690
And a bunch of graph objects
all related to each other,

00:37:13.730 --> 00:37:16.500
separate clusters,
and they're basically all

00:37:16.500 --> 00:37:19.560
edited at the same time,
so it's a single scope.

00:37:19.900 --> 00:37:21.900
In which you're working with your data.

00:37:22.000 --> 00:37:25.990
So all of these graphs that
we manage are controlled by a

00:37:25.990 --> 00:37:27.480
single managed object context.

00:37:27.500 --> 00:37:30.620
So a separate graph would have
multiple different contexts,

00:37:30.620 --> 00:37:31.740
one for each graph.

00:37:31.740 --> 00:37:35.050
And the context performs
all the change tracking,

00:37:35.300 --> 00:37:38.210
the undo, the fetching,
a lot of the verbs.

00:37:38.970 --> 00:37:42.240
and as I mentioned the relationships
between your data are what's really

00:37:42.240 --> 00:37:44.300
important for creating this graph.

00:37:44.300 --> 00:37:46.140
So as Matt showed you
in the modeling tool,

00:37:46.140 --> 00:37:50.220
we have inverses between objects,
objects have delete rules that

00:37:50.220 --> 00:37:54.570
get applied when you delete them,
and changes cascade throughout the graph.

00:37:56.310 --> 00:37:58.840
So the context is providing
all this change tracking.

00:37:58.970 --> 00:38:02.580
And for you,
we're built on top of key value

00:38:02.580 --> 00:38:04.930
observing and NS Notification Center.

00:38:05.100 --> 00:38:09.300
So a lot of that is how we're all
providing these features to you.

00:38:09.310 --> 00:38:14.200
And the context provides a
list for you of inserted,

00:38:14.270 --> 00:38:19.850
updated, and deleted objects,
as well as when it saves.

00:38:19.850 --> 00:38:20.550
And we flush out those changes,
and we maintain those inverses.

00:38:22.360 --> 00:38:25.290
Matt might give you a little
demo of the undo/redo support.

00:38:25.290 --> 00:38:27.490
So we provide complete
support based on the model.

00:38:27.490 --> 00:38:30.060
Transient properties and all
the persistent properties

00:38:30.060 --> 00:38:32.300
get undo and redo for free.

00:38:32.300 --> 00:38:34.840
We're built on top of the
foundation NSUndoManager,

00:38:34.840 --> 00:38:37.300
so there isn't really
any super magic in there.

00:38:37.300 --> 00:38:40.560
If you want, you can go to a context and
you can get its undo manager,

00:38:40.560 --> 00:38:44.150
and you can call all of the
foundation methods on it,

00:38:44.150 --> 00:38:47.440
so you can set a limit to
the number of items to undo,

00:38:47.620 --> 00:38:52.120
or you can turn off grouping by events,
or you can set the undo manager to nil

00:38:52.120 --> 00:38:54.300
to turn off undo management entirely.

00:38:54.300 --> 00:38:58.300
Matt kind of stole my thunder
there with undo/redo cross saves.

00:38:58.300 --> 00:39:02.450
So, in addition,
at the same level here at

00:39:02.450 --> 00:39:05.290
the object graph management,
we provide validation.

00:39:05.300 --> 00:39:10.310
So how to validate is in the model,
and in the modeling tool you can

00:39:10.310 --> 00:39:12.890
specify rules like whether or
not a relationship is allowed to

00:39:12.890 --> 00:39:15.030
have a certain number of items,
if there's a mandatory

00:39:15.030 --> 00:39:18.300
minimum or a limit,
whether or not a property is optional.

00:39:18.300 --> 00:39:21.250
So if it's optional,
it might be set to nil.

00:39:21.300 --> 00:39:24.300
If it's not optional,
then you must give it a value.

00:39:24.300 --> 00:39:25.300
It could be a default value.

00:39:25.300 --> 00:39:27.600
But when to validate
is done by the context,

00:39:27.600 --> 00:39:29.240
and this is done at save time.

00:39:29.300 --> 00:39:32.550
So we'll basically validate all
the objects before we push the

00:39:32.590 --> 00:39:34.280
save to the database itself.

00:39:34.320 --> 00:39:39.300
And there are a bunch of hooks there for
custom validation that you can apply,

00:39:39.300 --> 00:39:40.300
validate for insert, validate for save.

00:39:40.300 --> 00:39:45.270
And key value coding has its own set
of callbacks that you can also provide,

00:39:45.320 --> 00:39:46.300
so validate name error,
validate person error.

00:39:46.300 --> 00:39:52.980
Validate person or photographer
error in the previous example.

00:39:54.700 --> 00:39:56.950
I keep coming back to this
Managed Object Context.

00:39:56.980 --> 00:39:59.580
It's your primary access
point in Core Data.

00:39:59.600 --> 00:40:02.670
It's the place where you're
going to find most of the verbs,

00:40:02.710 --> 00:40:06.000
most of the actions that you apply
to Managed Objects will be methods

00:40:06.000 --> 00:40:07.730
on the Managed Object Context.

00:40:07.740 --> 00:40:11.160
And it's the central observer,
the spider in the web,

00:40:11.160 --> 00:40:15.130
that is basically reacting to all the
changes that you make to your objects.

00:40:15.140 --> 00:40:19.220
And each one is its own context,
its own isolated scope,

00:40:19.260 --> 00:40:20.660
so it's a scratch pad.

00:40:20.660 --> 00:40:22.740
So you can have multiple of them,
you can have different changes.

00:40:22.740 --> 00:40:25.150
So you might have one context for, say,
an inspector,

00:40:25.150 --> 00:40:28.740
and another context for the main view,
and they can track changes separately.

00:40:28.740 --> 00:40:32.050
And that lets you save some,
maybe you undo others,

00:40:32.150 --> 00:40:35.590
but you don't have to
commingle all those edits.

00:40:36.790 --> 00:40:41.680
The notifications are a great way for
you to add custom code in reaction

00:40:41.680 --> 00:40:44.380
to what Core Data is doing if you
don't find that there's a delegate

00:40:44.420 --> 00:40:45.700
method that does what you want.

00:40:45.700 --> 00:40:48.810
A lot of people have done some
really interesting things,

00:40:48.850 --> 00:40:51.700
building on top of the
NS notifications that we post.

00:40:51.700 --> 00:40:55.520
The contexts of posting these
notifications about all the things that

00:40:55.520 --> 00:40:59.700
happen at the end of every user event,
as well as after a save.

00:40:59.800 --> 00:41:04.090
Some cool things you can do is
use the Distributor Notification

00:41:04.090 --> 00:41:06.700
Center to repost those to other apps.

00:41:06.700 --> 00:41:11.270
The managed objects themselves provide
KVO notifications at a fine-grained

00:41:11.270 --> 00:41:13.700
level for every single property change.

00:41:13.700 --> 00:41:17.840
Another thing to note
is that Cocoa Bindings,

00:41:17.840 --> 00:41:22.810
the integration with Core Data,
a lot of what Matt demoed to you,

00:41:22.810 --> 00:41:24.700
is all built on top of
this same mechanism.

00:41:24.700 --> 00:41:28.180
The communication between Core Data and
Cocoa Bindings is really the same

00:41:28.180 --> 00:41:29.700
set of mechanisms available to you.

00:41:29.700 --> 00:41:30.700
for you.

00:41:30.700 --> 00:41:33.080
So it's built on top of the notification
center and key value observing.

00:41:35.550 --> 00:41:39.330
So sort of a reprise of the
overlooked features here,

00:41:39.350 --> 00:41:40.450
now at the object graph layer.

00:41:42.450 --> 00:41:44.550
The first is batch faulting.

00:41:44.900 --> 00:41:48.690
Basically, one thing that comes up a lot
on some of the mailing lists,

00:41:48.690 --> 00:41:51.350
a lot of questions people have,
is we tell them that the SQLite

00:41:51.350 --> 00:41:52.980
store is the most scalable store.

00:41:52.980 --> 00:41:55.970
And so they decide that
their app has a lot of data,

00:41:55.970 --> 00:41:58.900
for whatever that means,
and they switch over,

00:41:58.910 --> 00:42:02.850
and then it runs slower than it did with,
say, the XML store.

00:42:02.860 --> 00:42:06.030
Never mind that when you write
out XML it's huge compared

00:42:06.030 --> 00:42:07.780
to a nice little database.

00:42:08.160 --> 00:42:10.790
And part of what's going on is
Core Data is trying to be lazy

00:42:10.790 --> 00:42:13.830
to keep memory pressure down,
and we have this faulting mechanism

00:42:13.840 --> 00:42:16.240
that only pulls in the objects
that you're actually using.

00:42:16.240 --> 00:42:18.600
So if you ask for an
object one at a time,

00:42:18.660 --> 00:42:22.950
we're going to have to go and fulfill
all those values one at a time.

00:42:22.960 --> 00:42:26.800
And performing a fetch from the
database is a lot like unbuffered I.O.

00:42:26.800 --> 00:42:30.870
You want to have a nice big chunk,
not so big that you waste memory,

00:42:30.870 --> 00:42:34.660
but not so small that you keep
getting hit by the overhead.

00:42:34.660 --> 00:42:36.200
So it's really easy to do this.

00:42:36.280 --> 00:42:37.520
You can set up a predicate.

00:42:37.700 --> 00:42:40.150
That's self in,
and you give it a var arg,

00:42:40.150 --> 00:42:44.150
and you bind that up to an NSArray of
object IDs or managed objects,

00:42:44.150 --> 00:42:46.200
and we'll grab all of those objects.

00:42:46.200 --> 00:42:49.280
They don't have to have any
particular relationship to each other.

00:42:49.280 --> 00:42:50.390
You just identify them that way.

00:42:50.400 --> 00:42:53.710
And that's a good way to
get much better performance.

00:42:55.530 --> 00:42:58.710
Something else is all the
object IDs we provide are sort

00:42:58.780 --> 00:43:03.240
of opaque identifiers for every
object in the persistent stores,

00:43:03.250 --> 00:43:04.910
and these objects
provide a URI reference.

00:43:05.000 --> 00:43:07.420
So you can ask them for
a textual representation,

00:43:07.420 --> 00:43:10.540
which is an NSURL,
and you can pass that out

00:43:10.540 --> 00:43:12.360
to another application.

00:43:12.360 --> 00:43:14.100
You can put it on the pasteboard.

00:43:14.100 --> 00:43:15.950
There are lots of things you
can do once you have a nice

00:43:16.070 --> 00:43:17.520
URL format for your identifiers.

00:43:19.520 --> 00:43:20.700
Now, they're only useful after
the object's been saved,

00:43:20.700 --> 00:43:23.510
because until it's been saved,
it's a temporary reference.

00:43:23.510 --> 00:43:28.110
But once you have saved it,
whenever you get that textual

00:43:28.110 --> 00:43:30.350
URI representation back,
you can give it to the persistent

00:43:30.350 --> 00:43:34.150
store coordinator and get
back your original object ID.

00:43:35.240 --> 00:43:38.800
So another thing that Address
Book and iCal are now making use of in

00:43:38.800 --> 00:43:41.000
Leopard is the multi-process access.

00:43:41.040 --> 00:43:44.680
So the SQLite store supports
multi-process access on file systems

00:43:44.680 --> 00:43:47.030
that correctly implement file locking.

00:43:47.150 --> 00:43:51.310
So you'll have to check what version
of NFS your file server is running.

00:43:51.310 --> 00:43:55.450
But on HFS Plus and AFP you can get
multiple readers and multiple writers,

00:43:55.510 --> 00:43:58.910
and conflicts are handled at
this layer by the managed object

00:43:58.950 --> 00:44:00.850
context when it does the saving.

00:44:00.950 --> 00:44:05.180
It basically realizes that it's not
going to be able to save the data.

00:44:05.200 --> 00:44:08.410
is that someone's edited
things out from underneath you.

00:44:10.010 --> 00:44:12.880
And as part of that,
we have merge policies,

00:44:12.880 --> 00:44:16.860
which you can set per context,
which tell Core Data what you want

00:44:16.870 --> 00:44:18.800
to do after it detects a conflict.

00:44:18.940 --> 00:44:23.770
So we're tracking revisions in
the database to all the objects.

00:44:23.890 --> 00:44:27.390
And at that point,
we can tell whether or not a different

00:44:27.390 --> 00:44:29.800
process has changed the object,
or even different threads.

00:44:29.880 --> 00:44:31.960
Or as I mentioned,
you can have multiple contexts,

00:44:31.960 --> 00:44:35.540
so an inspector window and a main window,
and they can have different changes.

00:44:35.540 --> 00:44:38.630
We can tell even if it's
a single thread that,

00:44:38.630 --> 00:44:40.870
say, the inspector window has
changed something that the

00:44:40.870 --> 00:44:42.170
main window hasn't saved.

00:44:42.290 --> 00:44:44.700
So we provide for you four
automated recovery options,

00:44:44.700 --> 00:44:47.590
so you don't even have to necessarily
think about it if you decide that

00:44:47.590 --> 00:44:51.020
you want last writer to always win,
or the first writer to win and the

00:44:51.020 --> 00:44:53.920
last writer to be forced to roll back,
or whatever.

00:44:54.040 --> 00:44:57.120
And you can use the default policy,
which will give you a user info

00:44:57.150 --> 00:45:02.280
dictionary on the NSError that has all
the information you need to do whatever

00:45:02.280 --> 00:45:04.620
you would like to resolve that conflict.

00:45:04.620 --> 00:45:06.950
And then you just save again.

00:45:08.410 --> 00:45:12.510
So some new features in
Core Data I'm very excited about.

00:45:12.570 --> 00:45:15.370
I hope many of you,
since a lot of you have

00:45:15.410 --> 00:45:18.300
started playing with Core Data,
will be interested in these.

00:45:18.300 --> 00:45:21.300
And the first is the schema evolution,
so schema migration.

00:45:21.300 --> 00:45:26.460
This is the single most requested feature
of Core Data after Tiger Shift was

00:45:26.830 --> 00:45:30.300
done a version of their app or
even just a beta of their app.

00:45:30.330 --> 00:45:33.780
And you want to change your model,
add a new attribute to an entity,

00:45:33.780 --> 00:45:36.300
something like that, really simple stuff.

00:45:36.330 --> 00:45:39.740
And at that point,
Core Data wouldn't open

00:45:39.740 --> 00:45:42.300
up older database files.

00:45:42.300 --> 00:45:45.270
So somewhat inconvenient,
a lot of people have worked

00:45:45.360 --> 00:45:48.590
around this in various ways,
and we're providing a full tool

00:45:48.930 --> 00:45:53.300
about this that allows versioning of
the different models and the stores,

00:45:53.300 --> 00:45:57.160
so we can detect which version of the
model was used to write out a store,

00:45:57.320 --> 00:45:59.300
provide mapping rules
between the versions about

00:45:59.300 --> 00:45:59.300
how you would use the model,
and then we can use the model to

00:45:59.300 --> 00:45:59.300
create a new version of the model.

00:45:59.300 --> 00:45:59.300
So we're going to talk
about the core data,

00:45:59.300 --> 00:45:59.300
and we're going to talk
about the core data,

00:45:59.300 --> 00:45:59.300
and we're going to talk
about the core data,

00:45:59.300 --> 00:45:59.300
and we're going to talk
about the core data,

00:45:59.300 --> 00:45:59.300
and we're going to talk
about the core data,

00:45:59.300 --> 00:45:59.300
and we're going to talk
about the core data,

00:45:59.300 --> 00:45:59.300
and we're going to talk
about the core data,

00:46:00.300 --> 00:46:05.700
would like to upgrade between different
versions and a migration manager

00:46:05.700 --> 00:46:08.420
to help run some of that process.

00:46:08.500 --> 00:46:12.410
So the entities all now
have a version hash code,

00:46:12.410 --> 00:46:16.660
which is basically sort
of a cryptographic hash.

00:46:16.770 --> 00:46:19.390
And we record all the version
hashes used to write out a

00:46:19.400 --> 00:46:21.120
store in the store's metadata.

00:46:21.220 --> 00:46:23.410
And when you open up the store,
we'll make sure that

00:46:23.520 --> 00:46:25.540
everything is in sync.

00:46:26.250 --> 00:46:30.290
The mappings are pretty simple rules to
describe how to transform one version

00:46:30.290 --> 00:46:32.160
of a store into another version.

00:46:32.160 --> 00:46:34.360
So if you add an attribute,
do you want that new attribute

00:46:34.440 --> 00:46:35.980
to have the default value?

00:46:36.120 --> 00:46:38.160
Do you want the value to be
derived from existing data?

00:46:38.200 --> 00:46:39.290
Stuff like that.

00:46:39.450 --> 00:46:45.390
And there are a bunch of simple
transformation rules that we provide.

00:46:45.820 --> 00:46:49.240
And then the Migration Manager is
basically a helper class to

00:46:49.240 --> 00:46:51.970
help run the migration for you.

00:46:52.050 --> 00:46:58.020
So it basically finds the new model
for a store and gives you some

00:46:58.020 --> 00:47:04.100
customized callbacks and sort of
gets rid of some of the tedium here.

00:47:07.400 --> 00:47:28.260
and Michael Sanchez will be giving a
session on the schema evolution feature.

00:47:28.260 --> 00:47:28.260
And Miguel Sanchez will be giving
a session and go into a great deal

00:47:28.260 --> 00:47:28.260
of detail about how to upgrade your
stores and make use of the versioning.

00:47:30.280 --> 00:47:33.190
Another new feature is
the Atomic Store API,

00:47:33.190 --> 00:47:36.340
and this allows you to write
your own custom backend.

00:47:36.610 --> 00:47:41.750
Core Data will interact with your store,
and then we do the same stuff we

00:47:41.750 --> 00:47:45.620
do on the frontend with the Manage
Objects and Manage Object Context.

00:47:45.640 --> 00:47:51.010
This allows you to bring in legacy data
or write out data in a standardized file

00:47:51.290 --> 00:47:54.620
format that Core Data couldn't annotate.

00:47:54.640 --> 00:47:58.330
Core Data will interact with your store,
and then we do the same stuff

00:47:58.530 --> 00:48:01.810
we do on the frontend with
the Manage Object Context.

00:48:03.530 --> 00:48:10.350
and tomorrow at 2:00 PM in the
Optimizing Core Data application session,

00:48:10.350 --> 00:48:13.720
Melissa Turner will talk more about
writing your own custom store.

00:48:16.770 --> 00:48:19.630
So in the Managed Object context,
we've added some new API.

00:48:19.740 --> 00:48:21.810
These are some fairly basic enhancements.

00:48:21.900 --> 00:48:25.070
The first is a fast account
for fetch request method,

00:48:25.070 --> 00:48:27.190
where you don't really
actually want any of the data,

00:48:27.300 --> 00:48:30.650
but you'd like to know how many
objects would match that query.

00:48:30.820 --> 00:48:34.000
So if you're doing a
summation field or something,

00:48:34.000 --> 00:48:37.840
you don't need to fetch all the data just
to figure out how many match that query.

00:48:37.870 --> 00:48:41.800
And also to help address part of the
problem and some of the tediousness

00:48:41.800 --> 00:48:43.940
of working with temporary object IDs.

00:48:44.060 --> 00:48:46.260
So if you have an object
that hasn't been saved yet,

00:48:46.410 --> 00:48:50.130
but you still want that URL reference
to put it on the paste board,

00:48:50.230 --> 00:48:53.530
we now have a method on the context
to obtain a permanent ID before

00:48:53.640 --> 00:48:55.100
you actually save the object.

00:48:55.250 --> 00:48:57.740
So that way when you do save the object,
its ID won't change,

00:48:57.800 --> 00:49:00.720
you'll sort of pre-allocated
a permanent ID for it.

00:49:00.810 --> 00:49:05.010
And this really makes it a lot easier
to do cross-door relationships.

00:49:05.920 --> 00:49:08.820
And for the Fetch Request API,
we've added a bunch of

00:49:08.830 --> 00:49:10.600
API to help tune performance.

00:49:10.690 --> 00:49:14.230
In particular, you can decide now if
you just want object IDs,

00:49:14.230 --> 00:49:16.850
you don't actually want
to fetch all the data,

00:49:16.850 --> 00:49:19.810
you just want the identities
that match that query.

00:49:19.900 --> 00:49:24.130
So you can do this to build up some sets,
and then you could intersect them or

00:49:24.130 --> 00:49:26.280
do some other kind of manipulation.

00:49:26.360 --> 00:49:29.550
You might pull them aside and
then fetch the data that match

00:49:29.640 --> 00:49:31.560
those object IDs at a later time.

00:49:31.560 --> 00:49:35.880
And then another important
optimization is prefetching.

00:49:35.900 --> 00:49:37.420
So prefetching is the processing
of relationship key paths.

00:49:37.460 --> 00:49:39.590
Like I said,
you don't want to do lots of small

00:49:39.590 --> 00:49:40.870
fetches if you don't have to.

00:49:40.920 --> 00:49:46.300
So if you're pulling up a window and you
know that you have a master detail view,

00:49:46.380 --> 00:49:49.940
you might want to fetch
the detail information.

00:49:49.940 --> 00:49:52.610
So that'll be off of the
master object's relationships.

00:49:52.610 --> 00:49:55.110
And you can grab all of that
with one fetch by specifying

00:49:55.110 --> 00:49:58.000
the key paths that you'd like
to bring back at the same time.

00:49:58.000 --> 00:50:02.190
So that's a great way for improving
the responsiveness of the UI,

00:50:02.190 --> 00:50:04.640
get exactly what the UI is showing.

00:50:04.660 --> 00:50:05.880
And then the last thing I want
to talk about is the key path.

00:50:05.880 --> 00:50:05.880
So if you're pulling up a window and you
know that you have a master detail view,

00:50:05.880 --> 00:50:05.880
you might want to fetch
the detail information.

00:50:05.880 --> 00:50:05.880
So that'll be off of the
master object's relationships.

00:50:05.880 --> 00:50:05.880
And you can grab all of that
with one fetch by specifying

00:50:05.880 --> 00:50:05.880
the key paths that you'd like
to bring back at the same time.

00:50:05.880 --> 00:50:08.870
And there's some sundry additional
API on the fetch request.

00:50:08.930 --> 00:50:11.330
There's a bunch of stuff that
Malcolm Crawford has very

00:50:11.390 --> 00:50:12.690
kindly documented for us.

00:50:12.730 --> 00:50:16.470
Prepopulating managed objects,
if you know that you don't really

00:50:16.470 --> 00:50:20.010
want the faulting to go on,
and you can make the queries a little

00:50:20.010 --> 00:50:22.740
more exclusive and not match subentities.

00:50:25.010 --> 00:50:29.280
And we have some additional
notification keys and context to tell

00:50:29.280 --> 00:50:33.190
you what objects have been refreshed
in the past event if you call refresh

00:50:33.190 --> 00:50:37.710
object on it or the context does,
as well as what objects have been

00:50:37.710 --> 00:50:40.480
invalidated if you call reset.

00:50:40.510 --> 00:50:42.830
Then the manage objects themselves
have a few more callbacks.

00:50:42.900 --> 00:50:47.700
The Persistent Store Coordinator has a
set URL method that you can use if you

00:50:47.740 --> 00:50:52.580
decide to move a Persistent Store file
that's loaded in a coordinator.

00:50:52.580 --> 00:50:54.310
You move it on the database.

00:50:54.910 --> 00:50:57.610
You move it on the file system
out from underneath Core Data.

00:50:57.770 --> 00:51:00.440
You can tell us where you've moved it to.

00:51:00.460 --> 00:51:03.310
And also we're shipping now
as part of all the installs a

00:51:03.310 --> 00:51:04.560
debug version of the framework.

00:51:04.560 --> 00:51:08.990
So you can use the
DOLD image suffix export,

00:51:09.080 --> 00:51:12.120
and you can get assertions in
your code as you're debugging.

00:51:12.120 --> 00:51:15.740
And you can also turn on multi-threading
assertions where a coder will check to

00:51:15.740 --> 00:51:19.280
make sure that the state that you've
put it in and you've put the context

00:51:19.280 --> 00:51:22.900
and all the manage objects are in
are what we think ought to be done.

00:51:22.900 --> 00:51:28.560
And these are obviously disabled in
the shipping version of the framework

00:51:28.560 --> 00:51:29.950
because it's a little expensive to do.

00:51:29.950 --> 00:51:32.220
But there's a whole separate
framework there for you.

00:51:32.610 --> 00:51:38.100
And some related enhancements in
Foundation instead of Core Data are

00:51:38.100 --> 00:51:41.350
the predicates and expressions
that Core Data is built on top of.

00:51:41.760 --> 00:51:46.040
There's filtering on NSSet now
that matches the filtered

00:51:46.040 --> 00:51:47.720
the array with predicate.

00:51:47.720 --> 00:51:50.700
And we also have a subquery
expression for you.

00:51:50.700 --> 00:51:53.270
There are custom function
expressions where you can say you

00:51:53.270 --> 00:51:57.520
want to set up a predicate that's
using a function that you provide.

00:51:57.610 --> 00:51:59.230
We have some set operations.

00:51:59.370 --> 00:52:05.170
So you have predicates that can do
unions and intersects as part of a fetch.

00:52:05.170 --> 00:52:08.380
And a fetch request expression that
Miguel will show a little more about

00:52:08.510 --> 00:52:12.500
tomorrow in the modeling session that's
basically a predicate that performs

00:52:12.500 --> 00:52:16.060
a fetch as part of the qualification.

00:52:17.780 --> 00:52:21.230
So one of the things that I'm
most excited about are all of

00:52:21.280 --> 00:52:25.420
the platform initiatives that
Mac OS X is doing in Leopard now.

00:52:25.780 --> 00:52:29.540
I was very sad yesterday when it
took over 90 minutes to get to the

00:52:29.540 --> 00:52:32.180
store to configure a new machine.

00:52:33.180 --> 00:52:37.640
So part of that here,
and Core Data has participated in

00:52:37.640 --> 00:52:43.180
some way and form in pretty much all
of the Leopard platform initiatives.

00:52:43.180 --> 00:52:47.180
The first is, of course,
the universal transition to Intel,

00:52:47.180 --> 00:52:52.180
and the transition to 64-bit
on both PowerPC and Intel.

00:52:52.180 --> 00:52:57.880
So Core Data now is just built four ways,
and it's pretty easy for you to set up

00:52:57.970 --> 00:53:03.010
your applications using Core Data to
ship on any of these architectures.

00:53:03.990 --> 00:53:08.720
and going on right now as we speak
is a session on Objective-C 2.0.

00:53:08.800 --> 00:53:12.300
They have a bunch of new language
features that are actually pretty cool.

00:53:12.300 --> 00:53:14.990
So they're adding garbage
collection to Cocoa,

00:53:15.070 --> 00:53:18.250
and that's opt-in so you
don't have to use it.

00:53:18.350 --> 00:53:20.600
And then there's a fast
enumeration protocol,

00:53:20.600 --> 00:53:24.080
so it lets you type a foreign syntax
that I'll show a little bit later.

00:53:26.080 --> 00:53:29.080
And then Objective-C supporting
properties,

00:53:29.080 --> 00:53:31.510
and Core Data, I'm afraid,
didn't quite get to that

00:53:31.510 --> 00:53:32.570
in the Leopard Seed.

00:53:32.580 --> 00:53:34.080
I will demo some of that in a bit.

00:53:34.080 --> 00:53:38.300
But properties are some things
you see in some other languages,

00:53:38.310 --> 00:53:43.080
and they're really a great way to
get type safe key paths in your code,

00:53:43.080 --> 00:53:48.690
have the compiler check as opposed
to just the arbitrary strings.

00:53:49.580 --> 00:53:52.060
and we spent a lot of time
working on performance and

00:53:52.060 --> 00:53:56.790
scalability enhancements in Leopard.

00:53:57.000 --> 00:54:00.710
On my trusty dual G5,
I was getting about a little over

00:54:00.760 --> 00:54:03.840
20,000 rows per second on Tiger.

00:54:03.840 --> 00:54:05.870
And on Leopard,
now in the seed that you have,

00:54:05.870 --> 00:54:08.770
we're getting about
125,000 rows per second.

00:54:08.910 --> 00:54:13.250
So we've made some small adjustments.

00:54:18.700 --> 00:54:19.600
Thank you.

00:54:19.600 --> 00:54:21.230
This is really only the beginning.

00:54:21.240 --> 00:54:25.860
There are more performance enhancements
that have been throughout the

00:54:25.920 --> 00:54:30.120
Leopard development cycle than
I can actually put on the slide here,

00:54:30.120 --> 00:54:31.740
but there's tons of stuff.

00:54:31.740 --> 00:54:34.930
Odds and ends, query short-circuiting,
improved caching,

00:54:34.940 --> 00:54:37.810
improved memory management,
faster saving,

00:54:37.920 --> 00:54:42.070
and we have a lot of additional
things that are right around the

00:54:42.320 --> 00:54:44.500
corner in a future Leopard seed.

00:54:44.500 --> 00:54:47.840
Now, you may ask why we
consider this so important,

00:54:47.840 --> 00:54:51.000
and that's because the first
question that 92% of you ask

00:54:51.000 --> 00:54:58.170
is-- and the other 8% of you ask
me if I have time for a question.

00:54:58.310 --> 00:55:00.100
So--

00:55:05.770 --> 00:55:08.190
So these reflect some
legitimate concerns.

00:55:08.200 --> 00:55:10.300
I tend not to hear them from
people who have used Core Data,

00:55:10.300 --> 00:55:14.640
but they are legitimate concerns
as people need to decide whether

00:55:14.640 --> 00:55:17.240
or not they want to invest the
effort to adopt a new technology.

00:55:17.240 --> 00:55:21.240
So I appreciate that.

00:55:21.350 --> 00:55:25.460
Then there's this,
which is an interesting question.

00:55:25.460 --> 00:55:29.310
It's perhaps better phrased
or rephrased as the,

00:55:29.470 --> 00:55:32.560
well, Core Data is a new technology.

00:55:32.560 --> 00:55:34.540
So I'm going to start with Core Data.

00:55:34.550 --> 00:55:35.800
So Core Data is a new technology.

00:55:35.800 --> 00:55:37.510
We came out in Tiger,
and all of you pretty much

00:55:37.570 --> 00:55:38.600
had data before Tiger.

00:55:38.600 --> 00:55:40.830
I mean,
Panther was not some great dark age.

00:55:40.830 --> 00:55:43.400
You've all used persistence
solutions before.

00:55:43.400 --> 00:55:45.220
Some of you have rolled your own.

00:55:45.220 --> 00:55:46.910
Some of them are really fast.

00:55:46.920 --> 00:55:49.790
And others of you have
reused other technologies,

00:55:49.790 --> 00:55:52.140
maybe even been as simple as NS Coding.

00:55:52.140 --> 00:55:56.650
But there are a lot of different
persistence solutions out there,

00:55:56.650 --> 00:56:00.030
and adopting Core Data is
a transition for you.

00:56:00.080 --> 00:56:01.760
Now, this is my favorite.

00:56:03.360 --> 00:56:09.040
and David So this one I have
a little less sympathy for,

00:56:09.070 --> 00:56:12.400
because I just don't see how
hand coding V tables with

00:56:12.400 --> 00:56:15.710
Strixit function pointers is fun.

00:56:15.760 --> 00:56:17.460
Objective-C is a tool.

00:56:17.460 --> 00:56:19.390
It can be used well,
it can be used poorly,

00:56:19.390 --> 00:56:22.290
it can be used for the wrong problem.

00:56:24.520 --> 00:56:27.000
So now I'm going to provide
you a demonstration.

00:56:27.010 --> 00:56:30.290
So we've run a little bit
longer than I expected,

00:56:30.390 --> 00:56:33.780
but hopefully none of you have
to go anywhere too quickly.

00:56:33.870 --> 00:56:37.210
So basically, I'm going to show three
different projects that are all

00:56:37.210 --> 00:56:38.390
doing exactly the same thing.

00:56:38.400 --> 00:56:41.940
They're fetching 500,000 words
from a dictionary of words.

00:56:42.020 --> 00:56:44.900
And the words are actually
very trivial objects,

00:56:44.900 --> 00:56:50.410
but they should help demonstrate how
well or not well Core Data manages all

00:56:50.410 --> 00:56:53.080
the overhead that its features provide.

00:56:53.170 --> 00:56:59.360
So the first project is something
that I see fairly indicative

00:56:59.360 --> 00:57:06.060
of people who've decided that
Core Data and Objective-C are too slow.

00:57:06.810 --> 00:57:09.140
Basically, as you can see here,
it's a .c.

00:57:09.140 --> 00:57:12.500
We've dispensed with
Objective-C entirely.

00:57:12.500 --> 00:57:16.800
And the key point here is, basically,
we have a generic dictionary

00:57:16.850 --> 00:57:18.380
as our model object.

00:57:18.380 --> 00:57:20.240
We don't have a formal schema.

00:57:20.240 --> 00:57:23.920
We're just sort of throwing
things into it in key pairs.

00:57:23.920 --> 00:57:28.820
And we're using core foundation
collections to handle the data.

00:57:28.820 --> 00:57:31.890
And this is all, you know, I mean,
it's not necessarily pretty,

00:57:31.920 --> 00:57:33.290
but it's all pretty straightforward.

00:57:33.350 --> 00:57:35.660
We're using SQLite as directly.

00:57:35.660 --> 00:57:38.260
Nothing much going on there.

00:57:39.820 --> 00:57:44.220
And sometimes you see pretty
much the same thing in C++,

00:57:44.380 --> 00:57:46.400
but with STL classes.

00:57:46.490 --> 00:57:48.180
So I'm going to hint this a bit.

00:57:48.280 --> 00:57:52.350
And we're going to have a
reproducible experiment.

00:57:52.380 --> 00:57:55.460
So I'm going to run it a couple
times to warm everything up so

00:57:55.490 --> 00:58:01.460
the future test apps run and
don't get an unfair advantage.

00:58:01.550 --> 00:58:07.450
So basically we're fetching about 150,000
rows per second here with this pretty

00:58:07.450 --> 00:58:10.560
basic SQLite code using Core Foundation.

00:58:10.580 --> 00:58:16.210
And if we pop up terminal,
that was about 96 lines of code.

00:58:20.480 --> 00:58:25.080
If you spent a great deal of time in
Shark and you spent a lot of bribes

00:58:25.080 --> 00:58:29.310
on the Cocoa team and the kernel
team and all the other teams at

00:58:29.390 --> 00:58:33.420
Apple to how to resolve every single
problem that you found in Shark,

00:58:33.510 --> 00:58:36.740
you'd move along in the direction
that this app is going in.

00:58:36.740 --> 00:58:43.020
So we come back to Objective-C because
we can get some things for free in here.

00:58:43.020 --> 00:58:43.890
That's very nice.

00:58:44.000 --> 00:58:47.110
And so the key point is we've
replaced the dictionary,

00:58:47.200 --> 00:58:50.340
which is a very convenient
model object but not a really

00:58:50.340 --> 00:58:54.900
high-performing model object,
with a real class that has scalars.

00:58:55.010 --> 00:58:58.280
And we've done some serious
hacking on retain and release.

00:58:58.280 --> 00:59:01.070
We've got these static functions,
which are basically Objective-C's

00:59:01.070 --> 00:59:04.710
equivalent of a non-virtual method.

00:59:04.750 --> 00:59:07.960
And otherwise, it's pretty much the same.

00:59:07.960 --> 00:59:11.180
We've got some custom callbacks
now in the CF collection

00:59:11.180 --> 00:59:12.940
classes that we're using.

00:59:24.960 --> 00:59:27.480
Now we're running at over
200,000 rows per second.

00:59:27.570 --> 00:59:36.090
It's about 40% faster than the
more obvious way of doing it.

00:59:40.600 --> 00:59:43.170
and it's about a third more code,
so not so bad.

00:59:43.230 --> 00:59:51.760
And then here for the Core Data example,
first I'll show you a model.

00:59:51.760 --> 00:59:53.930
Now all the apps are using
exactly the same schema.

00:59:54.030 --> 00:59:59.610
So we've got a very trivial word here.

00:59:59.610 --> 01:00:01.200
Word's got a length,
it's got a first letter,

01:00:01.200 --> 01:00:01.200
and it's got some word text.

01:00:02.400 --> 01:00:06.400
One of the nice things about Word,
we have a Word class.

01:00:06.400 --> 01:00:09.820
Now here we're showing some of
the new Objective-C properties.

01:00:11.870 --> 01:00:15.800
So for Objective-C 2.0,
the properties allow a way for

01:00:15.800 --> 01:00:19.600
Core Data to really tell the
compiler about the same kind of

01:00:19.600 --> 01:00:23.830
things that the entity description
is telling Core Data about.

01:00:23.890 --> 01:00:27.220
Properties are much more
generic than Core Data.

01:00:27.220 --> 01:00:30.530
Objective-C is using them
for all kinds of things,

01:00:30.530 --> 01:00:35.700
and they provide a really nice interface
to the access that the word object has,

01:00:35.740 --> 01:00:37.660
or your object has.

01:00:37.680 --> 01:00:41.270
And basically what ends up happening
is the compiler then infers the

01:00:41.270 --> 01:00:42.920
existence of accessor methods.

01:00:42.920 --> 01:00:45.210
So you don't have to declare all
the additional accessor methods.

01:00:45.210 --> 01:00:48.570
You could if you wanted to,
but there's a text and a set text

01:00:48.660 --> 01:00:50.770
method and a length and a set length.

01:00:50.770 --> 01:00:54.230
And that's about it.

01:00:54.230 --> 01:00:57.300
Now for Core Data objects...

01:00:58.430 --> 01:01:01.360
Yeah, that's about all you need to do
to implement all those properties.

01:01:01.360 --> 01:01:05.480
So one of the great things about this
is working with the Objective-C team,

01:01:05.480 --> 01:01:09.230
we're now generating all the
accessor methods dynamically for you,

01:01:09.290 --> 01:01:10.800
including the primitive accessor methods.

01:01:10.800 --> 01:01:15.450
So you don't have to write any of
the calls to primitive key value

01:01:15.450 --> 01:01:16.840
coding that you might have before.

01:01:16.840 --> 01:01:20.600
If you want to write a
custom accessor method,

01:01:20.600 --> 01:01:23.980
then you can call, in this case,
you could call primitive length,

01:01:23.980 --> 01:01:27.510
and Core Data will infer the
existence of that method and will

01:01:27.510 --> 01:01:30.570
specialize them at runtime to
be exactly what the entity needs.

01:01:30.600 --> 01:01:32.090
We'll optimize them.

01:01:32.100 --> 01:01:35.330
They're great,
and they're actually quite a bit faster

01:01:35.340 --> 01:01:39.780
than doing the key value coding through
the original Tiger Core Data templates.

01:01:39.780 --> 01:01:42.120
So...

01:01:45.370 --> 01:01:48.840
Take a quick look at the
main body of this sample.

01:01:48.840 --> 01:01:50.330
It's pretty straightforward.

01:01:50.340 --> 01:01:53.510
We're creating a core data stack--
the same thing you can get from

01:01:53.510 --> 01:01:56.440
any of the template projects here.

01:01:56.440 --> 01:01:57.840
We create a fetch request.

01:01:57.960 --> 01:02:01.220
So here's some of our new API to
turn off some of the faulting,

01:02:01.220 --> 01:02:06.180
because we know we're going to iterate
through every element of the result set.

01:02:06.220 --> 01:02:10.100
And we set a fetch limit,
which is the same that the SQL was

01:02:10.100 --> 01:02:12.410
written for in the other examples.

01:02:12.470 --> 01:02:13.710
And we execute the fetch.

01:02:13.810 --> 01:02:16.490
And then here,
we see the new faster enumeration

01:02:16.490 --> 01:02:20.000
syntax in Objective-C,
which is quite a bit faster

01:02:20.440 --> 01:02:24.840
for iterating through any of
the Cocoa Collection classes.

01:02:24.900 --> 01:02:28.830
Something I neglected to show you
is the advanced SQLite project that

01:02:28.830 --> 01:02:30.420
I just showed you is also using that.

01:02:30.490 --> 01:02:31.870
So you can use them bridged.

01:02:31.950 --> 01:02:32.700
Pretty nice.

01:02:32.950 --> 01:02:36.860
And here is the new property syntax.

01:02:37.060 --> 01:02:40.450
So like I mentioned,
this is type safe compiler

01:02:40.490 --> 01:02:41.810
check key paths for you.

01:02:41.880 --> 01:02:43.760
A lot of people have asked for
this feature for a long time.

01:02:43.760 --> 01:02:45.410
It's really nice.

01:02:45.430 --> 01:02:49.010
If words were more complicated,
you could follow relationships further.

01:02:49.130 --> 01:02:52.260
Now, if you decide that you
don't like this syntax,

01:02:52.290 --> 01:02:56.270
because you're more of an
Objective-C traditionalist,

01:02:56.430 --> 01:02:57.120
you can do this.

01:02:57.290 --> 01:02:59.380
You don't have to change any
other part of the project.

01:02:59.390 --> 01:03:01.610
These accessors will
be generated for you.

01:03:01.740 --> 01:03:04.210
So that all works.

01:03:12.900 --> 01:03:20.000
[Transcript missing]

01:03:20.200 --> 01:03:24.980
We're getting close to
500,000 rows per second.

01:03:24.990 --> 01:03:27.060
If this were built a
little bit differently,

01:03:27.060 --> 01:03:31.760
it might actually break that,
but pretty close.

01:03:31.780 --> 01:03:35.940
And we'll throw in the header file too.

01:03:38.060 --> 01:03:42.780
We're getting close to
500,000 rows per second.

01:03:42.780 --> 01:03:44.860
If this were built a
little bit differently,

01:03:44.860 --> 01:03:48.110
it might actually break that,
but pretty close.

01:03:55.290 --> 01:04:04.150
So if we can cut back to the slides.

01:04:04.150 --> 01:04:04.150
Great.

01:04:04.150 --> 01:04:04.150
Yes, no whammy.

01:04:04.150 --> 01:04:04.150
All right.

01:04:04.150 --> 01:04:04.150
So.

01:04:07.900 --> 01:04:11.240
Over 800,000 lines of, sorry,
800,000 rows per second

01:04:11.240 --> 01:04:13.510
on the new hotness.

01:04:13.710 --> 01:04:15.900
The exact, exact same code.

01:04:15.900 --> 01:04:18.960
So, it's been fun.

01:04:20.010 --> 01:04:23.380
So now one of the things about this is
I don't mean to say that Core Data is

01:04:23.380 --> 01:04:25.770
some magic silver bullet that you
should use for all your problems.

01:04:25.960 --> 01:04:27.950
Rather,
this is a demonstration that we're

01:04:27.960 --> 01:04:31.440
really serious about delivering
high-performance solutions to you.

01:04:31.440 --> 01:04:35.160
And forthcoming and future leper seeds,
you'll be able to get a hold of a

01:04:35.160 --> 01:04:38.840
version of Core Data that supports
the Objective-C app property syntax,

01:04:38.930 --> 01:04:43.170
and has a dynamic method generation,
and is scalable across the architectures.

01:04:43.310 --> 01:04:46.680
As you might have imagined,
there's quite a bit going on

01:04:46.720 --> 01:04:49.980
there behind the scenes to
get that 2x speed improvement.

01:05:20.000 --> 01:05:25.940
So one of the things that Core Data is
providing is this scalability,

01:05:25.940 --> 01:05:31.050
where regardless of what
machines your customer is using,

01:05:31.050 --> 01:05:36.000
if they're on a mini with a core solo,
a dual core MacBook,

01:05:36.120 --> 01:05:41.050
or one of the new hotnesses,
or they're like me and they're

01:05:41.060 --> 01:05:46.150
on a little older power PC,
Core Data is going to be managing

01:05:46.150 --> 01:05:49.970
the data as efficiently as possible.

01:05:50.000 --> 01:05:51.770
that hardware.

01:05:53.100 --> 01:05:56.140
So, just to wrap up,
I hope that you learned that

01:05:56.140 --> 01:06:00.510
most of the applications on the
system can benefit from Core Data.

01:06:00.560 --> 01:06:02.640
Even if you're something like
mail and you already have your

01:06:02.640 --> 01:06:05.960
own core persistency solution,
you might do some new features,

01:06:06.020 --> 01:06:08.000
some preferences, something like that.

01:06:08.000 --> 01:06:12.880
It's model-driven, really easy to use,
powerful object graph features,

01:06:12.890 --> 01:06:15.180
and we have lots of new stuff in Leopard.

01:06:15.180 --> 01:06:16.560
We've shown you some.

01:06:16.560 --> 01:06:19.000
The custom stores we'll
talk about more tomorrow.

01:06:19.000 --> 01:06:21.960
The schema migration is
tomorrow morning at 9 a.m.

01:06:23.000 --> 01:06:26.150
And Core Data is participating
in all of these Leopard platform

01:06:26.150 --> 01:06:28.810
initiatives that Core Data apps
can pretty much get for free.

01:06:31.500 --> 01:06:35.580
A parting request from us to you:
help us help you, please.

01:06:35.580 --> 01:06:36.940
We love great feedback.

01:06:36.980 --> 01:06:38.820
Please read the documentation.

01:06:38.930 --> 01:06:49.800
Knock on Croft has done a fabulous job.

01:06:49.800 --> 01:06:49.800
I personally think it's the
best documentation for Cocoa.

01:06:49.800 --> 01:06:49.800
There, you know, throw down the gauntlet.

01:06:50.400 --> 01:06:53.130
Please use bugreport.apple.com.

01:06:53.130 --> 01:06:56.120
It really helps us a lot to
know what parts of the framework

01:06:56.200 --> 01:06:58.810
are most important to you,
where we need to add

01:06:58.820 --> 01:07:02.680
a little more polish,
what performance improvements

01:07:02.680 --> 01:07:05.030
we should do first,
stuff like that.

01:07:05.080 --> 01:07:07.870
If you have a performance issue,
please include a shark trace.

01:07:07.870 --> 01:07:11.080
Shark's really easy to use and provides
us some really valuable feedback.

01:07:11.820 --> 01:07:16.620
If you have a bug and you include a
very small sample application that we

01:07:16.620 --> 01:07:20.370
can click run and it shows us our bug,
that's great.

01:07:20.520 --> 01:07:23.100
Let me tell you that
I fix those bugs first.

01:07:23.100 --> 01:07:26.870
If someone sends me a sample app,
they have my attention.

01:07:28.850 --> 01:07:31.420
So for more information,
Derek Horan is the

01:07:31.430 --> 01:07:35.270
Application Framework Evangelist,
and you can find all the good

01:07:35.270 --> 01:07:36.360
stuff in the usual places.
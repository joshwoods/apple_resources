WEBVTT

00:00:10.410 --> 00:00:13.950
Hi, I'm Geoffrey Keating,
and I'll be giving this

00:00:13.950 --> 00:00:19.410
session number 303,
GCC, C++, and You'. I'm an engineer,

00:00:19.410 --> 00:00:22.710
and I work on GCC at Apple.

00:00:24.590 --> 00:00:27.330
So, what you'll learn in this session,
there are three basic

00:00:27.330 --> 00:00:28.600
things that you'll learn.

00:00:28.740 --> 00:00:31.680
So, first of all,
I'll be telling you about

00:00:31.680 --> 00:00:33.560
how C++ works on Mac OS.

00:00:33.740 --> 00:00:37.710
I won't go so far as to
say innermost details,

00:00:37.940 --> 00:00:39.740
but at least some of the details.

00:00:39.740 --> 00:00:43.290
I'll tell you how to write your
application so that you don't

00:00:43.300 --> 00:00:45.700
need to know how GCC works,
which is probably what

00:00:45.700 --> 00:00:46.740
you're really after.

00:00:46.740 --> 00:00:52.300
And I'll be telling you about how
to write a C++ library with a stable

00:00:52.300 --> 00:00:59.620
ABI so that you can do things like have
release-to-release binary compatibility.

00:01:01.240 --> 00:01:03.790
So what's different about C++?

00:01:04.040 --> 00:01:08.490
Why does this have to be
a talk about C++ at all?

00:01:08.900 --> 00:01:13.840
So C++ has a bunch of features
that aren't available in C.

00:01:13.910 --> 00:01:20.320
You can see the first four here are
things that appear in other languages,

00:01:20.320 --> 00:01:25.380
like function overloading is in Java,
exceptions you can find in Objective-C.

00:01:25.520 --> 00:01:29.910
Many languages have multiple namespaces
that you can define things in.

00:01:30.640 --> 00:01:34.440
There's also some things
that are unique to C++.

00:01:34.580 --> 00:01:37.540
C++ has a very unique
functionality for inlining,

00:01:37.540 --> 00:01:39.160
for example.

00:01:39.450 --> 00:01:44.520
C++ type linkage, and virtual functions,
and multiple inheritance, and so on.

00:01:44.520 --> 00:01:47.460
All of these are things that you
don't find in other languages.

00:01:47.520 --> 00:01:52.240
And all of these things require
special runtime or ABI support.

00:01:52.330 --> 00:02:00.070
And many of them require consideration
when you're designing your library,

00:02:00.120 --> 00:02:02.050
building an ABI,
or just trying to work out what on

00:02:02.050 --> 00:02:02.050
earth is going on in your application.

00:02:03.670 --> 00:02:08.270
So I'll start with the first two,
namespaces and function overloading.

00:02:08.370 --> 00:02:13.540
So C++ has a bunch of ways
where you can define the same

00:02:13.570 --> 00:02:16.990
function with the same name,
as you can see here in the example,

00:02:17.210 --> 00:02:19.560
but the functions are all different.

00:02:19.560 --> 00:02:21.730
For example,
you can define a function and

00:02:21.730 --> 00:02:25.880
then another function of the same
name that's a member of a class.

00:02:25.880 --> 00:02:30.610
You can also use the C++ namespace
feature to declare yet another

00:02:30.610 --> 00:02:32.590
copy of the same function.

00:02:34.130 --> 00:02:37.060
C++ also has function overloading.

00:02:37.060 --> 00:02:40.720
You can define two functions of the
same name in the same namespace,

00:02:40.830 --> 00:02:42.860
but if they take
different parameter types,

00:02:42.860 --> 00:02:44.150
then they're still different.

00:02:44.320 --> 00:02:47.650
For example, here you see two functions
which are different because

00:02:47.650 --> 00:02:49.580
they take different parameters.

00:02:49.980 --> 00:02:53.700
And finally,
there are some functions in C++

00:02:53.750 --> 00:02:57.070
that don't really have pronounceable
or printable names at all.

00:02:57.170 --> 00:02:59.450
For example,
here we have the dereference operator

00:02:59.550 --> 00:03:03.400
on a particular kind of parameter.

00:03:04.200 --> 00:03:08.630
Now, the problem with all of these
is that the Mac OS linker,

00:03:08.630 --> 00:03:11.900
and the linker on virtually
every other operating system,

00:03:12.360 --> 00:03:16.360
expects that a function is
given a particular name,

00:03:16.360 --> 00:03:18.390
and it can only be like
a character string,

00:03:18.520 --> 00:03:20.480
preferably a reasonably
readable character string,

00:03:20.480 --> 00:03:23.140
or at least one made
up of ASCII characters.

00:03:23.140 --> 00:03:27.240
So you can't just tell the linker,
I've got three things,

00:03:27.240 --> 00:03:29.260
and they're all named func, right?

00:03:29.260 --> 00:03:30.130
That's not going to work.

00:03:30.160 --> 00:03:32.400
It'll say,
you've defined func three times.

00:03:32.400 --> 00:03:38.050
So instead, C++ gives these various
functions mangled names.

00:03:38.840 --> 00:03:42.080
For example, here,
we have the three mangled names

00:03:42.080 --> 00:03:43.670
corresponding to these three functions.

00:03:43.680 --> 00:03:46.660
And you can see in each of
these that the namespace is

00:03:46.660 --> 00:03:49.830
encoded into the mangled name,
along with a bunch of other stuff,

00:03:49.830 --> 00:03:51.210
which looks totally unreadable.

00:03:52.980 --> 00:03:54.990
Likewise,
when a function has different parameters,

00:03:55.070 --> 00:03:58.400
the parameters are also
encoded into the mangled name.

00:03:58.400 --> 00:04:01.160
And finally, for functions that don't
have printable names,

00:04:01.240 --> 00:04:02.240
they're given one.

00:04:02.310 --> 00:04:06.960
So here you can see it says ZDE,
and actually DE stands for

00:04:07.020 --> 00:04:08.770
the reference operator.

00:04:09.730 --> 00:04:16.020
So now, because the linker only knows
about these mangled names,

00:04:16.040 --> 00:04:20.000
sometimes you need to know about it.

00:04:20.010 --> 00:04:22.860
The compiler, the debugger,
and Shark will all mangle and

00:04:22.860 --> 00:04:24.660
de-mangle these names automatically.

00:04:24.700 --> 00:04:29.640
So you don't have to worry about
how to mangle or de-mangle names,

00:04:29.650 --> 00:04:32.930
so long as you're using the compiler,
the debugger, and Shark.

00:04:33.220 --> 00:04:40.900
If you use the NM tool to see what
the names are in a Mac OS object,

00:04:41.140 --> 00:04:43.380
You'll see that NM presents
the names in the mangled form,

00:04:43.390 --> 00:04:45.740
because it tells you what
the linker is thinking,

00:04:45.740 --> 00:04:48.740
and the linker only knows
about mangled names.

00:04:48.790 --> 00:04:52.000
There is a tool called C++Field
that'll take these mangled

00:04:52.000 --> 00:04:53.440
names and de-mangle them.

00:04:53.520 --> 00:04:55.690
I should mention, though, that

00:04:55.920 --> 00:04:59.800
The demangling does not tell you
everything about the mangled name.

00:04:59.830 --> 00:05:05.700
There are some fairly rare cases
where two different demangled names

00:05:05.700 --> 00:05:10.130
will be mangled into the same form,
or the other way around.

00:05:10.490 --> 00:05:12.200
If you ever look at assembly code,
or worse,

00:05:12.200 --> 00:05:16.940
if you actually have to write assembly
code to link with C++ objects,

00:05:17.090 --> 00:05:19.030
you'll find that that has
to have mangled names,

00:05:19.120 --> 00:05:22.110
because the assembler also
expects functions and so

00:05:22.280 --> 00:05:23.900
on to have a single name.

00:05:24.510 --> 00:05:29.130
If you use export lists, then on Mac OS,
export lists contain mangled

00:05:29.130 --> 00:05:30.750
names for maximum control.

00:05:30.760 --> 00:05:34.300
The disadvantage is that because
they contain mangled names,

00:05:34.300 --> 00:05:36.210
it means you have to know
what the mangled names are.

00:05:36.220 --> 00:05:41.640
If you want to find a mangled name,
the easiest way to do it is to write

00:05:41.640 --> 00:05:45.280
a short C++ program that contains the
mangled symbol that you're hoping for,

00:05:45.280 --> 00:05:47.610
run it through the compiler,
and see what the compiler

00:05:47.610 --> 00:05:48.900
says the mangled name is.

00:05:48.900 --> 00:05:53.130
You can also go look at the multi-vendor
C++ API and try to work it out yourself,

00:05:53.670 --> 00:05:57.420
But it's probably a lot easier if
you just let the tool do it for you.

00:05:57.580 --> 00:06:01.730
To avoid needing to deal with
mangled names in an export list,

00:06:01.840 --> 00:06:05.300
the easiest thing to do is
let the compiler know what the

00:06:05.300 --> 00:06:09.180
visibility is by using visibly
attributes or pragmas instead,

00:06:09.200 --> 00:06:10.430
as in the code example here.

00:06:10.440 --> 00:06:15.310
And then you can see very simply that,
and then you can simply add

00:06:15.340 --> 00:06:19.800
the attribute to your function
and not have to worry what the

00:06:19.800 --> 00:06:22.130
mangled name of that function is.

00:06:37.240 --> 00:06:41.740
So if you're trying to
maintain a stable ABI,

00:06:41.870 --> 00:06:43.640
name mangling really is your friend.

00:06:43.750 --> 00:06:47.300
It's probably the best thing that
you'll find has ever happened to you.

00:06:47.390 --> 00:06:49.760
Unlike in C,
where if a function has a name,

00:06:49.790 --> 00:06:52.720
it's got that name,
name mangling permits you to have

00:06:52.720 --> 00:06:54.770
many names for the same function.

00:06:54.860 --> 00:06:58.670
For example, suppose you've written
your wonderful library.

00:06:58.770 --> 00:07:02.340
So if you'd been doing this
with an ABI compatibility,

00:07:02.480 --> 00:07:06.160
one thing you might consider is
putting your great library inside a

00:07:06.160 --> 00:07:08.480
namespace if you're doing it in C++.

00:07:08.480 --> 00:07:11.530
This will make life easier for C++
users of your library because they

00:07:11.590 --> 00:07:14.230
don't have to worry about conflicts.

00:07:14.260 --> 00:07:19.060
But if you decide you need to maintain
binary compatibility with this library,

00:07:19.060 --> 00:07:21.620
namespaces give you a
wonderful advantage.

00:07:21.620 --> 00:07:24.270
For example, suppose your library,
you've written a new

00:07:24.270 --> 00:07:25.600
version of your library.

00:07:25.600 --> 00:07:26.840
It's totally different.

00:07:26.840 --> 00:07:27.840
Nothing is the same.

00:07:27.840 --> 00:07:30.830
You've improved every little detail,
or at least enough that

00:07:30.830 --> 00:07:32.300
everything is different.

00:07:32.480 --> 00:07:37.360
What you can do is simply give
it and put it in a new namespace.

00:07:37.360 --> 00:07:41.300
So instead of My Great Library,
you might put it in My Great Library V2.

00:07:41.300 --> 00:07:44.270
This way,
users will be able to use both versions

00:07:44.270 --> 00:07:48.230
of your library simultaneously,
and you can have both versions

00:07:48.230 --> 00:07:51.480
of your library linked into
a program at the same time.

00:07:51.480 --> 00:07:52.480
Everything will just work.

00:07:52.480 --> 00:07:54.790
The two libraries will
be completely separate.

00:07:58.100 --> 00:08:01.060
However,
sometimes you need to be aware of name

00:08:01.060 --> 00:08:03.680
mangling when maintaining a stable ABI.

00:08:03.780 --> 00:08:06.800
For example, suppose you're converting
your program to 64-bit,

00:08:06.800 --> 00:08:10.220
which is something you might want
to consider doing around now.

00:08:10.550 --> 00:08:14.870
You might have found that originally
you'd define some typedefs,

00:08:14.870 --> 00:08:18.610
where previously the typedef was int,
but you've decided you'd really

00:08:18.620 --> 00:08:22.090
like it to be able to use a 64-bit
value here on 64-bit systems.

00:08:22.140 --> 00:08:23.460
Well, that's okay.

00:08:23.460 --> 00:08:24.980
Int and long are the same size, right?

00:08:25.030 --> 00:08:27.170
So you can just switch the
typedef for everything,

00:08:27.170 --> 00:08:28.230
and it'll just work.

00:08:28.260 --> 00:08:31.450
Except,
suppose the user has a function which

00:08:31.450 --> 00:08:34.380
takes one of these types as a parameter.

00:08:34.400 --> 00:08:37.850
In C++,
typedefs don't really define a new type.

00:08:37.850 --> 00:08:40.080
They just give a new name to an old type.

00:08:40.500 --> 00:08:44.460
So this function has changed from
taking an int to taking a long,

00:08:44.460 --> 00:08:47.370
and that means the mangled
names are going to change,

00:08:47.440 --> 00:08:49.140
because the mangled names
include the parameters.

00:08:49.140 --> 00:08:52.640
So here you can see that an i in the
mangled name has turned into an l.

00:08:52.640 --> 00:08:54.740
This will cause the
function to be different,

00:08:54.760 --> 00:08:57.470
and means that if you're hoping
for binary compatibility,

00:08:57.470 --> 00:08:59.080
it's not going to work anymore.

00:08:59.080 --> 00:09:01.500
So you should avoid
doing this in general.

00:09:01.500 --> 00:09:05.230
What you can do if you do need to change
an int to a long is something that

00:09:05.300 --> 00:09:07.540
we've done a lot in the system headers.

00:09:08.170 --> 00:09:11.440
You make an int in 32-bit mode,
and then you use the preprocessor

00:09:11.440 --> 00:09:13.180
to make it long in 64-bit mode.

00:09:13.200 --> 00:09:16.560
You can test, for example,
the LP64 macro to do this.

00:09:19.400 --> 00:09:21.930
Something else that you can do
if you don't want to change the

00:09:21.930 --> 00:09:25.000
namespace of your entire library,
but you've just got a small part of

00:09:25.000 --> 00:09:27.880
it that you've updated or changed,
but the update makes the

00:09:28.060 --> 00:09:32.280
new type incompatible,
is change the name of a structure type.

00:09:32.340 --> 00:09:36.420
For example, if you had my class,
and you've decided to add a new field,

00:09:36.420 --> 00:09:39.580
or do something to it which
would make it incompatible,

00:09:39.580 --> 00:09:41.910
you can change the name of that type.

00:09:42.000 --> 00:09:46.550
Then at least those two won't conflict,
but because of name mangling,

00:09:46.730 --> 00:09:48.660
you get something else free.

00:09:49.400 --> 00:09:53.080
If someone had a function which
took that class as a parameter,

00:09:53.090 --> 00:09:55.480
they can now have two
different functions,

00:09:55.480 --> 00:09:57.630
one for the old version and
one for the new version.

00:09:57.640 --> 00:10:01.040
You can do this in your library,
so that now the two functions

00:10:01.040 --> 00:10:04.110
don't conflict with each other,
and you've managed to

00:10:04.320 --> 00:10:07.580
preserve your ABI because
they have different names now.

00:10:10.860 --> 00:10:14.450
One case where this doesn't work,
unfortunately, is for return types.

00:10:14.510 --> 00:10:18.130
Because C++ doesn't do
overloading on the return type,

00:10:18.250 --> 00:10:20.800
the return type isn't
encoded in the function name.

00:10:20.820 --> 00:10:23.580
So in this case here,
if you've gone from my class

00:10:23.630 --> 00:10:26.470
to an incompatible my class v2,
these functions both

00:10:26.470 --> 00:10:28.910
still have the same name,
because they have the same

00:10:28.910 --> 00:10:30.620
name and the same parameters.

00:10:30.650 --> 00:10:33.120
So now, unfortunately,
doing this will break the ABI,

00:10:33.120 --> 00:10:35.620
and you'll need to work
around any such cases,

00:10:35.690 --> 00:10:38.890
possibly using another of the
techniques I've described.

00:10:40.460 --> 00:10:42.780
So that does us for namespaces
and function overloadings.

00:10:42.780 --> 00:10:45.710
Now we're on to constructors
and destructors.

00:10:54.900 --> 00:11:00.180
A case where you particularly need to
know about how C++ works with respect

00:11:00.180 --> 00:11:04.140
to constructors and destructors is if
you're trying to maintain compatibility

00:11:04.140 --> 00:11:07.450
right the way back to Panther to 10.3.9.

00:11:07.510 --> 00:11:12.110
We made a change in Tiger,
where instead of constructors running

00:11:12.740 --> 00:11:16.900
with the first time a function is
used from your dynamic library,

00:11:16.900 --> 00:11:20.000
now they run at application startup.

00:11:20.010 --> 00:11:23.120
This is definitely an improvement,
because it means they now run at a

00:11:23.120 --> 00:11:26.510
predictable time instead of when the
user just happens to use your library.

00:11:26.580 --> 00:11:29.930
But it's something you need to be aware
of if you're porting code between the

00:11:29.930 --> 00:11:33.810
various versions of the operating system,
that this has now changed.

00:11:33.960 --> 00:11:36.730
Another thing you should be aware
of about constructors is that

00:11:36.730 --> 00:11:39.660
with the new multi-core systems,
you might be deciding

00:11:39.660 --> 00:11:41.950
to use threads more,
or even add threads to a

00:11:41.950 --> 00:11:43.610
program that didn't have them.

00:11:43.710 --> 00:11:46.810
In 10.4 and later,
constructors are thread-safe,

00:11:46.900 --> 00:11:50.430
so they get run at a predictable time,
and in the rare cases where

00:11:50.770 --> 00:11:53.720
they have to get run when a
particular routine is called,

00:11:53.830 --> 00:11:56.300
it's run in a thread-safe
way to guarantee that the

00:11:56.300 --> 00:11:58.660
constructors run exactly once.

00:11:59.480 --> 00:12:02.900
In 10.3.9,
this doesn't happen quite so reliably.

00:12:02.900 --> 00:12:05.260
So this is, again,
something you need to be aware of if

00:12:05.330 --> 00:12:07.020
you're running code way back to 10.3.9.

00:12:10.570 --> 00:12:13.120
For destructors of static variables,
so for example,

00:12:13.190 --> 00:12:17.780
here we have a static variable named
myVariable with a type which has

00:12:17.780 --> 00:12:19.780
a destructor associated with it.

00:12:19.790 --> 00:12:21.900
That's going to get run
on program shutdown,

00:12:21.930 --> 00:12:24.320
basically when you call exit.

00:12:24.350 --> 00:12:27.260
Previously, they were run from the
marco detour section.

00:12:27.260 --> 00:12:30.550
This is in Xcode versions
2.1 and previous,

00:12:30.550 --> 00:12:31.490
I believe.

00:12:31.890 --> 00:12:35.560
In 2.2 and later,
they all get registered to run

00:12:35.560 --> 00:12:37.940
with the add/exit functions.

00:12:38.300 --> 00:12:41.160
Most people will never
notice this change of timing.

00:12:41.250 --> 00:12:44.040
However,
sometimes it does cause problems,

00:12:44.080 --> 00:12:48.440
but we've produced a switch to enable
you to go back to the old behavior.

00:12:48.440 --> 00:12:50.890
So if you're finding that your
destructors are now running in a

00:12:50.890 --> 00:12:54.260
different order than they used to,
and this is causing problems,

00:12:54.260 --> 00:12:59.050
you can simply use the no-use CXA at exit
switch to go back to the old behavior.

00:13:15.560 --> 00:13:19.500
Another case where destructors become
interesting is with exceptions.

00:13:19.580 --> 00:13:24.290
So you'll know that in C++,
if this routine here might throw,

00:13:24.290 --> 00:13:30.320
in this example, throws an exception,
then the local variable called

00:13:30.320 --> 00:13:33.780
myVariable in this well-named example

00:13:34.700 --> 00:13:37.850
has a destructor,
and so the destructor will get executed

00:13:37.850 --> 00:13:40.580
if my throw throws an exception.

00:13:40.930 --> 00:13:43.550
As well as, of course,
the normal running of the

00:13:43.550 --> 00:13:46.910
destructor when the routine exits,
if the routine doesn't

00:13:46.930 --> 00:13:48.790
get to throw an exception.

00:13:49.940 --> 00:13:53.540
So I'll talk more about exception,
about how this works later.

00:13:53.560 --> 00:13:56.710
But something to know about
exception handling is that the

00:13:56.920 --> 00:14:00.720
Objective-C exception handling,
which is new with Leopard,

00:14:00.720 --> 00:14:07.070
and the C++ exception handling use
different underlying mechanisms.

00:14:07.130 --> 00:14:10.990
So if the routine that you're calling
might throw an Objective-C exception

00:14:11.000 --> 00:14:14.490
instead of a C++ exception,
you should know that the

00:14:14.490 --> 00:14:16.070
destructor won't get run.

00:14:16.310 --> 00:14:19.400
One way to deal with this is that
whenever you transition between

00:14:19.690 --> 00:14:24.960
C++ code that might throw C++
exceptions and Objective-C code,

00:14:25.210 --> 00:14:30.590
Then what you're going to want
to do is catch your C++ exception

00:14:30.600 --> 00:14:34.920
or Objective-C exception and
re-throw it as the other kind.

00:14:39.000 --> 00:14:43.200
So that, of course,
takes us to exceptions.

00:14:43.220 --> 00:14:46.050
So here's a simple
example of an exception.

00:14:46.110 --> 00:14:50.280
And you can see that there's some
things that C++ does with exceptions

00:14:50.650 --> 00:14:52.660
that are somewhat complicated.

00:14:52.670 --> 00:14:55.320
C++ exception handling is based on types.

00:14:55.590 --> 00:15:01.540
You throw something of a particular type,
and then you catch some things.

00:15:01.580 --> 00:15:05.740
Hopefully, one of the things you're
catching matches that type.

00:15:05.830 --> 00:15:08.880
There's also an independent part.

00:15:09.700 --> 00:15:14.680
So the language-specific exception
handling lives in the C++ runtime.

00:15:14.780 --> 00:15:18.590
It determines which catch clauses
actually catch which exceptions.

00:15:18.770 --> 00:15:21.610
There's also generic
stack unwinding code,

00:15:21.610 --> 00:15:24.860
which can be used in
it from any language.

00:15:24.890 --> 00:15:27.940
You can't catch exceptions
that have a different language.

00:15:27.940 --> 00:15:30.650
So you can't catch C++ exceptions in C.

00:15:30.740 --> 00:15:33.560
But you can unwind
through a C stack frame.

00:15:33.580 --> 00:15:38.300
You can also use the cleanup attribute,
the last bullet point here,

00:15:38.310 --> 00:15:41.860
to enable you to run
basically a destructor from C.

00:15:41.870 --> 00:15:45.160
So if your C routine is
calling a C++ routine,

00:15:45.190 --> 00:15:48.150
and might need to, for instance,
deallocate memory or

00:15:48.150 --> 00:15:52.450
release a file descriptor,
you can use a cleanup routine to do this.

00:16:05.490 --> 00:16:07.480
If you're trying to
maintain a stable ABI,

00:16:07.480 --> 00:16:10.960
which is a theme we'll come back
to in this presentation many times,

00:16:11.920 --> 00:16:16.980
And you have a C++ shared
library that throws exceptions.

00:16:18.120 --> 00:16:21.060
Then, first of all,
you need to realize that the exceptions

00:16:21.110 --> 00:16:25.230
that you throw are as much a part of your
ABI as the functions that you declare

00:16:25.310 --> 00:16:27.270
or the structures that you return.

00:16:27.370 --> 00:16:31.250
So it's important to keep this
stable if you expect your callers

00:16:31.300 --> 00:16:33.580
to be catching these exceptions.

00:16:34.020 --> 00:16:36.980
Something that helps with this
is that if you have routines that

00:16:36.980 --> 00:16:40.040
don't throw exceptions at all,
you can use throw clauses

00:16:40.040 --> 00:16:41.960
on them to declare this.

00:16:41.960 --> 00:16:44.570
This will help the user who
might be reading your header,

00:16:44.570 --> 00:16:46.410
so it helps with the documentation.

00:16:46.420 --> 00:16:50.020
The compiler can occasionally
warn you about this,

00:16:50.020 --> 00:16:53.500
about incompatibilities,
if you're definitely throwing

00:16:53.500 --> 00:16:55.950
something from a routine that
isn't supposed to throw at all.

00:16:55.980 --> 00:16:58.530
And this also helps a
lot with code quality.

00:16:59.160 --> 00:17:01.970
If the compiler sees that a
routine can't throw an exception,

00:17:01.970 --> 00:17:04.760
it doesn't have to generate
code to run the destructors,

00:17:04.760 --> 00:17:06.080
as you saw in the previous examples.

00:17:06.080 --> 00:17:10.300
So this can save a reasonable
amount in code size.

00:17:10.300 --> 00:17:13.700
And you can see an example
here of how to add a throw

00:17:13.700 --> 00:17:16.220
attribute to your declaration.

00:17:21.020 --> 00:17:22.820
So that does this with exceptions.

00:17:22.820 --> 00:17:26.260
Now we'll move on to inlining.

00:17:26.280 --> 00:17:31.820
So you're probably thinking, well,
every language has inlining, right?

00:17:31.820 --> 00:17:34.250
I mean,
I can declare an inline function in C.

00:17:34.340 --> 00:17:35.740
And this is very true.

00:17:35.820 --> 00:17:42.140
However,
C++ has one feature which makes its

00:17:42.140 --> 00:17:42.140
version of inlining really quite unique.

00:17:42.370 --> 00:17:44.840
For example, consider this function here.

00:17:44.860 --> 00:17:48.590
You'll notice this function declares
a static variable called myVariable,

00:17:48.590 --> 00:17:52.470
which it then uses to
count something or other.

00:17:56.110 --> 00:18:00.900
A unique thing about C++ is
that if this function is,

00:18:00.900 --> 00:18:03.520
say, in a header,
maybe included into many

00:18:03.520 --> 00:18:07.630
different translation units,
there are two things

00:18:07.660 --> 00:18:08.760
that are really neat.

00:18:08.840 --> 00:18:12.780
First of all, you don't have to tell the
compiler one place where the

00:18:12.780 --> 00:18:15.800
variable is really defined.

00:18:15.820 --> 00:18:19.050
Secondly, all the addresses of the
function are the same,

00:18:19.100 --> 00:18:19.300
too.

00:18:19.300 --> 00:18:22.090
So you can take the function's address,
and it's everywhere.

00:18:22.150 --> 00:18:25.310
But you haven't had to tell the compiler,
"You've got to output one

00:18:25.330 --> 00:18:27.450
copy of this function here."

00:18:28.530 --> 00:18:31.060
So if you think about
how this is implemented,

00:18:31.110 --> 00:18:34.760
it's kind of neat inside,
because the compiler doesn't know

00:18:34.760 --> 00:18:38.580
that at any one point it has to have
the one true copy of the function.

00:18:38.640 --> 00:18:45.010
And the same is true with the variable.

00:18:46.710 --> 00:18:51.880
So there are a variety of ways that
the system has dealt with this.

00:18:52.170 --> 00:18:57.530
On some systems, like on Windows and
with GCC 3.3 on Mac OS,

00:18:57.620 --> 00:19:00.980
C++ is basically local
to one dynamic library.

00:19:01.040 --> 00:19:04.500
So you get one copy of the static
variable per dynamic library,

00:19:04.500 --> 00:19:07.340
unless you've somehow told the
system to do something different.

00:19:07.500 --> 00:19:12.250
On Windows, you have export decorations
that you can use to do this.

00:19:14.880 --> 00:19:18.820
And we've kind of emulated
that mode in GCC 4.0 with the

00:19:18.820 --> 00:19:21.130
visibility MS compat flag.

00:19:21.220 --> 00:19:23.840
But what we really think
is the right way to do it,

00:19:23.840 --> 00:19:27.590
and it's done on Linux and
on Mac OS X with GCC 4.0,

00:19:27.790 --> 00:19:30.220
is full C++ support
across dynamic libraries.

00:19:30.220 --> 00:19:33.180
So you don't have to worry
about explicitly telling the

00:19:33.180 --> 00:19:36.740
compiler to export anything,
or telling the compiler where

00:19:36.740 --> 00:19:38.580
the one true copy should go.

00:19:38.580 --> 00:19:41.570
The system just deals with it for you.

00:19:45.130 --> 00:19:48.590
So I'll tell you about how
this works under the hood.

00:19:48.720 --> 00:19:52.720
Suppose you've got an application,
and it's used the very inline function

00:19:52.720 --> 00:19:54.280
that we were talking about before.

00:19:54.320 --> 00:19:59.280
So it's used my variable,
and it's done this in a header file.

00:19:59.280 --> 00:20:02.590
So what happens is this.

00:20:03.020 --> 00:20:06.210
GCC 4.0 will output a copy
of the variable everywhere

00:20:06.350 --> 00:20:07.960
it thinks it might need one.

00:20:08.120 --> 00:20:10.350
So in this example,
you have an executable that's

00:20:10.360 --> 00:20:11.660
made up of two .o files.

00:20:11.740 --> 00:20:14.370
You get two copies of the variable,
one in each .o file.

00:20:15.200 --> 00:20:16.960
Normally,
if you tried to link an app like this,

00:20:17.100 --> 00:20:17.920
you'd get a link error.

00:20:17.950 --> 00:20:21.000
It would say,
"My variable is declared twice."

00:20:22.310 --> 00:20:27.310
Instead, the compiler marks the variables
as what we call coalesced.

00:20:27.370 --> 00:20:31.560
And what this means to the linker
is that one of these two copies

00:20:31.640 --> 00:20:33.000
of the variable should win.

00:20:33.170 --> 00:20:35.680
It should get into the final executable.

00:20:35.750 --> 00:20:38.940
One copy will be ignored,
and all references to it will go

00:20:38.940 --> 00:20:41.840
to the copy that was actually used.

00:20:41.910 --> 00:20:44.960
So you'll end up with one copy of
the variable in the executable.

00:20:44.990 --> 00:20:47.560
The same applies to the
actual function itself.

00:20:47.600 --> 00:20:52.190
If an out-of-line copy was generated,
you'll get one copy.

00:20:53.000 --> 00:20:59.000
So that works for executables and
that works on most operating systems.

00:20:59.000 --> 00:21:02.000
The static linker understands how
to reduce these down to one copy.

00:21:02.000 --> 00:21:04.750
On Darwin, in addition,
if you have a copy of the

00:21:04.750 --> 00:21:08.000
variable in a shared library,
the same thing happens.

00:21:08.000 --> 00:21:12.210
So the loader, DYLD,
will ignore the copy of the variable

00:21:12.290 --> 00:21:16.990
in the shared library and use
only the copy in the executable.

00:21:19.690 --> 00:21:21.840
So this has some important consequences.

00:21:21.840 --> 00:21:24.640
So first of all,
if you've got slightly different copies

00:21:24.640 --> 00:21:27.160
of these inline functions running around,
perhaps because you have a

00:21:27.160 --> 00:21:30.240
version 1 and a version 2,
and you fixed a bug in version 2,

00:21:30.250 --> 00:21:33.020
that change won't take
effect everywhere at once.

00:21:33.020 --> 00:21:36.180
In particular, if you've changed the copy
in the shared library because

00:21:36.180 --> 00:21:38.160
you've written a new version,
but you still have old

00:21:38.290 --> 00:21:41.000
executables running around,
it's quite likely that the

00:21:41.090 --> 00:21:43.880
copy in the executable will be
the one that's actually used.

00:21:43.900 --> 00:21:46.920
So the change you made won't
take effect everywhere at once.

00:21:46.920 --> 00:21:49.560
So you need to be aware of
this and make sure that both

00:21:49.560 --> 00:21:51.600
versions will work together.

00:21:51.620 --> 00:21:55.110
Also, because this is done by name,
right, by mangled name,

00:21:55.210 --> 00:21:57.770
static variables will still be
shared if they have the same name

00:21:57.970 --> 00:21:59.980
and they're in the same function.

00:22:00.720 --> 00:22:03.490
So if you want them to be shared,
make sure they continue

00:22:03.500 --> 00:22:04.520
to have the same name.

00:22:04.540 --> 00:22:07.030
And if you don't, of course,
then you don't.

00:22:08.460 --> 00:22:10.740
Also,
even if you just recompile your program

00:22:10.740 --> 00:22:13.100
with a new version of the compiler,
but you haven't changed

00:22:13.100 --> 00:22:14.790
any part of the sources.

00:22:14.850 --> 00:22:17.900
You'll find that out-of-line copies
of inline functions might appear

00:22:17.900 --> 00:22:21.860
or go away as the compiler decides,
you know, improves its optimization,

00:22:21.860 --> 00:22:24.100
improves its inlining heuristics.

00:22:24.180 --> 00:22:27.910
So the presence or absence of
such a copy of an inline function

00:22:28.310 --> 00:22:34.380
or any other coalesced symbol is
not part of your library's ABI.

00:22:35.500 --> 00:22:38.870
So if you have tools, for example,
that run through your shared library

00:22:39.240 --> 00:22:44.500
and use NM to check to see whether it's
the same ABI as your previous version,

00:22:44.500 --> 00:22:47.590
you should make sure that
these tools know not to worry

00:22:47.660 --> 00:22:49.380
about any coalesced symbol.

00:22:52.250 --> 00:22:55.740
There's also a performance
thing to worry about.

00:22:55.830 --> 00:23:00.620
So you might remember from that in C++,
any method that is actually

00:23:00.620 --> 00:23:03.240
defined inside a class,
like my method here,

00:23:03.300 --> 00:23:06.980
you can see it's got actual code there,
or not very much, but some.

00:23:07.260 --> 00:23:09.110
All of those variables,
all of those methods are

00:23:09.110 --> 00:23:11.250
actually automatically inline.

00:23:11.330 --> 00:23:14.140
So that means that this
whole machinery gets invoked,

00:23:14.180 --> 00:23:14.330
right?

00:23:14.340 --> 00:23:16.240
It means that when
your program starts up,

00:23:16.290 --> 00:23:20.090
the loader has to collapse all
of these down into a single copy.

00:23:20.860 --> 00:23:24.440
For just methods,
if you're not comparing pointers to them,

00:23:24.440 --> 00:23:27.300
then you probably don't need
any of this behavior to happen,

00:23:27.300 --> 00:23:29.360
and it does have a performance impact.

00:23:29.360 --> 00:23:34.240
So you can use the visibility inline's
hidden flag to get that performance back

00:23:34.240 --> 00:23:38.540
by telling the loader that it doesn't
need to worry about these functions.

00:23:38.590 --> 00:23:41.820
For inline functions which
you've explicitly marked

00:23:41.930 --> 00:23:45.380
inline and aren't methods,
you can do the same thing

00:23:45.380 --> 00:23:47.560
using the hidden attribute.

00:23:47.560 --> 00:23:52.220
This will improve your
application startup time.

00:23:52.240 --> 00:23:56.380
Okay, so from inlining we're
going to go to type linkage.

00:24:05.200 --> 00:24:09.200
App linkage is something that works
quite differently in C++ and C.

00:24:09.270 --> 00:24:13.900
In C, every time you declare a structure,
it's a different structure.

00:24:14.560 --> 00:24:17.540
So if you define it for
two different .o files,

00:24:17.540 --> 00:24:20.500
those structures are really,
they're not the same type.

00:24:20.730 --> 00:24:26.090
This wouldn't be very useful,
but C++ has a feature

00:24:26.140 --> 00:24:29.120
called type compatibility,
where two structures that

00:24:29.120 --> 00:24:30.500
are different get matched up.

00:24:30.500 --> 00:24:33.500
And if they have the same fields in
the same order with the same names,

00:24:33.500 --> 00:24:37.500
and they have the same names,
then they're considered to be compatible.

00:24:37.500 --> 00:24:40.860
And so you can do things like
have a routine that returns them,

00:24:40.860 --> 00:24:42.010
and that's okay.

00:24:42.280 --> 00:24:43.950
This doesn't happen in C++.

00:24:44.260 --> 00:24:47.740
In C++,
types never get matched up like this.

00:24:47.810 --> 00:24:51.470
Two types are either always the
same or they're always different.

00:24:52.300 --> 00:24:57.860
So, they're the same if they have the
same name and they're in the same

00:24:57.860 --> 00:25:02.470
namespace and the hidden visibility
is appropriately compatible.

00:25:03.000 --> 00:25:04.260
So this has some consequences.

00:25:04.330 --> 00:25:06.500
First of all,
C++ says that two definitions of the

00:25:06.500 --> 00:25:09.440
same type have to be written the same,
because unlike in C,

00:25:09.440 --> 00:25:12.750
where they can be matched up,
it just requires you

00:25:12.750 --> 00:25:15.090
to make them the same.

00:25:16.560 --> 00:25:20.240
Another place where this matters is that
in C++ a bunch of things vary depending

00:25:20.240 --> 00:25:22.400
on whether two types are the same or not.

00:25:22.550 --> 00:25:25.950
For example,
earlier I mentioned function overloading,

00:25:25.950 --> 00:25:31.340
and I said that you can have two
functions with different parameter types,

00:25:31.340 --> 00:25:32.900
and then they become different.

00:25:33.010 --> 00:25:37.200
Well, so the way you tell if their types
are different is by seeing if

00:25:37.250 --> 00:25:39.600
their name is different and so on.

00:25:39.690 --> 00:25:43.230
Likewise, when you specialise a template,
the template that you specialise

00:25:43.230 --> 00:25:45.350
depends on what types are involved.

00:25:45.550 --> 00:25:47.840
Earlier I mentioned exception handling.

00:25:47.890 --> 00:25:51.710
I said that when you catch an
exception of a particular type,

00:25:51.710 --> 00:25:55.630
then the way a catch is matched
to the actual exception that

00:25:55.720 --> 00:26:00.520
was thrown varies based on what
type the actual exception was.

00:26:00.650 --> 00:26:03.520
And finally,
you can actually compare types.

00:26:03.710 --> 00:26:08.220
You can simply get their type info
and use the equals equals operator to

00:26:08.320 --> 00:26:10.520
see if two types are the same or not.

00:26:11.990 --> 00:26:14.710
So all of this applies
to classes and enums,

00:26:14.810 --> 00:26:17.060
and to fundamental types,
and to pointers to them,

00:26:17.060 --> 00:26:18.890
and arrays of them,
and that kind of thing.

00:26:19.030 --> 00:26:20.500
Type def names don't count.

00:26:20.610 --> 00:26:23.010
You remember I said earlier,
a type def name is just a

00:26:23.310 --> 00:26:25.010
new name for an old type.

00:26:27.300 --> 00:26:32.270
So this is actually a real thing, right,
as opposed to just a language idea.

00:26:32.370 --> 00:26:36.240
There's a real data structure for
each type called the type info.

00:26:36.260 --> 00:26:40.980
And two types are the same based
on identity of the data structure.

00:26:41.180 --> 00:26:45.400
So the compiler and the runtime uses
address equality to compare them.

00:26:45.610 --> 00:26:49.820
The two types are the same if their
type info has the same address.

00:26:50.510 --> 00:26:53.860
So in order to make this work,
because you can declare a type in a

00:26:53.860 --> 00:26:57.590
shared library and then have the same
type again in an application and so on,

00:26:57.730 --> 00:27:00.870
coalescing is used to combine
all of these type info data

00:27:01.280 --> 00:27:05.340
structures down to just one copy
for the one copy for the type.

00:27:07.650 --> 00:27:11.120
So again,
this has some consequences if you have

00:27:11.120 --> 00:27:16.330
shared libraries and you're worried about
what your ABI for those libraries is.

00:27:16.390 --> 00:27:19.190
In C++,
your types are part of your interface.

00:27:19.350 --> 00:27:22.530
So first of all,
if you're using visibility attributes,

00:27:22.690 --> 00:27:24.360
you want to make sure
that you mark your types,

00:27:24.360 --> 00:27:26.080
visible or hidden,
according to whether you

00:27:26.080 --> 00:27:28.250
expected it to be visible or not.

00:27:28.400 --> 00:27:32.400
If you're using export lists,
then you mark the type info entry

00:27:32.400 --> 00:27:35.780
as visible because the type info
entry is what represents the type.

00:27:37.510 --> 00:27:41.090
However, the compiler isn't guaranteed to
generate a type info entry for every

00:27:41.130 --> 00:27:42.720
type that you just happened to mention.

00:27:42.780 --> 00:27:45.350
It'll only generate it if it needs it.

00:27:46.200 --> 00:27:49.190
So if it doesn't generate it,
you want to make sure that you don't

00:27:49.190 --> 00:27:50.440
mention it in your export list.

00:27:50.440 --> 00:27:55.860
Or you can just use the
pragmas or the attributes.

00:27:58.630 --> 00:28:00.260
So that was types.

00:28:00.300 --> 00:28:03.840
So another thing that C++ has
that I'm sure every C++ programmer

00:28:03.840 --> 00:28:06.340
knows is virtual functions.

00:28:06.610 --> 00:28:11.280
So a virtual function works like this.

00:28:11.290 --> 00:28:16.640
Normally, if you have a class and a
subclass and they have a method,

00:28:16.970 --> 00:28:20.590
If you call the method,
the method gets called based

00:28:20.590 --> 00:28:23.740
on what the compiler thinks
the type is at the moment.

00:28:23.910 --> 00:28:27.070
However,
if you have pointers and you want to

00:28:27.070 --> 00:28:31.320
make sure that the method that's called
is the method of the most derived type,

00:28:31.320 --> 00:28:37.070
you can just mark them as virtual
and the method will be called.

00:28:37.430 --> 00:28:39.560
So as in this example here.

00:28:39.620 --> 00:28:43.860
Well, so how does this work underneath?

00:28:43.860 --> 00:28:43.860
Well,

00:28:44.110 --> 00:28:45.990
Sometimes the compiler knows, right?

00:28:46.050 --> 00:28:47.840
If you have a static variable
of a particular type,

00:28:47.840 --> 00:28:50.570
the compiler can tell what
the most derived type is,

00:28:50.610 --> 00:28:52.760
and it just knows which one,
and it can work out which

00:28:52.760 --> 00:28:54.200
function to call directly.

00:28:54.330 --> 00:28:57.640
When the underlying type is uncertain,
like in the previous example where

00:28:57.640 --> 00:29:00.710
we were calling through a pointer,
virtual function calls are made

00:29:00.710 --> 00:29:02.020
through procedure pointers.

00:29:02.280 --> 00:29:06.080
The procedure pointers are stored
in a virtual function table,

00:29:06.200 --> 00:29:10.540
and each instance of the class,
the first word of the instance is a

00:29:10.550 --> 00:29:13.820
pointer to the virtual function table.

00:29:14.460 --> 00:29:17.630
If you make a subclass,
the subclass's Vtable contains

00:29:17.690 --> 00:29:19.520
the Vtables of its parents.

00:29:19.520 --> 00:29:23.250
So in the diagram here you can
see that in my subclass that

00:29:23.310 --> 00:29:26.500
contains the Vtable for my class,
but there's still only one pointer,

00:29:26.500 --> 00:29:30.420
so you only pay four or eight
bytes in every instance of your

00:29:30.570 --> 00:29:32.760
class to use virtual functions.

00:29:35.920 --> 00:29:41.080
So, then you have the question of, well,
where does this Vtable get output?

00:29:41.900 --> 00:29:45.730
So if the compiler can't work out any
one place that it should be output,

00:29:45.760 --> 00:29:50.480
it just outputs it everywhere and uses
coalescing as in the previous examples.

00:29:50.500 --> 00:29:54.790
But the compiler has an optimization to
avoid having to do this all the time.

00:29:55.170 --> 00:29:58.200
If there is a virtual method which
is not declared as inline in the

00:29:58.200 --> 00:30:02.700
class and is not pure virtual,
then the first of those virtual

00:30:02.700 --> 00:30:04.640
methods is called the key method.

00:30:04.820 --> 00:30:09.000
And the Vtable gets output in the same
place as the key method is defined.

00:30:09.010 --> 00:30:11.670
And we know there's only one
place because it wasn't inline,

00:30:11.670 --> 00:30:16.920
so you can only define it
in one file in your program.

00:30:17.660 --> 00:30:23.920
So, sometimes this causes a slightly less
than optimal error message to appear.

00:30:23.970 --> 00:30:27.640
If you get a link error saying
that the Vtable is undefined,

00:30:27.770 --> 00:30:30.570
then what that usually really
means is not that the compiler

00:30:30.570 --> 00:30:33.610
has decided not to output it,
but that the compiler was

00:30:33.610 --> 00:30:36.480
waiting to see the key method,
and it never did.

00:30:36.550 --> 00:30:40.830
So usually that means that the key method
is the thing that's really undefined.

00:30:52.490 --> 00:30:55.350
So again, of course,
virtual functions have an impact

00:30:55.540 --> 00:30:59.480
on the binary compatibility
of your shared library.

00:30:59.710 --> 00:31:03.080
First of all,
you'll remember in the previous diagram,

00:31:03.430 --> 00:31:10.280
that the subclass Vtable contains
the Vtable for its parent.

00:31:10.310 --> 00:31:13.240
Well, so that means if you add
something to its parent,

00:31:13.290 --> 00:31:14.840
it's not going to fit anymore.

00:31:14.900 --> 00:31:19.010
So one thing you typically can't
do to maintain ABI stability is

00:31:19.010 --> 00:31:23.070
adding to the list of virtual
functions or deleting something

00:31:23.150 --> 00:31:25.280
from it or randomly changing it.

00:31:25.620 --> 00:31:28.450
By comparison, you can add to the list
of non-virtual functions,

00:31:28.450 --> 00:31:30.900
and that's okay,
because that's just like adding

00:31:30.910 --> 00:31:32.700
a new routine to your library.

00:31:33.930 --> 00:31:37.010
If you're using an export
list to control visibility,

00:31:37.200 --> 00:31:40.320
then you need to make sure that
the Vtable symbols are visible

00:31:40.320 --> 00:31:43.890
if your class has a key method,
because users of your library

00:31:43.930 --> 00:31:46.950
will be expecting to use
that one copy of the Vtable.

00:31:47.400 --> 00:31:50.860
You'll also need to make sure that
the functions mentioned in the Vtable,

00:31:50.890 --> 00:31:54.800
so any virtual functions in your library,
are also visible.

00:31:54.810 --> 00:31:57.300
Because remember,
a subclass has to create this

00:31:57.300 --> 00:32:00.880
new Vtable that contains your
previous Vtable at the top.

00:32:00.910 --> 00:32:06.310
So it's going to have to reference
any virtual functions that

00:32:06.310 --> 00:32:09.280
were defined in your library.

00:32:09.380 --> 00:32:11.600
If you're using pragmas or
attributes to control visibility,

00:32:11.600 --> 00:32:15.100
then by default the compiler will
set everything up so that this works.

00:32:15.250 --> 00:32:18.440
You can still override the
compiler if you're really sure

00:32:18.480 --> 00:32:20.110
that's what you want to do.

00:32:22.530 --> 00:32:25.780
So that was virtual functions.

00:32:25.790 --> 00:32:28.220
We're still going to be talking
about virtual functions for a bit,

00:32:28.220 --> 00:32:29.810
but now we're going to talk
about the more complicated

00:32:29.830 --> 00:32:34.210
case of multiple inheritance,
where a class has more than one parent.

00:32:34.700 --> 00:32:38.030
So in this example here you can see
that my subclass has two parents,

00:32:38.130 --> 00:32:44.550
my class and my class two,
and they both have a field in them.

00:32:44.550 --> 00:32:44.550
Now,

00:32:47.220 --> 00:32:51.700
Now, normally if you're using
single inheritance,

00:32:51.820 --> 00:32:52.880
life is very simple.

00:32:52.880 --> 00:32:56.900
A pointer to a subclass is also
a pointer to the parent class,

00:32:56.900 --> 00:32:59.830
because the parent class goes at the top.

00:33:00.290 --> 00:33:02.470
If you have two parent classes,
obviously this can't work.

00:33:02.520 --> 00:33:04.600
They can't both be on top.

00:33:04.670 --> 00:33:11.710
So what happens is they simply get
queued up at the top of the class.

00:33:11.940 --> 00:33:14.980
But this means some things
won't work quite so well.

00:33:15.150 --> 00:33:19.300
For example, suppose the second class,
the one that didn't get to be on top,

00:33:19.350 --> 00:33:21.330
has a virtual method.

00:33:21.360 --> 00:33:27.950
It's expecting to be called
with a pointer to a MyClass2.

00:33:28.220 --> 00:33:31.670
But a pointer to the subclass
is a pointer to a myClass,

00:33:31.780 --> 00:33:33.950
not a myClass2.

00:33:34.210 --> 00:33:37.120
So a small routine is created
to adjust the pointer.

00:33:37.140 --> 00:33:44.210
It actually subtracts the appropriate
amount from the pointer to adjust the

00:33:44.300 --> 00:33:47.860
pointer so that the virtual function
gets the pointer that it's expecting.

00:33:47.960 --> 00:33:51.370
And there are a few other cases where
similar little routines are generated.

00:33:51.470 --> 00:33:53.750
Now these routines are pretty small,
they're only like four instructions

00:33:53.750 --> 00:33:56.540
or five instructions long,
because all they have to do is adjust

00:33:56.580 --> 00:33:58.260
a pointer and then make a call.

00:33:58.330 --> 00:34:01.290
But unfortunately you still
have to worry about them.

00:34:01.490 --> 00:34:04.840
If you're using an export list,
then you need to make sure that the

00:34:04.840 --> 00:34:08.900
thunk symbols are visible if the
subclass is part of your interface.

00:34:09.090 --> 00:34:13.230
And you need to be aware that the mangled
names of these functions encode the size

00:34:13.230 --> 00:34:16.850
of the offset that's added or subtracted,
and that might vary

00:34:16.850 --> 00:34:20.340
between 64-bit and 32-bit,
for example.

00:34:20.700 --> 00:34:25.830
So you'll want to have a different
export list for each architecture.

00:34:25.890 --> 00:34:28.580
If you're using pragmas or
attributes to control visibility,

00:34:28.630 --> 00:34:32.500
because you don't have to
deal with mangled names,

00:34:32.500 --> 00:34:34.970
the compiler will deal with this for you.

00:34:46.590 --> 00:34:48.750
The other thing that's
different about C++,

00:34:48.750 --> 00:34:52.190
and a fairly substantial feature in it,
is templates.

00:34:53.210 --> 00:34:57.390
So templates, to some degree,
are not terribly interesting

00:34:57.470 --> 00:35:00.700
for ABI because they're just
macros and they just expand.

00:35:00.960 --> 00:35:07.450
Unfortunately, C++ has this thing called
implicit template instantiation,

00:35:07.460 --> 00:35:10.150
so you don't have to tell
the compiler in advance what

00:35:10.180 --> 00:35:11.660
templates you're going to use.

00:35:11.660 --> 00:35:13.790
You can just decide to use them.

00:35:13.810 --> 00:35:17.370
For example, here we've defined a
variable called myVector,

00:35:17.370 --> 00:35:19.200
which is a vector of floats.

00:35:19.200 --> 00:35:23.170
And the system may not ever have
heard of a vector of floats before.

00:35:23.380 --> 00:35:27.100
And this might not be the only
place where it's mentioned.

00:35:27.100 --> 00:35:30.090
So templates are another place
where coalescing is used to collapse

00:35:30.140 --> 00:35:34.170
all the various instantiations
of the template down into just one.

00:35:36.710 --> 00:35:40.920
Now, there are some things
to be careful of here.

00:35:41.080 --> 00:35:43.800
For example,
you should follow the C++ rules about

00:35:43.810 --> 00:35:45.240
templates from the standard library.

00:35:45.280 --> 00:35:47.440
And the rule I'm particularly
thinking of is the one that

00:35:47.440 --> 00:35:51.830
says that you're not allowed to
specialise it on standard types.

00:35:51.970 --> 00:35:56.300
For example, don't try to specialise
a vector of float.

00:35:56.350 --> 00:36:00.300
The reason for this is that
because coalescing works across

00:36:00.300 --> 00:36:02.070
the entire process space,

00:36:02.690 --> 00:36:07.060
This system might, as it turns out,
be using a vector of floats.

00:36:07.130 --> 00:36:09.800
If you specialize it
and change the behavior,

00:36:09.800 --> 00:36:11.640
the system's going to get
your changed behavior,

00:36:11.760 --> 00:36:14.300
which it probably wasn't expecting.

00:36:14.870 --> 00:36:17.700
Instead,
what you can do is define a subclass.

00:36:17.760 --> 00:36:23.610
So you simply subclass a vector
of float and override whatever

00:36:23.650 --> 00:36:25.140
routines you don't like.

00:36:25.290 --> 00:36:29.690
Another alternative is to simply
include a vector of float in your

00:36:29.690 --> 00:36:33.510
class and then write and have
your class be a wrapper around it.

00:36:36.300 --> 00:36:41.800
So you can specialise vectors
for on your own classes.

00:36:42.020 --> 00:36:45.570
You can also instantiate them
of course on your own classes,

00:36:45.570 --> 00:36:47.770
otherwise they wouldn't
be terribly useful.

00:36:48.130 --> 00:36:50.910
To avoid having conflicts,
because as you can see

00:36:50.910 --> 00:36:54.590
in the example here,
we've instantiated a vector of my class.

00:36:54.730 --> 00:36:58.650
Well, someone else in your application
or someone else in the system

00:36:58.940 --> 00:37:02.500
might have decided that my
class is a good class name too.

00:37:02.520 --> 00:37:05.430
In which case, the two my classes are
going to be different.

00:37:05.640 --> 00:37:06.640
They would conflict.

00:37:06.700 --> 00:37:09.340
The vector instantiations will conflict.

00:37:09.460 --> 00:37:13.540
So to avoid this happening,
it's good to keep your own

00:37:13.560 --> 00:37:16.000
classes in your own namespace.

00:37:16.780 --> 00:37:23.860
If you have a shared library and
it has a template in its header

00:37:23.860 --> 00:37:27.840
files and you need to change that
to upgrade to the next version,

00:37:27.840 --> 00:37:31.350
you should remember that
because coalescing is used,

00:37:31.560 --> 00:37:34.290
just like for inline functions,
your clients may have their

00:37:34.290 --> 00:37:37.350
own instantiations of this,
which will not automatically change just

00:37:37.350 --> 00:37:39.140
because you've changed your header file.

00:37:39.140 --> 00:37:40.190
They might need to recompile.

00:37:41.190 --> 00:37:43.800
So if you're making an
incompatible change to a template,

00:37:43.870 --> 00:37:47.860
you need to place the updated
templates in a different namespace.

00:37:48.880 --> 00:37:52.080
One performance issue,
which also helps with ABIs,

00:37:52.190 --> 00:37:55.390
is that you can prevent the
compiler from using coalescing,

00:37:55.550 --> 00:37:58.610
generating a new copy of the
template in every .o file and so on.

00:37:58.820 --> 00:38:03.890
You can use the external template
functionality to tell the compiler,

00:38:03.890 --> 00:38:06.800
"I've already explicitly
instantiated this template somewhere.

00:38:06.800 --> 00:38:09.610
Please don't make a new copy
of it everywhere." This reduces

00:38:09.610 --> 00:38:13.800
your code size and dramatically
reduces the size of your .o files.

00:38:13.800 --> 00:38:17.790
It also has ABI benefits because now you
know where the copy of the template is.

00:38:17.800 --> 00:38:20.800
You can change it and know
that it's been changed.

00:38:22.560 --> 00:38:26.710
So I do strongly recommend using extern
template in a shared library that is

00:38:26.710 --> 00:38:28.340
expected to be exporting templates.

00:38:31.000 --> 00:38:36.270
So another feature in C++ that is
sort of available in C but not quite

00:38:36.790 --> 00:38:40.600
is that you can override the standard
allocation and deallocation mechanisms,

00:38:40.610 --> 00:38:42.640
new and delete in C++.

00:38:42.710 --> 00:38:47.950
In C, this is like overriding mallocan,
this is like replacing mallocan free.

00:38:49.900 --> 00:38:52.580
So, I won't go into all the
details of how to do it,

00:38:52.620 --> 00:38:56.210
but there is a code sample
available on the WWDC website,

00:38:56.210 --> 00:38:59.960
and the C++ standard has
extensive rules about what these

00:39:00.410 --> 00:39:02.870
new routines can and can't do.

00:39:02.950 --> 00:39:06.730
Please do follow the rules
for a very important reason.

00:39:07.080 --> 00:39:09.460
Because of inlining,
it's not recommended that you

00:39:09.460 --> 00:39:12.100
try and override new and delete
for just a single shared object,

00:39:12.220 --> 00:39:14.770
right, for a single application,
and try and leave the

00:39:14.770 --> 00:39:16.000
rest of the system intact.

00:39:16.150 --> 00:39:20.270
Because what will happen is that
parts of the system C++ library might

00:39:20.270 --> 00:39:23.600
be inlined into your application,
they'll use your version,

00:39:23.690 --> 00:39:26.440
and other parts might not be inlined,
and they won't.

00:39:26.540 --> 00:39:29.870
So you'll be having memory allocated
with your version that's being trained

00:39:29.870 --> 00:39:32.500
to deallocate with the system version,
or vice versa.

00:39:32.500 --> 00:39:35.090
And this is not likely to end up well.

00:39:35.750 --> 00:39:39.450
So we recommend that you do just
bite the bullet and overwrite new

00:39:39.450 --> 00:39:41.530
and delete for the whole system.

00:39:41.750 --> 00:39:46.690
But this does mean that the system will
use your versions of new and delete.

00:39:46.770 --> 00:39:51.380
The system might even use it before
all of your constructors have been run,

00:39:51.380 --> 00:39:52.270
for example.

00:39:53.500 --> 00:39:55.640
No system library will ever
override new or delete,

00:39:55.640 --> 00:39:57.360
so you know that your
application can do it.

00:39:57.400 --> 00:40:01.300
And we recommend that
you follow the same rule,

00:40:01.340 --> 00:40:03.760
that is that libraries that
you write and give to others

00:40:04.180 --> 00:40:07.050
shouldn't override new or delete,
unless they're supposed to

00:40:07.050 --> 00:40:09.440
be overriding new or delete,
because that's what

00:40:09.490 --> 00:40:10.920
they're intended to do.

00:40:13.900 --> 00:40:16.920
So that was kind of a lot of stuff.

00:40:16.960 --> 00:40:20.720
I have some rules here which,
even if you forget the rest of the talk,

00:40:20.740 --> 00:40:21.920
might help.

00:40:22.300 --> 00:40:27.520
So the first thing to remember
as a nice general rule is you

00:40:27.520 --> 00:40:30.170
should write an unusual app.

00:40:30.700 --> 00:40:34.600
Your app should be different
and special in some way.

00:40:34.600 --> 00:40:38.700
But this doesn't mean that you have
to write your app in an unusual way.

00:40:38.910 --> 00:40:40.530
What it does should be
different and special.

00:40:40.860 --> 00:40:47.360
The way it's written, if at all possible,
should be just like everybody else.

00:40:47.360 --> 00:40:47.360
As much as is possible.

00:40:48.200 --> 00:40:51.690
Part of this is that if the
system provides a functionality,

00:40:51.690 --> 00:40:54.830
it's really better to use that
rather than inventing your own.

00:40:54.990 --> 00:40:57.380
For example,
use vector of float rather than

00:40:57.390 --> 00:41:01.000
writing your own thing which
contains a list of floats.

00:41:01.100 --> 00:41:04.260
The advantage of that is that we
can improve the one in the system,

00:41:04.260 --> 00:41:08.230
maybe by adding vectorization to it,
whereas we can't go into your

00:41:08.300 --> 00:41:10.270
application and change it.

00:41:11.500 --> 00:41:15.560
You should know and be aware of
the standards because the compiler

00:41:15.560 --> 00:41:21.160
specification is that it tries to
compile standard C and standard C++.

00:41:21.270 --> 00:41:23.640
And it's good to read
the documentation too.

00:41:23.640 --> 00:41:26.140
Often documentation has
critical warnings about things.

00:41:26.370 --> 00:41:29.320
For example,
much of what's in here is available

00:41:29.540 --> 00:41:31.490
somewhere in documentation.

00:41:33.010 --> 00:41:37.800
Okay, and for more information,
we have Matthew Formica, who is our

00:41:37.800 --> 00:41:41.360
Developer Tools Software Evangelist,
and whose email address is printed

00:41:41.400 --> 00:41:43.360
in very small print on the screen.

00:41:43.730 --> 00:41:49.380
But you can also go to the WWDC website,
which by now I hope you've all found,

00:41:49.520 --> 00:41:51.520
to find the sample code
I mentioned earlier,

00:41:52.140 --> 00:41:55.420
important documentation
about how the C++ ABI works,

00:41:55.540 --> 00:41:57.990
and all kinds of other neat stuff.

00:41:58.390 --> 00:42:01.150
and we're going to have
Q&A in a few minutes,

00:42:01.150 --> 00:42:03.260
but if your questions
don't get answered there,

00:42:03.260 --> 00:42:07.300
you can come to the Development Tools and
Universal Binaries Lab in Lab B,

00:42:07.490 --> 00:42:12.360
which is right next to Lab A,
that way at 3:30.
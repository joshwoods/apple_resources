WEBVTT

00:00:10.230 --> 00:00:12.100
Welcome to the 64-bit Overview session.

00:00:12.100 --> 00:00:13.320
My name is Ali Ozer.

00:00:13.490 --> 00:00:16.060
I'm the manager of the
Cocoa Frameworks team.

00:00:16.180 --> 00:00:22.450
I've also been coordinating the 64-bit
effort across Leopard for the past year,

00:00:22.620 --> 00:00:25.130
and that's why I'm speaking to you today.

00:00:25.890 --> 00:00:27.900
Okay, so today's talk,
we're first going to

00:00:27.910 --> 00:00:29.820
cover what 64-bit is,
then we're going to look

00:00:29.890 --> 00:00:33.090
at the 64-bit landscape,
we're going to talk about

00:00:33.090 --> 00:00:36.080
what 64-bit means to you,
then we're going to talk a bit about

00:00:36.080 --> 00:00:39.800
the porting and pitfalls that you
might encounter during the porting,

00:00:39.840 --> 00:00:43.140
and have some closing
thoughts at the end.

00:00:43.500 --> 00:00:45.400
So what is 64-bit?

00:00:45.400 --> 00:00:48.880
64-bit is support for
64-bit address space.

00:00:48.900 --> 00:00:51.390
That's the most basic definition.

00:00:51.600 --> 00:00:56.380
32-bit can support 4 gigabytes,
which is about 4 billion bytes of course,

00:00:56.440 --> 00:01:01.510
while 64-bit extends that to 16 exabytes,
which is 16 billion billion bytes,

00:01:01.510 --> 00:01:03.080
or 16 quintillion.

00:01:03.460 --> 00:01:06.700
Now,
the important thing about 64-bit support

00:01:06.800 --> 00:01:10.460
is that it's concurrent use of 64-bit.

00:01:10.460 --> 00:01:14.060
There are already some 32-bit
applications out there,

00:01:14.060 --> 00:01:17.480
such as iMovie, Final Cut Pro,
database programs,

00:01:17.480 --> 00:01:20.920
etc., that let you manage
more than 4 gigabytes of data.

00:01:21.240 --> 00:01:23.040
However,
the way they do that is by loading

00:01:23.040 --> 00:01:26.420
those files into memory in chunks,
and they sort of do their

00:01:26.420 --> 00:01:29.580
own paging if needed,
and they never load more than 4

00:01:29.580 --> 00:01:31.550
gigabytes into memory at once.

00:01:31.600 --> 00:01:35.630
With 64-bit support,
you get concurrent access to potentially

00:01:35.630 --> 00:01:38.280
64-bit's worth of address space.

00:01:38.330 --> 00:01:42.020
Now let me give you sort of
a scale of what 64-bit means.

00:01:42.060 --> 00:01:44.330
Now 4 billion 32-bit is
a pretty large number.

00:01:44.340 --> 00:01:46.340
If you started counting
to 4 billion today,

00:01:46.340 --> 00:01:50.000
it would take you about
200 years to get there.

00:01:50.000 --> 00:01:52.060
On the other hand,
4 billion is not really

00:01:52.310 --> 00:01:54.280
such a big number.

00:01:54.280 --> 00:01:56.860
It is not enough to represent
the world population.

00:01:56.920 --> 00:01:59.010
It's not big enough to represent the U.S.

00:01:59.050 --> 00:01:59.340
debt.

00:01:59.420 --> 00:02:02.480
It's not big enough to
even represent the U.S.

00:02:02.480 --> 00:02:02.480
deficit.

00:02:02.480 --> 00:02:06.420
It's not big enough to
represent Bill Gates's fortune.

00:02:06.420 --> 00:02:07.960
On good days,
it's not enough to represent

00:02:08.010 --> 00:02:09.020
Steve Jobs's fortune.

00:02:09.020 --> 00:02:13.660
And it's not enough to represent the
number of pages indexed by Google or the

00:02:13.660 --> 00:02:15.720
number of hamburgers sold by McDonald's.

00:02:15.720 --> 00:02:20.640
So really, 32-bit is very inadequate,
in fact, for many purposes.

00:02:20.640 --> 00:02:24.250
On the other hand, 64-bit is huge.

00:02:24.340 --> 00:02:26.720
If you started counting
to 16 quintillion,

00:02:26.720 --> 00:02:29.570
and let's say you started
the day the universe started,

00:02:29.570 --> 00:02:33.600
which was about 14 billion years ago,
you'd only be about 1.5%

00:02:33.600 --> 00:02:34.960
of the way there today.

00:02:34.960 --> 00:02:36.130
So it's a pretty big number.

00:02:38.860 --> 00:02:41.860
Okay, so let's talk about the
data type changes in 64-bit.

00:02:41.860 --> 00:02:46.200
Since it's a 64-bit address space,
and since you have concurrent

00:02:46.200 --> 00:02:50.690
access to this address space,
pointers go from 32 to 64 bits.

00:02:50.740 --> 00:02:54.230
In addition, the long data type goes
from 32 to 64 bits,

00:02:54.230 --> 00:02:56.700
and all other data types remain the same.

00:02:56.700 --> 00:03:00.530
And that's why this is referred
to as the LP64 model - longs

00:03:00.530 --> 00:03:02.700
and pointers go to 64-bit.

00:03:02.700 --> 00:03:06.340
Now the interesting thing about
the LP64 model is it is the

00:03:06.340 --> 00:03:09.580
model that other Unixes use,
so therefore it is compatible

00:03:09.580 --> 00:03:12.670
with a lot of open source software
that you will find out there,

00:03:12.760 --> 00:03:14.980
which of course is a good thing.

00:03:15.720 --> 00:03:18.730
And here is a chart of
the data type changes.

00:03:18.860 --> 00:03:23.070
In ILP32, which is where we are today,
integers, longs, and pointers are 32-bit.

00:03:23.240 --> 00:03:24.790
These are the data types.

00:03:24.790 --> 00:03:28.200
And in the LP64 world,
they all remain the same size,

00:03:28.200 --> 00:03:33.500
except long goes to 8 bytes and
pointer goes to 8 bytes as well.

00:03:33.540 --> 00:03:37.430
Now one interesting thing to note
here is I said other Unixes are LP64,

00:03:37.460 --> 00:03:41.040
but Windows in the 64-bit world is LLP64.

00:03:41.370 --> 00:03:46.110
What that means is Windows programs under
64-bit have longs which are 32-bits,

00:03:46.200 --> 00:03:48.270
but long longs which are 64-bits.

00:03:48.480 --> 00:03:52.620
So if you have part of your source
space which is cross-platform that

00:03:52.620 --> 00:03:55.740
needs to go in Windows as well,
that's something to keep in mind.

00:03:55.740 --> 00:03:59.310
You might want to avoid the
long data type in those cases.

00:04:00.980 --> 00:04:06.150
So given that a pointer is 64-bit,
that sort of implies that the

00:04:06.270 --> 00:04:11.280
process is either 32-bit or 64-bit,
but it cannot be both.

00:04:11.310 --> 00:04:15.840
There is no notion of mixed mode
where a 64-bit process can load

00:04:16.270 --> 00:04:19.800
32-bit plugins or libraries.

00:04:19.800 --> 00:04:24.760
So this means all libraries, frameworks,
plugins needed for your application

00:04:24.760 --> 00:04:29.250
have to be 64-bit for your
application to run as 64-bit.

00:04:30.380 --> 00:04:33.800
So here's the way the world looked
about a year and a half ago.

00:04:33.800 --> 00:04:34.920
It was nice and simple.

00:04:34.920 --> 00:04:38.640
We had PowerPC, text-edit, 32-bit,
and it in turn depended

00:04:38.640 --> 00:04:41.920
on a 32-bit PowerPC,
Cocoa, and that depended on

00:04:41.920 --> 00:04:44.960
application services,
core services, lib system,

00:04:44.960 --> 00:04:47.780
down what we refer to
as the framework stack.

00:04:47.780 --> 00:04:52.180
And everything was 32-bit PowerPC,
and that's all we had.

00:04:52.180 --> 00:04:55.540
Now with 64-bit,
you basically have another

00:04:55.540 --> 00:04:57.820
parallel stack of frameworks.

00:04:57.820 --> 00:05:00.740
And the 64-bit text-edit,
to run a 64-bit text-edit,

00:05:00.810 --> 00:05:03.720
you need a 64-bit Cocoa,
which needs application services,

00:05:03.720 --> 00:05:05.860
core services, lib system, etc.

00:05:05.860 --> 00:05:08.870
And this is very similar really to
the way we did the Intel transition

00:05:08.870 --> 00:05:10.490
when we introduced it a year ago.

00:05:10.820 --> 00:05:14.060
32-bit Intel text-edit
requires a 32-bit Intel Cocoa,

00:05:14.280 --> 00:05:15.510
and so on down the stack.

00:05:15.570 --> 00:05:18.440
They all have to be built
for that architecture.

00:05:18.440 --> 00:05:23.020
And of course, yesterday we introduced
64-bit Intel as well,

00:05:23.020 --> 00:05:25.540
and that's also yet another stack.

00:05:25.540 --> 00:05:26.600
Now of course,
the interesting thing to know

00:05:26.600 --> 00:05:29.270
that is although these are
all separate architectures,

00:05:29.270 --> 00:05:33.560
they are all bundled together in
the universal packaging format.

00:05:33.560 --> 00:05:37.090
So it is actually one binary that
contains four separate architectures.

00:05:39.600 --> 00:05:41.740
Now, so let me give you a
perspective on what we're doing.

00:05:41.910 --> 00:05:44.900
The 64-bit effort requires
that all libraries,

00:05:45.180 --> 00:05:45.990
frameworks, etc.

00:05:46.040 --> 00:05:47.540
be available as 64-bit.

00:05:47.860 --> 00:05:53.380
In that way, it's sort of similar to the
widening of the Panama Canal.

00:05:53.550 --> 00:05:55.790
Panama Canal used to be,
when it was first built,

00:05:55.880 --> 00:05:59.090
it was wide enough for most ships,
or all ships of today,

00:05:59.110 --> 00:06:01.820
but these days it no longer is
wide enough for the large super

00:06:01.900 --> 00:06:03.500
tankers or the larger cargo ships.

00:06:03.500 --> 00:06:07.500
And there is an effort, or a desire,
to get the Panama Canal widened.

00:06:07.630 --> 00:06:10.340
Now one interesting thing about this
effort is that it's not an effort

00:06:10.420 --> 00:06:14.480
you can do 95%. Because if you did,
this is what it would look like.

00:06:14.540 --> 00:06:17.500
And that big ship would get through
most of the canal and still get stuck.

00:06:17.500 --> 00:06:21.060
So really, the effort,
doing something like the Panama Canal,

00:06:21.060 --> 00:06:24.110
requires that you do
the job 100%. Similarly,

00:06:24.250 --> 00:06:27.500
if you're an application
that wants to run a 64-bit,

00:06:27.500 --> 00:06:30.460
you need to make sure everything you
depend on is available to you as 64-bit.

00:06:30.500 --> 00:06:34.330
If only 95% of the things are available,
your application will not be able to run.

00:06:34.500 --> 00:06:36.500
So, and that's, you know,
that's what you need.

00:06:36.500 --> 00:06:38.500
So that's, you know,
that's sort of a cheerful realization.

00:06:38.500 --> 00:06:41.570
So let's think about why we're doing,
why we're doing all this,

00:06:41.570 --> 00:06:43.500
why we're going to all this effort.

00:06:43.500 --> 00:06:46.680
Why 64-bit?

00:06:47.320 --> 00:06:49.460
Now one reason is developers.

00:06:49.460 --> 00:06:53.500
There are certain developers,
certain applications where you're

00:06:53.500 --> 00:06:56.510
already running into limits of
32-bit and telling us about it.

00:06:56.570 --> 00:06:59.800
You have applications that really
are pushing the limits of 32-bit

00:06:59.800 --> 00:07:02.910
and you know you need 64-bit to
get those applications running.

00:07:03.080 --> 00:07:05.590
Similarly,
users are also telling us the same thing.

00:07:05.610 --> 00:07:09.340
They hear from developers that there
are certain applications which really

00:07:09.340 --> 00:07:12.190
need more than 32-bit to be effective.

00:07:12.810 --> 00:07:14.990
Another reason for doing
64-bit is competition.

00:07:15.050 --> 00:07:18.470
Microsoft already has 64-bit
version of Windows XP out,

00:07:18.480 --> 00:07:21.350
and there is 64-bit version
of Vista on the horizon.

00:07:21.430 --> 00:07:24.710
So this is something which again
developers and users point to

00:07:24.780 --> 00:07:27.610
as something that they need
to have on Mac OS X as well.

00:07:28.370 --> 00:07:32.680
Hardware is another very
important reason for doing 64-bit.

00:07:32.680 --> 00:07:35.300
We already have 64-bit
capable hardware out there.

00:07:35.610 --> 00:07:39.300
64-bit chips are available,
and on this hardware,

00:07:39.300 --> 00:07:43.020
like especially Intel 64,
there is more registers

00:07:43.060 --> 00:07:45.300
available in 64-bit,
there are wider registers,

00:07:45.710 --> 00:07:50.460
there is the instruction
relative addressing mode,

00:07:50.510 --> 00:07:53.290
which actually helps out.

00:07:53.290 --> 00:07:56.300
So therefore, there are some hardware
benefits to running in 64-bit.

00:07:56.300 --> 00:07:59.500
Not to mention the fact that you
can put up to 8 or 16 gigabytes

00:07:59.510 --> 00:08:01.300
of memory into these machines.

00:08:01.300 --> 00:08:05.760
So really having an application
which can access just the piddly 4

00:08:05.760 --> 00:08:09.290
gigabytes on your 16-gigabyte hardware,
that seems pretty limiting.

00:08:09.390 --> 00:08:11.290
So today's hardware is
already pushing the limits,

00:08:11.290 --> 00:08:14.300
so the software has to
catch up in some way.

00:08:15.500 --> 00:09:37.900
[Transcript missing]

00:09:38.890 --> 00:09:40.460
So let's look at the 64-bit landscape.

00:09:40.520 --> 00:09:45.390
Let's look at where we are and
where others are in 64-bit.

00:09:45.770 --> 00:09:48.580
Now in Tiger,
only libsystem and accelerated

00:09:48.580 --> 00:09:52.720
frameworks are available,
and it's only C and C++.

00:09:52.720 --> 00:09:55.230
We don't have support for Objective-C,
and we don't have support

00:09:55.360 --> 00:09:56.600
for Java in Tiger.

00:09:56.600 --> 00:09:59.240
So what this means is in
Tiger you don't have Carbon,

00:09:59.240 --> 00:10:01.600
you don't have Cocoa,
you don't have Quartz,

00:10:01.600 --> 00:10:04.600
you don't have core services,
you don't have core foundation.

00:10:04.600 --> 00:10:08.600
So a lot of the user interface
level functionality is missing.

00:10:08.610 --> 00:10:13.590
So this is useful for command line tools,
but really no GUI applications.

00:10:13.650 --> 00:10:15.870
And we recommend that to
create a GUI application

00:10:15.970 --> 00:10:19.730
you create a 64-bit backend,
and you create a 32-bit frontend,

00:10:19.760 --> 00:10:22.600
and you basically communicate using IPC.

00:10:22.600 --> 00:10:25.600
And that's what Mathematica,
for instance, has done.

00:10:25.600 --> 00:10:27.590
That's how Mathematica
works in the 64-bit mode.

00:10:27.600 --> 00:10:32.440
It's got a 32-bit frontend
with a 64-bit backend.

00:10:33.960 --> 00:10:36.300
Now in Leopard, of course,
we're enabling any Cocoa or

00:10:36.300 --> 00:10:39.090
Carbon application to run as 64-bit.

00:10:39.090 --> 00:10:40.720
And this also includes Java.

00:10:40.790 --> 00:10:45.480
However, we're making Java available
only for Intel 64-bit.

00:10:46.380 --> 00:10:49.630
Now let me talk about what
Microsoft has done with Windows.

00:10:49.630 --> 00:10:55.700
Its 64-bit version of Windows XP,
which is known as XP x64,

00:10:55.700 --> 00:10:59.280
was released more than a year ago,
in April of last year.

00:10:59.320 --> 00:11:01.300
And it's really marketed
at advanced users.

00:11:01.300 --> 00:11:04.140
It's not something you can
go easily get at your local

00:11:04.140 --> 00:11:06.300
Costco and install on your machine.

00:11:06.300 --> 00:11:08.300
You have to jump through a few hoops.

00:11:08.300 --> 00:11:13.050
But it's not been wildly successful,
and that's according to Microsoft.

00:11:13.300 --> 00:11:16.300
One of the reasons for this is
there are compatibility issues.

00:11:16.300 --> 00:11:20.270
64-bit Windows require 64-bit drivers,
which originally were

00:11:20.270 --> 00:11:22.630
a very small number,
and since then there's

00:11:22.630 --> 00:11:24.180
been new ones introduced.

00:11:24.300 --> 00:11:27.530
16-bit DOS and Windows applications
are unsupported,

00:11:27.530 --> 00:11:30.300
and also some 32-bit
applications don't work.

00:11:30.510 --> 00:11:35.270
Because really, under 64-bit Windows,
32-bit applications are

00:11:35.400 --> 00:11:37.300
running under this WOW64.

00:11:37.300 --> 00:11:39.340
So,
it's a Windows on Windows 64 environment,

00:11:39.340 --> 00:11:41.300
which Microsoft used
the term emulation for.

00:11:41.300 --> 00:11:44.450
And, you know,
that's good enough for many, many apps,

00:11:44.530 --> 00:11:45.290
but not all.

00:11:45.340 --> 00:11:49.300
So some 32-bit applications
do not work under XP x64.

00:11:50.920 --> 00:11:53.870
And this is a quote from Paul Thoreau
of Supersight for Windows,

00:11:53.870 --> 00:11:54.830
a recent quote.

00:11:54.830 --> 00:11:57.960
And you know, he said,
"XP-X64 is doomed to failure

00:11:57.960 --> 00:12:01.000
because of hardware and software
incompatibilities." And truth is,

00:12:01.000 --> 00:12:05.550
I don't think Microsoft really
also put a lot behind this product.

00:12:05.740 --> 00:12:10.840
For Microsoft, their intent is to make
64-bit mainstream with Vista.

00:12:10.840 --> 00:12:13.100
And that's where they're
really looking forward to,

00:12:13.120 --> 00:12:13.880
it seems like.

00:12:13.960 --> 00:12:17.500
In Vista,
64-bit is not a separate product.

00:12:17.660 --> 00:12:20.800
However, it is still a separate DVD.

00:12:20.930 --> 00:12:22.800
And I think that's the way
it's going to be shipping.

00:12:22.800 --> 00:12:26.100
Most editions of Vista will
come with 64-bit version and

00:12:26.130 --> 00:12:27.800
32-bit version in the box.

00:12:27.800 --> 00:12:31.780
And at the time you install,
you choose which one you want to install.

00:12:31.810 --> 00:12:32.790
So the user has to make a choice.

00:12:32.820 --> 00:12:34.740
Am I installing 32 or 64?

00:12:34.800 --> 00:12:37.610
And from what I understand,
it will have some of the same sort

00:12:37.630 --> 00:12:39.740
of compatibility issues as XP-X64.

00:12:39.840 --> 00:12:42.080
And of course,
also some benefits as well that

00:12:42.080 --> 00:12:43.770
64-bit brings to the environment.

00:12:43.800 --> 00:12:45.800
Now let's compare that to Leopard.

00:12:45.800 --> 00:12:47.800
In Leopard, it's a single install.

00:12:47.800 --> 00:12:53.800
You know, you buy your Mac OS ...and
you install Leopard.

00:12:53.940 --> 00:12:57.800
And it's 64-bit capable,
assuming your hardware is 64-bit capable.

00:12:58.200 --> 00:13:00.800
32-bit and 64-bit applications coexist.

00:13:00.820 --> 00:13:03.760
That's because I showed you, you know,
each application runs

00:13:03.760 --> 00:13:04.800
in its own framework.

00:13:04.800 --> 00:13:05.800
It uses its own binary.

00:13:05.800 --> 00:13:08.670
So there's no emulation or
anything like that going on here.

00:13:08.800 --> 00:13:11.960
A 32-bit application runs
fully well on a 64-bit machine,

00:13:11.960 --> 00:13:14.800
and so will a 64-bit application.

00:13:14.820 --> 00:13:16.790
So it's full compatibility.

00:13:16.800 --> 00:13:21.510
So the good thing here is that... ...the
user's choice for 64-bit is whether they

00:13:21.570 --> 00:13:23.800
bought a 64-bit capable machine or not.

00:13:23.800 --> 00:13:25.840
And, you know,
you as the developer decide

00:13:25.960 --> 00:13:27.800
whether 64-bit is right for you.

00:13:27.800 --> 00:13:31.840
But even when you ship a 32-bit app,
you know, there's not this danger that,

00:13:31.910 --> 00:13:35.780
"Oh, because the user installed 64-bit,
my app won't run." So we believe,

00:13:35.780 --> 00:13:40.800
you know, this gives you somewhat more
of a choice in choosing 64-bit.

00:13:40.800 --> 00:13:43.800
So, okay, the OS has 64-bit.

00:13:43.800 --> 00:13:46.690
What does this mean for you?

00:13:47.830 --> 00:13:54.160
Okay, so there are a number of
considerations for moving to 64-bit.

00:13:54.160 --> 00:13:57.720
And most of them are performance related,
because 64-bit is really touted

00:13:57.840 --> 00:13:59.800
for performance most of the time.

00:13:59.800 --> 00:14:03.580
Now, if your application needs
large address space,

00:14:03.830 --> 00:14:05.710
the answer is a definite yes.

00:14:05.800 --> 00:14:08.580
I mean,
this is the example we saw with the

00:14:08.590 --> 00:14:11.020
DNA demo Simon showed yesterday.

00:14:11.020 --> 00:14:12.800
Simon Patience showed it.

00:14:12.800 --> 00:14:15.930
I don't know if you saw it,
but basically a 32-bit version took

00:14:15.930 --> 00:14:19.510
many minutes to go through the frames,
because it had to load a 4-gigabyte

00:14:19.510 --> 00:14:23.070
file in chunks and process it,
while the 64-bit version could

00:14:23.150 --> 00:14:25.340
load the whole 4-gigabyte file
and just run through it and

00:14:25.470 --> 00:14:26.800
generate a frame every second.

00:14:26.800 --> 00:14:30.800
I mean, there are the orders of magnitude
faster for the 64-bit case.

00:14:30.800 --> 00:14:31.790
And there are many
applications like this,

00:14:31.840 --> 00:14:35.800
so if you have one of those applications,
the answer is yes.

00:14:35.800 --> 00:14:37.670
64-bit is definitely for you.

00:14:37.800 --> 00:14:39.800
Now, how about others?

00:14:39.800 --> 00:14:41.790
So there are a few other
performance considerations.

00:14:41.800 --> 00:14:46.800
One is that when you're
running in 64-bit mode,

00:14:46.800 --> 00:14:50.660
your pointers are larger,
some of your data types are larger,

00:14:50.840 --> 00:14:51.800
so you're going to be
using a little more memory.

00:14:51.800 --> 00:14:54.770
But you know,
it's probably not that much more.

00:14:54.820 --> 00:14:58.800
In reality, most of the memory used by
applications tend to be in

00:14:58.800 --> 00:15:01.790
window backing stores and images,
which don't change size.

00:15:01.800 --> 00:15:04.800
So this additional memory
impact isn't that bad.

00:15:04.800 --> 00:15:06.800
On the other hand,
there's performance benefits.

00:15:06.800 --> 00:15:09.390
As I mentioned earlier,
there are hardware benefits

00:15:09.510 --> 00:15:10.800
to running in 64-bit.

00:15:10.800 --> 00:15:15.800
On Intel, you get more registers,
there are wider registers,

00:15:15.800 --> 00:15:20.800
you get addressing mode.

00:15:20.850 --> 00:15:25.840
So with those, compute-bound,
CPU-bound applications can actually get

00:15:25.840 --> 00:15:28.800
a good boost from running in 64-bit.

00:15:28.800 --> 00:15:31.890
So if your application is very
much compute-bound and you're

00:15:31.890 --> 00:15:35.790
really interested in getting every
percentage of CPU out of the machine,

00:15:35.930 --> 00:15:37.710
64-bit might be interesting
for you as well,

00:15:37.870 --> 00:15:39.800
although you might not
be handling lots of data.

00:15:39.800 --> 00:15:46.800
One other consideration is the overall
memory impact of 64-bit to the system.

00:15:46.800 --> 00:15:49.800
Now let's look at the earlier
framework stack we had.

00:15:49.800 --> 00:15:52.800
You have the stack of 32-bit frameworks.

00:15:52.800 --> 00:15:56.380
Now when you run 32-bit text edit,
it pulls in the 32-bit

00:15:56.380 --> 00:15:57.800
stack of frameworks.

00:15:57.800 --> 00:16:00.800
When you go ahead and run another
32-bit application like Safari,

00:16:00.800 --> 00:16:02.780
it also uses the same frameworks.

00:16:02.860 --> 00:16:06.030
Of course, it might use some other
frameworks as well,

00:16:06.080 --> 00:16:08.720
but the basic system
ones are the same ones.

00:16:08.800 --> 00:16:12.890
So 32-bit mail and 32-bit iChat and
all other 32-bit applications all

00:16:12.890 --> 00:16:14.800
use the same stack of frameworks.

00:16:14.800 --> 00:16:17.800
Now let's assume you ran 64-bit chess.

00:16:17.800 --> 00:16:21.800
And by the way, chess on your system is
actually 64-bit today.

00:16:21.800 --> 00:16:23.770
Of course, it's also 32-bit and that's
why it runs on your laptops,

00:16:23.840 --> 00:16:27.800
but if you run it on a 64-bit machine,
it will run as a 64-bit application.

00:16:27.880 --> 00:16:32.340
So when you run 64-bit chess,
it pulls in the 64-bit architectures

00:16:32.400 --> 00:16:34.800
from each one of those frameworks.

00:16:35.090 --> 00:16:37.800
So clearly, there is a little bit of an
additional memory over time.

00:16:37.800 --> 00:16:39.800
So there is an additional
memory overhead here.

00:16:39.830 --> 00:16:42.250
And so therefore,
64-bit in a very low memory machine

00:16:42.250 --> 00:16:43.700
will cause some memory pressure.

00:16:43.800 --> 00:16:46.780
So that's yet another
consideration to keep in mind.

00:16:48.100 --> 00:16:52.280
So with those in mind,
our answer is that in Leopard,

00:16:52.330 --> 00:16:56.160
if your application is not
going to benefit from 64-bit,

00:16:56.160 --> 00:17:00.000
it's probably not a good
idea to move to 64-bit.

00:17:00.510 --> 00:17:04.000
However, post-Leopard,
the answer changes.

00:17:04.040 --> 00:17:06.970
And we believe the answer is, yeah,
likely someday.

00:17:07.000 --> 00:17:11.120
We don't believe that 64-bit is going
to remain a niche for specialized

00:17:11.120 --> 00:17:13.000
applications going forward.

00:17:13.000 --> 00:17:15.440
At some point, we believe,
most applications will

00:17:15.440 --> 00:17:16.890
probably become 64-bit.

00:17:17.070 --> 00:17:20.210
It's almost like today,
you do not see 16-bit

00:17:20.210 --> 00:17:22.000
applications anywhere,
really.

00:17:22.000 --> 00:17:25.340
They're really part of the history,
because the systems are optimized

00:17:25.340 --> 00:17:27.000
for running 32-bit applications.

00:17:27.200 --> 00:17:30.000
And that's probably going to be the case.

00:17:30.000 --> 00:17:32.930
Five, ten years from now,
do you want to be the only 32-bit app

00:17:33.000 --> 00:17:35.000
in a block of 64-bit applications?

00:17:35.000 --> 00:17:37.000
That might be the scenario.

00:17:37.000 --> 00:17:39.270
Now we don't have a crystal ball,
we don't know what date this is, so on,

00:17:39.270 --> 00:17:42.000
so it's hard to tell,
but we believe this is the case.

00:17:42.000 --> 00:17:46.000
Now, if you have a framework, a library,
or a plugin, and especially if you

00:17:46.000 --> 00:17:49.000
have a public framework,
or a public library, public plugin,

00:17:49.000 --> 00:17:53.000
like a plugin that goes into, say,
WebKit or some other plugin mechanism,

00:17:53.000 --> 00:17:57.060
we really do want you to move
to 64-bit as soon as possible,

00:17:57.130 --> 00:18:00.530
because by making your product,
your framework, library, or plugin,

00:18:00.570 --> 00:18:03.050
available as 64-bit,
you'll be enabling others who might be

00:18:03.190 --> 00:18:06.000
thinking of moving to 64-bit themselves.

00:18:06.000 --> 00:18:09.960
So, just like we're making the system
libraries available as 64-bit,

00:18:10.060 --> 00:18:13.630
we'd ask you to consider
doing the same thing as well.

00:18:14.240 --> 00:18:17.480
Now let's talk about
levels of 64-bitness.

00:18:17.480 --> 00:18:22.090
This is like the levels you attain as
you go through the conversion process.

00:18:22.230 --> 00:18:25.010
The very first level
is the 64-bit wannabes.

00:18:25.010 --> 00:18:29.100
And these are who can build
their applications as 64-bit.

00:18:29.190 --> 00:18:30.940
What this means is you
open up your project,

00:18:31.040 --> 00:18:33.220
you check that checkbox,
and you deal with the

00:18:33.220 --> 00:18:35.350
warnings and the errors,
and eventually your

00:18:35.350 --> 00:18:37.100
project builds as 64-bit.

00:18:37.140 --> 00:18:40.100
Congratulations,
you're now a 64-bit wannabe.

00:18:40.100 --> 00:18:43.080
Of course,
that's not where you really wanna be.

00:18:43.350 --> 00:18:46.090
The next level is the 64-bit novice.

00:18:46.090 --> 00:18:49.070
And that's when you can actually
run your application as 64-bit,

00:18:49.160 --> 00:18:51.100
which might require some debugging.

00:18:51.110 --> 00:18:53.240
Now, believe me,
it's a real thrill to have your

00:18:53.240 --> 00:18:55.080
application come up as 64-bit.

00:18:55.140 --> 00:18:58.180
It's probably the same as the
thrill you get when you ran it,

00:18:58.260 --> 00:19:01.950
and you hopefully did,
as running your application on Intel.

00:19:02.100 --> 00:19:04.100
You have just conquered
a brand new architecture.

00:19:04.110 --> 00:19:05.090
Congratulations.

00:19:05.100 --> 00:19:09.100
But again,
novice is not where you wanna be either.

00:19:09.100 --> 00:19:12.100
You wanna go to a few
more levels above this.

00:19:12.100 --> 00:19:15.090
There's a 64-bit apprentice.

00:19:15.320 --> 00:19:18.100
Here, not only does your
application run under 64-bit,

00:19:18.100 --> 00:19:21.090
it can run with addresses
above 4 gigabytes.

00:19:21.100 --> 00:19:23.980
Now, why is this interesting?

00:19:24.160 --> 00:19:28.350
One of the most common errors that
you'll see in 64-bit applications

00:19:28.850 --> 00:19:32.780
is truncation of addresses,
where somebody will take an address,

00:19:32.850 --> 00:19:36.820
put it into a 32-bit quantity,
and then extract it.

00:19:36.910 --> 00:19:39.440
Now clearly if the address
is below 4 gigabytes,

00:19:39.490 --> 00:19:40.360
that will work.

00:19:40.440 --> 00:19:43.460
But once you start managing
addresses above 4 gigabytes,

00:19:43.460 --> 00:19:47.940
that will start to truncate addresses
and causing your app to crash.

00:19:48.040 --> 00:19:52.340
So therefore this might be a harder
level to attain than just novice.

00:19:52.480 --> 00:19:54.940
Now the good news is

00:19:55.600 --> 00:20:00.940
When you build your application for 10.5,
at least on Intel 64,

00:20:00.940 --> 00:20:04.980
we build with certain options that
make your application run with

00:20:05.300 --> 00:20:08.080
addresses above 4 GB out of the gate.

00:20:08.080 --> 00:20:10.090
So therefore by the time
your application runs,

00:20:10.110 --> 00:20:11.620
it's already an apprentice.

00:20:11.620 --> 00:20:14.530
On PowerPC the situation is
a little more complicated,

00:20:14.530 --> 00:20:17.860
and I think we'll go into it
in tomorrow's in-depth talk.

00:20:17.860 --> 00:20:20.820
But again,
a 10.5 built app will have most

00:20:20.830 --> 00:20:22.830
of the addresses above 4 GB.

00:20:22.830 --> 00:20:24.990
And once you get your
application running,

00:20:25.040 --> 00:20:26.150
it will be an apprentice.

00:20:26.290 --> 00:20:27.670
But for instance,
if you had a Tiger-based

00:20:27.740 --> 00:20:30.210
64-bit command line tool,
and you run it on Leopard,

00:20:30.210 --> 00:20:33.270
it's not yet an apprentice because it
doesn't have these options enabled.

00:20:33.290 --> 00:20:37.420
Now apprentice is not really
where you want to be either.

00:20:37.420 --> 00:20:40.540
You really want to be the 64-bit master.

00:20:40.540 --> 00:20:44.880
I mean, probably the important reason you
went to 64-bit is that you want

00:20:44.880 --> 00:20:46.340
to handle large amounts of data.

00:20:46.340 --> 00:20:50.160
And you've proven yourself a
master of 64-bit which can actually

00:20:50.250 --> 00:20:52.300
manage more than 4 GB of data.

00:20:52.300 --> 00:20:53.700
So why is this hard to achieve?

00:20:53.960 --> 00:20:56.650
Well, maybe not hard,
but why might it involve difficulties?

00:20:56.680 --> 00:21:00.220
I don't want to discourage anybody here.

00:21:00.230 --> 00:21:05.020
Types like int, Sint32, uint32t,
et cetera, these are all 32 bits.

00:21:05.020 --> 00:21:08.280
And they're 32 bits even
in a 64-bit environment.

00:21:08.300 --> 00:21:13.320
If your application still uses these
types and uses APIs with those types,

00:21:13.650 --> 00:21:16.910
you will only be managing
up to 4 GB of data.

00:21:16.920 --> 00:21:20.910
So really to make your
application fully 64-bit capable,

00:21:20.910 --> 00:21:25.410
you need to switch those ints to longs,
switch them to 64-bit capable types,

00:21:25.410 --> 00:21:27.710
and where necessary,
move to APIs that enable

00:21:27.760 --> 00:21:30.290
64-bit management of data.

00:21:30.290 --> 00:21:32.730
And that will make you a master.

00:21:32.730 --> 00:21:37.170
Now master isn't the end of this chain
either because there's one more level.

00:21:37.250 --> 00:21:39.860
And that's when you get
to be 64-bit shippable.

00:21:39.950 --> 00:21:44.260
And that is not only do you do all this,
you can run and you can run about 4 GB,

00:21:44.330 --> 00:21:45.970
but you do it efficiently.

00:21:46.060 --> 00:21:50.680
And the reason I mention this is
64-bit gives you the impression of,

00:21:50.680 --> 00:21:53.390
oh yeah, it's performance nirvana.

00:21:53.400 --> 00:21:55.040
You get there,
you got all the elbow room,

00:21:55.100 --> 00:21:57.680
you can do whatever you want,
allocate memory, just throw it away,

00:21:57.680 --> 00:21:59.520
who cares, a lot of memory.

00:21:59.520 --> 00:22:01.600
And that's not true at all.

00:22:01.600 --> 00:22:05.750
One thing to keep in mind is
not every user who has 64-bit

00:22:06.020 --> 00:22:09.340
machine has 16 GB of memory,
for instance.

00:22:09.380 --> 00:22:14.090
So really, even under 64-bit,
you have to stick to both the tried and

00:22:14.140 --> 00:22:17.400
true performance techniques you have,
and in fact, some others as well,

00:22:17.410 --> 00:22:18.360
as a way to make sure.

00:22:18.360 --> 00:22:23.080
your application is as
efficient as possible.

00:22:23.080 --> 00:22:25.350
So really,
we want you to design those supertankers

00:22:25.360 --> 00:22:28.360
that can go through the Panama Canal,
but we want them to be very efficient,

00:22:28.360 --> 00:22:30.530
0 to 60 in 4 seconds.

00:22:32.220 --> 00:22:35.940
Okay, now there are some additional
framework considerations when

00:22:35.940 --> 00:22:36.900
you're going through this.

00:22:36.900 --> 00:22:38.980
So if you own a framework,

00:22:39.250 --> 00:22:42.260
Now let's remind ourselves,
to be a master, you need to be able to

00:22:42.260 --> 00:22:44.380
handle more than 4GB of data.

00:22:44.430 --> 00:22:47.100
Now if you're a framework or a library,
meaning you have some

00:22:47.190 --> 00:22:51.100
public API other people use,
there are two steps to attaining this.

00:22:51.150 --> 00:22:53.870
And this is true for
the system APIs as well.

00:22:53.960 --> 00:22:58.970
Step one is to make your
API handle 64-bit quantities.

00:22:59.430 --> 00:23:03.160
And step two is to make your
implementation handle 64-bit quantities.

00:23:03.180 --> 00:23:07.100
And you can do these at different times,
and let me talk about that.

00:23:07.910 --> 00:23:11.200
Now as I mentioned earlier,
types such as INT, INT32, etc.

00:23:11.200 --> 00:23:13.530
- these are not 64-bit capable.

00:23:13.530 --> 00:23:18.990
So if you use these types in your APIs,
it cannot express 64-bit quantities.

00:23:20.170 --> 00:23:20.990
Here's an example.

00:23:21.130 --> 00:23:22.280
This is from Core Foundation.

00:23:22.350 --> 00:23:24.910
Core Foundation has a
type called CFIndex.

00:23:24.950 --> 00:23:27.980
And in Tiger,
this is declared to be Sint32,

00:23:28.240 --> 00:23:29.860
which is clearly a 32-bit type.

00:23:30.320 --> 00:23:34.880
And an API such as
CFArrayGetCount returns a CFIndex,

00:23:34.880 --> 00:23:38.960
so therefore it's only capable
of managing 32-bit worth of data.

00:23:39.050 --> 00:23:43.400
And since it's signed,
CFArrayGetCount cannot represent

00:23:43.470 --> 00:23:46.110
more than 2 billion elements.

00:23:46.900 --> 00:23:48.660
So how do you deal with this?

00:23:48.720 --> 00:23:51.500
Well,
one solution is to use 64-bit types:

00:23:51.500 --> 00:23:55.630
Long, SizeT, S-SizeT,
there's a number of them.

00:23:55.700 --> 00:23:58.880
Another solution,
a separate path you can take,

00:23:58.930 --> 00:24:01.600
is to update definitions
of existing type-defs.

00:24:01.750 --> 00:24:05.600
Like CFIndex could be updated,
byte count could be updated, and so on.

00:24:05.600 --> 00:24:08.600
And we've in fact done these
with some of these types.

00:24:08.690 --> 00:24:11.690
And another solution is to just
add new type-defs and start

00:24:11.700 --> 00:24:13.600
using them where appropriate.

00:24:13.600 --> 00:24:14.600
And we've done this in some other cases.

00:24:14.600 --> 00:24:17.590
For instance, we've introduced NSInteger,
PrefCon, and so on.

00:24:17.600 --> 00:24:22.570
With that, our sample,
core foundation CFIndex,

00:24:22.600 --> 00:24:27.810
now is declared to return a long,
and thus CFArrayGetCount is

00:24:28.050 --> 00:24:31.600
now able to represent up to at
least 8 quintillion elements.

00:24:31.600 --> 00:24:34.600
Not 16, but 8,
because of the sign in this.

00:24:34.680 --> 00:24:37.590
Now, one thing that's important is,
as you do this,

00:24:37.600 --> 00:24:41.600
you want to make sure that the
32-bit API remains compatible.

00:24:41.600 --> 00:24:46.560
And here, after making this change,
one thing to notice is that CFIndex

00:24:46.600 --> 00:24:46.600
is still declared to return a long.

00:24:46.630 --> 00:24:47.190
And here, after making this change,
one thing to notice is that CFIndex

00:24:47.230 --> 00:24:47.540
is still declared to return a long.

00:24:47.660 --> 00:24:50.180
declared to be a 32-bit
quantity on 32 bits,

00:24:50.180 --> 00:24:53.540
so therefore it is compatible
in the 32-bit world.

00:24:53.640 --> 00:24:58.440
In fact, Sint32 used to be declared as
long in the 32-bit environment,

00:24:58.440 --> 00:25:03.740
so therefore we have not changed anything
on the 32-bit platform after this change.

00:25:03.740 --> 00:25:06.610
This is important, especially like us.

00:25:06.610 --> 00:25:11.880
You're in a position of providing
binary compatibility release-to-release.

00:25:12.360 --> 00:25:15.180
Okay, so now let me do a quick
case study of Cocoa.

00:25:15.180 --> 00:25:20.980
In Cocoa we solved our problem of getting
to the master level by adding new types,

00:25:21.020 --> 00:25:23.020
NSInteger and NSUInteger.

00:25:23.020 --> 00:25:26.220
And as you might know,
Cocoa used ints and unsigned

00:25:26.220 --> 00:25:30.620
ints in almost all of the API,
and we just replaced all of those

00:25:30.620 --> 00:25:34.320
with NSInteger and NSUInteger.

00:25:34.320 --> 00:25:37.010
And NSInteger and UInteger
are declared like this.

00:25:37.110 --> 00:25:42.300
In LP64, which is how you denote 64-bit,
they're defined to be longs,

00:25:42.520 --> 00:25:45.400
and in 32-bit they're defined to be ints.

00:25:45.400 --> 00:25:47.250
And again, you know,
we have this definition because

00:25:47.250 --> 00:25:51.780
we want to maintain that absolute
binary compatibility in 32-bit.

00:25:51.930 --> 00:25:54.110
And with that,
we've changed the definition

00:25:54.220 --> 00:25:55.800
of the NSRA methods,
for instance,

00:25:55.800 --> 00:25:59.200
for count and objected index
to deal with NSU integers,

00:25:59.350 --> 00:26:01.710
which means they're
now capable of 64-bit.

00:26:01.880 --> 00:26:04.800
Now one thing you might be wondering
is why do this to all the APIs,

00:26:04.800 --> 00:26:09.800
and the reason for that is consistency,
impedance match, and so on.

00:26:09.800 --> 00:26:13.830
Across Cocoa APIs we want consistency,
so even though there are some APIs which

00:26:13.950 --> 00:26:17.720
might not benefit from 64-bit,
just changing all of them introduces

00:26:17.720 --> 00:26:21.680
or preserves that kind of consistency
that Cocoa is well known for.

00:26:21.800 --> 00:26:25.310
So we want to continue that
consistency across API by just

00:26:25.650 --> 00:26:27.790
using the same APIs throughout.

00:26:28.330 --> 00:26:30.760
Another interesting case is Quartz.

00:26:30.870 --> 00:26:33.800
In the Quartz case we
added the CG float type.

00:26:33.800 --> 00:26:41.390
It's a float on 32-bit,
but it's a double on 64-bit.

00:26:41.870 --> 00:26:45.670
This value is used for
graphical quantities,

00:26:45.770 --> 00:26:47.800
coordinates, sizes, etc.

00:26:47.900 --> 00:26:53.980
And using doubles gives us much bigger
range and much better precision.

00:26:53.980 --> 00:26:56.470
We didn't do this
though for LP64 reasons.

00:26:56.470 --> 00:26:59.800
In fact, LP64 doesn't dictate anything
about floating-point types.

00:26:59.820 --> 00:27:01.440
There's no changes.

00:27:01.440 --> 00:27:05.310
But the reason we did this is to take
advantage of this opportunity we have,

00:27:05.310 --> 00:27:07.610
the binary incompatibility opportunity.

00:27:07.650 --> 00:27:10.340
You know, everybody will be rebuilding
their applications,

00:27:10.340 --> 00:27:13.550
so why not introduce this very
forward-looking change so we can

00:27:13.590 --> 00:27:15.680
benefit from this in years to come?

00:27:17.030 --> 00:27:21.480
So all Quartz and Quartz-based
APIs will now be using CG floats

00:27:21.500 --> 00:27:25.190
to represent coordinates,
and they're doubles on 64-bit.

00:27:26.600 --> 00:27:30.180
Here are some examples:
Move to Point takes two CG floats,

00:27:30.180 --> 00:27:33.770
Set Font Size takes a CG float,
CG Color Create,

00:27:33.880 --> 00:27:38.010
which used to take an array of floats,
now takes an array of CG floats.

00:27:39.720 --> 00:27:43.840
OK,
so at this point you might be thinking,

00:27:43.840 --> 00:27:46.060
you know, give me a break.

00:27:46.060 --> 00:27:48.800
Can CFArray really manage
billions of values?

00:27:48.890 --> 00:27:50.880
That doesn't sound realistic at all.

00:27:50.880 --> 00:27:54.660
And the answer is, you know,
even if something doesn't handle

00:27:54.660 --> 00:27:59.020
64 bits behind the scenes,
behind the API today, it might someday,

00:27:59.020 --> 00:28:01.600
you know, someday it will probably do it.

00:28:01.600 --> 00:28:04.540
And the important thing is to get
the API right today because we

00:28:04.540 --> 00:28:06.540
cannot change APIs very easily.

00:28:06.540 --> 00:28:08.190
Every time we change APIs,
we have to go through

00:28:08.250 --> 00:28:09.200
a deprecation process.

00:28:09.200 --> 00:28:10.300
We have to let you all know.

00:28:10.300 --> 00:28:12.320
You all have to get off the old APIs.

00:28:12.330 --> 00:28:15.940
It's a hassle for us, hassle for you,
hassle for our text pubs folks.

00:28:15.940 --> 00:28:18.580
You know, it's a lot of work.

00:28:18.580 --> 00:28:21.280
So it's important to get
the APIs right today.

00:28:21.280 --> 00:28:22.940
The implementation can follow.

00:28:22.940 --> 00:28:26.780
And one other thing to keep in
mind is that APIs like this,

00:28:26.880 --> 00:28:32.180
which are capable of 64-bit,
can enable new approaches.

00:28:32.180 --> 00:28:36.510
For instance, with a CFArray capable of
representing up to 64-bit services.

00:28:36.520 --> 00:28:37.760
It's worth of elements.

00:28:37.760 --> 00:28:40.470
You might even imagine
using sparse arrays.

00:28:40.480 --> 00:28:42.300
So arrays which actually don't have,
you know,

00:28:42.520 --> 00:28:45.050
billions and billions of elements in it,
but which have indexes in the

00:28:45.050 --> 00:28:47.390
billions and billions of range
where the implementation is

00:28:47.390 --> 00:28:48.960
smart enough to deal with that.

00:28:48.960 --> 00:28:52.800
And that could enable you to do,
you know, different things in the future

00:28:52.870 --> 00:28:54.200
using such a data structure.

00:28:57.220 --> 00:28:59.890
Okay,
so let me talk about the porting process

00:29:00.070 --> 00:29:04.490
and go through some of the pitfalls
you might encounter during this.

00:29:05.700 --> 00:29:10.210
So porting to 64-bit could be as simple
as checking that checkbox and going,

00:29:10.210 --> 00:29:12.040
and you know, you can try that.

00:29:12.080 --> 00:29:15.420
If you're a command line type of person,
you can also compile with the

00:29:15.420 --> 00:29:16.760
appropriate architectures.

00:29:16.790 --> 00:29:21.750
You can go ahead and say, you know,
just compile your file with

00:29:21.750 --> 00:29:25.040
-arch ppc64 or -arch x8664.

00:29:25.070 --> 00:29:28.390
Or you can even do Xcode build
from the command line by specifying

00:29:28.400 --> 00:29:30.380
arches with these architectures.

00:29:30.420 --> 00:29:32.730
That's all pretty straightforward.

00:29:34.700 --> 00:29:38.590
Now, some code conversion
will likely be needed.

00:29:38.690 --> 00:29:42.590
64-bit is not necessarily
source compatible with 32-bit.

00:29:42.590 --> 00:29:47.540
There are changes in some of the APIs,
some APIs are not there anymore, so on.

00:29:47.540 --> 00:29:49.200
So you'll get warnings,
you'll get errors,

00:29:49.200 --> 00:29:51.440
and you'll have to deal with those.

00:29:51.440 --> 00:29:55.160
But our intent is that once you've
converted your source base to 64-bit,

00:29:55.160 --> 00:29:59.920
that you can use the same source base to
generate both 32-bit and 64-bit versions

00:29:59.920 --> 00:30:02.600
of your application or or framework,
and so on.

00:30:02.600 --> 00:30:05.250
And that will just give
you one source space.

00:30:06.360 --> 00:30:08.750
Now for Cocoa we have
this conversion script.

00:30:08.940 --> 00:30:14.000
I demoed that earlier in another session,
but it's described pretty completely

00:30:14.000 --> 00:30:17.880
in the Cocoa 64-bit transition guide.

00:30:18.070 --> 00:30:21.840
And basically this conversion script
will take your Cocoa application

00:30:21.840 --> 00:30:25.600
and do a fairly reasonable job of
converting it so it's 64-bit ready.

00:30:25.710 --> 00:30:28.630
And you'll still have to do some
work on it to complete the job.

00:30:28.780 --> 00:30:31.040
But anyway,
it'll get you part of the way there,

00:30:31.040 --> 00:30:34.190
and maybe even 80-90% if you're lucky.

00:30:35.210 --> 00:30:37.750
So, when you port, you know,
you're going to get compiler

00:30:37.750 --> 00:30:38.940
warnings and errors.

00:30:38.940 --> 00:30:43.580
So it's a good idea to build your project
warning-free before you do the port.

00:30:43.670 --> 00:30:47.170
That way you know all the warnings
you're getting are due to 64-bit and not,

00:30:47.170 --> 00:30:49.490
you know, oh, the warning was there,
and so on.

00:30:49.710 --> 00:30:52.900
And sometimes, you know,
the warnings you fix in 32-bit end

00:30:52.900 --> 00:30:55.100
up fixing real crashers in 64-bit.

00:30:55.100 --> 00:30:56.600
So it's a good idea to
pay attention to those.

00:30:56.980 --> 00:31:01.840
There's some additional flags to help
some catching some conversion problems.

00:31:01.900 --> 00:31:04.500
For instance, shorten 64 to 32.

00:31:04.590 --> 00:31:06.180
You can either use it
from the command line,

00:31:06.180 --> 00:31:07.960
or there's a checkbox in Xcode for this.

00:31:08.100 --> 00:31:11.090
This will tell you potentially
any place where you're truncating

00:31:11.090 --> 00:31:12.920
a 64-bit prompt to the 32-bit.

00:31:13.310 --> 00:31:16.100
Unfortunately,
this can be a little too noisy.

00:31:16.100 --> 00:31:18.100
You'll get warnings where
you really didn't want to.

00:31:18.100 --> 00:31:20.380
However,
it might still be a good idea to turn

00:31:20.380 --> 00:31:24.100
it on at some phase during your port
and see what warnings you're getting,

00:31:24.100 --> 00:31:26.100
because some might be interesting.

00:31:26.260 --> 00:31:28.530
The W format flag will tell
you where you have the wrong

00:31:28.560 --> 00:31:31.600
printf or sprintf arguments,
and it's also very useful.

00:31:31.600 --> 00:31:36.100
This flag is actually on by default
if you're using W all or W most.

00:31:36.100 --> 00:31:38.870
Now, beyond compiler warnings
and beyond compiler errors,

00:31:38.870 --> 00:31:42.100
you might get runtime crashes when
you try to run your application.

00:31:42.100 --> 00:31:46.400
That's actually good news,
because that means, you know,

00:31:46.470 --> 00:31:48.850
you're still able to catch
your errors before you ship

00:31:48.850 --> 00:31:50.600
your application to the users.

00:31:50.600 --> 00:31:55.600
And, you know, then you work through
your runtime crashes.

00:31:55.600 --> 00:31:55.600
And right now,
let me go through some of the pitfalls

00:31:55.600 --> 00:31:55.600
that you might have to deal with.

00:31:55.600 --> 00:31:56.600
So, the very first one is
the very common one.

00:31:56.600 --> 00:31:56.600
It's, you know, pretty obvious.

00:31:56.600 --> 00:31:56.600
I've already referred to it.

00:31:56.600 --> 00:31:56.600
It's basically truncating pointers,
because the code made an assumption

00:31:56.600 --> 00:31:56.600
that the size of a pointer is
equal to the size of an int.

00:31:56.600 --> 00:32:00.240
So, the very first one is
the very common one.

00:32:00.270 --> 00:32:03.060
It's, you know, pretty obvious.

00:32:03.060 --> 00:32:05.600
I've already referred to it.

00:32:05.600 --> 00:32:10.110
It's basically truncating pointers,
because the code made an assumption

00:32:10.110 --> 00:32:13.600
that the size of a pointer is
equal to the size of an int.

00:32:13.600 --> 00:32:16.560
You have code here, void star a pointer.

00:32:16.610 --> 00:32:20.420
You assign that to an int,
and then you extract that later on.

00:32:20.500 --> 00:32:22.500
So,
if you had the value 2 billion something,

00:32:22.500 --> 00:32:25.100
or, you know, that's, you know,
a little bit more than that,

00:32:25.100 --> 00:32:25.100
then you would have to do a lot of work.

00:32:25.100 --> 00:32:28.990
So, that's 2 with 8 zeros following it,
which is clearly above 4 gigabytes.

00:32:29.380 --> 00:32:33.060
After you're done, you know,
the top part of the pointer is gone.

00:32:33.090 --> 00:32:35.100
So, clearly a bad idea.

00:32:35.180 --> 00:32:38.600
To fix this,
you can use a type like int pointer t.

00:32:38.600 --> 00:32:40.910
Int pointer t was
designed for this purpose,

00:32:40.910 --> 00:32:43.760
to be the same size as a pointer,
an integer which is the

00:32:43.760 --> 00:32:45.080
same size as a pointer.

00:32:45.170 --> 00:32:48.760
You can also use other types like
long or any other 64-bit quantity,

00:32:48.760 --> 00:32:50.100
depending on your use.

00:32:50.180 --> 00:32:53.910
But anyway, something like this is the
way you fix this issue.

00:32:55.730 --> 00:33:00.000
Another common mistake is
mismatch in formatting characters.

00:33:00.000 --> 00:33:02.310
You know that %d refers to ints.

00:33:03.150 --> 00:33:05.600
However,
it will work with longs in 32-bit.

00:33:05.690 --> 00:33:08.920
But in 64-bit,
if you have a long and if you have %d,

00:33:09.100 --> 00:33:10.590
that's not a good combination.

00:33:10.610 --> 00:33:15.290
Because if you have a value like, say,
5 billion or whatever that

00:33:15.290 --> 00:33:18.980
is - too many zeros - anyway,
so if you have a value

00:33:18.980 --> 00:33:22.220
that's above 4 billion,
it will go ahead and

00:33:22.220 --> 00:33:24.600
print a truncated value.

00:33:24.730 --> 00:33:26.600
So, not a good idea.

00:33:26.600 --> 00:33:29.600
In this case,
the fix is to simply use %ld.

00:33:29.700 --> 00:33:33.550
Because %ld is what refers to a long,
and that is the right thing to use here.

00:33:33.830 --> 00:33:37.700
And I believe Wformat will
catch errors like this.

00:33:38.540 --> 00:33:39.840
Failing to use size of.

00:33:39.840 --> 00:33:41.580
This is probably a pretty
elementary problem,

00:33:41.580 --> 00:33:44.180
but there could be some reason
why you use the four there.

00:33:44.220 --> 00:33:46.360
Maybe the memory you're
copying into is four.

00:33:46.390 --> 00:33:48.840
But anyway, if you have a long and
you're copying it somewhere,

00:33:48.840 --> 00:33:50.760
you really wanna use size of.

00:33:50.770 --> 00:33:52.820
'Cause if you don't,
it will again truncate a part of

00:33:52.820 --> 00:33:55.240
the data you're trying to copy,
and you will get different results

00:33:55.240 --> 00:33:56.610
and different architectures.

00:33:56.760 --> 00:33:57.950
So this is also a bad idea.

00:33:58.140 --> 00:33:58.960
Now, this one's easy.

00:33:59.000 --> 00:34:00.790
Just go ahead and use size of.

00:34:00.810 --> 00:34:03.830
And in other cases, the fixes might vary.

00:34:03.880 --> 00:34:06.700
But it's a common problem as well.

00:34:06.720 --> 00:34:08.640
Mixing signed and unsigned arithmetic.

00:34:08.640 --> 00:34:12.880
This is a common pitfall that even in
32-bit that sometimes becomes a problem.

00:34:12.910 --> 00:34:17.840
This occurs because of C's rules for
how it deals with unsigned and signed.

00:34:17.840 --> 00:34:20.460
When you mix the two,
the result is unsigned.

00:34:20.480 --> 00:34:23.160
Now, typically,
when you mix the two and assign

00:34:23.160 --> 00:34:27.100
the result to assigned value,
you don't feel the

00:34:27.100 --> 00:34:28.560
effects of this problem.

00:34:28.590 --> 00:34:31.260
But in this case, for instance,
where you have an int and

00:34:31.260 --> 00:34:33.820
you have an unsigned int,
you add them together,

00:34:33.840 --> 00:34:36.740
and then you assign to
assigned larger quantity the

00:34:36.740 --> 00:34:38.880
signed extension is a problem.

00:34:38.910 --> 00:34:40.580
Let me give you an example.

00:34:40.580 --> 00:34:42.900
If you had a value-- here's what happens.

00:34:42.920 --> 00:34:46.760
In this case, minus 2 plus 1 is supposed
to give you minus 1.

00:34:46.830 --> 00:34:48.840
However,
because it's treated as unsigned,

00:34:48.840 --> 00:34:51.780
it gives you 4.2 billion whatever.

00:34:51.810 --> 00:34:53.420
And then when that's
assigned to the long,

00:34:53.420 --> 00:34:56.760
it still retains that 4.2 billion,
which is clearly wrong.

00:34:56.760 --> 00:34:58.020
Not what you wanted.

00:34:58.050 --> 00:35:00.670
Now, there are many fixes to this.

00:35:00.900 --> 00:35:03.900
The easiest one probably is
to make sure that unless you

00:35:03.900 --> 00:35:08.140
really want an unsigned result,
cast your unsigns to signed values

00:35:08.140 --> 00:35:09.900
when you're doing arithmetic.

00:35:09.900 --> 00:35:11.790
That way the compiler
knows what you mean.

00:35:11.830 --> 00:35:13.330
And this is one way to fix this.

00:35:13.330 --> 00:35:15.320
There are other possible solutions.

00:35:17.850 --> 00:35:20.380
Failing to specify the
appropriate type of constant.

00:35:20.380 --> 00:35:24.500
So you're going to start seeing a lot of
decorations on your constants in 64-bit.

00:35:24.640 --> 00:35:28.940
In this case we have an int and
we're trying to shift the number

00:35:28.940 --> 00:35:33.920
1 by a certain number of bits.

00:35:34.310 --> 00:35:38.800
Now if you happen to pass 30,
this works as expected.

00:35:38.800 --> 00:35:42.740
If you happen to pass 31,
you get this garbage,

00:35:42.790 --> 00:35:46.100
mainly because of the sign
extension to unsigned.

00:35:46.270 --> 00:35:50.180
Because you're rolling - or
you're shifting a signed 1.

00:35:50.250 --> 00:35:54.110
So you might think the fix
is to use a 1u over there,

00:35:54.190 --> 00:35:56.190
which is of course an unsigned 1.

00:35:56.200 --> 00:36:00.200
Now that gets you over the 31,
which now behaves correctly.

00:36:00.200 --> 00:36:04.200
However, 32 doesn't work.

00:36:04.200 --> 00:36:05.050
And the reason for that is
you have an int quantity,

00:36:05.110 --> 00:36:08.200
and if you try to shift
an int more than 32,

00:36:08.200 --> 00:36:08.200
it just becomes 0.

00:36:08.200 --> 00:36:10.840
Because it's only 32 bits,
even though you're

00:36:10.840 --> 00:36:12.190
assigning it to a long.

00:36:12.190 --> 00:36:15.090
So really the fix here is
that you have a long int,

00:36:15.090 --> 00:36:15.090
and you're not going to
be able to get a long int.

00:36:15.340 --> 00:36:17.070
is to use 1UL.

00:36:17.520 --> 00:36:21.690
And there you're specifying
that you want an unsigned 64-bit

00:36:21.700 --> 00:36:23.980
quantity that you're going to shift,
and you might be

00:36:23.980 --> 00:36:25.440
shifting it more than 32.

00:36:25.480 --> 00:36:27.060
You're going to see these
kinds of decorations,

00:36:27.060 --> 00:36:30.290
U's and UL's and so on,
a lot in your code as you move forward.

00:36:30.300 --> 00:36:33.530
So constants are a good
thing to take a look at.

00:36:34.980 --> 00:36:36.500
Now here's another one.

00:36:36.570 --> 00:36:38.320
You might assume this code
is pretty straightforward:

00:36:38.410 --> 00:36:42.410
if def ppc print
PowerPC else print Intel.

00:36:42.410 --> 00:36:46.180
And on 64-bit PowerPC this prints Intel.

00:36:46.180 --> 00:36:51.790
Because if def_ppc is
only true for 32-bit PPC.

00:36:52.080 --> 00:36:54.820
There are a number of preprocessor
macros you should use.

00:36:54.920 --> 00:37:00.000
The first four here: PPC, PPC64, i386,
x8664 - these are all

00:37:00.000 --> 00:37:01.560
architecture specific.

00:37:01.630 --> 00:37:03.680
These are a good idea
to use in some cases,

00:37:03.680 --> 00:37:07.420
for instance if you have assembly code,
but they're really not what you

00:37:07.420 --> 00:37:09.050
might want to use in other cases.

00:37:09.210 --> 00:37:11.340
If you want to distinguish BigAndian,
for instance,

00:37:11.340 --> 00:37:12.620
you would use FDefBigAndian.

00:37:12.800 --> 00:37:16.920
If you want to distinguish 64-bit,
you would use this FLP64

00:37:16.920 --> 00:37:18.870
that I showed earlier.

00:37:19.170 --> 00:37:21.600
So again,
here's how you might handle BigNDN,

00:37:21.630 --> 00:37:27.410
and here's how you would
handle 64-bit - #iflp64.

00:37:29.750 --> 00:37:31.840
Now there is the pitfall
of wrong underlying type,

00:37:31.840 --> 00:37:35.050
and that's something that impacted us,
and it might also hit you as well.

00:37:35.200 --> 00:37:37.870
And the example is SN32,
which I showed earlier.

00:37:37.900 --> 00:37:41.550
In Tiger,
SN32 is declared to be signed long.

00:37:41.870 --> 00:37:45.370
Now SN32 is clearly a 32-bit quantity,
the name says so.

00:37:45.370 --> 00:37:48.910
So if you were to go ask for the
size of SN32 in a 64-bit app,

00:37:48.910 --> 00:37:50.800
you will get 8,
which is not what you want.

00:37:50.900 --> 00:37:52.900
So, not a good idea.

00:37:52.900 --> 00:37:57.480
So what we did to fix this is we
declared SN32 with two definitions.

00:37:57.510 --> 00:38:02.000
In 64-bit it's defined as an int,
and in 32-bit it's defined as a long,

00:38:02.000 --> 00:38:04.500
which gives you a 32-bit definition.

00:38:04.600 --> 00:38:07.600
Now we did this because we want
to maintain binary compatibility.

00:38:07.600 --> 00:38:09.580
If this sort of thing
happened in your code,

00:38:09.720 --> 00:38:12.400
and you weren't part of a framework,
it's all in an app,

00:38:12.640 --> 00:38:15.390
then you could just go ahead
and do the simple declaration,

00:38:15.500 --> 00:38:17.370
which is just declared to be int32t.

00:38:17.490 --> 00:38:18.900
You know,
this is really the straightforward thing.

00:38:18.900 --> 00:38:20.400
This is what you really want to do here.

00:38:20.400 --> 00:38:22.350
You have a type called 32-bit,
it's signed int.

00:38:22.400 --> 00:38:27.830
Go ahead and declare it as
an underlying signed integer.

00:38:29.110 --> 00:38:32.920
Okay, another pitfall is not upgrading
source code to new types.

00:38:32.920 --> 00:38:36.000
As I said, we're not using CG floats
everywhere for Quartz.

00:38:36.000 --> 00:38:38.990
And this actually, even if you don't
update your source code,

00:38:39.000 --> 00:38:43.580
it will seem to work in many, many cases,
because a float will get upgraded to

00:38:43.580 --> 00:38:46.000
a double when you call a function.

00:38:46.320 --> 00:38:48.700
However, if you have something like this,
where you have an array of

00:38:48.730 --> 00:38:51.190
four floats and you're trying
to create a color with them,

00:38:51.360 --> 00:38:55.000
and CGColorCreate takes
an array of CG floats.

00:38:55.100 --> 00:38:59.740
So if you call this on a 64-bit app,
you will get this result,

00:38:59.740 --> 00:39:02.270
which is not what you expected.

00:39:02.540 --> 00:39:05.330
Really, you need to be passing
in an array of CG floats.

00:39:05.630 --> 00:39:08.550
Now this is interesting
to keep in mind because,

00:39:08.670 --> 00:39:12.530
again,
this CG float conversion cases will work

00:39:12.620 --> 00:39:15.590
most of the time except when pointers
to these quantities are involved.

00:39:15.660 --> 00:39:17.160
So something to keep in mind.

00:39:17.260 --> 00:39:22.230
And note that this pitfall could occur
with NSInteger and NSUInteger as well.

00:39:22.790 --> 00:39:28.360
You know, writing data to files is always
tricky across architectures.

00:39:28.360 --> 00:39:31.100
Using size-changing data types
across architectures is interesting.

00:39:31.100 --> 00:39:33.480
Now with Intel,
you might have had to worry about

00:39:33.560 --> 00:39:35.610
endianness of stuff you wrote to files.

00:39:35.750 --> 00:39:38.290
With 64-bit you of course
have to worry about the size,

00:39:38.290 --> 00:39:39.700
in addition to endianness.

00:39:39.700 --> 00:39:42.110
Let's say you have a 32-bit process.

00:39:42.110 --> 00:39:45.200
It writes a long out,
and it does it by just F-writing

00:39:45.200 --> 00:39:46.700
the long using size of long.

00:39:46.700 --> 00:39:48.700
That's fine, it writes out 4 bytes.

00:39:48.700 --> 00:39:51.780
Now if the corresponding
process is run in 64-bit,

00:39:51.780 --> 00:39:54.700
to read it,
it will clearly try to read 8 bytes.

00:39:54.700 --> 00:39:57.830
So while you really meant
to write out 20,000 hexes,

00:39:57.830 --> 00:40:00.800
it will read back 20,000
followed by garbage,

00:40:00.850 --> 00:40:04.700
and might even crash or give you
some other unexpected result.

00:40:04.700 --> 00:40:07.620
And again,
the problem is size of long is 8 bytes.

00:40:07.690 --> 00:40:08.690
There are multiple fixes here.

00:40:08.740 --> 00:40:11.700
One possible one is be very
explicit about what you're writing.

00:40:11.700 --> 00:40:17.610
Use int32t and write out just 4
bytes in both input and output.

00:40:17.700 --> 00:40:17.700
This is pretty straightforward.

00:40:17.810 --> 00:40:22.470
This sort of pitfall exists for
the old archiver in Cocoa as well.

00:40:22.700 --> 00:40:26.650
Let's say you have an instance variable,
and let's say it used to be an int.

00:40:26.730 --> 00:40:29.700
And let's say you ran the
conversion script we told you about.

00:40:29.700 --> 00:40:32.820
The conversion script will
convert your int to an NSInteger,

00:40:32.820 --> 00:40:36.700
and you might think that's a good idea,
because that seems fine.

00:40:36.700 --> 00:40:38.690
And that's the way you want to leave it,
which is good.

00:40:38.700 --> 00:40:42.730
However, if you're using the
old non-keyed archiver,

00:40:42.890 --> 00:40:45.250
you need to look at the code now.

00:40:46.640 --> 00:40:49.540
The code might have looked like this:
you're writing out your instance

00:40:50.500 --> 00:40:54.850
variable using the type i,
which clearly refers to a 32-bit element.

00:40:56.010 --> 00:40:57.900
And here is the reader
that corresponds to this.

00:40:57.900 --> 00:41:01.270
Clearly if the reader is
in a 64-bit application,

00:41:01.270 --> 00:41:04.400
there is now an inconsistency between
the read and the written value.

00:41:04.400 --> 00:41:06.280
So this also is a bad idea.

00:41:06.510 --> 00:41:08.900
So let me show you how
you might fix this.

00:41:08.900 --> 00:41:11.350
Assuming you don't want to
change your file format,

00:41:11.490 --> 00:41:15.400
because you want to keep your file format
the same between 32-bit and 64-bit,

00:41:15.400 --> 00:41:17.400
this is one way you could approach this.

00:41:17.400 --> 00:41:20.280
And this also is complete
with error handling here.

00:41:20.400 --> 00:41:23.830
If the instance variable's
value is less than int max,

00:41:24.370 --> 00:41:27.880
assign it to a temporary integer,
and write it out using the

00:41:27.880 --> 00:41:29.390
code you were using before.

00:41:29.470 --> 00:41:33.360
Now if the value is greater than int max,
clearly you have a value that can

00:41:33.360 --> 00:41:35.840
no longer be written to that file,
and it's something you might

00:41:35.950 --> 00:41:37.320
want to warn the user about.

00:41:37.390 --> 00:41:39.400
You might need to
upgrade your file format,

00:41:39.400 --> 00:41:42.370
but that's left as an exercise to you.

00:41:42.450 --> 00:41:45.370
And then the reader is - you
do the similar kind of change.

00:41:45.400 --> 00:41:49.400
You read the value into a temp,
which is an integer,

00:41:49.400 --> 00:41:51.400
and then you assign it to
your instance variable.

00:41:51.400 --> 00:41:54.390
And the reason we have to
use that temporary integer is

00:41:54.420 --> 00:41:59.400
because we're reading the value
via a pointer by the address.

00:41:59.400 --> 00:42:02.400
So we really need to provide
the correct size there.

00:42:03.100 --> 00:42:07.180
Now the good news is this is only a
problem with the old archiver in Cocoa.

00:42:07.180 --> 00:42:10.220
And we've actually introduced
a new archiver back in 10.2,

00:42:10.320 --> 00:42:13.000
and we've been encouraging
you to move over to it.

00:42:13.000 --> 00:42:17.000
So hopefully this is only a problem
for a very small number of cases.

00:42:17.000 --> 00:42:19.700
One case is clearly if you
have old document formats

00:42:19.700 --> 00:42:22.590
that you're still sporting,
this is something to keep

00:42:22.590 --> 00:42:23.980
in mind if you do that.

00:42:25.490 --> 00:42:28.370
Now here's unexpected API behaviors.

00:42:28.470 --> 00:42:32.610
Let's say you want to write a function
that returns a random number from 0 to 1.

00:42:32.610 --> 00:42:35.800
And you saw in standard lib.h
that random returns a long.

00:42:35.900 --> 00:42:38.400
So you went ahead and
wrote this function.

00:42:38.400 --> 00:42:41.710
It gets the value of random,
divides it by long_max,

00:42:41.710 --> 00:42:44.390
and gets you a value between 0 and 1.

00:42:44.540 --> 00:42:48.550
Now if you were to run this
on a 64-bit application,

00:42:48.550 --> 00:42:52.400
you will get these tiny little
values most of the time.

00:42:52.400 --> 00:42:55.800
And people playing your poker application
or whatnot will either be delighted

00:42:55.860 --> 00:42:58.470
that they're winning all the time,
or they'll be sad that they'll

00:42:58.480 --> 00:42:59.400
be losing all the time.

00:42:59.400 --> 00:43:01.400
But it's not going to seem very random.

00:43:01.400 --> 00:43:05.400
And the reason for that is because if
you read the documentation for random,

00:43:05.400 --> 00:43:10.400
it says that random returns
values from 0 to 2^31 - 1.

00:43:10.410 --> 00:43:14.080
So although the header says one thing,
the documentation clarifies

00:43:14.140 --> 00:43:15.340
it a little further.

00:43:15.390 --> 00:43:18.400
So that's the way random
is documented to behave.

00:43:18.400 --> 00:43:21.400
And this is one of these cases where
you can trust the documentation.

00:43:21.570 --> 00:43:23.510
So...

00:43:24.090 --> 00:43:25.490
This is one possible fix.

00:43:25.500 --> 00:43:29.880
Since you know that it returns
2^ , you go divide that by value,

00:43:29.880 --> 00:43:33.070
so this will give you
quantities from 0 to 1.

00:43:33.930 --> 00:43:40.890
Now this is in a category of pitfalls
that deserves a special mention.

00:43:40.890 --> 00:43:45.080
There are some other
API changes across the system.

00:43:45.080 --> 00:43:47.670
Now this random one
was not an API change,

00:43:47.740 --> 00:43:50.220
but there are some other things
to watch out in APIs you're using.

00:43:50.220 --> 00:43:53.090
And one of them is these
API changes where we're making

00:43:53.200 --> 00:43:54.990
our APIs more POSIX compliant.

00:43:54.990 --> 00:43:59.290
Functions like mmap, putenv, open,
select, and a few more now have

00:43:59.290 --> 00:44:03.420
different behaviors when run
in POSIX compliance mode.

00:44:03.420 --> 00:44:09.500
And by default, these changes apply to
10.5 only applications.

00:44:09.500 --> 00:44:11.420
So existing 32-bit
applications are unaffected,

00:44:11.480 --> 00:44:14.860
but they are enabled
for 64-bit applications.

00:44:14.860 --> 00:44:18.750
So when you run your 64-bit
application and when you debug it,

00:44:18.750 --> 00:44:22.450
you need to pay attention to how
you're using these functions.

00:44:22.510 --> 00:44:25.100
The documentation goes through
detail as to what the changes are,

00:44:25.140 --> 00:44:26.860
so it's something you really
need to pay attention to.

00:44:26.860 --> 00:44:29.740
And some of the changes are subtle,
and you have to pass the

00:44:29.830 --> 00:44:31.110
right options and so on.

00:44:33.150 --> 00:44:37.720
Now speaking of these API changes,
there's of course another category

00:44:37.820 --> 00:44:40.510
of API changes to be aware of,
and these are APIs not

00:44:40.510 --> 00:44:42.140
available in 64-bit.

00:44:42.180 --> 00:44:43.710
Simon mentioned these yesterday.

00:44:43.760 --> 00:44:46.290
I'm not going to go through
it in any detail today,

00:44:46.290 --> 00:44:49.320
but these are some of the
APIs that are not available.

00:44:49.320 --> 00:44:50.260
And these are some of the cars.

00:44:50.260 --> 00:44:53.200
And I really love that the CFM there.

00:44:53.200 --> 00:44:56.780
But these are some of the APIs that
are not available to you in 64-bit.

00:44:56.780 --> 00:45:00.630
Now for tomorrow's in-depth talk,
which is tomorrow morning at 9:00

00:45:00.630 --> 00:45:04.800
a.m., Matthew Formica will actually
go through these APIs and go through

00:45:04.800 --> 00:45:07.040
what the replacements are in detail.

00:45:07.040 --> 00:45:09.380
So be sure to come for that.

00:45:10.570 --> 00:45:14.940
Okay, so with that let's go to our
closing thoughts on 64-bit.

00:45:17.320 --> 00:45:20.390
Now one thing that's important
as you move to 64-bit is this

00:45:20.390 --> 00:45:22.700
notion of interoperability.

00:45:23.140 --> 00:45:25.880
You really want the file
formats used between 32-bit

00:45:25.880 --> 00:45:27.760
and 64-bit to be compatible.

00:45:27.760 --> 00:45:29.800
For instance,
Nib files that Interface Builder

00:45:29.800 --> 00:45:34.310
generates will work either in 32-bit apps
or 64-bit apps with no changes needed.

00:45:34.470 --> 00:45:38.310
This is true for preference files,
all other data files your app writes,

00:45:38.320 --> 00:45:39.670
and also documents as well.

00:45:39.860 --> 00:45:42.500
Unless there is a reason that
your document needs to start

00:45:42.500 --> 00:45:45.830
holding 64-bit quantities,
so you need to upgrade

00:45:45.830 --> 00:45:48.490
your document format,
be sure that the document

00:45:48.620 --> 00:45:49.910
formats are interchangeable.

00:45:49.910 --> 00:45:53.460
The user should not care which
version of the app wrote the document.

00:45:53.460 --> 00:45:55.060
So in this way,
the interoperability stakes

00:45:55.060 --> 00:45:58.680
are similar to 32-bit Intel.

00:45:58.700 --> 00:46:01.290
Just like users don't know whether
they're using 32-bit Intel or

00:46:01.290 --> 00:46:04.530
PowerPC version of the app,
the same holds true for 64-bit

00:46:04.590 --> 00:46:06.560
versions of the applications.

00:46:06.560 --> 00:46:08.950
Now another consideration is performance.

00:46:08.950 --> 00:46:13.370
Now we already talked about whether you
should move applications 64-bit or not.

00:46:13.440 --> 00:46:17.910
And the general recommendation is
there's absolutely no benefit to move it,

00:46:17.990 --> 00:46:19.010
no performance benefit.

00:46:19.150 --> 00:46:20.860
You probably don't need to move it.

00:46:20.860 --> 00:46:23.580
You know,
it's not going to get you any benefit.

00:46:23.580 --> 00:46:25.330
Why do it?

00:46:26.050 --> 00:46:31.150
Now however, even in cases where it seems
like there might be no benefit,

00:46:31.150 --> 00:46:33.160
let me give you an example.

00:46:33.240 --> 00:46:35.460
Earlier in another session
I showed how to convert the

00:46:35.460 --> 00:46:38.440
TextEdit application to 64-bit.

00:46:38.440 --> 00:46:41.070
And you would think
TextEdit is a fairly small,

00:46:41.150 --> 00:46:44.980
harmless application, and it is harmless,
but when run under 64-bit it

00:46:45.320 --> 00:46:49.920
actually becomes capable of opening
documents larger than 4 gigabytes.

00:46:49.920 --> 00:46:52.020
That's one hidden benefit.

00:46:52.020 --> 00:46:53.220
Is it a good enough benefit?

00:46:53.220 --> 00:46:53.980
Probably not.

00:46:53.980 --> 00:46:55.840
In fact,
we're not going to ship TextEdit as

00:46:55.840 --> 00:46:58.110
a 64-bit application on the system,
but you know,

00:46:58.110 --> 00:46:59.280
it is something to keep in mind.

00:46:59.320 --> 00:47:02.840
Now there is one other
performance consideration.

00:47:02.910 --> 00:47:06.690
If you are moving to 64-bit
and you're using 64-bit because

00:47:06.690 --> 00:47:09.620
of the large memory access,
you need to keep in mind,

00:47:09.620 --> 00:47:12.830
you need to check the physical
memory in the machine and adjust

00:47:12.860 --> 00:47:14.790
your algorithms accordingly.

00:47:14.830 --> 00:47:18.230
Earlier I said,
just because a user has a 64-bit machine,

00:47:18.310 --> 00:47:22.260
it does not mean they have 8 or 16
gigabytes of memory in their machine.

00:47:22.260 --> 00:47:25.570
In fact, if you're in that
DNA demo we saw yesterday,

00:47:25.570 --> 00:47:30.830
if you ran the 64-bit version of that
on an iMac G5 with 512 megs of memory,

00:47:30.860 --> 00:47:34.910
it would just bog down terribly
because it assumes it's got at

00:47:34.910 --> 00:47:36.780
least 4 gigabytes of memory.

00:47:36.780 --> 00:47:40.570
So when you write large memory algorithms
where you take advantage of large memory,

00:47:40.570 --> 00:47:44.160
one thing you should do is you should
check the memory in the machine and if,

00:47:44.160 --> 00:47:49.470
you know, enough memory isn't available,
either fall back to 32-bit algorithms or

00:47:49.480 --> 00:47:51.730
maybe your application isn't able to run.

00:47:51.750 --> 00:47:53.640
And here is one way you could do that.

00:47:53.700 --> 00:47:56.760
You use the syscadl or syscadl
by name with the mem size and

00:47:56.760 --> 00:47:59.630
it returns to you the amount of
physical memory in the machine.

00:47:59.770 --> 00:48:01.080
Fairly straightforward.

00:48:01.080 --> 00:48:03.050
And this is one way
you can check for this.

00:48:06.390 --> 00:48:10.140
And porting stakes,
again as I said earlier,

00:48:10.140 --> 00:48:13.910
it's totally our intent to use the
same source base for 32-bit and

00:48:14.050 --> 00:48:16.260
64-bit versions of your binary.

00:48:16.350 --> 00:48:20.270
This means less sources, less divergence,
and less opportunity for problems.

00:48:20.550 --> 00:48:24.800
Now if you do need to conditionalize
parts of your source code,

00:48:24.800 --> 00:48:29.720
and you might need to,
use #if LP64 to distinguish those cases.

00:48:30.870 --> 00:48:33.920
And opportunities in
the 64-bit transition.

00:48:33.920 --> 00:48:36.210
You already saw one of the
opportunities that we took,

00:48:36.210 --> 00:48:40.740
and that was to introduce CGFloat
and make our graphics subsystem

00:48:40.800 --> 00:48:44.960
capable of more accuracy,
more range, wider range.

00:48:45.210 --> 00:48:49.140
64-bit is really an opportunity
to remove deprecated APIs,

00:48:49.140 --> 00:48:52.860
to remove compatibility
hacks and old subsystems.

00:48:52.910 --> 00:48:55.080
It's really an opportunity
for us to modernize the

00:48:55.140 --> 00:48:58.600
OS by removing all the stuff,
and for you to modernize your apps

00:48:58.600 --> 00:49:01.780
by also doing things brand new ways,
taking advantage of the six-word

00:49:01.830 --> 00:49:05.450
address space and moving to new APIs and
getting rid of the old APIs that

00:49:05.560 --> 00:49:08.940
might be holding your application back.

00:49:08.940 --> 00:49:12.670
Now we will talk about this in
the in-depth talk a great deal,

00:49:12.770 --> 00:49:14.580
so please come tomorrow.

00:49:14.580 --> 00:49:18.120
Now for more coverage for 64-bit,
for the API changes,

00:49:18.140 --> 00:49:23.190
for unavailable APIs, for replacements,
state of 64-bit in Leopard Preview,

00:49:23.610 --> 00:49:27.360
because not everything is quite perfect,
we have to admit that.

00:49:27.390 --> 00:49:30.790
And also, a good amount of information
on architectural details,

00:49:30.790 --> 00:49:36.440
especially Intel 64, which is a brand new
environment to many of us.

00:49:36.440 --> 00:49:40.180
Please come to the in-depth talk
tomorrow morning at 9:00 AM,

00:49:40.220 --> 00:49:44.500
and I believe it's in the
big hall in the Presidio.

00:49:44.500 --> 00:49:46.320
We have a bunch of documentation.

00:49:46.320 --> 00:49:48.740
This documentation is not on your DVD,
so you have to download

00:49:48.740 --> 00:49:50.800
it from the WWDC site.

00:49:50.800 --> 00:49:53.250
We have a 64-bit transition guide,
which is an upgraded version

00:49:53.250 --> 00:49:54.920
of the Tiger document.

00:49:54.920 --> 00:49:57.200
And we have transition
guides for both Carbon,

00:49:57.250 --> 00:49:57.960
and Cocoa.

00:49:57.960 --> 00:50:01.700
And these cover the topics
I touched upon and a bunch more.

00:50:01.700 --> 00:50:05.280
And the 64-bit Cocoa one, as I mentioned,
goes through the conversion

00:50:05.280 --> 00:50:06.580
process step by step.

00:50:06.580 --> 00:50:09.040
So if you're going to be doing that,
it's a good thing to read through.

00:50:09.040 --> 00:50:12.580
We also have three 64-bit labs
starting tomorrow afternoon,

00:50:12.780 --> 00:50:14.610
and Thursday morning, and Friday morning.

00:50:14.610 --> 00:50:16.390
And there will be many
engineers from Appleto's,

00:50:16.390 --> 00:50:19.160
and there will also be
64-bit capable machines.

00:50:19.160 --> 00:50:21.260
So please come with your
projects if you're interested

00:50:21.330 --> 00:50:24.410
in converting to 64-bit,
and we can try to answer some questions.
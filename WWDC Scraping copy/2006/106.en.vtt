WEBVTT

00:00:10.600 --> 00:00:13.270
I'm Kristin Forster,
I work in the Cocoa Frameworks group and

00:00:13.270 --> 00:00:16.700
I'd like to welcome you to session 106,
Taking Advantage of

00:00:16.720 --> 00:00:19.680
Leopard Features in Cocoa.

00:00:20.150 --> 00:00:23.150
Today we're going to dive into three
of the features that Chris covered

00:00:23.150 --> 00:00:25.380
in his What's New in Cocoa talk.

00:00:25.380 --> 00:00:27.580
We're going to talk about the
benefits of these features and

00:00:27.580 --> 00:00:31.100
we're going to show how to adopt
them using TextEdit as an example.

00:00:31.100 --> 00:00:35.100
We'll show some problems you may run
into and talk about how to solve them.

00:00:35.100 --> 00:00:38.180
And our goal is that you leave
this session ready to take

00:00:38.190 --> 00:00:41.530
advantage of Leopard features
in your Cocoa application.

00:00:42.700 --> 00:00:45.940
First,
Ali Ozer is going to talk about 64-bit.

00:00:45.940 --> 00:00:49.080
Some 64-bit libraries
are available on Tiger.

00:00:49.080 --> 00:00:52.630
On Leopard, 64-bit has been brought
to the Cocoa frameworks.

00:00:52.660 --> 00:00:54.810
With a fairly mechanical conversion,
you can make your

00:00:54.810 --> 00:00:58.360
application 64-bit aware,
and we provide a top

00:00:58.430 --> 00:01:00.940
script to make this easy.

00:01:00.940 --> 00:01:06.500
Once you have done this conversion,
you can take advantage of 64-bit

00:01:06.500 --> 00:01:06.500
capabilities in your application.

00:01:07.150 --> 00:01:11.300
Next, Mark Piccirelli is going to talk
about uniform type identifiers.

00:01:11.300 --> 00:01:13.810
Uniform type identification is
a type system that encapsulates

00:01:13.810 --> 00:01:16.260
file name extensions,
MIME types, OS types,

00:01:16.260 --> 00:01:17.820
and other information.

00:01:17.820 --> 00:01:21.180
You may already be using uniform type
identifiers if you've written a spotlight

00:01:21.180 --> 00:01:24.700
importer for your custom document format.

00:01:24.700 --> 00:01:27.060
On Leopard,
you can use uniform type identifiers

00:01:27.060 --> 00:01:30.340
throughout your application to
simplify your type management and

00:01:30.340 --> 00:01:33.970
to improve your interoperability
with the rest of the system.

00:01:34.420 --> 00:01:38.480
Lastly, Kevin Perry is going to talk
about resolution independence.

00:01:38.480 --> 00:01:41.000
Resolution independence allows your
user interface to be drawn at the

00:01:41.000 --> 00:01:45.400
same physical size regardless of
the pixel density of the display.

00:01:45.400 --> 00:01:48.400
We had some support for
resolution independence in Tiger.

00:01:48.400 --> 00:01:52.400
In Leopard, we have improved and extended
this support and most notably,

00:01:52.400 --> 00:01:56.100
most standard user interface
elements are now drawn using

00:01:56.100 --> 00:01:58.710
resolution independent artwork.

00:01:58.810 --> 00:02:03.980
Now I'd like to invite Ali Ozer
up on stage to talk about 64-bit.

00:02:09.540 --> 00:02:10.750
Good morning.

00:02:10.750 --> 00:02:16.920
So 64-bit is one of the major
big things that we've done,

00:02:16.920 --> 00:02:20.540
of course, throughout, across Leopard,
and Cocoa is, of course,

00:02:20.540 --> 00:02:22.980
also one of these areas where
we did a lot of changes.

00:02:22.980 --> 00:02:25.740
So let me first define what 64-bit is.

00:02:25.740 --> 00:02:29.630
64-bit,
the most fundamental definition of 64-bit

00:02:29.630 --> 00:02:32.600
is support for 64-bit address space.

00:02:32.600 --> 00:02:37.100
32-bit supports 4 gigabytes,
and 64-bit supports 4 billion times that.

00:02:37.900 --> 00:02:41.150
And, you know, if you were to have one
fundamental definition,

00:02:41.150 --> 00:02:42.690
it's 64-bit pointers.

00:02:42.700 --> 00:02:44.080
That's what 64-bit means.

00:02:44.080 --> 00:02:49.100
64-bit is very interesting for
applications which need more than

00:02:49.100 --> 00:02:51.680
4 gigabytes of address space.

00:02:51.680 --> 00:02:53.880
These are applications that
have already been asking for

00:02:53.880 --> 00:02:56.630
64-bits for some time now,
and clearly they're a good

00:02:56.660 --> 00:02:58.010
target group to move over.

00:02:58.080 --> 00:03:01.420
But it's also potentially interesting
for other applications as well.

00:03:01.530 --> 00:03:06.400
Now I'm not going to go into
details or motivations for that now,

00:03:06.400 --> 00:03:07.270
but this afternoon,
2:00 p.m., after lunch, in Marina,

00:03:07.270 --> 00:03:12.580
64-bit overview is where we'll
cover this topic in more detail.

00:03:14.430 --> 00:03:17.060
64-bit uses the LP64 data model.

00:03:17.060 --> 00:03:18.060
Simon mentioned this.

00:03:18.060 --> 00:03:20.920
It's longs and pointers change to 64-bit.

00:03:20.920 --> 00:03:24.150
So pointers are 64,
the long data type is 64,

00:03:24.370 --> 00:03:27.320
and all other data types remain the same.

00:03:27.320 --> 00:03:30.320
So here's a handy little chart
showing you what happens.

00:03:30.320 --> 00:03:32.320
And again,
you can see everything remains the same.

00:03:32.320 --> 00:03:35.320
And one interesting item here is
the fact that the int data type,

00:03:35.320 --> 00:03:39.320
which used to be 4-byte,
is still 4 bytes.

00:03:40.600 --> 00:03:43.370
Now, in Cocoa APIs,
as most of you are probably aware,

00:03:43.410 --> 00:03:48.110
integral values are almost
always int or unsigned int.

00:03:48.520 --> 00:03:52.390
And this includes APIs which
should support 64-bit

00:03:52.390 --> 00:03:54.630
quantities in a 64-bit process.

00:03:54.690 --> 00:03:56.750
This includes things like NSData.

00:03:56.900 --> 00:03:58.700
You know,
you really want NSData to represent

00:03:58.830 --> 00:04:00.500
files larger than 4 gigabytes.

00:04:00.500 --> 00:04:02.540
Same with, in fact,
array and string as well.

00:04:02.540 --> 00:04:05.080
These methods, instead of returning ints,
you really want them

00:04:05.130 --> 00:04:06.310
to be 64-bit capable.

00:04:09.000 --> 00:04:15.780
So one possible solution here is why
not change ints in these APIs to longs?

00:04:15.900 --> 00:04:19.220
In that case,
an SRA method such as count would

00:04:19.220 --> 00:04:23.020
start returning unsigned long,
and object index would start

00:04:23.020 --> 00:04:25.840
taking unsigned long as well,
and that would make them 64-bit

00:04:25.840 --> 00:04:27.330
capable on a 64-bit environment.

00:04:27.340 --> 00:04:30.560
Now, however, that's not what we did.

00:04:33.060 --> 00:04:37.120
The major reason we didn't do this
is the fact that if we change ints

00:04:37.120 --> 00:04:40.690
to longs in all these APIs while
keeping the APIs the same,

00:04:40.690 --> 00:04:43.640
this might have adverse effects
on existing 32-bit applications.

00:04:43.640 --> 00:04:48.500
It's very important that we maintain
binary compatibility as we change stuff.

00:04:48.590 --> 00:04:50.720
And if we change ints
to longs in methods,

00:04:50.720 --> 00:04:54.570
although that's totally compatible
in the 32-bit world from a size,

00:04:54.590 --> 00:04:58.400
you know, 4 bytes, 4 bytes,
it does change the method signatures

00:04:58.400 --> 00:05:00.060
in the runtime to some degree.

00:05:00.160 --> 00:05:03.960
It doesn't actually change, you know,
the method name, but the method metadata.

00:05:03.960 --> 00:05:07.520
It also would require some
source code changes on your part.

00:05:07.520 --> 00:05:09.910
So even though you might not
care at all about 64-bit,

00:05:09.970 --> 00:05:12.880
by compiling under Leopard,
you might find yourself having to change

00:05:12.930 --> 00:05:14.660
your source code to accommodate this.

00:05:14.660 --> 00:05:16.740
So we decided not to do this.

00:05:16.740 --> 00:05:18.960
So we leave 32-bit as is.

00:05:18.960 --> 00:05:21.480
Now what we really want
is something like this.

00:05:21.480 --> 00:05:23.960
If we're compiling for 64-bit,
we want the count

00:05:24.060 --> 00:05:26.840
method to return a long,
and if we're compiling for 32,

00:05:26.920 --> 00:05:28.340
we want it to return an int.

00:05:28.440 --> 00:05:29.980
Of course, this solution.

00:05:30.140 --> 00:05:32.850
Where we do this per method
is very unwieldy because,

00:05:32.890 --> 00:05:34.900
you know,
depending on how many methods we do,

00:05:34.900 --> 00:05:37.580
you're going to have all these alternate
declarations for every one of them,

00:05:37.590 --> 00:05:38.970
and that's going to get messy.

00:05:39.020 --> 00:05:40.570
So, you know, it's not exactly.

00:05:40.580 --> 00:05:43.890
We don't want to do exactly this,
but in spirit, this is what we want.

00:05:43.900 --> 00:05:49.920
So we introduce two new types
and NSInteger and NSUInteger.

00:05:50.800 --> 00:05:52.230
And here are the way they're defined.

00:05:52.240 --> 00:05:55.970
Now first thing to note is
this underbar underbar LP64.

00:05:55.990 --> 00:05:59.800
This is the way we know that we're
under the 64-bit environment.

00:05:59.800 --> 00:06:04.200
If we're in the 64-bit environment,
we define NSInteger and NSUnteger to

00:06:04.200 --> 00:06:06.750
be long and unsigned long respectively.

00:06:06.810 --> 00:06:10.800
Otherwise, we define them to be
int and unsigned int.

00:06:10.800 --> 00:06:14.790
And that's the only sort of
conditional declaration we have.

00:06:15.560 --> 00:06:17.470
So with this,
then we go through the APIs where

00:06:17.470 --> 00:06:20.290
we want to make this change,
and we change int to NSInteger,

00:06:20.290 --> 00:06:22.780
unsigned it to NSUInteger,
and the NSArray methods

00:06:22.820 --> 00:06:23.740
now look like this.

00:06:23.740 --> 00:06:27.020
Instead of unsigned int,
it's returning an NSUInteger,

00:06:27.020 --> 00:06:29.840
and instead of unsigned
int and object index,

00:06:29.840 --> 00:06:31.640
it's taking an NSUInteger.

00:06:31.640 --> 00:06:35.160
And note that in the 32-bit world,
this is still the same exact thing.

00:06:35.260 --> 00:06:37.700
It's an unsigned int.

00:06:39.710 --> 00:06:42.590
So now the question is,
what API should we do this in?

00:06:42.600 --> 00:06:45.590
We already mentioned data,
we already mentioned array and string,

00:06:45.600 --> 00:06:47.390
and there are good reasons
for doing it there.

00:06:47.400 --> 00:06:49.050
But what other APIs?

00:06:49.060 --> 00:06:52.120
Well, attributed string is very
heavily based on string,

00:06:52.120 --> 00:06:55.020
and text storage is a
subclass of attributed string.

00:06:55.020 --> 00:06:57.080
So if we're going to do string,
we decide that we should

00:06:57.080 --> 00:06:58.360
really do attributed string.

00:06:58.360 --> 00:07:00.800
It would be weird to not have
attributed string do this.

00:07:00.940 --> 00:07:03.160
But if you do those,
then you really need to do text view,

00:07:03.240 --> 00:07:05.880
because text view uses attributed
string as its backing store,

00:07:05.880 --> 00:07:08.380
and it seems weird to have
attributed strings capable of more

00:07:08.380 --> 00:07:10.030
than 4 gigabytes and text view not.

00:07:10.080 --> 00:07:14.220
NSRange and IndexSet are a type
and a class which we use very

00:07:14.270 --> 00:07:18.960
frequently in all of these APIs to
represent ranges and so on.

00:07:18.980 --> 00:07:21.970
And since we want to
represent ranges in strings,

00:07:21.970 --> 00:07:26.850
text, etc., NSRange has to also be able
to represent 64-bit quantities,

00:07:26.860 --> 00:07:29.010
and the same goes for IndexSet.

00:07:29.140 --> 00:07:30.920
So we pull those in, too.

00:07:30.920 --> 00:07:33.870
TableView and OutlineView are often
used with these other classes.

00:07:33.880 --> 00:07:36.070
The backing store of a
TableView is often an array.

00:07:36.170 --> 00:07:39.790
TableViews represent ranges of
elements with range and IndexSet,

00:07:39.790 --> 00:07:42.560
so I think these should
come into the fold as well.

00:07:42.640 --> 00:07:45.420
Now, Matrix and Browser,
they don't want to be left out,

00:07:45.420 --> 00:07:47.220
so they bring them into the fold.

00:07:47.240 --> 00:07:50.240
And, you know, after a while,
this mental exercise says,

00:07:50.240 --> 00:07:54.170
"Let's just do everything." And let
me talk about the benefits of

00:07:54.170 --> 00:07:56.390
why we'd want to do everything.

00:07:56.670 --> 00:08:00.200
First of all, it gives us much better
impedance match across APIs.

00:08:00.200 --> 00:08:03.850
You can take the return from any method,
you know it's 64-bit capable,

00:08:03.880 --> 00:08:06.480
and pass it to any other method,
and you know it's 64-bit capable.

00:08:06.480 --> 00:08:08.540
What this means, for instance,
is you don't have to

00:08:08.540 --> 00:08:09.700
worry about truncation.

00:08:09.700 --> 00:08:14.020
My array count could return a
number greater than 4 gigabytes,

00:08:14.020 --> 00:08:17.830
but if table we did not accept a
value greater than 4 gigabytes,

00:08:17.880 --> 00:08:20.330
every time you call this
method or something like this,

00:08:20.360 --> 00:08:23.020
you'd have to worry,
what do I do if it's not big enough?

00:08:23.220 --> 00:08:28.210
By making them both capable of 64-bit,
the problem really becomes the rect

00:08:28.210 --> 00:08:30.710
of row method needs to worry about it.

00:08:30.770 --> 00:08:33.390
If it itself cannot deal with
more than 4 gigabytes internally,

00:08:33.390 --> 00:08:36.280
you know it will do something,
but at least the APIs are consistent.

00:08:36.280 --> 00:08:39.540
This is also compatible with the
CF index type and core foundation.

00:08:39.630 --> 00:08:41.850
As you know,
we use toll-free bridging between

00:08:41.850 --> 00:08:44.940
foundation and core foundation classes,
so data types go back and

00:08:45.040 --> 00:08:47.880
forth in various cases,
and having NSInteger be compatible

00:08:47.920 --> 00:08:49.890
with CF index is quite important.

00:08:49.900 --> 00:08:54.020
And finally, you know,
one big... One big reason is

00:08:54.020 --> 00:08:55.640
this whole consistency story.

00:08:55.760 --> 00:09:00.420
Now, as API providers, us,
or those of you who do APIs,

00:09:00.490 --> 00:09:03.620
you don't have to worry about,
should this be 32-bit,

00:09:03.760 --> 00:09:05.150
should this be 64-bit?

00:09:05.160 --> 00:09:07.620
You know, the answer is clear,
even if sometimes it seems

00:09:07.620 --> 00:09:10.240
like 64-bit is overkill,
there's no decision.

00:09:10.310 --> 00:09:12.930
And as, you know, API consumers,
when you're using an API,

00:09:12.930 --> 00:09:16.310
you don't have to guess whether
it's 32- or 64-bit compatible.

00:09:16.320 --> 00:09:20.110
So it's the whole consistency story.

00:09:20.420 --> 00:09:25.040
In addition to NSInteger and NSUInteger,
we have one more change,

00:09:25.140 --> 00:09:28.480
and that concerns the float data type.

00:09:28.480 --> 00:09:31.650
Now both Quartz and Cocoa and
other Cocoa-based APIs in

00:09:31.660 --> 00:09:36.300
Mac OS X use the float data type
for specifying graphical quantities.

00:09:36.300 --> 00:09:41.480
This includes coordinates, sizes,
color components, and so on.

00:09:41.700 --> 00:09:42.920
Now floats are great.

00:09:43.040 --> 00:09:47.990
Floats are already a step above what
some other systems did or we used to do

00:09:47.990 --> 00:09:49.930
with fixed numbers or integers and so on.

00:09:49.950 --> 00:09:52.120
They have a large range and
they have good accuracy.

00:09:52.120 --> 00:09:54.860
However, sometimes it's not good enough.

00:09:54.900 --> 00:09:59.140
We do get bugs from developers who say,
I have a view that's 10 million

00:09:59.170 --> 00:10:02.970
pixels or 10 million points high,
and when I scroll to the bottom,

00:10:02.970 --> 00:10:04.680
it's just not pixel perfect.

00:10:04.680 --> 00:10:08.510
Or when I zoom in 800 times in my view,
things are not, you know,

00:10:08.510 --> 00:10:11.180
weird things are happening
with the drawing.

00:10:11.180 --> 00:10:14.940
And that's because floating point numbers
start to fall apart at those limits.

00:10:14.940 --> 00:10:19.940
So what we decide to do is in 64-bit,
instead of float, we're switching to the

00:10:19.940 --> 00:10:21.790
double in all these APIs.

00:10:21.800 --> 00:10:25.860
So again, we have another CG float type
introduced in Quartz and used

00:10:25.860 --> 00:10:30.100
in Cocoa and Carbon as well to
represent these graphical quantities.

00:10:30.100 --> 00:10:33.100
And note that all dependent
types like NSRect,

00:10:33.110 --> 00:10:34.240
NSSize, etc.

00:10:34.240 --> 00:10:34.630
are also in Cocoa.

00:10:34.680 --> 00:10:36.660
And we're also now in terms of this type.

00:10:36.680 --> 00:10:38.680
The interesting thing about this change,
by the way,

00:10:38.680 --> 00:10:42.580
is it's not dictated by the LP64 change.

00:10:42.700 --> 00:10:46.000
It has nothing to do with 64-bit,
but we're taking advantage of

00:10:46.000 --> 00:10:51.070
this binary incompatibility change
to introduce this other change.

00:10:52.400 --> 00:10:55.030
Okay,
so let me talk about porting to 64-bit.

00:10:55.110 --> 00:10:57.200
Some source code changes
aren't necessary to port.

00:10:57.200 --> 00:10:58.840
You know,
you might take your application,

00:10:58.840 --> 00:11:01.260
you might try to build it,
and it might build if you're lucky.

00:11:01.260 --> 00:11:04.160
However, changes are likely needed.

00:11:04.160 --> 00:11:06.060
First of all,
there are a number of deprecated,

00:11:06.070 --> 00:11:06.920
unavailable APIs.

00:11:06.920 --> 00:11:08.340
You might have to get off those.

00:11:08.340 --> 00:11:11.160
In addition,
if you do not change your source code,

00:11:11.190 --> 00:11:15.100
and if you're using ints and floats,
it's likely that your program will not

00:11:15.280 --> 00:11:17.780
be taking full advantage of 64-bit.

00:11:17.840 --> 00:11:20.440
So you really want to
switch to NS integers,

00:11:20.440 --> 00:11:23.240
NSU integers,
CG floats throughout your code

00:11:23.240 --> 00:11:27.600
to take advantage of 64-bit when
you convert your application.

00:11:27.600 --> 00:11:31.410
The good thing is we provide the
script to help you convert your code,

00:11:31.410 --> 00:11:32.790
and it's a TOPS script.

00:11:32.870 --> 00:11:34.750
So some of you might be wondering, TOPS?

00:11:34.770 --> 00:11:36.640
Is this some new thing Apple has done?

00:11:36.640 --> 00:11:39.770
And the answer is no,
it's been there about 15, 16 years, but,

00:11:39.770 --> 00:11:41.680
you know, it still feels pretty fresh.

00:11:41.680 --> 00:11:47.780
It's sort of a refactoring engine of
sorts that works on C and Objective-C.

00:11:47.800 --> 00:11:51.780
And it basically, you give it a script,
and you give it some source files,

00:11:51.800 --> 00:11:53.740
and it does its thing in place.

00:11:53.740 --> 00:11:57.120
And now I want to show you
how to run this on TextEdit.

00:11:57.210 --> 00:12:00.110
Can we switch to the demo machine,
please?

00:12:02.740 --> 00:12:06.300
Okay, now as I said,
it does work in place.

00:12:06.300 --> 00:12:08.290
So first thing you want to do is
you want to take your sources and

00:12:08.290 --> 00:12:09.700
you want to make a copy of them.

00:12:09.700 --> 00:12:13.530
So here I have the
Tiger sources for text edit.

00:12:13.600 --> 00:12:16.390
I'm going to go ahead and duplicate this.

00:12:17.540 --> 00:12:20.390
There you go, text edit, tiger copy,
and let's just call it new so

00:12:20.390 --> 00:12:21.600
it's clear what we're doing.

00:12:21.600 --> 00:12:25.380
Now, TOPS requires a terminal window.

00:12:25.380 --> 00:12:29.260
We have not yet integrated
into any of the new refactoring

00:12:29.260 --> 00:12:30.540
things we have in Xcode.

00:12:30.540 --> 00:12:33.330
Now, I want to go into that folder.

00:12:33.330 --> 00:12:35.800
Let's just drag and drop here.

00:12:35.800 --> 00:12:37.500
And you want to run TOPS.

00:12:37.500 --> 00:12:40.500
Now, one argument you can give TOPS is
the semi-verbose argument,

00:12:40.500 --> 00:12:42.060
which means show me what you're doing.

00:12:42.060 --> 00:12:46.710
Then you specify this script file,
and the script file in

00:12:46.710 --> 00:12:52.100
this case is developer,
extras, 64-bit, Cocoa.TOPS.

00:12:52.100 --> 00:12:54.920
And then you give it the name of
the files you want to run it on.

00:12:54.920 --> 00:12:56.990
We just want to run it
on all our source files,

00:12:56.990 --> 00:12:58.100
H files and M files.

00:12:58.100 --> 00:13:00.000
So here is how you might run TOPS.

00:13:00.060 --> 00:13:01.230
Go ahead and run it.

00:13:01.230 --> 00:13:04.100
And it runs through your files,
and it's done.

00:13:04.100 --> 00:13:05.550
As you can see, it showed the progress.

00:13:05.570 --> 00:13:07.800
And text edit isn't very big,
so it was pretty quick.

00:13:07.870 --> 00:13:08.810
We can hide terminal.

00:13:08.860 --> 00:13:11.060
Now, next thing I want to do
is launch File Merge.

00:13:11.060 --> 00:13:16.400
And File Merge is the best way to
look at what the TOPS script did.

00:13:16.400 --> 00:13:19.400
I'm going to open this
File Merge window a bit.

00:13:19.540 --> 00:13:23.310
This allows me to drag
the original sources here.

00:13:23.500 --> 00:13:54.600
[Transcript missing]

00:13:54.960 --> 00:13:58.080
Now, you're looking at this thinking,
Windows count,

00:13:58.080 --> 00:14:01.810
and this need saving argument here is
the number of documents that need saving.

00:14:01.810 --> 00:14:05.670
These are not quantities that are
ever going to be more than 4 billion,

00:14:05.670 --> 00:14:06.200
ever.

00:14:06.200 --> 00:14:09.060
So this change seems unnecessary,
and I'm going to undo it.

00:14:09.060 --> 00:14:12.090
On the other hand, the truth is,
these values were never going

00:14:12.090 --> 00:14:13.600
to be up to 32-bit anyway.

00:14:13.600 --> 00:14:16.320
We used an int in the 32-bit world,
and truthfully,

00:14:16.320 --> 00:14:17.750
you could have used a short.

00:14:17.750 --> 00:14:19.600
You might have even used a char.

00:14:19.600 --> 00:14:21.740
But we went ahead and used int,
because that's the

00:14:21.900 --> 00:14:23.520
natural thing for 32-bits.

00:14:23.720 --> 00:14:26.550
And in 64-bit,
the natural thing is to use long.

00:14:26.560 --> 00:14:29.990
So in cases like this,
where you have local variables,

00:14:30.220 --> 00:14:32.920
arguments,
go ahead and use the NSU integer.

00:14:32.920 --> 00:14:34.010
Don't fight it.

00:14:34.010 --> 00:14:36.880
Just accept it, and things will be fine.

00:14:36.880 --> 00:14:40.560
And really, in 64-bit world,
these things are in registers,

00:14:40.560 --> 00:14:42.030
and they're plenty fast.

00:14:42.040 --> 00:14:45.230
So that's the one kind of
change you'll see TOPS doing.

00:14:45.230 --> 00:14:47.690
Now, another kind of change is down here,
this one.

00:14:47.690 --> 00:14:51.430
TOPS will drop these pound
warnings in your code where

00:14:51.430 --> 00:14:53.660
it thinks it wants your help.

00:14:53.720 --> 00:14:56.190
In this case, it dropped this,
because it saw a call

00:14:56.230 --> 00:14:58.340
to string with format,
and it wasn't sure how

00:14:58.340 --> 00:14:59.640
to handle the arguments.

00:14:59.650 --> 00:15:02.190
Now, note that there's a %d here,
and the argument it

00:15:02.190 --> 00:15:05.260
corresponds to is need saving,
which is an NSU integer.

00:15:05.260 --> 00:15:07.150
Now, %d refers to an int.

00:15:07.150 --> 00:15:11.570
You would need to do %ld for long,
while need saving is going to be

00:15:11.570 --> 00:15:14.620
int in 32-bit and long in 64-bit.

00:15:14.630 --> 00:15:17.910
We don't have a % specifier
for an NSU integer.

00:15:17.910 --> 00:15:22.630
So this is a case where you sort
of have to think about what to do.

00:15:23.010 --> 00:15:26.900
And the recommended solution that
we do is just go ahead and use %ld.

00:15:26.930 --> 00:15:31.970
Oh, and to edit in FileMerge,
you open up this spiffy lower panel here,

00:15:31.970 --> 00:15:34.420
which lets you customize the changes.

00:15:34.490 --> 00:15:35.420
So let's do that.

00:15:35.500 --> 00:15:36.660
Let me just scroll this up a bit.

00:15:36.740 --> 00:15:40.660
So I'm going to go change to %ld,
and I'm going to go cast

00:15:40.660 --> 00:15:42.740
the need saving to a long.

00:15:42.740 --> 00:15:46.890
Now, some of you might be thinking, oh,
casting, that's so distasteful.

00:15:52.280 --> 00:15:55.720
So %d says pick a long argument,
and here we're making sure

00:15:55.720 --> 00:15:57.240
this argument is long.

00:15:57.300 --> 00:15:59.710
So this is a perfectly safe,
very localized change,

00:15:59.720 --> 00:16:01.880
and it's totally appropriate
to do in this case.

00:16:01.880 --> 00:16:03.260
And so we go ahead and do it.

00:16:03.320 --> 00:16:04.940
And this works for both 32-bit.

00:16:04.940 --> 00:16:08.920
In the 32-bit, it acts just like before,
and in 64-bit, it also works.

00:16:08.920 --> 00:16:09.800
We won't get any warnings.

00:16:09.800 --> 00:16:11.500
So you can go ahead and
delete this warning.

00:16:11.500 --> 00:16:15.200
Now, I will not go through
this file one by one.

00:16:15.200 --> 00:16:17.680
I'll just scroll quickly,
and I want to show you one more case.

00:16:21.560 --> 00:16:23.400
So this is a case that's going
to be sort of lame at the moment.

00:16:23.400 --> 00:16:25.890
It didn't need to put this warning
because there was nothing to worry about,

00:16:25.990 --> 00:16:26.800
but it did anyway.

00:16:26.800 --> 00:16:29.060
In those cases,
just go ahead and delete the warning.

00:16:29.120 --> 00:16:30.770
So I'm going to save this and close it.

00:16:30.860 --> 00:16:33.060
Let me open another file
to show you another case.

00:16:33.120 --> 00:16:35.100
This is multiple page view.

00:16:35.110 --> 00:16:36.760
It's a subclass of NSView.

00:16:36.760 --> 00:16:40.430
Note that the instance variable
unsigned was changed to NSU integer.

00:16:40.530 --> 00:16:45.100
For instance variables,
you should probably pause a

00:16:45.100 --> 00:16:50.730
bit and think about whether you
really want it to be NSU integer.

00:16:50.830 --> 00:16:50.840
If the value is not likely
to go to above 4 billion,

00:16:50.870 --> 00:16:52.840
you can leave it as an integer.

00:16:52.840 --> 00:16:58.560
Instance variables and other data types,
other values that go into core data,

00:16:58.560 --> 00:17:01.690
backing stores, your documents,
etc., you might think about whether

00:17:01.690 --> 00:17:04.540
they need to be 64-bit because
they are a little more persistent

00:17:04.540 --> 00:17:05.930
than stack variables and so on.

00:17:05.970 --> 00:17:07.800
Now, in this case,
we have very few instances of

00:17:07.800 --> 00:17:09.440
multiple page view in the application.

00:17:09.440 --> 00:17:11.820
There's only one per document,
so I'm not going to worry about it.

00:17:11.880 --> 00:17:13.520
And in most cases,
that's probably the right thing to do.

00:17:13.520 --> 00:17:15.920
But if you have object that's
allocated by the thousands,

00:17:15.920 --> 00:17:20.120
you might want to think about how big
the instance variables are getting.

00:17:20.210 --> 00:17:22.480
So, with this, I'm not going to go
through the rest of this.

00:17:22.480 --> 00:17:23.620
It's pretty straightforward.

00:17:23.670 --> 00:17:27.430
But I'm going to go open a version
of TextEdit where I have fixed all

00:17:27.440 --> 00:17:29.220
the pound warnings and nothing else.

00:17:29.220 --> 00:17:31.520
So everything else is as TOPS did.

00:17:31.520 --> 00:17:35.050
So let's go ahead and open
this version of TextEdit.

00:17:36.100 --> 00:17:37.560
Let's make this window bigger.

00:17:37.620 --> 00:17:41.730
Now I'm going to go ahead and

00:17:43.250 --> 00:17:45.000
There we are.

00:17:45.060 --> 00:17:48.220
I'm going to go ahead and
open the build inspector.

00:17:48.260 --> 00:17:50.930
And you can see that
it's set to build I386.

00:17:51.060 --> 00:17:53.100
Let's go ahead and build this.

00:17:53.100 --> 00:17:55.900
And it's compiling and there it's done.

00:17:55.900 --> 00:18:00.100
If you can see down here,
it compiled without any warnings.

00:18:00.100 --> 00:18:04.610
Let's go ahead and bring the
inspector up again and change to

00:18:04.700 --> 00:18:07.990
64-bit build and go ahead and build.

00:18:08.400 --> 00:18:10.300
And you see that there's
already a few warnings.

00:18:10.300 --> 00:18:12.910
Let's go take a look at
what warnings we've gotten.

00:18:12.960 --> 00:18:15.690
The first one is about NSFont
methods not being there.

00:18:15.700 --> 00:18:18.040
And again,
this is due to the deprecated or

00:18:18.040 --> 00:18:19.820
unavailable APIs I mentioned earlier.

00:18:19.820 --> 00:18:23.040
Some deprecated APIs,
we've totally removed them in 64-bit,

00:18:23.050 --> 00:18:25.960
and that's why you're getting
this warning or this error when

00:18:25.960 --> 00:18:28.110
you're trying to build for 64-bit.

00:18:28.300 --> 00:18:30.180
So let's go look at this case here.

00:18:30.180 --> 00:18:31.270
Width of string.

00:18:31.440 --> 00:18:34.300
Now you might be wondering
how I deal with this.

00:18:34.300 --> 00:18:38.430
Command double click brings up NSFont.h,
and you see that this is an

00:18:38.430 --> 00:18:41.880
NSFont deprecated category,
and it says something about

00:18:41.880 --> 00:18:44.130
use string drawing API instead.

00:18:44.130 --> 00:18:45.080
Ah, that's good.

00:18:45.100 --> 00:18:47.750
With that,
I will go ahead and delete these

00:18:47.840 --> 00:18:51.380
two lines which have errors in them,
and I'll trust my demo

00:18:51.380 --> 00:18:54.370
assistant to do the right thing,
and it did.

00:18:54.500 --> 00:18:56.500
So as you can see,
size with attributes is the

00:18:56.530 --> 00:18:58.280
replacement for width of string.

00:18:58.280 --> 00:19:00.600
And this is the more
modern way to do this.

00:19:00.600 --> 00:19:01.570
So this is good.

00:19:01.570 --> 00:19:05.240
Let's save this, and let's go ahead and
look at our other warning.

00:19:05.240 --> 00:19:08.020
There's this warning
about glyph is encoded.

00:19:08.020 --> 00:19:10.990
This also is one of
those deprecated methods.

00:19:10.990 --> 00:19:13.580
For that,
we need to get rid of these lines

00:19:13.630 --> 00:19:15.660
and introduce two other lines.

00:19:15.660 --> 00:19:16.440
There we go.

00:19:16.560 --> 00:19:19.800
And finally,
we're getting a warning from QSort.

00:19:19.800 --> 00:19:21.400
Let's open that one.

00:19:21.400 --> 00:19:24.530
Now QSort is, as you know,
a low-level function,

00:19:24.530 --> 00:19:27.090
and we're giving it a compare function.

00:19:27.160 --> 00:19:28.280
It's compare.

00:19:28.280 --> 00:19:30.890
It's complaining about
the return type of this.

00:19:30.890 --> 00:19:33.920
If we search for this encoding compare,
which is up here,

00:19:33.950 --> 00:19:37.480
you see that it was changed by
the script to return an S integer.

00:19:37.480 --> 00:19:41.380
But QSort, being a low-level function,
doesn't know about an S integer.

00:19:41.420 --> 00:19:42.680
It really wants an int.

00:19:42.690 --> 00:19:45.200
So in this case,
we can undo what the script did,

00:19:45.200 --> 00:19:46.890
change this back to an int.

00:19:46.930 --> 00:19:48.980
Now this is something you
might have noticed when you

00:19:48.980 --> 00:19:51.350
were going through file merge,
but of course I left it here so

00:19:51.410 --> 00:19:52.810
that we could enjoy this moment.

00:19:52.820 --> 00:19:54.950
So with that, I'm going to save this.

00:19:54.950 --> 00:19:58.270
I'm going to close it,
and I'm going to go ahead and build.

00:19:58.330 --> 00:20:00.610
So I'm going to open the app again,
and it builds.

00:20:00.650 --> 00:20:00.860
No problem.

00:20:00.860 --> 00:20:03.810
So let's go ahead and run this.

00:20:04.940 --> 00:20:08.900
And there you go.

00:20:08.900 --> 00:20:10.900
This is a 64-bit text edit.

00:20:10.900 --> 00:20:14.660
I won't try to prove it right now to you,
but you can do this yourselves

00:20:14.660 --> 00:20:16.880
and see that it's indeed 64-bit.

00:20:16.920 --> 00:20:20.890
Okay, if you can go back to the slides,
please.

00:20:24.210 --> 00:20:26.290
Okay, so the one question you
might be thinking is,

00:20:26.300 --> 00:20:27.570
"Text-ed is 64-bit.

00:20:27.660 --> 00:20:30.720
Does that mean I should port my
application to 64-bit?" And the

00:20:30.720 --> 00:20:33.200
answer to this is complicated.

00:20:33.270 --> 00:20:35.180
Frameworks, libraries, plugins.

00:20:35.210 --> 00:20:37.200
If you own a framework,
if you own a library,

00:20:37.200 --> 00:20:39.200
if you own a plugin that
other developers use,

00:20:39.200 --> 00:20:42.160
please go ahead and make it
available in 64-bit so those other

00:20:42.160 --> 00:20:45.140
developers can make the decision
to move to 64-bit themselves.

00:20:45.240 --> 00:20:48.160
They need to have everything
they depend on be 64-bit.

00:20:48.200 --> 00:20:50.200
For applications, it depends.

00:20:50.200 --> 00:20:53.170
Again, as I said,
some applications really need it,

00:20:53.270 --> 00:20:54.200
others maybe not.

00:20:54.200 --> 00:20:56.170
Should they be ported in Leopard?

00:20:56.200 --> 00:20:57.200
You know, we don't know.

00:20:57.200 --> 00:21:00.590
By the way,
the more detailed answer to that

00:21:00.850 --> 00:21:04.200
will be in the next session at 2 p.m.

00:21:04.200 --> 00:21:08.200
But it really depends on
what you're trying to do.

00:21:08.200 --> 00:21:11.800
Just as an aside,
the 64-bit Text-ed I showed you does have

00:21:11.920 --> 00:21:16.200
the added feature that it can actually
open documents greater than 4 gigabytes,

00:21:16.200 --> 00:21:18.170
which is what the old
Text-ed could not do.

00:21:18.290 --> 00:21:19.200
And the Text system supports that.

00:21:19.200 --> 00:21:20.200
So it's added.

00:21:20.200 --> 00:21:21.200
It's actually capable.

00:21:21.200 --> 00:21:24.200
It already has some benefit that
the 32-bit one didn't give you.

00:21:24.200 --> 00:21:26.170
But is that good enough
reason to port to 64-bit?

00:21:26.210 --> 00:21:28.200
Again, it's really case by case.

00:21:28.200 --> 00:21:32.140
In any case, we encourage you to
write 64-bit clean code,

00:21:32.200 --> 00:21:36.200
meaning for new code, use CGFloat,
use an S-integer, use an SU-integer.

00:21:36.200 --> 00:21:38.200
Once in a while, build with 64-bit.

00:21:38.200 --> 00:21:39.990
Make sure you're on the
right track so that if you do

00:21:39.990 --> 00:21:43.200
decide to port at some point,
it's no big transition,

00:21:43.200 --> 00:21:44.200
no big porting work.

00:21:44.200 --> 00:21:49.200
And that would make it
easy for you at that point.

00:21:49.320 --> 00:21:54.300
More information about the conversion
process and what it does to your code is

00:21:54.300 --> 00:21:57.420
in the 64-bit Transition Guide for Cocoa,
which you can download

00:21:57.480 --> 00:21:59.200
from the WWDC Connect site.

00:21:59.200 --> 00:22:03.480
And we also have 64-bit labs,
three of them, tomorrow, Thursday,

00:22:03.590 --> 00:22:06.140
and Friday, where we'll have engineers,
many engineers available to

00:22:06.140 --> 00:22:07.200
help answer your questions.

00:22:07.200 --> 00:22:10.380
And there will also be machines
if you want to come actually test

00:22:10.380 --> 00:22:14.160
out your 64-bit applications since
you can't do it on your laptops.

00:22:14.270 --> 00:22:15.160
Okay.

00:22:15.230 --> 00:22:17.670
With that,
I'm going to invite Mark Petrueli

00:22:17.670 --> 00:22:18.200
on stage to talk about Uniforce.

00:22:18.200 --> 00:22:22.150
on stage to talk about
uniform type identifiers.

00:22:26.700 --> 00:22:28.340
Thank you, Ali.

00:22:28.340 --> 00:22:33.090
So, back in Pantherd,
we added a new facility to launch

00:22:33.090 --> 00:22:36.260
services called Uniform Type Identifiers,
UTIs.

00:22:36.260 --> 00:22:39.220
And now in Leopard,
we're adding full support to

00:22:39.220 --> 00:22:41.410
UTIs for UTIs throughout Cocoa.

00:22:41.420 --> 00:22:45.710
So, a really, really quick overview,
if you're not familiar.

00:22:45.710 --> 00:22:46.820
What is a UTI?

00:22:46.820 --> 00:22:50.290
Well, Uniform Type Identification
abstracts the concept of type.

00:22:50.600 --> 00:22:53.150
So, if you've been working with Cocoa,
you know, historically,

00:22:53.170 --> 00:22:56.270
we have a bunch of different namespaces
that all really represent the same thing,

00:22:56.270 --> 00:22:57.440
you know, file types.

00:22:57.440 --> 00:23:02.490
There's file name extensions like RTF,
there's HFS type codes like RTF space,

00:23:02.490 --> 00:23:06.340
and there's pasteboard type names,
RTF keyboard type.

00:23:06.410 --> 00:23:09.840
The kind of strings that fly
around in the NS Document API,

00:23:09.840 --> 00:23:12.790
rich text format,
also sometimes used as the user

00:23:12.850 --> 00:23:15.040
visible form of the file format.

00:23:15.040 --> 00:23:18.450
And you don't see much of this in Cocoa,
but there's MIME types to deal with, too.

00:23:19.820 --> 00:23:23.890
What UTIs does for you is it
provides a unified hierarchical

00:23:23.890 --> 00:23:25.700
identification system.

00:23:25.700 --> 00:23:29.730
So, you get to just work with this
one type namespace throughout

00:23:29.730 --> 00:23:32.010
all the code in your application.

00:23:32.060 --> 00:23:34.610
And the goal there,
the benefit is to reduce the

00:23:34.610 --> 00:23:36.600
complexity of your application.

00:23:36.600 --> 00:23:41.760
Another benefit, though,
is the fact that we can build in

00:23:41.770 --> 00:23:46.010
information about a lot of different file
formats right into the operating system.

00:23:46.020 --> 00:23:49.420
It's in this core types
bundle deep within the system.

00:23:49.420 --> 00:23:49.420
Like, if you're using a file type,
you're going to have to have a

00:23:49.420 --> 00:23:49.560
lot of different file formats.

00:23:49.560 --> 00:23:49.620
It's in this core types
bundle deep within the system.

00:23:49.660 --> 00:23:54.070
And you can see the names of the
types that we support in launch

00:23:54.070 --> 00:23:56.840
services slash utcoretypes.h.

00:23:56.840 --> 00:23:58.960
If you're importing Cocoa.h,
you're getting this header.

00:23:58.960 --> 00:24:01.900
Just a quick sample of
what you'll find there.

00:24:01.970 --> 00:24:07.580
Public.RTF, for instance, is the UTI,
the uniform type identifier

00:24:07.680 --> 00:24:10.470
string for the rich text format.

00:24:10.480 --> 00:24:15.810
And this reveals right here
a really big feature of UTIs,

00:24:15.810 --> 00:24:19.560
the fact that it's a
hierarchical type namespace.

00:24:19.560 --> 00:24:24.630
Rich text format documents
are plain text documents.

00:24:24.670 --> 00:24:26.560
I'm sorry,
they're not plain text documents,

00:24:26.560 --> 00:24:27.800
they're text documents.

00:24:27.800 --> 00:24:30.440
And this is reflected by
the fact that the UTI,

00:24:30.440 --> 00:24:34.300
public.RTF,
is said to conform to public.text.

00:24:34.300 --> 00:24:37.880
And so these are the ones, you know,
there's a bunch of them declared

00:24:37.910 --> 00:24:40.140
right in Tiger and in Leopard.

00:24:40.140 --> 00:24:42.110
And, of course,
you get to declare your own

00:24:42.110 --> 00:24:45.040
types that are identified by
uniform type identifiers in

00:24:45.040 --> 00:24:46.670
your application's Info.plist.

00:24:46.700 --> 00:24:49.440
So what are we doing to
support all this stuff?

00:24:49.560 --> 00:24:50.020
We're supporting Cocoa.h.

00:24:50.060 --> 00:24:53.220
Now in Leopard,
we're supporting them pretty much

00:24:53.290 --> 00:24:57.420
everywhere you would expect we would
in your Info.plist declarations.

00:24:57.440 --> 00:24:59.360
We added a bunch of
methods to this workspace.

00:24:59.360 --> 00:25:02.440
And this document controller,
whose APIs deal very

00:25:02.440 --> 00:25:06.040
heavily in file types,
now deal in UTIs.

00:25:06.040 --> 00:25:08.450
OpenPanel and SavePanel take UTIs.

00:25:08.460 --> 00:25:09.840
Pasteboard takes UTIs.

00:25:09.860 --> 00:25:14.480
And a miscellany of other AppKit classes
also take UTIs or applicable.

00:25:14.480 --> 00:25:17.190
And, you know, one nice,
another nice benefit of all

00:25:17.190 --> 00:25:21.510
this is there's now a better,
match between Cocoa and other

00:25:21.520 --> 00:25:25.690
relatively new APIs in Leopard,
like Spotlight's metadata

00:25:25.690 --> 00:25:28.330
framework and image IO framework.

00:25:30.900 --> 00:25:33.570
So what kind of stuff will
you find in your application's

00:25:33.570 --> 00:25:35.900
Info.plist if you're using UTIs?

00:25:35.900 --> 00:25:38.900
Well, just to go back,
if you're writing an application

00:25:38.900 --> 00:25:41.010
that doesn't take advantage
of any Leopard features,

00:25:41.010 --> 00:25:42.900
it looks something
like what's on the top.

00:25:42.900 --> 00:25:46.360
This is like the document type
declaration for text edit,

00:25:46.360 --> 00:25:47.900
for rich text format.

00:25:47.900 --> 00:25:50.390
And you have to put the
file name extension,

00:25:50.390 --> 00:25:50.900
RTF.

00:25:50.900 --> 00:25:54.900
You have to specify a
file name for the icon,

00:25:54.900 --> 00:25:58.840
a corresponding MIME type,
a type name that will be

00:25:58.840 --> 00:26:00.900
used in NSDocument APIs.

00:26:00.900 --> 00:26:03.920
And by the way,
NSRTF pBoard type is actually an

00:26:03.920 --> 00:26:07.900
abbreviation that we allow you to put in
your Info.plist for a much longer string

00:26:07.900 --> 00:26:09.900
that's more or less human readable.

00:26:09.900 --> 00:26:14.900
And then also the HFS type code,
the four character code, RTF.

00:26:14.900 --> 00:26:16.860
So if you look at the
one on the bottom now,

00:26:16.860 --> 00:26:19.900
if you're writing an application
that just depends on Leopard,

00:26:19.900 --> 00:26:23.900
you don't have to declare all
that stuff because in this case,

00:26:23.900 --> 00:26:26.900
RTF is actually declared
as part of the system.

00:26:26.900 --> 00:26:30.090
So you can just say public.rtf.

00:26:31.650 --> 00:26:34.000
Now we know we want you to use
these new Leopard features,

00:26:34.000 --> 00:26:37.860
but of course we also know that
you want to ship applications very

00:26:37.860 --> 00:26:39.600
often that still run on Tiger.

00:26:39.600 --> 00:26:43.450
In the case of this feature,
we're really paying attention to

00:26:43.450 --> 00:26:45.600
what it will take for you to do that.

00:26:45.610 --> 00:26:49.590
So it turns out it's pretty convenient
that you can just leave all the

00:26:49.590 --> 00:26:53.450
Tiger stuff in your Info.plist and just
add a little bit of stuff to start taking

00:26:53.450 --> 00:26:55.600
advantage of UTIs in your application.

00:26:55.600 --> 00:27:04.600
So LS Item Content Types in this
example is ignored by Cocoa on Tiger.

00:27:04.600 --> 00:27:07.600
Launch Services still pays
attention to it on Tiger.

00:27:07.620 --> 00:27:11.460
But because it's pretty much
consistent with all that other stuff,

00:27:11.460 --> 00:27:14.030
you can't really tell
that Launch Services is

00:27:14.030 --> 00:27:15.600
doing anything on Tiger.

00:27:15.600 --> 00:27:21.340
Except when it's being used
from other applications,

00:27:21.340 --> 00:27:22.730
of course.

00:27:25.630 --> 00:27:31.940
On Leopard,
these things are ignored by Cocoa because

00:27:32.090 --> 00:27:36.610
there is an LS Item Content types
entry and that's its trigger to

00:27:36.610 --> 00:27:39.160
start ignoring the old stuff.

00:27:41.080 --> 00:27:44.490
These ones, CFBundle type name and
CFBundle icon file,

00:27:44.500 --> 00:27:45.760
are optional.

00:27:45.760 --> 00:27:48.550
They were required on Tigrip and
now they're optional on Leopard.

00:27:48.670 --> 00:27:52.760
These are what you still provide even in
an all-Leopard application if you want

00:27:52.760 --> 00:27:59.750
to override the default user visible
name for a file format and its icon.

00:28:01.900 --> 00:28:03.400
So, and this brings up an issue.

00:28:03.400 --> 00:28:07.860
I said that LS Item Content Types
triggers a bunch of new behavior.

00:28:07.940 --> 00:28:11.630
Well, for backward binary compatibility,
it takes more than that.

00:28:11.640 --> 00:28:14.310
You have to link your
application against the version

00:28:14.340 --> 00:28:16.780
of Cocoa that's part of Leopard.

00:28:17.000 --> 00:28:19.610
So, this is something to pay attention
to the first time you build

00:28:19.610 --> 00:28:22.150
your application on Leopard,
is that if you have

00:28:22.150 --> 00:28:26.480
LS Item Content Types in your Info.plist,
all of a sudden a whole bunch of

00:28:26.480 --> 00:28:29.110
new strings are going to start
flying around in NS Document,

00:28:29.110 --> 00:28:31.490
Document Controller API,
and some of your subclasses

00:28:31.490 --> 00:28:32.970
may need updating for that.

00:28:33.030 --> 00:28:34.910
So, and of course,
if you just want to stick

00:28:34.910 --> 00:28:37.560
with the old behavior,
well, that's what the SDKs are for.

00:28:37.560 --> 00:28:39.900
You can just link against the 10.4 SDK.

00:28:42.230 --> 00:28:46.400
So, some new methods we added to
NSWorkspace where we're putting

00:28:46.400 --> 00:28:51.240
most of the new support for
UTIs that requires new methods.

00:28:51.260 --> 00:28:55.040
Type of file error
given a path to a file,

00:28:55.090 --> 00:28:59.960
return its UTI or an error that you
can present to the user explaining what

00:28:59.960 --> 00:29:02.480
went wrong while trying to do that.

00:29:02.750 --> 00:29:04.700
Localized description for type.

00:29:04.700 --> 00:29:08.440
If you need to show the user
the name of a file format,

00:29:08.440 --> 00:29:10.920
like an alert or something like that,
this is the method to call.

00:29:10.920 --> 00:29:13.500
Preferred file name extension for type.

00:29:13.500 --> 00:29:18.290
If you're writing out a file and you need
to know which file name extension to slap

00:29:18.290 --> 00:29:22.930
on the end of the name so that it gets
identified properly as the correct type,

00:29:22.930 --> 00:29:25.300
this is the method to use for that.

00:29:26.160 --> 00:29:29.560
File name extension is valid
for type is actually something

00:29:29.560 --> 00:29:31.280
that's used by save panel.

00:29:31.280 --> 00:29:38.280
And why we introduced this is because in
this hierarchical namespace now of UTIs,

00:29:38.280 --> 00:29:43.650
you really have to ask the
exact correct question.

00:29:43.660 --> 00:29:47.370
You can't just get the file name
extension for UTI and then compare

00:29:47.370 --> 00:29:49.660
it to the one that the user typed in.

00:29:49.660 --> 00:29:55.540
You sort of have to let Cocoa with
launch services help answer the question.

00:29:56.160 --> 00:30:00.440
So save panel uses this when it's
letting the user type a file name

00:30:00.510 --> 00:30:04.330
extension to see if it's one that works.

00:30:04.560 --> 00:30:06.460
And the last one is pretty important.

00:30:06.520 --> 00:30:09.170
Type conforms to type,
returns a yes or no answer.

00:30:09.210 --> 00:30:14.710
Answers the question,
is this first type a

00:30:14.710 --> 00:30:17.360
subtype of the second one?

00:30:17.360 --> 00:30:20.770
So if you pass this
public.rtf and public.text,

00:30:20.770 --> 00:30:22.140
it'll return yes.

00:30:22.860 --> 00:30:25.910
And this is what you're going
to use in a lot of places

00:30:25.910 --> 00:30:28.100
instead of just comparing UTIs.

00:30:28.100 --> 00:30:30.650
You don't just compare
them for string equality,

00:30:30.650 --> 00:30:33.850
you do this conformance check and
it opens up a lot of flexibility

00:30:33.940 --> 00:30:35.690
in what your applications do.

00:30:37.530 --> 00:30:40.500
So NS Document Controller has
also been heavily updated.

00:30:40.500 --> 00:30:43.400
Methods like, there's a bunch of methods
that have been updated,

00:30:43.440 --> 00:30:44.690
but I'll just go through a few of them.

00:30:44.700 --> 00:30:49.350
Default type in an application
whose types are declared with UTIs

00:30:49.350 --> 00:30:54.460
will pick one of the document type
declarations from the Info.plist.

00:30:54.460 --> 00:30:57.780
And because LS Item Content Types
is actually an array,

00:30:57.780 --> 00:31:00.630
it'll return the first
UTI out of that array.

00:31:00.640 --> 00:31:06.300
So the order of the UTIs listed in
that array matters for some things.

00:31:07.860 --> 00:31:11.990
Make Untitled Document of Type Error and
all the other creation routines have all

00:31:12.000 --> 00:31:17.790
been updated to accept UTIs in addition
to the old style NS Document type

00:31:17.790 --> 00:31:20.110
names that were used before.

00:31:21.520 --> 00:31:28.740
Type for contents of
URL returns the UTI for a file.

00:31:28.770 --> 00:31:34.170
And with the type that's returned,
if you're checking to see can

00:31:34.170 --> 00:31:36.500
my application handle this,
you don't do the equality check.

00:31:36.500 --> 00:31:41.270
You use that NSWorkspace
type conforms to type method.

00:31:42.430 --> 00:31:45.820
And methods of AppKit's own,
like NSDocumentController,

00:31:45.820 --> 00:31:48.020
DocumentClusterType, do do that.

00:31:48.140 --> 00:31:51.410
They use type conformance so
that if the type of a file is

00:31:51.410 --> 00:31:54.600
something that wasn't even known
when your application was created,

00:31:54.610 --> 00:31:59.100
but does conform to one of the types
that your application claims to handle,

00:31:59.100 --> 00:32:01.050
your application will
be able to handle it,

00:32:01.070 --> 00:32:03.280
even though the file name
extension is brand new,

00:32:03.280 --> 00:32:05.840
was invented after you
shipped your application.

00:32:06.780 --> 00:32:10.150
As long as, by the way,
the application that declares that type,

00:32:10.150 --> 00:32:12.580
you know, declares the type conformance.

00:32:13.970 --> 00:32:16.990
Two methods that we're not updating,
file extensions from type

00:32:16.990 --> 00:32:21.450
and type from file extension,
don't work correctly with UTIs and

00:32:21.450 --> 00:32:24.720
we're not making them work with UTIs,
we're just deprecating them because they

00:32:24.720 --> 00:32:30.790
answer questions that don't make so much
sense anymore in the context of UTIs.

00:32:31.560 --> 00:32:34.130
And likewise,
NSDocument has been updated.

00:32:34.130 --> 00:32:39.690
So, readable types and writable types are
default implementations with return UTIs.

00:32:39.720 --> 00:32:43.250
IsNativeType gets this conformance
checking concept right.

00:32:43.260 --> 00:32:48.760
NSDocument has always
been very customizable.

00:32:48.760 --> 00:32:50.590
It's a really heavily overridden class.

00:32:50.660 --> 00:32:54.680
We want to maintain that customizability
as we add new facilities to it.

00:32:54.740 --> 00:32:57.820
So, just to make sure everything
stays open to you,

00:32:57.820 --> 00:33:01.090
we're adding this method,
file name extension for type

00:33:01.150 --> 00:33:02.740
colon save operation colon.

00:33:02.740 --> 00:33:05.730
And it's used when NSDocument
is going to save a file,

00:33:05.730 --> 00:33:10.730
but it doesn't know what file name
extension to put on it yet because

00:33:10.810 --> 00:33:14.740
it's being done because of auto-saving
or scripting or something like that.

00:33:14.740 --> 00:33:17.960
It'll call this,
and if you have a complicated plug-in

00:33:17.960 --> 00:33:21.320
mechanism or something like that,
you'll get a chance to

00:33:21.320 --> 00:33:23.400
control what NSDocument does.

00:33:25.500 --> 00:33:30.240
So when your application is using UTIs
because it has these LS item content

00:33:30.240 --> 00:33:34.350
types entries in its info P list,
they're going to be flying around in

00:33:34.350 --> 00:33:37.880
all the method invocations between
NSDocument and Document Controller.

00:33:37.880 --> 00:33:41.850
And if you're subclassing one of these,
your subclasses are going

00:33:41.850 --> 00:33:43.780
to have to understand UTIs.

00:33:43.780 --> 00:33:47.520
So you're probably going to have to
update them when you switch to UTIs.

00:33:47.520 --> 00:33:52.420
And this is a good opportunity if
you're updating what NSDocument methods

00:33:52.420 --> 00:33:56.630
your application overrides anyway,
to stop overriding the ones

00:33:56.630 --> 00:33:59.790
we deprecated in Tiger,
which by the way haven't been updated

00:33:59.790 --> 00:34:01.350
at all to handle this UTI stuff.

00:34:01.360 --> 00:34:06.920
So take the opportunity to get off
the NSDeprecated methods and start

00:34:06.920 --> 00:34:09.900
using uniform type identifiers.

00:34:09.900 --> 00:34:13.380
And a great side benefit of this
is much better error handling,

00:34:13.380 --> 00:34:17.080
which is why we introduced all
those methods into NSDocument.

00:34:17.360 --> 00:34:19.510
in Tiger.

00:34:20.730 --> 00:34:25.940
The open panel and the save panel have
likewise been updated to accept UTIs.

00:34:25.970 --> 00:34:30.200
They had methods that would
take arrays that were,

00:34:30.200 --> 00:34:35.090
we allowed you to mix file name
extensions and HFS type codes together.

00:34:35.220 --> 00:34:37.900
Now you can mix UTIs in with all those,
and we have a reliable

00:34:37.930 --> 00:34:40.620
way to distinguish them,
so we can support this without

00:34:40.620 --> 00:34:42.390
having to add any new methods.

00:34:44.270 --> 00:34:49.400
Their implementations understand the
rules that you just don't compare UTIs,

00:34:49.400 --> 00:34:52.760
you check one UTI for
conformance with another.

00:34:52.760 --> 00:34:59.310
And likewise,
save panel accepts and returns UTIs.

00:35:00.750 --> 00:35:02.900
Pasteboard, of course,
has been updated too.

00:35:02.900 --> 00:35:07.700
So, you know, it's going to be nice,
it's going to be less code because

00:35:07.700 --> 00:35:12.810
there's just one unified namespace,
one uniform unified namespace,

00:35:12.810 --> 00:35:15.820
for all the types that
exist in your applications.

00:35:15.820 --> 00:35:18.460
There's not going to be pasteboard
types and file name extensions anymore.

00:35:18.820 --> 00:35:21.060
So there's just UTIs.

00:35:21.150 --> 00:35:25.200
And now you can pass
UTIs like KUT type TIFF,

00:35:25.200 --> 00:35:29.450
which is the
Launch Services Declaration for

00:35:29.450 --> 00:35:34.610
public.TIFF,
right into pasteboard methods.

00:35:35.470 --> 00:35:40.480
Methods like NSPasteboard types
for backward compatibility

00:35:40.480 --> 00:35:44.540
still return the old type names,
so you don't have to update any code.

00:35:44.540 --> 00:35:50.980
They also now, mixed right into the list,
return the new type names, the UTIs.

00:35:51.000 --> 00:35:55.880
And we've done this before,
mixing the old and the new style type

00:35:55.880 --> 00:36:00.490
names in the arrays that we return,
and your code is expected to

00:36:00.490 --> 00:36:04.010
pick out the ones it cares about,
and that's worked out pretty well,

00:36:04.010 --> 00:36:05.280
and so we're doing it here too.

00:36:05.400 --> 00:36:11.010
Now I know some of you have already tried
to pass UTIs to NSPasteboard methods,

00:36:11.020 --> 00:36:12.230
and it didn't work.

00:36:12.240 --> 00:36:16.430
For instance, you promised data of a
specific type using a UTI,

00:36:16.430 --> 00:36:21.920
and when NSPasteboard called back
for you to fulfill that promise,

00:36:21.920 --> 00:36:25.460
the string was just
not what you passed in.

00:36:25.460 --> 00:36:28.550
So now that we're officially
supporting UTIs with NSPasteboard,

00:36:28.660 --> 00:36:30.630
if you pass in a UTI and
you make a promise,

00:36:30.630 --> 00:36:33.360
you'll get that same UTI back
when you're asked to fulfill

00:36:33.360 --> 00:36:35.320
the Pasteboard data promise.

00:36:35.400 --> 00:36:36.580
- Thanks.

00:36:38.040 --> 00:36:39.840
So other AppKit classes.

00:36:39.910 --> 00:36:43.590
NSImage and NSImageRep have a
pretty sophisticated system for

00:36:43.620 --> 00:36:49.380
determining what subclass of
NSImageRep should be instantiated for

00:36:49.380 --> 00:36:52.700
a particular pasteboard item or file.

00:36:52.700 --> 00:36:56.290
And that's all being updated
to take advantage of UTIs.

00:36:56.290 --> 00:36:59.770
And we're doing it in such a way
that you don't have to update

00:36:59.880 --> 00:37:03.760
your entire application to use
this new typing scheme at once.

00:37:03.820 --> 00:37:07.580
So if you're overriding
NSImageRep and it overrides the

00:37:07.580 --> 00:37:12.190
methods that return type names,
you can start overriding the new

00:37:12.190 --> 00:37:14.590
methods that return UTIs instead.

00:37:14.600 --> 00:37:19.470
Without having to, for instance,
update all your invocations

00:37:19.470 --> 00:37:23.600
of the NSImage methods
that instantiate NSImages.

00:37:23.640 --> 00:37:25.190
And vice versa.

00:37:25.200 --> 00:37:28.380
So you don't have to do your
whole application all at once.

00:37:28.440 --> 00:37:31.390
And this is all, of course,
documented in great detail

00:37:31.390 --> 00:37:32.780
in the release notes.

00:37:32.780 --> 00:37:38.630
NSSound and AppKit's additions to
the distributed string have the same

00:37:38.630 --> 00:37:42.280
sort of methods for handling the
types of things that get loaded.

00:37:42.280 --> 00:37:44.280
And likewise, they've been updated.

00:37:44.280 --> 00:37:50.310
So let me show you a quick
demo of some of this stuff.

00:38:09.650 --> 00:38:14.200
So let me show you just one of the
methods that you might be overriding

00:38:14.270 --> 00:38:16.070
in an application like TextEdit.

00:38:16.070 --> 00:38:20.030
Updated to use UTIs now instead
of the old style type names.

00:38:20.040 --> 00:38:21.360
This one is default type.

00:38:21.360 --> 00:38:26.060
TextEdit has a preference when
you create a new document.

00:38:26.060 --> 00:38:29.260
You want to create a rich text
document or a plain text document.

00:38:29.260 --> 00:38:33.960
And which one it does is control by
this document controller default type,

00:38:33.960 --> 00:38:39.580
which it overrides just to get the
value from the preference and pick one.

00:38:39.600 --> 00:38:42.750
UTI or the other.

00:38:43.650 --> 00:38:44.910
No big whoop.

00:38:44.910 --> 00:38:50.640
Let me show you the InfoP list
for what TextEdit looks like now.

00:38:50.640 --> 00:38:53.460
And by the way,
TextEdit in Leopard has been updated

00:38:53.460 --> 00:38:55.600
to be an NSDocument based application.

00:38:55.600 --> 00:39:00.910
So when I show you TextEdit,
as far as the user shouldn't

00:39:00.910 --> 00:39:03.540
see any difference we're hoping,
but now you have more

00:39:03.550 --> 00:39:05.100
NSDocument example code.

00:39:05.100 --> 00:39:11.280
So one of the nice things about just the
way this is arranged in the InfoP list

00:39:11.330 --> 00:39:18.380
now is because you can list so many
UTIs in one document type declaration,

00:39:18.380 --> 00:39:22.610
it ends up being,
your InfoP list ends up being a great bit

00:39:22.650 --> 00:39:24.380
shorter and simpler than the old ones.

00:39:24.400 --> 00:39:27.430
So TextEdit handles
seven document formats,

00:39:27.430 --> 00:39:31.040
including some Microsoft Word ones
and Open Document,

00:39:31.090 --> 00:39:32.560
all in the same way.

00:39:32.620 --> 00:39:33.590
So we just list them all.

00:39:33.600 --> 00:39:36.590
They all result in instantiation
of the document class,

00:39:36.650 --> 00:39:38.600
and it's an editor for all of them.

00:39:38.600 --> 00:39:45.800
We break out rich text into its own
entry because we have this little "Ls

00:39:45.800 --> 00:39:48.600
is Apple default for type" on there.

00:39:48.600 --> 00:39:51.960
So that's a little TextEdit trick
to make sure that it gets to look

00:39:51.960 --> 00:39:55.570
at the rich text documents when
the user is clicking on things.

00:39:55.600 --> 00:39:59.110
So, and then the last thing,
the other reason to have a

00:39:59.110 --> 00:40:02.600
separate document type declaration
is because for a few types,

00:40:02.600 --> 00:40:05.600
um, TextEdit is just a viewer.

00:40:05.600 --> 00:40:09.140
So for this UTI,
which identifies old style

00:40:09.140 --> 00:40:12.100
simple text documents,
TextEdit can view them,

00:40:12.100 --> 00:40:13.600
but it doesn't try and save them.

00:40:13.600 --> 00:40:17.550
And for public data,
this is one of the super types

00:40:17.690 --> 00:40:19.600
of pretty much everything.

00:40:19.600 --> 00:40:23.060
And, you know,
can you really open any file in TextEdit?

00:40:23.110 --> 00:40:23.600
No.

00:40:23.600 --> 00:40:25.600
But TextEdit is meant to
be a really general tool,

00:40:25.600 --> 00:40:26.090
so it's game.

00:40:26.100 --> 00:40:29.390
It claims it'll open public.data.

00:40:31.770 --> 00:40:34.840
Now, just to show you something
actually running,

00:40:34.840 --> 00:40:39.840
let me show you a little
user interface refinement.

00:40:39.840 --> 00:40:42.870
You know how in open panels
you're supposed to disable the

00:40:42.870 --> 00:40:47.340
files that the application can't
actually open successfully?

00:40:47.340 --> 00:40:50.620
And we really weren't able to do
that correctly in TextEdit before

00:40:50.620 --> 00:40:55.180
because we want to make sure that
people who are using TextEdit as the

00:40:55.180 --> 00:40:59.650
editor of the last resort don't get
hassled by the open panel saying,

00:40:59.650 --> 00:41:03.010
"No,
TextEdit doesn't know how to to open it.

00:41:03.040 --> 00:41:06.000
So what we did is--

00:41:08.300 --> 00:41:15.810
We're using just the regular Info
P-List declaration from TextEdit.

00:41:17.900 --> 00:41:22.740
We're saying that TextEdit
can open any text document.

00:41:22.740 --> 00:41:27.860
So when you look at its open panel now,
it can open any text document,

00:41:27.860 --> 00:41:31.440
including .h files,
and TextEdit didn't have to list .h

00:41:31.440 --> 00:41:37.380
files explicitly in its Info.plist,
but not icon files,

00:41:37.380 --> 00:41:43.080
because the icon file type is
not declared to be a subtype

00:41:43.080 --> 00:41:46.430
of text or anything like that.

00:41:47.360 --> 00:41:49.760
So, you know,
this is a little bit better UI, but,

00:41:49.760 --> 00:41:52.050
you know,
TextEdit as the editor of last resort,

00:41:52.050 --> 00:41:54.520
we don't want to, you know,
hassle our users.

00:41:54.520 --> 00:41:56.680
They're like, you know,
let me just open it.

00:41:56.700 --> 00:42:00.390
So we added this checkbox
to open any type,

00:42:00.390 --> 00:42:07.040
and that makes, you know, the open panel,
you know, enable this file.

00:42:07.040 --> 00:42:09.340
So, and TextEdit will give it a go.

00:42:09.340 --> 00:42:11.210
Garbage in, garbage out.

00:42:11.210 --> 00:42:19.250
So, so to do this UI,
what we did is we overrode the

00:42:19.250 --> 00:42:24.450
NSOpenPanel delegate method
that controls this stuff.

00:42:25.310 --> 00:42:28.770
And if the preference is set
to open file of any type,

00:42:28.770 --> 00:42:30.100
it returns yes.

00:42:30.100 --> 00:42:35.130
And if it doesn't,
what it does is it invokes

00:42:35.130 --> 00:42:38.670
this NSWorkspace method that
I keep telling you about.

00:42:38.670 --> 00:42:41.040
It gets the UTI of the file.

00:42:41.600 --> 00:42:46.470
And then one thing you have to do here,
if it's a folder in an open panel,

00:42:46.470 --> 00:42:51.920
you have to return yes so that the open
panel will let you navigate into that.

00:42:51.950 --> 00:42:53.100
And we check to do that.

00:42:53.100 --> 00:42:57.520
We just see if whatever the file type is,
if it conforms to the folder type,

00:42:57.590 --> 00:42:58.840
just return yes.

00:42:58.840 --> 00:43:03.110
And otherwise, well,
let's see if it's readable according

00:43:03.110 --> 00:43:06.160
to what's declared in the application.

00:43:06.160 --> 00:43:11.560
So, and Texas Document Controller has
a pretty simple method.

00:43:11.600 --> 00:43:12.490
It's readable type.

00:43:12.500 --> 00:43:17.900
And it goes through all the types that
all the subclasses of NSDocument has.

00:43:17.900 --> 00:43:21.020
There's just one, but it's general code,
so it goes through the list.

00:43:21.040 --> 00:43:26.860
And it does stuff like if
it conforms to the type,

00:43:26.860 --> 00:43:28.640
it says yes.

00:43:28.640 --> 00:43:35.950
So it's able to do the proper UI while
still handling a wide variety of file

00:43:35.950 --> 00:43:40.780
formats that aren't even known at
the time that TextEdit is shipping.

00:43:41.670 --> 00:43:44.840
So that's it for the demo.

00:43:44.850 --> 00:43:46.540
Slides.

00:43:51.900 --> 00:43:54.020
So that's about it for UTIs.

00:43:54.020 --> 00:43:55.900
If you're writing a new
application for Leopard,

00:43:55.900 --> 00:43:58.480
we want you to start using
UTIs right away because it's

00:43:58.480 --> 00:44:02.370
going to simplify your code,
your application is going to mesh well

00:44:02.400 --> 00:44:07.440
with all the new API that we and other
groups keep introducing into Mac OS X.

00:44:08.260 --> 00:44:12.040
And if your application needs to
run on both Tiger and Leopard,

00:44:12.040 --> 00:44:14.880
we still want you to
give it a try using UTIs.

00:44:14.880 --> 00:44:17.920
You'll have to pay
attention to some issues,

00:44:17.920 --> 00:44:21.440
but you'll be able to get a
few improved type handling

00:44:21.440 --> 00:44:25.020
and interoperability features,
and you'll still be able to

00:44:25.020 --> 00:44:27.720
make your application work
on Tiger while you do that.

00:44:27.780 --> 00:44:31.760
So for more information about UTIs,
it's in the place it's been

00:44:31.780 --> 00:44:33.940
for a while now on the website.

00:44:33.940 --> 00:44:37.940
So developer.apple.com, Mac OS X,
uniform type identifiers.

00:44:38.260 --> 00:44:40.420
No spaces or underscores.

00:44:40.430 --> 00:44:42.450
And for information
about what's in Cocoa,

00:44:42.530 --> 00:44:44.570
please, please read our release notes.

00:44:44.570 --> 00:44:48.660
This is one of the issues about
which it is really detailed.

00:44:48.660 --> 00:44:52.410
So it's on the website, you know,
release notes slash

00:44:52.480 --> 00:44:54.720
Cocoa slash appkit dot html.

00:44:56.200 --> 00:44:59.160
So with that,
I'd like you to invite Kevin Perry on

00:44:59.160 --> 00:45:02.070
the stage to talk to you about
resolution independence in Cocoa.

00:45:02.080 --> 00:45:03.750
Thank you.

00:45:10.500 --> 00:45:13.440
As you can tell,
I'm the intern in the AppKit group,

00:45:13.460 --> 00:45:16.390
and it's kind of obvious because
I'm the only one actually

00:45:16.390 --> 00:45:17.860
wearing the T-shirt they gave us.

00:45:17.860 --> 00:45:22.780
But I will be talking to you
about resolution independence.

00:45:24.800 --> 00:45:28.920
And what it means for you and
your applications in Cocoa.

00:45:28.920 --> 00:45:32.680
So really quick,
what is resolution independence?

00:45:32.680 --> 00:45:35.810
When you draw in resolution
independence in your programs,

00:45:35.810 --> 00:45:41.030
there isn't really a direct relationship
between the size of your drawing that

00:45:41.030 --> 00:45:43.500
you're drawing in your applications
and the size it's actually going

00:45:43.500 --> 00:45:46.230
to be rendered to on the screen.

00:45:46.430 --> 00:45:51.400
And you've always drawn in
units that are called points,

00:45:51.400 --> 00:45:53.200
which are resolution independent.

00:45:53.320 --> 00:45:56.430
And of course,
screen coordinates are pixels.

00:45:56.610 --> 00:46:01.460
And with resolution independence,
another way to define it is that one

00:46:01.460 --> 00:46:06.200
point will not map to a pre-known
number of pixels on the screen.

00:46:06.370 --> 00:46:08.750
So let's go over what exactly that means.

00:46:08.750 --> 00:46:15.100
And with Cocoa, we've always had a
resolution independent model.

00:46:15.100 --> 00:46:18.100
As you can see here in this diagram,
there are three different

00:46:18.240 --> 00:46:19.690
coordinate systems.

00:46:19.700 --> 00:46:23.700
First, on the screen,
that of course is its own coordinate

00:46:23.700 --> 00:46:25.980
system represented in pixels.

00:46:26.860 --> 00:46:29.130
The window coordinate system,
which we also call the

00:46:29.140 --> 00:46:32.620
base coordinate system,
is also represented in pixels.

00:46:32.620 --> 00:46:36.380
And the view inside the window
has its own coordinate system,

00:46:36.380 --> 00:46:39.330
which we also call the
local coordinate system,

00:46:39.330 --> 00:46:41.490
which is represented in points.

00:46:41.750 --> 00:46:44.990
And we can say that Cocoa has
sort of a resolution independent

00:46:45.000 --> 00:46:48.020
model because on views,
we're able to apply certain

00:46:48.020 --> 00:46:51.190
transformations to them,
such as this view.

00:46:51.190 --> 00:46:57.500
We've just applied a 1.5x scale
factor or zoom factor to it.

00:46:57.620 --> 00:47:05.120
And it's now no longer 450 by 600 points,
but 300 by 400 points.

00:47:05.120 --> 00:47:07.280
And so there,
we can kind of say there's not

00:47:07.280 --> 00:47:10.690
a direct mapping between points
and pixels as there was before.

00:47:12.600 --> 00:47:18.000
Until this point, Cocoa hasn't,
in a general sense,

00:47:18.000 --> 00:47:22.720
taken advantage of this model for
drawing its user interface elements.

00:47:22.720 --> 00:47:24.330
And you as developers,
when you do your drawing

00:47:24.330 --> 00:47:27.850
in your applications,
you could assume that you've got

00:47:27.980 --> 00:47:33.700
a one-to-one mapping of points
to pixels and be generally safe.

00:47:33.700 --> 00:47:36.280
However,
you can no longer make that assumption

00:47:36.280 --> 00:47:39.990
because of the changes we're
making to resolution independence.

00:47:40.940 --> 00:47:45.680
So to go over what problems we
have with resolution independence,

00:47:45.680 --> 00:47:52.060
as technology advances and we have
displays with higher pixel densities,

00:47:52.060 --> 00:47:55.440
we get additional quality,
which is a good thing.

00:47:55.440 --> 00:47:58.390
However, take this example here.

00:47:58.390 --> 00:48:04.920
We've got a 72 dpi screen with a
window that's 600 by 900 pixels,

00:48:04.990 --> 00:48:08.840
and it's drawn fine on the 72 dpi screen.

00:48:09.280 --> 00:48:14.200
However, without any modifications,
we run that on a 144 dpi screen,

00:48:14.200 --> 00:48:21.590
and you can see that you basically have
to squint to see anything in the view.

00:48:21.830 --> 00:48:25.830
So this isn't a desired effect at all.

00:48:25.840 --> 00:48:31.020
And our solution for this is to have
Cocoa automatically apply a scaling

00:48:31.020 --> 00:48:36.360
factor to the top level view and the
entire view hierarchy inside your

00:48:36.530 --> 00:48:40.590
windows so that it will be scaled
to a comfortable size for users.

00:48:40.690 --> 00:48:45.550
So in this example,
whereas the window in the 72

00:48:45.560 --> 00:48:51.740
DPI screen was 600 by 900 pixels,
we apply a scale factor of 2.0.

00:48:51.770 --> 00:48:56.490
So we resize the window to
be 1,200 by 1,800 pixels.

00:48:56.560 --> 00:49:00.560
And you notice that the view is
still inside 450 by 600 points.

00:49:00.630 --> 00:49:03.100
That's because points are
resolution independent.

00:49:03.170 --> 00:49:07.100
And so we can scale the entire
coordinate system without actually

00:49:07.100 --> 00:49:09.090
changing the coordinates within it.

00:49:10.900 --> 00:49:12.060
So just a quick overview.

00:49:12.060 --> 00:49:16.330
Remember that you've got
screen frame units in pixels,

00:49:16.340 --> 00:49:21.510
window frame units also in pixels,
and view frame and balance units

00:49:21.510 --> 00:49:24.400
in resolution independent points.

00:49:26.530 --> 00:49:31.930
So when you do computations of
coordinates for custom layout or whatnot,

00:49:31.930 --> 00:49:35.580
you need to make sure that you're
in the correct coordinate system.

00:49:37.000 --> 00:49:43.070
NSView has always provided API for
you to convert between coordinate

00:49:43.070 --> 00:49:48.140
systems and different views
and also to the window space.

00:49:48.140 --> 00:49:53.240
You can see here that we're
converting a rectangle from view nil,

00:49:53.240 --> 00:49:57.440
which means that we're converting
the rectangle from the window space,

00:49:57.440 --> 00:50:02.210
that's what the nil means,
to the local space of the view.

00:50:02.500 --> 00:50:04.000
And here we're doing the opposite.

00:50:04.000 --> 00:50:08.160
We're converting the rectangle to
the window space by passing nil

00:50:08.160 --> 00:50:09.200
as the second parameter there.

00:50:09.200 --> 00:50:14.670
And of course there is a similar
API for points and sizes.

00:50:17.710 --> 00:50:21.060
Something you have been able to
do before the advent of resolution

00:50:21.060 --> 00:50:24.930
independence is the following,
where you want to compute the

00:50:24.930 --> 00:50:28.410
content rect for your window,
and so you get the window frame,

00:50:28.410 --> 00:50:33.870
and just do a simple subtraction
to find the rectangle that's

00:50:33.870 --> 00:50:36.230
for your content view.

00:50:36.240 --> 00:50:39.680
However,
that obviously will not work when you've

00:50:39.680 --> 00:50:44.520
got a scale factor that's not 1.0,
because you're going between

00:50:44.520 --> 00:50:46.670
coordinate systems there.

00:50:48.120 --> 00:50:52.050
And so the correct thing to do is
use the NSWindow API that's existed

00:50:52.050 --> 00:50:54.390
since 10.0 to do this for you.

00:50:54.490 --> 00:50:59.640
You just get the window frame and then
pass it to content rect for frame rect,

00:50:59.740 --> 00:51:04.250
and that will automatically apply the,
take into account the

00:51:04.250 --> 00:51:06.920
scale factor for you.

00:51:10.510 --> 00:51:15.560
And in Cocoa, it's always been optimal,
of course, to draw on pixel boundaries.

00:51:15.560 --> 00:51:18.420
And that was easy when you could
assume that one point was equal to

00:51:18.430 --> 00:51:22.550
one pixel because you could just,
in a local coordinate system,

00:51:22.600 --> 00:51:25.310
align things to points.

00:51:26.500 --> 00:51:30.090
However, if you have, for example,
a non-integral scale factor

00:51:30.100 --> 00:51:33.220
now with resolution dependence,
and you integralize all

00:51:33.220 --> 00:51:35.970
your point boundaries,
then when it's converted

00:51:35.970 --> 00:51:37.840
up to the screen,
you're going to have

00:51:37.840 --> 00:51:41.960
non-integral pixel boundaries,
which is going to cause certain effects

00:51:41.960 --> 00:51:44.860
in your drawing that are not desirable.

00:51:44.860 --> 00:51:52.100
So the correct thing to do is not use,
for example, nsintegral rect, floor,

00:51:52.190 --> 00:51:55.780
round, whatever on point values.

00:51:56.540 --> 00:51:57.900
In the local coordinate system.

00:51:57.900 --> 00:52:03.420
Use the API that I just talked about
to convert to window coordinates first.

00:52:03.420 --> 00:52:07.260
So here we've got a rectangle that
we're first converting to window space.

00:52:07.260 --> 00:52:10.570
Then we can use nsintegral rect,
and then convert back to view space

00:52:10.570 --> 00:52:12.420
so that we can draw it in our view.

00:52:14.070 --> 00:52:19.060
And there is a method on
NSVUE called center scan rect,

00:52:19.120 --> 00:52:24.240
which we intend to handle
the basic case for you,

00:52:24.240 --> 00:52:25.260
the most common case.

00:52:25.260 --> 00:52:31.440
And the method works somewhat in
the seed that you've got right now.

00:52:31.440 --> 00:52:33.990
It's not perfect,
but we do intend to improve

00:52:33.990 --> 00:52:35.560
it for Leopard release.

00:52:35.560 --> 00:52:39.300
But you can go ahead and
experiment with it now.

00:52:39.300 --> 00:52:42.720
This will do the conversion between
coordinate systems and all that for you.

00:52:45.430 --> 00:52:49.450
All right, so let me see who is really
proud of all their artwork in

00:52:49.450 --> 00:52:52.310
their Mac OS X applications.

00:52:54.310 --> 00:52:57.300
OK, I'm sure there are a lot of
you who like to boast about it.

00:52:57.300 --> 00:53:03.180
And it's really great because that's
part of the Mac OS X user experience.

00:53:03.180 --> 00:53:09.350
And we really appreciate all the effort
you do to make those good looking images.

00:53:09.490 --> 00:53:12.740
But as I said before,
with the scale factor applied

00:53:12.800 --> 00:53:17.090
to the entire view hierarchy,
we're also resizing all of

00:53:17.090 --> 00:53:19.700
your images automatically.

00:53:19.740 --> 00:53:23.650
So just imagine all of your
beautiful artwork scaled up to,

00:53:23.650 --> 00:53:25.730
say, twice its normal size.

00:53:25.840 --> 00:53:28.700
Probably not a pretty
picture in most cases.

00:53:28.700 --> 00:53:32.570
And so this is something that
Cocoa can't solve directly for you,

00:53:32.570 --> 00:53:35.700
but we do make it pretty
easy for you as developers,

00:53:35.700 --> 00:53:41.200
though it may not be quite so
easy for your graphic designers.

00:53:41.500 --> 00:53:45.500
So, there's two possible solutions.

00:53:45.500 --> 00:53:49.980
Where possible,
try to switch to vector-based art.

00:53:49.980 --> 00:53:54.140
That is obviously automatically
going to scale correctly and

00:53:54.140 --> 00:53:56.420
look great at any scale factor.

00:53:56.420 --> 00:54:00.440
However, for bitmap images,
if you need to use those,

00:54:00.440 --> 00:54:04.520
we suggest that you supply your
bitmaps at one time and four

00:54:04.640 --> 00:54:09.430
times their normal resolution
in a multi-representation TIFF.

00:54:10.390 --> 00:54:12.950
Making sure to set the
DPI appropriately so that they are

00:54:12.950 --> 00:54:14.570
actually drawn to the same size.

00:54:14.620 --> 00:54:17.910
And you can see an introspective
view of one of these images

00:54:17.910 --> 00:54:25.330
where we've got two image
representations with the same size but

00:54:25.930 --> 00:54:29.310
The first step is to create a new image.

00:54:29.400 --> 00:54:35.340
The image is going to be four times the
size for the second image representation.

00:54:35.350 --> 00:54:40.290
When you do that,
when you ask NS Image to draw your image,

00:54:40.290 --> 00:54:44.570
it will automatically look at
the scale factor and select the

00:54:44.570 --> 00:54:47.330
correct image representation.

00:54:47.360 --> 00:54:52.080
Using the quality image
interpolation that we have,

00:54:52.090 --> 00:54:55.210
scale that down to the correct size
and make sure that your images still

00:54:55.210 --> 00:54:55.210
look great at any scale factor.

00:54:55.500 --> 00:54:59.740
And as Chris Parker mentioned
in the previous talk,

00:54:59.740 --> 00:55:04.650
we do intend to publish several named
images that will use high res art

00:55:04.740 --> 00:55:08.550
for the most commonly used images,
such as the ad.

00:55:08.920 --> 00:55:12.080
and remove plus and minus signs.

00:55:12.120 --> 00:55:17.150
That's not in the seed at this point,
but we do intend to put that

00:55:17.160 --> 00:55:19.390
into the leopard release.

00:55:20.480 --> 00:55:22.680
OK, so we're going to have a quick Q&A,
but this is going to be kind

00:55:22.680 --> 00:55:26.300
of different because I'm going
to be asking all the questions,

00:55:26.310 --> 00:55:28.000
and you get to listen to all the answers.

00:55:28.040 --> 00:55:32.420
So you can wait until later
to ask all your questions.

00:55:32.420 --> 00:55:34.800
So the first question is,
how do I know what scale factor

00:55:34.800 --> 00:55:36.970
has been applied to my window?

00:55:37.220 --> 00:55:40.610
The answer is, well,
you really shouldn't need to know this.

00:55:40.830 --> 00:55:48.060
But NSWindow does provide API for this
in the user space scale factor method.

00:55:48.140 --> 00:55:53.040
And this might be useful in cases
where you want to maybe save your

00:55:53.040 --> 00:55:55.850
window frames to disk manually.

00:55:56.700 --> 00:56:02.220
So before you do this,
you want to invert the scale factor done

00:56:02.220 --> 00:56:07.820
to the window so that in case the window
is read from disk in an environment

00:56:07.820 --> 00:56:11.220
with a different scale factor,
it can be reapplied when you read it.

00:56:11.220 --> 00:56:14.100
And you don't get any explosions
of window size or anything.

00:56:14.100 --> 00:56:17.410
But remember,
this is not for use in converting between

00:56:17.600 --> 00:56:20.080
view and window coordinate systems.

00:56:20.120 --> 00:56:22.710
There are a lot of other
transformations that may be

00:56:22.710 --> 00:56:26.480
applied to your views that you just
can't take into account with this.

00:56:26.700 --> 00:56:29.800
So use the API that
we've provided in NSView.

00:56:29.800 --> 00:56:31.760
It's really the simplest way to do this.

00:56:31.760 --> 00:56:34.280
Next question is,
I have an offscreen view

00:56:34.290 --> 00:56:35.980
that shouldn't be scaled.

00:56:35.980 --> 00:56:37.920
How do I prevent automatic scaling?

00:56:37.920 --> 00:56:42.450
Well, in Tiger,
we've provided this ability for you

00:56:42.450 --> 00:56:48.240
using the NSUnscaledWindowMask when
applied to the NSBorderlessWindowMask.

00:56:48.300 --> 00:56:49.930
Yes, that's right.

00:56:50.000 --> 00:56:52.560
You can only use this
on borderless windows.

00:56:52.560 --> 00:56:55.410
But it's a pretty simple solution here.

00:56:55.420 --> 00:56:56.260
You just apply it.

00:56:56.770 --> 00:57:01.460
and pass it into the init method.

00:57:03.150 --> 00:57:04.540
Okay, next question.

00:57:04.540 --> 00:57:08.900
I happen to know that OpenGL has to
draw in pixels for it to be correct.

00:57:08.900 --> 00:57:10.960
How does that work in a scaled window?

00:57:10.960 --> 00:57:16.940
The answer is we're going to
make NSOpenGLView internally

00:57:16.950 --> 00:57:23.590
perform an inverse transform on
the bounds of the view so that

00:57:23.590 --> 00:57:31.400
internally the OpenGLView can
draw directly to pixel values.

00:57:31.400 --> 00:57:35.150
And externally, you're using the view.

00:57:35.150 --> 00:57:36.800
It'll be normal.

00:57:36.820 --> 00:57:39.660
The frame is still in points.

00:57:39.660 --> 00:57:44.060
So, all this is handled
automatically for you.

00:57:44.060 --> 00:57:46.740
You don't really need
to worry about this.

00:57:47.030 --> 00:57:51.830
But discuss that because for those of
you who have resolution dependent views,

00:57:51.830 --> 00:57:55.060
you can do the same
sort of transformation,

00:57:55.060 --> 00:57:56.220
though this shouldn't be very common.

00:57:57.720 --> 00:58:00.070
Last question,
probably one of the most important.

00:58:00.090 --> 00:58:03.630
How do I test my application
for resolution independence?

00:58:03.670 --> 00:58:07.460
We hope you all go and
do this fairly quickly,

00:58:07.490 --> 00:58:08.460
because it's fairly easy.

00:58:08.460 --> 00:58:13.640
You just launch Quartz Debug,
and you can find this window,

00:58:13.640 --> 00:58:16.300
the User Interface Resolution window.

00:58:16.320 --> 00:58:22.450
And we suggest choosing 1.25, 1.5,
and 2.0 as representative scale factors

00:58:22.450 --> 00:58:27.070
to see how your app will work in
general with resolution independence.

00:58:27.330 --> 00:58:30.220
And then relaunch your
application and see how it works.

00:58:30.460 --> 00:58:31.440
So it's that simple.

00:58:34.010 --> 00:58:41.100
OK,
continuing with the common theme here,

00:58:41.100 --> 00:58:41.100
we're going to--

00:58:41.210 --> 00:58:44.040
do resolution independence
check for text edit.

00:58:44.040 --> 00:58:47.530
So let's get the demo machine, please.

00:58:56.200 --> 00:58:59.240
Thank you.

00:58:59.240 --> 00:59:05.060
So let's go ahead and set, let's say,
just 2.0 scale factor.

00:59:05.060 --> 00:59:06.960
We're going to test this out.

00:59:06.960 --> 00:59:09.100
Launch text edit.

00:59:09.100 --> 00:59:10.140
Boom.

00:59:10.140 --> 00:59:13.020
That actually looks pretty good.

00:59:13.650 --> 00:59:15.810
We haven't done any
changes to this at all.

00:59:15.820 --> 00:59:22.340
We've got pretty much just standard
Cocoa controls and Cocoa text.

00:59:22.340 --> 00:59:26.160
So there's really not any work that
needs to be done to prepare a text

00:59:26.160 --> 00:59:28.580
edit for resolution independence.

00:59:28.680 --> 00:59:30.180
So no work done there.

00:59:30.180 --> 00:59:31.710
We really like that.

00:59:33.270 --> 00:59:39.430
For a more representative view of this,
we've prepared a little

00:59:39.430 --> 00:59:41.580
bit of sample code here.

00:59:41.580 --> 00:59:47.620
We've got a beginning of a Minesweeper
game that uses custom layout with images

00:59:47.620 --> 00:59:49.680
and so forth to draw its minefield.

00:59:49.810 --> 00:59:53.510
So here we've got a typical minefield.

00:59:53.530 --> 00:59:58.680
You can resize it or make
the minefield larger,

00:59:58.680 --> 00:59:59.200
whatever.

00:59:59.240 --> 01:00:00.970
Just really simple.

01:00:01.950 --> 01:00:07.910
But let's go ahead and run this at, say,
1.25 scale factor.

01:00:12.000 --> 01:00:14.430
I can't really see that there
on the projector very well,

01:00:14.430 --> 01:00:17.500
but I've launched Pixie here to show you.

01:00:17.500 --> 01:00:21.720
In between a lot of these images
are these pixel-wide cracks.

01:00:22.600 --> 01:00:26.230
And as I mentioned before,
this happens when we're drawing

01:00:26.240 --> 01:00:28.560
on non-integral pixel values.

01:00:28.560 --> 01:00:32.670
So there's something wrong
there with our drawing routines.

01:00:32.800 --> 01:00:36.710
And also when we try and
resize this minefield,

01:00:36.720 --> 01:00:39.170
the window isn't getting
set to the correct size.

01:00:39.280 --> 01:00:43.580
So let's go and investigate
what's going on there.

01:00:43.580 --> 01:00:50.180
Go ahead and open our View subclass here.

01:00:52.070 --> 01:00:55.070
Here we've got our drawRects,
and we're calculating the size

01:00:55.160 --> 01:00:59.000
of the rectangle here that we're
going to draw the image into.

01:00:59.120 --> 01:01:03.660
And here we're calling a method
which is just right up here.

01:01:03.660 --> 01:01:07.190
This is where we're integralizing
the rect and everything.

01:01:07.340 --> 01:01:11.760
And you know what,
we're doing this in view coordinates.

01:01:11.760 --> 01:01:14.130
We haven't done any sort
of transformation here.

01:01:14.240 --> 01:01:16.570
So let's go ahead and insert.

01:01:16.830 --> 01:01:22.620
The necessary method to convert
first to window coordinates.

01:01:22.970 --> 01:01:26.350
And then we can integrate this
directly in window coordinates.

01:01:26.400 --> 01:01:27.850
And then we convert back
to view coordinates,

01:01:27.880 --> 01:01:28.900
because that's what we have to draw in.

01:01:28.900 --> 01:01:31.940
So that should fix the
pixel crack problem.

01:01:31.940 --> 01:01:35.830
And down here,
where we set the number of squares,

01:01:35.830 --> 01:01:39.460
so this is where we're
resizing our window as well,

01:01:39.460 --> 01:01:42.590
right here,
we are computing the delta that

01:01:42.590 --> 01:01:45.090
we want to resize our window by.

01:01:45.090 --> 01:01:46.650
And you know what?

01:01:46.710 --> 01:01:50.570
We're doing that in terms
of view coordinates.

01:01:50.660 --> 01:01:55.980
So that isn't being set
correctly with our scale factor.

01:01:56.110 --> 01:02:05.260
So we want to make sure that we convert
the size first to window coordinates so

01:02:05.260 --> 01:02:06.840
that the window is resized correctly.

01:02:06.840 --> 01:02:13.680
And there's a little interesting behavior
of the convert size to view method.

01:02:13.680 --> 01:02:18.000
If you just happen to have
negative values in your size,

01:02:18.000 --> 01:02:20.640
when you pass it through
convert size to view,

01:02:20.640 --> 01:02:22.170
it's normalized to a positive value.

01:02:22.820 --> 01:02:29.180
So we actually have to,
before we convert it,

01:02:30.540 --> 01:02:36.040
We need to check whether
the size is negative.

01:02:36.090 --> 01:02:38.370
Save that state.

01:02:40.510 --> 01:02:48.460
And then, after we're done converting it,
we restore it.

01:02:48.870 --> 01:02:53.260
That should handle the window resizing,
and we'll just run this again.

01:02:53.260 --> 01:02:56.300
Again, we're still in 1.25 scale factor.

01:02:56.350 --> 01:02:59.860
And switch back over to Pixie here,
and you see there's not

01:02:59.860 --> 01:03:01.930
any pixel corrects anymore.

01:03:01.990 --> 01:03:05.300
We've solved that problem by making sure
that we're drawing on pixel boundaries.

01:03:05.310 --> 01:03:09.110
And when we resize the minefield,
it resizes it to the

01:03:09.110 --> 01:03:10.640
correct size of the window.

01:03:10.790 --> 01:03:14.570
So that looks pretty good
for preparing this app for

01:03:14.570 --> 01:03:17.980
resolution independence as well.

01:03:18.200 --> 01:03:22.880
So it could be that simple
for your applications as well.

01:03:22.880 --> 01:03:26.640
So let's switch over back
to the slides if we could.

01:03:27.500 --> 01:03:32.250
And let me invite Kristin Forster back
up for a summary of all the points

01:03:32.260 --> 01:03:34.340
that we've gone over in this talk.

01:03:41.900 --> 01:03:44.300
Thank you, Kevin.

01:03:44.300 --> 01:03:46.620
So to summarize,
we'd like you to consider converting

01:03:46.620 --> 01:03:50.140
your application to 64-bit for
increased data handling capabilities.

01:03:50.140 --> 01:03:52.500
And as Ali said,
this is especially important if you

01:03:52.610 --> 01:03:55.800
have a plug-in or a framework or a
library that somebody else is relying on.

01:03:55.800 --> 01:03:59.800
We'd like you to start using uniform type
identifiers for improved type management,

01:03:59.800 --> 01:04:04.900
and we'd like you to prepare your
application for resolution independence

01:04:04.900 --> 01:04:07.750
so it looks great on high DPI displays.

01:04:08.210 --> 01:04:11.520
For more information you
can contact Derek Horne,

01:04:11.520 --> 01:04:14.010
Application Frameworks Evangelist.

01:04:14.010 --> 01:04:17.690
You should also check out the
documentation attached to this

01:04:17.690 --> 01:04:19.970
session on the conference website.

01:04:20.770 --> 01:04:24.140
And please come see us in the
APCIT lab Thursday at 2:00.

01:04:24.140 --> 01:04:27.060
And as Ali mentioned,
there's also 64-bit labs

01:04:27.060 --> 01:04:28.290
running throughout the week.
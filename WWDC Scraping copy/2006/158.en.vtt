WEBVTT

00:00:10.510 --> 00:00:12.360
Good morning.

00:00:12.550 --> 00:00:15.580
Today we're going to be talking about,
in this session,

00:00:15.940 --> 00:00:21.370
something new in Leopard that
we call Identity Services.

00:00:21.890 --> 00:00:25.500
I was just yawning before I came out.

00:00:25.500 --> 00:00:28.760
I have to point out that if
you're going to have to give a

00:00:28.760 --> 00:00:32.090
big talk in the morning sometime,
I personally recommend if you

00:00:32.090 --> 00:00:34.850
want to look and feel your best,
you go to a big party the night

00:00:34.960 --> 00:00:38.140
before with lots of really loud
music that shakes your whole

00:00:38.140 --> 00:00:39.650
body and drink a bunch of beer.

00:00:39.650 --> 00:00:43.120
That works for me pretty well anyway.

00:00:44.380 --> 00:00:46.370
So with that in mind, let's get started.

00:00:46.370 --> 00:00:55.090
I thought that I would structure this
talk around some actual software,

00:00:55.190 --> 00:00:59.910
some sample code that we
want to add some features to.

00:00:59.920 --> 00:01:05.020
And so I'm going to start with kind
of an overview of where we are in

00:01:05.020 --> 00:01:10.680
Tiger with peer-to-peer networking
between Tiger systems and look at a

00:01:10.680 --> 00:01:14.270
sample app called Picture Sharing,
which is a software that we've

00:01:14.270 --> 00:01:14.300
been using for a long time.

00:01:14.380 --> 00:01:15.990
And then we're going to talk about
some of the features that we've

00:01:15.990 --> 00:01:18.870
been using for the developer tools,
and then talk a little bit

00:01:18.970 --> 00:01:22.260
about Identity Services,
and then integrate that into

00:01:22.330 --> 00:01:26.040
Picture Sharing so that at the end
we have a better Picture Sharing.

00:01:26.040 --> 00:01:27.510
And we'll see what it does.

00:01:27.560 --> 00:01:28.670
Thank you.

00:01:30.110 --> 00:01:34.800
So when I say peer-to-peer
collaboration in this session,

00:01:34.800 --> 00:01:38.210
what we're talking about
is connecting between,

00:01:38.210 --> 00:01:44.600
say, a Tiger system to a Tiger system
or Mac OS to Mac OS.

00:01:44.600 --> 00:01:49.690
Examples are personal file sharing,
screen sharing for system services,

00:01:49.740 --> 00:01:57.920
but also applications such as iTunes
music sharing or iPhoto album sharing.

00:01:57.920 --> 00:02:01.430
And maybe your application does
some similar resource sharing,

00:02:01.430 --> 00:02:04.110
which would hopefully be why you're here.

00:02:04.560 --> 00:02:09.900
The key thing about this kind
of collaboration is that we

00:02:09.900 --> 00:02:12.650
want to make sure it always
works well in ad hoc networks.

00:02:12.800 --> 00:02:17.560
And to that end, we have,
in addition to CF Network APIs for

00:02:17.560 --> 00:02:22.590
doing network connections,
of course we have Bonjour to support

00:02:22.590 --> 00:02:27.820
simple service browsing and discovery.

00:02:27.900 --> 00:04:02.600
[Transcript missing]

00:04:03.470 --> 00:04:06.500
At the same time,
we want to make sure that

00:04:06.500 --> 00:04:10.500
there's actual security,
good authentication going on.

00:04:11.180 --> 00:04:13.900
As I mentioned,
we want to make it work well

00:04:13.900 --> 00:04:18.580
both in managed networks
as well as ad hoc networks.

00:04:21.480 --> 00:04:26.900
And, of course, we want to maintain a
great user experience.

00:04:28.800 --> 00:04:32.200
So I mentioned we were
going to use a case study.

00:04:32.200 --> 00:04:37.760
This is a screenshot of an example
application called Picture Sharing.

00:04:37.760 --> 00:04:42.020
This is how it builds right now on Tiger,
how it looks.

00:04:42.020 --> 00:04:44.720
Really simple functionality
on the server side.

00:04:44.730 --> 00:04:47.720
You give your service a name.

00:04:47.720 --> 00:04:50.090
It's basically an example
code showing Bonjour,

00:04:50.180 --> 00:04:51.480
Service Discovery.

00:04:51.500 --> 00:04:54.780
So you give your service a name,
you click the Start button,

00:04:54.780 --> 00:04:59.280
and you pick a photo or an
image to share from a short list

00:04:59.280 --> 00:05:01.900
that the app makes available.

00:05:01.900 --> 00:05:06.040
On the client side,
this is the client app called

00:05:06.100 --> 00:05:08.160
Picture Sharing Browser.

00:05:08.160 --> 00:05:14.010
And it shows on the left
a list of picture sharing

00:05:14.090 --> 00:05:16.540
services found through Bonjour.

00:05:16.540 --> 00:05:20.220
And when you click on one,
it's a really simple-- I don't even

00:05:20.220 --> 00:05:21.730
know if you can call it a protocol.

00:05:21.740 --> 00:05:26.640
It just opens a stream and downloads the
image into the client so you can view it.

00:05:26.640 --> 00:05:28.980
No access controls at all.

00:05:30.570 --> 00:05:32.650
So what do we want to
do to picture sharing?

00:05:32.700 --> 00:05:35.870
There's four steps.

00:05:36.210 --> 00:05:40.850
First, we want on the server side,
whoever's sharing the picture,

00:05:40.850 --> 00:05:44.610
we want to be able to let
them specify who is going to

00:05:44.610 --> 00:05:49.050
be able to view the picture,
basically set up an access control list.

00:05:50.090 --> 00:05:56.350
Then we need to make that access
control list persist so that when you

00:05:56.490 --> 00:06:00.370
quit and restart your application,
we remember who is allowed

00:06:00.370 --> 00:06:02.030
to see the picture.

00:06:03.410 --> 00:06:07.820
When a connection request comes in,
we need to authenticate the connection,

00:06:07.930 --> 00:06:12.370
see who it is, and finally,
check if they're in the

00:06:12.370 --> 00:06:15.090
access control list,
if they have actually-- so

00:06:15.090 --> 00:06:16.430
do the authorization step.

00:06:16.560 --> 00:06:19.170
Do they have access to the picture?

00:06:21.050 --> 00:06:25.650
So what kinds of stuff do we need to
make this all work easier on Leopard

00:06:25.660 --> 00:06:28.000
and make this easy to implement?

00:06:28.010 --> 00:06:31.400
We need a bunch of infrastructure.

00:06:31.420 --> 00:06:34.980
And that's what Identity Services is.

00:06:34.990 --> 00:06:39.180
We want to make it easy for
applications to get information

00:06:39.180 --> 00:06:41.830
about users and groups,
both those that are defined

00:06:41.830 --> 00:06:45.550
locally or created locally,
as well as users and groups

00:06:45.730 --> 00:06:48.270
on a managed network,
such as in an LDAP or

00:06:48.270 --> 00:06:49.720
an Active Directory.

00:06:49.720 --> 00:06:53.280
things accessible through Open Directory.

00:06:54.120 --> 00:06:59.510
At the user experience level,
we want to beef up what we

00:06:59.510 --> 00:07:02.790
can do in system preferences,
account preferences,

00:07:02.960 --> 00:07:09.080
for managing local users and groups,
and also come up with some UI guidelines

00:07:09.200 --> 00:07:15.630
and some new UI elements to make it easy
for apps to manage access control lists.

00:07:17.290 --> 00:07:18.740
So first, the infrastructure part.

00:07:18.850 --> 00:07:23.080
Identity Services,
it's a new foundation for

00:07:23.080 --> 00:07:28.440
working with users and groups,
as I mentioned, both local users as well

00:07:28.440 --> 00:07:31.460
as managed network users.

00:07:31.490 --> 00:07:34.740
It's essentially built
on top of Open Directory.

00:07:34.850 --> 00:07:42.860
So any user record or group record
that's in the Open Directory--

00:07:43.130 --> 00:07:47.650
The identity store on your system
is expressed as an identity

00:07:47.650 --> 00:07:51.370
in the Identity Services API.

00:07:51.420 --> 00:07:56.310
At the same time,
Open Directory is a very open schema,

00:07:56.310 --> 00:07:57.960
a very open API.

00:07:57.960 --> 00:08:03.310
It doesn't really enforce any
kind of policy or uniqueness.

00:08:03.460 --> 00:08:07.810
It's pretty hard for applications
to go in and say modify a user

00:08:07.810 --> 00:08:10.840
or add members to a group.

00:08:10.840 --> 00:08:13.960
There's just a bunch of
data parsing you have to do,

00:08:13.960 --> 00:08:17.060
and you have to come up with unique IDs.

00:08:17.060 --> 00:08:20.690
And so the idea of Identity Services is
to enforce all of that policy,

00:08:20.790 --> 00:08:24.270
make sure we have data integrity,
and make it much easier to

00:08:24.270 --> 00:08:26.510
deal with users and groups.

00:08:27.680 --> 00:08:31.320
So here's where it fits
in the framework stack.

00:08:31.320 --> 00:08:35.160
It's part of the core services
framework here in the middle.

00:08:35.170 --> 00:08:39.940
As I mentioned, it's built on foundation
technologies in Darwin,

00:08:39.940 --> 00:08:43.320
such as Open Directory and
some other things.

00:08:43.320 --> 00:08:47.220
But it also sits below Carbon and Cocoa.

00:08:47.220 --> 00:08:52.040
So if you already have an application,
you don't have to change your linkage.

00:08:52.040 --> 00:08:54.980
You already have access to
everything in core services,

00:08:55.100 --> 00:08:57.990
including identity services on Leopard.

00:09:00.120 --> 00:09:03.440
So now I'd like to talk about
just the small number of concepts

00:09:03.590 --> 00:09:07.530
that you need to understand to
work with Identity Services.

00:09:07.620 --> 00:09:10.680
The first is just the
idea of a user identity.

00:09:10.680 --> 00:09:15.640
That's simply an identity or someone,
usually representing a person,

00:09:15.640 --> 00:09:19.720
that can be authenticated some way for,
say,

00:09:19.810 --> 00:09:23.290
a network connection to prove who it is.

00:09:23.830 --> 00:09:30.230
And that authentication technique
is bound to some identifiers such

00:09:30.390 --> 00:09:34.150
as the full name of a person,
which is what we would

00:09:34.150 --> 00:09:35.490
usually show in the UI.

00:09:35.760 --> 00:09:43.060
And there's also some machine identifiers
such as we assign a 128-bit UUID,

00:09:43.130 --> 00:09:45.680
unique ID, to each user.

00:09:45.810 --> 00:09:48.650
For legacy compatibility,
every user also, of course,

00:09:48.650 --> 00:09:51.640
gets a POSIX name,
which is the name with no spaces,

00:09:52.160 --> 00:09:57.700
usually all lowercase,
as well as a unique UUID assigned.

00:09:57.700 --> 00:10:03.640
In addition, aliases are a way to assign
alternate names to an identity.

00:10:03.750 --> 00:10:05.820
So if you want to give
someone a nickname,

00:10:05.820 --> 00:10:06.890
you can do that.

00:10:07.280 --> 00:10:12.700
Now, on Tiger, every user-- oh, sorry,
there's other attributes

00:10:12.700 --> 00:10:16.440
that you can assign,
some optional attributes,

00:10:16.440 --> 00:10:20.370
such as you can have image
data or an image URL.

00:10:20.460 --> 00:10:26.940
We support both image URLs to files,
because directory servers work that way.

00:10:26.940 --> 00:10:30.730
They have either data
or a path to a file.

00:10:30.810 --> 00:10:35.480
You can also put in an email address,
the primary email address for a user.

00:10:35.730 --> 00:10:43.620
Now, in addition to password credentials,
the API also supports storing

00:10:43.680 --> 00:10:50.740
an X.509 certificate in the
repository for the user.

00:10:50.780 --> 00:10:54.090
And we'll talk about that
a little bit later also.

00:10:55.390 --> 00:10:57.420
So here's an example.

00:10:57.750 --> 00:11:02.160
We have a user named Charles Darwin,
POSIX name C Darwin.

00:11:02.160 --> 00:11:05.220
A long UUID has been
assigned automatically,

00:11:05.220 --> 00:11:08.850
as well as a POSIX UID.

00:11:09.180 --> 00:11:11.160
Chuck, Charles, often went by Chuck.

00:11:11.160 --> 00:11:13.390
I don't know if you knew that.

00:11:13.530 --> 00:11:15.970
And there he is.

00:11:16.740 --> 00:11:19.400
His image data is also in there.

00:11:19.400 --> 00:11:24.590
Now, on Tiger, pretty much every user
was a full login user.

00:11:24.740 --> 00:11:29.760
So if you went to Account Preferences
and created a user,

00:11:29.760 --> 00:11:33.600
you got a home directory
created for that user,

00:11:33.740 --> 00:11:36.840
and they were allowed to
log in at login window.

00:11:36.840 --> 00:11:41.240
In Leopard, we're introducing a new class
of user called a sharing user.

00:11:41.240 --> 00:11:43.310
It's sort of a lightweight user.

00:11:43.320 --> 00:11:48.400
It's stored in the same way as a regular
user in the open directory store.

00:11:48.400 --> 00:11:51.260
It's available through
the Identity Services API.

00:11:51.350 --> 00:11:54.080
But it's a minimal user
with no home directory,

00:11:54.090 --> 00:11:58.340
and there's no login shell
set in the user record.

00:11:58.400 --> 00:12:03.560
So if they walk up to login window,
they can't actually log in.

00:12:03.560 --> 00:12:04.840
They don't have access.

00:12:05.020 --> 00:12:09.050
So the sharing user is intended
for when you want to be able to

00:12:09.050 --> 00:12:13.730
create identities that you want
to grant access to your photos or

00:12:13.730 --> 00:12:15.640
other resources that you're sharing.

00:12:15.640 --> 00:12:19.690
And over the network,
you can create local users

00:12:20.000 --> 00:12:24.110
that are very lightweight,
very quick to create.

00:12:25.790 --> 00:12:26.940
We're also supporting groups.

00:12:26.960 --> 00:12:39.280
Group identities are simply group
identities that have membership.

00:12:39.320 --> 00:12:44.940
And we look at it as mostly an
advanced access control tool.

00:12:44.970 --> 00:12:47.920
Most end users aren't ever
going to create a group.

00:12:48.030 --> 00:12:53.450
But for advanced users that want to
do a lot of access control management,

00:12:53.450 --> 00:12:57.300
it's something you always wish for
right away if you don't have it.

00:12:57.520 --> 00:13:00.840
When you start getting a
lot of local users created,

00:13:00.840 --> 00:13:05.120
you want to be able to
create groups for them.

00:13:05.350 --> 00:13:11.360
Otherwise, most of the attributes of a
group are the same as a user.

00:13:11.370 --> 00:13:13.900
They have a unique ID, a full name,
and so on.

00:13:13.900 --> 00:13:17.290
You can even have an image or
an email address for the group.

00:13:20.150 --> 00:13:23.280
So where conceptually do Identities live?

00:13:23.290 --> 00:13:28.240
And according to the API,
they live in Identity Authorities,

00:13:28.270 --> 00:13:32.260
which is a trusted repository
for Identity information.

00:13:32.290 --> 00:13:38.440
And every system has a built-in
local Identity Authority.

00:13:38.440 --> 00:13:40.600
And that's where all of your
local users are defined.

00:13:40.600 --> 00:13:44.140
Essentially,
this is a representation of what's in

00:13:44.140 --> 00:13:47.510
the local open directory user store.

00:13:48.000 --> 00:13:51.770
If you're on a managed network,
you have what's called

00:13:51.770 --> 00:13:53.260
the network authority.

00:13:53.260 --> 00:13:57.440
So that might be users
defined in your LDAP server.

00:13:57.460 --> 00:14:04.440
And in the API, when you say you want to
find or look up some user,

00:14:04.450 --> 00:14:07.680
you have to specify
where you want to look.

00:14:07.780 --> 00:14:11.200
So you can look at the network
authority or the local authority.

00:14:11.210 --> 00:14:13.800
Often you want to look at both.

00:14:13.810 --> 00:14:18.980
And in that case, you specify the default
authority for identities,

00:14:18.980 --> 00:14:22.840
which is a synonym for both.

00:14:23.580 --> 00:14:26.080
repositories.

00:14:26.080 --> 00:14:28.600
All right,
so that's the conceptual overview.

00:14:28.600 --> 00:14:31.040
Let's take a quick look at the API.

00:14:31.040 --> 00:14:37.060
And I just want to give you a
feel for what you can do with it.

00:14:37.580 --> 00:14:40.310
It's a C API based on the
core foundation runtime.

00:14:40.430 --> 00:14:45.900
So the object types follow all of
the standard naming conventions they

00:14:45.900 --> 00:14:47.880
have after creating or copying them.

00:14:47.880 --> 00:14:51.890
You need to make sure you release
them with CF release and so on.

00:14:52.390 --> 00:14:54.850
There's two types.

00:14:54.900 --> 00:14:56.830
Pretty simple API, really.

00:14:56.970 --> 00:15:02.090
Type CS Identity Ref represents
either a user or a group.

00:15:02.370 --> 00:15:06.370
We decided to have one type
for both because so many of

00:15:06.380 --> 00:15:09.600
the functions or methods that
you call on them are identical.

00:15:09.600 --> 00:15:11.980
Almost all the attributes are the same.

00:15:12.020 --> 00:15:14.380
And since C doesn't
do subclassing at all,

00:15:14.390 --> 00:15:17.940
it's just easier to have one type.

00:15:17.940 --> 00:15:20.420
That does mean that if you really
need to know whether a given

00:15:20.420 --> 00:15:23.490
identity is a user or a group,
you have to get its class attribute.

00:15:23.660 --> 00:15:27.490
So you ask for the class and you
get back an enum value indicating

00:15:27.570 --> 00:15:29.480
whether it's a user or a group.

00:15:29.830 --> 00:15:35.130
And then most of the API on this
type is a series of attribute

00:15:35.440 --> 00:15:38.520
setters and getters and setters.

00:15:40.120 --> 00:15:43.210
The other data type is
the CS Identity Query,

00:15:43.320 --> 00:15:45.660
CS Identity Query Ref.

00:15:45.660 --> 00:15:51.340
And this is how you pull existing
identities out of an identity authority.

00:15:51.340 --> 00:15:52.940
You create a query.

00:15:53.200 --> 00:15:56.700
So how does that work?

00:15:56.740 --> 00:15:58.740
Basically,
when you create a query object,

00:15:58.740 --> 00:16:01.800
you point it at a particular
identity authority.

00:16:01.810 --> 00:16:05.920
And that means it's only going
to find identities there.

00:16:05.940 --> 00:16:11.360
And you specify some other sorts of
criteria that you want to search on.

00:16:11.400 --> 00:16:12.780
And you execute it.

00:16:12.880 --> 00:16:17.150
And the result is an array
of matching identities.

00:16:19.350 --> 00:16:21.880
There are several different
types of queries you can create.

00:16:22.000 --> 00:16:26.300
A simple one, you just say "all," and you
point it at an authority,

00:16:26.300 --> 00:16:29.000
and you say whether you
want users or groups,

00:16:29.000 --> 00:16:31.170
and it gives you
everything that it finds.

00:16:31.350 --> 00:16:37.630
You can also search by name,
either an exact match or a partial match.

00:16:38.900 --> 00:16:42.430
You can, if you have a specific
UUID you're looking for,

00:16:42.550 --> 00:16:46.220
let's say you're working
with a file system ACL.

00:16:46.320 --> 00:16:49.280
File system ACLs are all UUID-based.

00:16:49.430 --> 00:16:55.750
So you have a UUID, you want to look up
that user information,

00:16:55.750 --> 00:16:55.750
you create this kind of query.

00:16:59.030 --> 00:17:04.820
Again, if you happen to have a UID,
let's say you need to look

00:17:04.930 --> 00:17:08.700
up the owner of a process,
all you have is a UID.

00:17:08.700 --> 00:17:13.170
You can create a query
on the POSIX identifiers.

00:17:13.730 --> 00:17:17.260
You can create a query for
group members if you want to

00:17:17.260 --> 00:17:21.390
enumerate the group membership,
and you can create a query

00:17:21.390 --> 00:17:25.050
for the current user to
find out that user record.

00:17:26.770 --> 00:17:29.020
There's two ways to execute queries.

00:17:29.020 --> 00:17:32.300
The simple way is
synchronous query execution.

00:17:32.360 --> 00:17:36.170
And it's simple because
it's very procedural.

00:17:36.220 --> 00:17:41.410
You create a query-- three function
calls here-- creating a query.

00:17:41.420 --> 00:17:45.540
This one's looking for users in
the local identity authority.

00:17:45.540 --> 00:17:48.320
So it's going to give me all local users.

00:17:48.320 --> 00:17:51.710
You execute it, csidentityquery execute.

00:17:51.800 --> 00:17:57.180
When it's done, if it returns true,
you say csidentityquery copy results.

00:17:57.180 --> 00:18:00.570
And you get back an array
of all the identities.

00:18:00.610 --> 00:18:06.560
If the execution returns false,
then you've got an error in the third

00:18:06.560 --> 00:18:09.350
parameter to the execute function.

00:18:09.400 --> 00:18:15.100
And for those of you who
didn't hear about CFError,

00:18:15.100 --> 00:18:18.180
I hope it was covered in one of
the Core Foundation sessions.

00:18:18.250 --> 00:18:24.220
But there's a new error
object called cferrorref.

00:18:24.220 --> 00:18:26.310
It's based on the NSError API.

00:18:26.320 --> 00:18:31.900
And it's a nice way to return errors
because usually they have localized

00:18:31.940 --> 00:18:36.170
strings associated with them,
as well as underlying error information.

00:18:36.270 --> 00:18:44.860
So if you get back an error as the return
from a cferror-based function like this,

00:18:45.030 --> 00:18:50.280
then you have to make sure you release
the error if the function returns false.

00:18:52.040 --> 00:18:57.800
Now, the problem with synchronous queries
is that they might take a long time.

00:18:57.990 --> 00:18:58.630
They might block.

00:18:58.750 --> 00:19:01.750
They will almost certainly
be doing local I/O,

00:19:01.910 --> 00:19:06.420
but if you're running against the
default identity authority and the

00:19:06.480 --> 00:19:10.970
system is bound to some directory server,
then you're going to be

00:19:10.970 --> 00:19:12.580
hitting the network also.

00:19:12.810 --> 00:19:17.240
And so certainly if you're a
single-threaded app and you're looking

00:19:17.240 --> 00:19:20.340
at queries on your main thread,
you don't want to get the

00:19:20.340 --> 00:19:22.700
spinning pizza of death.

00:19:22.830 --> 00:19:27.280
So we recommend generally that you
use asynchronous queries using a

00:19:27.280 --> 00:19:30.040
pretty standard callback model.

00:19:30.210 --> 00:19:34.430
Another advantage of asynchronous
queries is that we wanted to make

00:19:34.430 --> 00:19:38.170
it easy to get change notifications.

00:19:38.270 --> 00:19:42.790
It's not that unusual to be working
with an access control list in one

00:19:42.850 --> 00:19:47.830
application and somebody switches
over to account preferences and

00:19:47.830 --> 00:19:51.660
creates a new user or a new group.

00:19:51.660 --> 00:19:51.660
And it might be appropriate to
have a system that's not always

00:19:51.660 --> 00:19:52.660
the same as the previous one.

00:19:52.660 --> 00:19:52.660
But it's not that unusual to be
working with an access control list.

00:19:52.660 --> 00:19:56.190
So we wanted to make it easy for that
new user to show up in the applications

00:19:56.730 --> 00:19:58.600
query that it happens to be looking at.

00:19:58.600 --> 00:20:02.040
And so if you use
asynchronous query execution,

00:20:02.040 --> 00:20:04.240
you get change notifications for free.

00:20:04.240 --> 00:20:10.710
The way that works is you
create a callback function and

00:20:10.720 --> 00:20:13.280
events happen on the query.

00:20:13.280 --> 00:20:17.280
Mainly three kinds of events: added,
changed, and removed.

00:20:17.280 --> 00:20:19.890
And you get passed an array
of identities that are not

00:20:20.070 --> 00:20:21.540
the same as the previous ones.

00:20:21.540 --> 00:20:29.550
So you get a bunch of added
events that come in in batches.

00:20:30.020 --> 00:20:35.140
And the array indicates
which identities are added.

00:20:35.200 --> 00:20:38.550
If you leave the query running
because you haven't stopped it,

00:20:38.550 --> 00:20:43.650
then you'll get changed events
or even removed events if either

00:20:43.660 --> 00:20:46.710
an identity is deleted or,
let's say,

00:20:46.720 --> 00:20:51.420
you're doing a name-based query and
the name of the identity gets changed.

00:20:51.420 --> 00:20:53.720
So if you leave the query
running under query criteria,

00:20:53.720 --> 00:20:55.600
then you'll get a removed
event for that identity.

00:20:55.600 --> 00:20:57.870
So removed doesn't necessarily
mean it's been deleted.

00:21:03.550 --> 00:21:06.410
To execute asynchronously,
you just call CS Identity

00:21:06.530 --> 00:21:08.720
Query execute asynchronously.

00:21:08.720 --> 00:21:16.060
You pass in the query and some options,
a client context structure,

00:21:16.260 --> 00:21:22.020
which includes your callback and a
reference constant that you can control.

00:21:22.020 --> 00:21:25.350
And then you specify just a single
run loop and run loop mode that you

00:21:25.350 --> 00:21:27.570
want to receive your callbacks on.

00:21:27.580 --> 00:21:30.560
And in many cases,
you just specify the current run

00:21:30.560 --> 00:21:35.050
loop and the default run loop mode.

00:21:35.380 --> 00:21:39.140
Now, whenever you start a
query asynchronously,

00:21:39.140 --> 00:21:42.890
if you just release it,
when you're done with it,

00:21:42.890 --> 00:21:49.000
you're not necessarily guaranteed that
your callback won't be called anymore.

00:21:49.340 --> 00:21:52.500
So as with other asynchronous
APIs on the system,

00:21:52.700 --> 00:21:55.940
you want to make sure you
call CS Identity Query Stop.

00:21:55.940 --> 00:21:59.480
Because releasing doesn't
necessarily mean that the object

00:21:59.570 --> 00:22:02.430
is going to be deleted right away.

00:22:02.500 --> 00:22:05.680
Because you don't know really
what the ref count is for sure.

00:22:05.710 --> 00:22:10.100
If you say stop,
then it clears out your callbacks.

00:22:10.140 --> 00:22:17.530
And that's the signal to us that we
will not call your functions anymore.

00:22:19.790 --> 00:22:23.690
Once you have an identity,
say retrieved from a query,

00:22:23.830 --> 00:22:28.510
there's just simple getters for
all of the attributes such as

00:22:28.730 --> 00:22:31.360
get the UUID returns a CFUUIDRef.

00:22:31.440 --> 00:22:34.760
You get CS Identity get full name.

00:22:34.760 --> 00:22:38.880
CS Identity get class I mentioned
that returns an enum value.

00:22:38.880 --> 00:22:43.240
You can test, say, if it's a user,
then you can call CS Identity

00:22:43.380 --> 00:22:47.590
get certificate and that
returns the sex certificate ref.

00:22:47.710 --> 00:22:49.520
These are all CF objects.

00:22:49.820 --> 00:22:51.940
However,
because the functions are getters,

00:22:51.940 --> 00:22:52.900
it's very convenient.

00:22:52.900 --> 00:22:56.680
You don't have to release any
of the values retrieved here.

00:22:58.660 --> 00:23:01.500
By the way,
if you happen to call CS Identity

00:23:01.500 --> 00:23:04.880
Get Certificate on a group,
it's not going to crash or anything.

00:23:04.880 --> 00:23:06.980
It's just going to return null.

00:23:09.720 --> 00:23:15.050
Most applications aren't going
to need to modify identities.

00:23:15.310 --> 00:23:21.580
Some applications might want to use a
group as their access control model.

00:23:21.580 --> 00:23:27.420
If you have a service that runs
as root or as a privileged user,

00:23:27.420 --> 00:23:31.140
you might want to create a
group to represent your ACL.

00:23:31.140 --> 00:23:36.860
But most applications aren't going to
need to actually be creating users.

00:23:37.980 --> 00:23:39.700
However, the API supports it.

00:23:39.760 --> 00:23:44.970
If you're an admin user and you
go through the Authorization

00:23:45.150 --> 00:23:51.030
Services authentication dialogue,
then you can create users and groups,

00:23:51.090 --> 00:23:54.280
change attributes,
and it uses a commit model.

00:23:54.390 --> 00:23:57.300
So you can call setters on an identity,
and then you say,

00:23:57.300 --> 00:24:00.430
"Commit this," and it writes
it back to the authority.

00:24:00.460 --> 00:24:04.480
It can be committed either
synchronously or asynchronously again.

00:24:07.240 --> 00:24:10.390
Simple example, set full name and then
CS Identity commit.

00:24:10.440 --> 00:24:17.320
So that is a real quick
overview of the API.

00:24:17.320 --> 00:24:22.780
And now I wanted to switch over to the
laptop here and show you some sample code

00:24:22.860 --> 00:24:27.000
that's available on the session website.

00:24:30.570 --> 00:24:33.760
It's called Identity Sample,
and its purpose is just to

00:24:33.790 --> 00:24:39.940
exercise the API and serve
as sample code for you guys.

00:24:39.940 --> 00:24:43.680
We have a sidebar on the left here
which shows all of the local users,

00:24:43.680 --> 00:24:46.820
some of the people in my group.

00:24:46.820 --> 00:24:49.410
So it's doing initially a
query for all the local users.

00:24:49.570 --> 00:24:52.040
It can also do a partial
name match query.

00:24:52.040 --> 00:24:57.860
So as I type, as soon as I pause typing,
it starts a query for

00:24:57.860 --> 00:25:02.720
identities beginning with MAR,
and it finds all the marks.

00:25:02.720 --> 00:25:05.780
By the time we ship Leopard,
you'll be able to search by

00:25:05.780 --> 00:25:11.710
last name also automatically
without doing a different query.

00:25:12.700 --> 00:25:17.690
I can select an identity and
it shows all of the detailed

00:25:17.700 --> 00:25:22.510
attribute values over on the right,
including if there's an image,

00:25:22.510 --> 00:25:23.310
it shows it.

00:25:23.620 --> 00:25:29.110
I can click the plus button
if I want to create a new one,

00:25:29.110 --> 00:25:30.390
new user.

00:25:30.980 --> 00:25:33.600
I'll go ahead and create Charles Darwin.

00:25:33.610 --> 00:25:39.900
And if I don't assign a password,
there's actually no password.

00:25:39.980 --> 00:25:43.720
And what I mean is they
can't authenticate.

00:25:43.720 --> 00:25:45.340
It's not a zero-link password.

00:25:45.340 --> 00:25:47.700
It's like disabled user.

00:25:47.720 --> 00:25:49.420
But I'll go ahead and assign a password.

00:25:49.440 --> 00:25:51.910
And there's Charles Darwin.

00:25:52.190 --> 00:25:56.560
If I want to go and, say,
add that nickname Chuck,

00:25:56.800 --> 00:25:57.630
I can do that.

00:25:58.340 --> 00:26:04.540
And maybe add an email address.

00:26:06.750 --> 00:26:09.580
And when I'm done with the changes,
I click the Apply button,

00:26:09.580 --> 00:26:14.160
and that calls CS Identity Commit to
write the changes back to the store.

00:26:14.360 --> 00:26:16.340
So pretty simple application.

00:26:16.550 --> 00:26:20.010
And as I mentioned,
it's available on the website for

00:26:20.010 --> 00:26:28.570
this session along with preliminary
documentation for the API.

00:26:28.660 --> 00:26:30.690
Back to slides, please.

00:26:39.400 --> 00:26:45.040
So, of course, end users have a need to
do the same kinds of things

00:26:45.080 --> 00:26:46.100
that that application does.

00:26:46.250 --> 00:26:51.310
So what we've done,
if you haven't seen it yet, on Leopard,

00:26:51.310 --> 00:26:53.810
you can look at the Accounts
Preference pane and see that

00:26:54.260 --> 00:26:56.240
there's more stuff going on now.

00:26:56.240 --> 00:27:02.240
You can actually see the different kinds
of users and groups over on the left.

00:27:02.240 --> 00:27:06.460
It has My Account still up at the top,
and then there's a section for

00:27:06.460 --> 00:27:10.670
sharing accounts or sharing users,
and a section for groups

00:27:10.670 --> 00:27:12.080
down at the bottom.

00:27:12.080 --> 00:27:16.580
In this example,
I clicked on the Core Services group,

00:27:16.590 --> 00:27:22.460
and it shows the membership
over on the right side.

00:27:22.700 --> 00:27:26.010
It's pretty simple to add somebody
just by checking the checkbox.

00:27:26.170 --> 00:27:28.420
So that's what Accounts
Preferences looks like.

00:27:28.490 --> 00:27:31.920
It's sort of the central place
on the system that we use

00:27:31.920 --> 00:27:34.080
to manage users and groups.

00:27:35.760 --> 00:27:37.840
And now we can finally go
back to picture sharing.

00:27:37.920 --> 00:27:42.030
We have enough infrastructure to
be able to add access controls to

00:27:42.080 --> 00:27:43.600
the picture sharing application.

00:27:43.600 --> 00:27:46.600
So here's what it looks like currently.

00:27:46.630 --> 00:27:50.130
And we want to be able to set up an ACL.

00:27:50.390 --> 00:27:53.220
So we're ready to do step one.

00:27:53.270 --> 00:27:56.940
And to kind of show you
what that looks like,

00:27:56.960 --> 00:28:02.220
I'd like to please welcome Alex Aybes
up to give us a quick view of

00:28:02.220 --> 00:28:04.690
the new picture sharing server.

00:28:09.570 --> 00:28:13.370
So like Chris mentioned,
we want to be able to share photos

00:28:13.380 --> 00:28:18.640
with a restricted set of people,
not allow access to everyone.

00:28:18.790 --> 00:28:22.400
So to do that, we have updated the
Picture Sharing Sample Code,

00:28:22.400 --> 00:28:24.080
the Picture Sharing Application.

00:28:24.080 --> 00:28:27.160
And I'm going to show you what
we've done to it right now.

00:28:27.370 --> 00:28:29.820
So here's the picture
sharing application.

00:28:29.820 --> 00:28:32.330
You just saw the original
one on the slide.

00:28:32.360 --> 00:28:35.400
So like you can see,
we've updated the UI.

00:28:35.400 --> 00:28:41.370
We've added a couple of radio buttons,
a list, and the plus and minus button.

00:28:42.490 --> 00:28:48.410
This is-- I'm going to
show you how this works.

00:28:50.200 --> 00:28:54.600
This is the UI we recommend you adopt
in your applications when you want

00:28:54.600 --> 00:28:57.550
to do access control list management.

00:28:57.640 --> 00:28:59.730
This is what it should look like,
and this is how it works.

00:28:59.980 --> 00:29:04.620
So the first button, Share with Everyone,

00:29:04.830 --> 00:29:06.690
maintains the current functionality.

00:29:06.790 --> 00:29:09.810
Anyone, everyone can access the photo.

00:29:11.250 --> 00:29:13.360
The second button that I'm
going to click right now,

00:29:13.370 --> 00:29:15.980
you see that it enables the list.

00:29:16.090 --> 00:29:19.150
We have now enabled authentication.

00:29:19.370 --> 00:29:20.400
Access is restricted.

00:29:20.510 --> 00:29:24.890
In the current state, no one can actually
connect and see that photo.

00:29:25.120 --> 00:29:28.220
So now we've enabled authentication.

00:29:28.220 --> 00:29:29.110
We need to add people.

00:29:29.280 --> 00:29:32.080
How are we going to add
people to this list?

00:29:32.100 --> 00:29:35.630
Well, for that purpose, we are providing,
introducing in Leopard,

00:29:35.630 --> 00:29:38.550
a new standard panel that
we call the Identity Picker.

00:29:38.870 --> 00:29:42.850
And this allows users to pick identities.

00:29:43.680 --> 00:29:50.640
So let's say I want to share this photo,
this beautiful ladybug, with my mom.

00:29:50.660 --> 00:29:53.900
She also happens to have an
account in this computer.

00:29:54.450 --> 00:29:55.830
She can log into that machine.

00:29:55.920 --> 00:29:59.240
So I want to share this photo with her.

00:29:59.240 --> 00:30:00.950
What am I going to do?

00:30:01.000 --> 00:31:04.900
[Transcript missing]

00:31:05.140 --> 00:31:08.130
And Chris is not on my Mac,
and I've never shared with him,

00:31:08.130 --> 00:31:10.460
so he's not in the sharing users.

00:31:10.520 --> 00:31:14.100
But I know I have him on Address Book,
so all I have to do is select

00:31:14.270 --> 00:31:18.610
the Address Book icon and
click on Chris and press Share.

00:31:18.920 --> 00:31:23.460
Since I've never shared with Chris,
I need to set a password for him.

00:31:23.580 --> 00:31:26.600
So I'm going to set a password for Chris.

00:31:26.930 --> 00:31:27.640
Don't repeat it.

00:31:27.640 --> 00:31:32.280
It's one, two, three, four,
just for when you need to log in.

00:31:32.300 --> 00:31:33.900
And go share.

00:31:33.920 --> 00:31:36.600
And that's all I really need to do.

00:31:36.600 --> 00:31:38.860
Under the hood,
we have just created an identity,

00:31:38.880 --> 00:31:41.080
just like we would have
done the identity sample,

00:31:41.090 --> 00:31:44.610
but showed the minimal UI to the user.

00:31:44.700 --> 00:31:47.080
This is not to scare them too much.

00:31:49.390 --> 00:31:52.350
The other thing I wanted to mention
is that now that you've done this,

00:31:52.440 --> 00:31:55.050
all these identities are available
throughout all the applications

00:31:55.140 --> 00:31:56.800
that use the Identity Picker.

00:31:56.880 --> 00:32:02.780
So you're going to be able to see the
sharing users in any app that uses it,

00:32:02.780 --> 00:32:06.560
as well as in the system preferences,
the accounts preferences,

00:32:06.560 --> 00:32:09.840
the identity sample, anywhere you go.

00:32:10.100 --> 00:32:16.220
Like I mentioned,
the API is extremely simple.

00:32:16.240 --> 00:32:17.350
There's just a couple calls.

00:32:17.360 --> 00:32:22.320
You can get a modal dialog, a sheet,
whichever you want.

00:32:22.340 --> 00:32:25.660
And in those two cases that
were fairly different as far

00:32:25.660 --> 00:32:28.080
as what we had to do-- one,
we had to just pick an

00:32:28.080 --> 00:32:31.070
identity and return it,
the other one, create it-- the API,

00:32:31.170 --> 00:32:33.080
you don't have to worry
about any of that.

00:32:33.080 --> 00:32:34.620
You don't have to worry
about creating it.

00:32:34.650 --> 00:32:40.590
All you do is call the method to bring
up the dialog and then handle and process

00:32:40.590 --> 00:32:43.380
through the identities it returns.

00:32:43.420 --> 00:32:45.020
So that's it for the demo.

00:32:45.260 --> 00:32:46.040
Back to you, Chris.

00:32:46.150 --> 00:32:47.380
CHRIS BROADFOOT: Thank you.

00:32:53.750 --> 00:32:57.470
So as Alex mentioned,
sort of like a file open

00:32:57.550 --> 00:33:05.780
panel or the AB person picker,
the address person picker,

00:33:05.800 --> 00:33:11.320
the Identity Picker insulates your app
from not only the UI details of browsing,

00:33:11.320 --> 00:33:15.530
but even from the details of, say,
being able to write from within

00:33:15.580 --> 00:33:21.320
the context of your application,
promote Address Book entries

00:33:21.590 --> 00:33:22.660
to sharing users.

00:33:22.660 --> 00:33:24.130
So that they actually have a credential.

00:33:24.170 --> 00:33:27.350
So that little sheet that came
down prompting for a password,

00:33:27.350 --> 00:33:29.150
that was not implemented by the app.

00:33:29.240 --> 00:33:33.480
That was still all part of
the Identity Picker panel.

00:33:35.230 --> 00:33:36.640
So that's pretty nice.

00:33:36.640 --> 00:33:38.860
It simplifies all of that for your app.

00:33:38.860 --> 00:33:43.560
It keeps people working right in your
application to edit access control lists.

00:33:43.580 --> 00:33:47.830
However, I do need to mention that
it's still a work in progress.

00:33:47.870 --> 00:33:51.200
I'm sure that the UI is
going to go through some more

00:33:51.250 --> 00:33:53.510
change before Leopard ships.

00:33:53.540 --> 00:33:57.590
And that probably means the API is
going to change somewhat also.

00:33:57.600 --> 00:34:00.620
But it's available in the seed
if you want to play with it.

00:34:00.620 --> 00:34:04.600
It's part of the Address Book framework,
abidentitypicker.h.

00:34:07.110 --> 00:34:10.460
Alex also mentioned the
API was pretty simple,

00:34:10.460 --> 00:34:12.660
and here it is.

00:34:12.670 --> 00:34:17.200
AB Identity Picker, alexinit,
creates a picker instance.

00:34:17.230 --> 00:34:21.500
And then you call the method
beginSheetModalForWindow,

00:34:21.500 --> 00:34:24.840
specifying the parent window,
a delegate object,

00:34:24.980 --> 00:34:30.170
and the didEndSelector is the
delegate method that gets called

00:34:30.170 --> 00:34:31.800
when the panel is complete.

00:34:31.820 --> 00:34:36.880
And at that point,
it passes you an array of identities.

00:34:39.690 --> 00:34:42.760
All right, finally,
we're now to step two, persistence.

00:34:42.940 --> 00:34:45.360
We have an ACL in the application.

00:34:45.360 --> 00:34:47.880
We could enforce it while
the application is running,

00:34:47.880 --> 00:34:51.990
but if we quit it and restart it,
we want to keep that ACL associated

00:34:51.990 --> 00:34:53.650
with the shared resource.

00:34:53.990 --> 00:34:59.140
This is not terribly complicated,
but you have to have a simple way to

00:34:59.140 --> 00:35:03.010
serialize or flatten your ACL into data.

00:35:03.130 --> 00:35:05.810
Conceptually,
an ACL is just an array of identities

00:35:05.930 --> 00:35:10.880
that might be just the identity,
or it may-- each identity may

00:35:10.880 --> 00:35:14.190
have a read/write privilege,
something like that associated with it.

00:35:14.330 --> 00:35:16.890
It's an application-specific thing.

00:35:16.930 --> 00:35:19.700
Every application has different needs.

00:35:19.740 --> 00:35:23.150
But the fundamental need is you
need to be able to take an identity

00:35:23.470 --> 00:35:27.840
that's an entry in your ACL and turn
it into some sort of data reference

00:35:27.920 --> 00:35:34.440
that you can use to restore the
identity when your app launches again.

00:35:34.460 --> 00:35:37.470
One way to do that is with the UUID.

00:35:37.760 --> 00:35:40.370
I mentioned everything-- every
identity gets a unique UUID.

00:35:40.380 --> 00:35:45.880
We've been doing that, actually,
starting in Tiger.

00:35:45.970 --> 00:35:49.100
But on Leopard, you can use the UUID.

00:35:49.540 --> 00:35:51.900
But we actually recommend
something a little different,

00:35:51.900 --> 00:35:56.190
which is a feature of the API called
Persistent Identity Reference.

00:35:56.310 --> 00:35:58.180
And it's just a data blob.

00:35:58.180 --> 00:36:01.200
You ask an identity
for its data reference,

00:36:01.280 --> 00:36:03.050
and you get a data blob back.

00:36:03.150 --> 00:36:05.980
One of the things in there, of course,
is the UUID,

00:36:06.070 --> 00:36:09.650
but it gives us the flexibility
to put other things in the

00:36:09.650 --> 00:36:15.460
persistent reference that help us,
A, find the identity faster

00:36:15.460 --> 00:36:17.960
when we need to look it up,
and B,

00:36:17.960 --> 00:36:22.380
know if it's been moved to a different
machine and do the right thing,

00:36:22.380 --> 00:36:27.500
just in case we want to know
that this identity blob really

00:36:27.500 --> 00:36:29.800
isn't valid on this machine.

00:36:31.340 --> 00:36:32.800
So how does that look?

00:36:32.800 --> 00:36:36.200
One call, CS Identity,
create persistent reference.

00:36:36.250 --> 00:36:39.800
So that takes an identity,
gives you back a data ref,

00:36:39.800 --> 00:36:40.610
which is your blob.

00:36:40.620 --> 00:36:44.760
You save that in your preferences
file or whatever you're using as a

00:36:44.810 --> 00:36:49.560
data store for your shared resources.

00:36:49.560 --> 00:36:53.640
And the inverse operation then
is to create a query based

00:36:53.640 --> 00:36:56.060
on the persistent reference.

00:36:56.060 --> 00:36:59.700
So when you need to turn that
back into the same identity

00:36:59.700 --> 00:37:03.640
object it was created from,
you CS Identity query create

00:37:03.750 --> 00:37:06.780
for persistent reference
and pass in the data,

00:37:06.780 --> 00:37:08.100
execute the query.

00:37:08.100 --> 00:37:13.840
And assuming the identity still exists,
you get back-- the result is

00:37:14.080 --> 00:37:17.180
the identity that you want.

00:37:18.810 --> 00:37:19.530
All right.

00:37:19.590 --> 00:37:21.200
Step three, authentication.

00:37:21.310 --> 00:37:24.610
Well, authentication is
actually the hardest part.

00:37:24.770 --> 00:37:28.970
So I'm going to save that for last
and go around to authorization.

00:37:28.980 --> 00:37:33.380
Authorization is still
working with the ACL,

00:37:33.380 --> 00:37:37.330
so it fits in flow-wise
a little bit better here.

00:37:37.340 --> 00:37:39.750
So authorization is when
a connection comes in,

00:37:39.820 --> 00:37:43.180
you've gone through authentication,
so you know who the

00:37:43.410 --> 00:37:45.460
connection is coming from.

00:37:46.380 --> 00:37:49.760
Let's say then the result
of the authentication step

00:37:49.840 --> 00:37:52.960
is an identity object,
which represents the user

00:37:52.960 --> 00:37:54.220
making the connection.

00:37:54.220 --> 00:37:58.820
And you simply want to know,
is this a user that actually has access,

00:37:58.820 --> 00:38:01.600
in this case,
to the photo that we're sharing?

00:38:02.980 --> 00:38:07.180
And so basically you have to
compare the entry or the identity

00:38:07.230 --> 00:38:09.660
against the entries in your ACL.

00:38:09.660 --> 00:38:11.840
And by the way,
you might have groups that

00:38:11.840 --> 00:38:13.040
have been added to the ACL.

00:38:13.040 --> 00:38:15.810
We didn't show that,
but you can add groups to an ACL.

00:38:15.930 --> 00:38:18.920
So that means you need to write--
this is the simplest case,

00:38:18.930 --> 00:38:21.600
is what we do in picture sharing.

00:38:21.780 --> 00:38:24.740
If you have the ACL represented
as an array of identities

00:38:24.910 --> 00:38:29.010
and you have an identity ref,
which is the user that's connecting,

00:38:29.200 --> 00:38:32.960
you create a loop through
every entry in your ACL.

00:38:32.980 --> 00:38:38.890
And if the entry is a user,
you use CFEqual to compare the

00:38:39.340 --> 00:38:42.140
entry to the connecting user.

00:38:42.510 --> 00:38:49.500
CFEqual is implemented in CS Identity
such that if two different objects really

00:38:49.500 --> 00:38:55.210
represent the same person or identity,
then CFEqual returns true.

00:38:55.320 --> 00:38:58.120
So you use CFEqual for user entries.

00:38:58.150 --> 00:39:03.990
If the ACL entry is a group,
then you check group membership on it.

00:39:04.080 --> 00:39:08.920
You say, is the connecting user
a member of this group?

00:39:08.920 --> 00:39:11.840
And if so,
if either of those ends up being true,

00:39:11.840 --> 00:39:16.170
then the user has authorization
to access the resource.

00:39:19.510 --> 00:39:22.900
So that takes care of everything
except authentication.

00:39:23.030 --> 00:39:25.640
Like I said, this is a little trickier.

00:39:25.680 --> 00:39:27.170
Everyone does authentication differently.

00:39:27.180 --> 00:39:30.910
There's a lot of different protocols.

00:39:35.260 --> 00:39:39.840
One way to do it is
simply implement your own.

00:39:40.010 --> 00:39:45.450
So let's say you want to prompt the
user for a password on the client

00:39:45.450 --> 00:39:50.000
side of your application and send
the password over to the server.

00:39:50.030 --> 00:39:54.390
And you can basically
then look up the username,

00:39:54.420 --> 00:39:59.120
use the Identity Services API to say,
is this the right password for this user?

00:39:59.150 --> 00:40:00.080
And you're done.

00:40:00.080 --> 00:40:02.560
You've got your authentication.

00:40:02.680 --> 00:40:05.680
But that's a lot of work
for your application.

00:40:05.680 --> 00:40:08.210
You've got to do all of the UI.

00:40:08.220 --> 00:40:11.770
It means every application has
a different user experience

00:40:11.890 --> 00:40:13.440
for doing authentication.

00:40:13.480 --> 00:40:19.100
You've got to worry about not passing
the password over the wire in plain text.

00:40:19.410 --> 00:40:23.950
And there are other issues like, well,
then there's no way through

00:40:23.950 --> 00:40:27.490
your application anyway for the
user to change their password,

00:40:27.580 --> 00:40:28.560
for example.

00:40:28.560 --> 00:40:31.360
So there is a better way,
which is called a

00:40:31.630 --> 00:40:33.900
Network Authentication Service.

00:40:33.900 --> 00:40:37.740
It kind of abstracts the
whole authentication process

00:40:37.740 --> 00:40:41.250
away from your application,
insulating your app from

00:40:41.480 --> 00:40:43.420
the authentication process.

00:40:43.420 --> 00:40:47.020
And this has a lot of advantages.

00:40:47.590 --> 00:40:53.280
So for example, Kerberos is a network
authentication protocol.

00:40:53.370 --> 00:40:54.900
And it has a lot of advantages.

00:40:54.990 --> 00:40:58.300
Kerberos has been around
for a long time now.

00:40:58.330 --> 00:41:02.980
And so it has very
nice security features.

00:41:02.980 --> 00:41:05.940
For example, the password is actually
never even sent over the wire.

00:41:05.940 --> 00:41:13.740
It uses this nice little exchange of
encrypted messages to pass tickets,

00:41:13.830 --> 00:41:17.070
to grant tickets,
which prove to an application that the

00:41:17.520 --> 00:41:20.610
connecting user is who they say they are.

00:41:20.960 --> 00:41:27.100
It's an open source standard created
at MIT about 20-some years ago.

00:41:27.140 --> 00:41:29.410
And it also has a single sign-on model.

00:41:29.420 --> 00:41:33.360
Once you get a ticket from Kerberos,
it's usually good for several hours,

00:41:33.360 --> 00:41:37.400
which means that the application,
other applications,

00:41:37.490 --> 00:41:41.410
can use that same credential pulled
from the Kerberos credential cache.

00:41:41.520 --> 00:41:45.860
And the user doesn't have to go
through an authentication step,

00:41:45.860 --> 00:41:51.230
again, to connect to the same machine
or any machine that's part

00:41:51.230 --> 00:41:53.300
of the same Kerberos realm.

00:41:53.350 --> 00:41:55.920
But there are some disadvantages,
some downside to Kerberos.

00:41:56.040 --> 00:42:03.260
It typically requires a lot of
maintenance and a lot of administration.

00:42:03.380 --> 00:42:11.460
It doesn't really account currently
for ad hoc and mobile networks.

00:42:11.500 --> 00:42:15.840
And finally,
the user usually has to know something.

00:42:15.840 --> 00:42:18.250
They definitely have to know
they're using Kerberos and be

00:42:18.260 --> 00:42:22.220
a little educated about what
Kerberos is and what it's doing.

00:42:22.310 --> 00:42:27.160
So what we'd like to do in
Leopard is build on what we've

00:42:27.160 --> 00:42:30.220
done with Mac OS X Server,
which has been very successful.

00:42:30.220 --> 00:42:34.180
It makes setting up a
Kerberos realm really easy.

00:42:34.200 --> 00:42:40.470
And maintaining the Kerberos user
database in sync with the X Server user

00:42:40.510 --> 00:42:43.220
database is all tightly integrated.

00:42:43.410 --> 00:42:51.350
And so we want to build on that
and build a Kerberos server

00:42:51.350 --> 00:42:53.570
into every Leopard client.

00:42:58.020 --> 00:42:59.960
I'm glad you clapped.

00:43:00.000 --> 00:43:05.950
This is pretty cool,
and it's a real challenge because

00:43:05.950 --> 00:43:10.230
essentially we're saying we want to
take care of all of those disadvantages

00:43:10.230 --> 00:43:13.020
that I listed on the last slide.

00:43:13.040 --> 00:43:17.740
So the real goal is the user
shouldn't need to know that

00:43:17.750 --> 00:43:18.940
they're actually using Kerberos.

00:43:18.940 --> 00:43:24.350
It means that all of the administration
has to happen automatically.

00:43:24.470 --> 00:43:27.100
Every time you create an
Identity Services user,

00:43:27.640 --> 00:43:33.940
they have to be set up as a local user
in the Kerberos principal database.

00:43:35.590 --> 00:43:38.950
It means we need to be able
to integrate Kerberos with

00:43:39.480 --> 00:43:44.860
Bonjour Discovery so that we can find
the KDC for a given application server.

00:43:44.860 --> 00:43:49.180
And we also want to make sure that,
as I said,

00:43:49.180 --> 00:43:51.670
the user shouldn't really need to
know that they're using something

00:43:51.740 --> 00:43:55.250
called Kerberos or what our realm is,
but they should get all the

00:43:55.310 --> 00:43:57.750
advantages of using Kerberos.

00:43:57.760 --> 00:43:59.350
So we want to make a
great user experience.

00:43:59.380 --> 00:44:04.920
And we've been talking to the Kerberos
team at MIT about this for a while.

00:44:05.500 --> 00:44:08.450
And they're pretty into it too.

00:44:08.960 --> 00:44:11.900
So there's still some problems to solve.

00:44:12.160 --> 00:44:16.640
It's not all there by any
means in the leopard seed that

00:44:16.640 --> 00:44:20.120
you got at the conference,
but

00:44:20.950 --> 00:44:26.580
We will be working out all the
last issues before Leopard ships.

00:44:26.580 --> 00:44:33.480
And what that means is your application,
when it's running on Leopard,

00:44:33.480 --> 00:44:38.340
can assume universal Kerberos
availability when connecting

00:44:38.340 --> 00:44:40.790
to other Leopard systems.

00:44:40.800 --> 00:44:44.270
And this means if you have an
application that wants to work

00:44:44.270 --> 00:44:48.560
in an ad hoc environment but also
needs to work in a higher security,

00:44:48.560 --> 00:44:51.760
kind of a static,
traditional Kerberos environment,

00:44:51.760 --> 00:44:54.490
you have a single authentication
architecture that you can

00:44:54.490 --> 00:44:56.000
build into your application.

00:44:57.590 --> 00:45:01.010
It does mean you need to adopt Kerberos
authentication in your application.

00:45:01.020 --> 00:45:03.870
So what are the choices for doing that?

00:45:03.980 --> 00:45:08.520
Probably,
if you're not familiar with Kerberos

00:45:08.620 --> 00:45:11.520
like I wasn't a couple years ago,
it always sounded kind of scary,

00:45:11.520 --> 00:45:16.500
especially if you looked up the
header files and took a look in there.

00:45:16.500 --> 00:45:21.580
Because one choice is you can
write direct to the Kerberos API,

00:45:21.580 --> 00:45:27.400
which is a fairly complex thing and
something you might want to do if

00:45:27.410 --> 00:45:30.290
you're already familiar with it or
you've already adopted Kerberos.

00:45:30.380 --> 00:45:37.760
But there is another way to go,
which is a layer above that called the

00:45:37.760 --> 00:45:41.300
Generic Security Services or GSS API.

00:45:41.300 --> 00:45:45.660
It's sort of a high-level way
to take a network connection

00:45:45.660 --> 00:45:52.930
and use it to fairly... Well,
I'm not going to lie to you.

00:45:52.980 --> 00:45:55.200
Yeah, I am going to lie to you.

00:45:55.300 --> 00:45:57.020
It's really simple.

00:45:57.140 --> 00:45:57.500
-

00:45:59.460 --> 00:46:05.040
No, it is easier to adopt because it
has a model that assumes you're

00:46:05.040 --> 00:46:08.930
making a network connection,
and it's particularly easier if you

00:46:08.930 --> 00:46:10.540
have some good sample code to go from.

00:46:10.540 --> 00:46:13.800
And that's what we're trying
to do with the picture sharing

00:46:13.850 --> 00:46:18.360
enhancements is produce a complete
application that does access control,

00:46:18.360 --> 00:46:23.890
also does GSS authentication,
because it's a fairly

00:46:24.550 --> 00:46:29.050
straightforward recipe once
you have some code you can use.

00:46:29.400 --> 00:46:33.400
And so GSS is our recommended way.

00:46:33.400 --> 00:46:37.440
If you want to fully adopt
Identity Services and the preferred

00:46:37.440 --> 00:46:42.480
authentication model on Leopard,
then this is the way to go.

00:46:42.480 --> 00:46:46.090
One of the other advantages of
GSS is once you've gone through

00:46:46.520 --> 00:46:51.870
the authentication steps,
it's really simple to basically create

00:46:51.870 --> 00:46:58.790
encryption and signing capabilities
for anything going over the network.

00:46:59.400 --> 00:47:01.540
And that's, again,
exactly what we're doing in

00:47:01.540 --> 00:47:04.820
picture sharing is once you have
an authenticated connection,

00:47:04.820 --> 00:47:09.270
we can GSS wrap the picture data
and GSS unwrap it over on the

00:47:09.270 --> 00:47:14.430
client side so that it's all
strongly encrypted on the network.

00:47:17.130 --> 00:47:21.430
So that kind of summarizes
what we did to picture sharing.

00:47:21.440 --> 00:47:24.700
And Alex and I would like
to show it to you now.

00:47:26.510 --> 00:47:31.640
If you remember, we need the laptop.

00:47:34.410 --> 00:47:40.930
So Alex left the server running,
showing the Ladybug picture.

00:47:40.950 --> 00:47:45.690
And I have access to
the picture right now.

00:47:46.540 --> 00:47:49.740
So I'm going to go ahead and
bring up Picture Sharing Browser.

00:47:49.740 --> 00:47:51.550
There it is.

00:47:53.440 --> 00:47:56.590
It's got the service list
over on the left and a spot to

00:47:56.670 --> 00:47:58.900
show the picture on the right.

00:47:58.900 --> 00:48:06.180
And just to show kind of the machinery,
this is just for credibility here,

00:48:06.180 --> 00:48:11.380
I'm going to launch the Kerberos app,
which shows what Kerberos credentials

00:48:11.380 --> 00:48:13.450
are in the credential cache.

00:48:13.830 --> 00:48:16.260
CHRISTIAN LANDRIFF:
Which is nothing at the moment.

00:48:16.280 --> 00:48:17.440
And here goes nothing.

00:48:17.440 --> 00:48:20.480
I'm going to go ahead and
click on Alex's service.

00:48:20.490 --> 00:48:25.660
And we actually are getting to a
fairly normal looking logon dialog.

00:48:25.690 --> 00:48:29.940
It says, please type your account name
and password for Alex's Mac.

00:48:29.940 --> 00:48:32.960
So it tells me I'm
connecting to Alex's Mac.

00:48:32.960 --> 00:48:35.560
It's asking for my username and password.

00:48:35.560 --> 00:48:38.900
And it wants to know if I want
to add that to the keychain.

00:48:38.920 --> 00:48:43.680
This is, in fact, a modified Kerberos
authentication dialog.

00:48:43.730 --> 00:48:46.740
So when I go ahead and connect,
I see the picture.

00:48:46.740 --> 00:48:51.300
And we get tickets in the ticket viewer.

00:48:54.110 --> 00:48:55.400
So that worked.

00:48:55.400 --> 00:48:56.610
That was great.

00:48:56.650 --> 00:48:58.000
Very exciting.

00:48:58.020 --> 00:49:08.080
But what happens if I quit the app and
I see that the ticket viewer or the

00:49:08.270 --> 00:49:10.480
Kerberos app still has my tickets there?

00:49:10.480 --> 00:49:13.870
So in theory, I can go back in to
Picture Sharing Browser and

00:49:13.870 --> 00:49:15.800
click on Alex's service again.

00:49:15.820 --> 00:49:19.260
And single sign-on allows us to
use the credentials in the private

00:49:19.390 --> 00:49:20.750
credential cache for the user.

00:49:20.910 --> 00:49:23.820
There's no authentication needed again.

00:49:24.850 --> 00:49:29.250
Now, they're into it.

00:49:29.730 --> 00:49:30.520
Good.

00:49:30.640 --> 00:49:31.100
Yeah.

00:49:31.100 --> 00:49:36.760
Now, let's say I go home,
and I come in the next day,

00:49:36.800 --> 00:49:38.650
and my tickets have all expired.

00:49:38.680 --> 00:49:40.110
So I destroy my tickets.

00:49:40.140 --> 00:49:42.870
There's no more credentials in the cache.

00:49:42.890 --> 00:49:46.390
I can go in,
launch Picture Sharing Browser,

00:49:46.840 --> 00:49:48.300
Click on Alex's service.

00:49:48.300 --> 00:49:52.640
I do have to authenticate again,
but because of keychain integration,

00:49:52.640 --> 00:49:56.140
the password has been pulled out
of my keychain for Alex's Mac.

00:49:56.140 --> 00:49:59.170
And I just click OK, and I'm in.

00:50:02.200 --> 00:50:05.880
So now, if I don't want to share
this photo with you anymore.

00:50:06.000 --> 00:50:06.760
ALEX KOMOROSKE: What?

00:50:06.900 --> 00:50:07.580
No.

00:50:07.660 --> 00:50:09.210
Yeah, no.

00:50:09.260 --> 00:50:10.160
Don't ask me why.

00:50:10.200 --> 00:50:10.920
I just don't want to.

00:50:10.920 --> 00:50:14.030
ALEX KOMOROSKE:
Alex is removing me from the ACL.

00:50:14.100 --> 00:50:15.500
And there, you're gone.

00:50:15.550 --> 00:50:19.480
ALEX KOMOROSKE: And the way we wrote
this application-- well,

00:50:19.550 --> 00:50:22.280
the way our colleague wrote
this application-- thank you,

00:50:22.280 --> 00:50:28.170
Mark Krakmal-- it's always waiting
for more data from the server.

00:50:28.370 --> 00:50:32.080
And so as soon as he
revoked access to me,

00:50:32.080 --> 00:50:34.940
we just sent an error over the network.

00:50:34.990 --> 00:50:39.080
And immediately, I was denied access.

00:50:39.130 --> 00:50:42.470
And now Alex is going to go
ahead and add me back in.

00:50:42.600 --> 00:50:43.980
We're friends again.

00:50:43.980 --> 00:50:45.400
We're friends again.

00:50:45.560 --> 00:50:46.970
You may view my ladybug again.

00:50:47.000 --> 00:50:48.410
ALEX KOMOROSKE: And boom.

00:50:48.570 --> 00:50:49.380
We get access again.

00:50:49.380 --> 00:50:58.300
So we've done the authentication
and we have live authorization.

00:50:58.300 --> 00:51:03.820
Not all apps need to do instantaneous
access controls like that,

00:51:03.890 --> 00:51:08.010
but it helps illustrate what's
going on with our application.

00:51:08.160 --> 00:51:10.160
All right, thanks, Alex.

00:51:14.730 --> 00:51:18.720
So just to recap,
the four things we went through,

00:51:18.720 --> 00:51:25.250
we added ACL editing to the
server picture sharing app.

00:51:25.500 --> 00:51:27.620
We save that ACL.

00:51:27.620 --> 00:51:29.720
We didn't actually show that,
but you can quit the

00:51:29.720 --> 00:51:34.340
server and restart it,
and it loads up the ACL again.

00:51:34.370 --> 00:51:39.560
We added GSS-based authentication
to picture sharing.

00:51:39.560 --> 00:51:42.990
And last step,
we enforce the ACL by looking at

00:51:42.990 --> 00:51:48.740
every entry and comparing it to the
authenticated identity coming in.

00:51:48.790 --> 00:51:53.250
So that is most of what
I wanted to talk about.

00:51:53.260 --> 00:51:54.500
We've got a few minutes left.

00:51:54.500 --> 00:51:57.000
And I wanted to say a little
bit more about Kerberos,

00:51:57.010 --> 00:52:01.290
because it does get a
little bit better from here.

00:52:01.410 --> 00:52:05.280
Kerberos is-- because it is open source
and it's been around a long time and

00:52:05.280 --> 00:52:10.260
has a lot of people working on it,
industry standard and all that,

00:52:10.890 --> 00:52:14.630
If your app adopts it,
you get all of the future enhancements

00:52:14.800 --> 00:52:17.400
to Kerberos moving forward.

00:52:17.400 --> 00:52:23.260
And because you have adopted
an abstraction of the whole

00:52:23.260 --> 00:52:27.330
authentication process,
then it means Apple and Kerberos

00:52:27.330 --> 00:52:32.840
can control the user experience,
the kinds of credentials that

00:52:32.840 --> 00:52:36.020
the authentication process uses.

00:52:36.020 --> 00:52:39.020
And I want to talk a little
bit about Kerberos PK-ANIT,

00:52:40.030 --> 00:52:41.980
which is an extension to Kerberos.

00:52:41.980 --> 00:52:47.940
It's, I guess, a variation on K-ANIT,
which is the Kerberos

00:52:48.020 --> 00:52:49.980
log command line tool.

00:52:50.060 --> 00:52:55.180
PK-ANIT is a public-key
infrastructure-based

00:52:55.460 --> 00:52:56.980
authentication scheme.

00:52:57.020 --> 00:53:02.340
So if you have X.509 certs
associated with your users,

00:53:02.360 --> 00:53:08.660
you can use cert-based
authentication through Kerberos.

00:53:09.320 --> 00:53:14.030
and essentially have no password
authentication for users.

00:53:14.100 --> 00:54:44.900
[Transcript missing]

00:54:45.170 --> 00:54:49.380
So .Mac is,
the .Mac team's pretty into that,

00:54:49.380 --> 00:54:53.820
and they're interested and
currently pursuing issuing

00:54:54.050 --> 00:55:00.160
essentially Identity Certificates
through .Mac in the same way.

00:55:00.160 --> 00:55:02.670
And this is planned to be a free service.

00:55:02.770 --> 00:55:06.280
You don't have to be a .Mac
member to be able to use it.

00:55:06.320 --> 00:55:08.050
Anyone can get a handle through .Mac.

00:55:08.700 --> 00:55:12.290
And our plan is to tightly integrate
this with Identity Services and

00:55:12.400 --> 00:55:19.800
pretty much attempt to replicate the
kind of transparent experience you

00:55:19.990 --> 00:55:22.460
have working with iChat encryption.

00:55:22.480 --> 00:55:28.060
So again, this isn't, of course,
available in the WWDC seed release,

00:55:28.220 --> 00:55:31.780
but we're working hard on it.

00:55:33.620 --> 00:55:36.680
So now I really am done.

00:55:36.700 --> 00:55:38.610
In summary--

00:55:39.200 --> 00:55:43.200
We talked a lot about Identity
Services as the foundation for

00:55:43.200 --> 00:55:45.750
working with Identities on the Mac.

00:55:46.360 --> 00:55:50.360
In that architectural
diagram down at the bottom,

00:55:50.370 --> 00:55:51.540
I had Darwin.

00:55:51.600 --> 00:55:55.300
And in the Darwin box,
I just had Open Directory.

00:55:55.300 --> 00:56:00.080
But I wanted to point out that, in fact,
if you adopt Identity Services,

00:56:00.080 --> 00:56:02.030
it really abstracts you
from other things too.

00:56:02.040 --> 00:56:04.670
So for instance,
I could go back to the diagram and

00:56:04.670 --> 00:56:07.220
add Kerberos into the Darwin box.

00:56:07.220 --> 00:56:10.870
If you work with Identity Services,
it means you're abstracted from

00:56:11.220 --> 00:56:14.930
whatever we do under the API to
make the whole user experience of

00:56:14.930 --> 00:56:20.920
authentication and working with
access control lists that much better.

00:56:22.400 --> 00:56:23.580
Start investigating.

00:56:23.640 --> 00:56:25.950
If you're not familiar with Kerberos,
sounds like some of you are

00:56:25.950 --> 00:56:27.050
because we got some applause.

00:56:27.140 --> 00:56:27.600
That was cool.

00:56:27.600 --> 00:56:30.960
But this is something you're
going to be able to count on being

00:56:30.960 --> 00:56:33.720
available on all Leopard machines.

00:56:36.410 --> 00:56:40.910
And we hope to have more to say
about .Mac Identity Certificates

00:56:41.100 --> 00:56:43.260
in the not too distant future here.

00:56:44.160 --> 00:56:49.940
So we don't-- they compressed the
schedule on Friday here because,

00:56:49.940 --> 00:56:52.760
well, I guess we have to be out of
here by noon or something.

00:56:52.800 --> 00:56:55.630
And so we don't have time for questions.

00:56:55.750 --> 00:56:58.660
The next session actually
starts in 15 minutes.

00:56:58.690 --> 00:57:02.090
But for some reason,
they called our lab the

00:57:02.090 --> 00:57:04.750
Identity Picker Lab,
but it's really the

00:57:04.760 --> 00:57:06.820
Identity Services Lab.

00:57:06.850 --> 00:57:11.340
And it starts at 11 o'clock,
which means we're all late already.

00:57:11.340 --> 00:57:14.160
We're just going to be walking
down to the Mac OS X lab,

00:57:14.160 --> 00:57:17.780
and we'll be happy to take
your questions as we do that.

00:57:17.780 --> 00:57:19.900
So thanks very much.
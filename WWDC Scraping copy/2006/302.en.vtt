WEBVTT

00:00:10.950 --> 00:00:13.290
Good afternoon, everyone.

00:00:13.360 --> 00:00:14.630
My name is Matthew Formica.

00:00:14.730 --> 00:00:18.140
I'm the developer tools software
evangelist in developer relations,

00:00:18.310 --> 00:00:21.800
and we've got some great technology
to talk to you about this afternoon.

00:00:21.800 --> 00:00:26.540
So this is the Objective-C 2.0 Overview.

00:00:27.080 --> 00:00:31.530
And as you heard Ted Goldstein say
in the Developer Tools State of

00:00:31.540 --> 00:00:35.830
the Union yesterday,
Objective-C as a language is really

00:00:35.880 --> 00:00:40.400
Apple's secret weapon that helps us be
far more productive than other companies

00:00:40.400 --> 00:00:43.960
with much greater numbers of engineers.

00:00:43.960 --> 00:00:46.760
So how does Objective-C let
us be this productive?

00:00:46.760 --> 00:00:49.110
Well, it's due to a few reasons.

00:00:49.180 --> 00:00:51.630
First of all, some of the great features
that are in Objective-C.

00:00:51.670 --> 00:00:55.520
It's got a powerful dynamic runtime
and introspection capabilities

00:00:55.520 --> 00:00:59.540
that allow us to write really
flexible and reusable code.

00:00:59.540 --> 00:01:04.280
And Objective-C allows you to do
that in your applications as well.

00:01:04.310 --> 00:01:08.240
Secondly, we've got great OS integration
with the language.

00:01:08.240 --> 00:01:11.860
We've got frameworks that
know of and take advantage

00:01:11.860 --> 00:01:15.200
of the Objective-C language,
the Cocoa frameworks,

00:01:15.200 --> 00:01:19.730
and they work really well
together in a seamless manner.

00:01:20.040 --> 00:01:23.730
And finally, Objective-C as a language
is really easy to learn.

00:01:23.860 --> 00:01:31.130
It's not the complicated spaghetti code
you might get in some other languages.

00:01:31.130 --> 00:01:31.130
C++.

00:01:32.510 --> 00:01:33.400
and others.

00:01:33.400 --> 00:01:35.960
Being in developer relations,
I've seen many of you cross the

00:01:35.960 --> 00:01:39.750
hurdle to learn Objective-C over
the past several years,

00:01:39.750 --> 00:01:42.850
and usually there's some
hesitation at first,

00:01:42.850 --> 00:01:47.880
but then within a few days you've been
up and running using the language.

00:01:48.050 --> 00:01:51.090
There may be a few of you here
at the conference who are not

00:01:51.100 --> 00:01:53.080
yet using this amazing language.

00:01:53.210 --> 00:01:56.140
I encourage you to learn
it here at the conference.

00:01:56.140 --> 00:01:59.140
You can be fluent,
you can be using it within a few days

00:01:59.140 --> 00:02:01.800
and really fluent within a few weeks.

00:02:01.800 --> 00:02:04.650
We've got this additional layer,
Objective-C++,

00:02:04.770 --> 00:02:08.950
that allows you to actually intermingle
Objective-C code with C++ code so

00:02:09.070 --> 00:02:13.960
that if you do have cross-platform C++
code that you need to continue you can

00:02:14.090 --> 00:02:18.010
continue to use that with Objective-C.

00:02:18.480 --> 00:02:21.300
So Objective-C has these great benefits.

00:02:21.310 --> 00:02:26.710
They allow Apple and you as
developers to be amazingly productive.

00:02:26.990 --> 00:02:29.500
Objective-C is a great language.

00:02:29.550 --> 00:02:34.290
But some of the original architects
of the language at Apple got

00:02:34.290 --> 00:02:37.190
together and were thinking,
"What could we do to make

00:02:37.190 --> 00:02:39.210
the language even better?

00:02:39.380 --> 00:02:43.850
What would it mean to
improve on Objective-C?"

00:02:44.620 --> 00:02:47.220
And as they thought about this,
they came up with some goals

00:02:47.380 --> 00:02:52.370
that an improved version 2 of
Objective-C would need to meet.

00:02:54.860 --> 00:02:57.140
The Objective-C goals would be fourfold.

00:02:57.140 --> 00:02:59.140
First of all,
they wanted to build in first-class

00:02:59.140 --> 00:03:01.240
support for Cocoa idioms.

00:03:01.240 --> 00:03:03.560
Over the years,
we've seen that there are common

00:03:03.560 --> 00:03:08.500
patterns to how you use Cocoa,
and we wanted to make a fast path

00:03:08.500 --> 00:03:13.100
through the language to using
those common patterns in Cocoa.

00:03:13.340 --> 00:03:16.160
Secondly,
we wanted to make the SQL perform

00:03:16.160 --> 00:03:18.440
even better than the original.

00:03:18.440 --> 00:03:23.700
And that's because the uses of
Objective-C are far greater now and

00:03:23.700 --> 00:03:29.320
applications are far larger than they
were when Objective-C was first invented.

00:03:29.730 --> 00:03:33.080
Thirdly, the science of language design
has continued to advance,

00:03:33.220 --> 00:03:36.050
and there are other features that
have been invented that we wanted

00:03:36.050 --> 00:03:37.520
to incorporate into the language.

00:03:37.600 --> 00:03:41.440
And we wanted to do all of this in
a way that didn't break existing

00:03:41.440 --> 00:03:45.530
Cocoa Objective-C applications
on the platform.

00:03:47.820 --> 00:03:51.940
So what would it mean to make
Objective-C achieve those goals?

00:03:51.940 --> 00:03:53.650
It would mean revving the language.

00:03:53.820 --> 00:03:55.680
And that's exactly what we've done.

00:03:55.700 --> 00:03:59.020
And so this session is about
the improved Objective-C,

00:03:59.120 --> 00:04:02.700
Objective-C 2.0,
that hits those design goals.

00:04:02.700 --> 00:04:06.460
And so what you're going to learn
about in this session is all the new

00:04:06.460 --> 00:04:11.080
language features that we've added,
including several that have not yet been

00:04:11.080 --> 00:04:13.700
talked about in the states of the union.

00:04:13.700 --> 00:04:16.370
We're going to tell you a
little bit about some aspects

00:04:16.480 --> 00:04:17.700
of the rewritten runtime.

00:04:17.700 --> 00:04:23.030
And actually, since in 64-bit computing,
we aren't limited by the

00:04:23.030 --> 00:04:27.700
same ABI requirements that
32-bit applications have,

00:04:27.700 --> 00:04:30.700
we don't need to maintain
binary compatibility.

00:04:30.930 --> 00:04:33.270
There are actually some features
that we could only implement

00:04:33.270 --> 00:04:34.660
for 64-bit applications.

00:04:34.700 --> 00:04:38.690
So 64-bit apps get to go even further.

00:04:38.750 --> 00:04:42.700
And to explain these features and more,
I'd like to introduce Blaine Garst,

00:04:42.700 --> 00:04:46.510
one of the architects of Objective-C2.

00:04:51.100 --> 00:04:53.100
Let's see, is this mic working yet?

00:04:53.100 --> 00:04:53.760
Is this mic working?

00:04:53.900 --> 00:04:55.100
Okay, good.

00:04:55.100 --> 00:04:57.810
Let's talk about garbage
collection first of all.

00:04:58.100 --> 00:09:00.000
[Transcript missing]

00:09:00.210 --> 00:09:02.020
It's an opt-in system.

00:09:02.050 --> 00:09:05.980
You get it by compiling with
this magic little compiler flag.

00:09:05.980 --> 00:09:07.600
There's a checkbox in Xcode.

00:09:07.600 --> 00:09:11.280
I'll show you that in
the talk following this.

00:09:11.460 --> 00:09:15.530
All Apple frameworks work in both modes.

00:09:15.600 --> 00:09:22.410
So if there's a framework on the system,
it will be GC-capable by lepidogia.

00:09:22.440 --> 00:09:27.160
We didn't quite get to all of them in
the seed that you have in your hands,

00:09:27.280 --> 00:09:31.930
but all the major kits are converted,
and we've run lots of code against them,

00:09:31.930 --> 00:09:33.940
including Xcode internally.

00:09:33.940 --> 00:09:38.710
And as you saw on a TED stage,
we even went and talked to the

00:09:38.710 --> 00:09:42.340
Omni guys and got several of their
apps up and running on it too.

00:09:42.360 --> 00:09:48.720
So the basic scheme in order
for our frameworks internally

00:09:48.810 --> 00:09:52.010
to run in both modes is that
they still have to have all that

00:09:52.010 --> 00:09:54.730
retain-release code and logic in there.

00:09:54.730 --> 00:09:58.980
It's just that the runtime
just ignores those messages.

00:09:58.980 --> 00:10:00.980
It's like, you know, in two instructions,
we detect that it's one of

00:10:00.980 --> 00:10:02.580
these things and just bail out.

00:10:02.580 --> 00:10:07.930
And so there's no code,
no retain-release code is ever executed.

00:10:08.380 --> 00:10:12.240
The major new way to think about things,
though,

00:10:12.240 --> 00:10:16.430
is that instead of a dialog method,
you know, dialog methods sometimes

00:10:16.510 --> 00:10:19.630
really do something important,
like let go of a resource.

00:10:19.700 --> 00:10:22.560
And so in those cases,
you do need an equivalent.

00:10:22.560 --> 00:10:24.620
You need what we call a finalized method.

00:10:24.800 --> 00:10:30.480
And so if, and only if,
you need to get rid of resources,

00:10:30.550 --> 00:10:34.980
you need to write a finalized method,
and we provide support for that.

00:10:35.220 --> 00:10:39.420
What's fun is we've added some more
tool support to make that happen.

00:10:39.420 --> 00:10:42.580
You may have seen X-Ray showing
garbage collections going on

00:10:42.580 --> 00:10:46.270
when a text edit was converted.

00:10:46.360 --> 00:10:51.500
It turns out that text edit needed no
changes whatsoever to run in a GC mode.

00:10:51.500 --> 00:10:54.520
It didn't do anything really
magic in its DLX methods,

00:10:54.520 --> 00:10:59.700
and so you just compile it with the
GC flag and it comes up and runs.

00:10:59.700 --> 00:11:03.990
So very simple applications require
very little work to get up and run.

00:11:05.250 --> 00:11:08.360
So as I said earlier,
internally we've been using

00:11:08.360 --> 00:11:12.500
Xcode to kind of push our
changes through everything else.

00:11:12.500 --> 00:11:17.010
We have some of the small apps
and there's other apps internally.

00:11:17.990 --> 00:11:23.280
We have, I think, a fairly small API for
garbage collection.

00:11:23.310 --> 00:11:30.120
It is obviously about reducing your code,
and so we don't have to force

00:11:30.120 --> 00:11:33.340
a lot of new ideas on you,
but we do have a few things.

00:11:33.340 --> 00:11:37.590
We have a garbage collector object,
which you can query about what's going

00:11:37.590 --> 00:11:40.280
on and to do a few critical operations.

00:11:40.390 --> 00:11:44.710
We've updated map tables and
hash tables from sort of opaque

00:11:44.710 --> 00:11:50.340
structures into first-class
objects that deal with objects,

00:11:50.340 --> 00:11:53.930
including this new concept
called a weak object,

00:11:54.000 --> 00:12:00.690
meaning there still are cases where you
do want to have sort of a non-retained

00:12:00.690 --> 00:12:02.320
reference to something else.

00:12:02.340 --> 00:12:04.970
In Java, there's something
called a weak reference,

00:12:04.970 --> 00:12:08.340
and when it's an object itself,
and you can put a pointer into it.

00:12:08.340 --> 00:12:09.570
And when the referenced
object is not retained,

00:12:09.630 --> 00:12:10.340
it's not a weak reference.

00:12:10.340 --> 00:12:13.340
And when the referenced object goes away,
the weak reference gets zeroed.

00:12:13.340 --> 00:12:15.340
Well, we put that into the language.

00:12:15.340 --> 00:12:20.340
So we actually have a weak attribute that
you can put on your instance variables

00:12:20.350 --> 00:12:24.330
and on globals such that when the
collector collects the referenced object,

00:12:24.490 --> 00:12:26.340
your instance variable gets zeroed out.

00:12:26.340 --> 00:12:28.340
It's very cool.

00:12:28.340 --> 00:12:31.340
We have had for some time now
the finalize and drain methods.

00:12:31.340 --> 00:12:36.930
We started this work several years ago,
and in fact, Tiger Reflex has a lot of

00:12:36.990 --> 00:12:39.220
almost GC-ready code in it.

00:12:39.340 --> 00:12:40.340
There's a lot of stuff.

00:12:40.340 --> 00:12:45.150
We have an allocate collectible
routine to actually let you allocate

00:12:45.150 --> 00:12:48.130
collectible memory and do things with it.

00:12:48.340 --> 00:12:55.680
And all this and more in depth is going
to be told to you in this room in the

00:12:55.780 --> 00:13:00.180
session immediately following this one.

00:13:00.340 --> 00:13:03.980
It's too much to go into in this talk,
and so that's just sort of

00:13:03.980 --> 00:13:06.340
a teaser for the next talk,
really.

00:13:06.340 --> 00:13:09.170
So let's go on to the next topic.

00:13:09.890 --> 00:13:12.200
Fast enumeration.

00:13:13.220 --> 00:13:17.840
We had, for fast enumeration,
several girls.

00:13:17.960 --> 00:13:20.620
We wanted to make enumeration fast.

00:13:20.620 --> 00:13:24.870
I will show you some code
examples later as to...

00:13:26.000 --> 00:13:51.800
[Transcript missing]

00:13:52.400 --> 00:13:54.410
Let's talk about enumerating arrays.

00:13:54.410 --> 00:13:58.000
Now, if you're a real object
programmer and it's time to

00:13:58.000 --> 00:14:02.300
walk through an array object,
you might start out by just getting the

00:14:02.300 --> 00:14:05.170
object enumerator and running through it.

00:14:05.170 --> 00:14:07.930
It's pretty nice.

00:14:08.210 --> 00:14:11.020
But it has some expense.

00:14:11.020 --> 00:14:14.300
You have to allocate
an enumerator object.

00:14:14.330 --> 00:14:21.290
And it turns out for safety reasons,
over the 15 years since we put this in,

00:14:21.300 --> 00:14:26.400
it turns out that the enumerator
objects actually had to make a copy of

00:14:26.450 --> 00:14:31.220
all the elements inside the collection
in order to vend them to you safely.

00:14:31.300 --> 00:14:36.300
And making a copy of all those
elements is actually expensive.

00:14:36.300 --> 00:14:40.300
So once the copy is established, though,
in the middle of the loop,

00:14:40.300 --> 00:14:42.610
the inner part of the loop,
it boils down to one

00:14:42.610 --> 00:14:44.300
method call per item.

00:14:44.300 --> 00:14:45.480
title.

00:14:45.900 --> 00:15:47.600
[Transcript missing]

00:15:47.850 --> 00:15:51.800
Wouldn't it be nice if we could
simply write this instead?

00:15:51.980 --> 00:15:56.270
And so the cost with this,
with language support,

00:15:56.400 --> 00:16:00.540
is two hidden method calls to
go through the entire array.

00:16:00.690 --> 00:16:03.630
You get a benefit that we put
a safety check in the middle.

00:16:03.760 --> 00:16:07.740
We check to see whether or not that
collection has been changed while

00:16:07.740 --> 00:16:09.660
you're in the middle of the enumeration.

00:16:09.830 --> 00:16:13.130
Because that happens, it turns out.

00:16:13.300 --> 00:16:15.960
Even though our documentation
says that it shouldn't,

00:16:16.030 --> 00:16:18.870
you shouldn't trust on that,
it turns out that there

00:16:18.870 --> 00:16:20.340
is a fair amount of code.

00:16:20.340 --> 00:16:23.550
And I could cite the radars,
but we don't really

00:16:23.550 --> 00:16:25.260
want to get into that.

00:16:25.360 --> 00:16:29.090
So there's a hidden mutation
safety check in the middle of that.

00:16:29.300 --> 00:16:32.740
And the other benefit, of course,
is that it's concise.

00:16:32.850 --> 00:16:35.860
You don't have to repeat
that NSString twice.

00:16:35.860 --> 00:16:38.660
You don't have to have
an unsigned int counter.

00:16:38.660 --> 00:16:39.600
I always type int.

00:16:39.670 --> 00:16:42.600
I mean, you know, it just reads better.

00:16:42.680 --> 00:16:43.910
So I like that.

00:16:44.160 --> 00:16:46.380
It's a better way to program.

00:16:46.660 --> 00:16:50.230
Let's show you a little bit of
the performance going on here.

00:16:50.390 --> 00:16:55.510
So the first line is our
new fast enumeration scheme.

00:16:55.570 --> 00:17:00.590
This is for arrays of size, you know,
factor of 10 on up to 100,000.

00:17:00.600 --> 00:17:04.820
So it turns out that at size 10,
you know, there might be a little bit of

00:17:04.820 --> 00:17:08.500
a setup cost still apparent,
but by size 100, it's just linear with

00:17:08.500 --> 00:17:09.600
the number of objects.

00:17:09.600 --> 00:17:13.600
Remember, there's no object copying
going on with this one.

00:17:13.600 --> 00:17:17.090
We're just going in,
getting the raw pointer to the memory,

00:17:17.190 --> 00:17:18.790
and ripping through it.

00:17:19.280 --> 00:17:25.330
The super-extreme code, you know,
that big bunch of boilerplate,

00:17:25.460 --> 00:17:26.420
comes in pretty fast.

00:17:26.480 --> 00:17:29.840
You know,
it's pretty competitive on a speed level.

00:17:29.910 --> 00:17:32.190
But remember,
it is doing a copy of all the

00:17:32.190 --> 00:17:33.940
elements most of the time.

00:17:33.940 --> 00:17:35.820
Anything above 100 is a copy.

00:17:35.820 --> 00:17:37.560
So we've sort of done the impossible.

00:17:37.560 --> 00:17:38.560
We've squared the circle.

00:17:38.560 --> 00:17:43.420
We have gotten the speed
without paying for the memory.

00:17:43.420 --> 00:17:44.640
It's a very nice win.

00:17:44.640 --> 00:17:46.320
We really like that.

00:17:46.320 --> 00:17:50.580
Looking at the standard objected index
shows you what some people have found if

00:17:50.580 --> 00:17:53.520
they've done some performance analysis.

00:17:53.520 --> 00:17:57.120
Objected index is
actually pretty expensive.

00:17:57.120 --> 00:17:59.930
The fun thing here is
that for large objects,

00:17:59.930 --> 00:18:03.510
that very first one,
the enumerator example, is actually,

00:18:03.510 --> 00:18:04.690
you know, comes in ahead.

00:18:04.710 --> 00:18:07.620
But you know,
arrays are not often 1,000 in size.

00:18:07.620 --> 00:18:14.390
So in the low sizes, you know, 0 to 100,
the enumerator example is just way, way,

00:18:14.390 --> 00:18:14.810
way expensive.

00:18:15.100 --> 00:18:17.540
So I talked about how we
did a good job for arrays.

00:18:17.580 --> 00:18:20.880
This is a feature for all collections,
however, and another common collection

00:18:20.880 --> 00:18:21.950
we have are dictionaries.

00:18:22.100 --> 00:18:25.110
And so this is the standard code
that you have to write to go through

00:18:25.110 --> 00:18:27.100
the elements of a dictionary.

00:18:27.150 --> 00:18:29.600
And this is the code you're
going to write to go through the

00:18:29.600 --> 00:18:31.080
elements of a dictionary now.

00:18:31.190 --> 00:18:34.100
Again, a little bit more concise.

00:18:34.100 --> 00:18:40.100
And again, remember that in all cases
these objects were copied.

00:18:40.100 --> 00:18:43.460
Well, as of Leopard,
those objects aren't going

00:18:43.460 --> 00:18:45.100
to be copied anymore.

00:18:45.100 --> 00:18:48.090
So enumeration has gotten
a little bit faster,

00:18:48.100 --> 00:18:51.100
and you're going to be -- if
you compile and target Leopard,

00:18:51.100 --> 00:18:55.200
you may get some enumeration mutation
warnings coming out of these guys if

00:18:55.200 --> 00:18:59.100
you've been cheating and changing your
collections while enumerating them.

00:18:59.100 --> 00:19:03.090
Let's take a look at the graph of
the performance for dictionaries.

00:19:03.490 --> 00:19:06.640
Again, the first one is fast enumeration.

00:19:06.640 --> 00:19:12.000
We don't quite get to rip along
as fast as we do with arrays.

00:19:12.000 --> 00:19:13.190
There's an extra null check.

00:19:13.380 --> 00:19:18.080
There's essentially one method
call per element in this case.

00:19:18.080 --> 00:19:22.750
And the existing enumerator is, you know,
we're a little bit faster

00:19:23.220 --> 00:19:26.790
than the existing enumerator,
although in this case it

00:19:26.880 --> 00:19:28.420
was still copying memory.

00:19:28.450 --> 00:19:30.790
So again,
we're faster without using the memory.

00:19:30.930 --> 00:19:35.180
And for small objects,
for small dictionaries,

00:19:35.230 --> 00:19:36.910
the cost is just exorbitant.

00:19:37.090 --> 00:19:42.290
Clearly, you want to use the new language
mechanism whenever you can to get

00:19:42.290 --> 00:19:45.570
through your small object dictionaries.

00:19:46.550 --> 00:19:53.160
What you've seen so far syntactically is
you put the type declarator right in the

00:19:53.160 --> 00:19:58.490
middle of the parenthesized expression,
but you don't have to.

00:19:58.520 --> 00:20:03.620
If you already have an iterator variable
that you want to use for other purposes,

00:20:03.620 --> 00:20:05.520
you can go ahead and use that also.

00:20:05.520 --> 00:20:11.470
Here's examples of both forms,
showing that as a for statement,

00:20:11.540 --> 00:20:15.520
so the regular control flow
operations work as you would expect.

00:20:15.520 --> 00:20:20.570
You can return from the middle,
you can break out and have the last value

00:20:20.600 --> 00:20:23.360
assigned in there available for you.

00:20:26.440 --> 00:20:33.600
Inside Cocoa, of course, the collections,
mutable and immutable variations

00:20:33.600 --> 00:20:35.580
on the collections adopt this.

00:20:35.820 --> 00:20:39.930
The new map table and hash
table objects also adopt this,

00:20:39.930 --> 00:20:43.500
and as I said before,
all NS enumerators have

00:20:43.500 --> 00:20:45.000
an implementation of this.

00:20:45.100 --> 00:20:49.320
If you've coded your own,
you can override this method and

00:20:49.320 --> 00:20:52.190
make it even faster if you know how.

00:20:53.000 --> 00:20:55.080
These are just some of the objects.

00:20:55.080 --> 00:20:57.710
I didn't go through the header
files and name them all,

00:20:57.750 --> 00:21:00.600
but it's there where you want it.

00:21:00.620 --> 00:21:03.720
So let me talk just a little
bit about the implementation.

00:21:03.900 --> 00:21:04.570
It's fun.

00:21:04.750 --> 00:21:07.000
So when the compiler sees
that language statement,

00:21:07.000 --> 00:21:10.400
it synthesizes this on-stack
sort of state buffer with some

00:21:10.400 --> 00:21:12.780
pointers in the middle of it.

00:21:12.800 --> 00:21:17.800
It calls into a batch enumerator
to grab a bunch at a time.

00:21:17.800 --> 00:21:20.230
And once it gets a
batch of them at a time,

00:21:20.230 --> 00:21:27.300
it loops through them doing a mutation
check before it hands off to your code.

00:21:27.300 --> 00:21:32.600
The collections implement this method,
and the method basically says, you know,

00:21:32.600 --> 00:21:35.600
you get this state
field coming in at zero.

00:21:35.600 --> 00:21:37.190
That means it's the start of one.

00:21:37.190 --> 00:21:41.270
It resets it to be some internal state,
sets a guard pointer

00:21:41.370 --> 00:21:47.400
for the mutation check,
and sets the pointer to the real objects.

00:21:47.400 --> 00:21:49.200
And it returns how
many of them there are.

00:21:49.200 --> 00:21:52.560
It's pretty simple.

00:21:52.710 --> 00:21:54.470
You don't really want to
have to remember this,

00:21:54.570 --> 00:21:57.620
but for reference,
that's what the structure looks like,

00:21:57.700 --> 00:22:00.600
and that's the method that
the collections implement.

00:22:00.600 --> 00:22:04.640
A simple implementation of
that method for an array with

00:22:04.640 --> 00:22:07.590
just a list of objects is,
as I said,

00:22:07.590 --> 00:22:11.170
you set the state to be 1 to say,
you know, next time you're in,

00:22:11.170 --> 00:22:11.600
we're done.

00:22:11.600 --> 00:22:15.650
You set the mutation pointer,
in this case, to yourself,

00:22:15.650 --> 00:22:19.320
because in this example,
you're an immutable array.

00:22:19.600 --> 00:22:23.700
Set the element pointer
and return the count.

00:22:24.310 --> 00:22:27.820
So when the compiler
sees this in your code,

00:22:27.820 --> 00:22:29.000
what it generates

00:22:30.860 --> 00:22:49.410
is this.

00:22:50.590 --> 00:22:50.600
It's a lot of code.

00:22:50.600 --> 00:22:50.600
You don't want to have to write that.

00:22:50.600 --> 00:22:50.600
You want the compiler
to write it for you.

00:22:50.600 --> 00:22:50.600
That's what compilers are good for.

00:22:50.600 --> 00:22:50.600
So if you wanted to use
that method by yourself,

00:22:50.600 --> 00:22:50.600
you've got to do this in your code.

00:22:50.600 --> 00:22:50.600
I don't know why you necessarily would.

00:22:50.710 --> 00:22:54.040
And with that,
let's shift gears a little bit.

00:22:54.040 --> 00:22:55.770
We've made a couple other
changes to the language.

00:22:55.780 --> 00:22:56.910
One of them is to protocols.

00:22:56.920 --> 00:23:03.370
Protocols came into the language
about 15 years ago and from one

00:23:03.830 --> 00:23:10.320
person's viewpoint here at Apple,
they were missing something.

00:23:10.450 --> 00:23:14.700
Ali Ozer has been ringing
our necks for years saying,

00:23:14.700 --> 00:23:19.670
"I can't use them to describe
delegate methods." He calls those

00:23:19.670 --> 00:23:24.090
informal protocols and he's right.

00:23:24.090 --> 00:23:24.980
You can't use protocols.

00:23:24.980 --> 00:23:28.060
Protocols say,
"Here's a set of methods you

00:23:28.060 --> 00:23:31.720
must define." They're a nice
grouping function for that.

00:23:31.790 --> 00:23:33.820
So what we've done is

00:23:34.150 --> 00:23:37.540
has added a capability to protocols now.

00:23:37.540 --> 00:23:41.550
So what Cocoa does today
to describe these informal

00:23:41.550 --> 00:23:44.570
protocols-- this is a real example.

00:23:44.760 --> 00:23:46.920
The layout manager
delegate has two methods.

00:23:46.920 --> 00:23:49.740
It's the first one I could
find that only had two.

00:23:49.790 --> 00:23:51.160
These are either/or.

00:23:51.160 --> 00:23:52.890
Use one or both, you know.

00:23:52.960 --> 00:23:57.370
And he declares them as a category
on NSObject just so that you have

00:23:57.370 --> 00:24:01.520
some type information available
so you know what the types are

00:24:01.550 --> 00:24:03.790
to your arguments and stuff.

00:24:04.410 --> 00:24:06.100
Yeah, it works.

00:24:06.300 --> 00:24:09.050
What would be better is
if you had a protocol,

00:24:09.130 --> 00:24:14.960
if you could declare that concept
in a protocol and say optional

00:24:15.150 --> 00:24:16.660
about the methods that follow it.

00:24:16.900 --> 00:24:21.580
And so we put that in as a--

00:24:25.920 --> 00:24:34.430
Ali has not had time to actually rewrite
all of Cocoa or all the headers yet,

00:24:34.430 --> 00:24:37.960
but he will because we did this already.

00:24:37.960 --> 00:24:38.720
Well, anyway, he will.

00:24:38.750 --> 00:24:41.160
He has every intention of making
this happen by Leopard GM.

00:24:41.160 --> 00:24:44.410
So in the future,
what you're going to see in the header

00:24:44.410 --> 00:24:48.120
files is that in the layout manager,
you're going to get to type

00:24:48.120 --> 00:24:51.160
the delegate being set,
and then in your code,

00:24:51.160 --> 00:24:55.270
you get to say that you're going to
be adopting one of those methods.

00:24:55.300 --> 00:25:00.770
And so that makes your code easier,
the design of your code

00:25:00.770 --> 00:25:03.040
more easily expressed.

00:25:03.530 --> 00:25:06.820
This is going to be adopting this thing,
and so when you set it,

00:25:06.820 --> 00:25:10.630
the compiler is going to be very
happy with you when you do this.

00:25:11.120 --> 00:25:12.400
Hmm.

00:25:12.510 --> 00:25:17.910
For completeness,
there is also an @ required.

00:25:18.220 --> 00:25:21.730
And that lets you, you know,
mix and match and design your

00:25:21.730 --> 00:25:24.080
protocol layout the way you want.

00:25:24.100 --> 00:25:28.000
And with that,
I'd like to hand the podium

00:25:28.000 --> 00:25:31.100
over to Patrick Beard,
who's going to talk about a feature

00:25:31.100 --> 00:25:34.990
you've seen several times already,
and that's ""properties.""

00:25:41.600 --> 00:25:45.230
And that lets you, you know,
mix and match and design your

00:25:45.230 --> 00:25:47.600
protocol layout the way you want.

00:25:47.600 --> 00:25:51.500
And with that,
I'd like to hand the podium

00:25:51.500 --> 00:25:54.070
over to Patrick Beard,
who's going to talk about a feature

00:25:54.070 --> 00:25:54.070
you've seen several times already,
and that's ""properties.""

00:25:54.840 --> 00:25:58.270
Properties,
what we really wanted to do with them was

00:25:58.270 --> 00:26:01.580
to streamline support for encapsulation.

00:26:01.580 --> 00:26:04.960
So with properties in your code,
you get the convenience and

00:26:05.020 --> 00:26:08.600
sort of the similarity to
variables and instance variables,

00:26:08.650 --> 00:26:12.010
but you get the encapsulation of
methods and all the power that

00:26:12.010 --> 00:26:14.600
goes along with key value coding.

00:26:14.600 --> 00:26:17.660
You know and love if you're
an AppKit diehard user.

00:26:17.660 --> 00:26:23.640
One of the other things about properties
is they're very easy to add to your code.

00:26:23.660 --> 00:26:27.330
They're very easy to adopt
because if you've already written

00:26:27.380 --> 00:26:30.790
KVC compliant accessor methods,
you just declare a property and

00:26:30.880 --> 00:26:33.810
the property will be implemented
in terms of those accessor methods.

00:26:35.080 --> 00:26:36.840
And here's the real killer feature.

00:26:36.960 --> 00:26:40.690
We support automatic generation of
accessor methods when you use properties.

00:26:40.790 --> 00:26:43.340
We call these synthesized properties.

00:26:43.410 --> 00:26:46.500
And they're going to make a lot of the
tedious code you may have to write,

00:26:46.500 --> 00:26:50.040
some of the code you saw
earlier in the GC section,

00:26:50.090 --> 00:26:51.700
just go away.

00:26:52.870 --> 00:26:54.760
And here's the real killer feature.

00:26:54.760 --> 00:26:58.500
We support automatic generation of
accessor methods when you use properties.

00:26:58.500 --> 00:27:01.140
We call these synthesized properties.

00:27:01.140 --> 00:27:04.300
And they're going to make a lot of the
tedious code you may have to write,

00:27:04.300 --> 00:27:07.880
some of the code you saw
earlier in the GC section,

00:27:07.880 --> 00:27:09.500
just go away.

00:27:13.960 --> 00:27:15.860
And here's the real killer feature.

00:27:15.860 --> 00:27:19.600
We support automatic generation of
accessor methods when you use properties.

00:27:19.600 --> 00:27:22.240
We call these synthesized properties.

00:27:22.240 --> 00:27:25.400
And they're going to make a lot of the
tedious code you may have to write,

00:27:25.400 --> 00:27:28.970
some of the code you saw
earlier in the GC section,

00:27:29.180 --> 00:27:30.560
just go away.

00:27:35.490 --> 00:27:37.360
And here's the real killer feature.

00:27:37.360 --> 00:27:41.090
We support automatic generation of
accessor methods when you use properties.

00:27:41.090 --> 00:27:43.740
We call these synthesized properties.

00:27:43.740 --> 00:27:46.900
And they're going to make a lot of the
tedious code you may have to write,

00:27:46.900 --> 00:27:50.480
some of the code you saw
earlier in the GC section,

00:27:50.480 --> 00:27:52.070
just go away.

00:27:58.220 --> 00:28:03.280
Categories, and, gotta love 'em,
Protocols.

00:28:03.870 --> 00:28:06.970
The great thing about properties
on protocols is they let you

00:28:06.970 --> 00:28:10.420
model both behavior and state.

00:28:10.420 --> 00:28:15.200
You can define a generic queue,
for example, with generic nodes that

00:28:15.200 --> 00:28:19.780
would have next fields,
next properties, and write some really

00:28:19.800 --> 00:28:21.820
interesting generic code.

00:28:21.820 --> 00:28:26.710
All of these classes, all of these forms,
also have metadata generated for

00:28:26.710 --> 00:28:28.410
them that's available at runtime.

00:28:28.460 --> 00:28:32.780
So you can walk up to a class
that purports to implement a

00:28:32.780 --> 00:28:37.860
particular protocol or a category,
all the metadata for categories

00:28:37.860 --> 00:28:40.980
is merged into classes,
and walk up to a class and ask it,

00:28:40.980 --> 00:28:44.740
"What are all the things you support
as properties?" And reflect on them,

00:28:44.740 --> 00:28:46.300
print them out, do interesting things.

00:28:49.780 --> 00:28:54.370
So here's synthesized properties.

00:28:54.420 --> 00:28:58.420
First thing to note is something
called a property attribute.

00:28:58.700 --> 00:29:03.180
Property attributes are directives
to the compiler to say how to

00:29:03.180 --> 00:29:08.140
implement the property or how the
property's behavior should work.

00:29:08.230 --> 00:29:12.190
So in this case,
the Ivar property attribute

00:29:12.320 --> 00:29:15.600
tells the compiler to
synthesize the implementation.

00:29:15.610 --> 00:29:20.450
It declares an instance variable,
underscore name in this case.

00:29:20.470 --> 00:29:24.200
It declares and implements
the accessor methods.

00:29:24.430 --> 00:29:26.690
So you write this.

00:29:27.400 --> 00:29:58.700
[Transcript missing]

00:29:59.000 --> 00:30:19.900
[Transcript missing]

00:30:22.690 --> 00:30:25.770
So here's how you add a
property to existing code.

00:30:25.790 --> 00:30:28.360
I'm just showing this in
context of an AppKit class.

00:30:28.480 --> 00:30:32.670
It already defines the title
and set title accessor methods.

00:30:32.750 --> 00:30:37.640
So simply declaring @property in a
string title gives the compiler enough

00:30:37.740 --> 00:30:42.700
information to let you start accessing
that property using dot notation.

00:30:42.740 --> 00:30:44.160
You're done.

00:30:47.090 --> 00:30:51.480
You can even simplify it further and
remove the accessors if you like.

00:30:51.660 --> 00:30:55.040
The compiler is, in essence,
declaring those accessors

00:30:55.040 --> 00:30:57.490
when it sees this property.

00:31:00.360 --> 00:31:03.560
So I was talking,
I introduced property attributes

00:31:03.720 --> 00:31:06.420
by way of example with Ivar.

00:31:06.420 --> 00:31:09.300
We actually classify our
attributes into two forms,

00:31:09.300 --> 00:31:12.970
those which are interesting
to clients and those which are

00:31:12.970 --> 00:31:16.860
interesting to implementers,
implementation details.

00:31:16.950 --> 00:31:21.310
And we try to keep the client property
attributes in the interface file,

00:31:21.310 --> 00:31:26.410
in the header file, and try to move the
implementation attributes where

00:31:26.410 --> 00:31:28.530
no one else has to see them.

00:31:28.600 --> 00:31:30.840
So the first three,
the three client attributes

00:31:30.840 --> 00:31:33.480
I want to tell you about,
one is the read-only attribute

00:31:33.530 --> 00:31:36.530
that allows you to declare
this property can only be read,

00:31:36.560 --> 00:31:38.180
cannot be set.

00:31:38.240 --> 00:31:44.580
The compiler, if you say x.y equals zero,
it will refuse.

00:31:46.110 --> 00:31:51.800
We also defined three attributes that
tell how to manage an object reference.

00:31:51.950 --> 00:31:53.400
One is by copy.

00:31:53.570 --> 00:31:58.890
This is appropriate for a key
value coding attribute or by value,

00:31:58.890 --> 00:32:01.640
such as a string or an NSNumber.

00:32:01.790 --> 00:32:05.700
What happens is when you
synthesize such a property,

00:32:05.850 --> 00:32:09.930
we will call the NS copying
protocol methods "copy with zone"

00:32:09.940 --> 00:32:14.350
on the object when it's assigned
into your object automatically.

00:32:14.660 --> 00:32:19.290
The complement of byCopy is byRef,
which is default, and that just means

00:32:19.290 --> 00:32:21.080
use a retained pointer.

00:32:21.130 --> 00:32:23.750
And the third example is Weak.

00:32:23.780 --> 00:32:26.640
In the garbage collection system,
Weak will give you a zeroing

00:32:26.640 --> 00:32:29.090
weak reference in your property.

00:32:29.110 --> 00:32:33.470
In non-garbage collection mode,
you'll just get a non-retained pointer.

00:32:34.930 --> 00:32:36.800
So implementation attributes.

00:32:36.900 --> 00:32:42.210
Technically the IVAR attribute is what
we call an implementation attribute,

00:32:42.210 --> 00:32:45.790
although for architectural reasons it
has to go in your header file today.

00:32:45.800 --> 00:32:50.800
That's because we need to know all of the
instance variables that are in your class

00:32:50.800 --> 00:32:56.610
so that subclasses can infer how large
your class is to do their IVAR layout.

00:32:57.400 --> 00:33:01.330
In 64-bit, we'll actually be able to
move the IVAR attribute

00:33:01.470 --> 00:33:02.660
outside of the header file.

00:33:02.870 --> 00:33:04.240
It's sort of an implementation detail.

00:33:04.320 --> 00:33:07.980
Clients of your property don't really
care that it's synthesized or not.

00:33:07.980 --> 00:33:09.900
They just want to use it.

00:33:10.480 --> 00:33:15.160
The Ivar= form definitely belongs
inside the @Implementation.

00:33:15.160 --> 00:33:17.480
And so what I haven't shown
you is that you can declare,

00:33:17.480 --> 00:33:21.060
re-declare your property the same
way you declare methods in your

00:33:21.060 --> 00:33:23.160
@Implementation section of your class.

00:33:23.160 --> 00:33:28.340
When you use Ivar=,
your Italian compiler synthesizes

00:33:28.340 --> 00:33:32.160
the accessor methods in terms of an
already existing instance variable.

00:33:32.160 --> 00:33:34.880
So it doesn't have to match
a particular naming pattern.

00:33:34.970 --> 00:33:36.080
You specify the name.

00:33:36.160 --> 00:33:41.730
The getter=setter= form,
a good example of why you might want

00:33:41.730 --> 00:33:46.810
to use it is if you have a case of
pre-existing accessor methods that don't

00:33:46.810 --> 00:33:50.100
match the compiler's default pattern,
which is property name

00:33:50.100 --> 00:33:51.160
and set property name.

00:33:51.160 --> 00:33:54.150
Those are the default
names for a property.

00:33:54.160 --> 00:33:56.150
A good example is Boolean properties.

00:33:56.160 --> 00:33:59.980
Boolean properties,
many of them begin with "is," although

00:33:59.980 --> 00:34:04.160
their setter is "set." So set name,
is name.

00:34:04.220 --> 00:34:06.160
Auto display is a good
example of that property.

00:34:06.160 --> 00:34:08.250
property in Ennis Window.

00:34:08.400 --> 00:34:10.060
Again, this is an implementation detail.

00:34:10.060 --> 00:34:12.940
No one's interested in seeing these
sort of ugly-- what I would consider

00:34:12.940 --> 00:34:16.100
ugly directives in the header file.

00:34:17.450 --> 00:34:20.650
Finally, the really exciting and,
I think,

00:34:20.650 --> 00:34:24.890
innovative thing about properties,
beyond what I've already said,

00:34:24.990 --> 00:34:27.320
is something we call dynamic properties.

00:34:27.430 --> 00:34:32.540
Dynamic properties are properties that
don't have an implementation that the

00:34:32.540 --> 00:34:35.090
compiler can find at compile time.

00:34:35.200 --> 00:34:36.840
They are resolved at runtime.

00:34:36.930 --> 00:34:41.160
So the next section I'm going to go into
more details about dynamic properties.

00:34:42.110 --> 00:34:47.020
Dynamic properties allow a class,
for example, to provide services to its

00:34:47.020 --> 00:34:50.700
subclasses in the way of

00:34:50.980 --> 00:34:54.400
The properties that it didn't
know about at compile time.

00:34:54.410 --> 00:34:58.020
By using the property metadata,
we can get the name of the property and

00:34:58.020 --> 00:34:59.300
we can get the type of the property.

00:34:59.300 --> 00:35:01.830
And all, in fact,
all of the property attributes

00:35:01.830 --> 00:35:04.800
that I've told you about are
all expressed in the metadata.

00:35:04.800 --> 00:35:09.390
So you can look at them,
see if it's read-only or how it should

00:35:09.390 --> 00:35:12.270
be managed in terms of references.

00:35:13.520 --> 00:35:17.160
So a good example for
this would be Core Data.

00:35:17.300 --> 00:35:22.860
Core Data provides the NSManagedObject
to do persistent storage of objects.

00:35:22.950 --> 00:35:27.620
And here's the canonical way,
classical way of implementing

00:35:28.020 --> 00:35:29.740
a subclass of NSManagedObject.

00:35:29.790 --> 00:35:33.730
Let's say you have an entity
that defines a property called

00:35:33.730 --> 00:35:36.070
"name" that's string-valued.

00:35:36.210 --> 00:35:38.800
In this case,

00:35:39.100 --> 00:35:41.970
The generic way of getting
at your properties with core

00:35:41.970 --> 00:35:43.500
data is to use value for key.

00:35:43.850 --> 00:35:47.400
Value for key is an untyped
way to get at your data.

00:35:47.400 --> 00:35:48.760
You know it's an object.

00:35:49.000 --> 00:35:51.940
However, they encourage you to
write your own accessors,

00:35:52.060 --> 00:35:56.110
and typically you'll use the
Xcode assistant to generate

00:35:56.120 --> 00:35:57.210
code that looks like this.

00:35:57.480 --> 00:36:01.250
Another example of what I think
is pretty awful to have to

00:36:01.250 --> 00:36:03.560
contemplate boilerplate code.

00:36:03.750 --> 00:36:06.030
Especially if you want to add more
properties and you have to deal

00:36:06.030 --> 00:36:11.160
with merging the changes into a
source file you might already have.

00:36:11.320 --> 00:36:15.990
So wouldn't it be great if we
didn't have to do any of this?

00:36:16.370 --> 00:36:22.350
Well, in the version of Core Data that's
going to be shipping with Leopard GM,

00:36:22.370 --> 00:36:27.200
you will just be able to
define a dynamic property,

00:36:27.260 --> 00:36:29.480
and Core Data will write the rest.

00:36:35.580 --> 00:36:39.270
Turns out, with this implementation,
Core Data can actually provide

00:36:39.270 --> 00:36:42.640
you an accessor that runs at
least three times faster than that

00:36:42.640 --> 00:36:44.130
boilerplate code I showed you.

00:36:44.200 --> 00:36:46.530
The reason being,
Core Data can access all of its

00:36:46.530 --> 00:36:51.070
private implementation details to
give you the most optimized accessor.

00:36:51.120 --> 00:36:53.090
That's pretty cool.

00:36:54.650 --> 00:36:57.140
So how does this work?

00:36:57.200 --> 00:37:00.640
Well, it's built on a new feature,
a feature I invented

00:37:01.220 --> 00:37:03.510
for dynamic properties,
but it turns out it's

00:37:03.510 --> 00:37:04.940
a more general feature.

00:37:05.060 --> 00:37:09.260
It's similar in spirit to forwarding.

00:37:09.380 --> 00:37:14.330
What happens is the runtime system,
if it encounters a method, does a cache,

00:37:14.340 --> 00:37:16.100
has a cache miss,
and it tries to find the

00:37:16.100 --> 00:37:18.850
method in your class,
if it doesn't find it,

00:37:18.850 --> 00:37:23.670
it'll introspect on your class and
see if you implement this new method,

00:37:23.710 --> 00:37:25.230
resolve instance method.

00:37:25.350 --> 00:37:28.990
There's also a resolve class
method for class methods.

00:37:29.600 --> 00:37:33.310
It calls the method if it exists,
and if that method returns true,

00:37:33.400 --> 00:37:34.620
it's telling the runtime.

00:37:34.620 --> 00:37:36.670
It has, in fact,
added some kind of method

00:37:36.670 --> 00:37:43.050
implementation to the method list,
and that it should now try to find it.

00:37:43.260 --> 00:37:46.150
Now one of the interesting things
beyond properties you could use

00:37:46.150 --> 00:37:51.430
this for would be to lazily map in,
let's say,

00:37:51.430 --> 00:37:55.610
reflection to Python objects or
Ruby objects that you might be using

00:37:55.610 --> 00:37:58.140
in embedded scripting language.

00:37:58.190 --> 00:38:00.420
With this,
you don't have to eagerly reflect

00:38:00.430 --> 00:38:02.760
everything into Objective-C as methods.

00:38:02.760 --> 00:38:06.300
You can simply do it as they're used.

00:38:06.610 --> 00:38:09.360
There are a lot of other things that
Core Data is going to also be showing

00:38:09.360 --> 00:38:14.880
in their demo in terms of other kinds
of key value coding implementations

00:38:14.900 --> 00:38:16.130
that this can be used for.

00:38:16.190 --> 00:38:20.770
So lazy and dynamic,
that's pretty powerful.

00:38:23.530 --> 00:38:26.780
So again, to summarize,
properties are built on

00:38:26.850 --> 00:38:28.760
top of accessor methods.

00:38:28.760 --> 00:38:31.000
They provide really good
support for encapsulation.

00:38:31.000 --> 00:38:34.180
So if you decide to change how a
property is implemented down the road,

00:38:34.240 --> 00:38:36.400
you can, and clients are none the wiser.

00:38:36.400 --> 00:38:40.120
As a notational convenience,
you can override property methods.

00:38:40.120 --> 00:38:44.400
You could override an individual accessor
method if you like in a subclass.

00:38:44.400 --> 00:38:47.870
If you're thinking properties,
then you can use super.a as a

00:38:47.870 --> 00:38:51.400
notational way to get at the
superclass's implementation.

00:38:52.400 --> 00:38:56.140
You can also use the name of a
property unqualified in your methods,

00:38:56.140 --> 00:38:59.400
and that's just sugar for
calling the accessor method.

00:38:59.400 --> 00:39:04.400
You can also say self.a if
you like to be more explicit.

00:39:04.910 --> 00:39:09.530
Finally, we made a conscious choice to
implement chained or cascaded

00:39:09.530 --> 00:39:13.220
assignment with properties,
so that if you do this

00:39:13.320 --> 00:39:18.070
x.a equals x.b equals c,
the c is evaluated only once,

00:39:18.070 --> 00:39:20.780
and then it's more or
less parallel assignment.

00:39:20.800 --> 00:39:23.830
We've seen other
property implementations,

00:39:23.840 --> 00:39:27.900
for example,
ActionScript in another program,

00:39:28.050 --> 00:39:30.800
Flash I guess it is,
implements it in a different way.

00:39:30.800 --> 00:39:37.020
And it's very confusing to programmers
because the value would get changed and

00:39:37.020 --> 00:39:40.310
it wouldn't work the way you'd expect.

00:39:41.680 --> 00:39:44.130
So clients, well,
if you've been to any of

00:39:44.130 --> 00:39:46.790
the core animation talks,
you've seen properties.

00:39:46.790 --> 00:39:47.800
There they were.

00:39:47.840 --> 00:39:49.290
Stole my thunder.

00:39:49.450 --> 00:39:52.050
I was really excited to see that stuff.

00:39:52.140 --> 00:39:55.320
So I think the great thing you're
going to find about them is that

00:39:55.320 --> 00:39:57.130
you can go find the properties.

00:39:57.150 --> 00:39:59.690
You can go find what these classes do.

00:39:59.770 --> 00:40:02.160
You don't have to rely on
your documentation anymore.

00:40:02.160 --> 00:40:05.460
You can discover the stuff.

00:40:05.460 --> 00:40:10.270
That's, to me, pretty nice.

00:40:10.620 --> 00:40:12.160
ImageKit as well is using them.

00:40:12.160 --> 00:40:16.620
And we're promised that by Leopard GM,
Cocoa is going to be adopting

00:40:16.780 --> 00:40:19.150
properties very wholeheartedly.

00:40:19.180 --> 00:40:22.430
So go to the Core Data talk
later on today if you can,

00:40:22.550 --> 00:40:23.620
or the Garbage Collection talk.

00:40:23.620 --> 00:40:25.260
I think they're at the same time.

00:40:25.320 --> 00:40:27.960
And now I'd like to
hand off to Greg Parker,

00:40:28.060 --> 00:40:32.280
who's going to tell you about
64-bit Objective-C runtime.

00:40:37.600 --> 00:40:39.870
Thank you, Patrick.

00:40:39.910 --> 00:40:43.700
We have a new runtime in 64-bit.

00:40:43.710 --> 00:40:46.300
We have a few reasons for doing this.

00:40:47.040 --> 00:40:50.890
We want to provide with
a more extensible API.

00:40:50.890 --> 00:40:54.560
In particular, the existing runtime API.

00:40:54.630 --> 00:40:57.500
If any of you have gone and looked
at the Objective-C header files,

00:40:57.520 --> 00:40:58.920
there are structures.

00:40:58.950 --> 00:41:00.080
There's a class structure.

00:41:00.080 --> 00:41:01.900
There's a method structure.

00:41:01.930 --> 00:41:04.930
The structures we have are the
same structures that we have to

00:41:05.130 --> 00:41:08.960
use internally because people
go to see the IVAR structure,

00:41:09.000 --> 00:41:12.500
and they try and change the value,
or they go to the method structure and

00:41:12.510 --> 00:41:14.810
try and change the method implementation.

00:41:14.890 --> 00:41:16.150
We don't want that anymore.

00:41:16.230 --> 00:41:21.140
So 64-bit, we're providing you API to do
most of the things you're doing,

00:41:21.280 --> 00:41:24.120
most of the little tricks
and hacks you've been doing,

00:41:24.160 --> 00:41:27.760
without needing the structures,
which means we can change the structures.

00:41:28.090 --> 00:41:30.620
When we change the structures,
we can give you a few things.

00:41:30.730 --> 00:41:32.440
Better performance is a big one.

00:41:32.440 --> 00:41:34.520
We give you better memory performance.

00:41:34.540 --> 00:41:38.440
The class structure in particular
needs to be initialized to

00:41:38.440 --> 00:41:41.430
start up time for all classes,
whether you use them or not.

00:41:41.430 --> 00:41:43.100
This takes memory.

00:41:43.100 --> 00:41:44.220
This takes startup time.

00:41:46.170 --> 00:41:49.040
So, without a new class,
with a hidden class structure,

00:41:49.110 --> 00:41:52.670
we can give you lazy class setup,
better memory performance,

00:41:52.670 --> 00:41:56.450
better startup time,
which means TextEdit, for example,

00:41:56.530 --> 00:42:00.350
doesn't need to initialize
2,000 Cocoa classes that it

00:42:00.350 --> 00:42:02.300
doesn't use as startup time.

00:42:02.510 --> 00:42:05.050
Another better performance
we're going to give you:

00:42:05.200 --> 00:42:07.560
better dispatch, object-C message send.

00:42:07.560 --> 00:42:09.300
We can do it better.

00:42:09.300 --> 00:42:11.390
You'll like it.

00:42:11.400 --> 00:42:14.730
Finally, in 64-bit,
we can give you even more new

00:42:14.730 --> 00:42:18.400
features that would have broken
the 64-bit compatibility.

00:42:18.400 --> 00:42:22.400
In 32-bit,
we give you the API for the functions,

00:42:22.400 --> 00:42:25.280
but we still have to provide
object-C class because all the

00:42:25.280 --> 00:42:27.260
existing programs still call it.

00:42:27.440 --> 00:42:30.100
64-bit, we can take it away,
which means we can give

00:42:30.170 --> 00:42:32.560
you some neat features,
and we're going to talk

00:42:32.560 --> 00:42:33.880
about them in a minute.

00:42:34.640 --> 00:42:39.660
So, the new API, new functions in the
Objective-C runtime header files.

00:42:39.680 --> 00:42:41.290
Most of you will never care.

00:42:41.320 --> 00:42:44.060
Cocoa is a great
object-oriented framework.

00:42:44.180 --> 00:42:46.550
For those of you who do care,
you're writing a language bridge,

00:42:46.570 --> 00:42:52.720
you're doing some weird little hacks,
you're calling class poseAs, for example.

00:42:52.720 --> 00:42:54.980
We have a new API for you.

00:42:55.870 --> 00:42:58.040
Functional replacements for structs.

00:42:58.070 --> 00:43:01.020
This is for obc class, obc, ivr,
all the structures.

00:43:01.350 --> 00:43:04.570
We have covers that do most of the
work of accessing the structures and

00:43:04.570 --> 00:43:09.030
changing the structures where reasonable.

00:43:09.380 --> 00:43:12.320
Easier introspection of classes,
protocols,

00:43:12.320 --> 00:43:16.910
in addition to properties that we've
shown you today and some other things.

00:43:17.080 --> 00:43:18.630
We'll give you functional APIs.

00:43:18.700 --> 00:43:21.150
You won't have to go groveling
through the header structures anymore

00:43:21.310 --> 00:43:24.580
to look at what an IVAR list looks
like or what a method list looks

00:43:24.580 --> 00:43:27.240
like because we keep changing it,
that sort of thing.

00:43:27.380 --> 00:43:29.730
Finally, simpler class construction.

00:43:29.830 --> 00:43:34.380
For the very few of you who are offering
new classes dynamically at runtime,

00:43:34.670 --> 00:43:36.910
it is a very difficult thing to do today.

00:43:37.120 --> 00:43:40.470
You have to allocate the structure,
initialize the structure exactly

00:43:40.470 --> 00:43:41.830
the way the runtime wants.

00:43:41.990 --> 00:43:47.240
If you put a null pointer or the runtime
wanted a pointer to a null pointer,

00:43:47.240 --> 00:43:48.720
it just crashes.

00:43:48.780 --> 00:43:49.460
We don't like that.

00:43:49.460 --> 00:43:51.750
We're giving you a better
class construction API.

00:43:51.990 --> 00:43:55.160
Again, functional,
no structures involved.

00:43:56.590 --> 00:44:00.130
So these new functions are
available now on your Leopard

00:44:00.130 --> 00:44:03.410
Seed in 32-bit and 64-bit.

00:44:03.750 --> 00:44:07.640
Again, all the 32-bit old API is
still there in 32-bit.

00:44:07.710 --> 00:44:10.350
All the class structures,
a couple functions we've taken away.

00:44:11.030 --> 00:44:17.100
64-bit,
the structures are currently still there,

00:44:17.330 --> 00:44:18.170
but not for long.

00:44:18.180 --> 00:44:18.820
You'll see in a minute.

00:44:18.840 --> 00:44:23.660
There's documentation on the WDC website
talking about these new functions,

00:44:23.660 --> 00:44:25.420
describing what they do.

00:44:25.440 --> 00:44:28.560
So see that for more details.

00:44:29.300 --> 00:44:31.340
Here's a quick example of a couple.

00:44:31.550 --> 00:44:32.640
Again, see the documentation.

00:44:32.640 --> 00:44:34.690
There are a few dozen like this.

00:44:34.740 --> 00:44:36.960
The first one, class gets superclass.

00:44:36.980 --> 00:44:40.380
This is a basic cover replacing
the object-C class structure,

00:44:40.390 --> 00:44:42.160
which had a superclass field in it.

00:44:42.210 --> 00:44:43.100
Call the function instead.

00:44:43.100 --> 00:44:43.960
You'll be happier.

00:44:43.980 --> 00:44:45.900
We'll be happier, too.

00:44:46.430 --> 00:44:48.620
Here's a quick example of a couple.

00:44:48.620 --> 00:44:49.690
Again, see the documentation.

00:44:49.740 --> 00:44:51.800
There are a few dozen like this.

00:44:51.800 --> 00:44:54.060
The first one, class gets superclass.

00:44:54.060 --> 00:44:57.480
This is a basic cover replacing
the object-C class structure,

00:44:57.480 --> 00:44:59.260
which had a superclass field in it.

00:45:00.130 --> 00:45:03.220
So instead, we have this function,
which will allocate an array for you,

00:45:03.230 --> 00:45:04.720
give you the count.

00:45:04.720 --> 00:45:08.330
The IVARs are now, of course,
opaque pointers that you have

00:45:08.410 --> 00:45:10.760
functional access to as well.

00:45:10.810 --> 00:45:14.940
Finally, cost-get-property,
copy-property list.

00:45:15.380 --> 00:45:17.120
Of course,
looking at the new properties we've just

00:45:17.190 --> 00:45:21.500
given you and the introspection of the
features that Patrick was talking about.

00:45:22.470 --> 00:45:25.420
Here's a brief example of
the class construction API.

00:45:25.580 --> 00:45:30.780
obc allocate class pair will allocate
a class and its metaclass for you.

00:45:30.950 --> 00:45:34.620
Again, you don't have to know what
the class structure looks like.

00:45:34.820 --> 00:45:37.410
Once you have that result,
you call a few functions like class

00:45:37.420 --> 00:45:40.050
add Ivar to add an Ivar to the class.

00:45:40.060 --> 00:45:43.580
There's also class add method function,
add methods as a class,

00:45:43.580 --> 00:45:45.180
similar things like that.

00:45:45.190 --> 00:45:48.340
When you're done constructing the class,
you call register class pair.

00:45:48.340 --> 00:45:51.820
It tells the runtime, first of all,
you're done building it.

00:45:51.950 --> 00:45:53.820
Second of all,
it should now be ready for use.

00:45:53.820 --> 00:45:57.180
Objects can now be
allocated of that class.

00:45:57.180 --> 00:45:59.950
Much simpler than it was before.

00:45:59.950 --> 00:46:03.290
We can take down the old sample code
that Arriba needed to copy and paste

00:46:03.290 --> 00:46:05.100
in order to get it to work before.

00:46:06.520 --> 00:46:09.240
Second of all,
it should now be ready for use.

00:46:09.240 --> 00:46:13.040
Objects can now be
allocated of that class.

00:46:13.040 --> 00:46:14.800
Much simpler than it was before.

00:46:14.900 --> 00:46:17.740
We can take down the old sample code
that Airbay needed to copy and paste

00:46:17.740 --> 00:46:18.010
in order to get it to work before.

00:46:18.470 --> 00:46:23.480
So all the existing class structures,
obc class, obc method, the method list,

00:46:23.480 --> 00:46:26.440
the symbol table that
nobody's ever heard of,

00:46:26.470 --> 00:46:28.570
these are all deprecated.

00:46:29.080 --> 00:46:30.530
Selectors.

00:46:30.630 --> 00:46:33.150
Cell currently is a car star.

00:46:33.150 --> 00:46:37.250
It happens to be a unique car star,
but it's just a car star.

00:46:37.520 --> 00:46:41.490
So a lot of people will cast it to a car
star in order to do things like print

00:46:41.520 --> 00:46:43.570
it or stir comp or things like that.

00:46:43.640 --> 00:46:48.640
In the future, it will not necessarily
be a car star at runtime.

00:46:48.640 --> 00:46:50.470
So don't cast your cells to car star.

00:46:50.790 --> 00:46:54.130
Instead, call the cell getName function,
which returns a perfectly

00:46:54.130 --> 00:46:55.640
good car star already.

00:46:55.720 --> 00:46:59.010
And that will remain,
that will continue to work when

00:46:59.010 --> 00:47:01.270
cells are not car stars anymore.

00:47:01.720 --> 00:47:06.520
Here's a big one for
you hackers out there:

00:47:06.630 --> 00:47:10.680
Pose as Class is now deprecated.

00:47:11.250 --> 00:47:14.530
So there are complicated
reasons for this.

00:47:14.690 --> 00:47:21.150
POSAS class is primarily poorly defined,
unsupportable, unthreadsave, et cetera,

00:47:21.160 --> 00:47:22.390
ad infinitum.

00:47:22.550 --> 00:47:26.390
We are giving you functions in the new
functional API that will do most of the

00:47:26.500 --> 00:47:28.840
things you used to do with PoseAs class.

00:47:28.950 --> 00:47:32.440
If you want to replace a method that's
still called the old implementation,

00:47:32.440 --> 00:47:34.650
you can still do that.

00:47:34.920 --> 00:47:37.660
You want to add a method to a class,
you can use a category instead

00:47:37.660 --> 00:47:38.980
of a posing class to do that.

00:47:39.040 --> 00:47:41.880
So most of the functionality
is still there,

00:47:41.880 --> 00:47:44.910
you just can't do class pose as itself.

00:47:45.130 --> 00:47:47.960
You want to add a method to a class,
you can use a category instead

00:47:47.960 --> 00:47:49.340
of a posing class to do that.

00:47:49.340 --> 00:47:52.180
So most of the functionality
is still there,

00:47:52.180 --> 00:47:55.220
you just can't do class pose as itself.

00:47:59.070 --> 00:48:01.860
You want to add a method to a class,
you can use a category instead

00:48:01.860 --> 00:48:03.240
of a posing class to do that.

00:48:03.240 --> 00:48:06.070
So most of the functionality
is still there,

00:48:06.180 --> 00:48:08.590
you just can't do class pose as itself.

00:48:08.790 --> 00:48:11.020
and your leopard seed,
they are not deleted.

00:48:11.060 --> 00:48:11.700
They're still there.

00:48:11.700 --> 00:48:13.980
They still work.

00:48:13.980 --> 00:48:15.790
If you want to get the
deprecation warnings,

00:48:15.800 --> 00:48:19.360
you need to set your deployment
target on the command line or in

00:48:19.360 --> 00:48:25.610
Xcode or wherever else to 10.5,
and then you'll get standard

00:48:25.610 --> 00:48:29.940
compiler deprecation warnings
for all the functions,

00:48:29.940 --> 00:48:29.940
all the structures, maybe even at-defs.

00:48:31.260 --> 00:48:33.540
So, why are we taking away API?

00:48:33.790 --> 00:48:35.120
So we can give you new ABI.

00:48:35.310 --> 00:48:36.750
Why are we giving you new ABI?

00:48:36.830 --> 00:48:39.080
So we can give you new features.

00:48:39.100 --> 00:48:40.920
New ABI is not available yet.

00:48:40.960 --> 00:48:46.490
The current ABI is still the
32-bit one in the 64-bit world.

00:48:47.100 --> 00:48:50.500
In Leopard GM,
we will have the new ABI in place.

00:48:50.570 --> 00:48:54.180
The features we will give you at
Leopard GM with this new ABI include

00:48:54.610 --> 00:48:58.840
non-fragile instance variables,
zero-cost exceptions,

00:48:58.990 --> 00:49:01.440
and faster messaging dispatch.

00:49:01.440 --> 00:49:03.570
So, let's look at those.

00:49:03.890 --> 00:49:07.300
In Leopard GM,
we will have the new ABI in place.

00:49:07.300 --> 00:49:11.270
The features we will give you at
Leopard GM with this new ABI include

00:49:11.380 --> 00:49:15.120
non-fragile instance variables,
zero-cost exceptions,

00:49:15.120 --> 00:49:15.120
and faster messaging dispatch.

00:49:15.120 --> 00:49:15.120
So, let's look at those.

00:49:15.570 --> 00:49:18.340
It's got two IVARs in it,
plus NSObjects IVAR,

00:49:18.340 --> 00:49:20.140
title and a content view.

00:49:20.140 --> 00:49:23.320
On the right,
we have a subclass of NSWindow,

00:49:23.320 --> 00:49:26.310
your subclass of NSWindow, my window.

00:49:26.510 --> 00:49:28.400
So you're riding a pet
store or something,

00:49:28.400 --> 00:49:31.200
I guess, because you have a kitten's
array and a puppy's array,

00:49:31.220 --> 00:49:33.050
which are I-bars.

00:49:33.580 --> 00:49:35.590
So here's the problem.

00:49:35.800 --> 00:49:39.090
Leopard ships,
and they've added a new IVAR to NSWindow.

00:49:39.270 --> 00:49:40.460
Call it Toolbar.

00:49:40.540 --> 00:49:44.250
You want a standard toolbar
API or something like that.

00:49:44.400 --> 00:49:46.580
So here's the problem.

00:49:46.580 --> 00:49:50.010
Leopard ships,
and they've added a new IVAR to NSWindow.

00:49:50.020 --> 00:49:51.310
Call it Toolbar.

00:49:51.320 --> 00:49:55.060
You want a standard toolbar
API or something like that.

00:49:56.940 --> 00:49:59.440
So we don't like this.

00:49:59.470 --> 00:50:02.550
So today, AppKit,
the rest of the Cocoa stack,

00:50:02.640 --> 00:50:07.290
any time they create a class,
they may not add IVARs later like this,

00:50:07.290 --> 00:50:10.440
because any of your
subclasses don't work anymore.

00:50:10.640 --> 00:50:12.440
This is fragile instance variables.

00:50:12.450 --> 00:50:16.320
In C++, it's commonly called
fragile base class problem.

00:50:16.340 --> 00:50:20.640
C++ has it with IVARs and with methods,
which makes it even worse.

00:50:20.700 --> 00:50:23.030
We at least have methods that work.

00:50:23.470 --> 00:50:30.110
So we're going to fix this in 64-bit,
non-fragile instance variables.

00:50:30.380 --> 00:50:35.700
How this works is the runtime is
going to compute the offset at

00:50:35.780 --> 00:50:40.580
runtime based on the size of the
superclass it sees at runtime.

00:50:40.660 --> 00:50:44.510
So your generated code is no longer
having-- let's go back here--

00:50:44.570 --> 00:50:49.540
when we look at the kittens array,
it's no longer a fixed offset, 12, or 24,

00:50:49.540 --> 00:50:51.020
because it's 64-bit.

00:50:51.050 --> 00:50:53.860
Instead,
that 12 will be looked up at runtime.

00:50:53.890 --> 00:50:58.270
And the Objective-C runtime is free to
change it if it sees that NSWindow is in

00:50:58.270 --> 00:51:00.820
fact bigger than it was when you compile.

00:51:02.190 --> 00:51:03.500
So what does this mean?

00:51:03.520 --> 00:51:06.610
It means that AppKit, Cocoa,
everybody else can add instance

00:51:06.610 --> 00:51:09.780
variables without breaking your code,
without requiring you

00:51:09.780 --> 00:51:11.310
to recompile your code.

00:51:11.510 --> 00:51:13.280
You can reorder the instance variables.

00:51:13.480 --> 00:51:16.640
You know, the offset is just a different
offset inside the class.

00:51:16.750 --> 00:51:19.230
Deleting private IVRs also works.

00:51:19.450 --> 00:51:22.570
You still can't delete a public
IVR because that's public API,

00:51:22.570 --> 00:51:23.700
really, once it ships.

00:51:23.830 --> 00:51:25.860
So, yeah, don't use public IVRs.

00:51:26.000 --> 00:51:27.850
Private IVRs, you can delete them.

00:51:28.090 --> 00:51:31.100
You don't have to worry about
the gap that is now in your class

00:51:31.100 --> 00:51:35.200
that previously you'd have to fill
with some sort of placeholder.

00:51:35.380 --> 00:51:37.140
The performance cost is rather small.

00:51:37.240 --> 00:51:39.930
It just needs to read an extra
offset from a global variable

00:51:39.930 --> 00:51:42.460
telling it where the IVAR now lives.

00:51:43.120 --> 00:51:47.000
So this is the reason
why @def doesn't work.

00:51:47.000 --> 00:51:51.150
Because when you call @def,
it creates a compile-time structure

00:51:51.160 --> 00:51:53.960
that tries to look like the class
as well as its superclasses.

00:51:54.000 --> 00:51:56.510
Of course,
the superclass now may look different,

00:51:56.510 --> 00:51:58.970
which means the @def
structure will be out of date.

00:51:58.990 --> 00:52:02.000
It just doesn't work anymore,
so we're taking it away.

00:52:02.000 --> 00:52:04.560
Hopefully none of you care.

00:52:04.800 --> 00:52:11.030
Finally, offset of an IVAR and size of
a class also no longer make

00:52:11.030 --> 00:52:16.520
any sense because these are no
longer compile time constants.

00:52:16.520 --> 00:52:21.140
You can use the runtime's functional
API to get the offset of an IVAR.

00:52:21.140 --> 00:52:23.210
There's a class IVAR offset.

00:52:23.220 --> 00:52:25.500
There's a class get instance size.

00:52:25.500 --> 00:52:29.040
You want to know the
size of a class object.

00:52:29.040 --> 00:52:32.700
So you can use those instead
of offset of and size of.

00:52:32.710 --> 00:52:36.380
So again, this is 64-bit Leopard GM only.

00:52:36.380 --> 00:52:39.700
The Leopard seed you have now is still
using fragile instance variables,

00:52:39.710 --> 00:52:44.760
but they probably won't change
apt-get between the seed and GM,

00:52:44.760 --> 00:52:46.250
at least not without you recompiling.

00:52:46.280 --> 00:52:48.090
So it'll be fine.

00:52:49.160 --> 00:52:52.000
Next feature, zero-cost exceptions.

00:52:52.170 --> 00:52:55.170
This is primarily for
those of you Objective-C++

00:52:55.270 --> 00:52:57.350
programmers in the audience.

00:52:57.940 --> 00:52:59.240
So observation.

00:52:59.360 --> 00:53:01.440
Cocoa rarely throws exceptions.

00:53:01.600 --> 00:53:04.850
Most Cocoa exceptions
are programmer error,

00:53:04.860 --> 00:53:08.840
out-of-array index access,
things like that.

00:53:08.850 --> 00:53:11.860
Or method not found is another example.

00:53:11.910 --> 00:53:15.800
Currently,
the implementation of exceptions in

00:53:15.830 --> 00:53:20.130
Cocoa is using set jump and long jump,
which are slow when

00:53:20.130 --> 00:53:21.410
you enter a try block.

00:53:21.550 --> 00:53:23.860
You need to do some work
when you start the try block,

00:53:23.910 --> 00:53:26.690
whether or not you end
up throwing anything.

00:53:26.920 --> 00:53:31.030
So instead, for the 64-bit API,
we're going to reuse the

00:53:31.060 --> 00:53:35.560
C++ infrastructure and their
online info for exceptions.

00:53:35.700 --> 00:53:40.390
What this means is a try block costs you
nothing at runtime when you enter it.

00:53:40.480 --> 00:53:41.140
There's no set jump.

00:53:41.140 --> 00:53:43.560
There's no other data setup.

00:53:43.890 --> 00:53:47.280
Throwing is a little bit more
expensive because you need to do all

00:53:47.280 --> 00:53:50.500
the work that you would have done at
the try block in order to find out

00:53:50.500 --> 00:53:54.080
where your data went when unwinding.

00:53:54.270 --> 00:53:56.520
But we just noted that
Cocoa doesn't throw very much,

00:53:56.520 --> 00:53:57.240
so that's OK.

00:53:57.240 --> 00:53:58.710
Nobody minds.

00:53:58.940 --> 00:54:03.260
The big benefit for this-- again,
Objective-C++ programmers out there--

00:54:03.270 --> 00:54:07.650
your C++ exception handling and your
Cocoa exception handling are now unified.

00:54:07.960 --> 00:54:11.440
You can throw-- Thank you.

00:54:14.200 --> 00:54:18.490
You can throw a Cocoa exception
and catch it in a catch-ID block

00:54:18.600 --> 00:54:21.200
or catch-dot-dot-dot block in C++.

00:54:21.500 --> 00:54:25.830
Conversely,
you can throw a C++ exception and catch

00:54:25.830 --> 00:54:31.200
it in an Objective-C catch-dot-dot-dot
equivalent block,

00:54:31.200 --> 00:54:34.190
or an Objective-C finally
block if you have those.

00:54:34.220 --> 00:54:36.690
The finally block will be invoked
instead of being just skipped

00:54:36.730 --> 00:54:39.200
completely like it is today.

00:54:39.530 --> 00:54:43.190
Which is sometimes wrong.

00:54:44.550 --> 00:54:46.860
Finally, Faster Dispatch.

00:54:46.880 --> 00:54:50.770
You're going to like this.

00:54:51.330 --> 00:54:57.080
This is a sharp sample of Keynote showing
the Objective-C message send overhead

00:54:57.330 --> 00:54:59.400
for the dynamic message dispatch.

00:54:59.640 --> 00:55:01.420
Dynamic message dispatch is great.

00:55:01.700 --> 00:55:02.480
It's powerful.

00:55:02.790 --> 00:55:04.080
You get key-value coding.

00:55:04.100 --> 00:55:04.960
You get forwarding.

00:55:04.960 --> 00:55:07.000
You get all this neat
stuff that Cocoa uses.

00:55:07.020 --> 00:55:10.440
On the other hand,
it does cost a bit of runtime.

00:55:10.580 --> 00:55:16.370
In this Keynote example,
15.2% of the CPU time is in message send,

00:55:16.410 --> 00:55:18.200
messaging lookup.

00:55:18.330 --> 00:55:20.130
It's not bad, but it's not great.

00:55:20.150 --> 00:55:21.010
We can do better than this.

00:55:23.040 --> 00:55:29.700
Here's another example that we'll use
for taking advantage when we optimize it.

00:55:29.850 --> 00:55:32.800
This is looking at the polymorphic
messages that mail sends,

00:55:32.880 --> 00:55:36.400
the messages that have more than
one implementation somewhere.

00:55:36.520 --> 00:55:42.040
If we look at the list, the top methods,
there are about 10 of them,

00:55:42.040 --> 00:55:43.800
are taking 72% of the dispatch time.

00:55:43.940 --> 00:55:47.790
So three-quarters of the time
in OBSI message send is sent

00:55:47.790 --> 00:55:50.690
doing only a dozen methods or so.

00:55:50.830 --> 00:55:54.610
Looking back at the "for each" example,
you'll note object index is the top

00:55:54.830 --> 00:55:58.000
consumer in mail messaging time.

00:55:58.150 --> 00:56:01.180
Looking at garbage collection,
you'll also see retain and

00:56:01.420 --> 00:56:03.080
release are also top clients.

00:56:03.300 --> 00:56:06.200
So use that "for each" statement,
the "for in" statement,

00:56:06.200 --> 00:56:08.700
use garbage collection,
you can take away that overhead.

00:56:08.850 --> 00:56:13.260
But for the rest of the overhead,
we want to be able to optimize this time.

00:56:14.020 --> 00:56:18.750
So what we are adding is a
hybrid virtual table dispatch.

00:56:18.840 --> 00:56:20.860
If any of you are familiar
with C++ internals,

00:56:20.890 --> 00:56:23.750
you'll know what a virtual
table is for doing dispatch.

00:56:23.820 --> 00:56:26.620
Objective-C message
send uses a hash table.

00:56:26.670 --> 00:56:31.570
Looks up your selector using a
hash function in the method table.

00:56:31.630 --> 00:56:34.780
A virtual table is basically
an array of function pointers

00:56:34.780 --> 00:56:37.200
that you look up by index.

00:56:37.280 --> 00:56:39.670
So array access, hash table access.

00:56:39.780 --> 00:56:42.180
The array is a little bit faster.

00:56:42.660 --> 00:56:46.330
In C++,
this is a problem because they have

00:56:46.330 --> 00:56:47.440
the fragile base class problem.

00:56:47.440 --> 00:56:49.080
You can't change the Vtable.

00:56:49.220 --> 00:56:51.540
In Objective-C,
we have a dynamic runtime.

00:56:51.540 --> 00:56:55.240
The dynamic runtime will generate
the Vtable for you and will change

00:56:55.240 --> 00:56:57.510
the Vtable if the classes change.

00:56:57.870 --> 00:57:01.720
The other problem that C++ has
is they use the virtual table

00:57:01.720 --> 00:57:03.980
for all methods in all classes.

00:57:03.980 --> 00:57:06.020
This turns out to be a lot of memory.

00:57:06.040 --> 00:57:09.570
You have an array of function
pointers for every class that covers

00:57:09.630 --> 00:57:13.590
all the methods that class has,
all the methods that superclasses have.

00:57:13.760 --> 00:57:16.660
This is a lot more memory
than the Objective-C system,

00:57:16.660 --> 00:57:20.450
which is only caching a few methods
that you've actually called.

00:57:21.160 --> 00:57:25.700
So we noted with the mail example that
there were only a few methods that

00:57:25.740 --> 00:57:27.790
were actually the really hot ones,
the ones that are called a lot,

00:57:27.800 --> 00:57:29.930
the ones we want to optimize.

00:57:30.070 --> 00:57:34.070
So what we will do with the
hybrid virtual tables is we will

00:57:34.070 --> 00:57:38.790
only use the V table for the
very frequently called methods.

00:57:39.650 --> 00:57:41.710
These methods are,
they're very frequently called,

00:57:41.710 --> 00:57:43.580
and they tend not to be very polymorphic.

00:57:43.750 --> 00:57:47.230
There aren't that many implementations
of object-at-index out there.

00:57:47.340 --> 00:57:49.890
So what this means is the
virtual tables are small.

00:57:49.960 --> 00:57:51.910
There's only maybe a
dozen methods in them,

00:57:51.940 --> 00:57:52.540
usually.

00:57:52.570 --> 00:57:57.180
And the virtual table is generally
the same for different classes,

00:57:57.180 --> 00:58:00.060
because your class
didn't override release.

00:58:00.060 --> 00:58:02.990
It didn't override object-at-index,
which means you can use

00:58:02.990 --> 00:58:04.500
your superclass's Vtable.

00:58:04.540 --> 00:58:06.900
So the Vtables get reused
across many classes,

00:58:06.900 --> 00:58:09.990
which means that the memory
cost is still very low.

00:58:10.390 --> 00:58:15.200
For all the rest of your methods,
the methods that aren't called as often,

00:58:15.200 --> 00:58:17.570
we still use the normal
hash table lookup.

00:58:17.610 --> 00:58:20.380
So we don't get the speed gain,
but those methods aren't called as often,

00:58:20.380 --> 00:58:22.840
so the speed gain is just not there.

00:58:23.900 --> 00:58:30.120
So the Vtable dispatch is at least 50%
faster than the object-C message sent.

00:58:31.510 --> 00:58:35.060
for those functions that
you're actually calling.

00:58:35.060 --> 00:58:38.480
It is not quite as fast as C++
virtual tables because we want to

00:58:38.480 --> 00:58:40.340
avoid the fragile base class problem.

00:58:40.370 --> 00:58:42.330
So ours is a bit more dynamic.

00:58:42.650 --> 00:58:46.760
The virtual table size and
contents are adjustable per app.

00:58:46.790 --> 00:58:50.130
So if your application has
particular methods that it is calling

00:58:50.130 --> 00:58:53.290
frequently that you want to optimize,
you stick those in a

00:58:53.290 --> 00:58:56.520
list in an Xcode window,
and the virtual table will be

00:58:56.520 --> 00:59:00.710
constructed at runtime using
your methods that you call.

00:59:00.940 --> 00:59:03.460
which means that you get the performance
gain for the methods you write instead

00:59:03.460 --> 00:59:08.130
of just the standard foundation
object and index and similar methods.

00:59:08.810 --> 00:59:13.200
So that is it for what we're going
to say about the Objective-C runtime.

00:59:13.200 --> 00:59:16.690
And now back to Blaine
Garst for some final words.

00:59:21.800 --> 00:59:31.500
[Transcript missing]

00:59:33.480 --> 00:59:37.590
All the features we talked about
require changes to the runtime.

00:59:37.600 --> 00:59:40.640
And so, unfortunately,
you're not going to be able to

00:59:40.640 --> 00:59:44.980
use these constructs if you're
going to try to ship back on Tiger.

00:59:45.000 --> 00:59:49.070
There's just no way we could
figure out how to make that happen.

00:59:49.100 --> 00:59:52.100
So,
this is a Leopard-only set of features.

00:59:52.100 --> 00:59:58.900
And the only consolation prize here,
though, is that the headers that you use,

00:59:58.900 --> 01:00:03.490
even as we adopt these
optional methods and protocols,

01:00:03.490 --> 01:00:06.000
as we put properties and stuff
into the header files and stuff,

01:00:06.100 --> 01:00:12.280
you can still compile against 10.5
and ship against 10.4 or 10.3.

01:00:12.300 --> 01:00:16.550
So, you can look at them,
but you can't use them until you

01:00:16.640 --> 01:00:20.150
compile and build for Leopard-only.

01:00:20.200 --> 01:00:25.300
And so, with that, we have, again,
a session on garbage collection.

01:00:25.300 --> 01:00:27.590
Stay in your seats if you
want to hear more about that.

01:00:27.600 --> 01:00:28.800
We have a language lesson.

01:00:28.800 --> 01:00:32.800
We have a language lab tomorrow night.

01:00:32.800 --> 01:00:36.800
I will be -- there will be members
of the team in the language lab

01:00:36.800 --> 01:00:39.100
probably most of the day tomorrow,
in fact.

01:00:39.100 --> 01:00:41.410
So,
come on down if you want to hear about

01:00:41.410 --> 01:00:43.500
what's going on and check it out.

01:00:43.500 --> 01:00:46.700
And, of course,
documentation is still very useful.

01:00:46.700 --> 01:00:51.100
And we've got some great
documentation on all of this stuff.

01:00:51.100 --> 01:00:54.190
Some of it may only be
downloadable right now.

01:00:54.200 --> 01:00:58.000
And there are still some
things yet to be documented.
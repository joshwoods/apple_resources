WEBVTT

00:00:11.190 --> 00:00:14.900
We're the group that does
keychain and cryptography

00:00:14.900 --> 00:00:18.800
and PKI and things like that,
and also smart cards.

00:00:21.450 --> 00:00:25.820
So in this session,
we're going to go over how we use smart

00:00:25.950 --> 00:00:29.610
cards and other tokens in Mac OS X.

00:00:30.120 --> 00:00:34.940
It's particularly about
actually the last bullet point,

00:00:35.030 --> 00:00:37.440
which is how to add support
for new types of tokens.

00:00:37.440 --> 00:00:41.980
So we'll be just going over very,
very quickly how to configure a

00:00:41.980 --> 00:00:46.630
system for token-based authentication,
how to write applications

00:00:46.630 --> 00:00:50.130
that support tokens,
and then we'll spend most of

00:00:50.130 --> 00:00:51.380
the time on how to add support
for new types of tokens.

00:00:51.400 --> 00:00:54.350
support for new types of tokens.

00:00:58.360 --> 00:01:01.640
Okay,
so quickly going over configuration.

00:01:01.640 --> 00:01:07.600
We have had built-in support for
smart cards for several releases now.

00:01:07.600 --> 00:01:11.540
We've been adding more
capabilities as time goes on.

00:01:11.560 --> 00:01:15.810
One of the things that we
added for Tiger was support for

00:01:15.950 --> 00:01:20.660
something we called a TokenD,
which gives us the ability

00:01:20.660 --> 00:01:25.430
to support additional types
of smart cards and tokens.

00:01:26.940 --> 00:01:32.150
So we've had support for
PCSC Drivers and PCSC Lite,

00:01:32.590 --> 00:01:37.330
actually I think since release 10.2.

00:01:37.340 --> 00:01:40.670
But with TokenDs,
we get the ability to support

00:01:41.210 --> 00:01:42.870
different types of cards.

00:01:42.920 --> 00:01:46.990
If you look inside
System Library Security TokenD,

00:01:47.030 --> 00:01:52.480
you'll see the few different ones
that we ship built in with Tiger and,

00:01:52.480 --> 00:01:55.200
of course, with Leopard 2.

00:01:55.860 --> 00:02:00.790
And if you look in User LibExec
Smart Card Services Drivers,

00:02:00.810 --> 00:02:05.970
you'll see some of the different
PCSC drivers for the different devices.

00:02:06.020 --> 00:02:11.060
The different types of TokenDs
that we support so far on Tiger are

00:02:11.150 --> 00:02:15.140
for the Common Access Card,
which is the U.S.

00:02:15.140 --> 00:02:20.150
Department of Defense-issued
smart card for identification.

00:02:20.220 --> 00:02:24.940
The Belgian Identity Card,
which is issued to every Belgian citizen.

00:02:24.940 --> 00:02:30.520
They'll have completed
their rollout by 2008.

00:02:30.750 --> 00:02:33.190
And also the Japanese PKI card.

00:02:33.360 --> 00:02:36.680
So those are the token
deeds that are built in now,

00:02:36.680 --> 00:02:39.720
but you'll learn through this
session how if you have a token,

00:02:39.780 --> 00:02:41.310
you can add support for it as well.

00:02:44.060 --> 00:02:49.540
Now, this slide is kind of surprising
and I think very important.

00:02:49.540 --> 00:02:55.160
But with Leopard,
you do not have to do any

00:02:55.160 --> 00:02:59.760
client-side modification at all to
enable token-based authentication.

00:02:59.760 --> 00:03:03.840
And if you've ever tried to do this,
this is actually, as I say,

00:03:03.840 --> 00:03:05.230
it's surprising.

00:03:06.950 --> 00:03:13.870
Currently on Tiger,
you do have to change something on the

00:03:13.940 --> 00:03:16.300
system to enable the smart card sniffer.

00:03:16.300 --> 00:03:18.930
But still, actually,
there's no client-side

00:03:18.930 --> 00:03:20.420
modification needed.

00:03:23.350 --> 00:03:31.720
So part of the authentication process,
if you went to the session yesterday

00:03:31.790 --> 00:03:35.500
about login and authorization,
you learned how this worked in detail.

00:03:35.500 --> 00:03:42.430
But part of it is,
as a user starts to log in to the system

00:03:42.460 --> 00:03:50.490
or starts to authenticate to the system,
they make a claim about who they are.

00:03:50.490 --> 00:03:50.490
And

00:03:50.620 --> 00:03:53.040
As part of this process,
you want to validate whether

00:03:53.220 --> 00:03:54.580
that claim is true or not.

00:03:54.730 --> 00:04:00.640
So if you're looking at smart card login,

00:04:01.630 --> 00:04:07.950
The authorization plug-in will actually
make calls off to directory services

00:04:08.240 --> 00:04:14.160
to look up the user in the directory
services or in the back-end directory.

00:04:14.160 --> 00:04:17.650
So you can see all the directories
shown in purple down below.

00:04:17.650 --> 00:04:22.940
Those are all the different kinds
of directories that we support.

00:04:22.940 --> 00:04:26.230
And you'll be going through
the different layers,

00:04:26.230 --> 00:04:29.100
the authentication API or
security framework.

00:04:29.110 --> 00:04:31.480
We'll be looking up and doing
all the different things.

00:04:31.500 --> 00:04:39.940
We'll be looking at the standard
directory services to find that user.

00:04:43.060 --> 00:04:46.280
So again,
I want to emphasize that for the really,

00:04:46.280 --> 00:04:50.700
really gory details about how to do this,
there's a session on Friday morning.

00:04:50.700 --> 00:04:53.790
The number will be shown at the end here.

00:04:53.800 --> 00:04:58.460
So if you're in IT,
then that will be the session

00:04:58.460 --> 00:05:01.360
you'll really want to see.

00:05:01.360 --> 00:05:07.300
But for the recommended way of
setting up token-based authentication,

00:05:07.460 --> 00:05:12.700
what we recommend is storing the
public key hash associated with

00:05:12.700 --> 00:05:17.140
the key that you want to use
to log in or authenticate with,

00:05:17.230 --> 00:05:19.120
storing that in the directory.

00:05:19.120 --> 00:05:24.750
So you can figure out what the
different public key hashes

00:05:24.750 --> 00:05:27.960
are by typing in scauth hash.

00:05:27.960 --> 00:05:33.150
And if you have a smart card or token,
one that's supported,

00:05:33.400 --> 00:05:36.950
it will list all the
different public key hashes.

00:05:39.050 --> 00:05:43.440
Okay, you can then add this to
the authentication authority

00:05:43.440 --> 00:05:45.120
attribute for the user.

00:05:45.360 --> 00:05:50.190
And again, using the SCAuth script.

00:05:50.570 --> 00:05:58.140
You can say seauth accept my
user and then follow that by

00:05:58.140 --> 00:05:58.140
the hash of the public key.

00:05:59.990 --> 00:06:03.240
And to borrow from a commercial
from a while back that Apple did,

00:06:03.310 --> 00:06:04.580
there is no step three.

00:06:04.630 --> 00:06:05.290
That's it.

00:06:05.290 --> 00:06:06.870
That's all you have to do.

00:06:06.960 --> 00:06:16.760
So it's very,
very easy in the sort of the recommended

00:06:16.790 --> 00:06:18.200
setup to add a user and allow them
to authenticate using their token.

00:06:20.780 --> 00:06:26.150
So again, go to the session on Friday to
see some of the caveats and other

00:06:26.150 --> 00:06:29.540
things that you might run into.

00:06:29.540 --> 00:06:32.190
But a very,
very common one that sort of prevents

00:06:32.190 --> 00:06:36.750
you from doing that recommended scheme
is that you don't have the ability to

00:06:36.750 --> 00:06:39.360
add items to your directory schema.

00:06:39.360 --> 00:06:43.190
So you might be in an organization
that doesn't allow changes like

00:06:43.190 --> 00:06:45.340
that or would be prohibitive to do.

00:06:45.340 --> 00:06:46.960
That can be a difficulty.

00:06:47.830 --> 00:06:52.190
There is a way to create a configuration
file that will allow you to use other

00:06:52.190 --> 00:06:58.640
items on the token to look up credentials
that you can use to authenticate with,

00:06:58.830 --> 00:07:01.320
and there are more details on that.

00:07:02.700 --> 00:07:06.910
One specific example that unfortunately
doesn't work with this setup is that

00:07:07.020 --> 00:07:12.540
the Active Directory plug-in generates
authentication authority on the fly,

00:07:12.540 --> 00:07:15.220
and so you can't really add
that in using this script.

00:07:15.330 --> 00:07:22.080
But we are thinking about ways
of improving that experience,

00:07:22.080 --> 00:07:25.060
and so it could be that when the
final version of Leopard ships

00:07:25.060 --> 00:07:25.060
that we'll have sorted that out.

00:07:26.480 --> 00:07:31.860
Okay, so now again a brief thing
for people that are writing

00:07:31.860 --> 00:07:39.050
application-level code that needs to
talk to smart cards or other tokens.

00:07:41.480 --> 00:07:43.520
So how do you get token support?

00:07:43.570 --> 00:07:46.060
Now traditionally,
this has really been very,

00:07:46.060 --> 00:07:51.530
very difficult because
as an application writer,

00:07:51.540 --> 00:07:55.320
often you're not really that
concerned with security or

00:07:55.320 --> 00:07:57.380
that's not your primary focus.

00:07:57.510 --> 00:08:02.080
And so it's a lot of extra
work to add security layers in.

00:08:02.220 --> 00:08:05.390
But it's even worse when you look
at all the different types of tokens

00:08:05.430 --> 00:08:06.970
that you might have to talk to.

00:08:07.000 --> 00:08:12.300
So it rapidly gets out of hand if
you want to start supporting these.

00:08:12.400 --> 00:08:16.820
So typically what happens is you'll
write an application and then you'll

00:08:16.820 --> 00:08:19.600
write maybe through a PKCS11 layer.

00:08:19.830 --> 00:08:23.370
And then you'll write directly to
a particular token that's maybe

00:08:23.370 --> 00:08:25.220
unique to your organization.

00:08:25.260 --> 00:08:28.370
But that really doesn't scale very well.

00:08:29.770 --> 00:08:36.730
So we had thought about this for a while,
and the recommendation that we have to

00:08:36.730 --> 00:08:46.200
work on Mac OS X is to use the CDSA or
SEC APIs inside your application.

00:08:46.220 --> 00:08:52.340
So if you do that, you will get automatic
support for tokens underneath.

00:08:52.700 --> 00:08:59.030
So some of the SEC APIs,
Secure Transport, CF Network, WebKit,

00:08:59.030 --> 00:09:03.800
SEC Keychain Calls,
those are all examples of these.

00:09:03.800 --> 00:09:09.710
And if you write to these APIs,
then you'll automatically have support

00:09:09.710 --> 00:09:16.400
for tokens at the same level that you
would have for a file-based keychain,

00:09:16.400 --> 00:09:17.920
for example.

00:09:19.530 --> 00:09:23.350
And that last bullet point is important,
that you should be able to do most,

00:09:23.350 --> 00:09:26.080
if not all,
of your testing just using soft keys.

00:09:26.080 --> 00:09:30.110
So in other words,
a key that you've picked up that's, say,

00:09:30.210 --> 00:09:33.520
from VeriSign or Thought,
that's in a P12 file

00:09:33.640 --> 00:09:37.200
imported into your keychain,
if it works with that,

00:09:37.200 --> 00:09:42.820
then you should be able to just go ahead
and expect that it will work with tokens.

00:09:42.820 --> 00:09:46.400
So we have a concrete
example of this working,

00:09:46.650 --> 00:09:48.520
Microsoft Entourage.

00:09:49.670 --> 00:09:54.320
This is an existing Mac OS X app,
and actually this story

00:09:54.320 --> 00:09:56.780
is really from last year.

00:09:56.780 --> 00:10:03.070
When they were working on Office 2004,
they wanted to add the ability

00:10:03.110 --> 00:10:05.640
to have smart card support.

00:10:05.640 --> 00:10:09.220
And we didn't even have the
APIs finalized or anything.

00:10:09.300 --> 00:10:11.320
We had nothing for them to
work with at that point.

00:10:11.320 --> 00:10:17.200
But we knew that we would be basing it
on this idea of talking to the sec APIs.

00:10:17.200 --> 00:10:19.480
So we said, okay,
just write everything down.

00:10:19.500 --> 00:10:47.740
And we said, okay,
just write everything down.

00:10:50.700 --> 00:10:58.400
Okay, so now I'm going to talk a little
bit about the architecture of

00:10:58.400 --> 00:11:00.900
tokens in Mac OS X Leopard.

00:11:02.600 --> 00:11:14.400
[Transcript missing]

00:11:14.700 --> 00:11:45.800
[Transcript missing]

00:11:46.320 --> 00:11:51.780
We wanted it to work with existing
applications using current Mac OS X APIs.

00:11:51.780 --> 00:11:56.370
We wanted it to be able
to support single sign-on,

00:11:56.440 --> 00:12:00.570
and as a follow-on to that,
it needed to be able to

00:12:00.570 --> 00:12:05.670
allow the token to be shared
among different applications.

00:12:05.700 --> 00:12:09.380
So we wanted the ability
to enter a PIN here,

00:12:09.380 --> 00:12:14.810
and then, unless you disallow it,
allow some other application

00:12:14.810 --> 00:12:16.610
to also use that card.

00:12:16.620 --> 00:12:20.210
So we had looked at different
things like writing a CSP,

00:12:20.210 --> 00:12:23.120
which is a cryptographic
service provider,

00:12:23.390 --> 00:12:24.800
data library module.

00:12:24.800 --> 00:12:27.890
We could have written
one of those per card,

00:12:27.960 --> 00:12:32.350
but then only that particular
app would know about that PIN.

00:12:33.060 --> 00:12:37.070
Writing the PKCS11 driver has some
of the drawbacks that I mentioned,

00:12:37.070 --> 00:12:39.080
which is it tends to be very,
very vertical,

00:12:39.080 --> 00:12:40.880
very specific to the token.

00:12:44.850 --> 00:12:50.820
So what advantages did we get
out of the TokenD solution?

00:12:50.840 --> 00:12:53.050
Excuse me.

00:12:54.230 --> 00:12:57.850
We ended up with horizontal
support for the tokens.

00:12:57.980 --> 00:13:00.910
So across all these
different applications,

00:13:00.910 --> 00:13:04.860
they could all share the token
and use the token without all of

00:13:04.860 --> 00:13:07.150
them having to do all of the work.

00:13:07.260 --> 00:13:12.450
So out of the box on actually for some
features going back as far as Panther,

00:13:12.550 --> 00:13:19.400
but certainly Tiger and Leopard,
there's support for login, authorization,

00:13:19.680 --> 00:13:23.980
mail using S-MIME,
Safari for client-side authentication.

00:13:24.100 --> 00:13:25.760
Screen locking.

00:13:25.760 --> 00:13:32.020
And also any apps that are
using CDSA or CDSA-type APIs.

00:13:32.020 --> 00:13:37.100
So again, including WebKit or CF Network.

00:13:37.700 --> 00:13:40.480
If the token allows it,
you can have single

00:13:40.480 --> 00:13:42.260
sign-on with the token.

00:13:42.260 --> 00:13:44.250
So in other words,
you authenticate once to

00:13:44.270 --> 00:13:47.860
the token using your PIN,
and that will remain unlocked until

00:13:47.860 --> 00:13:50.340
the developer wants that to be locked.

00:13:50.420 --> 00:13:53.670
We have support for ACLs.

00:13:53.670 --> 00:13:58.970
And as I mentioned,
previously all you had was support for

00:13:58.980 --> 00:14:02.750
vertical applications based on PCSC.

00:14:07.250 --> 00:14:11.910
So here, conceptually,
what we're trying to do with

00:14:11.910 --> 00:14:16.650
this is just think of tokens,
either smart cards or

00:14:16.650 --> 00:14:18.960
other hardware tokens,
as keychains.

00:14:19.100 --> 00:14:20.760
That's the best way to think of them.

00:14:20.820 --> 00:14:25.700
They're not file-based like the
regular keychain that you're used to,

00:14:25.870 --> 00:14:28.940
but they are still keychains,
so they support all the same APIs.

00:14:28.940 --> 00:14:33.950
You can see from the diagram up above,
you have the applications

00:14:33.950 --> 00:14:37.180
written on top of the smart card.

00:14:37.200 --> 00:14:48.330
of the Sec APIs and those Sec APIs are
calling into the CDSA pieces of

00:14:48.330 --> 00:14:54.700
CSSM and this new cryptographic
service provider called the SDCSPDL.

00:14:54.700 --> 00:15:00.700
So that's a smart card device
cryptographic service provider.

00:15:01.050 --> 00:15:05.230
The SDCSP DL communicates back
and forth with Security D,

00:15:05.420 --> 00:15:11.350
which is the process that's responsible
for managing sort of traffic directing

00:15:11.350 --> 00:15:13.960
for cryptographic operations.

00:15:13.960 --> 00:15:19.120
And Security D will communicate
not only with individual token Ds,

00:15:19.180 --> 00:15:21.730
but also back and forth to PCSC D.

00:15:21.730 --> 00:15:24.980
Now,
the communication to PCSC D is mostly

00:15:24.980 --> 00:15:30.870
deciding whether or not to launch a
new token or not to launch a new token.

00:15:30.910 --> 00:15:35.000
So if it sees the insertion of a device,
it will say, okay,

00:15:35.000 --> 00:15:37.820
I better launch PCSC D,
start that rolling.

00:15:37.820 --> 00:15:41.180
But it can also detect removal
events and things like that.

00:15:41.230 --> 00:15:46.710
You can see from the diagram, too,
PCSC D will communicate with the readers

00:15:46.710 --> 00:15:51.210
or has the APIs to talk to the readers,
and it knows when readers

00:15:51.250 --> 00:15:53.300
are inserted or removed.

00:15:53.340 --> 00:16:00.880
And then the individual token Ds will
talk to the readers through the PCSC D.

00:16:00.900 --> 00:16:02.780
APIs.

00:16:05.950 --> 00:16:13.760
Now to make these token Ds possible,
we have something called the

00:16:14.060 --> 00:16:18.270
Security Token D Framework,
which helps you-- it sort of

00:16:18.390 --> 00:16:21.010
wraps around each token D.

00:16:21.180 --> 00:16:24.770
A token D, by the way, is--

00:16:25.300 --> 00:17:03.900
[Transcript missing]

00:17:06.460 --> 00:17:12.700
So a token D, again,
is a process that's loaded for

00:17:12.710 --> 00:17:15.840
each token or card that's inserted.

00:17:15.840 --> 00:17:19.770
And you'll have one
token D per active token.

00:17:20.200 --> 00:17:24.060
As you go up through the
different layers of the API,

00:17:24.130 --> 00:17:27.830
the higher levels of the system just
see those as additional keychains.

00:17:27.860 --> 00:17:32.610
And as you insert and remove tokens,
they'll be added to the dynamic

00:17:32.610 --> 00:17:34.800
search list for keychains.

00:17:39.210 --> 00:17:43.430
The API for this has a number of
callback functions which are called

00:17:43.430 --> 00:17:45.660
by the system as they're needed.

00:17:45.670 --> 00:17:50.130
So there's a set of functions that
are initially invoked to kind of

00:17:50.280 --> 00:17:54.420
get the token D up and running,
and then there are another set

00:17:54.420 --> 00:17:58.920
of callbacks which are invoked
as the higher-level applications

00:17:58.970 --> 00:18:01.560
call down through the CDSA stack.

00:18:07.620 --> 00:18:12.300
So here you can see,
this is just a larger version

00:18:12.300 --> 00:18:15.600
of that previous diagram,
where you can see that the SDCS PDL is

00:18:15.600 --> 00:18:21.320
just another cryptographic service
provider alongside the other modules

00:18:21.320 --> 00:18:24.560
that are inside the CDSA architecture.

00:18:24.560 --> 00:18:28.460
If you're not familiar with CDSA,
it's an acronym for

00:18:28.920 --> 00:18:33.930
Common Data Security Architecture,
and this is our framework for

00:18:34.250 --> 00:18:41.400
doing cryptography and public key
infrastructure and things like that.

00:18:41.420 --> 00:18:46.110
It's roughly equivalent in size and
thickness of manual to something

00:18:46.110 --> 00:18:48.750
like Crypto API on the Windows side.

00:18:52.930 --> 00:18:58.960
So what happens, how does a token D sort
of come into life?

00:18:59.060 --> 00:19:01.630
As a device is inserted,

00:19:01.750 --> 00:19:06.630
PCSC, well actually IOCIT,
will send a notification that

00:19:06.630 --> 00:19:12.840
PCSC picks up and Security D will
notice that this new device is there.

00:19:12.840 --> 00:19:17.260
An additional step ahead of
this is if PCSC is not running,

00:19:17.260 --> 00:19:23.310
then Security D is actually looking for
notifications of insertions as well.

00:19:23.340 --> 00:19:26.980
Assuming PCSC is running,
it will get that notification.

00:19:26.980 --> 00:19:33.010
And then Security D will look
at each token D that is inside

00:19:33.250 --> 00:19:37.310
system library security token D.

00:19:37.820 --> 00:19:42.530
It's going to launch each one
of those token Ds in turn,

00:19:42.700 --> 00:19:47.260
and it makes an API call
called probe to each token.

00:19:47.260 --> 00:19:52.190
The token D that returns the highest
score through probe will end up

00:19:52.190 --> 00:19:57.180
living and will be assigned by
security D to work with the token.

00:19:57.460 --> 00:19:59.670
The other token Ds will be killed off.

00:20:01.600 --> 00:20:03.930
And then after that process is done,
established is called,

00:20:03.930 --> 00:20:07.420
and that's a chance for your code
to do whatever it might need to

00:20:07.420 --> 00:20:09.570
do to initially set up the token.

00:20:13.430 --> 00:20:16.620
Okay, so now that's a very,
very brief overview of the

00:20:16.770 --> 00:20:19.100
architecture and configuration,
whatever.

00:20:19.100 --> 00:20:22.380
Now we're going to dive right
into the implementation.

00:20:25.530 --> 00:20:28.940
Okay, so the one-day token D,
that's the goal.

00:20:28.940 --> 00:20:34.990
That's what hopefully we can do as we
step through these different slides.

00:20:34.990 --> 00:20:41.680
You might think that the one-day token
D is sort of hyperbole or whatever,

00:20:41.750 --> 00:20:46.990
but we've actually had more than
one developer write a pretty

00:20:47.120 --> 00:20:50.310
functioning token D in a single day.

00:20:53.840 --> 00:20:56.290
The standard token D for
the common access card,

00:20:56.290 --> 00:21:02.590
DOD common access card,
is only 1,900 lines of code total.

00:21:02.590 --> 00:21:09.570
And a lot of lines in that set
of code don't have to be modified

00:21:09.570 --> 00:21:11.130
to make it work with your token.

00:21:15.090 --> 00:21:15.090
So, our goal...

00:21:15.100 --> 00:22:14.100
[Transcript missing]

00:22:14.550 --> 00:22:18.220
You can use either the
Common Access Card or the BellPix

00:22:18.220 --> 00:22:21.120
sources from Darwin as starting points.

00:22:21.120 --> 00:22:26.440
And at some point pretty soon,
we should have a sample token D where

00:22:26.440 --> 00:22:32.180
we took the CAC token D and stripped
out everything that's CAC-specific

00:22:32.180 --> 00:22:35.010
so it's even easier to start from.

00:22:35.040 --> 00:22:38.850
The interesting thing is
that most of the code,

00:22:38.950 --> 00:22:44.350
so I mentioned there were
1,900 lines in the CAC code.

00:22:44.460 --> 00:22:49.710
Excuse me, in the CAC token D,
I would say probably

00:22:50.600 --> 00:23:04.300
[Transcript missing]

00:23:07.950 --> 00:23:11.100
Okay, so our plan of attack
for this one-day token D,

00:23:11.100 --> 00:23:13.850
we're going to go
through a few steps here.

00:23:13.850 --> 00:23:16.690
Implement at least a stub
for probe and identify,

00:23:16.730 --> 00:23:19.880
so that tells security D whether
or not it should leave,

00:23:19.880 --> 00:23:22.240
you know,
whether or not your token D wins

00:23:22.240 --> 00:23:24.490
and knows how to talk to the card.

00:23:24.500 --> 00:23:30.330
There are two classes called
XYZ record in this sample code and

00:23:30.330 --> 00:23:37.020
XYZ key record that we will modify
to know more about our token.

00:23:37.970 --> 00:23:44.240
We'll add at least one key and one
certificate in the populate call,

00:23:44.290 --> 00:23:47.570
and then we'll fill in the actual
data in get data attribute.

00:23:47.570 --> 00:23:50.200
Then we'll try it out.

00:23:52.650 --> 00:23:56.600
Okay, so there are a few functions
that you will need to change.

00:23:56.600 --> 00:24:02.700
So starting from that base of either the
XYZ sample or the CAC token D sample,

00:24:02.700 --> 00:24:04.710
you will have to change these functions.

00:24:04.850 --> 00:24:09.070
So they are probe, identify,
which is really just a

00:24:09.070 --> 00:24:11.330
sub-function of probe.

00:24:13.120 --> 00:24:23.780
Populate, which will put items
into the local database,

00:24:23.780 --> 00:24:23.780
and get data attribute.

00:24:23.780 --> 00:24:23.780
So these, you're going to have to write
at least four functions.

00:24:24.810 --> 00:24:27.790
Okay, so now let's go on to our
stub for probe and identify.

00:24:27.800 --> 00:24:33.110
So you can see from the

00:24:33.600 --> 00:24:46.900
[Transcript missing]

00:24:47.200 --> 00:24:51.640
The point of Probe is that you,
as the token D writer, know your token,

00:24:51.700 --> 00:24:55.370
and if somebody inserts a token,
you need to know whether that's a

00:24:55.410 --> 00:24:57.310
token that you can handle or not.

00:24:57.350 --> 00:25:01.300
If it's something that you can handle,
return a score, say, of 100.

00:25:01.300 --> 00:25:04.050
Or if it's something you
might be able to handle,

00:25:04.050 --> 00:25:06.940
maybe you'll return something like a 50.

00:25:06.940 --> 00:25:11.380
Whichever token D comes up with the
highest score will stay running.

00:25:13.100 --> 00:25:15.830
If you're familiar with
PCSE and using that,

00:25:15.870 --> 00:25:19.410
there's a structure in there
called SCARD reader state,

00:25:19.550 --> 00:25:23.660
and that is passed to this call,
or it's available from this call,

00:25:23.720 --> 00:25:26.690
and you can get things
like the ATR out of that.

00:25:30.080 --> 00:25:33.120
If you decide that, yes,
you really know how to handle this token

00:25:33.120 --> 00:25:38.590
and you want to be in charge of it,
then you should do your best to

00:25:38.950 --> 00:25:44.340
fill in token UID with a really
unique identifier for that card.

00:25:44.380 --> 00:25:53.140
So, the best thing is if your card has a,
you know, you've issued it to employee,

00:25:53.140 --> 00:25:58.960
you know, 12345 and your company name is,
you know, XYZ Corp,

00:25:59.190 --> 00:26:05.300
maybe return an identifier of, you know,
XYZ Corp 12345.

00:26:05.300 --> 00:26:09.240
And the reason that you want to
do that is as part of establish,

00:26:09.240 --> 00:26:13.030
you get past a directory
which is your cache directory

00:26:13.030 --> 00:26:18.130
and security D keeps track,
helps you keep track of different cards

00:26:18.130 --> 00:26:21.540
that are inserted by this unique ID.

00:26:21.540 --> 00:26:23.540
So you want to try and... Okay.

00:26:23.540 --> 00:26:26.510
Do a good job filling that out.

00:26:27.450 --> 00:26:32.300
Okay, so here's a very,
very simple implementation of probe.

00:26:32.320 --> 00:26:37.810
You call the probe for the base class,
which will do some basic stuff.

00:26:37.920 --> 00:26:40.010
You can go off and look at
the class there to see the

00:26:40.010 --> 00:26:42.380
different things that it's doing,
but you'll almost

00:26:42.400 --> 00:26:43.670
certainly want to do that.

00:26:47.300 --> 00:27:11.500
[Transcript missing]

00:27:13.260 --> 00:27:19.200
So looking at identify, again,
you as the owner and manufacturer

00:27:19.200 --> 00:27:24.100
of the token or populator of the
token are going to know what will

00:27:24.480 --> 00:27:28.390
uniquely identify that as one of the
tokens that you know how to handle.

00:27:28.390 --> 00:27:33.680
It may be that you identify
that by something in the ATR.

00:27:33.680 --> 00:27:38.430
In the case of, say,
a Java card like the Common Access card,

00:27:38.430 --> 00:27:43.180
if you look at the sources for that,
you'll see that it selects

00:27:43.270 --> 00:27:45.020
a particular Java applet.

00:27:45.140 --> 00:27:48.650
If it manages to select that,
then it's pretty confident that

00:27:49.090 --> 00:27:53.010
it's found an actual CAC card.

00:27:53.220 --> 00:27:54.650
Here it shows a couple things.

00:27:54.660 --> 00:27:57.880
You pull out the,
by calling startup reader info,

00:27:57.880 --> 00:28:00.400
you will get back a copy of the ATR.

00:28:00.400 --> 00:28:06.310
And here at the bottom, you can see,
well, okay, we're going to say if byte 12

00:28:06.310 --> 00:28:10.680
and byte 14 are these values,
then this must be one of our tokens.

00:28:13.410 --> 00:28:18.500
Okay, so next,
I'm not going to go over how you change

00:28:18.500 --> 00:28:25.950
XYZ record and XYZ key record in detail,
but we do need to add at least one

00:28:26.030 --> 00:28:28.770
key and one certificate in Populi.

00:28:34.520 --> 00:28:40.320
So what Populate does is it's a
chance for you to push records

00:28:40.320 --> 00:28:41.720
into the local database.

00:28:41.720 --> 00:28:46.590
So as I mentioned earlier
on the architecture diagram,

00:28:46.680 --> 00:28:51.740
Say the file-based keychain
is a combination CSP and DL,

00:28:51.800 --> 00:28:54.080
data library module.

00:28:54.180 --> 00:28:56.520
That means it's a database of sorts.

00:28:56.520 --> 00:29:00.850
It contains your keys and passwords
and secure notes and things like that.

00:29:00.880 --> 00:29:05.880
In this populate call, you're saying,
okay, I have a few different

00:29:05.940 --> 00:29:08.840
record types on my token,
and when the upper levels

00:29:09.210 --> 00:29:13.080
call down and make CDSA calls,
it will be able to iterate through

00:29:13.150 --> 00:29:15.090
those records and find them.

00:29:16.570 --> 00:29:20.920
So on this slide,
you'll see that we're basically doing

00:29:20.920 --> 00:29:23.000
some database housekeeping here.

00:29:23.160 --> 00:29:30.510
We're describing to the schema class
some of the different relations or tables

00:29:30.510 --> 00:29:34.260
that we have on this token database.

00:29:34.260 --> 00:29:37.760
So we have one relation
for an X.509 certificate,

00:29:37.870 --> 00:29:40.630
we have a different
relation for a private key,

00:29:40.630 --> 00:29:43.030
and we have another one for generic.

00:29:43.820 --> 00:29:46.700
Generic might be if
you have data records.

00:29:46.760 --> 00:29:52.020
For example,
the common access card has pay grade

00:29:52.020 --> 00:29:55.700
and it has social security number and
date of birth and things like that.

00:29:55.750 --> 00:29:57.660
So those would be generic
data type records.

00:30:01.540 --> 00:30:04.250
One thing I didn't
mention at the end there,

00:30:04.400 --> 00:30:09.110
you do not have to actually go and
fetch any of the data at populate time.

00:30:09.130 --> 00:30:13.600
If you want, you can defer actual data
retrieval to when somebody

00:30:14.160 --> 00:30:16.660
calls a get data attribute call.

00:30:19.150 --> 00:30:25.900
Okay, so to continue on with Populate,
see the first set of lines there?

00:30:25.900 --> 00:30:31.000
It's creating a new certificate
record called ID cert.

00:30:31.000 --> 00:30:35.300
And the next two parameters
there to the new call,

00:30:35.300 --> 00:30:39.980
there's one that's in blue
that's K select XYZ applet PK ID.

00:30:39.980 --> 00:30:44.800
This is an example of something that you
might be doing if you had a Java card.

00:30:44.810 --> 00:30:50.240
So on Java, Java cards you have applets
which are little Java applets,

00:30:50.300 --> 00:30:52.480
you know, a subset of Java.

00:30:52.480 --> 00:30:56.960
And they have ATR kind of identifiers,
you know, hex identifiers,

00:30:56.960 --> 00:31:00.610
and you pick a particular one and it
will do a particular function for you.

00:31:00.700 --> 00:31:06.860
So here I'm passing
that as an identifier.

00:31:06.860 --> 00:31:11.170
If you have different type of token,
that might not be relevant to you.

00:31:11.180 --> 00:31:14.450
So you can change,
this is what I meant when I said

00:31:14.450 --> 00:31:18.740
you might have to change the
XYZ certificate record call.

00:31:19.240 --> 00:31:23.140
In particular,
the constructor to take something that's

00:31:23.140 --> 00:31:31.760
useful for you to be able to identify
different applets or files on your token.

00:31:32.030 --> 00:31:35.820
And we passed along this
name identity certificate.

00:31:36.100 --> 00:31:41.910
That's also just really
for your purposes.

00:31:42.170 --> 00:31:45.350
The second line of that cert
relation dot insert record,

00:31:45.540 --> 00:31:48.770
you actually take that new cert
record that you created and you

00:31:49.110 --> 00:31:50.740
add it into the local database.

00:31:50.740 --> 00:31:53.280
So this doesn't actually
have any data in it yet.

00:31:53.380 --> 00:31:57.820
It's really just a pointer saying, yep,
there's one certificate on this card.

00:31:57.820 --> 00:32:01.890
And if I had a bunch of certificates,
I could either have a bunch of new

00:32:01.890 --> 00:32:05.460
calls or I could have a loop that
goes and checks with my card or

00:32:05.460 --> 00:32:07.490
maybe most cards are very small.

00:32:07.490 --> 00:32:12.000
They don't have a lot of items on them,
so you can just enumerate them.

00:32:13.190 --> 00:32:15.250
We're going to do a very,
very similar thing for

00:32:15.840 --> 00:32:19.540
the private key record.

00:32:19.770 --> 00:32:27.170
So you can see we're creating a
new XYZ key record called IDKey.

00:32:53.100 --> 00:32:53.100
And again,
we're passing in this XYZ applet

00:32:53.100 --> 00:32:53.100
PKID just to pick out that
particular Java applet.

00:32:53.100 --> 00:32:53.100
And then we're going to also insert
that record into the local database.

00:32:53.100 --> 00:32:53.100
Now the last set of lines there,
probably the least familiar to anyone.

00:32:55.560 --> 00:32:59.110
with the particular private
key that you're working with,

00:32:59.210 --> 00:33:02.060
you want to be able to
associate a certificate record.

00:33:02.060 --> 00:33:05.810
So we provided a way to do
that by saying set adornment.

00:33:05.920 --> 00:33:09.740
So you take the private
key record and you say,

00:33:09.740 --> 00:33:14.330
oh, yeah, this private key,
I use that certificate over there.

00:33:14.380 --> 00:33:18.220
So you don't have to do lots of
searches to find the certificate

00:33:18.220 --> 00:33:20.670
that goes with the private key.

00:33:20.680 --> 00:33:22.990
That's all that line is really doing.

00:33:25.500 --> 00:33:30.610
Okay, so next we're going to fill in
the data in getDataAttribute.

00:33:34.890 --> 00:33:42.370
So, get data attribute is the actual call
where you're going to be going off

00:33:42.370 --> 00:33:45.490
to your token and retrieving data.

00:33:45.490 --> 00:33:52.730
You will make the calls that
you need to read the certificate

00:33:52.730 --> 00:33:56.250
data or do key operations.

00:33:56.250 --> 00:33:58.030
Sorry, not key operations.

00:33:58.180 --> 00:34:04.900
So, if you look at the CAC token,
you'll see a really detailed

00:34:04.900 --> 00:34:07.560
example that has a lot of

00:34:07.600 --> 00:34:29.600
[Transcript missing]

00:34:29.810 --> 00:34:36.760
But what I did put in here,
just to illustrate sort of the

00:34:37.570 --> 00:34:37.950
general layout of this call,

00:34:38.480 --> 00:34:45.050
You're passed in a
reference to a token record.

00:34:45.460 --> 00:34:48.130
And when this call is called.

00:34:48.150 --> 00:34:53.100
And I've highlighted
the PCSC transaction.

00:34:53.100 --> 00:34:57.200
So you can use that class
to start a transaction.

00:34:57.200 --> 00:35:02.240
And then the lines below that,
you're going to do whatever you need to

00:35:02.300 --> 00:35:05.430
do with your card to retrieve that data.

00:35:05.430 --> 00:35:08.140
So in the case of a CAC card,
you're going to be talking

00:35:08.140 --> 00:35:09.410
with that Java applet.

00:35:12.440 --> 00:35:16.540
There are classes that are built
in to help you cache that data,

00:35:16.540 --> 00:35:17.520
which you may want to do.

00:35:17.520 --> 00:35:19.380
Like smart cards have very low data rate.

00:35:19.440 --> 00:35:23.500
So you're going to want to
read the certificate once.

00:35:23.500 --> 00:35:24.190
It's public.

00:35:24.190 --> 00:35:25.500
You might as well cache it.

00:35:25.500 --> 00:35:26.590
So read it in.

00:35:26.590 --> 00:35:30.820
You can use these classes
to help you cache that data.

00:35:32.450 --> 00:35:34.850
At the end, you're going to end up with
a blob of data that you

00:35:34.850 --> 00:35:36.490
want to return in this call.

00:35:36.550 --> 00:35:38.730
And you can see the last line there.

00:35:38.730 --> 00:35:41.320
The two parameters there are data.

00:35:42.440 --> 00:35:43.400
Data.data and data.length.

00:35:43.420 --> 00:35:49.450
That data is a CSSM data structure,
which is just a pointer and a length.

00:35:49.510 --> 00:35:51.280
And you're going to return that up.

00:35:51.300 --> 00:35:58.100
And that will get passed up through
the different levels and get mushed

00:35:58.100 --> 00:36:02.770
around as necessary to turn it into
something that looks like a certificate.

00:36:05.460 --> 00:36:07.650
Okay, so now that's it.

00:36:07.770 --> 00:36:10.520
Those are the four things
that you had to change.

00:36:10.520 --> 00:36:11.910
So build it.

00:36:11.980 --> 00:36:15.980
You install it into system
library security token D,

00:36:15.980 --> 00:36:18.470
which of course you have
to be able to do that.

00:36:18.520 --> 00:36:21.580
And then try it out in keychain access.

00:36:25.510 --> 00:36:27.610
So there you go, success.

00:36:27.620 --> 00:36:29.450
This is what it should look like.

00:36:29.590 --> 00:36:33.820
This is an example of actually
the shipping CAC token D,

00:36:33.820 --> 00:36:36.340
but you'll see something
very similar to this.

00:36:36.340 --> 00:36:41.200
You can see on the top left,
this shows up as smart card number three.

00:36:41.200 --> 00:36:46.000
So it's a dynamic keychain,
and it's just added

00:36:46.000 --> 00:36:48.560
to your keychain list.

00:36:48.720 --> 00:36:51.960
If you click on that,
you will then see the

00:36:52.080 --> 00:36:54.480
contents of that keychain.

00:36:54.480 --> 00:36:59.310
So here you can see it has
a couple different keys and

00:36:59.530 --> 00:37:06.400
a couple different certs,
three keys and three certs on that token.

00:37:11.900 --> 00:37:14.780
Okay, now, you probably did all
that in about an hour,

00:37:14.780 --> 00:37:15.360
right?

00:37:15.360 --> 00:37:18.420
It's all ready to go,
and you're practically ready to ship.

00:37:18.590 --> 00:37:22.380
But probably you should add
some calls to the crypto code.

00:37:22.390 --> 00:37:30.390
So these are the calls that you're
going to be calling or modifying

00:37:31.050 --> 00:37:36.280
to add the actual cryptographic
operations for your token.

00:37:36.280 --> 00:37:36.280
So compute crypt.

00:37:37.110 --> 00:37:47.150
Compute Crypt, I should point out,
is where the bulk of your

00:37:47.240 --> 00:37:54.050
cryptographic work is going to happen.

00:37:54.050 --> 00:37:54.050
So you'll either be making requests
to the card to do encryption or...

00:37:54.650 --> 00:37:57.240
you know,
perhaps use a key in other ways.

00:37:57.240 --> 00:38:00.730
There's a lot of code,
if you look at the CAC example,

00:38:01.040 --> 00:38:05.350
you'll see there's a lot of code
that's there that deals with things

00:38:05.350 --> 00:38:10.280
like different types of padding,
you know, notepad, pad,

00:38:10.530 --> 00:38:12.440
different RSA things.

00:38:12.440 --> 00:38:17.170
A lot of that code you should be able
to reuse because it's just standard

00:38:17.840 --> 00:38:21.890
things that you have to do before you
can set up for a cryptographic operation.

00:38:22.080 --> 00:38:25.800
So in many cases you won't change
any of those lines of code.

00:38:25.830 --> 00:38:29.410
But of course,
ultimately you'll end up calling out

00:38:29.670 --> 00:38:35.720
either to your card directly or you may
have a PKCS 11 library that you can make

00:38:35.720 --> 00:38:42.500
the crypto calls to PKCS 11 to actually
have that library do the work for you.

00:38:43.880 --> 00:38:47.710
You'll certainly need to implement verify
pin if you want to be able to do anything

00:38:47.710 --> 00:38:52.490
that requires the card to be unlocked.

00:38:52.560 --> 00:38:58.750
That takes a pin number and
the pin and the pin length.

00:38:58.750 --> 00:39:02.940
And you will be passed
these from the upper layers.

00:39:03.010 --> 00:39:08.800
So for example, when you're logging in,
if you set your machine up for smart

00:39:08.800 --> 00:39:17.100
card login and insert a supported token,
you'll see that the login window

00:39:17.100 --> 00:39:21.170
dialog changes from password to pin.

00:39:21.220 --> 00:39:24.590
If you enter the pin,
that'll go through security agent,

00:39:24.660 --> 00:39:27.420
which will talk with security D,
which will then pass it

00:39:27.510 --> 00:39:29.290
down to your token D.

00:39:29.290 --> 00:39:30.710
So that's the path for that.

00:39:32.070 --> 00:39:37.170
Change pin, very,
very similar type thing.

00:39:38.070 --> 00:39:41.010
And pin status essentially
tells you whether or not

00:39:41.010 --> 00:39:42.790
the card is unlocked or not.

00:39:42.860 --> 00:39:46.250
So if you think back to
keychain access where you see

00:39:46.250 --> 00:39:54.620
the card is locked or unlocked,
pin status will help the upper levels

00:39:54.620 --> 00:39:58.860
do the right thing in terms of showing
you whether the token's locked or not.

00:40:02.870 --> 00:40:10.790
Okay, so it's kind of a quick
summary of token-Ds in general.

00:40:11.800 --> 00:40:16.760
TokenDs allow you to have shared access
to different smart cards or other tokens.

00:40:16.760 --> 00:40:22.770
They're pretty simple to implement,
especially using the C++ layer.

00:40:22.770 --> 00:40:28.260
It does require that you
understand your particular token,

00:40:28.260 --> 00:40:32.580
but given that,
the additional work involved to

00:40:32.580 --> 00:40:39.750
get these working with Mac OS X is
relatively small on a development scale.

00:40:40.660 --> 00:40:44.390
TokenD is not PKCS 11, although you can,
if you want,

00:40:44.390 --> 00:40:48.220
you could wrap a TokenD around
a PKCS 11 driver.

00:40:48.220 --> 00:40:50.840
Maybe you've written it
for another platform,

00:40:50.940 --> 00:40:53.010
and that would be a good way to do it.

00:40:53.120 --> 00:40:57.360
We've had developers that have done,
that have, you know,

00:40:57.600 --> 00:41:01.220
We already have an
existing PKCS 11 driver,

00:41:01.400 --> 00:41:07.060
and one developer started
wrapping their PKCS 11 library

00:41:07.360 --> 00:41:11.770
with a token D and realized,
no, it's just easier to just call

00:41:11.770 --> 00:41:14.100
their functions directly.

00:41:14.100 --> 00:41:21.290
We had another developer that decided,
no, we'll keep that separation so that

00:41:21.290 --> 00:41:23.800
it's easier for us to maintain.

00:41:23.800 --> 00:41:23.800
Either way should work for you.

00:41:25.000 --> 00:41:29.090
It's certainly the additional work
for writing a token D is much,

00:41:29.160 --> 00:41:31.850
much less work than
writing a PKCS 11 library.

00:41:34.400 --> 00:41:38.230
Not only because, well,
if you already have that,

00:41:38.300 --> 00:41:42.980
you already know how to do crypto
operations with your token,

00:41:42.980 --> 00:41:48.960
but the C++ layers handle so much of
the database management and the key

00:41:49.170 --> 00:41:56.180
management for you that you don't
have to write a lot of things that you

00:41:56.180 --> 00:41:56.180
would have to do in a PKCS 11 library.

00:41:56.740 --> 00:42:02.320
I didn't go into modifying
the token at all.

00:42:02.460 --> 00:42:08.020
The callbacks are there,
but we don't currently have any

00:42:08.020 --> 00:42:12.080
token-Ds that write to the card.

00:42:12.200 --> 00:42:18.800
If you are writing, say,
a provisioning system for

00:42:18.800 --> 00:42:18.800
smart cards or tokens,

00:42:18.980 --> 00:42:22.230
It's possible that you'll
want to do that just using,

00:42:22.320 --> 00:42:24.200
say, PCSC calls directly.

00:42:25.520 --> 00:42:30.230
I think the main point behind
a token D is that you get a

00:42:30.230 --> 00:42:34.810
user-level experience that's really,
really nice because all these apps

00:42:34.810 --> 00:42:38.700
that the users are used to using,
they don't have to do anything

00:42:38.700 --> 00:42:39.980
special for smart cards.

00:42:40.070 --> 00:42:43.410
They just kind of work
once you have this token D.

00:42:46.590 --> 00:42:50.820
For more information,
you can contact Craig Keithley,

00:42:51.030 --> 00:42:54.530
who's the biotechnology
and security evangelist.

00:42:55.190 --> 00:42:58.970
We have...

00:42:59.230 --> 00:43:02.890
Some sample code coming up,
particularly the XYZ token,

00:43:02.890 --> 00:43:05.770
which hopefully we'll be
able to release very soon.

00:43:05.770 --> 00:43:06.980
It's already completed.

00:43:06.980 --> 00:43:13.140
And in addition, you can look at the
Darwin sources for the sources

00:43:13.140 --> 00:43:16.130
to the CAC and BellPIC tokens.
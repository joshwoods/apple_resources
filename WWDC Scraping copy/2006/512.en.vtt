WEBVTT

00:00:10.730 --> 00:00:11.900
Welcome, everybody.

00:00:11.900 --> 00:00:12.700
Good morning.

00:00:12.700 --> 00:00:17.180
My name is Viktor Miladinov,
and I'm one of the graphics

00:00:17.230 --> 00:00:20.190
engineers in the Java team at Apple.

00:00:20.370 --> 00:00:23.100
And today,
we're going to talk about performance and

00:00:23.100 --> 00:00:26.370
graphics tuning your Java application.

00:00:27.690 --> 00:00:30.570
So this is an early session,
and I kind of wanted to

00:00:30.570 --> 00:00:32.320
capture your attention.

00:00:32.360 --> 00:00:34.880
And I wanted to come up
with a catchy slogan.

00:00:34.970 --> 00:00:37.240
So I sat down and started
thinking about the slogan.

00:00:37.400 --> 00:00:40.200
And for some odd reason,
the only thing that was stuck into

00:00:40.200 --> 00:00:43.240
my head was this cheesy quote,
"15-minute call to Geico can save

00:00:43.240 --> 00:00:47.180
you 15% or more on car insurance."
So I tried to shake it off,

00:00:47.180 --> 00:00:47.980
and I couldn't.

00:00:48.120 --> 00:00:51.140
So I decided to play along
with this cheesy theme.

00:00:51.290 --> 00:00:53.960
So here's the catchy
slogan for this session.

00:00:54.340 --> 00:00:56.540
60 minutes of paying attention
to this session can increase

00:00:56.570 --> 00:00:59.940
your Java application
performance by 60% or more.

00:01:00.100 --> 00:01:01.220
Right.

00:01:01.220 --> 00:01:03.850
And in worst case,
you might just have to buy one of

00:01:03.850 --> 00:01:07.720
those new Mac Pros and you're pretty
much guaranteed 60% out of the box.

00:01:07.720 --> 00:01:14.170
But let's try to do it the hard way.

00:01:14.170 --> 00:01:14.170
Old school.

00:01:14.620 --> 00:01:15.940
So how are we going to do that?

00:01:15.940 --> 00:01:18.680
We're going to structure
this talk in three parts.

00:01:18.760 --> 00:01:20.490
The first part,
we're going to talk about the

00:01:20.490 --> 00:01:22.960
Java 2D graphics pipeline in Mac OS X.

00:01:22.960 --> 00:01:26.000
And we have several pipelines
now that you can choose from.

00:01:26.000 --> 00:01:28.630
And second part of the talk,
we're going to talk about

00:01:28.630 --> 00:01:33.160
resolution independence and how
that affects your Java application.

00:01:33.160 --> 00:01:35.990
And last but not least,
we're going to talk about Shark for Java.

00:01:36.020 --> 00:01:38.340
For those of you who don't know,
Shark is a very cool

00:01:38.430 --> 00:01:40.420
profiling tool for Mac OS X.

00:01:40.420 --> 00:01:42.160
We have Java support.

00:01:42.160 --> 00:01:43.840
And for those of you
who know about Shark,

00:01:43.980 --> 00:01:47.680
We have some new stuff
to talk to you this year.

00:01:49.210 --> 00:01:52.050
So this session is going to be
pretty packed in terms of content.

00:01:52.070 --> 00:01:53.440
It's going to be fairly intense.

00:01:53.440 --> 00:01:54.410
We have about 100 slides.

00:01:54.480 --> 00:01:55.370
We have three demos.

00:01:55.440 --> 00:01:57.070
So it's going to be pretty intense.

00:01:57.320 --> 00:02:00.690
But however,
I only want you to kind of get a

00:02:00.770 --> 00:02:03.680
few key things out of this session.

00:02:03.710 --> 00:02:06.170
So when this session is over,
I would like for you to be

00:02:06.170 --> 00:02:09.160
able to answer this question,
like what are the different

00:02:09.210 --> 00:02:11.580
Java 2D graphics pipeline and Mac OS X?

00:02:11.610 --> 00:02:14.790
Another question, what are the pros and
cons of each pipeline?

00:02:15.130 --> 00:02:18.910
What are some of the performance
characteristics of each pipeline?

00:02:19.200 --> 00:02:23.540
How do we compare against Windows XP for
some simple primitive drawing?

00:02:23.570 --> 00:02:28.890
And how can I take advantage of
OpenGL hardware exploration from Java?

00:02:29.170 --> 00:02:31.400
and Is Java Going to
Resolution Independent?

00:02:31.490 --> 00:02:33.960
So like I said, this is going to be a
pretty intense session,

00:02:34.040 --> 00:02:37.790
but these are some of the stuff I kind
of want you to pay attention to.

00:02:37.950 --> 00:02:41.440
However, the most important goal,
or the most important question

00:02:41.440 --> 00:02:44.920
I want you to get out of this
session is basically answer this.

00:02:44.930 --> 00:02:47.420
What is the best pipeline for my app?

00:02:47.430 --> 00:02:49.640
So we have several pipelines,
and choosing the right

00:02:49.770 --> 00:02:51.760
pipeline should be very,
very important.

00:02:51.760 --> 00:02:55.870
I mean, you can actually get 60%,
100%, 200% improvement if you

00:02:55.870 --> 00:02:57.120
choose the right pipeline.

00:02:57.140 --> 00:02:59.940
So we're going to
actually look over that.

00:02:59.940 --> 00:03:02.150
And the second goal,
or the second most important

00:03:02.180 --> 00:03:04.840
goal of this session,
is you should all know how

00:03:04.840 --> 00:03:08.160
you can use Shark to profile
and optimize your job out.

00:03:08.170 --> 00:03:10.980
It's very easy,
and we're going to go over that.

00:03:12.520 --> 00:03:16.390
Finally, I also wanted to remind you
that we're here to help you.

00:03:16.410 --> 00:03:20.300
So if there is something that's
not clear from this session,

00:03:20.300 --> 00:03:23.140
or you're having a performance
issue with your Java application,

00:03:23.140 --> 00:03:25.880
come talk to us afterwards
or during the labs.

00:03:25.880 --> 00:03:26.580
We'd love talking to you.

00:03:28.950 --> 00:03:32.040
So now we're going to actually dig into
the meat of the first part of the talk,

00:03:32.160 --> 00:03:33.620
the Java 2D graphics pipelines.

00:03:33.640 --> 00:03:37.190
Before we do that,
let's talk a little bit what do

00:03:37.260 --> 00:03:39.060
we mean by graphics pipeline.

00:03:39.060 --> 00:03:42.200
So for the purpose of this slide,
a graphics pipeline is

00:03:42.210 --> 00:03:43.650
an orange rectangle.

00:03:43.660 --> 00:03:45.430
It has one input and one output.

00:03:45.440 --> 00:03:49.700
The input is, for example,
a drawing command like graphics.drawline.

00:03:49.700 --> 00:03:53.520
And the output is kind of the
rasterized version of that command.

00:03:53.520 --> 00:03:56.240
So the graphics pipeline does
most of the work for you.

00:03:56.240 --> 00:03:58.800
it does the clipping and
the transformation and the

00:03:58.800 --> 00:04:01.150
restoration and so on and so on.

00:04:01.600 --> 00:04:44.000
[Transcript missing]

00:04:45.500 --> 00:04:48.920
So now we all know what's a
Java 2D graphics pipeline,

00:04:48.940 --> 00:04:51.660
and we're going to talk about
the first graphics pipeline,

00:04:51.660 --> 00:04:53.770
which is the Quartz-based
Java 2D pipeline.

00:04:53.780 --> 00:04:56.730
For those of you who don't know,
Quartz is basically the

00:04:56.730 --> 00:04:59.920
renderer of choice for pretty
much most apps in Mac OS X.

00:04:59.920 --> 00:05:02.330
Cocoa is written on top of Quartz,
so Quartz does the

00:05:02.330 --> 00:05:03.650
heavy lifting for Cocoa.

00:05:03.830 --> 00:05:08.780
And we actually implemented the
Java 2D pipeline on top of Quartz.

00:05:11.000 --> 00:05:13.120
So this graph should
be familiar with you.

00:05:13.360 --> 00:05:16.290
We have the Java 2D APIs,
and at the end we have the

00:05:16.290 --> 00:05:17.620
Quartz rendering engine.

00:05:17.640 --> 00:05:19.820
In the middle we have
the glue code that we,

00:05:19.920 --> 00:05:23.130
the Java team at Apple,
wrote to connect Java 2D APIs and

00:05:23.200 --> 00:05:24.560
the Quartz renderer.

00:05:24.610 --> 00:05:26.780
One thing to keep in
mind from this slide,

00:05:26.780 --> 00:05:28.650
I'm going to use the
color to mean something.

00:05:28.710 --> 00:05:31.860
So the blue color means
that code written by Sun,

00:05:31.880 --> 00:05:36.240
and orange color means code
written by us at Apple.

00:05:37.820 --> 00:05:40.100
So this slide should be
familiar to everybody.

00:05:40.330 --> 00:05:44.410
So we're going to see how the Quartz
pipeline deals with drawing a line.

00:05:44.740 --> 00:05:46.750
So it's actually very simple.

00:05:46.900 --> 00:05:51.760
On the Java end,
there is a call called graphics.drawline.

00:05:51.780 --> 00:05:54.330
And on the other end,
the graphics pipeline spits

00:05:54.330 --> 00:05:57.520
out this quartz command called
CGContextStrokeLineSegments,

00:05:57.520 --> 00:05:59.300
which is a native C call.

00:05:59.300 --> 00:06:00.640
So this is a very simple case.

00:06:00.710 --> 00:06:04.910
We have a clear one-to-one mapping
from the Java side to the native side.

00:06:05.040 --> 00:06:07.300
So I'm going through this for a reason.

00:06:07.300 --> 00:06:10.180
We're going to see in the next slides.

00:06:11.880 --> 00:06:15.070
So the best way to describe Quartz,
I like to use the phrase

00:06:15.210 --> 00:06:16.640
a veteran warrior.

00:06:16.840 --> 00:06:18.440
It's been with us since 1.3.

00:06:18.560 --> 00:06:21.760
We use it in 1.3, 1.4, 5.0, and 6.

00:06:21.820 --> 00:06:25.180
And it's been getting better
and better with each release.

00:06:25.200 --> 00:06:29.010
And by better,
I mean less bugs and faster performance.

00:06:29.230 --> 00:06:34.250
So we can see that Quartz actually
served us well over the years.

00:06:35.680 --> 00:06:37.230
However, there is a problem.

00:06:37.240 --> 00:06:40.020
And it's a rather big problem.

00:06:40.020 --> 00:06:42.860
And the best way to
describe this problem,

00:06:42.860 --> 00:06:45.400
I'm gonna borrow a term
from electrical engineering,

00:06:45.400 --> 00:06:47.670
and I'm gonna call it impedance mismatch.

00:06:47.830 --> 00:06:52.750
So here's a graphical representation
of what I mean by impedance mismatch.

00:06:53.370 --> 00:06:57.400
So there's a certain subset of
Java 2D APIs that there is no

00:06:57.400 --> 00:06:59.870
clear mapping or support in Quartz.

00:06:59.950 --> 00:07:03.440
So we also, in the graphics draw line,
there was a very easy one-to-one

00:07:03.440 --> 00:07:06.270
mapping between Java 2D and Quartz.

00:07:06.480 --> 00:07:10.920
However, there is a certain set of
APIs where Quartz does not support.

00:07:10.970 --> 00:07:13.950
But Java needs to run on Mac OS X,
and it needs to support

00:07:14.030 --> 00:07:15.110
all the Java 2D APIs.

00:07:15.150 --> 00:07:18.650
So we, the Java team at Apple,
had to put a lot of work around

00:07:18.650 --> 00:07:20.780
to make those stuff work.

00:07:20.780 --> 00:07:22.840
So why is this important for you?

00:07:22.950 --> 00:07:25.810
Impedance mismatch, really bad.

00:07:26.590 --> 00:07:28.680
results in a poor performance
and buggy software.

00:07:28.680 --> 00:07:33.830
Now, let's look in detail what are
some cases of impedance mismatch.

00:07:33.830 --> 00:07:37.170
So the number one culprit of this
impedance mismatch is the fact

00:07:37.170 --> 00:07:41.670
that CORS does not support direct
pixel access in their images.

00:07:41.860 --> 00:07:45.560
So we all know in buffered images,
you can say get raster, get data buffer,

00:07:45.630 --> 00:07:47.570
and basically can muck
with the pixels yourself.

00:07:47.600 --> 00:07:49.660
Well, CORS doesn't support that.

00:07:49.680 --> 00:07:53.180
So we go to great lengths to kind
of make this work on Mac OS X.

00:07:53.940 --> 00:07:55.060
And it's pretty painful.

00:07:55.060 --> 00:07:57.500
And this is kind of an
unofficial statistics,

00:07:57.500 --> 00:08:00.850
but I work in the graphics team,
so I kind of screen most of the bugs.

00:08:00.890 --> 00:08:04.050
And I would say from my experience,
50% or more of the bugs we

00:08:04.050 --> 00:08:07.250
get on Mac OS X are related
to this particular issue.

00:08:07.390 --> 00:08:10.790
So this is a big issue for us,
and it's kind of hard to solve.

00:08:12.320 --> 00:08:14.230
Second issue,
I'm going to call it-- this is

00:08:14.240 --> 00:08:16.220
another case of impedance mismatch.

00:08:16.220 --> 00:08:18.620
I'm going to call it the
unfriendly image types.

00:08:18.640 --> 00:08:23.940
So we all know buffered images that have
12 or more or less image types-- ARGB,

00:08:23.940 --> 00:08:27.080
ARGB3, 3-byte BGR, and so on and so on.

00:08:27.080 --> 00:08:29.500
Well,
Quartz only supports a handful of them.

00:08:29.500 --> 00:08:32.500
So when you use one of those
unfriendly image types,

00:08:32.500 --> 00:08:37.630
like type U short 565 RGB,
you're hitting the slow path on Mac OS X.

00:08:37.720 --> 00:08:41.700
You might not be paying any penalty
when you use it in other platforms.

00:08:41.700 --> 00:08:43.500
Another issue is XR.

00:08:43.630 --> 00:08:44.760
Quartz does not support XR.

00:08:44.760 --> 00:08:47.960
So we have to go to great
lengths to support XR.

00:08:47.960 --> 00:08:50.750
And there are many more cases,
but we're not going to go into

00:08:50.750 --> 00:08:53.830
that because I just kind of
wanted to get you an idea of

00:08:53.830 --> 00:08:57.040
examples of impedance mismatch.

00:08:57.040 --> 00:08:59.820
And again,
the same slide as before-- really bad.

00:08:59.820 --> 00:09:01.460
And we're going to see why.

00:09:01.460 --> 00:09:04.390
So really poor performance
and buggy software.

00:09:05.170 --> 00:09:08.480
So if this is really bad,
what have we done to solve it?

00:09:08.700 --> 00:09:10.280
So we worked really hard at this issue.

00:09:10.310 --> 00:09:12.900
And every release that
we release with Java,

00:09:12.920 --> 00:09:17.380
it's getting better and better and
better at solving this particular issue.

00:09:17.400 --> 00:09:19.380
And the second thing
that we have been doing,

00:09:19.380 --> 00:09:20.840
we have been educating developers.

00:09:20.970 --> 00:09:23.640
So if you were here last
year in this session,

00:09:23.660 --> 00:09:28.350
or the year before, or three years ago,
you probably heard us saying,

00:09:28.350 --> 00:09:31.380
on Mac OS X,
try not calling raster.getDataBuffer,

00:09:31.380 --> 00:09:32.980
or don't use setPixel.getPixel.

00:09:33.030 --> 00:09:33.720
It's slow.

00:09:33.740 --> 00:09:35.980
It's going to make your
application really slow.

00:09:36.000 --> 00:09:39.390
Or you probably heard us saying,
always call createCompatibleImage.

00:09:39.420 --> 00:09:41.230
Never use any of the other types.

00:09:41.420 --> 00:09:45.700
By the way, the second one is a good
suggestion nonetheless.

00:09:45.700 --> 00:09:48.710
And the last one is don't use XR.

00:09:49.120 --> 00:09:49.940
This is not right.

00:09:49.940 --> 00:09:52.780
I mean, Java, it's a cross-platform API.

00:09:52.780 --> 00:09:56.620
You write your code on Windows, Linux,
or whatever platform,

00:09:56.620 --> 00:09:58.400
and it should just work on Mac OS X.

00:09:58.620 --> 00:10:01.240
You shouldn't be worrying about this, oh,
don't do this on a Mac,

00:10:01.240 --> 00:10:02.470
or this thing is in a Mac.

00:10:02.500 --> 00:10:06.150
or you shouldn't be special
casing your code for a Mac.

00:10:07.200 --> 00:10:10.720
So I'm kind of happy to say that
I think we finally solved this problem,

00:10:10.740 --> 00:10:13.680
that your experience in the
Mac when you call these APIs,

00:10:13.700 --> 00:10:16.220
it's not going to be degraded.

00:10:16.220 --> 00:10:19.950
And the way we solved this problem,
and the solution to us,

00:10:19.950 --> 00:10:22.860
comes in a completely different pipeline.

00:10:22.890 --> 00:10:25.560
So we talked about a quartz pipeline.

00:10:25.580 --> 00:10:27.550
Now we're going to talk about a
completely different pipeline,

00:10:27.550 --> 00:10:30.390
and we're going to call
it the SAN 2D pipeline.

00:10:31.380 --> 00:10:35.760
So we sat down to think about how to
solve this impedance mismatch problem,

00:10:35.760 --> 00:10:39.060
and we realized that
Sun actually over-dissolved it.

00:10:39.060 --> 00:10:42.580
Sun actually wrote the
rendering engine in C.

00:10:42.630 --> 00:10:46.190
And since it's written by Sun,
it's a pretty much direct mapping

00:10:46.220 --> 00:10:47.820
from the Java to the APIs.

00:10:47.930 --> 00:10:49.880
So it supports the Java to
the APIs really well.

00:10:49.990 --> 00:10:53.140
So we said, why don't we just port
that code to Mac OS X?

00:10:53.290 --> 00:10:55.460
So after we ported it,
that gave birth to this

00:10:55.460 --> 00:10:56.820
completely different pipeline.

00:10:56.830 --> 00:11:00.100
And for lack of a better term,
we called it a Sun 2D pipeline,

00:11:00.100 --> 00:11:05.280
because most of the code is the
software render that's written by Sun.

00:11:07.230 --> 00:11:10.590
Very two important points
about this pipeline.

00:11:10.720 --> 00:11:13.550
One, it should be bug for bug
compatible with Windows,

00:11:13.550 --> 00:11:17.100
Linux, and Solaris.

00:11:17.550 --> 00:11:18.890
Should be.

00:11:18.990 --> 00:11:21.280
And mainly this is in
the off-screen case,

00:11:21.310 --> 00:11:23.680
because I think, San,
when it comes to Windows or

00:11:23.730 --> 00:11:25.420
the other platforms,
when you draw on screen,

00:11:25.450 --> 00:11:28.990
they might use GDI or
DirectDraw and whatnot.

00:11:29.000 --> 00:11:31.890
But if you draw off-screen,
you should be bug for bug compatible.

00:11:31.960 --> 00:11:34.620
And the second thing
that's also very important,

00:11:34.620 --> 00:11:36.500
and I think it's the
most important issue,

00:11:36.500 --> 00:11:38.500
is there is no impedance mismatch.

00:11:38.530 --> 00:11:42.360
So everything we talked about it,
San2D pipeline is actually

00:11:42.360 --> 00:11:43.720
immune to this problem.

00:11:43.720 --> 00:11:45.910
So very important.

00:11:46.480 --> 00:11:48.820
Now, let's look at a graph
of the SAN 2D pipeline.

00:11:49.110 --> 00:11:50.600
What I'd like for you
to pay attention here,

00:11:50.630 --> 00:11:52.730
it's actually the color of the boxes.

00:11:52.850 --> 00:11:56.960
So blue code means code written by SAN,
orange code, code written by us.

00:11:56.980 --> 00:12:00.160
So most of the code,
it's actually code written by SAN,

00:12:00.190 --> 00:12:04.320
just ported to Mac OS X with very,
very few modifications.

00:12:04.540 --> 00:12:07.460
We still have to write a little bit
of blue code to let SAN render a

00:12:07.460 --> 00:12:11.130
talk to our native Windows and so on,
but it's very minimal.

00:12:11.250 --> 00:12:13.740
So it should be very similar
to the code that your app is

00:12:13.740 --> 00:12:15.710
taking on other platforms.

00:12:16.020 --> 00:12:18.360
Now, here they are side by side.

00:12:18.360 --> 00:12:21.490
The big thing to pay attention
here is the render at the end.

00:12:21.620 --> 00:12:26.200
Quartz render in the Quartz pipeline,
the sun to the render.

00:12:26.770 --> 00:12:29.290
This should make you happy
and scary at the same time.

00:12:29.400 --> 00:12:32.260
It should make you happy because if
you had a bunch of bugs in the Quartz

00:12:32.260 --> 00:12:35.380
renderer and they were not solved,
now you can try a completely

00:12:35.420 --> 00:12:38.220
different renderer,
again, completely different code pads,

00:12:38.220 --> 00:12:40.670
and all of your bugs
might just disappear.

00:12:40.740 --> 00:12:45.430
It should make you scary if things
are just working fine in Quartz,

00:12:45.430 --> 00:12:48.840
then doing your testing on a
completely different pipeline should

00:12:48.840 --> 00:12:50.020
make you worried a little bit.

00:12:50.030 --> 00:12:53.860
However, they're both optional,
so you can choose one or the other,

00:12:53.880 --> 00:12:55.670
so you shouldn't worry that much.

00:12:55.780 --> 00:12:57.990
So she'd only make you happy.

00:12:58.480 --> 00:13:00.860
Let's look at the history a
little bit of the pipelines.

00:13:00.860 --> 00:13:05.560
And we can see that course has been
the default render in 1.3.1.4.5.0.

00:13:06.060 --> 00:13:10.500
and we actually introduced the
Santorini pipeline in Java 5.

00:13:10.500 --> 00:13:14.580
It was optional and it was a beta state,
so we didn't make a big deal about it.

00:13:14.780 --> 00:13:17.990
So we're going to focus
today actually on this.

00:13:18.970 --> 00:13:20.900
and the rest of the team.

00:13:20.900 --> 00:13:23.590
We're going to make a big switch,
and I want you to pay attention

00:13:23.670 --> 00:13:24.900
to this right now because
it's going to impact you.

00:13:24.900 --> 00:13:28.900
We're going to switch the default
rendering pipeline in Java 6.

00:13:28.900 --> 00:13:31.900
So we're going to go
from Quartz to SAN 2D.

00:13:31.900 --> 00:13:36.900
And the main reason why we did that is
for the two reasons I mentioned earlier.

00:13:37.070 --> 00:13:39.900
First,
bug for bug compatible with Windows.

00:13:40.010 --> 00:13:43.800
And second, you should be hitting none of
these impedance mismatch problems.

00:13:43.900 --> 00:13:45.880
However, we still want your feedback.

00:13:45.990 --> 00:13:48.980
This is a decision we did
for our beta and for Leopard,

00:13:48.980 --> 00:13:49.900
but we're not set on it.

00:13:49.900 --> 00:13:53.900
So please run your app with the two
pipelines and let us know what you think.

00:13:53.900 --> 00:13:56.900
If you think we're crazy of
making this render the default,

00:13:56.900 --> 00:13:57.900
let us know.

00:13:57.900 --> 00:13:59.900
We'd like to know if you're crazy.

00:14:02.740 --> 00:14:03.530
How do I make it run?

00:14:03.540 --> 00:14:05.080
How do I switch?

00:14:05.140 --> 00:14:08.340
One thing to keep in mind,
you cannot switch at runtime,

00:14:08.340 --> 00:14:09.810
meaning after your app is running.

00:14:09.930 --> 00:14:12.760
So you have to make a decision
before you run your app.

00:14:12.900 --> 00:14:19.680
So you can use this command line option,
-d apple/awt/graphics/use-quartz=true.

00:14:19.740 --> 00:14:23.880
That will make sure that your
app runs to the Quartz pipeline.

00:14:24.020 --> 00:14:27.450
Use Quartz equals false,
you run through the SAN2D pipeline.

00:14:27.580 --> 00:14:32.750
If you specify no option on 6.0 you get,
or on Java 6.0 you get SAN2D,

00:14:32.750 --> 00:14:34.260
on 5.0 you get Quartz.

00:14:34.460 --> 00:14:39.170
So this is important for you if you
want to play with the pipelines.

00:14:40.090 --> 00:14:42.390
So remember this question
that I kind of said it's very,

00:14:42.440 --> 00:14:43.160
very important.

00:14:43.370 --> 00:14:45.830
So now we're going to try
to answer it or somehow.

00:14:46.060 --> 00:14:47.920
So first I'm going to
give you a lame answer.

00:14:47.950 --> 00:14:49.120
Well, it depends.

00:14:49.160 --> 00:14:51.050
So I'm just going to wave my hands.

00:14:51.210 --> 00:14:52.770
So let's see what does it depend on.

00:14:52.780 --> 00:14:55.800
What are the factors that
might impact your decision?

00:14:56.670 --> 00:14:58.380
Number one, bugs.

00:14:58.380 --> 00:15:00.270
Like I said,
there are two different pipelines,

00:15:00.610 --> 00:15:02.650
and they have completely
different set of bugs.

00:15:02.660 --> 00:15:07.020
So you're probably going to
pick the pipeline that has the

00:15:07.030 --> 00:15:08.900
less critical bugs for you.

00:15:08.900 --> 00:15:12.920
I just kind of want to go on a tangent
here and mention two other points.

00:15:12.990 --> 00:15:13.400
Bugs.

00:15:13.400 --> 00:15:15.740
When you file bugs
from now on with Apple,

00:15:16.290 --> 00:15:19.530
please specify which pipeline
you use or whether it works

00:15:19.650 --> 00:15:20.930
on the other pipeline or not.

00:15:20.930 --> 00:15:23.050
So it will make our lives a lot easier.

00:15:23.050 --> 00:15:26.970
And also, for example,
if you have a critical bug in Quartz

00:15:27.000 --> 00:15:30.660
that's a show stopper for your app,
then you try the Santorini pipeline

00:15:30.660 --> 00:15:32.220
and things just work great.

00:15:32.350 --> 00:15:35.110
Then you kind of start using
the Santorini pipeline and

00:15:35.410 --> 00:15:36.970
continue happily with your life.

00:15:36.970 --> 00:15:39.560
What you should have done, though,
you should have filed

00:15:39.560 --> 00:15:42.850
that show stopper with us,
the Java team at Apple,

00:15:42.850 --> 00:15:45.360
because we'd like to fix all bugs.

00:15:45.380 --> 00:15:46.280
So bugs.

00:15:46.450 --> 00:15:51.450
The second thing that should
be a factor in your decision is

00:15:51.450 --> 00:15:53.050
this impedance mismatch penalty.

00:15:53.080 --> 00:15:54.100
And this is very simple.

00:15:54.100 --> 00:15:56.180
If you're hitting this
impedance mismatch penalty,

00:15:56.180 --> 00:15:59.700
or in the cases that I outlined earlier,
you're pretty much going to

00:15:59.700 --> 00:16:00.820
use the Santorini pipeline.

00:16:00.820 --> 00:16:01.910
You can trust me.

00:16:01.910 --> 00:16:05.690
Quartz is not there and there
for you if you're hitting this

00:16:05.690 --> 00:16:07.010
impedance mismatch penalty.

00:16:07.010 --> 00:16:10.100
We're going to see a little bit
more why in the performance talk.

00:16:10.980 --> 00:16:13.680
Two different renderers,
two different pixel coverages.

00:16:13.780 --> 00:16:16.910
We're going to see a little
bit of this on the next slide.

00:16:17.290 --> 00:16:20.470
and last but not least,
it's gonna be very important,

00:16:20.470 --> 00:16:23.110
two different renderers,
two different performance

00:16:23.120 --> 00:16:24.150
characteristics.

00:16:24.150 --> 00:16:25.710
We're gonna look at them too.

00:16:25.820 --> 00:16:28.590
So let's look at pixel coverage first.

00:16:29.410 --> 00:16:34.170
So I drew a circle with a
Sun 2D renderer and a quartz pipeline,

00:16:34.250 --> 00:16:35.420
or the quartz renderer.

00:16:35.440 --> 00:16:38.200
And from far away,
they might look identical to you.

00:16:38.250 --> 00:16:42.230
But if you zoom in on particular details,
you're actually going to see that

00:16:42.250 --> 00:16:44.530
they have different pixel coverages.

00:16:44.860 --> 00:16:46.160
Okay, so what does this mean for you?

00:16:46.160 --> 00:16:47.200
Which render should you use?

00:16:47.200 --> 00:16:52.140
So if you're optimizing your
app to kind of run on Windows,

00:16:52.290 --> 00:16:55.670
more likely the sound 2D render is
going to be a good choice for you.

00:16:55.760 --> 00:16:58.560
Other than that,
I cannot give you any advice.

00:16:58.560 --> 00:17:02.370
Basically, you just have to run your app
and see whichever looks better.

00:17:02.520 --> 00:17:04.740
Like if you ask me which of
this circle looks better,

00:17:04.910 --> 00:17:05.910
you know, I have no idea.

00:17:05.920 --> 00:17:11.290
I might say quartz, but other than that,
I have no idea.

00:17:11.530 --> 00:17:14.410
So they also differ in
anti-aliasing pixel coverage.

00:17:14.600 --> 00:17:16.340
Most of you should know
what anti-aliasing is,

00:17:16.360 --> 00:17:19.000
but probably a few people in
the audience might be saying,

00:17:19.030 --> 00:17:20.690
what is anti-aliasing?

00:17:20.940 --> 00:17:23.310
So I'm not going to go into
digital signal processing to

00:17:23.310 --> 00:17:26.370
kind of explain anti-aliasing,
and I'm going to make it very simple.

00:17:26.450 --> 00:17:27.760
I'm going to use one definition.

00:17:27.760 --> 00:17:31.790
I'm going to say anti-aliasing is the
effect that makes this line look jaggy

00:17:31.880 --> 00:17:33.970
or makes it look like a staircase.

00:17:34.100 --> 00:17:37.450
So there's a technique in
computer graphics that kind of

00:17:37.770 --> 00:17:41.440
draws or fills the nearby pixels
to make this line look smooth.

00:17:41.500 --> 00:17:44.340
So here's how it looks once
anti-aliasing is applied.

00:17:44.360 --> 00:17:47.360
You might not be able to
see that much on this slide,

00:17:47.480 --> 00:17:49.250
but let me see.

00:17:49.490 --> 00:17:51.470
Yeah,
you can see a little bit if you squint,

00:17:51.470 --> 00:17:54.370
the NTLS line should look
more like a solid line.

00:17:54.540 --> 00:17:58.160
But it looks really good
on the LCD monitors.

00:17:58.910 --> 00:18:02.070
So different NTLS pixel coverage, again,
due to the projector,

00:18:02.070 --> 00:18:03.400
you might not be able
to see the difference.

00:18:03.400 --> 00:18:06.060
But if you zoom in at the end pixel,
let me see.

00:18:06.060 --> 00:18:10.150
Yeah, you can kind of see that the
pixels have different intensities.

00:18:10.160 --> 00:18:12.560
These pixels also have
different intensity,

00:18:12.610 --> 00:18:14.760
and I'm sure you cannot see this pixel.

00:18:14.760 --> 00:18:18.360
But just all in all,
NTLS pixel coverage would also be

00:18:18.360 --> 00:18:20.870
different with the two pipelines.

00:18:21.780 --> 00:18:23.940
So let's summarize the pixel coverage.

00:18:23.940 --> 00:18:27.930
It was very brief, but point number one,
SAN 2D is, or should be,

00:18:28.050 --> 00:18:32.220
pixel-for-pixel compatible with Windows,
Linux, and Solaris.

00:18:32.220 --> 00:18:34.570
If you optimize your
app to work on Windows,

00:18:34.570 --> 00:18:37.240
then the SAN 2D might be
a good choice for you.

00:18:39.330 --> 00:18:41.560
Other than that,
there is no right or wrong choice.

00:18:41.650 --> 00:18:44.480
You run your app and see
whichever renderer gives you

00:18:44.520 --> 00:18:46.570
the best look or pixel coverage.

00:18:46.640 --> 00:18:47.520
And I'll give you an advice.

00:18:47.580 --> 00:18:50.480
If you work in a bigger company
where there is a UI design team,

00:18:50.700 --> 00:18:52.020
you can run it by them.

00:18:52.020 --> 00:18:55.340
In my past experience,
I found that UI designers are very good

00:18:55.500 --> 00:18:58.650
at spotting these pixel differences,
and they actually get particular

00:18:58.710 --> 00:19:00.210
about where their pixels go.

00:19:00.310 --> 00:19:02.270
So run it by them.

00:19:03.350 --> 00:19:08.670
Okay, now we're gonna switch gears and
talk for a while about performance.

00:19:09.050 --> 00:19:11.330
Like I said,
there are two different pipelines,

00:19:11.350 --> 00:19:13.510
two different performance
characteristics.

00:19:13.630 --> 00:19:16.600
So we're going to compare the
SAN2D renderer pipeline on Mac OS X.

00:19:16.600 --> 00:19:19.500
We're going to compare the Quartz
pipeline against each other.

00:19:19.520 --> 00:19:22.120
And on top of that,
we're going to compare how they

00:19:22.220 --> 00:19:25.570
perform against Windows or Windows XP.

00:19:27.510 --> 00:19:31.250
Performance challenge number one,
how do we accurately compare to Windows?

00:19:31.350 --> 00:19:32.940
Well, it used to be hard and
people would argue,

00:19:32.940 --> 00:19:34.880
is my G4 fast as your Pentium 4?

00:19:34.880 --> 00:19:37.580
And these debates would go on forever.

00:19:37.650 --> 00:19:38.640
It's very easy now.

00:19:38.810 --> 00:19:41.720
Intel boot camp, same machine, very easy.

00:19:42.080 --> 00:19:46.020
You get apples to apples comparison,
pun intended.

00:19:46.540 --> 00:19:49.630
And then,
so this is a test machine that I'm

00:19:49.940 --> 00:19:51.400
going to present the numbers from.

00:19:51.400 --> 00:19:52.340
It's just a Mac Mini.

00:19:52.340 --> 00:19:56.740
It's running Windows with
Sans version of 6,

00:19:56.740 --> 00:20:00.460
Beta 85, and same on Mac OS X, DP4, B85.

00:20:02.270 --> 00:20:04.310
Performance challenge number two,
finding a good benchmark.

00:20:04.310 --> 00:20:06.680
We have a bunch of internal
benchmarks at Apple,

00:20:06.680 --> 00:20:09.060
but they wouldn't mean anything
to you if you list the numbers.

00:20:09.080 --> 00:20:13.750
So we wanted to find a public benchmark,
and luckily, we found one.

00:20:13.780 --> 00:20:15.010
It's J2D Bench.

00:20:15.020 --> 00:20:17.300
For those of you who don't
know about J2D Bench,

00:20:17.300 --> 00:20:20.080
it's just a collection of
graphics micro-benchmarks.

00:20:20.130 --> 00:20:22.610
You can run thousands and thousands
of graphics micro-benchmarks.

00:20:22.660 --> 00:20:25.980
The cool thing about it,
it's part of the Mustang source drop.

00:20:26.040 --> 00:20:28.470
So if you download the source drop,
you can actually compile

00:20:28.470 --> 00:20:29.520
it and run it yourself.

00:20:31.020 --> 00:20:32.700
And you can get the numbers yourself.

00:20:32.980 --> 00:20:36.290
And if you download Mustang,
you can find it under source

00:20:36.290 --> 00:20:38.800
share demo Java to the J2D Bench.

00:20:38.800 --> 00:20:43.500
So try that for yourself and
play around with the numbers.

00:20:46.670 --> 00:20:48.800
There's one note on J2DBench or a caveat.

00:20:48.980 --> 00:20:53.790
It is not fair to compare on-screen
results against Windows XP.

00:20:53.800 --> 00:20:55.540
And you're probably dying to know why.

00:20:55.570 --> 00:20:57.950
And here's the answer.

00:20:58.090 --> 00:21:02.540
So I draw a line on screen and
basically J2DBench told us that the

00:21:02.790 --> 00:21:06.720
Mac OS X Quartz renderer or the pipeline,
it's 14 times faster than Windows,

00:21:06.720 --> 00:21:11.170
so 14,000%. Well,

00:21:11.380 --> 00:21:12.780
This is not true.

00:21:12.800 --> 00:21:14.500
And let me explain to you why.

00:21:14.500 --> 00:21:16.640
You kind of need to know how
they work behind the scenes

00:21:16.640 --> 00:21:18.500
to kind of know it's not true.

00:21:18.510 --> 00:21:21.020
All Windows in Mac OS X,
or when you draw on screen,

00:21:21.020 --> 00:21:22.040
they're double buffered.

00:21:22.040 --> 00:21:25.440
So you'll be drawing into this back
buffer in Mac OS X and periodically

00:21:25.640 --> 00:21:27.400
flashing the updates back on screen.

00:21:27.400 --> 00:21:29.270
Whereas in Windows,
they're single buffers,

00:21:29.270 --> 00:21:32.500
so you might be drawing
directly on screen.

00:21:32.540 --> 00:21:35.140
So in Mac OS X,
you kind of have this queuing

00:21:35.620 --> 00:21:38.620
strategy as opposed to with Windows,
you draw directly on screen.

00:21:38.620 --> 00:21:42.100
Anyway, to make a long story short,
just trust us, it's not fair to compare,

00:21:42.100 --> 00:21:46.510
even though we would love to be able
to publish these kind of numbers.

00:21:47.500 --> 00:21:49.770
So we're only going to look
at the off-screen test.

00:21:49.870 --> 00:21:52.560
What that means is it's
drawing into a buffered image.

00:21:52.580 --> 00:21:55.460
So it's kind of lame,
but that's all we can

00:21:55.750 --> 00:21:57.700
compare apples to apples.

00:21:58.400 --> 00:22:04.180
There are gazillions of micro benchmarks,
but I picked the four most common

00:22:04.270 --> 00:22:06.340
primitive drawing routines,
like drawing an image,

00:22:06.450 --> 00:22:09.550
drawing a rectangle, drawing a line,
and drawing text.

00:22:09.620 --> 00:22:11.860
So let's dive into one of them.

00:22:13.750 --> 00:22:14.870
Drawing an opaque image.

00:22:14.870 --> 00:22:18.280
So I'm going to pause and you
can take a look at the graph

00:22:18.280 --> 00:22:20.350
and I'll get a sip of water.

00:22:27.720 --> 00:22:31.370
So what this slide tells us is that
the Sanity and the Quartz render

00:22:31.430 --> 00:22:34.570
are about 25% faster than Windows.

00:22:34.900 --> 00:22:38.100
So I'm also going to kind of explain this
pattern because all of the other slides,

00:22:38.230 --> 00:22:39.680
we have at least like
10 more graphic slides,

00:22:39.680 --> 00:22:40.920
they're going to follow this pattern.

00:22:40.940 --> 00:22:43.950
We're always going to have
Windows at 100% and we're going to

00:22:43.950 --> 00:22:47.360
have the SanTudino Quartz render
numbers relative to Windows.

00:22:47.360 --> 00:22:51.030
So can we make this claim that
drawing an opaque image is

00:22:51.040 --> 00:22:53.330
faster in Mac OS X than Windows?

00:22:53.340 --> 00:22:54.740
Well, not quite.

00:22:54.820 --> 00:22:55.940
It's too vague of a statement.

00:22:55.940 --> 00:22:58.380
And the reason why it's vague,
we have to look at the

00:22:58.380 --> 00:23:00.000
details or the parameters.

00:23:00.750 --> 00:23:03.680
So all of the slides are going
to have this little line where

00:23:03.680 --> 00:23:05.780
you can look at the details
or the parameters of the call.

00:23:05.820 --> 00:23:07.670
So the source is an RGB image.

00:23:07.680 --> 00:23:10.880
We're drawing an RGB image onto
a destination compatible opaque.

00:23:10.920 --> 00:23:13.900
And the size of the image is 250 by 250.

00:23:13.900 --> 00:23:16.450
And it's just going
through identity transfer.

00:23:16.760 --> 00:23:21.140
This is really important because varying
any of these parameters might completely

00:23:21.200 --> 00:23:26.280
change your results of the benchmark
and also the results of your app.

00:23:26.360 --> 00:23:31.270
So we're going to be very careful
when we actually specify this result.

00:23:31.350 --> 00:23:34.840
The reason why we have to be careful,
the next slide tells us why.

00:23:34.840 --> 00:23:38.080
So this is drawing an opaque image,
same as before.

00:23:38.080 --> 00:23:40.040
The only thing that's
different is the size,

00:23:40.040 --> 00:23:41.320
so it's 20 by 20.

00:23:41.320 --> 00:23:42.940
And you can look at it,
the characteristics are

00:23:42.940 --> 00:23:43.860
completely different.

00:23:43.930 --> 00:23:47.100
I mean, Quartz is now three times
slower than Windows.

00:23:47.120 --> 00:23:51.420
So just to summarize these two slides,
the Quartz pipeline is kind

00:23:51.420 --> 00:23:55.420
of good at drawing big images,
but not as good as smaller images.

00:23:55.420 --> 00:23:58.880
And we can see the Sun 2D render kind
of trails a little bit behind Windows.

00:24:00.640 --> 00:24:02.970
So now we're going to look at
drawing a translucent image.

00:24:03.160 --> 00:24:05.260
Same as before,
the only thing that's different

00:24:05.380 --> 00:24:07.840
is instead of an RGB image,
we're going to do an ARGB image,

00:24:07.840 --> 00:24:10.190
and there's going to be
some blending involved.

00:24:11.280 --> 00:24:13.990
So this slide looks good.

00:24:14.120 --> 00:24:17.020
So drawing a big image,
Quartz actually is about three

00:24:17.100 --> 00:24:18.300
times faster than Windows.

00:24:18.310 --> 00:24:22.010
The sound of the renderer
kind of performs like Windows.

00:24:22.650 --> 00:24:24.760
I kind of happen to know
why this is happening too,

00:24:24.760 --> 00:24:26.250
so I'll tell you.

00:24:26.410 --> 00:24:30.600
The Quartz render is actually
optimized for the CPUs that we ship.

00:24:30.660 --> 00:24:33.480
So a lot of the blending
code is being done,

00:24:33.480 --> 00:24:34.120
it's vectorized.

00:24:34.120 --> 00:24:38.260
So on G5, there's some Altivec code,
and on the Intel processor,

00:24:38.260 --> 00:24:39.120
there is SSE code.

00:24:39.150 --> 00:24:41.810
Versus the Sanity render,
it's just a C render that's

00:24:41.870 --> 00:24:43.140
not optimized for the CPU.

00:24:43.300 --> 00:24:45.460
So Quartz looks really
good if we actually,

00:24:45.540 --> 00:24:48.600
if you have a bunch of those images,
very likely that Quartz is gonna

00:24:48.600 --> 00:24:50.180
be three times faster than Windows.

00:24:51.090 --> 00:24:54.190
Now, if you have small images,
we kind of knew that Quartz

00:24:54.280 --> 00:24:57.270
wasn't good at small images,
but their blending algorithm is

00:24:57.270 --> 00:24:59.700
so good that they still kind of
come a little bit ahead of Windows.

00:24:59.720 --> 00:25:01.620
But we can call this a tie.

00:25:01.660 --> 00:25:05.280
And the Sanity just lags a
little bit behind Windows.

00:25:07.160 --> 00:25:10.980
So we're gonna kind of jump through the,
we're gonna skip the image part and

00:25:10.980 --> 00:25:13.120
we're gonna go into drawing primitives,
fill rect.

00:25:13.140 --> 00:25:15.660
And I'll kind of tell
you what to expect now.

00:25:15.710 --> 00:25:19.740
There's gonna be a big difference
whether we draw aliased or anti-aliased.

00:25:19.760 --> 00:25:22.260
And we kind of know now what's
aliasing and anti-aliasing.

00:25:22.290 --> 00:25:26.290
So keep that in mind, aliased,
anti-aliased, big difference.

00:25:26.870 --> 00:25:28.030
During a fill rect.

00:25:28.210 --> 00:25:31.970
So during a fill rect,
it's about three times slower

00:25:32.130 --> 00:25:33.270
on Mac OS X than Windows.

00:25:33.310 --> 00:25:37.530
And this is the key word here,
it's alias.

00:25:37.530 --> 00:25:42.610
Because once we switch to anti-aliased,
Quartz is about four

00:25:42.650 --> 00:25:45.160
times faster than Windows.

00:25:45.160 --> 00:25:47.610
And you're wondering why,
and I kind of happen to

00:25:47.680 --> 00:25:49.200
know the answer to this too.

00:25:49.200 --> 00:25:53.520
Everything in Mac OS X is drawn
anti-aliased because we like

00:25:53.580 --> 00:25:55.900
our interfaces to be pretty.

00:25:56.900 --> 00:26:06.120
And the Quartz team has spent a lot of
time optimizing the anti-aliasing path.

00:26:06.790 --> 00:26:09.540
There it is, NTLES Fasten Mac OS X.

00:26:09.570 --> 00:26:12.010
And you can see the sound to the
render is the same code as Windows,

00:26:12.010 --> 00:26:15.010
so it kind of performs
around that ballpark.

00:26:15.950 --> 00:26:18.110
Drawing a line.

00:26:18.170 --> 00:26:27.970
So you're going to see the exact same
thing that we saw with filling a rack.

00:26:27.970 --> 00:26:30.640
And this is kind of painful.

00:26:30.640 --> 00:26:30.640
Drawing an alias line,
Quartz is about 10 times

00:26:30.640 --> 00:26:30.640
slower than Windows.

00:26:30.640 --> 00:26:30.640
Really, really bad.

00:26:30.640 --> 00:26:30.640
But

00:26:30.630 --> 00:26:33.210
If you go to the NTLS line,
it's about three times

00:26:33.210 --> 00:26:34.550
faster than Windows.

00:26:34.590 --> 00:26:37.930
The sound of the render on the other
hand is the same code as Windows,

00:26:37.930 --> 00:26:41.350
or similar code as Windows,
performs around the same.

00:26:42.100 --> 00:26:45.470
So I'm gonna stop here and kind
of summarize those two slides,

00:26:45.550 --> 00:26:47.160
rectangle and lines.

00:26:47.190 --> 00:26:49.010
Anti-aliasing chords, really,
really good.

00:26:49.230 --> 00:26:51.480
Aliasing chords, bad.

00:26:51.610 --> 00:26:53.740
So drawstring,
we're gonna see the exact same thing.

00:26:53.740 --> 00:26:56.590
So I'm just gonna breeze
through this slide.

00:26:56.970 --> 00:26:59.580
Alias string,
of course about three times slower,

00:26:59.600 --> 00:27:01.340
not so good.

00:27:01.400 --> 00:27:04.240
And the Alias string,
it's a little bit faster, better.

00:27:04.270 --> 00:27:06.940
So we see the exact same pattern.

00:27:08.070 --> 00:27:10.100
So first I'm going to apologize
for kind of breezing through

00:27:10.100 --> 00:27:12.720
those micro benchmarks.

00:27:12.780 --> 00:27:16.120
And I kind of did it on purpose because
I didn't want us to focus on these

00:27:16.120 --> 00:27:17.600
little micro benchmarks and parameters.

00:27:17.630 --> 00:27:22.810
I want us to have the big picture of
how the two renders perform against

00:27:22.970 --> 00:27:24.680
each other in this big picture.

00:27:24.770 --> 00:27:29.350
So what I ended up doing is I took all
the tests and I put them on one graph.

00:27:29.500 --> 00:27:31.590
So now they're flipped from
horizontal to vertical.

00:27:31.760 --> 00:27:34.160
They're stacked next to each other.

00:27:34.240 --> 00:27:35.920
This graph didn't tell me much.

00:27:36.010 --> 00:27:38.850
So what I ended up doing,
I ended up doing a plot chart

00:27:38.930 --> 00:27:41.200
and I connected the actual lines.

00:27:41.410 --> 00:27:43.960
And for those of you
who are chart purists,

00:27:43.990 --> 00:27:46.800
yes, the line between the two
points has no meaning.

00:27:46.840 --> 00:27:48.870
However, I like this slide a lot.

00:27:48.980 --> 00:27:54.510
So if you're actually kind
of falling asleep now,

00:27:54.580 --> 00:27:58.150
this is the most important
slide of the performance part.

00:27:58.300 --> 00:27:59.720
So let me explain what this means.

00:27:59.720 --> 00:28:02.840
So this is the time to pay attention.

00:28:03.040 --> 00:28:05.920
So we have Windows at 100%.

00:28:06.370 --> 00:28:10.240
And we're going to see the
SAN 2D renderer on Mac OS X kind

00:28:10.240 --> 00:28:12.540
of following Windows.

00:28:12.660 --> 00:28:14.260
Again, it's the same code.

00:28:14.270 --> 00:28:17.840
And sometimes it performs faster,
sometimes slower, sometimes the same.

00:28:17.980 --> 00:28:21.440
The reason why we're seeing-- and we're
currently investing in investigating

00:28:21.450 --> 00:28:24.460
this-- but we believe it's basically
the fact that there are different

00:28:24.510 --> 00:28:26.290
compilers produce different code.

00:28:26.380 --> 00:28:30.860
So for example, Windows is compiled with
Visual Studio and Mac OS X with GCC.

00:28:30.920 --> 00:28:32.660
But we're investigating
this to prove this.

00:28:32.680 --> 00:28:34.860
But you can see that the
actual curve is fairly similar.

00:28:34.860 --> 00:28:37.720
So it kind of gives you the
sense it's the same render.

00:28:37.820 --> 00:28:39.910
Quartz, completely different story.

00:28:39.930 --> 00:28:41.580
It's like a roller coaster ride.

00:28:41.620 --> 00:28:44.710
So sometimes it does really, really good,
or sometimes it does really, really,

00:28:44.810 --> 00:28:45.360
really bad.

00:28:45.400 --> 00:28:48.930
So the moral of this story is that

00:28:49.520 --> 00:28:53.410
If you're using anti-alias drawing
or you're using big images or you

00:28:53.410 --> 00:28:56.780
have lots of translucent images,
then Quartz will definitely give

00:28:56.780 --> 00:29:01.000
you a much better performance than
you might be getting on Windows.

00:29:01.160 --> 00:29:04.850
Now, on the other hand,
if you're drawing in alias graphics

00:29:04.940 --> 00:29:08.020
and you have a bunch of small images,
then Quartz might not

00:29:08.190 --> 00:29:10.130
be the renderer for you.

00:29:12.270 --> 00:29:14.880
OK, now I've been kind of harping
on this impedance mismatch

00:29:14.880 --> 00:29:16.440
and probably bored about it.

00:29:16.470 --> 00:29:20.250
But I said, let me kind of prove it
to you how bad it is.

00:29:20.380 --> 00:29:22.950
So remember that call
raster.getDataBuffer?

00:29:22.960 --> 00:29:26.160
You can say image.getRaster,
raster.getDataBuffer.

00:29:26.180 --> 00:29:29.790
And I'm kind of saying you
get really poor performance.

00:29:30.260 --> 00:29:32.660
And I rerun all the benchmarks.

00:29:32.780 --> 00:29:34.970
So on all the images,
I called raster.getDataBuffer

00:29:34.990 --> 00:29:36.800
before I run the benchmarks.

00:29:36.810 --> 00:29:39.140
And here are the results.

00:29:39.190 --> 00:29:40.580
Should be staggering, I think.

00:29:40.750 --> 00:29:44.400
So all the course benchmarks go
less than 1%. So they're about

00:29:44.480 --> 00:29:46.260
100 times slower than Windows.

00:29:46.320 --> 00:29:49.060
So when I say the
experience is suboptimal,

00:29:49.080 --> 00:29:51.090
it's actually really bad.

00:29:51.450 --> 00:29:56.560
So, actually as you saw, Java,
the graphics part of Mac OS X,

00:29:56.560 --> 00:29:58.070
it's not that bad with the course render.

00:29:58.080 --> 00:29:59.360
It's actually faster than Windows.

00:29:59.410 --> 00:30:02.520
But sometimes we get a bad
reputation because when you hit this

00:30:02.700 --> 00:30:05.860
weird case of impedance mismatch,
our performance is so bad that people

00:30:05.880 --> 00:30:07.260
just throw their hands in the air.

00:30:07.670 --> 00:30:10.020
Well, not anymore.

00:30:10.210 --> 00:30:12.300
We have a completely
different renderer now.

00:30:12.300 --> 00:30:15.530
It's the Mac OS X San2D renderer.

00:30:15.530 --> 00:30:23.130
And it's completely unaffected by this
call to get pixel or set pixel or so on.

00:30:23.200 --> 00:30:27.730
So if you're having one of these cases,
then probably San2D renderer clearly,

00:30:27.750 --> 00:30:32.550
you get 100% improvement of your,
or 100 times improvement

00:30:32.780 --> 00:30:34.730
of your performance.

00:30:36.150 --> 00:30:37.330
OK, let's summarize this.

00:30:37.340 --> 00:30:39.780
This is one of the questions
I wanted you to answer.

00:30:39.780 --> 00:30:42.580
What is the fastest pipeline for my app?

00:30:42.610 --> 00:30:43.820
Same lame answer.

00:30:43.830 --> 00:30:45.280
It depends.

00:30:45.290 --> 00:30:48.280
And here is basically summarized
what I've been kind of going

00:30:48.590 --> 00:30:50.520
through in the previous slides.

00:30:50.570 --> 00:30:52.480
Quartz,
really good at anti-alias drawing,

00:30:52.480 --> 00:30:55.340
big image fills, translucent images.

00:30:55.340 --> 00:30:58.340
Not so good,
or where the has the advantage,

00:30:58.340 --> 00:31:02.680
it's alias primitive, small images,
direct pixel access,

00:31:02.680 --> 00:31:05.130
or when you use one of those
unfriendly image types.

00:31:05.200 --> 00:31:08.320
So keep this in mind,
depending on whichever,

00:31:08.360 --> 00:31:09.640
whatever your app is doing.

00:31:09.640 --> 00:31:12.300
Like I said, I mean,
forget 60% improvement.

00:31:12.390 --> 00:31:16.850
You can get like 100 times improvement
if you pick the right renderer.

00:31:17.060 --> 00:31:21.260
So keep this in mind, or play around,
and see how your app performs.

00:31:21.260 --> 00:31:23.450
At least we give you a choice now.

00:31:24.960 --> 00:31:27.360
This is the same slide as before,
the slide that I liked a lot,

00:31:27.360 --> 00:31:28.900
and it's the exact same slide.

00:31:28.950 --> 00:31:31.100
This is where we are today.

00:31:31.270 --> 00:31:34.540
So I want to talk maybe a little
bit about where we want to be.

00:31:34.580 --> 00:31:37.260
This is not something we're working on,
but we kind of said,

00:31:37.290 --> 00:31:39.350
what if we take the best of
the Quartz renderer and the

00:31:39.350 --> 00:31:40.380
best of the Sound2D renderer?

00:31:40.400 --> 00:31:43.550
You're basically going to get
a graph like this green line,

00:31:43.550 --> 00:31:46.500
and basically most of the
time you outperform Windows,

00:31:46.560 --> 00:31:49.290
and in some cases you
perform as well as Windows.

00:31:49.300 --> 00:31:51.060
So this is what we'll be shooting for.

00:31:51.060 --> 00:31:52.290
I don't know if it's possible.

00:31:52.290 --> 00:31:53.360
I'll be honest with you.

00:31:53.360 --> 00:31:55.290
I don't know if we'll be able to
mix and match the two renders.

00:31:55.840 --> 00:31:58.870
But if we can, you'll get really,
really good performance and pretty

00:31:58.870 --> 00:32:02.130
much never have to pay this impedance
mismatch penalty and get all the

00:32:02.300 --> 00:32:05.940
benefit of Quartz of anti-aliased
drawing or blending and so on and so on.

00:32:06.000 --> 00:32:08.890
Again, this is not something
that we have in store,

00:32:08.890 --> 00:32:11.140
but something that we might explore.

00:32:13.790 --> 00:32:18.620
So we talked about two renders,
Sun 2D and the Quartz renderer.

00:32:18.640 --> 00:32:21.880
And if that wasn't enough for you,
we're going to confuse you

00:32:21.880 --> 00:32:25.220
even more with talking about a
completely different architecture,

00:32:25.240 --> 00:32:27.500
and that is OpenGL.

00:32:27.500 --> 00:32:29.860
And more particular, OpenGL and Java.

00:32:30.130 --> 00:32:32.410
How do they talk to each other?

00:32:32.580 --> 00:32:35.220
But before we talk about it,
we should probably hear what

00:32:35.250 --> 00:32:36.890
Sun Microsystems has been up to.

00:32:37.120 --> 00:32:39.260
So let's hear their story first.

00:32:39.280 --> 00:32:42.590
And we actually invited a special
guest to tell us that story,

00:32:42.680 --> 00:32:45.100
and that is Chris Campbell from
Sun Microsystems.

00:32:45.100 --> 00:32:48.190
He is one of the engineers who
works on OpenGL and Java at Sun.

00:32:48.470 --> 00:32:50.940
So everybody, welcome Chris.

00:32:57.170 --> 00:32:58.960
Thanks, Viktor.

00:32:58.990 --> 00:33:00.530
As Viktor said,
my name is Chris Campbell.

00:33:00.700 --> 00:33:04.220
I'm an engineer on the
Java 2D team at Sun.

00:33:04.220 --> 00:33:08.120
And primarily,
I'm responsible for the OpenGL-based

00:33:08.330 --> 00:33:11.750
Java 2D pipeline that I'll
tell you more about today.

00:33:12.190 --> 00:33:15.800
Now, OpenGL has been playing
an increasing role in the

00:33:15.870 --> 00:33:21.230
Java graphics story over the past,
say, two or three years.

00:33:21.420 --> 00:33:23.880
It's being used-- for those
of you who don't know OpenGL,

00:33:23.880 --> 00:33:29.160
it's basically a cross-platform
API that allows you to get really

00:33:29.160 --> 00:33:31.600
close to the graphics hardware.

00:33:31.760 --> 00:33:33.900
In many cases,
there's one-to-one mappings between

00:33:33.910 --> 00:33:35.980
what modern hardware can provide you.

00:33:36.040 --> 00:33:38.290
So big benefit, obviously,
is performance.

00:33:38.440 --> 00:33:45.230
So the OpenGL-based Java 2D pipeline
that I'm responsible for was

00:33:45.390 --> 00:33:50.320
first introduced in JDK 5,
or in Sun's JDK 5 release,

00:33:50.340 --> 00:33:51.690
a couple years back.

00:33:51.950 --> 00:33:57.290
Now, like I said,
the obvious reason for implementing

00:33:57.590 --> 00:34:01.140
this OpenGL pipeline was performance.

00:34:01.140 --> 00:34:06.260
The picture you can keep in your head
would look similar to what Viktor showed

00:34:06.260 --> 00:34:11.580
you earlier with Apple's Quartz
renderer and their Sun 2D pipeline.

00:34:11.620 --> 00:34:15.190
Well, the OpenGL-based Java 2D pipeline
is just another pipeline.

00:34:15.200 --> 00:34:17.240
It's an implementation detail.

00:34:17.270 --> 00:34:22.390
This means that you don't need
to change your existing Swing or

00:34:22.400 --> 00:34:25.030
Java 2D application in any way.

00:34:25.270 --> 00:34:26.850
It's behind the scenes.

00:34:26.960 --> 00:34:32.220
We're basically taking those
high-level Java 2D API calls and

00:34:32.220 --> 00:34:37.730
translating them behind the scenes
into low-level OpenGL commands.

00:34:38.000 --> 00:37:37.300
[Transcript missing]

00:37:37.500 --> 00:37:40.730
In the new architecture,
we're able to avoid a lot of the

00:37:40.730 --> 00:37:42.680
JNI overhead that we had previously.

00:37:42.680 --> 00:37:48.210
So this results in faster,
especially for small primitives,

00:37:48.220 --> 00:37:51.960
small primitives like fill rec,
draw line, those can render a lot faster.

00:37:52.660 --> 00:37:56.090
The other thing is in
the new architecture,

00:37:56.100 --> 00:37:59.740
we have the ability to batch
up similar primitives and send

00:37:59.740 --> 00:38:02.110
them down to OpenGL in one pass.

00:38:02.120 --> 00:38:06.920
And some of you may know that graphics
hardware likes to work on hundreds

00:38:06.920 --> 00:38:10.900
of thousands of small triangles
and the like at the same time.

00:38:10.970 --> 00:38:17.200
So this is another area that
we get a big bang in JDK 6.

00:38:17.540 --> 00:38:20.630
So stability's improved.

00:38:20.760 --> 00:38:22.180
Performance is greatly improved.

00:38:22.310 --> 00:38:26.680
Along the way, we've been doing some bug
fixing in the pipeline itself,

00:38:26.770 --> 00:38:30.110
so quality is much better
than it was in JDK5.

00:38:30.120 --> 00:38:34.130
Interestingly,
we've also worked quite closely

00:38:34.630 --> 00:38:40.260
with driver teams from ATI,
NVIDIA, Sun, Intel, and others to really

00:38:40.260 --> 00:38:42.580
improve their drivers.

00:38:43.510 --> 00:38:47.500
Every once in a while, your application,
if you turned on the OpenGL pipeline,

00:38:47.530 --> 00:38:52.470
you might trip across a number of
rendering artifacts and the like,

00:38:52.510 --> 00:38:53.180
or even crashes.

00:38:53.180 --> 00:38:57.280
Sometimes there's no way we
can really work around those,

00:38:57.280 --> 00:39:00.170
and the solution was to work
closely with those teams,

00:39:00.170 --> 00:39:03.840
kind of raise the level of
quality across the board.

00:39:03.840 --> 00:39:06.740
So I'm happy to say that
in the past year or so,

00:39:06.740 --> 00:39:10.470
the driver quality's really
improved with respect to the

00:39:10.470 --> 00:39:13.020
OpenGL-based Java 2D pipeline.

00:39:15.180 --> 00:39:18.500
Now,
that's the OGL pipeline in a nutshell.

00:39:18.500 --> 00:39:22.240
I could probably talk for
weeks on end about it,

00:39:22.360 --> 00:39:23.400
since that's what I work on.

00:39:23.400 --> 00:39:25.640
But I'll spare you the pain.

00:39:25.640 --> 00:39:30.660
And I'll switch gears now and talk
about another API called Joggle.

00:39:31.680 --> 00:39:34.320
Now, this stands for the
Java Bindings for OpenGL.

00:39:34.320 --> 00:39:38.590
It's a completely separate API that's
been going through the JSR process

00:39:38.600 --> 00:39:40.380
for the past couple years.

00:39:40.380 --> 00:39:46.930
And if any of you have ever
done any graphics programming

00:39:46.930 --> 00:39:50.640
in OpenGL in the C language,
then Joggle's API should

00:39:50.640 --> 00:39:52.750
look quite familiar to you.

00:39:52.760 --> 00:39:57.920
And that's because it's essentially
just a thin wrapper around the

00:39:58.460 --> 00:40:01.240
existing C-based OpenGL libraries.

00:40:02.840 --> 00:40:07.000
But Joggle's API also offers a number
of high-level classes that allow

00:40:07.000 --> 00:40:11.080
you to integrate that 3D rendering
into your existing Java application,

00:40:11.580 --> 00:40:14.130
whether it's an AWT app
or even a Swing app.

00:40:14.220 --> 00:40:18.700
So I think one of the coolest
things that is in Joggle's

00:40:18.760 --> 00:40:22.040
API is something called GLJPanel.

00:40:22.820 --> 00:40:28.580
This is a hardware-accelerated
implementation of the

00:40:28.580 --> 00:40:31.550
Swing JPanel component,
except that it allows you

00:40:31.550 --> 00:40:35.000
to do 3D rendering directly
into your Swing application.

00:40:35.000 --> 00:40:39.050
Probably the easiest way for
me to explain this is to switch

00:40:39.050 --> 00:40:41.050
over to the demo machine.

00:40:45.770 --> 00:40:51.660
And what I'm going to show you now is one
of the demos that ships with the-- or is

00:40:51.660 --> 00:40:54.040
available from Joggle's demos website.

00:40:54.110 --> 00:40:56.570
It's called Jrefract.

00:40:57.580 --> 00:41:00.800
Now, what I'm bringing up here is a demo.

00:41:01.020 --> 00:41:03.990
At first, it looks like a very
typical swing application.

00:41:04.120 --> 00:41:09.580
This is running on Apple's latest
Mustang developer preview bits.

00:41:09.610 --> 00:41:12.780
So it's kind of the latest and greatest.

00:41:12.820 --> 00:41:16.130
So pretty boring at first,
but I'm going to open up

00:41:16.140 --> 00:41:18.760
one of the 3D demos here.

00:41:18.820 --> 00:41:25.350
So this is the standard OpenGL Gears
demo that you may have seen before.

00:41:25.380 --> 00:41:29.140
And you might notice there's
some artifacts in here.

00:41:29.140 --> 00:41:32.940
Like I said,
it's Mustang's early access release,

00:41:33.180 --> 00:41:38.290
so there's still more work
to be done on the Apple side.

00:41:38.950 --> 00:41:41.400
What you can see here is that
performance is reasonable.

00:41:41.460 --> 00:41:44.440
The interesting thing is that
I can drag other internal frames,

00:41:44.440 --> 00:41:45.780
for example, over.

00:41:45.810 --> 00:41:48.500
And you'll notice that there's
no issues with lightweight,

00:41:48.500 --> 00:41:51.630
heavyweight mixing that you may
have heard about in the past.

00:41:51.640 --> 00:41:58.040
There's no issues with the Z order of the
internal frames and that sort of thing.

00:41:58.050 --> 00:42:01.820
So everything's rendering correctly.

00:42:02.010 --> 00:42:04.460
Performance looks
reasonable at this size,

00:42:04.530 --> 00:42:09.340
but you'll see that if I make
the internal frame a lot larger,

00:42:09.340 --> 00:42:15.130
the frame rate really begins to dip
or down below 15 frames per second.

00:42:15.280 --> 00:42:19.310
Still relatively usable,
but definitely not ideal.

00:42:19.470 --> 00:42:27.240
I should mention that prior to Mustang,
at least, the GLJ panel implementation

00:42:27.270 --> 00:42:30.000
uses kind of a two-step process.

00:42:30.050 --> 00:42:35.280
It'll render the 3D rendering into
a separate off-screen surface.

00:42:35.280 --> 00:42:40.460
And then it has to go through this very
slow path of pulling the pixels back and

00:42:40.490 --> 00:42:43.540
getting them into the swing back buffer.

00:42:43.690 --> 00:42:46.460
So that second step is the one
that really kills performance.

00:42:46.480 --> 00:42:49.790
And that's the effect
that you're seeing here.

00:42:50.250 --> 00:42:56.430
In the Mustang timeframe,
we worked closely with Ken Russell from

00:42:56.430 --> 00:42:58.860
the Joggle team at Sun.

00:42:58.860 --> 00:43:03.480
And he came up with some pretty
novel techniques that allow us to

00:43:03.600 --> 00:43:08.800
basically make the OpenGL-based
Java 2D pipeline interoperate with

00:43:08.930 --> 00:43:12.520
Joggle's GLJPanel implementation.

00:43:12.520 --> 00:43:18.480
So I can demonstrate this by
bringing up the same demo.

00:43:19.520 --> 00:43:22.550
The only difference here is
that on the command line,

00:43:22.550 --> 00:43:26.760
we're passing the
Sun Java 2D OpenGL flag,

00:43:26.760 --> 00:43:31.720
setting it to true,
which turns on the OpenGL-based pipeline.

00:43:31.720 --> 00:43:34.860
Now, the first thing you'll
notice here is that,

00:43:34.860 --> 00:43:36.770
well, this time it came up.

00:43:36.840 --> 00:43:38.980
Last time it came up in
the Aqua look and feel.

00:43:38.980 --> 00:43:41.540
Here it's coming up using Metal.

00:43:41.540 --> 00:43:44.060
Viktor will tell you a little
bit more about that later.

00:43:44.060 --> 00:43:48.310
There's some bugs to be worked out with
respect to the Aqua look and feel first.

00:43:49.250 --> 00:43:52.950
But as you can see,
the demo looks basically the same.

00:43:52.960 --> 00:43:57.040
But behind the scenes,
since the OpenGL pipeline was turned on,

00:43:57.040 --> 00:44:01.060
we're using OpenGL behind the
scenes to render even the most

00:44:01.070 --> 00:44:04.390
basic swing elements here,
like the text and the

00:44:04.550 --> 00:44:05.850
internal frame itself.

00:44:05.880 --> 00:44:11.730
But the real power is seen if
we open up the Gears demo again.

00:44:11.830 --> 00:44:14.220
You'll see that the frame
rate has jumped considerably.

00:44:14.220 --> 00:44:18.140
I think it's about 50%
faster than it was before.

00:44:19.060 --> 00:44:22.000
You'll see that we still
have the same artifacts.

00:44:22.020 --> 00:44:22.880
That'll be fixed.

00:44:22.960 --> 00:44:23.800
But...

00:44:26.080 --> 00:44:30.490
If I increase the size
of the internal frame,

00:44:30.490 --> 00:44:37.510
I think performance goes up, again,
about at least 50%, 60% faster.

00:44:37.640 --> 00:44:38.940
This is still early.

00:44:39.000 --> 00:44:44.180
On our own platforms, for example,
on Linux, Solaris, and Windows,

00:44:44.180 --> 00:44:48.050
we see improvements of this case up to 3,
4x.

00:44:48.240 --> 00:44:53.450
So this is just a taste of what
Mustang can offer in terms of

00:44:53.450 --> 00:44:55.780
the mixing of 2D and 3D elements.

00:44:55.980 --> 00:44:58.930
I think the really powerful thing
here for developers is that it

00:44:58.930 --> 00:45:03.950
shows that you no longer have
to think in terms of creating,

00:45:03.950 --> 00:45:09.200
say, an OpenGL application or a
Swing application or a Java 2D.

00:45:09.200 --> 00:45:10.940
It's not an either/or situation anymore.

00:45:10.960 --> 00:45:15.840
It's really possible now
to integrate 3D rendering.

00:45:15.860 --> 00:45:25.920
Even more complex 3D demos will run
together inside the same window.

00:45:25.920 --> 00:45:28.440
For example,
I can open up this refraction

00:45:28.610 --> 00:45:30.170
demo behind the scenes.

00:45:30.380 --> 00:45:33.000
You'll see that, again,
there's no issues with mixing.

00:45:33.090 --> 00:45:36.810
The Z order is respected of the frames.

00:45:37.050 --> 00:45:41.340
Going back to this demo here,
I can show you the background is rendered

00:45:41.340 --> 00:45:44.190
with a Java 2D gradient back here.

00:45:44.200 --> 00:45:46.360
There's a 3D scene
rendered on top of that.

00:45:46.360 --> 00:45:51.560
There's some more heads-up display
on the front with images and text.

00:45:51.730 --> 00:45:53.840
So the nice thing here is
that it allows for mixing,

00:45:53.850 --> 00:45:55.880
even in the same component
or the same window.

00:45:55.880 --> 00:45:59.090
You can mix 2D and 3D elements.

00:45:59.190 --> 00:46:06.750
If anyone was at the Eryth demo that was
shown at the Java session on Tuesday,

00:46:07.020 --> 00:46:07.920
you saw this in action.

00:46:08.000 --> 00:46:11.480
You saw that you can actually mix
2D and 3D in the same application,

00:46:11.480 --> 00:46:13.770
and it's seamless to the user.

00:46:14.000 --> 00:46:20.200
[Transcript missing]

00:46:21.060 --> 00:46:27.780
Greatly improved performance,
improved stability, much better quality,

00:46:28.040 --> 00:46:30.600
opens up the doors for
this 2D and 3D mixing.

00:46:30.630 --> 00:46:33.720
And I think the coolest thing for this
audience is that it's not just for

00:46:33.830 --> 00:46:35.720
the platform's Sun supports anymore.

00:46:35.750 --> 00:46:41.350
And it's coming to Mac OS X very shortly,
just like I showed you.

00:46:41.350 --> 00:46:46.080
So I'll hand it back to Viktor,
and he'll tell you more about the work

00:46:46.080 --> 00:46:46.080
that Apple's team is doing in this area.

00:46:50.710 --> 00:46:51.700
Thanks, Chris.

00:46:51.700 --> 00:46:55.060
Yeah, OpenGL Java running on a Mac.

00:46:55.060 --> 00:46:55.730
Exciting.

00:46:57.490 --> 00:47:10.000
and Chris Campbell, Rick Altherr,
and Chris Campbell, Rick Altherr,

00:47:10.000 --> 00:47:10.000
and Chris Campbell,

00:47:11.480 --> 00:47:15.710
So I'm going to talk to you about
the OpenGL pipeline on a Mac.

00:47:15.860 --> 00:47:21.680
We just announced this in DP5,
which went out on Tuesday, I believe.

00:47:21.680 --> 00:47:26.960
And some had this thing since Java 5,
but we just got it implemented

00:47:27.090 --> 00:47:29.200
and it's running in Java 6.

00:47:29.200 --> 00:47:30.740
And currently, there's a beta sticker.

00:47:30.740 --> 00:47:33.920
And I'm going to talk about
what that beta sticker means.

00:47:35.120 --> 00:47:38.480
First, all of this graph should
be familiar with you.

00:47:38.530 --> 00:47:41.110
The only thing that I kind of want
you to pay attention to right now

00:47:41.340 --> 00:47:43.520
is-- so we have the Java to the API.

00:47:43.550 --> 00:47:46.420
And at the end,
we have the OpenGL rendering engine.

00:47:46.590 --> 00:47:48.080
In the middle,
we have this thing that we didn't

00:47:48.080 --> 00:47:52.290
have in the previous slides,
which is Sun Java to the OpenGL layer.

00:47:52.480 --> 00:47:55.620
This is actually the code that
Chris has been writing at Sun.

00:47:55.650 --> 00:47:57.840
And again, it's blue,
so it's written by Sun.

00:47:57.900 --> 00:47:59.880
And we ported it to Mac OS X.

00:48:00.140 --> 00:48:02.880
And we had to write a very,
very thin layer of Mac glue

00:48:02.950 --> 00:48:06.320
code to connect that to
our OpenGL implementation.

00:48:06.350 --> 00:48:08.150
So this is very similar to
the Sun to the renderer.

00:48:08.190 --> 00:48:11.860
We're leveraging most of the
work that Sun is working on.

00:48:11.880 --> 00:48:17.340
And we're just writing a thin layer
that sits on top of our OpenGL drivers.

00:48:17.440 --> 00:48:21.120
So this is exciting,
because you'll get the same code

00:48:21.160 --> 00:48:24.590
running fairly well on all platforms.

00:48:25.900 --> 00:48:26.860
OpenGL Pipeline.

00:48:26.880 --> 00:48:28.240
There are many pros and cons.

00:48:28.290 --> 00:48:29.900
I'm going to focus on three of them.

00:48:29.910 --> 00:48:34.340
And the number one advantage,
as Chris mentioned, it's speed.

00:48:34.370 --> 00:48:36.940
And everything should
be running in hardware.

00:48:36.970 --> 00:48:39.290
Therefore, it should be much faster.

00:48:39.600 --> 00:48:44.510
Now, disadvantages is just because
it's running in hardware,

00:48:44.620 --> 00:48:45.760
your app will be hardware dependent.

00:48:45.760 --> 00:48:47.280
So this is very important now,
pay attention.

00:48:47.280 --> 00:48:52.180
If you have the same app, same code,
running with the same Java release,

00:48:52.180 --> 00:48:56.100
with the same operating system, again,
the same Java app might behave

00:48:56.340 --> 00:48:59.920
differently on two different
machines with two different cards.

00:48:59.950 --> 00:49:02.140
So this is kind of something
to pay attention to.

00:49:02.480 --> 00:49:06.100
And if you're going to ship your
Java app with the OpenGL pipeline,

00:49:06.110 --> 00:49:10.220
you better have a pretty good test suite
where you test on every single graphics

00:49:10.620 --> 00:49:12.500
card that you're going to ship on.

00:49:12.560 --> 00:49:16.880
So another disadvantage is there
are some technical challenges,

00:49:16.880 --> 00:49:19.650
and I'm going to go into those right now.

00:49:19.660 --> 00:49:22.180
So that's why we have a
beta sticker right now.

00:49:22.340 --> 00:49:25.180
Could be an alpha,
we just like the word beta.

00:49:25.180 --> 00:49:28.030
Currently, applets don't work with
the OpenGL pipeline.

00:49:28.030 --> 00:49:31.930
OpenGL pipeline doesn't work with the
resolution independence in Leopard yet.

00:49:32.480 --> 00:49:34.960
We have some issues with
overlapping components,

00:49:34.960 --> 00:49:36.480
missing lightweight and heavyweight.

00:49:36.700 --> 00:49:40.150
And as you saw in Chris's demo,
Aqua look and feel

00:49:40.160 --> 00:49:42.040
doesn't work with OpenGL.

00:49:42.330 --> 00:49:44.630
These are all things we're working
on and we're hoping to have it

00:49:44.720 --> 00:49:46.290
resolved by the time we ship SEX.

00:49:48.900 --> 00:49:50.600
So this is the history of the pipelines.

00:49:50.600 --> 00:49:54.000
We have the Santonion Quartz pipeline,
same as the graphic before.

00:49:54.000 --> 00:49:57.800
In six, we're going to introduce
an optional pipeline,

00:49:57.800 --> 00:49:59.660
the OpenGL pipeline.

00:49:59.660 --> 00:50:02.660
I want you to kind of pay
attention now to the 1.3 column.

00:50:02.660 --> 00:50:05.240
There is this OpenGL optional.

00:50:05.240 --> 00:50:08.290
What that means, and for those of you who
don't know the history,

00:50:08.290 --> 00:50:10.520
is Apple already shipped
an OpenGL implementation.

00:50:10.530 --> 00:50:14.420
And we were the first Java that
actually had an OpenGL pipeline.

00:50:14.450 --> 00:50:18.250
But we kind of decided to move away from
that effort and kind of leverage on most

00:50:18.250 --> 00:50:19.960
of the work that San has been doing.

00:50:19.960 --> 00:50:22.990
Why have two separate implementation
when we can have one implementation?

00:50:23.000 --> 00:50:25.720
We can both work together
to make it better.

00:50:25.720 --> 00:50:29.160
So just to make it clear,
there are two different implementations.

00:50:29.160 --> 00:50:33.150
But yes,
we did have OpenGL acceleration in 1.3.

00:50:33.520 --> 00:50:34.730
How do I make it go?

00:50:34.790 --> 00:50:36.260
Same flag on all platforms.

00:50:36.400 --> 00:50:39.840
SAN Java to the OpenGL equals true.

00:50:40.130 --> 00:50:44.530
So now let me give you a demo of
the OpenGL pipeline on Mac OS X.

00:51:01.480 --> 00:51:02.440
So I have some notes here.

00:51:02.470 --> 00:51:05.360
Basically what we're going to do,
we're going to run it first with 1.5,

00:51:05.370 --> 00:51:07.790
and that will be with
the Quartz renderer.

00:51:11.310 --> 00:51:15.980
So what we're seeing here is
we have these bouncing balls.

00:51:15.980 --> 00:51:20.520
And what they do is we're going to
try to put as many balls on the screen

00:51:20.520 --> 00:51:23.660
until we reach 30 frames a second.

00:51:23.660 --> 00:51:27.060
So we're going to wait a
little bit until it stabilizes.

00:51:27.060 --> 00:51:30.180
And we basically saw that we
reached 30 frames a second,

00:51:30.180 --> 00:51:33.220
and we have about 1,800 bouncing balls.

00:51:33.220 --> 00:51:36.640
Now we're actually going to run
this with the OpenGL pipeline.

00:51:41.610 --> 00:51:42.550
Let's see what happens.

00:51:42.600 --> 00:51:47.810
So we're going to wait a little bit
and we're going to try to basically

00:51:47.810 --> 00:51:50.900
double the number of balls until
we reach 30 frames per second.

00:51:55.740 --> 00:51:59.320
So we see we're getting
lots and lots of balls.

00:51:59.330 --> 00:52:01.040
And eventually it's going
to stabilize at about,

00:52:01.050 --> 00:52:03.580
I don't know, 10,000.

00:52:03.600 --> 00:52:08.240
So we get about five times
improvement of the OpenGL pipeline.

00:52:08.320 --> 00:52:10.190
Yep, for some odd reason,
people get a kick out of

00:52:10.220 --> 00:52:11.200
these bouncing balls things.

00:52:11.220 --> 00:52:14.440
I don't know why,
but they like to see bouncing balls.

00:52:14.520 --> 00:52:17.280
So can we switch the slides for now?

00:52:19.030 --> 00:52:22.980
So the take-home message of this thing
is if you have a lot of bouncing balls,

00:52:23.060 --> 00:52:25.160
use the OpenGL pipeline.

00:52:26.030 --> 00:52:31.020
Well, seriously,
we're working on the performance numbers.

00:52:31.140 --> 00:52:33.380
As Chris said, sometimes we'll go faster,
sometimes we'll be slower.

00:52:33.380 --> 00:52:35.500
But this just gives you
a glimpse of the future.

00:52:37.740 --> 00:52:38.610
We're going to switch gears now.

00:52:38.630 --> 00:52:41.110
We're going to talk about
resolution-independent Java.

00:52:41.300 --> 00:52:44.260
You've probably all heard about
resolution-independent in the

00:52:44.370 --> 00:52:47.000
Java overview or just general.

00:52:47.290 --> 00:52:51.070
And you're probably wondering,
how does that affect your Java app?

00:52:51.510 --> 00:52:53.350
So here's a little story.

00:52:53.370 --> 00:52:55.040
How will that affect you?

00:52:55.040 --> 00:52:59.310
This is running a Java app,
IntelliJ IDEA, at 72 DPI,

00:52:59.620 --> 00:53:01.260
1x scale factor.

00:53:01.260 --> 00:53:03.540
Let's say you go out and you
buy this fancy new display that

00:53:03.540 --> 00:53:07.710
doesn't exist yet that has 216 DPI,
which is three times the

00:53:07.710 --> 00:53:09.460
number of dots per inch.

00:53:09.460 --> 00:53:12.160
You plug in your monitor,
you fire up IntelliJ,

00:53:12.160 --> 00:53:13.640
and it's going to look like this.

00:53:13.640 --> 00:53:15.060
You won't be able to see anything.

00:53:15.060 --> 00:53:16.350
It's so small.

00:53:16.600 --> 00:53:57.800
[Transcript missing]

00:53:58.170 --> 00:54:00.350
Yeah, it looks fairly crisp.

00:54:00.470 --> 00:54:04.520
And then the primitives,
like these lines, will also be crisp.

00:54:04.720 --> 00:54:06.480
There's going to be one problem, though.

00:54:06.480 --> 00:54:09.700
The images will be kind
of scaled or blown up.

00:54:09.710 --> 00:54:12.580
The reason why this is
happening is because currently,

00:54:12.640 --> 00:54:15.580
buffered images are not aware
of resolution independence.

00:54:15.620 --> 00:54:18.170
And we'll need some help
from Sun to provide us new

00:54:18.170 --> 00:54:23.240
APIs to kind of have different
resolutions of the buffered images.

00:54:23.260 --> 00:54:27.850
Until then,
all buffered images will be blown up.

00:54:28.840 --> 00:54:34.850
So this is how, again, same idea,
same app looks in 72 DPI,

00:54:34.850 --> 00:54:36.620
or a scale factor of 1x.

00:54:36.650 --> 00:54:38.900
And this is how it looks in 3x.

00:54:39.260 --> 00:54:42.040
So let me see if you see the difference.

00:54:42.210 --> 00:54:44.410
Do you actually see the
actual like jaggedness?

00:54:44.430 --> 00:54:47.210
And I'm going to flip between the two.

00:54:48.370 --> 00:54:51.420
High DPI, low DPI, high DPI, low DPI.

00:54:51.530 --> 00:54:54.840
So kind of just pay
attention to the text.

00:54:54.860 --> 00:54:57.140
You have so many more pixels to do that.

00:54:57.160 --> 00:55:02.690
Anyway, I don't know about you,
but I'm excited about those new

00:55:02.690 --> 00:55:02.690
monitors that are not out yet.

00:55:03.580 --> 00:55:06.050
So let's summarize this.

00:55:06.230 --> 00:55:10.740
First, we need some help from Sun for
resolution independence from Java.

00:55:10.740 --> 00:55:14.070
And currently, only six on Leopard is
resolution independent,

00:55:14.070 --> 00:55:15.440
only using the Quartz renderer.

00:55:15.460 --> 00:55:17.980
We're working on making the
Sun2D renderer work with

00:55:17.980 --> 00:55:19.880
resolution independence.

00:55:20.490 --> 00:55:22.400
Time to summarize,
and in the interest of time,

00:55:22.400 --> 00:55:25.070
I'm going to skip through
these slides really,

00:55:25.070 --> 00:55:27.000
or I'm going to breeze
through them really quick.

00:55:27.010 --> 00:55:28.700
What I'm going to do now,
remember those questions

00:55:28.750 --> 00:55:29.880
I asked at the beginning?

00:55:29.910 --> 00:55:31.200
We're going to answer them now.

00:55:31.260 --> 00:55:34.700
So if you haven't been paying
attention to this talk at all,

00:55:34.720 --> 00:55:37.450
this is the time to pay attention,
because this is what you

00:55:37.450 --> 00:55:38.900
should get out of it.

00:55:38.990 --> 00:55:43.880
Different pipelines on Mac OS X,
we have three: Quartz, Santuri, OpenGL.

00:55:45.320 --> 00:55:46.940
Pros and cons of each pipeline.

00:55:47.110 --> 00:55:49.110
So I'm going to kind
of breeze through this.

00:55:49.240 --> 00:55:51.600
Quartz, we know it's good at
anti-aliased drawing,

00:55:51.600 --> 00:55:52.640
high quality drawing.

00:55:52.640 --> 00:55:55.470
One huge problem,
this impedance mismatch that

00:55:55.590 --> 00:55:56.590
we kind of beat to death.

00:55:56.660 --> 00:56:00.140
San2D, Windows, bug for bug and pixel
for pixel compatibility,

00:56:00.160 --> 00:56:00.920
really good.

00:56:00.950 --> 00:56:03.540
You pay no penalty for
the impedance mismatch.

00:56:03.540 --> 00:56:06.890
However, you get some slower...

00:56:07.000 --> 00:56:26.400
[Transcript missing]

00:56:26.980 --> 00:56:30.010
Simple derivative drawing
compared to Windows XP.

00:56:30.060 --> 00:56:30.720
This is important.

00:56:30.880 --> 00:56:34.370
The Sun 2D should give you
similar performance to Windows.

00:56:34.520 --> 00:56:37.040
Quartz, on the other hand, like we saw,
it's a roller coaster ride,

00:56:37.220 --> 00:56:41.610
and it does beat Java and Windows pretty
handily for anti-LDS primitives,

00:56:41.840 --> 00:56:45.080
big images, big fills,
and translucent images.

00:56:45.140 --> 00:56:47.140
For everything else,
like the LDS drawing,

00:56:47.140 --> 00:56:49.100
it didn't do that as well.

00:56:49.800 --> 00:56:52.900
How can you take advantage of
OpenGL acceleration from Java?

00:56:53.070 --> 00:56:54.070
Chris talked about this.

00:56:54.070 --> 00:56:56.160
We have the OpenGL pipeline.

00:56:56.160 --> 00:56:58.380
We have the Joggle bindings.

00:56:58.380 --> 00:57:00.860
And then we have this bridge
that Chris talked about,

00:57:00.860 --> 00:57:04.390
the OpenGL and Joggle bridge,
when they all draw into the same context.

00:57:04.860 --> 00:57:06.880
Is Java going to be resolution-dependent?

00:57:06.940 --> 00:57:09.000
Yes, on Mac OS X.

00:57:09.000 --> 00:57:11.090
And what we're going to get,
we're going to get crisp

00:57:11.240 --> 00:57:12.150
text and crisp primitive.

00:57:12.150 --> 00:57:14.240
Scaled images are blown-up images.

00:57:14.270 --> 00:57:17.220
And basically,
we need some new help from Sun.

00:57:17.220 --> 00:57:25.270
Java needs to be able to distinguish
between points and pixels.

00:57:25.270 --> 00:57:25.270
Currently, there is no such mechanism,
but hopefully, it's coming.

00:57:26.590 --> 00:57:29.340
The most important
question for this session,

00:57:29.340 --> 00:57:32.890
and we kind of talked about this a lot,
was the best pipeline for my app?

00:57:33.060 --> 00:57:40.840
And the big answer is try it yourself and
use this criteria to kind of evaluate.

00:57:40.870 --> 00:57:42.610
And the second question is,
how can I use Shark to

00:57:42.730 --> 00:57:43.990
profile my Java app?

00:57:44.080 --> 00:57:47.380
Well, this is a trick question because
we haven't talked about Shark yet.

00:57:47.400 --> 00:57:50.770
And to tell us about Shark now,
I'd like to invite Rick Altherr from

00:57:50.770 --> 00:57:52.740
the Architecture and Performance Group.

00:57:52.900 --> 00:57:54.910
So welcome, Rick.

00:57:59.030 --> 00:58:03.240
So Shark for Java is something that
we introduced a couple of years ago.

00:58:03.240 --> 00:58:07.170
And let's quickly talk
about what Shark is.

00:58:07.370 --> 00:58:13.920
Shark is a profiling tool developed by
my team at Apple that is a profiler,

00:58:13.920 --> 00:58:16.960
does a variety of different
performance characteristics,

00:58:16.970 --> 00:58:21.530
helps you identify the performance
behavior of your application,

00:58:21.710 --> 00:58:24.400
and also helps you find performance
problems or bottlenecks.

00:58:24.400 --> 00:58:29.440
It supports a large number of languages,
mainly native machine languages.

00:58:29.440 --> 00:58:31.300
But we also do support Java.

00:58:31.300 --> 00:58:35.620
We offer both a GUI and command
line version of the tool.

00:58:35.620 --> 00:58:38.160
So you can actually run it
in automated test suites,

00:58:38.210 --> 00:58:39.700
various configurations.

00:58:39.700 --> 00:58:44.780
And we actually have a new version
available for download as of yesterday,

00:58:44.800 --> 00:58:47.680
or it's also new today, at this website.

00:58:47.680 --> 00:58:53.630
It's newer than what is actually on your
Leopard seed disks and or Xcode 2.4.

00:58:55.350 --> 00:58:57.300
So why do we have a
special thing for Java?

00:58:57.300 --> 00:59:01.560
Well, when you talk about profilers,
the standard way of doing a profile

00:59:01.560 --> 00:59:05.950
is you look at what's executing on the
processors and collecting information and

00:59:05.950 --> 00:59:07.200
figuring out what was actually executing.

00:59:07.200 --> 00:59:10.940
The problem with Java, of course,
is you're looking at the VM.

00:59:10.940 --> 00:59:13.510
You're seeing the JIT code
running or the interpreter

00:59:13.540 --> 00:59:15.430
running or whatever's happening.

00:59:15.440 --> 00:59:18.880
That doesn't really help you find out
what's happening in your application.

00:59:18.940 --> 00:59:20.780
It's what's happening inside the VM.

00:59:21.500 --> 00:59:23.990
So,
Shark for Java is a JNI extension that

00:59:24.040 --> 00:59:27.940
gets loaded into the VM so that we can
actually retrieve a bunch of information

00:59:27.940 --> 00:59:30.110
about what is executing inside the VM.

00:59:30.120 --> 00:59:34.010
So, we can actually show you which class,
which method, etc.

00:59:35.960 --> 00:59:36.860
So how do we do this?

00:59:36.860 --> 00:59:39.240
Well, there's two different
methods that we use.

00:59:39.240 --> 00:59:42.170
And the reason is that
initially we started with the

00:59:42.170 --> 00:59:43.890
Java VM Profiler Interface.

00:59:43.990 --> 00:59:47.040
The Profiler Interface was
an experimental interface

00:59:47.490 --> 00:59:51.950
that was put in in Java 4,
or 1.4, and provided some pretty

00:59:51.950 --> 00:59:54.170
rudimentary hooks,
but it was enough to get

00:59:54.170 --> 00:59:57.230
basic profiling information,
what was executing,

00:59:57.230 --> 00:59:58.900
where you were running.

00:59:58.900 --> 01:00:02.760
It's actually deprecated in Java 5
and completely gone in Java 6.

01:00:02.980 --> 01:00:05.900
So we had to move to something new.

01:00:05.900 --> 01:00:09.000
Well, what they did is they combined
the Profiler Interface and

01:00:09.000 --> 01:00:11.900
what was the Debugger Interface
into a unified Tools Interface.

01:00:11.900 --> 01:00:13.900
And this actually gives
us a lot more flexibility.

01:00:13.900 --> 01:00:17.860
We can do a lot of new types of
instrumentation and various things,

01:00:17.960 --> 01:00:21.890
but it also takes a bit of work
to actually do this change.

01:00:21.900 --> 01:00:24.390
We're not completely
on feature parity yet,

01:00:24.390 --> 01:00:25.870
but we're pretty close.

01:00:25.900 --> 01:00:29.900
The important thing is that
Shark for Java works in both.

01:00:29.900 --> 01:00:36.910
You can actually use the same version
of Shark in both JVM PI with Java 1.4 or

01:00:36.970 --> 01:00:42.900
Java 5 and JVM TI with Java 5 or Java 6.

01:00:44.110 --> 01:00:48.560
So we offer three main
types of profiling for Java.

01:00:48.560 --> 01:00:52.090
The first one is our
classic time profile.

01:00:52.260 --> 01:00:54.380
What it does is it looks
at where were you actually

01:00:54.380 --> 01:00:56.600
executing and spending your time.

01:00:56.650 --> 01:00:57.970
So we show you a couple things.

01:00:58.060 --> 01:01:02.430
One, we show you the number of samples
during the session that were in

01:01:02.430 --> 01:01:04.980
each function or each method.

01:01:04.980 --> 01:01:09.900
And we actually show you which package,
class, and method that was.

01:01:09.910 --> 01:01:12.620
So this way you can actually
look at-- here it is.

01:01:12.620 --> 01:01:14.360
And in fact,
there's the little triangle there

01:01:14.360 --> 01:01:16.400
we'll show you in a little bit.

01:01:16.400 --> 01:01:20.970
You can actually look down the back trace
or the stack trace and actually see how

01:01:20.970 --> 01:01:24.290
it was invoked and by what other methods.

01:01:24.520 --> 01:01:27.600
The problem with this is that
it's a statistical sample.

01:01:27.600 --> 01:01:31.720
So you can actually get in cases where
you can't accurately depict what was

01:01:31.810 --> 01:01:35.140
happening by doing a statistical sample
because things are happening too fast.

01:01:35.140 --> 01:01:38.150
So we offer another
method called Call Trace,

01:01:38.150 --> 01:01:42.410
which actually looks at the
entry and exit points of methods.

01:01:42.420 --> 01:01:46.150
Now this significantly slows down
the execution of your program,

01:01:46.200 --> 01:01:50.010
but it gives you an accurate number
of invocations of methods as well

01:01:50.010 --> 01:01:52.050
as time spent in those methods.

01:01:52.690 --> 01:01:55.410
So you will literally see everything
that happened from the time you click

01:01:55.410 --> 01:01:56.780
start to the time you click stop.

01:01:56.820 --> 01:01:59.480
It just offers a large
performance penalty,

01:01:59.480 --> 01:02:03.900
whereas time profile being statistical,
actually your app runs very close to

01:02:03.950 --> 01:02:05.970
if you weren't running Shark at all.

01:02:07.550 --> 01:02:09.940
Now these are great for finding out
where you're spending a lot of time,

01:02:09.950 --> 01:02:12.460
but in Java,
one of the larger performance

01:02:12.530 --> 01:02:15.660
bottlenecks can be memory allocation.

01:02:15.770 --> 01:02:19.490
So what we do is we have a
trace that actually looks at

01:02:19.490 --> 01:02:22.030
where objects are allocated.

01:02:22.140 --> 01:02:29.910
So we collect this and summarize
it as a total size of allocations

01:02:29.990 --> 01:02:31.400
that happen in a method.

01:02:31.540 --> 01:02:33.770
And this way, during the course of it,
you can see, well,

01:02:33.770 --> 01:02:37.670
I have one method that allocates
16k over the course of the sample.

01:02:37.870 --> 01:02:39.980
And that's not actually too bad,
but I have actually seen some

01:02:39.980 --> 01:02:47.060
applications that allocate multiple tens
of megabytes in one function constantly.

01:02:47.130 --> 01:02:49.390
That's just the way that things happen.

01:02:49.570 --> 01:02:54.690
Now the allocation trace is currently
only in the profiler interface.

01:02:54.710 --> 01:02:56.310
We're working on getting
that in the tools interface,

01:02:56.390 --> 01:02:59.960
but it requires a little bit more
work that we haven't had time to

01:02:59.960 --> 01:03:01.420
finish for what's available today.

01:03:01.420 --> 01:03:04.380
It'll be coming soon.

01:03:04.380 --> 01:03:09.450
So let's do a little guided
tour of how you might use Shark.

01:03:15.210 --> 01:03:17.600
So we have this demo program.

01:03:17.600 --> 01:03:26.010
And all I'm doing is I'm invoking
Java with the Java Tool Interface

01:03:26.010 --> 01:03:31.810
command line for Shark,
which loads the Shark JNI extension

01:03:31.810 --> 01:03:33.720
or the Shark agent.

01:03:33.720 --> 01:03:37.840
And the agent itself actually
does nothing in the background.

01:03:37.840 --> 01:03:41.590
It's just present,
loaded into the executable.

01:03:42.200 --> 01:03:45.720
What we have is a ray tracer written
in Java that is multi-threaded,

01:03:45.750 --> 01:03:47.260
and we'll let it go ahead and run.

01:03:47.260 --> 01:03:48.350
It does two passes.

01:03:48.380 --> 01:03:50.960
It does the actual
rendering of the scene.

01:03:51.310 --> 01:03:54.150
When that completes,
it actually goes through and

01:03:54.150 --> 01:03:56.170
does a full anti-aliasing pass.

01:03:56.260 --> 01:03:58.690
In the course of doing this,
it actually visits every pixel

01:03:58.700 --> 01:04:02.790
multiple times and does a lot
of calculations on each one.

01:04:02.970 --> 01:04:05.300
As you can see,
performance for a ray tracer

01:04:05.300 --> 01:04:06.900
actually isn't terrible.

01:04:06.900 --> 01:04:08.140
It does a pretty good job.

01:04:08.140 --> 01:04:11.300
But there are certain spots
where it really slows down.

01:04:11.370 --> 01:04:15.140
And we should be able to
make some improvements here.

01:04:15.140 --> 01:04:17.960
So we're going to go ahead and let
this run just to get a baseline

01:04:17.960 --> 01:04:20.260
number as to how long this takes.

01:04:20.260 --> 01:04:24.210
And it's almost done with this.

01:04:27.900 --> 01:04:32.220
So here we see I have a little
drawing problem in my app,

01:04:32.340 --> 01:04:36.460
but it took 41 seconds to
actually render the whole scene.

01:04:36.480 --> 01:04:39.490
Well, what we can do is say, well,
what was actually happening?

01:04:39.550 --> 01:04:44.260
So here I have Shark in Java time
profile on my Java process.

01:04:44.260 --> 01:04:45.890
And I can click Start over here.

01:04:46.090 --> 01:04:47.980
And I'm actually going to use a hotkey.

01:04:47.980 --> 01:04:50.900
I can hit Option Escape on my
keyboard to start Shark without

01:04:51.000 --> 01:04:52.370
even having it in focus.

01:04:52.370 --> 01:04:53.680
Let it run for a little while.

01:04:53.680 --> 01:04:56.380
And you'll notice that the renderer
is still actually running at

01:04:56.380 --> 01:04:57.750
a pretty decent performance.

01:04:57.830 --> 01:04:58.800
I stop it.

01:04:58.800 --> 01:05:00.800
And now I'm collecting the samples.

01:05:00.800 --> 01:05:06.340
And here we can see I'm spending
most of my time in four places-- some

01:05:06.570 --> 01:05:12.790
SHA-1 calculations and also in the
math libraries calling POW and FLOR.

01:05:13.740 --> 01:05:18.090
So in this case, we know a lot about how
the execution is happening,

01:05:18.110 --> 01:05:20.280
but you go, well,
there's nothing I can do about

01:05:20.300 --> 01:05:22.160
changing how floor is implemented.

01:05:22.230 --> 01:05:26.960
Well, Shark lets you do an option
called charge to callers.

01:05:26.960 --> 01:05:29.610
So instead of saying,
these samples happened

01:05:29.610 --> 01:05:31.860
in strict math floor,
I can say, well,

01:05:31.940 --> 01:05:35.240
I can't do anything there,
so make them look like the samples

01:05:35.320 --> 01:05:39.060
came from whoever called it,
which moves it to math floor.

01:05:39.520 --> 01:05:41.510
But, you know,
that's not interesting either,

01:05:41.510 --> 01:05:45.350
and in fact, the entire package
I can't do anything with,

01:05:45.430 --> 01:05:48.710
so I can say charge the
entire package to the callers.

01:05:48.720 --> 01:05:52.950
Well, now, everything,
this new method pops up,

01:05:52.950 --> 01:05:54.600
which is hit transform.

01:05:54.600 --> 01:05:56.640
Let's take a look at what's happening.

01:05:56.640 --> 01:06:00.070
I can double click and it takes
me to the actual lines of source

01:06:00.070 --> 01:06:04.430
code in the application and
shows me which lines of source.

01:06:04.440 --> 01:06:08.150
We change background colors
in the table to indicate,

01:06:08.150 --> 01:06:09.210
I don't know,

01:06:09.200 --> 01:06:18.200
[Transcript missing]

01:06:18.850 --> 01:06:23.800
So we can go ahead and
remove a lot of these calls.

01:06:23.810 --> 01:06:32.440
And we'll actually see that performance,
not really-- there might be

01:06:32.440 --> 01:06:34.080
a little improvement there.

01:06:34.110 --> 01:06:38.340
But what we find is that floor and
power are actually being called a

01:06:38.340 --> 01:06:40.760
fairly significant number of times.

01:06:40.800 --> 01:06:42.880
And because of being
a statistical sampler,

01:06:42.880 --> 01:06:46.040
we see Nyquist sampling
theorem comes into play,

01:06:46.040 --> 01:06:48.980
where we just see it ending
up in that function a lot,

01:06:48.980 --> 01:06:53.030
even though it doesn't
take a whole lot of time.

01:06:54.300 --> 01:06:56.930
If we go back to the profile,
there were some other things

01:06:56.930 --> 01:07:00.370
that we saw which were SHA-1.

01:07:00.540 --> 01:07:05.330
Well, what's happening is all of these
different textures that you see

01:07:05.330 --> 01:07:05.330
in the scene that are rendered,

01:07:05.760 --> 01:07:11.100
A number of them are actually generated
using SHA-1 hashes as a texture,

01:07:11.140 --> 01:07:16.770
a way to get the random
numbers for texturing.

01:07:17.450 --> 01:07:22.800
These are calculated on every pixel
multiple times in both passes,

01:07:22.860 --> 01:07:24.900
the render phase and
the anti-aliasing phase.

01:07:24.900 --> 01:07:28.560
So we've done some optimizations
to go ahead and look and see,

01:07:28.560 --> 01:07:30.800
well, okay, where am I being called?

01:07:30.820 --> 01:07:37.070
Because SHA-1 itself is actually
pretty difficult to optimize anymore.

01:07:37.080 --> 01:07:38.350
So let's look.

01:07:38.450 --> 01:07:41.020
Well,
we see that this one particular method,

01:07:41.020 --> 01:07:45.010
we have a number of calls to SHA-1.

01:07:45.990 --> 01:07:47.820
And in fact,

01:07:49.030 --> 01:07:54.480
The same number is going to be passed
to SHA-1 over and over and over again.

01:07:54.980 --> 01:07:57.450
Each time a new pixel is visited,
the calculations,

01:07:57.520 --> 01:08:00.560
you can kind of see that the numbers
are going to be very similar.

01:08:00.620 --> 01:08:04.480
So what I've done is I've gone ahead
and implemented a cache inside of

01:08:04.480 --> 01:08:08.310
these SHA-1 values so that we don't
have to recompute them every time.

01:08:08.540 --> 01:08:10.340
So go ahead and start it.

01:08:10.370 --> 01:08:14.850
And this is-- didn't
actually do the SHA cache.

01:08:15.620 --> 01:08:18.500
So the render phase actually has to
go through and generate all these

01:08:18.500 --> 01:08:21.100
once and cache all these values.

01:08:21.230 --> 01:08:26.790
But the interesting aspect is that
the anti-aliaser uses them once again.

01:08:26.790 --> 01:08:30.990
So the anti-aliasing phase happens much,
much, much faster.

01:08:30.990 --> 01:08:34.410
And this was all found just by
taking a very simple look at what

01:08:34.430 --> 01:08:38.700
was happening and where we were
actually spending our execution time.

01:08:39.960 --> 01:08:43.700
I'll go ahead and let this finish so
we can see how long it actually takes.

01:08:43.950 --> 01:08:47.360
And then I'll come back and show
you a new profile of what we find.

01:08:47.600 --> 01:08:50.100
But there we see it took 32 seconds.

01:08:50.180 --> 01:08:52.320
We shaved off a little over 10 seconds.

01:08:52.400 --> 01:08:56.540
So now if I run it again and
take yet another profile,

01:08:56.540 --> 01:08:57.350
we can see...

01:08:57.880 --> 01:09:00.490
We're still calling floor
a fair number of times,

01:09:00.490 --> 01:09:03.150
but now we're actually spending
a fair amount of our time in

01:09:03.150 --> 01:09:04.770
rendering the image itself.

01:09:04.800 --> 01:09:09.040
So you could repeat this process and
look at the different types of things

01:09:09.040 --> 01:09:10.180
that are happening underneath the covers.

01:09:15.140 --> 01:09:18.300
Back to slides.

01:09:18.450 --> 01:09:21.220
So that's a brief tour of Shark.

01:09:21.450 --> 01:09:26.720
For more information on the
Java pipelines and other things,

01:09:26.730 --> 01:09:29.950
there's the WWDC website with
documentation and sample code.

01:09:30.060 --> 01:09:34.290
There's also Chris Campbell's
blog that you can go look at.

01:09:34.700 --> 01:09:39.800
and we're actually a little low on time,
so I think that's all we have time for.
WEBVTT

00:00:10.300 --> 00:00:12.300
Wow, thanks for coming.

00:00:12.300 --> 00:00:14.700
You guys do know there's a
Core Imaging session right now,

00:00:14.700 --> 00:00:15.100
don't you?

00:00:15.100 --> 00:00:20.400
Hi, welcome to session 132,
Cocoa Animation Techniques.

00:00:20.400 --> 00:00:21.780
My name is Troy Stephens.

00:00:21.780 --> 00:00:23.820
I'm a software engineer
on the AppKit team.

00:00:23.820 --> 00:00:27.430
And today, I get to tell you about some
really neat stuff that we've

00:00:27.480 --> 00:00:30.870
been working on for Leopard,
with the goal of making it very,

00:00:30.980 --> 00:00:34.720
very easy for you to add
sophisticated animations and visual

00:00:34.720 --> 00:00:38.380
effects to your Cocoa applications,
to your existing

00:00:38.380 --> 00:00:40.680
view-based user interfaces.

00:00:40.680 --> 00:00:43.920
So, animation can be a lot of fun,
adding animation to your apps,

00:00:43.980 --> 00:00:46.640
and you can and will go
completely nuts with this stuff.

00:00:46.640 --> 00:00:50.120
It can also, however,
serve some useful user interface

00:00:50.200 --> 00:00:53.850
purposes and provide good
user experience benefits.

00:00:53.970 --> 00:00:56.900
And that's been part of the
motivation behind our developing

00:00:56.900 --> 00:00:59.770
this technology and making it easier
for you to do these kinds of things.

00:00:59.820 --> 00:01:04.010
Animation can make your
application feel more adaptive,

00:01:04.020 --> 00:01:06.000
live, dynamic, responsive.

00:01:06.040 --> 00:01:08.800
And it can put that kind
of last bit of polish,

00:01:08.800 --> 00:01:11.790
that extra fit and finish on your app,
that tells users that you've

00:01:11.810 --> 00:01:15.240
paid attention to every detail,
and that you really want them to have

00:01:15.240 --> 00:01:17.040
a highly interactive user experience.

00:01:17.070 --> 00:01:20.350
But in addition to stuff like that,
that's just sort of endears users

00:01:20.350 --> 00:01:23.440
to your apps in a general way,
you can do things like help

00:01:23.520 --> 00:01:25.140
users maintain context.

00:01:25.170 --> 00:01:28.260
In Panther, we added animated scrolling,
for example,

00:01:28.260 --> 00:01:31.380
for web views and mail messages,
and now you may notice

00:01:31.380 --> 00:01:34.160
in your Leopard seat,
it's turned on for all scroll views.

00:01:34.160 --> 00:01:37.650
So, you know,
when I'm reading a web page,

00:01:37.750 --> 00:01:40.080
if the page jumps when I page down,
I kind of got to figure out

00:01:40.130 --> 00:01:43.600
where I was and pick up,
but with animated scrolling,

00:01:43.600 --> 00:01:46.660
my eyes can kind of track
along as the page is moving,

00:01:46.660 --> 00:01:49.950
and I can pick up where I left off
much more easily and continue reading.

00:01:50.140 --> 00:01:54.180
Another use for animations is to
alert users to state changes that they

00:01:54.220 --> 00:01:56.260
themselves did not necessarily initiate.

00:01:56.320 --> 00:01:59.040
For example,
the iChat buddy list is one of the

00:01:59.040 --> 00:02:01.220
first places we really saw this,
where, you know,

00:02:01.220 --> 00:02:03.790
you have buddies coming online,
going offline,

00:02:03.800 --> 00:02:05.940
and you kind of want to get a visual cue.

00:02:05.940 --> 00:02:07.510
That something's going on there,
you know, "Oh,

00:02:07.590 --> 00:02:09.730
dad's online now," or something,
or somebody just left,

00:02:09.780 --> 00:02:11.680
but you don't want to
be interrupted with it.

00:02:11.680 --> 00:02:13.730
It's something you can be
sort of peripherally aware of,

00:02:13.730 --> 00:02:17.150
and animation works beautifully
in that particular situation

00:02:17.160 --> 00:02:19.860
to sort of give you a cue that
something's going on off to the side.

00:02:19.860 --> 00:02:23.350
Another thing you can do with
animation is indicate sort of a

00:02:23.380 --> 00:02:26.520
tentative response to a user action
that hasn't been committed yet.

00:02:26.520 --> 00:02:29.840
An example of this would be when
you go to customize your toolbar,

00:02:29.840 --> 00:02:32.170
and you're dragging a new
item in or taking an existing

00:02:32.200 --> 00:02:34.500
item and moving it around,
you'll notice that all

00:02:34.500 --> 00:02:37.360
the other toolbar items,
sort of move around in a

00:02:37.360 --> 00:02:39.560
live animated way to show,
you know, "Okay,

00:02:39.600 --> 00:02:42.070
this is how we're going to move out of
the way to make room for the item that

00:02:42.090 --> 00:02:44.740
you're about to drop." So if you drop it,
you know where it's going to go.

00:02:44.740 --> 00:02:47.560
You can do that kind of thing
arguably without animation,

00:02:47.560 --> 00:02:50.320
but it just looks a lot slicker
and feels a lot more responsive

00:02:50.320 --> 00:02:51.600
when animation is used.

00:02:51.600 --> 00:02:54.980
Lastly,
another thing you might want to do

00:02:54.980 --> 00:02:58.120
is indicate that some major change
of interaction mode is occurring.

00:02:58.130 --> 00:03:00.120
Like front row, for example.

00:03:00.120 --> 00:03:03.190
If you take out your Apple remote,
and you click the menu button on it,

00:03:03.320 --> 00:03:06.150
then everybody else who's
seated in your section will see

00:03:06.230 --> 00:03:09.060
their desktop slowly fade away,
and the notes they're taking will fade

00:03:09.060 --> 00:03:10.840
away as the front row UI comes on.

00:03:10.850 --> 00:03:15.500
And it gives users a cue that, "Okay,
we're leaving the desktop now.

00:03:15.500 --> 00:03:18.700
We're leaving that set of metaphors
and that means of user interaction,

00:03:18.840 --> 00:03:20.380
and things are going to
work a little differently.

00:03:20.380 --> 00:03:22.270
We're going to interact with the machine,
with the remote,

00:03:22.270 --> 00:03:26.080
and so forth." So these are just
a few examples to give you some

00:03:26.080 --> 00:03:30.150
ideas of the kinds of things that
you might be able to find uses for

00:03:30.150 --> 00:03:32.920
animation for in your own applications.

00:03:33.140 --> 00:03:35.700
So today we're going to look at
some new animation support that

00:03:35.700 --> 00:03:37.700
we've been working on for AppKit.

00:03:37.700 --> 00:03:40.820
We'll start off with a demo to sort
of seed a picture in your minds

00:03:40.820 --> 00:03:43.770
of just what kind of stuff we're
talking about being able to do.

00:03:43.790 --> 00:03:47.230
Then I'll go into a design overview
of sort of the hows and whys of how we

00:03:47.230 --> 00:03:49.080
decided to present this functionality.

00:03:49.080 --> 00:03:51.950
And we'll look at the new API in
detail so that you'll be able to

00:03:51.950 --> 00:03:55.600
go away and start using this stuff
right away on the Leopard Seed.

00:03:55.600 --> 00:03:58.470
And I'll close with some usage
tips and performance tips for

00:03:58.470 --> 00:04:00.420
how to get the most out of this.

00:04:00.420 --> 00:04:02.470
So if we could go to demo D please.

00:04:02.520 --> 00:04:05.030
We'll start with our first demo.

00:04:07.420 --> 00:04:12.020
And I know you guys have seen a lot of
sort of image browser apps this week.

00:04:12.020 --> 00:04:13.200
So I apologize.

00:04:13.200 --> 00:04:15.080
I have another image
browser app to show you.

00:04:15.140 --> 00:04:17.580
But I made this one
look a little different.

00:04:17.580 --> 00:04:22.480
So in this one, the user's presented with
a set of images as slides.

00:04:22.690 --> 00:04:26.560
And each of these-- this is
all done using Cocoa Views.

00:04:26.760 --> 00:04:29.720
Each slide is actually a
small subtree of views.

00:04:29.720 --> 00:04:33.060
I've got the custom view
that draws the slide carrier,

00:04:33.100 --> 00:04:35.860
the sort of white, rounded corner,
bezier path,

00:04:35.860 --> 00:04:37.420
using a subtle NSGradient there.

00:04:37.420 --> 00:04:40.980
NSGradient is a handy new class
that's been added to AppKit.

00:04:40.980 --> 00:04:43.320
So yeah, it's much easier to do that now.

00:04:43.320 --> 00:04:46.620
No need to drop down to Core graphics
and write lots of C code.

00:04:46.620 --> 00:04:48.260
And in fact,
the background here is a very

00:04:48.300 --> 00:04:51.740
subtle gradient from dark
gray to black up at the top.

00:04:51.740 --> 00:04:55.420
So we've got a simple container view
that just sort of draws the slide shape.

00:04:55.420 --> 00:04:58.880
We've got a-- up here
at the top of each one,

00:04:58.880 --> 00:05:02.410
we've got a simple button that is
a checkbox style button that both

00:05:02.410 --> 00:05:05.740
displays the title and enables me
to check off a slide as selected.

00:05:05.840 --> 00:05:09.270
And then we've got a couple of ordinary
NSText fields down at the bottom that

00:05:09.340 --> 00:05:11.430
display some information about the image,
what type it is,

00:05:11.430 --> 00:05:13.170
and what its pixel dimensions are.

00:05:13.290 --> 00:05:16.180
So far,
this is all pretty ordinary Cocoa Views.

00:05:16.180 --> 00:05:19.740
And I've added some sort
of different layouts,

00:05:19.800 --> 00:05:21.880
different ways we can sort
of scatter the slides around.

00:05:21.880 --> 00:05:26.240
We can arrange them in sort of
an infinite loop configuration,

00:05:26.370 --> 00:05:27.280
arrange them in a circle.

00:05:27.280 --> 00:05:29.050
And this is just sort of setting views.

00:05:29.200 --> 00:05:32.060
All I'm doing in each of these
cases is computing the frame origin

00:05:32.060 --> 00:05:35.100
that I want and the frame rotation
for each of the views and putting

00:05:35.100 --> 00:05:36.360
them in the new configuration.

00:05:36.360 --> 00:05:39.020
So so far,
this is all ordinary Cocoa Views stuff.

00:05:39.170 --> 00:05:43.310
But what's interesting here is that
these views are not being composited

00:05:43.340 --> 00:05:45.840
into the window via the usual means.

00:05:45.840 --> 00:05:48.810
Behind the scenes,
AppKit is creating automatically a

00:05:48.810 --> 00:05:52.650
layer tree that mirrors everything
in the view subtree here from the

00:05:52.700 --> 00:05:56.220
content view here all the way on down
the view hierarchy to the leaves.

00:05:56.220 --> 00:05:58.140
So we've got views and layers.

00:05:58.140 --> 00:06:01.030
And the significance of having
view content in layers is that

00:06:01.100 --> 00:06:02.680
each view gets its own layer.

00:06:02.680 --> 00:06:05.800
Each layer has its own backing store,
therefore you have

00:06:05.870 --> 00:06:07.030
pre-cached view content.

00:06:07.040 --> 00:06:09.420
And it's very easy-- once you
have pre-rendered content,

00:06:09.440 --> 00:06:11.660
it's very easy to move
stuff around efficiently.

00:06:11.770 --> 00:06:16.410
And if we want to animate stuff,
I can give this a non-zero duration here.

00:06:16.580 --> 00:06:19.620
And instead of sending things
immediately to their new locations--

00:06:19.620 --> 00:06:23.700
let's say I want to relay these out--
I can just sort of have them smoothly

00:06:23.700 --> 00:06:25.780
animate to their new position.

00:06:25.780 --> 00:06:28.770
And one of the take points here--

00:06:28.900 --> 00:06:31.140
And I'll just let that run automatically.

00:06:31.190 --> 00:06:33.520
So I'm just cycling among
the different configurations.

00:06:33.520 --> 00:06:36.930
And this is running very slowly,
so you can get a clear picture of it.

00:06:37.020 --> 00:06:38.940
But this can run fast if you want.

00:06:39.000 --> 00:06:41.220
You want half-second animations.

00:06:41.220 --> 00:06:45.040
You can make people a little seasick.

00:06:45.040 --> 00:06:48.990
There we go.

00:06:49.200 --> 00:11:21.700
[Transcript missing]

00:11:27.850 --> 00:11:30.290
So, you know,
you want to pick a transition and that

00:11:30.290 --> 00:11:32.040
just works and it's very little code.

00:11:32.040 --> 00:11:34.040
Part of the take-home point
is this is very little code.

00:11:34.210 --> 00:11:38.030
And this is all running on the
very same leopard seed that you

00:11:38.030 --> 00:11:39.920
guys have received this week
that you have in your possession.

00:11:39.920 --> 00:11:43.740
So this is all stuff that you can
begin experimenting with today.

00:11:46.040 --> 00:11:51.780
So if we could go back to the slides,
I'd like to get into how you can do that.

00:11:52.790 --> 00:11:55.700
So a quick design overview
of what we've decided to do.

00:11:55.700 --> 00:11:58.860
You may have had the chance to attend
the Core Animation session yesterday.

00:11:58.860 --> 00:12:01.000
If not, I'll give a quick recap
of Core Animation.

00:12:01.090 --> 00:12:04.380
Core Animation is a powerful
new framework and foundation for

00:12:04.380 --> 00:12:07.000
compositing and animating of content.

00:12:07.110 --> 00:12:09.000
Core Animation is an Objective-C API.

00:12:09.000 --> 00:12:11.510
It's part of the Quartz Core framework.

00:12:11.520 --> 00:12:14.640
Its development code name was LayerKit,
so you'll hear me say

00:12:14.640 --> 00:12:16.600
LayerKit occasionally by mistake.

00:12:16.600 --> 00:12:21.810
And that's why all the classes
have the LK prefix in the names.

00:12:22.850 --> 00:12:26.400
The most basic unit of currency that you
work with in Core Animation is layers.

00:12:26.400 --> 00:12:28.680
Layers are in many ways
analogous to views.

00:12:28.720 --> 00:12:30.950
The layer API was patterned
after the view API.

00:12:30.950 --> 00:12:33.830
And layers are like these sort of
blank canvases that you can put

00:12:33.830 --> 00:12:35.520
whatever content you want into.

00:12:35.520 --> 00:12:37.240
They are nestable in a hierarchy.

00:12:37.350 --> 00:12:39.780
Each has its own local coordinate
system defined in terms of its

00:12:39.790 --> 00:12:41.140
parent's coordinate system.

00:12:41.140 --> 00:12:45.340
There's some limited support for
event handling and that sort of thing.

00:12:45.340 --> 00:12:47.460
So it's very much like
working with a view hierarchy,

00:12:47.550 --> 00:12:50.440
except you don't have this
implementation of all the Aqua controls.

00:12:50.440 --> 00:12:52.680
Basically,
layers are just like an NSView.

00:12:52.800 --> 00:12:56.320
They don't have any inherent behavior,
but they have sort of potential behaviors

00:12:56.450 --> 00:12:57.640
and a way that they work together.

00:12:57.640 --> 00:13:00.010
As I mentioned,
you have per-layer content buffering,

00:13:00.090 --> 00:13:02.640
so you can do very efficient
kinds of animations and applying

00:13:02.640 --> 00:13:04.180
effects and that sort of thing.

00:13:04.180 --> 00:13:05.560
That's very important.

00:13:05.560 --> 00:13:09.410
And it's part of how
Core Animation provides all

00:13:09.410 --> 00:13:12.120
these performance improvements
over standard view animation.

00:13:12.120 --> 00:13:17.100
And it has this fantastic implicit
asynchronous animation model where

00:13:17.100 --> 00:13:22.220
you basically set new properties on
things and it's implied that you get an

00:13:22.220 --> 00:13:22.780
animation to the end of the animation.

00:13:22.800 --> 00:13:24.800
So you can change the new target
state rather than the changes

00:13:24.800 --> 00:13:25.800
taking effect immediately.

00:13:25.800 --> 00:13:28.430
So that's a really powerful,
easy way for you to

00:13:28.430 --> 00:13:31.220
implement animations to say,
I want something to animate.

00:13:31.220 --> 00:13:32.660
You just change properties.

00:13:32.680 --> 00:13:36.400
Core Animation comes with a
very expressive set of animation

00:13:36.400 --> 00:13:38.990
description classes that we'll look
at in detail that let you specify

00:13:38.990 --> 00:13:40.500
all kinds of different animations.

00:13:40.500 --> 00:13:44.180
It encapsulates a set of layout
algorithms that you can use as

00:13:44.180 --> 00:13:48.090
layout managers to specify how
sublayers are positioned when

00:13:48.090 --> 00:13:50.340
their super layer changes size.

00:13:50.340 --> 00:13:52.780
And it provides you access
to the full-duty animation.

00:13:52.800 --> 00:13:54.800
You can have a full range
of core image effects,

00:13:54.800 --> 00:13:55.940
shadow effects on layers.

00:13:55.940 --> 00:13:57.670
You can have masks on
layers and so forth.

00:13:57.690 --> 00:14:02.580
And one of the greatest potentials
that Core Animation has going

00:14:02.580 --> 00:14:07.060
forward is to be sort of a unifying
graphics technology that helps

00:14:07.060 --> 00:14:11.120
bring together Quartz rendering
with other sort of sub-universes

00:14:11.120 --> 00:14:13.200
of rendering like GL rendering,
QuickTime,

00:14:13.200 --> 00:14:16.970
Quartz Composer content rendering
that previously have had a really

00:14:16.970 --> 00:14:18.920
hard time coexisting together.

00:14:18.920 --> 00:14:21.200
You know, if you have some
GL rendering in a window,

00:14:21.200 --> 00:14:22.780
that's usually going to
a hardware accelerator.

00:14:22.800 --> 00:14:22.800
You know, if you have some
GL rendering in a window,

00:14:22.800 --> 00:14:22.820
that's usually going to
a hardware accelerator.

00:14:22.820 --> 00:14:25.220
And it doesn't play well
with having controls on top

00:14:25.220 --> 00:14:26.220
of it and stuff like that.

00:14:26.280 --> 00:14:30.540
So stuff that has been really
hard to do before is going to be

00:14:30.540 --> 00:14:32.160
much easier to do in the future.

00:14:32.160 --> 00:14:35.830
On the other hand,
there are a number of things

00:14:35.830 --> 00:14:37.700
that Core Animation does
not attempt to provide.

00:14:37.700 --> 00:14:40.680
Core Animation sits in Quartz
Core down below the AppKit layer.

00:14:40.680 --> 00:14:43.600
And among other things,
it is not an implementation

00:14:43.600 --> 00:14:45.140
of the Aqua Control set.

00:14:45.140 --> 00:14:46.630
It's not a user interface toolkit.

00:14:46.640 --> 00:14:49.220
It is an Objective-C API,
so in that sense it's somewhat

00:14:49.270 --> 00:14:51.100
object-oriented and high-level.

00:14:51.100 --> 00:14:54.230
But it does not... It does not
attempt to supplant AppKit or

00:14:54.280 --> 00:14:56.800
do the job of providing all
these standard controls for you.

00:14:57.000 --> 00:15:00.160
Likewise, you get no built-in
accessibility support with it.

00:15:00.160 --> 00:15:04.230
Other things like printing support,
you can, I found out, you can,

00:15:04.230 --> 00:15:06.160
I found out in the
Core Animation session yesterday,

00:15:06.340 --> 00:15:10.620
render a layer tree to a PDF,
so there is support for output

00:15:10.620 --> 00:15:12.480
to things other than the screen.

00:15:12.480 --> 00:15:15.630
But AppKit has this whole
complex printing architecture

00:15:15.790 --> 00:15:19.150
that provides you with a lot
more when it comes to printing.

00:15:19.330 --> 00:15:21.280
Complex event handling.

00:15:21.280 --> 00:15:24.840
There are some basic event handling
capabilities in Core Animation.

00:15:24.850 --> 00:15:29.760
But AppKit has all these long-standing
paradigms for things like input focus,

00:15:29.840 --> 00:15:32.790
the responder chain,
that give you lots of power

00:15:32.880 --> 00:15:35.390
when it comes to event handling
and lots of flexibility.

00:15:35.440 --> 00:15:37.390
So that's another thing AppKit provides.

00:15:37.440 --> 00:15:40.240
Drag and drop support,
support for things like tooltips,

00:15:40.240 --> 00:15:41.440
cursor recs, tracking recs.

00:15:41.440 --> 00:15:44.760
These are all just sort of higher-level
things that you expect more from a

00:15:44.760 --> 00:15:46.720
user interface toolkit like AppKit.

00:15:46.800 --> 00:15:50.440
So we've got a lot of power
down in Core Animation.

00:15:50.440 --> 00:15:52.430
And we want to make
it really easy to use.

00:15:52.440 --> 00:15:55.030
And so the thing we wanted to
do going forward was enable you

00:15:55.030 --> 00:15:56.410
to get the best of both worlds.

00:15:56.440 --> 00:15:58.390
And so what we've
decided to do in AppKit,

00:15:58.530 --> 00:16:01.420
our goals were, first,
make animation easy and fun.

00:16:01.440 --> 00:16:04.140
So try to minimize the syntax,
make this really easy

00:16:04.140 --> 00:16:05.380
to take advantage of.

00:16:05.440 --> 00:16:09.440
Leverage Core Animation's performance
and feature benefits as much as possible.

00:16:09.500 --> 00:16:13.970
And extend the same sort of convenient
and powerful compositing and animation

00:16:13.970 --> 00:16:15.440
model to you for use with views.

00:16:15.440 --> 00:16:18.960
So that you can continue to work
with views and not even worry about

00:16:18.960 --> 00:16:19.440
layers unless you really want to.

00:16:19.440 --> 00:16:20.000
So that you can continue to work
with views and not even worry about

00:16:20.000 --> 00:16:20.440
layers unless you really want to.

00:16:20.440 --> 00:16:22.350
or need to.

00:16:22.600 --> 00:16:25.090
In hand with doing that,
we've added a set of new visual

00:16:25.090 --> 00:16:27.970
effect properties to NSView,
like the shadows I demonstrated,

00:16:28.000 --> 00:16:31.360
like the ability to apply core
image filters to the content

00:16:31.360 --> 00:16:33.140
of a view that it's rendered.

00:16:33.140 --> 00:16:38.810
All of that stuff was inspired
by the new properties on layers

00:16:38.970 --> 00:16:43.870
that we didn't have in Views,
so we said, okay, well,

00:16:43.870 --> 00:16:43.870
let's bring this up to the
View level and use Core Animation to

00:16:43.870 --> 00:16:43.870
do all of the rendering.

00:16:44.320 --> 00:16:46.830
Likewise,
AppKit will manage all the layer creation

00:16:46.830 --> 00:16:48.660
and refresh for you automatically.

00:16:48.710 --> 00:16:51.770
There is,
apart from one line of code in that demo

00:16:51.770 --> 00:16:54.420
where I throw the master switch and say,
OK,

00:16:54.420 --> 00:16:58.220
I want everything in this view subtree to
be rendered and animated using LayerKit,

00:16:58.220 --> 00:17:01.280
there's not one other line of
code in that app that has to worry

00:17:01.280 --> 00:17:03.080
about the existence of layers.

00:17:03.080 --> 00:17:04.380
This is all happening automatically.

00:17:04.470 --> 00:17:05.660
AppKit takes care of it.

00:17:05.710 --> 00:17:08.520
When a view needs redisplay,
the view gets redrawn into

00:17:08.520 --> 00:17:09.870
its layer and so forth.

00:17:09.930 --> 00:17:11.670
And AppKit manages the layers for you.

00:17:13.560 --> 00:17:15.310
However, if you do want to start
meddling with layers,

00:17:15.320 --> 00:17:18.010
if you want access to properties that
layers have that we maybe haven't

00:17:18.100 --> 00:17:22.020
mirrored up to the AppKit API,
some of the specialized stuff like 3D

00:17:22.020 --> 00:17:26.060
transforms like you saw in the State of
the Union demo and the building,

00:17:26.060 --> 00:17:29.420
the city of album art,
that kind of stuff, you can get out the

00:17:29.420 --> 00:17:30.620
layers if you want to.

00:17:30.620 --> 00:17:32.630
And you can even replace them
with your own layers if for some

00:17:32.630 --> 00:17:33.720
reason you wanted to do that.

00:17:33.790 --> 00:17:36.130
Likewise,
if you just want to work with layer

00:17:36.130 --> 00:17:39.960
trees in some particular part of your
window and you just want to build your

00:17:39.960 --> 00:17:40.820
own layer tree and have us render it,
you can do that.

00:17:40.820 --> 00:17:45.080
You just set up a view to
render a layer tree and you say,

00:17:45.080 --> 00:17:49.250
"Here's your root layer
and we'll do that for you."

00:17:49.950 --> 00:17:53.020
So here's how mirroring of
view content into layers works,

00:17:53.020 --> 00:17:55.300
just to sort of give us a mental picture.

00:17:55.300 --> 00:17:57.450
I've got my slide,
which is really sort of a subtree

00:17:57.450 --> 00:17:59.900
of views that's broken down
into the slide carrier view.

00:17:59.900 --> 00:18:01.450
And then I've got a button in there.

00:18:01.450 --> 00:18:03.680
I've got an image view,
and I've actually got a couple

00:18:03.750 --> 00:18:05.240
of text fields in the example.

00:18:05.240 --> 00:18:09.870
So we've got this view subtree to draw,
and AppKit sees this and sees that it's

00:18:09.870 --> 00:18:14.940
in a descendant of a view that's switched
on for Core Animation-backed rendering.

00:18:14.940 --> 00:18:18.740
So AppKit goes ahead and creates
when it's time to render.

00:18:19.240 --> 00:18:21.250
We create a layer for
each view automatically,

00:18:21.250 --> 00:18:22.740
and the layers start out empty.

00:18:22.740 --> 00:18:24.180
We size them to match the views.

00:18:24.180 --> 00:18:26.740
And when it's time to render, we say,
okay, we've got to push the

00:18:26.740 --> 00:18:28.040
content into the layers.

00:18:28.040 --> 00:18:30.060
So automatically,
the views get their content

00:18:30.110 --> 00:18:31.420
rendered into the layers.

00:18:31.420 --> 00:18:34.700
As far as the views are concerned,
they don't have to do anything special.

00:18:34.700 --> 00:18:36.740
Their draw rect gets called
when it's time to draw.

00:18:36.740 --> 00:18:40.510
The view just draws as usual,
except that AppKit behind the scenes

00:18:40.520 --> 00:18:44.320
has diverted that drawing into the
layers graphics context so that

00:18:44.320 --> 00:18:48.570
that drawing can be individually
buffered and cached for later use.

00:18:48.580 --> 00:18:51.530
And then the layer tree,
when it's time to draw the window,

00:18:51.610 --> 00:18:55.050
we composite the layer
tree using Core Animation.

00:18:56.400 --> 00:18:57.470
So how do you switch this on?

00:18:57.480 --> 00:18:57.940
This is neat.

00:18:57.940 --> 00:18:58.640
How do you turn it on?

00:18:58.640 --> 00:18:59.780
We want to make this real easy.

00:18:59.780 --> 00:19:02.210
So you choose a root view,
and you can do this for more

00:19:02.210 --> 00:19:03.320
than one view in a window.

00:19:03.320 --> 00:19:05.640
And you just say, set wants layer, yes.

00:19:05.640 --> 00:19:07.560
And that's how you
throw the master switch.

00:19:07.560 --> 00:19:09.800
And then AppKit takes care
of the rest after that.

00:19:09.870 --> 00:19:12.120
So when you do this for a view,
it has the following

00:19:12.120 --> 00:19:13.820
consequences and implications.

00:19:13.820 --> 00:19:16.770
AppKit mirrors the view subtree
automatically into a layer tree for you.

00:19:16.770 --> 00:19:18.070
So we'll create the layer tree.

00:19:18.070 --> 00:19:19.500
We'll update it as needed and so on.

00:19:19.500 --> 00:19:22.390
When you change properties of the views,
we'll change the corresponding

00:19:22.390 --> 00:19:23.180
layer properties.

00:19:23.260 --> 00:19:24.700
That all happens automatic.

00:19:25.920 --> 00:19:29.450
Views draw into their layers
via drawRect as before.

00:19:29.840 --> 00:19:32.760
When you do setNeedsDisplay for a view,
that carries over to the

00:19:32.850 --> 00:19:34.300
view's corresponding layer.

00:19:34.300 --> 00:19:37.140
So OK,
you've changed some of your view content.

00:19:37.140 --> 00:19:39.320
Your model has changed,
and you need to redraw some of the view.

00:19:39.320 --> 00:19:42.590
OK, so I need to do setNeedsDisplay
in this rect or setNeedsDisplay

00:19:42.670 --> 00:19:43.250
for the whole view.

00:19:43.290 --> 00:19:45.780
We note that, OK,
we need to do the same for the layer.

00:19:45.800 --> 00:19:49.900
And so when we redraw the view,
we'll refresh the layer content.

00:19:50.480 --> 00:19:53.580
View property changes map to
layer properties automatically.

00:19:53.680 --> 00:19:56.140
AppKit implements animation
of non-layer properties.

00:19:56.140 --> 00:19:58.010
So this is something
that we wanted to add.

00:19:58.020 --> 00:20:01.360
We wanted you to be able to animate more
than just the core geometric properties

00:20:01.360 --> 00:20:06.550
that you get for layers and enable you
to animate just about anything you want,

00:20:06.600 --> 00:20:07.710
including your own properties.

00:20:07.760 --> 00:20:10.040
And we'll see how to do that shortly.

00:20:10.170 --> 00:20:13.050
Finally,
any setting of this flag further down

00:20:13.140 --> 00:20:14.580
in the View subtree will be ignored.

00:20:14.580 --> 00:20:17.520
So we look for the root-most
view in an ancestor chain

00:20:17.520 --> 00:20:19.640
that has once layer enabled.

00:20:19.830 --> 00:20:22.270
And that will be the view from
which we start doing layer tree

00:20:22.280 --> 00:20:24.310
rendering all the way down.

00:20:24.960 --> 00:20:27.730
I mentioned some new view
properties that we've added,

00:20:27.790 --> 00:20:29.700
including visual properties.

00:20:29.700 --> 00:20:32.890
Every NSView now has an alpha value.

00:20:32.950 --> 00:20:34.900
This is named to match
the NSWindow property,

00:20:34.900 --> 00:20:36.560
and it works exactly the same.

00:20:36.570 --> 00:20:39.670
Once the view has drawn its content,
this is the overall opacity with which we

00:20:39.770 --> 00:20:41.480
will composite the view into the window.

00:20:41.480 --> 00:20:47.550
You could set it to zero and effectively
make a view invisible if you want.

00:20:47.550 --> 00:20:47.550
You can vary it, and you can animate it.

00:20:47.810 --> 00:20:50.100
Likewise, views have filters.

00:20:50.100 --> 00:20:53.110
You have the ability to specify
any core image filters that you

00:20:53.110 --> 00:20:56.760
want for the view's content,
for the background behind the view,

00:20:56.830 --> 00:20:59.320
and for-- actually,
you can specify any of the core

00:20:59.430 --> 00:21:02.960
image compositing filters if you
don't want source over compositing.

00:21:02.960 --> 00:21:04.540
Most of the time, you're not going to
be interested in that,

00:21:04.540 --> 00:21:07.800
but the content filters and background
filters are more interesting,

00:21:07.800 --> 00:21:09.460
because those are arrays of filters.

00:21:09.460 --> 00:21:10.970
Those are array-typed values.

00:21:11.110 --> 00:21:15.490
So you can actually specify maybe
you want to sepia tone and then blur

00:21:15.490 --> 00:21:17.720
and then do some other halo effect.

00:21:17.720 --> 00:21:18.340
You can do that.

00:21:18.340 --> 00:21:20.100
You just specify an
array of three filters,

00:21:20.100 --> 00:21:21.290
and boom, off you go.

00:21:21.300 --> 00:21:24.860
And we automatically-- AppKit or
actually Core Animation under the hood

00:21:24.860 --> 00:21:29.480
will link those filters together for
you and run your content through them.

00:21:29.480 --> 00:21:33.150
You can specify a per-view shadow,
much as you can specify

00:21:33.150 --> 00:21:34.460
a per-layer shadow.

00:21:34.460 --> 00:21:37.040
And at the AppKit level,
since we already had NSShadow

00:21:37.040 --> 00:21:40.400
as a convenient encapsulation
for expressing shadows,

00:21:40.400 --> 00:21:42.360
we used that as the type.

00:21:42.360 --> 00:21:45.800
Also, we provided some new
API for animation control.

00:21:45.800 --> 00:21:48.200
You can-- each view has
an animations dictionary,

00:21:48.200 --> 00:21:52.280
and each window also has an animations
dictionary that you can use to specify

00:21:52.280 --> 00:21:55.740
per instance what kinds of animations
you want for different properties.

00:21:55.740 --> 00:21:58.720
And we'll look at that in a bit later.

00:21:58.720 --> 00:22:02.170
And then finally,
the view's use of Core Animation for

00:22:02.170 --> 00:22:06.440
rendering and for animating is
controlled by that wants layer flag.

00:22:06.440 --> 00:22:09.420
And then you also have the ability
to get and potentially set the layer.

00:22:09.420 --> 00:22:13.010
So there's a layer getter,
and there's a set layer method also.

00:22:13.700 --> 00:22:15.910
So we're starting to
get into API inevitably,

00:22:15.910 --> 00:22:17.210
so let's just keep going.

00:22:17.210 --> 00:22:19.930
So what we'll look at in this
session is how to animate your

00:22:19.930 --> 00:22:23.610
views in Windows using the new API,
primarily focusing actually on views.

00:22:23.610 --> 00:22:25.710
We'll look at how to initiate animations.

00:22:25.710 --> 00:22:28.440
We'll look at view and window
properties that animate for

00:22:28.440 --> 00:22:30.030
you automatically by default.

00:22:30.030 --> 00:22:32.740
So you just have to specify
that you want animation and you

00:22:32.780 --> 00:22:34.300
get some default parameters.

00:22:34.300 --> 00:22:37.700
And we'll look at making your own
views custom properties animatable,

00:22:37.700 --> 00:22:38.580
which you can do.

00:22:38.670 --> 00:22:41.430
That was very important for us
to extend that to you so you can

00:22:41.430 --> 00:22:43.680
do it with arbitrary properties.

00:22:43.700 --> 00:22:46.130
of your own design.

00:22:46.350 --> 00:22:49.760
We'll look at building animation
specifications of various kinds for,

00:22:49.760 --> 00:22:52.420
I want a transition of
this particular type.

00:22:52.420 --> 00:22:54.600
Or I want something to
animate from A to B,

00:22:54.600 --> 00:22:57.280
but I want a particular
type of time curve on it.

00:22:57.300 --> 00:23:00.140
So we'll look at how you express
the kind of animation you want.

00:23:00.260 --> 00:23:02.360
And finally,
we'll look at applying filter effects

00:23:02.360 --> 00:23:04.780
to view content and how that works.

00:23:04.780 --> 00:23:08.000
So when we went to design this,
we went back to basics.

00:23:08.000 --> 00:23:11.040
And we said, well,
what fundamentally is animation?

00:23:11.040 --> 00:23:13.210
What does it mean to animate something?

00:23:13.230 --> 00:23:14.970
Objects have properties, obviously.

00:23:15.110 --> 00:23:18.050
Animation, when you think about it,
is really nothing more than varying

00:23:18.120 --> 00:23:21.190
a property of an object over time,
rather than setting

00:23:21.190 --> 00:23:22.980
that value immediately.

00:23:22.980 --> 00:23:25.030
So when you set a target
value for a property,

00:23:25.150 --> 00:23:27.760
you should be able to just say, OK,
I want this to go to there.

00:23:27.760 --> 00:23:28.900
And it's here right now.

00:23:28.900 --> 00:23:30.860
And go ahead and initiate an animation.

00:23:30.860 --> 00:23:34.040
It should be really easy to do that.

00:23:34.040 --> 00:23:37.440
So we provided default animation
parameters for all of the built-in

00:23:37.500 --> 00:23:40.040
view and window properties
that you might want to animate.

00:23:40.040 --> 00:23:42.110
And so animations just
sort of work when you say,

00:23:42.120 --> 00:23:43.920
OK, animate to here.

00:23:43.920 --> 00:23:46.480
There are opportunities given
to you to substitute different

00:23:46.590 --> 00:23:49.460
parameters if you want different
kind of animation to happen,

00:23:49.460 --> 00:23:51.490
different kind of timing.

00:23:51.820 --> 00:23:54.480
And any animation,
as you saw in the demo,

00:23:54.500 --> 00:23:57.400
that any new animation instructions
you give an object automatically

00:23:57.400 --> 00:24:00.020
supersede any in-flight animations
for the object property.

00:24:00.020 --> 00:24:03.820
We'll just start from where we are
now and move on to the new property.

00:24:03.820 --> 00:24:05.550
So how do you set a target value?

00:24:05.640 --> 00:24:06.720
How do you do this?

00:24:06.720 --> 00:24:09.340
We spent a lot of time thinking about
what the API should look like for this.

00:24:09.340 --> 00:24:12.520
Setting an immediate value,
like setting the frame of a view,

00:24:12.520 --> 00:24:14.660
just looks like view, set frame, rec.

00:24:14.770 --> 00:24:15.440
That's really simple.

00:24:15.440 --> 00:24:18.350
And we wanted to keep it as close
as we could to that simplicity

00:24:18.350 --> 00:24:20.100
without adding a lot of syntax.

00:24:20.320 --> 00:24:24.680
So we thought about, well, you know,
we've got NSWindows set

00:24:24.680 --> 00:24:26.540
frame animate method.

00:24:26.540 --> 00:24:30.980
And so we could add an animate with a
bool parameter to each of the setters.

00:24:30.980 --> 00:24:33.480
But then that becomes
an explosion of methods,

00:24:33.480 --> 00:24:35.560
and that requires us to rethink KVC.

00:24:35.560 --> 00:24:36.630
We didn't really want to do that.

00:24:36.740 --> 00:24:39.710
So we said, well, how about if we,
what we ended up coming up with

00:24:39.710 --> 00:24:41.340
is this concept of an animator.

00:24:41.340 --> 00:24:44.910
So views and windows
have animator objects.

00:24:44.940 --> 00:24:46.260
You can ask a view for its animator.

00:24:46.260 --> 00:24:47.800
You can ask a window for its animator.

00:24:48.940 --> 00:24:50.870
And then all you have to
do is message the animator

00:24:50.870 --> 00:24:52.300
instead of the view or window.

00:24:52.300 --> 00:24:53.800
So you insert a little extra syntax.

00:24:53.800 --> 00:24:55.680
You say view animator set frame.

00:24:55.760 --> 00:24:58.350
And that's all you have to do
to move a frame from A to B and

00:24:58.350 --> 00:25:00.120
have it animate automatically.

00:25:00.220 --> 00:25:02.550
And this goes for a lot
of other properties,

00:25:02.550 --> 00:25:04.880
not just frame, frame rotation.

00:25:04.880 --> 00:25:07.210
You want to set the alpha value
and have that fade to a new value.

00:25:07.300 --> 00:25:08.300
You can do that, too.

00:25:08.400 --> 00:25:11.150
So what exactly is an animator?

00:25:11.380 --> 00:25:15.890
An animator is a proxy in a sense,
somewhat similar in concept, at least,

00:25:15.890 --> 00:25:16.660
to NSProxy.

00:25:16.660 --> 00:25:17.560
They aren't necessarily NSProxies.

00:25:17.560 --> 00:25:21.960
It's a proxy for a target object
that has animatable properties

00:25:21.960 --> 00:25:23.790
like a view or a window.

00:25:24.100 --> 00:25:27.760
You can treat the proxy as if it was the
type of the object that you got it from.

00:25:27.780 --> 00:25:29.820
So you get a views animator.

00:25:29.820 --> 00:25:32.470
You can basically treat that
as if it was the view itself.

00:25:32.540 --> 00:25:35.280
You can send it the same kinds of
messages the view can respond to.

00:25:35.280 --> 00:25:39.990
And in fact, you can even pass it to code
that expects to get a view.

00:25:39.990 --> 00:25:42.220
And that's perfectly valid.

00:25:42.220 --> 00:25:44.840
And in fact, in the demo there,
all of that layout code was written

00:25:44.840 --> 00:25:46.620
thinking that it's dealing with views.

00:25:46.620 --> 00:25:49.190
I pass it a view, and I say,
layout subview's a view.

00:25:49.190 --> 00:25:52.300
And I've got a circular layout function,
and I've got the infinite

00:25:52.400 --> 00:25:53.700
loop layout function.

00:25:54.000 --> 00:25:56.280
And those just think they're
dealing with views directly,

00:25:56.390 --> 00:25:58.000
and the parameters are typed as NSView.

00:25:58.000 --> 00:26:01.330
What I'm doing is passing an
animator in for the view that's

00:26:01.330 --> 00:26:04.520
the container view there,
and then everything just sort of works.

00:26:04.520 --> 00:26:07.640
So if you have existing layout code
that's written to just interact

00:26:07.640 --> 00:26:11.220
with views and set their properties,
or not even layout code necessarily,

00:26:11.220 --> 00:26:14.480
but code that sets properties on
a whole bunch of views in your UI,

00:26:14.480 --> 00:26:18.000
you can animate those changes
now very easily just by

00:26:18.000 --> 00:26:20.510
surrounding it with some context.

00:26:21.000 --> 00:26:24.830
So when you send value
set messages to the proxy,

00:26:24.830 --> 00:26:28.440
or the animator rather,
those can initiate animations.

00:26:28.440 --> 00:26:32.040
And what happens when you do that,
first we search the target

00:26:32.060 --> 00:26:34.040
object for an animation to use.

00:26:34.040 --> 00:26:36.040
So the target object in
this case would be the view.

00:26:36.040 --> 00:26:37.500
You get a views animator.

00:26:37.500 --> 00:26:38.750
The target object is the view.

00:26:38.760 --> 00:26:43.410
We search the view for, OK,
this property is going to animate.

00:26:43.500 --> 00:26:46.820
What kind of animation should I use?

00:26:46.820 --> 00:26:49.020
The property's name is the search key.

00:26:49.020 --> 00:26:51.600
So if we're changing the frame origin,
the string coming in there

00:26:51.600 --> 00:26:52.920
will be frame origin.

00:26:52.920 --> 00:26:55.940
And that's what we'll use for the lookup,
or if it's frame or alpha value,

00:26:55.940 --> 00:26:57.900
that sort of thing.

00:26:57.900 --> 00:27:02.020
AppKit then checks the current
NSAnimationContext duration.

00:27:02.020 --> 00:27:05.140
NSAnimationContext is a brand new
class that we've introduced in Leopard.

00:27:05.140 --> 00:27:08.100
And I'm going to discuss
that in the next slide.

00:27:08.940 --> 00:27:12.700
If we find an animation and we find
that the duration in the surrounding

00:27:12.700 --> 00:27:15.990
animation context is greater than zero,
we initiate an animation to

00:27:15.990 --> 00:27:17.400
the specified target value.

00:27:17.400 --> 00:27:18.700
So those are the two things we need.

00:27:18.790 --> 00:27:20.600
We need to find an animation to use.

00:27:20.600 --> 00:27:22.290
If we don't find an animation,
we assume you don't want

00:27:22.290 --> 00:27:23.220
the property animated.

00:27:23.220 --> 00:27:25.380
If we find a zero duration,
we assume you don't want the

00:27:25.380 --> 00:27:26.590
property animated either.

00:27:26.590 --> 00:27:29.040
You don't want anything
animated within that context.

00:27:29.220 --> 00:27:31.620
By default though,
AppKit provides default animations

00:27:31.990 --> 00:27:35.620
for all the standard properties like
frame that you might want to animate.

00:27:35.620 --> 00:27:38.080
And likewise,
we provide a default context

00:27:38.080 --> 00:27:41.540
duration of a quarter second,
the same as Core Animation.

00:27:41.540 --> 00:27:43.790
So you don't even have to worry
about setting those for a lot of

00:27:43.870 --> 00:27:46.280
things and you just have to message
the animator and that's all you

00:27:46.280 --> 00:27:47.910
have to do to get things to animate.

00:27:47.920 --> 00:27:51.190
So if we find an animation,
duration is greater than zero,

00:27:51.190 --> 00:27:55.200
we initiate an animation,
the proxy passes everything else through.

00:27:55.200 --> 00:27:58.810
So that's sort of the general
proxy behavior that you expect.

00:27:59.220 --> 00:28:00.220
Thank you.

00:28:00.770 --> 00:28:04.460
So NSAnimationContext, I mentioned,
is a new class in Leopard.

00:28:04.460 --> 00:28:07.320
And you can think of NSAnimationContexts
in a sense they're sort of

00:28:07.330 --> 00:28:10.210
analogous to graphics contexts
in that they hold state.

00:28:10.210 --> 00:28:13.480
And each thread has a
stack of these of its own.

00:28:13.520 --> 00:28:15.700
And there's always a
current animation context,

00:28:15.700 --> 00:28:18.220
just like there's always a
current graphics context.

00:28:18.220 --> 00:28:20.900
And the properties are per context.

00:28:21.380 --> 00:28:24.870
Right now,
the only property that NSAnimationContext

00:28:24.890 --> 00:28:28.990
holds is the duration that is
used for implied animations.

00:28:29.060 --> 00:28:31.880
For any animation that doesn't have
a duration explicitly specified,

00:28:31.990 --> 00:28:33.690
we just take the duration
from the context.

00:28:33.740 --> 00:28:36.620
And that makes it real easy to say, okay,
I'm going to animate a bunch of stuff.

00:28:36.700 --> 00:28:38.020
I want a duration of one second.

00:28:38.020 --> 00:28:40.770
I set that up in the context,
and then I just message animators

00:28:40.770 --> 00:28:42.160
to change the properties.

00:28:42.160 --> 00:28:45.070
And it just goes,
and everything has the same duration.

00:28:45.080 --> 00:28:48.150
NSAnimationContexts are
somewhat analogous to

00:28:48.150 --> 00:28:50.660
Core Animation's LKTransactions.

00:28:51.320 --> 00:28:55.300
Which you will learn about if
you study the Core Animation API.

00:28:55.300 --> 00:28:59.240
Typical usage for an animation
context is you begin a grouping,

00:28:59.240 --> 00:29:01.090
and then you set the
duration that you want,

00:29:01.090 --> 00:29:03.140
and then you do a bunch
of animation operations,

00:29:03.140 --> 00:29:04.380
and you end the grouping.

00:29:04.380 --> 00:29:07.980
So begin grouping is sort of like pushing
an animation context on the stack.

00:29:07.980 --> 00:29:10.600
You get a fresh context that's
a copy of the previous one.

00:29:10.600 --> 00:29:12.780
So by default,
you inherit the duration from the

00:29:12.850 --> 00:29:14.740
context that was previously active.

00:29:14.740 --> 00:29:18.800
And then you can say NSAnimationContext,
current context, set duration.

00:29:18.800 --> 00:29:20.680
And here I'm setting it to a half second.

00:29:20.680 --> 00:29:21.300
Because I'm going to
animate a bunch of stuff.

00:29:21.300 --> 00:29:23.660
And I want all the animations
in that grouping to have a half

00:29:23.660 --> 00:29:24.740
second duration by default.

00:29:24.790 --> 00:29:26.160
You can nest these.

00:29:26.160 --> 00:29:30.660
So you can group things such that
they have different durations.

00:29:30.660 --> 00:29:33.670
And you can stack these
up as high as you want.

00:29:33.760 --> 00:29:37.650
The two main significant points
for NSAnimationContext is that all

00:29:37.690 --> 00:29:41.800
the animations that you initiate
within a grouping have the same

00:29:41.800 --> 00:29:43.820
inherited implied duration.

00:29:43.820 --> 00:29:47.180
And they all also implicitly
start at the same time.

00:29:47.180 --> 00:29:49.180
They're guaranteed to start
in a synchronized way.

00:29:49.180 --> 00:29:51.280
So when you end the grouping,
that's when we fire off the animation.

00:29:51.280 --> 00:29:54.490
So it doesn't matter how long it
takes you to assemble this in code.

00:29:54.500 --> 00:29:58.860
We will synchronize all the animations
unless they have explicit begin times.

00:30:00.160 --> 00:30:03.160
So as I said, this is sort of a
general set of concepts.

00:30:03.210 --> 00:30:07.240
We thought all objects
that have properties,

00:30:07.240 --> 00:30:09.860
you may potentially want to be
able to animate those properties.

00:30:09.860 --> 00:30:12.500
So we defined an
NSAnimatablePropertyContainer

00:30:12.570 --> 00:30:14.440
protocol that's new in Leopard.

00:30:14.440 --> 00:30:17.560
This is declared at the
top of NSAnimation.h.

00:30:17.560 --> 00:30:19.910
So an animatable property
container is anything that has

00:30:20.090 --> 00:30:21.360
properties that can be animated.

00:30:21.360 --> 00:30:24.890
And right now in your Leopard seed,
views and windows both conform to the

00:30:24.890 --> 00:30:27.240
NSAnimatablePropertyContainer protocol.

00:30:27.380 --> 00:30:31.720
And we're considering extending that to
other classes potentially in the future.

00:30:31.720 --> 00:30:35.740
So there are five methods that every
animatable property container implements.

00:30:35.740 --> 00:30:38.640
You can get an animatable
property containers animator.

00:30:38.650 --> 00:30:42.820
You can get and set a dictionary of
animations on a per instance basis.

00:30:42.880 --> 00:30:46.160
There's also a class method,
default animation for key,

00:30:46.160 --> 00:30:50.960
that you can override to specify on a
per class basis what sorts of animations

00:30:51.150 --> 00:30:55.600
you want to respond to different kinds
of property changes for different keys.

00:30:55.600 --> 00:30:58.770
And then there's animation for key,
which I'm going to discuss in a moment,

00:30:58.770 --> 00:31:02.920
which is sort of a top level search
mechanism through which AppKit and

00:31:02.920 --> 00:31:06.720
CoreAnimation find the animation to use.

00:31:06.890 --> 00:31:09.190
So here's how the search process works,
just briefly.

00:31:09.340 --> 00:31:11.520
Animation for Key is the
top-level method that we invoke.

00:31:11.580 --> 00:31:14.770
So you've messaged an
animator and you've said,

00:31:14.800 --> 00:31:16.770
you know, view animator, set frame,
and we say, okay,

00:31:16.770 --> 00:31:19.040
they're trying to change the
frame through the animator.

00:31:19.040 --> 00:31:21.320
Let's look for an animation
that corresponds to frame.

00:31:21.320 --> 00:31:22.880
So we'll invoke Animation for Key.

00:31:22.920 --> 00:31:24.180
The key name will be frame.

00:31:24.180 --> 00:31:27.060
And we'll look in the object's
animations dictionary.

00:31:27.060 --> 00:31:29.970
So per instance animation settings
override per class settings,

00:31:29.970 --> 00:31:30.980
as you might expect.

00:31:31.840 --> 00:31:35.360
If we don't find one there,
we'll check the object's class's

00:31:35.360 --> 00:31:39.320
default animation for key method
and see if the class has specified

00:31:39.320 --> 00:31:43.180
an animation for the frame key or
whatever the property key may be.

00:31:43.180 --> 00:31:47.620
So again, Animation for Key first checks
the instance dictionary and then

00:31:47.620 --> 00:31:49.460
calls default animation for key.

00:31:51.180 --> 00:31:54.200
To make it so that you don't have to be
specifying these all the time explicitly,

00:31:54.260 --> 00:31:57.340
for all of the default
view and window properties,

00:31:57.360 --> 00:31:59.600
we've specified default simple
animations of interpolation

00:31:59.600 --> 00:31:59.600
from the object to the key.

00:31:59.600 --> 00:31:59.600
So we've got a lot of
different options here.

00:31:59.600 --> 00:31:59.600
We've got the default animation for key,
and we've got the default

00:31:59.600 --> 00:31:59.600
animation for key.

00:31:59.600 --> 00:31:59.600
So we've got the default
animation for key,

00:31:59.600 --> 00:31:59.600
and we've got the default
animation for key.

00:31:59.800 --> 00:32:00.420
So we've got the default
animation for key,

00:32:00.420 --> 00:32:01.180
and we've got the default
animation for key.

00:32:01.280 --> 00:32:04.770
target from initial position to target.

00:32:04.790 --> 00:32:09.160
So views frame origin, frame size,
frame rotation,

00:32:09.160 --> 00:32:12.920
all the frame parameters are animatable,
all the bounds parameters.

00:32:13.130 --> 00:32:17.400
So all the geometric stuff has
default animation specified for you.

00:32:17.400 --> 00:32:18.550
You don't have to specify them.

00:32:18.640 --> 00:32:19.560
Same for alpha value.

00:32:19.560 --> 00:32:22.100
All the filter properties
for when subviews change,

00:32:22.100 --> 00:32:24.240
by default, you get a fade animation.

00:32:24.240 --> 00:32:27.710
And there's also this nsanimation
trigger order in and out set of

00:32:27.710 --> 00:32:33.100
constants that you can pass in
that are defined in nsanimation.h.

00:32:33.100 --> 00:32:37.440
And that's analogous to adding a view
to its super view or removing the view.

00:32:37.440 --> 00:32:39.790
So you can specify,
if you want to specify a transition

00:32:39.890 --> 00:32:42.380
for when the view is added
or when the view is removed,

00:32:42.380 --> 00:32:43.830
you can do that sort of thing.

00:32:43.900 --> 00:32:47.140
For nswindow,
currently alpha value and frame have

00:32:47.190 --> 00:32:48.800
default animation specified for them.

00:32:48.800 --> 00:32:51.140
But as I said,
we didn't want to limit you to just

00:32:51.140 --> 00:32:54.120
animating the built-in kind of stuff
that we provide in the app kit,

00:32:54.130 --> 00:32:56.920
all the standard properties
of views in Windows.

00:32:56.920 --> 00:32:59.530
So you can enable animation of
your own properties that you

00:32:59.530 --> 00:33:01.820
define in your own view subclasses.

00:33:01.880 --> 00:33:03.820
The way to do this,
you can specify-- again,

00:33:03.820 --> 00:33:07.350
you specify an animation either on a
per instance basis or more commonly,

00:33:07.350 --> 00:33:09.480
you'll want to do it
on a per class basis.

00:33:09.480 --> 00:33:13.220
In either case, you're mapping property
name keys to LK animations.

00:33:13.220 --> 00:33:16.200
AppKit knows how to interpolate
some of the basic scalar types,

00:33:16.200 --> 00:33:20.960
so floats, doubles, CG floats, NS points,
NS sizes, NS recs,

00:33:20.960 --> 00:33:24.000
all the geometric aggregates
of those automatically.

00:33:24.000 --> 00:33:27.210
So for all those types of properties,
anything that you have that's of one of

00:33:27.210 --> 00:33:28.770
those types is potentially animatable.

00:33:28.780 --> 00:33:32.110
And there are a couple
of steps to doing this.

00:33:32.300 --> 00:33:34.720
First,
you want to have a KVC compliant setter

00:33:34.720 --> 00:33:37.630
method that the animator proxy can find.

00:33:37.720 --> 00:33:41.720
And so let's say I have a class, myView,
that has a border width property

00:33:41.790 --> 00:33:44.960
that defines how thick the
border that the view draws is.

00:33:44.960 --> 00:33:48.110
And it's really important that
I be able to animate this because

00:33:48.110 --> 00:33:49.940
that enhances the user experience.

00:33:49.940 --> 00:33:51.200
So I have a set border width.

00:33:51.200 --> 00:33:53.160
At minimum,
I need a KVC compliant setter method,

00:33:53.160 --> 00:33:58.470
set border width here,
that gets the new value, stores it,

00:33:58.520 --> 00:34:00.520
and then starts the view as
needing redisplay in whatever

00:34:00.520 --> 00:34:01.420
areas are affected by that.

00:34:01.420 --> 00:34:02.550
So you should be doing this.

00:34:02.600 --> 00:34:03.560
You need this already.

00:34:03.560 --> 00:34:06.720
So really, there is no step one here.

00:34:06.720 --> 00:34:09.860
Step two is to do something
like specify an animation,

00:34:09.860 --> 00:34:12.360
either by overriding default
animation for key or setting it

00:34:12.430 --> 00:34:13.820
in the per instance dictionary.

00:34:13.820 --> 00:34:15.420
Normally,
you're writing a new view class.

00:34:15.420 --> 00:34:17.780
And if you want a property
to just animate by default,

00:34:17.780 --> 00:34:19.280
override default animation for key.

00:34:19.280 --> 00:34:22.220
And then people don't have to
individually configure their instances.

00:34:22.220 --> 00:34:25.600
And if they want to override and replace
the animation that you specified,

00:34:25.600 --> 00:34:26.140
that's fine.

00:34:26.140 --> 00:34:26.930
They can do that too.

00:34:26.980 --> 00:34:28.500
But then they have a
default to fall back to.

00:34:28.610 --> 00:34:30.980
So here, I've done this for border width.

00:34:30.980 --> 00:34:35.160
I've overridden default animation
for key for my view subclass.

00:34:35.160 --> 00:34:37.620
I'm looking for the border
width key to be coming in.

00:34:37.620 --> 00:34:41.420
And if I see it,
I'm returning an LK basic animation.

00:34:41.420 --> 00:34:44.300
And that is one of four
concrete animation classes

00:34:44.300 --> 00:34:45.640
that Core Animation provides.

00:34:45.640 --> 00:34:47.920
We're going to look at those
in detail to see what kinds

00:34:47.920 --> 00:34:49.280
of animations you can specify.

00:34:49.280 --> 00:34:51.590
This is just saying,
this is the most basic kind

00:34:51.600 --> 00:34:53.860
of animation that there is,
as its name suggests.

00:34:53.860 --> 00:34:56.280
It's an interpolation
with a standard curve.

00:34:56.280 --> 00:34:58.260
And the duration is implied,
and so forth.

00:34:58.260 --> 00:35:01.390
So I'm saying, basically,
all I'm saying is I want

00:35:01.390 --> 00:35:03.320
border width to animate.

00:35:03.320 --> 00:35:05.360
And then,
any time you override this method,

00:35:05.360 --> 00:35:08.320
you want to invoke supers implementation
for any keys you don't recognize.

00:35:08.320 --> 00:35:11.790
So we're doing that here at the bottom.

00:35:12.100 --> 00:35:15.960
So what kinds of
animations can we describe?

00:35:15.960 --> 00:35:17.360
We thought about this for a while.

00:35:17.360 --> 00:35:22.700
And Core Animation has a very
rich set of expressive classes

00:35:22.700 --> 00:35:24.200
for describing animations.

00:35:24.200 --> 00:35:26.660
We thought about, well,
should we wrap this in the AppKit API?

00:35:26.660 --> 00:35:29.700
And it turned out there was really
no clear benefit to doing so.

00:35:29.700 --> 00:35:32.510
So what we've done is we've gone
ahead and used the LKAnimation

00:35:32.560 --> 00:35:34.960
classes directly in the AppKit API.

00:35:34.960 --> 00:35:36.580
So you just create LKAnimations.

00:35:36.580 --> 00:35:38.650
And these are really
actually very simple classes.

00:35:38.670 --> 00:35:41.300
They're very suitable for that
because they're basically massive

00:35:41.300 --> 00:35:43.540
containers for properties,
properties that have

00:35:43.860 --> 00:35:45.620
implied default values.

00:35:45.620 --> 00:35:49.150
So at the root, you have LKAnimation,
which defines the basic

00:35:49.150 --> 00:35:52.080
animation-- the basic properties
that all animations have.

00:35:52.080 --> 00:35:56.250
And animation can have a timing function,
which basically gives you the opportunity

00:35:56.250 --> 00:36:00.560
to specify some nonlinear progress
curve that the animation will follow.

00:36:00.560 --> 00:36:02.220
And animation can also have a delegate.

00:36:02.220 --> 00:36:05.090
So if you're interested in
knowing when the animation starts

00:36:05.140 --> 00:36:09.340
and when the animation stops,
you can get callbacks, objc messages,

00:36:09.340 --> 00:36:11.830
to your delegate by
wiring the delegate up.

00:36:11.930 --> 00:36:15.040
From LKAnimation is derived
LKPropertyAnimation,

00:36:15.040 --> 00:36:17.240
which is still a semi-abstract class.

00:36:17.240 --> 00:36:22.020
It's the root class for animations
that animate properties,

00:36:22.030 --> 00:36:24.340
things that have identifiable names.

00:36:24.430 --> 00:36:27.330
So a property animation has
a key path that specifies

00:36:27.330 --> 00:36:29.650
the property to be animated.

00:36:29.900 --> 00:36:32.060
Normally,
you just leave the key path empty.

00:36:32.060 --> 00:36:34.340
You just leave it to be implied.

00:36:34.340 --> 00:36:36.310
Because when you message, say,
a view through its

00:36:36.310 --> 00:36:38.820
animator to set its frame,
well, we know that frame is the key.

00:36:38.940 --> 00:36:40.040
And we'll fill that in for you.

00:36:40.050 --> 00:36:43.980
But what this lets you do is if
you explicitly set the key path,

00:36:43.980 --> 00:36:47.460
you can specify that something
else is to be animated when that

00:36:47.460 --> 00:36:49.200
change fires for that property.

00:36:49.200 --> 00:36:53.300
So OK, when subviews changes,
maybe I want my frame to animate.

00:36:53.300 --> 00:36:57.040
And you can use an explicit key path
setting to do that kind of thing.

00:36:57.040 --> 00:37:00.990
You can specify whether animations
are additive or cumulative.

00:37:01.180 --> 00:37:05.060
That's something that's mainly used
by core animation at this point.

00:37:05.060 --> 00:37:07.300
And then so if we want
a concrete animation,

00:37:07.300 --> 00:37:08.460
there's LKBasicAnimation.

00:37:08.460 --> 00:37:09.950
This is the most common
kind you're going to use.

00:37:09.960 --> 00:37:11.770
It's derived from LKPropertyAnimation.

00:37:11.960 --> 00:37:15.760
Basic animation has a from value and
a to value and an optional by value.

00:37:15.760 --> 00:37:18.160
And normally,
we just let this all be implied.

00:37:18.160 --> 00:37:21.330
You're setting the to value when
you message the animator to set

00:37:21.340 --> 00:37:23.020
the target value for the property.

00:37:23.020 --> 00:37:25.940
The from value we get from where
the object is right now and

00:37:25.940 --> 00:37:27.460
likewise for core animation.

00:37:27.460 --> 00:37:29.760
So if you want to get a little
more complicated than that,

00:37:29.760 --> 00:37:34.020
there's LKKeyframeAnimation,
which lets you specify basically a

00:37:34.020 --> 00:37:39.160
series of waypoints so that you can have
something animate from A to B to C to D,

00:37:39.160 --> 00:37:39.880
either geometrically.

00:37:39.880 --> 00:37:42.640
Or in terms of any other
property that's animatable.

00:37:42.640 --> 00:37:45.880
So a keyframe animation has
a set of waypoint values,

00:37:45.880 --> 00:37:49.700
a set of key times,
a path that it can follow potentially.

00:37:49.700 --> 00:37:55.010
You can specify an array of timing
functions now instead of a single overall

00:37:55.010 --> 00:37:57.820
timing function and a calculation mode.

00:37:57.820 --> 00:38:01.320
So those are sort of the two
animation types for most properties.

00:38:01.320 --> 00:38:02.780
But you also want to be
able to have things like

00:38:02.780 --> 00:38:04.340
transitions that you can express.

00:38:04.340 --> 00:38:08.120
So there's the LKTransition class,
which is derived from LKAnimation.

00:38:08.120 --> 00:38:11.600
A transition has a type,
which sort of expresses the overall

00:38:11.700 --> 00:38:13.420
kind of transition you want.

00:38:13.420 --> 00:38:15.900
There are four types
defined by layer kit,

00:38:15.900 --> 00:38:18.470
rather by core animation.

00:38:18.540 --> 00:38:21.780
The subtype expresses basically
the direction of the transition.

00:38:21.780 --> 00:38:24.810
So you want something to slide from
left to right or top to bottom,

00:38:24.810 --> 00:38:27.020
similar to the way you
pick things in Keynote.

00:38:27.020 --> 00:38:29.560
You pick the overall transition
and then set parameters.

00:38:29.560 --> 00:38:32.520
You can set start and
end progress if you want.

00:38:32.520 --> 00:38:34.180
But normally those are just implied.

00:38:34.180 --> 00:38:35.220
And you can set a filter.

00:38:35.220 --> 00:38:38.260
Like I said, you can take any core
image transition filter,

00:38:38.290 --> 00:38:43.360
which is one of a set of-- one of a class
of filters that QuartzCore provides,

00:38:43.360 --> 00:38:45.430
and say, hey,
I want you to use this filter and

00:38:45.440 --> 00:38:47.720
do a ripple transition or something.

00:38:47.720 --> 00:38:51.790
When you specify that filter property,
that overrides the type and subtype,

00:38:51.790 --> 00:38:53.400
and those are ignored.

00:38:53.400 --> 00:38:56.400
So there's one other class,
LKAnimationGroup.

00:38:56.400 --> 00:38:58.360
And that's basically like
an array of animations.

00:38:58.360 --> 00:39:01.800
That gives you the opportunity to,
instead of specifying one animation,

00:39:01.800 --> 00:39:04.040
maybe you want to aggregate a
whole bunch of them together.

00:39:04.040 --> 00:39:05.580
So you can do that with LKAnimationGroup.

00:39:05.600 --> 00:39:06.620
It just has one property.

00:39:06.670 --> 00:39:09.640
It's the array of animations,
and that lets you define--

00:39:09.770 --> 00:39:12.850
potentially complex compound
animations that have a whole bunch

00:39:12.850 --> 00:39:14.340
of things in flight all at once.

00:39:14.340 --> 00:39:16.060
So it looks like a lot
of complexity here,

00:39:16.060 --> 00:39:16.640
a lot of stuff.

00:39:16.690 --> 00:39:19.030
But really,
there are only four concrete classes

00:39:19.040 --> 00:39:20.090
that you need to be concerned with.

00:39:20.130 --> 00:39:22.560
And a lot of the time,
you're just going to be wanting a

00:39:22.560 --> 00:39:24.220
basic animation or a transition.

00:39:24.220 --> 00:39:26.360
And then maybe you start to
get more complex with the

00:39:26.420 --> 00:39:28.800
groups and keyframe animations.

00:39:29.520 --> 00:39:33.160
So, much like comedy,
animation is all about timing.

00:39:33.220 --> 00:39:36.780
And up here you may have noticed
the LK timing protocol that

00:39:36.780 --> 00:39:39.400
all LK animations conform to.

00:39:39.400 --> 00:39:42.160
And we'll look at that in
detail because those timing

00:39:42.160 --> 00:39:45.970
properties are very important for
defining how animations behave.

00:39:48.240 --> 00:39:49.240
So, most basic property of all, duration.

00:39:49.240 --> 00:39:51.080
How long do you want the
animation to execute for?

00:39:51.080 --> 00:39:54.720
It's just an interval in
time value in seconds.

00:39:54.720 --> 00:39:57.730
The default value is zero,
which implies that we're going

00:39:57.730 --> 00:40:01.030
to get the duration from the
surrounding NS animation context.

00:40:01.080 --> 00:40:02.610
Or if you're using
Core Animation directly,

00:40:02.620 --> 00:40:05.080
you're going to get the duration
from the surrounding transaction.

00:40:05.710 --> 00:40:07.790
Likewise, there's a begin time
that's implied to be,

00:40:07.790 --> 00:40:09.770
well,
whenever I close the animation context.

00:40:09.770 --> 00:40:13.080
That's when I want you to begin it,
whenever I'm initiating the animation.

00:40:13.560 --> 00:40:15.670
But you can specify a begin time
in the future so that you can

00:40:15.680 --> 00:40:17.080
explicitly get the duration.

00:40:18.330 --> 00:40:21.640
So,
you can set an animation to auto-reverse,

00:40:21.640 --> 00:40:25.080
so that gives you an easy way
to go from A to B and back to A.

00:40:25.080 --> 00:40:27.080
And you can potentially
repeat that animation.

00:40:27.080 --> 00:40:30.080
And that also works together
with the auto-reverse property.

00:40:30.450 --> 00:40:32.070
So, you can set, there are a couple of
ways you can repeat.

00:40:32.150 --> 00:40:35.080
You can either set a repeat count,
so I want this to repeat seven times.

00:40:35.080 --> 00:40:38.820
Or you can specify a repeat duration,
which is how long overall do

00:40:38.820 --> 00:40:41.070
I want this animation to run for.

00:40:42.730 --> 00:40:46.920
You can specify a time
offset and a speed.

00:40:46.920 --> 00:40:46.920
And this is what I want to do.

00:40:47.540 --> 00:40:50.920
And these are parameters that are used
primarily by core animation right now

00:40:50.920 --> 00:40:54.790
because you have the concept of nestable,
just the same as you have local

00:40:54.890 --> 00:40:57.880
space coordinate systems for layers.

00:40:58.290 --> 00:40:59.920
Each layer can have its own
local time coordinate system.

00:40:59.920 --> 00:41:02.920
And this is also significant
for LK animation groups,

00:41:02.920 --> 00:41:04.920
which is why it matters for
AppKit based animations.

00:41:05.470 --> 00:41:08.200
Because you can define a group to have
its own local time coordinate system

00:41:08.300 --> 00:41:09.920
that's convenient for you to work with.

00:41:09.920 --> 00:41:11.920
You can scale time.

00:41:11.920 --> 00:41:12.920
You can specify an offset.

00:41:13.990 --> 00:41:16.560
There's also finally
a fill mode parameter.

00:41:17.540 --> 00:41:21.760
That defines basically how things
end up when the animation terminates.

00:41:21.760 --> 00:41:24.760
Does it stay in the layer tree,
in the render tree or not?

00:41:24.760 --> 00:41:26.290
That's mainly used by core animation.

00:41:26.290 --> 00:41:28.000
We don't really touch
that at the AppKit level,

00:41:28.000 --> 00:41:28.710
but it's there.

00:41:29.520 --> 00:41:32.610
So, as I mentioned,
you can define local time coordinate

00:41:32.610 --> 00:41:34.760
systems within an animation group.

00:41:34.760 --> 00:41:36.660
And this is just a
simple linear equation.

00:41:36.760 --> 00:41:38.760
Normally your speed is one
and your time offset is zero.

00:41:39.440 --> 00:41:42.040
So really it's just sort of
an offset calculation to get

00:41:42.040 --> 00:41:43.760
down into the animation group.

00:41:43.760 --> 00:41:46.600
So you can define an animation
group so that your time is zero.

00:41:47.800 --> 00:41:50.500
And you don't have to worry about
what the surrounding absolute time is.

00:41:51.260 --> 00:41:52.600
So just some handy stuff.

00:41:52.600 --> 00:41:55.630
Most of the time you're just
interested in duration and begin time.

00:41:55.830 --> 00:41:58.640
So how do we create these instances,
these basic animations?

00:41:58.640 --> 00:42:01.720
We saw how you just create a basic
animation with default parameters,

00:42:01.720 --> 00:42:03.440
LKBasicAnimation, animation.

00:42:03.440 --> 00:42:04.220
It's that simple.

00:42:04.280 --> 00:42:07.630
And animation, by the way,
is the defined factory method

00:42:07.750 --> 00:42:09.520
for all classes of LKAnimation.

00:42:09.520 --> 00:42:12.930
So it doesn't matter if you're creating
an LKTransition or an LKBasicAnimation,

00:42:12.930 --> 00:42:14.200
you just send it an animation message.

00:42:14.200 --> 00:42:17.680
This creates you an
auto-released instance.

00:42:17.800 --> 00:42:19.960
Say you want to then take
that basic animation,

00:42:19.960 --> 00:42:21.160
set a duration of one second.

00:42:21.160 --> 00:42:23.000
Real simple, set duration 1.0.

00:42:23.140 --> 00:42:26.240
You want to add a delegate, anim,
set delegate,

00:42:26.250 --> 00:42:28.470
and specify your delegate object.

00:42:28.660 --> 00:42:30.620
Creating animation
groups is pretty simple.

00:42:30.620 --> 00:42:34.460
You just instantiate the animation group,
LKAnimationGroupAnimation,

00:42:34.460 --> 00:42:37.420
and then you set the group's
animations as an array.

00:42:37.630 --> 00:42:40.490
And the interesting thing about
animation groups is they don't

00:42:40.490 --> 00:42:43.220
have any implied sequence,
really, although an array is

00:42:43.220 --> 00:42:44.350
an ordered collection.

00:42:44.490 --> 00:42:46.000
The sequence isn't really important here.

00:42:46.000 --> 00:42:49.750
You can use an animation group to
have animations batched together

00:42:49.760 --> 00:42:51.240
that execute simultaneously.

00:42:51.240 --> 00:42:53.060
Like if you give them
all the same begin time.

00:42:53.120 --> 00:42:55.720
You can have animations
that run sequentially.

00:42:55.720 --> 00:42:59.370
Have anim2 begin after
anim1 has terminated.

00:42:59.410 --> 00:43:00.760
You can set it up that way.

00:43:00.760 --> 00:43:03.440
You can have animations overlapping
within an animation group.

00:43:03.530 --> 00:43:06.000
You can have time gaps where
nothing's happening and you're waiting

00:43:06.000 --> 00:43:07.350
for the next animation to start.

00:43:07.370 --> 00:43:11.100
So you can define sort of the timeline
of an animation group however you want.

00:43:11.120 --> 00:43:14.640
So that's a very powerful feature
for collecting animations together.

00:43:14.770 --> 00:43:18.260
Transition animations
are easily specified.

00:43:18.490 --> 00:43:23.120
Here in the top example,
we're creating an LKTransition.

00:43:23.120 --> 00:43:25.800
We're setting its type
to LKTransitionMoveIn.

00:43:25.800 --> 00:43:28.630
This is one of the four basic
built-in transition types that

00:43:28.760 --> 00:43:31.120
CoreAnimation itself implements.

00:43:31.130 --> 00:43:33.830
And we're setting the subtype
to transition from left.

00:43:33.890 --> 00:43:35.820
So we want to move in
transition from the left.

00:43:35.920 --> 00:43:36.600
And that's all it takes.

00:43:36.600 --> 00:43:38.840
It takes three lines of
code to instantiate that.

00:43:38.940 --> 00:43:43.880
If you want a CI filter-based transition,
you create an LKTransition again,

00:43:43.880 --> 00:43:47.540
but then you're instantiating a
CI filter using all the normal means

00:43:47.610 --> 00:43:50.850
of instantiating a CoreImageFilter.

00:43:50.980 --> 00:43:52.960
Usually you just go filter with name.

00:43:53.150 --> 00:43:55.800
You set the parameters
of the filter to default.

00:43:55.800 --> 00:43:57.800
You override any other
parameters you want.

00:43:57.800 --> 00:44:01.790
And then when you're done,
you just say animation set filter filter.

00:44:01.800 --> 00:44:05.790
So you're setting the LKTransitions
to use that CI filter.

00:44:05.840 --> 00:44:06.800
And that's really simple.

00:44:06.800 --> 00:44:08.790
That's all it takes to do that.

00:44:09.430 --> 00:44:12.740
Finally, what if you want to use this to
apply filter effects to views,

00:44:12.740 --> 00:44:16.680
like for example the pointillized filter
that I used to highlight my view there?

00:44:17.020 --> 00:44:19.190
Adding a content filter to
a view is really simple.

00:44:19.250 --> 00:44:21.480
Again,
you instantiate the filter and that's

00:44:21.580 --> 00:44:24.510
most of the work is configuring
the filter the way you want it.

00:44:24.510 --> 00:44:27.590
Once you have the filter you want,
stick it in an array and you can

00:44:27.590 --> 00:44:29.690
even do this in line because a view,
again,

00:44:29.700 --> 00:44:31.590
can take an array of content filters.

00:44:31.620 --> 00:44:33.480
It doesn't have to be just one filter.

00:44:33.480 --> 00:44:35.250
You can specify as many as you want.

00:44:35.250 --> 00:44:37.610
So if you want to apply
that effect immediately,

00:44:37.610 --> 00:44:41.860
you just say,
"View Set Content Filters" filters,

00:44:41.860 --> 00:44:44.240
pass it in the NSArray of
filters and blam,

00:44:44.240 --> 00:44:45.750
the effect is applied immediately.

00:44:45.880 --> 00:44:48.830
Or if you want the effect
to transition in over time,

00:44:48.960 --> 00:44:52.070
you can say,
"View Animator Set Content Filters"

00:44:52.070 --> 00:44:56.890
and then whatever filters,
if any, were applied before will sort of

00:44:56.890 --> 00:45:00.110
transition from the way the view looks
now to the way the view is going to

00:45:00.120 --> 00:45:04.080
look when the new filters are applied.

00:45:04.410 --> 00:45:07.900
So again, in our slide example we had
highlighting with a pointillized filter.

00:45:07.900 --> 00:45:10.700
You might want to use something a little
more subtle or a little more crazy.

00:45:10.700 --> 00:45:11.860
But it's that easy.

00:45:11.860 --> 00:45:13.400
That's all you have to do.

00:45:13.400 --> 00:45:15.820
View set content filters
and you've got core image

00:45:15.820 --> 00:45:17.640
filtering on your view content.

00:45:17.640 --> 00:45:20.640
And we don't even have to re-render
your view when the filters change.

00:45:20.640 --> 00:45:23.380
Because again, all of this content is
being cached in layers.

00:45:23.420 --> 00:45:26.740
So this has enabled one of the many
great visual effect features that

00:45:26.810 --> 00:45:30.500
are enabled when you're rendering
your views in layer-backed mode.

00:45:31.480 --> 00:45:33.770
So finally,
some usage tips for this stuff.

00:45:33.830 --> 00:45:36.020
How can you get the most
performance out of this?

00:45:36.020 --> 00:45:40.740
And also, what kinds of things
should you look out for?

00:45:40.740 --> 00:45:43.100
So there are a few behavioral
nuances to look out for.

00:45:43.100 --> 00:45:46.150
A few things that are a little different
from standard view compositing mode.

00:45:46.170 --> 00:45:49.030
For one thing,
the semantic difference between

00:45:49.110 --> 00:45:53.530
sending set needs display to a view and
doing the same thing for an ancestor

00:45:53.530 --> 00:45:57.880
for the same sort of area in the
window becomes more significant now.

00:45:57.880 --> 00:46:01.260
It used to be views are all sort of
mushed together in the window backing.

00:46:01.480 --> 00:46:03.480
But now, we're able to do that in a way
that's not so much a problem.

00:46:03.480 --> 00:46:05.610
So if you dirty a certain
area of the window,

00:46:05.610 --> 00:46:09.180
it doesn't really matter which view
you're talking to as long as there's

00:46:09.180 --> 00:46:10.480
something occupying that area.

00:46:10.520 --> 00:46:14.170
You can get away with it and the
content will all be redrawn to cover

00:46:14.170 --> 00:46:15.860
the affected area of the window.

00:46:15.870 --> 00:46:20.440
That becomes obviously something
that might not work very well.

00:46:20.440 --> 00:46:23.400
Now that you have views,
each view has its own backing store.

00:46:23.400 --> 00:46:26.790
So it's really important that
you dirty the stuff that actually

00:46:26.790 --> 00:46:28.400
needs to redraw its content.

00:46:28.400 --> 00:46:31.400
Not only so the content will be updated,
but also so we don't waste it.

00:46:31.400 --> 00:46:34.110
We don't waste time re-rendering
content that actually is static

00:46:34.170 --> 00:46:35.640
and doesn't need to be redrawn.

00:46:35.640 --> 00:46:37.450
So be aware of that.

00:46:37.870 --> 00:46:41.940
Another thing to note is that when
you're animating layer backed views

00:46:42.030 --> 00:46:47.700
and you're animating properties such
as the geometric properties that we

00:46:47.700 --> 00:46:52.090
use core animation to implement that
animation so it happens completely

00:46:52.090 --> 00:46:54.640
without your app's intervention.

00:46:54.640 --> 00:46:57.240
From your app's perspective,
those properties are changing

00:46:57.240 --> 00:46:58.640
immediately in its own space.

00:46:58.640 --> 00:47:01.270
So you say view animator
set frame blonde.

00:47:01.330 --> 00:47:05.330
If your view is layer backed,
that has a slightly different semantic

00:47:05.330 --> 00:47:07.520
than if you're in non-layer backed mode.

00:47:07.630 --> 00:47:09.670
In non-layer backed mode,
the view is going to see its frame

00:47:09.670 --> 00:47:12.480
gradually changed incrementally from
the current value to the new value.

00:47:12.610 --> 00:47:15.770
If the view is layer backed,
that's going to happen immediately in

00:47:15.770 --> 00:47:18.690
the application space because really
the animation in core animation,

00:47:18.690 --> 00:47:22.080
most animations are just sort of a
visual treatment that happen off in

00:47:22.080 --> 00:47:24.560
the render tree on a separate thread.

00:47:24.560 --> 00:47:27.560
And they're not really something
that the app needs to be aware of.

00:47:27.560 --> 00:47:29.560
So that's something to be aware of.

00:47:29.560 --> 00:47:31.240
And one consequence of that is
if you're moving stuff around,

00:47:31.240 --> 00:47:31.240
you're going to have a lot of
things that are going to be

00:47:31.240 --> 00:47:31.240
in the way of the render tree.

00:47:31.240 --> 00:47:33.240
So if you're moving stuff
around really slowly,

00:47:33.240 --> 00:47:34.540
you have controls that you're
moving around that the user

00:47:34.540 --> 00:47:36.710
may want to interact with,
you might want to disable those

00:47:36.730 --> 00:47:39.420
controls during the course of a
long animation because the user

00:47:39.420 --> 00:47:42.780
could be clicking around and,
you know, hey, you know,

00:47:42.780 --> 00:47:46.440
it won't be clear at all to them that,
you know, the app thinks that the control

00:47:46.440 --> 00:47:48.540
is in its destination when
it's going to take another,

00:47:48.540 --> 00:47:50.160
you know, five seconds to get there.

00:47:50.160 --> 00:47:53.320
Most of the time,
you're probably going to be using

00:47:53.380 --> 00:47:57.390
short animations of a second or less,
maybe even a half second or

00:47:57.390 --> 00:48:00.820
so because you want your app
to feel really responsive.

00:48:01.160 --> 00:48:02.160
Amen.

00:48:02.670 --> 00:48:07.270
Also, layer content is not only,
view content is not only cached

00:48:07.270 --> 00:48:11.030
individually into individual layers,
but it's drawn axis-aligned in the

00:48:11.030 --> 00:48:13.420
view's own local coordinate system.

00:48:13.420 --> 00:48:16.490
So when you think about this,
this comes into play when

00:48:16.490 --> 00:48:18.020
you have rotated views.

00:48:18.020 --> 00:48:21.810
Even though the view may be rotated,
if it's in a layer-backed tree,

00:48:21.880 --> 00:48:24.480
that rotation is all
implemented in LayerKit,

00:48:24.480 --> 00:48:29.230
and the drawing that the view does
is actually aligned with the bitmap.

00:48:29.340 --> 00:48:31.320
Even though the view is
rotated in the window,

00:48:31.320 --> 00:48:36.920
all the drawing the view does is aligned
with the pixels of the backing store.

00:48:36.920 --> 00:48:40.160
So that actually, in most cases,
is sort of a benefit.

00:48:40.160 --> 00:48:42.720
That's part of why controls
look so much better.

00:48:42.720 --> 00:48:44.760
If they're rotated,
they look so much better

00:48:44.800 --> 00:48:47.800
in layer-backed mode,
mostly, than in non-layer-backed mode,

00:48:47.800 --> 00:48:50.400
because everything just
sort of lines up as it is.

00:48:50.400 --> 00:48:52.660
And effectively,
we're just then taking an image and

00:48:52.660 --> 00:48:54.330
compositing that image in rotated.

00:48:54.340 --> 00:48:56.970
And so you just get some
filtering and some anti-aliasing,

00:48:56.970 --> 00:48:58.420
but things mostly look nice.

00:48:58.740 --> 00:49:00.090
But in some cases,
you may have some negative

00:49:00.090 --> 00:49:00.790
effects from that.

00:49:00.850 --> 00:49:02.680
So something else to look out for.

00:49:02.680 --> 00:49:04.970
And that's another reason,
in addition to performance issues,

00:49:04.980 --> 00:49:07.560
in addition to the fact that
this has a performance cost,

00:49:07.610 --> 00:49:11.980
compatibility with existing rendering is
another reason why we didn't just switch

00:49:12.050 --> 00:49:17.310
this on for all your views in Windows,
because the output is slightly different.

00:49:17.340 --> 00:49:21.600
A layer-backed view's content may
be composited in like an image.

00:49:21.620 --> 00:49:23.190
That's basically what we're doing.

00:49:23.200 --> 00:49:28.270
Views are not always going
to necessarily be backed.

00:49:28.340 --> 00:49:30.230
They're not always going to be
backed by a bitmap backing store.

00:49:30.460 --> 00:49:34.100
There's also a facility for layers
to have a display list backing store,

00:49:34.100 --> 00:49:38.100
which is a much more compact
representation for vector-type art.

00:49:38.100 --> 00:49:40.740
And currently, as of the seed,
we don't really have a way to take

00:49:40.740 --> 00:49:43.180
advantage of this yet in AppKit,
but that's something that may

00:49:43.180 --> 00:49:45.250
be coming as a way to specify,
"You know,

00:49:45.250 --> 00:49:47.570
this view just draws a gradient,"
or "It just draws a box,

00:49:47.570 --> 00:49:50.780
and it's really huge,
and it's not worth caching it

00:49:50.780 --> 00:49:53.940
as a bitmap." But oftentimes,
things are just composited

00:49:53.970 --> 00:49:56.040
in like an image,
so they'll have those sorts of

00:49:56.040 --> 00:49:57.310
image compositing semantics.

00:49:58.010 --> 00:50:01.040
In terms of getting the best
performance from layer-backed views,

00:50:01.140 --> 00:50:04.240
the most important thing to do,
kind of as before,

00:50:04.240 --> 00:50:07.870
is to avoid retraw as much as possible,
only now, to avoid retraw,

00:50:07.960 --> 00:50:11.640
it pays off to isolate static
parts of your user interface.

00:50:11.640 --> 00:50:15.860
So if you have stuff that is
animating and moving and changing,

00:50:16.040 --> 00:50:19.370
and then you have some other
stuff that is static and doesn't

00:50:19.370 --> 00:50:21.210
really need to be redrawn,
it just needs to be

00:50:21.260 --> 00:50:24.440
recomposited into the scene,
it pays to potentially separate

00:50:24.440 --> 00:50:26.200
that content into its own view.

00:50:26.200 --> 00:50:27.660
So you have the dynamic content.

00:50:27.660 --> 00:50:31.710
in one view and your static
parts in some other views.

00:50:32.160 --> 00:50:35.120
Likewise,
you want to design by composing things

00:50:35.120 --> 00:50:38.590
together and applying effects because
once you have content that's rendered,

00:50:38.590 --> 00:50:41.160
it's real easy and cheap, as we've seen,
to sort of move it around

00:50:41.160 --> 00:50:42.290
and apply effects to it.

00:50:42.400 --> 00:50:47.780
But re-rendering content requires the
app's intervention and can take time.

00:50:47.800 --> 00:50:51.020
So you can obviously have some sorts
of animations of that type going on,

00:50:51.020 --> 00:50:53.340
but most of the time you want
to try to avoid redrawing

00:50:53.340 --> 00:50:54.920
stuff when you don't have to.

00:50:54.920 --> 00:50:55.720
Real common sense.

00:50:57.290 --> 00:50:59.960
Also, it's good to optimize your
use of backing stores.

00:50:59.960 --> 00:51:02.970
You don't want to have a view that has a
big margin around it and doesn't really

00:51:03.030 --> 00:51:06.500
draw anything out to its full extents,
but just draws something inside

00:51:06.500 --> 00:51:09.710
of itself and leaves a bunch
of blank space around it.

00:51:09.790 --> 00:51:12.180
You're just using a layer backing store.

00:51:12.180 --> 00:51:16.080
So try to crop your view content tightly
and you'll get better performance

00:51:16.080 --> 00:51:19.860
that way and you'll be able to put
more objects in your scene that way.

00:51:19.900 --> 00:51:23.440
Some possible future directions
for this stuff for Leopard and

00:51:23.440 --> 00:51:25.590
beyond that we're thinking about.

00:51:26.080 --> 00:51:28.830
We want to support additional
animatable value types.

00:51:28.900 --> 00:51:29.800
So for example, colors.

00:51:29.820 --> 00:51:31.080
You should be able to interpolate colors.

00:51:31.080 --> 00:51:32.830
We're going to be adding stuff like that.

00:51:32.940 --> 00:51:36.380
AppKit does not currently
interpret LK timing functions

00:51:36.380 --> 00:51:40.580
and keyframe animations for your
own custom property animations,

00:51:40.580 --> 00:51:43.820
although for layer backed properties,
that's automatically taken

00:51:43.820 --> 00:51:45.220
care of by core animation.

00:51:45.220 --> 00:51:47.020
So that we expect to be coming.

00:51:47.020 --> 00:51:50.340
There will be some further performance
work on non-layer backed mode.

00:51:50.400 --> 00:51:52.460
So all of this stuff,
and maybe it hasn't been

00:51:52.460 --> 00:51:55.100
clear in the session so far,
all this animation stuff.

00:51:55.190 --> 00:51:59.090
Also will work even if you're
not using layer backed views.

00:51:59.100 --> 00:52:01.850
You can animate views frames by
talking to an animator proxy.

00:52:01.930 --> 00:52:04.790
Part of the idea here was we wanted
you to be able to use the same

00:52:04.800 --> 00:52:08.000
convenient syntax whether you have
a layer backed view tree or not.

00:52:08.040 --> 00:52:11.000
So we're probably going to
do a little more improving

00:52:11.010 --> 00:52:15.280
of the non-layer backed mode,
but right now the future really

00:52:15.280 --> 00:52:18.260
is layer backed views for really
high performance animations,

00:52:18.260 --> 00:52:18.620
we think.

00:52:18.620 --> 00:52:20.780
So we've been focusing on that
and that's the kind of stuff

00:52:20.890 --> 00:52:24.080
that you should be testing and
experimenting with in the seed.

00:52:24.080 --> 00:52:26.030
and see,
and flip layer back view mode on and

00:52:26.030 --> 00:52:28.410
start doing your animations that way.

00:52:28.760 --> 00:52:32.760
There's some new API that was
mentioned in the Cocoa What's New talk

00:52:32.760 --> 00:52:34.340
for taking a view full screen.

00:52:34.340 --> 00:52:36.400
You've got a view and some
content and you want the user

00:52:36.400 --> 00:52:38.680
to be able to interact with it,
filling up the screen.

00:52:38.680 --> 00:52:42.200
We want to be able to have
transition effects applied to that.

00:52:42.280 --> 00:52:44.640
There's a provision for transition
effects in there that's not

00:52:44.640 --> 00:52:47.310
yet implemented in the seed,
but we'd like to be able to add that

00:52:47.310 --> 00:52:51.030
so you can get a nice smooth transition
when you're going into full screen mode.

00:52:52.090 --> 00:52:53.740
Integration with other
graphics technologies,

00:52:53.740 --> 00:52:57.380
as I mentioned, such as OpenGL,
Quartz Composer, and QuickTime.

00:52:57.380 --> 00:52:59.520
There's a lot of potential
here in Core Animation.

00:52:59.520 --> 00:53:02.650
This is one of the most powerful
graphics technologies that we've

00:53:02.750 --> 00:53:04.080
had come along on Mac OS X.

00:53:04.840 --> 00:53:08.120
And in fact, I've got a second demo,
if we could go back to Demo D,

00:53:08.120 --> 00:53:14.070
to give you an idea of what kind of
stuff is going to be possible here.

00:53:15.110 --> 00:53:17.880
So I've got my slides demo.

00:53:17.880 --> 00:53:21.600
And it's got this nice gradient
background and everything.

00:53:21.600 --> 00:53:24.500
And yeah, an NSGradient is nice,
and that's fun to be able to draw.

00:53:24.500 --> 00:53:24.890
But you know what?

00:53:24.960 --> 00:53:27.260
If I wanted to be able to
have something else arbitrary,

00:53:27.260 --> 00:53:31.000
like a Quartz Composer composition
behind it or something.

00:53:31.000 --> 00:53:32.260
So I turn that on.

00:53:32.260 --> 00:53:36.740
And when I restart the app,
it's going to work.

00:53:36.740 --> 00:53:38.200
Hmm.

00:53:41.040 --> 00:53:43.000
There we go,
we got a little bit of a stall.

00:53:43.000 --> 00:53:46.690
Let me quit and restart
and this will be happier.

00:53:55.960 --> 00:53:59.340
The leopard's a little unhappy today.

00:53:59.340 --> 00:54:00.540
OK.

00:54:01.640 --> 00:54:04.900
This is a work in progress, by the way.

00:54:04.910 --> 00:54:06.410
OK, starting this up new.

00:54:06.630 --> 00:54:09.580
When in doubt, get out of the car,
close the doors, reopen the doors,

00:54:09.580 --> 00:54:12.060
get back in the car, restart the engine.

00:54:12.060 --> 00:54:13.400
And let's see.

00:54:13.400 --> 00:54:14.140
OK, here we go.

00:54:14.140 --> 00:54:17.140
OK,
so we've got a quartz composition here.

00:54:20.100 --> 00:54:22.680
You know, we've got some arbitrary
views on top of it.

00:54:22.780 --> 00:54:26.510
These happen to be sort of custom views,
drawing these slide shapes.

00:54:26.640 --> 00:54:28.200
But they really could be anything.

00:54:28.200 --> 00:54:29.400
We could put sliders here.

00:54:29.400 --> 00:54:32.900
We've got the ability to have all kinds
of different app kit controls there.

00:54:32.900 --> 00:54:37.180
In fact, I've got another little
test app here we can run.

00:54:39.060 --> 00:54:41.750
And this is a much more
useless app except for just

00:54:41.830 --> 00:54:42.900
testing the animation stuff.

00:54:42.900 --> 00:54:45.080
So here I've got a quartz
composition in the background.

00:54:45.180 --> 00:54:48.740
And I've got just a bunch of
different app kit controls.

00:54:48.740 --> 00:54:51.070
And these are all
layer-backed views here again.

00:54:51.070 --> 00:54:52.790
That's how we can,
I mean we wouldn't be able to do

00:54:52.790 --> 00:54:54.240
this without layer-backed views.

00:54:54.240 --> 00:54:57.110
There's no way to really have
conventional view drawing on top

00:54:57.110 --> 00:55:00.020
of a quartz composition or any
other type of OpenGL rendering,

00:55:00.090 --> 00:55:03.080
anything else that goes to a
hardware surface because the surface

00:55:03.080 --> 00:55:04.940
normally floats over the window.

00:55:04.940 --> 00:55:07.820
So there's, this was something that was
previously very hard to do.

00:55:07.820 --> 00:55:08.880
Now you're in the future
going to have to do it again.

00:55:09.900 --> 00:55:11.210
And you're going to be able to have,
you know, you want to put a slider

00:55:11.240 --> 00:55:12.400
on top of your movie view.

00:55:12.400 --> 00:55:15.230
We're looking to make that kind of
thing really easy to do so you don't

00:55:15.230 --> 00:55:18.040
have to go to these sort of heroic
lengths to do that kind of stuff.

00:55:18.080 --> 00:55:20.460
So all these controls sort of work,
you know.

00:55:20.460 --> 00:55:21.720
I can slide the slider.

00:55:21.720 --> 00:55:23.100
I can click the buttons.

00:55:23.100 --> 00:55:27.330
Let's see, I've got a color well,
you know, I can pick around in there.

00:55:27.550 --> 00:55:28.210
It's live.

00:55:28.210 --> 00:55:29.410
It's interactive.

00:55:29.510 --> 00:55:31.960
You may notice as I'm
mousing over the views,

00:55:31.960 --> 00:55:34.010
I've got sort of a halo filter there.

00:55:34.010 --> 00:55:35.610
You can sort of see it there.

00:55:35.610 --> 00:55:38.880
I've got sort of a bloom
filter that I'm applying there.

00:55:39.290 --> 00:55:41.110
And again,
the controls are all sort of interactive.

00:55:41.110 --> 00:55:41.840
They just work.

00:55:41.840 --> 00:55:44.660
Text fields aren't quite
working yet well in the seed.

00:55:44.660 --> 00:55:46.790
We've got a fixed forthcoming for that.

00:55:46.830 --> 00:55:50.110
But most of the other controls, you know,
they just sort of magically work.

00:55:50.110 --> 00:55:52.740
And if you want to animate them
using layer backed animations,

00:55:52.800 --> 00:55:54.000
you know, that works too.

00:56:02.990 --> 00:56:02.990
I can turn off use of layer kit here.

00:56:02.990 --> 00:56:02.990
And now we're just going to go to
a static image because now we can't

00:56:02.990 --> 00:56:02.990
do the quartz composition anymore.

00:56:02.990 --> 00:56:02.990
And

00:56:03.150 --> 00:56:05.410
I'm animating using the exact same APIs.

00:56:05.490 --> 00:56:07.560
The views have no idea that
they're animating differently.

00:56:07.560 --> 00:56:08.860
And you can see, you know, it works.

00:56:08.860 --> 00:56:11.820
I can talk to the animator
and set a frame target.

00:56:11.820 --> 00:56:14.800
And all the retargeting stuff works, too.

00:56:14.800 --> 00:56:16.210
But it's just not quite as smooth.

00:56:16.210 --> 00:56:17.660
It's a little chunkier, right?

00:56:17.710 --> 00:56:22.730
So if we go back to LayerKit backed mode,
you know, things just kind of flow.

00:56:22.730 --> 00:56:26.100
They're much smoother,
mainly because the app isn't involved.

00:56:26.100 --> 00:56:28.950
You know, once your view content
is rendered into layers,

00:56:28.950 --> 00:56:31.520
then Core Animation is moving
stuff around behind the

00:56:31.520 --> 00:56:33.030
scenes on a separate layer.

00:56:33.150 --> 00:56:35.920
And your app is free to do
other stuff on its main thread,

00:56:35.920 --> 00:56:36.710
on its run loop.

00:56:36.820 --> 00:56:39.030
So, you know,
this is the kind of stuff that

00:56:39.160 --> 00:56:40.580
we see coming in the future.

00:56:40.580 --> 00:56:44.420
And we hope to make it
much easier to do this.

00:56:44.420 --> 00:56:48.220
Now, the adding of the quartz
composition here in the background,

00:56:48.220 --> 00:56:51.880
that was actually done using
API that's on your leopard seed.

00:56:51.880 --> 00:56:56.060
And what I did is
I explicitly got a LK quartz,

00:56:56.060 --> 00:56:59.320
sorry, a QC composition layer.

00:56:59.320 --> 00:57:03.080
So there's a LK layer subclass
that is exposed as part of the

00:57:03.080 --> 00:57:07.660
public API in the quartz composer
framework that you can instantiate.

00:57:07.660 --> 00:57:09.560
And I've substituted that layer.

00:57:09.560 --> 00:57:21.010
I've used the set layer API that's on
views to substitute my own layer in

00:57:21.010 --> 00:57:33.060
place of the layer that AppKit would
otherwise automatically create.

00:57:33.060 --> 00:57:33.060
And I just say, okay,
I want you to create a quartz composition

00:57:33.060 --> 00:57:33.060
layer with this composition and blam,
it's in there.

00:57:33.060 --> 00:57:33.060
Going down the road in the future,
we kind of want to make this even easier.

00:57:33.060 --> 00:57:33.060
You know, it should be possible to just
have a QC view that's in a view

00:57:33.060 --> 00:57:33.060
hierarchy for which you happen
to enable layer backed rendering.

00:57:33.060 --> 00:57:35.570
And AppKit should
automatically know what to do,

00:57:35.570 --> 00:58:02.980
you know, what kind of special layer to
create and how to configure it.

00:58:03.040 --> 00:58:03.040
But right now,
you can even sort of kludge this in

00:58:03.040 --> 00:58:03.040
right now just with what's on your seed.

00:58:03.040 --> 00:58:03.040
So some neat stuff is
going to be possible now.

00:58:03.040 --> 00:58:03.040
If we could go back to the
slides just for a wrap up.

00:58:03.040 --> 00:58:03.040
So where can you learn
more about this stuff?

00:58:03.040 --> 00:58:03.040
There's some draft
documentation that's available.

00:58:03.040 --> 00:58:03.040
Or it's called LayerKit still.

00:58:03.040 --> 00:58:03.040
Okay, the author has just reminded
me that this is called,

00:58:03.040 --> 00:58:05.110
so look for LayerKit overview
and LayerKit reference available,

00:58:05.170 --> 00:58:11.110
I think, via the ADC site and for
download from the WWDC site.

00:58:11.220 --> 00:58:14.370
And also, please read the Leopard
AppKit release notes for this talk

00:58:14.370 --> 00:58:15.950
specifically and also in general.

00:58:15.950 --> 00:58:18.830
There are a bunch of notes there
about the new animation functionality

00:58:18.950 --> 00:58:21.440
and should serve as a pretty
good quick start guide for you

00:58:21.440 --> 00:58:23.430
to start experimenting with this.

00:58:23.430 --> 00:58:26.800
The source code for this sample
we intend to make available soon.

00:58:26.800 --> 00:58:29.150
It's been really hard for
me to stop playing around

00:58:29.340 --> 00:58:31.010
with it and adding new stuff.

00:58:31.550 --> 00:58:35.510
This adding the quartz composition,
I did that on the train this morning.

00:58:35.510 --> 00:58:37.700
I was just like, well,
maybe we could just get that working too,

00:58:37.700 --> 00:58:38.970
you know, and it was easy to do.

00:58:38.970 --> 00:58:40.970
I added five lines of
code and it just worked.

00:58:41.080 --> 00:58:43.080
So I'm going to try to
stop futzing with it.

00:58:43.130 --> 00:58:45.010
We're going to try to get it
published very shortly so you

00:58:45.010 --> 00:58:46.380
can look at how this is all done.

00:58:50.600 --> 00:58:55.680
And finally, since we are using the
LK Animations in the AppKit API,

00:58:55.680 --> 00:59:00.080
it might be useful for you to take a look
at the Quartz Core framework headers,

00:59:00.080 --> 00:59:03.780
just a few of them,
specifically LKAnimation.h, LKTiming.h,

00:59:03.920 --> 00:59:07.530
and if you want LKLayer.h,
there are a lot of comments in the

00:59:07.530 --> 00:59:11.760
headers that will help give you
more detail about how these things

00:59:11.760 --> 00:59:15.360
work and when to use which kind and
so forth and how to configure them.

00:59:15.360 --> 00:59:17.600
So hopefully this has been helpful.

00:59:17.600 --> 00:59:20.500
For more information,
you can contact Derek Horn,

00:59:20.510 --> 00:59:24.140
who's our Application Frameworks
Evangelist.

00:59:24.140 --> 00:59:27.440
And lastly, just some take-home points,
if you remember nothing

00:59:27.440 --> 00:59:28.920
else from this session.

00:59:28.920 --> 00:59:32.360
The key idea I want to get across here is
that to take advantage of this powerful

00:59:32.360 --> 00:59:34.930
new core animation functionality,
there's no need to re-architect

00:59:35.040 --> 00:59:37.870
your user interfaces,
maybe a little refactoring of where you

00:59:37.940 --> 00:59:40.130
put your static and dynamic content.

00:59:40.200 --> 00:59:42.300
But in general,
there's no need to rebuild your UIs.

00:59:42.300 --> 00:59:45.110
You can work with layers
directly if you want to,

00:59:45.150 --> 00:59:48.150
but there's also no need to be
aware that they even exist or

00:59:48.160 --> 00:59:50.400
that AppKit is auto-managing them.

00:59:50.400 --> 00:59:52.300
So what I'm showing you,
except for swapping in that

00:59:52.440 --> 00:59:55.100
Quartz Composition layer,
has no idea that there's any

00:59:55.100 --> 00:59:56.300
of this layer stuff going on.

00:59:56.300 --> 00:59:58.740
It just does set once layer
yes for the root view,

00:59:58.740 --> 01:00:01.260
and AppKit takes care of the rest.

01:00:01.260 --> 01:00:02.580
So it's all very automatic.

01:00:02.580 --> 01:00:06.200
We've tried to make it very automatic,
while also providing you the opportunity

01:00:06.200 --> 01:00:09.020
to override behavior where you want to.

01:00:09.160 --> 01:00:13.710
So keep designing great UI using views,
and let AppKit help you

01:00:13.710 --> 01:00:15.390
animate them efficiently.
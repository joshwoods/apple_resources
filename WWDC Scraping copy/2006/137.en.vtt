WEBVTT

00:00:10.520 --> 00:00:11.940
Good morning.

00:00:11.950 --> 00:00:13.130
My name is Julio González.

00:00:13.140 --> 00:00:15.420
I manage the type group at Apple.

00:00:15.440 --> 00:00:18.040
I am very excited to
be here with you today.

00:00:18.080 --> 00:00:19.960
I'm excited for two reasons.

00:00:19.990 --> 00:00:22.650
I get to introduce to
you a new framework,

00:00:22.650 --> 00:00:25.750
and believe it or not,
I'm excited because I got to

00:00:25.750 --> 00:00:27.280
finally tell you about it.

00:00:27.580 --> 00:00:32.500
See, we've been listening to your
feedback during this past few years.

00:00:32.500 --> 00:00:36.500
You want to have a faster
way to layout text.

00:00:36.640 --> 00:00:40.500
You want to have an easier
way to do so as well.

00:00:40.500 --> 00:00:45.500
You want to have a font framework that is
unified and it's not all over the place.

00:00:45.500 --> 00:00:48.500
Well, we've done so.

00:00:48.500 --> 00:00:51.400
I am an active member of
the Carbon Developer List.

00:00:51.400 --> 00:00:55.500
I usually answer questions
regarding text and fonts.

00:00:55.500 --> 00:00:56.090
And a lot of the time,
I'm not the only one.

00:00:56.090 --> 00:00:56.500
I'm the only one.

00:00:56.500 --> 00:00:57.490
I'm the only one.

00:00:57.550 --> 00:00:59.500
I don't like the answers that I give you.

00:00:59.500 --> 00:01:04.500
Some of those are, stick to Quikdraw,
even though I know that

00:01:04.500 --> 00:01:06.500
Quikdraw is a deprecated API.

00:01:06.500 --> 00:01:09.810
Or, at times,
I give you an answer that says,

00:01:09.810 --> 00:01:13.610
here's a bunch of Cocoa APIs that
you can use to do so,

00:01:13.740 --> 00:01:19.220
even though I know that you can't or
it may not be possible for you to apply

00:01:19.370 --> 00:01:21.500
this Cocoa solution to your application.

00:01:21.990 --> 00:01:23.580
So,

00:01:23.630 --> 00:01:27.720
You know, I sit back and I say, boy,
I really want to let those

00:01:27.720 --> 00:01:30.640
people know about CoreText,
but I can't and I'm just,

00:01:30.690 --> 00:01:33.710
that's why I'm so excited to be here
today and introduce to you CoreText.

00:01:33.920 --> 00:01:36.650
So, today,

00:01:39.290 --> 00:01:43.200
I'll give you a little
rundown of what CoreText is.

00:01:43.340 --> 00:01:45.790
Then I'd like to take a step
back and take a look at the

00:01:45.790 --> 00:01:49.970
whole text system in Mac OS X,
how things fit together

00:01:50.100 --> 00:01:52.250
and where CoreText fits in.

00:01:52.520 --> 00:01:56.370
Then we'll go and dive deep down
into CoreText and what it is,

00:01:56.660 --> 00:02:01.400
look at some of its concepts, the APIs,
give you a demo, look at sample code.

00:02:01.400 --> 00:02:04.700
Then leave you with some
thoughts and hopefully we'll

00:02:04.700 --> 00:02:06.400
have some time for some Q&A.

00:02:08.230 --> 00:02:09.260
So what is CoreText?

00:02:09.460 --> 00:02:14.410
CoreText is a brand new text
layout engine for Mac OS X.

00:02:14.530 --> 00:02:18.530
It also comprises a
comprehensive set of font API.

00:02:19.320 --> 00:02:20.710
So I say it's new.

00:02:20.880 --> 00:02:22.920
Well, it's not really new.

00:02:22.990 --> 00:02:24.700
CoreText has been there since Tiger.

00:02:24.930 --> 00:02:26.460
Some of you have noticed it.

00:02:26.470 --> 00:02:28.980
I know so because you've told
me so on the developer list.

00:02:28.990 --> 00:02:30.660
You asked me, what is it?

00:02:30.660 --> 00:02:34.620
I said, well, wait.

00:02:36.560 --> 00:02:40.830
During the Tiger timeframe,
the Cocoa and Carbon frameworks

00:02:40.830 --> 00:02:42.450
made use of CoreText.

00:02:42.650 --> 00:02:47.100
They started moving away from using
Atsui and using CoreText instead.

00:02:47.370 --> 00:02:50.690
So it is a proven technology.

00:02:50.820 --> 00:02:54.950
One of our goals when we set
out to design CoreText was

00:02:54.950 --> 00:02:57.290
we really wanted fast layout.

00:02:57.480 --> 00:03:01.970
We wanted to have really fast
text rendered on the screen.

00:03:02.460 --> 00:03:09.480
So in the Tiger timeframe, as I said,
Cocoa and HIToolbox started using it.

00:03:09.540 --> 00:03:12.990
And for example,
internal benchmarks for HIToolbox

00:03:13.060 --> 00:03:19.940
show that draw theme text box is twice
as fast once they adopted CoreText.

00:03:20.110 --> 00:03:23.290
So hopefully we can do the
same for your applications.

00:03:23.410 --> 00:03:26.100
When we set out to do CoreText,

00:03:26.790 --> 00:03:32.210
We had that performance in mind,
so we just took a step back and looked

00:03:32.290 --> 00:03:37.440
at what we had to offer in the past and
the new things that we had in Cocoa,

00:03:37.440 --> 00:03:39.700
plus a few other things
that we did internally.

00:03:39.700 --> 00:03:45.640
And we created this unified framework for
you to use so you don't have to jump back

00:03:45.680 --> 00:03:48.700
and forth between one API to the next.

00:03:48.700 --> 00:03:51.850
And finally,
one of the main goals of CoreText was

00:03:52.080 --> 00:03:54.700
to help out our Carbon developers.

00:03:54.700 --> 00:03:58.390
A lot of them still use Quickdraw.

00:03:58.730 --> 00:04:01.200
In fact, as of last week,
I'm answering questions of

00:04:01.200 --> 00:04:03.700
Carbon developers that are
starting a brand new app

00:04:03.700 --> 00:04:05.520
and they're using Quickdraw.

00:04:05.700 --> 00:04:09.700
So hopefully with CoreText,
we've solved some of these problems,

00:04:09.700 --> 00:04:12.950
given you an avenue to
move from Quickdraw into

00:04:12.950 --> 00:04:14.690
something that is more modern.

00:04:14.700 --> 00:04:18.700
So let's take a look
at the text subsystem.

00:04:18.700 --> 00:04:22.610
So at the very bottom,
we have what we call the core frameworks.

00:04:22.700 --> 00:04:26.700
First one is ATS, Apple Type Services.

00:04:26.930 --> 00:04:29.700
You can't use it to draw
text or layout text.

00:04:29.700 --> 00:04:31.010
But it's a...

00:04:31.440 --> 00:04:34.900
A base framework that allows or vents
all the font data to the system.

00:04:34.900 --> 00:04:38.370
Without it, the rest of the system,
you can't do, you can't draw any text.

00:04:38.400 --> 00:04:40.100
Next one is Quartz.

00:04:40.190 --> 00:04:41.820
It's our core rendering engine.

00:04:41.880 --> 00:04:45.320
It is the bottleneck for all
text that is drawn in the system.

00:04:45.340 --> 00:04:48.250
As such,
it is the fastest way to draw text.

00:04:48.360 --> 00:04:51.960
So you say at this point in time, "Well,
it is the fastest way to draw text.

00:04:52.000 --> 00:04:53.880
Why should I be doing anything else?

00:04:53.970 --> 00:04:57.690
I should just use Quartz." Well,
Quartz is just a rendering engine.

00:04:57.810 --> 00:04:59.710
It really cares little about text.

00:04:59.710 --> 00:05:01.020
It has no idea about text.

00:05:01.240 --> 00:05:03.900
If you have the glyphs
that you want to display,

00:05:03.900 --> 00:05:05.730
it will put those on the screen.

00:05:05.780 --> 00:05:08.720
It will get those pixels
on the screen really fast.

00:05:08.800 --> 00:05:13.430
But if you have any issues such
as text issues such as reordering,

00:05:13.750 --> 00:05:18.350
kerning, ligatures,
it doesn't know anything about that.

00:05:18.450 --> 00:05:22.020
For that, you need a text system.

00:05:22.470 --> 00:05:27.540
So here's what the text system
looks as of the Panther timeframe.

00:05:28.110 --> 00:05:29.710
Oldest of all is QD Text.

00:05:30.030 --> 00:05:33.610
I love QD Text, Quickdraw Text.

00:05:33.990 --> 00:05:36.500
Being the oldest,
it has the most handicaps.

00:05:36.570 --> 00:05:39.000
It does not support all fonts.

00:05:39.110 --> 00:05:41.630
It has no support for UniCode.

00:05:42.640 --> 00:05:47.290
In OS X, it has a more limited support
of languages and scripts than it

00:05:47.290 --> 00:05:51.640
did in the classic time frame,
and it's also the slowest to render.

00:05:51.680 --> 00:05:55.530
If that's not enough, as of Leopard,
it will be the second release

00:05:55.610 --> 00:05:57.380
where Quickdraw is deprecated.

00:05:57.440 --> 00:06:01.910
And new to Leopard, 64-bit,
Quickdraw is not supported

00:06:02.010 --> 00:06:03.780
at all in 64-bit.

00:06:04.930 --> 00:06:09.090
Next is Atsui,
Apple type services for Unicode imaging.

00:06:09.480 --> 00:06:13.640
This is a very powerful layout engine,
a very complete layout engine,

00:06:13.880 --> 00:06:18.740
so much so that Cocoa uses Atsui
to do some of its text operations.

00:06:18.800 --> 00:06:22.520
However,
it's a technology that predates Mac OS X.

00:06:22.790 --> 00:06:26.800
As such, it has some really bad,
or I shouldn't say bad,

00:06:26.800 --> 00:06:31.800
it carries some old technologies
with it such as Quickdraw.

00:06:31.820 --> 00:06:36.580
So it creates some clashes, if you will,
when you try to use

00:06:36.580 --> 00:06:38.800
these with modern APIs.

00:06:39.230 --> 00:06:43.640
Aside from that,
folks that program with Atsui

00:06:44.000 --> 00:06:48.300
Generally run into all these
obscure performance pitfalls.

00:06:48.300 --> 00:06:51.830
And tasks that should be simple
to use in Atsui or simple to

00:06:51.830 --> 00:06:54.040
do in Atsui are often complex.

00:06:54.040 --> 00:06:57.240
If you take one of these boxes,
the box that says they're Atsui and

00:06:57.240 --> 00:07:00.140
you want to draw that text Atsui,
it takes you half a

00:07:00.140 --> 00:07:01.660
page of code to do so.

00:07:01.660 --> 00:07:07.280
So these are some of the issues
that we've solved with CoreText and

00:07:07.280 --> 00:07:07.280
hope to show you a little later on.

00:07:07.670 --> 00:07:10.740
On top of ATSUI, we have Cocoa and MLTE.

00:07:10.940 --> 00:07:16.600
MLTE, Multilingual Text Engine,
is a powerful framework.

00:07:16.990 --> 00:07:20.600
However,
this framework is also old technology.

00:07:20.600 --> 00:07:22.640
It predates Mac OS X,
and believe it or not,

00:07:22.640 --> 00:07:24.600
it's even older than ATSUI.

00:07:24.690 --> 00:07:27.850
As such, it has more baggage
that it carries around,

00:07:27.850 --> 00:07:28.560
if you will.

00:07:28.910 --> 00:07:31.600
Quickdraw text, Script Manager,
a lot more.

00:07:31.670 --> 00:07:33.600
However,
it's a very easy-to-use framework.

00:07:33.600 --> 00:07:36.600
And to draw the same text,
I'll give you the same example.

00:07:36.600 --> 00:07:39.070
To draw MLTE there,
it probably takes you one or

00:07:39.070 --> 00:07:40.590
two lines of code to do so.

00:07:40.730 --> 00:07:43.580
So it is very nice in that respect.

00:07:43.600 --> 00:07:48.550
Now, one note of caution for MLTE that
I want to bring up at this time.

00:07:48.580 --> 00:07:53.590
For 64-bit and Leopard,
MLTE is not going to be fully supported.

00:07:53.730 --> 00:07:58.620
The only APIs that will be
supported in 64-bit for MLTE are

00:07:58.620 --> 00:08:01.600
those that make HI TextView work.

00:08:01.620 --> 00:08:05.460
That's why in previous,
I think in the last WWDC,

00:08:05.460 --> 00:08:10.600
we told you to start moving away from
MLTE and start using HI TextView instead.

00:08:10.680 --> 00:08:12.870
Finally, there is Cocoa.

00:08:13.410 --> 00:08:20.780
Cocoa is the best way and the
easiest way to draw text in Mac OS X.

00:08:22.310 --> 00:08:26.320
It is the simplest and most
powerful way to do so in Waco S10.

00:08:26.420 --> 00:08:30.840
And if at times,
if you don't find what you need in Cocoa,

00:08:30.960 --> 00:08:34.710
you can possibly subclass one of its
classes and do what you need to do.

00:08:34.840 --> 00:08:37.280
However,
we know full well that for a lot of you,

00:08:37.390 --> 00:08:38.780
Cocoa is not an answer.

00:08:38.910 --> 00:08:41.680
It doesn't fit into your architecture.

00:08:41.770 --> 00:08:47.040
Or you need to be at a much more lower
level that Cocoa doesn't fit your needs.

00:08:47.180 --> 00:08:50.400
For those, a lot of you folks have picked
at ZUI and that's great.

00:08:50.490 --> 00:08:53.400
But now we have CoreText,
which is what we think

00:08:53.400 --> 00:08:55.670
a much better solution,
a better performing solution,

00:08:55.740 --> 00:08:58.290
easier solution for you to use.

00:08:59.150 --> 00:09:01.420
Now,
here's the text architecture in Tiger.

00:09:01.480 --> 00:09:05.200
As you can see, the Cocoa arrow that was
pointing to Atsui is now gone,

00:09:05.200 --> 00:09:09.340
indicating the first transition
from Cocoa to using CoreText.

00:09:09.540 --> 00:09:14.880
And also notice the arrow going from
Cocoa down to the base frameworks,

00:09:14.880 --> 00:09:16.340
ATS and Quartz.

00:09:16.720 --> 00:09:19.160
In the Leopard timeframe,
that arrow is gone.

00:09:19.310 --> 00:09:21.900
Now, what do I mean about that?

00:09:22.300 --> 00:09:26.080
It doesn't mean that Cocoa no longer uses
the base frameworks to do its things.

00:09:26.290 --> 00:09:29.790
But what it means is that it's using
much less and relying much more so

00:09:29.790 --> 00:09:32.100
on CoreText in the Leopard timeframe.

00:09:32.100 --> 00:09:34.680
Also notice here the
new arrow from Carbon to

00:09:34.760 --> 00:09:38.300
CoreText indicating that finally,
Carbon developers can make

00:09:38.310 --> 00:09:39.600
use of the new technology.

00:09:39.600 --> 00:09:42.860
And finally,
the coloring for MLT and QD text

00:09:42.930 --> 00:09:47.600
indicating a warning that they're
not supported or in the case of MLT,

00:09:47.600 --> 00:09:50.600
there's little support in 64-bit.

00:09:50.600 --> 00:09:55.600
So, now you can see CoreText is sort of
living in between those two layers,

00:09:55.600 --> 00:09:59.100
in between the Carbon Cocoa layer
and the Frame layer,

00:09:59.100 --> 00:10:03.340
being the layer where most
of the core layout operations

00:10:03.350 --> 00:10:05.430
are going to go through.

00:10:06.490 --> 00:10:07.750
So what is CoreText?

00:10:07.860 --> 00:10:10.680
Now you need to know what is
it that it really does for you.

00:10:10.680 --> 00:10:14.120
So I told you before
there is two facets to it.

00:10:14.120 --> 00:10:16.700
There is the layout and the font API.

00:10:16.750 --> 00:10:19.830
I will talk to you about the font API,
but before I do that,

00:10:19.920 --> 00:10:24.390
I want to introduce Ned Holbrook,
who will tell you all about the

00:10:24.460 --> 00:10:27.130
layout capabilities of CoreText.

00:10:30.720 --> 00:10:33.100
Thank you Julio.

00:10:33.160 --> 00:10:34.240
Good morning.

00:10:34.270 --> 00:10:37.230
I'm very excited to be here with
you and tell you about performing

00:10:37.280 --> 00:10:38.600
text layout with CoreText.

00:10:38.700 --> 00:10:43.840
So, as Julio mentioned,
CoreText is newly public in the

00:10:43.840 --> 00:10:48.700
Leopard timeframe and as such,
if you have taken the opportunity

00:10:48.700 --> 00:10:51.960
to look at your developer seed,
you'll see the full range

00:10:51.960 --> 00:10:54.700
of CoreText headers that
you have available to you.

00:10:54.700 --> 00:10:56.700
Has anyone taken a look at those yet?

00:10:56.740 --> 00:10:58.700
Okay, that's good.

00:10:59.110 --> 00:11:02.830
Because there's,
it may look daunting at first and

00:11:02.830 --> 00:11:07.480
so what I'd like to do is walk you
through sort of the higher level

00:11:07.700 --> 00:11:11.300
objects that we have available to you
in CoreText and how you might use them

00:11:11.300 --> 00:11:13.480
appropriately to do what you need.

00:11:13.960 --> 00:11:17.220
So, in order to do so,

00:11:18.620 --> 00:11:24.200
We should first answer the question,
well, why should I even care?

00:11:24.560 --> 00:11:28.390
Well, we've tried to give you several
different reasons why you will

00:11:28.390 --> 00:11:30.900
be interested in CoreText,
and so I'd like to

00:11:30.900 --> 00:11:32.480
discuss some of those now.

00:11:32.580 --> 00:11:36.500
The first is that CoreText is
a modern API design.

00:11:36.670 --> 00:11:40.500
Not only does CoreText make extensive
use of system services internally,

00:11:40.690 --> 00:11:44.410
but it also makes use of the very
same conventions used elsewhere

00:11:44.500 --> 00:11:47.000
in frameworks for Mac OS X.

00:11:47.000 --> 00:11:50.480
So this means that a lot of the
rules of thumb that you've garnered

00:11:50.590 --> 00:11:54.720
for yourself over the years working
with OS X technologies can be put

00:11:54.750 --> 00:11:58.320
to the same use with CoreText,
which means that you can spend

00:11:58.430 --> 00:12:01.750
less of your time fighting the
API and more of the time getting

00:12:01.790 --> 00:12:04.320
stuff accomplished with CoreText.

00:12:04.530 --> 00:12:05.990
Cortext is fast.

00:12:06.140 --> 00:12:10.400
This was a big concern for a lot of
you with some previous architectures

00:12:10.400 --> 00:12:13.200
rendering engines on Mac OS X.

00:12:13.410 --> 00:12:16.690
And as Julio mentioned,
we found internally that Cortext

00:12:16.750 --> 00:12:21.200
is up to twice as fast than Atsui,
so we hope you'll be

00:12:21.200 --> 00:12:23.590
very excited about that.

00:12:23.910 --> 00:12:27.460
CoreText makes use of
core foundation objects.

00:12:27.460 --> 00:12:31.440
Not only does it use core
foundation objects as

00:12:31.440 --> 00:12:37.120
parameters to various functions,
but CoreText itself is a collection

00:12:37.190 --> 00:12:39.140
of core foundation objects.

00:12:39.140 --> 00:12:43.760
So I'll be talking about these
objects in the next 25 minutes or so,

00:12:43.760 --> 00:12:47.780
but what you should know
is that once you have a

00:12:47.780 --> 00:12:51.940
CoreText object in your possession,
then you can go ahead and follow the

00:12:51.940 --> 00:12:55.700
same create rule that you've learned
when dealing with core foundation,

00:12:55.700 --> 00:12:59.560
and so you can retain and release
those objects as necessary,

00:12:59.560 --> 00:13:00.760
which is great.

00:13:01.910 --> 00:13:05.140
CoreText has both Quartz
and Cocoa integration.

00:13:05.140 --> 00:13:09.260
Now, I suppose integration isn't
exactly the right word to use.

00:13:09.340 --> 00:13:12.900
I think I was looking for
a word closer to synergy.

00:13:12.900 --> 00:13:18.890
But basically what this means is that,
as Julio mentioned,

00:13:18.950 --> 00:13:25.900
Quartz is the only way to get text
drawn on Mac OS X at the lowest level.

00:13:25.930 --> 00:13:29.620
And so obviously,
Quartz is making use of Quartz.

00:13:29.630 --> 00:13:34.170
But in addition, as you'll see,
for those of you who need access

00:13:34.170 --> 00:13:38.990
to the lowest level of information,
we've provided that to you in a form

00:13:39.120 --> 00:13:41.330
that is directly usable by Quartz.

00:13:41.410 --> 00:13:45.850
So there aren't any expensive type
conversions that you'll need to do or

00:13:45.850 --> 00:13:50.900
that need to be done internally even in
order to make use of that information.

00:13:50.900 --> 00:13:51.580
And for Cocoa, of course,
since Quartz is a core file,

00:13:51.580 --> 00:13:52.110
a file that's not
necessarily a core file,

00:13:52.110 --> 00:13:52.900
it's a core file that's not
necessarily a core file.

00:13:52.900 --> 00:13:53.190
So we've provided that to you in a
form that is directly usable by Quartz.

00:13:53.200 --> 00:13:53.460
So there aren't any expensive type
conversions that you'll need to do or

00:13:53.460 --> 00:13:53.900
that need to be done internally even in
order to make use of that information.

00:13:53.910 --> 00:13:54.370
And for Cocoa, of course,
since Quartz is a core file,

00:13:54.370 --> 00:13:54.900
a very common file that's
not necessarily a core file,

00:13:54.940 --> 00:13:58.390
but it's a core file, a core framework,
it doesn't require the use of

00:13:58.390 --> 00:14:01.900
any higher level framework,
be it Carbon or Cocoa.

00:14:01.920 --> 00:14:04.870
But if you are making use of Cocoa,
there are a couple of instances

00:14:04.930 --> 00:14:09.900
where we've been able to
streamline the process of doing so.

00:14:09.900 --> 00:14:13.900
And so if you are programming
in a Cocoa application,

00:14:13.900 --> 00:14:16.090
it'll be really easy to get
information into Quartz,

00:14:16.090 --> 00:14:17.990
and I'll show you how.

00:14:18.540 --> 00:14:22.520
The most important thing on this slide
and the thing I want you to remember is,

00:14:22.520 --> 00:14:25.640
like Julio said, simple tasks are simple.

00:14:25.840 --> 00:14:29.900
And frequently these are the most common
operations you're going to need to do.

00:14:29.900 --> 00:14:32.990
If you want to draw a simple
paragraph of text on screen,

00:14:32.990 --> 00:14:36.480
you shouldn't have to write a bunch
of code in order to do so because,

00:14:36.600 --> 00:14:37.990
hey, everybody needs to do it.

00:14:38.080 --> 00:14:41.260
So with CoreText,
we've made those simple tasks,

00:14:41.260 --> 00:14:43.950
those common operations, very easy to do.

00:14:43.960 --> 00:14:47.710
And I'll be showing you several
examples of how to do so.

00:14:47.930 --> 00:14:50.790
And finally,
CoreText is easy to optimize.

00:14:51.020 --> 00:14:53.420
Well, what exactly do I mean by this?

00:14:53.760 --> 00:14:58.420
Well, with ATSUI,
there are cases where calling

00:14:58.420 --> 00:15:01.800
one function could cause a
performance degradation elsewhere

00:15:01.800 --> 00:15:05.690
in a different ATSUI function,
and it wasn't always very obvious,

00:15:05.770 --> 00:15:09.560
even to us Apple engineers,
when those cases were going to be.

00:15:09.740 --> 00:15:12.760
And so with CoreText,
we've tried to make the processing

00:15:12.760 --> 00:15:16.560
that we've done more transparent,
so you'll be able to look at a piece

00:15:16.710 --> 00:15:21.240
of code using CoreText and make a very
accurate prediction as to where the

00:15:21.370 --> 00:15:24.920
time in your application is going to
be spent for large amounts of text.

00:15:25.050 --> 00:15:28.280
And so we think that this will make
you a lot more interested in using

00:15:28.280 --> 00:15:31.780
CoreText since you won't have to
worry about those issues since you'll

00:15:31.780 --> 00:15:33.400
be able to see it all up front.

00:15:33.600 --> 00:15:38.990
And since it's so fast to start, then,
well, you're off on a good foot already.

00:15:40.030 --> 00:15:42.970
So to start,
I figured it wouldn't be fair

00:15:42.980 --> 00:15:45.650
to let you get through a session
without having some sort of demo.

00:15:45.720 --> 00:15:49.100
And so I'm going to show you what the
operation that we call frame setting,

00:15:49.100 --> 00:15:53.140
but you probably know as
simple multi-line text layout.

00:16:06.660 --> 00:16:11.860
Okay, so with this example,
I have a couple of text

00:16:11.860 --> 00:16:15.400
documents on screen,
and let me bring those up now.

00:16:15.490 --> 00:16:18.270
So for those of you
who can read this text,

00:16:18.320 --> 00:16:23.000
you'll see that they're not exactly
the world's most engrossing documents,

00:16:23.060 --> 00:16:25.970
but they do have some interesting
characteristics that I just

00:16:25.970 --> 00:16:27.360
want to point out quickly.

00:16:27.470 --> 00:16:30.180
Both of these documents
are regular RTF files,

00:16:30.240 --> 00:16:32.700
and I'm showing them
in TextEdit right now.

00:16:32.740 --> 00:16:37.230
And so you'll see this first one
with WWDC at the top has a couple

00:16:37.230 --> 00:16:38.710
of interesting characteristics.

00:16:38.970 --> 00:16:40.400
It's set in two different languages.

00:16:40.400 --> 00:16:43.400
I've got the same text
on here in Japanese.

00:16:43.470 --> 00:16:47.040
And you'll note that there are tab
stops around these bullet points here.

00:16:48.420 --> 00:16:51.100
In this other document,
which is the text of

00:16:51.100 --> 00:16:53.330
the French Constitution,
you'll see that there's a large

00:16:53.330 --> 00:16:56.100
amount of text in this document,
and that it also makes use of

00:16:56.200 --> 00:17:00.800
some various fonts and styles
here for simple formatting.

00:17:00.960 --> 00:17:07.230
And so we have two documents that
are looking great in TextEdit,

00:17:07.600 --> 00:17:10.860
and so I've written a demo
application that I'd like to

00:17:10.860 --> 00:17:12.610
show you CoreText with now.

00:17:17.900 --> 00:17:22.190
So this demo example that I've
written is basically a very,

00:17:22.200 --> 00:17:27.920
very simple Cocoa application,
but really what I'm making

00:17:27.920 --> 00:17:32.300
use of Cocoa here is for its
RTF reading capabilities.

00:17:32.300 --> 00:17:35.420
And so there's nothing in this
demo that's inherently tied

00:17:35.420 --> 00:17:40.300
to the use of Cocoa with the
exception of the RTF reading,

00:17:40.300 --> 00:17:44.070
but basically what I've done
is created a custom view using

00:17:44.170 --> 00:17:46.240
CoreText to do text layout.

00:17:46.240 --> 00:17:49.690
So anything you can do
with Cocoa using CoreText,

00:17:49.760 --> 00:17:54.390
of course, Carbon is available also,
and we'll be making samples available

00:17:54.390 --> 00:17:56.490
to you using both of those frameworks.

00:17:57.400 --> 00:18:02.100
So let's go ahead and open up both of
these documents in my application here.

00:18:02.230 --> 00:18:05.980
Now, as I noted,
I simply made a custom view

00:18:05.980 --> 00:18:11.300
here that uses CoreText to
do the layout of this text.

00:18:11.390 --> 00:18:14.250
And the first thing you'll notice
is that both these documents

00:18:14.310 --> 00:18:17.100
have their formatting preserved,
which is great,

00:18:17.190 --> 00:18:23.300
because all I did was just
ask for the RTF to be parsed,

00:18:23.320 --> 00:18:27.300
and now I'm using CoreText to render it,
and it looks great out of the box.

00:18:27.300 --> 00:18:32.300
One of the other features that I added
to this view is that when I click on it,

00:18:32.300 --> 00:18:35.290
I can change the number of columns
that the text is displaying in.

00:18:35.300 --> 00:18:38.400
And so in this example,
I have that large document,

00:18:38.400 --> 00:18:40.300
and I'm displaying it in three columns.

00:18:40.300 --> 00:18:43.240
And one thing you'll notice is
that besides the formatting,

00:18:43.310 --> 00:18:47.730
which is the same as it was before,
it's still smooth and responsive

00:18:47.730 --> 00:18:50.300
even for three columns of text.

00:18:53.300 --> 00:18:54.800
Thank you.

00:18:54.800 --> 00:18:57.330
Could we switch back to the slides?

00:19:04.600 --> 00:19:09.940
So really, at this point,
this demo is just smoke and mirrors.

00:19:10.060 --> 00:19:14.310
And so I thought what I'd do is show
you the code that it took to actually

00:19:14.470 --> 00:19:16.560
draw that view using CoreText.

00:19:16.560 --> 00:19:19.700
And so you can think of what
needed to be done there.

00:19:19.760 --> 00:19:23.240
Basically,
we have the bounding box of the view.

00:19:23.250 --> 00:19:26.170
And in that last example,
we went ahead and determined

00:19:26.180 --> 00:19:29.950
what the boxes for the three
columns in that view were.

00:19:30.150 --> 00:19:34.580
And so once we have those boxes
determined for each column,

00:19:34.600 --> 00:19:39.090
I'll show you the code that was needed
in order to draw the text using CoreText.

00:19:43.040 --> 00:19:44.740
Well, that's it.

00:19:44.880 --> 00:19:47.690
You'll see at the top there's a
for loop for each of the columns

00:19:47.760 --> 00:19:48.760
that I'm going to be drawing.

00:19:49.060 --> 00:19:51.890
Now, at this point,
I don't expect you to know what the

00:19:51.890 --> 00:19:53.650
classes are that we're dealing with here.

00:19:53.780 --> 00:19:56.400
What I do want to point
out is how simple this was.

00:19:56.620 --> 00:20:01.360
Simply for each path for the box
that we're drawing text into,

00:20:01.510 --> 00:20:03.860
we're going to create a frame,
we're going to draw it,

00:20:03.900 --> 00:20:06.400
and if there's any more,
we're going to move on to the next.

00:20:06.400 --> 00:20:08.400
And that's all there is to it.

00:20:08.400 --> 00:20:10.430
So you can imagine for
a simple box of text,

00:20:10.430 --> 00:20:15.280
all you need are those first two calls,
which is fantastic because I need to

00:20:15.420 --> 00:20:19.420
set text in boxes quite frequently,
and so we've tried to make

00:20:19.420 --> 00:20:20.400
it as easy as possible.

00:20:20.400 --> 00:20:25.020
So in the next few slides,
I'm going to explain to you exactly what

00:20:25.020 --> 00:20:31.020
these classes are that I'm dealing with,
so don't worry about that now, but again,

00:20:31.020 --> 00:20:33.390
fast and easy with CoreText.

00:20:34.690 --> 00:20:39.550
So now I'm going to kind of give you
the roadmap to the CoreText headers that

00:20:39.550 --> 00:20:42.270
you have available in your Leopard Seed.

00:20:42.430 --> 00:20:46.260
But to do so,
first I just want to have one aside

00:20:46.300 --> 00:20:48.300
to talk about some terminology.

00:20:48.530 --> 00:20:52.380
And that is that since CoreText is
a UniCode text layout engine,

00:20:52.460 --> 00:20:56.440
we do have to touch on UniCode
terminology for this process.

00:20:56.920 --> 00:21:01.300
And that is that there's a distinction
between characters and glyphs.

00:21:01.490 --> 00:21:06.400
Now, characters are the numeric input,
the actual values of the characters

00:21:06.400 --> 00:21:08.600
that we're going to layout.

00:21:08.730 --> 00:21:10.900
And glyphs,
those are the graphical entities

00:21:10.990 --> 00:21:14.600
that actually are used to
display the text on screen.

00:21:14.920 --> 00:21:20.600
Now, as Julio pointed out,
Quartz doesn't really know text.

00:21:20.660 --> 00:21:21.940
All it knows are glyphs.

00:21:22.040 --> 00:21:25.540
And so what people need is a way to
get from the text that they have,

00:21:25.630 --> 00:21:28.600
along with any style
information they might have,

00:21:28.600 --> 00:21:33.610
such as font sizes or colors or whatever,
and convert them into the appropriate

00:21:33.650 --> 00:21:36.700
glyphs for drawing that text on screen.

00:21:36.820 --> 00:21:40.380
And so that is the process
that CoreText provides to you,

00:21:40.460 --> 00:21:42.500
is that text layout process.

00:21:42.610 --> 00:21:47.420
And so when I, if I refer to text as
having been laid out,

00:21:47.560 --> 00:21:50.730
then what we are dealing
with are the glyphs that are

00:21:51.120 --> 00:21:53.140
appropriate for use by Quartz.

00:21:53.420 --> 00:21:56.960
So to start with,
to give you this roadmap to find out how

00:21:56.960 --> 00:22:00.770
to dive into CoreText and make use of it,
we should start by talking

00:22:00.770 --> 00:22:04.460
about a fundamental class,
which is the attributed string.

00:22:04.500 --> 00:22:08.660
Now, when I say fundamental,
I don't mean that CoreText implements

00:22:08.660 --> 00:22:12.830
an attributed string class,
but rather it is vital to

00:22:12.830 --> 00:22:17.390
CoreText because this is the
input type for all of the layout

00:22:17.470 --> 00:22:20.370
operations performed by CoreText.

00:22:21.220 --> 00:22:25.100
So you have two choices for classes
to use for an attributed string.

00:22:25.290 --> 00:22:29.240
There's CF attributed string
and NS attributed string.

00:22:29.340 --> 00:22:31.770
As the names imply, they're very similar,
and in fact,

00:22:31.770 --> 00:22:34.960
they're what we call toll-free bridged,
which means that any time you

00:22:34.960 --> 00:22:40.100
see a function that takes one of
these classes as a parameter type,

00:22:40.130 --> 00:22:42.920
then the other can be
used interchangeably.

00:22:43.170 --> 00:22:50.120
So really then it comes down to how you
choose to construct these objects and/or

00:22:50.460 --> 00:22:52.000
where you may have gotten them from.

00:22:52.090 --> 00:22:56.610
But both of these objects are
the same in their function,

00:22:56.610 --> 00:22:59.370
and that is to store the text
and the style information that's

00:22:59.370 --> 00:23:01.000
associated with that text.

00:23:01.000 --> 00:23:04.000
And so if you look in
the CoreText headers,

00:23:04.000 --> 00:23:09.250
you'll see that we provide a list
of various attribute names for

00:23:09.470 --> 00:23:12.000
styles to which CoreText responds.

00:23:12.070 --> 00:23:14.720
And so basically each of these classes,
for those of you who

00:23:14.830 --> 00:23:17.030
aren't familiar with it,
and I'm sure many of you

00:23:17.030 --> 00:23:21.500
have seen these before,
for each range of text it has associated

00:23:21.520 --> 00:23:25.000
with it a dictionary of keys and values.

00:23:25.000 --> 00:23:29.000
And those keys are the attribute
names and the values are,

00:23:29.000 --> 00:23:32.710
for instance, for a font attribute name,
it would be the font object

00:23:32.710 --> 00:23:35.090
itself corresponding to that text.

00:23:35.730 --> 00:23:38.000
So one note on bridging here.

00:23:38.010 --> 00:23:42.830
So in that example that I showed you,
what I got from the RTF conversion

00:23:42.840 --> 00:23:47.910
was an NS attributed string that
contained all the style information

00:23:47.950 --> 00:23:50.610
for the text I was drawing.

00:23:50.640 --> 00:23:56.570
CoreText does make available to you its
list of attributes that it responds to.

00:23:56.600 --> 00:23:59.880
But of course,
it would be rather a nuisance if

00:23:59.880 --> 00:24:03.110
you had an NS attributed string
and you needed to convert from,

00:24:03.260 --> 00:24:07.310
say,
NS font attribute name to our version,

00:24:07.370 --> 00:24:09.590
the KCT font attribute name.

00:24:09.880 --> 00:24:12.860
And so we have taken the
opportunity to bridge the most

00:24:12.860 --> 00:24:14.840
commonly used Cocoa attributes.

00:24:15.010 --> 00:24:18.540
And so for those of you who are using
CoreText within a Cocoa application,

00:24:18.580 --> 00:24:22.080
this is one of those steps we've taken
in order to make that integration

00:24:22.080 --> 00:24:23.700
simple and painless for you.

00:24:23.780 --> 00:24:27.500
So let's get on to what is
actually in CoreText now.

00:24:27.560 --> 00:24:32.580
And the first object or class that I want
to talk to you about is the frame setter.

00:24:33.600 --> 00:26:39.300
[Transcript missing]

00:26:40.340 --> 00:26:43.830
Well,
the Framesteader internally makes use of

00:26:44.490 --> 00:26:49.600
a class referred to as the typesetter,
and this is really the heart of CoreText.

00:26:49.670 --> 00:26:53.030
The typesetter is the class that
is responsible for performing

00:26:53.030 --> 00:26:54.680
the layout operation itself.

00:26:54.780 --> 00:26:59.760
So once you've supplied
CoreText with an attribute of string,

00:26:59.820 --> 00:27:02.200
you've given it the text and the
styles that it needs in order

00:27:02.200 --> 00:27:06.640
to determine which glyphs are
appropriate for drawing that text.

00:27:06.680 --> 00:27:10.530
And so the typesetter is the class
that actually does that for you.

00:27:10.650 --> 00:27:13.080
And so internally,
the typesetter is the Framesteader,

00:27:13.110 --> 00:27:13.750
excuse me.

00:27:14.000 --> 00:27:17.440
The Framesteader is making use of
a typesetter in order to determine

00:27:17.440 --> 00:27:19.880
the actual text to be drawn,
but you also have the

00:27:19.880 --> 00:27:24.410
opportunity to use it directly,
which is fantastic because, well,

00:27:24.600 --> 00:27:26.460
it comes in handy.

00:27:26.520 --> 00:27:30.980
The typesetter has a couple of other
functions besides its core function,

00:27:31.030 --> 00:27:36.440
and those other functions are to
suggest line breaks and to create lines.

00:27:36.470 --> 00:27:40.340
Now, the process of suggesting
a line break is simple.

00:27:40.390 --> 00:27:45.310
It says, for a given amount of space,
how much text can I fit on a

00:27:45.310 --> 00:27:47.910
single line within that space?

00:27:48.070 --> 00:27:53.350
And so the typesetter is responsible
for determining what the appropriate

00:27:53.690 --> 00:27:57.640
length of -- what the appropriate
length for a line is given a width,

00:27:57.710 --> 00:28:01.200
and it can do so by the
most common word break,

00:28:01.200 --> 00:28:04.240
word wrapping,
or there's also an opportunity

00:28:04.240 --> 00:28:08.890
to get finer-grained,
cluster breaks, but the default is,

00:28:08.890 --> 00:28:12.390
of course, to do simple word wrapping.

00:28:12.770 --> 00:28:15.500
And finally,
the typesetter creates lines.

00:28:15.550 --> 00:28:18.240
Now, I alluded to this when I was
talking about line breaking,

00:28:18.320 --> 00:28:20.100
but what is a line?

00:28:20.140 --> 00:28:26.390
Well, a line is the object of
core currency in CoreText.

00:28:26.800 --> 00:28:29.620
It is the object that holds
the glyphs that are the result

00:28:29.700 --> 00:28:31.600
of the text layout process.

00:28:31.680 --> 00:28:36.790
And so any individual line can
correspond to a range of characters

00:28:36.840 --> 00:28:39.050
within an attributed string.

00:28:39.230 --> 00:28:42.110
And so you might imagine that
a line can encompass the entire

00:28:42.110 --> 00:28:45.930
string that you provided it with,
which could be miles long, really,

00:28:45.930 --> 00:28:49.970
or it can correspond to individual
lines within a paragraph,

00:28:49.970 --> 00:28:51.000
as you've seen.

00:28:51.630 --> 00:28:55.700
And so these line objects can be
created from several different sources.

00:28:56.030 --> 00:28:59.990
As I mentioned, the frame setter,
which will create lines for you,

00:29:00.250 --> 00:29:03.970
has an array of lines
corresponding to the text in the

00:29:04.360 --> 00:29:07.430
box that you asked it to fill.

00:29:07.930 --> 00:29:09.870
The line can also be
created from the typesetter.

00:29:09.990 --> 00:29:12.240
So, for instance,
in a line breaking example,

00:29:12.240 --> 00:29:15.780
and I've got a slide on
this in just a few seconds,

00:29:15.890 --> 00:29:20.200
you'll ask a typesetter to create a
line from a known range of characters.

00:29:20.300 --> 00:29:22.860
And in addition,
we realize that multi-line text

00:29:23.190 --> 00:29:26.290
layout is not something that
you're always going to need to do.

00:29:26.300 --> 00:29:30.260
And there are cases when you
need just a simple label of text

00:29:30.370 --> 00:29:32.290
or a single line that you know.

00:29:32.300 --> 00:29:34.820
And so in that case,
there's a convenience method

00:29:34.820 --> 00:29:38.300
offered by the line for creating
what we call a freestanding line.

00:29:38.300 --> 00:29:42.550
The result is the same,
but the upside is that you don't need to

00:29:42.550 --> 00:29:45.800
manage creating the typesetter yourself.

00:29:45.800 --> 00:29:49.210
And so this is another way
where we've tried to make

00:29:49.210 --> 00:29:51.510
your life a little bit easier.

00:29:53.080 --> 00:29:55.400
Once you have a line,
there are several operations that

00:29:55.510 --> 00:29:58.340
you can perform with that line.

00:29:58.340 --> 00:30:01.550
One of the most common operations
is the process of determining

00:30:01.680 --> 00:30:04.410
the flushness of that line,
which you might also

00:30:04.410 --> 00:30:05.880
know of as alignment.

00:30:05.880 --> 00:30:11.320
So given a particular line,
then if I know that I'm going

00:30:11.320 --> 00:30:14.000
to draw it into a certain space,
I might want it to be, say,

00:30:14.150 --> 00:30:15.860
right flush or aligned right.

00:30:15.860 --> 00:30:18.100
And so a line can give you the
information that you need in

00:30:18.100 --> 00:30:22.130
order to draw it in the correct
position for that flushness.

00:30:22.370 --> 00:30:25.470
A line can also create a justified
or a truncated version of itself,

00:30:25.520 --> 00:30:28.510
which is great when you need to
perform either of those operations.

00:30:31.310 --> 00:30:35.410
Most commonly, though,
you'll probably be asking the

00:30:35.410 --> 00:30:37.590
line for various measurements.

00:30:37.690 --> 00:30:41.030
And there are two major types of
measurements that we provide from

00:30:41.030 --> 00:30:43.190
the line object using CoreText.

00:30:43.300 --> 00:30:46.690
The first is something we call the
typographic bounds of the line,

00:30:46.690 --> 00:30:49.430
and the second is the
image bounds of the line.

00:30:49.570 --> 00:30:53.230
Now the typographic bounds is
what you'll be using when you're

00:30:53.230 --> 00:30:55.600
dealing with lines of text.

00:30:55.690 --> 00:30:58.460
And those are the common measurements
that you'll need to know how to place

00:30:58.460 --> 00:30:59.900
those lines relative to each other.

00:30:59.900 --> 00:31:02.920
And those are measurements,
the ascent and descent

00:31:02.980 --> 00:31:05.300
of the line as a whole,
and the width,

00:31:05.490 --> 00:31:08.120
the typographic width of that line.

00:31:08.880 --> 00:31:10.240
So for text,
those are the most appropriate

00:31:10.320 --> 00:31:11.840
measurements to be using.

00:31:11.910 --> 00:31:17.790
But there are others of you who are using
text as sort of a graphical element,

00:31:18.020 --> 00:31:18.800
really.

00:31:18.810 --> 00:31:21.290
And so what you need to know is,
you know,

00:31:21.290 --> 00:31:25.800
I'm going to be using this text as an
object in a graphic that I'm drawing,

00:31:25.800 --> 00:31:28.790
and so what is it exactly?

00:31:28.920 --> 00:31:33.990
And so the image bounds for a given
line are defined as the rectangle

00:31:34.170 --> 00:31:37.030
that -- the smallest possible
rectangle that encloses all of

00:31:37.080 --> 00:31:38.800
the glyphs in that particular line.

00:31:38.800 --> 00:31:43.090
And so if you don't need to deal
with the ascent and descent of

00:31:43.290 --> 00:31:46.800
the text and you want to know
the actual coverage of that line,

00:31:46.800 --> 00:31:48.770
then the image bounds are for you.

00:31:48.800 --> 00:31:53.680
And finally, the line object,
like the frame object, is ready to draw.

00:31:53.850 --> 00:31:58.800
So since we designed CoreText to
be an immediate image,

00:31:58.800 --> 00:32:01.720
and we're going to be
using CG adjunct to Quartz,

00:32:01.810 --> 00:32:05.800
we use the same placement
strategy as Quartz for text.

00:32:05.800 --> 00:32:10.800
And that is that the origin of a line
of text is on the baseline of the text.

00:32:10.850 --> 00:32:15.530
And so as you would in Quartz,
to figure out where to put this line,

00:32:15.800 --> 00:32:19.700
you simply set the text position
in a CG context and then have the

00:32:19.700 --> 00:32:21.730
line draw itself into that context.

00:32:22.010 --> 00:32:23.800
So it's very simple.

00:32:24.500 --> 00:32:27.580
So as I mentioned at
the start of this talk,

00:32:27.600 --> 00:32:30.890
we tried to make common
operations very easy to do.

00:32:31.250 --> 00:32:36.280
And so I'd like to spend a few
lines now talking about those common

00:32:36.280 --> 00:32:39.540
examples I gave you and how you
can actually do them with CoreText.

00:32:39.600 --> 00:32:42.270
So we're going to take
a look at some code now,

00:32:42.270 --> 00:32:44.360
but I don't think it's too much.

00:32:45.430 --> 00:32:49.430
The first of these operations is the
process of drawing a simple paragraph.

00:32:49.430 --> 00:32:53.720
And this is essentially the heart
of that first slide of code I gave

00:32:53.720 --> 00:32:56.060
you earlier on as part of my demo.

00:32:56.060 --> 00:32:59.180
And so in all these examples,
I'm going to assume that you've

00:32:59.180 --> 00:33:03.320
already figured out some things
that are important to the particular

00:33:03.760 --> 00:33:05.580
application of this process.

00:33:06.080 --> 00:33:09.160
And so in this case,
we'll have an attributed string.

00:33:09.180 --> 00:33:12.530
We'll have a path that corresponds
to the box in which we're going

00:33:12.620 --> 00:33:13.760
to want to draw this text.

00:33:13.810 --> 00:33:16.000
And we have the CG context itself.

00:33:16.000 --> 00:33:18.000
So I'll assume that we've set those up.

00:33:18.030 --> 00:33:19.910
Now once we have those,
we go ahead and create

00:33:19.910 --> 00:33:22.960
a framesetter object,
CTFramesetterCreateWithAttributedString.

00:33:23.010 --> 00:33:26.790
And this will give you that object then
that is responsible for doling out those

00:33:26.790 --> 00:33:28.970
frame objects that I talked to you about.

00:33:29.000 --> 00:33:32.240
And so in this example,
we're simply going to fill

00:33:32.240 --> 00:33:33.920
a single box with text.

00:33:34.000 --> 00:33:38.000
And so with that framesetter,
we simply ask it to create us a frame.

00:33:38.000 --> 00:33:40.760
And then once we have that frame,
we can draw that frame

00:33:40.760 --> 00:33:41.980
into the CG context.

00:33:42.000 --> 00:33:45.990
So I will point out that in
the examples that I'm giving,

00:33:46.070 --> 00:33:48.880
you should note that I've,
in addition to leaving out the

00:33:48.880 --> 00:33:51.750
initialization of those variables,
I've also left out the very

00:33:51.750 --> 00:33:54.000
necessary calls to CF release.

00:33:54.000 --> 00:33:56.680
But it shouldn't be difficult to
figure out where you need to put

00:33:56.760 --> 00:33:59.000
those because we followed the example.

00:33:59.000 --> 00:34:05.760
And so what I've done is left off the
calls to CF release in these examples.

00:34:06.370 --> 00:34:11.980
But don't forget.

00:34:12.750 --> 00:34:15.500
So that's all it takes for a paragraph.

00:34:15.560 --> 00:34:19.580
The other common example I gave is
using just text as a label within

00:34:19.590 --> 00:34:23.600
a graphic or perhaps you know that
you have a limited amount of text.

00:34:23.600 --> 00:34:25.590
And this next one is a
little bit more complicated,

00:34:25.680 --> 00:34:29.670
but that's only because I actually
show you how to create the

00:34:29.670 --> 00:34:31.600
attributed string itself.

00:34:31.600 --> 00:34:34.600
So again at the top we're going
to start with some things.

00:34:34.600 --> 00:34:35.600
We've got a string.

00:34:35.600 --> 00:34:37.600
This is just a plain old CFString.

00:34:37.600 --> 00:34:40.140
And we've got a font,
which we're going to talk

00:34:40.140 --> 00:34:41.340
about in just a second.

00:34:41.610 --> 00:34:43.600
And we've got our CG context again.

00:34:43.600 --> 00:34:46.250
So then in order to create
the attributed string,

00:34:46.320 --> 00:34:48.690
for those of you who
are unfamiliar with it,

00:34:48.690 --> 00:34:52.210
what we're going to do is we're going to
make the dictionary of those key value

00:34:52.210 --> 00:34:54.600
pairs that define the style attributes.

00:34:54.600 --> 00:34:57.060
And so in this case there's
only one style that I'm

00:34:57.060 --> 00:34:58.600
going to apply to my string.

00:34:58.620 --> 00:35:01.150
So in this case I know that
I have a particular font that

00:35:01.150 --> 00:35:03.600
I want to draw the string from.

00:35:03.600 --> 00:35:06.600
And of course being a good
programmer I got this string

00:35:06.600 --> 00:35:07.600
from a localized string.

00:35:07.600 --> 00:35:10.510
So I'm going to call this strings
file or nib or however you've

00:35:10.510 --> 00:35:12.600
chosen to localize your application.

00:35:12.600 --> 00:35:16.980
And so I'm going to apply the font
to it by creating an attributed

00:35:16.980 --> 00:35:18.600
string with those attributes.

00:35:18.600 --> 00:35:21.960
And then once I've done that,
now we can actually get into

00:35:21.960 --> 00:35:23.600
the core text part of things.

00:35:23.600 --> 00:35:27.140
And that is we're going to create,
as I mentioned, this freestanding line,

00:35:27.140 --> 00:35:28.600
which is this convenience.

00:35:28.600 --> 00:35:31.600
So CT line create with attributed string.

00:35:31.860 --> 00:35:35.630
Once we have that line we can use
either of those measurement capabilities

00:35:35.630 --> 00:35:37.600
I talked about a couple slides back.

00:35:37.600 --> 00:35:40.700
Either the typographic bounds or the
image bounds to figure out where I'm

00:35:40.770 --> 00:35:43.600
going to put this in my CG context.

00:35:43.600 --> 00:35:48.600
And once I've done so I set my
text position and I draw the line.

00:35:48.600 --> 00:35:50.600
So again, very easy.

00:35:50.600 --> 00:35:53.350
This example is a bit cluttered,
but that's only because

00:35:53.350 --> 00:35:54.600
of this stuff up here.

00:35:54.600 --> 00:35:58.600
But this should be old
hat to most of you.

00:36:00.260 --> 00:36:02.850
So now there's one more example
that I'm going to walk you through,

00:36:02.850 --> 00:36:04.940
and that's the process of line breaking.

00:36:04.970 --> 00:36:09.010
Now, most of you,
or I should say in many cases,

00:36:09.010 --> 00:36:11.660
you won't need to go through this
process yourself because we've

00:36:11.660 --> 00:36:16.700
already provided the frame object for
dealing with simple boxes of text.

00:36:16.750 --> 00:36:19.270
But you may find that in your
application you have more

00:36:19.280 --> 00:36:21.000
advanced line breaking needs.

00:36:21.030 --> 00:36:25.590
Maybe you have a special hyphenation
mechanism or some other sort of process

00:36:25.590 --> 00:36:28.700
that you need to do when breaking lines.

00:36:28.730 --> 00:36:34.400
And so what I've done here is I'm
going to replicate the process

00:36:34.420 --> 00:36:39.800
of filling a frame and show you
what's necessary so that if you have

00:36:39.800 --> 00:36:45.100
one of those more advanced needs,
then you can use this as a framework

00:36:45.270 --> 00:36:47.490
for doing what you need to do.

00:36:47.980 --> 00:36:51.140
So to start with, again,
we're going to have several variables

00:36:51.140 --> 00:36:53.900
that are set up as appropriate.

00:36:53.900 --> 00:36:56.330
In this case, we have the width,
which is,

00:36:56.330 --> 00:37:00.900
we'll assume it's the width of the box
in which we're going to set this text.

00:37:00.900 --> 00:37:03.900
And then we have our CG context,
of course.

00:37:03.900 --> 00:37:05.900
And then we have our text position.

00:37:05.900 --> 00:37:08.900
It's likely that you might not
have figured this out up front.

00:37:08.900 --> 00:37:09.900
Maybe we'll figure it out later on.

00:37:09.900 --> 00:37:12.220
But again,
I'll leave it as an exercise to

00:37:12.220 --> 00:37:15.830
the reader to figure out what
the text position is appropriate

00:37:16.070 --> 00:37:19.190
for this particular need.

00:37:20.930 --> 00:37:24.600
Once you've initialized those variables,
then we're going to start again

00:37:24.600 --> 00:37:27.680
with the heart of the process
by creating a typesetter.

00:37:28.100 --> 00:37:32.060
So the typesetter then is going to
take this attributed string and it's

00:37:32.130 --> 00:37:36.900
going to do some initial processing
on that to determine which glyphs are

00:37:36.900 --> 00:37:38.500
going to be used to draw that string.

00:37:38.630 --> 00:37:42.680
And so then the process of filling
this box with text then is going

00:37:42.680 --> 00:37:47.200
to be simply determining what each
of those lines are in that box.

00:37:47.340 --> 00:37:51.640
And we can do that by asking
the typesetter to create or to

00:37:51.640 --> 00:37:54.100
suggest a line break for us.

00:37:54.530 --> 00:37:56.900
And so in this example,
I'm going to start with

00:37:56.900 --> 00:38:00.260
the very start of the text,
the very first character

00:38:00.260 --> 00:38:02.160
in my attributed string.

00:38:02.320 --> 00:38:05.620
And so that's my start variable,
which is the offset

00:38:05.810 --> 00:38:07.400
into the string itself.

00:38:07.540 --> 00:38:08.380
And I've got a width.

00:38:08.470 --> 00:38:11.600
I know the width of the box
that I'm trying to fill.

00:38:11.680 --> 00:38:14.000
At this point, I'm trying to figure out
what the first line is.

00:38:14.000 --> 00:38:17.200
And so I'm going to ask the typesetter
to suggest a line break for me.

00:38:17.340 --> 00:38:20.050
And what the typesetter is going
to do is it's going to return to

00:38:20.050 --> 00:38:24.060
us the number of characters that
are appropriate for fitting in

00:38:24.060 --> 00:38:26.460
that -- on that first line of text.

00:38:26.500 --> 00:38:29.420
And so this is taking into
account things like hard breaks.

00:38:29.460 --> 00:38:32.250
And in this case, suggest line break,
of course,

00:38:32.250 --> 00:38:35.310
is the default method of word wrapping.

00:38:35.370 --> 00:38:37.820
So it will give you the
number of characters.

00:38:37.820 --> 00:38:39.220
It'll work out just great.

00:38:39.270 --> 00:38:41.160
And then once you've
gotten that information,

00:38:41.160 --> 00:38:44.480
then you can use the starting offset,
which is zero for our first line,

00:38:44.580 --> 00:38:48.370
and then the number of characters in that
first line to actually create the line.

00:38:48.450 --> 00:38:50.420
And so this is a pretty
simple process at this point.

00:38:50.420 --> 00:38:52.800
And so we've determined -- we've
determined what the text is

00:38:52.800 --> 00:38:56.080
going to fit on the first line
of this particular paragraph is.

00:38:56.130 --> 00:39:00.080
Now, I've decided to spice
things up just a little bit.

00:39:00.150 --> 00:39:03.000
And I'm going to draw
this first line centered.

00:39:03.330 --> 00:39:04.740
Okay, slow down.

00:39:05.060 --> 00:39:05.800
Okay.

00:39:05.910 --> 00:39:09.530
So we're going to determine
the flushness of this line.

00:39:09.530 --> 00:39:11.960
In CoreText,
we indicate flushness or alignment,

00:39:11.960 --> 00:39:15.580
as I mentioned,
as a floating point value between 0

00:39:15.580 --> 00:39:19.000
being left flush and 1 being right flush.

00:39:19.140 --> 00:39:23.740
And so in this case, of course,
0.5 seems just right for centered text.

00:39:23.890 --> 00:39:26.500
And so what I'm going to do is
I'm going to ask the line to

00:39:26.600 --> 00:39:29.920
tell me where I need to move,
how much I need to move

00:39:30.000 --> 00:39:34.340
my pen position by,
basically, in order to draw it perfectly

00:39:34.390 --> 00:39:36.400
centered within my known width.

00:39:36.470 --> 00:39:39.790
And so once I have that offset,
then I can go ahead and

00:39:39.790 --> 00:39:44.990
update my text position in my
CG context and then draw my line.

00:39:45.310 --> 00:39:50.150
So, one thing I want to point out
is that once I've asked the

00:39:50.260 --> 00:39:54.270
typesetter to suggest a line break,
this is a point in the process

00:39:54.360 --> 00:39:55.860
where you have some flexibility.

00:39:55.960 --> 00:39:59.090
So, for instance,
if you were dealing in a situation where

00:39:59.090 --> 00:40:03.960
you needed to prohibit a line break
between certain words in your text,

00:40:03.960 --> 00:40:06.730
then that's the point where you
don't necessarily have to take

00:40:06.730 --> 00:40:08.310
the suggestion right off the bat.

00:40:08.460 --> 00:40:12.540
You could confer with your own
information and adjust that as necessary

00:40:12.540 --> 00:40:16.460
for your needs and then go ahead and
create the line based on the suggestion

00:40:16.460 --> 00:40:17.460
but also some additional input.

00:40:17.460 --> 00:40:19.460
So, you have a lot of
flexibility in this process.

00:40:19.460 --> 00:40:21.410
So, at this point,
we've drawn our first line.

00:40:21.460 --> 00:40:23.460
In this case, we've drawn it centered.

00:40:23.460 --> 00:40:26.100
And so, in order to move on and find
out what the next line in the

00:40:26.170 --> 00:40:29.330
box we're going to be drawing,
we simply increment the starting

00:40:29.330 --> 00:40:33.460
position by the number of characters
that we had in our first line.

00:40:33.460 --> 00:40:36.120
And then we'll go back up and ask
the typesetter to suggest a line

00:40:36.120 --> 00:40:38.430
break for the next line in the box.

00:40:38.460 --> 00:40:41.780
And so, that is, in a nutshell,
the process of line

00:40:41.780 --> 00:40:42.460
breaking text with CoreText.

00:40:42.760 --> 00:40:46.560
Now, again,
this is going to be very helpful to

00:40:46.720 --> 00:40:49.460
those of you who have specific needs
when dealing with line breaking.

00:40:49.470 --> 00:40:53.620
But in many cases,
we expect that the framesetter will

00:40:53.620 --> 00:40:56.460
be all that's necessary in order to
deal with multiple lines of text.

00:40:56.460 --> 00:40:59.460
So, you have,
in addition to being very easy,

00:40:59.460 --> 00:41:02.460
you have a lot of
flexibility in this process.

00:41:03.670 --> 00:41:07.110
So now there's one more class I'm
going to talk to you about today.

00:41:07.110 --> 00:41:11.100
And this is another
instance where many of you,

00:41:11.100 --> 00:41:14.340
or for many of your needs,
you won't need to make use of this last

00:41:14.690 --> 00:41:18.900
class because we think that in general
dealing with lines and dealing with

00:41:18.900 --> 00:41:23.250
frames are much easier than dealing with
the nitty-gritty details of the actual

00:41:23.250 --> 00:41:26.500
glyphs when dealing with UniCode layout.

00:41:26.510 --> 00:41:30.160
But there are those of you who do
need access to that information.

00:41:30.250 --> 00:41:33.900
Perhaps you're going to perform
some graphical operation,

00:41:33.900 --> 00:41:37.600
some sort of, you know,
mask or fill or whatever

00:41:37.600 --> 00:41:39.900
on particular glyphs.

00:41:39.940 --> 00:41:45.360
Basically, you have need to read the
information about the glyphs

00:41:45.360 --> 00:41:47.040
themselves from the layout process.

00:41:47.070 --> 00:41:50.080
And so for those of you,
we make available to you

00:41:50.080 --> 00:41:51.820
individual glyph runs.

00:41:51.920 --> 00:41:59.940
So the glyph run is the smallest possible
storage container for a run of glyphs.

00:41:59.970 --> 00:42:04.160
And so it contains the actual glyphs,
their positions.

00:42:04.280 --> 00:42:08.290
And for each run,
you also have access to a dictionary

00:42:08.340 --> 00:42:12.340
of the style attributes that
pertain to the glyphs in that run.

00:42:12.370 --> 00:42:20.100
Now, each run is the result of having
grouped glyphs by their attributes.

00:42:20.180 --> 00:42:22.560
And so in addition to those style
attributes that you can get from

00:42:22.560 --> 00:42:27.140
the dictionary for each run that is
uniform for all the glyphs in that run,

00:42:27.170 --> 00:42:29.680
there are also occasionally
attributes that are not.

00:42:29.680 --> 00:42:30.920
And so you can see that the glyphs are
actually grouped by their attributes

00:42:30.920 --> 00:42:31.640
that are intrinsic to the text itself.

00:42:31.680 --> 00:42:34.460
So for instance, if you're dealing with
right-to-left text,

00:42:34.700 --> 00:42:37.330
of course,
the glyphs for a range of right-to-left

00:42:37.330 --> 00:42:39.110
text need to be swapped in turn.

00:42:39.280 --> 00:42:43.330
And so we may have made a
particular grouping of glyphs

00:42:43.330 --> 00:42:46.630
based on directionality,
for instance.

00:42:46.790 --> 00:42:50.720
So there are various reasons
why that might happen.

00:42:50.980 --> 00:42:54.310
But you can be assured that
the attributes for each run

00:42:54.420 --> 00:42:58.730
correspond equally to all of the
glyphs in that particular run.

00:42:59.390 --> 00:43:04.240
As with the line, you can use the run to
obtain measurements.

00:43:04.310 --> 00:43:06.400
Again,
we offer both the typographic bounds,

00:43:06.400 --> 00:43:10.860
which is ascent, descent,
and also the image bounds if

00:43:11.060 --> 00:43:14.400
you need to make use of that.

00:43:14.600 --> 00:44:30.100
[Transcript missing]

00:44:31.050 --> 00:44:33.100
Those are the basic objects
that we expect you to be

00:44:33.170 --> 00:44:34.580
dealing with in CoreText.

00:44:34.580 --> 00:44:38.300
And there are a number of
other functionality groupings

00:44:38.300 --> 00:44:40.200
available to you in CoreText.

00:44:40.310 --> 00:44:42.700
And so I haven't given you
an overview of every class,

00:44:42.700 --> 00:44:45.220
but like Core Foundation,
we've organized things

00:44:45.560 --> 00:44:47.000
by class in our headers.

00:44:47.050 --> 00:44:50.870
And so you know where to look now
to find out how to get started.

00:44:50.950 --> 00:44:53.030
But before you do so,
I do want to leave you some

00:44:53.130 --> 00:44:57.670
parting thoughts here for
this section of the talk.

00:44:57.680 --> 00:44:57.680
And

00:44:58.010 --> 00:45:01.500
The first of these points that I want
to mention is that we hope that you'll

00:45:01.500 --> 00:45:03.880
choose the right tool for the job.

00:45:04.440 --> 00:45:09.960
Now, in general,
this means that you can take advantage

00:45:10.080 --> 00:45:14.060
of these higher-level classes,
in particular the frame setter,

00:45:14.060 --> 00:45:16.300
for instance,
if you want to deal with paragraphs.

00:45:16.300 --> 00:45:20.750
And that way it's less hassle to
you because it's much less code than

00:45:20.800 --> 00:45:25.290
delving down into the lower levels and
so much less opportunity for mistakes.

00:45:25.300 --> 00:45:29.300
And I know I make a lot,
so I try to go as high as possible.

00:45:29.300 --> 00:45:32.380
In addition,
if you're using a higher-level

00:45:32.830 --> 00:45:36.390
class in CoreText,
it does take any opportunity

00:45:36.770 --> 00:45:41.300
it can to optimize operations
based on knowledge that it has.

00:45:41.300 --> 00:45:43.810
And so in some cases,
asking a frame setter to do

00:45:44.010 --> 00:45:47.290
something might be slightly
faster than doing it yourself,

00:45:47.410 --> 00:45:48.300
but we're just trying to help.

00:45:50.220 --> 00:45:53.180
But once you have picked which
class you're going to deal with,

00:45:53.260 --> 00:45:55.340
as I mentioned,
Framesetter for paragraphs,

00:45:55.430 --> 00:45:58.420
Typesetter if you want to do
things on individual lines,

00:45:58.420 --> 00:46:01.700
and Align if you're just dealing
with a known amount of text,

00:46:01.810 --> 00:46:03.940
we encourage you to reuse those objects.

00:46:04.040 --> 00:46:07.830
We expect that you've become used to
reusing your core foundation objects,

00:46:07.910 --> 00:46:10.880
and that's one of the reasons
we've made it easy to reuse

00:46:10.880 --> 00:46:12.540
CoreText objects as well.

00:46:12.650 --> 00:46:14.780
But of course,
anytime you create an object,

00:46:14.780 --> 00:46:17.740
there's a certain amount of
work associated with that.

00:46:17.850 --> 00:46:19.870
And so,
so long as you know that you can make use

00:46:20.060 --> 00:46:23.900
of that same work over and over again,
you can go ahead and retain that

00:46:23.900 --> 00:46:26.700
or stick it in a CF collection
class if you need to.

00:46:26.700 --> 00:46:29.090
But hang on to it for as long
as you can make use of it,

00:46:29.090 --> 00:46:33.870
and then when you're done with it,
CF release it, and it'll be great.

00:46:34.260 --> 00:46:38.670
There is sort of one bugaboo
that I have to talk about,

00:46:38.670 --> 00:46:42.200
and that is that you may find
yourself using CoreText within

00:46:42.200 --> 00:46:44.000
a larger application framework.

00:46:44.040 --> 00:46:46.900
And in particular,
you may find yourself drawing

00:46:46.920 --> 00:46:50.050
into a CG context that isn't
one that you've created.

00:46:50.190 --> 00:46:53.240
So it's kind of like the
dollar you found on the street.

00:46:53.270 --> 00:46:55.850
It spends like real money,
but you're not sure

00:46:55.850 --> 00:46:57.460
exactly where it's been.

00:46:57.520 --> 00:47:02.400
And so the one thing I want to
suggest to you is that unless

00:47:02.400 --> 00:47:05.650
you've created the context yourself,
or unless you know that everyone

00:47:05.650 --> 00:47:10.400
in your application is coordinating
the use of this context,

00:47:10.750 --> 00:47:12.610
it's a shared resource,
and so you should be

00:47:12.610 --> 00:47:13.900
defensive when using it.

00:47:13.940 --> 00:47:17.700
And so in particular,
if you set the text matrix properly,

00:47:17.750 --> 00:47:22.060
in general that corresponds to the
identity transform for the text matrix,

00:47:22.110 --> 00:47:25.500
then you're assured that the measurements
that you took from CoreText are

00:47:25.500 --> 00:47:29.210
going to correspond to what actually
gets drawn by Quartz in the end.

00:47:29.300 --> 00:47:32.200
So it's very easy to do.

00:47:32.200 --> 00:47:33.320
It's one call.

00:47:33.400 --> 00:47:36.120
But it's just good defensive programming.

00:47:36.180 --> 00:47:39.610
And finally,
if you are making use of the glyph run,

00:47:39.610 --> 00:47:42.280
individual run objects
when dealing with glyphs,

00:47:42.340 --> 00:47:45.620
don't assume that there's a one-to-one
mapping of characters to glyphs.

00:47:45.820 --> 00:47:48.740
I know this is preaching to
the choir for many of you,

00:47:48.850 --> 00:47:52.700
but the result is not
always a one-to-one mapping.

00:47:52.800 --> 00:47:56.450
Even in English text, for instance,
when dealing with ligatures,

00:47:56.560 --> 00:48:01.480
we have a case where there's not always
exactly one glyph for each character.

00:48:01.730 --> 00:48:05.390
And so when dealing with a run,
you should just be careful when you're

00:48:05.390 --> 00:48:10.740
dealing with it to ensure that you're
not assuming that there is that mapping,

00:48:10.880 --> 00:48:14.080
and things will get along just great.

00:48:14.550 --> 00:48:18.480
So with this overview of CoreText,
I think you have the bulk of

00:48:18.560 --> 00:48:21.100
the knowledge that you need
in order to go off and try

00:48:21.100 --> 00:48:23.000
using it in your applications.

00:48:23.070 --> 00:48:25.890
And in fact,
we encourage you to just give it a try.

00:48:25.900 --> 00:48:26.710
See if you like it.

00:48:26.840 --> 00:48:30.530
Maybe there's a problem that you
have a bunch of code for and you have

00:48:30.530 --> 00:48:33.310
some extra time in your schedule,
and you can try it out with

00:48:33.310 --> 00:48:37.050
CoreText and see if things
are easier or faster for you.

00:48:37.270 --> 00:48:39.200
And so we encourage you to do so.

00:48:39.230 --> 00:48:42.500
We've tried to make something
for you that is fun to use,

00:48:42.500 --> 00:48:45.880
frankly,
because it's so easy and so fast.

00:48:45.980 --> 00:48:49.130
We think you'll have the opportunity
to be a lot more playful in what you

00:48:49.130 --> 00:48:50.900
do with text in your application.

00:48:50.950 --> 00:48:53.970
And we've had fun making it,
and we certainly hope that

00:48:53.970 --> 00:48:55.800
you enjoy taking a look at it.

00:48:55.820 --> 00:48:59.790
And now that we've made it public to you,
we encourage your feedback,

00:48:59.790 --> 00:49:02.290
and we'd like to know what
else you need from us in order

00:49:02.330 --> 00:49:04.250
to make a great application.

00:49:04.360 --> 00:49:08.260
So the astute among you may
have noticed that there was one

00:49:08.350 --> 00:49:09.100
hole I left in the application.

00:49:09.100 --> 00:49:12.520
And that was where to get
that font that I stuck in my

00:49:12.520 --> 00:49:14.900
attributed string earlier on.

00:49:14.900 --> 00:49:19.180
And so in order to talk about the font
objects available in CoreText and the

00:49:19.180 --> 00:49:21.770
unified font architecture in CoreText,
I'd like to invite

00:49:21.770 --> 00:49:22.890
Julio back up on stage.

00:49:22.900 --> 00:49:24.770
Thank you.

00:49:30.660 --> 00:49:31.070
Thank you, Ned.

00:49:31.100 --> 00:49:32.200
That was great.

00:49:32.250 --> 00:49:36.280
Hopefully you can see why we're so
excited about CoreText layout and

00:49:37.100 --> 00:49:39.810
especially how simple it is to use.

00:49:40.490 --> 00:49:45.480
So before I talk to you about CT font,

00:49:45.950 --> 00:49:49.450
I want to give you a little
rundown of all the font references

00:49:49.490 --> 00:49:51.780
that we have in Mac OS X.

00:49:52.490 --> 00:49:54.400
Yeah, a little overwhelming, isn't it?

00:49:54.530 --> 00:49:57.500
But anyhow, it isn't that bad.

00:49:57.600 --> 00:50:01.960
At the lower level, we have ATS font,
and that is your primitive font

00:50:01.960 --> 00:50:04.160
reference to access any font data.

00:50:04.280 --> 00:50:08.010
Then on top of that, we have CG font,
which is you need one of these

00:50:08.010 --> 00:50:09.850
references if you need to draw text.

00:50:09.960 --> 00:50:11.170
It's a primitive font reference.

00:50:11.390 --> 00:50:16.780
Typically, it encapsulates an ATS font,
and new in Leopard,

00:50:17.030 --> 00:50:20.750
you can also deal with PDF fonts as well.

00:50:21.220 --> 00:50:23.590
On this side of the screen,
I have what I call the

00:50:23.590 --> 00:50:26.850
classic references,
references that predate Mac OS X,

00:50:27.020 --> 00:50:28.680
the FM font and the font family.

00:50:29.060 --> 00:50:31.860
An FM font is,
you can think of it pretty much

00:50:31.860 --> 00:50:35.610
the same as an ATS font reference,
whereas the FM font family is

00:50:35.700 --> 00:50:39.900
a collection of these fonts as
defined by the FOND resource.

00:50:39.900 --> 00:50:45.040
Now, we have an ATS font family,
which is also, think of it the same

00:50:45.040 --> 00:50:46.900
as an FM font family.

00:50:46.900 --> 00:50:50.400
I want to point this out here
at this point because being that

00:50:50.400 --> 00:50:56.170
Quickdraw is not available in 64-bit,
and architecture allows both

00:50:56.220 --> 00:50:59.900
64-bit and 32-bit applications
to be running at once.

00:50:59.900 --> 00:51:02.310
So,
it is very likely that you're going to,

00:51:02.310 --> 00:51:05.100
if you're a 64-bit app,
that you're going to be

00:51:05.100 --> 00:51:08.720
dealing with a 32-bit app that
has the old font references.

00:51:08.900 --> 00:51:12.430
So, I said Quickdraw is dead for 64-bit,
and it is,

00:51:12.430 --> 00:51:14.900
but there's a few APIs that still live.

00:51:14.900 --> 00:51:15.900
And those APIs are those that
I'll talk about in a minute.

00:51:15.900 --> 00:51:15.900
On this side of the screen,
I have what I call the

00:51:15.900 --> 00:51:15.900
classic references,
references that predate Mac OS X,

00:51:15.900 --> 00:51:15.900
the FM font family.

00:51:15.900 --> 00:51:15.900
An FM font family, which is also,
think of it the same

00:51:15.900 --> 00:51:15.900
as an ATS font family.

00:51:15.900 --> 00:51:19.550
And those APIs are those that allow
you to convert from the old FM font

00:51:19.650 --> 00:51:24.050
references to the new font references,
or to the ATS font references,

00:51:24.060 --> 00:51:26.720
so that you can still operate with them.

00:51:27.330 --> 00:51:29.260
Finally,
there is the ATSU font reference,

00:51:29.260 --> 00:51:32.900
and the ATSU font reference is
essentially the same as an FM font.

00:51:32.900 --> 00:51:35.780
They can be used interchangeably.

00:51:36.460 --> 00:51:42.230
On this side of the screen we have the
new font references native to Mac OS X.

00:51:42.250 --> 00:51:44.990
So you see the NS font and
then the NS font descriptor and

00:51:44.990 --> 00:51:48.640
sitting right below it you see the
CT font and CD font descriptor.

00:51:48.690 --> 00:51:50.610
I'm not going to get too
much into it right now.

00:51:50.830 --> 00:51:56.680
I will talk to them as
I talk about CT font.

00:51:57.940 --> 00:52:01.590
One of the features of
these font references,

00:52:01.590 --> 00:52:03.330
when you compare them with
the old font references,

00:52:03.430 --> 00:52:05.890
is that they do encapsulate
a lot of information.

00:52:05.910 --> 00:52:08.400
They're not just in the
old font references,

00:52:08.400 --> 00:52:12.030
they're just basically the same
as the primitive font references.

00:52:12.160 --> 00:52:16.230
So the new font reference,
you get a lot of that

00:52:16.430 --> 00:52:17.660
comes along with them.

00:52:17.690 --> 00:52:20.790
And there are some things that you
need to be aware of as you use them.

00:52:20.920 --> 00:52:24.200
So let's go into CoreText font.

00:52:25.510 --> 00:52:28.960
As I said at the beginning of the talk,
one of the feedback that we received from

00:52:28.960 --> 00:52:33.240
you is that font references were complex,
you needed something more unified.

00:52:33.240 --> 00:52:36.040
So that's what we set out
to do with CoreText font.

00:52:36.050 --> 00:52:41.730
We took a look at the old FM font APIs,
the ATS font APIs,

00:52:41.730 --> 00:52:45.990
what Cocoa had to offer,
but also we looked internally

00:52:45.990 --> 00:52:51.000
at what we did for our layout
engines and took into consideration

00:52:51.000 --> 00:52:52.760
feedback that we received from you.

00:52:52.950 --> 00:52:56.220
And we created a unified
API for you to use,

00:52:56.300 --> 00:53:01.000
an API where you can feel that everything
that you need to do for text drawing,

00:53:01.000 --> 00:53:02.750
you can stick within this API.

00:53:02.800 --> 00:53:05.580
No need to go from one API to the other.

00:53:06.010 --> 00:53:08.230
And the same with the font types.

00:53:08.540 --> 00:53:12.170
If you have a CT font,
there should be no reason for you to make

00:53:12.260 --> 00:53:17.550
a call to get an ATS font reference or an
FM font reference to get your job done.

00:53:17.680 --> 00:53:20.900
Everything that you need to do,
you should be able to do with CT font.

00:53:20.920 --> 00:53:22.680
And finally,
one of the great things about

00:53:22.680 --> 00:53:22.680
CoreText font is that it's
a very easy to use font.

00:53:22.680 --> 00:53:25.350
One of the goals that I set at the
beginning of the talk was to help

00:53:25.350 --> 00:53:29.880
our Carvin developers move away from
Quickdraw into the world of Mac OS X or

00:53:29.970 --> 00:53:32.600
the way things have looked in Mac OS X.

00:53:32.730 --> 00:53:35.600
All with the old way of looking
at font families and the way

00:53:35.690 --> 00:53:37.000
Quickdraw looks at fonts.

00:53:37.130 --> 00:53:40.940
And now you get the same view,
they can get the same view as the

00:53:40.940 --> 00:53:43.240
Cocoa developers have in the past.

00:53:43.410 --> 00:53:50.670
So as I talked about CoreText font,
you will notice all the similarities

00:53:50.670 --> 00:53:52.600
with the font Cocoa API.

00:53:52.600 --> 00:53:55.600
So to start with,
we have the font reference,

00:53:55.630 --> 00:53:58.040
CT font reference.

00:53:58.040 --> 00:54:04.910
That, you can think of a font reference
as a very specific font instance,

00:54:05.120 --> 00:54:09.000
much more so than an ATS font ref,
which is a pointer into a,

00:54:09.000 --> 00:54:12.390
or a reference to a face
or a strike in the font.

00:54:12.440 --> 00:54:15.210
With this one,
you can specify more things,

00:54:15.210 --> 00:54:16.460
such as a point size.

00:54:16.810 --> 00:54:20.110
If you're dealing with fonts that,
multiple master fonts that

00:54:20.210 --> 00:54:22.520
have variation information,
you can specify more things.

00:54:22.580 --> 00:54:25.690
You can specify that information
into the font reference.

00:54:25.780 --> 00:54:28.500
Also, if you want to create a font
reference for a particular

00:54:28.500 --> 00:54:31.720
font that has a font feature,
you can also do so.

00:54:31.720 --> 00:54:33.330
So it is quite specific.

00:54:33.410 --> 00:54:40.130
Think of it as the reference that
you will use to draw text or to

00:54:40.280 --> 00:54:45.750
find very specific information
about the text at that point size.

00:54:46.840 --> 00:54:50.700
So there are many or we have many
ways to create this font references.

00:54:50.840 --> 00:54:51.860
Here's just a sample.

00:54:51.860 --> 00:54:53.500
There's more than these.

00:54:53.620 --> 00:54:58.070
At the top, CT font create with font
descriptor is the preferred

00:54:58.070 --> 00:55:00.220
way to create font references.

00:55:00.340 --> 00:55:02.940
As I haven't talked
about font descriptors,

00:55:02.940 --> 00:55:07.010
I'll talk about them in a little bit and
we'll see why they're the preferred way.

00:55:07.110 --> 00:55:12.930
Now, the next three APIs that I have for
you are what I call conversion APIs.

00:55:13.190 --> 00:55:16.820
It is inevitable that as you deal
with all the layers in the system,

00:55:16.890 --> 00:55:19.500
you're going to be handed
font references that are not

00:55:19.890 --> 00:55:22.600
CT font or an NS font reference.

00:55:22.710 --> 00:55:26.180
So, for example,
if you get a Post-Crit name,

00:55:26.240 --> 00:55:28.860
you can use CT font create with name.

00:55:28.930 --> 00:55:32.030
If you're given an ATS font ref,
you can call CT font

00:55:32.030 --> 00:55:33.910
create with platform font.

00:55:34.060 --> 00:55:39.490
Or if you're dealing
with an old Carbon API,

00:55:39.600 --> 00:55:42.960
you likely will be provided with a
Quickdraw font reference of some sort.

00:55:42.960 --> 00:55:47.270
Be it the Quickdraw font family
name or a font family and a style.

00:55:47.530 --> 00:55:51.200
So you can create a font
reference using those as well.

00:55:51.240 --> 00:55:55.130
But the last API is a sample of
an API that I want to point out.

00:55:55.400 --> 00:55:59.370
It gives added value to the font API,
the new font API.

00:55:59.710 --> 00:56:06.770
CT font create UI font for language.

00:56:06.920 --> 00:56:12.260
With this API, when you call it,
you will get a font right

00:56:12.260 --> 00:56:12.820
away that has the UI.

00:56:12.820 --> 00:56:17.610
The UI font for the application
you're using and the

00:56:17.820 --> 00:56:21.320
localization that you're using.

00:56:21.320 --> 00:56:25.170
This is something that in the past,
I know Carbon developers couldn't

00:56:25.170 --> 00:56:26.400
do in any of the font APIs.

00:56:26.500 --> 00:56:31.400
They would have to query HIToolbox
to get what the appropriate font was.

00:56:31.530 --> 00:56:34.840
So now you can see a sample of
an API that's really putting

00:56:34.840 --> 00:56:36.480
everything into one spot.

00:56:36.600 --> 00:56:40.200
So you don't have to go to
different layers to get things done.

00:56:41.690 --> 00:56:45.460
Also, CT font provides a brand
new set of functionality.

00:56:45.590 --> 00:56:48.420
As I told you before,
we looked at what we do internally for

00:56:48.910 --> 00:56:55.140
our layout engines and things that you
had asked us to make available to you.

00:56:55.770 --> 00:57:01.280
These APIs, we have a set of APIs such as
APIs for getting line metrics,

00:57:01.280 --> 00:57:06.780
getting encoding information,
language information, glyph information,

00:57:06.950 --> 00:57:08.330
character to glyph mapping.

00:57:08.460 --> 00:57:11.630
All these APIs were,
a lot of them were private or not

00:57:11.630 --> 00:57:14.220
available in any of the other API sets.

00:57:14.340 --> 00:57:16.210
And what these APIs are,
you can think of them

00:57:16.210 --> 00:57:17.260
as font abstractions.

00:57:17.480 --> 00:57:20.390
In the past,
what you would have had to do was

00:57:20.590 --> 00:57:24.980
go to the low-level access APIs,
query the font tables, or even worse,

00:57:24.980 --> 00:57:26.930
if you know how to deal
with PostScript fonts,

00:57:27.030 --> 00:57:30.020
you would go dig through the
PostScript font to find the

00:57:30.020 --> 00:57:31.370
information that you had.

00:57:31.480 --> 00:57:36.630
So now we have a nice set of APIs that
give you all this functionality.

00:57:37.480 --> 00:57:42.980
Now, another nice feature of CT font
is its font cascading mechanism.

00:57:42.980 --> 00:57:45.640
For those of you that know Atsui,
think of font cascading

00:57:45.770 --> 00:57:47.030
as font substitution.

00:57:47.190 --> 00:57:50.790
It is basically a better
font substitution mechanism.

00:57:50.840 --> 00:57:52.380
It is more trade-aware.

00:57:52.660 --> 00:57:53.550
What do we mean by that?

00:57:53.650 --> 00:57:57.830
It pays a lot more attention
to font characteristics.

00:57:57.840 --> 00:58:01.970
At the bottom, we have a sample here of
what Atsui and CoreText do.

00:58:02.150 --> 00:58:05.160
You see the first line,
both Atsui and CoreText do

00:58:05.160 --> 00:58:06.840
the same font substitution.

00:58:06.840 --> 00:58:08.840
For the Japanese text.

00:58:08.930 --> 00:58:12.050
Whereas in the second one,
I don't know if you

00:58:12.050 --> 00:58:17.230
can see the difference,
but CoreText picks a Japanese font that

00:58:17.290 --> 00:58:20.840
matches the Serfs in the base Roman font.

00:58:21.020 --> 00:58:22.830
And Atsui doesn't do that.

00:58:22.880 --> 00:58:26.200
In the last line,
we have a sample where Atsui does

00:58:26.200 --> 00:58:30.770
not know that the base Roman font
is not bold and CoreText does.

00:58:30.870 --> 00:58:36.280
So it tries a bit harder than
Atsui to figure out what the

00:58:36.280 --> 00:58:39.280
right font to substitute is.

00:58:39.420 --> 00:58:42.080
The nice thing about this is
that you get this for free.

00:58:42.080 --> 00:58:45.460
As long as you use one of the
APIs that Ned talked about,

00:58:45.460 --> 00:58:50.280
the CT line draw or the CT frame draw,
you'll get this functionality for free.

00:58:50.280 --> 00:58:53.590
You have an attributed string that is
just basically a bunch of Unicodes,

00:58:53.590 --> 00:58:55.280
it'll do the right thing for you.

00:58:55.280 --> 00:58:57.280
It'll do the substitution.

00:58:57.280 --> 00:59:00.450
Now, for those of you that
need to go deeper down,

00:59:00.510 --> 00:59:03.750
as Ned said,
there's the glyph run functionality

00:59:03.750 --> 00:59:05.720
in CoreText font layout.

00:59:05.720 --> 00:59:09.710
If you need to go at that level,
you probably will need to get the same

00:59:09.710 --> 00:59:14.580
algorithm for font substitution that we
use for CT line draw and CT frame draw.

00:59:14.720 --> 00:59:19.180
So for those,
you can use CT font create for string

00:59:19.190 --> 00:59:23.120
and you will get the same functionality.

00:59:24.180 --> 00:59:25.660
Next, the font descriptors.

00:59:25.770 --> 00:59:32.660
So now you can start to see the parallels
that we have with the Cocoa APIs.

00:59:32.820 --> 00:59:33.850
Font descriptors are great.

00:59:33.870 --> 00:59:38.220
This is something that Carbon developers
did not have in their arsenal at all.

00:59:38.400 --> 00:59:42.610
You can think of them as a
query into the font system.

00:59:42.680 --> 00:59:45.760
And this query, you can have,
it's basically a

00:59:45.800 --> 00:59:47.190
dictionary of attributes.

00:59:47.340 --> 00:59:49.680
And here's a sample of some
of the attributes you can pass

00:59:49.680 --> 00:59:52.370
to create a font descriptor.

00:59:52.540 --> 00:59:56.060
So it can be very specific or very loose.

00:59:56.200 --> 01:00:00.060
So some of the samples of the attributes
that you can pass are postscript name,

01:00:00.260 --> 01:00:03.740
family name, style name, such as bold,
or traits.

01:00:03.900 --> 01:00:06.070
So you can say,
give me a font descriptor of all

01:00:06.070 --> 01:00:07.650
the monospace fonts in the system.

01:00:07.960 --> 01:00:09.980
It will do that for you.

01:00:10.200 --> 01:00:13.520
Now, one thing I want to point out,
if you notice when we were

01:00:13.520 --> 01:00:18.600
talking about the font references,
in the modern references,

01:00:18.600 --> 01:00:20.840
we don't have a family reference.

01:00:20.900 --> 01:00:25.440
Well, there is no need for a
family reference in Mac OS X,

01:00:25.490 --> 01:00:26.740
in the CT font world.

01:00:26.800 --> 01:00:28.300
You have a font descriptor.

01:00:28.380 --> 01:00:30.860
You can basically create a
font descriptor that says,

01:00:31.060 --> 01:00:36.060
"Give me a font descriptor that matches
a family name with this name." And boom,

01:00:36.060 --> 01:00:39.920
you have your family built for you.

01:00:40.460 --> 01:00:44.060
Lastly, there is persistent storage
with font descriptors,

01:00:44.060 --> 01:00:49.700
and I will talk to you
about some sample code.

01:00:49.840 --> 01:00:54.890
Here is some sample code on how to
go about creating a font descriptor.

01:00:56.150 --> 01:01:00.100
First,
you assume that we have a font name,

01:01:00.100 --> 01:01:05.220
a CFString with a font name,
but likely a PostScript name, and a size.

01:01:05.220 --> 01:01:09.380
You call ctfontDescriptor,
create with name and size,

01:01:09.400 --> 01:01:12.480
and you're given a font descriptor.

01:01:12.480 --> 01:01:16.140
In order to obtain a font reference,
the next thing you do is you just call

01:01:16.140 --> 01:01:20.560
ctfontCreate with font descriptor,
and there's two optional

01:01:20.560 --> 01:01:22.660
parameters that you can pass here.

01:01:22.660 --> 01:01:26.200
I decided to pass this
point size and a matrix.

01:01:26.200 --> 01:01:28.790
The point size,
I passed zero because when

01:01:28.860 --> 01:01:32.540
I created the font descriptor,
I already specified a size,

01:01:32.640 --> 01:01:34.040
so I choose to ignore it.

01:01:34.040 --> 01:01:35.840
And then I also choose
to ignore the matrix.

01:01:35.920 --> 01:01:38.240
I'm not going to touch that.

01:01:38.240 --> 01:01:41.620
And I did include a CF release,
which Ned didn't include in his slides.

01:01:41.620 --> 01:01:45.020
I did have some more space.

01:01:45.020 --> 01:01:48.980
And here's where we go about
creating or storing font references.

01:01:49.600 --> 01:01:51.560
Remember,
I told you that the preferred way to

01:01:51.640 --> 01:01:57.820
create a... font descriptors or font
references was using font descriptors.

01:01:57.820 --> 01:02:01.510
And the reason for that is because
we also recommend that you use font

01:02:01.510 --> 01:02:04.480
descriptors as persistent storage.

01:02:04.480 --> 01:02:07.290
So let's assume that you're working
with a document and you were

01:02:07.290 --> 01:02:10.760
using a particular font reference,
one of your fonts.

01:02:10.760 --> 01:02:15.000
So you want to now save out
your document out to disk.

01:02:15.000 --> 01:02:17.020
How do you go about storing
that font reference?

01:02:17.020 --> 01:02:19.490
Well,
the first thing you do is you obtain

01:02:19.550 --> 01:02:21.820
a descriptor for that reference.

01:02:21.820 --> 01:02:22.500
So you call ctfontDescriptor.

01:02:22.710 --> 01:02:25.430
You get the descriptor.

01:02:25.880 --> 01:02:29.960
The next, you call ctfontdescriptor
copy attributes.

01:02:29.960 --> 01:02:34.880
What this does for you,
it gives you a dictionary of attributes,

01:02:34.880 --> 01:02:38.820
and it's the minimal set of attributes
in this dictionary that it takes

01:02:38.930 --> 01:02:40.980
to create this font descriptor.

01:02:40.980 --> 01:02:44.140
So that's what you go ahead...
You can then go ahead,

01:02:44.140 --> 01:02:47.010
serialize, and put in your document.

01:02:48.880 --> 01:02:52.340
Finally, in the CT font API,
we have font collections,

01:02:52.340 --> 01:02:56.300
much like in the Cocoa APIs.

01:02:56.300 --> 01:02:59.600
You can think of font collections
as just unions or font descriptors.

01:02:59.620 --> 01:03:03.640
So you can create a font
collection for all your bold fonts,

01:03:03.870 --> 01:03:06.260
all your italic fonts, whatever.

01:03:06.260 --> 01:03:11.960
Font collections fit into the
realm more of font management.

01:03:11.960 --> 01:03:14.760
So it's not a lot of use
to most of you folks here,

01:03:14.760 --> 01:03:19.440
but font collections do offer something
that you all need in your applications,

01:03:19.440 --> 01:03:20.960
and that is enumeration.

01:03:20.960 --> 01:03:25.500
There is an API in font collections
to obtain all the fonts that

01:03:25.500 --> 01:03:27.600
are available in the system.

01:03:27.600 --> 01:03:29.700
And as part of that,
you can specify that you don't want

01:03:29.700 --> 01:03:33.400
to have any duplicates returned
to you in this font collection.

01:03:33.650 --> 01:03:38.410
Also, a neat feature of this is that when
you extract the font descriptor

01:03:38.410 --> 01:03:41.970
from the font collection,
you can get a callback or pass a

01:03:41.970 --> 01:03:46.750
callback that lets you sort the way
the descriptors are returned to you.

01:03:46.940 --> 01:03:49.100
So, it gives you a lot of flexibility.

01:03:49.100 --> 01:03:50.570
You can get it whatever way you want.

01:03:50.900 --> 01:03:54.120
If you want to have a
list of font families,

01:03:54.190 --> 01:03:58.540
you can have your sorting algorithm
that lists them by font family.

01:03:58.540 --> 01:04:02.420
So, as you can see,
the new CT font API parallels

01:04:02.420 --> 01:04:07.160
a lot what is in Cocoa,
and that is very intentional.

01:04:07.450 --> 01:04:11.920
We wanted to give Carbon developers
the same access that the

01:04:11.920 --> 01:04:14.940
Cocoa developers had in their APIs.

01:04:14.940 --> 01:04:18.400
We did take a look at
what was in the old APIs,

01:04:18.510 --> 01:04:21.820
what was in new APIs,
took a look at what was

01:04:22.040 --> 01:04:25.140
best from those APIs,
and gave you a little extra in those

01:04:25.360 --> 01:04:28.540
private APIs that we had been using
in the past that were not available.

01:04:28.540 --> 01:04:31.800
available to you.

01:04:32.230 --> 01:04:34.940
Before I go, I want to,
just like Ned did,

01:04:34.940 --> 01:04:38.590
I want to give you some
pointers about CT fonts.

01:04:39.670 --> 01:04:42.240
Like I said,
create fonts from font descriptors.

01:04:42.300 --> 01:04:44.960
The reason is once you
create a font descriptor,

01:04:44.960 --> 01:04:48.970
think of the font descriptor
as the result of a query.

01:04:49.130 --> 01:04:52.330
So you've done some work already
and it is quite fast to go from

01:04:52.330 --> 01:04:53.900
a font descriptor to a font.

01:04:54.000 --> 01:04:59.050
And then the other thing is, like I said,
the preferred way to store your font

01:04:59.050 --> 01:05:01.810
reference is using font descriptors.

01:05:01.970 --> 01:05:06.310
So go ahead, extract the attributes out
of the font descriptor and

01:05:06.400 --> 01:05:08.020
serialize those out to this.

01:05:09.060 --> 01:05:13.560
Finally, like Ned mentioned with the
framesetters and the typesetter objects,

01:05:13.560 --> 01:05:16.740
with the CT font reference,
it's something that

01:05:16.810 --> 01:05:18.340
you want to hang on to.

01:05:18.400 --> 01:05:22.810
Like I said, these references encapsulate
a lot of information.

01:05:24.350 --> 01:05:26.600
For sure you can imagine
there is a CG font ref.

01:05:26.600 --> 01:05:29.340
There is a lot of information that
it carries around so you never

01:05:29.460 --> 01:05:34.160
have to go to another API set or
API type to get what you need done.

01:05:34.300 --> 01:05:35.420
So hold on to it.

01:05:35.420 --> 01:05:37.300
It's good for performance.

01:05:37.300 --> 01:05:41.250
And once you're done, yeah,
go ahead and release it.

01:05:42.170 --> 01:05:44.860
Finally,
use our font cascading mechanism.

01:05:44.860 --> 01:05:46.200
I say this for two reasons.

01:05:46.200 --> 01:05:50.340
One, font substitution is
really expensive to do,

01:05:50.510 --> 01:05:54.220
and we've taken great -- gone through
great lengths to optimize it so

01:05:54.380 --> 01:05:57.550
that it performs well with a small
number of fonts that we have and

01:05:57.550 --> 01:05:59.860
with large amount of fonts installed.

01:05:59.860 --> 01:06:03.420
But more importantly,
we want to provide a consistent

01:06:03.430 --> 01:06:05.400
experience for our users.

01:06:05.400 --> 01:06:08.300
Now, you can tell me at this point,
"Well, you didn't do that when you showed

01:06:08.420 --> 01:06:11.250
me the Atsui example." Well,
that's going to change.

01:06:11.420 --> 01:06:16.410
It is certainly our goal for Leopard that
every layer in the system will have or

01:06:16.410 --> 01:06:19.300
experience the same font substitution.

01:06:19.330 --> 01:06:23.840
And finally, something that we've
said in previous WWDCs,

01:06:23.930 --> 01:06:26.060
and that is rely on our font APIs.

01:06:26.210 --> 01:06:29.640
This goes for both the CT font
or any other APIs that we have.

01:06:29.660 --> 01:06:32.960
And I say this again because
it is expensive to go

01:06:32.960 --> 01:06:37.360
looking through font data,
and it might seem fine to you when

01:06:37.360 --> 01:06:41.080
you try to do something on your own,
and you're working with the standard set

01:06:41.080 --> 01:06:43.100
of fonts that would ship with the system.

01:06:43.130 --> 01:06:47.260
But the moment somebody drops two, three,
four, 8,000 fonts into the system,

01:06:47.310 --> 01:06:49.550
it's going to look very ugly.

01:06:50.700 --> 01:06:52.890
So, just want to point out
some more information here.

01:06:53.110 --> 01:06:55.320
Two things from this slide
that I want to point out.

01:06:55.410 --> 01:07:00.590
We've created a new mailing list,
CoreText Dev.

01:07:00.660 --> 01:07:03.480
I checked two hours ago and
it's still not up and running,

01:07:03.480 --> 01:07:05.800
but it should be up and
running fairly soon.

01:07:06.000 --> 01:07:09.590
And it's a great place for you to
give us feedback regarding CoreText.

01:07:09.600 --> 01:07:11.450
Next is documentation.

01:07:11.450 --> 01:07:14.620
We have no online
documentation of CoreText yet.

01:07:14.620 --> 01:07:16.600
It's been written as we speak.

01:07:17.230 --> 01:07:20.540
However,
the headers are very well documented.

01:07:20.620 --> 01:07:25.250
All the APIs, all the parameters,
all the attributes that you need

01:07:25.330 --> 01:07:27.600
to use are very well documented.

01:07:27.760 --> 01:07:29.600
And also, they're very well organized.

01:07:29.600 --> 01:07:33.430
All the classes, if you will,
that we had, the typesetter,

01:07:33.570 --> 01:07:36.600
the framesetter, CT font,
the font reference,

01:07:36.600 --> 01:07:37.600
it's all in its own header.

01:07:37.600 --> 01:07:42.370
So, it should be fairly easy for you to
go dig through information there.

01:07:43.070 --> 01:07:46.970
Labs, following this session at noon,
we will have a Cortex lab.

01:07:46.980 --> 01:07:49.950
So if you want to get your hands dirty,
you want to talk more about it,

01:07:50.050 --> 01:07:51.140
we'll be there to assist you.

01:07:51.140 --> 01:07:54.480
Following the Cortex lab,
there will be the AppKit lab.

01:07:54.520 --> 01:07:57.940
And if you have questions
regarding Tex and Cocoa,

01:07:57.940 --> 01:07:59.530
please attend that.

01:07:59.630 --> 01:08:01.750
There will be somebody there to help you.

01:08:02.250 --> 01:08:04.640
Tomorrow,
we have the Tex Internationalization Lab.

01:08:04.640 --> 01:08:07.470
So if you have questions
regarding Unicode,

01:08:07.470 --> 01:08:11.610
input methods, localization of some sort,
If you have further

01:08:11.610 --> 01:08:13.660
questions about Cortex,
some of us will be there

01:08:13.660 --> 01:08:15.760
to assist you as well.

01:08:17.820 --> 01:08:24.800
Finally, I want to drive some
points before you leave.

01:08:26.730 --> 01:08:31.590
was developed with a lot of
Carbon developers in mind.

01:08:32.450 --> 01:08:36.590
We really wanted to get
you out of using Quickdraw,

01:08:36.730 --> 01:08:39.730
but we knew that you didn't have
a really good avenue to do so.

01:08:39.740 --> 01:08:42.610
We feel that with Cortex we have done so.

01:08:42.620 --> 01:08:45.740
So it's really, really time.

01:08:45.740 --> 01:08:47.150
You know,
we've been telling you for the past

01:08:47.150 --> 01:08:48.560
few years to get rid of Quickdraw.

01:08:48.560 --> 01:08:50.460
I mean, now you've seen the
right end of the wall.

01:08:50.460 --> 01:08:52.130
It's not even in 64-bit.

01:08:52.130 --> 01:08:57.170
There'll be less and less support
for Quickdraw as time goes along.

01:08:57.380 --> 01:09:02.300
So go take a serious look at Cortex
if you're a Carbon developer.

01:09:02.300 --> 01:09:04.780
Next.

01:09:06.090 --> 01:09:08.060
CoreText is the low-level framework.

01:09:08.130 --> 01:09:11.240
And if you remember the first slides
that I had on text architecture,

01:09:11.240 --> 01:09:13.980
we had the base frameworks,
ATS and Quartz.

01:09:14.030 --> 01:09:17.850
And on top, we had Cocoa and Carbon.

01:09:18.020 --> 01:09:20.970
CoreText is sitting right
there in the middle.

01:09:21.710 --> 01:09:23.300
All our text system depends on it.

01:09:23.640 --> 01:09:25.770
Performance for our text
system depends on it.

01:09:26.020 --> 01:09:31.210
We've done a great job creating
a framework that is really,

01:09:31.210 --> 01:09:35.840
really good, works well,
and performs really well.

01:09:36.010 --> 01:09:41.190
So if you are thinking about
moving your code to CoreText,

01:09:41.300 --> 01:09:43.960
we're pretty confident that
we can accomplish the same

01:09:43.960 --> 01:09:45.540
things for your code as well.

01:09:45.720 --> 01:09:48.410
Finally, CoreText is brand new.

01:09:48.740 --> 01:09:50.770
It's not set in stone.

01:09:50.880 --> 01:09:52.550
Go ahead and take a look at the APIs.

01:09:52.690 --> 01:09:53.960
Give us some feedback.

01:09:54.160 --> 01:09:57.600
When we designed CoreText, yes,
we had performance in mind.

01:09:57.750 --> 01:10:00.380
We had Carbon developers in mind.

01:10:00.720 --> 01:10:05.600
And internally, we had internal needs
that we needed to fulfill.

01:10:05.600 --> 01:10:08.210
So we built the API based
on all that information,

01:10:08.210 --> 01:10:10.600
but we know that we're
going to miss stuff.

01:10:10.600 --> 01:10:11.510
We need to hear from you.

01:10:11.510 --> 01:10:12.870
There's stuff missing?

01:10:12.870 --> 01:10:13.600
Let us know.

01:10:13.600 --> 01:10:15.880
There's stuff that quite
doesn't work for you?

01:10:15.880 --> 01:10:16.590
Let us know.

01:10:16.600 --> 01:10:18.600
Make use of that list as soon as it's up.

01:10:18.600 --> 01:10:23.600
Or talk to your developer relations
person and get that information for us.

01:10:23.600 --> 01:10:24.490
We're all ears.
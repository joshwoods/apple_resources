WEBVTT

00:00:12.020 --> 00:00:16.900
Hi, I'm Simon Douglas here to talk
about 64-bit I/O Kit Drivers

00:00:17.040 --> 00:00:19.190
for Large-Memory Systems.

00:00:20.180 --> 00:00:25.060
There's actually two very independent
parts to 64-bit support in I/O Kit.

00:00:25.060 --> 00:00:29.340
The first part is 64-bit
physical address support for I/O,

00:00:29.500 --> 00:00:33.940
and that's being added with the
Mac Pro hardware and 10.4.7 software,

00:00:33.940 --> 00:00:34.930
which just got announced.

00:00:34.940 --> 00:00:37.820
The second part is 64-bit
virtual address support,

00:00:37.860 --> 00:00:40.140
and that's for
I/O Kit client applications,

00:00:40.140 --> 00:00:42.130
and that's shipping with Leopard.

00:00:46.170 --> 00:00:49.980
So on to part one,
which is 64-bit physical addressing.

00:00:49.980 --> 00:00:55.050
As I said, that's shipping with the
Mac Pro just announced and in 10.4.7,

00:00:55.230 --> 00:00:58.510
but it's not supported
by any earlier release.

00:01:01.500 --> 00:01:04.970
So up until this point,
we have supported machines that

00:01:04.970 --> 00:01:06.900
have greater than 4GB of memory.

00:01:07.020 --> 00:01:10.260
And the G5 desktop machines
were the first Apple machines

00:01:10.260 --> 00:01:11.900
that we shipped that way.

00:01:12.050 --> 00:01:16.110
However, the situation on the G5 hardware
was that all I/O went through some

00:01:16.110 --> 00:01:21.400
onboard hardware that remapped
it into the target address space.

00:01:21.520 --> 00:01:25.560
And so that meant that a driver could
address all of memory in the machine with

00:01:25.560 --> 00:01:28.200
only 32 bits of addressing capability.

00:01:28.330 --> 00:01:30.180
And because of that,
there are very few software

00:01:30.230 --> 00:01:33.200
changes needed in the drivers
to support the G5 desktops.

00:01:33.200 --> 00:01:39.190
It was pretty invisible to them since
they could continue to use 32-bit

00:01:39.200 --> 00:01:41.700
addresses to get to all of memory.

00:01:43.890 --> 00:01:47.700
With the new Mac Pro hardware, though,
we don't have this remapping

00:01:47.700 --> 00:01:50.440
capability on the onboard hardware.

00:01:50.560 --> 00:01:57.090
So that means that any I/O devices that
do DMA and the drivers that drive those

00:01:57.090 --> 00:02:02.800
devices need to be able to address memory
that's above the 4-gig 32-bit limit.

00:02:04.080 --> 00:02:06.300
And if you have a driver
that uses physical addresses,

00:02:06.300 --> 00:02:11.690
which usually means that you're a
device that does DMAs to system memory,

00:02:11.790 --> 00:02:15.460
you must make changes to be
compatible with the large

00:02:15.900 --> 00:02:18.520
memory Mac Pro configurations.

00:02:19.820 --> 00:02:23.480
And to make sure that any
device that does do 32-bit

00:02:23.480 --> 00:02:29.530
I/O doesn't corrupt physical
memory due to address truncation,

00:02:29.530 --> 00:02:34.920
we've made the 32-bit physical
address APIs panic the system on

00:02:34.920 --> 00:02:37.710
a large-memory Mac Pro system.

00:02:39.450 --> 00:02:42.880
There is one caveat here and that's
that all the network mBufs are

00:02:42.880 --> 00:02:48.990
allocated in the low memory which
is accessible to 32-bit hardware.

00:02:51.980 --> 00:02:55.830
To support the Mac Pro,
we've added a new API,

00:02:55.920 --> 00:02:59.120
a new class called IODMA Command.

00:02:59.120 --> 00:03:03.350
And this is a new interface for
obtaining physical addresses.

00:03:04.210 --> 00:03:06.900
It's designed to work transparently
on all the architectures,

00:03:06.900 --> 00:03:12.320
so it works the same on G5,
desktop machines, portables,

00:03:12.320 --> 00:03:15.760
PowerPC and Intel machines.

00:03:15.760 --> 00:03:18.340
And that's important because the
hardware that's coming in the

00:03:18.420 --> 00:03:21.790
future may operate differently
from how the Mac Pro works today,

00:03:21.980 --> 00:03:26.680
and we may have the capability
to remap I/O addresses again.

00:03:26.680 --> 00:03:29.640
So it's very important that
you use IODMA command to obtain

00:03:29.640 --> 00:03:34.080
your physical addresses to be
compatible with future hardware.

00:03:36.810 --> 00:03:38.140
So what is an I/O DMA command?

00:03:38.140 --> 00:03:42.420
It's an object that represents an
instance of an I/O DMA request.

00:03:42.420 --> 00:03:45.980
And that means that the instance
has to exist for the entire

00:03:45.980 --> 00:03:48.530
duration that the I/O is in flight.

00:03:49.090 --> 00:03:53.400
As far as the software goes,
the API replaces I/O Memory Cursor

00:03:53.400 --> 00:03:56.940
and the API I/O Memory Descriptor
Get Physical Segment,

00:03:56.940 --> 00:04:02.690
which were the old 32-bit APIs for
obtaining physical addresses.

00:04:03.560 --> 00:04:07.820
And what I/O DMA command adds
to those older interfaces is a

00:04:07.820 --> 00:04:12.380
specification of what your capabilities
are as far as addressing memory.

00:04:12.500 --> 00:04:17.700
So that's basically a specification
of the limitations of your hardware.

00:04:18.550 --> 00:04:21.770
And if your hardware does
have some limited addressing,

00:04:21.770 --> 00:04:26.940
IODMA command adds support for doing
the necessary buffering and copying.

00:04:27.220 --> 00:04:30.530
That allows your hardware
to access memory that's out

00:04:30.590 --> 00:04:32.600
of its addressing limits.

00:04:33.380 --> 00:04:36.700
The advantage to doing it in the
system is that we can do it only for

00:04:36.790 --> 00:04:40.700
the pages that need to be copied,
and we can also share any buffers that

00:04:40.700 --> 00:04:43.150
are needed across the entire system.

00:04:46.890 --> 00:04:48.630
So as I said,
when you create an I/O DMA client,

00:04:48.630 --> 00:04:53.370
you have to give it a specification of
exactly the kind of memory that your

00:04:53.460 --> 00:04:56.160
particular hardware can get access to.

00:04:56.200 --> 00:04:59.680
And usually the most important
number is the number of address

00:04:59.680 --> 00:05:01.840
bits your hardware can support.

00:05:01.880 --> 00:05:03.820
32 and 64 are common.

00:05:03.850 --> 00:05:08.570
There's also some graphics devices,
for example, that have settled on 39

00:05:08.570 --> 00:05:12.590
and 40 bits of addressing,
and that's all fine.

00:05:13.590 --> 00:05:17.140
Obviously the optimal situation is
that your device can get access to

00:05:17.160 --> 00:05:19.130
all of the memory in the system.

00:05:19.130 --> 00:05:22.900
And usually that means you
have 64 bits of addressing.

00:05:23.920 --> 00:05:26.900
That's obviously going to be the best
performing solution because we'll

00:05:26.900 --> 00:05:31.800
never have to copy or double buff the
memory and it's highly encouraged.

00:05:35.050 --> 00:05:37.510
There are some other parameters that
you pass to the IID make-and-find

00:05:37.510 --> 00:05:42.630
when you create it that also
specify the limits of your hardware.

00:05:42.750 --> 00:05:45.690
The first one is the max segment size.

00:05:45.790 --> 00:05:49.210
That sets a limit on the
physically contiguous chunk that

00:05:49.210 --> 00:05:51.790
your hardware can do I/O in.

00:05:52.990 --> 00:05:56.500
Another one is that you can now
pass an alignment restriction.

00:05:56.500 --> 00:05:58.500
For example,
it's quite common for hardware

00:05:58.500 --> 00:06:02.700
to only be able to DMA directly
to a 4-byte aligned buffer.

00:06:02.900 --> 00:06:06.100
If you're in that situation,
then you can use the alignment

00:06:06.100 --> 00:06:09.560
restriction to let I/O DMA command
take care of doing any

00:06:09.580 --> 00:06:11.650
double buffering necessary.

00:06:12.930 --> 00:06:16.340
Another one is the Max Transfer Size and
that just simply sets the

00:06:16.420 --> 00:06:21.820
largest size of any I/O that
will be allowed to your driver.

00:06:22.580 --> 00:06:26.230
And then the final one is you can set
the format of the physical addresses that

00:06:26.230 --> 00:06:28.470
I/O DMA client will be returning to you.

00:06:28.500 --> 00:06:34.260
And most importantly you can decide
whether or not to use 32 or 64-bit

00:06:34.260 --> 00:06:38.370
addresses and they can be in big,
little or high standardness.

00:06:42.430 --> 00:06:44.900
So how do you go about
using an IIDMA command?

00:06:44.900 --> 00:06:46.900
As I said,
you have to have an IIDMA command

00:06:46.900 --> 00:06:49.860
object instance per I/O.

00:06:49.860 --> 00:06:53.650
So you may create one per I/O,
or you could have a command pool that's

00:06:53.650 --> 00:06:55.990
created when the driver starts up.

00:06:56.800 --> 00:07:00.300
And then when an I/O request comes in,
you need to point the IODMA command

00:07:00.300 --> 00:07:03.730
at the memory descriptor of the I/O.

00:07:03.730 --> 00:07:07.700
And there's an API called
setMemoryDescriptor to do that.

00:07:07.700 --> 00:07:13.330
You also have to call an
API called IODMA command prepare.

00:07:13.990 --> 00:07:18.620
The IODMA Command Prepare and
Complete APIs are low-level

00:07:18.620 --> 00:07:21.700
DMA start and end bracketing APIs.

00:07:21.700 --> 00:07:24.910
They're actually completely
distinct from the old

00:07:25.000 --> 00:07:29.720
IMMJscriptor Prepare and Complete,
and they do very different things.

00:07:29.720 --> 00:07:36.420
That means that IMMJscriptor
Prepare and Complete should still

00:07:36.420 --> 00:07:36.420
be called in exactly the same
places that it was called before.

00:07:39.580 --> 00:07:42.500
Once you've got your DMA command
pointed at the memory descriptor,

00:07:42.500 --> 00:07:48.680
you can use the APIs to generate either
64-bit physical addresses and lengths or

00:07:48.790 --> 00:07:51.540
32-bit physical addresses and lengths.

00:07:51.760 --> 00:07:55.420
You use those addresses to
build your DMA command list

00:07:55.570 --> 00:07:57.990
and kick off the hardware I/O.

00:07:58.350 --> 00:08:02.880
And then when the I/O completes,
you need to call those bracketing

00:08:03.320 --> 00:08:08.460
methods in IDMA commands complete
and clear memory descriptor to mark

00:08:08.720 --> 00:08:13.430
that the I/O has been completed.

00:08:17.180 --> 00:08:19.790
So as I said,
the best situation to be in is

00:08:19.840 --> 00:08:23.680
obviously if your hardware can address
all of the memory in the system,

00:08:23.680 --> 00:08:26.830
in which case IDMA kind will
usually never have to copy

00:08:26.830 --> 00:08:28.550
or double-buffer memory.

00:08:29.670 --> 00:08:31.830
So for example,
the Mac Pro hardware supports

00:08:31.830 --> 00:08:34.490
up to 64 gigabytes of RAM,
so that means if your hardware has

00:08:34.490 --> 00:08:38.460
at least 36 bits of addressing,
I/O DMA command will

00:08:38.490 --> 00:08:40.410
never have to copy memory.

00:08:41.500 --> 00:08:44.700
If your driver wants to make sure
that I/O DMA command is never used

00:08:44.700 --> 00:08:48.680
and it's buffering in copy mode,
there's an option you

00:08:48.690 --> 00:08:52.720
can pass to enforce this,
and this is called Kiterate only.

00:08:52.920 --> 00:08:57.160
When you use IODMA command in this mode,
you're basically just using it

00:08:57.160 --> 00:09:01.430
as an iterator over the memory
descriptor's physical addresses.

00:09:02.140 --> 00:09:06.930
If IEDMA command is being used in this
mode and it ever does hit a physical

00:09:07.000 --> 00:09:12.290
address that would be outside of your
hardware's addressing restrictions,

00:09:12.450 --> 00:09:16.520
it will just fail to return any such
physical address and give you an error.

00:09:16.690 --> 00:09:19.460
The advantage to using it,
if you're in the situation

00:09:19.930 --> 00:09:23.240
where you expect to have
direct access to all of memory,

00:09:23.330 --> 00:09:29.210
you can use a single IADMA command
instance in this mode simply as an

00:09:29.210 --> 00:09:33.250
iterator over the memory descriptor,
in which case you're basically

00:09:33.260 --> 00:09:37.930
just using it to generate 64-bit
physical addresses and it's a direct

00:09:38.250 --> 00:09:43.280
replacement for IAMemoryCursor and the
IAMemoryDescriptorGetPhysicalSegment

00:09:43.280 --> 00:09:45.140
APIs,
which were the older 32-bit APIs.

00:09:48.010 --> 00:09:51.110
However, if you're using I/O DMA command
in the general case where it could

00:09:51.180 --> 00:09:56.340
have some extra buffers that have
been associated with the DMA,

00:09:56.480 --> 00:09:59.740
these buffers have to be
synchronized with the original data.

00:09:59.740 --> 00:10:04.530
This buffering scheme is often
called "bounce buffering".

00:10:05.250 --> 00:10:09.800
The synchronization happens when
I/O DMA Command Prepare is called.

00:10:09.800 --> 00:10:14.290
And when Prepare is called,
the bounce buffers are brought

00:10:14.290 --> 00:10:16.050
in sync with the original data.

00:10:16.200 --> 00:10:19.840
And when Complete is
called on I/O DMA Command,

00:10:19.860 --> 00:10:23.000
the DMA data in the bounce
buffer is copied back to

00:10:23.000 --> 00:10:25.100
the original client buffer.

00:10:25.720 --> 00:10:30.200
And both of those copies will depend on
how the memory descriptor was prepared,

00:10:30.200 --> 00:10:34.300
in particular the direction of
the prepared memory descriptor.

00:10:38.190 --> 00:10:43.840
If your driver knows that the data in
the original buffer has been changed

00:10:44.370 --> 00:10:49.060
since the DMA command was created for it,
there's an explicit

00:10:49.060 --> 00:10:51.740
API called Synchronize,
and you can use that to copy data

00:10:51.740 --> 00:10:55.810
backwards and forwards between the
bounce buffers and the original data.

00:10:55.920 --> 00:11:00.130
Obviously,
if there is no bounce buffer or

00:11:00.140 --> 00:11:01.970
there's no synchronization needed,
then Synchronize will just be a no-op.

00:11:03.690 --> 00:11:06.200
So often you'll use this if you
know that the memory descriptor has

00:11:06.200 --> 00:11:09.570
changed out from underneath the DMA.

00:11:09.610 --> 00:11:13.390
An example might be if memory descriptor
read or write bytes was called,

00:11:13.390 --> 00:11:17.420
or the CPU itself actually
changed the data in the buffer.

00:11:21.070 --> 00:11:23.160
That covers I/O DMA command.

00:11:23.160 --> 00:11:27.670
There's another class of problem
where your hardware may need to have a

00:11:27.670 --> 00:11:36.150
buffer that's been allocated once and
shared with the hardware and software.

00:11:36.150 --> 00:11:39.650
And this is often used
for a DMA program list,

00:11:39.650 --> 00:11:40.000
for example.

00:11:40.600 --> 00:11:43.370
When you're in this case,
you know that you need to allocate

00:11:43.380 --> 00:11:46.980
the buffer in a certain address
range in memory so that the

00:11:46.980 --> 00:11:49.390
hardware always has access to it.

00:11:49.930 --> 00:11:52.360
And as I said earlier,
network MBUS are actually

00:11:52.360 --> 00:11:56.840
always allocated by default
in 32-bit addressable memory.

00:11:56.880 --> 00:11:59.490
So you don't have to
worry about that case.

00:12:00.920 --> 00:12:03.700
So to cover this,
we've got a new API and I/O buffer memory

00:12:03.700 --> 00:12:07.210
descriptor called InTaskWithPhysicalMask.

00:12:07.610 --> 00:12:11.610
And the main addition is
a 64-bit address mask,

00:12:11.610 --> 00:12:16.440
and that basically sets the allowable
physical address bits that your

00:12:16.440 --> 00:12:18.760
hardware is prepared to support.

00:12:19.020 --> 00:12:23.340
So most commonly,
you would pass a number like, you know,

00:12:23.340 --> 00:12:27.800
Fox, Fox, Fox, Fox,
0000 for 32-bit addressable

00:12:27.800 --> 00:12:29.470
page-aligned memory.

00:12:30.650 --> 00:12:34.100
and you'll quite often want that
memory to be physically contiguous,

00:12:34.120 --> 00:12:35.780
which is an option.

00:12:39.390 --> 00:12:44.030
So quite often today when you've been
allocating your DMA program lists,

00:12:44.030 --> 00:12:48.220
you've been using an
API called IML at Contiguous.

00:12:48.250 --> 00:12:49.950
And for compatibility
with the current software,

00:12:49.960 --> 00:12:54.850
that will always return a
32-bit accessible memory.

00:12:56.440 --> 00:13:01.320
There's another case where
buffers need to be allocated

00:13:01.390 --> 00:13:06.340
with certain restrictions,
and that's for USB and FireWire clients,

00:13:06.340 --> 00:13:10.470
where they're allocating buffers
to be used for Isochronous I/O.

00:13:11.260 --> 00:13:15.810
And because of the performance
restrictions on that kind of I/O,

00:13:15.810 --> 00:13:19.360
USB and FireWire will require
their clients to allocate buffers

00:13:19.360 --> 00:13:21.200
with a certain restriction.

00:13:21.390 --> 00:13:24.200
And that's covered in
their session tomorrow,

00:13:24.200 --> 00:13:30.710
which is tomorrow morning at 10:30,
the I/O Technologies Overview session.

00:13:35.730 --> 00:13:40.520
So that covers the
Mac Pro 10.4.7 changes.

00:13:40.630 --> 00:13:45.490
The second part to 64-bit address
support in I/O Kit is support for

00:13:45.490 --> 00:13:52.690
virtual addresses greater than 32-bit,
which is being added in Leopard.

00:13:52.700 --> 00:13:55.920
And as you know,
Leopard is adding broader support for

00:13:55.920 --> 00:14:00.080
tasks running with 64-bit address spaces.

00:14:01.520 --> 00:14:05.280
But even in Leopard and
even on 64-bit hardware,

00:14:05.280 --> 00:14:08.620
the kernel is going to
remain a 32-bit task.

00:14:08.740 --> 00:14:13.300
And that means that KEXs continue
to be compiled as 32-bit code.

00:14:14.060 --> 00:14:16.230
So you don't have to go out
and recompile all of your kegs

00:14:16.250 --> 00:14:20.010
to run on a 64-bit system.

00:14:22.510 --> 00:14:25.930
So very often there'll be absolutely
no driver changes needed for

00:14:25.930 --> 00:14:31.260
64-bit for virtual address support
because most often the family will

00:14:31.260 --> 00:14:34.780
take care of creating the memory
descriptor that represents the client

00:14:35.100 --> 00:14:37.430
buffer before your driver sees it.

00:14:38.660 --> 00:14:40.640
So for example,
if you're writing a storage driver and

00:14:40.640 --> 00:14:44.280
you're just generating a DMA list for
a buffer that's being passed to you,

00:14:44.280 --> 00:14:47.290
you never see the virtual
address in the client,

00:14:47.320 --> 00:14:51.650
so you don't really care if
they're a 64-bit or 32-bit task.

00:14:53.270 --> 00:14:55.680
However,
there is one class of driver that will

00:14:55.780 --> 00:15:01.190
have to change to support 64-bit clients,
and that's if you've implemented

00:15:01.190 --> 00:15:03.880
an I/O User-Client subclass.

00:15:04.290 --> 00:15:08.680
Because most often they will deal
directly with client virtual addresses.

00:15:11.150 --> 00:15:16.240
So if you do want your driver
to support 64-bit tasks,

00:15:16.260 --> 00:15:19.280
in other words 64-bit applications,
and you implement an

00:15:19.280 --> 00:15:22.370
I/O User-Client subclass,
then it's very likely you'll

00:15:22.440 --> 00:15:24.370
have to make changes for Leopard.

00:15:27.380 --> 00:15:30.980
To support this, we've added some APIs in
I/O Memory Descriptor.

00:15:30.980 --> 00:15:34.970
Basically, everywhere a virtual address

00:15:35.460 --> 00:15:39.290
"The first version of the I/O Kit was
passed into I/O Memory Descriptor.

00:15:39.290 --> 00:15:41.850
There is now a 64-bit
version of that API.

00:15:41.850 --> 00:15:44.730
So, for example,
we have an API I/O Memory Descriptor

00:15:44.740 --> 00:15:47.920
with address and that takes a
vm_address_t address and that's

00:15:47.920 --> 00:15:51.580
got a new version now called
I/O Memory Descriptor with address range

00:15:51.590 --> 00:15:54.210
and that takes a mach_vm_address_t type.

00:15:56.450 --> 00:16:00.280
The types are mach_vm_address_t
and mach_vm_size_t,

00:16:00.280 --> 00:16:04.440
and the kernel defines these
to be always 64-bit quantities,

00:16:04.440 --> 00:16:09.100
regardless of whether or not
the task is 32- or 64-bit.

00:16:09.130 --> 00:16:14.140
Whereas the older types,
vm_address_t and vm_size_t,

00:16:14.390 --> 00:16:21.450
the kernel defines those types to be the
size of the compiled code that's running.

00:16:21.520 --> 00:16:24.800
So since the kernel
is only a 32-bit task,

00:16:24.800 --> 00:16:27.630
that means that
vm_address_t and vm_size_t

00:16:27.990 --> 00:16:32.070
We're running 32-bit quantities,
so obviously they can't be used to

00:16:32.580 --> 00:16:36.790
represent an address in a client
application because he could be 64-bit.

00:16:38.480 --> 00:16:43.340
And very much the same way
I/O Memory Map has any API that

00:16:43.380 --> 00:16:47.230
returns a virtual address,
now has a 64-bit version.

00:16:51.680 --> 00:16:54.500
So the behavior of the
current 32-bit APIs,

00:16:54.500 --> 00:17:00.360
number one is obviously if you're using
the current 32-bit APIs on a 32-bit task,

00:17:00.360 --> 00:17:04.000
there is no change at all.

00:17:04.000 --> 00:17:11.560
There are changes when you attempt to use
the 32-bit APIs on a 64-bit client task.

00:17:12.580 --> 00:17:16.540
The first one is that an API such as
I/O Memory Descriptor with Address,

00:17:16.540 --> 00:17:19.230
which is attempting to create
an I/O Memory Descriptor for

00:17:19.230 --> 00:17:23.640
a range of memory in a task,
if that task is 64-bit will

00:17:23.770 --> 00:17:27.350
actually fail outright and not
create an I/O Memory Descriptor

00:17:27.350 --> 00:17:29.200
for you in that situation.

00:17:31.440 --> 00:17:36.490
If you do manage to get by that
call and manage to get an I/O memory

00:17:36.510 --> 00:17:40.400
mapping created and then call the
old 32-bit version of the API,

00:17:40.400 --> 00:17:43.840
which is get virtual address,
we can't actually fail that call,

00:17:43.840 --> 00:17:48.290
but we will warn you that there's
an address truncation taking place.

00:17:48.970 --> 00:17:52.460
Net Warning is logged to the system
log and there's some text information

00:17:52.560 --> 00:17:57.280
logged there as well so you get a
backtrace to try and track down the call.

00:17:57.900 --> 00:18:00.930
But generally the first failure
will mean that you can't

00:18:00.960 --> 00:18:04.320
create a memory descriptor,
so therefore you can't create a mapping.

00:18:09.280 --> 00:18:16.620
When you're going through your
I/O User Client subclass for

00:18:16.620 --> 00:18:16.620
Leopard to support 64-bit,

00:18:16.730 --> 00:18:19.240
What we recommend doing is just
replacing all of the parameter

00:18:19.240 --> 00:18:23.950
in-calls with a simple structure-in,
structure-out style of call.

00:18:24.400 --> 00:18:28.600
We still have the scalar-based
calls and we do have 64

00:18:28.600 --> 00:18:32.330
versions of those scalar calls,
but they're generally being quite

00:18:32.330 --> 00:18:37.960
confusing for developers and most
people are used to an ICTL kind

00:18:37.960 --> 00:18:42.800
of interface and so the simple
structure-in and structure-out

00:18:43.080 --> 00:18:47.720
calls seem to be the most popular.

00:18:48.680 --> 00:18:52.300
What you have to do is basically go
through any of your parameters and make

00:18:52.300 --> 00:18:56.840
sure that any of the parameters that
refer to client virtual addresses need

00:18:57.040 --> 00:19:00.500
to be converted to the 64-bit types.

00:19:01.660 --> 00:19:05.200
And generally what you want to
do is for both 32 and 64-bit

00:19:05.200 --> 00:19:09.890
clients is just settle on a 64-bit
type for all of your parameters.

00:19:10.050 --> 00:19:12.490
And when you do that the kernel
can then treat all of the clients

00:19:12.520 --> 00:19:16.150
the same because all of the
addresses coming in are 64-bit.

00:19:17.290 --> 00:19:20.750
And then you take those parameters and
pass them to the new 64-bit versions of

00:19:20.760 --> 00:19:26.170
the I/O Memory Descriptor APIs whenever
you're dealing with the client virtual

00:19:26.170 --> 00:19:28.270
addresses and mapping client memory.

00:19:31.840 --> 00:19:35.700
Another thing to watch out for when
implementing an I/O user client,

00:19:35.700 --> 00:19:40.660
because the kernel has been compiled for
32-bit and the client could potentially

00:19:40.660 --> 00:19:44.850
have been compiled for 64-bit,
that means that C-compile code has very

00:19:45.080 --> 00:19:47.700
different structure alignment by default.

00:19:47.700 --> 00:19:51.190
So you have to make sure that
when you define your structures,

00:19:51.190 --> 00:19:54.900
they're defined in such a way that
they will be aligned identically

00:19:54.940 --> 00:19:57.290
between 32-bit and 64-bit.

00:19:58.530 --> 00:20:02.140
This is actually documented
quite well in this tech note

00:20:02.140 --> 00:20:05.190
that I'm pointing out here,
and that's been around

00:20:05.190 --> 00:20:11.000
since Tiger supported
64-bit for Darwin clients.

00:20:15.700 --> 00:20:19.050
And we have some sample
code on the seed CD,

00:20:19.050 --> 00:20:21.600
and that's in developer examples I/O Kit.

00:20:21.670 --> 00:20:27.180
And that is a sample of a
KEXT that uses IODMA command.

00:20:27.960 --> 00:20:31.310
to iterate over an I/O memory
descriptor and get the physical

00:20:31.390 --> 00:20:36.680
addresses in a 64-bit and 32-bit form.

00:20:36.680 --> 00:20:38.650
And it also has an I/O user
client implementation

00:20:38.710 --> 00:20:43.780
That works the same on both
32 and 64-bit Intel and PPC.

00:20:44.950 --> 00:20:50.040
So it's quite a small sample
and pretty easy to understand.

00:20:54.500 --> 00:20:56.900
I'm going to pass over now to
Curtis Gallowaay who's going

00:20:56.900 --> 00:20:59.680
to give us an update on EFI.

00:21:06.600 --> 00:21:12.000
[Transcript missing]

00:21:14.020 --> 00:21:20.790
I'll give you an overview of what EFI is,
why you should care about EFI,

00:21:20.790 --> 00:21:25.900
if you should care about EFI,
how EFI is different from open firmware,

00:21:26.130 --> 00:21:29.320
how EFI works on a Mac,

00:21:29.570 --> 00:21:33.890
and writing EFI device
drivers and applications.

00:21:34.050 --> 00:21:39.250
So first of all, EFI,
maybe you've heard of it.

00:21:39.260 --> 00:21:39.870
I don't know.

00:21:39.950 --> 00:21:44.070
How many of you out here have
written I/O Kit drivers before?

00:21:44.130 --> 00:21:44.660
Yeah.

00:21:44.720 --> 00:21:48.940
How many of you are actually
writing drivers during the session?

00:21:49.110 --> 00:21:52.780
So maybe you're familiar with EFI then.

00:21:53.210 --> 00:21:57.960
EFI is the Extensible Firmware Interface,
which is the firmware that's

00:21:57.960 --> 00:22:00.060
used on Intel-based Macs.

00:22:00.110 --> 00:22:04.920
It's extensible because it's easy for
Apple to extend it in the firmware and

00:22:04.920 --> 00:22:10.080
for developers to write drivers that
actually extend EFI's functionality.

00:22:10.120 --> 00:22:13.190
It's firmware,
so it actually lives in the machine.

00:22:13.240 --> 00:22:15.780
It's built into the hardware.

00:22:15.880 --> 00:22:19.310
And it's a well-defined interface
that has published specification

00:22:19.340 --> 00:22:23.770
that you can download and
read and hopefully understand.

00:22:24.820 --> 00:22:26.750
Should you care about EFI?

00:22:27.080 --> 00:22:28.650
Well, it depends.

00:22:28.730 --> 00:22:30.100
Maybe you shouldn't care about EFI.

00:22:30.540 --> 00:22:33.900
If you don't write any device drivers
and you don't make any hardware,

00:22:33.900 --> 00:22:36.700
then you probably shouldn't
care about it all that much.

00:22:36.700 --> 00:22:40.670
If you do make a boot device,
like for example a RAID device or some

00:22:40.670 --> 00:22:45.290
other piece of hardware that's required
during the boot process that doesn't

00:22:45.450 --> 00:22:49.700
follow a standard interface like ATA or
something that's already built in,

00:22:50.090 --> 00:22:52.700
then maybe you do care.

00:22:52.700 --> 00:22:57.270
If you want to run a pre-boot
application such as a hardware test

00:22:57.270 --> 00:23:01.700
or some kind of repair utility,
then maybe you do care.

00:23:01.700 --> 00:23:04.700
You want to write something that
doesn't actually use the OS.

00:23:05.490 --> 00:23:08.140
But in general,
if you can do something in the OS,

00:23:08.320 --> 00:23:12.110
then you should not do it in EFI.

00:23:13.910 --> 00:23:17.430
Let me just give you a brief history
of personal computer firmware.

00:23:17.610 --> 00:23:20.620
Apple, up until recently,
has used Open Firmware,

00:23:20.620 --> 00:23:25.400
which was invented by Sun as
Open Boot way back in 1988.

00:23:25.400 --> 00:23:30.110
It was adopted by Apple for our first
generation of PCI machines and was

00:23:30.170 --> 00:23:33.480
actually standardized by the IEEE.

00:23:33.620 --> 00:23:35.750
The PC industry has
traditionally used BIOS,

00:23:35.820 --> 00:23:39.870
which is the basic input/output
system which goes all the way back

00:23:39.870 --> 00:23:41.920
to 1980 and the original IBM PC.

00:23:42.010 --> 00:23:44.530
It was sort of a hack they came up with.

00:23:44.590 --> 00:23:48.810
They decided they needed something, "Oh,
let's do this," and it's kind of

00:23:48.930 --> 00:23:51.920
persisted for all these years.

00:23:51.920 --> 00:23:54.450
The history of BIOS is kind of checkered.

00:23:54.450 --> 00:23:57.910
It's industry standard,
but that doesn't mean that

00:23:57.990 --> 00:24:02.500
there's really a standard in
the industry for how it works.

00:24:02.500 --> 00:24:04.990
It's generally written
entirely in assembly code.

00:24:04.990 --> 00:24:08.300
It runs in 16-bit mode,
which is really old.

00:24:08.300 --> 00:24:14.940
It's not standardized at all,
and generally it's kind of a mess.

00:24:14.940 --> 00:24:21.710
On the other hand,
EFI was conceived by some really smart

00:24:21.710 --> 00:24:28.100
people at Intel to replace BIOS and was
intended to be kind of a well-thought-out

00:24:28.100 --> 00:24:32.850
alternative to the agglomeration of
random things that BIOS had turned into.

00:24:32.850 --> 00:24:38.660
It has more modern features like Unicode,
strings, 64-bit physical addressing,

00:24:38.660 --> 00:24:41.830
and it's now turned over
to the unified EFI forum,

00:24:41.830 --> 00:24:46.310
which is a group of companies that
are interested in promoting EFI,

00:24:46.310 --> 00:24:48.670
which Apple is a member of.

00:24:49.140 --> 00:24:52.560
EFI has many benefits both
for Apple and for developers.

00:24:52.580 --> 00:24:55.020
Unlike BIOS,
there's very little assembly code in it,

00:24:55.230 --> 00:25:01.840
so it's possible for normal people to
understand it and write code for it.

00:25:01.850 --> 00:25:05.060
It has good debugging tools,
so you can actually run a debugger

00:25:05.060 --> 00:25:07.260
and find out what's going on.

00:25:07.260 --> 00:25:13.420
It's easy to extend both inside
EFI and with drivers and applications.

00:25:13.420 --> 00:25:16.730
It allows us to leverage our
existing device driver writing

00:25:16.740 --> 00:25:19.500
expertise so that someone,
for example,

00:25:19.500 --> 00:25:23.460
who's written an I/O Kit driver
for the Bluetooth family could

00:25:23.690 --> 00:25:28.710
easily go and write EFI driver for
Bluetooth without having to learn some

00:25:28.710 --> 00:25:30.940
strange backwards language like fourth.

00:25:30.950 --> 00:25:34.730
Not that I'm down on fourth,
but people seem to be

00:25:34.730 --> 00:25:37.800
kind of allergic to it,
so that's sort of a problem.

00:25:37.830 --> 00:25:40.180
It has very good performance
compared to OpenFirmware,

00:25:40.180 --> 00:25:43.260
which is not so much a knock on
OpenFirmware's implementation

00:25:43.260 --> 00:25:45.700
as the design of it,
as I'll explain a little

00:25:45.700 --> 00:25:46.360
bit more in a moment.

00:25:46.930 --> 00:25:48.820
And there's third party support.

00:25:48.900 --> 00:25:52.400
You can go buy an implementation
of EFI for your machine

00:25:52.810 --> 00:25:54.080
from multiple vendors.

00:25:54.210 --> 00:25:59.240
You can buy tools from multiple
vendors for developing and debugging

00:25:59.240 --> 00:26:01.630
EFI drivers and applications.

00:26:01.700 --> 00:26:04.680
So that's already a plus.

00:26:05.200 --> 00:27:21.900
[Transcript missing]

00:27:23.140 --> 00:27:23.990
I just explained that.

00:27:24.000 --> 00:27:27.950
OpenFirmware does have
human-readable device paths,

00:27:28.000 --> 00:27:30.700
which are real Unix-y
looking things like,

00:27:30.830 --> 00:27:33.240
you know, slash PCI, blah, blah, blah.

00:27:33.240 --> 00:27:39.840
EFI does not have the idea of
human-readable device paths by default.

00:27:39.890 --> 00:27:45.810
An EFI device path is a binary structure,
which is flexible so that you

00:27:45.810 --> 00:27:50.000
can have it describe any kind
of device by just extending it

00:27:50.000 --> 00:27:51.570
with a new kind of structure,
but it makes it a little bit

00:27:51.590 --> 00:27:54.550
more difficult to look at
a path and see what it is.

00:27:54.590 --> 00:27:57.960
There is a standard in the new
EFI spec for how to translate that

00:27:58.050 --> 00:28:01.350
into something that you can see,
but it's a little bit

00:28:01.350 --> 00:28:03.460
less straightforward.

00:28:03.460 --> 00:28:07.330
OpenFirmware device drivers
are written in fourth,

00:28:07.410 --> 00:28:11.300
and even though there's an F in EFI,
they're written in C, so maybe,

00:28:11.300 --> 00:28:13.670
I don't know,
they should change the acronym.

00:28:13.680 --> 00:28:21.280
OpenFirmware does not use a runtime
component in Apple computers.

00:28:22.100 --> 00:28:25.460
There is a definition in the
standard for a runtime component

00:28:25.460 --> 00:28:28.690
that can live on into the OS,
but we don't actually use that.

00:28:28.810 --> 00:28:31.660
But in EFI,
there is a runtime service that the

00:28:31.690 --> 00:28:36.080
operating system can take advantage
of for things like getting the time,

00:28:36.080 --> 00:28:39.710
resetting the system,
using NVRAM variables,

00:28:39.750 --> 00:28:42.580
and we do take advantage of
that in our operating system.

00:28:44.310 --> 00:28:47.840
So starting up your Mac with EFI,
how is that different?

00:28:47.880 --> 00:28:50.250
Well,
it's pretty much exactly like starting

00:28:50.250 --> 00:28:53.000
up your Mac with Open Firmware,
which is kind of what

00:28:53.000 --> 00:28:54.920
our customers expect.

00:28:55.150 --> 00:28:56.460
Not too many changes.

00:28:56.490 --> 00:29:01.220
Under the covers, really,
it's doing a similar set of things,

00:29:01.220 --> 00:29:03.790
initializing the hardware.

00:29:04.010 --> 00:29:09.050
But there are a few UI differences
that I can show you.

00:29:09.490 --> 00:29:11.910
If you want to get into--

00:29:12.500 --> 00:29:17.140
The EFI Boot Picker on
your Intel based Mac,

00:29:17.290 --> 00:29:19.630
just hold down the Option key
when you're starting up.

00:29:19.680 --> 00:29:23.490
So in that sense, it's just like an
Open Firmware based machine.

00:29:23.500 --> 00:29:28.180
I've got a little Mac Mini here,
which has one volume on it,

00:29:28.290 --> 00:29:28.810
which shows up.

00:29:28.970 --> 00:29:32.280
So if I had multiple partitions,
those would show up in the Boot Picker.

00:29:32.320 --> 00:29:38.420
But I can also take a USB device
like my iPod here and plug it in.

00:29:38.420 --> 00:29:43.300
And the Boot Picker will notice
that I plugged in a new device.

00:29:43.300 --> 00:29:45.300
And in fact,
it even knows what kind it is,

00:29:45.390 --> 00:29:48.500
because it stored the
volume icon on the device.

00:29:48.820 --> 00:29:56.580
Or I can take a shuffle or some other
USB thumb drive and plug that in,

00:29:56.580 --> 00:30:00.270
or just a random SanDisk cruiser.

00:30:00.660 --> 00:30:05.400
And EFI will notice all of those
devices and let me pick from them.

00:30:05.450 --> 00:30:08.660
And in fact,
I can even use the remote control

00:30:08.660 --> 00:30:10.960
to navigate back and forth.

00:30:11.720 --> 00:30:14.800
Because, you know,
we're Apple and we're cool.

00:30:14.960 --> 00:30:20.900
So if you want to boot the EFI shell,
you just put that on your thumb drive.

00:30:20.900 --> 00:30:24.110
You can download the
shell from tianocore.org,

00:30:24.260 --> 00:30:27.200
which I'll talk about later,
and just run the EFI shell,

00:30:27.200 --> 00:30:31.600
which should make you feel a lot like
it's 1980 and you're running DOS.

00:30:31.600 --> 00:30:33.130
It's kind of exciting.

00:30:33.260 --> 00:30:40.150
Or if you are creative and
do a little bit more work,

00:30:40.280 --> 00:30:44.440
you can actually write
your own EFI application,

00:30:44.490 --> 00:30:46.600
which I'll show you here.

00:30:49.740 --> 00:30:51.600
Which it is possible to do.

00:30:51.630 --> 00:30:56.440
We wrote a little demo application
here in EFI just to prove that it is

00:30:56.440 --> 00:31:00.100
in fact possible to draw some graphics.

00:31:00.100 --> 00:31:07.400
You have support for timers,
dual animation, get the system time.

00:31:07.640 --> 00:31:13.820
So it is possible to do reasonably
complicated things in EFI.

00:31:14.200 --> 00:31:17.680
Hopefully your application will
be a little bit more technically

00:31:17.680 --> 00:31:19.100
functional than this one.

00:31:19.100 --> 00:31:24.090
But thanks to Ronnie and
Josh for helping out with that.

00:31:24.180 --> 00:31:26.080
That's our big demo.

00:31:26.160 --> 00:31:31.100
And just one last thing
to show on the UI front.

00:31:31.100 --> 00:31:36.100
It's really hard to demo
things with something like EFI.

00:31:36.100 --> 00:31:39.620
You do all this work and all
you have to show for it is,

00:31:39.620 --> 00:31:44.100
"Look, the machine turned on." So,
you know, the machine turned on.

00:31:44.120 --> 00:31:49.100
So the real eye candy
is stuff like the poof.

00:31:50.800 --> 00:31:54.280
When you show it to the executives,
that's the kind of stuff that

00:31:54.340 --> 00:31:55.700
they get all excited about.

00:31:55.700 --> 00:31:58.770
So for all you hardware
developers out there,

00:31:59.070 --> 00:32:03.180
make sure you put some kind of slick
UI that you can show off because

00:32:03.570 --> 00:32:05.700
that'll get you promoted faster.

00:32:08.670 --> 00:32:13.710
So, back to the world of slides.

00:32:14.670 --> 00:32:18.350
As you can see, starting up,
it's a little fancier, but in general,

00:32:18.350 --> 00:32:22.360
most people will probably never see that,
which is kind of too bad.

00:32:22.360 --> 00:32:27.920
So you can show that to your grandma or
whoever when you're installing her Mac.

00:32:27.920 --> 00:32:32.480
So what EFI does under the covers
is when you turn on the machine,

00:32:32.480 --> 00:32:35.480
there's a little bit of assembly
that runs to set up kind of

00:32:35.480 --> 00:32:39.490
the pre-execution environment,
and then you get into basically looks

00:32:39.950 --> 00:32:45.740
like device drivers that initialize a
minimal set of hardware in the machine.

00:32:45.740 --> 00:32:52.060
It sets up the memory and the
PCI bus and a few other things.

00:32:52.060 --> 00:32:56.880
And then its real job is to load and
execute the bootloader for the system.

00:32:56.880 --> 00:32:59.690
So if you've told it through
an NVRAM where that is,

00:32:59.690 --> 00:33:02.110
it will find it directly
and load it and run it.

00:33:02.110 --> 00:33:04.980
Otherwise, it will go search for it.

00:33:04.980 --> 00:33:09.950
And the bootloader then uses the
EFI services just like it would the

00:33:10.110 --> 00:33:14.540
operating system if it were a regular
operating system program to find

00:33:14.540 --> 00:33:17.000
and load the kernel device drivers.

00:33:17.000 --> 00:33:19.820
And then the kernel takes
over and terminates.

00:33:19.900 --> 00:33:22.580
EFI is terminated,
and the operating system

00:33:22.600 --> 00:33:25.000
owns the whole system,
except for a little bit of EFI that

00:33:25.000 --> 00:33:27.870
lingers around as a runtime service.

00:33:29.110 --> 00:33:32.620
So again,
the boot program draws the Apple logo.

00:33:32.760 --> 00:33:35.280
So if you're debugging a system,
you see the Apple logo,

00:33:35.280 --> 00:33:37.530
you know the boot loader loaded.

00:33:37.700 --> 00:33:41.200
It loads the OS and drivers,
either the caches or

00:33:41.200 --> 00:33:44.800
the individual drivers,
into memory.

00:33:44.840 --> 00:33:48.630
It leaves behind some information
that it got from EFI that it

00:33:48.680 --> 00:33:52.570
constructs in a device tree format
that it can pass off to I/O Kit.

00:33:52.610 --> 00:33:56.540
So in that sense, it's similar to how
Open Firmware does it.

00:33:56.550 --> 00:34:01.130
It basically simulates an Open Firmware
device tree just for convenience.

00:34:01.210 --> 00:34:05.580
And then it terminates EFI except for the
runtime services and starts the kernel.

00:34:05.680 --> 00:34:08.920
So again, when you're debugging,
if you see the little spinning gear,

00:34:08.920 --> 00:34:11.320
that means the kernel has started.

00:34:11.320 --> 00:34:16.930
And you know that the booter is done,
and you've gone into kernel space.

00:34:17.390 --> 00:34:22.840
So for configuring EFI's behavior,
NVRAM variables are used to control

00:34:22.960 --> 00:34:26.300
some aspects of how EFI works.

00:34:26.300 --> 00:34:28.750
In EFI terminology,
they're just called EFI variables.

00:34:28.830 --> 00:34:30.060
They don't have to be in NVRAM.

00:34:30.060 --> 00:34:32.680
They can be stored somewhere else,
but our implementation

00:34:32.680 --> 00:34:33.870
uses NVRAM for that.

00:34:33.990 --> 00:34:36.350
In Apple terminology,
it's NVRAM variables.

00:34:36.370 --> 00:34:38.300
That's what you use for writing
from the operating system.

00:34:38.300 --> 00:34:42.200
Non-volatile RAM, it's actually stored
in Flash in hardware.

00:34:42.300 --> 00:34:52.370
EFI variables are named by a 128-bit
GUID for the vendor and a Unicode

00:34:52.370 --> 00:34:57.300
16-bit wide string as the name of it.

00:34:57.320 --> 00:35:01.400
So in theory,
an Apple variable won't conflict

00:35:01.400 --> 00:35:05.960
if you install Linux or some
other operating system on there

00:35:05.970 --> 00:35:07.300
and they use EFI variables.

00:35:07.300 --> 00:35:12.300
The GUIDs will make sure that your
variable names don't ever conflict.

00:35:12.330 --> 00:35:15.300
And if you are a developer who's
writing an EFI device driver,

00:35:15.300 --> 00:35:18.300
you can set your own variables with
your own GUID that you make up.

00:35:18.300 --> 00:35:21.280
And you don't have to worry about
prefixing them with anything.

00:35:21.310 --> 00:35:23.300
Just name them whatever you like.

00:35:24.310 --> 00:35:29.890
The NVRAM variables used by the operating
system are implemented as EFI variables.

00:35:29.890 --> 00:35:33.290
So if you get into the EFI shell
and you know the GUID that we use,

00:35:33.350 --> 00:35:35.710
you can look at all of those,
set them in the shell,

00:35:35.710 --> 00:35:37.400
and examine them that way.

00:35:37.540 --> 00:35:44.000
They are set using different vendor
GUIDs for different purposes of things.

00:35:44.180 --> 00:35:47.130
For example,
internally within our firmware,

00:35:47.130 --> 00:35:49.700
there are some settings that
are stored in NVRAM that use a

00:35:49.700 --> 00:35:53.700
different GUID than the ones that the
OS variables use so they don't conflict.

00:35:53.790 --> 00:35:59.180
Any variables that are set by third-party
drivers could again use their own GUID.

00:35:59.200 --> 00:36:03.540
The NVRAM command in the OS can
be used to set NVRAM variables

00:36:03.930 --> 00:36:06.700
that persist across an OS boot.

00:36:06.700 --> 00:36:09.330
So that's your standard interface
that you would use from the

00:36:09.340 --> 00:36:11.700
operating system for NVRAM variables.

00:36:11.860 --> 00:36:14.110
Just like in the old days,
it works exactly the same way.

00:36:14.240 --> 00:36:17.900
There's an extension to that that
lets you prefix a GUID to the name of

00:36:17.900 --> 00:36:23.200
the variable so that you can actually
read and write other variables

00:36:23.200 --> 00:36:29.610
that are set either in the firmware
or by drivers or anyone else.

00:36:29.700 --> 00:36:33.700
So that's one difference from open
firmware that you might notice.

00:36:33.700 --> 00:36:35.700
It's documented in the man page.

00:36:35.700 --> 00:36:39.260
Behavior that's controlled
by NVRAM variables

00:36:39.850 --> 00:36:41.700
includes target disk mode.

00:36:41.700 --> 00:36:44.350
So when you start up the machine,
hold down the T key and it turns

00:36:44.350 --> 00:36:45.700
into a big FireWire disk drive.

00:36:45.940 --> 00:36:49.670
That's actually initiated by a
variable that the firmware looks at.

00:36:49.700 --> 00:36:56.250
The firmware updater, if you run that,
basically just the application

00:36:56.250 --> 00:37:00.700
sets a path to launch the
firmware updater once only,

00:37:00.820 --> 00:37:02.700
which is a real nice convenience.

00:37:02.700 --> 00:37:07.000
If you set a firmware password,
that's stored in NVRAM as well.

00:37:07.510 --> 00:37:12.200
And BootCamp uses NVRAM to configure
some of its behavior for booting

00:37:12.200 --> 00:37:13.700
into a legacy operating system.

00:37:15.870 --> 00:37:18.790
The booter actually
interprets one NVRAM variable,

00:37:18.880 --> 00:37:22.600
boot args, to look at some of its
aspects of how it works.

00:37:22.600 --> 00:37:25.240
For instance,
if you want to get a text console to see

00:37:25.240 --> 00:37:28.960
what the booter is doing for debugging,
you can set -v in the boot args

00:37:28.960 --> 00:37:30.760
and the booter will look at that.

00:37:30.880 --> 00:37:35.080
Also, you can set the root partition
or where it looks for

00:37:35.080 --> 00:37:36.670
various things that it loads.

00:37:36.800 --> 00:37:42.100
You can also set boot variables in a
plist file that's read by the booter,

00:37:42.350 --> 00:37:45.800
which is stored on disk,
or if you're netbooting,

00:37:45.800 --> 00:37:48.800
it's actually read from the
same location as the booter.

00:37:48.800 --> 00:37:52.800
And this is a big convenience
for debugging and for netbooting.

00:37:52.800 --> 00:37:55.730
And it might be mysterious if you set
something in there and forget about it

00:37:55.730 --> 00:37:59.250
and clear out your NVRAM and wonder,
"Why is it still verbose booting?" Well,

00:37:59.250 --> 00:38:04.300
you might have set something in your
plist file that the booter is looking at.

00:38:05.790 --> 00:38:07.960
So, EFI device drivers.

00:38:07.980 --> 00:38:13.520
Let's say you are a hardware vendor
and you think that you might want

00:38:13.680 --> 00:38:15.170
to write an EFI device driver.

00:38:15.230 --> 00:38:18.680
Well,
are you really sure you want to do that?

00:38:18.780 --> 00:38:24.300
If you have a device that is a
boot device that is not standard,

00:38:24.300 --> 00:38:27.700
as I said before,
then maybe you do need to do that.

00:38:27.700 --> 00:38:30.850
So,
the best practice is to actually build

00:38:30.850 --> 00:38:32.700
that into the ROM on your system.

00:38:32.700 --> 00:38:36.890
And we provide standard EFI interfaces
according to the EFI spec,

00:38:36.890 --> 00:38:41.480
which you can download from Intel's
website for the 1.1 or from the

00:38:41.480 --> 00:38:43.520
UEFI website for the latest one.

00:38:43.700 --> 00:38:48.180
And we have a few extensions that we use
to do our whizzy stuff like the icons

00:38:48.280 --> 00:38:53.180
and making the screen look beautiful,
but those are not required for a device

00:38:53.180 --> 00:38:58.530
driver that just controls a device that
the operating system wants to boot from.

00:38:58.760 --> 00:39:00.810
EFI applications.

00:39:00.810 --> 00:39:01.650
You can do that, as we saw.

00:39:01.750 --> 00:39:02.590
It's possible to do that with a computer.

00:39:02.730 --> 00:39:07.590
It's also possible to write, you know,
whizzy little EFI applications.

00:39:07.710 --> 00:39:09.700
It's not easy.

00:39:09.700 --> 00:39:13.330
You don't get a whole lot of
help from EFI for doing stuff

00:39:13.330 --> 00:39:15.580
like drawing lines or anything.

00:39:15.700 --> 00:39:18.700
You get blit pixels to the screen.

00:39:18.700 --> 00:39:20.700
And the rest is up to you.

00:39:20.700 --> 00:39:23.700
So, you know, it's not easy.

00:39:23.700 --> 00:39:26.680
You can get basic console support
if you just want to do a textual

00:39:26.740 --> 00:39:30.390
application for doing something like,
you know, printing out some stuff

00:39:30.390 --> 00:39:31.700
about your device.

00:39:31.700 --> 00:39:33.050
That's pretty easy.

00:39:33.450 --> 00:39:35.930
You can do that from the EFI shell.

00:39:36.720 --> 00:39:43.110
So in the spirit of 64-bit,
all of our current Apple systems

00:39:43.110 --> 00:39:46.020
use a 32-bit EFI ROM.

00:39:46.020 --> 00:39:51.340
But our latest machines, the Mac Pro,
do have a 64-bit processor in them.

00:39:51.460 --> 00:39:58.990
And UEFI 2.0, the specification,
does have a spec for a 64-bit ABI for

00:39:59.520 --> 00:40:02.910
a version of EFI that basically has
all the same interfaces but has a

00:40:02.940 --> 00:40:05.530
different ABI for running in 64-bit mode.

00:40:05.560 --> 00:40:09.260
So what that means to you is you
should be prepared for the future and

00:40:09.260 --> 00:40:13.340
make sure that your device drivers
on any devices that you make and

00:40:13.340 --> 00:40:17.670
sell should support both 32-bit and
64-bit so they're compatible with

00:40:18.070 --> 00:40:22.420
both today's machines and any machines
in the future which either Apple or

00:40:22.420 --> 00:40:28.780
anyone might ship that work with,
that have a 64-bit EFI ROM in them.

00:40:29.450 --> 00:40:30.640
So how do you do that?

00:40:30.790 --> 00:40:36.410
Well, you can build natively,
which means you build once on a 32-bit

00:40:36.410 --> 00:40:38.260
system and once on a 64-bit system.

00:40:38.300 --> 00:40:42.780
The EFI build environment
lets you build one at a time,

00:40:42.870 --> 00:40:45.230
which then you can build
separately into your ROM.

00:40:45.290 --> 00:40:46.540
That's one way to do it.

00:40:46.540 --> 00:40:48.300
That's not a bad way to do it.

00:40:48.320 --> 00:40:51.210
You can have them live in
different areas in your ROM.

00:40:51.470 --> 00:40:53.290
That might be bigger than you want.

00:40:53.530 --> 00:41:00.010
Another solution is EBC, EFI Bytecode,
which is an interpreted

00:41:00.110 --> 00:41:03.300
bytecode kind of like Java.

00:41:03.300 --> 00:41:07.480
I don't really want to say the word Java,
but in principle it's similar to that,

00:41:07.480 --> 00:41:12.290
where your code gets compiled down into
bytecode that's interpreted by the ROM.

00:41:12.410 --> 00:41:15.770
It requires a compiler
that Intel will sell you,

00:41:15.770 --> 00:41:18.300
and it's interpreted like Java.

00:41:18.300 --> 00:41:19.570
There's that word again.

00:41:19.570 --> 00:41:22.290
It will run on both 32-
and 64-bit systems as is,

00:41:22.290 --> 00:41:25.320
so you don't need to do
anything to make your bytecode

00:41:25.320 --> 00:41:27.240
work on either kind of system.

00:41:27.340 --> 00:41:28.260
So that's the advantage.

00:41:28.320 --> 00:41:32.940
It should be a comparable speed,
unless you're doing matrix transforms

00:41:32.940 --> 00:41:36.150
or something insane like that,
which you probably shouldn't

00:41:36.150 --> 00:41:37.300
do in your device driver.

00:41:37.300 --> 00:41:44.300
And it's only about 50% larger than
just the one-way native binary,

00:41:44.300 --> 00:41:50.550
so there's some size savings there,
which might be important to you if

00:41:50.550 --> 00:41:53.300
size is a limitation in your firmware.

00:41:53.310 --> 00:41:56.140
which it probably is.

00:41:56.520 --> 00:42:00.000
The build environment,
you can build on Windows,

00:42:00.000 --> 00:42:02.010
which you may like or you may not like.

00:42:02.190 --> 00:42:05.980
A lot of device driver vendors
actually like building on Windows,

00:42:06.060 --> 00:42:08.380
so more power to you.

00:42:08.400 --> 00:42:12.040
You can use Visual Studio plus
some freely available pieces

00:42:12.050 --> 00:42:13.220
that you can download.

00:42:13.760 --> 00:42:17.760
Intel explains how to do that in
the EFI training documentation

00:42:17.760 --> 00:42:21.500
on the Tiano Core website,
which is the open source

00:42:21.500 --> 00:42:24.400
website for EFI development.

00:42:24.520 --> 00:42:29.080
The EBC compiler is available for
sale from our friends at Intel.

00:42:29.080 --> 00:42:35.400
And it is possible to build
with Xcode on Mac OS X.

00:42:35.400 --> 00:42:39.400
We hope to release that environment
as open source really soon.

00:42:39.530 --> 00:42:42.450
And you should check out the
Apple open source website

00:42:42.450 --> 00:42:44.350
for more information on that.

00:42:44.470 --> 00:42:46.400
That's how we build the OS loader.

00:42:46.400 --> 00:42:47.350
We came up with a way of doing that.

00:42:47.430 --> 00:42:50.230
And in fact,
Intel is working on a next generation

00:42:50.230 --> 00:42:52.400
of the EFI development kit that
will be available for the Mac OS X.

00:42:52.400 --> 00:42:56.360
And we have a new version of the
EFI development kit that will be

00:42:56.400 --> 00:43:00.400
much easier to use on multiple
platforms on Linux on OS X.

00:43:00.400 --> 00:43:02.400
So that will be good.

00:43:02.400 --> 00:43:04.260
Keep your eyes peeled for that.

00:43:04.400 --> 00:43:09.040
There are open source examples available
on Intel's website and we will have

00:43:09.040 --> 00:43:13.400
some as well when we release our
open source version of these tools.

00:43:13.400 --> 00:43:17.100
Just to give you an example of
what an EFI program looks like,

00:43:17.240 --> 00:43:20.260
this is Hello World using
the EFI development kit,

00:43:20.400 --> 00:43:20.400
the driver development kit.

00:43:20.400 --> 00:43:23.400
So you include some headers.

00:43:23.400 --> 00:43:27.230
You have a main, an entry point that
looks a lot like main.

00:43:27.540 --> 00:43:32.400
You get a handle to your image,
which is your program.

00:43:32.400 --> 00:43:35.610
And then the system table,
which has pointers to various

00:43:35.740 --> 00:43:37.400
services that you can use.

00:43:37.400 --> 00:43:41.860
And then there's a driver library that
includes a bunch of useful functions

00:43:41.860 --> 00:43:46.400
that will take those handles and
squirrel them away for you to use later.

00:43:46.420 --> 00:43:48.400
And then you can print.

00:43:48.400 --> 00:43:48.400
You notice the L indicating
that it's a driver.

00:43:48.400 --> 00:43:52.400
And then the C indicating that
it's a 16-bit Unicode character.

00:43:52.400 --> 00:43:56.400
So all strings that are
used are generally Unicode.

00:43:56.400 --> 00:43:58.400
So that's a good thing.

00:43:58.400 --> 00:44:01.400
But it might take some getting
used to if you're not used to that.

00:44:02.460 --> 00:44:06.700
A protocol is the basic
unit of interface in EFI.

00:44:06.700 --> 00:44:10.640
That's how you find stuff,
how you find interfaces for doing things

00:44:10.640 --> 00:44:14.400
like reading or writing or anything.

00:44:14.400 --> 00:44:17.730
A protocol is just a structure
that has pointers to functions

00:44:17.730 --> 00:44:19.360
and it's named by a GUID.

00:44:19.570 --> 00:44:23.320
So the next version of the protocol
will just have a different GUID so you

00:44:23.350 --> 00:44:25.380
can have as many protocols as you want.

00:44:25.450 --> 00:44:27.630
There's functions to look
them up and associate them

00:44:27.630 --> 00:44:29.380
with handles in the system.

00:44:29.400 --> 00:44:36.700
And this is a standard disk I/O protocol
that lets you read and write blocks.

00:44:37.280 --> 00:44:42.590
And one of those functions for
reading would look like this.

00:44:42.660 --> 00:44:48.070
You pass in a pointer to the structure
that is the protocol and some

00:44:48.070 --> 00:44:51.200
arguments and get a return value that
tells you whether it worked or not.

00:44:51.530 --> 00:44:53.580
Pretty standard.

00:44:54.640 --> 00:44:59.860
You can find a lot more information
about EFI at the TianoCore website,

00:44:59.910 --> 00:45:04.420
which is the open source effort
started by Intel that has

00:45:04.420 --> 00:45:08.660
actually source code for complete
sample implementation of EFI,

00:45:09.150 --> 00:45:12.290
as well as the libraries and headers that
you would need to get started with that.

00:45:12.500 --> 00:45:17.960
The specification is available
either on Intel's website for

00:45:17.960 --> 00:45:23.520
the 1.1 or the new UEFI 2 spec,
which is followed by our

00:45:23.520 --> 00:45:27.500
new Mac Pro hardware,
is available at UEFI.org.

00:45:27.500 --> 00:45:29.460
You do have to register to get it,
but it's free.

00:45:29.500 --> 00:45:30.500
It doesn't cost anything.

00:45:30.500 --> 00:45:32.460
You don't have to join or
sign any massive paperwork.

00:45:32.510 --> 00:45:35.850
You just have to say that
you're not going to sue them,

00:45:35.850 --> 00:45:36.610
I think.

00:45:37.070 --> 00:45:40.580
And for more information,
here are some contacts here at

00:45:40.580 --> 00:45:45.990
Apple that you can contact for
more information about UEFI,

00:45:45.990 --> 00:45:50.240
EFI development at Apple,
or I/O Kit in general.

00:45:50.280 --> 00:45:51.150
It's all available here.

00:45:51.160 --> 00:45:54.200
There's on your seed DVD,
there's a bunch of sample

00:45:54.740 --> 00:45:57.920
documentation not about EFI but
about I/O Kit in general.
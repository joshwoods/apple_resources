WEBVTT

00:00:10.320 --> 00:00:12.540
Welcome to the middle of the conference.

00:00:12.600 --> 00:00:16.990
I hope everybody's found it
instructional so far and had a good time.

00:00:17.100 --> 00:00:19.900
So we've actually got quite
a lot to cover this morning,

00:00:19.900 --> 00:00:24.400
so I hope you've had your coffee,
and let's get started.

00:00:25.970 --> 00:00:29.850
So this morning's session is sort of
an introductory session to I/O Kit or

00:00:30.000 --> 00:00:33.900
possibly a refresher for some of
you who've spent some time there.

00:00:33.900 --> 00:00:35.840
If this is not the session
you thought you were in,

00:00:35.840 --> 00:00:38.800
this is your opportunity to bail.

00:00:38.800 --> 00:00:40.680
We'll press on now.

00:00:42.620 --> 00:00:43.830
So, what is I/O Kit?

00:00:43.970 --> 00:00:46.980
Sort of in the simplest terms,
it is the device driver

00:00:47.060 --> 00:00:48.360
model for Mac OS X.

00:00:48.450 --> 00:00:53.070
And a little more specifically,
it is the driver model where

00:00:53.070 --> 00:00:56.340
you write drivers in C++,
load them inside the kernel,

00:00:56.380 --> 00:00:59.820
the Darwin kernel,
and they execute in that environment.

00:00:59.860 --> 00:01:04.230
Applications talk to those drivers
indirectly by using mechanisms

00:01:04.230 --> 00:01:08.040
across the user-kernel boundary,
a variety of plug-ins or

00:01:08.040 --> 00:01:11.550
other system abstractions,
and we'll talk about those later.

00:01:13.530 --> 00:01:15.820
So to kind of lay it
out for you graphically,

00:01:15.820 --> 00:01:19.870
this is a simplified stack of sort
of the Mac OS X operating system.

00:01:20.000 --> 00:01:22.680
Up above the dashed line there,
we have the user space where

00:01:22.760 --> 00:01:25.060
all the applications run,
and they make use of the

00:01:25.610 --> 00:01:29.400
various frameworks and libraries
to use the system services.

00:01:29.540 --> 00:01:33.320
And the purple area is the kernel,
and within that it's subdivided

00:01:33.320 --> 00:01:35.400
into a variety of technologies.

00:01:35.400 --> 00:01:37.550
And the one we're going to be
focusing on today is over here,

00:01:37.610 --> 00:01:39.840
is the I/O Kit space.

00:01:40.310 --> 00:01:44.990
And that includes what we call families,
as well as the actual device drivers.

00:01:45.120 --> 00:01:49.110
And we'll spend most of our time
this morning talking about those.

00:01:49.260 --> 00:01:53.400
We will talk a little bit about
kecks in general a little later on,

00:01:53.510 --> 00:01:56.530
which is all the gray
boxes in this diagram.

00:02:00.200 --> 00:02:03.850
So when is it appropriate to use I/O Kit?

00:02:03.900 --> 00:02:06.620
A lot of devices already are
supported with generic drivers

00:02:06.620 --> 00:02:08.300
or facilities in the system.

00:02:08.300 --> 00:02:13.780
So in those cases, you won't need to use
I/O Kit to write a driver.

00:02:13.870 --> 00:02:17.590
Also, there are a variety of
applications where you would want

00:02:17.590 --> 00:02:21.390
to have a user-land construct,
an application or utility,

00:02:21.450 --> 00:02:23.000
talking to hardware.

00:02:23.050 --> 00:02:25.480
Now, we don't consider this an
I/O Kit driver because it's

00:02:25.480 --> 00:02:27.000
not running inside the kernel.

00:02:27.000 --> 00:02:29.030
Some examples of this,
anything that uses the

00:02:29.030 --> 00:02:32.460
image capture framework,
for example, cameras, scanners, printers,

00:02:32.600 --> 00:02:35.400
these are all user-level plug-ins.

00:02:35.540 --> 00:02:40.100
Now, they do use I/O Kit in that they use
it to communicate with their hardware,

00:02:40.140 --> 00:02:42.690
but these drivers don't run
in an I/O Kit environment.

00:02:42.700 --> 00:02:44.580
They actually run out in user-space.

00:02:44.660 --> 00:02:47.500
And from I/O Kit's perspective,
they could just be any application.

00:02:47.590 --> 00:02:50.760
So when I use the term
"applications" in this presentation,

00:02:50.840 --> 00:02:52.900
I'm not referring just to
apps that the user launches.

00:02:52.900 --> 00:02:56.380
I really refer to anything running,
any task or process running out of the

00:02:56.660 --> 00:02:59.420
user-- out of the kernel address space.

00:02:59.710 --> 00:03:03.080
These uses of I/O Kit use
the I/O Kit framework.

00:03:03.110 --> 00:03:08.110
The I/O Kit framework is available for
applications and utilities outside of the

00:03:08.110 --> 00:03:10.860
kernel to gain access to I/O Kit drivers.

00:03:11.540 --> 00:03:13.900
Now, device drivers that must
run inside the kernel,

00:03:13.930 --> 00:03:16.460
which is what we'll be
focusing on this morning,

00:03:16.570 --> 00:03:20.030
there's a few criteria there that
help you kind of decide where

00:03:20.030 --> 00:03:21.670
you want to put your driver.

00:03:21.960 --> 00:03:24.730
Once you start looking at the
documentation and some other examples,

00:03:24.730 --> 00:03:26.920
you'll probably be guided by
what other people have done,

00:03:26.920 --> 00:03:30.690
but a lot of that comes down to
these three requirements here.

00:03:30.830 --> 00:03:33.390
If you need direct
access to your hardware,

00:03:33.450 --> 00:03:36.940
and I mean like register-level I/O,
you pretty much have to

00:03:36.940 --> 00:03:38.500
be in the kernel for that.

00:03:38.790 --> 00:03:42.550
If you require interrupt handling,
you pretty much have to

00:03:42.550 --> 00:03:44.580
be in the kernel for that.

00:03:44.950 --> 00:03:46.990
Also,
if your primary client is in the kernel,

00:03:47.000 --> 00:03:50.500
this is really what's driven most
I/O Kit drivers into the kernel.

00:03:50.510 --> 00:03:54.260
For example, storage drivers,
their primary client is

00:03:54.260 --> 00:03:55.890
the file system layer.

00:03:55.920 --> 00:03:57.660
So,
it only makes sense for storage drivers

00:03:57.660 --> 00:04:00.900
to be below them in the architecture,
so therefore they're in the kernel.

00:04:00.950 --> 00:04:01.860
Now, this is important.

00:04:02.020 --> 00:04:05.680
The kernel framework is where you
will find all of the APIs that

00:04:05.680 --> 00:04:07.490
you use inside the kernel.

00:04:08.000 --> 00:04:12.100
This includes all of the
I/O Kit APIs that I/O Kit drivers use.

00:04:12.190 --> 00:04:16.140
So, if you're writing an I/O Kit driver,
you do not use the I/O Kit framework.

00:04:16.230 --> 00:04:19.550
I know that's kind of counterintuitive,
but look in the kernel framework.

00:04:19.680 --> 00:04:23.320
That is the one and only framework
that you can use inside the kernel.

00:04:23.600 --> 00:04:26.240
In that being said,
you really should try to avoid writing a

00:04:26.240 --> 00:04:29.940
kernel-level driver if at all possible,
because it's harder to debug,

00:04:29.990 --> 00:04:32.510
it's a more limited environment,
you don't have all the

00:04:32.510 --> 00:04:39.370
frameworks available,
but it is necessary in a lot of cases,

00:04:39.370 --> 00:04:39.370
so we'll press on and
talk about those cases.

00:04:40.920 --> 00:04:42.880
Now,
I/O Kit has a number of design goals,

00:04:42.890 --> 00:04:45.080
and I'm going to spend a minute
on philosophy here just so you

00:04:45.080 --> 00:04:48.060
can kind of understand maybe
some of the decisions we've made.

00:04:48.260 --> 00:04:50.860
So writing a device driver
in a modern operating system

00:04:50.860 --> 00:04:52.050
is a very complicated task.

00:04:52.150 --> 00:04:54.980
You have a lot of things to juggle.

00:04:55.030 --> 00:04:57.820
From a scheduling perspective,
you have multiprocessor systems,

00:04:57.840 --> 00:04:59.460
you have preemption to worry about.

00:04:59.730 --> 00:05:03.140
You have multiple address spaces,
and now as you've seen

00:05:03.140 --> 00:05:05.850
from sessions this week,
those address spaces

00:05:05.850 --> 00:05:06.960
can be different sizes.

00:05:07.010 --> 00:05:09.890
They're not all 32-bit
address spaces anymore.

00:05:10.900 --> 00:05:15.600
Also, architecture neutrality,
also very important to Apple these days.

00:05:15.600 --> 00:05:20.700
So I/O Kit needs to be able to cope
with various ndns and other variations

00:05:20.700 --> 00:05:22.890
that can be even more subtle.

00:05:23.790 --> 00:05:27.850
We also really want drivers to focus
on mechanism and not on policy.

00:05:28.040 --> 00:05:30.280
And this actually has driven
a number of decisions that

00:05:30.480 --> 00:05:31.780
we'll kind of hit on later on.

00:05:32.020 --> 00:05:35.460
But what I mean by this is drivers
are there to service requests

00:05:35.460 --> 00:05:37.730
from the user-space applications.

00:05:37.870 --> 00:05:39.740
They're not there to generate I/O.

00:05:39.860 --> 00:05:42.950
Now, there will be a few cases where
they have to generate I/O in the

00:05:42.960 --> 00:05:45.720
course of doing their business,
and that's okay.

00:05:45.900 --> 00:05:49.380
But all the I/O that they do
really should be either a direct

00:05:49.380 --> 00:05:53.300
or indirect result of some
request that came in from above.

00:05:53.370 --> 00:05:54.760
That's what I mean by mechanism.

00:05:54.760 --> 00:05:56.080
They simply are there to serve.

00:05:59.360 --> 00:06:02.970
I/O Kit is also intended to be
sort of a long-lived technology.

00:06:02.980 --> 00:06:06.300
We really didn't want to encumber
it with any specific technology.

00:06:06.470 --> 00:06:09.530
If you think back to
the classic Mac OS days,

00:06:09.610 --> 00:06:14.300
the SCSI Manager, even though SCSI wasn't
really used very much,

00:06:14.400 --> 00:06:18.300
sort of the end of the
days for Mac OS Classic,

00:06:18.300 --> 00:06:21.300
the SCSI Manager was kind of
entrenched in the API set.

00:06:21.440 --> 00:06:23.420
And even though people didn't
really use it for SCSI,

00:06:23.420 --> 00:06:25.300
they used it for general disk management.

00:06:25.300 --> 00:06:28.560
So we didn't want to have
something like that in I/O Kit that

00:06:28.560 --> 00:06:30.300
was perpetuated forever.

00:06:30.300 --> 00:06:33.830
So what we did was we took all of
the device or protocol-specific

00:06:33.870 --> 00:06:37.300
stuff and split it out into
these things called families.

00:06:37.300 --> 00:06:39.300
Well, they extend I/O Kit.

00:06:39.300 --> 00:06:40.300
I/O Kit remains generic.

00:06:40.300 --> 00:06:43.300
The families provide the
bus-specific protocols.

00:06:43.300 --> 00:06:47.770
And of course, third parties can extend
I/O Kit either by writing families

00:06:47.770 --> 00:06:50.050
or drivers within those families.

00:06:51.570 --> 00:06:54.140
A word on the kernel environment here.

00:06:54.140 --> 00:06:58.250
As I said, it's a little different from
programming in user space.

00:06:58.410 --> 00:07:00.830
The Darwin kernel is a process,
just like any other

00:07:00.830 --> 00:07:01.760
process on the system.

00:07:01.760 --> 00:07:04.100
Well, not just like,
but it has a lot in common

00:07:04.100 --> 00:07:05.280
with other processes.

00:07:05.280 --> 00:07:06.120
It has threads.

00:07:06.290 --> 00:07:09.250
It has its own virtual
memory address space.

00:07:09.420 --> 00:07:12.720
So a lot of the general
concepts are the same.

00:07:12.860 --> 00:07:15.350
But it doesn't have any of
the sort of the BSD process

00:07:15.360 --> 00:07:19.160
attributes that you think of,
like you can't open file descriptors.

00:07:19.160 --> 00:07:22.690
There's lots of things like that you
can't do within that environment.

00:07:24.890 --> 00:07:29.340
So we inject code into the kernel task
using something called kernel extensions,

00:07:29.340 --> 00:07:30.680
or KEXTs.

00:07:30.680 --> 00:07:33.350
And we've got another speaker
coming up to talk about those

00:07:33.350 --> 00:07:38.750
at the end of the session,
and we'll defer that for now.

00:07:40.000 --> 00:07:43.800
All the code running in the
kernel address space shares

00:07:43.800 --> 00:07:45.980
the same virtual address space.

00:07:45.980 --> 00:07:47.870
We call it the kernel
virtual address space.

00:07:47.900 --> 00:07:49.300
Very creative name there.

00:07:49.430 --> 00:07:50.890
But you'll see it in documentation.

00:07:50.900 --> 00:07:53.930
That's what it refers to,
is the address space that all the

00:07:54.040 --> 00:07:55.690
code running in the kernel uses.

00:07:55.740 --> 00:07:58.090
And it is not the same as
the physical address space,

00:07:58.190 --> 00:08:02.100
and it's not the same as any
particular user virtual address space.

00:08:02.770 --> 00:08:06.340
Within the kernel,
interfaces are called KPIs,

00:08:06.470 --> 00:08:10.650
Kernel Programming Interfaces, and again,
they're present only in

00:08:10.650 --> 00:08:11.970
the kernel framework.

00:08:12.800 --> 00:08:15.920
I'll touch on this a little bit later,
but another aspect of programming in

00:08:15.920 --> 00:08:19.360
the kernel environment is once your code
is running in the kernel environment,

00:08:19.460 --> 00:08:20.240
you are trusted.

00:08:20.410 --> 00:08:24.100
You basically have no bounds placed
on you as to what you can do,

00:08:24.100 --> 00:08:27.090
so you have to program responsibly
if you're going to do that.

00:08:27.100 --> 00:08:29.700
The user has to install
your kernel extension,

00:08:29.700 --> 00:08:32.790
they have to authenticate
as an admin user to do that.

00:08:32.900 --> 00:08:35.660
There's a level of trust there,
so it's very important that you

00:08:35.660 --> 00:08:39.100
consider the security implications
of the code you're writing.

00:08:41.060 --> 00:08:43.040
A few more constraints for the kernel.

00:08:43.040 --> 00:08:45.060
When you're programming in the kernel,
you can think of it like a

00:08:45.060 --> 00:08:46.450
sort of a long-running app.

00:08:46.590 --> 00:08:49.310
When the app exits,
the machine is shut down,

00:08:49.740 --> 00:08:52.000
either happily or sadly with a panic.

00:08:52.000 --> 00:08:54.870
So, do not leak.

00:08:55.720 --> 00:08:59.760
Make sure your drivers do not leak,
because the kernel memory

00:08:59.760 --> 00:09:00.760
is wired by default.

00:09:00.850 --> 00:09:03.600
When you allocate memory or
allocate an object in I/O Kit,

00:09:03.760 --> 00:09:05.640
that is actual physical
memory you're pinning down.

00:09:05.640 --> 00:09:07.090
It can't be paged out later.

00:09:07.270 --> 00:09:10.630
So pay special attention to that.

00:09:11.050 --> 00:09:13.600
Floating Point is unavailable
in the kernel generally.

00:09:13.600 --> 00:09:14.820
It is possible to use it.

00:09:14.920 --> 00:09:18.210
It's not trivially done,
so it's not something that

00:09:18.390 --> 00:09:21.150
we'll be discussing today,
but you should assume

00:09:21.150 --> 00:09:22.770
that it's not available.

00:09:23.420 --> 00:09:24.780
Most libraries are not available.

00:09:24.820 --> 00:09:27.140
We have a very incomplete
implementation of libc,

00:09:27.140 --> 00:09:28.230
for example.

00:09:28.460 --> 00:09:31.200
Even printf, you know,
not all the arguments or the different

00:09:31.210 --> 00:09:32.800
format options are supported.

00:09:32.970 --> 00:09:37.310
So it's a very minimalized
environment there.

00:09:37.490 --> 00:09:39.250
This question comes up very frequently.

00:09:39.410 --> 00:09:41.610
File I/O is not supported
from the kernel.

00:09:41.730 --> 00:09:45.960
This is sort of a restatement of that
driver shouldn't be implementing policy.

00:09:46.040 --> 00:09:49.490
A driver shouldn't be
opening and writing files.

00:09:49.700 --> 00:09:56.480
If a driver needs some
information out of a file,

00:09:56.480 --> 00:10:02.270
some higher-level entity
should open that file,

00:10:02.270 --> 00:10:02.270
like a daemon or an application utility
should open that file and communicate

00:10:02.270 --> 00:10:02.270
the contents down to the driver.

00:10:03.740 --> 00:10:06.400
Debugging is via remote GDB.

00:10:06.400 --> 00:10:11.470
Generally that's attached over Ethernet,
but it can also be done through FireWire.

00:10:13.370 --> 00:10:15.300
C++ in the kernel.

00:10:15.770 --> 00:10:17.430
So I/O Kit is C++.

00:10:17.510 --> 00:10:19.800
We actually use kind of a restricted set.

00:10:19.890 --> 00:10:23.790
It's very similar to the embedded
C++ effort from a few years ago.

00:10:23.890 --> 00:10:26.100
We don't support
exceptions in the kernel.

00:10:26.200 --> 00:10:28.600
Multiple inheritance are not used.

00:10:28.710 --> 00:10:30.310
They're not supported.

00:10:30.640 --> 00:10:32.520
Non-trivial constructors
are not supported.

00:10:32.710 --> 00:10:35.000
Because we don't support exceptions,
you basically,

00:10:35.000 --> 00:10:36.490
your constructors can't fail.

00:10:36.610 --> 00:10:39.610
So you can't do anything in
them that could cause failure.

00:10:39.610 --> 00:10:42.610
They're generally just for
trivial initialization.

00:10:44.270 --> 00:10:46.720
So we don't have the
standard template library,

00:10:46.780 --> 00:10:52.110
and we don't have the standard
RTTI support from C++.

00:10:52.290 --> 00:10:59.200
We actually have our own variant
of that we call OS Metaclass.

00:10:59.200 --> 00:11:01.950
So templates are partially supported,
and by that I mean we

00:11:01.950 --> 00:11:04.700
don't use them in Apple,
we don't test them.

00:11:04.790 --> 00:11:07.200
However, we've done nothing to prevent
them from working in the compiler.

00:11:07.200 --> 00:11:09.950
So it's kind of a no-lifeguard
on duty situation,

00:11:10.110 --> 00:11:13.570
but I know there are developers
who successfully use them.

00:11:14.870 --> 00:11:17.470
And in general,
you're free to use any language feature.

00:11:17.520 --> 00:11:22.990
If you can figure out a way to make a
Fortran compile and run inside a text,

00:11:23.320 --> 00:11:24.190
You're welcome to do that.

00:11:24.200 --> 00:11:26.680
As long as none of the
runtime requirements spill

00:11:26.680 --> 00:11:30.670
over across the kex boundary,
it's not going to create any problems.

00:11:30.780 --> 00:11:32.790
But basically,
we're using C++ as our ABI,

00:11:32.790 --> 00:11:35.700
and that's what we're going
to be talking about today.

00:11:35.700 --> 00:11:38.700
So, let's talk about classes.

00:11:38.830 --> 00:11:42.760
The root class of everything
in the kernel C++ environment

00:11:42.770 --> 00:11:46.360
is called OSObject,
and it provides basic object

00:11:46.360 --> 00:11:51.140
services like introspection,
casting, things like that.

00:11:51.290 --> 00:11:53.860
The reference counting is one
of the major things that you'll

00:11:53.860 --> 00:11:56.530
encounter in I/O Kit objects,
so it is important to understand

00:11:56.580 --> 00:11:58.170
how the reference counting works.

00:11:58.360 --> 00:12:00.440
But it's basically when
you allocate an object,

00:12:00.440 --> 00:12:01.700
it has a ref count of one.

00:12:01.940 --> 00:12:04.040
When the ref count goes to zero,
that object is

00:12:04.040 --> 00:12:05.660
automatically freed for you.

00:12:05.850 --> 00:12:08.090
You should never call free
directly on an object.

00:12:08.220 --> 00:12:10.700
You should use ref counts to manage that.

00:12:11.470 --> 00:12:13.770
And this is so important,
you'll see it at least three

00:12:13.770 --> 00:12:14.940
times in this presentation.

00:12:15.000 --> 00:12:19.110
Make sure and use the OS declare
or OS define structure macros

00:12:19.500 --> 00:12:22.190
for every class that you create.

00:12:22.250 --> 00:12:25.780
This is a set of macros that generates
some additional information that our

00:12:25.780 --> 00:12:28.120
binary compatibility patcher uses.

00:12:28.190 --> 00:12:30.800
So when we load your text
on future operating systems,

00:12:30.960 --> 00:12:34.180
we can patch the V tables so
that it will work correctly.

00:12:34.260 --> 00:12:38.110
If you don't put these in,
your driver will probably work

00:12:38.110 --> 00:12:40.260
until the next OS comes out.

00:12:40.900 --> 00:12:43.660
So, the evil of this is if
you don't put it in there,

00:12:43.660 --> 00:12:44.740
there's no immediate symptom.

00:12:44.740 --> 00:12:48.770
It doesn't happen until your
driver's already out in the field.

00:12:50.260 --> 00:12:52.460
We have a number of container
and collection classes.

00:12:52.460 --> 00:12:55.300
I'm not going to go into these because
there's plenty of documentation on them.

00:12:55.380 --> 00:12:58.080
They're basically object wrappers
that either contain other objects

00:12:58.100 --> 00:13:00.500
or contain quantities or strings.

00:13:00.520 --> 00:13:04.510
They're used for communication
with I/O Kit and for communicating

00:13:04.510 --> 00:13:07.090
status and configuring drivers.

00:13:10.030 --> 00:13:13.240
Now, probably the most important
class for anybody playing

00:13:13.240 --> 00:13:14.920
an I/O Kit is I/O Service.

00:13:15.210 --> 00:13:18.910
This is where the bulk of the
I/O Kit's implementation exists.

00:13:19.290 --> 00:13:21.880
This is where the bulk of
the services are implemented.

00:13:21.980 --> 00:13:24.900
So, you'll need to become very
familiar with this class.

00:13:24.900 --> 00:13:27.830
Every driver class in
I/O Kit inherits from it,

00:13:27.840 --> 00:13:30.900
and it handles things
like the driver lifecycle,

00:13:30.900 --> 00:13:34.900
the matching in of drivers,
the initializing them,

00:13:34.900 --> 00:13:35.880
tearing them down later.

00:13:36.290 --> 00:13:39.900
Power management is driven
entirely out of this object.

00:13:40.050 --> 00:13:44.200
Access control,
the ability to have one object owned

00:13:44.310 --> 00:13:48.900
possibly by multiple drivers or
owned exclusively by a single driver,

00:13:48.900 --> 00:13:50.900
there's implementation in there for that.

00:13:51.020 --> 00:13:54.230
In general, service rendezvous,
how you find things in I/O Kit,

00:13:54.290 --> 00:13:57.380
how you acquire them,
it's all done through I/O Service.

00:13:57.700 --> 00:14:02.100
Now there's two different roles that
subclasses of I/O Service can play.

00:14:02.150 --> 00:14:05.100
The first role is that of a driver.

00:14:05.190 --> 00:14:07.800
This is the actual
implementation of something.

00:14:07.800 --> 00:14:11.370
This is the code that knows how to take
a generic thing like a SCSI command

00:14:11.680 --> 00:14:14.100
and get it out on the silicon,
out on the bus.

00:14:14.100 --> 00:14:16.250
Okay,
that's the piece you're going to write.

00:14:16.360 --> 00:14:21.390
The other object is called a nub,
and this is a little bit more conceptual.

00:14:21.400 --> 00:14:22.520
It's more of an interface.

00:14:22.670 --> 00:14:27.880
You often don't have to subclass these,
but these are the sort of the

00:14:27.980 --> 00:14:29.990
units of attainable service.

00:14:30.000 --> 00:14:32.150
When you publish a nub, you're saying,
"Here's a service.

00:14:32.440 --> 00:14:34.500
Somebody else in the operating
system can acquire it,

00:14:34.500 --> 00:14:37.950
can open it." If you have
multiple services you export,

00:14:37.970 --> 00:14:39.900
you create multiple nubs.

00:14:42.990 --> 00:14:44.120
Memory Management.

00:14:44.120 --> 00:14:46.390
I won't spend a lot of time on these.

00:14:46.390 --> 00:14:47.540
There's quite a lot there.

00:14:47.540 --> 00:14:50.580
In fact, there's a whole other session
following this one that you

00:14:50.590 --> 00:14:52.150
would probably want to attend.

00:14:52.260 --> 00:14:54.290
I/O Memory Descriptor is just that.

00:14:54.410 --> 00:14:55.600
It describes memory.

00:14:55.830 --> 00:15:01.050
It's a class that we use as sort of a
universal token when we communicate an

00:15:01.050 --> 00:15:04.300
I/O request across the various drivers.

00:15:04.350 --> 00:15:07.550
It remembers what task
the request came from.

00:15:07.840 --> 00:15:10.300
It knows if it's been mapped
into the kernel address space.

00:15:10.300 --> 00:15:11.600
It knows if it's been wired.

00:15:11.730 --> 00:15:12.700
It keeps track of all that.

00:15:12.700 --> 00:15:16.180
So if one driver wires it down and
then the next driver goes to wire it,

00:15:16.240 --> 00:15:17.600
it remembers that it's already wired.

00:15:17.600 --> 00:15:20.620
So it's very efficient when
you have multiple drivers

00:15:20.620 --> 00:15:22.300
acting on the same memory.

00:15:22.310 --> 00:15:26.270
I/O DMA Command is sort of our
next generation replacement

00:15:26.270 --> 00:15:29.950
for I/O Memory Cursor,
and it is necessary on the

00:15:29.950 --> 00:15:32.000
new Intel 64-bit machines.

00:15:32.060 --> 00:15:35.050
I won't spend a lot of time talking
about it because about half of

00:15:35.070 --> 00:15:38.700
the following session in this
room is dedicated to this class.

00:15:38.710 --> 00:15:41.800
But it basically will
take your constraints.

00:15:41.800 --> 00:15:43.970
You'll say my DMA engine
is capable of this reach,

00:15:44.060 --> 00:15:45.700
this stride, and so on.

00:15:45.790 --> 00:15:50.770
And whenever you go to say, well,
here's an I/O Memory Descriptor,

00:15:50.770 --> 00:15:55.290
I need to be able to hand this off down
into my hardware with these constraints.

00:15:55.400 --> 00:15:57.200
It will do the right
thing on that hardware.

00:15:57.380 --> 00:16:00.720
It'll either do the mappings,
it'll copy it if necessary

00:16:00.920 --> 00:16:04.890
to double buffer,
and it also has API for getting

00:16:04.990 --> 00:16:08.590
64-bit physical addresses,
which will be important.

00:16:10.150 --> 00:16:10.940
Synchronization.

00:16:10.950 --> 00:16:14.580
This is probably one of the
areas where I/O Kit diverges

00:16:14.650 --> 00:16:17.010
from most other driver models,
and so you'll want to

00:16:17.120 --> 00:16:18.640
pay close attention here.

00:16:18.660 --> 00:16:22.930
I/O Kit's synchronization model
actually comes from the same

00:16:22.930 --> 00:16:25.240
lineage as the CF run loop.

00:16:25.280 --> 00:16:28.630
Actually,
I/O Kit has a common ancestor with Cocoa,

00:16:28.780 --> 00:16:30.120
if you can believe that.

00:16:30.180 --> 00:16:35.020
So, I/O Work Loop is basically, you can,
conceptually,

00:16:35.020 --> 00:16:36.700
you can think of it as a thread.

00:16:36.730 --> 00:16:39.140
It is, in fact, a lock and a thread,
and I'm not going to go

00:16:39.150 --> 00:16:40.240
into the details here.

00:16:40.260 --> 00:16:44.180
But the idea is, when you have something
attached to a work loop,

00:16:44.210 --> 00:16:46.640
it won't ever be re-entered.

00:16:46.760 --> 00:16:49.410
It guarantees that only one of
the things attached to the work

00:16:49.510 --> 00:16:50.700
loop is executing at a time.

00:16:50.700 --> 00:16:54.040
It's a way of serializing
access to your hardware.

00:16:54.280 --> 00:16:57.200
Now, the way you do that is by attaching
these things called event sources.

00:16:57.200 --> 00:17:01.660
An event source can be an interrupt,
it can be a timer, it can be an arbitrary

00:17:01.690 --> 00:17:02.800
thing that you've created.

00:17:02.800 --> 00:17:06.190
Maybe you've generated your
own command queue and you

00:17:06.200 --> 00:17:08.400
attach that as an event source.

00:17:08.490 --> 00:17:12.020
So the idea is that events come in,
like an interrupt or a timeout,

00:17:12.260 --> 00:17:15.300
and you've specified a callback
with that event source.

00:17:15.350 --> 00:17:18.980
When that event triggers, at some point,
hopefully very shortly

00:17:18.980 --> 00:17:22.270
after the event triggers,
your handler will be called,

00:17:22.280 --> 00:17:24.670
and it will be called in a
guaranteed synchronized manner.

00:17:24.750 --> 00:17:28.910
This is actually a very simple mechanism,
and it's actually carefully

00:17:29.010 --> 00:17:31.890
crafted to work well where you
have multiple drivers interacting

00:17:31.890 --> 00:17:35.500
together that are not aware of each
other's internal locking structure.

00:17:35.530 --> 00:17:39.510
It uses recursive spin locks so
that you can actually share a

00:17:39.510 --> 00:17:43.470
work loop across multiple drivers,
and this is being done for you

00:17:43.470 --> 00:17:44.880
whether you know it or not.

00:17:44.950 --> 00:17:48.920
And it's done in a way to prevent
additional context switches as data

00:17:49.220 --> 00:17:51.260
moves up and down driver stacks.

00:17:51.400 --> 00:17:54.600
So it's intended to be
simple for you to use,

00:17:54.620 --> 00:17:57.300
but it's also intended to be
very efficient for the system.

00:17:57.400 --> 00:18:00.180
So pay attention and make sure
you're using it correctly.

00:18:00.310 --> 00:18:03.570
Probably one of the number one pitfalls
that I've seen with people porting

00:18:03.570 --> 00:18:06.400
drivers to Mac OS X is they say,
"Well, I've already got a locking

00:18:06.440 --> 00:18:07.900
structure in this driver that works.

00:18:08.130 --> 00:18:09.000
I'm not going to mess with it.

00:18:09.000 --> 00:18:11.680
I'm just going to kind of cobble
on a work loop to the side to

00:18:11.710 --> 00:18:14.500
get it to work with I/O Kit."
You will deadlock frequently.

00:18:14.500 --> 00:18:16.870
It will not be a pleasant
debugging experience.

00:18:16.960 --> 00:18:21.330
So I strongly recommend that
you don't try that approach.

00:18:21.660 --> 00:18:26.500
If you can successfully go that way,
you'll be lucky, but you need to look at

00:18:26.500 --> 00:18:28.670
I/O Work Loop carefully.

00:18:30.410 --> 00:18:34.250
As I spoke about before,
I/O Kit families provide

00:18:34.250 --> 00:18:38.060
bus or protocol-specific
implementation to the system.

00:18:38.060 --> 00:18:40.170
And the families can be
introduced at any time.

00:18:40.340 --> 00:18:43.850
Like the ADB family is
probably on its last legs.

00:18:43.910 --> 00:18:46.140
There's not a lot of reason to
keep it around for many more years.

00:18:46.300 --> 00:18:52.120
So they can come and go over time with
the core of I/O Kit remaining untouched.

00:18:52.350 --> 00:18:56.470
And the way you can spot the
family API or I/O Kit API is

00:18:56.580 --> 00:18:58.290
it has the I/O prefix.

00:18:58.300 --> 00:19:02.200
Except for a few small exceptions,
every time you see the I/O prefix,

00:19:02.200 --> 00:19:03.300
that's I/O Kit.

00:19:03.410 --> 00:19:05.650
By that token,
you should not be writing anything

00:19:05.650 --> 00:19:07.290
with an I/O prefix in your code.

00:19:07.440 --> 00:19:09.210
That's for us.

00:19:10.030 --> 00:19:11.540
Again, look in the kernel framework.

00:19:11.590 --> 00:19:14.580
That's where all of the I/O Kit APIs for
in-kernel development go.

00:19:14.890 --> 00:19:17.830
That's where all the family APIs go.

00:19:17.920 --> 00:19:22.500
And the specific family
that you use depends on

00:19:24.000 --> 00:19:27.490
What service your driver
is going to provide.

00:19:27.570 --> 00:19:29.720
So you can think of it this way.

00:19:30.390 --> 00:19:33.280
The PCI Ethernet adapter
that the user plugs in,

00:19:33.280 --> 00:19:35.140
what is the user putting in?

00:19:35.200 --> 00:19:36.430
They're putting in an Ethernet card.

00:19:36.440 --> 00:19:37.760
That's what they care about.

00:19:37.830 --> 00:19:39.940
That's where you look
to find your family.

00:19:40.150 --> 00:19:42.960
A lot of developers will,
the immediate thought is, "Well,

00:19:43.020 --> 00:19:45.750
I'm attached via PCI,
therefore I must go through the

00:19:45.750 --> 00:19:49.540
PCI family." You will use the PCI family,
but that is not the service

00:19:49.540 --> 00:19:51.610
that your driver is providing.

00:19:53.220 --> 00:19:56.700
Here's a sort of short list of
families that are available.

00:19:56.700 --> 00:20:01.440
Some of these are actually
sort of collapsed lists of

00:20:01.440 --> 00:20:04.680
multiple sub-families as well.

00:20:05.240 --> 00:20:07.910
There's quite a few to choose from,
and in fact your driver might

00:20:07.910 --> 00:20:11.090
fall into the sort of category
we have of familyless drivers,

00:20:11.100 --> 00:20:12.680
and that's entirely possible.

00:20:12.790 --> 00:20:15.550
It just means you don't actually
inherit any implementation.

00:20:15.650 --> 00:20:18.200
You can inherit straight
from I/O Service,

00:20:18.280 --> 00:20:21.300
implement whatever you need to,
and you're not actually getting

00:20:21.300 --> 00:20:22.700
any functionality from a family.

00:20:22.700 --> 00:20:26.410
But it's not required that you
actually inherit from a family.

00:20:29.030 --> 00:20:31.390
Another concept that's very
important to I/O Kit is something

00:20:31.490 --> 00:20:33.280
we call the I/O Registry.

00:20:33.300 --> 00:20:35.970
It is not the Windows Registry.

00:20:37.000 --> 00:20:38.690
I'll say that again.

00:20:39.030 --> 00:20:40.990
It is not the Windows registry.

00:20:40.990 --> 00:20:43.070
Thanks.

00:20:44.460 --> 00:20:45.940
It is not persistent.

00:20:45.980 --> 00:20:51.070
It is actually the
network of live objects.

00:20:51.860 --> 00:20:52.440
Right?

00:20:52.480 --> 00:20:55.460
These are all the I/O Kit objects,
all the I/O Service objects,

00:20:55.460 --> 00:20:56.860
sort of in this cloud.

00:20:56.860 --> 00:20:59.370
And all the registry is is
just a collection of pointers

00:20:59.370 --> 00:21:00.660
linking them together.

00:21:00.690 --> 00:21:01.800
It's very simple.

00:21:01.920 --> 00:21:05.030
We often speak of it
as this tree structure.

00:21:05.340 --> 00:21:06.720
It is a tree structure.

00:21:06.790 --> 00:21:11.130
It's actually a directed acyclic graph
because it is possible to have one

00:21:11.130 --> 00:21:14.810
driver with two providers below it,
like in the case of RAID or

00:21:14.870 --> 00:21:15.800
a few other rare cases.

00:21:15.800 --> 00:21:17.800
But think of it as a tree.

00:21:17.960 --> 00:21:23.100
We have one node at the bottom that
represents the platform itself,

00:21:23.100 --> 00:21:24.670
the platform nub.

00:21:24.840 --> 00:21:28.800
And then everything above that represents
more specific and more specific hardware

00:21:28.800 --> 00:21:33.260
until you actually sort of get to
the boundaries where it steps out of

00:21:33.260 --> 00:21:39.660
I/O Kit into some other family like the
file systems or the networking stacks.

00:21:41.490 --> 00:21:43.780
So focusing in on just
two of the objects here,

00:21:43.820 --> 00:21:48.100
we refer to the relationship here
as a client-provider relationship.

00:21:48.150 --> 00:21:52.780
And the idea here is the NUB is
providing some service that the driver,

00:21:52.780 --> 00:21:54.920
in this case, is a client of.

00:21:54.960 --> 00:21:56.870
Simple as that.

00:21:58.790 --> 00:22:01.790
In addition to the actual objects
that are running in the registry,

00:22:01.910 --> 00:22:04.540
we have these dictionaries
attached to the side.

00:22:04.780 --> 00:22:08.860
These are basically
collections of strings,

00:22:08.970 --> 00:22:11.540
property names,
and values that can be used

00:22:11.580 --> 00:22:12.670
to describe your driver.

00:22:12.820 --> 00:22:14.580
You can use it for status.

00:22:14.610 --> 00:22:18.170
You can use it for stats,
command and control.

00:22:18.400 --> 00:22:20.830
It is,
you can think of it as sort of like

00:22:20.910 --> 00:22:23.350
an I/Octal replacement in I/O Kit.

00:22:23.490 --> 00:22:24.520
It's not high bandwidth.

00:22:24.650 --> 00:22:27.680
You will not be doing disk
I/O through the registry,

00:22:27.730 --> 00:22:29.990
but you will be discovering
maybe the capabilities of the

00:22:29.990 --> 00:22:32.100
drive through the registry.

00:22:33.110 --> 00:22:35.600
So every object in the registry has this.

00:22:35.670 --> 00:22:38.150
There's a command line utility
called I/O Reg that will dump

00:22:38.150 --> 00:22:39.450
the contents of the registry.

00:22:39.730 --> 00:22:43.580
There's also an I/O Registry
Explorer app that will allow

00:22:43.580 --> 00:22:45.700
you to graphically do this.

00:22:45.770 --> 00:22:47.750
If you're new to I/O Kit, try I/O Reg.

00:22:47.750 --> 00:22:51.870
You're going to learn a tremendous
amount just by poking around in there.

00:22:52.510 --> 00:22:55.000
And of course,
apps use the registry as sort of

00:22:55.000 --> 00:22:57.140
their main rendezvous mechanism.

00:22:57.140 --> 00:23:00.160
They discover things by doing
searches on those dictionaries

00:23:00.160 --> 00:23:01.830
that are hanging off the side.

00:23:01.890 --> 00:23:04.230
We'll draw that in a bit.

00:23:06.420 --> 00:23:07.400
There.

00:23:07.520 --> 00:23:10.600
So, in this case,
we have an application which is using the

00:23:10.600 --> 00:23:12.900
I/O Kit framework to search for a driver.

00:23:13.070 --> 00:23:15.620
It's very common that you'll search
for a driver by class because

00:23:15.700 --> 00:23:17.170
you know what you're looking for.

00:23:17.330 --> 00:23:19.380
You can also search by
any variety of properties.

00:23:19.420 --> 00:23:24.850
We've got a staggering array of
search capabilities in the registry.

00:23:25.000 --> 00:23:29.370
And once you've found the object
that you're interested in,

00:23:29.660 --> 00:23:33.520
you can communicate with it
simply by getting and setting

00:23:33.650 --> 00:23:33.910
properties in the registry.

00:23:34.890 --> 00:23:38.290
Or you can open up a high bandwidth
channel we call an I/O User Client,

00:23:38.290 --> 00:23:40.190
and I'll spend time
talking about that later.

00:23:40.300 --> 00:23:45.940
But basically it is a dedicated channel
that uses Mach IPC or Mach shared memory,

00:23:45.940 --> 00:23:50.600
depending on the context,
to communicate across

00:23:50.600 --> 00:23:50.600
the user-kernel boundary.

00:23:53.590 --> 00:23:56.310
Okay, we've just spent a little
while talking about sort of the

00:23:56.430 --> 00:23:57.950
high-level concepts in I/O Kit.

00:23:58.020 --> 00:24:01.290
We've kind of taught
you basic vocabulary.

00:24:01.470 --> 00:24:04.060
To drive that home,
I think we're going to go through

00:24:04.110 --> 00:24:06.990
an example here of kind of how
you would go about piecing a

00:24:06.990 --> 00:24:08.920
driver together using I/O Kit.

00:24:14.470 --> 00:24:19.540
So if you're brand new to Mac OS X,
you need to discover developer.apple.com.

00:24:19.560 --> 00:24:23.940
It has a fantastic search engine that
searches all the available documentation,

00:24:23.940 --> 00:24:25.860
and I use it daily.

00:24:26.010 --> 00:24:27.420
It's a very powerful tool.

00:24:27.540 --> 00:24:31.420
So go there, browse it,
become comfortable with it.

00:24:31.780 --> 00:24:36.490
We've created a few tutorials that
we thought would be useful for

00:24:36.490 --> 00:24:39.250
getting people's feet wet sort
of on day one when they were first

00:24:39.250 --> 00:24:40.700
exposed to kernel development.

00:24:40.700 --> 00:24:42.700
So the first one is called Hello Kernel.

00:24:42.700 --> 00:24:47.040
It is literally writing a kernel
extension that does nothing but

00:24:47.040 --> 00:24:49.700
log Hello Kernels and then exiting.

00:24:49.820 --> 00:24:52.580
So what you need to do is spend
the half a day or so it takes to

00:24:52.580 --> 00:24:54.600
download this and experiment with it.

00:24:54.700 --> 00:24:59.820
There's also a Hello I/O Kit tutorial
which takes that and puts the

00:24:59.820 --> 00:25:03.500
C++ wrappers around it that
you'll need to have a driver

00:25:03.630 --> 00:25:05.490
object interact with I/O Kit.

00:25:05.700 --> 00:25:09.030
There's also a debugger tutorial
that talks you through setting

00:25:09.080 --> 00:25:11.050
up the two-machine environment.

00:25:14.680 --> 00:25:15.630
So we're writing a driver.

00:25:15.790 --> 00:25:16.350
Where do we start?

00:25:16.530 --> 00:25:18.350
Well, as I said before,
you need to think about the

00:25:18.370 --> 00:25:22.270
service that you're vending
out to the operating system.

00:25:22.910 --> 00:25:26.300
So a PCI Ethernet driver
presents an Ethernet interface.

00:25:26.300 --> 00:25:29.510
A mouse driver provides
a pointing device.

00:25:29.710 --> 00:25:33.350
In neither of those cases is the
method of attachment relevant,

00:25:33.430 --> 00:25:35.100
at least not yet.

00:25:35.790 --> 00:25:39.530
So in our exercise,
we're going to write a block storage

00:25:39.530 --> 00:25:41.920
device that attaches via PCI.

00:25:41.920 --> 00:25:43.230
This is a hypothetical device.

00:25:43.280 --> 00:25:46.730
You can think of it as a
battery-backed-up RAM disk or

00:25:46.730 --> 00:25:48.620
it could be some remote thing.

00:25:48.620 --> 00:25:52.470
It doesn't really matter,
but it's a way of persistently

00:25:52.470 --> 00:25:54.890
storing data through a PCI card.

00:25:56.940 --> 00:25:59.140
And at this point in the exercise,
the fact that it's

00:25:59.140 --> 00:26:00.980
PCI isn't really relevant.

00:26:01.110 --> 00:26:02.860
So we have to select a family first.

00:26:02.860 --> 00:26:05.180
Again, go to developer.apple.com.

00:26:05.220 --> 00:26:07.170
If you go to the
I/O Kit Fundamentals document,

00:26:07.180 --> 00:26:11.480
which I highly recommend, by the way,
there's Appendix A in there,

00:26:11.480 --> 00:26:13.020
which is a family reference guide.

00:26:13.020 --> 00:26:15.180
It has like a page for each
family that kind of gives you

00:26:15.180 --> 00:26:16.960
the scope of what it covers.

00:26:17.010 --> 00:26:20.160
That's your sort of first
stop to figure this out.

00:26:20.270 --> 00:26:22.910
So you select an appropriate driver,
and then maybe you go search

00:26:22.910 --> 00:26:26.970
Darwin for examples of drivers
written for that family.

00:26:28.880 --> 00:26:30.810
So in our case,
we're going to discover the

00:26:30.810 --> 00:26:33.260
Mass Storage Device Driver Programming
Guide,

00:26:33.260 --> 00:26:38.710
and it's going to become clear that our
driver fits into the I/O storage family.

00:26:42.530 --> 00:26:46.600
Now, the approach we're going to take
from a class perspective is a little

00:26:46.600 --> 00:26:48.150
bit backwards than you might think.

00:26:48.210 --> 00:26:50.940
And we wouldn't code in this order,
but this is the way

00:26:50.940 --> 00:26:51.990
we're going to design.

00:26:52.070 --> 00:26:53.290
So we're going to start at the top.

00:26:53.360 --> 00:26:55.000
Again, we're service-oriented.

00:26:55.120 --> 00:26:58.880
What service are we
exporting to the world,

00:26:58.880 --> 00:27:01.040
to the OS in this case?

00:27:01.120 --> 00:27:04.470
So we've got to determine
what our NUB class is.

00:27:07.370 --> 00:27:09.870
Well, from looking at the headers
in our selected family,

00:27:09.870 --> 00:27:13.280
we'll see this little quote here:
"The I/O Block Storage Device class

00:27:13.370 --> 00:27:17.110
exports the generic block storage
protocol." That's what we're looking for.

00:27:17.280 --> 00:27:19.830
So in our driver here,
the nubs are going to be of

00:27:19.830 --> 00:27:24.160
class "I/O Block Storage Device."
A word on I/O Kit naming.

00:27:24.460 --> 00:27:27.770
You'll very commonly
see the suffix "device."

00:27:28.190 --> 00:27:31.240
For something that is
representing a device,

00:27:31.240 --> 00:27:34.070
sort of the proxy for
a device in the system.

00:27:34.190 --> 00:27:36.860
So this class,
when you instantiate one of them,

00:27:36.930 --> 00:27:38.550
represents the actual device.

00:27:38.740 --> 00:27:41.790
It is the software
embodiment of the device.

00:27:41.980 --> 00:27:45.010
A lot of nubs have a
device as their suffix,

00:27:45.010 --> 00:27:49.400
and you'll find that "driver"
is very commonly the suffix for

00:27:49.490 --> 00:27:51.880
the other class we talked about.

00:27:53.360 --> 00:27:54.940
So the base class.

00:27:55.190 --> 00:27:58.950
This is the class that you're going
to use to write all your code in.

00:27:59.380 --> 00:28:02.300
This is going to be the class
that then goes and publishes

00:28:02.300 --> 00:28:04.110
that nub that we just discovered.

00:28:05.690 --> 00:28:09.450
Now, our first way of determining what
class to use here is going to be,

00:28:09.480 --> 00:28:11.170
again, to look at the nub class.

00:28:11.550 --> 00:28:13.860
Very few nubs are completely agnostic.

00:28:13.960 --> 00:28:17.370
They have some particular class
they want to be published by,

00:28:17.500 --> 00:28:20.300
and so they'll usually point
you in the right direction.

00:28:20.390 --> 00:28:22.870
And sure enough,
the transport driver can be of any type

00:28:22.870 --> 00:28:24.900
as long as it inherits from I/O Service.

00:28:24.900 --> 00:28:28.190
So it points us in the right direction,
just happens that it's

00:28:28.250 --> 00:28:30.100
a very vague direction.

00:28:30.320 --> 00:28:32.100
In this case, it doesn't matter.

00:28:32.100 --> 00:28:35.560
Most nubs do care what their
providing class is going to be.

00:28:35.770 --> 00:28:38.000
In our case, for this example,
it doesn't.

00:28:38.000 --> 00:28:41.110
So we're just going to
inherit from I/O Service.

00:28:44.360 --> 00:28:47.200
Now the third bubble down
on our I/O Registry graph is

00:28:47.260 --> 00:28:49.410
going to be the Provider Class.

00:28:49.530 --> 00:28:51.430
This is not a class that we write.

00:28:51.620 --> 00:28:53.590
This is not a class that we instantiate.

00:28:53.770 --> 00:28:55.440
This is something that is given to us.

00:28:55.560 --> 00:28:59.850
This is handed to us as our way of
attaching and getting at our hardware.

00:29:00.780 --> 00:29:05.490
So we call down into this object
to communicate to the hardware

00:29:05.500 --> 00:29:07.480
that we're going to be driving.

00:29:09.920 --> 00:29:13.100
In our particular example,
we know it's PCI.

00:29:13.100 --> 00:29:15.150
This is where the attachment
method becomes relevant.

00:29:15.280 --> 00:29:19.100
What's interesting here is we're not
inheriting any code from the PCI family.

00:29:19.200 --> 00:29:22.230
All we're doing is calling into
an object that it provides,

00:29:22.230 --> 00:29:24.440
in this case a nub called I/O PCI Device.

00:29:24.610 --> 00:29:31.150
Again, the device suffix represents the,
indicates that the object you're

00:29:31.150 --> 00:29:34.580
talking to is a proxy for the hardware.

00:29:34.590 --> 00:29:35.710
In this case, it represents the
PCI hardware on the bus.

00:29:37.720 --> 00:29:39.190
So, I've talked through that.

00:29:39.190 --> 00:29:40.720
Let's look at it graphically.

00:29:40.920 --> 00:29:45.120
So, on the top there, we have our nub,
which is going to be an I/O block

00:29:45.140 --> 00:29:47.170
storage device subclass.

00:29:47.440 --> 00:29:50.770
Our driver, where the meat of our
implementation is going to go,

00:29:50.770 --> 00:29:55.890
is going to be a subclass of I/O Service,
and then I/O PCI device is

00:29:55.890 --> 00:29:57.440
going to be our provider.

00:29:57.510 --> 00:30:01.290
This is where we're going to
get access to our PCI card.

00:30:01.330 --> 00:30:04.100
These are the parts
that we need to write.

00:30:04.820 --> 00:30:07.770
Okay, we have to write code in our
NUB subclass and we have to write

00:30:08.000 --> 00:30:10.070
code in our driver subclass.

00:30:10.070 --> 00:30:12.880
And depending on the family and
depending on exactly what you're writing,

00:30:12.930 --> 00:30:13.920
this can vary.

00:30:14.020 --> 00:30:18.260
It's very common that you don't have
to write any code in your NUB at all.

00:30:20.100 --> 00:30:22.460
Now another interesting thing
here is why split this up?

00:30:22.720 --> 00:30:25.510
Why do we have two objects in
this hierarchy and why are we

00:30:25.510 --> 00:30:26.690
writing code in both of them?

00:30:26.790 --> 00:30:29.210
Seems like it would be
simpler to combine the two.

00:30:29.320 --> 00:30:32.150
Well, this is a contrived
example that's very simple.

00:30:32.280 --> 00:30:36.380
Most controllers can export
more than one device.

00:30:36.970 --> 00:30:40.740
So it wouldn't be uncommon for
your controller to export two,

00:30:40.740 --> 00:30:42.440
three, four nubs.

00:30:42.480 --> 00:30:47.520
So when you think about that,
it makes more sense to have this split.

00:30:48.490 --> 00:30:51.670
But if you do have a case where
you have a one-to-one relationship

00:30:51.810 --> 00:30:55.960
between the controller and the nub,
in many cases I/O Kit does support

00:30:55.960 --> 00:30:58.110
combining them into one class.

00:30:58.160 --> 00:31:02.190
If you recall, the nub documentation
said that its provider,

00:31:02.250 --> 00:31:05.840
the actual driver class,
could be any subclass of I/O Service.

00:31:05.880 --> 00:31:09.040
Well, the nub itself is a
subclass of I/O Service.

00:31:09.100 --> 00:31:12.640
So you can imply from that it
would be okay for the nub to

00:31:12.640 --> 00:31:14.700
basically be driven by itself.

00:31:14.950 --> 00:31:17.700
In this case, you could write all
your code in one blob,

00:31:17.700 --> 00:31:19.960
and it would just simply publish itself.

00:31:20.030 --> 00:31:23.340
You'll find there are not many
cases where this is actually useful,

00:31:23.390 --> 00:31:26.170
but for sort of first time
experimenting with I/O Kit,

00:31:26.270 --> 00:31:27.870
you might find it handy.

00:31:29.850 --> 00:31:32.220
So, let's talk about
implementation a little bit.

00:31:32.420 --> 00:31:34.150
We need to write the NUB class.

00:31:34.240 --> 00:31:37.270
Again, this is the thing that
presents our interface,

00:31:37.380 --> 00:31:39.310
our service out to I/O Kit.

00:31:39.420 --> 00:31:41.310
And the details here are
going to be family specific.

00:31:41.420 --> 00:31:44.300
We're not going to spend
a lot of time on APIs,

00:31:44.300 --> 00:31:47.140
but we will talk about them a little bit.

00:31:49.490 --> 00:31:51.280
So again, looking,
going back to our headers,

00:31:51.330 --> 00:31:53.760
we find this comment.

00:31:53.840 --> 00:31:57.040
A typical implementation for
a subclass relays all the

00:31:57.040 --> 00:31:59.560
methods down to its provider,
which implements the

00:31:59.570 --> 00:32:01.100
device-specific behavior.

00:32:01.170 --> 00:32:04.730
So back in that stacked diagram,
the upper blue box that we're writing is

00:32:04.730 --> 00:32:07.000
primarily going to just be pass-through.

00:32:07.020 --> 00:32:11.100
And we've referred to this in the past
as sort of an impedance matching layer.

00:32:11.200 --> 00:32:14.940
This is because we have two
I/O Kit objects stacked up that

00:32:14.940 --> 00:32:17.400
don't inherit from a common tree.

00:32:17.460 --> 00:32:19.430
Therefore,
they can't make assumptions about

00:32:19.830 --> 00:32:22.390
what class the other one is,
and they can't cast.

00:32:22.480 --> 00:32:27.870
So what we have to do is we use the nub
object as a intermediary that is aware of

00:32:27.870 --> 00:32:30.200
the classes and can do the right thing.

00:32:30.200 --> 00:32:35.280
And so it's basically simply calling
through directly down to its provider.

00:32:35.630 --> 00:32:37.880
As I said before,
you're going to see this in a few places.

00:32:37.950 --> 00:32:39.210
Here we're implementing a class.

00:32:39.460 --> 00:32:40.790
Make sure and put these macros in.

00:32:41.020 --> 00:32:44.170
Every time you implement a class,
make sure these are in.

00:32:44.390 --> 00:32:47.340
The OS declare structures and
define structures are necessary

00:32:47.430 --> 00:32:48.900
for binary compatibility.

00:32:49.000 --> 00:32:51.400
So looking through the header,
we find we have to implement

00:32:51.400 --> 00:32:53.350
about 20 methods in this subclass.

00:32:53.530 --> 00:32:57.990
So let's look at what
that breaks down to,

00:32:57.990 --> 00:32:57.990
just to give you an idea
of what you'll be facing.

00:32:59.320 --> 00:33:01.120
Well, again,
most of them are simple down calls.

00:33:01.250 --> 00:33:05.190
Fourteen of them are just sort of
capabilities and description functions,

00:33:05.190 --> 00:33:09.000
like get the vendor name,
get the block size, get the block count.

00:33:09.030 --> 00:33:12.200
These are very trivial
getter-setter functions.

00:33:12.270 --> 00:33:15.610
So that leaves us with about
six that are actually important,

00:33:15.610 --> 00:33:17.040
complicated functions.

00:33:17.240 --> 00:33:20.200
On the data path,
we basically only have two.

00:33:20.310 --> 00:33:23.320
We have doAsyncReadWrite,
and you'll notice the first argument

00:33:23.320 --> 00:33:25.200
there is an I/O memory descriptor.

00:33:25.300 --> 00:33:27.770
As I said,
we use memory descriptors as a token

00:33:27.770 --> 00:33:30.180
to pass memory around between drivers.

00:33:30.200 --> 00:33:32.430
Well,
this is where the block storage layer

00:33:32.430 --> 00:33:36.630
is receiving a memory descriptor that
describes the memory that we're either

00:33:36.630 --> 00:33:40.350
going to be reading from or writing into.

00:33:40.840 --> 00:33:44.190
There's a block count, excuse me,
a block index and a block count,

00:33:44.270 --> 00:33:46.100
and then there's a completion callback.

00:33:46.260 --> 00:33:50.270
Pretty much all of the data APIs in
I/O Kit you'll find are asynchronous.

00:33:50.360 --> 00:33:55.290
We use a callback,
and so that's what that's about.

00:33:56.620 --> 00:34:01.000
Do synchronize cache is necessary for
basically guaranteeing that all the

00:34:01.000 --> 00:34:04.500
writes that have happened down the
stack actually get flushed to media.

00:34:04.610 --> 00:34:07.290
So we use this, I believe,
for our journaling to make sure

00:34:07.290 --> 00:34:08.910
the metadata is flushed out.

00:34:09.410 --> 00:34:11.150
Then there's a few methods
here for media management.

00:34:11.180 --> 00:34:14.150
We've got the eject,
we've got something for

00:34:14.150 --> 00:34:16.510
reporting the media state,
whether it's been inserted or not,

00:34:16.630 --> 00:34:18.900
whether it's changed
since we last checked.

00:34:19.030 --> 00:34:22.300
And there's also formatting
and locking the media.

00:34:22.410 --> 00:34:25.200
Again, we're not going to go into those,
but these are just basic

00:34:25.310 --> 00:34:26.830
operations for managing a device.

00:34:26.940 --> 00:34:30.410
You can see sort of where the
complexity here is really is

00:34:30.410 --> 00:34:32.460
around do async read/write.

00:34:33.090 --> 00:34:35.840
Of course, there's also the additional
methods that we call driver

00:34:35.840 --> 00:34:39.420
lifecycle methods that you have to
implement as being part of I/O Kit.

00:34:39.580 --> 00:34:42.100
Init, start,
and stop are sort of the most basic ones.

00:34:42.100 --> 00:34:44.140
There's additional
ones you can implement.

00:34:44.210 --> 00:34:47.710
There's power management methods
you'll want to implement.

00:34:48.090 --> 00:34:51.730
But the one thing I'll call out
here is in your start method,

00:34:52.010 --> 00:34:55.150
in your nub, you're going to want to
call register service.

00:34:55.210 --> 00:34:58.980
This is the thing that kicks off
a lot of activity in I/O Kit.

00:34:59.100 --> 00:35:04.350
Register service says I am now available
and ready for the operating system

00:35:04.350 --> 00:35:06.620
to start sending requests to me.

00:35:08.060 --> 00:35:11.320
And I'll also point out your driver
cannot be located in the registry using

00:35:11.320 --> 00:35:14.930
searching unless you've registered it.

00:35:15.380 --> 00:35:17.370
The theory there is if you
don't register yourself,

00:35:17.460 --> 00:35:18.600
you don't want to be found.

00:35:18.640 --> 00:35:20.300
It's like having an unlisted number.

00:35:20.390 --> 00:35:25.600
So somebody can still navigate the
registry and find you topographically,

00:35:25.830 --> 00:35:31.170
but you can't do a generic search
and find an unregistered object.

00:35:33.900 --> 00:35:35.060
So down to the driver class.

00:35:35.110 --> 00:35:38.360
Again, this is sort of the bulk of
the implementation that you're

00:35:38.360 --> 00:35:39.330
going to be thinking about.

00:35:39.470 --> 00:35:43.190
This is where those commands coming
down from the nub are going to have to

00:35:43.190 --> 00:35:48.740
actually be translated into something
that your PCI driver can actually,

00:35:48.810 --> 00:35:51.200
or PCI hardware can actually execute.

00:35:51.310 --> 00:35:55.680
So what you want to do here is try to
inherit as much behavior as possible.

00:35:56.110 --> 00:35:58.920
In our particular exercise,
we inherit nothing because we're

00:35:58.920 --> 00:36:00.700
using I/O Service as our superclass.

00:36:00.700 --> 00:36:03.170
Different families will
have different details,

00:36:03.390 --> 00:36:06.500
but basically we try to
embody as much common code in

00:36:06.500 --> 00:36:08.570
the superclass as possible.

00:36:08.860 --> 00:36:14.660
And your driver really only needs
to implement the differences or the

00:36:14.660 --> 00:36:17.500
details that make your hardware unique.

00:36:17.500 --> 00:36:20.560
One way of thinking about
it that I've seen people,

00:36:20.560 --> 00:36:24.960
seen sort of the light bulb go off,
is don't think of the family

00:36:24.960 --> 00:36:27.320
as a plug-in to your driver.

00:36:27.710 --> 00:36:30.040
Think of your driver as
a plug-in to the family,

00:36:30.090 --> 00:36:30.540
right?

00:36:30.660 --> 00:36:33.810
The family is the thing
driving this whole operation.

00:36:33.820 --> 00:36:34.920
It knows how the hardware works.

00:36:34.920 --> 00:36:37.120
It knows how to tie in
with the rest of I/O Kit.

00:36:37.220 --> 00:36:41.610
Your driver is a plug-in to that family
to give it hardware-specific details.

00:36:41.690 --> 00:36:45.370
So your driver is responding
to the family as opposed to

00:36:45.480 --> 00:36:48.440
controlling the way the family works.

00:36:48.530 --> 00:36:50.160
Don't try to drive the family.

00:36:50.270 --> 00:36:52.570
Your job is to drive the hardware.

00:36:54.890 --> 00:36:58.510
Okay, so we're going to declare a
new subclass of I/O Service,

00:36:58.510 --> 00:37:00.030
and again the macros.

00:37:00.060 --> 00:37:02.800
Every time you declare a new class,
it's so important.

00:37:02.920 --> 00:37:05.800
And probe and start are
our first two entry points.

00:37:05.800 --> 00:37:08.000
Probe just basically says,
"Can you drive this

00:37:08.000 --> 00:37:12.650
hardware?" And start says,
"Start driving this hardware."

00:37:18.200 --> 00:37:20.530
Okay, again, we're going to have to
provide an init routine.

00:37:20.540 --> 00:37:23.750
This is responsible for
setting up any structures,

00:37:23.750 --> 00:37:27.570
anything that we're going to need
to do that's sort of trivial.

00:37:28.730 --> 00:37:30.600
There's really not a
whole lot to say there.

00:37:30.600 --> 00:37:33.470
When you call your init method,
you're probably going to want to

00:37:33.470 --> 00:37:38.260
pass in some configuration data,
but it's basically standard

00:37:38.260 --> 00:37:40.550
object-oriented coding here.

00:37:40.600 --> 00:37:43.600
Attach is how you get
attached into the registry.

00:37:43.600 --> 00:37:49.590
This is the method that actually creates
that link between provider and client.

00:37:52.450 --> 00:37:54.830
And again,
start is what will be called on you

00:37:54.910 --> 00:38:00.930
when the I/O PCI device below you is
ready for you to start driving it.

00:38:04.270 --> 00:38:08.570
And again, you're going to have your nub
call Register Service to publish

00:38:08.570 --> 00:38:12.300
itself out into the registry so
that other drivers can then attach

00:38:12.300 --> 00:38:14.500
to it and start doing their thing.

00:38:15.460 --> 00:38:19.900
Now, your driver class can instantiate
as many nubs as necessary.

00:38:19.900 --> 00:38:22.550
If you've got a piece of
hardware that can run four

00:38:22.550 --> 00:38:26.580
drives or 12 drives or whatever,
you can instantiate a nub for each drive.

00:38:26.640 --> 00:38:30.520
Another important thing here is they
don't all have to be of the same class.

00:38:30.610 --> 00:38:33.290
You can very easily write a
driver that supports two or three

00:38:33.290 --> 00:38:36.900
different kinds of functions,
so the nubs can be dissimilar.

00:38:40.900 --> 00:38:42.620
Okay, so we've got our driver class.

00:38:42.740 --> 00:38:43.630
It's published in Nub.

00:38:43.640 --> 00:38:44.970
It's gone through all that,
but we still have to

00:38:45.050 --> 00:38:45.890
deal with our provider.

00:38:45.900 --> 00:38:48.230
We have to gain access to our hardware.

00:38:48.330 --> 00:38:50.830
So, to do that,
we're going to wind up calling

00:38:50.830 --> 00:38:52.750
down into that driver a good bit.

00:38:52.980 --> 00:38:56.200
As I said earlier,
I/O Workloop is designed to sort

00:38:56.200 --> 00:38:59.840
of allow for sharing vertically
through the driver stack.

00:39:00.010 --> 00:39:02.660
Well,
you get your Workloop from your provider.

00:39:02.700 --> 00:39:06.200
There's a method called, oddly enough,
GetWorkloop.

00:39:07.120 --> 00:39:09.480
And so when you get that,
you will synchronize all of your

00:39:09.480 --> 00:39:12.190
operations on that work loop,
so when you call down to the provider,

00:39:12.200 --> 00:39:14.710
you're sharing the same work loop he is.

00:39:15.660 --> 00:39:19.620
In our particular case, it's a PCI,
I/O PCI device.

00:39:19.830 --> 00:39:22.060
Now, what does that do?

00:39:22.130 --> 00:39:23.450
Again, it's all PCI-specific.

00:39:23.540 --> 00:39:27.340
It maps the base address registers
into your address space so you

00:39:27.460 --> 00:39:29.670
can actually talk to the hardware.

00:39:30.190 --> 00:39:32.070
It allows you to access config space.

00:39:32.170 --> 00:39:33.940
It hooks you up to your interrupts.

00:39:34.170 --> 00:39:37.600
You know, all the basic stuff you'd
expect from a PCI family.

00:39:37.640 --> 00:39:40.990
You generally use it
mostly at setup time.

00:39:41.050 --> 00:39:44.940
You very rarely will call
down into the PCI family to do

00:39:44.940 --> 00:39:46.690
actual memory reads and writes.

00:39:46.750 --> 00:39:49.600
You can,
and for generating config space access,

00:39:49.600 --> 00:39:50.800
you probably will.

00:39:50.820 --> 00:39:52.400
But once you've got
your registers mapped,

00:39:52.400 --> 00:39:56.200
you pretty much are just doing reads
and writes straight to those registers.

00:39:56.260 --> 00:39:57.590
That's unique to PCI.

00:39:57.590 --> 00:40:00.400
If you're nubbed,
you're matching against the USB.

00:40:00.440 --> 00:40:03.100
Obviously, you don't get registers to
talk to your USB device.

00:40:03.100 --> 00:40:05.800
You're going to be calling other APIs.

00:40:07.500 --> 00:40:12.400
Also, our provider is responsible for
matching our driver to the hardware.

00:40:12.450 --> 00:40:15.870
If you remember, the IOPCI device nub,
its job in the system is to

00:40:15.960 --> 00:40:17.900
present a piece of hardware.

00:40:17.900 --> 00:40:19.720
It's a proxy for that piece of hardware.

00:40:19.810 --> 00:40:25.120
So its job is to also then
go off and find a driver

00:40:25.120 --> 00:40:25.120
that can drive that hardware.

00:40:25.560 --> 00:40:27.540
So let's talk about
matching a little bit.

00:40:27.580 --> 00:40:32.700
Matching starts off outside of
code in a driver's Info.plist file.

00:40:32.890 --> 00:40:36.090
This is a dictionary,
it's actually an XML file.

00:40:36.150 --> 00:40:39.660
I've presented it here in a slightly
more readable form than XML,

00:40:39.870 --> 00:40:42.770
because otherwise it
wouldn't fit on the slide.

00:40:42.970 --> 00:40:46.370
The idea here is that you basically
have a dictionary of what we

00:40:46.370 --> 00:40:48.020
call I/O Kit personalities.

00:40:48.070 --> 00:40:51.460
This is a property that's at the
top level of your Info.plist file.

00:40:51.560 --> 00:40:53.600
Now, you'll notice it's plural.

00:40:53.920 --> 00:40:57.900
I'm only showing one personality here,
but it is entirely possible for your

00:40:57.900 --> 00:41:00.040
driver to have multiple personalities.

00:41:00.040 --> 00:41:01.360
And what does that mean?

00:41:01.360 --> 00:41:06.190
Well, you could have slightly similar

00:41:06.930 --> 00:41:08.900
"There are a lot of different
hardware that you want to support,

00:41:08.900 --> 00:41:10.900
and they can maybe be
supported by the same driver,

00:41:10.900 --> 00:41:13.900
but you've got to have different
matching information for them.

00:41:13.900 --> 00:41:15.900
Or maybe you want to have
a few different parameters,

00:41:15.900 --> 00:41:20.520
and so you might create a
personality for each of them.

00:41:20.660 --> 00:41:22.990
For our example,
we're just going to have one personality,

00:41:22.990 --> 00:41:23.470
though.

00:41:23.570 --> 00:41:28.400
And Apple Marketing has requested that
we call it Apple PCI Storage Thingy.

00:41:30.670 --> 00:41:35.770
So, I'm getting ahead of myself here.

00:41:35.850 --> 00:41:38.370
So, the name here actually
is completely irrelevant.

00:41:38.550 --> 00:41:40.520
This is just a unique identifier.

00:41:40.550 --> 00:41:43.750
Because it's a dictionary,
each entry has to have a unique name.

00:41:43.890 --> 00:41:46.530
It's not really used by anything.

00:41:48.810 --> 00:41:52.250
The Provider Class:
This tells I/O Kit what

00:41:52.720 --> 00:41:54.890
class you need as a provider.

00:41:55.050 --> 00:41:57.960
Again, you're writing your driver
to make calls down into,

00:41:57.960 --> 00:42:00.620
in our case, PCI,
so it wouldn't work at all if

00:42:00.620 --> 00:42:04.000
our driver somehow magically
got attached to a USB device,

00:42:04.000 --> 00:42:07.340
because the map bar
functions don't exist there.

00:42:07.490 --> 00:42:13.210
So this is basically saying don't
even consider this driver for

00:42:13.210 --> 00:42:13.210
anything other than a PCI device.

00:42:13.730 --> 00:42:16.810
Now the next two properties
are PCI-specific,

00:42:16.810 --> 00:42:19.730
and these are things the PCI-nub is
going to look at to try to figure

00:42:19.730 --> 00:42:21.240
out if your driver is a good match.

00:42:21.430 --> 00:42:25.600
Just a couple random examples here:
I/O PCI match matches you against

00:42:25.600 --> 00:42:28.360
the PCI vendor and device IDs.

00:42:28.600 --> 00:42:31.180
There's a number of properties
you can look up in the PCI family,

00:42:31.180 --> 00:42:35.100
so you can determine if it's
the main ID or the sub-ID.

00:42:35.100 --> 00:42:39.930
You can also use bitwise and
if you want to do a wild mask.

00:42:41.960 --> 00:42:43.980
The idea here is it's
a space-separated list.

00:42:44.220 --> 00:42:47.350
If any of the IDs on that
space-separated list match,

00:42:47.360 --> 00:42:49.320
then it's considered a match.

00:42:49.790 --> 00:42:50.930
PCI Class Match.

00:42:51.070 --> 00:42:53.030
This is similar,
except instead of looking at

00:42:53.030 --> 00:42:55.620
the vendor and device codes,
it's looking at the class code,

00:42:55.620 --> 00:42:57.000
which is a 24-bit quantity.

00:42:57.000 --> 00:42:59.100
Again, it's PCI-specific.

00:42:59.220 --> 00:43:01.930
The general rule, and again,
you have to look at the

00:43:02.020 --> 00:43:05.210
family to know for sure,
but the general rule is if you've

00:43:05.210 --> 00:43:07.870
listed multiple properties,
like these two,

00:43:08.610 --> 00:43:12.770
Both of them must match for the
driver to be considered a match.

00:43:12.820 --> 00:43:17.180
So it's an AND operation between all
the matching criteria you put in there.

00:43:17.260 --> 00:43:21.100
Again, it's dependent on the family,
so look in the documentation for that.

00:43:21.710 --> 00:43:22.690
Probe score.

00:43:22.700 --> 00:43:25.150
This is a little bit under-documented.

00:43:25.280 --> 00:43:29.780
This is a quantity that's used to
sort if you have multiple drivers

00:43:29.940 --> 00:43:31.590
that may have made it this far.

00:43:31.680 --> 00:43:34.960
So if you have multiple drivers
that all make it past the provider

00:43:35.210 --> 00:43:39.110
class criteria and the other
family-specific matching criteria,

00:43:39.110 --> 00:43:42.390
then we've got a multi-way
race we have to resolve.

00:43:42.700 --> 00:43:44.600
So we sort based on probe score.

00:43:44.720 --> 00:43:47.710
So you need to look at the family
documentation to get an idea of

00:43:47.730 --> 00:43:49.590
what probe scores are reasonable.

00:43:49.600 --> 00:43:52.600
1,000 is the default probe score.

00:43:52.600 --> 00:43:57.430
If you have a driver that's
specific to your vendor,

00:44:00.100 --> 00:44:09.450
If you have a vendor-specific
driver or a device-specific

00:44:09.450 --> 00:44:11.290
or device-family-specific,
you're going to want to put a

00:44:11.290 --> 00:44:11.290
higher probe score so that you win
out over a generic device driver.

00:44:13.630 --> 00:44:17.100
You also have to tell
I/O Kit what class to instantiate.

00:44:17.190 --> 00:44:20.530
This is the actual class name
that we're going to pass off into

00:44:20.530 --> 00:44:24.860
the OS Meta Class stuff and say,
"Conjure one of these up." And so after

00:44:24.920 --> 00:44:28.630
we've loaded your KEXT into the kernel,
we'll go and create one of

00:44:28.790 --> 00:44:32.580
these and attach it to the
IOPCI device provider class.

00:44:32.580 --> 00:44:35.190
That's how the whole stacking starts off.

00:44:38.990 --> 00:44:42.200
So, crossing the user-kernel boundary.

00:44:42.230 --> 00:44:46.810
This is actually, in many cases,
not going to be necessary for you to do,

00:44:46.860 --> 00:44:50.230
because if you're writing, in our case,
a blocked storage driver,

00:44:50.400 --> 00:44:53.940
there's really no reason for
us to provide a new mechanism.

00:44:53.980 --> 00:44:57.550
Mac OS X already has perfectly
fine storage APIs for file

00:44:57.620 --> 00:44:59.360
systems to mount and so on.

00:44:59.520 --> 00:45:02.210
So, it doesn't really apply
so much to our example,

00:45:02.330 --> 00:45:06.060
but if you're writing a driver that does
need some kind of a custom interface,

00:45:06.110 --> 00:45:08.680
there's a couple possibilities here.

00:45:10.940 --> 00:45:14.410
So, again,
mass storage and networking is serial.

00:45:14.540 --> 00:45:19.400
All use BSD style,
either sockets or device nodes.

00:45:19.420 --> 00:45:22.010
And then most of the other
families provide other mechanisms

00:45:22.020 --> 00:45:26.260
for getting at devices,
generally I/O user clients.

00:45:26.310 --> 00:45:28.810
But if you want to roll your own,
you can.

00:45:30.940 --> 00:45:33.390
And as I showed you before
on one of the graphics,

00:45:33.390 --> 00:45:36.600
there's two ways to have your app
communicate down to your driver.

00:45:36.750 --> 00:45:38.880
The first way is very I/O control-like.

00:45:39.000 --> 00:45:41.590
It's using the registry
to get and set properties.

00:45:41.720 --> 00:45:44.370
It's...you're going to have
to use the registry to find

00:45:44.370 --> 00:45:45.900
your driver in the first place.

00:45:45.900 --> 00:45:48.200
So you've already gone through...

00:45:48.320 --> 00:45:50.930
90% of what you're going to
have to do to find the device,

00:45:50.930 --> 00:45:54.950
and then you can simply start getting
properties on it or setting it.

00:45:56.360 --> 00:45:58.300
If you need something
that's higher bandwidth,

00:45:58.310 --> 00:46:01.220
you need to move either large
amounts of memory or you need

00:46:01.220 --> 00:46:06.340
to move memory very quickly,
you can use an I/O User-Client subclass.

00:46:07.240 --> 00:46:09.540
Now, why do we call it I/O User-Client?

00:46:09.690 --> 00:46:11.750
I'll show you a graphic in
a second that'll make it

00:46:11.750 --> 00:46:13.000
maybe a little more clear.

00:46:13.130 --> 00:46:17.910
But the idea here is from a
kernel driver perspective,

00:46:18.460 --> 00:46:21.850
You have a client that
lives in the user space.

00:46:22.120 --> 00:46:24.060
That's literally where
the name came from.

00:46:24.060 --> 00:46:27.770
So this is an object that lives
in the kernel that is a proxy

00:46:27.770 --> 00:46:30.200
for some out-of-kernel client.

00:46:32.030 --> 00:46:32.890
They're fairly simple.

00:46:33.010 --> 00:46:36.350
You can write a user client in
just a few dozen lines of code.

00:46:36.470 --> 00:46:38.780
There's an example on the DTS website.

00:46:38.780 --> 00:46:41.210
You can look for,
I believe it's just called

00:46:41.250 --> 00:46:42.900
Simple User Client Example.

00:46:42.900 --> 00:46:44.210
They're very versatile.

00:46:44.220 --> 00:46:45.900
You can do quite a lot with them.

00:46:46.030 --> 00:46:48.720
And they are efficient.

00:46:48.720 --> 00:46:52.660
So it's sometimes hard to look at a
C++ class and get an understanding

00:46:52.930 --> 00:46:56.740
of sort of what's underneath the hood
and know if it's going to be a pig

00:46:56.740 --> 00:46:58.900
or if it's going to be efficient.

00:46:58.900 --> 00:47:01.230
In this case,
we make these very efficient because we

00:47:01.230 --> 00:47:02.900
use them quite a bit in our own code.

00:47:02.900 --> 00:47:05.690
So they have to work well.

00:47:05.980 --> 00:47:11.290
So the basic process is you define a
sort of an indexed array of entry points.

00:47:11.290 --> 00:47:13.960
So you can think of it as
simply numbered entry points.

00:47:14.070 --> 00:47:17.070
And you define them in a header
that's going to be common to both your

00:47:17.070 --> 00:47:19.080
user-space code and your kernel code.

00:47:20.620 --> 00:47:23.980
Then you have an either your
application directly or if you're

00:47:24.080 --> 00:47:27.540
creating a library or a plug-in,
that code creates a stub function for

00:47:27.540 --> 00:47:29.250
each of those numbered entry points.

00:47:29.380 --> 00:47:32.860
And then that's going to call
into an I/O Kit library function

00:47:32.860 --> 00:47:36.620
that basically says call index
number blah on this object.

00:47:36.730 --> 00:47:40.340
On the kernel side,
you create an I/O user client subclass.

00:47:40.450 --> 00:47:43.470
And that's what actually
implements the entry points.

00:47:44.970 --> 00:47:46.930
All right,
there's actually some subtlety here,

00:47:46.930 --> 00:47:49.810
and I'll go through it graphically
again just so you understand.

00:47:49.960 --> 00:47:54.340
But step one,
the application uses the framework

00:47:54.740 --> 00:47:56.720
to locate the thing of interest.

00:47:56.740 --> 00:48:00.360
In this case,
we have properties on a nub.

00:48:02.120 --> 00:48:06.150
Once it's discovered it,
it can then create a direct

00:48:06.180 --> 00:48:09.000
connection to a user client.

00:48:09.110 --> 00:48:13.000
Now you notice that user client was
conjured up as part of this process.

00:48:13.000 --> 00:48:16.000
So what happens is the app
calls I/O Service Open,

00:48:16.200 --> 00:48:18.840
and that basically
will cause your driver,

00:48:18.970 --> 00:48:23.750
if it has a user client defined,
to conjure one of those user clients up.

00:48:24.790 --> 00:48:27.500
And it's very important to
understand is this user client

00:48:27.500 --> 00:48:29.190
is private to your application.

00:48:29.250 --> 00:48:32.080
If there are three apps
all talking to your driver,

00:48:32.140 --> 00:48:35.200
each one will get a private
copy of the user client.

00:48:35.340 --> 00:48:38.290
This is very important
for asset tracking,

00:48:38.290 --> 00:48:41.450
because if you have
multiple I/Os in flight,

00:48:41.450 --> 00:48:46.370
and one of the three apps crashes,
we have to know what I/Os to terminate

00:48:46.440 --> 00:48:48.690
or who to send the response to.

00:48:48.700 --> 00:48:52.200
So each user client
represents one user client.

00:48:52.200 --> 00:48:54.390
And that VINs our custom API.

00:48:56.870 --> 00:49:01.630
Okay, so now if the app crashes,
the user client is notified.

00:49:01.700 --> 00:49:03.750
It discovers that the client,
the thing it's

00:49:03.860 --> 00:49:05.320
representing has gone away.

00:49:05.360 --> 00:49:07.160
Now it's still stacked
there in the kernel.

00:49:07.160 --> 00:49:10.370
It still has this nub open and
potentially has in-flight IOs going.

00:49:10.380 --> 00:49:14.940
So its responsibility is
to clean that mess up.

00:49:15.040 --> 00:49:17.820
It's either got to terminate
the IOs if that's possible,

00:49:17.820 --> 00:49:19.570
or it's got to wait for them to complete.

00:49:19.580 --> 00:49:23.330
It's got to release any in-kernel
resources that are being

00:49:23.330 --> 00:49:24.640
held on that user's behalf.

00:49:25.250 --> 00:49:26.870
This is very important
because if you don't,

00:49:26.900 --> 00:49:30.040
it's possible now for a user
application to cause kernel

00:49:30.100 --> 00:49:31.810
resources to be permanently pinned.

00:49:31.840 --> 00:49:35.240
So the user client must
clean up after itself.

00:49:35.280 --> 00:49:37.370
The idea is this needs to
be completely symmetrical.

00:49:37.450 --> 00:49:39.280
Once it's gone,
it needs to leave no traces.

00:49:42.500 --> 00:49:44.400
So as I said before,
our user client provides a

00:49:44.410 --> 00:49:47.730
custom interface to our drivers,
something the I/O Kit doesn't

00:49:47.730 --> 00:49:49.510
provide by default.

00:49:49.600 --> 00:49:53.560
The problem with this is,
it also provides our custom

00:49:53.690 --> 00:49:55.510
APIs to any software.

00:49:57.520 --> 00:49:58.860
This is very, very important.

00:49:58.970 --> 00:50:02.220
When you're designing your user client,
remember I said all code running

00:50:02.220 --> 00:50:03.480
in the kernel is trusted.

00:50:03.620 --> 00:50:07.400
Well, the user client is a bridge
between the user and kernel space.

00:50:07.420 --> 00:50:12.180
We trust your code in the kernel,
therefore it needs to be trustworthy.

00:50:13.220 --> 00:50:17.070
So the user-client subclass must
defend against inappropriate access.

00:50:17.100 --> 00:50:18.700
Now there's some very basic things.

00:50:18.700 --> 00:50:21.250
This is very much like what
you would think of when

00:50:21.250 --> 00:50:23.700
writing a set UID application.

00:50:23.810 --> 00:50:26.600
So first off,
make sure your API is minimal.

00:50:26.660 --> 00:50:28.780
Don't implement more than you need to.

00:50:28.900 --> 00:50:33.600
Don't write "dev kmim" in your
user-client just because you can.

00:50:33.680 --> 00:50:34.120
Okay?

00:50:34.120 --> 00:50:37.730
That would be very bad and it
would not serve your users.

00:50:39.690 --> 00:50:40.930
Don't receive kernel pointers.

00:50:41.140 --> 00:50:45.020
You cannot trust a pointer
coming in from user-space in an

00:50:45.020 --> 00:50:46.470
attempt to reference kernel code.

00:50:46.530 --> 00:50:50.470
So, for example, if you wanted to have an
API that handed a pointer,

00:50:50.570 --> 00:50:54.340
a kernel address out to user-space,
and then later let it

00:50:54.400 --> 00:50:57.150
send it back to you,
you cannot dereference that pointer.

00:50:57.200 --> 00:50:58.370
You don't know if it's still valid.

00:50:58.460 --> 00:51:00.800
You don't know if it's
been modified by the user.

00:51:00.910 --> 00:51:05.410
So you would want to use a hash table or
some other mechanism to make sure that

00:51:05.410 --> 00:51:08.140
you can validate that address yourself.

00:51:08.420 --> 00:51:10.360
Invalidate the client credentials.

00:51:10.510 --> 00:51:13.660
It's possible for you to determine
if the client is a GUI session.

00:51:13.660 --> 00:51:16.970
It's possible to determine if
it's privileged or an admin user.

00:51:17.040 --> 00:51:18.750
There are a few APIs for that.

00:51:18.860 --> 00:51:26.120
So if you can restrict the users that
would be able to access your device,

00:51:26.120 --> 00:51:27.200
do that.

00:51:27.200 --> 00:51:30.690
But please, please, please,
if you're writing user-client,

00:51:30.690 --> 00:51:30.690
think about this.

00:51:30.690 --> 00:51:30.690
It's very important.

00:51:33.330 --> 00:51:34.140
Okay, thank you very much.

00:51:34.210 --> 00:51:37.690
With that, I'd like to hand the
stage over to Nik Gervae.

00:51:37.800 --> 00:51:41.000
He's going to come up and talk
about text management now.

00:51:51.300 --> 00:51:51.720
Is the mic on?

00:51:51.740 --> 00:51:52.770
Yes, it is now.

00:51:52.800 --> 00:51:53.370
All right.

00:51:53.500 --> 00:51:56.140
So Dean talked about what you're
going to do to build a KEXT.

00:51:56.140 --> 00:51:59.580
I'm going to talk to you about how
you deploy it and the tools you use.

00:51:59.580 --> 00:52:01.720
So first off, what is a KEXT?

00:52:01.740 --> 00:52:04.260
It's basically a bundle,
and it is the plug-in

00:52:04.360 --> 00:52:05.500
format for a kernel.

00:52:05.500 --> 00:52:10.840
It is, at core,
a relocatable object file, unlinked yet.

00:52:10.860 --> 00:52:14.260
It's packaged in a bundle
directory with an info dictionary,

00:52:14.260 --> 00:52:16.850
and that's pretty much
all that a KEXT is,

00:52:16.860 --> 00:52:19.160
is an info dictionary and a binary.

00:52:20.070 --> 00:52:23.920
The info dictionary identifies the
KEXT in version by CFBundle identifier

00:52:23.920 --> 00:52:27.120
and lists the matching
personalities as Dean covered.

00:52:27.120 --> 00:52:31.780
Those are used to match I-O kit
drivers and load them into the kernel.

00:52:31.780 --> 00:52:34.270
The other kinds of KEXTs are
loaded via different mechanisms.

00:52:34.280 --> 00:52:36.860
It also lists libraries needed.

00:52:36.860 --> 00:52:38.130
We haven't covered that so far.

00:52:38.140 --> 00:52:41.190
Most applications,
you'll list the libraries in Xcode.

00:52:41.200 --> 00:52:43.420
They get linked when you build it.

00:52:43.520 --> 00:52:45.150
That's not how things work with KEXTs.

00:52:45.160 --> 00:52:47.020
Those get linked at load time.

00:52:47.020 --> 00:52:49.500
KEXTs themselves can serve as libraries.

00:52:49.500 --> 00:52:51.110
In fact,
all of those families Dean listed

00:52:51.200 --> 00:52:53.330
earlier are loadable KEXTs.

00:52:53.380 --> 00:52:58.050
And even the kernel itself is
represented as a set of library KEXTs.

00:52:58.130 --> 00:53:01.600
The kernel itself lives
in slash as Mach kernel,

00:53:01.600 --> 00:53:04.700
but there are a bunch of pseudo KEXTs,
as we call them.

00:53:04.700 --> 00:53:08.430
They don't have an object file,
but they do have version

00:53:08.430 --> 00:53:09.760
information and compatibility.

00:53:12.200 --> 00:53:16.050
The dependencies that you declare
go under the OS Bundle Libraries

00:53:16.050 --> 00:53:17.970
property in your info dictionary.

00:53:18.150 --> 00:53:22.500
Each key is a bundle identifier,
such as com.apple.kpi Mach,

00:53:22.500 --> 00:53:24.050
if you need to use Mach resources.

00:53:24.180 --> 00:53:25.440
And the values are version strings.

00:53:25.440 --> 00:53:30.210
This is basically whatever version you
need or any compatible later version.

00:53:30.630 --> 00:53:37.590
For kernel components,
you use com.apple.kpi.mocbsd/libkern

00:53:37.590 --> 00:53:38.720
or I/O Kit.

00:53:38.720 --> 00:53:43.710
If you need compatibility
with pre-Tiger systems,

00:53:43.710 --> 00:53:43.710
you can use...

00:53:44.640 --> 00:53:49.180
:com.apple.kernel and any of those.

00:53:49.180 --> 00:53:50.100
And I've got something on my
screen that I didn't want.

00:53:50.100 --> 00:53:51.350
There we go.

00:53:51.360 --> 00:53:52.900
You should not mix those.

00:53:52.930 --> 00:53:54.710
KPI is a new mechanism as of Tiger.

00:53:54.820 --> 00:53:56.710
.kernel is the older mechanism.

00:53:56.860 --> 00:53:57.500
Don't mix them.

00:53:57.610 --> 00:54:00.600
It may work,
but you will run into problems.

00:54:00.620 --> 00:54:03.470
And also,
you can use the new keckslibs program

00:54:04.050 --> 00:54:06.580
to find any declarations you need.

00:54:06.600 --> 00:54:10.230
As I mentioned before,
kecks aren't linked when you build them.

00:54:10.350 --> 00:54:14.360
You won't know until you try to
load it which families you need.

00:54:14.390 --> 00:54:17.180
But if you run keckslibs,
it will actually tell you,

00:54:17.430 --> 00:54:19.750
and you can even ask it
to present that as XML.

00:54:19.750 --> 00:54:22.160
You can just paste it into your project.

00:54:23.100 --> 00:54:25.680
The tools that you
actually use are these:

00:54:25.680 --> 00:54:28.300
kextload is what you'll
use during development,

00:54:28.420 --> 00:54:31.110
kextunload when you're done,
you can unload your KEXT.

00:54:31.270 --> 00:54:35.000
It is the standard load and
unload API for non-I/O Kit KEXTs.

00:54:35.000 --> 00:54:38.280
So you guys are only going to be using
this when you're doing development,

00:54:38.280 --> 00:54:38.960
basically.

00:54:39.080 --> 00:54:40.200
Another program is kextee.

00:54:40.200 --> 00:54:42.000
This is a continuously running daemon.

00:54:42.000 --> 00:54:44.590
It loads drivers on
demand from the kernel,

00:54:44.780 --> 00:54:48.000
and it is the standard load
mechanism for I/O Kit KEXTs.

00:54:48.000 --> 00:54:50.990
New in Leopard is the kextlabs
program that I just mentioned.

00:54:50.990 --> 00:54:53.980
Once you've built your KEXT,
you can just run this program on it.

00:54:54.070 --> 00:54:57.140
It will tell you what libraries
you need to declare in order

00:54:57.160 --> 00:54:58.960
to then have it load properly.

00:54:59.410 --> 00:55:05.000
KextStat lists running KEXTs in
the kernel by bundle ID and version

00:55:05.390 --> 00:55:07.000
with dependency information as well.

00:55:07.000 --> 00:55:10.300
It will actually show you what
KEXTs your KEXT is linked against.

00:55:10.300 --> 00:55:13.420
Some advanced programs that
we use for system optimization

00:55:13.420 --> 00:55:15.300
are kextcache and mkextunpack.

00:55:15.300 --> 00:55:18.300
You probably won't need to
worry about those at first.

00:55:18.310 --> 00:55:21.300
And finally, another new feature in
Leopard is kextfind.

00:55:21.300 --> 00:55:24.300
You can ask it to find
KEXTs with a given bundle ID,

00:55:24.300 --> 00:55:28.300
with various properties,
any KEXTs that have problems.

00:55:28.300 --> 00:55:31.290
like find command for
the extensions folder.

00:55:33.470 --> 00:55:36.880
When you use kextload,
this is used as both a development

00:55:36.880 --> 00:55:38.370
and a diagnostic tool at present.

00:55:38.400 --> 00:55:42.090
While you're using development,
doing it for development,

00:55:42.090 --> 00:55:44.460
you'll use kextload
manually to load your KEXT.

00:55:44.460 --> 00:55:48.740
If you have any problems,
you run kextload-nt.

00:55:48.760 --> 00:55:51.960
I can't tell you how many times
people within Apple call me and say,

00:55:51.960 --> 00:55:53.580
I'm having a problem with my KEXT.

00:55:53.580 --> 00:55:54.100
It won't load.

00:55:54.100 --> 00:55:57.030
I say, run kextload-nt, and they go, oh,
there it is.

00:55:57.140 --> 00:55:57.750
There's my problem.

00:55:58.660 --> 00:56:01.330
As a deployment tool,
you're only going to need to

00:56:01.390 --> 00:56:04.680
use this with non-IO kit KEXTs,
usually via an exec call.

00:56:04.680 --> 00:56:07.050
Some running application
will set up the command line

00:56:07.050 --> 00:56:08.520
arguments and then do an exec.

00:56:08.520 --> 00:56:11.610
You should avoid using dash-t or
other interactive and development

00:56:11.610 --> 00:56:13.250
options when you use it this way.

00:56:13.800 --> 00:56:16.320
Basically,
only use the dash-b option for bundle ID,

00:56:16.320 --> 00:56:20.400
dash-d to list an explicit dependency,
and dash-i to specify an alternative

00:56:20.410 --> 00:56:21.940
directory for dependencies.

00:56:25.040 --> 00:56:28.120
Now, as far as installing
kernel extensions go,

00:56:28.140 --> 00:56:31.240
keep in mind that kecks are much
more sensitive than other software.

00:56:31.320 --> 00:56:33.900
They are loaded into the kernel
environment and can pretty

00:56:33.900 --> 00:56:35.360
much do anything they want.

00:56:35.390 --> 00:56:38.400
So when you install your kecks,
it has to be installed as

00:56:38.400 --> 00:56:41.080
owned by a root and wheel,
and it must not be

00:56:41.080 --> 00:56:42.760
writable by group another.

00:56:42.770 --> 00:56:45.460
You should also make sure that your
kecks get installed atomically.

00:56:45.470 --> 00:56:48.350
You don't want a partially written
kecks even being considered

00:56:48.350 --> 00:56:49.660
for loading into the kernel.

00:56:49.690 --> 00:56:52.280
So make sure you copy the whole
thing to a temporary directory

00:56:52.280 --> 00:56:54.580
on the boot volume first,
then change its owner group

00:56:54.660 --> 00:56:57.280
of permissions as needed,
and move it atomically

00:56:57.320 --> 00:56:59.160
into the extensions folder.

00:56:59.200 --> 00:57:02.860
When you're done,
you can run a touch command on the

00:57:02.880 --> 00:57:06.680
system library extensions folder and
send a SIGHUB to kexty if it's running,

00:57:06.680 --> 00:57:08.000
and you should check for that.

00:57:08.040 --> 00:57:11.520
That will cause all of the caches
that we build to be updated.

00:57:11.530 --> 00:57:13.300
Don't go poking around
for caches yourself.

00:57:13.420 --> 00:57:14.180
Don't look for them.

00:57:14.270 --> 00:57:20.420
They do move around and see the technical
QA 1319 for more details and specifically

00:57:20.440 --> 00:57:23.250
for compatibility information
with older versions of the OS.

00:57:25.440 --> 00:57:28.290
And now that we've shot a fire
hose of information at you,

00:57:28.440 --> 00:57:31.510
you can go look for these other
titles on the ADC website.

00:57:31.700 --> 00:57:33.060
Dean's already mentioned a few of these.

00:57:33.060 --> 00:57:37.060
We've got the Kernel Extensions Concepts,
Hello Kernel, Hello I/O Kit,

00:57:37.100 --> 00:57:39.500
and Hello Debugger,
which walks you through doing

00:57:39.500 --> 00:57:41.300
a two-machine debug session.

00:57:41.470 --> 00:57:44.880
The I/O Kit Fundamentals document,
which is more conceptual,

00:57:44.920 --> 00:57:49.000
and then related sessions today,
which include the following sessions,

00:57:49.080 --> 00:57:52.590
64-bit I/O Kit Drivers,
the I/O Technologies Overview,

00:57:52.590 --> 00:57:54.170
and our lab later this week.

00:57:54.250 --> 00:57:55.300
There we go.
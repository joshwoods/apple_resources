WEBVTT

00:00:10.600 --> 00:00:14.460
Hello and welcome to session 409,
I/O Technologies,

00:00:14.460 --> 00:00:17.280
Best Practices for Driver Development.

00:00:17.450 --> 00:00:20.260
We will be talking to you today,
we'll have four speakers today

00:00:20.260 --> 00:00:22.680
talking about four different
areas of driver development,

00:00:22.840 --> 00:00:24.970
so let's get started.

00:00:25.090 --> 00:00:29.370
Here are the four speakers and
the areas we will be discussing.

00:00:30.160 --> 00:00:31.300
My name is Rhoaads Hollowell.

00:00:31.300 --> 00:00:35.810
I'm with the USB software team,
the USB technology team,

00:00:35.810 --> 00:00:39.890
and I'll be talking about
what's new with USB.

00:00:41.020 --> 00:00:45.110
So the main issue that we have,
or the main thing that's

00:00:45.110 --> 00:00:48.380
new with USB these days,
of course, is that we've now switched

00:00:48.690 --> 00:00:52.940
to the Intel I/O chipsets
in all of our products,

00:00:52.940 --> 00:00:57.290
which means we have two
different USB controllers

00:00:57.340 --> 00:00:58.560
than we've had historically.

00:00:58.560 --> 00:01:03.200
We have Intel's high-speed controller,
or their EHCI controller,

00:01:03.200 --> 00:01:05.810
and we have Intel's
full-speed controller,

00:01:05.810 --> 00:01:07.460
the UHCI controller.

00:01:07.460 --> 00:01:13.110
We also, new with the Mac Pro,
have 64-bit systems that are slightly

00:01:13.110 --> 00:01:18.110
different than historical 64-bit systems,
and so I'll talk a little bit about that.

00:01:18.620 --> 00:01:21.340
First of all, I want to talk about the
Intel EHCI controller,

00:01:21.340 --> 00:01:23.080
their new high-speed controller.

00:01:23.320 --> 00:01:27.770
The use of this controller should be
completely transparent to both driver

00:01:27.770 --> 00:01:31.810
writers and device manufacturers.

00:01:32.190 --> 00:01:37.060
The existing Apple USB/EHCI controller
driver that we've had for quite

00:01:37.060 --> 00:01:43.490
a number of years now works great
with this new Intel architecture.

00:01:43.820 --> 00:01:47.810
Things that we've seen that might
affect driver writers slightly is,

00:01:47.910 --> 00:01:53.010
for example, in isochronous I/O,
you may not be able to send out

00:01:53.100 --> 00:01:58.610
isochronous data packets in frames that
are too close to the current frame.

00:01:58.790 --> 00:02:03.580
That number has always been an issue
with isochronous driver writers.

00:02:03.700 --> 00:02:07.700
The number may be two
milliseconds into the future,

00:02:07.700 --> 00:02:09.700
it may be four milliseconds
into the future,

00:02:09.700 --> 00:02:12.890
so your driver just has to
be aware that when it begins

00:02:12.890 --> 00:02:16.690
an isochronous data stream,
the first so many frames may

00:02:16.870 --> 00:02:21.140
or may not go out on the bus,
and you should be able to deal

00:02:21.160 --> 00:02:23.700
with that without any issues.

00:02:23.700 --> 00:02:26.990
Other than that,
there are very few issues that

00:02:26.990 --> 00:02:31.470
we've seen with drivers that,
you know, some slight timing issues as

00:02:31.560 --> 00:02:35.700
far as how much data can go in a
millisecond and that kind of thing.

00:02:37.030 --> 00:02:41.070
The Intel Full Speed Controller,
the UHCI controller, is also new to us.

00:02:41.070 --> 00:02:44.390
And although this particular
controller has been around at

00:02:44.510 --> 00:02:48.340
Intel for quite a long time,
the Apple Mac OS X driver for the

00:02:48.460 --> 00:02:50.900
UHCI controller is fairly new.

00:02:50.900 --> 00:02:57.360
We started shipping this driver
in 2005 with pre-Intel systems

00:02:57.360 --> 00:03:01.770
to support UHCI PCI cards,
and now with the Intel systems,

00:03:01.960 --> 00:03:04.820
we of course have to support
it in all of the new hardware.

00:03:04.900 --> 00:03:10.020
One of the issues that driver writers
might see is that you might get slightly

00:03:10.020 --> 00:03:14.900
different error messages returned
than you did in the old OHCI days.

00:03:14.900 --> 00:03:19.160
This comes from the fact that the
UHCI controller gives the system

00:03:19.160 --> 00:03:23.340
software different information
than an OHCI controller does,

00:03:23.340 --> 00:03:27.720
and so we may end up taking that
information and we do our best to map it

00:03:27.720 --> 00:03:32.900
to the same types of error messages in
the case of errors as we did with OHCI,

00:03:32.900 --> 00:03:36.780
but this is not always possible
because we don't always have

00:03:36.780 --> 00:03:38.900
the same amount of information.

00:03:38.990 --> 00:03:42.900
Now another issue that affects
people with the UHCI controller

00:03:42.900 --> 00:03:46.900
is that the UHCI controller,
unlike an OHCI controller

00:03:46.900 --> 00:03:50.840
or an EHCI controller,
is not allowed to have a data buffer

00:03:50.900 --> 00:03:54.900
for any packet across a page boundary.

00:03:54.900 --> 00:03:58.930
So this means that, for example,
if the max packet size

00:03:58.930 --> 00:04:00.900
of a device is 64 bytes,
which is typical,

00:04:00.940 --> 00:04:06.900
and a particular 64 byte data
packet would cross a page boundary,

00:04:06.900 --> 00:04:11.320
then the system software has to
actually copy that 64 bytes before

00:04:11.320 --> 00:04:14.260
it DMAs it to the controller,
or before it gives the DMA address

00:04:14.300 --> 00:04:17.890
to the controller for sending
or receiving the data buffer.

00:04:17.990 --> 00:04:21.570
Now the host controller driver
handles this type of thing

00:04:21.620 --> 00:04:23.900
transparently for your driver.

00:04:23.910 --> 00:04:25.900
You should not have to
deal with it at all.

00:04:25.900 --> 00:04:28.900
You shouldn't even know it's happening.

00:04:28.900 --> 00:04:34.180
What this does mean is that you may
not change the data in your data

00:04:34.180 --> 00:04:39.750
buffer after making the I/O call
and before that call returns.

00:04:39.900 --> 00:04:43.890
So, for example,
if you have an outgoing I/O packet

00:04:43.890 --> 00:04:47.760
or an outgoing I/O buffer and
you were sort of cheating,

00:04:47.980 --> 00:04:51.220
if you will,
and filling in the data closer to

00:04:51.280 --> 00:04:54.830
the time you expected it to go out,
that's no longer acceptable.

00:04:54.950 --> 00:04:56.900
If you are sort of cheating
and looking at a data buffer,

00:04:56.980 --> 00:05:02.180
expecting data to come in,
it may or may not all be

00:05:02.360 --> 00:05:06.880
there when you expect it to,
because we may have to be copying the

00:05:06.880 --> 00:05:09.880
64 byte data packet behind your back.

00:05:09.910 --> 00:05:14.900
So don't change the data in the
buffer after you make the I/O call.

00:05:15.190 --> 00:05:18.690
Now, for low-latency isochronous N,
where we do have people that

00:05:18.690 --> 00:05:22.830
sort of expect to be able to see
their data in a real-time thread

00:05:22.830 --> 00:05:26.680
before they get the callback,
we do copy the data before we

00:05:26.680 --> 00:05:32.340
update the status in the frame,
in the isochronous frame structure.

00:05:32.420 --> 00:05:33.830
And so that is still the case.

00:05:33.830 --> 00:05:38.290
If you wait until that isochronous
frame structure status is updated

00:05:38.360 --> 00:05:43.280
before you look at the data,
those data bytes will be, in fact,

00:05:43.280 --> 00:05:46.200
there when you look at them.

00:05:47.310 --> 00:05:48.750
64-bit system support.

00:05:48.820 --> 00:05:53.000
Now, even though the kernel is a 32-bit
task and your kernel extension,

00:05:53.000 --> 00:05:55.510
if you have a USB driver
that's a kernel extension,

00:05:55.640 --> 00:05:59.970
is also a 32-bit task,
it may be running on a 64-bit system

00:06:00.300 --> 00:06:10.040
where the memory buffer itself is mapped
into a physical memory space that is

00:06:10.040 --> 00:06:10.040
greater than a 32-bit address can handle.

00:06:10.480 --> 00:06:14.690
The EHCI controller is
able to handle these data,

00:06:14.800 --> 00:06:18.590
these physical memory addresses,
these 64-bit memory addresses,

00:06:18.620 --> 00:06:22.780
transparently,
completely capable of doing 64-bit DMA.

00:06:22.880 --> 00:06:24.090
So that's not a problem.

00:06:24.390 --> 00:06:27.540
However,
both the UHCI and the OHCI controllers

00:06:27.590 --> 00:06:32.960
are not capable of handling more than
32 bits of physical address space.

00:06:33.060 --> 00:06:36.780
So in this situation,
the host controller driver,

00:06:36.900 --> 00:06:41.890
the I/O USB family software,
will see that that's the case and

00:06:41.890 --> 00:06:45.080
will end up copying the data buffer.

00:06:45.650 --> 00:06:53.110
The I/O Kit is a new feature that
allows you to change the driver's data

00:06:53.470 --> 00:06:58.040
before or after the I/O as appropriate.

00:06:58.040 --> 00:06:58.040
So again,
what this means is your driver should

00:06:58.040 --> 00:06:58.040
not change the data in the data
buffer while the I/O is in flight.

00:06:58.430 --> 00:07:02.770
This is a case where low latency
isochronous does need to pay attention

00:07:02.780 --> 00:07:08.110
because our low latency API gives
you the ability to look at your data

00:07:08.590 --> 00:07:10.620
once we've updated the frame status.

00:07:10.750 --> 00:07:14.140
And of course,
that's going to be very difficult

00:07:14.330 --> 00:07:18.840
if the data is in 64-bit memory,
the physical address is 64 bits,

00:07:18.950 --> 00:07:20.560
and we have to do the copying.

00:07:20.670 --> 00:07:25.860
So what we've done is we've added a new
API for those of you who are doing low

00:07:25.860 --> 00:07:28.960
latency isochronous in transactions.

00:07:29.000 --> 00:07:32.500
And it's called
GetLowLatencyOptionsAndPhysicalMask.

00:07:32.560 --> 00:07:40.030
This allows you to retrieve a physical
mask for use with I/O Kit's new call in

00:07:40.030 --> 00:07:44.890
task with physical mask that will say,
"Hey, I want to make sure that my data

00:07:45.030 --> 00:07:50.130
buffer is allocated in physical memory
whose address is lower than 32 bits."

00:07:50.330 --> 00:07:53.190
It also allows you to
retrieve option bits.

00:07:53.200 --> 00:07:57.910
The only one that is actually
relevant in this case is physically

00:07:57.990 --> 00:08:02.310
contiguous because on some controllers,
for example, the UHCI controller,

00:08:02.370 --> 00:08:05.790
you also want to allocate your
memory as physical contiguous.

00:08:05.860 --> 00:08:11.440
We had a property-based mechanism
for doing that in the past,

00:08:11.440 --> 00:08:15.790
and we've now rolled that into the
same API so that you can just with this

00:08:15.790 --> 00:08:21.270
one call retrieve from the controller
the option bits and physical mask that

00:08:21.270 --> 00:08:25.530
is necessary for that controller to
function properly for low-latency,

00:08:25.530 --> 00:08:27.260
isochronous input buffers.

00:08:27.300 --> 00:08:34.420
And I will now turn it over to Rob,
who will talk about HID Manager.

00:08:40.380 --> 00:08:41.480
Thanks, Rhoaads.

00:08:41.510 --> 00:08:44.540
I'm Rob Yepez with the I/O Kit team,
and I'm primarily responsible

00:08:44.540 --> 00:08:47.900
for the HID Manager in Mac OS X.

00:08:47.900 --> 00:08:50.850
Today I'm just going to talk
about what's new in HID,

00:08:50.920 --> 00:08:54.990
create a new HID Manager API,
and talk a little bit about the 64-bit

00:08:54.990 --> 00:08:57.570
support that we've added in Leopard.

00:08:58.600 --> 00:09:01.740
So first off,
I'll start by discussing the past issues

00:09:01.740 --> 00:09:04.420
that we've had with the HID Manager.

00:09:04.610 --> 00:09:06.910
The old API used the
CFPlugin architecture,

00:09:06.910 --> 00:09:09.920
which was a little bit confusing
for some of our developers.

00:09:09.930 --> 00:09:12.820
It also required a working
knowledge of the I/O Kit APIs,

00:09:12.820 --> 00:09:17.100
and you need to use these APIs for
device discovery and removal and whatnot.

00:09:17.100 --> 00:09:22.510
It also required the developers to
manage all aspects of the HID objects.

00:09:22.520 --> 00:09:26.330
So you had to basically take
care of storing them and

00:09:26.400 --> 00:09:28.980
keeping track of everything
associated with the HID objects,

00:09:29.010 --> 00:09:33.100
such as the transactions, the queues,
the elements, whatever.

00:09:33.100 --> 00:09:37.090
And the other past issue we've
had is the inconsistencies with

00:09:37.250 --> 00:09:39.560
acquiring the device properties.

00:09:39.560 --> 00:09:41.760
With some properties,
you'd get them from the plugin,

00:09:41.760 --> 00:09:44.060
and other properties you'd
get from the I/O registry.

00:09:44.060 --> 00:09:48.000
So we're kind of trying to
centralize that in the newer API.

00:09:48.020 --> 00:09:51.720
And also, the way we pass the HID events
is a little confusing.

00:09:51.720 --> 00:09:54.980
We use the really big,
massive structure to pass the events

00:09:55.340 --> 00:10:00.180
that sometimes either had a 32-bit
value or a data value on there.

00:10:00.180 --> 00:10:03.160
And it was kind of hard to decipher
what value was actually being

00:10:03.160 --> 00:10:04.670
passed in that particular event.

00:10:07.340 --> 00:10:10.440
So here's the new HID Manager API.

00:10:10.440 --> 00:10:14.560
What we've done here is we've pretty
much based the API on CF-type objects.

00:10:14.560 --> 00:10:18.120
And what we gain for free here is
reference counting and the ability to

00:10:18.120 --> 00:10:20.560
store these in CF collection objects.

00:10:20.560 --> 00:10:23.850
The new objects that we've
created are the I/O HID Manager,

00:10:23.850 --> 00:10:28.050
I/O HID Element, and the I/O HID Value.

00:10:28.060 --> 00:10:31.360
We also have newer versions of
the old APIs we had in the past,

00:10:31.400 --> 00:10:35.480
so I/O HID Device, I/O HID Queue,
and I/O HID Transaction.

00:10:35.520 --> 00:10:38.510
The advantage of doing all this work
is we're able to clean up the API a

00:10:38.510 --> 00:10:43.990
little bit and shield the developer
from using any unnecessary APIs.

00:10:45.210 --> 00:10:49.260
So this kind of gives you a brief
layout of the new HitManager API.

00:10:49.550 --> 00:10:52.230
And what you see here is the first
thing you'd really want to talk

00:10:52.230 --> 00:10:53.960
to you is the I/O HitManager.

00:10:53.960 --> 00:10:56.000
And then if you really need to,
you can talk to the

00:10:56.000 --> 00:10:58.650
I/O HitDevice and I/O HitElement,
but they're not really required.

00:10:58.660 --> 00:11:00.820
And of course,
the optional objects here are the

00:11:00.820 --> 00:11:03.880
I/O HitQueue and the I/O HitTransaction.

00:11:05.800 --> 00:11:08.200
So let's talk about the I/O Hit Manager.

00:11:08.360 --> 00:11:10.680
This is an entirely
new object in Leopard.

00:11:10.680 --> 00:11:13.010
And what this does is it
handles most aspects of your

00:11:13.010 --> 00:11:14.680
device and queue management.

00:11:14.680 --> 00:11:16.920
So it will do everything for you.

00:11:16.970 --> 00:11:19.710
Kind of nice global interaction
with your Hit devices.

00:11:19.740 --> 00:11:23.610
So this is your single endpoint to
communicate with all your devices.

00:11:23.740 --> 00:11:25.850
And what this does is it
sets up your device discovery

00:11:26.400 --> 00:11:28.300
and receiving input events.

00:11:28.300 --> 00:11:32.910
So what we've done here is you can
start beginning to receive input

00:11:32.910 --> 00:11:35.360
events in only five API methods.

00:11:37.130 --> 00:11:41.000
This is kind of a brief example
of how to use the I/O Hit Manager.

00:11:41.030 --> 00:11:44.430
What we're doing here is we
first create the I/O Hit Manager.

00:11:44.440 --> 00:11:47.780
We don't have any options yet,
but we will in the future.

00:11:47.840 --> 00:11:50.910
And after you've created the Hit Manager,
we go ahead and open the

00:11:50.910 --> 00:11:52.570
Hit Manager for communication.

00:11:52.700 --> 00:11:57.210
What we do here is you can also pass
the KIOHitOptionsSees option bit here,

00:11:57.210 --> 00:12:00.780
and this will give you exclusive
access to the devices that

00:12:00.780 --> 00:12:02.690
you're communicating with.

00:12:02.690 --> 00:12:05.960
So if you wanted to seize the mouse
or the keyboard from the system.

00:12:08.000 --> 00:12:11.650
After you've opened the HID Manager,
let's go ahead and set up a matching

00:12:11.650 --> 00:12:14.760
dictionary for the devices that we're
actually interested in talking to.

00:12:14.810 --> 00:12:17.470
For this example,
we're going to try to register

00:12:17.470 --> 00:12:18.860
interest in joysticks.

00:12:19.040 --> 00:12:22.520
So what we do is we create the
matching dictionary using CFDictionary,

00:12:22.520 --> 00:12:23.800
create mutable.

00:12:23.860 --> 00:12:27.280
Go ahead and set up the CFNumbers for
the usage page and usage.

00:12:27.430 --> 00:12:31.210
In this case,
the usage page is generic desktop.

00:12:31.280 --> 00:12:34.230
The usage is joystick.

00:12:35.390 --> 00:12:36.990
Once we've done that,
we go ahead and set the

00:12:36.990 --> 00:12:39.740
values into the dictionary.

00:12:39.820 --> 00:12:42.450
And after we've done that,
we make a call to I/O Hit Manager,

00:12:42.450 --> 00:12:43.780
Set Device Matching.

00:12:43.860 --> 00:12:45.410
Now,
if we're interested in multiple devices,

00:12:45.410 --> 00:12:48.380
we can use I/O Hit Manager,
Set Device Matching Multiple.

00:12:48.420 --> 00:12:52.180
And what that does is it takes
in a CFArray of CFDictionary's.

00:12:52.240 --> 00:12:56.610
And so you can use that to set up
interest in multiple device types.

00:12:59.110 --> 00:13:01.460
So after we've done that,
let's go ahead and register a

00:13:01.520 --> 00:13:02.750
callback for device matching.

00:13:02.760 --> 00:13:06.150
And so this is a callback that's
used to notify us any time a device

00:13:06.180 --> 00:13:09.640
matching our profile enters the system.

00:13:09.690 --> 00:13:11.660
We also register the
input value callback,

00:13:11.740 --> 00:13:14.730
and this is for the events that
are being received from the device.

00:13:15.030 --> 00:13:16.930
And let's go ahead and schedule
this with the run loop.

00:13:16.980 --> 00:13:19.390
And in this example,
we're just using the current

00:13:19.470 --> 00:13:21.220
run loop with the default mode.

00:13:21.300 --> 00:13:24.620
And if you look at the end,
we're calling CF run loop run.

00:13:24.880 --> 00:13:27.680
This may not be necessary in
Cocoa or Carbon applications,

00:13:27.730 --> 00:13:31.630
But if you're doing a regular task,
this might be useful for you.

00:13:33.200 --> 00:13:36.790
And for the input value callback,
we just receive the event here.

00:13:36.800 --> 00:13:38.300
We're just checking to
see if it's not null,

00:13:38.300 --> 00:13:39.960
and we go ahead and call processValue.

00:13:39.960 --> 00:13:44.650
And this is a method we'll discuss a
little bit later in the presentation.

00:13:46.720 --> 00:13:50.480
The next object is I/O Hit Device,
and this is basically a newer version

00:13:50.480 --> 00:13:54.130
of the old API we had in the past,
not really required.

00:13:54.430 --> 00:13:57.710
And what this does is it provides you
similar functionality to the older API,

00:13:57.710 --> 00:14:01.240
so you can use this to set and get
element values and obtain input

00:14:01.670 --> 00:14:05.280
reports and set and get reports.

00:14:05.480 --> 00:14:07.600
We've also added
additional functionality.

00:14:07.600 --> 00:14:10.980
We allow you to kind of store your
own application-specific properties,

00:14:10.980 --> 00:14:13.240
and this is useful for
you to maintain states.

00:14:13.250 --> 00:14:15.720
Instead of having to create
objects that wrap around this,

00:14:15.740 --> 00:14:19.410
you can just use this object directly.

00:14:19.600 --> 00:14:22.910
We also allow you to set up and
register for simple input events.

00:14:22.910 --> 00:14:25.050
And so what this does is
eliminates the need for you

00:14:25.050 --> 00:14:26.830
to use a queue in most cases.

00:14:26.930 --> 00:14:31.540
Now we do limit the objects that
we enqueue here to those that are

00:14:31.540 --> 00:14:34.300
smaller than or the size of CFindex.

00:14:34.380 --> 00:14:37.760
And from previous presentations,
CFindex is either 32 bits

00:14:37.760 --> 00:14:41.700
or 64 bits depending on what
architecture you're compiling for.

00:14:43.880 --> 00:14:48.290
Now, there are some issues that you need
to watch out for with I/O Kit device.

00:14:48.420 --> 00:14:51.530
First of which,
the differences between input

00:14:51.590 --> 00:14:53.820
report callback and get report.

00:14:54.140 --> 00:14:57.680
Now, you'd use the input report
callback to get interrupt-driven

00:14:57.680 --> 00:15:00.040
input reports from the device.

00:15:00.170 --> 00:15:03.120
I/O Kit device get report

00:15:04.340 --> 00:15:06.870
can be used as well,
but this issues control requests

00:15:06.930 --> 00:15:08.250
for a particular report.

00:15:08.490 --> 00:15:10.590
The thing you've got to watch
out for is that this should

00:15:10.640 --> 00:15:13.700
be supported by a device,
but we've seen in the past is that

00:15:13.700 --> 00:15:17.770
reported calls to the device for
an input report via get report

00:15:18.720 --> 00:15:20.230
sometimes results in a stalled pipe.

00:15:20.370 --> 00:15:27.210
So you might want to defer to using
the callback mechanism instead to

00:15:27.210 --> 00:15:27.210
kind of avoid that from happening.

00:15:27.500 --> 00:15:30.700
Another thing is you need to
be making use of I/O Kit device

00:15:30.790 --> 00:15:32.720
copy matching elements.

00:15:32.760 --> 00:15:35.330
And what this does is--

00:15:35.550 --> 00:15:39.080
Basically gives you all the elements
of interest in the particular device.

00:15:39.120 --> 00:15:41.590
Previously, what you had to do was parse
through the elements by

00:15:41.600 --> 00:15:43.500
grabbing them from the registry.

00:15:43.540 --> 00:15:46.960
And depending on the number of
elements that were available on the

00:15:46.960 --> 00:15:51.090
devices can be potentially expensive,
because what you had to do was serialize

00:15:51.160 --> 00:15:55.500
the elements on the kernel side and then
un-serialize them back on the user side.

00:15:55.500 --> 00:16:00.490
And this pretty much locked up
your application for a little bit.

00:16:00.520 --> 00:16:03.710
Also, beginning in 10.4,
not all the elements were

00:16:04.230 --> 00:16:05.500
accessible from the registry.

00:16:05.500 --> 00:16:08.940
And we did that on purpose basically
to kind of minimize the amount

00:16:08.940 --> 00:16:12.500
of time it took to actually grab
the elements from the registry.

00:16:14.530 --> 00:16:18.520
So a new object that we've
added is I/O Hit Element.

00:16:18.540 --> 00:16:22.280
And what this does is it replaces
the old CFDictionary representation

00:16:22.280 --> 00:16:23.300
we had in the past.

00:16:23.490 --> 00:16:25.690
So it just provides you
convenient accessors to get

00:16:25.720 --> 00:16:27.360
at all the element properties.

00:16:27.400 --> 00:16:29.730
Like I/O Hit Device,
it allows you to store and obtain

00:16:29.730 --> 00:16:32.250
application-specific properties.

00:16:32.430 --> 00:16:35.400
So of course if you wanted to save any
kind of state or maybe potentially have

00:16:35.400 --> 00:16:39.400
action IDs associated with each element,
you can do so here.

00:16:39.550 --> 00:16:43.360
We've also added the ability
to have calibration settings.

00:16:43.390 --> 00:16:45.380
So what we can do is
support calibration bounds,

00:16:45.490 --> 00:16:48.400
the granularity, the dead zone,
and the saturation.

00:16:48.400 --> 00:16:51.830
And we'll show you a little
example of how we do that here.

00:16:53.030 --> 00:16:57.800
So this kind of gives you a layout of
how the calibration could be set up.

00:16:57.810 --> 00:17:01.890
See, we have the saturation points and
the dead zone in the saturation.

00:17:04.240 --> 00:17:06.680
So, just to give you kind of
a brief example of how to

00:17:06.680 --> 00:17:08.980
actually set up the calibration.

00:17:09.020 --> 00:17:13.370
So, what we do first here is we try to
look for the x-axis of the joystick.

00:17:13.600 --> 00:17:16.610
So, we go ahead and set up
our matching dictionary.

00:17:16.710 --> 00:17:21.120
And we've already prepared the
usage page and usage CFNumbers here.

00:17:21.270 --> 00:17:27.170
So, we're looking at the generic
desktop and usage for the x-axis.

00:17:28.610 --> 00:17:31.040
Now that we've done that,
we go ahead and call I/O HitDevice

00:17:31.110 --> 00:17:32.500
Copy Matching Element.

00:17:32.500 --> 00:17:34.600
And what that does is it
returns back a CFArray.

00:17:34.860 --> 00:17:37.540
We see if it's not null,
it's got at least one object inside here.

00:17:37.540 --> 00:17:41.420
So let's just go ahead and
grab the first element.

00:17:42.620 --> 00:17:44.600
Now that we've done that,
just go ahead and set

00:17:44.600 --> 00:17:45.600
the properties on there.

00:17:45.600 --> 00:17:48.000
And what we're doing is we're
setting the property for the

00:17:48.000 --> 00:17:49.400
calibration bin and the max.

00:17:49.500 --> 00:17:52.500
In this example,
just negative one and one.

00:17:52.500 --> 00:17:56.320
And for the granularity,
just go ahead and set that to one.

00:17:58.600 --> 00:18:02.900
Now let's set the saturation
points and dead zone for

00:18:02.900 --> 00:18:05.210
the joystick and the X-axis.

00:18:11.400 --> 00:18:14.820
So now another object that we
have here is I/O Hit Value.

00:18:14.820 --> 00:18:17.690
And this is a new object, of course,
in Leopard.

00:18:17.700 --> 00:18:21.100
And what this does is it provides
accessors to obtain the integer

00:18:21.100 --> 00:18:23.080
or data representation of a value.

00:18:23.080 --> 00:18:25.940
So it's more of opaque calls
as opposed to looking at the

00:18:25.940 --> 00:18:28.200
structure like we did in the past.

00:18:28.200 --> 00:18:30.920
You can get the scale representation
of an element value as well.

00:18:30.920 --> 00:18:34.160
And this is useful for getting
either the physical value of the

00:18:34.160 --> 00:18:36.710
element or the calibrated value.

00:18:36.730 --> 00:18:39.240
And like I said earlier,
it replaces the confusing

00:18:39.240 --> 00:18:42.180
I/O Hit that we had in the past.

00:18:42.810 --> 00:18:46.410
Just to kind of give you an idea of what
the previous structure looked like here,

00:18:46.470 --> 00:18:50.680
it's like basically an event
struct that had about six fields.

00:18:50.710 --> 00:18:54.910
And the confusing thing here is that
you had both a value that was 32 bits,

00:18:54.910 --> 00:18:58.040
but then the ability to be passing
data values in there with the long

00:18:58.040 --> 00:18:59.620
value and the long value size.

00:18:59.770 --> 00:19:02.840
And sometimes it was a little annoying
to kind of decipher which value

00:19:02.840 --> 00:19:04.420
was actually in this structure.

00:19:04.480 --> 00:19:08.780
So we kind of just shielded you
for that with I/O Hit Value.

00:19:11.240 --> 00:19:13.920
So here's an example of
how to use I/O Kit value.

00:19:13.920 --> 00:19:17.120
What we're doing here is,
like the method we mentioned earlier,

00:19:17.150 --> 00:19:18.400
process value.

00:19:18.420 --> 00:19:22.280
Let's go ahead and deal with the
value that's being passed to us.

00:19:22.340 --> 00:19:25.530
First thing we do here is we go
ahead and get the element that's

00:19:25.530 --> 00:19:27.720
associated with that value.

00:19:27.750 --> 00:19:30.670
After we've done that,
we go ahead and obtain the usage

00:19:30.760 --> 00:19:33.270
page and usage for that value.

00:19:34.330 --> 00:19:37.200
In this example,
we're only interested in the X axis,

00:19:37.200 --> 00:19:40.200
so we go ahead and look for that.

00:19:40.330 --> 00:19:43.780
Once we've found that element,
let's go ahead and get the scaled value.

00:19:43.920 --> 00:19:48.240
And in this one, we're only interested in
the type that's calibrated.

00:19:48.360 --> 00:19:52.440
And just simple, greater than zero,
move right, less than zero, move left.

00:19:52.660 --> 00:19:54.420
Pretty straightforward.

00:19:57.250 --> 00:20:00.750
Another object in the head
manager is ioHit::queue.

00:20:00.870 --> 00:20:02.390
And this is strictly optional.

00:20:02.490 --> 00:20:04.760
You don't really need
to make use of this.

00:20:04.780 --> 00:20:08.400
But it's useful for queuing
input type element values.

00:20:08.420 --> 00:20:12.320
And, like the older API,
it gives you the ability to

00:20:12.360 --> 00:20:16.320
specify the queue depth and
manually dequeue element values.

00:20:16.330 --> 00:20:18.660
This is useful for
queuing complex elements,

00:20:18.660 --> 00:20:22.590
such as those that are greater
than the size of CF index,

00:20:22.590 --> 00:20:24.540
and also for handling duplicate elements.

00:20:24.540 --> 00:20:27.740
And those are the elements
that have one use tied to a

00:20:27.740 --> 00:20:30.370
multiple report current element.

00:20:30.640 --> 00:20:32.730
Unless you really need
to make use of this API,

00:20:32.740 --> 00:20:35.430
I would defer to using
I/O Hit Manager Register Input

00:20:35.520 --> 00:20:37.980
Value Callback or
I/O Hit Device Register Input

00:20:38.160 --> 00:20:39.980
Value Callback,
as that will handle

00:20:39.980 --> 00:20:41.540
that properly for you.

00:20:43.170 --> 00:20:47.060
Now, issues with using the
I/O Kit device queue.

00:20:47.120 --> 00:20:50.990
There's a difference between absolute
and relative elements in the way

00:20:51.060 --> 00:20:52.600
that they're handled on the queue.

00:20:52.650 --> 00:20:56.080
Absolute element values that do
not differ will not be enqueued.

00:20:56.180 --> 00:20:59.280
So if you're looking for
that kind of behavior,

00:20:59.380 --> 00:21:02.860
you might want to defer to
using the input value call-- or,

00:21:02.860 --> 00:21:05.460
sorry, the input report callback.

00:21:05.500 --> 00:21:08.150
Also, relative element values,
just because of their nature,

00:21:08.220 --> 00:21:10.360
will always be enqueued.

00:21:11.500 --> 00:21:15.920
Also, when you're using the
I/O Kit Q register value callback,

00:21:15.920 --> 00:21:19.390
you need to make notice that the
callback will only be issued when the

00:21:19.390 --> 00:21:21.640
queue transitions to being non-empty.

00:21:21.680 --> 00:21:24.630
So what this means is that
when the callback is issued for

00:21:24.880 --> 00:21:27.890
your particular application,
you need to make sure to

00:21:28.010 --> 00:21:29.460
drain the queue completely.

00:21:29.460 --> 00:21:33.060
Otherwise, you will not continue to
receive any callbacks.

00:21:33.960 --> 00:21:36.480
This is an example of
how to do such a thing.

00:21:36.490 --> 00:21:38.860
So here we've got the queue callback.

00:21:38.860 --> 00:21:41.510
And what we're doing here is
we're looping until we run out

00:21:41.590 --> 00:21:44.660
of values that are passed with
I/O Hit Queue Copy Next Value.

00:21:44.660 --> 00:21:48.370
And what that does is dequeues
the values from the queue.

00:21:48.450 --> 00:21:55.140
Because it is a copy,
you do need to make sure that

00:21:55.140 --> 00:21:55.140
you CF release the value ref
after you're complete with it.

00:21:57.410 --> 00:22:01.300
Next object here is I/O Kit Transaction.

00:22:01.300 --> 00:22:07.300
And this is useful for manipulating
multiple feature output type elements.

00:22:07.930 --> 00:22:11.340
Basically, we'll limit the amount of
communication to the device,

00:22:11.410 --> 00:22:15.430
so instead of individually calling set
element value or get element value,

00:22:15.440 --> 00:22:18.300
you can kind of group them together
and then use one transaction.

00:22:18.300 --> 00:22:21.600
Another thing you want to do is use
report IDs to kind of group these

00:22:21.600 --> 00:22:25.300
together and still make sure only
one report is issued to the device.

00:22:25.300 --> 00:22:28.990
New support that we've added
in Leopard is the ability to

00:22:29.170 --> 00:22:31.300
have bidirectional support.

00:22:31.300 --> 00:22:34.300
In the past,
we only supported output transactions,

00:22:34.300 --> 00:22:36.750
so now we can set up input as well,
so this is useful for

00:22:36.750 --> 00:22:38.880
feature type elements to,
you know,

00:22:38.880 --> 00:22:41.300
obtain the state of a particular element.

00:22:41.300 --> 00:22:44.590
As with the older API,
we allow the ability

00:22:45.290 --> 00:22:49.270
to set default values,
and that's pretty useful

00:22:49.380 --> 00:22:52.210
for the output transaction.

00:22:55.020 --> 00:22:59.380
and I'll briefly cover the 64-bit
support that we've added to Leopard.

00:22:59.410 --> 00:23:04.600
Both the current and new HitManager
API is 64-bit compatible.

00:23:04.630 --> 00:23:06.860
One thing we've changed here
is I/O HitElementCookie.

00:23:06.910 --> 00:23:13.090
The type changes from void star
to UN32 when you're building LP64.

00:23:13.500 --> 00:23:16.380
And this is done just for
compatibility reasons,

00:23:16.380 --> 00:23:19.040
not anything you really
notice on your end.

00:23:19.100 --> 00:23:22.670
And as we covered before in the past,
the new API makes use

00:23:22.670 --> 00:23:26.390
of CFNX and like I said,
32-bits or 64-bits depending on what is

00:23:26.430 --> 00:23:28.910
native architecture you're compiling for.

00:23:29.070 --> 00:23:32.880
And with that, I'll go ahead and pass
this on to Ethan Bold.

00:23:43.400 --> 00:23:46.800
I'm Ethan Bold, and like Rob,
I work on the I/O Kit team,

00:23:46.800 --> 00:23:50.890
and today we're going to talk a
little bit about some best practices

00:23:50.890 --> 00:23:53.120
for driver power management.

00:23:54.050 --> 00:23:56.640
So why do you need to
power manage your driver?

00:23:56.710 --> 00:24:00.690
Because most of the computers that
Apple sells today are laptops.

00:24:00.890 --> 00:24:07.300
And if your driver is going to be for
a PC card or any kind of PCI device,

00:24:07.300 --> 00:24:12.200
you need to have a power
management-aware driver.

00:24:12.350 --> 00:24:13.590
And it's very easy.

00:24:13.700 --> 00:24:18.690
Your driver probably only needs to be
able to power itself on and off when the

00:24:18.690 --> 00:24:20.990
machine is going to sleep and waking up.

00:24:21.130 --> 00:24:23.370
So today--

00:24:23.530 --> 00:24:27.890
So today I want to familiarize you
with OS X's power management support

00:24:28.270 --> 00:24:33.480
and discuss how you can add that to
your internal I/O service-based driver.

00:24:34.730 --> 00:24:38.640
So who needs the APIs I'm going
to be talking about today?

00:24:38.650 --> 00:24:43.400
You don't need them if you have
a user space driver of any kind.

00:24:43.400 --> 00:24:48.260
User space, USB, or FireWire doesn't need
to implement these APIs.

00:24:48.630 --> 00:24:53.690
If you have an in-kernel driver whose
family already supports power management,

00:24:53.940 --> 00:24:56.180
then you don't need to
implement these APIs either.

00:24:56.400 --> 00:24:59.170
For example,
the I/O networking family has good

00:24:59.220 --> 00:25:01.500
built-in support for power management.

00:25:01.500 --> 00:25:04.760
So if you're subclassing
I/O Ethernet interface,

00:25:04.760 --> 00:25:07.450
you don't need to use any of these APIs.

00:25:07.590 --> 00:25:13.040
So the calls I'm about to talk about
are for in-kernel drivers that directly

00:25:13.040 --> 00:25:19.980
subclass I/O service or subclass a family
that doesn't offer that power management.

00:25:21.490 --> 00:25:26.970
So your driver's role in power
managing your device is to,

00:25:27.350 --> 00:25:30.390
first and foremost,
power the device off while the

00:25:30.390 --> 00:25:35.350
machine goes to sleep and power
it back on during wake from sleep.

00:25:35.490 --> 00:25:38.980
And beyond that,
you need to save the state

00:25:39.030 --> 00:25:41.280
of your hardware to memory.

00:25:41.500 --> 00:26:04.400
[Transcript missing]

00:26:05.060 --> 00:26:09.230
One of the big gotchas with sleep is
that user space threads and processes

00:26:09.230 --> 00:26:12.630
are still running while we're putting
the machine to sleep and while we're

00:26:12.630 --> 00:26:14.260
turning your device to power off.

00:26:14.360 --> 00:26:18.460
So your device could be deluged
with dozens of hardware accesses

00:26:18.460 --> 00:26:21.040
after it's already turned off.

00:26:21.110 --> 00:26:25.110
So you need a strategy for preventing
those from actually trying to touch

00:26:25.110 --> 00:26:27.990
the hardware and panic the system.

00:26:28.070 --> 00:26:33.930
A good approach is the I/O work
loop based approach where you block

00:26:34.210 --> 00:26:38.920
all incoming threads with a close
gate call and then those threads

00:26:38.920 --> 00:26:44.350
can safely resume on wake from sleep
and complete their I/O accesses.

00:26:44.870 --> 00:26:48.390
And to your driver,
all kinds of sleep will appear the same.

00:26:48.390 --> 00:26:50.340
You'll get the same
types of notifications.

00:26:50.340 --> 00:26:57.530
Be it idle sleep, or late closed sleep,
or even safe sleep, or hibernation.

00:27:00.400 --> 00:27:07.180
So there are three pretty simple calls to
sign up your device for power management.

00:27:07.180 --> 00:27:09.800
And there's one cleanup
call you need to make.

00:27:09.820 --> 00:27:13.350
And we're also going to talk
about one I/O service method you

00:27:13.350 --> 00:27:17.500
need to override to get those
power management notifications.

00:27:17.520 --> 00:27:21.300
So the first call you need to
make to register your driver

00:27:21.580 --> 00:27:24.420
for power management is PMINIT.

00:27:24.420 --> 00:27:29.580
And that just allocates some internal
power management data structures.

00:27:30.750 --> 00:27:35.220
The second call that you
need to make is join PMTree.

00:27:35.220 --> 00:27:42.040
And this tells the kernel power
management where your device needs

00:27:42.050 --> 00:27:44.390
to belong in the I/O power plane.

00:27:44.510 --> 00:27:48.960
And the I/O power plane is how
we order sleep/wake across all

00:27:48.960 --> 00:27:51.340
of the devices in the system.

00:27:51.340 --> 00:27:56.250
For instance, the I/O power plane kind
of looks like a tree.

00:27:56.250 --> 00:28:02.640
And the leaf nodes are always the first
to be slept and the last to be woken.

00:28:02.770 --> 00:28:07.840
And only after all of a node's
children have been put to sleep will

00:28:07.840 --> 00:28:10.760
that parent node be put to sleep.

00:28:12.040 --> 00:28:14.510
So here's an example of that.

00:28:14.720 --> 00:28:17.190
This is an example of the
I/O Power Plan that I took

00:28:17.220 --> 00:28:20.880
off of a MacBook Pro,
and you can pull this off of

00:28:20.880 --> 00:28:27.480
any of your own laptops just
by running ioreg-p iopower.

00:28:27.490 --> 00:28:29.840
And if you're familiar
with the I/O Registry,

00:28:29.850 --> 00:28:33.210
this is just another facet of
the I/O Registry that tracks

00:28:33.330 --> 00:28:34.830
these power dependencies.

00:28:35.010 --> 00:28:39.290
And in this example,
you can see Airport at the

00:28:39.640 --> 00:28:44.400
very bottom of the hierarchy,
and its direct parent is

00:28:44.400 --> 00:28:47.440
an I/O Power connection,
which we can ignore.

00:28:47.440 --> 00:28:51.900
And above that is the PCI nub
that it is attached to,

00:28:51.920 --> 00:28:56.420
and above that is the PCI bus
that it's connected to.

00:28:56.570 --> 00:29:00.090
So when the machine is going to sleep,
Airport will always be told

00:29:00.260 --> 00:29:04.470
to power off first before the
PCI bus that it's attached to.

00:29:06.150 --> 00:29:11.420
The last step in signing up for power
management is to define a couple of

00:29:11.620 --> 00:29:16.740
power states in an array and pass
those into kernel power management.

00:29:16.800 --> 00:29:22.870
So we're starting here by defining
an array of two power states.

00:29:22.960 --> 00:29:28.150
Each power state is defined by
the struct IOPM_POWER_STATE,

00:29:28.150 --> 00:29:33.160
and you can find the definition
for that in IOPM_POWER_STATE.h

00:29:33.220 --> 00:29:35.200
in the kernel framework.

00:29:35.280 --> 00:29:39.640
But you can see here that
at index 0 of the array,

00:29:39.700 --> 00:29:42.410
we're defining our off state,
and at index 1,

00:29:42.410 --> 00:29:44.390
we're defining our on state.

00:29:44.470 --> 00:29:47.470
So when the system goes to sleep,
we'll be told to go into this off state,

00:29:47.590 --> 00:29:51.210
and when the system wakes,
we'll be told to go into this on state.

00:29:51.490 --> 00:29:55.240
And we're only setting
three important fields here:

00:29:55.290 --> 00:29:58.640
this capability flags,
output power character,

00:29:58.800 --> 00:30:00.690
and input power requirement.

00:30:00.870 --> 00:30:04.300
And for our off state,
we're setting them all to 0.

00:30:04.300 --> 00:30:07.530
And for the on state,
we're going to set them all to 1.

00:30:08.880 --> 00:30:12.740
And here's some shorthand
for setting that struct up,

00:30:12.770 --> 00:30:14.470
that array of structs.

00:30:14.830 --> 00:30:19.240
And this is how you're more
likely to see these power states

00:30:19.240 --> 00:30:22.360
defined in any Apple driver code.

00:30:24.660 --> 00:30:31.030
And next, all we have to do is call the
I/O service method registerPowerDriver

00:30:31.060 --> 00:30:35.910
with a pointer to ourselves,
or this pointer, because we are our own

00:30:36.270 --> 00:30:39.500
power controlling driver,
a pointer to the array of two

00:30:39.610 --> 00:30:43.360
power states we just defined,
and the number two,

00:30:43.390 --> 00:30:45.240
because we have two power states.

00:30:45.330 --> 00:30:50.250
So, remember we had to call pm init,
and then join pmtree,

00:30:50.250 --> 00:30:53.870
and then registerPowerDriver,
in that order,

00:30:54.020 --> 00:30:57.870
and you typically do that in
your driver start routine.

00:30:59.540 --> 00:31:04.840
Now when your driver unloads for when
your device disappears for any reason,

00:31:04.850 --> 00:31:09.550
you just need to call PM Stop to
clean up for all three of

00:31:09.910 --> 00:31:13.830
those PM initialization calls.

00:31:16.820 --> 00:31:22.190
Okay, and the last step is to override
the I/O Service Virtual Method set

00:31:22.190 --> 00:31:23.400
power state.

00:31:23.400 --> 00:31:26.600
Set power state takes an
unsigned long argument,

00:31:26.600 --> 00:31:31.450
power state ordinal,
and that's the important

00:31:31.470 --> 00:31:33.920
argument to watch here.

00:31:33.940 --> 00:31:38.520
So that number tells you which
index into your power state array

00:31:38.520 --> 00:31:41.430
you need to transition into.

00:31:41.440 --> 00:31:44.800
So here's some example code.

00:31:44.800 --> 00:31:46.900
You can see here that

00:31:47.580 --> 00:31:52.380
If the unsigned long which
state argument is set to zero,

00:31:52.380 --> 00:31:55.210
then we're going to sleep
and we need to take action to

00:31:55.330 --> 00:32:00.660
save state of our hardware,
prevent any incoming hardware accesses,

00:32:00.780 --> 00:32:03.320
and turn our device off.

00:32:03.400 --> 00:32:07.470
And otherwise,
we are waking up and we need to power

00:32:07.470 --> 00:32:13.610
our hardware back on and allow any
blocked hardware accesses to proceed.

00:32:13.980 --> 00:32:17.450
And there's a couple of interesting
lines down at the bottom.

00:32:17.520 --> 00:32:20.780
You can--there are two
return codes you can make.

00:32:20.920 --> 00:32:24.860
You can return I/O PM ACK implied,
which means that you have

00:32:25.080 --> 00:32:30.280
completely powered your hardware
off or on in this method,

00:32:30.330 --> 00:32:31.330
and you're done.

00:32:31.380 --> 00:32:34.420
Your hardware is completely powered off.

00:32:34.490 --> 00:32:42.260
Or you can return I/O PM will ACK later,
and that means that you are finishing

00:32:42.260 --> 00:32:44.860
your hardware work asynchronously.

00:32:44.880 --> 00:32:52.490
And you will acknowledge later with
the call Acknowledge Set Power State.

00:32:54.480 --> 00:33:01.320
So, it can be very painful to debug power
management problems and sleep-wake issues

00:33:01.800 --> 00:33:06.700
because a lot of the debugging facilities
that we rely on aren't there when the

00:33:06.700 --> 00:33:10.640
machine is going to sleep or waking up.

00:33:11.140 --> 00:33:14.810
So, the display can be powered off,
Ethernet can be powered off,

00:33:15.010 --> 00:33:16.670
and hard disks can be spun down.

00:33:16.910 --> 00:33:20.770
So, all those facilities that
we rely on aren't available.

00:33:20.860 --> 00:33:27.060
But luckily, unless you're working on a
FireWire driver of some sort,

00:33:27.120 --> 00:33:33.760
you can load up a FireWire logging kex
that lets you do printf-style logging

00:33:34.420 --> 00:33:37.200
from your machine to a second computer.

00:33:37.230 --> 00:33:41.690
And you can get logs all the way down to
the point that the CPUs are turned off.

00:33:41.750 --> 00:33:45.160
So, it's a very, very useful tool.

00:33:45.180 --> 00:33:50.200
And we also have a... Oh,
and the FireWire kprintf debugging is

00:33:50.210 --> 00:33:53.720
available in the FireWire SDKs today.

00:33:54.200 --> 00:33:57.680
So there's also a tool called
SleepX that I'll point you to.

00:33:57.700 --> 00:34:03.070
And SleepX just lets you stress driver
sleep/wake in your driver by sleeping

00:34:03.070 --> 00:34:07.600
and waking the entire system dozens
or hundreds or thousands of times.

00:34:07.600 --> 00:34:13.080
And you can catch leaks and
races and all sorts of stuff.

00:34:13.350 --> 00:34:18.960
And that is probably not available today,
but should be available from DTS soon.

00:34:19.670 --> 00:34:21.600
So that's about it for me.

00:34:21.600 --> 00:34:26.320
There are a few gotchas with
Sleep/Wake that I'd like to mention.

00:34:26.470 --> 00:34:30.530
One is you can't allocate memory
on the sleep path because a memory

00:34:30.590 --> 00:34:35.980
allocation could require VM to
page out some user space memory,

00:34:36.150 --> 00:34:40.240
but if the disks are already spun down,
you'll create a deadlock

00:34:40.270 --> 00:34:42.190
and the system will hang.

00:34:42.390 --> 00:34:45.590
I should mention that
these APIs won't give you a

00:34:45.590 --> 00:34:48.630
notification at system shutdown.

00:34:48.890 --> 00:34:53.630
And I should also note that this was a
pretty simple run-through of a simple

00:34:53.630 --> 00:34:58.920
way to do device power management,
but it gets considerably more

00:34:58.920 --> 00:35:03.350
complicated to do any higher
levels of power management.

00:35:03.470 --> 00:35:04.670
So, thank you.

00:35:04.990 --> 00:35:05.600
That's it for me.

00:35:05.710 --> 00:35:07.840
And Eric Anderson's up.

00:35:18.050 --> 00:35:19.900
Okay, thanks Ethan.

00:35:20.080 --> 00:35:20.800
Hi everybody.

00:35:21.050 --> 00:35:23.580
To round out this morning's presentation,
we're going to talk about

00:35:23.580 --> 00:35:25.590
best practices in FireWire.

00:35:25.620 --> 00:35:28.940
A lot of the same general concepts
as you heard for the other

00:35:29.020 --> 00:35:31.000
I/Os from a FireWire point of view.

00:35:31.000 --> 00:35:32.900
First, what's new?

00:35:33.000 --> 00:35:36.460
We spent the past year pretty
much changing everything,

00:35:36.800 --> 00:35:38.990
hopefully in order to change nothing.

00:35:38.990 --> 00:35:43.330
We believe on the Intel platforms
we have total feature parity with

00:35:43.330 --> 00:35:46.000
the PowerPC platforms before them.

00:35:46.000 --> 00:35:48.000
Everything should work.

00:35:48.000 --> 00:35:51.010
We have our SDK 22 that
Ethan just mentioned,

00:35:51.010 --> 00:35:53.980
which has the FireWire
kprintf service in it.

00:35:54.000 --> 00:35:56.990
That's available at the
URL you can see there.

00:35:57.000 --> 00:35:57.900
That's already up.

00:35:58.060 --> 00:35:59.990
That's been up for a
couple months actually.

00:36:00.350 --> 00:36:04.000
Everything in there is
100% universal source code,

00:36:04.000 --> 00:36:06.910
sample code,
and the tools that are in there

00:36:06.910 --> 00:36:09.580
are just about 100% universal.

00:36:10.500 --> 00:36:12.960
I should note,
unlike the transition a few years

00:36:12.960 --> 00:36:16.690
ago from Mac OS 9 to Mac OS X,
where we sort of dropped FireWire

00:36:16.690 --> 00:36:20.780
out of the classic environment,
FireWire is fully supported in Rosetta.

00:36:20.780 --> 00:36:26.280
You can use the PowerPC applications
from SDK 22 or 21 even,

00:36:26.290 --> 00:36:28.820
and they will all work
fine on the Intel systems.

00:36:28.820 --> 00:36:30.340
Of course, we encourage you to go native.

00:36:30.340 --> 00:36:32.420
We've done everything we can
to support that with full

00:36:32.430 --> 00:36:33.940
parity and full source code.

00:36:33.940 --> 00:36:36.220
But if you do need to
run in Rosetta because,

00:36:36.220 --> 00:36:39.560
say, you're a plug-in to an app
that itself is not native,

00:36:39.560 --> 00:36:40.110
you can do that.

00:36:40.270 --> 00:36:41.980
FireWire services are
completely available,

00:36:41.980 --> 00:36:43.810
and they should work fine.

00:36:44.010 --> 00:36:48.000
Two other new areas that I'm going
to discuss this morning are 64-bit

00:36:48.060 --> 00:36:51.600
support for the new Mac Pro and
some new sample code that we have

00:36:51.740 --> 00:36:54.330
for audio/video type devices.

00:36:54.790 --> 00:36:58.540
So like you heard a little earlier,
the Mac Pro has a 64-bit architecture.

00:36:58.540 --> 00:37:02.310
It can have more than 4
gigabytes of system memory.

00:37:02.540 --> 00:37:07.140
The OHCI FireWire controller that we use
today is limited to working within the

00:37:07.150 --> 00:37:10.500
first 4GB of memory by its architecture.

00:37:10.640 --> 00:37:13.870
So if you are working from
user space through FireWire,

00:37:13.940 --> 00:37:16.500
through our user clients for example,
or through higher level APIs,

00:37:16.500 --> 00:37:18.160
you're fine.

00:37:18.580 --> 00:37:21.410
Your buffers and user space can
be remapped so that the physical

00:37:21.410 --> 00:37:25.350
page underneath them moves into
the low 4GB where FireWire can

00:37:25.350 --> 00:37:26.500
see that page with its DMA.

00:37:26.500 --> 00:37:28.400
So you don't need to worry about that.

00:37:28.500 --> 00:37:32.540
On the other hand, if you're developing a
kernel driver for FireWire,

00:37:32.610 --> 00:37:35.700
because we're a high performance I/O,
we don't want to be copying your data all

00:37:35.700 --> 00:37:38.500
over the place just to get it in and out.

00:37:38.500 --> 00:37:41.680
So we require that you allocate
these buffers below 4GB if

00:37:41.680 --> 00:37:45.380
necessary on these systems so that
the DMA can touch them directly.

00:37:45.500 --> 00:37:49.070
Now there's two kinds of
buffers in FireWire that you

00:37:49.150 --> 00:37:51.480
may need to be concerned with.

00:37:51.500 --> 00:37:56.490
For ordinary buffers in memory
that you're simply going to

00:37:56.560 --> 00:38:00.500
run an isochronous program,
to transmit or receive,

00:38:00.730 --> 00:38:04.500
or the basic FWREAD, FWWRIGHT calls.

00:38:04.500 --> 00:38:09.390
These are handled by the
first block of code here.

00:38:09.500 --> 00:38:13.410
There are APIs to simply find out
the mask or the number of bits

00:38:13.490 --> 00:38:16.500
that's supported by the controller
that's backing up your object.

00:38:16.500 --> 00:38:20.550
Today these will all return
either 32 or that constant that

00:38:20.560 --> 00:38:22.680
you see with 32 ones in it.

00:38:23.340 --> 00:38:27.820
Conceivably, in the future,
you may run into the

00:38:28.110 --> 00:38:30.020
need for a different API.

00:38:30.150 --> 00:38:35.310
FireWire allows external devices to
access the memory in the computer

00:38:35.720 --> 00:38:39.290
directly through the FireWire hardware
with no software intervention at all.

00:38:39.300 --> 00:38:42.780
The FireWire specification carves
out a range of memory addresses

00:38:42.780 --> 00:38:44.270
in which this can be done.

00:38:44.390 --> 00:38:47.300
That range is actually 48 bits large.

00:38:47.300 --> 00:38:50.450
So, conceivably,
physical memory can be accessed

00:38:50.450 --> 00:38:54.100
above 4 gigabytes through a
controller that supports it.

00:38:54.300 --> 00:38:58.210
We don't have one yet that does it,
but if you want to be forward-thinking

00:38:58.450 --> 00:39:01.210
and take full advantage of a future
controller that did support that,

00:39:01.300 --> 00:39:03.300
there's an API for you.

00:39:03.300 --> 00:39:07.290
If your buffer is going to be visible
from outside the box through FireWire,

00:39:07.330 --> 00:39:11.680
then use this second API,
which in the future could

00:39:11.680 --> 00:39:13.300
return a number up to 48.

00:39:13.300 --> 00:39:15.300
It can't go above 48.

00:39:15.300 --> 00:39:16.300
But if we someday make a mistake,
we can do it.

00:39:16.300 --> 00:39:17.300
So, I'm going to show you how to do that.

00:39:17.300 --> 00:39:19.880
So, if you have a PC machine
with 256 terabytes,

00:39:19.880 --> 00:39:22.560
this will keep you on the
right-hand side of that line where

00:39:22.570 --> 00:39:24.300
your stuff will work properly.

00:39:25.940 --> 00:39:29.400
So here's a simple example,
just like you saw in the slides before.

00:39:29.430 --> 00:39:35.300
Get the FireWire physical buffer mask,
which today will tell you 32 bits of one.

00:39:35.670 --> 00:39:39.600
Use InTask with physical mask
and just pass that mask in.

00:39:39.600 --> 00:39:42.610
Then it's common in FireWire,
if you're doing isochronous

00:39:42.610 --> 00:39:46.860
real-time transfers in or out,
to get one large buffer and carve

00:39:46.860 --> 00:39:48.870
it up yourself packet by packet.

00:39:48.980 --> 00:39:52.700
So you can simply call getBytesNoCopy
to find out where things are and start

00:39:52.700 --> 00:39:56.330
doing pointer arithmetic to build
up your program just like before.

00:39:57.470 --> 00:40:00.960
Okay, one other area that is new in
FireWire is a substantial increase

00:40:00.980 --> 00:40:05.660
in the amount of sample code for
our audio/video services framework.

00:40:05.850 --> 00:40:11.620
There is an MPEG transmitter now that's
constructed using the new DCL service.

00:40:11.740 --> 00:40:15.550
New DCL is sort of an abstract
programming language by which

00:40:15.550 --> 00:40:19.890
you describe a real-time,
isochronous transfer into or

00:40:19.940 --> 00:40:22.250
out of the system on FireWire.

00:40:22.340 --> 00:40:25.960
The MPEG transmitter demonstrates
how to use variable length packets.

00:40:26.040 --> 00:40:29.560
The previous system only
had fixed length packets.

00:40:29.630 --> 00:40:32.240
And even if you're not sending MPEG,
this is probably a good starting

00:40:32.240 --> 00:40:34.330
point for any kind of transmit code.

00:40:34.400 --> 00:40:37.960
You can just change the packet sizes,
change the loop sizes, the callbacks,

00:40:37.960 --> 00:40:40.810
and so on to meet your needs.

00:40:41.110 --> 00:40:44.140
Also available is a
new universal receiver.

00:40:44.150 --> 00:40:47.570
This is actually a
legacy-style DCL receiver.

00:40:47.700 --> 00:40:50.890
We also will have a new
DCL version of this.

00:40:51.340 --> 00:40:54.000
This can receive any Isochrone's channel.

00:40:54.000 --> 00:40:57.510
It could be DV, it could be MPEG,
it could be iSight, it could be audio,

00:40:57.590 --> 00:41:00.800
it could be something that you've
invented for some unique device.

00:41:00.980 --> 00:41:03.700
Whatever it is,
this receiver can receive it.

00:41:03.700 --> 00:41:07.250
So you can use this as a starting
point to develop your own code to

00:41:07.250 --> 00:41:11.690
optimize it to meet your needs,
or you may just want to run it as is.

00:41:11.700 --> 00:41:16.100
Many kinds of data that we receive
from FireWire stream according

00:41:16.110 --> 00:41:18.700
to the ISO 61883 standard.

00:41:18.800 --> 00:41:22.590
So if your data fits in that category,
there's a parser built in that will help

00:41:22.600 --> 00:41:27.800
pick it apart and find the appropriate
packets and payload buffers for you.

00:41:28.230 --> 00:41:32.720
So why a universal receiver aside from
just its good sample code to start with?

00:41:32.880 --> 00:41:36.960
Well, there's two places you might want
to keep the full universal support.

00:41:37.030 --> 00:41:42.610
One is there are devices like camcorders
that actually support multiple formats.

00:41:42.670 --> 00:41:45.420
They may stream DV at one moment, DV25.

00:41:45.700 --> 00:41:49.630
They may turn around and stream MPEG or
HDV the next moment because the user has

00:41:49.630 --> 00:41:53.020
moved a switch on the camera or they've
put a different tape in the camera.

00:41:53.050 --> 00:41:56.520
Or the tape may even have different
formats recorded on it and it's just

00:41:56.520 --> 00:41:58.480
playing back and switching on the fly.

00:41:58.670 --> 00:42:01.270
So with the universal receiver,
you don't need to tear down and

00:42:01.270 --> 00:42:04.160
build up a receive program every
time you detect a format change.

00:42:04.160 --> 00:42:07.180
You can just roll on through
and receive everything.

00:42:07.370 --> 00:42:09.750
The other case where you might want this,
even if you don't have

00:42:09.850 --> 00:42:11.600
that kind of device,
maybe you have a

00:42:11.650 --> 00:42:13.620
multilingual application.

00:42:13.630 --> 00:42:17.040
Maybe you've developed some sort
of FireWire video viewer that just

00:42:17.050 --> 00:42:19.090
wants to display video from anything.

00:42:19.290 --> 00:42:23.000
Here, too, rather than maintaining four
different receive DCLs for four

00:42:23.000 --> 00:42:26.680
different packet formats coming in,
just run the universal receiver.

00:42:26.710 --> 00:42:28.640
You can pick the bytes out
and decode them yourself,

00:42:28.660 --> 00:42:30.850
but now you don't need to tear
it down and maintain it for each

00:42:30.880 --> 00:42:33.470
different device that may come along.

00:42:33.850 --> 00:42:36.790
All of this will be
available in FireWire SDK 23.

00:42:36.790 --> 00:42:39.070
It's at the same URL you saw before.

00:42:39.160 --> 00:42:40.970
It's not available yet,
but we do plan to post

00:42:40.970 --> 00:42:42.010
it within a few weeks.

00:42:44.760 --> 00:42:46.820
One other thing that will
be in there is a tool,

00:42:46.960 --> 00:42:49.480
a sample code called AVC Browser.

00:42:49.590 --> 00:42:52.500
This replaces an older
version by the same name.

00:42:52.570 --> 00:42:56.030
AVC Browser is sort of
like Apple System Profiler,

00:42:56.150 --> 00:42:59.560
but for a FireWire device
that uses the AVC protocol,

00:42:59.560 --> 00:43:03.480
which would be a camcorder, a television,
a DVHS, whatever.

00:43:03.590 --> 00:43:06.430
So you can see the panel on
the left is a list of devices

00:43:06.430 --> 00:43:08.110
found on the FireWire bus.

00:43:08.210 --> 00:43:12.700
The panel on the right has opened up
one device and is offering controls.

00:43:12.760 --> 00:43:17.490
This allows you to sort of poke hands-on,
it's somewhat like Reggie in a sense,

00:43:17.510 --> 00:43:20.700
which is a developer tool for reading
and writing memory and other things.

00:43:20.700 --> 00:43:24.700
AVC Browser can send primitive
commands to and from your device,

00:43:24.700 --> 00:43:27.700
so you can explore to see what
commands the device actually supports,

00:43:27.700 --> 00:43:30.950
how it reacts to them,
before you sit down and write code

00:43:30.950 --> 00:43:33.700
for doing each of those things and
then trying to debug it on the fly.

00:43:33.700 --> 00:43:38.040
So it's a good way to get started with an
unknown device or to become familiar with

00:43:38.130 --> 00:43:40.500
the protocol that your device speaks.

00:43:41.840 --> 00:43:44.800
Okay, to wrap up,
we have some advice and recommendations

00:43:45.070 --> 00:43:49.560
for how to be successful and
effective developing FireWire drivers.

00:43:49.820 --> 00:43:52.280
Always start with the
latest FireWire SDK.

00:43:52.440 --> 00:43:54.430
There's the URL again,
same one as before.

00:43:54.580 --> 00:43:58.800
It is full of sample code, source code,
documentation, tools.

00:43:58.800 --> 00:44:02.910
And a lot of the tools are
designed to help you get started

00:44:02.910 --> 00:44:05.800
on understanding how things work.

00:44:05.800 --> 00:44:09.780
Like AVC Browser specifically lets
you poke around at an AVC device.

00:44:09.850 --> 00:44:13.800
We have tools for viewing the
configuration ROM in a FireWire device,

00:44:13.800 --> 00:44:17.790
tools for viewing the registers in a PHY,
tools for viewing the bus topology.

00:44:17.870 --> 00:44:22.790
So rather than cracking open a 400-page
spec and thousands of lines of API,

00:44:22.790 --> 00:44:25.860
you can try these things hands-on,
one by one,

00:44:25.860 --> 00:44:27.800
whatever is appropriate to your device,
and get comfortable before

00:44:27.800 --> 00:44:28.730
you start writing code.

00:44:28.800 --> 00:44:32.100
So then you really feel
you know what you're doing.

00:44:34.980 --> 00:44:37.340
If at all possible,
please write in user space.

00:44:37.340 --> 00:44:42.000
As I said, we have 100% parity with
our PowerPC services.

00:44:42.160 --> 00:44:45.890
We believe 100% of FireWire
is available in user space.

00:44:45.890 --> 00:44:48.890
If you find something that's missing,
we will add it.

00:44:49.050 --> 00:44:51.890
So it's much easier to
debug in user space.

00:44:51.900 --> 00:44:53.690
You can run an Xcode,
you can step through your code,

00:44:53.780 --> 00:44:56.290
you can see what's happening,
you don't have to keep rebooting

00:44:56.290 --> 00:44:57.890
every time something goes wrong.

00:44:57.900 --> 00:44:59.900
It's very preferable.

00:44:59.900 --> 00:45:02.430
In the SDK,
most of the sample code that we

00:45:02.430 --> 00:45:04.900
provide is for user space projects.

00:45:04.900 --> 00:45:06.900
There are a few exceptions.

00:45:06.900 --> 00:45:09.750
If we're going to boot
from your FireWire device,

00:45:09.930 --> 00:45:10.900
your driver will have
to be in the kernel.

00:45:10.900 --> 00:45:13.900
If you've invented some new kind
of RAID we've never seen before,

00:45:13.900 --> 00:45:16.010
you may need to write
your own driver for that.

00:45:16.080 --> 00:45:17.700
That would have to be in the kernel.

00:45:18.010 --> 00:45:21.000
Similarly, a network driver,
if you've got a better internet

00:45:21.020 --> 00:45:23.900
protocol or some custom
application-specific thing,

00:45:23.900 --> 00:45:26.270
that probably has to go in the
kernel as well so that it can

00:45:26.270 --> 00:45:27.900
plug into the networking family.

00:45:27.900 --> 00:45:28.900
Finally, search engine.

00:45:29.000 --> 00:45:32.550
Finally, certain audio devices,
if you need extremely low latency,

00:45:32.550 --> 00:45:35.940
such as for real-time effects processing,
that may need to be in the

00:45:35.940 --> 00:45:38.900
kernel as well just to take
advantage of real-time services.

00:45:39.010 --> 00:45:41.900
Other than those, we think you should be
able to work in user space.

00:45:44.670 --> 00:45:47.240
This really applies to
USB as well as FireWire.

00:45:47.270 --> 00:45:50.360
Do not assume that there's
exactly one controller.

00:45:50.400 --> 00:45:53.450
The Macs that we sell today have
one FireWire controller built in,

00:45:53.550 --> 00:45:56.570
but some of them have slots where the
customer can add another controller.

00:45:56.600 --> 00:45:59.920
Some of you are developers for the
cards that would go in those slots,

00:45:59.920 --> 00:46:02.500
but it's unfortunate if
your customer buys the card,

00:46:02.500 --> 00:46:05.150
adds it to the Mac,
and their plug-in or their driver won't

00:46:05.150 --> 00:46:08.600
work on it because someone assumed
there's one and only one FireWire port.

00:46:08.600 --> 00:46:12.570
So please test out your drivers on
systems that have an added controller

00:46:12.570 --> 00:46:14.600
to make sure you can cope with it.

00:46:14.600 --> 00:46:16.600
The same goes for your device.

00:46:16.600 --> 00:46:18.600
Of course we want the customer
to buy one of your devices,

00:46:18.600 --> 00:46:20.600
but it's even better if the
customer buys two of your devices.

00:46:20.600 --> 00:46:24.230
So please make sure that that's going
to work for them by testing on the

00:46:24.230 --> 00:46:26.600
system with two or more devices at once.

00:46:26.600 --> 00:46:29.600
Usually all it requires is
letting the user choose.

00:46:29.600 --> 00:46:32.000
Give them a menu or some kind
of control where they can pick

00:46:32.000 --> 00:46:33.550
which device they want to talk to.

00:46:33.600 --> 00:46:37.500
A lot of the tools in the
SDK show how to do this.

00:46:37.600 --> 00:46:41.030
They have a menu in the upper left corner
that lets you select which FireWire

00:46:41.030 --> 00:46:45.510
interface and if applicable which device
or which node they're going to talk to.

00:46:50.210 --> 00:46:52.970
Device matching is usually the
first thing someone tackles when

00:46:52.970 --> 00:46:55.650
they sit down with a new device
and try to write code for it.

00:46:55.760 --> 00:46:58.390
It's a mystery.

00:46:59.160 --> 00:47:01.760
You know, you're just getting
started on the project.

00:47:01.810 --> 00:47:04.000
As soon as you match to the device,
usually,

00:47:04.000 --> 00:47:07.000
do you declare victory and move on
to actually making it do something?

00:47:07.270 --> 00:47:10.230
Well, please take care to check
that you haven't matched

00:47:10.230 --> 00:47:12.000
too lightly on your device.

00:47:12.000 --> 00:47:15.110
Your driver and your device
may work perfectly together,

00:47:15.110 --> 00:47:18.340
but if your driver also matches
on someone else's device,

00:47:18.340 --> 00:47:20.000
which may be a very
different kind of thing,

00:47:20.000 --> 00:47:23.000
it may thrash trying to talk to
that device and getting confused.

00:47:23.000 --> 00:47:26.100
So, even though this is usually
done first and then forgotten,

00:47:26.100 --> 00:47:29.330
please come back and make sure you
really are matching as tightly as

00:47:29.330 --> 00:47:33.000
possible to your device so that you
won't conflict with other things.

00:47:33.000 --> 00:47:36.190
FireWire provides a structured
configuration ROM in the device,

00:47:36.370 --> 00:47:37.990
which our software discovers.

00:47:38.000 --> 00:47:41.210
In there are places for your vendor ID,
your model ID,

00:47:41.220 --> 00:47:44.910
and other values that help set
your device apart from others.

00:47:45.000 --> 00:47:48.780
So, one of the tools in the
SDK is called Firecracker.

00:47:48.780 --> 00:47:51.990
It is a browser for the
configuration ROM in your device.

00:47:52.000 --> 00:47:52.940
So, put it in your device.

00:47:53.040 --> 00:47:54.000
Plug your device in.

00:47:54.000 --> 00:47:55.000
Run Firecracker.

00:47:55.000 --> 00:47:58.000
See what sense Firecracker
can make out of your device.

00:47:58.000 --> 00:48:02.990
Make sure your unique values, vendor ID,
model ID, and so on are all correct.

00:48:03.000 --> 00:48:07.760
If you need some examples for comparison,
Firecracker comes with about eight

00:48:07.830 --> 00:48:11.670
built-in devices that you can
pull up from the file menu just to

00:48:11.680 --> 00:48:14.000
see what other devices look like.

00:48:16.140 --> 00:48:17.840
Finally, this is not a complaint.

00:48:17.840 --> 00:48:19.340
We know you all test
your products carefully.

00:48:19.340 --> 00:48:23.000
Here's just some tips on how to
test them the most effectively.

00:48:23.000 --> 00:48:26.990
As I just described, use Firecracker to
validate your config ROM.

00:48:27.060 --> 00:48:30.110
If Firecracker has error messages
or complaints about bad checksums,

00:48:30.110 --> 00:48:33.000
there's probably something wrong in
your ROM that you need to clean up.

00:48:33.000 --> 00:48:36.000
Another tool in the
SDK is called FireStarter.

00:48:36.000 --> 00:48:40.110
It shows the bus topology and some very
low-level information about the bus,

00:48:40.120 --> 00:48:43.250
and you can use this to check that
all the bits are correct in the

00:48:43.250 --> 00:48:45.000
self-ID packet that your device sends.

00:48:45.000 --> 00:48:48.850
There's going to be more detail on
this in this afternoon's session,

00:48:48.850 --> 00:48:50.000
session 410.

00:48:50.730 --> 00:48:54.580
Another tool built into the SDK,
FWPlug-O-Matic,

00:48:54.610 --> 00:48:57.690
electrically connects and disconnects
the FireWire port from your device,

00:48:57.730 --> 00:49:00.550
so it can simulate the hot
plugging and hot unplugging

00:49:00.610 --> 00:49:02.590
of your device automatically.

00:49:02.670 --> 00:49:04.370
This saves wear and
tear on the connector,

00:49:04.450 --> 00:49:07.440
saves wear and tear on you,
and helps you check for rare

00:49:07.440 --> 00:49:11.590
loading or unloading problems,
memory leaks, and so on.

00:49:12.220 --> 00:49:14.890
As I mentioned before,
try two of your devices or more.

00:49:15.040 --> 00:49:17.200
Put them on the same bus,
get them active at the same time,

00:49:17.200 --> 00:49:19.330
make sure they're really solid
when they're both active.

00:49:21.140 --> 00:49:24.720
Like Ethan mentioned, test, sleep, wake.

00:49:24.740 --> 00:49:26.730
Often we hear people say, oh,
sleep/wake's not

00:49:26.740 --> 00:49:28.900
supported for my product.

00:49:29.090 --> 00:49:31.100
There's no explaining
that to the customer.

00:49:31.310 --> 00:49:32.320
The product sleeps and wakes.

00:49:32.320 --> 00:49:35.680
It's configured out of the box to
fall asleep if you leave it alone.

00:49:35.760 --> 00:49:37.580
Do what Ethan said, support sleep/wake.

00:49:37.720 --> 00:49:38.350
And test it.

00:49:38.460 --> 00:49:39.860
Test it with your device plugged in.

00:49:40.160 --> 00:49:41.740
Test it with your device active.

00:49:42.030 --> 00:49:45.620
People do things like close the lid in
the middle of copying files or printing,

00:49:45.620 --> 00:49:50.310
and your driver can survive that if you
use the right APIs and test it carefully.

00:49:51.780 --> 00:49:54.230
On FireWire,
when a device is plugged in or unplugged

00:49:54.230 --> 00:49:58.100
or certain changes happen in software,
there's an event called a bus reset.

00:49:58.160 --> 00:50:00.250
This is not an error or reason to stop.

00:50:00.300 --> 00:50:01.500
It's just an ordinary event.

00:50:01.500 --> 00:50:03.530
It happens from time to time.

00:50:03.640 --> 00:50:06.360
Nothing bad should happen
when there's a bus reset.

00:50:06.460 --> 00:50:09.290
We have two tools in the SDK that
can generate these so that you

00:50:09.310 --> 00:50:12.540
can easily test your devices
to make sure they keep working.

00:50:12.620 --> 00:50:16.190
FW Busy Bus is really good
at creating bus resets.

00:50:16.250 --> 00:50:18.500
It can generate thousands
per second or less.

00:50:18.500 --> 00:50:20.030
It's very adjustable.

00:50:20.350 --> 00:50:25.050
FW Reset Storm is a little bit gentler,
but maybe a good place to

00:50:25.050 --> 00:50:27.800
start for causing bus resets.

00:50:27.870 --> 00:50:30.110
Busy Bus has some
additional capabilities,

00:50:30.110 --> 00:50:30.730
finally.

00:50:30.840 --> 00:50:35.000
You can use this to rapidly
test your device against traffic

00:50:35.010 --> 00:50:36.820
that comes in over FireWire.

00:50:36.820 --> 00:50:40.800
A simple test would be to just throw
configuration ROM reads at your

00:50:40.850 --> 00:50:42.960
device as fast as the tool can do it.

00:50:43.200 --> 00:50:45.050
That's much faster than
plugging and unplugging your

00:50:45.060 --> 00:50:46.490
device over and over again.

00:50:46.540 --> 00:50:49.540
This tool can literally do
thousands of packets per second.

00:50:49.540 --> 00:50:51.810
If you have a rare problem
responding to these,

00:50:51.840 --> 00:50:53.480
it should pop out pretty quick.

00:50:53.540 --> 00:50:56.290
If you can pass that, try a harder test.

00:50:56.340 --> 00:50:58.790
Configure the tool to send
junk packets to your device.

00:50:58.820 --> 00:51:01.300
This wouldn't happen in practice,
but if you can survive that,

00:51:01.300 --> 00:51:04.170
you can probably handle anything the
user is going to throw against you.

00:51:04.260 --> 00:51:05.850
It's a powerful tool.

00:51:05.860 --> 00:51:06.800
It's in the SDK.

00:51:06.900 --> 00:51:09.260
Give it a try.

00:51:09.910 --> 00:51:12.060
Finally, please participate.

00:51:12.060 --> 00:51:16.200
We have a variety of events and
services to work with developers.

00:51:16.220 --> 00:51:19.740
Tonight at the Apple campus,
there's a Plugfest.

00:51:19.740 --> 00:51:22.900
It's combined FireWire, USB, and Bonjour.

00:51:22.910 --> 00:51:25.490
We'll have a lot of the engineers there,
a lot of the devices,

00:51:25.500 --> 00:51:27.300
all the tools I've talked
about will be available.

00:51:27.300 --> 00:51:28.400
You can try them out.

00:51:28.650 --> 00:51:31.800
There's also something
about a band and free beer,

00:51:31.800 --> 00:51:33.570
but come to the Plugfest.

00:51:34.430 --> 00:51:36.390
Okay,
we have a public mailing list where we

00:51:36.390 --> 00:51:39.950
answer your questions about FireWire,
and even better, you answer each other's

00:51:39.950 --> 00:51:41.290
questions about FireWire.

00:51:41.300 --> 00:51:45.300
The details are in the SDK,
so you don't have to copy them down here.

00:51:45.300 --> 00:51:49.080
And the 1394 Trade Association is
a worldwide organization of

00:51:49.090 --> 00:51:52.300
130 companies that all make
some kind of FireWire device.

00:51:52.300 --> 00:51:56.300
It's a great resource for
meeting engineers and designers,

00:51:56.300 --> 00:51:59.300
people responsible for the standard,
a lot of creative ideas.

00:51:59.300 --> 00:52:02.100
They run their own plugfests,
they have quarterly meetings,

00:52:02.100 --> 00:52:04.110
technical working groups, mailing lists.

00:52:04.300 --> 00:52:07.540
If you're serious about making devices,
you should join the Trade Association and

00:52:07.540 --> 00:52:10.300
tap the many services that they offer.

00:52:11.340 --> 00:52:13.450
Okay,
if you need more information about any

00:52:13.450 --> 00:52:17.190
of the topics that we discussed today,
you can contact Craig Keithley.

00:52:17.340 --> 00:52:21.750
He is the technology evangelist
just for I/O in general.

00:52:21.930 --> 00:52:25.940
You can also find the documentation,
the sample code, the source code,

00:52:25.970 --> 00:52:30.740
and other resources from these
sessions all at the WWDC 2006 site.

00:52:32.900 --> 00:52:35.580
Okay, with that I'm going to,
oh I'm sorry, there's one more.

00:52:35.600 --> 00:52:39.880
There is a lab tomorrow
morning from 9 to 11,

00:52:39.880 --> 00:52:43.340
and there is the beer bash,
I mean plugfest,

00:52:43.340 --> 00:52:45.300
that I already mentioned,
and that's tonight back at Apple.
WEBVTT

00:00:10.220 --> 00:00:13.340
Welcome to session 411,
Designing for Security.

00:00:13.340 --> 00:00:16.260
We've got a lot of very exciting
things to tell you about today.

00:00:16.260 --> 00:00:18.360
There's going to be two presenters.

00:00:18.360 --> 00:00:21.420
Conrad Sauerwald from the
Data Security Group will

00:00:21.530 --> 00:00:24.450
be talking first,
and then I'll be taking the latter

00:00:24.520 --> 00:00:29.230
half of the session and talking
about some other exciting things.

00:00:29.260 --> 00:00:30.100
So here's what we're going to cover.

00:00:30.100 --> 00:00:32.940
We're only going to be
highlighting some key points.

00:00:32.940 --> 00:00:35.560
We don't have a lot of time
to go into great detail.

00:00:37.060 --> 00:00:40.200
We're going to talk about system
facilities and techniques you can use,

00:00:40.200 --> 00:00:43.180
and hopefully we'll give you some
takeaway points that will at least

00:00:43.580 --> 00:00:45.850
help you with some of your issues.

00:00:45.860 --> 00:00:47.980
So here are the areas
we're going to cover.

00:00:47.980 --> 00:00:52.780
We're going to cover data security,
then system security, secure coding,

00:00:52.780 --> 00:00:55.920
and then we're going to talk
about process sandboxing,

00:00:55.920 --> 00:00:59.740
which is a technology preview of
what we hope to put into Leopard.

00:00:59.740 --> 00:01:01.970
So here we go.

00:01:02.010 --> 00:01:03.730
I'd like to introduce
you to Conrad Sauerwald,

00:01:03.870 --> 00:01:05.140
who's going to talk about data security.

00:01:11.140 --> 00:01:11.700
Hello there.

00:01:11.710 --> 00:01:15.430
So I'm first going to talk about a
topic that doesn't come to mind that

00:01:15.490 --> 00:01:18.520
quickly when people talk about security,
which is data security.

00:01:18.520 --> 00:01:21.280
When you say security,
you're often immediately looking

00:01:21.290 --> 00:01:23.640
at buffer overflows and such.

00:01:23.640 --> 00:01:26.340
And while, you know, as a user,
you prefer that your

00:01:26.340 --> 00:01:28.140
system runs smoothly,
beyond that,

00:01:28.350 --> 00:01:31.920
if you start getting a little bit
into the user's perspective on things,

00:01:31.920 --> 00:01:35.760
you actually start looking at the user's
data and seeing how that is actually

00:01:35.760 --> 00:01:39.630
really valuable and not that often
thought of when we talk about security.

00:01:39.640 --> 00:01:40.540
So,

00:01:42.670 --> 00:01:46.320
The topic obviously ought to be like
you're writing an application and

00:01:46.320 --> 00:01:47.900
you're managing the user's data.

00:01:47.900 --> 00:01:49.910
What can you do to keep that data safe?

00:01:50.000 --> 00:01:53.440
So, first question,
do you manage sensitive data?

00:01:53.440 --> 00:01:55.790
Well, you know,
that's kind of a question that has

00:01:55.790 --> 00:01:59.790
multiple answers because obviously
often you will have data that can be

00:01:59.790 --> 00:02:02.380
sensitive and other times it may not be.

00:02:03.720 --> 00:02:06.420
It really depends on what the
user may do with your application.

00:02:06.420 --> 00:02:09.390
If you write a word processor, well,
you know, they are obviously going to

00:02:09.390 --> 00:02:11.730
write a sensitive document
with it at some point in time,

00:02:11.740 --> 00:02:14.960
but it may not necessarily be like
the core strength of your application.

00:02:14.960 --> 00:02:19.270
In those cases, users have, of course,
the possibility of using the built-in

00:02:19.270 --> 00:02:22.960
facilities like FileVault and
encrypted disk images to take care of

00:02:22.960 --> 00:02:25.240
keeping their data safe themselves.

00:02:25.240 --> 00:02:30.650
Beyond that, applications may not just
manage the actual content,

00:02:30.650 --> 00:02:33.380
the actual data to be kept safe.

00:02:33.500 --> 00:02:33.560
So, the key chain is a key chain
that is stored in the key chain.

00:02:33.560 --> 00:02:33.600
So, the key chain is a key chain
that is stored in the key chain.

00:02:33.600 --> 00:02:37.980
But also passwords, symmetric keys,
and more these days as well,

00:02:38.030 --> 00:02:42.040
public-private key pairs or
identities for the user that they

00:02:42.040 --> 00:02:47.030
use to use certain services and that
can then be stored in the key chain.

00:02:47.040 --> 00:02:51.000
To go a little bit beyond using
a key chain for passwords,

00:02:51.000 --> 00:02:54.760
the benefit of keeping
identities in there as well is,

00:02:54.790 --> 00:02:58.080
of course,
that if you use a public-private key

00:02:58.080 --> 00:03:02.090
pair that is stored in the key chain,
then the actual crypto can be

00:03:02.100 --> 00:03:03.470
done in the security service.

00:03:03.500 --> 00:03:06.130
So, that the secret is never given out.

00:03:06.150 --> 00:03:07.900
So,
that is an extra strength of using the

00:03:07.900 --> 00:03:09.620
key chain for those types of things.

00:03:09.620 --> 00:03:14.840
Now, beyond that, you may go like, well,
that's all great and nice,

00:03:14.840 --> 00:03:17.520
but why don't I just roll my own?

00:03:17.520 --> 00:03:20.260
Well,
we really want to discourage you from

00:03:20.260 --> 00:03:22.620
doing that because it's just hard.

00:03:22.620 --> 00:03:26.630
So, I'm going to go through a couple of
slides and try to give you a better

00:03:26.630 --> 00:03:30.620
perspective on what we offer and what
things you'd need to take care of in

00:03:30.740 --> 00:03:33.200
case you actually think of doing this.

00:03:33.500 --> 00:03:39.400
So, first one, that's really one that
you cannot stay away from.

00:03:39.400 --> 00:03:40.600
It's like the data handling.

00:03:40.600 --> 00:03:43.860
Once you hold the sensitive data,
you've got to make sure that

00:03:43.860 --> 00:03:46.840
there's no traces left behind,
and this is really hard to

00:03:46.860 --> 00:03:50.060
do because often you'll take
a piece of sensitive data,

00:03:50.060 --> 00:03:53.400
you'll use it through an API,
it creates a nice object for you.

00:03:53.400 --> 00:03:55.680
You didn't get to say
what allocator to use,

00:03:55.720 --> 00:03:58.880
how this was going to be stored,
and when you say like, hey,

00:03:58.880 --> 00:04:02.420
this object I no longer need it,
how is it going to be cleaned up?

00:04:02.500 --> 00:04:03.480
So, yeah.

00:04:03.560 --> 00:04:07.110
That's a really hard area,
and the only reasonable possibility

00:04:07.370 --> 00:04:11.600
you have right now to handle that is
really system-wide and just turn on

00:04:11.600 --> 00:04:16.530
secure VM to make sure that anything
gets swapped out to disk gets encrypted.

00:04:16.540 --> 00:04:20.280
But beyond that,
you get into areas where if you're

00:04:20.280 --> 00:04:25.420
rolling your own and you have a
deficiency in your protection scheme,

00:04:25.420 --> 00:04:27.220
well, there you go.

00:04:27.220 --> 00:04:30.140
There's a big portion of maintenance
for you as well as now you're

00:04:30.140 --> 00:04:33.480
dealing with the key material
yourself instead of having security.

00:04:33.480 --> 00:04:36.050
So, you've got to have security server,
as I mentioned,

00:04:36.160 --> 00:04:39.330
when you use it through the key chain
as a third process that can handle this

00:04:39.330 --> 00:04:42.920
so that it only gives you results that
were produced out of using this key.

00:04:44.860 --> 00:04:49.060
So why use the system facilities?

00:04:49.170 --> 00:04:51.910
First of all, this is a lot of work.

00:04:51.920 --> 00:04:53.520
It's a lot of code to write.

00:04:53.790 --> 00:04:56.690
Now, once you're done with writing it,
the next step comes,

00:04:56.720 --> 00:04:58.490
which is really testing this whole stuff.

00:04:58.500 --> 00:05:01.820
And testing is actually not as
simple as you test your application.

00:05:01.820 --> 00:05:04.040
Your application works
or it doesn't work.

00:05:04.140 --> 00:05:07.270
Testing it also becomes partially
seeing if you can break it,

00:05:07.300 --> 00:05:09.740
if you can circumvent it
and all these other things.

00:05:09.740 --> 00:05:13.940
And that's going to add to the
time that it takes to test it.

00:05:14.080 --> 00:05:15.660
And then, of course,
there's the maintenance.

00:05:15.660 --> 00:05:18.600
And maintenance is not just
make sure that it works,

00:05:18.720 --> 00:05:22.360
but you're working with a lot of
stuff that changes in the world.

00:05:22.380 --> 00:05:25.460
Certain hashes are suddenly
not that good anymore.

00:05:25.460 --> 00:05:29.710
Now you sign up for the work of keeping
this secure and trying to run that

00:05:29.930 --> 00:05:33.860
arms race with what is secure today.

00:05:33.890 --> 00:05:37.950
So system facilities then also
provide all of their stuff through

00:05:37.950 --> 00:05:39.660
an API that kind of hangs around.

00:05:39.660 --> 00:05:43.110
And it goes through multiple versions
of your application that you roll.

00:05:43.240 --> 00:05:44.820
So it will always be there.

00:05:44.820 --> 00:05:48.290
And as it improves,
it will try to implement the best it

00:05:48.330 --> 00:05:54.540
can do on the back end while you just
have this one API to work towards.

00:05:54.540 --> 00:05:58.370
Another positive aspect of putting
passwords in the key chain is that

00:05:58.660 --> 00:06:02.610
when people start using a particular
application and they use a username

00:06:02.610 --> 00:06:06.280
password to connect to a particular
server for some service that they use,

00:06:06.280 --> 00:06:07.880
then they switch to a
different application.

00:06:07.880 --> 00:06:10.140
Say you've created a much
better application that

00:06:10.140 --> 00:06:12.110
they'd really like to use.

00:06:12.240 --> 00:06:12.360
If the password is already
in the application,

00:06:12.360 --> 00:06:12.960
then you can use it.

00:06:12.960 --> 00:06:13.960
If the password is
already in the key chain,

00:06:13.960 --> 00:06:16.220
it actually makes it really
easy for the user to just say,

00:06:16.220 --> 00:06:18.710
like, it's okay that that
application starts using it,

00:06:18.710 --> 00:06:18.990
too.

00:06:19.000 --> 00:06:19.880
They'll get a dialogue.

00:06:19.900 --> 00:06:22.830
They can say that's okay
and then be on their way.

00:06:22.860 --> 00:06:26.160
So that's a good usability aspect.

00:06:26.360 --> 00:06:30.620
And the other thing that even if
you build a whole security system,

00:06:30.620 --> 00:06:34.330
the one thing that you probably don't
have time for is to also scale it,

00:06:34.340 --> 00:06:38.060
make it appropriate for your audience.

00:06:38.110 --> 00:06:40.960
If you look at a
standard install of OS X,

00:06:40.960 --> 00:06:45.340
the first thing that happens is
you have an auto logged in account.

00:06:45.340 --> 00:06:48.510
Well, it's all great and all,
but your key chain is now unlocked and

00:06:48.510 --> 00:06:51.560
that may be perfect for you because
you're not connected to a network.

00:06:51.560 --> 00:06:53.010
You don't really care.

00:06:53.020 --> 00:06:58.240
Now, if the user decides, like,
I have a funny feeling about this,

00:06:58.240 --> 00:07:00.800
I'd really like to just
have a password to log in,

00:07:00.800 --> 00:07:02.320
they can turn auto login off.

00:07:02.330 --> 00:07:04.800
As you continue,
you can start setting stricter

00:07:04.800 --> 00:07:07.770
access control lists on the items
so that applications that want

00:07:07.770 --> 00:07:11.460
to use your passwords at least
show up as trying to use it.

00:07:11.680 --> 00:07:14.510
And from there on out,
you can start having multiple

00:07:14.560 --> 00:07:19.040
key chains to have different
classes of information that have

00:07:19.040 --> 00:07:21.740
different strengths of passwords.

00:07:21.790 --> 00:07:23.500
One can be a simple one
you can type easily.

00:07:23.500 --> 00:07:26.340
One can be a much longer one
that you don't use that often,

00:07:26.340 --> 00:07:29.850
and then it all remains usable.

00:07:30.110 --> 00:07:34.720
So if that doesn't scare you
and you're continuing on,

00:07:34.720 --> 00:07:38.820
let me point out a couple of more
things that you run into while

00:07:38.820 --> 00:07:40.800
you're implementing this yourself.

00:07:40.850 --> 00:07:45.410
I mean, obviously you can read up on this
because every system that's out

00:07:45.520 --> 00:07:49.620
there has been written about to
prove to the world that this is it,

00:07:49.620 --> 00:07:50.700
this works.

00:07:50.700 --> 00:07:53.550
Everyone has seen this,
so I'm pretty sure that

00:07:53.570 --> 00:07:55.640
there's no problems with this.

00:07:55.660 --> 00:07:58.190
But that's a lot of work.

00:07:58.220 --> 00:08:01.480
The second one is that--

00:08:02.280 --> 00:08:04.960
Cryptographic protocols go
through a lot of revisions.

00:08:04.960 --> 00:08:09.110
Most of the protocols we use today
have had changes happen to them,

00:08:09.110 --> 00:08:10.980
and you have to go
through those revisions.

00:08:10.980 --> 00:08:12.870
This goes back to that maintenance work.

00:08:13.060 --> 00:08:16.010
After you implement the first one,
there's the second one that

00:08:16.140 --> 00:08:17.420
you already have to do.

00:08:19.450 --> 00:08:21.370
Third one, you may want to make it easy.

00:08:21.370 --> 00:08:23.860
A user can enter a password
to use this service.

00:08:23.920 --> 00:08:24.950
Well, that's great.

00:08:24.950 --> 00:08:27.340
Passwords are, however,
not good key material.

00:08:27.340 --> 00:08:30.240
You have to do something with
that password to make it good.

00:08:30.240 --> 00:08:32.640
I mean, someone can type an
utterly long password,

00:08:32.640 --> 00:08:34.260
but that doesn't make it a key yet.

00:08:39.050 --> 00:08:42.120
I'm going to skip the password-based
key derivation function for the

00:08:42.190 --> 00:08:46.670
moment and just continue on saying,
like, if you have, like,

00:08:46.670 --> 00:08:49.700
a lot of data lying around, like, say,
like a file vault image,

00:08:49.700 --> 00:08:52.020
and the user decides, you know,
I don't like my password.

00:08:52.020 --> 00:08:53.080
I really want to change it.

00:08:53.150 --> 00:08:55.490
You really want to
deal with a master key,

00:08:55.490 --> 00:08:59.470
a key that actually encrypts the data,
where the user's password only

00:08:59.470 --> 00:09:01.610
gives access to this master key.

00:09:03.400 --> 00:09:09.550
So, beyond that though,
some of you may not be looking to

00:09:09.550 --> 00:09:11.960
really just write all of the system.

00:09:11.960 --> 00:09:15.440
You are just coming to the platform
with a bunch of code that needs

00:09:15.440 --> 00:09:17.590
to use some basic algorithms.

00:09:17.600 --> 00:09:23.680
And we've obviously advertised CDSA many
years as a very generic API through

00:09:23.680 --> 00:09:28.360
which you can select whatever algorithms
you want to use for doing all your

00:09:28.360 --> 00:09:30.760
hashing and your encryption purposes.

00:09:30.760 --> 00:09:33.740
But that is not a very
drop-in replacement,

00:09:33.740 --> 00:09:37.100
not something that's
very convenient to use.

00:09:37.100 --> 00:09:43.850
As CDSA was used through the system,
obviously it goes to many lower levels.

00:09:43.880 --> 00:09:46.270
And at these lower levels,
you don't want all that

00:09:46.280 --> 00:09:48.120
complexity of the stack anyway.

00:09:48.120 --> 00:09:49.930
You actually want some
more raw performance.

00:09:49.940 --> 00:09:53.260
So, out of all of that,
we've basically distilled the

00:09:53.260 --> 00:09:57.160
algorithms and pushed them all
the way down to Common Crypto,

00:09:57.160 --> 00:10:00.730
which is actually a
library that becomes part.

00:10:00.760 --> 00:10:04.200
It's a sort of lib system
that contains the algorithms.

00:10:04.200 --> 00:10:07.510
Now, the rest of the system actually
uses this same library.

00:10:07.830 --> 00:10:10.360
So, you know, it's already there.

00:10:10.360 --> 00:10:12.040
You don't have to link
in another library.

00:10:12.040 --> 00:10:14.900
You don't get into, you know,
link another library that you

00:10:14.900 --> 00:10:16.270
have to stay compatible with.

00:10:16.520 --> 00:10:17.950
It's just there.

00:10:18.060 --> 00:10:19.970
And it contains algorithms.

00:10:20.390 --> 00:10:25.230
Since Tiger has had cryptographic
secure hashing algorithms in there,

00:10:25.240 --> 00:10:27.320
you may remember
Common Digest from there.

00:10:27.320 --> 00:10:30.310
For Leopard, we've added,
and this is actually on the seed already,

00:10:30.380 --> 00:10:32.320
HMeching.

00:10:32.320 --> 00:10:36.430
So, if you're choosing to use hashing
as a method of authenticating,

00:10:36.440 --> 00:10:40.320
like, a piece of text that you want
to do integrity checking on,

00:10:40.570 --> 00:10:42.320
you want to use HMeching.

00:10:42.320 --> 00:10:44.280
And encryption.

00:10:44.360 --> 00:10:46.320
The API is generally pretty
much compatible with OpenSSL.

00:10:46.320 --> 00:10:50.320
It's just, you know, initialize,
feed data, final step.

00:10:50.320 --> 00:10:52.310
That's it.

00:10:52.320 --> 00:10:56.440
To contrast Common Crypto to OpenSSL a
little bit and give you an idea of

00:10:56.790 --> 00:10:59.030
what our thoughts are around that,
OpenSSL will obviously be

00:10:59.060 --> 00:10:59.880
a little bit more complex.

00:10:59.880 --> 00:11:01.880
It's there for portability.

00:11:01.880 --> 00:11:03.860
You know,
some of the algorithms we also provide,

00:11:03.900 --> 00:11:05.710
some of them we don't.

00:11:05.970 --> 00:11:09.870
Depending on your application,
it can be much easier just to use it.

00:11:09.920 --> 00:11:13.880
It does, however,
come with the out-of-the-box performance.

00:11:13.880 --> 00:11:17.510
We have the benefit of looking
in Common Crypto and seeing,

00:11:17.510 --> 00:11:20.880
like, what alternative implementations
of these algorithms have been

00:11:20.880 --> 00:11:21.880
done that are possibly faster.

00:11:21.880 --> 00:11:25.560
We have ways of modifying
it to our own content,

00:11:25.720 --> 00:11:26.780
so to speak.

00:11:26.880 --> 00:11:29.430
And the last one is really important.

00:11:29.440 --> 00:11:31.440
The first one is really a
public service announcement.

00:11:31.440 --> 00:11:34.860
If you are using OpenSSL,
OpenSSL has recently changed

00:11:34.860 --> 00:11:37.440
from a version 0.9.4.

00:11:37.440 --> 00:11:39.560
Well, not recently,
but we've recently updated

00:11:39.560 --> 00:11:41.440
to 0.9.7 from 0.9.4.

00:11:41.440 --> 00:11:45.440
And unfortunately,
those are not API-compatible,

00:11:45.440 --> 00:11:49.440
although there is another SIM link
that points to a 0.9 version.

00:11:49.440 --> 00:11:51.280
So technically,
that should have been a major version.

00:11:51.440 --> 00:11:55.430
So you may run into some linking
issues as you go from Tiger to Leopard

00:11:55.470 --> 00:11:57.570
if you're currently using Libcrypto.

00:11:58.420 --> 00:12:03.890
With that, I want to quickly show you
the new APIs that we have.

00:12:04.060 --> 00:12:08.020
So for encryption, we obviously offer the
basic suite of algorithms.

00:12:08.020 --> 00:12:12.620
One thing about all the algorithms that
are in here that I want to make clear

00:12:12.660 --> 00:12:15.540
is they're there for older purposes,
too.

00:12:15.540 --> 00:12:18.430
If you just happen to need
some really ancient algorithm,

00:12:18.430 --> 00:12:20.760
it's in there, too, just for that reason.

00:12:20.760 --> 00:12:23.380
It's not something that we
recommend over the other ones.

00:12:23.380 --> 00:12:26.340
You still need to do your homework and
figure out which ones you want to use.

00:12:27.640 --> 00:12:30.820
When you use encryption,
it also turns on cipher block chaining

00:12:30.820 --> 00:12:33.050
per default for the block cipher status.

00:12:33.050 --> 00:12:37.330
There is still the common mode
in there that avoids the block

00:12:37.330 --> 00:12:41.980
cipher chaining if you want to
implement alternate encryption modes.

00:12:41.980 --> 00:12:45.660
And if you want to use it,
it also provides padding in case the

00:12:45.660 --> 00:12:49.630
amount of data that you're trying
to encrypt basically will never

00:12:49.630 --> 00:12:53.660
be like exactly a multiple of the
block size of your block cipher.

00:12:53.660 --> 00:12:57.890
So padding takes care of that
to basically put in the message

00:12:58.150 --> 00:13:03.600
some pointer to kind of suggest
what the actual size is.

00:13:03.740 --> 00:13:08.670
Now, you don't really have to understand
that because as you use this,

00:13:08.750 --> 00:13:12.920
there is the get output length
function that will tell you

00:13:13.240 --> 00:13:15.000
what the actual length was,
and that will look at

00:13:15.070 --> 00:13:15.910
the padding for you.

00:13:15.910 --> 00:13:20.240
Now, if you are trying to encrypt
something and you are worried

00:13:20.240 --> 00:13:22.790
about the data handling,
as I mentioned earlier,

00:13:22.790 --> 00:13:25.630
there is also a way for you to
provide the data that's going

00:13:25.630 --> 00:13:28.090
to be used in the context.

00:13:29.190 --> 00:13:34.530
So the one that you already know
from Tiger is that we have the

00:13:34.530 --> 00:13:36.500
secure hashing functions in there.

00:13:36.500 --> 00:13:40.130
The difference is that that one was
named with the actual algorithms in

00:13:40.130 --> 00:13:43.860
the name instead of actually taking
that as a parameter in the init.

00:13:43.860 --> 00:13:46.760
The more important thing
that I wanted to point out,

00:13:46.820 --> 00:13:50.370
if you have a program that already
uses OpenSSL and you just want

00:13:50.370 --> 00:13:54.380
to give Common Crypto a role,
if you do a pound define of Common Digest

00:13:54.450 --> 00:13:58.040
for OpenSSL and then include that file,
it will actually define some aliases,

00:13:58.580 --> 00:14:02.910
which will make, like all the invocations
of OpenSSL that we support,

00:14:02.920 --> 00:14:06.600
actually directly go through
Common Crypto instead.

00:14:07.210 --> 00:14:08.960
And last, of course, HMAC.

00:14:09.100 --> 00:14:11.490
Not much to mention about that.

00:14:11.560 --> 00:14:15.090
The common digests are all included.

00:14:15.400 --> 00:14:19.060
So that is all I have for data security.

00:14:19.060 --> 00:14:23.180
Let me continue with system
security a little bit.

00:14:23.290 --> 00:14:27.220
Now, the one bug to destroy it all
sounds a little bit cynical,

00:14:27.220 --> 00:14:30.940
but if you look at it, you know,
it starts really with the whole story.

00:14:30.940 --> 00:14:33.060
Your system is as secure as the whole is.

00:14:33.060 --> 00:14:35.700
So, you know,
you only have to find that weakest link.

00:14:35.700 --> 00:14:39.280
And if you're writing some secure system,
everyone is looking for it.

00:14:39.350 --> 00:14:44.920
So it rings true when you are trying
to write a crypto system or you're even

00:14:44.920 --> 00:14:48.780
just trying to deal with the use of,
like, resources and operations

00:14:48.800 --> 00:14:50.100
that are restricted.

00:14:50.100 --> 00:14:57.140
So I'm going to show you a couple of
example system services that actually

00:14:57.140 --> 00:15:01.300
do some of this handling through
trampolines to give you an idea of how we

00:15:01.300 --> 00:15:05.990
already support access to some of these
privileged resources and operations that

00:15:06.040 --> 00:15:10.620
you can also use without having to write
your own programs to deal with those.

00:15:10.620 --> 00:15:14.100
And after that,
I will go into a more general description

00:15:14.100 --> 00:15:20.060
of how you can start your application to
have basically a similar architecture.

00:15:20.700 --> 00:18:38.300
[Transcript missing]

00:18:39.470 --> 00:18:43.470
So let's have a look at how you
would structure your own application,

00:18:43.540 --> 00:18:48.490
and maybe it gets a little clearer on
how we arrived at this trampoline model.

00:18:48.550 --> 00:18:51.140
So in the beginning,
there's your application.

00:18:51.190 --> 00:18:51.630
It's nice.

00:18:51.640 --> 00:18:52.090
It's happy.

00:18:52.130 --> 00:18:53.300
It's sitting there.

00:18:53.300 --> 00:18:55.420
But you want to use a
resource or an operation,

00:18:55.420 --> 00:18:58.680
and those are technically
limited because,

00:18:58.730 --> 00:19:01.730
well, otherwise we wouldn't
be talking about this.

00:19:01.870 --> 00:19:05.790
So as your application needs to
access this resource or operation,

00:19:05.790 --> 00:19:09.150
well, the most obvious thing is like,
hey, let's run it with privileges.

00:19:09.350 --> 00:19:10.370
Oops.

00:19:10.520 --> 00:19:12.680
This is a big application.

00:19:12.680 --> 00:19:14.610
It contains a lot of code.

00:19:14.670 --> 00:19:18.320
As you remember in the beginning,
I talked about having one bug in the

00:19:18.390 --> 00:19:20.740
system is going to take everything down.

00:19:20.740 --> 00:19:24.320
Well, that application is a pretty
big system right there.

00:19:24.320 --> 00:19:24.320
So

00:19:25.350 --> 00:19:27.130
This privilege is very crude.

00:19:27.130 --> 00:19:29.470
You have the privileges
or you don't have them.

00:19:29.480 --> 00:19:32.720
You cannot really temporarily turn
them off securely and then just

00:19:32.720 --> 00:19:34.780
regain them at a later point in time.

00:19:34.780 --> 00:19:37.540
That's just the reality of the
system we deal with right now.

00:19:37.650 --> 00:19:41.420
But if you look through your application,
you can probably iterate through

00:19:41.420 --> 00:19:44.750
the right items in there that
actually need these privileges.

00:19:44.790 --> 00:19:48.900
You can define the operations that you
need to do that require the privileges.

00:19:49.640 --> 00:19:53.390
So if you structure your application
such that you can identify

00:19:53.390 --> 00:19:56.500
those as individual functions,
like do it here,

00:19:56.500 --> 00:20:01.320
then you can start lifting them out
and putting them in a separate process.

00:20:01.320 --> 00:20:04.380
So we put them in a tool and we
move them out of the application.

00:20:04.380 --> 00:20:08.180
And now the application can run
without these privileges again.

00:20:08.180 --> 00:20:11.250
The tool is the one that
has the privileges and that

00:20:11.250 --> 00:20:12.990
will do some limited work.

00:20:12.990 --> 00:20:16.780
It has a limited amount of code,
so it's easier for you to audit that

00:20:16.780 --> 00:20:19.460
it will behave as you expect it to.

00:20:20.950 --> 00:20:23.240
Now, as you move it out,
there is another point that

00:20:23.250 --> 00:20:24.780
you need to take into account.

00:20:24.800 --> 00:20:29.310
Your application may have been
linking with an external framework.

00:20:29.380 --> 00:20:31.170
And, you know,
these frameworks generally,

00:20:31.180 --> 00:20:33.700
when you start with an application,
are fairly high level.

00:20:33.700 --> 00:20:37.000
High level applications
are nice and flexible.

00:20:37.000 --> 00:20:39.630
They have, like,
lots of functions and they have lots

00:20:39.700 --> 00:20:44.040
of interesting implicit behavior
that you maybe did not know about.

00:20:44.040 --> 00:20:46.260
So, when you're trying to
create an application,

00:20:46.280 --> 00:20:48.360
or in this case,
the tool with the privileges

00:20:48.360 --> 00:20:51.640
to operate in a way that,
you know, you accept,

00:20:51.640 --> 00:20:53.040
it's going to be hard.

00:20:53.060 --> 00:20:55.420
So, the framework in the application,
that's just fine.

00:20:55.420 --> 00:20:58.960
But if you move that tool out and have
that tool use a high level framework,

00:20:58.960 --> 00:21:00.960
you're in for a lot of ugly surprises.

00:21:00.960 --> 00:21:03.600
So,
you have to try to keep that tool limited

00:21:03.600 --> 00:21:06.050
to using the lower level frameworks.

00:21:06.060 --> 00:21:10.090
I cannot really give you, like,
a safe frameworks list because

00:21:10.130 --> 00:21:11.960
we don't really keep one.

00:21:11.960 --> 00:21:13.970
But you can see, you know,
what's going on.

00:21:14.060 --> 00:21:17.400
the reality is on the
system as it exists.

00:21:18.520 --> 00:21:21.680
So let's move that resource or
operation thing out of the way for

00:21:21.770 --> 00:21:24.870
a second because the tool has kind
of taken its place as being the one

00:21:24.870 --> 00:21:27.860
that has the privileges and that we
have to focus on for a little bit.

00:21:27.990 --> 00:21:31.240
So now that the tool is
outside of the application,

00:21:31.300 --> 00:21:34.520
we have one other thing
that we have to fix here,

00:21:34.520 --> 00:21:37.100
and that is, well,
the application needs to make

00:21:37.190 --> 00:21:38.930
sure that it talks to this tool.

00:21:38.940 --> 00:21:42.100
It needs to make sure that it is
talking to the tool that it expects

00:21:42.100 --> 00:21:43.920
to do the work that it wants to do.

00:21:43.920 --> 00:21:46.010
There has to be a relation
where the application knows

00:21:46.010 --> 00:21:47.270
who's going to do this work.

00:21:47.900 --> 00:21:51.960
And on the other side, the tool,
of course, has to go ahead and see, like,

00:21:51.970 --> 00:21:54.370
well, who am I doing this for?

00:21:54.380 --> 00:21:56.420
It now completely lost context.

00:21:56.420 --> 00:21:57.630
It's out there by itself.

00:21:57.740 --> 00:21:59.360
It doesn't know who it's working for.

00:21:59.360 --> 00:22:03.130
So somehow the tool has to also
be given a form of context so

00:22:03.210 --> 00:22:07.230
that when it authorizes operations
or authenticates people that it

00:22:07.230 --> 00:22:08.860
knows who I'm doing this for.

00:22:08.860 --> 00:22:13.180
So let's talk a little bit about
this inter-process communication.

00:22:14.610 --> 00:22:16.670
There's a bunch of
low-level communication

00:22:16.670 --> 00:22:18.220
mechanisms that you can use.

00:22:18.220 --> 00:22:20.780
Now,
one that I already described a little

00:22:20.780 --> 00:22:24.790
bit and I will go into now is the one
where you can inherit a file descriptor.

00:22:24.800 --> 00:22:30.140
Now, if I make this tool such that my
application launches the tool,

00:22:30.140 --> 00:22:33.600
then I have the parent-child
relationship through which I can

00:22:33.600 --> 00:22:35.520
gain a little bit of information.

00:22:35.620 --> 00:22:39.190
But one other thing that is possible
in those situations is that if the

00:22:39.190 --> 00:22:42.620
application opened the file descriptor
to a file that does not have a

00:22:42.620 --> 00:22:45.060
backing store in the file system,
it can have put some

00:22:45.060 --> 00:22:46.010
information in there.

00:22:46.020 --> 00:22:49.350
Now, that information is only accessible
through this file descriptor,

00:22:49.400 --> 00:22:53.720
and as you execute into the tool,
the file descriptor goes to the tool,

00:22:53.720 --> 00:22:55.090
and the tool can now also read it.

00:22:55.150 --> 00:22:58.260
So if the two have an agreement
that the application writes it in,

00:22:58.260 --> 00:23:00.750
starts the tool,
and the tool can read it out again,

00:23:00.750 --> 00:23:03.720
then you have a way of passing
some information through.

00:23:05.160 --> 00:23:09.610
One particular instance that uses
this is the authorization execute

00:23:09.610 --> 00:23:11.340
with privileges trampoline.

00:23:11.340 --> 00:23:15.340
And, of course,
this is all in the Darwin sources,

00:23:15.340 --> 00:23:18.300
so if you want to have a look
at how that would work for real,

00:23:18.300 --> 00:23:19.550
you can have a look at that one.

00:23:19.580 --> 00:23:26.650
Another mechanism you can use is
communicating over Unix domain sockets.

00:23:27.390 --> 00:23:32.500
Now, this has very limited possibilities.

00:23:32.500 --> 00:23:34.270
It's a little bit better
than a file descriptor,

00:23:34.320 --> 00:23:37.160
which really is kind of
a one-shot operation.

00:23:37.230 --> 00:23:41.100
While communicating over domain sockets,
at least you can keep a couple

00:23:41.100 --> 00:23:47.400
of sessions going and you can
go through a couple of commands.

00:23:48.080 --> 00:23:51.310
With that, though,
you have the opportunity of

00:23:51.590 --> 00:23:53.410
finding out who your client is.

00:23:53.410 --> 00:23:56.060
Because if you use, for example,
a streaming socket,

00:23:56.110 --> 00:23:58.300
which is the one that you
have to use to get this,

00:23:58.300 --> 00:24:00.810
local credentials can be passed along.

00:24:00.950 --> 00:24:04.290
So your tool getting this request
can actually figure out what the

00:24:04.290 --> 00:24:08.420
UID was of the user on the other side
that asked you to do this operation.

00:24:10.950 --> 00:24:13.150
A much higher level one,
and you notice that I'm

00:24:13.150 --> 00:24:16.700
skipping Mach messaging here,
is distributed objects.

00:24:16.700 --> 00:24:19.740
That's a very high level tool.

00:24:19.740 --> 00:24:23.330
I put it on here not as a glowing
recommendation of trying this out,

00:24:23.330 --> 00:24:26.290
but that's one that you may
already be familiar with.

00:24:27.520 --> 00:24:30.180
The unfortunate problem with it is
that it's so flexible that for you

00:24:30.180 --> 00:24:34.040
to try to use it safely requires a
lot of research and a lot of work,

00:24:34.130 --> 00:24:35.420
so it's very, very tricky.

00:24:35.420 --> 00:24:41.020
If you don't note them into every detail,
it's going to be hard because, well,

00:24:41.020 --> 00:24:42.840
it's a very flexible system.

00:24:42.840 --> 00:24:45.390
You send messages,
they get delivered to whoever

00:24:45.390 --> 00:24:47.100
actually can implement them.

00:24:49.280 --> 00:24:50.940
Do you know whether you're
talking to the proxy?

00:24:50.940 --> 00:24:52.510
Are you talking to the real object?

00:24:52.520 --> 00:24:58.380
As you find beyond that is, of course,
that these invocations are

00:24:58.390 --> 00:25:00.020
very much unstructured.

00:25:00.020 --> 00:25:03.420
Anything could be sent across,
but you want to make sure that only

00:25:03.420 --> 00:25:06.560
the things that you allow in your
protocol actually can send across.

00:25:06.560 --> 00:25:08.520
And for that,
you'd have to use a protocol checker.

00:25:08.630 --> 00:25:12.250
That, in short,
is my recommendation against it.

00:25:12.290 --> 00:25:15.820
All in all,
this is really about trying to secure

00:25:15.820 --> 00:25:18.680
the endpoints of this authentication.

00:25:19.510 --> 00:25:23.620
Between these two parties,
and for the server to find the tool,

00:25:23.620 --> 00:25:25.840
and for the tool to figure
out who its server is.

00:25:27.570 --> 00:25:33.730
So one other mechanism you can use,
I've described these tool and server

00:25:33.730 --> 00:25:37.100
connections where the only thing
that they really shared was the UID,

00:25:37.100 --> 00:25:40.380
which is nice and all,
but that doesn't really tell

00:25:40.380 --> 00:25:43.920
you much about the fact whether
the user did this himself.

00:25:43.920 --> 00:25:47.400
If he installed a piece of
malware that started running,

00:25:47.400 --> 00:25:50.800
then the UID might have just been,
you know, the user never accepted

00:25:50.800 --> 00:25:52.960
that this was going to run,
that this was going to happen.

00:25:53.760 --> 00:25:57.490
The application just ran with
the privileges of the user that,

00:25:57.490 --> 00:25:59.230
you know, came across it.

00:25:59.320 --> 00:26:03.600
A way to make this more flexible
would be to use authorization.

00:26:03.600 --> 00:26:06.270
I'm going to quickly go over
the principles to give you an

00:26:06.270 --> 00:26:08.320
understanding of what it is because,
of course,

00:26:08.320 --> 00:26:11.660
we've talked about this in many sessions,
but there's new people coming

00:26:11.670 --> 00:26:12.930
to the platform every day.

00:26:12.940 --> 00:26:17.180
So authorization is
basically about the question,

00:26:17.180 --> 00:26:21.410
do I have a certain right,
and getting the answer yes

00:26:21.410 --> 00:26:23.480
or no in response to it.

00:26:23.760 --> 00:26:27.840
Now, it does not imply any
privileges in itself.

00:26:27.840 --> 00:26:30.480
If you have the right,
there's no way that anyone

00:26:30.480 --> 00:26:31.800
is going to see this.

00:26:31.800 --> 00:26:34.670
You can share this handle that
you have for this authorization,

00:26:34.670 --> 00:26:37.070
pass it to someone else,
and then configure it out,

00:26:37.100 --> 00:26:39.860
but the system by itself does not
imply that you have privileges.

00:26:39.860 --> 00:26:43.700
In that, we have a third party,
the security server, which is the process

00:26:43.700 --> 00:26:47.140
called security these days,
that operates as the middleman.

00:26:47.160 --> 00:26:49.040
So it will sit in the middle.

00:26:49.040 --> 00:26:53.160
You will ask it to get authorization
to do a particular thing.

00:26:53.860 --> 00:26:55.880
You will get a particular
right to perform an operation.

00:26:55.880 --> 00:27:01.110
Then you pass it to the
tool out of our example,

00:27:01.220 --> 00:27:04.380
and the tool will be able to
ask the impartial middleman,

00:27:04.380 --> 00:27:05.590
like, hey, what do you think?

00:27:05.640 --> 00:27:07.090
Does he have the right to do this?

00:27:07.100 --> 00:27:09.160
And if everything went
well at that point,

00:27:09.160 --> 00:27:12.500
the answer will be yes,
and then the operation can be performed.

00:27:12.500 --> 00:27:15.880
Now,
the right in itself does not do anything.

00:27:15.880 --> 00:27:19.510
So security has a database in the
back end in Etsy authorization that

00:27:19.510 --> 00:27:23.740
contains a description that tells it
what to do for this particular right.

00:27:23.760 --> 00:27:25.000
All right.

00:27:25.490 --> 00:27:29.380
So that basically gives you an out.

00:27:29.440 --> 00:27:35.940
And for administrators, you could ship,
for example,

00:27:35.940 --> 00:27:40.560
a very strict policy just for
your own benefits that you

00:27:40.560 --> 00:27:40.560
don't have to deal with any

00:27:40.990 --> 00:27:44.080
Well,
insecurely shipping your application

00:27:44.080 --> 00:27:47.620
and allowing the administrator
who may not have such high

00:27:47.680 --> 00:27:49.280
restrictions to lower that.

00:27:49.450 --> 00:27:51.660
The policy lives now
outside of your application,

00:27:51.660 --> 00:27:52.440
outside of the tool.

00:27:52.440 --> 00:27:55.630
It's kind of inspectable by
the administrator to see what

00:27:55.630 --> 00:28:00.260
you normally require and how
they might want to change that.

00:28:00.300 --> 00:28:05.090
Another thing it does for you
is transparently handle the UI.

00:28:06.790 --> 00:28:09.860
So the UI we handle through
a different process.

00:28:09.860 --> 00:28:14.500
So neither your application nor
your tool actually needs to have

00:28:14.500 --> 00:28:17.960
real possibility of providing GUI.

00:28:17.960 --> 00:28:20.000
And both could be just
command line tools.

00:28:20.000 --> 00:28:23.380
The only thing that is required is,
for right now,

00:28:23.380 --> 00:28:28.860
that the client that is in this operation
actually lives in a GUI context.

00:28:28.860 --> 00:28:32.850
Because the only way that we
know how to interact with the

00:28:32.970 --> 00:28:35.150
user is in a GUI kind of a way.

00:28:35.150 --> 00:28:36.680
In the future,
that might be a way to do that.

00:28:36.700 --> 00:28:39.790
So we've realized that we improved that,
but for now, there's not.

00:28:39.980 --> 00:28:43.620
And a third feature that is kind
of interesting is instead of

00:28:43.620 --> 00:28:47.380
giving one user the authorization
to do a particular operation,

00:28:47.380 --> 00:28:48.920
you could actually just avoid it.

00:28:49.040 --> 00:28:52.780
And for once or twice that he
requires that kind of authorization,

00:28:52.780 --> 00:28:56.090
you could come in there,
type your username and password for them,

00:28:56.090 --> 00:28:57.700
and allow them to do this operation once.

00:28:57.700 --> 00:29:01.260
So you can restrict it even
further than just giving people

00:29:01.280 --> 00:29:03.080
access to it all the time.

00:29:03.220 --> 00:29:08.090
So now quickly moving back to the
situation that we ended up with.

00:29:08.220 --> 00:29:10.240
We have the tool living
outside of the application.

00:29:10.240 --> 00:29:12.100
Now,
how does that tool have these privileges?

00:29:12.160 --> 00:29:14.400
Well, obviously,
it needed to get them somehow.

00:29:14.400 --> 00:29:18.890
So most often, the tool will have to
set your ID bit set.

00:29:18.910 --> 00:29:22.320
Well, this is, of course,
the start of a new problem because that

00:29:22.320 --> 00:29:24.340
tool lives in a hostile environment.

00:29:24.340 --> 00:29:27.860
Everyone can just run it,
and it will still have those privileges.

00:29:27.860 --> 00:29:30.930
It's not just your application
that's trying to use it.

00:29:31.010 --> 00:29:33.080
So let's have a look at
a couple of the threats.

00:29:33.100 --> 00:29:34.900
that exist.

00:29:35.300 --> 00:29:38.120
So there's the tool,
and there's some environment, and, well,

00:29:38.270 --> 00:29:40.490
there's a couple of problems
that happen with this.

00:29:40.490 --> 00:29:43.380
Some are more obvious,
some are slightly more intricate.

00:29:43.380 --> 00:29:46.530
The ones on the left,
arguments and environment variables,

00:29:46.530 --> 00:29:49.400
often seen as basic user input
that you'd have to check.

00:29:49.450 --> 00:29:53.680
Well, you know, that's all good and well,
but it goes a little further than that.

00:29:53.680 --> 00:29:57.040
Say that you have a framework that
has some implicit knowledge of,

00:29:57.090 --> 00:30:00.820
hey, if that argument gets passed,
I'll do something special.

00:30:00.820 --> 00:30:05.130
So an argument can have an expectation.

00:30:05.230 --> 00:30:07.920
It can have an expectation that it's
going to get a lot of results for you,

00:30:07.920 --> 00:30:10.050
and that's a reason why that
needs to be kept in check.

00:30:10.120 --> 00:30:12.020
Same goes for environment variables.

00:30:12.030 --> 00:30:14.250
I was just talking about
high-level frameworks,

00:30:14.490 --> 00:30:18.050
but DYLD supports an option where you can
kind of insert a piece of code and say,

00:30:18.050 --> 00:30:20.020
go ahead, take that along with you.

00:30:20.040 --> 00:30:22.260
Now, I have to say, of course,
with that one,

00:30:22.300 --> 00:30:25.680
this situation doesn't exist
because the framework will actually,

00:30:25.680 --> 00:30:28.550
the library in this case,
will actually figure out, hey,

00:30:28.550 --> 00:30:30.730
you're running with set-duty privileges.

00:30:30.730 --> 00:30:34.730
I'm not taking any of this random
user input that might have been faked.

00:30:35.200 --> 00:30:38.540
I'm just leaving that alone,
and we'll just continue as normal.

00:30:38.540 --> 00:30:42.040
I mean, we're turning that feature off
for this particular situation.

00:30:42.040 --> 00:30:45.590
The third one, kind of surprisingly,
because I've described it as a

00:30:45.590 --> 00:30:50.200
way to securely talk to your tool,
are file descriptors.

00:30:50.200 --> 00:30:53.990
Now, the case may be that your tool
wants to write out a standard in,

00:30:54.040 --> 00:30:55.540
standard out, or standard error.

00:30:55.540 --> 00:30:58.030
Well, you know,
those have the notion of canonically

00:30:58.060 --> 00:31:01.720
sitting at these file descriptors 0,
1, and 2, but that's just convention.

00:31:01.720 --> 00:31:04.230
That's not necessarily to be there.

00:31:04.240 --> 00:31:08.080
So, if you do not use standard in,
standard out, and standard error,

00:31:08.080 --> 00:31:11.390
you may want to dupe those to def
null and make sure that nothing

00:31:11.390 --> 00:31:13.700
leaks out of there accidentally.

00:31:13.700 --> 00:31:18.860
And lastly, process limits,
which is even more intricate.

00:31:18.860 --> 00:31:23.310
Every process can put
certain limits on itself,

00:31:23.310 --> 00:31:26.010
and, well,
those limits may actually cause

00:31:26.040 --> 00:31:29.400
the program to work slightly
differently than it did before.

00:31:29.400 --> 00:31:34.560
So, say that I limit the process to
not be able to open any files.

00:31:34.820 --> 00:31:36.620
Now,
if you don't do enough error checking,

00:31:36.620 --> 00:31:40.080
and you go through your code path,
and you try to open the file,

00:31:40.080 --> 00:31:42.540
and it doesn't work,
but you didn't do the error check,

00:31:42.540 --> 00:31:45.920
now we have basically created a
new code path through your code

00:31:45.970 --> 00:31:49.200
that you may not have tested for,
and it may have unexpected results.

00:31:49.200 --> 00:31:53.660
So, one way to go is, say,
I'm going to avoid this

00:31:53.730 --> 00:31:55.910
whole set UID business,
and I'm going to let

00:31:55.910 --> 00:31:57.260
LaunchD do this work.

00:31:57.260 --> 00:32:03.360
Now, LaunchD is nice in such that you can
basically set up your helper to go.

00:32:03.360 --> 00:32:04.380
You can tell it what privileges it has.

00:32:04.480 --> 00:32:05.660
What privileges to run with.

00:32:05.880 --> 00:32:10.130
It will sanitize the environment,
and all of that is under control now.

00:32:10.140 --> 00:32:11.880
It doesn't always have to run.

00:32:11.880 --> 00:32:14.160
It can demand launch it
when it's necessary again.

00:32:14.160 --> 00:32:16.460
So, those are really nice features, but,
of course,

00:32:16.510 --> 00:32:19.410
the problem changes with that in
terms that you only tell LaunchD where

00:32:19.410 --> 00:32:21.020
the process is that needs to be run.

00:32:21.020 --> 00:32:21.850
You give it a path.

00:32:21.940 --> 00:32:24.310
If the directory where that
tool exists is not very secure,

00:32:24.310 --> 00:32:26.140
and you can just replace
another one in there,

00:32:26.140 --> 00:32:29.070
LaunchD will just launch it for you,
and that's fine, too, for it.

00:32:29.130 --> 00:32:32.150
So, that is another way of solving it,
and it has its own problems that

00:32:32.260 --> 00:32:33.830
you're going to have to deal with.

00:32:34.090 --> 00:32:35.090
-

00:32:35.220 --> 00:32:40.490
If you're interested in more of
these intricacies about changing code

00:32:40.490 --> 00:32:43.720
and how to protect it against it,
of course, there's a session after this

00:32:43.720 --> 00:32:46.550
coming up on launch day as well
as a session on code signing.

00:32:46.560 --> 00:32:49.920
If you have any interest in that area,
I suggest you go see those.

00:32:49.920 --> 00:32:52.950
Those are sessions 4.13 and 4.14,
respectively.

00:32:54.710 --> 00:32:58.640
So with that, quickly some documentation.

00:32:58.660 --> 00:33:03.340
You can look up about the things
that I've talked about via

00:33:03.340 --> 00:33:04.940
the Apple Developer website.

00:33:05.090 --> 00:33:08.620
Follow the breadcrumb trail
because the URL is hard to parse.

00:33:08.620 --> 00:33:11.380
You go through the reference library,
the Darwin section,

00:33:11.390 --> 00:33:14.210
then the security subsection,
and you can find security overview

00:33:14.220 --> 00:33:17.490
that will tell you a little bit about
the facilities that are in the system.

00:33:17.560 --> 00:33:22.000
And AuthSample describes more
or less how the AuthExec with

00:33:22.120 --> 00:33:24.180
privileges trampoline works.

00:33:24.190 --> 00:33:28.510
So that will give you an idea how
you can implement such a thing.

00:33:28.830 --> 00:33:31.370
For LaunchD,
I have to refer you to the man pages.

00:33:31.490 --> 00:33:33.180
There might be some
documentation coming up.

00:33:33.180 --> 00:33:34.710
I'm not aware of that.

00:33:34.810 --> 00:33:40.070
And for authorization, of course,
look at the File and Security Framework.

00:33:40.120 --> 00:33:43.860
And then any questions in the area
of data security and authorization,

00:33:43.860 --> 00:33:46.930
you can join the Apple CDSA mailing
list and talk with the whole

00:33:46.930 --> 00:33:49.570
data security group where we'll
happily answer your questions.

00:33:49.660 --> 00:33:53.190
And with that,
I want to ask Simon back on stage.

00:33:59.000 --> 00:34:00.000
Thank you, Conrad.

00:34:00.000 --> 00:34:04.290
So we're going to switch
gears a little bit here.

00:34:04.300 --> 00:34:07.300
We're going to talk about secure
goading and some easy ways to

00:34:07.300 --> 00:34:10.900
eliminate frequent flaws that show up.

00:34:11.090 --> 00:34:15.550
So I'm going to emphasize
the reference library again.

00:34:15.560 --> 00:34:19.300
In May 2006,
Apple released a secure coding guide,

00:34:19.300 --> 00:34:22.140
which is there,
which covers all of the material

00:34:22.140 --> 00:34:27.200
I'm going to be talking about and a
whole number of additional things.

00:34:27.200 --> 00:34:30.570
So it also contains references
to other books and online

00:34:30.570 --> 00:34:32.660
resources which can be useful.

00:34:32.660 --> 00:34:36.900
The guide that Apple has published
is specific to the Apple platform.

00:34:40.240 --> 00:34:42.830
So I'm going to talk about two
things in the secure coding section.

00:34:42.840 --> 00:34:45.320
I'm going to talk about buffer
overflows and integer overflows.

00:34:45.320 --> 00:34:48.980
And I need to say,
why did I pick those two things?

00:34:48.980 --> 00:34:52.980
If you take the big bundle of
security vulnerabilities and you

00:34:52.980 --> 00:34:57.810
throw out the 52% of things which
were stupid mistakes in your coding,

00:34:57.830 --> 00:35:01.910
you just got the logic wrong,
or you just did something wrong,

00:35:01.930 --> 00:35:05.990
you're left with 48% of
technical vulnerabilities.

00:35:07.180 --> 00:35:11.540
40% of those vulnerabilities are either
buffer overflows or integer overflows.

00:35:11.540 --> 00:35:14.500
So if you can eliminate those,
you can eliminate a huge number

00:35:14.500 --> 00:35:16.260
of vulnerabilities in programs.

00:35:16.320 --> 00:35:21.270
Now, also, buffer overflows and integer
overflows are a big risk to your

00:35:21.270 --> 00:35:23.420
customers and to your users.

00:35:23.440 --> 00:35:25.190
So why is that?

00:35:25.310 --> 00:35:28.750
A buffer overflow usually
kind of manifests itself as

00:35:28.750 --> 00:35:32.010
like a crash or a data loss,
and it's an irritant.

00:35:32.040 --> 00:35:35.840
And you want to swat it, and you say, ah,
horrible.

00:35:36.340 --> 00:35:39.070
It's mostly harmless at this point.

00:35:39.680 --> 00:35:43.400
The problem is that there
are things with bigger byte.

00:35:43.670 --> 00:35:48.360
There can be a vector for worm, virus,
or spyware.

00:35:49.180 --> 00:35:52.000
So the only thing that takes
you from the irritation,

00:35:52.010 --> 00:35:55.600
really, to the big bite is motivation,
experience, and time.

00:35:55.600 --> 00:35:58.040
And the bad guys out there have that.

00:35:58.040 --> 00:35:59.460
That's what they do.

00:35:59.470 --> 00:36:00.960
They look for crashes.

00:36:00.960 --> 00:36:03.300
When they get a crash,
they start poking around,

00:36:03.300 --> 00:36:04.920
and they start manipulating it.

00:36:04.990 --> 00:36:09.320
So their target is to take things which
are an annoyance and turn it into a

00:36:09.380 --> 00:36:11.740
vector for a worm virus or spyware.

00:36:15.370 --> 00:36:17.540
So,
what's a sign that you have an overflow?

00:36:17.540 --> 00:36:22.560
This is an example where I took a
little program that I hacked up.

00:36:22.630 --> 00:36:25.800
It took me five minutes to do in Xcode.

00:36:25.800 --> 00:36:28.260
And it had a text field,
and I copied it into

00:36:28.320 --> 00:36:31.050
a stack-based buffer,
which was too short.

00:36:31.170 --> 00:36:33.220
And I just entered a
whole bunch of characters,

00:36:33.260 --> 00:36:34.220
capital letter A.

00:36:34.220 --> 00:36:37.300
And this is a PowerPC crash.

00:36:37.300 --> 00:36:40.100
And you can see there
that the capital A's,

00:36:40.220 --> 00:36:44.310
the 41, 41, 41, appear in the crash dump.

00:36:44.370 --> 00:36:47.180
And they appear in the crash
dump in quite a few places.

00:36:47.450 --> 00:36:49.980
So, this is a sure sign that
you've got a buffer overflow.

00:36:49.980 --> 00:36:53.380
If you start seeing them in the link
register and various other registers,

00:36:53.380 --> 00:36:58.170
you can get a similar
dump on an Intel platform.

00:36:58.500 --> 00:37:00.890
So, usually engineers,
when they see this,

00:37:00.970 --> 00:37:05.050
they kind of get mad and they go, ah,
why is somebody doing this?

00:37:05.050 --> 00:37:08.130
They go through the stages of grief,
they get the anger,

00:37:08.130 --> 00:37:09.880
and then they get the denial.

00:37:09.880 --> 00:37:12.150
So, they go and then say,
I need to prove that

00:37:12.160 --> 00:37:13.860
this is an exploitable,
right?

00:37:13.920 --> 00:37:15.430
This isn't a problem for me.

00:37:17.240 --> 00:37:18.910
Well, doing that is very, very hard.

00:37:18.910 --> 00:37:22.600
The cone of effort you have to
go to to prove that a buffer

00:37:22.610 --> 00:37:26.060
overflow or an integer overflow
isn't exploitable is huge.

00:37:26.060 --> 00:37:28.960
It escalates very, very rapidly when you
start looking at the code.

00:37:28.980 --> 00:37:32.460
And so what does a bad guy have to do?

00:37:32.740 --> 00:37:35.090
Well, all they have to do
is find one code path,

00:37:35.090 --> 00:37:35.700
right?

00:37:35.710 --> 00:37:39.670
It's much easier for them to find a
vulnerability than for you to prove

00:37:39.880 --> 00:37:42.430
that it couldn't possibly be exploited.

00:37:42.870 --> 00:37:46.560
So one thing to take away here is
that it's almost always faster to fix

00:37:46.560 --> 00:37:48.770
the problem than prove it's benign.

00:37:57.400 --> 00:37:58.770
So let's talk about stack frames.

00:37:58.780 --> 00:38:02.160
This is the usual place
where buffer overflows occur.

00:38:02.160 --> 00:38:05.440
I've got a PowerPC stack frame
here and an Intel stack frame.

00:38:05.440 --> 00:38:09.510
They're laid out a little differently,
and the names are not quite the same,

00:38:09.540 --> 00:38:12.040
but they're generally
the same idea holds.

00:38:12.040 --> 00:38:14.240
So what happens in a buffer overflow?

00:38:14.240 --> 00:38:17.910
You usually have a local variable
that's allocated on the stack,

00:38:17.910 --> 00:38:20.580
and you overflow it,
and you corrupt either saved

00:38:20.780 --> 00:38:24.480
registers or the bookkeeping that
the compiler does for returning

00:38:24.480 --> 00:38:26.520
and going between functions.

00:38:27.400 --> 00:38:32.800
Now, for Leopard, we do, in fact,
have no execute stack turned on for the

00:38:32.950 --> 00:38:36.120
Intel platform and for G5 processors.

00:38:36.120 --> 00:38:40.230
We can't do that for G4s, unfortunately,
but that will be on by default.

00:38:40.240 --> 00:38:43.490
This does cause some problems
for certain types of functions.

00:38:43.550 --> 00:38:46.930
GCC, for example, uses stack trampolines
for nested functions,

00:38:46.930 --> 00:38:49.870
which means if you're using those,
you'll have to turn off

00:38:49.870 --> 00:38:51.260
the no execute stack.

00:38:51.280 --> 00:38:54.920
Now, no execute stack doesn't
solve all your problems.

00:38:54.920 --> 00:38:57.380
The bad guys, well,
you know they're bad guys.

00:38:57.400 --> 00:38:58.400
They've got lots of time.

00:38:58.400 --> 00:39:01.740
They've figured out ways to get around
all of the no execute stack stuff.

00:39:01.870 --> 00:39:05.740
They do return into libraries,
and then they also do heap overflows.

00:39:05.760 --> 00:39:08.880
They can all try and switch their
area of focus to heap overflows.

00:39:08.900 --> 00:39:15.540
So what you're seeing here is a layout
of the Mac OS X malloc allocator.

00:39:15.540 --> 00:39:18.180
It's a little different than
traditional Unix allocators.

00:39:18.180 --> 00:39:21.390
There are no pointers
between the buckets.

00:39:21.450 --> 00:39:27.150
That data is held in a separate area,
so you have contiguous memory.

00:39:27.400 --> 00:39:27.640
You can see that the data
is held in a separate area,

00:39:27.640 --> 00:39:27.900
so you have contiguous memory.

00:39:27.900 --> 00:39:30.690
And then when you get
very large allocations,

00:39:30.700 --> 00:39:32.950
they get to go directly
to the VM subsystem.

00:39:32.960 --> 00:39:38.720
So here's a picture of a buffer,
and when you overflow it,

00:39:38.800 --> 00:39:40.410
it goes into the red area.

00:39:40.420 --> 00:39:43.850
And for Objective-C and C++ objects,
that's very bad.

00:39:43.900 --> 00:39:45.660
So why is that very bad?

00:39:45.680 --> 00:39:50.170
Well, for both of these objects,
the first thing at the beginning

00:39:50.210 --> 00:39:52.190
of the object is a pointer.

00:39:52.200 --> 00:39:54.160
It's a code pointer.

00:39:54.160 --> 00:39:57.280
So if you can overflow an input,
you can overflow an input.

00:39:57.480 --> 00:40:00.130
And if you can influence that pointer,
you can make the program

00:40:00.140 --> 00:40:02.520
jump somewhere else,
maybe back into the data again.

00:40:02.730 --> 00:40:04.670
So you're basically
going to get exploited.

00:40:04.680 --> 00:40:09.420
This is a little harder, but again,
the bad guys have the time and the

00:40:09.520 --> 00:40:11.500
effort and the will to go and do this.

00:40:14.850 --> 00:40:21.040
So what's the easiest way in C-like
languages to eliminate buffer overflows?

00:40:21.040 --> 00:40:22.950
And we're talking about C here.

00:40:22.960 --> 00:40:26.180
If you've got a high-level
language that has constructs

00:40:26.250 --> 00:40:29.880
for strings that have lengths,
then please use those.

00:40:29.880 --> 00:40:32.440
What I'm talking about here
is very frequent mistakes

00:40:32.440 --> 00:40:34.920
that people make in just C.

00:40:35.140 --> 00:40:37.230
They use functions on the red side.

00:40:37.420 --> 00:40:38.480
Don't use those functions.

00:40:38.540 --> 00:40:39.720
They're really bad.

00:40:39.780 --> 00:40:41.670
They're going to get you.

00:40:41.880 --> 00:40:44.900
Everybody will say, yeah,
I know how to calculate this.

00:40:44.900 --> 00:40:47.020
You know,
if I multiply this by this and add one

00:40:47.020 --> 00:40:50.520
and take off one when I do the malloc
because I have to account for the zero,

00:40:50.520 --> 00:40:52.300
then maybe it's all right.

00:40:54.210 --> 00:40:55.990
Very,
very difficult to get these things right.

00:40:56.020 --> 00:41:03.640
So what I recommend is you use the stuff
on the green side and use the strlcat,

00:41:03.640 --> 00:41:07.730
strlcopy for both strcat and strcopy.

00:41:07.940 --> 00:41:10.040
The n functions,
I don't recommend using those,

00:41:10.130 --> 00:41:12.050
and I'm going to show
you why in a second.

00:41:12.060 --> 00:41:15.150
For sprintf,
use the n versions where you're actually

00:41:15.160 --> 00:41:17.590
accounting for the space that's used.

00:41:18.440 --> 00:41:22.690
So another takeaway point here is use
unsigned variables for calculating sizes.

00:41:22.700 --> 00:41:24.900
You never get a negative size buffer.

00:41:24.900 --> 00:41:25.800
They're always positive.

00:41:25.800 --> 00:41:27.570
They always have real value.

00:41:27.580 --> 00:41:30.310
And use the save functions
for all new code.

00:41:30.340 --> 00:41:34.010
Sometimes it can be very difficult
to go back and retrofit old code,

00:41:34.100 --> 00:41:37.070
but if you can write new code,
then use the new functions.

00:41:37.080 --> 00:41:42.520
In fact, certain quality,
if you read papers on software quality,

00:41:42.530 --> 00:41:47.830
75% of, or a way to improve your code by
75% is to juggle the same code as

00:41:47.890 --> 00:41:48.300
the same code as the same code.

00:41:48.320 --> 00:41:52.020
introduce new practices and change
the way that you write code.

00:41:55.580 --> 00:41:59.970
So let's compare STR copy, STRN copy,
and STRL copy.

00:42:00.080 --> 00:42:03.760
Now we're going to start out with a tiny
buffer that's actually going to fit.

00:42:03.800 --> 00:42:06.420
So we're going to take
those three functions,

00:42:06.570 --> 00:42:11.110
and then we're going to see what the
result of running those functions are.

00:42:11.330 --> 00:42:14.800
Now, in each case, we're fine.

00:42:14.840 --> 00:42:16.200
No buffers or overflow.

00:42:16.540 --> 00:42:18.600
There's no buffer overflow.

00:42:18.600 --> 00:42:19.760
The overflow is in the red area.

00:42:22.380 --> 00:42:23.100
So let's start again.

00:42:23.100 --> 00:42:25.640
This time we're going to take the
source string to be a little larger.

00:42:25.640 --> 00:42:28.320
It's the same functions again.

00:42:28.320 --> 00:42:31.540
Now what happens with strCopy?

00:42:31.600 --> 00:42:32.700
Well, you get owned.

00:42:32.700 --> 00:42:36.130
You've overflown the buffer,
you're in the red area,

00:42:36.130 --> 00:42:38.330
you're running somebody else's code.

00:42:38.330 --> 00:42:39.360
That's game over.

00:42:39.660 --> 00:42:40.160
So that's bad.

00:42:42.020 --> 00:42:44.120
What happens with STR in copy?

00:42:44.140 --> 00:42:45.400
Well, you're okay.

00:42:45.400 --> 00:42:48.870
You don't actually overflow the buffer,
but there's something a

00:42:48.980 --> 00:42:50.380
little fishy about this.

00:42:51.910 --> 00:42:54.080
That's not a zero.

00:42:54.180 --> 00:42:58.400
For a correctly terminated C string,
this isn't the correctly

00:42:58.400 --> 00:42:59.960
terminated C string.

00:42:59.960 --> 00:43:04.760
So if you try and use that string
in additional code later on,

00:43:05.030 --> 00:43:06.860
you're going to go into the red area.

00:43:06.950 --> 00:43:09.770
So you've got an overflow here,
but it's a little bit more

00:43:09.770 --> 00:43:11.560
subtle than a buffer overflow.

00:43:11.650 --> 00:43:13.800
So this is also bad.

00:43:13.800 --> 00:43:20.400
And there have been hacks that have
used this to actually cause problems.

00:43:21.290 --> 00:43:23.150
So what happens with STRL copy?

00:43:23.410 --> 00:43:25.680
Well, STRL copy does the perfect thing.

00:43:25.690 --> 00:43:29.580
It doesn't overflow the buffer,
and it always zero terminates.

00:43:29.580 --> 00:43:33.260
So you don't have to add that little
extra piece there that either puts it at

00:43:33.260 --> 00:43:36.670
the beginning before you do the STRL end
copy or afterwards to actually make

00:43:36.740 --> 00:43:38.580
sure that the last character is zero.

00:43:38.580 --> 00:43:39.960
So this is good.

00:43:40.600 --> 00:43:43.300
Definitely use STRL copy and STRL cat.

00:43:44.790 --> 00:43:48.020
So in summary, think the L means total
length of the buffer.

00:43:48.020 --> 00:43:51.180
This is a subtle difference between
the N versions and the L versions.

00:43:51.180 --> 00:43:55.020
The STRL versions always use
the total length of the buffer

00:43:55.130 --> 00:43:56.060
when doing calculations.

00:43:56.060 --> 00:43:58.530
This can simplify the
arithmetic in your code,

00:43:58.650 --> 00:43:59.900
you know, amazingly.

00:43:59.900 --> 00:44:03.770
You can get rid of all those,
if I add one, take off one,

00:44:03.830 --> 00:44:06.350
to adjust for the end of the buffer.

00:44:06.350 --> 00:44:08.620
You don't have to do any of that.

00:44:08.620 --> 00:44:09.850
You just give it the size of the buffer.

00:44:09.850 --> 00:44:09.850
You always give it the
size of the buffer.

00:44:10.370 --> 00:44:14.260
So this reduces the need
for complex length tracking.

00:44:14.640 --> 00:44:16.980
If you do, in fact,
overflow the buffer and it couldn't

00:44:16.980 --> 00:44:19.950
put all the characters into the buffer
that you wanted to put in there,

00:44:20.090 --> 00:44:23.810
the return value from the
L functions is a little different.

00:44:23.900 --> 00:44:26.940
And it tells you the actual
length you would have needed.

00:44:26.940 --> 00:44:30.390
So if you wanted to go back around
and allocate some more memory and

00:44:30.390 --> 00:44:32.820
really use that length string,
you can.

00:44:32.940 --> 00:44:35.660
Now for Leopard,
we actually implemented these

00:44:35.660 --> 00:44:37.240
functions in the kernel.

00:44:37.350 --> 00:44:40.100
So for Leopard,
you can use these functions in the KEXT.

00:44:40.100 --> 00:44:43.400
And in fact,
we would very much like to deprecate

00:44:43.500 --> 00:44:46.860
the use of the non-N versions.

00:44:46.860 --> 00:44:49.520
And people do use those versions
in the kernel scarily enough.

00:44:49.520 --> 00:44:52.270
Please don't use those
versions in the kernel.

00:44:52.270 --> 00:44:53.420
Use the L versions.

00:44:56.260 --> 00:44:57.790
So let's move on to integer overflow.

00:44:57.800 --> 00:45:01.140
They're kind of related to
buffer overflow in that if

00:45:01.140 --> 00:45:03.640
you get an integer overflow,
you normally end up

00:45:03.640 --> 00:45:04.880
triggering a buffer overflow.

00:45:04.880 --> 00:45:09.690
So here we have some unsigned arithmetic.

00:45:09.730 --> 00:45:13.640
We've got 1, 2, 3, and we added 1 to it,
and we got 1, 2, 4.

00:45:13.640 --> 00:45:15.860
Now we've got another integer,
and we add 1 to it,

00:45:15.860 --> 00:45:17.980
and suddenly it's become
a negative number.

00:45:19.310 --> 00:45:23.540
And in Hex, if you remember your two's
complement arithmetic,

00:45:23.540 --> 00:45:25.080
the last line shows you why that is.

00:45:25.080 --> 00:45:27.610
The top bit suddenly flips on
and all the rest are zeros.

00:45:27.620 --> 00:45:35.020
So in that last line of that box there,
1024 plus 2147483647,

00:45:35.020 --> 00:45:39.010
is that less than zero
or greater than zero?

00:45:40.800 --> 00:45:43.450
If you're using signed arithmetic,
that will actually turn

00:45:43.510 --> 00:45:44.860
out to be a true statement.

00:45:47.180 --> 00:45:49.670
Now,
if that data is coming from the user,

00:45:49.670 --> 00:45:53.100
then you're basically going
to be trying to fit something

00:45:53.100 --> 00:45:55.310
that's too big into a small spot.

00:45:55.590 --> 00:45:57.880
Because if you then feed that
to Malik to try and get some

00:45:57.920 --> 00:46:00.490
area to actually store the data,
you're going to get up

00:46:00.490 --> 00:46:01.660
a smaller data region.

00:46:01.660 --> 00:46:04.570
And the data that you're going
to try and put into it is larger,

00:46:04.570 --> 00:46:06.390
so you're going to get an overflow.

00:46:06.500 --> 00:46:09.290
So the real problem
here is external data,

00:46:09.290 --> 00:46:12.180
things that are provided
to you by the user.

00:46:12.260 --> 00:46:16.700
Maybe you don't really think of
it as being provided by the user.

00:46:16.700 --> 00:46:19.690
It's an image on a web page, for example,
and you're using WebKit or

00:46:19.790 --> 00:46:20.720
something like that.

00:46:20.820 --> 00:46:24.160
Or you've got your own image
code for processing images,

00:46:24.160 --> 00:46:27.520
and you have a width and a
height and the number of pixels,

00:46:27.520 --> 00:46:28.900
the depth of pixels.

00:46:28.900 --> 00:46:30.980
Well,
if you multiply those things together,

00:46:31.020 --> 00:46:32.490
they overflow very quickly.

00:46:32.490 --> 00:46:35.110
And I've forgotten the number.

00:46:35.110 --> 00:46:36.390
It's not very large.

00:46:36.390 --> 00:46:39.110
When you multiply numbers
together like that,

00:46:39.110 --> 00:46:41.200
you run out of space really quickly.

00:46:41.280 --> 00:46:45.470
In fact, probably in the next couple of
generations of cinema displays,

00:46:45.470 --> 00:46:46.300
you'll be able to overflow.

00:46:46.300 --> 00:46:49.100
But you'll be able to overflow that if
you multiply those numbers together.

00:46:49.100 --> 00:46:50.470
I'm sure about it.

00:46:50.550 --> 00:46:55.930
So another common thing that people do
is they take a count and they multiply it

00:46:55.930 --> 00:47:00.670
by the size of an object because they're
going to create an array of structures.

00:47:00.910 --> 00:47:03.590
The Malik of zero,
if you can magically make

00:47:03.590 --> 00:47:06.500
that come out to be a zero,
the Malik of zero,

00:47:06.500 --> 00:47:12.260
although it allocates zero space,
isn't actually a zero pointer.

00:47:12.340 --> 00:47:15.900
So if you're testing for null in your
code to see whether the Malik failed,

00:47:15.900 --> 00:47:15.900
it won't fail.

00:47:15.900 --> 00:47:17.400
It will succeed.

00:47:17.400 --> 00:47:22.400
So you really do need to be
careful with integer overflows.

00:47:22.450 --> 00:47:26.360
Now, unfortunately here,
this is a little bit of a tease.

00:47:26.640 --> 00:47:29.270
Compilers don't and cannot help
you with integer overflows.

00:47:29.280 --> 00:47:32.900
This is a runtime problem,
and the C specification doesn't have

00:47:32.900 --> 00:47:35.020
any help for you in detecting overflows.

00:47:35.020 --> 00:47:38.240
You kind of leave that as a sort of
a process or implementation detail,

00:47:38.240 --> 00:47:42.090
so you have to either code it yourself
or get some help from external libraries.

00:47:42.100 --> 00:47:46.080
The publicly available tools
don't solve the problem very well.

00:47:46.080 --> 00:47:50.740
You can find some C++ classes that try
to help you with integer overflows,

00:47:50.800 --> 00:47:55.210
or that's one common library,
and it uses template overloading.

00:47:56.600 --> 00:47:59.220
If you're using C++,
you could potentially use that.

00:47:59.360 --> 00:48:02.810
The Civa things that are out
there force you to use unsigned

00:48:02.810 --> 00:48:04.840
ints and aren't very helpful.

00:48:04.840 --> 00:48:08.000
So we actually would like to
provide something for everybody in

00:48:08.120 --> 00:48:12.360
Leopard to help with this problem,
but we weren't quite ready for WWDC,

00:48:12.360 --> 00:48:13.510
so I apologize for that.

00:48:13.570 --> 00:48:14.500
This is a little bit of a tease.

00:48:14.500 --> 00:48:16.120
There's more coming in this area.

00:48:16.120 --> 00:48:19.110
We know it's a big area,
and it's important.

00:48:21.590 --> 00:48:22.940
So here's a summary for overflows.

00:48:22.940 --> 00:48:26.800
You have to be very careful about
statically sized stack-based buffers.

00:48:26.800 --> 00:48:33.040
They are the real red
area for buffer overflows.

00:48:33.040 --> 00:48:35.210
Avoid dangerous string functions.

00:48:35.210 --> 00:48:36.680
Only use the safe ones.

00:48:36.680 --> 00:48:40.490
If there are higher language features
or frameworks available to you,

00:48:40.630 --> 00:48:46.370
such as CFString or other mechanisms
which can handle buffers of size,

00:48:46.380 --> 00:48:47.980
then use those.

00:48:49.550 --> 00:48:52.790
Check for arithmetic overflow
and use unsigned arithmetic

00:48:52.790 --> 00:48:54.640
when manipulating buffers.

00:48:54.640 --> 00:48:55.870
They always have positive size.

00:48:55.900 --> 00:48:57.530
Do not trust user input.

00:48:57.530 --> 00:49:01.360
Most of the time,
users will provide you very nice input.

00:49:01.360 --> 00:49:02.540
The bad guys don't.

00:49:02.540 --> 00:49:03.720
That's the first thing they go after.

00:49:03.720 --> 00:49:06.880
They have these things called fuzzers,
which try to manipulate the data so

00:49:06.880 --> 00:49:10.110
that it goes outside the bounds you
would have normally programmed for.

00:49:11.560 --> 00:49:15.800
So again,
a pointer to the ADC reference library.

00:49:15.800 --> 00:49:17.730
There's a secure coding guide there.

00:49:21.820 --> 00:49:24.800
So okay,
now we're going to talk about sandboxing.

00:49:24.800 --> 00:49:26.100
This is a technology preview.

00:49:26.100 --> 00:49:27.330
This is new in Leopard.

00:49:27.410 --> 00:49:28.800
It doesn't exist anywhere else.

00:49:28.950 --> 00:49:31.650
This is very experimental.

00:49:32.330 --> 00:49:33.320
So here we go.

00:49:33.320 --> 00:49:34.940
Why do you want sandboxing?

00:49:35.030 --> 00:49:36.260
Why is sandboxing important?

00:49:36.280 --> 00:49:41.660
Well, on any kind of operating system,
and in particular Mac OS X,

00:49:41.660 --> 00:49:46.400
your application has access to
all of the resources that the

00:49:46.450 --> 00:49:48.420
operating system provides you.

00:49:48.420 --> 00:49:50.470
So you can access files,
there is networking,

00:49:50.470 --> 00:49:53.250
and then there are other
applications running on the system.

00:49:53.280 --> 00:49:55.350
And it will interact with them.

00:49:55.380 --> 00:49:59.190
Now what happens if you have one of
these floors that allows somebody to

00:49:59.190 --> 00:50:01.300
inject code into your application?

00:50:02.530 --> 00:50:05.380
Well, once they've injected that
code into the application,

00:50:05.380 --> 00:50:10.830
then that row code has access
to all of those resources.

00:50:10.840 --> 00:50:12.340
Everything.

00:50:12.340 --> 00:50:16.660
If you've got photographs somewhere
off in a particular place,

00:50:16.660 --> 00:50:19.900
that row code has access
to your photographs.

00:50:19.900 --> 00:50:22.220
It may not be photographs,
it may be credit card numbers,

00:50:22.220 --> 00:50:23.170
it may be anything.

00:50:23.220 --> 00:50:27.010
It has access to everything
that application has access to.

00:50:30.050 --> 00:50:33.600
So as users, what would you really
like the behavior to be?

00:50:33.610 --> 00:50:38.360
If you have an application,
you want that application,

00:50:38.360 --> 00:50:39.360
let's pick Safari.

00:50:39.360 --> 00:50:42.970
You want the application to
behave like a web browser.

00:50:42.980 --> 00:50:45.220
You want it to do web
browser type things.

00:50:45.220 --> 00:50:48.150
It can maintain a cache
of its image files.

00:50:48.220 --> 00:50:50.500
You want to be able to save pages.

00:50:50.500 --> 00:50:54.440
And you want to be able to
download stuff to the desktop.

00:50:54.440 --> 00:50:57.080
You want it to go out onto the
network so that you can retrieve

00:50:57.080 --> 00:50:59.690
and browse around and have a great,
rich experience.

00:51:00.000 --> 00:51:04.110
And sometimes you want to make
it talk to other applications

00:51:04.120 --> 00:51:06.540
to have hyperlinking through.

00:51:06.860 --> 00:51:09.510
So in this environment,
what does a user really want?

00:51:09.590 --> 00:51:10.320
What do they expect?

00:51:10.380 --> 00:51:16.970
And so I think it would be reasonable
to expect that if you get rogue

00:51:16.970 --> 00:51:19.760
code inside the application,
that that rogue code,

00:51:19.830 --> 00:51:23.790
the only things it can do is do damage
to the things that Safari can do.

00:51:23.820 --> 00:51:29.360
So it can only modify the cache
files maybe that Safari is keeping.

00:51:29.360 --> 00:51:35.420
It doesn't necessarily have carte blanche
access to download things or modify

00:51:35.420 --> 00:51:36.780
files anywhere that Safari can do.

00:51:36.800 --> 00:51:37.770
And so it can only modify the cache
files maybe that Safari can do.

00:51:37.770 --> 00:51:38.800
So it can only modify the cache
files maybe that Safari can do.

00:51:38.830 --> 00:51:40.850
And it can't talk to
other network places.

00:51:40.860 --> 00:51:45.560
It can't phone home to Bulgaria and
squirt data over there,

00:51:45.560 --> 00:51:47.040
although that's a very
hard problem for Safari.

00:51:47.040 --> 00:51:50.920
And for other applications,
you don't want it to be able to

00:51:50.960 --> 00:51:55.610
go around and fire up all sorts of
other applications on the system.

00:51:55.610 --> 00:51:59.180
So that's kind of what the user
would really want to have happen.

00:52:00.970 --> 00:52:02.060
Well,
that's what I would want to have happen.

00:52:02.060 --> 00:52:03.220
I don't know about you guys.

00:52:03.290 --> 00:52:06.140
So we don't want--

00:52:06.690 --> 00:52:12.000
The bad code to access any files that
are outside of what Safari could access,

00:52:12.000 --> 00:52:14.570
we don't want them to be able
to go and talk to websites or

00:52:14.570 --> 00:52:17.650
particular services on the network
that we don't want them to talk to,

00:52:17.650 --> 00:52:20.230
and we don't want them to
talk to other applications.

00:52:22.420 --> 00:52:23.380
So how are we going to manage that?

00:52:23.430 --> 00:52:27.840
So here's the sandboxing
implementation that we currently have.

00:52:27.840 --> 00:52:31.800
It's based on mandatory access control.

00:52:31.800 --> 00:52:36.140
This was talked a little bit
about in the kernel session.

00:52:40.440 --> 00:52:43.780
A process can have its own sandbox.

00:52:43.780 --> 00:52:45.440
There is not a limited
number of sandboxes.

00:52:45.440 --> 00:52:46.450
It's not predefined.

00:52:46.490 --> 00:52:50.020
It doesn't require privilege to use.

00:52:50.050 --> 00:52:54.310
So an unprivileged application
can put itself in a sandbox,

00:52:54.690 --> 00:52:56.130
but you cannot escalate privilege.

00:52:56.140 --> 00:52:58.630
So you can't say,
I'm going to put this thing in a sandbox,

00:52:58.630 --> 00:53:01.840
but I'm also going to give it access
to write into the root directory.

00:53:01.840 --> 00:53:07.030
You can only create sandboxes that have
less privilege than you currently have.

00:53:09.020 --> 00:53:12.710
This is included in the developer seed.

00:53:12.820 --> 00:53:16.660
The sandbox is defined
right now by a text profile.

00:53:16.660 --> 00:53:21.090
There are three examples in
the seed in user share sandbox.

00:53:21.200 --> 00:53:25.100
And the whole design of the
sandboxing mechanism is designed

00:53:25.100 --> 00:53:27.270
to be cooperative with apps.

00:53:27.410 --> 00:53:31.800
So we designed this in a way so
that if you're building an app,

00:53:31.830 --> 00:53:35.390
you would think about building a profile,
a sandboxing profile to

00:53:35.410 --> 00:53:37.370
go along with that app.

00:53:40.860 --> 00:53:42.420
So let's talk a little bit
about the profile language.

00:53:42.450 --> 00:53:44.500
I said that it was a text-based language.

00:53:44.530 --> 00:53:46.380
It is very provisional.

00:53:46.380 --> 00:53:47.660
It's subject to change.

00:53:47.660 --> 00:53:49.510
There are things we
would like to add to it.

00:53:49.660 --> 00:53:52.430
We're sure there are things that
you would like us to add to it.

00:53:52.500 --> 00:53:53.760
So we want your feedback.

00:53:53.760 --> 00:53:55.820
We definitely want your feedback on this.

00:53:55.820 --> 00:53:59.720
The profile, at its basic level,
consists of rules and filters.

00:53:59.790 --> 00:54:02.700
It ends up getting compiled
for the policy engine,

00:54:02.760 --> 00:54:04.710
which executes up in the kernel.

00:54:04.710 --> 00:54:07.160
So there's strong enforcement here.

00:54:08.110 --> 00:54:10.950
There are three examples, as I say,
shipped on the developer seed in there.

00:54:10.950 --> 00:54:12.080
You can go look at there.

00:54:12.080 --> 00:54:15.870
And after this session,
there will be a little cheat sheet

00:54:15.890 --> 00:54:19.910
and a language definition for
the profile language available

00:54:19.910 --> 00:54:22.460
at this session's developer page.

00:54:24.910 --> 00:54:27.220
So here's a very simple example.

00:54:27.220 --> 00:54:29.590
I'm going to give a demonstration
of this example a bit later on,

00:54:29.700 --> 00:54:31.500
so you'll have to memorize
everything on the screen here

00:54:31.570 --> 00:54:32.660
to make sure I'm not cheating.

00:54:32.660 --> 00:54:35.860
At the top here,
there's a version number.

00:54:35.860 --> 00:54:38.860
We're definitely going
to make some changes,

00:54:38.860 --> 00:54:44.990
so we're trying to point out that this
is going to change and subject to change,

00:54:45.040 --> 00:54:47.230
so don't build any products
based upon this language.

00:54:48.240 --> 00:54:51.040
There is a debugging facility,
which we've got turned off right now.

00:54:51.040 --> 00:54:54.780
In this profile,
everything is denied by default,

00:54:54.780 --> 00:54:59.580
so you get no access to any operating
system resources by default.

00:54:59.930 --> 00:55:04.420
Parentage allows things like fork, exec,
and spawn to actually operate.

00:55:04.440 --> 00:55:06.660
And because this example
and the demonstration is

00:55:06.660 --> 00:55:09.380
going to be running a shell,
all of the sub-processes

00:55:09.380 --> 00:55:10.950
need to get launched.

00:55:10.950 --> 00:55:11.880
So I need that.

00:55:11.980 --> 00:55:14.790
SysControl read-only,
that's a little bit of

00:55:14.790 --> 00:55:17.200
boilerplate that we need for DYLD.

00:55:17.200 --> 00:55:19.960
That's reading some system
configuration information.

00:55:19.960 --> 00:55:22.790
And we're not going to
allow any network access.

00:55:22.830 --> 00:55:26.080
So in this demonstration,
it won't be possible to make any

00:55:26.100 --> 00:55:28.270
network access off the machine.

00:55:28.710 --> 00:55:44.610
For this process.

00:55:44.790 --> 00:55:44.790
So then there's a couple of lines
to allow DYLD to load and then

00:55:44.790 --> 00:55:44.790
for applications to load and run.

00:55:44.790 --> 00:55:44.790
And then here's the little example.

00:55:44.790 --> 00:55:44.790
I'm going to allow
reading the file readme,

00:55:44.790 --> 00:55:44.790
but not writing or removing it.

00:55:45.250 --> 00:55:48.080
So that's any path on
the system that says,

00:55:48.100 --> 00:55:48.780
read me.

00:55:48.900 --> 00:55:51.460
I'm going to be able to read it,
but not write to it or remove it.

00:55:51.560 --> 00:55:55.410
I'm going to deny reading
any file named secret,

00:55:55.410 --> 00:55:58.500
but I'm allowed to write to that file.

00:55:58.680 --> 00:56:03.500
And lastly,
any other file I can read on the system.

00:56:05.260 --> 00:56:06.640
So that was a little introduction.

00:56:06.680 --> 00:56:09.860
The general form of the
language is a sequence of

00:56:09.860 --> 00:56:15.000
operations followed by an action,
whether that currently is allow or deny,

00:56:15.000 --> 00:56:17.380
and then you can apply
filters to that action.

00:56:17.380 --> 00:56:21.970
And those filters for path
names and string-like objects

00:56:21.970 --> 00:56:26.080
are regular expressions,
and that's also true for

00:56:26.090 --> 00:56:28.780
network addresses and ports.

00:56:28.780 --> 00:56:30.280
It's a little regular expression-y.

00:56:32.280 --> 00:56:37.770
Sorry, I'm getting a look from one
of the implementers down here.

00:56:38.160 --> 00:56:41.640
So here is the list of
operations that can be performed.

00:56:41.750 --> 00:56:46.780
This is described,
the actual documentation and explanation

00:56:46.780 --> 00:56:51.570
of what all these mean is in the
documentation guide that you can

00:56:51.980 --> 00:56:54.990
download from the session website.

00:56:55.700 --> 00:56:58.600
The regular expressions,
they're mostly POSIX 0.2.

00:56:58.600 --> 00:57:02.200
Then there's no backtracking
allowed in regular expressions.

00:57:02.200 --> 00:57:05.670
And there are some additional
character classes that we've

00:57:05.790 --> 00:57:09.370
defined that allow construction
of the strings a little easier.

00:57:09.380 --> 00:57:14.800
So in these examples,
there's a file name and paths which

00:57:14.800 --> 00:57:20.900
eliminate access to dot and dot dot,
so you can't escape out.

00:57:24.040 --> 00:57:27.000
So this is an excerpt from
the profile that's shipped

00:57:27.000 --> 00:57:30.010
on the Leopard Seed for NTPD.

00:57:30.040 --> 00:57:34.250
And what this actually does here is
allow NTPD to access the network.

00:57:34.300 --> 00:57:43.090
It allows it to modify the
NTP configuration file and the key files.

00:57:43.100 --> 00:57:45.020
It allows it to read those two files,
I'm sorry.

00:57:45.020 --> 00:57:48.820
And it allows it to write the
NTP drift file and a temporary

00:57:48.820 --> 00:57:51.410
file when it's renaming that.

00:57:52.520 --> 00:57:57.240
And it also allows it
to create the PID file.

00:57:57.200 --> 00:57:59.400
It also allows the time to be set.

00:57:59.460 --> 00:58:04.670
So this example, if you apply it to NTPD,
when running, let's suppose that NTPD,

00:58:04.670 --> 00:58:07.440
tomorrow somebody finds
a buffer overflow.

00:58:07.440 --> 00:58:11.000
If you were running under this profile,
the attacker would not be

00:58:11.090 --> 00:58:12.690
able to exec any programs.

00:58:12.690 --> 00:58:18.300
The only files they will be able to write
to are the etc.ntp.conf and keys file,

00:58:18.300 --> 00:58:20.710
the drift file, and the pid file.

00:58:20.790 --> 00:58:23.960
No other files on the system will
be accessible by that program.

00:58:25.220 --> 00:58:27.890
And that's pretty much, you know,
that's what they could do.

00:58:27.900 --> 00:58:30.310
So the only things that they
could do if they exploited NTPD,

00:58:30.430 --> 00:58:33.180
they managed to generate a buffer
overflow to try and exploit it,

00:58:33.260 --> 00:58:36.550
is they could do the same things as NTPD,
which is not very exciting.

00:58:36.550 --> 00:58:42.080
You're not going to generate a
self-propagating worm that does any

00:58:42.480 --> 00:58:45.600
damage to a system using NTPD like that.

00:58:45.660 --> 00:58:47.760
Okay.

00:58:47.760 --> 00:58:49.980
You can do a denial of service, maybe.

00:58:54.580 --> 00:58:56.490
Okay, yeah,
we're going to have some questions later.

00:58:56.490 --> 00:58:58.560
Sorry.

00:59:00.860 --> 00:59:02.150
You can't harm the user system.

00:59:02.160 --> 00:59:05.360
So here's a usage example.

00:59:05.360 --> 00:59:07.170
This tool is also on the Leopard Seed.

00:59:07.170 --> 00:59:11.860
There is a sandbox exec program,
and you can provide it either

00:59:11.980 --> 00:59:16.260
a path to a profile or a
profile string in its entirety.

00:59:16.300 --> 00:59:25.240
You can also use this mechanism to
launch programs via launchd by prepending

00:59:25.240 --> 00:59:29.820
sandbox exec to the launchd command.

00:59:32.710 --> 00:59:37.540
And we also have a little API for
launching things into a sandbox so that

00:59:37.540 --> 00:59:44.320
an application can also launch itself
into a sandbox and get some cleanup.

00:59:44.890 --> 00:59:47.830
So now I'm going to show
you a little demonstration.

00:59:53.110 --> 00:59:56.940
All righty, so now we're going to,
just to show you that we've

00:59:56.990 --> 00:59:59.050
got network access here.

01:00:02.760 --> 01:00:04.800
Okay, that's a text version
of the Google web page.

01:00:04.960 --> 01:00:09.540
Very exciting.

01:00:11.000 --> 01:00:17.100
[Transcript missing]

01:00:17.450 --> 01:00:23.120
I have the secret file
and I have the profile.

01:00:23.370 --> 01:00:26.800
So this is the same profile
that was up on the slide.

01:00:28.700 --> 01:00:33.400
And now we are going to...
So the profile doesn't allow,

01:00:33.400 --> 01:00:35.620
I'll just go over this again,
it allows fork and exec.

01:00:35.690 --> 01:00:38.520
So when I run this profile,
I'm going to be running bash.

01:00:38.520 --> 01:00:41.080
So I want to allow sub-programs to run.

01:00:41.080 --> 01:00:42.460
They inherit the sandbox.

01:00:42.530 --> 01:00:44.590
I didn't actually say that earlier,
I should have.

01:00:46.280 --> 01:00:48.070
It does not allow any network access.

01:00:48.300 --> 01:00:51.960
It allows DYLD to operate so
that it can load programs.

01:00:51.960 --> 01:00:55.440
And I can read the readme,
but I can't write to it or remove it.

01:00:55.550 --> 01:01:00.300
And I can't read the secret
file and every other file

01:01:00.300 --> 01:01:02.830
I can read on the system.

01:01:14.620 --> 01:01:16.490
So here we are in the sandbox.

01:01:16.710 --> 01:01:26.120
So let's show that-- so we're not
able to connect to the network.

01:01:26.130 --> 01:01:28.420
So it says permission denied.

01:01:32.460 --> 01:01:33.690
So here's the README file.

01:01:33.890 --> 01:01:35.960
It allows me to do that still.

01:01:36.000 --> 01:01:41.610
I can't access the secret file.

01:01:43.250 --> 01:01:49.050
So I also am not able to
remove the readme file.

01:01:58.350 --> 01:02:00.060
So I'm going to add
something to the secret file,

01:02:00.060 --> 01:02:02.560
and that allowed me to add
something to the secret file.

01:02:02.580 --> 01:02:05.720
But-- whoops.

01:02:08.200 --> 01:02:11.570
I still can't read the secret file.

01:02:11.630 --> 01:02:13.330
So let's exit out of there.

01:02:13.510 --> 01:02:15.510
So we're now back at the regular shell.

01:02:15.810 --> 01:02:20.000
And, oops, I guess I don't have
completion turned on.

01:02:20.000 --> 01:02:27.070
So there's the secret file
again out of the sandbox.

01:02:33.740 --> 01:02:40.500
Can we go back to the slides, please?

01:02:40.570 --> 01:02:41.540
So here's a summary.

01:02:41.540 --> 01:02:44.170
This is a technology preview.

01:02:44.180 --> 01:02:46.530
This is subject to change.

01:02:46.630 --> 01:02:52.460
We would like you to play in the sandbox,
do some things with it, send us feedback.

01:02:52.510 --> 01:02:57.820
We have documentation after the session,
which should be up in the session area.

01:02:57.820 --> 01:03:00.720
There's some sample profiles
in UserShare sandbox.

01:03:00.720 --> 01:03:04.430
There's a header file in UserInclude
sandbox for using the API.

01:03:04.500 --> 01:03:06.620
There's a binary on your
system that you can play with,

01:03:06.620 --> 01:03:08.660
userbin sandbox exec.

01:03:08.770 --> 01:03:13.290
There is a mailing list,
which does not quite exist yet.

01:03:13.350 --> 01:03:16.490
I'm not sure when it's going to show up.

01:03:16.500 --> 01:03:19.540
SandboxingDev@lists.apple.com.

01:03:19.540 --> 01:03:22.640
That's the list we would like
people to use to send us feedback,

01:03:22.780 --> 01:03:24.780
suggestions on this technology.
WEBVTT

00:00:10.280 --> 00:00:11.900
Good morning, everyone.

00:00:11.900 --> 00:00:16.490
Thank you all for coming to session 536,
Developing Xsan-Friendly Applications.

00:00:16.500 --> 00:00:17.500
My name is Jason Thorpe.

00:00:17.500 --> 00:00:21.450
I'm the engineering manager for Xsan.

00:00:22.710 --> 00:00:25.840
So here's a little bit about
what you're going to learn today.

00:00:25.970 --> 00:00:30.980
First of all, you're going to learn what
XAN is and how it works.

00:00:30.980 --> 00:00:32.640
Raise your hand if
you're an XAN user today.

00:00:32.640 --> 00:00:33.560
You have one deployed.

00:00:33.560 --> 00:00:33.750
All right.

00:00:33.800 --> 00:00:34.460
That's a good amount of you.

00:00:34.460 --> 00:00:36.130
So for you guys,
this is going to be a review,

00:00:36.190 --> 00:00:38.480
because I'm sure you're
all familiar with it.

00:00:38.480 --> 00:00:41.940
How many of you are
considering deploying an XAN?

00:00:41.940 --> 00:00:45.420
And how many of you are
developing applications that

00:00:45.420 --> 00:00:47.680
you would like to work with XAN?

00:00:47.680 --> 00:00:50.450
OK, so this background information,
you guys are really going

00:00:50.510 --> 00:00:54.000
to pay attention to this,
especially application developers.

00:00:54.000 --> 00:00:55.930
Secondly,
we're going to talk about some of

00:00:55.930 --> 00:00:57.840
the XAN volume characteristics.

00:00:57.840 --> 00:01:00.660
Again, application developers pay
careful attention to this.

00:01:00.660 --> 00:01:02.760
This is really targeted at you guys.

00:01:02.770 --> 00:01:05.780
And finally,
we're going to talk about tips on making

00:01:05.780 --> 00:01:11.010
those applications both compatible
and how to make them work better.

00:01:12.150 --> 00:01:16.100
So let's just jump right into the basics.

00:01:16.110 --> 00:01:20.090
So for those of you who don't know,
Xsan is the SAN file system for Mac OS X.

00:01:20.210 --> 00:01:22.950
SAN stands for Storage Area Network.

00:01:23.140 --> 00:01:26.020
Network -- that's a key
concept to keep in mind as we

00:01:26.080 --> 00:01:28.100
go throughout this discussion.

00:01:28.100 --> 00:01:31.430
It actually describes a lot
of the behaviors -- explains a

00:01:31.430 --> 00:01:34.100
lot of the behaviors of Xsan.

00:01:34.100 --> 00:01:37.990
What Xsan does is it allows multiple
computers to have high-speed

00:01:37.990 --> 00:01:40.100
access to a shared pool of storage.

00:01:40.180 --> 00:01:44.140
And it differs from the traditional
file server in a number of ways,

00:01:44.140 --> 00:01:45.850
which we'll go into shortly.

00:01:46.100 --> 00:01:51.390
And let's just take a look at what
some customers are saying about Xsan.

00:01:52.630 --> 00:01:57.260
So, JW2,
they are the in-house production facility

00:01:57.260 --> 00:02:00.840
for the award-winning JWT ad agency.

00:02:00.840 --> 00:02:04.800
And Xsan has allowed them
and their creative staff to

00:02:04.800 --> 00:02:08.120
work in a really organic way,
to collaborate in ways

00:02:08.140 --> 00:02:10.370
they couldn't do before,
because they can share all

00:02:10.390 --> 00:02:12.780
their assets quite easily.

00:02:18.000 --> 00:02:22.900
So, Bunamuri Productions,
they're a television production company.

00:02:22.900 --> 00:02:26.390
They make some TV shows you
may have seen or heard of,

00:02:26.400 --> 00:02:32.050
including MTV's "The Real World" and
Fox's "Simple Life." The combination

00:02:32.110 --> 00:02:36.240
of Xsan and Final Cut Pro has allowed
them to do all their TV production

00:02:36.240 --> 00:02:39.200
editing really in real time.

00:02:39.200 --> 00:02:41.400
You know,
they're on really tight schedules,

00:02:41.400 --> 00:02:45.080
and it allows them to do this very
quickly at a fraction of the cost of

00:02:45.080 --> 00:02:47.300
other solutions that are out there.

00:02:52.420 --> 00:02:54.580
So how many of you watched the Olympics?

00:02:54.610 --> 00:02:55.680
Raise your hand.

00:02:55.680 --> 00:02:58.510
Did you enjoy some of the stuff
that they were able to do?

00:02:58.650 --> 00:03:02.900
So NBC actually had a very large Xsan.

00:03:02.900 --> 00:03:05.500
It was over 20 terabyte.

00:03:05.500 --> 00:03:09.700
And they used a completely Mac-based
workflow on that Xsan to take

00:03:09.700 --> 00:03:14.240
the content from the cameras that
are out at the actual events,

00:03:14.240 --> 00:03:18.160
edit it, add motion graphics and
commentary and whatnot.

00:03:18.240 --> 00:03:20.670
And they actually had three
Power Mac G5s that were connected

00:03:20.670 --> 00:03:24.710
to the Xsan that were able to play
that content out directly to air.

00:03:26.490 --> 00:03:29.700
And of course,
these are just a few examples of the many

00:03:29.700 --> 00:03:32.540
organizations that are using Xsan today.

00:03:33.700 --> 00:03:38.450
So the benefits that Xsan brings
to its customers has really enabled

00:03:38.450 --> 00:03:42.120
-- has really made Xsan one of,
if not the fastest-growing

00:03:42.130 --> 00:03:45.600
SAN solutions out there in terms
of the number of deployments.

00:03:45.610 --> 00:03:48.400
So what does this mean to you
as application developers?

00:03:48.400 --> 00:03:51.030
Well, first and foremost,
it means that if your

00:03:51.250 --> 00:03:55.100
application is compatible with,
you know, works well with Xsan,

00:03:55.100 --> 00:03:58.050
it's going to have an advantage in
the marketplace up against another,

00:03:58.060 --> 00:04:00.500
you know,
competing product that does not.

00:04:00.500 --> 00:04:03.080
It also means that as the
number of Xsan deployments grow,

00:04:03.080 --> 00:04:06.040
you know, one of the things that we
hear a lot from customers is,

00:04:06.100 --> 00:04:07.700
"Hey, you know, does this work with Xsan?

00:04:07.700 --> 00:04:13.590
Does that work with Xsan?" And, you know,
your application doesn't want to be

00:04:13.590 --> 00:04:16.630
left out as more places adopt Xsan.

00:04:18.520 --> 00:04:20.400
So that's what Xsan is.

00:04:20.400 --> 00:04:23.640
Let's talk about some of how it works.

00:04:23.740 --> 00:04:27.640
So what we see here is
a very basic Xsan setup.

00:04:27.760 --> 00:04:29.400
What we're going to do is
kind of just walk through,

00:04:29.500 --> 00:04:31.130
highlight each piece,
and describe a little

00:04:31.190 --> 00:04:33.390
bit about what it does.

00:04:33.490 --> 00:04:36.940
So first of all,
we have the Xsan controller.

00:04:37.160 --> 00:04:42.840
So the Xsan controller is really -- it's
kind of the key focal piece of the SAN.

00:04:42.840 --> 00:04:48.560
It actually controls all aspects
of file access within the volume.

00:04:48.600 --> 00:04:53.290
It's not involved in the data transfer,
but it actually controls where

00:04:53.290 --> 00:04:56.780
the data is located on the disk,
how blocks are allocated,

00:04:56.840 --> 00:05:01.600
the policy for block allocation,
and also manages all the volume metadata.

00:05:01.600 --> 00:05:04.260
So this is not to be confused
with Spotlight metadata.

00:05:04.340 --> 00:05:07.700
We're talking about very basic
things like file attributes such

00:05:07.700 --> 00:05:09.600
as the owner group and permissions.

00:05:09.600 --> 00:05:12.840
And also it manages all
the directory entries.

00:05:12.840 --> 00:05:16.340
So anything revolving
around file creation,

00:05:16.340 --> 00:05:19.060
deletion, and renaming,
all that is handled by

00:05:19.060 --> 00:05:20.840
the Xsan controller.

00:05:20.840 --> 00:05:24.500
And the Xsan controller also
manages the byte range locks.

00:05:24.500 --> 00:05:27.460
So unlike some other
SAN solutions that are out there,

00:05:27.500 --> 00:05:32.500
Xsan provides file-based locking that
has the granularity of individual

00:05:32.500 --> 00:05:36.540
ranges of bytes within a file,
whereas other SAN solutions out

00:05:36.620 --> 00:05:39.790
there might lock out all other
clients from updating files,

00:05:39.900 --> 00:05:40.510
writing files,
while one other computer is operating.

00:05:40.600 --> 00:05:41.680
So it's a very simple setup.

00:05:41.880 --> 00:05:42.600
So let's talk about the Xsan controller.

00:05:42.600 --> 00:05:44.470
is updating them.

00:05:45.990 --> 00:05:49.350
So the next piece -- there's no real
surprise here -- is the XServe RAID.

00:05:49.360 --> 00:05:50.880
It basically provides
the backend storage.

00:05:50.960 --> 00:05:55.430
So it stores your volume
metadata and your file data.

00:05:56.530 --> 00:05:58.400
Next, we have the clients.

00:05:58.400 --> 00:06:02.970
These are the workstations,
the servers that actually connect to

00:06:02.970 --> 00:06:04.900
the SAN and use the SAN to do work.

00:06:04.900 --> 00:06:07.400
It might be a
Final Cut Pro editing station,

00:06:07.510 --> 00:06:11.490
it might be a cluster node
in an HPC environment,

00:06:11.490 --> 00:06:14.000
or it might be a server that's
providing file services to

00:06:14.100 --> 00:06:15.900
other clients on the network.

00:06:15.900 --> 00:06:20.400
The clients actually access the
data directly over Fibre Channel.

00:06:20.400 --> 00:06:22.900
They don't actually have to go through
the controller to get that data,

00:06:22.900 --> 00:06:26.900
so that makes it unlike a sort
of traditional file server.

00:06:26.950 --> 00:06:29.650
However, they do have to send messages
to the controller to gain

00:06:29.650 --> 00:06:33.900
access to that file data,
which we'll go over in just a minute.

00:06:36.140 --> 00:06:39.500
So next here we have the
Fiber Channel Switch.

00:06:39.500 --> 00:06:43.100
This is really kind of the glue
piece that binds everything together.

00:06:43.100 --> 00:06:45.700
It allows you to connect your clients,
your controller,

00:06:45.700 --> 00:06:48.690
and all the RAIDs together to
form what we call a fabric.

00:06:48.730 --> 00:06:52.360
Without the switch,
you'd be able to only do really a

00:06:52.360 --> 00:06:56.330
direct-attach scenario where you have
one computer attached to a single RAID.

00:06:56.380 --> 00:07:01.690
And it's useful in some environments,
but not in others.

00:07:03.310 --> 00:07:06.800
So we can't forget the cables, of course.

00:07:06.800 --> 00:07:10.110
And then finally,
we have a private Ethernet network

00:07:10.260 --> 00:07:13.320
that connects all the clients
and the controllers together.

00:07:13.520 --> 00:07:16.940
A lot of people ask me, "Well,
why do we have this private Ethernet

00:07:17.270 --> 00:07:20.910
network?" The reason we have this is
because the messages that are sent

00:07:20.910 --> 00:07:25.920
between the clients and the controller,
they're very small.

00:07:26.040 --> 00:07:29.790
And for those of you who have been
network administrators for a long time,

00:07:29.900 --> 00:07:36.420
you know that small packets are kind
of the pessimal workload for a network.

00:07:36.420 --> 00:07:43.010
So by keeping the SAN traffic away from
your normal local area network traffic,

00:07:43.010 --> 00:07:45.220
you're kind of doing two things.

00:07:45.220 --> 00:07:47.300
First of all,
you're preventing the SAN traffic from

00:07:47.300 --> 00:07:50.860
slowing down your email reading and your
web surfing and all the other things

00:07:50.860 --> 00:07:52.690
that you do on your local area network.

00:07:52.720 --> 00:07:55.060
At the same time,
you're also preventing the

00:07:55.080 --> 00:07:58.160
traffic on your local area
network from kind of competing for

00:07:58.160 --> 00:07:59.950
the available network resources
that the SAN network is providing.

00:07:59.950 --> 00:08:02.080
So you can see here that the
SAN network is actually using the

00:08:02.110 --> 00:08:04.530
same network that the SAN uses,
which actually improves the

00:08:04.530 --> 00:08:06.980
overall performance of the SAN,
because you need to have that

00:08:06.980 --> 00:08:09.530
responsiveness between the
client and the controller.

00:08:12.030 --> 00:08:15.870
So, unlike other volume formats
supported by Mac OS X,

00:08:16.030 --> 00:08:19.000
Xsan has this concept of storage pools.

00:08:19.000 --> 00:08:23.500
It allows you to actually structure
your data around on the disks in kind of

00:08:23.500 --> 00:08:26.000
different ways that match your workload.

00:08:26.000 --> 00:08:31.670
Now, you always have to have one
storage pool that's dedicated

00:08:31.760 --> 00:08:33.000
to holding your volume metadata.

00:08:33.000 --> 00:08:37.000
Here we've highlighted one
of the RAID sets there.

00:08:37.000 --> 00:08:39.560
We actually strongly recommend
that you put this on its own

00:08:39.560 --> 00:08:41.000
dedicated RAID controller.

00:08:41.110 --> 00:08:44.850
The reason for this is that the
transactions involved in the

00:08:44.850 --> 00:08:48.880
volume metadata are -- again,
they're small -- and you don't

00:08:48.880 --> 00:08:53.000
want those to really interfere
with the streaming of data.

00:08:53.000 --> 00:08:56.000
You know,
say you have a large video clip to read.

00:08:56.000 --> 00:09:00.430
You don't want these individual metadata
transactions to be interfering with being

00:09:00.430 --> 00:09:01.970
able to stream the data off the disk.

00:09:02.000 --> 00:09:04.650
So, again,
we strongly recommend that you have

00:09:04.650 --> 00:09:06.910
a dedicated RAID controller for this.

00:09:07.800 --> 00:09:11.440
Next, in our little example here,
what we've done is we've actually

00:09:11.480 --> 00:09:16.750
pooled the other RAID sets together
to form a single large storage pool.

00:09:17.200 --> 00:09:20.550
Another thing that Xsan allows you
to do is to create what we call

00:09:20.550 --> 00:09:25.100
"affinities" -- it allows you to assign
an affinity to a folder in the volume.

00:09:25.160 --> 00:09:31.320
What that does is it allows you to steer
data to individual storage pools just

00:09:31.320 --> 00:09:33.140
simply by copying it to that folder.

00:09:33.140 --> 00:09:37.140
Now, in this example here,
it doesn't make much sense --

00:09:37.140 --> 00:09:40.320
we only have one user data pool,
but as we go along the slide,

00:09:40.320 --> 00:09:45.130
you'll see how this makes a
little more sense as we go along.

00:09:46.730 --> 00:09:49.740
And, of course,
one of the things that's really nice

00:09:49.740 --> 00:09:52.990
about Xsan is that the controller
really puts us all together and shows

00:09:52.990 --> 00:09:54.600
it just as one volume on the desktop.

00:09:54.600 --> 00:09:58.780
You don't have to put your users
through dealing with 12 different

00:09:58.790 --> 00:10:01.600
drive icons in a desktop just to
know where to store their data.

00:10:01.600 --> 00:10:03.620
It's all one volume.

00:10:04.720 --> 00:10:07.360
Now, in this example,
we're talking about just one volume.

00:10:07.360 --> 00:10:09.090
Of course,
you're not limited to just one.

00:10:09.260 --> 00:10:12.150
You can actually have up to 20 of these.

00:10:14.330 --> 00:10:17.740
So what we're going to do now is we're
going to just kind of step through a

00:10:17.760 --> 00:10:22.690
simplified write operation and highlight
each of the components that's involved,

00:10:22.690 --> 00:10:25.940
just to kind of illustrate
better a little how this works.

00:10:25.940 --> 00:10:28.520
So first of all,
the application on our client

00:10:28.520 --> 00:10:31.310
here decides it wants to
write some data to the volume.

00:10:31.400 --> 00:10:37.120
So it uses the write system call,
and in response,

00:10:37.130 --> 00:10:42.960
the Xsan client software on that computer
sends a message to the controller,

00:10:42.960 --> 00:10:47.060
Basically asking where that
file is located on disk.

00:10:48.800 --> 00:10:51.150
So next,
the controller consults the volume

00:10:51.150 --> 00:10:54.770
metadata that we have on our first
RAID set there and basically it

00:10:54.770 --> 00:10:59.600
traverses its data structures to
determine where that file is located.

00:10:59.600 --> 00:11:02.020
If the data blocks for that
file are not allocated,

00:11:02.140 --> 00:11:04.820
it goes ahead and allocates them.

00:11:05.620 --> 00:11:08.500
And then it responds back to
the client with what we call an

00:11:08.500 --> 00:11:12.660
"extent list," which basically
describes the layout of that file.

00:11:13.070 --> 00:11:20.430
Each time the client has to write a file,
let's say for example that this client

00:11:20.440 --> 00:11:24.000
wanted to write the same range of the
file over and over and over again.

00:11:24.060 --> 00:11:26.850
It does not actually have to
contact the controller each time.

00:11:26.980 --> 00:11:31.580
It is able to cache the information,
and then the controller will send

00:11:31.600 --> 00:11:35.390
a notification to the client when
that information becomes out of date.

00:11:35.910 --> 00:11:38.370
So,
armed with that extent list information,

00:11:38.380 --> 00:11:41.550
the client is then able to go
over Fibre Channel directly

00:11:41.550 --> 00:11:42.730
to write that data to disk.

00:11:42.800 --> 00:11:46.010
Now,
note here that the controller actually

00:11:46.010 --> 00:11:52.030
allocated the storage for that file
and spread it across each of the three

00:11:52.120 --> 00:11:54.800
RAID sets in our User Data Storage Pool.

00:11:54.800 --> 00:11:57.900
And by doing so,
it actually allowed the client

00:11:57.900 --> 00:12:02.740
to write to those three RAIDs in
parallel to increase the throughput.

00:12:07.550 --> 00:12:14.500
So that's how Xsan works, basically.

00:12:14.500 --> 00:12:16.320
And this little example
isn't all that interesting.

00:12:16.320 --> 00:12:17.320
There's just one computer.

00:12:17.320 --> 00:12:19.240
This is kind of glorified
direct-attached storage.

00:12:19.250 --> 00:12:22.960
But one of the beauties of Xsan,
of course, is because it's a network,

00:12:22.960 --> 00:12:26.140
it allows you to connect
multiple clients to the SAN.

00:12:26.140 --> 00:12:31.120
They have access to the SAN,
first-class access to that storage

00:12:31.150 --> 00:12:34.260
on a kind of a peer-to-peer level.

00:12:34.260 --> 00:12:39.760
Now, let's say you've been using your
SAN for a while and you suddenly

00:12:39.760 --> 00:12:44.620
realize that you need some new
space to store your audio clips.

00:12:44.620 --> 00:12:48.710
You've run out of space or your
audio clips are kind of interfering

00:12:48.830 --> 00:12:52.540
with being able to stream video
off of your other storage pool.

00:12:52.640 --> 00:12:55.320
Xsan actually would then
just simply allow you to

00:12:55.400 --> 00:12:58.610
plop on another storage pool,
expand the volume without

00:12:58.610 --> 00:13:01.520
having to recreate it,
and you could basically add

00:13:01.520 --> 00:13:03.680
another storage pool for this
different kind of workload.

00:13:03.680 --> 00:13:06.330
You could tune that second
storage pool for the type of

00:13:06.420 --> 00:13:07.710
data you want to put on it.

00:13:07.760 --> 00:13:10.020
And this is where affinities
would become very useful.

00:13:10.020 --> 00:13:12.260
You could create a folder at
the top level of your volume,

00:13:12.260 --> 00:13:14.980
say this is my audio folder,
assign it to that pool.

00:13:14.980 --> 00:13:18.840
Any content that went in there would be
automatically assigned to those drives,

00:13:18.840 --> 00:13:21.910
and it wouldn't interfere with
being able to read and write data

00:13:21.910 --> 00:13:23.620
quickly from the other storage pool.

00:13:23.650 --> 00:13:27.900
Now, let's say, for example, again,
that you've gone from

00:13:27.900 --> 00:13:29.490
shooting static to video.

00:13:29.490 --> 00:13:32.840
And you've got a lot of data
that's standard definition video

00:13:32.970 --> 00:13:36.500
to moving to high definition video,
and suddenly you realize that

00:13:36.500 --> 00:13:38.680
you need more throughput.

00:13:38.700 --> 00:13:43.060
Well, again, XAN would simply allow
you to add another RAID.

00:13:43.060 --> 00:13:45.720
It would allow you to assign that
RAID to your existing storage

00:13:45.860 --> 00:13:49.960
pool and to expand the throughput
available to that storage pool.

00:13:51.080 --> 00:14:03.240
Xsan also allows you to add
redundant volume controllers.

00:14:04.480 --> 00:14:04.500
This basically protects you in the
event that your primary controller

00:14:04.500 --> 00:14:04.500
were to fail for some reason,
for any of the number of reasons

00:14:04.500 --> 00:14:04.500
that computers sometimes fail.

00:14:06.350 --> 00:14:08.610
So, that's how it works.

00:14:08.880 --> 00:14:13.430
Let's talk a little bit about the
characteristics of Xsan volumes.

00:14:14.630 --> 00:14:19.170
So, the next point I'm about to make
is probably the most important

00:14:19.170 --> 00:14:21.800
one I can say to all you
application developers out there.

00:14:21.800 --> 00:14:24.000
If this is the one thing that
you were to come away with,

00:14:24.000 --> 00:14:31.480
I would want it to be this:
Xsan is not HFS+. It has a much different

00:14:31.480 --> 00:14:36.380
heritage than HFS+. The technological
underpinnings are very different.

00:14:36.500 --> 00:14:39.550
In a lot of ways,
it does not have some of the same

00:14:39.570 --> 00:14:42.490
capabilities or features that HFS+ has.

00:14:42.490 --> 00:14:45.720
And so,
we find that when applications depend

00:14:45.720 --> 00:14:50.790
on some of those features of HFS+, the
applications either do not perform well

00:14:50.790 --> 00:14:53.090
on Xsan or they'll fail to work at all.

00:14:54.860 --> 00:14:58.240
So it's not like HFS+. Well,
what is it like?

00:14:58.240 --> 00:15:00.920
Well, in many ways,
it is like any direct attached

00:15:00.920 --> 00:15:02.580
volume that you have on your system.

00:15:02.580 --> 00:15:04.640
You have high speed access to that data.

00:15:04.640 --> 00:15:08.080
You can depend on that sort
of performance profile.

00:15:08.080 --> 00:15:12.180
However,
remember that XAN has to communicate with

00:15:12.180 --> 00:15:16.210
a controller to do things like change
file attributes or even look up a file,

00:15:16.210 --> 00:15:18.800
because it has to do path name
resolution through that controller.

00:15:18.800 --> 00:15:22.120
So in many ways,
it behaves a lot like a network volume.

00:15:22.120 --> 00:15:26.140
And with all the sort of latency and
whatnot that go along with those type

00:15:26.140 --> 00:15:28.650
of operations on a network volume.

00:15:29.960 --> 00:15:34.500
So, Xsan is also a POSIX volume format.

00:15:34.520 --> 00:15:37.820
This is where most of the
differences of HFS+ really lie.

00:15:37.980 --> 00:15:43.400
In a lot of ways,
Xsan is very much like UFS in the way

00:15:43.400 --> 00:15:45.900
it behaves in terms of its POSIX-ness.

00:15:45.900 --> 00:15:49.670
And in fact, one of the first things that
the Xsan engineering team does

00:15:49.670 --> 00:15:53.000
is when we see a compatibility
problem with an application,

00:15:53.000 --> 00:15:56.100
the first thing we do is attempt
to reproduce that problem with

00:15:56.110 --> 00:15:58.900
the UFS file system because
they're so alike in many ways.

00:15:58.900 --> 00:16:01.860
So, first of all,
there's no resource fork.

00:16:01.930 --> 00:16:04.900
So, it's a single-fork file system.

00:16:04.900 --> 00:16:09.050
Any application that uses a resource
fork using the resource manager,

00:16:09.050 --> 00:16:13.080
basically that is going to be
emulated by the file manager,

00:16:13.080 --> 00:16:16.720
and you get those little
dot-on-a-bar Apple double files

00:16:16.720 --> 00:16:18.820
littered all over your file system.

00:16:18.900 --> 00:16:23.320
So, the emulation of the resource fork,
you know, works pretty well,

00:16:23.320 --> 00:16:24.880
but it's not perfect.

00:16:24.890 --> 00:16:27.900
So, just keep that in mind.

00:16:27.900 --> 00:16:29.900
So,
there's also no exchange data operation.

00:16:29.900 --> 00:16:34.000
There are a number of applications out
there that are based on Carbon that

00:16:34.050 --> 00:16:37.650
use exchange data in order to
implement atomic save operations.

00:16:37.970 --> 00:16:40.420
Those did not work on Xsan.

00:16:40.600 --> 00:16:45.140
Next,
there is no catalog search operation.

00:16:45.140 --> 00:16:48.830
Catalog search APIs that are available
in the file manager are very tied to

00:16:48.830 --> 00:16:51.420
the way the HFS+ catalog file works.

00:16:51.530 --> 00:16:55.020
Doing the same types of queries
with the same type of API is

00:16:55.020 --> 00:16:58.600
not really feasible on Xsan,
so we don't provide that underlying

00:16:58.600 --> 00:17:02.500
file system hook that the file
manager uses to do those queries.

00:17:02.500 --> 00:17:05.500
And finally,
Xsan is always case-sensitive.

00:17:06.500 --> 00:17:10.470
So, HFS+ also has the capability of
being a case-sensitive file system.

00:17:10.710 --> 00:17:15.600
However, it is not the default for HFS+.
And this might seem like kind

00:17:15.600 --> 00:17:19.500
of a trivial or minor issue,
but believe it or not,

00:17:19.500 --> 00:17:23.500
when we were doing our qualification
phase with Xsan 1.4 release,

00:17:23.500 --> 00:17:27.500
we actually found a test suite
for an application that failed

00:17:27.500 --> 00:17:33.500
specifically because it encoded
file names inconsistently

00:17:33.500 --> 00:17:34.500
with respect to their case.

00:17:38.180 --> 00:17:40.890
So, with those characteristics in mind,
let's talk about some of the

00:17:40.890 --> 00:17:43.340
important do's and don'ts.

00:17:44.280 --> 00:17:47.960
So, first of all,
every single one of you,

00:17:47.990 --> 00:17:51.200
when you're writing an application
that saves a file to disk,

00:17:51.380 --> 00:17:53.970
you should be using one of
the pre-allocation APIs that

00:17:53.970 --> 00:17:55.200
are available to you.

00:17:55.290 --> 00:17:58.650
You can do this on any
file system -- Xsan,

00:17:58.650 --> 00:18:00.960
HFS -- any file system that
doesn't support it will

00:18:00.960 --> 00:18:04.200
just give you back an error,
which you can just ignore.

00:18:04.320 --> 00:18:08.070
There's no reason not to do this,
and there's plenty of reasons to do this,

00:18:08.210 --> 00:18:10.200
which we'll cover in just a second.

00:18:10.380 --> 00:18:13.200
There's basically two
APIs available to you for this.

00:18:13.200 --> 00:18:16.320
There's the FSAllocate fork
API and the file manager,

00:18:16.320 --> 00:18:20.800
and there's also an F-control
operation for applications that

00:18:20.890 --> 00:18:24.360
are written at the BSD layer,
or if you're a Cocoa application,

00:18:24.360 --> 00:18:29.330
you can use some of the NSFileManager and
FileHandle APIs to get file descriptors

00:18:29.400 --> 00:18:32.200
for those files and then use F-control.

00:18:32.200 --> 00:18:38.190
So, there are really two reasons that
you would want to pre-allocate files.

00:18:38.340 --> 00:18:42.200
One is to minimize file fragmentation,
which is what I have here on my slide.

00:18:42.200 --> 00:18:46.200
Now,
when you're writing a file out to disk,

00:18:46.210 --> 00:18:49.200
the whole thing doesn't
magically appear all at once.

00:18:49.200 --> 00:18:51.150
It gets written out in pieces.

00:18:51.210 --> 00:18:54.210
When that happens,
Xsan has to extend the file

00:18:54.210 --> 00:18:56.200
every time you write to it.

00:18:56.200 --> 00:19:00.120
Now, in many circumstances,
Xsan is able to make good decisions

00:19:00.620 --> 00:19:04.310
about where to allocate those
blocks in order to keep them as

00:19:04.310 --> 00:19:08.190
contiguous on disk as possible,
which helps with reading them back.

00:19:08.190 --> 00:19:09.200
You get higher performance
reading them back.

00:19:09.200 --> 00:19:13.080
But especially in cases where you
have a large number of clients

00:19:13.080 --> 00:19:17.200
that are writing concurrently,
Xsan cannot always make the best choices.

00:19:17.200 --> 00:19:19.730
So, you know,
we really strongly recommend

00:19:19.730 --> 00:19:22.200
that your application,
which, after all,

00:19:22.200 --> 00:19:25.190
has the high-level semantic knowledge
about what's really going on,

00:19:25.200 --> 00:19:28.460
we really recommend that you tell
the file system what you want to

00:19:28.520 --> 00:19:30.200
do instead of making it guess.

00:19:30.200 --> 00:19:34.190
So, this can actually have a
huge impact on performance,

00:19:34.250 --> 00:19:38.190
and what I'm going to do here is
kind of walk through an example,

00:19:38.200 --> 00:19:42.080
of a scenario where an application
was not using preallocation,

00:19:42.200 --> 00:19:44.200
performed badly,
and they used preallocation,

00:19:44.200 --> 00:19:45.190
and they worked great.

00:19:45.200 --> 00:19:48.200
It's an application I'm sure
you're all familiar with.

00:19:48.200 --> 00:19:50.790
It's the iTunes Music Store.

00:19:50.860 --> 00:19:54.150
So the iTunes Music Store,
they actually use Xsan as kind of a

00:19:54.150 --> 00:19:58.110
key component of their workflow that
converts the MPEG-2 content that they

00:19:58.170 --> 00:20:03.770
get from content providers into the iPod
H.264 format that you all know and love.

00:20:03.800 --> 00:20:07.800
Back when there were only a couple
of shows on the iTunes Music Store,

00:20:07.800 --> 00:20:11.800
they had kind of a human-driven
workflow that wasn't perfect,

00:20:11.800 --> 00:20:13.800
but it was workable.

00:20:13.800 --> 00:20:17.170
You know, content came in,
person sat down at a desk and dragged

00:20:17.170 --> 00:20:21.260
that content to the SAN and started
marshalling it through the process.

00:20:21.340 --> 00:20:24.710
Well, pretty soon a couple of shows
became a couple of dozen,

00:20:24.710 --> 00:20:28.640
and this sort of human-driven workflow
wasn't working so well anymore.

00:20:28.640 --> 00:20:31.900
People were staying late,
and they started to look and smell funny

00:20:31.900 --> 00:20:33.530
because they never left the office.

00:20:33.590 --> 00:20:35.930
And, you know,
they realized that they needed to

00:20:35.930 --> 00:20:37.640
do something a little different.

00:20:37.730 --> 00:20:41.430
So they realized they needed
automation in this process.

00:20:41.520 --> 00:20:45.240
So they wrote some tools that
automated the process of,

00:20:45.240 --> 00:20:48.240
you know, content gets uploaded,
and it gets pushed through the system,

00:20:48.240 --> 00:20:51.120
and out comes an iPod video.

00:20:51.110 --> 00:20:54.410
Well,
I was actually standing out in front

00:20:54.420 --> 00:20:58.780
of a Walgreens near my house one night
and my cell phone rang and I got this

00:20:58.790 --> 00:21:01.990
kind of panic phone call from one of
the music store engineers who told

00:21:01.990 --> 00:21:04.720
me about this horrible performance
problem they were seeing and they were

00:21:04.800 --> 00:21:09.080
under the gun to get some content up
before a deadline and could I help them.

00:21:09.280 --> 00:21:10.900
So I told them I'd be happy to help them.

00:21:10.900 --> 00:21:13.160
I took a look,
and with some drilling down,

00:21:13.160 --> 00:21:16.260
we actually discovered that the
files that they were processing,

00:21:16.260 --> 00:21:18.900
they were having so many problems,
were heavily fragmented.

00:21:18.900 --> 00:21:22.960
We're talking thousands,
and in some cases tens of thousands,

00:21:22.960 --> 00:21:25.960
of individual chunks on
the disk for each file.

00:21:26.550 --> 00:21:29.320
Now, as a result,
what was happening is when

00:21:29.320 --> 00:21:35.070
those files were read back by
their post-processing tools,

00:21:35.070 --> 00:21:35.070
they --

00:21:43.100 --> 00:21:43.460
So, really a couple of things.

00:21:43.460 --> 00:21:44.350
First of all, there's, I don't know, 20,
30 machines on this SAN that are

00:21:44.350 --> 00:21:45.090
actually doing the post-processing.

00:21:45.250 --> 00:21:51.430
And the load of those computers
asking for the extent list from the

00:21:51.550 --> 00:21:55.680
controller each time was actually
causing the Xsan controller to be

00:21:55.680 --> 00:21:57.090
just pegged in terms of CPU usage.

00:21:57.100 --> 00:21:59.100
It was really busy.

00:21:59.100 --> 00:22:02.720
Now, kind of a secondary effect of the
files being fragmented were that they

00:22:02.780 --> 00:22:04.970
were spread out all over the disk,
right?

00:22:05.120 --> 00:22:07.000
They were, you know,
a chunk here and a chunk

00:22:07.000 --> 00:22:08.090
here and a chunk there.

00:22:08.160 --> 00:22:11.130
And the clients were not
able to stream that data off

00:22:11.130 --> 00:22:13.080
disk in an efficient manner.

00:22:13.100 --> 00:22:15.980
The actual just I/O was slow
because the RAIDs couldn't,

00:22:15.980 --> 00:22:18.900
you know, prefetch the data on
disk and stream it out.

00:22:19.930 --> 00:22:22.070
Now,
what was curious is that there was some

00:22:22.120 --> 00:22:25.280
content that they had not yet moved
over to this new workflow that was still

00:22:25.280 --> 00:22:27.800
being marshaled through by human beings.

00:22:27.830 --> 00:22:29.800
And all that was working just fine.

00:22:29.800 --> 00:22:31.760
You know,
their sort of expected performance

00:22:31.870 --> 00:22:35.010
because of the amount of processing
that they have to do -- it

00:22:35.050 --> 00:22:36.800
was about two times real-time.

00:22:36.800 --> 00:22:39.800
So a 30-minute show takes
about an hour to process.

00:22:39.880 --> 00:22:43.780
And the humans were basically
beating the computers,

00:22:43.800 --> 00:22:44.720
and that's sort of counterintuitive.

00:22:44.800 --> 00:22:48.040
Well,
it turns out that what was happening

00:22:48.040 --> 00:22:51.750
is the finder in Mac OS X actually
pre-allocates the space for files

00:22:51.830 --> 00:22:53.800
when it copies into an Xsan volume.

00:22:53.800 --> 00:22:56.980
So there were a couple things
that we did to kind of,

00:22:56.980 --> 00:22:59.800
you know, get them over the hump, right?

00:22:59.800 --> 00:23:01.800
We used some tools to
defragment their file system.

00:23:01.800 --> 00:23:04.800
And then we provided them with
a little teeny five-line patch

00:23:04.800 --> 00:23:08.780
they were able to apply to a
Python module that they were using.

00:23:08.800 --> 00:23:12.730
And they went from the six times
real-time that was just killing them

00:23:12.830 --> 00:23:13.800
all the way back to two times real-time.

00:23:13.800 --> 00:23:14.800
They gained all of their time.

00:23:14.800 --> 00:23:19.060
performance back with just a simple
five line change to their source code.

00:23:21.440 --> 00:23:25.310
So the next thing that all
your applications should be

00:23:25.310 --> 00:23:27.790
doing is using large I/O sizes.

00:23:27.970 --> 00:23:30.900
Large I/O sizes are much more
efficient in a SAN environment.

00:23:30.900 --> 00:23:33.810
Actually,
they're much more efficient everywhere,

00:23:33.920 --> 00:23:38.470
but the consequences of not
using them are a little more

00:23:38.470 --> 00:23:40.890
readily apparent on a SAN.

00:23:41.320 --> 00:23:45.920
So there's a couple of
reasons why this is.

00:23:46.120 --> 00:23:51.020
First of all,
when you use large I/O sizes,

00:23:51.020 --> 00:23:51.020
you're sort of --

00:23:51.170 --> 00:23:54.450
Amortizing the overhead of the
disk transactions over the wire.

00:23:54.490 --> 00:23:57.220
There's commands and headers
back in the responses.

00:23:57.220 --> 00:24:00.580
And the more data that you ship over
the wire with each one of those,

00:24:00.580 --> 00:24:04.530
the more efficiency you're going to
get out of the actual storage network.

00:24:05.540 --> 00:24:08.290
But secondly,
so one of the things that operating

00:24:08.290 --> 00:24:13.120
systems do is they go to great
lengths to try to make I/O that goes

00:24:13.120 --> 00:24:15.750
out to the file system sequential.

00:24:16.180 --> 00:24:19.420
So when you're talking
about a single computer,

00:24:19.420 --> 00:24:23.390
talking to its internal
drives or to a FireWire drive,

00:24:23.690 --> 00:24:24.600
This is no problem.

00:24:24.600 --> 00:24:27.600
The operating system lines up all I/O,
spits it out,

00:24:27.600 --> 00:24:30.140
the disk is very happy because
sequential I/O is much more

00:24:30.140 --> 00:24:31.910
efficient for a disk drive.

00:24:32.190 --> 00:24:34.970
But think about what happens when
you have a lot of computers on a

00:24:34.970 --> 00:24:37.000
SAN talking to the same pool of disks.

00:24:37.440 --> 00:24:39.940
Suddenly,
even though each of those computers

00:24:39.940 --> 00:24:43.540
might be doing sequential I/O,
by the time it gets to the disk,

00:24:43.540 --> 00:24:47.070
it effectively looks random because
they're all reading different files.

00:24:47.350 --> 00:24:51.210
So the bigger the I/O size is that you
actually issue out to those drives,

00:24:51.300 --> 00:24:56.360
the more efficiently the drive is
able to schedule that I/O internally,

00:24:56.360 --> 00:24:58.500
and then it can do sequential
I/O within the context of that

00:24:58.500 --> 00:25:00.290
one operation -- single operation.

00:25:00.320 --> 00:25:03.290
So it can just perform more efficiently.

00:25:04.100 --> 00:25:07.500
So again, we're going to take a look
at the iTunes Music Store,

00:25:07.500 --> 00:25:10.140
because they actually had a
little performance problem with an

00:25:10.220 --> 00:25:14.680
application that they used to upload
content from the content providers

00:25:14.680 --> 00:25:16.920
up to the SAN to start processing.

00:25:17.610 --> 00:25:21.000
So again, we're going to take a look
at the iTunes Music Store,

00:25:21.000 --> 00:25:23.620
because they actually had a
little performance problem with an

00:25:23.660 --> 00:25:28.170
application that they used to upload
content from the content providers

00:25:28.180 --> 00:25:30.420
up to the SAN to start processing.

00:25:42.810 --> 00:25:43.250
So I went on over and we
discussed what was going on.

00:25:43.250 --> 00:25:43.650
They were having just
kind of bad performance.

00:25:43.700 --> 00:25:47.740
There was lots of idle time on the
CPU and made a couple of suggestions

00:25:47.750 --> 00:25:49.000
to this application developer.

00:25:49.000 --> 00:25:50.940
The first one, of course,
was make sure to pre-allocate

00:25:50.940 --> 00:25:53.760
your space on disk.

00:25:53.870 --> 00:25:57.580
But as we talked a little more,
we came to discover that they

00:25:57.580 --> 00:26:01.310
actually had some code in this
application that would buffer up

00:26:01.310 --> 00:26:10.990
the I/O to 64 kilobyte or 1 megabyte
chunks and spit it out to disk.

00:26:11.210 --> 00:26:12.800
in those big chunks.

00:26:12.800 --> 00:26:15.150
But that code was not enabled
on a Mac OS X platform.

00:26:15.160 --> 00:26:19.320
Instead, what they were doing is when a
packet came in from the network,

00:26:19.320 --> 00:26:22.060
they were extracting data out of
that packet and then just spitting

00:26:22.060 --> 00:26:23.240
it out to the right place on disk.

00:26:23.260 --> 00:26:27.480
So remember,
the Ethernet MTU is 1,500 bytes,

00:26:27.540 --> 00:26:34.510
and so for every three packets that
they were getting from the network,

00:26:34.520 --> 00:26:36.700
three packets or so,
they were actually having

00:26:36.720 --> 00:26:39.750
to read a file system block,
modify part of it, and write it back out.

00:26:40.290 --> 00:26:43.120
So it's basically three times
the amount of I/O that you

00:26:43.120 --> 00:26:45.200
would normally need to do.

00:26:52.600 --> 00:26:53.030
So I made a little suggestion to
them that they actually enable this

00:26:53.050 --> 00:26:53.200
buffer at I/O for Mac OS X as well.

00:26:53.200 --> 00:26:54.000
And kind of for two reasons.

00:26:54.000 --> 00:26:56.810
One, just for all the benefits
of using a large I/O size,

00:26:56.900 --> 00:26:59.550
but also, you know,
if you're buffering it up in a nice,

00:26:59.600 --> 00:27:03.210
you know, rounded power of two increment,
you get to write it out

00:27:03.210 --> 00:27:06.070
on block boundaries,
which means you eliminate

00:27:06.070 --> 00:27:08.600
all those read-modify-write
cycles in the file system.

00:27:10.660 --> 00:27:14.450
And as you can see,
the results were absolutely outstanding.

00:27:14.450 --> 00:27:17.980
They got a 23 times improvement
in performance by simply turning

00:27:18.040 --> 00:27:19.530
on buffering in their code.

00:27:19.600 --> 00:27:22.500
It went from 10 megabytes per
second to an aggregate throughput

00:27:22.500 --> 00:27:24.600
of 203 megabytes per second.

00:27:25.140 --> 00:27:26.790
Now,
how many of you watch the Daily Show or

00:27:26.790 --> 00:27:28.600
the Colbert Report or anything like that?

00:27:28.600 --> 00:27:29.600
Yeah?

00:27:29.600 --> 00:27:30.600
Do you watch it on iTunes?

00:27:30.710 --> 00:27:32.600
Sometimes, maybe?

00:27:32.600 --> 00:27:32.600
Okay.

00:27:33.260 --> 00:27:35.830
It would not be possible to
get the content uploaded on a

00:27:35.830 --> 00:27:37.600
daily basis without this change.

00:27:37.910 --> 00:27:38.600
So every time you get your fix,
you're going to get a new one.

00:27:38.600 --> 00:27:41.400
just remember that this made it possible.

00:27:43.500 --> 00:27:47.450
So I expect this is going to be
kind of a controversial suggestion,

00:27:47.550 --> 00:27:51.860
to use the setAddrList system
call for a couple of reasons.

00:27:51.860 --> 00:27:54.160
One, it's not a POSIX system call.

00:27:54.160 --> 00:27:58.160
It's available at the BSD layer,
but it's only available on Mac OS X.

00:27:58.240 --> 00:28:00.830
And second of all,
it's not really the most

00:28:00.830 --> 00:28:02.930
straightforward API to use.

00:28:03.010 --> 00:28:07.180
However, if you are an application that,
you know,

00:28:07.290 --> 00:28:10.080
say you're a file service application,

00:28:10.480 --> 00:28:13.810
You can change the attributes
of files frequently.

00:28:13.810 --> 00:28:17.440
This enables you to reduce the
number of messages that you

00:28:17.440 --> 00:28:19.390
send to the Xsan controller.

00:28:19.390 --> 00:28:23.150
Remember, the Xsan controller is
connected to a network,

00:28:23.220 --> 00:28:26.410
and the communication
latency is network-like.

00:28:26.410 --> 00:28:30.400
It's not just like modifying
a data structure in memory.

00:28:31.080 --> 00:28:35.240
So, by using the setAddrList system call,
instead of discrete chown and chmod

00:28:35.240 --> 00:28:39.400
and chgroup and utimes and all those
other things to change file attributes,

00:28:39.540 --> 00:28:42.620
you can collapse all that stuff
from the end messages into one

00:28:42.620 --> 00:28:44.380
and get better performance.

00:28:45.030 --> 00:28:53.140
The example I'm going to turn to
here is the Mac OS X AFP server.

00:28:53.140 --> 00:28:57.200
Some time ago we were investigating
an escalation we got from a customer.

00:28:57.200 --> 00:29:00.370
They were having some bad performance
when they were copying a folder

00:29:00.390 --> 00:29:04.690
that had tens of thousands of
small files in it to an AFP share

00:29:04.690 --> 00:29:07.420
that was backed by Xsan volume.

00:29:07.700 --> 00:29:09.600
In the end,
we actually made several changes

00:29:09.600 --> 00:29:13.600
to the file system that improved
the performance for the customer.

00:29:13.600 --> 00:29:16.190
But one of the things we noticed
during our investigation was that we

00:29:16.190 --> 00:29:20.380
saw a lot of what seemed to be very
redundant set attribute operations

00:29:20.380 --> 00:29:23.080
going from the client to the controller.

00:29:23.180 --> 00:29:27.200
So we drilled down in this a little more,
and one of the places we looked

00:29:27.490 --> 00:29:29.700
was inside the Carbon File Manager.

00:29:29.700 --> 00:29:35.770
So that's the framework on top
of which the AFP server is built.

00:29:35.910 --> 00:29:38.860
It turned out that there are
two code paths in File Manager:

00:29:38.980 --> 00:29:45.110
one for HFS+ and one for
basically everything else,

00:29:45.110 --> 00:29:45.110
for positive volumes.

00:29:45.320 --> 00:29:48.190
It turned out that there are
two code paths in File Manager:

00:29:48.470 --> 00:29:54.420
one for HFS+ and one for
basically everything else,

00:29:54.420 --> 00:29:54.420
for positive volumes.

00:30:01.210 --> 00:30:05.520
So what we did is we modified the
file manager to use the same code

00:30:05.520 --> 00:30:12.200
path for file set attributes for
POSIX files as it did for HFS+.

00:30:12.200 --> 00:30:16.540
And just with that simple change,
we actually squeezed another 10% out

00:30:16.540 --> 00:30:20.200
of the little test that we were using,
which was to copy a large folder

00:30:20.200 --> 00:30:23.200
of Keynote presentations that
had a bunch of small files in it.

00:30:23.210 --> 00:30:27.330
And we gained 10% on that benchmark,
which if you're doing performance tuning,

00:30:27.330 --> 00:30:29.740
10% is not really anything to sneeze at.

00:30:31.640 --> 00:30:35.790
So the next thing that you're going
to want to avail yourself of is

00:30:35.790 --> 00:30:38.380
the Disk Arbitration Framework.

00:30:39.140 --> 00:30:42.620
We actually recently ran into
an application that started

00:30:42.620 --> 00:30:45.850
early in the boot process,
and it was sometimes

00:30:45.850 --> 00:30:50.400
failing in strange ways,
and sort of more to the point,

00:30:50.400 --> 00:30:54.270
it was actually causing Xsan to fail
in strange ways because it was making

00:30:54.270 --> 00:30:57.910
bad assumptions about whether or
not the Xsan volume that it expected

00:30:57.910 --> 00:31:00.000
to be mounted was actually mounted.

00:31:00.000 --> 00:31:04.980
It was testing certain conditions,
and when those things evaluated to true,

00:31:04.990 --> 00:31:06.160
it assumed that the
Xsan volume was there,

00:31:06.160 --> 00:31:08.990
even though those conditions really
had nothing to do with whether or

00:31:08.990 --> 00:31:11.380
not the volume is actually mounted.

00:31:12.000 --> 00:31:28.800
[Transcript missing]

00:31:29.160 --> 00:31:31.630
So we suggested to that
application developer,

00:31:31.630 --> 00:31:34.240
"You really ought to be
using disk arbitration,

00:31:34.240 --> 00:31:37.340
because it can do a couple
of things for you." One,

00:31:37.340 --> 00:31:40.010
you can ask it if a
certain volume is mounted,

00:31:40.020 --> 00:31:43.170
and it will give you a
definitive yes or no.

00:31:43.720 --> 00:31:48.560
You can also register for a
notification from the framework

00:31:49.120 --> 00:31:53.870
whenever a volume is mounted,
or also when an existing

00:31:53.870 --> 00:31:55.810
volume goes away.

00:31:56.930 --> 00:32:00.290
So,
I guess my broader point here is that,

00:32:00.290 --> 00:32:03.800
as of Tiger, we all live in this world
of deferred initialization.

00:32:03.800 --> 00:32:08.800
We are moving away from startup
items and going more toward launch-D.

00:32:08.800 --> 00:32:11.300
And this overall is a very,
very good thing.

00:32:11.400 --> 00:32:12.800
There's a lot of benefits to that.

00:32:12.800 --> 00:32:15.430
Your systems boot up much faster
now than they did in Panther,

00:32:15.430 --> 00:32:18.800
and that's largely due to the fact
that we have deferred initialization.

00:32:18.800 --> 00:32:22.410
However,
it can sometimes break assumptions

00:32:22.410 --> 00:32:26.680
that applications make that are
bad assumptions in the world

00:32:26.680 --> 00:32:27.800
of deferred initialization.

00:32:27.800 --> 00:32:32.730
So, please, make use of all the different
types of notification facilities

00:32:32.780 --> 00:32:35.800
that are available in Mac OS X,
not just disk arbitration,

00:32:35.800 --> 00:32:38.710
because it will make your lives
a lot easier in the long run.

00:32:40.560 --> 00:32:42.920
So next, the resource fork.

00:32:42.970 --> 00:32:43.950
Do not use this.

00:32:44.100 --> 00:32:46.050
Please, please, please.

00:32:46.120 --> 00:32:48.880
As I said before,
we're a single fork file system.

00:32:48.920 --> 00:32:51.290
All that resource fork stuff is emulated.

00:32:51.370 --> 00:32:54.610
And as I said before,
it's not always perfect.

00:32:54.750 --> 00:32:57.800
And it leaves these other
little files that Mac OS X knows

00:32:57.800 --> 00:32:59.760
about and knows how to process.

00:32:59.810 --> 00:33:02.860
But other systems connected to the
SAN may not know anything about.

00:33:02.880 --> 00:33:04.980
And remember,
XSAN is actually compatible with

00:33:04.980 --> 00:33:06.950
some third party SAN products.

00:33:07.010 --> 00:33:10.880
And those Linux or Windows systems
don't know about this Apple double file.

00:33:10.880 --> 00:33:12.780
So if you rename your file,
suddenly you've lost your

00:33:12.780 --> 00:33:13.880
resource fork information.

00:33:13.880 --> 00:33:15.270
And that's not good.

00:33:16.280 --> 00:33:21.310
So the new way to do this in
Mac OS X is to use bundles.

00:33:21.420 --> 00:33:25.760
So I realize that for a lot
of you who write applications

00:33:25.760 --> 00:33:29.150
that use a resource fork,
this is a file format change.

00:33:29.150 --> 00:33:32.770
But in your next major release,
I strongly encourage you to

00:33:32.770 --> 00:33:36.400
consider making this change because
you're just going to gain kind of

00:33:36.460 --> 00:33:38.140
broader compatibility everywhere.

00:33:38.270 --> 00:33:40.720
And there are both
C and Objective-C APIs,

00:33:40.850 --> 00:33:43.180
the CFBundle and S bundle APIs.

00:33:43.180 --> 00:33:47.490
So it's available to a
wide array of applications.

00:33:49.640 --> 00:33:52.120
Okay, FS Exchange Objects.

00:33:52.300 --> 00:33:54.500
This is something that you
should not be using either.

00:33:55.010 --> 00:33:57.490
This is an API that's
in the file manager,

00:33:57.560 --> 00:34:01.000
and as I described before,
Xsan doesn't support this.

00:34:01.130 --> 00:34:05.030
What Exchange Objects does is it allows
you to take one file and another file and

00:34:05.270 --> 00:34:08.000
atomically swap the data forks of them.

00:34:08.000 --> 00:34:13.000
And what applications use this for is
to implement a safe-save operation.

00:34:13.000 --> 00:34:17.000
That is, basically,
when a user saves a file,

00:34:17.000 --> 00:34:21.060
they expect either the new contents to
be there or the old contents to be there,

00:34:21.070 --> 00:34:21.960
and not a mixture of both.

00:34:22.060 --> 00:34:27.640
And that's what this API call
allows applications to implement.

00:34:28.270 --> 00:34:30.200
So, it's not available on Xsan.

00:34:30.200 --> 00:34:33.840
It's also not available on
UFS or FAT or anything like that.

00:34:33.850 --> 00:34:35.200
So, what can you do instead?

00:34:35.200 --> 00:34:39.330
Well, what you can do instead is you
can create a temporary file,

00:34:39.330 --> 00:34:43.200
and then you can rename the temporary
file to the original file name.

00:34:43.200 --> 00:34:45.090
And on all the file
systems that we support,

00:34:45.090 --> 00:34:48.110
that is also an atomic operation
and gives you the same semantics.

00:34:48.610 --> 00:34:52.130
There are some caveats, however.

00:34:52.260 --> 00:34:56.440
When you use Exchange Objects,
you're only exchanging the data forks.

00:34:56.440 --> 00:34:58.900
So all the other attributes
of the original file,

00:34:58.900 --> 00:35:01.300
like the owner and permissions
and all that stuff,

00:35:01.330 --> 00:35:03.200
remain intact.

00:35:03.370 --> 00:35:05.160
However,
when you create a temporary file,

00:35:05.200 --> 00:35:08.150
the owner and the group and the
permissions and the timestamps

00:35:08.200 --> 00:35:11.200
and all those other things
are going to be different.

00:35:11.230 --> 00:35:15.030
So your application has to be aware of
that and actually copy the attributes

00:35:15.030 --> 00:35:20.170
to the temporary file that you
want to preserve from the original.

00:35:20.200 --> 00:35:22.200
It's a little tedious.

00:35:22.200 --> 00:35:23.190
There's not really
another way to do this,

00:35:23.200 --> 00:35:25.190
especially in a
Carbon application right now.

00:35:25.300 --> 00:35:30.200
However, there are APIs in
Cocoa that do this for you,

00:35:30.200 --> 00:35:33.200
so maybe you can consider
switching to those.

00:35:33.200 --> 00:35:38.650
Any of the classes that provide sort
of write-to-file atomically methods

00:35:38.650 --> 00:35:41.200
actually do this work for you.

00:35:41.200 --> 00:35:45.790
There are other classes that
don't provide this exact method

00:35:45.790 --> 00:35:48.200
but that implement the methods
that they use on top of this one.

00:35:48.270 --> 00:35:53.190
And this document is one such example.

00:35:56.310 --> 00:35:57.850
So those are the do's and don'ts.

00:35:57.930 --> 00:36:01.240
Those are really the main key points
that you as application developers

00:36:01.290 --> 00:36:05.800
need to keep in mind when you're
developing applications and you want

00:36:05.830 --> 00:36:09.350
to maximize both your performance
and your compatibility with Xsan.

00:36:10.300 --> 00:36:19.600
[Transcript missing]

00:36:21.180 --> 00:36:25.370
So, how many of you are excited about
those cool new Macs that were

00:36:25.380 --> 00:36:26.390
introduced earlier this week?

00:36:26.510 --> 00:36:27.190
You like those?

00:36:27.360 --> 00:36:29.290
Raise your hand, yeah?

00:36:29.730 --> 00:36:30.700
Guess what?

00:36:30.700 --> 00:36:33.550
Xsan now works with them.

00:36:33.590 --> 00:36:37.340
So we actually are shipping
universal binaries in Xsan 1.4.

00:36:37.350 --> 00:36:40.100
And in addition to Xsan being
ready for those new machines,

00:36:40.130 --> 00:36:42.540
those new machines are
basically ready for Xsan.

00:36:42.540 --> 00:36:45.700
They actually -- all of them come
with dual-gigabit Ethernet networks,

00:36:45.700 --> 00:36:48.830
so you have -- you don't need to
buy another network card in order to

00:36:48.830 --> 00:36:50.600
have that private Ethernet network.

00:36:50.600 --> 00:36:51.900
Really,
the only thing you need to buy for them

00:36:51.900 --> 00:36:55.040
is the PCI Express Fibre Channel card.

00:36:55.970 --> 00:36:58.630
Last year at WWDC,
I got a lot of questions

00:36:58.660 --> 00:36:59.900
about this next one.

00:36:59.900 --> 00:37:04.110
A lot of people were asking me,
"So there's this new snazzy access

00:37:04.130 --> 00:37:05.900
control list architecture in Tiger.

00:37:05.900 --> 00:37:08.530
Does Xsan work with
it?" And unfortunately,

00:37:08.530 --> 00:37:13.890
my answer last year was kind of a
meek "no." But I have good news.

00:37:13.890 --> 00:37:19.770
This year, I can say that Xsan 1.4
supports access control lists.

00:37:21.080 --> 00:37:23.780
Not only does it work just like
Access Control Lists work on every

00:37:23.790 --> 00:37:27.700
other file system in Mac OS X,
it also interoperates with ADIC's

00:37:27.700 --> 00:37:31.160
StoreNext file system and the
Access Control Lists that they

00:37:31.160 --> 00:37:33.030
support on their Windows client.

00:37:34.090 --> 00:37:38.690
So, and like always,
there's lots and lots of bug fixes.

00:37:38.740 --> 00:37:43.000
So all told, we made over 100 software
changes in Xsan 1.4.

00:37:43.000 --> 00:37:46.890
And a lot of those were actually in
direct response to you guys filing

00:37:47.050 --> 00:37:51.000
bug reports through Bug Reporter or
participating in customer seeding,

00:37:51.000 --> 00:37:55.000
so I'd like to just take a minute to
thank you for providing your feedback.

00:37:56.000 --> 00:37:57.080
And for those of you who
don't participate in that,

00:37:57.080 --> 00:38:00.870
I'm going to encourage you to participate
in both our customer seeding program and

00:38:00.870 --> 00:38:03.000
our developer seeding program for Xsan.

00:38:03.000 --> 00:38:07.990
You get early access to Xsan releases,
and we like to hear feedback,

00:38:07.990 --> 00:38:11.000
and of course, we'd like you to test your
applications with Xsan.

00:38:12.540 --> 00:38:15.340
So we're going to go
ahead and wrap up here,

00:38:15.340 --> 00:38:18.560
just to kind of review some of
the points we've touched on.

00:38:18.710 --> 00:38:22.950
First of all,
Xsan allows for shared volume access at

00:38:22.950 --> 00:38:25.990
high speed directly over a fiber channel.

00:38:26.270 --> 00:38:31.940
And it also allows you to configure your
storage in a flexible manner that works

00:38:31.940 --> 00:38:34.800
for the type of work that you need to do.

00:38:35.210 --> 00:38:38.050
Of course,
applications need to be aware of

00:38:38.170 --> 00:38:41.100
Xsan's somewhat unique characteristics.

00:38:41.100 --> 00:38:43.290
But more importantly,
they can be tuned for better

00:38:43.510 --> 00:38:47.100
performance on Xsan once you're
aware of those characteristics.

00:38:47.100 --> 00:38:50.070
And then finally, of course,
Xsan now supports the new

00:38:50.070 --> 00:38:52.100
Intel Macs and Access Control Lists.

00:38:54.570 --> 00:38:58.150
So finally, again,
I just want to reiterate that

00:38:58.150 --> 00:39:01.750
ADC Select and Premier members,
you have early access

00:39:01.800 --> 00:39:03.200
to these Xsan seeds.

00:39:03.310 --> 00:39:06.810
I really, really, really encourage you
to participate in this.

00:39:06.900 --> 00:39:08.490
The more feedback we get, the better.

00:39:08.490 --> 00:39:12.090
We love it when you guys
use this stuff early.

00:39:12.250 --> 00:39:14.770
And one of the things
that I'm often asked,

00:39:14.810 --> 00:39:18.980
even within Apple,
by other teams in the company,

00:39:19.300 --> 00:39:20.440
We don't have an Xsan.

00:39:20.440 --> 00:39:22.960
We don't know how to
test our stuff with Xsan.

00:39:22.960 --> 00:39:25.470
We don't know how to fix this
bug that people are seeing

00:39:25.500 --> 00:39:27.200
because we don't have a SAN.

00:39:27.430 --> 00:39:32.200
Well, you can actually use Firewire for
basic Xsan compatibility testing.

00:39:32.330 --> 00:39:37.200
This is especially
good for smaller shops.

00:39:37.200 --> 00:39:41.520
You don't necessarily have to break the
bank to buy a bunch of stuff in order

00:39:41.570 --> 00:39:44.190
to just do basic compatibility testing.

00:39:44.200 --> 00:39:46.920
I'm going to be working with
Developer Technical Support to

00:39:46.920 --> 00:39:48.190
get an article written.

00:39:48.200 --> 00:39:52.200
You can just have one place you can
reference for the steps to do this.

00:39:52.200 --> 00:39:53.190
It's very simple.

00:39:53.300 --> 00:39:56.580
It's basically exactly the
same as setting it up with

00:39:56.580 --> 00:39:59.560
a regular fiber channel,
except there's less

00:39:59.560 --> 00:40:01.200
stuff to hook together.

00:40:02.590 --> 00:40:06.470
That's really about all
I have for you today.

00:40:06.520 --> 00:40:09.200
Just to kind of reference
you to some more information,

00:40:09.240 --> 00:40:12.960
I really strongly encourage all of you
who are either running Xsan or thinking

00:40:12.960 --> 00:40:16.980
about switching to Xsan to go to the
Xsan Best Practices session that is

00:40:16.980 --> 00:40:19.200
in this room this afternoon at 3:30.

00:40:19.500 --> 00:40:21.500
JD is going to be presenting that.

00:40:21.500 --> 00:40:25.500
He's got a lot of experience in
doing Xsan deployments for customers.

00:40:25.500 --> 00:40:26.500
Bring your questions.

00:40:26.500 --> 00:40:28.500
He's got a lot of good info for you guys.

00:40:28.500 --> 00:40:30.500
And I'll actually be on the
Q&A panel for that as well.

00:40:30.500 --> 00:40:33.000
So any questions that we don't
get to today or if you have

00:40:33.000 --> 00:40:36.500
something you think of later,
I'll be available at that time.

00:40:36.610 --> 00:40:40.500
And then I just want to point you
to just a couple of places online.

00:40:40.510 --> 00:40:45.500
First of all,
the Xsan webpages at www.apple.com/xsan.

00:40:45.500 --> 00:40:48.500
In addition to basic product information,
there are links to the support pages,

00:40:48.500 --> 00:40:51.340
and also there are frequently
updated links to new customer

00:40:51.340 --> 00:40:54.440
deployment scenarios that
make for an interesting read.

00:40:54.500 --> 00:40:58.500
Also,
there's a great mailing list out there.

00:40:58.500 --> 00:41:00.150
If you're a Xsan user,
you can find a lot of Xsan

00:41:00.150 --> 00:41:01.500
users at list.apple.com.

00:41:01.500 --> 00:41:04.500
There's quite a vibrant Xsan
user community out there.

00:41:04.500 --> 00:41:09.420
For those of you who are using or
deploying Xsan in your IT environment,

00:41:09.500 --> 00:41:12.960
this is just a great place to
meet other Xsan users and bounce

00:41:12.970 --> 00:41:14.500
ideas and problems off of them.

00:41:14.500 --> 00:41:18.210
And for those of you who are
developing applications for Xsan,

00:41:18.210 --> 00:41:22.280
it's a great potential place to find
testers or people to buy the stuff.
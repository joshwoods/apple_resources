WEBVTT

00:00:10.550 --> 00:00:11.490
I'm Peter Edberg.

00:00:11.490 --> 00:00:15.060
I've been working at Apple for
about 18 years on various aspects of

00:00:15.060 --> 00:00:16.740
system software internationalization.

00:00:16.740 --> 00:00:19.020
I'll be doing the first
third of the talk today,

00:00:19.020 --> 00:00:21.340
but before that,
I'd like to give you an overview

00:00:21.340 --> 00:00:22.900
of the whole presentation.

00:00:22.900 --> 00:00:26.130
I'm going to begin with some
background information on the

00:00:26.130 --> 00:00:29.640
motivation for what we're doing
in Leopard and some background

00:00:29.640 --> 00:00:33.700
information on the organization of
the text input system as a whole.

00:00:34.680 --> 00:00:37.640
Then on my portion of the talk,
I'm going to focus on the

00:00:37.640 --> 00:00:39.140
Text Input Sources API.

00:00:39.140 --> 00:00:43.870
This is a new API for Leopard that
allows you to find out information

00:00:43.870 --> 00:00:47.520
about text input sources,
to get notifications of

00:00:47.520 --> 00:00:50.720
changes to text input sources,
and to be able to

00:00:50.720 --> 00:00:53.400
programmatically manipulate them.

00:00:53.400 --> 00:00:58.400
Then Michael Grady is going to talk
about some improvements to TSM and how

00:00:58.400 --> 00:01:01.420
TSM is adapting to changes in Leopard.

00:01:01.420 --> 00:01:04.660
Finally,
Lee Collins is going to talk about it.

00:01:04.660 --> 00:01:08.450
Lee Collins is going to talk about
the new input method kit framework

00:01:08.450 --> 00:01:12.180
for creation of input methods,
which finally allows you to create

00:01:12.180 --> 00:01:16.990
input methods that are applications
instead of component manager components.

00:01:17.300 --> 00:01:18.810
Throughout,
we're going to try and show you how

00:01:18.810 --> 00:01:21.880
the changes we're making are going
to enable you to better address

00:01:22.220 --> 00:01:27.610
user expectations and needs in your
applications and also hopefully make

00:01:27.610 --> 00:01:31.590
it simpler for you to write code.

00:01:32.320 --> 00:01:34.400
Simply,
making code simpler is not necessarily

00:01:34.470 --> 00:01:38.020
consistent with making changes because
you'll have multiple platform targets.

00:01:38.020 --> 00:01:40.440
There has to be a good
reason for making changes,

00:01:40.440 --> 00:01:42.220
and we think we have a few.

00:01:42.220 --> 00:01:45.540
First, of course,
we've got some leopard-wide initiatives.

00:01:47.600 --> 00:01:52.710
The 64-bit ABI, the new binary interface,
has no backward

00:01:52.710 --> 00:01:54.560
compatibility requirement.

00:01:54.660 --> 00:02:00.030
Deprecated interfaces are not being
carried forward to this new API or ABI,

00:02:00.040 --> 00:02:02.520
so it allows us the opportunity
for some modernization,

00:02:02.520 --> 00:02:06.050
the opportunity to introduce
new API that replace some of

00:02:06.060 --> 00:02:08.670
the deprecated functionality.

00:02:08.930 --> 00:02:13.450
Also, resolution independence affects
the content of events that

00:02:13.450 --> 00:02:16.050
refer to screen position,
and of course,

00:02:16.050 --> 00:02:19.670
there are a number of these
events associated with TSM.

00:02:20.140 --> 00:02:23.670
The second big reason has to do with
a number of modernizations that we're

00:02:23.670 --> 00:02:25.500
making for the Text Input system.

00:02:25.500 --> 00:02:28.860
First, and you'll hear this
throughout the presentation,

00:02:28.860 --> 00:02:31.440
the Script Manager is really,
really deprecated,

00:02:31.440 --> 00:02:34.180
as are all of the types
associated with it,

00:02:34.180 --> 00:02:37.940
script code, language code, region code,
and so on.

00:02:37.940 --> 00:02:41.930
We've got modern replacements for all
those that are better in many respects.

00:02:42.800 --> 00:02:46.830
So we're removing the Script Manager from
the main parts of the control flow

00:02:47.200 --> 00:02:52.570
in Text Input and focusing on a
Unicode-clean Text Input path.

00:02:52.970 --> 00:02:56.510
The Script Manager will still
exist in 32-bit ABI as a kind of

00:02:56.510 --> 00:02:58.990
compatibility adjunct to the main path.

00:02:59.060 --> 00:03:03.130
Second, we do have to enable new
types of input methods,

00:03:03.130 --> 00:03:06.810
as I mentioned,
and we have to have tokens that refer to

00:03:06.810 --> 00:03:11.340
not just component-based input methods,
but a wider range of input methods,

00:03:11.340 --> 00:03:13.690
so we need a more abstract
token type for these.

00:03:15.700 --> 00:03:19.850
Third, we have to enable new
types of input methods,

00:03:19.850 --> 00:03:23.530
as I mentioned,
and we need a more abstract

00:03:23.530 --> 00:03:25.730
token type for these.

00:03:25.880 --> 00:03:28.250
We're also trying to do a lot
of performance improvements

00:03:28.250 --> 00:03:32.530
and memory reductions,
especially for App Launch and App Switch.

00:03:32.710 --> 00:03:35.030
And finally,
the third big reason for changes

00:03:35.040 --> 00:03:39.630
is to respond to requests that
a number of you have made.

00:03:39.720 --> 00:03:42.250
So let's dive into the
Leopard Text Input system.

00:03:42.520 --> 00:03:46.410
There are two new pieces for Leopard,
the highlighted ones here.

00:03:46.520 --> 00:03:50.130
And along with these two,
there are several other areas that we're

00:03:50.130 --> 00:03:52.290
going to be focusing on in the talk.

00:03:52.920 --> 00:03:57.300
Now, there's always been some capability
for management of text input sources.

00:03:57.300 --> 00:04:00.800
It's been spread through
the Script Manager and TSM,

00:04:00.800 --> 00:04:04.800
and a lot of it depended on
the now-deprecated tokens,

00:04:04.800 --> 00:04:07.910
the script code,
even component ID as a way

00:04:07.910 --> 00:04:10.260
to refer to input methods.

00:04:10.260 --> 00:04:13.420
It's not necessarily deprecated,
but it's not general enough.

00:04:14.280 --> 00:04:17.360
So anyway,
we're extracting that functionality,

00:04:17.360 --> 00:04:21.380
expanding it, and modernizing it for
Leopard as a separate module.

00:04:21.380 --> 00:04:24.330
This allows TSM to
focus on its core tasks,

00:04:24.350 --> 00:04:29.820
which include management of input
context state through the TSM document,

00:04:29.820 --> 00:04:33.360
handling text input from
a variety of input sources

00:04:33.360 --> 00:04:38.040
using a variety of protocols,
and mediating input source

00:04:38.090 --> 00:04:41.480
access to application documents.

00:04:41.480 --> 00:04:44.100
And this is important if you went
to the latent semantic analysis.

00:04:44.340 --> 00:04:46.660
So, for example,
we're going to use the TSM-TMS session

00:04:46.710 --> 00:04:49.370
for things like that to enable
input methods to do a better job.

00:04:49.890 --> 00:04:52.540
Now there are some dark brown
or kind of reddish brown

00:04:52.540 --> 00:04:54.030
boxes over there on the right.

00:04:54.330 --> 00:04:58.460
Those represent input sources,
some of which come from Apple and

00:04:58.460 --> 00:05:00.290
some of which come from some of you.

00:05:00.440 --> 00:05:04.410
And this brings me to the
second new piece for Leopard,

00:05:04.410 --> 00:05:06.880
which is the Input Method Kit.

00:05:07.110 --> 00:05:09.720
Now there are some dark brown
or kind of reddish brown

00:05:09.740 --> 00:05:11.500
boxes over there on the right.

00:05:11.500 --> 00:05:15.660
Those represent input sources,
some of which come from Apple and

00:05:15.660 --> 00:05:17.600
some of which come from some of you.

00:05:17.600 --> 00:05:21.610
And this brings me to the
second new piece for Leopard,

00:05:21.610 --> 00:05:24.000
which is the Input Method Kit.

00:05:37.350 --> 00:05:39.060
There are a few other
boxes on this diagram.

00:05:39.060 --> 00:05:41.500
I'm not going to really
focus on them today,

00:05:41.500 --> 00:05:44.410
but for example,
the NS Text Field box is meant to

00:05:44.410 --> 00:05:49.540
indicate that AppKit will handle a lot
of the text input system interaction

00:05:49.630 --> 00:05:52.380
on your behalf if you're a Cocoa app.

00:05:52.400 --> 00:05:56.500
The Text Input menu is an important
user interface element for text input,

00:05:56.500 --> 00:05:59.940
but there's no programmatic
interface for applications.

00:06:01.120 --> 00:06:03.030
And of course,
the reason that all these pieces are

00:06:03.030 --> 00:06:04.550
there is to make applications work.

00:06:04.570 --> 00:06:08.030
So the gray box in the diagram is
meant to represent an application

00:06:08.040 --> 00:06:11.220
that does interact heavily
with the text input system,

00:06:11.220 --> 00:06:13.600
which presumably some of you are writing.

00:06:13.600 --> 00:06:17.250
Now, one thing that some of these
applications do is do a lot of key

00:06:17.250 --> 00:06:20.910
translation on their own and handle
key layout data on their own,

00:06:20.910 --> 00:06:24.180
and that brings me to an
important point for Leopard.

00:06:24.180 --> 00:06:28.530
We're converting all of the
Apple-supplied keyboard layouts

00:06:28.530 --> 00:06:31.100
to use the Unicode format,
the U-char format.

00:06:31.100 --> 00:06:34.270
This is part of our Unicode
clean text input path,

00:06:34.270 --> 00:06:36.610
and it has several implications.

00:06:36.660 --> 00:06:39.310
First,
for those of you who are developing

00:06:39.310 --> 00:06:43.350
and providing keyboard layouts,
you should know that this is the

00:06:43.350 --> 00:06:46.160
preferred format for keyboard layouts.

00:06:46.350 --> 00:06:50.360
Also, if you're a developer who does
access key layout data directly,

00:06:50.360 --> 00:06:54.710
you should not assume that data is
available in the old K-chart format,

00:06:54.740 --> 00:06:57.860
which depended on Mac encodings and
is associated with the Script Manager.

00:06:57.860 --> 00:07:00.280
And in fact,
that's been true for many releases.

00:07:00.280 --> 00:07:03.630
It's been true for a long time
that many keyboard layouts did

00:07:03.630 --> 00:07:07.450
not have K-chart data available,
but there are still applications

00:07:07.450 --> 00:07:08.900
that depend on this.

00:07:09.660 --> 00:07:12.940
Experimentally,
in an earlier release of Leopard,

00:07:12.940 --> 00:07:16.230
we tried making all K-chart
data unavailable through

00:07:16.230 --> 00:07:19.900
the key layout access APIs,
and that did break a few applications.

00:07:19.900 --> 00:07:22.620
We filed bugs, so you know who you are,
hopefully.

00:07:22.620 --> 00:07:24.640
But anyway, we may do that again.

00:07:24.640 --> 00:07:29.020
So you should not depend on having
that K-chart data available.

00:07:29.020 --> 00:07:32.540
Now, it is still the case that,
as a kind of a hedge,

00:07:32.540 --> 00:07:36.660
getResource for K-chart data
will work as it did in Tiger.

00:07:36.660 --> 00:07:39.640
And this is part of the
Script Manager backward compatibility.

00:07:39.660 --> 00:07:44.520
The Script Manager uses that
way to get keyboard layout data,

00:07:44.520 --> 00:07:46.310
but the rest of the system does not.

00:07:46.320 --> 00:07:51.600
So the keyboard layout access API do not,
and the new input sources API do not get

00:07:51.600 --> 00:07:54.200
access to keyboard layout data that way.

00:07:54.200 --> 00:07:56.890
And you should not either.

00:07:57.900 --> 00:08:03.000
Okay, so who are the people who might be
interested in the Text Input Sources API?

00:08:03.070 --> 00:08:07.800
Well, any developer who wants to do
direct processing of text input,

00:08:07.800 --> 00:08:10.680
any developer who wants to have
some control over text input

00:08:10.680 --> 00:08:13.520
and may have been using some of
the Script Manager functionality

00:08:13.970 --> 00:08:16.670
to do that in the past,
developers who need

00:08:16.670 --> 00:08:20.400
information about text input,
and there are facilities

00:08:20.400 --> 00:08:24.300
in the new TIS API also for
developers of input methods.

00:08:24.300 --> 00:08:26.520
So it affects a large number of clients.

00:08:27.220 --> 00:08:28.640
And why are we doing this?

00:08:28.640 --> 00:08:30.800
Well,
I touched on a little bit of this before,

00:08:30.800 --> 00:08:33.140
but let me say a little more detail now.

00:08:33.140 --> 00:08:37.280
We've had a number of developer
requests for things like notification

00:08:37.280 --> 00:08:41.340
of changes to input sources,
such as changes to selection or changes

00:08:41.340 --> 00:08:44.630
to the set of enabled input sources,
the capability for

00:08:44.630 --> 00:08:46.160
background manipulation.

00:08:46.160 --> 00:08:49.650
If you're an app that wants to
sit in the background processing

00:08:49.650 --> 00:08:52.820
text input in some way,
but having some control over the

00:08:52.820 --> 00:08:55.980
input source used by the front app,
that's a capability

00:08:55.980 --> 00:08:56.640
that's been requested.

00:08:56.640 --> 00:09:01.320
And the ability to have more
information about input sources,

00:09:01.320 --> 00:09:06.080
such as what's an input source that's
appropriate for a given language.

00:09:06.400 --> 00:09:09.450
Also, as I mentioned,
we do need this new unified notion

00:09:09.450 --> 00:09:13.220
of input source that can abstract
away the particular architecture

00:09:13.220 --> 00:09:16.980
of the input method used,
for example, and several other issues,

00:09:16.980 --> 00:09:19.670
and the TIS Input
Source API provides that.

00:09:19.700 --> 00:09:21.740
Finally,
this is another step in moving away

00:09:21.800 --> 00:09:25.320
from the Script Manager and moving away
from the script codes and other types

00:09:25.320 --> 00:09:27.320
associated with the Script Manager.

00:09:27.320 --> 00:09:31.780
It provides some similar functionality,
but using new, more modern types.

00:09:31.780 --> 00:09:36.020
And again,
our primary path is for Unicode text.

00:09:37.640 --> 00:09:40.940
There are a couple of important
concepts you need to know or understand

00:09:40.940 --> 00:09:44.210
associated with text input sources.

00:09:44.420 --> 00:09:47.540
First of all, there are three categories.

00:09:47.540 --> 00:09:51.050
There are keyboard input sources,
which include keyboard layouts,

00:09:51.050 --> 00:09:51.990
such as Swedish.

00:09:52.170 --> 00:09:55.090
There are input methods, such as Kotori.

00:09:55.170 --> 00:09:58.330
And there are input modes,
which are particular ways of inputting

00:09:58.330 --> 00:10:00.460
text associated with an input method.

00:10:00.460 --> 00:10:04.110
So for example, Kotori has Hiragana,
Katakana, Romaji,

00:10:04.290 --> 00:10:08.360
several other input modes associated
with the parent input method,

00:10:08.360 --> 00:10:09.150
Kotori.

00:10:09.980 --> 00:10:13.010
There are some input methods that
are modeless and have only an input

00:10:13.020 --> 00:10:14.720
method with no associated modes.

00:10:14.720 --> 00:10:17.480
A second category is
palette input sources,

00:10:17.480 --> 00:10:21.440
such as the character palette,
keyboard viewer, and so on.

00:10:21.440 --> 00:10:23.650
And a third category is ink.

00:10:23.650 --> 00:10:25.530
And these all behave in
slightly different ways,

00:10:25.530 --> 00:10:26.830
and I'll get to that in a second.

00:10:26.840 --> 00:10:31.240
Some input sources are invisible
to the system user interface.

00:10:31.240 --> 00:10:35.080
These include things like
private keyboard layouts that

00:10:35.080 --> 00:10:39.570
are used by an input method,
and even private input modes.

00:10:39.650 --> 00:10:44.670
Some input sources are visible,
but not selectable.

00:10:44.670 --> 00:10:48.820
So parent input methods that have
modes are typically not selectable

00:10:48.840 --> 00:10:51.150
in things like the text input menu.

00:10:51.160 --> 00:10:55.240
They are visible, however,
in the international press panel.

00:10:55.240 --> 00:10:59.840
For example, you can enable or disable
all the modes associated with

00:11:00.040 --> 00:11:02.120
an input method as a group.

00:11:02.390 --> 00:11:05.580
Now, in most cases,
input sources are enabled and disabled

00:11:05.580 --> 00:11:08.490
using international preferences,
although Inc.

00:11:08.490 --> 00:11:10.870
has its own preferences panel for that.

00:11:11.190 --> 00:11:14.900
As I mentioned, there's some different
behavior associated with the

00:11:14.910 --> 00:11:16.700
three different categories.

00:11:16.740 --> 00:11:18.690
At any moment,
there's exactly one keyboard

00:11:18.690 --> 00:11:19.900
input source selected.

00:11:19.900 --> 00:11:21.440
It may be an input method.

00:11:21.440 --> 00:11:23.760
It may be a keyboard layout.

00:11:23.760 --> 00:11:26.740
You can have zero or more
palette input sources selected.

00:11:26.740 --> 00:11:32.130
So you can have keyboard viewer and
character palette up at the same time,

00:11:32.130 --> 00:11:33.420
or none of them.

00:11:33.440 --> 00:11:37.250
And for ink,
you can only have one ink input source,

00:11:37.250 --> 00:11:39.510
and it can either be
enabled and selected or not.

00:11:40.020 --> 00:11:42.780
Okay, so enough of the background.

00:11:43.070 --> 00:11:46.970
This is the core token associated
with the Text Input Source API,

00:11:46.970 --> 00:11:48.710
a TIS input source ref.

00:11:48.730 --> 00:11:52.350
This is a CF-type ref,
and so it can be passed to all the

00:11:52.490 --> 00:11:57.890
normal polymorphic CF-based functions,
and be put in collections and so on.

00:11:57.890 --> 00:12:01.100
This is our abstract representation
of any type of input source.

00:12:01.120 --> 00:12:02.420
It's the modern token.

00:12:04.990 --> 00:12:06.870
Having one of these,
you can get a number of

00:12:06.920 --> 00:12:08.710
properties associated with it.

00:12:08.710 --> 00:12:11.570
We have a function
TIS_GET_INPUT_SOURCE_PROPERTY.

00:12:11.690 --> 00:12:15.920
You pass your input source ref and the
key for the property that you want to

00:12:15.920 --> 00:12:18.600
examine and get back a void star value.

00:12:18.600 --> 00:12:26.270
Typically, this value will be a CF type,
but not always.

00:12:26.270 --> 00:12:26.270
In some cases,
we return an icon ref or something else.

00:12:26.710 --> 00:12:30.600
These properties generally
fall into several categories.

00:12:30.600 --> 00:12:33.590
They're ones that help you
identify the input source,

00:12:33.590 --> 00:12:38.140
such as our new input source ID,
and more on that in a moment.

00:12:38.140 --> 00:12:42.180
You can find out the category
or type of input source,

00:12:42.210 --> 00:12:43.480
the bundle ID.

00:12:43.540 --> 00:12:45.220
If it's a mode,
you can find out the mode ID.

00:12:46.040 --> 00:12:48.000
Now, more about the input source ID.

00:12:48.000 --> 00:12:51.650
This is a new property,
a universal string that's

00:12:51.650 --> 00:12:55.900
going to uniquely identify
input sources in Leopard.

00:12:55.900 --> 00:13:01.360
We are going to provide a plist key
that will enable you to specify these.

00:13:01.360 --> 00:13:04.670
Absent that, we have a way of
automatically constructing it,

00:13:04.670 --> 00:13:07.340
but we do want to make
that plist key available.

00:13:07.340 --> 00:13:10.000
That's something that's
not in your seed version,

00:13:10.000 --> 00:13:12.640
but we will publicize
that shortly afterward.

00:13:13.600 --> 00:13:13.600
There are other kinds of properties,
like input source ID,

00:13:13.600 --> 00:13:13.600
which is a new property,
a universal string that's

00:13:13.600 --> 00:13:13.600
going to uniquely identify
input sources in Leopard.

00:13:13.600 --> 00:13:13.600
We are going to provide a plist key
that will enable you to specify these.

00:13:13.600 --> 00:13:13.600
Absent that, we have a way of
automatically constructing it,

00:13:13.600 --> 00:13:13.600
but we do want to make
that plist key available.

00:13:13.600 --> 00:13:13.600
That's something that's
not in your seed version,

00:13:13.600 --> 00:13:13.640
but we will publicize
that shortly afterward.

00:13:13.640 --> 00:13:17.140
There are other kinds of properties,
like is it ASCII capable?

00:13:17.140 --> 00:13:18.560
Is it capable of entering ASCII?

00:13:18.640 --> 00:13:19.880
Is it selectable?

00:13:19.880 --> 00:13:20.550
The name?

00:13:20.790 --> 00:13:23.360
What are the languages it can support?

00:13:23.360 --> 00:13:24.160
Icon, etc.

00:13:24.160 --> 00:13:28.770
Key layout data, in this case,
is only going to be Unicode

00:13:28.770 --> 00:13:30.910
format key layout data.

00:13:31.160 --> 00:13:34.560
One property that's not on this list and
is not in the seed but we realize we will

00:13:34.560 --> 00:13:38.150
have to make available is visibility,
whether it's an invisible

00:13:38.630 --> 00:13:40.500
or visible input source.

00:13:40.760 --> 00:13:43.120
And finally, dynamic state:
isn't currently enabled,

00:13:43.120 --> 00:13:44.520
isn't currently selected.

00:13:44.520 --> 00:13:49.140
Okay, well, how do you create these
input source refs?

00:13:49.260 --> 00:13:53.320
There's one primitive function,
TISCreateInputSourceList,

00:13:53.320 --> 00:13:59.950
and this takes a filter CFDictionary of
keys and corresponding values and

00:13:59.950 --> 00:14:04.860
returns an array of input source
refs that match that specified

00:14:04.860 --> 00:14:07.160
set of property keys and values.

00:14:07.160 --> 00:14:10.520
By default,
this will just return information

00:14:10.520 --> 00:14:12.040
for enabled input sources.

00:14:12.040 --> 00:14:15.090
However, there's a Boolean parameter
to this function that lets

00:14:15.120 --> 00:14:19.510
you find out information about
all installed input sources.

00:14:19.800 --> 00:14:22.260
In some cases,
the CFArray will just have one element.

00:14:22.260 --> 00:14:25.310
If you pass a property key
for a particular bundle ID,

00:14:25.310 --> 00:14:28.190
say, or input source ID,
you can narrow it down to a

00:14:28.190 --> 00:14:31.850
single input source and get
the input source ref that way.

00:14:31.860 --> 00:14:35.440
There are some primitive
functions that build on this.

00:14:35.440 --> 00:14:39.900
You can get the current
keyboard input source,

00:14:39.900 --> 00:14:42.990
as you see,
the ASCII-capable keyboard input source,

00:14:42.990 --> 00:14:44.660
and various other things.

00:14:44.660 --> 00:14:47.420
Input source appropriate
for a particular language.

00:14:49.030 --> 00:14:52.140
Here's an example of
how you would use this.

00:14:52.970 --> 00:14:57.220
And you've seen this kind of thing
in other talks today and the day

00:14:57.220 --> 00:15:02.070
before about using CFDictionary's to
create matching dictionaries of

00:15:02.070 --> 00:15:07.440
properties and values and using that
information to obtain something.

00:15:07.440 --> 00:15:09.900
In this case,
it's going to be an input source ref.

00:15:09.900 --> 00:15:14.900
So basically, the key elements are the
CFDictionary create with

00:15:14.900 --> 00:15:19.440
your keys and values and the
TIS create input source list.

00:15:19.440 --> 00:15:19.900
And I show all the
releases here and so on.

00:15:20.360 --> 00:15:23.210
Much simpler is if you just want
to get an input source that's

00:15:23.210 --> 00:15:27.970
appropriate for a particular language.

00:15:28.180 --> 00:15:31.270
Say check in this case,
you just pass the language code for

00:15:31.400 --> 00:15:34.560
that to TIS copy input source for
language and get an input source ref.

00:15:34.600 --> 00:15:37.480
Now note here, we're not using the
Script Manager language code

00:15:37.480 --> 00:15:38.940
or region code or anything.

00:15:38.940 --> 00:15:44.660
We're using, actually what this is,
is an RFC 3066 BIS language code,

00:15:44.660 --> 00:15:48.760
but this is the type of string that's
used in CFLocale and ICU and elsewhere.

00:15:48.760 --> 00:15:52.100
It's the modern way that we
indicate languages in the system.

00:15:53.750 --> 00:15:56.130
At its simplest form,
it might just consist of

00:15:56.130 --> 00:16:00.480
an ISO 639 language code,
and in fact, that's what this is.

00:16:02.600 --> 00:16:05.800
Now for manipulating them,
in most cases the API that's going to be

00:16:05.800 --> 00:16:08.840
important to you is select input source.

00:16:08.930 --> 00:16:12.710
So with a keyboard input source,
that will deselect the

00:16:12.710 --> 00:16:17.710
previous keyboard input source,
not keyboard layout as it says there.

00:16:18.050 --> 00:16:24.670
For other types of input sources,
it has no effect on what other

00:16:24.670 --> 00:16:24.670
input sources may be selected.

00:16:24.880 --> 00:16:29.840
Deselect input source is mainly useful
for palette or ink input sources.

00:16:29.840 --> 00:16:33.430
And the enable or disable input
source API are mainly intended for

00:16:33.430 --> 00:16:37.910
input methods that may want to bring
up their own palettes and so forth.

00:16:38.870 --> 00:16:44.890
We also have a couple of notifications,
one for changing the selected keyboard

00:16:44.980 --> 00:16:49.510
input source and one for changing the
set of enabled keyboard input sources.

00:16:49.560 --> 00:16:55.180
Okay, well I'd like to go
through a quick demo here.

00:16:58.450 --> 00:17:02.640
Okay, so I threw together a quick
Cocoa app here called TIS Demo

00:17:02.640 --> 00:17:04.740
just to show you some of the kinds
of things you can do with this.

00:17:04.800 --> 00:17:07.800
There are a couple of
little rough edges with it,

00:17:07.800 --> 00:17:09.960
and it's not meant to
demonstrate a user interface.

00:17:09.960 --> 00:17:14.220
Basically, selecting a row in the table
view here will give you

00:17:14.220 --> 00:17:19.040
additional information below,
what its input source ID is, bundle ID,

00:17:19.040 --> 00:17:22.340
input mode if it has one,
and some supported languages.

00:17:24.050 --> 00:17:28.840
You can enable or disable
input sources using this.

00:17:28.840 --> 00:17:31.090
You can also select them,
and that will be reflected

00:17:31.090 --> 00:17:32.200
elsewhere in the UI.

00:17:32.200 --> 00:17:38.080
So, for example, if I go down here and,
oh, let's see, let's pick something.

00:17:38.080 --> 00:17:40.630
Let me select Hiragana
as my input source,

00:17:40.630 --> 00:17:43.650
and you can see that the
Text Input menu changes it,

00:17:43.650 --> 00:17:44.860
changes there.

00:17:46.280 --> 00:17:50.180
The boxes at the bottom always
reflect the current keyboard

00:17:50.180 --> 00:17:54.870
input source and the current
ASCII-capable keyboard input source,

00:17:54.880 --> 00:18:00.800
so that you see right now we've
got Hiragana as our input source,

00:18:00.800 --> 00:18:04.840
but the ASCII-capable input source
is still the US keyboard layout.

00:18:04.860 --> 00:18:07.890
If I go through here and, for example,
I enable,

00:18:07.890 --> 00:18:12.310
or I can enable it in here as well,
if I go through and enable French, say,

00:18:12.500 --> 00:18:15.780
you'll see that French is
the current input source,

00:18:15.920 --> 00:18:18.640
but it's also the current
ASCII-capable input source.

00:18:18.660 --> 00:18:23.020
One fun little thing here that
shows background manipulation is to

00:18:23.070 --> 00:18:26.680
cycle through enabled input sources,
so, and this is going to cycle

00:18:26.680 --> 00:18:29.620
through them in the order that
the table view is in here,

00:18:29.620 --> 00:18:31.120
so let me start this.

00:18:31.120 --> 00:18:32.920
This is going to cycle
through every five seconds.

00:18:32.920 --> 00:18:34.920
It's going to pick a new,
the next enabled input

00:18:34.920 --> 00:18:36.220
source in the list here.

00:18:36.270 --> 00:18:38.300
So let me start that,
and then I'm going to switch

00:18:38.330 --> 00:18:40.800
over here to TextEdit,
so I'm typing in TextEdit.

00:18:40.860 --> 00:18:44.890
I've got some Arabic in there,
and now we've got

00:18:46.100 --> 00:18:47.380
What have we got here?

00:18:47.380 --> 00:18:49.300
I guess that's... Oh,
now we're on to French,

00:18:49.300 --> 00:18:51.140
so I've got the Azzurri keyboard here.

00:18:51.140 --> 00:18:55.340
And now we're on to German,
so I've got the German keyboard,

00:18:55.340 --> 00:19:00.380
but it's got still QW in the upper left,
and we're in Russian here, and so on.

00:19:00.380 --> 00:19:02.880
Let me stop that.

00:19:04.620 --> 00:19:06.720
Anyway, so that just gives you a
sense of the kinds of things

00:19:06.720 --> 00:19:07.700
that you can do with that.

00:19:07.730 --> 00:19:09.840
Okay, so back to slides, please.

00:19:14.260 --> 00:19:16.290
Okay, well,
we're full of recommendations,

00:19:16.290 --> 00:19:20.000
do's and don'ts,
so don't use the Script Manager,

00:19:20.000 --> 00:19:22.940
don't assume that key layouts
have K-chart data available,

00:19:22.940 --> 00:19:26.180
and don't assume that input
methods are components.

00:19:26.180 --> 00:19:29.910
And one way you can avoid a lot of
these don'ts is by the first do,

00:19:29.910 --> 00:19:34.810
which is adopt the Text Input Sources
API for manipulation of input sources.

00:19:34.820 --> 00:19:38.330
Also, I've alluded to this,
is you can use more precise and more

00:19:38.410 --> 00:19:42.160
modern tokens for representation
of a lot of the types you need.

00:19:42.560 --> 00:19:44.800
And I've got a little cheat
sheet in the next slide that

00:19:44.980 --> 00:19:46.540
goes into more detail on this.

00:19:46.540 --> 00:19:51.090
And finally, and very important,
give us your feedback and suggestions.

00:19:51.180 --> 00:19:55.040
It's not too late to have an
impact on the API for Leopard,

00:19:55.040 --> 00:19:57.220
so please do give us your
feedback and suggestions,

00:19:57.220 --> 00:20:00.140
things that you want to add,
or additional notifications,

00:20:00.220 --> 00:20:01.740
whatever you'd like to see.

00:20:01.740 --> 00:20:04.870
Okay, well,
here's the promised cheat sheet.

00:20:04.880 --> 00:20:09.380
It shows you some of the ways that these
older tokens have been used in the past.

00:20:09.400 --> 00:20:11.500
Script Code, especially,
has been used for many

00:20:11.500 --> 00:20:12.540
different purposes.

00:20:12.540 --> 00:20:16.690
And we'd like to have you replace
most of those usages with something

00:20:16.690 --> 00:20:21.640
that's more appropriate for the way in
which you were using the script code.

00:20:21.640 --> 00:20:24.230
So, CF Character Set,
where you meant the script code to

00:20:24.290 --> 00:20:26.180
indicate a repertoire of characters.

00:20:26.180 --> 00:20:29.850
CFString Encoding, or Text Encoding,
where you meant script code

00:20:29.850 --> 00:20:31.620
to indicate a text encoding.

00:20:31.620 --> 00:20:36.420
CFLocale, for language code,
or CFLocale Language String, sorry,

00:20:36.420 --> 00:20:40.260
that's that language string
I was referring to earlier,

00:20:40.260 --> 00:20:42.440
to refer to a language, etc.

00:20:42.560 --> 00:20:46.510
And also the TIS Input Source Ref,
where you mean to refer to

00:20:46.510 --> 00:20:49.900
other kinds of input sources,
Keyboard Layout Ref,

00:20:49.900 --> 00:20:52.940
or the component where it was
used to indicate input methods.

00:20:52.940 --> 00:20:55.980
Now, I'd like to bring up Michael Grady,
Mr.

00:20:55.980 --> 00:20:58.730
TSM,
to give you some more detail on what's

00:20:58.730 --> 00:21:01.780
happening with the Tech Services Manager.

00:21:06.440 --> 00:21:08.310
Thank you, Peter,
for that consideration of the

00:21:08.310 --> 00:21:10.540
new Text Input Sources API.

00:21:10.710 --> 00:21:11.330
Hello, everybody.

00:21:11.350 --> 00:21:15.590
My part of this symposium will be a
low-level consideration of changes to

00:21:15.590 --> 00:21:17.480
the Text Services Manager in Leopard.

00:21:17.480 --> 00:21:21.060
In particular, I'll be addressing two
types of developers.

00:21:21.060 --> 00:21:24.060
Application developers who
provide your own text engine,

00:21:24.060 --> 00:21:26.880
so most likely you're
programming to the Carbon API.

00:21:26.880 --> 00:21:30.420
Certainly,
developers using Cocoa or HIToolbox's

00:21:30.420 --> 00:21:36.280
HITextView are insulated from most of the
information except for part of the text.

00:21:36.300 --> 00:21:38.430
I'll be presenting the first part
at the end of my presentation

00:21:38.430 --> 00:21:41.200
that has to do with restricting
input sources and input context.

00:21:41.200 --> 00:21:45.490
Another type of developer affected
by the information I'll be presenting

00:21:45.540 --> 00:21:47.450
are input method developers.

00:21:49.000 --> 00:21:51.300
The information will
be three general areas:

00:21:51.300 --> 00:21:54.660
changes to TSM that affect
you in your deployment of your

00:21:54.660 --> 00:22:00.090
applications to the 64-bit platform,
as well as your input methods.

00:22:00.330 --> 00:22:03.360
Changes to TSM to support
resolution independence and how

00:22:03.360 --> 00:22:06.740
they help you also support it
in your apps and input methods.

00:22:06.740 --> 00:22:14.300
And finally,
modernization in TSM itself and how

00:22:14.300 --> 00:22:16.100
that allows you to be more modern
and hopefully write more maintainable

00:22:16.100 --> 00:22:16.100
code than you could in the past.

00:22:17.560 --> 00:22:21.630
By far the biggest change to
TSM in Leopard has been the

00:22:21.640 --> 00:22:24.300
large-scale deprecation of API.

00:22:24.500 --> 00:22:28.500
API that expose deprecated
notions such as script code,

00:22:28.500 --> 00:22:34.560
API that exposed underlying
types like the component ID,

00:22:34.590 --> 00:22:39.500
which is really a plugin architecture
notion that has no business

00:22:39.500 --> 00:22:41.500
being exposed at the API level.

00:22:41.500 --> 00:22:44.500
All of these APIs mostly
fall in one group.

00:22:44.660 --> 00:22:47.500
They're APIs that attempt
to control input sources,

00:22:47.500 --> 00:22:51.590
manage input sources, enable them,
select them,

00:22:51.610 --> 00:22:54.620
and they're not really part of
the core functionality of TSM,

00:22:54.620 --> 00:22:58.460
which is input context management,
not input source management.

00:22:58.510 --> 00:23:03.180
So it's logical that these all
have natural replacements in

00:23:03.240 --> 00:23:05.370
the Text Input Sources API.

00:23:05.550 --> 00:23:09.820
Of particular note is the
deprecation and death of key script.

00:23:09.870 --> 00:23:12.620
Please attend this funeral.

00:23:12.790 --> 00:23:17.750
It's mostly been used to select
an input source via a script code.

00:23:17.810 --> 00:23:21.240
And so it has a natural
replacement in the TIS API.

00:23:21.620 --> 00:23:25.570
There is one use of key script that
does not have a replacement in TIS.

00:23:25.750 --> 00:23:26.800
And we'll be discussing that.

00:23:26.800 --> 00:23:28.920
It has to do with
passing negative values,

00:23:28.920 --> 00:23:32.020
non-script code values,
to it to restrict input sources

00:23:32.020 --> 00:23:34.280
in a given input context,
like a text field.

00:23:34.450 --> 00:23:37.110
We'll see the replacement for that later.

00:23:37.370 --> 00:23:41.170
Another API that's been deprecated,
and when I mean deprecated here,

00:23:41.170 --> 00:23:44.700
I mean not available on 64-bit
at all for all these APIs.

00:23:44.710 --> 00:23:49.080
A further example is the
Keyboard Layout Access API,

00:23:49.080 --> 00:23:51.340
also known as the KL API.

00:23:51.450 --> 00:23:57.170
These APIs provided mostly iteration over
keyboard layouts and property queries.

00:23:57.350 --> 00:24:02.000
These also all have natural
replacements in the TIS API.

00:24:02.210 --> 00:24:05.680
I mentioned one more thing
here in the context of 64-bit,

00:24:05.680 --> 00:24:08.480
and that is the TSM support
for an additional type of

00:24:08.480 --> 00:24:09.980
input method architecture.

00:24:09.980 --> 00:24:14.400
TSM still, even on 64-bit,
continues to support component

00:24:14.400 --> 00:24:19.300
manager-based plugin input methods,
in addition to application-based

00:24:19.570 --> 00:24:22.940
input methods developed to the Input
Method Kit framework that will be

00:24:23.020 --> 00:24:24.740
discussed later by Lee Collins.

00:24:25.680 --> 00:24:28.420
Why do I mention this in
conjunction with 64-bit?

00:24:28.430 --> 00:24:31.080
Because it gives you,
the input method developer,

00:24:31.080 --> 00:24:33.420
a choice on how to
deploy your input method.

00:24:33.420 --> 00:24:37.210
If you're going to continue to be a
component manager-based input method,

00:24:37.210 --> 00:24:38.260
you are a plugin.

00:24:38.260 --> 00:24:41.580
As a plugin,
you are hosted in a parent process,

00:24:41.580 --> 00:24:45.910
and if that process is 64-bit,
you need to be so as well.

00:24:45.920 --> 00:24:49.070
Alternatively,
if you port your input method

00:24:49.140 --> 00:24:52.360
to the Input Method Kit,
you are free from that requirement.

00:24:52.360 --> 00:24:55.660
32-bit implementation is sufficient.

00:24:55.680 --> 00:24:57.300
for you.

00:24:57.640 --> 00:25:00.860
So all the deprecated
API are in techservices.h.

00:25:00.900 --> 00:25:05.170
There are some more changes
in the Carbon events realm.

00:25:05.890 --> 00:25:10.880
TSM defines two Carbon event
suites in the Carbon Event Manager.

00:25:10.880 --> 00:25:15.790
Some of those events use
parameters whose event parameter

00:25:15.890 --> 00:25:19.270
types are problematic on 64-bit.

00:25:19.370 --> 00:25:24.120
One notable example is the use
of type long integer as the event

00:25:24.120 --> 00:25:27.300
type for many different parameters.

00:25:27.990 --> 00:25:30.880
It might not be obvious why that
type is problematic at first.

00:25:30.920 --> 00:25:36.210
After all, on the LP64 data model,
a long is 64 bits.

00:25:36.390 --> 00:25:41.140
The problem is that this event
parameter type is an alias to type SN32,

00:25:41.270 --> 00:25:44.270
making it completely unsuitable
for things that need to be 64 bit.

00:25:44.340 --> 00:25:46.070
For example, refcons.

00:25:46.070 --> 00:25:50.760
Refcons are usually an object reference
of some sort or a pointer to data.

00:25:50.760 --> 00:25:52.880
It needs to be 64 bits.

00:25:53.780 --> 00:25:58.330
Byte counts and byte offsets are also
frequently used in TSM event parameters.

00:25:58.370 --> 00:26:01.260
Those need to be 64 bits on LP64 as well.

00:26:01.260 --> 00:26:04.020
So the Carbon Event Manager,
not just for TSM events,

00:26:04.020 --> 00:26:06.440
but other events that
have similar problems,

00:26:06.440 --> 00:26:10.950
have introduced three explicit
Carbon event parameter types,

00:26:10.950 --> 00:26:14.740
type refcon, type byte count,
type byte offset.

00:26:14.740 --> 00:26:19.550
Now, these event parameter types are new,
separate event parameter

00:26:19.620 --> 00:26:21.840
types from type long integer.

00:26:21.840 --> 00:26:23.760
They are source components,
and they are not necessarily the

00:26:23.760 --> 00:26:23.760
same as the type long integer.

00:26:23.760 --> 00:26:26.810
They are compatible between
32-bit and 64-bit implementations,

00:26:26.810 --> 00:26:28.940
but there is a binary
compatibility issue.

00:26:28.940 --> 00:26:33.130
If an input method, for example,
sets a parameter with

00:26:33.130 --> 00:26:35.160
the type long integer,
and you, the application,

00:26:35.160 --> 00:26:37.970
ask for a type refcon,
how does that work?

00:26:38.000 --> 00:26:39.510
It's a different event parameter type.

00:26:39.540 --> 00:26:42.820
The answer is that the
Carbon Event Manager provides

00:26:42.820 --> 00:26:46.860
automatic type coercion for
these types on 32-bit only.

00:26:46.870 --> 00:26:49.230
On 64-bit,
you are required to use the new

00:26:49.310 --> 00:26:51.340
event parameter types in all cases.

00:26:51.340 --> 00:26:53.740
Of course,
with these new event parameters,

00:26:53.740 --> 00:26:53.740
you can't use the new
event parameter types.

00:26:53.740 --> 00:26:55.260
You'll want to use the
corresponding data types,

00:26:55.330 --> 00:26:56.720
such as those found in MacTypes.h.

00:26:56.720 --> 00:27:03.810
The different variants of refcon,
byte offset, and byte count are also

00:27:03.810 --> 00:27:05.690
defined in that header.

00:27:07.990 --> 00:27:09.620
For the new parameter types,
you'll want to use the

00:27:09.620 --> 00:27:13.290
corresponding data types,
such as those found in MacTypes.h.

00:27:13.290 --> 00:27:18.090
The different variants of RefCon,
ByteOffset, and ByteCounter are also

00:27:18.090 --> 00:27:19.860
defined in that header.

00:27:37.900 --> 00:27:42.380
You'll also want to use the
point data in point space,

00:27:42.380 --> 00:27:46.810
or also known as 72 dpi
virtual coordinate space.

00:27:48.200 --> 00:27:51.360
The geometries for which you
might want data in screen pixel

00:27:51.360 --> 00:27:55.080
coordinates are not limited to
things like rectangles or points.

00:27:55.080 --> 00:27:57.750
There are things that are
unidimensional in nature,

00:27:57.750 --> 00:28:01.010
like line height, line ascent,
that might make sense for you to ask

00:28:01.100 --> 00:28:03.130
for in screen pixel coordinates as well.

00:28:03.270 --> 00:28:05.760
So we have a new type
CG float screen pixel,

00:28:05.760 --> 00:28:08.590
a variant of another new
event parameter type,

00:28:08.650 --> 00:28:11.570
type CG float,
we'll be discussing in a bit.

00:28:11.650 --> 00:28:15.970
So let's see how these new
types affect TSM events.

00:28:17.050 --> 00:28:20.700
Some TSM events use some
deprecated event parameter types,

00:28:20.720 --> 00:28:22.460
an example type QD point.

00:28:22.530 --> 00:28:25.700
This has been replaced in all
cases by the type HI point.

00:28:25.770 --> 00:28:28.830
And of course,
you're free to request that data

00:28:28.830 --> 00:28:34.020
using the new screen pixel variants of
those event parameter types as well.

00:28:35.340 --> 00:28:38.790
Some event parameter data in
TSM events are scalar values.

00:28:38.790 --> 00:28:41.270
They've been typed in various ways.

00:28:41.270 --> 00:28:45.800
We have an example here of a reply
point size parameter typed as type fix.

00:28:45.800 --> 00:28:49.170
We have a line height in
one case typed as type SN16,

00:28:49.220 --> 00:28:50.920
a font size as a type float.

00:28:50.950 --> 00:28:55.940
Wouldn't it be nice if all of the things
that need to be floats were floats?

00:28:56.440 --> 00:29:00.670
And so we have the type CG float used
in all cases for these parameters.

00:29:00.670 --> 00:29:04.640
And where it makes sense,
such as line height,

00:29:04.640 --> 00:29:07.550
line ascent information,
you can request those as type

00:29:07.550 --> 00:29:09.590
CG float screen pixel as well.

00:29:09.590 --> 00:29:11.800
And that coercion is all automatic.

00:29:14.340 --> 00:29:17.880
TSM has undergone a lot
of internal modernization.

00:29:17.940 --> 00:29:22.200
Upheaval is another
word for it on Leopard.

00:29:22.330 --> 00:29:26.040
I mentioned already the support for
several input method architectures.

00:29:26.040 --> 00:29:29.060
There's still full support,
even on 64-bit,

00:29:29.060 --> 00:29:34.280
for component manager-based plugins,
also application-based input methods

00:29:34.280 --> 00:29:36.540
implemented to the Input Method Kit.

00:29:36.540 --> 00:29:40.630
TSM has completely moved off of
any notion of the Script Manager,

00:29:40.630 --> 00:29:43.680
in particular,
any use of the Keyscript API.

00:29:43.680 --> 00:29:49.040
It uses the TIS API that
Peter referred to.

00:29:49.060 --> 00:29:52.220
This API is really the
way to go for you as well.

00:29:52.330 --> 00:29:58.040
It can do things that you just simply
could not do with the old Keyscript API,

00:29:58.040 --> 00:30:02.040
especially from background apps,
as Peter showed in the demo.

00:30:02.870 --> 00:30:08.700
TSM has also modernized its event
parameter content with modern event

00:30:08.700 --> 00:30:14.480
parameters with modern event types,
but still supporting the existing

00:30:14.480 --> 00:30:17.100
event parameters in TSM events.

00:30:17.100 --> 00:30:19.310
So how does this work?

00:30:19.370 --> 00:30:25.120
How can you,
a client of a modern event parameter,

00:30:25.560 --> 00:30:30.400
Get that data if the event parameter
data in the event are the older types.

00:30:30.400 --> 00:30:35.390
This is not just a type coercion issue,
it's a parameter set

00:30:35.390 --> 00:30:37.720
coercion issue of sorts.

00:30:37.720 --> 00:30:41.480
So TSM is able to solve this
because you as input method

00:30:41.860 --> 00:30:44.530
developers are really good citizens.

00:30:44.540 --> 00:30:47.420
And you are using the
API we tell you to use,

00:30:47.420 --> 00:30:49.370
you always do so, right?

00:30:50.520 --> 00:30:53.250
While TSM is able to
leverage off of this,

00:30:53.260 --> 00:30:56.220
consider what happens when
an input method dispatches

00:30:56.220 --> 00:30:57.490
an event to an application.

00:30:57.500 --> 00:31:01.460
It always calls an API called
SendTextInputEvent.

00:31:01.460 --> 00:31:05.030
This is a perfect bottleneck
for TSM to inspect the event,

00:31:05.090 --> 00:31:10.870
see what parameter data is there,
what parameter data it could promise.

00:31:11.230 --> 00:31:13.490
and derive from the data that's present.

00:31:13.520 --> 00:31:17.410
If the application then requests
the modern event parameter,

00:31:17.410 --> 00:31:21.100
TSM will coerce them using a
promise mechanism on demand.

00:31:21.200 --> 00:31:24.800
Similarly, when an event is returned to
TSM after being handled or not,

00:31:24.900 --> 00:31:27.310
but before being returned
to the input method,

00:31:27.380 --> 00:31:30.420
TSM can again inspect the event,
see what data is there,

00:31:30.420 --> 00:31:32.340
and promise additional data.

00:31:33.520 --> 00:31:36.620
Here are some examples of
the modern event parameter

00:31:36.620 --> 00:31:38.740
types that TSM is introducing.

00:31:38.740 --> 00:31:40.840
We have a typect fontref.

00:31:41.000 --> 00:31:43.280
This refers to a Cortex font.

00:31:43.280 --> 00:31:49.400
Some of you will have heard of this
in the Cortex session this morning.

00:31:49.430 --> 00:31:53.510
An event parameter of this type
can encapsulate information

00:31:53.510 --> 00:31:56.400
that was contained in various
parameters in the past.

00:31:56.400 --> 00:32:01.400
We might have needed a font
parameter like an ATS fontref,

00:32:01.400 --> 00:32:04.400
size, ascent, descent information.

00:32:04.400 --> 00:32:07.520
All of this information can be
encapsulated in a single modern

00:32:07.520 --> 00:32:09.400
event parameter of this new type.

00:32:09.400 --> 00:32:12.430
We have an example of this
in the middle of the slide

00:32:12.430 --> 00:32:14.220
in the offset to pause event.

00:32:14.400 --> 00:32:19.780
It currently is introducing a replyct
fontref parameter that can encapsulate

00:32:19.890 --> 00:32:23.400
the older parameters that contain font,
point size, etc.

00:32:23.400 --> 00:32:29.400
There's a new typect glyph info ref that
replaces the ATS type glyph selector.

00:32:29.400 --> 00:32:33.400
And a new typect attributed string ref.

00:32:33.400 --> 00:32:37.580
And a parameter of this type can
encapsulate data formerly found in

00:32:37.580 --> 00:32:41.500
different parameters that would contain
Unicode text separate from font,

00:32:41.500 --> 00:32:43.400
separate from glyph info information.

00:32:43.400 --> 00:32:47.400
An example of this is the text
input Unicode for key event.

00:32:47.400 --> 00:32:50.720
This is a new send attributed string
parameter to replace the two or

00:32:50.770 --> 00:32:52.400
three parameters needed previously.

00:32:55.380 --> 00:32:58.130
A bit more on the modernization front.

00:32:58.310 --> 00:33:01.980
Since TSM does support additional
input method architectures,

00:33:01.980 --> 00:33:06.300
the type component instance event
parameter type is being eliminated.

00:33:06.480 --> 00:33:09.310
In addition,
the type Intel writing code is really

00:33:09.400 --> 00:33:13.180
a reference to a structure containing
a script code and a language.

00:33:13.310 --> 00:33:15.320
In a Unicode world,
that's been deprecated.

00:33:16.540 --> 00:33:20.380
Some of you application developers
who implement your own text engines,

00:33:20.380 --> 00:33:24.820
you may have used an
API that's being deprecated,

00:33:24.880 --> 00:33:27.060
TSM Set Inline Input Region.

00:33:27.060 --> 00:33:31.970
This API was used to allow you
to communicate to TSM the bounds

00:33:31.970 --> 00:33:35.580
on screen of an inline input
session as a user is typing.

00:33:35.580 --> 00:33:38.920
That in turn allows TSM to filter
out mouse events that have no need

00:33:38.920 --> 00:33:42.660
to be routed to an input method if
they don't intersect those bounds.

00:33:42.660 --> 00:33:45.960
Well,
that's kind of an expensive way to do it.

00:33:46.540 --> 00:33:49.860
TSM doesn't always need the information,
and that API required the

00:33:49.910 --> 00:33:53.910
application to constantly update
the bounds in case TSM did need it.

00:33:53.960 --> 00:33:57.070
Also had to make sure to call
the API in all the right places.

00:33:57.090 --> 00:34:00.080
So it's being replaced
by a more convenient,

00:34:00.080 --> 00:34:04.600
more interesting to you, we hope,
Carbon event, a text input event called

00:34:04.600 --> 00:34:06.510
IsMouseEventInAnInputArea.

00:34:06.520 --> 00:34:11.070
When TSM needs the information,
it will call your callback.

00:34:12.310 --> 00:34:15.650
I have another plea for application
developers who provide your own

00:34:15.660 --> 00:34:21.250
text engines to please implement
the TSM Document Access Protocol.

00:34:21.600 --> 00:34:26.440
This is another TSM event suite that
essentially allows text services to

00:34:26.440 --> 00:34:31.800
interact with any part of your document,
not just near the insertion point,

00:34:31.820 --> 00:34:32.870
but anywhere.

00:34:32.880 --> 00:34:38.530
Dictionary Services uses this
to provide definitions of

00:34:38.530 --> 00:34:41.820
words that lie under the mouse,
no matter where the insertion point is.

00:34:41.880 --> 00:34:45.430
The typography panel uses
the protocol as well.

00:34:46.410 --> 00:34:49.920
It has been available
since MacOSX 10.3.

00:34:50.010 --> 00:34:53.510
It's fully supported by Cocoa,
fully supported by

00:34:53.510 --> 00:34:55.080
HIToolbox's HITextView.

00:34:55.080 --> 00:35:01.180
Essentially, it is a set of events that
mimic the CFString API,

00:35:01.180 --> 00:35:05.420
treating your document as if it were
one big CFString and accessing read-only

00:35:05.420 --> 00:35:07.380
access anywhere in that string.

00:35:07.380 --> 00:35:12.320
While the protocol does not implement
write access anywhere in a document,

00:35:12.380 --> 00:35:15.150
it does define how this should be done.

00:35:15.840 --> 00:35:21.490
There is an auxiliary event parameter in
the UpdateActiveInputArea event that's

00:35:21.490 --> 00:35:27.570
used for inline input in general that
allows an input method or a text service

00:35:27.580 --> 00:35:31.880
to specify a replaced range at arbitrary
locations in your document again,

00:35:31.880 --> 00:35:34.160
independent of where
the insertion point is.

00:35:35.640 --> 00:35:39.580
So what you need to do besides
implement the handlers in

00:35:39.580 --> 00:35:44.860
the Document Access Protocol,
simply in any TSM event that you create,

00:35:44.860 --> 00:35:50.240
indicate that you support this protocol
with the TSM document property,

00:35:50.330 --> 00:35:53.190
support document access property.

00:35:53.580 --> 00:35:57.650
This will allow TSM to notify input
methods that you do support that

00:35:57.650 --> 00:36:02.200
and enable a richer set of features
for the users of your application.

00:36:03.980 --> 00:36:09.240
The whole title of this session
is Take Charge of Text Input.

00:36:09.240 --> 00:36:12.500
Developers have been asking for
quite a while for more control

00:36:12.760 --> 00:36:17.050
in one area in particular,
and that is more flexibility in

00:36:17.050 --> 00:36:25.200
restricting the set of input sources
for a given input context or text field.

00:36:25.200 --> 00:36:28.580
For example,
developers often want to restrict the

00:36:28.650 --> 00:36:32.920
set of input sources available to the
user for a text field to ASCII only.

00:36:32.990 --> 00:36:37.280
Or once the application has
identified an input source

00:36:37.340 --> 00:36:39.650
that really needs to be used,
it may want to prevent the user

00:36:39.650 --> 00:36:44.020
from switching to something else,
again, in the context of that text field.

00:36:44.900 --> 00:36:49.070
This has traditionally been done with
the KeyScript API with negative values,

00:36:49.080 --> 00:36:51.390
non-script code values passed to it.

00:36:51.580 --> 00:36:54.690
The big disadvantage with this
API is that it's global in scope,

00:36:54.690 --> 00:36:57.700
at least global in the app's context.

00:36:57.700 --> 00:37:01.690
And this has required careful cleanup on
your part to make sure that the effect

00:37:01.690 --> 00:37:06.070
of calling KeyScript with the intent
of affecting input in only one input

00:37:06.070 --> 00:37:10.500
context does not spill over into another
input context and affect the user there.

00:37:10.520 --> 00:37:13.060
So you had to carefully clean up.

00:37:13.060 --> 00:37:16.870
Wouldn't it be nice if the input
context could encapsulate that state?

00:37:16.940 --> 00:37:19.240
In particular,
the TSM document associated

00:37:19.240 --> 00:37:21.160
with that input context.

00:37:21.180 --> 00:37:26.130
So the solution we're providing
are two TSM document properties.

00:37:26.150 --> 00:37:30.790
One TSM document property allows
you to specify a subset of all those

00:37:30.790 --> 00:37:35.900
input sources enabled by the user,
such as in the international prefs panel.

00:37:36.370 --> 00:37:39.650
And by default, any time your input
context gets key focus,

00:37:39.650 --> 00:37:42.950
TSM would use the last used
input source from the restricted

00:37:43.000 --> 00:37:44.900
list that you have specified.

00:37:44.900 --> 00:37:48.640
If you want more fine-grained control,
again, this slide is all about control,

00:37:48.640 --> 00:37:53.280
you can yourself specify which input
source specifically from that list

00:37:53.280 --> 00:37:57.640
you want to become current when
your input context gets key focus.

00:37:57.640 --> 00:38:01.790
Now, there is a desire for minimal
interference of this kind of

00:38:01.790 --> 00:38:06.020
restriction with input contexts
that have no restriction.

00:38:06.300 --> 00:38:09.780
For example, suppose you're typing away
in Japanese in TextEdit,

00:38:09.780 --> 00:38:11.700
and you switch to
another app temporarily,

00:38:11.700 --> 00:38:14.810
force is asking only input,
you switch from US to

00:38:14.810 --> 00:38:16.360
French and back to TextEdit.

00:38:16.490 --> 00:38:19.360
Well, you would expect to continue
to type in Japanese.

00:38:19.380 --> 00:38:24.420
So TSM solves this problem by saving
and restoring all the input source

00:38:24.420 --> 00:38:27.690
state necessary around any restriction.

00:38:30.370 --> 00:38:32.940
Here are some details on the
two properties I mentioned.

00:38:33.050 --> 00:38:36.540
We have the new Enable
Input Sources property.

00:38:36.540 --> 00:38:40.750
And again, by default,
the behavior in TSM is to select from

00:38:40.750 --> 00:38:46.250
that list the last used input source
when your input context gets focused.

00:38:46.300 --> 00:38:50.900
If you want more control,
there is the new Input

00:38:50.900 --> 00:38:50.900
Source Override property.

00:38:51.620 --> 00:38:54.820
Now,
in the lifetime of a given login session,

00:38:54.820 --> 00:38:57.890
the user may,
at several different points,

00:38:57.890 --> 00:39:02.310
enable and disable various input
sources through the system,

00:39:02.320 --> 00:39:04.430
the international press pin.

00:39:04.470 --> 00:39:08.670
So you as a developer need to
know from time to time when

00:39:08.730 --> 00:39:13.080
to perhaps adjust the subset,
the restricted set of input sources you

00:39:13.160 --> 00:39:15.120
specified on various input contexts.

00:39:15.220 --> 00:39:18.060
We have a notification that
will allow you to do this.

00:39:18.060 --> 00:39:22.010
The KTIS notify enabled
keyboard input sources changed.

00:39:22.110 --> 00:39:25.960
It's dispatched through the
CF Distributed Notification Center.

00:39:27.900 --> 00:39:30.790
Some examples of the new
document properties in use.

00:39:30.850 --> 00:39:34.900
We have the enabled input sources
property in the first box.

00:39:34.900 --> 00:39:39.890
The value for this property is simply
a CFArray of TIS input source refs.

00:39:39.890 --> 00:39:44.900
If you want that extra level of control,
specify a preferred input source.

00:39:44.900 --> 00:39:50.100
We have the input source override
property tag whose value is

00:39:50.100 --> 00:39:50.100
simply a TIS input source ref.

00:39:50.300 --> 00:39:56.840
Now, one thing I want to point out with
this is that unlike using key script,

00:39:56.850 --> 00:40:02.650
which had to be called around the time
that an input context gets key focus,

00:40:02.730 --> 00:40:05.570
these properties can be set when
your input context is created,

00:40:05.570 --> 00:40:07.300
and then you can forget about them.

00:40:07.330 --> 00:40:12.770
Set it, forget it,
let TSM deal with the necessary

00:40:12.770 --> 00:40:16.310
synchronization as focus goes from
one input context to the next.

00:40:18.560 --> 00:40:23.230
By far the most common use of
restricting input sources is ASCII only.

00:40:23.250 --> 00:40:27.270
To that end, we have a convenience API,
TIS Create ASCII Capable

00:40:27.330 --> 00:40:31.390
Input Source List,
that gives you back an array of

00:40:31.390 --> 00:40:36.840
TIS input sources that are ASCII capable,
take that result,

00:40:36.850 --> 00:40:42.950
pass it directly as the value of
the enabled input sources property,

00:40:42.950 --> 00:40:44.990
and of course release the result
because it is a Create API.

00:40:46.070 --> 00:40:50.740
By far the most common use of
restricting input sources is ASCII only.

00:40:50.740 --> 00:40:54.790
To that end, we have a convenience API,
TIS Create ASCII Capable

00:40:54.790 --> 00:40:58.890
Input Source List,
that gives you back an array of

00:40:58.890 --> 00:41:04.350
TIS input sources that are ASCII capable,
take that result,

00:41:04.350 --> 00:41:10.450
pass it directly as the value of
the enabled input sources property,

00:41:10.450 --> 00:41:11.340
and of course release the result
because it is a Create API.

00:41:11.810 --> 00:41:14.590
The benefit of this is twofold.

00:41:14.680 --> 00:41:18.400
One, all key events are pre-translated
by the system before they're

00:41:18.400 --> 00:41:20.390
delivered to your input method.

00:41:20.440 --> 00:41:22.940
That frees you, the developer,
from having to do your

00:41:22.990 --> 00:41:24.450
own keyboard translation.

00:41:24.520 --> 00:41:28.840
Another benefit is that since the system
now knows about your override explicitly,

00:41:28.840 --> 00:41:34.090
it can show it in system UI,
such as keyboard layout palette.

00:41:34.850 --> 00:41:37.300
And this again frees you,
the input method,

00:41:37.300 --> 00:41:40.780
from having to implement your
own keyboard layout palettes.

00:41:40.890 --> 00:41:44.320
Apple's own Chinese and Korean input
methods have been using this

00:41:44.320 --> 00:41:47.180
mechanism since MacOSX 10.4.

00:41:47.230 --> 00:41:50.770
And before we go on to the specifics
of this new API I mentioned,

00:41:50.790 --> 00:41:54.780
I'd just like to call your
attention briefly to those input

00:41:54.780 --> 00:41:58.620
methods that implement input modes,
input mode savvy input methods.

00:41:58.620 --> 00:42:02.740
You are currently using TSM select
input mode to switch between

00:42:02.740 --> 00:42:05.020
the input modes you implement.

00:42:05.020 --> 00:42:09.340
This has been deprecated in favor
of the TIS select input source API,

00:42:09.340 --> 00:42:13.220
a very natural correspondence.

00:42:13.950 --> 00:42:16.660
There are two lines here in
blue that I really want you

00:42:16.660 --> 00:42:18.050
to look for in your code.

00:42:18.250 --> 00:42:23.870
If you see these two lines,
please throw them away.

00:42:24.380 --> 00:42:27.690
Just look out for them, act aggressively,
and throw them away.

00:42:27.690 --> 00:42:30.890
Replace them by the single line,
single API call,

00:42:30.900 --> 00:42:34.080
TIS Set Input Method Keyboard
Layout Override.

00:42:34.200 --> 00:42:36.840
This will give you all
the benefits I mentioned,

00:42:36.840 --> 00:42:41.140
key events pre-translated for free,
and your private keyboard layouts will

00:42:41.140 --> 00:42:45.280
be visible in the system keyboard layout,
keyboard viewer palette.

00:42:45.310 --> 00:42:48.810
Finally, there is,
if you have a need to find out

00:42:48.810 --> 00:42:52.580
what the current override is,
there is a copy function

00:42:52.580 --> 00:42:52.580
for that as well.

00:42:54.110 --> 00:42:57.740
So, some takeaway points.

00:42:57.740 --> 00:43:01.440
Look at the headers, techservices.h,
carbonevents.h,

00:43:01.440 --> 00:43:02.960
for all the deprecated API.

00:43:02.960 --> 00:43:04.960
Move off of Keyscript, please.

00:43:04.960 --> 00:43:08.280
You can do a whole lot more with the
TIS API you could never do before.

00:43:08.280 --> 00:43:11.890
Adopt in your applications the
TSM Document Access Protocol.

00:43:11.890 --> 00:43:15.500
This will benefit your users,
give them access to a richer set of

00:43:15.500 --> 00:43:18.200
services to interact with your documents.

00:43:19.460 --> 00:43:21.960
And you'll notice the changes
in the headers on 64-bit,

00:43:22.030 --> 00:43:24.230
Carbon events for
resolution independence.

00:43:24.260 --> 00:43:25.580
And that's it.

00:43:25.640 --> 00:43:29.280
Next, I'd like to hand over
the talk to Lee Collins,

00:43:29.280 --> 00:43:31.990
Manager of OS Engineering in Asia.

00:43:31.990 --> 00:43:33.230
Thank you.

00:43:44.120 --> 00:43:46.000
Thank you, Michael.

00:43:46.100 --> 00:43:49.800
As Michael mentioned,
I'm the manager of the team

00:43:49.800 --> 00:43:55.600
that does the system software
engineering for our Asian products.

00:43:55.600 --> 00:43:58.950
That includes input methods for Chinese,
Korean, and other languages.

00:43:59.040 --> 00:44:04.290
Not only do we implement input methods,
but we also are designing new

00:44:04.290 --> 00:44:06.820
architectures to support them.

00:44:06.980 --> 00:44:12.030
I'll be talking about the Input
Method Kit as one of those today.

00:44:14.430 --> 00:44:17.570
So I think this part of the
section will be of particular

00:44:17.570 --> 00:44:20.710
interest to those of you,
like my team,

00:44:20.710 --> 00:44:26.810
who are developing input methods or are
thinking about developing them for OS X.

00:44:27.250 --> 00:44:29.860
I'll be talking about four
things that we're working on

00:44:29.890 --> 00:44:32.760
that will be of interest to you.

00:44:32.790 --> 00:44:37.410
The big one is the input method kit,
which is basically a new foundation-based

00:44:37.410 --> 00:44:40.740
framework for building input methods.

00:44:40.920 --> 00:44:46.010
Next, I'll talk to you about how you can
use the keyboard layout overrides that

00:44:46.010 --> 00:44:52.040
Michael talked about to enhance your
user experience and to eliminate a lot

00:44:52.050 --> 00:44:56.710
of code that you might have in your input
method now for displaying your keyboard

00:44:56.720 --> 00:44:59.450
layout and doing keyboard mapping.

00:44:59.570 --> 00:45:03.020
I'll talk briefly also about
data-driven input methods,

00:45:03.040 --> 00:45:07.310
which are possibly the easiest way
for you to deliver an input method,

00:45:07.310 --> 00:45:11.270
depending on how your input method is
structured and what it needs to do,

00:45:11.310 --> 00:45:15.490
and finally,
some changes in the way we're going

00:45:15.490 --> 00:45:19.000
to package and install input methods.

00:45:19.100 --> 00:45:21.320
So what's the Input Method Kit?

00:45:22.720 --> 00:45:27.530
You no doubt know that our current
way of building input methods was

00:45:27.530 --> 00:45:30.980
designed way back in the early 90s.

00:45:30.980 --> 00:45:34.080
It's been obvious to us for many
years that it's very painful

00:45:34.290 --> 00:45:35.940
to develop an input method.

00:45:35.940 --> 00:45:36.690
We do it all the time.

00:45:36.700 --> 00:45:40.510
We have a lot of code that we have
to maintain that is not really

00:45:40.510 --> 00:45:45.600
necessary because so much could
be shared across input methods.

00:45:45.960 --> 00:45:50.840
The Input Method Kit idea is to make
it simpler both for you and for us to

00:45:50.850 --> 00:45:53.120
develop and maintain input methods.

00:45:53.120 --> 00:45:56.800
It's a foundation-based API,
and we really think it's

00:45:56.910 --> 00:45:58.660
going to be a lot simpler.

00:45:58.660 --> 00:46:01.670
So, for example,
if you've tried to look at our sample

00:46:01.670 --> 00:46:06.060
code now for building an input method,
it's called the Basic Input Method.

00:46:06.060 --> 00:46:08.610
It's component manager-based.

00:46:08.610 --> 00:46:11.940
It requires at least 28 source files.

00:46:11.990 --> 00:46:15.940
We've reduced that in the
new Input Method Kit sample.

00:46:15.960 --> 00:46:18.690
to five source files.

00:46:19.300 --> 00:46:23.460
The Input Method Kit has a number
of nice architectural features,

00:46:23.520 --> 00:46:29.190
one of which is that the input
methods can now run as applications

00:46:29.190 --> 00:46:30.660
in their own address space.

00:46:30.660 --> 00:46:38.660
This has some advantages for security,
performance, and robustness.

00:46:38.660 --> 00:46:42.220
And in addition,
it has a big advantage for those of

00:46:42.220 --> 00:46:46.260
you who have input methods and are
thinking about porting to 64-bit.

00:46:46.260 --> 00:46:52.750
Because one of the drawbacks of
the Component Manager-based input

00:46:52.870 --> 00:46:59.240
methods is that they run in the same
space as does the client application.

00:46:59.260 --> 00:47:03.240
This means that you have to
recompile your input method to

00:47:03.240 --> 00:47:05.980
get it to run in a 64-bit client.

00:47:06.030 --> 00:47:09.970
With the Input Method Kit,
because the applications run

00:47:09.970 --> 00:47:14.940
in their own address space,
you can be running as 32-bit.

00:47:16.370 --> 00:47:19.770
Needless to say,
the Input Method Kit is fully integrated

00:47:19.770 --> 00:47:23.790
with the TSM so you get all of the
functionality that the TSM offers

00:47:23.810 --> 00:47:30.950
and it works with all applications,
Cocoa, and Carbon that support the TSM.

00:47:32.290 --> 00:47:35.410
The Input Method Kit is based
around a fairly simple and

00:47:35.410 --> 00:47:37.240
natural division of labor.

00:47:37.240 --> 00:47:40.550
Basically,
the Kit manages all of the UI and

00:47:40.570 --> 00:47:45.430
communications with client apps,
the candidate window, input method modes,

00:47:45.430 --> 00:47:45.740
etc.

00:47:45.740 --> 00:47:50.830
What you, the developers,
supply are the engine,

00:47:50.830 --> 00:47:54.020
the basic conversion engine.

00:47:54.440 --> 00:48:01.700
You also indicate how client input should
be treated through key bindings or,

00:48:01.700 --> 00:48:05.790
if you really need to go into details,
optional event handling.

00:48:06.200 --> 00:48:29.600
[Transcript missing]

00:48:31.900 --> 00:49:17.100
[Transcript missing]

00:49:17.670 --> 00:49:22.480
So all of these controllers will
share one candidate window object.

00:49:22.480 --> 00:49:24.610
Candidate windows are,
if you don't know what

00:49:24.610 --> 00:49:29.540
the technology is about,
it's a way to present optional choices

00:49:29.540 --> 00:49:32.460
to the user when there's ambiguous input.

00:49:32.560 --> 00:49:36.980
The controllers will share the candidate,
create one candidate,

00:49:36.980 --> 00:49:41.600
and bring it up whenever they want
to display the options to the user.

00:49:41.600 --> 00:49:44.440
The candidate then points
back to the server,

00:49:44.440 --> 00:49:47.480
which actually manages
the candidate object.

00:49:49.710 --> 00:49:51.580
So the most interesting class to you,
of course,

00:49:51.580 --> 00:49:54.070
will be the IMK Input Controller.

00:49:54.370 --> 00:49:56.000
This is the hub,
if you want to think about it.

00:49:56.000 --> 00:50:01.280
It takes input from
the client application

00:50:01.480 --> 00:50:05.780
passes it to the engine and then
passes it back into the application.

00:50:05.840 --> 00:50:08.240
This is where you'll
do most of your work.

00:50:13.000 --> 00:50:15.480
So when you're thinking about
how you're going to handle

00:50:15.630 --> 00:50:19.770
input from client application,
there are three basic approaches

00:50:19.770 --> 00:50:25.000
shown here in order of increasing
control but also complexity.

00:50:25.000 --> 00:50:29.920
You can choose to use key binding,
in which case you don't look

00:50:29.920 --> 00:50:36.000
directly at key codes or the
modifiers attached to the key codes.

00:50:36.000 --> 00:50:40.160
You can do this by implementing the
method inputText that only takes a string

00:50:40.300 --> 00:50:43.780
in a client and did command by selector.

00:50:44.690 --> 00:50:50.590
If you actually need to look at
individual key codes and modifiers,

00:50:50.700 --> 00:50:54.970
you take the second approach,
which is to implement input

00:50:54.970 --> 00:50:59.240
text that also takes the
modifiers and the key codes.

00:50:59.240 --> 00:51:09.430
Finally, if you need to look at an event
in all of its glorious detail,

00:51:09.430 --> 00:51:09.430
just implement handleEvents.

00:51:12.100 --> 00:51:15.380
Let's talk a little bit
about the candidate window.

00:51:15.380 --> 00:51:20.010
Candidate windows are a way of
presenting to the user different

00:51:20.010 --> 00:51:22.530
choices when you have ambiguous input.

00:51:22.640 --> 00:51:26.000
This is very common in Chinese, Korean,
and Japanese.

00:51:26.000 --> 00:51:32.380
For an example, within UniCode,
there are a number of characters that

00:51:32.380 --> 00:51:35.320
can be described as a kind of star.

00:51:35.320 --> 00:51:39.240
You might want to let your user
input the word "star" and give them

00:51:39.240 --> 00:51:42.000
choices for all of the star variants.

00:51:42.000 --> 00:51:45.210
To do this,
you would use a candidate window.

00:51:46.230 --> 00:51:49.330
When you're using one of the Input
Method Kit candidate windows,

00:51:49.340 --> 00:51:52.740
basically you supply the candidates.

00:51:52.740 --> 00:51:58.030
The IMK candidates object will handle
selection of the candidate by the user,

00:51:58.090 --> 00:52:01.960
let you know which candidates
have been selected,

00:52:01.960 --> 00:52:04.140
and all of the other stuff.

00:52:05.150 --> 00:52:08.240
For Leopard,
you'll be able to choose up to three

00:52:08.250 --> 00:52:10.900
different flavors of window layout.

00:52:10.900 --> 00:52:16.120
The grid view shown up here in the top,
a vertical view in the middle,

00:52:16.120 --> 00:52:18.730
and finally a horizontal view.

00:52:21.370 --> 00:52:22.860
So if you want to use
the candidate window,

00:52:22.860 --> 00:52:25.260
this is what you would do.

00:52:25.260 --> 00:52:28.660
Inside of your controller class,
you implement two methods.

00:52:28.660 --> 00:52:31.570
The first method, candidates,
is basically a way of feeding

00:52:31.580 --> 00:52:34.040
the candidates to the window.

00:52:34.040 --> 00:52:37.240
The simplest implementation
would just be to pass back an

00:52:37.240 --> 00:52:39.090
array of all your candidates.

00:52:40.840 --> 00:52:43.980
The second method is Candidate Selected.

00:52:43.980 --> 00:52:47.050
This is called whenever
the user has gone through,

00:52:47.050 --> 00:52:50.340
looked at the list of candidates
in the candidate window

00:52:50.340 --> 00:52:52.080
and decided to choose one.

00:52:52.080 --> 00:52:55.410
Something you might do in
Candidate Selected is confirm

00:52:55.410 --> 00:52:58.960
the active input area,
maybe update the state of your

00:52:58.960 --> 00:53:03.720
input method to rearrange the
frequency with which you display

00:53:03.830 --> 00:53:06.730
characters in the candidate window.

00:53:08.030 --> 00:53:13.710
Then you create the candidate
object with initWithServer.

00:53:13.710 --> 00:53:18.840
You do this with the server
because the server actually,

00:53:18.840 --> 00:53:18.840
your IMK,

00:53:19.710 --> 00:53:24.640
IMK Server actually is what's going to
manage the candidate window for you.

00:53:24.640 --> 00:53:27.670
And then you also pass in the
kind of candidate window you want,

00:53:27.670 --> 00:53:30.730
whether you want vertical, horizontal,
or grid.

00:53:31.310 --> 00:53:33.730
Then whenever you want to present
the candidates to the user,

00:53:33.740 --> 00:53:37.940
you call update and show candidates.

00:53:37.940 --> 00:53:41.930
Finally,
remember that your candidate selected

00:53:42.020 --> 00:53:43.770
method will be called whenever

00:53:44.360 --> 00:53:48.850
A candidate has been chosen,
so make sure that you respond to that

00:53:48.910 --> 00:53:52.930
to do whatever you need to update
the state of your input method.

00:53:55.360 --> 00:53:57.850
Let's talk a little bit about modes.

00:53:58.000 --> 00:54:01.440
Michael and Peter both mentioned modes.

00:54:01.440 --> 00:54:05.120
Modes are basically a way
of packaging related input

00:54:05.120 --> 00:54:07.360
sources in one input method.

00:54:07.360 --> 00:54:09.170
You can think,
I mean a mode is basically,

00:54:09.170 --> 00:54:13.960
could be a standalone input method,
but many of the so-called input methods

00:54:14.040 --> 00:54:16.640
will actually package sub-input methods.

00:54:16.660 --> 00:54:22.870
For example, Japanese contains Hiragana,
Katakana, and Romaji.

00:54:23.220 --> 00:54:30.120
Previously, before OS X.3 Panther,
each of our input methods had

00:54:30.120 --> 00:54:36.600
very elaborate machinery for
managing these input method modes.

00:54:36.930 --> 00:54:41.880
Then we observed that we could
actually simplify this and have

00:54:41.880 --> 00:54:46.100
a common way of managing them,
and we came up with this

00:54:46.200 --> 00:54:50.180
whole idea of modes,
which we did make public in Panther.

00:54:50.180 --> 00:54:55.520
Basically,
it's all driven through data in a plist.

00:54:55.940 --> 00:55:00.900
The IMK Kit makes this
even easier for you to use.

00:55:00.900 --> 00:55:05.290
To use modes within the kit,
first of all, you just provide

00:55:05.290 --> 00:55:09.050
information in the plist,
which we've previously documented

00:55:09.190 --> 00:55:14.010
in Tech Note 2128 in the
Component Input Mode Dictionary.

00:55:14.720 --> 00:55:17.970
And then the kit will tell you each
time that your mode has been selected

00:55:18.000 --> 00:55:26.410
by sending the message "set value."
"Set value" sends a key and a value.

00:55:26.420 --> 00:55:30.310
The key in this case would be a key
telling you that your mode has been

00:55:30.350 --> 00:55:32.600
selected with the name of the mode.

00:55:32.600 --> 00:55:38.210
So respond to this to do whatever
you need to do to switch the mode.

00:55:38.540 --> 00:55:41.020
And that's pretty much all you
need to do to add input method

00:55:41.090 --> 00:55:43.930
mode support using the IMK Kit.

00:55:45.880 --> 00:55:51.460
Let's look at some things you add
to your plist when you're building

00:55:51.630 --> 00:55:53.990
an IMK Kit-based input method.

00:55:54.680 --> 00:56:00.060
I just mentioned the component mode
dict described in Tech Note 2128.

00:56:00.140 --> 00:56:02.340
You do that if you're a
mode-based input method,

00:56:02.340 --> 00:56:04.190
and many are.

00:56:05.030 --> 00:56:08.660
Input methods are applications,
but they need to run in the background.

00:56:08.720 --> 00:56:12.590
So set a key and value LS background
only indicating that they

00:56:12.590 --> 00:56:14.790
are background applications.

00:56:15.250 --> 00:56:18.080
Now the Kit needs to identify
your controller class,

00:56:18.160 --> 00:56:23.640
so there's a key-value pair that
lets you identify that for the Kit.

00:56:23.740 --> 00:56:27.060
Input Method Server Controller Class.

00:56:27.060 --> 00:56:32.980
This lets the Kit go into your bundle,
find your controller object,

00:56:32.980 --> 00:56:38.400
and instantiate it whenever
there needs to be a connection

00:56:38.400 --> 00:56:41.330
between the client application
and your Input Method application.

00:56:41.580 --> 00:56:44.910
Finally, you need to add a string that
indicates the connection name.

00:56:44.930 --> 00:56:50.070
This is how the
IMK Kit talks to your server.

00:56:52.680 --> 00:56:57.310
Now let's talk briefly about how
you can improve your input method

00:56:57.310 --> 00:56:59.700
using keyboard layout overrides.

00:57:00.120 --> 00:57:05.180
The overrides basically let
you associate a keyboard layout

00:57:05.270 --> 00:57:08.510
with any input method mode.

00:57:09.140 --> 00:57:14.110
The keyboard layouts, of course,
are defined as XML and

00:57:14.110 --> 00:57:19.620
then rendered into Uchars,
as was previously discussed.

00:57:19.720 --> 00:57:24.240
The beauty of doing it
this way is twofold.

00:57:24.240 --> 00:57:29.580
You don't have to have elaborate mapping
tables inside of your input method to

00:57:29.580 --> 00:57:34.460
map from virtual keys to the codes that
you take as input in your input method.

00:57:35.580 --> 00:57:40.160
Secondly, you don't have to have a
lot of machinery to display

00:57:40.900 --> 00:57:45.800
Before we started using
the layout overrides,

00:57:45.800 --> 00:57:50.620
all of the Chinese input methods,
for example, had bitmaps of the layouts

00:57:50.620 --> 00:57:55.790
and they had key to character
mapping tables built into them.

00:57:55.790 --> 00:58:01.410
Once we started using the layouts,
we were able to rip all of that

00:58:01.430 --> 00:58:07.590
out and just specify an XML-based
keyboard layout and let the keyboard

00:58:07.590 --> 00:58:07.800
viewer do all the drawing for us.

00:58:10.510 --> 00:58:14.040
So this is how you would use
the overrides with the IAM Kit.

00:58:14.040 --> 00:58:17.650
I previously mentioned that one of
the methods you're going to want

00:58:17.650 --> 00:58:19.940
to implement is called setValue.

00:58:19.960 --> 00:58:24.970
This will be called whenever
the user selects one of your

00:58:24.970 --> 00:58:31.740
modes in the Text Input menu or
using Command Space or however.

00:58:31.740 --> 00:58:31.740
In this case,

00:58:32.350 --> 00:58:37.440
Set value will contain, as the value,
the name of your mode.

00:58:37.440 --> 00:58:42.320
In the example shown here,
we assume that the name of the mode

00:58:42.340 --> 00:58:43.950
is the same as the keyboard layout.

00:58:43.960 --> 00:58:45.280
It doesn't have to be.

00:58:45.300 --> 00:58:51.000
The keyboard layout is going to be stored
inside of your input method bundle.

00:58:52.300 --> 00:58:57.740
If you call override
keyboard with keyboard named,

00:58:57.740 --> 00:58:59.680
the Input Method Kit will
then go into your bundle,

00:58:59.680 --> 00:59:02.880
find the layout,
set it as the current keyboard,

00:59:02.880 --> 00:59:05.320
and then you're off and running.

00:59:08.900 --> 00:59:12.540
Now let's move briefly to
data-driven input methods.

00:59:12.540 --> 00:59:17.890
If your input method can be
described as a very simple mapping

00:59:17.890 --> 00:59:22.910
of one string to other strings,
including candidates for

00:59:22.910 --> 00:59:26.890
strings that are ambiguous,
then you might want to actually consider

00:59:26.890 --> 00:59:29.600
using the data-driven input methods.

00:59:30.320 --> 00:59:33.440
It's basically a text
file with mapping rules.

00:59:33.440 --> 00:59:37.310
And for Leopard, we plan on using two
semi-standard formats.

00:59:37.330 --> 00:59:40.970
One, the .im plugin is the one we've
been using in our Chinese input

00:59:40.970 --> 00:59:43.180
methods for a number of releases now.

00:59:43.180 --> 00:59:50.270
And .cin is used by an open source
project called Open Vanilla.

00:59:50.280 --> 00:59:54.620
These are basically just text
files with very simple mapping.

00:59:54.880 --> 00:59:58.750
You supply the text file and register it,
and the system will

00:59:58.750 --> 01:00:04.190
handle everything else:
input, a display of your input

01:00:04.750 --> 01:00:11.110
method in the text input menu,
candidate window, etc.

01:00:11.490 --> 01:00:14.220
Previously,
these kind of data-driven input

01:00:14.220 --> 01:00:17.710
methods have been used for a
lot of different languages,

01:00:17.710 --> 01:00:20.600
mostly Chinese languages like Cantonese.

01:00:20.600 --> 01:00:22.400
You see an example here.

01:00:22.500 --> 01:00:28.860
You take the string "DEU6" and map it
to several Chinese candidate characters,

01:00:28.950 --> 01:00:31.690
but it could also be used for English.

01:00:31.910 --> 01:00:34.880
Take "Happy Face" and generate
all the Unicode characters

01:00:34.950 --> 01:00:36.550
that look like a happy face.

01:00:39.180 --> 01:00:42.510
So finally,
I'd like to talk briefly about

01:00:42.590 --> 01:00:46.840
changes in how we're going to
deliver input methods in Leopard.

01:00:47.040 --> 01:00:50.610
Previously, input methods were all based
on the Component Manager,

01:00:50.730 --> 01:00:57.360
so they resided in the components
folder in System Library,

01:00:57.380 --> 01:00:58.400
etc.

01:00:58.400 --> 01:01:05.080
The new input methods are going to be
stored in an input methods folder that

01:01:05.080 --> 01:01:11.310
will be supported for three domains:
System, Host, and User.

01:01:12.600 --> 01:01:16.490
When you're going to
install an input method,

01:01:16.490 --> 01:01:21.480
you can now call a new function
called TISRegisterInputSource that

01:01:21.480 --> 01:01:26.460
will register it as you're installing
so you don't have to log out and

01:01:26.500 --> 01:01:29.330
log back in for it to take effect.

01:01:29.860 --> 01:01:36.640
I think this will be useful for those
of you writing input method installers.

01:01:37.150 --> 01:01:41.870
And finally, just a note,
your keyboard layouts need to

01:01:41.870 --> 01:01:45.240
be installed in your bundle.

01:01:45.440 --> 01:01:48.410
This is actually mostly a
note for internal developers,

01:01:48.490 --> 01:01:54.900
but the basic message is if you
don't install them in your bundle,

01:01:54.900 --> 01:01:58.690
then you have to do a little bit
more elaborate searching in the

01:01:58.710 --> 01:02:02.560
system using the new TIS API to
find your keyboard layouts.

01:02:02.600 --> 01:02:06.450
So the easiest thing is just
keep them in the bundle.

01:02:09.990 --> 01:02:13.100
Now I'd like to go to a brief demo.

01:02:13.130 --> 01:02:20.130
So my team has not only been designing
and developing the Input Method Kit,

01:02:20.400 --> 01:02:23.830
But at the same time,
we've been reimplementing all of

01:02:23.830 --> 01:02:26.140
our input methods using the kit.

01:02:26.140 --> 01:02:28.940
Our philosophy is that if
the kit doesn't work for us,

01:02:28.940 --> 01:02:31.300
it's certainly not going to work for you.

01:02:31.300 --> 01:02:35.780
It's got to be good enough for
us before we send it to you.

01:02:45.150 --> 01:02:48.940
So, as of this point,
we have two of our input methods are

01:02:48.950 --> 01:02:53.810
running inside of the Input Method Kit,
Tamil and Korean.

01:02:53.910 --> 01:02:58.580
They're both somewhat simpler than
the elaborate Chinese and Japanese,

01:02:58.610 --> 01:03:00.710
but those are going underway.

01:03:01.130 --> 01:03:01.940
So let's take a look.

01:03:01.940 --> 01:03:06.410
I'll also show you the advantage of
using the keyboard layout overrides.

01:03:06.780 --> 01:03:12.070
So to see what we're doing,
let's bring up the keyboard viewer.

01:03:16.520 --> 01:03:18.710
So you probably-- I hope you're
all familiar with the Keyboard

01:03:18.710 --> 01:03:19.730
Viewer and what it does.

01:03:19.770 --> 01:03:20.230
Let's see.

01:03:20.240 --> 01:03:23.770
Type some English.

01:03:23.780 --> 01:03:26.730
You can actually type directly
from the Keyboard Viewer.

01:03:26.770 --> 01:03:29.810
Probably not very
useful outside of demos.

01:03:32.730 --> 01:03:34.700
Now we pick Korean.

01:03:34.700 --> 01:03:36.700
Oops.

01:03:36.700 --> 01:03:38.700
Well, let's see.

01:03:38.800 --> 01:03:41.700
There is a bug.

01:03:41.700 --> 01:03:44.900
It was supposed to update.

01:03:44.900 --> 01:03:50.100
And the demo gods were
not going with us today.

01:03:50.100 --> 01:03:54.890
Well, let's see.

01:03:54.910 --> 01:03:56.890
Let's try that again.

01:04:07.620 --> 01:04:11.040
Well, like I said,
I just finished building this last night,

01:04:11.040 --> 01:04:13.640
so I'm not going to be
able to demo the overrides,

01:04:13.640 --> 01:04:17.390
but let's see if I can demo Korean.

01:04:19.210 --> 01:04:21.770
Ah, I got something there.

01:04:21.780 --> 01:04:24.420
OK, there.

01:04:24.450 --> 01:04:28.260
So now what I've done is I've
specified a keyboard layout

01:04:28.280 --> 01:04:29.700
override inside my bundle.

01:04:29.700 --> 01:04:34.530
So when I selected one of
those two Korean modes,

01:04:34.750 --> 01:04:37.270
the keyboard viewer went in and--

01:04:37.500 --> 01:04:43.590
and updated using the keyboard
layout that I specified.

01:04:43.590 --> 01:04:47.290
So this has a great advantage so
you can actually see the characters

01:04:47.330 --> 01:04:50.800
in the keyboard layout if you're
not familiar with this layout.

01:04:50.930 --> 01:04:55.130
This is a Romanized layout,
but not everybody starting to type

01:04:55.130 --> 01:04:57.490
Korean may be familiar with it.

01:05:00.620 --> 01:05:02.480
So I can type some Korean here.

01:05:02.480 --> 01:05:10.320
And this is the Input
Method Kit-based Korean input method.

01:05:11.210 --> 01:05:13.200
So all of this is being handled for me.

01:05:13.200 --> 01:05:18.500
The only thing I'm really doing is
taking the Hangul input off the keyboard,

01:05:18.740 --> 01:05:22.090
converting it internally,
and sending it back to the kit.

01:05:22.200 --> 01:05:25.700
And the kit does everything,
all the connection with the document,

01:05:25.700 --> 01:05:27.960
et cetera, to update the active area.

01:05:32.780 --> 01:05:34.740
And even provides an input method window.

01:05:34.740 --> 01:05:37.830
I can select.

01:05:37.900 --> 01:05:40.950
Notice that as I select
the different candidates,

01:05:40.950 --> 01:05:42.840
they're being updated
inside the document.

01:05:42.840 --> 01:05:46.700
That's just a couple lines
of code to do all this.

01:05:46.700 --> 01:05:53.360
And that's it.

01:06:06.490 --> 01:06:12.200
Okay, so I'd like to end my part of the
session with a few recommendations.

01:06:12.200 --> 01:06:15.000
Use the Input Method Kit framework.

01:06:15.000 --> 01:06:15.860
We think it's really good.

01:06:15.860 --> 01:06:16.840
We're using it.

01:06:16.840 --> 01:06:20.560
We encourage you to use it also.

01:06:20.560 --> 01:06:23.100
Think about keyboard layout overrides.

01:06:23.100 --> 01:06:25.690
We found them very useful in practice.

01:06:25.830 --> 01:06:29.890
As I said,
we were able to rip out a lot of

01:06:29.950 --> 01:06:32.830
code and just let the keyboard
viewer do a lot of work for us.

01:06:33.170 --> 01:06:37.680
And finally,
if your problem is simple enough,

01:06:37.720 --> 01:06:39.860
just consider data-driven input methods.

01:06:42.920 --> 01:06:48.430
Now for those of you who are willing
to spend a little bit extra effort

01:06:48.470 --> 01:06:54.720
and want to have a great opportunity
to sit down with Apple engineers and

01:06:54.890 --> 01:06:58.660
bring your code and start working
on porting the Input Method Kit,

01:06:58.660 --> 01:07:04.370
your input method to
the Input Method Kit,

01:07:04.370 --> 01:07:07.150
we're doing a kitchen in China in
the first week of September.

01:07:07.550 --> 01:07:10.920
If you're interested in that,
there are some contacts here.

01:07:10.920 --> 01:07:12.300
You can also try contacting me.

01:07:12.300 --> 01:07:14.690
I'll be around tomorrow
at the International Lab.

01:07:18.810 --> 01:07:21.940
Some more information.

01:07:22.090 --> 01:07:25.580
I have to apologize
about the sample code.

01:07:25.690 --> 01:07:31.170
The sample code contains
some calls to ICU,

01:07:31.170 --> 01:07:35.700
the International Components for UniCode,
which is an open source.

01:07:35.700 --> 01:07:39.700
We make wide use of it in the system,
but it's not public.

01:07:39.700 --> 01:07:48.130
And it relies on internal headers that
you don't have access to normally.

01:07:48.380 --> 01:07:52.240
So if you actually want to get
that sample code to compile,

01:07:52.240 --> 01:07:56.820
I suggest that you comment out the
few lines that actually use ICU.

01:07:56.950 --> 01:07:59.140
It's not essential to the sample.

01:07:59.140 --> 01:08:02.300
It was just there as illustration.

01:08:02.300 --> 01:08:04.360
You do that and the
sample should work fine.

01:08:04.360 --> 01:08:07.560
Modulo the bugs that are in the README.

01:08:08.810 --> 01:08:12.630
There will be a lab tomorrow if
you want to come talk to me more

01:08:12.630 --> 01:08:15.750
or other people who are here,
Peter, Michael,

01:08:15.780 --> 01:08:17.700
who are here giving the presentation.
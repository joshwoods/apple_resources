WEBVTT

00:00:10.020 --> 00:00:10.760
Hi, good afternoon.

00:00:10.760 --> 00:00:14.120
Welcome to session 415,
What's New In The File System?

00:00:14.130 --> 00:00:15.760
I'm Deric Horn,
the Application Frameworks

00:00:15.760 --> 00:00:18.540
and File Systems Evangelist,
and I'll be joined a little

00:00:18.540 --> 00:00:22.280
bit later by Dominic Giampaolo,
File Systems Engineer.

00:00:22.870 --> 00:00:25.060
So today I'd like to start
off by going over a little

00:00:25.160 --> 00:00:27.810
recap of some of the important
features we introduced in Tiger.

00:00:28.030 --> 00:00:31.800
Those include the copy engine,
extended attributes,

00:00:31.850 --> 00:00:33.800
introduction of access control lists.

00:00:33.800 --> 00:00:37.020
Then we're going to talk about some of
the really important new features that

00:00:37.020 --> 00:00:38.760
we're introducing today in Leopard.

00:00:38.840 --> 00:00:41.800
Things like ""safe save",
move to trash" functionality.

00:00:41.940 --> 00:00:44.800
And then Dominic's going to
come up on stage and talk about

00:00:44.800 --> 00:00:46.780
filesystem event notification.

00:00:46.860 --> 00:00:48.980
This is a very heavily
requested feature from you,

00:00:48.980 --> 00:00:51.800
the developers,
and it's really a very elegant API.

00:00:51.800 --> 00:00:55.500
And we'll have plenty of
time for Q&A afterwards.

00:00:56.140 --> 00:01:00.760
So I'd like to start off with a little
filesystems architecture diagram.

00:01:00.800 --> 00:01:03.760
Here on the upper left,
we see a typical Cocoa application.

00:01:03.800 --> 00:01:07.000
Cocoa applications being object-oriented
call down into the NSFileManager.

00:01:07.000 --> 00:01:11.000
And NSFileManager offers
object-oriented APIs.

00:01:11.070 --> 00:01:15.780
And in turn, the NSFileManager calls down
directly down to the BSD layer,

00:01:16.010 --> 00:01:19.080
and also down to the
Core Services File Manager.

00:01:19.100 --> 00:01:21.460
I just want to take a minute and
kind of talk a little bit about

00:01:21.470 --> 00:01:23.100
the Core Services File Manager.

00:01:23.130 --> 00:01:27.260
The Core Services File Manager is what
we used to call the Carbon File Manager.

00:01:27.460 --> 00:01:29.360
And it contains those
familiar APIs to us,

00:01:29.420 --> 00:01:33.710
those FSRef-based APIs,
the old FSSpec-based APIs,

00:01:33.710 --> 00:01:36.410
the APIs located in files.h.

00:01:36.620 --> 00:01:41.070
So the core services file manager
offers an abstraction layer above

00:01:41.190 --> 00:01:47.170
the BSD APIs and the volume format,
like discrepancies underneath, right?

00:01:47.230 --> 00:01:50.300
How resource forks are stored,
how extended attributes are stored.

00:01:50.310 --> 00:01:51.410
So we don't have to bother with that.

00:01:51.460 --> 00:01:53.980
We use one familiar API.

00:01:54.080 --> 00:01:58.060
And it's really a thin layer
right above the BSD APIs,

00:01:58.060 --> 00:02:00.900
actually located in the
Carbon Core framework.

00:02:00.960 --> 00:02:03.260
So obviously,
we have Carbon applications,

00:02:03.340 --> 00:02:05.500
which call down directly to
the core services file manager.

00:02:06.880 --> 00:02:09.440
And then on the right hand side,
command utilities.

00:02:09.550 --> 00:02:13.800
Typical command line utilities will
call down directly down to the BSD APIs.

00:02:13.800 --> 00:02:16.120
But we often find that command
line utilities also like to take

00:02:16.120 --> 00:02:19.150
advantage of the abstraction that the
core services file manager offers.

00:02:19.280 --> 00:02:22.600
So they also call down into
the core services file manager.

00:02:25.220 --> 00:02:27.520
So I've got a long history
with the filesystem.

00:02:27.570 --> 00:02:30.810
I started out on the development side
back in the HFS+ days and moved over

00:02:30.810 --> 00:02:33.360
into the filesystem on the Carbon,
and then moved over to

00:02:33.360 --> 00:02:35.700
developer relations where I got
to work with a lot of you.

00:02:35.710 --> 00:02:38.470
And by far,
I'd say the most requested feature

00:02:38.880 --> 00:02:41.210
from you developers has been
to give me access to the same

00:02:41.210 --> 00:02:42.770
copy engine that the Finder uses.

00:02:42.890 --> 00:02:47.050
Well, in Tiger we introduced
the FSCopyObject API.

00:02:47.190 --> 00:02:50.590
This is a high performance
API which is tuned for performance

00:02:50.600 --> 00:02:52.450
across all volume formats.

00:02:52.550 --> 00:02:55.910
And it's the same copy
engine that the Finder uses.

00:02:56.900 --> 00:03:00.330
During its copy, it manages copying all
the metadata for you,

00:03:00.330 --> 00:03:04.140
the data fork, resource fork,
extended attributes, and so forth.

00:03:04.180 --> 00:03:08.470
And it comes in those four
familiar sets of APIs,

00:03:08.470 --> 00:03:13.260
and those are the FSRef-based,
both synchronous and asynchronous APIs,

00:03:13.270 --> 00:03:16.160
as well as the path-based
synchronous and asynchronous APIs.

00:03:16.190 --> 00:03:20.440
So we have the FSCopyObjectSynchronous
for the FSRef-based synchronous,

00:03:20.440 --> 00:03:25.760
versus the FSPathCopyObjectAsync,
path-based asynchronous APIs.

00:03:28.220 --> 00:03:32.010
So here's a little snippet of how to
use the FSPath Copy Object Sync API,

00:03:32.040 --> 00:03:36.620
and underneath it, its counterpart,
the FSPath Move Object Sync API.

00:03:36.620 --> 00:03:39.710
I'm not going to go into the code,
but periodically you'll see these yellow

00:03:39.710 --> 00:03:41.080
boxes at the bottom of the slides.

00:03:41.100 --> 00:03:43.000
And that will detail where
you can find examples.

00:03:43.000 --> 00:03:45.940
So if you look in the
WWDC attendees site,

00:03:45.940 --> 00:03:49.260
and the area associated with session 415,
you should find a sample

00:03:49.260 --> 00:03:50.900
called FS file operation.

00:03:51.070 --> 00:03:55.780
And this is going to have details of the
implementation of the copy object APIs.

00:03:58.520 --> 00:04:00.790
So, extended attributes.

00:04:00.810 --> 00:04:03.560
Extended attributes are really
a great way of associating some

00:04:03.560 --> 00:04:05.500
metadata with any file or directory.

00:04:05.500 --> 00:04:07.740
So if you want to leave a
little breadcrumb with any file,

00:04:07.740 --> 00:04:10.300
whether you own it or not,
and just attach it to a file,

00:04:10.310 --> 00:04:12.500
you can do this with extended attributes.

00:04:12.500 --> 00:04:16.970
It's supported across all volume formats,
and we typically recommend that you

00:04:16.970 --> 00:04:19.500
use the reverse DNS name convention.

00:04:19.610 --> 00:04:21.750
So if you were to look
at your filesystem today,

00:04:21.880 --> 00:04:26.510
you'd notice a lot of files have the
com.apple.finderinfo extended attribute,

00:04:26.570 --> 00:04:27.500
and that's going to contain
just what you'd expect.

00:04:27.500 --> 00:04:30.840
Things like the type, creator,
maybe label information that

00:04:30.840 --> 00:04:32.500
the finder is going to save.

00:04:33.610 --> 00:04:37.350
I also want to mention the
"ctime" that you get back from

00:04:37.350 --> 00:04:40.050
"stat". When you "stat" a file,
it will return back the

00:04:40.050 --> 00:04:42.430
"ctime". I just want to clarify
a little bit what this is.

00:04:42.650 --> 00:04:44.580
This actually represents
the status change time.

00:04:44.640 --> 00:04:47.170
So the last time you change
any attribute on the file,

00:04:47.170 --> 00:04:48.580
the "ctime" is updated.

00:04:49.600 --> 00:04:52.680
So for instance,
if you're writing a backup application,

00:04:52.680 --> 00:04:56.920
you might want to compare the
"content_mod_date" to the "ctime" to see

00:04:56.920 --> 00:05:01.600
if potentially you don't have to actually
backup the actual contents of the file,

00:05:01.600 --> 00:05:03.600
the actual data portion of the file.

00:05:03.600 --> 00:05:06.040
You may just be sufficient
in backing up the attributes,

00:05:06.160 --> 00:05:08.920
extended attributes,
and metadata supported with that file.

00:05:09.380 --> 00:05:13.000
But you should be aware of the current
limitations of extended attributes.

00:05:13.040 --> 00:05:17.320
So in general, extended attributes are
going to be under 4K.

00:05:17.510 --> 00:05:21.180
I believe on HFS+ volumes,
it's 3083 bytes.

00:05:21.180 --> 00:05:24.490
I think that's been drilled into me now.

00:05:24.650 --> 00:05:27.500
It's set up so that you're
going to read an entire extended

00:05:27.620 --> 00:05:29.320
attribute in one fell swoop.

00:05:29.320 --> 00:05:30.840
It's not a stream-based call.

00:05:30.940 --> 00:05:34.820
You're going to go ahead and allocate a
buffer and read it all in at one time.

00:05:35.070 --> 00:05:37.150
And likewise,
when you write an extended attribute,

00:05:37.170 --> 00:05:38.440
you write it all out at once.

00:05:38.500 --> 00:05:40.600
Now,
I said this is kind of a generalization.

00:05:40.670 --> 00:05:43.120
The one exception is the resource fork.

00:05:43.240 --> 00:05:45.540
So the resource fork,
you can access through

00:05:45.770 --> 00:05:49.140
extended attributes,
and at this time, you can access it kind

00:05:49.140 --> 00:05:50.590
of in a stream-based API.

00:05:50.690 --> 00:05:53.670
What I really mean by that is
you can set the file position to

00:05:53.670 --> 00:05:57.430
potentially halfway through the
resource fork and continue reading.

00:05:59.690 --> 00:06:02.790
Whether or not you deal with
extended attributes directly,

00:06:02.910 --> 00:06:06.260
you should always be mindful of them.

00:06:06.260 --> 00:06:09.500
Whether you're writing an FTP client,
an archiver, or so forth,

00:06:09.910 --> 00:06:13.600
there are always three rules
that you have to be aware of.

00:06:13.600 --> 00:06:16.190
And that is to be mindful
of the data of the file,

00:06:16.350 --> 00:06:19.840
extended attributes of the file,
and security information.

00:06:19.840 --> 00:06:23.720
So sometimes I wish all Apple engineers
were mindful of these three rules.

00:06:26.230 --> 00:06:29.020
So let's take a deeper look at the APIs.

00:06:29.040 --> 00:06:32.640
The APIs to access extended
attributes are the get-x-addr,

00:06:32.640 --> 00:06:36.530
set-x-addr, list-x-addr,
and remove-x-addr APIs.

00:06:36.940 --> 00:06:38.750
These are all BSD-level APIs.

00:06:39.030 --> 00:06:40.930
Really shouldn't matter
whether you're Carbon,

00:06:40.930 --> 00:06:41.150
Cocoa.

00:06:41.290 --> 00:06:44.180
You can still call BSD APIs directly.

00:06:44.740 --> 00:06:49.840
The method for actually getting the size
of an extended attribute is quite easy.

00:06:50.030 --> 00:06:54.030
We'll use the Get XAddr API and
specify null for our buffer,

00:06:54.120 --> 00:06:57.140
at which time it will return back
the size of the extended attribute.

00:06:57.210 --> 00:06:59.330
You can then allocate your
buffer to be that size,

00:06:59.540 --> 00:07:03.990
call XAddr again, passing in that buffer,
and read in the entire buffer.

00:07:04.210 --> 00:07:07.490
Again, for samples of how to use
the extended attribute APIs,

00:07:07.490 --> 00:07:10.690
we have the filesystem_example sample.

00:07:12.240 --> 00:07:14.780
So, access control lists.

00:07:14.800 --> 00:07:17.480
So typical Unix permissions
are what we would call,

00:07:17.600 --> 00:07:21.070
or what we all know of as, owner group,
other, read, write, and execute,

00:07:21.150 --> 00:07:23.830
or as I call them, user group world,
read, write, and execute.

00:07:24.000 --> 00:07:24.570
Very limited.

00:07:24.740 --> 00:07:26.670
We're not allowed to
create more than 16 groups.

00:07:26.780 --> 00:07:28.440
We can't nest groups.

00:07:28.480 --> 00:07:32.150
So in Tiger,
we introduced access control lists,

00:07:32.150 --> 00:07:32.900
or ACLs.

00:07:33.060 --> 00:07:38.030
They provide a much finer granularity
security permissions for a file.

00:07:38.170 --> 00:07:41.320
So for instance,
we can either allow or deny a

00:07:41.410 --> 00:07:44.770
user or group to append to a file.

00:07:44.990 --> 00:07:49.520
We can either allow or deny someone
to actually read the ACL information

00:07:49.520 --> 00:07:51.290
on this file or directory.

00:07:53.150 --> 00:07:56.130
So access control lists
were introduced in Tiger,

00:07:56.130 --> 00:07:58.540
but we had them turned off by default.

00:07:58.540 --> 00:08:01.880
Now in Leopard,
we're turning them on by default.

00:08:01.880 --> 00:08:05.960
There's a few tools that you can use to
access your access control information.

00:08:05.960 --> 00:08:08.940
So a typical tool, ls,
if you specify the "-e" option,

00:08:08.940 --> 00:08:12.330
it'll print out all the extended
attribute information associated

00:08:12.430 --> 00:08:13.890
with that file or directory.

00:08:14.120 --> 00:08:18.120
Likewise,
ChangeMod with the "+A" option is a

00:08:18.120 --> 00:08:25.320
great way of either allowing or denying
users access control list information.

00:08:25.740 --> 00:08:27.980
You should also be aware if
you're writing your application

00:08:27.980 --> 00:08:31.190
now and you want to make use of
access control lists on Tiger,

00:08:31.190 --> 00:08:34.670
for instance,
you can use the FS ACL control

00:08:34.670 --> 00:08:38.530
tool to turn on or off access
control lists for that volume.

00:08:38.670 --> 00:08:40.960
So as I said in Tiger,
they're turned off by default.

00:08:41.220 --> 00:08:46.710
Use the FS ACL control tool and you can
turn them back on on that Tiger volume.

00:08:47.360 --> 00:08:50.640
Again, these are BSD-level APIs,
and I wanted to mention that they're

00:08:50.730 --> 00:08:54.000
used heavily in the .Mac servers.

00:08:54.000 --> 00:08:57.790
So this was really a big push to
control access information and

00:08:57.790 --> 00:09:02.140
permissions for users and groups on
the .Mac servers that we all use.

00:09:02.640 --> 00:09:05.040
And now in Leopard,
we have full finder integration,

00:09:05.040 --> 00:09:07.150
so when you do a "Get Info
in a File", you're going to

00:09:07.160 --> 00:09:09.600
see all the ACL information,
more detailed ACL information.

00:09:09.600 --> 00:09:15.590
Again, you can find samples of this in
the "File System Examples" sample.

00:09:16.540 --> 00:09:19.710
Okay, now on to some of the fantastic
new features that we're

00:09:19.710 --> 00:09:21.540
introducing today for Leopard.

00:09:21.570 --> 00:09:24.410
First one, ""safe save". We're all pretty
familiar with how this works,

00:09:24.410 --> 00:09:24.810
right?

00:09:24.820 --> 00:09:27.710
You have your original file,
you write out a new file,

00:09:27.920 --> 00:09:30.080
once it's coherent,
we're going to want to replace

00:09:30.140 --> 00:09:31.820
the original with our new file.

00:09:31.820 --> 00:09:34.390
Up until now,
I would say it's been almost a burden

00:09:34.390 --> 00:09:37.280
to implement ""safe save"" for yourself,
based on all the

00:09:37.280 --> 00:09:39.420
different volume formats,
and the details of the

00:09:39.420 --> 00:09:41.880
underlying formats,
and which options they support

00:09:41.880 --> 00:09:43.200
and which ones they don't.

00:09:46.500 --> 00:09:48.980
We're going to talk about
the ""safe save"" API,

00:09:48.980 --> 00:09:51.310
replace object,
available through the core

00:09:51.310 --> 00:09:53.120
services API through files.h.

00:09:53.260 --> 00:09:56.020
It's supported on all file systems,
and it's largely based

00:09:56.020 --> 00:09:57.650
on the renamed semantics.

00:09:57.650 --> 00:10:00.910
It's designed to properly
preserve all your metadata.

00:10:02.500 --> 00:10:05.350
and by and large, in the past,
maybe on Mac OS 9,

00:10:05.350 --> 00:10:07.740
we used something like FSExchangeObjects.

00:10:07.740 --> 00:10:09.980
And this was a great way to do safe save.

00:10:10.120 --> 00:10:13.880
But the big problem on Mac OS X is
that this was really limiting.

00:10:14.150 --> 00:10:16.900
It only worked on files,
and it was really only designed

00:10:16.900 --> 00:10:18.900
to work on HFS+ type volumes.

00:10:19.030 --> 00:10:21.540
So we weren't able to
use it on NFS volumes,

00:10:21.630 --> 00:10:22.650
for instance.

00:10:22.810 --> 00:10:25.420
By releasing a new API,
this gives us the opportunity

00:10:25.670 --> 00:10:28.410
to do what's best in each
particular volume format.

00:10:28.590 --> 00:10:31.530
So for instance, on HFS+ volumes,
we can go ahead and call

00:10:31.530 --> 00:10:34.890
exchange data under the hood,
if that's the best way to do it.

00:10:35.850 --> 00:10:38.900
I want to mention that now in Leopard,
if you're a Cocoa developer,

00:10:38.900 --> 00:10:42.040
it's used by default in NSDocument.

00:10:42.040 --> 00:10:45.780
So in the case of a catastrophe while
you're saving a file using NSDocument,

00:10:45.780 --> 00:10:50.220
you may notice that a file might
be created called "a document being

00:10:50.220 --> 00:10:51.640
saved by text edit" in brackets.

00:10:51.640 --> 00:10:54.010
This would be your original file,
maybe while you're writing it out,

00:10:54.010 --> 00:10:55.780
network cable gets pulled,
power goes out,

00:10:55.780 --> 00:10:57.120
something along those lines.

00:10:57.120 --> 00:10:59.320
You can get more information on
that in the AppKit release notes,

00:10:59.320 --> 00:11:01.710
and specifically there's a section
in there called "advice for

00:11:01.960 --> 00:11:05.810
overwriters of NSDocument reading
and writing methods". Thank you.

00:11:07.640 --> 00:11:11.700
So the Replace
Object API is Mac OS X API,

00:11:11.700 --> 00:11:15.660
which does really what we'd
expect from a Mac OS X API.

00:11:15.710 --> 00:11:19.120
What I mean by that is we can not
only replace files with files,

00:11:19.140 --> 00:11:22.400
or directories with directories,
but we can replace

00:11:22.400 --> 00:11:25.140
files with directories,
or directories with files.

00:11:25.320 --> 00:11:29.730
This is really especially useful
if you've ever maybe edited

00:11:29.730 --> 00:11:31.660
a README file in TextEdit.

00:11:31.900 --> 00:11:34.180
And you're editing your README file,
and then you decide to start

00:11:34.180 --> 00:11:36.250
pasting some pictures in there,
and you notice that your README file

00:11:36.310 --> 00:11:40.300
changes from README.RTF to README.RTFD.

00:11:40.370 --> 00:11:43.100
That file is actually a document package.

00:11:43.180 --> 00:11:44.940
So for instance,
if you're saving a file to

00:11:44.940 --> 00:11:46.830
your iDisk in this case,
you can go ahead,

00:11:46.900 --> 00:11:49.630
you have your original file,
go ahead and make your entire

00:11:49.630 --> 00:11:52.200
document package hierarchy,
make everything coherent.

00:11:52.280 --> 00:11:55.230
Once you have the entire
document hierarchy coherent,

00:11:55.250 --> 00:11:58.520
replace that original file
with your document package.

00:11:58.630 --> 00:12:00.470
There can be only one.

00:12:02.070 --> 00:12:06.100
What I mean by that is the
way the API works by default.

00:12:06.160 --> 00:12:09.090
When you call replace object,
you have your original file

00:12:09.220 --> 00:12:10.390
and you have your new file.

00:12:10.500 --> 00:12:13.540
After replace object is called,
you end up with your new file

00:12:13.650 --> 00:12:16.590
in the original file's location,
one file object when you're done.

00:12:16.600 --> 00:12:20.530
Of course, we have plenty of options to
override the default behavior.

00:12:20.650 --> 00:12:23.550
The "save original as
backup" is one of them,

00:12:23.550 --> 00:12:26.840
in which case you might want
to specify a directory to save

00:12:26.840 --> 00:12:28.590
your original as a backup.

00:12:28.630 --> 00:12:33.730
We have an accessory routine
called fsgettemporarydirectory

00:12:33.750 --> 00:12:35.560
for replace object.

00:12:35.560 --> 00:12:38.540
This is a higher-level API which
might sit on top of find folder,

00:12:38.590 --> 00:12:41.870
and it will return back the
best place on this volume to

00:12:41.870 --> 00:12:43.600
save your files as a backup.

00:12:43.600 --> 00:12:49.470
Not only is it a good API to use to
find the best place to save your backup,

00:12:49.600 --> 00:12:53.410
one of the things, as you can imagine,
about replace object is that your

00:12:53.410 --> 00:12:56.600
new file and your original file
have to be on the same volume.

00:12:56.600 --> 00:12:58.580
We can't have our new
file on our local file.

00:12:58.630 --> 00:13:01.630
We can't have our new file on our local
disk and our original file on our network

00:13:01.720 --> 00:13:03.490
disk and expect this to be one operation.

00:13:03.600 --> 00:13:07.010
By calling the fsgettemporarydirectory
for replace object,

00:13:07.010 --> 00:13:11.600
it will return back a suitable location
on the same volume as the original file.

00:13:12.770 --> 00:13:18.930
The default behavior of replace object is
to actually merge the extended attributes

00:13:19.320 --> 00:13:21.570
of the original file and the new file.

00:13:21.570 --> 00:13:24.790
In the case of a collision,
the priority is given to the

00:13:24.790 --> 00:13:26.710
new file's extended attributes.

00:13:27.050 --> 00:13:30.180
and with ACLs,
we take quite the opposite approach.

00:13:30.200 --> 00:13:33.000
We will take the security
information from the original file,

00:13:33.050 --> 00:13:36.600
move the new file into that location,
and then apply it to the new file.

00:13:36.630 --> 00:13:40.180
Again, we have options to override
both of these behaviors.

00:13:43.020 --> 00:13:45.850
Here's some sample implementation file.

00:13:45.980 --> 00:13:49.200
Actually, there is actually sample code,
and I believe the sample is

00:13:49.200 --> 00:13:53.330
called FSReplaceObjectSampleCode,
found in the same location.

00:13:54.710 --> 00:13:56.080
Move to trash.

00:13:56.360 --> 00:14:00.200
This is actually quite
a complicated problem.

00:14:00.200 --> 00:14:02.670
When someone wants to move a
file to the appropriate trash,

00:14:02.700 --> 00:14:04.990
it's hard to know what
the appropriate trash is.

00:14:05.010 --> 00:14:09.450
We have the /usr/trash, /trash,
/networktrashes, I believe.

00:14:09.550 --> 00:14:12.440
And some volumes don't
even have trash cans.

00:14:12.600 --> 00:14:16.830
So typically what developers have
done in the past is maybe create an

00:14:16.830 --> 00:14:21.570
Apple script that says something like,
"Tell finder move file object to

00:14:21.570 --> 00:14:25.480
trash." This is really a suboptimal
approach for many reasons.

00:14:25.770 --> 00:14:28.600
Once the finder does this,
you have no idea where the file went.

00:14:28.600 --> 00:14:31.880
You have no idea if it succeeded
or if the finder is presenting

00:14:31.970 --> 00:14:33.590
a dialog in the background.

00:14:33.600 --> 00:14:36.620
So now in Leopard,
we're introducing the fs

00:14:36.620 --> 00:14:38.600
move object to trash API.

00:14:38.600 --> 00:14:41.550
It will move your filesystem
object to the proper trash.

00:14:41.610 --> 00:14:41.850
So now in Leopard,
we're introducing the fs

00:14:41.850 --> 00:14:42.020
move object to trash API.

00:14:42.020 --> 00:14:42.600
It will move your filesystem
object to the proper trash.

00:14:42.870 --> 00:14:45.350
and it will return a
reference to the moved item.

00:14:45.350 --> 00:14:47.820
One of the reasons why it returns
back a reference to the moved item

00:14:48.080 --> 00:14:51.570
is because it can potentially rename
that filesystem object en route to

00:14:51.570 --> 00:14:54.190
the trash in case of a name collision.

00:14:56.230 --> 00:15:01.590
The Move to Trash API will return back a
-120 or directory not found error in the

00:15:01.590 --> 00:15:03.480
case where it cannot find a trash can.

00:15:03.510 --> 00:15:05.160
So in this case,
the finder typically presents up

00:15:05.160 --> 00:15:08.180
a dialog that says something like,
the item main.c will

00:15:08.210 --> 00:15:09.520
be deleted immediately.

00:15:09.630 --> 00:15:10.750
Are you sure you want to continue?

00:15:10.850 --> 00:15:12.900
You can do the same thing.

00:15:14.750 --> 00:15:18.440
Here's a list of other information
that I wanted to get out for Leopard.

00:15:18.440 --> 00:15:21.350
Kind of a grab bag of small tidbits here.

00:15:21.840 --> 00:15:27.260
In Leopard,
we are finally moving to 64-bit file IDs.

00:15:27.290 --> 00:15:29.720
What this really means is that the
alias manager will automatically

00:15:29.720 --> 00:15:32.760
resolve your 64-bit file IDs for you,
and so forth.

00:15:32.790 --> 00:15:35.270
That integration is already
built into the Finder,

00:15:35.270 --> 00:15:37.800
and we will be releasing
higher level APIs to gain

00:15:37.800 --> 00:15:40.550
access to the 64-bit file IDs.

00:15:41.190 --> 00:15:42.420
UFS.

00:15:42.500 --> 00:15:48.280
With the introduction of
case-sensitive HFS+ or HFSx volumes,

00:15:48.280 --> 00:15:52.930
there is no longer a big reason
to have UFS disks around.

00:15:52.930 --> 00:15:55.920
So starting in Leopard,
we will allow you to

00:15:55.920 --> 00:15:58.890
read and write UFS disks,
but we will no longer

00:15:58.890 --> 00:16:00.490
format disks as UFS.

00:16:02.320 --> 00:16:05.230
Last year at WWDC,
we announced the deprecation

00:16:05.270 --> 00:16:08.390
of non-thread-safe filesystems.

00:16:08.600 --> 00:16:11.160
Through the KPI right now,
there's a flag to specify whether or

00:16:11.170 --> 00:16:12.900
not your filesystem is thread-safe.

00:16:13.090 --> 00:16:18.960
And we went through the hoops in
VFS layer to make sure that your

00:16:18.960 --> 00:16:20.900
filesystem did the right thing.

00:16:20.900 --> 00:16:24.410
Now, starting in Leopard,
those non-thread-safe filesystems

00:16:24.480 --> 00:16:26.260
are going to be unsupported.

00:16:26.520 --> 00:16:29.940
and things that I know
that you would never do.

00:16:29.940 --> 00:16:32.020
Dot underscore files, right?

00:16:32.230 --> 00:16:33.370
I think most of you know what those are.

00:16:33.380 --> 00:16:37.520
Those are the Apple double files that
we sometimes have to save the resource

00:16:37.580 --> 00:16:40.050
fork or extend attribute information in.

00:16:40.190 --> 00:16:46.310
We store them in dot underscore files,
for instance,

00:16:46.310 --> 00:16:46.460
if you're saving it to an NFS volume,
and we've all seen these

00:16:46.460 --> 00:16:46.460
kind of lingering around.

00:16:46.770 --> 00:16:48.940
In the past,
a lot of this functionality was

00:16:48.940 --> 00:16:50.690
in the core services file manager.

00:16:50.950 --> 00:16:54.020
So the way we do things is, for instance,
write out the size of the--

00:16:54.020 --> 00:16:56.780
when we touch the resource fork,
we would write out the size

00:16:56.780 --> 00:16:59.680
of the resource fork into the
header of the Apple double file.

00:16:59.700 --> 00:17:02.640
And then we'd go ahead and write
out that entire resource fork.

00:17:02.680 --> 00:17:06.040
Well, as we move this functionality from
the core services file manager

00:17:06.040 --> 00:17:08.350
and push it down into the kernel,
we operate under

00:17:08.350 --> 00:17:09.780
different constraints now.

00:17:09.780 --> 00:17:12.910
So now we're going to effectively
write out the size information and

00:17:12.910 --> 00:17:16.520
the resource fork at the same time
when the file is actually closed.

00:17:16.890 --> 00:17:20.720
But you shouldn't be accessing
the ._ file directly anyway.

00:17:20.720 --> 00:17:23.320
The /RSRC.

00:17:23.350 --> 00:17:26.740
If we have a file named
"foo" on an HFS+ volume,

00:17:26.800 --> 00:17:30.130
for instance,
we can always go cat foo/rsrc,

00:17:30.130 --> 00:17:35.580
and this will actually catalog the
entire resource fork of the file foo.

00:17:35.770 --> 00:17:38.450
This was kind of a hack, as I mentioned,
because it really only worked

00:17:38.570 --> 00:17:40.190
on certain volume formats.

00:17:40.290 --> 00:17:43.580
And now, since we pushed a lot of this
functionality down into the kernel,

00:17:43.600 --> 00:17:46.790
we're removing that back in,
or that hack anyway.

00:17:48.390 --> 00:17:49.860
Removal of VOLFS.

00:17:49.890 --> 00:17:52.720
So in the past,
if you ran the FS usage tool,

00:17:52.840 --> 00:17:58.370
you would notice a whole bunch of reads
and writes going to /.vol directory,

00:17:58.590 --> 00:18:00.180
and you typically see
a file ID after that.

00:18:00.300 --> 00:18:02.820
We're starting to close
the hole on VOLFS,

00:18:02.860 --> 00:18:05.200
so you're no longer going to see that.

00:18:05.290 --> 00:18:11.300
We have a great tech note, 11.13,
describing the /.vol and VOLFS.

00:18:11.300 --> 00:18:14.300
And one of the comments in there,
or one of the notes in there, says,

00:18:14.300 --> 00:18:17.380
"Under no circumstances should
your application construct paths

00:18:17.380 --> 00:18:20.290
with /.vol." So this still applies.

00:18:20.350 --> 00:18:24.260
At this time, I would like to welcome
Dominic Giampaolo.

00:18:31.800 --> 00:18:33.010
All right, I'm on.

00:18:33.160 --> 00:18:34.300
I'm Dominic Giampaolo.

00:18:34.300 --> 00:18:37.430
I'm a filesystem engineer,
and I'm here to talk about the

00:18:37.430 --> 00:18:39.730
filesystem events framework.

00:18:39.900 --> 00:18:43.130
First, I'll go over the agenda of what
we're going to cover today.

00:18:43.240 --> 00:18:47.460
I'm going to start with some history and
background about what the problem is,

00:18:47.490 --> 00:18:50.560
or how we see it,
and what's difficult about it,

00:18:50.560 --> 00:18:54.390
what we were trying to do
with the FS Events Framework.

00:18:54.460 --> 00:18:57.800
I'll introduce the
FS Events Framework API itself.

00:18:57.800 --> 00:19:01.350
And of course,
since this is a developer conference,

00:19:01.350 --> 00:19:05.340
we're going to go through some
code and an example application

00:19:05.480 --> 00:19:08.590
that uses the FS Events Framework,
and then review and wrap up.

00:19:10.570 --> 00:19:11.790
What is the problem?

00:19:12.070 --> 00:19:15.660
Well,
there's two classes of problems that

00:19:15.660 --> 00:19:17.860
we see or we get a lot of requests for.

00:19:18.080 --> 00:19:19.920
Did anything change in this hierarchy?

00:19:20.000 --> 00:19:23.370
So you have an application
like iPhoto or iTunes,

00:19:23.370 --> 00:19:25.610
and it manages some large hierarchy.

00:19:25.890 --> 00:19:28.500
Did something change underneath of there?

00:19:28.540 --> 00:19:31.000
You have other applications
where they're running live,

00:19:31.070 --> 00:19:34.150
including something like
iPhoto or iTunes or the Finder.

00:19:34.380 --> 00:19:36.670
Is anything changing in this hierarchy?

00:19:36.760 --> 00:19:39.640
So there may be some window
that's open that represents

00:19:39.680 --> 00:19:43.470
some current file system state,
and you want to know,

00:19:43.510 --> 00:19:46.270
is anything currently changing
underneath there because

00:19:46.270 --> 00:19:48.300
I need to update my display?

00:19:48.470 --> 00:19:50.560
So those are actually
really difficult questions.

00:19:50.630 --> 00:19:55.380
And historically, there has been no good
answer to those questions.

00:19:55.610 --> 00:19:59.370
We also see that different applications
want different kinds of answers.

00:19:59.500 --> 00:20:04.770
What changed differs depending on
what type of application you are.

00:20:06.030 --> 00:20:08.410
So what exactly is a
filesystem and event?

00:20:08.530 --> 00:20:12.090
At a low level,
a filesystem event is a create, a rename,

00:20:12.090 --> 00:20:12.830
a delete.

00:20:12.930 --> 00:20:16.810
It's other more subtle things such
as the update to the mod time or

00:20:16.810 --> 00:20:19.100
the ownership permissions of a file.

00:20:19.350 --> 00:20:20.900
It's when a file changes.

00:20:20.900 --> 00:20:24.460
It's really quite a bit
of low-level events.

00:20:24.510 --> 00:20:27.210
At a high level,
an event is something like, "Well,

00:20:27.280 --> 00:20:30.400
I saved a document." From my perspective,
that's one thing.

00:20:30.400 --> 00:20:34.230
As a user,
I hit save and there's a file there now.

00:20:34.440 --> 00:20:38.290
In reality, when you change a file
and you do a safe save,

00:20:38.310 --> 00:20:41.040
as Deric alluded to,
there may be a whole bunch of

00:20:41.040 --> 00:20:43.200
operations that go on under the hood.

00:20:43.260 --> 00:20:47.050
And in practice, if you've ever looked at
it from the underside,

00:20:47.050 --> 00:20:50.720
as I'm frequently doing,
you'll see that a filesystem save

00:20:50.720 --> 00:20:56.200
operation from an application may be 5,
10, or 20 even, actual events that come

00:20:56.200 --> 00:20:58.990
through at a low level.

00:20:59.080 --> 00:21:03.390
The raw stream of events that
we see generated is really

00:21:03.390 --> 00:21:05.120
very difficult to manage.

00:21:05.120 --> 00:21:10.470
It's a big fire hose
and it's quite complex.

00:21:11.700 --> 00:21:14.870
Now, clearly everybody hasn't just sat
around for 20 years waiting for us

00:21:14.900 --> 00:21:16.960
to introduce the FS events framework.

00:21:17.060 --> 00:21:19.600
They've come up with other solutions.

00:21:19.710 --> 00:21:20.980
At one level you have polling.

00:21:21.150 --> 00:21:22.150
"Did this file change?

00:21:22.150 --> 00:21:23.200
Did this file change?

00:21:23.200 --> 00:21:24.790
Did this file change?" And so on.

00:21:24.930 --> 00:21:26.600
Or a full rescan.

00:21:26.600 --> 00:21:28.900
You know,
if you have a backup application,

00:21:28.900 --> 00:21:33.590
typically it walks the whole filesystem
hierarchy to find out what is different

00:21:33.590 --> 00:21:35.910
and what needs to be backed up.

00:21:36.200 --> 00:23:19.900
[Transcript missing]

00:23:20.600 --> 00:23:22.030
There's no history of events.

00:23:22.080 --> 00:23:25.400
You can't say, "Well,
this backup application, or whatever,

00:23:25.400 --> 00:23:28.010
this synchronization app,
or whatever have you,

00:23:28.010 --> 00:23:29.260
hasn't run for a week.

00:23:29.430 --> 00:23:33.240
What changed in the last week?" So,
not having any history,

00:23:33.320 --> 00:23:37.060
all of these things were sort of live,
not having any history

00:23:37.060 --> 00:23:38.500
was a bit of a problem.

00:23:38.500 --> 00:23:41.470
And the chaos subsystem
is extremely powerful,

00:23:41.590 --> 00:23:45.480
but kernel-level monitoring is not
practical for most applications.

00:23:45.520 --> 00:23:48.580
Typically,
people are not going to write a KEXT to

00:23:48.650 --> 00:23:50.830
go along with their user-level app.

00:23:51.950 --> 00:23:54.860
Something else that we introduced
in Tiger was called DevEvS Events.

00:23:54.900 --> 00:23:58.280
Well, we didn't really introduce it,
but a number of you found it anyway.

00:23:58.310 --> 00:24:02.280
It was implemented for
Spotlight specifically.

00:24:02.340 --> 00:24:05.040
And it provides a raw stream
of events to support the

00:24:05.120 --> 00:24:07.650
functionality that Spotlight needs.

00:24:07.790 --> 00:24:10.340
It's all locally generated events.

00:24:10.470 --> 00:24:13.900
So any change to any file
system that's mounted locally,

00:24:13.900 --> 00:24:20.480
or any change that's produced by a
local application produces an event.

00:24:20.700 --> 00:24:21.950
The events are very raw.

00:24:21.960 --> 00:24:25.680
As I said, you see everything that
comes out of the kernel.

00:24:25.730 --> 00:24:30.450
So a stat change,
a permission change-- well,

00:24:30.450 --> 00:24:32.880
permission change is a stat change,
an ownership change,

00:24:32.880 --> 00:24:35.410
when a file is closed
after being written,

00:24:35.410 --> 00:24:38.280
you get a modification, renames, deletes.

00:24:38.280 --> 00:24:39.460
It's everything.

00:24:39.590 --> 00:24:44.430
Because it's a kernel-based mechanism,
it's also sensitive to slow clients for

00:24:44.430 --> 00:24:47.000
some reasonably complicated reasons.

00:24:47.000 --> 00:24:49.980
It has limited buffer
space in the kernel.

00:24:50.030 --> 00:24:52.280
And it's shared by all the clients.

00:24:52.390 --> 00:24:56.230
If someone is slow at reading them,
it will back up,

00:24:56.330 --> 00:24:59.040
and eventually it will run out of space,
and events are lost,

00:24:59.040 --> 00:25:02.080
which is a fairly catastrophic event.

00:25:02.150 --> 00:25:04.490
So because it's sensitive
to slow clients,

00:25:04.520 --> 00:25:09.300
it's not really appropriate to open
that up to general purpose applications.

00:25:09.320 --> 00:25:12.250
Besides, with the event stream
being as raw as it is,

00:25:12.250 --> 00:25:15.480
it's not as useful either.

00:25:15.810 --> 00:25:19.020
With all these problems,
we clearly have an

00:25:19.020 --> 00:25:21.200
opportunity on our hands.

00:25:21.200 --> 00:25:24.200
So, we started thinking about it,
and we decided to come up

00:25:24.200 --> 00:25:25.700
with the FSEvents framework.

00:25:25.700 --> 00:25:28.420
I'd like to talk a little bit
about our design rationale,

00:25:28.420 --> 00:25:30.700
so you understand where
we're coming from.

00:25:30.700 --> 00:25:33.690
We sort of thought about some
of the different clients.

00:25:33.690 --> 00:25:36.700
Clearly,
as you can see from the Leopard preview,

00:25:36.700 --> 00:25:40.700
backup is important,
sync is another application,

00:25:40.700 --> 00:25:42.700
and of course the Venerable Finder.

00:25:42.920 --> 00:25:47.540
Backup and sync will ask the question,
"Did anything change in this hierarchy?"

00:25:47.700 --> 00:25:50.700
The Finder is more of an online,
live kind of "Is anything changing in

00:25:50.700 --> 00:25:53.700
this hierarchy?" type of application.

00:25:53.700 --> 00:25:56.690
Clients we know that we aren't
going to satisfy are virus checkers.

00:25:56.690 --> 00:26:01.110
Virus checkers really have very
sophisticated requirements that

00:26:01.210 --> 00:26:05.830
can't be met with this API,
and the KAUTH subsystem is

00:26:05.840 --> 00:26:07.490
actually more appropriate.

00:26:07.770 --> 00:26:10.700
So, we're not trying to be
all things to all people.

00:26:10.700 --> 00:26:12.650
We also knew that we had to put
some limitations on the API.

00:26:12.700 --> 00:26:17.390
and constraints on the problem to
make it a little bit more tractable.

00:26:17.920 --> 00:26:20.860
Storing a complete log of
events is just not possible.

00:26:21.000 --> 00:26:24.660
Your computer is designed to run
user applications and to do things,

00:26:24.660 --> 00:26:27.500
not to sit around storing all the
stuff that you're trying to do,

00:26:27.500 --> 00:26:30.490
but it's being interfered with by
the fact that you're storing all

00:26:30.510 --> 00:26:32.350
the events that you're trying to do.

00:26:32.470 --> 00:26:37.350
So we have to really filter the event
stream down to something manageable,

00:26:37.470 --> 00:26:40.570
something digestible that
makes sense to applications.

00:26:40.610 --> 00:26:45.400
If you look at the raw event stream,
it's extremely complicated to understand,

00:26:45.470 --> 00:26:47.930
"Oh,
that was a safe-- those 20 operations

00:26:48.040 --> 00:26:52.460
were actually just a safe save
of a single file." And as I said,

00:26:52.460 --> 00:26:58.030
we can't be all things to all people,
so we had to narrow things down a bit.

00:26:58.290 --> 00:27:03.760
So without further ado,
introducing the FSEvents framework.

00:27:03.760 --> 00:27:09.200
This is a core foundation-based API that
lets you watch an entire hierarchy

00:27:09.200 --> 00:27:12.190
of-- a file hierarchy for changes.

00:27:12.270 --> 00:27:15.480
You get directory-level
notifications of changes that

00:27:15.480 --> 00:27:17.200
happen within that hierarchy.

00:27:17.200 --> 00:27:19.200
So if you say,
"I want to watch the user's

00:27:19.200 --> 00:27:21.940
home directory," and I'll
go into more detail on this,

00:27:22.050 --> 00:27:25.110
you'll find out specific locations
that have changed within it.

00:27:25.210 --> 00:27:29.760
We offer a persistent change history,
and again, I'm going to go into more

00:27:29.860 --> 00:27:31.070
detail about all of these.

00:27:31.240 --> 00:27:36.200
And we have fine control over the
frequency of updates that you get.

00:27:36.200 --> 00:27:37.200
What don't you get?

00:27:37.200 --> 00:27:39.800
You don't get events for
changes to specific files.

00:27:39.800 --> 00:27:42.800
And I'll talk about this again
more in the later slides,

00:27:42.800 --> 00:27:46.730
but you can't say, "Did file foo change?"

00:27:47.850 --> 00:27:49.560
What does it architecturally look like?

00:27:49.660 --> 00:27:52.890
This sort of helps to understand
what's going on under the covers.

00:27:52.950 --> 00:27:56.380
At the top level,
FSEvents is obviously the framework,

00:27:56.480 --> 00:27:58.630
the API that you as developers can call.

00:27:58.700 --> 00:28:03.380
There's a corresponding daemon,
FSEventsD, that orchestrates things

00:28:03.380 --> 00:28:04.660
behind the scenes.

00:28:04.770 --> 00:28:10.680
FSEventsD is based on the DevFS events
device that provides the raw

00:28:10.680 --> 00:28:13.700
stream of events from the kernel.

00:28:13.700 --> 00:28:16.570
It filters,
FSEventsD filters the event stream

00:28:16.570 --> 00:28:21.110
into something that is coherent,
sends the updates through a

00:28:21.160 --> 00:28:28.400
Mach message to client applications,
and it also keeps the historical records.

00:28:29.160 --> 00:28:30.190
Actually, I should go back.

00:28:30.270 --> 00:28:34.320
So as you can see,
we have the event history that's

00:28:34.340 --> 00:28:35.720
being stored away on disk.

00:28:35.770 --> 00:28:38.300
FSEventsD is reading the
events out of the kernel,

00:28:38.370 --> 00:28:42.720
passing them over to
the FSEvents framework,

00:28:42.840 --> 00:28:49.120
which in turn hooks into the
core foundation-based API.

00:28:49.300 --> 00:28:53.410
So what are the concepts
behind the FSEvents framework?

00:28:54.170 --> 00:28:56.830
You can monitor a path in
the filesystem namespace,

00:28:56.830 --> 00:29:00.000
and you get only events that
happen beneath that path.

00:29:00.000 --> 00:29:01.760
So yes,
you can watch slash and you'll see

00:29:01.800 --> 00:29:05.740
all the directories that are changed,
all the directories that have changes

00:29:05.760 --> 00:29:08.000
made to them anywhere in the filesystem.

00:29:08.180 --> 00:29:12.000
All events that you get have
a corresponding event ID.

00:29:12.030 --> 00:29:15.330
Event IDs are 64-bit,
so they never get recycled,

00:29:15.330 --> 00:29:19.000
at least not for,
now let's say about 5,000 years.

00:29:19.000 --> 00:29:24.000
You can ask for all the events
since a specific event ID.

00:29:24.000 --> 00:29:29.700
As I said, event IDs are persistent,
so they last across a reboot.

00:29:30.770 --> 00:29:33.100
When you get an event,
you're supposed to use it to figure out

00:29:33.100 --> 00:29:38.950
what happened that's of interest to you,
and then, of course, do the right thing.

00:29:40.340 --> 00:29:43.550
The path that you watch
doesn't have to actually exist.

00:29:43.670 --> 00:29:46.310
It's actually just a
string-based prefix match.

00:29:46.420 --> 00:29:49.130
So you can watch something
that doesn't exist,

00:29:49.160 --> 00:29:53.760
and when it does come into existence,
you'll start receiving events for the

00:29:53.770 --> 00:29:56.210
changes that happen under that path.

00:29:56.300 --> 00:29:58.530
For now,
the path has to be an absolute path.

00:29:58.750 --> 00:30:01.220
Even in the future, if we allow you to
specify a relative path,

00:30:01.370 --> 00:30:04.180
we're just going to turn
it into an absolute path.

00:30:04.360 --> 00:30:09.680
As I said, you get events for anything
that changes under the path.

00:30:09.790 --> 00:30:14.780
You can watch any number
of paths that you want,

00:30:14.780 --> 00:30:14.860
I suppose within reason, of course.

00:30:14.890 --> 00:30:18.820
And security, right now there is none,
but obviously there will be,

00:30:18.820 --> 00:30:21.760
so you're not going to be
able to watch things that you

00:30:21.760 --> 00:30:23.490
don't have permission to see.

00:30:24.260 --> 00:30:26.310
Here's some specific examples.

00:30:26.410 --> 00:30:33.070
If you watch users foo and then
someone creates the file users foo

00:30:33.070 --> 00:30:37.000
documents my cool stuff new file,
you get an event,

00:30:37.110 --> 00:30:40.320
the event that you get is
for the directory users foo

00:30:40.380 --> 00:30:42.760
documents my cool stuff.

00:30:42.820 --> 00:30:45.850
If someone creates slash temp ignore me,
you don't get any event,

00:30:45.850 --> 00:30:49.010
nothing comes through to you
because you're not watching that,

00:30:49.090 --> 00:30:50.920
you're only watching users foo.

00:30:51.060 --> 00:30:53.890
You don't find out about
changes to the root of the path.

00:30:53.950 --> 00:30:57.770
So for example, if you chose to watch a
directory which didn't exist,

00:30:57.780 --> 00:31:01.780
let's say users foo sumdir,
and then someone creates it,

00:31:01.820 --> 00:31:04.040
you don't get an event for that.

00:31:04.110 --> 00:31:06.500
If then they create
something inside of there,

00:31:06.500 --> 00:31:08.090
then you do get an event.

00:31:08.180 --> 00:31:10.730
Now as it says,
this is open to discussion because

00:31:10.730 --> 00:31:12.670
we've kind of gone back and forth.

00:31:12.770 --> 00:31:14.450
Clearly it's something
that's easy to work around.

00:31:14.460 --> 00:31:18.880
You just watch one level above for
the thing that you're looking for.

00:31:19.040 --> 00:31:23.780
But it's something that we'd
like to get feedback on.

00:31:25.300 --> 00:32:39.600
[Transcript missing]

00:32:40.430 --> 00:32:42.060
We also had a few assumptions.

00:32:42.110 --> 00:32:46.100
And I want to detail these so we
understand where we're coming from.

00:32:46.290 --> 00:32:49.500
First off,
clients that want to monitor some

00:32:49.500 --> 00:32:53.160
large file hierarchy have to have
a mechanism to generate their

00:32:53.160 --> 00:32:57.080
initial state about what it is they
care about about that hierarchy.

00:32:57.150 --> 00:33:00.320
So you have to have code that
does a full scan and knows how

00:33:00.320 --> 00:33:02.630
to process that and build state.

00:33:02.810 --> 00:33:06.730
If you have code that does a full scan,
it's pretty straightforward to make it

00:33:06.730 --> 00:33:09.230
code that does a partial scan by saying,
oh,

00:33:09.230 --> 00:33:11.680
just go update this particular directory.

00:33:11.760 --> 00:33:18.050
And given a directory that changed,
you can scan that directory and

00:33:18.180 --> 00:33:21.610
update your internal state based
on what differences you find

00:33:21.630 --> 00:33:23.510
that are interesting to you.

00:33:23.610 --> 00:33:28.500
So we sort of have, like I said,
those assumptions about what

00:33:28.540 --> 00:33:33.650
clients are going to have to do to
maintain their state given the event

00:33:33.660 --> 00:33:36.390
notifications that they receive.

00:33:36.690 --> 00:33:42.080
Now, we'll go to this demo machine and
we'll go through a simple example

00:33:42.100 --> 00:33:47.600
that shows how the raw event stream
that comes out of the FS events API.

00:33:47.600 --> 00:33:52.590
So we have this tool down
here called FSEvents.

00:33:52.600 --> 00:33:57.140
And this just prints out all
the events that it receives.

00:33:57.270 --> 00:34:00.590
As you can see,
I'm specifying an option of

00:34:00.600 --> 00:34:02.360
a latency-- dash latency 1.0.

00:34:02.450 --> 00:34:05.430
And I'm going to give it the path
slash so that we see everything

00:34:05.500 --> 00:34:06.750
that changes on the system.

00:34:06.920 --> 00:34:10.410
So we may actually see some other
stuff depending on what Damon's run,

00:34:10.410 --> 00:34:11.700
what goes on.

00:34:11.820 --> 00:34:14.650
Now, I have this other terminal window.

00:34:14.740 --> 00:34:21.520
And I'm going to make a directory,
and I'll call it foo-- wonderful name.

00:34:21.650 --> 00:34:23.540
About a second later,
you see that we got an

00:34:23.540 --> 00:34:27.540
event for users/apple/dbg,
because that's the directory.

00:34:27.540 --> 00:34:30.470
If you see, that's where I'm at,
and that's the directory that I created.

00:34:30.610 --> 00:34:35.340
If I go into foo and I touch new file,
we're going to get an event

00:34:35.340 --> 00:34:39.760
for the directory foo,
because that is what changed.

00:34:40.240 --> 00:34:46.730
Another example, I'm going to geek out
here for just a second,

00:34:46.730 --> 00:34:49.790
to create a whole bunch of files.

00:34:56.140 --> 00:34:59.730
So we're going to create
a couple thousand files,

00:34:59.840 --> 00:35:06.180
and I want you to observe... So that
created... This machine's too fast.

00:35:06.180 --> 00:35:08.060
I need to slow it down.

00:35:08.120 --> 00:35:18.490
Well, alright, I can play this game too.

00:35:18.490 --> 00:35:18.490
We'll create a lot of files.

00:35:18.700 --> 00:35:21.570
All right, thwarted.

00:35:21.630 --> 00:35:23.520
All right,
so now what you see is that we're

00:35:23.530 --> 00:35:29.070
getting multiple events as I'm
creating many thousands of files here.

00:35:29.140 --> 00:35:30.510
And they're coming through.

00:35:30.640 --> 00:35:35.640
And what I wanted to demonstrate is,
if I went down here and changed

00:35:35.640 --> 00:35:39.510
this latency-- like you may say,
oh, one second, that's too long.

00:35:39.520 --> 00:35:41.180
I can't tolerate that kind of latency.

00:35:41.180 --> 00:35:44.340
So I'm going to have
a 0.1 second latency.

00:35:44.430 --> 00:35:47.930
Now, if I go up here and create-- well,
I'm not going to create

00:35:47.930 --> 00:35:48.930
that many files this time.

00:35:49.040 --> 00:35:51.700
You see,
we get a whole lot more notifications.

00:35:51.820 --> 00:35:56.550
Now, this is obviously good if you need
to update in that kind of real time.

00:35:56.590 --> 00:36:00.180
But typically,
you want to have a latency that's long

00:36:00.180 --> 00:36:02.900
enough so that events get compressed.

00:36:02.990 --> 00:36:06.160
Because 4,000 files were
created in this directory.

00:36:06.270 --> 00:36:08.670
But really,
I only want to have to do one re-scan

00:36:08.670 --> 00:36:14.210
at the end when the dust has settled,
so to speak.

00:36:14.230 --> 00:36:23.010
So if I was to change this latency and,
say, use a 2.0 second latency,

00:36:23.810 --> 00:36:27.700
and then go and create
all those files again.

00:36:27.700 --> 00:36:28.610
Whoops, that one.

00:36:28.610 --> 00:36:30.970
What you'll see is that that
will run and I might get one or

00:36:30.970 --> 00:36:32.940
two events instead of 10 or 15.

00:36:32.940 --> 00:36:35.180
In fact, I only got one event.

00:36:35.210 --> 00:36:39.050
Now, you see these event IDs.

00:36:39.110 --> 00:36:41.660
I will show you the history.

00:36:41.790 --> 00:36:45.820
If I specify-- well,
let's do latency 1.0 and I'll

00:36:45.820 --> 00:36:48.760
specify a dash since when.

00:36:48.760 --> 00:36:52.830
And I'm going to say-- because
I was paying attention earlier.

00:36:52.890 --> 00:36:55.860
So this is actually going to be a fair
number of events that are going to

00:36:55.900 --> 00:36:59.910
come through for the history since,
let's say,

00:36:59.920 --> 00:37:04.710
a time-- an event ID of 320,000,
which when I came into the room was

00:37:04.710 --> 00:37:07.000
roughly what the event IDs were at.

00:37:07.000 --> 00:37:09.230
Whoops,
I have to give it a directory to watch.

00:37:09.360 --> 00:37:13.750
So here we see everything
that's changed since-- so you

00:37:13.760 --> 00:37:15.980
can see Spotlight was busy.

00:37:16.020 --> 00:37:20.100
Something changed in /dev,
which is probably worth ignoring.

00:37:20.100 --> 00:37:22.510
And these are all the other directories.

00:37:22.520 --> 00:37:27.390
In fact, we can see that the fseventsd
was writing to its directory.

00:37:27.470 --> 00:37:30.560
Temporary items,
preferences got modified.

00:37:30.650 --> 00:37:34.630
So again, this is what's happened since
that particular event ID.

00:37:34.750 --> 00:37:39.460
And then you can see that users
dbgfoo got a few updates as well.

00:37:39.460 --> 00:37:43.110
These get coalesced on
a 30-second granularity.

00:37:43.240 --> 00:37:45.840
That's not super interesting,
but you can get multiple

00:37:45.840 --> 00:37:47.500
events for the same directory.

00:37:47.640 --> 00:37:50.220
So this is just kind of giving
you an example of the parameters

00:37:50.220 --> 00:37:55.410
and options that you have
with the fseventsd framework.

00:37:55.520 --> 00:37:58.160
So if we go back to the slides--

00:38:05.070 --> 00:38:09.060
So now we're going to get into talking
about the specifics of the API.

00:38:09.130 --> 00:38:13.860
The data types that you have to
worry about-- it's a very simple API.

00:38:13.960 --> 00:38:17.210
First thing you have to know
about is the FSEventsStream.

00:38:17.290 --> 00:38:21.600
This is the channel that you receive the
notifications on when there's changes.

00:38:21.670 --> 00:38:24.910
It's a CF run loop provider,
so you can create it,

00:38:25.010 --> 00:38:28.980
schedule it on a run loop,
and we'll go into those details too.

00:38:29.160 --> 00:38:31.850
And then the next data type--
not really a data type,

00:38:31.940 --> 00:38:36.950
but the FSEventsStream callback,
which is a typedef for the API that

00:38:36.960 --> 00:38:39.280
you have for your callback function.

00:38:39.340 --> 00:38:43.270
And that's what gets called each
time that there are changes.

00:38:44.490 --> 00:38:48.160
FS Event Stream Create is a
standard CF run loop provider,

00:38:48.160 --> 00:38:53.000
so there's a variety of template
arguments that you expect,

00:38:53.000 --> 00:38:56.240
the CFAllocators,
there's a context pointer.

00:38:56.300 --> 00:39:00.090
The arguments that are of interest
for the event stream itself are,

00:39:00.210 --> 00:39:04.180
first and foremost, the callback,
or perhaps the paths

00:39:04.280 --> 00:39:06.240
are even more important.

00:39:06.310 --> 00:39:12.240
The paths is a CFArray of CFStrings of
paths that you want to watch.

00:39:12.240 --> 00:39:16.220
The since when parameter,
which is a 64-bit ID,

00:39:16.330 --> 00:39:19.370
that's the starting event ID,
we have a couple of

00:39:19.380 --> 00:39:21.240
different options for that.

00:39:21.240 --> 00:39:24.850
You can specify since now,
which means just from the current time,

00:39:24.850 --> 00:39:28.240
from when you get this forward
is when I want to receive events.

00:39:28.240 --> 00:39:30.700
Or you could specify zero,
which would be from

00:39:30.700 --> 00:39:34.220
the beginning of time,
but you probably don't want to do that.

00:39:34.320 --> 00:39:36.240
Or you can specify an actual event.

00:39:36.240 --> 00:39:39.240
You can specify the current event ID,
which is the last one that you saw.

00:39:39.380 --> 00:39:43.240
The latency is the frequency of
updates that you want to receive,

00:39:43.240 --> 00:39:46.240
or how often you want to be called.

00:39:46.240 --> 00:39:50.500
So as you saw,
I was specifying like 1.0 for one second,

00:39:50.500 --> 00:39:54.090
or 0.1 seconds,
and that's how you will receive

00:39:54.090 --> 00:39:56.240
events at most that frequently.

00:39:56.520 --> 00:40:00.100
There's also a flags argument,
but we don't have any flags,

00:40:00.100 --> 00:40:03.500
so you can just pass zero
or the constant for none.

00:40:04.920 --> 00:40:08.370
The lifecycle of an FS event
stream looks like this.

00:40:08.550 --> 00:40:12.360
You create it first,
specifying the arguments that you want.

00:40:12.560 --> 00:40:14.380
Then you schedule it on a run loop.

00:40:14.540 --> 00:40:16.800
Then you have to start the event stream.

00:40:16.800 --> 00:40:21.430
Again, we have very sort of explicit
phases so that you have pretty

00:40:21.470 --> 00:40:23.800
good control over when you,
so you're creating it,

00:40:23.820 --> 00:40:27.580
then you can start it so that you know
that everything in your application

00:40:27.900 --> 00:40:30.520
will be initialized at that point,
and your callback's going

00:40:30.620 --> 00:40:31.700
to start being called.

00:40:31.820 --> 00:40:34.500
You can stop an event stream,
which allows you to do clean

00:40:34.500 --> 00:40:37.940
teardowns so you don't have to
worry about race conditions between,

00:40:37.940 --> 00:40:42.300
"Oh, I'm still getting events called
back," and "I need to stop it," and,

00:40:42.300 --> 00:40:45.800
you know, this is a very
straightforward way to do it.

00:40:45.800 --> 00:40:50.620
Once you stop an event stream,
you can restart it if you want.

00:40:50.940 --> 00:40:52.920
Once you call invalidate,
the thing is basically

00:40:52.920 --> 00:40:55.580
headed for the bit bucket,
and the only other thing you

00:40:55.580 --> 00:40:57.390
can really do is call release.

00:40:58.530 --> 00:41:01.580
The callback itself gets
a couple of arguments.

00:41:01.630 --> 00:41:04.130
There is first the number
of events that you receive.

00:41:04.140 --> 00:41:06.440
You may receive more than one event.

00:41:06.440 --> 00:41:12.340
If you have a very long latency,
you may get 10 or 20 or 30 events.

00:41:12.340 --> 00:41:15.080
I forget what the maximum
is that will pass at a time,

00:41:15.200 --> 00:41:17.420
but you can receive quite a few.

00:41:17.580 --> 00:41:24.100
You get three parallel arrays,
and you get the paths for each event.

00:41:24.240 --> 00:41:28.120
So the event paths array,
the first entry is for the first event,

00:41:28.300 --> 00:41:31.980
and that tells you which directory
under the hierarchy that you're

00:41:31.980 --> 00:41:34.560
interested in that was modified.

00:41:34.680 --> 00:41:38.150
For each event,
you also get a flags argument

00:41:38.170 --> 00:41:40.690
and an event ID as well.

00:41:40.770 --> 00:41:42.750
The flags argument is very important.

00:41:42.980 --> 00:41:45.600
Normally, it's just going to be 0,
which is good.

00:41:45.600 --> 00:41:47.850
That means nothing of interest happened.

00:41:48.100 --> 00:41:51.150
You may also receive one
of these three flags.

00:41:51.180 --> 00:41:55.800
The first one, must scan sub dirs,
means that, well,

00:41:55.860 --> 00:41:56.710
there were some problems.

00:41:56.720 --> 00:42:02.160
As I said, devfs events in the kernel
has limited buffer space,

00:42:02.300 --> 00:42:07.580
and when it starts to get tight on space,
it will start to combine events.

00:42:07.690 --> 00:42:10.580
So what can happen is that
you will receive an event

00:42:10.730 --> 00:42:14.870
for some directory within the
hierarchy which you're watching,

00:42:15.000 --> 00:42:19.910
but it says what this flag means is that
you need to rescan from that point down.

00:42:20.090 --> 00:42:23.390
This is an unfortunate circumstance,
but it's better than clearly having

00:42:23.390 --> 00:42:25.000
to rescan the entire hierarchy.

00:42:25.000 --> 00:42:29.640
. Again, we go to great lengths to
avoid having this happen,

00:42:29.670 --> 00:42:31.820
but if it does happen,
you need to be aware

00:42:31.820 --> 00:42:34.420
that if that bit is set,
you need to rescan from that

00:42:34.490 --> 00:42:38.420
point down to be able to find
all the changes that happened.

00:42:38.560 --> 00:42:41.020
The next two flags are a
little bit more serious,

00:42:41.130 --> 00:42:43.870
and hopefully you'll never see them.

00:42:44.270 --> 00:42:49.090
The first one is called "Flags
User Dropped". What this means

00:42:49.110 --> 00:42:52.390
is that your application was
not reading events fast enough,

00:42:52.390 --> 00:42:55.170
the callback wasn't processing
the data fast enough,

00:42:55.260 --> 00:42:58.680
and things got clogged up,
and we had to drop events for you.

00:42:59.010 --> 00:43:01.120
Something changed,
we can't tell you what,

00:43:01.150 --> 00:43:03.700
because you weren't
reading them fast enough.

00:43:03.800 --> 00:43:07.160
Now this is catastrophic in the
sense that you now have to do a

00:43:07.160 --> 00:43:10.740
full rescan of the entire hierarchy
that you were interested in,

00:43:10.740 --> 00:43:14.740
but it's a very clear indication that
you need to make sure that the you're

00:43:14.740 --> 00:43:17.580
processing the callback fast enough.

00:43:17.610 --> 00:43:21.110
The next event,
"Kernel Dropped", there's nothing

00:43:21.110 --> 00:43:22.070
that you can do about this.

00:43:22.120 --> 00:43:25.680
You have to do a full rescan,
but things got so clogged up

00:43:25.680 --> 00:43:29.680
that the kernel couldn't even
keep up with the stream of

00:43:29.680 --> 00:43:31.410
events that were being generated.

00:43:31.550 --> 00:43:34.250
And again,
this is catastrophic in the sense that it

00:43:34.250 --> 00:43:36.390
means that you have to do a full rescan.

00:43:36.500 --> 00:43:39.030
So we go to great lengths
to avoid these things,

00:43:39.280 --> 00:43:43.970
but realistically they can happen,
and you need to be aware of that.

00:43:44.300 --> 00:43:46.700
The last array is the event ID.

00:43:46.700 --> 00:43:51.700
For each path,
it has the flags and an event ID.

00:43:51.750 --> 00:43:54.200
These are monotonically
increasing numbers.

00:43:54.200 --> 00:43:57.730
They are in essence a timestamp,
but they bear no relation to any wall

00:43:57.730 --> 00:43:59.700
clock time or anything like that.

00:43:59.700 --> 00:44:00.950
It's just a number.

00:44:00.950 --> 00:44:04.200
You can store them away for later use.

00:44:04.400 --> 00:44:09.180
When your application is shutting down,
the last event that you receive,

00:44:09.180 --> 00:44:12.280
you store that ID,
and then you can pick up from

00:44:12.280 --> 00:44:13.250
that point in the future.

00:44:13.900 --> 00:44:20.900
[Transcript missing]

00:44:21.590 --> 00:44:24.810
This program called Watcher,
that I'll start going

00:44:24.810 --> 00:44:28.140
through the code in a second,
is, well, sadly,

00:44:28.140 --> 00:44:32.500
a command line application
because that's all I'm capable of.

00:44:32.500 --> 00:44:39.800
I took a Cocoa programming class,
but it's just, I don't know.

00:44:39.800 --> 00:44:39.800
Anyway.

00:44:41.200 --> 00:44:49.220
Yeah, what it does is monitors a file
hierarchy and keeps track of the size.

00:44:49.300 --> 00:44:51.630
So if something changes
inside of the file hierarchy,

00:44:51.630 --> 00:44:54.160
it updates its state and tells
you what the new size is.

00:44:54.330 --> 00:44:58.900
And it does that by re-scanning
the one directory that changed.

00:44:58.980 --> 00:45:00.760
So it doesn't have to do a full re-scan.

00:45:00.790 --> 00:45:03.380
So I can watch a particular
directory hierarchy.

00:45:03.380 --> 00:45:07.550
It will build its initial state,
and then it will update

00:45:07.650 --> 00:45:09.770
that state as things change.

00:45:09.840 --> 00:45:12.140
So there's a little bit of support
code that I'm not going to go into.

00:45:12.140 --> 00:45:14.120
I'm not going to go through the
code that walks the directory

00:45:14.120 --> 00:45:15.560
hierarchy to build the initial state.

00:45:15.670 --> 00:45:18.960
You can figure out that
that's not too exciting,

00:45:18.980 --> 00:45:22.350
or the code that parses
the command line options.

00:45:22.530 --> 00:45:26.540
So anyway, starting here in main,
we're going to go down.

00:45:26.540 --> 00:45:30.320
As I said, the first thing is that we
have to get an absolute path.

00:45:30.400 --> 00:45:35.670
So we call real path on the path
that came in on the command line.

00:45:35.680 --> 00:45:38.680
And we only support monitoring a
single directory as a simple example.

00:45:39.780 --> 00:45:43.520
And if real path fails,
because let's say the

00:45:43.520 --> 00:45:47.760
directory doesn't exist,
we just copy it in.

00:45:47.760 --> 00:45:50.910
One other thing to point out,
a frequent thing that people

00:45:50.930 --> 00:45:54.240
do with the FS events APIs,
they'll go and watch /temp.

00:45:54.240 --> 00:45:55.840
And they go, I don't get any events.

00:45:55.950 --> 00:45:58.900
Well, that's because /temp is
actually a symbolic link.

00:45:58.900 --> 00:46:04.560
So if you call real path,
then it'll resolve the symbolic link.

00:46:04.560 --> 00:46:09.530
Now, the first thing that we do is we get
the directory size for that full path.

00:46:11.210 --> 00:46:14.300
So that prints out just what
it sees the initial size is.

00:46:14.320 --> 00:46:18.540
And that get directory size function
builds some internal state for each of

00:46:18.540 --> 00:46:23.100
the directories that it encountered,
and you'll see how we use that later.

00:46:23.240 --> 00:46:26.800
Now we're going to go in
and create the event stream.

00:46:26.840 --> 00:46:29.930
So up here we have the
fseventstreamcreate,

00:46:29.930 --> 00:46:34.090
which is a pretty simple
wrapper function in this case.

00:46:34.270 --> 00:46:38.110
And the first thing that I want
to point out is the context,

00:46:38.190 --> 00:46:40.330
the fseventstreamcontext.

00:46:40.360 --> 00:46:44.580
So your callback function obviously
needs some hook back into your

00:46:44.580 --> 00:46:46.100
application data structures.

00:46:46.100 --> 00:46:48.940
The fseventstreamcontext
is how you do that.

00:46:49.200 --> 00:46:51.500
In this case,
we're going to set our info pointer

00:46:51.870 --> 00:46:55.510
to be the path that we're monitoring,
the root of the hierarchy

00:46:55.530 --> 00:46:57.090
that we want to monitor.

00:46:57.100 --> 00:47:00.160
And so there's some other arguments
that you can fill in if you're a

00:47:00.160 --> 00:47:02.100
sophisticated core foundation app.

00:47:02.100 --> 00:47:04.100
In this case,
we don't have any need for that.

00:47:04.100 --> 00:47:11.370
Next, we create a cfaray of CFStrings and
basically massage the string that we

00:47:11.490 --> 00:47:14.920
got into this cfaray of CFStrings.

00:47:15.100 --> 00:47:17.100
And then we call fseventstreamcreate.

00:47:17.100 --> 00:47:19.100
As I said, you have the callback.

00:47:19.100 --> 00:47:22.050
We have this function
called fseventscallback.

00:47:22.100 --> 00:47:24.100
We pass it the context pointer.

00:47:24.100 --> 00:47:28.100
This is our hook back into the
application data structures.

00:47:28.240 --> 00:47:31.360
Pass in that cfaray,
and then the settings that were specified

00:47:31.360 --> 00:47:34.100
on the command line for the since when,
latency.

00:47:34.100 --> 00:47:36.080
And flags.

00:47:36.150 --> 00:47:37.810
In this case, most of these,
except for latency,

00:47:37.950 --> 00:47:40.100
are not terribly interesting.

00:47:41.630 --> 00:47:48.490
Back in main, once we've got our stream,
we schedule it on the run loop,

00:47:48.510 --> 00:47:56.500
and then we start the event stream for
the event stream that we just created.

00:47:56.500 --> 00:47:59.000
We're not going to talk
about the flush seconds,

00:47:59.010 --> 00:48:00.480
this is a separate thing.

00:48:00.510 --> 00:48:07.500
And then we call cf run loop run,
and off it goes to get our events.

00:48:07.500 --> 00:48:11.500
Now, first off,
there's a bug in this program,

00:48:11.500 --> 00:48:14.070
I'll just tell you that right now,
but I want to go and show

00:48:14.070 --> 00:48:15.500
you how it works in practice.

00:48:15.500 --> 00:48:21.550
So, down here,
I will run -watcher -latency,

00:48:21.790 --> 00:48:28.500
let's be a little aggressive,
and this current directory.

00:48:28.500 --> 00:48:32.180
So it tells me that the initial
size is somewhere over 2

00:48:32.320 --> 00:48:34.500
megabytes for this directory.

00:48:34.500 --> 00:48:37.500
Now, up in this other window,
I'm in a subdirectory there.

00:48:37.680 --> 00:48:43.700
And again, I'll - whoops, gee,
I've got a lot of stuff.

00:48:45.440 --> 00:48:49.500
Right, so it's removing all these things.

00:48:49.500 --> 00:48:52.790
The size of the directory
has gone down a small amount.

00:48:52.790 --> 00:48:56.060
So now what I'm going to do
is I'm going to create a file.

00:48:56.180 --> 00:49:00.140
And again, I'll geek out.

00:49:00.400 --> 00:49:09.900
[Transcript missing]

00:49:11.900 --> 00:49:23.200
[Transcript missing]

00:49:25.710 --> 00:49:29.700
If I remove that file,
the size will go back down.

00:49:29.700 --> 00:49:30.940
Remove junk.

00:49:30.940 --> 00:49:33.560
And you can see that it just
re-scanned the one directory

00:49:33.720 --> 00:49:34.700
where the changes were made.

00:49:34.700 --> 00:49:38.860
So, remove junk, size goes back down
to what it was before,

00:49:38.860 --> 00:49:40.700
and everything is okay.

00:49:40.700 --> 00:49:46.050
Now, if I open this,

00:49:46.460 --> 00:49:52.250
So we have an empty directory,
and you can see that a change was...

00:49:54.730 --> 00:49:59.810
Made to the directory
up above by the finder.

00:50:00.400 --> 00:50:06.690
If I get a new finder window
and go to applications,

00:50:07.890 --> 00:50:11.710
I want to take the calculator
and drag it in here.

00:50:11.790 --> 00:50:14.400
We get a whole bunch more.

00:50:14.400 --> 00:50:17.370
It goes up by about 5 megabytes.

00:50:17.580 --> 00:50:21.710
If I delete that, our size goes back.

00:50:21.820 --> 00:50:23.190
Yeah, 5 or 6 megabytes.

00:50:23.240 --> 00:50:24.180
Empty the trash.

00:50:24.300 --> 00:50:26.520
Yes, I am sure.

00:50:26.570 --> 00:50:27.220
And it's gone.

00:50:27.220 --> 00:50:29.220
So it plays well regardless.

00:50:29.220 --> 00:50:32.310
So that calculator application,
my point of showing that was that

00:50:32.390 --> 00:50:34.910
that's actually a bundle and has
a whole bunch of subdirectories

00:50:35.360 --> 00:50:37.190
and the FS events stuff.

00:50:37.520 --> 00:50:39.440
Tells us about the changes.

00:50:39.440 --> 00:50:46.730
If I do make dir, let's say,
a series of directories, A/B/D,

00:50:46.940 --> 00:50:51.040
get a series of events,
these changes in sizes are small

00:50:51.210 --> 00:50:54.310
because it's just the small
directories that are being created.

00:50:54.320 --> 00:50:59.110
But if I go into A, B, C, D,
and then I go and do the D, D again,

00:50:59.500 --> 00:51:01.790
we get an event.

00:51:01.980 --> 00:51:04.520
And even though we have a
particularly large hierarchy,

00:51:04.520 --> 00:51:08.360
we only have to rescan the one
directory that actually changed.

00:51:08.360 --> 00:51:14.180
That's the whole point of this allowing
your application to be more efficient.

00:51:14.180 --> 00:51:17.120
So again, if I delete it,
the size goes back down.

00:51:17.120 --> 00:51:20.890
Now, going back to the code,
what I want to point

00:51:20.890 --> 00:51:22.800
out is what the bug is.

00:51:23.880 --> 00:51:27.460
Here, you saw I said I got the
initial size of the directory,

00:51:27.580 --> 00:51:31.640
and then I created the stream,
and then I started the stream.

00:51:31.640 --> 00:51:36.460
The problem is that by getting
the directory size first,

00:51:36.500 --> 00:51:39.750
and then starting the event stream,
we've left a window open.

00:51:39.970 --> 00:51:45.120
And we all know that there
can be problems with windows.

00:51:45.870 --> 00:51:50.070
You want to make sure that you're
getting events after you've

00:51:50.070 --> 00:51:52.110
created your initial state.

00:51:52.140 --> 00:51:59.800
So the right thing to do here is to
take this code and to put it after

00:51:59.800 --> 00:52:02.010
we've started the event stream.

00:52:02.120 --> 00:52:08.270
So that once we have our size,
we have our initial size,

00:52:08.390 --> 00:52:13.780
then when we start getting updates,
they'll update.

00:52:13.780 --> 00:52:17.420
There's no window for things
to change without us receiving

00:52:17.420 --> 00:52:18.870
notifications about it.

00:52:18.980 --> 00:52:22.260
So that takes care of that.

00:52:22.260 --> 00:52:24.580
If we go back to the slides.

00:52:28.820 --> 00:52:30.270
All right.

00:52:30.380 --> 00:52:32.740
So, it's a summary of what we did.

00:52:32.890 --> 00:52:36.830
The application that we showed is just
very basic FS events stream usage because

00:52:36.880 --> 00:52:41.230
it's just monitoring a single path,
no complicated stuff with the run loop,

00:52:41.400 --> 00:52:42.800
pretty simple guy.

00:52:42.800 --> 00:52:48.800
So, just for pedagogical purposes,
we kept it straightforward.

00:52:49.000 --> 00:52:51.390
The application creates
its initial state,

00:52:51.390 --> 00:52:54.790
and it lets the callback
drive updates to that state.

00:52:54.900 --> 00:52:57.220
As I said,
whenever we made a change to a directory,

00:52:57.220 --> 00:52:59.520
you know,
somewhere deep in the hierarchy,

00:52:59.520 --> 00:53:03.290
it would update that portion of
the state and reflect the new

00:53:03.300 --> 00:53:05.790
total size of the hierarchy.

00:53:05.800 --> 00:53:08.800
More advanced apps could do
a lot of different things.

00:53:08.800 --> 00:53:10.800
They could use the event history.

00:53:10.800 --> 00:53:12.800
We didn't actually use that in this case.

00:53:12.800 --> 00:53:16.760
They could watch multiple different
hierarchies if they needed to.

00:53:16.880 --> 00:53:17.800
They could create multiple streams.

00:53:17.800 --> 00:53:20.490
You may have a highly
multi-threaded application,

00:53:20.490 --> 00:53:23.800
and different parts of it need
to watch different hierarchies,

00:53:23.800 --> 00:53:26.800
and they want -- they
have different run loops,

00:53:26.800 --> 00:53:28.800
and they need different event streams.

00:53:28.820 --> 00:53:32.750
You can do fancy scheduling --
excuse me -- with start and stop.

00:53:32.880 --> 00:53:38.070
As I said, that's a good way to do clean
sort of start up and tear

00:53:38.070 --> 00:53:40.800
down of your FS event stream.

00:53:40.800 --> 00:53:45.910
You can use custom CFAllocators if
you wanted to and so on.

00:53:46.080 --> 00:53:51.340
Now,
some advice and sort of other things.

00:53:51.410 --> 00:53:53.880
You have to look at
the flags for an event.

00:53:53.880 --> 00:53:58.340
Oh, I suppose actually that's one thing
I didn't show was the callback.

00:53:58.450 --> 00:54:01.350
Can we go back to the code?

00:54:04.300 --> 00:54:07.890
I kind of forgot the punchline,
so to speak.

00:54:07.890 --> 00:54:14.030
So the FSEvents callback is, as I said,
it gets a couple of standard things.

00:54:14.180 --> 00:54:18.590
The context pointer is passed to it,
which in our case is the full

00:54:18.800 --> 00:54:21.100
path that we are monitoring.

00:54:21.190 --> 00:54:28.070
And then for each of the events,
it goes through and takes a look at them.

00:54:28.070 --> 00:54:31.050
Now, in this case-- let me just make
this just a wee bit bigger.

00:54:32.600 --> 00:55:25.100
[Transcript missing]

00:55:29.160 --> 00:55:32.130
So, dropped events are rare,
but you do need to handle them,

00:55:32.150 --> 00:55:34.740
as I just showed in the callback.

00:55:34.740 --> 00:55:38.730
The types of re-scanning that you
may have to do are starting at some

00:55:38.770 --> 00:55:43.490
point in the hierarchy and below,
or everything, which are really just

00:55:43.590 --> 00:55:45.700
variants of the same thing.

00:55:45.720 --> 00:55:48.140
Another thing that we discovered,
or not discovered,

00:55:48.140 --> 00:55:51.880
or sort of realized you could do,
is you can create token events.

00:55:51.980 --> 00:55:54.950
So you don't have to be passive
and just listen to what happens.

00:55:54.990 --> 00:55:58.690
You can actually do things and
observe those events coming through

00:55:58.690 --> 00:56:00.540
the pipeline on the other end.

00:56:00.540 --> 00:56:04.980
You can use this to kind of wrap the
beginning and end of some other operation

00:56:04.980 --> 00:56:07.150
that someone may be doing on your behalf.

00:56:07.250 --> 00:56:10.620
So you may create an initial,
some directory or file

00:56:10.810 --> 00:56:12.470
with a well-known name.

00:56:12.530 --> 00:56:15.210
You see that the
modification comes through,

00:56:15.230 --> 00:56:18.170
and you observe that it's there,
and then a series of

00:56:18.170 --> 00:56:20.260
other events may happen.

00:56:20.260 --> 00:56:22.660
And then you,
when that operation is complete,

00:56:22.770 --> 00:56:24.420
you do a token event at the end.

00:56:24.430 --> 00:56:30.470
And so you sort of have begin-end
pairs to know when things are finished.

00:56:30.890 --> 00:56:33.470
As I mentioned,
you want to be careful of leaving

00:56:33.800 --> 00:56:37.980
windows open between when you generate
your state and when you start receiving

00:56:37.980 --> 00:56:40.290
events that would update that state.

00:56:40.490 --> 00:56:43.890
It's very important because
they may be small windows,

00:56:43.890 --> 00:56:47.760
but you don't want to miss
things that would cause you

00:56:47.760 --> 00:56:50.060
to have out-of-date state.

00:56:51.160 --> 00:56:53.830
Now, FS events isn't the only thing.

00:56:53.840 --> 00:56:57.670
It's a good thing, but it's not always
appropriate in all cases.

00:56:57.680 --> 00:57:00.960
A lot of times you go, oh, wow, new API,
got to use it.

00:57:01.060 --> 00:57:04.440
And FS events framework
is a good solution,

00:57:04.440 --> 00:57:05.570
but it's not the only one.

00:57:05.580 --> 00:57:08.260
You may want to consider just using a KQ.

00:57:08.260 --> 00:57:11.460
There's no need to change if you're
only monitoring a single directory.

00:57:11.460 --> 00:57:15.490
If you have a spool directory and there's
no subdirectories or anything like that,

00:57:15.550 --> 00:57:19.530
a KQ is actually probably lighter
weight and more efficient,

00:57:19.540 --> 00:57:23.360
less trouble to use than
using the FS events framework.

00:57:23.360 --> 00:57:26.330
If you just have to
check a couple of files,

00:57:26.340 --> 00:57:30.280
did some particular preference
file change when I wasn't running,

00:57:30.280 --> 00:57:32.930
you would not use the
FS events framework.

00:57:33.000 --> 00:57:36.240
Simply stack the file and get
the information that you need.

00:57:36.260 --> 00:57:41.000
FS events is best when you've got a
really big hierarchy that you want

00:57:41.000 --> 00:57:45.500
to monitor or know about changes to,
or you need a history of changes.

00:57:45.500 --> 00:57:48.260
If you don't actually need
the history and so on,

00:57:48.260 --> 00:57:53.440
it's probably more straightforward to
use a KQ if you only have a few files,

00:57:53.480 --> 00:57:58.460
or you only need directory changes
for a single level of hierarchy.

00:58:00.960 --> 00:58:04.480
Now, as we've been developing things,
we noticed there's some issues.

00:58:04.480 --> 00:58:07.220
So there are going to
be some changes coming.

00:58:07.230 --> 00:58:12.060
We realize that you're going to have
to have a GUID for an event stream

00:58:12.100 --> 00:58:16.890
to uniquely identify it so that an
event ID is really paired with the

00:58:16.890 --> 00:58:19.620
event stream from which it comes.

00:58:19.800 --> 00:58:23.780
So that if for some reason you stored
an event ID and then let's say someone

00:58:23.830 --> 00:58:27.030
dragged copy stuff to another machine,
that event ID is no

00:58:27.030 --> 00:58:28.860
longer really meaningful.

00:58:28.860 --> 00:58:31.780
You have to have a way to know
that the underlying event stream

00:58:31.780 --> 00:58:33.660
that you're getting is different.

00:58:33.700 --> 00:58:37.900
So it's really going to be a pair,
a GUID for the event stream

00:58:37.900 --> 00:58:40.180
from which the event ID came.

00:58:40.200 --> 00:58:45.600
We're probably going to also introduce
a special event that indicates a volume

00:58:45.600 --> 00:58:48.340
was modified outside of our purview.

00:58:48.470 --> 00:58:51.000
That is, somebody changed it.

00:58:51.010 --> 00:58:54.150
Like if you have an external
FireWire drive and it's taken

00:58:54.150 --> 00:58:57.940
somewhere else and modified and
then comes back to a Leopard system,

00:58:58.100 --> 00:59:00.930
you need to know about that
because it means that you're

00:59:00.930 --> 00:59:02.680
going to have to do a full rescan.

00:59:02.800 --> 00:59:04.800
And there's nothing that
we can do about that.

00:59:04.800 --> 00:59:07.570
There's no magic in the world
in the sense of if somebody else

00:59:07.580 --> 00:59:10.620
makes changes and they don't
record the FS event history,

00:59:10.680 --> 00:59:12.480
there's no way to know about that.

00:59:13.820 --> 00:59:17.700
We will probably also
have some API cleanups,

00:59:17.700 --> 00:59:22.040
so that some little things like the
paths to the callback may become

00:59:22.040 --> 00:59:26.620
CFStrings instead of just being
standard C strings like they are now.

00:59:26.720 --> 00:59:29.610
On the way in,
you specify a CFArray of CFStrings,

00:59:29.610 --> 00:59:31.860
but then the callback
just gets C strings.

00:59:31.980 --> 00:59:36.180
So there's some little inconsistencies
there that we'll probably try to resolve.

00:59:36.430 --> 00:59:39.530
Again,
we're also very open to feedback and

00:59:39.530 --> 00:59:42.620
hearing what people are interested in.

00:59:43.440 --> 00:59:46.960
So, in summary,
the FSEvents framework provides

00:59:46.960 --> 00:59:51.390
you with a change notification
for any file hierarchy or file

00:59:51.390 --> 00:59:54.400
hierarchies that you want to watch.

00:59:54.500 --> 00:59:59.590
Monitoring a file hierarchy provides
notifications for changes to

00:59:59.590 --> 01:00:03.400
directories within that hierarchy.

01:00:03.400 --> 01:00:07.510
Events are coarse-grained, as I said,
they are directory-level changes,

01:00:07.510 --> 01:00:09.380
and it gives you a full event history.

01:00:09.400 --> 01:00:13.390
The purpose of this is to allow your
application to be more efficient

01:00:13.390 --> 01:00:17.890
at processing updates and changes,
so that you don't have to just

01:00:17.890 --> 01:00:24.260
rescan an entire hierarchy,
or poll, or periodically stat things

01:00:24.390 --> 01:00:26.400
to find out about changes.

01:00:26.530 --> 01:00:32.550
So, that's the FSEvents framework,
and I guess that concludes things,

01:00:32.550 --> 01:00:36.770
and we have, I think,
about 15 minutes for Q&A.

01:00:43.640 --> 01:00:46.760
I just also wanted to mention that
we're starting a filesystems dev list,

01:00:46.910 --> 01:00:47.480
a public list.

01:00:47.480 --> 01:00:50.240
You can find it at list.apple.com
where you can get eyes like Dominic's,

01:00:50.240 --> 01:00:51.440
have discussions.

01:00:51.480 --> 01:00:54.190
The filesystems engineers will
be available tomorrow morning,

01:00:54.190 --> 01:00:57.330
9am, in the Kernel Extensions Lab,
and also at the Campus Beer Bash.
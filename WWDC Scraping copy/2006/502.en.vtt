WEBVTT

00:00:11.300 --> 00:00:12.300
Welcome everybody.

00:00:12.300 --> 00:00:14.660
Well, if even the voice of
God can't botch my name,

00:00:14.660 --> 00:00:15.780
I really have to change it.

00:00:15.780 --> 00:00:17.050
I am Francois Jouaux.

00:00:17.080 --> 00:00:20.010
I'm the
Java Technologies Engineering Manager and

00:00:20.010 --> 00:00:22.330
we have
a fun-packed session this morning,

00:00:22.330 --> 00:00:23.930
so we'll start right along.

00:00:23.930 --> 00:00:31.120
The agenda we are going to cover today is
the state of the art of Java on Mac OS X.

00:00:31.120 --> 00:00:34.970
Answer some common Java questions.

00:00:35.210 --> 00:00:38.290
talk about Java SE 6
which is fast coming,

00:00:38.290 --> 00:00:42.070
and finally cover
IDE support on the platform.

00:00:44.720 --> 00:00:49.650
What I would like you to do by
the end of this session is to keep

00:00:49.700 --> 00:00:51.600
on attending the Java sessions.

00:00:51.600 --> 00:00:54.610
They are mostly bright and
early at 9:00 AM in the morning,

00:00:54.610 --> 00:00:58.680
so why not take a little,
put a little bit of Java in your morning

00:00:58.680 --> 00:01:01.040
routine so Cocoa can wait for later.

00:01:01.800 --> 00:01:05.300
Use new Java SE technologies on IDEs.

00:01:05.320 --> 00:01:09.080
And after leaving W3C,
keep telling the world how strong

00:01:09.080 --> 00:01:12.380
the Java community is on Mac OS X.

00:01:15.640 --> 00:01:19.780
So to keep you awake,
I have this new button popping up here

00:01:19.780 --> 00:01:25.880
and there that will indicate that we have
exciting features on almost every slide.

00:01:25.880 --> 00:01:27.980
Exciting new features
on almost every slide.

00:01:27.980 --> 00:01:32.170
And I used to have a jingle,
but I guess no sound.

00:01:34.790 --> 00:01:36.460
Who is it for?

00:01:36.460 --> 00:01:38.440
Let's have a show of hands here.

00:01:38.510 --> 00:01:41.220
We have students in this room.

00:01:41.650 --> 00:01:49.360
A few researchers, scientists,
seasoned Java developers,

00:01:49.360 --> 00:01:51.710
that makes the bulk of it.

00:01:52.800 --> 00:01:56.260
And we're all striving to
build consumer products,

00:01:56.270 --> 00:02:00.590
whether you are all consumers and you're
building either websites for consumers

00:02:00.590 --> 00:02:02.560
or shrink-wrapped Java applications.

00:02:02.560 --> 00:02:06.790
But the consumer is always in your mind.

00:02:06.840 --> 00:02:10.010
Why is Mac OS X the best Java platform?

00:02:11.400 --> 00:02:16.680
We believe this is the most
tightly integrated Java in any OS.

00:02:16.790 --> 00:02:19.160
We keep the Java lean and fit.

00:02:19.210 --> 00:02:23.570
Java on Mac OS X is very
tight to the underlying OS,

00:02:23.610 --> 00:02:24.830
the core frameworks.

00:02:24.840 --> 00:02:26.800
And we like it this way,
and that's what this

00:02:26.800 --> 00:02:29.020
session will be about.

00:02:30.270 --> 00:02:34.570
On the contrary, on Windows,
I think you see where I'm getting there,

00:02:34.570 --> 00:02:37.200
Java is bloated and inconsistent.

00:02:37.200 --> 00:02:40.350
You have to carry your
Java version with you.

00:02:40.390 --> 00:02:42.750
If you want to shrink
wrap an application,

00:02:42.750 --> 00:02:47.200
you have to instruct your customer to
go and download the latest security

00:02:47.200 --> 00:02:50.200
fixes or the latest packages from Sun.

00:02:50.200 --> 00:02:52.200
Otherwise,
your application will not work.

00:02:52.200 --> 00:02:55.990
We don't like this and we
won't follow this model.

00:02:59.400 --> 00:03:02.790
So as a summary,
every consumer has the right

00:03:02.790 --> 00:03:04.780
version of Java in their OS.

00:03:04.780 --> 00:03:08.350
It's bundled, pre-installed,
and continually updated through the

00:03:08.350 --> 00:03:10.660
automated software update system.

00:03:11.060 --> 00:03:14.490
Every developer also has
integrated SDK tools that

00:03:14.520 --> 00:03:18.990
work with Java and excellent
documentation at their fingertips.

00:03:19.950 --> 00:03:23.330
Other bundle extensions
are JAI on Java 3D,

00:03:23.330 --> 00:03:30.630
Live Connect, and Web Start,
which is fast becoming the best way to

00:03:30.630 --> 00:03:33.100
deploy applications on other platforms.

00:03:33.100 --> 00:03:35.960
And we support it as well on Mac OS X.

00:03:37.110 --> 00:03:39.720
In the enterprise,
I want you to check out the

00:03:39.720 --> 00:03:43.000
new Java server options that
are coming with Leopard,

00:03:43.000 --> 00:03:45.670
and we'll talk more about them later.

00:03:46.170 --> 00:03:51.940
And for development and deployment,
we include a set of very powerful tools,

00:03:51.990 --> 00:03:54.640
WebObjects,
which is our own application server,

00:03:54.680 --> 00:03:56.800
Apache Tomcat, and JBoss.

00:03:56.930 --> 00:04:01.390
These are all pure Java project tools.

00:04:02.870 --> 00:04:06.880
Ease of use and flexibility.

00:04:06.910 --> 00:04:11.640
Again, your system is pre-configured
with a default Java,

00:04:11.640 --> 00:04:14.680
but it also has legacy
versions of Java bundled.

00:04:14.680 --> 00:04:17.840
And through a preferences application,
you can switch back and forth.

00:04:17.920 --> 00:04:25.790
You will never be able to override the
developer's choice in the application,

00:04:25.790 --> 00:04:26.280
but for your applets and
for your Java command line,

00:04:26.280 --> 00:04:26.280
you can do so.

00:04:26.800 --> 00:04:31.360
To paraphrase someone well known,
this is Unix Java with taste.

00:04:31.400 --> 00:04:38.510
We make all the Java command line tools
available at their correct Unix location.

00:04:39.300 --> 00:04:43.540
and I forgot we have
bundled IDEs and tools,

00:04:43.540 --> 00:04:47.920
Xcode, Shark,
and new X-Ray and D-Trace from Sun.

00:04:47.920 --> 00:04:49.920
X-Ray from Apple, D-Trace from Sun.

00:04:52.840 --> 00:04:55.790
Quality, compatibility, and performance.

00:04:55.900 --> 00:04:59.540
The Java team has fixed more
than 1,800 bugs this year.

00:04:59.580 --> 00:05:02.040
So I'd like to applaud the
Java team and their manager,

00:05:02.040 --> 00:05:04.820
but they deserve some credit.

00:05:08.350 --> 00:05:13.020
This is much more than last year
and we're running out of bugs fast,

00:05:13.020 --> 00:05:14.890
so we need your help.

00:05:16.240 --> 00:05:19.150
We go beyond the Java compatibility kit.

00:05:19.210 --> 00:05:23.510
We are in constant discussion with
SANS engineers regarding unwritten specs.

00:05:23.560 --> 00:05:29.370
We are always striving to make
Mac OS X Java behave as well as,

00:05:29.470 --> 00:05:34.900
behave much like Windows Java,
but keeping all look and feel.

00:05:34.900 --> 00:05:40.900
And this is a very,
very tight line to work on.

00:05:41.170 --> 00:05:45.950
We have an enhanced in-house
regression test suite based on JUnit.

00:05:46.060 --> 00:05:49.180
And the reason I mentioned this
is that if you provide your own

00:05:49.180 --> 00:05:53.400
JUnit test in your bug reports,
you have good chances that

00:05:53.400 --> 00:05:55.140
we will incorporate them.

00:05:55.180 --> 00:05:59.200
And we will never regress
on any of your bug files.

00:06:01.610 --> 00:06:05.070
The number of critical applications
that are based on Java on

00:06:05.070 --> 00:06:06.780
Mac OS X keeps increasing.

00:06:06.880 --> 00:06:10.260
With Leopard,
we expect to have more than 72 of them.

00:06:10.360 --> 00:06:13.770
And this is a great progress,
and it shows that Java on the

00:06:13.770 --> 00:06:16.660
desktop is alive and strong.

00:06:18.970 --> 00:06:20.090
Performance.

00:06:20.130 --> 00:06:21.050
Is it fast enough?

00:06:21.120 --> 00:06:24.580
Well, when Tiger shipped,
this was the fastest

00:06:24.580 --> 00:06:26.840
Java we had ever shipped.

00:06:26.890 --> 00:06:28.720
When Leopard will ship,
it will still be true.

00:06:28.740 --> 00:06:31.060
We are making great
progress in performance.

00:06:31.110 --> 00:06:37.790
And we now have really a good
apples-to-apples way of comparing Java.

00:06:37.850 --> 00:06:43.360
We can run Windows on Bootcamp,
run Java on Mac OS X and on Bootcamp,

00:06:43.400 --> 00:06:48.210
and we can really see the exact
performance of our frameworks.

00:06:49.780 --> 00:06:50.620
Let's take an example.

00:06:50.620 --> 00:06:52.760
This is straight out of our labs.

00:06:52.780 --> 00:06:57.900
The SciMark scientific benchmark
is well known in the industry.

00:06:58.080 --> 00:07:02.700
It's used to benchmark the
Java performance for both

00:07:02.700 --> 00:07:04.990
software and hardware.

00:07:05.070 --> 00:07:11.070
And you can see that we've been making
progress on our hardware since Java 5.

00:07:11.280 --> 00:07:17.470
Java SE 6 client is already much
faster than a J2 SE 5 client.

00:07:17.580 --> 00:07:19.870
What's interesting is the server version.

00:07:19.960 --> 00:07:24.270
It's now much, much faster than anything
we have had in the past,

00:07:24.270 --> 00:07:27.970
and it's 20% better than the
currently published number.

00:07:27.980 --> 00:07:31.740
Mac OS X has never been
better than rank number 10.

00:07:31.740 --> 00:07:34.420
If we were to ship today,
it would be rank number

00:07:34.420 --> 00:07:36.110
1 with a 20% margin.

00:07:36.120 --> 00:07:39.940
So imagine what's going to
happen when we ship tomorrow.

00:07:46.440 --> 00:07:50.620
Similarly, startup times are improving.

00:07:50.890 --> 00:07:53.950
Two very large applications that
take a very long time to start

00:07:53.970 --> 00:07:57.570
up are IntelliJ IDEA and Eclipse.

00:07:57.610 --> 00:08:00.820
They both used to start
between 12 and 20 seconds,

00:08:00.840 --> 00:08:02.810
depending whether you were
running with the client

00:08:02.820 --> 00:08:05.310
compiler or the server compiler.

00:08:05.370 --> 00:08:08.460
Today on the new hardware,
they are at five seconds.

00:08:08.470 --> 00:08:13.300
And the gap between the client compiler
and the server compiler is shrinking.

00:08:13.300 --> 00:08:16.890
And this goes in the direction
that we're taking to try to merge

00:08:16.890 --> 00:08:18.400
the two technologies together.

00:08:18.400 --> 00:08:23.990
And this is a goal
that Sun is working on.

00:08:27.450 --> 00:08:31.210
We have always lagged in alias drawing.

00:08:31.260 --> 00:08:33.500
On Mac OS X,
everything is anti-aliased and

00:08:33.500 --> 00:08:37.700
we are very performant there.

00:08:37.700 --> 00:08:42.350
But on Windows,
Java is drawn with alias graphics.

00:08:42.360 --> 00:08:45.880
And when we compare
all drawing on Windows,

00:08:45.880 --> 00:08:50.320
Windows drawing to all drawing,
if we are fair,

00:08:50.320 --> 00:08:52.280
we should compare graphics
alias and we are lagging.

00:08:52.280 --> 00:08:56.590
With the new OpenGL pipeline,
we've made great progress.

00:08:56.600 --> 00:09:01.270
The OpenGL pipeline will be
available in Java SE 6 and it's

00:09:01.280 --> 00:09:07.460
coming from Sun on leveraging the
OpenGL libraries available on Mac OS X.

00:09:11.730 --> 00:09:14.360
Let's answer some common Java questions.

00:09:14.450 --> 00:09:21.320
So these are questions that are
recurring on our Java dev mailing list,

00:09:21.320 --> 00:09:25.030
and I'd like to close
them once and for all.

00:09:25.030 --> 00:09:28.300
I'd like to prove that
we are listening to you.

00:09:30.700 --> 00:09:33.470
Very often we get, well,
every time we have a new release,

00:09:33.470 --> 00:09:36.290
we get asked, can we get Java previews
on a shipping OS?

00:09:36.300 --> 00:09:41.370
This year we've listened to you,
and Java SE 6 previews have been

00:09:41.370 --> 00:09:46.130
made available on Mac OS X Tiger as
soon as we started working on them.

00:09:46.140 --> 00:09:49.740
Today I'm happy to announce that
we'll have a new developer preview.

00:09:49.740 --> 00:09:54.150
If it's not available yet, yes it is,
live, at this minute.

00:09:54.200 --> 00:09:55.930
Go ahead and download it.

00:09:55.930 --> 00:10:00.400
It's packed with the OpenGL pipeline
and all the goodies from Sun.

00:10:00.700 --> 00:10:06.150
And it's also available
on the Leopard DVD.

00:10:09.460 --> 00:10:13.000
I'd like to take this opportunity
to thank you because your testing

00:10:13.160 --> 00:10:18.990
and your feedback has provided us
more than 180 great bugs to work on.

00:10:22.160 --> 00:10:26.490
How long will it take to
fix the bugs I just filed?

00:10:26.590 --> 00:10:29.490
For a lot of us,
the Apple bug reporting process

00:10:29.500 --> 00:10:33.390
is a lot like a black hole,
a lot of you.

00:10:33.440 --> 00:10:35.610
We know this is not true.

00:10:35.670 --> 00:10:39.400
All bugs are screened within 48 hours.

00:10:40.810 --> 00:10:44.970
And out of these 1,800 bugs
that we have fixed last year,

00:10:45.080 --> 00:10:48.350
a third were developer-originated
and were fixed.

00:10:48.360 --> 00:10:53.410
And that represents 75% of the bugs
that were originated by you last year.

00:10:53.420 --> 00:10:59.530
So some bugs may take longer than others,
but on average, we do not sit more

00:10:59.530 --> 00:11:02.200
than 100 days on a bug.

00:11:02.200 --> 00:11:06.620
And it used to be like 200
days in the previous year.

00:11:06.740 --> 00:11:08.060
So we are making great progress there.

00:11:08.060 --> 00:11:11.350
Our time to release,
or at least to developer release,

00:11:11.350 --> 00:11:12.460
is much faster.

00:11:15.490 --> 00:11:16.800
When is the next Java coming?

00:11:16.910 --> 00:11:23.590
So as soon as Sun comes up with their
pre-alpha version of Java SE 20,

00:11:23.660 --> 00:11:26.150
we are asked to provide it.

00:11:27.260 --> 00:11:31.310
And we are following, indeed,
some releases of Java IC6 Beta and

00:11:31.380 --> 00:11:33.440
other Java updates very closely.

00:11:33.440 --> 00:11:36.360
We cannot worry just
about the latest Java.

00:11:36.360 --> 00:11:44.600
We have to go back on 1.3, 1.4, 1.5,
and on all the OS we still support.

00:11:46.270 --> 00:11:51.200
The state of the art on Tiger is
that Java 1.3.1 is duplicated,

00:11:51.270 --> 00:11:56.620
and for Java 1.4 and J2SE5,
we are very close to the latest

00:11:56.620 --> 00:11:59.170
updates available from Sun.

00:11:59.200 --> 00:12:03.750
And Java ICC 6 previews are at beta 88,
which is as well a few points

00:12:03.750 --> 00:12:06.350
behind the latest beta.

00:12:08.950 --> 00:12:11.350
How do I make the latest
Java the default on my system?

00:12:11.360 --> 00:12:15.680
So this question accompanies--
is always coming after developers

00:12:15.680 --> 00:12:17.880
install a developer preview.

00:12:17.880 --> 00:12:21.570
They want to take advantage of it
or stop taking advantage of it.

00:12:21.950 --> 00:12:26.870
And again, I talked about this earlier,
we have an updated Java preferences

00:12:26.900 --> 00:12:31.210
application that lets you specify
the default Java for applets,

00:12:31.320 --> 00:12:34.740
command lines, and applications.

00:12:34.760 --> 00:12:37.440
There is no more mucking
around with symlink,

00:12:37.440 --> 00:12:40.700
copying around current JDK directories,
and so on.

00:12:40.700 --> 00:12:43.650
It's clean, easy, and it's foolproof.

00:12:44.450 --> 00:12:47.630
And the UI hasn't changed,
it still has the same location,

00:12:47.630 --> 00:12:48.880
so it's just more powerful.

00:12:53.170 --> 00:12:57.350
Why isn't Apple's
Java as stable as Sun's?

00:12:57.450 --> 00:13:01.800
We're working hard to
correct this misconception.

00:13:02.610 --> 00:13:08.770
Only 35 bugs were filed on J2SE 5
since the April 2006 release.

00:13:08.770 --> 00:13:12.500
In April 2006, J2SE 5 became the
default Java on Mac OS X.

00:13:12.500 --> 00:13:15.500
It's been four months,
35 bugs have been filed.

00:13:15.500 --> 00:13:19.000
Anybody wants to guess
how many downloads we had?

00:13:20.790 --> 00:13:22.390
6.5 million downloads.

00:13:22.390 --> 00:13:27.700
6.5 million people suffered through 45
megabyte download on a slow connection.

00:13:27.700 --> 00:13:32.010
They used Java and didn't
find anything to report.

00:13:34.770 --> 00:13:35.690
It's very cool.

00:13:35.710 --> 00:13:37.640
Everything I've tried
has worked very well.

00:13:37.640 --> 00:13:39.800
Congratulations to the team.

00:13:39.910 --> 00:13:45.020
Someone we really liked sent
us an email about J2SE 6 DP1s.

00:13:45.030 --> 00:13:49.350
And all indication is that even
our first DP was very stable.

00:13:49.390 --> 00:13:51.000
And this person is James Gosling.

00:13:51.060 --> 00:13:55.430
And I'd like to welcome him on
stage to say this by himself.

00:14:03.800 --> 00:14:05.610
Hi, Francois.

00:14:05.650 --> 00:14:06.620
Thanks for inviting me up.

00:14:06.620 --> 00:14:12.350
He also asked me to show off
a few things in NetBeans.

00:14:12.400 --> 00:14:17.360
And so if we can get my screen up here.

00:14:20.240 --> 00:14:21.170
Can I have my screen up?

00:14:21.200 --> 00:14:26.080
Hello.

00:14:26.190 --> 00:14:27.620
Thank you.

00:14:28.100 --> 00:14:29.620
So this is NetBeans.

00:14:29.620 --> 00:14:36.180
This is the tool that I've been helping
out with for the last several years.

00:14:36.180 --> 00:14:38.860
I'm sort of the CTO of
the Java organization,

00:14:38.860 --> 00:14:40.920
which means I kind of
get to kibitz a lot.

00:14:40.920 --> 00:14:42.030
I don't actually get to work.

00:14:42.040 --> 00:14:44.140
I just get to kibitz.

00:14:44.580 --> 00:14:47.850
But this is my favorite toy
to play with these days.

00:14:47.990 --> 00:14:50.640
And it's a very nice little IDE.

00:14:50.640 --> 00:14:52.450
It's got all kinds of little eye candy.

00:14:52.460 --> 00:14:58.210
And one of my favorite little hacks
from lately is this little navigator,

00:14:58.210 --> 00:15:02.940
which is kind of a scroll bar that
gives you a fisheye lens version.

00:15:02.960 --> 00:15:08.330
And the interesting thing about
this is that various people have

00:15:08.330 --> 00:15:12.400
done sort of fisheye lens viewers,
where they sort of Greek the

00:15:12.400 --> 00:15:15.230
text by drawing little lines.

00:15:15.290 --> 00:15:16.620
This one doesn't do that.

00:15:16.620 --> 00:15:18.640
This one actually draws the text.

00:15:18.640 --> 00:15:25.320
All the little gray things you see
are the text drawn really small.

00:15:25.320 --> 00:15:29.680
And so this is actually drawing the
entire text document over and over again.

00:15:29.680 --> 00:15:33.400
And so you can see how unbelievably
fast text rendering is on this thing,

00:15:33.400 --> 00:15:39.080
because it's repainting the whole
document at every slide of the mouse.

00:15:39.080 --> 00:15:41.480
And it's actually quite smooth.

00:15:41.480 --> 00:15:43.180
It lets me get around very quickly.

00:15:46.340 --> 00:15:47.870
uh...

00:15:51.100 --> 00:16:03.700
[Transcript missing]

00:16:04.050 --> 00:16:06.050
You know,
it's got all the sort of inline help.

00:16:06.060 --> 00:16:11.460
It even has inline Java doc
that sort of pops up.

00:16:11.460 --> 00:16:15.020
You can do things like, you know,
as your-- you know,

00:16:15.080 --> 00:16:18.460
you can set breakpoints,
and you can run things.

00:16:18.460 --> 00:16:21.240
One of the things that we do--

00:16:21.990 --> 00:16:25.780
is, is, is, we actually bundle all the,
all the enterprise facilities

00:16:25.780 --> 00:16:28.290
together at the same time.

00:16:28.700 --> 00:16:32.220
So this is actually just
deploying to Tomcat,

00:16:32.230 --> 00:16:36.120
starting up Tomcat,
and thank you very much.

00:16:41.100 --> 00:16:53.700
and the Tomcat Ghost Blat.

00:16:53.700 --> 00:16:53.700
Oh no, sorry.

00:16:53.700 --> 00:16:53.700
I got a brain of a duck.

00:16:53.700 --> 00:16:53.700
It hit the breakpoint.

00:16:54.590 --> 00:16:58.520
So you see all the displays
of the HTTP requests,

00:16:58.520 --> 00:17:01.940
and I can... I'll delete the breakpoint.

00:17:01.940 --> 00:17:05.760
I'd forgotten that I had started
this guy a little bit strangely.

00:17:05.820 --> 00:17:11.380
So let's just sort of continue
out of that and get back.

00:17:14.280 --> 00:17:18.600
and you can see how it was, you know,
it's actually been, you know,

00:17:18.600 --> 00:17:19.350
booted this thing up.

00:17:19.380 --> 00:17:24.170
The ability to do remote debugging
in NetBeans is a really nice feature,

00:17:24.170 --> 00:17:26.320
particularly of deployed app servers.

00:17:26.320 --> 00:17:30.740
Right now I'm using Tomcat,
but there's about half a dozen

00:17:30.810 --> 00:17:34.520
different app servers that it
supports that you can deploy and

00:17:34.520 --> 00:17:36.150
control and all the rest of it.

00:17:36.210 --> 00:17:39.250
One of the demos that I wanted
to be able to show was doing

00:17:39.300 --> 00:17:41.480
remote debugging on cell phones.

00:17:42.440 --> 00:17:45.940
There's a lot of facilities
in NetBeans that are all about

00:17:45.940 --> 00:17:50.030
developing stuff on cell phones,
doing remote debugging of them.

00:17:50.040 --> 00:17:55.640
Unfortunately, the remote debugging stuff
doesn't work from OS X.

00:17:55.640 --> 00:18:02.910
It works great on Windows,
but it actually does work.

00:18:02.940 --> 00:18:10.000
It's just a little too shaky
for me to be comfortable with.

00:18:10.120 --> 00:18:12.250
All right, there you are.

00:18:12.440 --> 00:18:13.460
- Yeah.

00:18:13.970 --> 00:18:18.080
All right,
so here's another little thing.

00:18:18.080 --> 00:18:20.640
Here's an app.

00:18:20.770 --> 00:18:23.680
One of the nice features
that NetBeans has got is a

00:18:23.680 --> 00:18:25.380
bunch of stuff for profiling.

00:18:25.380 --> 00:18:30.180
And I apologize, I've got a lot of stuff
loaded on this thing,

00:18:30.180 --> 00:18:32.200
and it's spending a lot of time paging.

00:18:32.200 --> 00:18:35.040
So you can profile all kinds of stuff.

00:18:35.120 --> 00:18:39.300
Here I'm just going to do some
relatively generic profiling,

00:18:39.300 --> 00:18:40.680
and I'm going to run the app.

00:18:41.620 --> 00:18:45.250
And this app actually is
the slide program that I use

00:18:45.250 --> 00:18:47.500
whenever I'm doing slides.

00:18:47.560 --> 00:18:49.630
Page, page, page, page, page.

00:18:49.630 --> 00:18:51.770
I can get a little disk drive going.

00:18:51.780 --> 00:18:54.680
I've only got two gigs
of RAM on this thing.

00:18:58.750 --> 00:19:01.460
Yeah, actually,
most of the memory is the app

00:19:01.460 --> 00:19:04.540
that I'll show at the end.

00:19:04.540 --> 00:19:10.090
And it, unfortunately, has a timer task.

00:19:10.630 --> 00:19:17.440
So now it's instrumenting it
and starting up anytime soon.

00:19:17.440 --> 00:19:18.840
Yes.

00:19:22.060 --> 00:19:23.320
and I'm not using JDK 6.

00:19:23.420 --> 00:19:26.680
JDK 6 actually makes a real difference.

00:19:26.680 --> 00:19:31.980
So this is my little slide app.

00:19:32.020 --> 00:19:34.700
So I'll just sort of play
around with it for a little bit.

00:19:34.700 --> 00:19:39.520
All kinds of fun statistics
in the Java world.

00:19:39.700 --> 00:19:42.910
We did 240 million
JRE downloads last year,

00:19:42.970 --> 00:19:46.300
8 million downloads of the JDK.

00:19:46.300 --> 00:19:49.830
That's for developers and that
counts like Morgan Stanley or

00:19:49.830 --> 00:19:51.300
Lehman Brothers as one.

00:19:52.010 --> 00:19:57.090
One of the nice things we do on
Windows is we've got bundling deals

00:19:57.090 --> 00:20:03.400
with almost all of the manufacturers so
your customers don't have to download.

00:20:03.640 --> 00:20:07.340
You know, they announced the 64-bit
support in the Mac OS,

00:20:07.340 --> 00:20:09.800
in the Mac JVM just recently.

00:20:09.800 --> 00:20:12.860
And it's actually been out for a while,
so don't worry about it.

00:20:12.860 --> 00:20:14.580
It's actually very solid,
very mission critical.

00:20:14.600 --> 00:20:17.720
And we actually qualify it
all to about 500 gigabytes.

00:20:17.720 --> 00:20:22.740
One of the fun things that I've been
involved with is all the real-time work.

00:20:22.800 --> 00:20:25.120
This is a really great chart.

00:20:25.120 --> 00:20:28.720
You see here, there's a,
this is two app servers,

00:20:28.720 --> 00:20:30.420
the real-time and the
non-real-time server.

00:20:30.420 --> 00:20:33.490
The blue is the non-real-time,
and the horizontal axis is

00:20:33.490 --> 00:20:35.100
kind of the response time.

00:20:35.100 --> 00:20:39.900
And you can see that the real-time
app server completes almost all

00:20:39.900 --> 00:20:42.970
requests in 2.4 milliseconds.

00:20:42.980 --> 00:20:46.470
And there's actually two peaks here,
you can't really see it.

00:20:46.520 --> 00:20:49.200
The other one's at 11 milliseconds,
which turns out to be a TCP bug.

00:20:49.200 --> 00:20:52.930
But, you know,
getting those things all sort of down

00:20:52.930 --> 00:20:55.950
there has been a really fun thing for us.

00:20:55.960 --> 00:20:58.770
And of course, you know,
this stuff all works a

00:20:58.830 --> 00:21:00.400
lot better in Mustang.

00:21:00.420 --> 00:21:07.400
Now let's do a little bit of typing
to warm up our performance stats.

00:21:16.020 --> 00:21:21.100
All right, so let's call that done.

00:21:21.100 --> 00:21:23.380
Save before exiting.

00:21:23.390 --> 00:21:26.120
No, I don't want to save that slide set.

00:21:26.120 --> 00:21:29.310
And yes, I do want to see the profile.

00:21:30.380 --> 00:21:35.170
So now we've seen what the
profiling has spit out for us.

00:21:35.180 --> 00:21:36.160
There's the main thread.

00:21:36.160 --> 00:21:40.560
There's a bunch of stuff that
spends doing initialization.

00:21:40.560 --> 00:21:46.160
Here's actually where
things like painting happen.

00:21:46.160 --> 00:21:50.660
And you can sort of do
all kinds of breakdown.

00:21:50.660 --> 00:21:56.180
You can get an amazing amount
of detail to really see where

00:21:56.180 --> 00:21:59.240
all your performance is going.

00:22:00.200 --> 00:22:01.870
Um...

00:22:02.530 --> 00:22:03.500
and others.

00:22:03.500 --> 00:22:03.500
Thank you.

00:22:32.500 --> 00:22:33.500
There you go.

00:22:33.500 --> 00:22:34.500
The next thing I want to show
you is the Matisse editor.

00:22:34.500 --> 00:22:39.500
This is the Matisse editor that
you've probably heard about.

00:22:39.500 --> 00:22:43.700
One of the nice things that it does is
it doesn't use absolute positioning.

00:22:43.700 --> 00:22:47.430
It gives you all the advantages
of all the dynamic positioning,

00:22:47.430 --> 00:22:53.010
but it gives you a user experience that's
a lot like an absolute positioning thing.

00:22:53.040 --> 00:22:55.240
And if you can see,
I don't know how well it's

00:22:55.240 --> 00:22:58.700
showing up on the projectors,
but there's all these little sort of

00:22:58.700 --> 00:23:04.090
vertical bars where it's showing you
the constraints that it's deriving.

00:23:04.180 --> 00:23:11.090
It's deriving the constraints from all
the little bits and pieces that you drag.

00:23:11.470 --> 00:23:17.190
This has the advantage that you
get this really easy experience,

00:23:17.190 --> 00:23:22.780
and yet all of this responds correctly
when you do internationalization,

00:23:22.780 --> 00:23:26.400
when you change labels
from Chinese to German,

00:23:26.400 --> 00:23:28.660
or when you resize things.

00:23:28.660 --> 00:23:30.740
It all works really smoothly.

00:23:30.740 --> 00:23:35.220
Now, there are actually a few
slides I wanted to go through,

00:23:35.220 --> 00:23:40.860
and we'll get back to that slide deck.

00:23:40.860 --> 00:23:44.450
I wanted to talk a little bit about the

00:23:46.580 --> 00:23:50.500
About some real-world applications,
I mean, Java is used out there for just

00:23:50.500 --> 00:23:51.820
billions and billions of things.

00:23:51.820 --> 00:23:54.170
You know,
my favorite one these days is still the

00:23:54.170 --> 00:23:56.420
Brazilian national healthcare system.

00:23:56.420 --> 00:24:01.130
You know, 120 million people,
every patient-caregiver interaction from,

00:24:01.210 --> 00:24:07.600
you know,
from proctoscopies to taking your

00:24:07.600 --> 00:24:12.500
temperature to filing a prescription.

00:24:13.640 --> 00:24:14.730
You know, giant telescopes.

00:24:14.790 --> 00:24:18.870
Most of the world's giant telescopes
are controlled by Java apps.

00:24:18.880 --> 00:24:21.400
You know,
the JPL guys use it really heavily for,

00:24:21.400 --> 00:24:22.940
like, the Mars Rover stuff.

00:24:23.030 --> 00:24:25.090
You know,
the protein-folding world uses it.

00:24:25.120 --> 00:24:29.340
All of eBay and Orbitz, you know,
they're giant Java apps.

00:24:29.340 --> 00:24:33.620
And there are a lot of desktop
apps that have been showing up.

00:24:33.620 --> 00:24:36.880
This is a few that I sort of gleaned
off the web in the last week or so.

00:24:36.880 --> 00:24:40.040
Blurb.com is a fun one.

00:24:40.040 --> 00:24:42.920
It's kind of like the book
publishing thing in iPhoto.

00:24:43.640 --> 00:24:45.420
Except that it also works on Windows.

00:24:45.420 --> 00:24:51.090
One of the nice things about doing
Java desktop apps is that you get all the

00:24:51.090 --> 00:24:54.460
fun of developing and so forth on Apple.

00:24:54.460 --> 00:24:58.500
But you're not cutting yourself
off from the Windows market.

00:24:58.500 --> 00:25:01.080
Here's another one, Spring Medical.

00:25:01.080 --> 00:25:03.820
They're a nice sort of charting company.

00:25:03.820 --> 00:25:06.740
And here's a couple of
screenshots from there.

00:25:06.740 --> 00:25:09.680
They do everything that
you need to run a hospital.

00:25:09.680 --> 00:25:13.570
And this is basically
the Brazilian healthcare.

00:25:13.640 --> 00:25:15.820
Healthcare system design.

00:25:15.820 --> 00:25:18.960
Sort of,
except that it's done for the U.S.

00:25:19.000 --> 00:25:20.980
So it does all the right U.S.

00:25:20.980 --> 00:25:21.600
stuff.

00:25:21.660 --> 00:25:27.820
And they very nicely support, you know,
both Windows and the Macintosh.

00:25:27.820 --> 00:25:31.820
So you find doctor's offices using
this on the Mac as well as on Windows.

00:25:31.820 --> 00:25:34.560
It's kind of whatever the
doctor's office wants to do.

00:25:34.690 --> 00:25:37.000
It does things like patient charts.

00:25:37.000 --> 00:25:41.440
One of the nice things that's been
happening in the Java world because,

00:25:41.440 --> 00:25:45.080
you know, we do both, you know,
interesting desktop apps,

00:25:45.080 --> 00:25:47.320
cell phone apps,
and infrastructure stuff,

00:25:47.320 --> 00:25:50.440
is that you find a lot of companies are
kind of changing the way that they're

00:25:50.440 --> 00:25:52.680
doing business around their software.

00:25:52.680 --> 00:25:55.460
And one of my favorite examples
is my brother's company.

00:25:55.460 --> 00:25:56.510
It's called Dirt.

00:25:56.520 --> 00:25:58.260
Doing it right this time.

00:25:58.260 --> 00:26:00.760
My brother's an industrial designer.

00:26:00.760 --> 00:26:03.000
And they do furniture and wall systems.

00:26:03.000 --> 00:26:07.070
And they started this company
a couple of years ago.

00:26:07.080 --> 00:26:11.220
And they had the lovely advantage
of being able to design the product,

00:26:11.220 --> 00:26:13.600
the business, and all the processes.

00:26:13.600 --> 00:26:14.620
And software together.

00:26:14.620 --> 00:26:17.370
So what they build is
walls kind of like this.

00:26:17.380 --> 00:26:21.560
They're the only people around
that can build truly curved walls.

00:26:21.560 --> 00:26:24.240
And not custom.

00:26:24.240 --> 00:26:26.800
Just, you know, using standard parts.

00:26:26.800 --> 00:26:29.930
And they have this app, which I'll...

00:26:33.600 --> 00:26:34.580
I'll try to bring up here.

00:26:34.680 --> 00:26:39.030
So their app is right here.

00:26:39.590 --> 00:26:43.280
So their app looks kind of boring.

00:26:43.330 --> 00:26:50.040
It's one where you can pick
different kinds of structures.

00:26:50.040 --> 00:26:56.780
You can pick walls and you can draw
walls and it just puts the wall in.

00:26:56.880 --> 00:27:00.630
Now what's going on here is actually
pretty interesting because there's

00:27:00.830 --> 00:27:04.500
actually an expert system behind this
that has done all the figuring out of how

00:27:04.530 --> 00:27:09.460
all the clips and connectors have to go,
how all of the structure of the

00:27:09.460 --> 00:27:11.280
wall has to be put together.

00:27:11.420 --> 00:27:14.980
If you draw walls at strange angles,
the expert system figures

00:27:14.980 --> 00:27:18.430
out how the posts work.

00:27:18.510 --> 00:27:22.210
And if you're running this on Windows,
unfortunately, because they did something

00:27:22.210 --> 00:27:25.670
I really didn't like,
which is that they tied their,

00:27:25.680 --> 00:27:28.760
they do real-time pricing.

00:27:28.760 --> 00:27:31.610
So you can get real-time pricing
but only on Windows because they use

00:27:31.610 --> 00:27:35.900
Internet Explorer and I've been beating
the crap out of them to get rid of that.

00:27:35.900 --> 00:27:37.720
They don't need to do that.

00:27:37.720 --> 00:27:39.880
Why they did it is beyond me.

00:27:39.880 --> 00:27:45.220
So this looks vaguely like a lot of
the interior design apps that you see.

00:27:45.220 --> 00:27:48.210
This has got a couple of
things that are different.

00:27:48.220 --> 00:27:52.000
So is that the first time
these apps work on Mac OS?

00:27:52.000 --> 00:27:58.340
Is that the first time
these apps work on Mac OS X?

00:27:59.300 --> 00:28:03.330
In that design community,
finding people who use Macs

00:28:03.330 --> 00:28:05.440
is actually pretty hard.

00:28:05.440 --> 00:28:10.250
So the really interesting thing
I wanted to show is that they

00:28:10.280 --> 00:28:15.020
actually use all of the OpenGL stuff,
all the Joggle support.

00:28:15.020 --> 00:28:20.300
They use a 3D API called Zith,
which is one that was

00:28:20.300 --> 00:28:23.230
designed for video games.

00:28:23.260 --> 00:28:25.700
So now if I do something like that.

00:28:25.700 --> 00:28:27.370
I think we have to cut this here.

00:28:27.400 --> 00:28:28.900
Yeah, I just want to put a door in.

00:28:29.300 --> 00:28:33.440
And, you know, it does all the AI stuff,
and it's really cool.

00:28:33.440 --> 00:28:36.440
And they actually, you know,
there's a build button on this thing

00:28:36.440 --> 00:28:40.400
that causes giant robot arms and
laser cutters to go into action.

00:28:40.440 --> 00:28:43.000
They actually control
all the robots from it.

00:28:43.000 --> 00:28:43.800
So thanks.

00:28:43.800 --> 00:28:44.740
Thank you, James.

00:28:56.480 --> 00:28:56.990
Great, great.

00:28:57.020 --> 00:29:00.740
We stay in the trenches and we
sometimes forget about these great

00:29:00.740 --> 00:29:01.970
applications being developed.

00:29:04.940 --> 00:29:10.300
Let's move on to Java SE 6
and start with Sun's feature.

00:29:10.690 --> 00:29:11.540
For Java C6.

00:29:11.540 --> 00:29:15.390
As you've heard,
Java C6 is a codename Mustang,

00:29:15.390 --> 00:29:18.890
and a Mustang can be a lot of
different things for different people.

00:29:18.960 --> 00:29:21.270
Here it's a plane for Duke.

00:29:21.470 --> 00:29:24.540
And I'd like to welcome
another person from Sun,

00:29:24.540 --> 00:29:25.550
Scott Violet.

00:29:25.550 --> 00:29:29.100
He's a client lead
architect and he has a demo.

00:29:29.100 --> 00:29:32.030
He will demo IRIS,
a showcase of Java 6 features.

00:29:32.040 --> 00:29:33.080
Thank you, Francois.

00:29:33.080 --> 00:29:35.840
All right,
so a while back when I had contacted

00:29:35.840 --> 00:29:39.520
Francois about speaking at WWDC,
I offered to speak about all

00:29:39.550 --> 00:29:42.870
the wonderful and amazing
client features we've done to

00:29:42.880 --> 00:29:45.180
really reinvigorate the client.

00:29:45.340 --> 00:29:48.120
But you know what,
Francois is much better speaker.

00:29:48.120 --> 00:29:50.700
He has that sexy Frenchman
accent that I can't compare with,

00:29:50.700 --> 00:29:52.360
so I'm just going to focus on a demo.

00:29:52.360 --> 00:29:56.620
So, you know, if you went to the keynote
like I suspect all of you did,

00:29:56.620 --> 00:29:59.810
if you're like me,
you were blown away by the visuals

00:29:59.810 --> 00:30:02.020
that the Time Machine app had.

00:30:02.020 --> 00:30:04.900
It was just amazing to see sort
of dropping into this 3D view and,

00:30:04.900 --> 00:30:06.700
you know, looping through things.

00:30:06.700 --> 00:30:09.600
Wonderful use of 3D technology
to convey the point.

00:30:09.600 --> 00:30:11.760
I suspect this is a good
indication of where,

00:30:11.760 --> 00:30:14.480
you know,
all desktop applications are going to go.

00:30:14.580 --> 00:30:17.570
And, you know,
the demo that I'm going to show nicely

00:30:17.570 --> 00:30:21.600
fits in with that insofar as you can
do those effects with Java today.

00:30:21.600 --> 00:30:24.420
Now, I don't have a lot of time,
so I'm just going to show

00:30:24.420 --> 00:30:26.000
you a small portion of IRIS.

00:30:26.000 --> 00:30:28.960
This IRIS demo is one that we
actually created at Java 1.

00:30:28.960 --> 00:30:31.970
And you'll notice a lot of
use of these sort of 3D,

00:30:31.970 --> 00:30:35.890
these animation effects,
sort of you'll get nice hover effects,

00:30:35.890 --> 00:30:38.060
these subtle animation in and out.

00:30:38.130 --> 00:30:40.020
You can go ahead and
type in and log in here.

00:30:40.020 --> 00:30:42.200
Now, this application actually
does a number of things.

00:30:42.200 --> 00:30:44.560
It's a sort of photo viewer,
but it's meant to be one.

00:30:44.560 --> 00:30:47.700
That you can map out a particular
vacation that you went along

00:30:47.700 --> 00:30:50.700
or a trip that you went along
and assign photos to that.

00:30:50.740 --> 00:30:53.070
So, again, you can see, you know,
these nice transitions

00:30:53.160 --> 00:30:54.520
that are going everywhere.

00:30:54.520 --> 00:30:56.970
I mouse over,
I get these really nice effects.

00:30:57.040 --> 00:30:59.980
And I just want to show
one aspect of this.

00:30:59.980 --> 00:31:03.470
And, again, you know, mouse over here,
you get these nice zoom in, zoom out,

00:31:03.470 --> 00:31:06.490
all extensive use of effects
all throughout this application.

00:31:08.130 --> 00:31:11.160
But the one aspect I just want to
show here is the photo aspect of it.

00:31:11.160 --> 00:31:14.970
And this is an application that will
allow me to put together a trip report

00:31:14.970 --> 00:31:19.180
with photos going along the way,
but a key part of that is photo albums.

00:31:19.180 --> 00:31:21.720
And this is actually pulling
data from Flickr right now,

00:31:21.810 --> 00:31:24.420
so that's why in certain aspects of it,
it's a little chuggy,

00:31:24.420 --> 00:31:28.420
just because we're sucking all this
data down from the web right now.

00:31:28.420 --> 00:31:31.310
So one of the interesting things, again,
that I should mention

00:31:31.310 --> 00:31:34.420
about this application,
it's a complete swing application.

00:31:34.480 --> 00:31:37.640
The things that you have going on here,
you have JList up there, you have labels,

00:31:37.750 --> 00:31:40.610
text areas, buttons,
they've all been customized,

00:31:40.610 --> 00:31:43.360
but nonetheless,
they're just swing widgets.

00:31:44.470 --> 00:31:47.710
So if I click on the Show button here,
I'll be dropped into a nice photo viewer.

00:31:47.840 --> 00:31:50.960
And the photo viewer is making
extensive use of Joggle,

00:31:50.960 --> 00:31:52.660
Java bindings for GL.

00:31:53.070 --> 00:31:55.470
So I can go ahead and click,
and I can navigate through these,

00:31:55.520 --> 00:31:59.450
zoom in to some particular photos,
go back and forth between them,

00:31:59.530 --> 00:32:00.500
and et cetera.

00:32:00.580 --> 00:32:05.220
So I think if you've seen how cool
the Time Machine application is,

00:32:05.520 --> 00:32:08.400
there's no reason we can't do those
sort of things in Java applications.

00:32:08.400 --> 00:32:12.280
And this is sort of a
small example of that.

00:32:12.280 --> 00:32:14.320
If you're interested,
the source for this code,

00:32:14.320 --> 00:32:17.710
the source for this application has all
been made on a Java.net application.

00:32:17.800 --> 00:32:20.420
So if you are interested,
I'd encourage you to take a look there.

00:32:20.420 --> 00:32:23.260
So I think at this point,
I'm going to hand it over to Francois,

00:32:23.260 --> 00:32:26.360
who I'm sure will be
happy that I'm done early.

00:32:26.360 --> 00:32:28.110
FRANCOIS CHOLLET: Oh, great.

00:32:32.570 --> 00:32:33.160
Thank you.

00:32:33.210 --> 00:32:34.660
Well, Mustang.

00:32:34.710 --> 00:32:37.910
All the features you see on these screens
are covered in Scott's application,

00:32:37.940 --> 00:32:40.240
or almost, hopefully.

00:32:40.240 --> 00:32:44.110
And I'm going to go,
I don't understand half of them,

00:32:44.200 --> 00:32:47.410
I'm just going to go
through a few of them.

00:32:50.700 --> 00:32:56.300
On the desktop, core libraries features,
security and networking,

00:32:56.430 --> 00:32:59.630
enterprise and XML,
VM and serviceability.

00:32:59.760 --> 00:33:02.660
These are the five main areas.

00:33:05.230 --> 00:33:08.410
The main desktop features, I believe,
is improved layout experience.

00:33:08.460 --> 00:33:13.680
You also have a new swing worker
and drag-and-drop enhancements,

00:33:13.710 --> 00:33:14.800
desktop APIs.

00:33:14.880 --> 00:33:16.260
A lot of things have been going on there.

00:33:19.050 --> 00:33:23.120
Core libraries improvements include
refinements to the concurrent

00:33:23.120 --> 00:33:28.650
package for locking mechanisms,
compiler APIs and annotation processing.

00:33:28.660 --> 00:33:32.120
This is for IDE developers mainly.

00:33:32.270 --> 00:33:34.940
Scripting language APIs.

00:33:34.970 --> 00:33:39.670
And Rhino JavaScript engine was
in and is now out of the betas.

00:33:42.540 --> 00:33:46.060
On the security front,
a great improvement there is our

00:33:46.060 --> 00:33:50.000
XML digital signatures for web services.

00:33:50.140 --> 00:33:52.990
Smartcard I/O API.

00:33:53.350 --> 00:33:56.470
Native JSS Kerberos integration
is something we've had

00:33:56.470 --> 00:34:00.390
in J2SE 5 and Mac OS X,
and it's now included

00:34:00.390 --> 00:34:02.750
by Sun in Java SE 6.

00:34:02.790 --> 00:34:05.550
And an HTTP cookie manager,
we have had this in

00:34:05.550 --> 00:34:08.890
WebObjects for a while,
and it's now part of J2SE 6.

00:34:08.990 --> 00:34:14.350
So we'll make sure for these APIs we
will align to Sun's way of doing things.

00:34:16.490 --> 00:34:21.400
On the enterprise front,
the XML parsing packages,

00:34:21.400 --> 00:34:24.840
the database connectivity package,
and the Java management

00:34:24.840 --> 00:34:26.400
extensions have been revved up.

00:34:26.400 --> 00:34:31.690
And there is a new database,
a pure Java database called Derby that

00:34:31.690 --> 00:34:34.400
has been added to the latest betas.

00:34:34.400 --> 00:34:37.400
And it's coming from
the open source world,

00:34:37.400 --> 00:34:43.590
and we will try to take
advantage of it in WebObjects.

00:34:45.780 --> 00:34:49.690
VM features, last but not least,
VM features.

00:34:49.750 --> 00:34:54.780
Performance improvements through faster
class verification and compilers.

00:34:55.020 --> 00:35:00.800
VM Attach and Demand for
debugging systems in production.

00:35:02.830 --> 00:35:06.360
You do not need to have special options,
to type special options when

00:35:06.360 --> 00:35:09.980
you start your production system
to be able to attach to the VM.

00:35:10.090 --> 00:35:16.420
And new VM tools: Remote Stack Analysis,
Java Heap Analysis, and very important,

00:35:16.420 --> 00:35:17.220
DTrace.

00:35:20.270 --> 00:35:24.610
Now, these were some features
improvement for Java SE 6.

00:35:24.660 --> 00:35:27.900
On top of that,
we have a lot of Leopard changes,

00:35:27.900 --> 00:35:31.650
and we want to take advantage
of them in Java SE 6.

00:35:32.490 --> 00:35:36.690
As always, Java is built on top
of Core OS frameworks.

00:35:36.880 --> 00:35:42.260
There is pretty much a one-to-one mapping
between Mac OS X core frameworks or

00:35:42.260 --> 00:35:45.160
core libraries and Java's feature set.

00:35:45.250 --> 00:35:48.500
For example,
Print Services is used for Java printing,

00:35:48.500 --> 00:35:54.280
Cocoa is used for AWT,
Quartz for Java 2D, and so on.

00:35:56.310 --> 00:35:57.620
Cocoa Component.

00:35:57.620 --> 00:36:03.650
If you're tired of the
look of Sun's color picker,

00:36:03.650 --> 00:36:03.650
why not use

00:36:04.030 --> 00:36:08.900
and Mac OS X look and feel
and our own color chooser.

00:36:08.900 --> 00:36:12.860
If you do not want to
implement your own font picker,

00:36:12.860 --> 00:36:15.760
why not use Mac OS X font picker?

00:36:15.780 --> 00:36:19.070
You do not have to type any code,
you just embed it in your

00:36:19.070 --> 00:36:25.540
Java application through the
embedded Cocoa components system.

00:36:25.570 --> 00:36:27.450
And here you go.

00:36:29.000 --> 00:36:30.380
Bundling applications.

00:36:30.530 --> 00:36:33.200
So there's a correct way to bundle
an application and a messy way

00:36:33.230 --> 00:36:35.400
to distribute an application.

00:36:35.400 --> 00:36:36.600
The messy way is on Windows.

00:36:36.600 --> 00:36:39.180
The correct application
bundle is on Mac OS X.

00:36:39.210 --> 00:36:44.710
If you do this, you will be able to drop
your application in the dock,

00:36:44.750 --> 00:36:48.850
keep it nice and clean,
and it will bounce and have all

00:36:48.850 --> 00:36:50.750
the Genie effects that you want.

00:36:50.760 --> 00:36:53.420
You'll be able to drag and drop to it.

00:36:53.490 --> 00:36:54.940
Please use Jarbundler.

00:36:54.940 --> 00:36:56.640
It's your friend.

00:36:57.790 --> 00:37:00.330
New Aqua support.

00:37:00.330 --> 00:37:01.700
There's the new and the not so new.

00:37:01.700 --> 00:37:04.800
For a while,
we've had Aqua everywhere in Java.

00:37:04.900 --> 00:37:07.710
This means that you get
for free screen menu bars,

00:37:07.820 --> 00:37:10.340
AWT widgets,
and swing Aqua look and feel.

00:37:10.340 --> 00:37:13.840
And again, as I said earlier,
anti-aliasing is a default

00:37:13.870 --> 00:37:15.260
for text rendering.

00:37:15.260 --> 00:37:16.400
It just works.

00:37:19.130 --> 00:37:23.300
Extended AWT,
there are many hot Mac OS X features

00:37:23.300 --> 00:37:27.060
that cannot be implemented in pure Java.

00:37:27.060 --> 00:37:31.410
So we have extended AWT to
give you access to a set of

00:37:31.410 --> 00:37:34.190
Mac OS X application events.

00:37:34.200 --> 00:37:39.200
And this is mostly for Doc on Finder,
Drag on Drop, also to intercept

00:37:39.200 --> 00:37:44.640
application menu callbacks,
such as quit, preferences, about events.

00:37:44.640 --> 00:37:48.560
You can intercept them and put your own
Java code in your Java applications.

00:37:51.740 --> 00:37:55.640
New this year is Extended Swing.

00:37:55.640 --> 00:37:58.700
You now have alternate window
styles at your disposition.

00:37:58.700 --> 00:38:04.700
There's a handful of them and also small
and mini Aqua controls to populate them.

00:38:04.700 --> 00:38:08.700
And as well, we added sheets.

00:38:08.700 --> 00:38:13.960
I'd like to welcome Mike Swingle
on stage to demo these features.

00:38:19.400 --> 00:38:21.300
Thank you Francois.

00:38:21.300 --> 00:38:26.180
So for my demo here,
I've constructed a small little

00:38:26.180 --> 00:38:31.240
application that represents like a
palette for a document window for

00:38:31.360 --> 00:38:33.180
something that you'd see in pages.

00:38:33.180 --> 00:38:36.740
And I've launched this in Java 1.5
without our extended swing

00:38:36.760 --> 00:38:38.650
features that we're working on.

00:38:38.660 --> 00:38:40.770
And it's okay.

00:38:40.770 --> 00:38:42.480
It's Java.

00:38:42.480 --> 00:38:47.900
Just, you know, little Aqua controls,
standard size and stuff.

00:38:47.980 --> 00:38:52.350
But to really make it look right,
what we want to do is actually

00:38:52.590 --> 00:38:55.180
make it look like a real palette.

00:38:55.180 --> 00:39:01.590
We'll enable the small title bar for
the window that most palettes have.

00:39:01.620 --> 00:39:06.740
We'll change the size variant of
the controls to miniature style.

00:39:06.740 --> 00:39:10.030
And just for fun,
I want to show you the sheets as well.

00:39:10.110 --> 00:39:16.660
So this is what the new
Aqua look and feel looks like.

00:39:16.660 --> 00:39:19.300
This is what the new Aqua look
and feel looks like with

00:39:19.300 --> 00:39:21.100
mini controls in Java 1.6.

00:39:21.100 --> 00:39:23.100
There's a world of difference.

00:39:23.100 --> 00:39:27.390
We automatically set the font
for you and the preferred size.

00:39:27.610 --> 00:39:31.490
All the pop-ups just automatically scale.

00:39:31.540 --> 00:39:35.100
And something that you've
wanted for a long time,

00:39:35.110 --> 00:39:36.930
sheets.

00:39:37.800 --> 00:39:43.290
So we look forward to seeing some
new and exciting swing applications

00:39:43.360 --> 00:39:46.900
that look more at home on Mac OS X.

00:39:46.900 --> 00:39:47.800
Francois?

00:39:47.800 --> 00:39:51.440
Thank you, Mike.

00:39:51.440 --> 00:39:52.190
This is great.

00:39:52.210 --> 00:39:54.880
I think I'll call you
back on stage later.

00:39:57.300 --> 00:40:00.740
Clive?

00:40:00.750 --> 00:40:04.140
OK,
let's move on to graphics improvements.

00:40:04.950 --> 00:40:09.550
You now have the choice
on Mac OS X Java SE 6.

00:40:09.630 --> 00:40:13.240
You have a choice of
different graphics engines.

00:40:14.420 --> 00:40:17.760
Forever we've had the
Quartz graphics engine.

00:40:17.790 --> 00:40:20.430
We have added last year
the Sun 2D renderer,

00:40:20.430 --> 00:40:24.320
which is another
software graphics engine.

00:40:24.360 --> 00:40:28.160
And this year,
we're adding the OpenGL graphics engine,

00:40:28.160 --> 00:40:32.860
which is taking advantage of the
OpenGL hardware acceleration.

00:40:32.880 --> 00:40:37.140
This is an effort that
was spearheaded by Sun.

00:40:37.160 --> 00:40:41.210
And since we have a great
OpenGL library on Mac OS X,

00:40:41.220 --> 00:40:43.880
we have been able to leverage it.

00:40:43.880 --> 00:40:46.980
You're going to see great
performance improvement from this.

00:40:47.140 --> 00:40:49.990
But as always, your mileage may vary.

00:40:50.000 --> 00:40:53.320
So I encourage you to go to the
Java graphics and performance

00:40:53.320 --> 00:40:57.490
session at 9:00 AM on Thursday.

00:41:00.370 --> 00:41:03.030
Java 3D on Joggle, what's behind there?

00:41:03.200 --> 00:41:07.000
Java 3D used to be a very
thin layer of Java on top of

00:41:07.000 --> 00:41:09.510
a lot of native drawing code.

00:41:09.510 --> 00:41:12.300
This is changing with Java 3D 1.5.

00:41:12.300 --> 00:41:14.560
It is now based on Joggle.

00:41:14.580 --> 00:41:19.980
And since Joggle is also available on
Mac OS X and Java 3D is now pure Java,

00:41:19.980 --> 00:41:24.290
Java 3D on Joggle will be
available on Sun's website.

00:41:27.750 --> 00:41:29.600
Resolution Independence Support.

00:41:29.600 --> 00:41:36.340
It will not be in
Java SE until version 7,

00:41:36.360 --> 00:41:38.510
and that's a statement.

00:41:38.640 --> 00:41:41.420
But we have to do something for Leopard.

00:41:42.340 --> 00:41:45.190
You will have great
default layout behavior:

00:41:45.220 --> 00:41:48.840
sharp text, sharp controls,
and sharp AWT drawing.

00:41:48.850 --> 00:41:54.080
Since we cannot add developer
APIs for resolution independence,

00:41:54.140 --> 00:41:57.800
your images and your layout
will be scaled accordingly.

00:41:57.870 --> 00:42:02.600
And I think demo speaks
better than text here.

00:42:02.600 --> 00:42:05.040
So I'll call Mike again.

00:42:06.010 --> 00:42:07.490
Thanks, Francois.

00:42:07.550 --> 00:42:09.040
Thank you, Francois.

00:42:09.040 --> 00:42:13.030
So what I'm doing with--

00:42:13.250 --> 00:42:18.640
So to come up with a demo here,
I thought, well, you know,

00:42:18.640 --> 00:42:22.550
I could make something kind of contrived,
or I could just take a real-world,

00:42:22.550 --> 00:42:27.460
unmodified application and
bring it up with our resolution

00:42:27.460 --> 00:42:31.160
independence and see how it works.

00:42:31.160 --> 00:42:36.140
So what we're doing here,
we're just going to go to Quartz

00:42:36.140 --> 00:42:42.330
Debug and just ratchet it up
to 2.0 and see what happens.

00:42:46.360 --> 00:42:47.540
So it's launching right now.

00:42:47.540 --> 00:42:50.300
The window positioning and
coordinate stuff is still

00:42:50.300 --> 00:42:52.060
something that we're working on.

00:42:52.060 --> 00:42:57.130
But as you can see, in high res,
all of the text is crisp

00:42:57.130 --> 00:42:58.550
and clear and sharp.

00:42:58.720 --> 00:43:02.460
All of the rounded rectangles
for these tabs here,

00:43:02.460 --> 00:43:05.500
all the Java 2D drawing
for the code collapse,

00:43:05.520 --> 00:43:09.080
it's sharp and crystal clear
when we have a screen that

00:43:09.270 --> 00:43:11.700
actually has a lot more pixels.

00:43:11.700 --> 00:43:14.630
Unfortunately,
I can't show you because our monitors

00:43:14.720 --> 00:43:16.690
are only fixed resolution here.

00:43:16.840 --> 00:43:20.530
You'll notice that the images are scaled,
but they're not any different

00:43:20.610 --> 00:43:23.700
than what you would normally
see at a 1.0 scale factor,

00:43:23.700 --> 00:43:25.680
72 DPI, on a regular screen.

00:43:26.070 --> 00:43:30.450
The real story here is it just works.

00:43:30.840 --> 00:43:36.410
You know, and you shouldn't have to
change a single line of code.

00:43:44.930 --> 00:43:51.160
Well, it's going to be great to have
so many pixels to play with.

00:43:51.400 --> 00:43:55.120
Back when I started
tinkering with computers,

00:43:55.150 --> 00:43:58.400
we were building icons with 8 bytes.

00:43:58.480 --> 00:44:02.400
And now in 8 bytes,
we're putting a pointer.

00:44:02.920 --> 00:44:07.140
This is 64-bit programming,
and with Java, it just works.

00:44:07.200 --> 00:44:10.450
I am able to reuse a
slide from last year.

00:44:10.520 --> 00:44:13.660
We use this slide for
the transition to Intel,

00:44:13.660 --> 00:44:16.890
and we're using it this
year for Java 64-bit.

00:44:16.920 --> 00:44:21.420
There is a little asterisk here,
and the little asterisk stands

00:44:21.420 --> 00:44:23.680
for the usual disclaimer.

00:44:23.690 --> 00:44:26.700
It's only for Intel processors.

00:44:26.960 --> 00:44:32.660
You have to run your Java applications
with the Java SE6 server 64-bit VM.

00:44:32.660 --> 00:44:36.180
And of course, if you have JNI libraries,
you have to recompile

00:44:36.180 --> 00:44:38.120
them for Intel 64-bit.

00:44:39.080 --> 00:44:41.630
But mostly, everything works.

00:44:41.680 --> 00:44:43.610
And you can trust us.

00:44:43.670 --> 00:44:47.890
You've heard James Gosling saying
how far this had been tested.

00:44:48.730 --> 00:44:49.990
It works.

00:44:50.100 --> 00:44:51.090
So what does this give you?

00:44:51.100 --> 00:44:54.080
It blows away the 4GB heap barrier.

00:44:54.080 --> 00:44:57.790
It allows more larger objects
in multidimensional arrays.

00:44:57.790 --> 00:45:00.830
And with Java,
you get the full Java stack,

00:45:00.830 --> 00:45:02.120
including the graphics.

00:45:02.120 --> 00:45:07.390
This means that you do not have to
divide your application between a client

00:45:07.640 --> 00:45:13.300
32-bit to draw the results of your
simulation and your actual simulator.

00:45:13.300 --> 00:45:17.460
You can put everything in one
process and have both drawing and

00:45:17.460 --> 00:45:21.720
simulation going simultaneously.

00:45:22.580 --> 00:45:23.630
Who is this for?

00:45:23.720 --> 00:45:25.990
Well,
they are consumers of huge data sets,

00:45:26.010 --> 00:45:30.640
like the iTunes music store
that want to have the database

00:45:30.640 --> 00:45:36.250
of all of its songs in memory,
and other examples are gene

00:45:36.290 --> 00:45:38.370
sequencing applications.

00:45:38.960 --> 00:45:43.020
You also have the producers
of huge datasets like NASA,

00:45:43.020 --> 00:45:47.470
NOAA, petroleum engineering simulations,
and so on.

00:45:47.840 --> 00:45:50.740
For you,
if you're not in these categories,

00:45:50.830 --> 00:45:54.170
you need to evaluate on
a per application basis.

00:45:54.230 --> 00:45:56.910
So there's a possible performance cost.

00:45:57.960 --> 00:46:02.760
If I go back to the benchmark
that I showed earlier,

00:46:02.990 --> 00:46:10.140
you will see that Java 64-bit is
trailing slightly behind Java 32-bit.

00:46:10.140 --> 00:46:13.450
And this is still-- this is very early.

00:46:13.450 --> 00:46:18.790
We just got it running
within the last month.

00:46:18.810 --> 00:46:22.850
And it is still among the best
performers of all the industry in 64-bit.

00:46:23.680 --> 00:46:28.720
If I drill down in this particular
benchmark to the sub-benchmark,

00:46:28.800 --> 00:46:33.880
you will see that there are some of
the mathematical operations like fast

00:46:34.320 --> 00:46:38.960
Fourier transforms that are much faster,
other ones that are slower,

00:46:38.960 --> 00:46:44.030
and it really depends on whether your
algorithm is able to take advantage

00:46:44.130 --> 00:46:46.990
of the increased number of registers.

00:46:46.990 --> 00:46:49.900
There are also fixes coming in
from both Sun and Apple that

00:46:49.900 --> 00:46:49.900
should improve these numbers.

00:46:53.160 --> 00:46:57.720
I'd like to welcome on stage
people from Agilent Technologies,

00:46:57.720 --> 00:47:04.420
Peter Eastman and Mihailo Despotovic,
to show us GinSpring.

00:47:10.330 --> 00:47:11.200
Thank you.

00:47:11.200 --> 00:47:16.190
So we want to talk about GeneSpring GX,
which is an application for

00:47:16.240 --> 00:47:19.620
analyzing data from gene
expression microarray experiments.

00:47:19.640 --> 00:47:23.980
So this is a technology that has
become very popular in the last decade.

00:47:23.980 --> 00:47:27.940
And what it allows you to do is to
take some kind of a biological sample,

00:47:27.940 --> 00:47:32.500
like a blood sample or a tissue
sample or maybe a cell culture,

00:47:32.500 --> 00:47:36.150
and you can take a snapshot of
what every single gene is doing

00:47:36.150 --> 00:47:38.180
in that sample at one moment.

00:47:38.480 --> 00:47:41.160
And then you can repeat this
for a lot of different samples.

00:47:41.160 --> 00:47:44.170
Like maybe you want to look at
a lot of different individuals,

00:47:44.170 --> 00:47:47.240
or maybe some people who have a
disease and others who are healthy,

00:47:47.240 --> 00:47:50.670
or people who have been given a drug
and other people who haven't been.

00:47:50.740 --> 00:47:54.080
And so you then take all of this
data from all these microarrays,

00:47:54.080 --> 00:47:56.240
and this can produce
really a lot of data,

00:47:56.240 --> 00:48:00.110
easily hundreds of millions of numbers.

00:48:01.470 --> 00:48:03.530
And if you just look at it,
it's just sort of this

00:48:03.530 --> 00:48:05.070
mess of lines on a graph.

00:48:05.180 --> 00:48:09.180
And so the goal of GeneSpring GX is
to help you analyze this data in

00:48:09.180 --> 00:48:13.520
many different ways and try to figure
out what it means and get to some

00:48:13.520 --> 00:48:15.320
sort of understanding of the biology.

00:48:15.320 --> 00:48:18.530
Now just to make things worse,
the microarray technology

00:48:18.540 --> 00:48:20.660
is advancing very,
very quickly.

00:48:20.660 --> 00:48:25.630
So this data set that you see up here
was generated with a kind of microarray

00:48:25.630 --> 00:48:29.140
that measures about 55,000 genes.

00:48:29.840 --> 00:48:31.850
And about two years ago,
that was considered a

00:48:31.850 --> 00:48:33.080
really big microarray.

00:48:33.080 --> 00:48:37.090
But today, there are already ones on the
market that measure hundreds of

00:48:37.090 --> 00:48:39.980
thousands of gene transcripts,
and that number is just going

00:48:39.990 --> 00:48:41.260
to be increasing in the future.

00:48:45.700 --> 00:48:47.660
All right, thanks Peter.

00:48:47.660 --> 00:48:50.810
And as Peter already implied,
the GeneSpring, our application,

00:48:50.820 --> 00:48:52.660
has to deal with huge data sets.

00:48:52.660 --> 00:48:56.020
Unfortunately, sometimes when you deal
with huge data sets,

00:48:56.020 --> 00:48:57.340
we run into problems.

00:48:57.340 --> 00:49:01.300
So some of our algorithms try
to compensate for the barriers

00:49:01.310 --> 00:49:06.180
imposed by 32-bit JVMs by swapping
data to disk and swapping it back,

00:49:06.180 --> 00:49:09.100
which then slows down the computation.

00:49:09.480 --> 00:49:13.360
And sometimes you can't even execute the
computation because you really need to

00:49:13.360 --> 00:49:15.430
have some chunk of data in the memory.

00:49:15.430 --> 00:49:18.070
And if you can't have that in memory,
you'll just pop up an

00:49:18.070 --> 00:49:20.460
error message saying,
sorry, we cannot execute.

00:49:20.460 --> 00:49:24.960
Some of these algorithms are not designed
to swap in data for various reasons.

00:49:24.960 --> 00:49:27.880
And in that case...

00:49:29.850 --> 00:49:32.350
This is something you
might see in our program.

00:49:32.360 --> 00:49:37.390
And in this particular case,
user tried to calculate and construct

00:49:37.410 --> 00:49:41.420
the gene tree with this same data set,
so it's more than 50,000 genes.

00:49:41.420 --> 00:49:45.400
Unfortunately, the user didn't have
enough memory for this,

00:49:45.400 --> 00:49:48.300
and we cannot just let
this algorithm run.

00:49:48.300 --> 00:49:50.630
We cannot just throw out of
memory exception because JVM will

00:49:50.630 --> 00:49:51.910
be in an inconsistent state.

00:49:51.920 --> 00:49:53.540
User might not save some data.

00:49:53.540 --> 00:49:54.750
It might be very bad.

00:49:54.760 --> 00:49:59.350
So we actually tried to estimate how
much memory the algorithm is going

00:49:59.350 --> 00:50:01.260
to need to finish the calculation.

00:50:01.260 --> 00:50:05.980
In this particular case, unfortunately,
that amount of memory

00:50:05.980 --> 00:50:10.260
was about 6 gigabytes,
which is over the 4 gigabyte limit.

00:50:10.260 --> 00:50:14.760
And the user had about 2
gigabytes on this machine.

00:50:14.760 --> 00:50:20.160
And this is an unfortunate message,
but however,

00:50:21.850 --> 00:50:25.800
When we ran this in 64-bit JVM,
the message didn't show up,

00:50:25.800 --> 00:50:28.060
the calculation started,
and the user eventually

00:50:28.060 --> 00:50:29.360
will get its results.

00:50:29.360 --> 00:50:33.920
So, an important thing to emphasize here
is that the difference between program

00:50:33.920 --> 00:50:38.970
running in the 64-bit JVM on this slide
and the program running on this slide

00:50:38.970 --> 00:50:41.950
inside 32 JVM really doesn't exist.

00:50:41.960 --> 00:50:45.230
So, it's the same jar,
as a matter of fact, same classes,

00:50:45.230 --> 00:50:47.100
no recompilation, nothing.

00:50:47.100 --> 00:50:50.220
Of course, it's Java,
and it just confirms what Francois said,

00:50:50.240 --> 00:50:51.400
that it just works.

00:50:51.800 --> 00:50:53.040
It works better, actually.

00:50:53.040 --> 00:50:58.280
So, there are only two things which
are done to produce this slide.

00:50:58.280 --> 00:51:03.630
First of all, 64-bit JVM was started,
so it was given a hint to JVM that

00:51:03.630 --> 00:51:06.510
it should start in 64-bit mode.

00:51:06.520 --> 00:51:10.310
And we, of course, had to adjust the heap
size for the application,

00:51:10.310 --> 00:51:14.260
because the original heap size was still
less than required by this algorithm.

00:51:14.260 --> 00:51:17.670
So, this is just one small data point.

00:51:17.680 --> 00:51:19.800
We consider this as a tip of an iceberg.

00:51:20.640 --> 00:51:24.430
It's, GeneSpring is also just one of
our applications we produce,

00:51:24.430 --> 00:51:28.580
and we are expecting more applications
coming on the very similar engine,

00:51:28.580 --> 00:51:32.840
and eventually they are all going
to benefit from 64-bit JVM on Apple.

00:51:32.840 --> 00:51:35.940
So, which will eventually
make our customers happy,

00:51:35.940 --> 00:51:37.980
and that's eventually our goal.

00:51:37.980 --> 00:51:43.340
So, with this I would conclude,
and thank you very much.

00:51:43.340 --> 00:51:45.320
Now back to the main presentation.

00:51:52.480 --> 00:51:53.240
Thank you, Mihailo.

00:51:53.240 --> 00:52:00.630
So as a summary,
here are the restrictions for

00:52:00.630 --> 00:52:04.800
VM flavors on both architectures.

00:52:04.910 --> 00:52:07.750
Java EC6 previews.

00:52:08.390 --> 00:52:13.410
The server 32 and 64-bit will
only be available on Intel.

00:52:14.270 --> 00:52:20.500
J2SE 5, the 32-bit VM,
will only be available on Intel.

00:52:20.500 --> 00:52:23.790
And Java 1.4 is for client only.

00:52:25.590 --> 00:52:28.460
For more details,
go to the Java VM session,

00:52:28.460 --> 00:52:31.250
which is Thursday at 10:30 AM.

00:52:33.490 --> 00:52:37.320
Java 1.3, let's not spend much time on
Java 1.3 because it's dead.

00:52:37.320 --> 00:52:38.380
It's gone.

00:52:38.390 --> 00:52:39.680
It's not on your Leopard CD.

00:52:39.680 --> 00:52:41.960
Rest in peace, Java 1.3.

00:52:44.170 --> 00:52:47.100
Java 1.4, well,
it's following very closely

00:52:47.100 --> 00:52:50.600
the sad story of Java 1.3.

00:52:50.600 --> 00:52:53.140
Move to Java 5 now.

00:52:53.140 --> 00:52:54.520
You've been warned.

00:52:58.250 --> 00:53:01.420
The Java bridge,
it served its purpose over

00:53:01.420 --> 00:53:03.700
its 10 years lifespan.

00:53:03.700 --> 00:53:05.380
It's time to retire it.

00:53:05.380 --> 00:53:09.220
All the Cocoa Java APIs have
been deprecated.

00:53:09.460 --> 00:53:10.850
Use JNI.

00:53:10.960 --> 00:53:14.220
And the Xcode templates
have been removed from Lepl.

00:53:18.160 --> 00:53:22.460
Let's move on to
IDE support on the platform.

00:53:22.550 --> 00:53:26.030
The three main third-party
tools are Eclipse,

00:53:26.030 --> 00:53:28.770
NetBeans, and IntelliJ IDEA.

00:53:28.830 --> 00:53:30.820
We have already seen NetBeans.

00:53:30.820 --> 00:53:33.260
Eclipse has its own session.

00:53:34.250 --> 00:53:36.170
I have a couple slides on Eclipse though.

00:53:36.300 --> 00:53:43.990
The important thing this quarter is that
Eclipse 3.2 was released on Mac OS X,

00:53:44.050 --> 00:53:50.200
and with it we had a joint effort to fix
and improve the AWT/SWT interoperability.

00:53:50.270 --> 00:53:55.390
This means that plugins can embed
AWT components in SWT windows,

00:53:55.510 --> 00:54:00.720
and there shouldn't be any pure
Java plugin that does not work

00:54:00.720 --> 00:54:02.930
out of the box on Mac OS X.

00:54:03.760 --> 00:54:07.060
The cave-out is that there are
still some remaining AWT threading

00:54:07.060 --> 00:54:10.730
combinations that may deadlock,
and we are chasing them.

00:54:11.030 --> 00:54:14.360
Some plugins with native code are
not yet available on Mac OS X,

00:54:14.360 --> 00:54:19.200
so you should put pressure on your
plugin provider to support our platform.

00:54:19.200 --> 00:54:21.110
There's no reason not to do so.

00:54:23.980 --> 00:54:26.060
Let's have a demo of IDEA.

00:54:26.060 --> 00:54:31.780
I'd like to welcome Ben Galbraith,
who is a member of the

00:54:31.780 --> 00:54:34.220
IntelliJ advisory board.

00:54:34.220 --> 00:54:35.470
Yes, sorry.

00:54:35.490 --> 00:54:37.400
You don't need that.

00:54:40.700 --> 00:56:15.700
[Transcript missing]

00:56:16.230 --> 00:56:18.100
You guys don't mind, do you?

00:56:18.100 --> 00:56:20.100
Five minutes and 30 seconds,
let's do that.

00:56:20.100 --> 00:56:22.750
Okay,
so what I want to do in the next five

00:56:22.750 --> 00:56:27.090
minutes and 25 seconds is actually
show you coding this timer application

00:56:27.090 --> 00:56:29.100
from scratch in my code editor.

00:56:29.100 --> 00:56:31.530
And actually,
I did a couple of rehearsals--oops,

00:56:31.670 --> 00:56:31.900
sorry.

00:56:32.080 --> 00:56:33.090
That was stupid.

00:56:33.100 --> 00:56:35.100
I'll set it to 550.

00:56:35.100 --> 00:56:37.920
I did a couple of rehearsals,
and I can't do the entire thing from

00:56:37.930 --> 00:56:40.090
scratch in five minutes and 15 seconds.

00:56:40.100 --> 00:56:43.530
But I can do a little bit of it,
and as I do that, I want to show you the

00:56:43.530 --> 00:56:45.100
experience of coding in IntelliJ.

00:56:45.100 --> 00:56:47.060
So let's start a new class file.

00:56:47.100 --> 00:56:49.100
I'll call it My Timer.

00:56:49.100 --> 00:56:51.070
And let's get going.

00:56:51.110 --> 00:56:54.100
The first feature I want to show
you is what we call live templates.

00:56:54.100 --> 00:56:56.100
With live templates,
you just type an abbreviation

00:56:56.100 --> 00:56:59.070
and hit the tab key,
and it expands some code out from that.

00:56:59.120 --> 00:57:01.100
Now,
this was a simple static code insertion.

00:57:01.100 --> 00:57:04.100
It's actually fairly sophisticated,
where you can have parameters.

00:57:04.100 --> 00:57:06.970
It can actually look at the surrounding
state of your code and figure out what

00:57:06.970 --> 00:57:09.100
possible parameter values are and things.

00:57:09.100 --> 00:57:11.100
But I'm just doing a simple one there.

00:57:11.100 --> 00:57:14.100
And now, I need to create a J frame
to actually display.

00:57:14.100 --> 00:57:15.990
I'm going to display my timer.

00:57:16.240 --> 00:57:19.100
And if you notice--sorry,
I'm not used to this keyboard.

00:57:19.100 --> 00:57:21.040
I'm fat fingering all over the place.

00:57:21.240 --> 00:57:23.930
IntelliJ automatically handled
the import of the J frame.

00:57:24.180 --> 00:57:26.020
And in fact, if I get rid of it,
it can automatically get

00:57:26.020 --> 00:57:26.990
rid of the J frame import.

00:57:28.200 --> 00:57:29.160
and others.

00:57:58.420 --> 00:57:59.200
Thank you for watching.

00:58:28.200 --> 00:58:31.900
- Well, it turns out there's an exception
here that I need to handle.

00:58:31.900 --> 00:58:35.460
If you notice to the left,
you see the little light bulb here,

00:58:35.560 --> 00:58:38.240
IDEA also has a feature
called intention actions,

00:58:38.240 --> 00:58:41.620
where we try and figure out what
you're trying to do in a given

00:58:41.620 --> 00:58:43.520
context and just do it for you.

00:58:43.520 --> 00:58:45.810
In this case,
we have a number of options that

00:58:45.940 --> 00:58:49.040
we figure you might wanna do here,
and one of these options is adding the

00:58:49.040 --> 00:58:52.070
exception to the method definition,
to the method signature.

00:58:52.150 --> 00:58:56.200
I also want to assign the result
of this invocation to a variable.

00:58:56.200 --> 00:58:58.060
IDEA supports what are
called refactoring.

00:58:58.060 --> 00:59:00.110
Refactoring is a big trend
in our industry right now.

00:59:00.190 --> 00:59:03.440
In fact, Xcode just got support for it,
which is great.

00:59:03.440 --> 00:59:06.280
Refactorings are automated
changes across your code base.

00:59:06.280 --> 00:59:09.310
One refactoring that IDEA supports
is just inserting a variable

00:59:09.310 --> 00:59:10.920
where there wasn't one previously.

00:59:10.920 --> 00:59:14.300
And so I can insert a variable and
IntelliJ automatically looks at

00:59:14.300 --> 00:59:16.800
the return type and figures out
that I might wanna call it model.

00:59:16.800 --> 00:59:19.780
I could also call it form model if
I like a little bit more verbosity,

00:59:19.780 --> 00:59:21.740
and it automatically inserts that for me.

00:59:21.740 --> 00:59:25.010
This feature is so effective that
I actually find that I don't even write

00:59:25.010 --> 00:59:28.820
the left-hand side of my code a lot,
I just rely on this and

00:59:28.840 --> 00:59:31.030
just insert the variable.

00:59:31.340 --> 00:59:36.040
And now that I have my variable,
I want to go ahead and

00:59:36.100 --> 00:59:38.580
create the top level panel.

00:59:38.660 --> 00:59:40.780
Notice actually when I do
the code completion here,

00:59:40.780 --> 00:59:43.940
I just type in C and hit the
code completion shortcut.

00:59:43.960 --> 00:59:48.010
And that time it actually didn't work,
but typically it will highlight the

00:59:48.010 --> 00:59:52.310
last method that you invoked because
it keeps track of all the methods you

00:59:52.310 --> 00:59:56.000
invoke and just tries to figure out
which one you're likely to want to do.

00:59:56.030 --> 00:59:59.990
And now I'm gonna go ahead
and get my content pane and

00:59:59.990 --> 01:00:01.390
add this panel definition.

01:00:01.480 --> 01:00:04.480
And so now I have a GUI,
but I'm not really done yet because

01:00:04.480 --> 01:00:05.960
I need to add some behaviors to it.

01:00:05.970 --> 01:00:08.730
And so let me go ahead and do that.

01:00:08.830 --> 01:00:15.340
And I'm gonna get references to a
couple of components that are in my UI.

01:00:15.370 --> 01:00:20.130
And I can just type some abbreviations
of these methods and IntelliJ will

01:00:20.130 --> 01:00:23.400
automatically expand those out for me.

01:00:23.480 --> 01:00:26.080
So you can actually find when
you use all these features,

01:00:26.110 --> 01:00:28.880
the number of keystrokes that you use,
goes down tremendously.

01:00:28.950 --> 01:00:32.040
I'm getting pretty old in years and this
is useful for me because I actually have

01:00:32.040 --> 01:00:34.440
a lot of repetitive stress symptoms.

01:00:34.440 --> 01:00:38.320
And so I find when I use IntelliJ,
I can actually code a lot less

01:00:38.320 --> 01:00:41.640
in terms of number of keystrokes,
which for me is kind of important.

01:00:41.640 --> 01:00:45.140
Now I want to add a listener
to my button for my behaviors.

01:00:45.140 --> 01:00:49.910
IntelliJ has another feature where we
actually will list all the different

01:00:50.020 --> 01:00:53.590
classes in your class leader domain that
implement the listener contract that

01:00:53.810 --> 01:00:55.040
you're currently trying to implement.

01:00:55.140 --> 01:00:57.500
So these are all the action
listeners in my application.

01:00:57.500 --> 01:00:59.500
Here I'm gonna choose one.

01:00:59.580 --> 01:01:02.700
And now that I have my action listener,
I need to prevent reentry in my timer.

01:01:02.700 --> 01:01:03.850
So I'm gonna set the button to enable.

01:01:04.120 --> 01:01:06.500
It marks a squiggly line because,
as you probably know,

01:01:06.500 --> 01:01:09.910
I need to have references inside
of inner classes marked as final.

01:01:10.110 --> 01:01:12.000
It does that for me with
an intention action.

01:01:12.140 --> 01:01:13.800
And now I need to do a
couple of other things.

01:01:13.800 --> 01:01:16.900
I need to get the text that the
user entered from that field.

01:01:16.970 --> 01:01:19.330
And I'm gonna have to mark
that text field final.

01:01:19.500 --> 01:01:21.700
I'm gonna use my
refactoring to get the text.

01:01:21.800 --> 01:01:25.500
And I'm also going to
auto-import my timer utils class,

01:01:25.500 --> 01:01:28.340
which is a shortcut that lets
me cheat because it's a bunch of

01:01:28.340 --> 01:01:31.660
pre-written code that I just didn't
have time to do live in front of you.

01:01:31.660 --> 01:01:36.260
And I'm gonna introduce a variable here,
countdown seconds.

01:01:36.260 --> 01:01:40.110
And I'm not gonna make it, am I?

01:01:40.200 --> 01:01:40.860
Let's see.

01:01:40.860 --> 01:01:45.560
Start long equals system
current utils milliseconds.

01:01:45.560 --> 01:01:48.360
And I just have a couple more lines left.

01:01:48.360 --> 01:01:51.560
So now I need to do the loop where
we actually count down the seconds.

01:01:51.560 --> 01:01:52.730
Start long.

01:01:52.860 --> 01:01:53.830
How am I doing, Francois?

01:01:53.880 --> 01:01:55.300
Do I got a couple more seconds?

01:01:55.360 --> 01:01:57.220
Can you give me a couple more seconds?

01:01:57.220 --> 01:01:58.020
And let's see.

01:01:58.020 --> 01:01:59.020
I need the label here.

01:01:59.020 --> 01:02:00.570
I'm gonna have to mark that as final.

01:02:00.770 --> 01:02:04.410
And ooh, at the very end,
I need to set my button back enabled.

01:02:04.420 --> 01:02:05.220
True.

01:02:05.220 --> 01:02:05.380
All right.

01:02:05.450 --> 01:02:06.560
So that's basically all I wanted to do.

01:02:06.560 --> 01:02:08.500
Are there any obvious problems here?

01:02:08.550 --> 01:02:11.420
One obvious problem is that
I have this loop on the UI thread.

01:02:11.460 --> 01:02:13.480
So before I wrap up,
I just need to put that

01:02:13.480 --> 01:02:14.660
onto a background thread.

01:02:14.660 --> 01:02:16.080
I'm gonna use the surround with feature.

01:02:16.080 --> 01:02:17.540
It's another feature of IntelliJ.

01:02:17.560 --> 01:02:19.670
Oops,
I didn't mean to access that feature.

01:02:19.700 --> 01:02:22.280
I was turning to mark this as final.

01:02:22.300 --> 01:02:24.110
And the right keystroke, yeah.

01:02:24.140 --> 01:02:27.080
And now new thread, runnable.

01:02:27.080 --> 01:02:28.780
Start.

01:02:28.780 --> 01:02:29.380
And OK.

01:02:29.380 --> 01:02:32.310
So we've got-- and there's just one
tiny little additional thing that

01:02:32.400 --> 01:02:33.920
I'm not gonna have time to fix.

01:02:34.100 --> 01:02:36.270
I have to put this
back on the AWT thread.

01:02:36.310 --> 01:02:38.890
But I wanted to show you that
IntelliJ actually keeps track of all

01:02:38.890 --> 01:02:40.360
your to-dos in a central location.

01:02:40.360 --> 01:02:43.340
So you can go back and look at it
and see that you need to solve this.

01:02:43.400 --> 01:02:45.740
And now I can just right
click on my main method.

01:02:45.740 --> 01:02:49.830
And with any luck,
the demo will actually work.

01:02:49.910 --> 01:02:53.190
So that's ideal.

01:02:59.000 --> 01:02:59.350
Thank you.

01:02:59.360 --> 01:03:01.080
Any closing statement?

01:03:01.080 --> 01:03:02.050
No, I'll do it.

01:03:02.320 --> 01:03:04.300
Thanks, Ben.

01:03:04.300 --> 01:03:05.180
Great.

01:03:09.210 --> 01:03:12.590
Let's not let this eclipse Xcode.

01:03:12.640 --> 01:03:15.090
It's our own Java development tool.

01:03:15.110 --> 01:03:18.100
It's the one we're using in my team.

01:03:18.240 --> 01:03:22.100
And the reason we're using it is because
it's the best tool to do cross-language

01:03:22.100 --> 01:03:27.100
development if you're doing Java,
C, Objective-C, C++ side by side.

01:03:27.100 --> 01:03:31.750
It has all the goodies of a modern IDE,
including integrated debugging,

01:03:31.750 --> 01:03:34.080
code sense, no-call power edit.

01:03:34.100 --> 01:03:37.080
What we added this year
are new end templates,

01:03:37.100 --> 01:03:42.020
and I encourage new developers,
students to start here.

01:03:42.100 --> 01:03:47.100
Teams can now use multiple
IDEs and build in harmony.

01:03:47.100 --> 01:03:50.100
You could have half of
your team using Eclipse,

01:03:50.100 --> 01:03:55.090
half of your team using Xcode,
and half of your team using IDEA.

01:03:57.550 --> 01:04:00.510
and the other way around.

01:04:00.540 --> 01:04:02.900
Other Mac OS X tools
available on the platform.

01:04:02.900 --> 01:04:06.650
Well, you have Terminal, Emacs, VI.

01:04:06.760 --> 01:04:10.940
For building and deploying,
I already talked about JAR bundler.

01:04:11.000 --> 01:04:14.550
Shark will be demoed in
our performance session,

01:04:14.550 --> 01:04:17.390
or Java graphics and performance session.

01:04:17.430 --> 01:04:19.440
Quartz Debug as well
will be showcased there.

01:04:19.540 --> 01:04:22.400
What I'd like to show you now is X-Ray.

01:04:22.400 --> 01:04:25.430
X-Ray is our new profiling tool.

01:04:25.460 --> 01:04:28.770
I'd like to welcome Lynn on stage.

01:04:28.800 --> 01:04:34.920
She needs a few more minutes to
showcase X-Ray support for Java.

01:04:36.800 --> 01:04:41.360
In our Java VM session,
we will also show you the new command

01:04:41.360 --> 01:04:43.830
line profiling tool called Dtrace.

01:04:43.840 --> 01:04:46.900
It's coming from Sun and it's working
great on Mac OS X and Leopard.

01:04:46.900 --> 01:04:49.670
So I really encourage you to go see it.

01:04:49.690 --> 01:04:51.440
And I'm off, so Lynn is here.

01:04:51.600 --> 01:04:52.760
Thank you, Francois.

01:04:52.760 --> 01:04:56.990
So I'm going to show you,
yesterday you've probably seen how

01:04:56.990 --> 01:04:59.860
X-Ray works in profiling your tools.

01:04:59.860 --> 01:05:02.520
So I'm going to show you today
how to use it to profile Java.

01:05:03.000 --> 01:05:05.860
So right here I have X-Ray and as
you can see I have my instruments

01:05:05.860 --> 01:05:07.110
down here at the bottom.

01:05:07.220 --> 01:05:11.000
So I'm going to select my
CPU load tool and drag it up

01:05:11.080 --> 01:05:13.100
here and my Java thread tool.

01:05:13.140 --> 01:05:16.300
And in order to start it,
I'm going to click play.

01:05:16.300 --> 01:05:22.360
And, okay, I'm probably going to
have to run this again.

01:05:31.330 --> 01:05:38.720
Okay, once again, I'm going to start with
dragging the CPU load up here.

01:05:40.200 --> 01:05:42.400
and then my Java Thread tool.

01:05:42.440 --> 01:05:44.860
And I'm going to get
rid of the UI recorder,

01:05:44.860 --> 01:05:47.070
so just going to minimize it.

01:05:47.300 --> 01:05:49.160
and I'm going to click play.

01:05:49.210 --> 01:05:52.880
And I'm going to select
a Java demo application,

01:05:52.880 --> 01:05:55.960
which is Java 2D,
and I'm going to open it.

01:05:55.990 --> 01:06:00.110
And as you can see,
I can view the results of my

01:06:00.110 --> 01:06:02.550
sampling at the same time.

01:06:02.600 --> 01:06:08.200
[Transcript missing]

01:06:12.470 --> 01:06:15.240
All right,
it seems to be stuck on something,

01:06:15.240 --> 01:06:17.710
so let me just try this again.

01:06:37.430 --> 01:06:39.890
So, yeah, once again,
let me just put in my

01:06:39.890 --> 01:06:42.380
CPU load and my Java thread.

01:06:42.380 --> 01:06:44.310
I'll click Play.

01:06:51.300 --> 01:06:55.300
All right,
so it seems that all the fooling

01:06:55.300 --> 01:07:02.940
around with the number of processors
and other demos have sort of messed

01:07:02.940 --> 01:07:04.280
up the setup that I had before.

01:07:04.340 --> 01:07:08.730
But anyway, I'm just going to return
this back to Francois.

01:07:08.730 --> 01:07:08.730
Sorry.

01:07:10.930 --> 01:07:13.740
Keep going, I have a few more slides
you can... Alright.

01:07:13.740 --> 01:07:14.740
Keep trying.

01:07:14.740 --> 01:07:19.040
I'll move on to the next slide, please.

01:07:19.040 --> 01:07:23.270
We have a few more minutes,
so we're fine on time.

01:07:25.160 --> 01:07:26.690
Hopefully you can get back to this.

01:07:26.810 --> 01:07:30.280
For more information on Java,
please attend the sessions

01:07:30.380 --> 01:07:31.190
we have this week.

01:07:31.330 --> 01:07:34.750
We have seven,
I'd say five more sessions on Java,

01:07:34.810 --> 01:07:38.080
four more sessions on Java,
two more sessions on WebObjects,

01:07:38.080 --> 01:07:41.990
and a feedback forum
joined for both of them.

01:07:42.270 --> 01:07:46.340
Documentation, sample code,
you should get all your

01:07:46.340 --> 01:07:48.360
information for this URL.

01:07:48.360 --> 01:07:50.190
We want your feedback.

01:07:50.230 --> 01:07:53.200
Please follow us after
this session to the labs.

01:07:53.200 --> 01:07:55.200
We have a feedback forum.

01:07:55.200 --> 01:08:02.000
And emails,
send your emails to Alan Samuel,

01:08:02.000 --> 01:08:03.740
not to me.

01:08:03.740 --> 01:08:05.810
Even though I'm listed,
you can talk to me afterwards.

01:08:06.520 --> 01:08:08.200
And Lynn is still trying.

01:08:08.200 --> 01:08:09.040
- Oh, it works.

01:08:09.040 --> 01:08:09.880
- Coming, okay.

01:08:09.880 --> 01:08:10.700
Back to demo?

01:08:10.700 --> 01:08:12.000
- Yeah.

01:08:12.100 --> 01:08:22.000
[Transcript missing]

01:08:22.570 --> 01:08:25.660
It actually shows me the threads
that are running at the same time

01:08:25.660 --> 01:08:30.560
that I'm actually playing around
with my Java 2D demo application.

01:08:30.610 --> 01:08:36.400
And so my thread instrument's right here,
and I'm going to stop sampling right now.

01:08:36.520 --> 01:08:39.390
I mean,
I'm going to stop running the profiling.

01:08:39.510 --> 01:08:42.780
and zoom out a little bit
so you can see the threads.

01:08:42.790 --> 01:08:45.500
And as you can see,
we have all the threads that

01:08:45.530 --> 01:08:47.300
were currently running up here.

01:08:47.300 --> 01:08:51.960
And the names are up here and
threads that are running are green.

01:08:51.960 --> 01:08:54.710
Threads that are waiting are in
yellow and threads that are blocked,

01:08:54.790 --> 01:08:56.950
I'm going to zoom in a little bit,
you can see are red.

01:08:56.960 --> 01:09:01.240
And you can see in this situation,
the main thread and the AWT event

01:09:01.280 --> 01:09:03.640
queue are blocked in some cases.

01:09:03.640 --> 01:09:07.390
So I'm going to scrub over here to see
this interesting region and I'm going

01:09:07.390 --> 01:09:09.580
to click on the info button right here.

01:09:09.640 --> 01:09:13.920
So as you can see,
my more detailed view shows

01:09:13.920 --> 01:09:17.970
me the names of the threads
that are currently running.

01:09:18.140 --> 01:09:21.560
And it tells me their priorities,
whether they're daemon or not,

01:09:21.560 --> 01:09:22.640
and their state.

01:09:22.790 --> 01:09:25.430
And the most interesting
threads are the main thread,

01:09:25.430 --> 01:09:27.640
which is blocked, and the event queue.

01:09:27.780 --> 01:09:31.730
And I could click on those threads
and look at more extended detail,

01:09:31.730 --> 01:09:33.640
which actually shows me the
stack trace of those threads.

01:09:33.710 --> 01:09:37.150
And the monitors that they own,
so you could actually tell

01:09:37.150 --> 01:09:38.890
what they're blocked on.

01:09:39.190 --> 01:09:42.790
And I could also go back
to the Java Threads view

01:09:42.800 --> 01:09:47.340
and as I change the time,
it actually scrubs along.

01:09:47.340 --> 01:09:51.320
So I'm just going to go back to where
it's blocked and click the info button.

01:09:51.320 --> 01:09:55.600
And you could actually scrub along
this way and your stack trace

01:09:56.170 --> 01:09:58.450
actually changes at the same time.

01:09:58.460 --> 01:10:03.370
So I hope you all use this tool
to profile your Java applications.

01:10:03.390 --> 01:10:04.410
And back to you, Francois.

01:10:11.310 --> 01:10:12.300
Thank you Lynn.

01:10:12.300 --> 01:10:16.180
This is the first,
but hopefully just the first,

01:10:16.180 --> 01:10:20.300
plugin we will develop for
Java profiling on X-Ray.
WEBVTT

00:00:10.290 --> 00:00:11.400
Good afternoon everyone.

00:00:11.490 --> 00:00:17.000
Welcome to the third and final Quartz
Composer session during this WWDC.

00:00:17.070 --> 00:00:20.150
My name is Pierre-Olivier Latour
and I'm the Engineering Manager for

00:00:20.150 --> 00:00:22.350
Quartz Composer at Apple.

00:00:23.220 --> 00:00:25.700
In this session,
titled "Advanced Techniques of

00:00:25.700 --> 00:00:29.090
Quartz Composer," we are going
to learn a number of things.

00:00:29.220 --> 00:00:32.190
First of all,
like the title of that session implies,

00:00:32.200 --> 00:00:35.530
a number of advanced techniques
using either the QC view or

00:00:35.530 --> 00:00:39.820
the QC renderers and how to do
low-level rendering of compositions.

00:00:39.870 --> 00:00:45.730
But then the biggest part of
that session is going to be

00:00:45.730 --> 00:00:45.940
how to write your own patches,
so we'll have a deep look at that.

00:00:46.180 --> 00:00:49.200
Through that session I'm going
to assume a number of things

00:00:49.250 --> 00:00:51.950
that you are already familiar
with the Quartz Composer concept,

00:00:52.020 --> 00:00:54.970
which would be fine if you have
already played with it or if you

00:00:54.970 --> 00:00:59.400
went to either a session this
morning or the one yesterday.

00:00:59.530 --> 00:01:06.350
I'm going to assume you have the
basics of OpenGL as well as the

00:01:06.350 --> 00:01:09.070
basics of the Objective C 2.0 and the
changes that went into that language.

00:01:10.590 --> 00:01:13.000
So let's start with advanced techniques.

00:01:13.060 --> 00:01:14.160
First of all, the QC view.

00:01:14.200 --> 00:01:17.880
Well, the QC view is the easiest way
for you to display Quartz Composer

00:01:17.880 --> 00:01:20.140
contents inside your application.

00:01:20.140 --> 00:01:25.260
The way it works is it's pretty much
an autonomous view that's driven by a

00:01:25.260 --> 00:01:30.210
timer that's running on the main thread,
and every x number of times per second,

00:01:30.240 --> 00:01:33.300
it's going to render a new frame.

00:01:33.300 --> 00:01:36.400
So because the QC view is kind
of living in its own world,

00:01:36.400 --> 00:01:39.600
the question becomes how to
best interact with the rendering

00:01:39.660 --> 00:01:41.730
that's happening in a QC view.

00:01:43.540 --> 00:01:46.300
In part,
we're introducing a new method that's

00:01:46.300 --> 00:01:50.050
called "renderAtTimeArguments".
That method is only for

00:01:50.050 --> 00:01:54.170
subclasses of the QC view,
so you don't want to call that directly.

00:01:54.170 --> 00:01:56.860
And when you subclass QC view
and override that method,

00:01:56.920 --> 00:02:02.650
you do not want to modify the time
or arguments parameters when passing

00:02:02.650 --> 00:02:05.760
them to the super implementation.

00:02:05.890 --> 00:02:07.370
So what's the point of that new method?

00:02:07.380 --> 00:02:10.400
Well, it's to cover two usage cases
when you want to interface

00:02:10.500 --> 00:02:11.960
tightly with the QC view.

00:02:12.130 --> 00:02:14.850
It's either to do
synchronized communication,

00:02:14.850 --> 00:02:18.500
when talking and retrieving
results from the QC view,

00:02:18.500 --> 00:02:21.610
or if you want to even add
your own OpenGL rendering

00:02:21.660 --> 00:02:23.270
as underlays or overlays.

00:02:23.320 --> 00:02:25.560
So let's look at the
synchronized communication.

00:02:25.760 --> 00:02:27.360
What does that exactly mean?

00:02:27.470 --> 00:02:31.670
Well, remember, in the QC view,
the composition is rendering its own

00:02:31.670 --> 00:02:33.160
world and its own rate and so on.

00:02:33.180 --> 00:02:36.790
So the problem becomes,
what if you want to set some input

00:02:36.890 --> 00:02:40.610
parameters of the composition,
but you want to set it for every frame?

00:02:40.670 --> 00:02:43.430
So the way you would do it in
Tiger is by probably having your

00:02:43.430 --> 00:02:46.330
own timer that's running a little
faster than the one of the QC view,

00:02:46.330 --> 00:02:48.370
say, 70 hertz or something like that.

00:02:48.530 --> 00:02:50.650
And then you would end up setting
the parameters all the time,

00:02:50.650 --> 00:02:52.400
but it wouldn't be synchronous.

00:02:52.450 --> 00:02:56.570
So the idea here is that you
can now know precisely when the

00:02:56.570 --> 00:02:59.400
QC view is about to render a frame,
and therefore set your input

00:02:59.400 --> 00:03:02.560
parameters only when necessary
and only at that time.

00:03:02.580 --> 00:03:05.600
And then it renders,
and you retrieve the result.

00:03:05.730 --> 00:03:07.830
So let's look at an example.

00:03:08.150 --> 00:03:09.690
You subclass QC view.

00:03:09.870 --> 00:03:12.780
You override the renderAtTime
arguments method.

00:03:13.130 --> 00:03:15.170
And the first thing you do is
you're going to call super so

00:03:15.180 --> 00:03:18.220
that the QC view is not broken
and actually performs rendering.

00:03:18.340 --> 00:03:22.880
But then before calling super,
you can call a set value for input key

00:03:22.890 --> 00:03:26.640
and set your input parameters at that
time just before rendering happens.

00:03:26.830 --> 00:03:30.380
Then rendering happens,
and you can retrieve the results.

00:03:30.390 --> 00:03:31.380
So it's pretty straightforward.

00:03:33.450 --> 00:03:37.050
A more interesting and let's
say more powerful use of that is

00:03:37.290 --> 00:03:41.550
if you want to add some custom
OpenGL overlays or underlays combined

00:03:41.560 --> 00:03:43.890
with the rendering in the QC view.

00:03:44.350 --> 00:03:46.000
A couple of restrictions there.

00:03:46.020 --> 00:03:48.410
First of all,
we're going to do OpenGL drawing

00:03:48.780 --> 00:03:51.310
and the current context does matter.

00:03:51.480 --> 00:03:55.600
Instead of changing the current
context to the one that the QCV uses,

00:03:55.710 --> 00:03:59.090
it's simpler and more efficient
to just use the CGL macros.

00:03:59.090 --> 00:04:01.860
So there'll be more in a minute.

00:04:01.860 --> 00:04:04.480
A golden rule to follow
when you work inside Quartz

00:04:04.550 --> 00:04:07.270
Composer and do OpenGL code,
and we're going to repeat that a few

00:04:07.320 --> 00:04:10.500
times throughout the presentation,
is make sure you save/restore

00:04:10.500 --> 00:04:11.660
the state you change.

00:04:11.700 --> 00:04:15.080
Open--Quartz Composer is
tightly integrated with OpenGL.

00:04:15.310 --> 00:04:17.130
OpenGL is a giant state machine.

00:04:17.200 --> 00:04:19.660
If you change the states and
you don't restore them properly

00:04:19.660 --> 00:04:22.240
to what they were before,
then the whole system end up

00:04:22.300 --> 00:04:25.440
in an inconsistent state and
your rendering is not correct.

00:04:25.520 --> 00:04:29.070
And finally, you want to make sure you
check for OpenGL errors.

00:04:29.220 --> 00:04:30.410
So here's what it means.

00:04:30.520 --> 00:04:33.800
In that case, we subclass QCVue,
override render at time like

00:04:33.850 --> 00:04:35.180
in the previous example.

00:04:35.240 --> 00:04:39.850
You will notice at the top of the--of
that example sample code that there is

00:04:39.870 --> 00:04:43.330
the inclusion of that CGL macro file,
which basically is going

00:04:43.330 --> 00:04:46.460
to make it so that whenever
you call an OpenGL function,

00:04:46.460 --> 00:04:51.060
it will be targeted to the context,
to a specific OpenGL context that's

00:04:51.060 --> 00:04:55.120
defined by the variable CGL_CTX.

00:04:55.120 --> 00:04:58.510
And it's basically a bunch of
preprocessor macros that expand.

00:04:58.540 --> 00:05:00.890
And this way, you don't have to touch at
all the current context.

00:05:00.900 --> 00:05:03.980
You don't have to try to set it,
to restore it, anything like that.

00:05:04.040 --> 00:05:05.460
It's very straightforward.

00:05:05.460 --> 00:05:09.180
You just retrieve the context
that the QCVue uses by doing,

00:05:09.180 --> 00:05:13.920
in that case, self OpenGL context,
and then CGL context object to retrieve

00:05:13.920 --> 00:05:16.360
the underlying CGL context object.

00:05:16.360 --> 00:05:19.960
And then every OpenGL code you're
going to put there from that point

00:05:19.960 --> 00:05:22.400
on will be sent to that context.

00:05:22.400 --> 00:05:26.280
So about the OpenGL code,
so here's an example that

00:05:26.290 --> 00:05:28.580
would just draw a red quad.

00:05:28.580 --> 00:05:30.480
Remember what I said
that was very important.

00:05:30.480 --> 00:05:32.360
You want to save, restore the steps.

00:05:32.360 --> 00:05:35.500
So the first step at the top
is saving the current step

00:05:35.500 --> 00:05:39.880
that we're about to change,
changing them, then perform the drawing,

00:05:39.880 --> 00:05:41.360
restore the original steps.

00:05:41.360 --> 00:05:46.210
instead and handle any errors.

00:05:48.590 --> 00:05:52.020
Another thing we added to the QC view
in Leopard is the ability to retrieve

00:05:52.200 --> 00:05:55.140
directly the image that it's rendered.

00:05:55.220 --> 00:05:56.500
It's very straightforward as well.

00:05:56.500 --> 00:06:00.720
All you have to do is call on the QC view
you want to retrieve the rendering,

00:06:00.750 --> 00:06:02.740
create snapshot image of type.

00:06:02.830 --> 00:06:06.260
And what's great about that method
is you can specify a number of types.

00:06:06.370 --> 00:06:09.410
So you specify the type as a string,
which can be for instance

00:06:09.410 --> 00:06:12.160
NSBitmapImageRep or
could be CVPixelBuffer.

00:06:12.240 --> 00:06:16.700
That method would take care of
downloading the image from the GPU and

00:06:16.700 --> 00:06:20.060
flipping it vertically if necessary,
because the OpenGL rendering on a

00:06:20.140 --> 00:06:23.420
GPU usually happens upside down,
so you don't even have to deal with that.

00:06:23.670 --> 00:06:28.520
It will provide you directly an object
ready to be used in the format you want.

00:06:28.540 --> 00:06:32.460
Now you've got to be careful because that
method starts with "create" for a reason.

00:06:32.460 --> 00:06:34.520
It means it's going to return
you a brand new object.

00:06:34.520 --> 00:06:36.700
It's not an auto-release,
it's not on the auto-release pool,

00:06:36.730 --> 00:06:41.400
so make sure you call "release" on it
or the appropriate CF release type,

00:06:41.420 --> 00:06:44.690
whatever it is for the image type.

00:06:45.330 --> 00:06:48.740
And you will also want to make sure
for best performances to ask for the

00:06:48.740 --> 00:06:51.820
type that is best suited for what
you're going to do with it afterwards.

00:06:51.940 --> 00:06:55.410
So for example,
if what you want to do is get the image,

00:06:55.510 --> 00:06:58.170
pass it further to QuickTime, well,
QuickTime,

00:06:58.180 --> 00:07:01.800
like the compression session APIs,
they're typically using CVPixel buffers.

00:07:01.800 --> 00:07:03.590
So you ask for a CVPixel buffer.

00:07:03.630 --> 00:07:07.170
If you were to pass it to Core Image,
you would ask for CI Image and so on.

00:07:07.300 --> 00:07:12.900
One of those cases is I want to pass
the rendered image to another QC view

00:07:12.900 --> 00:07:14.670
or QC render or something like that.

00:07:14.770 --> 00:07:19.300
The best type you can use in that case
is CVOpenGL buffer because it is a

00:07:19.300 --> 00:07:23.100
buffer that is on the GPU and therefore
your content will stay on the GPU.

00:07:23.100 --> 00:07:26.400
There is no extra download and
then upload that would be done.

00:07:26.450 --> 00:07:29.290
I'll show you a quick demo
of some of those features.

00:07:32.600 --> 00:07:39.600
[Transcript missing]

00:07:39.810 --> 00:07:42.600
showcasing those two features,
you can see here,

00:07:42.630 --> 00:07:44.630
I got a basic composition
with an Apple logo,

00:07:44.630 --> 00:07:48.040
and I can just rotate it like that,
do some inertia in the logo.

00:07:48.060 --> 00:07:52.920
Well, here, that red frame could be,
for example,

00:07:52.920 --> 00:07:54.860
a set frame area in the video world.

00:07:54.860 --> 00:07:59.270
And that is drawn by a few lines
of OpenGL code that were inserted

00:07:59.270 --> 00:08:01.020
after the drawing of the QC view.

00:08:01.160 --> 00:08:04.870
So it's completely synchronous
with the rendering of the QC view.

00:08:04.880 --> 00:08:09.230
Now, you can see here I also
have a secondary window,

00:08:09.230 --> 00:08:12.820
which has a timer,
and it's simply an NSImageView inside.

00:08:12.820 --> 00:08:15.390
The timer fires 10 times per second.

00:08:15.400 --> 00:08:19.480
Take a snapshot of the main
view and put it as an NSImage

00:08:19.480 --> 00:08:21.910
inside the NSImageView here.

00:08:22.460 --> 00:08:27.590
So it's really simple to do overlay
rendering or underlay or grabbing

00:08:27.590 --> 00:08:30.300
snapshots from the QC view.

00:08:30.300 --> 00:08:32.120
Back to slides please.

00:08:36.500 --> 00:11:33.400
[Transcript missing]

00:11:34.330 --> 00:11:38.010
So like I said earlier,
you can interleave the rendering of the

00:11:38.070 --> 00:11:41.480
QC renderer with your own OpenGL code,
which allows interesting

00:11:41.480 --> 00:11:43.540
underlays and overlays as well.

00:11:43.780 --> 00:11:47.930
In that case, you can see that I took
the same loop as before,

00:11:47.930 --> 00:11:50.620
but I added a bit of
OpenGL code before and after,

00:11:50.620 --> 00:11:53.140
where you would draw
some kind of background,

00:11:53.190 --> 00:11:55.200
then you draw the composition.

00:11:55.200 --> 00:12:00.040
Obviously,
we're assuming here that the composition

00:12:00.040 --> 00:12:03.720
is not covering the whole drawing area.

00:12:03.720 --> 00:12:06.670
Otherwise,
it's pointless to draw something before.

00:12:06.670 --> 00:12:06.670
And then you can draw some
overlay with some GL code.

00:12:09.140 --> 00:12:12.530
If you want to communicate with the
compositions through the QC renderer,

00:12:12.570 --> 00:12:15.240
it's the same exact set of
methods as on the QC view.

00:12:15.380 --> 00:12:19.390
So, set value for input key will set an
input parameter on the composition.

00:12:19.640 --> 00:12:25.400
Value for output key will retrieve an
output result from the composition.

00:12:25.450 --> 00:12:28.970
Now, regarding the arguments you can pass
when you call renderer time arguments,

00:12:29.050 --> 00:12:31.290
there are two of them and
they're completely optional.

00:12:31.400 --> 00:12:34.090
The first one is QC renderer event key.

00:12:34.140 --> 00:12:38.100
If you have an NS event around,
because your QC renderer,

00:12:38.100 --> 00:12:41.040
the result is being displayed
in Windows or something and then

00:12:41.120 --> 00:12:44.620
you have NS events flowing in,
you should pass it in to the

00:12:44.620 --> 00:12:48.340
QC renderer when you call renderer time,
pass only the current event.

00:12:48.410 --> 00:12:50.370
And this will allow patches
that depend on events,

00:12:50.480 --> 00:12:53.300
for example,
the keyboard or the mouse to work

00:12:53.300 --> 00:12:55.640
properly for the mouse clicks and such.

00:12:55.700 --> 00:13:01.190
If another optional argument is
passing the current mouse location,

00:13:01.260 --> 00:13:04.460
so the way we do that here is
you put the mouse location as an

00:13:04.460 --> 00:13:09.690
NS point stored inside an NS value
and the coordinate system for the

00:13:09.750 --> 00:13:13.990
mouse must be normalized 01 to 01.

00:13:16.670 --> 00:13:20.110
A great thing about the QC Renderer
is that you can do offline rendering.

00:13:20.120 --> 00:13:23.890
You could have a custom thread that's
a separate thread from the main thread

00:13:23.890 --> 00:13:27.840
that's rendering composition in the
background or something like that.

00:13:27.840 --> 00:13:30.870
Or you can just have a common line
tool that's rendering composition

00:13:30.870 --> 00:13:34.160
directly to a bunch of TIFF files,
things like that.

00:13:34.360 --> 00:13:38.720
Well, we made it easier in Leopard where
there is a new method on QC Renderer

00:13:38.720 --> 00:13:42.740
called InitOffScreenWithSize,
Colorspace and File.

00:13:42.830 --> 00:13:46.270
So what it does is taking care completely
of creating the OpenGL context,

00:13:46.270 --> 00:13:49.200
the P buffer to render on the GPU,
all of that, you don't even need to

00:13:49.200 --> 00:13:50.070
know about how it works.

00:13:50.120 --> 00:13:51.050
You just use it.

00:13:51.080 --> 00:13:53.280
You specify a file, a color space.

00:13:53.280 --> 00:13:56.830
You can even pass null instead of a
color space to get the default one,

00:13:56.830 --> 00:13:58.080
and you're good to go.

00:13:58.080 --> 00:14:02.040
Now,
that rendering still happens on a GPU,

00:14:02.040 --> 00:14:05.240
always happens on a GPU,
which means you cannot render at size

00:14:05.240 --> 00:14:09.180
that won't be supported on a GPU,
for example, like 16,000 by 10,000.

00:14:09.180 --> 00:14:10.480
That wouldn't work.

00:14:10.550 --> 00:14:14.440
Typically, the size limitation is 2K,
2K on the current hardware.

00:14:14.480 --> 00:14:19.010
But-- most of the machines we're shipping
today are probably more than 4K and 4K.

00:14:19.290 --> 00:14:21.980
And depending on the amount
of VRAM you will have around,

00:14:21.980 --> 00:14:24.820
the rendering will
happen more or less fast.

00:14:25.970 --> 00:14:29.460
I would like to now look at a
very interesting possibility

00:14:29.460 --> 00:14:33.830
we added in Mac OS X Leopard,
which is the ability to do

00:14:33.830 --> 00:14:36.180
chaining of compositions.

00:14:36.180 --> 00:14:39.730
The idea behind that is that instead
of having a big monolithic composition

00:14:39.760 --> 00:14:43.070
with a ton of patches inside,
you divide it into a set of

00:14:43.350 --> 00:14:46.860
primary composition and then a
bunch of sub-compositions that

00:14:46.860 --> 00:14:50.420
are well-defined and that you load
dynamically into the first one.

00:14:50.420 --> 00:14:53.520
So that was not possible in
Mac OS X Tiger and you can now do

00:14:53.520 --> 00:14:58.220
that in Leopard using a new patch
that's called the Composition Loader.

00:14:58.220 --> 00:15:00.130
So let's do a demo of that.

00:15:02.800 --> 00:15:13.800
[Transcript missing]

00:15:14.010 --> 00:15:22.350
The Quartz Composer is a powerful
visual programming tool for using

00:15:22.350 --> 00:15:27.080
graphics and animation on the Mac.

00:15:27.080 --> 00:15:27.080
With Quartz Composer you can easily
explore the graphics stack in Mac OS X.

00:15:27.080 --> 00:15:27.080
Mac OS X Leopard brings a number
of new APIs as well as the ability

00:15:27.080 --> 00:15:27.080
to write custom ""patches""
for use in your compositions,

00:15:27.080 --> 00:15:27.080
allowing you to take Quartz Composer
further than it's ever gone before.

00:15:27.080 --> 00:15:27.080
We'll demonstrate this new technology
as well as advanced API techniques

00:15:27.080 --> 00:15:27.080
for integrating Quartz Composer
technology into your applications,

00:15:27.080 --> 00:15:27.080
allowing you to take Quartz Composer
together with your computer.

00:15:28.480 --> 00:15:33.700
is applying some kind of neon effect
to an input image and you can also

00:15:33.760 --> 00:15:36.460
pick the color of that neon effect.

00:15:36.780 --> 00:15:40.800
What I want to do now is build a
new composition from scratch that

00:15:40.830 --> 00:15:45.540
puts these two sub-compositions
into this master one.

00:15:45.540 --> 00:15:48.530
So let me organize that quite a bit.

00:15:49.920 --> 00:15:54.600
Okay, so what we need is that new patch
called the Composition Loader.

00:15:54.600 --> 00:15:57.000
I'm going to create an instance of it.

00:15:57.470 --> 00:15:59.980
The first thing you expect from
it is the ability to specify the

00:15:59.980 --> 00:16:03.140
composition to actually render,
and there is an input for that,

00:16:03.140 --> 00:16:06.290
composition location,
which will accept the file path, the URL,

00:16:06.290 --> 00:16:07.190
usual things.

00:16:07.290 --> 00:16:10.770
So let's take that gradient composition.

00:16:12.760 --> 00:16:15.750
It's loaded and now it's rendering here.

00:16:15.960 --> 00:16:19.210
However, that would be pretty limited
if you were only able to load

00:16:19.210 --> 00:16:20.460
composition and render them.

00:16:20.460 --> 00:16:23.880
What we want to do as well is
communicate with the inputs

00:16:23.880 --> 00:16:25.750
and outputs and we can do that.

00:16:25.860 --> 00:16:29.500
If you display the inspector for
the new composition loader patch,

00:16:29.540 --> 00:16:31.200
go to the settings pane.

00:16:31.260 --> 00:16:34.560
You can configure a kind of
template with the inputs and

00:16:34.560 --> 00:16:36.370
outputs of the composition.

00:16:36.580 --> 00:16:39.650
If I look again at the
gradient composition,

00:16:39.750 --> 00:16:42.680
there is one input and
the key is "image."

00:16:44.550 --> 00:16:48.870
So here in the settings of that patch,
I'm going to say I have an image

00:16:48.870 --> 00:16:52.740
of type-- I have a-- sorry,
an input of type image

00:16:52.740 --> 00:16:54.580
with the key image.

00:16:54.620 --> 00:16:55.940
Create that.

00:16:55.940 --> 00:16:58.690
You can see the image is
now available as an input.

00:16:58.820 --> 00:17:03.740
And I can take my Apple logo
and connect it there.

00:17:03.740 --> 00:17:04.690
And it just works.

00:17:04.700 --> 00:17:07.020
Now,
what would exactly happen if I were to

00:17:07.020 --> 00:17:12.840
load a composition that doesn't have an
image input with the key input image?

00:17:12.900 --> 00:17:13.540
Well, nothing.

00:17:13.540 --> 00:17:15.300
I mean, you wouldn't get an error.

00:17:15.300 --> 00:17:16.340
It wouldn't get connected.

00:17:16.340 --> 00:17:20.470
So you can see the inputs and outputs
that you define on the compositor,

00:17:20.500 --> 00:17:23.390
on the composition loader,
as kind of a weak template

00:17:23.390 --> 00:17:25.000
of inputs and outputs.

00:17:25.000 --> 00:17:28.920
If the composition that's loaded has
one or more of those inputs and outputs,

00:17:29.050 --> 00:17:31.740
they will automatically get connected,
and you can talk to those

00:17:31.740 --> 00:17:35.060
inputs and outputs through the
inputs and outputs of the patch.

00:17:35.080 --> 00:17:37.720
If they don't exist, well, no big deal.

00:17:37.720 --> 00:17:38.670
You don't get errors.

00:17:38.680 --> 00:17:41.010
It doesn't crash or anything like that.

00:17:42.020 --> 00:17:47.040
Now let's insert our effect,
the neon effect.

00:17:47.080 --> 00:17:48.850
I'm going to create
another Composition Loader,

00:17:48.870 --> 00:17:51.730
and in that case we also
have something interesting,

00:17:51.730 --> 00:17:53.160
which is

00:17:54.090 --> 00:17:55.950
We don't want that neon effect to render.

00:17:56.030 --> 00:18:00.180
We want it to be inserted between
the Apple logo image and the

00:18:00.180 --> 00:18:05.260
image that's displayed in the
second composition loader here.

00:18:05.810 --> 00:18:08.240
So let's look at the settings.

00:18:08.240 --> 00:18:13.600
And you can see that the top
setting is the type of patches.

00:18:13.600 --> 00:18:17.080
So remember, there are several types of
patches in Quartz Composer--

00:18:17.080 --> 00:18:21.160
three to be precise-- processor,
consumer, and provider.

00:18:21.160 --> 00:18:25.250
And obviously, the system,
when it loads a composition from disk,

00:18:25.310 --> 00:18:28.200
the type definitely matters.

00:18:28.200 --> 00:18:32.040
So in our case,
we are going to use that neon

00:18:32.040 --> 00:18:38.140
composition as a processor with
the input image and color inputs.

00:18:38.140 --> 00:18:42.280
And it also has an output,
which we can see by

00:18:42.280 --> 00:18:43.340
looking at the composition.

00:18:43.460 --> 00:18:45.140
Because right now,
we don't have a way to display

00:18:45.140 --> 00:18:46.220
the outputs on the viewer.

00:18:46.220 --> 00:18:49.040
We only display the inputs in that area.

00:18:49.040 --> 00:18:53.730
You can see it has a published output,
which has the key output image.

00:18:54.190 --> 00:18:58.130
So I can go back here,
set the execution mode to processor,

00:18:58.130 --> 00:19:03.090
and now I can define inputs and outputs
because consumers have that particularity

00:19:03.100 --> 00:19:05.090
that they're not allowed to have outputs.

00:19:05.190 --> 00:19:08.560
So now the two sets are
visible and I can add--

00:19:09.490 --> 00:19:14.060
An image input with the key input
"image", an image output with

00:19:14.320 --> 00:19:22.000
the key output "image". Let's
specify the composition location.

00:19:26.000 --> 00:19:35.400
[Transcript missing]

00:19:37.300 --> 00:19:39.450
So as you can imagine,
that opens the door to pretty

00:19:39.540 --> 00:19:41.320
powerful possibilities.

00:19:41.370 --> 00:19:44.660
And as a demonstration of that,
for those of you who

00:19:44.660 --> 00:19:47.540
were present last year,
there was this hands-on

00:19:47.540 --> 00:19:50.240
session that I gave where,
at the end,

00:19:50.400 --> 00:19:53.560
we were building a fact TV system
that was called the QC TV.

00:19:53.600 --> 00:19:56.740
And it's a sample code that you
can get from the ADC website.

00:19:56.810 --> 00:20:00.500
The way it was implemented is that
there were a number of composition

00:20:00.500 --> 00:20:04.410
for each part of the TV setup,
where you have one composition that

00:20:04.410 --> 00:20:09.680
handles the crawler at the bottom,
another one that renders the

00:20:09.710 --> 00:20:12.320
upper bar with the logo and such.

00:20:12.340 --> 00:20:14.190
Each of them was a different composition.

00:20:14.200 --> 00:20:17.440
And then in the source code,
there was a QC renderer for

00:20:17.440 --> 00:20:18.360
each of the composition.

00:20:18.360 --> 00:20:22.140
And everything was put
together in an OpenGL context.

00:20:22.180 --> 00:20:25.120
Well, now doing the sensing
would be a lot simpler,

00:20:25.320 --> 00:20:30.460
because I have here a composition
folder with all the sub-compositions,

00:20:30.530 --> 00:20:34.670
which is really convenient when you
want to have artists or programmers

00:20:34.670 --> 00:20:37.920
work on separate composition
without having everyone touching

00:20:37.920 --> 00:20:40.220
on that big master composition.

00:20:40.220 --> 00:20:41.400
So it gives you granularity.

00:20:41.400 --> 00:20:44.600
It gives you an easy way to
replace sub-compositions.

00:20:44.600 --> 00:20:48.100
And here,
it's really a bunch of composition

00:20:48.270 --> 00:20:52.060
loaders that are configured with
the proper inputs and outputs.

00:20:52.060 --> 00:20:56.080
And now, on the code side,
you would simply have one QC renderer or

00:20:56.080 --> 00:20:59.590
one QC view to be able to render that,
instead of having a number of

00:20:59.590 --> 00:21:03.520
QC renderers and do all the logic to
render them in a proper order and such.

00:21:03.570 --> 00:21:05.210
So that would simplify
your life quite a bit.

00:21:05.680 --> 00:21:11.020
Let's go back to the slides, please.

00:21:14.940 --> 00:21:17.840
Now it's time to get down and
dirty with the real thing,

00:21:17.870 --> 00:21:20.430
which is writing your own patches.

00:21:21.520 --> 00:21:23.620
This has been the number
one developer request,

00:21:23.650 --> 00:21:26.420
as you can imagine,
so the nice thing about it is that, yes,

00:21:26.480 --> 00:21:29.300
it does make sense for you
to send all your requests and

00:21:29.300 --> 00:21:32.360
bugs to bugreport@apple.com
and it actually works,

00:21:32.360 --> 00:21:33.600
so we listen to them.

00:21:33.730 --> 00:21:36.590
We wanted it,
that ability to write custom patches,

00:21:36.720 --> 00:21:39.090
simple and powerful like
the rest of Quartz Composer,

00:21:39.090 --> 00:21:43.730
which concretely means we wanted it
easy to be able to manage your set of

00:21:43.750 --> 00:21:49.170
inputs and outputs on the custom patch,
easy to make, to do image processing or

00:21:49.180 --> 00:21:53.280
OpenGL rendering or even provide a
custom user interface to edit kind of

00:21:53.280 --> 00:21:55.250
the internal settings of your patch.

00:21:55.370 --> 00:21:58.650
So to achieve that goal,
we actually built completely

00:21:58.650 --> 00:22:02.300
a custom patch mechanism
on top of Objective-C 2.0,

00:22:02.390 --> 00:22:06.790
which as a side effect implies that
those custom patches that you write

00:22:06.820 --> 00:22:10.790
will only work on Mac OS X Leopard.

00:22:10.910 --> 00:22:15.030
Let me introduce you to that
new class called the QC plugin.

00:22:17.120 --> 00:22:20.100
This is the base class for
writing your custom patches.

00:22:20.190 --> 00:22:22.300
It is itself a subclass of NSObject.

00:22:22.320 --> 00:22:26.720
And the way it's going to work is that
you subclass in turn the QCPlugin class.

00:22:26.740 --> 00:22:30.620
You implement one or more-- you implement
or override one or more methods,

00:22:30.620 --> 00:22:33.620
the one you need,
define the inputs and outputs,

00:22:33.640 --> 00:22:37.100
implement how exactly the
patch executes and so on.

00:22:37.130 --> 00:22:39.660
And then you end up with a
plugin that you can put at the

00:22:39.660 --> 00:22:41.490
appropriate location on disk.

00:22:41.720 --> 00:22:46.280
It gets loaded inside Quartz Composer
and turns into a custom patch.

00:22:47.750 --> 00:22:50.610
There are a few requirements
when you write custom patches.

00:22:50.730 --> 00:22:59.630
The first of them is that, obviously,
you want to be a good citizen and your

00:22:59.750 --> 00:23:03.530
custom patch must be able to have-- well,
let's say your QC plugin subclass

00:23:03.530 --> 00:23:03.530
must be able to generate multiple
instances of those custom patches.

00:23:03.770 --> 00:23:05.830
And that's really a requirement.

00:23:05.910 --> 00:23:09.660
The other one is that you've got
to be able to write code that

00:23:09.740 --> 00:23:11.480
is going to work on any thread.

00:23:11.790 --> 00:23:13.540
We're not talking about reentrant code.

00:23:13.710 --> 00:23:16.390
But we're talking about code that
doesn't matter if it's executed

00:23:16.390 --> 00:23:20.160
on the main thread or a background
thread or those kind of things.

00:23:20.160 --> 00:23:22.970
In the same direction,
you also need to make code that works

00:23:23.000 --> 00:23:24.980
if you don't have a run loop around.

00:23:25.070 --> 00:23:29.390
So for some system services,
the way they work is they require

00:23:29.390 --> 00:23:32.630
a run loop to be able to post
notifications and things like that.

00:23:32.700 --> 00:23:36.210
If you want to use those APIs inside
one of your custom patches,

00:23:36.240 --> 00:23:39.940
you will likely need to
spin off a custom thread.

00:23:39.960 --> 00:23:41.850
And then in that thread,
have a run loop and then

00:23:41.890 --> 00:23:43.110
communicate with the patch.

00:23:45.370 --> 00:23:47.290
Here are the basics of
the QC plugin class.

00:23:47.510 --> 00:23:51.210
So you subclass it,
and then the first two methods you are

00:23:51.210 --> 00:23:54.770
likely to implement are attributes,
which is called so that the

00:23:54.820 --> 00:23:58.550
system can retrieve the name,
description, and so on for the UI.

00:23:58.710 --> 00:24:05.770
And if you need to,
you can implement init and dialog,

00:24:05.770 --> 00:24:05.770
which are the way the plugin
instances are created.

00:24:06.630 --> 00:24:10.580
Now the important thing is how
do those custom patches execute?

00:24:10.700 --> 00:24:13.670
Well, there are a number of methods
on the QC plugin class that

00:24:13.670 --> 00:24:15.580
you implement whenever needed.

00:24:15.800 --> 00:24:20.320
You will notice that there is a
certain symmetry in those methods.

00:24:20.510 --> 00:24:22.970
So what happened is
when the engine starts,

00:24:22.970 --> 00:24:25.990
start execution is called
on your plugin instance.

00:24:25.990 --> 00:24:29.170
When the engine shuts down,
stop execution is called.

00:24:29.410 --> 00:24:32.000
When your patch starts being
used by the engine because

00:24:32.000 --> 00:24:35.570
somebody's pulling data from it,
pulling, let's say, results from it,

00:24:35.690 --> 00:24:37.330
then enable execution is called.

00:24:37.330 --> 00:24:41.310
And when nobody needs the data anymore,
for example, for several minutes before

00:24:41.320 --> 00:24:43.890
it's being used again,
disable execution is called.

00:24:44.110 --> 00:24:46.410
And at the core of it,
we have the execute method,

00:24:46.410 --> 00:24:50.270
which is called by the engine whenever
results are needed from your patch.

00:24:53.060 --> 00:24:56.670
You will have likely noticed that all
those methods were taking a parameter

00:24:56.670 --> 00:25:02.040
that was an opaque object complying
to the QC plugin context protocol.

00:25:02.060 --> 00:25:04.920
That protocol defines the
number of methods that you can

00:25:04.920 --> 00:25:07.590
use to get information about
the rendering destination,

00:25:07.590 --> 00:25:09.910
like obviously the bounds,
the color space,

00:25:09.910 --> 00:25:13.840
and the OpenGL context to render to it,
as well as a couple utilities so that you

00:25:13.860 --> 00:25:19.600
can send a message to the Quartz Composer
log or store some user information.

00:25:19.620 --> 00:25:24.310
The interest of that user information
method is that this mutable

00:25:24.310 --> 00:25:29.070
dictionary is shared between
all your instances that are running

00:25:29.070 --> 00:25:31.070
in the same Quartz Composer context.

00:25:31.150 --> 00:25:34.760
So that's a great way if you need to
do caching that is shared between your

00:25:34.760 --> 00:25:40.820
various instances in the same context
to use the user info dictionary.

00:25:40.850 --> 00:25:41.760
You want to be careful.

00:25:41.820 --> 00:25:45.190
Do not retain that
QC plugin context object.

00:25:45.220 --> 00:25:49.500
Do not make calls to it outside of
the scope of those execution methods.

00:25:49.610 --> 00:25:53.930
It's really a dedicated object for that,
for only being used inside

00:25:53.980 --> 00:25:55.780
the execution methods.

00:25:56.610 --> 00:25:58.840
So the core execution,
like I mentioned earlier,

00:25:58.840 --> 00:26:01.090
is all about that execute method.

00:26:01.200 --> 00:26:04.490
So remember, in Course Composer,
we have patches.

00:26:04.570 --> 00:26:07.150
Those custom patches are going
to execute in the environment

00:26:07.180 --> 00:26:08.470
of the QC plugin context.

00:26:08.550 --> 00:26:10.990
They get their input parameters.

00:26:11.070 --> 00:26:12.080
You read the values.

00:26:12.310 --> 00:26:14.730
So that means reading the
values from the input port.

00:26:14.820 --> 00:26:18.860
Then you do computations in your
execute method to build the result.

00:26:18.860 --> 00:26:21.670
You can also take the time
into account if necessary.

00:26:21.820 --> 00:26:23.950
And finally,
you output those results to the

00:26:24.140 --> 00:26:28.110
output ports of of your patch,
or you render it to the destination.

00:26:28.590 --> 00:26:32.440
There are two more things we need
to define regarding execution.

00:26:32.560 --> 00:26:36.730
Like I mentioned earlier
with the CompositionLoader,

00:26:36.880 --> 00:26:40.010
those three types of patches, Provider,
Processor, and Consumer,

00:26:40.010 --> 00:26:41.660
are fairly important to the system.

00:26:41.660 --> 00:26:47.500
So you need to implement the plus
execution method in your class to define

00:26:47.640 --> 00:26:51.980
what's the execution mode for your patch.

00:26:52.050 --> 00:26:55.470
So as a reminder here,
providers are the ones that are executed

00:26:55.470 --> 00:26:58.840
whenever their outputs are needed,
but no more than once per frame.

00:26:58.900 --> 00:27:00.690
Processors are kind of the lazy patches.

00:27:00.740 --> 00:27:02.940
They're only executed when
their input change and their

00:27:02.970 --> 00:27:06.180
output change are needed.

00:27:06.340 --> 00:27:10.010
Or the consumer always are the one
putting the data from the two others,

00:27:10.010 --> 00:27:12.460
and they're pretty much always executed.

00:27:13.560 --> 00:27:17.600
You also need to specify the
time dependency of the patch.

00:27:17.710 --> 00:27:18.450
Three cases.

00:27:18.580 --> 00:27:21.350
Either your patch doesn't care
about the time at all in its execute

00:27:21.400 --> 00:27:25.810
method-- it just ignores the parameter,
so the type is none-- or it

00:27:25.810 --> 00:27:30.290
can definitely take the time
into account its computation,

00:27:30.290 --> 00:27:33.380
so you would say the
patch has a time base.

00:27:33.470 --> 00:27:36.040
Or there is kind of an intermediate
case where you have some patches

00:27:36.040 --> 00:27:38.720
that just need some idle time,
because it could be a provider patch

00:27:38.720 --> 00:27:41.950
that's connected to some hardware,
and you want to make sure it

00:27:41.950 --> 00:27:44.600
pulls data from it whenever
it's needed by the engine.

00:27:44.600 --> 00:27:47.510
So you don't truly depend on time,
but you need some idling going on.

00:27:47.700 --> 00:27:51.010
So that's the kind of a special
case that is defined by the

00:27:51.270 --> 00:27:53.200
KQC plugin timeModeIdle.

00:27:53.360 --> 00:27:54.150
But it's pretty rare.

00:27:54.160 --> 00:27:56.760
You shouldn't use that very often.

00:27:57.620 --> 00:28:01.670
So we define how the patches execute,
when they get executed, and so on.

00:28:01.680 --> 00:28:03.930
The last thing we need to look at is,
well,

00:28:04.120 --> 00:28:06.730
how do I define my inputs and outputs?

00:28:06.930 --> 00:28:11.540
So we're completely leveraging
the Objective-C 2.0 properties.

00:28:11.580 --> 00:28:15.960
And the way we do that is if you define
a property of your subclass whose name

00:28:15.990 --> 00:28:20.580
starts with input and output and whose
type is one of the supported types,

00:28:20.600 --> 00:28:24.320
then we automatically turn that into
an input and output-- or output,

00:28:24.320 --> 00:28:26.710
sorry-- on the patch.

00:28:26.840 --> 00:28:31.500
So for instance,
you can see here I have a dynamic

00:28:31.500 --> 00:28:37.230
property called input value one,
double, and that will turn into an input

00:28:37.300 --> 00:28:42.000
port on your patch with the key
input value one and of type number.

00:28:42.060 --> 00:28:46.420
So the same thing for input value two,
and it's pretty much the same thing

00:28:46.420 --> 00:28:48.920
for an output result property.

00:28:48.980 --> 00:28:53.590
You still need to define--
it's not mandatory,

00:28:53.600 --> 00:28:57.390
but it would be nice for the UI--
that to provide some description for

00:28:57.490 --> 00:29:00.420
your inputs and outputs so that when
you're in a Quartz Composer editor,

00:29:00.420 --> 00:29:04.490
you see a normal name instead
of saying input value one.

00:29:04.580 --> 00:29:07.000
So for that,
you override the method attributes

00:29:07.390 --> 00:29:11.500
for property port with key,
and that will get called by the system.

00:29:11.510 --> 00:29:13.520
And it will pass, for instance,
input value one,

00:29:13.520 --> 00:29:16.810
and you can return a dictionary that
contains the name and the default value,

00:29:16.810 --> 00:29:18.650
those kind of things.

00:29:19.760 --> 00:29:22.060
How do you read and write
to those property ports?

00:29:22.070 --> 00:29:24.200
Well,
the beauty of Objective-C 2.0 is that

00:29:24.420 --> 00:29:26.500
it becomes completely transparent.

00:29:26.500 --> 00:29:28.940
You want to read from one
of those property ports,

00:29:29.100 --> 00:29:30.960
input value one.

00:29:30.960 --> 00:29:33.620
You just access it like if
it was an IVAR of your class.

00:29:33.620 --> 00:29:35.100
It's that transparent.

00:29:35.100 --> 00:29:38.370
It will automatically make
a round trip to the port,

00:29:38.520 --> 00:29:41.900
query the value, and return it,
as if you were using an IVAR.

00:29:41.900 --> 00:29:44.930
If you want to write to an output,
it's the exact same mechanism.

00:29:45.280 --> 00:29:49.040
So there is a little
thing to be aware of.

00:29:49.040 --> 00:29:52.440
It's definitely more expensive
than reading and writing to an

00:29:52.440 --> 00:29:55.690
IVAR because of that round trip
to the input or output port.

00:29:55.910 --> 00:29:59.390
So if you have a loop,
like a for loop or any kind of loop,

00:29:59.460 --> 00:30:04.200
it is definitely recommended to actually
cache the value before you do that loop

00:30:04.270 --> 00:30:06.460
and use the cached value in the loop.

00:30:06.460 --> 00:30:10.660
As a hint,
what you may do in your code is instead

00:30:10.740 --> 00:30:16.010
of typing input value one in your source
code to read or write to a property port,

00:30:16.080 --> 00:30:18.020
you can do self.inputValue1.

00:30:18.100 --> 00:30:18.360
It works exactly the same.

00:30:18.390 --> 00:30:22.050
But in that case,
when you read your code again later,

00:30:22.110 --> 00:30:24.280
it will remind you, oh,
I'm actually not reading

00:30:24.280 --> 00:30:25.260
and writing to an IVAR here.

00:30:25.330 --> 00:30:29.070
I'm accessing a property of myself.

00:30:29.360 --> 00:30:32.790
And therefore,
if you see self.foo inside a loop,

00:30:32.920 --> 00:30:36.140
then you know you should
move that out of the loop.

00:30:37.400 --> 00:30:39.590
Now,
not all patches want to have a pretty

00:30:39.590 --> 00:30:41.340
fine number of inputs and outputs.

00:30:41.410 --> 00:30:44.590
So obviously, we provide a way for you to
add custom inputs and outputs.

00:30:44.600 --> 00:30:46.090
And it's pretty straightforward.

00:30:46.300 --> 00:30:48.450
You call addInputPortWithType.

00:30:48.470 --> 00:30:51.750
The type is going to be, for example,
Boolean, string number,

00:30:51.790 --> 00:30:52.880
those kind of things.

00:30:52.920 --> 00:30:56.940
And then the key to use for the port,
as well as optional attributes,

00:30:56.940 --> 00:31:00.190
which are the same attributes as
the EWD return for property ports,

00:31:00.190 --> 00:31:03.060
like name, default value,
those kind of things.

00:31:03.070 --> 00:31:06.380
And it's the exact same
mechanism to create output ports.

00:31:06.400 --> 00:31:09.420
Because those are not property ports,
when you want to read and write to them,

00:31:09.420 --> 00:31:11.140
you need to go through
an explicit method.

00:31:11.140 --> 00:31:15.090
And it's called valueForInputKey,
or it's called setValueForOutputKey

00:31:15.090 --> 00:31:16.720
to write to the outputs.

00:31:18.370 --> 00:31:19.960
Here's a detailed list.

00:31:20.180 --> 00:31:24.450
And you can see on the left column,
the first one, the type of port in the

00:31:24.500 --> 00:31:27.120
course of the world,
for example, Color.

00:31:27.350 --> 00:31:32.130
You can see the type of the
Objective-C 2.0 property that is

00:31:32.130 --> 00:31:35.110
required so that your property
turns into a Color port.

00:31:35.220 --> 00:31:37.750
In that case, that will be CG ColorRef.

00:31:37.770 --> 00:31:40.740
If you create it directly
by calling addInputPort,

00:31:40.840 --> 00:31:44.810
the type would be the
QC Port Type Color constant.

00:31:45.170 --> 00:31:50.300
And if you were to talk to
it using setValueForInputKey,

00:31:50.330 --> 00:31:54.180
valueForOutputKey,
the type you would get is CG ColorRef.

00:31:54.200 --> 00:31:58.580
You may notice here that we're taking a
break from the usual Course Commoder API,

00:31:58.580 --> 00:31:59.850
which are really flexible.

00:31:59.920 --> 00:32:03.290
And they would typically
allow you to pass an NSColor,

00:32:03.300 --> 00:32:05.810
a CI Color, a CG Color,
pretty much anything.

00:32:05.920 --> 00:32:09.260
Well, the idea here is that the code
you write is executing inside

00:32:09.260 --> 00:32:10.420
the Course Commoder Engine.

00:32:10.420 --> 00:32:12.990
So for performance reasons,
we need to make sure we minimize

00:32:13.000 --> 00:32:14.300
the number of conversions.

00:32:14.490 --> 00:32:17.560
And if we allow people to write
a patch that take an NSColor,

00:32:17.560 --> 00:32:20.120
the next one that takes a CI Color, well,
we would need to convert

00:32:20.120 --> 00:32:22.890
that all the time,
which might still be OK for colors,

00:32:22.890 --> 00:32:26.470
but as you can imagine, for images,
it would be pretty expensive.

00:32:26.570 --> 00:32:33.370
So we have restricted it to one type of
object per type of Course Commoder Port.

00:32:34.820 --> 00:32:38.980
The last thing we need to do is when we
build our plugin to package it somewhere,

00:32:39.130 --> 00:32:43.120
and QC plugins, you simply put them into
standard Cocoa bundles.

00:32:43.270 --> 00:32:46.690
The only specificity they're going
to have is a special entry in

00:32:46.710 --> 00:32:52.260
the Info.plist of the bundle that
list the subclasses of QC plugin

00:32:52.260 --> 00:32:53.870
that you have in that bundle.

00:32:54.120 --> 00:32:56.560
Then you put that plugin
in the proper location,

00:32:56.680 --> 00:32:59.320
library graphics,
course composer plugins.

00:32:59.320 --> 00:33:01.850
You cannot put them in the
tilde library graphics,

00:33:01.900 --> 00:33:03.740
they won't get loaded here.

00:33:03.740 --> 00:33:08.020
Only library graphics,
because we want for security reasons,

00:33:08.070 --> 00:33:11.680
have administrator only have the
rights to install those plugins.

00:33:11.710 --> 00:33:16.460
Or you can also load the plugins
directly from inside your application

00:33:16.460 --> 00:33:18.620
if for whatever reason you don't
want to install the plugin and

00:33:18.620 --> 00:33:20.180
make it available for everyone.

00:33:20.280 --> 00:33:22.580
So you can either load a
plugin from an arbitrary pass,

00:33:22.580 --> 00:33:25.310
or you can have the code mixed
with your application code and

00:33:25.320 --> 00:33:29.380
just called registerPluginClass,
class being a subclass of QC plugin.

00:33:29.490 --> 00:33:33.250
One thing I did not mention here
is that even if you install your

00:33:33.450 --> 00:33:37.880
custom plugin at the proper location,
that doesn't mean it's going to

00:33:37.880 --> 00:33:39.360
get loaded in all environments.

00:33:39.370 --> 00:33:43.530
Because in WebKit, for example,
we have to have restrictions

00:33:43.600 --> 00:33:46.410
for security reasons as well,
and we're not allowed to load any

00:33:46.460 --> 00:33:48.240
kind of patch in a web environment.

00:33:48.360 --> 00:33:50.660
So your custom plugins won't get loaded.

00:33:50.920 --> 00:33:54.740
But for regular clients,
from the editor to applications

00:33:54.740 --> 00:33:57.770
you write or anything else,
they will get loaded.

00:33:59.200 --> 00:34:02.020
So in a theory for now,
it's time to build our first patch.

00:34:02.020 --> 00:34:05.350
And what I'm going to build
here is a very simple patch to

00:34:05.350 --> 00:34:11.780
demonstrate all the best principles,
something that I call the "iPatch,"

00:34:11.780 --> 00:34:17.400
which is kind of a marketing tool
where you start with a regular name

00:34:17.400 --> 00:34:20.100
and you end up with an "i" name.

00:34:20.100 --> 00:34:21.920
So it's very simple.

00:34:21.920 --> 00:34:22.900
Input string, output string,
pure string manipulation.

00:34:22.900 --> 00:34:22.900
OK, thank you.

00:34:27.230 --> 00:34:31.850
So we start in Xcode and
we create a new project.

00:34:32.020 --> 00:34:34.590
There are two templates for
Quartz Composer plugins.

00:34:34.710 --> 00:34:37.380
The one we're going to use,
the simplest one, Quartz Composer Plugin,

00:34:37.380 --> 00:34:38.380
that's the name.

00:34:38.410 --> 00:34:42.680
Those templates are not in the
Leopard seed that you currently have.

00:34:42.680 --> 00:34:48.610
We'll upload them on the ADC website or
the WWDC website as soon as possible,

00:34:48.610 --> 00:34:50.840
so likely later this
week or the week after,

00:34:50.870 --> 00:34:53.390
so that you can download them
and put them at the proper

00:34:53.390 --> 00:34:55.290
location so they appear in Xcode.

00:34:55.360 --> 00:35:01.050
So let's go ahead and create what
we call the eyepatch project.

00:35:03.740 --> 00:35:05.990
And let's start by looking at
the structure of the template.

00:35:06.080 --> 00:35:13.290
So we have on the left side the series
of files that are used by default.

00:35:13.620 --> 00:35:18.860
Here are your two files that
define the subclass of QC plug-in.

00:35:18.860 --> 00:35:23.300
Then you have your usual prefix
file so that it compiles faster,

00:35:23.300 --> 00:35:25.810
which includes by default
here the Quartz framework,

00:35:25.810 --> 00:35:29.500
which in turn includes all
the Quartz Composer APIs.

00:35:29.510 --> 00:35:33.350
Then we only need two frameworks,
the Quartz framework, Abusely,

00:35:33.360 --> 00:35:35.280
and then the Cocoa framework.

00:35:35.290 --> 00:35:40.840
Now if we look more precisely
at the ipatchplugin.h file,

00:35:40.840 --> 00:35:44.590
so pretty straightforward, remember,
subclass of QC plug-in

00:35:44.590 --> 00:35:47.480
and called ipatchplugin.

00:35:47.540 --> 00:35:52.380
First thing I'm going to do is add those
input properties we talked about so much.

00:35:52.410 --> 00:35:57.540
So we need two properties to define
the input string and the output string.

00:35:57.620 --> 00:35:59.150
So the type would be NSString.

00:35:59.450 --> 00:36:01.480
First name would be input string.

00:36:01.480 --> 00:36:06.150
And then let me create another one
that's of type NSString as well,

00:36:06.150 --> 00:36:08.480
except it's called output string.

00:36:08.480 --> 00:36:10.200
That's all we need to do so far.

00:36:10.210 --> 00:36:13.790
Then we can look at the
.m implementation file.

00:36:14.040 --> 00:36:16.320
So by default,
it's pretty much a placeholder.

00:36:16.320 --> 00:36:19.900
And you just have to fill your code
at the proper places if you want to.

00:36:19.900 --> 00:36:21.220
You can see the structure here.

00:36:21.220 --> 00:36:23.980
Every method is implemented,
except it does nothing or

00:36:23.980 --> 00:36:25.450
returns the default value.

00:36:25.580 --> 00:36:27.400
So you can either delete
the one you don't need,

00:36:27.400 --> 00:36:28.620
or you can leave them as is.

00:36:28.620 --> 00:36:30.400
It won't make a difference.

00:36:30.410 --> 00:36:31.000
So let's start at the top of the file.

00:36:31.000 --> 00:36:35.800
First thing I'm going to do is
change the description of the patch,

00:36:35.800 --> 00:36:39.270
which is conveniently defined
as a preprocessor constant.

00:36:39.350 --> 00:36:46.800
So let's say a patch that
converts any name to an iname.

00:36:47.020 --> 00:36:48.700
OK.

00:36:48.700 --> 00:36:51.850
The attributes here are defined
directly through the preprocessor

00:36:51.850 --> 00:36:55.320
constants we have there,
so we don't need to touch that method.

00:36:55.340 --> 00:36:59.210
Then remember, it would be nice to define
for the UI attributes for

00:36:59.210 --> 00:37:01.270
the inputs and output ports.

00:37:01.600 --> 00:37:07.870
So let's look for the key output string.

00:37:10.540 --> 00:37:13.030
And if we have a match,
then let's return a

00:37:13.030 --> 00:37:18.170
dictionary that contains

00:37:19.080 --> 00:37:21.330
A UI name for that input part.

00:37:21.330 --> 00:37:24.350
So the key would be
"nameKey" and the name,

00:37:24.350 --> 00:37:27.310
let's say, "name".

00:37:27.530 --> 00:37:32.270
Now if the key is input string,
we're going to do a little more than

00:37:32.270 --> 00:37:35.900
return an ""m". We're also going to
define the default value to have on that

00:37:35.900 --> 00:37:38.180
part when your patch instance is created.

00:37:43.500 --> 00:37:46.980
So let's see,
dictionary with object and keys.

00:37:46.980 --> 00:37:50.790
And my first object is
going to be "iName".

00:37:51.000 --> 00:37:54.230
"It's going to be the official
name of our port in the UI.

00:37:54.270 --> 00:37:57.200
Then we're going to
have some default value.

00:37:58.290 --> 00:38:00.560
And that's pretty much it.

00:38:00.610 --> 00:38:02.410
And default value,
I'm going to define that

00:38:02.440 --> 00:38:05.750
to a conveniently pod.

00:38:06.390 --> 00:38:08.750
Execution mode,
that patch is a processor,

00:38:08.760 --> 00:38:10.810
just like data in, data out,
nothing to change.

00:38:10.830 --> 00:38:13.520
This is what we have by default,
processor.

00:38:13.540 --> 00:38:15.410
Time mode, nothing to change at all.

00:38:15.420 --> 00:38:17.800
That our patch doesn't
depend on the time.

00:38:17.940 --> 00:38:19.620
We don't have anything
to do in inter-dialog.

00:38:19.720 --> 00:38:22.040
We don't need global resources
or anything like that.

00:38:22.040 --> 00:38:22.970
We can skip it.

00:38:23.250 --> 00:38:25.610
We don't care to know when
the engine is starting,

00:38:25.610 --> 00:38:29.260
stopping, or enable execution,
so we don't touch any of those methods,

00:38:29.260 --> 00:38:31.210
we leave them as is, doing nothing.

00:38:31.370 --> 00:38:34.580
And the only one where we need to do
something is in the execute method.

00:38:34.660 --> 00:38:38.090
So remember, in execute,
you take your inputs, process them,

00:38:38.190 --> 00:38:40.630
produce some result on the outputs.

00:38:40.740 --> 00:38:45.360
So our output is output string,
so you can just write to it,

00:38:45.360 --> 00:38:50.420
and we're going to
have that ising happen,

00:38:50.420 --> 00:38:50.770
so

00:38:54.100 --> 00:38:57.890
"String by Append in
String" input string.

00:38:57.930 --> 00:39:02.000
And to make it even better,
we're going to capitalize

00:39:02.000 --> 00:39:04.400
the input string.

00:39:05.750 --> 00:39:06.860
OK.

00:39:07.160 --> 00:39:10.940
Now, we are almost ready to build.

00:39:10.940 --> 00:39:15.830
Let me tell you first that by default,
the Active executable is the course

00:39:15.830 --> 00:39:18.120
composer editing environment,
so that's pretty nice,

00:39:18.120 --> 00:39:19.720
you don't even need to add it.

00:39:19.770 --> 00:39:22.420
You can build a debug and release,
that's configured.

00:39:22.610 --> 00:39:27.070
We also provide, as a convenience,
a secondary target,

00:39:27.080 --> 00:39:28.790
that's called build and copy.

00:39:28.860 --> 00:39:30.970
So typically,
if you don't use that target,

00:39:30.970 --> 00:39:34.360
you build your patch,
and then it's in the build directory,

00:39:34.370 --> 00:39:36.940
but it's not going to get loaded
by course composer because it's

00:39:36.940 --> 00:39:39.540
not located in the appropriate
course composer plug-ins.

00:39:39.640 --> 00:39:41.920
So at that point,
you would either manually copy it there,

00:39:41.920 --> 00:39:44.430
or you would put a symlink,
something like that.

00:39:44.450 --> 00:39:49.320
To avoid that annoying operation,
that target is simply

00:39:49.700 --> 00:39:54.160
calling the normal target,
and after, run a script phase that copies

00:39:54.380 --> 00:39:58.020
the built result directly into the
course composer plug-ins folder.

00:39:58.170 --> 00:39:59.900
So let's build.

00:40:03.500 --> 00:40:21.410
Pierre-Olivié Latour: OK.

00:40:21.410 --> 00:40:21.410
Now I can look into the Quartz
Composer plugins folder,

00:40:21.410 --> 00:40:21.410
which is located into library graphics,
and my """patch"" is there.

00:40:21.410 --> 00:40:21.410
So let's launch -- well,
actually I need to quit it and relaunch.

00:40:21.410 --> 00:40:21.410
There we go.

00:40:21.410 --> 00:40:21.410
And I already have -- let's see,
a composition to host.

00:40:21.680 --> 00:40:24.160
Here we go, my new patch.

00:40:24.160 --> 00:40:25.200
Just zoom on that.

00:40:25.210 --> 00:40:28.520
What this composition does is it
has simply an image with string to

00:40:28.520 --> 00:40:31.510
generate the image with some string
on it and display it on a billboard.

00:40:31.620 --> 00:40:33.060
Very straightforward.

00:40:33.070 --> 00:40:35.080
And now I can look for my eye patch.

00:40:35.080 --> 00:40:37.120
Whoops, not too fast.

00:40:37.140 --> 00:40:39.530
Create an instance of it connected there.

00:40:39.700 --> 00:40:42.980
You can see the name is proper, iname,
name.

00:40:42.980 --> 00:40:47.860
The default value is-- let's
wait for the tool tip-- is pod.

00:40:47.860 --> 00:40:50.660
And so the result is iPod,
but it definitely works.

00:40:50.680 --> 00:40:53.790
So I can type book, and you get iBook,
and you can even invent

00:40:53.790 --> 00:40:56.990
completely new products like
chair or whatever and get iChair.

00:40:57.150 --> 00:41:00.900
So it's very simple to
implement that plugin.

00:41:00.900 --> 00:41:06.660
And we almost type no code,
thanks to Objective-C 2.0.

00:41:06.660 --> 00:41:08.760
Back to the slides, please.

00:41:18.060 --> 00:41:20.660
So that was a very basic
demo just to make sure you

00:41:20.660 --> 00:41:22.120
understand the principles there.

00:41:22.280 --> 00:41:26.060
Now we're going to go a bit further and
do some interesting OpenGL rendering.

00:41:26.170 --> 00:41:27.680
So what are the conditions here?

00:41:27.800 --> 00:41:30.290
Well, first of all,
your QCplugin subclass is going

00:41:30.290 --> 00:41:34.210
to have to be of type consumer,
because they're the only ones which

00:41:34.220 --> 00:41:35.970
can render to the destination.

00:41:36.130 --> 00:41:39.510
If you have a processor or provider,
that won't work.

00:41:39.650 --> 00:41:45.700
Now, the same way we have those OpenGL,
let's say, good citizenship rules,

00:41:45.790 --> 00:41:48.600
they also apply when you
write custom batches,

00:41:48.600 --> 00:41:53.080
which means use cgl macros instead of
touching the current OpenGL context,

00:41:53.080 --> 00:41:55.890
and make sure you save
restore all your OpenGL steps,

00:41:56.040 --> 00:41:59.200
except the one that are part
of the GL current bit state.

00:41:59.230 --> 00:42:01.420
So that basically means the
current vertex position,

00:42:01.520 --> 00:42:04.100
current vertex color,
current vertex texture coordinates,

00:42:04.160 --> 00:42:06.660
because everyone is changing them anyway,
so there is no point in

00:42:06.660 --> 00:42:08.430
saving or restoring them.

00:42:09.180 --> 00:42:13.360
So here's what the execute
method of your patch that does

00:42:13.360 --> 00:42:15.210
OpenGL rendering would look like.

00:42:15.250 --> 00:42:19.410
Remember,
you included the top OpenGL cglmacros.h

00:42:19.510 --> 00:42:21.190
to get the cglmacros.

00:42:21.490 --> 00:42:25.590
And then the first thing we would do in
execute is retrieve the OpenGL context

00:42:25.590 --> 00:42:30.190
to render with and assign it to
a variable with the name cgl_ctx.

00:42:30.460 --> 00:42:33.640
So we simply do that by calling
the cglcontext object method

00:42:33.990 --> 00:42:36.800
on the context parameter.

00:42:36.800 --> 00:42:39.670
For extra safety here,
you can always check--

00:42:39.670 --> 00:42:43.220
that should never be null,
but you can always do if it's null,

00:42:43.220 --> 00:42:44.870
return null, fail execution.

00:42:45.200 --> 00:42:47.490
Then you insert your gl code.

00:42:47.980 --> 00:42:52.430
Exact same thing as the example for
the QC renderer and the QC view.

00:42:52.490 --> 00:42:55.070
Save the current state,
change the one you want to the

00:42:55.070 --> 00:42:58.920
values you're interested in,
then perform your OpenGL rendering,

00:42:59.030 --> 00:43:01.840
restore the states,
check and handle errors.

00:43:01.890 --> 00:43:03.770
Really straightforward.

00:43:05.090 --> 00:43:08.000
Well, the next question becomes, "Okay,
I can do OpenGL rendering,

00:43:08.000 --> 00:43:09.200
but what about images?

00:43:09.240 --> 00:43:13.570
I would like to draw images, obviously,
or get images from the system." So the

00:43:13.570 --> 00:43:17.500
way you use images within QC Plugin
is by dealing with OPEC objects.

00:43:17.630 --> 00:43:19.000
There are two OPEC objects.

00:43:19.000 --> 00:43:21.950
The first one is called--
I use a protocol that is

00:43:21.950 --> 00:43:25.430
QC Plugin Input Image Source,
and the second one is QC Plugin

00:43:25.430 --> 00:43:27.100
Output Image Provider.

00:43:27.240 --> 00:43:29.960
The reasons we use protocols
there is because we have

00:43:29.960 --> 00:43:33.400
numerous image types in the OS,
you know, NSEmage, NSEbitmapRef,

00:43:33.400 --> 00:43:36.120
CGImageRef, and so on,
and each of them is really

00:43:36.170 --> 00:43:38.730
suited to a given usage,
and Quartz Composer is

00:43:38.730 --> 00:43:41.760
a really generic system,
so none of those was really fitting,

00:43:41.760 --> 00:43:45.080
and so by picking one of them,
it would have a number of

00:43:45.080 --> 00:43:47.860
restrictions to deal with,
or by, on the contrary,

00:43:47.860 --> 00:43:50.600
allowing any of them,
then we would have to deal with, again,

00:43:50.800 --> 00:43:53.500
impedance mismatch,
which can be really expensive.

00:43:53.600 --> 00:43:56.420
So we solved that problem,
and the nice thing we get as a

00:43:56.420 --> 00:43:59.360
side effect is that we can defer,
through those protocols,

00:43:59.360 --> 00:44:04.160
as you're gonna see in a minute,
all computation until it's really needed.

00:44:04.160 --> 00:44:07.460
So that improves-- improves performance.

00:44:07.590 --> 00:44:10.080
First thing, input images.

00:44:13.180 --> 00:44:16.340
Like I said earlier,
those are OPEC objects that simply comply

00:44:16.340 --> 00:44:19.320
to the QC plugin input image source.

00:44:19.420 --> 00:44:23.190
The way you would create input
image ports is either through

00:44:23.200 --> 00:44:26.630
Objective-C 2.0 properties,
where the type would be ID because it's

00:44:26.640 --> 00:44:30.400
a generic object and then a protocol,
or it would be dynamic ports

00:44:30.540 --> 00:44:34.130
where you can just create them
calling self-add-input-port,

00:44:34.130 --> 00:44:37.800
where the type would
be QC port type image.

00:44:38.080 --> 00:44:40.150
Now you have those images,
you have those ports,

00:44:40.150 --> 00:44:41.160
you get images through them.

00:44:41.180 --> 00:44:43.400
How do you access the pixels
to do something with them?

00:44:43.610 --> 00:44:46.220
Well,
we use what we call representations.

00:44:46.320 --> 00:44:47.760
There are two types of representation.

00:44:47.760 --> 00:44:49.460
The first one is on the CPU.

00:44:49.530 --> 00:44:52.960
So the idea here is that when you want
to access the contents of the image,

00:44:52.960 --> 00:44:56.500
the actual pixels,
on the CPU you call log buffer

00:44:56.710 --> 00:45:01.240
representation with pixel format
on the OPEC object and you specify

00:45:01.240 --> 00:45:04.140
one of the supported formats
right now that can be RGB8,

00:45:04.370 --> 00:45:10.170
RGBF for 32 bits float,
or intensity 8 or intensity float.

00:45:10.270 --> 00:45:12.420
And in case of success
it will return yes,

00:45:12.570 --> 00:45:15.620
which theoretically should
always be successful,

00:45:15.620 --> 00:45:18.500
unless you already logged the image
in a different format obviously.

00:45:18.660 --> 00:45:23.630
But at that point on, you have the image,
the pixels of the image accessible

00:45:23.630 --> 00:45:25.500
in the buffer on the CPU.

00:45:25.500 --> 00:45:29.040
So you can call regular methods like,
you know, buffer pixel wide,

00:45:29.080 --> 00:45:31.660
buffer pixel high,
and the usual base address and byte

00:45:31.660 --> 00:45:33.360
sparrows to read from the pixels.

00:45:33.360 --> 00:45:36.200
Finally, when you're done,
you simply have to call unlock

00:45:36.200 --> 00:45:38.080
pixel buffer represent unlock
buffer representation to

00:45:38.080 --> 00:45:40.000
release that representation.

00:45:40.000 --> 00:45:42.690
You cannot have multiple
representation at a time.

00:45:42.820 --> 00:45:46.000
You need to unlock the current
one and relock a new one.

00:45:46.000 --> 00:45:49.600
The pixel buffer is read only,
so it's very important you

00:45:49.600 --> 00:45:51.310
don't touch that memory.

00:45:51.310 --> 00:45:52.680
Only for reading.

00:45:52.810 --> 00:45:56.480
The second case is accessing
the input images on a GPU.

00:45:56.480 --> 00:45:59.900
It's pretty much a similar mechanism,
except instead of locking a

00:45:59.900 --> 00:46:03.040
pixel buffer in CPU memory,
you're going to lock a texture.

00:46:03.040 --> 00:46:06.120
And you can specify the target,
which can be 2D or rectangle.

00:46:06.120 --> 00:46:11.990
If you specify 2D and the actual image
does not have power of two dimensions,

00:46:11.990 --> 00:46:13.820
it will be automatically resized to fit.

00:46:13.820 --> 00:46:17.280
So you will get your 2D texture,
which will allow you to do repeat and

00:46:17.280 --> 00:46:21.560
various operations that can only be
done on 2D textures at the expense

00:46:21.560 --> 00:46:25.340
of a potential quality loss because
of the rescaling that had happened to

00:46:25.340 --> 00:46:29.950
get a 2D texture out of a non-power
of two-texture original image.

00:46:29.990 --> 00:46:32.820
Once it is locked as a texture,
it's the usual stuff.

00:46:32.820 --> 00:46:37.330
You can get the width, the height,
the target again, as well as the name,

00:46:37.330 --> 00:46:38.100
obviously.

00:46:38.100 --> 00:46:41.110
As a conveniency,
and also the fact if the contents

00:46:41.110 --> 00:46:44.760
inside a texture is flipped or not,
vertically flipped.

00:46:44.840 --> 00:46:48.060
As a conveniency,
we provide a texture matrix.

00:46:48.060 --> 00:46:51.870
The idea here is that if
you get a rectangle texture,

00:46:51.870 --> 00:46:55.840
you have to express the texture
coordinates in pixels versus the regular,

00:46:55.980 --> 00:46:59.350
let's say,
normalized units that you use for 1D, 2D,

00:46:59.360 --> 00:47:00.860
and 3D textures.

00:47:00.860 --> 00:47:05.410
Also, if the texture content is flipped,
you would need to flip your texture

00:47:05.410 --> 00:47:07.270
coordinates to take that into account.

00:47:07.390 --> 00:47:09.170
Well,
you can do all that transparently and

00:47:09.170 --> 00:47:12.920
always have to deal with unflipped,
normalized texture coordinates

00:47:12.920 --> 00:47:16.440
just by loading a texture matrix
on the OpenGL texture matrix stack.

00:47:16.710 --> 00:47:20.140
And then your coordinates
are sent through that matrix,

00:47:20.140 --> 00:47:22.340
which will do the proper transform
before producing the texture coordinates,

00:47:22.340 --> 00:47:25.100
producing the real coordinates
to use for the texture.

00:47:25.110 --> 00:47:28.780
You don't have to use that mechanism,
but it simplifies your life if you do.

00:47:28.780 --> 00:47:31.350
So we provide a code that will
return a texture matrix that

00:47:31.360 --> 00:47:34.120
you can directly load on OpenGL.

00:47:34.120 --> 00:47:38.040
If there is no need for a texture matrix,
this will return null.

00:47:38.720 --> 00:47:43.030
The same way you cannot modify the
contents of the pixel buffer on a CPU,

00:47:43.060 --> 00:47:46.020
you cannot modify the
content of the texture.

00:47:47.650 --> 00:47:52.630
Then the third case to look at is
producing images out of the plugin.

00:47:52.690 --> 00:47:57.590
So once again, we have an OPEC object,
which is going to have to comply to

00:47:57.650 --> 00:47:59.590
the QC plugin output image provider.

00:47:59.790 --> 00:48:02.860
But you're the one creating that object,
so you can return any object as long

00:48:02.860 --> 00:48:04.820
as it conforms to that protocol.

00:48:04.840 --> 00:48:09.380
The way you would create
output ports for output images,

00:48:09.400 --> 00:48:13.560
exact same thing as for input images,
Objective-C 2.0 properties,

00:48:13.560 --> 00:48:15.180
or dynamic ports.

00:48:16.130 --> 00:48:21.000
So let's look a bit closer at that
protocol output image provider.

00:48:21.000 --> 00:48:23.830
So it's going to--your
OPEC object that you return,

00:48:23.830 --> 00:48:27.190
that you built and return,
which complies to that protocol,

00:48:27.190 --> 00:48:30.350
is going to be curated by the
engine whenever necessary.

00:48:30.350 --> 00:48:33.440
And it's going to be responsible
for providing pixels for

00:48:33.440 --> 00:48:35.280
the image on the CPU,
on the GPU.

00:48:35.360 --> 00:48:38.960
So it's the inverse mechanism that
getting image in your plug-in.

00:48:39.280 --> 00:48:42.040
There are two methods that
are generic on that protocol,

00:48:42.050 --> 00:48:45.780
just the dimensions of your image,
pixel wide and pixels high.

00:48:47.190 --> 00:48:49.970
Then, once again, two cases, CPU and GPU.

00:48:50.100 --> 00:48:54.160
In case of CPU,
your provider object is called,

00:48:54.160 --> 00:48:58.640
and the engine is going to ask what are
your supported buffer pixel formats?

00:48:58.640 --> 00:49:01.100
So if you're able to
draw your image into,

00:49:01.100 --> 00:49:05.540
let's say, an RGB8 format,
you will return RGB8.

00:49:05.700 --> 00:49:10.280
If you can support more than one format,
you return more than one in SNES array,

00:49:10.280 --> 00:49:12.670
and you can order them
by order of preferences.

00:49:12.810 --> 00:49:18.200
If you don't support rendering in CPU,
then just return an MTRR or NIL.

00:49:18.370 --> 00:49:21.990
If that condition passes,
then the engine is going to call when

00:49:21.990 --> 00:49:25.000
it actually needs the actual pixels,
render to buffer,

00:49:25.000 --> 00:49:27.830
giving you a base address and
a row bytes and the actual

00:49:27.830 --> 00:49:29.600
pixel format of that buffer.

00:49:29.680 --> 00:49:35.510
And at that point,
you just access the buffer and write

00:49:35.510 --> 00:49:35.510
to it and put your pixels in there.

00:49:40.320 --> 00:49:44.540
In the case of producing
pixels for the image on a GPU,

00:49:44.630 --> 00:49:46.370
it's pretty similar.

00:49:46.690 --> 00:50:19.080
Pierre-Olivié Latour as well say,
I'd like to render into a

00:50:19.080 --> 00:50:22.760
floating point buffer on the GPU,
if that's possible.

00:50:22.930 --> 00:50:27.080
So that's the point of that method,
support a drawable pixel format.

00:50:27.080 --> 00:50:29.910
Because we're in the OpenGL world,
to be able to render,

00:50:29.920 --> 00:50:33.280
you might also require from
the OpenGL context a number

00:50:33.280 --> 00:50:34.490
of extensions to be supported.

00:50:34.600 --> 00:50:36.330
So you can check for those,
and return yes,

00:50:36.330 --> 00:50:38.220
if you can work with that context.

00:50:38.230 --> 00:50:40.320
And finally,
if the above conditions are met,

00:50:40.370 --> 00:50:42.170
render with CGL context is called.

00:50:42.290 --> 00:50:44.880
The context is ready to
be used with CGL macros,

00:50:44.950 --> 00:50:48.810
as you can see, and you just draw,
and the viewport is already set,

00:50:48.830 --> 00:50:49.570
and so on.

00:50:49.640 --> 00:50:52.820
The projection and model view
matrices are set to identity.

00:50:52.870 --> 00:50:54.070
You just render.

00:50:54.090 --> 00:50:57.860
Remember, very important,
preserve the stats you change, always.

00:50:57.860 --> 00:51:00.760
And at that point, you're done.

00:51:00.760 --> 00:51:03.830
So you don't have to implement
both CPU and GPU method,

00:51:03.960 --> 00:51:08.560
but obviously,
you need to implement one of them.

00:51:08.570 --> 00:51:11.520
So let's do a demo of OpenGL rendering.

00:51:14.500 --> 00:51:17.790
In that case I'm not going to build a
patch because there is a bit more code,

00:51:17.790 --> 00:51:20.910
especially GL code,
so I'm going to show you a

00:51:20.910 --> 00:51:23.480
project that's already written.

00:51:25.230 --> 00:51:28.970
OK, so this is our usual plug-in project.

00:51:29.000 --> 00:51:32.610
The difference here is the inputs
and outputs and the execution method

00:51:32.610 --> 00:51:34.700
compared to the previous one we wrote.

00:51:34.730 --> 00:51:38.890
So you can see here dynamic properties
that define the inputs of our plug-in.

00:51:39.120 --> 00:51:42.940
I should mention first that our plug-in
is just drawing a square with an

00:51:42.940 --> 00:51:47.230
image in it and colorizing the image.

00:51:47.330 --> 00:51:51.800
So the inputs we need are x and y for
the position of that square on screen,

00:51:51.830 --> 00:51:54.410
as well as the color to
modulate the image with.

00:51:54.590 --> 00:51:57.640
And finally, we need an image.

00:51:57.660 --> 00:52:00.500
Now let's look at the actual
implementation of that file.

00:52:00.530 --> 00:52:04.640
By default, Quartz Composer,
the project template in

00:52:04.640 --> 00:52:07.620
Xcode already has OpenGL,
CGL macros at the top.

00:52:07.620 --> 00:52:11.330
So you don't need to bother with
that if you have actually forgotten.

00:52:11.340 --> 00:52:12.390
So same thing here.

00:52:12.400 --> 00:52:15.100
We define a nice name and a
description that's going to

00:52:15.100 --> 00:52:17.200
go in there in the attributes.

00:52:17.210 --> 00:52:21.630
Attributes for property port with key,
exact same thing like we saw before.

00:52:21.690 --> 00:52:25.420
Check for each of those keys and return
an appropriate set of attributes.

00:52:25.430 --> 00:52:27.190
Execution mode, that's the difference.

00:52:27.390 --> 00:52:30.190
Remember, we have to be a consumer
to be able to render.

00:52:30.400 --> 00:52:32.950
We don't depend on time,
so it's still known.

00:52:33.190 --> 00:52:36.600
Then to make the code clear,
I deleted all the methods that

00:52:36.940 --> 00:52:38.220
were actually not implemented.

00:52:38.220 --> 00:52:41.180
So we're only left with one,
which is the execute method.

00:52:41.280 --> 00:52:44.190
So let's rapidly look at it.

00:52:44.490 --> 00:52:48.190
The first thing we do is we retrieve
the OpenGL context to draw with.

00:52:48.240 --> 00:52:50.760
And for extra safety,
we check to make sure it's not null,

00:52:50.760 --> 00:52:53.590
because I should have mentioned
before that when you actually use

00:52:53.590 --> 00:52:58.260
CGL macros and CGL context is null,
you will crash.

00:52:58.290 --> 00:53:01.260
So you want to make sure it's not null.

00:53:01.660 --> 00:53:05.390
Here, for convenience,
remember it's-- when you

00:53:05.390 --> 00:53:08.120
access the image many,
many times, you might as well cache it in

00:53:08.120 --> 00:53:11.100
a local variable rather than
read from the input property.

00:53:11.100 --> 00:53:12.930
So that's what I'm doing here.

00:53:12.940 --> 00:53:18.660
I am copying the image on the
input into an image local variable.

00:53:18.660 --> 00:53:20.540
And now it's time to
get to the real thing.

00:53:20.540 --> 00:53:22.780
So what we want to do is we
have an image as an input.

00:53:22.780 --> 00:53:25.510
We want to get an
OpenGL texture out of it.

00:53:25.610 --> 00:53:28.980
If this image exists,
and if we can successfully get a texture

00:53:28.980 --> 00:53:32.830
representation of type rectangle here,
then let's just put the texture

00:53:32.830 --> 00:53:35.080
name inside another local variable.

00:53:35.090 --> 00:53:37.210
Otherwise, we put zero.

00:53:38.010 --> 00:53:41.700
Then we set up our model
view to do the translation.

00:53:41.700 --> 00:53:45.600
And remember, we have to save the
previous model view matrix.

00:53:45.650 --> 00:53:49.280
If a texture does exist,
if we do have a texture,

00:53:49.280 --> 00:53:55.000
then we configure the texture unit
in OpenGL to enable texturing,

00:53:55.000 --> 00:53:59.100
to use the texture corresponding
to the texture name.

00:53:59.220 --> 00:54:02.220
And if we need a texture matrix,
we just load it on the

00:54:02.220 --> 00:54:04.010
texture matrix stack.

00:54:04.610 --> 00:54:05.730
We're almost there.

00:54:05.750 --> 00:54:11.460
One more configuration we need
to do is set the current color,

00:54:11.470 --> 00:54:14.520
so we can get-- remember,
input color will contain

00:54:14.520 --> 00:54:16.840
a CG color ref object.

00:54:16.840 --> 00:54:19.760
So we can get the components out of it,
and it's guaranteed

00:54:19.860 --> 00:54:23.940
to be RGBA components.

00:54:23.940 --> 00:54:26.840
So we retrieve them, and we can directly
set the current color,

00:54:26.890 --> 00:54:30.080
which we don't need to save,
because it's one of the few stats

00:54:30.080 --> 00:54:33.640
that is part of the current stat bit.

00:54:33.640 --> 00:54:34.780
Everything is set up.

00:54:34.780 --> 00:54:36.080
At that point, we're ready to draw.

00:54:36.250 --> 00:54:39.740
So we draw a quad,
specifying the four vertices of the quad,

00:54:39.740 --> 00:54:42.260
as well as the texture
coordinates for each of those.

00:54:42.260 --> 00:54:45.360
Because we know the texture,
we actually load the texture

00:54:45.360 --> 00:54:47.420
matrix that is provided to us.

00:54:47.420 --> 00:54:50.670
We don't need to deal with rectangle
texture coordinates and specify the

00:54:50.670 --> 00:54:52.480
coordinates in pixels or anything.

00:54:52.610 --> 00:54:56.080
We just specify normalized
coordinates for the texture,

00:54:56.080 --> 00:54:58.560
like 0 and 1, and it just works.

00:54:58.560 --> 00:55:02.660
So if you were to change the
constant above here to be 2D

00:55:02.660 --> 00:55:05.300
instead of rectangle-- you
would just replace it there,

00:55:05.300 --> 00:55:06.980
and it would still work.

00:55:06.980 --> 00:55:09.140
You wouldn't have to
change that code here.

00:55:09.200 --> 00:55:11.760
Finally, our quad is drawn,
and we do the inverse operation,

00:55:11.760 --> 00:55:13.230
restoring the previous stats.

00:55:13.390 --> 00:55:16.520
So if there was a texture name,
we unload the texture matrix.

00:55:16.520 --> 00:55:21.620
We restore the original state of the
texture unit by disabling texturing.

00:55:21.620 --> 00:55:27.250
And we restore the model view matrix,
and finally check for OpenGL errors.

00:55:27.290 --> 00:55:31.410
And don't forget to unlock the
texture presentation at the end.

00:55:31.680 --> 00:55:33.520
So it might seem a bit complex.

00:55:33.640 --> 00:55:35.580
But all of that is OpenGL code.

00:55:35.580 --> 00:55:39.400
The real QC code is very simple.

00:55:39.400 --> 00:55:41.490
Let's build a project.

00:55:45.040 --> 00:55:49.200
Okay, let's run.

00:55:49.210 --> 00:55:50.520
Yeah, should be installed.

00:55:50.660 --> 00:55:51.380
Just double check.

00:55:51.420 --> 00:55:53.190
Yes, it is.

00:55:55.570 --> 00:55:56.940
Create a new document.

00:55:57.090 --> 00:56:00.100
Look for our brand new Square patch.

00:56:00.160 --> 00:56:02.200
Create an instance of it.

00:56:02.210 --> 00:56:05.040
As you can see, X,
Y color and image inputs.

00:56:05.070 --> 00:56:07.210
So let's take an image.

00:56:08.210 --> 00:56:16.390
Okay, and I can obviously change the
color and the position as well.

00:56:20.760 --> 00:56:25.740
So that was a simple demo of how you
would implement OpenGL rendering.

00:56:25.840 --> 00:56:28.130
Well,
obviously you would start from that and

00:56:28.310 --> 00:56:31.600
then replace with your own OpenGL code,
however complex it is.

00:56:31.600 --> 00:56:34.600
Let's go to the -- oh,
before we go back to the slides,

00:56:34.600 --> 00:56:38.600
I wanted to show you a more complex
plugin that I wrote the other day.

00:56:38.600 --> 00:56:42.600
So it's a hide-fill plugin that does
a lot more complex GL operations.

00:56:42.600 --> 00:56:47.600
But the QC side of things
is still very simple.

00:56:47.600 --> 00:56:50.740
Let me open that composition here.

00:56:51.900 --> 00:56:57.950
So what I have in that plugin is,
we start-- well,

00:56:57.950 --> 00:56:59.780
let's look at the composition,
and then I'll explain

00:56:59.780 --> 00:57:01.080
what the plugin does.

00:57:01.190 --> 00:57:03.160
So we start with the video input.

00:57:03.260 --> 00:57:04.720
We get the image out of that.

00:57:04.880 --> 00:57:07.880
Then there is a custom
Core Image Kernel that extracts,

00:57:07.910 --> 00:57:09.750
computes the luminosity
out of that image.

00:57:09.830 --> 00:57:13.190
So you get basically a grayscale
image representing the luminosity.

00:57:13.270 --> 00:57:19.180
Then we have another image kernel that
is going to take the luminosity and build

00:57:19.180 --> 00:57:23.330
a new image where the RGBA components,
instead of representing colors,

00:57:23.430 --> 00:57:25.240
are representing vertices.

00:57:25.280 --> 00:57:29.030
So R maps to X, G maps to Y, and so on.

00:57:29.040 --> 00:57:32.300
So you get an image where the
color components are actually XYZW,

00:57:32.300 --> 00:57:34.980
coordinates of vertices.

00:57:35.050 --> 00:57:39.100
So we're building just a mesh
of vertices stored in an image,

00:57:39.180 --> 00:57:40.520
in a way.

00:57:40.610 --> 00:57:44.320
And what happened is,
we take that special type of image,

00:57:44.350 --> 00:57:46.580
and it goes inside-- well,
here I have a trackball so

00:57:46.580 --> 00:57:50.550
that I can rotate-- but inside,
it's basically passed to the

00:57:50.550 --> 00:57:53.220
custom patch I was talking about,
height field.

00:57:53.310 --> 00:57:55.330
And here inside,
you have some fairly complex

00:57:55.400 --> 00:58:00.740
GL code that is getting that image,
copying it into an FBO,

00:58:00.740 --> 00:58:04.440
then going from the FBO to a VBO,
and basically processing

00:58:04.440 --> 00:58:05.620
a mesh of vertices.

00:58:05.720 --> 00:58:10.180
So the whole operation from
processing the video captured

00:58:10.220 --> 00:58:15.040
frames to building the vertices in
real time to generating the mesh,

00:58:15.120 --> 00:58:16.340
it's completely done on a GPU.

00:58:16.340 --> 00:58:16.840
It doesn't leave the mesh.

00:58:16.840 --> 00:58:17.420
It leaves the GPU.

00:58:17.420 --> 00:58:19.440
So that's fairly advanced OpenGL.

00:58:19.440 --> 00:58:24.800
And that is to show you here that you
can really leverage the Quartz Composer

00:58:24.800 --> 00:58:27.860
environment to do complex GL code,
where you don't have to

00:58:27.860 --> 00:58:28.960
deal with all your stuff.

00:58:28.960 --> 00:58:31.730
Like, now I need to write some code
to capture the video input,

00:58:31.730 --> 00:58:34.460
I need to write some code to
import images and create textures.

00:58:34.610 --> 00:58:37.520
You can leverage all those
facilities provided by Quartz

00:58:37.520 --> 00:58:39.800
Composer to do fairly advanced GL.

00:58:39.930 --> 00:58:43.160
So you can kind of see it here
that it's basically-- well,

00:58:43.160 --> 00:58:45.620
I need to rotate it,
but you might see my face in the mesh.

00:58:45.620 --> 00:58:46.740
There we go.

00:58:47.530 --> 00:58:52.860
So it's a mesh of about 16,000 vertices
and a bunch of triangles as well.

00:58:52.970 --> 00:58:56.630
Here you see on the bottom left the
result of the first Core Image Kernel

00:58:56.760 --> 00:59:00.990
that is computing that luminosity and
here you can see that special image

00:59:01.270 --> 00:59:11.200
where RGBA are actually vertex positions
in a kind of normalized in a 0 to 1,

00:59:11.200 --> 00:59:11.200
0 to 1 space in X, Y, and Z.

00:59:11.200 --> 00:59:11.200
All right.

00:59:17.740 --> 00:59:21.780
To learn about advanced
OpenGL techniques like this one,

00:59:21.800 --> 00:59:25.320
I would recommend you definitely
go tomorrow to the GLSL session.

00:59:27.960 --> 00:59:31.230
Now it's time to look at the final
part of writing custom plug-ins,

00:59:31.230 --> 00:59:34.500
which is using internal settings.

00:59:34.630 --> 00:59:39.520
The idea behind that is you cannot have
a plug-in where necessarily all the

00:59:39.580 --> 00:59:44.230
inputs and parameters needed by that
plug-in are defined through input ports.

00:59:44.330 --> 00:59:46.060
For instance,
you write a custom plug-in that is

00:59:46.060 --> 00:59:49.430
going to access some hardware device,
and you might have a number of

00:59:49.430 --> 00:59:52.290
parameters for the configuration
of that hardware device or the

00:59:52.290 --> 00:59:55.350
way you communicate with it,
and you simply don't want to have those

00:59:55.350 --> 00:59:58.700
settings available on the inputs because
you don't want them to be animatable or

00:59:58.700 --> 01:00:00.950
it might just not make any sense at all.

01:00:01.010 --> 01:00:03.080
In that case,
you have what we call internal

01:00:03.080 --> 01:00:05.140
settings for the plug-in.

01:00:05.170 --> 01:00:08.100
And the way people are going
to be editing those is by going

01:00:08.100 --> 01:00:10.900
through a custom interface,
which appears in the

01:00:10.900 --> 01:00:13.210
inspector of the editor.

01:00:13.310 --> 01:00:20.360
So in that schematic drawing here
you can see the RQC plugin which

01:00:20.360 --> 01:00:26.450
gets some values from input ports,
produce results,

01:00:26.450 --> 01:00:29.960
while the internal settings are set
from the inspector and the communication

01:00:29.960 --> 01:00:29.960
between the plugin and inspector
happens through key value coding.

01:00:31.060 --> 01:00:34.200
So how exactly do we
implement internal settings?

01:00:34.220 --> 01:00:37.040
Typically,
you would define IVARs in your class,

01:00:37.040 --> 01:00:40.170
or even better,
Objective-C 2.0 properties.

01:00:40.210 --> 01:00:43.830
Then you make sure those are accessible
through key value coding-- remember,

01:00:43.850 --> 01:00:46.040
value for key, set value for key.

01:00:46.050 --> 01:00:49.500
You also need to list the keys
corresponding to those internal settings

01:00:49.500 --> 01:00:52.630
by implementing the method PluginKeys,
which return an array

01:00:52.630 --> 01:00:54.040
containing those keys.

01:00:54.060 --> 01:00:56.340
We need that list of keys,
because then we can do a

01:00:56.340 --> 01:00:57.540
number of automatic things.

01:00:57.600 --> 01:00:59.900
Like for now,
we do automatic serialization of

01:00:59.900 --> 01:01:01.390
the values for those settings.

01:01:01.540 --> 01:01:04.610
But we can also do in the
future automatic undo,

01:01:04.610 --> 01:01:06.580
redo, those kind of things.

01:01:07.490 --> 01:01:08.930
Here's an example of internal settings.

01:01:09.010 --> 01:01:11.840
It's the same subclass that
I had earlier in my slide,

01:01:11.840 --> 01:01:16.500
except I added two Objective-C 2.0
properties that you can see at the

01:01:16.500 --> 01:01:19.130
bottom to store my internal settings.

01:01:19.240 --> 01:01:22.420
In that case, I have a system color.

01:01:22.690 --> 01:01:26.000
So just--it's completely arbitrary
for the sake of that example.

01:01:26.000 --> 01:01:29.480
So an NSColor, you know, kind of thing,
and another one that would be

01:01:29.480 --> 01:01:34.340
a completely opaque object,
and let's call that system configuration.

01:01:35.040 --> 01:01:38.820
We need to declare the
corresponding keys,

01:01:38.820 --> 01:01:41.020
system color, system configuration,
when implementing the

01:01:41.020 --> 01:01:41.910
Plug-in Keys method.

01:01:43.140 --> 01:01:45.120
Now how does serialization work?

01:01:45.180 --> 01:01:48.990
Well, remember, you have your plug-in,
you have your internal settings,

01:01:48.990 --> 01:01:52.190
and obviously when the user creates
an instance of your plug-in and

01:01:52.190 --> 01:01:54.480
then save the composition file,
you want those internal

01:01:54.480 --> 01:01:56.600
settings to be saved,
and you want them to be restored

01:01:56.600 --> 01:01:59.200
when the composition file is loaded.

01:01:59.210 --> 01:02:03.690
Well, we do that automatically for you as
long as the object you return for that

01:02:03.690 --> 01:02:06.760
internal setting complies to NSCoding.

01:02:06.760 --> 01:02:10.200
If it doesn't, you will have to override
SerializedValue for Key and set

01:02:10.200 --> 01:02:14.940
SerializedValue for Key methods,
which basically are used to convert

01:02:15.160 --> 01:02:19.850
an arbitrary object into a value we
can store in the composition file.

01:02:20.000 --> 01:02:22.740
And that has to be either
nil or it has to be a class,

01:02:22.740 --> 01:02:26.000
like NSString, NSNumber, and so on.

01:02:26.790 --> 01:02:32.380
Here's an example serialization still
leveraging our previous class interface.

01:02:32.380 --> 01:02:36.420
Remember, the first one we had as an
internal setting was system-color.

01:02:36.420 --> 01:02:40.930
Because it's an NSColor type of object
and it already conforms to NSCodding,

01:02:40.930 --> 01:02:42.180
there's nothing to do.

01:02:42.220 --> 01:02:45.020
However, for the second one,
that special configuration

01:02:45.020 --> 01:02:48.410
object completely opaque,
well, it doesn't conform to NSCodding,

01:02:48.430 --> 01:02:51.190
so we have to handle the
serialization ourselves.

01:02:51.200 --> 01:02:54.720
So we override serialize value for key,
check for the appropriate key,

01:02:54.880 --> 01:02:58.790
and for the sake of the example here,
I'm assuming that this object

01:02:58.790 --> 01:03:02.820
can return some kind of just
binary data of its representation.

01:03:02.830 --> 01:03:04.110
So we just return that.

01:03:04.120 --> 01:03:06.200
It's an NSData, so it's PLoS compliant.

01:03:06.200 --> 01:03:07.200
We're fine.

01:03:07.200 --> 01:03:11.060
Then on the other way,
when the composition file is loaded,

01:03:11.150 --> 01:03:14.910
setSerializeValueForKey is called,
and we need to override that,

01:03:15.070 --> 01:03:17.840
check for that custom key,
do the opposite operation.

01:03:17.840 --> 01:03:21.340
We got that kind of data object,
so we recreate a configuration

01:03:21.340 --> 01:03:23.780
object from it and set it.

01:03:25.180 --> 01:03:27.640
Now, the user interface,
how does that work?

01:03:27.730 --> 01:03:31.030
Well,
you are going to create an NSView with

01:03:31.030 --> 01:03:34.590
a number of controls inside to
edit those internal settings.

01:03:34.720 --> 01:03:37.420
And it's displayed in a
settings pane of the Inspector.

01:03:37.450 --> 01:03:39.770
This NSView is going to be
managed through a QCPlugin

01:03:39.780 --> 01:03:41.140
ViewController instance.

01:03:41.250 --> 01:03:44.320
So the controller,
it's your usual model view

01:03:44.320 --> 01:03:48.160
controller mechanism in Cocoa,
is going to act as an intermediary

01:03:48.160 --> 01:03:51.440
between the plugin instance,
which is the model, the view,

01:03:51.440 --> 01:03:55.070
which is your view full of controls,
and the controller in the middle,

01:03:55.070 --> 01:03:56.660
the QCPluginViewController.

01:03:56.690 --> 01:04:00.810
And it also handles all the loading of
the Nib file and those kind of things.

01:04:01.110 --> 01:04:04.490
The way you return the controller
is by implementing that method,

01:04:04.490 --> 01:04:07.140
which has to return a brand
new controller object for

01:04:07.200 --> 01:04:10.800
your plug-in instance,
and it's called createViewController.

01:04:11.040 --> 01:04:13.740
Typically, you would not subclass
QC view controller,

01:04:13.740 --> 01:04:17.130
you only need to do that if you want
to do some fairly advanced things.

01:04:17.140 --> 01:04:19.700
But for now,
I'm assuming simple case-- just return

01:04:19.700 --> 01:04:23.060
an instance initiated from self,
your own plug-in instance,

01:04:23.060 --> 01:04:27.300
and as well as providing the
name of the Nib file to use.

01:04:27.300 --> 01:04:29.510
Now the Nib file,
how is it going to work?

01:04:29.630 --> 01:04:32.100
Well, we use Cocoa Bindings
to simplify our life.

01:04:32.100 --> 01:04:34.950
So whenever possible,
your controls are simply going to be

01:04:35.050 --> 01:04:38.130
Cocoa bound to the plug-in settings.

01:04:38.210 --> 01:04:42.360
So using the plugin.xxx,
where xxx would be simply the key

01:04:42.360 --> 01:04:44.210
corresponding to the internal settings.

01:04:44.400 --> 01:04:47.540
If you want to use the more--
the kind of the former target

01:04:47.540 --> 01:04:50.170
action communication model,
it's completely doable.

01:04:50.240 --> 01:04:53.760
You would just have to subclass
QC plugin view controller.

01:04:53.850 --> 01:04:55.290
So practically, how does that work?

01:04:55.510 --> 01:04:58.020
We start with our QC plugin.

01:04:58.770 --> 01:05:01.270
It returns a QC plugin view
controller which is going to

01:05:01.320 --> 01:05:05.000
communicate through KVC to set
and read the internal settings.

01:05:05.060 --> 01:05:08.680
That plugin view controller is
loading a Nib file and it makes itself

01:05:08.680 --> 01:05:10.600
the file's owner of the Nib file.

01:05:10.670 --> 01:05:14.710
Then the plugin view controller as
the file owner has a view outlet which

01:05:14.710 --> 01:05:17.960
you need to connect to a view in your
Nib file that contains all the controls.

01:05:18.010 --> 01:05:21.120
And finally,
all those controls use Cocoa bindings

01:05:21.480 --> 01:05:23.880
bound to the QC plugin view controller.

01:05:23.880 --> 01:05:25.700
And that's pretty much it.

01:05:26.530 --> 01:05:29.860
So in that final demo,
I'm going to quickly build some kind

01:05:29.860 --> 01:05:34.980
of simple text thing where you have
the ability to enter a long text

01:05:35.000 --> 01:05:40.230
in the interface in the inspector
of Quartz Composer editor and then

01:05:40.450 --> 01:05:43.420
this is just produced as an output.

01:05:49.850 --> 01:05:52.120
Okay, new project.

01:05:52.240 --> 01:05:56.060
In this case I'm going to use another
template which is the one which already

01:05:56.060 --> 01:05:57.800
provides support for all the UI.

01:05:57.800 --> 01:06:01.800
We need files and everything
and let's call that simple text.

01:06:01.800 --> 01:06:04.130
Alright.

01:06:07.700 --> 01:06:14.000
[Transcript missing]

01:06:15.640 --> 01:06:18.340
Which will be the string that
we-- the text and the string

01:06:18.340 --> 01:06:21.580
that we actually produce,
so output string.

01:06:21.580 --> 01:06:25.000
And my internal setting is going to be--

01:06:25.400 --> 01:06:38.200
[Transcript missing]

01:06:39.340 --> 01:06:41.660
Now I can go to the implementation file.

01:06:41.700 --> 01:06:46.000
So, simple text,
I'm going to change here.

01:06:46.020 --> 01:06:51.070
Usual attributes, so let's do if key.

01:07:05.400 --> 01:07:09.640
Alright, default name,
and I'm just going to retrieve...

01:07:09.640 --> 01:07:11.730
I forgot to copy that...

01:07:12.600 --> 01:07:13.840
All right, name key.

01:07:13.840 --> 01:07:15.970
Execution mode, processor,
nothing to do here.

01:07:16.070 --> 01:07:18.080
Time mode, still not in it.

01:07:18.160 --> 01:07:19.880
So remember,
we have an internal variable,

01:07:19.880 --> 01:07:21.740
an internal setting that
is storing our text.

01:07:21.850 --> 01:07:24.180
So let's give it some default value.

01:07:28.640 --> 01:07:32.890
This internal setting is stored
using an Objective-C 2.0 property

01:07:33.210 --> 01:07:36.640
and when your class is dialogued,
your instance is dialogued,

01:07:36.710 --> 01:07:38.440
you need to set it to nil.

01:07:38.500 --> 01:07:42.600
If you don't do that,
then it will basically leak.

01:07:42.620 --> 01:07:45.200
And you cannot release the
text because it's a property,

01:07:45.200 --> 01:07:47.920
so you just set it to nil,
which will trigger, you know,

01:07:47.990 --> 01:07:50.940
replace the property by the nil
value and release the previous

01:07:50.940 --> 01:07:52.890
string that was stored in there.

01:07:52.960 --> 01:07:56.190
To plug in keys,
remember we have to list our keys here.

01:07:56.240 --> 01:08:02.190
We have only one, r with object, text.

01:08:02.550 --> 01:08:07.000
We don't need to change the serialization
because NSString conforms to NSCoding,

01:08:07.000 --> 01:08:08.740
so nothing to do here.

01:08:08.810 --> 01:08:11.890
CreateViewController is
already all implemented for us,

01:08:11.920 --> 01:08:13.160
nothing to do.

01:08:13.240 --> 01:08:16.730
And the only method we
actually care about is execute,

01:08:16.730 --> 01:08:18.840
where we do output string.

01:08:18.880 --> 01:08:21.650
So we do it very simply,
we take the text that we have internally

01:08:21.900 --> 01:08:24.740
and we copy it to the output string.

01:08:24.790 --> 01:08:25.860
We're almost done here.

01:08:25.970 --> 01:08:29.290
The last step we have
is edit the Nib file.

01:08:29.360 --> 01:08:32.500
So the templates provide a Nib file
that's already ready with a view.

01:08:32.500 --> 01:08:34.000
You can just put your control on.

01:08:34.200 --> 01:08:37.950
The view is already,
the file owner is already configured

01:08:38.010 --> 01:08:41.900
to be of class QCPluginViewController.

01:08:41.900 --> 01:08:44.840
Its view outlet is already
connected to the NSView,

01:08:44.860 --> 01:08:46.460
so everything's pretty much ready.

01:08:46.520 --> 01:08:48.960
Let's add an NSTextView.

01:08:49.990 --> 01:08:53.390
configure the NSTES view
to not have multiple fonts.

01:08:53.520 --> 01:08:57.460
And let's see, small sliders,
there we go.

01:08:57.650 --> 01:08:59.570
And finally,
we're going to bind the content

01:08:59.580 --> 01:09:04.760
of the NSTES view to the
internal state of our plugin.

01:09:04.810 --> 01:09:08.880
So we make sure we select the actual
NSTES view inside the NS scroll view.

01:09:09.130 --> 01:09:11.040
Then we go to bindings.

01:09:11.080 --> 01:09:15.000
The value here is going to be an
NSString if the NSTES view does

01:09:15.000 --> 01:09:18.910
not have multiple fonts enabled,
which is exactly what we want.

01:09:18.980 --> 01:09:22.590
So we bind to the file's owner,
which turns out to be our

01:09:22.590 --> 01:09:24.520
QC plugin view controller.

01:09:24.550 --> 01:09:27.020
Then the key pass is going to be plugin.

01:09:27.060 --> 01:09:29.430
Then at that point,
we retrieve the plugin instance.

01:09:29.680 --> 01:09:33.860
And remember,
the internal setting is text.

01:09:33.890 --> 01:09:34.760
That's our internal setting.

01:09:34.840 --> 01:09:39.200
So we just bound the contents of that
NSTES view to our internal variable.

01:09:39.250 --> 01:09:43.380
And the last thing we need to do here
is make sure it updates continuously.

01:09:43.420 --> 01:09:47.810
So let's save that and build it.

01:09:51.370 --> 01:09:52.280
All good.

01:09:52.390 --> 01:09:53.550
Make sure it's in there.

01:09:53.740 --> 01:09:54.840
It is.

01:09:54.880 --> 01:09:56.610
Simple text.

01:09:56.680 --> 01:09:58.300
Let me hide that.

01:09:58.300 --> 01:09:59.300
Hide this.

01:09:59.300 --> 01:10:00.250
Quit this.

01:10:00.290 --> 01:10:00.860
Okay.

01:10:00.980 --> 01:10:06.330
And now I have a patch that's
conveniently pre-populated.

01:10:06.740 --> 01:10:10.970
So this patch is-- sorry,
this composition has an imagery string

01:10:11.080 --> 01:10:15.740
and applies some bloom effect on the
text before displaying it on a billboard

01:10:15.830 --> 01:10:17.800
so you get a nice kind of look.

01:10:17.800 --> 01:10:22.140
And let's create the
instance of our simple text.

01:10:22.140 --> 01:10:24.320
Oops.

01:10:24.320 --> 01:10:27.760
Oh, I might have to quit it.

01:10:27.760 --> 01:10:29.950
Yeah, it's there.

01:10:30.000 --> 01:10:31.530
Simple text.

01:10:33.660 --> 01:10:39.800
Pierre-Olivié Latour: Here we go.

01:10:39.800 --> 01:10:39.800
It wasn't loaded, I guess.

01:10:39.800 --> 01:10:39.800
Connect to the string input.

01:10:40.130 --> 01:10:42.980
So now I have my initial value,
which if you remember was Bonjour.

01:10:43.030 --> 01:10:46.740
What becomes interesting is
I can go show the inspector,

01:10:46.940 --> 01:10:48.930
go to the settings pane,
and now I have my text

01:10:48.990 --> 01:10:49.930
view with the text.

01:10:50.060 --> 01:10:52.300
And I can type some text here,
and it's all real time.

01:10:52.300 --> 01:10:56.250
So do a nice thing with the effects,
you know.

01:11:09.580 --> 01:11:15.520
I can save the composition, quit,
and reopen it, and a text is there,

01:11:15.550 --> 01:11:19.420
which shows that serialization
worked perfectly fine.

01:11:19.500 --> 01:11:21.530
Back to slides, please.

01:11:26.520 --> 01:11:29.590
So that was all for the advanced
Quartz Composer session,

01:11:29.610 --> 01:11:31.440
pretty intensive context.

01:11:31.470 --> 01:11:33.790
Remember that there are many
advanced features you can

01:11:33.800 --> 01:11:34.940
leverage out of Quartz Composer.

01:11:34.940 --> 01:11:38.980
Quartz Composer is definitely more
than just to do pretty motion graphics.

01:11:38.980 --> 01:11:40.970
You can do pretty
professional work with it,

01:11:41.000 --> 01:11:44.110
especially if you leverage the
advanced feature of the QC view or

01:11:44.110 --> 01:11:48.000
use the QC renderer to integrate
into your own imaging pipelines.

01:11:48.020 --> 01:11:50.270
And when you reach the
limits of Quartz Composer,

01:11:50.310 --> 01:11:52.940
the Composition Loader will
allow you to build pretty complex

01:11:53.010 --> 01:11:56.680
compositions by dividing them into
sub-composition and a master one.

01:11:56.680 --> 01:11:58.190
Or you can even write your own patches.

01:11:58.200 --> 01:12:00.520
And we've said it's not that difficult.

01:12:00.590 --> 01:12:03.340
All the basics of writing your
own patches is really simple.

01:12:03.340 --> 01:12:06.630
So you just have to, in a way,
put your code for the actual patch

01:12:06.670 --> 01:12:10.200
in the pre-populated templates,
and you're good to go.

01:12:10.200 --> 01:12:11.830
Thanks for coming.

01:12:18.800 --> 01:12:21.400
I don't think we have
obviously time for Q&A.

01:12:21.400 --> 01:12:24.780
The one thing worth noticing
is that we have a number of

01:12:24.780 --> 01:12:26.600
labs regarding Quartz Composer.

01:12:26.600 --> 01:12:32.520
There will be Quartz Composer folks
at the lab tonight starting at 6:00.

01:12:32.530 --> 01:12:36.020
Our official Quartz Composer
lab is tomorrow at 3:30,

01:12:36.020 --> 01:12:37.870
so there will be a number there.

01:12:37.980 --> 01:12:40.540
And finally,
I would like to remind you that we

01:12:40.540 --> 01:12:45.380
have a great developer mailing list
called QuartzComposerDev@list.apple.com

01:12:45.410 --> 01:12:47.080
to which you're welcome to subscribe.

01:12:47.080 --> 01:12:47.080
Thanks.
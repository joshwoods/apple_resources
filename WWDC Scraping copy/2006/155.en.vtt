WEBVTT

00:00:10.910 --> 00:00:13.400
Welcome to the session
on speech technology.

00:00:13.400 --> 00:00:15.920
We call this Let's Talk.

00:00:15.960 --> 00:00:20.690
I am touched that you guys all came out,
and ladies, came out here at 9 o'clock

00:00:20.690 --> 00:00:22.000
in the morning for us.

00:00:22.000 --> 00:00:24.030
You must really want to be here.

00:00:24.190 --> 00:00:31.910
My name is Kim Silverman,
and I'm the manager of the spoken

00:00:31.910 --> 00:00:31.910
language technologies at Apple.

00:00:32.270 --> 00:00:36.870
Today we're going to talk
about speech synthesis.

00:00:36.870 --> 00:00:38.150
We're going to talk
about speech recognition.

00:00:38.490 --> 00:00:42.400
I'll give you overviews of
those features in the Mac,

00:00:42.400 --> 00:00:52.320
and give you some guidelines about how
to use them well in your applications,

00:00:52.320 --> 00:00:55.990
and then we'll talk through
the APIs in a bit more detail

00:00:55.990 --> 00:00:55.990
to show you some real code.

00:00:55.990 --> 00:00:55.990
So let's start with speech synthesis.

00:00:58.540 --> 00:01:01.580
Speech synthesis has been
on the Mac since the Mac was

00:01:01.580 --> 00:01:05.390
first launched in 1984,
and particularly starting

00:01:05.390 --> 00:01:08.510
around about the time of OS 7,
it started getting better

00:01:08.670 --> 00:01:10.540
and better with each release.

00:01:10.540 --> 00:01:17.440
We currently have quite a range
of voices that give you different

00:01:17.440 --> 00:01:17.440
trade-offs of footprint and technology.

00:01:17.720 --> 00:01:20.960
Speech synthesis is the core
technology in VoiceOver,

00:01:21.180 --> 00:01:23.680
which is Apple's screen reader.

00:01:23.680 --> 00:01:26.560
And today,
I'm delighted to be able to announce

00:01:26.560 --> 00:01:28.920
that we have new speech synthesis.

00:01:28.920 --> 00:01:33.500
You might have heard this in the
Steve Jobs keynote on Monday morning,

00:01:33.500 --> 00:01:37.520
and I'd like to introduce our new voice,
whose name is Alex.

00:01:37.520 --> 00:01:41.850
And rather than me telling you about it,
it seemed to me that I should

00:01:41.850 --> 00:01:43.960
let Alex introduce himself.

00:01:43.960 --> 00:01:45.560
So could we shift to the demo machine,
please?

00:01:55.330 --> 00:01:59.390
Let me just plug in the audio,
just a moment.

00:01:59.390 --> 00:02:02.200
I'm going to plug in the audio,
this might click.

00:02:02.200 --> 00:02:05.920
Okay, we are in.

00:02:05.950 --> 00:02:07.740
Ready?

00:02:09.540 --> 00:02:14.400
My name is Alex, and I am the new speech
synthesis voice in Mac OS X.

00:02:14.400 --> 00:02:18.560
I'm not yet finished,
so you will probably notice some places

00:02:18.560 --> 00:02:21.060
where I still need more polishing.

00:02:21.060 --> 00:02:25.610
Apple has worked on a different
approach to speech synthesis technology

00:02:25.610 --> 00:02:27.860
in order to be able to produce me.

00:02:27.860 --> 00:02:31.790
People say that I sound more
natural and easier to understand

00:02:31.790 --> 00:02:33.800
than Apple's prior voices.

00:02:33.800 --> 00:02:38.620
Like some of those voices,
I'm based on recordings of a real human.

00:02:39.250 --> 00:02:42.950
But unlike those voices,
I'm based on much longer recordings

00:02:42.950 --> 00:02:46.050
and have a very different
approach to the signal processing.

00:02:46.060 --> 00:02:50.040
Another improvement is that
I can speak very quickly,

00:02:50.050 --> 00:02:53.680
and yet people can still
understand my speech.

00:02:53.680 --> 00:02:55.200
Here is a sample.

00:02:55.200 --> 00:02:58.180
Make sure to be there Monday, July 5th,
about 8.30 in the morning.

00:02:58.180 --> 00:03:00.410
Try to be on time and bring the
most recent results with you.

00:03:02.170 --> 00:03:07.660
And now, to tell you more about me,
let me introduce a man so deep,

00:03:07.660 --> 00:03:10.190
he is almost unfathomable.

00:03:10.250 --> 00:03:14.180
A man so quick, he is even fast asleep.

00:03:14.220 --> 00:03:17.210
A man who is a legend in his own mind.

00:03:17.280 --> 00:03:19.100
Gandalf.

00:03:19.120 --> 00:03:20.540
Er, sorry.

00:03:20.870 --> 00:03:23.850
I mean, Kim Silverman.

00:03:29.300 --> 00:03:33.750
So Alex is being a bit of
a smart alec this morning.

00:03:33.890 --> 00:03:39.940
I mentioned that Alex has been
designed to be the core technology

00:03:40.080 --> 00:03:42.160
and work well in VoiceOver.

00:03:42.220 --> 00:03:44.550
For those of you who
are unfamiliar with it,

00:03:44.660 --> 00:03:51.880
VoiceOver is a feature of Mac OS X for
people with low vision or no vision.

00:03:51.900 --> 00:03:55.610
And it uses speech synthesis to
feed back to a person who can't

00:03:55.610 --> 00:03:58.900
see the screen information about
everything going on on the screen,

00:03:58.940 --> 00:04:03.620
what the front most window is,
where the mouse is, and so on.

00:04:03.620 --> 00:04:05.450
Let's turn it on.

00:04:06.500 --> 00:04:08.530
Welcome to Macintosh.

00:04:08.530 --> 00:04:09.530
VoiceOver is running.

00:04:09.640 --> 00:04:14.500
System Preferences,
Universal Access Window, Back button.

00:04:14.500 --> 00:04:18.500
So I'll navigate around a few of these
controls and you will hear how it sounds.

00:04:18.630 --> 00:04:27.150
Forward, Dimmed button, Show All button,
Seeing, Selected tab 1 of 4,

00:04:27.150 --> 00:04:29.500
Hearing tab 2 of 4.

00:04:29.610 --> 00:04:33.320
Now, people who use these things all day,
every day, want the speech usually

00:04:33.320 --> 00:04:35.380
to be faster than this.

00:04:35.510 --> 00:04:38.430
So let's take the volume, the rate up.

00:04:38.540 --> 00:04:40.500
You can do this with keystroke
commands that I'm using here.

00:04:41.100 --> 00:04:46.500
Faster, faster, faster, faster, faster,
faster, faster, faster, faster, faster,

00:04:46.500 --> 00:04:46.500
faster.

00:04:46.500 --> 00:04:47.380
Let's try that.

00:04:47.500 --> 00:04:52.500
Seeing, Selected tab 1 of 4,
Hearing tab 2 of 4, Keyboard tab 3 of 4.

00:04:52.520 --> 00:04:55.490
But they like it even faster than that,
so let's go further.

00:04:55.500 --> 00:04:59.500
Faster, faster, faster, faster, faster,
faster, faster, faster.

00:04:59.500 --> 00:05:00.440
Turn VoiceOver on or off, Command F5.

00:05:00.500 --> 00:05:04.500
VoiceOver on, Selected radio off,
Radio button 2 of 2.

00:05:04.500 --> 00:05:05.780
go with voiceover.

00:05:05.780 --> 00:05:06.970
Thank you.

00:05:07.370 --> 00:05:10.930
Now, while I'm in the System Preferences,
I'd like to show you one of the features

00:05:11.420 --> 00:05:18.780
that we've used to incorporate speech
synthesis into the user interface.

00:05:18.780 --> 00:05:24.610
And the reason I'm showing you
this is to inspire you with one

00:05:24.610 --> 00:05:28.480
use of speech synthesis you could
use in your own applications.

00:05:28.480 --> 00:05:28.480
If I go to the Speech Preferences
and the Text-to-Speech tab,

00:05:28.680 --> 00:05:33.440
There's a control here that's labeled
"announce when alerts are displayed."

00:05:33.490 --> 00:05:36.910
We call this "talking alerts."

00:05:37.070 --> 00:05:38.540
Here's what this is about.

00:05:38.620 --> 00:05:43.140
Suppose I'm working on the computer,
and then an alert comes up on my screen

00:05:43.140 --> 00:05:47.640
that wants some kind of response from me,
but I'm not looking.

00:05:47.710 --> 00:05:54.720
My attention is out the window,
or I'm daydreaming,

00:05:54.720 --> 00:05:54.720
talking to somebody else,
and I miss the alert and

00:05:54.720 --> 00:05:54.720
miss responding to it.

00:05:55.600 --> 00:05:59.740
In that case, if I don't respond after
a certain amount of time,

00:05:59.740 --> 00:06:04.140
the computer could read out the alert
to me in order to get my attention back.

00:06:04.250 --> 00:06:05.490
So that's what this does.

00:06:05.610 --> 00:06:09.310
In the alert options, you can set a delay
until it starts speaking.

00:06:09.400 --> 00:06:13.480
By default, it's about 20 seconds.

00:06:13.480 --> 00:06:18.490
I'll put it back to being
zero now and set it to,

00:06:18.490 --> 00:06:21.540
say, one of these phrases.

00:06:21.540 --> 00:06:22.310
So suppose I modify this document.

00:06:23.750 --> 00:06:28.300
And then I go to close
it without saving it.

00:06:28.330 --> 00:06:29.250
Here's how it sounds.

00:06:30.160 --> 00:06:31.020
Alert.

00:06:31.180 --> 00:06:35.150
Do you want to save changes to
this document before closing?

00:06:36.380 --> 00:06:39.300
We've been getting a lot
of feedback about this.

00:06:39.300 --> 00:06:41.670
One guy said to me,
"I was crawling around on my

00:06:41.670 --> 00:06:44.810
hands and knees underneath my
desk rearranging some cables,

00:06:44.810 --> 00:06:48.300
and suddenly this voice unexpectedly
came out of my computer saying,

00:06:48.350 --> 00:06:54.510
'The internet is being
disconnected.' I turned around and,

00:06:54.510 --> 00:06:55.300
oh, sure enough, my foot had kicked out
the ethernet cable."

00:06:56.870 --> 00:07:02.710
And so, the principle here is,
if there are things going on

00:07:02.710 --> 00:07:09.590
in your application that you'd
like your user to respond to,

00:07:09.590 --> 00:07:09.590
but your user may not be attending,
then you can add speech as a way of

00:07:09.590 --> 00:07:09.590
getting the user's attention back.

00:07:11.300 --> 00:07:16.750
Now, another announcement we have today
is that we have modified the API to

00:07:16.890 --> 00:07:19.540
allow a plug-in architecture.

00:07:19.610 --> 00:07:24.980
What that's all about is that there are
other companies like yourselves out there

00:07:24.980 --> 00:07:30.900
who have speech synthesis technology that
has different characteristics from ours.

00:07:30.900 --> 00:07:35.380
Different voices, different genders,
different trade-offs of

00:07:35.380 --> 00:07:39.380
quality and footprint,
or, most relevantly to you guys,

00:07:39.380 --> 00:07:40.570
different languages.

00:07:44.590 --> 00:07:45.500
Thank you.

00:07:45.500 --> 00:07:48.330
So it's now possible,
oh let's just close this,

00:07:48.550 --> 00:07:52.070
for them to port their speech
synthesis to the speech manager,

00:07:52.070 --> 00:07:57.740
and their voices show up under the list
of voices just like our own voices do.

00:07:57.870 --> 00:08:00.060
One of those companies is capstral.com.

00:08:00.260 --> 00:08:02.060
You may have heard of them.

00:08:02.180 --> 00:08:05.250
So I have here a couple
of voices from Capstral.

00:08:05.440 --> 00:08:08.400
One of them is Katrin,
their German voice.

00:08:08.430 --> 00:08:11.100
Dies ist die Capstra-Katrin-Stimme.

00:08:11.140 --> 00:08:13.930
So let's have her introduce
herself over here.

00:08:16.020 --> 00:08:19.140
Hello,
I am Katrin from the Capstall house.

00:08:19.220 --> 00:08:23.110
I am always well occupied and
therefore have not held a lecture on

00:08:23.170 --> 00:08:25.960
an interesting conference for a while.

00:08:26.000 --> 00:08:29.730
That is why I was also deeply
moved when I was asked to

00:08:29.730 --> 00:08:32.000
talk here in front of Apple.

00:08:32.000 --> 00:08:36.770
And I have to say, on a Mac I really feel
like home again and again.

00:08:42.950 --> 00:08:45.260
For those of you that
don't understand German,

00:08:45.340 --> 00:08:48.540
she just said some very complimentary
things about you and about us.

00:08:49.990 --> 00:08:52.080
So this means if you've got
an application that you want

00:08:52.080 --> 00:08:54.330
to sell into a German market,
German speaking market,

00:08:54.470 --> 00:08:57.860
and you use speech synthesis,
here's a way that you can go.

00:08:57.910 --> 00:09:00.690
If you're selling into
the English market,

00:09:00.690 --> 00:09:05.300
there are also some interesting things
that you can do with these voices.

00:09:05.460 --> 00:09:08.300
For example,
if you pass them English text,

00:09:08.500 --> 00:09:12.230
then they will speak that text
as a native speaker of that other

00:09:12.230 --> 00:09:14.330
language would try to speak it.

00:09:14.360 --> 00:09:17.220
And that can sometimes sound interesting.

00:09:17.250 --> 00:09:19.720
We think this is very interesting.

00:09:23.200 --> 00:09:28.840
We have another voice over here, Miguel,
who speaks Spanish.

00:09:28.950 --> 00:09:32.760
Miguel, who speaks Spanish.

00:09:33.260 --> 00:09:37.100
So let's get him to
introduce himself as well.

00:09:37.750 --> 00:09:40.200
Hola, me llamo Miguel.

00:09:40.700 --> 00:09:43.880
Soy la voz del español de
las Américas de Kevstral.

00:09:43.890 --> 00:09:45.200
Encantado de conoceros.

00:09:46.350 --> 00:09:49.780
Es mi primera vez en
una conferencia WWDC.

00:09:49.830 --> 00:09:53.280
Verdaderamente me
fascina el mundo del Mac.

00:09:53.360 --> 00:09:54.370
So that's speech synthesis.

00:09:54.500 --> 00:09:55.270
Thanks.

00:09:55.290 --> 00:10:02.180
Can we go back to the main slides,
please?

00:10:06.780 --> 00:10:11.050
So, you use speech synthesis just by
passing it text and having it speak it.

00:10:11.260 --> 00:10:14.140
And the speech synthesizer will
analyze the text and make its

00:10:14.190 --> 00:10:17.960
best guess regarding how you
would like that text spoken.

00:10:17.960 --> 00:10:21.940
And usually the guess is pretty good,
but you can do even better.

00:10:21.940 --> 00:10:26.540
The problem is,
the way we say something depends on why

00:10:26.540 --> 00:10:31.670
we're saying it and on how it relates
to what the listener already knows.

00:10:33.030 --> 00:10:35.620
So really, to get it right,
the speech synthesis engine

00:10:35.620 --> 00:10:37.020
has got to be a mind reader.

00:10:37.020 --> 00:10:40.500
And we're not going to
release that one in Leopard.

00:10:42.850 --> 00:10:47.090
But the solution, the workaround,
is that your application knows a

00:10:47.090 --> 00:10:50.190
lot more about what it's saying
and why it's saying it than the

00:10:50.190 --> 00:10:51.930
speech synthesizer could ever guess.

00:10:51.940 --> 00:10:55.460
And so you can use that domain-specific
knowledge that's inherent in your

00:10:55.470 --> 00:10:57.760
application to improve the speech.

00:10:57.760 --> 00:11:00.550
For example,
one thing you can do is filter the texts.

00:11:00.660 --> 00:11:03.960
Take, for example,
an application that let

00:11:03.960 --> 00:11:06.020
people deal with stocks.

00:11:06.020 --> 00:11:11.680
It could substitute for each of the
ticker symbols the actual company name,

00:11:11.920 --> 00:11:15.900
such as, rather than saying AAPL,
it could say Apple Computer.

00:11:15.900 --> 00:11:18.910
You can customize the pronunciations.

00:11:18.940 --> 00:11:20.780
You can customize the intonation.

00:11:20.780 --> 00:11:23.480
Let's talk about those
in a bit more detail.

00:11:23.480 --> 00:11:27.700
In the case of pronunciations,
there are some words that a

00:11:27.700 --> 00:11:31.460
synthesizer may not pronounce
the way you know they ought to be

00:11:31.460 --> 00:11:32.810
pronounced in your application.

00:11:32.820 --> 00:11:35.820
Some names are a particular
problem like that.

00:11:35.900 --> 00:11:37.900
Some technical expressions.

00:11:37.900 --> 00:11:40.660
Some words that are specific
to your application.

00:11:40.960 --> 00:11:43.240
Well,
what developers have done in the past has

00:11:43.960 --> 00:11:49.190
been what we call "funny spelling", which
is they retype a word with different

00:11:49.360 --> 00:11:52.300
spelling in order to try to get it
to be pronounced the way they want.

00:11:52.610 --> 00:11:56.590
We don't recommend this because
pronunciation of non-standard

00:11:56.670 --> 00:12:00.460
spellings might change as we make
different releases of the synthesizer.

00:12:00.500 --> 00:12:03.460
And besides, there's only a limit to how
far you can go with a spelling

00:12:03.460 --> 00:12:05.460
because you're still working
through the letter-to-sound rules.

00:12:05.460 --> 00:12:09.740
The better way is to use part of the
API that's called "phoneme input".

00:12:10.060 --> 00:12:15.230
That lets you embed in the input to
the synthesizer the exact specification

00:12:15.230 --> 00:12:18.030
of the phonemes that you want it
to use when pronouncing something.

00:12:18.040 --> 00:12:19.540
Let me give you an example.

00:12:19.540 --> 00:12:20.490
This is a real example.

00:12:21.100 --> 00:12:25.200
The name "beardno" was
mispronounced by our synthesizer

00:12:25.280 --> 00:12:26.540
up until about a week ago.

00:12:26.540 --> 00:12:28.540
Here's how it was pronounced.

00:12:28.540 --> 00:12:39.210
It's saying something
like "by I are now". So,

00:12:39.210 --> 00:12:43.040
I... substitute in our dictionary
this particular phoneme string,

00:12:43.230 --> 00:12:46.950
and now it says:
"My name is Professor Beardno".

00:12:47.040 --> 00:12:51.960
"Beardno". "My name is
Professor Beardno". This phoneme

00:12:52.070 --> 00:12:54.040
input is very easy to learn.

00:12:54.040 --> 00:12:58.040
There are about 40-something,
maybe 42 symbols,

00:12:58.230 --> 00:13:01.040
and it's all documented in
the speech documentation.

00:13:01.100 --> 00:13:02.970
This is your insurance
against the future.

00:13:03.140 --> 00:13:05.960
Use this method to customize
the pronunciations.

00:13:07.180 --> 00:13:11.540
Now, to customize the intonation,
the problem that we're addressing

00:13:11.540 --> 00:13:17.310
here is once we have intelligibly
synthesized the words,

00:13:17.400 --> 00:13:18.910
we haven't done enough.

00:13:19.040 --> 00:13:21.500
You know the expression,
it's not what he said,

00:13:21.500 --> 00:13:22.910
it's the way that he said it.

00:13:23.040 --> 00:13:26.330
The way that you say something
can change its meaning.

00:13:26.340 --> 00:13:30.870
Take, for example, the sentence,
John only introduced Mary to Bill.

00:13:30.880 --> 00:13:34.230
That means he didn't introduce
Mary to anybody else.

00:13:35.600 --> 00:13:38.910
But if I say,
John only introduced Mary to Bill,

00:13:38.920 --> 00:13:41.040
that means he didn't actually
encourage her to have a

00:13:41.100 --> 00:13:42.600
business relationship with him.

00:13:44.290 --> 00:13:47.640
Now the problem here again is
that automatically determining

00:13:47.640 --> 00:13:51.040
the correct intonation is
difficult in the general case.

00:13:51.040 --> 00:13:53.350
You've got to have ESP.

00:13:53.630 --> 00:13:57.260
But your application knows why
it's saying what it's saying,

00:13:57.260 --> 00:14:01.440
and it knows what the listener has
already done in its prior interaction.

00:14:01.440 --> 00:14:03.380
And so you can do better.

00:14:03.380 --> 00:14:08.320
And one principle that you can apply
is what I call let the user catch up.

00:14:08.440 --> 00:14:12.420
That is,
add pauses at the boundaries between

00:14:12.420 --> 00:14:15.200
major information chunks in your texts.

00:14:15.200 --> 00:14:19.840
One easy way to do that is just liberally
sprinkle punctuation around and break up

00:14:20.290 --> 00:14:23.100
larger sentences into smaller sentences.

00:14:23.510 --> 00:14:28.800
When we developers and technical folk
write our texts in our applications,

00:14:28.800 --> 00:14:32.070
we tend to write it in
the style of written text.

00:14:32.080 --> 00:14:34.320
Written text tends to
have long sentences.

00:14:34.320 --> 00:14:37.160
Human speech tends to
have short sentences.

00:14:37.160 --> 00:14:38.140
So break them up.

00:14:38.240 --> 00:14:41.960
If there are any pauses that
the synthesizer inserts that

00:14:42.020 --> 00:14:44.470
you'd like to be even longer,
you can lengthen them by

00:14:44.480 --> 00:14:47.680
embedding the command in
yellow up there into your text.

00:14:47.680 --> 00:14:49.230
That inserts silence.

00:14:49.320 --> 00:14:53.240
In this case, it adds another 500
milliseconds of silence.

00:14:53.460 --> 00:14:56.270
Let me illustrate the issue here.

00:14:56.300 --> 00:15:00.810
Suppose you have an airline
reservation application that reads back

00:15:00.810 --> 00:15:03.640
information about a booking to a user.

00:15:03.640 --> 00:15:09.260
You might populate a text sentence by
filling out fields from a database.

00:15:09.260 --> 00:15:11.900
The values in yellow would
be pulled out of a database,

00:15:11.960 --> 00:15:14.610
put into this frame sentence,
and then the text sent to

00:15:14.610 --> 00:15:15.860
the speech synthesizer.

00:15:15.860 --> 00:15:19.230
If you do it with this text as written,
it sounds like this.

00:15:19.240 --> 00:15:23.440
Your first flight is with
Alaska Airlines Flight 2762D,

00:15:23.470 --> 00:15:27.670
departing from San Jose on Monday,
May 24th at 6:10 p.m., landing

00:15:27.670 --> 00:15:29.560
in San Francisco at 7:10 p.m.

00:15:29.680 --> 00:15:31.370
Thanks for choosing Apple Travel.

00:15:31.420 --> 00:15:34.010
So you can get all the words,
but it kind of barrels

00:15:34.200 --> 00:15:35.220
through it pretty quickly.

00:15:35.280 --> 00:15:38.700
If the user were trying to jot
down the information there,

00:15:38.710 --> 00:15:41.620
they might have trouble
keeping up with it.

00:15:41.690 --> 00:15:47.190
So in this version, I've added commas,
some periods.

00:15:47.310 --> 00:15:50.410
I've separated out that last
line into a separate paragraph,

00:15:50.660 --> 00:15:53.420
which adds a bit more of a
pause and changes its pitch.

00:15:53.630 --> 00:15:57.440
And I've added an extra silence of
300 milliseconds before the last

00:15:57.640 --> 00:15:58.700
phrase of the first paragraph.

00:15:58.740 --> 00:16:00.720
So that now sounds like this.

00:16:00.780 --> 00:16:05.700
Your first flight is with
Alaska Airlines Flight 2762,

00:16:06.100 --> 00:16:10.760
departing from San Jose on Monday,
May 24th at 6:10 p.m., landing

00:16:11.280 --> 00:16:13.890
in San Francisco at 7:10 p.m.

00:16:13.900 --> 00:16:17.120
Thanks for choosing Apple Travel.

00:16:17.140 --> 00:16:20.940
That gives people a bit more of a
chance to catch up and maybe jot down

00:16:21.060 --> 00:16:22.240
some notes while they're listening.

00:16:22.260 --> 00:16:24.500
The point is, Customize.

00:16:26.640 --> 00:16:30.280
Okay,
so let's talk about speech recognition.

00:16:30.280 --> 00:16:33.280
There's a speech recognizer
built into every Mac.

00:16:33.280 --> 00:16:34.480
It's part of OS X.

00:16:34.530 --> 00:16:39.940
It has a well-documented API that you'll
hear about a little later this morning.

00:16:40.030 --> 00:16:44.250
But there are a few characteristics
of the recognizer that I'd

00:16:44.250 --> 00:16:46.180
like you to know about now.

00:16:46.250 --> 00:16:49.060
One is that it's speaker independent.

00:16:49.060 --> 00:16:53.710
Your users don't have to spend
hours training it to their voices.

00:16:53.710 --> 00:16:54.110
They can just walk up to it and use it.

00:16:54.280 --> 00:16:57.340
The second is that it's driven
by a finite state grammar.

00:16:57.340 --> 00:17:00.360
What that means is you load
up the recognizer with a

00:17:00.590 --> 00:17:03.620
representation of everything
that you want it to listen for,

00:17:03.620 --> 00:17:07.120
and then tell it to start listening,
and it tells you when it hears a

00:17:07.120 --> 00:17:09.290
string that's part of that grammar.

00:17:09.300 --> 00:17:13.420
That means it works really
well for command and control,

00:17:13.420 --> 00:17:19.880
for spoken interactive dialogues,
but it doesn't do unrestricted dictation.

00:17:20.810 --> 00:17:23.680
For that, there are some third-party
solutions available,

00:17:23.680 --> 00:17:25.420
such as iListen from Mac Speech.

00:17:27.060 --> 00:17:30.870
The third thing is that it works
with a Far Field Microphone.

00:17:30.940 --> 00:17:34.250
That means for the general case,
you don't need to tether yourself

00:17:34.250 --> 00:17:37.000
to the machine with a head-mounted,
close-talking,

00:17:37.000 --> 00:17:38.780
noise-cancelling microphone.

00:17:38.780 --> 00:17:41.020
You don't have to go out
and buy extra hardware.

00:17:41.020 --> 00:17:44.420
You don't have to have extra
cables dangling across your desk.

00:17:44.420 --> 00:17:47.380
Now because it's working
with a Far Field Microphone,

00:17:47.700 --> 00:17:51.120
that means it hears all the
background noises in the room.

00:17:51.120 --> 00:17:56.700
The reverberation, the echoes,
the computer fans, the air conditioning,

00:17:56.750 --> 00:17:59.770
the traffic going past,
all the stuff that we as

00:17:59.770 --> 00:18:02.220
people are not aware of,
it's hearing.

00:18:02.220 --> 00:18:04.850
How many of you have ever
recorded a meeting on a cassette

00:18:04.970 --> 00:18:07.740
deck or a dictaphone and then
played the tape back later?

00:18:07.740 --> 00:18:09.360
Who's done that?

00:18:09.820 --> 00:18:10.800
It's amazing isn't it?

00:18:10.800 --> 00:18:13.240
You listen to it and think how on
Earth did I understand anything?

00:18:13.360 --> 00:18:15.720
Well our speech recognizer
has to deal with that as well,

00:18:15.720 --> 00:18:19.080
so we have layers of algorithms
to dynamically track,

00:18:19.170 --> 00:18:23.420
adapt to and compensate
for the room acoustics.

00:18:23.420 --> 00:18:26.560
There are, however,
limits to how far it can compensate and

00:18:26.560 --> 00:18:30.380
we're going to be demoing it in here
where the distance between here and

00:18:30.380 --> 00:18:33.950
the back wall is causing this enormous
echo which is just on the limit,

00:18:33.950 --> 00:18:38.160
actually a little bit past the
limit of what we've designed it for.

00:18:38.160 --> 00:18:41.520
So I am going to be using a head mounted
microphone demoing it today and there's

00:18:41.520 --> 00:18:44.440
a principle there for your users,
give them some kind of guidance

00:18:44.530 --> 00:18:47.290
to know am I going to be using
it in a place that's too noisy,

00:18:47.290 --> 00:18:51.320
in which case there are a lot of third
party head mounted microphones out there.

00:18:51.320 --> 00:18:53.570
Now because it's adapting, I'm

00:18:53.680 --> 00:18:57.760
That means that if you use it in one
place and then go to a different place,

00:18:57.810 --> 00:19:00.810
a different acoustic environment,
it will still think it's in the old

00:19:00.810 --> 00:19:02.420
place and it may not work so well.

00:19:02.420 --> 00:19:05.590
For example, you're using it at home,
on the kitchen table,

00:19:05.590 --> 00:19:09.370
at night after the kids go to bed,
and then you close up your MacBook,

00:19:09.370 --> 00:19:11.980
take it to the office next
morning and open it up,

00:19:11.980 --> 00:19:15.250
it still thinks it's at home,
and so it takes a while before

00:19:15.350 --> 00:19:17.770
it can adapt to your voice in
the new acoustic environment.

00:19:17.780 --> 00:19:20.300
And you might think, oh,
the recogniser's not working so well.

00:19:21.290 --> 00:19:24.440
Well, we have a user interface that
speeds up that adaptation,

00:19:24.440 --> 00:19:26.680
and I'd like to start off
by showing that to you now.

00:19:26.680 --> 00:19:29.140
So could we go back to the demo machine,
please?

00:19:39.370 --> 00:19:43.010
If you go to the speech
recognition preferences,

00:19:43.010 --> 00:19:48.700
then there's a button there called
"Calibrate". If I click on that,

00:19:49.560 --> 00:19:54.040
I get a dialogue that lets me set the
volume sensitivity of the microphone.

00:19:54.090 --> 00:20:00.440
And I should set that so that the peaks
of my speech are just coming up to the

00:20:00.440 --> 00:20:00.440
end of the green or bumping into the red.

00:20:01.020 --> 00:20:04.460
Then there are a list
of commands on the left.

00:20:04.510 --> 00:20:14.650
After you have set the volume correctly,
then you read down these commands,

00:20:14.650 --> 00:20:14.650
and each command, if it is recognized,
will flash.

00:20:14.930 --> 00:20:18.020
If a command doesn't flash,
you say it a second time.

00:20:18.200 --> 00:20:22.400
If it doesn't get it the second time,
just go on to the next command.

00:20:22.590 --> 00:20:30.150
When you get to the bottom of the list,
if it missed any of them,

00:20:30.150 --> 00:20:30.150
go back up and go through
the list a second time.

00:20:30.150 --> 00:20:30.150
So let's give it a try.

00:20:31.130 --> 00:20:33.400
What time is it?

00:20:33.560 --> 00:20:36.000
Quit this application?

00:20:36.150 --> 00:20:38.200
Open a document?

00:20:38.380 --> 00:20:40.470
Show me what to say?

00:20:41.300 --> 00:20:44.320
Make this page speakable.

00:20:44.400 --> 00:20:46.580
Move page down.

00:20:46.770 --> 00:20:48.800
Hide this application.

00:20:49.070 --> 00:20:50.980
Switch to Finder.

00:20:52.230 --> 00:20:53.440
Done.

00:20:53.570 --> 00:20:57.440
We just set a couple of
hundred parameters in there.

00:20:57.440 --> 00:21:04.480
So let's put it through its paces a
little bit before I talk any more,

00:21:04.480 --> 00:21:04.480
and so you can see what happens.

00:21:10.900 --> 00:21:30.100
[Transcript missing]

00:21:31.480 --> 00:21:32.630
What time is it?

00:21:32.800 --> 00:21:35.160
It's 9:24.

00:21:35.220 --> 00:21:36.390
What day is it?

00:21:36.480 --> 00:21:38.940
It's Friday, August 11th.

00:21:39.010 --> 00:21:40.940
Quit from System Preferences?

00:21:41.010 --> 00:21:43.500
Quitting System Preferences.

00:21:43.590 --> 00:21:46.460
Get my mail?

00:21:46.530 --> 00:21:48.580
Open my browser.

00:21:48.630 --> 00:21:50.660
Open my browser.

00:21:52.380 --> 00:21:54.060
Get Apple stock price.

00:21:54.110 --> 00:21:55.930
Get Apple.

00:21:56.020 --> 00:21:57.520
Let's see how we're doing.

00:21:57.580 --> 00:21:58.730
Ah, 63.

00:21:58.800 --> 00:22:00.700
Hey, the stock's a bit low, guys.

00:22:00.810 --> 00:22:05.020
Could you write lots of cool applications
for us and get our stock price up?

00:22:05.680 --> 00:22:07.600
Oh, look at that.

00:22:07.990 --> 00:22:09.600
Astronomy Picture of the Day.

00:22:09.880 --> 00:22:11.600
Astronomy Picture of the Day.

00:22:11.600 --> 00:22:12.560
Oh, this is cool.

00:22:12.600 --> 00:22:13.520
Look at that shooting star.

00:22:13.600 --> 00:22:15.600
Zoom into this.

00:22:15.600 --> 00:22:17.600
Cool.

00:22:17.600 --> 00:22:19.220
Zoom back out.

00:22:21.600 --> 00:22:25.080
Suppose I'd like to mail
this web page to a friend.

00:22:25.080 --> 00:22:28.500
Well, I could go through the
steps of copying the URL,

00:22:28.500 --> 00:22:33.910
finding his name in the address book,
launching mail, or I could just say,

00:22:34.930 --> 00:22:37.970
Mail this to Kevin Aiitken.

00:22:38.330 --> 00:22:40.200
Mail this to Kevin Aiitken.

00:22:40.210 --> 00:22:42.090
One moment please.

00:22:45.030 --> 00:22:48.900
Created a message to
Kevin Aiitken with this URL.

00:22:48.900 --> 00:22:52.890
So it goes into the address book,
finds his address, goes to mail,

00:22:53.080 --> 00:22:54.900
creates a new message,
goes back to the browser,

00:22:54.900 --> 00:22:56.900
copies out the URL,
goes back to the message,

00:22:56.900 --> 00:23:00.070
pastes it all in,
and puts it up in front of my face,

00:23:00.280 --> 00:23:03.900
ready for me to either
type some explanatory text,

00:23:03.900 --> 00:23:05.890
or just say,

00:23:06.100 --> 00:23:07.100
Send this message.

00:23:07.570 --> 00:23:08.750
Send this message.

00:23:09.020 --> 00:23:11.180
And that goes out as real mail.

00:23:11.270 --> 00:23:16.100
Now at this stage, Kevin is very patient,
but he's probably sick of getting all

00:23:16.100 --> 00:23:18.660
these stupid demo messages from me.

00:23:18.770 --> 00:23:22.460
So I want to telephone him and let him
know that yet another one's on its way,

00:23:22.460 --> 00:23:24.110
but I can't remember his phone number.

00:23:24.240 --> 00:23:27.600
So I say, phone for Kevin Aiitken.

00:23:27.760 --> 00:23:28.860
Opening text edit.

00:23:28.900 --> 00:23:30.360
Oh.

00:23:30.550 --> 00:23:31.980
Phone for Kevin Aiitken.

00:23:32.050 --> 00:23:34.470
Phone for Kevin Aiitken.

00:23:36.140 --> 00:23:39.500
And were a dress book set up properly,
it would do it.

00:23:39.700 --> 00:23:45.340
Why is that not working?

00:23:45.340 --> 00:23:45.340
Every time I do this, it works.

00:23:45.340 --> 00:23:45.340
Then I demo it.

00:23:45.770 --> 00:23:49.460
I have to tell you that this
is my personal PowerBook here,

00:23:49.460 --> 00:23:54.470
and some of the components here are parts
of software that we've been working on

00:23:54.470 --> 00:23:58.500
as we download new versions of Leopard,
and sometimes I get

00:23:58.500 --> 00:23:59.790
interactions like this.

00:23:59.940 --> 00:24:05.790
Oh well,
it would have displayed it on the screen.

00:24:05.790 --> 00:24:05.790
Try it on your own machines, and it will,
there.

00:24:07.060 --> 00:24:08.280
Quit from Address Book.

00:24:08.340 --> 00:24:12.350
Quitting Address Book.

00:24:12.350 --> 00:24:16.080
There are some applications
that call our API directly.

00:24:16.080 --> 00:24:16.080
Let me just show you one of them.

00:24:17.200 --> 00:24:30.500
[Transcript missing]

00:24:33.110 --> 00:24:39.320
Nye G A2F6 I don't like it when a
computer this powerful takes six and

00:24:39.320 --> 00:24:43.000
a half seconds thinking about what
it's going to do to counter my moves.

00:24:45.620 --> 00:24:50.040
This lets me do something that my
17-year-old son won't let me do

00:24:50.040 --> 00:24:52.000
when I'm playing chess with him.

00:24:52.250 --> 00:24:58.290
This lets me say,
"Take back move." Take back move.

00:25:01.320 --> 00:25:03.390
Now one of the things
that you can do with,

00:25:03.390 --> 00:25:05.260
uh, well let me, well I've shown you a
whole bunch of things,

00:25:05.320 --> 00:25:09.260
let me explain a little bit
about what you've just seen.

00:25:09.660 --> 00:25:13.940
We have a speech recognition
engine that has an API.

00:25:13.970 --> 00:25:21.600
Applications such as your
own can call that API,

00:25:21.600 --> 00:25:24.790
and already many of you do,
and use it to add speech control

00:25:24.790 --> 00:25:24.790
to your own user interfaces.

00:25:24.790 --> 00:25:24.790
But it seemed to us that

00:25:25.030 --> 00:25:27.780
It's not very good if
our users have to go out,

00:25:28.100 --> 00:25:32.490
track down, and purchase third-party
software before they can have any

00:25:32.540 --> 00:25:34.530
experience at all with speech.

00:25:34.820 --> 00:25:39.230
So we also make some simple applications
that sit in the user interface

00:25:39.290 --> 00:25:41.500
and do some things with speech.

00:25:41.500 --> 00:25:48.990
One of those is called Speakable Items.

00:25:48.990 --> 00:25:48.990
Open the Speech Preferences.

00:25:51.000 --> 00:25:59.600
You turn speakable items on in the
speech recognition preferences.

00:25:59.600 --> 00:25:59.600
That's up here.

00:25:59.600 --> 00:25:59.600
When you turn on speakable items,

00:25:59.740 --> 00:26:06.320
We create a folder in your home directory
called the Speakable Items folder.

00:26:06.320 --> 00:26:08.110
Open the Speakable Items folder.

00:26:09.180 --> 00:26:14.640
So here it is, Home, Library, Speech,
Speakable Items.

00:26:14.640 --> 00:26:23.630
Anything that's in that folder can
be launched by double-clicking it.

00:26:23.630 --> 00:26:26.950
And it's exactly the same-- sorry,
it can be launched by saying it.

00:26:26.950 --> 00:26:26.950
And that's exactly the
same as double-clicking it.

00:26:27.290 --> 00:26:30.900
We pre-populate that folder
with a number of items that

00:26:31.020 --> 00:26:33.250
kind of get you up and going,
and some of the things I've

00:26:33.250 --> 00:26:34.520
been saying are in there.

00:26:34.650 --> 00:26:41.360
For example, what time is it,
and zoom into this.

00:26:41.690 --> 00:26:47.610
Anything that can be
launched by double-clicking,

00:26:47.610 --> 00:26:47.610
you can now launch by speech,
by putting it into that folder.

00:26:47.680 --> 00:26:50.710
The real power is that you can
add things to that folder to

00:26:50.750 --> 00:26:55.380
customize it to work well with
the things that you do most often.

00:26:55.460 --> 00:26:57.580
Let me give you an example.

00:26:58.770 --> 00:27:04.100
Suppose that I have a standard
workflow that I always go through,

00:27:04.100 --> 00:27:08.480
which requires me to always
create a standard set of

00:27:08.480 --> 00:27:11.330
folders with standard names.

00:27:13.730 --> 00:27:15.600
Make a new folder.

00:27:15.600 --> 00:27:18.600
Hang on.

00:27:18.860 --> 00:27:19.600
Make new folder.

00:27:19.600 --> 00:27:20.410
There we go.

00:27:22.760 --> 00:27:24.100
Open this folder.

00:27:24.160 --> 00:27:26.620
Open this folder.

00:27:26.710 --> 00:27:28.020
Make a new folder.

00:27:28.080 --> 00:27:30.190
Make a new folder.

00:27:30.290 --> 00:27:33.250
Call this data to be analyzed.

00:27:34.280 --> 00:27:35.540
Make a new folder?

00:27:35.580 --> 00:27:37.620
Make a new folder.

00:27:37.690 --> 00:27:40.510
Call this work in progress?

00:27:41.260 --> 00:27:42.140
Make a new folder?

00:27:42.580 --> 00:27:44.360
Make a new folder.

00:27:44.630 --> 00:27:47.400
Call this "Finished Publications".

00:27:49.000 --> 00:27:50.440
Close this window.

00:27:51.320 --> 00:27:52.860
Move this to the trash.

00:27:52.860 --> 00:27:54.620
Move this to trash.

00:27:54.660 --> 00:27:55.900
Empty the trash.

00:27:55.930 --> 00:27:57.620
Empty the trash.

00:27:57.690 --> 00:28:00.560
So it's pretty easy to
customize it like that.

00:28:00.850 --> 00:28:02.960
One of the things that you can
do to customize it like that

00:28:03.280 --> 00:28:09.130
is you can add a spoken command
to send a keyboard shortcut.

00:28:09.380 --> 00:28:11.550
And that means that you guys
can very easily add speech

00:28:11.650 --> 00:28:14.650
commands to your applications
if you have keyboard shortcuts.

00:28:14.710 --> 00:28:17.880
Let me give you an illustration of that.

00:28:17.940 --> 00:28:18.580
Get my mail.

00:28:21.050 --> 00:28:25.730
So suppose I want to be able to
mark a message as being unread.

00:28:25.760 --> 00:28:29.240
Now I know it's possible,
and I know it's in one of these menus.

00:28:29.240 --> 00:28:35.230
Let's try Edit, no, View Menu, Message,
Mark.

00:28:35.320 --> 00:28:35.770
There it is.

00:28:35.970 --> 00:28:40.500
Down in this submenu, Mark as Unread.

00:28:40.500 --> 00:28:43.200
It's Shift, Command, U.

00:28:43.200 --> 00:28:47.820
These kinds of keyboard shortcuts
are sometimes hard to memorize.

00:28:47.840 --> 00:28:52.740
So I can attach a spoken
command to it by saying,

00:28:52.750 --> 00:28:55.300
define a keyboard command.

00:28:55.580 --> 00:28:57.340
And it asks me,
"What's the keyboard shortcut

00:28:57.340 --> 00:29:01.000
I want to send?" Well,
I type Shift-Command-U.

00:29:01.940 --> 00:29:04.490
And then it asks me what
is it that I want to say?

00:29:04.760 --> 00:29:11.170
So I'll say, "Mark this as unread."

00:29:11.380 --> 00:29:15.160
That's easier for me to memorize
than the keyboard shortcut.

00:29:15.320 --> 00:29:16.900
So now let's try it.

00:29:16.940 --> 00:29:22.810
I'll zoom in over here.

00:29:23.020 --> 00:29:26.760
Zoom into this.

00:29:26.760 --> 00:29:27.870
Mark this as unread.

00:29:27.870 --> 00:29:27.870
Mark this as unread.

00:29:27.870 --> 00:29:27.870
There we go.

00:29:34.100 --> 00:29:35.000
Zoom back out.

00:29:35.220 --> 00:29:38.060
Can I go back to the slides please?

00:29:47.800 --> 00:29:50.900
So when and where should you use speech?

00:29:51.080 --> 00:29:54.540
Well,
a lot of us play out recorded sounds,

00:29:54.540 --> 00:29:56.910
alerts, beeps.

00:29:57.230 --> 00:30:00.840
Back in the 1960s,
beep was about all that

00:30:00.840 --> 00:30:02.340
a computer could do.

00:30:02.470 --> 00:30:04.950
And somehow we're stuck
in that mentality.

00:30:04.950 --> 00:30:07.490
But it seems to me we're
in the 21st century now,

00:30:07.490 --> 00:30:10.210
when your computer makes a sound
to get the user's attention.

00:30:10.520 --> 00:30:15.180
You know why you're doing it,
so why not tell the computer?

00:30:15.180 --> 00:30:16.290
Use speech.

00:30:16.290 --> 00:30:21.350
And if you think about the mouse,
the point-and-click interface,

00:30:21.570 --> 00:30:24.290
it's like pointing at
things and grunting.

00:30:24.290 --> 00:30:24.290
"Ugh!

00:30:24.290 --> 00:30:24.290
Ugh!

00:30:24.290 --> 00:30:24.290
Ugh!"

00:30:26.010 --> 00:30:28.310
There's a lot you can do with it,
but I like to think that we've

00:30:28.310 --> 00:30:29.660
gone beyond just grunting.

00:30:29.660 --> 00:30:32.400
So how can you go beyond beep
and grunt in your applications?

00:30:32.400 --> 00:30:35.460
Well,
one thing you can do is notifications.

00:30:35.460 --> 00:30:37.850
Talking alerts was an example of that.

00:30:37.930 --> 00:30:42.340
Another one would be that in iChat,
you can set it up to speak to you

00:30:42.340 --> 00:30:43.870
when somebody wants to chat with you.

00:30:43.880 --> 00:30:46.610
Mail allows you to set
up rules that could say,

00:30:46.610 --> 00:30:49.750
for example,
you've got new mail from your boss.

00:30:50.360 --> 00:30:54.170
You might want to hear that rather than
discovering it two hours later when you

00:30:54.170 --> 00:30:55.960
next get to looking at your mail program.

00:30:55.980 --> 00:30:59.410
So if you have things that you
want to notify your people about,

00:30:59.670 --> 00:31:00.100
tell them.

00:31:00.200 --> 00:31:01.110
Gosh.

00:31:01.120 --> 00:31:02.380
Proofreading.

00:31:02.380 --> 00:31:05.130
You know, we all have spellcheckers,
but there are limits to how

00:31:05.130 --> 00:31:06.400
far a spellchecker can go.

00:31:06.400 --> 00:31:09.240
Many of our typing
errors make real words,

00:31:09.240 --> 00:31:11.300
such as form instead of from.

00:31:11.360 --> 00:31:13.030
Spellcheckers don't find those.

00:31:13.160 --> 00:31:15.420
Grammar checkers don't do much better.

00:31:15.420 --> 00:31:16.520
They're not very satisfying.

00:31:16.520 --> 00:31:19.120
But when you hear your
prose read out to you,

00:31:19.120 --> 00:31:20.190
you get proof.

00:31:20.380 --> 00:31:22.520
You don't get the grammar
mistakes immediately.

00:31:22.530 --> 00:31:27.080
You also get a much better feel
of the overall flow of the text.

00:31:27.480 --> 00:31:29.400
Games are a good
opportunity to use speech.

00:31:29.600 --> 00:31:31.990
If you have non mission
critical interactions that

00:31:32.050 --> 00:31:34.360
you want your user to have,
speech can be a good

00:31:34.360 --> 00:31:35.710
alternative modality for that.

00:31:35.850 --> 00:31:38.960
For example,
there was a few years ago a car racing

00:31:39.500 --> 00:31:43.320
game where you could radio ahead
to your pit stop crew to tell them

00:31:43.320 --> 00:31:46.730
what they needed to be ready to do
to your car when you next came around,

00:31:46.730 --> 00:31:51.100
such as changing the front right
tire and topping up the oil.

00:31:51.150 --> 00:31:53.260
So speech was good for that.

00:31:53.290 --> 00:31:59.110
Education-- the teachers keep telling
us we love speech synthesis because when

00:31:59.440 --> 00:32:05.360
our kids interact with an application,
if it talks, it engages them much more.

00:32:05.400 --> 00:32:09.690
Like a talking math application will
engage a kid for 20 to 25 minutes,

00:32:09.690 --> 00:32:12.200
whereas without the speech,
it only engages them

00:32:12.200 --> 00:32:13.540
for about five minutes.

00:32:13.630 --> 00:32:16.670
And while kids are hearing
things spoken back,

00:32:16.820 --> 00:32:21.280
it's reinforcing their literacy,
whether they know it or not.

00:32:21.950 --> 00:32:24.330
Web browsing,
you saw me surfing the web by voice.

00:32:24.340 --> 00:32:26.370
There's a lot more that could
be done in that direction.

00:32:26.380 --> 00:32:28.920
Speech is good for form filling.

00:32:28.920 --> 00:32:32.200
If you have an application where
there are fixed alternatives

00:32:32.200 --> 00:32:33.280
that could go into a field.

00:32:33.280 --> 00:32:37.430
For example,
a finance application where people can

00:32:37.430 --> 00:32:41.240
write checks and have a list of people
that they normally write checks to.

00:32:41.240 --> 00:32:43.800
So you could say,
make out a check to Macy's.

00:32:43.800 --> 00:32:46.740
In general,
if you have any user interaction

00:32:46.740 --> 00:32:50.080
scenario where people's eyes are
busy and their hands are busy,

00:32:50.540 --> 00:32:54.020
speech provides another modality
for you to allow them to interact.

00:32:54.120 --> 00:32:56.080
And it's kind of cool, you know.

00:32:57.720 --> 00:32:59.800
And finally, Delegation.

00:32:59.950 --> 00:33:05.350
Normally we interact with a computer
by specifying the steps we want

00:33:05.820 --> 00:33:11.960
the computer to take to achieve
a goal that we have in mind.

00:33:12.220 --> 00:33:15.820
A better user interaction model is
to delegate the goal to the computer

00:33:16.300 --> 00:33:17.960
and have it do what it's good at.

00:33:17.960 --> 00:33:20.980
Have it figure out the steps
along the way to get there.

00:33:21.250 --> 00:33:26.960
If, along the way,
it needs more information to

00:33:26.960 --> 00:33:32.550
refine how it gets to that goal,
it can come back and ask you.

00:33:32.550 --> 00:33:32.550
Sending a web page to someone
was an example of delegation.

00:33:34.280 --> 00:33:36.560
If you're going to be successful
with speech recognition in your app,

00:33:36.580 --> 00:33:37.940
then here's a few things you should do.

00:33:38.130 --> 00:33:41.600
First of all, educate your users.

00:33:41.660 --> 00:33:45.440
Let them know what the user
interface elements are,

00:33:45.440 --> 00:33:50.820
like the speech commands window,
which shows people what they can say.

00:33:50.820 --> 00:33:55.620
Explain about calibrating,
the way I just explained it to you.

00:33:55.620 --> 00:33:57.110
And when you go back to your hotel
rooms tonight to try out the speech,

00:33:57.110 --> 00:33:57.110
what's the first thing
you're going to do?

00:33:57.710 --> 00:34:02.320
Give them examples of how to speak.

00:34:02.320 --> 00:34:05.770
For example,
ship an AIFF file recording of you

00:34:06.190 --> 00:34:10.250
saying something to your application
so they hear the style of speech,

00:34:10.370 --> 00:34:13.560
so they know that they
shouldn't pause between words.

00:34:13.560 --> 00:34:18.890
They shouldn't shout at the computer.

00:34:18.890 --> 00:34:20.190
They shouldn't mumble.

00:34:20.190 --> 00:34:20.190
They shouldn't over-articulate.

00:34:20.330 --> 00:34:22.980
If you want some guidelines,
look at the helpful tips in the

00:34:23.000 --> 00:34:24.640
speech preferences for what we say.

00:34:24.640 --> 00:34:27.970
Make users aware of background noises.

00:34:28.030 --> 00:34:30.050
Often people say to me,
the speech recognition

00:34:30.530 --> 00:34:31.720
wasn't working for me.

00:34:31.720 --> 00:34:34.240
And when I look into why, well,
they have the microphone

00:34:34.240 --> 00:34:35.320
listening all the time.

00:34:35.320 --> 00:34:38.540
And they're using speech recognition.

00:34:38.540 --> 00:34:40.840
Well, somebody comes into the room,
tells them a joke.

00:34:40.900 --> 00:34:43.880
The computer thinks it
hears the other person,

00:34:43.880 --> 00:34:45.010
responds to it.

00:34:45.110 --> 00:34:46.160
They both start laughing.

00:34:46.160 --> 00:34:47.530
There's overlapped speech going on.

00:34:47.540 --> 00:34:48.740
And then they say,
the thing doesn't work.

00:34:49.420 --> 00:34:51.090
Make people aware of background noises.

00:34:51.100 --> 00:34:55.120
And in the context of doing that,
help your listeners to know

00:34:55.120 --> 00:34:57.550
when they should be considering
using a head-mounted microphone.

00:34:57.560 --> 00:35:02.110
Such as, if you have an application to
be used in a warehouse where

00:35:02.170 --> 00:35:06.050
there's a lot of machinery around,
you might want your users to wear a

00:35:06.120 --> 00:35:07.720
head-mounted microphone in that case.

00:35:09.530 --> 00:35:15.850
There are two listening modes:
Push-to-Talk and Continuous Listening.

00:35:15.860 --> 00:35:20.660
Push-to-Talk is the
mode that I was using,

00:35:20.660 --> 00:35:20.660
where it's not listening
unless you press a hotkey.

00:35:20.890 --> 00:35:24.700
That addresses the following problem:
that speech recognisers are great

00:35:24.950 --> 00:35:28.660
at recognising what they're supposed
to recognise but terrible at knowing

00:35:28.660 --> 00:35:31.460
when you're not talking to them.

00:35:31.460 --> 00:35:34.760
And so in situations like this,
where I'm doing a demo,

00:35:35.180 --> 00:35:38.590
99% of the words that I say are
not directed to the computer and

00:35:38.600 --> 00:35:40.500
so I have it in push to talk mode.

00:35:40.500 --> 00:35:44.460
You can tell it to listen
continuously and if you do,

00:35:44.460 --> 00:35:48.620
then it will require a key word
before each spoken command.

00:35:48.620 --> 00:35:51.230
You can even turn that key word
off and then the microphone

00:35:51.240 --> 00:35:52.660
is listening all the time.

00:35:52.660 --> 00:35:53.950
Very dangerous.

00:35:53.990 --> 00:35:58.370
If you're in your office by yourself,
that will work quite well until the phone

00:35:58.470 --> 00:36:02.940
rings and you have a conversation on the
telephone and then it's dangerous again.

00:36:02.940 --> 00:36:05.720
So educate your listeners
about the costs as well as the

00:36:05.720 --> 00:36:07.600
benefits of continuous listening.

00:36:08.830 --> 00:36:11.680
And give them some guidance
about non-native speakers.

00:36:11.680 --> 00:36:17.730
We have trained the speech
recognizer on 750 speakers of

00:36:17.730 --> 00:36:19.680
varieties of North American English.

00:36:19.700 --> 00:36:21.950
Including a few non-native
speakers in there.

00:36:21.960 --> 00:36:25.420
Because we're doing statistical
modeling of the acoustics of

00:36:25.480 --> 00:36:27.550
speech in Hidden Markov models.

00:36:27.560 --> 00:36:30.500
That means there's some
forgiveness in the recognizer.

00:36:30.500 --> 00:36:32.250
So as you can hear, I'm Australian.

00:36:32.260 --> 00:36:36.200
In my group,
Jia is a native Chinese speaker.

00:36:36.980 --> 00:36:39.640
Matthias is a native
speaker of Swiss German.

00:36:39.640 --> 00:36:41.500
Jerome's a native French speaker.

00:36:41.500 --> 00:36:45.840
Devang is a native
Hindi and Gujarati speaker.

00:36:45.840 --> 00:36:48.800
Heavens, Kevin Aitken's from Oregon.

00:36:51.290 --> 00:36:52.960
And it understands all of us.

00:36:52.960 --> 00:36:54.830
So there is some
forgiveness in the models.

00:36:55.680 --> 00:37:01.860
Nevertheless,
let your users know that the

00:37:01.910 --> 00:37:06.230
further their English is from
North American adult English,

00:37:06.230 --> 00:37:06.230
the more chance there is that
the recogniser might trip up.

00:37:07.700 --> 00:37:11.190
So, we've talked a lot about speech
synthesis and speech recognition.

00:37:11.190 --> 00:37:15.590
I'd like to hand over to Kevin Aiitken,
one of our senior engineers,

00:37:15.740 --> 00:37:20.390
who will tell you about how to put
this into your own applications.

00:37:20.390 --> 00:37:20.390
Kevin?

00:37:24.960 --> 00:37:25.770
Good morning.

00:37:25.840 --> 00:37:28.400
As Kim said, I'm Kevin Aiitken.

00:37:28.510 --> 00:37:33.200
So, what I'm going to do is dive right
into some of the programming details.

00:37:33.270 --> 00:37:37.060
So, that's why I'm here.

00:37:37.060 --> 00:37:42.650
First, I'm going to start talking
about speech recognition,

00:37:42.650 --> 00:37:42.650
and then I'm going to talk about
the APIs for speech synthesis.

00:37:42.900 --> 00:37:45.860
So let's start with
accessing speech recognition.

00:37:45.920 --> 00:37:50.560
So there are four main ways that you can
access our speech recognition engine.

00:37:50.560 --> 00:37:53.190
And I go through each one of those,
giving you some ideas of

00:37:53.320 --> 00:37:55.210
what the API looks like.

00:37:55.340 --> 00:37:59.260
So if you're writing with AppleScript,
we have two commands.

00:37:59.260 --> 00:38:01.240
The first one is the listen for command.

00:38:01.460 --> 00:38:03.570
It's great for a simple Q&A.

00:38:03.570 --> 00:38:07.670
You give it a list of
commands listened for.

00:38:07.780 --> 00:38:10.390
It starts recognizing
once it's heard something,

00:38:10.390 --> 00:38:13.630
or it's optional timeout,
stops listening,

00:38:13.660 --> 00:38:17.580
and then you can take the
result and do something with it.

00:38:17.870 --> 00:38:20.550
If you need a little more flexibility,
you can use the listen

00:38:20.550 --> 00:38:22.800
continuously for command.

00:38:22.890 --> 00:38:25.720
Unlike the other command,
it continues to listen even

00:38:25.720 --> 00:38:27.240
after it's heard something.

00:38:27.270 --> 00:38:32.180
That way, you can update the commands
depending on what you want to do.

00:38:32.410 --> 00:38:37.070
And then once you're finished listening,
you can just call stop listening.

00:38:38.240 --> 00:38:41.510
So now Kim gave you an
overview of Speakable Items,

00:38:41.620 --> 00:38:44.850
demoed what it looks like to the user,
and then he also delved into

00:38:44.850 --> 00:38:46.680
the Speakable Items folder.

00:38:46.900 --> 00:38:50.890
And so he showed you what an item is.

00:38:50.940 --> 00:38:54.900
If you have a Scriptable application,
you can use Apple script files.

00:38:54.900 --> 00:38:57.140
That's really great.

00:38:57.180 --> 00:39:01.320
Otherwise you can use keyboard command
files to map a keyboard shortcut

00:39:01.320 --> 00:39:03.740
to a particular spoken command.

00:39:03.770 --> 00:39:07.590
And you can even create many little
applications for your spoken commands

00:39:07.590 --> 00:39:11.740
that can communicate with your
application in whatever way you want.

00:39:11.740 --> 00:39:14.920
The simplest way to get started
is just to embed those items

00:39:14.930 --> 00:39:17.140
inside your application's bundle.

00:39:17.140 --> 00:39:20.760
You just put them in a folder
inside the resources directory,

00:39:20.760 --> 00:39:25.320
set a key in your Info.plist,
and when Speakable Items is running,

00:39:25.350 --> 00:39:29.320
it finds that in your application
and puts those commands in a list.

00:39:29.320 --> 00:39:32.170
Or if you want to give the user
just a little more flexibility

00:39:32.170 --> 00:39:36.240
to rename and delete your items,
you can actually install those

00:39:36.310 --> 00:39:40.720
into the user speak volume
folder that Kim showed you.

00:39:42.560 --> 00:39:45.190
If you're running a Cocoa application,
we have a great class

00:39:45.190 --> 00:39:47.030
called NSSpeechRecognizr.

00:39:47.040 --> 00:39:50.300
It's designed to be for fast,
easy implementation

00:39:50.300 --> 00:39:51.980
of speech recognition.

00:39:52.020 --> 00:39:56.890
It has a number of ways that
you can change what it's

00:39:56.890 --> 00:40:00.300
listening for as it's running.

00:40:00.300 --> 00:40:04.300
So, I'm going to give you a little bit of
code as an example of what it looks like.

00:40:04.380 --> 00:40:07.480
But let's say you're
running a game program.

00:40:07.480 --> 00:40:08.300
It's a maze.

00:40:09.390 --> 00:40:12.870
The user can move in four directions
to move their little token from

00:40:12.870 --> 00:40:14.260
one side of the maze to the other.

00:40:14.260 --> 00:40:19.610
And so you've set it up so they
use the keypad or the arrow keys.

00:40:19.620 --> 00:40:21.550
And then you go to a talk
like this and you go,

00:40:21.630 --> 00:40:25.740
wow, you know, I can have the user say
one of those directions.

00:40:25.740 --> 00:40:27.270
So, what might the code look like?

00:40:29.090 --> 00:40:35.490
So we're going to start off by
instantiating a speech recognizer.

00:40:35.490 --> 00:40:39.270
And then we're going to set the
delegate to an object that you want

00:40:39.270 --> 00:40:43.390
to receive the message of when one
of those commands is recognized.

00:40:44.040 --> 00:40:45.860
Then we're going to tell the
recognizer what to listen for.

00:40:45.860 --> 00:40:47.960
In this case,
it's just an array of strings.

00:40:47.960 --> 00:40:51.220
Each one of those strings is one of
the directions that you specified.

00:40:51.220 --> 00:40:54.250
And then finally,
we're going to start listening.

00:40:54.260 --> 00:41:00.180
So now the user is using your maze,
having fun, making way to the end.

00:41:00.180 --> 00:41:02.890
And so they say one of those commands.

00:41:02.900 --> 00:41:09.050
And so your delegate message method,
delegate object, is going to get the did

00:41:09.110 --> 00:41:13.380
recognize command message along
with a string that it heard.

00:41:13.620 --> 00:41:17.330
And then what you can do is you can
just easily compare that to one of the

00:41:17.390 --> 00:41:19.930
known directions and move accordingly.

00:41:19.940 --> 00:41:24.020
So that's a really simple
example of a fictitious program.

00:41:24.020 --> 00:41:28.790
What I'd like to do now is show
you a real cool application that

00:41:28.950 --> 00:41:33.240
a developer has used this API in
order to enhance with speech.

00:41:33.240 --> 00:41:37.500
So what I'd like to do
is bring up Will Shipley,

00:41:37.500 --> 00:41:43.150
CEO of Delicious Monster,
to give us a demo of that.

00:41:43.340 --> 00:41:44.440
Thank you.

00:41:49.610 --> 00:41:51.640
Hello.

00:41:51.660 --> 00:41:52.710
Thanks for coming out at 9:00.

00:41:52.850 --> 00:41:56.960
This is probably the only time
you'll ever see me before noon,

00:41:57.000 --> 00:41:58.100
so live it up.

00:41:58.100 --> 00:42:02.100
We just bought some books and
CDs to test this to show you guys

00:42:02.100 --> 00:42:04.260
that this is not a canned demo.

00:42:04.260 --> 00:42:07.620
If you guys want these,
see me after the session,

00:42:07.620 --> 00:42:11.380
because we don't really want
to take them back with us.

00:42:11.380 --> 00:42:12.260
Let's see.

00:42:12.260 --> 00:42:16.100
I need to change-- can I have
demo whatever it is thingy?

00:42:16.100 --> 00:42:17.500
I've always wanted to say that.

00:42:17.500 --> 00:42:17.500
That's so fun.

00:42:18.270 --> 00:42:20.130
The power, I'm going to be like,
could you switch it to

00:42:20.220 --> 00:42:21.160
the demo in the next room?

00:42:21.250 --> 00:42:23.310
Can you go back?

00:42:29.870 --> 00:42:31.800
I must use this only for good.

00:42:31.800 --> 00:42:36.710
Um... So I was instructed to, uh...

00:42:38.110 --> 00:42:41.200
Yeah, can I go back to demo again?

00:42:41.250 --> 00:42:45.230
I was instructed to calibrate
this before I use it.

00:42:45.340 --> 00:42:47.060
I had no idea about
this calibration stuff,

00:42:47.060 --> 00:42:49.470
and I put the voice
stuff in two years ago,

00:42:49.470 --> 00:42:51.680
so that tells you something.

00:42:51.770 --> 00:42:53.810
I don't know what.

00:42:53.990 --> 00:42:56.300
But it's probably something
really interesting.

00:42:56.360 --> 00:43:03.690
So I'm going to calibrate now,
which is really exciting for all of you.

00:43:03.690 --> 00:43:03.690
Actually, I think this is kind of
magic every time I do it.

00:43:03.690 --> 00:43:03.690
So there we go.

00:43:04.150 --> 00:43:05.800
What time is it?

00:43:05.860 --> 00:43:08.040
Quit this application.

00:43:08.040 --> 00:43:09.340
Open a document.

00:43:09.450 --> 00:43:11.300
Show me what to say.

00:43:11.350 --> 00:43:13.300
Make this page speakable.

00:43:13.340 --> 00:43:14.690
Move page down.

00:43:14.690 --> 00:43:16.740
Hide this application.

00:43:16.850 --> 00:43:19.140
Switch to Finder.

00:43:19.490 --> 00:43:20.240
That was pretty neat.

00:43:20.240 --> 00:43:23.070
That was 100%. I mean, I don't know.

00:43:23.100 --> 00:43:24.640
I just got up here, I set it up.

00:43:24.640 --> 00:43:28.480
I'm just like,
I find that completely magic.

00:43:29.070 --> 00:43:31.030
Okay, so here's the point where I'm
going to do something which

00:43:31.060 --> 00:43:32.960
you're never supposed to do,
which is I have not tested these.

00:43:32.960 --> 00:43:36.170
But I was told to show
the app a little bit.

00:43:36.180 --> 00:43:37.510
I don't want to turn this
into an ad for my app,

00:43:37.620 --> 00:43:40.240
because you guys really don't want to be
sitting here paying to watch me do ads.

00:43:40.240 --> 00:43:46.050
But the basic idea of the app is this
gives you a physical catalog or a virtual

00:43:46.190 --> 00:43:49.300
catalog of all your physical stuff.

00:43:49.370 --> 00:43:51.300
So it's sort of like iTunes
for your physical items.

00:43:51.360 --> 00:43:53.960
It doesn't do your electronic items,
and it doesn't try to actually

00:43:53.990 --> 00:43:55.300
have the content of the items.

00:43:55.320 --> 00:43:57.840
It's just like a card
catalog into those items.

00:43:58.540 --> 00:44:00.850
So you can catalog the books that are
on your shelf and the CDs that are

00:44:00.850 --> 00:44:02.900
on your shelf and your video games
and your blah-biddy-blah-biddy-blue.

00:44:02.900 --> 00:44:06.700
The cool thing about it is these
apps have existed for 30 years.

00:44:06.700 --> 00:44:10.090
It's all really we all wanted to do
with computers is catalog our crap.

00:44:10.320 --> 00:44:13.890
The cool thing about it is this
is really easy to get it in.

00:44:13.900 --> 00:44:15.450
So what I do is it scans the barcode.

00:44:15.490 --> 00:44:17.590
So I'm going to show you the
first part of voice feedback,

00:44:17.590 --> 00:44:19.030
assuming this machine is mic'd up.

00:44:19.050 --> 00:44:20.440
Hopefully the audio is on this too.

00:44:20.440 --> 00:44:23.430
So I'm going to pop up
the iSight camera on this,

00:44:23.430 --> 00:44:25.100
point it at this barcode.

00:44:25.100 --> 00:44:26.590
And please, please, please, please.

00:44:35.800 --> 00:44:39.460
Now I think today we've all learned a
valuable lesson about licensing software.

00:44:39.460 --> 00:44:45.040
Stealing is wrong, and I want you to take
that home with you.

00:44:45.040 --> 00:44:48.510
It's not something you want to do.

00:44:48.510 --> 00:44:56.240
So what I'm going to do,
and this is actually really teaching me a

00:44:56.240 --> 00:44:56.240
lot about how I should ship the program.

00:44:56.240 --> 00:44:56.240
What I'm going to do is go ahead and

00:44:56.240 --> 00:45:00.190
I'm going to delete a bunch of items
so that I'm under the 25 item limit.

00:45:00.200 --> 00:45:04.620
But you saw how fast that would
have worked if it had worked.

00:45:04.620 --> 00:45:05.130
So here we are.

00:45:05.210 --> 00:45:07.940
This is the barcode.

00:45:07.940 --> 00:45:11.410
Hold it up to the eyesight.

00:45:11.410 --> 00:45:13.140
Scans it in.

00:45:13.140 --> 00:45:16.740
I can go on, do other items.

00:45:16.740 --> 00:45:18.270
Look, I failed.

00:45:18.270 --> 00:45:18.270
Is this on the net?

00:45:18.270 --> 00:45:18.270
It's really slow.

00:45:18.270 --> 00:45:18.270
I see.

00:45:18.270 --> 00:45:18.270
Wait.

00:45:20.370 --> 00:45:22.180
Me and my gang.

00:45:22.200 --> 00:45:23.120
All right, so there's that.

00:45:23.120 --> 00:45:25.300
Did that.

00:45:25.370 --> 00:45:26.480
Mm-hmm.

00:45:26.530 --> 00:45:28.410
Mm-hmm.

00:45:28.450 --> 00:45:30.170
Yes, we're not going to go over that now.

00:45:30.410 --> 00:45:32.770
This is why you never do demos on
items that you haven't actually

00:45:32.770 --> 00:45:34.940
checked in the lighting conditions
that you're going to do them in there.

00:45:35.000 --> 00:45:40.790
Game of Shadows, Barry Bonds, BLSU,
and the steroid scandal that

00:45:40.790 --> 00:45:42.310
rocked professional sports.

00:45:42.320 --> 00:45:43.980
All right, so that's scanning items in.

00:45:43.980 --> 00:45:46.570
And you can see I'm using the feedback
there to read out the item title,

00:45:46.570 --> 00:45:48.260
which seems kind of
neat and kind of magic.

00:45:48.310 --> 00:45:51.300
And the big point behind that was
I did want to make it seem magic.

00:45:51.300 --> 00:45:53.600
I wanted for the user to
understand what they did,

00:45:53.600 --> 00:45:55.910
because just the beep,
and then it would take a

00:45:55.910 --> 00:45:56.880
little while for it to load in.

00:45:56.880 --> 00:45:58.020
And they weren't really
sure what had happened.

00:45:58.020 --> 00:45:59.500
And they'd usually moved
on to another item,

00:45:59.500 --> 00:46:02.200
because it's not threaded,
as you may have seen.

00:46:02.200 --> 00:46:05.200
I was actually able to read in other
barcodes while it was looking up.

00:46:05.240 --> 00:46:06.040
And so you get behind.

00:46:06.040 --> 00:46:08.660
And so this isn't just
like just adding flash.

00:46:08.690 --> 00:46:10.780
It actually adds something useful,
which is if you're sitting

00:46:10.780 --> 00:46:13.750
there and you go beep,
beep, beep, beep, and then it fails,

00:46:13.800 --> 00:46:14.700
it says look up fail.

00:46:14.700 --> 00:46:17.120
And so you'd hear, oh, Lost Lake,
and then look up fail.

00:46:17.120 --> 00:46:17.920
And you go, oh, Lost Lake.

00:46:17.920 --> 00:46:18.050
Oh.

00:46:18.220 --> 00:46:18.960
This one didn't work.

00:46:19.040 --> 00:46:20.240
I better type it in by hand.

00:46:20.290 --> 00:46:21.460
So we're not just talking about flash.

00:46:21.480 --> 00:46:23.810
We're talking about actual functionality
that's enabled by speech when

00:46:23.810 --> 00:46:25.600
someone's not looking at the screen.

00:46:25.640 --> 00:46:29.190
And similarly, you can actually look
up things by title here.

00:46:29.200 --> 00:46:32.610
And I'll show this.

00:46:33.010 --> 00:46:34.160
"Was I supposed to do
something before this?

00:46:34.260 --> 00:46:35.230
No, not.

00:46:35.590 --> 00:46:37.450
So I'm going to hold down
escape and I'm going to just

00:46:37.450 --> 00:46:38.700
say the name of one of these.

00:46:38.940 --> 00:46:42.400
Mario Party 5." Mario Party 5.

00:46:42.400 --> 00:46:46.400
"Grand Theft Auto:
Vice City." Grand Theft Auto: Vice City.

00:46:46.400 --> 00:46:48.350
"So you can see it's just
selecting the item that I say.

00:46:48.470 --> 00:46:50.480
Now that's really cool because
we actually tested this,

00:46:50.580 --> 00:46:52.400
and you can actually be,
and they don't guarantee this,

00:46:52.400 --> 00:46:54.290
so you know, this is in Apple words.

00:46:54.500 --> 00:46:57.300
You can actually be like 30
feet away from a microphone in

00:46:57.300 --> 00:47:00.360
one of these machines and say
fairly clearly in a relatively

00:47:00.360 --> 00:47:02.400
quiet environment what you want,
and it'll get it.

00:47:02.450 --> 00:47:04.990
So you could actually have
this continuous listen and

00:47:05.000 --> 00:47:08.400
be in your library and say,
'Oh, did I scan in Mario Party?'

00:47:08.400 --> 00:47:10.560
And the thing will go,
'Mario Party?' And you're like, 'Oh,

00:47:10.570 --> 00:47:12.610
yeah, I got that one.' And so you can
just read off your bookshelf,

00:47:12.610 --> 00:47:13.360
and it actually works.

00:47:13.500 --> 00:47:15.400
It's really, really cool.

00:47:15.560 --> 00:47:18.490
Something I just discovered
when I was doing all this,

00:47:18.490 --> 00:47:22.400
when they were showing it to me, whoops,
there's the source code for it.

00:47:22.480 --> 00:47:23.480
Well,
I'm going to show you the source code

00:47:23.480 --> 00:47:24.400
so it's not going to be too long.

00:47:24.400 --> 00:47:25.400
It's not that bad.

00:47:25.400 --> 00:47:28.400
Did anybody notice the
crasher in the code earlier?

00:47:28.560 --> 00:47:29.400
No one?

00:47:29.410 --> 00:47:30.400
He was showing Cocoa code.

00:47:30.400 --> 00:47:31.400
Anyone see the crasher he did?

00:47:31.400 --> 00:47:32.400
What was it?

00:47:32.400 --> 00:47:36.990
He didn't nil terminate his array
when he said array with objects.

00:47:40.060 --> 00:47:43.500
So one of the things I discovered is, oh,
Speakable Items on/off.

00:47:43.500 --> 00:47:45.130
That's supposed to turn it on.

00:47:45.130 --> 00:47:48.780
So now it's on, which it was before,
but I'm pretending it wasn't.

00:47:48.860 --> 00:47:52.760
So yesterday, he's going through this.

00:47:52.760 --> 00:47:55.740
I just got out of this session.

00:47:55.740 --> 00:47:57.400
That's why this is so random.

00:47:57.400 --> 00:47:57.400
Yesterday,
we were going through this with Kim,

00:47:57.400 --> 00:47:57.400
and he's showing me the Speakable Items.

00:47:57.400 --> 00:47:57.400
Where's the other thing?

00:48:02.880 --> 00:48:04.410
He was showing me this,
and as you can see here,

00:48:04.420 --> 00:48:05.810
let me see if I can do this little trick.

00:48:05.850 --> 00:48:06.260
Isn't that neat?

00:48:06.280 --> 00:48:09.700
All these things that are
just coming from my app for

00:48:09.820 --> 00:48:10.840
free because it's a Cocoa app.

00:48:10.940 --> 00:48:13.950
Now, I didn't program these,
and it really freaked me out because,

00:48:14.010 --> 00:48:17.080
I mean, you can see things like open
page on Amazon's with this title,

00:48:17.080 --> 00:48:19.100
which I didn't add.

00:48:19.120 --> 00:48:23.560
I mean, I added it to my app, you know,
as a menu item, but I didn't add that

00:48:23.560 --> 00:48:24.320
as a speakable item.

00:48:24.320 --> 00:48:27.510
But it turns out in Cocoa,
you just get your buttons,

00:48:27.520 --> 00:48:31.320
the titles or the labels actually
get used as speakable items for free.

00:48:32.740 --> 00:48:33.550
Which is really amazing.

00:48:33.560 --> 00:48:37.480
So our apps are actually already more
speakable or unspeakable in some cases.

00:48:39.260 --> 00:48:51.650
Then we thought, so for example,
I'll actually do this and I'll say, "Hey,

00:48:51.650 --> 00:48:52.310
uh, my info." My info.

00:48:52.310 --> 00:48:52.310
And it switches to my info tab.

00:48:52.310 --> 00:48:52.310
Details.

00:48:52.310 --> 00:48:52.310
Details.

00:48:52.310 --> 00:48:52.310
Similar.

00:48:52.310 --> 00:48:52.310
Similar.

00:48:53.040 --> 00:48:54.700
I forgot what that command was now,
sorry.

00:48:54.840 --> 00:48:57.500
I was going to do the show info,
blah blah blah blah blah blah blah.

00:48:57.650 --> 00:48:58.150
Yes.

00:48:58.160 --> 00:49:01.900
View other formats on Amazon.com.

00:49:01.900 --> 00:49:05.350
I probably said dot wrong.

00:49:06.990 --> 00:49:08.450
Oh, I'm looking at the wrong one.

00:49:08.560 --> 00:49:10.890
Yeah.

00:49:10.970 --> 00:49:12.970
What did I do with it?

00:49:14.200 --> 00:49:15.800
Speech Commands Window.

00:49:15.960 --> 00:49:17.580
Right, right,
that Speech Commands Window.

00:49:17.640 --> 00:49:27.380
Oh, oh, oh, yeah,
I got it from a different place.

00:49:27.380 --> 00:49:27.380
That's why we didn't see that.

00:49:27.380 --> 00:49:27.380
Toggle EyeSight Monitor.

00:49:27.380 --> 00:49:27.380
Toggle EyeSight Monitor.

00:49:28.620 --> 00:49:31.200
Open page on Amazon on
books with this author.

00:49:31.460 --> 00:49:35.000
Open page on Amazon on
books with this author.

00:49:35.260 --> 00:49:37.330
So that's pretty cool.

00:49:40.870 --> 00:49:45.650
Now the big story here is I've always
been a skeptic on speech technologies

00:49:45.650 --> 00:49:48.020
and with apologies to the people
who actually wrote all this stuff.

00:49:48.150 --> 00:49:51.880
I've always been a huge skeptic
and I think a lot of people are.

00:49:51.880 --> 00:49:54.900
I think a lot of people think, you know,
well, that's not really what I'm

00:49:55.040 --> 00:49:57.650
going to do with it when you
see demos where you're like,

00:49:57.710 --> 00:50:00.610
move up a pixel, move up another pixel,
move up, oh, damn it,

00:50:00.610 --> 00:50:01.870
I'm just going to use the mouse,
you know?

00:50:01.880 --> 00:50:06.460
And I think the story is we need to
start thinking of this as a way to do

00:50:06.460 --> 00:50:11.110
hands-free input when your hands are
doing something else and we need to

00:50:11.110 --> 00:50:15.680
think about doing output feedback when
your eyes are doing something else.

00:50:15.680 --> 00:50:18.770
And the example Kim gave was an
awesome one where the computer says,

00:50:18.770 --> 00:50:20.020
hey, I just came unplugged.

00:50:20.140 --> 00:50:22.480
How great would it be if you
had a server machine and when

00:50:22.480 --> 00:50:25.700
you unplugged that server,
it said, hey, hey, I'm unplugged,

00:50:25.710 --> 00:50:28.840
you know, you unplug the network,
I'm not, you know,

00:50:28.840 --> 00:50:30.140
I'm not serving web pages anymore.

00:50:30.140 --> 00:50:31.360
Hey, hey, and it just sat there.

00:50:31.600 --> 00:50:32.550
Hey, hey, hey.

00:50:32.560 --> 00:50:34.260
That'd be good feedback, right?

00:50:34.260 --> 00:50:35.300
I could really use that.

00:50:35.300 --> 00:50:36.060
I'd save a lot of money.

00:50:36.920 --> 00:50:38.020
And I see my time is up.

00:50:38.110 --> 00:50:41.440
So, yeah, so in conclusion,
I think this is really great technology.

00:50:41.440 --> 00:50:43.720
I hope we get a lot more APIs in Cocoa.

00:50:43.800 --> 00:50:44.940
Please, please, please, please, please.

00:50:44.940 --> 00:50:46.470
And I hope you all use it.

00:50:46.540 --> 00:50:46.740
Thanks.

00:50:52.000 --> 00:50:54.000
Thanks a lot.

00:50:54.210 --> 00:50:55.970
Okay, slides.

00:50:56.000 --> 00:50:57.920
Slides once again.

00:50:58.040 --> 00:51:00.000
Alright.

00:51:00.450 --> 00:51:04.000
Thanks a lot, Wil, and especially for
debugging our demo code.

00:51:04.010 --> 00:51:10.000
That's what we get for not
compiling and writing our demo code.

00:51:10.030 --> 00:51:12.250
Okay,
so if you need more functionality than

00:51:12.250 --> 00:51:15.290
what we provide with the Cocoa API,
you can use the

00:51:15.380 --> 00:51:17.000
Carbon Speech Recognition API.

00:51:17.000 --> 00:51:21.000
It gives you full access to
the speech recognition engine,

00:51:21.000 --> 00:51:25.000
access to a very powerful way of
defining what it should listen for,

00:51:25.000 --> 00:51:28.000
and a little bit of control
over the user interaction.

00:51:28.000 --> 00:51:31.800
But because we give you all that power

00:51:32.380 --> 00:51:34.760
to define what it's going to listen for.

00:51:34.760 --> 00:51:36.540
You need to be careful.

00:51:36.540 --> 00:51:40.240
So in the case of chess,
it's easy to just say, oh, well,

00:51:40.240 --> 00:51:43.040
that's just a piece followed
by a square followed by the

00:51:43.120 --> 00:51:44.740
word two followed by a square.

00:51:44.740 --> 00:51:49.840
Well, if you multiply that all out,
you've got over 24,000 spoken commands.

00:51:50.170 --> 00:51:53.780
Well, the message here is constrain
your language model and listen

00:51:53.870 --> 00:51:55.320
only for what's appropriate.

00:51:55.320 --> 00:51:59.000
So that improves accuracy because
we're not listening for all those

00:51:59.290 --> 00:52:01.110
invalid commands in the case of chess.

00:52:01.940 --> 00:52:04.220
But, you know,
I'll leave a few alternative phrasings in

00:52:04.220 --> 00:52:06.980
there just to make it easy on the user.

00:52:06.980 --> 00:52:11.650
So a language model, again,
is just a way of telling the recognition

00:52:11.650 --> 00:52:13.820
system what it should listen for.

00:52:13.820 --> 00:52:17.400
So one way we might define the
language model is we might have

00:52:17.420 --> 00:52:22.160
a set of branches for each one
of the piece types under that,

00:52:22.160 --> 00:52:23.980
and we have the valid
moves at that moment.

00:52:23.980 --> 00:52:27.740
As the user is playing the chess game,
we're going to update this

00:52:27.740 --> 00:52:28.760
so it's always correct.

00:52:28.840 --> 00:52:32.820
So what we do is we give this to the
speech recognition engine and it searches

00:52:32.830 --> 00:52:36.610
through trying to find the best match,
and then once it does,

00:52:36.660 --> 00:52:39.680
it's going to make a copy of
that original language model

00:52:39.680 --> 00:52:42.680
and hand that back to you,
trimming away everything

00:52:42.680 --> 00:52:45.320
that wasn't valid,
just the valid portion.

00:52:45.320 --> 00:52:50.030
And then you're going to take that and
then map that onto a particular move.

00:52:50.040 --> 00:52:54.460
So as far as just a summary of how
you use speech recognition API,

00:52:54.460 --> 00:52:58.840
you're going to create a recognition
system and a recognizer object,

00:52:58.970 --> 00:53:02.000
set up your callback routines,
set up the language model,

00:53:02.000 --> 00:53:03.920
and begin listening.

00:53:03.920 --> 00:53:07.500
And then finally,
as those commands come through,

00:53:07.500 --> 00:53:09.220
then you're going to handle
the recognition result.

00:53:09.260 --> 00:53:11.790
Let's talk about speech synthesis.

00:53:11.800 --> 00:53:12.620
Very similar.

00:53:12.620 --> 00:53:14.960
Four main ways to access it.

00:53:15.020 --> 00:53:17.300
AppleScript, we have the say command.

00:53:17.300 --> 00:53:19.540
Here are a couple of examples.

00:53:19.540 --> 00:53:20.940
You can just say a string.

00:53:20.940 --> 00:53:24.720
You can say it using a specific voice
if you want perhaps a female voice.

00:53:24.800 --> 00:53:28.340
You can even, let's say,
convert some of your news articles

00:53:28.340 --> 00:53:31.800
into a podcast by actually
saving it to an AIFF5 that file,

00:53:31.800 --> 00:53:33.890
throw it on your iPod.

00:53:34.320 --> 00:53:36.900
We also have a Say command line tool.

00:53:36.900 --> 00:53:41.940
Similar, you can just say a string,
say it with a particular voice,

00:53:42.020 --> 00:53:43.750
and save it off in a file.

00:53:44.170 --> 00:53:48.040
One thing Kim loves to do is if you've
got a long compile or something,

00:53:48.110 --> 00:53:52.000
you put that command, and then you follow
it by the Say command.

00:53:52.030 --> 00:53:56.150
And that way, he can put it off,
move the terminal to the background,

00:53:56.540 --> 00:54:00.410
answer some emails from his team,
and then he hears the computer say,

00:54:00.510 --> 00:54:02.990
your compile is finished,
or whatever voice it uses.

00:54:03.590 --> 00:54:08.360
If you're using Cocoa,
just like with speech recognition,

00:54:08.460 --> 00:54:10.490
we have a class for that.

00:54:10.490 --> 00:54:14.150
It allows you to do
asynchronous speaking.

00:54:14.150 --> 00:54:17.230
You have a number of notifications.

00:54:17.230 --> 00:54:21.080
You can do the bouncing
ball across the words.

00:54:21.080 --> 00:54:24.920
You can animate a mouth
to speak along with it.

00:54:24.920 --> 00:54:25.190
You have access to the voices,
and you can integrate it with the

00:54:25.190 --> 00:54:25.190
speech recognizer objects as well.

00:54:25.320 --> 00:54:26.930
So here's a little bit of an idea.

00:54:27.090 --> 00:54:29.200
Hopefully there won't
be any bugs in this one.

00:54:29.200 --> 00:54:34.220
Instantiate the synthesizer,
set the delegate if you want

00:54:34.220 --> 00:54:38.640
to get those notifications,
and then you just start

00:54:38.640 --> 00:54:40.590
speaking the string.

00:54:40.680 --> 00:54:45.190
And if you've signed up for
one of the notifications,

00:54:45.190 --> 00:54:47.790
such as the "Did
Finish Speaking" message,

00:54:47.790 --> 00:54:47.790
you'll get that,
so you can update your UI or

00:54:47.790 --> 00:54:47.790
whatever you want to do.

00:54:48.170 --> 00:54:52.700
So we also have a Carbon version
of the speech synthesis API.

00:54:53.100 --> 00:54:55.730
That allows you full
access to the synthesizer.

00:54:55.760 --> 00:54:57.780
Oops, let's go back.

00:54:57.780 --> 00:55:02.340
Direct access to the synthesizer,
so you can set and get properties.

00:55:02.340 --> 00:55:04.980
We have more notifications.

00:55:05.110 --> 00:55:10.950
And there's a few utility routines
for converting text into phonemes

00:55:11.000 --> 00:55:13.690
and support for custom dictionaries,
so you can fine-tune particular words.

00:55:14.750 --> 00:55:18.740
So like speech recognition,
it follows a general pattern

00:55:18.740 --> 00:55:22.930
of creating a speech channel,
setting a callback routine,

00:55:22.930 --> 00:55:27.110
setting any properties you need,
such as rate or pitch,

00:55:27.110 --> 00:55:30.820
and then you start speaking,
and then you handle any

00:55:30.820 --> 00:55:32.730
of those notifications.

00:55:32.760 --> 00:55:38.240
So that's just a summary of the APIs,
a lot more detail in the documentation,

00:55:38.270 --> 00:55:39.320
other areas.

00:55:39.320 --> 00:55:40.510
So with that, I'm going to let Kim sum up
and finish out the session.

00:55:43.600 --> 00:55:44.600
Thanks, Kim.

00:55:44.600 --> 00:55:50.890
So, in the last couple of minutes,

00:55:51.340 --> 00:55:55.260
To summarize,
you've seen the new speech synthesis,

00:55:55.270 --> 00:55:57.710
and you've got some guidelines
about how to use it,

00:55:57.720 --> 00:55:59.240
and speech recognition.

00:55:59.270 --> 00:56:02.500
Regarding that new speech synthesis,
this is a work in progress.

00:56:02.530 --> 00:56:04.480
We have a lot more work
that we want to do on it.

00:56:04.520 --> 00:56:06.970
So please, please, please help us out.

00:56:07.150 --> 00:56:08.280
Run it.

00:56:08.290 --> 00:56:09.860
Listen to things you don't like.

00:56:09.870 --> 00:56:12.040
And write bugs and send them to us.

00:56:12.050 --> 00:56:13.040
We need your help.

00:56:13.090 --> 00:56:16.970
We can't test all of the
texts that you'll be testing.

00:56:17.330 --> 00:56:20.730
And in particular,
make sure it works well in the kinds of

00:56:20.730 --> 00:56:23.370
strings that are in your applications.

00:56:23.400 --> 00:56:25.850
For speech recognition,

00:56:26.420 --> 00:56:30.680
We don't think there's a lot of value
in trying to use speech recognition

00:56:30.680 --> 00:56:32.900
to replace the mouse completely.

00:56:32.900 --> 00:56:36.660
The mouse allows you to point
at and click on an object on

00:56:36.680 --> 00:56:39.080
the screen in a single gesture.

00:56:39.080 --> 00:56:44.280
The value of speech recognition is for
things that you can't see to point to,

00:56:44.280 --> 00:56:45.340
to click on.

00:56:45.400 --> 00:56:48.170
If you have items within menus,
within submenus,

00:56:48.170 --> 00:56:51.340
within other submenus that
would scroll off the screen,

00:56:51.340 --> 00:56:53.670
speech recognition is a
good way to get to those.

00:56:54.540 --> 00:56:58.320
Consider at least adding keyboard
shortcuts to all of your buried items

00:56:58.400 --> 00:57:02.490
so that you can then ship speakable
items so that people can speak them.

00:57:02.520 --> 00:57:05.750
Look at other ways.

00:57:05.830 --> 00:57:09.570
You can maybe shift some scripts,
Apple scripts, for speakable items that

00:57:09.570 --> 00:57:12.840
control your commands,
or even better, call the API directly.

00:57:15.610 --> 00:57:19.730
We have more information.

00:57:19.820 --> 00:57:21.500
If you have any questions, don't call me.

00:57:21.500 --> 00:57:23.460
I'm terrible at answering email.

00:57:23.570 --> 00:57:27.780
Contact John Galenzi,
because he's good at

00:57:27.860 --> 00:57:31.920
getting back to people,
and he bugs me.

00:57:31.930 --> 00:57:35.530
There are some great examples of
code at developer examples speech.

00:57:35.530 --> 00:57:35.530
Download some of those.

00:57:35.530 --> 00:57:35.530
Those do compile, and they do run.

00:57:35.740 --> 00:57:39.550
and uh... we've documented all the
speech api speech recognition and

00:57:39.550 --> 00:57:45.170
speech synthesis we are holding a
lab session from eleven o'clock into

00:57:45.170 --> 00:57:49.420
one o'clock today we don't have time
for cook our public question answered

00:57:49.420 --> 00:57:53.970
right now but we'll uh... be hanging
around outside this room from the end

00:57:53.970 --> 00:57:58.570
of this uh... presentation including
kevin lindsoe kevin could you stand

00:57:58.960 --> 00:58:02.810
up please kevin lindsoe was the c_e_o_
founder and inspiration of casterly

00:58:02.810 --> 00:58:06.310
dot com and he's here to answer any
questions about his voices how to

00:58:06.310 --> 00:58:10.110
get them or the experience of putting
them to the mac so we'll be out the

00:58:10.140 --> 00:58:11.460
back thanks a lot thanks for coming
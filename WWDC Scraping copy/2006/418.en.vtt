WEBVTT

00:00:13.060 --> 00:00:14.350
Hello.

00:00:14.580 --> 00:00:18.750
Welcome to Kernel Tracing
Made Easy with DTrace.

00:00:20.070 --> 00:00:23.130
Today we're going to do a
short introduction to DTrace.

00:00:23.290 --> 00:00:24.830
We're going to learn what it is.

00:00:25.000 --> 00:00:28.900
We're going to learn a little bit
about the deprogramming language.

00:00:28.900 --> 00:00:31.900
I'll show you a sample script,
another sample script.

00:00:32.050 --> 00:00:34.900
We'll talk a little bit
about what works now.

00:00:35.080 --> 00:00:40.120
We'll talk a little bit about what's
not in the WWDC Leopard seed that

00:00:40.120 --> 00:00:41.900
you guys already have in your hands.

00:00:41.900 --> 00:00:46.130
And we'll talk a little bit about
what's going to be different.

00:00:47.950 --> 00:00:52.840
Anybody who attended Dave's talk
earlier this week saw this slide.

00:00:52.860 --> 00:00:55.800
This is DTrace being used by X-Ray.

00:00:55.800 --> 00:01:00.540
What we're going to talk
about is this part of things,

00:01:00.650 --> 00:01:03.030
just DTrace by itself.

00:01:04.250 --> 00:01:06.560
So what is DTrace?

00:01:06.560 --> 00:01:12.300
DTrace is an open source technology
and it came out of OpenSolaris.

00:01:12.300 --> 00:01:14.170
It was the first thing
OpenSolaris released.

00:01:14.170 --> 00:01:20.200
The D stands for dynamic,
so it's dynamic trace.

00:01:20.200 --> 00:01:26.760
It's usable for profiling, locating bugs,
exploring the operating system,

00:01:27.000 --> 00:01:29.200
just figuring out what's going on.

00:01:29.200 --> 00:01:32.340
There's no recompilation of
code necessary to use this

00:01:32.430 --> 00:01:37.950
tracing facility on the operating
system or on your own programs.

00:01:38.300 --> 00:01:42.480
You can trace more stuff, less stuff,
and you can drill down

00:01:42.480 --> 00:01:48.200
on problems iteratively,
again, without changing a line of code.

00:01:48.200 --> 00:01:52.200
There's near zero overhead
when it's not in use.

00:01:52.200 --> 00:01:58.200
So if you don't use it,
it doesn't cost you anything.

00:01:58.200 --> 00:02:02.190
For dynamic probes,
there's no overhead at all,

00:02:02.280 --> 00:02:04.790
unless you're using it.

00:02:05.280 --> 00:02:08.250
For static probes,
there's a tiny bit of overhead

00:02:08.250 --> 00:02:12.730
which is normally eaten by the
CPU instruction pipeline because

00:02:12.820 --> 00:02:19.200
it turns static probes into no ops,
and then replaces them with code when

00:02:19.200 --> 00:02:24.900
you turn them on and puts them back
to no ops when you turn them off.

00:02:25.350 --> 00:02:29.400
DTRACE is not here to
replace your debugger.

00:02:29.400 --> 00:02:31.700
You can't modify memory.

00:02:31.700 --> 00:02:34.100
You can't modify registers.

00:02:34.100 --> 00:02:38.450
You can't interpose functions,
so you can't change the arguments to a

00:02:38.490 --> 00:02:42.320
function or the results from a function.

00:02:42.320 --> 00:02:45.340
You can't call arbitrary functions.

00:02:45.340 --> 00:02:50.810
So if you had lock_debug in your
kernel and you wanted to run

00:02:50.950 --> 00:02:55.530
it like you would from a and it
would print out your lock list.

00:02:55.540 --> 00:02:56.440
You can't do that.

00:02:56.440 --> 00:03:01.070
D itself is not a Turing
complete language.

00:03:01.120 --> 00:03:07.410
And the simple way to explain
that is you can't write

00:03:07.410 --> 00:03:09.200
general purpose programs in it.

00:03:09.260 --> 00:03:12.520
But what it means to you
is there's no branching,

00:03:12.520 --> 00:03:16.370
so you can't jump backwards
and get into an infinite loop.

00:03:16.420 --> 00:03:20.700
There's no iteration,
so you can't blow a loop counter

00:03:20.700 --> 00:03:22.180
and get into an infinite loop.

00:03:22.800 --> 00:03:27.050
And there's no user functions,
so it's not possible to do

00:03:27.270 --> 00:03:31.150
recursion and either get into
an infinite loop or crash.

00:03:31.260 --> 00:03:34.610
But you can change the
timing a little bit.

00:03:34.680 --> 00:03:40.520
When you do probe functions,
you actually do end up

00:03:40.550 --> 00:03:44.580
executing code that you would
not have otherwise executed,

00:03:44.580 --> 00:03:49.050
and this can sometimes
result in timing changes.

00:03:49.060 --> 00:03:51.820
And you can use that to your
advantage if you want to trigger

00:03:51.820 --> 00:03:57.260
a timing change if something only
happens when the timing is off.

00:03:58.880 --> 00:04:01.560
The deprogramming language.

00:04:01.560 --> 00:04:04.770
The deprogramming language
has a C-like syntax.

00:04:04.860 --> 00:04:06.970
It's an event declarative language.

00:04:06.980 --> 00:04:10.500
That means it's very much like awk.

00:04:10.530 --> 00:04:12.190
I don't know if everybody's
familiar with awk.

00:04:12.300 --> 00:04:14.690
If you're a Unix head, you are.

00:04:14.850 --> 00:04:19.400
If you're not,
it's the weirdest thing ever.

00:04:19.720 --> 00:04:24.490
You can indicate an interest in
an event by creating a probe.

00:04:24.590 --> 00:04:31.490
And what happens when that
event goes is the probe fires.

00:04:31.490 --> 00:04:36.840
And then whether or not it actually
does anything or collects any

00:04:36.840 --> 00:04:39.600
information is based on a predicate.

00:04:39.600 --> 00:04:42.780
So actually when you
instrument a probe point,

00:04:42.930 --> 00:04:46.250
the probe is firing,
but you don't necessarily

00:04:46.250 --> 00:04:50.580
have any collection of data
unless the predicate is true.

00:04:50.590 --> 00:04:53.600
And it's basically like an if test.

00:04:53.600 --> 00:04:57.640
So you declare the probe, you say,
"Here's the probe,

00:04:57.640 --> 00:05:01.810
but only do it if this thing
happens." And of course the

00:05:01.940 --> 00:05:04.590
order of the probes is important.

00:05:04.880 --> 00:05:09.370
We can decode C, C++ data types.

00:05:09.600 --> 00:05:13.210
Actually, Objective-C as well,
with some of the work

00:05:13.330 --> 00:05:14.720
by the tools people.

00:05:14.720 --> 00:05:19.800
But they don't use the
compact type format for it.

00:05:19.800 --> 00:05:26.020
Compact type format is basically
massaged debugger information,

00:05:26.020 --> 00:05:31.800
which gets put into a separate section,
and then is used to allow

00:05:31.800 --> 00:05:37.800
you to know whether or not
something's a pointer or an int,

00:05:37.800 --> 00:05:41.740
and allow you to dereference
structure members.

00:05:41.790 --> 00:05:44.800
For example,
the contents of the proc structure.

00:05:44.800 --> 00:05:47.970
You want to look at p_com,
which is the command that happens

00:05:47.970 --> 00:05:49.800
to be running in that process.

00:05:49.800 --> 00:05:51.800
You can do that.

00:05:51.960 --> 00:05:54.800
It also supports speculative tracing.

00:05:54.800 --> 00:05:58.800
What speculative tracing does is it
lets you collect data on everything,

00:05:58.800 --> 00:06:03.790
and then if you decide after
you've collected the data,

00:06:03.900 --> 00:06:07.800
no, that's not what I was interested in.

00:06:07.800 --> 00:06:11.890
You can throw that away and only
show the data that shows the

00:06:11.970 --> 00:06:13.780
things that you're interested in.

00:06:13.820 --> 00:06:20.630
This is a little bit more powerful
than the windowed debugging in Shark,

00:06:20.630 --> 00:06:25.800
in that all you get back from
it is the events of interest,

00:06:26.000 --> 00:06:30.340
not all the events surrounding it.

00:06:30.790 --> 00:06:34.760
So, what's a D script?

00:06:35.100 --> 00:06:40.380
Well, if you're a Unix head,
then you'll recognize this as a

00:06:40.380 --> 00:06:43.040
back-of-snow grammar for a D script.

00:06:43.250 --> 00:06:48.700
But what it basically means is that
a D script is one or more clauses.

00:06:48.890 --> 00:06:55.360
A clause consists of a probe,
a predicate, and an action.

00:06:55.360 --> 00:06:59.690
The predicate is optional,
as you can see by the brackets.

00:06:59.710 --> 00:07:04.930
A probe itself consists of a provider,
a colon, a module name,

00:07:04.930 --> 00:07:11.300
which is optional, a colon,
a function name, which is optional,

00:07:11.600 --> 00:07:15.340
colon,
and then a name for the probe itself

00:07:15.610 --> 00:07:17.650
for the action that it's going to do.

00:07:17.770 --> 00:07:23.400
So, for example,
entry or return on a function.

00:07:23.400 --> 00:07:25.600
And I have a couple of examples here.

00:07:25.600 --> 00:07:31.790
The first example right there,
we're doing a system call probe.

00:07:31.790 --> 00:07:35.550
So, that matches system call.

00:07:35.820 --> 00:07:37.740
It matches any module.

00:07:37.740 --> 00:07:42.010
In our case,
the only one who implements system

00:07:42.150 --> 00:07:45.290
call probes is the kernel itself.

00:07:45.300 --> 00:07:49.340
That module name is mock_kernel.

00:07:49.340 --> 00:07:53.240
And then we get the close function.

00:07:53.240 --> 00:07:57.290
And when the close function returns,
then if self -- self is a

00:07:57.290 --> 00:07:59.360
reference to the thread.

00:07:59.380 --> 00:08:03.070
And if that's true,
then it sets it to false.

00:08:03.070 --> 00:08:07.990
This is basically the probe
we use to turn off tracing on

00:08:08.310 --> 00:08:11.320
the way out of a system call.

00:08:11.320 --> 00:08:17.420
This second example is
function boundary tracing.

00:08:17.420 --> 00:08:23.500
Function boundary tracing traces
entries into and out of functions.

00:08:23.880 --> 00:08:29.220
This particular one,
we're saying match only the Mach kernel.

00:08:29.220 --> 00:08:32.660
Actually,
you could put a KEXT name in there,

00:08:32.660 --> 00:08:35.980
although that won't
work in the WWDC seed.

00:08:35.980 --> 00:08:37.920
And then it doesn't care
what function it is.

00:08:38.020 --> 00:08:40.440
All we care about is the
entry to the function.

00:08:40.440 --> 00:08:45.100
And then, of course, just to be tidy,
I'm saying I'm not interested

00:08:45.100 --> 00:08:49.780
in tracing things which have
to do with Dtrace itself.

00:08:49.780 --> 00:08:52.340
So, if the executable name
is actually Dtrace,

00:08:52.340 --> 00:08:55.090
then I'm not going to trace it.

00:08:55.090 --> 00:08:59.140
And then what I do in my action
is -- and you'll get a little more

00:08:59.140 --> 00:09:03.990
information on this later -- is I have
an aggregate variable like calls.

00:09:04.210 --> 00:09:07.450
This is similar to a
Perl associative array.

00:09:07.560 --> 00:09:11.260
It's indexed by the executable name.

00:09:11.400 --> 00:09:16.420
And what it'll do is it'll count the
number of times that you enter into this.

00:09:16.420 --> 00:09:21.570
So, this particular example counts the
number of function call entries.

00:09:21.900 --> 00:09:26.960
"That happen within any given
executable over the entire time

00:09:27.060 --> 00:09:29.830
that the probe set is running."

00:09:30.070 --> 00:09:32.630
So let's start with the sample script.

00:09:32.660 --> 00:09:36.610
At the top,
there's the familiar pound bang

00:09:36.840 --> 00:09:40.370
that says this is a script.

00:09:40.630 --> 00:09:43.680
The executable name is UserSbinDTrace.

00:09:43.680 --> 00:09:47.700
That's the same location
as it is on OpenSolaris.

00:09:47.700 --> 00:09:49.580
The dash S says it's a script.

00:09:49.740 --> 00:09:52.870
So what we're going to do is
we're going to do the close

00:09:52.890 --> 00:09:54.400
entry instead of the exit.

00:09:54.400 --> 00:09:59.800
And when the touch program calls close,
because we use the predicate touch,

00:09:59.810 --> 00:10:02.210
we're going to begin tracing this thread.

00:10:02.420 --> 00:10:07.060
And the guard is a global variable which,
like basic,

00:10:07.060 --> 00:10:09.480
you declare it and start using it.

00:10:09.700 --> 00:10:29.000
[Transcript missing]

00:10:29.180 --> 00:10:33.420
When the close call returns,
we unmark the thread as traced.

00:10:33.530 --> 00:10:36.900
What this is basically going to do is
we're going to enter into the close call,

00:10:36.980 --> 00:10:40.780
we're going to see all of the
functions which happen in the kernel

00:10:40.780 --> 00:10:44.300
as a result of the close call,
and then we're going to

00:10:44.300 --> 00:10:46.120
see the close call exit.

00:10:46.880 --> 00:10:48.830
So, I have a demo.

00:10:48.960 --> 00:10:51.140
So, demo machine please.

00:10:51.140 --> 00:10:55.370
Demo please?

00:10:56.600 --> 00:11:19.500
[Transcript missing]

00:11:28.000 --> 00:11:31.320
Is this thing normally
running Leopard or not?

00:11:31.360 --> 00:11:32.280
Do we know?

00:11:32.310 --> 00:11:35.000
We probably don't know.

00:11:35.470 --> 00:11:42.200
Well, that's interesting.

00:11:50.000 --> 00:12:01.600
[Transcript missing]

00:12:01.820 --> 00:12:04.800
The DTrace output is the trace output.

00:12:04.800 --> 00:12:10.110
Maybe I can get Steve to come
up and boot this thing on the

00:12:10.110 --> 00:12:13.660
Leopard on the external hard drive,
unless it's running Leopard already.

00:12:13.800 --> 00:12:19.220
What you would have seen is
a column which indicated the

00:12:19.260 --> 00:12:25.800
CPU that things were running on,
another column which is the probe ID,

00:12:26.800 --> 00:12:32.830
and then you would have seen function
call entry and exit for all of

00:12:33.380 --> 00:12:36.800
the function calls in between.

00:12:36.800 --> 00:12:42.620
And it turns out that this is actually
not an incredibly pretty output.

00:12:42.800 --> 00:12:49.800
So what you can do is you can actually
control the output that you get.

00:12:49.800 --> 00:12:55.800
The output that you get is
actually varying by provider.

00:12:56.800 --> 00:12:59.800
So you can override the default output.

00:12:59.820 --> 00:13:02.890
In this particular case,
we were getting the function

00:13:02.890 --> 00:13:04.790
boundary trace output,
and it was pretty ugly.

00:13:04.800 --> 00:13:07.800
So I don't mind missing that demo.

00:13:07.800 --> 00:13:10.780
You can override the default output.

00:13:10.800 --> 00:13:16.850
You can either do this with your own
output in addition to the default output,

00:13:16.930 --> 00:13:18.800
and there are a bunch of
intrinsics for doing this.

00:13:18.800 --> 00:13:23.890
There's a trace intrinsic,
which allows you to trace

00:13:23.890 --> 00:13:25.800
variables or data out.

00:13:25.800 --> 00:13:33.800
There's the trace mem,
which outputs chunks of memory.

00:13:33.800 --> 00:13:35.800
It's controllable.

00:13:35.800 --> 00:13:38.800
There's our old friend printf.

00:13:38.800 --> 00:13:41.760
There's printa,
which is like printf for the aggregate

00:13:41.760 --> 00:13:43.800
variables I talked about earlier.

00:13:43.800 --> 00:13:47.340
There's stack,
which will show you the kernel stack

00:13:47.390 --> 00:13:49.800
at the time that the probe fires.

00:13:49.800 --> 00:13:53.330
And there's ustack,
which shows you the user stack

00:13:53.360 --> 00:13:55.780
at the time that the probe fires.

00:13:56.800 --> 00:14:00.550
And some providers let you
select from alternate outputs

00:14:00.550 --> 00:14:02.730
that they themselves support.

00:14:02.800 --> 00:14:10.040
For example, the FBT provider has a
poundpregmedd option flow indent,

00:14:10.090 --> 00:14:13.800
which is really more
complicated than it needs to be.

00:14:13.800 --> 00:14:17.800
A way of saying,
"I don't want the ugly output.

00:14:17.800 --> 00:14:18.750
I want the pretty output."

00:14:21.020 --> 00:14:22.880
Is it back alive?

00:14:23.000 --> 00:14:25.000
Yes.

00:14:26.100 --> 00:14:26.910
Okay.

00:14:27.040 --> 00:14:29.180
I'll let Steve check to see if it works.

00:14:31.330 --> 00:14:36.260
So I'm actually going
to give another demo,

00:14:36.360 --> 00:14:42.780
which shows actually the
call graph nesting depth.

00:14:46.300 --> 00:14:52.500
[Transcript missing]

00:14:53.210 --> 00:14:55.590
We'll get the demos up in a second.

00:14:55.680 --> 00:14:57.590
Adding information to our sample script.

00:14:57.780 --> 00:15:00.900
So, in addition to getting the
pretty call graph output,

00:15:00.900 --> 00:15:10.360
which would have included only
the CPU ID and the function name,

00:15:10.550 --> 00:15:14.280
as well as little arrows left
and right as to the probe depth,

00:15:14.440 --> 00:15:19.840
which I actually would have been
able to sneakily show you if they

00:15:19.840 --> 00:15:21.890
hadn't got rid of my folded slides.

00:15:22.700 --> 00:17:01.400
[Transcript missing]

00:17:02.550 --> 00:17:10.470
If it's up and happy, which it may be,
then I'll be able to give

00:17:10.470 --> 00:17:13.910
a couple of short demos.

00:17:19.680 --> 00:17:21.950
Does it panic when you do
a function boundary trace?

00:17:21.960 --> 00:17:25.990
We'll see in a sec.

00:17:26.580 --> 00:17:28.840
Looks good, okay.

00:17:29.050 --> 00:17:33.790
So, I guess back to the demo machine.

00:17:35.530 --> 00:17:37.490
Oh, what is it?

00:17:37.500 --> 00:17:42.070
Shift Option +?

00:17:42.080 --> 00:17:42.090
Yeah.

00:17:43.660 --> 00:17:44.830
Oh, go back to demo, please.

00:17:44.830 --> 00:17:49.030
Go back to demo.

00:18:10.980 --> 00:18:16.100
Yay!

00:18:16.170 --> 00:18:17.100
Okay.

00:18:17.100 --> 00:18:19.540
This is kind of meaningless over here.

00:18:19.800 --> 00:18:20.700
You can ignore it.

00:18:20.700 --> 00:18:24.600
But what I'm going to do is I'm going
to trigger the sample over here.

00:18:24.730 --> 00:18:25.990
And this is my initial sample.

00:18:26.000 --> 00:18:31.890
So what we'll do is we'll touch,
since that's the program that's

00:18:31.940 --> 00:18:35.800
waiting for some file in temp.

00:18:35.800 --> 00:18:39.050
All of my files tend to be named foo.

00:18:39.520 --> 00:18:41.160
And there.

00:18:41.160 --> 00:18:44.000
This is the initial output
we were supposed to see.

00:18:44.160 --> 00:18:47.400
And as you can see, it's not very pretty.

00:18:47.610 --> 00:18:51.180
You can also see that
it does a lot of work.

00:18:51.310 --> 00:18:56.100
So,
let's make the output a little prettier.

00:18:57.750 --> 00:19:00.810
This is the second demo.

00:19:00.860 --> 00:19:01.350
I'm lazy.

00:19:01.400 --> 00:19:04.740
I'll just up arrow and do foo again.

00:19:04.780 --> 00:19:06.090
Okay.

00:19:06.220 --> 00:19:10.910
So now here we see our
call nesting depth.

00:19:11.010 --> 00:19:13.700
This is the same type of thing
that you might get out of

00:19:13.700 --> 00:19:18.210
Cflow or something like that,
some other tool.

00:19:18.420 --> 00:19:22.270
But it gives us a good
idea of what's going on.

00:19:22.450 --> 00:19:31.190
DTrace, an open source project which
provides insight into the interaction

00:19:31.190 --> 00:19:31.190
between your code and the OS kernel,
is now available as part of Leopard.

00:19:31.190 --> 00:19:31.190
This session will explain how kernel
developers can both take advantage of,

00:19:31.190 --> 00:19:31.190
and extend,
DTrace's functionality to help

00:19:31.190 --> 00:19:31.190
debug and optimize low-level code.

00:19:31.190 --> 00:19:31.190
This session will explain how kernel
developers can both take advantage of,

00:19:31.190 --> 00:19:31.190
and extend,
DTrace's functionality to help

00:19:31.190 --> 00:19:31.190
debug and optimize low-level code.

00:19:31.560 --> 00:19:35.220
how the nesting depth
doesn't quite line up.

00:19:35.220 --> 00:19:38.960
The reason is because we don't
see the tail call optimization

00:19:39.570 --> 00:19:41.800
on that particular function.

00:19:41.800 --> 00:19:43.640
Hopefully,
we'll be able to deal with that.

00:19:43.640 --> 00:19:47.740
But it actually doesn't
distort the output too much.

00:19:47.740 --> 00:19:50.310
You get useful output from it.

00:19:50.430 --> 00:19:59.750
So what we'll do is we'll go to the
pretty example with our own output.

00:20:00.290 --> 00:20:01.840
Let's mix things up.

00:20:02.030 --> 00:20:05.990
Phi instead of fu.

00:20:06.340 --> 00:20:07.740
So, what do we have here?

00:20:07.990 --> 00:20:12.620
On the right,
we have timestamps in nanoseconds

00:20:12.620 --> 00:20:17.300
for the amount of time that it
took in each one of these calls.

00:20:17.320 --> 00:20:23.300
These are actually one behind because of
the way that I'm calculating the deltas.

00:20:23.330 --> 00:20:28.300
I could have tried to make it prettier,
but it's not a Turing complete language.

00:20:28.300 --> 00:20:32.290
So, we can look through these and we
can see that out of these numbers,

00:20:32.660 --> 00:20:43.080
the only thing that really sticks out
as a high number is this guy here.

00:20:43.300 --> 00:20:47.520
That basically means that that
function is potentially one that

00:20:47.820 --> 00:20:50.130
we're going to want to optimize.

00:20:50.300 --> 00:20:53.780
Okay, podium please.

00:21:01.620 --> 00:21:04.380
So let's talk a little
bit about probe order.

00:21:04.580 --> 00:21:06.100
Probe order is important.

00:21:06.100 --> 00:21:09.650
Probes are firing every time they're hit.

00:21:09.790 --> 00:21:16.770
You can think of these
as events which occur.

00:21:17.250 --> 00:21:20.190
And event streams always occur in order.

00:21:20.270 --> 00:21:23.660
So what's going to happen in this,
we've switched up the order of

00:21:23.660 --> 00:21:26.900
assist call and the FBT probes.

00:21:27.000 --> 00:21:29.600
And we're going to see what happens.

00:21:29.710 --> 00:21:34.000
Because this probe comes first here,
the assist call close probe,

00:21:34.010 --> 00:21:38.320
and we see that its action
is to turn off tracing.

00:21:38.450 --> 00:21:40.100
This probe does not fire.

00:21:40.120 --> 00:21:44.290
And the reason this probe doesn't fire is
because its predicate is no longer true.

00:21:44.390 --> 00:21:48.170
So you've got to be careful a little
bit about probe order if you want

00:21:48.170 --> 00:21:51.730
to capture all of the information
that you're trying to capture.

00:21:52.930 --> 00:21:58.140
So,
don't know if I want to go back there.

00:21:58.290 --> 00:22:00.050
So we have another demo coming up here.

00:22:00.140 --> 00:22:03.860
What we're going to do is we're
going to watch the amount of data

00:22:03.990 --> 00:22:06.890
read and written by the program top.

00:22:07.040 --> 00:22:11.600
This shows instrumentation of the
system call functions read and write,

00:22:11.610 --> 00:22:15.140
and it shows introspection
of their arguments.

00:22:15.140 --> 00:22:18.090
You can see I'm using another
aggregate function down in the

00:22:18.110 --> 00:22:20.250
read entry and the write entry.

00:22:20.400 --> 00:22:21.430
They seem identical.

00:22:21.560 --> 00:22:24.730
What I'm really doing
is by probe function,

00:22:24.820 --> 00:22:28.450
which in the read case is
the string quote read quote,

00:22:28.680 --> 00:22:32.160
and in the write function
is quote write quote,

00:22:32.200 --> 00:22:36.650
and we quantize it on
the second argument.

00:22:36.730 --> 00:22:41.090
Arguments are option based zero,
so don't know how many people

00:22:41.100 --> 00:22:44.860
directly use read and write.

00:22:45.160 --> 00:22:49.180
Read and write take a file descriptor,
they take a buffer pointer,

00:22:49.220 --> 00:22:50.520
and they take a byte count.

00:22:50.740 --> 00:22:55.430
So what we're going to quantize
on here is argument two,

00:22:55.740 --> 00:22:58.410
which is the third
parameter to the function,

00:22:58.630 --> 00:23:00.100
which is the byte count.

00:23:00.100 --> 00:23:02.100
So we're interested in the byte
count that's going to happen.

00:23:02.100 --> 00:23:05.100
And then when we see the
system call exit get entered,

00:23:05.100 --> 00:23:08.100
what we're going to do is we're
going to print out our information,

00:23:08.100 --> 00:23:10.050
and we're going to exit DTrace.

00:23:10.050 --> 00:23:15.270
So this basically captures
only the information that

00:23:15.450 --> 00:23:18.090
you're interested in capturing.

00:23:18.100 --> 00:23:20.680
Demo, please.

00:23:32.040 --> 00:23:34.380
Okay,
so what we're going to do is we're going

00:23:34.440 --> 00:23:36.680
to watch what the program top does.

00:23:36.680 --> 00:23:39.720
So I'll start up top over here.

00:23:39.980 --> 00:23:41.900
What it's doing really doesn't matter.

00:23:41.900 --> 00:23:45.800
I'll switch its mode,
switch its mode back.

00:23:45.860 --> 00:23:47.700
I'll quit it out.

00:23:47.860 --> 00:23:50.730
And here's what we get back from it.

00:23:50.890 --> 00:23:54.940
What we get back is power of
two histograms on the number

00:23:54.940 --> 00:23:57.630
of bytes read and written,
and the number of times

00:23:57.630 --> 00:23:58.720
each function is called.

00:23:58.800 --> 00:24:02.900
So for example,
we've had three calls which were

00:24:03.370 --> 00:24:08.800
somewhere between 1025 and 2048 bytes.

00:24:08.800 --> 00:24:18.800
We've had seven calls down in the
165 to 128 bucket and so forth.

00:24:18.800 --> 00:24:21.600
So we basically get a histogram on that.

00:24:21.800 --> 00:24:27.340
So actually it's kind of not necessarily
interesting to do this because you don't

00:24:27.350 --> 00:24:32.800
necessarily capture what's going on at
the time that you're having a problem.

00:24:32.800 --> 00:24:38.800
So what I did was with a little
ANSI escape sequence foo on my computer,

00:24:38.800 --> 00:24:42.800
I was using my original script and then
using what's called the profile provider,

00:24:42.810 --> 00:24:46.640
which fires at a certain time interval.

00:24:46.800 --> 00:24:48.790
It's user-specifiable.

00:24:48.850 --> 00:24:50.800
I said do it once a second.

00:24:50.800 --> 00:24:56.400
I'm going to capture just the writes.

00:24:57.700 --> 00:25:00.300
And I'm doing this in real time.

00:25:00.370 --> 00:25:02.500
And it's updating the graph in real time.

00:25:02.620 --> 00:25:06.230
So you can use DTrace
to write your own tools.

00:25:10.310 --> 00:25:14.060
And you notice when I move the pointer,
it actually moves,

00:25:14.060 --> 00:25:18.160
so it's not eating the system either.

00:25:19.010 --> 00:25:22.000
And when I quit top, it stops.

00:25:22.120 --> 00:25:24.690
If I start it back up,
it picks up where it left off.

00:25:24.820 --> 00:25:29.780
Okay.

00:25:29.820 --> 00:25:33.100
Uh, podium.

00:25:39.840 --> 00:25:43.580
That was our demo that we just did.

00:25:43.810 --> 00:25:46.080
What works right now?

00:25:46.080 --> 00:25:48.980
Right now,
we have a number of providers working.

00:25:48.980 --> 00:25:53.550
We have the DTrace provider itself
that provides begin and an error.

00:25:53.750 --> 00:25:57.640
That lets you set up
things before you start.

00:25:57.880 --> 00:26:01.480
It lets you clean up things or
print out data when you're done.

00:26:01.540 --> 00:26:04.420
And it lets you handle error conditions.

00:26:04.470 --> 00:26:08.920
Right now,
please don't generate error conditions.

00:26:08.970 --> 00:26:15.740
Basically, what this is intended to do is
it's intended to trap things like

00:26:15.820 --> 00:26:20.020
null pointer dereferences if you
attempt to introspect a pointer to

00:26:20.020 --> 00:26:24.070
a string that happens to be null,
or things like that.

00:26:24.440 --> 00:26:27.360
Function boundary tracing,
we just demoed that.

00:26:27.450 --> 00:26:29.630
System call tracing, we demoed that.

00:26:29.810 --> 00:26:32.980
Timed events, we demoed that.

00:26:32.980 --> 00:26:36.060
There's actually another
demo in the set of scripts,

00:26:36.090 --> 00:26:39.730
which makes the timed events
a little more understandable.

00:26:39.740 --> 00:26:41.320
But I won't show that.

00:26:41.420 --> 00:26:43.040
You can get that at the website.

00:26:43.090 --> 00:26:46.740
PID providers.

00:26:46.740 --> 00:26:47.890
We have two PID providers.

00:26:48.050 --> 00:26:51.320
We have the regular PID provider
and the tools people have added

00:26:51.320 --> 00:26:53.960
in Objective-C PID provider.

00:26:53.960 --> 00:26:58.720
The Objective-C changes up
the arguments a little bit for

00:26:58.720 --> 00:27:04.420
module name and function name,
and replaces them with class and method.

00:27:04.420 --> 00:27:07.160
And we'll be documenting that.

00:27:07.160 --> 00:27:12.040
We've got some static user probes going,
which basically means instrumenting

00:27:12.040 --> 00:27:17.160
your own code or instrumenting our code,
or as you maybe saw yesterday,

00:27:17.160 --> 00:27:19.160
instrumenting Java 1.6.

00:27:19.160 --> 00:27:27.040
We support the full probe complement
for detracing Java that Sun supports.

00:27:27.240 --> 00:27:30.160
And then Mach calls.

00:27:30.160 --> 00:27:33.160
That's an example of a
little bit of a demo.

00:27:33.160 --> 00:27:34.760
And then we have a little
bit of a demo of the code.

00:27:34.760 --> 00:27:36.760
We're going to show you
a little bit of a demo.

00:27:36.910 --> 00:27:37.750
That's an Apple edition.

00:27:37.760 --> 00:27:41.760
And it's basically the same
as a system call provider,

00:27:41.810 --> 00:27:45.760
except for Mach calls,
which Solaris didn't have.

00:27:45.760 --> 00:27:52.480
The detrace command line works,
although apparently not the first time.

00:27:53.290 --> 00:27:57.720
The detrace library works.

00:27:57.770 --> 00:28:01.760
So you can link your own programs
that use it against that library,

00:28:01.760 --> 00:28:05.760
although I don't think many
people actually do that.

00:28:05.760 --> 00:28:07.760
We don't even do that with X-Ray.

00:28:07.760 --> 00:28:12.760
X-Ray actually invokes the command
line detrace and parses its output.

00:28:12.760 --> 00:28:15.970
And the detrace documentation
already out there applies to

00:28:15.970 --> 00:28:19.760
everything that we've done in detrace.

00:28:19.760 --> 00:28:25.760
So anything you can Google on the web,
that basically applies to us.

00:28:26.120 --> 00:28:29.990
So, what's not in the leopard
seed that you have?

00:28:30.090 --> 00:28:33.920
What's not in the leopard
seed is some of the providers.

00:28:33.950 --> 00:28:36.270
They're all static probes.

00:28:36.500 --> 00:28:37.910
They're all in my bug queue.

00:28:38.000 --> 00:28:45.090
And they're basically the static
kernel probes for gathering

00:28:45.090 --> 00:28:50.000
information from places where it's
dangerous to gather information

00:28:50.000 --> 00:28:52.000
with a function boundary tracing.

00:28:52.000 --> 00:28:55.950
And so, when these events fire,
we have a different way of

00:28:55.970 --> 00:28:59.000
collecting the information,
and because of that,

00:28:59.000 --> 00:29:04.000
we instrument things that you can't.

00:29:04.000 --> 00:29:06.940
And if you had something
like that in your driver,

00:29:06.940 --> 00:29:08.770
you'd be able to use that as well.

00:29:09.040 --> 00:29:12.000
But, like I said, right now,
for the seed,

00:29:12.000 --> 00:29:14.000
we're not supporting static probes.

00:29:14.000 --> 00:29:19.940
The compact type format and symbols
for tracing texts is not there.

00:29:22.040 --> 00:29:23.990
That would include your texts.

00:29:24.050 --> 00:29:27.790
So, right now, you can't specify your
text name as a module name,

00:29:28.040 --> 00:29:32.000
but you will be able to specify
your text name as a module name.

00:29:32.000 --> 00:29:37.030
Static probes in your texts,
you could use those as well

00:29:37.030 --> 00:29:40.000
if you had dangerous places.

00:29:40.000 --> 00:29:45.000
The PPC support is currently
lagging behind the x86 support.

00:29:45.290 --> 00:29:47.000
That's a little explainable.

00:29:47.000 --> 00:29:49.990
We're porting x86 code.

00:29:52.190 --> 00:29:58.000
The PPC support is pretty much there
with the exception of the PID provider.

00:29:58.040 --> 00:30:03.330
And then there's a number of
additional exit probes and entry

00:30:03.330 --> 00:30:07.240
probes that were kind of scary
because there's actually a lot of

00:30:07.240 --> 00:30:10.890
assembly language in our PPC kernel.

00:30:11.000 --> 00:30:14.000
And the x86 support
is currently disabled.

00:30:14.000 --> 00:30:17.980
You can actually boot your
system with a boot args,

00:30:18.030 --> 00:30:20.990
your 64-bit system with
a boot args of -legacy.

00:30:22.000 --> 00:30:24.000
And that'll re-enable it.

00:30:24.000 --> 00:30:27.000
But you won't be able to run 64-bit
programs while you're doing that.

00:30:27.000 --> 00:30:31.000
We expect to address
this in the near future.

00:30:32.250 --> 00:30:36.200
So, what's going to be
different from Solaris?

00:30:36.280 --> 00:30:41.730
I was going to say the other ports,
but it looks like we're

00:30:41.760 --> 00:30:45.190
out of the gate first.

00:30:45.680 --> 00:30:48.940
Mostly,
they're OpenSolera-specific things,

00:30:48.940 --> 00:30:52.490
and most of them have to do with
impedance mismatches in kernel design.

00:30:52.500 --> 00:30:57.180
I could go into detail
on each one of these,

00:30:57.200 --> 00:31:03.600
but effectively, they have to do with the
differences in architecture.

00:31:03.600 --> 00:31:07.890
Where possible, we're going to map to
Mac OS X equivalents.

00:31:07.900 --> 00:31:14.060
So you should be safe from them
when running generic scripts.

00:31:14.900 --> 00:31:17.600
You might get slightly
different information,

00:31:17.600 --> 00:31:23.400
but we expect the probe points will work,
maybe with the exception of the UFS probe

00:31:23.400 --> 00:31:27.580
points that they have in their code.

00:31:27.690 --> 00:31:31.630
And you should be able to use
generic scripts which are written

00:31:31.630 --> 00:31:36.300
on Mac OS X on non-Mac OS X systems.

00:31:36.410 --> 00:31:43.610
"We'll be contributing to the organ
bank out there and we'll be collecting."

00:31:46.740 --> 00:31:52.300
So, what can I use it for now
with what I get in the seed?

00:31:52.320 --> 00:31:55.720
Well, you can find the location
of kernel memory leaks.

00:31:55.750 --> 00:31:59.530
I won't go into that in detail,
but there is a sample script

00:32:00.100 --> 00:32:05.840
which instruments the kernel zone
allocator and counts the number

00:32:05.840 --> 00:32:08.600
of allocations and deallocations.

00:32:08.660 --> 00:32:12.750
And everywhere there's a positive number,
you either have a leak or you

00:32:12.960 --> 00:32:14.930
have a persistent allocation.

00:32:15.150 --> 00:32:20.130
And everywhere there's a negative number,
I'm surprised you didn't crash.

00:32:20.700 --> 00:32:26.460
You can find out where
an error is coming from.

00:32:26.460 --> 00:32:29.240
That's kind of neat.

00:32:29.240 --> 00:32:33.590
So you could use
speculative tracing to say,

00:32:33.680 --> 00:32:36.860
give me the results of this,
and when this function

00:32:36.860 --> 00:32:41.680
kicks back this error,
then I want that information.

00:32:41.830 --> 00:32:47.030
But until then,
just keep doing it and throw

00:32:47.030 --> 00:32:47.320
away the stuff I don't want.

00:32:47.310 --> 00:32:51.080
You can find out where to look for
performance problems for a given

00:32:51.080 --> 00:32:53.500
program load or a given benchmark.

00:32:53.530 --> 00:33:06.370
My benchmark of touching the file foo
in /temp indicated that the closef

00:33:06.600 --> 00:33:23.000
[Transcript missing]

00:33:23.190 --> 00:33:29.100
That's a real big thing for
me because unlike texts,

00:33:29.100 --> 00:33:34.050
I can't necessarily unload my kernel
and load a new one without rebooting.

00:33:34.070 --> 00:33:44.980
Most places that you'd put a printf
are places where you would do

00:33:45.390 --> 00:33:51.060
printing out of arguments or
lock state or things like that.

00:33:51.060 --> 00:33:56.340
And obviously anything that's available
on the argument stack is available

00:33:56.340 --> 00:33:59.580
at the time that the probe fires.

00:33:59.580 --> 00:34:03.550
Things which aren't available
are local variables.

00:34:03.560 --> 00:34:07.890
So you aren't going to be able to,
for example, introspect the contents

00:34:07.890 --> 00:34:09.350
of a stack variable.

00:34:09.370 --> 00:34:15.010
So maybe once in a while you'll
either have to put in a static probe,

00:34:15.140 --> 00:34:21.260
which will be deactive and
not out of your shipping code,

00:34:21.450 --> 00:34:27.880
or you'll have to put in a printf,
do it the old way.

00:34:27.880 --> 00:34:32.780
You can also be surprised at how
much work the kernel really does.

00:34:32.850 --> 00:34:36.310
I expected a lot of people
who come from user space,

00:34:36.510 --> 00:34:42.360
expected it to go into close and come --
right back out without doing anything.

00:34:42.360 --> 00:34:46.650
Instead we had maybe 40
lines of function calls,

00:34:46.690 --> 00:34:52.750
maybe 20 functions being entered
and 20 functions -- the same

00:34:52.820 --> 00:34:55.680
20 functions being exited.

00:34:55.680 --> 00:34:59.260
And it's fun for just poking around.

00:34:59.410 --> 00:35:06.330
I know Steve and a couple other people
poked around and we found out that,

00:35:06.330 --> 00:35:09.920
for example,
our Windows server was -- I think it was

00:35:09.970 --> 00:35:17.400
-- I think it was calling sigprocmask
an ungodly number of times a second.

00:35:17.400 --> 00:35:21.490
And that's something
we have to look into.

00:35:22.040 --> 00:35:26.620
So, what we're going to do is
we're going to do a bug hunt.

00:35:26.620 --> 00:35:29.830
This is a bug hunt that
I've done personally,

00:35:29.830 --> 00:35:36.900
and it was my first real use of DTrace,
and so I'm going to show it to you guys.

00:35:36.900 --> 00:35:38.790
Demo, please.

00:35:50.300 --> 00:35:56.700
[Transcript missing]

00:35:57.840 --> 00:36:03.790
I worked on the POSIX conformance stuff,
and as part of that, we had to deal with

00:36:04.710 --> 00:36:08.440
differences in the set UID,
set GID calls, and so on.

00:36:08.630 --> 00:36:11.030
And we have this little
thing called Apple Directory,

00:36:11.030 --> 00:36:17.990
which is not such a little thing,
and it provides credential information

00:36:18.350 --> 00:36:20.400
that is not stored locally.

00:36:20.540 --> 00:36:27.600
Well, it turns out that you pretty much
have to be able to get out of

00:36:28.740 --> 00:36:35.300
with a particular group with set groups.

00:36:35.300 --> 00:36:38.980
And it turns out that even
when you left the group,

00:36:38.990 --> 00:36:40.940
you were still in the group.

00:36:40.940 --> 00:36:45.680
Because set group would say no,
you're not in the group.

00:36:45.680 --> 00:36:48.250
And then it would say, well,
let me ask the directory server.

00:36:48.260 --> 00:36:49.920
Directory server says yes.

00:36:49.980 --> 00:36:52.030
Congratulations, you're in the group.

00:36:52.230 --> 00:36:56.520
So I had to do a bunch of
code to deal with that.

00:36:58.600 --> 00:37:05.500
And my code to deal with
that is-- let's see.

00:37:05.500 --> 00:37:08.720
What did I call it?

00:37:10.640 --> 00:37:13.760
About 1900 lines of code.

00:37:13.810 --> 00:37:17.890
So I had to deal with it in
about 1900 lines of code.

00:37:18.350 --> 00:37:23.700
And,
like most 1900 lines of code changes,

00:37:23.810 --> 00:37:25.940
something didn't work.

00:37:26.200 --> 00:37:34.300
[Transcript missing]

00:37:34.750 --> 00:37:39.470
That should have been the transition
event for the credentials were

00:37:39.980 --> 00:37:42.940
spread all over the place.

00:37:43.150 --> 00:37:45.650
There are a lot of files.

00:37:45.720 --> 00:37:59.710
I can say index of three files,
three fairly large files.

00:37:59.710 --> 00:37:59.720
And

00:38:00.780 --> 00:38:03.120
To do this with the traditional method,
what I would have to do is I'd

00:38:03.120 --> 00:38:07.040
have to spread printfs in every
place where potentially one

00:38:07.040 --> 00:38:10.790
of these things was happening,
and I would have to deal with it.

00:38:10.990 --> 00:38:20.150
So instead,
what I did was I wrote a DTrace script.

00:38:20.150 --> 00:38:20.150
Let's see, where is it?

00:38:24.800 --> 00:38:29.260
I wrote a little DTrace script.

00:38:29.260 --> 00:38:34.010
My little exec name cheat here is so
that I can use a different code path.

00:38:34.150 --> 00:38:38.500
Obviously, this kernel does not
have the bug anymore,

00:38:38.500 --> 00:38:40.980
so I had to put it back in,
but if I put it back in,

00:38:40.980 --> 00:38:44.790
it would have been bad,
so I had to put it in a different place.

00:38:44.800 --> 00:38:47.880
So what I'm going to do is I'm
basically going to check the

00:38:48.220 --> 00:38:53.660
function boundary crossings to see
what code path is there in the bug.

00:38:54.410 --> 00:39:00.570
And I have a little file.

00:39:03.030 --> 00:39:17.390
The DTrace: Kernel Logging Made Easy.

00:39:17.390 --> 00:39:17.390
DTrace, an open source project which
provides insight into the interaction

00:39:17.390 --> 00:39:17.390
between your code and the OS kernel,
is now available as part of Leopard.

00:39:17.390 --> 00:39:17.390
This session will explain how kernel
developers can both take advantage of,

00:39:17.390 --> 00:39:17.390
and extend,
DTrace's functionality to help

00:39:17.390 --> 00:39:17.390
debug and optimize low-level code.

00:39:24.100 --> 00:39:34.000
[Transcript missing]

00:39:35.210 --> 00:39:37.740
And here's the call path.

00:39:37.960 --> 00:39:47.880
And rather than getting into
a huge amount of explanation

00:39:48.590 --> 00:39:52.500
on all the mandatory access
control and all that stuff,

00:39:52.500 --> 00:39:52.500
what we'll do is we'll say, well,

00:39:53.580 --> 00:39:57.070
This is the only thing in the
code path that I touched in

00:39:57.070 --> 00:39:59.260
the 16 places that I touched.

00:39:59.370 --> 00:40:04.160
So that's the one that I care about.

00:40:04.160 --> 00:40:08.660
So what we'll do is--

00:40:12.040 --> 00:40:15.360
What we'll do is we'll wait
until we get into that function.

00:40:15.450 --> 00:40:17.310
That happens to be a kernel function.

00:40:17.450 --> 00:40:20.490
That's a kernel function you wouldn't
otherwise be able to see into unless

00:40:20.530 --> 00:40:24.470
you had sources to the kernel,
compiled up your own kernel,

00:40:24.500 --> 00:40:25.800
put a printf in.

00:40:25.920 --> 00:40:29.090
And what I'm going to print out is
I'm going to print out the user ID,

00:40:29.090 --> 00:40:35.170
the effective user ID, the saved user ID,
and the group membership UID,

00:40:35.340 --> 00:40:41.010
which is the one that
should have been changing.

00:40:41.520 --> 00:40:44.150
Those are all the
parameters to the function.

00:40:44.160 --> 00:40:51.400
There are arguments 1, 2, 3,
and 4 to Kauth, Cred, SetReal, Effective,

00:40:51.400 --> 00:40:58.540
and Saved user IDs.

00:40:58.550 --> 00:40:58.550
So we'll say ./script2.

00:40:58.750 --> 00:41:04.480
And we'll run my special
buggy version of the code.

00:41:06.540 --> 00:41:07.830
It wasn't an X.

00:41:07.850 --> 00:41:08.610
What was it called?

00:41:08.610 --> 00:41:10.750
It was called bug.

00:41:13.040 --> 00:41:17.180
Of course, why would a bug be called bug?

00:41:17.230 --> 00:41:19.970
Okay, and we're going to run it.

00:41:20.860 --> 00:41:23.330
And if I quit reaching for the
clicker instead of the mouse.

00:41:26.530 --> 00:41:31.560
We'll see that what's happening is
it's effectively opting us back in.

00:41:31.770 --> 00:41:34.890
It's saying,
"For group membership checks,

00:41:35.010 --> 00:41:38.980
check for UID 501 in the
Apple directory." Well,

00:41:39.030 --> 00:41:41.400
I told it not to do that
with the set groups.

00:41:41.400 --> 00:41:43.000
What's going on?

00:41:43.020 --> 00:41:47.190
Obviously, the parameter is wrong.

00:41:47.300 --> 00:41:49.680
So, how do I find that out?

00:41:49.700 --> 00:41:53.340
Well, I can...

00:41:53.680 --> 00:41:57.770
I can go through here and try
and find something near or

00:41:58.170 --> 00:42:03.450
around or before or after,
or maybe not even in the diffs that

00:42:03.510 --> 00:42:05.780
I did because I forgot something.

00:42:05.940 --> 00:42:07.330
That's a lot to go through.

00:42:07.580 --> 00:42:09.360
That's not interesting.

00:42:09.360 --> 00:42:14.330
I could go into the C file itself.

00:42:15.470 --> 00:42:23.640
I could go in the C file and look around,
but that's not a lot of work.

00:42:23.640 --> 00:42:29.420
But I know from the DTrace that
it's that particular function.

00:42:29.520 --> 00:42:34.270
So what I'll do is
I will go in the C file.

00:42:34.650 --> 00:42:37.920
Kernel.proc.c.

00:42:37.970 --> 00:42:42.790
And what we're looking for
is we're looking for chaos.

00:42:45.800 --> 00:42:46.890
DTrace, an open source project which
provides insight into the interaction

00:42:46.890 --> 00:42:47.930
between your code and the OS kernel,
is now available as part of Leopard.

00:42:47.930 --> 00:42:49.030
This session will explain how kernel
developers can both take advantage of,

00:42:49.030 --> 00:42:49.650
and extend,
DTrace's functionality to help

00:42:49.650 --> 00:42:50.180
debug and optimize low-level code.

00:42:50.180 --> 00:42:51.280
This session will explain how kernel
developers can both take advantage of,

00:42:51.280 --> 00:42:51.870
and extend,
DTrace's functionality to help

00:42:51.900 --> 00:42:52.800
debug and optimize low-level code.

00:42:55.250 --> 00:42:58.550
Let's see,
we know it's in the setuid function.

00:42:58.620 --> 00:43:05.310
So what we'll do is we'll go
down to chaos-cred probably.

00:43:05.440 --> 00:43:05.930
Did I do that?

00:43:06.040 --> 00:43:06.630
Yeah.

00:43:06.740 --> 00:43:08.390
Yeah, CathCred.

00:43:08.500 --> 00:43:11.540
So here's the function call.

00:43:12.220 --> 00:43:18.340
And it turns out that what I did
was I set a group membership UID

00:43:18.740 --> 00:43:29.660
I set it only in the case that I'm
opting out of the directory services,

00:43:29.660 --> 00:43:31.320
in this case, memberd.

00:43:31.660 --> 00:43:34.740
And then, well, I'll be darned.

00:43:34.810 --> 00:43:44.080
I did all my work except
passing the right parameter.

00:43:50.400 --> 00:43:56.040
I assume that I've
recompiled and rebooted,

00:43:56.040 --> 00:43:58.200
but only once.

00:44:09.430 --> 00:44:15.540
And I see from my DTrace output,

00:44:20.110 --> 00:44:24.190
It's passing Kauth no cred,
Kauth cred no cred,

00:44:24.210 --> 00:44:27.450
which is what it should have
been passing in the first place.

00:44:28.020 --> 00:44:31.230
And so I fixed my bug,
and I've done it in about five minutes,

00:44:31.230 --> 00:44:34.430
and that's about what it took me.

00:44:34.480 --> 00:44:36.190
Podium, please.

00:44:43.530 --> 00:44:48.700
So I pretty much, while I was talking,
went through the moral of the story.

00:44:48.980 --> 00:44:52.830
Doing a lot of printfs and debug,
I would have been at least four

00:44:52.940 --> 00:44:55.300
kernel recompiles and reboots out.

00:44:55.320 --> 00:44:57.870
I would have had to put
the printfs in everywhere.

00:44:57.880 --> 00:45:00.120
I would have had to take
them out of everywhere except

00:45:00.120 --> 00:45:03.230
the code path of interest,
put more printfs in the

00:45:03.230 --> 00:45:06.530
code path of interest,
and then I'd have to

00:45:06.530 --> 00:45:10.000
recompile and reboot again,
try again.

00:45:10.150 --> 00:45:17.520
And then I would have had to take all my
printfs out and hope that I got them all.

00:45:17.620 --> 00:45:21.470
Instead, five minutes.

00:45:22.030 --> 00:45:24.860
Here are the DTrace
resources on the internet.

00:45:24.920 --> 00:45:30.980
I'm sure that Garth will make
this available somewhere.

00:45:31.590 --> 00:45:34.500
And so,
what should you take away from this?

00:45:34.500 --> 00:45:36.750
DTrace is neat.

00:45:36.800 --> 00:45:37.480
I like it.

00:45:37.600 --> 00:45:42.230
And that's not just
because I helped Steve,

00:45:42.280 --> 00:45:46.210
who did most of the work, work on it.

00:45:46.940 --> 00:45:48.560
You want it.

00:45:48.720 --> 00:45:50.800
Leopard has it.

00:45:50.800 --> 00:45:53.120
It's not hard to use.

00:45:53.120 --> 00:45:57.360
As we saw, hopefully everybody's going to
come away from this with a basic

00:45:57.400 --> 00:46:00.990
understanding of how to do a Descript,
or at least putter around until

00:46:00.990 --> 00:46:03.480
they get something useful out of it.

00:46:03.480 --> 00:46:07.150
It's going to make your life easier,
and it's going to help improve your code.
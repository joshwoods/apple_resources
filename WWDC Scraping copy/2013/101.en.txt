---
Title:  Platforms State of the Union
Year:   2013
Web:    https://nonstrict.eu/wwdcindex/wwdc2013/101/

[!] This transcript has potential transcription errors.
---

Ladies and gentlemen, please welcome Senior Director OS X Platform Experience Andreas Venter [assumed spelling].

[ Applause ]

Good afternoon. Welcome to WWDC 2013. The epic ecosystem continues to thrive for hundreds of millions of users enjoying their iPhones, iPads and Macs. This morning, we had several great announcements that will make our users even happier. Starting of course with iOS 7, the big theme of iOS 7 is its beautiful new look. And it also contains features like control center and multi-tasking UI and AirDrop.

OS X Mavericks is a very compelling mix of infrastructure improvements that lower power consumption, increase responsiveness. Together, let's [inaudible] user features like margin monitor support and file tagging and of course our new maps and iBooks applications. Now, what we didn't tell you this morning is that we also have big news on our developer tools. In addition to our operating systems, we're also announcing a major new version of Xcode today, version 5.

[ Applause ]

Yeah.

[ Applause ]

Yeah.

[ Applause ]

The most important purpose of Xcode 5 is of course to let you take advantage of all the new APIs in iOS 7 and OS X Mavericks, so that you can get the most out of these operating systems. But it also contains features that will allow you to create higher quality apps with a really strong-focus on testing and debugging.

And all of this gets surfaced in a fresh new look that simplifies the Xcode experience. This is the new Xcode 5. Everything is more compact and clear. With fewer distractions from your source code, you're going to see quite a bit about the new Xcode 5 throughout this session. But for now, I'm going to focus a little more on our agenda with platform ecosystem.

One of the major forces that prepares our platforms is the continued and growing success of our app stores. Just recently, we crossed this amazing mark of over 50 billion app downloads. And the rate of downloads start accelerating because they're constantly working on improving our app store experience. This year, we're making it easier for users to discover new apps through our apps [inaudible] feature which crowd-sources relevant apps that you might want to use based on your location. So for example, you can find apps that's specific to a shopping mall you're entering, or a sports event you're attending or an area that you're visiting as a tourist.

You're also significantly improving our volume purchase program which allows companies and schools to initiate mass purchases of app licenses for both iOS and Mac and to distribute those licenses to their users with the help of MDM service. And for you developers, we're improving our purchase receipts. We're now encrypting through receipts on both platforms, and via extending the data, you can access from these receipts.

The concrete example that is really useful is if you're in the process of moving your app from a paid app to be a premium. In which case, you can validate with the receipts which users have already paid in full for these apps and credit them [inaudible] app purchases you might want to offer for free.

[ Applause ]

So taking it all together, they are making improvements for our end users for enterprises and schools and for developers. And all these features work together to make the app store experience even more compelling that we're adding to the business opportunities they offer to you as third-party developers. I'd also like to give you a very brief update on iCloud. iCloud provides a set of services that integrate seamlessly with applications so that users can access their documents, their media, and their app data from any device they choose to work on.

And it's a huge success for hundreds of millions of users worldwide. iCloud also offers a set of developer APIs that users can use to integrate these services with your apps. Now, we understand that there is one specific area that many of you have struggled to get to work right. And that is our documents in the Cloud API with core data. So this is an area that we have decided to not implement any new features this year but instead to focus on reliability and quality. We have fixed a ton of perks in this space.

[ Applause ]

We've also made it easier for you to interact with this technology. We're adding specific iCloud debugging tools to Xcode 5.

[ Applause ]

You'll be able to use the key-value store and the Document API from the simulator for better testing. And in case your users -- in case if users ever need a way to reset their Cloud data, we would give them a way to do just that later this year on icloud.com. So, that's just a brief update on iCloud. We're working very hard to getting this right this time, please try that one more time.

[ Applause ]

All right, for the remainder of this session, we're going to take a look at how our new products impact your apps. You already got a good idea for what they bring to the table this morning in the keynote for end users and at this session, they're going to focus on what they -- what this all means for you as developers. We're going to start with iOS 7, and for that, I'm going to bring Toby Paterson up on stage.

[ Applause ]

Good afternoon. We've been working for quite a while on iOS 7 and I'm really excited to tell you a bit about it today. We've got a lot of new things for you here. Just for fun, we took a look and counted the number of new symbols in our public frameworks. We've got 114 new classes, 679 new methods and 917 new properties. Wow! All right, we'll take that for what it's worth. But the bottom-line here is that we've got a lot of new things for you to dig into.

Right now though, I want to talk about just one thing. The new user interface, the visual changes that we've made are of course the most obvious difference. But it goes much deeper than that. This is not just a facelift. We broke down all of our applications and reassembled them, focusing first on the content and then building the chrome around that. The result is a fundamental change to our user experience that will affect all applications.

This is not something that we undertook lightly. We took a very serious and measured approach to this. And there are three big ideas at the heart of our redesigned UI. The first of these, clarity is all about showing what's relevant. It means presenting data to users in a way that makes sense. Providing features which are self-explanatory and discoverable and providing a consistent and cohesive user experience across your applications.

Deference can be summed up simply as getting the chrome out of the way. Your users care about their content, their videos, their messages, their music. The user interface should not compete with that for their attention. This is perhaps the most radical change that we've made in the new UI. And I think that new understated look of iOS 7 will really allow the personality of your applications to shine through far more than ever before.

Now, although we've simplified the user interface, that doesn't mean that it's static. iOS 7 has tremendous vitality through the use of depth and motion. Parallax blurs and translucency take the place of gradients and shadows and cut-lines in defining your content areas. And sophisticated animations make this perhaps the most lifelike of the any iOS release yet. Take a look at the use of Parallax on the home screen here. Notice how the background appears behind the application icons and the badge appears to float above it.

So what does this mean for you? There are four things that you need to pay attention to. The first of these are changes to the way your content is laid out. We have some new metrics on our system controls and buttons and pickers have a new look and a new behavior about them. I'd like to give you a quick demo now. I'm going to walk through some of the applications that Craig showed you this morning, and just point out some things that we think you should pay attention to.

Let's go into photos here. And right away, you can see some differences. Let's try this one and there we go. Okay, let's go into photos here. Right away, you can see some big differences. Take a look at the bars at the top and the bottom. Gone are the gradients and the shadows and we've got a much more muted understated look. If I drill into some content here and start scrolling, take a look closely at the bars at the top and the bottom. You can see some of your content just sort of hinting through the bar there.

The bars are partially translucent and we put a heavy blur on them so that the text on the buttons on your bars remain legible. If you take a look at the buttons in the navigation bar, the Back button on the left and the Select button on the right, you'll notice also that they don't have any borders anymore.

Let me select a couple of photos here and have a look at the buttons at the bottom. They too have no boarders. And in fact, you'll notice that we're starting to use text in place of icons in some place for greater clarity. Now this is not something special to photos. We actually made this change throughout the system.

Let's go into mail now, and we'll see here a message that I was reading earlier. As I scroll up, you can see the content showing through the bars as well. And here too the buttons have no borders. Now, this begs a very important question, how is the user meant to know what to tap on? Well, we're using color in place of borders to indicate things that are tappable or can otherwise be interacted with. In the case of mail here, the color is blue but every application has its own personality. And so you can tailor the tint color to your application's theme.

Let's go back up to the message list. There's one more thing I want to show you here. I'm going to swipe on a message and tap the More button to bring up the action sheet, and take a look at the buttons up in the navigation bar now. You'll notice that they've lost their color because of course I can't tap on them because the action sheet is up.

If I just missed the action sheet, the color goes away. And this is not just a simple dimming effect. We're actually desaturating the tint color of the control there. What's happening under the covers is that UIKit is changing the tint color on the inactive controls and posting a notification. You can listen for that notification in your app so that you can update the color of your controls accordingly. And I have a small confession to make. My eyes aren't what they used to be and I'm having a bit of trouble reading the text in mail here.

So, I want to show you a new text-sizing feature that we've added to iOS 7. I'm going to switch into settings here and you can see right here. This is a great example of the new group style Table View. This is the case where we've changed some of the metrics. You'll notice the cells are now going edge-to-edge instead of being inset into rounded racks.

Let's drill into general and text size and you'll see that I've got a slider here. I can drag it to the left to make text smaller or drag it to the right to make text larger in applications which adopted this feature. I'm going to leave it on the right in the largest setting and switch back through multi-tasking to mail.

And you can see that mail is now using a much larger font and it's also adapted to the layout of the cells to accommodate the larger text. This is a place where I think Auto Layout Constraints are really going to help you in your application with this feature.

Now, I'm having so much fun up here that I worry the session may go a little bit late. Let's check the calendar and see if that's going to cause any problems. Sure enough, we've got the Apple Design Awards coming up a little bit later. We better do something about that. I'm going to tap into the awards event and edit it and I'm going to tap on the start time here to push it back a little. Notice how the picker slides or notice how the Table View slides open to reveal the new picker.

Once I've changed the time to push it back or we don't need to go to 6, I think 5 will be fine. I'm going to tap the Start Time to accept my action and the Table View slides closed to hide the picker. This is a new way of using pickers which will take a bit of work in your code to adopt it but I think the result is a much lighter weight, easier to use control. Okay, let's go back to the slides now. I want to recap briefly some of the things we've just talked about.

So first, your content needs to go full screen now. We've always had translucent bars in UIKit. The difference now is that all bars are translucent all the time. If your content is in the scroll view, we can dynamically resize that and set the content insets appropriately for you. If your content isn't in a scroll view, you'll have to do a little bit of work to adopt for the new layout. Buttons have no borders anymore whether you're using a UI button with a now horribly misnamed bordered bar button item. The borders are gone.

[ Laughter ]

And we're using tint color to indicate things that can now be interacted with or tapped on. Group style Table Views and some of our new controls or some of our controls have new metrics. Now, we tried very hard to minimize the number of places where we did this because we're fully cognizant of the impact this will have in the layout of our application. Those places where we did do it, we felt were absolutely essential to the goals of the redesigned UI. And finally, a new way of using pickers in line.

So those are some of the things that have change in UIKit. The thing to bear in mind is the vast majority of the kit remains the same. I'd like to talk a little bit now about some new things that we've added to help you in your applications adopt the new principles of design.

Let's start with typography. Retina devices permit this incredible quality of text. What's been missing are some of the more advanced ideas in typography that come from the printed publishing world. The first of these are kerning and ligatures which we turned on by default in text throughout the system whether using UIKit or WebKit.

Now, for those of you wondering what kerning and ligatures mean, kerning is when two letters overlap each other such as the T and the R at the start of truffle. And ligatures tie letters together such as the F, F, and L at the end of the word. This might strike some of you as a rather esoteric point. But it's one of those little details that we at Apple find so important. I think the result is text that's much more legible and frankly more beautiful. We even support some of the more extreme cases out there such as Zapfino.

Another thing that we've added is a new way of working with the system font. Instead of a single one-type-fits-all system font, we've introduced a family of fonts that are being chosen by our designers to work well with each other. We looked at text across all of our applications and classified them into a series of usage categories or styles. And for each of those styles, we chose a specific font and size relative to each other.

Now typically, if you wanted to present more information on the line or make text more readable, you would just scale the font down or scale it up appropriately. The problem with that is that it can leave text very hard to read at the smaller sizes or your letters can be big and blocky at the larger sizes. So, we're introducing a new way of sizing text. You saw me demonstrate this in mail just now. We actually changed the stroke width and the character in the line spacing of text at each of the relative sizes.

There's a new API on UIKit that were turned use -- the specific font to use for a given size and style. And WebKit makes this available to you through the use of CSS font values. We're calling this dynamic type. It's a very -- we think it's a very advanced typography, set of typography features that we're giving to you in a mobile operating system. We think it's pretty cool.

Another thing that we've added is Text Kit. Text Kit is an advanced text and layout rendering engine. It's a great compliment to WebKit for those times where you want to use code to control the layout of your text. We took the Cocoa Text technology from OS X and brought it to iOS in the form of a new set of APIs. Those of you who are familiar with Cocoa Text will have no problem using these APIs. For the most part, they're the same.

And that's it for text. Let's talk about animations now. There are generally three ways that we sort of group animations when we talk about them. Transitions are canned animations between your view controllers, for example. Motion effects tie animations to the movement of the device. And dynamics are animations that interact with the user. Let's dig into these a little.

So out of the box, we write a standard set of view controller transitions. Your view slide up from the bottom when you present them modally or from right to left when you push them on to a navigation controller. Well, we're opening that up to you now so that you can define your own animations for a transition.

If you want to flip your view around when you push it on to a navigation controller, for example. We're also making it easy for you to tie your animations to the system transition so that you can animate alongside one of the system transitions or kick off a set of animations at the end.

UI motion effects. So as I said before, motion effects tie movement of the device to changes in your UI. You're familiar with core motion. Well we took that and packaged it up in an easy to use API, that we're calling UIMotionEffects. We take the event string from core motion and we crunch the numbers and convert that into a series of perspective changes. We then feature those perspective changes so that you can adapt your UI accordingly. This is how we implement the Parallax effect on the Home screen and the new tab UI in Safari.

And finally, I'd like to talk a bit about UIKit dynamics. I asked one of my engineers for a succinct description of this, and he's a smart guy, a doctor. And this is what he told me. I had to think about this one for a little bit. And I think I can sum it up a little more simply for you. We built a physics engine into UIKit.

So the idea is that the physics engine deals in terms of real world type behaviors -- collisions, gravity, forces, that kind of thing. You associate a set of behaviors with using your hierarchy. And as the physics engine runs, it updates properties on your views and changing that frame orientation.

Conversely, if you change properties on your view, say, in response to the user swiping across the screen, we feed those back into the physics engine and it runs until -- I'm sorry, it runs until it come back to an equilibrium. This is a super powerful system that lets you -- makes it very easy to compose sophisticated interactions with users. That's what we call UIKitDynamics.

Let's talk about images a little bit. In the beginning, it was really simple. You created your image, you gave it a name, and you looked it up. Well then we added iPad and we needed a way of differentiating your iPad art from your iPhone art. And so we came up with a clever way of mangling the filename.

Well then we added Retina iPhones and we need a new way of differentiating your iPhone high-res art from your 1x art. And then we added Retina iPad, so frankly, it all just start getting out of control. We were running out of ways of mangling your filenames. With iOS 7, we are ending the insanity.

[ Applause ]

We've got a great new UI in Xcode that makes it really easy to manage your images. You can tell at a glance if you're missing some Retina art, and we've integrated this tightly with UIKit. You still look up your images the same way that you've been doing it for years, and it's a little bit faster to boot. I'd like to invite Max Drukman on stage now to give you a demo of this and some other cool new features in Xcode 5.

[ Applause ]

Thank you Toby. Can we switch to the demo machine please? Welcome to Xcode 5. Now as Andreas told you, Xcode 5 is much cleaner and lighter and does a really good job of keeping your content front and center. You'll see a lot more of Xcode 5 in this session, but for right now, I'm going to talk to you about two new features, Asset Catalogs, that's the feature that gets rid of that naming convention for you, and the totally revamped Auto Layout.

Let's have a look. Here's a game project I'm working on. I'm going to dive right in to the intro screen. Here I have a couple of buttons and it's fairly typical in a game project. I'm using UIKit buttons but I'm styling them with custom art. Since there are only two buttons on this screen, I think I'll make them as big as I can. And I'm going to push them over to the side and I'll make this one really, really wide.

And here we see that's one of the pitfalls of using custom art with a scalable button. I made my button big but my artwork got all distorted. Now, I know what most of you are already saying to yourselves, I know how to fix that problem. You need to get art that's sliced into three parts.

Well, you're absolutely right and I appreciate you bringing that up because it gives me just the segue way I need to start talking about Asset Catalogs. I'm going to navigate to the Asset Catalog in my project. And here we are. On the left is an outline with all of the visual assets of my project and on the right, there's a thumbnail view that keeps all of my assets and their variants organized.

Here we can see the background of the screen I was just on, that sort of lime color, with both the 1x and 2x variants. The next screen over, the sort of stone color, also 1x and 2x. And even my app icon and launch images with their five representations.

That's right. As Toby told you, gone are the days of the -427K at 1x twiddle i something. Naming convention, now we can all go back to the foo, bar and baz convention that we all love so well, or no convention at all because the Asset Catalog keeps your image reps organized for you, it doesn't really matter what you name your images anymore. Let's go back to my orange buttons. Now as we know, we need these in three parts. Well, one of the features of the asset catalog editor in Xcode 5 is that you can now do slicing right in Xcode.

[ Applause ]

That's right. I'm going to click the Show Slicing button down here in the bottom of the editor. And here we see the slicing UI with the 1x and 2x representations of my art blown up so we can see pixels. I can even zoom in a little more. Now, all I need to do is click the Start Slicing button and I'm given three choices.

I can slice in three parts so that my image can scale horizontally, or in three parts so it can scale vertically, or of course in nine parts so that it can scale both horizontally and vertically. Somebody out there wins a prize. I only need mine to scale horizontally, so I'm going to choose that. Now, Xcode analyzed my image and found the best place to put the slice points.

[ Applause ]

So I have a left cap, a right cap, and one pixel of stretch. The grayed out area won't be used. Now, of course, you can make your own decisions and change the width of the caps if you want. You can even change the width of the center portion and it will repeat rather than stretch. But I like what Xcode gave me, so I'm going to slice the 1x in exactly the same way. And now, when I use the back button to go to my story board, my art is doing the right thing.

[ Applause ]

And now, even when I scale the other one, everything is looking great. Now, let's talk about Auto Layout. Obviously, I'm designing my interface in the landscape orientation. But what happens when my user rotates her device to see it in portrait? I need to know what my interface is going to do when that happens. Now, of course, I can run my app in a simulator or run a device if I have one handy.

But we've made it even easier in Xcode 5 because we've added a preview assistant. The preview assistant allows you to look at your story boards under different visual conditions. So here, I'm designing in landscape, but previewing in portrait. I can essentially design in two orientations at once now. And you can see that I have an Auto Layout problem. Of course, these demos always start with a problem, right?

Now, notice that my buttons are clipped off and they're kind of floating in the center somewhere. But my background and the logo of my game, they're actually doing the right thing. That's because of a big change we've made to Auto Layout in Xcode 5. Now while you're working with your interfaces, you no longer need to have every object constrained.

[ Applause ]

Yeah, that's got to be worth something. It makes it really easy to work iteratively through your interfaces without Auto Layout, well, getting in your way. Yeah. Now, we didn't stop there though. We've also added a lot of different ways to make constraints. Let me show you my favorite. Control drag. I'm going to constraint this button by control dragging from it to its superview.

[ Applause ]

Well, wait. I can even make more than one constraint at a time. And now the preview assistant updates, so I see that I'm on the right track and I know that I only need to make one more constraint, and now my button is doing the right thing in both orientations.

[ Applause ]

There's one more thing. Now, doing the other button is even easier. I can control drag to the other button and set up all three constraints at once. In one gesture, and that's pretty simple. Now -- -- let's look at this next view over. It's obviously having some layout difficulties. That's because there are no constraints in this view at all.

Now, control drag is great for setting up one, two, three, a handful of constraints, but of course, you can do things like select all of the objects in this view and add all of the constraints at once. And you get immediate feedback that it worked. That's pretty good.

[ Applause ]

Now let's look at one of these tab views I have over here featuring the great new iOS 7 look and feel. Now as I said, you can have the assistant in a different orientation like, you know, I can go back and forth between landscape and portrait. I can have different device sizes so I can -- here I'm switching between the three and a half and four inch. I can even go back and look at iOS 6.1 style UI.

[ Applause ]

And we see that my constraints are doing the right thing. They're -- it's -- they're reacting perfectly to orientation change, device sizes, and even iOS versions. And I get to see immediately, thanks to the assistant, that I'm doing the right thing. Thank you. Back to you Toby.

[ Applause ]

So there really is so much more in iOS 7 than just one thing. The new multitasking interface, for example. It really shows off the user's running applications. This makes it all the more important than your app -- that your app's content is as up to date as you can make it. To help you out, we're adding three ways for you to update your application's content in the background. With background fetch, we will run your application periodically so that you can pull new data down and update your UI accordingly. If your server --

[ Applause ]

-- if your server has a minimum time between connection attempts, you can use this API to tell us when it would be inappropriate to run you. With remote notifications, we'll run your application in response to a push notification so that you can update your content on demand versus having to pull.

[ Applause ]

And with background transfers, we make it easy for you to upload or download your data in the background even if your application isn't running. You simply create an NSURL session and we take care of transferring the data for you. Now, I've been told I'm not actually allowed to push back the start time of the Apple Design Awards, and there's really too much for me to cover up on stage here. We have a lot of sessions and labs this week and I know a number of my engineers are up here to talk with you.

So how should you get started with this? Well, first of course, download the SDK, build your application, and boom, you've got the new user interface. You may need to update your UI to accommodate some of the changes that we've talked about, but we really encourage you to actually take a deeper rethink on the design of your UI along the lines of what we've done in iOS 7. Let's take a look at these numbers again from this morning, 93 percent of our users are running the latest iOS release. That's pretty incredible. We think it won't be very long after all before the vast majority of your users are running iOS 7.

We've got some great documentation on the web, and I encourage you to download the iOS 7 UI Transition Guide available at this URL here. If you can type that one quickly. And that's it for iOS 7. Now, games are a very important category of application. And to talk about some exciting new stuff, I'd like to hand off to Jeff Stone. Jeff?

[ Applause ]

Thanks Toby. So we have some really great new game technology to talk about today, first let's do an update -- update on Game Center. Apple's social gaming network, we introduced it three years ago and it's doing amazingly well with 240 million players. Of course, Game Center supports things like leaderboards and multiplayer challenges and friends. And we're going to continue to enhance it. Now leaderboards, you can have over 500 leaderboards, you can have up to 500 leaderboards. We have modal challenges that allow you to tie a challenge to a specific mode of your game.

And we have -- we have turn -- you can add to turn-based applications either auctions or in-game trading among other things. But the big news today is we have two new technologies to introduce that makes game development easier and better than ever. First, I want to introduce Sprite Kit.

So if you're building a game like one of our iconic games on the platform, Cut the Rope, Where's My Water, or Jetpack Joyride, you need to spend time building a good game engine. And to build a good game engine, it takes a lot of knowledge to do that. So we thought, what can we do to help you game developers make your life easier?

So that's why we created Sprite Kit. It has everything you expect in a game engine. It has a great animation system, particles, physics, image effects, video tie-in, and all that and more. It's high performance with -- at its core is a high-performance rendering engine built by people who really know GPU development inside and out.

We have integrated tools in Xcode and it's easy to learn, which means you have less code to write. Let us do the heavy lifting for you and so you can concentrate on building a great game. And of course, it's available for both iOS and OS X, which means the code you write can be used on both platforms. So let's take a look at a demo.

[ Applause ]

So here's a little tour of some of the features of Sprite Kit. First, obviously, is an animation system. The animation system has all the things you would expect -- translation, rotation, scaling, fade in, fade out, and these actions can be chained together -- chained together or combined and run in parallel in groups. Oops, let's try that again. This is also optimized for both -- for OS X and iOS hardware with the added benefit that it makes it really battery-efficient.

So that -- so that's the animation system. Next is physics. We obviously -- we have integrated physics. But this is not just, we provide physics alongside of Sprite Kit, we actually have integrated physics. Putting physics into your application is as simple as one API call for setting the physics body. So we can -- we can kind of lean one direction or we can go back the other way, and also we can obviously put some touch events in to add some impulses to our physics engine. Really efficient physics engine built into Sprite Kit.

The -- next, particles. We have full particle system in there, 37 properties of these particles, and the key here is you can either modify these with your code or you can -- or you can modify the data which means you can build particles offline and archive them for use by your application. We also have an interpolated spawning [phonetic] system which we think of this as an anti-clumping technology. As I move this around, you see the particles are evenly distributed in the trail. Everything like that, all of this 60 frames per second, I can even write with it.

Here you go. We've also integrated Sprite Kit into our existing graphics technology core image. So you can apply CI filters to your application here. And once we toss a filter on here, so you can have this great, yeah, this great pinch effect on there as the physics simulation continues to run.

We have a pixelate filter on top of the system. And these filters can be applied to all or part Sprite tree and finally a really, really cool -- -- twirl effect. So you can apply CI filters right on top of your scene. Finally, the video. We've taken our great media technologies and integrated video in the Sprite Kit.

This means you can mass the video and I can manipulate the mass on top of the video. And you can combine this into your scene such the video is not just for cut scenes and transitions. I can add sprites in here. And you see the sprites fly in front and behind the video. Video is a first class citizen in Sprite Kit. So that's a quick tour of Sprite Kit.

[ Applause ]

I thought of making the game development easier for all of you. How else I'm going to do that? Well, we're going to introduce comprehensive, full-featured, production quality game sample code for you guys. So let me jump in here and show you what we have. So this is our adventure game. It is a Multiplayer Dungeon Crawler with all the features you would expect.

So it has a multi-directional scrolling, parallax effects, we have part of this falling leaves particle effects that the enemies have AI, with high quality art work. All of this was production quality code which allows you to just grab it, and either start your next game project with it, or adapt the two, or pull some technologies out of it to adapt it to your current game.

There you go. So let's jump back in the Xcode and take a look. So these samples are made for both OS X and iOS which means the vast majority of the source files are shared, so you can use them to support either operating system. We have over 1,700 art files in this sample. And if we go look at the part -- one of the particle effects here, this is a leaf particle effect, what you'll notice is we build a particle editor right in the Xcode.

[ Applause ]

So I can change the generation rate on the particles here. We take a lot more of leaves -- that that's felt better for the game. And, you know, leaves fall in the fall not when they're green so we want to change one of our key colors here. And we'll make that red.

And we've changed the particle effect. Again, this is editing the particle data so when you build your application again, when you build your game, it's picked right up and your game will have this effect in it. So that's a quick tour of one of our new game samples.

[ Applause ]

The next big technology we have to announce today is Game Controllers.

[ Applause ]

We're taking the gaming experience to a new level by defining the standard -- a common standard for game controllers that allow high -- that allow all users to have high quality game controllers. So how are we doing this? We are providing the users -- users can pick whatever third-party controller they prefer. Software developers can build a single software interface rather than having to support a multitude of software interfaces, thus as game developers, you can concentrate in building your game versus supporting a whole bunch of different game controllers.

This comes into two parts. First, a hardware standard, this is part of our MFi program. And secondly, a software interface which allows software developers to build -- which allows you to build to a common interface. Let's first talk about the hardware. The hardware comes into two types, either form-fitting snapping controls, or your stand-alone controllers. There's also two configurations. The standard configuration has a d-pad, four buttons, and some shoulder buttons. The hands configuration adds two thumb sticks and two triggers.

All inputs are pressure-sensitive. And we talked about high quality. We want to ensure there are high quality controllers to give your users a great experience, we do these by requiring no calibration, the inputs can't drift, and all the buttons have to have the same feel. Of course there's a software piece of this.

So you can -- so your software can communicate directly with controllers. And this is, the truth be told, this is really easy to adopt with both polling and callback types of inputs. We've also designed it so you can actually use the Multi-Touch interface or the gyro in conjunction with your controller so you can make a great a hybrid experience for your users.

And of course this is both on iOS 7 and OS X Mavericks. So I think the best way to show what you can do with controllers is to do a demo. I like to invite Thomas Schegloff [assumed spelling] on stage to show what they've built. So we do --

[ Applause ]

Last week, we reached out to Crytek, they're working on their new iOS application collectibles and they came in and integrated game controllers into their application. Within a day, they had a standard controller working. What you have here is a tactical action game and this is running on the iPhone and you can use the controller using the D-pad for relative movements to avoid those explosions and advance his squad, as he advances his squad, he get -- comes under fire. What he now can do is hit a button to move the squad to cover.

He finds that he wants to directly manipulate some of his troops. What he can do is he can use at the touch interface to touch on a troop and he can drag it specifically to a point he wants deploy them at. But this allows a great hybrid mix of the game controller and the Direct-Touch interface. He finds his squad gets in a little --

[ Applause ]

He finds -- he gets in a little trouble, he can hit the shoulder button, calling some air support, now the D-pad switches over to controlling his air support. Beautiful job, very little time integrating controller setup into this game, brilliant graphics. Tremendous job by Crytek and then you can go, thank you, Thomas.

[ Applause ]

So we want to make you -- get you guys jump-started on working with controllers. We've worked with Logitech, put some standard snapping controllers in the labs this week and they'll be -- so tomorrow, you can head down to the labs with your code and get a jump-start on developing for controllers integrating them to your application.

So we've talked about a lot of things in game development, two new APIs, Sprite Kit and game controllers. Tools built in the Xcode, particle editor, and a text [inaudible] generator. We have new game samples. We showed you one of them, adventure, we also have a turn based puzzle game.

These samples are production quality code, they're fully documented and a code displaying cell documentation allow you -- allowing you to grab that, use it to start your next application or take a piece of technology out of it and add it to your current application. So I can't wait to see -- I can't wait to see what you guys build with our new game technology and I'd like to hand it back over to Andreas to talk about OS X Mavericks.

[ Applause ]

Thank you Jeff. Our gaming technologies have we, come a long way just last year and I'm already looking forward to wasting even more of my time with the new creations you come up with. All right. Let's talk about OS X Mavericks. So Mavericks, the big architectural focus area is optimizing power consumption. All of us here are already used to optimizing our apps for low memory use and low CPU utilization.

But the majority of computers used nowadays are laptops and mobile users really also care about long battery life. These added several features to Mavericks that allows end users to understand the power consumption of the apps they're using better. For example, by listing how are hungry apps in the battery menu extra and in activity monitor. And you probably don't want your apps to show up there.

[ Laughter ]

The good news is that the following -- a few very straightforward rules like not using unnecessary or too frequent timers, you can often achieve great results. This slide here shows a comparison of OS X, 10.8 and 10.9 running on the same hardware. As you can see, just two software changes, we were able to squeeze out significant improvements to battery life and so can you in your own apps.

Another big focus area for us was responsiveness such as the scroll speed of table use and the smoothness of animations and switching between different application states. You saw this morning in the key note how nicely made [inaudible] and Safari, now react to user events. Now one problem is that optimizing power consumption and preparing an app for great responsiveness can sometimes trade often each other. So the trick is to find the right balance, the right intersection between power and responsiveness.

Let's take a look at a few things within the Mavericks that you believe represent the right choices. We implemented new mechanisms that vastly improved memory management. We introduced in our scrolling architecture in App Kit and of course we added the new App Net feature which started, it's the power consumption of background with apps.

For memory, we've now centralized all our management policies which makes the OS more efficient and more predictable. For several releases already, we have notified apps if you needed their help because memory pressure in the system had reached the level -- that we needed to free some extra memory.

But they only notified once we had already reached a very high level of memory pressure. So in general, apps didn't really know what was going on around them and then it was okay again to become more aggressive. That's using more memory. So we're improving this in two ways and [inaudible]. First of all, they're going to send you two notifications why the memory pressure is increasing.

An early warning and also a critical level notification. And then we're also going to send you an all clear signal if the memory drops back down to normal levels then it's okay for you for example to create larger in-memory caches again. So by listening to all this notifications, apps can now make much more informed decisions about their memory use.

We've also improved all purgeable memory handling and made it actually predictable. Instead of purging memory based on age, you now purge based on the memory pressure in the system. And they're allowing apps to specify more fine-grained priorities to indicate which regions are best to take down first. Unlike low memory notifications, purgeable memory is designed so that the system can free memory without unvoiding any apps. So it's quicker and it's cheaper. And with the new behavior, it is a lot more useful now. The easiest way for you to leverage purgeable memory is through our Libcache and NSCache APIs.

We've also added a compressor to the memory management techniques you now use in Mavericks. Instead of swapping out memory directly to disc, you're now freeing pages by compressing them in an intermediate stage, which dramatically improves responsiveness to memory regress, because there is no I/O needed. And if you do have to swap out to disc later, we can do so in an asynchronous fashion that's larger, more uniformed chunks of memory. It also has a really nice side effect of swap -- side effect of swapped files staying smaller and less fragmented. So all this memory management techniques now work together in Mavericks to give us the most efficient memory management system you've ever had in OS X.

Next, our scrolling architecture. To improve responsiveness of scroll views, you've completely reinvent all the scrolling architecture in AppKit. To maybe achieve the smooth scrolling you observed this morning and in [inaudible] calendar is that you're now pregenerating and buffering additional review content beyond the visible view areas and just scrolling that content with the help of core animation just makes it hardware accelerated. So let's say we have a scroll view that shows a portion of a larger document. AppKit will now ask the application to render extra content in small chunks when the system is otherwise idle?

Notice that we are not changing the threading model of AppKit in any way. All the rendering still takes place on the main thread as usual. But since this happens in small chunks as long as your application can render that content quickly enough if we never block them in main thread for long and interfere with the user in any way. Also, so that we can easily give the memory back to the system in case we get in the high memory pressure, they're storing this overdraw of content in purgeable memory.

Now, when the user initiates a scored event, AppKit can respond immediately [inaudible] of the available overdraw. So AppKit will stop at the attempt scoring with a perfect 60 frames a second as long as there are sufficient overdraw available, but at the same time right from the beginning of the event working with your app to draw even more content for the download document.

So chances are that by the time the scored event has reached these new areas, the application is already had time to finish rendering those as well. And the net result is that became as long as your application can render that content quickly enough often achieve better, smooth 60 frames a second for the entire scroll event.

Responsive scrolling takes effect automatically for most applications linked against our latest tested case. There is no special adoption required, but they did add a few methods to end this view and in the scroll view that allow you to customize the behavior in case your application has special needs.

Next, let's talk about App Nap. The perhaps most effective way we found to lower power consumption of the overall system is the new App Nap feature. It focuses system resources on the user -- on the work that made us the most to the user right now, while at the same time drastically scaling back the resources being offered to applications that aren't as critical to the user at this point in time.

App Nap takes effect after a short delay, but once an application naps if it see a reduction in priority for I/O and CPU -- for I/O and CPU time. And also, maybe most importantly, if it see any time as it sets up being rate limited. We found that unnecessary, in two frequent timers and one of the largest sources of unnecessary power drain in the system.

So we are quite aggressive with our RAID limiting, napping apps, received events, time events, only every 10 seconds or so. And the -- even aligning the time as of all the napping apps so that don't end up breaking up the CPU individually, but instead perform their work together at the same time.

To decide whether an application can nap, we take a look at manufactures. The decision is fairly easy if a user for example hides an application. But the -- even monitoring things like drawing activity of backgrounded apps. So that applications that are in the background may be possibly occluded by other windows to -- for you to App Nap if they don't update the UI in any visible way.

Another factor we take into consideration is whether applications have declared in power assertions. This is an area that is going to be more important going forward. Applications need to tell the system if they are performing any work that the user still expects to finish quickly even if the application is being backgrounded.

For example, a long running file export. And the easiest way to do that as to the new NSProcessInfo API was listed here on the slide. Now, to show you a little bit more about how App Nap works, I'm going to ask Max Drukman to come up on stage again for another demo.

[ Applause ]

Thank you [inaudible]. Can we switch to the demo machine, please? All right. Here is the Mac version of the game I was working on earlier and now we can all thrill as I implement power assertions. Now, just kidding. I'm going to show you App Nap in action and some features in Xcode 5 of course that can help you spot performance problems you might not have known you had. We're going to run my app.

Here it is. But before we look at the app, let's look at Xcode and see what it's showing us. I'm going to zoom in so we get a good look. Now, in the debug navigator, we showed you what we were calling debug gauges. There is one each for CPU, memory and energy impact. There's super low overhead and they're great for spotting problems with your app.

Here we can see that my app is taking, well, zero CPU, the memory is stable and the energy impact is low to zero. That means this view in this app is doing great. It's a good citizen. Nothing much to see here, move along. But now let me show you a problem scenario that in the past was kind of hard to spot.

I'm implementing a new feature behind this map button. And what that does is it allows my users to bring up a level map in the game and see where they are as represented by this pin in the center as well as other players around the world who were playing on the same level.

Now, the position of the other players is provided by a server. There are obviously aren't any players yet, I'm still developing here, but the codes in place to provide that information. But if we look back in Xcode we can see that there is some trouble. My CPU and energy impact gauges have spiked up and kind of stayed there. Let's have a closer look.

When you select a debug gauge in Xcode, you see its report in the editor area. The report gives you the current status as well as a view over time and a button that even allows you to dive directly into instruments right away if there's a problem you spot and wants to deeply analyze.

The memory report is similar with the current and overtime views. Energy impact provides that data as well as your App Nap status and various aspects of power usage. Each of which has a button that allows you to analyze that aspect in the instruments. Now, let's start with CPU here.

High CPU usage is often associated with drawing, but it sure doesn't look like my app is doing any drawing. Luckily, Xcode 5 has given us something that can help us with that. We've added Cocoa view debugging support so I can do something like turn on view drawing. And now, every time a view redraws, I get a highlight.

[ Applause ]

Oh, well, you may be thrilled by that but of course, what this tells me is that I didn't do a very clever thing. My map pin is redrawing itself all the time even though it isn't moving. The one clever thing I did do, however, is add a debug menu so I can turn off draw updating. There, problem solved.

[ Laughter ]

Now, my CPU is looking good but my energy impact is still kind of high. Let's see if App Nap helps us with that. I'm going to maximize Xcode so that my app is behind and would -- should get App Nap to kick in. Now, on this machine, I've set App Nap to kick in quicker than normal and hopefully we're going to see it any second now.

And, there it goes. Now, App Nap has done its thing and my app is now driven to zero energy usage or almost. Notice that I'm getting little blips on the graph. Now, as Andreas told us earlier, that's indicative of a timer firing. And sure enough, I've got a timer firing.

Yet another bad pattern. I've gone with here is that my app is pulling the server for user updates instead of waiting for a notification. That's not a great design pattern but it's one who's impact was kind of tough to spot before. After all, I wasn't seeing poor graphics performance or beach balling or my fan spinning. But that doesn't mean there wasn't a significant energy impact going on.

So, even though App Nap does the right thing for your users, it really pays to do the extra work to make your app also a good energy citizen whether it's active or it's napping. And Xcode 5 gives you the tools to make that possible and easy to do. Back to you, Andreas.

[ Applause ]

Thank you, Max. There's a few more APIs and behaviors I'd like to cover starting with our new margin monitor support which makes using [inaudible] displays even more powerful and flexible. Do you think this is going to work especially great for all pro-users who often work with multiple apps at the same time?

And by the way, it also works well to the Xcode that you can run Xcode on one screen and the back end application on the other screen. Now, we also believe that the new behavior to make it more likely that users will choose to go into full screen modes. So now more than ever it's worth spending the extra time on implementing a great full screen experience in your own apps.

Now, there's a few behaviors you might have felt like in the past that don't hold through anymore. Most importantly, there's no distinction between primary and secondary displays. So, an app cannot assume anymore that it has the entire screen available to itself on another display because now the doc and the Menu bar show up there as well. You might want to validate that your apps behave properly under these new conditions before we ship Mavericks later this year.

Another exciting change in Mavericks is the TVs can now act as fully independent displays via AirPlay. AirPlay is not limited to mirroring the primary screen anymore. That opens up whole new ways for you to innovate. If your apps would benefit from the special presenter display, AirPlay is now an even more attractive option. We're looking very much forward to the new ideas you guys are going to come up with to leverage this new capability.

Next is Map Kit. If you brought Map Kit over to the Mac, that's practically the identical API that many of you are already familiar with from iOS. So you can now have beautiful fast vector-based maps integrated with your Mac apps as well. In addition to creating the actual maps application, they started using this new API [inaudible] in Mavericks in various ways.

For example, by adding a new data detector, all by supporting map locations in the calendar app. Map Kit is a really fantastic edition to the OS X API. And just like with our other cloud services based APIs, it's available to apps shipping through the Mac App Store that declare the use of Map Kit as a capability.

Now, there's numerous more APIs in Mavericks that I do not have time to cover in this session. AppKit has a fantastic new stack view. They even added things like vec notifications. But you'll also push notifications to a Mac even if you don't have a native application for it. You can learn about many of these APIs here in later sessions at the conference. But for now, I'm going to hand over to Matthew Firlik to tell you more about Xcode 5.

[ Applause ]

Thank you, Andreas. Xcode 5 is our latest tools release for iOS 7 and OS X Mavericks. And it is packed with features I think you guys are going to love. From the earlier demonstrations you've seen Xcode's new clean interface design. This design surfaces Xcode's familiar workflows and features. It works to minimize clatter and really put the focus on the controls and your content.

To highlight your content, we'd worked to reduce the application chrome. Compared with the previous release, our toolbar is 30 percent smaller. And its work is great on small displays. We've also focused on improving the activity view. You now see more details for your activities, bigger icons for issues, and overall progress is much easier to see.

And throughout the interface, you'll see our design focuses on removing borders, simplifying items, and through this use of a simple blue highlight presenting a feeling of seamlessness and fluidity throughout the ID. Now, a focus on simplicity does not mean a lost in functionality, actually quite to the contrary. In most cases, we were able to put more functionality in a smaller space.

The UI for looking at project-wide finds is a really good example. Comparing a new UI to the previous release seen here on the left, you can see that we were able to put the same functionality in less than half of the space. And in a way that is far easier to use.

Now, with the additional real estate, we wanted to bring to the surface even more of your content. In the previous Xcode release, search results were shown at a single line displace. Xcode 5, we're bringing in wrapping. So, now, you can see even more context for your search results.

[ Applause ]

And if that wasn't enough for bringing the same display to issues as well. So for errors and warnings --

[ Applause ]

-- not that that you have issues, but for all the errors and warnings that might come up for all the other guys, you can see all of the details. Now, another area of focus for us is documentation. And we have a brand new interface for you. Documentation is now its own separate window using all of the new design elements. Now, on top of some great documentation content, you now have better and faster searching, scrollable search results, tab based browsing, and a great book marking system so you can work with multiple documents really easily.

[ Applause ]

And if that wasn't enough, once you find a document that you like, the new integrated table of contents makes it really easy to browse and navigate the content.

[ Applause ]

You'll see elements of a new design throughout our interface, and it really focuses on surfacing the value of the technologies that are underneath because the same time that we are changing things you can see on the front end. We were doing a lot of work on the back ends too in ways that you won't be able to see but you will definitely feel.

Xcode 5 has been converted over to Automatic Reference Counting or ARC. And as part of this transition, we have some awesome performance wins to share with you. Many of the tasks, new perform every day, are much faster in Xcode 5, things like searching and incremental builds are up to twice as fast. And working with tabs, devices, and project editor is quicker than ever.

[ Applause ]

Inside and out, Xcode 5 really sings. So on top of the new UI and its great foundation of faster technologies, we've built some amazing new features. And it starts with interface design. Xcode 5 provides access to the latest views and controls for iOS 7 and OS X Mavericks. So, you can get started today using all of these new UIs and features in your application.

And, Max demonstrated three new editions to our design tools. The new workflow for Auto Layout, the Asset Catalog, and the new Preview Assistant for iOS. These features in concert with other editions to interface builder, make it easy for you to design applications that look and feel great for all of your users.

Now, Mac still a little bit of the Thunder 2 and showed you another great addition to Xcode 5 in the form of debug gauges. The debug gauges provide a way for you to ensure your application is behaving exactly as you expect. You now have CPU memory and other information available to you at a glance and in a way that is really easy to track.

The integrative reports provide even more detail on the performance of your application. So you can dig in when issues arise. Now, as Max noted, the gauges perform high level profiling in a super efficient manner so as not to interrupt with your own applications performance. But when you need more information, the power of instruments is just a click away. We'll launch a session automatically configured to your application and you'll get all the information you need.

Now we have gauges for CPU, memory and energy and two others in the form of iCloud and OpenGL ES. And these gauges present themselves automatically when you start using these technologies. So we think debug gauges are going to be a great way for you to monitor, maintain, and improve the performance for your applications. But we didn't stop there because we have some other great additions to the debugging technologies.

First up, our debugging services. Xcode provides new functionality to help you during development. For example, we can simulate a backgroundd fetch for iOS 7 making it really easy for you to adapt to the new API. We can also simulate location changes for iOS and OS X which are great to use with colocation and with maps. And a cocoa view debugging that Max demonstrated before is a great way for you to be interactive with your application and see things you might not been able to before.

Another area of focus for us was on presentation of variables. A new variables view is simple, clean, and compact. And the improvements of the data formatters really highlight the essential information. But, we know that not all objects present themselves well in summary or in textural form. So for this release we've integrated a technology that should be very familiar to you right in the debugger in the form of Quick Look.

Now, in the variables view and in the editor across every variable, you will see a Quick Look button. And in this case, a poke in the eye is actually a really good thing. We now have Quick Look support for common geometric types like points, rects, sizes, and bezier paths.

[ Applause ]

Working with plain or rich text, super easy. Media types like images present themselves really naturally. Object types like Pads and URLs actually resolve to their remote content whether it's a website or a local document.

[ Applause ]

And when running on OS X Mavericks, locations present themselves using the gorgeous new map view. These are just a few of the Quick Look support we've innovated in the debugger and I'm absolutely certain you guys are going to love this. So the combination of debug gauges, debug services, and the Quick Look for variables, all great ways for you guys to get more information about your applications.

Now, debugging is generally about getting your application into a working state. In contrast, unit testing is about keeping it in that state. We feel that testing is a really essential component to writing a great application. And for this release, we're providing some new powerful testing tools for you to use. And to show you a little bit more, I'm going to give you demonstration.

[ Applause ]

So here we have the Adventure project that Max and I have been working on. Max has been adding some of the configuration screens. I've been working on adding some new villainous characters and some additional game play options. Now along the way, Max and I have been writing unit tests to make sure that we're staying on track and then we're not regressing. And we've been using some of the new features of Xcode 5 with that.

One of the new features I've been using is the new test navigator. When I select here on the left hand side, the test navigator now shows you all of the tests for your project organized by test class and by test case, making it really easy for you to navigate and select an item. The navigator can show you all of your tests or just the ones that are configured for your current scheme.

Now as you might expect, I made some changes to my project right before coming up on stage. And I like to see how I'm doing. So we'll go ahead and perform the test command here and see the results. And you can see that the status for all of my tests is now displayed in the test navigator. All of the passing tests are in green and the failing tests are in red. We can see I have a couple red icons here so we know that -- I probably shouldn't check this code in quite yet.

Let's select one of the failing tests. This test is testing that the chase radius for one of my anime characters is actually larger than the character himself, seems to make sense. I'd like to actually debug this test to figure out why it's failing. And to do that, I'm going to use a new feature of Xcode 5. I'll put a breakpoint in my test. But in order to just work on this one test, I'll hover over this indicator. And you'll see it turns into a play button. This gives me the ability to run just this one test.

[ Applause ]

Actually, this feature is even cooler. Anywhere you see this status icons you get the same functionality. So if I clicked on the icon at the class level it would perform all the tests in the class at the bundle level, all the tests with a bundle and so forth. For this case, I just want to run this one test. So I click here, and it's going to build and now I'm stopped here right into my test.

To debug this a little further, I want to get some information on the variables to make sure that the values are as I expect. I'll hover over the chase radius here and if you can look really closely, a little tool that pop up showing that that the value is 8,000, that's correct, that's what I expected to be. Let's take a look at this next piece. I have an image for the character. I want to make sure that it's the right one. I'll hover over it and click the little Quick Look icon and there we go. There is a picture of my boss.

[ Applause ]

Actually, I want to clarify a second. I said that's a picture of my boss. It's not actually a picture of my boss, it's picture of the character in the game. All right. Let's move on. I can also check the size of the character is correct and that looks right. You know what? I see the problem here. It's actually just a logic error. I use greater than instead of less than. So let me fix that and remove my breakpoint. And let's run the test again to make sure that that fix is correct.

And sure enough, my test succeeds, the indication is updated and now I know that I can move on. So just like that I was able to use the navigator to get to my tests that are failing, used the status indication in your workflows to focus on this one test.

Now, we've seen the navigator, I have some other failing tests. They're little bit strewn out across my project. I'm going to turn on the filter at the bottom of the test navigator to show me only the failing tests. Now, I see here that I have three or four tests that look all the same and are failing in a similar way.

Earlier, I added some new functionality to the game, a new way for anime characters to meet their maker, so to speak. It's affectionately known as splort [phonetic]. You can imagine what it does. To test for this, I first look for the characters health to be non-zero beforehand, tell them to splort and then test afterwards to see that is zero. This test is failing. Now the test itself is relatively simple, so it's probably somewhere in my AppLogic. That's okay, we can take a look.

I'll command click on the API to jump right to it. And this kind of highlights are really interesting scenario where sometimes you'll be working on your tests and sometimes you'll be working on your API. But often you want to correlate between the two. To make sure you're making decisions correctly on both sides. Xcode 5 provides a really great way to do this. Let's collapse the navigator to give ourselves a little more room.

With -- my focus inside of this method, I'm going to click on the related files pop-up here and we'll see that there are two new categories. Test classes and test colors. I'm going to hold on the Option key and select the test colors, and have it opened up in the assistant editor. Now, what is this showing me? It's showing me on the left hand side my API. And the right hand side, it's showing the tests that directly call that API. Making it really easier for me to correlate.

And actually, this is really helpful in this case because I see that my test is testing for health, but I don't actually use that value any over here in my actual method. And it turns out that's my fault. What I forgot to do was to call super, when I implemented this method. So let's go ahead and fix that. And while I'm still in the assistant here, I'll just run my other tests.

Sure enough, that was the fix. We'll use the power of this system here to just flip to the next one and make sure that that one is fixed too and, yep that was my problem. So just like that, I was able to correlate my API and my tests and work with them together to fix my problem. So that was just a quick view of some of the great new testing features in Xcode 5. Let's go back to slides.

[ Applause ]

So the new unit testing features of Xcode, the test navigator, the assistant editor, and the new workflow integrations, all great ways for you to make testing a seamless part of your development workflow. Now, another investment for us in the area of testing was in the test framework itself. And for this release, we are announcing a new framework XC test.

XC test is derived from OCUnit. And for this release we've made some minor enhancements. Going forward, XC test will be our vehicle for providing great testing features for you. Now Xcode 5 continues to include OC unit and it includes a powerful migration utility for you to convert over whenever you're ready. Now, from all the feedback you've provided, the number one request you've had in the area of testing is better ways to integrate it into your automation systems. And with Xcode 5, we have a great new option for you in the form of command line testing.

[ Applause ]

I didn't know a terminal window is so exciting. The test command is now fully supported from the command line. And this command mirrors the test action inside of the IDE. So, your investment in setting up your schemes and your test plans now pay off beautifully inside the IDE and out. The command allows you to specify the destination you'd like. So, for example, you can target one of the simulators. As you might expect, you can also target a connected device. And, as a little gift to you guys, you can also specify multiple destinations in a single invocation.

[ Applause ]

So we think this is going to be a great addition for all of your workflows. Apple IDs. Your Apple ID is your identity, but it's also your key to communicating with Apple. And for this release we've made Apple IDs simple and more powerful to use. Xcode 5 now includes a new Accounts pane to manage all of the Accounts that the ID will use.

Entering your Apple ID gives you access to all of the assets necessary for App Store development. And for those amongst you who have multiple Apple IDs, you can enter them all into the panel here and select which one you want to use at anytime including specifying them per project.

[ Applause ]

And to take things a step further, we've built some great functionality on top of this in the form of Automatic Project Configuration. Wrong button there. Automatic Project Configuration. So, with each platform release, we give you guys amazing new features and capabilities, each with their own options and also with some requirements. And we wanted to make it really easy for you guys to get started with these features. So, we've built a section of the Project Editor dedicated directly to each of these capabilities with all the necessary requirements and options in one place.

And getting started with the feature is really easy. It's a simple matter of flipping a switch. Doing so, let's extra -- make all of the necessary changes to set up your machine for development. That includes changing project settings, adding frameworks, setting entitlements, and making all of the requests and downloads necessary for App IDs, provisioning profiles, and certificates.

[ Applause ]

From start to finish, you can stay in Xcode and focus on the work you want to do and frankly let Xcode do all of this work for you. We wanted to provide also some great source control features for you to use. And in order to do that, we re-imagined and redesigned our workflows to integrate them directly into the project life cycle.

In Xcode 5, you will find a new top-level Source Control menu with all of the options you need and accessible at any time in a really simple manner. When you want to access the project for the first time, the new checkout workflow makes that really easy. Select the repository, select the branch, and Xcode will check out your project and open it for you.

Now, once you have the project open, you'll notice the new working copies area of the menu. This provides a list of all the working copies you have opened in your project plus their current branches, making it easy for you to keep track of what you're working on. The Associated Branch menu gives you all of the branch management functions you need, such as creating new branches, switching branches, and merging right from inside the project workflow.

And when you want more detailed information about what's changed in your working copy, the Integrative History View provides a browsable and searchable display that works across all of your working copies. For this release, we've really focused on giving you guys great Source Control tools. We've added functionality to the editor, giving you the preferences and integrated Subversion 1.7. So, for all of you not using Source Control today, I highly recommend you guys give this new features a try.

Continuous integration. For those of you not familiar with this term, Continuous integration is the practice of taking changes from many developers and merging them frequently. Ensuring the code builds, your tests pass, and that generally your project meets your requirements. By integrating frequently, you can minimize the effect of any individual change, often known as integration hell.

Now integration systems need to provide a myriad of features. And they need to fit well in your development process. One item that is often missing from these systems is tight IDE Integration, which you want are continuous integration systems that are an extension of your development process. In fact, you want them built on the native concepts of your tools. And for Xcode 5, that's exactly what we've done in the form of bots.

[ Applause ]

Cool icon, even cooler technology. Bots are continuous integration systems that -- well, bots are tasks and they run on OS X server. And their primary reason for being is to do your bidding. So bots use the Xcode 5 technologies to perform integrations, which are sorts of tasks like build, test, and analyze. And to get to what the final -- the slide finally says here, I'm going to show you a demo of how bots work.

So here I have the iOS version of a project. Now, behind the scenes here, my team has set up a Mac mini and installed the latest OS X server. And we've created bots for all of the projects that we're going to use throughout WWDC. For me to take advantage of the bot, all I need to do is add the account to this Xcode instance. So I'll bring up my preferences here and we see the new Accounts pane.

I'll click the plus sign and say Add Server. Now we see that on my Mac mini is broadcasting over Bonjour. I can select that and I'll enter my extremely secure credentials. Now, when I click Add, I want you to watch in the left hand side in the project navigator. You see when I click Add, a new item appears. That's my bot.

What we're seeing here is the log navigator which normally presents all of your local actions. We wanted to integrate the bot into the log navigator so you could correlate what the bot is doing for you with all the work you see locally. Selecting the bot is going to show me the integration summary. And here it is. And there's a lot of information going on here.

[ Applause ]

Across the top, you're seeing the integration results. These are the kind of statistics of the last run -- errors, warnings, analyses, and tests. We see I have zero errors, so my product is building successfully, but I still have some issues I should probably be resolving. Across the middle of our charts that display the relative recent history of my bot, for things like builds and tests.

We can see that I've had some warnings happen for a while. We can see this integration here right in the middle with the red bar, that's one that actually failed. On tests I'm not doing too badly. The green are all the tests that passed. But it looks like we had some failures introduced recently. I should probably look at that.

Across the bottom are the integration details. These are the specifics of what happens during this integration. They might look kind of familiar, it's very similar to the style we present them in the bill blogs. And in fact they work very similarly. I'll double-click on our olm here and it's going to take me right to that place in my source code.

Now I want to point out what this is doing. It's taking information the bot gave me and presenting it right inside of my project. So now I can change the source code, integrate it, and push those changes out. So it's a really great integration between the two systems.

We'll go back to the summary here and look at some more information. One of the really valuable things about the bot is doing for me is testing. And if I select the Test tab across the top, we'll see the test history for all the integrations that have happened recently.

Across the top is a timeline that shows me my test history. You can see my tests have been building up over time, but recently, it looks like we had some tests not get performed but it looks like we're back on track. I could actually grab this loop and move it anywhere back in time and look at the test history to get more information on a particular issue.

The bottom section is showing me a combination of pieces of information. The rows are all of the tests in my project. The columns are the integrations or the actions the bot are performing. So we can see here, this is when some of the tests were created the first time they were run. We can also see where tests failed. This column right here, this is the integration that failed and none of my tests ran. So it gives me a great way to kind of see how the evolution of my project has gone.

Let's say we wanted to investigate this particular test issue, well I have a couple options. One would be to double-click on it and navigate to the source code like I did before and try to fix the problem myself. Another option though would be to look at the integration and see who made the changes and get them to fix it.

Well, I'll do that one right now. So to do that, I'm going to double-click on the Integration, and jump to the Integration Details. This is similar to what I was saying before, it's showing me the results and it's showing me the specific details below. But there are some other tabs across the top that will provide additional information. I'll select the Tests tab and we'll now see here are the results from my tests.

Important thing to note here is it's also showing me the devices it was running on, this bot is running all of my tests on three separate devices, an iPad and two iPods. Now, my test is failing uniformly across all of them so it's probably a logic failure, but this would be a really great way for me to be able to test if different devices cause problems for my app or even devices running different OS's how my tests do.

I'll select the Commits tab across the top and look to see who made the change and up it was Max who made this change, so we can blame him. Actually this is probably difficult for you guys in the back to read, but if I read the commit message it says, "Re-enable tests that should have never been disabled."

If I wanted to figure out more about what Max means by that, I can just click on the Show Modified Files, and it's going to show me that very familiar comparison view of the changes for this integration and sure enough looks like Max took out some comments for some tests. We should probably go and fix that. But right here you can see the bot is doing a bunch of work for me, building, analyze, testing and I can get that information right here inside of the IDE quickly and easily.

So, this is just a little bit of the power of bots. What I'd like to show you next is how easy it is to create one. We already have one from my iOS project here. So, let's bring up the OS X project I had before and create a bot for this. Creating a bot is as simple as going under the Product menu and selecting Create bot.

The first question it's going to ask is what I want to build. And this is going to be a very familiar list of all the schemes in my project. I'll select this one, the project I want or the item I want. My servers are already selected, and I'm going to leave this box checked to say integrate immediately, we wanted to kick off and start doing this work.

I'll select Next. And I now have some options for when and what the bot does for me. I can set the schedule to go on periodically at a certain time, manually at my request or uncommit. I'm going to select uncommit because I want the bot to do this work every time someone makes a change. I'll leave the default actions checked, I wanted to analyze, test and create an archive of my project when it's done.

I'll select Next. And the bot now provides me access to send out email notifications when integration is successful or when it fails. I definitely want people to know when they break something, so I leave this check box enabled and we'll click Create Bot. That's it, Xcode and the server have not communicated to create a bot for this project. And here it is it shows out in my navigator.

So, just like that I was able to make use of the continuous integration system to start tracking my project. Now, it's going to take a second here to perform the integration. So, in the meantime what I want to do is show you some other features we have in the system.

In order to keep track of all of the projects you might be using, we have an integrated web view. You can see here a list of all the projects that I have, their current status and the ability to interact with them. In fact I can go ahead and click on anyone of these to create an integration or download the product of any of these bots.

So, this is a great way for engineering, QA, and other groups to leverage the value and the power of the continuous integration system. But to keep everybody kind of on a level playing field with how things are working, we also want to provide a really interactive and fun display and we've done that in the form of Scoreboard.

[ Applause ]

The Scoreboard presents a view of all of the bots that are running on my server. On the left hand side you can see the projects and their current status; on the right hand side you can see the details. Integration results the commit logs and devices that it was running on.

And you'll see that it cycles through each one giving me the details, it happens to hang out a little bit longer on failed ones which is not good for me right now, but you'll see when it actually switches it will give you the details about each including who made the changes.

So, this is a great way whether it's running on TVs or monitors around your office, or just running on your desktop for you guys to keep track of how the continuous integration system is working, the status of your projects, and frankly who the heroes and the villains are in your own office. And that's Continuous Integration with Xcode 5.

[ Applause ]

So, bots and Continuous Integration. At the heart of this solution is OS X server. OS X server continuous deliver powerful services such as mail, calendaring, and wiki, and the Xcode service now joins them to deliver continuous integration. And running OS X server is easier than ever. The set of experience has been redesigned and simplified and in literally just a few minutes you can have the server up and running on your network.

Now the Xcode service leverages many of the functionalities and features of Xcode 5 including the Apple ID integration, unit testing, and source control features. And layers on top elements like Bonjour discovery, repository hosting, and the new web client, and Scoreboard. The combination of these features is a continuous integration system that you, your team, and your entire company can use to deliver great iOS and OS X applications.

Xcode 5, we have a ton of great features for you in this release and I'm pretty sure you guys are going to love them. With Xcode 5 you should be able to build applications better, faster, and easier than ever, and we're really excited to see what you do with it. Thank you.

[ Applause ]

Thank you, Matthew. All right. So we announced three major new products to you today, iOS 7, OS X Mavericks, and also Xcode 5. They contained fantastic new features for end users and developers and we recommend that you use the next few months to get ready for us launching these products later this year.

To get you started, you're going to make developer previews of all these products available for you today. So, you'll be able to go to the WWDC attendee website later this evening and download previews of iOS 7 for your iPhones, iPads will come a little later, OS X Mavericks, Xcode 5 with the SDKs for both of this new OS's and even the new server app for Mavericks which allows to try out a new continuous integration features that Matt just showed you.

There will be numerous opportunities here at the conference to learn more about these products, we have done more than 100 sessions where you can learn about what's new and different, and many labs we have organized, excellent opportunities for you to meet within many [inaudible], see you on site to get your questions answered right here.

A few sessions that you might find particularly interesting, tomorrow we're going to start the day with the developer tools kick off, and another session I'd like to point out is the maximizing battery life session with [inaudible] tomorrow who would tell you about more about power consumption on OS X. And with that I hope you enjoyed the session, I'd see you around this week.

[ Applause ]

[ Silence ]

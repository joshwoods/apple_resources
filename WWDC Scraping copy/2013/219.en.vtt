WEBVTT

00:00:10.066 --> 00:00:11.306
>> Alright, good
morning everyone.

00:00:12.116 --> 00:00:13.926
I'm Doug Davidson, and
I'm here to talk to you

00:00:13.926 --> 00:00:15.646
about making your
app world ready.

00:00:18.236 --> 00:00:20.816
So, the app store
is available in more

00:00:20.816 --> 00:00:23.026
than 150 countries worldwide,

00:00:23.486 --> 00:00:26.906
and if your application is
only targeted at one of them;

00:00:27.196 --> 00:00:29.566
not only are you missing
out, but also a lot

00:00:29.566 --> 00:00:31.936
of your potential users
are being deprived as well.

00:00:32.366 --> 00:00:36.566
So, we're going to tell you how
with a little additional effort,

00:00:37.066 --> 00:00:39.236
you can make your app ready
for international use.

00:00:40.106 --> 00:00:42.556
The steps to go through
are fairly simple.

00:00:42.696 --> 00:00:45.476
In many cases, we find
that what you have to watch

00:00:45.476 --> 00:00:48.416
out for is assumptions
that you may be making;

00:00:48.526 --> 00:00:49.836
maybe even unconsciously,

00:00:50.186 --> 00:00:52.406
that just don't hold
everywhere in the world.

00:00:53.086 --> 00:00:55.466
And, so we'll be
talking a lot about that.

00:00:55.506 --> 00:00:58.186
Often, it's not things you don't
know that will hurt so much,

00:00:58.186 --> 00:01:00.266
as the things you do
know that just aren't so.

00:01:02.146 --> 00:01:05.476
Now, there are some
genuine challenges here.

00:01:05.476 --> 00:01:09.706
Our customers around the world
use many different languages,

00:01:09.756 --> 00:01:11.276
many different writing systems,

00:01:11.696 --> 00:01:13.866
and they have often
significantly different

00:01:13.866 --> 00:01:18.246
expectations after the
presentation of items like dates

00:01:18.246 --> 00:01:19.616
and times and numbers.

00:01:20.046 --> 00:01:23.916
But, fortunately, the frameworks
are designed to handle this,

00:01:23.916 --> 00:01:24.756
if you work with them.

00:01:25.396 --> 00:01:28.216
Now, I say frameworks,
it's important to note

00:01:28.476 --> 00:01:30.366
that almost everything
we're going talk

00:01:30.366 --> 00:01:34.226
about here today applies
to both iOS and OS X.

00:01:34.226 --> 00:01:37.546
Now, we're going to do
this in three parts.

00:01:37.826 --> 00:01:39.596
The first is about localization.

00:01:40.006 --> 00:01:42.996
Localization refers
to the language

00:01:43.446 --> 00:01:45.906
in which you application's
user interface is presented.

00:01:47.116 --> 00:01:50.266
Your job as a developer
is to make sure

00:01:50.266 --> 00:01:53.566
that your application is
localizable, so that you can go

00:01:53.566 --> 00:01:56.776
to the localizer, who
will translate the text

00:01:56.776 --> 00:01:59.786
in your user interface into
any particular language,

00:02:00.326 --> 00:02:03.526
then all you have to do is
decide how many languages you

00:02:03.526 --> 00:02:04.406
want to do this for.

00:02:05.536 --> 00:02:08.716
Second, we'll talk about
locale data, and that refers

00:02:08.716 --> 00:02:11.856
to presenting things like
dates and times and numbers

00:02:11.856 --> 00:02:13.646
in a way that's intelligible
to people

00:02:13.646 --> 00:02:15.066
in that particular region.

00:02:16.026 --> 00:02:18.366
And, finally, we'll talk
about handling texts

00:02:18.446 --> 00:02:20.956
and all the different writing
systems used around the world.

00:02:20.956 --> 00:02:26.336
There are two main settings
that are involved here,

00:02:26.536 --> 00:02:28.506
and this is what they
look like on iOS.

00:02:29.106 --> 00:02:31.796
The first is the user's
language preference,

00:02:31.936 --> 00:02:33.016
and that's what determines

00:02:33.016 --> 00:02:35.546
which localization
your app will run in,

00:02:36.616 --> 00:02:39.696
and the second is the
user's region preference,

00:02:40.166 --> 00:02:43.966
which determines what their
locale settings will be.

00:02:44.516 --> 00:02:49.806
On OS X Mavericks, we have
an entirely new pref pane

00:02:49.856 --> 00:02:50.866
for handling this.

00:02:50.866 --> 00:02:52.766
It's designed to streamline it,

00:02:52.766 --> 00:02:55.336
and make changing
the settings simple,

00:02:55.336 --> 00:02:56.556
and make it all more logical.

00:02:56.796 --> 00:02:57.556
It's very similar.

00:02:57.626 --> 00:03:00.136
You have the user's
language preference again

00:03:00.136 --> 00:03:02.416
that determines what
localizations will be used,

00:03:03.006 --> 00:03:04.376
and the user region preference

00:03:04.486 --> 00:03:06.136
that determines the
locale settings.

00:03:06.556 --> 00:03:10.896
Additionally, on OS X,
there is an advanced sheet

00:03:10.956 --> 00:03:14.106
that allows the user to
customize in great detail,

00:03:14.106 --> 00:03:17.866
if they want to, any of the
various settings that are part

00:03:17.866 --> 00:03:19.096
of their locale preferences.

00:03:20.126 --> 00:03:23.706
So, to start off with, we'll
talk about localization.

00:03:23.706 --> 00:03:26.756
I'll bring up my colleague,
Albert Lund to talk about that.

00:03:27.516 --> 00:03:31.896
[ Applause ]

00:03:32.396 --> 00:03:34.616
>> Hello, I'm going to be
talking about localization,

00:03:34.926 --> 00:03:36.826
and what localization is,

00:03:36.826 --> 00:03:38.966
is that it translates
your application

00:03:38.966 --> 00:03:41.536
from its current language
to another language,

00:03:41.876 --> 00:03:45.296
so your app can provide much
more exposure and visibility

00:03:45.296 --> 00:03:47.106
to other markets
around the world,

00:03:47.106 --> 00:03:49.676
leading to more downloads
for your app.

00:03:49.676 --> 00:03:53.526
It's also about adapting your
application to cultural norms

00:03:53.526 --> 00:03:56.756
in those regions, so you
can provide the same level

00:03:56.756 --> 00:04:01.056
of user experience for
all users of your app.

00:04:01.696 --> 00:04:03.626
Now, today, I'm going
to be talking about how

00:04:03.626 --> 00:04:07.026
to use our tools and X codes
to localize your application,

00:04:07.426 --> 00:04:09.376
as well as some common
mistakes and issues

00:04:09.376 --> 00:04:11.676
that may occur when localizing.

00:04:13.186 --> 00:04:17.286
So, here's your project is
structured for localization.

00:04:17.576 --> 00:04:21.156
You have your single binary,
which is your header files,

00:04:21.156 --> 00:04:23.446
your implementation files,
and libraries you call,

00:04:23.666 --> 00:04:26.006
and you only have one
set of these files.

00:04:27.386 --> 00:04:31.486
You also have localization
folders alongside your binary,

00:04:31.666 --> 00:04:34.236
and these are folders
called L proj folders,

00:04:34.236 --> 00:04:36.476
or your language
specific project folders.

00:04:37.116 --> 00:04:40.986
Each localization is placed
into one of these folders,

00:04:40.986 --> 00:04:45.596
and it's abbreviated
by the language.

00:04:45.596 --> 00:04:49.416
So, for example, the English
location is EN, French is FR,

00:04:49.666 --> 00:04:51.346
Spanish is ES and so on.

00:04:52.166 --> 00:04:54.216
All of these localizations
are then placed

00:04:54.216 --> 00:04:55.846
into your single app bundle,

00:04:56.196 --> 00:04:58.226
and one of these will
get loaded at runtime.

00:04:59.056 --> 00:05:01.476
Whichever one gets loaded
at run time is determined

00:05:01.476 --> 00:05:03.916
by what the user selected
system language is.

00:05:03.916 --> 00:05:05.706
So, if the user's
language is Spanish,

00:05:05.706 --> 00:05:07.086
the Spanish localization
gets loaded.

00:05:07.086 --> 00:05:10.496
So, here's how your
project is structured.

00:05:10.496 --> 00:05:13.416
You can see that the L proj
folders are alongside your

00:05:13.416 --> 00:05:15.906
implication files
and your localizers

00:05:15.906 --> 00:05:18.836
or your translators just have
to modify these folders only;

00:05:18.836 --> 00:05:20.196
they don't need to
touch anything else.

00:05:21.496 --> 00:05:24.736
These folders contain things
such as your strings files,

00:05:24.736 --> 00:05:27.496
which contains things such
as your user visible text,

00:05:27.896 --> 00:05:30.486
as well as any resource
files, such as images

00:05:30.486 --> 00:05:32.886
and anything else you might
want to use for localization.

00:05:32.886 --> 00:05:36.776
So, let's get started on
how to localize things

00:05:36.776 --> 00:05:39.776
such as your interface files or
your nib files or storyboards.

00:05:40.546 --> 00:05:43.206
The old way to do this, and
you can still do this today,

00:05:43.206 --> 00:05:46.196
is to make a copy of
every single nib file

00:05:46.196 --> 00:05:47.956
for every single
localization you have.

00:05:48.626 --> 00:05:50.116
Your localizers then just open

00:05:50.116 --> 00:05:52.746
and modify the specific
interface file

00:05:52.746 --> 00:05:55.486
for that specific
localization, modify the text

00:05:55.486 --> 00:05:57.456
so it's localized, and make sure

00:05:57.456 --> 00:05:59.016
that everything surrounding
it looks good

00:05:59.016 --> 00:06:00.386
and works for this interface.

00:06:01.466 --> 00:06:03.166
Like I said, while
these work today,

00:06:03.166 --> 00:06:04.326
if you want to localize
this way,

00:06:04.326 --> 00:06:06.666
you can see this
gets very cumbersome,

00:06:06.666 --> 00:06:10.666
and can be very time consuming
for you and your localizers,

00:06:10.886 --> 00:06:13.076
so we highly recommend
you use this method called

00:06:13.156 --> 00:06:14.366
base internationalization.

00:06:15.386 --> 00:06:19.116
With base internationalization,
you only need to modify one set

00:06:19.216 --> 00:06:21.406
of storyboards and nib files,
so you don't have to worry

00:06:21.406 --> 00:06:23.686
about localization when it
comes to your interface.

00:06:24.556 --> 00:06:26.906
Every single time you
create a new localization,

00:06:27.506 --> 00:06:29.676
a strings file, which
basically takes all

00:06:29.676 --> 00:06:34.286
of the user visible text out of
your nib file, is then placed

00:06:34.286 --> 00:06:36.166
into those specific
language folders,

00:06:36.546 --> 00:06:40.026
and your localizer just has to
modify those, the text only.

00:06:40.076 --> 00:06:41.446
They don't need to touch
your interface at all.

00:06:42.556 --> 00:06:45.446
Now, it's highly recommended
that you should use auto layout

00:06:45.446 --> 00:06:46.846
for base internationalization,

00:06:46.846 --> 00:06:48.896
and I'll explain what auto
layout is in a moment.

00:06:49.406 --> 00:06:52.926
But, here's an example how base
internationalization works.

00:06:53.026 --> 00:06:54.506
I have my one nib file here,

00:06:54.886 --> 00:06:58.136
and this is my base
internationalization file.

00:06:58.816 --> 00:07:01.666
As a developer, I only need
to modify this one file,

00:07:02.056 --> 00:07:04.456
and every single time I
create a new localization,

00:07:04.496 --> 00:07:06.646
a strings file is then
generated for every single one.

00:07:07.486 --> 00:07:11.256
From there on, my localizers
then do not touch anything

00:07:11.256 --> 00:07:12.146
involving my interface.

00:07:12.206 --> 00:07:13.756
They only need to
modify the strings,

00:07:13.756 --> 00:07:16.526
and that's really convenient.

00:07:17.816 --> 00:07:19.506
So, what's auto layout.

00:07:20.126 --> 00:07:23.826
Auto layout is a way to define
the constraints between text

00:07:23.826 --> 00:07:26.766
and anything surrounding your
text, such as text views,

00:07:26.766 --> 00:07:28.596
UI image views, and
pretty much anything

00:07:28.886 --> 00:07:29.816
that surrounds the text.

00:07:30.526 --> 00:07:33.806
It is a way to appropriately
resize everything depending

00:07:33.806 --> 00:07:36.486
on the length of the text, which
is crucial for localization;

00:07:37.066 --> 00:07:39.476
the reason being is that when
you translate your application

00:07:39.476 --> 00:07:40.886
from one language to another,

00:07:41.356 --> 00:07:44.306
some translated strings may be
significantly longer or shorter,

00:07:44.306 --> 00:07:46.826
and you want to be able to
dynamically adjust these,

00:07:46.826 --> 00:07:49.266
so your interface looks good.

00:07:50.076 --> 00:07:51.906
And, to learn more
about auto layout,

00:07:52.006 --> 00:07:54.906
I highly recommend you check out
the video for "Taking Control

00:07:54.906 --> 00:07:56.316
of Auto Layout in X Code 5".

00:07:56.316 --> 00:07:57.176
That was held yesterday.

00:07:58.716 --> 00:08:02.766
So, let's get started on how to
use base internationalization.

00:08:02.966 --> 00:08:05.066
So in my project
window for X code,

00:08:05.066 --> 00:08:08.236
I have this checkbox here called
used space internationalization.

00:08:09.106 --> 00:08:12.836
I check this box, and then
X code will then ask me

00:08:13.276 --> 00:08:17.096
which files do I want to use for
my base internationalization.

00:08:17.096 --> 00:08:19.976
It will then move all
of these interface files

00:08:19.976 --> 00:08:22.876
and any file I want into
the base.Lproj folder,

00:08:23.336 --> 00:08:25.596
and anytime I want to
create a new localization,

00:08:25.596 --> 00:08:27.046
I then push this
plus button here.

00:08:28.556 --> 00:08:30.496
Any interface files
then that are placed

00:08:30.616 --> 00:08:33.376
in the base.Lproj folder
will then generate their own

00:08:33.376 --> 00:08:34.135
strings files.

00:08:34.916 --> 00:08:37.596
And, then again, my
localizer just has to go

00:08:37.596 --> 00:08:40.466
into these strings file
only, and have nothing to do

00:08:40.466 --> 00:08:46.096
with the interface,
which is great.

00:08:46.296 --> 00:08:49.396
Now, when you make an update to
your interface, you also want

00:08:49.396 --> 00:08:52.026
to make sure that your interface
is also localized as well.

00:08:52.336 --> 00:08:56.736
And, we have a command line
tool in OS X; we call it IB12,

00:08:56.736 --> 00:08:59.346
which will generate a
strings file for you.

00:08:59.986 --> 00:09:04.726
So, in this example here
in my base.Lproj folder,

00:09:04.726 --> 00:09:08.496
I just pass in the nib file that
I have changed, and run IB12

00:09:08.666 --> 00:09:12.656
on it, and it will generate a
new strings file containing all

00:09:12.656 --> 00:09:14.436
of the strings that
were originally

00:09:14.436 --> 00:09:15.436
in this interface file.

00:09:16.536 --> 00:09:20.256
I then go in and open
this new strings file,

00:09:21.176 --> 00:09:23.196
copy and paste everything
that has changed,

00:09:23.196 --> 00:09:25.636
or anything that I have
updated or added, and paste it

00:09:25.636 --> 00:09:27.176
into every single strings file

00:09:27.516 --> 00:09:30.236
that has this interface
file here,

00:09:30.236 --> 00:09:34.746
so it's very good to update.

00:09:35.346 --> 00:09:37.686
Now, some issues that can come
up with using auto layout,

00:09:37.686 --> 00:09:40.556
is that you may use the
fixed width for auto layout.

00:09:40.926 --> 00:09:43.016
This entirely defeats the
purpose of auto layout,

00:09:43.016 --> 00:09:45.086
since you want to make sure

00:09:45.086 --> 00:09:47.086
that all text is
resized automatically,

00:09:47.086 --> 00:09:49.516
and you don't want your
interface to look bad

00:09:49.516 --> 00:09:51.386
on certain localization
because you decided

00:09:51.446 --> 00:09:54.136
to have a fixed width
between text

00:09:54.136 --> 00:09:56.076
and UI text view or something.

00:09:56.656 --> 00:09:59.406
And, as always, it's good

00:09:59.406 --> 00:10:02.946
to prefer an intrinsic content
size instead and as always

00:10:02.946 --> 00:10:07.366
if you, you should always
try out your layouts

00:10:07.366 --> 00:10:08.876
in every single localization
and test,

00:10:08.876 --> 00:10:10.366
so your app in those
localizations.

00:10:10.876 --> 00:10:13.186
Because what's works
in one language,

00:10:13.186 --> 00:10:15.196
and what constraints may
work in one language,

00:10:15.196 --> 00:10:16.616
may not necessarily
work in another.

00:10:18.336 --> 00:10:20.546
So, let's talk about
the strings file.

00:10:20.896 --> 00:10:23.486
The strings file contains
the user visible text

00:10:23.486 --> 00:10:28.006
that will get localized
and displayed in your app.

00:10:28.116 --> 00:10:31.386
The strings file is placed
into a key value table,

00:10:31.386 --> 00:10:33.296
and what happens is,
is that the left side

00:10:33.296 --> 00:10:34.696
of the table is your key.

00:10:35.186 --> 00:10:37.316
The key is what the application
is going to be looking

00:10:37.316 --> 00:10:40.696
for to display what localized
text should be displayed

00:10:40.696 --> 00:10:41.146
to the user.

00:10:41.896 --> 00:10:46.156
So, in this example here, I have
three localized strings files

00:10:46.156 --> 00:10:48.006
that are placed in three
separate localizations;

00:10:48.096 --> 00:10:50.946
the English, simplified
Chinese, and Spanish.

00:10:51.716 --> 00:10:54.996
At run time, depending on what
localization my user is in,

00:10:55.286 --> 00:10:56.546
one of these will get loaded,

00:10:56.546 --> 00:10:57.896
and one of these
will get displayed.

00:10:58.196 --> 00:11:03.156
So, if my application is looking
for a name key, it will look

00:11:03.156 --> 00:11:05.756
in the name field for that
specific localization,

00:11:05.816 --> 00:11:08.086
and display whatever is
in the user visible text.

00:11:08.646 --> 00:11:12.626
Now, you will also have
some strings in your code

00:11:12.866 --> 00:11:14.586
or some user visible
text in your code

00:11:14.586 --> 00:11:15.786
that you want localized as well.

00:11:16.496 --> 00:11:18.736
To do this, you should
use NSLocalizedString

00:11:18.736 --> 00:11:20.396
and use NSLocalizedString
everywhere

00:11:20.396 --> 00:11:22.076
where you have user
visible text,

00:11:22.436 --> 00:11:24.746
and NSLocalizedString
has many variants

00:11:24.746 --> 00:11:27.256
that pretty much can do
what you want it to do,

00:11:27.256 --> 00:11:28.946
so check out more details

00:11:28.946 --> 00:11:30.746
for NSLocalizedString
in the release notes.

00:11:31.266 --> 00:11:34.676
Here's an example of
NSLocalizedString used

00:11:34.676 --> 00:11:36.116
in its most common case.

00:11:36.116 --> 00:11:38.776
It takes in two parameters;
one is a key,

00:11:38.776 --> 00:11:41.826
which what will get mapped
to the localized text

00:11:41.826 --> 00:11:44.236
that you want, as well as
a comment to the localizer,

00:11:44.236 --> 00:11:47.516
which I'll talk about later.

00:11:47.746 --> 00:11:50.296
Once you localize your
strings in your code,

00:11:50.356 --> 00:11:52.726
you want to make sure that
you create a strings file

00:11:52.726 --> 00:11:55.896
that will have all these
NSLocalizedStrings in one place.

00:11:56.606 --> 00:11:58.886
You can do this manually,
but there is a script

00:11:59.116 --> 00:12:03.236
that will do this for you, and
it's highly recommended you use.

00:12:03.516 --> 00:12:05.496
It's called gen strings,

00:12:06.116 --> 00:12:09.806
and it's highly scriptable
and customizable.

00:12:09.806 --> 00:12:11.926
You can add it to all of
your X code billing phases,

00:12:11.926 --> 00:12:13.786
and to learn about gen strings,

00:12:13.786 --> 00:12:14.956
you just check out
the amend page.

00:12:15.546 --> 00:12:18.446
So, here's an example of
how gen strings is invoked.

00:12:18.976 --> 00:12:21.726
What happens here is that I
look in the local directory

00:12:21.726 --> 00:12:25.436
for all files that end in
.m, and run gen streams

00:12:25.436 --> 00:12:27.656
of every single one;
meaning that it will go

00:12:27.656 --> 00:12:30.526
into all .m files, search
for NSLocalizedString,

00:12:31.056 --> 00:12:34.326
and place a localizable
.strings file

00:12:34.446 --> 00:12:37.126
into the English localization
folder in this case.

00:12:38.536 --> 00:12:41.506
So, I have a case here
when I've run gen streams

00:12:41.506 --> 00:12:42.856
on two separate localization,

00:12:43.226 --> 00:12:46.156
my .m file contained this
one NSLocalizedString,

00:12:46.156 --> 00:12:49.096
and I placed the strings file
in the English localization

00:12:49.096 --> 00:12:50.456
and the Japanese localization.

00:12:51.106 --> 00:12:53.526
You can see that the comments
and the key have been placed

00:12:53.526 --> 00:12:56.316
in the appropriate
positions, and now my localizer

00:12:56.316 --> 00:12:58.976
or my translators just have
to modify the right side

00:12:58.976 --> 00:13:01.116
of the table to localize
it to whatever language

00:13:01.116 --> 00:13:07.646
that this is in, and
this is done right here.

00:13:07.826 --> 00:13:10.666
Some issues that can come up
with using NSLocalizedString is

00:13:10.666 --> 00:13:13.546
that you overload your keys,
meaning you have one key

00:13:13.546 --> 00:13:14.966
that maps to many
different places.

00:13:15.876 --> 00:13:18.236
Let's say in your application,
you ask the user if they want

00:13:18.236 --> 00:13:19.886
to save, and you
have two buttons;

00:13:20.076 --> 00:13:21.546
one for yes and one for no.

00:13:22.716 --> 00:13:25.366
You also have another button
asking if they want to subscribe

00:13:25.366 --> 00:13:28.166
to the super popular
catfacts, with a button

00:13:28.166 --> 00:13:29.586
for yes and a button for no.

00:13:30.336 --> 00:13:33.236
You have one NSLocalizedString
that maps to both of these,

00:13:33.596 --> 00:13:36.186
and this seems to work perfectly
fine for your application.

00:13:37.476 --> 00:13:39.706
However, later on in
your development process,

00:13:39.706 --> 00:13:42.686
you start to realize that
yes and no aren't very clear,

00:13:43.066 --> 00:13:46.356
and should be possibly save
and cancel, but in doing so,

00:13:46.356 --> 00:13:49.236
you replace the string and you
inherently break the other part

00:13:49.236 --> 00:13:50.466
of your application, and save

00:13:50.466 --> 00:13:52.066
and cancel doesn't
really make any sense.

00:13:52.816 --> 00:13:55.446
So, it's very important
that you make sure

00:13:55.446 --> 00:13:59.176
that all user visible text
has its own unique key,

00:13:59.486 --> 00:14:01.636
so you don't run into
this issue where one part

00:14:01.636 --> 00:14:03.436
of your application
inherently breaks another.

00:14:04.416 --> 00:14:06.846
Also notice here that
when I made the change

00:14:06.916 --> 00:14:07.886
to NSLocalizedString,

00:14:08.216 --> 00:14:10.026
the comments were also
updated appropriately

00:14:10.026 --> 00:14:11.376
to reflect what was going on,

00:14:12.126 --> 00:14:13.476
which leads me to
the second issue.

00:14:13.846 --> 00:14:16.726
You provide no comments
to the localizer

00:14:16.726 --> 00:14:18.066
or insufficient comments,

00:14:19.096 --> 00:14:22.156
it is your localizer's worst
nightmare, and possibly

00:14:22.156 --> 00:14:25.046
like will hate you for this,
if you add no comment provided,

00:14:25.406 --> 00:14:27.606
and yes equals yes,
or not enough context.

00:14:28.266 --> 00:14:29.636
While in English, for example,

00:14:29.946 --> 00:14:32.796
yes can mean many different
things, in some languages,

00:14:32.796 --> 00:14:36.206
such as Chinese, the word yes
has many different possible

00:14:36.206 --> 00:14:38.056
translations, and
without any context

00:14:38.056 --> 00:14:40.546
or knowing exactly what's
going on in your application,

00:14:40.856 --> 00:14:43.716
your localizer will
pretty much be able

00:14:43.716 --> 00:14:46.226
to translate this
part of your app.

00:14:46.796 --> 00:14:49.636
So, it's very important that
you provide enough context

00:14:49.636 --> 00:14:52.166
to the translators, so
they know exactly how

00:14:52.346 --> 00:14:54.226
to translate your
application properly.

00:14:54.756 --> 00:14:58.736
The third issue is
composing phrases together,

00:14:58.736 --> 00:15:01.126
which is something we as
engineers do quite often;

00:15:02.306 --> 00:15:04.976
the reason being is that if
you compose phases together,

00:15:04.976 --> 00:15:07.366
some languages have
these conjugation rules

00:15:07.796 --> 00:15:11.706
and some grammatical rules
that depend on other parts

00:15:11.706 --> 00:15:13.046
of a phrase or sentence,

00:15:13.046 --> 00:15:15.756
and without knowing the
previous parts of your sentence,

00:15:15.806 --> 00:15:17.456
it will be grammatically
incorrect.

00:15:18.406 --> 00:15:20.716
So, for example here, I
have three strings here,

00:15:20.856 --> 00:15:24.436
one for go to next blank,
chapter, and then page.

00:15:25.506 --> 00:15:27.226
In English, this seems
to work perfectly fine,

00:15:27.226 --> 00:15:29.586
since go to next chapter and
go to next page are valid

00:15:29.586 --> 00:15:30.596
and grammatically correct.

00:15:31.526 --> 00:15:33.316
However, if I'm a
Spanish localizer,

00:15:33.316 --> 00:15:37.656
and I try to translate this, I
see go to next and then chapter.

00:15:37.956 --> 00:15:40.046
Since chapter is
a masculine noun,

00:15:40.286 --> 00:15:44.076
and I must have a masculine
article in order to agree

00:15:44.076 --> 00:15:46.656
with chapter, this is going
to work perfectly fine.

00:15:47.566 --> 00:15:50.116
When it comes to page, since
page is a feminine noun,

00:15:50.476 --> 00:15:51.916
the article must be feminine,

00:15:51.916 --> 00:15:53.476
but if I've already
made it masculine,

00:15:53.476 --> 00:15:55.206
then this is inherently broken,

00:15:55.206 --> 00:15:57.106
and this localization
is broken for Spanish.

00:15:57.906 --> 00:16:00.356
So, it's very important
to make sure again

00:16:00.356 --> 00:16:04.236
that your user visible text
each has their own unique key,

00:16:04.576 --> 00:16:07.876
and you compose things in
a sentence wise, or else,

00:16:07.876 --> 00:16:09.426
you're going to run
into grammatical issues.

00:16:11.016 --> 00:16:12.956
There are going to be
some cases, however,

00:16:12.956 --> 00:16:16.676
when you are going to have to
dynamically create strings,

00:16:16.676 --> 00:16:19.246
such as when it comes to
the case of pluralization.

00:16:19.916 --> 00:16:23.116
This is cases where if I want
to display to the user I have 0

00:16:23.116 --> 00:16:25.626
of something remaining, one
of something, or more than one

00:16:25.626 --> 00:16:27.816
of something, and
in some languages,

00:16:27.816 --> 00:16:31.056
this can get very complicated,
where there's a different string

00:16:31.056 --> 00:16:34.326
for two to five of something or
10-14 of something and so on.

00:16:35.316 --> 00:16:37.396
There is a new feature
in OS X Mavericks

00:16:37.396 --> 00:16:41.846
and iOS 7 called strings
dict, which a localized P list

00:16:41.846 --> 00:16:44.406
that essentially
handles all these cases

00:16:44.406 --> 00:16:45.756
of pluralization for you.

00:16:46.496 --> 00:16:49.026
You as a developer do not
need to call any new API's,

00:16:49.256 --> 00:16:51.476
since strings dict will
be called automatically,

00:16:51.476 --> 00:16:54.406
if it's available, and your
localizers then just have

00:16:54.406 --> 00:16:55.396
to fill out this P list,

00:16:55.396 --> 00:16:57.506
and will handle all
these cases for you.

00:16:58.556 --> 00:17:00.976
To learn more about this in
complete technical detail,

00:17:01.036 --> 00:17:03.466
check out the foundation
release notes, but if you want

00:17:03.466 --> 00:17:06.246
to learn how to get the setup
and have a brief tutorial

00:17:06.246 --> 00:17:09.026
about this, check out the
"What's New in Cocoa Video"

00:17:09.026 --> 00:17:10.996
for the session that
was held two days ago.

00:17:12.516 --> 00:17:14.906
So, here's an example
of strings dict

00:17:14.906 --> 00:17:16.665
on two separate localizations;

00:17:16.816 --> 00:17:18.526
one for English and
one for Russian.

00:17:19.246 --> 00:17:22.846
You can see that the English
localization has very simple

00:17:22.846 --> 00:17:25.256
case with one and
anything but one,

00:17:25.386 --> 00:17:27.636
and the Russian case can
get very, very complicated.

00:17:29.976 --> 00:17:34.906
Now, aside from text, which
is the most localizing you'll

00:17:34.906 --> 00:17:37.676
probably be doing, you can
localize other things as well,

00:17:37.676 --> 00:17:40.026
such as your images,
your sound files,

00:17:40.026 --> 00:17:41.946
and pretty much anything
can be localized.

00:17:42.756 --> 00:17:46.946
To do this, you create a
localized version of this file,

00:17:46.946 --> 00:17:49.556
and place it into the
respective localization folder

00:17:49.856 --> 00:17:53.086
that you wish to load for
this specific localization.

00:17:53.976 --> 00:17:55.516
The API's you called to call

00:17:55.516 --> 00:17:58.226
for these specific files
will automatically call the

00:17:58.226 --> 00:17:59.086
localized version.

00:17:59.466 --> 00:18:01.746
So, there is no need
for any extra code

00:18:01.746 --> 00:18:03.396
to handle for localization.

00:18:05.136 --> 00:18:08.876
So, let's say I have an image
here that I want to localize.

00:18:09.206 --> 00:18:12.816
I push this localize
button here, right there,

00:18:12.816 --> 00:18:16.606
and X code will then
ask me where do I want

00:18:16.606 --> 00:18:18.896
to place this localization file.

00:18:19.806 --> 00:18:21.896
In this case, I want
to move this image file

00:18:21.896 --> 00:18:24.516
to the English localization,
so this file will get loaded

00:18:24.516 --> 00:18:25.666
for the English localization.

00:18:26.476 --> 00:18:29.266
Any single time I want to
create a new localized file

00:18:29.266 --> 00:18:33.156
for this specific image here,
I just have to create a file

00:18:33.156 --> 00:18:34.676
with the same name,
and just place it

00:18:34.676 --> 00:18:37.756
into the specific
localized folder that I want,

00:18:38.486 --> 00:18:41.606
so for example here, I have an
RTF file that has been localized

00:18:41.606 --> 00:18:43.276
to several different languages,

00:18:43.586 --> 00:18:46.416
and all of these
RTF files are placed

00:18:46.416 --> 00:18:48.276
into their respective
L.proj folders.

00:18:50.596 --> 00:18:52.766
Now some issues that
can come up is

00:18:52.766 --> 00:18:54.486
that you have some
text in your image.

00:18:55.006 --> 00:18:56.746
While it's okay to have
text in your image,

00:18:56.806 --> 00:19:00.426
be aware that your localizers
will have trouble translating

00:19:00.426 --> 00:19:03.086
text in your image, as opposed
to just translating text itself,

00:19:03.086 --> 00:19:04.536
since it requires
a bit more effort

00:19:04.536 --> 00:19:05.906
to translate text in your image.

00:19:06.906 --> 00:19:09.306
The other issue is having
an image or something

00:19:09.306 --> 00:19:10.726
to convey a meaning to the user,

00:19:10.726 --> 00:19:13.696
since some images may
not necessarily work

00:19:14.046 --> 00:19:15.056
in other languages.

00:19:15.836 --> 00:19:19.626
So, for example I have a
keyword search, and I use a key

00:19:19.626 --> 00:19:20.886
to denote a keyword search.

00:19:21.516 --> 00:19:23.286
In English, this seems
to work perfectly fine,

00:19:23.286 --> 00:19:25.836
since I see a key, I can think
of keyword, since, you know,

00:19:25.836 --> 00:19:28.666
there's the same word,
but in other languages,

00:19:28.996 --> 00:19:32.536
the word keyword doesn't
necessarily translate to a key

00:19:32.536 --> 00:19:35.436
at all, since you'd come out
to head word or focus word

00:19:35.436 --> 00:19:38.276
or indicative word, and your
users will pretty much have no

00:19:38.276 --> 00:19:40.116
idea why you have
a key for keyword,

00:19:40.116 --> 00:19:42.106
so the idea is completely
lost in translation.

00:19:43.776 --> 00:19:46.136
Another issue is having
a cultural reference,

00:19:46.136 --> 00:19:48.646
or something that's specific
to a specific culture,

00:19:48.646 --> 00:19:51.776
and this may run
into some issues.

00:19:52.276 --> 00:19:55.576
So, for example, in Japan,
this image here is placed

00:19:55.576 --> 00:19:59.356
onto the back of all cars for
anyone who is inexperienced

00:19:59.356 --> 00:20:00.956
or a beginner driver
to alert other drivers

00:20:00.956 --> 00:20:01.926
that she should probably
get out of the way.

00:20:02.306 --> 00:20:08.576
Some Japanese developers
sometimes use this to show

00:20:08.576 --> 00:20:11.366
that this is a tutorial or a
beginner's guide to something,

00:20:11.366 --> 00:20:15.066
and if someone isn't well
versed in the Japanese culture,

00:20:15.066 --> 00:20:16.536
or doesn't know anything
about Japan,

00:20:16.536 --> 00:20:18.606
they pretty much have no
idea what this icon is,

00:20:18.606 --> 00:20:20.546
and they'll get lost
in your application.

00:20:21.356 --> 00:20:23.526
So, make sure that any
images that you have

00:20:23.596 --> 00:20:26.726
that display a meaning or try
to convey a meaning to the user,

00:20:27.166 --> 00:20:29.606
is workable for all the
localizations you want

00:20:29.606 --> 00:20:30.136
to support.

00:20:31.636 --> 00:20:33.516
Now once you've localized
your application,

00:20:33.516 --> 00:20:36.246
you'll want to test this out,
and the most accurate way

00:20:36.246 --> 00:20:39.136
to do this, and to see exactly
what your user is going to see,

00:20:39.516 --> 00:20:42.166
is to change the system
language inside of your system

00:20:42.166 --> 00:20:43.176
to the language you want.

00:20:43.876 --> 00:20:45.106
Also, the other reason is,

00:20:45.106 --> 00:20:49.326
is that some system services may
not work in that localization

00:20:49.366 --> 00:20:52.036
until you explicitly send the
language to that localization.

00:20:53.066 --> 00:20:54.896
However, if you want to
quickly check whether

00:20:54.896 --> 00:20:57.306
or not a string has
been localized

00:20:57.306 --> 00:21:00.986
or a file loads correctly,
you can run your application

00:21:00.986 --> 00:21:03.566
in X code using the dash
Apple language as argument.

00:21:04.016 --> 00:21:05.256
And, in this example here,

00:21:05.296 --> 00:21:07.746
no matter what language my
system is in, it's going to run

00:21:07.746 --> 00:21:09.546
in the Korean localization.

00:21:10.976 --> 00:21:13.786
A really cool way to
check whether or not

00:21:13.786 --> 00:21:16.046
if your application
has been localized,

00:21:16.046 --> 00:21:18.316
and to test out whether
your interface will work

00:21:18.316 --> 00:21:20.996
for longer strings,
longer strings,

00:21:20.996 --> 00:21:22.476
is to use pseudo localization.

00:21:23.396 --> 00:21:24.796
So, what's pseudo localization?

00:21:25.426 --> 00:21:28.516
Pseudo localization
is a way, well,

00:21:28.516 --> 00:21:31.396
if you have your strings
files, you can run a script

00:21:31.546 --> 00:21:34.736
through the user visible text
in your string to modify it

00:21:34.736 --> 00:21:36.636
and distort it, such
that it is longer

00:21:36.636 --> 00:21:39.246
than what's originally there,
and will distort it to the point

00:21:39.246 --> 00:21:41.076
where if you were looking
in your application

00:21:41.076 --> 00:21:43.896
to check whether or not some
strings have been localized,

00:21:44.226 --> 00:21:46.626
you can obviously tell whether
you're missing some parts

00:21:46.626 --> 00:21:47.986
or you forget to
localize something.

00:21:48.886 --> 00:21:50.676
And, with that, I'd
like to bring back Doug

00:21:50.676 --> 00:21:51.976
up to show us a demo on
how localization works.

00:21:52.516 --> 00:21:55.656
[ Applause ]

00:21:56.156 --> 00:21:58.896
>> Thanks Albert so in
order to demo this out,

00:21:59.656 --> 00:22:04.756
we wrote a tiny little
application.

00:22:04.756 --> 00:22:09.966
So, what this application
does is it lets me type

00:22:10.016 --> 00:22:18.556
in some brief little notes,
and then it shows them

00:22:18.556 --> 00:22:20.276
in a scrolling list,
really simple.

00:22:25.006 --> 00:22:30.186
And, so the first version
of this application

00:22:30.186 --> 00:22:32.906
that we have here is
not localized at all.

00:22:33.336 --> 00:22:35.686
Notice, it's not using
base internationalization;

00:22:35.686 --> 00:22:36.686
that's turned off.

00:22:37.016 --> 00:22:43.426
The only localization that's
there is English, and if I look

00:22:43.426 --> 00:22:46.756
at my nib file, it's all in
English, and if I take a look

00:22:46.756 --> 00:22:51.186
at my code, I notice that there
are some user visible strings

00:22:51.186 --> 00:22:53.036
in here; for example when
I'm creating an alert,

00:22:54.116 --> 00:22:56.206
they're just static
explicit strings,

00:22:56.786 --> 00:22:59.926
and for setting the title of
the window to reflect the number

00:23:00.006 --> 00:23:05.656
of notes, I have
switched between one note

00:23:05.656 --> 00:23:08.246
or multiple notes, so
it's all in English.

00:23:08.786 --> 00:23:15.706
So, what that means is that if
I go in and change my system

00:23:15.876 --> 00:23:20.136
into say German, and then run
the app again, nothing changes

00:23:20.136 --> 00:23:21.626
at all, it's not localized.

00:23:22.266 --> 00:23:31.616
So, the next thing to do
is to create a new version

00:23:31.616 --> 00:23:34.826
of this application,
and we turned

00:23:34.826 --> 00:23:36.806
on base internationalization.

00:23:37.976 --> 00:23:40.526
What that does is create
a base localization,

00:23:40.526 --> 00:23:42.856
and that's where
our nib file goes,

00:23:42.856 --> 00:23:46.956
and then we added an additional
German localization to this app.

00:23:48.066 --> 00:23:51.146
So, if we take a look at our nib
file, it has not changed at all.

00:23:51.146 --> 00:23:53.156
The only thing that happened
to it is that it moved

00:23:53.156 --> 00:23:58.616
from the English localization
into the base, and in addition,

00:23:59.176 --> 00:24:03.076
we get a strings file
associated with it

00:24:03.766 --> 00:24:07.266
that contains the
translations; we added a rough

00:24:07.266 --> 00:24:10.076
and ready German translation
here, to the various strings

00:24:10.076 --> 00:24:15.506
that appear in that nib
file, and then we run the app

00:24:15.506 --> 00:24:18.656
in German, these will
automatically be substituted

00:24:18.656 --> 00:24:21.756
into that nib, in
place of all the places

00:24:21.756 --> 00:24:23.736
where the English text appears.

00:24:24.336 --> 00:24:29.886
In addition in code, we
took these explicit strings,

00:24:29.886 --> 00:24:32.466
and replaced them calls
to NSLocalizedString

00:24:32.536 --> 00:24:36.456
with suitable keys and suitable
comments for the localizer,

00:24:37.546 --> 00:24:40.336
and then for the title that
reflects the number of notes,

00:24:40.336 --> 00:24:41.666
we're going to use
a string sticks,

00:24:42.256 --> 00:24:46.416
to get appropriate
localization of plurals

00:24:46.986 --> 00:24:49.156
in whatever language we're
translating this into.

00:24:49.996 --> 00:24:53.216
So, we ran gen strings on
this, and the result is

00:24:53.216 --> 00:24:56.066
that we have localizable
string files for English,

00:24:57.396 --> 00:25:01.286
and then for German, where we
put in appropriate translations

00:25:01.656 --> 00:25:06.606
for each of the keys that
appear in our NSLocalizedString,

00:25:07.096 --> 00:25:10.266
and created string
sticks for details

00:25:10.616 --> 00:25:13.556
on the format string
sticked file.

00:25:13.556 --> 00:25:15.886
You can again, take a look at
the foundation of these styles.

00:25:15.886 --> 00:25:19.476
If explains it all in detail,
but the business part of it,

00:25:20.426 --> 00:25:23.046
has these lines that
describe what to do for,

00:25:23.116 --> 00:25:25.666
when the number is
one, and what to do

00:25:25.666 --> 00:25:26.866
when the number is
other than one.

00:25:26.866 --> 00:25:29.906
So, for English, we chose
a very simple set of rules.

00:25:30.536 --> 00:25:33.096
For German, it got a
little more complicated.

00:25:33.136 --> 00:25:36.606
We have rules for 0,
one or anything else.

00:25:38.496 --> 00:25:40.896
And, let's see what
happens when this ends

00:25:40.896 --> 00:25:43.556
up in our built application.

00:25:43.556 --> 00:25:45.656
So, here we're taking a
look inside the app bundle.

00:25:46.196 --> 00:25:48.306
In the resources we
have a base L.proj

00:25:48.476 --> 00:25:52.446
that contains our nib file, so
there's only one copy of that,

00:25:52.446 --> 00:25:57.846
and then in German L.proj, we
have just the strings file,

00:25:57.846 --> 00:26:00.926
the strings dict, and that
credits file that X code wants

00:26:00.926 --> 00:26:04.736
to create for us,
and when we run this,

00:26:05.866 --> 00:26:11.096
then the main menu.strings
contents should be automatically

00:26:11.096 --> 00:26:12.556
substituted into our nib.

00:26:13.686 --> 00:26:17.626
So, let's try that out.

00:26:17.906 --> 00:26:22.426
And, we see one right now, the
whole interface is in German.

00:26:23.496 --> 00:26:27.066
We got our strings sticks
has given us a proper title

00:26:27.066 --> 00:26:32.286
for 0 items, and even
our menus are localized.

00:26:32.756 --> 00:26:35.886
Even the Apple menu stuff, this
comes from outside our app,

00:26:36.366 --> 00:26:43.886
all localized properly, and
our localized strings show

00:26:43.886 --> 00:26:44.596
up in the alert.

00:26:45.946 --> 00:26:49.316
So, that is the basic
process of localizing an app.

00:26:50.226 --> 00:26:52.336
Let me go back to the slides.

00:26:53.956 --> 00:26:56.276
And next, I want to bring
up my colleague, Nat,

00:26:56.426 --> 00:26:57.976
to talk about dealing
with locale data.

00:26:58.516 --> 00:27:00.946
[ Applause ]

00:27:01.446 --> 00:27:02.506
>> Okay, hello, hello.

00:27:02.776 --> 00:27:03.346
Thank you, Doug.

00:27:03.486 --> 00:27:05.836
So, my name is Nat Hillard,
and for this section,

00:27:05.836 --> 00:27:07.866
we will be going
over locale data.

00:27:08.516 --> 00:27:12.486
So, another critical aspect of
making your app world ready,

00:27:12.706 --> 00:27:16.296
is presenting numbers, dates,
times, and symbols in a manner

00:27:16.296 --> 00:27:17.786
that is appropriate
for your users.

00:27:18.306 --> 00:27:20.726
Now, to do this isn't
just a stylistic issue.

00:27:20.726 --> 00:27:23.546
It can have practical usability
complications and implications

00:27:23.546 --> 00:27:26.976
as well, and ultimately, you
can conceive of this process

00:27:26.976 --> 00:27:29.586
as translating between
machine readable data

00:27:29.826 --> 00:27:31.196
and user readable strengths.

00:27:31.656 --> 00:27:35.056
Now, interestingly, this is
not a one to one mapping.

00:27:35.056 --> 00:27:36.326
Things can get pretty
complicated.

00:27:36.796 --> 00:27:39.766
Now, luckily, we provided a set
of API's for you that do a lot

00:27:39.766 --> 00:27:40.956
of the heavy lifting for you.

00:27:41.466 --> 00:27:43.746
So, in this section, I'll
be going over the first five

00:27:43.746 --> 00:27:45.556
in this table, and Doug
will cover NS string

00:27:45.556 --> 00:27:46.786
in more detail in the next.

00:27:47.366 --> 00:27:49.406
So, first of all,
what is a locale?

00:27:50.256 --> 00:27:53.226
In an abstract sense, it's a
collection of user preferences

00:27:53.226 --> 00:27:54.336
with regard to formatting.

00:27:54.746 --> 00:27:56.446
The users will set
this, as Doug mentioned,

00:27:56.446 --> 00:27:59.816
in the region format
preference on iOS or on OS X

00:27:59.926 --> 00:28:01.936
in the languages and
format preference pane.

00:28:02.396 --> 00:28:05.516
In a concrete sense, it
is represented in Cocoa

00:28:05.836 --> 00:28:09.106
with the NS locale API.

00:28:10.156 --> 00:28:12.156
Usually as a programmer,
you will not be dealing

00:28:12.156 --> 00:28:14.096
with the NS locale
object directly.

00:28:14.186 --> 00:28:17.246
Instead, interacting with it at
the class level or passing it

00:28:17.246 --> 00:28:19.506
in as argument to other API's.

00:28:20.886 --> 00:28:23.526
So, important to keep in mind,
however, is the distinction

00:28:23.526 --> 00:28:25.496
between a local and
a localization.

00:28:25.896 --> 00:28:28.956
Locale represents the formatting
standards for a particular user.

00:28:29.206 --> 00:28:30.816
These are informed
by their region,

00:28:30.996 --> 00:28:32.446
their language, and
their script.

00:28:32.956 --> 00:28:35.226
On the other hand, localization
refers to the language

00:28:35.226 --> 00:28:36.386
of the user interface.

00:28:36.786 --> 00:28:38.696
Now, these can often
be the same,

00:28:38.696 --> 00:28:40.486
but for a given user,
they may differ.

00:28:41.606 --> 00:28:45.166
As an example of using locale
information to present,

00:28:45.366 --> 00:28:47.736
or locale data to present
information to your users,

00:28:47.736 --> 00:28:49.256
let's take a look
at formatting dates.

00:28:49.756 --> 00:28:52.746
So, for this, we've provided
the NS date formatter.

00:28:53.096 --> 00:28:56.906
This converts between NS
date machine readable data

00:28:57.016 --> 00:28:59.626
and a string representation
for a particular user.

00:29:00.986 --> 00:29:03.576
Often, you'll be working with
this and explicitly attaching it

00:29:03.606 --> 00:29:05.976
to a text field within
your nib file.

00:29:06.486 --> 00:29:08.266
On the other hand, if you
need to use it in code,

00:29:08.266 --> 00:29:10.196
you can call localized
string from date;

00:29:10.456 --> 00:29:12.236
passing in your NS date, as well

00:29:12.236 --> 00:29:14.086
as a date style and
a time style.

00:29:15.176 --> 00:29:17.336
So, what do these date
and time styles look like?

00:29:17.826 --> 00:29:19.096
Well, they differ in the amount

00:29:19.096 --> 00:29:20.826
of information they're
presenting to the user

00:29:20.826 --> 00:29:22.136
about your NS date object.

00:29:22.796 --> 00:29:25.006
Here, they can vary
from anything as short

00:29:25.006 --> 00:29:27.316
as a short style, where you're
simply presenting numbers,

00:29:27.726 --> 00:29:29.716
to the full style where
you spell everything out.

00:29:30.166 --> 00:29:31.936
As well, as if you need
to suppress either one

00:29:31.936 --> 00:29:33.486
of these, you can use no style.

00:29:34.936 --> 00:29:38.996
So, to see what this looks
like, we call localized string

00:29:38.996 --> 00:29:41.176
from date on the NS
date formatter class.

00:29:41.526 --> 00:29:44.386
We pass in our date, and we
pass in medium style for date

00:29:44.636 --> 00:29:45.956
and short style for time.

00:29:46.736 --> 00:29:50.216
Now, keep in mind this will
do the heavy lifting for us,

00:29:50.416 --> 00:29:51.646
and present this information

00:29:51.646 --> 00:29:53.786
in a locale appropriate
manner for our given user.

00:29:54.436 --> 00:29:57.246
So, here we have three locales,
English as used in the US,

00:29:57.506 --> 00:30:01.266
French as used in France,
and Chinese as used in China.

00:30:01.266 --> 00:30:04.106
Here we have the out of
the box representation

00:30:04.106 --> 00:30:06.166
of a single NS date object.

00:30:06.866 --> 00:30:09.526
Here we have June 6, 2013,

00:30:09.526 --> 00:30:11.226
a presentation familiar
in US English.

00:30:12.536 --> 00:30:15.666
On the other hand in France,
this API has done the work

00:30:15.666 --> 00:30:18.756
of presenting first the day
number, followed by the month,

00:30:18.756 --> 00:30:20.476
followed by the year,
and without a coma.

00:30:21.126 --> 00:30:23.786
Also, in Chinese, we presented
the year number first,

00:30:23.976 --> 00:30:25.306
followed by the character
for year,

00:30:25.526 --> 00:30:27.816
followed by the month
number, character for month,

00:30:27.816 --> 00:30:29.896
and day number, followed
by character for day.

00:30:30.516 --> 00:30:33.846
Likewise with times, we
present AM in the United States.

00:30:34.216 --> 00:30:37.436
We don't provide either
AM or PM for France,

00:30:37.436 --> 00:30:40.326
which traditionally uses
24 hour time, and in China,

00:30:40.326 --> 00:30:42.756
we present the characters
for morning,

00:30:43.076 --> 00:30:45.706
followed by our single
time object.

00:30:46.326 --> 00:30:48.706
So, this is the preferred
way to work with NS date.

00:30:49.016 --> 00:30:51.476
Out of the box, calling a
class method, localized string

00:30:51.476 --> 00:30:53.926
from date, you've gotten three
very different representations

00:30:53.926 --> 00:30:54.926
from the same object.

00:30:55.116 --> 00:30:59.276
If on the other hand, you
want to present a custom view

00:30:59.276 --> 00:31:00.706
of this same NS date object,

00:31:00.706 --> 00:31:04.886
you have to go beyond the
certain present packaged styles.

00:31:05.256 --> 00:31:09.046
Keep in mind that the medium
style will always present the

00:31:09.046 --> 00:31:11.226
month, the day, and the year.

00:31:11.626 --> 00:31:13.076
Let's say for instance
though that you wanted

00:31:13.076 --> 00:31:15.036
to only present the
month and the day.

00:31:15.406 --> 00:31:17.566
So, when the default styles
don't meet your needs,

00:31:17.966 --> 00:31:20.576
you create an instance of
the NS day formatter class.

00:31:21.476 --> 00:31:24.166
From there, you create
a format string.

00:31:24.466 --> 00:31:27.546
This is done with date format
from template, a class method

00:31:27.546 --> 00:31:28.556
on interstate formatter.

00:31:29.206 --> 00:31:31.276
To this, you pass
a format string.

00:31:31.666 --> 00:31:32.826
Now, for more information
on this,

00:31:32.826 --> 00:31:35.636
you can check Unicode
standard 35, which has a lot

00:31:35.636 --> 00:31:36.526
of information on this.

00:31:36.886 --> 00:31:38.346
Suffice it to say,
we've said here

00:31:38.346 --> 00:31:39.536
that we want the day number,

00:31:39.536 --> 00:31:41.666
followed by an abbreviated
form of the month.

00:31:41.726 --> 00:31:43.716
This can go into
a lot of detail.

00:31:43.716 --> 00:31:47.976
These format strings can present
everything from given variance

00:31:47.976 --> 00:31:50.316
of abbreviations, as
well as fully spelled

00:31:50.316 --> 00:31:51.876
out or number variance.

00:31:52.566 --> 00:31:55.106
Also critically, we
pass here the locale,

00:31:55.326 --> 00:31:56.666
NS locale, current locale.

00:31:57.966 --> 00:32:01.596
So, this is the correct to do
it, but, there is, oh, sorry,

00:32:01.756 --> 00:32:06.326
finally, we set the date format
on our date formatter instance.

00:32:06.596 --> 00:32:08.776
Now, this is the
correct way to do it.

00:32:08.776 --> 00:32:11.246
However, there is an incorrect
and naive way to do it.

00:32:11.696 --> 00:32:13.606
Let's say you've read
Unicode standard 35,

00:32:13.936 --> 00:32:16.676
and you've explicitly set
date format to a string

00:32:16.676 --> 00:32:17.426
that you've read about here.

00:32:17.426 --> 00:32:19.806
You want the month, followed by
the day, followed by the year.

00:32:20.136 --> 00:32:22.606
Notice though that we haven't
got through the template object.

00:32:23.256 --> 00:32:24.696
The template does
the work for us

00:32:24.696 --> 00:32:26.176
of rearranging the components,

00:32:26.176 --> 00:32:27.716
so they're appropriate
for a given locale.

00:32:28.466 --> 00:32:30.666
Consequently though, when we
call from string from date,

00:32:30.666 --> 00:32:33.216
we get a representation that
is the same for all three

00:32:33.216 --> 00:32:34.786
of these very different locales.

00:32:35.756 --> 00:32:37.426
So, this is not the
correct way to do this.

00:32:37.476 --> 00:32:40.616
Instead, going through the
intermediary of date format

00:32:40.616 --> 00:32:42.966
from template, it will do
the rearranging for us.

00:32:43.406 --> 00:32:46.546
Consequently, if we pass in
lower case d, capital MMM,

00:32:46.606 --> 00:32:50.866
day and number, basically
indicating that we wish

00:32:50.866 --> 00:32:55.646
to convey day number and
month, and then call a string

00:32:55.646 --> 00:32:58.116
from date, we get the
appropriate representation

00:32:58.116 --> 00:32:58.946
for a given locale.

00:32:59.326 --> 00:33:01.446
We have the month name
followed by number in the US,

00:33:01.846 --> 00:33:05.526
the vice versa in France, and
in China, we have month number,

00:33:05.526 --> 00:33:09.156
followed by month
character, day, day character.

00:33:10.086 --> 00:33:12.366
Likewise though, with NS dates,

00:33:12.366 --> 00:33:14.086
let's take a look at
number formatting.

00:33:14.116 --> 00:33:16.086
This is another area in
which there's a great degree

00:33:16.086 --> 00:33:17.256
of variation around the world.

00:33:18.166 --> 00:33:21.146
To help you with this, we
have NS number formatter,

00:33:21.426 --> 00:33:23.426
which is meant to mirror
an estate formatter.

00:33:24.476 --> 00:33:27.506
As an example of the type of
variation you may come across,

00:33:27.726 --> 00:33:29.256
you'll have everything
from the separator

00:33:29.256 --> 00:33:31.846
between the thousands digit
and the decimal digit.

00:33:32.286 --> 00:33:34.686
Likewise, even the
digits themselves,

00:33:34.686 --> 00:33:36.446
something we may take
for granted, can vary.

00:33:36.736 --> 00:33:39.186
On the right, we have an
aerobic Egyptian representation

00:33:39.186 --> 00:33:40.316
of this same digit number.

00:33:41.066 --> 00:33:42.696
Currency can differ
in the symbol,

00:33:42.696 --> 00:33:43.756
as well as the separators.

00:33:44.146 --> 00:33:46.446
Percentage size itself
can differ, as well again,

00:33:46.446 --> 00:33:48.986
we see the digits
differing, and even numbers

00:33:48.986 --> 00:33:51.286
that are not numbers,
so not a number can come

00:33:51.286 --> 00:33:53.666
up differently in
different locales.

00:33:54.596 --> 00:33:59.006
Again though one thing to avoid
is providing explicit format

00:33:59.006 --> 00:34:01.656
strings, so those of you coming
from C world will be familiar

00:34:01.656 --> 00:34:04.546
with the print F style
C format strings.

00:34:05.076 --> 00:34:07.946
Here we call string from
format on NS String,

00:34:08.386 --> 00:34:11.755
saying that we want a floating
point number with three digits.

00:34:11.755 --> 00:34:14.746
Consequently though, we get
the same number for all three

00:34:14.746 --> 00:34:15.946
of these very different locales.

00:34:16.735 --> 00:34:18.426
This is not the correct
way to do it.

00:34:19.045 --> 00:34:23.016
So, one way to do a very
simple in place fix,

00:34:23.016 --> 00:34:25.186
is to instead called
localized string

00:34:25.186 --> 00:34:26.676
of format on your NS String.

00:34:27.065 --> 00:34:28.826
This is only for a code
that exists already,

00:34:28.826 --> 00:34:30.306
and is a simple in place fix.

00:34:30.786 --> 00:34:34.255
However, if you're making code
that will be used going forward,

00:34:34.255 --> 00:34:36.226
we prefer using the
NS number formatter.

00:34:36.735 --> 00:34:38.476
Here you call localized
string with number,

00:34:38.636 --> 00:34:41.246
pass in your NS number,
and pass in again,

00:34:41.246 --> 00:34:43.036
an explicit format string.

00:34:43.976 --> 00:34:46.985
And, this will do the
heavy lifting for you

00:34:46.985 --> 00:34:47.956
in presenting a number

00:34:47.956 --> 00:34:50.346
in a locale appropriate
manner for a given user.

00:34:52.016 --> 00:34:55.766
So, like NS day formatter, we
have explicit preset styles.

00:34:56.136 --> 00:34:57.246
Here's what these look like.

00:34:57.526 --> 00:35:00.186
Let's start with an NS number
literal, denoted by the at sign,

00:35:00.186 --> 00:35:03.846
followed by the number, 1234.56,

00:35:04.446 --> 00:35:06.786
decimal style will
do the correct thing.

00:35:06.786 --> 00:35:10.936
Here on this table we have,
the left column is US English,

00:35:10.936 --> 00:35:12.626
and on the right are
variants you may encounter

00:35:12.626 --> 00:35:13.146
around the world.

00:35:13.946 --> 00:35:16.746
Again, see in Italy,
we have the period

00:35:16.746 --> 00:35:17.676
and the coma have flipped.

00:35:18.146 --> 00:35:19.736
Currency style is
different in China.

00:35:20.216 --> 00:35:23.406
Percentage style differs
in these two aspects again,

00:35:23.406 --> 00:35:25.916
and even scientific style can
differ in that it uses the comma

00:35:25.916 --> 00:35:27.596
to separate out the
significant digits.

00:35:28.736 --> 00:35:31.076
Finally, the spell out style
itself can be dramatically

00:35:31.076 --> 00:35:32.526
different between both locales.

00:35:32.806 --> 00:35:37.226
So, let's go into more detail

00:35:37.226 --> 00:35:39.106
about the NS locale
object itself.

00:35:40.036 --> 00:35:43.156
Traditionally, the
standard API's will do,

00:35:43.156 --> 00:35:45.176
take into account this
information for you.

00:35:45.176 --> 00:35:49.526
To give it as an information,
sorry, to give it as an argument

00:35:49.526 --> 00:35:51.656
to an NS number formatter
and NS date formatter,

00:35:51.966 --> 00:35:54.966
you can call current
locale the class method

00:35:54.966 --> 00:35:57.896
or auto updating current
locale, which will listen

00:35:57.896 --> 00:35:59.476
for notification that indicates

00:35:59.476 --> 00:36:02.626
that the user has changed your
locale as your app is running.

00:36:03.736 --> 00:36:06.776
From there, if you
want even more detail,

00:36:06.836 --> 00:36:09.176
you can create an instance
of the NS locale class.

00:36:09.596 --> 00:36:13.566
From there, you can call object
for key with various keys

00:36:13.566 --> 00:36:14.536
to get more information.

00:36:15.276 --> 00:36:17.266
For instance, let's
say you want to see

00:36:17.266 --> 00:36:19.096
if a given user uses
the metric system.

00:36:19.576 --> 00:36:22.586
This information is stored in an
instance of the NS locale class.

00:36:22.996 --> 00:36:25.656
You call object for key
with uses metric system.

00:36:26.446 --> 00:36:28.446
Likewise, you can get
the currency symbol,

00:36:28.826 --> 00:36:30.336
or for a slightly
more detailed example,

00:36:30.336 --> 00:36:31.346
you can get the beginning

00:36:31.346 --> 00:36:33.306
and end quotation marks
for a given locale.

00:36:33.936 --> 00:36:36.856
All this is available from an
instance of NS locale class.

00:36:38.006 --> 00:36:41.736
So, here, let's see what this
looks like in a real example,

00:36:41.736 --> 00:36:43.006
where you call a
string from format,

00:36:43.006 --> 00:36:46.916
and pass in our previously
obtained beginning quote string

00:36:46.916 --> 00:36:47.456
and end quote.

00:36:47.766 --> 00:36:50.476
As a result, we have the
appropriate quotation marks

00:36:50.476 --> 00:36:52.516
for China, France, and Japan.

00:36:52.606 --> 00:36:54.646
We have the angle
brackets for France

00:36:54.646 --> 00:36:56.076
and the square brackets
for Japan.

00:36:56.576 --> 00:37:00.766
Keep in mind though,
the distinction

00:37:00.766 --> 00:37:02.686
between a locale
and a localization.

00:37:04.076 --> 00:37:07.106
To get a given user's
localization, that is to say,

00:37:07.316 --> 00:37:08.776
the user interface language

00:37:08.776 --> 00:37:10.716
that the user is
running your app within,

00:37:10.956 --> 00:37:13.416
you call preferred
localizations on an instance

00:37:13.416 --> 00:37:14.616
of the NS bundle class.

00:37:15.036 --> 00:37:17.946
On the other hand, to get the
locale you call current locale

00:37:17.946 --> 00:37:18.976
on the locale object.

00:37:19.396 --> 00:37:21.606
This is what you'll be passing
into the formatting objects

00:37:21.976 --> 00:37:24.466
in order to obtain the
appropriate representation.

00:37:26.196 --> 00:37:28.846
So, one final area in which
you'll see a lot of variation

00:37:28.846 --> 00:37:32.686
around the world is in the
presentation of calendars.

00:37:32.746 --> 00:37:35.516
We may take for granted
that this is the year 2013,

00:37:35.756 --> 00:37:38.766
or year 2011, and you
can see that in fact,

00:37:38.816 --> 00:37:45.676
this is simultaneously also
the year 1432, 2554, 5771.

00:37:45.676 --> 00:37:48.756
Likewise, this era
is AD or CE here,

00:37:48.756 --> 00:37:50.666
but in Japan, it's
the Hassay era.

00:37:50.666 --> 00:37:53.256
The number of months per
year, length of the months,

00:37:53.256 --> 00:37:54.756
the day of the week
itself can vary,

00:37:55.156 --> 00:37:56.906
and even the transition
of years.

00:37:57.246 --> 00:37:59.536
Now, here we have a transition
between the Showa period

00:37:59.536 --> 00:38:00.956
and the Hassay period in Japan,

00:38:01.276 --> 00:38:03.296
which happened as
recently as 1989.

00:38:03.886 --> 00:38:08.746
So, to interact with calendars,
we use the NS calendar object.

00:38:09.096 --> 00:38:10.576
This allows us to
do calculations

00:38:10.576 --> 00:38:11.506
in a more intelligent way.

00:38:12.466 --> 00:38:14.506
It also, it allows us to
obtain the information we saw

00:38:14.506 --> 00:38:16.346
in the previous table, the
number of days in the month,

00:38:16.346 --> 00:38:19.496
weeks in the year, etc. It also
allows us to get components

00:38:19.496 --> 00:38:20.766
from the date, that
then we can add

00:38:20.766 --> 00:38:24.236
on to additional NS date objects
to get dates in the future.

00:38:25.516 --> 00:38:28.206
Likewise, as I said, you
can do delta computations

00:38:28.206 --> 00:38:30.016
between two NS date objects.

00:38:31.036 --> 00:38:34.936
So, keep in mind though that NS
date itself is an abstract point

00:38:34.936 --> 00:38:35.516
in time.

00:38:36.266 --> 00:38:39.236
You must interpret this NS
date object through the lens

00:38:39.236 --> 00:38:41.796
of an NS calendar if you're
presenting it to the user.

00:38:42.476 --> 00:38:43.766
If you're using a
code internally,

00:38:43.766 --> 00:38:45.946
of course it's still fine
to use the NS date object.

00:38:46.016 --> 00:38:51.066
So, let's see an example of
getting the components of a date

00:38:51.066 --> 00:38:52.056
that may be of interest to you.

00:38:52.596 --> 00:38:55.476
We here, call components
from date,

00:38:55.476 --> 00:38:57.106
passing in our NS date object,

00:38:57.526 --> 00:39:00.106
and passing in the individual
units that we wish to obtain.

00:39:00.676 --> 00:39:03.796
Keep in mind here, you'll
only obtain these units

00:39:03.796 --> 00:39:06.496
that you explicitly specify
that are returned in the form

00:39:06.496 --> 00:39:08.236
of an NS date components object.

00:39:09.326 --> 00:39:11.746
From there, you can
call day, month, year,

00:39:11.746 --> 00:39:13.616
and era to get this
information out of the object

00:39:13.616 --> 00:39:14.416
that you've just created.

00:39:15.046 --> 00:39:17.366
You can then this NS
date components object

00:39:17.616 --> 00:39:23.216
onto an additional NS calendar
method to add these components

00:39:23.246 --> 00:39:25.966
to an existing NS date, and
obtain a date in the future.

00:39:26.836 --> 00:39:30.526
Now, this is important because
calendar computations can

00:39:30.526 --> 00:39:31.576
be complicated.

00:39:32.696 --> 00:39:34.766
The common thing to
keep in mind is that,

00:39:34.766 --> 00:39:37.236
let's say we do some simple
arithmetic and we say,

00:39:37.446 --> 00:39:40.436
well a day is 60
x 60 x 24 seconds.

00:39:40.686 --> 00:39:43.506
So, if I go 86,400
seconds into the future,

00:39:43.726 --> 00:39:45.226
I will be at this time tomorrow.

00:39:45.596 --> 00:39:48.726
However, keep in mind
that on the border

00:39:48.726 --> 00:39:50.416
between daylight savings time

00:39:50.416 --> 00:39:52.596
and non-daylight savings
time, this is not the case.

00:39:53.416 --> 00:39:55.936
Likewise, one month is not
always 30 days in the future.

00:39:56.216 --> 00:39:59.426
One year is not always
525,600 minutes,

00:39:59.426 --> 00:40:01.286
despite what the song may say.

00:40:01.496 --> 00:40:03.206
So, for more information
on this,

00:40:03.206 --> 00:40:04.566
you can see tomorrow's
presentation,

00:40:04.566 --> 00:40:05.836
date and time challenges.

00:40:06.676 --> 00:40:08.546
I assure you its quite
complicated, but they'll go

00:40:08.546 --> 00:40:09.916
into a lot of information
about this.

00:40:10.866 --> 00:40:13.726
So, with that, I'll pack to
Doug, and we'll do a demo

00:40:13.756 --> 00:40:14.776
of seeing this in real life.

00:40:15.266 --> 00:40:17.266
[ Applause ]

00:40:17.516 --> 00:40:18.006
>> Thanks, Nat.

00:40:18.946 --> 00:40:21.466
Alright. So, let me go back

00:40:21.536 --> 00:40:24.506
to my first crude
unlocalized application,

00:40:25.206 --> 00:40:31.236
and notice that it prints a
little header in front of each

00:40:31.236 --> 00:40:35.136
of my notes that shows an
index number; I've started

00:40:35.136 --> 00:40:37.936
with a thousand, just so I
can illustrate some things,

00:40:38.286 --> 00:40:39.436
and a date.

00:40:40.046 --> 00:40:43.476
Unfortunately, the format I've
chosen for this is pretty crude.

00:40:44.086 --> 00:40:45.866
Let's see what that
looks like in code.

00:40:47.476 --> 00:40:51.006
So, I'm just creating
using string with format

00:40:51.576 --> 00:40:55.426
from the NS number and NS date
attached to my note object.

00:40:55.876 --> 00:40:57.866
Now, that's the sort of thing
that I might want to use

00:40:57.946 --> 00:41:01.226
for an internal machinery
for full representation,

00:41:01.226 --> 00:41:03.686
but it's not the sort of thing
I want to present to my users.

00:41:03.686 --> 00:41:06.996
I really want to give them
locale appropriate presentations

00:41:06.996 --> 00:41:08.236
of the number and the date.

00:41:09.286 --> 00:41:13.866
So, let me go and see what
that looks like in my updated,

00:41:14.096 --> 00:41:15.656
properly localized application.

00:41:16.956 --> 00:41:19.006
So, what I've chosen
to do here is

00:41:19.006 --> 00:41:22.436
to create an NS date formatter
and an NS number formatter

00:41:22.436 --> 00:41:23.876
to format these two objects.

00:41:24.566 --> 00:41:28.056
Once I have those, it's
just a simple matter

00:41:28.056 --> 00:41:33.946
of replacing the index
number and date in my string

00:41:33.946 --> 00:41:37.256
with format with the
properly formatted results

00:41:37.256 --> 00:41:39.116
of calling string
from number and string

00:41:39.116 --> 00:41:41.336
from date using my
number formatter

00:41:41.336 --> 00:41:42.716
and date formatter objects.

00:41:43.266 --> 00:41:46.306
So, to do that, I have to
create the date formatter

00:41:46.306 --> 00:41:48.546
and the number formatter,
which is pretty simple.

00:41:49.356 --> 00:41:53.046
I've chosen to use a custom
format for my date formatter,

00:41:53.046 --> 00:41:55.206
so I create a date
format from template,

00:41:55.596 --> 00:41:59.236
with a simple template,
month, day, hour and minute,

00:41:59.916 --> 00:42:03.946
and then I set that date format
that I got on my date formatter,

00:42:03.946 --> 00:42:06.656
and it's ready to go
for my number formatter.

00:42:06.816 --> 00:42:11.316
I just create it, and I set
an appropriate style on it.

00:42:11.316 --> 00:42:15.096
There are also, if you want to
customize your number formatter,

00:42:15.096 --> 00:42:16.546
there are many, many
different options,

00:42:16.546 --> 00:42:18.656
so you can control
all the various pieces

00:42:18.656 --> 00:42:19.466
of number formatting.

00:42:19.986 --> 00:42:23.376
The only thing I'm doing here
is saying I don't want floats.

00:42:24.416 --> 00:42:26.866
So, I set that up at the
beginning of my application,

00:42:27.506 --> 00:42:30.766
and then I have my date
formatter and number formatter

00:42:30.766 --> 00:42:33.986
that I can use whenever I have
to format one of these headers.

00:42:34.816 --> 00:42:37.426
Now, one thing I did
want to keep in mind is

00:42:37.426 --> 00:42:40.206
that the user might change their
locale while my app is running,

00:42:40.946 --> 00:42:43.956
and if they do that, then I'm
stuck with this number formatter

00:42:43.956 --> 00:42:46.106
or date formatter that I
created for the old locale.

00:42:46.146 --> 00:42:48.996
So, I want to listen
to a notification,

00:42:49.946 --> 00:42:55.046
a little further down, I'm going
to add myself as an observer

00:42:55.046 --> 00:42:59.326
to the locale that changed
notification, and when I get

00:42:59.326 --> 00:43:01.786
that notification, I'm just
going to recreate my formatters

00:43:01.836 --> 00:43:03.256
with whatever the new locale is.

00:43:04.396 --> 00:43:06.736
So, now my app should be ready.

00:43:07.556 --> 00:43:09.506
Let's try running it in English,

00:43:13.846 --> 00:43:17.306
and I see that I got
properly formatted numbers

00:43:17.346 --> 00:43:18.796
and dates for English.

00:43:19.166 --> 00:43:24.346
I also note that my title of the
window is changing appropriately

00:43:25.996 --> 00:43:31.776
with my using string stick to
give appropriate representations

00:43:32.006 --> 00:43:34.206
for the proper pluralization,

00:43:35.256 --> 00:43:40.186
and so my numbers are formatted
using the appropriate thousand

00:43:40.186 --> 00:43:45.716
separator for English, and
I get a suitable date format

00:43:45.716 --> 00:43:50.106
and number format for English
showing first the month name

00:43:50.256 --> 00:43:58.436
and day, followed by the
time in 12 hour format.

00:43:58.576 --> 00:44:01.946
So, now if I go into
the system preferences,

00:44:01.946 --> 00:44:05.686
I change my primary language
to English, and my region

00:44:06.036 --> 00:44:13.846
from English to German, and my
region format also to Germany.

00:44:16.296 --> 00:44:19.116
Let's try running the
app again in German.

00:44:19.116 --> 00:44:24.876
Of course, the interface is
localized to German, let's see,

00:44:25.926 --> 00:44:34.096
and now we can see that I
get appropriately formatted

00:44:34.206 --> 00:44:37.276
for German with the
right thousand separator,

00:44:37.336 --> 00:44:40.916
rather than a comma, and
appropriately formatted dates

00:44:41.516 --> 00:44:45.486
with a day number, month name,

00:44:45.816 --> 00:44:49.826
and using 24 hour
format for the hours.

00:44:50.586 --> 00:44:56.226
And, we can see also that
are string stick is giving us

00:44:56.286 --> 00:45:07.406
appropriately pluralized titles
as the number of notes changes.

00:45:08.266 --> 00:45:11.996
So, that's using date
and number formatters

00:45:12.736 --> 00:45:16.496
to get properly formatted
user representations

00:45:16.846 --> 00:45:18.496
of dates and numbers.

00:45:18.986 --> 00:45:20.296
Now, let me go back
to the slides,

00:45:21.746 --> 00:45:23.756
and let me talk about text.

00:45:24.536 --> 00:45:26.986
Now, there are many
applications that deal with text

00:45:27.206 --> 00:45:28.476
in one form or another.

00:45:28.866 --> 00:45:32.086
Maybe your app is representing
text to the user that it got

00:45:32.086 --> 00:45:34.686
from some external source, or
maybe you're dealing with text

00:45:34.746 --> 00:45:37.966
that the user entered
themselves, but in either case,

00:45:38.116 --> 00:45:40.846
you need to deal with all
the kinds of writing systems

00:45:40.846 --> 00:45:42.656
that the users are
going to want to see.

00:45:43.166 --> 00:45:45.276
I have some examples here.

00:45:45.276 --> 00:45:49.576
These are all writing
systems for which we have font

00:45:49.576 --> 00:45:52.046
and input method support
on both iOS and OS X.

00:45:52.546 --> 00:45:53.926
You want to be able
to handle them all.

00:45:54.906 --> 00:45:56.956
Well, here's some simple
rules for doing that.

00:45:56.956 --> 00:46:01.456
The first one is, use
Unicode and in particular,

00:46:01.626 --> 00:46:04.676
the NS string class, which is
our standard representation

00:46:04.736 --> 00:46:07.576
of the Unicode string
for representing text.

00:46:08.556 --> 00:46:13.186
A second one is that when you
want to analyze this text,

00:46:13.346 --> 00:46:15.516
going into or do something
to it, iterate through it,

00:46:15.516 --> 00:46:17.476
search for a substring,
sort it, etc.,

00:46:17.846 --> 00:46:20.026
use some of the standard
NS string API's,

00:46:20.836 --> 00:46:24.216
which are all Unicode savvy,
and will deal with text in many

00:46:24.216 --> 00:46:25.406
in many different
writing systems,

00:46:25.866 --> 00:46:28.816
and as much as possible, use
the standard system views

00:46:28.816 --> 00:46:32.726
and controls for displaying that
text or for accepting input.

00:46:32.726 --> 00:46:35.146
Let me go into that
in some more detail.

00:46:35.736 --> 00:46:39.366
So, Unicode is a
standard that allows us

00:46:39.366 --> 00:46:43.476
to encode essentially all of the
world's living writing systems,

00:46:43.596 --> 00:46:45.696
most of its date blocks
in a single strength,

00:46:46.926 --> 00:46:52.136
we use NS string as our standard
Unicode containing object,

00:46:53.166 --> 00:46:57.506
and it exposes the
contents using the UTF 16

00:46:57.506 --> 00:46:58.536
and coding format.

00:46:59.736 --> 00:47:02.796
The thing I want you to
remember about using Unicode

00:47:02.796 --> 00:47:08.396
to represent text, is that you
cannot treat what the user sees

00:47:08.396 --> 00:47:10.466
as a character as
being something

00:47:10.466 --> 00:47:12.646
that is fixed length in memory.

00:47:13.366 --> 00:47:16.206
That's true no matter what
encoding form you're using

00:47:16.206 --> 00:47:17.716
or what normalization
form you're using.

00:47:17.716 --> 00:47:19.936
It's just a fundamental
property of Unicode.

00:47:20.446 --> 00:47:22.776
So, what we recommend
that you do is not deal

00:47:22.776 --> 00:47:24.826
with individual characters
in a string.

00:47:25.216 --> 00:47:28.306
Instead, work with ranges
of characters in a string

00:47:28.306 --> 00:47:29.556
or substrings of a string.

00:47:31.376 --> 00:47:32.456
Let me give you some examples.

00:47:32.456 --> 00:47:36.186
So, here I have a Chinese
character, a Korean syllable,

00:47:36.186 --> 00:47:37.376
and a couple of emogies.

00:47:37.946 --> 00:47:42.896
And their representations
numerically in UTF 16 or UTF 32,

00:47:42.896 --> 00:47:46.446
you can see that they all have
different lengths no matter what

00:47:46.446 --> 00:47:47.696
encoding formats you've used.

00:47:48.896 --> 00:47:51.726
So, to avoid dealing
with all this complexity,

00:47:51.726 --> 00:47:52.976
you can use standard API's,

00:47:53.956 --> 00:47:56.866
like range of composed
character sequence at index,

00:47:57.246 --> 00:47:59.836
so this will give you
the range within a string

00:48:00.336 --> 00:48:03.856
of what is effectively
user visible character,

00:48:03.856 --> 00:48:06.166
what we call a composed
character sequence

00:48:06.236 --> 00:48:08.726
or sometimes a character
cluster for short.

00:48:09.706 --> 00:48:13.156
So we use this API, it will give
you the range that corresponds

00:48:13.156 --> 00:48:15.676
to what the user is seeing
as a character and respect

00:48:15.736 --> 00:48:18.156
that range, so you don't
split these things up,

00:48:18.156 --> 00:48:20.466
and end up with broken text.

00:48:21.876 --> 00:48:25.366
If you need to go through
a string; maybe you need

00:48:25.366 --> 00:48:27.746
to through it by
character cluster or by word

00:48:27.746 --> 00:48:30.566
or by sentence or by paragraph,
we have a standard API for that.

00:48:30.986 --> 00:48:33.876
Innumerate substrings and
range options using block.

00:48:34.476 --> 00:48:37.546
Depending on what options you
pass in, you can through it

00:48:37.906 --> 00:48:40.446
by character cluster,
by word sentence, etc.,

00:48:41.306 --> 00:48:44.206
and then you give it a block,
and your block gets called

00:48:44.206 --> 00:48:46.256
with the range of each
individual component.

00:48:46.256 --> 00:48:47.716
For example, if you're
going through it

00:48:47.716 --> 00:48:51.496
by user visible characters,
character clusters,

00:48:52.496 --> 00:48:54.016
you use the NS string
enumeration

00:48:54.016 --> 00:48:56.046
by composed character
sequences options,

00:48:56.046 --> 00:48:59.266
and then your block will
be called successively

00:48:59.516 --> 00:49:03.256
with the range and the string
corresponding to this character,

00:49:03.256 --> 00:49:08.086
whatever it may be,
whether it's short or long.

00:49:08.276 --> 00:49:10.016
Likewise, if you're going
through it by words,

00:49:10.016 --> 00:49:11.776
use NS string enumeration
by words,

00:49:11.826 --> 00:49:15.566
and your block will be called
successfully with the range

00:49:15.626 --> 00:49:17.706
of each word and the text notice

00:49:17.806 --> 00:49:20.156
that words are not necessarily
going to be separated

00:49:20.276 --> 00:49:22.316
by punctuation or white space.

00:49:22.896 --> 00:49:26.856
If you need to search for a
substring within a string,

00:49:27.046 --> 00:49:28.666
there's a standard
API for that too.

00:49:29.176 --> 00:49:31.526
Range of string options,
range locale.

00:49:31.986 --> 00:49:35.396
There are a number of different
options you can pass in for case

00:49:35.396 --> 00:49:36.976
and sensitive searching,
die printing

00:49:36.976 --> 00:49:38.886
and sensitive searching,
if you're searching

00:49:38.886 --> 00:49:40.096
for something user provider,

00:49:40.576 --> 00:49:42.726
there's a good change you may
want to use both of those.

00:49:43.476 --> 00:49:45.346
You can search forwards
or backwards.

00:49:46.006 --> 00:49:48.336
There's the also the
anchored search option.

00:49:48.336 --> 00:49:51.826
If you pass that in, you're not
looking for the next instance

00:49:51.926 --> 00:49:55.406
of the substring, you're looking
to see whether it's present

00:49:55.406 --> 00:49:58.016
or not at the given
location you start at,

00:49:58.996 --> 00:49:59.976
which is often useful too.

00:50:01.396 --> 00:50:04.856
And, sorting.

00:50:05.546 --> 00:50:09.526
If you need to sort strings in
such a way as to present them

00:50:09.526 --> 00:50:13.516
to the user in sorted order,
you have to keep in mind

00:50:13.726 --> 00:50:17.426
that each different
language; not just language,

00:50:17.506 --> 00:50:21.676
but each country or region,
may have a different standard,

00:50:21.836 --> 00:50:25.326
sort order, in which they
like to see strings presented.

00:50:26.046 --> 00:50:29.676
Some die critics are sensitive,
important, sometimes not,

00:50:30.316 --> 00:50:33.096
even what constitutes a
letter for sorting may change,

00:50:33.446 --> 00:50:35.336
and if you don't put
things in the right order,

00:50:35.336 --> 00:50:36.216
people are not going to be able

00:50:36.216 --> 00:50:37.316
to find what they're
looking for.

00:50:38.136 --> 00:50:42.246
Now, there are a couple of API's
that you might look at for this.

00:50:42.246 --> 00:50:43.916
NS string has a standard
compare method

00:50:43.916 --> 00:50:46.656
and a localized standard
compare, so the difference is

00:50:46.956 --> 00:50:50.446
that the compare method
is that locale and variant

00:50:50.696 --> 00:50:54.566
for internal machinery
purposes for sorting.

00:50:55.946 --> 00:50:58.786
That's not what you want to use
for user presentation of text.

00:50:59.046 --> 00:51:01.806
For user presentation of text,
use localized standard compare.

00:51:02.256 --> 00:51:03.616
That will be locale sensitive.

00:51:03.616 --> 00:51:06.636
It will give you the
order that users expect.

00:51:07.436 --> 00:51:10.536
It will match, for
example, the order of files

00:51:10.536 --> 00:51:12.276
that are sorted in the finder.

00:51:13.706 --> 00:51:14.936
So, let me give you
a few examples.

00:51:15.506 --> 00:51:16.676
Here is a set of strings.

00:51:16.776 --> 00:51:18.596
Here's the order that
you would get them

00:51:18.596 --> 00:51:19.646
if you sorted them according

00:51:19.646 --> 00:51:23.056
to the locale independent
internal compare method.

00:51:24.166 --> 00:51:29.616
If we change this to localized
standard compare for let us say,

00:51:29.616 --> 00:51:30.606
the US English locale,

00:51:31.066 --> 00:51:33.576
you notice that the
order changes a fair bit.

00:51:34.626 --> 00:51:37.156
If we were using
Danish sort order,

00:51:37.566 --> 00:51:38.926
it changes even still further,

00:51:39.146 --> 00:51:41.106
or we're using a
Chinese sort order,

00:51:41.406 --> 00:51:42.696
it changes quite a bit again.

00:51:43.406 --> 00:51:44.356
So, use the standard API,

00:51:44.356 --> 00:51:47.046
and you'll get the sort
order users expect;

00:51:47.126 --> 00:51:48.466
whatever it may happen to be.

00:51:50.486 --> 00:51:56.256
For displaying text, keep
in mind that the characters

00:51:56.536 --> 00:51:59.756
as they appear in the string
are not necessarily directly

00:51:59.756 --> 00:52:03.586
correlated with what
gets shown on the screen.

00:52:04.006 --> 00:52:06.746
So, what gets shown on the
screen is a sequence of glifs.

00:52:06.746 --> 00:52:10.916
A glif is the smallest unit from
a font that can be displayed.

00:52:10.916 --> 00:52:13.376
It may represent one character
or more than one character

00:52:13.826 --> 00:52:15.036
or a part of a character.

00:52:15.946 --> 00:52:18.206
The mapping between the
characters in memory

00:52:18.206 --> 00:52:21.106
and the glifs that are shown
is not necessarily simple

00:52:21.106 --> 00:52:25.806
and general, it can mean many
to many, and even the ordering

00:52:26.036 --> 00:52:28.256
of glifs within a line
can become complex.

00:52:29.096 --> 00:52:33.336
Now, our standard views and
controls use the text system

00:52:33.946 --> 00:52:37.596
to get proper Unicode
layout and display,

00:52:37.596 --> 00:52:38.726
so use them as much as possible.

00:52:38.726 --> 00:52:40.486
If you need to go beyond that

00:52:40.486 --> 00:52:44.446
and do custom display,
use text API's.

00:52:45.006 --> 00:52:48.996
Now it used to be, this was more
difficult on iOS than on OS X,

00:52:49.596 --> 00:52:51.346
because on iOS, you had
to go down all the way

00:52:51.346 --> 00:52:53.126
to the core text level to do it.

00:52:53.256 --> 00:52:55.366
Not anymore.

00:52:55.936 --> 00:52:58.966
With the iOS 7, we
have text kit API's,

00:52:58.966 --> 00:53:01.806
and there are some
excellent sessions on this.

00:53:01.846 --> 00:53:03.676
There was an introductory
session yesterday.

00:53:04.116 --> 00:53:06.636
There is a more advanced
session this afternoon

00:53:06.636 --> 00:53:09.686
that will tell you exactly how
they keep track of the mapping

00:53:09.686 --> 00:53:15.116
between the characters and
the glifs that display them.

00:53:15.416 --> 00:53:19.506
Here's an example; I got
this from a developer.

00:53:19.676 --> 00:53:22.796
This is some English text with
some Hebrew in the middle.

00:53:22.796 --> 00:53:24.696
So, English goes left to right.

00:53:25.166 --> 00:53:26.336
Hebrew goes right to left.

00:53:26.336 --> 00:53:29.016
You put them together, you
have bidirectional text.

00:53:29.686 --> 00:53:32.126
This is the proper order
for displaying the text,

00:53:33.136 --> 00:53:35.286
but the way it shows up in
memory is very different.

00:53:35.406 --> 00:53:38.616
It starts off with the English
on the left, flowing from left

00:53:38.616 --> 00:53:41.386
to right, then the Hebrew
in logical order flows

00:53:41.976 --> 00:53:44.446
for the first character,

00:53:44.446 --> 00:53:47.186
which shows up as the
right-most one and so on.

00:53:48.046 --> 00:53:49.396
Then this exclamation point;

00:53:50.206 --> 00:53:53.236
it's a bit ambiguous whether
the explanation point goes

00:53:53.236 --> 00:53:54.976
with the Hebrew or the English.

00:53:54.976 --> 00:53:56.066
Here it goes with Hebrew.

00:53:56.406 --> 00:53:58.776
In order to specify that,

00:53:58.856 --> 00:54:01.466
there are some Unicode control
characters that are included

00:54:01.466 --> 00:54:04.756
in this text and these
are things that may show

00:54:04.756 --> 00:54:05.646
up in text that you get.

00:54:05.646 --> 00:54:08.496
Text that you get from
an external source

00:54:08.496 --> 00:54:12.036
or from your localizers, or
sometimes text from formatters

00:54:12.176 --> 00:54:14.816
in bidirectional text languages.

00:54:14.906 --> 00:54:18.446
It may include these to
specify certain cases

00:54:18.446 --> 00:54:19.766
that are otherwise ambiguous.

00:54:20.196 --> 00:54:25.096
And again, the text API's and
the standard system controls

00:54:25.096 --> 00:54:26.886
and fields will handle
this properly,

00:54:27.186 --> 00:54:30.936
and give you the appropriate
Unicode sensitive bidirectional

00:54:31.166 --> 00:54:32.766
layout of this text.

00:54:33.986 --> 00:54:36.166
Text input; it's
important to keep in mind

00:54:36.306 --> 00:54:41.036
that it's not always a
matter of pressing a key

00:54:41.456 --> 00:54:43.996
and getting a letter
in the text.

00:54:44.566 --> 00:54:48.216
For languages that use complex
input methods like Chinese

00:54:48.216 --> 00:54:50.426
and Japanese, usually
what will happen is

00:54:50.426 --> 00:54:52.986
that the user types
a representation;

00:54:52.986 --> 00:54:55.566
a phonetic representation
perhaps of the text they want,

00:54:55.966 --> 00:54:58.336
that gets preliminarily
inserted into the text.

00:54:59.176 --> 00:55:02.086
Then the system shows them
some options of choices,

00:55:02.086 --> 00:55:03.766
and they pick the one
they actually want,

00:55:03.766 --> 00:55:04.966
and after that gets confirmed,

00:55:04.966 --> 00:55:06.646
and that's the final
text that goes in.

00:55:07.056 --> 00:55:10.876
So, in this case, the text on
the left has been confirmed.

00:55:11.046 --> 00:55:13.286
The underlying text;
it's called marked text,

00:55:13.286 --> 00:55:17.386
is preliminary only, and then
they'll pick one, and again,

00:55:17.386 --> 00:55:18.626
this is what it looks like OS X.

00:55:18.626 --> 00:55:21.886
This is what is looks like
on iOS; the same text.

00:55:22.356 --> 00:55:24.216
It's not just for
Chinese and Japanese too.

00:55:24.506 --> 00:55:29.116
On OS X, if you press and hold
to get accenting characters,

00:55:29.116 --> 00:55:31.706
it's the same, your preliminary
character gets insert,

00:55:31.706 --> 00:55:33.276
then the user picks
the final one.

00:55:34.136 --> 00:55:37.276
So, if you're dealing with text
as its input, keep in mind,

00:55:37.696 --> 00:55:40.226
it's not just a simple matter of
being inserted letter by letter,

00:55:40.276 --> 00:55:44.006
there may be this preliminary
marked test that shows

00:55:44.006 --> 00:55:46.146
up in your text view first.

00:55:47.176 --> 00:55:51.476
If you're dealing with text as
it changes, deal with it change

00:55:51.476 --> 00:55:54.966
by change, not keystroke by
keystroke, and you probably want

00:55:54.966 --> 00:55:56.836
to notice that text
views will tell you

00:55:56.836 --> 00:55:58.406
if there's marked
text from where it is.

00:55:58.906 --> 00:56:00.376
You probably don't want
to operate on that,

00:56:00.376 --> 00:56:03.906
because it's only preliminary,
it's not the final text.

00:56:04.336 --> 00:56:06.886
One last thing to mention
is that names, addresses,

00:56:06.886 --> 00:56:09.646
and phone numbers vary quite
a bit around the world.

00:56:10.266 --> 00:56:12.526
Names use many different
writing systems;

00:56:12.586 --> 00:56:17.266
sometimes a user will have
their family name first,

00:56:17.266 --> 00:56:18.216
and first name last.

00:56:18.396 --> 00:56:19.946
Sometimes they may
not have a family name

00:56:19.946 --> 00:56:21.036
or not have a personal name.

00:56:22.516 --> 00:56:25.586
Phone number formats
differ widely.

00:56:25.926 --> 00:56:29.196
The number of digits used
and the punctuation that goes

00:56:29.226 --> 00:56:32.596
between them, and there are
many different address formats

00:56:32.596 --> 00:56:33.116
around the world.

00:56:33.516 --> 00:56:35.126
So, try as much as possible

00:56:35.126 --> 00:56:37.976
to avoid making assumptions
about these formats.

00:56:38.176 --> 00:56:42.026
Do it only as your app needs
to for its own purposes.

00:56:42.456 --> 00:56:44.956
One thing that can help
sometimes is data detectors,

00:56:45.196 --> 00:56:49.536
which can detect phone
numbers and addresses

00:56:49.536 --> 00:56:52.986
in many different international
formats, so you can add this

00:56:53.186 --> 00:56:56.276
to some views, and it
will detect these things,

00:56:56.276 --> 00:56:58.286
and even make them into links.

00:56:58.756 --> 00:57:01.206
There is also NS data detector
at the foundation level

00:57:01.206 --> 00:57:02.286
for doing this protomatically
[assumed spelling].

00:57:04.866 --> 00:57:07.836
So, we have a lot of
documentation for all this stuff

00:57:07.836 --> 00:57:11.566
on line, both conceptual
documentation, tutorials,

00:57:13.386 --> 00:57:15.516
and there are a number
of relevant sessions

00:57:15.766 --> 00:57:18.966
that you might be interested
in, including sessions

00:57:18.966 --> 00:57:22.186
about auto layout, many
sessions about text kit

00:57:22.186 --> 00:57:23.136
and text handling,

00:57:23.576 --> 00:57:27.126
and tomorrow's very interesting
session on date and time.

00:57:27.976 --> 00:57:32.146
So, the most important things
to take away; for localization,

00:57:32.686 --> 00:57:34.806
you job is to make your
interfaces localizable,

00:57:35.676 --> 00:57:38.476
preferably by using base
localization with auto layout,

00:57:39.176 --> 00:57:40.906
and for your strings and code,

00:57:41.686 --> 00:57:43.836
use NSLocalizedString
and gen strings.

00:57:44.806 --> 00:57:47.676
For locale data, be sure to
use formatters; date formatters

00:57:47.676 --> 00:57:48.596
and number formatters

00:57:48.596 --> 00:57:50.556
when you're presenting
these things to the user.

00:57:51.346 --> 00:57:57.266
With the constants or templates,
if necessary, customize them,

00:57:57.326 --> 00:57:59.536
and then as calendar for
calendrical calculations.

00:58:00.776 --> 00:58:04.446
For text, use Unicode and NS
string, and the NS string API's

00:58:04.886 --> 00:58:07.026
for iteration, searching,
sorting, and so forth,

00:58:07.616 --> 00:58:10.256
and as much as possible, use
the standard views and controls

00:58:10.256 --> 00:58:11.386
for input and display.

00:58:11.986 --> 00:58:15.116
If you have to go beyond those,
use the text system API's

00:58:15.116 --> 00:58:19.196
to do so, and get proper Unicode
aware layout and display.

00:58:21.616 --> 00:58:23.906
Thanks everyone, have
a great conference.

00:58:24.516 --> 00:58:29.270
[ Applause ]
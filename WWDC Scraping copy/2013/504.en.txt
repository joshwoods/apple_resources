---
Title:  What's New in Game Center
Year:   2013
Web:    https://nonstrict.eu/wwdcindex/wwdc2013/504/

[!] This transcript has potential transcription errors.
---

My name is Daniel Kurtz. I'm an iOS engineer on the Game Center team here at Apple. And I'm here to talk to you today about what's new in Game Center. So before we really get into it, let's do a quick recap of what Game Center actually is.

Game Center is a gaming platform which allows the players of your games, be they single player or multiplayer, to be able to interact with each other by tracking their scores and achievements that they'd been earning in your game, sending challenges to their friends in order to beat those scores and achievements.

And then going even further with the multiplayer support, we have hosted turn-based gaming within the game kit framework, as well as real-time multiplayer matchmaking. Now, Game Center has been incredibly successful. You might have heard the other day that we have over 240 million players in Game Center, and they're playing games both on their iOS devices as well as on OS X.

So we've-- when I asked you what's new in Game Center this year, perhaps the first thing that comes to mind is our brand new UI for our Game Center app on iPhone. And we're very happy about this UI. We think it's very exciting and fun. But we're not stopping here. We've got a lot of things going on under the covers new this year for Game Center that you can take advantage of within your game in order to make it even further integrated and social with your players.

So today, we've got a large grab back of topics that we're going to talk about. First up is the Game Center in-game experience with the GK Game Center view controller. We also have a lot of new changes regarding leaderboards and scores, Leaderboard Sets, as well as Most Recent Score Leaderboards, a new type of leaderboard that allows you to track scores in a new way. Also, because we're talking so much about scores today, we have improved security measures to help you limit cheating within your game. And building on top of both scores and achievements, we've improved challenges even further to make it more immersive for your players.

And then, finally, last but not the least, we're going to round it out of talking about how you can take advantage of handling local player events and some fundamental API changes that we've done with how you can respond to events relevant to the local player of your game.

So let's get right into it. Let's talk about the Game Center in-game experience. And you probably all already know this game, perhaps, it's the in-game menu for Temple Run 2. And on that right column in the middle row, it's the leaderboards button. Now, today, if you were to pull out your iPhone and play this game and tap that leaderboard button, up would pop the GK Game Center view controller, giving you the ability to take a look at your leaderboard scores, your achievements, perhaps new challenges you've earned.

In iOS 7, that same thing still happens and we've updated the look, the UI of the GK Game Center view controller in a very radical way. We feel that this makes it much more ingrained, much more embedded within Temple Run 2. As you can see, Temple Run 2's screen still shows through in the background.

However, the same information is still available to your players. You still have the same list of leaderboards, can still look at the achievements that your players have earned or currently endeavoring to earn, and the challenges they've gotten from their friends, as well as the ability to rate the game within the App Store up in the top left or like the game on Facebook if they wish.

So programmatically, nothing has really changed as to how you're going to present the GK Game Center view controller. It's the same exact API that you'd be using before with a little bit of a wrinkle when you're thinking about performance. So let's take a look at some code. Let's say that you have a target action setup for that leaderboard button in your game and you want to hear when that button is tapped to show the Game Center view controller.

Well, in your target action method, the first thing you're going to do is grab the shared instance for the GK Game Center view controller, setting up the delegate to cells so that you can dismiss it appropriately, set up your view state to whatever appropriate initial view state you wish to show.

And here's a little bit of a wrinkle, the throttle rendering call. We'll get into that in just a moment. And then, finally, you're going to present the view controller just like you would with any other UI view controller within you game. Now that throttle rendering call that I'm talking about, right? As I mentioned, the GK Game Center view controller with iOS 7 is partially transparent.

Moreover, it's also doing some blurring and other heavy compositing on the GPU. So in order to make this present as smoothly as possible so that players can get in and out of the menu and back to playing your game, you don't really need to be running graphics at 60 frames per second and you're about to push this view controller over. So you can step back in the gas pedal a little bit and let the view controller present, dismiss when you need to, and get right back to it.

So really, that's all that's changed with the GK Game Center view controller. It's really just the exact same API with a brand new look that we feel really makes it that much more ingrained within your game. So let's move on to the next new topic of today. Leaderboard Sets. This is something we're very excited about. Today, on-- in iOS 6 device or on OS X Mountain Lion, your game currently has at most 25 leaderboards that it can define and use on Game Center.

Now, I'm happy to tell you that we have increased this maximum limit to 100 leaderboards. You can have at most 100 leaderboards in a flat list that your game can use in Game Center. And we're not stopping there. With this new feature that we have, Leaderboard Sets, we're increasing actually the maximum amount of leaderboards you can use within your game twentyfold to 500 maximum leaderboards.

And now, with Leaderboard Sets, we're introducing an organizational hierarchy, a structure that you can impose on these leaderboards. You can think of Leaderboard Sets as a tagging architecture where a single leaderboard can belong to many different sets, and likewise, a single set can contain many different leaderboards. Then you have at most 100 sets that you can use within your game and at most 100 leaderboards that you can put in a single set.

So why are we asking you to use Leaderboard Sets before you can actually unlock the full 500 leaderboards for use within your game? It actually comes down to usability issue. Let's say you've got a Water Planet group of stages, right? And also, for this group of stages, you have a boss level at the end. And maybe you've also got different levels of difficulty-- easy, medium, hard. So one possible leaderboard that your game has is the Water Planet Boss Level Medium leaderboard.

You, being the endeavoring game developer that you are, however, also have 499 other leaderboards that you've made within your game. So when a player wants to go and checkout their score on the Water Planet Boss Level Medium leaderboard, either within your game, the Game Center application, or the GK Game Center view controller, how are they supposed to find this leaderboard amongst all 500 leaderboards? It really comes down to a needle in a haystack problem, right?

So what sets allow us to do is to organize this into meaningful groups of data to make it a lot easier for players to parse when they're looking through your game. Here's an example from the GK Game Center view controller for this game, where when the player taps the leaderboard segment, the first thing that they are shown is the list of Leaderboard Sets within the game. Then if we were to tap that Water Planet set up at the top, the very next screen would show all the leaderboards that are contained within the Water Planet set. Pretty straightforward, right?

So let's consider how we could actually put this single leaderboard into various sets and how we can start imposing some order to the chaos of these 500 leaderboards. Well, right off the bat, we have three pretty obvious ways or three pretty obvious sets that we could organize a single leaderboard into.

One characteristic of this leaderboard is that it belongs to the Water Planet group of stages within the game. There's also the boss level for the Water Planet, and its medium difficulty. So right there, that's three different sets that this leaderboard could belong to. And while this leaderboard could belong to these sets, we could also add all the other leaderboards that belong to these appropriate sets as well.

So the Water Planet set contains all the stages for Water Planet-- water boss, medium, et cetera. So just like with leaderboards, Leaderboard Sets can have names of players saved. And moreover, depending upon the set that a leaderboard is contained within, the name for that individual leaderboard can change as well. So let's take a look at the examples of what this actually means and how it works.

So we go back to these three sets that we've defined that the Water Boss Medium Level leaderboard can be contained within. In Water Planet set, we could simply just name Water Planet, and that Water Boss Medium Level leaderboard, when it's contained within the Water Planet, that is when the player has navigated to the Water Planet set to look at this leaderboard, we could just display the string boss medium. From here, it's clear that this is the Boss Medium Level leaderboard for the Water Planet group of stages. There's no redundant information. Everything is very much contextual. And we can go and name all the other leaderboards appropriately for that set as well.

Then the Water Boss Set, just call it Water Boss. That same leaderboard when it's in the Water Boss Set, we only have to call it medium because it's obvious it's the medium level of difficulty for the water boss set. We go and name all the other leaderboards in that set appropriately. And then you're getting the picture with medium set, call it medium. And we could call this one stage Water Boss. And name all the other medium level leaderboards in the medium set appropriately as well.

So we've gone and we've given this single leaderboard different names depending upon the way the players have actually navigated to it. But it's still the exact same leaderboard. That is, regardless of the path that players happen to go or take in order to find this leaderboard, the exact same list of scores is going to be displayed to the user. It's just really UI customization option that you have at your disposal in order to make information contextual and not redundant.

So let's take a look at how we can actually set your game up in iTunes Connect in order to use Leaderboard Sets and start organizing the leaderboards of your game into these sets. We're going to take a very, very quick blow-by-blow quick flyover here. I definitely urge you to check out the iTunes Connect session tomorrow, however, if you want to get more detail as how you can set up Leaderboard Sets within your game. So in the Game Center page for your game on iTunes Connect, in the leaderboard section of that page is this new button, Move All Leaderboards into Display Sets.

When you click this button, you're going to be asked to create the very first set for your game. And now, the first thing that you're going to have to do when you're creating this set is to find a handle. This is really just the name that you're going to be referring to this set when you're configuring it on iTunes Connect. This isn't the same as the string that players are going to see when they're using your game. It's really just a convenience for you.

Then, after creating that handle, that Set Reference Name, you're going to have to create a leaderboard set ID. Just like leaderboards, you have to create a unique identifier for your set on iTunes Connect. And we suggest that you create it as a reverse DNS style string. So in this case, for the Water Planet set, we're going to give it this reverse DNS string. Now, after that, you've created a set.

And from creating a set, you actually have to give it a name that is going to be displayed to your players. So the very next step you're going to have to take is within the Display Set Localization portion of the screen after creating the set, there's an Add Language button here. And you need to then go and create language-specific display names for this set.

So we could take, say, English as the first language that we're going to define a name for, for this set. We're going to name this Water Planet set just Water Planet, liked we talked about in the example. And then we can also create an English locale-specific image that we wish to be displayed to players when they're looking at this set on English locale devices. And then, further, if you're creating your games for multiple languages either now or in the future, you can create other localizations as you see fit.

So after you've created the display name for this set, the next thing you need to do is actually start adding leaderboards in your game into this set. So you'll see another part on the screen that says Leaderboards in This Set with Add to Set button. Clicking that button, you're going to be asked to select one of the leaderboards that you've already defined in iTunes Connect.

Let's take that Water Boss Medium Level leaderboard. And then you're going to have to give that leaderboard a name when it's being displayed within the Water Planet set. So again, you choose a language, give, in this case, the English language string that's going to be displayed to your players. And then either now or in the future, go and give other languages if you decide to localize your game for multiple locales.

So that's really all there is to it for actually setting up sets within iTunes Connect. Now, using Leaderboard Sets programmatically with the Game Kit Framework is very straightforward. We nowhave a GK Leaderboard Set class and it defines three fundamental properties that you're going to have to care about when you're using sets within your game.

The first is an NS string title. Now this is really just the display name that you set up on iTunes Connect for your set. And if your game is running on an English locale device, it's going to display the English name, Japanese or Japanese name, et cetera, et cetera, just like how leaderboard titles work today as well. Then you're going to have your NS string identifier. This is just the set ID that you defined on iTunes Connect.

And, as well, optionally, there's the group identifier. Now we didn't talk about this in the iTunes Connect overview, but just like how leaderboards work with game groups, a feature that we introduced last year, so too do Leaderboard Sets. And we're not really going to talk a whole lot about the group identifier in game groups with Leaderboard Sets today, but I definitely urge you again to check out the iTunes Connect session tomorrow for more detail on that.

So we've got the GK Leaderboard Set class. Just like GK Leaderboard objects before, you can actually use the sets that you've set up on iTunes Connect within your game. The very first thing you need to do is load all the sets that belong to your game. And you can do that calling Load Leaderboard Sets with Completion Handler.

Now, when your completion handler is called, you're going to be passed back an NS array of GK Leaderboard set instances. And from there, you're on free. You can do anything that you wish with these leaderboard set objects. For instance, you can load the leaderboards that are contained within those sets. So when this completion handler is called, we can take one of the sets that we've been given back.

And to load the leaderboards that are contained within that set, we could call Load Leaderboard with Completion Handler or Load Leaderboards with Completion Handler. And when that completion handler is called back, you'll be provided an NS array of GK Leaderboard instances. And now I'm assuming that you're already familiar with GK Leaderboard objects, from this point, you can treat these objects just like you would any other GK Leaderboard object within your game.

One other thing that you can do with GK Leaderboard set instances is to load the image that you upload with iTunes Connect for that set. So within this Load Leaderboard Sets with Completion Handler called back, you could take one of those sets and call Load Image with Completion Handler. And that completion handler will pass back a GK image object.

So a GK image object is really just a typedef. If you're running on iOS, then that's going to point to UI image, if you're running on OS X, they'll be an NS image. And once this completion handler is called back, you can use it just like any other image asset within your game.

So that's Leaderboard Sets. Again, it's-- you can think of them as a tagging architecture. It allows you to group multiple leaderboards into a set. A single leaderboard can be contained within many different sets. An important thing that I wish to pint out here is that if you wish to unlock all 500 leaderboards, that is, if you wish to adopt Leaderboard Sets within your game, then you must make sure that every leaderboard that you create within your game is a member of at least one set.

So let's move on to the next new thing with leaderboards today, Most Recent Score Leaderboards. So you're all probably already familiar with how leaderboards work within Game Center, the best score ranking system. That is, if you've got an ascending leaderboard or ascending sort order leaderboard, and your player happens to earn 10,000 points today, then tomorrow, when they score 5,000 points, let's say, 5,000 isn't better than 10,000, so 10,000 is going to remain on the all-time time span for that leaderboard.

Or what if you want to implement a leaderboard where scores can both go up and down over the course of people playing your game, like batting average. If you want to track your player's batting average over a season, that's going to not just be monotonically increasing or decreasing, it's actually going to be increasing or decreasing over time. So that's what a Most Recent Score Leaderboard allows you to do.

Most Recent Score Leaderboards, they're just an alternative to Best Score Leaderboards. And the way that they function should be pretty obvious by the name. It's just that the next score that you submit to a leaderboard for your player, that's going to be the score that shows up on the leaderboard in Game Center.

So really, what this means, it's actually a very profound effect of this is that it allows you to take full 100 percent control over the ranking system for this leaderboard. You could do things like power rankings for your chess game or your legendary RPG Heroes game. You could do win/lose percentage or even, you know, simpler things like batting average or golf strokes or OPS. Really, it's entirely up to you. And setting up a Most Recent Score Leaderboard for your game is really just a single checkbox away on iTunes Connect.

Within the Leaderboard Configuration screen on iTunes Connect when you're creating a new leaderboard, you'll notice that there's a new field here called Score Submission Type. Now by default, that Best Score field is going to be clicked. However, if you click the Most Recent Score checkbox right there, that instantly turns this leaderboard into a Most Recent Score Leaderboard.

Now you may already be familiar with the Sort Order field right below, we've had this for a long while already. Sort Order is just as applicable to Most Recent Score Leaderboards as it is to Best Score Leaderboards. If you say set this to low to high, then the lowest scores are going to get the best ranks on this leaderboard. So using baseball, again, as an example, if you want to track ERA, you'd probably want it to be low to high because lower is better. High to low for batting average. You want it so that the highest scores get the best ranks.

So Most Recent Score Leaderboards programmatically are identical. 100 percent identical to regular best score leaderboards in the Game Kit Framework. However, since you are now being given the power to entirely customize the ranking system that's afforded to you, there's a lot of things that you could do when you're preparing these scores for submission. So let's take a look at an example of what you could do.

Let's say that you want to create a power ranking system, that is, you have a multiplayer game and you've got like a ladder ranking system within your game so that if a high-rank player and a low-rank player play each other in a match and the low-rank player happens to win, then the low-rank player's rank is going to jump up the difference of those two players' ranks, and vice versa, the high-rank player, because he lost, is going to drop by the difference.

Well, what we could do here programmatically is at the end of the match, we could load the leaderboard scores for those two players, the local player and the other player, setting the identifier for the GK Leaderboard object to that Most Recent Score Leaderboard identifier you've set up on iTunes Connect.

So once you've loaded the scores with completion handler and your completion handler is called back, you can grab the score values for both the local player and the other player. And then, based upon the previous power ranking, that is, the local player's value of the local player and the previous ranking of the other player's value, as well as the outcome of the match whether the local player happened to win or lose, you can create a new local player score value.

Then from there, you submit these scores just like you would any other score to any other regular old leaderboard. You allocate a native score with the leaderboard identifier for the Most Recent Score Leaderboard, you set the value to the new local player's value, and then, finally, you call report scores passing in an array with that local player's score.

So, really, that's all there is to Most Recent Score Leaderboards. It's very, very similar to how you would work with Best Score leaderboards programmatically, but since there's so much else that you can do in order to customize the ranking system, really, the opportunities are endless as to what it can do.

So while we're in the neighborhood of GK Leaderboard and its API, I just want to touch on a couple of changes that we have this year with iOS 7 for the Game Kit Framework. First of all, you may be familiar with the GK Leaderboard Category property. That was a pointer for basically the NS string identifier that you set up on iTunes Connect. We're deprecating this in favor of the identifier property. And the reason is basically because with GK Leaderboard Sets, sets and categories, they sound sort of familiar or similar to each other, so in order to, you know, allay any confusion, we're deprecating the category property.

You may also be familiar with the Set Default Leaderboard with Completion Handler Call on GK Leaderboard as a class method. Now, this basically allowed you to make it such that when a player is viewing your game within the Game Center app, that the very first leaderboard that they're presented with within your game detail view is the leaderboard that you're choosing. But since this is something that isn't so much of the property of the leaderboard, but much more the local player, we're deprecating the GK Leaderboard method in favor of GK Local Player Set Default Leaderboard Identifier Completion Handler method. So use that instead in case you're interested.

So we've talked a lot about new leaderboard features today, Leaderboard Sets, to increase the maximum amount of leaderboards that you can use, as well as Most Recent Score Leaderboards, and new ranking systems that you can create using them. Let's take a quick peek under the hood as to how actual score submission works in the Game Kit Framework in the Game Center platform, and what's going on under the hood when you're communicating with Game Center.

So when your game is running and it's making submissions to Game Center, whether it's running on an iOS device or an OS X system, it's actually not alone. We have a daemon called gamed that is always running in the background. And when your game is communicating through the Game Kit Framework with the Game Center platform, transparently, as in you don't need to remember any of this, transparently, your game is actually establishing a connection with gamed, our daemon.

Then in turn, gamed is establishing a connection with the Game Center servers in the outside world. So when you submit a score, let's say, to the Game Center system, you're actually submitting that to gamed. And now, gamed is going to automatically relay that to the Game Center server. So why do we do this? Well, let's say, for instance, that internet connectivity of the device happens to be lost, and thus, the connection with the Game Center server is separate.

Well, for any score submissions or achievement submissions or any other type of submissions happen to fail because of this, gamed will automatically store those requests that you're making. Any of the failed ones or any of the future ones that you're making to game d, your game doesn't need to worry about internet connect-- internet connectivity, gamed is always just there managing it for you.

So that when Game Center server, the connection with the server happens to be reestablished and the device comes back online, or even if your game happens to go offline before these submissions make it over, gamed is going to immediately go and forward those score submissions over to the Game Center server on your behalf. Really, you don't need to worry about any of this, it's all done transparently for you.

So you may be familiar with the report scores with completion handler API and how our completion handler, as a signature, such that it can pass back an NS error object. This is largely vestigial. This whole store and forward mechanism with the gamed daemon is something that we introduced in iOS 5.

So it's been running up through today. As long as your score and/or if you're submitting achievements, your achievements happen to be in it with the proper consistent identifier that you set up on iTunes Connect, you don't need to worry about checking this NS error object and its value.

We're actually not going to hand one back to you. In the past, before we implement the store and forward, we used to ask you to check to see if there was an internet connectivity error that was handed back to you. And if so, we asked you to actually do the storing and forwarding of these requests later.

But you don't need to do that. You haven't had to do that since iOS 5. So if you've got a code like that within your game, definitely take it out. You don't have to worry about caching your scores and achievements. In fact, we definitely urge you not to because there are complications that can arise with challenges.

Just the moment that your player has earned the score and achievement, submit right away. Give it over to gamed, it'll do the heavy lifting for you. And that being said, if you're submitting multiple scores for a single play-through session, like, let's say, your player is going to be earning coins in the session, they're also going to be getting a track time around the level, and then finally, you're also going to be submitting another score for their high score in that level, then those are three different scores, you should batch those into a single NS array and pass that in via report scores method.

So that's what new in leaderboards. A lot of new stuff. We've got many more leaderboards with Leaderboard Sets, up to 500 leaderboards that you can define within your game. We also have Most Recent Score Leaderboards that allow you to create custom ranking solutions for your game. And we also took a quick peek under the hood of how gamed works when you're submitting scores and also achievements and other requests to the Game Center platform, and how we do the heavy lifting for you so you don't have to worry about this caching logic and network connectivity. You just have to submit your scores and then get right on to letting players play your game.

So we've talked a lot about leaderboards today on a very related topic that I think dovetails pretty nicely. Let's talk about how we can limit cheating within your game. Now you may all be familiar a bit with screens such as this. In case you don't recognize that there's some suspicious score values here.

I don't think, you know, the six top players or however many in this game happened to have earned in 64 max, but I don't think that's actually ever humanly possible. So clearly, something suspicious is going on here and it probably means that there are people who are cheating in the game. I'm happy to tell you today that with iOS 7, we are doing three things in order to help you limit and combat cheating within your game.

And the first is completely free for you. When your game is submitting scores to gamed on an iOS 7 device, when it reaches gamed and gamed goes to relay that score to the Game Center server, it is automatically attaching a cryptographic signature to the score submission, as well as other submissions like achievements. So that if a nefarious player happens to go and tamper with that submission when it's in midstream to the Game Center servers, that's going to get picked up automatically and Game Center is going to reject that score outright.

That's free for you. You don't have to do any sort of coding or configuration steps. If your game is running on iOS 7, we've gotten that taken care of for you. Now another thing that you can do in order to help limit cheating within your game like from an exploit level or angle is with the Score Range property on the Leaderboard Configuration screen in iTunes Connect.

If you've got a leaderboard where it's only believable or only humanly possible for a player to legitimately earn at most 10,000 points within that leaderboard on your game, then I definitely suggest that you set that To Value in the Score Range field to 10,000. What this does is it essentially creates a visible score range for scores within your leaderboard for that game.

And what I mean by that is if a player happens to submit, say, one billion points to this leaderboard, when it's really only humanly possible for them to earn 10,000 legitimately, then the Game Center server is going to accept that score submission, it's just not going to be visible to other players of the game when they're looking at that leaderboard.

So we're hanging on to these scores, right? There are a lot of reasons, one is because circumstances within your game might actually change. You might realize that you forgot to carry the one, for instance, when you're trying out your game design docs, and you realized that it's actually totally allowable and believable for a player to earn at most a billion points within this leaderboard.

So at a later time, you can come back to the screen in iTunes Connect, vamp that To field up to a billion, and that player's score that was earlier hidden by the Game Center server will now become visible. So this isn't an unforgiving configuration set. It's just another arrow in your quiver to help limit cheating and exploits within your game, but it will allow you to backtrack in case you decide that, "No, it's totally OK all along."

The third thing that we are providing you with iOS 7 and OS X with iTunes Connect to help limit cheating is a brand new configuration tool within iTunes Connect. And this tool is going to help you audit suspicious player activity on your leaderboards of your game. And now, we've got a lot of things that we're talking about today.

So I definitely urge you to check out what's new on iTunes Connect session tomorrow 'cause they're going to go into in-depth as to how you're going to be able to actively manage player activity within your game, 'cause you know you're being best, you made it. And it's a living breathing thing so you understand it as it's being played. So with this tool, you'll be able to make sure that everything is running smoothly.

So that's what's new in security for Game Center. We've got signed submissions, this is totally free for you. We are signing every submission we're making to the Game Center platform and to the server. So if anybody happens to tamper with it, when it leaves the device and goes off into the internet, we're going to detect that on the other end and we're going to reject those submissions outright.

Definitely, I suggest you use the Score Range field within iTunes Connect on the Leaderboard Configuration screen in order to filter out anybody who's exploiting issues within your game. And then finally, we've got a new management tool that's going to allow you to help audit suspicious player activity. And you can find out more about that tomorrow.

So we've gone through new leaderboard features as well as how we can help you limit cheating within your game if it's Game Center enabled. Let's move on to the next topic today-- Challenges. So Challenges was a brand new feature that we introduced last year, and we've been thrilled with the uptake and adoption of challenges in your games.

And we introduced, again, last year with iOS 6 Mountain Lion. And what it really does is whether your game is a single player or a multiplayer, challenges add a competitive element to your game. If your game support leaderboards or achievements within Game Center, and players can challenge each other to either meet or beat those leaderboard scores or to earn those achievements that they've earned.

And this was also supported automatically whether through the Game Center app on iOS or OS X or through the GK Game Center view controller, players that go through our UI, select their scores, challenge their friends to beat those scores, same with achievements, and players would start receiving notifications and would complete everything, and it was great. We also provided you, however, with API to extend your game for custom challenge gameplay to hook into events when players happen to complete a challenge, and also to allow you to issue challenges programmatically within your game.

So before we talk about what's new in Challenges this year, let's just do a quick run through of how Challenges work currently. So let's say Tom is playing a racing game and he happens to earn a lap time of 50 seconds around the track. Then he could challenge Alice to go and beat his lap time of 50 seconds. So he sends a challenge to Alice. Alice gets that challenge and she opens up your game, and she happens to play that same track getting a score of 40-second lap time.

Now, 40 seconds is better than 50 seconds, so Alice has completed that challenge. She gets a push notification to her device from the Game Center server telling her that she just beat the challenge. Automatically in the background, since the score challenge, Tom gets a new challenge from Alice challenging him to beat her score of 40 seconds.

So that's great and that's how Challenges work currently. But let's say that Tom happened to earn that lap time using a beat-up old pickup truck per se. So it might be hard to actually get 50 seconds as a lap time with a beat-up old pickup truck and much, much harder than doing it with, say, a super car. So how can we make it such that when Alice gets that challenge from Tom that she can only complete that challenge as long as she's earned that score with the same gameplay context that Tom used to earn his score?

Well, that's what a new feature, Modal Challenges, allows you to do. Now, Modal Challenges, what they allow you to do is when you're reporting scores and reporting achievements to Game Center, you can optionally provide us with a list of challenges that you wish the server to consider for completion.

And this entails some new API. Report Scores and Report Achievements now have extra methods for Report Scores with Eligible Challenges with Completion Handler and Report Achievements with Eligible Challenges with Completion Handler. This API doesn't replace the current Report Scores and Report Achievements API that you know. It's really just an augmented version in case you wish to make use of Modal Challenges within your game.

So let's take a look at how we can make sure that when Alice is earning her lap time around this track in your game that she only completes challenges that were earned for that exact same car that Alice has raced around with. So at the end of Alice's play through, right, first thing that you could do is load the Received Challenges that Alice got from her friends, and that completion handler is called back. You could filter through any of the score challenges because we only really care about lap times in this case.

For every score challenge that Alice has received from her friend, there is a context property. Now this is something that has existed forever in Game Center. Every score has a UN64 property called context that you can add any value that you wish to the score. And when you either submit it to a leaderboard or attach to a challenge, that context is going to be attached to that score on the other end. So you could embed the car model that Tom happened to race around the track with on that score that he used to create the challenge. And then on Alice's device, you can pull the car model out of that score.

All you need to do is check to see whether the car model for that challenge happens to match the car model Alice just used to race around the track. And if it does match, you can add it to these challenges with same car array. Really, just a list of challenges you wish to be considered by the Game Center servers for completion.

And finally, you're going to use the new API for Report Scores. You're going to pass the score that Alice just earned in her play through session and you're going to pass a list of the challenges that were created with scores with the exact same care that Alice just raced around the track end. And then the optional completion handler.

And that's it. That's how Modal Challenges work. As well as making sure that only challenges that makes sense can be completed within your game, this also allows you to do things like challenge-specific modes within your game so that when a player launches your game because they wish to play a single challenge, you could set them up an entirely new gameplay mode so that when they are in a score in that mode, only that one challenge is completed. Really, it's all up to you.

A new feature that we have for Challenges as well regards programmatically issuing challenges within your game. Now, we allowed you to programmatically send Challenges to players within your game when we released Challenges in iOS 6 and OS X Mountain Lion. And we further augmented this with iOS 7.

So let's say that your player just happened to complete a level and they earned a score of 500 points and maybe they even earned an achievement, right now will be a great time to allow your players to send a challenge to their friends. You don't want them to have to exit your game in order to go into the Game Center app to do this, it's better for them to just do it right here so that they can get on with playing your game.

Now again, last year, with iOS 6 and OS X Mountain Lion, we allowed you to do this. We're making it even easier this year by providing you with a friend picker and compose controller that we create on your behalf and present to the player, where they get a list of their friends, and if it's an achievement challenge which friends have earned this achievement or eligible to receive this challenge, the player can then select friends, one or many, that they wish to send this challenge to, pressing the Next button, up comes a composed controller with a preformatted default message that you can optionally pass to us that they can edit, and then they can choose to send that challenge to their friends.

Using this composed controller flow is very, very straightforward. And let's take a look at how we can do this with achievement challenges. The first thing that you're going to do is allocate your GK achievement object just like you would in any achievement challenge that you wish to issue programmatically previously. You set up the achievement, setting the identifier with the appropriate identifier on iTunes Connect. And you make sure that you set that percent complete value to 100 percent. You can only challenge friends to 100 percent complete achievement, not part way.

And then, to get this UI view controller that represents the composed sequence, you're going to call a new API. And it's available on both GK achievement and GK score, and it's this method here. Its challenge composed controller with players where you can pass in an optional list of friends of the local player that you wish to be preselected. Then a message which is an optional NS string that you can pass that will pop up in the composed controller as the default message that players can then edit. And then the completion handler.

And when the completion handler is called back, that means that the player happen to either send the challenge to their friends or cancel sending the challenge. And at this point, you need to dismiss the view controller and then do whatever post processing you wish because we also tell you whether the player happened to really issue that challenge, and if they did, which friends and player IDs they sent that challenge to.

And then finally, once you've gotten this incense of the UI view controller, you just need to present it like you would any other UI view controller within your app. And that's it. That's how you do programmatic issuing of challenges with iOS 7. We think it makes it even easier in order to allow players to send challenges to each other.

So you may be familiar already with our existing Issue Challenge to Players Message method. And since we've really streamlined the way that you can send challenges to friends of your local player, we're deciding to deprecate this method. And instead, we urge you to move on to using the Challenge Composed Controller with Players Message Completion Handler, the new API.

Now, in case your game is running on an iOS 7 device and is still using this legacy API, they'll still work, but we're going to present a composed controller and friend picker to the player on your behalf automatically. And this is great, but I definitely urge you to consider moving over to the new API because if you were programmatically sending challenges in the middle of a gameplay session per se, you definitely don't want a view controller to pop up in the middle of a player jumping over a very wide pit. So you know when the timing is best to actually present this UI. So definitely move on to the new API that we have.

So that's what's new in Challenges. We've got modal challenges for selective completion of challenges within your game based on context that you define. We've got brand new programmatic issuing of challenges API to make it even easier to send challenges to friends with a local player in your game.

And we've also-- because of this streamlined API, we've deprecated the issue challenge API. And if your game still happens to use it when it's running on iOS 7, it's still going to work, but the new UI, that new view controller, is automatically going to be presented to the local player.

So that's Challenges, that's what's new in Game Center for Challenges. Let's move on to the next big topic of the day-- handling events relevant to the local player. Now you may be familiar with handling events for the local player in the Game Kit Framework today. We have a lot of different singleton objects that you had to declare delegates for.

If you want to hook into when the local player completed the challenge, we have the GK Challenge Event Handler Singleton and we had the GK Challenge Event Handler Delegate Protocol that you would set as a delegate for that event handler. We also had things for turn-based match-- or for a turn-based gameplay, they had a singleton object, and the GK Matchmaker had an invite property.

Well, we've thoroughly revamped the way and redefined the way in iOS 7 that you can handle events relevant to the local player. And we're doing it like this. You can think of the GK Local Player instance as the source of all the events that are relevant to your local player.

And so, whether the players received the challenge, completed the challenge, gotten a new turn, maybe a turn-based invite or some matchmaking invite, that's going to be channeled through the local player. And the local player can have multiple listeners registered to it. And when a local player listener is registered on the local player and a message happens to come in, an event is triggered, that listener or any listener that is compatible for that callback is going to get called.

Your listener object when you register on a local player, it needs to conform to the GK Local Player Listener Protocol. And this protocol, in turn, conforms to three sub-protocols, all defining optional methods. None of the methods in these protocols are required, so you can pick and choose. First is the GK Challenge Listener Subprotocol that defines the various callbacks that you can optionally conform to when the player has completed a challenge or had some sort of challenge relevant event occur. We've also got GK Turn-Based Event Listener for turn-based gaming specific callbacks and GK Invite Event Listener for GK Matchmaking, real-time matchmaking callbacks.

Once you've created your listener, in order to register, it's very straightforward. I'm going to adopt one of these subprotocols or any of those methods and those subprotocols, and you're going to call on the Local Player Instance Register Listener passing this listener instance that you've set up. And you can pass-- you can register multiple listeners.

And you also don't need to worry about the timing that you're registering these listeners. You may be familiar that previously we asked you to register or set delegates on turn-based event handlers, challenge event handlers, all those other singletons in the authentication handler callback. Well, you don't need to worry about that anymore.

In case your-- the local player happened to receive some sort of event and there is no listener registered for the local player at that time that could handle that event, the local player is going to cache that event. So when you register listener at some time later, it'll have that event to dispatch to your listener or all of the listeners that are capable of handling that event.

So since we've talked a bit about challenges today, how about we take a look at the group of methods that you can implement optionally within your listener in order to hook into challenge relevant gameplay? The GK Challenge Listener Subprotocol defines four different methods that you can optionally implement in order to hook into challenge-specific events concerning the local player. Let's take a quick look through these different methods, what they mean, and how you can use them within your listener object or objects in order to enable custom challenge based gameplay in your game.

The first is concerning selecting challenges. That is, when a player happens to receive a challenge from a friend, whether they are playing your game or they're hanging around in the Game Center app, and they tap an iOS notification center banner or they tap a play bubble within the Game Center app, or if they tap a play bubble within the GK Game Center view controller, we're going to call back to your listener Player Wants to Play Challenge.

And really, what this means is that the player tapped this challenge banner and they want to play your game in order to complete that challenge. So at that point, if you've got challenge-specific gameplay modes within your game, you can call Self-Start Challenge for Challenge if you've got a method like that, passing in the challenge to set up this gameplay mode for challenges.

Similar to selecting challenges within your game, we also got receiving challenges. This is an event that is called back to your-- on your local player listener when the player is playing your game currently and they happen to receive a challenge from a friend. At that time, player did receive challenge is going to called on your listener and you may wish to present some custom UI, like if Alice sent Tom a challenge to beat her track score, you might want to show Alice's picture right there with the challenge message that she happened to define. And you could do that within this method.

The last two methods in the GK Challenge Listener Protocol are concerning completing challenges. The first, when the local player happened to complete a challenge that they receive from a friend, Player Did Complete Challenge Issued by Friend is called when the local player completes a challenge in your game. And at this point, you know, if you want to congra-- display a congrats banner to the player or whatever UI, maybe even reward them gameplay-wise within your game, you could do that here.

And then, also, when the local player's friend happened to have completed the challenge that the local player sent then, that's where Player Issue Challenge was Completed by Friend is going to be called back on your listener. At this point, you might want to inform the player that perhaps their friends are a little bit better than they thought they were, and again, do whatever you wish in your game that makes sense.

So that's just how challenges work with GK Local Player Listener. But we're also doing a lot of things concerning turn-based gaming as well as real-time matchmaking. Those are all built with the GK Local Player Listener architecture as well. And as you may guess, that means that we are, in turn, deprecating the GK Challenge Event Handler, the GK Turn-Based Event Handler Singleton and their delegates, as well as the Invite Handler property of the GK Matchmaker object.

And since this affects multiplayer as well, tomorrow, Nathan's got a multiplayer session, making multiplayer games with Game Center, I definitely urge you to check that out in order to learn how you can adopt GK Local Player Listener Protocols, in order to use turn-based gaming within your game and GK Matchmaking.

So we've learned a lot of different things today. In addition to our brand new UI that we've also got going on with the GK Game Center view controller, we've increased the maximum amount of leaderboards that you can use within your game to 500 leaderboards. And you can impose a hierarchical structure on these leaderboards with a new feature called Leaderboard Sets.

Most Recent Score Leaderboards, in case you want to make it such that player scores on a leaderboard can go both up and down, and completely customize the way that you rank players within a leaderboard for your game, we've got those too. Security measures that we're taking on your behalf and we're also allowing you to take in order to help combat and limit cheating within your game.

Challenges, we've got modal challenges, further augmenting challenge-based gameplay, and making it even easier for you to allow your friends to send-- or your players to send challenges to their friends within their game. And then finally, we have totally redefined the way that you can handle events with-- concerning the GK Local Player-- with the GK Local Player Listener API. So it's a ton of stuff that we've got going on this year, and that means that you probably have a lot of questions.

So Allan Schaffer, he's our Graphics and Game Technologies Evangelist. You can reach him at this address right here. Ask him if you've got any questions after the conference. Also, we've got brand new documentation updated for this year's Game Kit Framework available at the URL in the screen, as well as at developer.apple.com, we've got some sample code exhibiting how you can make use of best practices in order to adopt Game Center features, both new for this year with iOS 7 and preexisting. So definitely check that out.

As well as Apple developer forms, definitely use those. So a couple of sessions, what's new in iTunes Connect tomorrow, check that out if you want to learn more about how to use game groups for Leaderboard Sets, this new auditing tool to help limit cheating, turn-based gaming with Game Center. So thank you so much everybody. Have a great WWDC. It's been a pleasure. [Applause]

[ Silence ]

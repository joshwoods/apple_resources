WEBVTT

00:00:00.506 --> 00:00:09.516
[ Silence ]

00:00:10.016 --> 00:00:14.000
[ Applause ]

00:00:15.326 --> 00:00:16.076
>> Good afternoon.

00:00:17.186 --> 00:00:20.116
My name is Doug Gregor and I'm
here today to talk today to you

00:00:20.276 --> 00:00:22.196
about Advances in Objective-C.

00:00:23.786 --> 00:00:27.906
Objective-C is a great language
with the vibrant user community.

00:00:28.846 --> 00:00:31.776
If you're here last year,
you saw that we are really,

00:00:31.836 --> 00:00:33.966
really excited that
we could see this here

00:00:33.966 --> 00:00:35.876
in the TIOBE Programming
Community Index.

00:00:35.876 --> 00:00:38.096
This is from May 2012.

00:00:38.806 --> 00:00:40.916
And we see that Objective-C
had moved all the way

00:00:40.916 --> 00:00:42.526
up to fourth place
in the rankings.

00:00:42.856 --> 00:00:43.796
Just pretty amazing.

00:00:44.666 --> 00:00:47.946
Well in just the last
year, Objective-C has moved

00:00:47.946 --> 00:00:51.376
up even further displacing
the vulnerable C++

00:00:51.376 --> 00:00:52.846
for the number three spot.

00:00:52.846 --> 00:00:53.586
Whoo!

00:00:54.516 --> 00:00:59.306
[ Applause ]

00:00:59.806 --> 00:01:01.526
So how do we evolve
the Objective-C?

00:01:01.886 --> 00:01:04.296
Well, there are some
things that we focus on.

00:01:04.676 --> 00:01:07.486
The two things in general that
we really do want to focus

00:01:07.486 --> 00:01:10.016
on are developer
productivity, that's your time,

00:01:10.686 --> 00:01:13.336
and software quality,
that's the quality that goes

00:01:13.336 --> 00:01:14.506
into your applications.

00:01:14.976 --> 00:01:17.336
And we can improve
both of these things

00:01:17.946 --> 00:01:20.506
through evolving the language
and the tools that support it.

00:01:21.626 --> 00:01:25.026
So in the realm of developer
productivity, we can do things

00:01:25.026 --> 00:01:27.316
like find places where
there's boilerplate,

00:01:27.316 --> 00:01:30.256
you're writing the same thing
over and over and over again,

00:01:30.256 --> 00:01:33.546
at synthesize, at synthesize,
at synthesize, and eliminate

00:01:33.546 --> 00:01:36.276
that from the language by
getting the right defaults.

00:01:36.676 --> 00:01:39.806
Second, we can find other
operations that you do day in

00:01:39.806 --> 00:01:42.316
and day out throughout many,
many different code bases

00:01:42.536 --> 00:01:45.036
and simplify them, bring the
syntax into the language,

00:01:45.036 --> 00:01:49.746
make them easier to use, faster
to write, faster to read.

00:01:49.746 --> 00:01:52.146
And finally, we can
provide great tools

00:01:52.196 --> 00:01:55.336
because you use tools to
write codes in Objective-C.

00:01:55.696 --> 00:01:59.186
And part of this is developing
the tools themselves and part

00:01:59.186 --> 00:02:02.186
of this is making sure that
the language itself is amenable

00:02:02.186 --> 00:02:03.326
to building great tools.

00:02:03.326 --> 00:02:06.246
We'll actually get back to that
with our first major feature.

00:02:07.456 --> 00:02:09.556
The other area is
software quality

00:02:09.556 --> 00:02:12.026
and how can we help there
through the language.

00:02:12.856 --> 00:02:13.756
So, couple of areas.

00:02:13.846 --> 00:02:16.246
We can try to catch
more bugs earlier.

00:02:16.686 --> 00:02:20.646
You can do this through stronger
and better static type safety

00:02:21.056 --> 00:02:23.476
so the compiler can reason
about the type in your program

00:02:23.476 --> 00:02:25.946
and warn when something
is going wrong.

00:02:26.166 --> 00:02:30.086
Next, we can find error
prone tasks, for example,

00:02:30.086 --> 00:02:33.576
writing retain and release
everywhere, automate those away

00:02:33.576 --> 00:02:36.736
within the compiler to eliminate
huge classes of problems.

00:02:38.056 --> 00:02:40.916
And finally, Objective-C is a
language with a rich history.

00:02:40.916 --> 00:02:42.666
We have a large developer
community

00:02:42.666 --> 00:02:45.316
that has established
best practices for how

00:02:45.316 --> 00:02:46.866
to use this language well.

00:02:46.866 --> 00:02:49.366
And we can bring those
into the language

00:02:49.366 --> 00:02:50.926
to help you build
better software.

00:02:52.376 --> 00:02:54.836
Today, we're going to talk
about a couple of things.

00:02:55.246 --> 00:02:57.176
We're going to talk about a new
Objective-C language feature

00:02:57.336 --> 00:02:58.426
called Modules.

00:02:58.426 --> 00:03:01.666
We're also going to talk
about better productivity

00:03:01.786 --> 00:03:03.276
in the use of Objective-C.

00:03:03.626 --> 00:03:05.106
And finally, some improvements

00:03:05.106 --> 00:03:10.176
to Automatic Reference
Counting or ARC.

00:03:10.446 --> 00:03:16.006
Modules. So, the idea behind
Modules is that if you look

00:03:16.006 --> 00:03:19.166
at applications built
for iOS and OS X,

00:03:19.246 --> 00:03:23.506
at the core of these
applications is the use of a ton

00:03:23.506 --> 00:03:25.436
of really great systems
frameworks.

00:03:26.246 --> 00:03:28.166
This is how you integrate
with services

00:03:28.236 --> 00:03:30.576
like iCloud or with Game Center.

00:03:30.966 --> 00:03:33.636
Maybe it's using
iAd to introduce ads

00:03:33.636 --> 00:03:36.716
into your application or
core location services

00:03:37.476 --> 00:03:39.866
so that you give your
user relevant content

00:03:39.916 --> 00:03:41.836
where they at right now.

00:03:42.876 --> 00:03:45.316
And so, this is sort of
the foundational layer

00:03:45.316 --> 00:03:48.736
on which you build all of the
magic of your applications.

00:03:49.326 --> 00:03:51.326
So we looked at the
process of how is it

00:03:51.326 --> 00:03:52.346
that you use a framework.

00:03:53.156 --> 00:03:54.986
Well, first, you go into Xcode.

00:03:54.986 --> 00:03:56.056
You go into your coding window.

00:03:56.746 --> 00:03:58.666
You write the #import for
the framework you want.

00:03:58.916 --> 00:04:01.176
In this case, we're going
to pull in iAd and use

00:04:01.176 --> 00:04:02.696
that as our demonstration.

00:04:03.096 --> 00:04:05.466
And the name is really
important, so you see iAd twice

00:04:05.466 --> 00:04:09.906
when you import iAd/iAd.h.
That's fine.

00:04:09.906 --> 00:04:12.066
You start writing your
code to the iAd framework,

00:04:12.066 --> 00:04:13.916
use some tutorial
samples and so on.

00:04:14.196 --> 00:04:16.906
You hit Build and you get
the dreaded link error.

00:04:17.555 --> 00:04:20.636
If this is the first time you've
seen this, this is horrifying

00:04:20.636 --> 00:04:22.666
and you have to search to
see what actually went wrong.

00:04:23.056 --> 00:04:25.016
But of course seasoned
developers know.

00:04:25.296 --> 00:04:26.896
Fine, there's several
ways to fix this.

00:04:26.896 --> 00:04:28.926
You can go edit the project,

00:04:28.926 --> 00:04:32.056
just go over to the build
phases, just close the triangle,

00:04:32.126 --> 00:04:34.746
hit the Plus, go find
the framework again.

00:04:34.746 --> 00:04:37.196
We said iAd three times
now if you're counting.

00:04:37.796 --> 00:04:40.496
Hit Add and we can actually
build our application,

00:04:41.346 --> 00:04:42.786
not exactly wonderful.

00:04:43.456 --> 00:04:46.606
And both of these steps
are very disjointed.

00:04:46.636 --> 00:04:49.456
We have the #import which is
what you write in your code

00:04:49.456 --> 00:04:51.366
and then we have the
addition of the library

00:04:51.366 --> 00:04:53.216
which is something you
do in Xcode, elsewhere.

00:04:53.896 --> 00:04:56.416
And so, let's go back to
the #import side of things

00:04:56.816 --> 00:05:00.356
because #import is a
teeny tiny innovation

00:05:00.666 --> 00:05:04.036
over the basic #include
that's been in C for three,

00:05:04.126 --> 00:05:06.136
four decades based
on the preprocessor.

00:05:06.766 --> 00:05:09.106
And so, we're going to look a
little bit at how the #import

00:05:09.106 --> 00:05:10.796
and #include actually work.

00:05:10.866 --> 00:05:14.176
So you have your application,
some .m file from it.

00:05:14.176 --> 00:05:18.306
And what it does is it
#imports iAd.h. Fine,

00:05:18.306 --> 00:05:19.056
what does that actually do?

00:05:19.056 --> 00:05:22.166
Well, it resolves iAd.h and
the compiler goes and hunts

00:05:22.166 --> 00:05:24.486
for the next thing
that iAd included

00:05:24.486 --> 00:05:26.076
and the next thing
that that included.

00:05:26.366 --> 00:05:29.066
Eventually, we get back to
UIKit and all of its headers

00:05:29.066 --> 00:05:30.506
and all the things
that that brings in.

00:05:30.506 --> 00:05:33.146
And so, really, the
dependency that you have

00:05:33.616 --> 00:05:36.386
from your data .m is
out to a whole bunch

00:05:36.386 --> 00:05:40.346
of different header
files within the SDK.

00:05:40.576 --> 00:05:44.236
How does this actually
work as the language model?

00:05:44.356 --> 00:05:47.146
Well, again, this is the C
model of the preprocessor.

00:05:47.146 --> 00:05:48.946
It's essentially
textual inclusion

00:05:49.246 --> 00:05:51.386
or a fancy form of
cut and paste.

00:05:51.956 --> 00:05:55.176
So, here we have, you know,
simple .m for an app delegate.

00:05:55.506 --> 00:05:57.776
It imports iAd.h.
What's that do?

00:05:58.376 --> 00:05:59.386
First thing compiler does,

00:05:59.386 --> 00:06:03.776
go find what is iAd/iAd.h
actually refers to and it comes

00:06:03.776 --> 00:06:04.846
up with a file on disk.

00:06:05.626 --> 00:06:08.836
Fine, it copies that
file, preprocess it,

00:06:09.206 --> 00:06:15.496
and pastes the results
into our .m at the end.

00:06:15.546 --> 00:06:17.536
Okay. And then what do we have?

00:06:17.536 --> 00:06:18.356
More imports.

00:06:18.726 --> 00:06:20.886
So we go hunt for the next file.

00:06:21.056 --> 00:06:25.256
Take its text, copy it,
preprocess it, paste it in,

00:06:25.256 --> 00:06:27.266
and the .m gets as
little longer.

00:06:27.346 --> 00:06:30.646
And we go hunt for more files
and we copy and paste those in.

00:06:30.646 --> 00:06:33.976
And once you get at the
end is one big long .m

00:06:33.976 --> 00:06:36.746
which is what the
compiler actually sees

00:06:36.976 --> 00:06:38.696
for each .m file in
your application.

00:06:40.036 --> 00:06:42.016
This model has been
working for decades,

00:06:42.096 --> 00:06:44.316
so what's wrong with it?

00:06:44.316 --> 00:06:46.006
Well, it has two problems.

00:06:46.006 --> 00:06:47.226
The first problem
we're going to talk

00:06:47.226 --> 00:06:49.656
about is it's a very
fragile model.

00:06:49.656 --> 00:06:51.776
So I'm going to do
something here

00:06:51.776 --> 00:06:53.246
that may make a few
of you cringe.

00:06:53.606 --> 00:06:57.226
I'm going to define a
constant read-only to 0x01

00:06:57.226 --> 00:07:00.416
because that makes sense for
my .m, for my application code.

00:07:00.466 --> 00:07:05.766
And I happen to do that
before #importing iAd.h. See,

00:07:05.766 --> 00:07:08.016
preprocessor does
what its design to do.

00:07:08.306 --> 00:07:10.856
It goes and hunts down
these files, copies them,

00:07:10.956 --> 00:07:13.126
preprocess them,
paste the result,

00:07:13.566 --> 00:07:15.566
and we end up with
this file up here

00:07:15.566 --> 00:07:17.846
which is the .m the
compiler sees.

00:07:18.886 --> 00:07:22.116
The compiler is not going to
like this .m and it's going

00:07:22.116 --> 00:07:25.456
to complain, 0x01 is not a
valid property attribute,

00:07:25.826 --> 00:07:26.896
it is very correct.

00:07:27.896 --> 00:07:31.056
The really unfortunate
thing here is that the error

00:07:31.056 --> 00:07:32.706
that you get is in
the system headers.

00:07:32.706 --> 00:07:34.826
That's not code you wrote and

00:07:34.826 --> 00:07:39.256
yet somehow you accidentally
broke it just by doing something

00:07:39.326 --> 00:07:41.546
where you defined the local
constant in your header file.

00:07:41.956 --> 00:07:43.946
And now, you can blame
me for doing this.

00:07:43.946 --> 00:07:45.656
I'm the one that write--
wrote this code in this slide.

00:07:45.786 --> 00:07:49.636
Clearly, it's my fault because
what I should have done is used

00:07:49.906 --> 00:07:54.186
a prefixed very long
uppercase name for my constant

00:07:54.216 --> 00:07:55.826
because that's what
we do with macros.

00:07:56.126 --> 00:07:57.976
It's the convention
that we've established

00:07:58.016 --> 00:08:00.836
within the C programming
world to cope

00:08:00.836 --> 00:08:02.886
with this fragility problem.

00:08:03.146 --> 00:08:05.286
And so, this doesn't
happen often

00:08:05.286 --> 00:08:06.436
that you hit these problems.

00:08:06.646 --> 00:08:09.036
But we do hit them
in programming.

00:08:09.036 --> 00:08:10.576
And usually, they
come in as some sort

00:08:10.576 --> 00:08:11.776
of header include-dependency.

00:08:12.216 --> 00:08:15.086
Someone's header over here
didn't follow the rules.

00:08:15.086 --> 00:08:16.056
He didn't get the memo.

00:08:16.396 --> 00:08:18.396
And it stomps on
another header over here.

00:08:18.396 --> 00:08:21.086
And if you include them in
one order, things work fine,

00:08:21.086 --> 00:08:23.756
or with one version of some
framework, it works fine.

00:08:24.206 --> 00:08:25.746
You migrate to another
version and, suddenly,

00:08:25.746 --> 00:08:27.646
there's a conflict
that you get to debug.

00:08:27.866 --> 00:08:30.566
If you're lucky, it manifests
an error that's fairly easy

00:08:30.566 --> 00:08:31.276
to track down.

00:08:31.996 --> 00:08:35.035
If you're not so lucky, it could
actually be a runtime that's

00:08:35.176 --> 00:08:37.356
really hard to track down
for something that ends

00:08:37.356 --> 00:08:39.096
up being just flipping
to include.

00:08:39.726 --> 00:08:43.676
So this is a problem that we
deal with but we've been working

00:08:43.746 --> 00:08:45.196
through it through
our conventions.

00:08:45.576 --> 00:08:46.156
It's fine.

00:08:47.076 --> 00:08:48.926
The real issue here, however,

00:08:48.926 --> 00:08:51.866
is that this whole model
is inherently not scalable.

00:08:52.436 --> 00:08:56.726
And so, to see this, we took
all of the .m files in iOS Mail

00:08:56.756 --> 00:08:59.176
and we plot them according
to their size on disk.

00:08:59.806 --> 00:09:02.386
So it's got, you know,
about 250 .ms here

00:09:02.756 --> 00:09:05.246
and you can see they range
from half a kilobyte up to

00:09:05.246 --> 00:09:09.156
about 200 kilobytes in
size with a very large skew

00:09:09.186 --> 00:09:10.676
with really tiny files.

00:09:10.676 --> 00:09:13.446
And we see this across the
numerous projects that you tend

00:09:13.446 --> 00:09:15.806
to have many, many
small .m files.

00:09:17.096 --> 00:09:20.546
Now, we've added iAd.h,
an import of iAd.h

00:09:20.696 --> 00:09:23.136
into a fairly central header.

00:09:23.586 --> 00:09:25.606
So what that really means
is for all these .m files,

00:09:25.606 --> 00:09:27.476
we're not just parsing
what's in the .m file,

00:09:27.476 --> 00:09:30.356
we're also parsing
everything that's in iAd.

00:09:30.466 --> 00:09:34.196
iAd is a fairly small
framework and the headers come

00:09:34.196 --> 00:09:35.896
in about 25 kilobytes.

00:09:35.946 --> 00:09:39.546
So, for many of these
files, just the size

00:09:39.786 --> 00:09:42.786
of iAd works the size
of the actual code

00:09:42.786 --> 00:09:44.966
that you wrote in your .m file.

00:09:45.916 --> 00:09:47.476
Of course, iAd isn't standalone

00:09:47.476 --> 00:09:49.626
and everyone needs
UIKit everywhere

00:09:49.626 --> 00:09:52.236
and UIKit is more
like 400 kilobytes.

00:09:53.336 --> 00:09:56.456
Okay. So now, our tiny
little files which is most

00:09:56.456 --> 00:10:01.906
of what's here are actually
going through 425 kilobytes

00:10:01.906 --> 00:10:03.596
of header files pulling
all those

00:10:03.596 --> 00:10:07.276
in from disk parsing
them just to get

00:10:07.276 --> 00:10:09.266
at your tiny little bit of code.

00:10:10.306 --> 00:10:11.406
And if you think this is bad,

00:10:11.406 --> 00:10:14.136
this is iOS where UIKit
is actually fairly small.

00:10:14.436 --> 00:10:19.096
So, on OS X, the Cocoa framework
that you pull in everywhere,

00:10:19.096 --> 00:10:23.096
it's about 29 times
larger than UIKit.

00:10:23.226 --> 00:10:26.556
So you can't even see the
.m files, your own code

00:10:26.556 --> 00:10:27.796
in this kind of chart.

00:10:28.276 --> 00:10:32.356
So what this presents is
inherent scalability problem.

00:10:32.356 --> 00:10:34.166
You can't scale with
a system like this

00:10:34.216 --> 00:10:36.306
because you have
your M source files

00:10:36.456 --> 00:10:38.316
and you have the N headers.

00:10:39.476 --> 00:10:41.986
That's the storage
on disk, M plus N.

00:10:42.046 --> 00:10:44.526
But the time to compile
is M times N

00:10:44.526 --> 00:10:46.956
because you're reparsing
every one of those headers

00:10:46.956 --> 00:10:48.456
for all of your .m files.

00:10:48.566 --> 00:10:51.476
And of course, both
M and N are growing

00:10:51.836 --> 00:10:54.656
as you build your applications
and add more code to them

00:10:54.976 --> 00:10:59.936
and as the system adds more
frameworks and APIs to them.

00:11:00.126 --> 00:11:03.426
So clearly, it can't be this
horrible or I'll be screaming

00:11:03.426 --> 00:11:05.016
at us to fix the
compile time issue.

00:11:05.466 --> 00:11:08.686
And so, one of that features
that we've had for a long time

00:11:08.686 --> 00:11:11.306
to try to solve this
is precompiled headers.

00:11:12.206 --> 00:11:14.626
And so, precompiled headers
actually do help a lot.

00:11:14.676 --> 00:11:15.866
The idea is fairly simple.

00:11:16.226 --> 00:11:18.396
You take some subset of
headers that's common

00:11:18.396 --> 00:11:21.866
across your entire project,
like maybe all of UIKit.

00:11:21.866 --> 00:11:25.256
And you compile it once
into some efficient

00:11:25.446 --> 00:11:26.896
on disk representation.

00:11:27.726 --> 00:11:29.746
And then whenever
you build a .m file,

00:11:29.996 --> 00:11:31.706
you load that representation
first,

00:11:31.706 --> 00:11:33.376
that binary representation
that's fast,

00:11:33.676 --> 00:11:36.216
no parsing, and start
from there.

00:11:36.866 --> 00:11:38.556
Now, this is great
because you don't have

00:11:38.556 --> 00:11:40.906
to parse UIKit or Cocoa.

00:11:40.906 --> 00:11:43.706
And in fact, when you started
with your project with Xcode,

00:11:43.706 --> 00:11:46.206
you got a precompiled
header for UIKit or Cocoa

00:11:46.206 --> 00:11:47.326
for free as you started.

00:11:48.206 --> 00:11:51.136
But anything else that you've
added later on, when you add

00:11:51.136 --> 00:11:54.816
that #import of iAd.h
is still being parsed

00:11:54.816 --> 00:11:56.146
over and over again.

00:11:57.176 --> 00:11:59.106
You could fix this if
you really wanted to.

00:11:59.426 --> 00:12:01.626
You could extend your
precompiled header

00:12:01.756 --> 00:12:04.416
to include iAd.h. And now,

00:12:04.416 --> 00:12:06.186
you're no longer
parsing this every time.

00:12:06.226 --> 00:12:08.406
What we've seen, however,

00:12:08.406 --> 00:12:11.216
is that developers don't
generally maintain their

00:12:11.266 --> 00:12:12.276
precompiled headers.

00:12:12.646 --> 00:12:14.686
A few people do and
they see more benefits

00:12:14.686 --> 00:12:15.866
out of precompiled headers.

00:12:16.236 --> 00:12:19.176
But most don't, partly because
they don't know about it,

00:12:19.176 --> 00:12:22.146
partly because they don't want
to be optimizing for our tools.

00:12:22.796 --> 00:12:26.666
But also, there's another
reason you might want to this

00:12:26.666 --> 00:12:29.196
and that's using
precompiled headers introduces

00:12:29.196 --> 00:12:30.116
namespace pollution.

00:12:30.646 --> 00:12:34.426
You may not want to have iAd in
every part of your application.

00:12:34.426 --> 00:12:36.726
It maybe fairly centralized
but putting it

00:12:36.726 --> 00:12:39.696
into your precompiled header
makes it available everywhere.

00:12:39.696 --> 00:12:40.796
So they're always showing

00:12:40.796 --> 00:12:42.866
up in code completion
results, for example.

00:12:43.156 --> 00:12:44.256
It's always available.

00:12:44.256 --> 00:12:46.486
And so, there's principle
reasons for not wanting

00:12:46.486 --> 00:12:47.856
to use precompiled
headers anywhere.

00:12:48.486 --> 00:12:52.416
So Modules are designed to
solve these two problems,

00:12:53.226 --> 00:12:55.636
the problem of the inherent
scalability problem of headers

00:12:55.636 --> 00:12:57.556
and also the fragility
problem of headers.

00:12:58.716 --> 00:13:00.156
So what are these Modules?

00:13:00.586 --> 00:13:02.986
So think of them
as an encapsulation

00:13:03.046 --> 00:13:04.896
of what a framework is.

00:13:05.206 --> 00:13:08.096
It's API and its
corresponding implementation.

00:13:09.096 --> 00:13:11.946
A Module is something that's
separately compiled all

00:13:11.946 --> 00:13:12.286
the time.

00:13:12.756 --> 00:13:17.646
So, it's compiled once and
set aside so that later

00:13:17.646 --> 00:13:19.816
on your application
can import that Module,

00:13:19.816 --> 00:13:22.816
get access to the API, get
access to the implementation

00:13:23.696 --> 00:13:25.726
without having the go
through and parse the headers.

00:13:26.936 --> 00:13:28.396
Now in support of Modules,

00:13:28.516 --> 00:13:30.656
we introduced one
little bit of syntax.

00:13:31.256 --> 00:13:32.936
It's the @import declaration.

00:13:33.906 --> 00:13:38.896
What @import does is it pulls in
the API for a particular Module

00:13:38.896 --> 00:13:40.046
which corresponds
to the framework.

00:13:40.276 --> 00:13:44.146
So here, we're importing
the iAd frameworks API

00:13:44.396 --> 00:13:45.396
into our application.

00:13:46.466 --> 00:13:48.896
Now this is what we
call a Semantic Import

00:13:48.896 --> 00:13:51.756
and it's very different from the
textual inclusion that you get

00:13:51.756 --> 00:13:54.216
with headers 'cause
semantic import, of course,

00:13:54.296 --> 00:13:55.726
it doesn't parse the headers

00:13:56.566 --> 00:13:59.916
but it also doesn't let
the API that's exposed

00:13:59.916 --> 00:14:03.616
by @import be changed by
any of your local context.

00:14:03.616 --> 00:14:06.556
So if I do this horrible
thing that I did earlier,

00:14:06.786 --> 00:14:10.826
# defining read-only to
0x01, it's perfectly fine.

00:14:10.936 --> 00:14:15.516
That doesn't change or break
the API of iAd in any way.

00:14:16.096 --> 00:14:20.346
The API you get out of the iAd
Module is exactly as the authors

00:14:20.406 --> 00:14:21.736
of iAd intended you to get.

00:14:21.826 --> 00:14:23.106
You can't make mistake here.

00:14:23.676 --> 00:14:29.186
Now, Modules can be thought
of as monolithic things,

00:14:29.186 --> 00:14:30.716
like we often think
of frameworks

00:14:30.716 --> 00:14:31.786
as a monolithic thing.

00:14:31.836 --> 00:14:35.966
I want to get all of the API of
iAd, but you don't have to think

00:14:35.966 --> 00:14:37.046
about frameworks this way.

00:14:37.046 --> 00:14:38.866
And therefore, you don't have
to think about Modules this way.

00:14:39.346 --> 00:14:43.196
And so, we can think of Modules
as being a larger structure,

00:14:43.196 --> 00:14:46.806
so here we have the iAd Module
and their smaller pieces

00:14:46.806 --> 00:14:48.026
which we call submodules.

00:14:48.176 --> 00:14:50.176
So here, we have the
ADInterstitialAd,

00:14:50.176 --> 00:14:57.256
the ADBannerView as submodules
within the iAd module itself.

00:14:57.556 --> 00:15:00.326
We can import just
part of a framework

00:15:00.636 --> 00:15:02.716
by writing @import of iAd.

00:15:02.716 --> 00:15:04.336
and then one of the
submodule names.

00:15:04.336 --> 00:15:05.746
In this case, it's ADBannerView.

00:15:05.746 --> 00:15:09.876
And what that does is it gives
us just the API corresponding

00:15:09.876 --> 00:15:11.736
to ADBannerView within iAd.

00:15:12.236 --> 00:15:14.326
So from an API perspective,

00:15:14.326 --> 00:15:17.916
this is giving you exactly the
same thing that you would get

00:15:17.916 --> 00:15:21.836
out of #import of
iAd/ADBannerView.h. And in fact,

00:15:21.836 --> 00:15:23.666
the frameworks and the sub--

00:15:23.666 --> 00:15:27.726
the framework headers and the
submodules match up exactly.

00:15:27.726 --> 00:15:30.036
It's something you can see if
you look at code completion

00:15:30.036 --> 00:15:32.416
for example after @import iAd.

00:15:33.286 --> 00:15:37.186
is the submodule structure here
to get at exactly what you want

00:15:37.186 --> 00:15:41.726
and this match up exactly what
the file names that are there.

00:15:41.726 --> 00:15:45.436
Now, once you've used @import,
you get the API of a framework.

00:15:46.246 --> 00:15:47.506
You also get the implementation

00:15:47.506 --> 00:15:49.266
for free via the
Autolinking feature.

00:15:50.156 --> 00:15:53.716
And so, once you've
switch over to Modules

00:15:53.896 --> 00:15:56.046
and you're importing
a particular Module,

00:15:56.046 --> 00:15:57.766
the compiler is just
going to record

00:15:57.766 --> 00:16:00.766
in the object files it
create what Modules you used

00:16:01.036 --> 00:16:03.516
so that we'll automatically
link against these things

00:16:03.736 --> 00:16:05.856
and you never have
to go in-- thank you.

00:16:06.516 --> 00:16:10.476
[ Applause ]

00:16:10.976 --> 00:16:13.236
Right. So you should not have
to go in and then link binary

00:16:13.236 --> 00:16:14.066
with libraries anymore.

00:16:14.576 --> 00:16:16.556
So what does it takes
to use Modules?

00:16:16.556 --> 00:16:19.276
We've shown the new
syntax, the @import syntax.

00:16:20.296 --> 00:16:22.416
So Modules are an
opting feature.

00:16:23.536 --> 00:16:25.786
So you can opt in via
build setting and I'll show

00:16:25.786 --> 00:16:27.366
in just a few moments.

00:16:28.476 --> 00:16:31.146
And of course, once you've
opted in, you have access

00:16:31.146 --> 00:16:32.526
to the @import syntax.

00:16:32.526 --> 00:16:37.206
Now, you probably have
a couple of #imports

00:16:37.206 --> 00:16:38.936
and maybe some #includes
in your code,

00:16:38.936 --> 00:16:41.316
maybe a handful,
hundreds, thousands.

00:16:42.166 --> 00:16:44.236
We don't actually want you to
have to go and rewrite those,

00:16:44.516 --> 00:16:46.376
not even automatically.

00:16:46.376 --> 00:16:47.466
Of course, we could
migrate them.

00:16:47.466 --> 00:16:50.106
What we really want is you
to be able to turn on Modules

00:16:50.106 --> 00:16:51.866
and go use the feature
immediately.

00:16:52.216 --> 00:16:52.976
And so, the way we deal

00:16:52.976 --> 00:16:55.506
with this is we actually
automatically remapped the

00:16:55.686 --> 00:16:57.986
#includes and the #includes
in your source code.

00:16:58.426 --> 00:17:00.566
When those refer to a
header that we know is part

00:17:00.566 --> 00:17:02.216
of a Module, we just treat it

00:17:02.216 --> 00:17:05.066
as if you had written
@import all along.

00:17:05.195 --> 00:17:07.136
And the great thing
here is you don't have

00:17:07.205 --> 00:17:09.556
to change your source
code to use Modules.

00:17:09.715 --> 00:17:12.066
You just need to opt in
via the build settings.

00:17:12.756 --> 00:17:16.076
The Modules, the @import
provides the exact same API

00:17:16.076 --> 00:17:19.596
that you got before just
through a different mechanism

00:17:19.596 --> 00:17:21.945
that is safer and
more efficient.

00:17:23.376 --> 00:17:26.685
Now, all of the system
frameworks in iOS 7

00:17:26.685 --> 00:17:30.496
and OS X Mavericks are
available as Modules.

00:17:31.226 --> 00:17:34.546
And so, when you opt in to
Modules, anything you're using

00:17:34.546 --> 00:17:37.176
from the system, any of those
system frameworks automatically

00:17:37.176 --> 00:17:41.196
goes through this more
efficient, safer path.

00:17:41.376 --> 00:17:43.196
You may be wondering, how
does this actually work

00:17:43.196 --> 00:17:43.746
under the hood?

00:17:43.746 --> 00:17:45.286
Well, let's take a quick look.

00:17:45.576 --> 00:17:51.926
So, the basic idea is we have
this notion of Module Maps.

00:17:52.086 --> 00:17:56.936
And a Module Map establishes a
relationship between the headers

00:17:57.026 --> 00:17:59.876
that are part of the framework
and have always been there,

00:18:00.326 --> 00:18:02.886
and the actual logical
Module structure.

00:18:03.166 --> 00:18:04.826
So here's a fragment
of a Module Map.

00:18:05.366 --> 00:18:08.586
It defines the UIKit Module
based on the UIKit framework.

00:18:09.586 --> 00:18:13.186
It says that to actually get
the contents of the UIKit model,

00:18:13.186 --> 00:18:15.276
you parse the umbrella
header UIKit.h

00:18:15.546 --> 00:18:18.036
which UIKit.h is what
you generally import.

00:18:18.036 --> 00:18:19.736
So this is the same
API description.

00:18:20.406 --> 00:18:25.446
And that anything that UIKit.h
itself imports becomes a

00:18:25.446 --> 00:18:26.966
submodule within UIKit.

00:18:26.966 --> 00:18:29.286
This is what reflects
the header structure

00:18:29.866 --> 00:18:31.726
within the logical
Module structure.

00:18:33.046 --> 00:18:34.966
And finally, you can
see Autolinking here

00:18:34.966 --> 00:18:37.736
through the link framework
line here that says

00:18:37.806 --> 00:18:40.526
when you actually use the
UIKit Module, you should link

00:18:40.526 --> 00:18:41.816
against the UIKit framework.

00:18:42.996 --> 00:18:45.056
Now, these Module Maps
are actually very crucial

00:18:45.446 --> 00:18:48.836
because in our SDKs, we
don't ship Module binaries.

00:18:49.246 --> 00:18:51.766
Instead, we ship headers
like we always have.

00:18:51.766 --> 00:18:55.286
And when the compiler asks
for a Module, when you ask

00:18:55.286 --> 00:19:00.016
to @import UIKit, the compiler
will find the Module Map,

00:19:00.016 --> 00:19:01.486
it tells it how to build UIKit

00:19:01.486 --> 00:19:04.506
and effectively spawn a
separate compilation process

00:19:04.506 --> 00:19:08.896
to go separately compile
UIkit.h into the UIKit Module

00:19:09.206 --> 00:19:11.736
which is then cached in
Xcode's derived data.

00:19:12.216 --> 00:19:15.486
So the next time you come
through and ask to import UIKit,

00:19:15.676 --> 00:19:17.956
it's already there and
it's instantaneous to load.

00:19:18.336 --> 00:19:22.366
So this is what breaks the M
times N scalability problem

00:19:22.366 --> 00:19:24.416
down to actually
efficient compilation model.

00:19:24.416 --> 00:19:27.626
So let's take a quick look at
what this does to build times?

00:19:28.126 --> 00:19:31.016
So build times, of course, build
time for an entire project.

00:19:31.016 --> 00:19:32.666
And so, we'll talk about
a couple of projects

00:19:32.666 --> 00:19:35.896
at different scales and with
different levels of utilization

00:19:35.896 --> 00:19:37.476
of the precompiled
headers feature.

00:19:37.896 --> 00:19:41.046
So Xcode is a very, very
large Objective-C project,

00:19:41.306 --> 00:19:42.736
a lot going on in the build.

00:19:43.356 --> 00:19:45.806
And in fact, they've been
tuning their precompiled headers

00:19:45.806 --> 00:19:46.366
for years.

00:19:46.656 --> 00:19:48.436
And so, what we see when
we turn on Modules is

00:19:48.436 --> 00:19:50.706
that they don't have to change
their source code at all.

00:19:50.706 --> 00:19:51.706
It's just a build setting.

00:19:52.206 --> 00:19:53.706
And they get a smallish win,

00:19:53.706 --> 00:19:55.716
a couple of percent
win in the build time.

00:19:56.286 --> 00:19:58.336
Since they had optimized
precompiled headers,

00:19:58.336 --> 00:19:59.446
this isn't a huge surprise.

00:20:00.906 --> 00:20:05.816
Preview on the Mac is
actually a much smaller project

00:20:05.816 --> 00:20:06.606
as you might expect.

00:20:06.906 --> 00:20:11.046
Also, has fairly decent
precompiled header.

00:20:11.046 --> 00:20:14.006
And so, you get a small
win [inaudible] larger win

00:20:14.306 --> 00:20:15.366
out of using Modules.

00:20:15.366 --> 00:20:18.696
Again, no source code-- yeah--
source code changes required,

00:20:19.296 --> 00:20:21.176
so it's essentially a
free performance here.

00:20:21.876 --> 00:20:25.846
And finally, the Mail
Application on iOS didn't have

00:20:25.846 --> 00:20:26.606
such great use

00:20:26.606 --> 00:20:29.456
of the precompiled headers
'cause they hadn't been actively

00:20:29.456 --> 00:20:30.256
maintained, like most

00:20:30.256 --> 00:20:32.336
of all operators don't actively
maintained their precompiled

00:20:32.336 --> 00:20:35.786
headers and it's a huge
40 percent speed up just

00:20:35.786 --> 00:20:37.866
from flipping the
switch, turning on Modules

00:20:37.866 --> 00:20:40.036
and not doing anything
else, all right.

00:20:40.456 --> 00:20:41.656
This is the elimination

00:20:41.656 --> 00:20:44.256
of repeated header
processing really helping.

00:20:45.596 --> 00:20:48.456
So now, build times or
overall project build times,

00:20:48.716 --> 00:20:50.766
they're a little
bit messy in a sense

00:20:50.766 --> 00:20:52.336
that we're not really
just measuring what the

00:20:52.336 --> 00:20:52.926
compiler does.

00:20:52.926 --> 00:20:54.556
There's a whole lot of
other things going on.

00:20:55.216 --> 00:20:58.616
So, let's go to something
a little bit more heavy

00:20:58.616 --> 00:21:01.386
on the parsing and
that is indexing.

00:21:01.386 --> 00:21:03.786
When an Xcode is
indexing your project,

00:21:03.786 --> 00:21:06.766
it's parsing all the sources
in your project so it can build

00:21:06.766 --> 00:21:09.906
that rich cross reference
to give you more information

00:21:09.906 --> 00:21:11.126
at your fingertips
within the IDE.

00:21:11.126 --> 00:21:15.636
And so if we take these
same projects, indexing time

00:21:15.636 --> 00:21:17.496
for Xcode got a bit faster,

00:21:17.496 --> 00:21:20.496
we're in the seven
percent range or so.

00:21:21.476 --> 00:21:24.716
Preview on the other hand got
pretty significantly faster,

00:21:24.716 --> 00:21:27.526
so 32 percent faster
indexing time just

00:21:27.526 --> 00:21:28.846
from switching to Modules.

00:21:29.986 --> 00:21:32.556
And iOS Mail, as you may have
seen earlier this morning,

00:21:32.866 --> 00:21:36.486
got 2.3 times faster
indexing just

00:21:36.486 --> 00:21:37.796
from doing the switch
to Modules.

00:21:40.016 --> 00:21:42.036
Hopefully, at this
point, I've convinced you,

00:21:42.036 --> 00:21:45.176
you should at least try out
Modules, fairly easy to do.

00:21:45.176 --> 00:21:47.696
So if you start a new
project in Xcode 5,

00:21:47.696 --> 00:21:49.316
Modules are enabled by default.

00:21:49.316 --> 00:21:52.106
We really thinking this is the
way forward for Objective-C

00:21:52.266 --> 00:21:54.536
to get access to
system frameworks.

00:21:54.786 --> 00:21:58.096
If you have an existing
project, to covert it Modules,

00:21:58.096 --> 00:22:01.186
just go into your Build Settings
and find the Module Setting,

00:22:01.456 --> 00:22:02.996
change it to Yes
and then Rebuild.

00:22:02.996 --> 00:22:04.586
Nothing else is needed.

00:22:05.756 --> 00:22:08.426
Now, if you're doing some
fancy linking tricks,

00:22:09.106 --> 00:22:11.406
you may actually want to turn
off the Autolinking feature

00:22:11.956 --> 00:22:13.816
in which case there is
a separate option here

00:22:13.816 --> 00:22:16.046
where you can turn off
the Autolinking feature.

00:22:16.286 --> 00:22:20.076
Most users shouldn't
actually need to do this.

00:22:20.286 --> 00:22:22.576
As you may expect, there's
a couple of caveats.

00:22:22.576 --> 00:22:26.706
So, first caveat, you
need to be using the iOS 7

00:22:26.826 --> 00:22:28.416
or OS X Mavericks SDK.

00:22:28.416 --> 00:22:30.806
Only those SDKs have
support for Modules.

00:22:31.146 --> 00:22:32.986
Now, of course, you
can deploy backward

00:22:33.396 --> 00:22:35.886
because you can use the new
SDK and deploy backward.

00:22:36.146 --> 00:22:39.316
Modules don't change how
your code is actually built.

00:22:39.316 --> 00:22:40.836
They don't change
for your source code.

00:22:40.836 --> 00:22:42.336
They don't change how
your code is built.

00:22:42.336 --> 00:22:45.736
You just need to move to
the newer SDK to get those--

00:22:45.796 --> 00:22:46.936
essentially the Module Maps

00:22:47.316 --> 00:22:50.356
that tell the Module
system how to work.

00:22:50.536 --> 00:22:54.416
Second point is that
Modules aren't available C++.

00:22:54.736 --> 00:22:58.656
Now, it's perfectly fine to
enable Modules in a C++ project.

00:22:58.946 --> 00:23:01.836
Essentially, the fact that you
requested Modules will just be

00:23:01.836 --> 00:23:05.176
ignored for the C++ sources,
you'll still get the benefits

00:23:05.176 --> 00:23:07.146
of Modules for your
Objective-C sources.

00:23:07.756 --> 00:23:10.386
The only downside here is you
can't use the fancy new @import

00:23:10.386 --> 00:23:12.096
syntax in something
that's shared

00:23:12.546 --> 00:23:16.066
between C++ and non-C++ code.

00:23:16.276 --> 00:23:19.206
And finally, while Modules
are available for all

00:23:19.206 --> 00:23:22.986
of the system frameworks,
on iOS and the Mac,

00:23:22.986 --> 00:23:24.686
they're not available
for user frameworks.

00:23:26.116 --> 00:23:28.676
So, let's wrap up here.

00:23:29.596 --> 00:23:32.176
We talked about this
new feature, Modules.

00:23:32.696 --> 00:23:35.826
The idea behind Modules is to
simplify the user frameworks

00:23:35.826 --> 00:23:39.896
so you can just get the nice
semantic import behavior

00:23:40.326 --> 00:23:41.516
which is much harder to break

00:23:41.586 --> 00:23:44.766
than the textual inclusion
behavior that would, so--

00:23:44.766 --> 00:23:47.816
and this means we've essentially
eliminated all of the problems

00:23:47.816 --> 00:23:50.246
with strange header
order dependencies

00:23:50.246 --> 00:23:52.556
between system frameworks
and user code,

00:23:54.166 --> 00:23:57.946
and we've eliminated the
separate link with library step

00:23:57.946 --> 00:24:00.426
through the Autolinking
feature of Modules.

00:24:01.696 --> 00:24:04.096
Now, Modules are
actually a lot more

00:24:04.096 --> 00:24:05.646
than just a user convenience.

00:24:06.226 --> 00:24:09.196
We're actually fundamentally
changing the underlying model

00:24:09.196 --> 00:24:11.916
and how we can access
to APIs in a way

00:24:11.916 --> 00:24:15.076
that can significantly improve
the performance of source tools.

00:24:15.416 --> 00:24:17.056
And the very nice thing here is

00:24:17.056 --> 00:24:19.176
that improvement
essentially comes for free.

00:24:19.496 --> 00:24:21.546
You no longer have to tweak
your precompiled header

00:24:21.546 --> 00:24:22.526
to get the build times.

00:24:22.826 --> 00:24:25.476
Just use Modules and forget
about the precompiled header,

00:24:25.716 --> 00:24:27.396
Modules will do the right thing.

00:24:28.616 --> 00:24:31.886
And finally, you can enable
this feature without any changes

00:24:31.886 --> 00:24:33.156
to your source code, whatsoever.

00:24:33.226 --> 00:24:36.186
It's changing your Build Setting
and rebuilding your application.

00:24:36.456 --> 00:24:37.436
The application doesn't change.

00:24:37.436 --> 00:24:38.496
Your source code doesn't change.

00:24:39.936 --> 00:24:42.346
So with that, I'd like to
turn you over to my colleague,

00:24:42.346 --> 00:24:44.886
Dave Zarzycki to talk about
advances in Objective-C.

00:24:44.886 --> 00:24:45.446
[applause]

00:24:45.446 --> 00:24:47.516
>> All right.

00:24:48.066 --> 00:24:48.556
Thanks, Doug.

00:24:51.396 --> 00:24:53.796
So I'm going to be talking
to you about more advances

00:24:53.796 --> 00:24:56.536
in Objective-C, some
recent, some new.

00:24:57.336 --> 00:24:59.146
So, I'm going to be
starting off talking

00:24:59.146 --> 00:25:00.216
about better productivity.

00:25:00.216 --> 00:25:01.986
We're going to be
talking about tool support

00:25:01.986 --> 00:25:03.236
for modernizing your code.

00:25:03.236 --> 00:25:05.576
We'll be talking about
improvements in the SDK

00:25:05.576 --> 00:25:08.146
and how they make your life
better and more productive

00:25:08.146 --> 00:25:09.066
and generate better code.

00:25:09.066 --> 00:25:12.466
And we'll be talking
about block return safety

00:25:12.556 --> 00:25:13.926
and catching some common errors.

00:25:14.436 --> 00:25:16.196
And then we'll be talking
about the runtime in your code.

00:25:16.196 --> 00:25:19.886
And then, for the rest of
the talk, we'll be talking

00:25:19.886 --> 00:25:21.216
about Automatic Reference
Counting.

00:25:21.296 --> 00:25:24.486
We'll be talking about
updates we've made to it

00:25:24.486 --> 00:25:26.576
and we've been talking--
we'll talk about improvements

00:25:26.616 --> 00:25:28.206
in generating better warnings

00:25:28.206 --> 00:25:29.716
that help you generate
more correct code.

00:25:30.476 --> 00:25:32.386
So with that, let's
jump in and talk

00:25:32.386 --> 00:25:34.136
about Tools Support
for Modernization.

00:25:35.066 --> 00:25:38.336
Something we did recently
was adding a Refactoring Tool

00:25:38.386 --> 00:25:39.716
to modernize your code.

00:25:40.676 --> 00:25:42.516
It's found right
here in the Edit Menu

00:25:42.656 --> 00:25:45.956
under the Refactoring
Submenu and you just convert

00:25:45.956 --> 00:25:48.506
to the Modern Objective-C
Syntax.

00:25:49.546 --> 00:25:50.736
So what does this do?

00:25:50.976 --> 00:25:54.336
Well, it reduces a ton of
boilerplate in your code.

00:25:54.336 --> 00:25:57.756
We have object-- more object
literals, container literals.

00:25:58.246 --> 00:25:59.936
We have improved subscripting.

00:26:00.536 --> 00:26:01.596
And this is covered in-depth

00:26:01.596 --> 00:26:03.036
at last year's version
of this talk.

00:26:04.416 --> 00:26:05.806
So let's look at
the example of this.

00:26:05.946 --> 00:26:08.236
Here is an example of one of
my favorite jazz musicians.

00:26:09.436 --> 00:26:12.046
Now, we do have literals.

00:26:12.046 --> 00:26:12.736
We have string literals.

00:26:12.796 --> 00:26:13.846
We have a lot of other things.

00:26:13.846 --> 00:26:15.406
We need to remember how
to create a dictionary.

00:26:15.406 --> 00:26:17.506
What factory method to call?

00:26:17.866 --> 00:26:21.146
We need to remember the order
of the keys and the objects.

00:26:21.586 --> 00:26:23.856
We need to remember that
they have to be objects.

00:26:23.986 --> 00:26:26.246
And we have to remember to
nil-terminate this list.

00:26:26.916 --> 00:26:28.846
And similarly for NSArray,

00:26:28.846 --> 00:26:30.716
we have to remember the
right factory method to call.

00:26:30.796 --> 00:26:33.256
And like NSDictionary, we need

00:26:33.256 --> 00:26:34.496
to remember the nil-terminate
it.

00:26:35.866 --> 00:26:38.166
Similarly, NSNumber
has the same problem.

00:26:39.366 --> 00:26:41.646
We need to remember the
right factory method to call.

00:26:41.646 --> 00:26:42.276
Is that an end?

00:26:42.276 --> 00:26:43.456
Is it a long?

00:26:43.456 --> 00:26:45.106
Is it a short?

00:26:45.106 --> 00:26:47.466
We need to remember
the right one for Bool.

00:26:48.056 --> 00:26:50.726
There's a lot of opportunity
here to reduce boilerplate.

00:26:51.666 --> 00:26:55.256
Well, with the Refactoring Tool,
you can adopt the modern syntax.

00:26:55.736 --> 00:26:58.126
Dictionary literals just
become @, curly brace.

00:26:58.596 --> 00:27:01.916
Array literals become
@ square bracket.

00:27:03.026 --> 00:27:06.136
The compiler helps you remember
keys and values and the fact

00:27:06.136 --> 00:27:07.266
that they have to be objects.

00:27:07.836 --> 00:27:10.036
You don't need to worry about
nil terminating the list.

00:27:10.106 --> 00:27:13.436
And similarly, for NSNumber,
you don't need to worry

00:27:13.436 --> 00:27:14.546
about what type it is anymore.

00:27:14.546 --> 00:27:17.826
You can just say @
number or @ yes or @ no.

00:27:17.826 --> 00:27:21.046
So this is a huge simplification
and we have tools to help you

00:27:21.046 --> 00:27:23.556
about the syntax so you can
focus on writing great code

00:27:23.556 --> 00:27:26.046
and sweeping away the details.

00:27:27.876 --> 00:27:30.386
Similarly, we can consider
containers before the

00:27:30.386 --> 00:27:31.416
modern syntax.

00:27:32.276 --> 00:27:34.966
Throughout your code, you work
with containers and you have

00:27:35.026 --> 00:27:37.196
to write this code repeatedly.

00:27:37.196 --> 00:27:40.236
You have to remember
if in the case--

00:27:40.266 --> 00:27:43.506
whether the key comes first
or the object comes first,

00:27:44.056 --> 00:27:46.976
it's just a lot of boilerplate
that could be simplified.

00:27:47.976 --> 00:27:49.876
Well, with modern
syntax, you can do that.

00:27:50.506 --> 00:27:53.966
You can use common subscripting
syntax that's available

00:27:53.966 --> 00:27:56.676
in a variety of languages
to access containers

00:27:56.676 --> 00:27:59.296
in the modern SDK and
the modern syntax.

00:27:59.816 --> 00:28:03.766
Now, there's a ton more to
modern syntax that I'm not going

00:28:03.766 --> 00:28:05.176
to cover here and
I strongly suggest

00:28:05.176 --> 00:28:06.346
that you watch last year's talk.

00:28:07.266 --> 00:28:09.726
We have boxed expressions
via @ parenthesis.

00:28:10.786 --> 00:28:14.456
We have the full intersection
with C types if you want

00:28:14.456 --> 00:28:17.476
to understand how they work,
like shorts and chars and longs

00:28:17.476 --> 00:28:18.466
and unsigned behavior.

00:28:19.736 --> 00:28:24.016
We have-- we teach you how
to implement subscripting

00:28:24.016 --> 00:28:27.786
for your own classes and you can
see this on last year's version

00:28:27.936 --> 00:28:31.056
of this talk, number
four or five.

00:28:31.926 --> 00:28:35.276
So with that, I'd like to
jump into SDK improvements

00:28:35.446 --> 00:28:37.616
and how they will
improve your productivity.

00:28:38.686 --> 00:28:42.116
So the SDK is constantly
leveraging the compiler.

00:28:42.116 --> 00:28:43.486
It's adopting new features.

00:28:43.876 --> 00:28:47.026
It's helping you write more
correct code, safer code,

00:28:47.546 --> 00:28:50.836
and get better compiled time
error detection and problems

00:28:50.836 --> 00:28:51.846
that you might be running into.

00:28:52.846 --> 00:28:55.186
And specifically, I'd like
to call out two features

00:28:55.186 --> 00:28:57.756
that the new SDKs have adopted

00:28:57.806 --> 00:29:00.676
that will affect
potentially your experience

00:29:00.676 --> 00:29:03.806
and help you write better code.

00:29:04.026 --> 00:29:06.186
And specifically, where there--

00:29:06.836 --> 00:29:09.956
instancetype keyword and
explicitly-typed enums.

00:29:11.086 --> 00:29:12.866
So let's jump in and
consider with that is.

00:29:14.236 --> 00:29:16.786
Now, some of you probably
can look at this code

00:29:16.896 --> 00:29:18.006
and already see the bug.

00:29:18.806 --> 00:29:20.916
We're taking an NSArray
and we're assigning it

00:29:20.916 --> 00:29:22.976
to an NSDictionary variable.

00:29:22.976 --> 00:29:24.386
That's terrible.

00:29:24.866 --> 00:29:27.766
But, copy and paste
errors are easy.

00:29:28.676 --> 00:29:30.586
Refactoring are easy.

00:29:31.236 --> 00:29:35.346
And in fact, now with the
SDKs worshipping this,

00:29:35.486 --> 00:29:39.376
you will actually get a warning
pointing out the problem.

00:29:40.636 --> 00:29:42.926
So how is it that the compiler
knows if we have a problem?

00:29:43.746 --> 00:29:45.256
When previous versions
of the SDK,

00:29:45.256 --> 00:29:48.876
array and many similar
APIs returned IDE.

00:29:49.676 --> 00:29:52.516
The problem is that IDE
implicitly converts to anything,

00:29:52.556 --> 00:29:54.746
so the compiler didn't
historically know

00:29:54.746 --> 00:29:56.346
that there was a problem here.

00:29:57.826 --> 00:30:01.146
In the new SDK, array
returns instancetype.

00:30:02.176 --> 00:30:03.946
This is a contextual keyword.

00:30:04.896 --> 00:30:06.796
It's only for return types.

00:30:07.286 --> 00:30:12.066
And subclasses don't need
to redeclare array here

00:30:12.066 --> 00:30:14.786
to expose the fact that
they're returning an instance

00:30:14.866 --> 00:30:16.656
of their subclass.

00:30:17.156 --> 00:30:20.446
And finally, the compiler
contextually matches the return

00:30:20.446 --> 00:30:21.756
type to that other receiver.

00:30:23.056 --> 00:30:24.306
Okay, well what does that mean?

00:30:25.016 --> 00:30:27.506
Let's consider our
subclassing NSArray.

00:30:27.646 --> 00:30:29.516
And let's say we create
a class name Foobar.

00:30:30.116 --> 00:30:31.596
We don't do anything more.

00:30:31.596 --> 00:30:33.036
We just put in @end.

00:30:33.226 --> 00:30:37.526
And what happens in this code
now that we're taking a Foobar

00:30:37.526 --> 00:30:40.726
and calling array and this
signage NSDictionary variable?

00:30:40.726 --> 00:30:44.606
Well, the compiler would still
print out the warning, great.

00:30:45.866 --> 00:30:47.476
But I'd like to point out is

00:30:47.476 --> 00:30:49.836
that the compiler is
contextually taking the receive

00:30:49.836 --> 00:30:53.706
type Foobar and printing
out the warning pointing

00:30:53.706 --> 00:30:55.696
out that the return
value is also a Foobar,

00:30:55.696 --> 00:30:57.156
and that's the source
of the problem.

00:30:58.246 --> 00:30:59.926
So that's the instancetype
keyword.

00:31:00.776 --> 00:31:04.206
Next up, I'd like to talk
about explicitly-typed enum.

00:31:04.206 --> 00:31:07.886
Another feature that the SDK
has adopted that will show

00:31:07.886 --> 00:31:09.946
up in your code and help
you detect more errors

00:31:10.036 --> 00:31:10.946
and be more productive.

00:31:12.386 --> 00:31:14.356
So let's look at this code.

00:31:15.016 --> 00:31:16.446
Some of you that have experience

00:31:16.446 --> 00:31:19.106
with URLs may already
see the bug.

00:31:19.966 --> 00:31:22.266
These are not the same enum.

00:31:23.166 --> 00:31:26.016
We have an NSURLHandleStatus
on the left.

00:31:26.456 --> 00:31:29.086
We have an NSURLSessionTaskState
on the right.

00:31:29.986 --> 00:31:34.326
Whoops. Well, again, copy
and paste errors are easy

00:31:35.126 --> 00:31:36.736
and refactoring errors
are really easy.

00:31:37.646 --> 00:31:40.266
And the reason this is used
to compile in the past is

00:31:40.266 --> 00:31:43.276
that enums are essentially
just global integers.

00:31:43.276 --> 00:31:45.296
So, we're just assigning
one number to another.

00:31:46.476 --> 00:31:51.416
Well now, with the SDKs, you
will get a warning pointing

00:31:51.416 --> 00:31:53.366
out that these are
of different types

00:31:53.456 --> 00:31:54.666
which is exactly what you want.

00:31:54.666 --> 00:31:58.396
So how does the compiler know?

00:31:59.446 --> 00:32:01.756
In the past, we declared
enums like this.

00:32:02.576 --> 00:32:05.536
In one line, we would declare
the enum and enumerate,

00:32:05.966 --> 00:32:08.016
you know, ABC, JKL, XYZ.

00:32:08.016 --> 00:32:12.396
And the next line, we
declare a typedef where we say

00:32:12.396 --> 00:32:17.066
that what the storage is
and then give it a name.

00:32:17.066 --> 00:32:21.126
Well, this is where the
first line is just mint.

00:32:21.286 --> 00:32:24.466
We haven't actually bound the
two pieces of information here.

00:32:26.736 --> 00:32:28.706
And how we fixed this in the SDK

00:32:28.706 --> 00:32:31.046
and with the compiler is the
compiler supports a new feature

00:32:31.046 --> 00:32:32.766
for explicitly-typed enums.

00:32:33.286 --> 00:32:34.016
What you can see here

00:32:34.016 --> 00:32:37.266
on the first line is we've
actually moved the storage up

00:32:37.266 --> 00:32:39.476
and now the enum knows
what its storage type is

00:32:39.476 --> 00:32:42.306
and then now it's no longer
an int, it's an NSUInteger.

00:32:42.306 --> 00:32:46.806
Now in the next line,
we actually bind or enum

00:32:46.806 --> 00:32:49.126
to a type available for use.

00:32:49.796 --> 00:32:53.126
This is all covered last year
in-depth and this version--

00:32:53.256 --> 00:32:54.546
in this talk last year.

00:32:56.036 --> 00:32:59.346
Now, the Cocoa team have
provided convenient macros

00:32:59.456 --> 00:33:00.716
that exposed this feature.

00:33:00.996 --> 00:33:04.056
We have NS Enum for a
traditional enumerations,

00:33:04.056 --> 00:33:05.326
like we just demonstrated.

00:33:06.036 --> 00:33:07.696
You know, ABC, JKL, XYZ.

00:33:07.696 --> 00:33:11.826
And they also have a
convenient macro for NS Options.

00:33:12.686 --> 00:33:16.756
So, a bit wise operations,
like, you know, different flags.

00:33:17.336 --> 00:33:21.416
So I recommend the use of these
macros and you'll see them

00:33:21.416 --> 00:33:22.536
in the system frameworks.

00:33:24.146 --> 00:33:26.646
But we don't stop
with just warnings.

00:33:27.166 --> 00:33:30.816
We also improved code
completion with NS Enum

00:33:30.816 --> 00:33:32.146
and explicitly-typed enums.

00:33:33.236 --> 00:33:37.186
So before NS Enum, if you tried

00:33:37.186 --> 00:33:40.806
to code complete our
example enumeration here

00:33:40.806 --> 00:33:45.086
and you typed X, you would see
a bunch of XPC-related APIs

00:33:45.086 --> 00:33:46.976
and you wouldn't see your enum.

00:33:47.456 --> 00:33:48.396
That's not fun.

00:33:49.356 --> 00:33:52.756
Well, if we just switch to
the NS Enum macro and then get

00:33:52.756 --> 00:33:53.886
up the compiler feature,

00:33:53.886 --> 00:33:55.966
Code Completion gives
us exactly what we want

00:33:56.656 --> 00:33:58.736
and we see our enumeration
available

00:33:58.736 --> 00:33:59.936
in Code Completion
which is great.

00:34:00.426 --> 00:34:04.326
But it just doesn't--
it doesn't stop there.

00:34:04.476 --> 00:34:08.376
The power of explicitly-typed
enums manifest in multiple ways.

00:34:09.536 --> 00:34:12.476
So in this particular
case, we have an NSArray

00:34:12.476 --> 00:34:17.025
that we're trying to
sort using a comparator.

00:34:17.116 --> 00:34:19.025
And we do some logic
and then we decide

00:34:19.025 --> 00:34:20.666
to return ascending
or descending.

00:34:21.646 --> 00:34:22.456
Now if you look closely,

00:34:22.456 --> 00:34:24.956
we actually haven't specified
the return type of this block

00:34:24.956 --> 00:34:26.946
between the caret and
the opening parenthesis.

00:34:27.525 --> 00:34:32.156
And the compiler would actually
give us an error saying that,

00:34:32.226 --> 00:34:35.735
"Well, we infer the type of
this block as returning int

00:34:35.735 --> 00:34:42.005
but the API actually takes
NS-- comparison result."

00:34:42.005 --> 00:34:44.025
All right.

00:34:44.676 --> 00:34:46.146
Well, how do we fix this?

00:34:46.706 --> 00:34:50.116
Before explicitly-typed
enums, we have the Cast, thus,

00:34:50.556 --> 00:34:51.866
assigning the correct type.

00:34:53.146 --> 00:34:54.896
And yes, this would
make the warning go away

00:34:54.896 --> 00:34:57.366
but now we have this lingering
cast in our code that, you know,

00:34:57.406 --> 00:34:58.956
could create future problems.

00:34:59.266 --> 00:35:01.686
Because the explicitly-typed
enums allow us to fix this

00:35:01.686 --> 00:35:04.146
and make the enum how
many explicit-type,

00:35:05.216 --> 00:35:08.186
we can help you avoid casting
and in fact you can now go

00:35:08.266 --> 00:35:09.646
and delete these
casts and go back

00:35:09.646 --> 00:35:11.966
to the natural looking
code you wanted to have

00:35:11.996 --> 00:35:14.506
in the first place and
write it as intended.

00:35:16.776 --> 00:35:19.526
Digging deeper on what
NS Enum can do for you,

00:35:20.046 --> 00:35:21.666
let's consider the fact

00:35:21.666 --> 00:35:24.806
of how implicitly-typed enums
can manifest in different ways.

00:35:25.396 --> 00:35:27.396
Again, before explicitly-typed
enums,

00:35:27.456 --> 00:35:30.506
these two URL-related enums

00:35:30.506 --> 00:35:33.486
that are actually different
were just ints as far

00:35:33.486 --> 00:35:35.226
as the compiler was concerned.

00:35:36.746 --> 00:35:39.636
And this manifested as a
silent bug in your code.

00:35:40.296 --> 00:35:42.966
Now with NS Enum, you get
the warning that you want

00:35:43.106 --> 00:35:46.266
and now you have to
decide how to fix the code.

00:35:46.266 --> 00:35:48.256
Now, here, this is pointing
out a design problem

00:35:48.256 --> 00:35:49.716
so that there is
no quick solution.

00:35:49.716 --> 00:35:51.646
You'd have to think about
it and actually figure

00:35:51.646 --> 00:35:52.796
out what you originally
intended.

00:35:53.306 --> 00:35:56.536
So with that, now
I'd like to move

00:35:56.536 --> 00:35:59.216
on to the Objective-C
Runtime and you.

00:35:59.216 --> 00:36:02.806
The Objective-C Runtime is
the core of the language.

00:36:03.406 --> 00:36:05.816
It enables a ton of
dynamic behavior.

00:36:05.816 --> 00:36:10.286
We have, you know, of course,
dynamic method dispatch.

00:36:10.736 --> 00:36:12.296
We have object introspection.

00:36:12.826 --> 00:36:14.846
We have object proxies.

00:36:15.066 --> 00:36:16.686
And we have dynamic
class construction,

00:36:16.686 --> 00:36:18.306
even a dynamic method
replacement.

00:36:20.056 --> 00:36:23.596
The runtime enables a ton of
innovation in the language.

00:36:24.336 --> 00:36:26.666
We've added many
features over the years

00:36:26.666 --> 00:36:28.546
and it's really the heart
of all these features.

00:36:29.646 --> 00:36:32.646
So to give you an example, we've
added a new key-value observing,

00:36:32.646 --> 00:36:38.326
associated objects, we've added
@synchronized to do locking,

00:36:38.936 --> 00:36:41.786
we've added weak references,
we've added tagged pointers,

00:36:41.786 --> 00:36:44.236
and the list go on, on and on.

00:36:44.286 --> 00:36:46.466
I'd like to actually call
out tagged pointers though

00:36:46.466 --> 00:36:50.006
because we have some new
warnings to enable innovation.

00:36:51.006 --> 00:36:54.036
So, let's first dive deep
and ask the question,

00:36:54.036 --> 00:36:55.136
what are tagged pointers?

00:36:56.006 --> 00:37:00.936
They were added in 64-bit Cocoa
for a small value-like objects.

00:37:01.006 --> 00:37:03.336
And examples of a
value-like objects are

00:37:03.336 --> 00:37:06.576
like NSNumber, NSDate,
just values.

00:37:07.436 --> 00:37:11.416
What we're doing is we're
actually storing the object

00:37:11.416 --> 00:37:13.696
in the pointer itself,
so we don't actually need

00:37:13.696 --> 00:37:15.066
to call malloc or free.

00:37:15.066 --> 00:37:18.456
And when you don't call
malloc or free, you could've--

00:37:19.056 --> 00:37:21.976
code gets a ton faster and
it's more space efficient.

00:37:22.066 --> 00:37:23.936
It's three times more
space efficient and it's

00:37:23.936 --> 00:37:25.506
over 100 times faster
to allocate

00:37:25.506 --> 00:37:27.446
and deallocate these
small value-like objects.

00:37:28.856 --> 00:37:31.636
Okay, it's great in theory
but I'm a visual person.

00:37:31.636 --> 00:37:32.896
Show me how this actually works.

00:37:34.116 --> 00:37:35.066
In a normal pointer,

00:37:35.436 --> 00:37:37.856
we're actually only
using the top 60 bits.

00:37:38.186 --> 00:37:40.616
The bottom four bits of
a pointer are always zero

00:37:40.616 --> 00:37:42.476
because objects are
always 16-byte aligned.

00:37:43.056 --> 00:37:45.376
We can take advantage
of this fact

00:37:45.376 --> 00:37:49.206
to implement what we call tagged
pointers where we actually store

00:37:49.206 --> 00:37:52.146
in the bottom bit discriminators
and when it's one,

00:37:52.466 --> 00:37:54.886
we can actually store a ton of
data in the rest of the bits.

00:37:55.306 --> 00:37:58.076
And this is in fact what we do.

00:37:58.286 --> 00:38:01.686
Having said all this, this
is an implementation detail.

00:38:02.116 --> 00:38:03.876
Some of you have
discovered this feature

00:38:03.876 --> 00:38:05.116
and we need you to
undiscover it.

00:38:05.966 --> 00:38:10.616
[laughter] The runtime
details are private.

00:38:10.616 --> 00:38:13.616
And in fact, what
remaining little tidbits

00:38:13.616 --> 00:38:15.756
of data structures you're
finding that are still public

00:38:15.756 --> 00:38:17.596
in the data structures
are becoming private.

00:38:18.796 --> 00:38:21.926
Most URI-- applications
are well behaved

00:38:21.926 --> 00:38:24.256
and we thank you for that.

00:38:24.256 --> 00:38:26.176
Use APIs to instropect things

00:38:26.776 --> 00:38:28.556
and this lets us
innovate considerably

00:38:28.556 --> 00:38:29.596
as we've already described.

00:38:30.206 --> 00:38:34.866
But we've added some new
warnings to detect the use

00:38:34.866 --> 00:38:39.036
of tagged pointers and a related
problem of Raw 'isa' access.

00:38:40.416 --> 00:38:43.896
So, you might have code
like this in your program

00:38:44.026 --> 00:38:46.836
where you're testing the tag bit
and then you are like, "Great,

00:38:47.036 --> 00:38:50.256
I have discovered the tag bit
isn't set, I'm just going to run

00:38:50.256 --> 00:38:53.196
in there and just access
the isa directly and--

00:38:53.546 --> 00:38:55.696
because I'm think I'm
optimizing, this is fun."

00:38:56.506 --> 00:38:58.446
But in the case when
the tag bit is set,

00:38:58.446 --> 00:38:59.796
you actually called
the correct API.

00:39:01.326 --> 00:39:04.556
Well now, you're going to get a
warning for that tag bit check.

00:39:05.636 --> 00:39:06.936
And you're actually
going to get an error

00:39:06.936 --> 00:39:08.626
for the direct usage of the isa.

00:39:09.836 --> 00:39:10.916
Well how do you fix this?

00:39:11.576 --> 00:39:14.316
You delete the testing of that
bit and direct that access

00:39:14.316 --> 00:39:15.846
to the isa and you actually call

00:39:15.846 --> 00:39:18.816
like it isKindOfClass
or object getClass.

00:39:19.866 --> 00:39:21.126
We really need you to do this

00:39:21.126 --> 00:39:22.926
so we can unlock the
next level of innovation.

00:39:23.336 --> 00:39:25.726
And failure to do so, might
break your code in the future.

00:39:25.876 --> 00:39:28.466
So please, heed these warnings
and errors in your code

00:39:28.806 --> 00:39:30.386
and do the right thing.

00:39:31.476 --> 00:39:32.506
Thank you.

00:39:32.726 --> 00:39:35.706
Finally on the runtime part
of this talk, I'd like to talk

00:39:35.706 --> 00:39:36.806
about Garbage Collection.

00:39:38.096 --> 00:39:40.186
GC only exists on the Mac.

00:39:41.026 --> 00:39:42.176
We have replaced it with ARC

00:39:43.126 --> 00:39:47.216
and in fact we deprecated
Garbage Collection as of 10.8.

00:39:48.376 --> 00:39:50.006
We're very serious about this.

00:39:50.186 --> 00:39:52.566
We're not supporting Garbage
Collection in new frameworks,

00:39:52.606 --> 00:39:55.726
things like AVKit or Accounts
or GameController or GameKit,

00:39:56.736 --> 00:39:59.626
et cetera, et cetera, we're not
supporting Garbage Collection.

00:40:01.176 --> 00:40:03.686
We really need you to
use the ARC Migrator

00:40:03.686 --> 00:40:05.866
to transition off GC.

00:40:06.676 --> 00:40:09.866
So with that, let's talk about
Automatic Reference Counting

00:40:10.276 --> 00:40:13.006
and tell you about updates we've
been doing and some improvements

00:40:13.226 --> 00:40:15.276
to help you write better code.

00:40:16.706 --> 00:40:18.346
Let's start with the updates.

00:40:19.306 --> 00:40:22.636
Cocoa is designed with reference
counting semantics in mind.

00:40:22.936 --> 00:40:23.696
This is great.

00:40:24.136 --> 00:40:26.016
Being able to deterministically
know

00:40:26.016 --> 00:40:27.706
when an object is
destroyed allows you

00:40:27.706 --> 00:40:28.996
to better reason
about your code.

00:40:29.546 --> 00:40:31.066
It allows you to
better schedule things.

00:40:31.066 --> 00:40:32.536
It allows you to better design.

00:40:32.536 --> 00:40:34.266
And it's also just
great for debugging.

00:40:34.966 --> 00:40:38.296
ARC also helps you
write great code.

00:40:38.296 --> 00:40:42.026
It allows you to focus on what
matters and not the minutia

00:40:42.026 --> 00:40:45.986
of details of when things
need to be released.

00:40:47.256 --> 00:40:51.726
The majority of new App Store
submissions are using ARC.

00:40:51.726 --> 00:40:54.776
So a lot of you also agree that
this is a really great tool

00:40:54.776 --> 00:40:56.086
for focusing on what matters.

00:40:57.736 --> 00:41:01.236
Specific-- another great
example of ARC is Xcode 5.0.

00:41:01.716 --> 00:41:03.626
This used to be a GC app.

00:41:04.266 --> 00:41:05.266
It was a large app.

00:41:06.006 --> 00:41:07.596
Nevertheless, we were
able to convert it

00:41:07.596 --> 00:41:08.906
to Automatic Reference Counting

00:41:08.966 --> 00:41:10.506
and we're thrilled
with the results.

00:41:11.486 --> 00:41:13.226
We're thrilled with
the better determinism.

00:41:13.526 --> 00:41:14.786
We love the better debugging.

00:41:14.956 --> 00:41:17.426
We love that we're able to offer
tons of better performance.

00:41:17.936 --> 00:41:20.996
And we hope that you'll
find the same experience.

00:41:20.996 --> 00:41:25.486
Speaking of performance,
we are continuing

00:41:25.486 --> 00:41:27.476
to improve the performance
of ARC.

00:41:27.876 --> 00:41:30.146
Weak references are
now about twice as fast

00:41:30.276 --> 00:41:31.456
and this year's version

00:41:31.516 --> 00:41:34.906
of our operating system
iOS 7 and 10.9 for the Mac.

00:41:36.316 --> 00:41:39.246
And we're also improving the
debug experience as well.

00:41:39.366 --> 00:41:41.946
We have more predictable memory
usage under debug builds.

00:41:42.636 --> 00:41:44.376
Specifically, the lifetime

00:41:44.376 --> 00:41:47.156
of autoreleased objects is
much more like released builds.

00:41:48.586 --> 00:41:49.996
Now when you autorelease
an object,

00:41:49.996 --> 00:41:51.696
you don't necessarily
know when it goes away.

00:41:52.066 --> 00:41:54.926
And in fact, ARC
optimizations could kick in

00:41:54.926 --> 00:41:56.046
and change that timing.

00:41:56.736 --> 00:41:58.266
We've improved the compilers

00:41:58.266 --> 00:42:02.436
so the debug builds now
release the object much more

00:42:02.436 --> 00:42:06.166
like when released builds and
we hope you appreciate that.

00:42:11.746 --> 00:42:13.926
[applause] So this is our
great [inaudible] ARC.

00:42:14.736 --> 00:42:15.766
Well, we have Migrator.

00:42:16.326 --> 00:42:17.896
It does all the heavy
lifting for you.

00:42:17.896 --> 00:42:19.856
It removes retain,
release, autorelease.

00:42:20.616 --> 00:42:24.366
It deletes empty dealloc methods

00:42:24.366 --> 00:42:26.656
if all your dealloc method
was doing was calling release,

00:42:26.656 --> 00:42:27.386
release, release.

00:42:28.846 --> 00:42:30.726
It converts NSAutoreleasePool

00:42:30.726 --> 00:42:33.646
to @autoreleasepool
in the modern syntax.

00:42:34.986 --> 00:42:36.106
But you have to do the rest.

00:42:36.466 --> 00:42:39.966
You need to reason about some
rare things like id in structs.

00:42:39.966 --> 00:42:42.556
Usually the easiest thing to
do is convert these to classes

00:42:42.556 --> 00:42:44.536
and then, you know,
your code looks prettier

00:42:44.536 --> 00:42:45.146
in the end anyway.

00:42:45.906 --> 00:42:48.276
You also need to reason
about some atypical uses

00:42:48.276 --> 00:42:50.466
of memory management APIs.

00:42:51.736 --> 00:42:53.976
This was covered
in depth last year

00:42:54.106 --> 00:42:55.856
in the Automatic
Reference Counting talk

00:42:56.136 --> 00:42:57.536
and you can get all
the details there.

00:42:58.566 --> 00:43:00.436
But if you don't have time
to jump back to the video,

00:43:00.436 --> 00:43:01.836
here's what you need to do.

00:43:02.186 --> 00:43:05.626
Just like with modern syntax,
you can go to the Edit Menu,

00:43:05.626 --> 00:43:10.256
go to the Refracturing Submenu,
and you can convert to ARC

00:43:10.256 --> 00:43:14.566
and let the tools help
you along the way.

00:43:14.796 --> 00:43:18.746
So ARC and your app, we really
want you to switch to ARC

00:43:18.746 --> 00:43:21.606
by default and focus on what
matters which is your app

00:43:21.606 --> 00:43:22.606
and writing great code.

00:43:23.166 --> 00:43:25.876
You can always opt out specific
files if you run into problems.

00:43:25.876 --> 00:43:27.956
So you can just go to the
Profile Build Settings

00:43:27.956 --> 00:43:32.816
and select the Compiler
Flag for turning off ARC.

00:43:33.756 --> 00:43:35.746
And I'd also like to point

00:43:35.746 --> 00:43:38.866
out that the ARC Migrator
supports both manual reference

00:43:38.916 --> 00:43:41.156
counting code and
garbage-collected code

00:43:41.156 --> 00:43:44.436
and it helps you migrate both
easily and straight forward.

00:43:45.066 --> 00:43:49.726
Now for an update on
new things we've added

00:43:49.796 --> 00:43:51.886
that we think you will love.

00:43:51.886 --> 00:43:54.976
Let's talk about some new memory
management warnings we have

00:43:54.976 --> 00:43:58.606
added to help you better
reason about life under ARC.

00:43:59.356 --> 00:44:02.736
So, there are three things
I'm going to be talking about

00:44:03.316 --> 00:44:06.056
and we're going to be talking
about the implicit referencing

00:44:06.056 --> 00:44:08.716
of self and retain
cycles with blocks.

00:44:08.716 --> 00:44:13.876
We're going to be talking about
repeated use of a weak variable

00:44:13.876 --> 00:44:15.386
and what does that even mean.

00:44:16.046 --> 00:44:18.796
And then thirdly, we'll be
talking about sending messages

00:44:18.796 --> 00:44:22.316
to weak and had a better reason
about the behavior thereof.

00:44:23.716 --> 00:44:26.856
So let's jump in first and
talk about retain cycles.

00:44:27.296 --> 00:44:28.276
As a brief refresher,

00:44:28.276 --> 00:44:30.786
let's imagine your app is
just referencing an object.

00:44:31.266 --> 00:44:34.076
The reference count of this
object will start out is one.

00:44:35.136 --> 00:44:38.826
And similarly, if that object
references another object,

00:44:38.946 --> 00:44:41.216
that will be one.

00:44:41.216 --> 00:44:44.146
But, if we actually
have a reference back

00:44:44.146 --> 00:44:46.786
to the original object, its
reference count would be two.

00:44:46.786 --> 00:44:50.676
And if our app lets go of
the object, we have a leak

00:44:50.676 --> 00:44:52.766
because now these two
objects are holding references

00:44:52.766 --> 00:44:54.976
on to each other and
keeping the object alive.

00:44:56.206 --> 00:44:58.836
So with that in mind,
let's look at some code.

00:44:59.896 --> 00:45:02.376
Let's say in a method you
have two instance variables.

00:45:03.546 --> 00:45:05.526
And one of the instance
variables holds the block

00:45:05.526 --> 00:45:06.966
and the other one
is just an object.

00:45:06.966 --> 00:45:08.116
It doesn't really
matter what kind.

00:45:09.146 --> 00:45:10.186
In the block we use ivar2,

00:45:10.266 --> 00:45:12.346
and then we assign
the block to ivar1.

00:45:12.346 --> 00:45:15.796
Well what's actually
going on under the covers

00:45:15.796 --> 00:45:17.226
and how the compiler reasons

00:45:17.226 --> 00:45:19.146
about this is we have
implicit use of self

00:45:19.146 --> 00:45:20.256
in both of these cases.

00:45:20.556 --> 00:45:23.166
And those are the actual
objects in question

00:45:23.166 --> 00:45:26.606
that we need to think about.

00:45:26.606 --> 00:45:30.236
So let's delete that and then
see what warning the compiler

00:45:30.236 --> 00:45:31.036
can now print out.

00:45:32.276 --> 00:45:35.736
So I've enabled this warning,
the compiler will print out,

00:45:36.126 --> 00:45:39.516
they were capturing self
strongly in the ivar2 case,

00:45:39.516 --> 00:45:41.856
and then it points
out the related case

00:45:41.856 --> 00:45:43.546
where it believes
the cycle began.

00:45:44.846 --> 00:45:46.196
Well, again, I'm
a visual person,

00:45:46.196 --> 00:45:47.916
but show what this
looks like in practice.

00:45:48.486 --> 00:45:52.616
So we have an instance of
our class and we have ivar2.

00:45:52.726 --> 00:45:55.506
Again, ivar2 can be any
object, string, whatever.

00:45:56.466 --> 00:45:57.876
And now we're creating
this block.

00:45:59.096 --> 00:46:01.496
Now when we wrote the code,
it may look like this.

00:46:01.496 --> 00:46:04.206
It may look like we're just
assigning the block to ivar1

00:46:04.206 --> 00:46:05.086
and we're using ivar2.

00:46:05.256 --> 00:46:06.516
What's the problem?

00:46:06.516 --> 00:46:07.376
I don't see any cycle.

00:46:08.866 --> 00:46:11.086
Well because there is
an implicit use of self,

00:46:11.176 --> 00:46:13.326
the block is actually
retaining self.

00:46:13.326 --> 00:46:17.416
And now we have a cycle and now
it's indirectly accessing ivar2.

00:46:17.416 --> 00:46:19.696
And again, we'll
get the same leak

00:46:19.696 --> 00:46:22.916
that we demonstrated earlier
if we let go of the instance

00:46:22.916 --> 00:46:25.296
of our class, the
block will be keeping

00:46:25.296 --> 00:46:28.656
that instance alive
and we have a leak.

00:46:28.796 --> 00:46:30.566
So let's go back to the
code and the warning.

00:46:30.856 --> 00:46:31.936
How do we fix this?

00:46:32.706 --> 00:46:34.996
Well we make some room and
we add a weak variable.

00:46:35.696 --> 00:46:38.716
So what we do is we create
a weak variable on the stack

00:46:39.776 --> 00:46:41.306
and assign self to it.

00:46:41.306 --> 00:46:44.856
And this variable is an instance
of the same type of our class.

00:46:45.926 --> 00:46:49.596
And then what we do is we use
this weak variable in our block.

00:46:50.376 --> 00:46:52.786
And if we do that,
the warning goes away.

00:46:54.476 --> 00:46:56.466
So what's going on here?

00:46:57.746 --> 00:47:01.246
Weak variables do not extend
the lifetime on objects.

00:47:02.116 --> 00:47:04.806
They are-- and therefore,

00:47:04.806 --> 00:47:06.806
they don't implicitly
create retain cycles.

00:47:07.326 --> 00:47:11.636
And the great thing about weak
variables is they safely become

00:47:11.636 --> 00:47:12.826
nil when the reference count

00:47:12.826 --> 00:47:14.906
of the object they're
referring to drops to zero.

00:47:15.686 --> 00:47:18.696
Now in this particular
case, they are tied together

00:47:18.696 --> 00:47:19.646
so we don't have a problem.

00:47:19.646 --> 00:47:21.206
But it allows us
to break the cycle

00:47:21.206 --> 00:47:22.576
and actually get
the paper we want

00:47:22.576 --> 00:47:26.486
when we release the
instance of our class.

00:47:26.636 --> 00:47:29.536
So building on this, let's talk
about weak variables in general.

00:47:30.666 --> 00:47:31.806
Consider this simple method

00:47:31.806 --> 00:47:34.746
where we're logging the
description of a weak ivar.

00:47:36.176 --> 00:47:37.576
Does this method
even called call?

00:47:37.576 --> 00:47:39.096
What happens if the weak is nil?

00:47:39.396 --> 00:47:41.196
You know, what actually
happens here?

00:47:41.856 --> 00:47:45.876
How do we reason
about this at all?

00:47:45.936 --> 00:47:49.526
Well, now the compiler
can warn about this saying

00:47:50.246 --> 00:47:55.516
that we're using weak variable
and it may unpredictably be nil.

00:47:56.686 --> 00:48:00.056
Well what do we do about this?

00:48:00.266 --> 00:48:01.706
Well, it's actually
worst than that.

00:48:01.706 --> 00:48:05.406
It can get-- we can have a
weak variable and use it twice.

00:48:05.956 --> 00:48:08.606
Does this get called
zero, one or two times?

00:48:08.886 --> 00:48:10.416
You know, how do we
reason about this?

00:48:11.346 --> 00:48:13.296
Well there's actually a
solution for both of these

00:48:13.436 --> 00:48:16.176
and I'd like to-- oh, sorry.

00:48:17.106 --> 00:48:19.246
In the repeated use case, we
now have a specific warning

00:48:19.246 --> 00:48:21.046
for that too pointing
out that, you know,

00:48:21.116 --> 00:48:23.636
you can't actually reason about
the zero, one or two case.

00:48:24.516 --> 00:48:28.716
[ Pause ]

00:48:29.216 --> 00:48:33.656
So let's go back to the original
code and the original warning

00:48:33.716 --> 00:48:34.826
and look at how we fix this.

00:48:35.266 --> 00:48:39.826
Let's make some room and
do as the compiler advices

00:48:39.826 --> 00:48:42.376
and put a local strong
variable on the stack,

00:48:42.986 --> 00:48:45.056
assign our weak variable
into it.

00:48:45.516 --> 00:48:46.566
And once we've done that,

00:48:47.116 --> 00:48:50.506
that strong variable is
either nil or not nil.

00:48:50.816 --> 00:48:52.106
It's not going to
change magically

00:48:52.106 --> 00:48:53.106
out from underneath us.

00:48:53.836 --> 00:48:56.156
And because we know that,
we can now test for it.

00:48:56.156 --> 00:48:59.886
And if it's not nil, we can now
safely print the description.

00:48:59.886 --> 00:49:02.736
And if we do that, of
course, the warning goes away.

00:49:03.646 --> 00:49:06.786
So this is great.

00:49:07.216 --> 00:49:10.126
We now can reason about the
lifetime of this variable.

00:49:11.056 --> 00:49:14.396
And the great thing too is
handling the nil case becomes

00:49:14.396 --> 00:49:15.086
very obvious.

00:49:15.086 --> 00:49:20.716
We just add the else block
and do the right thing.

00:49:20.936 --> 00:49:24.206
Next up in the Automatic
Reference Counting Improvements,

00:49:24.476 --> 00:49:26.976
I'd like to talk
about the relationship

00:49:27.066 --> 00:49:28.726
between ARC and CoreFoundation.

00:49:29.296 --> 00:49:31.766
If you've already
been using ARC,

00:49:31.766 --> 00:49:32.956
you may have been writing a code

00:49:32.956 --> 00:49:34.946
like this every time you
interact with CoreFoundation.

00:49:34.946 --> 00:49:38.836
You have a CFDictionary,
getting some value out of it.

00:49:39.246 --> 00:49:43.736
And in order to help ARC reason
about the object lifetime,

00:49:43.846 --> 00:49:46.756
we use a bridge cast saying
that there's no net change

00:49:46.756 --> 00:49:47.696
in the reference count here.

00:49:49.196 --> 00:49:52.546
This is required because
anytime we come in and out

00:49:52.546 --> 00:49:54.396
of the ARC system, we
need the ARC compiler

00:49:54.396 --> 00:49:55.926
to actually be tracking
the reference count

00:49:55.926 --> 00:49:58.386
so that way objects live
only as long as they need to,

00:49:58.386 --> 00:49:59.626
and no longer and no shorter.

00:49:59.626 --> 00:50:06.836
We have a +1-- you can express
+1 to ARC via CFBridgingRetain.

00:50:07.116 --> 00:50:09.116
You can express a decrement

00:50:09.116 --> 00:50:11.376
of the reference count
via CFBridgingRelease.

00:50:12.036 --> 00:50:18.976
And you can express a no
net change via bridge cast.

00:50:19.156 --> 00:50:22.036
Well, you know, it's
great that we're using ARC

00:50:22.036 --> 00:50:23.806
and we've been able
to make our CF code

00:50:23.806 --> 00:50:25.386
and our Foundation
code work together,

00:50:25.386 --> 00:50:26.926
but can we improve
this situation?

00:50:27.816 --> 00:50:29.716
Well, CoreFoundation
actually has some really

00:50:29.716 --> 00:50:30.796
strong conventions.

00:50:31.296 --> 00:50:33.516
Create and copy methods
return +1

00:50:33.816 --> 00:50:35.526
and everything else returns +0.

00:50:36.456 --> 00:50:39.596
And in fact, we already have
some compiler attributes

00:50:39.596 --> 00:50:42.026
for the exceptions,
like CF RETUNS RETAINED

00:50:42.026 --> 00:50:46.806
and CF RETURNS NOT RETAINED and
CF releases argument for APIs

00:50:46.806 --> 00:50:48.466
that consume their argument.

00:50:49.416 --> 00:50:52.236
And these are there to
help the static analyzer

00:50:52.236 --> 00:50:53.986
and you may have already
seen this kick in,

00:50:53.986 --> 00:50:55.536
in your use of the
static analyzer.

00:50:56.326 --> 00:51:00.696
Well, what if we can just
use these conventions

00:51:00.696 --> 00:51:03.146
to make this bridge
cast go away?

00:51:04.186 --> 00:51:07.376
In fact, we've formalized
the everything else cast now.

00:51:08.406 --> 00:51:13.096
The common CF APIs you use
now allow implicit bridging

00:51:13.096 --> 00:51:14.846
as opposed to this
explicit bridging.

00:51:15.516 --> 00:51:21.086
[ Applause ]

00:51:21.586 --> 00:51:24.286
There are new macros
available for use too.

00:51:24.286 --> 00:51:26.336
And with that, I'd like to
show you how this works.

00:51:27.126 --> 00:51:29.656
So, how do we enable
implicit bridging?

00:51:30.206 --> 00:51:34.706
Let's imagine we're wrapping
a CoreFoundation Array

00:51:34.706 --> 00:51:36.066
and we have our example
Foo that--

00:51:36.066 --> 00:51:37.896
we have just bunch of
wrappers around the array.

00:51:39.376 --> 00:51:41.716
Well the first API we
have here is great.

00:51:41.716 --> 00:51:43.876
It follows the convention
as copying the name.

00:51:44.266 --> 00:51:45.456
We don't need to do anything.

00:51:46.856 --> 00:51:48.606
The second API is also great.

00:51:48.756 --> 00:51:49.756
We don't need to anything

00:51:49.756 --> 00:51:50.956
because it follows
the convention.

00:51:50.956 --> 00:51:51.936
It returns +1.

00:51:51.936 --> 00:51:53.316
It doesn't consume
any arguments.

00:51:54.376 --> 00:51:57.176
But our third API, we don't
know what we were thinking.

00:51:57.176 --> 00:52:01.486
We decided that we're going
to return retained and--

00:52:01.746 --> 00:52:03.136
but we're following
the convention.

00:52:03.756 --> 00:52:07.936
Well, what we need to do is put
a CF RETURNS RETAINED attribute

00:52:07.976 --> 00:52:13.016
there via macro and let the
compiler know what's going on.

00:52:13.576 --> 00:52:14.966
Even if we just stop
here and do this,

00:52:14.966 --> 00:52:17.496
we've already help the static
analyzer reason about our code.

00:52:18.066 --> 00:52:20.196
But once we're done auditing,

00:52:20.196 --> 00:52:22.886
what we can do is
add these macros,

00:52:22.936 --> 00:52:26.786
CF IMPLICIT BRIDGING ENABLED and
CF IMPLICIT BRIDGING DISABLED

00:52:26.986 --> 00:52:29.246
to tell the compiler
that we've audited code.

00:52:30.586 --> 00:52:33.636
Now, this must be
after all #includes.

00:52:33.766 --> 00:52:36.006
Obviously, you're not
auditing somebody else's code.

00:52:36.006 --> 00:52:37.226
You're auditing your code.

00:52:38.476 --> 00:52:40.696
And you don't have to
do it around everything.

00:52:40.696 --> 00:52:42.526
If there's code you don't
want to think about right now,

00:52:42.526 --> 00:52:45.466
you could have the explicitly
bridge code remain outside

00:52:45.466 --> 00:52:48.346
of the macros they are using.

00:52:49.786 --> 00:52:51.576
And that is implicit bridging

00:52:51.576 --> 00:52:54.736
and this is all the
common CF plist types

00:52:54.776 --> 00:52:57.876
or have been auditing and you
can go remove this bridge cast

00:52:57.876 --> 00:53:00.316
from your code if you're
using the new SDKs.

00:53:00.836 --> 00:53:04.656
So to wrap up, we have Modules.

00:53:05.206 --> 00:53:08.696
This is really great for finally
fixing the textual inclusion

00:53:08.696 --> 00:53:11.236
problem and all the
associated bugs.

00:53:11.706 --> 00:53:13.536
It also adds great performance

00:53:13.536 --> 00:53:15.986
for compilation time
and indexing.

00:53:16.596 --> 00:53:19.076
And it's just a much more
pleasurable experience

00:53:19.076 --> 00:53:20.246
with features like Autolinking.

00:53:20.826 --> 00:53:22.246
We also have improved
productivity

00:53:22.246 --> 00:53:25.946
with better compiler warnings
throughout the SDK adoption

00:53:25.946 --> 00:53:28.686
of these compiler warnings to
help you catch errors early

00:53:29.106 --> 00:53:30.696
and write more productive code.

00:53:31.326 --> 00:53:33.176
And with ARC, we've made
it better and faster

00:53:33.176 --> 00:53:37.356
by allowing you to better
reason about simple retain cycle

00:53:37.356 --> 00:53:40.386
and weak reference bugs,
and also easier in the fact

00:53:40.386 --> 00:53:42.316
that you no longer need
to write bridge cast

00:53:42.316 --> 00:53:45.046
for common CF plist types.

00:53:45.236 --> 00:53:46.986
For more information,
I'd like to point you

00:53:47.086 --> 00:53:48.596
at Dave DeLong, our evangelist.

00:53:49.576 --> 00:53:51.016
We also have tons
of documentation

00:53:51.016 --> 00:53:54.816
on the developer website and
of course the Developer Forums.

00:53:55.576 --> 00:53:58.376
We have two labs,
one tomorrow morning

00:53:58.376 --> 00:54:00.156
and one Thursday afternoon.

00:54:01.326 --> 00:54:02.666
Oh sorry, related sessions.

00:54:03.006 --> 00:54:04.816
We have What's New
in LLVM Compiler,

00:54:04.816 --> 00:54:07.146
it happened earlier today, you
have to catch them on video.

00:54:07.196 --> 00:54:10.136
But tomorrow, we have
Optimize Your Code Using LLVM

00:54:10.226 --> 00:54:12.306
in Nob Hill at 3:30.

00:54:12.656 --> 00:54:13.706
So, thanks for coming.

00:54:14.516 --> 00:54:21.840
[ Applause ]
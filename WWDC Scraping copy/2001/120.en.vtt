WEBVTT

00:00:03.480 --> 00:00:06.600
Alright, so this session we're going to
carry on with the topics that we're,

00:00:06.600 --> 00:00:08.650
or not with the topics,
but we're going to carry on the track

00:00:08.650 --> 00:00:11.000
that we were talking about earlier,
which is how do you make a

00:00:11.000 --> 00:00:12.400
great application on Mac OS X.

00:00:12.400 --> 00:00:15.470
And if you remember in
Session 111 yesterday,

00:00:15.470 --> 00:00:19.400
I had at the beginning the good, better,
best scenarios for adopting Aqua.

00:00:19.400 --> 00:00:21.940
And in the best scenario,
or even in the better,

00:00:21.940 --> 00:00:24.630
we started to talk about
things like Help Tags,

00:00:24.630 --> 00:00:28.400
and doing lists,
making lists appear properly on Mac OS X.

00:00:28.400 --> 00:00:31.400
And doing the right thing with the Doc.

00:00:31.400 --> 00:00:35.400
So one of the very basic things
that every application should do

00:00:35.470 --> 00:00:37.310
is respect the Doc's position,
right?

00:00:37.410 --> 00:00:38.400
And not size windows behind that.

00:00:38.400 --> 00:00:40.390
We're going to talk about
that in this session.

00:00:40.400 --> 00:00:44.260
Some of the other things you might do,
some applications might do with the Doc,

00:00:44.480 --> 00:00:47.400
is animate the Doc icon
or the application icon.

00:00:47.400 --> 00:00:49.400
And we're going to talk about
some of that material here.

00:00:49.420 --> 00:00:52.010
So to go in depth on this stuff,
I'd like to bring

00:00:52.100 --> 00:00:53.880
Guy Fullerton back on stage.

00:00:54.940 --> 00:00:56.950
from the High-Level Toolbox team.

00:00:56.950 --> 00:00:57.710
Guy, go for it.

00:00:57.810 --> 00:00:58.740
All right.

00:00:58.740 --> 00:01:01.140
Well, thankfully,
I'm not given the demo for this one,

00:01:01.140 --> 00:01:03.950
so I can't screw another one up.

00:01:05.380 --> 00:01:07.300
That's me!

00:01:07.300 --> 00:01:10.300
John mentioned I'm going to
talk about a lot of things.

00:01:10.420 --> 00:01:12.940
Yesterday at Ed's session,
we talked about new features

00:01:12.940 --> 00:01:17.950
in the Window and Menu Manager,
and I'm going to talk about a bunch of

00:01:17.950 --> 00:01:24.690
new features in the Control Manager,
as well as sort of a toolbox potpourri.

00:01:24.690 --> 00:01:24.690
We're going to touch on Doc issues,
DataBrowser, Help Tags,

00:01:24.690 --> 00:01:24.690
and a few other things.

00:01:25.190 --> 00:01:28.740
So to dive right in, like I said,
the Control Manager is moving forward.

00:01:28.830 --> 00:01:31.880
We've added a bunch of
new functionality to it.

00:01:32.180 --> 00:01:36.100
The most obvious piece of
functionality is Aqua widget animation.

00:01:36.120 --> 00:01:38.360
When you create a push-button control,
it flashes.

00:01:38.430 --> 00:01:41.900
When you create a progress bar control,
the fill moves to let the user know

00:01:41.900 --> 00:01:43.750
that the progress is really happening.

00:01:43.840 --> 00:01:46.380
Some other controls that we've
had on previous systems that

00:01:46.380 --> 00:01:51.200
animate are the Chasing Arrows
Control and the Edit Text Control.

00:01:51.240 --> 00:01:52.620
Those animated on previous systems.

00:01:52.860 --> 00:01:54.900
They animate today on Mac OS X.

00:01:54.990 --> 00:01:58.590
But the difference is that
all of these controls animate

00:01:58.590 --> 00:02:00.450
via a Carbon event timer.

00:02:00.940 --> 00:02:04.840
What this means is the controls
will animate automatically behind

00:02:04.860 --> 00:02:07.380
your back whenever you're sort
of in the event loop sleeping.

00:02:07.400 --> 00:02:10.580
If you got a chance to see Ed's
Carbon Event session the other day,

00:02:10.600 --> 00:02:11.830
you'll know what I'm talking about.

00:02:11.910 --> 00:02:14.610
If you didn't get a chance to see it,
it's important that you try to

00:02:14.750 --> 00:02:16.400
track down the video for that later.

00:02:16.400 --> 00:02:19.370
It's got some key concepts
with respect to use of timers.

00:02:19.400 --> 00:02:23.320
But fundamentally what this means
is that you no longer need to

00:02:23.330 --> 00:02:27.400
call idle controls for the system
controls under Aqua on Mac OS X.

00:02:27.400 --> 00:02:30.470
They're going to do their animation
automatically via a timer,

00:02:30.470 --> 00:02:33.380
so you don't need to be calling
WaitNextEvent with some small timeout

00:02:33.480 --> 00:02:35.350
just so you can call idle controls.

00:02:35.410 --> 00:02:37.270
In fact,
that's going to be bad because your

00:02:37.270 --> 00:02:40.400
app's going to be using up a lot of
the CPU and you don't want to do that.

00:02:41.010 --> 00:02:44.900
Now all of the controls will begin to
animate as soon as they've drawn once.

00:02:44.900 --> 00:02:48.040
We do this so that we can get the
proper look as soon as a window appears.

00:02:48.060 --> 00:02:50.620
We don't want to begin
animating a push button,

00:02:50.660 --> 00:02:53.230
for instance,
right after the window appears

00:02:53.320 --> 00:02:56.120
before you get the update event,
because you'll see the button show up

00:02:56.200 --> 00:02:58.000
before the rest of the window paints.

00:02:58.120 --> 00:03:01.660
So what we do is we actually delay
the beginning of the animation until

00:03:01.670 --> 00:03:03.970
after the control draws normally once.

00:03:04.060 --> 00:03:06.080
And for some of the controls,
particularly the progress

00:03:06.080 --> 00:03:08.350
bar and the chasing arrows,
we offer a way to start

00:03:08.350 --> 00:03:11.100
and stop the animation,
if that's useful to your users.

00:03:11.100 --> 00:03:14.570
You might want to say that a
download's paused for some reason,

00:03:14.570 --> 00:03:17.070
or there's a network lag,
and so you want to stop spinning

00:03:17.070 --> 00:03:18.090
the arrows for that reason.

00:03:18.100 --> 00:03:21.240
And you can do that via
the Set Control Data API.

00:03:21.300 --> 00:03:25.480
Set Control Data takes a control and a
tag for the type of data you want to set,

00:03:25.610 --> 00:03:29.690
and in these particular cases you pass
in the KControlProgressBarAnimatingTag

00:03:30.070 --> 00:03:32.700
or KControlChasingArrowsAnimatingTag,
as well as a Boolean value for

00:03:32.700 --> 00:03:33.300
whether the control is set or not.

00:03:33.300 --> 00:03:33.300
So you can set the control to be set,
and then you can set

00:03:33.300 --> 00:03:33.300
the control to be set.

00:03:33.300 --> 00:03:35.180
value for whether or not
you want it to animate.

00:03:35.180 --> 00:03:37.790
So you can start and stop it that way.

00:03:38.460 --> 00:03:41.440
Push Buttons - the way you start
and stop them from animating

00:03:41.530 --> 00:03:43.300
is by marking them as default.

00:03:43.360 --> 00:03:45.300
There's a bunch of different
ways you can do that.

00:03:45.360 --> 00:03:48.300
The preferred way is
Set Window Default Button.

00:03:48.510 --> 00:03:50.290
This is a new API for Carbon.

00:03:50.290 --> 00:03:53.640
Essentially,
what it does for you is it marks a

00:03:53.640 --> 00:03:57.300
particular control as the default
control for a given window.

00:03:57.360 --> 00:04:01.140
And the coolest thing about this is if
that default control is a push button,

00:04:01.140 --> 00:04:03.300
the push button will begin animating.

00:04:03.300 --> 00:04:06.150
The other benefit of Set Window Default
Button is that it also tells

00:04:06.190 --> 00:04:08.850
the Carbon Event Manager which
control to hit when the user

00:04:08.850 --> 00:04:10.290
presses the Return or Enter key.

00:04:10.300 --> 00:04:11.900
So if you can use
Set Window Default Button,

00:04:11.990 --> 00:04:13.280
by all means, go ahead and do it.

00:04:13.300 --> 00:04:16.270
It's going to get you the most free
functionality now and in the future.

00:04:16.300 --> 00:04:21.270
Now, an API that you're probably familiar
with already is Set Dialog Default Item.

00:04:21.300 --> 00:04:25.000
If you use the Dialog Manager a lot,
you use this API to tell the Dialog

00:04:25.030 --> 00:04:27.300
Manager which the default button is.

00:04:27.300 --> 00:04:30.380
And of course, when you call this API,
we will start the default

00:04:30.450 --> 00:04:32.300
button animating appropriately.

00:04:32.300 --> 00:04:34.300
And if neither of those
really serve your needs,

00:04:34.300 --> 00:04:37.000
if you want more fine-grained
control over whether or

00:04:37.000 --> 00:04:40.470
not a button is animating,
you can use Set Control Data to toggle

00:04:40.470 --> 00:04:45.300
on or off the animation as you wish with
the K-Control Push Button default tag.

00:04:46.900 --> 00:04:48.890
We've added a number of
new widgets for Aqua,

00:04:48.910 --> 00:04:50.790
and you can see all of
them up on the screen.

00:04:50.800 --> 00:04:53.600
I'll go through them sort of one by one
and tell you what they're useful for.

00:04:53.640 --> 00:04:55.020
We have a rounded bevel button.

00:04:55.030 --> 00:04:57.890
You can see those down at the
bottom of the window snapshot there.

00:04:57.970 --> 00:05:00.190
It's just a different
look for a bevel button.

00:05:00.310 --> 00:05:02.390
By default,
your bevel buttons will come up with

00:05:02.440 --> 00:05:05.940
the square look that you're used to,
and that's so you can continue using

00:05:05.940 --> 00:05:09.230
the same sort of grouped bevel button
APIs where they're real close together.

00:05:09.350 --> 00:05:11.250
But you might have some needs
where you really want to

00:05:11.250 --> 00:05:12.500
draw a rounded bevel button.

00:05:12.500 --> 00:05:16.380
And the way you go about that is
by using a cool feature we added

00:05:16.430 --> 00:05:19.850
to the Mac OS X bevel button,
whereby you can change the

00:05:19.850 --> 00:05:23.370
appearance of the bevel button and
essentially tell it which Appearance

00:05:23.400 --> 00:05:25.800
Manager theme button to draw itself as.

00:05:25.860 --> 00:05:28.370
So you can create a bevel
button control and say,

00:05:28.480 --> 00:05:32.520
"Draw in a rounded fashion," or "Draw
in a normal push button fashion,"

00:05:32.640 --> 00:05:36.370
or "Draw in some other fashion."
So the bevel button is sort of

00:05:36.470 --> 00:05:38.590
visually polymorphic in that way.

00:05:38.690 --> 00:05:40.750
We also offer a round button
that you can see up in the top

00:05:40.760 --> 00:05:42.250
left-hand corner of the screenshot.

00:05:42.540 --> 00:05:44.790
This is used for a number of reasons.

00:05:44.870 --> 00:05:48.430
Most prominently,
it's the new Help button that we want

00:05:48.430 --> 00:05:51.290
in our Aqua user interface guidelines.

00:05:51.310 --> 00:05:54.020
I'm going to talk specifically
about how to get that a little

00:05:54.020 --> 00:05:57.100
bit later in some gotchas with
respect to Mac OS X and Mac OS 9.

00:05:57.230 --> 00:06:01.610
We also use that for the Back button
and the Home button in things

00:06:01.720 --> 00:06:04.550
like Sherlock and the Help Viewer.

00:06:05.080 --> 00:06:08.760
We have a Relevance Bar as well,
which is essentially just a variant

00:06:08.760 --> 00:06:10.200
of the Progress Bar Control.

00:06:10.280 --> 00:06:11.430
It lets you do relevance ranking.

00:06:11.470 --> 00:06:12.830
Sherlock uses this.

00:06:13.070 --> 00:06:16.140
If you were using the
Progress Bar Control in Mac OS 9

00:06:16.140 --> 00:06:19.270
in Carbon to do a relevance rank,
that's not going to give you the right

00:06:19.330 --> 00:06:21.440
appearance under Aqua on Mac OS X.

00:06:21.440 --> 00:06:25.840
So you should really begin using
the Relevance Bar under Mac OS X.

00:06:26.170 --> 00:06:28.940
We also have a Disclosure Button,
which is not on the screenshot.

00:06:28.990 --> 00:06:32.000
That's most prominently used in
a Navigation Services dialog.

00:06:32.040 --> 00:06:36.030
It's useful for controlling
whether a window resizes or shrinks

00:06:36.130 --> 00:06:38.240
back to show you more details.

00:06:38.240 --> 00:06:40.710
Something that's not
exactly new for Aqua,

00:06:40.710 --> 00:06:43.700
but that I wanted to point out,
is the fact that we still

00:06:43.700 --> 00:06:45.000
have four-sided tabs.

00:06:45.000 --> 00:06:47.360
Platinum has supported four-sided tabs.

00:06:47.400 --> 00:06:51.200
You can have tabs on the top, right,
bottom, and left of your control.

00:06:51.240 --> 00:06:55.190
But earlier releases of Mac OS X didn't
support the full functionality.

00:06:55.240 --> 00:06:57.380
I think we only supported
top tabs for a while.

00:06:57.400 --> 00:06:59.700
Well, they're all back into the
GM release of Mac OS X,

00:06:59.720 --> 00:07:01.930
so you can continue using
them on all four sides.

00:07:01.960 --> 00:07:05.320
Of course, we have appearance primitives
to draw all of these widgets.

00:07:05.320 --> 00:07:07.320
So if you don't feel
comfortable using the controls,

00:07:07.320 --> 00:07:09.970
or you have very specialized needs,
you can call the Appearance

00:07:09.970 --> 00:07:12.640
Manager to draw any of these for you.

00:07:15.420 --> 00:07:17.980
Another request we got when we came
out with the Aqua User Interface

00:07:18.100 --> 00:07:22.290
Guidelines was we need smaller
controls or differently sized controls.

00:07:22.300 --> 00:07:25.340
Now the normal controls are
basically platinum sized,

00:07:25.440 --> 00:07:28.050
but there are certain cases in your
user interface where you've got a small

00:07:28.060 --> 00:07:31.650
palette or some other tiny piece of
screen real estate where you need to draw

00:07:31.650 --> 00:07:34.610
a bunch of small check boxes or small
push buttons or something like that.

00:07:34.800 --> 00:07:38.300
And the Aqua widgets are
just too big for those cases.

00:07:38.300 --> 00:07:41.770
So what we did is we implemented
some small versions of various

00:07:41.770 --> 00:07:44.790
system controls so that you could
get the right look under Aqua.

00:07:44.800 --> 00:07:49.300
A lot of applications out there had
small controls already on Mac OS 9.

00:07:49.300 --> 00:07:51.680
That's because they
implemented them themselves.

00:07:51.850 --> 00:07:53.770
They wrote custom C-Defs or
maybe they weren't C-Defs.

00:07:53.900 --> 00:07:55.800
They just wrote custom
code to draw these things.

00:07:55.800 --> 00:07:58.300
And of course those are going
to look really ugly under Aqua.

00:07:58.300 --> 00:08:01.760
So if you're using your own
hand rolled small controls,

00:08:01.790 --> 00:08:04.720
you want to begin using the
system supported smaller controls.

00:08:06.520 --> 00:08:09.240
There are four basic
sizes of controls now.

00:08:09.280 --> 00:08:11.630
Like I mentioned before,
the Platinum metrics

00:08:11.760 --> 00:08:13.060
are the normal sizes.

00:08:13.200 --> 00:08:17.470
This allows you to have a window that's
laid out and have it look just fine

00:08:17.470 --> 00:08:20.000
on Platinum and just fine on Mac OS X.

00:08:20.110 --> 00:08:23.030
Some controls,
like the checkbox and the radio button,

00:08:23.030 --> 00:08:24.500
support a smaller size.

00:08:24.500 --> 00:08:27.690
Others, like the progress bar,
support a larger size.

00:08:27.780 --> 00:08:31.070
The progress bar is an interesting case,
actually,

00:08:31.070 --> 00:08:34.690
because the default progress bar size,
being the same size

00:08:34.690 --> 00:08:38.140
as it was in Platinum,
is good for your layout purposes.

00:08:38.280 --> 00:08:40.540
But unfortunately,
the default size for the progress

00:08:40.540 --> 00:08:43.200
bar does not match the Acquia
User Interface guidelines.

00:08:43.220 --> 00:08:45.500
The guidelines say you
should use a larger one.

00:08:45.590 --> 00:08:49.780
So in order to match the guidelines,
you need to set the size of your progress

00:08:49.780 --> 00:08:51.900
bar control to be the large size.

00:08:52.010 --> 00:08:55.700
The fourth size we support is
actually an automatic size.

00:08:55.810 --> 00:08:57.200
And we've actually
supported this for a while,

00:08:57.200 --> 00:08:57.650
just not a case.

00:08:57.700 --> 00:08:59.700
We've also supported this explicitly.

00:08:59.700 --> 00:09:03.360
Certain controls, like the scroll bar,
vary how they draw depending on

00:09:03.360 --> 00:09:06.700
how wide or narrow you make the
control rectangle themselves.

00:09:06.700 --> 00:09:09.100
If your scroll bar is
about 15 or 16 pixels wide,

00:09:09.100 --> 00:09:11.140
we're going to draw the
normal size scroll bar.

00:09:11.200 --> 00:09:13.150
But as soon as you drop it
below a certain threshold,

00:09:13.190 --> 00:09:16.150
which I think is about 12 pixels,
we begin drawing a narrower,

00:09:16.150 --> 00:09:17.200
small scroll bar.

00:09:17.200 --> 00:09:21.190
So the scroll bar is one of the ones
that can support an automatic size.

00:09:21.200 --> 00:09:23.660
Now, if you don't like the automatic
sizing for scroll bars,

00:09:23.690 --> 00:09:27.200
you can explicitly request
either the normal or small size.

00:09:27.200 --> 00:09:27.700
So that's one of the things
we're going to be looking at.

00:09:27.700 --> 00:09:29.700
And the other thing is that you
can use the small size if you wish.

00:09:29.790 --> 00:09:31.720
But in general,
you need to make sure that you don't

00:09:31.720 --> 00:09:33.690
just use these because they're available.

00:09:33.700 --> 00:09:35.700
You need to have good reasons for them.

00:09:35.700 --> 00:09:38.650
The larger size controls
are much more reasonable.

00:09:38.720 --> 00:09:40.170
And if you can fit them
into your interface,

00:09:40.170 --> 00:09:42.080
please do so,
even if it means making your

00:09:42.080 --> 00:09:43.700
windows a little bit larger.

00:09:43.700 --> 00:09:45.940
But if you do have specialized needs,
like to fit a whole bunch of

00:09:45.940 --> 00:09:48.690
widgets on a pallet or some other
small bit of screen real estate,

00:09:48.700 --> 00:09:51.420
go ahead and use the small
controls that we provide.

00:09:51.940 --> 00:09:54.780
Now, to change the size of a control,
it's really straightforward.

00:09:54.780 --> 00:09:57.320
You can use the set control data API.

00:09:57.320 --> 00:09:59.720
I mentioned it this session,
the previous session.

00:09:59.720 --> 00:10:01.010
You pass it a control.

00:10:01.020 --> 00:10:03.300
You pass it the tag for the
data type you want to change.

00:10:03.300 --> 00:10:05.210
In this case,
you say change the control size,

00:10:05.390 --> 00:10:07.630
K control size tag,
and then you pass the size

00:10:07.630 --> 00:10:08.820
that you're interested in.

00:10:08.860 --> 00:10:12.060
K control size, normal, small, large,
or auto.

00:10:12.060 --> 00:10:16.030
Not all controls support all sizes,
so be ready to handle errors.

00:10:16.050 --> 00:10:18.650
I believe we have comments
in the header which say which

00:10:18.680 --> 00:10:20.360
controls support which sizes.

00:10:20.360 --> 00:10:22.960
But in general,
if you're good about handling errors,

00:10:22.960 --> 00:10:24.220
you'll be just fine.

00:10:24.220 --> 00:10:26.660
The other important thing to
note is right now these are

00:10:26.660 --> 00:10:27.930
only available on Mac OS X.

00:10:28.150 --> 00:10:31.860
CarbonLib 1.3 does not support
any of the control sizing stuff.

00:10:31.860 --> 00:10:34.500
We're investigating what we would need
to do to bring that into CarbonLib,

00:10:34.500 --> 00:10:37.040
but I can't make any promises about it.

00:10:38.430 --> 00:10:42.080
This got brought up last
session in the Q&As,

00:10:42.350 --> 00:10:44.300
but it bears repeating.

00:10:44.300 --> 00:10:46.700
The Control Manager supports the
notion of an embedding hierarchy,

00:10:46.700 --> 00:10:48.760
and we've done that since Mac OS 8.0.

00:10:48.760 --> 00:10:50.860
It's been optional on the
traditional operating system,

00:10:50.860 --> 00:10:54.960
including CarbonLib, but now on Mac OS X,
embedding is always on.

00:10:55.440 --> 00:10:58.970
And this has certain interaction

00:10:59.220 --> 00:11:01.600
side effects for your application.

00:11:01.600 --> 00:11:04.250
Essentially,
hit testing and draw order might

00:11:04.250 --> 00:11:08.350
not be exactly what you'd expect on
Mac OS X if your application does not

00:11:08.350 --> 00:11:10.880
use the embedding hierarchy on Mac OS 9.

00:11:10.960 --> 00:11:14.240
So, my suggestion to everyone
is always explicitly request

00:11:14.240 --> 00:11:15.840
the embedding hierarchy.

00:11:15.920 --> 00:11:18.690
You do it on 9, just so you can get the
embedding hierarchy,

00:11:18.780 --> 00:11:21.300
and you do it on 10,
it's effectively a no-op because the

00:11:21.300 --> 00:11:24.440
embedding hierarchy's already there,
and it's still totally legal to do that.

00:11:24.440 --> 00:11:27.200
But make sure you explicitly
request the embedding hierarchy

00:11:27.200 --> 00:11:29.340
and run your app on 9,
and get your behavior

00:11:29.340 --> 00:11:31.600
straightened out on there,
and you should be able to

00:11:31.600 --> 00:11:36.690
take that app then and put it
on 10 and see good behavior.

00:11:36.840 --> 00:11:40.100
Create root control is generally
the way you turn on embedding.

00:11:40.220 --> 00:11:43.600
Creating a root control for a window
switches on the embedding hierarchy.

00:11:43.750 --> 00:11:47.600
That's not the only way you necessarily
can turn on the embedding hierarchy.

00:11:47.700 --> 00:11:53.300
If you use the dialogue manager,
you can specify a DLGX resource,

00:11:53.300 --> 00:11:56.920
which corresponds to your DLOG resource,
and there is a feature bit in

00:11:56.920 --> 00:11:59.460
that DLGX resource that says,
"Please turn on the embedding

00:11:59.460 --> 00:12:03.250
hierarchy for me." You can do the
same thing with alert resources.

00:12:03.390 --> 00:12:07.900
Now, the reason we turned this on
automatically on Mac OS X is that

00:12:08.140 --> 00:12:12.800
it not only allows us to really
simplify the Mac OS X code base,

00:12:12.880 --> 00:12:15.400
and we basically had divergent
code on the traditional OS.

00:12:15.400 --> 00:12:18.900
We got rid of one whole side of the
divergent code and divergent behaviors,

00:12:19.010 --> 00:12:21.390
so that makes our maintenance
life a lot easier.

00:12:21.520 --> 00:12:25.000
But it also allows us to add a
whole bunch of future enhancements.

00:12:25.110 --> 00:12:27.300
Yesterday at the
Windows and menu session,

00:12:27.300 --> 00:12:31.100
we talked about how transparent
sheets for Carbon were going to

00:12:31.100 --> 00:12:32.590
be coming in a future release.

00:12:32.600 --> 00:12:35.070
We wouldn't even be able to
do that unless the control

00:12:35.080 --> 00:12:36.290
embedding was mandatory.

00:12:36.300 --> 00:12:39.930
So future control management
enhancements are also going to be sort

00:12:39.930 --> 00:12:42.700
of dependent on the embedding hierarchy.

00:12:44.070 --> 00:12:48.600
Now, Carbon removed access to
a Windows control list.

00:12:48.680 --> 00:12:53.160
The way controls were maintained in a
window on traditional OS was that there

00:12:53.160 --> 00:12:57.000
was literally just a link list that hung
off a window where we kept each control.

00:12:57.000 --> 00:13:01.340
We eliminated that for Carbon in
favor of people just embedding the

00:13:01.430 --> 00:13:04.000
controls where they wanted them to.

00:13:04.000 --> 00:13:07.000
Unfortunately, we heard a lot of feedback
from developers when they said,

00:13:07.000 --> 00:13:08.000
"You know what?

00:13:08.000 --> 00:13:10.000
We need the control list because
we're doing cool things with it.

00:13:10.000 --> 00:13:12.930
We have an interface that we
literally want to move on the

00:13:12.930 --> 00:13:15.990
fly from one window to another,
maybe via drag & drop.

00:13:16.000 --> 00:13:19.600
It's got great performance
impact for us if you make us

00:13:19.690 --> 00:13:24.170
create both hierarchies at once,
as we destroy one window

00:13:24.170 --> 00:13:25.980
and put up another.

00:13:26.010 --> 00:13:28.770
We'd really like a way to move
a control between windows,

00:13:28.770 --> 00:13:31.740
so we gave it to you." Essentially,
we don't allow you to hack

00:13:31.740 --> 00:13:35.000
the control list anymore,
but we allow an existing API,

00:13:35.000 --> 00:13:38.000
the Embed Control API,
to take a control out of one window

00:13:38.000 --> 00:13:38.910
and just embed it someplace else.

00:13:39.000 --> 00:13:42.040
The only gotcha with respect
to all this is that you cannot

00:13:42.040 --> 00:13:44.000
actually move the root control.

00:13:44.000 --> 00:13:46.450
The root control,
once it's associated with a window,

00:13:46.450 --> 00:13:48.000
is always stuck to that window.

00:13:48.000 --> 00:13:51.770
But you can go ahead and move any
sub-controls you're interested in.

00:13:53.510 --> 00:13:57.090
We've mentioned this
a ton of times again.

00:13:57.200 --> 00:14:00.600
Carbon events permeate the toolbox.

00:14:00.740 --> 00:14:08.190
The controls themselves are
actually implemented in terms

00:14:08.190 --> 00:14:11.630
of Carbon events right now.

00:14:11.630 --> 00:14:11.630
In fact, the

00:14:12.930 --> 00:14:15.370
The messaging model for
control definitions is

00:14:15.370 --> 00:14:17.400
inherently Carbon event based.

00:14:17.560 --> 00:14:21.330
Now, we obviously still support
message based defprocs,

00:14:21.470 --> 00:14:24.530
but we do this through a compatibility
layer where we intercept a Carbon event

00:14:24.600 --> 00:14:26.340
coming towards a particular defproc.

00:14:26.370 --> 00:14:28.890
We see it doesn't handle it,
we turn it into a control message

00:14:28.890 --> 00:14:30.390
and route it off to the defproc.

00:14:30.400 --> 00:14:34.520
But, we don't necessarily handle
direct messaging in the old

00:14:34.720 --> 00:14:37.090
school way to the system controls.

00:14:37.090 --> 00:14:40.300
What that means is if you have any
application code which is calling

00:14:40.300 --> 00:14:43.740
send control message and trying to
make the system controls do things,

00:14:43.750 --> 00:14:46.140
they probably won't work on Mac OS X.

00:14:46.160 --> 00:14:49.540
You might get lucky for the short term,
because I know we still support

00:14:49.590 --> 00:14:52.400
a few messages this way,
but ultimately we plan on removing

00:14:52.440 --> 00:14:56.390
all support for send control message
to the system control definitions.

00:14:56.400 --> 00:14:58.600
Now, generally speaking,
you shouldn't even need

00:14:58.600 --> 00:14:59.990
send control message anyway.

00:15:00.000 --> 00:15:02.940
We have high level control manager
APIs that let you do things

00:15:02.940 --> 00:15:06.000
like drawing and hit testing
and whatever at a very high level.

00:15:06.160 --> 00:15:09.170
So, you could probably just eliminate
your use of send control message

00:15:09.170 --> 00:15:10.560
in favor of these other APIs.

00:15:10.560 --> 00:15:14.080
Now, if you have custom controls,
you may not be planning on revving them

00:15:14.080 --> 00:15:16.980
to support Carbon events anytime soon,
and you're using send

00:15:16.990 --> 00:15:18.770
control message with them,
obviously, now.

00:15:18.960 --> 00:15:20.320
You can continue to do so.

00:15:20.400 --> 00:15:22.740
We're not going to eliminate
the send control message API.

00:15:22.830 --> 00:15:25.180
We're just going to prevent
it from working with the

00:15:25.180 --> 00:15:26.800
system control definitions.

00:15:26.800 --> 00:15:29.910
But your custom CDEFs
will still work just fine.

00:15:31.450 --> 00:15:34.160
So I want to go into a few of
the future enhancements we're

00:15:34.160 --> 00:15:37.490
adding to the control manager.

00:15:37.580 --> 00:15:40.800
For performance reasons,
drawing with Quick Draw right now

00:15:40.800 --> 00:15:44.450
in the toolbox is a little bit slow,
because ultimately when we

00:15:44.450 --> 00:15:47.180
render a particular widget,
we're going to draw with quarts.

00:15:47.180 --> 00:15:51.100
And drawing with quarts means we need to
build the proper quarts port equivalent,

00:15:51.100 --> 00:15:52.770
which is a CG context ref.

00:15:52.790 --> 00:15:57.480
Building one of these is a little time
consuming and a little memory intensive.

00:15:57.480 --> 00:16:00.440
And ideally, what we'd like to do
for a given draw cycle,

00:16:00.440 --> 00:16:04.220
we would like to just create one context
and pass it to all the controls when

00:16:04.220 --> 00:16:08.210
they draw such that each control now no
longer needs to create its own context.

00:16:08.320 --> 00:16:11.780
This will save us a lot on
time and memory overhead.

00:16:12.090 --> 00:16:16.480
Drawing with Quartz will also allow
you to get around one major missing

00:16:16.480 --> 00:16:18.230
feature in the Appearance Manager.

00:16:18.400 --> 00:16:20.290
Right now,
the Appearance Manager does not let

00:16:20.290 --> 00:16:22.000
you draw pulsing default buttons.

00:16:22.000 --> 00:16:25.000
There's no way to do it via the APIs.

00:16:25.190 --> 00:16:31.600
Ultimately,
when we allow drawing through Quartz,

00:16:31.600 --> 00:16:32.790
you will be able to draw pulsing default
buttons through the Appearance Manager.

00:16:35.340 --> 00:16:39.200
Now yesterday we gave you a little taste
of what control drawing modes were.

00:16:39.900 --> 00:16:42.360
Essentially,
we want to build some functionality

00:16:42.360 --> 00:16:46.200
into the control manager that makes
it a lot more reasonable to work with.

00:16:46.200 --> 00:16:48.230
Right now when you call
a control manager API,

00:16:48.340 --> 00:16:51.200
you don't necessarily know
whether or not it's going to draw.

00:16:51.200 --> 00:16:53.190
If the control is visible,
it draws for some APIs.

00:16:53.300 --> 00:16:55.100
And on Mac OS X,
you notice that it draws if

00:16:55.100 --> 00:16:58.160
you call set control bounds,
but on CarbonLib it doesn't draw.

00:16:58.340 --> 00:17:00.960
And there's all sorts of
weird little nuances like that

00:17:01.120 --> 00:17:03.200
that we've had historically.

00:17:03.410 --> 00:17:07.010
And we want to offer a way that
lets you have more explicit control

00:17:07.010 --> 00:17:09.190
of exactly when a control draws.

00:17:09.290 --> 00:17:13.190
In fact, we want to get to a point where
controls don't really draw by default.

00:17:13.320 --> 00:17:16.290
You can go configure a control
five times with five control

00:17:16.410 --> 00:17:20.200
manager APIs and not draw until
you've done all that configuration.

00:17:20.200 --> 00:17:22.890
And finally, at some later point,
the control manager

00:17:23.130 --> 00:17:25.180
should be able to say,
"Well, you know what?

00:17:25.180 --> 00:17:28.200
I know what controls are dirty,
so why don't I just go and redraw them?"

00:17:28.200 --> 00:17:31.200
And this was all done initially to
allow us to support transparent sheets.

00:17:31.200 --> 00:17:35.180
Which will be coming up in the future.

00:17:35.330 --> 00:17:37.200
But it gave us a whole bunch
of these cool side effects,

00:17:37.240 --> 00:17:39.480
and in the future we're going to
allow you to turn this stuff on

00:17:39.480 --> 00:17:42.200
for your Windows and get all kinds
of cool performance benefits.

00:17:44.430 --> 00:17:51.050
I'm going to switch gears a little
bit and start talking about the Doc.

00:17:51.050 --> 00:17:51.050
A lot of applications

00:17:51.680 --> 00:17:53.770
Need a new icon.

00:17:53.770 --> 00:17:56.410
Right now,
your icons are probably 32 by 32,

00:17:56.410 --> 00:17:57.970
and they look pretty miserable.

00:17:58.040 --> 00:18:00.300
And with the Dock being so
prominent in the interface,

00:18:00.300 --> 00:18:03.230
and the fact that the Dock
can display 128 by 128 icons,

00:18:03.270 --> 00:18:06.840
you need to spend a lot of time
making your Dock icon look great.

00:18:06.970 --> 00:18:10.460
But it may not be enough to just put
a great-looking icon in the Dock.

00:18:10.580 --> 00:18:13.460
Some applications need to
put status in the Dock.

00:18:13.560 --> 00:18:16.530
They need to--the best
example is Mail application.

00:18:16.610 --> 00:18:19.240
Mail puts a little marker in
the Dock that says how many

00:18:19.260 --> 00:18:20.820
messages you've got unread.

00:18:20.820 --> 00:18:23.480
It's a really cool feature,
but at the same time,

00:18:23.480 --> 00:18:24.470
you don't want to overdo it.

00:18:24.600 --> 00:18:27.170
You shouldn't just animate
your application icon or badge

00:18:27.260 --> 00:18:30.300
something on your application icon
just because the APIs are there.

00:18:30.440 --> 00:18:35.300
You need to not be intrusive into
the user's visual space unless it's

00:18:35.340 --> 00:18:36.590
going to be meaningful to them.

00:18:36.600 --> 00:18:39.230
If you find an instance in your
application where animating

00:18:39.230 --> 00:18:41.260
your icon would be useful,
there's a number of

00:18:41.260 --> 00:18:42.680
different ways you can do it.

00:18:42.800 --> 00:18:46.400
Probably the most straightforward way,
if you're used to doing this,

00:18:46.400 --> 00:18:46.440
is to use the Dock application.

00:18:46.440 --> 00:18:50.410
The most common way to do programming for
traditional Mac OS is to use Quick Draw.

00:18:50.440 --> 00:18:53.030
And the way we allow this is through
the use of the begin and end QD context

00:18:53.140 --> 00:18:54.400
for application Dock tile APIs.

00:18:54.440 --> 00:18:58.630
These APIs give you a color graph
pointer that you can draw into,

00:18:58.630 --> 00:19:01.630
and when you call end,
it ends up putting the

00:19:01.650 --> 00:19:03.430
image into the Dock for you.

00:19:03.440 --> 00:19:06.000
Now, Quick Draw, as you know,
does not support transparently

00:19:06.000 --> 00:19:07.440
in the alpha channel properly.

00:19:07.440 --> 00:19:13.350
And if you want your application
icon to have transparency,

00:19:13.350 --> 00:19:16.340
you need to draw with quartz,
and you do that with a

00:19:16.340 --> 00:19:16.340
similarly named begin and end C.

00:19:16.340 --> 00:19:18.330
And then you can use CG context
for application Dock tile.

00:19:18.360 --> 00:19:22.210
You call those, you draw with quartz,
you end the context,

00:19:22.210 --> 00:19:23.880
it draws to the screen.

00:19:24.060 --> 00:19:26.850
You can also do badging,
which is what Mail does.

00:19:27.090 --> 00:19:29.900
And there's only, unfortunately,
a Quartz way of doing that.

00:19:30.050 --> 00:19:31.920
But in order for badging
to work properly,

00:19:31.940 --> 00:19:35.000
it needs to use alpha,
so that's why it's Quartz only.

00:19:35.000 --> 00:19:37.050
We've got a couple APIs for that as well.

00:19:37.150 --> 00:19:40.150
Now, all of these APIs have pretty good
documentation in the header itself.

00:19:40.400 --> 00:19:41.940
They're in MacApplication.h.

00:19:41.940 --> 00:19:45.470
We show you some ways you use them,
some of the pitfalls in there,

00:19:45.510 --> 00:19:47.480
so I suggest you check those out.

00:19:48.550 --> 00:19:50.850
Your minimized windows
also show up in the doc,

00:19:50.850 --> 00:19:55.430
and therefore you might want to change
the icon that's used to represent them.

00:19:55.850 --> 00:19:58.260
When a window is first
minimized and put into the Dock,

00:19:58.430 --> 00:20:02.360
the Window Manager automatically
takes a snapshot of the entire window,

00:20:02.400 --> 00:20:03.940
its structure, its content,
and everything,

00:20:03.940 --> 00:20:07.400
scales it down to 128x128,
and puts that in the Dock.

00:20:07.560 --> 00:20:10.580
If your application has
fairly simple needs,

00:20:10.580 --> 00:20:15.270
and you just want to update the image
in the Dock based on your window's new

00:20:15.270 --> 00:20:18.740
image contents while it's minimized,
you can do that with the

00:20:18.790 --> 00:20:20.800
Update Collapse Window Dock tile.

00:20:20.800 --> 00:20:22.570
If your application
has a minimized window,

00:20:22.570 --> 00:20:24.430
and it's busy processing,
and you put some more

00:20:24.450 --> 00:20:26.830
status in your window,
or you change some image slightly,

00:20:26.880 --> 00:20:28.970
and you want it to be
reflected in the Dock,

00:20:29.090 --> 00:20:31.200
just call Update Collapse
Window Dock tile on your window,

00:20:31.200 --> 00:20:34.610
and the Window Manager will just do
the right thing for you automatically.

00:20:34.680 --> 00:20:37.720
If you need more custom control,
we offer APIs for those as well.

00:20:37.800 --> 00:20:41.100
Create and release QD context
for collapsed window doc tile.

00:20:41.200 --> 00:20:44.730
And these APIs are all
documented in MacWindows.h.

00:20:44.730 --> 00:20:47.650
And we're working with the
documentation people to get other

00:20:47.650 --> 00:20:49.000
forms of documentation available.

00:20:49.060 --> 00:20:51.440
But right now, I took a look at these
headers the other day,

00:20:51.520 --> 00:20:53.100
and they're really, really good.

00:20:53.100 --> 00:20:55.780
They explain a lot of
what you need to know.

00:20:55.950 --> 00:20:58.730
Now to give you a more
concrete example of all this,

00:20:58.730 --> 00:20:59.900
I would like to bring up David McLeod.

00:20:59.900 --> 00:21:03.000
He can show you some of the details.

00:21:03.000 --> 00:21:03.000
David?

00:21:05.000 --> 00:21:06.990
Thanks.

00:21:07.000 --> 00:21:08.790
Morning.

00:21:09.010 --> 00:21:13.310
I wrote a small demo application,
if you could bring up-- right.

00:21:13.680 --> 00:21:20.250
This session builds on the
material presented in Session 119,

00:21:20.250 --> 00:21:20.250
providing details on Dock icon animation,
DataBrowser, Help Tags,

00:21:20.250 --> 00:21:20.250
improved direct manipulation
of data with Drag & Drop,

00:21:20.250 --> 00:21:20.250
and much more.

00:21:20.250 --> 00:21:20.250
Learn how to make your
application "go the extra mile."

00:21:21.200 --> 00:21:23.800
That's a little demo
application called Tyler.

00:21:23.800 --> 00:21:26.950
And keep an eye on this guy down here.

00:21:26.960 --> 00:21:29.300
That's the guy that's
going to get animated.

00:21:29.340 --> 00:21:34.380
First,
I'm going to draw on it with Quick Draw.

00:21:35.700 --> 00:21:37.160
I'm not a graphic artist or anything.

00:21:37.160 --> 00:21:40.580
I didn't have anybody
make fancy art for me.

00:21:40.760 --> 00:21:44.080
You can see that I had to erase

00:21:44.670 --> 00:21:49.810
"I would have left behind the image,
otherwise I would have left

00:21:49.810 --> 00:21:53.810
behind some remnants of the other

00:21:54.000 --> 00:22:13.500
[Transcript missing]

00:22:14.330 --> 00:22:16.960
Next, I'll show Quartz.

00:22:16.970 --> 00:22:19.750
You can see it's the same drawing.

00:22:19.760 --> 00:22:22.800
If you can see really up close on it,
it's all anti-aliased and stuff,

00:22:22.800 --> 00:22:25.230
because Quartz is really nice.

00:22:25.250 --> 00:22:26.740
That way you get it all for free.

00:22:26.840 --> 00:22:28.970
There's also a transparency on here.

00:22:28.970 --> 00:22:32.210
You can't really see it unless
I drag a window behind it.

00:22:32.460 --> 00:22:35.530
You can see that that,
all that drawing is transparent.

00:22:35.580 --> 00:22:38.150
You can see right through it,
see the window up there.

00:22:40.680 --> 00:22:44.960
The next thing I'll show you here is
I'm going to add a tile to the badge.

00:22:45.020 --> 00:22:47.600
I'm going to add a badge to the tile,
excuse me.

00:22:47.690 --> 00:22:51.590
It's just my WWDC badge.

00:22:51.680 --> 00:22:55.420
Again, I think that might break
some HI guidelines.

00:22:55.650 --> 00:22:57.600
I just made it myself.

00:22:57.610 --> 00:22:58.830
It's fairly simple.

00:22:58.830 --> 00:23:01.860
You just make an image with
an alpha channel and you blast

00:23:01.860 --> 00:23:03.500
it on there with an API call.

00:23:03.590 --> 00:23:07.910
One gotcha here though is that you need
to clean the tile before you draw on it.

00:23:08.100 --> 00:23:12.530
Because if you don't, the badge will just
overcomposite on top of itself.

00:23:12.590 --> 00:23:15.450
I'll just do that a few times and draw.

00:23:15.590 --> 00:23:20.100
You can see that its shadow has
just overcomposited over and over.

00:23:20.100 --> 00:23:22.640
It's not much of a shadow anymore.

00:23:22.640 --> 00:23:25.780
It's kind of a black blob, which is ugly.

00:23:26.670 --> 00:23:30.880
The second last thing I'll
show you is Restore Tile.

00:23:31.150 --> 00:23:38.950
Just bring it back to what the
application sets the icon in there.

00:23:41.900 --> 00:23:45.710
The last thing that I'm going to show
you is something Guy talked about with

00:23:45.710 --> 00:23:48.900
the collapsed window tile animation.

00:23:48.900 --> 00:23:51.900
So I have a little demo window here.

00:23:51.900 --> 00:23:53.900
Got a beautiful picture of someone.

00:23:53.900 --> 00:23:55.900
It's a little dark though.

00:23:56.000 --> 00:24:00.490
So we have some processing that
can happen to it to lighten it

00:24:00.490 --> 00:24:02.890
so we can see his pretty mug.

00:24:04.340 --> 00:24:08.370
We can actually minimize
this into the doc,

00:24:08.370 --> 00:24:11.280
and you can see that the tile
continues to update itself,

00:24:11.300 --> 00:24:15.300
so you can see how far
along the processing is.

00:24:15.300 --> 00:24:20.490
Let's do it one more time, just for fun.

00:24:20.490 --> 00:24:20.490
Let's do a whole bunch of them.

00:24:22.610 --> 00:24:24.390
Good thing my head's not really that big.

00:24:24.410 --> 00:24:27.200
Yay.

00:24:27.200 --> 00:24:29.210
He's so pretty.

00:24:31.150 --> 00:24:32.860
So you can see they're
all down there animating.

00:24:32.860 --> 00:24:35.600
And you can also see that there's a whole
bunch of things down there animating,

00:24:35.600 --> 00:24:36.870
and it's a little ugly.

00:24:36.940 --> 00:24:39.280
So don't get crazy doing the animating.

00:24:39.280 --> 00:24:42.100
It's just fun sometimes.

00:24:42.790 --> 00:24:44.990
Next, I'll just show you some
of the code I used.

00:24:45.000 --> 00:24:48.340
It was all very simple
and straightforward to do.

00:24:48.500 --> 00:24:53.450
First,
you saw me do the QuickDraw animation.

00:24:54.620 --> 00:24:59.420
You call in and you get a QD Context
for the application Doctile.

00:24:59.430 --> 00:25:03.360
You keep a hold of the port and
you get to use it for a while.

00:25:04.240 --> 00:25:06.490
I happen to do some erasing here.

00:25:06.490 --> 00:25:07.780
You really do have to erase.

00:25:07.870 --> 00:25:12.260
You can get the same overcompositing
problems with Quartz.

00:25:12.260 --> 00:25:14.200
And if you don't erase
with the Quick Draw,

00:25:14.200 --> 00:25:19.940
you'll end up with remnants of your
previous tile drawing on there.

00:25:20.460 --> 00:25:22.940
I do a little bit of
drawing using QuickDraw.

00:25:22.940 --> 00:25:26.090
Everybody knows how to do that,
probably better than I do.

00:25:26.670 --> 00:25:28.240
And here's a gotcha.

00:25:28.470 --> 00:25:32.410
When you request a context,
you always have to flush the context

00:25:32.580 --> 00:25:39.460
before you finish with it because
the tile won't update until you get

00:25:39.460 --> 00:25:41.200
some other update queue later on.

00:25:41.280 --> 00:25:42.580
So don't forget to flush.

00:25:42.580 --> 00:25:44.740
It's really important.

00:25:44.790 --> 00:25:47.430
And lastly,
you've got to tell the doc that you're

00:25:47.430 --> 00:25:52.060
finished with that context and you're
not going to be drawing in there anymore.

00:25:52.120 --> 00:25:55.710
That's the quick draw way,
and you saw how it made everything opaque

00:25:55.710 --> 00:25:57.830
and it just killed the transparency.

00:25:57.980 --> 00:25:59.870
That's just no fun.

00:26:00.420 --> 00:26:04.020
Very similar code to do the Quartz.

00:26:04.030 --> 00:26:08.200
I begin the CG context right here.

00:26:08.200 --> 00:26:09.360
I clear it out.

00:26:09.370 --> 00:26:13.000
This particular clear though,

00:26:13.640 --> 00:26:16.080
"maintains the transparency."
So I start out with something

00:26:16.120 --> 00:26:19.090
completely transparent,
and I can start drawing on that.

00:26:19.170 --> 00:26:24.040
I do the happy face drawing again,
and I happen to do a little bit

00:26:24.040 --> 00:26:27.420
of transparent yellow in there,
and that's how you can see through it.

00:26:27.750 --> 00:26:30.860
"CG Contexts are just like the
QD Contexts you get in the first one.

00:26:31.060 --> 00:26:35.700
Don't forget to flush,
or else it won't update properly."

00:26:35.720 --> 00:26:40.620
"Can't forget to flush." "And lastly,
you gotta tell it, 'Hey,

00:26:40.620 --> 00:26:43.310
I'm finished with the context.'"

00:26:44.930 --> 00:26:48.840
The badge is a little
bit more complicated,

00:26:48.840 --> 00:26:51.330
and you require a CG image.

00:26:51.360 --> 00:26:56.120
You say, "I have a CG image,
and I'm going to be

00:26:56.250 --> 00:26:58.360
blasting it onto the tile.

00:26:58.650 --> 00:27:02.140
I'm going to blit it on there."

00:27:02.620 --> 00:27:04.840
There's a bit of a pitfall,
like I mentioned earlier,

00:27:04.840 --> 00:27:07.860
where I showed you where the
badge overcomposited on itself

00:27:07.920 --> 00:27:09.700
and its shadow was darkened.

00:27:09.700 --> 00:27:14.290
So I actually restore the
tile just before I draw on it,

00:27:14.410 --> 00:27:17.980
so I have a nice clean
tile to start with.

00:27:18.610 --> 00:27:23.020
I make some PixMaps,
and there's a really nice call available

00:27:23.440 --> 00:27:27.820
called "Create CG Image from PixMaps."
So you can take a PixMap that is an

00:27:27.820 --> 00:27:31.600
image that you want to put on there,
another PixMap that is the

00:27:31.700 --> 00:27:33.500
alpha mask that you want to use.

00:27:33.520 --> 00:27:35.500
It makes a nice CG image for you to use.

00:27:35.500 --> 00:27:37.370
Very convenient.

00:27:39.400 --> 00:27:42.620
And lastly, just want to overlay that
image on top of the tile.

00:27:42.620 --> 00:27:44.640
It's really straightforward.

00:27:45.360 --> 00:27:48.130
The next part is restoring the Doctile.

00:27:48.170 --> 00:27:50.560
It's very complicated,
so Guy wanted me to go through

00:27:50.560 --> 00:27:53.190
the code line by line for you.

00:27:53.550 --> 00:27:55.240
Here it is here, the one line.

00:27:55.360 --> 00:27:57.100
Restore application Dock tile image.

00:27:57.100 --> 00:27:58.900
Very straightforward, no parameters.

00:27:58.900 --> 00:28:02.550
I think we can all manage to cut and
paste that one out of the header.

00:28:04.080 --> 00:28:10.030
And the last one was the
collapsed Dock tile animation.

00:28:10.030 --> 00:28:10.920
It was very straightforward.

00:28:10.920 --> 00:28:15.730
All I did is I updated the window so that
you could see the processing happening.

00:28:15.800 --> 00:28:18.960
And you just have to tell,
you just have to call the

00:28:18.990 --> 00:28:23.210
API "update collapsed window
Dock tile" with a window pointer,

00:28:23.210 --> 00:28:24.240
and it does all the work for you.

00:28:24.240 --> 00:28:27.560
It just takes the image of the
window and sticks it into the tile.

00:28:27.630 --> 00:28:30.500
So I do some image
processing before and after,

00:28:30.540 --> 00:28:33.750
and just make that one call and
it does the animation for you.

00:28:33.840 --> 00:28:36.400
The only gotcha there is you want
to make sure you update it one

00:28:36.470 --> 00:28:38.160
final time when you're finished.

00:28:38.160 --> 00:28:41.520
So there's some tricky code hiding up
here where I update it one last time.

00:28:41.520 --> 00:28:42.930
But that's about it.

00:28:42.930 --> 00:28:45.590
It was really easy to do tile animation.

00:28:45.730 --> 00:28:46.990
Oh, one last thing.

00:28:47.110 --> 00:28:49.640
This code is going to
be up on the website.

00:28:49.790 --> 00:28:52.670
It's just going to be sample source
code for everybody to try out.

00:28:52.700 --> 00:28:54.700
Thanks, David.

00:28:58.640 --> 00:29:00.270
So that was cool.

00:29:00.320 --> 00:29:02.230
One final note about the Doc stuff.

00:29:02.280 --> 00:29:04.800
Again, I know you've probably heard
this about a dozen times.

00:29:04.920 --> 00:29:07.570
Just because you can do this
doesn't mean you should do this.

00:29:07.670 --> 00:29:11.370
Make sure that your application
and window icon animation is subtle

00:29:11.370 --> 00:29:13.560
and use it only when necessary.

00:29:13.590 --> 00:29:16.410
The last thing I want to see
personally is about ten applications

00:29:16.440 --> 00:29:19.600
each spinning some little random
animation just because they can.

00:29:19.600 --> 00:29:23.970
Not only is it visually distracting,
but it's just going to wreck

00:29:23.970 --> 00:29:25.730
performance for the machine.

00:29:25.730 --> 00:29:25.730
So do it only when it's necessary.

00:29:26.300 --> 00:30:56.200
[Transcript missing]

00:30:57.320 --> 00:31:01.490
All right, so switching gears back
to the Control Manager.

00:31:01.550 --> 00:31:03.470
Control Manager supports
a lot of Carbon Events.

00:31:03.570 --> 00:31:05.840
They're all documented in CarbonEvents.h.

00:31:05.890 --> 00:31:08.290
We tell you what they're used for,
we tell you when they're sent,

00:31:08.460 --> 00:31:14.410
we tell you what parameters
come along with them,

00:31:14.410 --> 00:31:14.410
we tell you what the responsibility
of someone who handles them is.

00:31:14.820 --> 00:31:18.440
This is a great way to
write custom def procs now.

00:31:18.480 --> 00:31:20.200
This is only available
on Mac OS X right now,

00:31:20.200 --> 00:31:23.160
but we're looking at making
Carbon event def procs available

00:31:23.160 --> 00:31:24.700
in a future version of CarbonLib.

00:31:24.700 --> 00:31:28.570
The best part about
Control Carbon Events is it also

00:31:28.570 --> 00:31:33.240
allows application clients of controls,
whether they be custom controls

00:31:33.240 --> 00:31:35.700
that you wrote or system
controls that Apple wrote,

00:31:35.700 --> 00:31:40.240
it allows those application clients to
sort of override or augment the behavior

00:31:40.250 --> 00:31:42.590
of a particular control definition.

00:31:42.910 --> 00:31:45.330
All of the Control Carbon Events,
except for two that I'm

00:31:45.330 --> 00:31:48.800
going to be mentioning today,
are of the KEVENT class control.

00:31:48.860 --> 00:31:54.700
Just take a look in carbonevents.h and
it'll tell you all the details there.

00:31:54.940 --> 00:31:57.840
Let's say you want to write a
Carbon event based control definition.

00:31:57.870 --> 00:31:58.800
It's your first time you're doing this.

00:31:58.800 --> 00:32:01.190
I'm going to take you
through step by step.

00:32:01.440 --> 00:32:04.490
In order to do a
Carbon Event-based Toolbox object,

00:32:04.590 --> 00:32:07.290
you need to register your
Toolbox object class.

00:32:07.300 --> 00:32:10.590
And a Toolbox object class is
just an opaque wrapper around

00:32:10.590 --> 00:32:11.660
the notion of a def proc.

00:32:11.720 --> 00:32:13.770
You can think of it that way.

00:32:13.940 --> 00:32:17.550
The way you create an object class is
by calling RegisterToolboxObjectClass.

00:32:17.630 --> 00:32:20.100
You give it a name,
and you give it the Carbon event

00:32:20.160 --> 00:32:25.290
handler for that defproc,
and you give it the list of events

00:32:25.290 --> 00:32:25.290
that you're interested in handling.

00:32:25.760 --> 00:32:29.360
The API hands you back a
Toolbox Object Class Ref.

00:32:29.380 --> 00:32:33.070
Now, when you call createCustomControl,
you can pass in that

00:32:33.070 --> 00:32:36.490
Toolbox Object Class Ref,
actually pass it in as part of

00:32:36.490 --> 00:32:38.600
a control-def-spec structure.

00:32:38.600 --> 00:32:40.480
But you pass that in
to createCustomControl,

00:32:40.490 --> 00:32:42.590
and therefore the control manager says,
"Oh, you know what?

00:32:42.590 --> 00:32:44.700
I know what defproc to create now.

00:32:44.700 --> 00:32:46.390
I'm going to go create it."

00:32:46.550 --> 00:32:49.810
When you call Create Custom Control,
you can also pass in an initialization

00:32:49.810 --> 00:32:52.660
collection with all sorts of
initialization information that

00:32:52.660 --> 00:32:53.990
your control definition might want.

00:32:54.130 --> 00:32:57.500
Totally free form, totally up to you what
you want to put in there.

00:32:57.550 --> 00:33:00.190
The Control Manager does support
some default things in this

00:33:00.190 --> 00:33:01.680
initialization collection.

00:33:01.740 --> 00:33:04.500
It will look for things
like a starting value,

00:33:04.500 --> 00:33:06.840
a starting minimum,
whether or not the control is visible,

00:33:06.900 --> 00:33:07.780
things like that.

00:33:07.860 --> 00:33:10.880
This is all documented
in the header as well.

00:33:11.530 --> 00:33:14.590
Let's say, however,
that you do all of your

00:33:14.590 --> 00:33:18.500
control creation either via
New Control or Get New Control.

00:33:18.590 --> 00:33:23.110
Or perhaps you want to write a shared
library version of a control that needs

00:33:23.110 --> 00:33:26.560
to be used by third-party applications,
and all they use are

00:33:26.560 --> 00:33:28.500
New Control and Get New Control.

00:33:28.500 --> 00:33:31.800
In order to support
New Control and Get New Control,

00:33:31.880 --> 00:33:35.500
you need to use the
Register Control Definition API.

00:33:35.500 --> 00:33:41.500
I should probably go into a little bit of
background to make this make more sense.

00:33:41.500 --> 00:33:45.590
When you call Create Custom Control,
you're essentially saying,

00:33:45.590 --> 00:33:48.500
"Create this control
with this entry point.

00:33:48.500 --> 00:33:52.910
I already know what the entry point is."
New Control and Get New Control operate

00:33:52.910 --> 00:33:54.490
off this PROC ID model.

00:33:54.490 --> 00:33:57.020
If you've done any toolbox
programming in the past,

00:33:57.050 --> 00:33:58.450
you know what a PROC ID is.

00:33:58.610 --> 00:34:01.160
Essentially,
it's just sort of a mangled resource

00:34:01.160 --> 00:34:04.320
ID of where a defproc would have
lived on the traditional OS.

00:34:04.500 --> 00:34:07.820
And what Register Control Definition
lets you do is it lets you take

00:34:07.940 --> 00:34:11.500
a proc pointer-based defproc,
whether it's a toolbox object type,

00:34:11.510 --> 00:34:13.910
or whether it's just a raw proc pointer,
and say,

00:34:13.930 --> 00:34:17.640
"Associate it with this sort of virtual
resource ID." So now your clients can

00:34:17.640 --> 00:34:21.990
call New Control and Get New Control and
actually instantiate versions of

00:34:22.010 --> 00:34:24.500
your Carbon event-based defproc.

00:34:27.680 --> 00:34:29.940
There's a couple basic
Carbon Events that just about every

00:34:29.940 --> 00:34:31.440
DefProc is going to want to support.

00:34:31.600 --> 00:34:34.600
And of course, those have to do with
initialization and disposal.

00:34:34.600 --> 00:34:38.780
We send two different Carbon Events:
KEventControlInitialize.

00:34:38.790 --> 00:34:41.600
This is the one where you initialize.

00:34:41.600 --> 00:34:45.230
It, in the Carbon Event,
has the initialization collection that

00:34:45.230 --> 00:34:47.590
you passed in to create Custom Control.

00:34:47.600 --> 00:34:49.930
So you can extract that out,
start digging through there,

00:34:49.930 --> 00:34:52.590
looking for your bits of information
that are important to you.

00:34:52.600 --> 00:34:58.600
Your only responsibility for handling of
KEventControlInitialize is to make sure

00:34:58.600 --> 00:35:03.600
you report your control's features back
out in the KEventParamsControlFeatures.

00:35:03.600 --> 00:35:06.590
You do this so the control manager
knows what kind of things you support,

00:35:06.600 --> 00:35:09.600
like whether or not you're an
embedder or various other things.

00:35:09.600 --> 00:35:12.490
And of course,
also while handling initialization,

00:35:12.490 --> 00:35:15.400
you want to allocate any instance
data or do any prep work that your

00:35:15.400 --> 00:35:16.600
control definition might need to do.

00:35:16.600 --> 00:35:18.590
And you can imagine how the dispose work.

00:35:18.600 --> 00:35:21.580
You get the dispose event,
you dispose your stuff, and you're done.

00:35:21.580 --> 00:35:22.600
It's pretty easy, right?

00:35:24.880 --> 00:35:28.200
Now, if you want to be a
full-featured control definition,

00:35:28.200 --> 00:35:32.690
you want to allow your clients to make
use of certain Control Manager APIs.

00:35:32.830 --> 00:35:35.190
For instance,
if your clients want to determine what

00:35:35.340 --> 00:35:38.800
the proper size of your control is,
given its current settings, like,

00:35:38.800 --> 00:35:42.540
let's say an application
creates a static text control,

00:35:42.540 --> 00:35:45.640
and they start out creating one that's
just 10 pixels wide and 10 pixels long,

00:35:45.640 --> 00:35:47.950
just because it's the easiest
way for them to do it,

00:35:48.030 --> 00:35:49.410
and then they shove some text in there.

00:35:49.530 --> 00:35:50.750
Then they want to ask
the Control Manager,

00:35:50.760 --> 00:35:54.850
"Hey, how big should you really be to
display all your text?" You would use

00:35:54.850 --> 00:35:57.430
the GetControlBestRect API to do so.

00:35:57.490 --> 00:36:00.420
In order for a control definition
to report the right thing,

00:36:00.480 --> 00:36:03.520
it needs to listen to the
KEventControlGetOptimalBounds

00:36:03.520 --> 00:36:04.630
Carbon event.

00:36:04.660 --> 00:36:07.500
You handle this Carbon event by
examining your current state,

00:36:07.550 --> 00:36:10.490
figuring out how big you should be,
and you can even include

00:36:10.490 --> 00:36:13.430
a baseline offset.

00:36:13.480 --> 00:36:16.280
This baseline offset allows
your clients to do things like

00:36:16.280 --> 00:36:19.340
line up the text baselines for
two totally different widgets,

00:36:19.380 --> 00:36:23.200
make things look right according to
the Aqua Human Interface guidelines.

00:36:23.210 --> 00:36:25.640
Now, another API that you might
want to allow your clients to

00:36:25.640 --> 00:36:27.140
support is GetControlRegion.

00:36:27.160 --> 00:36:31.530
GetControlRegion allows your clients
to ask for any region relative to a

00:36:31.530 --> 00:36:34.800
particular part code of your control,
as well as a couple

00:36:34.930 --> 00:36:39.030
sort of meta part codes,
like the structure and the content part.

00:36:39.230 --> 00:36:41.560
When the application
calls GetControlRegion,

00:36:41.560 --> 00:36:45.200
we send your control definition,
a K-event control GetPartRegion.

00:36:45.200 --> 00:36:45.750
And well, guess what?

00:36:45.860 --> 00:36:48.260
It has the part in it that
the client is interested in,

00:36:48.310 --> 00:36:51.180
and it's your responsibility to
figure out what the region is,

00:36:51.180 --> 00:36:54.680
stuff that in the Carbon event,
say you handled it, and then you're done.

00:36:54.680 --> 00:36:57.680
You'll probably want to handle
the K-control structure metapart

00:36:57.790 --> 00:37:00.640
and the K-control content metapart
in addition to all the sort of

00:37:00.640 --> 00:37:02.130
unique parts of your control.

00:37:02.130 --> 00:37:04.720
And these will allow your
clients to determine the total

00:37:04.860 --> 00:37:06.930
draw area of your control,
as well as the sort of

00:37:06.930 --> 00:37:08.570
embeddable area of your control.

00:37:09.030 --> 00:37:12.340
And likewise,
get and set control data is a free-form

00:37:12.340 --> 00:37:16.330
way that clients can ask your control
for a certain piece of information.

00:37:16.410 --> 00:37:20.230
It basically enables you to
provide information to clients

00:37:20.490 --> 00:37:23.400
that the control manager does not
already have explicit support for.

00:37:23.400 --> 00:37:26.910
For instance,
the disclosure triangle--that's a bad

00:37:26.960 --> 00:37:29.400
example--of the static text control.

00:37:29.400 --> 00:37:33.400
The static text control supports a
one-line mode or a two-line mode.

00:37:33.400 --> 00:37:34.700
Well,
it doesn't really make sense to add a

00:37:34.700 --> 00:37:38.520
control manager API that's called "set
control one-line mode" with a Boolean,

00:37:38.520 --> 00:37:38.900
right?

00:37:38.940 --> 00:37:42.900
You can just use set control data to say,
"Hey, static text,

00:37:42.900 --> 00:37:45.400
I want you to be one-line or I want
you to be two-line." So this is a

00:37:45.430 --> 00:37:48.900
very powerful thing for configuration
of complex custom controls.

00:37:48.900 --> 00:37:50.900
And if you want to allow
your clients to use it,

00:37:50.900 --> 00:37:54.900
you listen to the k-event control
get set data Carbon events.

00:37:57.770 --> 00:38:00.270
Any control worth its salt
is probably going to draw,

00:38:00.420 --> 00:38:00.740
right?

00:38:00.810 --> 00:38:04.140
To do that, you listen to the kevent
control draw Carbon event.

00:38:04.210 --> 00:38:09.700
And normally for message-based CDEFs
you always draw in the current port.

00:38:09.840 --> 00:38:12.920
But for this Carbon event,
we actually pass you the port

00:38:13.050 --> 00:38:15.300
that we want you to draw into.

00:38:15.420 --> 00:38:18.190
And in fact,
we only optionally pass you this port.

00:38:18.260 --> 00:38:21.680
If you see a port inside the
kevent control draw Carbon event,

00:38:21.920 --> 00:38:22.920
draw into that port.

00:38:22.990 --> 00:38:26.100
If you don't,
go ahead and draw into the current port.

00:38:26.170 --> 00:38:28.840
And likewise,
if your control supports a sort of opaque

00:38:29.000 --> 00:38:32.210
background that you need sub-controls
to be rendered on top of properly,

00:38:32.210 --> 00:38:35.620
you want to listen to the kevent
control apply background and kevent

00:38:35.720 --> 00:38:37.820
control apply text color Carbon events.

00:38:37.830 --> 00:38:40.540
These give you a chance to set
up the background properly so

00:38:40.540 --> 00:38:42.940
your sub-controls can erase.

00:38:44.940 --> 00:38:46.060
Most controls track the mouse.

00:38:46.200 --> 00:38:46.660
How do you do that?

00:38:46.850 --> 00:38:49.750
Well, it's actually really simple
if you have a simple control.

00:38:49.790 --> 00:38:52.400
If your control is something like
a push button where it pretty

00:38:52.400 --> 00:38:55.400
much just has two visual states,
you know, the user's tracking on it,

00:38:55.400 --> 00:38:57.750
the user's tracking off of it,
all you need to support is

00:38:57.750 --> 00:38:59.020
K event control hit test.

00:38:59.040 --> 00:39:04.940
This Carbon event is sent by the control
manager in a number of situations.

00:39:04.940 --> 00:39:07.800
A client might be asking, "Hey,
what part of the control

00:39:07.800 --> 00:39:10.140
am I over right now?" Well,
we'll send you the Carbon event for

00:39:10.140 --> 00:39:11.250
that so you can tell the client.

00:39:11.300 --> 00:39:15.820
But if your tracking needs are simple,
this hit test Carbon event

00:39:15.820 --> 00:39:20.230
allows the control manager to
do the majority of work for you.

00:39:20.290 --> 00:39:24.030
You simply respond with the part code
that the mouse currently is over.

00:39:24.040 --> 00:39:26.890
And if you have simple needs,
the control manager will just

00:39:26.960 --> 00:39:30.750
highlight and unhighlight you,
withdraw Carbon events as appropriate.

00:39:31.030 --> 00:39:34.440
And if you have more
complex tracking needs,

00:39:34.440 --> 00:39:36.690
you should listen to the K-Event
Control Track Carbon Event.

00:39:36.700 --> 00:39:39.590
This is sort of the one-stop shopping,
high-level Carbon event where you

00:39:39.650 --> 00:39:40.890
can do anything you need to do.

00:39:40.900 --> 00:39:44.560
This Carbon event is sent to you
almost immediately after a client calls

00:39:44.610 --> 00:39:46.900
handle control click or track control.

00:39:46.900 --> 00:39:49.840
You've got full rain,
you can do custom tracking,

00:39:49.960 --> 00:39:51.900
weird scroll bar behavior,
anything you want.

00:39:51.900 --> 00:39:57.190
Now there's actually about a half a dozen
more tracking related Carbon events,

00:39:57.190 --> 00:40:00.340
and they're honestly fairly complex,
and I'm not going to go

00:40:00.340 --> 00:40:01.650
into the details here,
but I doubt you'll

00:40:01.760 --> 00:40:02.900
really need to use them.

00:40:02.900 --> 00:40:06.820
If you are a widget like a scroll
bar and you want the control manager

00:40:06.820 --> 00:40:10.760
to sort of do its default thumb
behaviors and weird things like that,

00:40:10.850 --> 00:40:13.900
you can actually take advantage of about
a half a dozen other Carbon events.

00:40:13.900 --> 00:40:16.870
Those are all documented
in the header pretty well,

00:40:17.000 --> 00:40:18.380
so take a look there.

00:40:19.880 --> 00:40:22.730
If you want to support keyboard input,
the first thing you must do is

00:40:22.730 --> 00:40:24.600
support the notion of focusing.

00:40:24.680 --> 00:40:25.890
We talked about focusing before.

00:40:25.900 --> 00:40:26.790
It basically says, "You know what?

00:40:26.880 --> 00:40:28.310
My control is ready for keyboard input.

00:40:28.400 --> 00:40:31.830
I'm where the keyboard input should
go." So in order to support that,

00:40:31.830 --> 00:40:35.300
you need to listen to the K-Event
Control Set Focus Part Carbon Event.

00:40:35.380 --> 00:40:37.180
There's a lot of
information in this slide,

00:40:37.180 --> 00:40:38.700
but it's really all important.

00:40:38.810 --> 00:40:42.300
When you get sent this event,
you're going to be told

00:40:42.440 --> 00:40:43.990
which part to focus.

00:40:44.260 --> 00:40:47.370
Now sometimes you might
be told to focus no part.

00:40:47.460 --> 00:40:49.600
That means clear the focus
if you have it already.

00:40:49.730 --> 00:40:53.190
Other times you might be told
a specific part to focus.

00:40:53.210 --> 00:40:55.840
So you should go ahead and
focus that specific part.

00:40:55.990 --> 00:40:58.290
Other times,
like when the user hits the Tab key

00:40:58.440 --> 00:41:01.960
or Shift Tab key as they're tabbing
through your user interface,

00:41:02.090 --> 00:41:05.230
we say focus the next part
or focus the previous part.

00:41:05.230 --> 00:41:07.140
So you want to handle
those as appropriate.

00:41:07.140 --> 00:41:08.930
Of course,
if you're not currently focused

00:41:08.990 --> 00:41:11.670
and you receive the Carbon event
that says focus the next part,

00:41:11.670 --> 00:41:13.380
you should focus to your first part.

00:41:13.440 --> 00:41:16.530
And as you keep receiving
next part Carbon events,

00:41:16.550 --> 00:41:19.030
keep focusing next part
until you get to the end.

00:41:19.060 --> 00:41:21.280
And finally,
when you're at the last available

00:41:21.280 --> 00:41:24.570
focusable part and you receive another
request to focus the next part,

00:41:24.630 --> 00:41:26.040
just turn your focus off.

00:41:26.040 --> 00:41:30.270
Of course, you do the reverse if the user
is asking for the previous part.

00:41:30.780 --> 00:41:33.140
Now your one responsibility on
exit from this Carbon event is

00:41:33.140 --> 00:41:35.940
to tell the Control Manager what
part is really focused.

00:41:35.990 --> 00:41:38.990
This is so the Control Manager can
do certain smart things.

00:41:39.000 --> 00:41:42.400
Just store your currently focused
part in the Kevent Param control

00:41:42.540 --> 00:41:45.660
part of the Carbon event,
and that's all you really need to do.

00:41:45.730 --> 00:41:48.110
You might optionally want
to support the Kevent

00:41:48.190 --> 00:41:50.360
Control GetFocused part Carbon event.

00:41:50.490 --> 00:41:53.090
In fact, this is probably...

00:41:54.570 --> 00:41:58.490
Most of you will not need to support
this if you return the proper part

00:41:58.500 --> 00:42:00.140
in K-Event Param control part.

00:42:00.240 --> 00:42:02.000
But if you have very special needs,
you might want to take

00:42:02.000 --> 00:42:03.340
advantage of this Carbon event.

00:42:03.470 --> 00:42:08.380
It allows the control manager to request
sort of lazily what part is focused.

00:42:09.370 --> 00:42:11.250
Oh, actually,
let's go back one more thing.

00:42:11.540 --> 00:42:14.270
This becomes especially
important in the future.

00:42:14.340 --> 00:42:18.230
One thing we want to do with
Mac OS X is allow keyboard navigability

00:42:18.490 --> 00:42:20.330
across all the user interface.

00:42:20.420 --> 00:42:25.360
And it's a little ways off, but

00:42:25.520 --> 00:42:28.900
The only way to make that happen
for your custom controls is to

00:42:28.900 --> 00:42:30.300
support these Carbon events.

00:42:30.330 --> 00:42:33.780
You will not be able to make it happen
for controls that are message-based.

00:42:33.860 --> 00:42:37.640
Now the cool thing is you can actually
have a message-based control that just

00:42:37.640 --> 00:42:41.600
installs a few Carbon event handlers.

00:42:41.630 --> 00:42:43.470
And this might be one of them
you want to take advantage of.

00:42:43.630 --> 00:42:45.840
So I suggest checking this stuff out,
learning how it works,

00:42:45.880 --> 00:42:47.900
because it will become very important
in the future if you want to have

00:42:47.900 --> 00:42:50.710
a totally keyboard-navigable UI.

00:42:52.070 --> 00:42:55.330
So once you've got the focus,
you want to accept keyboard input.

00:42:55.370 --> 00:42:58.090
The best way to do that is to
listen to a Carbon Event that's

00:42:58.160 --> 00:42:59.690
not part of the Control class.

00:42:59.770 --> 00:43:02.390
This is actually part
of the Text Input class,

00:43:02.390 --> 00:43:04.840
and it's a K-Event class, Text Input.

00:43:04.910 --> 00:43:08.520
The Carbon Event specifically is K-Event
Text Input Unicode for Key Event.

00:43:08.660 --> 00:43:12.690
It's a little cumbersome of a name,
but it's documented well in the header.

00:43:12.750 --> 00:43:15.170
And essentially,
the Unicode character stream is stored

00:43:15.170 --> 00:43:16.850
in a parameter of that Carbon Event.

00:43:16.860 --> 00:43:19.020
You extract it,
you slap it into your control,

00:43:19.020 --> 00:43:20.600
and you're pretty much all set.

00:43:20.650 --> 00:43:23.330
Now the even cooler bit is
that keyboard events are routed

00:43:23.330 --> 00:43:24.610
directly to the user focus.

00:43:24.890 --> 00:43:28.160
Once you're focused, if you're doing
Carbon Event-savvy defprocs,

00:43:28.250 --> 00:43:30.580
you don't need to worry about the
client calling handle_control_key.

00:43:30.600 --> 00:43:33.270
It all just gets sent
there automatically.

00:43:36.250 --> 00:43:38.900
There are several more events you might
or may not want to handle depending

00:43:38.900 --> 00:43:40.760
on how complex your control is.

00:43:40.840 --> 00:43:43.390
The first is K-Event
Control Activate and Deactivate.

00:43:43.440 --> 00:43:46.750
These are sent when a client calls
Activate or Deactivate Control.

00:43:46.850 --> 00:43:49.120
Now generally speaking,
most widgets will not need to

00:43:49.120 --> 00:43:50.600
respond to these Carbon events.

00:43:50.710 --> 00:43:54.380
These are only useful if you need to
change your control's internal state as

00:43:54.380 --> 00:43:56.790
a result of activating or deactivating.

00:43:56.860 --> 00:43:59.830
You don't need to worry about handling
this event if you only change your visual

00:43:59.850 --> 00:44:01.740
state on activating and deactivating.

00:44:01.800 --> 00:44:05.660
I guess the best example of
this is the Edit Text control.

00:44:05.730 --> 00:44:08.940
When it receives this Carbon event,
it calls TE Activate, right,

00:44:09.000 --> 00:44:11.510
because it needs to disable
the look of the edit field.

00:44:11.590 --> 00:44:14.040
And it doesn't just do that
to get the visual look.

00:44:14.220 --> 00:44:17.120
It needs to do that so that the
text services manager can make sure

00:44:17.120 --> 00:44:19.850
to deactivate any TSM documents
and stuff of that nature.

00:44:19.950 --> 00:44:21.950
But in general,
other controls like the push button,

00:44:21.960 --> 00:44:24.620
they don't worry about it
because after this Carbon event

00:44:24.620 --> 00:44:26.640
is sent to your control,
the control manager will

00:44:26.640 --> 00:44:29.070
request to draw anyway,
so you'll be redrawn in

00:44:29.070 --> 00:44:30.790
the proper visual state.

00:44:31.730 --> 00:44:34.620
Now a lot of controls are
becoming more complex these days.

00:44:34.790 --> 00:44:36.000
Case in point, the DataBrowser.

00:44:36.000 --> 00:44:38.030
We'll talk more about the
DataBrowser a little bit later,

00:44:38.130 --> 00:44:42.590
but as controls become more complex,
it becomes important to display a proper

00:44:42.590 --> 00:44:44.360
cursor when you're over a control.

00:44:44.360 --> 00:44:46.050
We're no longer at the
point where we know,

00:44:46.050 --> 00:44:47.880
"All right, well,
we want an arrow over buttons

00:44:47.990 --> 00:44:49.390
and just about everything.

00:44:49.400 --> 00:44:52.270
Oh, except for the Edit Text Control,
which needs an insertion point." No,

00:44:52.270 --> 00:44:55.000
now we're at the situation where,
"All right, if I'm over one of the column

00:44:55.000 --> 00:44:57.200
headers in DataBrowser,
I need to display the

00:44:57.200 --> 00:44:59.910
little Expando arrow cursor,
unless I'm all the way

00:44:59.910 --> 00:45:02.580
expanded to one direction,
then I want to show the Expando

00:45:02.580 --> 00:45:05.480
cursor that only points the
other direction." So we have a

00:45:05.540 --> 00:45:09.440
Handle Control Set Cursor API,
which was introduced relatively recently,

00:45:09.440 --> 00:45:11.670
and in order to take advantage of that,
you just listen to the

00:45:11.720 --> 00:45:13.580
K Event Control Set Cursor Carbon Event.

00:45:13.600 --> 00:45:16.900
We tell you where the mouse location is,
as well as what modifier keys are down,

00:45:16.900 --> 00:45:19.100
and then you can look at your
control's internal data structures

00:45:19.100 --> 00:45:21.900
and figure out what cursor to put up.

00:45:22.260 --> 00:45:23.800
Likewise,
contextual menus are becoming more

00:45:23.800 --> 00:45:25.400
important in the user interface.

00:45:25.400 --> 00:45:28.870
We offer a Handle
Control Contextual Menu Click API.

00:45:28.990 --> 00:45:32.110
And when the client calls this,
we send you a K-Event Control Contextual

00:45:32.110 --> 00:45:33.460
Menu Click Carbon event.

00:45:33.460 --> 00:45:37.970
Now the cool bit is these Carbon events
will be sent to your control definition

00:45:38.080 --> 00:45:42.510
automatically if the default window
handler is installed on your window.

00:45:42.640 --> 00:45:44.140
It means if you're very
Carbon event savvy,

00:45:44.140 --> 00:45:46.590
your control definition can
just handle these Carbon events.

00:45:46.640 --> 00:45:49.490
You don't need to worry about the
right API calls because the toolbox

00:45:49.490 --> 00:45:50.870
is going to call them for you.

00:45:52.600 --> 00:47:40.100
[Transcript missing]

00:47:40.330 --> 00:47:44.910
If you have a large,
visually complex CDEF and you resize,

00:47:45.160 --> 00:47:47.950
right now the control
manager says draw everything.

00:47:48.030 --> 00:47:50.200
And if it's particularly
expensive for you to draw,

00:47:50.200 --> 00:47:52.170
that can take a lot of time,
you see the lag,

00:47:52.200 --> 00:47:56.680
maybe a flash on Mac OS 9,
and it just really isn't a good thing.

00:47:56.810 --> 00:48:00.700
What we're going to start doing
in the future is allowing you to

00:48:00.700 --> 00:48:04.560
tell us what region to update as a
result of one of these state changes.

00:48:04.670 --> 00:48:08.310
So what will happen is someone will
call size control on your control,

00:48:08.460 --> 00:48:13.860
and you will be able to put a region
into a parameter of the K event

00:48:13.860 --> 00:48:16.870
control bounds change Carbon event
that tells the control manager,

00:48:16.920 --> 00:48:20.520
"Look, just redraw this particular area,
that way it's not very expensive."

00:48:20.640 --> 00:48:22.800
Now this stuff isn't in yet,
but it's one of the things that

00:48:22.800 --> 00:48:25.790
we're sort of throwing in the control
compositing mode bucket that we've

00:48:25.840 --> 00:48:27.590
been talking about a little bit.

00:48:27.820 --> 00:48:30.210
And finally,
if you're using the Embed Control API to

00:48:30.210 --> 00:48:34.820
move controls from one window to another,
we send a K event control owning

00:48:34.840 --> 00:48:37.610
window change to CarbonEvent.

00:48:37.610 --> 00:48:37.610
So you might want to react
to that appropriately.

00:48:38.090 --> 00:48:39.120
There's a few others.

00:48:39.120 --> 00:48:42.060
And these, actually,
DevProcs won't want to handle.

00:48:42.110 --> 00:48:45.460
These are pretty much reserved
for the client of the control.

00:48:45.560 --> 00:48:47.720
The first is kEventControlHit.

00:48:47.740 --> 00:48:51.110
After the user clicks on a control
and the application calls track

00:48:51.110 --> 00:48:54.090
control or handle control click,
and the click did successfully

00:48:54.090 --> 00:48:55.860
end on that control,
we send out a

00:48:55.860 --> 00:48:58.120
kEventControlHit Carbon event.

00:48:58.130 --> 00:49:02.700
This will give your application a chance
to react to the control as appropriate.

00:49:02.700 --> 00:49:06.080
If that control has a command
ID associated with it,

00:49:06.080 --> 00:49:08.860
and the kEventControlHit
Carbon event was not handled,

00:49:08.860 --> 00:49:12.080
we will send out a
kEventCommandProcess Carbon event,

00:49:12.210 --> 00:49:14.530
first to the control,
and then ultimately through its

00:49:14.530 --> 00:49:16.260
embedding hierarchy down to the window.

00:49:16.260 --> 00:49:19.180
Now, the really cool thing about this
is you can build up an entire

00:49:19.180 --> 00:49:22.440
user interface with a window and
a whole bunch of controls in it,

00:49:22.450 --> 00:49:26.250
and let the default Carbon event handlers
track all the clicks on your controls and

00:49:26.250 --> 00:49:28.250
let all the default processing happen.

00:49:28.270 --> 00:49:31.880
And then at the window level,
you can install a kEventControlHit or

00:49:31.880 --> 00:49:36.060
a kEventCommandProcess Carbon event
handler that listens to all the controls.

00:49:36.080 --> 00:49:38.680
So you can have four control
hits and command processes,

00:49:38.690 --> 00:49:40.160
four controls in that window.

00:49:40.160 --> 00:49:42.340
So it sort of lets you
encapsulate all your logic code

00:49:42.340 --> 00:49:44.680
into one place in a clean way.

00:49:46.460 --> 00:49:49.160
Now, I've mentioned complex controls,
and right now there is no more

00:49:49.240 --> 00:49:51.050
complex control than the DataBrowser.

00:49:51.260 --> 00:49:53.570
The DataBrowser is our
list manager replacement,

00:49:53.570 --> 00:49:54.400
essentially.

00:49:54.400 --> 00:49:56.720
And we figured, well, if we're going to
replace the list manager,

00:49:56.720 --> 00:49:57.900
we're going to need a new API.

00:49:57.900 --> 00:50:01.890
Well, we don't want to make a new API,
so let's just leverage an existing API.

00:50:01.900 --> 00:50:04.430
Well,
the Control Manager API was really rich,

00:50:04.430 --> 00:50:07.400
so we decided to turn the
DataBrowser into a control.

00:50:07.540 --> 00:50:09.590
And essentially,
DataBrowser is the list view

00:50:09.590 --> 00:50:12.210
that you see in the Finder,
and it's the column view that you

00:50:12.210 --> 00:50:13.870
see in a Navigation Services dialog.

00:50:13.900 --> 00:50:15.790
It's totally customizable.

00:50:15.790 --> 00:50:17.900
We support resizable columns.

00:50:17.900 --> 00:50:20.400
You can change what's
displayed in a given column.

00:50:20.400 --> 00:50:22.390
You get to control the
text that's displayed,

00:50:22.400 --> 00:50:23.400
the icon that's displayed.

00:50:23.400 --> 00:50:28.380
It supports text editing, drag and drop,
all kinds of stuff like that.

00:50:28.940 --> 00:50:31.490
Like I said,
it's a system supply control definition.

00:50:31.510 --> 00:50:34.540
You create it with
Create Data Browser Control.

00:50:34.600 --> 00:50:35.870
Gives you back a normal control ref.

00:50:35.970 --> 00:50:37.910
You can use all the normal
control manager APIs.

00:50:37.960 --> 00:50:40.640
You can size control it,
you can move control it, you can hide it,

00:50:40.710 --> 00:50:42.320
you can make it active, inactive.

00:50:42.420 --> 00:50:45.870
But of course, a complex list needs a
whole new suite of APIs.

00:50:45.870 --> 00:50:48.090
You can give it the right data,
configure it properly.

00:50:48.180 --> 00:50:51.290
So there's a bunch of new
APIs in ControlDefinitions.h

00:50:51.290 --> 00:50:53.280
to configure the Data Browser.

00:50:55.880 --> 00:50:58.230
So we're not planning on
leaving the DataBrowser alone.

00:50:58.270 --> 00:51:00.960
We need to improve it in several ways.

00:51:00.960 --> 00:51:03.100
The version we shipped in
Mac OS X is pretty good.

00:51:03.130 --> 00:51:04.940
There are some bugs in it, yeah, granted.

00:51:04.990 --> 00:51:08.400
The version in CarbonLib is
lagging behind a little bit.

00:51:08.400 --> 00:51:10.600
So there's definitely some
enhancements we want to make to it.

00:51:10.670 --> 00:51:11.720
First off is speed.

00:51:11.780 --> 00:51:15.880
We plan on speeding up the DataBrowser,
for one, through the control compositing

00:51:15.990 --> 00:51:19.510
stuff I've been talking about,
and specifically by handling a K event

00:51:19.510 --> 00:51:21.670
control bounds change Carbon event.

00:51:21.750 --> 00:51:23.730
That way, when you're live
resizing a Finder window,

00:51:23.730 --> 00:51:26.200
we don't repaint the
entire DataBrowser control.

00:51:26.210 --> 00:51:29.410
And in fact, that's why live resizing a
Finder window is so darn slow.

00:51:29.410 --> 00:51:31.880
So we're going to make
that a little bit faster.

00:51:31.920 --> 00:51:35.080
I've fixed several critical
crashing bugs lately,

00:51:35.080 --> 00:51:38.320
and they will show up in a
future operating system release.

00:51:38.320 --> 00:51:39.950
There's still a bunch of
other bugs we know about.

00:51:40.060 --> 00:51:41.310
We plan on fixing the major ones.

00:51:41.310 --> 00:51:43.910
And I want to get as many of
those bug fixes into the version

00:51:43.920 --> 00:51:47.770
of DataBrowser that ships with
CarbonLib 1.4 as possible.

00:51:47.930 --> 00:51:50.480
And finally,
DataBrowser supports most of its

00:51:50.490 --> 00:51:52.900
customization through proc pointers.

00:51:52.920 --> 00:51:55.250
Proc pointers are a little bit
limiting in that you can't change

00:51:55.250 --> 00:51:56.860
the parameter list they receive.

00:51:56.860 --> 00:51:59.100
Once you've got a four
parameter proc pointer,

00:51:59.100 --> 00:52:02.820
you're pretty much always stuck
with a four parameter proc pointer.

00:52:02.860 --> 00:52:05.020
Well, Carbon events are sort of our
proc pointer replacements,

00:52:05.020 --> 00:52:06.740
so we're going to integrate
them more with DataBrowser.

00:52:06.740 --> 00:52:09.590
So you'll be able to do more
customization through Carbon events.

00:52:13.780 --> 00:52:16.900
So, if you're going to support help
properly in your application,

00:52:17.000 --> 00:52:18.460
there's several steps you need to take.

00:52:18.580 --> 00:52:21.280
Probably the most basic one
is including the proper help

00:52:21.280 --> 00:52:22.850
button in your application.

00:52:23.650 --> 00:52:27.740
If you display standard alerts
from Create Standard Alert,

00:52:27.800 --> 00:52:30.290
Standard Alert, Create Standard Sheet,
we're going to put the right

00:52:30.290 --> 00:52:31.170
button in there for you.

00:52:31.240 --> 00:52:34.260
But if you have custom needs,
either in a larger window or in

00:52:34.260 --> 00:52:37.590
a dialog that you roll yourself,
you want to display

00:52:37.590 --> 00:52:39.360
the proper help button.

00:52:39.430 --> 00:52:41.980
Unfortunately,
you have to conditionalize your code to

00:52:41.980 --> 00:52:44.040
make this work on both Mac OS 9 and 10.

00:52:44.190 --> 00:52:47.250
On Aqua, we want you to use the
round button control.

00:52:47.340 --> 00:52:49.140
Unfortunately,
you can only create a round

00:52:49.140 --> 00:52:50.900
button control on Mac OS X.

00:52:50.900 --> 00:52:53.440
On Mac OS X,
just call Create Round Button Control.

00:52:53.510 --> 00:52:55.210
On Mac OS 9, however,
we don't have support for

00:52:55.210 --> 00:52:56.260
the round button control.

00:52:56.330 --> 00:52:59.700
And in fact, the Mac OS 9 Look is just a
plain bevel button control.

00:52:59.700 --> 00:53:04.080
So call Create Bevel Button Control when
you're running on CarbonLib.

00:53:04.140 --> 00:53:07.540
Now, to get the right help icon,
you can just use icon services.

00:53:07.660 --> 00:53:11.280
Both of these control types support
totally custom behavior via icon refs.

00:53:11.390 --> 00:53:14.630
So you call Get Icon Ref to get the
help icon associated with the control,

00:53:14.790 --> 00:53:17.740
and that's pretty much all
you have to worry about.

00:53:18.640 --> 00:53:21.230
Another step for supporting help is,
of course, Help Tags.

00:53:21.230 --> 00:53:22.250
We showed it on the screen.

00:53:22.290 --> 00:53:23.960
We showed it on the last slide.

00:53:24.020 --> 00:53:26.840
Help Tags, you can think of those as
a balloon help replacement,

00:53:26.840 --> 00:53:28.940
if you're used to the traditional of us.

00:53:28.990 --> 00:53:31.990
But really,
they're just context-sensitive tool tips.

00:53:32.080 --> 00:53:37.620
The cool part about Help Tags is that
they remain very brief for most cases.

00:53:37.650 --> 00:53:40.890
As you hover over a particular button,
it should give you just a

00:53:40.890 --> 00:53:43.740
very brief indication of what
that button's going to do.

00:53:43.820 --> 00:53:46.800
But if you hold down the Control key,
the Help Tag actually expands to give

00:53:46.800 --> 00:53:48.460
you a little bit more information.

00:53:48.530 --> 00:53:50.670
That way, you can get that
information if you want it,

00:53:50.750 --> 00:53:54.890
but it doesn't stand in your way and
block out the rest of the interface.

00:53:54.960 --> 00:53:58.880
Help Tags also allow customizable
positioning relative to the

00:53:58.950 --> 00:54:01.610
UI element that you're planning
on putting help up about.

00:54:01.780 --> 00:54:05.410
And we have content guidelines in
the Aqua User Interface Guidelines,

00:54:05.410 --> 00:54:06.150
I believe.

00:54:06.170 --> 00:54:09.860
I believe there's a section in the back
that talks expressly about what sort

00:54:09.860 --> 00:54:12.950
of help content is good help content,
and how much is too much,

00:54:12.950 --> 00:54:14.700
and what is just the right amount.

00:54:14.720 --> 00:54:16.640
So take a look at that.

00:54:17.420 --> 00:54:20.250
You can implement Help Tags
in a number of ways.

00:54:20.360 --> 00:54:24.790
The most straightforward way is to use
Interface Builder and its NIB support.

00:54:24.890 --> 00:54:28.200
Any NIB that you build from Interface
Builder for a Carbon application

00:54:28.490 --> 00:54:31.730
will allow you to specify help
information directly in that NIB.

00:54:31.800 --> 00:54:35.300
So not only can you position everything,
but you can give it all the help content.

00:54:35.300 --> 00:54:38.410
And then when you run that interface
with the Carbon Event Manager,

00:54:38.420 --> 00:54:40.580
the Help Tags just come up automatically.

00:54:40.660 --> 00:54:42.300
So that's the most straightforward way.

00:54:42.480 --> 00:54:48.380
We also offer a programmatic interface,
and we even added a few APIs to let you

00:54:48.720 --> 00:54:52.290
leverage existing Balloon Help content
that you might have for your dialogues.

00:54:52.300 --> 00:54:56.460
Now while these APIs are available to
let you use the Balloon Help content,

00:54:56.480 --> 00:54:59.300
I don't recommend using them,
not for any sort of

00:54:59.300 --> 00:55:03.300
performance or technical issue,
but just because the guidelines for

00:55:03.300 --> 00:55:07.300
Balloon content do not match up the
guidelines for Help Tag content.

00:55:07.300 --> 00:55:09.530
In general,
Help Tag content is a little bit more

00:55:09.530 --> 00:55:11.300
concise than the Balloon content.

00:55:11.300 --> 00:55:12.250
But if you need a component
that's more precise,

00:55:12.300 --> 00:55:12.300
you can use the Help Tag content.

00:55:12.350 --> 00:55:14.500
crutch for the short term,
you can go ahead and use

00:55:14.500 --> 00:55:16.170
the compatibility APIs.

00:55:16.470 --> 00:55:17.960
So if you want to use the
programmatic interface,

00:55:17.960 --> 00:55:20.890
there's actually three
different ways you can do it.

00:55:20.960 --> 00:55:25.160
You can associate static help
content with an individual control

00:55:25.160 --> 00:55:30.390
window or menu by using these
HMsetControlWindowOrMenuHelpContent APIs.

00:55:30.400 --> 00:55:33.160
You can go back and change
the help content later,

00:55:33.160 --> 00:55:36.370
but essentially, once you've set it,
the CarbonEvent subsystem,

00:55:36.390 --> 00:55:40.000
which actually will run for your
WaitNextEvent-based application,

00:55:40.020 --> 00:55:42.080
will put up the help content
automatically based on the

00:55:42.080 --> 00:55:43.380
control's current position.

00:55:43.400 --> 00:55:47.780
Now if you need a little bit more control
over when your content is displayed,

00:55:47.780 --> 00:55:50.320
you can use a certain callback mechanism.

00:55:50.410 --> 00:55:54.570
We allow a callback to be associated
for controls and windows and menu items,

00:55:54.570 --> 00:55:58.790
such that you can display the help tag,
or you can generate the help tag's

00:55:58.800 --> 00:56:00.400
information dynamically on the fly.

00:56:00.400 --> 00:56:03.400
This might be useful for a
lot of frameworks out there.

00:56:03.400 --> 00:56:05.900
And finally,
if that doesn't even serve your needs,

00:56:05.900 --> 00:56:08.710
you can just put up any arbitrary
help tag in any position you

00:56:08.710 --> 00:56:10.400
want by calling HMDisplayTag.

00:56:10.400 --> 00:56:13.400
You provide the right hot
rectangle and the right help data.

00:56:13.400 --> 00:56:15.400
And then you just put it up
on screen and there you go.

00:56:15.580 --> 00:56:17.930
Now unfortunately,
tearing down the help tags

00:56:17.930 --> 00:56:19.400
is a little cumbersome.

00:56:19.400 --> 00:56:21.400
We forgot the remove tag API.

00:56:21.400 --> 00:56:25.380
So right now what you have to do--yeah,
I know, we're lame sometimes.

00:56:25.750 --> 00:56:30.180
Right now what you have to do is turn off
help tags to make the help tag go away,

00:56:30.180 --> 00:56:32.390
and then turn help tags back on.

00:56:32.400 --> 00:56:35.880
Kind of a crummy workaround,
but it'll do the trick.

00:56:36.580 --> 00:56:39.560
Now on the Drag Manager front,
most of the stuff's the same,

00:56:39.560 --> 00:56:42.100
although there's a few gotchas.

00:56:42.100 --> 00:56:44.490
The drag highlight color
is changed under Aqua.

00:56:44.500 --> 00:56:48.380
It's no longer the,
I think it was a blue for Platinum.

00:56:48.380 --> 00:56:53.190
We now have a theme brush to
allow you to draw the proper

00:56:53.190 --> 00:56:55.960
Aqua-savvy drag highlight.

00:56:56.000 --> 00:56:58.340
And of course,
if we ever decide to change the drag

00:56:58.340 --> 00:57:01.460
highlight and you continue using
the Set Theme Background API with

00:57:01.520 --> 00:57:03.500
the right brush,
you'll keep getting the right look.

00:57:03.500 --> 00:57:06.250
In fact, we might even change the drag
highlight depending on whether

00:57:06.250 --> 00:57:07.450
you're in Aqua or Graphite.

00:57:07.550 --> 00:57:12.260
So use these APIs to get the right color
and you'll always have the right look.

00:57:12.800 --> 00:57:15.520
As was pointed out yesterday
in one of the sessions,

00:57:15.650 --> 00:57:19.200
Drop Rocks for Drag Manager don't
work anymore on Mac OS X.

00:57:19.250 --> 00:57:22.950
The way you do this on Mac OS X is
actually through the Set Drag Image API.

00:57:22.960 --> 00:57:26.910
Set Drag Image is actually callable
repeatedly during the drag,

00:57:26.910 --> 00:57:29.970
so you can alter your drag
image as the drag is moving

00:57:29.970 --> 00:57:32.150
along the screen if you want to.

00:57:35.330 --> 00:57:38.960
So we actually get questions
about cursors quite a bit.

00:57:38.960 --> 00:57:40.960
The HI guidelines talk
about it quite a bit,

00:57:40.960 --> 00:57:44.560
but there's sort of one main gotcha
that you need to worry about.

00:57:44.750 --> 00:57:47.330
Essentially, the guidelines say this:
If you're going to be busy

00:57:47.330 --> 00:57:49.760
for less than two seconds,
just put up a watch cursor.

00:57:49.760 --> 00:57:51.940
If you're going to be busy
for more than ten seconds,

00:57:52.040 --> 00:57:54.850
put up some kind of progress dialogue
or spinning arrows or something to let

00:57:54.850 --> 00:57:56.330
the user know you're going to be busy.

00:57:56.480 --> 00:57:59.590
But unfortunately,
there's this weird window of opportunity

00:57:59.590 --> 00:58:01.700
between two seconds and ten seconds.

00:58:01.840 --> 00:58:05.540
And the reason it's a weird window is
because the system will automatically

00:58:05.540 --> 00:58:09.550
put up the spinning wait cursor for your
application if your application is not

00:58:09.560 --> 00:58:11.800
responsive to events for two seconds.

00:58:11.800 --> 00:58:13.770
So if you get into some long
processing loop that goes

00:58:13.770 --> 00:58:16.270
beyond the two-second threshold,
up comes the spinning cursor,

00:58:16.270 --> 00:58:18.400
which we like to call the
spinning cursor of death.

00:58:18.400 --> 00:58:22.270
You don't want to rely on this cursor
for your busy needs because of why we

00:58:22.270 --> 00:58:24.450
call it the spinning cursor of death.

00:58:24.690 --> 00:58:29.140
Generally speaking, this cursor should be
interpreted by the user as,

00:58:29.140 --> 00:58:31.340
"Wow, this app is really hung.

00:58:31.340 --> 00:58:32.690
Maybe I want to try this out."
You don't want to force quit it.

00:58:32.700 --> 00:58:37.340
Or, "This app is really in a bad state."
So if you start relying on the system's

00:58:37.340 --> 00:58:40.480
spinning wait cursor for your busy needs,
the user is going to think your

00:58:40.560 --> 00:58:43.340
application is actually hung and
might force quit you prematurely.

00:58:43.370 --> 00:58:45.490
So what I would suggest doing
is if you're going to do any

00:58:45.490 --> 00:58:48.100
busy processing that's going
to take more than two seconds,

00:58:48.100 --> 00:58:50.600
make sure you put up some kind
of mode-less dialogue or spinning

00:58:50.600 --> 00:58:52.600
arrows to let the user know
it's going to take a while.

00:58:52.600 --> 00:58:56.220
And continue processing events as
normal to allow the user to get

00:58:56.220 --> 00:58:58.520
access to the rest of your interface.

00:58:59.480 --> 00:59:00.230
So get out there.

00:59:00.240 --> 00:59:01.240
Go ship your applications.

00:59:01.240 --> 00:59:02.480
I'm sick of using classic apps.

00:59:02.480 --> 00:59:02.920
Come on.

00:59:02.920 --> 00:59:03.720
Come on.

00:59:03.960 --> 00:59:05.660
Carbon events are the way to do this.

00:59:05.790 --> 00:59:07.820
Carbon events permeate
the entire toolbox.

00:59:07.820 --> 00:59:10.440
You can take advantage of all
sorts of new toolbox functionality.

00:59:10.440 --> 00:59:12.440
We've talked about it in
four different sessions.

00:59:12.440 --> 00:59:14.770
You can use Carbon events
to adopt sheets,

00:59:14.980 --> 00:59:16.990
Carbon events to do cool
things with your controls,

00:59:17.100 --> 00:59:19.100
Carbon events to do cool
things with the windows.

00:59:19.100 --> 00:59:22.730
You can use this as the sort of
patching mechanism for Mac OS X to

00:59:22.730 --> 00:59:25.140
alter the toolbox behavior.

00:59:25.160 --> 00:59:27.880
Take advantage of the dock when it
makes sense for your applications.

00:59:27.880 --> 00:59:30.160
Don't go overboard with it,
but make sure if you've got a

00:59:30.200 --> 00:59:32.920
really great way to give the user
a little bit more information

00:59:32.950 --> 00:59:35.440
by changing your dock's icon,
great, do it.

00:59:35.440 --> 00:59:39.660
And as John Galenzi said
in his session yesterday,

00:59:39.660 --> 00:59:41.700
Aqua gives you the chance
to go and stand out.

00:59:41.910 --> 00:59:43.060
The playing field's leveled.

00:59:43.060 --> 00:59:45.360
A lot of applications are trying
to make the most out of Aqua.

00:59:45.360 --> 00:59:48.060
This is your chance to go and beat
all your competitors and get a great

00:59:48.130 --> 00:59:51.320
looking Aqua interface and make
your application best of class.

00:59:51.320 --> 00:59:53.460
So with that,
to go through some roadmap and Q&A,

00:59:53.460 --> 00:59:55.000
I'd like to bring back up John Galenzi.

00:59:55.020 --> 00:59:56.480
Thanks.

01:00:07.700 --> 01:00:08.450
Let's see, the roadmap.

01:00:08.580 --> 01:00:11.200
The first one, 119,
we just had that earlier this morning.

01:00:11.200 --> 01:00:14.090
So if you weren't here,
you got to watch it on DVD.

01:00:14.140 --> 01:00:16.760
Designing Aqua Icons,
go to that one on Friday.

01:00:16.810 --> 01:00:18.420
Tomorrow morning here
in this hall at 10:30,

01:00:18.420 --> 01:00:19.940
it's going to be a great session.

01:00:19.940 --> 01:00:22.060
Apple Help, again,
we've talked through all of these,

01:00:22.110 --> 01:00:24.080
so I won't go into great detail.

01:00:24.640 --> 01:00:26.500
Anything new here?

01:00:26.670 --> 01:00:28.490
Nope, all this stuff happened.

01:00:28.590 --> 01:00:29.700
No, no, feedback for him.

01:00:29.850 --> 01:00:30.690
Friday, tomorrow.

01:00:30.800 --> 01:00:32.720
Oh yes,
feedback on the high-level toolbox,

01:00:32.720 --> 01:00:33.400
correct.

01:00:33.520 --> 01:00:36.470
Give us your feedback as to what
you want added to the high-level

01:00:36.570 --> 01:00:39.730
toolbox or Carbon functionality
to get a really great user

01:00:39.730 --> 01:00:42.410
experience with your product on 10.

01:00:43.100 --> 01:00:46.210
There's my contact info if you
need anything added to the system,

01:00:46.210 --> 01:00:48.950
or you think we're missing something,
or something's not working

01:00:48.960 --> 01:00:51.000
the way you want it to work,
please contact me.

01:00:51.000 --> 01:00:53.900
Or if you have questions about
creating a great application on X,

01:00:53.900 --> 01:00:57.090
feel free to send me an email
and work with me to get your

01:00:57.130 --> 01:00:59.000
app revised for Mac OS X.
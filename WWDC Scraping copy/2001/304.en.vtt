WEBVTT

00:00:04.100 --> 00:00:05.100
Good morning.

00:00:05.100 --> 00:00:06.560
My name is Tom Weier.

00:00:06.650 --> 00:00:09.980
I'm the Network and
Communications Technology Manager in

00:00:10.010 --> 00:00:11.000
Developer Relations.

00:00:11.000 --> 00:00:16.110
I'm going to introduce session 304,
which is Extensible Kernel

00:00:16.110 --> 00:00:18.000
Networking Services.

00:00:18.000 --> 00:00:27.000
Hopefully many of you have made it over
from the previous session in room A1.

00:00:27.000 --> 00:00:31.000
With that,
I'd like to introduce Laurent Dumont,

00:00:31.000 --> 00:00:34.910
who is one of the
CoreOS networking engineers.

00:00:40.870 --> 00:00:41.900
- Good morning.

00:00:41.900 --> 00:00:46.600
I'm gonna talk about the extensible
kernel networking services.

00:00:46.600 --> 00:00:50.040
And in our case,
we'll see that really mainly what

00:00:50.050 --> 00:00:54.900
we're talking about here are kernel
extensions and how to create kernel

00:00:54.900 --> 00:00:59.800
extension to add some networking
functionality to the kernel.

00:00:59.940 --> 00:01:03.210
So as an introduction,
Mac OS X networking

00:01:03.590 --> 00:01:06.390
architecture is extensible.

00:01:06.610 --> 00:01:11.870
So we get mechanism where you can
add firewalls or VPNs or content

00:01:11.870 --> 00:01:14.800
filters or network drivers.

00:01:14.800 --> 00:01:18.420
So this is the goal here is that a
little bit like in Mac OS 9 where

00:01:18.420 --> 00:01:20.800
you get a mechanism for extensions.

00:01:20.800 --> 00:01:25.980
Here you can add your networking
extension without having to

00:01:25.980 --> 00:01:28.800
recompile the whole kernel like
you would do in a regular kernel.

00:01:29.970 --> 00:01:33.400
free BSD type of environments.

00:01:34.570 --> 00:01:38.790
- What you'll learn in this session,
we'll talk in some details about

00:01:38.850 --> 00:01:41.190
the network kernel architecture.

00:01:41.310 --> 00:01:45.700
So what we have for Mac OS X and Darwin,
we're gonna use both terms because

00:01:45.850 --> 00:01:49.500
everything here is in Darwin,
so it's all open source.

00:01:49.500 --> 00:01:52.030
So you're really welcome
to look at all this,

00:01:52.030 --> 00:01:55.500
you know, at the source yourself
from the Darwin kernel.

00:01:55.500 --> 00:02:01.340
So, and we'll see how to do and
filter and intercept packets from

00:02:01.340 --> 00:02:05.500
different points in the kernel,
from the socket layer,

00:02:05.500 --> 00:02:08.500
from the lower levels,
and we'll see that.

00:02:08.500 --> 00:02:13.490
And also how to add network
interfaces and drivers in the kernels.

00:02:13.490 --> 00:02:19.580
And one of the interesting
things that you may learn here is

00:02:19.640 --> 00:02:24.500
some interesting tips about the
specificities of Mac OS X kernel.

00:02:24.500 --> 00:02:25.130
And some of the things that you may
learn here is some interesting tips about

00:02:25.130 --> 00:02:25.500
the specificities of Mac OS X kernel.

00:02:25.500 --> 00:02:29.700
And some of the changes, you know,
coming from Mac OS 9 or even

00:02:29.820 --> 00:02:34.130
from some FreeBSD or Darwin,
I mean, that are different in

00:02:34.130 --> 00:02:35.500
Darwin from FreeBSD.

00:02:35.500 --> 00:02:42.500
So there is different behaviors and some
tips here that you may be interested in.

00:02:42.900 --> 00:05:03.900
[Transcript missing]

00:05:04.160 --> 00:05:07.500
So networking on Darwin,
to summarize this,

00:05:07.650 --> 00:05:14.050
it's currently based on FreeBSD 3.2,
so we get the TCP/IP stack, socket,

00:05:14.050 --> 00:05:17.450
and a bunch of other services
for networking from the

00:05:17.450 --> 00:05:19.090
FreeBSD 3.2 implementation.

00:05:19.160 --> 00:05:27.050
So if you're a little bit aware of this,
it's not the latest version of FreeBSD,

00:05:27.110 --> 00:05:30.100
but it's a very solid base
for what we're doing here.

00:05:31.160 --> 00:05:33.100
So it's a very robust and
proven implementation.

00:05:33.100 --> 00:05:37.090
FreeBSD is used in many places,
in servers and things like that.

00:05:37.100 --> 00:05:40.970
So what that gives us,
it's a stack which has a lot of life,

00:05:40.970 --> 00:05:44.090
and a lot of problems
have been flushed already.

00:05:44.100 --> 00:05:51.020
So we inherit all those improvements and
all those things in the Darwin kernel.

00:05:51.470 --> 00:05:55.100
However,
we got some Apple enhancements there.

00:05:55.100 --> 00:06:00.950
For plenty of reasons that we'll detail,
but the FreeBSD stack by itself was

00:06:01.190 --> 00:06:04.100
not completely meeting our needs.

00:06:04.100 --> 00:06:07.700
So we're trying to have a more
dynamic approach where people

00:06:07.700 --> 00:06:11.100
can load and unload without
rebooting and without recompiling.

00:06:11.100 --> 00:06:14.100
So we also have support for MPs.

00:06:14.100 --> 00:06:19.100
The FreeBSD stack right
now is not really MP-savvy,

00:06:19.100 --> 00:06:27.330
so we got some mechanism here for
multithreading and MP efficiency and

00:06:27.340 --> 00:06:30.100
it's a networking subsystem in 10.

00:06:30.100 --> 00:06:33.100
So we also, as Vincent talked about
a little bit before,

00:06:33.100 --> 00:06:38.770
we also tuned some buffer allocation for
both client and some high performance

00:06:38.770 --> 00:06:41.080
for gigabit and things like that.

00:06:41.110 --> 00:06:45.100
So that's also some of the
modification we've done to the stack.

00:06:45.100 --> 00:06:49.100
And so we get this famous
data link interface layer,

00:06:49.100 --> 00:06:54.120
which is a mechanism for
extensibility at the bottom of

00:06:54.160 --> 00:06:58.100
the stack for adding protocols,
adding network families.

00:06:58.100 --> 00:07:02.590
One of the biggest problems with
FreeBSD is that basically when you get

00:07:02.590 --> 00:07:06.100
a new driver or a new class of driver,
a new family of driver,

00:07:06.100 --> 00:07:09.240
you more or less have to go
pretty deep into the kernel and

00:07:09.240 --> 00:07:15.820
recompile the kernel and get that
to be integrated in your stack.

00:07:16.170 --> 00:07:22.510
With Mac OS X and DLIL,
we have some mechanism to do

00:07:22.510 --> 00:07:25.100
this on the fly basically.

00:07:25.100 --> 00:07:29.100
You can load and unload your drivers,
add some type of different family

00:07:29.100 --> 00:07:32.100
without having to restart the machine.

00:07:32.100 --> 00:07:36.100
And as we said,
it's extensible because of those

00:07:36.100 --> 00:07:41.090
plug-in architectures and network kernel
extension we're going to just talk about.

00:07:41.100 --> 00:07:45.080
So the network kernel extensions,
what are they?

00:07:45.170 --> 00:07:49.930
They add extensibility
to the kernel networking.

00:07:50.240 --> 00:07:54.100
They are basically part of code
that's going to link against a kernel.

00:07:54.100 --> 00:07:57.100
Dynamically,
and that will be part of the kernel.

00:07:57.100 --> 00:07:59.080
So this is a big responsibility.

00:07:59.100 --> 00:08:01.100
You as a developer are
going to make some,

00:08:01.100 --> 00:08:04.100
I don't know, filter,
a new protocol or something.

00:08:04.120 --> 00:08:11.080
And using the network kernel extension,
you'll link your code to the kernel code.

00:08:11.100 --> 00:08:15.100
As you know in Mac OS X,
and it's been said in all the sessions,

00:08:15.140 --> 00:08:20.090
but there is a pretty hard boundary
in between user mode and kernel mode.

00:08:20.160 --> 00:08:25.100
In user mode, basically whatever you do,
if you crash your application,

00:08:25.100 --> 00:08:27.040
you're not going to
bring down the machine.

00:08:27.100 --> 00:08:31.240
When you run in the kernel,
you're in protected mode and

00:08:31.280 --> 00:08:35.100
you have access to all the
goodies and all the resources.

00:08:35.100 --> 00:08:40.210
It means that if your
code does something wrong,

00:08:40.210 --> 00:08:43.100
it's going to panic and it's
going to be a very bad experience.

00:08:43.100 --> 00:08:48.100
So kernel extension in that sense
are some things that should be

00:08:48.100 --> 00:08:52.100
used only if what you're trying
to do cannot be done in user mode.

00:08:52.100 --> 00:08:56.430
If what you're trying to
do as an application using

00:08:56.430 --> 00:09:01.100
networking can be done in user,
without running in the kernel,

00:09:01.100 --> 00:09:03.100
it's always best to do so.

00:09:03.100 --> 00:09:04.100
Why?

00:09:04.100 --> 00:09:06.100
Because if your application
crashes for some reason,

00:09:06.100 --> 00:09:08.100
you'll bring down your application.

00:09:08.100 --> 00:09:10.100
User may have to restart
your application,

00:09:10.100 --> 00:09:12.100
but life will be fine.

00:09:12.220 --> 00:09:16.100
If something goes wrong in the kernel,
it's a reboot,

00:09:16.100 --> 00:09:19.100
and that's really something we're
trying to avoid at all costs.

00:09:19.100 --> 00:09:21.100
So this is a first word of caution.

00:09:21.100 --> 00:09:24.090
We're going to have several
of them during this talk.

00:09:24.100 --> 00:09:28.100
Kernel extensions have the
potential to crash your machines.

00:09:28.100 --> 00:09:32.090
You have to be really careful
about what is done there.

00:09:34.300 --> 00:09:37.150
So what you can do in
a network extension,

00:09:37.150 --> 00:09:40.440
and basically you can
do a filter and case.

00:09:40.440 --> 00:09:46.920
So filter and case will see, can modify,
and inject or drop packets.

00:09:46.920 --> 00:09:51.300
So at those different
layers we've seen before,

00:09:51.300 --> 00:09:53.710
you'll be able,
we're going to go through the different

00:09:53.740 --> 00:09:56.510
type of filter and case you can make.

00:09:56.510 --> 00:10:00.370
But those filters will
intercept packets at some point.

00:10:00.520 --> 00:10:04.350
And you'll be able to do
whatever you want with a packet.

00:10:04.440 --> 00:10:07.150
So you can decide to let it go through.

00:10:07.170 --> 00:10:08.580
You can decide to modify it.

00:10:08.580 --> 00:10:12.100
You can decide to swallow it,
duplicate it, whatever you're trying to,

00:10:12.190 --> 00:10:15.240
you want to do, you'll be able to do that
through filter and case.

00:10:15.240 --> 00:10:17.920
So this is a very powerful mechanism.

00:10:17.920 --> 00:10:22.270
However, as I said,
you have the potential to, you know,

00:10:22.270 --> 00:10:25.240
if you, somebody,
if you're sending back a packet

00:10:25.320 --> 00:10:29.220
which is bad and it's going to
crash somewhere up the stack,

00:10:29.220 --> 00:10:29.640
you know, it's going to crash
somewhere up the stack.

00:10:29.640 --> 00:10:30.120
You know, it's going to crash
somewhere up the stack.

00:10:30.120 --> 00:10:31.000
It's a bad thing.

00:10:31.000 --> 00:10:32.920
So you've got to be really
careful about what you're doing.

00:10:32.920 --> 00:10:39.800
Network kind of extensions are
using the I/O Kit functionality.

00:10:39.870 --> 00:10:45.420
So through the I/O Kit mechanism,
you can dynamically load

00:10:45.420 --> 00:10:48.340
and unload the NKEs.

00:10:48.390 --> 00:10:49.640
And there is no need to reboot.

00:10:49.640 --> 00:10:55.270
This is something that you can do by
yourself or you can have through a

00:10:55.270 --> 00:10:58.280
set of dependency your NKE be loaded.

00:10:58.280 --> 00:10:59.720
We'll see in the next slide.

00:10:59.720 --> 00:11:04.140
So again, you're running in the kernel.

00:11:04.140 --> 00:11:05.500
So big liability.

00:11:05.750 --> 00:11:07.150
Be careful about your pointers.

00:11:07.160 --> 00:11:08.730
Be careful about your doing.

00:11:08.730 --> 00:11:11.800
When you're unloading,
you have some special things to do

00:11:11.800 --> 00:11:17.720
to make sure that you're living a
clean state after your module unloads.

00:11:18.140 --> 00:11:20.720
So, proceed with caution.

00:11:20.840 --> 00:11:25.830
Another important point is
that there is no real API.

00:11:25.850 --> 00:11:27.490
The networking subsystem is wide open.

00:11:27.500 --> 00:11:30.100
You're looking against all
the symbols in the kernel.

00:11:30.100 --> 00:11:34.660
So there is no guarantee of binary
compatibility in the future.

00:11:34.660 --> 00:11:37.740
Just a simple example here.

00:11:37.860 --> 00:11:44.120
If we change a structure or even worse,
if we change a macro and you have linked

00:11:44.120 --> 00:11:48.800
with an old version of this macro,
somehow this is going to work.

00:11:48.800 --> 00:11:54.670
You won't have any resolution
problem because this is a macro.

00:11:54.750 --> 00:11:57.810
But the underlying implementation of
the macro is going to be different

00:11:57.910 --> 00:11:58.990
from what is in the kernel.

00:11:59.020 --> 00:12:02.790
And your NKE may work for a while,
but at some point when it's

00:12:02.790 --> 00:12:06.650
going to hit this macro,
it's going to do the wrong stuff and

00:12:06.650 --> 00:12:09.360
the consequences might be harmful.

00:12:09.400 --> 00:12:14.840
You can potentially panic or even worse,
panic two hours later because

00:12:14.840 --> 00:12:16.760
you freed the wrong stuff.

00:12:16.800 --> 00:12:21.990
So this is a problem here,
but you get to be aware of this.

00:12:22.210 --> 00:12:25.200
The binary compatibility is not
guaranteed in the future because

00:12:25.200 --> 00:12:27.230
we may have to fix a stack.

00:12:27.300 --> 00:12:29.640
We may have to fix some of the things.

00:12:29.640 --> 00:12:34.140
So there is some
mechanism in I/O Kitties.

00:12:34.140 --> 00:12:39.080
I/O Kitties that let you declare
dependency and that will make sure

00:12:39.080 --> 00:12:43.540
that your NKE won't load if the kernel
version has changed and things like that.

00:12:43.540 --> 00:12:49.800
So those are things that you need to
look into when you're doing an NKE.

00:12:49.800 --> 00:12:51.280
Darwin is not BSD.

00:12:51.280 --> 00:12:52.780
Darwin is based on BSD.

00:12:52.780 --> 00:12:54.880
So some of the rules apply.

00:12:54.880 --> 00:13:00.340
Most of the rules, if you're used to BSD,
apply, but not all of them.

00:13:00.340 --> 00:13:01.880
And we'll go into some of them.

00:13:01.880 --> 00:13:05.770
We'll talk about things like funnels,
or things like where you have to

00:13:05.770 --> 00:13:07.880
be a little bit careful with MP.

00:13:08.000 --> 00:13:13.930
So don't expect your code that you just
got from open source for the kernel

00:13:13.930 --> 00:13:16.780
part to just compile and run in Darwin.

00:13:16.780 --> 00:13:19.190
It probably will,
but you need to have to be

00:13:19.190 --> 00:13:22.420
careful to look at some of
the aspects we'll talk about.

00:13:22.530 --> 00:13:28.420
And get a pretty good eye on it
and see what are the areas that

00:13:28.470 --> 00:13:30.220
may give you problems into Darwin.

00:13:30.220 --> 00:13:33.620
So don't expect this to
just compile and link it.

00:13:33.720 --> 00:13:35.280
into Darwin, it will work.

00:13:35.480 --> 00:13:37.900
You may have to do a little bit more.

00:13:38.040 --> 00:13:43.000
OK, so the NKE dynamic loadings,
so as we said before,

00:13:43.000 --> 00:13:46.300
this is provided by I/O Kit.

00:13:46.300 --> 00:13:49.770
So basically a kernel module,
is it a filter, is it your protocol,

00:13:49.770 --> 00:13:56.370
you know, whatever you do as an NKE will
have two required entry points.

00:13:56.530 --> 00:13:59.310
A start routine,
which would be called when

00:13:59.310 --> 00:14:03.110
your module is loaded,
and a stop routine, which is called when

00:14:03.200 --> 00:14:04.580
your module is unloaded.

00:14:04.580 --> 00:14:09.970
This is basically it,
all the rest is in terms of

00:14:09.970 --> 00:14:13.680
the NKE I/O Kit side of things.

00:14:13.680 --> 00:14:16.710
All the rest is going to be the
filter or whatever you're going

00:14:16.740 --> 00:14:21.700
to use as a mechanism to plug
yourself inside the kernel.

00:14:21.700 --> 00:14:25.700
So the NKs are not automatically loaded.

00:14:25.700 --> 00:14:29.420
You have to load them or invoke
their loading through a startup

00:14:29.470 --> 00:14:31.540
script or through dependency.

00:14:31.580 --> 00:14:34.560
You can have a chain of dependency
like that will require a start up.

00:14:34.560 --> 00:14:36.200
You can have a chain of dependency like
that will require your NKE to be loaded.

00:14:36.200 --> 00:14:41.840
This is pretty much what's going on
for some of the NKE we got in the

00:14:41.840 --> 00:14:44.080
system library extensions as well.

00:14:44.080 --> 00:14:45.960
The Apple NKs live.

00:14:45.960 --> 00:14:49.520
Some of them are loaded through
scripts and some of them are

00:14:49.520 --> 00:14:51.500
loaded through dependency.

00:14:51.500 --> 00:14:54.960
So there is three command line tools
that you should be aware of for,

00:14:55.090 --> 00:14:59.590
you know, especially if you're
debugging and doing your NKs.

00:14:59.680 --> 00:15:01.660
Kxload is going to load your NKE.

00:15:01.660 --> 00:15:04.520
Kmodstat will give you
a list of all the NKEs.

00:15:04.550 --> 00:15:07.470
Kmodunload will load your NKE.

00:15:07.640 --> 00:15:12.250
Your NKE won't load if there
is some symbol collision

00:15:12.250 --> 00:15:14.940
with what's in the kernel.

00:15:14.940 --> 00:15:16.860
This is I think in the next slide.

00:15:16.860 --> 00:15:17.860
No.

00:15:17.860 --> 00:15:22.470
One of the things I wanted to add here
is that when you're going to do an NKE,

00:15:22.470 --> 00:15:26.670
you should use some prefixing.

00:15:27.200 --> 00:15:31.050
- For your symbols there because you're
gonna be in the same address space,

00:15:31.050 --> 00:15:32.100
in the same symbol space as the kernel.

00:15:32.100 --> 00:15:42.090
So if you declare a function which is,
I don't know, TCP connect, right?

00:15:42.090 --> 00:15:47.630
You're gonna have a problem because this
function is already inside the stack in

00:15:47.630 --> 00:15:50.100
the kernel so your module won't load.

00:15:50.100 --> 00:15:54.820
And also we would like people
to somehow prefix their symbols

00:15:55.280 --> 00:16:00.100
with their own kind of prefix,
I don't know, maybe their vendor code,

00:16:00.100 --> 00:16:04.390
the Apple OS type,
to be sure that they're not gonna

00:16:04.390 --> 00:16:10.100
conflict with anything else or any
other vendor NKEs that might load.

00:16:10.100 --> 00:16:13.940
So that's something to think about.

00:16:14.300 --> 00:16:16.310
So different,
we alluded to this a little bit,

00:16:16.310 --> 00:16:18.010
but different types of NKE.

00:16:18.130 --> 00:16:20.240
So four main types.

00:16:20.240 --> 00:16:23.040
Socket filters.

00:16:23.040 --> 00:16:27.300
Socket filters are at the socket layer,
we'll go into details on this.

00:16:27.300 --> 00:16:30.040
So basically they let you
intercept socket calls.

00:16:30.040 --> 00:16:31.130
Network protocols.

00:16:31.210 --> 00:16:34.820
Network protocols can be
implemented as NKE also.

00:16:34.850 --> 00:16:37.450
And there is mechanism to
add those network protocol to

00:16:37.450 --> 00:16:40.980
the Darwin stack dynamically.

00:16:40.990 --> 00:16:43.200
Data link interface layer filters.

00:16:43.200 --> 00:16:47.600
So there's different types
of filter here for more of a

00:16:47.600 --> 00:16:51.060
lower level type of filtering.

00:16:51.100 --> 00:16:52.810
And also network interfaces.

00:16:52.870 --> 00:16:57.000
If you add some different, a new family,
a new type of interface,

00:16:57.050 --> 00:17:02.290
you might have to have some NKE to
describe that and let the protocol

00:17:02.480 --> 00:17:06.320
and DLIL know about your new family.

00:17:06.320 --> 00:17:09.140
So we'll go into those.

00:17:09.220 --> 00:17:11.380
So first of all, the socket layer.

00:17:11.400 --> 00:17:17.990
So just for people who are aware of
the Unix or the FreeBSD way of things,

00:17:18.000 --> 00:17:23.000
the socket layer is right under
the user to kernel boundary.

00:17:23.020 --> 00:17:26.820
And it's got a pretty
interesting role here.

00:17:26.840 --> 00:17:31.450
Is that the socket layer basically
is doing all the copying of

00:17:31.550 --> 00:17:34.500
buffers in and out of kernel space.

00:17:34.640 --> 00:17:38.860
So by this,
when your application under Mac OS X,

00:17:38.860 --> 00:17:42.800
when your application is trying to do,
let's say a SAN call,

00:17:42.800 --> 00:17:45.290
it's gonna try to send
something on the network.

00:17:45.460 --> 00:17:49.700
The buffer live into your user
thread in your application,

00:17:49.710 --> 00:17:54.000
and they need to be put
into the kernel memory.

00:17:54.020 --> 00:17:55.480
And this is done at the socket layer.

00:17:55.530 --> 00:17:59.900
The socket layer here is
gonna take the memory,

00:17:59.900 --> 00:18:03.940
I mean your buffers,
and put them into the socket buffer.

00:18:03.950 --> 00:18:07.420
Cues will go in details,
a little bit more details about this.

00:18:07.440 --> 00:18:11.880
And the copy to the kernel space
is done at the socket layer.

00:18:12.090 --> 00:18:15.500
One thing to note,
for people who are more aware of FreeBSD,

00:18:15.510 --> 00:18:19.890
is that here,
the execution of your thread is

00:18:19.920 --> 00:18:21.210
gonna continue in the kernel.

00:18:21.600 --> 00:18:26.300
So your user thread will do the SAN.

00:18:26.300 --> 00:18:30.100
So we'll do that from that thread.

00:18:30.100 --> 00:18:35.860
So on the other side,
the socket layer is where the protocol

00:18:35.860 --> 00:18:42.400
stack are gonna send the buffers,
and basically, by a mechanism, awake,

00:18:42.470 --> 00:18:46.000
get the application awakened,
the application thread awakened.

00:18:46.000 --> 00:18:50.620
We're gonna come another thread,
the input thread, and by some mechanism,

00:18:50.640 --> 00:18:55.760
we'll get the application awakened,
and the buffer will be copied from

00:18:55.760 --> 00:18:58.050
the socket layer back to user space.

00:18:58.120 --> 00:19:00.400
If you remember what Vincent was
talking about this morning,

00:19:00.400 --> 00:19:07.700
about those XTI SAN buff size, well,
this is where they are, basically.

00:19:07.700 --> 00:19:12.200
We got two sets of cues here,
one for sending and one for receiving.

00:19:12.200 --> 00:19:17.090
And this is,
they have some parametriable size.

00:19:17.200 --> 00:19:23.080
So the socket filters actually
live into the socket layer.

00:19:23.080 --> 00:19:30.600
So they're a way to intercept packets,
both coming from the application,

00:19:30.900 --> 00:19:35.940
or going from the application,
or going up to the application.

00:19:35.990 --> 00:19:40.480
So different sets of calls,
if you are aware of the socket calls,

00:19:40.480 --> 00:19:43.770
most of them have some, you know,
some kind of a mechanism

00:19:43.800 --> 00:19:44.530
here for filters.

00:19:44.580 --> 00:19:49.740
So what we'll do is,
when you'll create an NKE socket filter,

00:19:49.740 --> 00:19:53.460
we'll have a mechanism
to know that your socket,

00:19:53.460 --> 00:19:56.020
your filter, your code need to be called.

00:19:56.030 --> 00:19:59.260
And depending on which call
you added your filter to,

00:19:59.260 --> 00:20:03.730
you will be called and you'll receive
the packets and decide either to modify,

00:20:03.790 --> 00:20:06.530
drop, you know,
do nothing most of the time.

00:20:06.670 --> 00:20:09.770
But you have the flexibility
to do something with packets

00:20:09.770 --> 00:20:13.300
coming in and out of the socket,
or you can do something with packets

00:20:13.300 --> 00:20:14.670
coming in and out of the socket layer.

00:20:14.730 --> 00:20:16.360
So this is one way of putting a,
that's a content filter.

00:20:16.360 --> 00:20:18.590
I'm talking about all this in this slide.

00:20:18.770 --> 00:20:22.460
So sockets, again,
is the API for networking.

00:20:22.460 --> 00:20:24.620
This is the native API.

00:20:24.760 --> 00:20:27.780
So everything is going
through the socket layer.

00:20:27.780 --> 00:20:30.450
Socket is a glue in between
application and network protocols,

00:20:30.450 --> 00:20:31.740
we talked about this.

00:20:31.860 --> 00:20:36.710
This is where you cross the boundaries
of the kernel to user boundary.

00:20:36.760 --> 00:20:38.280
It sits above the network protocol.

00:20:38.300 --> 00:20:41.600
So the network protocols are
not in the socket layers.

00:20:41.600 --> 00:20:45.520
The socket layer is gonna decide
which protocol need to be called.

00:20:47.890 --> 00:20:50.510
Socket is kind of a file structure.

00:20:50.750 --> 00:20:56.800
It's following the Unix type,
everything is a file system,

00:20:56.970 --> 00:20:57.830
more or less.

00:20:57.830 --> 00:20:59.880
So it's a subset of that.

00:20:59.940 --> 00:21:05.590
It's got some specific calls,
but it's following some of the systems.

00:21:05.590 --> 00:21:08.560
You can do a read or you can
do a write on your socket.

00:21:11.400 --> 00:21:13.160
So we talked about this.

00:21:13.160 --> 00:21:16.980
Socket has a pair of packet queues
for incoming and outgoing packets.

00:21:16.980 --> 00:21:20.330
So your packets are going
to sit in those queues,

00:21:20.330 --> 00:21:24.050
especially on the way up,
until basically your application

00:21:24.080 --> 00:21:27.220
is awakened and it's going
to grab those packets.

00:21:27.220 --> 00:21:31.930
So as we said,
Darwin Sockets have plug-ins.

00:21:32.370 --> 00:21:38.340
Each of those calls, let's say,
SB receive, for example, is going to run,

00:21:38.340 --> 00:21:41.460
is going to look through all the
filters that are associated to it

00:21:41.460 --> 00:21:43.970
before it actually does the call.

00:21:44.020 --> 00:21:47.590
So you have the opportunity
to just discard the packet

00:21:47.640 --> 00:21:49.370
if you want or change it.

00:21:49.930 --> 00:21:50.740
- It's one way.

00:21:50.740 --> 00:21:57.100
Okay, so socket filter and KE, yeah,
we just talked about this.

00:21:57.100 --> 00:22:03.660
Oh yeah, the other thing is you have two
type of socket filters here.

00:22:03.780 --> 00:22:06.510
You can have,
which probably is the simplest one,

00:22:06.600 --> 00:22:08.880
a global socket filter.

00:22:08.900 --> 00:22:15.280
Your filter, the filters that you create,
is gonna be invoked for each socket.

00:22:15.340 --> 00:22:18.000
So every socket is gonna
run through your filter.

00:22:18.110 --> 00:22:19.730
Even if you don't care, you'll say,
"Okay,

00:22:19.730 --> 00:22:23.680
well I don't care." And you'll return
and the packet won't be touched.

00:22:26.950 --> 00:22:29.650
- And the application, I mean,
and the processing will continue.

00:22:29.890 --> 00:22:32.810
There is some,
a little bit more complex way of doing

00:22:32.810 --> 00:22:36.610
things where you can do programmatic
socket filters that will only

00:22:36.610 --> 00:22:38.900
apply to a certain type of sockets.

00:22:38.900 --> 00:22:41.700
You know,
let's say you just want something

00:22:41.820 --> 00:22:43.900
for web traffic or something.

00:22:43.900 --> 00:22:49.810
You have some way to decide that your
socket filter will apply only to that.

00:22:51.540 --> 00:22:54.730
You have to register your
NKE handle with Apple.

00:22:54.780 --> 00:22:57.860
So those are for people
familiar with Mac OS 9,

00:22:57.860 --> 00:23:00.080
those are the OS types, the vendor types.

00:23:00.080 --> 00:23:05.450
So that let us identify the
sockets and there is no collision

00:23:05.460 --> 00:23:07.010
when you insert your sockets.

00:23:07.080 --> 00:23:16.760
Your socket filter can be run after
some other vendor X socket filter,

00:23:16.760 --> 00:23:17.550
so you don't know that.

00:23:17.600 --> 00:23:21.070
So we need to have some way to
identify all socket filters.

00:23:21.070 --> 00:23:23.180
So you need to use the NKE handle.

00:23:23.180 --> 00:23:27.180
So C with DTS to get your handle there.

00:23:27.180 --> 00:23:30.770
And as we said,
an example of this is a content

00:23:30.770 --> 00:23:35.170
filter where you're going
to decide based on some...

00:23:37.550 --> 00:23:41.680
- You know, your own criteria,
what you want to let go through

00:23:41.680 --> 00:23:42.500
in those packets that you
receive each time you get a call.

00:23:42.500 --> 00:23:49.640
So, either you change them,
you swallow them,

00:23:49.640 --> 00:23:53.180
you do whatever you want,
you duplicate them, that's what,

00:23:53.180 --> 00:23:58.360
you know, whatever your content filter or
your socket filter is gonna do.

00:23:58.640 --> 00:24:05.500
So important points for the socket NKEs,
there is no built-in reference tracking.

00:24:05.520 --> 00:24:08.670
What we mean by this is,

00:24:08.850 --> 00:24:13.180
- That you have to, in your NKE,
you need to keep track of where

00:24:13.180 --> 00:24:15.660
your socket filter is inserted.

00:24:15.720 --> 00:24:17.800
If you're inserted in
15 different sockets,

00:24:17.800 --> 00:24:23.800
you'll receive, you'll know that,
and basically what it means,

00:24:23.800 --> 00:24:27.120
if somebody asks you to unload,
you get to keep track

00:24:27.190 --> 00:24:28.410
of those insertions.

00:24:29.430 --> 00:24:32.550
- And I'm gonna explain
briefly what's going on,

00:24:32.550 --> 00:24:36.910
that when we run the socket filter code,
basically there's a pointer to

00:24:36.910 --> 00:24:41.000
your socket filter handler where
you're gonna receive packets.

00:24:41.150 --> 00:24:46.350
And if you don't correctly
remove all this when you unload,

00:24:46.500 --> 00:24:48.640
we're gonna call into some
code that doesn't exist,

00:24:48.710 --> 00:24:50.000
and guess what?

00:24:50.060 --> 00:24:51.160
It's gonna panic.

00:24:51.220 --> 00:24:57.840
So it's all your responsibility to
take care of this and refuse to unload.

00:24:57.840 --> 00:25:01.400
It's, it's pretty,
it's pretty reasonable if your

00:25:01.510 --> 00:25:05.060
socket filter is in a state
where it doesn't know or for

00:25:05.170 --> 00:25:07.730
some reason cannot really unload,
to refuse to unload.

00:25:07.760 --> 00:25:11.620
And people won't be able to
unload your socket filter,

00:25:11.640 --> 00:25:16.030
but it's much better than
panicking five minutes later.

00:25:16.050 --> 00:25:20.700
So that's something you need to be aware,
and as a warning, you're in the kernel,

00:25:20.880 --> 00:25:22.560
it's pretty much wide open.

00:25:22.680 --> 00:25:25.380
You know, you have wide open access
to all the structure,

00:25:25.440 --> 00:25:27.830
all the thing,
but you're part of the kernel.

00:25:27.850 --> 00:25:28.880
You're just a function.

00:25:28.880 --> 00:25:32.110
If you're not there,
you get to do the right

00:25:32.110 --> 00:25:37.120
stuff to plug the hole,
basically, and don't leave, you know,

00:25:37.120 --> 00:25:39.680
no pointers and things
like that hanging around.

00:25:39.680 --> 00:25:42.630
Because that's, that's gonna be a pretty
bad user experience.

00:25:42.680 --> 00:25:46.050
So that's why we,
another word of caution about

00:25:46.190 --> 00:25:50.670
using kernel extensions,
you get to be really careful.

00:25:51.930 --> 00:25:58.150
- Okay, so now that second layer when
we looked at what basically

00:25:58.150 --> 00:26:01.920
the networking in Darwin is,
the network protocols,

00:26:02.060 --> 00:26:06.490
two examples that come to mind
here is TCP/IP and AppleTalk.

00:26:06.490 --> 00:26:13.230
So that's more or less something which
is pretty close to what you'll find in

00:26:13.230 --> 00:26:20.750
FreeBSD as a way to register protocol and
add protocols is pretty much the same.

00:26:20.760 --> 00:26:21.720
We get some

00:26:22.000 --> 00:26:25.040
- Some mechanism to let
you do that dynamically,

00:26:25.040 --> 00:26:28.970
add and remove dynamically
your protocols and your domain.

00:26:29.000 --> 00:26:32.430
So this is a second layer
we're gonna talk about.

00:26:32.880 --> 00:26:39.110
So what's important to know here is
that a domain defines a protocol family.

00:26:39.120 --> 00:26:42.480
One of the big examples here is pfinet.

00:26:42.480 --> 00:26:47.360
This is where all the TCP, UDP,
and raw IP live.

00:26:47.360 --> 00:26:52.100
Another one that you can think about
that we have in Darwin is pfinet6,

00:26:52.100 --> 00:26:59.450
which is for the family of IPv6.

00:26:59.470 --> 00:27:05.530
And so this is something that is pretty
much covered in a bunch of BSD books,

00:27:05.600 --> 00:27:09.320
the protocol family,
and how the protocol handler works.

00:27:09.320 --> 00:27:13.860
So this is what we have in Darwin here.

00:27:13.860 --> 00:27:15.950
From the socket layer,
we're going to decide

00:27:15.950 --> 00:27:19.910
which protocol handler,
depending of the type of sockets,

00:27:19.910 --> 00:27:22.570
the address family you
put in your socket.

00:27:22.580 --> 00:27:28.060
And if you have TCP, you do a connect,
we're going to call TCP connect.

00:27:28.060 --> 00:27:29.060
And this is done.

00:27:29.060 --> 00:27:32.000
This is a structure where you
can add your own protocol.

00:27:32.000 --> 00:27:37.460
If you come with a next killer protocol
family that's going to replace IP,

00:27:37.460 --> 00:27:38.820
this is where you're going to add it.

00:27:38.820 --> 00:27:41.560
So if you do that,
please do it and put it in Darwin.

00:27:41.560 --> 00:27:44.620
We'll be happy to take it.

00:27:44.620 --> 00:27:46.900
So this is extensible.

00:27:46.920 --> 00:27:47.920
Same thing.

00:27:47.920 --> 00:27:49.090
You can add your own protocol.

00:27:49.100 --> 00:27:52.810
And there is a mechanism to
declare this from your NKE.

00:27:52.820 --> 00:27:54.800
Again, you can remove that.

00:27:54.800 --> 00:27:57.140
When you remove it, be careful.

00:27:57.140 --> 00:27:58.660
Clean up after yourself.

00:27:58.660 --> 00:28:03.990
Otherwise, a very bad thing will happen
and the kernel will panic.

00:28:05.100 --> 00:29:35.100
[Transcript missing]

00:29:35.100 --> 00:29:40.480
some kind of a wire or wireless but you
know they're moving some physical bits

00:29:40.530 --> 00:29:44.790
if we can say that well you get some
pseudo drivers like tunneling devices

00:29:44.790 --> 00:29:49.600
and things like that that just add stuff
or remove things to frames that have

00:29:49.600 --> 00:29:54.610
been generated somewhere else so they can
generate their own frames but they don't

00:29:54.610 --> 00:30:00.290
they don't go to a media somehow all
those go to dlil and register themselves

00:30:00.410 --> 00:30:05.850
and and give some information about the
type of framings they do and the type

00:30:05.850 --> 00:30:12.610
of you know specificities they have so
dlil is here as a central point to uh

00:30:12.610 --> 00:30:19.260
to handle those and added to this if
i go back to the previous scheme here in

00:30:19.260 --> 00:30:24.620
between those we got two types of filter
again we got in between the network

00:30:24.620 --> 00:30:30.160
protocol we got the protocol filters
that register with dlil and say i want

00:30:30.160 --> 00:30:36.810
the ip packets for interface you know
en0 you know your your built-in ethernet

00:30:36.810 --> 00:30:42.300
and you also have interface filters
that are registering with dlil and are

00:30:42.300 --> 00:30:51.020
more lower level those guys will see
all packets for these one interface say

00:30:51.020 --> 00:30:57.900
you want to see everything coming from
en0 or cr port n1 or whatever ppp and

00:30:57.900 --> 00:31:02.620
you're going to put an interface filter
here that will not be protocol dependent

00:31:02.620 --> 00:31:08.090
you will get all your appletalk plus
ip plus you know whatever packets here

00:31:08.090 --> 00:31:14.670
well as a protocol filter you'll specify
that you're interested only in ip packets

00:31:14.720 --> 00:31:18.130
or appletalk packets whatever you want so

00:31:18.160 --> 00:31:22.030
- So this mechanism here
is different from BSD,

00:31:22.030 --> 00:31:26.580
and this is something you need to
be aware of if you take something

00:31:26.620 --> 00:31:28.340
like a driver or something like that.

00:31:28.340 --> 00:31:33.340
It's got to, or pseudo driver, let's say,
tunneling driver,

00:31:33.340 --> 00:31:38.480
it's got to follow some different
rules that it would in FreeBSD 3 or 4.

00:31:38.480 --> 00:31:44.340
It will have to declare some
DLL modules there to register with

00:31:44.340 --> 00:31:46.360
DLL and do things differently.

00:31:46.360 --> 00:31:50.680
There is some example in the end case and
in the Darwin code about how to do that.

00:31:50.680 --> 00:31:52.240
AppleTalk is an example.

00:31:52.240 --> 00:31:53.300
IP does that.

00:31:53.300 --> 00:31:56.180
IPv6 does that.

00:31:56.180 --> 00:31:57.580
So.

00:31:58.590 --> 00:32:05.060
So the interface layers is for,
as I said,

00:32:05.060 --> 00:32:08.260
I/O Kit type drivers or absolute drivers.

00:32:08.290 --> 00:32:12.870
So they attach to DLL and
basically tell the networking

00:32:12.870 --> 00:32:14.500
stack that they're available.

00:32:14.510 --> 00:32:19.100
So dynamically,
your airport is turned on or something.

00:32:19.110 --> 00:32:24.260
And the EN1 is going
to basically tell DLL,

00:32:24.260 --> 00:32:27.450
hey, I'm an Ethernet type of driver.

00:32:27.510 --> 00:32:30.490
And this is where I am.

00:32:30.540 --> 00:32:33.640
So it's more of a flexible
mechanism for attachment of

00:32:33.720 --> 00:32:37.500
detachment of interface on the fly.

00:32:37.500 --> 00:32:42.480
On the same way, you register your new,
you load your new protocol.

00:32:42.620 --> 00:32:46.880
And dynamically,
it's going to tell DLL that, hey,

00:32:46.880 --> 00:32:51.450
I'm protocol this type and I'll take
whatever snap ID for my packets.

00:32:51.500 --> 00:32:56.490
Now I want all those packets on
this interface and that interface.

00:32:56.580 --> 00:33:02.050
So you'll see around the DLL tag,
which is the cookies or the handle that

00:33:02.050 --> 00:33:08.500
you'll get for filters and you'll get
for protocol attachment or to interface.

00:33:08.510 --> 00:33:14.400
And all this is what identify basically
your unique connection to DLL.

00:33:14.500 --> 00:34:50.200
[Transcript missing]

00:34:50.730 --> 00:34:56.060
The DLL filters, so as we said before,
there is protocol filters on top

00:34:56.190 --> 00:35:01.920
of DLL and under the protocols.

00:35:02.600 --> 00:35:05.290
The difference,
what they do is that they see all

00:35:05.300 --> 00:35:07.540
protocol datagram for an interface.

00:35:07.540 --> 00:35:11.720
So the little trick here is that you
register per interface your filter.

00:35:11.720 --> 00:35:22.600
So if you register for IP on EN0,
you'll see valid IP frames for EN0.

00:35:22.600 --> 00:35:24.560
You won't see any
AppleTalk packets there,

00:35:24.560 --> 00:35:29.780
but you won't see IP packets
for EN1 for your airport,

00:35:29.780 --> 00:35:30.200
let's say.

00:35:30.200 --> 00:35:31.550
So you need to register on both.

00:35:31.560 --> 00:35:34.740
So they're kind of low level.

00:35:34.740 --> 00:35:37.490
However,
you got the interface filters that

00:35:37.570 --> 00:35:41.080
give you even more flexibility
because basically at this point

00:35:41.080 --> 00:35:43.160
you'll see the walled frame.

00:35:43.160 --> 00:35:46.940
So framing, looking at, you know,
if it's an IP packet

00:35:46.940 --> 00:35:50.200
or an AppleTalk packet,
won't be done in the interface filter.

00:35:50.200 --> 00:35:53.420
So this is between the
interface and the family here.

00:35:53.420 --> 00:35:56.760
You'll get access to the packets
as they come from the driver.

00:35:56.760 --> 00:35:59.960
You'll get access to the valid
packets coming from the driver.

00:35:59.960 --> 00:36:01.540
So you'll get access to the valid
packets coming from the driver.

00:36:01.540 --> 00:36:02.260
You'll see full frames.

00:36:02.260 --> 00:36:05.790
And this is where you can,
if you're trying to do like

00:36:05.790 --> 00:36:09.920
a VPN solution or a firewall,
is there one way where you

00:36:09.920 --> 00:36:12.940
could put your NKE is asking,
you know.

00:36:14.300 --> 00:36:17.090
You could be doing that
as a protocol filter,

00:36:17.120 --> 00:36:18.940
or add the interface filter.

00:36:18.940 --> 00:36:20.360
It really depends what you're doing.

00:36:20.470 --> 00:36:23.120
But those are good point
for getting all the traffic.

00:36:23.140 --> 00:36:29.270
While things at the socket layer
are more for getting things

00:36:29.340 --> 00:36:31.650
distinct to an application.

00:36:31.660 --> 00:36:35.220
Here you'll get all the
traffic for all the sockets,

00:36:35.230 --> 00:36:36.230
basically.

00:36:36.310 --> 00:36:38.520
Or even if they don't go to any socket.

00:36:38.520 --> 00:36:40.800
If they just dropped in the stack,
you'll see them at this point.

00:36:40.800 --> 00:36:45.250
It's before any processing by the stacks.

00:36:45.260 --> 00:36:49.810
So those are good solutions
for VPN and firewalls.

00:36:50.510 --> 00:36:54.480
Network interface,
there is still the FreeBSD,

00:36:54.480 --> 00:36:55.400
the BSD IFNet structure.

00:36:55.400 --> 00:36:57.810
You have one per interface.

00:36:57.810 --> 00:37:00.150
It's I/O Kit based.

00:37:00.150 --> 00:37:02.400
You have a lot of things for Ethernet.

00:37:02.400 --> 00:37:06.480
Ethernet has,
there is a lot of sample and the family

00:37:06.720 --> 00:37:09.380
shows how to do that for I/O Kit.

00:37:09.430 --> 00:37:12.490
So there, that's,
if you're doing an Ethernet driver or,

00:37:12.490 --> 00:37:15.320
you know,
some drivers that really talk to a media,

00:37:15.400 --> 00:37:18.400
you really need to look into
I/O Kit because those drivers

00:37:18.400 --> 00:37:20.400
don't live into those four layers.

00:37:20.400 --> 00:37:22.400
They live into I/O Kit.

00:37:22.400 --> 00:37:25.720
However,
if you're doing a pseudo device of some,

00:37:25.720 --> 00:37:29.320
or something which is a little
bit in between like PPP,

00:37:29.410 --> 00:37:33.390
you may have to do some work
in the I/O Kit for your driver,

00:37:33.390 --> 00:37:35.400
you know, dealing with media side.

00:37:35.400 --> 00:37:39.400
And also at the,
at the network interface layer.

00:37:39.400 --> 00:37:46.690
Here, where you will have some DLL work
to get your stuff registered with

00:37:46.690 --> 00:37:50.360
DLL and known by the network stack.

00:37:50.400 --> 00:37:56.390
So the network, networking subsystem
is not part of I/O Kit.

00:37:56.440 --> 00:38:00.720
But I/O Kit has some way to
basically give the packets and,

00:38:00.720 --> 00:38:06.400
you know, call some DLL functions to
make the interface well known.

00:38:06.400 --> 00:38:11.770
One case where if you're doing a
pseudo driver like a tunneling device,

00:38:11.930 --> 00:38:16.400
you may, you may do that only in
the networking subsystem.

00:38:16.400 --> 00:38:17.400
You don't have to go to I/O Kit.

00:38:17.400 --> 00:38:22.290
If all you do is take packets, you know,
add a header to it and do some

00:38:22.290 --> 00:38:27.400
encapsulation of some sort and send it
back to an Ethernet or another interface,

00:38:27.400 --> 00:38:31.390
you won't have to go through I/O Kit.

00:38:32.700 --> 00:38:35.250
- That's a thing to know.

00:38:35.320 --> 00:38:38.160
There is another,
we just mentioned that here because

00:38:38.160 --> 00:38:41.320
there is some confusion here,
but those filters we're talking

00:38:41.450 --> 00:38:45.860
about are different levels and people
who are coming from Unix may know,

00:38:45.860 --> 00:38:49.880
especially on the BSD side, so BPF,
which is,

00:38:49.880 --> 00:38:53.690
BPF is really an I/O Kit kind of tap.

00:38:53.750 --> 00:38:59.440
The difference, it's, well,
it's a standard way, if you're not aware,

00:38:59.440 --> 00:39:06.220
if you're coming from on FreeBSD to get
things like sniffer type application,

00:39:06.220 --> 00:39:09.380
network traffic analyzer,
and those kind of things.

00:39:09.510 --> 00:39:15.660
So those are tap from the driver,
which will copy all the frames back to

00:39:15.660 --> 00:39:23.520
BPF and get them to your application,
which asking for BPF traffic.

00:39:23.640 --> 00:39:27.100
The big difference with the
DLL filter is that in DLL,

00:39:27.100 --> 00:39:30.220
when you put, let's say,
an interface filter,

00:39:30.220 --> 00:39:35.210
you will get packets,
but you'll decide to let those packets

00:39:35.210 --> 00:39:39.860
go through or make a copy and do
your own kind of tap functionality.

00:39:39.880 --> 00:39:43.560
But by default, the packets,
there's one instance of the packet.

00:39:43.630 --> 00:39:46.040
Here, you get a copy of the
packet which is made.

00:39:46.260 --> 00:39:51.060
And also, for internet,
that's pretty true for internet, BPF,

00:39:51.060 --> 00:39:56.480
opening the BPF device will put
the driver in promiscuous mode,

00:39:56.480 --> 00:39:58.180
which means you will get all the packets,
you know,

00:39:58.180 --> 00:40:00.140
basically seen by your interface,
and you can see the packets, you know,

00:40:00.140 --> 00:40:01.240
basically seen by your interface,
and you can see the packets, you know,

00:40:01.250 --> 00:40:03.390
basically seen by your interface,
not just the one for

00:40:03.390 --> 00:40:06.890
your MAC address and,
you know, the various multicast or

00:40:06.890 --> 00:40:08.310
broadcasts that you can get.

00:40:08.440 --> 00:40:12.010
You will get everything that is
physically seen on your segment.

00:40:12.050 --> 00:40:17.020
So it's something you won't see
from a DLL interface filter.

00:40:17.020 --> 00:40:23.510
DLL interface filter will get only the
packets that are valid for your address.

00:40:23.520 --> 00:40:26.120
It's not gonna be in promiscuous mode.

00:40:26.130 --> 00:40:28.380
And again,
there are some standard hooks in

00:40:28.380 --> 00:40:30.820
I/O Kit network interface for this.

00:40:30.940 --> 00:40:34.900
So that's a good model to follow if
you're building your own drivers.

00:40:35.120 --> 00:40:40.600
It's a neat utility to
be able to use TCP dumps.

00:40:40.600 --> 00:40:44.780
There's a bunch of, you know,
services on top of that.

00:40:44.780 --> 00:40:52.060
And that's pretty much low work to do to
get the BPF support in your new driver.

00:40:52.110 --> 00:40:57.080
So we just mention it here because
there's some confusion between

00:40:57.080 --> 00:40:59.360
those and the DLL interface filters.

00:40:59.360 --> 00:41:00.740
They are not exactly the same.

00:41:00.740 --> 00:41:02.200
at the same level.

00:41:02.840 --> 00:41:06.550
So, non-IoKit interfaces need
to support BPF works.

00:41:06.560 --> 00:41:09.580
That's for BPF.

00:41:09.580 --> 00:41:14.330
Okay, another important thing here that
we wanna talk about about the

00:41:14.330 --> 00:41:18.280
networking subsystem is the MBUF.

00:41:18.300 --> 00:41:25.160
So, MBUFs are the memory buffers that
we use all over the system in the

00:41:25.160 --> 00:41:28.900
networking subsystem to all network data.

00:41:28.900 --> 00:41:33.060
If you're coming from 9,
you're pretty much aware of

00:41:33.060 --> 00:41:38.520
the MBLOCs which are used in
the OT or the streams modules.

00:41:38.520 --> 00:41:43.260
It's more or less the same
thing in the BSD world.

00:41:43.550 --> 00:41:51.290
What we do with MBUF is that we're
gonna hold either the packets coming

00:41:51.290 --> 00:41:56.620
from the socket layer in MBUFs or
things that are coming from drivers.

00:41:56.620 --> 00:42:01.240
So, I/O Kit is gonna create some
MBUF with the packets received by,

00:42:01.240 --> 00:42:06.820
let's say, an internet driver and sends
this back up to the DLL,

00:42:06.820 --> 00:42:12.180
of course,
and DLL will route those packets

00:42:12.180 --> 00:42:14.870
back to TCP/IP or AppleTalk,
whatever.

00:42:15.020 --> 00:42:18.270
But those are all MBUFs
that are manipulated.

00:42:18.340 --> 00:42:23.800
So, MBUFs are interesting because,
like MBLOCs, manipulate pointers to data.

00:42:23.820 --> 00:42:28.910
So, once you're in the kernel,
there is no more copy of data.

00:42:28.920 --> 00:42:30.480
Everything is done through MBUF.

00:42:30.700 --> 00:42:37.460
So, the drivers copy their data from
their ring buffer to the MBUF,

00:42:37.460 --> 00:42:42.360
actually, there's a MBUF already,
and they're passed up until

00:42:42.400 --> 00:42:44.400
they get to the socket layer.

00:42:44.410 --> 00:42:49.190
And then, when the application will be
awakened and will get its data,

00:42:49.330 --> 00:42:55.560
then they will be copied back from kernel
space to the user application memory.

00:42:55.560 --> 00:42:58.620
And they'll be released at this point.

00:42:58.720 --> 00:43:00.480
So, what's interesting in the MBUF,
is that the data is already there.

00:43:00.480 --> 00:43:01.700
So,
what's interesting in the MBUF is that,

00:43:01.700 --> 00:43:04.720
if we take the example
of a packet going down,

00:43:04.720 --> 00:43:08.180
the example of a send,
you're sending some TCP traffic,

00:43:08.180 --> 00:43:12.860
what's gonna happen at the socket
layer is that your packets from

00:43:12.860 --> 00:43:18.600
user space will be copied in the
kernel into some MBUF clusters,

00:43:18.600 --> 00:43:22.040
into some MBUF, and those MBUF will be
in the socket queue,

00:43:22.040 --> 00:43:26.620
remember the socket queue we
were talking about earlier.

00:43:26.620 --> 00:43:30.130
And what we're gonna do to send, I think,
the data, is that we're gonna send the

00:43:30.190 --> 00:43:30.260
data to the socket layer.

00:43:30.260 --> 00:43:31.230
So, what's gonna happen
is that the IP packet,

00:43:31.290 --> 00:43:34.370
CPIP packets,
is that we'll add an MBUF to a

00:43:34.370 --> 00:43:40.690
part of the data that you sent,
and this will logically point to

00:43:40.690 --> 00:43:44.420
the data in your socket buffer.

00:43:44.420 --> 00:43:48.120
And until,
and this is gonna go down to the driver,

00:43:48.120 --> 00:43:52.630
and the driver will send this,
and the driver will send this.

00:43:52.940 --> 00:43:57.280
we'll say it's done,
but the data in the socket buffer

00:43:57.280 --> 00:44:00.970
won't be released until the data
has been acknowledged by the

00:44:00.980 --> 00:44:03.150
other side of the TCP protocol.

00:44:03.270 --> 00:44:09.200
So if we need to do a retransmit of
this packet that we took from your data,

00:44:09.290 --> 00:44:14.070
we'll do that by prepending a new
header and pointing to your data,

00:44:14.080 --> 00:44:15.930
but your data will be the same in there.

00:44:15.970 --> 00:44:17.230
So there is no copy here.

00:44:17.260 --> 00:44:20.520
It's only once we know that all
the data has been acknowledged

00:44:20.520 --> 00:44:24.080
and we don't need it at the socket
layers that it's gonna be released.

00:44:24.160 --> 00:44:26.550
So that's something to know about mbuf.

00:44:26.680 --> 00:44:31.300
For you, as somebody who's gonna write
in network kernel extension,

00:44:31.300 --> 00:44:35.100
you have a bunch of
function to access mbuf,

00:44:35.110 --> 00:44:37.030
to allocate mbuf, to manipulate mbuf.

00:44:37.140 --> 00:44:41.810
There is pretty much everything
you can think about to do with

00:44:41.880 --> 00:44:47.280
mbuf in mbuf.h is a good start
in the sys directory to look at.

00:44:47.650 --> 00:44:50.850
However, there is a bunch of
macro dealing with mbuf.

00:44:51.110 --> 00:44:55.700
Try to avoid using them if possible
for the problem we talked about before.

00:44:55.710 --> 00:44:58.800
If we change the implementation
underneath in the macro,

00:44:59.010 --> 00:45:04.580
that may give some kind of
panic if you're using that.

00:45:04.580 --> 00:45:07.820
So try to avoid the
macro use if possible.

00:45:08.230 --> 00:45:12.440
The other thing to know which
is a little bit different from

00:45:12.440 --> 00:45:17.000
BSD is that we have a different
VM subsystem underneath and the way we

00:45:17.000 --> 00:45:18.890
allocate memory is kind of different.

00:45:18.990 --> 00:45:22.580
So in free BSD, you're pretty much,
guaranteed that you'll get

00:45:22.650 --> 00:45:24.540
memory when you allocate an mbuf.

00:45:24.680 --> 00:45:27.170
It's not the case in Darwin.

00:45:27.270 --> 00:45:30.260
So be aware of that,
that your allocation of

00:45:30.260 --> 00:45:32.280
mbuf can and will fail.

00:45:32.420 --> 00:45:34.730
There is two modes for mbuf.

00:45:34.740 --> 00:45:39.380
You can ask for an
mbuf with a don't wait,

00:45:39.420 --> 00:45:43.670
which means give me an mbuf if you
have one to handle your packets,

00:45:43.670 --> 00:45:44.300
your data.

00:45:44.300 --> 00:45:47.210
If you don't, just return.

00:45:47.220 --> 00:45:49.300
This is something you
use in the Fastpass,

00:45:49.300 --> 00:45:50.680
let's say on your
transmit and receive path.

00:45:50.680 --> 00:45:52.600
In your end case.

00:45:52.600 --> 00:45:59.260
This be warned that you may get,
you will get a null back.

00:45:59.260 --> 00:46:02.580
And probably the best way in
that case to drop your packet

00:46:02.580 --> 00:46:05.780
and do whatever is good there.

00:46:05.780 --> 00:46:10.020
You can also ask for a wait mode,
but don't do that on the Fastpass

00:46:10.090 --> 00:46:13.170
because you're gonna block the thread
while we're trying to allocate memory.

00:46:13.210 --> 00:46:16.770
So you're gonna block
potentially a thread.

00:46:17.300 --> 00:46:18.680
- Yeah, it's not very good.

00:46:18.680 --> 00:46:21.040
So do that for things that are
low bandwidth kind of things.

00:46:21.040 --> 00:46:25.500
When you start your protocol
and need some mbuf to upfront

00:46:25.500 --> 00:46:27.140
or something like that.

00:46:27.140 --> 00:46:29.300
But don't do that on the Fastpass.

00:46:29.300 --> 00:46:31.800
So yeah, the rule is do not block.

00:46:31.800 --> 00:46:33.680
So mbuf, you get to release them.

00:46:33.680 --> 00:46:35.230
There is some rules.

00:46:35.270 --> 00:46:38.600
It's not completely depending on
socket buffers and everything.

00:46:38.660 --> 00:46:42.620
You'll see that you have to release them
or somebody's gonna release it for you.

00:46:42.620 --> 00:46:46.610
There's no real preset rules.

00:46:47.880 --> 00:46:51.880
Yeah, maybe some other thing about mbufs.

00:46:51.880 --> 00:46:52.720
No, I think that's it.

00:46:52.800 --> 00:46:56.900
Just, yeah,
just the warning is be careful with mbuf.

00:46:56.960 --> 00:46:58.620
Be careful about the use of macros.

00:46:58.620 --> 00:47:03.960
And there is some command like netstat-m
that's going to tell you how many

00:47:03.960 --> 00:47:06.180
mbuf you're using in your system.

00:47:06.180 --> 00:47:09.440
And this is a really good way to
see if you have a leak in your NKE.

00:47:09.440 --> 00:47:14.110
If you see the number of mbuf, you know,
going up in use, it's probably somewhere

00:47:14.110 --> 00:47:15.910
you forget to release one.

00:47:15.920 --> 00:47:17.780
And so you might want to look at that.

00:47:17.800 --> 00:47:23.440
You might want to check that when
you're doing debugging of your NKEs.

00:47:24.300 --> 00:47:28.970
- From inside the kernel from GDB,
you can look at MB stats.

00:47:28.990 --> 00:47:31.110
It's gonna give you some
stats about the allocations,

00:47:31.170 --> 00:47:32.970
number of drops, and things like that.

00:47:33.000 --> 00:47:36.660
And again, it's gonna give you some
information if you forget to

00:47:36.660 --> 00:47:39.270
release some MBUF in your NK.

00:47:40.330 --> 00:47:44.130
Another thing here that we have
in terms of kernel extensibility

00:47:44.290 --> 00:47:47.000
are the kernel events.

00:47:47.130 --> 00:47:52.190
What we have is basically
a new domain here,

00:47:52.200 --> 00:47:56.720
the PF system,
which from the socket protocol

00:47:56.750 --> 00:48:04.320
gives you a way by listening on a
socket to see some kernel events.

00:48:04.320 --> 00:48:07.900
So it's going to report events
from kernel to user space.

00:48:07.960 --> 00:48:10.980
And those are pretty
low bandwidth events.

00:48:10.980 --> 00:48:15.540
Usually the kind of events we have
are things like your interface,

00:48:15.540 --> 00:48:20.030
you put the link, the link is up,
the link is down, things like that,

00:48:20.030 --> 00:48:21.580
or the IP address change.

00:48:21.580 --> 00:48:25.530
So you will receive an
event if you listen on this,

00:48:25.530 --> 00:48:28.860
if you connect to this socket.

00:48:28.890 --> 00:48:32.140
This is used mainly by
the system configuration.

00:48:32.140 --> 00:48:35.680
The configuration is pretty simple.

00:48:35.680 --> 00:48:41.020
You can also add your own
events to this mechanism.

00:48:41.060 --> 00:48:43.460
You can,
if you have like some specific driver,

00:48:43.460 --> 00:48:45.980
some specific driver
families that you added,

00:48:45.990 --> 00:48:48.960
and you want to add your
events and you want to have an

00:48:48.960 --> 00:48:53.460
application listening to this,
those events, you can do that.

00:48:53.490 --> 00:48:55.400
It's not meant for high traffic.

00:48:55.400 --> 00:48:57.560
It's just low bandwidth stuff.

00:48:57.590 --> 00:48:59.810
But it's a system, PF system.

00:48:59.980 --> 00:49:04.460
There is another thing
that we add in Darwin,

00:49:04.460 --> 00:49:08.110
which is the network NDRV, the PF NDRV.

00:49:08.120 --> 00:49:12.980
So that gives an access to, yeah,
I want to mention for

00:49:12.980 --> 00:49:17.330
people coming from 9,
it has nothing to do with NDRV that you,

00:49:17.330 --> 00:49:20.800
you know, the driver,
the native driver from Mac OS 9.

00:49:20.800 --> 00:49:24.160
It's really, you know,
the network driver here.

00:49:24.730 --> 00:49:28.520
So what it gives you is
from the socket level,

00:49:28.520 --> 00:49:31.750
it gives you access to all the packets,
to the raw packets.

00:49:31.820 --> 00:49:37.540
And one, you know, you can do,
as we said before, try to avoid,

00:49:37.580 --> 00:49:41.360
if you can, to do your protocol or
things you're trying to do,

00:49:41.360 --> 00:49:45.440
try to avoid doing them in the kernel
for all the reasons we stated before.

00:49:45.440 --> 00:49:48.860
If you want to do your
own protocol in user land,

00:49:48.860 --> 00:49:52.470
you could use PF NDRV to
get some packets there.

00:49:53.980 --> 00:49:56.740
As an example, in Darwin,
you can look at shared IP,

00:49:56.740 --> 00:50:00.280
which is the name of the kernel
extension we're using for doing

00:50:00.380 --> 00:50:04.580
the port sharing with classic,
with classic networking.

00:50:04.580 --> 00:50:09.700
It's an example of basically
classic listen to PF NDRV sockets

00:50:09.700 --> 00:50:16.610
to get its packet back and,
you know, emulate ZOT, you know, driver,

00:50:16.610 --> 00:50:19.280
DLPI driver that way.

00:50:19.280 --> 00:50:23.340
So the DLPI drivers is really
talking through a socket to PF NDRV.

00:50:23.980 --> 00:50:26.420
That's an example for you if you're
trying to do those kind of things.

00:50:26.420 --> 00:50:27.780
So.

00:50:29.320 --> 00:50:31.840
- Right now it works on Ethernet.

00:50:31.930 --> 00:50:33.100
Okay, funnels.

00:50:33.100 --> 00:50:39.140
Funnels are a mechanism that
we introduced in Darwin.

00:50:39.140 --> 00:50:42.720
This is not something
you'll find in FreeBSD.

00:50:42.720 --> 00:50:43.660
Why do we have this?

00:50:43.660 --> 00:50:47.700
Is basically, as you know,
we have an MP and we're an MP system,

00:50:47.700 --> 00:50:50.920
so we have a multi-processor.

00:50:50.940 --> 00:51:00.420
And what we want is to have a mode
where we can have performance in MP and

00:51:00.420 --> 00:51:09.080
the networking stack in Darwin from
FreeBSD is not completely MP safe,

00:51:09.080 --> 00:51:10.710
let's say.

00:51:10.720 --> 00:51:16.620
And so funnels are a mechanism to give
some mutual exclusion to make sure that

00:51:16.760 --> 00:51:23.910
when we run into the networking code,
networking from coming from

00:51:23.910 --> 00:51:27.180
I/O Kit up to the socket layer,
to the system call, to the packet level,

00:51:27.180 --> 00:51:31.210
that nobody else is gonna be running
into the code at the same time.

00:51:31.260 --> 00:51:37.280
So we got a mutex that we take from
the socket layer or from the packet

00:51:37.300 --> 00:51:43.700
level that's gonna make sure that
nobody else can be running in the,

00:51:43.700 --> 00:51:47.960
let's say,
TCP code and do something at the socket.

00:51:47.990 --> 00:51:52.420
One problem to think about is
you're trying to send something on,

00:51:52.420 --> 00:51:56.240
let's say, TCP,
you're sending some data on the TCP,

00:51:56.240 --> 00:51:58.240
and you're sending some
data on the TCP socket,

00:51:58.270 --> 00:52:00.240
at the same time we're
getting a disconnect.

00:52:00.310 --> 00:52:05.240
If we didn't have a system like funnels,
we're in a multi-processor environment,

00:52:05.240 --> 00:52:10.450
you could be doing your TCP send while
the state of your TCP transaction

00:52:10.450 --> 00:52:14.240
is being modified by the packets,
the incoming packet,

00:52:14.240 --> 00:52:15.920
and we don't wanna do that.

00:52:15.920 --> 00:52:17.320
We are not prepared for that.

00:52:17.320 --> 00:52:20.670
So the way to do this is to have funnel.

00:52:20.740 --> 00:52:26.220
So basically in the Darwin kernel,
there is two funnels,

00:52:26.220 --> 00:52:28.620
there is the network funnel,
which is used by the network stack,

00:52:28.630 --> 00:52:31.780
and the kernel funnel,
which is used by the rest

00:52:32.010 --> 00:52:34.050
of the BSD subsystem.

00:52:34.120 --> 00:52:38.900
If you remember the diagram from before,
inside the Mac OS X kernel,

00:52:38.900 --> 00:52:41.920
we get BSD subsystem,
which is more or less

00:52:42.100 --> 00:52:44.510
networking plus file system.

00:52:44.520 --> 00:52:47.110
So it's used by the file system.

00:52:47.190 --> 00:52:51.020
So what it means is that in the
file system or in the networking,

00:52:51.020 --> 00:52:54.450
you cannot have two
processors at the same time.

00:52:54.570 --> 00:52:59.200
However, by this mechanism,
you can have one processor running,

00:52:59.270 --> 00:53:02.330
dealing with packets and processing
packets while the other processor

00:53:02.420 --> 00:53:04.660
is doing file system sync.

00:53:04.660 --> 00:53:09.600
So that give us some good performance
in servers and MP environment,

00:53:09.700 --> 00:53:14.200
where you can have your Apache or
Apple share server do at the same time,

00:53:14.200 --> 00:53:17.460
have one processor do some
networking activity while the

00:53:17.460 --> 00:53:22.160
other is flashing stuff on the
disk or doing some file access.

00:53:22.230 --> 00:53:27.980
So the problem with this funnel is
that you need to be aware of them.

00:53:27.980 --> 00:53:32.280
And the rule I stated is that basically
we have one lock on top of the

00:53:32.520 --> 00:53:35.180
networking stack at the socket layer.

00:53:35.180 --> 00:53:36.840
And I mean, that's a system called layer.

00:53:36.880 --> 00:53:40.820
And one at the bottom
is not completely true.

00:53:40.820 --> 00:53:43.610
So we're gonna go into some of
the detail you need to do in

00:53:43.610 --> 00:53:45.720
your NKE to deal with funnels.

00:53:45.730 --> 00:53:48.720
But that's a difference from FreeBSD.

00:53:48.720 --> 00:53:50.760
So that's something you
need to be aware of.

00:53:50.860 --> 00:53:55.830
And the thing is here is that
you need to deal with funnels.

00:53:55.860 --> 00:53:57.800
You cannot like say,
I don't care about funnels.

00:53:57.820 --> 00:54:03.820
Your system is gonna be on having problem
if you don't deal with that right.

00:54:05.850 --> 00:54:09.060
Okay, so when to use them.

00:54:09.280 --> 00:54:13.480
So you need to set the network
funnel and specify that you

00:54:13.480 --> 00:54:17.430
wanna work in the network funnel
in your module start and stop.

00:54:17.480 --> 00:54:18.400
Why?

00:54:18.450 --> 00:54:25.120
Because you're called by I/O Kit,
basically when your module starts.

00:54:25.130 --> 00:54:28.320
And I/O Kit is not
running under a funnel.

00:54:28.320 --> 00:54:32.020
I/O Kit and the Mac part of the
kernel don't need to have funnels.

00:54:32.020 --> 00:54:36.120
They're already MP, completely safe,
and they don't need that.

00:54:36.190 --> 00:54:40.420
So you need, when you're gonna be called,
you need to basically tell,

00:54:40.420 --> 00:54:43.100
I'm gonna use the network funnel,
and there's calls to do that.

00:54:43.180 --> 00:54:44.810
Same thing for the stop.

00:54:44.920 --> 00:54:48.750
Timeouts are another one
where you need to be switching

00:54:48.750 --> 00:54:52.990
funnel or taking the funnel,
taking the network funnel.

00:54:53.200 --> 00:54:53.990
Why?

00:54:54.070 --> 00:54:59.000
Because the timeouts are called as a
direct mapping from the Mach subsystem,

00:54:59.000 --> 00:55:01.240
and you're not under any funnels.

00:55:01.240 --> 00:55:05.390
So if you, to run your code,
you need to explicitly say, hey,

00:55:05.390 --> 00:55:08.580
I'm gonna run the networking code,
so I need to grab the

00:55:08.580 --> 00:55:10.630
network funnel first.

00:55:10.740 --> 00:55:13.800
And there is also things,
when you're doing things with threading,

00:55:13.800 --> 00:55:18.420
if you create a new thread,
you need to explicitly tell that this

00:55:18.430 --> 00:55:20.350
thread has to run to the network funnel.

00:55:20.360 --> 00:55:23.100
Yeah, it's a preemption point.

00:55:23.100 --> 00:55:28.030
So each time you're trying to grab the
funnel or you're gonna leave the funnel,

00:55:28.040 --> 00:55:29.180
you can be preempted.

00:55:29.200 --> 00:55:32.000
Another thread in the kernel can run.

00:55:32.000 --> 00:55:33.220
So be aware of that.

00:55:33.220 --> 00:55:39.330
Your state might change when you
come back from asking for getting

00:55:39.330 --> 00:55:41.180
a funnel or leaving a funnel.

00:55:41.180 --> 00:55:42.710
Just be aware of that.

00:55:42.890 --> 00:55:46.560
And more or less, if you're aware with
FreeBSD and the SPLnet,

00:55:46.560 --> 00:55:50.750
SPLX, in Darwin,
there are more or less no ops.

00:55:50.910 --> 00:55:55.710
I'm saying more or less because
all they do right now is they just

00:55:55.990 --> 00:55:59.530
make sure that your ether under
the network is a kernel funnel.

00:55:59.580 --> 00:56:02.760
So they don't have any active
nesting or anything like that.

00:56:02.830 --> 00:56:06.950
They just, they don't have the, I mean,
in FreeBSD,

00:56:06.950 --> 00:56:11.220
you would product yourself for a
critical section by raising SPLnet and

00:56:11.220 --> 00:56:13.700
say nobody else can enter at this point.

00:56:13.700 --> 00:56:17.300
On 10, there are more or less no ops.

00:56:17.310 --> 00:56:20.900
But if you're under the network funnel,
nobody's gonna get in there.

00:56:21.100 --> 00:56:23.190
So that's for funnels.

00:56:23.200 --> 00:56:26.610
So that's something you need to
look at and look at our kernel

00:56:26.610 --> 00:56:30.220
extensions in Darwin to see
how to use that appropriately.

00:56:31.300 --> 00:56:33.330
NKE control.

00:56:33.430 --> 00:56:37.500
There is a way, PF NKE,
to control the NKE from a process,

00:56:37.520 --> 00:56:38.340
from user mode.

00:56:38.340 --> 00:56:45.590
So let's say you inserted a socket filter
or a data link interface layer filter,

00:56:45.620 --> 00:56:47.560
and you want to have
some control to that,

00:56:47.750 --> 00:56:54.480
you can have a special mechanism
like a conduit to control your

00:56:54.480 --> 00:56:59.460
NKE through this NKE control,
the PF NKE.

00:56:59.980 --> 00:57:04.360
The NKE manager is not loaded by default,
so it's something you need to do.

00:57:04.530 --> 00:57:10.420
And we're kind of in the changing,
we'll change that.

00:57:10.420 --> 00:57:13.280
So right now it's work in progress.

00:57:13.310 --> 00:57:14.500
It's a character device.

00:57:14.500 --> 00:57:20.060
And there is some other way that
we encourage to talk to your NKEs.

00:57:20.060 --> 00:57:21.710
You can go through I/O CTLs.

00:57:21.720 --> 00:57:26.880
You're gonna intercept I/O CTLs and use
that as a control mechanism for your NKE.

00:57:26.880 --> 00:57:28.380
Or also socket options.

00:57:28.380 --> 00:57:28.760
This is what we do.

00:57:28.760 --> 00:57:32.630
If you look in shared IP,
we use socket option as a

00:57:32.750 --> 00:57:35.710
control mechanism for the NKE.

00:57:36.250 --> 00:57:41.200
So VPN, yeah,
we talked about a way to implement a VPN.

00:57:41.200 --> 00:57:46.140
So you could do that as a pseudo device,
depending of what you're doing,

00:57:46.140 --> 00:57:48.080
the type of VPN you're doing.

00:57:48.080 --> 00:57:50.560
Or you could do that as a DLL filter.

00:57:50.560 --> 00:57:54.600
It really depends about how your code
is organized and which level you think

00:57:54.600 --> 00:57:57.720
is appropriate for you to plug in.

00:57:57.720 --> 00:58:00.740
Be aware that the CAME IPSec
is coming to Mac OS X.

00:58:00.740 --> 00:58:07.960
So if your VPN solution is using IPSec,
IPSec right now, CAME IPSec is in Darwin.

00:58:07.960 --> 00:58:13.160
You can take a peek of that and this is
gonna come and be sometime in the future,

00:58:13.160 --> 00:58:16.060
this will be part of the Mac OS X kernel.

00:58:16.070 --> 00:58:19.980
So you can build your own
Darwin kernel with IPSec right now

00:58:19.980 --> 00:58:25.600
and use that as a base for your
VPN solution if you're using IPSec.

00:58:25.600 --> 00:58:27.600
And talk to us if you're interested.

00:58:27.600 --> 00:58:32.190
We're really interested in knowing
how we can help you with that.

00:58:32.370 --> 00:58:35.240
Summary,
I just want to go again because the

00:58:35.240 --> 00:58:38.440
message here is about the rule for NKEs.

00:58:38.440 --> 00:58:41.260
You have to be really careful
about your dependency.

00:58:41.260 --> 00:58:45.370
You have some IOCAT mechanism to say,
"Hey, I'm linking against that kernel.

00:58:45.370 --> 00:58:51.370
I don't want to be loaded if it's
version 15 of Mac OS X." You got to

00:58:51.390 --> 00:58:53.660
keep track of your resource and usage.

00:58:53.660 --> 00:58:55.850
Nobody's going to clean up after you.

00:58:55.990 --> 00:58:58.620
You have to do it.

00:58:58.620 --> 00:59:00.660
Do not block input on the Fastpass.

00:59:00.660 --> 00:59:02.880
You're going to block the
world networking stack here.

00:59:02.880 --> 00:59:06.090
You're part of the networking,
so you just have to behave

00:59:06.090 --> 00:59:08.080
and use those rules.

00:59:08.080 --> 00:59:09.810
You have to know your split funnels.

00:59:09.920 --> 00:59:12.040
Be really careful about that.

00:59:12.040 --> 00:59:19.060
Remember timeouts and anything
that is coming out of the kernel

00:59:19.060 --> 00:59:25.140
funnel or the rest of the kernel
is probably not under the funnel.

00:59:25.140 --> 00:59:29.700
So just check with that and be
aware of binary compatibility.

00:59:29.840 --> 00:59:33.040
In the future, as we said, IPsec,
IPv6 are coming.

00:59:33.040 --> 00:59:34.180
They're part of Darwin.

00:59:34.500 --> 00:59:38.800
We get, you know, you can look at that
in the Darwin kernel.

00:59:38.800 --> 00:59:40.200
We're gonna be based on that.

00:59:40.200 --> 00:59:45.780
PPP extensibility, there will be a way to
get some plugins for PPP.

00:59:45.780 --> 00:59:50.340
If you say you wanna have PPP over
ATM or PPP over some other new

00:59:50.340 --> 00:59:52.370
cool media you just invented.

00:59:52.380 --> 00:59:57.060
The NKE control via
socket API is in flux,

00:59:57.060 --> 00:59:58.940
so it's gonna change a little bit.

00:59:58.940 --> 01:00:04.480
And also in the future,
we're planning to get something to,

01:00:04.480 --> 01:00:09.130
you know, instead of funnels,
some more finer grain locking of

01:00:09.130 --> 01:00:13.060
sockets and things so we don't
have to use a funnel mechanism.

01:00:13.110 --> 01:00:15.980
So that's pretty much it.

01:00:16.000 --> 01:00:18.350
So I hope you got information there.

01:00:18.440 --> 01:00:21.310
You can have additional resources here.

01:00:21.640 --> 01:00:23.360
Mac OS X, of course, you've seen those.

01:00:23.360 --> 01:00:24.510
I'm gonna go fast through those.

01:00:24.710 --> 01:00:28.080
Darwin org and FreeBSD are also
good points for information.

01:00:28.080 --> 01:00:30.270
information.

01:00:30.520 --> 01:00:35.400
Resources, the TCP,
the Stevens books that we talked about.

01:00:35.400 --> 01:00:40.070
The implementation,
design implementation of BSD 4.4

01:00:40.190 --> 01:00:41.340
is also pretty interesting.

01:00:41.440 --> 01:00:44.860
However, be aware of those differences
we talked about like funnels,

01:00:44.940 --> 01:00:48.160
DLL, and things like that that gives
you a pretty good idea about

01:00:48.160 --> 01:00:51.500
what's going on but it's not
exactly what we have in Darwin.

01:00:51.500 --> 01:00:58.180
And the network kernel extension
PDF file that has a very,

01:00:58.340 --> 01:01:02.640
very complete coverage about
all the type of DLL filter

01:01:02.640 --> 01:01:04.220
you can do and socket filters.

01:01:04.240 --> 01:01:09.410
This is where you're gonna dig into all
the details about how to do your NKE.

01:01:09.460 --> 01:01:13.950
And also kernel extension tutorial
from Iokits which is gonna tell

01:01:13.960 --> 01:01:18.270
you about how to build NKs with
Project Builder and what are the rules

01:01:18.270 --> 01:01:21.390
for dependency and things like that.

01:01:21.760 --> 01:01:24.720
and tell us what you need from us.

01:01:24.720 --> 01:01:26.680
We're trying to make this extensible.

01:01:26.790 --> 01:01:30.500
We got some mechanisms that
we think cover some ground.

01:01:30.520 --> 01:01:34.700
So tell us if you need more or what
you think we should change here.

01:01:34.700 --> 01:01:37.380
And we're really interested in
getting your feedback on this.

01:01:39.410 --> 01:01:43.960
And the roadmap this morning was
the networking overview session.

01:01:43.960 --> 01:01:45.060
It's done already.

01:01:45.060 --> 01:01:49.850
And this afternoon, pretty interesting,
the 303 network configuration mobility.

01:01:49.920 --> 01:01:53.610
We'll see how those guys are
using the events to get some

01:01:53.610 --> 01:01:56.360
state information from the stack.

01:01:56.420 --> 01:02:00.580
And Thursday morning,
we'll all be there for the

01:02:00.650 --> 01:02:06.170
network feedback forum,
which is in room J1, just next.

01:02:06.180 --> 01:02:06.990
It's always fun.

01:02:07.010 --> 01:02:10.650
So with that, you know who to contact.

01:02:10.650 --> 01:02:12.920
Contact my boss, Vincent.
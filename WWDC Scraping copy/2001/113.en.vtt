WEBVTT

00:00:01.820 --> 00:00:04.860
Hi, Bonjour, je l'essaye.

00:00:04.890 --> 00:00:09.790
I'd like to welcome you to session 113,
Text on Mac OS X.

00:00:10.410 --> 00:00:13.470
This session will focus on the
technologies that will enable

00:00:13.470 --> 00:00:18.000
a Carbon application to display
text correctly on Mac OS X.

00:00:18.110 --> 00:00:21.340
When I say correctly, I mean two things.

00:00:21.490 --> 00:00:24.770
First, the text has to be in UniCode,
and you need to support

00:00:24.890 --> 00:00:26.300
multilingual text.

00:00:26.400 --> 00:00:30.580
Mac OS X is an international OS,
and you see it Monday with Avi.

00:00:30.790 --> 00:00:33.890
We're going to be shipping a new version
of Mac OS X with support with Korean,

00:00:33.890 --> 00:00:37.200
Chinese, and other languages in Europe.

00:00:37.280 --> 00:00:40.200
And your application
needs to support UniCode.

00:00:40.230 --> 00:00:44.160
UniCode is like, you know,
the standard for encoding text now.

00:00:44.360 --> 00:00:48.030
The second point, which is very important
for our customers,

00:00:48.060 --> 00:00:51.500
is you need to use Quartz
rendering to display the text.

00:00:51.670 --> 00:00:58.270
Quartz is a powerful 2D rendering engine
that gives to Mac OS X its special taste.

00:00:58.370 --> 00:01:01.600
The nice anti-aliasing on the text,
the drop shadows.

00:01:01.710 --> 00:01:03.690
You need to use Quartz
to render your text.

00:01:03.800 --> 00:01:07.090
You don't want your text
to stick like a sore thumb.

00:01:07.150 --> 00:01:09.940
if you still use the
Quick Draw rendering.

00:01:12.200 --> 00:01:13.790
Excellent.

00:01:13.970 --> 00:01:16.440
In this session,
we'll discuss as well MLT,

00:01:16.440 --> 00:01:18.900
which is the Multilingual Text Engine.

00:01:18.930 --> 00:01:22.130
Last year in this same room,
I discussed MLT, the benefits,

00:01:22.130 --> 00:01:24.710
the features,
and how it could be implemented

00:01:24.710 --> 00:01:26.100
in your application.

00:01:26.130 --> 00:01:31.290
We got tremendous feedback from MLT,
and I'd like to show you a

00:01:31.340 --> 00:01:36.420
couple of applications that
are using MLT and are shipping,

00:01:36.420 --> 00:01:37.520
actually.

00:01:37.520 --> 00:01:37.670
Some of them are shipping right now.

00:01:37.670 --> 00:01:37.670
I'll start with

00:01:38.600 --> 00:01:40.120
Acrobat Reader.

00:01:40.120 --> 00:01:42.880
We're very pleased Acrobat
has been using MLT.

00:01:42.880 --> 00:01:46.800
For instance,
here you can see in the Find window.

00:01:46.800 --> 00:01:49.720
And Acrobat needed to support UniCode.

00:01:49.720 --> 00:01:52.720
And they had their
implementation using TextEdit.

00:01:52.720 --> 00:01:56.960
And MLT fitted very well in this
integration towards Mac OS X.

00:01:56.960 --> 00:01:59.400
With MLT,
they get the Quartz anti-aliasing

00:01:59.400 --> 00:02:03.680
and the UniCode support they
needed in their edit text fields.

00:02:07.020 --> 00:02:10.940
Another client of MLT and we're very
happy that they're using it is Maya.

00:02:10.940 --> 00:02:14.870
Maya is a huge application,
and when they had to find a way

00:02:14.870 --> 00:02:18.570
to render their text in Mac OS X,
they used MLT.

00:02:18.650 --> 00:02:20.240
MLT was their choice.

00:02:20.290 --> 00:02:22.790
Here they get, for instance,
in the script editor,

00:02:22.790 --> 00:02:25.030
they have a full MLT object
with the scroll bars.

00:02:25.230 --> 00:02:29.200
They support UniCode text,
and the text is anti-aliased correctly.

00:02:31.900 --> 00:02:33.880
Another client,
and we're very pleased of that

00:02:33.900 --> 00:02:36.240
because we think it's very
important for the platform,

00:02:36.340 --> 00:02:37.800
is of course, ResourceSerer.

00:02:37.800 --> 00:02:42.760
I'm sure all of you know ResourceSerer,
and here, ResourceSerer implements

00:02:42.770 --> 00:02:44.320
MLT as a UTXT editor.

00:02:44.320 --> 00:02:47.120
A lot of the strings you're going
to be passing to Apparence Manager,

00:02:47.230 --> 00:02:49.580
for instance, have to be Unicode.

00:02:49.580 --> 00:02:51.460
Well,
now with a new version of ResourceSerer,

00:02:51.470 --> 00:02:54.760
and thanks to MLT,
the Multilingual Text Engine,

00:02:54.760 --> 00:02:58.130
you're going to be able to have
Unicode resources in your application,

00:02:58.130 --> 00:03:00.380
so you don't have to do a
CFString and convert your text

00:03:00.550 --> 00:03:04.700
from Mac OS X encodings to Unicode,
and then pass it to MLT,

00:03:04.760 --> 00:03:07.900
DrawTheme TextBox, or other APIs.

00:03:07.900 --> 00:03:11.430
Another great feature that I really
like in the new ResourceSerer

00:03:11.740 --> 00:03:13.690
is actually the Unicode Viewer.

00:03:13.890 --> 00:03:17.910
They implemented in Resourcer
this window that shows you all

00:03:17.910 --> 00:03:21.800
the character sets for UniCode,
the 65,000 characters.

00:03:21.800 --> 00:03:24.790
So you could change the font and you'd
be able to see all the characters.

00:03:24.800 --> 00:03:28.470
Here in this case, they use ATSUI,
or actually the

00:03:28.470 --> 00:03:33.130
TXN Draw UniCode TextBox API,
which enables them once again

00:03:33.150 --> 00:03:37.790
to have the UniCode support
and the great quartz rendering.

00:03:40.320 --> 00:03:44.150
Last, and this is of course just
a couple of our customers,

00:03:44.220 --> 00:03:45.140
the Finder.

00:03:45.170 --> 00:03:46.340
The Finder uses MLT.

00:03:46.590 --> 00:03:49.590
The Finder needs to be
able to enter Japanese and

00:03:49.590 --> 00:03:51.680
Roman text in the text files.

00:03:51.700 --> 00:03:55.490
Well here, in fact,
when you edit text in the Finder,

00:03:55.490 --> 00:03:58.470
in fact, behind is an MLT text object.

00:03:59.040 --> 00:04:00.310
Keycaps, you all know Keycaps.

00:04:00.490 --> 00:04:04.210
Keycaps uses MLT as well and uses
the DrawTheme TextBox APIs to

00:04:04.210 --> 00:04:06.640
display the characters on the keys.

00:04:06.640 --> 00:04:08.850
Another great application, of course,
is WordText,

00:04:08.910 --> 00:04:17.580
which takes power off MLT and shows
advanced typographic features that

00:04:17.580 --> 00:04:17.580
we support on Mac OS X with AppSuite,
Apple-type services for Unicode imaging.

00:04:18.790 --> 00:04:21.140
There are way more customers, of course,
and if you look at the

00:04:21.140 --> 00:04:23.390
Carbon Development List,
you'll see a lot of questions on

00:04:23.390 --> 00:04:25.320
MLTE and a lot of developers using it.

00:04:25.370 --> 00:04:28.060
We're very pleased with what we've been
doing and we're very pleased with the

00:04:28.060 --> 00:04:30.760
feedback that you're giving us so far.

00:04:31.320 --> 00:04:33.360
Now, the agenda for today.

00:04:33.780 --> 00:04:37.260
I'll give you quickly a brief
overview about the text architecture,

00:04:37.260 --> 00:04:40.720
how the solutions we're going to be
talking about today are going to be

00:04:40.810 --> 00:04:44.500
fitting in the Mac OS X overview and
the Mac OS X architecture by itself.

00:04:44.630 --> 00:04:47.470
Then John Harvey,
our senior architect on MLT,

00:04:47.470 --> 00:04:51.130
will be talking about what
APIs you're going to be able

00:04:51.130 --> 00:04:53.240
to use to display static text.

00:04:53.320 --> 00:04:55.600
Last year,
actually at the same conference,

00:04:55.710 --> 00:04:58.680
we got a lot of feedback and
a lot of people wanted to have

00:04:58.800 --> 00:05:00.580
a UniCode Text Edit Control.

00:05:00.730 --> 00:05:04.780
They wanted the toolbox to have
an MLT control in the toolbox.

00:05:04.860 --> 00:05:07.610
What I'm glad to say,
with the new version of Mac OS X,

00:05:07.610 --> 00:05:10.550
the one that has shipped in March,
you have actually this

00:05:10.550 --> 00:05:11.700
control and you can use it.

00:05:11.810 --> 00:05:14.590
John will be talking about that as well.

00:05:15.160 --> 00:05:15.640
Thank you.

00:05:15.640 --> 00:05:17.000
We'll talk about that, don't worry.

00:05:17.160 --> 00:05:18.840
And then of course we still have MLT.

00:05:18.840 --> 00:05:21.920
If you need more control,
if you want support for drag and drop,

00:05:22.090 --> 00:05:28.820
if you want support for embedded objects,
we'll talk a bit about how you

00:05:28.820 --> 00:05:28.820
can do that once again with
a Multilingual Text Engine.

00:05:30.800 --> 00:05:33.340
And we have a special guest.

00:05:33.340 --> 00:05:37.290
We worked very closely with Metro-ERC,
and happy to say that actually,

00:05:37.290 --> 00:05:40.550
Metro-ERC, in the next release,
will implement a couple of

00:05:40.620 --> 00:05:42.620
new classes in Power Plant.

00:05:42.650 --> 00:05:44.320
So in Power Plant,
you'll be able to drag and

00:05:44.370 --> 00:05:48.260
drop an object and you get all
the MLT support you wanted.

00:05:48.350 --> 00:05:51.980
Greg Dow, the architect for Power Plant,
will be here and come on stage and

00:05:51.980 --> 00:05:55.020
show you a demo of his implementation.

00:05:55.020 --> 00:05:57.580
The last point that we
talk about is Rick Fabric,

00:05:57.580 --> 00:06:02.020
one of engineers on the MLT team,
will talk about tips and tricks on

00:06:02.020 --> 00:06:04.200
how to use a multilingual text engine.

00:06:04.230 --> 00:06:07.220
Sometimes we get some questions,
since the architecture is different

00:06:07.730 --> 00:06:11.250
between quick draw text and MLT,
and he'll be answering a couple

00:06:11.360 --> 00:06:14.430
of most of the questions,
most of the common questions,

00:06:14.430 --> 00:06:15.860
when we can ask them.

00:06:15.870 --> 00:06:16.780
Pretty interesting.

00:06:16.780 --> 00:06:18.730
I encourage you to stay.

00:06:19.360 --> 00:06:21.320
Quickly, the overview.

00:06:21.530 --> 00:06:23.720
So we'll be talking today
about two different parts.

00:06:23.810 --> 00:06:26.180
The first thing you have to
achieve in your application

00:06:26.500 --> 00:06:28.520
is display some static text.

00:06:28.540 --> 00:06:31.320
And if you use a drawstring,
it's not going to work.

00:06:31.470 --> 00:06:33.800
Or draw text is not going to
work because it's going to work.

00:06:33.880 --> 00:06:36.120
But then the text is going to
be rendered with Quick Draw.

00:06:36.230 --> 00:06:37.180
And you don't want that.

00:06:37.200 --> 00:06:39.150
You don't want your text to stick out.

00:06:39.410 --> 00:06:41.260
You want it to use Quartz.

00:06:41.290 --> 00:06:46.460
And here we talk about solutions to
draw static text using our technologies

00:06:46.470 --> 00:06:48.330
that use Quartz and UniCode.

00:06:48.380 --> 00:06:50.360
The second part,
we'll talk about text editing.

00:06:50.510 --> 00:06:53.460
And here, once again,
you have two different choices.

00:06:53.570 --> 00:06:56.490
We'll talk about the single line control,
which is the toolbox control

00:06:56.490 --> 00:06:58.460
I talked about that uses MLT.

00:06:58.490 --> 00:07:01.380
And in order to display bigger
text areas-- and once again,

00:07:01.380 --> 00:07:03.760
if you want support for
embedded objects like sound,

00:07:03.870 --> 00:07:07.580
picture, or movies,
then you'd be able to use MLT.

00:07:07.600 --> 00:07:11.100
All these technologies use ATSUI.

00:07:11.120 --> 00:07:15.100
ATSUI is the heart or text
rendering on Mac OS X.

00:07:15.120 --> 00:07:17.420
ATSUI is Apple type services
for UniCode imaging.

00:07:17.420 --> 00:07:21.730
And it's a powerful UniCode
layout engine that enables us

00:07:21.730 --> 00:07:25.630
to enter CGK script-- Chinese,
Korean, Japanese-- and give us

00:07:25.640 --> 00:07:28.480
advantage of Quartz rendering.

00:07:28.670 --> 00:07:33.020
MLTE of course uses ATSUI directly and
has its own implementation using ATSUI.

00:07:33.110 --> 00:07:35.520
On top of that,
you'll see that in order to display

00:07:35.550 --> 00:07:39.540
static text and the single line control,
the Apparence Manager is the one

00:07:39.540 --> 00:07:41.700
that will be actually using ATSUI.

00:07:41.800 --> 00:07:47.060
And below all that,
you see that Quartz is the heart

00:07:47.060 --> 00:07:51.700
of our 2D rendering and gives us
a point of flexibility of this new

00:07:51.700 --> 00:07:51.700
architecture to render text on Mac OS X.

00:07:53.750 --> 00:07:55.760
Alright,
in order to talk about these different

00:07:55.760 --> 00:07:59.820
solutions to display text on Mac OS X,
I have to invite on stage John Harvey.

00:07:59.870 --> 00:08:05.280
John Harvey has been working on MLT and
is the architect for the technology.

00:08:10.500 --> 00:08:14.900
Well, it's great to have a chance to come
out and talk to people about the things

00:08:14.900 --> 00:08:20.890
we've been working on for the last year,
and I appreciate your coming.

00:08:22.410 --> 00:08:23.580
There we go.

00:08:23.700 --> 00:08:25.640
So as Xavier said,
I'm going to talk about

00:08:25.850 --> 00:08:28.160
three different areas:
static text drawing,

00:08:28.530 --> 00:08:33.080
drawing a simple text area via
control the way you did it on

00:08:33.080 --> 00:08:35.700
System 9 with the Edit Text control.

00:08:35.840 --> 00:08:38.890
It's exactly the same kind of thing,
except you get all the

00:08:39.010 --> 00:08:44.640
Mac OS X features with this new control:
Unicode editing, Quartz rendering,

00:08:44.840 --> 00:08:47.140
automatic CJK support.

00:08:47.260 --> 00:08:51.640
And then finally,
we'll talk a lot about building

00:08:51.640 --> 00:08:54.480
your own text area using MLTE.

00:08:54.640 --> 00:08:58.890
It's not that complicated,
but obviously there's more APIs and

00:08:58.900 --> 00:09:03.510
so on you need to be involved in
than if you just use the control.

00:09:04.420 --> 00:09:07.700
Okay, so displaying static text.

00:09:07.720 --> 00:09:11.410
There's basically two
approaches you can use on 10.

00:09:11.490 --> 00:09:16.410
You can use the theme text APIs,
which are really pretty nice,

00:09:16.440 --> 00:09:20.650
because they bring together all
the parts you need to deal with to

00:09:20.690 --> 00:09:23.670
get the right look in your text,
you know.

00:09:23.730 --> 00:09:27.600
The theme text APIs,
they know about what is the localization,

00:09:27.600 --> 00:09:30.560
they know about what the theme
appearance should look like,

00:09:30.610 --> 00:09:34.550
they know about the state
of whatever that text is.

00:09:34.620 --> 00:09:38.940
And then if you really want a lot
of control and like an incredibly

00:09:39.110 --> 00:09:42.780
feature rich set of APIs,
you'd want to use Atsui.

00:09:42.790 --> 00:09:46.340
Now, in this session,
I'm not going to talk any more

00:09:46.340 --> 00:09:48.510
about Atsui rather than to say that.

00:09:48.710 --> 00:09:50.940
There wasn't drawing with Atsui session.

00:09:50.940 --> 00:09:52.960
There'll be feedback for them.

00:09:53.130 --> 00:09:56.820
But it's just important to know
that if you really want to get

00:09:56.820 --> 00:10:00.560
down and have fine-tuned text,
those APIs are going to be there.

00:10:00.560 --> 00:10:01.690
And those APIs are available.

00:10:01.740 --> 00:10:08.070
But we'll talk about the theme
text APIs for static text.

00:10:09.450 --> 00:10:10.830
Okay, so here's the set.

00:10:10.940 --> 00:10:13.030
It's a pretty small set.

00:10:13.070 --> 00:10:16.200
Obviously the first thing you
want to do is render text.

00:10:16.280 --> 00:10:19.060
For that, there's Draw Theme Text Box.

00:10:19.110 --> 00:10:21.290
It's basically the same kind
of functionality you got

00:10:21.400 --> 00:10:25.600
from the TextEdit text box,
but you get your quartz rendering,

00:10:25.600 --> 00:10:29.090
which you can see we're going
to emphasize over and over again

00:10:29.100 --> 00:10:33.520
how important that is to have.

00:10:34.200 --> 00:11:37.100
[Transcript missing]

00:11:37.360 --> 00:11:39.470
Okay, and finally,
I think a nice thing is

00:11:39.470 --> 00:11:41.530
the truncate theme text.

00:11:41.610 --> 00:11:47.290
On 9, you used to have to call,
I think it's a text utility function

00:11:47.290 --> 00:11:50.740
to get a truncated string back,
and then you'd have to go

00:11:50.740 --> 00:11:52.100
to Quick Draw to render it.

00:11:52.150 --> 00:11:56.250
Truncate theme text will
do the rendering for you.

00:11:56.320 --> 00:12:00.100
And, you know, these replace these
old familiar routines,

00:12:00.100 --> 00:12:04.170
and I think a really nice thing is you
don't have to sometimes look in the,

00:12:04.170 --> 00:12:06.500
in text edit,
sometimes look in Quick Draw,

00:12:06.580 --> 00:12:08.700
sometimes look in text utilities.

00:12:08.720 --> 00:12:13.060
They're all there in Appearance Manager,
specifically Appearance.h is the

00:12:13.060 --> 00:12:16.270
header where you can find them.

00:12:16.270 --> 00:12:16.270
Oops.

00:12:17.170 --> 00:12:23.050
Okay, so talk a minute about the
parameters that you pass into this.

00:12:23.800 --> 00:12:26.250
They have the concept of metafon IDs.

00:12:26.290 --> 00:12:28.700
These have been around for a
while in the Appearance Manager,

00:12:28.700 --> 00:12:33.690
but they give you some
really nice control,

00:12:33.690 --> 00:12:38.350
or makes it easy for you to tell what
you want the text to look like without

00:12:38.350 --> 00:12:42.690
having to do all the work you had to do
online where you'd have to go look in the

00:12:42.690 --> 00:12:47.700
Script Manager data structures and things
like that to find what the right text is.

00:12:47.820 --> 00:12:53.700
You use these APIs, you say, "Okay,
I want the views font,

00:12:53.700 --> 00:12:57.700
the push button font,"
something like that.

00:12:57.700 --> 00:13:00.830
The Appearance Manager does all the work,
what's the localization,

00:13:00.830 --> 00:13:03.680
what's the right shadowing,
that kind of thing.

00:13:03.710 --> 00:13:07.700
At the same time,
if you do want to use a font of the port,

00:13:07.700 --> 00:13:11.700
there's a metafont that says,
"Use the information in the port."

00:13:11.700 --> 00:13:17.700
And by using these metafonts,
you don't have to say a font, a style.

00:13:17.710 --> 00:13:19.700
And by using these metafonts,
you don't have to say a font, a style.

00:13:19.700 --> 00:13:24.080
And again, if you wanted to use the
information in the graph port,

00:13:24.080 --> 00:13:31.090
you use the metafont which says,
"Use port information."

00:13:31.550 --> 00:13:34.890
Like I said, these will take care of
appropriate shadowing effects,

00:13:34.890 --> 00:13:38.660
you know, if something's active,
inactive, that kind of thing,

00:13:38.660 --> 00:13:43.400
on the desktop, drawn in white, you know,
the dot kind of text, that thing,

00:13:43.400 --> 00:13:44.500
those things.

00:13:44.710 --> 00:13:48.000
And these are Unicode-savvy.

00:13:48.000 --> 00:13:53.900
One way that they are Unicode-savvy
is when you pass text into these APIs,

00:13:53.920 --> 00:13:55.780
you use a CFStringRef.

00:13:55.780 --> 00:14:00.500
That's really the way to package
Unicode text on Mac OS X.

00:14:00.500 --> 00:14:05.000
And the toolbox deals
completely in those.

00:14:05.030 --> 00:14:07.000
And it's an opaque structure.

00:14:07.000 --> 00:14:08.490
You're probably familiar with it.

00:14:08.500 --> 00:14:12.500
And it will efficiently
store Unicode text in there.

00:14:12.500 --> 00:14:18.930
You just pass it into these functions
or other window titling menu functions,

00:14:18.930 --> 00:14:21.990
and it will draw the text in there.

00:14:24.630 --> 00:14:27.910
Okay, so making sure these
perform at their best,

00:14:28.060 --> 00:14:30.640
there's a few things you can do.

00:14:30.770 --> 00:14:35.130
Where appropriate,
these APIs take a CG context ref.

00:14:35.240 --> 00:14:38.950
Um, now,
if you were allowed to pass null in,

00:14:38.960 --> 00:14:43.660
if you do, the function will create a
CG context ref and then dispose it.

00:14:43.830 --> 00:14:47.160
Obviously, that takes time-- some time,
not a huge amount of time.

00:14:47.160 --> 00:14:49.200
But if you're calling the
function over and over again,

00:14:49.200 --> 00:14:51.300
it's creating, throwing away, creating,
throwing away.

00:14:51.300 --> 00:14:53.040
It's time wasted.

00:14:53.100 --> 00:14:55.460
So you can create your own,
keep it around,

00:14:55.460 --> 00:14:58.500
and just use that to pass in.

00:14:58.570 --> 00:15:02.760
Like anything you code, you know,
be careful how often you measure text.

00:15:02.810 --> 00:15:06.040
Catch the values you get
from measuring the text,

00:15:06.040 --> 00:15:06.500
and so on.

00:15:06.500 --> 00:15:12.460
Don't, like, constantly be calling, um,
the measurement routine all the time.

00:15:12.520 --> 00:15:15.000
Um,
there's a lot more that goes on on 10.

00:15:15.000 --> 00:15:18.400
You know, probably on 9,
it was real easy to just, uh, get,

00:15:18.490 --> 00:15:20.730
you know, text width all the time.

00:15:20.740 --> 00:15:24.330
That was real fast compared
to maybe storing it.

00:15:24.400 --> 00:15:28.500
But it's really--it's important to
think about holding on to those values.

00:15:29.570 --> 00:15:34.870
And of course, in the engineering group,
performance is our utmost concern,

00:15:34.870 --> 00:15:39.160
and so we're working on
speeding things up internally.

00:15:41.150 --> 00:15:45.610
Okay, so next area I'll talk a bit
about the edit text control,

00:15:45.680 --> 00:15:49.850
which, you know,
for your basic editing needs, passwords,

00:15:50.030 --> 00:15:50.760
so on, is there.

00:15:50.760 --> 00:15:54.600
It's real easy to use.

00:15:55.100 --> 00:15:57.200
Oops, keep pointing up at that.

00:15:57.200 --> 00:16:01.940
OK, so again, you use this,
you get quartz rendering for free.

00:16:01.980 --> 00:16:04.980
You don't need to worry about
creating the CG context.

00:16:04.980 --> 00:16:09.730
In this case,
the control does that for you.

00:16:09.740 --> 00:16:14.360
The one thing that's nice
is you use the same control,

00:16:14.560 --> 00:16:18.250
and you'll get built-in
support for CJK input,

00:16:18.250 --> 00:16:22.210
but really there's a lot now on
Mac OS X that has input methods.

00:16:22.210 --> 00:16:27.340
I mean there's UniCode input methods,
hex input methods, things like that.

00:16:27.370 --> 00:16:29.640
You just use this control,
it's all built-in.

00:16:29.640 --> 00:16:31.290
It's different from 9.

00:16:31.340 --> 00:16:34.850
On 9 you had to use,
be sure and use a different proc

00:16:34.850 --> 00:16:37.000
ID if you wanted to care about that.

00:16:37.040 --> 00:16:42.330
And probably diddle around a little
bit with TSMTE and modified dialogue

00:16:42.330 --> 00:16:43.840
structures and things like that.

00:16:43.950 --> 00:16:45.750
But this is,
you don't need to think about it,

00:16:45.750 --> 00:16:47.760
it's just there.

00:16:47.830 --> 00:16:51.300
Which of course is really important
on an international system.

00:16:51.360 --> 00:16:54.860
Again, you know,
this control is built on top of MLTE.

00:16:54.890 --> 00:16:57.350
That's different from
the Edit Text Control,

00:16:57.350 --> 00:16:59.600
which was built on top of TextEdit.

00:16:59.740 --> 00:17:04.240
But it's the same concept, you know,
the basic text engine and then

00:17:04.240 --> 00:17:06.300
the control on top of that.

00:17:06.390 --> 00:17:10.730
If you want to create this control,
well all the controls on 10

00:17:10.730 --> 00:17:13.720
now have a create function,
which is a bit more

00:17:13.720 --> 00:17:15.220
straightforward to use.

00:17:15.400 --> 00:17:19.030
They're only on 10.

00:17:19.170 --> 00:17:23.200
So the old ways of course still work,
new control, get new control.

00:17:23.270 --> 00:17:26.750
And in that case you
have the new proc ID,

00:17:26.830 --> 00:17:30.720
which is K control
edit UniCode text proc.

00:17:32.800 --> 00:17:42.170
Okay, so with that,
we'll move on to the building your

00:17:42.170 --> 00:17:42.170
own text area using MLTE directly.

00:17:43.690 --> 00:17:46.590
So, you know, last year we talked about
some of these features,

00:17:46.590 --> 00:17:48.010
but we want to go over them again.

00:17:48.100 --> 00:17:49.410
People may not have been here.

00:17:49.560 --> 00:17:51.800
People not, you know,
a lot of new developers

00:17:51.800 --> 00:17:57.600
coming over to Mac,
I think, because of System 10.

00:17:57.670 --> 00:18:01.580
Again, this is, on Carbon,
this is the only way you

00:18:01.580 --> 00:18:03.600
can edit UniCode text.

00:18:03.600 --> 00:18:05.540
This is what you use, MLTE.

00:18:05.610 --> 00:18:08.600
There's no more 32K limit.

00:18:08.600 --> 00:18:10.560
That's been said a lot of times.

00:18:10.590 --> 00:18:13.600
It was a big problem in
the past with text edit.

00:18:13.600 --> 00:18:16.970
For years and years, people said,
"Fix that, fix that." Well,

00:18:17.030 --> 00:18:18.600
we didn't fix it in text edit.

00:18:18.600 --> 00:18:19.560
We made a new engine.

00:18:19.600 --> 00:18:22.530
And again,
you get your built-in support for CJK.

00:18:22.530 --> 00:18:24.600
You don't have to worry about it.

00:18:24.600 --> 00:18:28.210
And it's really not right, as I said,
to just say,

00:18:28.210 --> 00:18:32.250
"Build in support for CJK." It's
built-in support for input methods.

00:18:32.250 --> 00:18:35.600
And there can be an input
method for any language now,

00:18:35.630 --> 00:18:39.980
any section of the UniCode character set.

00:18:40.830 --> 00:18:43.850
On the old days,
you had to allocate and hook your

00:18:43.960 --> 00:18:47.390
scroll bars up with text edit
and handle the scrolling there.

00:18:47.390 --> 00:18:48.390
You don't have to do that.

00:18:48.490 --> 00:18:49.790
That's built in.

00:18:49.900 --> 00:18:54.310
Really, everything is handled,
drag and drop,

00:18:54.310 --> 00:18:59.290
any sort of click handling that you had
to deal with a lot of code in the past.

00:18:59.290 --> 00:19:01.600
Well, not a lot,
but a significant amount.

00:19:01.660 --> 00:19:06.100
It's just handled with one function,
the TXN click function.

00:19:06.430 --> 00:19:09.910
We support embedded objects, pictures,
sound, movies.

00:19:09.980 --> 00:19:13.160
There's a single tab per document.

00:19:13.190 --> 00:19:19.120
And we have a multiple undo/redo
stack and also a way to find out

00:19:19.160 --> 00:19:24.460
what the undo/redo action is so you
can then not only just say undo/redo,

00:19:24.460 --> 00:19:29.760
but undo typing, undo cuts,
and that kind of thing.

00:19:30.050 --> 00:19:32.330
And, you know,
again and again we're going to say this,

00:19:32.340 --> 00:19:36.810
you get the quartz rendering,
which is such a signature

00:19:36.810 --> 00:19:38.270
part of Mac OS X.

00:19:40.150 --> 00:19:41.800
Okay, so a quick comparison.

00:19:41.800 --> 00:19:45.590
I talked about how in TextEdit
you had to do work to scroll

00:19:45.590 --> 00:19:49.570
and print and things like that.

00:19:49.720 --> 00:19:53.520
So on TextEdit, you had to write code,
create the scroll bars,

00:19:53.600 --> 00:19:57.480
hook the rectangles up,
deal with offsetting the rack.

00:19:57.500 --> 00:20:01.260
There certainly was a TE click function,
but if you were scrolling,

00:20:01.260 --> 00:20:05.440
there was more that you had
to do than just call TE click.

00:20:05.810 --> 00:20:08.990
All that scrolling is
handled with the TXN click.

00:20:09.050 --> 00:20:14.030
There's one thing you know,
it's the multilingual text engine,

00:20:14.030 --> 00:20:19.590
but for historical reasons,
the APIs begin with the signature TXN.

00:20:21.240 --> 00:20:23.720
So it's building support for clicks.

00:20:23.860 --> 00:20:27.980
That includes drag and drop
and all the highlighting.

00:20:28.020 --> 00:20:31.410
And the other big thing is if
you wanted to print text at it,

00:20:31.490 --> 00:20:35.330
you had to write a fairly
large amount of code.

00:20:35.460 --> 00:20:40.690
And that's just, there's two functions,
TXN page setup and TXN print you

00:20:40.710 --> 00:20:43.170
can call and you get the printing.

00:20:43.480 --> 00:20:48.540
So just to emphasize this,
you can see the difference in lines.

00:20:48.540 --> 00:20:53.620
These 269 lines, these samples are taken
from the TE sample,

00:20:53.620 --> 00:20:56.110
which has been shipping
with all the development

00:20:56.120 --> 00:21:01.290
environments that ever went out,
MetroWorks, MPW.

00:21:01.350 --> 00:21:07.760
There's 269 lines to do these things,
compared to two if you do it in MLTE.

00:21:07.820 --> 00:21:12.580
And on the web, there's a project,
a MetroWorks project,

00:21:12.670 --> 00:21:16.650
which has the old TE sample
and then a new MLTE sample

00:21:16.660 --> 00:21:18.500
built in the same project.

00:21:18.510 --> 00:21:21.170
And you can compare the files,
you can see it's the

00:21:21.170 --> 00:21:22.890
same basic functionality.

00:21:22.900 --> 00:21:27.000
And it's just a lot of code
dropped out of the MLTE version.

00:21:27.070 --> 00:21:30.420
And the nice thing is, you know, I mean,
you need this functionality,

00:21:30.420 --> 00:21:32.720
but you'd really probably
rather not worry about it,

00:21:32.720 --> 00:21:36.630
because you're trying to give
something else to your users,

00:21:36.630 --> 00:21:37.760
your clients.

00:21:37.760 --> 00:21:40.550
So you don't have to anymore.

00:21:41.300 --> 00:21:43.200
Okay,
now something I'm really looking forward

00:21:43.200 --> 00:21:45.240
to because I haven't seen it yet.

00:21:45.250 --> 00:21:48.980
We're going to see the
demo from Greg Dow,

00:21:49.010 --> 00:21:56.490
and I think this is
going to be really great.

00:22:06.800 --> 00:22:09.040
I'm going to quickly just run
through a couple of slides here.

00:22:09.040 --> 00:22:12.600
I think John already mentioned
everything that MLTE and ATSUI and

00:22:12.600 --> 00:22:14.800
themed text drawing can do.

00:22:14.800 --> 00:22:18.110
And what I've done is created some
Power Plant classes that wrap all

00:22:18.110 --> 00:22:21.560
this functionality up into simple,
neat packages that you can

00:22:21.560 --> 00:22:23.730
use directly in Power Plant.

00:22:23.870 --> 00:22:26.770
So I have a class now for MLTE.

00:22:26.790 --> 00:22:29.800
It replaces the existing
text edit classes.

00:22:29.820 --> 00:22:33.140
There's also a class that calls
LThemeTextBox to give you just

00:22:33.140 --> 00:22:36.900
a simple static text caption
that you can use instead of all

00:22:36.900 --> 00:22:39.800
the other Power Plant caption
or static text controls.

00:22:39.800 --> 00:22:43.800
Let me just move quickly
to the demo here.

00:22:43.800 --> 00:22:47.370
This machine's seven.

00:22:51.580 --> 00:22:56.260
I have a project here that I've
built with these new classes.

00:22:56.260 --> 00:22:57.540
I'm just going to run it quickly.

00:22:57.540 --> 00:23:04.680
First thing that comes up
is we have an MLTE pane.

00:23:07.100 --> 00:23:20.900
[Transcript missing]

00:23:23.200 --> 00:23:37.700
[Transcript missing]

00:23:37.990 --> 00:23:41.370
It's giving me the font
menu automatically.

00:23:41.390 --> 00:23:43.220
It builds the font menu for me.

00:23:43.220 --> 00:23:48.130
I can select.

00:23:52.410 --> 00:23:54.390
More readable, bigger.

00:23:54.400 --> 00:23:56.440
Capital's there, different font.

00:23:56.510 --> 00:23:59.310
It also automatically supports

00:24:00.000 --> 00:24:07.100
[Transcript missing]

00:24:09.200 --> 00:24:12.990
There, I automatically get
Japanese characters mixed in

00:24:12.990 --> 00:24:16.620
with the same English characters,
pictures, everything is all wrapped

00:24:16.710 --> 00:24:20.940
together neatly for me by MLTE.

00:24:20.960 --> 00:24:24.700
Undo, redo,
here I can undo what I did there,

00:24:24.700 --> 00:24:29.290
undo a little more,
keep going on the undo here.

00:24:29.300 --> 00:24:30.280
and others.

00:24:30.320 --> 00:24:32.900
"I'm doing the picture drop
and then I can go back,

00:24:32.900 --> 00:24:34.740
redo everything.

00:24:34.740 --> 00:24:37.770
And all this is handled
automatically by MLTE.

00:24:37.780 --> 00:24:41.750
What I did is I took the existing
Power Plant L-Edit text classes,

00:24:41.890 --> 00:24:45.430
pretty much stripped out all the
code in each of the functions

00:24:45.430 --> 00:24:50.080
and replaced it with one or two
lines of text of calls to MLTE.

00:24:50.080 --> 00:24:52.790
So in terms of your code
that uses Power Plant,

00:24:52.980 --> 00:24:54.680
it'll be almost exactly the same.

00:24:54.680 --> 00:24:57.710
The same API, you'll be just calling
into a different object,

00:24:57.880 --> 00:25:01.220
but your calls will all be the same and
it'll just work much better and faster."

00:25:05.600 --> 00:25:11.030
show quickly here's a demonstration of
the theme box theme text box control

00:25:11.340 --> 00:25:15.260
or actually not to control just the
pain one of the problems with this is a

00:25:15.260 --> 00:25:19.620
normal static text control people have
mentions that it automatically erases

00:25:19.770 --> 00:25:22.920
so here you can see that there's the
gray striped background behind the text

00:25:23.060 --> 00:25:27.090
when I have it over a picture if you
don't want that to happen you can use

00:25:27.140 --> 00:25:30.970
the new theme text box class which will
just draw the text directly without

00:25:30.970 --> 00:25:35.670
any erasing and see if I click off it
there the text automatically dims there

00:25:35.670 --> 00:25:39.920
comes back and that's all taken care of
automatically and this is all properly

00:25:39.920 --> 00:25:43.740
anti-aliased here over the picture

00:25:45.690 --> 00:25:48.120
Finally,
I just want to show quickly here at SUI,

00:25:48.120 --> 00:25:51.910
although John didn't mention a lot of
the details of what you can do with it,

00:25:51.910 --> 00:25:54.620
here is a sample here of the
animation I'm doing myself

00:25:54.620 --> 00:25:56.120
just quickly inside a loop.

00:25:56.120 --> 00:25:59.560
What I'm doing is I'm changing the
degree of rotation by five degrees

00:25:59.560 --> 00:26:01.530
each time and then just redrawing.

00:26:01.760 --> 00:26:04.850
And here I'm drawing over a
background picture and all that

00:26:04.970 --> 00:26:06.810
SUI is handling everything for me.

00:26:06.810 --> 00:26:08.570
So there's very flexible text.

00:26:08.570 --> 00:26:11.720
You can set the rotation,
you can set the size, the style,

00:26:11.720 --> 00:26:13.800
and all sorts of other features.

00:26:14.000 --> 00:26:17.470
And all that is wrapped together
in two power plant classes,

00:26:17.600 --> 00:26:20.720
one for handling the text
layout itself and the other

00:26:21.010 --> 00:26:22.890
for handling the ADSUI style.

00:26:22.960 --> 00:26:26.630
And you can take those classes and use
them in a custom pane to draw captions,

00:26:26.720 --> 00:26:29.400
like if you're doing a graph
or something like that,

00:26:29.400 --> 00:26:31.130
we need vertical text on an axis.

00:26:31.370 --> 00:26:36.220
All this is accessible here from
just a couple calls to ADSUI classes.

00:26:38.100 --> 00:26:43.500
and best of all, this is also integrated
now into Constructor.

00:26:43.620 --> 00:26:45.180
quickly here.

00:26:45.180 --> 00:26:47.270
Here's the MLTE pane that I had up there.

00:26:47.340 --> 00:26:49.000
I can just double click here.

00:26:49.000 --> 00:26:53.640
All the options for MLTE are accessible
to you here from the properties.

00:26:53.650 --> 00:26:57.950
I can change the file type
that's associated with the MLTE,

00:26:57.950 --> 00:26:59.170
the encoding.

00:26:59.170 --> 00:27:00.980
Here's some options.

00:27:00.980 --> 00:27:03.710
You probably can't read
all the options here,

00:27:04.000 --> 00:27:06.890
but I can turn off whether
it has scroll bars,

00:27:07.070 --> 00:27:17.190
whether the carrot blinks
in the background or not.

00:27:17.190 --> 00:27:17.190
Let me shrink this one up here.

00:27:17.190 --> 00:27:17.190
Take this

00:27:18.000 --> 00:27:24.190
Let's shrink that a bit and
go back here to the layout

00:27:24.280 --> 00:27:27.790
catalog and drag out a new...

00:27:28.000 --> 00:27:31.040
MLTE pane here,
so I can put a new one right

00:27:31.040 --> 00:27:34.000
next to that one there.

00:27:34.000 --> 00:27:37.110
And if I save this.

00:27:41.200 --> 00:27:47.630
I'll go back to my project and run.

00:27:47.660 --> 00:27:49.710
We'll just bring in the new...

00:27:50.300 --> 00:28:02.600
[Transcript missing]

00:28:04.710 --> 00:28:10.370
Theme text.

00:28:10.390 --> 00:28:11.090
I'm going to close this window here.

00:28:11.090 --> 00:28:11.090
Bring up the, uh, the

00:28:12.630 --> 00:28:15.000
and the Theme text window.

00:28:15.000 --> 00:28:17.530
For the theme text box, again,
I have a couple new options.

00:28:17.540 --> 00:28:20.620
It supports the theme font ID,
so here I've chosen to

00:28:20.620 --> 00:28:22.580
use the current port font.

00:28:22.580 --> 00:28:25.050
I can switch over to use the system font.

00:28:25.100 --> 00:28:28.130
You won't see it updated in Constructor
since Constructor hasn't been

00:28:28.130 --> 00:28:29.640
rebuilt yet with the new classes.

00:28:29.690 --> 00:28:33.490
And maybe I'll turn off--I don't
want it to dim when inactive.

00:28:36.300 --> 00:28:45.600
[Transcript missing]

00:28:48.390 --> 00:28:51.150
through, bring up the theme text,
and now you can see the theme text

00:28:51.150 --> 00:28:54.720
box is again drawn in the system font,
again using the theme font ID so

00:28:54.720 --> 00:28:58.130
you don't have to worry when you're
internationalizing your code,

00:28:58.150 --> 00:29:01.640
whether it's Japanese, Korean, English,
or whatever,

00:29:01.650 --> 00:29:04.840
you'll get the proper system font
without worrying about having to set

00:29:04.910 --> 00:29:07.720
up in PowerPlant now where you have
to make a text trace resource where

00:29:07.720 --> 00:29:09.300
you put the name of the font in there.

00:29:09.300 --> 00:29:11.330
Here you can choose the theme font ID.

00:29:11.330 --> 00:29:14.620
Again, if I click here you can see
there the text doesn't dim,

00:29:14.620 --> 00:29:17.140
I've turned that off,
so you have the option of having

00:29:17.140 --> 00:29:20.580
the text dim or not in the
background depending on your needs.

00:29:20.580 --> 00:29:22.410
So this is all built into PowerPlant.

00:29:22.540 --> 00:29:26.300
Unfortunately, it's not in the version
you have on your CD now.

00:29:26.380 --> 00:29:29.420
That version froze about a month ago
and I didn't have time to update it,

00:29:29.420 --> 00:29:32.200
but it'll be in the next
seed version of PowerPlant,

00:29:32.200 --> 00:29:35.040
which if you haven't signed up already,
you should consider joining the

00:29:35.040 --> 00:29:38.720
MetroWorks Beta program and you can
come by the booth and ask about this

00:29:38.720 --> 00:29:42.510
or check on the website and it'll give
you directions for sending an email

00:29:42.520 --> 00:29:44.300
in to join up on the Beta program.

00:29:44.300 --> 00:29:45.340
Subtitles by the Amara.org
community program.

00:29:45.340 --> 00:29:46.340
Subtitles by the Amara.org
community Thank you.

00:30:02.110 --> 00:30:03.680
Thank you.

00:30:03.740 --> 00:30:07.240
Well, that's really great.

00:30:07.390 --> 00:30:13.210
I mean,
it's so rewarding to work on something,

00:30:13.210 --> 00:30:17.330
and you wonder how much people
use it while you're working on it.

00:30:17.330 --> 00:30:17.330
And then to see that
demo is fantastic for me.

00:30:17.330 --> 00:30:17.330
And really thanks to Greg for doing that.

00:30:17.500 --> 00:30:19.660
I can't wait to start using it myself.

00:30:19.660 --> 00:30:21.500
Make my life a lot easier.

00:30:21.500 --> 00:30:25.260
Okay, so now we'll talk a little
bit about the newer things.

00:30:25.260 --> 00:30:28.040
We'll talk about Quartz rendering again.

00:30:28.270 --> 00:30:34.200
And so Quartz rendering, you know,
over and over again,

00:30:34.200 --> 00:30:34.200
this is what you can get.

00:30:34.710 --> 00:30:38.200
You get your anti-aliasing,
it's a really significant

00:30:38.200 --> 00:30:40.520
part of the look of Mac OS X.

00:30:40.520 --> 00:30:45.540
Also in MLTE, we have the beginning of
support for Carbon Events.

00:30:45.540 --> 00:30:47.930
We're going to extend
this as we go along.

00:30:48.010 --> 00:30:52.190
Right now,
we support text input Carbon Events,

00:30:52.230 --> 00:30:56.520
and I'll talk about some
of what this gives you.

00:30:56.600 --> 00:31:02.210
On System 9, all the input from UniCode
keyboards came through Apple Events.

00:31:02.300 --> 00:31:06.010
Currently on 10 now,
it by default comes through Apple Events,

00:31:06.080 --> 00:31:11.570
but you can tell us to use Carbon Events,
or you can put your own text input

00:31:11.590 --> 00:31:16.530
handler on top of us and do filtering,
which I'll talk about.

00:31:16.630 --> 00:31:19.660
And the other thing we've done is,
where appropriate,

00:31:19.660 --> 00:31:23.380
we haven't changed our APIs,
but underneath, under the hood,

00:31:23.450 --> 00:31:26.540
we've adopted the newer
Mac OS X architecture.

00:31:26.540 --> 00:31:30.540
The specific cases are
printing and the Scrap Manager.

00:31:30.540 --> 00:31:36.000
So we use the promises, things like that,
if you're familiar with the

00:31:36.010 --> 00:31:38.050
new Mac OS X Scrap Manager.

00:31:39.580 --> 00:31:41.260
Okay, so quartz rendering.

00:31:41.260 --> 00:31:43.500
Let's look at how you do this.

00:31:43.500 --> 00:31:46.540
You get your system,
get that right system

00:31:46.700 --> 00:31:50.260
look when you do it,
and it's really pretty simple to do.

00:31:50.310 --> 00:31:54.210
You create a CG context,
and then you hook the CG context

00:31:54.410 --> 00:31:56.480
up with your MLTE object.

00:31:56.580 --> 00:31:57.790
That's all you need to do.

00:31:57.900 --> 00:32:00.680
I can show you the code right here.

00:32:01.350 --> 00:32:03.610
So, there's a few data structures.

00:32:03.650 --> 00:32:07.040
You have your TXN,
the prefaced data structures,

00:32:07.040 --> 00:32:10.140
the control tag and the control data.

00:32:10.200 --> 00:32:14.160
The tag you set with a constant.

00:32:14.200 --> 00:32:18.310
It's actually defined in at atsunicode.h.

00:32:18.400 --> 00:32:19.200
That's the atzui header.

00:32:19.200 --> 00:32:22.200
The other ones are in mactexteditor.h.

00:32:22.200 --> 00:32:27.080
That's where MLTE constants
and functions are defined.

00:32:27.200 --> 00:32:33.200
And then you create your CG context
with the createCGContext for port.

00:32:33.390 --> 00:32:36.200
That's an API in Quick Draw.

00:32:36.200 --> 00:32:39.070
Once that's done and
it's done successfully,

00:32:39.070 --> 00:32:44.200
you plug that into the control data,
the value field,

00:32:44.300 --> 00:32:49.200
and then you just simply call
this TXN setTXNObjectControl.

00:32:49.200 --> 00:32:52.010
Once you've done that,
you get Quartz rendering.

00:32:52.240 --> 00:32:54.890
You don't have to do anything else.

00:32:57.490 --> 00:33:01.400
Okay,
the next thing is the Carbon events,

00:33:01.550 --> 00:33:04.240
text input specifically.

00:33:04.320 --> 00:33:07.900
It's nice to see everything
and then highlight like that.

00:33:07.930 --> 00:33:10.900
Okay,
so we support all the text input events.

00:33:10.900 --> 00:33:13.680
So that includes the text
input event when it's coming

00:33:13.720 --> 00:33:17.330
directly from a keyboard,
and then the text input events

00:33:17.470 --> 00:33:20.510
that come from an input method,
which include all the ones which

00:33:20.570 --> 00:33:23.960
tell me which the input method
might ask where the text is,

00:33:23.990 --> 00:33:28.210
or might ask for the text,
and that kind of thing.

00:33:28.310 --> 00:33:31.880
The nice thing about text input events,
which

00:33:32.110 --> 00:33:42.170
For you, which was very,
very hard to do if close to

00:33:42.170 --> 00:33:42.170
impossible when we used Apple Events,
is you can pre- and

00:33:42.170 --> 00:33:42.170
post-process text input.

00:33:42.750 --> 00:33:47.960
and the other thing to know is that if
you tell MLTE to use text input events,

00:33:47.970 --> 00:33:50.180
that's going to be the optimal path.

00:33:50.240 --> 00:33:55.250
Because right now on 10,
if we are still using Apple events,

00:33:55.370 --> 00:33:59.100
what happens is the text services
manager has to take the text

00:33:59.250 --> 00:34:03.290
input event off the event queue,
pull the data out,

00:34:03.570 --> 00:34:07.720
allocate an Apple event, fill that in,
and then pass that to us.

00:34:07.760 --> 00:34:10.510
I mean it's not something that's
so time consuming that you

00:34:10.510 --> 00:34:14.840
really notice it in your typing,
but if you tell MLTE to use

00:34:14.860 --> 00:34:18.020
a text input event handler,
that doesn't happen.

00:34:18.090 --> 00:34:22.910
The data structure can just move around
the S's without any massaging on the

00:34:22.910 --> 00:34:25.190
part of the text services manager.

00:34:26.460 --> 00:34:27.700
Okay, so how to do this?

00:34:27.700 --> 00:34:30.420
You see this is,
the code is actually very,

00:34:30.480 --> 00:34:34.040
very similar to what we saw
for the CG context draft.

00:34:34.130 --> 00:34:37.950
You've got those same
TXN control data structures.

00:34:38.020 --> 00:34:41.620
This time we use a
constant useCarbonEvents,

00:34:41.640 --> 00:34:44.440
which is in the Mac Text Editor header.

00:34:44.520 --> 00:34:50.540
And we have an array of keys,
an array of values,

00:34:50.570 --> 00:34:53.440
which we'll use to build a CFDictionary.

00:34:53.440 --> 00:34:56.900
We use CFDictionary so we
can include more and more

00:34:57.050 --> 00:34:59.200
Carbon events as appropriate.

00:34:59.280 --> 00:35:02.530
So the expandability is right
there and ready for you,

00:35:02.570 --> 00:35:04.580
or us, ready for everyone.

00:35:04.640 --> 00:35:09.270
Okay, then there's a data structure,
the TXN Carbon event info.

00:35:09.280 --> 00:35:10.780
A few fields you set up there.

00:35:10.780 --> 00:35:14.950
You say, "I'm using Carbon events."
Obviously you can turn them off if

00:35:14.950 --> 00:35:17.430
you want by setting that to false.

00:35:17.490 --> 00:35:21.440
In this case, there's a flag that says,
"I want you to turn off the Apple event

00:35:21.440 --> 00:35:23.440
handlers." This is usually what you do.

00:35:23.440 --> 00:35:30.440
But the thing is that when
you throw this object away,

00:35:30.440 --> 00:35:33.970
if you have other TXN objects,
or there might be other TXN objects

00:35:34.120 --> 00:35:38.010
around in your application,
you want to be sure and tell it to

00:35:38.010 --> 00:35:41.400
turn the Apple event handlers back on.

00:35:41.440 --> 00:35:44.420
Then you create your dictionary
with CFDictionary create,

00:35:44.460 --> 00:35:47.440
one of the core foundation functions.

00:35:47.440 --> 00:35:50.470
And at that point,
you put a pointer to the

00:35:50.770 --> 00:35:53.440
Carbon event info in the value.

00:35:53.440 --> 00:35:57.440
And you call that same function again.

00:35:57.440 --> 00:36:03.360
It hooks it up and
MLTE will start using text,

00:36:03.440 --> 00:36:07.440
handling text input with the Carbon event
handler rather than Apple events.

00:36:07.440 --> 00:36:10.480
And in this case,
you need to be sure and release the

00:36:10.500 --> 00:36:16.410
CFDictionary because all the information
MLTE needs is copied when you call

00:36:16.430 --> 00:36:19.440
the set TXN object control function.

00:36:19.440 --> 00:36:21.430
Very straightforward.

00:36:21.440 --> 00:36:22.440
It's sort of like boilerplate.

00:36:22.470 --> 00:36:23.300
Okay.

00:36:23.450 --> 00:36:27.440
So, I'm going to use the boilerplate now
for telling MLTE what to do on 10.

00:36:30.060 --> 00:36:32.540
Okay, so there's the three topics again.

00:36:32.540 --> 00:36:35.950
And what, I mean,
I'm not going to say anything else.

00:36:36.040 --> 00:36:40.980
There's no slides talking about
the printing or the scrap managers.

00:36:41.000 --> 00:36:43.990
Just as I said before,
we have the exact same

00:36:44.090 --> 00:36:49.530
functions that we had before,
you know, TXN paste, copy cut, TXN print,

00:36:49.530 --> 00:36:50.930
TXN page setup.

00:36:51.050 --> 00:36:54.700
But underneath,
they use the new architectures.

00:36:55.480 --> 00:36:58.950
Okay, so at this point,
I've been working a

00:36:58.950 --> 00:37:01.100
lot with Rick Fabrick.

00:37:01.100 --> 00:37:06.210
He's done most of the work,
or all the work, not all the work,

00:37:06.300 --> 00:37:07.690
but most of the work on CarbonLib.

00:37:07.700 --> 00:37:10.090
And he's had the most
interaction with you,

00:37:10.090 --> 00:37:11.100
the developers.

00:37:11.200 --> 00:37:16.920
And he'll talk about some problems
people have had and issues that

00:37:16.970 --> 00:37:19.670
they weren't sure about that
he's been able to help them with,

00:37:19.670 --> 00:37:22.800
and basically his experience
working with developers.

00:37:22.970 --> 00:37:24.700
Thanks a lot.

00:37:28.880 --> 00:37:30.230
Thanks, John.

00:37:30.230 --> 00:37:34.520
In working with developers who are
integrating MLTE into their applications,

00:37:34.610 --> 00:37:38.860
we get many questions, as John has said,
similar to what's the best way to

00:37:38.980 --> 00:37:40.950
program for this particular task.

00:37:41.060 --> 00:37:47.420
So what we're going to do now is
go over some of the tasks that we

00:37:47.420 --> 00:37:47.420
have received the most questions on.

00:37:48.810 --> 00:37:51.640
What you see here is a list of the
tasks that we'll be discussing today.

00:37:51.690 --> 00:37:54.310
And we'll see this list several
more times as we go through

00:37:54.310 --> 00:37:55.940
each of the tasks individually.

00:37:56.050 --> 00:37:59.450
We're going to be starting with,
what is the best way for you to

00:37:59.450 --> 00:38:01.350
change the size of your text objects?

00:38:01.450 --> 00:38:04.580
And there are some key concepts
to understand in order to get

00:38:04.580 --> 00:38:08.400
the best interaction between
the user and your text object,

00:38:08.460 --> 00:38:11.420
as well as the printout
that you're looking for when

00:38:11.440 --> 00:38:13.270
you print the object out.

00:38:13.910 --> 00:38:17.850
Now the first thing to understand is
what the difference is between the view

00:38:17.850 --> 00:38:22.980
rectangle and the destination rectangle,
and how MLTE defines them.

00:38:23.890 --> 00:38:27.130
So the destination rectangle
defines where the text will

00:38:27.130 --> 00:38:28.760
wrap in your text objects.

00:38:28.880 --> 00:38:33.320
It's the full page of text for your
object and is what would be printed

00:38:33.320 --> 00:38:35.160
out when you print the object out.

00:38:35.240 --> 00:38:38.470
The view rectangle shows the
currently visible portion of the

00:38:38.510 --> 00:38:42.850
destination rectangle and is what
the user sees at any one time.

00:38:42.920 --> 00:38:45.910
Now in MLTE,
the view rectangle includes the

00:38:45.910 --> 00:38:48.240
area taken up by the scroll bar.

00:38:48.320 --> 00:38:51.840
So if you're familiar with the
Mac OS's original text engine,

00:38:51.870 --> 00:38:55.800
the view rectangle in text-edited
objects doesn't include the

00:38:55.800 --> 00:38:58.380
area of the scroll bars,
and that's because text-edited

00:38:58.470 --> 00:38:59.950
objects don't have scroll bars.

00:39:00.160 --> 00:39:03.350
If scroll bars were necessary,
then the developer would have

00:39:03.350 --> 00:39:06.660
to create and manage them
separately from the text object.

00:39:06.720 --> 00:39:12.230
But since MLTE handles the creation and
the event handling automatically for you,

00:39:12.240 --> 00:39:16.340
we do include the areas
from the scroll bars.

00:39:19.770 --> 00:39:23.780
So the initial value of these
rectangles are set when you create

00:39:23.790 --> 00:39:26.650
the object with Tx and newObject.

00:39:26.650 --> 00:39:33.060
This API has a parameter that accepts
either null or a pointer to a rectangle.

00:39:33.100 --> 00:39:36.080
If you passed in null to this API,
what you would get back is an object

00:39:36.200 --> 00:39:38.240
that takes up the entire window.

00:39:38.240 --> 00:39:41.900
Basically the view rectangle
would be the bounds of the window.

00:39:42.090 --> 00:39:48.360
And the destination rectangle would be
set to the standard US letter page size.

00:39:48.360 --> 00:39:52.320
If on the other hand you passed
in a pointer to a rectangle,

00:39:52.320 --> 00:39:56.190
the object that you got back would
only take up a portion of the window,

00:39:56.200 --> 00:39:59.600
and that portion would be equal to
the rectangle that you passed in.

00:39:59.600 --> 00:40:01.740
Now in this case,
the destination rectangle

00:40:01.740 --> 00:40:04.730
would be that rectangle,
but we don't include the scroll

00:40:04.730 --> 00:40:08.060
bars in this case because you
want the text to wrap at the

00:40:08.060 --> 00:40:10.100
scroll bar and not go underneath.

00:40:10.110 --> 00:40:13.300
So let's say you need to
change the size of your object.

00:40:13.300 --> 00:40:16.520
If you had passed a null and your
object takes up the entire window,

00:40:16.520 --> 00:40:19.810
then what you should be calling when
the user is trying to change the size

00:40:19.880 --> 00:40:22.160
of the window is Tx and growWindow.

00:40:22.170 --> 00:40:24.900
And what this will do,
this API changes both the size

00:40:24.900 --> 00:40:28.630
of the window and the view
rectangle for your object.

00:40:28.640 --> 00:40:31.850
But if you had passed in
the pointer to a rectangle,

00:40:31.970 --> 00:40:34.560
you would want to call one of these APIs.

00:40:34.630 --> 00:40:38.450
So let's say you have an object that you
allow the user to change the size of,

00:40:38.560 --> 00:40:42.270
and when the size of the object changes,
you want the text to always

00:40:42.270 --> 00:40:44.160
wrap at the scroll bar.

00:40:44.180 --> 00:40:48.320
In this case you would call the
first API here Tx and resizeFrame,

00:40:48.320 --> 00:40:48.320
passing in the new window.

00:40:48.320 --> 00:40:55.610
So you can see that the text
is always going to be at the

00:40:55.740 --> 00:41:00.490
width and height of your object.

00:41:00.490 --> 00:41:00.490
What this API does is it keeps the
destination rectangle and the view

00:41:00.490 --> 00:41:00.490
rectangle in sync so that the text
will always wrap at the scroll bar.

00:41:01.070 --> 00:41:05.100
Now, let's say you have another object
that when the user changes its size,

00:41:05.100 --> 00:41:07.430
you don't want to change
the size of the text,

00:41:07.500 --> 00:41:11.240
the destination rectangle in your object,
just the view into it.

00:41:11.320 --> 00:41:13.780
In this case,
you would call the second API here,

00:41:13.780 --> 00:41:15.410
TX_IN_SET_FRAME_BOUNDS.

00:41:15.410 --> 00:41:18.120
In this case,
you would be passing in all four

00:41:18.120 --> 00:41:20.640
boundaries of the new view rectangle.

00:41:22.250 --> 00:41:28.040
Now, this API is very handy if your
object takes up the entire window,

00:41:28.040 --> 00:41:31.860
because what it does is...

00:41:32.990 --> 00:41:34.720
Well, actually, I'm not there yet.

00:41:34.900 --> 00:41:37.660
So what this API will do is it's
also helpful when you want to move

00:41:37.660 --> 00:41:40.320
the object around in your window,
because you are passing

00:41:40.320 --> 00:41:41.920
in all four boundaries.

00:41:42.890 --> 00:41:47.120
So we don't offer an API that allows you
to change just the destination rectangle.

00:41:47.160 --> 00:41:51.800
But if you find it necessary
to change the dimensions of

00:41:51.800 --> 00:41:56.490
the destination rectangle,
what you can do is call TXN resize frame,

00:41:56.650 --> 00:42:00.320
passing in the new width and height
of the destination rectangle.

00:42:00.400 --> 00:42:02.650
And what this will do is the
side effect will be that the

00:42:02.720 --> 00:42:06.490
view rectangle will also change,
so then you could call after

00:42:06.490 --> 00:42:11.590
that TXN set frame bounds so that
you can reset the view rectangle

00:42:11.600 --> 00:42:12.800
back to what you want it to be.

00:42:12.800 --> 00:42:13.940
Thank you.

00:42:15.440 --> 00:42:19.080
So we do offer a couple of
options that allow you to change

00:42:19.080 --> 00:42:22.440
the behavior of these API,
and they deal with how the

00:42:22.500 --> 00:42:24.670
text will wrap in your objects.

00:42:25.490 --> 00:42:28.430
and the first option here,
Always Wrap at View Edge.

00:42:28.430 --> 00:42:31.620
If you go back to the example
of your object where you always

00:42:31.680 --> 00:42:34.730
want the text to wrap the edge,
what you could do is pass in

00:42:34.800 --> 00:42:38.160
this mask to Tx a new object
when you create the object.

00:42:38.290 --> 00:42:42.880
And what this option will do is it
will keep the destination rectangle

00:42:42.960 --> 00:42:48.530
always in sync with the view rectangle,
regardless of which of the API you call.

00:42:48.530 --> 00:42:52.670
So what I was going to say before
is if you have a window that the

00:42:52.670 --> 00:42:55.400
object takes up the entire window,

00:42:56.440 --> 00:42:59.400
You're going to have to
call Tx in Grow window.

00:42:59.400 --> 00:43:03.160
And normally this API only changes
the size of the view rectangle.

00:43:03.210 --> 00:43:11.180
But if this option is set,
then the destination rectangle will be

00:43:11.180 --> 00:43:11.180
kept in sync with the view rectangle and
text will always wrap in your window.

00:43:12.810 --> 00:43:17.140
So if you have an object that you
allow the user to edit source code,

00:43:17.140 --> 00:43:18.340
you're going to want
to turn Word Wrap off.

00:43:18.340 --> 00:43:20.840
So our second option
here allows you to do so.

00:43:20.840 --> 00:43:24.460
What you would do is you would pass
in the Word Wrap state tag to the

00:43:24.480 --> 00:43:28.160
API TXN set TXN object controls.

00:43:28.170 --> 00:43:32.360
And what that does is basically
sets the width of the destination

00:43:32.360 --> 00:43:34.100
rectangle to be infinite.

00:43:34.120 --> 00:43:38.000
So text will not wrap unless
the user explicitly enters a

00:43:38.000 --> 00:43:40.190
character that ends a line.

00:43:40.200 --> 00:43:42.810
And one example would be character term.

00:43:43.270 --> 00:43:47.350
So along with the tag,
what you'd want to pass in is a constant

00:43:47.410 --> 00:43:52.350
that is defined in MacTextEditor.h
telling the object whether it

00:43:52.350 --> 00:43:55.000
should be turning WordRef on or off.

00:43:55.330 --> 00:43:58.610
So we offer several API that lets
you change the size of your objects,

00:43:58.610 --> 00:44:02.650
and that gives you the flexibility of
getting the exact behavior that you want,

00:44:02.650 --> 00:44:05.430
and you can have different
types of objects.

00:44:09.380 --> 00:44:13.700
So another task that we've gotten lots of
questions on is how to set the style of

00:44:13.700 --> 00:44:16.950
a certain range of text in your object.

00:44:17.040 --> 00:44:21.660
And in order to do that,
what you would need to call

00:44:21.660 --> 00:44:22.290
is txnSetTypeAttributes.

00:44:22.760 --> 00:44:25.460
What you would do is you would
fill in an array of TX and

00:44:25.460 --> 00:44:28.990
type attributes with all of the
attributes that you want to change,

00:44:28.990 --> 00:44:32.720
and then pass that array into the
API along with a count of the number

00:44:32.720 --> 00:44:34.730
of attributes you're changing.

00:44:35.630 --> 00:44:38.440
What I want you to note here is that you
can change as many of the attributes as

00:44:38.440 --> 00:44:42.880
you want with a single call to the API,
just simply by filling in as many of

00:44:42.880 --> 00:44:45.860
the elements of the array that you need.

00:44:45.930 --> 00:44:50.980
Now along with the array and the count,
you would also be passing in

00:44:51.060 --> 00:44:53.960
the start and end offsets for
the text you want updated.

00:44:53.990 --> 00:44:57.760
So in this case,
when this text gets executed,

00:44:57.840 --> 00:45:00.110
the current selection will become red.

00:45:00.200 --> 00:45:07.590
It will have a font size of 36,
and it will become bold.

00:45:09.170 --> 00:45:12.290
Pretty straightforward.

00:45:12.290 --> 00:45:12.730
Filtering text.

00:45:12.800 --> 00:45:18.180
That's another important thing
that we get questions on.

00:45:18.180 --> 00:45:18.180
And so

00:45:18.470 --> 00:45:20.900
For instance,
you may have an MLTE field that you

00:45:20.900 --> 00:45:25.170
only want numbers to be entered into,
or you want to filter out characters like

00:45:25.170 --> 00:45:27.800
the carriage return or tab character.

00:45:27.850 --> 00:45:30.190
What you would need to do
is install some filters,

00:45:30.340 --> 00:45:34.440
and in this case,
for key events entered from the keyboard,

00:45:34.580 --> 00:45:37.750
these filters take the form
of Carbon event handlers.

00:45:37.790 --> 00:45:40.030
Here's an example of one of them.

00:45:40.890 --> 00:45:43.960
Normally what you would do is
you would install this handler

00:45:44.190 --> 00:45:48.210
to the particular class,
the event class of text input and the

00:45:48.210 --> 00:45:50.400
event kind of UniCode for key event.

00:45:50.480 --> 00:45:52.760
So you wouldn't be doing the test
for those values here in your filter,

00:45:52.760 --> 00:45:55.440
but I put them here so you
can see what their values are.

00:45:55.500 --> 00:45:58.940
This example here basically
just makes sure that all the key

00:45:58.940 --> 00:46:01.150
downs in your object are numbers.

00:46:01.150 --> 00:46:03.900
If they're not numbers,
then they're filtered out.

00:46:05.180 --> 00:46:06.090
So you do your test.

00:46:06.100 --> 00:46:09.100
If you want the text to be
entered into your object,

00:46:09.100 --> 00:46:11.360
then what you would do is you would
return event not handled error,

00:46:11.360 --> 00:46:14.760
telling the Carbon event manager
that you haven't handled the event,

00:46:14.760 --> 00:46:16.740
so pass it on to some
other handler that may.

00:46:16.740 --> 00:46:20.050
And in this case, that would be MLTE.

00:46:20.150 --> 00:46:25.440
If you do want to filter the text out,
then you would return no error,

00:46:25.530 --> 00:46:29.260
telling the Carbon event manager that
you've handled the event with no error

00:46:29.310 --> 00:46:31.210
and nothing else needs to happen.

00:46:31.500 --> 00:46:35.250
So this event handler for UniCode
for a key event will get called

00:46:35.250 --> 00:46:39.690
for every key event that's entered
into the keyboard if there isn't

00:46:39.730 --> 00:46:42.500
an input method handling the text.

00:46:42.530 --> 00:46:46.840
If you do have an active inline area,
however,

00:46:46.870 --> 00:46:51.490
a seconds handler will be called,
and this is the update active input area.

00:46:52.200 --> 00:46:54.550
What you would do here is
basically the same thing,

00:46:54.550 --> 00:46:58.540
but you would need to wait until the
active input area has been confirmed.

00:46:58.540 --> 00:47:01.370
And there's a piece of information
in the event that you can examine

00:47:01.370 --> 00:47:04.140
to tell when this happens.

00:47:04.140 --> 00:47:08.100
When this does happen,
then all you need to do is do your test

00:47:08.180 --> 00:47:10.300
on all of the text that was just entered.

00:47:10.400 --> 00:47:13.340
And part of the data for the
event is the range offset,

00:47:13.340 --> 00:47:17.040
so you know exactly what text to filter.

00:47:17.110 --> 00:47:19.690
And you return the same values
depending on whether you

00:47:19.690 --> 00:47:23.770
want to filter that data in,
filter that data out or let it pass in.

00:47:25.670 --> 00:47:27.260
Normally you wouldn't
have two separate filters,

00:47:27.260 --> 00:47:30.730
you'd have a single one and
you could install it directly

00:47:30.730 --> 00:47:34.850
to the two event kinds,
Update Active Input Area and

00:47:34.850 --> 00:47:37.320
Unicode for Key Event.

00:47:37.800 --> 00:47:42.480
have two filters here so that I can
fit them on a slide--on two slides.

00:47:42.480 --> 00:47:46.800
Okay,
so entering data in from the keyboard is

00:47:46.800 --> 00:47:51.550
one way to get text into your object but
you can also have drag events happening.

00:47:51.550 --> 00:47:55.480
So to be able to filter that data,
you would need to install

00:47:55.550 --> 00:47:56.890
your own drag handlers.

00:47:56.890 --> 00:47:58.350
And it's pretty easy to do.

00:47:58.350 --> 00:48:02.940
The first thing you need to do is tell
MLT not to install its drag handlers,

00:48:02.940 --> 00:48:07.560
and then basically you just install
your drag and drag receive handlers.

00:48:07.560 --> 00:48:10.500
And I'll describe those
two handlers in a second.

00:48:10.730 --> 00:48:13.380
Telling MLTE not to install its
drag handlers is really easy.

00:48:13.400 --> 00:48:15.140
All you do is when you're
creating your object,

00:48:15.140 --> 00:48:20.200
you pass in "Do not install
dragprox mask" to Tx a new object.

00:48:20.200 --> 00:48:23.320
Now,
this mask doesn't disable drag and drop.

00:48:23.620 --> 00:48:26.050
Dragging from your object is
still enabled at this point.

00:48:26.060 --> 00:48:30.440
All it does is it temporarily disables
drags to your object until you've

00:48:30.440 --> 00:48:32.580
installed your own drag handlers.

00:48:33.050 --> 00:48:37.020
So the first drag handler you need to
install is the drag tracking procedure.

00:48:37.330 --> 00:48:42.050
And this handler gets called
continuously as the user is

00:48:42.050 --> 00:48:45.380
dragging the data over your object.

00:48:45.560 --> 00:48:50.300
And MLTE's default behavior
isn't sufficient in most cases.

00:48:50.430 --> 00:48:54.830
So all you would need to
do is pass this event on to

00:48:54.860 --> 00:48:58.020
MLTE by calling txndragtracker.

00:48:58.460 --> 00:49:00.760
In my example here,
I'm doing some eye candy just to show

00:49:00.780 --> 00:49:03.050
you that if you need to do something,
you can.

00:49:03.130 --> 00:49:05.470
But as I said,
MLTE's default behavior is,

00:49:05.530 --> 00:49:08.570
in most cases, sufficient.

00:49:09.320 --> 00:49:13.800
Now the filtering of the data is done
here in your drag-receive procedure.

00:49:13.830 --> 00:49:17.160
And this gets called once when the
user lets go of the mouse button and

00:49:17.160 --> 00:49:19.880
has dropped the data into your object.

00:49:22.020 --> 00:49:25.140
This example here also filters
out anything that isn't a number,

00:49:25.140 --> 00:49:30.500
so the first thing you need to do is
test the data to see if it's all digits,

00:49:30.540 --> 00:49:31.560
all numbers.

00:49:31.600 --> 00:49:37.140
If so, then you want to pass the event on
to MLTE by calling TXN_DRAG_RECEIVER.

00:49:37.180 --> 00:49:42.960
If you do want to filter the text out,
however, you return no error,

00:49:42.960 --> 00:49:46.000
telling the drag manager that you've
handled the event with no error

00:49:46.080 --> 00:49:48.490
and nothing else needs to happen.

00:49:50.330 --> 00:49:55.460
So I've given you some help on
some of the tasks that we've been

00:49:55.460 --> 00:49:57.840
getting questions from you guys.

00:49:57.840 --> 00:49:59.530
If you have any more questions,
and I'm sure you do,

00:49:59.550 --> 00:50:06.640
please stay for the Q&A session at the
end of this session and let us have it.

00:50:06.640 --> 00:50:10.810
At this time,
I'd like to bring Xavier back up

00:50:10.860 --> 00:50:16.500
to go over a quick summary of what
we've been talking about today.

00:50:16.500 --> 00:50:16.500
Xavier?

00:50:16.500 --> 00:50:16.500
Okay.

00:50:16.500 --> 00:50:16.500
Thank you.

00:50:19.700 --> 00:50:27.690
quick wrap-up for this session so once
again you don't want your application to

00:50:27.700 --> 00:50:31.760
stick out like a sore thumb by displaying
text with quick draw text and you want

00:50:31.760 --> 00:50:35.810
your customers to be able to enter unique
code text and use all the power of that

00:50:35.810 --> 00:50:40.670
suey and the quartz rendering once again
all these technologies have been talking

00:50:40.670 --> 00:50:43.810
about today use the power of at sweet
for doing the unique code rendering

00:50:44.310 --> 00:50:48.720
and use the power of quartz to actually
bleed the text correctly with the right

00:50:48.720 --> 00:50:54.000
anti-aliasing so in order to display
text on the Mac OS X please use the

00:50:54.010 --> 00:50:58.420
H I toolbox API's the theme text box
API's are great we're still working

00:50:58.500 --> 00:51:03.130
of course and always making them better
they are like a nice migration for you

00:51:03.200 --> 00:51:05.990
to display text static text correctly

00:51:06.520 --> 00:51:11.410
If you want to have editable text areas,
you have two solutions.

00:51:11.540 --> 00:51:14.900
If you want a quick turnaround,
and let's say you're using

00:51:14.900 --> 00:51:17.850
already the old TextEdit control,
please use the new

00:51:17.850 --> 00:51:19.600
UniCodeEditTextControl.

00:51:19.690 --> 00:51:21.440
John talked about how you can use that.

00:51:21.440 --> 00:51:22.900
It's very straightforward.

00:51:23.030 --> 00:51:28.600
It could be just a matter of using the
new proc ID for the UniCodeTextControl.

00:51:28.910 --> 00:51:32.420
If you need more control, and as we said,
if you need embedded objects,

00:51:32.420 --> 00:51:37.710
if you need support for sound, movies,
and pictures in the object,

00:51:37.710 --> 00:51:41.230
if you want to control yourself,
the score bars, if you want vertical,

00:51:41.270 --> 00:51:44.840
horizontal, if you want drag and drop,
please use the MLT APIs directly.

00:51:44.840 --> 00:51:47.760
I think we showed you that
the set of APIs that we're

00:51:47.840 --> 00:51:49.800
giving you is very powerful.

00:51:49.800 --> 00:51:53.540
In just a couple of calls,
you'll be able to achieve a lot.

00:51:53.640 --> 00:51:57.140
You get not only the support
for multi-lingual text,

00:51:57.140 --> 00:52:01.040
but you'll get as well all these features
that have been missing in TextEdit.

00:52:01.040 --> 00:52:04.490
As you're seeing too, with Power Plant,
if you're using Power Plant,

00:52:04.530 --> 00:52:08.140
you get all these features very
quickly integrated in your application,

00:52:08.250 --> 00:52:11.870
which is going to make your life way,
way easier.

00:52:13.140 --> 00:52:16.220
I'd like to give you some information
on where you can get actual

00:52:16.220 --> 00:52:18.540
information on our documentation.

00:52:18.540 --> 00:52:22.500
We just released the MLT documentation
which has been updated.

00:52:22.610 --> 00:52:24.260
TechPubs has been doing
like a fabulous job with our

00:52:24.260 --> 00:52:28.020
technologies in the last year,
releasing more and more information.

00:52:28.020 --> 00:52:31.070
And I'm glad to say that actually you'll
be able to get the PDF on the web,

00:52:31.070 --> 00:52:34.260
or you can actually get the bone
documentation from FatBrain.

00:52:34.260 --> 00:52:38.410
You have here like, you know,
the two places on the web

00:52:38.410 --> 00:52:40.260
where you can get them.

00:52:40.260 --> 00:52:43.830
We have a lot of sample code that
uses the Multilingual Text Engine.

00:52:43.990 --> 00:52:48.010
And you'll be able actually to find the
latest sample code on the CarbonLib SDK.

00:52:48.140 --> 00:52:50.780
We have as well an MLT SDK,
but the CarbonLib SDK is great

00:52:50.870 --> 00:52:54.290
because we're updated every time
we do a new release for CarbonLib.

00:52:54.350 --> 00:52:56.730
So you'll get there like, you know,
the latest things.

00:52:56.740 --> 00:52:59.510
You'll get like actually the application
that was written just to show the

00:52:59.510 --> 00:53:01.930
migration between text to MLT.

00:53:01.930 --> 00:53:03.700
It's kind of nice.

00:53:03.760 --> 00:53:06.650
AtSuite is the center of text rendering,
and that's like, you know,

00:53:06.650 --> 00:53:08.900
the foundation for all of text drawing.

00:53:09.050 --> 00:53:12.580
Once again, as John said,
you need more control on the layout.

00:53:12.580 --> 00:53:14.240
You really need to
measure the text yourself,

00:53:14.240 --> 00:53:17.220
and you need, let's say you're writing
your own text engine,

00:53:17.340 --> 00:53:21.220
then please check out
Let's Read documentation.

00:53:21.220 --> 00:53:21.760
And here you have it.

00:53:21.760 --> 00:53:23.260
You'll find it on developers.apple.com.

00:53:26.520 --> 00:53:29.760
So where to go from here?

00:53:29.810 --> 00:53:33.010
We didn't talk about Cocoa Text,
but for a very good reason,

00:53:33.050 --> 00:53:37.460
which is Cocoa Text is already ready
for UniCode and supports Quads as well.

00:53:37.510 --> 00:53:40.470
If you need more information about using
text for your next TextView classes,

00:53:40.530 --> 00:53:44.100
for instance in Cocoa,
please go to the session 122 on Thursday,

00:53:44.100 --> 00:53:47.260
which will be actually in this hall.

00:53:47.360 --> 00:53:51.660
Font management is a big, big,
big new thing here on Mac OS X with all

00:53:51.660 --> 00:53:54.120
these new fonts that we support now.

00:53:54.170 --> 00:53:56.770
I encourage you, if you need to have more
information on that,

00:53:56.770 --> 00:54:01.150
to go to session 128,
Thursday at 2 in Room C.

00:54:01.150 --> 00:54:01.150
I'll be there.

00:54:01.320 --> 00:54:03.530
We talked about the Quartz support.

00:54:03.530 --> 00:54:06.050
And if you need more
information about how do I get

00:54:06.120 --> 00:54:09.620
my CG context on my graph port,
how can I manipulate, do rotations,

00:54:09.620 --> 00:54:12.660
skewing, rotation,
all these new things that are supported

00:54:12.660 --> 00:54:19.330
by the Quartz rendering engine,
please go to session 132,

00:54:19.330 --> 00:54:20.710
Graphics and Imaging Tips and Tricks,
in room A2 on Friday at 9:00 AM.

00:54:22.490 --> 00:54:24.240
If you have feedback,
and I'm sure you have,

00:54:24.270 --> 00:54:26.520
and you want to let us know
that we're on the right track,

00:54:26.520 --> 00:54:28.720
you love what we're doing,
or even if you have questions

00:54:28.720 --> 00:54:31.500
and you want to tell us,
hey, I need this API, please come to the

00:54:31.560 --> 00:54:33.400
International Feedback Forum.

00:54:33.400 --> 00:54:36.260
It's a great way for us to
measure what we're doing,

00:54:36.260 --> 00:54:39.580
how much of these answers you need,
and it's a great way as

00:54:39.600 --> 00:54:41.390
well to talk to developers.

00:54:41.500 --> 00:54:44.660
Another great way to talk to our
engineers is to come to more of what

00:54:44.700 --> 00:54:48.550
we call the International Lunch,
where French food will be served,

00:54:48.550 --> 00:54:50.400
in the cafeteria, actually.

00:54:50.400 --> 00:54:54.350
We'll try to get some balloons,
and we'll have different themes going on.

00:54:54.450 --> 00:54:57.210
We'll have a table for if you want to
talk about the font management APIs.

00:54:57.400 --> 00:55:00.470
We'll have a table about text,
and we'll get Cocoa engineers

00:55:00.470 --> 00:55:01.400
as well there.

00:55:01.400 --> 00:55:04.400
So if you have Cocoa and
Carbon questions on the same table,

00:55:04.400 --> 00:55:07.400
you'll be able to get your answers.

00:55:07.400 --> 00:55:09.400
We'll have another table, too,
on localization.

00:55:09.400 --> 00:55:13.400
There is a session that is not there,
but we'll have a session on localization

00:55:13.400 --> 00:55:16.330
and how you can localize your
application for Mac OS X tomorrow,

00:55:16.490 --> 00:55:19.740
Thursday, in Room C at 3:30.

00:55:22.260 --> 00:55:24.830
Should you have any questions,
you can always contact

00:55:24.830 --> 00:55:26.280
me at xavier.apple.com.

00:55:26.280 --> 00:55:28.900
I work in worldwide developer
relations and that's my job to

00:55:28.910 --> 00:55:32.320
answer your needs and to make sure
that the APIs that you want and the

00:55:32.320 --> 00:55:34.600
bugs you want to be fixed are fixed.

00:55:34.600 --> 00:55:35.670
So you can always contact me.

00:55:35.670 --> 00:55:36.230
It's great.

00:55:36.230 --> 00:55:39.150
I have a lot of developers already
contacting me and have been working very

00:55:39.260 --> 00:55:41.960
closely with probably some of you here.

00:55:41.960 --> 00:55:43.430
Don't hesitate to send an email.
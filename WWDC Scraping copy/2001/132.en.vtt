WEBVTT

00:00:07.190 --> 00:00:08.740
Good morning everyone.

00:00:08.740 --> 00:00:11.170
I'm Travis Bruhn,
I'm the Imaging Technology Manager for

00:00:11.170 --> 00:00:14.200
Mac OS X and I want to welcome
everyone to session 132,

00:00:14.200 --> 00:00:16.100
which is Graphics &
Imaging Tips and Tricks.

00:00:16.100 --> 00:00:20.090
What we're going to be talking about
in today's session are two things.

00:00:20.100 --> 00:00:25.100
The first is something we think is a
great opportunity for Carbon developers.

00:00:25.350 --> 00:00:30.610
And that is to better define
for you the interaction between

00:00:30.610 --> 00:00:33.100
Quartz 2D and QuickDraw.

00:00:33.100 --> 00:00:37.400
And we think there's a great
opportunity for Carbon applications

00:00:37.400 --> 00:00:43.100
to look at using some of Mac OS X's
very powerful graphic technologies to

00:00:43.110 --> 00:00:48.220
deliver things such as PDF support,
anti-aliased graphics,

00:00:48.220 --> 00:00:52.100
all sorts of interesting possibilities
for features for your users.

00:00:52.340 --> 00:00:54.100
Secondly, what we'll do is we'll
concentrate on the graphics that

00:00:54.100 --> 00:00:54.100
are available in the Mac OS X.

00:00:54.100 --> 00:00:55.100
We'll focus on the graphics that
are available in the Mac OS X.

00:00:55.100 --> 00:00:59.150
on performance issues
with Quartz in general.

00:00:59.230 --> 00:01:02.810
Quartz has a piece that we've talked
about a little bit during this

00:01:02.840 --> 00:01:06.690
WWDC called the Quartz Compositor,
which essentially abstracts

00:01:06.700 --> 00:01:07.660
you from the screen.

00:01:07.670 --> 00:01:11.040
Unlike Mac OS 9 and earlier where
you had direct access to the screen,

00:01:11.040 --> 00:01:12.670
you don't have that intent.

00:01:12.720 --> 00:01:15.810
And therefore,
there's a little knowledge we

00:01:15.810 --> 00:01:19.670
need to communicate with you with
regards to how to optimize your

00:01:19.680 --> 00:01:23.170
application in this environment where
your pixels are essentially being

00:01:23.180 --> 00:01:24.700
buffered by the Quartz Compositor.

00:01:24.700 --> 00:01:28.180
So I'd like to get started because we
have a lot of information for you today.

00:01:28.180 --> 00:01:31.060
So let me introduce David Gelfman,
who will continue the

00:01:31.060 --> 00:01:32.920
presentation from here.

00:01:37.400 --> 00:01:38.500
Hi, I'm David Gelphman.

00:01:38.620 --> 00:01:39.750
Can you hear me?

00:01:39.770 --> 00:01:40.540
Okay.

00:01:40.540 --> 00:01:41.100
I'm David Gelphman.

00:01:41.100 --> 00:01:43.840
I work in the graphics and imaging group,
primarily on printing,

00:01:43.850 --> 00:01:45.970
but that sort of takes me
off into some other areas,

00:01:45.970 --> 00:01:47.800
so I get to do a little
bit of work in QuickDraw,

00:01:47.800 --> 00:01:50.830
a little bit of work in
the Quartz 2D system.

00:01:50.980 --> 00:01:54.480
So, as I was lying awake in bed last
night thinking about this talk

00:01:54.590 --> 00:01:57.610
and sort of anticipating it,
you might say,

00:01:57.610 --> 00:02:01.900
I thought about the first developer
conference that I came to in 1987.

00:02:01.900 --> 00:02:06.110
And at that conference,
Apple had just recently introduced

00:02:06.110 --> 00:02:11.930
the Mac 2 and was new technology,
was color QuickDraw,

00:02:12.310 --> 00:02:15.900
and Apple had sort of hidden in
the background some new stuff

00:02:15.900 --> 00:02:16.900
they were going to show us.

00:02:16.900 --> 00:02:18.900
It was something called Multifinder.

00:02:18.900 --> 00:02:19.900
Does anybody remember that?

00:02:19.900 --> 00:02:20.910
Oh, yeah.

00:02:21.230 --> 00:02:22.890
So, yeah.

00:02:23.060 --> 00:02:27.740
So, to me it's really exciting to
be here talking about something

00:02:27.740 --> 00:02:33.100
besides QuickDraw in the most part,
Core Graphics, Quartz 2D as we call it.

00:02:33.100 --> 00:02:36.900
And here's the agenda for today.

00:02:38.050 --> 00:02:42.930
We're going to start talking about
how you can use Quartz 2D in your

00:02:43.330 --> 00:02:46.000
Carbon-based application on Mac OS X.

00:02:46.000 --> 00:02:49.000
The Cocoa people, for the most part,
get it free.

00:02:49.000 --> 00:02:50.000
It's easy to use it.

00:02:50.000 --> 00:02:54.000
They have cover routines for a lot
of the functions that you might use.

00:02:54.000 --> 00:02:59.000
But we're going to talk about how you
can use it in your Carbon application.

00:02:59.000 --> 00:03:04.000
That sort of leads us to talking
some about printing on Mac OS X.

00:03:04.030 --> 00:03:06.200
Specifically,
we're going to focus a lot on the

00:03:06.300 --> 00:03:08.000
Carbon printing graph port on Mac OS X.

00:03:08.000 --> 00:03:12.000
It's a different kind of graph port
than you've seen before on Mac OS.

00:03:12.060 --> 00:03:15.000
And I think you'll see that we've
done some interesting things there.

00:03:15.000 --> 00:03:18.300
Then my colleague Ralph Bruhner
is going to follow up and talk

00:03:18.300 --> 00:03:21.000
about performance tuning of your
application when you use Quartz,

00:03:21.000 --> 00:03:25.800
or just when you use
anything in Carbon and Cocoa.

00:03:27.020 --> 00:03:30.420
So just as a way of
sort of getting started,

00:03:30.500 --> 00:03:32.940
as you've hopefully seen
during the conference,

00:03:32.940 --> 00:03:35.800
Quartz has very powerful 2D capabilities.

00:03:35.850 --> 00:03:39.880
The imaging model of the Quartz
2D system is consistent with

00:03:39.880 --> 00:03:42.060
the PostScript imaging model,
which is a very powerful,

00:03:42.060 --> 00:03:44.520
mature imaging model.

00:03:44.750 --> 00:03:47.360
For those of you that have been
using PostScript generation yourself,

00:03:47.430 --> 00:03:49.900
or you've been using
PostScript picture comments,

00:03:49.960 --> 00:03:52.460
we think that you're going to
want to move over and start

00:03:52.460 --> 00:03:55.590
using Quartz 2D instead of
generating your own PostScript.

00:03:55.650 --> 00:03:58.720
This is going to have some
pretty significant improvements

00:03:58.720 --> 00:04:00.100
for your application.

00:04:00.100 --> 00:04:02.900
That is, on all the imaging devices,
when you go to print,

00:04:02.900 --> 00:04:05.560
you're going to see really high quality,
rather than the QuickDraw drawing

00:04:05.630 --> 00:04:08.540
that you were doing when you were
printing to raster devices in the past.

00:04:08.690 --> 00:04:11.090
When you're using Quartz 2D,
you're going to see the

00:04:11.090 --> 00:04:12.330
really high quality.

00:04:12.520 --> 00:04:16.900
Now this talk is going to assume that
you have some familiarity with Quartz 2D.

00:04:16.900 --> 00:04:18.500
We're not going to talk all
about the imaging model.

00:04:18.500 --> 00:04:21.700
I am going to touch on some things
that are relevant specifically for

00:04:21.700 --> 00:04:25.500
people that are probably coming
from a QuickDraw based background.

00:04:25.620 --> 00:04:27.290
And this is just a reminder, a heads up.

00:04:27.290 --> 00:04:32.160
Quartz 2D and Quartz the system
is a Mac OS X only technology.

00:04:32.160 --> 00:04:35.410
It's not something that's in CarbonLib.

00:04:36.960 --> 00:04:40.900
So I'm going to start
by giving a little demo.

00:04:40.980 --> 00:04:44.320
So if we can get the demo
machine up over here.

00:04:48.740 --> 00:04:51.740
So the first thing I have here
is just some really simple

00:04:51.800 --> 00:04:52.640
drawing that we've done.

00:04:52.640 --> 00:04:56.450
Some of this is drawn with QuickDraw,
some of it is drawn with Quartz 2D.

00:04:56.600 --> 00:04:59.650
And I've got the little
pixie application here,

00:04:59.650 --> 00:05:02.350
which is just sort of
a fat bits equivalent.

00:05:02.750 --> 00:05:06.240
where we can magnify the screen,
we can come over here and look at--

00:05:06.240 --> 00:05:09.750
hopefully people can tell which
are the lines that are drawn with

00:05:09.750 --> 00:05:12.450
Quartz 2D and which are the lines
that are drawn with Quickdraw.

00:05:12.620 --> 00:05:15.780
The Quickdraw line,
the ends of the lines have that

00:05:15.780 --> 00:05:17.360
square pin that hangs down.

00:05:17.530 --> 00:05:21.700
You can look with the Pixie application,
if you look over on the right side here

00:05:21.700 --> 00:05:23.880
where we can see how jagged that line is.

00:05:23.880 --> 00:05:26.340
If we move over and we look
at the next line over here,

00:05:26.340 --> 00:05:29.480
of course, we're looking at a line that
was rendered by Quartz 2D.

00:05:29.600 --> 00:05:33.010
If we look at the end of that line,
you can see it's a nice butt end cap.

00:05:33.170 --> 00:05:36.540
It's anti-alias along the line.

00:05:36.610 --> 00:05:38.490
As you're far away,
you probably can't see

00:05:38.490 --> 00:05:39.800
the difference in quality.

00:05:39.860 --> 00:05:42.000
But of course,
if you're looking at a screen

00:05:42.000 --> 00:05:44.600
and you see that anti-alias line,
it really looks a lot better,

00:05:44.600 --> 00:05:45.860
a lot sharper.

00:05:45.860 --> 00:05:48.820
And then of course, just for fun,
I did a little dash line.

00:05:48.820 --> 00:05:52.610
That's something that's
trivial to do using Quartz 2D.

00:05:53.100 --> 00:05:56.320
Now this middle portion here,
I have a couple of ovals.

00:05:56.640 --> 00:05:59.390
And I think as you get far away
it's a little harder to tell,

00:05:59.480 --> 00:06:02.080
but I'll look at it here
with Pixie and you can see.

00:06:02.160 --> 00:06:07.040
Now this is actually not an oval
that I've drawn using QuickDraw.

00:06:07.040 --> 00:06:12.850
What I've done here is I've made an
oval mask region that I use to clip,

00:06:12.940 --> 00:06:15.940
or as a clip region,
that I use to clip some drawing.

00:06:15.940 --> 00:06:18.060
I just have a big rectangle that
I'm clipping through an oval.

00:06:18.130 --> 00:06:22.410
Of course you get essentially the
same result if you do the oval itself.

00:06:22.580 --> 00:06:25.540
But if you look at the edges here,
you can see how jagged it is.

00:06:25.540 --> 00:06:27.670
If we look over here,
what I've done is I've set a clip

00:06:27.890 --> 00:06:29.800
that's the same oval using Quartz 2D.

00:06:29.800 --> 00:06:32.800
And I've just drawn the same rectangle.

00:06:32.800 --> 00:06:35.680
And you can see it's nice
and anti-aliased along here.

00:06:35.680 --> 00:06:40.880
And again, on screen you see this jagged
behavior with QuickDraw.

00:06:40.880 --> 00:06:42.070
And of course it looks nice and smooth.

00:06:42.170 --> 00:06:45.900
Now one of the reasons I did this as a
clip rather than just drawing an oval,

00:06:45.900 --> 00:06:48.820
when you go to print,
if you've done clipping,

00:06:49.330 --> 00:06:51.880
what we do is we're going to take the,
if you've done clipping with QuickDraw,

00:06:51.900 --> 00:06:55.400
we're going to take that region
clip that you've supplied and we're

00:06:55.440 --> 00:06:58.250
going to turn that into a path,
a Quartz 2D path.

00:06:58.320 --> 00:07:02.530
And when we do that, well,
regions are device dependent.

00:07:02.980 --> 00:07:05.020
They are resolution specific.

00:07:05.130 --> 00:07:06.990
So to do that,
what we're going to do is we're

00:07:07.040 --> 00:07:10.230
going to make a little path that's a
bunch of jagged lines just like that.

00:07:10.410 --> 00:07:11.240
And that's what you're going to see.

00:07:11.320 --> 00:07:14.360
Now if you draw using Quartz 2D,
what you're going to see at print time is

00:07:14.490 --> 00:07:16.230
you're going to see a nice smooth clip.

00:07:16.320 --> 00:07:18.480
So of course, you know,
you wouldn't really

00:07:18.480 --> 00:07:21.320
draw an oval this way,
but this is just to give you an idea of,

00:07:21.320 --> 00:07:25.130
what kinds of things you can do
with Quartz 2D and how that actually

00:07:25.130 --> 00:07:27.390
translates into your real imaging.

00:07:27.780 --> 00:07:30.220
The last thing here,
I've got some text here on the

00:07:30.220 --> 00:07:33.120
left hand side I've drawn text with
QuickDraw and on the right hand

00:07:33.120 --> 00:07:34.940
side I've done text with Quartz 2D.

00:07:34.940 --> 00:07:38.330
One of the things that
especially small point sizes,

00:07:38.350 --> 00:07:40.750
it's a little hard with Pixie to see,
I hope you can see it

00:07:40.780 --> 00:07:41.440
when you display it.

00:07:41.510 --> 00:07:44.830
The difference of course with the
text with Quartz 2D is anti-alias,

00:07:44.830 --> 00:07:46.200
nice clean looking text.

00:07:46.340 --> 00:07:49.300
One thing that's really nice is
the weight of the text as you

00:07:49.330 --> 00:07:52.040
go through the point sizes with
this sort of waterfall text.

00:07:52.040 --> 00:07:54.620
The weight's nice and consistent,
looks real smooth.

00:07:54.950 --> 00:07:59.430
When you look with QuickDraw you tend
to see sort of the chunky gradations

00:07:59.440 --> 00:08:03.470
as the text increases in point size.

00:08:07.710 --> 00:08:10.670
On this page what I have is
a couple different things.

00:08:10.800 --> 00:08:12.100
First of all,
I mean I've already shown you

00:08:12.280 --> 00:08:15.290
we're mixing Quartz 2D drawing
with QuickDraw in a window here,

00:08:15.310 --> 00:08:20.600
but I just got a picture here that I'm
drawing with QuickDraw using DrawPicture.

00:08:20.600 --> 00:08:24.920
And I've also taken some text
using Atsui text drawing and we

00:08:24.920 --> 00:08:29.300
can apply the usual Quartz 2D
transformations to the coordinate

00:08:29.300 --> 00:08:30.510
system and get different effects.

00:08:30.620 --> 00:08:32.160
I haven't done anything
particularly fancy,

00:08:32.160 --> 00:08:33.550
but it's really trivial to rotate text.

00:08:33.630 --> 00:08:37.600
If you want to supply other
special effects you can do that.

00:08:37.720 --> 00:08:39.600
One thing I put on here because
I want to emphasize something

00:08:39.600 --> 00:08:42.060
I think is really important,
we'll talk a little bit

00:08:42.060 --> 00:08:44.600
about it in just a second,
about the details of how to do it.

00:08:44.600 --> 00:08:49.600
But this zebra picture here is a PDF file
that I've just drawn on my page here.

00:08:49.600 --> 00:08:52.570
And the zebra that's rotated
I've done the same way.

00:08:52.600 --> 00:08:53.600
It's just a PDF that I'm drawing.

00:08:53.600 --> 00:08:57.600
I've rotated the coordinate system
before I've drawn it using Quartz 2D.

00:08:57.740 --> 00:09:00.600
But I do want to emphasize it's really
easy to support PDF in the system.

00:09:00.600 --> 00:09:02.600
It's just essentially
like drawing a picture.

00:09:02.600 --> 00:09:03.600
Very simple.

00:09:03.600 --> 00:09:04.580
Very easy to do.

00:09:04.720 --> 00:09:07.740
And even if you're not thinking of
adopting some of the other things

00:09:07.740 --> 00:09:11.850
that we're doing with Quartz 2D,
consider seriously adding

00:09:11.850 --> 00:09:14.600
PDF support to your application.

00:09:14.630 --> 00:09:16.600
Now I did a little thing in here for fun.

00:09:16.600 --> 00:09:17.990
Oops, excuse me.

00:09:18.560 --> 00:09:22.610
Which is,
I applied a clip now to the drawing right

00:09:22.740 --> 00:09:24.900
before I actually drew that last zebra.

00:09:25.010 --> 00:09:27.190
So I drew a text character,
but before I actually

00:09:27.320 --> 00:09:29.730
drew the text character,
I set the text rendering mode

00:09:30.310 --> 00:09:33.060
in Quartz 2D to be a clip.

00:09:33.150 --> 00:09:34.960
Then after I did that, I drew the zebra.

00:09:35.220 --> 00:09:36.560
I just drew the PDF.

00:09:36.640 --> 00:09:39.500
It's really easy to get
these kinds of effects.

00:09:39.570 --> 00:09:44.440
Okay,
so let's go back over to the slides.

00:09:47.420 --> 00:09:52.100
Can we go back over to the slides please?

00:09:52.100 --> 00:09:52.100
Thank you.

00:09:52.120 --> 00:09:54.800
Okay,
so I told you how easy PDF import is,

00:09:54.800 --> 00:09:56.560
I'm going to show you how easy it is.

00:09:56.580 --> 00:09:59.980
Now of course, this little example is
importing from a file.

00:09:59.990 --> 00:10:02.540
I've assumed that you already have
an FSRef that points to a file.

00:10:02.600 --> 00:10:05.230
If you don't have an FSRef,
but you have an FSSpec,

00:10:05.240 --> 00:10:07.470
there's an easy way to get an FSRef.

00:10:07.920 --> 00:10:11.480
From the FSRef you can create a URL,
CFURL.

00:10:11.490 --> 00:10:13.900
This is part of Core Foundation.

00:10:13.920 --> 00:10:17.390
Once you have a CFURL,
you can make a call that's

00:10:17.390 --> 00:10:19.640
part of Core Graphics,
part of Quartz 2D,

00:10:19.690 --> 00:10:22.850
CGPDF document create with URL.

00:10:23.470 --> 00:10:26.300
You get what's called a
PDF document from that.

00:10:26.340 --> 00:10:28.750
That's the doc that I have here.

00:10:28.870 --> 00:10:31.550
From that we can get the media box,
which is essentially the

00:10:31.610 --> 00:10:33.400
bounding box of the graphic here.

00:10:33.400 --> 00:10:34.740
Get the bounding box for that.

00:10:34.740 --> 00:10:38.720
And in this case I'm just going to draw
with that bounding box into my context,

00:10:38.790 --> 00:10:40.400
which is the CTX parameter.

00:10:40.400 --> 00:10:41.270
It's a Quartz 2D context.

00:10:41.320 --> 00:10:43.340
Draw the document.

00:10:43.360 --> 00:10:44.490
That's it.

00:10:44.570 --> 00:10:46.240
That's to draw the first
page of a document.

00:10:46.240 --> 00:10:48.640
You can also find out the number
of pages in the document and so on.

00:10:48.720 --> 00:10:51.410
And there's other bounding boxes that
you can get besides the media box,

00:10:51.410 --> 00:10:52.200
but that's it.

00:10:52.960 --> 00:10:55.580
Now if you say, "Oh,
I don't have my data as a file

00:10:55.680 --> 00:10:58.870
on disk or URL really," because
you can really have URLs here.

00:10:58.870 --> 00:11:03.920
Of course, if you were in the Quartz 2D
discussion you would have heard about

00:11:03.920 --> 00:11:06.810
data providers where you can have,
there's a generalized

00:11:06.900 --> 00:11:10.190
mechanism so you can provide
the data for the PDF document.

00:11:10.200 --> 00:11:12.900
So this was just the
simple one for a file.

00:11:12.900 --> 00:11:16.550
So again,
straightforward use of Quartz 2D drawing,

00:11:16.550 --> 00:11:19.390
even for a QuickDraw based application.

00:11:20.690 --> 00:11:22.600
Okay, so now, how do I get started?

00:11:22.600 --> 00:11:24.240
I'm really piped about doing this.

00:11:24.360 --> 00:11:25.600
Let's get to it.

00:11:25.600 --> 00:11:29.110
Okay, so the first thing, of course,
is you need to have what's called

00:11:29.180 --> 00:11:30.580
a CG context in order to draw into.

00:11:30.670 --> 00:11:32.420
All of the Quartz drawing
routines expect that you're

00:11:32.420 --> 00:11:33.600
going to draw into CG context.

00:11:33.600 --> 00:11:37.590
It's an explicit parameter that you
provide to the drawing routines.

00:11:37.840 --> 00:11:39.600
There's no set port like
there is in QuickDraw.

00:11:39.600 --> 00:11:42.490
You're going to pass in the context
to all of the drawing that you do.

00:11:42.600 --> 00:11:45.600
So the CG context is something like you
might think of as a Quartz drawing port

00:11:45.600 --> 00:11:48.600
instead of a QuickDraw drawing port.

00:11:48.770 --> 00:11:52.880
Now, one thing that's really important to
realize is that a CG context has a

00:11:52.880 --> 00:11:55.600
graphic state that's associated with it.

00:11:55.600 --> 00:11:58.600
QuickDraw graph port does also.

00:11:58.600 --> 00:12:01.540
It has the usual things, the pen size,
the font, the font size,

00:12:01.650 --> 00:12:04.930
the background pattern,
the foreground pattern, you know,

00:12:04.930 --> 00:12:05.540
all of that stuff.

00:12:05.610 --> 00:12:09.240
Well, there's similar kinds of things
that are part of the graphic

00:12:09.300 --> 00:12:12.350
state of the CG context,
such as there's a separate fill

00:12:12.350 --> 00:12:13.600
color and a separate stroke color.

00:12:13.600 --> 00:12:17.200
There's a separate fill color and stroke,
excuse me, separate fill color space

00:12:17.350 --> 00:12:18.590
and stroke color space.

00:12:18.870 --> 00:12:19.570
There's a clip.

00:12:19.640 --> 00:12:20.420
There's a line width.

00:12:20.540 --> 00:12:21.600
Those kinds of things.

00:12:21.600 --> 00:12:23.600
All those parameters
are on the CG context.

00:12:23.790 --> 00:12:26.670
And now, when you get one of these
things from QuickDraw,

00:12:26.670 --> 00:12:29.220
or if you're using QuickDraw at
the same time that you're using a

00:12:29.220 --> 00:12:34.050
CG context that you got for a graph port,
you should realize that those graphic

00:12:34.050 --> 00:12:35.600
states are completely independent.

00:12:35.600 --> 00:12:37.600
There's no sharing of the graphic state.

00:12:37.600 --> 00:12:39.700
If you go and you set a
color on the QuickDraw port,

00:12:39.900 --> 00:12:41.590
that's not reflected in your CG context.

00:12:41.720 --> 00:12:45.180
So when you go to use Quartz 2D,
you're going to set the parameters in

00:12:45.180 --> 00:12:47.580
the Quartz 2D context for your drawing.

00:12:49.890 --> 00:12:52.400
Okay, so let's start just, I think,
some real basics.

00:12:52.400 --> 00:12:53.840
And like I said,
I'm not going to talk a lot

00:12:53.840 --> 00:12:56.670
about how you use Quartz 2D,
but I think these are relevant

00:12:56.840 --> 00:12:59.800
things for developers coming
from a QuickDraw background.

00:13:00.050 --> 00:13:03.860
The first thing is that the
coordinate system is based on the

00:13:03.960 --> 00:13:06.730
PostScript PDF coordinate systems.

00:13:06.850 --> 00:13:09.770
It was a fundamental decision by
Apple to follow the PDF imaging model.

00:13:09.890 --> 00:13:11.800
This is the coordinate system
in the PDF imaging model.

00:13:11.800 --> 00:13:15.280
Standard Cartesian coordinates:
X goes to the right,

00:13:15.280 --> 00:13:20.300
across the screen or across the page,
Y goes up, and the origin is in the lower

00:13:20.300 --> 00:13:27.550
left corner of the window,
or of the port, rather, or of the page.

00:13:27.550 --> 00:13:27.550
Okay?

00:13:28.070 --> 00:13:28.970
So this is what it looks like.

00:13:29.050 --> 00:13:32.630
This is the relationship
between the coordinate systems,

00:13:32.660 --> 00:13:34.860
the QuickDraw coordinate system,
the Quartz2D coordinate system,

00:13:34.960 --> 00:13:38.840
sort of the standard relationship when
you get a CG graphics context for a port.

00:13:39.000 --> 00:13:43.740
The QuickDraw coordinate system,
as always, top left corner, Quartz2D,

00:13:43.920 --> 00:13:45.800
bottom left corner, Y going up.

00:13:46.000 --> 00:13:48.650
Now the relationship between
the origins is initially,

00:13:48.720 --> 00:13:50.970
at least if you haven't
changed the port origin,

00:13:51.030 --> 00:13:55.990
the relationship between the origins
is based on the port rect height.

00:13:56.000 --> 00:13:59.800
That's the height of the port.

00:14:00.710 --> 00:14:03.940
So there's a couple issues if you're
used to drawing with QuickDraw.

00:14:03.990 --> 00:14:06.920
Apps are used to that QuickDraw
coordinate system where it's in

00:14:06.920 --> 00:14:09.020
the top left corner of the port.

00:14:09.060 --> 00:14:12.360
Event coordinates are returned in
the QuickDraw coordinate system.

00:14:12.400 --> 00:14:15.370
In some apps,
when they switch over to using

00:14:15.840 --> 00:14:20.930
the Quartz 2D imaging system,
they sort of want to keep using

00:14:20.930 --> 00:14:24.930
that top left corner with the
coordinate system flipped.

00:14:24.990 --> 00:14:26.100
Okay, well there's a couple ideas.

00:14:26.250 --> 00:14:30.010
One is, you can actually transform
your coordinates on the fly

00:14:30.010 --> 00:14:31.400
yourself if you want to.

00:14:31.450 --> 00:14:35.280
The relationship between the
QuickDraw coordinate system and

00:14:35.280 --> 00:14:38.100
the Quartz 2D coordinate system
I showed you on the picture before,

00:14:38.120 --> 00:14:43.440
you can calculate the port bounds height,
you can compute from a given QuickDraw Y,

00:14:43.440 --> 00:14:48.420
you can compute a Y that would
be suitable for a Quartz 2D

00:14:48.560 --> 00:14:49.940
coordinate system drawing.

00:14:50.020 --> 00:14:51.540
So you can do that yourself.

00:14:51.580 --> 00:14:54.740
Now, there's some disadvantage of just
doing this kind of transformation.

00:14:54.740 --> 00:14:57.320
And one of them is that,
as you start rotating,

00:14:57.320 --> 00:14:59.500
and scaling the Quartz
2D coordinate system,

00:14:59.500 --> 00:15:01.500
something that you
can't do with QuickDraw,

00:15:01.530 --> 00:15:04.520
now this kind of transformation
gets a little messy because now your

00:15:04.520 --> 00:15:06.520
coordinate system is transformed.

00:15:06.670 --> 00:15:09.190
So, just some other ideas.

00:15:09.230 --> 00:15:12.420
Here's what I call approach B,
which was using Quartz itself to

00:15:12.580 --> 00:15:14.780
do coordinate transforms for you.

00:15:14.810 --> 00:15:17.060
Now, when you draw with the
Quartz 2D coordinate system,

00:15:17.060 --> 00:15:19.380
you're drawing in what's
called user space,

00:15:19.390 --> 00:15:21.280
and that's malleable by the application.

00:15:21.280 --> 00:15:24.460
You can scale it, translate it, rotate,
skew it, do whatever.

00:15:24.470 --> 00:15:27.300
And Quartz 2D is always
doing transformations,

00:15:27.300 --> 00:15:30.140
and it transforms on user space
coordinates that are supplied by

00:15:30.140 --> 00:15:32.580
your application when you draw,
into device space,

00:15:32.580 --> 00:15:35.360
or into the space of the actual
device you're drawing on,

00:15:35.360 --> 00:15:37.700
be it a printer, be it on screen,
whatever.

00:15:37.700 --> 00:15:40.730
Now, you can piggyback off of those
transformations that Quartz

00:15:40.730 --> 00:15:44.350
2D is already doing for you,
by simply making your own matrix that

00:15:44.350 --> 00:15:47.590
you can cat to what's called the CTM,
the current transformation matrix

00:15:47.830 --> 00:15:50.020
from user space into device space.

00:15:50.020 --> 00:15:52.000
You can piggyback off
those transformations,

00:15:52.000 --> 00:15:54.020
and that's what I'm doing here.

00:15:54.080 --> 00:15:55.560
So I make up a transform.

00:15:55.560 --> 00:15:57.180
There's in CTM,
there's in the device space,

00:15:57.180 --> 00:15:57.280
and then I make up a transform.

00:15:57.280 --> 00:15:57.310
So I make up a transform.

00:15:57.370 --> 00:15:57.790
So I make up a transform.

00:15:57.790 --> 00:15:58.240
So I make up a transform.

00:15:58.240 --> 00:15:59.110
I'm going to use the CGAffineTransform.h.

00:15:59.200 --> 00:16:02.260
There's a whole bunch of stuff
about transforms you can read about.

00:16:02.490 --> 00:16:04.600
And you can make a translation transform.

00:16:04.600 --> 00:16:08.140
In this case, I'm translating by the
port-bounds height.

00:16:08.160 --> 00:16:13.620
That's the thing that connects the
QuickDraw origin to the Core graphics,

00:16:13.790 --> 00:16:15.800
to the Quartz 2D origin.

00:16:15.810 --> 00:16:18.390
And then, in addition,
I'm going to do a further

00:16:18.390 --> 00:16:21.350
transform on that transform,
by scaling it, by flipping it.

00:16:21.580 --> 00:16:23.700
So I made y minus y.

00:16:23.750 --> 00:16:27.260
So at that point, if I actually take that
transform that I built up,

00:16:27.290 --> 00:16:32.100
this QD transform that I built up,
and I can cap that to the

00:16:32.230 --> 00:16:35.380
coordinate system that's
already part of my context here,

00:16:35.380 --> 00:16:39.700
represented by my context parameter here,
now I have a flipped coordinate system,

00:16:39.750 --> 00:16:42.330
and I have the origin of my
Quartz coordinate system in the

00:16:42.420 --> 00:16:44.100
top left corner of the port.

00:16:44.140 --> 00:16:45.380
Okay?

00:16:45.380 --> 00:16:46.580
Well, it's all great.

00:16:46.580 --> 00:16:47.610
Start drawing your graphics.

00:16:47.670 --> 00:16:48.440
You do your line art.

00:16:48.440 --> 00:16:49.160
You do your ovals.

00:16:49.160 --> 00:16:49.820
You do whatever.

00:16:49.820 --> 00:16:51.490
Well, wait a minute.

00:16:51.500 --> 00:16:54.380
When I go and I start
drawing text using Atsui,

00:16:54.380 --> 00:16:57.240
I find that I've got a little problem.

00:16:57.240 --> 00:16:59.240
I've got a little problem here,
which is my text is flipped.

00:16:59.240 --> 00:17:02.840
Because we flipped the coordinate system,
and when you draw text with

00:17:02.840 --> 00:17:06.360
Atsui into a CG context,
they're expecting upright

00:17:06.430 --> 00:17:08.370
coordinate systems,
and that's flipped.

00:17:08.690 --> 00:17:10.340
OK, well, it's a tips and tricks.

00:17:10.530 --> 00:17:13.000
So here's maybe something
you can consider.

00:17:13.140 --> 00:17:15.200
You could actually modify
the approach a little bit.

00:17:15.200 --> 00:17:17.700
It's a little bit of a pain.

00:17:17.760 --> 00:17:20.230
But what you can do is
before you draw your text,

00:17:20.380 --> 00:17:21.800
you unflip the coordinate system.

00:17:21.810 --> 00:17:23.820
So normally you're going to draw
into a flipped coordinate system.

00:17:23.920 --> 00:17:26.720
But before you go draw in the text,
you're going to unflip it.

00:17:26.720 --> 00:17:30.000
The only thing you have to do
is unflip the coordinate system.

00:17:30.000 --> 00:17:32.650
At that point,
you want to use minus y-coordinates

00:17:32.780 --> 00:17:37.600
instead of y-coordinates because
now you've got the origin in the

00:17:37.790 --> 00:17:39.420
top left corner and y goes down.

00:17:39.680 --> 00:17:41.720
So we'll be using minus y-coordinates.

00:17:41.750 --> 00:17:43.790
But that's what's involved there.

00:17:43.950 --> 00:17:46.960
Okay, now let me just emphasize,
the only reason that you would

00:17:46.960 --> 00:17:50.570
need to consider using some of
these approaches is if you want

00:17:51.210 --> 00:17:54.850
the Quartz 2D coordinate system,
when you go to draw,

00:17:54.870 --> 00:17:56.990
to match the QuickDraw coordinate
system that you're familiar with.

00:17:57.060 --> 00:17:59.360
If you're comfortable drawing
with an upright coordinate system,

00:17:59.360 --> 00:17:59.800
go for it.

00:17:59.800 --> 00:18:00.800
Don't bother with all of this.

00:18:00.800 --> 00:18:04.450
One other thing to say is,
in CGaffinetransform.h,

00:18:04.530 --> 00:18:08.360
in the header file,
there are some additional transforms

00:18:08.360 --> 00:18:12.730
that let you take points and
transform them through the matrix to

00:18:12.730 --> 00:18:14.300
get a new point that's transformed.

00:18:14.300 --> 00:18:17.200
So if you'd rather do your
coordinate transformations using

00:18:17.310 --> 00:18:20.800
CG by transforming the coordinates,
not by transforming the coordinate

00:18:20.800 --> 00:18:25.200
system that's part of the CG context,
you can do that yourself also.

00:18:26.450 --> 00:18:29.300
Let's talk just for a
second about text drawing.

00:18:29.320 --> 00:18:31.830
Hopefully you've had an opportunity
to go to some of the text drawing,

00:18:31.940 --> 00:18:36.300
Carbon text drawing sessions
here at the conference.

00:18:36.300 --> 00:18:41.300
We discourage use of the low
level Quartz API for drawing text.

00:18:41.300 --> 00:18:44.300
It's really not suitable
for international text.

00:18:44.300 --> 00:18:46.910
International text,
I mean if you've seen some of these demos

00:18:46.910 --> 00:18:50.300
and the kinds of things that people need
to be able to do with international text,

00:18:50.560 --> 00:18:56.340
all of that is layered on top
of the Quartz 2D imaging system,

00:18:56.340 --> 00:18:57.490
but they are really
providing the facilities for

00:18:57.520 --> 00:18:59.300
drawing international text.

00:18:59.300 --> 00:19:03.900
So, the recommendation is look
at and use ATSUI and MLTE for

00:19:03.900 --> 00:19:06.300
drawing text into a CG context.

00:19:06.370 --> 00:19:10.300
And they've talked a little bit about
how to do that in those sessions.

00:19:11.670 --> 00:19:14.290
Just to give you an idea of
how straightforward it is,

00:19:14.310 --> 00:19:17.940
if you're already familiar
with using Atsui text drawing,

00:19:17.940 --> 00:19:20.510
you know that you're going to use
a layout for drawing your text.

00:19:20.600 --> 00:19:23.580
All you need to do is
add a tag to that layout.

00:19:23.670 --> 00:19:25.600
That's what I'm doing
here in this sample code.

00:19:25.820 --> 00:19:27.930
Adding a tag to the layout,
then I actually draw the text

00:19:28.050 --> 00:19:29.600
the way I otherwise would have.

00:19:29.630 --> 00:19:32.730
The tag that I'm adding just says
that I'm adding a CG context and

00:19:32.800 --> 00:19:34.600
I pass a pointer to that context.

00:19:34.680 --> 00:19:36.550
So I'm supplying the context to Atsui.

00:19:36.600 --> 00:19:40.640
Now all of the coordinate system
transformations and so on,

00:19:40.640 --> 00:19:44.790
the color, all of those things are
used from the CG context,

00:19:44.790 --> 00:19:47.600
assuming for example the color you
haven't made as part of your layout.

00:19:47.600 --> 00:19:52.600
That would override the color
that would be in the CG context.

00:19:54.060 --> 00:19:58.600
Okay, so I've given you a bit of an idea
about some of the issues maybe

00:19:58.600 --> 00:20:00.200
of drawing with a CG context.

00:20:00.340 --> 00:20:00.880
How do you get one?

00:20:00.880 --> 00:20:05.900
Well, there's a routine,
create CG context for port.

00:20:06.030 --> 00:20:09.900
What that does is, you give it a port,
it gives you a CG context for that.

00:20:09.900 --> 00:20:11.800
You can start drawing
into that CG context.

00:20:11.800 --> 00:20:15.160
There's a couple other helper
routines that you may need to use.

00:20:15.300 --> 00:20:17.680
One of them, I can't say these
without looking at them,

00:20:17.680 --> 00:20:18.140
sorry.

00:20:18.220 --> 00:20:20.400
Sync CG context origin with port.

00:20:20.400 --> 00:20:25.610
What that does is, when you call that,
it resets the current transformation

00:20:25.710 --> 00:20:27.300
matrix on the context of the default.

00:20:27.300 --> 00:20:31.000
That removes any scaling or anything
that you might have provided.

00:20:31.100 --> 00:20:36.370
It then resets the CG context origin so
that it has that relationship between the

00:20:36.470 --> 00:20:39.280
port origin and the CG context origin.

00:20:39.300 --> 00:20:47.820
So, for example, if you've done,
a set origin in QuickDraw, now,

00:20:47.820 --> 00:20:50.700
you want to,
and you want to tell the CG context

00:20:50.700 --> 00:20:53.700
that you're using associated with
that port that you've done that,

00:20:53.700 --> 00:20:54.700
that's when you call this routine.

00:20:54.700 --> 00:20:57.780
Then there's also a clip
CG context to region,

00:20:57.940 --> 00:21:01.770
where you supply a clipping
region and that will reset the

00:21:01.930 --> 00:21:05.700
clip on the CG context to that
that you're supplying here.

00:21:06.560 --> 00:21:09.150
Okay, so when would you do these things?

00:21:09.420 --> 00:21:12.500
Window resizing, so you've made your
window bigger or smaller,

00:21:12.500 --> 00:21:13.740
you're going to have to reset the clip.

00:21:13.780 --> 00:21:16.850
Because the vis region on the window,
or the clipping region rather,

00:21:16.850 --> 00:21:20.040
on the window, it's gotten larger,
you want to sync that up,

00:21:20.140 --> 00:21:22.230
you want to tell the CG context
that you've got a bigger clip.

00:21:22.260 --> 00:21:26.700
And then if you're scrolling or for other
reasons you changed the port origin,

00:21:26.770 --> 00:21:30.670
now you need to synchronize your
CG context with the port origin.

00:21:32.340 --> 00:21:36.060
Alright, well I'm mostly a printing guy,
so I've got to talk about printing.

00:21:36.060 --> 00:21:38.050
What about printing?

00:21:39.190 --> 00:21:42.510
So, I've sort of divided up
the kinds of applications,

00:21:42.510 --> 00:21:44.400
these again are Carbon applications.

00:21:44.420 --> 00:21:47.100
I've divided them up
into three categories.

00:21:47.110 --> 00:21:51.100
The first category is our favorite
kind of application on Mac OS X.

00:21:51.310 --> 00:21:54.230
That's an application that
when imaging during printing,

00:21:54.360 --> 00:21:57.490
the only thing that you're
drawing into the printing port,

00:21:57.490 --> 00:22:00.490
so to speak, or the only thing that
you're trying to image,

00:22:00.490 --> 00:22:04.090
is something, or all the content is
drawn using only Quartz 2D.

00:22:04.090 --> 00:22:07.100
So, that's the first type of application.

00:22:07.100 --> 00:22:09.190
So,
all the content is imaged with Quartz 2D.

00:22:09.280 --> 00:22:11.600
And you say, well, you know,
maybe I'd like to do that,

00:22:11.600 --> 00:22:14.030
but I have all this legacy
data that's sitting around.

00:22:14.100 --> 00:22:17.100
I've got these pic files,
and I've got to use Draw Picture.

00:22:17.160 --> 00:22:21.150
Well, we recognize that that's an issue,
and so what we're adding to Mac OS X,

00:22:21.150 --> 00:22:25.350
coming soon, is a routine that allows you
to take a QuickDraw picture and

00:22:25.350 --> 00:22:27.040
draw that into a CG context.

00:22:27.100 --> 00:22:30.090
And I have a little demo
that's sort of like doing that,

00:22:30.090 --> 00:22:31.090
and you'll get a chance to see that.

00:22:31.100 --> 00:22:33.740
Now, we want to hear from you about what
other kinds of QuickDraw content,

00:22:33.800 --> 00:22:37.250
other things that you're doing,
other things you're drawing

00:22:37.300 --> 00:22:41.530
into a graph port that,
hey, right now, you don't know how to

00:22:41.530 --> 00:22:43.100
draw into a CG context.

00:22:43.340 --> 00:22:45.100
Because if that's what's preventing
you from moving over to Quartz,

00:22:45.100 --> 00:22:47.070
we want to know what that is,
and we want to fix that.

00:22:47.150 --> 00:22:50.100
And, by the way, you know,
you probably can do it.

00:22:50.100 --> 00:22:52.090
We just need to give you some
ideas about how to do it,

00:22:52.100 --> 00:22:55.060
and maybe we can add some more
convenience things in the future.

00:22:55.210 --> 00:22:57.560
Okay,
so that's the first type of application,

00:22:57.560 --> 00:23:00.080
your application soon to be,
only imaging using

00:23:00.110 --> 00:23:02.330
Quartz 2D when printing.

00:23:02.590 --> 00:23:04.480
Alright,
second type of application is what

00:23:04.480 --> 00:23:06.060
I'll call a QuickDraw only app.

00:23:06.070 --> 00:23:09.500
It's the vast majority of
Carbon applications today.

00:23:09.500 --> 00:23:11.490
It's what you were doing on
9 when you were printing,

00:23:11.590 --> 00:23:15.500
you were drawing with
QuickDraw in some fashion.

00:23:15.500 --> 00:23:19.600
And then the third type is a type
that we want to talk about also,

00:23:19.610 --> 00:23:22.500
which are applications that
are going to mix their drawing.

00:23:22.500 --> 00:23:27.470
So they draw with both QuickDraw imaging
and Quartz 2D imaging at print time.

00:23:27.500 --> 00:23:32.040
Okay, and that might be an application,
for example, you say, "Well,

00:23:32.040 --> 00:23:33.740
I don't really want to
move over to Quartz 2D,

00:23:34.260 --> 00:23:36.500
but man, I like this PDF import.

00:23:36.500 --> 00:23:38.960
I really want to do that." Or,
maybe you want to do almost

00:23:38.960 --> 00:23:41.800
everything with Quartz 2D,
but there's still a little bit of

00:23:41.800 --> 00:23:44.490
QuickDraw stuff that you haven't
quite gotten weaned off of.

00:23:44.500 --> 00:23:48.530
Okay, so I'm going to talk about printing
issues with these three types

00:23:48.530 --> 00:23:50.290
of applications in that order.

00:23:50.500 --> 00:23:53.820
Now before I do so,
I need to say a little bit, I mean,

00:23:53.820 --> 00:23:56.570
I know everybody knows about the
printing architecture on Mac OS X,

00:23:56.570 --> 00:23:57.500
and I'm boring everybody.

00:23:57.500 --> 00:24:01.500
But it just helps me to
remind myself how it works.

00:24:01.610 --> 00:24:04.910
So printing architecture on Mac OS X,
it's really completely different

00:24:04.920 --> 00:24:06.500
than it is on Mac OS 8 and 9.

00:24:06.500 --> 00:24:08.310
We've totally rewritten
the back end of printing,

00:24:08.320 --> 00:24:10.480
the front end of printing,
it's all totally different.

00:24:10.500 --> 00:24:13.540
The APIs are similar,
very similar for Carbon Apps,

00:24:13.690 --> 00:24:17.310
but we've really rewritten the
underlying printing system.

00:24:17.410 --> 00:24:19.930
So, a couple things that are
important to know about it.

00:24:20.120 --> 00:24:24.300
The printing system completely
leverages Quartz 2D when

00:24:24.300 --> 00:24:30.020
actually both at imaging time,
at spool time,

00:24:30.020 --> 00:24:32.780
it's built into the printing system.

00:24:33.160 --> 00:24:36.720
All the printing that you do generates
a PDF spool file as an intermediate

00:24:36.820 --> 00:24:40.450
representation for the graphics
that you draw in your application.

00:24:40.860 --> 00:24:43.320
It's the same printing port
both for raster printing and

00:24:43.360 --> 00:24:44.790
for post-script printing.

00:24:44.810 --> 00:24:47.790
You don't have to worry
about driver X and driver Y.

00:24:47.830 --> 00:24:50.800
It's the same graph port,
has the same characteristics.

00:24:51.020 --> 00:24:54.070
Both of those, regardless of what the
back-end printing device is,

00:24:54.230 --> 00:24:55.800
we're going to spool out a PDF.

00:24:55.800 --> 00:25:00.200
Now the good thing about this,
I think all your customers

00:25:00.200 --> 00:25:04.490
are going to like,
all our customers are going to like,

00:25:04.540 --> 00:25:06.010
is you're going to get high quality
imaging on all printing devices.

00:25:06.010 --> 00:25:06.010
Okay?

00:25:07.110 --> 00:25:09.500
So, again,
I'm talking about an application

00:25:09.500 --> 00:25:12.880
that only does Quartz 2D
imaging during printing.

00:25:12.910 --> 00:25:16.570
Now, these are Carbon applications,
and by default the printing system

00:25:16.580 --> 00:25:20.810
is set up so that when you actually
start printing your document,

00:25:20.920 --> 00:25:23.510
we're expecting to hand
you a QuickDraw graph port,

00:25:23.510 --> 00:25:26.680
because Carbon, QuickDraw,
people think of them together,

00:25:26.680 --> 00:25:31.610
that's the default graphics context that
you get at the time that you go to draw,

00:25:31.610 --> 00:25:32.420
is QuickDraw.

00:25:32.420 --> 00:25:35.550
So before you actually start printing,
you need to tell the imaging

00:25:35.580 --> 00:25:39.980
system that you're going to
use Core Graphics Quartz 2D.

00:25:39.980 --> 00:25:41.310
Those are the same thing.

00:25:41.340 --> 00:25:46.090
So what I have here is we need to create
a CFArray that has one element in it,

00:25:46.090 --> 00:25:50.690
and that one element is a
CFString that we've predefined called

00:25:50.840 --> 00:25:53.460
KPM Graphics Context Core Graphics.

00:25:53.820 --> 00:25:56.080
Okay, you're going to draw with
Core Graphics Quartz 2D when

00:25:56.150 --> 00:25:57.640
you're imaging at print time.

00:25:57.750 --> 00:25:58.810
That's all you're going to do.

00:25:58.960 --> 00:26:02.290
So before you actually call this
routine PM Session Begin Document,

00:26:02.390 --> 00:26:05.550
which is beginning the printing process,
before you do that,

00:26:05.550 --> 00:26:06.830
you need to set up the
system to set up this array,

00:26:06.830 --> 00:26:09.940
you need to call a routine that tells
the printing system that's the format

00:26:09.940 --> 00:26:13.080
and that's the type of graphics
context that you're going to draw with.

00:26:13.080 --> 00:26:17.000
So you're going to say PM Session
Set Document Format Generation with

00:26:17.000 --> 00:26:20.730
the print session you got when
you created your print session.

00:26:20.980 --> 00:26:24.240
And then you pass in that
you want to do format PDF,

00:26:24.390 --> 00:26:26.720
which by the way is the default,
but you're reinforcing that,

00:26:26.720 --> 00:26:30.200
and you're going to pass in
this graphics context array.

00:26:30.200 --> 00:26:32.930
Then you release that array,
because we hang on to it, you release it.

00:26:32.930 --> 00:26:35.620
This is a classic way of
using Core Foundation.

00:26:35.740 --> 00:26:39.460
Okay, so now you've told the printing
system that you're going

00:26:39.460 --> 00:26:41.390
to use Quartz 2D at imaging

00:26:41.810 --> 00:26:44.780
So, how do you get your graphics
context that's associated with

00:26:44.780 --> 00:26:46.550
the printing system at print time?

00:26:46.550 --> 00:26:48.340
Well, you ask the printing system.

00:26:48.390 --> 00:26:51.550
This is just what you would do if
you weren't using Core Graphics.

00:26:51.560 --> 00:26:54.220
It's a little bit different
because now you're saying,

00:26:54.320 --> 00:26:57.640
okay, I want the Core Graphics context
from the Get Graphics context,

00:26:57.700 --> 00:26:59.680
PM Session Get Graphics context.

00:26:59.700 --> 00:27:00.150
Okay?

00:27:00.210 --> 00:27:02.710
Now you have a context,
a CG context that you can

00:27:02.710 --> 00:27:04.380
draw into using Quartz 2D.

00:27:04.380 --> 00:27:05.920
You can't draw any QuickDraw.

00:27:06.090 --> 00:27:09.490
You can only draw into that
Quartz 2D graphics context.

00:27:09.500 --> 00:27:12.540
Alright,
one thing that's different about the

00:27:12.580 --> 00:27:15.570
graphics context in the coordinate
system that's different than you might

00:27:15.570 --> 00:27:20.900
be familiar with with Carbon printing,
that the origin of the coordinate system

00:27:20.900 --> 00:27:22.990
is the lower left corner of the sheet.

00:27:23.040 --> 00:27:24.020
Okay?

00:27:24.240 --> 00:27:27.200
Now, when you're doing Carbon printing,
you're probably familiar with the

00:27:27.200 --> 00:27:29.920
fact that the origin of the coordinate
system is the top left corner of

00:27:30.000 --> 00:27:31.300
the imageable area of the page.

00:27:31.300 --> 00:27:33.420
So this is a significant difference.

00:27:33.620 --> 00:27:36.100
Not only is it the bottom left corner,
it's not the bottom left

00:27:36.100 --> 00:27:39.300
corner of the imageable area,
it's the bottom left corner of the sheet.

00:27:39.300 --> 00:27:40.300
Thank you.

00:27:42.560 --> 00:27:48.960
Okay, now that's for your application
that's drawing only using Quartz 2D.

00:27:49.030 --> 00:27:53.460
So what about your application
that's drawing using only QuickDraw,

00:27:53.460 --> 00:27:54.600
or some QuickDraw?

00:27:54.650 --> 00:27:56.790
Let's start with the only QuickDraw.

00:27:57.010 --> 00:28:00.130
Now, as I said,
the spool file that we generate during

00:28:00.130 --> 00:28:02.260
printing is this PDF spool file.

00:28:02.290 --> 00:28:05.900
Now, QuickDraw applications,
they don't know how to generate PDF.

00:28:06.360 --> 00:28:11.080
So, what we do during the printing
system is we translate the

00:28:11.080 --> 00:28:16.900
QuickDraw imaging that you do into
the port into the Core graphics,

00:28:16.960 --> 00:28:18.840
Quartz 2D drawing,
and we're going to generate

00:28:18.920 --> 00:28:19.840
that spool file for you.

00:28:19.900 --> 00:28:22.140
Now,
how do you actually get your graph port?

00:28:22.140 --> 00:28:24.860
You do it the same way as you do,
you don't need to set call,

00:28:24.870 --> 00:28:27.900
you don't need to set this up
before you start your printing,

00:28:27.900 --> 00:28:31.900
but after each page, PM session,
begin page call, after that,

00:28:31.900 --> 00:28:33.900
you're going to go and you're
going to get your graphics context,

00:28:33.900 --> 00:28:38.900
which is going to be a QuickDraw port,
and you're going to image into that.

00:28:38.930 --> 00:28:42.150
Now, let's talk about that port,
because that port is completely unlike

00:28:42.150 --> 00:28:43.800
any graph port you've seen before.

00:28:43.900 --> 00:28:49.900
It's something like a hybrid QuickDraw
raster driver printing port and a

00:28:49.900 --> 00:28:49.900
port that's a little bit different.

00:28:49.930 --> 00:28:52.130
PostScript-like graph board.

00:28:53.510 --> 00:28:56.800
So,
I jumped ahead a little bit a second ago.

00:28:56.800 --> 00:29:00.610
Because we need to have PDF spool file,
of course,

00:29:00.820 --> 00:29:04.170
applications that draw with Quartz
2D drawing can produce that natively

00:29:04.250 --> 00:29:06.400
by just using Quartz 2D directly.

00:29:06.540 --> 00:29:09.230
However, during print time,
we need to translate any

00:29:09.270 --> 00:29:12.320
QuickDraw drawing that you
do into Quartz 2D drawing and

00:29:12.320 --> 00:29:14.390
therefore generate PDF from that.

00:29:14.400 --> 00:29:17.400
This is true both for QuickDraw,
pure QuickDraw applications,

00:29:17.400 --> 00:29:21.400
and also applications that mix
both QuickDraw and Quartz 2D.

00:29:21.400 --> 00:29:25.140
We have to translate the Quartz,
the QuickDraw portion

00:29:25.430 --> 00:29:27.510
into Quartz 2D drawing.

00:29:27.720 --> 00:29:29.590
Here's what that looks like.

00:29:29.680 --> 00:29:31.100
You do your QuickDraw imaging calls.

00:29:31.100 --> 00:29:35.850
We replace the QuickDraw port bottlenecks
with bottlenecks that translate that

00:29:35.970 --> 00:29:38.600
QuickDraw drawing into Quartz 2D drawing.

00:29:38.600 --> 00:29:41.600
So that's that second box, that blue box,
that's the translator.

00:29:41.600 --> 00:29:45.510
That turns into Quartz 2D
imaging calls and as you know,

00:29:45.700 --> 00:29:48.590
or hope you know by now,
the Quartz 2D imaging system can produce

00:29:48.750 --> 00:29:52.490
from those drawing calls a PDF file.

00:29:53.480 --> 00:29:58.780
Okay, well the process of doing this
translation is very similar to

00:29:59.200 --> 00:30:01.620
doing this kind of thing that we've
done with PostScript printing with

00:30:01.620 --> 00:30:03.380
the LaserWriter driver for years.

00:30:03.480 --> 00:30:08.430
The Quartz 2D imaging model is
essentially the PostScript imaging model.

00:30:08.810 --> 00:30:11.400
What we've done is we've borrowed
techniques that we've used with

00:30:11.400 --> 00:30:14.560
the LaserWriter 8 driver to do
this translation from QuickDraw

00:30:14.560 --> 00:30:16.700
into the Quartz 2D imaging model.

00:30:16.740 --> 00:30:19.310
We've tried to get results that
are consistent with the LaserWriter

00:30:19.430 --> 00:30:21.440
8 driver wherever possible,
because that's something

00:30:21.560 --> 00:30:22.830
that's very familiar to people.

00:30:22.930 --> 00:30:25.530
We think that's a win for
you and for customers.

00:30:25.760 --> 00:30:28.960
Alright, so I'm going to talk about
not only similarities with

00:30:29.210 --> 00:30:31.960
the LaserWriter 8 driver,
but also differences.

00:30:32.120 --> 00:30:34.360
And again, let me just say,
what we're talking about is the

00:30:34.360 --> 00:30:38.430
translation on Mac OS X from the
QuickDraw drawing that your application

00:30:38.530 --> 00:30:43.090
does into the printing graph port,
into Quartz 2D drawing, into PDF.

00:30:43.100 --> 00:30:43.940
Okay?

00:30:44.050 --> 00:30:48.040
So, we use that same general approach
like we did for LaserWriter 8.

00:30:48.210 --> 00:30:51.860
We're using the same line layout
algorithms that we use for LaserWriter 8.

00:30:52.050 --> 00:30:55.540
Line layout algorithms are used
because frequently in QuickDraw,

00:30:55.540 --> 00:30:58.990
the metrics are different in your
QuickDraw fonts and so on than

00:30:58.990 --> 00:31:02.250
they are in both PostScript for
LaserWriter 8 and in PDF.

00:31:02.440 --> 00:31:05.880
So, if you're using integer font widths,
for example, well, we're going to turn

00:31:05.890 --> 00:31:08.770
those into fractional,
usage of fractional widths on fonts.

00:31:08.830 --> 00:31:11.220
We do layout in order to
adjust the differences.

00:31:11.280 --> 00:31:16.270
With regard to images,
we have the same QuickDraw transfer mode

00:31:16.270 --> 00:31:19.630
support that we have in LaserWriter 8.

00:31:19.710 --> 00:31:21.700
For 1-bit images,
we support all the same.

00:31:21.700 --> 00:31:24.490
We support all the transfer modes
except the XOR transfer modes,

00:31:24.490 --> 00:31:25.460
which we can't support.

00:31:25.700 --> 00:31:29.420
For deep PIX maps,
anything deeper than 1-bit,

00:31:29.420 --> 00:31:32.040
we support the source copy mode.

00:31:32.040 --> 00:31:33.680
We don't support any of
the other transfer modes.

00:31:33.700 --> 00:31:36.650
However, coming soon,
we're going to have support for the

00:31:36.760 --> 00:31:38.820
QuickDraw transparent transfer mode.

00:31:39.280 --> 00:31:43.620
Transparent transfer mode is where
the background color in the graph

00:31:43.730 --> 00:31:46.340
port is used as a transparent color.

00:31:46.460 --> 00:31:48.870
So, any pixels in your image that
have the same color as the

00:31:48.870 --> 00:31:51.460
background color in the graph port,
they're transparent.

00:31:51.460 --> 00:31:53.530
when you draw your image.

00:31:54.970 --> 00:31:57.420
Okay, more similarities to the
LaserWriter 8 driver.

00:31:57.420 --> 00:32:00.030
We do pattern substitution.

00:32:00.080 --> 00:32:02.330
So if your application
draws with patterns,

00:32:02.340 --> 00:32:05.040
which, by the way,
you actually always are because the port

00:32:05.070 --> 00:32:08.330
has a pattern in there that's using for
all your drawing when you do line art,

00:32:08.360 --> 00:32:14.630
what we do is we map some of the patterns
into grayscale colors or grayg levels.

00:32:14.780 --> 00:32:18.020
I hope this is clear what's
happening here in the slide.

00:32:18.020 --> 00:32:20.500
It's certainly clearer in the front
of the room maybe than the back,

00:32:20.670 --> 00:32:22.930
but on the top I've got
several different patterns.

00:32:23.960 --> 00:32:25.550
Let's see what that looks like,
dot patterns.

00:32:25.560 --> 00:32:29.190
And what we do is for certain
combinations of the dot patterns,

00:32:29.200 --> 00:32:30.460
we map those into gray levels.

00:32:30.520 --> 00:32:33.390
So you can see a much smoother
appearance in the drawing.

00:32:33.400 --> 00:32:36.640
And by the way, of course,
if there is a real pattern,

00:32:36.640 --> 00:32:40.040
like there is in this brick pattern,
we're going to generate that pattern.

00:32:42.780 --> 00:32:46.600
Okay, some other similarities
with LaserWriter 8.

00:32:46.630 --> 00:32:49.670
We also support many of the
picture comments that are supported

00:32:49.670 --> 00:32:51.660
during printing on Mac OS 8.9.

00:32:51.700 --> 00:32:54.920
So some of them are the text
alignment picture comments,

00:32:54.920 --> 00:32:59.230
text rotation and flipping,
polygon smoothing where you

00:32:59.230 --> 00:33:02.130
can draw with cubic beziers,
graphics rotation where you can have

00:33:02.130 --> 00:33:04.990
different kinds of QuickDraw graphics
and before you draw your graphics you

00:33:05.060 --> 00:33:07.700
can tell the imaging system to rotate.

00:33:07.700 --> 00:33:10.160
You can't do this on screen,
but the printing system

00:33:10.240 --> 00:33:11.700
knows how to deal with that.

00:33:11.760 --> 00:33:15.150
Dash lines, fractional width lines,
so something other than

00:33:15.280 --> 00:33:17.700
the normal pen sizes,
but fractions of a pen.

00:33:17.700 --> 00:33:19.590
And also color sync support.

00:33:19.680 --> 00:33:24.690
So on Mac OS 8.9 you could tag
your data with picture comments

00:33:24.750 --> 00:33:26.700
that provided color sync profiles.

00:33:26.700 --> 00:33:31.970
And we respect those and we'll use
those color sync profiles to draw

00:33:31.970 --> 00:33:36.700
the graphics as calibrated color
if you use those picture comments.

00:33:36.700 --> 00:33:39.210
I have some examples of a
couple of these things in the

00:33:39.210 --> 00:33:40.740
little demo I'm going to do.

00:33:41.270 --> 00:33:44.040
So, differences from LaserOtter 8.

00:33:44.120 --> 00:33:48.070
Well, I think the big one that probably
many people run into is that

00:33:48.240 --> 00:33:50.710
PostScript picture comments
are not supported when you're

00:33:50.710 --> 00:33:52.910
printing in this print graph board.

00:33:53.100 --> 00:33:55.820
There's no way to take these
PostScript picture comments

00:33:56.190 --> 00:33:59.340
and turn them into PDF without
having a PostScript interpreter.

00:33:59.370 --> 00:34:01.860
We don't have a PostScript interpreter
in the PDF printing system.

00:34:01.860 --> 00:34:06.380
So the PostScript picture comments
that you would generate are ignored.

00:34:06.380 --> 00:34:07.320
They're dropped on the floor.

00:34:07.320 --> 00:34:08.460
We don't do anything with them.

00:34:09.050 --> 00:34:11.880
Instead, in this manner,
we act something more

00:34:11.880 --> 00:34:14.840
like a QuickDraw driver,
what you might be familiar

00:34:14.840 --> 00:34:17.410
with on Mac OS 8 and 9,
where the portion,

00:34:17.410 --> 00:34:22.700
if you say PostScript begin and then
you draw with some QuickDraw and you

00:34:22.780 --> 00:34:25.540
draw some PostScript picture comments
and then you say PostScript end,

00:34:25.540 --> 00:34:29.220
a raster driver on Mac OS 8 and 9 uses
the QuickDraw drawing at that point.

00:34:29.250 --> 00:34:31.060
And that's what we do here on Mac OS X.

00:34:31.060 --> 00:34:34.100
Because we're not a PostScript driver,
we use the QuickDraw representation.

00:34:34.100 --> 00:34:37.830
So that also means, for example,
if you have an EPS preview

00:34:37.830 --> 00:34:40.200
that you're doing,
you don't just want to say

00:34:40.300 --> 00:34:43.320
PostScript begin and emit a whole
bunch of PostScript code and end.

00:34:43.320 --> 00:34:45.420
You want to draw that preview image also.

00:34:45.920 --> 00:34:49.570
And we will use that preview
image instead of the EPS data.

00:34:50.830 --> 00:34:53.700
Okay,
well that's one of the big differences.

00:34:53.830 --> 00:34:56.190
There's also another difference
in something we think is better

00:34:56.190 --> 00:34:57.870
and hopefully going to help you.

00:34:58.100 --> 00:35:02.300
That is, we've added for the first time
to a PostScript type of driver,

00:35:02.300 --> 00:35:03.940
we've added support
for QuickDraw regions.

00:35:03.940 --> 00:35:07.510
That is, you can have a QuickDraw
region that you clip with,

00:35:07.510 --> 00:35:09.570
that you fill, that you frame.

00:35:09.570 --> 00:35:11.500
Arbitrary regions are supported.

00:35:12.080 --> 00:35:14.660
Now, of course,
they're device dependent and you

00:35:14.660 --> 00:35:17.420
might be unhappy with some of
the results you get and that's of

00:35:17.420 --> 00:35:20.400
course one of the reasons why we're
pushing you toward using Quartz 2D,

00:35:20.460 --> 00:35:22.690
but we are supporting it.

00:35:22.740 --> 00:35:24.510
So that's a good thing.

00:35:24.510 --> 00:35:28.860
Another thing is that we've
basically fixed a bug,

00:35:28.860 --> 00:35:31.700
which is that now when you
draw with your patterns,

00:35:31.700 --> 00:35:33.930
QuickDraw patterns
respect the port origin.

00:35:33.940 --> 00:35:38.790
LaserRotter8 driver didn't respect
the port origin when doing patterns.

00:35:38.930 --> 00:35:39.940
We fixed that.

00:35:40.110 --> 00:35:42.840
So let's say you had
your ducts like this,

00:35:42.940 --> 00:35:45.600
you had your ducts all lined up,
and you were drawing with the

00:35:45.670 --> 00:35:47.940
origin at the corner of the graphic.

00:35:47.940 --> 00:35:51.340
With the LaserRotter8 driver,
we're going to use the

00:35:51.430 --> 00:35:53.440
original 0-0 port origin.

00:35:53.680 --> 00:35:57.370
With the printing system on Mac OS X,
we're going to respect the port origin,

00:35:57.440 --> 00:35:59.040
so you'll get your ducts
in the right place.

00:35:59.040 --> 00:36:02.940
Okay,
let's move over to the demo machine.

00:36:02.940 --> 00:36:10.950
So I'm going to maybe hide Pixie.

00:36:16.510 --> 00:36:20.680
So, I have a couple of images
that I want to show you.

00:36:20.680 --> 00:36:22.560
This is a little
application that I wrote.

00:36:22.560 --> 00:36:26.730
It's essentially leveraging this draw
picture into CG context routine that

00:36:26.730 --> 00:36:29.400
I told you was coming soon in Mac OS X.

00:36:29.480 --> 00:36:31.440
On the left hand side here
I have a picture that I found on,

00:36:31.440 --> 00:36:33.400
actually I don't know
where I found this picture,

00:36:33.400 --> 00:36:35.400
a picture that came to me.

00:36:35.430 --> 00:36:38.400
And this is drawn using draw picture.

00:36:38.400 --> 00:36:42.870
On the right hand side in this window,
the same picture is drawn

00:36:43.120 --> 00:36:46.390
using Core graphics,
using Quartz 2D.

00:36:46.520 --> 00:36:49.300
It's essentially drawn through a port
which has its bottlenecks replaced

00:36:49.410 --> 00:36:51.400
as they would be during printing.

00:36:51.400 --> 00:36:54.400
So, I hope you can see some of these,
some of the features of this.

00:36:54.400 --> 00:36:56.400
First of all, we do pattern substitution.

00:36:56.400 --> 00:36:58.250
Let me use the mouse here
to maybe point a little bit.

00:36:58.740 --> 00:37:03.300
Over here, this is a normal QuickDraw
pattern that gets substituted

00:37:03.380 --> 00:37:05.400
with the gray level here.

00:37:05.450 --> 00:37:08.230
All the text here,
all the text is anti-aliased.

00:37:08.410 --> 00:37:11.190
All of the graphics are anti-aliased.

00:37:11.400 --> 00:37:13.400
This is the QuickDraw version.

00:37:13.400 --> 00:37:15.390
Of course,
over here is the Quartz 2D drawing.

00:37:15.400 --> 00:37:19.400
What else do we have here
that might be of interest?

00:37:19.540 --> 00:37:22.400
Anyway, of course the goal here is,
at print time,

00:37:22.400 --> 00:37:23.400
we want to get the best quality we can.

00:37:23.400 --> 00:37:26.400
And we think translating this into Quartz
2D is going to give you better quality,

00:37:26.400 --> 00:37:28.400
even when you're using QuickDraw.

00:37:30.650 --> 00:37:33.800
I've got a couple others.

00:37:33.830 --> 00:37:37.100
Oh, one thing that's sort of fun,
I want to mention,

00:37:37.150 --> 00:37:41.040
one thing I added to this little app is,
oh, a little save as PDF because this

00:37:41.150 --> 00:37:44.400
window on the right hand side
here is drawn using Quartz 2D,

00:37:44.450 --> 00:37:48.980
if I create a PDF context rather
than getting the context for

00:37:48.980 --> 00:37:52.350
the window and I do that same
drawing into that PDF context,

00:37:52.350 --> 00:37:53.560
I get a PDF file.

00:37:53.660 --> 00:37:59.100
So you can make it really easy to
get PDF out from your application.

00:37:59.160 --> 00:38:02.210
Here's another drawing.

00:38:04.140 --> 00:38:08.040
This is a highway map that we got.

00:38:08.040 --> 00:38:09.780
Again,
here's the QuickDraw version of that.

00:38:10.020 --> 00:38:12.100
There's a couple things
that are shown here.

00:38:12.100 --> 00:38:14.400
You can also see,
if I can bring this up here,

00:38:14.420 --> 00:38:17.840
you can also see pattern
substitution going on here.

00:38:17.920 --> 00:38:19.080
Here's the QuickDraw pattern.

00:38:19.340 --> 00:38:21.100
Over here is a nice smooth gray scale.

00:38:21.100 --> 00:38:28.100
The lines of the map here
are drawn using polygons,

00:38:28.100 --> 00:38:32.550
but at print time, the polygon picture
comments are being used.

00:38:32.600 --> 00:38:36.100
So, we interpret those picture comments
and now you get nice smooth lines.

00:38:36.100 --> 00:38:37.950
Not only anti-alias,
but smoothed out because

00:38:38.040 --> 00:38:39.090
they're drawn as Beziers.

00:38:39.100 --> 00:38:42.790
All the text is anti-alias,
so if you look at the text in here,

00:38:42.790 --> 00:38:44.600
over here, the text looks a lot better.

00:38:44.600 --> 00:38:48.190
And, oh, look, here's some rotated text.

00:38:48.600 --> 00:39:02.100
[Transcript missing]

00:39:05.260 --> 00:39:10.340
About ColorSync, the left hand side I've
got a pic that's an image.

00:39:10.350 --> 00:39:12.960
It's actually using,
this particular one's an extreme example.

00:39:13.100 --> 00:39:16.200
It's using the ColorSync
picture comments.

00:39:16.300 --> 00:39:17.700
And I'm drawing this with DrawPicture.

00:39:17.700 --> 00:39:20.330
There is a DrawMatch picture
that will let the imaging system

00:39:20.330 --> 00:39:23.160
handle that with QuickDraw,
but I'm just using DrawPicture here.

00:39:23.650 --> 00:39:25.740
And over here on the right,

00:39:25.870 --> 00:39:29.960
I'm not using Draw Picture, I'm using,
or rendering using Quartz 2D and it

00:39:30.080 --> 00:39:34.880
picks up the ColorSync picture comments
and draws in the calibrated color space.

00:39:36.380 --> 00:39:39.370
Somebody's clapping good.

00:39:39.450 --> 00:39:41.250
I like that.

00:39:42.150 --> 00:39:44.180
One of the things, this is sort of,
you know,

00:39:44.210 --> 00:39:48.120
I'd like to add a few tips and tricks
since that's the way we're advertised.

00:39:48.160 --> 00:39:50.500
One of them I think,

00:39:51.100 --> 00:39:51.990
You might be interested in this.

00:39:52.010 --> 00:39:56.310
This is a PDF that we're generating
for one of those graphics that I had.

00:39:56.910 --> 00:39:59.780
And when you start to look, you know,
if you're familiar with PDF,

00:39:59.980 --> 00:40:01.610
then you might be
interested in looking at it.

00:40:01.670 --> 00:40:02.700
If you're not familiar,
you might be interested in

00:40:02.700 --> 00:40:05.700
learning a little bit about
the PDF that we generate.

00:40:05.750 --> 00:40:10.970
However, for performance reasons
and file size reasons,

00:40:11.150 --> 00:40:15.000
we're generating PDF that has many of
the streams in the PDF file compressed.

00:40:15.090 --> 00:40:16.730
It's using the FLATE encoding.

00:40:16.860 --> 00:40:21.060
So here's the data that
represents the PDF data that's

00:40:21.240 --> 00:40:24.250
generated by the printing system.

00:40:24.470 --> 00:40:25.740
And it's compressed.

00:40:25.760 --> 00:40:29.800
Well, for developers we thought, okay,
maybe it would be helpful to you

00:40:29.800 --> 00:40:32.400
if you want to look at that data
to not have it be compressed.

00:40:32.400 --> 00:40:35.340
And I wrote a little app here that's
a printing preferences app that,

00:40:35.430 --> 00:40:37.400
you know, talk about a couple of the
preferences that are on here.

00:40:37.400 --> 00:40:41.180
So by default the printing system
is going to compress the PDF data

00:40:41.300 --> 00:40:43.400
as it's generating the spool file.

00:40:43.560 --> 00:40:45.880
And you can turn that off with
this little application if

00:40:45.960 --> 00:40:47.400
you uncheck it and save that.

00:40:47.400 --> 00:40:51.410
Then when you go to print your PDF,
if you go to look at the PDF,

00:40:51.490 --> 00:40:53.400
you'll see it's not
compressed any longer.

00:40:53.400 --> 00:40:55.400
You can actually look
at it in clear text.

00:40:55.400 --> 00:40:58.260
Just another couple of things
about this particular application.

00:40:58.400 --> 00:41:01.400
If you were in Paul Danbold's
talk yesterday,

00:41:01.400 --> 00:41:03.240
you learned that the printing system
can generate something that's called

00:41:03.290 --> 00:41:07.250
a job copy for the PostScript data
that's being sent to the output device.

00:41:07.400 --> 00:41:10.280
So for debugging purposes,
it's not a save to

00:41:10.280 --> 00:41:13.400
PostScript functionality
that a user would use.

00:41:13.400 --> 00:41:17.330
But I know we in the printing team
and I think a lot of developers

00:41:17.430 --> 00:41:19.680
appreciate the ability to see what
PostScript's being sent to the

00:41:20.060 --> 00:41:23.470
printer as part of the printing path,
whether if you're generating your own

00:41:23.470 --> 00:41:27.400
PostScript in some situations or you
just want to understand what's going on.

00:41:27.400 --> 00:41:28.260
You can turn this on.

00:41:28.460 --> 00:41:29.400
You can choose a location.

00:41:29.400 --> 00:41:31.400
By default it's in /temp.

00:41:31.400 --> 00:41:33.900
That location needs to be writable
by all just because of the

00:41:33.900 --> 00:41:35.400
way the printing system's run.

00:41:35.400 --> 00:41:38.330
You can set a new printing
-- a new location for these.

00:41:38.430 --> 00:41:40.400
The files that get generated
are based on the job name.

00:41:40.400 --> 00:41:44.310
So you really do get distinct files for
each print job and you can go and find

00:41:44.310 --> 00:41:46.400
them and look at them if you need to.

00:41:46.420 --> 00:41:50.510
This last thing is a job status
log -- printing status log,

00:41:50.600 --> 00:41:51.320
rather.

00:41:51.430 --> 00:41:53.950
And this is basically the data
that's coming back from the

00:41:54.080 --> 00:41:57.400
PostScript printer module that gets
logged if you turn this feature on

00:41:57.400 --> 00:41:59.400
and it goes into the temp directory.

00:41:59.460 --> 00:42:02.400
So this would be a very specialized
developer that would need this.

00:42:02.400 --> 00:42:04.960
You want to see what's coming back from
the printer from the PostScript job

00:42:05.030 --> 00:42:07.400
module -- the PostScript printer module.

00:42:07.400 --> 00:42:09.350
But you can also turn that on.

00:42:09.400 --> 00:42:10.370
Okay.

00:42:10.440 --> 00:42:13.490
So I uncheck this and I'm going to save
that and I'm going to quit this and

00:42:13.490 --> 00:42:15.400
I'm going to go and I'm going to print.

00:42:15.400 --> 00:42:18.480
And now this is something
I do and I think other people

00:42:18.480 --> 00:42:20.330
might find this interesting.

00:42:20.410 --> 00:42:25.400
Also, which is it's very easy to get
the PDF from the printing system.

00:42:25.400 --> 00:42:27.290
You just say print preview.

00:42:27.770 --> 00:42:29.400
There's the PDF file.

00:42:29.540 --> 00:42:31.400
Well,
I like to look at that all the time.

00:42:31.520 --> 00:42:34.400
So what you can do here --
this is just project builder.

00:42:34.400 --> 00:42:36.270
Open, drag that.

00:42:36.400 --> 00:42:37.400
There it is.

00:42:37.400 --> 00:42:39.500
Open it.

00:42:40.250 --> 00:42:41.110
There it is.

00:42:41.270 --> 00:42:44.590
Okay now, remember I checked on don't
compress the PDF stream.

00:42:44.620 --> 00:42:47.200
So here is the PDF stream
from that printing.

00:42:47.380 --> 00:42:49.140
Okay,
so for those that are familiar with PDF,

00:42:49.250 --> 00:42:52.320
we're just drawing an image here,
we're setting up a coordinate system,

00:42:52.530 --> 00:42:54.790
drawing an image,
but it's very easy to get that.

00:42:56.300 --> 00:43:00.100
Let me just see if there's
anything else I want to talk about.

00:43:00.160 --> 00:43:01.130
I think that's it.

00:43:01.240 --> 00:43:03.210
Should we go back to slides?

00:43:07.900 --> 00:43:10.190
Thank you.

00:43:10.190 --> 00:43:15.730
Okay, so we've talked about what happens
when you draw with QuickDraw and print.

00:43:15.730 --> 00:43:20.430
Let's talk about if you're drawing
with QuickDraw and Quartz 2D and doing

00:43:20.430 --> 00:43:22.930
Quartz 2D imaging during printing.

00:43:23.810 --> 00:43:28.010
So, I think the most important thing that
a number of developers have run into is

00:43:28.010 --> 00:43:31.690
that this routine that I talked about,
Create CG Context for Port,

00:43:31.700 --> 00:43:35.260
if the port that you have is the port
you got from the printing system,

00:43:35.260 --> 00:43:36.250
this routine fails.

00:43:36.540 --> 00:43:37.130
You get an error.

00:43:37.190 --> 00:43:39.700
You can't get a
CG context from that port.

00:43:39.700 --> 00:43:44.570
Now the reason is, as I've talked about,
the printing system itself that's

00:43:44.570 --> 00:43:48.700
translating QuickDraw graphics
into Core graphics drawing,

00:43:48.700 --> 00:43:51.360
into Quartz 2D drawing,
the printing system has a

00:43:51.360 --> 00:43:55.670
CG context associated with this
translation that it's doing.

00:43:55.670 --> 00:43:57.700
Now if you start drawing
into that yourself,

00:43:57.700 --> 00:44:00.700
there's some synchronization
problems that we have.

00:44:00.700 --> 00:44:04.550
Because the printing system thinks
that it owns that CG context and it can

00:44:04.550 --> 00:44:08.690
change the color and it can change the
clip and it can do all the stuff in it.

00:44:08.700 --> 00:44:10.680
If you start going in
and doing those things,

00:44:10.690 --> 00:44:11.680
we can't do our job.

00:44:11.720 --> 00:44:15.980
So to work properly doing this,
we need to have careful state

00:44:16.070 --> 00:44:19.700
management of QuickDraw and
Quartz 2D drawing at print.

00:44:19.700 --> 00:44:22.700
Now we're working really
hard to resolve these issues.

00:44:22.700 --> 00:44:25.700
Let's talk about what
it's going to look like.

00:44:27.220 --> 00:44:29.620
Well,
we need to enforce some kind of modality

00:44:29.630 --> 00:44:34.500
into this to separate the drawing that
you might do into this CG context from

00:44:34.500 --> 00:44:39.100
the drawing that the QuickDraw to Quartz
2D translator would do at print time.

00:44:39.100 --> 00:44:42.920
So, we've added some routines,
or we are adding routines

00:44:43.040 --> 00:44:45.100
to Mac OS X in the future.

00:44:45.100 --> 00:44:49.100
These are not in Mac OS X version 10.0.x.

00:44:49.100 --> 00:44:53.090
The routines are QD_begin_cgcontext
and QD_end_cgcontext.

00:44:53.090 --> 00:44:57.100
Now these routines,
unlike the Get Context Report,

00:44:57.100 --> 00:45:01.100
these routines work both for
screen drawing and for printing.

00:45:01.100 --> 00:45:07.060
So, if you're only doing screen drawing,
you can keep using this CG context,

00:45:07.070 --> 00:45:10.010
Create Context Report,
but if you're doing printing,

00:45:10.120 --> 00:45:11.970
you want to use these new routines.

00:45:12.100 --> 00:45:15.520
Now,
in order to enforce the fact that we have

00:45:15.890 --> 00:45:21.070
this modality where you're doing your,
you're doing your QuickDraw CG drawing,

00:45:21.170 --> 00:45:23.100
and then you're doing
your QuickDraw drawing,

00:45:23.100 --> 00:45:25.100
and then you're doing your
Core Graphics drawing,

00:45:25.100 --> 00:45:28.100
and then you're doing
your QuickDraw drawing,

00:45:28.160 --> 00:45:31.280
in order to enforce this,
when you actually call

00:45:31.280 --> 00:45:35.100
these routines on a port,
we take the bottlenecks in the port,

00:45:35.230 --> 00:45:39.100
the imaging bottlenecks in the port,
and we make them non-drawing bottlenecks.

00:45:39.100 --> 00:45:40.100
Okay?

00:45:40.100 --> 00:45:44.200
So, both on screen and printing,
QuickDraw drawing that goes on

00:45:44.200 --> 00:45:48.020
in between the QD_begin_cgcontext
and QD_end_cgcontext,

00:45:48.100 --> 00:45:49.100
that QuickDraw drawing will
be in the same context.

00:45:49.100 --> 00:45:51.100
So, that's why it's going to be ignored.

00:45:51.100 --> 00:45:57.100
One other thing is, when you call CG,
excuse me, QD_end_cgcontext,

00:45:57.180 --> 00:46:01.100
that CG context that you got
from the begin routine goes away.

00:46:01.100 --> 00:46:05.100
You have to get a new one next time you
want to do your drawing with Quartz 2D.

00:46:05.100 --> 00:46:08.100
Okay, sounds hard, it's not.

00:46:08.100 --> 00:46:09.100
Here's the way it looks.

00:46:09.100 --> 00:46:13.100
So, you start,
you don't have a context for the,

00:46:13.100 --> 00:46:15.100
you don't have a context to draw into.

00:46:15.100 --> 00:46:18.100
You have a port,
you call QD_begin_cgcontext.

00:46:18.100 --> 00:46:20.100
Pass in the port,
you pass in the pointer to your context,

00:46:20.100 --> 00:46:22.100
you get a context back.

00:46:22.100 --> 00:46:25.080
So, now you go and you do some
drawing using Quartz 2D.

00:46:25.260 --> 00:46:31.170
So, in this case, I'm just using the
CG context draw PDF document,

00:46:31.170 --> 00:46:34.050
similar to what I did before
on drawing a PDF document.

00:46:34.100 --> 00:46:36.090
So,
you're done drawing your PDF document,

00:46:36.170 --> 00:46:40.100
you're done for now drawing
your Quartz 2D content,

00:46:40.220 --> 00:46:42.930
and you now are going to draw some
QuickDraw content of whatever sort.

00:46:43.230 --> 00:46:46.100
You call QD_end_cgcontext,
you pass in the port,

00:46:46.100 --> 00:46:47.810
you pass in the pointer to the context,
that you had,

00:46:47.910 --> 00:46:50.100
that you got from the begin routine.

00:46:50.100 --> 00:46:53.030
Now that value that you
get back from this routine,

00:46:53.140 --> 00:46:54.100
that context is null.

00:46:54.100 --> 00:46:56.100
You can't draw to that context anymore.

00:46:56.100 --> 00:46:58.100
If you have another way
of hanging on to that,

00:46:58.100 --> 00:47:01.590
you're going to be really surprised
when you try and draw into that.

00:47:02.280 --> 00:47:05.320
Okay, so now you do your copy bits
or whatever other QuickDraw

00:47:05.320 --> 00:47:06.900
imaging that you need to do.

00:47:06.910 --> 00:47:08.700
It's time to do some more
Core graphics drawing,

00:47:08.700 --> 00:47:10.150
some more drawing with Quartz 2D.

00:47:10.380 --> 00:47:12.190
You go, you get your context again.

00:47:12.200 --> 00:47:14.980
Now,
when you go to get the context again,

00:47:14.980 --> 00:47:18.200
it's important to know
the graphics state,

00:47:18.200 --> 00:47:24.190
the G state on that context is
reset to an initial G state.

00:47:24.260 --> 00:47:27.790
So it doesn't remember whatever
transformations you might have

00:47:27.830 --> 00:47:31.200
done between the last time
you used begin and CG context.

00:47:31.200 --> 00:47:34.320
So you get it again,
you do some more Quartz

00:47:34.320 --> 00:47:36.240
2D imaging and so on.

00:47:36.450 --> 00:47:40.160
Okay, now we want you to start moving
over to this style if you're

00:47:40.160 --> 00:47:42.690
using the Quartz 2D system.

00:47:42.770 --> 00:47:46.000
And so in order to facilitate that,
we've written some code that you

00:47:46.080 --> 00:47:48.000
can link into your application.

00:47:48.090 --> 00:47:51.700
You can start using this style rather
than using the Create Context Report.

00:47:51.700 --> 00:47:53.690
Again, this is this printing issue.

00:47:53.700 --> 00:47:59.100
So these routines work both,
the real routines that are going to be

00:47:59.100 --> 00:48:03.700
in the future version of Mac OS X work
both on screen and print time.

00:48:03.730 --> 00:48:06.720
This linkable code does
not enable printing,

00:48:06.840 --> 00:48:10.700
but it lets you move your use
of core graphics of Quartz 2D

00:48:10.700 --> 00:48:16.700
over to this style of mixing
both QuickDraw and core graphics.

00:48:16.820 --> 00:48:19.290
So again,
if you're only drawing with QuickDraw or

00:48:19.290 --> 00:48:22.700
if you're only drawing with Quartz 2D,
this does not apply.

00:48:22.700 --> 00:48:24.560
So we have some linkable code.

00:48:24.630 --> 00:48:25.700
It does not enable printing.

00:48:25.700 --> 00:48:28.080
It doesn't install these
bottlenecks that dummy out the

00:48:28.200 --> 00:48:32.420
QuickDraw drawing in between,
but it lets you get going.

00:48:33.360 --> 00:48:34.650
Okay, well, tips and tricks.

00:48:34.760 --> 00:48:38.180
I hope I gave you a little bit of
a tip or a trick with the demo,

00:48:38.180 --> 00:48:40.210
but let's talk about some printing tips.

00:48:40.300 --> 00:48:44.360
First thing, number one, most important,
don't expect that when

00:48:44.360 --> 00:48:47.050
you say PostScript begin,
draw some picture comments,

00:48:47.050 --> 00:48:49.380
PostScript end,
that that's going to generate PostScript.

00:48:49.400 --> 00:48:50.900
You need to do something really special.

00:48:50.900 --> 00:48:54.680
Paul Danbold talked about how to
do that in the printing session.

00:48:54.680 --> 00:48:56.370
So you need to do something
really special if you want to

00:48:56.370 --> 00:48:57.240
generate your own PostScript.

00:48:57.240 --> 00:49:00.170
By default, the printing system doesn't
generate PostScript,

00:49:00.180 --> 00:49:02.300
won't let you generate PostScript, okay?

00:49:03.160 --> 00:49:07.360
So in addition,
don't expect that you can use

00:49:07.560 --> 00:49:10.640
PostScript begin and PostScript end
to hide quick draw drawing.

00:49:10.700 --> 00:49:13.070
Lots of applications do
this on Mac OS 8 and 9.

00:49:13.080 --> 00:49:16.080
They say, ah, well,
it's the laser writer driver, you know,

00:49:16.080 --> 00:49:19.800
so it's not going to, you know,
pay attention to the quick

00:49:20.200 --> 00:49:22.500
draw drawing that I'm doing in
between PostScript begin and end.

00:49:22.570 --> 00:49:26.660
Hey, we recognize that quick draw,
and we're going to image it, okay?

00:49:26.660 --> 00:49:32.300
So the next one here is if you're
someone who likes to actually

00:49:32.300 --> 00:49:35.730
go in and call the bottlenecks,
the quick draw bottlenecks directly,

00:49:35.740 --> 00:49:38.350
make sure you check that graph port.

00:49:38.420 --> 00:49:43.310
Make sure that those bottlenecks are
nil or don't exist already in the graph

00:49:43.310 --> 00:49:46.420
port before you go off and call standard
bits or standard text or whatever.

00:49:46.420 --> 00:49:50.500
Because if there's port bottlenecks,
you want to chain any

00:49:50.500 --> 00:49:52.590
calling that you make,

00:49:52.700 --> 00:50:11.100
[Transcript missing]

00:50:11.630 --> 00:50:14.500
You just get garbage
probably on Mac OS 8 and 9.

00:50:14.560 --> 00:50:16.930
You crash on Mac OS X.

00:50:17.550 --> 00:50:20.330
Okay, now there's some documentation
that we have out there on the

00:50:20.440 --> 00:50:22.660
Mac OS X printing graph port.

00:50:22.700 --> 00:50:23.470
It's already been written.

00:50:23.550 --> 00:50:26.500
It's already been out there for probably,
I don't know, maybe even 10 years,

00:50:26.500 --> 00:50:27.490
but close to it.

00:50:27.490 --> 00:50:32.980
And that's the documentation
that's in Appendix B,

00:50:32.980 --> 00:50:32.980
using Picture Comments for printing.

00:50:33.510 --> 00:50:35.760
Pretty much what it
says in there is true,

00:50:35.980 --> 00:50:38.640
modified by some of the
things I've said here.

00:50:38.750 --> 00:50:40.400
There are some picture
comments in there that say,

00:50:40.400 --> 00:50:41.400
"Oh, these are going away.

00:50:41.400 --> 00:50:44.590
You don't want to be using these." Hey,
these went away.

00:50:44.910 --> 00:50:47.220
You don't want to be using those.

00:50:48.090 --> 00:50:48.840
Okay?

00:50:48.870 --> 00:50:51.810
Now coming soon we're working on a
tech note that's specifically about

00:50:51.910 --> 00:50:53.400
the Mac OS X printing graph board.

00:50:53.550 --> 00:50:57.910
It's going to contain the material
that I have in this talk expanded.

00:50:58.810 --> 00:51:02.590
Okay,
so let me just give you a summary so far.

00:51:02.590 --> 00:51:06.660
We hope you see that there's both my talk
and obviously talks earlier in the week

00:51:06.740 --> 00:51:08.690
with far more impressive things in them.

00:51:08.690 --> 00:51:12.280
You can really do some cool
stuff with Quartz 2D in

00:51:12.360 --> 00:51:14.500
Carbon on Mac OS X in Carbon.

00:51:14.710 --> 00:51:17.710
The printing graph port,
it's not like a graph

00:51:18.170 --> 00:51:19.580
port you saw before.

00:51:19.740 --> 00:51:22.700
It recognizes all these picture comments,
but it's not a PostScript graph port.

00:51:22.700 --> 00:51:24.600
It's not a QuickDraw graph port.

00:51:24.750 --> 00:51:26.790
It's this sort of hybrid.

00:51:27.490 --> 00:51:32.720
And just to emphasize again,
applications can mix Quartz 2D and

00:51:32.720 --> 00:51:37.820
QuickDraw drawing content on screen
and at print time the mixing is

00:51:37.860 --> 00:51:41.400
going to take the form of these
new routines that I've described.

00:51:41.620 --> 00:51:44.400
Okay, that's the summary of what
I've given you so far.

00:51:44.400 --> 00:51:46.400
What about making it all go fast?

00:51:46.400 --> 00:51:49.220
And to talk about that,
my colleague Ralph Bruhner

00:51:49.220 --> 00:51:50.400
on the graphics team.

00:52:03.930 --> 00:52:07.090
Okay.

00:52:07.100 --> 00:52:12.620
So, I will talk about Quartz performance
tuning and in the next 15 minutes

00:52:12.790 --> 00:52:15.900
you will learn something about how
to improve your graphics speed,

00:52:16.490 --> 00:52:22.650
what to do about memory usage
and most importantly how to

00:52:22.650 --> 00:52:22.650
find the performance problems.

00:52:23.830 --> 00:52:29.900
First I'd like to say something about
how the architecture in Mac OS X works,

00:52:29.900 --> 00:52:31.950
the graphics architecture.

00:52:32.490 --> 00:52:38.400
On Mac OS X there is a process running in
the background called the Windows Server.

00:52:38.400 --> 00:52:44.020
That process is responsible for
managing screen real estate.

00:52:44.020 --> 00:52:48.110
So when an application creates a window,
it will go and send a message

00:52:48.110 --> 00:52:52.450
to the Windows Server and say,
"Well, I need a window that size,

00:52:52.610 --> 00:52:58.080
that spot." And the Windows Server will
go and allocate a buffer for that window,

00:52:58.080 --> 00:53:00.790
map it into shared memory
with that application,

00:53:01.010 --> 00:53:04.460
and then the application can
go and draw into these bits.

00:53:04.810 --> 00:53:06.920
Well,
when the application is done drawing,

00:53:06.920 --> 00:53:08.760
it sends again a message to
the Windows Server and says,

00:53:08.870 --> 00:53:10.510
"Okay, now here are the new bits.

00:53:10.730 --> 00:53:15.000
I want to put them on screen."
And the Windows Server will do that.

00:53:21.680 --> 00:53:25.810
The important concept here is that
the window has a backing store.

00:53:25.810 --> 00:53:30.270
So all your content is buffered
and that has some implications

00:53:30.430 --> 00:53:32.540
for how you do graphics.

00:53:32.670 --> 00:53:37.020
First of all,
what it gives that to you is

00:53:37.540 --> 00:53:40.950
The Windows Server is able to mix
the content of your application with

00:53:41.060 --> 00:53:42.780
the content of any other application.

00:53:42.780 --> 00:53:46.400
So that enables things like
the drop shadows you see,

00:53:46.550 --> 00:53:51.410
genie effects,
scalable dock and things like that.

00:53:51.900 --> 00:53:56.040
Now, you have to be aware that whenever
you do a manipulation of your window,

00:53:56.050 --> 00:53:59.640
that is no longer as lightweight
as it was under OS 9.

00:53:59.770 --> 00:54:03.250
Because pretty much everything
you do with windows that affects

00:54:03.440 --> 00:54:07.020
the window geometry is actually a
message that goes over to a different

00:54:07.020 --> 00:54:10.100
process and tells it what to do.

00:54:12.360 --> 00:54:18.300
One other implication is that
window buffers use a bit of memory.

00:54:18.310 --> 00:54:20.970
So the last thing you want
to do is allocate a lot of

00:54:20.970 --> 00:54:25.540
windows which are not on screen,
but just eat up some memory.

00:54:26.970 --> 00:54:28.670
So, two tips here.

00:54:28.890 --> 00:54:30.800
One is primarily for Cocoa applications.

00:54:30.800 --> 00:54:35.850
It's a bad idea to go allocate a window
at a certain size and immediately

00:54:35.850 --> 00:54:37.420
resize it to a different size.

00:54:37.420 --> 00:54:41.680
Because that essentially means the
Windows server will allocate some memory,

00:54:41.680 --> 00:54:45.010
then it will get a request, well,
toss that away, I really changed my mind,

00:54:45.010 --> 00:54:45.920
I want something else.

00:54:46.020 --> 00:54:50.890
And that is fairly common when you
have a default size in your Nib file

00:54:50.890 --> 00:54:55.860
and then set it to the window size
that the user set it last time to.

00:54:56.680 --> 00:55:01.100
So if you can avoid that,
that is a nice performance gain.

00:55:01.870 --> 00:55:05.230
Something from the
Carbon side of the world:

00:55:05.240 --> 00:55:10.270
some Carbon applications on 9
use an off-screen G-World to

00:55:10.270 --> 00:55:12.800
buffer the window content.

00:55:12.930 --> 00:55:15.580
So on 10,
this is counterproductive because

00:55:15.690 --> 00:55:19.170
you already have a buffer,
so you just double the memory size for

00:55:19.170 --> 00:55:21.800
the window and you do an additional copy.

00:55:21.870 --> 00:55:25.220
So if you can avoid that, that helps too.

00:55:27.520 --> 00:55:31.760
Another thing for Cocoa applications,
in the interface builder you have

00:55:31.760 --> 00:55:36.260
this little flag that says you
can make the window one shot.

00:55:36.270 --> 00:55:41.930
Well, one shot windows have the property
that when they go off screen,

00:55:41.930 --> 00:55:45.900
the buffer is automatically discarded,
and when it comes on screen again,

00:55:45.960 --> 00:55:50.260
the application gets a redraw
message to rebuild the content.

00:55:50.330 --> 00:55:53.800
So, whenever possible,
you should use that.

00:55:53.840 --> 00:55:58.140
Most times it's far cheaper to redraw
the content of the window than swapping

00:55:58.140 --> 00:55:59.940
it back in from the small file.

00:56:02.520 --> 00:56:04.660
Okay, let's talk about drawing.

00:56:04.880 --> 00:56:09.410
Well, the key message about drawing is,
in today's world,

00:56:09.430 --> 00:56:11.460
graphic speed is essentially a
function of memory bandwidth.

00:56:11.480 --> 00:56:12.970
It's the number of pixels you touch.

00:56:12.970 --> 00:56:17.060
It doesn't really matter anymore what
you're actually doing with these pixels.

00:56:18.100 --> 00:56:22.570
So, the first thing you want to
avoid is multiple drawing.

00:56:23.060 --> 00:56:28.380
Like, you draw your window with,
you fill it with a pinstripe pattern,

00:56:28.440 --> 00:56:30.760
and then you put a big white
rectangle on top of it to have

00:56:30.840 --> 00:56:32.200
a background for your text.

00:56:32.220 --> 00:56:36.010
So if you can avoid the pinstripe
drawing at the first place,

00:56:36.310 --> 00:56:38.290
that is a nice performance gain.

00:56:40.280 --> 00:56:43.700
And the other thing that ties
in with the architecture of the

00:56:43.700 --> 00:56:48.990
Windows Server I mentioned before
is avoid unnecessary flushing.

00:56:49.130 --> 00:56:51.100
So whenever you're done
with drawing something,

00:56:51.100 --> 00:56:54.470
that message gets sent to the
Windows Server to tell it,

00:56:54.870 --> 00:56:57.310
well, put this stuff on screen.

00:56:58.010 --> 00:57:04.610
Now, it's a fairly common bug
that you flush too often.

00:57:04.620 --> 00:57:06.880
You have essentially,
your drawing is half done,

00:57:06.880 --> 00:57:10.640
and then somewhere in your
code path a flush happens.

00:57:10.780 --> 00:57:16.580
And what that means is unfinished
drawing appears on screen.

00:57:17.240 --> 00:57:23.240
and then right after that the complete
drawing shows up causing flickering.

00:57:23.240 --> 00:57:28.420
So you want to avoid that,
try to avoid that as much as possible.

00:57:28.670 --> 00:57:33.120
Now, one nice thing about the
Windows Server is all updates you

00:57:33.240 --> 00:57:37.530
do are synced to the CRT beam,
so you really get totally smooth

00:57:37.530 --> 00:57:39.740
graphics if you play an animation.

00:57:39.930 --> 00:57:42.590
You get the exact 75 Hz of
your monitor or whatever.

00:57:42.600 --> 00:57:47.600
And that's the reason why dragging the
window around on OS X is really smooth.

00:57:48.010 --> 00:57:50.580
However, this can backfire for you.

00:57:50.610 --> 00:57:53.820
If you flush too much,
that mechanism will actually ensure that

00:57:53.820 --> 00:57:57.600
the unfinished drawing stays on screen
for long enough for the user to notice.

00:57:57.640 --> 00:58:02.520
So,
it might be a good idea to look at that.

00:58:05.870 --> 00:58:13.280
So in today's world, OS X.0.x,
window buffers live in main memory.

00:58:13.630 --> 00:58:17.030
But however,
it is a good idea not to rely on that.

00:58:17.150 --> 00:58:19.450
There may be changes coming.

00:58:20.050 --> 00:58:23.550
To move the window buffers
on the graphics card,

00:58:23.550 --> 00:58:26.500
or maybe they get compressed,
or any other performance

00:58:26.600 --> 00:58:28.340
optimizations we might think of.

00:58:28.460 --> 00:58:34.580
So, relying on the fact that the window
buffer is in main memory today is

00:58:34.690 --> 00:58:38.130
not such a future-proof strategy.

00:58:39.240 --> 00:58:44.910
So, what you want to avoid is
touching the window bits directly.

00:58:45.000 --> 00:58:47.980
Whenever possible, use QuickDraw,
QuickTime,

00:58:48.090 --> 00:58:51.510
Quartz 2D to produce your content.

00:58:52.610 --> 00:58:56.600
So this here on the slide,
essentially getting the port for your

00:58:56.610 --> 00:58:58.660
window and then the pick space address.

00:58:58.700 --> 00:59:02.350
That's whenever possible,
you should avoid that.

00:59:02.550 --> 00:59:05.520
Well, there are definitely
cases where you have to.

00:59:05.520 --> 00:59:07.880
So I can imagine if you write
an emulator for something,

00:59:07.880 --> 00:59:11.070
then you probably want
to produce your own bits.

00:59:11.400 --> 00:59:14.270
So, if you do,
we'd like to hear from you.

00:59:14.410 --> 00:59:18.680
We may come up with some APIs to
enable that without breaking

00:59:18.680 --> 00:59:22.050
the performance optimizations
we're going to do in the future.

00:59:25.150 --> 00:59:30.880
Okay, a word about the velocity engine.

00:59:31.010 --> 00:59:35.200
On OS X, we have a certain number of
functions inside the graphics system

00:59:35.200 --> 00:59:37.630
that are optimized for the G4.

00:59:37.720 --> 00:59:41.420
And this gives, in some cases,
really significant speedups.

00:59:41.490 --> 00:59:44.680
In fact, whenever we go and

00:59:45.320 --> 00:59:49.860
To vectorize one of these routines,
we usually get more than 2x out of it.

00:59:49.860 --> 00:59:54.790
And in some extreme cases,
we saw something like 17x speedups.

00:59:55.800 --> 00:59:59.620
Well, for your drawing to
actually make use of that,

00:59:59.620 --> 01:00:02.810
there's essentially
one hint to give here,

01:00:02.930 --> 01:00:04.820
which is whenever you
produce your own bitmaps,

01:00:04.820 --> 01:00:10.400
like you create a CG bitmap context
or you create a QuickDraw G-World and

01:00:10.400 --> 01:00:14.500
then hand that to the graphics system,
make the row bytes a multiple of 16,

01:00:14.500 --> 01:00:16.600
which is the vector
length on the G4 chip.

01:00:16.620 --> 01:00:21.030
That will enable more
optimizations to kick in.

01:00:21.720 --> 01:00:24.560
And as a side effect of that,
because there are routines

01:00:24.560 --> 01:00:28.400
that are significantly faster,
do test your software on a G3 as well,

01:00:28.400 --> 01:00:30.600
not just your G4 developer machine.

01:00:30.740 --> 01:00:33.190
If you have interactive
graphics going on,

01:00:33.190 --> 01:00:36.550
which is really nice on a G4,
it may be that you're actually

01:00:36.550 --> 01:00:40.000
triggering one of these optimizations
and it's dark slow on a G3.

01:00:40.190 --> 01:00:43.480
So it's worth verifying that.

01:00:45.000 --> 01:00:49.160
Okay,
now I'm going to do a demo about how to

01:00:49.260 --> 01:00:51.990
find performance issues on your system.

01:00:52.310 --> 01:00:57.090
Can I get rid of this?

01:01:00.930 --> 01:01:05.200
So in your developer folder there is a
little application called Quartz Debug.

01:01:05.270 --> 01:01:07.740
It has this colorful window here.

01:01:07.830 --> 01:01:10.520
And it enables you to

01:01:10.700 --> 01:01:25.300
[Transcript missing]

01:01:28.830 --> 01:01:32.980
The first switch here
is flash screen updates,

01:01:32.990 --> 01:01:36.870
which tells the Windows Server whenever
it puts something on screen,

01:01:36.910 --> 01:01:41.390
flash the area briefly in
yellow to make it very visible

01:01:41.710 --> 01:01:43.940
where updates are happening.

01:01:44.080 --> 01:01:47.450
So for example,
if I switch over to simple text here,

01:01:47.640 --> 01:01:52.500
you see there's some flickering going on,
and when I move the window around you see

01:01:52.500 --> 01:01:54.810
there's certain areas that get updated.

01:01:56.070 --> 01:01:58.960
Now,
I'm using simple text here because simple

01:01:58.960 --> 01:02:01.760
text has an interesting performance bug.

01:02:01.830 --> 01:02:05.790
So, when I type here,

01:02:07.600 --> 01:02:11.550
You see, it redraws the entire window
for every character I type.

01:02:11.550 --> 01:02:15.120
So this mechanism makes it blatantly
visible where your performance

01:02:15.250 --> 01:02:19.500
problems are and why your key
repeat rate is really slow.

01:02:19.500 --> 01:02:23.440
So this helps a lot in finding
these kinds of problems.

01:02:23.520 --> 01:02:28.500
Because the window contents are buffered,
it's now much harder to see.

01:02:28.500 --> 01:02:31.590
You no longer see flickering
on screen usually if the

01:02:31.670 --> 01:02:32.500
flush is in the right place.

01:02:32.500 --> 01:02:38.660
So this is the mechanism to counteract
that effect and tell you what's going on.

01:02:41.640 --> 01:02:44.280
Another switch here is
all the flash drawing,

01:02:44.280 --> 01:02:48.040
which essentially activates
whenever a primitive is drawn,

01:02:48.040 --> 01:02:52.000
either to QuickDraw or to Quartz 2D,
we flash immediately.

01:02:52.000 --> 01:02:55.000
This is like the immediate
mode drawing you see on OS 9.

01:02:55.000 --> 01:02:57.360
So if you combine that with
the flash screen updates,

01:02:57.370 --> 01:02:59.660
then you actually see
every single primitive.

01:02:59.660 --> 01:03:03.510
And you see there's a lot
of flickering going on,

01:03:03.510 --> 01:03:07.250
the menu gets redrawn,
and stuff like that.

01:03:07.340 --> 01:03:11.280
So this makes your system really,
really slow, as you can see.

01:03:11.500 --> 01:03:16.260
But it helps you to detect
something like duplicate drawing.

01:03:16.260 --> 01:03:19.650
If an area flashes twice, then you know,
well, okay, there is probably

01:03:19.650 --> 01:03:21.130
something going wrong here.

01:03:23.820 --> 01:03:29.360
Okay, so if I switch back you see there's
the fireworks still going on.

01:03:35.060 --> 01:03:39.350
Another thing that Quartz debug
allows you to do is look at

01:03:39.530 --> 01:03:43.090
the window list in the system.

01:03:43.760 --> 01:03:48.700
These are all the windows
the Windows Server sees.

01:03:48.760 --> 01:03:52.720
There are things like size on screen,
size in memory,

01:03:52.820 --> 01:03:57.380
position and the name of the
app that produces that window.

01:03:57.380 --> 01:04:00.890
For example,
the top three here say Quartz Debug App.

01:04:00.940 --> 01:04:04.610
There is one window which is
22 pixels high and has the

01:04:04.610 --> 01:04:09.100
width of the entire screen,
which is the menu bar on the top.

01:04:09.310 --> 01:04:13.030
There's another window down here
which is 300 by 200 something,

01:04:13.120 --> 01:04:17.200
which is this nice little picture here.

01:04:17.310 --> 01:04:20.390
And there's a third window,
interestingly.

01:04:20.910 --> 01:04:23.360
which is 19 by 19 pixels.

01:04:23.430 --> 01:04:28.150
Now this is AppKit caching
that little checkbox here.

01:04:28.440 --> 01:04:34.950
So, which is internally implemented
as an off-screen window.

01:04:36.550 --> 01:04:40.600
Look at your application using the
"Show Window List" feature here and

01:04:40.600 --> 01:04:44.500
find out if there are windows that
are off-screen and if they're big,

01:04:44.570 --> 01:04:47.800
try to get rid of them because
you don't really want them

01:04:47.800 --> 01:04:49.400
to end up in the swap file.

01:04:49.400 --> 01:04:56.680
Okay, that's it for the demo.

01:04:56.680 --> 01:04:56.680
If you can go back to the slides.

01:05:03.800 --> 01:05:12.400
[Transcript missing]

01:05:19.210 --> 01:05:21.500
Before we get to the Q&A,
I just want to take a quick time

01:05:21.500 --> 01:05:24.840
to go over the last item on our
roadmap at WWDC relating to graphics.

01:05:24.840 --> 01:05:28.500
And we have at 2 o'clock in room
J1 the Graphics Feedback Forum.

01:05:28.500 --> 01:05:32.980
This is a very important forum for
you to come and tell us feedback on

01:05:32.980 --> 01:05:35.440
Mac OS X's graphics technologies.

01:05:35.480 --> 01:05:41.660
It's a good opportunity to query us on to
why certain elements of the architecture

01:05:41.660 --> 01:05:44.360
are implemented differently from
what you experience in your Mac OS 9.

01:05:44.360 --> 01:05:46.990
Additionally, provide your feedback and
features and things you would

01:05:47.030 --> 01:05:48.050
like to see in the system.

01:05:50.630 --> 01:05:54.860
If you need my contact information,
I'm TravisBrown@apple.com.

01:05:54.860 --> 01:05:56.050
I can be reached.

01:05:56.070 --> 01:06:01.360
If you have questions about any of the
2D graphics technologies in Mac OS X,

01:06:01.360 --> 01:06:03.710
feel free to send me emails.
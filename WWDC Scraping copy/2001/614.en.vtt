WEBVTT

00:00:07.450 --> 00:00:09.960
So thank you and welcome to session 614.

00:00:09.960 --> 00:00:12.910
I know it's pretty late and you all
want to get a hold of some beer,

00:00:12.910 --> 00:00:16.510
so I try to make it quick.

00:00:16.540 --> 00:00:20.190
The session is about
advanced Java Client.

00:00:20.680 --> 00:00:24.380
I want to start out by summarizing
a little bit what we heard

00:00:24.380 --> 00:00:28.500
in the session 609 and 606,
and then want to go into a lot more

00:00:28.500 --> 00:00:30.600
details about the distribution there.

00:00:30.600 --> 00:00:33.570
So let me start by summarizing
what we learned so far.

00:00:33.600 --> 00:00:37.600
So Java Client is a technology for
distributed desktop applications.

00:00:37.600 --> 00:00:39.600
It's a three-tier architecture.

00:00:39.600 --> 00:00:42.600
The client interacts with the user,
displays the user interface.

00:00:42.600 --> 00:00:45.780
We use the Java Foundation classes
or Swing for that,

00:00:45.880 --> 00:00:48.690
so we are basically platform independent.

00:00:48.920 --> 00:00:52.570
The server accesses the database,
and the database is the third

00:00:52.570 --> 00:00:54.870
tier which stores the data.

00:00:55.320 --> 00:00:57.900
The client never accesses
the database directly.

00:00:57.960 --> 00:01:01.390
All the communication from the client
to the database goes through the server,

00:01:01.390 --> 00:01:04.520
so the server has complete control
over everything the client is

00:01:04.520 --> 00:01:06.200
allowed to do and not allowed to do.

00:01:06.200 --> 00:01:09.140
And also what's interesting to
know is that the communication

00:01:09.230 --> 00:01:13.190
protocol between client and server,
at least by default, is HTTP,

00:01:13.220 --> 00:01:17.180
so you get the connectivity
of an HTML-based application

00:01:17.200 --> 00:01:21.500
running in a browser,
but it's a much richer user interface.

00:01:21.880 --> 00:01:24.860
And Java Client is mostly
designed for the intranet.

00:01:24.860 --> 00:01:29.330
There are a couple of complications
with either the launch time or the

00:01:29.330 --> 00:01:32.710
amount of data you need to download
or you need to client installation,

00:01:32.740 --> 00:01:37.680
so it's not a good technology for you
to put on high-traffic internet sites.

00:01:40.600 --> 00:01:43.680
Now,
Java Client is actually pretty powerful,

00:01:43.680 --> 00:01:47.120
and it's very well prepared
for a lot of advanced tasks.

00:01:47.400 --> 00:01:51.140
But since we do not have too
much documentation at this time,

00:01:51.140 --> 00:01:53.720
a few of the features
are relatively hidden,

00:01:53.830 --> 00:01:55.100
but I think you should
really know about them.

00:01:55.100 --> 00:01:59.420
So I will try to talk about very
concrete method names this time,

00:01:59.420 --> 00:02:02.610
notification names,
and I hope that you can all

00:02:02.670 --> 00:02:07.230
take something away from here to
really tune your applications.

00:02:09.500 --> 00:02:12.930
So first of all,
I want to go in a lot of detail

00:02:12.930 --> 00:02:16.680
about the distribution layer and the
objects in the distribution layer.

00:02:16.680 --> 00:02:19.000
I want to talk a little bit about
issues that you have to know

00:02:19.000 --> 00:02:21.620
about when you want to go into
deployment with your applications.

00:02:21.620 --> 00:02:25.410
And if you save the time,
I'd like to talk a little more about

00:02:25.460 --> 00:02:30.200
the controller factory that comes from
actually the Direct to Java Client

00:02:30.260 --> 00:02:34.900
side and show you how you can use
it to implement some nice features.

00:02:36.010 --> 00:02:38.740
So,
you've probably seen this diagram before.

00:02:38.740 --> 00:02:41.220
I don't want to go through
all these boxes again,

00:02:41.220 --> 00:02:44.130
but I want to kind of point out
about which of the pieces in this

00:02:44.130 --> 00:02:45.980
architecture I'm going to talk.

00:02:45.980 --> 00:02:48.120
First of all,
the distribution layer is the layer

00:02:48.160 --> 00:02:50.040
that connects the client and the server.

00:02:50.040 --> 00:02:51.920
That's where I would
spend most of the time.

00:02:51.920 --> 00:02:53.830
And then at the end,
if we talk about the factory,

00:02:53.930 --> 00:02:56.190
it would be in the e-generation
layer right at the top.

00:02:59.140 --> 00:03:02.360
So let's start with some information
about the distribution layer.

00:03:02.500 --> 00:03:05.540
And the most important topic when
it comes to the distribution layer,

00:03:05.540 --> 00:03:08.570
to me, is business logic partitioning.

00:03:12.480 --> 00:03:14.240
In Java Client,
you can have implementations

00:03:14.240 --> 00:03:17.440
of your business logic both on
the client and the server side.

00:03:17.500 --> 00:03:21.550
The business objects are fully functional
on both sides of the architecture.

00:03:21.640 --> 00:03:26.990
And you have the choice to either
use the same identical business logic

00:03:27.210 --> 00:03:29.600
Or you can use what we call
petition business logic.

00:03:29.600 --> 00:03:34.090
And petition business logic simply means
that you use different implementations

00:03:34.140 --> 00:03:36.690
on both sides of the architecture.

00:03:36.780 --> 00:03:40.300
And so far, I always, you know,
when I started talking about it, I said,

00:03:40.300 --> 00:03:42.030
you know,
the first thing you can do is you

00:03:42.030 --> 00:03:45.330
can restrict the visibility of
properties to the server side,

00:03:45.330 --> 00:03:47.280
so that they are not
visible on the client side.

00:03:48.540 --> 00:03:50.120
I want to make it a little
more complicated for the

00:03:50.120 --> 00:03:52.440
purpose of this session,
because you can also add

00:03:52.440 --> 00:03:55.320
additional properties that are
only visible on the client side,

00:03:55.340 --> 00:03:56.540
but not on the server side.

00:03:56.570 --> 00:03:57.860
Now, how does that make sense?

00:03:57.860 --> 00:04:00.280
Well, you know,
sometimes you're not interested

00:04:00.280 --> 00:04:02.920
in all the information,
a lot of detailed information,

00:04:02.980 --> 00:04:05.460
you're just interested
in derived properties.

00:04:05.460 --> 00:04:08.100
So let's say you have an
object that stores dimensions,

00:04:08.100 --> 00:04:10.200
right, a width, a height, and a depth.

00:04:10.220 --> 00:04:12.350
And on the client,
you really only want to see the

00:04:12.360 --> 00:04:13.900
volume of the complete object.

00:04:14.220 --> 00:04:16.660
So what you can do is,
you can add an additional

00:04:16.660 --> 00:04:19.940
property to your model,
actually, and mark it only as a

00:04:19.940 --> 00:04:21.740
client-side attribute.

00:04:21.740 --> 00:04:27.640
And then you do not, and width, height,
and depth, so the detailed attributes,

00:04:27.650 --> 00:04:31.870
you know, would stay on the server side,
and on the client side,

00:04:31.870 --> 00:04:33.640
you only use a derived attribute.

00:04:36.710 --> 00:04:39.360
You also have the choice to
use different implementations.

00:04:39.370 --> 00:04:42.520
So if you want to perform
computations in different ways,

00:04:42.530 --> 00:04:46.190
the implementation of the business
objects you use can be different.

00:04:49.010 --> 00:04:51.280
First of all,
that adds a lot of security to your

00:04:51.280 --> 00:04:55.220
application because you never send data
or even implementations to the client

00:04:55.220 --> 00:04:56.710
that you don't want the client to see.

00:04:56.720 --> 00:04:59.110
Now with Java,
you should probably know that

00:04:59.110 --> 00:05:02.730
all the classes you send to the
client can easily be decompiled.

00:05:02.740 --> 00:05:07.740
So if you have computations,
algorithms that you consider secret,

00:05:07.740 --> 00:05:12.060
you don't want it to ever become
public on any client side,

00:05:12.080 --> 00:05:16.080
then you can force the client to use
an implementation on the server side.

00:05:16.140 --> 00:05:18.980
So you can force the client to
make a round trip to the server,

00:05:18.980 --> 00:05:22.480
execute the computation there,
and then just send the end result back.

00:05:22.480 --> 00:05:26.190
So no data and no implementation
that you don't want the client

00:05:26.190 --> 00:05:27.870
to see will ever go there.

00:05:30.110 --> 00:05:31.780
And business logic partitioning
also helps you a lot with

00:05:31.860 --> 00:05:35.060
performance optimization,
something that probably today

00:05:35.060 --> 00:05:38.020
with really fast client machines
doesn't matter so much anymore.

00:05:38.020 --> 00:05:42.220
But if you have very fast server machines
and relatively slow client machines,

00:05:42.220 --> 00:05:45.220
you can design your clients
to make use of the computation

00:05:45.230 --> 00:05:46.860
power of the server boxes.

00:05:46.860 --> 00:05:49.640
As I said, it probably doesn't
matter too much anymore.

00:05:49.640 --> 00:05:54.260
But what actually is important is that
you can use business logic partitioning

00:05:54.260 --> 00:05:59.060
to minimize the amount of data that is
transferred between server and client.

00:05:59.900 --> 00:06:02.710
If you have computations that need
to take a look at a lot of data,

00:06:02.710 --> 00:06:06.530
you need to fetch a lot of objects from
the database to just get an end result.

00:06:06.540 --> 00:06:08.920
But you only want to
display this end result.

00:06:08.920 --> 00:06:11.680
You don't want to send all the detailed
data that you need for the computation.

00:06:11.680 --> 00:06:14.020
There's no need for you
to send it to the client.

00:06:14.020 --> 00:06:17.290
You just design your client to
make a run-through to the server,

00:06:17.290 --> 00:06:20.070
execute the computation there,
and on the way back you

00:06:20.070 --> 00:06:21.200
just send the result.

00:06:21.200 --> 00:06:24.310
And all the data that is needed for
the computation does not have to be

00:06:24.310 --> 00:06:26.270
sent over the wire to the client side.

00:06:26.280 --> 00:06:29.790
I actually think that that's one of
the keys to be successful with Java.

00:06:29.800 --> 00:06:32.610
You can use Java client that
you find the right partitioning

00:06:32.610 --> 00:06:33.760
of your business logic.

00:06:33.810 --> 00:06:37.310
The key really is to minimize the
amount of data that is transferred

00:06:37.330 --> 00:06:39.370
between client and server.

00:06:42.070 --> 00:06:45.460
How do you tell EOF to use
business logic partitioning?

00:06:45.480 --> 00:06:47.760
Well, you just go into EO Modeler.

00:06:47.770 --> 00:06:51.150
And if you want to use
different implementations,

00:06:51.670 --> 00:06:53.620
Usually, well,
you choose a different class.

00:06:53.620 --> 00:06:56.320
Usually in EOModeler,
if you look at an entity,

00:06:56.320 --> 00:06:58.570
you have a column where
you can enter a class name.

00:06:58.580 --> 00:07:03.900
With Java Client, you can actually,
you know, unhide another column called

00:07:03.900 --> 00:07:07.790
the client-side class name,
and you actually find it in this

00:07:07.790 --> 00:07:11.540
add column pop-up menu that you
see at the bottom of the table.

00:07:11.900 --> 00:07:14.320
And in here,
you can specify a different class name.

00:07:14.320 --> 00:07:17.590
I don't know whether you can read it,
but in the example that I use here,

00:07:17.600 --> 00:07:22.480
you know, the packages are
example.common.creditcard

00:07:22.490 --> 00:07:25.770
in the first row,
and it's actually the same on

00:07:25.770 --> 00:07:26.960
both client and server side.

00:07:26.960 --> 00:07:30.860
But, for example, in the second row,
I use example.server.customer

00:07:30.860 --> 00:07:33.060
and example.client.customer.

00:07:33.060 --> 00:07:36.560
So, there are two classes, right,
in two different packages,

00:07:36.750 --> 00:07:39.250
and on the client,
I use a different implementation

00:07:39.250 --> 00:07:40.920
than on the server side.

00:07:42.690 --> 00:07:44.780
The other thing you
can do in EO Model is,

00:07:44.780 --> 00:07:47.060
if you actually look at
the detail of an entity,

00:07:47.080 --> 00:07:48.780
if you look at all the
properties and relationships,

00:07:48.780 --> 00:07:52.940
you're probably familiar with the
column to set class properties.

00:07:52.940 --> 00:07:56.630
So these are the properties that actually
make it into your business logic,

00:07:56.640 --> 00:07:57.960
your business objects.

00:07:58.040 --> 00:08:01.760
And for Java Clients,
you can again unhide another column.

00:08:01.760 --> 00:08:04.760
You can set the client-side
class properties.

00:08:04.780 --> 00:08:08.760
So here, you know, you can, in this case,
I actually restricted the clients,

00:08:08.780 --> 00:08:12.620
the visibility of the member
since and the phone attributes.

00:08:12.620 --> 00:08:15.110
So they're only visible on the server,
but not on the client.

00:08:20.730 --> 00:08:26.720
The methods you use to implement
business logic partitioning are

00:08:26.720 --> 00:08:28.190
defined in EU Enterprise Object.

00:08:28.200 --> 00:08:32.760
The most important one you probably need
to know about is invoke remote method.

00:08:32.780 --> 00:08:35.750
That's the method you
invoke on the client side,

00:08:35.750 --> 00:08:43.720
and you use it to basically move the
execution of a method to the server side.

00:08:43.740 --> 00:08:45.820
So if you want to go from
the client to the server,

00:08:45.820 --> 00:08:47.330
you use invoke remote method.

00:08:48.080 --> 00:08:51.700
The arguments you pass are, first of all,
the editing context the object is in,

00:08:51.700 --> 00:08:55.980
a method name, the argument types,
and the arguments themselves.

00:08:55.980 --> 00:08:58.690
So this is, you know,
the method name and the argument types

00:08:58.690 --> 00:09:02.050
identify the method that is supposed
to be invoked on the server side.

00:09:02.080 --> 00:09:06.840
If you invoke remote method,
what happens is that the state of the

00:09:06.980 --> 00:09:12.240
editing context on the client side is
basically pushed to the server side,

00:09:12.250 --> 00:09:14.030
to the editing context
on the server side.

00:09:14.040 --> 00:09:17.890
And then the method that you specify
with the last three arguments.

00:09:17.980 --> 00:09:22.200
Method name and argument types is
invoked on the server side objects.

00:09:22.200 --> 00:09:24.190
So on the equivalent server side object.

00:09:27.210 --> 00:09:29.700
And there are two more methods
that are helpful for you.

00:09:29.750 --> 00:09:32.320
And they use them on the server side.

00:09:32.330 --> 00:09:36.300
And they evade from client update
and prepare values for client.

00:09:36.460 --> 00:09:40.960
Those are basically notifications to
the business object that something

00:09:40.960 --> 00:09:43.730
has happened on the client side,
that the object has been

00:09:43.730 --> 00:09:44.970
updated on the client side.

00:09:44.980 --> 00:09:48.900
And you can use it to perform
additional validation,

00:09:48.900 --> 00:09:51.470
or you can do computations.

00:09:51.580 --> 00:09:55.710
Basically, it's a notification that tells
you the values for this object

00:09:55.790 --> 00:09:58.300
were changed on the client side.

00:09:58.350 --> 00:10:02.660
And prepare values for client is invoked
right before the object is sent back.

00:10:02.660 --> 00:10:05.450
When you send the result
back to the client,

00:10:05.880 --> 00:10:09.130
Before the object is
encoded to be transferred,

00:10:09.230 --> 00:10:10.890
we invoke prepare values for clients.

00:10:10.910 --> 00:10:14.860
If you have derived attributes that
are only visible on the client side,

00:10:14.920 --> 00:10:17.660
evade from client update and prepare
values for client are very useful.

00:10:19.360 --> 00:10:23.490
You can basically delay the computation
of the direct values until we

00:10:23.490 --> 00:10:24.800
invoke prepare values for client.

00:10:24.820 --> 00:10:30.470
Again, the order is, on the client side,
you invoke invoke remote method.

00:10:30.480 --> 00:10:34.360
On the server side,
evoke from client update is invoked.

00:10:34.380 --> 00:10:37.140
Then the remote method
actually is performed.

00:10:37.140 --> 00:10:40.320
Before the object is sent back,
we invoke prepare values for client.

00:10:42.790 --> 00:10:45.180
There's a very important
naming convention we use for

00:10:45.220 --> 00:10:46.700
remote method invocations.

00:10:46.800 --> 00:10:49.620
The naming convention is that
if the name of the method

00:10:49.700 --> 00:10:55.160
starts with client-side request,
then we considered a method that is open

00:10:55.270 --> 00:10:58.540
for unrestricted access from any client.

00:10:58.550 --> 00:11:01.540
If your method does not start
with client-side request,

00:11:01.540 --> 00:11:03.800
then actually there's a
security mechanism in place,

00:11:03.820 --> 00:11:07.750
I'll talk a little more about it later,
that you can use to restrict the

00:11:07.780 --> 00:11:10.340
access of methods to certain clients.

00:11:11.820 --> 00:11:14.380
Something that is now
possible in WebObjects 5,

00:11:14.440 --> 00:11:19.390
but was not possible in WebObjects 4.5,
is that now you can use

00:11:19.390 --> 00:11:22.380
common superclasses for your
business logic implementations.

00:11:22.380 --> 00:11:26.130
In WebObjects 4.5 or 4.5.1,
the server side was

00:11:26.130 --> 00:11:30.620
implemented in Objective-C,
the client side was implemented in Java.

00:11:30.620 --> 00:11:35.710
In Objective-C, we had a wrapped API,
so the superclass was in

00:11:35.750 --> 00:11:38.080
a server-side package.

00:11:39.780 --> 00:11:41.380
So your generic record,
your custom object,

00:11:41.380 --> 00:11:44.320
were in the server-side package,
and the client had a different

00:11:44.320 --> 00:11:46.540
implementation of the superclass.

00:11:46.540 --> 00:11:49.700
So for a client-side business object
and a server-side business object,

00:11:49.700 --> 00:11:51.540
you couldn't use a common superclass.

00:11:51.540 --> 00:11:54.830
But that's actually possible now,
and that opens the door

00:11:54.830 --> 00:11:57.090
for a lot of good design,
actually.

00:11:57.100 --> 00:11:59.970
So what I recommend to you is
that you use common superclasses

00:11:59.970 --> 00:12:04.130
for the two implementations,
and just define methods abstract that

00:12:04.130 --> 00:12:07.140
you want to have different on both sides.

00:12:07.870 --> 00:12:11.760
And then you implement a client subclass
with the remote method invocations,

00:12:11.760 --> 00:12:15.150
and a server subclass with
the concrete computations.

00:12:15.200 --> 00:12:16.900
Let me show you an example.

00:12:18.680 --> 00:12:23.700
So this slide shows roughly how
a class secret would look like.

00:12:23.700 --> 00:12:26.480
This time I'm subclassing
e-Generic Record.

00:12:26.530 --> 00:12:29.040
As you can see,
the package there shows this example.com.

00:12:29.040 --> 00:12:31.790
I import comwebobjects.eu.control.

00:12:31.850 --> 00:12:32.690
It's just business logic.

00:12:32.700 --> 00:12:33.610
I don't need anything more.

00:12:33.640 --> 00:12:36.260
Then I would implement
shared functionality,

00:12:36.260 --> 00:12:38.980
and all the methods that
I want to have different,

00:12:38.980 --> 00:12:40.340
I declare abstract.

00:12:44.560 --> 00:12:46.960
For the client side,
I use a different package.

00:12:46.960 --> 00:12:49.380
The package is now example.client.

00:12:49.380 --> 00:12:51.580
And the class doesn't extend
eugenic record anymore.

00:12:51.580 --> 00:12:54.190
It extends my superclass,
the one that I just created,

00:12:54.190 --> 00:12:55.710
example.common-secret.

00:12:55.720 --> 00:13:00.940
And the implementation of secret value
performs the remote method invocation.

00:13:00.940 --> 00:13:02.920
As you can see,
I'm using our naming convention,

00:13:02.920 --> 00:13:05.820
client-side request, here,
so that it's a little easier for me.

00:13:05.820 --> 00:13:08.500
I don't have to worry about
the security restrictions then.

00:13:10.520 --> 00:13:12.700
And the method that
I invoke takes no arguments.

00:13:12.700 --> 00:13:15.470
That's why 9 and 9 at the end
of the invoke remote method,

00:13:15.470 --> 00:13:18.590
you know, if there are no arguments,
you can just pass 9.

00:13:20.740 --> 00:13:23.500
On the server side,
again I use a different package,

00:13:23.500 --> 00:13:24.550
example.server.

00:13:24.550 --> 00:13:28.860
The class again extends
the common superclass.

00:13:28.860 --> 00:13:33.090
And now the method secretValue actually
implements my real business logic.

00:13:33.090 --> 00:13:34.440
As you can see,
it's pretty complicated here.

00:13:34.440 --> 00:13:36.840
But then there's a second method.

00:13:36.840 --> 00:13:39.690
It's client-setRequest secretValue.

00:13:39.700 --> 00:13:41.970
So this is the method the
client actually invokes,

00:13:41.970 --> 00:13:43.790
and it then invokes the real method.

00:13:43.800 --> 00:13:47.160
So this is the design pattern
that I recommend to you.

00:13:47.160 --> 00:13:54.050
And this is convenient because
you can write business logic,

00:13:54.050 --> 00:13:56.260
your code,
against the abstract superclass,

00:13:56.260 --> 00:13:57.630
which is available on both sides.

00:13:57.650 --> 00:14:00.030
You don't have to worry
about the concrete package.

00:14:00.060 --> 00:14:03.170
If you want to reference the
class from other classes,

00:14:03.170 --> 00:14:05.960
from other code,
you would write it against

00:14:05.960 --> 00:14:09.000
the shared superclass,
which is abstract.

00:14:09.000 --> 00:14:12.680
But since the API is defined
already as abstract methods,

00:14:13.540 --> 00:14:16.960
you can compile against it,
and then it happens to resolve

00:14:16.980 --> 00:14:20.380
to the concrete subclasses in the
different packages at runtime.

00:14:24.610 --> 00:14:28.330
Let's take a look at the
objects that make this happen.

00:14:28.440 --> 00:14:30.660
There are four objects
I want to point out to you.

00:14:30.770 --> 00:14:33.150
Two on the server side,
Vue Java Client Applet and

00:14:33.220 --> 00:14:36.190
EU Distribution Context,
and two on the client side,

00:14:36.200 --> 00:14:39.570
EU Distributed Object Store and
EU Distribution Channel,

00:14:39.570 --> 00:14:42.610
or actually EU HTTP Channel,
as we'll see later.

00:14:43.030 --> 00:14:46.660
The Vue Java Client applet
is a WebObjects component.

00:14:46.720 --> 00:14:49.680
Don't get confused with the name
that there's an applet in there.

00:14:49.700 --> 00:14:52.260
It's a WebObjects component
living on the server side,

00:14:52.260 --> 00:14:54.860
and it's responsible for
generating the applet tag.

00:14:57.910 --> 00:15:02.030
It has a lot of bindings,
some specific to the applet,

00:15:02.030 --> 00:15:06.340
like the width and the height,
the code base.

00:15:06.380 --> 00:15:09.710
But it also has bindings
really specific to Java Client,

00:15:09.730 --> 00:15:12.640
for example,
the name of the application class,

00:15:12.710 --> 00:15:15.380
the name of the distribution channel,
as you will see later.

00:15:15.380 --> 00:15:18.130
If you use Direct to Java Client,
you have a binding that you

00:15:18.130 --> 00:15:22.550
can use to specify the class
of the controller factory.

00:15:22.600 --> 00:15:26.150
And so the whole Java Client
applet is the object.

00:15:26.890 --> 00:15:29.950
They basically represent through
which all the communication

00:15:29.950 --> 00:15:31.200
from the client goes.

00:15:31.200 --> 00:15:34.910
If the client contacts the server,
it actually talks to this object,

00:15:34.910 --> 00:15:38.030
the VoJava Client App that the
WebObjects component that we

00:15:38.030 --> 00:15:40.110
instantiated on the server side.

00:15:40.800 --> 00:15:43.950
Now, you might wonder how that all
works if you start the client

00:15:44.100 --> 00:15:47.580
application as a desktop application,
not as an applet,

00:15:47.580 --> 00:15:49.590
if you start it as a desktop app.

00:15:50.150 --> 00:15:53.800
Then actually we do create
a whole Java Client applet.

00:15:53.870 --> 00:15:57.260
We don't really need it in that case,
but we decided to do it anyway

00:15:57.260 --> 00:16:01.800
because it gives you one single place
where you can configure your client.

00:16:01.800 --> 00:16:06.440
We basically use the bindings of the
whole Java Client applet that you

00:16:06.440 --> 00:16:11.520
can define to both initialize applets
as well as desktop applications.

00:16:11.520 --> 00:16:14.940
So the advantage for you is you don't
have to worry about whether your

00:16:14.940 --> 00:16:18.610
client runs as an application or
whether your client runs as an applet.

00:16:18.940 --> 00:16:21.440
It's the same code path that
is executed all the time,

00:16:21.440 --> 00:16:24.440
and there's one place on the server side.

00:16:25.700 --> 00:16:28.760
In the code on the server side,
we can initialize or we can specify

00:16:28.770 --> 00:16:30.370
all the parameters for the client.

00:16:30.370 --> 00:16:33.990
And usually, if you want to change
some of the bindings,

00:16:33.990 --> 00:16:37.620
just open the main component,
go into the WebObjectsBuilder

00:16:37.620 --> 00:16:40.290
in the inspector and change
all the bindings there.

00:16:41.850 --> 00:16:45.340
The other important object on the server
side is the EU distribution context.

00:16:45.380 --> 00:16:48.010
The EU distribution context is
the object that performs all the

00:16:48.010 --> 00:16:50.860
work when it comes to Java Client.

00:16:50.860 --> 00:16:55.080
It's the object that keeps
track of a lot of state.

00:16:55.080 --> 00:16:59.080
It tracks which objects have
been fetched by the client.

00:16:59.080 --> 00:17:04.710
It's the object that basically takes
care of synchronizing business data

00:17:04.710 --> 00:17:07.560
on the client and the server side.

00:17:09.800 --> 00:17:12.840
We could have made the Vaujava
Client Applet and the EU distribution

00:17:12.910 --> 00:17:14.240
context the same object.

00:17:14.240 --> 00:17:17.460
That probably would have been
pretty poor object design.

00:17:17.460 --> 00:17:22.750
Second of all, as you will see later,
you actually have the choice to

00:17:22.750 --> 00:17:25.900
change the communication protocol.

00:17:25.900 --> 00:17:28.280
If you don't want to use
our way of communication,

00:17:28.280 --> 00:17:30.860
if you don't want to go through
a Vaujava Client Applet,

00:17:30.910 --> 00:17:33.720
you can plug in your own mechanism,
and so you would still use

00:17:33.830 --> 00:17:35.640
the EU distribution context.

00:17:37.800 --> 00:17:41.250
The EU distribution context is basically
the object that receives messages,

00:17:41.250 --> 00:17:43.650
but it just forwards it to
the distribution context,

00:17:43.660 --> 00:17:47.650
and the distribution context is
where all the work is performed.

00:17:50.120 --> 00:17:53.100
On the client side,
the two important objects

00:17:53.140 --> 00:17:55.300
are EODistributedObjectStore
and EODistributionChannel.

00:17:55.300 --> 00:18:00.080
The EODistributedObjectStore is
another type of root object store.

00:18:00.080 --> 00:18:03.400
It basically replaces the EU database
context that you might be familiar with.

00:18:03.400 --> 00:18:07.380
The distributed object store
acts as the parent object store

00:18:07.410 --> 00:18:09.580
for all the editing contexts.

00:18:09.580 --> 00:18:11.840
So when editing contexts
fetch or save data,

00:18:11.860 --> 00:18:14.360
they go through the
distributed object store.

00:18:15.120 --> 00:18:17.800
And the distributed object
store basically makes the client

00:18:17.830 --> 00:18:20.550
behave like a nested editing
context to the server side.

00:18:22.550 --> 00:18:25.510
And every distributed object store,
the distributed object store

00:18:25.520 --> 00:18:28.700
uses a distribution channel to
actually perform the communication.

00:18:28.700 --> 00:18:32.150
So the distribution channel is
responsible for sending the data

00:18:32.180 --> 00:18:34.000
from the client to the server.

00:18:34.000 --> 00:18:37.920
And your distribution channel
is actually an abstract class,

00:18:37.920 --> 00:18:41.520
and you will usually use the
concrete subclass UHTTP channel.

00:18:41.520 --> 00:18:45.120
But if you don't like it,
you can plug in your own

00:18:45.120 --> 00:18:47.050
way of communication.

00:18:47.060 --> 00:18:50.520
I know that you all like pictures,
so I have one for you.

00:18:51.560 --> 00:18:56.540
So if an editing context, you know,
on the client side, fetches data,

00:18:56.540 --> 00:18:59.710
it will actually go through
a distributed object store,

00:18:59.720 --> 00:19:02.780
which will use the distribution
channel to perform actually the

00:19:02.780 --> 00:19:04.720
communication with the server side.

00:19:04.720 --> 00:19:07.870
On the server side,
the VoJava Client Applet,

00:19:07.880 --> 00:19:10.260
the instance of VoJava Client
Applet that we created,

00:19:10.260 --> 00:19:12.410
is the object that receives the request.

00:19:12.420 --> 00:19:15.640
It forwards it to the
distribution context,

00:19:15.640 --> 00:19:18.780
and that one then, you know,
usually accesses the editing context,

00:19:18.800 --> 00:19:20.480
the default editing
context of the session,

00:19:20.720 --> 00:19:22.720
to actually, you know,
take a look at the data.

00:19:22.720 --> 00:19:24.720
So the four objects that
I introduced to you,

00:19:24.720 --> 00:19:26.720
the distributed object store,
the distribution channel,

00:19:26.720 --> 00:19:30.720
the VoJava Client Applet,
and the distribution context,

00:19:30.730 --> 00:19:33.640
those four objects work together
to connect the editing context

00:19:33.740 --> 00:19:36.720
on the client side to the editing
context on the server side.

00:19:41.730 --> 00:19:44.230
Now that we know the
distributed object store,

00:19:44.230 --> 00:19:47.990
there's actually an
API I want to mention to you.

00:19:48.220 --> 00:19:51.530
The EU distributed object store
can easily be found because

00:19:51.530 --> 00:19:52.710
it's the root object store.

00:19:52.760 --> 00:19:57.180
There's API in EU object store,
default root object store.

00:19:57.350 --> 00:19:57.980
Is it that one?

00:19:57.980 --> 00:19:59.380
Default, root, parent?

00:19:59.380 --> 00:20:00.810
Sorry about that.

00:20:00.830 --> 00:20:01.900
You'll find it.

00:20:01.950 --> 00:20:06.580
So it's actually very easy to
access the EODC Build Object Store.

00:20:06.580 --> 00:20:13.590
And it has a generic API you can use
to perform remote method invocation.

00:20:13.600 --> 00:20:16.380
So if you have something you
need from the server that is

00:20:16.380 --> 00:20:19.240
not related to business logic,
something that you need

00:20:19.240 --> 00:20:22.270
in your application logic,
maybe information about what

00:20:22.530 --> 00:20:27.190
kind of resources are available,
maybe you want to handle user

00:20:27.190 --> 00:20:30.740
defaults in a special way,
then you can use this method here.

00:20:30.740 --> 00:20:34.180
And it takes similar parameters
than the one that we found

00:20:34.180 --> 00:20:35.500
on EO Enterprise Object.

00:20:35.500 --> 00:20:40.360
It takes an editing context,
the reason I'll talk about in a minute.

00:20:40.360 --> 00:20:45.070
It takes a key path that actually
identifies the object on the server

00:20:45.070 --> 00:20:47.400
side that receives the method.

00:20:47.400 --> 00:20:51.600
If you invoke it on an Enterprise Object,
it's clear which object is the

00:20:51.610 --> 00:20:53.540
receiver on the server side.

00:20:53.540 --> 00:20:56.420
Because there's one version of
the business object on the client,

00:20:56.530 --> 00:20:59.660
one version on the server side,
there's an equivalent on the server side,

00:20:59.660 --> 00:21:01.120
so we know exactly where
to send the method.

00:21:01.120 --> 00:21:04.610
But for the generic API here,
you have to specify where to send it.

00:21:04.620 --> 00:21:08.250
The other arguments, method name,
argument types, and arguments,

00:21:08.250 --> 00:21:09.300
we already know.

00:21:09.300 --> 00:21:11.210
And there's another flag, push changes.

00:21:13.330 --> 00:21:17.900
So the method, the arguments,
editing context, and push changes,

00:21:17.900 --> 00:21:21.900
I think you will probably
not need them very often.

00:21:21.900 --> 00:21:26.460
But if your remote method invocation is
related to some kind of business logic,

00:21:26.460 --> 00:21:30.040
you can pass an editing context,
and this method here will make

00:21:30.040 --> 00:21:33.700
sure that the state of that editing
context is synchronized with

00:21:33.700 --> 00:21:36.060
the server-side editing context.

00:21:38.060 --> 00:21:40.940
So if you need the latest state
of the business logic of the

00:21:40.940 --> 00:21:44.730
business data on the server-side,
you can pass the editing context,

00:21:44.740 --> 00:21:46.960
and for push changes you'd pass true.

00:21:46.960 --> 00:21:49.960
And then the distribution layer
would take care of synchronizing

00:21:50.100 --> 00:21:52.860
the state of the editing context
you pass to this method here,

00:21:52.870 --> 00:21:55.180
and the editing context
on the server-side.

00:21:58.210 --> 00:22:01.440
Let's take a look at the
key path for a moment.

00:22:01.780 --> 00:22:07.740
There are three ways you can describe the
target of the remote method invocation.

00:22:07.840 --> 00:22:10.570
First of all,
you can pass just null for the key path.

00:22:10.650 --> 00:22:13.120
If you do that,
the distribution layer assumes that

00:22:13.140 --> 00:22:16.760
you want to invoke the method on
the distribution context directly.

00:22:16.800 --> 00:22:19.540
It's pretty rare,
and on our default mutation

00:22:19.540 --> 00:22:21.420
of your distribution context,
there's probably nothing

00:22:21.420 --> 00:22:22.210
you want to invoke.

00:22:22.220 --> 00:22:24.660
But if you use subclasses
of distribution context,

00:22:24.690 --> 00:22:26.700
this might come in handy.

00:22:27.020 --> 00:22:29.470
More common is probably that
you pass an empty string.

00:22:29.480 --> 00:22:32.770
An empty string indicates to
the distribution layer that you

00:22:32.900 --> 00:22:36.510
want to invoke a method on what
we call a distribution target.

00:22:36.520 --> 00:22:39.800
The distribution context
on the server side has a

00:22:39.950 --> 00:22:42.290
registry for arbitrary objects.

00:22:42.290 --> 00:22:45.480
You can just add additional
objects to a registry.

00:22:45.480 --> 00:22:47.870
And when there's a
remote method invocation,

00:22:47.870 --> 00:22:51.710
the distribution context will search
through these targets and find the

00:22:51.710 --> 00:22:55.790
first one that implements the method you
described and invoke the method on it.

00:22:55.800 --> 00:22:58.620
So these invocation targets
are a very convenient way to

00:22:58.620 --> 00:23:02.200
basically extend the functionality
of the distribution context.

00:23:02.200 --> 00:23:06.430
There's nothing,
the object can really be arbitrary,

00:23:06.430 --> 00:23:09.400
you know, any class does just fine.

00:23:09.400 --> 00:23:11.700
It just has to implement the
method you want to invoke,

00:23:11.710 --> 00:23:13.700
and the method has to be public,
by the way.

00:23:13.720 --> 00:23:17.210
Now the question is,
how do you register additional targets?

00:23:17.270 --> 00:23:19.700
Because, you know,
while the server is running,

00:23:19.700 --> 00:23:21.620
there are multiple clients
that are instantiated.

00:23:21.620 --> 00:23:23.430
There's not just one
distribution context.

00:23:23.430 --> 00:23:25.640
For every client,
there's a distribution context.

00:23:25.800 --> 00:23:27.770
So to help you,
we send out a notification,

00:23:27.790 --> 00:23:31.550
and it's called EO Remote Method Receiver
Needed Notification.

00:23:31.560 --> 00:23:35.400
It's a very long name, so use copy-paste.

00:23:36.600 --> 00:23:39.030
If you register for this
notification and receive it,

00:23:39.040 --> 00:23:43.060
you can use the notification
to add your invocation target.

00:23:43.060 --> 00:23:45.760
So basically, you could make,
for example, your application object.

00:23:45.760 --> 00:23:49.070
You can register your application
object for this notification.

00:23:49.080 --> 00:23:51.600
And then in the notification,
the user info dictionary,

00:23:51.600 --> 00:23:54.960
you would actually find the distribution
context that was just created.

00:23:54.960 --> 00:23:57.530
So when the client
connects to the server,

00:23:57.530 --> 00:24:01.310
you would send out this notification,
and it would contain the

00:24:01.470 --> 00:24:03.040
distribution context.

00:24:03.080 --> 00:24:06.400
And then you can use it to
add your method receivers.

00:24:06.600 --> 00:24:07.760
Yes.

00:24:07.940 --> 00:24:10.480
And if you don't pass an I,
and if you don't pass an empty string,

00:24:10.480 --> 00:24:14.170
then the distribution layer
assumes that the key path actually

00:24:14.260 --> 00:24:19.120
identifies an object relative
to the distribution context.

00:24:19.120 --> 00:24:21.540
For example, it could be a session,
right?

00:24:21.570 --> 00:24:23.540
A distribution context
has a method session.

00:24:23.540 --> 00:24:28.600
So if you specify session, you know,
we would follow the key path, the string,

00:24:28.600 --> 00:24:32.960
interpret it as a key path,
starting at the distribution context.

00:24:33.400 --> 00:24:35.150
You know,
go to the target and use that one

00:24:35.150 --> 00:24:37.930
as the method you want to send the,
that one as the object you

00:24:37.930 --> 00:24:39.360
want to send the method to.

00:24:40.720 --> 00:24:43.540
Again, even for this generic API,
we use the naming convention

00:24:43.540 --> 00:24:44.740
client-side request.

00:24:44.740 --> 00:24:47.460
So if your method name starts
with client-side request,

00:24:47.460 --> 00:24:49.360
it's open for unrestricted access.

00:24:53.730 --> 00:24:55.410
We'll talk a little bit more
about distribution channels.

00:24:55.440 --> 00:25:00.790
As I said, the distribution channels are
responsible for transferring the

00:25:00.790 --> 00:25:02.180
data between client and server.

00:25:02.180 --> 00:25:05.780
And as I said, there's an abstract class
e-distribution channel,

00:25:05.780 --> 00:25:08.550
and there's a concrete
subclass e-HTTP channel.

00:25:08.580 --> 00:25:11.960
You will probably, on most of the cases,
you will stick with the e-HTTP channel.

00:25:11.960 --> 00:25:14.330
If you don't like it at all,
you can implement your own

00:25:14.330 --> 00:25:17.200
subclass of e-distribution
channel and use that instead.

00:25:18.060 --> 00:25:24.180
It's fairly complicated, so if you can,
try to stick with the e-HTTP channel.

00:25:26.040 --> 00:25:28.450
If you want to change the class
of the distribution channel,

00:25:28.610 --> 00:25:32.130
there's a binding in the Vore
Java Client applet that you can change,

00:25:32.130 --> 00:25:35.910
and there you can specify the new
class name that you want to use.

00:25:38.650 --> 00:25:41.030
On your HTTP channel,
there's one method that

00:25:41.040 --> 00:25:44.450
is particularly important,
because if you want to do things

00:25:44.450 --> 00:25:47.710
like connecting through SSL,
you can override this one method here,

00:25:47.710 --> 00:25:48.640
createSocket.

00:25:48.640 --> 00:25:51.190
You pass the protocol of the URL,
the host name,

00:25:51.190 --> 00:25:54.210
and the port number to create
a different kind of socket,

00:25:54.210 --> 00:25:55.920
for example, an SSL socket.

00:25:55.940 --> 00:25:59.920
Now, I'd actually like to show you
an example running through SSL,

00:25:59.980 --> 00:26:02.990
and I'd like to ask Norbert
Schatz to come up on stage

00:26:03.060 --> 00:26:04.820
and drive the demo for me.

00:26:04.820 --> 00:26:07.340
So if you could switch
to the demo machine.

00:26:11.890 --> 00:26:16.940
For our demo purposes here,
we used a package called JSSE that

00:26:16.940 --> 00:26:18.450
you can download from Sun's website.

00:26:18.450 --> 00:26:23.960
It's basically some kind of a reference
implementation for a secure socket layer.

00:26:23.960 --> 00:26:27.380
And we have the code that we had
to write on the client side for

00:26:27.400 --> 00:26:29.420
the channel here on the screen.

00:26:29.420 --> 00:26:32.430
So as you can see,
there's a class SSL channel

00:26:32.480 --> 00:26:34.660
extending our UHTTP channel.

00:26:35.420 --> 00:26:37.780
And if you focus for a moment
on the createSocket method,

00:26:37.780 --> 00:26:42.420
we first check whether
it's actually using HTTPS.

00:26:42.420 --> 00:26:44.680
If not, we just use the
superclass implementation.

00:26:44.680 --> 00:26:50.080
So this distribution channel
actually supports both protocols.

00:26:50.080 --> 00:26:53.720
And if it's HTTPS,
then the only thing we have to

00:26:53.720 --> 00:26:57.960
do is to use the JSSE classes
to create an SSL socket.

00:26:59.600 --> 00:27:34.100
[Transcript missing]

00:27:34.470 --> 00:27:37.930
Okay, I think now we'd just like to
run the application just so

00:27:37.950 --> 00:27:39.900
that you know that it works.

00:27:50.530 --> 00:27:52.180
So the server is starting.

00:27:52.180 --> 00:27:57.600
And so far, we obviously used this
Java Client Launcher program.

00:27:58.500 --> 00:28:01.770
I think it's minimized in the dark,
so it's at the right side.

00:28:01.800 --> 00:28:04.260
This time we want to show you
actually the script that we're using.

00:28:04.260 --> 00:28:06.680
So we wrote in a script,
and it's very simple.

00:28:06.680 --> 00:28:11.960
It's based on the script that
WebObjects generates for you anyway if

00:28:11.960 --> 00:28:15.340
you compile Java Client applications.

00:28:16.920 --> 00:28:20.350
We always create a launch script
for you for the server side,

00:28:20.350 --> 00:28:22.320
but we also create a
script for the client side.

00:28:22.320 --> 00:28:23.300
We just use that one.

00:28:23.300 --> 00:28:26.560
And then the difference is,
if you pass in the URL, as you can see,

00:28:26.560 --> 00:28:27.620
we use HTTPS.

00:28:27.620 --> 00:28:31.140
And if you pass additional arguments,
which is just channel class name,

00:28:31.140 --> 00:28:33.000
and there's our new channel class.

00:28:33.000 --> 00:28:35.680
So let's execute the script.

00:28:46.200 --> 00:28:48.700
And hopefully in a second we will
see an application that we just

00:28:48.700 --> 00:28:49.940
generated with the assistant.

00:28:49.940 --> 00:28:52.410
It's nothing fancy
about that application,

00:28:52.410 --> 00:28:53.820
but it connects to SSA.

00:28:55.980 --> 00:28:58.130
So there's actually not a lot
of code you have to write on the

00:28:58.150 --> 00:28:59.400
client side to make that happen.

00:28:59.400 --> 00:29:01.600
It actually turned out to us that
it's much more complicated to

00:29:01.600 --> 00:29:06.900
configure Apache to allow us to do
SSL than to implement the client side.

00:29:17.000 --> 00:29:27.000
[Transcript missing]

00:29:31.400 --> 00:29:32.860
Let's switch back to the slides.

00:29:32.860 --> 00:29:33.360
Thank you.

00:29:33.360 --> 00:29:40.960
A lot of features,
a lot of the hooks that you need

00:29:40.960 --> 00:29:46.040
to use are implemented or available
to you in the form of delegates.

00:29:46.040 --> 00:29:49.890
There are two objects where
you can set a delegate to.

00:29:50.390 --> 00:29:53.100
One is on the server side,
one is on the client side again.

00:29:53.110 --> 00:29:56.690
On the server side is on
the EU distribution context.

00:29:56.900 --> 00:30:00.520
There are various delegate
methods you can implement.

00:30:00.560 --> 00:30:02.040
Just to list what you can do.

00:30:02.040 --> 00:30:04.790
First of all, you can encrypt and
decrypt the communication.

00:30:04.790 --> 00:30:07.250
So every byte that is sent
between client and server,

00:30:07.250 --> 00:30:09.620
you can apply your own
encryption mechanism to.

00:30:09.620 --> 00:30:11.730
I think it's probably more
convenient for you to just use

00:30:11.730 --> 00:30:12.930
SSL or something like that.

00:30:12.930 --> 00:30:15.100
If you want to implement your
own encryption mechanism,

00:30:15.100 --> 00:30:17.740
you have delegate methods where you
can control every single byte that

00:30:17.740 --> 00:30:19.260
is sent between client and server.

00:30:21.690 --> 00:30:27.730
You can also control the access of the
client when fetching business objects.

00:30:27.780 --> 00:30:29.190
Basically,
there's a delegate method where you

00:30:29.210 --> 00:30:32.590
can control exactly which objects
the client's allowed to fetch.

00:30:32.600 --> 00:30:36.330
So if you don't want to make objects
of an entity visible to the client,

00:30:36.330 --> 00:30:39.090
you can just delegate and just say, no,
you can't see that.

00:30:39.100 --> 00:30:40.470
Sorry.

00:30:40.840 --> 00:30:45.710
The third hook you have in the
delegate is that you can restrict the

00:30:45.830 --> 00:30:47.660
invocation of remote method invocations.

00:30:47.660 --> 00:30:51.820
If you don't follow the naming
convention clients at request,

00:30:51.820 --> 00:30:57.080
then by default we do not allow the
clients to invoke any other method.

00:30:57.080 --> 00:31:00.420
But you can use the delegate to
open up the method invocation.

00:31:00.420 --> 00:31:04.460
So for every remote method invocation
that the client tries to perform,

00:31:04.460 --> 00:31:08.660
the delegate will be notified and can,
on a client basis,

00:31:08.660 --> 00:31:11.710
determine whether this method can
be executed on the server or not.

00:31:11.720 --> 00:31:14.440
So those are pretty strong
security features here.

00:31:14.460 --> 00:31:16.850
On the client side of the
e-distribution channel,

00:31:16.850 --> 00:31:19.160
you can also handle
encryption and decryption,

00:31:19.160 --> 00:31:20.910
but this is the other way around.

00:31:20.920 --> 00:31:24.030
Both client and server
obviously need to work together,

00:31:24.030 --> 00:31:25.880
otherwise you get a lot of mess.

00:31:29.600 --> 00:31:33.270
So, the second piece is,
the second hook in the delegate

00:31:33.270 --> 00:31:37.430
of the distribution channel is
that you can deal with exceptions.

00:31:37.430 --> 00:31:39.580
There are two types of
exceptions you can get.

00:31:39.600 --> 00:31:42.000
One is an I/O exception,
something went wrong

00:31:42.000 --> 00:31:45.540
with your communication,
right, maybe you can't open a socket,

00:31:45.540 --> 00:31:47.600
you know,
maybe the network just went down,

00:31:47.600 --> 00:31:48.600
something like that.

00:31:48.600 --> 00:31:51.870
If there's an exception like that,
the delegate can handle it,

00:31:51.870 --> 00:31:54.590
it can try to reconnect maybe,
but it's up to you.

00:31:54.600 --> 00:31:57.560
But there's another type of
exception that happens quite often,

00:31:57.580 --> 00:32:00.690
and that is that something on the server,
right, there's nothing wrong

00:32:00.690 --> 00:32:03.190
with the communication,
but there's an exception

00:32:03.190 --> 00:32:04.600
raised on the server side.

00:32:04.600 --> 00:32:07.370
Maybe a validation error, right,
maybe a validation method

00:32:07.380 --> 00:32:09.420
on the server side,
the business logic on the

00:32:09.420 --> 00:32:11.190
server side raised an exception.

00:32:11.300 --> 00:32:23.500
[Transcript missing]

00:32:25.420 --> 00:32:28.960
The timing is pretty important
for setting the delegates,

00:32:29.020 --> 00:32:32.450
because especially if you do
encryption and decryption,

00:32:32.460 --> 00:32:34.750
you have to make sure that the
delegates are in place before

00:32:34.910 --> 00:32:36.380
the first byte is transferred.

00:32:36.380 --> 00:32:41.100
The delegate needs to be in place
on both sides of the architecture.

00:32:41.920 --> 00:32:48.600
So the best way for you to set delegates
is on the server side by registering

00:32:48.660 --> 00:32:50.330
for another type of notification.

00:32:50.330 --> 00:32:54.140
It's the e-distribution context
instantiated notification.

00:32:54.140 --> 00:32:58.990
You send it out whenever we
create an e-distribution context,

00:32:58.990 --> 00:33:01.780
and there you can set a delegate.

00:33:02.620 --> 00:33:06.700
And on the client side,
the best way for you to set the

00:33:06.700 --> 00:33:11.560
delegate of the distribution channel
is by using a subclass of your

00:33:11.560 --> 00:33:14.120
application and going to the constructor.

00:33:14.120 --> 00:33:19.260
It's really the only place that
you have to plug in your own logic

00:33:19.260 --> 00:33:22.450
before we make the first round trip.

00:33:22.460 --> 00:33:24.680
If you don't do
encryption and decryption,

00:33:24.680 --> 00:33:25.800
you can do it later.

00:33:25.800 --> 00:33:30.270
But if you use encryption and decryption,
then you would have

00:33:30.320 --> 00:33:32.300
to use an application.

00:33:32.460 --> 00:33:34.790
your application subclass.

00:33:37.740 --> 00:33:41.290
I'd like now to talk a little
bit more about deployment issues.

00:33:41.340 --> 00:33:44.660
First of all, I'd like to go over the
system requirements.

00:33:44.770 --> 00:33:48.670
For the server side,
a Java Client server application is

00:33:48.670 --> 00:33:49.990
a standard WebObjects application.

00:33:50.000 --> 00:33:51.800
Wherever you can deploy
a WebObjects server,

00:33:51.800 --> 00:33:54.060
you can deploy a WebObjects
server for a Java Client.

00:33:54.720 --> 00:33:58.240
On the client side,
the only thing we require is JDK 1.3.

00:33:58.250 --> 00:33:59.920
That does contain Swing now.

00:33:59.920 --> 00:34:03.500
That was different in earlier times,
the JDK 1.1.8.

00:34:03.500 --> 00:34:06.520
Now JDK 1.3 contains Swing,
so there's no need to

00:34:06.520 --> 00:34:08.100
download it anymore.

00:34:08.100 --> 00:34:10.470
On MacOSX,
MacOSX is probably the best

00:34:10.480 --> 00:34:14.770
platform to deploy Java Client
applications because JDK 1.3 is

00:34:14.770 --> 00:34:18.560
integrated in the operating system,
very convenient.

00:34:18.560 --> 00:34:22.280
On Windows, you would have to download
it from some website.

00:34:22.280 --> 00:34:26.840
And unfortunately, on MacOS 9,
there's no JDK 1.3 support,

00:34:26.840 --> 00:34:29.020
so you will not be able to deploy there.

00:34:32.890 --> 00:34:37.590
The two options you have with
Java Client for deployment are

00:34:37.590 --> 00:34:40.920
desktop applications or applets.

00:34:41.230 --> 00:34:45.200
If you deploy as a desktop application,
you will create a little launch program.

00:34:45.200 --> 00:34:48.200
On MacOSX,
you will probably use Project Builder,

00:34:48.200 --> 00:34:51.200
or there's another tool
called MRJ App Builder.

00:34:51.200 --> 00:34:53.420
On Windows,
you will probably just create a

00:34:53.420 --> 00:34:57.190
little launch script and then create
a shortcut to it from the desktop.

00:34:58.430 --> 00:35:03.600
If you deploy as an applet on MacOSX,
again, it's relatively easy.

00:35:03.680 --> 00:35:07.620
You would probably use Internet Explorer,
which comes with the system.

00:35:07.750 --> 00:35:12.700
And browsers on MacOSX use
the Java VM that comes

00:35:12.700 --> 00:35:14.540
with the operating system.

00:35:14.590 --> 00:35:16.220
That's pretty nice.

00:35:16.270 --> 00:35:21.520
On Windows, for both IE and Netscape,
you would probably be required

00:35:21.550 --> 00:35:23.570
to use the Java plugin.

00:35:23.690 --> 00:35:30.200
For IE, Microsoft has not committed
to JDK 1.2 or 1.3 support.

00:35:30.200 --> 00:35:32.890
I think Netscape has,
but it depends on the version

00:35:32.890 --> 00:35:34.440
of Netscape that you use.

00:35:34.490 --> 00:35:37.520
So the best way around this
is to use the Java plugin,

00:35:37.520 --> 00:35:38.920
which Sun provides.

00:35:38.930 --> 00:35:40.520
Again,
it can be downloaded from Sun's website.

00:35:40.520 --> 00:35:42.480
It's available to everybody.

00:35:42.550 --> 00:35:45.540
And Java Client is actually
pretty smart about this.

00:35:45.540 --> 00:35:48.760
It uses JavaScript to detect
the client configuration.

00:35:48.820 --> 00:35:50.670
So we do the right thing for you.

00:35:50.750 --> 00:35:53.000
You can just say, yes,
please use the Java plugin.

00:35:53.100 --> 00:35:56.650
You'll find out that if it's on MacOSX,
you don't have to use it.

00:35:56.660 --> 00:35:58.170
It's integrated in the operating system.

00:35:58.260 --> 00:36:01.160
If it's on Windows, for IE and Netscape,
you do the right thing.

00:36:01.240 --> 00:36:03.360
Users will be pointed
automatically to Sun's website.

00:36:03.400 --> 00:36:06.620
They can download the plugin,
and then everything is fine.

00:36:08.240 --> 00:36:10.760
Just to show you how easy it
is to create a launch program,

00:36:10.760 --> 00:36:13.310
I'd like to ask Norbert to come up again.

00:36:13.320 --> 00:36:16.780
And what we want to do is we want
to create a launch program for

00:36:16.780 --> 00:36:20.240
the application we just generated,
the SSL that we just demoed before,

00:36:20.390 --> 00:36:21.890
the SSL demo.

00:36:21.930 --> 00:36:25.290
And that's actually pretty nice because
we can demo a few features of the new

00:36:25.350 --> 00:36:27.970
project builder that come in very handy.

00:36:29.430 --> 00:36:31.400
So the first thing we do
is we create a new project.

00:36:31.400 --> 00:36:33.960
And this time, we just choose a
Java application template.

00:36:33.960 --> 00:36:36.060
It's not even a WebObjects template.

00:36:36.080 --> 00:36:38.520
You give it a name.

00:36:38.520 --> 00:36:40.910
Call it SSL Launcher.

00:36:45.710 --> 00:36:47.090
And this is a pretty simple project.

00:36:47.100 --> 00:36:49.060
It has a Java class.

00:36:49.060 --> 00:36:51.540
It has an icon file,
so you can drag in your

00:36:51.540 --> 00:36:53.720
own icon if you want.

00:36:53.910 --> 00:36:55.890
This is the default IKB we get.

00:36:55.890 --> 00:36:56.900
And there's the properties file.

00:36:56.900 --> 00:37:00.640
And we will go ahead and change
some of these properties.

00:37:00.640 --> 00:37:02.880
Actually, we already wrote them.

00:37:03.700 --> 00:38:52.200
[Transcript missing]

00:38:56.500 --> 00:39:00.100
Let's take a moment because there
are actually a lot of classes that

00:39:00.100 --> 00:39:02.190
need to merge together in one Java.

00:39:16.100 --> 00:39:35.800
[Transcript missing]

00:39:42.510 --> 00:39:44.380
And it won't look very
different from before,

00:39:44.380 --> 00:39:46.440
but the nice thing is now we
have a desktop application.

00:39:46.440 --> 00:39:48.360
It's self-contained.

00:39:48.360 --> 00:39:49.570
We can take this one app.

00:39:49.630 --> 00:39:50.860
We can ship it to the client.

00:39:50.860 --> 00:39:51.920
That's all we have to do.

00:39:51.920 --> 00:39:53.060
Very nice.

00:40:03.800 --> 00:40:04.640
What's happening?

00:40:04.640 --> 00:40:04.980
There it is.

00:40:04.980 --> 00:40:06.330
So there's our client.

00:40:06.340 --> 00:40:07.350
Nothing special about it.

00:40:07.360 --> 00:40:09.090
Okay, thank you, Norbert.

00:40:09.100 --> 00:40:15.980
Could switch back to the slides.

00:40:22.760 --> 00:40:25.400
Okay, I'd like to go again to the
deployment options and compare

00:40:25.490 --> 00:40:26.920
the two deployment options.

00:40:26.920 --> 00:40:29.460
This is basically going to be a
repetition of what we've heard so far,

00:40:29.460 --> 00:40:31.080
but I think it's very
important to understand.

00:40:32.600 --> 00:40:35.290
So the biggest advantage of
an applet is the simplicity

00:40:35.290 --> 00:40:38.130
of the client installation,
because when the applet starts up,

00:40:38.130 --> 00:40:41.820
it downloads all the classes from
the server side that it needs

00:40:41.880 --> 00:40:43.890
to execute the client program.

00:40:44.400 --> 00:40:46.360
So if you want to
upgrade your application,

00:40:46.360 --> 00:40:48.260
if you want to ship a new
version of the client,

00:40:48.260 --> 00:40:51.150
you just have to install the
new classes on the server side,

00:40:51.160 --> 00:40:52.920
and when the clients
start up the next time,

00:40:52.920 --> 00:40:54.820
the applets,
they just pick up the new classes,

00:40:54.880 --> 00:40:56.860
so that's very convenient
for you to handle.

00:40:56.860 --> 00:40:58.710
With applications,
you first of all have to

00:40:58.710 --> 00:41:00.760
create this launch program,
and then you have to

00:41:00.760 --> 00:41:02.000
install it on the client.

00:41:02.000 --> 00:41:05.090
And on the client,
you have to have all the Java classes

00:41:05.090 --> 00:41:07.040
available on the client side.

00:41:07.040 --> 00:41:10.390
So if you want to upgrade,
you're in a little bit of trouble because

00:41:10.420 --> 00:41:14.160
you have to make sure that all your
end users upgrade to the new version.

00:41:14.300 --> 00:41:17.830
So the advantage of the applet
is really that installation

00:41:17.830 --> 00:41:19.580
and upgrading is so easy.

00:41:19.580 --> 00:41:22.870
On the other side,
the applications provide a

00:41:22.870 --> 00:41:26.790
much better user experience,
which is much more convenient for the

00:41:26.790 --> 00:41:31.920
user to have a desktop application
that can be accessed through an icon

00:41:31.920 --> 00:41:35.780
on the desktop that is completely
embedded in the desktop environment.

00:41:35.780 --> 00:41:38.880
You can hide the application,
you can minimize windows,

00:41:38.890 --> 00:41:40.900
you have access to service menus.

00:41:40.900 --> 00:41:43.020
You don't have that with applets.

00:41:43.020 --> 00:41:46.370
So the user experience... is much nicer.

00:41:47.150 --> 00:41:52.800
Also, applications perform a
little better than applets.

00:41:52.820 --> 00:41:57.120
That's mostly because
applications run very isolated.

00:41:57.290 --> 00:41:59.770
Applets in one browser,
multiple applets in one browser

00:41:59.770 --> 00:42:01.230
actually share the same Java VM.

00:42:01.230 --> 00:42:04.350
So they can have all kinds
of negative side effects,

00:42:04.350 --> 00:42:07.420
both on the performance
and the stability side.

00:42:07.460 --> 00:42:12.530
That's not something you would be happy
about as an application developer.

00:42:13.030 --> 00:42:15.150
But applications are isolated.

00:42:15.160 --> 00:42:18.140
If another Java application is running,
it doesn't affect us.

00:42:18.140 --> 00:42:20.540
If it crashes,
if it does something bad with the system,

00:42:20.540 --> 00:42:23.680
it doesn't affect the Java application.

00:42:23.980 --> 00:42:28.080
Also from your perspective,
as the application developer,

00:42:28.160 --> 00:42:31.490
you don't have to deal with security
restrictions on the client side.

00:42:31.500 --> 00:42:34.480
In AppLess,
there's a security manager in place

00:42:34.480 --> 00:42:38.680
that usually prevents untrusted
code to access the file system.

00:42:38.680 --> 00:42:41.390
But applications,
you don't have to worry about that

00:42:41.390 --> 00:42:43.540
because there is no security manager.

00:42:43.540 --> 00:42:46.180
You can do everything you
need to do on the client side.

00:42:46.200 --> 00:42:48.390
End users might see
that a little different,

00:42:48.390 --> 00:42:50.600
and that's why it's
got a little dot here.

00:42:51.650 --> 00:42:55.230
Because, you know, with AppLess,
they know if it's untrusted code,

00:42:55.230 --> 00:42:58.420
that the Java VM will prevent the AppLess
from messing around with the computer.

00:42:58.420 --> 00:43:00.460
So they might actually
like to execute AppLess.

00:43:00.460 --> 00:43:02.670
This other side,
if you're in intranet environments,

00:43:02.670 --> 00:43:05.490
it probably doesn't matter so much
because hopefully your end users

00:43:05.520 --> 00:43:08.040
trust the system administrator
to pass out good software.

00:43:10.000 --> 00:43:13.600
The last thing that can come
in very handy with applications

00:43:13.600 --> 00:43:16.140
is that you have full control
over all the Java VM parameters.

00:43:16.140 --> 00:43:20.860
If you need a special heap size,
or you actually want to choose

00:43:20.860 --> 00:43:24.100
the VM you want to execute in,
you can do so with

00:43:24.100 --> 00:43:25.540
applications and applets.

00:43:25.540 --> 00:43:27.750
You don't have any control over that.

00:43:31.590 --> 00:43:36.790
A good compromise from my perspective is,
when it comes in regards to

00:43:36.790 --> 00:43:40.460
installation and upgrading,
to use a special class loader

00:43:40.460 --> 00:43:42.280
for the client application.

00:43:42.520 --> 00:43:44.260
The base system doesn't
change that often.

00:43:44.260 --> 00:43:50.180
The base system would be the JDK 1.3
and all our UF Java Client classes.

00:43:50.470 --> 00:43:54.760
So it's actually a very good idea to
install those classes on the client side.

00:43:54.760 --> 00:43:58.900
And then to download all the classes
that are specific to your application.

00:43:58.920 --> 00:44:01.800
That's actually exactly what we
do with this Java Client Launcher

00:44:01.800 --> 00:44:03.580
that we used in the previous demos.

00:44:03.580 --> 00:44:06.930
We didn't have to configure
the client in any special way.

00:44:06.950 --> 00:44:10.190
The reason was that it contacted
the server first of all,

00:44:10.190 --> 00:44:13.500
asked it what kind of classes
are specific to this client,

00:44:13.500 --> 00:44:17.580
downloaded those classes even
before it went into the EUF code.

00:44:18.440 --> 00:44:22.520
So that's very convenient because the
base system doesn't change that often.

00:44:22.520 --> 00:44:23.360
It's on the client.

00:44:23.360 --> 00:44:28.390
But you still get a fair amount of
upgradability with the special class

00:44:28.410 --> 00:44:32.450
loader because you can upgrade the
client classes on the server side.

00:44:32.460 --> 00:44:34.290
You can make it available
on the server side.

00:44:34.290 --> 00:44:36.960
And you only take a small hit because
there are usually not that many

00:44:36.960 --> 00:44:38.790
specific classes to your application.

00:44:38.820 --> 00:44:40.340
It's maybe 50 classes or so.

00:44:40.340 --> 00:44:41.910
And that's pretty quick to download.

00:44:41.910 --> 00:44:45.810
So you probably take a hit of one
to three seconds at startup time.

00:44:46.480 --> 00:44:50.030
But the benefit for you to be able
to upgrade the client applications

00:44:50.160 --> 00:44:54.270
quickly and fix bugs in an elegant way
without having to worry about shipping

00:44:54.270 --> 00:44:58.320
another installer and making sure that
all the clients really install it,

00:44:58.320 --> 00:45:00.020
that's quite compelling.

00:45:04.660 --> 00:45:08.960
The next two points,
session timeouts and server instances,

00:45:09.020 --> 00:45:11.730
I receive a lot of questions about that.

00:45:12.760 --> 00:45:16.870
So Java Client on the server
side uses normal Vose sessions.

00:45:16.900 --> 00:45:20.110
When the client connects,
you create a Vose session object,

00:45:20.110 --> 00:45:23.940
and sessions time out.

00:45:23.960 --> 00:45:28.250
That's usually not a problem,
except that users of desktop

00:45:28.480 --> 00:45:31.380
applications usually don't expect that.

00:45:31.380 --> 00:45:33.900
I mean,
if I'm running an app in a browser,

00:45:33.900 --> 00:45:36.580
I can understand why
a session time's out.

00:45:36.580 --> 00:45:39.310
But if I use a desktop application
that I just double-clicked,

00:45:39.340 --> 00:45:42.340
I don't usually see this
concept of session timeouts.

00:45:43.890 --> 00:45:48.180
So to help you,
Java Client explicitly notifies the

00:45:48.200 --> 00:45:51.910
server if the user quits the application.

00:45:51.910 --> 00:45:56.610
So what that means is that if
the client is terminated cleanly,

00:45:56.610 --> 00:46:00.660
so the user chooses the quit command,
then it will actually make a

00:46:00.660 --> 00:46:04.170
round trip to tell the server,
hey, I'm gone, and the server will then

00:46:04.170 --> 00:46:05.520
clean up that session.

00:46:06.080 --> 00:46:10.800
So for most of your clients,
you shouldn't have to worry about

00:46:10.800 --> 00:46:15.260
the session not terminating,
because it will explicitly

00:46:15.280 --> 00:46:17.070
notify the server.

00:46:17.070 --> 00:46:20.280
The only sessions that might
stay around is if maybe the

00:46:20.300 --> 00:46:24.710
network connection went down,
the user decided to kill the application,

00:46:25.060 --> 00:46:26.140
something like that.

00:46:26.180 --> 00:46:29.120
So there might be a few sessions
of not-cleanly terminated

00:46:29.120 --> 00:46:32.940
applications that stay around,
but that shouldn't really bother you.

00:46:32.940 --> 00:46:36.060
So the best way to leave the
session timeouts is to use event.

00:46:36.080 --> 00:46:39.720
So that's a very large timeout,
maybe 24 hours, maybe 48 hours.

00:46:39.720 --> 00:46:42.490
That way, users that started the
desktop application,

00:46:42.490 --> 00:46:45.270
started in the morning,
then maybe they went for lunch,

00:46:45.270 --> 00:46:49.180
come back three or four hours later,
maybe had a few meetings in between,

00:46:49.180 --> 00:46:51.730
but they don't face session timeouts,
and it shouldn't really concern

00:46:51.730 --> 00:46:53.090
you that the sessions are around.

00:46:56.430 --> 00:47:00.110
Let's talk about server
instances for a moment.

00:47:00.150 --> 00:47:01.470
With Java Client,
you can scale the server

00:47:01.480 --> 00:47:03.770
side in the normal way,
like with every other

00:47:03.780 --> 00:47:04.940
WebObjects application.

00:47:04.980 --> 00:47:07.440
If you serve a lot of
clients at the same time,

00:47:07.530 --> 00:47:10.350
just use multiple server instances.

00:47:11.000 --> 00:47:15.540
I'd like to give you a little more
information so that you can better

00:47:15.830 --> 00:47:18.840
understand what's going on with clients,
some information that might

00:47:18.850 --> 00:47:21.790
help you to determine how many
server instances you need.

00:47:21.800 --> 00:47:25.580
The first thing you should know
about Java Client is that there's

00:47:25.580 --> 00:47:27.940
usually a very high load at startup.

00:47:27.940 --> 00:47:31.470
Often there are classes
that have to be downloaded,

00:47:31.480 --> 00:47:33.980
especially if you run as applets.

00:47:33.980 --> 00:47:36.900
If you use Direct to Java Client,
there's some kind of

00:47:36.900 --> 00:47:38.930
UI information being exchanged.

00:47:40.450 --> 00:47:43.870
Also, users usually start out in
the beginning to search for

00:47:43.960 --> 00:47:45.820
objects they want to work with.

00:47:45.860 --> 00:47:48.020
So there's usually a
high load at startup,

00:47:48.020 --> 00:47:51.720
and then afterwards, it's usually just
relatively small packages.

00:47:51.720 --> 00:47:54.460
And actually,
for the same amount of data,

00:47:54.460 --> 00:47:58.750
the communication with Java Client,
the package size for the data,

00:47:58.750 --> 00:48:00.880
is much smaller than the HTML.

00:48:00.880 --> 00:48:04.870
So if you have five objects
you want to display in HTML,

00:48:04.870 --> 00:48:09.640
or the HTML around it,
if you compare that to the encoded data,

00:48:09.640 --> 00:48:12.370
the encoded stream of data
that we use for Java Client,

00:48:12.370 --> 00:48:14.270
the Java Client stream
is much more compact.

00:48:14.320 --> 00:48:18.190
It's really nicely
compacted business data.

00:48:18.520 --> 00:48:20.360
Now,
the fact that the packages are smaller

00:48:20.360 --> 00:48:22.510
doesn't mean that you will never
have a problem with communication.

00:48:22.510 --> 00:48:25.720
And what I would like to
point out is that usually,

00:48:25.750 --> 00:48:29.220
in intranet applications,
the amount of business data that the

00:48:29.380 --> 00:48:31.610
client wants to access is much larger.

00:48:56.210 --> 00:48:57.800
Okay, and I think we actually
do have enough time,

00:48:57.800 --> 00:49:00.360
so I'd like to talk a little more
about the Controller Factory.

00:49:03.570 --> 00:49:07.460
The controller factory is the object in
the center of Direct to Java Client's

00:49:07.460 --> 00:49:09.500
dynamic user interface generation.

00:49:09.540 --> 00:49:13.040
It's the object that's responsible
to communicate with the server

00:49:13.040 --> 00:49:16.500
to request a description of
the client-side user interface.

00:49:16.500 --> 00:49:20.450
It's responsible for instantiating
all the controller hierarchies

00:49:20.450 --> 00:49:22.500
that we use on the client-side.

00:49:22.920 --> 00:49:25.310
But the controller factory is
not only useful in dynamically

00:49:25.310 --> 00:49:27.070
generated applications.

00:49:27.180 --> 00:49:28.650
You can make use of it.

00:49:28.690 --> 00:49:31.480
It's actually very convenient
sometimes to mix dynamically

00:49:31.490 --> 00:49:34.900
created user interfaces and
statically generated user interfaces,

00:49:34.900 --> 00:49:37.980
so libfiles that you generate
in the interface builder.

00:49:38.140 --> 00:49:40.200
The factory provides--

00:49:40.400 --> 00:49:45.110
A good amount of API that you can use
to retrieve additional configuration

00:49:45.150 --> 00:49:46.940
information from the root system.

00:49:48.500 --> 00:50:32.900
[Transcript missing]

00:50:34.090 --> 00:50:37.110
There's also more low-level
API to retrieve what we

00:50:37.170 --> 00:50:39.200
call primitive controllers.

00:50:39.200 --> 00:50:43.900
You can consider a primitive controller
to be a small unit in the UI,

00:50:43.910 --> 00:50:46.620
basically related to
one entity and one task.

00:50:46.640 --> 00:50:50.490
So, for example, in the query window,
you usually have a little

00:50:50.690 --> 00:50:54.200
query primitive controller and
a list primitive controller.

00:50:54.200 --> 00:50:58.320
Every query pane in the query
window will usually consist

00:50:58.320 --> 00:51:00.800
of two primitive controllers.

00:51:01.420 --> 00:51:02.600
And there's a pretty large API.

00:51:02.600 --> 00:51:03.970
I just listed a few methods here.

00:51:03.990 --> 00:51:05.820
Query controller with entity,
list controller,

00:51:05.840 --> 00:51:07.900
and form controller with entity,
which you can use.

00:51:07.900 --> 00:51:11.770
And I'd actually like to show
you how you can use these methods

00:51:11.770 --> 00:51:14.110
to implement some nice features.

00:51:14.120 --> 00:51:16.220
So Norbert is coming up again.

00:51:16.220 --> 00:51:18.080
Could we please switch
to the demo machine?

00:51:20.010 --> 00:51:25.910
So here we have a prepared application,
and I think we first want to start it.

00:51:42.300 --> 00:51:44.500
So the server started,
and now we use the Java Client

00:51:44.500 --> 00:51:49.450
Launcher again to launch the client.

00:51:49.710 --> 00:51:51.450
So we're connecting to the server now.

00:51:51.460 --> 00:51:53.080
See,
the nice thing about this Java Client

00:51:53.080 --> 00:51:55.900
Launch is that we can even launch the
client before the server is there,

00:51:55.900 --> 00:51:58.000
because it will wait until all
the classes are downloaded,

00:51:58.000 --> 00:51:58.200
right?

00:51:58.200 --> 00:52:00.660
It will wait until we connect
and then download the classes,

00:52:00.660 --> 00:52:04.500
and then start,
then jump into the real EUF code.

00:52:04.530 --> 00:52:05.420
So here's our application.

00:52:05.420 --> 00:52:07.900
It looks pretty normal.

00:52:08.000 --> 00:52:10.750
Why don't you move that window
a little more to the left?

00:52:11.230 --> 00:52:15.540
And it looks like basically a window we
could have created with the Assistant.

00:52:15.550 --> 00:52:18.240
There's a special menu item in
this application that we added.

00:52:18.240 --> 00:52:19.420
It's called Configure.

00:52:19.540 --> 00:52:23.790
And we get a configuration tool,
which happens to look very similar

00:52:23.790 --> 00:52:25.640
to the Assistant that we usually use.

00:52:25.640 --> 00:52:29.440
Now let's just have Norbert play around
a little bit there and see what happens.

00:52:29.480 --> 00:52:33.440
So he's removing some
of the attributes there.

00:52:33.440 --> 00:52:36.150
And then he's switching to List.

00:52:40.920 --> 00:52:42.060
OK, doing the same thing there.

00:52:42.060 --> 00:52:49.940
Now watch the window on the left
side when we press the Apply button.

00:52:49.970 --> 00:52:54.350
So the UI automatically actually
configures to this new layout.

00:52:54.400 --> 00:52:59.070
So what we kind of simulate here is a
UI where the end user can actually choose

00:52:59.120 --> 00:53:01.520
what kind of data he or she wants to see.

00:53:01.520 --> 00:53:03.660
It's like a user-configurable UI.

00:53:03.660 --> 00:53:07.070
Let's take a look at the source
code we had to write for that.

00:53:07.210 --> 00:53:08.490
So why don't you quit the client?

00:53:08.500 --> 00:53:10.120
OK, that's fine.

00:53:10.160 --> 00:53:13.380
So the class, interesting, is JC dynamic,
which is a subclass of

00:53:13.380 --> 00:53:14.710
UI Interface Controller.

00:53:14.910 --> 00:53:17.220
And that's all the code we had to write.

00:53:17.220 --> 00:53:20.520
So the important method here
is update user interface.

00:53:20.520 --> 00:53:23.840
We invoke it both in the constructor
of the interface controller,

00:53:23.900 --> 00:53:28.350
and it's also invoked when we press
on the apply button in this tool,

00:53:28.360 --> 00:53:30.180
in the configuration tool.

00:53:30.200 --> 00:53:31.980
And as you can see,
the only thing we do is if

00:53:31.980 --> 00:53:35.130
there is already an editor,
we remove the old one.

00:53:35.210 --> 00:53:39.320
then we create a new one that we
have with the controller factory.

00:53:40.040 --> 00:53:44.730
And actually, the primitive controller,
you know, it's one controller with

00:53:44.730 --> 00:53:46.200
multiple subcontrollers.

00:53:46.200 --> 00:53:49.320
It's a little hierarchy of
controllers that is responsible for,

00:53:49.320 --> 00:53:50.890
you know, this editor part.

00:53:50.890 --> 00:53:53.100
And we search the list
controller in there.

00:53:53.100 --> 00:53:55.150
So we use a method on EU controller.

00:53:55.190 --> 00:53:57.800
It's called controller
with key value pairs,

00:53:57.800 --> 00:54:01.780
which this is a method that walks
through a hierarchy of controllers,

00:54:01.780 --> 00:54:06.160
you know, and looks for a matching
controller for this key value pair.

00:54:06.300 --> 00:54:08.160
And then we just set a relationship path.

00:54:08.160 --> 00:54:10.790
So that's basically the
connection of the list controller,

00:54:10.790 --> 00:54:13.410
you know, the detail controller
to the master interface.

00:54:13.410 --> 00:54:14.990
And we add the subcontroller.

00:54:14.990 --> 00:54:16.930
So that's all the code we
have to write for that.

00:54:16.960 --> 00:54:20.040
So the controller factory is really
useful for you if you want to have

00:54:20.050 --> 00:54:21.820
some kind of user configurable UI.

00:54:23.340 --> 00:54:25.950
And why don't you press
on the JC application.

00:54:26.000 --> 00:54:28.800
So this is code that would be
much more complicated for you.

00:54:28.800 --> 00:54:31.480
You would obviously have to come
up with a real tool for the user

00:54:31.500 --> 00:54:35.970
to enter the configuration data.

00:54:36.010 --> 00:54:37.080
But we made it easy.

00:54:37.080 --> 00:54:40.820
We just used some kind of a
simplified assistant here.

00:54:40.880 --> 00:54:44.350
And the most important piece, actually,
if you scroll up again--

00:54:46.700 --> 00:55:05.000
[Transcript missing]

00:55:13.100 --> 00:55:16.940
So just to repeat what we did,
if you want to come up with

00:55:16.940 --> 00:55:19.560
a user-configurable UI,
you would have to actually

00:55:19.580 --> 00:55:21.020
use the rule system.

00:55:21.020 --> 00:55:23.470
I mean,
we would use a dynamically generated

00:55:23.730 --> 00:55:25.440
piece in the user interface.

00:55:25.440 --> 00:55:29.510
So you would have to write a
rule to retrieve the list of

00:55:29.520 --> 00:55:31.680
properties the user really chose.

00:55:31.700 --> 00:55:33.710
So you would have to create
some kind of a database,

00:55:33.710 --> 00:55:34.810
a configuration store.

00:55:34.860 --> 00:55:36.060
It could be in the file system.

00:55:36.060 --> 00:55:37.680
It can be in the database.

00:55:37.680 --> 00:55:42.110
And in the interface file-- oh, actually,
sorry.

00:55:42.120 --> 00:55:44.580
I forgot about that.

00:55:44.590 --> 00:55:47.780
Could we switch-- do you
still have that open in IB?

00:55:50.400 --> 00:55:50.850
Just close.

00:55:50.870 --> 00:55:51.400
Okay.

00:55:51.400 --> 00:55:53.280
It doesn't matter.

00:55:53.300 --> 00:56:00.160
What we did in the interface file is we
basically created it with the assistant

00:56:00.160 --> 00:56:04.290
and then just removed the whole lower
portion of the lib file and replaced it

00:56:04.360 --> 00:56:06.440
with an empty box with an NS custom view.

00:56:06.440 --> 00:56:08.780
And we told the interface
controller that this is the

00:56:08.780 --> 00:56:10.470
so-called sub-controller area.

00:56:10.640 --> 00:56:17.000
The sub-controller area is a way for
us to point the controller to a view

00:56:17.000 --> 00:56:22.160
where all the sub-views of dynamically
generated UIs should be placed.

00:56:22.160 --> 00:56:28.000
And so we have to write a rule in
the rule system to retrieve the

00:56:28.000 --> 00:56:31.620
list of properties on a user basis.

00:56:31.620 --> 00:56:33.360
We would have to go
into the interface file,

00:56:33.360 --> 00:56:36.000
basically remove everything that
we want to create dynamically.

00:56:36.160 --> 00:56:37.340
We would replace it with an empty box.

00:56:37.340 --> 00:56:41.030
And then we have to write
a little bit of code that

00:56:41.040 --> 00:56:44.340
dynamically swaps sub-controllers.

00:56:44.340 --> 00:56:47.380
And as I said,
we use the API in the factory to

00:56:47.390 --> 00:56:50.080
retrieve primitive controllers.

00:56:50.080 --> 00:56:51.570
So for example,
this controller with the entity.

00:56:53.090 --> 00:56:55.160
And then obviously,
and probably the most complicated part,

00:56:55.180 --> 00:56:57.580
you would have to write a tool,
like a preferences panel,

00:56:57.580 --> 00:57:00.290
so that the user can configure the data.

00:57:01.710 --> 00:57:02.350
It's fine, don't worry.

00:57:02.360 --> 00:57:07.900
Okay, so in summary,
Java Client is very powerful.

00:57:07.900 --> 00:57:10.120
It's prepared for a
lot of advanced tasks.

00:57:10.120 --> 00:57:15.510
The most important objects are the
EODistributionContext on the server

00:57:15.510 --> 00:57:18.560
side and the EODistributedObjectStore
on the client side.

00:57:18.560 --> 00:57:22.710
I also mentioned the VotJavaClient
applet and the EODistributionChannel.

00:57:22.720 --> 00:57:25.900
I think most of the time you
will not work with them directly,

00:57:25.900 --> 00:57:29.940
but you use the EODistributionContext
and the EODistributedObjectStore

00:57:29.940 --> 00:57:31.460
and the delegates for those objects.

00:57:31.460 --> 00:57:33.620
Distribution channels are customizable.

00:57:33.620 --> 00:57:34.520
It's actually pretty easy.

00:57:34.520 --> 00:57:37.150
It's your sort of plug-in SSL.

00:57:37.510 --> 00:57:39.320
Again,
you have multiple options to deploy.

00:57:39.320 --> 00:57:42.000
You can deploy as a desktop
application or as an applet.

00:57:42.070 --> 00:57:45.180
And the controller factory
is a useful thing to look at,

00:57:45.270 --> 00:57:48.940
even if you don't want to leave
the traditional development.

00:57:48.940 --> 00:57:51.830
If you still want to work with
interface files and generate most

00:57:51.830 --> 00:57:54.340
of the pieces of the UI by hand,
the controller factory

00:57:54.340 --> 00:57:55.760
might make your life easier.

00:57:55.760 --> 00:57:57.680
It's really worth to take a look at it.

00:57:59.130 --> 00:58:03.610
Okay, I think typical slides at the end.

00:58:03.610 --> 00:58:05.680
The lab actually closes now.

00:58:05.680 --> 00:58:09.000
It's open tomorrow again at 10:30.

00:58:09.000 --> 00:58:12.000
Please vote for WebObjects
as the best app server.

00:58:12.000 --> 00:58:17.150
Those are the persons to contact: Tony,
our director, and Bob in product

00:58:17.200 --> 00:58:20.000
marketing and iServices.
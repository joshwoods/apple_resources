WEBVTT

00:00:00.180 --> 00:00:05.110
Please welcome Jon Summers,
QuickTime Java Engineering.

00:00:09.420 --> 00:00:14.750
Thank you and welcome to
session 507 QuickTime for Java.

00:00:14.780 --> 00:00:18.060
Now today, we're going to be taking
you through some of the new

00:00:18.060 --> 00:00:21.770
features in QuickTime for Java,
specifically those that

00:00:21.780 --> 00:00:24.240
support QuickTime 5 features.

00:00:24.410 --> 00:00:30.700
But before we do that,
I want to move on to show you, basically,

00:00:30.750 --> 00:00:33.560
the QuickTime for Java is
built of two major components.

00:00:33.640 --> 00:00:37.930
QuickTime,
which is Apple's proprietary media

00:00:38.190 --> 00:00:40.040
and Michael Higgins.

00:00:40.160 --> 00:00:42.100
The architecture is mature,
cross-platform, flexible.

00:00:42.100 --> 00:00:48.150
It has a rich set of services which
support industry standard media formats,

00:00:48.150 --> 00:00:51.470
such as dynamic media,
that is audio and video,

00:00:51.470 --> 00:00:55.320
and a wealth of still image
importers and exporters,

00:00:55.320 --> 00:00:59.750
and also interactive media,
such as QuickTime VR and wired sprites.

00:00:59.810 --> 00:01:05.870
Java from Sun Microsystems is a modern
object-oriented interpreted language.

00:01:06.120 --> 00:01:11.500
You can deploy Java cross-platform
as standalone applications,

00:01:11.500 --> 00:01:13.300
Java applications and applets.

00:01:13.300 --> 00:01:17.300
So that briefly is the
basis of QuickTime for Java.

00:01:17.300 --> 00:01:18.520
This is what it's built on.

00:01:20.800 --> 00:01:23.940
Now, the actual implementation
of QuickTime for Java.

00:01:24.050 --> 00:01:28.000
QuickTime for Java is a cross-platform
Java class library accessing the

00:01:28.050 --> 00:01:30.340
native QuickTime C libraries.

00:01:30.340 --> 00:01:33.670
It has a core layer,
which is an object model that

00:01:33.740 --> 00:01:36.700
represents the QuickTime C API.

00:01:36.770 --> 00:01:40.710
This is represented as a set
of Java classes which have been

00:01:40.790 --> 00:01:43.030
grouped into logical packages.

00:01:43.500 --> 00:01:46.160
Also,
QuickTime for Java has a sophisticated

00:01:46.160 --> 00:01:50.820
application framework of abstracted
media services to simplify the

00:01:50.840 --> 00:01:53.830
integration of QuickTime and Java.

00:01:55.520 --> 00:01:59.640
QuickTime for Java delivers on the
promise of Java in that it has an

00:01:59.640 --> 00:02:02.970
identical API across all supported
platforms and operating systems.

00:02:03.020 --> 00:02:06.620
You can write Java applications
which use QuickTime for Java on

00:02:06.620 --> 00:02:10.930
any of the supported applications
and deliver that jar to run on

00:02:10.930 --> 00:02:13.740
all the supported platforms.

00:02:17.400 --> 00:02:21.240
So in brief,
QuickTime Java architecture relies

00:02:21.240 --> 00:02:28.300
on core services from QuickTime,
from Java, and from the operating system.

00:02:32.220 --> 00:02:37.190
and the QuickTime for Java 5,
which is the version of QuickTime for

00:02:37.190 --> 00:02:40.900
Java shipping in Apple's
current version of QuickTime,

00:02:40.900 --> 00:02:45.470
that is QuickTime version 5,
supports a new,

00:02:45.480 --> 00:02:48.770
brand new operating system, Mac OS X.

00:02:49.220 --> 00:02:54.100
with Apple's implementation
of Java 2 Standard Edition.

00:02:54.200 --> 00:02:59.780
As well, QuickTime for Java 5 continues
to support classic Mac OS.

00:03:00.060 --> 00:03:04.380
with Macintosh Runtime
for Java 2.1 and above,

00:03:04.400 --> 00:03:08.020
and this is based on
Java Development Kit 118.

00:03:09.120 --> 00:03:14.780
QuickTime for Java 5 also continues
to support and has enhanced support

00:03:14.920 --> 00:03:19.930
for Microsoft operating systems,
the Windows 95, 98 ME family,

00:03:19.930 --> 00:03:25.620
and Windows NT and 2000
family operating systems,

00:03:25.620 --> 00:03:30.400
and require to have installed a
Sun-compliant Java runtime edition,

00:03:30.400 --> 00:03:36.810
1.1, and also will run with Java 2.

00:03:38.030 --> 00:03:40.940
QuickTime for Java 5 has
specific enhancements for

00:03:40.940 --> 00:03:43.750
this new Java 2 environment.

00:03:43.750 --> 00:03:46.680
There are improvements to
the Java 2 security model,

00:03:46.680 --> 00:03:52.780
and I believe there is a session tomorrow
if you're interested in Java security.

00:03:53.080 --> 00:03:59.390
Specific enhancements in QuickTime for
Java have been changes due to

00:03:59.450 --> 00:04:03.870
issues with garbage collection
with the hotspot client compiler.

00:04:09.750 --> 00:04:18.270
So QuickTime for Java 5 has new support
for the new features in QuickTime 5.

00:04:20.540 --> 00:04:25.260
Some of the new features in
QuickTime 5 is the XML package.

00:04:25.340 --> 00:04:28.870
QuickTime for Java has an XML parser
package which allows you access,

00:04:28.900 --> 00:04:31.180
and we'll talk about this later.

00:04:31.320 --> 00:04:38.160
and QuickTime 5 also has a new
broadcast API and QuickTime for

00:04:38.160 --> 00:04:43.830
Java 5 supports QuickTime's
broadcast API with the presentation

00:04:43.890 --> 00:04:48.380
package and Michael will give you a
demonstration of that this afternoon.

00:04:48.870 --> 00:04:55.640
As well, QuickTime for Java 5 has full
coverage of the QuickTime 4 API.

00:04:55.740 --> 00:04:59.670
All of the QuickTime functionality
up to and including QuickTime 5 are

00:04:59.670 --> 00:05:02.300
available through QuickTime for Java.

00:05:03.470 --> 00:05:07.040
As well, this release of QuickTime for
Java 5 has additional functionality

00:05:07.660 --> 00:05:10.310
and enhanced services.

00:05:11.770 --> 00:05:19.770
Now I'd like to go on to a key
piece of multimedia presentations,

00:05:19.770 --> 00:05:22.720
which is time-based
multimedia presentations.

00:05:22.760 --> 00:05:29.680
We can think of a movie time
base as having two particular

00:05:32.100 --> 00:05:36.720
has a rate, which is the rate at which
the time base is moving,

00:05:36.720 --> 00:05:40.860
and also a current time, which is the,
for a movie time base,

00:05:40.860 --> 00:05:45.980
it's the place in time
where the playhead is.

00:05:46.900 --> 00:05:52.490
QuickTime for Java implements
time-based callbacks so that you can

00:05:52.720 --> 00:05:55.630
receive notification in your QuickTime

00:05:56.050 --> 00:05:59.400
Your QuickTime for Java application,
that is an application written in

00:05:59.400 --> 00:06:02.390
Java and utilizing QuickTime for Java,

00:06:03.900 --> 00:06:07.940
You can receive notification
of time-based events.

00:06:07.940 --> 00:06:12.440
As you can see from the diagram,
when the playhead reaches a

00:06:12.440 --> 00:06:17.300
certain time in the movie,
you can execute your own Java code.

00:06:17.300 --> 00:06:20.690
Now, what are these time-based events?

00:06:21.250 --> 00:06:24.850
They can execute at a certain time,
that is,

00:06:24.870 --> 00:06:28.150
at a certain time within the movie,
at intervals.

00:06:28.150 --> 00:06:31.900
You may want to have a ticker
in the movie so that you

00:06:31.900 --> 00:06:33.890
get notified every second.

00:06:34.690 --> 00:06:38.510
and also you can have callbacks
which fire at extremes,

00:06:38.510 --> 00:06:44.390
so you can get notification
that your movie has finished.

00:06:44.670 --> 00:06:49.910
and you can also have callbacks
for notification of rate change.

00:06:49.910 --> 00:06:53.750
That is when the movie starts,
when the movie stops,

00:07:00.330 --> 00:07:06.780
Now, when a movie starts playing,
the rate change goes from zero.

00:07:06.790 --> 00:07:09.300
A rate change of zero means
the movie is not playing.

00:07:09.330 --> 00:07:13.540
To a rate change of one means
the movie is moving forward.

00:07:14.630 --> 00:07:17.340
at normal play rate.

00:07:17.400 --> 00:07:20.060
To play the movie backwards,
you would change the rate to minus one.

00:07:21.820 --> 00:07:24.640
Now the reason why I'm going on about
time bases is that because they've

00:07:24.710 --> 00:07:29.180
been reworked in QuickTime for Java 5,
they are now much more efficient.

00:07:29.560 --> 00:07:30.290
and Michael C.

00:07:30.290 --> 00:07:32.100
Coyne,
they are now implemented using high

00:07:32.100 --> 00:07:34.090
priority native threads for efficiency.

00:07:34.170 --> 00:07:38.240
They deliver your Java code executing
very close to the time that the

00:07:38.360 --> 00:07:40.000
callback was actually fired.

00:07:40.000 --> 00:07:44.240
Also, this rework means that it's

00:07:45.400 --> 00:07:48.390
and QuickTime callbacks now have
an implicit idling mechanism.

00:07:48.470 --> 00:07:52.370
You no longer have to have a
timer tasking thread polling

00:07:52.710 --> 00:07:55.190
for when these events occur.

00:07:57.040 --> 00:08:02.690
So now I'd like to move on to the demo
to actually show you QuickTime callbacks.

00:08:10.170 --> 00:08:15.230
Here we have on 10 a
Java application written which

00:08:15.230 --> 00:08:19.180
utilizes QuickTime for Java.

00:08:20.570 --> 00:08:22.920
Specifically,
this application has been written

00:08:22.960 --> 00:08:25.800
to have a number of callbacks.

00:08:25.800 --> 00:08:29.070
The first callback I'll
demonstrate is time jumping.

00:08:29.290 --> 00:08:33.000
As you can see in the console,
we can find out where the

00:08:33.000 --> 00:08:37.070
user scrubs the controller to.

00:08:38.170 --> 00:08:42.600
Now we will start the movie
and you will notice that we

00:08:42.600 --> 00:08:44.460
have a rate callback change.

00:08:44.460 --> 00:08:45.550
I'll just stop the movie.

00:08:45.550 --> 00:08:48.460
A rate callback change.

00:08:49.000 --> 00:09:04.700
[Transcript missing]

00:09:04.890 --> 00:09:06.580
Time-based implementation.

00:09:06.720 --> 00:09:08.110
You'll see the accuracy.

00:09:08.110 --> 00:09:12.420
We can't measure the latency from the
time that the callback is actually called

00:09:12.440 --> 00:09:14.800
to the time that your Java code executes.

00:09:14.800 --> 00:09:16.800
We can't measure it on 10.

00:09:20.300 --> 00:09:24.140
So we'll restart the movie.

00:09:24.140 --> 00:09:27.180
And as you can see,
we have time-based callback

00:09:27.180 --> 00:09:29.540
being called once a second.

00:09:31.700 --> 00:09:33.400
is out of interest.

00:09:33.400 --> 00:09:35.440
This has a time scale of about
20 million years per second.

00:09:35.440 --> 00:09:40.010
This is a fluid dynamics simulation
of the collision of two galaxies.

00:09:42.760 --> 00:09:46.260
And if we stop the movie,
right goes to zero.

00:09:46.350 --> 00:09:48.330
Start the movie again.

00:09:53.870 --> 00:09:57.830
Now, the movie has stopped and
two events have occurred.

00:09:57.910 --> 00:10:00.980
We have an extremes callback to
say that the movie has reached

00:10:01.050 --> 00:10:03.000
the end of the time base.

00:10:03.070 --> 00:10:08.780
We also have another rate callback,
a rate callback so the movie has stopped,

00:10:08.910 --> 00:10:10.300
the rate has gone to zero.

00:10:10.300 --> 00:10:22.340
I think we'll go back to slides now.

00:10:34.100 --> 00:10:43.400
[Transcript missing]

00:10:44.540 --> 00:10:47.620
Some advice for actually using
time-based callbacks is that time-based

00:10:47.730 --> 00:10:49.120
callbacks require explicit cleanup.

00:10:49.130 --> 00:10:53.500
That is,
on exit you must call cancel and cleanup.

00:10:53.500 --> 00:10:57.220
Cancel will cancel the callback
and cleanup will remove

00:10:57.220 --> 00:10:58.640
system resources in use.

00:10:58.640 --> 00:11:01.690
If you want to stop or just
reschedule the callback,

00:11:01.700 --> 00:11:02.560
use cancel.

00:11:02.560 --> 00:11:05.340
Use the cancel method
of time-based class.

00:11:07.910 --> 00:11:11.420
For more sophisticated timing services,
you should really look at

00:11:11.420 --> 00:11:14.190
the application framework,
where there are some very nice classes,

00:11:14.230 --> 00:11:19.630
such as the timer class and its
target client ticklish objects.

00:11:19.640 --> 00:11:23.580
And also,
if you want to make a presentation

00:11:23.740 --> 00:11:28.440
which has different elements,
which are time-slave, that is,

00:11:28.440 --> 00:11:33.460
the rate of one object will
control the rate of all the other

00:11:34.010 --> 00:11:36.880
and other media objects
within that presentation.

00:11:36.910 --> 00:11:41.890
The application framework has some
very nice services for time-slaving.

00:11:45.680 --> 00:11:51.380
Now I'd like to introduce a new feature,
an enhancement of the

00:11:51.390 --> 00:11:55.140
QuickTime VR instance
methods in QuickTime Java 5.

00:11:55.280 --> 00:11:58.140
Specifically,
we are supporting the interaction

00:11:58.140 --> 00:12:02.750
properties of QuickTime VR 5.

00:12:02.970 --> 00:12:09.060
These new interaction properties deal
with panorama mouse click properties.

00:12:09.090 --> 00:12:15.530
This is the time from when the time or
the number of pixels moved before the...

00:12:15.730 --> 00:12:19.970
and the mouse click gesture becomes
an ordinary panning gesture.

00:12:19.970 --> 00:12:23.080
That is, the mouse click will time out

00:12:23.410 --> 00:12:29.640
and the This is a multiplier
factor for the pan and tilt.

00:12:29.730 --> 00:12:33.600
You'll see this quite well in the demo,
that basically,

00:12:33.600 --> 00:12:37.890
if the user is panning across the screen,

00:12:38.100 --> 00:12:41.120
is using the mouse to pan
across a panorama and you

00:12:41.120 --> 00:12:47.180
change the pan tilt speed,
the panorama will speed up or slow down.

00:12:48.470 --> 00:12:53.580
Similarly for VR objects,
you have a mouse motion scale,

00:12:53.580 --> 00:12:58.980
which allows you to change the number
of pixels the user must move the mouse

00:12:59.010 --> 00:13:02.240
in order to either rotate the object.

00:13:02.240 --> 00:13:06.100
And also we have a getter
and setter for zoom speed.

00:13:06.100 --> 00:13:12.880
You can change the zoom speed,
which is the zoom in on the Z axis.

00:13:12.880 --> 00:13:16.180
For QuickTime VR objects,
they have two modes.

00:13:16.180 --> 00:13:19.430
They have a rotation or translation.

00:13:19.430 --> 00:13:23.240
That is,
normally you can rotate a VR object

00:13:23.520 --> 00:13:29.870
or you can put it into translation
mode so that if it's zoomed in,

00:13:29.870 --> 00:13:29.870
the

00:13:30.080 --> 00:13:33.040
The user interaction will be to
move that single image rather

00:13:33.040 --> 00:13:34.760
than rotating the object.

00:13:34.800 --> 00:13:38.380
And in QuickTime for Java,

00:13:38.500 --> 00:13:44.860
We give you access to the two properties,
translate on mouse down,

00:13:44.860 --> 00:13:48.660
which allows you to change the
translate or rotate property,

00:13:48.660 --> 00:13:52.440
the property to either
rotate or translate,

00:13:52.440 --> 00:13:54.450
or the nudge mode.

00:13:54.480 --> 00:13:56.440
Now,
this is similar to the mouse down mode,

00:13:56.440 --> 00:13:58.190
except it works with the arrow keys.

00:13:58.200 --> 00:14:02.180
And there we have three states, rotate,
translate, or the same as the

00:14:02.180 --> 00:14:03.820
translate on mouse down.

00:14:07.320 --> 00:14:14.490
Now I'd like to show you a demonstration
of a QuickTime VR with these properties.

00:14:18.960 --> 00:14:23.280
Now here we have a
QuickTime VR and first of all,

00:14:23.280 --> 00:14:28.650
the Java application has
printed out some information.

00:14:28.730 --> 00:14:31.890
First of all,
we've installed an intercept proc.

00:14:31.890 --> 00:14:35.240
We've been able to do this with
QuickTime for Java 4 and this is

00:14:35.240 --> 00:14:39.860
one of the powerful things about
QuickTime for Java is it's very easy

00:14:39.990 --> 00:14:44.690
to create great dynamic functionality
within a presentation of VR.

00:14:47.090 --> 00:14:51.790
We also have another callback,
which is the mouseover proc,

00:14:51.800 --> 00:14:54.940
and this is basically the one where
we'll be getting and setting and

00:14:54.940 --> 00:14:56.560
checking some of these new properties.

00:14:58.930 --> 00:15:01.920
Now the pan/tilt speed,
that is the factor that multiplies the

00:15:01.920 --> 00:15:06.300
user's interaction with the panorama,
is, when we come into the panorama,

00:15:06.300 --> 00:15:08.900
is set to 5, which is the default.

00:15:08.930 --> 00:15:12.970
And just for reference,
the field of view is almost 40 degrees.

00:15:14.670 --> 00:15:21.600
When we enter a hotspot, as you can see,
Michael has entered a hotspot before,

00:15:21.600 --> 00:15:24.040
that the speed would go up to 8.

00:15:24.110 --> 00:15:28.570
So that if we pan slowly
towards this hotspot,

00:15:28.590 --> 00:15:33.920
when it enters the hotspot,
we'll have a notification

00:15:33.920 --> 00:15:37.310
and we'll increase the speed.

00:15:38.460 --> 00:15:41.640
and when we leave the hotspot,
it will slow back down again.

00:15:41.690 --> 00:15:44.560
The field of view has not been changed.

00:15:44.560 --> 00:15:50.170
I'll go back in because
I also have another feature

00:15:51.920 --> 00:15:57.260
More functionality in this
demonstration that when we click,

00:15:57.260 --> 00:16:01.870
we zoom in,
and when we leave the hotspot,

00:16:01.880 --> 00:16:03.860
it reverts to normal.

00:16:13.270 --> 00:16:18.320
So here we have a hotspot,
this top hotspot number 74,

00:16:18.340 --> 00:16:22.630
where if we entered the
hotspot while panning,

00:16:22.640 --> 00:16:23.700
the speed would increase again.

00:16:23.700 --> 00:16:25.540
So we'll do that.

00:16:25.540 --> 00:16:30.280
As we enter the hotspot,
we go past it quite quickly.

00:16:32.100 --> 00:16:37.900
[Transcript missing]

00:16:38.610 --> 00:16:42.990
I'll just demonstrate that basically
I'm going to click in this hotspot

00:16:43.000 --> 00:16:46.320
and we have a timeout of 30 ticks,
half a second.

00:16:46.320 --> 00:16:48.040
We can change that property.

00:16:48.040 --> 00:16:52.480
I haven't done this in this
particular demonstration.

00:16:57.670 --> 00:17:01.420
So here we have another hotspot,
and this one will be a very slow hotspot,

00:17:01.420 --> 00:17:04.310
so we'll pan into it quite quickly.

00:17:05.600 --> 00:17:09.070
and the user experiences that
over that particular hotspot,

00:17:09.140 --> 00:17:10.110
that's an important hotspot.

00:17:10.110 --> 00:17:12.600
We've slowed down.

00:17:12.600 --> 00:17:18.190
Okay, can we return to slides please?

00:17:23.780 --> 00:17:28.300
Now this sort of functionality is very
easy to achieve with QuickTime for Java.

00:17:29.950 --> 00:17:32.650
I have some demonstration,
some of the source code.

00:17:32.650 --> 00:17:36.930
This is very simple source code.

00:17:36.930 --> 00:17:36.930
Basically,

00:17:37.240 --> 00:17:42.440
We create a QtVR instance using
the movie controller and getting

00:17:42.440 --> 00:17:44.240
the QtVR track from the movie.

00:17:44.240 --> 00:17:47.580
Then we set a mouse over proc.

00:17:47.580 --> 00:17:51.530
And the execute function

00:17:52.450 --> 00:17:58.090
which is an override of the
QtVR mouse over hotspot.

00:17:58.580 --> 00:18:02.730
Implementation has two actions.

00:18:02.820 --> 00:18:07.610
Basically it looks at the action selector
coming in and when we enter a hotspot,

00:18:07.610 --> 00:18:12.190
we set the pan/tilt speed to
some function of the hotspot ID.

00:18:12.230 --> 00:18:13.930
This is a very quick demo.

00:18:14.490 --> 00:18:20.700
Else, when we leave the hotspot,
we reset the pan/tilt speed to normal.

00:18:28.020 --> 00:18:32.440
Now I'd like to move on and let
Michael tell you about the improved

00:18:32.440 --> 00:18:34.810
support for the Sound Manager.

00:18:38.500 --> 00:18:40.600
Thank you, Jon.

00:18:40.620 --> 00:18:43.500
I love having the clicker.

00:18:43.590 --> 00:18:46.330
Okay, today we're going to talk about
some of the new sound manager

00:18:46.370 --> 00:18:48.500
support in QuickTime for Java 5.

00:18:48.500 --> 00:18:51.630
This has been greatly enhanced
from our previous release to

00:18:51.770 --> 00:18:56.500
include the additional support of
asynchronous recording and playback.

00:18:56.500 --> 00:19:00.450
We've also provided the functionality
of being able to access the

00:19:00.450 --> 00:19:04.680
equalizer for the sound channel,
so you can get the values of

00:19:04.680 --> 00:19:06.500
the treble and bass equalizers.

00:19:06.500 --> 00:19:08.870
And also you can play
with level metering,

00:19:08.870 --> 00:19:11.500
turn that on and off,
get the status of that.

00:19:11.500 --> 00:19:15.400
Now keep in mind that this is
the classic sound manager support

00:19:15.400 --> 00:19:17.440
that is built into QuickTime.

00:19:17.590 --> 00:19:22.500
It's not the same as the core audio API,
which is native in Mac OS X.

00:19:22.500 --> 00:19:25.500
There are some other sessions
later on in the show.

00:19:25.500 --> 00:19:28.500
In fact, there are some today and
a few tomorrow on that.

00:19:28.500 --> 00:19:30.450
And that API is accessible from Java.

00:19:30.510 --> 00:19:32.790
However, since it's X only,
we recommend that if you do need to

00:19:32.880 --> 00:19:36.090
do cross-platform sound development,
that you use our sound

00:19:36.300 --> 00:19:38.500
manager support in QuickTime.

00:19:38.500 --> 00:19:40.840
Since we've added a whole
lot of new functionality,

00:19:40.840 --> 00:19:42.470
which makes it really nice to use.

00:19:44.950 --> 00:19:48.500
So what have we done in
the new Sound Manager?

00:19:48.500 --> 00:19:52.000
We've added an extended
scheduled sound header class.

00:19:52.030 --> 00:19:54.900
This allows you to send
buffered sound commands.

00:19:54.900 --> 00:19:59.960
We've also added an SC status class,
and with that you can get the

00:19:59.960 --> 00:20:01.200
status of the sound channel.

00:20:01.200 --> 00:20:04.870
You can determine whether it's busy,
whether there's a sound playing,

00:20:04.870 --> 00:20:06.220
and other operations.

00:20:06.220 --> 00:20:11.960
We also have an SI completion class that
enables you to register a completion

00:20:11.990 --> 00:20:16.390
routine that will get called upon
completion of asynchronous recording,

00:20:16.400 --> 00:20:19.860
so that your application can be
notified when recording is complete,

00:20:19.860 --> 00:20:23.200
and then save that sound somewhere
or play it back to the user.

00:20:23.200 --> 00:20:26.160
And finally,
we've added some additional constants

00:20:26.200 --> 00:20:29.830
in the sound constants class to
expose some of those new constants

00:20:29.830 --> 00:20:32.160
that weren't previously available.

00:20:32.160 --> 00:20:35.600
And these include things
like new sound commands,

00:20:35.600 --> 00:20:36.200
as we're going to talk about.

00:20:36.220 --> 00:20:40.220
So how do you use the new Sound Manager?

00:20:40.220 --> 00:20:43.260
And what else have we done?

00:20:43.260 --> 00:20:48.490
We've enhanced the sound channel
class significantly to provide support

00:20:48.490 --> 00:20:51.310
for doCommand and also doImmediate.

00:20:51.400 --> 00:20:54.510
The doCommand, when you call that,
places a sound command,

00:20:54.610 --> 00:20:58.320
such as a callback command or a
buffer command or a playback command,

00:20:58.320 --> 00:21:02.320
into the command queue and
executes that command immediately.

00:21:02.320 --> 00:21:05.580
That's the doImmediate call.

00:21:06.100 --> 00:21:09.710
Whereas the doCommand will place that
command into the queue of commands

00:21:09.710 --> 00:21:11.830
to be executed by the sound channel.

00:21:11.870 --> 00:21:15.850
And when the sound channel has
executed all its prior queued commands,

00:21:15.860 --> 00:21:18.380
then it will go ahead and
execute that one as well.

00:21:18.430 --> 00:21:21.930
So the primary difference between
doImmediate is that it skips that.

00:21:22.050 --> 00:21:23.130
Do you want to go ahead and do that?

00:21:23.430 --> 00:21:26.780
and the Q versus do command,
which places the command

00:21:26.780 --> 00:21:28.440
at the end of the queue.

00:21:28.450 --> 00:21:30.960
We also have support for
a new callback command,

00:21:30.960 --> 00:21:35.840
which we'll talk about in detail later,
which enables you to get a callback

00:21:35.840 --> 00:21:39.100
when your command is executed.

00:21:39.100 --> 00:21:43.230
And we also have some new informational
accessors that I alluded to previously,

00:21:43.230 --> 00:21:49.580
the get level metering on and off,
and also a set level metering on and off.

00:21:49.580 --> 00:21:52.640
So let's look at how you
use these in your code.

00:21:53.700 --> 00:21:56.760
First thing that we're going to talk
about is recording a sampled sound.

00:21:56.760 --> 00:22:00.160
And these slides are not in full detail.

00:22:00.160 --> 00:22:03.060
We do have some excellent sound
examples as part of the SDK.

00:22:03.090 --> 00:22:06.700
So if you really want to take
a look at this in detail versus

00:22:06.810 --> 00:22:10.140
this high-level discussion,
please go see that.

00:22:10.140 --> 00:22:13.120
And we'll show you where to download
that at the end of our presentation.

00:22:13.980 --> 00:22:16.960
So the first thing you need
to do to record a sample sound

00:22:16.960 --> 00:22:18.670
is prepare the sound channel.

00:22:18.720 --> 00:22:21.890
And the way you do that is you
create a new sound input device

00:22:21.890 --> 00:22:25.460
by calling new SPV device and
passing in whatever permissions are

00:22:25.460 --> 00:22:27.830
appropriate for that type of device.

00:22:27.830 --> 00:22:30.510
For example,
most microphones you can't write to,

00:22:30.560 --> 00:22:32.560
so you'd want to just do read with that.

00:22:32.600 --> 00:22:36.430
Also, you need to allocate a new sound
channel and pass the number of channels,

00:22:36.520 --> 00:22:39.160
the rate, the sample size,
and the compression type of

00:22:39.160 --> 00:22:41.050
the sound that you'll be using.

00:22:41.060 --> 00:22:43.940
And you can also just retrieve
that from the sound input.

00:22:43.980 --> 00:22:47.610
device if you want,
so you can get the defaults for that.

00:22:47.680 --> 00:22:49.520
So it's actually pretty easy.

00:22:49.540 --> 00:22:52.880
Once you've created the sound channel,
you create a new sound

00:22:52.880 --> 00:22:56.310
input parameter block,
which you need to pass in that,

00:22:56.370 --> 00:23:00.060
you need to create the new SPB,
pass in the device that you'll be using,

00:23:00.060 --> 00:23:04.000
and then the buffer size,
which is the size that you're

00:23:04.000 --> 00:23:08.040
going to use for the data,
and also the sound handle.

00:23:08.040 --> 00:23:11.620
You need to pass in where that's going
to be stored in the sound handle.

00:23:12.300 --> 00:23:16.460
Then you can optionally specify a
completion proc that will get called

00:23:16.460 --> 00:23:20.380
upon completion of the recording,
and you call that by overwriting

00:23:20.580 --> 00:23:24.720
the SI completion class and then
overwriting the execute method.

00:23:26.760 --> 00:23:29.190
So once you've done all that and
you want to record the sound,

00:23:29.290 --> 00:23:34.810
simply call record from your SPB object,
and then the sound will start recording.

00:23:34.820 --> 00:23:36.620
So that's recording.

00:23:36.620 --> 00:23:38.060
Let's look at playback.

00:23:38.060 --> 00:23:42.770
To playback the sound asynchronously,
which is the more interesting case,

00:23:42.770 --> 00:23:45.800
you need to prepare a sound command.

00:23:45.800 --> 00:23:47.960
In this case,
we're demonstrating how to use

00:23:47.960 --> 00:23:50.640
it with the buffer command,
which will do asynchronous

00:23:50.640 --> 00:23:53.350
callback versus the play command,
which doesn't.

00:23:53.980 --> 00:23:57.130
So you create a new sound command object,
specifying the command

00:23:57.130 --> 00:23:58.350
that you wish to use.

00:23:58.360 --> 00:24:01.510
And then in the case of a buffer command,
you also need to set the

00:24:01.510 --> 00:24:04.660
buffer that you'll be playing
from and give that to command.

00:24:04.660 --> 00:24:07.430
So you do that by calling setBuffer,
and then finally call

00:24:07.430 --> 00:24:10.610
doCommand on the sound channel,
and that will place that buffer

00:24:10.670 --> 00:24:13.370
command at the end of the
queue in the sound channel.

00:24:13.380 --> 00:24:18.060
If you wish to schedule a callback,
you need to create a sound command,

00:24:18.060 --> 00:24:23.040
excuse me, a callback command,
and put that into the channel as well.

00:24:23.440 --> 00:24:27.040
But before you do so,
when you allocate the sound channel,

00:24:27.130 --> 00:24:30.900
you specify the sound callback
to be used at that time.

00:24:30.900 --> 00:24:33.840
So a good example of reasons why
you'd want to do this is if you need

00:24:33.840 --> 00:24:37.060
a sound in the background that's
going to loop over and over again.

00:24:37.060 --> 00:24:42.030
So you could create a sound callback
that would be placed on the end of the

00:24:42.030 --> 00:24:44.910
queue after a sound had been playing.

00:24:44.920 --> 00:24:47.280
When the play command
popped off the queue,

00:24:47.340 --> 00:24:50.620
your callback command would get fired,
and that could put a new

00:24:50.770 --> 00:24:52.480
sound play or sound buffer.

00:24:52.640 --> 00:24:56.280
So you could put another command
into the queue and also put another

00:24:56.280 --> 00:24:59.990
callback command onto the queue,
and so that would continually loop.

00:25:01.950 --> 00:25:05.400
So that's pretty much all
there is for playing a sound.

00:25:05.400 --> 00:25:07.980
When you're using sounds,
there are a couple of things that you

00:25:08.030 --> 00:25:09.960
need to be aware of and cognizant of.

00:25:10.030 --> 00:25:13.710
And the first is that you need to make
sure that you dispose of all your sound

00:25:13.710 --> 00:25:15.890
channels when you're done playing them.

00:25:15.900 --> 00:25:20.360
You can do that by calling
disposeQtObject on the sound channel.

00:25:20.360 --> 00:25:23.260
And if you like,
you can do that directly from a callback.

00:25:23.340 --> 00:25:27.010
It's very important to do that as
opposed to waiting for the garbage

00:25:27.010 --> 00:25:30.800
collector to clean you up because
that can be a lot of native data.

00:25:32.020 --> 00:25:35.980
Additionally, if you have any completion
routines that you've specified and

00:25:35.980 --> 00:25:39.620
registered with the SPB device,
go ahead and remove those as well

00:25:39.620 --> 00:25:41.270
by calling removeCompletionProc.

00:25:41.280 --> 00:25:43.720
And finally,
there are a couple of garbage collection

00:25:43.720 --> 00:25:45.300
issues you need to keep in mind.

00:25:45.300 --> 00:25:48.770
If you have sound objects on the stack,
they can go out of scope,

00:25:48.770 --> 00:25:51.280
so be aware of your
use of local variables.

00:25:51.280 --> 00:25:56.250
SoundManager isn't happy if buffers
for sound that's supposed to be

00:25:56.250 --> 00:25:59.420
playing get garbage collected on you.

00:25:59.420 --> 00:26:00.940
Also, make sure that you dispose
of all your sound channels

00:26:00.940 --> 00:26:01.880
when you're done playing them.

00:26:01.880 --> 00:26:05.300
You can't dispose of any objects
that you use within a callback before

00:26:05.300 --> 00:26:07.280
you dispose of the callback itself.

00:26:07.400 --> 00:26:12.010
And keeping in mind those guidelines
will make sure that your experience

00:26:12.010 --> 00:26:13.940
using audio is a sound one.

00:26:13.940 --> 00:26:16.160
Oh, I know that was bad.

00:26:16.460 --> 00:26:17.940
Couldn't help it.

00:26:18.040 --> 00:26:22.520
Okay, so now we're going to look at a
new area of QuickTime for Java 5,

00:26:22.520 --> 00:26:24.770
which is the presentation API.

00:26:25.990 --> 00:26:28.130
and a bit of an overview first.

00:26:28.260 --> 00:26:31.730
For those of you that haven't seen any
of the previous QuickTime sessions,

00:26:31.730 --> 00:26:33.260
there was a presentation section.

00:26:33.260 --> 00:26:40.030
And that showed the new API available
with QuickTime 5 that we implemented

00:26:40.030 --> 00:26:42.100
in QuickTime for Java as well.

00:26:42.100 --> 00:26:46.300
This enables you to broadcast
from any source that is

00:26:46.300 --> 00:26:50.740
sequence grabber compatible,
audio devices such as two turntables

00:26:50.740 --> 00:26:55.740
and a microphone or any DV audio source,
also video devices as well.

00:26:55.740 --> 00:27:00.040
And you can specify that that
broadcast is unicast or multicast,

00:27:00.040 --> 00:27:04.520
going to a single machine or to a
number of machines on the same network.

00:27:04.530 --> 00:27:09.110
And the broadcast is also user
configurable via settings dialog,

00:27:09.210 --> 00:27:11.030
which we'll see in the demo to follow.

00:27:11.040 --> 00:27:14.040
So let's look at how this
works from a client side.

00:27:14.040 --> 00:27:18.040
The broadcaster is a machine
that has a set of devices that

00:27:18.040 --> 00:27:18.040
are connected to the network.

00:27:18.040 --> 00:27:21.010
It has some sort of device
such as a camera connected.

00:27:21.110 --> 00:27:25.150
And it also specifies,
it has an SDP file,

00:27:25.150 --> 00:27:27.030
which stands for stinky dead pigeon.

00:27:27.040 --> 00:27:29.030
No, actually it doesn't.

00:27:29.040 --> 00:27:31.040
It's the stream data protocol.

00:27:31.190 --> 00:27:38.250
And that's a standard for
specifying how streaming will

00:27:38.720 --> 00:27:42.040
be sent across the network.

00:27:42.040 --> 00:27:45.140
And so we use that standard as
part of QuickTime since we are

00:27:45.210 --> 00:27:47.040
a standards based technology.

00:27:47.040 --> 00:27:48.040
So once you specify the data,
you can go to the next slide.

00:27:48.040 --> 00:27:48.950
So let's look at the broadcast machine.

00:27:49.080 --> 00:27:50.180
So the broadcast machine is a
machine that is used to configure the

00:27:50.220 --> 00:27:51.040
SDP file to configure your broadcast.

00:27:51.040 --> 00:27:54.820
Then those packets are going to go out
onto the network and onto any machines

00:27:54.820 --> 00:27:56.960
which are also viewing the same SDP file.

00:27:57.050 --> 00:28:00.320
And in this case,
the illustration shows that

00:28:00.320 --> 00:28:05.030
those machines are just using the
QT player to open the SDP file.

00:28:05.180 --> 00:28:07.030
And that doesn't have to be a player.

00:28:07.040 --> 00:28:10.040
It can be any application that
is capable of opening a movie.

00:28:10.040 --> 00:28:14.040
So let's look at the
broadcaster in more detail now.

00:28:14.180 --> 00:28:17.040
On that broadcast machine,
we have a video system.

00:28:17.040 --> 00:28:21.040
We have a video camera,
which is the source of the broadcast.

00:28:21.050 --> 00:28:25.040
That goes through the sequence
grabber into the sourcer object.

00:28:25.040 --> 00:28:28.900
We also have a presentation that
encapsulates all these various

00:28:28.980 --> 00:28:31.010
units within the broadcaster.

00:28:31.120 --> 00:28:34.420
And the presentation you can think
of is kind of like the top level

00:28:34.420 --> 00:28:38.040
component or a movie that contains
all these other objects within it.

00:28:38.240 --> 00:28:42.030
That's configured by the SDP file,
which specifies whether there's audio,

00:28:42.050 --> 00:28:46.040
whether there's video,
whether it's unicast or multicast.

00:28:46.040 --> 00:28:51.290
What the sample rate is,
what the compression type of

00:28:51.390 --> 00:28:54.040
that broadcast is going to be.

00:28:54.280 --> 00:28:58.120
Once that is specified,
that's going to affect the packetizer,

00:28:58.130 --> 00:29:02.190
which is responsible for taking the
data from the sourcer object and

00:29:02.280 --> 00:29:05.400
splitting it up into little packets
that it can then send out on the

00:29:05.400 --> 00:29:07.040
network in an efficient manner.

00:29:07.150 --> 00:29:10.670
So that packetizer is going
to be affected greatly by the

00:29:10.670 --> 00:29:15.010
compression type that's being
used by the sourcer component.

00:29:15.100 --> 00:29:16.750
For example,
there are packetizers that are

00:29:16.750 --> 00:29:19.710
specific to Sorenson that know a lot
more about its format and can more

00:29:19.710 --> 00:29:22.040
efficiently send out those packets.

00:29:22.210 --> 00:29:27.070
And finally, we have the streamer,
which is required for actually

00:29:27.080 --> 00:29:30.030
sending the packets out on the wire.

00:29:30.040 --> 00:29:32.770
So that's how the presentation works.

00:29:32.980 --> 00:29:36.830
and how do we map this
into QuickTime for Java?

00:29:36.880 --> 00:29:39.460
We have a presentation
API that's been placed in the

00:29:39.570 --> 00:29:43.070
QuickTime.streaming package,
and we represent that

00:29:43.130 --> 00:29:48.000
presentation or streaming
session by a presentation object.

00:29:48.120 --> 00:29:51.820
The streaming session is configurable
again via settings dialog,

00:29:51.820 --> 00:29:53.380
which we'll show you
in our demo coming up.

00:29:53.440 --> 00:29:56.980
And we have a streamlined
API available now,

00:29:56.980 --> 00:30:01.280
and we'll be releasing additional
features of the API in the future

00:30:01.280 --> 00:30:04.520
to allow you to do things other than
just using the sequence grabber.

00:30:06.700 --> 00:30:13.930
Oops, skipped a slide,
so let's go over to the demo.

00:30:15.080 --> 00:30:17.160
And we have a video camera here.

00:30:17.160 --> 00:30:20.880
It's going to be digitizing all
you happy people in the audience.

00:30:21.760 --> 00:30:25.940
So what I'm going to do first is I'm
running a QuickTime for Java applet,

00:30:25.940 --> 00:30:30.440
and I'm selecting an SDP file,
which as I mentioned previously,

00:30:30.440 --> 00:30:33.150
is simply just a text file.

00:30:34.510 --> 00:30:40.030
And at that point then,
the settings dialog is going to come up.

00:30:40.040 --> 00:30:42.900
Let me move that onto the
monitor so you can see it.

00:30:43.060 --> 00:30:47.160
And on the top side you see
the settings for the audio,

00:30:47.340 --> 00:30:50.510
including the component
that that's coming from,

00:30:50.510 --> 00:30:53.740
which is actually in this case
coming from the sequence grabber.

00:30:53.740 --> 00:30:57.190
I'm going to go ahead and edit
the sound settings here to,

00:30:57.190 --> 00:31:01.980
since I don't really care about audio,
I'm going to cut that down a little bit.

00:31:02.310 --> 00:31:05.610
So that's the component responsible
for compression and then on the

00:31:05.620 --> 00:31:09.220
right side you see the packetizer
that's going to use to send that out.

00:31:09.220 --> 00:31:11.920
And I'm just going to use
the QuickTime packetizer.

00:31:11.920 --> 00:31:15.640
You'll note that it also is recognized
that I'm sending an 8-bit sound so

00:31:15.640 --> 00:31:17.920
there's a special packetizer for that.

00:31:18.380 --> 00:31:20.330
However,
since my .sdp file specified that

00:31:20.430 --> 00:31:23.480
the packetizer would be QuickTime,
I need to make sure that

00:31:23.480 --> 00:31:24.990
I use the same packetizer.

00:31:24.990 --> 00:31:29.320
Otherwise the client will be looking for
a different packetizer than what's being

00:31:29.320 --> 00:31:31.470
broadcast and it won't pick that up.

00:31:32.430 --> 00:31:35.990
And you can see that I'm
using a DV video source.

00:31:36.430 --> 00:31:41.790
And I'm going to go ahead and turn
down the quality a little bit.

00:31:41.800 --> 00:31:42.460
That's fine.

00:31:42.460 --> 00:31:47.920
And let's increase the keyframe frequency
slightly so we'll actually see some data.

00:31:47.920 --> 00:31:50.130
And then I'm going to
go ahead and hit OK.

00:31:50.170 --> 00:31:53.290
And we'll look at the broadcast.

00:31:55.870 --> 00:32:02.580
So once I click the Start button,
you can see now

00:32:03.360 --> 00:32:06.300
This is what we're
digitizing from the camera.

00:32:06.330 --> 00:32:09.000
And on the other machine,
we're going to go ahead now

00:32:09.000 --> 00:32:12.130
and open the same SDP file up.

00:32:12.270 --> 00:32:15.130
and the QuickTime player,
so you can see what's actually

00:32:15.140 --> 00:32:17.400
being broadcast across the network.

00:32:17.450 --> 00:32:22.880
And this is a multicast presentation,
and as such,

00:32:23.260 --> 00:32:27.990
If more than one machine could go
ahead and receive that broadcast.

00:32:27.990 --> 00:32:32.280
And as you can see,
we have a little lens flare going on.

00:32:33.390 --> 00:32:39.310
Somebody in the back waving fiendishly,
feverishly, maybe fiendishly as well.

00:32:41.090 --> 00:32:41.640
So there we go.

00:32:41.640 --> 00:32:45.380
We're doing a live broadcast from a
DV camera plugged in through a FireWire

00:32:45.500 --> 00:32:53.090
port from a QuickTime for Java app,
all on 10 and being received on a--

00:32:53.430 --> 00:32:54.900
Are you receiving that too, Jon?

00:32:54.900 --> 00:32:57.100
Oh, no, he's just waving.

00:32:57.100 --> 00:32:57.540
Okay.

00:32:57.540 --> 00:33:02.380
Anyway, people get so crazy when there
are video cameras on them.

00:33:02.380 --> 00:33:04.410
Alright,
so I'm going to go ahead and stop

00:33:04.520 --> 00:33:05.800
that now and go back to slides.

00:33:12.360 --> 00:33:16.100
A live presentation on a Java machine.

00:33:16.100 --> 00:33:17.340
Can't do that without QuickTime.

00:33:17.340 --> 00:33:19.080
And that's the beauty
of QuickTime for Java.

00:33:19.080 --> 00:33:23.310
It gives you a very elegant,
simplified interface that lets you to do

00:33:23.320 --> 00:33:28.170
some very powerful features that would
take tons and tons and tons of code.

00:33:28.180 --> 00:33:29.730
We're looking at the code now.

00:33:29.740 --> 00:33:33.280
Natively, this would take thousands
of lines of code,

00:33:33.280 --> 00:33:37.520
but in QuickTime for Java,
and in the example sent out on the SDK,

00:33:37.520 --> 00:33:40.480
you'll see that there's really
only a couple of lines of code,

00:33:40.480 --> 00:33:43.080
since we've taken care of a
lot of the details for you.

00:33:43.080 --> 00:33:47.220
You can specify advanced modes,
but you're not required to.

00:33:49.730 --> 00:33:52.500
So let's look at the presentation API.

00:33:52.520 --> 00:33:56.220
To create a presentation,
you can call presentation from

00:33:56.220 --> 00:33:58.700
file and specify an SDP file.

00:33:58.870 --> 00:34:01.700
You can also specify an
XML file if you like.

00:34:01.800 --> 00:34:07.550
And then your presentation parameters,
which is an object that lets

00:34:07.550 --> 00:34:11.280
you specify the sound rate,
etc., and data rate.

00:34:12.170 --> 00:34:14.580
Then if you like,
you need to show your settings dialog

00:34:14.640 --> 00:34:17.960
by calling new settings dialog and
pass in your presentation object.

00:34:18.030 --> 00:34:21.040
As the note says,
and as I previously mentioned,

00:34:21.040 --> 00:34:24.050
I have to reiterate that
the user is responsible,

00:34:24.050 --> 00:34:27.050
the broadcaster,
for choosing a setting that makes

00:34:27.190 --> 00:34:31.820
sense based on what the SDP file is
specifying for the type of broadcast.

00:34:31.820 --> 00:34:36.140
Since the client that's using that
SDP file is only going to look for

00:34:36.140 --> 00:34:38.600
a specific format of packetizer.

00:34:38.600 --> 00:34:42.320
And if you choose a different one, well,
the client's necessarily... That's

00:34:42.320 --> 00:34:44.540
not the broadcast I'm looking for,
so it won't find it.

00:34:44.550 --> 00:34:48.190
So make sure you do that correctly.

00:34:49.130 --> 00:34:54.360
To prepare and start a presentation,
you simply pre-roll your presentation

00:34:54.380 --> 00:34:55.890
and then call start on it.

00:34:56.030 --> 00:34:59.960
There's also a callback that you can
receive that QuickTime for Java does

00:35:00.080 --> 00:35:03.800
support that will allow you to determine
if the pre-roll has actually occurred.

00:35:03.800 --> 00:35:06.460
That can be important if you have
a slow device that you're grabbing

00:35:06.460 --> 00:35:07.870
from that just isn't ready yet.

00:35:07.940 --> 00:35:09.890
Once it's ready, you call start.

00:35:10.110 --> 00:35:11.840
And to stop, you call stop.

00:35:11.840 --> 00:35:13.560
It's as easy as it can get.

00:35:15.700 --> 00:35:17.270
So, oh, but there is a little bit more.

00:35:17.390 --> 00:35:19.000
Sorry, forgot.

00:35:19.000 --> 00:35:20.620
You do have to actually set up an idler.

00:35:20.620 --> 00:35:25.160
You can create a new task thread
that's going to be responsible

00:35:25.320 --> 00:35:27.340
for calling presentation idle.

00:35:27.340 --> 00:35:30.660
And that's the mechanism that will go
ahead and keep the sequence grabber

00:35:30.660 --> 00:35:34.380
running and go ahead and actually do
all the compression and packetization.

00:35:34.380 --> 00:35:37.270
And we recommend that you
do that in a task thread.

00:35:37.300 --> 00:35:40.320
And you can specify in the
task thread both a string name,

00:35:40.320 --> 00:35:43.410
which will allow you to easily
recognize it in a debugger,

00:35:43.490 --> 00:35:48.590
and also a rate of which that
thread is going to get serviced.

00:35:48.590 --> 00:35:51.590
In this case,
we chose 20 milliseconds because

00:35:51.590 --> 00:35:52.720
that seems to be a good value.

00:35:52.800 --> 00:35:54.700
And then when you
override your task method,

00:35:54.700 --> 00:35:55.530
you just call idle.

00:35:55.750 --> 00:35:59.680
And that's really all you need to
do to do a live broadcast from any

00:35:59.810 --> 00:36:02.460
source supported by the sequence
grabber in QuickTime for Java.

00:36:02.460 --> 00:36:06.100
Again, we encourage you to look at the
SDK code later if you're interested.

00:36:08.140 --> 00:36:11.530
And now I'm going to turn the
presentation over to Jon Summers again,

00:36:11.530 --> 00:36:13.780
who's going to talk about
transition enhancements.

00:36:14.060 --> 00:36:14.680
Thank you, Michael.

00:36:14.680 --> 00:36:16.510
MICHAEL HANSEN: Thank you, Jon.

00:36:20.740 --> 00:36:26.240
QuickTime for Java 5 now
supports enhanced transitions.

00:36:26.240 --> 00:36:30.090
To go back,
transitions are QuickTime effects.

00:36:30.120 --> 00:36:33.140
QuickTime effects architecture
has a large number of effects that

00:36:33.140 --> 00:36:36.880
you can apply to still images,
that is a single source,

00:36:36.960 --> 00:36:40.930
and this is represented
as a QuickTime filter,

00:36:40.940 --> 00:36:44.180
a Qt filter in Qt for Java,
or it can be applied

00:36:44.180 --> 00:36:48.660
between multiple sources,
a QuickTime transition.

00:36:49.710 --> 00:36:52.850
The main enhancement has been
to the parameter dialogue.

00:36:52.930 --> 00:36:56.700
In Qt Java 4, we supported editing

00:36:57.350 --> 00:37:07.930
and the creation of a
QuickTime parameter,

00:37:07.930 --> 00:37:09.710
QuickTime out of container,
which contains the data

00:37:09.710 --> 00:37:09.710
for a QuickTime effect.

00:37:10.100 --> 00:37:14.600
And in QuickTime for Java 5,
we've extended the parameter dialog so

00:37:14.600 --> 00:37:17.300
that now you can re-edit the parameters.

00:37:17.350 --> 00:37:21.060
This is an important consideration
for some of our developers.

00:37:21.060 --> 00:37:23.830
And as well,
we have allowed you to customize

00:37:23.830 --> 00:37:27.340
the dialog by putting in
optional preview pictures.

00:37:27.410 --> 00:37:31.760
Another new feature of QuickTime for
Java 5 is an enhancement

00:37:31.850 --> 00:37:36.520
to the AtomContainer class,
specifically the insertChildCall.

00:37:36.520 --> 00:37:38.800
We've extended the number of
data types to cover all the

00:37:38.810 --> 00:37:41.920
data types found in QuickTime.

00:37:42.470 --> 00:37:45.200
So we have all the simple
data types of byte,

00:37:45.280 --> 00:37:50.520
short, int, and float, and as well,
object data types,

00:37:50.520 --> 00:37:55.160
which will cover all of the other data
types that you'll need to actually

00:37:55.200 --> 00:37:58.010
create QuickTime atom containers.

00:37:58.520 --> 00:38:03.640
For tween-type atoms,
where the data is actually

00:38:03.980 --> 00:38:06.900
an array of two elements,
that is a start and end sample,

00:38:06.900 --> 00:38:12.120
we have a new class, tweenData,
which extends QT byte objects so it can

00:38:12.120 --> 00:38:13.960
be used directly with the insert child.

00:38:15.260 --> 00:38:21.620
Call for Adam Container.

00:38:21.620 --> 00:38:23.510
And how we've constructed,
how we've implemented this is

00:38:23.510 --> 00:38:23.510
to overload the constructor.

00:38:23.510 --> 00:38:23.510
So we take

00:38:24.510 --> 00:38:29.940
We take a start and end value
and the types are short int,

00:38:29.980 --> 00:38:34.670
fixed, float, double, point, fixed point,
etc., which are all the types

00:38:34.670 --> 00:38:38.760
that you will need to create
QuickTime tween type atoms.

00:38:41.120 --> 00:38:45.880
One of the things that we've done for
QuickTime for Java and QuickTime for

00:38:45.880 --> 00:38:49.870
Java 5 is to change the implementation,
the semantics of some of

00:38:49.870 --> 00:38:51.500
the atom container calls.

00:38:51.580 --> 00:38:55.590
You'll notice in the insert
child we have a parent atom.

00:38:56.270 --> 00:38:58.720
In some of the QuickTime atom
container methods,

00:38:58.750 --> 00:39:01.360
we have actually changed the semantics
so it can actually pass in null,

00:39:01.430 --> 00:39:07.460
so that actually this will be recognized
as being a synonym for atom zero.

00:39:07.460 --> 00:39:10.530
That is,
the container is the parent atom.

00:39:10.530 --> 00:39:12.320
The parent atom is the container.

00:39:16.100 --> 00:39:21.200
and new QuickTime 5 features in
QuickTime for Java 5 are support

00:39:21.330 --> 00:39:23.870
for the XML parser in QuickTime 5.

00:39:23.870 --> 00:39:28.280
We've implemented this with data classes,

00:39:28.900 --> 00:39:44.000
[Transcript missing]

00:39:45.090 --> 00:39:50.060
You can get to these elements
by creating callbacks,

00:39:50.070 --> 00:39:52.350
which will be called
during the parsing of XML,

00:39:52.350 --> 00:39:54.480
so you can find out when
the document parsing starts,

00:39:54.480 --> 00:39:57.090
when you reach a particular element.

00:39:58.780 --> 00:40:05.140
which will allow you to use
the QuickTimes XML parser

00:40:05.210 --> 00:40:09.890
for pretty good XML parsing.

00:40:11.770 --> 00:40:18.540
Now I'd like to hand the stage back to
Michael Hopkins for more new features.

00:40:19.100 --> 00:40:20.300
You guys thought we were done.

00:40:20.300 --> 00:40:22.720
No, we still have plenty of time.

00:40:22.720 --> 00:40:25.100
Okay,
additional new features in QuickTime 5.

00:40:25.100 --> 00:40:29.050
There's a brand new one that's
pretty significant called Drawing

00:40:29.050 --> 00:40:31.060
Notification Registration.

00:40:32.890 --> 00:40:36.460
And what that allows you to do
is register for notification when

00:40:36.460 --> 00:40:40.980
drawing and update operations occur
on objects such as a compositor,

00:40:40.980 --> 00:40:43.740
an effects presenter,
or a movie presenter.

00:40:43.740 --> 00:40:47.100
And this actually allows you to
do some pretty interesting things.

00:40:47.130 --> 00:40:50.540
For example, if you aren't really
big on using time bases,

00:40:50.540 --> 00:40:55.110
although that's also an excellent API,
you could synchronize a frame

00:40:55.110 --> 00:41:00.180
rate to the drawing by registering
as a listener for a component.

00:41:01.420 --> 00:41:04.890
Also, if you need to do some drawing
yourself onto an off screen

00:41:04.890 --> 00:41:08.540
before you present that,
you could go ahead and get notification

00:41:08.540 --> 00:41:12.250
when drawing was completed and then
do your additional drawing before

00:41:12.250 --> 00:41:14.000
that gets rendered to the screen.

00:41:14.000 --> 00:41:18.240
So the way this works is the listener
implements the drawing listener

00:41:18.240 --> 00:41:22.700
interface and they override the drawing
complete method and they can put

00:41:22.710 --> 00:41:25.120
in any code in there that they wish.

00:41:25.120 --> 00:41:28.750
You'll also notice that they
receive the QT drawable object

00:41:28.760 --> 00:41:30.760
that generated the message.

00:41:31.260 --> 00:41:33.770
Within that call,
so you have access to determine its

00:41:33.770 --> 00:41:36.600
time or what media it's presenting,
for example.

00:41:36.600 --> 00:41:41.830
Once you've overrided that interface,
you register your listener with a

00:41:41.870 --> 00:41:47.450
component by creating a new listener and
then adding that drawer listener to the

00:41:47.490 --> 00:41:50.030
object that you wish to register with.

00:41:50.200 --> 00:41:53.880
And not shown on the slide,
but additionally important,

00:41:53.880 --> 00:41:56.710
once you're done,
you can remove yourself by

00:41:56.710 --> 00:41:59.190
calling remove drawing listener.

00:41:59.560 --> 00:42:02.640
So it's a powerful new
feature that we've added,

00:42:02.640 --> 00:42:04.250
but we're not done yet.

00:42:04.250 --> 00:42:07.140
We've added a new sizing
option in Qt Canvas,

00:42:07.140 --> 00:42:10.870
a very strange named one called
K initial size no resize.

00:42:10.950 --> 00:42:14.500
And for those of you who are
astute Qt Java programmers,

00:42:14.500 --> 00:42:17.720
you may think, well,
there's already a K initial

00:42:17.720 --> 00:42:19.180
size sizing option.

00:42:19.180 --> 00:42:21.970
Well,
that one allowed an object contained

00:42:22.060 --> 00:42:26.780
within a canvas within a window to
grow smaller but not increase in size.

00:42:26.780 --> 00:42:31.900
Whereas this new sizing option,
absolutely specifies that that canvas

00:42:31.900 --> 00:42:35.920
will not grow or shrink regardless
of what happens to its parent window.

00:42:35.920 --> 00:42:39.040
Additionally,
we have a new interface called

00:42:39.040 --> 00:42:40.960
standard Qt constants 5.

00:42:40.960 --> 00:42:44.390
And oddly enough,
this represents newly defined

00:42:44.390 --> 00:42:46.500
constants in the Qt 5 API.

00:42:46.500 --> 00:42:52.340
And this supplements previous constants
such as the standard Qt constants 4,

00:42:52.400 --> 00:42:56.310
which represents Qt 4 API,
and standard Qt constants,

00:42:56.320 --> 00:42:58.500
which is Qt 3 and previous.

00:42:59.560 --> 00:43:02.740
So anything that's in 5 is
specifically going to be in that

00:43:02.740 --> 00:43:05.540
new standard constants 5 interface.

00:43:06.810 --> 00:43:09.560
So hopefully at this
point nobody's confused.

00:43:09.560 --> 00:43:12.720
We've added a lot of new
functionality in our product.

00:43:12.720 --> 00:43:17.190
We have a brand new operating system
that we're supporting in a very,

00:43:17.190 --> 00:43:20.020
very high fashion, and that's Mac OS X.

00:43:20.020 --> 00:43:26.490
We've added new support for compositing,
new support for broadcasting,

00:43:26.490 --> 00:43:28.940
new support for time base.

00:43:29.070 --> 00:43:35.350
We've worked through a lot of new
features that are part of the 5 API.

00:43:35.360 --> 00:43:37.630
And as such,
you as a developer may have a

00:43:37.630 --> 00:43:41.660
lot of questions about this,
but there are good places to get answers.

00:43:41.660 --> 00:43:44.170
The first of which is the
public mailing list that's

00:43:44.300 --> 00:43:46.200
available for Qt Java developers.

00:43:46.200 --> 00:43:50.630
You can go to list.apple.com and
sign up for the Qt Java list.

00:43:50.700 --> 00:43:54.970
And that's an excellent place for you to
go out and get information or ask some

00:43:54.970 --> 00:43:57.380
questions if you're having difficulty.

00:43:57.380 --> 00:44:01.060
We highly encourage that because
that's a very good community for

00:44:01.060 --> 00:44:03.200
QuickTime for Java developers.

00:44:04.090 --> 00:44:08.070
Also,
I mentioned previously the Qt Java SDK.

00:44:08.160 --> 00:44:12.210
We have five new examples in that SDK,
and that includes all of the

00:44:12.210 --> 00:44:14.470
things that we've covered today.

00:44:14.580 --> 00:44:18.100
So you can get examples
for that in that SDK.

00:44:18.450 --> 00:44:22.680
So that's at
developer.apple.com/quicktime/qtjava.

00:44:22.720 --> 00:44:25.160
Finally, if you want to be part
of our SEED program,

00:44:25.230 --> 00:44:27.720
I assume everybody's a
registered developer here,

00:44:27.730 --> 00:44:31.370
so if you want to get in on that and get
access to prereleases of our software,

00:44:31.520 --> 00:44:32.680
please send a mail to qtjava@apple.com.

00:44:32.740 --> 00:44:35.840
And we'll get you on that.

00:44:35.840 --> 00:44:40.140
And we really appreciate your feedback
and find out what things are important

00:44:40.170 --> 00:44:42.020
to you and see how we're doing.

00:44:42.130 --> 00:44:46.720
So additionally, I would be shot dead if
I didn't plug Bill's book.

00:44:46.730 --> 00:44:52.980
There's an excellent book called
QuickTime for Java Programming.

00:44:53.050 --> 00:44:55.360
Well,
I'm sure all of you are aware of that.

00:44:55.440 --> 00:44:59.220
It's an excellent book that has a
great overview of some of the concepts

00:44:59.250 --> 00:45:03.180
that QuickTime for Java were built on,
as well as a reference in the back.

00:45:03.230 --> 00:45:05.680
So again, we recommend that.

00:45:05.750 --> 00:45:10.580
So at this... Bill, the publisher?

00:45:10.580 --> 00:45:12.450
The publisher?

00:45:12.990 --> 00:45:15.120
Morgan and Kaufman.

00:45:15.120 --> 00:45:18.650
And you can find that on Amazon.com even,
I believe.

00:45:18.750 --> 00:45:22.210
Okay,
so I know it's Thursday and a lot of

00:45:22.210 --> 00:45:25.700
you feel like WWDC is almost over,
but there's still a number of

00:45:25.700 --> 00:45:27.920
excellent sessions coming up.

00:45:27.920 --> 00:45:31.280
We have the QuickTime feedback forum
immediately after this over in J1.

00:45:31.280 --> 00:45:35.210
It's a good place to come bring your
constructive criticism about things

00:45:35.210 --> 00:45:36.880
in QuickTime you'd like to see.

00:45:36.970 --> 00:45:38.810
Additionally,
immediately after the session,

00:45:38.820 --> 00:45:41.510
Jon Berkey is going to give
a killer Java graphics demo.

00:45:41.600 --> 00:45:45.420
That's really important because
as QuickTime for Java developers,

00:45:45.600 --> 00:45:49.740
you will be interacting with things
like Swing and the Java 2D API.

00:45:49.740 --> 00:45:52.490
So those are some good things to do
if you want to learn about some of

00:45:52.490 --> 00:45:55.170
those other ways of rendering in Java.

00:45:55.270 --> 00:45:59.980
Additionally,
we have some excellent audio services

00:45:59.980 --> 00:46:05.890
class in J2 here at 5 where you can learn
about the audio services on Mac OS X.

00:46:06.000 --> 00:46:09.200
And there is, as I mentioned, a Java API.

00:46:09.200 --> 00:46:12.040
So you can call that with Java.

00:46:12.040 --> 00:46:15.110
And that's a great way if you're
a 10 only developer to make use of

00:46:15.190 --> 00:46:16.820
some really advanced functionality.

00:46:16.820 --> 00:46:19.750
Additionally, for those of you that
are deploying applets,

00:46:19.750 --> 00:46:22.480
please see Java Security tomorrow at 9.

00:46:22.480 --> 00:46:25.340
And then of course the Java feedback
forum tomorrow at 10:30.
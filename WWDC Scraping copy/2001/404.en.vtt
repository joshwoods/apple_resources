WEBVTT

00:00:01.000 --> 00:02:54.700
[Transcript missing]

00:02:58.680 --> 00:03:00.710
Thanks Sergio.

00:03:00.800 --> 00:03:03.970
Today I'm going to talk about
how to use the OpenGL pipeline

00:03:03.970 --> 00:03:08.400
to get real impressive 2D
performance out of the platform.

00:03:08.520 --> 00:03:12.090
This includes both 2D or
traditional viewing pictures,

00:03:12.100 --> 00:03:15.580
those kind of things, and 2.5D,
maybe some work with sprites,

00:03:15.580 --> 00:03:17.600
work with movies and
those kind of things.

00:03:17.600 --> 00:03:21.050
We'll see how you can really use
the OpenGL pipeline to display

00:03:21.050 --> 00:03:23.110
those 2D kind of raster images.

00:03:23.780 --> 00:03:26.540
So first we'll talk about why
are we talking about OpenGL,

00:03:26.540 --> 00:03:29.880
a 3D API for 2D work.

00:03:30.150 --> 00:03:33.700
Then we'll move on to
implementing 2D with OpenGL.

00:03:33.700 --> 00:03:35.700
Things I'll talk about first
is how to display images.

00:03:35.700 --> 00:03:40.460
We'll talk about how to load images into
textures and use textures to image from.

00:03:40.790 --> 00:03:43.090
You can use this,
extrapolate this to using anything

00:03:43.090 --> 00:03:44.700
you generate from your program.

00:03:44.700 --> 00:03:48.710
We've seen demos before in the past
with using PDFs as a source of a texture

00:03:49.190 --> 00:03:51.180
and texturing that onto an object.

00:03:51.180 --> 00:03:53.700
You can do the same techniques there.

00:03:54.710 --> 00:03:57.500
We'll move on to talk about
sprites and side scrolling.

00:03:57.540 --> 00:03:59.000
I use side scrolling kind of loosely.

00:03:59.000 --> 00:04:01.600
With OpenGL, obviously,
there's no limitation on whether

00:04:01.600 --> 00:04:05.210
you're going to use it for vertical
and horizontal scrolling or you're

00:04:05.330 --> 00:04:09.690
going to create the next great game,
the next recreation of Defender.

00:04:09.750 --> 00:04:11.990
And then we'll talk a little
about QuickTime integration

00:04:11.990 --> 00:04:14.700
and beyond using just the
QuickTime API for loading textures,

00:04:14.700 --> 00:04:18.750
how we can use the QuickTime API and
Movie to integrate with

00:04:18.770 --> 00:04:20.680
OpenGL to display them.

00:04:21.400 --> 00:05:54.000
[Transcript missing]

00:05:54.930 --> 00:05:58.100
But I would be remiss if I didn't
talk about why not OpenGL.

00:05:58.110 --> 00:06:01.260
What things about
OpenGL may turn you away?

00:06:01.300 --> 00:06:04.910
Where may you not go down
the right pipeline here,

00:06:05.040 --> 00:06:08.560
so to speak, by thinking about using
OpenGL for your application?

00:06:08.720 --> 00:06:11.990
First, it works very well in
16 and 32 bit modes.

00:06:12.180 --> 00:06:14.790
But it does have some problems
if you're trying to get high

00:06:14.790 --> 00:06:16.350
performance in an 8 bit mode.

00:06:16.640 --> 00:06:19.610
The 8 bit mode is going to be,
you're going to fall into the software

00:06:19.970 --> 00:06:24.060
case and in a lot of special cases,
we have special, you're doing a palette

00:06:24.060 --> 00:06:24.560
animation for example.

00:06:24.560 --> 00:06:27.900
If you're doing palette animation,
OpenGL doesn't have a real equivalent

00:06:27.900 --> 00:06:31.330
of doing 8 bit palette animation,
so I suspect that your application

00:06:31.330 --> 00:06:34.540
could be specially coded to handle
that in a case better than OpenGL.

00:06:34.560 --> 00:06:38.640
So that would be a case that you may
want to not think about using OpenGL and

00:06:38.640 --> 00:06:40.550
use a special case of your own.

00:06:40.560 --> 00:06:43.470
Also, let's say you're doing fonts.

00:06:43.680 --> 00:06:45.500
You want to have very scalable fonts.

00:06:45.660 --> 00:06:46.560
You want to do a specific font.

00:06:46.560 --> 00:06:50.560
You want to do a specific kerning
with fonts or handle Unicode fonts.

00:06:50.560 --> 00:06:53.560
OpenGL doesn't have any built
in properties to do this.

00:06:53.560 --> 00:06:55.510
You could combine Quartz
and OpenGL to do this,

00:06:55.620 --> 00:07:00.470
but really if you're trying to do
like the next InDesign or PageMaker

00:07:00.560 --> 00:07:05.140
or those kind of applications,
you probably want to think about using

00:07:05.260 --> 00:07:09.560
the Quartz 2D API because that really has
a robust feature set for handling images,

00:07:09.560 --> 00:07:10.560
handling fonts and those kind of things.

00:07:10.610 --> 00:07:15.560
While OpenGL really is where the high
performance bit images can be handled.

00:07:17.100 --> 00:07:18.520
So what are we going to talk about?

00:07:18.640 --> 00:07:20.000
First,
we're going to hop into image display,

00:07:20.090 --> 00:07:22.600
talk about texture loading,
and talk about orthographic

00:07:22.600 --> 00:07:23.700
display and scaling.

00:07:23.760 --> 00:07:26.530
Then we're going to talk about sprites
with alpha blending and alpha test,

00:07:26.560 --> 00:07:28.020
and talk about using some
matrix manipulations to

00:07:28.020 --> 00:07:29.790
move them around the screen.

00:07:29.890 --> 00:07:32.260
Then we'll work that right
into the side scroller,

00:07:32.260 --> 00:07:36.000
showing a large scaling background
with sprites flying around on that.

00:07:36.060 --> 00:07:38.880
And lastly,
we'll talk about QuickTime integration.

00:07:40.500 --> 00:07:42.360
First let's talk about image display.

00:07:42.400 --> 00:07:44.890
One of the key things here
is how to load textures,

00:07:44.890 --> 00:07:47.340
how to get any texture or any
image you want into your system.

00:07:47.420 --> 00:07:49.800
We're going to use a
QuickTime image compression API.

00:07:49.890 --> 00:07:51.810
It's a great API for loading images.

00:07:52.060 --> 00:07:54.990
You can bring up a Nav Services dialog
and select any image you want,

00:07:55.030 --> 00:07:56.280
use QuickTime to load it.

00:07:56.520 --> 00:07:59.470
You didn't have to worry
about whether it was a BMP,

00:07:59.470 --> 00:08:01.800
a TIFF, a PIC, a JPEG, whatever.

00:08:01.800 --> 00:08:02.960
It'll load it for you.

00:08:03.020 --> 00:08:05.390
It'll put it in a buffer you can use.

00:08:05.480 --> 00:08:07.110
Some of you who've
looked at this may say,

00:08:07.150 --> 00:08:07.960
"Well, hold on.

00:08:08.020 --> 00:08:11.150
If I use new GWorld for that buffer,
I have some padding problems." I'll

00:08:11.150 --> 00:08:12.390
show you how to get around that.

00:08:12.450 --> 00:08:14.230
We'll show you how to use
any buffer that you can take.

00:08:14.230 --> 00:08:17.490
You're going to take a non-padded
buffer and you can use that

00:08:17.580 --> 00:08:19.630
directly for texturing to OpenGL.

00:08:19.780 --> 00:08:21.840
With that, you want to use PacPixels.

00:08:21.880 --> 00:08:27.400
The PacPixels extension or the PacPixels
that is in OpenGL 1.2 drivers will

00:08:27.400 --> 00:08:31.100
allow you to use a texture format
directly from the image to an off-screen

00:08:31.100 --> 00:08:34.700
G world to a texture without having
to do any pixel swizzling whatsoever.

00:08:34.700 --> 00:08:36.480
So you don't have to touch
those pixels unless you want

00:08:36.550 --> 00:08:37.660
to do some special effects.

00:08:37.700 --> 00:08:40.380
The three methods we'll
talk about is first,

00:08:40.470 --> 00:08:41.690
the simple way.

00:08:41.690 --> 00:08:44.610
OpenGL must have a power
of two textures currently.

00:08:44.730 --> 00:08:47.230
So what we're going to do,
the first way we'll talk about

00:08:47.530 --> 00:08:50.700
scaling with QuickTime to a
power of two texture on load and

00:08:51.000 --> 00:08:52.700
then fixing it as we display it.

00:08:52.700 --> 00:08:55.700
Next we'll talk about segmenting
the power of two textures.

00:08:55.700 --> 00:08:57.900
A little bit more complicated,
where you take a large image

00:08:57.900 --> 00:08:59.700
that is of abstract size,
any size you want,

00:08:59.700 --> 00:09:03.840
and you segment it down so you get
the pixel perfect representation

00:09:03.840 --> 00:09:06.290
of that image in multiple textures.

00:09:06.710 --> 00:09:08.980
And lastly, we'll talk about-- we're not
going to really talk about it.

00:09:08.980 --> 00:09:09.600
I'll talk about it here.

00:09:09.600 --> 00:09:11.240
We'll talk about texture rectangle.

00:09:11.310 --> 00:09:14.420
Texture rectangle is an extension coming
down the road that will allow you to

00:09:14.420 --> 00:09:17.970
take any shape or size-- not any shape,
but any rectangular texture

00:09:18.310 --> 00:09:20.940
that is not necessarily a power
of two in texture with that.

00:09:21.050 --> 00:09:22.930
All the vendors are working
hard to support that.

00:09:22.970 --> 00:09:24.060
We're working hard to support that.

00:09:24.060 --> 00:09:27.180
So look for that in the future when
you're talking about image loading

00:09:27.180 --> 00:09:28.580
and image handling with OpenGL.

00:09:28.580 --> 00:09:32.520
It will allow you to handle textures
of arbitrary size directly into

00:09:32.520 --> 00:09:35.330
the OpenGL hardware accelerator.

00:09:37.900 --> 00:09:41.930
I think I better take a
drink of water for this one.

00:09:42.000 --> 00:09:44.520
The QuickTime Image Compression API.

00:09:44.520 --> 00:09:47.740
Let me actually back up a
little bit with the code here.

00:09:47.810 --> 00:09:50.900
The code I'm putting up here will
all be available in sample code.

00:09:50.900 --> 00:09:54.360
There's no code you'll see on the screen
that you'll not be able to get a hold of.

00:09:54.410 --> 00:09:59.780
So don't try and take specific
notes exactly how to do it on this.

00:09:59.780 --> 00:10:01.500
Most of this stuff will be up
before the end of the week.

00:10:01.540 --> 00:10:02.930
Some of it's up already,
and the rest of the stuff

00:10:02.980 --> 00:10:04.360
will probably be up next week.

00:10:04.370 --> 00:10:05.440
So you'll definitely be
able to get at the code,

00:10:05.440 --> 00:10:08.980
and look at it yourself,
and look through it, and decipher it,

00:10:08.980 --> 00:10:10.500
and figure out what
we're doing with that.

00:10:10.550 --> 00:10:13.160
So if you listen hard,
I think I can go through and explain

00:10:13.160 --> 00:10:15.330
exactly what's happening here.

00:10:18.210 --> 00:10:21.150
First thing you do is get
graphics importer for a file.

00:10:21.250 --> 00:10:24.480
You have an FS spec from your
Nav Services dialog or something

00:10:24.510 --> 00:10:25.600
that you create yourself.

00:10:25.600 --> 00:10:28.360
And you get graphics importer for file.

00:10:28.700 --> 00:10:31.100
It returns the GI comp variable there.

00:10:31.100 --> 00:10:33.390
What then I do is get the
natural bounds of that.

00:10:33.810 --> 00:10:37.290
Basically tells me how big the image
is so I know what I'm working with.

00:10:37.670 --> 00:10:41.940
Second thing I do after that
is decide on what the stride

00:10:41.940 --> 00:10:45.350
of that image is to create a
pointer for it to hold that image.

00:10:45.370 --> 00:10:48.600
The reason I do this is that's
a step you may not normally see.

00:10:48.680 --> 00:10:52.270
That step, creating the stride,
tells you exactly, bit for bit,

00:10:52.270 --> 00:10:54.090
what's the width of that
image without padding.

00:10:54.100 --> 00:10:56.580
And then that new pointer,
I'm going to create a buffer

00:10:56.660 --> 00:10:59.440
that's exactly the size of
that image without any padding,

00:10:59.440 --> 00:11:02.210
without any padding through a 4-byte,
or anything that a

00:11:02.210 --> 00:11:03.700
GWorld may normally do.

00:11:03.700 --> 00:11:06.640
I then call qt new GWorld from pointer.

00:11:06.740 --> 00:11:09.190
It's not a function you see very often,
but it works very well because

00:11:09.190 --> 00:11:13.010
it will use that pointer I've
created for that new GWorld,

00:11:13.180 --> 00:11:15.680
and you're supplying the memory,
you're supplying the padding.

00:11:15.700 --> 00:11:18.320
It will say,
I know the information there,

00:11:18.320 --> 00:11:21.740
I have the stride at the end,
so I'm going to use that packed

00:11:21.930 --> 00:11:24.820
image buffer for the GWorld,
and I'm not going to

00:11:24.820 --> 00:11:26.690
allocate any memory myself.

00:11:26.700 --> 00:11:30.660
That is key to using packed pixels and
using direct texturing to OpenGL because

00:11:30.660 --> 00:11:34.690
that allows you not to have to skip rows,
not to have to do-- strange things with

00:11:34.690 --> 00:11:36.700
the image before using it with OpenGL.

00:11:36.760 --> 00:11:38.700
And you see there's two
different versions here.

00:11:38.700 --> 00:11:39.810
The reason there's two
different versions,

00:11:39.820 --> 00:11:43.700
and you probably could make it one with
assigning that constant to a variable,

00:11:43.700 --> 00:11:47.180
but in this case,
I wanted to show you that there

00:11:47.180 --> 00:11:54.630
is two K32 ARGB pixel format
and K16BE555 pixel format.

00:11:54.940 --> 00:11:56.840
Those are open--sorry,
those are QuickTime constants

00:11:56.840 --> 00:12:00.470
that indicate to QuickTime what
kind of pixel format you're going

00:12:00.480 --> 00:12:02.390
to have in that GWorld there.

00:12:04.900 --> 00:13:14.400
[Transcript missing]

00:13:14.570 --> 00:13:18.260
So lastly, we're going to do a
graphics import set G world.

00:13:18.300 --> 00:13:20.700
Graphics import set the
quality for lossless.

00:13:20.700 --> 00:13:22.240
We're going to get the G world pixmap.

00:13:22.240 --> 00:13:24.240
Of course,
remember to lock that and check

00:13:24.340 --> 00:13:26.720
the value of your lock on the
return because you don't want

00:13:26.840 --> 00:13:28.330
to draw into a non-lock pixmap.

00:13:28.390 --> 00:13:30.370
It's not good enough just
to call that lock pixels.

00:13:30.550 --> 00:13:33.940
And then use graphics import draw,
unlock pixels, and close your component.

00:13:33.950 --> 00:13:39.970
Now, in that pixmap that you've
created is the image off the disk.

00:13:39.970 --> 00:13:39.970
No problems.

00:13:40.680 --> 00:13:42.480
So what are some other
things we want to talk about?

00:13:42.480 --> 00:13:43.640
Let's talk about packed pixels.

00:13:43.640 --> 00:13:46.100
How do we get that image into OpenGL?

00:13:46.190 --> 00:13:48.700
First, real critical,
if you're using AGL,

00:13:48.700 --> 00:13:51.060
make sure you use AGL no recovery.

00:13:51.060 --> 00:13:54.020
AGL no recovery says,
I don't want to create a software

00:13:54.070 --> 00:13:58.460
backup render to back up if the
system runs out of resources for this.

00:13:58.460 --> 00:14:02.740
What that does in this case, it says,
I want to respect the

00:14:02.890 --> 00:14:05.020
hardware's pixel formats only.

00:14:05.030 --> 00:14:06.900
So if you're sending to a hardware,
all you're going to do is

00:14:07.050 --> 00:14:08.560
create the pixel format.

00:14:08.560 --> 00:14:10.430
OpenGL is only going to use
the pixel format for that one

00:14:10.580 --> 00:14:11.940
specific piece of hardware.

00:14:11.940 --> 00:14:13.960
It's not going to try and
use a software backup,

00:14:13.960 --> 00:14:16.070
which happens to not
support packed pixels,

00:14:16.180 --> 00:14:18.260
so it may convert everything to 32-bit.

00:14:18.260 --> 00:14:20.580
So if you have a 16-bit format here,
you want to make sure you

00:14:20.580 --> 00:14:22.760
do that to keep it 16-bit.

00:14:22.760 --> 00:14:28.000
You need OpenGL version 1.2 or the
GL Apple Packed Pixel extension

00:14:28.180 --> 00:14:32.220
to support packed pixels.

00:14:32.220 --> 00:14:34.680
And if you notice,
one thing you'll notice,

00:14:34.780 --> 00:14:37.470
the extension string is packed pixel,
not packed pixels,

00:14:37.700 --> 00:14:38.500
which I think it's listed.

00:14:38.520 --> 00:14:39.860
And this is just a little caveat.

00:14:39.930 --> 00:14:43.500
So if you search for packed pixel,
no matter which way we go with that,

00:14:43.670 --> 00:14:46.110
if it changes in the future,
you always make sure you get it.

00:14:46.200 --> 00:14:48.750
Because if you search for packed pixels,
you may not get it in the

00:14:48.750 --> 00:14:50.380
future or the other way around.

00:14:50.410 --> 00:14:54.910
In any case,
the key here is GL text image

00:14:54.910 --> 00:15:00.280
2D with a BGRA extension and the
unsigned in 8888 reversed and the

00:15:00.350 --> 00:15:02.980
BGRA unsigned short 155 reversed.

00:15:03.130 --> 00:15:07.050
The way you read that is the reverse of
the pixel format applies to the BGRA.

00:15:07.350 --> 00:15:08.400
So it's ARGB.

00:15:08.710 --> 00:15:13.580
155 or ARGB 888, which we recognize as a
standard Mac pixel format.

00:15:13.600 --> 00:15:18.510
Thus, you can use these to directly
texture out of your image buffer.

00:15:20.200 --> 00:15:22.780
So scaling to power of two,
what do we do with this?

00:15:22.780 --> 00:15:25.000
You notice I have the
example images here.

00:15:25.000 --> 00:15:28.140
The first one's like a 256 by 256
compressed down to exactly what

00:15:28.400 --> 00:15:30.060
the texture's going to look like.

00:15:30.060 --> 00:15:33.640
What we're going to do with this is
we're going to restore the aspect

00:15:33.760 --> 00:15:37.300
ratio by storing the image aspect
ratio that we read in and setting the

00:15:37.300 --> 00:15:41.020
polygon's aspect ratio to the same image,
texturing to fill the polygon,

00:15:41.020 --> 00:15:42.940
which will just stretch it back out.

00:15:42.940 --> 00:15:45.550
Again, we're losing information here,
but the image appears

00:15:45.630 --> 00:15:46.520
correct on our screen.

00:15:50.000 --> 00:15:52.190
So scale the power of 2.

00:15:55.200 --> 00:15:59.400
This piece of code here is actually
pretty simple and maybe easier

00:15:59.400 --> 00:16:00.790
to look through it on your own.

00:16:00.790 --> 00:16:02.660
But really what I'm doing
here is fairly simple.

00:16:02.850 --> 00:16:08.400
What I do is if the image
size is-- I step through,

00:16:08.590 --> 00:16:10.620
I take my largest--

00:16:10.800 --> 00:16:13.440
the largest power of two that I want,
and I step through and remove

00:16:13.440 --> 00:16:16.340
that from... I'm sorry,
that's incorrect.

00:16:16.340 --> 00:16:19.750
Basically what I'm going to do is
I'm going to use the fact that I can

00:16:19.840 --> 00:16:23.080
shift things down a power of two at
a time by using the shift registers.

00:16:23.080 --> 00:16:25.280
And I'll shift it down
until there's nothing left.

00:16:25.290 --> 00:16:27.870
When there's nothing left,
I'll put a one in the first

00:16:27.870 --> 00:16:29.210
bit and shift it back up.

00:16:29.210 --> 00:16:31.900
And what that does,
it tells me the largest power

00:16:31.900 --> 00:16:33.420
of two image that's nearest.

00:16:33.420 --> 00:16:37.250
And then at the end, I basically say,
if it's closer to one than the other,

00:16:37.250 --> 00:16:38.780
I check the above and below.

00:16:38.780 --> 00:16:43.590
So basically I got to the point where
I have a power of two that is going to

00:16:43.590 --> 00:16:46.680
be smaller or larger than the image.

00:16:46.680 --> 00:16:51.210
So if I had a 249 pixel image,
I shift it all the way down,

00:16:51.210 --> 00:16:54.510
and when I shift it back up, I got 256,
because I have that one bit

00:16:54.520 --> 00:16:59.960
in one of the... I have a one
in one bit of the image size.

00:16:59.960 --> 00:17:03.300
And then I compare that
to that shifted to 128,

00:17:03.400 --> 00:17:04.590
and I see which is closer.

00:17:04.590 --> 00:17:06.180
So I'm getting the nearest one.

00:17:06.180 --> 00:17:08.760
So what this little piece of code does,
it defines the nearest power.

00:17:08.780 --> 00:17:09.770
So I can see the nearest power of two.

00:17:09.770 --> 00:17:10.820
There's probably different
ways to slice it.

00:17:10.820 --> 00:17:12.780
I thought this was probably
the easiest way to do it.

00:17:12.820 --> 00:17:16.780
And it's not real easy to explain,
but I think if you step through it,

00:17:16.780 --> 00:17:16.780
you can see how it's working.

00:17:16.780 --> 00:17:18.070
And that's all.

00:17:18.070 --> 00:17:22.990
I'm just bringing up the demo machine,
and I'll show you this in action here.

00:17:27.300 --> 00:17:30.250
What we're going to do is we're
going to choose a file to open here,

00:17:30.250 --> 00:17:32.890
and this is going to open an image.

00:17:35.370 --> 00:17:37.640
And it's just going to
display it in OpenGL window.

00:17:37.730 --> 00:17:40.620
If you notice, it's a standard window,
standard image.

00:17:40.620 --> 00:17:42.930
Remember this image does
not have the complete image

00:17:43.030 --> 00:17:44.600
quality that we had originally.

00:17:44.660 --> 00:17:46.900
If you look at the text,
which may be hard to read up there,

00:17:46.900 --> 00:17:48.280
but I'll tell you what it says.

00:17:48.280 --> 00:17:50.420
It's a 640x480x32 bit image.

00:17:50.440 --> 00:17:52.160
That obviously isn't a power of 2.

00:17:52.180 --> 00:17:54.720
We've put it into a 512x512 texture.

00:17:54.920 --> 00:17:59.240
And then we've rescaled it out so it
looks exactly like the right image.

00:17:59.320 --> 00:18:02.850
If you want to see the actual polygon,
I can zoom it out for you.

00:18:02.860 --> 00:18:05.600
That's actually a single
polygon with a single texture,

00:18:05.610 --> 00:18:09.460
512x512 stretched back to the
correct aspect ratio for the image.

00:18:09.470 --> 00:18:11.920
One of the nice things you see
here is high performance 2D,

00:18:11.920 --> 00:18:12.140
right?

00:18:12.140 --> 00:18:13.280
That's what we're talking about.

00:18:13.280 --> 00:18:15.490
This is high performance 2D.

00:18:16.710 --> 00:18:20.100
Using the OpenGL transforms,
no problem rotating the image.

00:18:20.120 --> 00:18:23.040
And if you want to zoom in,
we can do that too.

00:18:23.150 --> 00:18:24.980
Very easy.

00:18:25.040 --> 00:18:27.150
We'll go to full screen.

00:18:27.570 --> 00:18:33.570
Still get really nice transforms,
real easy to manipulate

00:18:33.570 --> 00:18:33.570
images using OpenGL.

00:18:34.260 --> 00:18:36.200
Using OpenGL as your 2D transform.

00:18:36.250 --> 00:18:40.320
But you say, you know,
really I want all that information that,

00:18:41.190 --> 00:18:42.990
uh,
we can go back to the presentation now.

00:18:43.010 --> 00:18:45.190
I want all the information that
I had in the original image.

00:18:45.200 --> 00:18:48.200
I want to have all that,
I don't want to lose information.

00:18:48.200 --> 00:18:50.190
Oh, let me back up.

00:18:50.580 --> 00:18:52.680
If you notice,
if you look carefully at the

00:18:52.760 --> 00:18:55.710
screen saver in Mac OS X,
OS X uses the same technique.

00:18:55.710 --> 00:19:00.500
It translates all the images to
512 by 1024 textures and uses that.

00:19:00.500 --> 00:19:02.680
But you said, man,
that screen saver looks great,

00:19:02.730 --> 00:19:03.490
great detail.

00:19:03.640 --> 00:19:04.490
You're losing detail.

00:19:04.500 --> 00:19:08.050
If that image is 768 tall,
it's squished down to 524.

00:19:08.050 --> 00:19:11.500
If it's 900 wide,
it's stretched out to 1024.

00:19:11.500 --> 00:19:15.500
So it uses that to get consistent
images and to have easy texture loading.

00:19:15.500 --> 00:19:17.500
So that's an actual use of
this in a 2D environment.

00:19:17.500 --> 00:19:19.920
And you can see then they can get
the fades using the OpenGL hardware

00:19:19.920 --> 00:19:23.570
acceleration instead of having to
do some kind of fade themselves,

00:19:23.660 --> 00:19:27.290
which is going to be real hard
and real taxing for the system.

00:19:28.880 --> 00:19:31.060
So the other option we have
is segmenting to power of two.

00:19:31.070 --> 00:19:32.110
You don't want to lose that.

00:19:32.200 --> 00:19:36.490
And this is an interesting technique,
a little bit more complicated,

00:19:36.490 --> 00:19:38.840
but it uses the same
basis as the other ones.

00:19:38.890 --> 00:19:41.120
In this case, what we have is you can
see the image there,

00:19:41.120 --> 00:19:44.680
and the green lines indicate the actual
polygons that comprise that image.

00:19:45.010 --> 00:19:48.170
And I've segmented this image
to about four by four as

00:19:48.260 --> 00:19:49.790
far as using it to display.

00:19:49.800 --> 00:19:53.330
And so I've kept all the
pixels directly in one texture,

00:19:53.340 --> 00:19:56.020
and then I'm sliced out of
that texture for each image.

00:19:56.260 --> 00:20:00.580
The way I do that is when
you call GLTextImage2D,

00:20:00.580 --> 00:20:02.210
you provide it with a base address.

00:20:02.460 --> 00:20:03.860
That base address can be manipulated.

00:20:03.860 --> 00:20:05.950
It doesn't have to be the
beginning of your buffer.

00:20:06.040 --> 00:20:09.030
So what you can do is provide it
with the beginning of every single

00:20:09.030 --> 00:20:11.300
segment of that buffer very simply.

00:20:11.320 --> 00:20:14.460
The other thing you can provide
is OpenGL has a constant

00:20:14.660 --> 00:20:16.700
called unpacked row length.

00:20:16.750 --> 00:20:21.500
And normally, the width you pass into
GLTextImage2D is the width that it uses.

00:20:21.510 --> 00:20:23.620
Obviously,
if you were taking a piece out of this,

00:20:23.650 --> 00:20:26.200
that wouldn't make any sense
because it would be all skewed.

00:20:26.200 --> 00:20:29.120
It would try and take the next pixel
over and stick it on the end of your

00:20:29.120 --> 00:20:33.500
image so you get this kind of skewed
image that came across your screen.

00:20:33.700 --> 00:20:36.670
We'll set unpacked row length to
actually the width of the entire image,

00:20:36.700 --> 00:20:38.520
vice the width of that little
piece of texture we want.

00:20:38.620 --> 00:20:42.080
So what it'll do is for every row,
it'll skip that much.

00:20:42.160 --> 00:20:43.580
That's like its image stride.

00:20:43.620 --> 00:20:45.730
It'll skip that much and
come down to the next one,

00:20:45.810 --> 00:20:48.680
grab a piece of it,
skip the entire rest of the row,

00:20:48.680 --> 00:20:49.600
and grab the next piece.

00:20:49.600 --> 00:20:52.880
So it'll have that nice lined
up pieces of the polygons when

00:20:52.990 --> 00:20:55.100
it actually tries to draw it.

00:20:55.100 --> 00:20:57.750
So we use the image width
and the unpacked row length,

00:20:57.900 --> 00:21:02.140
and then the texture width will
be some smaller subset of that.

00:21:04.730 --> 00:21:05.100
OK.

00:21:05.100 --> 00:21:07.300
Segmenting to power of two.

00:21:07.300 --> 00:21:11.200
What we're going to do is this
first black box statement up here

00:21:11.200 --> 00:21:14.440
basically tells me how many textures
I have in the image dimension.

00:21:14.440 --> 00:21:15.850
Same technique we kind of used before.

00:21:15.900 --> 00:21:19.680
Basically what I do is I say, OK,
I know that if I look at the bitwise

00:21:19.680 --> 00:21:23.390
representation of that dimension,
I can just kind of count the

00:21:23.390 --> 00:21:24.730
bits that are actually turned on.

00:21:24.810 --> 00:21:27.880
So if I look at the ones and zeros,
I can go, how many ones are there?

00:21:27.880 --> 00:21:29.790
And that's the number of
textures I actually need to use.

00:21:29.950 --> 00:21:30.920
It's real simple.

00:21:30.920 --> 00:21:34.240
Works very well when you realize that
that's a nice little thing to have.

00:21:34.240 --> 00:21:36.700
I then do a new pointer
clear for texture names.

00:21:36.700 --> 00:21:38.700
And that's texture x by texture y.

00:21:38.800 --> 00:21:42.060
So I'm going to create an array that
I can store my texture names in.

00:21:42.060 --> 00:21:46.250
I'm going to use pixel store i,
as we talked about, for the image width,

00:21:46.410 --> 00:21:48.380
for the entire texture
width in this case,

00:21:48.380 --> 00:21:49.620
the entire texture width.

00:21:49.620 --> 00:21:53.800
And then I'm going to do a gen
textures to generate texture names for

00:21:53.800 --> 00:21:55.700
each texture I need for that image.

00:21:55.700 --> 00:21:57.530
So in that case,
you saw those are 4 by 4.

00:21:57.540 --> 00:21:59.900
I'm going to generate 16 texture names.

00:21:59.900 --> 00:22:02.340
Then when I draw the image,
I'll use gl bind textures.

00:22:02.340 --> 00:22:03.880
I'll bind each texture in turn.

00:22:03.880 --> 00:22:06.600
And I'll draw the image that way.

00:22:06.710 --> 00:22:11.090
So let's look at actually
getting it into memory.

00:22:11.700 --> 00:22:13.500
Another little black box
function we have here,

00:22:13.500 --> 00:22:16.180
that I'll show you in a few minutes,
is get next texture size.

00:22:16.200 --> 00:22:18.910
It takes where you are
currently in the image and says,

00:22:19.180 --> 00:22:20.130
what's the next size?

00:22:20.160 --> 00:22:22.640
What it does is I say
I have a max texture size.

00:22:22.640 --> 00:22:23.460
This is what I was talking about earlier.

00:22:23.460 --> 00:22:24.180
I got confused.

00:22:24.180 --> 00:22:27.500
I have a max texture size I want to use,
256, 512.

00:22:27.500 --> 00:22:29.610
Maybe I don't want to go
up to 2000 for an image.

00:22:29.650 --> 00:22:32.430
Maybe I want to keep it down to 128,
so I have 128 segments,

00:22:32.550 --> 00:22:33.260
whatever you prefer.

00:22:33.260 --> 00:22:35.900
It steps through 128,
removing that from the

00:22:35.900 --> 00:22:37.100
length of the image.

00:22:37.100 --> 00:22:41.000
And then once it gets past that,
once there's less than 128 left,

00:22:41.160 --> 00:22:43.210
it takes the next biggest
power of 2 off the image,

00:22:43.240 --> 00:22:44.800
and it keeps doing that kind of down.

00:22:44.800 --> 00:22:46.360
So it keeps doing 128, 64.

00:22:46.360 --> 00:22:47.640
Okay, there's no 32s.

00:22:47.640 --> 00:22:49.820
I'll give you a 16,
and then whatever else you got left.

00:22:49.940 --> 00:22:52.680
In this case,
we get the next texture size in the loop.

00:22:52.860 --> 00:22:54.960
We go for X and Y for
each of our textures.

00:22:54.960 --> 00:22:59.920
Our offset is 0 for the Y offset.

00:22:59.920 --> 00:23:02.610
That means we're going in the columns.

00:23:02.620 --> 00:23:04.940
We're going to start at the
top of the image for every row.

00:23:04.940 --> 00:23:08.520
Above this,
we're going to have the X offset

00:23:08.520 --> 00:23:09.800
is 0 at the very beginning.

00:23:09.800 --> 00:23:12.100
And what we're going to do,
is we're going to take

00:23:12.100 --> 00:23:14.740
the pointer to the buffer,
is the normal image buffer we

00:23:14.750 --> 00:23:21.360
got before from Quick Draw,
when we used the QGNUG from pointer.

00:23:21.360 --> 00:23:24.470
We're going to use the offset
Y by the texture width,

00:23:24.560 --> 00:23:28.340
times the image depth,
divided by 8 in this case, is shifted 3.

00:23:28.340 --> 00:23:31.790
So what basically we're doing is saying
that this is going to offset into the

00:23:31.790 --> 00:23:33.510
image for that corner of every texture.

00:23:33.580 --> 00:23:37.380
So we offset across for X,
offset down for Y for every row,

00:23:37.380 --> 00:23:41.020
and we offset in based on what the
width of each texture we need to get.

00:23:41.100 --> 00:23:42.990
to use this.

00:23:45.520 --> 00:23:47.240
Get the next texture size for the height.

00:23:47.270 --> 00:23:50.400
We've got it for the width,
so we put in the previous texture size.

00:23:50.400 --> 00:23:52.030
We call bind texture.

00:23:52.040 --> 00:23:53.350
We do that bind texture.

00:23:53.410 --> 00:23:55.400
We pick the next texture
name in our list of 16.

00:23:55.400 --> 00:24:00.400
And then we basically do
the same GL text image 2D.

00:24:00.400 --> 00:24:03.400
If you notice, I'm using the P buffer,
and I'll go back a slide.

00:24:03.400 --> 00:24:07.400
The P buffer is that P buffer,
not the P image buffer.

00:24:07.400 --> 00:24:09.400
The P image buffer was
the original pointer.

00:24:09.400 --> 00:24:13.400
And the P buffer is the pointer
to whatever specific texture.

00:24:13.400 --> 00:24:15.920
And we bound,
we've told it the unsigned row length,

00:24:15.920 --> 00:24:18.400
unpacked row length is the
width of the whole image.

00:24:18.420 --> 00:24:21.990
And so we use the GL text image
2D at that point to grab the

00:24:22.110 --> 00:24:24.400
right texture out of the image.

00:24:24.400 --> 00:24:25.400
So we're kind of doing the cookie cutter.

00:24:25.400 --> 00:24:29.400
Take a piece, take a piece, take a piece,
move down, take some more pieces,

00:24:29.400 --> 00:24:32.430
and we slice our image up that way.

00:24:33.380 --> 00:24:37.080
This is a little snippet of code from the
Get Texture Numb from Texture Dimension.

00:24:37.080 --> 00:24:38.010
Same kind of thing.

00:24:38.020 --> 00:24:40.230
First thing I'm going to do in
this is I'm going to remove what

00:24:40.290 --> 00:24:41.970
are my max size of textures.

00:24:41.980 --> 00:24:43.280
I have max text size.

00:24:43.280 --> 00:24:47.910
I'm going to divide by max text and count
how many max texture images fit in there.

00:24:47.920 --> 00:24:49.880
Then I'm going to take
whatever is left over,

00:24:49.880 --> 00:24:52.060
the Texture Dim I reset there,
and I'm going to,

00:24:52.060 --> 00:24:53.960
is there anything of 8,000?

00:24:53.960 --> 00:24:55.120
Is there anything of 4,000?

00:24:55.120 --> 00:24:56.240
Is there anything of 2,000?

00:24:56.240 --> 00:24:57.360
Is there anything of 1,000?

00:24:57.430 --> 00:24:58.730
I just go down each one.

00:24:58.740 --> 00:25:01.440
If you notice, when you add all that up,
it will add up back to the

00:25:01.440 --> 00:25:02.800
complete size of the image.

00:25:02.870 --> 00:25:06.770
So this tells me how many
textures across I have or down.

00:25:07.100 --> 00:25:10.580
And lastly here, get next text size.

00:25:10.580 --> 00:25:13.030
This says, hey,
I got the size of my current one.

00:25:13.250 --> 00:25:16.660
Is it one of the first max size ones,
or am I going to step down into my list

00:25:16.770 --> 00:25:20.510
and basically do the exact same thing,
checking to see if I have an 8,000,

00:25:20.510 --> 00:25:24.150
a 4,000, a 2,000, a 1,000, like that.

00:25:24.970 --> 00:25:26.160
So, how do we display these things?

00:25:26.160 --> 00:25:31.550
First, we're going to use an orthographic
display set up to the scale of the image,

00:25:31.550 --> 00:25:33.280
the scale of the screen.

00:25:33.280 --> 00:25:36.330
So, the images you saw,
I scale your display to be

00:25:36.330 --> 00:25:37.980
the pixel scale of the window.

00:25:37.980 --> 00:25:40.970
So, when you're manipulating them,
if I offset three pixels,

00:25:41.020 --> 00:25:42.720
I'm offsetting three
pixels in the window.

00:25:42.720 --> 00:25:44.710
So, this actually is a
good way to display it,

00:25:44.790 --> 00:25:47.540
so you're thinking like a quick,
like quick draw, or normal,

00:25:47.540 --> 00:25:50.750
what you're used to thinking as far as,
you invert the x,

00:25:50.750 --> 00:25:54.970
you invert the y coordinate, your x is,
your origin is in the upper left corner,

00:25:54.980 --> 00:25:58.560
and at that point you're moving
things in a pixel centric manner.

00:25:58.560 --> 00:26:01.810
I may ignore z, I don't need z,
so I don't need to

00:26:01.830 --> 00:26:05.420
establish a depth buffer,
and I ignore z for this one.

00:26:05.470 --> 00:26:08.370
I use poly,
I'll use a polygon to scale the image.

00:26:08.430 --> 00:26:11.140
When you saw me scaling it out,
that image before,

00:26:11.140 --> 00:26:13.390
I used a polygon to scale,
I used to manipulate

00:26:13.490 --> 00:26:15.800
the polygon positions,
I didn't use any texture coordinates,

00:26:15.800 --> 00:26:19.210
I didn't scale my window at all,
all I did was scale my polygon size,

00:26:19.210 --> 00:26:22.270
my texture stayed the same,
and OpenGL takes care of the whole thing.

00:26:22.340 --> 00:26:26.840
It takes care of the hardware accelerated
transform to get it onto the polygon.

00:26:26.840 --> 00:26:29.410
And you can use the model view
matrix very simply in the,

00:26:29.430 --> 00:26:31.340
in this case, to offset and rotate.

00:26:31.470 --> 00:26:34.310
So, as you saw me drag,
I just do a drag on the mouse,

00:26:34.330 --> 00:26:37.550
I use a real, real nice Carbon events,
tell me when the mouse drags,

00:26:37.550 --> 00:26:40.370
I figure out what the start point and
the end point for the mouse drag is,

00:26:40.370 --> 00:26:42.500
and I just drag the image
by that many pixels.

00:26:42.500 --> 00:26:44.460
My offset,
since I'm already in pixel space,

00:26:44.520 --> 00:26:47.600
is exactly that when I apply
it into the model view matrix.

00:26:47.620 --> 00:26:50.120
Rotation,
I get the rotation in degrees for the,

00:26:50.120 --> 00:26:52.810
for the turn of the mouse,
and I apply it in to the

00:26:52.850 --> 00:26:57.210
rotation matrix of the,
around the z-axis for the model view

00:26:57.510 --> 00:27:00.070
matrix to manipulate the rotation of it.

00:27:00.080 --> 00:27:02.160
And now we're going to
go back to the demo.

00:27:08.200 --> 00:27:14.310
And one thing about the multi-texture
demo here is that I can load

00:27:14.310 --> 00:27:16.440
the same image I did before.

00:27:16.510 --> 00:27:21.110
If you notice this one,
it's tiled in multiple textures.

00:27:21.220 --> 00:27:23.780
Let's expand it out.

00:27:23.890 --> 00:27:26.970
And I'll zoom in a little bit to
actually see what it looks like.

00:27:30.460 --> 00:27:33.830
What you see in there is the actual pixel
grid of the actual pixels on the screen,

00:27:33.850 --> 00:27:35.060
or actual pixels of the image.

00:27:35.060 --> 00:27:37.930
And you can see how the textures
actually lie right on the pixel grid.

00:27:38.060 --> 00:27:41.980
So you can see that these come together.

00:27:43.100 --> 00:27:45.230
Right on the pixel grid of the image.

00:27:45.230 --> 00:27:48.000
And OpenGL does a great job
of stretching that image.

00:27:48.000 --> 00:27:49.320
I mean, there's only a certain
amount of data there,

00:27:49.320 --> 00:27:50.930
but it does a great job
of scaling the image.

00:27:50.930 --> 00:27:54.470
And you've still got great
performance on this 640x480 image.

00:27:54.540 --> 00:27:57.590
But you say, you know,
maybe I want something bigger.

00:27:57.780 --> 00:27:59.940
So, I had to dig around to
find a bigger image,

00:27:59.940 --> 00:28:02.140
but I did find a bigger image,
and I haven't tried this one for a while,

00:28:02.140 --> 00:28:05.160
so hopefully this one will be okay.

00:28:05.340 --> 00:28:08.240
This one takes a while to load,
and I kind of remember

00:28:08.400 --> 00:28:09.590
how big this image is.

00:28:09.600 --> 00:28:12.860
I think it's 2800 by 2100.

00:28:12.890 --> 00:28:14.860
So it's a pretty big image.

00:28:14.970 --> 00:28:17.660
If you look at the polygons,
we'll zoom out a little bit.

00:28:18.030 --> 00:28:22.380
Those are five, the max texture size,
nine by six, I think the max texture

00:28:22.420 --> 00:28:24.060
size is 512 in this case.

00:28:24.200 --> 00:28:27.940
So, 2800 by 2100.

00:28:28.130 --> 00:28:28.540
Pretty nice.

00:28:28.550 --> 00:28:29.460
Oh, you want to rotate it?

00:28:29.460 --> 00:28:30.540
We can do the rotation too.

00:28:30.540 --> 00:28:31.330
That's easy to do.

00:28:31.330 --> 00:28:36.330
You want to zoom in to
see the actual inference?

00:28:39.500 --> 00:28:42.030
Nice detail there for the image.

00:28:42.110 --> 00:28:46.160
So you can see OpenGL works very
well for handling 2D images.

00:28:46.200 --> 00:28:48.560
One thing that might be interesting is,
see if I can find one of these.

00:28:48.600 --> 00:28:50.690
We'll help ourselves.

00:28:51.720 --> 00:28:53.920
People who've been working with
OpenGL say there's a little

00:28:54.040 --> 00:28:55.580
problem with my technique,
and there actually is.

00:28:55.630 --> 00:28:58.280
If I can find the corner.

00:28:58.530 --> 00:29:02.470
It'll show up right here, probably.

00:29:03.120 --> 00:29:06.080
You kind of can see it here,
not very well.

00:29:06.080 --> 00:29:07.400
Actually, it's better than I thought.

00:29:07.470 --> 00:29:10.180
There is a discontinuity along that line.

00:29:10.180 --> 00:29:12.540
And there's probably
better examples of it.

00:29:12.540 --> 00:29:14.660
Let me see actually if
I can find a better one,

00:29:14.660 --> 00:29:17.070
because it's kind of a
good thing to understand.

00:29:19.870 --> 00:29:25.500
Probably on the edge here
we'll be able to see it better.

00:29:25.750 --> 00:29:26.800
Back toward the middle you say?

00:29:26.800 --> 00:29:28.640
I can see it.

00:29:28.640 --> 00:29:34.640
How about down here?

00:29:40.500 --> 00:29:41.900
Okay, you'll have to think-- oh,
there it is.

00:29:41.900 --> 00:29:43.340
Actually, you can see it right there.

00:29:43.510 --> 00:29:44.350
See across there?

00:29:44.550 --> 00:29:46.190
You can see right across
here there's a discontinuity.

00:29:46.190 --> 00:29:49.470
The discontinuity is
OpenGL uses filtering.

00:29:49.590 --> 00:29:59.690
OpenGL filters across the texture
to-- when it tries to magnify and

00:29:59.690 --> 00:29:59.690
minify by a texture by texture

00:30:00.420 --> 00:30:01.270
I don't know what the best way to put it.

00:30:01.380 --> 00:30:02.660
It looks at each texture separately.

00:30:02.660 --> 00:30:04.200
Remember,
you've moved this image from image

00:30:04.200 --> 00:30:07.400
space that you had to the textures,
and it looks at each texture

00:30:07.480 --> 00:30:10.680
separately and wants to filter it
when it tries to do the scaling

00:30:10.680 --> 00:30:13.380
for minification and magnification.

00:30:13.400 --> 00:30:16.260
What that means is it looks at
the next pixel over and says,

00:30:16.350 --> 00:30:17.300
what is the color of the next pixel?

00:30:17.300 --> 00:30:20.560
Well, in this case,
it says there's no next pixel.

00:30:20.560 --> 00:30:21.410
It's the edge of the texture.

00:30:21.420 --> 00:30:24.130
So there's a filtering
discontinuity between two edges.

00:30:24.140 --> 00:30:27.740
So if you really want the
perfect representation of this,

00:30:27.740 --> 00:30:30.700
something I didn't do in this demo,
what you can do is take a texture border.

00:30:30.700 --> 00:30:35.480
You can take a border of one
row of pixels from your image.

00:30:35.480 --> 00:30:38.060
So you make your textures like one
pixel smaller and take a border

00:30:38.350 --> 00:30:41.910
around them so that minification,
magnification filtering is more accurate.

00:30:41.920 --> 00:30:44.450
Not something I did here,
but you can do it if you want

00:30:44.450 --> 00:30:46.610
the perfect example of this.

00:30:46.620 --> 00:30:50.350
So again, this is scaled up like
two and a half times,

00:30:50.380 --> 00:30:54.850
and you can see that it does a
pretty good job on this stuff.

00:30:54.920 --> 00:30:56.270
So we'll go back to the slides.

00:30:59.200 --> 00:31:04.080
Okay,
let's move on to talking about sprites.

00:31:12.230 --> 00:31:13.760
Sprites are actually pretty simple.

00:31:13.860 --> 00:31:17.310
Sprites are just going to be
textures handled by OpenGL.

00:31:17.310 --> 00:31:19.200
So we'll load the sprite frames
and store them in textures.

00:31:19.200 --> 00:31:22.200
Well what are we going to do for sprites
that have multiple images in them?

00:31:22.200 --> 00:31:25.200
Most people who want to use sprites want
to handle multiple images in one sprite.

00:31:25.200 --> 00:31:28.100
Even if you want an animated cursor,
for example, how would you do that?

00:31:28.190 --> 00:31:31.510
What you can simply do is have one
texture that fits all of your sprites

00:31:31.590 --> 00:31:32.200
or some of your sprites in there.

00:31:32.200 --> 00:31:36.260
And you can set it up so that your
sprite frames are offset and you

00:31:36.260 --> 00:31:40.200
use the texture coordinates to
offset into those sprite frames.

00:31:40.200 --> 00:31:42.210
So you load the whole thing in one
texture and instead of like we did

00:31:42.210 --> 00:31:46.200
before where you're loading a segmented,
that one image into a segmented texture,

00:31:46.200 --> 00:31:49.220
you're loading one texture and
then using it as a segment,

00:31:49.250 --> 00:31:53.200
in segments by using texture coordinates
every time you go to a polygon.

00:31:53.200 --> 00:31:56.490
For example, if you had a polygon,
if you had ten sprites,

00:31:56.490 --> 00:32:00.370
you would use a tenth of the texture
coordinates for that one sprite and

00:32:00.370 --> 00:32:04.200
you can maneuver across depending on
what sprite frame you're talking about.

00:32:04.200 --> 00:32:06.530
One thing you can also,
most people want to do with sprites is

00:32:06.570 --> 00:32:08.200
they want to use some kind of masking.

00:32:08.200 --> 00:32:10.200
I want to use a mask.

00:32:10.200 --> 00:32:12.860
They don't want to have just that cursor,
just my cool animated cursor

00:32:12.860 --> 00:32:14.200
spinning around or whatever.

00:32:14.200 --> 00:32:16.200
They want to use some kind of masking.

00:32:16.200 --> 00:32:18.200
So how do you do that?

00:32:18.200 --> 00:32:20.630
Well, you can easily do it by passing
an alpha channel or if you

00:32:20.630 --> 00:32:24.200
read an image from QuickTime,
you may not be sure of the alpha channel.

00:32:24.200 --> 00:32:26.090
You may not be sure that's the
exact alpha channel you want.

00:32:26.200 --> 00:32:29.150
So you want to go in there and blast
the alpha bits as something you know.

00:32:29.230 --> 00:32:32.200
In this case, I used a background color,
pure green,

00:32:32.200 --> 00:32:35.300
and I looked for it basically to
the green screen kind of thing and

00:32:35.300 --> 00:32:38.200
I just removed the green screen
by setting alpha of that to zero.

00:32:38.200 --> 00:32:38.200
I did this a couple times.

00:32:38.200 --> 00:32:38.200
And the first time I did it, I was like,
"Oh,

00:32:38.200 --> 00:32:38.200
I'm going to do this." And I was like,
"Oh, I'm going to do this."

00:32:38.200 --> 00:32:40.200
I did this a couple times.

00:32:40.200 --> 00:32:43.020
And the first time I did it,
I came out with what's on your

00:32:43.020 --> 00:32:46.100
right-hand side here with that
little green line around it.

00:32:46.230 --> 00:32:49.190
It was a pretty cool little effect,
but again, texture filtering.

00:32:49.200 --> 00:32:50.950
That is because it looked
at the next pixel and says,

00:32:51.000 --> 00:32:52.200
"Ah, I know there's green there.

00:32:52.200 --> 00:32:55.480
You want me to filter from that
green onto your image and that's

00:32:55.530 --> 00:32:59.060
what I'm going to give you." So what
you can do is the other image,

00:32:59.060 --> 00:33:01.660
what I did was I said,
"I'll put kind of a neutral gray in

00:33:01.660 --> 00:33:06.200
there." And the neutral gray allowed
me to filter it to a reasonable color.

00:33:06.200 --> 00:33:06.200
So that's something to just keep
in mind when you're doing it.

00:33:06.200 --> 00:33:09.200
Something that OpenGL will
want to filter that.

00:33:09.200 --> 00:33:13.200
And it will use both filtering on alpha
and filtering in the image domain.

00:33:13.230 --> 00:33:15.580
So you want to make sure your
filtering is set up correctly

00:33:15.790 --> 00:33:17.160
if you're using an alpha mask.

00:33:19.550 --> 00:33:22.180
So let's talk about how to do alpha mask.

00:33:22.180 --> 00:33:24.760
Basically, you want to set the
alpha channel on load.

00:33:24.760 --> 00:33:27.710
You want to look at the alpha channel
once you load it with QuickTime,

00:33:27.710 --> 00:33:29.580
and you want to blast the
exact bits you want into it.

00:33:29.580 --> 00:33:32.620
In this case, we're talking about the top
eight bits in 32-bit format,

00:33:32.620 --> 00:33:34.520
or the top one bit in a 16-bit format.

00:33:34.580 --> 00:33:36.680
If you wanted to,
you can use other formats, by the way.

00:33:36.680 --> 00:33:37.860
I'm not limiting you to these.

00:33:37.910 --> 00:33:40.180
These are just something
that I'm using for the talk.

00:33:40.210 --> 00:33:42.160
But you could use a 444 format.

00:33:42.160 --> 00:33:43.880
OpenGL would understand that,
which would give you the four

00:33:43.880 --> 00:33:48.100
bits of alpha in a 16-bit
representation of colors.

00:33:48.400 --> 00:33:52.240
Basically, background color pixels,
we're going to set the alpha to zero.

00:33:52.240 --> 00:33:56.320
And we're going to set the
pixel value of those pixels to

00:33:56.320 --> 00:33:59.050
some neutral background color.

00:33:59.470 --> 00:34:01.150
For all other pixels,
we're going to make sure

00:34:01.150 --> 00:34:02.230
the pixel is set to alpha.

00:34:02.310 --> 00:34:07.640
So in this case, in the 16-bit case,
we'll OR that with 8,000 hex.

00:34:07.690 --> 00:34:10.620
And in the 32-bit case,
we'll set the two high bits to

00:34:10.620 --> 00:34:14.000
FF to basically make sure they're
all ones in the two high bits.

00:34:14.030 --> 00:34:15.130
You want to ensure the alpha is set.

00:34:15.240 --> 00:34:17.800
Because sometimes,
depending on where the image comes from,

00:34:17.800 --> 00:34:20.260
I've seen images that I thought
out of Photoshop that I had

00:34:20.340 --> 00:34:21.250
set the alpha correctly.

00:34:21.430 --> 00:34:22.200
And it comes through a format.

00:34:22.200 --> 00:34:24.640
And when I look at it coming
through into the machine,

00:34:24.640 --> 00:34:26.500
the alpha is not set like
I would expect it to.

00:34:26.500 --> 00:34:29.590
So just make sure you keep that in mind,
that you have a known

00:34:29.590 --> 00:34:32.040
source of your alpha,
or you're setting it into

00:34:32.040 --> 00:34:33.700
what you want to set them to.

00:34:33.830 --> 00:34:34.800
So, how do we do this?

00:34:34.800 --> 00:34:36.560
It's actually pretty simple.

00:34:36.560 --> 00:34:39.550
If it's a 32-bit image what we're going
to do is we're going to get the pixel

00:34:39.550 --> 00:34:41.070
from the image buffer we saw before.

00:34:41.070 --> 00:34:43.920
We're going to step through
for texture width and texture

00:34:43.920 --> 00:34:45.560
height through the whole thing.

00:34:45.560 --> 00:34:48.900
We're only going to look at the
bits that are our color mask.

00:34:48.900 --> 00:34:50.600
In this case I'm saying green.

00:34:50.780 --> 00:34:53.460
FF in 32-bit format is our color mask.

00:34:53.460 --> 00:34:57.100
So, what I'm doing is I want to
ignore the alpha on these bits.

00:34:57.100 --> 00:34:59.010
I don't want to compare to 00, 00, FF.

00:34:59.010 --> 00:35:00.780
I don't want to compare to all 32 bits.

00:35:00.780 --> 00:35:02.540
I only want to compare
to the 24 bits of color.

00:35:02.620 --> 00:35:04.180
So, I'm not sure about that alpha.

00:35:04.180 --> 00:35:06.250
So,
I may have a difference in alpha and it

00:35:06.250 --> 00:35:08.140
won't quite match my source color key.

00:35:08.140 --> 00:35:09.470
So, I'm going to look at the color bits.

00:35:09.470 --> 00:35:12.830
So, I'm going to mask those color bits
out and if they equal that pure

00:35:12.940 --> 00:35:17.380
green I'm going to set the pixel to
a reasonable gray in this case with

00:35:17.580 --> 00:35:19.270
a 00 in the high bits for alpha.

00:35:19.370 --> 00:35:23.250
So, it will be blank and the
filtering will look good.

00:35:23.310 --> 00:35:25.250
If not, I'm going to OR that with FF.

00:35:25.430 --> 00:35:27.770
And the reason I'm going to OR it
with FF is to make sure that those

00:35:27.770 --> 00:35:29.780
two alpha bits are set at the top.

00:35:29.780 --> 00:35:30.160
Or eight alpha bits.

00:35:30.200 --> 00:35:31.430
So, there's two in hex.

00:35:31.720 --> 00:35:33.710
Two digits are set for alpha.

00:35:33.800 --> 00:35:36.420
And then I'm going to loop
through the next pixel.

00:35:36.420 --> 00:35:40.500
For the 16 bit case, very similar,
in this case I'm going to compare it to

00:35:40.500 --> 00:35:46.680
the 7FFF to mask out that one alpha bit
and make sure that 3 is 0 which is the

00:35:46.710 --> 00:35:50.650
same five bits of set for the green.

00:35:50.650 --> 00:35:55.390
I set it to a neutral
gray or set the top alpha

00:35:56.570 --> 00:35:57.620
So let's talk about alpha blending.

00:35:57.620 --> 00:35:58.570
So there's another way.

00:35:58.580 --> 00:36:00.030
You say now you have the sprite mask.

00:36:00.140 --> 00:36:01.500
You have your cursor
that you move around.

00:36:01.500 --> 00:36:02.880
You've cut out the background in.

00:36:02.880 --> 00:36:04.080
We're going to talk about alpha blending.

00:36:04.080 --> 00:36:06.690
Another thing you may want to have
is some kind of transparent texture,

00:36:06.740 --> 00:36:09.020
some kind of feature, some kind of,
you know,

00:36:09.020 --> 00:36:10.680
you have the heads-up display in a game.

00:36:10.680 --> 00:36:12.470
You want to just use
that with alpha mask.

00:36:12.560 --> 00:36:14.320
Real simple to set up an alpha mask.

00:36:14.430 --> 00:36:15.970
In this case,
what I'm going to do is I'm going

00:36:15.970 --> 00:36:19.390
to use the luminance value of
this texture to set an alpha mask.

00:36:19.660 --> 00:36:21.040
That's what this is an example of here.

00:36:21.040 --> 00:36:23.320
What I'm going to do is I'm
going to take the average,

00:36:23.320 --> 00:36:26.110
which is actually I'll correct
myself before anyone else does.

00:36:26.340 --> 00:36:27.870
This is not actually the luminance value.

00:36:27.880 --> 00:36:30.440
This is my poor man's luminance value.

00:36:30.440 --> 00:36:32.640
If you want to really do
the YUV conversion and

00:36:32.640 --> 00:36:35.510
just take the Y component,
you should do a correct YUV conversion.

00:36:35.520 --> 00:36:37.680
But in this case,
I'm going to assume this is grayscale.

00:36:37.680 --> 00:36:38.550
All the bits are the same.

00:36:38.560 --> 00:36:40.660
And so really the divide
by three is not necessary,

00:36:40.660 --> 00:36:42.100
but it looks good for the presentation.

00:36:44.370 --> 00:36:48.360
So,
we take our poor man's luminance value,

00:36:48.360 --> 00:36:52.250
we divide by three to
get the average for 2.55,

00:36:52.250 --> 00:36:53.800
we're going to shift it up
into the high bit and we're

00:36:53.860 --> 00:36:55.200
going to or it into the pixel.

00:36:55.200 --> 00:36:57.280
So in this case,
what we're going to say is

00:36:57.520 --> 00:37:00.200
whatever the kind of gray
scale value of that pixel is,

00:37:00.200 --> 00:37:00.670
is going to be the alpha.

00:37:00.730 --> 00:37:03.190
So we'll get transparency that
varies with the luminance.

00:37:03.250 --> 00:37:06.200
This is good if you get some
artist that has some kind of

00:37:06.200 --> 00:37:09.570
background or something like that,
that you just want the luminance value,

00:37:09.570 --> 00:37:12.800
you want to set an alpha that equals it,
you can use this kind of technique.

00:37:14.410 --> 00:37:15.450
How do you draw with these things?

00:37:15.570 --> 00:37:18.800
What are the key open GL,
the unlock the open GL kingdom here?

00:37:18.800 --> 00:37:21.110
We get GL alpha funk.

00:37:21.270 --> 00:37:23.260
What I do here, this is the masking.

00:37:23.320 --> 00:37:26.340
We talk about the alpha mask,
the first thing we talked about.

00:37:26.340 --> 00:37:29.360
In this case, we're going to say greater
than .5 or less than .5.

00:37:29.460 --> 00:37:31.660
If it's greater than .5,
we're going to draw it if

00:37:31.660 --> 00:37:33.100
it's less than .5 or not.

00:37:33.200 --> 00:37:34.670
In this case,
when we set everything to zero,

00:37:34.670 --> 00:37:35.560
we won't draw anything.

00:37:35.560 --> 00:37:36.840
When we set it to one, we will draw.

00:37:36.840 --> 00:37:41.360
If our polygon needs alpha test
or if our sprite needs alpha test,

00:37:41.360 --> 00:37:43.340
we'll turn alpha test on.

00:37:44.460 --> 00:37:46.750
For blending for transparency,
we use a blend funk.

00:37:46.810 --> 00:37:49.190
In this case, we'll use source alpha and
one minus source alpha.

00:37:49.280 --> 00:37:52.910
Basically, let's say the contribution of
the front pixel is source alpha.

00:37:53.010 --> 00:37:54.870
It's the source's alpha value.

00:37:54.870 --> 00:37:58.660
The contribution of whatever is
there already is one minus that.

00:37:58.660 --> 00:38:00.970
If your alpha is .8,
you can see the source

00:38:00.970 --> 00:38:02.290
is 80% contributor.

00:38:02.310 --> 00:38:04.840
The background is about 20% contributor.

00:38:04.840 --> 00:38:08.500
We enable blending.

00:38:09.840 --> 00:38:13.360
If we have transparency.

00:38:13.390 --> 00:38:15.400
Lastly, depth test.

00:38:15.410 --> 00:38:16.600
You may want to do a depth test.

00:38:16.600 --> 00:38:19.390
So if you have multiple pixels--

00:38:19.500 --> 00:38:36.500
[Transcript missing]

00:38:37.420 --> 00:38:41.380
So let's talk a little bit
about how to do a side scroller.

00:38:41.420 --> 00:38:43.360
Most people,
when we think of side scrollers,

00:38:43.360 --> 00:38:50.760
we think of like 1400 by 480 kind of
backgrounds that you play Defender

00:38:50.760 --> 00:38:55.830
on or run around in your 2D version
of Quake or whatever you're doing.

00:38:56.170 --> 00:39:00.980
And most people think of using
a 2D raster engine to move these

00:39:00.980 --> 00:39:03.070
things around to the screen
because we can compact it down,

00:39:03.070 --> 00:39:05.840
we have a lot of black space,
we can use the parallax scrolling.

00:39:05.840 --> 00:39:09.000
I'm saying you can use OpenGL to
get a much faster version of this

00:39:09.000 --> 00:39:10.590
with a lot less limitations on you.

00:39:10.600 --> 00:39:13.960
What we're going to do is we
use tiled images to form a

00:39:13.960 --> 00:39:15.200
large textured background.

00:39:15.200 --> 00:39:15.980
Pretty unlimited.

00:39:15.980 --> 00:39:17.060
You can even load the tiles.

00:39:17.060 --> 00:39:19.360
And I mean if you think of
something like Diablo 2,

00:39:19.390 --> 00:39:21.750
it actually was a similar
method where it loaded terrain,

00:39:21.760 --> 00:39:23.700
loaded sprites as it needed to.

00:39:23.700 --> 00:39:26.970
It was a forced perspective
kind of 2.5D thing,

00:39:26.970 --> 00:39:30.910
but in reality it was still kind of
the same idea of using an accelerated

00:39:30.910 --> 00:39:34.560
engine to drive something that
could have been done years ago.

00:39:34.560 --> 00:39:38.540
would attempt to be done
years ago with a 2D engine.

00:39:39.200 --> 00:39:41.340
So we use the grid of
polygons for the background.

00:39:41.400 --> 00:39:44.520
And there's a lot of different
ways to draw the grid of polygons.

00:39:44.520 --> 00:39:45.300
We toyed around with it.

00:39:45.410 --> 00:39:46.800
We've been talking about it.

00:39:46.810 --> 00:39:50.120
And there's some different kind of
techniques you can use as far as deciding

00:39:50.120 --> 00:39:53.060
what's on the screen and off the screen,
depending on your limitations.

00:39:53.140 --> 00:39:54.980
So I'm not going to try and
tell you exactly how to do that,

00:39:55.070 --> 00:39:58.200
because I found out that
depending on what your limitations

00:39:58.200 --> 00:40:00.970
are of your application,
you can find some ways are really

00:40:00.970 --> 00:40:02.540
easy and some ways are very difficult.

00:40:02.570 --> 00:40:04.730
The idea here, though,
is that you keep a grid of polygons.

00:40:04.790 --> 00:40:06.980
You're going to draw something
slightly bigger than the screen,

00:40:06.990 --> 00:40:09.900
or make sure you draw the polygons that
are actually present on the screen.

00:40:09.930 --> 00:40:12.560
And you're going to draw the ones
you need to as the person moves,

00:40:12.560 --> 00:40:14.510
whether it's north, south, east, or west.

00:40:14.610 --> 00:40:15.870
When they move that way,
you're going to draw

00:40:15.890 --> 00:40:17.810
some additional polygons.

00:40:18.110 --> 00:40:19.640
Basically,
when you draw the gridded polygons,

00:40:19.680 --> 00:40:20.890
you're going to find out
what your world center is.

00:40:20.900 --> 00:40:23.010
In this case,
we just attach it to a sprite,

00:40:23.010 --> 00:40:25.730
and we pick that sprite's world center,
and we offset everything

00:40:25.730 --> 00:40:26.590
else by that world center.

00:40:26.710 --> 00:40:30.490
So everything else just moves
off the screen as it would.

00:40:30.500 --> 00:40:32.770
So you don't have to worry
about some kind of strange

00:40:33.140 --> 00:40:34.990
transform you're writing yourself.

00:40:35.000 --> 00:40:39.450
Just use OpenGL's model view matrix and
transform it as you would with the world

00:40:39.450 --> 00:40:41.950
center attached to one of your sprites.

00:40:42.070 --> 00:40:43.530
We're going to rotate
it by world rotation.

00:40:43.530 --> 00:40:45.570
So if your sprite rotates,
you can rotate the entire world,

00:40:45.570 --> 00:40:48.000
or you can rotate your sprite,
whichever way you'd like to do it.

00:40:48.000 --> 00:40:51.720
So there's no limitation that everything
has to be kind of orthographically

00:40:51.720 --> 00:40:54.630
displayed across your screen,
which, I mean, if you're thinking about

00:40:54.630 --> 00:40:56.660
it from a 2D standpoint,
I'm not thinking that it's going

00:40:56.660 --> 00:41:01.000
to be real easy to take a 1400 by
480 image and turn it slightly.

00:41:01.000 --> 00:41:02.860
OpenGL can do that for you,
as we've seen.

00:41:03.000 --> 00:41:04.340
And you're going to scale by world scale.

00:41:04.360 --> 00:41:06.000
Most of the time,
you can't zoom in and zoom out.

00:41:06.000 --> 00:41:07.810
In this case,
you can zoom in and zoom out.

00:41:08.100 --> 00:41:10.340
Or you could draw your little
radar map up in the corner

00:41:10.390 --> 00:41:12.000
of your game or application.

00:41:12.030 --> 00:41:16.070
Or showing how you're manipulating
a large image by just showing a

00:41:16.070 --> 00:41:21.000
scaled version using mipmaps of that
larger texture you've already drawn.

00:41:23.460 --> 00:41:27.180
So how do we handle textures?

00:41:27.190 --> 00:41:30.580
You load the background as one
texture or a set of textures.

00:41:30.600 --> 00:41:34.400
But basically you load a large
image as a single large texture.

00:41:34.460 --> 00:41:36.410
You're going to segment it with
the techniques we've shown before.

00:41:36.410 --> 00:41:40.400
And you're going to let OpenGL do
the texture handling for you.

00:41:40.400 --> 00:41:43.350
We use GenTextures to generate
texture lists as we've seen before.

00:41:43.400 --> 00:41:47.890
And we'll let OpenGL handle the
memory management in and out of

00:41:47.990 --> 00:41:50.400
VRAM or in and out of the AGP space.

00:41:50.400 --> 00:41:54.900
Because the OpenGL implementation on 10
does a very good job of handling AGP and

00:41:54.980 --> 00:41:57.400
it's going to get better in the future.

00:41:57.400 --> 00:42:00.400
And you really should take
advantage of that fact.

00:42:00.400 --> 00:42:03.040
Instead of trying to have
your own what's in memory,

00:42:03.040 --> 00:42:05.440
what's not in memory,
what's load something,

00:42:05.440 --> 00:42:08.400
what's remove something,
just let it handle it for you.

00:42:08.400 --> 00:42:10.400
It'll push things out you're not using.

00:42:10.400 --> 00:42:12.390
It'll bring things in that you need.

00:42:12.390 --> 00:42:14.390
And I think you'll find it'll
be very effective in managing

00:42:14.390 --> 00:42:15.300
those textures for you.

00:42:15.400 --> 00:42:18.400
And this is again the same
as your segmented images.

00:42:18.400 --> 00:42:21.210
This is exactly the same technique
we've talked about before.

00:42:23.590 --> 00:42:24.760
So how do you draw this?

00:42:25.040 --> 00:42:27.940
In my case,
I set up an orthographic context.

00:42:27.980 --> 00:42:30.200
I thought about it later and I thought
it would be really cool that you

00:42:30.200 --> 00:42:33.500
could use a perspective context
actually for your side scroller.

00:42:33.500 --> 00:42:36.250
And when you zoomed in and zoomed out,
it actually would have

00:42:36.430 --> 00:42:38.500
that kind of parallax,
weird zooming.

00:42:38.540 --> 00:42:39.500
But I didn't have time to do that.

00:42:39.500 --> 00:42:40.490
But that's something to think about.

00:42:40.500 --> 00:42:44.560
So, I mean, if you really don't have to
set up an orthographic context,

00:42:44.560 --> 00:42:48.080
you can say, think about it as your art
workbench where you're looking

00:42:48.080 --> 00:42:51.500
straight down at one of those,
you know, camera mounted above a table.

00:42:51.500 --> 00:42:54.440
You actually can change
or use the GL you look at.

00:42:54.630 --> 00:42:56.430
And you can change the field
of view and the aspect.

00:42:56.510 --> 00:42:57.910
If you want to zoom in,
you just change your

00:42:57.910 --> 00:42:58.500
field of view to be wider.

00:42:58.500 --> 00:43:00.500
You want to zoom out,
you change it to be narrower.

00:43:00.500 --> 00:43:03.350
You change your near and far planes.

00:43:03.500 --> 00:43:07.070
And that kind of thing you can do and
gives you a lot of the features that

00:43:07.070 --> 00:43:11.490
you really would work hard for doing
it yourself with your own 2D engine.

00:43:11.500 --> 00:43:15.460
You can give it to you with
hardware acceleration in OpenGL.

00:43:16.070 --> 00:43:17.270
In this case,
we're going to pin the world

00:43:17.270 --> 00:43:18.160
to a sprite of interest.

00:43:18.220 --> 00:43:19.800
Here's another good thing you can do.

00:43:19.800 --> 00:43:24.320
Let's say you have some kind of
strategy game or something that you

00:43:24.320 --> 00:43:25.600
have multiple places of interest.

00:43:25.700 --> 00:43:27.430
You have a very large
document you're handling.

00:43:27.500 --> 00:43:31.330
The user can jump to an area
of interest very easily by just

00:43:31.340 --> 00:43:34.170
manipulating the center of that image.

00:43:34.170 --> 00:43:36.700
Do a lookup of your sprite
information or do a lookup of

00:43:36.700 --> 00:43:38.450
information into your document.

00:43:38.520 --> 00:43:40.350
You can jump to this
object on my document.

00:43:40.350 --> 00:43:42.460
I want to see how it's
positioned in my preview.

00:43:42.830 --> 00:43:46.540
They can do that basically by using
readout where that position is and

00:43:46.750 --> 00:43:49.860
offset to that position without having
to do some kind of calculation or having

00:43:49.860 --> 00:43:51.500
to move a lot of pixels around yourself.

00:43:51.500 --> 00:43:55.220
What I did was to draw the sprites,
I basically do a--you kind of grossly

00:43:55.220 --> 00:43:57.410
call the sprites to your visible list.

00:43:57.520 --> 00:44:00.080
You don't want to send OpenGL every
single sprite that's off the

00:44:00.300 --> 00:44:01.500
screen in your massive area.

00:44:01.540 --> 00:44:04.800
But you grossly call the ones
you think are close to visible.

00:44:04.800 --> 00:44:06.500
Let OpenGL do the fine work.

00:44:06.500 --> 00:44:06.920
You may find if you spend
way too much time on this,

00:44:06.920 --> 00:44:07.500
you may find that you're not
going to get the results you want.

00:44:07.500 --> 00:44:07.500
You may find if you spend
way too much time on this,

00:44:07.500 --> 00:44:07.500
you may find that you're not
going to get the results you want.

00:44:07.500 --> 00:44:10.450
if you spend way too much time trying
to replicate the transformations,

00:44:10.480 --> 00:44:12.700
trying to figure out exactly what's
on the screen and off the screen,

00:44:12.700 --> 00:44:14.070
you're spending a lot of time doing that.

00:44:14.120 --> 00:44:19.820
One thing I'll tout here is the
OpenGL optimization session tomorrow

00:44:19.820 --> 00:44:23.260
with John Stoffel will look very closely
at what OpenGL can do for you and what

00:44:23.270 --> 00:44:25.400
it can't do as far as optimizations.

00:44:25.400 --> 00:44:28.740
So come to that session,
look at his example of optimization,

00:44:28.740 --> 00:44:30.400
and apply it to your same application.

00:44:30.400 --> 00:44:33.950
Make sure you know in real time
what percentage of time you're

00:44:33.950 --> 00:44:36.600
in your application and what
percentage of time you're in OpenGL.

00:44:37.110 --> 00:44:39.590
Null out those drawing routines
and find out if you run

00:44:39.590 --> 00:44:42.240
your application open loop,
what actually is your

00:44:42.240 --> 00:44:43.530
possible frame rate.

00:44:43.560 --> 00:44:47.100
A lot of times you'll find that you're
not really spending much time in OpenGL.

00:44:47.100 --> 00:44:48.720
You're spending a lot of
time in your application.

00:44:48.750 --> 00:44:50.670
It doesn't matter how fast
the graphics engine is,

00:44:50.720 --> 00:44:52.540
you're going to have to
improve your application speed.

00:44:54.420 --> 00:44:57.440
Gain a strong understanding
of the design and construction

00:44:57.440 --> 00:45:00.930
of optimized image display,
sprite, and live scrolling engines

00:45:00.930 --> 00:45:02.290
using the OpenGL API.

00:45:08.520 --> 00:45:14.300
I'll open my sprite file.

00:45:14.410 --> 00:45:15.200
There's a couple sprites here.

00:45:15.200 --> 00:45:19.900
I think the background
image is 2000 by 1600.

00:45:19.940 --> 00:45:22.580
I have another texture in
there that's 1000 by 1000,

00:45:22.580 --> 00:45:23.220
both 32 bit.

00:45:23.270 --> 00:45:28.840
And then I have my sprite images which
are also they're actually 256 by 256 and

00:45:28.900 --> 00:45:30.800
I just used a scaling of OpenGL to do it.

00:45:30.880 --> 00:45:33.850
So we're going to run around
and see what this thing can do.

00:45:33.960 --> 00:45:37.820
So as you can see I can move
the rocket back and forth.

00:45:37.850 --> 00:45:40.690
I can fly around very easily.

00:45:42.100 --> 00:45:45.040
And we can zoom in or we can zoom out.

00:45:45.040 --> 00:45:48.140
Real nice that you get a nice feedback.

00:45:48.140 --> 00:45:51.440
And if I can do this right,
I probably can find Apple on here.

00:45:51.440 --> 00:45:57.080
This happens to be a
photograph of Cupertino.

00:45:57.080 --> 00:46:00.610
Let me see if I can do this.

00:46:00.620 --> 00:46:02.240
Where am I?

00:46:02.240 --> 00:46:04.760
Oh, up, up, up.

00:46:04.760 --> 00:46:06.480
I think we're up there.

00:46:09.980 --> 00:46:11.560
No, can't find Apple.

00:46:11.640 --> 00:46:12.460
I'll find it later.

00:46:12.510 --> 00:46:14.170
In any case,
you can see what I did here for

00:46:14.170 --> 00:46:15.410
the poor man's version of tiling.

00:46:15.420 --> 00:46:16.700
I flipped the image.

00:46:16.800 --> 00:46:19.680
And I just used OpenGL to
do the same image.

00:46:19.740 --> 00:46:20.420
You can zoom in.

00:46:20.420 --> 00:46:21.360
You can see that.

00:46:21.430 --> 00:46:23.380
And we got the cloud layer there.

00:46:23.510 --> 00:46:28.000
So we have a nice layer of
clouds that's flying over it.

00:46:28.050 --> 00:46:30.800
One thing you can do is this
is your standard side scroller.

00:46:30.800 --> 00:46:33.000
You kind of fly around
and scroll side to side.

00:46:33.040 --> 00:46:37.620
One thing you can do also is you
can do this very easily in OpenGL,

00:46:37.620 --> 00:46:38.640
which works the same.

00:46:38.640 --> 00:46:40.360
It's doing the same amount of work.

00:46:40.500 --> 00:46:48.230
So I can fly around, in this case,
in my standard method of the top is up.

00:46:49.960 --> 00:46:55.120
have a pretty convincing game and
make you all sick at the same time.

00:46:55.300 --> 00:46:58.280
So we'll go back to the presentation now.

00:47:04.300 --> 00:47:07.140
And the last thing we're going to
talk about is QuickTime integration.

00:47:07.140 --> 00:47:08.230
How do you integrate QuickTime?

00:47:08.300 --> 00:47:10.300
And I have about 10 minutes,
and I think I can get through this.

00:47:10.300 --> 00:47:12.300
A lot of this we've talked about already.

00:47:12.300 --> 00:47:13.300
Same techniques.

00:47:13.300 --> 00:47:15.300
This whole thing is using
the same techniques.

00:47:15.300 --> 00:47:16.300
It's all based on the same stuff.

00:47:16.300 --> 00:47:17.360
It's not rocket science.

00:47:17.360 --> 00:47:18.360
It's not separate stuff.

00:47:18.440 --> 00:47:21.190
You learn some of this stuff once
and apply it to all these techniques.

00:47:21.300 --> 00:47:22.340
Qt New GWO from Poynter.

00:47:22.340 --> 00:47:24.300
We've seen that at
least three times today.

00:47:24.300 --> 00:47:27.800
That is how you're going to allocate
the texture to get a packed texture

00:47:27.890 --> 00:47:34.070
format without having any extra space
to help not allow you to texture.

00:47:34.290 --> 00:47:37.300
We're going to use packed pixels
for direct texture handling.

00:47:37.300 --> 00:47:41.300
We're going to synchronize to
QuickTime to minimize our update.

00:47:41.510 --> 00:47:45.400
What that means is we're going to give
a callback procedure to QuickTime to

00:47:45.400 --> 00:47:46.950
tell us when it updated the frame.

00:47:46.950 --> 00:47:50.260
If we haven't updated the frame,
we're not going to update the texture.

00:47:50.400 --> 00:47:52.660
What this means is the only
textures uploaded to the card are

00:47:52.660 --> 00:47:54.290
the ones that actually got updated.

00:47:54.300 --> 00:47:56.370
You can see, obviously,
if you upload the frame

00:47:56.370 --> 00:47:58.300
every single time,
it's like playing an uncompressed game.

00:47:58.300 --> 00:48:01.850
You can see how that can compare to a
compressed movie where you're only really

00:48:01.850 --> 00:48:03.300
updating the frame every time it changes.

00:48:03.300 --> 00:48:07.300
If you have an OpenGL that
can do 100 frames per second

00:48:07.300 --> 00:48:09.300
and QuickTime is updating the
movie at 24 frames per second,

00:48:09.310 --> 00:48:11.300
there's no reason to update that texture.

00:48:11.300 --> 00:48:15.270
Let the texture sit in VRAM and then
only update it when you need to.

00:48:15.300 --> 00:48:22.120
Drawing, we're going to use subtext
image to--that's wrong.

00:48:22.290 --> 00:48:23.140
...maybe wrong.

00:48:23.190 --> 00:48:27.400
In any case,
we're going to do a subtexture upload.

00:48:27.650 --> 00:48:32.200
The movies usually are not
256 by 256 or 512 by 512.

00:48:32.200 --> 00:48:35.200
They're usually a 4 by 3,
which is usually not the texture size.

00:48:35.200 --> 00:48:42.290
So we're going to take the subtexture
out of that and we're only going to

00:48:42.290 --> 00:48:42.290
update the part that's actually updated.

00:48:42.290 --> 00:48:42.290
Again, saving bandwidth to the card.

00:48:43.200 --> 00:48:45.540
So, what are we going to do here?

00:48:45.580 --> 00:48:46.770
New pointer clear, we've seen that.

00:48:46.940 --> 00:48:49.340
Qt New GWorld from pointer,
we've seen that.

00:48:49.460 --> 00:48:52.060
Set GWorld, set Movie GWorld,
we haven't seen that.

00:48:52.060 --> 00:48:54.980
So all you're going to do
here is set the Movie GWorld,

00:48:55.030 --> 00:48:57.450
same as we did with the
graphics compressor,

00:48:57.450 --> 00:49:00.500
and that will tell the movie
to play into that GWorld.

00:49:02.900 --> 00:49:04.230
Texture formats.

00:49:04.330 --> 00:49:05.170
Pretty simple.

00:49:05.390 --> 00:49:09.930
GeoText Image 2D, RGB,
that would be an uncompressed format,

00:49:09.940 --> 00:49:14.570
and then you have the reversed format
showing the actual packed pixel format.

00:49:16.670 --> 00:49:17.590
QuickTime synchronization.

00:49:17.600 --> 00:49:18.600
Here's something new.

00:49:18.600 --> 00:49:22.680
You look up there, you see MovieDrawUPP.

00:49:22.680 --> 00:49:24.570
That's going to give you a universal
procedure pointer to a movie,

00:49:24.700 --> 00:49:26.600
to the movie completion procedure.

00:49:26.730 --> 00:49:29.710
New movie completion procedure,
so you're actually creating

00:49:29.710 --> 00:49:30.880
it with my MovieDraw proc.

00:49:31.270 --> 00:49:34.420
And then you're going to set the
procedure very simply for the movie.

00:49:34.420 --> 00:49:36.510
Gmovie is actually the
pointer to your movie,

00:49:36.630 --> 00:49:38.930
so that's something
you get from QuickTime.

00:49:39.420 --> 00:49:44.040
and then in your completion proc,
oh sorry, if you look at the call it says

00:49:44.040 --> 00:49:45.910
movie drawing call when changed.

00:49:45.910 --> 00:49:49.310
So it's going to call you every time
it updates that movie into the G world.

00:49:49.470 --> 00:49:51.290
So QuickTime will tell you
when it has something changed.

00:49:51.290 --> 00:49:54.430
This is the only code you have
to do to let QuickTime know

00:49:54.430 --> 00:49:55.760
when you've actually updated it.

00:49:55.880 --> 00:50:00.000
You can see this could actually be
very useful in some other things

00:50:00.040 --> 00:50:03.420
that use QuickTime so you know when
there's actually something changed

00:50:03.420 --> 00:50:03.420
in the movie and you're not trying
to update something all the time.

00:50:03.810 --> 00:50:05.500
And then the movie draw proc,
really simply.

00:50:05.520 --> 00:50:08.900
All I'm going to do is, in the RefCon,
I have a global variable,

00:50:08.970 --> 00:50:12.230
gfMovieTextUpdate,
and I'm going to set that to true

00:50:12.680 --> 00:50:14.080
every time I get to that procedure.

00:50:14.200 --> 00:50:18.500
So when I go down to draw my polygon,
I'll get all ready to draw and I'll say,

00:50:18.500 --> 00:50:19.750
do I need to update the texture?

00:50:19.770 --> 00:50:22.500
If I do, I'll re-update the texture
from the movie G World.

00:50:22.550 --> 00:50:25.030
If not, I'll just draw the
polygon with the texture.

00:50:25.160 --> 00:50:28.470
You can use the idea of current textures,
because you can bind it

00:50:28.520 --> 00:50:29.360
to any texture you want.

00:50:29.410 --> 00:50:31.220
You can have multiple movies playing.

00:50:31.220 --> 00:50:33.510
You can also, in this case,
the example you'll see,

00:50:33.740 --> 00:50:37.930
I just have one movie, one texture,
so I just leave it current.

00:50:39.460 --> 00:50:40.240
And how do we draw?

00:50:40.240 --> 00:50:42.660
GL text subimage 2D.

00:50:42.660 --> 00:50:43.090
I was right.

00:50:43.110 --> 00:50:43.570
It was wrong.

00:50:43.580 --> 00:50:44.720
It's not subtext images.

00:50:44.720 --> 00:50:45.700
Text subimage 2D.

00:50:45.700 --> 00:50:47.440
GL text subimage 2D.

00:50:47.440 --> 00:50:49.690
You'll see here,
and this basically is the exact

00:50:49.690 --> 00:50:53.500
same thing you've seen before as
far as using the same kind of call.

00:50:53.500 --> 00:50:56.620
You can use the 32-bit
version or the 16-bit version.

00:50:56.620 --> 00:50:58.500
Then I'm going to move the frame.

00:50:58.500 --> 00:51:01.220
What that does is that's just my call
to move the frame around the screen.

00:51:01.220 --> 00:51:02.940
However,
I'm manipulating that QuickTime frame.

00:51:02.940 --> 00:51:04.480
That's only the frame of the polygon.

00:51:04.480 --> 00:51:08.000
I'm using the model
view matrix to do this.

00:51:08.380 --> 00:51:09.120
I'm not doing this.

00:51:09.240 --> 00:51:11.010
This is not manipulating
the movie pixels itself,

00:51:11.010 --> 00:51:11.720
just the frame.

00:51:11.720 --> 00:51:14.820
And then I'm going to do
a GL begin with quads.

00:51:14.910 --> 00:51:17.240
And I'm going to set the texture
coordinates to the corners.

00:51:17.240 --> 00:51:20.020
I'm going to set the color
to white for the whole thing.

00:51:20.020 --> 00:51:23.620
You can colorize your movie if you
wanted to by changing the polygon color.

00:51:23.620 --> 00:51:26.860
And then I'm going to
do very simple vertices.

00:51:26.860 --> 00:51:28.940
Use basically square vertices.

00:51:28.940 --> 00:51:31.760
And the movie is going
to be inside that square.

00:51:31.760 --> 00:51:34.920
Let's go back to this demo.

00:51:41.500 --> 00:51:43.540
I'm going to show you a
couple different things here.

00:51:43.560 --> 00:51:45.910
First, in this case,
we're going to bring out a

00:51:46.040 --> 00:51:48.060
display size of 640 by 480.

00:51:48.060 --> 00:51:50.140
This demo does not use
a segmented texture,

00:51:50.140 --> 00:51:51.780
but you could easily
integrate that into this demo.

00:51:51.780 --> 00:51:54.580
This uses a single texture that
the movie is compressed into.

00:51:54.580 --> 00:51:56.280
256 by 256 movie.

00:51:56.280 --> 00:51:57.940
I'll use a 16-bit off screen.

00:51:58.020 --> 00:51:59.970
Full screen, I will use PacPixels.

00:51:59.980 --> 00:52:03.720
And I will sync to the VBL,
which we'll see how that works on this.

00:52:03.720 --> 00:52:06.660
Actually, let me turn off sync to VBL,
and then we'll turn it

00:52:06.660 --> 00:52:08.220
back on for the next run.

00:52:08.220 --> 00:52:10.040
I'll pick a movie.

00:52:11.600 --> 00:52:12.600
Have you seen this before?

00:52:12.600 --> 00:52:13.500
And Mr.

00:52:13.510 --> 00:52:16.310
Schaffer,
would you prefer window or aisle?

00:52:16.320 --> 00:52:20.600
So I'm getting 620 frames per second
playing that movie through OpenGL.

00:52:20.600 --> 00:52:28.640
It's playing the movie full screen
and then it's texturing as fast

00:52:28.640 --> 00:52:32.740
as it can for a single frame.

00:52:32.740 --> 00:52:35.880
So real simple there.

00:52:35.880 --> 00:52:38.670
Now we'll stay with this demo and we will

00:52:42.040 --> 00:52:43.990
In this case,
we'll just throw some effects in.

00:52:43.990 --> 00:52:46.220
We'll use fog and we'll sync the VBL.

00:52:46.220 --> 00:52:48.000
And we'll just leave it like that.

00:52:48.000 --> 00:52:50.950
And we'll play it in a window this time.

00:52:55.500 --> 00:52:55.920
And Mr.

00:52:55.980 --> 00:52:58.220
Schaefer,
would you prefer window or aisle?

00:52:58.220 --> 00:52:58.720
Middle.

00:52:58.720 --> 00:53:01.250
So again, this is using-- Middle?

00:53:02.500 --> 00:53:03.990
: I'm shooting about
70 frames per second.

00:53:04.000 --> 00:53:07.150
I'm not sure about the sync on this
because it seems to be varying more

00:53:07.170 --> 00:53:10.500
than I normally see because of the
video system that's going through.

00:53:10.500 --> 00:53:12.980
But in any case,
you're seeing just using a simple fog,

00:53:12.980 --> 00:53:14.500
turned on linear fog for this.

00:53:14.500 --> 00:53:16.500
Real simple to show an
effect with a movie.

00:53:16.500 --> 00:53:20.820
You get the full complement of OpenGL,
cool stuff you can do with it

00:53:20.820 --> 00:53:23.500
without having to do any extra work.

00:53:23.500 --> 00:53:25.500
: It's a little movie I'm working on.

00:53:34.790 --> 00:53:36.640
So where do you get resources for this?

00:53:36.670 --> 00:53:37.940
It's pretty simple.

00:53:37.990 --> 00:53:39.400
The Red Book and the Blue Book.

00:53:39.450 --> 00:53:40.900
If you're working with OpenGL,
make sure you've got the

00:53:40.900 --> 00:53:41.700
Red Book and the Blue Book.

00:53:41.700 --> 00:53:45.120
The other thing that I think that
everyone should have is in our

00:53:45.120 --> 00:53:46.620
OpenGL SDK you'll see the spec.

00:53:46.700 --> 00:53:47.700
Look at the spec.

00:53:47.700 --> 00:53:49.700
I use that more than I use
the Red Book and Blue Book.

00:53:49.700 --> 00:53:52.460
If you notice, if you look at the spec,
the Red Book and Blue Book look

00:53:52.520 --> 00:53:53.700
very much like the spec.

00:53:53.700 --> 00:53:56.260
But it has a lot of,
it goes into more math than many

00:53:56.260 --> 00:53:58.830
of us want to know sometimes,
but it actually has the real

00:53:59.240 --> 00:54:01.680
what's behind the engine,
how does it actually work,

00:54:01.790 --> 00:54:04.440
which is real important if you want,
if you're trying to

00:54:04.440 --> 00:54:04.700
debug something like fog.

00:54:04.700 --> 00:54:07.620
You want to know exactly
how the fog's going to work.

00:54:07.800 --> 00:54:09.700
Or you're trying to
look at how the texture,

00:54:09.710 --> 00:54:12.700
the unpacked row length.

00:54:12.700 --> 00:54:14.700
You want a good explanation
of unpacked row length.

00:54:14.700 --> 00:54:16.700
It goes through exactly
how it handles pixels.

00:54:16.700 --> 00:54:19.400
So I think the OpenGL 1.2.1
spec is a very good thing to

00:54:19.400 --> 00:54:21.700
have and all programmers working
with OpenGL should have it.

00:54:21.700 --> 00:54:22.580
It's in our SDK.

00:54:22.690 --> 00:54:23.940
It's in a PDF format.

00:54:23.940 --> 00:54:26.700
You can print it out and,
or look at it online.

00:54:27.700 --> 00:54:30.350
Good places to know if
you're working with OpenGL.

00:54:30.360 --> 00:54:31.590
www.opengl.org.

00:54:31.640 --> 00:54:32.590
A lot of resources.

00:54:32.710 --> 00:54:35.690
It tells you where the
current standard of OpenGL is.

00:54:35.730 --> 00:54:38.050
It gives a complete list of
the extensions for OpenGL.

00:54:38.080 --> 00:54:40.670
It gives you a lot of programming
examples and starter code.

00:54:40.910 --> 00:54:41.820
List.apple.com.

00:54:41.820 --> 00:54:42.770
Search for OpenGL.

00:54:42.770 --> 00:54:44.020
We have an OpenGL Mac list.

00:54:44.020 --> 00:54:45.700
I want to see you all on that list.

00:54:45.700 --> 00:54:48.660
It's a great place to get information,
ask questions,

00:54:48.770 --> 00:54:51.690
and we monitor the list and
try to help out when we can.

00:54:51.700 --> 00:54:53.760
And lastly, developer.apple.com/opengl.

00:54:53.760 --> 00:54:55.120
That's another good place to go.

00:54:55.120 --> 00:54:56.700
All of developer.apple.com.

00:54:56.700 --> 00:54:58.670
All of developer.apple.com URLs.

00:54:58.900 --> 00:55:00.450
Go to the OpenGL page.

00:55:00.750 --> 00:55:03.350
It's a pointer to the SDK,
pointer to the newest

00:55:03.350 --> 00:55:04.610
things we got for it.

00:55:05.970 --> 00:55:08.040
So, what did we talk about today?

00:55:08.040 --> 00:55:11.970
We talked about using
OpenGL mainly for 2D and 2.5D,

00:55:11.970 --> 00:55:15.240
and we did some movie stuff too,
but how OpenGL can be used to

00:55:15.240 --> 00:55:18.600
complement your applications that
aren't interested in doing the next

00:55:18.730 --> 00:55:24.900
Quake or the next Tomb Raider or
the next Nanosaur or Chromag Rally.

00:55:24.900 --> 00:55:27.500
We're talking about games that want
to use just the display images,

00:55:27.560 --> 00:55:29.900
want to use the power of
OpenGL to manipulate those images,

00:55:29.900 --> 00:55:33.870
and it's a really great thing
that you can do it easily.

00:55:34.110 --> 00:55:38.290
You can set up your transforms to let
the transforms handle the workload for

00:55:38.370 --> 00:55:40.890
you and just let OpenGL do the hard work.

00:55:40.900 --> 00:55:43.580
And we will continue to improve OpenGL,
we'll continue to work

00:55:43.660 --> 00:55:45.870
with the hardware vendors,
get the best hardware

00:55:45.870 --> 00:55:47.900
acceleration we can,
and that will give you,

00:55:47.900 --> 00:55:52.680
that will continue to improve your
app even without you doing work on it.

00:55:53.120 --> 00:55:55.300
Next, it does allow robust
hardware acceleration.

00:55:55.300 --> 00:55:57.990
You're not going to get that
any other way you slice it.

00:55:57.990 --> 00:55:59.540
You're not going to be able to
get to the hardware acceleration

00:55:59.540 --> 00:56:03.000
unless you're going to use OpenGL or
use one of our provided APIs.

00:56:03.000 --> 00:56:05.550
You just don't have the resources
and the ability to get at some

00:56:05.550 --> 00:56:09.120
of the hardware acceleration
unless you're writing the drivers,

00:56:09.180 --> 00:56:12.000
unless you're writing the
OpenGL implementation.

00:56:12.140 --> 00:56:14.980
And it really shows you a new paradigm
to solve these real world problems.

00:56:14.980 --> 00:56:18.000
You don't have to say, "Well, hey,
I use copy bits.

00:56:18.000 --> 00:56:20.570
I'm going to rotate that and
I'm going to use that and that's

00:56:20.570 --> 00:56:22.000
going to be really difficult.

00:56:22.000 --> 00:56:25.400
I'll go and swizzle now,
so OpenGL." Rotate

00:56:25.570 --> 00:56:28.160
your model view matrix,
throw it on the screen,

00:56:28.160 --> 00:56:31.000
scale your model view matrix,
throw it on the screen.

00:56:31.000 --> 00:56:33.000
You can shift it over, move it around.

00:56:33.000 --> 00:56:33.960
It's real easy.

00:56:34.010 --> 00:56:35.000
It's just a couple of instructions.

00:56:35.000 --> 00:56:35.870
Sample code.

00:56:35.870 --> 00:56:37.990
The samples will be up very shortly.

00:56:38.190 --> 00:56:40.000
The movie sample is up right now.

00:56:40.000 --> 00:56:42.000
The image sample should be
up by the end of the week.

00:56:42.000 --> 00:56:46.000
And the rocket sample should
be up probably next week.

00:56:48.790 --> 00:56:49.500
Let's talk about the road map.

00:56:49.680 --> 00:56:52.010
Sergio mentioned this is
the first of five sessions.

00:56:52.020 --> 00:56:56.610
The sessions that you want to go to are
right after this is geometry modeling.

00:56:56.620 --> 00:56:59.800
After that, tomorrow morning,
OpenGL optimization.

00:56:59.800 --> 00:57:01.760
John Stauffer,
the head of our OpenGL team,

00:57:01.860 --> 00:57:03.810
is going to be in here and
is going to take you through

00:57:03.910 --> 00:57:04.960
optimizing an OpenGL app.

00:57:04.960 --> 00:57:06.180
It's going to be a really great session.

00:57:06.180 --> 00:57:09.230
He has some really great tools to
show you how to optimize that app,

00:57:09.230 --> 00:57:13.000
and I'll show you how to get the most
performance out of an OpenGL application.

00:57:13.000 --> 00:57:14.560
Advanced rendering.

00:57:14.560 --> 00:57:16.680
Troy Dawson,
one of our engineers in the OpenGL team,

00:57:16.720 --> 00:57:19.570
is going to come and show some
advanced rendering techniques.

00:57:19.760 --> 00:57:21.270
You'll definitely want to see that.

00:57:21.270 --> 00:57:26.490
He talks about using the
stencil buffer to do shadows.

00:57:26.500 --> 00:57:28.870
He talks about anisotropic
filtering and some other topics.

00:57:28.950 --> 00:57:29.830
It'll be a really good talk.

00:57:29.920 --> 00:57:33.680
We have the feedback forum for
OpenGL at the end of the day tomorrow.

00:57:33.680 --> 00:57:36.960
Please come talk to us about
what you want to see in OpenGL,

00:57:36.960 --> 00:57:38.950
where we're doing well,
where we're not doing well.

00:57:39.050 --> 00:57:40.120
We want to get your feedback.

00:57:40.120 --> 00:57:43.120
We want to take your stuff in,
and we want to make sure that we

00:57:43.120 --> 00:57:45.890
improve it and make it the most
world-class implementation of

00:57:45.890 --> 00:57:47.700
OpenGL and 3D graphics API anywhere.

00:57:47.700 --> 00:57:53.120
Lastly, the feedback forum for QuickTime,
the QuickTime API,

00:57:53.120 --> 00:57:56.780
which I think you've seen is very
beneficial to your work in OpenGL for

00:57:56.780 --> 00:57:58.800
texture handling and for movie playback.

00:57:58.820 --> 00:58:01.690
There's a feedback forum for
QuickTime also Thursday at 3.30.

00:58:03.870 --> 00:58:08.100
Sergio Mello is the technology
manager for 3D Technologies at Apple.

00:58:08.120 --> 00:58:10.650
It's a great contact if you have
questions about implementations,

00:58:10.650 --> 00:58:13.220
questions about where we're going,
questions about what we have

00:58:13.340 --> 00:58:15.300
today to solve your problems.

00:58:15.310 --> 00:58:18.780
Please contact him, sergio@apple.com,
with those kind of questions.
WEBVTT

00:00:05.050 --> 00:00:06.540
Well, good afternoon.

00:00:06.540 --> 00:00:08.300
So this is the Using Cocoa Talk.

00:00:08.300 --> 00:00:09.280
My name is Ali Ozer.

00:00:09.280 --> 00:00:12.350
I'm the manager of the
Cocoa Frameworks Group.

00:00:12.400 --> 00:00:14.920
So the title of the talk is a bit vague.

00:00:14.920 --> 00:00:16.340
What are we going to do today?

00:00:16.340 --> 00:00:17.980
Let me just cover that quickly.

00:00:17.980 --> 00:00:20.340
We are going to cover some
Cocoa programming topics,

00:00:20.340 --> 00:00:21.440
which is good.

00:00:21.440 --> 00:00:24.080
We are also going to be
discussing some APIs.

00:00:24.080 --> 00:00:27.360
And we're actually going to
write some code using those APIs.

00:00:27.360 --> 00:00:30.460
We're actually also going to try to
compile and run those apps on stage,

00:00:30.460 --> 00:00:32.360
so keep your fingers crossed.

00:00:32.360 --> 00:00:35.290
And probably the overall
goal is to demonstrate that

00:00:35.360 --> 00:00:37.100
Cocoa is powerful and easy.

00:00:37.100 --> 00:00:38.140
You heard this on Monday.

00:00:38.140 --> 00:00:39.260
You saw some demos.

00:00:39.260 --> 00:00:43.100
And we want to show you with more
stuff that that's indeed the case.

00:00:43.100 --> 00:00:45.740
Now note that this doesn't mean--

00:00:45.880 --> 00:00:48.840
that if you're a newcomer to
Cocoa that within two weeks you've

00:00:48.840 --> 00:00:50.560
written the world's greatest
app and you're shipping it.

00:00:50.600 --> 00:00:52.770
There's still a
significant learning curve.

00:00:52.820 --> 00:00:54.840
You still have to learn all of
the functionality available,

00:00:54.840 --> 00:00:56.580
all of the classes, and so on.

00:00:56.660 --> 00:01:00.110
But again,
Cocoa has got a consistent set of APIs,

00:01:00.170 --> 00:01:04.560
some nice small number of
conventions and paradigms it uses.

00:01:04.560 --> 00:01:07.530
And as you become familiar with
those and as you see those,

00:01:07.530 --> 00:01:10.910
you're going to become an expert
in hopefully a short period of time

00:01:10.910 --> 00:01:12.870
and overcome that learning curve.

00:01:12.900 --> 00:01:17.030
And today we're going to cover some of
the representative topics that you might

00:01:17.030 --> 00:01:19.070
encounter in your Cocoa programming.

00:01:19.540 --> 00:01:24.850
So before I dive into APIs and some code,
I want to give you a quick

00:01:24.930 --> 00:01:26.060
overview of Objective-C.

00:01:26.060 --> 00:01:28.550
Very quick,
just so that those of you who are

00:01:28.590 --> 00:01:32.370
not familiar with Objective-C aren't
lost in the code examples

00:01:32.370 --> 00:01:33.780
we're going to be showing you.

00:01:33.790 --> 00:01:36.150
I should also note that a lot of
the examples I show you do have

00:01:36.150 --> 00:01:38.130
one-to-one correspondence in Java,
and it's actually pretty

00:01:38.130 --> 00:01:42.320
straightforward to use them from
Java if you're programming in Java.

00:01:42.320 --> 00:01:46.250
So Objective-C is a small superset of C,
and it's ANSI C.

00:01:46.260 --> 00:01:49.880
So everything you love about ANSI C and
everything you hate about ANSI C,

00:01:49.880 --> 00:01:53.080
there's probably some,
is present in Objective-C.

00:01:53.110 --> 00:01:55.750
There is some additional syntax,
and there's a few additional

00:01:55.750 --> 00:02:00.180
types in Objective-C,
and we'll cover them very soon.

00:02:00.200 --> 00:02:03.970
Objective-C also has a
dynamic object runtime.

00:02:04.260 --> 00:02:06.240
I mean two main things by that.

00:02:06.240 --> 00:02:08.890
One,
it's that messages are bound to objects.

00:02:08.890 --> 00:02:12.460
That is, when you call functions or when
you call methods in Objective-C,

00:02:12.460 --> 00:02:15.820
the binding doesn't happen until runtime,
which gives you a lot of flexibility.

00:02:15.820 --> 00:02:16.300
Second, it's a very complex environment.

00:02:16.300 --> 00:02:16.680
It's a very complex environment.

00:02:16.680 --> 00:02:17.820
It's a very complex facility.

00:02:17.820 --> 00:02:21.270
Secondly, objects are able to ask
questions about other objects,

00:02:21.270 --> 00:02:23.580
about what messages they respond to.

00:02:23.580 --> 00:02:26.020
Basically,
Objective-C has these facilities

00:02:26.130 --> 00:02:29.960
that allows you to ask at runtime,
"What messages do I respond to?

00:02:29.960 --> 00:02:32.760
What messages do you respond to?

00:02:32.760 --> 00:02:33.260
Who am I?

00:02:33.260 --> 00:02:36.030
Why am I here?" Et cetera,
those kinds of questions.

00:02:36.150 --> 00:02:38.450
That dynamism actually
adds a lot of power.

00:02:38.510 --> 00:02:42.620
It's responsible for a lot of the
power and flexibility of Cocoa,

00:02:42.620 --> 00:02:43.850
as you'll see.

00:02:43.910 --> 00:02:46.660
Just very quickly,
cover some of the syntax in Objective-C.

00:02:47.040 --> 00:02:48.520
Here's how you define a method.

00:02:48.520 --> 00:02:50.680
This is probably the weirdest syntax.

00:02:50.680 --> 00:02:55.010
This is just like a C or Java function,
except that the header line

00:02:55.010 --> 00:02:57.160
looks a bit different to you.

00:02:57.500 --> 00:02:59.470
You'll see that it's set width:height:.

00:02:59.470 --> 00:03:02.850
Again, it's a void return and two
floating point arguments,

00:03:02.890 --> 00:03:06.330
except the name of the method is broken
up into two pieces because you can

00:03:06.330 --> 00:03:10.900
use keywords in front of the various
parameters to identify them more easily.

00:03:10.930 --> 00:03:14.360
The rest of the body is sort
of like C or Objective-C,

00:03:14.360 --> 00:03:15.980
a mixture of those two.

00:03:15.980 --> 00:03:20.140
Now, to use this in a method,
here's what the line looks like.

00:03:20.140 --> 00:03:25.120
You use brackets to indicate that you're
making a message send or a method call.

00:03:25.120 --> 00:03:26.690
MyRect is the receiving object.

00:03:26.830 --> 00:03:30.430
Then you say set width:height:
with the parameters appearing

00:03:30.430 --> 00:03:32.760
in the appropriate places.

00:03:32.760 --> 00:03:35.690
Now note that when you--this
keywords that appear in front of

00:03:35.690 --> 00:03:38.670
parameters really allows you to
make the code a lot more readable,

00:03:38.740 --> 00:03:41.020
especially when you have
multiple arguments which all

00:03:41.240 --> 00:03:42.970
are identified by the keywords.

00:03:42.970 --> 00:03:44.970
Now, one other interesting
thing in Objective-C,

00:03:44.980 --> 00:03:48.680
is this ability to
refer to these methods.

00:03:48.680 --> 00:03:50.990
As I said,
Objective-C is fairly dynamic and one

00:03:51.360 --> 00:03:54.360
reason for that is this selector type.

00:03:54.360 --> 00:03:59.700
The SCL or the cell type allows you to
reference methods and then use them.

00:03:59.700 --> 00:04:02.380
So for instance, to reference this
method set width:height,

00:04:02.440 --> 00:04:06.720
you can say at selector and then
put the method name in there.

00:04:06.720 --> 00:04:10.170
And then this variable, myCell,
can be used in a variety of contexts.

00:04:10.280 --> 00:04:12.780
For instance,
you can apply it to an object.

00:04:12.780 --> 00:04:14.070
It's sort of like a function
pointer but a lot more dynamic.

00:04:14.270 --> 00:04:16.980
Because depending on the
object you're sending to,

00:04:16.980 --> 00:04:19.000
it'll actually execute a
different body of code,

00:04:19.030 --> 00:04:21.800
depending on how that object
is implemented to this method.

00:04:21.800 --> 00:04:24.460
We'll see a use of this later on.

00:04:24.460 --> 00:04:26.860
To refer to object,
here's how you declare it.

00:04:26.940 --> 00:04:32.340
Rectangle* says that this object, MyRect,
is instance of a rectangle or subclass.

00:04:32.340 --> 00:04:34.300
Again, this is the C syntax.

00:04:34.410 --> 00:04:36.140
It's a pointer to rectangle.

00:04:36.140 --> 00:04:39.650
ID is the generic term for an object,
which means that some other object

00:04:39.820 --> 00:04:41.690
is actually an object of any type.

00:04:41.690 --> 00:04:44.190
So these are how you
would refer to objects.

00:04:44.440 --> 00:04:46.940
Referring to this object,
meaning the object in the

00:04:46.950 --> 00:04:50.760
context of a message send,
the receiving object, is self.

00:04:50.770 --> 00:04:54.400
This is very much like this
in Java or this in C++.

00:04:54.570 --> 00:04:56.650
And finally, the object is self.

00:04:57.310 --> 00:05:00.220
This feature of constant strings,
strictly speaking,

00:05:00.220 --> 00:05:03.530
this is not a feature of Objective-C,
but something we've added

00:05:03.530 --> 00:05:05.200
fairly early on in the compiler.

00:05:05.200 --> 00:05:08.770
Using this @ quote business,
you can create constant strings,

00:05:08.770 --> 00:05:11.200
which are instances
of the NSString class.

00:05:11.200 --> 00:05:15.200
The NSString class is an object
that's used very heavily in Cocoa API.

00:05:15.200 --> 00:05:18.510
This allows you to get instances
of those very efficiently

00:05:18.510 --> 00:05:20.620
because they're at compile time.

00:05:21.190 --> 00:05:23.240
Okay, so much for Objective-C.

00:05:23.350 --> 00:05:25.900
Hopefully now you're armed with
just enough to understand some

00:05:26.010 --> 00:05:28.100
of the stuff we're talking about.

00:05:28.290 --> 00:05:31.100
So, how is today's talk format?

00:05:31.110 --> 00:05:34.100
We thought you would ask questions
and we would answer them.

00:05:34.100 --> 00:05:37.230
And just to make sure it's
all clean and not so messy,

00:05:37.230 --> 00:05:40.100
we thought of the
questions you want to ask.

00:05:40.100 --> 00:05:43.100
Okay, so let's just start, dive in.

00:05:43.220 --> 00:05:45.090
Question number one.

00:05:45.460 --> 00:05:47.560
I wrote a small app
for my school project,

00:05:47.560 --> 00:05:50.080
but for full credit,
I need to support Undo.

00:05:50.080 --> 00:05:51.880
The app is so simple,
I don't know if I can.

00:05:52.030 --> 00:05:52.400
Help me.

00:05:52.400 --> 00:05:53.910
Okay, there's a great question.

00:05:53.940 --> 00:05:57.090
Now, typically, when you think of Undo,
you think of a large app,

00:05:57.130 --> 00:05:59.760
and if you were here for
the Cocoa overview session,

00:05:59.760 --> 00:06:03.620
you heard Chuck say that Undo is easy
to add to applications that are designed

00:06:03.620 --> 00:06:05.830
using model view controller paradigm.

00:06:05.840 --> 00:06:08.730
And which implies, you know,
well-designed, large application,

00:06:08.830 --> 00:06:12.000
not necessarily a small application
that someone in kindergarten wrote.

00:06:12.010 --> 00:06:14.010
So, let's see how we can do this.

00:06:14.860 --> 00:06:17.680
So, now,
the reason you can add Undo to any kind

00:06:17.680 --> 00:06:22.530
of application is model view controller
is actually fairly easy to achieve,

00:06:22.540 --> 00:06:24.910
at least at a superficial level,
and that's sometimes enough.

00:06:24.940 --> 00:06:27.110
In addition,
the Undo is really not all that hard,

00:06:27.200 --> 00:06:30.100
so you can actually try to squeeze
into any kind of application.

00:06:30.100 --> 00:06:34.690
The main object you use to
do Undo is the NSUndoManager.

00:06:34.690 --> 00:06:36.970
So, let me just show you
a slide with the APIs,

00:06:36.970 --> 00:06:38.960
and then I'll jump right into a demo.

00:06:38.960 --> 00:06:42.610
NSUndoManager is the main class you use.

00:06:42.610 --> 00:06:44.320
There's usually one per window.

00:06:44.320 --> 00:06:46.320
There's usually one per
window or one per document.

00:06:46.320 --> 00:06:49.540
Typically, you would have one per Undo
context you want to support.

00:06:49.860 --> 00:06:52.900
So, if you want to have Undo that
applies to the whole application,

00:06:52.900 --> 00:06:54.570
meaning the Undo stack
applies to the whole app,

00:06:54.630 --> 00:06:56.810
you would have one instance of
this instead of one per window.

00:06:56.820 --> 00:06:59.830
The way you use this is,
whenever the user does

00:06:59.830 --> 00:07:03.770
an undoable action,
you know, they type some text,

00:07:03.770 --> 00:07:05.330
they do something,

00:07:05.540 --> 00:07:08.730
You register a callback,
and the callback is the callback you

00:07:08.830 --> 00:07:11.130
want invoked to undo that action.

00:07:11.400 --> 00:07:14.240
The way you register this
callback is to call this method.

00:07:14.310 --> 00:07:17.320
So note that this is, again,
those of you uneasy with objectivity,

00:07:17.360 --> 00:07:19.840
this is a method with three arguments.

00:07:19.910 --> 00:07:23.330
This method you provide, first of all,
the callback target,

00:07:23.330 --> 00:07:24.720
who's going to be called.

00:07:24.940 --> 00:07:27.570
And a selector,
basically the method that will be called.

00:07:27.650 --> 00:07:29.150
There is the use of that SEL type.

00:07:29.430 --> 00:07:31.650
And finally,
the single argument into which

00:07:31.730 --> 00:07:33.240
you can shove anything you want.

00:07:33.340 --> 00:07:36.430
So this is basically what you do.

00:07:37.360 --> 00:07:40.450
Okay, so this is pretty much all the
API I need to show you at this point,

00:07:40.480 --> 00:07:43.020
so let's go and do a little demo.

00:07:49.370 --> 00:07:52.570
So for demo, I'm going to be using
the dot view application.

00:07:52.640 --> 00:07:56.430
Those of you who were at last year's
Cocoa overview probably know that the dot

00:07:56.430 --> 00:07:58.920
view application was born there on stage.

00:07:58.920 --> 00:08:02.680
Then it made its way into the
examples folder on your 10 machine.

00:08:02.700 --> 00:08:06.160
It also makes an appearance in the
learning Cocoa book by O'Reilly.

00:08:06.200 --> 00:08:07.820
So this program has gotten around.

00:08:07.820 --> 00:08:10.860
And here it is again, once again,
for us to fiddle with.

00:08:10.870 --> 00:08:12.540
OK, so the program is very simple.

00:08:12.540 --> 00:08:14.910
It's got one subclass of view.

00:08:15.110 --> 00:08:16.810
Let me just run it.

00:08:21.460 --> 00:08:22.340
So there it is.

00:08:22.340 --> 00:08:24.640
You probably have seen this
in one of those contexts.

00:08:24.640 --> 00:08:25.840
You can make the dot larger.

00:08:25.840 --> 00:08:27.520
You can click anywhere you want.

00:08:27.520 --> 00:08:29.390
You can also click on
this color well object,

00:08:29.450 --> 00:08:31.340
which brings up the standard color panel.

00:08:31.340 --> 00:08:33.340
And you can change the color.

00:08:33.370 --> 00:08:36.100
So if you go look at the Edit menu,
which is standard in Cocoa apps,

00:08:36.100 --> 00:08:37.420
you notice that nothing is enabled.

00:08:37.420 --> 00:08:38.840
You can't cut, copy, paste.

00:08:38.840 --> 00:08:40.430
You also cannot do undo or redo.

00:08:40.680 --> 00:08:43.160
So our goal is to try to enable those.

00:08:43.160 --> 00:08:45.460
So let me quit this right now.

00:08:47.770 --> 00:08:49.650
This app only has one object.

00:08:49.700 --> 00:08:50.960
It's the dot view object.

00:08:50.960 --> 00:08:52.160
It's a subclass of NSView.

00:08:52.160 --> 00:08:55.310
As you know, NSView is the main
object used for drawing.

00:08:55.330 --> 00:08:57.140
I'm not going to go through
all of this implementation.

00:08:57.140 --> 00:08:59.900
There's actually only about
25 lines of stuff here.

00:08:59.900 --> 00:09:00.580
You init it.

00:09:00.580 --> 00:09:01.580
You dialog it.

00:09:01.580 --> 00:09:03.960
This is the way views draw themselves.

00:09:03.960 --> 00:09:05.590
The interesting methods are mouse up.

00:09:05.730 --> 00:09:07.720
This is what moves the dot.

00:09:07.780 --> 00:09:11.320
Set radius,
which is what changes the radius.

00:09:11.460 --> 00:09:13.200
Set color,
which is what changes the color.

00:09:13.200 --> 00:09:17.000
First, let's concentrate on
making the color undoable.

00:09:17.000 --> 00:09:19.300
Now let's look at this method here.

00:09:19.310 --> 00:09:21.200
It takes an ID sender.

00:09:21.200 --> 00:09:23.860
This is a typical target action method.

00:09:23.860 --> 00:09:26.190
If you remember from Monday or
from some of the other talks,

00:09:26.190 --> 00:09:31.980
target action is how Cocoa UI objects
communicate with the back end objects.

00:09:31.980 --> 00:09:34.750
In this case,
whenever I fiddle with the color well,

00:09:34.750 --> 00:09:37.220
I mean the color panel,
the color well ends up

00:09:37.220 --> 00:09:38.620
sending me a message.

00:09:38.620 --> 00:09:40.940
The argument here is the color well.

00:09:40.940 --> 00:09:42.790
Here, I get rid of my old color.

00:09:42.790 --> 00:09:44.680
Dot color is the current color.

00:09:44.680 --> 00:09:47.590
I hang on to the new color
by asking the sender what its

00:09:47.720 --> 00:09:49.560
color is and hanging on to it.

00:09:49.560 --> 00:09:51.800
I tell myself I need to display.

00:09:51.820 --> 00:09:55.880
That's all nice and good,
but this is not really an MVC.

00:09:55.880 --> 00:09:57.850
This is not a very good MVC method.

00:09:57.890 --> 00:10:01.000
It mixes the model, the view,
and controller all into one.

00:10:01.000 --> 00:10:02.200
Let's see if we can
make it a little better.

00:10:06.010 --> 00:10:08.640
Now I'm tired of typing,
so for the rest of this session

00:10:08.660 --> 00:10:11.260
I'm going to use this magic typing
assistant and I might explain

00:10:11.260 --> 00:10:12.610
to you how it works later on.

00:10:12.610 --> 00:10:14.160
So now you'll see how it works.

00:10:14.200 --> 00:10:16.350
I'm just going to go like this
and it's going to type for me.

00:10:16.400 --> 00:10:16.890
Okay?

00:10:16.890 --> 00:10:18.890
Okay, so let's get started.

00:10:18.930 --> 00:10:20.240
First I'm going to add this method.

00:10:20.240 --> 00:10:24.200
This assistant is really very good.

00:10:24.200 --> 00:10:24.200
Okay.

00:10:24.880 --> 00:10:28.330
Okay, so I've just added this method,
which is very much like this method,

00:10:28.330 --> 00:10:30.740
except instead of taking a sender,
it takes an sColor.

00:10:30.740 --> 00:10:33.550
And instead of obviously asking
the sender for the color,

00:10:33.550 --> 00:10:35.090
it just retains that color.

00:10:35.100 --> 00:10:36.780
So this is more of a model method.

00:10:36.780 --> 00:10:39.400
You know,
it sets the instance variable directly.

00:10:39.400 --> 00:10:41.960
That means somebody else can
call it to set the color.

00:10:42.070 --> 00:10:43.060
That's nice.

00:10:43.060 --> 00:10:47.250
Let's go ahead and rewrite setColor
to work in terms of setColor value,

00:10:47.300 --> 00:10:49.620
and that's fairly obvious as well.

00:10:49.620 --> 00:10:52.360
Hopefully it's fairly obvious
that this old method is

00:10:52.470 --> 00:10:54.030
equivalent to this and this.

00:10:54.460 --> 00:10:57.000
So this method just calls
setColor value with the color.

00:10:57.000 --> 00:10:57.700
Right?

00:10:57.830 --> 00:10:59.400
You're convinced it's
about the same thing.

00:10:59.400 --> 00:11:00.760
So let's get rid of this.

00:11:04.810 --> 00:11:07.940
So the beauty of doing this is
now we have a method here which

00:11:07.960 --> 00:11:09.800
we can use for our undo purposes.

00:11:09.910 --> 00:11:13.800
So the first thing I'm going to
do here is create an undo manager.

00:11:13.800 --> 00:11:17.520
Now it turns out that every window
by default has an undo manager.

00:11:17.650 --> 00:11:19.860
So if you don't do anything,
undos work within the

00:11:19.860 --> 00:11:20.900
context of a window.

00:11:20.900 --> 00:11:24.700
And why don't we take
advantage of that right now?

00:11:24.770 --> 00:11:28.470
So I'm going to ask myWindow.

00:11:29.220 --> 00:11:31.140
For its Undo Manager.

00:11:31.190 --> 00:11:32.400
By default, it's not created.

00:11:32.400 --> 00:11:34.090
It will be created lazily
and returned to you,

00:11:34.100 --> 00:11:35.800
and that's what we're
taking advantage of here.

00:11:35.910 --> 00:11:40.740
And now we're going to make use
of that code I showed earlier.

00:12:02.730 --> 00:12:02.730
Just to make sure you understand this,
I'm telling the undo manager

00:12:02.730 --> 00:12:02.730
to register undo with target,
self, self being this object.

00:12:02.730 --> 00:12:02.730
Selector is the set color value selector,
and object is the old color.

00:12:02.730 --> 00:12:02.730
What happens is whenever
I change the color,

00:12:02.730 --> 00:12:02.730
I tell the undo manager to
call myself with the old color

00:12:02.730 --> 00:12:02.730
if it needs to undo this.

00:12:04.200 --> 00:12:09.040
Okay, so this is pretty much all
that's needed and let me show

00:12:09.040 --> 00:12:10.810
you that that's indeed the case.

00:12:10.810 --> 00:12:14.110
I'm going to save, I'm going to build.

00:12:17.800 --> 00:12:20.420
and run.

00:12:20.420 --> 00:12:21.980
Let's hide others.

00:12:21.980 --> 00:12:23.720
So the Edit menu is disabled.

00:12:23.720 --> 00:12:24.880
I can click around.

00:12:24.880 --> 00:12:26.280
It's still disabled.

00:12:26.280 --> 00:12:28.000
But I can bring up a color well.

00:12:28.000 --> 00:12:29.880
I can change the color.

00:12:29.880 --> 00:12:31.640
Let me actually make this bigger.

00:12:31.690 --> 00:12:33.260
Change the color.

00:12:33.260 --> 00:12:34.500
And Undo is enabled.

00:12:34.500 --> 00:12:35.440
And I can undo.

00:12:35.440 --> 00:12:36.360
There you go.

00:12:36.360 --> 00:12:38.040
Now notice that one more magical thing.

00:12:38.040 --> 00:12:39.520
Redo is also enabled.

00:12:39.550 --> 00:12:44.920
So what's happening here is
any time an undo is being done,

00:12:44.920 --> 00:12:48.300
any time we do something,
the undo methods are recorded.

00:12:48.300 --> 00:12:51.700
Now when the user does an undo,
that same method is called.

00:12:51.700 --> 00:12:54.940
When that method is being executed,
it also registers undoes.

00:12:54.940 --> 00:12:58.340
So any undoes that are registered
as a part of processing an undo are

00:12:58.340 --> 00:13:00.490
recorded as redo actions for that undo.

00:13:00.520 --> 00:13:04.400
So it turns out that one line actually
is enough to do both the undo and redo.

00:13:04.400 --> 00:13:09.290
Another magical thing,
if I actually change this around so

00:13:09.290 --> 00:13:14.840
that I'm changing the color all the way,
when I undo, it doesn't go back to

00:13:14.840 --> 00:13:15.890
the-- incremental color.

00:13:16.040 --> 00:13:19.540
It just goes back to the last
color when I started clicking.

00:13:19.550 --> 00:13:22.740
That's because undo manager is smart
enough to know which event mode

00:13:22.740 --> 00:13:26.340
we're looking at and ignore all the
events-- not actually ignore them,

00:13:26.340 --> 00:13:30.420
but call us all the events that happen
when we're actually in tracking mode.

00:13:30.440 --> 00:13:32.900
This helps you get rid of methods
that happen like this or when

00:13:32.920 --> 00:13:33.940
a slider is moving and so on.

00:13:33.940 --> 00:13:35.120
That's the right thing to do.

00:13:35.160 --> 00:13:36.880
And again,
you can override this behavior,

00:13:36.900 --> 00:13:39.590
but typically it is
the right thing to do.

00:13:40.280 --> 00:13:42.440
Okay, so let me quit this.

00:13:42.440 --> 00:13:46.970
And next thing I want to show you is
let's also make the dot moving undoable.

00:13:47.230 --> 00:13:47.590
Okay?

00:13:47.710 --> 00:13:49.140
So here's mouse up.

00:13:49.240 --> 00:13:50.800
Here we look at the event location.

00:13:50.800 --> 00:13:54.160
We convert it to the current coordinates,
convert it to store in the

00:13:54.320 --> 00:13:56.680
variable called center,
and then we set needs display.

00:13:56.680 --> 00:13:59.250
Well, now we know how to fix this.

00:13:59.250 --> 00:14:04.000
We want to go ahead and add a method
that does a set center for us.

00:14:04.000 --> 00:14:04.000
Okay?

00:14:06.900 --> 00:14:12.120
Okay, so hopefully this is a pretty
obvious method to set the center.

00:14:12.120 --> 00:14:13.180
Pretty straightforward.

00:14:13.180 --> 00:14:16.590
That also means I can now
get rid of these two lines.

00:14:16.700 --> 00:14:27.300
[Transcript missing]

00:14:27.700 --> 00:14:28.150
OK.

00:14:28.600 --> 00:14:31.900
Suddenly, though, you notice one thing.

00:14:31.900 --> 00:14:36.500
That mechanism I showed you
takes as an argument an object.

00:14:36.500 --> 00:14:39.690
However,
the setCenter method takes as NSPoint.

00:14:39.750 --> 00:14:41.320
And NSPoints are not objects.

00:14:41.320 --> 00:14:42.280
They're structs.

00:14:42.280 --> 00:14:43.860
They're passed by structs.

00:14:43.880 --> 00:14:46.980
So we can't use that
method we showed you,

00:14:46.980 --> 00:14:49.880
because it is really geared
towards passing objects around.

00:14:49.880 --> 00:14:51.180
So what's the solution to this?

00:14:51.180 --> 00:14:53.160
Well,
it turns out there are two solutions.

00:14:53.160 --> 00:14:59.020
One is you can go ahead
and wrap the point,

00:14:59.060 --> 00:15:02.120
or wrap any structure, any C type,
any data structure you want,

00:15:02.120 --> 00:15:04.300
in this magical thing called NSValue.

00:15:04.300 --> 00:15:05.980
And then it becomes an object.

00:15:05.980 --> 00:15:07.940
However, note that this is really
not very pleasant,

00:15:07.940 --> 00:15:09.720
because suddenly you
have a setCenter method,

00:15:09.720 --> 00:15:12.180
which takes this NSValue as
opposed to taking a point.

00:15:12.180 --> 00:15:13.140
And that's not very natural.

00:15:13.140 --> 00:15:15.640
You really want to take a point,
because that's the argument.

00:15:15.640 --> 00:15:19.210
So we're going to not use this method.

00:15:19.890 --> 00:15:20.960
And we're going to use some other method.

00:15:20.960 --> 00:15:22.600
Let me just show you the slides for it.

00:15:22.680 --> 00:15:24.910
Can we go back to the slides?

00:15:27.790 --> 00:15:31.040
So for sophisticated callbacks in Undo,
you would use this method.

00:15:31.340 --> 00:15:33.400
Prepare with invocation target.

00:15:33.530 --> 00:15:35.500
Suddenly you're all going,
what's that mean?

00:15:35.500 --> 00:15:37.120
This name doesn't make much sense.

00:15:37.120 --> 00:15:38.580
The word register doesn't appear there.

00:15:38.580 --> 00:15:41.320
So it turns out this is quite a
sophisticated way of doing this,

00:15:41.370 --> 00:15:44.190
and the name will make a little
sense maybe when I explain it.

00:15:44.230 --> 00:15:47.220
But basically,
this call makes the Undo manager

00:15:47.270 --> 00:15:50.440
go into a state where then
you can make a call into it,

00:15:50.440 --> 00:15:53.110
and it freeze-dries that call you made.

00:15:53.110 --> 00:15:57.380
And then you can later on add
water and execute that call.

00:15:57.770 --> 00:16:00.000
This is a great way to
basically freeze-dry any call,

00:16:00.000 --> 00:16:01.020
no matter how complicated.

00:16:01.090 --> 00:16:01.950
It can have five arguments.

00:16:01.960 --> 00:16:03.740
It can have an argument
with a huge data structure.

00:16:03.740 --> 00:16:05.060
It remembers it all.

00:16:05.170 --> 00:16:08.260
And I'm going to show you exactly how
this works so it makes more sense.

00:16:08.260 --> 00:16:11.160
The reason the word invocation
appears here is because we use

00:16:11.160 --> 00:16:14.100
a thing called NSInvocation,
a class called NSInvocation,

00:16:14.100 --> 00:16:15.290
to implement this.

00:16:15.290 --> 00:16:16.980
And of course,
most of this owes a great deal

00:16:16.980 --> 00:16:19.930
to Objective-C's dynamic nature,
being able to do all this packaging.

00:16:19.930 --> 00:16:22.670
So let me show you how this works.

00:16:24.190 --> 00:16:26.100
Here's the call you make.

00:16:26.190 --> 00:16:29.930
First you call, say, undoManager,
prepare with invocation target self.

00:16:30.010 --> 00:16:33.860
Again, we want this object to be
called when this happens.

00:16:33.900 --> 00:16:35.600
And then we actually make the call.

00:16:35.700 --> 00:16:37.090
Set center, center.

00:16:37.090 --> 00:16:37.780
That's it.

00:16:37.960 --> 00:16:38.750
You make the call.

00:16:38.750 --> 00:16:41.390
And it just remembers the
call instead of executing it.

00:16:41.390 --> 00:16:43.710
It wraps it up and puts it away.

00:16:43.710 --> 00:16:45.440
So I'm going to save.

00:16:45.460 --> 00:16:47.710
I'm going to build and run.

00:16:56.100 --> 00:17:23.700
[Transcript missing]

00:17:27.620 --> 00:17:32.780
Okay, well enough for undo,
let's go to the next question.

00:17:33.710 --> 00:17:35.690
How do I add a toolbar to my application?

00:17:35.700 --> 00:17:37.030
I don't see the interface builder.

00:17:37.190 --> 00:17:38.600
Ah, that's a good question.

00:17:38.740 --> 00:17:41.240
Toolbar, as you know, is a new object.

00:17:41.240 --> 00:17:45.280
We added it very recently in 10.0.

00:17:46.050 --> 00:17:47.980
Most people when they're doing
Cocoa programming are used to

00:17:47.980 --> 00:17:51.140
just going to Interface Builder
and dragging their objects off.

00:17:51.170 --> 00:17:53.720
Well, Toolbar doesn't make an appearance
in Interface Builder yet because

00:17:53.820 --> 00:17:56.740
it's brand new and we haven't added
facilities for Toolbar to properly

00:17:56.740 --> 00:17:58.840
be archived in Interface Builder.

00:17:58.870 --> 00:18:00.100
And so it's not there.

00:18:00.350 --> 00:18:03.440
In addition, Toolbar is new so it's not
very well documented either,

00:18:03.440 --> 00:18:05.400
so you might be getting
confused about how to do it.

00:18:05.450 --> 00:18:08.780
So let's just show you a simple
example of how to do this.

00:18:09.360 --> 00:18:12.250
Now, the toolbar, as I said,
is new in 10.0, and there are two classes

00:18:12.250 --> 00:18:15.370
that implement the toolbar:
the toolbar item class

00:18:15.430 --> 00:18:17.290
and the toolbar class.

00:18:17.780 --> 00:18:22.100
ToolbarItem is the class that represents
the individual items on the toolbar.

00:18:22.100 --> 00:18:24.560
So the various buttons you see,
each one is a toolbar item.

00:18:24.560 --> 00:18:27.550
The attributes you can assign
to these toolbar items include

00:18:27.660 --> 00:18:31.430
stuff like what the image is,
what the label is, what the help tag is,

00:18:31.430 --> 00:18:32.600
what the menu is.

00:18:32.600 --> 00:18:34.940
So when you click on the menu drops,
you can assign that menu.

00:18:34.940 --> 00:18:38.480
In addition, of course, very importantly,
you assign a target and an action.

00:18:38.480 --> 00:18:41.680
As you know, target actions is how
UI elements do their thing.

00:18:41.680 --> 00:18:45.790
So you assign it to the toolbar
item and that does its thing.

00:18:46.780 --> 00:18:49.020
Note that toolbar items
can also be custom.

00:18:49.330 --> 00:18:52.770
They have a custom view,
which means if you have

00:18:52.770 --> 00:18:54.570
some sophisticated view
you want to put up there,

00:18:54.570 --> 00:18:57.000
not just a button-like thing,
you would use that mechanism.

00:18:57.000 --> 00:19:00.570
For instance, the mail search field,
which has a pop-up, a search field,

00:19:00.570 --> 00:19:03.000
some text over it,
is implemented using this.

00:19:03.000 --> 00:19:05.000
You can do all sorts of
crazy things with this.

00:19:05.000 --> 00:19:06.900
You can put a clock up there,
a CPU meter, stock ticker.

00:19:07.040 --> 00:19:09.280
You can sell ad space on your toolbar.

00:19:09.280 --> 00:19:10.480
So it's all very useful.

00:19:10.480 --> 00:19:11.990
Thank you.

00:19:12.990 --> 00:19:16.500
Now, toolbar items,
each one has a unique identifier,

00:19:16.500 --> 00:19:18.080
which is an NSString.

00:19:18.080 --> 00:19:20.860
This unique identifier is
used to reference the items.

00:19:20.910 --> 00:19:23.600
So typically the toolbar
talks in terms of identifiers,

00:19:23.600 --> 00:19:24.470
not toolbars.

00:19:24.480 --> 00:19:27.140
And when I say unique here,
I don't mean a globally unique

00:19:27.210 --> 00:19:29.060
credit card number-like thing.

00:19:29.060 --> 00:19:32.720
It's just a string that's unique
within the context of a toolbar.

00:19:33.560 --> 00:19:37.360
And we also provide some built-in
identifiers from Cocoa so you can use

00:19:37.360 --> 00:19:39.270
the standard items in your application.

00:19:39.270 --> 00:19:42.810
The toolbar is the class that
represents the whole toolbar.

00:19:42.810 --> 00:19:45.210
Again, it has attributes,
and these include stuff

00:19:45.210 --> 00:19:47.890
like whether it's visible,
whether it's customizable,

00:19:47.890 --> 00:19:49.980
whether it's display mode is, and so on.

00:19:50.000 --> 00:19:53.960
And toolbar also has an identifier,
and this identifier is used to, one,

00:19:53.960 --> 00:19:56.630
save the state of the toolbar,
because remember,

00:19:56.670 --> 00:19:58.820
you can customize those toolbars.

00:19:58.820 --> 00:20:00.520
And when you customize
a toolbar in an app,

00:20:00.520 --> 00:20:03.370
and you quit the app, and you restart it,
you want the same state.

00:20:05.450 --> 00:20:07.990
In addition,
this identifier is used to keep the

00:20:08.080 --> 00:20:10.440
toolbar synchronized with other toolbars.

00:20:10.440 --> 00:20:12.840
So if in your app you have seven
document windows and you change

00:20:12.840 --> 00:20:14.840
the toolbar on one of them,
you want all the other

00:20:14.840 --> 00:20:15.830
toolbars to change.

00:20:15.840 --> 00:20:17.960
However,
if you have two kinds of documents,

00:20:18.030 --> 00:20:21.540
for instance in mail there's a compose
window and there's a mailbox window,

00:20:21.570 --> 00:20:24.440
you would assign two different
identifiers so that when you change

00:20:24.540 --> 00:20:29.000
the compose window's toolbar,
the mailbox one remains distinct.

00:20:29.000 --> 00:20:31.300
So that's what the
identifier is used for.

00:20:31.300 --> 00:20:34.190
Now,
interesting thing about the toolbar is

00:20:34.500 --> 00:20:35.670
is quite a lazy little class.

00:20:35.750 --> 00:20:38.840
It relies on its delegate
to do most of the work.

00:20:38.840 --> 00:20:42.400
This is a paradigm we use
in other places in Cocoa.

00:20:42.400 --> 00:20:44.400
For instance,
a table view would ask its data

00:20:44.400 --> 00:20:46.960
source for the data and not
really store the data itself.

00:20:47.110 --> 00:20:48.560
This allows it to be lazy.

00:20:48.560 --> 00:20:50.170
It doesn't store the data.

00:20:50.180 --> 00:20:51.580
It can create it later.

00:20:51.580 --> 00:20:55.120
That's a pretty good paradigm,
and that's what Toolbar does.

00:20:55.330 --> 00:20:57.880
Given that's the case,
let's just look at three

00:20:57.880 --> 00:20:59.380
of the delegate methods.

00:20:59.490 --> 00:21:03.770
These are the important delegate methods
because these need to be implemented.

00:21:04.580 --> 00:21:08.620
So the first one is how a
toolbar finds out what items

00:21:08.710 --> 00:21:11.210
can be placed on the toolbar.

00:21:11.370 --> 00:21:13.800
Now note that this is
sent to the delegate,

00:21:13.890 --> 00:21:16.700
so the delegate gets a
reference to the toolbar.

00:21:16.700 --> 00:21:18.760
So if the same delegate is being
used for multiple toolbars,

00:21:18.760 --> 00:21:22.060
it can make different decisions.

00:21:22.070 --> 00:21:24.080
That's always the case
with delegate methods.

00:21:24.080 --> 00:21:27.740
And this returns an array of identifiers,
indicating here are all the items

00:21:27.750 --> 00:21:29.940
that can appear in this toolbar.

00:21:29.940 --> 00:21:32.360
The next method is similar,
except it returns the

00:21:32.360 --> 00:21:34.990
initial set of items,
meaning when the user first

00:21:34.990 --> 00:21:37.980
time brings up that toolbar,
what do they see?

00:21:38.100 --> 00:21:40.460
And finally, there's a method to
create the toolbar item.

00:21:40.460 --> 00:21:42.140
Because remember,
all of these methods are

00:21:42.140 --> 00:21:43.570
working in terms of identifiers.

00:21:43.690 --> 00:21:47.160
Eventually,
somebody has to create a toolbar

00:21:47.170 --> 00:21:49.820
item from the item identifier.

00:21:49.820 --> 00:21:54.090
And that's when you call this method,
passing in the toolbar, the identifier,

00:21:54.110 --> 00:21:57.090
and a flag indicating whether it's
being added to the toolbar or it's

00:21:57.090 --> 00:21:59.260
being created for some other reason.

00:21:59.260 --> 00:22:02.500
And that would determine whether
the thing should be live or not,

00:22:02.500 --> 00:22:03.400
for instance.

00:22:03.400 --> 00:22:07.040
So again, these are sent by the
toolbar to its delegate.

00:22:07.990 --> 00:22:10.940
Again, demo.

00:22:10.940 --> 00:22:15.270
For this, I'm going to use the
TextEdit application.

00:22:15.290 --> 00:22:17.220
Most of you probably know
about the TextEdit application.

00:22:17.260 --> 00:22:20.400
It is the app that ships
in the applications folder.

00:22:20.440 --> 00:22:27.410
The source is also available
on your developer CD in

00:22:27.410 --> 00:22:27.410
the app examples directory,
so you can take a look at it yourself.

00:22:30.940 --> 00:22:33.000
So TextEdit is not a document.

00:22:33.020 --> 00:22:35.070
It's not an NS document-based
application.

00:22:35.070 --> 00:22:37.400
It's a custom document-based application.

00:22:37.400 --> 00:22:39.530
It was done before NS documents,
so it implements its own

00:22:39.530 --> 00:22:41.330
document functionality.

00:22:41.450 --> 00:22:44.840
And it turns out the most convenient
place to create a toolbar is right after

00:22:44.840 --> 00:22:47.340
we create the window for a document,
because a toolbar goes

00:22:47.340 --> 00:22:50.080
hand-in-hand with the window,
so you basically want to create that

00:22:50.080 --> 00:22:51.660
toolbar when you create the window.

00:22:51.710 --> 00:22:54.940
And where that happens
is in the init method.

00:22:54.970 --> 00:22:56.210
I'm not going to explain
all this code here.

00:22:56.220 --> 00:22:57.560
There's a lot of code.

00:22:57.560 --> 00:22:59.460
But here's the init method,
which initializes the document.

00:22:59.480 --> 00:23:02.040
That also goes in and creates
the window and all that.

00:23:02.080 --> 00:23:04.900
Now,
this is not a super great example of MVC,

00:23:04.900 --> 00:23:06.980
so don't look at TextEdit for MVC hints.

00:23:06.980 --> 00:23:09.900
But anyway, it works.

00:23:09.970 --> 00:23:12.690
So at the bottom of init,
we're just going to go

00:23:12.710 --> 00:23:13.800
create our toolbar here.

00:23:13.880 --> 00:23:17.510
If you look up here a little bit,
we create the window and so on,

00:23:17.520 --> 00:23:18.800
so ignore all that mess.

00:23:18.830 --> 00:23:21.330
But here, let's create our toolbar.

00:23:22.660 --> 00:23:24.020
I'm going to open a brace.

00:23:24.020 --> 00:23:27.160
One thing people get confused about
in Objective-C is they think they

00:23:27.250 --> 00:23:29.510
can declare variables anywhere,
like in C++.

00:23:29.520 --> 00:23:32.440
That's not the case yet because
the C standard did not allow it,

00:23:32.440 --> 00:23:33.870
but it's been added to C99.

00:23:33.870 --> 00:23:36.480
We might actually see this
in Objective-C someday.

00:23:36.480 --> 00:23:39.640
For now, to create new variables in
the middle of your stream,

00:23:39.640 --> 00:23:41.660
in the middle of your code,
you have to open a new brace.

00:23:41.660 --> 00:23:44.840
Again, I could have done this at the top,
but that would be messy.

00:23:44.840 --> 00:23:46.490
We have a toolbar, Instance.

00:23:46.510 --> 00:23:48.490
We create the instance.

00:23:48.510 --> 00:23:52.990
Note that this is the class,
alloc init is what you normally

00:23:52.990 --> 00:23:55.080
use to create instances.

00:23:55.080 --> 00:23:59.730
Here I'm creating a toolbar myself
by hand because I can't do it in IB.

00:23:59.830 --> 00:24:03.460
This is work that I wouldn't have
to do sometime in the future,

00:24:03.460 --> 00:24:04.300
hopefully.

00:24:04.300 --> 00:24:05.160
I give an identifier.

00:24:05.160 --> 00:24:06.780
Again, it can be anything.

00:24:06.780 --> 00:24:08.440
Texted toolbar sounds good.

00:24:08.440 --> 00:24:10.990
Now let's go set a few
attributes on this.

00:24:10.990 --> 00:24:12.990
We make the delegate to be self.

00:24:12.990 --> 00:24:15.480
We tell it that it allows
user customization,

00:24:15.480 --> 00:24:17.010
meaning the user can change it.

00:24:17.150 --> 00:24:18.500
We say that it can save it.

00:24:18.500 --> 00:24:20.260
We say that it can
change its configuration.

00:24:20.260 --> 00:24:29.100
We also tell our window that the toolbar
I just created is the window's toolbar.

00:24:29.240 --> 00:24:29.770
Set toolbar.

00:24:29.780 --> 00:24:31.940
NSWindow has a method called set toolbar.

00:24:32.280 --> 00:24:35.300
Finally, because I gave this
toolbar off to the window,

00:24:35.300 --> 00:24:38.040
I no longer need it, so I release it.

00:24:38.070 --> 00:24:40.880
This is the memory management
stuff in Cocoa where you create it,

00:24:40.880 --> 00:24:44.230
you hand it off to somebody,
you don't need it anymore,

00:24:44.230 --> 00:24:45.500
you get rid of it.

00:24:45.500 --> 00:24:46.360
That's it.

00:24:46.400 --> 00:24:48.490
That creates the toolbar.

00:24:48.500 --> 00:24:52.740
Step two here is to implement
those delegate methods.

00:24:52.740 --> 00:24:56.620
Let's find some empty space here
and let's do our delegate methods.

00:24:56.730 --> 00:25:00.240
The first one was
allowed item identifiers.

00:25:00.240 --> 00:25:03.860
Here we're supposed to return
an array containing the items,

00:25:03.860 --> 00:25:05.560
the item identifiers.

00:25:05.560 --> 00:25:09.320
Let's go whole hog and do this.

00:25:09.320 --> 00:25:13.080
You're going, "Whoa,
what's that?" These are all the items

00:25:13.080 --> 00:25:16.180
that Cocoa gives you out of the box.

00:25:16.250 --> 00:25:20.380
The color dialog, the font blog,
the separate item, et cetera,

00:25:20.380 --> 00:25:21.780
and the customized item.

00:25:21.780 --> 00:25:24.770
We create an array and we return that.

00:25:25.250 --> 00:25:28.050
Next,
we implement the second delegate method,

00:25:28.050 --> 00:25:30.760
default item identifiers.

00:25:30.970 --> 00:25:32.440
Let me finish implementing this.

00:25:32.440 --> 00:25:34.660
Here we return an array of just one item.

00:25:35.080 --> 00:25:36.250
This is the default toolbar.

00:25:36.420 --> 00:25:37.740
It doesn't matter what it has.

00:25:37.820 --> 00:25:39.800
The user will customize it, hopefully.

00:25:39.840 --> 00:25:42.720
Let's just put the
customize item in there.

00:25:42.720 --> 00:25:45.160
Finally we have to implement
our third delegate method.

00:25:45.190 --> 00:25:46.900
Remember that was to create the items.

00:25:46.900 --> 00:25:48.950
In this case, because we were using
all the built-in items,

00:25:48.950 --> 00:25:51.080
that method actually
doesn't have to do any work.

00:25:51.110 --> 00:25:53.320
It turns out it has to be implemented.

00:25:53.320 --> 00:25:55.660
We just go ahead and implement it.

00:25:56.840 --> 00:25:59.320
Note, it's got three arguments.

00:25:59.320 --> 00:26:01.360
We implement it and we just return nil.

00:26:01.360 --> 00:26:05.080
We don't do anything in this case
because this method will never be called.

00:26:05.150 --> 00:26:06.250
It just happens to be implemented.

00:26:06.350 --> 00:26:08.390
It turns out most of the time
when you implement a toolbar,

00:26:08.390 --> 00:26:11.540
this method will be implemented and
I'll show you that in a few seconds.

00:26:11.600 --> 00:26:12.070
That's it.

00:26:12.130 --> 00:26:15.050
We implemented our three delegate
methods and we wrote a few lines of

00:26:15.050 --> 00:26:17.740
code to create the toolbar itself.

00:26:17.860 --> 00:26:22.870
Let's save and let's run this thing.

00:26:28.530 --> 00:26:30.070
Let me hide others.

00:26:30.120 --> 00:26:31.260
Well, and there you go.

00:26:31.260 --> 00:26:33.820
There's a toolbar and it
has a customized item.

00:26:33.820 --> 00:26:36.630
And it does all the things toolbar does.

00:26:36.740 --> 00:26:38.500
Appear, disappear, that's good.

00:26:38.500 --> 00:26:41.660
Note that the content area down here
doesn't know anything about the toolbar

00:26:41.840 --> 00:26:43.580
because that's part of the frame.

00:26:43.580 --> 00:26:46.470
Now I can do the magic stuff,
bring it down.

00:26:46.470 --> 00:26:47.990
Now I'm customizing it.

00:26:48.300 --> 00:26:51.180
I can put the colors panel,
I can put fonts panel.

00:26:51.180 --> 00:26:54.260
Let's put this customized item away.

00:26:54.290 --> 00:26:56.090
Put a flexible space.

00:26:57.200 --> 00:26:57.940
And there we are.

00:26:57.940 --> 00:26:59.630
So that's a toolbar that I can live with.

00:26:59.630 --> 00:27:01.200
If I create a new document.

00:27:01.200 --> 00:27:02.200
Thank you.

00:27:06.400 --> 00:27:10.030
Again, creating a new document also gives
me the same toolbar because I told it

00:27:10.150 --> 00:27:11.940
that it has an identifier and so on.

00:27:12.000 --> 00:27:15.100
So, again, this is interesting,
but you really want to create

00:27:15.100 --> 00:27:16.440
your own toolbar items.

00:27:16.500 --> 00:27:19.400
I mean, you're not going to be
content with just those items.

00:27:19.400 --> 00:27:22.290
So let's just do that one extra
step and show how we would do this.

00:27:22.300 --> 00:27:26.360
To allow that,
in the allowed item identifiers method,

00:27:26.420 --> 00:27:27.800
we want to return a new identifier.

00:27:27.800 --> 00:27:32.300
Again, creating this identifier is,
you just pick it out of thin air.

00:27:32.300 --> 00:27:33.780
You don't have to do anything magical.

00:27:34.110 --> 00:27:38.800
Let's call that find dialog because
let's say we want to add a button

00:27:38.800 --> 00:27:40.100
that brings up the find dialog.

00:27:40.100 --> 00:27:42.600
It turns out that's one of the
ones that's not standard in Cocoa.

00:27:42.600 --> 00:27:44.900
So we're changing our
allowed item identifiers.

00:27:44.900 --> 00:27:47.380
The default item identifiers
we don't need to touch.

00:27:47.400 --> 00:27:49.090
We can add it there,
but we don't need to.

00:27:49.100 --> 00:27:51.690
And finally,
we have to change this code here,

00:27:51.690 --> 00:27:53.880
the toolbar, the creation method,
because now we are

00:27:53.880 --> 00:27:54.750
creating a custom item.

00:27:54.800 --> 00:27:58.390
This method will be called
with that find dialog here.

00:27:58.400 --> 00:27:59.690
So let's see how we do that.

00:27:59.700 --> 00:28:03.100
First, get rid of this return nil.

00:28:03.500 --> 00:28:09.470
A series of demonstrations teach
both newcomers and experienced

00:28:09.470 --> 00:28:16.060
Cocoa developers how to take
advantage of advanced Cocoa features.

00:28:16.060 --> 00:28:16.070
Ali Ozer

00:28:16.950 --> 00:28:19.700
Now we're going to set some attributes.

00:28:19.720 --> 00:28:23.490
If it is equal to the find dialog,
because as I add more identifiers,

00:28:23.490 --> 00:28:27.900
I will get called with other ones too,
so I'll just make some conditional code.

00:28:27.900 --> 00:28:30.990
So if it's equal to the find dialog,
I will go ahead and set the label.

00:28:31.150 --> 00:28:33.220
Label is the string
that appears under it.

00:28:33.230 --> 00:28:35.580
I want the label to be set to find.

00:28:35.680 --> 00:28:37.950
Typically you would say set label find,
but that would be a

00:28:37.960 --> 00:28:40.420
non-localizable program,
and that wouldn't be very good

00:28:40.420 --> 00:28:43.140
the moment you want to sell
in Japan or other countries.

00:28:43.140 --> 00:28:46.100
So why not make it localizable
by calling this function,

00:28:46.100 --> 00:28:48.890
which allows this string
to be localizable.

00:28:49.860 --> 00:28:51.420
You can also set the palette label.

00:28:51.630 --> 00:28:54.010
That is the string that appears
in the customization window.

00:28:54.170 --> 00:28:57.540
It can be different than the
string that appears in the toolbar.

00:28:58.250 --> 00:28:59.550
I'm also going to set the target.

00:28:59.760 --> 00:29:01.600
Turns out to bring up a find panel.

00:29:01.600 --> 00:29:04.580
You contact this object
called text finder.

00:29:04.580 --> 00:29:06.260
This is in TextEdit.

00:29:06.310 --> 00:29:07.340
And we set the action.

00:29:07.340 --> 00:29:10.210
Turns out the action to bring
up the find panel is this thing,

00:29:10.210 --> 00:29:11.480
order front find panel.

00:29:11.600 --> 00:29:13.280
So again,
we're setting action and target.

00:29:13.450 --> 00:29:14.850
Typically, you know,
when you make connections

00:29:14.850 --> 00:29:17.190
in Interface Builder,
you're implicitly doing this.

00:29:17.290 --> 00:29:19.710
Here, you're seeing how to do it by hand.

00:29:19.770 --> 00:29:22.640
Again,
because we're diving a little deeper.

00:29:22.700 --> 00:29:24.660
And now I'm going to set the image.

00:29:24.700 --> 00:29:26.830
This is the image that
appears on the toolbar.

00:29:26.960 --> 00:29:30.640
Now, to set the image,
I ask NSImage for an image.

00:29:30.640 --> 00:29:32.700
And then I just set that to be my image.

00:29:32.700 --> 00:29:35.220
Now, here I put a question mark
because I don't have an image yet.

00:29:35.220 --> 00:29:37.540
Let me go ahead and find an image.

00:29:37.540 --> 00:29:41.140
If I go into finder,
go into my documents directory,

00:29:41.140 --> 00:29:43.900
I'll choose one of these images,
this one.

00:29:43.900 --> 00:29:44.460
Okay.

00:29:44.460 --> 00:29:46.390
And turns out this is
a picture of my cat.

00:29:46.390 --> 00:29:49.240
Turns out the reason for that
is because my cat's always

00:29:49.360 --> 00:29:52.160
finding things under the couch,
behind the refrigerator,

00:29:52.160 --> 00:29:53.170
inappropriate things.

00:29:53.300 --> 00:29:55.090
But he's a good finder,
so let's just use that.

00:29:55.150 --> 00:29:56.500
the cat.

00:29:57.210 --> 00:30:00.200
So to use that image,
and this is pretty typical whenever

00:30:00.200 --> 00:30:02.590
you want to use an image in your
application and you want to make it

00:30:02.740 --> 00:30:06.160
part of your application's resources,
you drag the image into

00:30:06.250 --> 00:30:08.400
Project Builder under Resources.

00:30:08.440 --> 00:30:10.240
Project Builder asks
me what to do with it.

00:30:10.340 --> 00:30:13.370
One of the important things you
might want to do is copy it into

00:30:13.440 --> 00:30:15.550
your sources and add it to my target.

00:30:15.610 --> 00:30:18.510
So now that the cat is part
of my resources along with all

00:30:18.510 --> 00:30:22.750
these other resources down here,
I can actually use this

00:30:22.750 --> 00:30:25.320
call NSImageImageNamed.

00:30:25.570 --> 00:30:27.110
Put the word cat here.

00:30:27.210 --> 00:30:30.540
So that method image named
will find any image out of your

00:30:30.540 --> 00:30:32.000
application's resource package.

00:30:32.000 --> 00:30:34.500
If it's correctly localized,
it'll find a localized version.

00:30:34.500 --> 00:30:37.640
So instead of having an Egyptian cat,
you want to have a Norwegian cat.

00:30:37.740 --> 00:30:38.520
That's OK.

00:30:38.620 --> 00:30:39.560
So you can do that.

00:30:39.740 --> 00:30:41.940
We didn't localize it here,
but that's fine.

00:30:42.000 --> 00:30:43.620
You get the idea.

00:30:43.850 --> 00:30:45.610
OK, and then we finish this
because we're done,

00:30:45.610 --> 00:30:48.660
and we return the item.

00:30:49.240 --> 00:30:50.760
It turns out that's all we need to do.

00:30:50.760 --> 00:30:53.140
Now, you might be asking,
what's this auto-release business?

00:30:53.140 --> 00:30:54.960
Again, it's got to do with
Cocoa's memory management.

00:30:54.960 --> 00:30:58.460
Because we created the item,
and because we're returning an item that

00:30:58.790 --> 00:31:02.020
the client's going to take ownership of,
we auto-release it,

00:31:02.020 --> 00:31:03.740
which means release it later.

00:31:03.740 --> 00:31:05.740
It's sort of like smart
garbage collection.

00:31:05.740 --> 00:31:07.690
And you will see this a lot,
and it's a standard

00:31:07.690 --> 00:31:08.840
part of the programming.

00:31:08.840 --> 00:31:10.440
I'm not going to go into it anymore.

00:31:10.440 --> 00:31:11.380
So that's it.

00:31:11.450 --> 00:31:15.130
And note that if you had other items,
you'd basically write code like this,

00:31:15.130 --> 00:31:18.590
or someday maybe use interface builder
and not have to do this at all.

00:31:19.280 --> 00:31:20.500
So I'm going to save.

00:31:20.500 --> 00:31:22.220
I'm going to run.

00:31:29.400 --> 00:31:31.260
Okay, hide others.

00:31:31.370 --> 00:31:34.480
Okay, there, note that when we ran it,
it remembered the old toolbar,

00:31:34.480 --> 00:31:35.780
so that seems to be working.

00:31:35.820 --> 00:31:37.240
Bring down customize.

00:31:37.300 --> 00:31:38.510
There is the find dialog.

00:31:38.680 --> 00:31:39.670
There is the cat.

00:31:39.700 --> 00:31:41.130
Let's say done.

00:31:41.180 --> 00:31:42.690
And let's see if the cat can find things.

00:31:42.910 --> 00:31:45.550
There's the find panel, so there you go.

00:31:48.200 --> 00:31:50.610
Okay, so, you know,
we could play with the

00:31:50.650 --> 00:31:52.470
toolbar all day long,
but that's okay.

00:31:52.490 --> 00:31:56.770
Let's go back to our next question.

00:31:56.770 --> 00:31:56.770
Question.

00:31:57.600 --> 00:32:00.240
How can I get a better frame
rate out of my animating game?

00:32:00.240 --> 00:32:01.890
Oh, it's a performance question.

00:32:01.900 --> 00:32:02.900
That's great.

00:32:02.900 --> 00:32:04.520
And you've been hearing
about performance all along,

00:32:04.520 --> 00:32:07.060
so let's see how, whether we can do this.

00:32:07.060 --> 00:32:10.200
Oh, demo again.

00:32:10.200 --> 00:32:10.200
Okay.

00:32:10.570 --> 00:32:12.450
Okay,
let's see about this animating game now.

00:32:12.450 --> 00:32:15.870
Let's see what it does,
what it looks like.

00:32:16.440 --> 00:32:19.500
Conveniently, it's on our dock.

00:32:19.500 --> 00:32:21.120
Ah, it's a worm game.

00:32:21.120 --> 00:32:24.310
OK,
so this game's been around for a while,

00:32:24.320 --> 00:32:25.520
I think since the '60s.

00:32:25.790 --> 00:32:28.340
And it even makes appearance
on your cell phones.

00:32:28.400 --> 00:32:29.840
You probably have seen this game.

00:32:29.840 --> 00:32:33.670
Let's run it just to
show you what it's about.

00:32:35.600 --> 00:32:48.300
[Transcript missing]

00:32:49.490 --> 00:32:50.120
Oh, yeah.

00:32:50.120 --> 00:32:51.680
And when he eats it, he grows by one dot.

00:32:51.820 --> 00:32:54.520
So as he gets longer and longer,
it becomes harder to manage it.

00:32:54.520 --> 00:32:56.180
And eventually, it hits itself and dies.

00:32:56.180 --> 00:32:58.320
And obviously, the more you eat,
the more you get.

00:32:58.320 --> 00:33:00.590
And typically, the worm,
when it hits the edges, would die.

00:33:00.700 --> 00:33:02.700
But we simplified the game
here for demo purposes,

00:33:02.700 --> 00:33:05.580
because I don't want to spend
too much time playing the game.

00:33:05.580 --> 00:33:10.540
So this slider here allows
us to change the frame rate.

00:33:10.540 --> 00:33:13.470
And I'm setting the frame
rate to a really high number.

00:33:13.480 --> 00:33:16.520
And you can see I'm
getting 38 frames a second.

00:33:16.520 --> 00:33:18.360
Now,
that seems good enough for this game.

00:33:18.360 --> 00:33:20.890
Well, I mean, this person's quite
worried about performance.

00:33:21.010 --> 00:33:23.120
But it's actually good to be
worried about performance.

00:33:23.120 --> 00:33:25.620
Even if your frame rate is good,
trying to speed it up means that

00:33:25.710 --> 00:33:28.080
there's more processor power in
the machine for other things.

00:33:28.080 --> 00:33:29.480
And you can be doing
other things in the back.

00:33:29.650 --> 00:33:32.140
So let's see whether we
can help this person out.

00:33:32.140 --> 00:33:37.040
Now, one thing you'll notice here is that
this whole area seems to be white.

00:33:37.040 --> 00:33:39.830
And we don't see any of
the window background.

00:33:40.450 --> 00:33:44.290
Typically, when you subclass a view,
you either draw everything in your

00:33:44.290 --> 00:33:46.340
bounds or you draw less than everything.

00:33:46.340 --> 00:33:49.420
Now, if you draw everything,
one thing you can do is tell the

00:33:49.420 --> 00:33:51.990
view subsystem that you really
don't want anything behind you to be

00:33:52.000 --> 00:33:53.490
drawn whenever you're being drawn.

00:33:53.500 --> 00:33:56.080
And the way to do that is to
implement one method in view.

00:33:56.080 --> 00:33:58.760
Now, whenever you're doing a drawing,
a subclass of view,

00:33:58.760 --> 00:34:00.880
a drawing application,
this is the first thing

00:34:00.880 --> 00:34:02.000
you should look for.

00:34:02.010 --> 00:34:04.390
And that's to implement this
method called isOpake to tell

00:34:04.500 --> 00:34:05.870
the system that you're opaque.

00:34:05.930 --> 00:34:07.650
That's the first thing we're going to do.

00:34:07.650 --> 00:34:10.220
Let's see if that will help us.

00:34:10.220 --> 00:34:14.490
Now, we go to our subclass of view,
in this case, worm view.

00:34:14.680 --> 00:34:18.500
And it's some fairly
involved little view class.

00:34:18.500 --> 00:34:21.710
There's also a controller class to
control the UI and the worm guts,

00:34:21.760 --> 00:34:23.800
which controls the logic of the game.

00:34:23.820 --> 00:34:24.610
Let me close this up.

00:34:24.640 --> 00:34:27.780
So this is, again, a standard view,
you know, init with frame.

00:34:27.780 --> 00:34:28.700
There's a dialog.

00:34:28.700 --> 00:34:31.000
There's a method to set the
string and get the string.

00:34:31.000 --> 00:34:31.340
Oh, yeah.

00:34:31.340 --> 00:34:34.000
If you notice,
the worm's body was made up of a string.

00:34:34.000 --> 00:34:36.690
That seems odd, but, you know,
there's a reason for

00:34:36.700 --> 00:34:38.020
that later in the demo.

00:34:40.010 --> 00:34:42.660
There's a method that performs
each frame of the animation.

00:34:42.660 --> 00:34:44.700
And finally,
there is the drawRect method.

00:34:44.790 --> 00:34:47.580
drawRect, again,
is the method you override to do drawing.

00:34:47.670 --> 00:34:52.840
Now, if we bring up our Find panel
and search for isOpaque,

00:34:52.930 --> 00:34:54.260
we see that it's not implemented.

00:34:54.380 --> 00:34:57.500
So the first thing we should
do is go implement that.

00:34:57.570 --> 00:34:59.560
It's implemented just like
this isFlipped method.

00:34:59.560 --> 00:35:03.380
It's so easy,
I don't need my typing assistant.

00:35:03.980 --> 00:35:12.470
is opaque.

00:35:12.470 --> 00:35:12.470
So we implement it and we return yes,
because the default

00:35:12.470 --> 00:35:12.470
implementation returns no.

00:35:12.470 --> 00:35:12.470
And this basically says--

00:35:12.930 --> 00:35:15.430
that when this view is being drawn,
don't worry about drawing

00:35:15.480 --> 00:35:18.060
anything that's behind it,
because this view will take care

00:35:18.200 --> 00:35:19.680
of every pixel within its bounds.

00:35:19.720 --> 00:35:22.040
So let's run this little puppy.

00:35:22.120 --> 00:35:22.790
Oh, look at that.

00:35:22.920 --> 00:35:23.950
44 frames a second.

00:35:23.960 --> 00:35:28.470
So just that one little line
got us up from 37 to 43,

00:35:28.890 --> 00:35:29.370
42.

00:35:29.380 --> 00:35:30.500
That's pretty good.

00:35:30.770 --> 00:35:34.040
But I have a feeling this
is not going to be enough.

00:35:34.100 --> 00:35:36.300
Let's hide the project builder.

00:35:36.390 --> 00:35:38.960
So next thing you might want
to do is run Quartz debug,

00:35:39.100 --> 00:35:41.660
which you saw earlier in the week,
I hope.

00:35:41.760 --> 00:35:44.090
Quartz Debug shows you
which areas are being drawn.

00:35:44.100 --> 00:35:46.010
Let's kick it on.

00:35:46.510 --> 00:35:49.000
OK, so again, obvious.

00:35:49.000 --> 00:35:52.530
This might have been a rigged demo,
but it's obvious that the worm is

00:35:52.600 --> 00:35:54.780
drawing the whole view every time.

00:35:55.020 --> 00:35:57.580
The yellow area shows the
area that's being updated.

00:35:57.610 --> 00:36:00.640
While you really want
the worm to only draw

00:36:01.080 --> 00:36:03.900
The area that's being updated.

00:36:03.900 --> 00:36:05.680
So that's the next
optimization we can do.

00:36:05.680 --> 00:36:07.760
So let's quit the worm.

00:36:07.760 --> 00:36:13.470
Let's hide Quartz debug and let's
go back to our worm application.

00:36:13.720 --> 00:36:17.060
Now there are two pieces to
drawing less than your whole view.

00:36:17.080 --> 00:36:21.770
One is to make sure that when you
tell the view it needs to be updated,

00:36:21.770 --> 00:36:24.790
you tell it what region or what
rectangle needs to be updated.

00:36:24.800 --> 00:36:26.980
And the second thing is
in your drawing method,

00:36:26.980 --> 00:36:28.550
pay attention to that rectangle.

00:36:28.790 --> 00:36:31.170
So we'll do both of these right now.

00:36:31.470 --> 00:36:33.290
So the first one happens here.

00:36:33.370 --> 00:36:36.840
In the perform animation method,
we say self set needs display, yes.

00:36:36.840 --> 00:36:39.200
That just says, I'm dirty, redraw me.

00:36:39.270 --> 00:36:42.000
And it gets drawn later
on whenever appropriate.

00:36:42.050 --> 00:36:44.290
So instead of doing that,
we have to compute a smaller,

00:36:44.290 --> 00:36:45.000
a tighter rect.

00:36:45.100 --> 00:36:46.840
And let's see how we might do that.

00:36:46.840 --> 00:36:51.640
Now some of the stuff here has
to do with the worm's logic,

00:36:51.940 --> 00:36:53.920
but basically what we want

00:36:54.780 --> 00:36:56.800
Let me push these lines down a bit.

00:36:56.870 --> 00:36:58.900
I want to start with Erect.

00:36:58.970 --> 00:37:01.800
And I'm going to remember
the old target position.

00:37:01.920 --> 00:37:07.310
and I wanna for the length of the worm,
I want to look at every position every

00:37:07.310 --> 00:37:10.720
body position of the worm I want to
figure out what the rectangle is,

00:37:10.720 --> 00:37:14.160
I want to union into my rectangle so
as a result of this operation I end

00:37:14.160 --> 00:37:18.260
up getting a rectangle which tightly
covers the worm okay so again you know

00:37:18.370 --> 00:37:22.150
that little method there returns the
worms body and so on so this allows us

00:37:22.150 --> 00:37:25.250
to create the tight body around the worm

00:37:25.700 --> 00:37:29.820
Then we update the game state,
meaning we move the worm.

00:37:29.830 --> 00:37:33.120
Now it turns out we know that the
worm only moves one block per frame,

00:37:33.200 --> 00:37:37.850
so after the game has updated the frame,
we can go ahead and union

00:37:37.850 --> 00:37:39.380
the new head position.

00:37:39.380 --> 00:37:42.420
Again, the worm's head moves,
so we also want to bring that

00:37:42.420 --> 00:37:45.720
rectangle into the whole rectangle
so our rectangle grows a bit.

00:37:45.730 --> 00:37:49.720
There's one more thing we need to
do to compute the tight rectangle.

00:37:49.730 --> 00:37:52.380
and that is to see if the
target changed position,

00:37:52.380 --> 00:37:54.480
meaning if the worm ate the target,
it moved.

00:37:54.480 --> 00:37:56.900
So let's also union that in.

00:37:56.920 --> 00:38:00.900
If the old position is not
equal to the new position,

00:38:00.960 --> 00:38:04.040
we go ahead and union
in the target position.

00:38:04.040 --> 00:38:05.080
So I hope this makes sense.

00:38:05.080 --> 00:38:08.500
Now we have a rect that includes
the target and the worm.

00:38:08.520 --> 00:38:10.040
It only includes the
target if the target moved,

00:38:10.040 --> 00:38:13.260
which is rare enough, so that's OK.

00:38:13.260 --> 00:38:17.350
And the final thing we have to do
is instead of set needs display,

00:38:17.460 --> 00:38:20.780
we call set needs display
in rect and pass that rect.

00:38:20.780 --> 00:38:24.480
So now that tells the view machinery
just draw the smaller rect.

00:38:24.480 --> 00:38:25.780
So let's save.

00:38:25.780 --> 00:38:28.870
The next thing we want to
do is modify our draw rect.

00:38:28.980 --> 00:38:30.960
Note that draw rect is
taking a rect argument,

00:38:30.960 --> 00:38:33.800
but nowhere in here it's
really being paid attention to.

00:38:33.820 --> 00:38:36.150
Again, sloppy programming.

00:38:36.180 --> 00:38:38.960
First thing we want to do is
this is the background drawing,

00:38:38.960 --> 00:38:41.840
and we do a rect fill
of the whole bounds.

00:38:41.960 --> 00:38:45.380
Self bounds means my whole bounds.

00:38:45.390 --> 00:38:47.140
Here, self is the view.

00:38:47.140 --> 00:38:48.380
So instead of self bounds,
we're going to do a rect

00:38:48.380 --> 00:38:48.380
fill of the whole bounds.

00:38:48.380 --> 00:38:51.580
So instead We really
want to pass in rect.

00:38:52.200 --> 00:39:12.800
[Transcript missing]

00:39:13.110 --> 00:39:19.440
All the time, unconditionally,
let's do it if the rect intersects

00:39:19.440 --> 00:39:21.280
the rectangle that was passed in.

00:39:21.370 --> 00:39:22.330
Okay, does that make sense?

00:39:22.340 --> 00:39:26.090
Again, we only draw it if the
worm is in that region.

00:39:27.240 --> 00:39:28.520
Again, pretty straightforward.

00:39:28.600 --> 00:39:32.600
This will intersect the two rects
and return to you yes or no.

00:39:32.780 --> 00:39:34.440
Finally, the same thing with the target.

00:39:34.600 --> 00:39:39.650
If the target rect happens to
be in that rect we passed in,

00:39:39.790 --> 00:39:41.750
we'll just go ahead.

00:39:44.870 --> 00:39:48.340
will only do it if the
target is also in that box.

00:39:48.340 --> 00:39:49.520
OK?

00:39:49.580 --> 00:39:51.030
So I'm going to save.

00:39:51.050 --> 00:39:52.600
I'm going to run.

00:39:58.820 --> 00:40:02.270
OK, here's the moment of truth.

00:40:02.330 --> 00:40:04.540
OK, so there's 85.

00:40:04.540 --> 00:40:05.740
I think that's fast enough.

00:40:05.740 --> 00:40:07.100
Do you think so?

00:40:07.100 --> 00:40:08.630
Agree?

00:40:08.700 --> 00:40:09.630
OK, good.

00:40:09.660 --> 00:40:10.900
So there you go.

00:40:10.910 --> 00:40:15.350
We've now made the game quite unplayable,
but it's also very fast,

00:40:15.350 --> 00:40:21.900
so I think this person should be
pretty satisfied with this performance.

00:40:21.900 --> 00:40:26.380
OK, so let's go back to the slides,
please.

00:40:27.580 --> 00:40:29.250
Okay,
so what we learned from here is that

00:40:29.340 --> 00:40:31.300
you want to draw as little as possible.

00:40:31.300 --> 00:40:34.000
One thing that means is you
should fine tune the drawing area,

00:40:34.000 --> 00:40:36.500
the update area, and you should also
pay attention to that.

00:40:36.530 --> 00:40:39.820
You should also use isOpaque to prevent
super views from drawing needlessly.

00:40:39.870 --> 00:40:42.950
Those are probably two most obvious
things you can do to speed up drawing.

00:40:42.980 --> 00:40:45.470
And also use Quartz Drawing
to see what's drawing.

00:40:45.630 --> 00:40:48.290
Sometimes you might find something
very surprising like some text field

00:40:48.410 --> 00:40:50.970
is being updated every so often
and you don't even know about it.

00:40:50.970 --> 00:40:53.730
Or as Robert showed on Monday,
even when paused,

00:40:53.870 --> 00:40:56.020
his application still kept on drawing.

00:40:56.020 --> 00:41:00.760
There are things like that that
Quartz debug will tell you.

00:41:00.790 --> 00:41:02.500
Next question.

00:41:24.490 --> 00:41:24.490
But still not good enough for my boss.

00:41:24.490 --> 00:41:24.490
Can I make it draw even faster?

00:41:24.490 --> 00:41:24.490
Okay.

00:41:24.490 --> 00:41:24.490
So that's interesting.

00:41:24.490 --> 00:41:24.490
We'll see if we can make
it draw a little faster.

00:41:24.490 --> 00:41:24.490
I think the thing to do at
this point is to see whether

00:41:24.490 --> 00:41:24.490
we can see what the problem is.

00:41:24.490 --> 00:41:24.490
So let's go back to demo again.

00:41:24.490 --> 00:41:24.490
And we'll now use another
performance tool quickly.

00:41:24.490 --> 00:41:24.490
Let's run it.

00:41:29.300 --> 00:41:30.740
Let's launch Sampler.

00:41:30.750 --> 00:41:32.360
Again,
I think you heard enough about Sampler

00:41:32.360 --> 00:41:34.990
that I'm not going to go into details.

00:41:36.640 --> 00:41:38.950
With Sampler you can attach
to a running program.

00:41:38.960 --> 00:41:39.940
I'm going to do that.

00:41:39.960 --> 00:41:43.210
I'm going to choose Worm
and I'm going to say OK.

00:41:43.650 --> 00:41:44.810
You've seen samplers.

00:41:44.870 --> 00:41:47.160
I'm not talking too much about it,
but what it's going to do is it's going

00:41:47.160 --> 00:41:50.480
to sample the target app every so often,
every 20 milliseconds,

00:41:50.480 --> 00:41:51.310
and capture the stack.

00:41:51.430 --> 00:41:55.420
That's going to give us an idea of where
the application is spending its time.

00:41:55.520 --> 00:41:56.840
Let's put this down here.

00:41:56.970 --> 00:41:58.040
Let's say start.

00:41:58.040 --> 00:41:58.870
There you go.

00:41:58.890 --> 00:42:00.600
Let's say start sampling.

00:42:00.670 --> 00:42:02.430
Then you sort of pace
back and forth a bit,

00:42:02.460 --> 00:42:03.340
get some coffee.

00:42:03.390 --> 00:42:04.440
It's sampling the worm.

00:42:04.440 --> 00:42:06.170
You can say stop.

00:42:06.170 --> 00:42:09.190
Let's stop the worm here.

00:42:09.580 --> 00:42:11.690
Okay, so this is now the biggest stack.

00:42:11.900 --> 00:42:14.260
Now you can actually go down
the tree here and look at all

00:42:14.260 --> 00:42:15.570
the things that are happening.

00:42:15.600 --> 00:42:17.500
But this turns out to
be the biggest stack.

00:42:17.500 --> 00:42:19.480
Let's go back.

00:42:19.510 --> 00:42:22.100
And if you look down here,

00:42:23.200 --> 00:42:25.630
It's main, it's application run.

00:42:25.670 --> 00:42:27.530
These are the standard
Objective-C things,

00:42:27.730 --> 00:42:30.100
standard Cocoa things,
which are part of the frameworks.

00:42:30.100 --> 00:42:33.030
And here the worm timer callback,
this is your code.

00:42:33.080 --> 00:42:35.640
And here we're displaying the view.

00:42:35.640 --> 00:42:38.110
And it turns out the biggest
thing we're doing in displaying,

00:42:38.110 --> 00:42:41.060
and you would expect the displaying
to be taking the longest time.

00:42:41.060 --> 00:42:43.460
The question is,
what is the displaying so slow?

00:42:43.460 --> 00:42:46.690
Turns out the biggest
thing here is NSString,

00:42:46.690 --> 00:42:49.220
string drawing, draw and rect.

00:42:49.220 --> 00:42:52.460
So the most time, in fact,
of all the drawing that's happening,

00:42:52.460 --> 00:42:56.690
90 something percent of the time
is spent in drawing that string.

00:42:56.740 --> 00:42:57.700
Okay?

00:42:57.700 --> 00:43:00.700
So maybe that's something we can look at.

00:43:00.700 --> 00:43:04.690
Okay, so let's go take a look at that.

00:43:07.300 --> 00:43:14.900
To draw short little
strings here and there,

00:43:14.900 --> 00:43:16.660
you would use this API in NSString.

00:43:16.660 --> 00:43:18.440
Draw and rect with attributes.

00:43:18.480 --> 00:43:20.360
It's the rectangle,
and the attributes include

00:43:20.360 --> 00:43:24.770
stuff like the font,
the color, everything else a style

00:43:25.120 --> 00:43:27.160
text would need to know.

00:43:27.180 --> 00:43:29.880
This method is very convenient,
and you should use it if you need

00:43:29.890 --> 00:43:31.290
to draw strings here and there.

00:43:31.520 --> 00:43:35.700
But it does do a lot
of work under covers.

00:43:35.700 --> 00:43:39.650
One of the things you need to
do when you're drawing true

00:43:39.650 --> 00:43:41.790
Unicode text is that you need

00:43:42.640 --> 00:43:44.460
You need to take the Unicode string.

00:43:44.490 --> 00:43:47.040
You need to convert it
into what's called glyphs,

00:43:47.060 --> 00:43:50.740
and then you need to lay those glyphs out
and you need to send them to the screen.

00:43:50.780 --> 00:43:54.280
So it's not just a simple matter of
taking the Unicode characters out of

00:43:54.280 --> 00:43:56.590
the string and blasting to the screen.

00:43:56.790 --> 00:43:59.730
The reason for this is Unicode
text is fairly complicated,

00:43:59.870 --> 00:44:03.870
and you basically need to convert those
Unicodes into elements in the font,

00:44:03.870 --> 00:44:05.360
which are called glyphs.

00:44:05.380 --> 00:44:07.850
And sometimes,
like a three-character Unicode string

00:44:07.860 --> 00:44:11.170
might correspond to five glyphs,
or it might correspond to one glyph,

00:44:11.170 --> 00:44:12.940
because there might be a special glyph.

00:44:12.940 --> 00:44:14.820
Some languages are actually
even more complicated.

00:44:14.820 --> 00:44:19.360
So that's why the text layout
machinery actually does a lot of work.

00:44:19.370 --> 00:44:22.720
In addition, there's a lot of work that
needs to set up just to start

00:44:22.820 --> 00:44:24.600
that operation and end it.

00:44:24.600 --> 00:44:28.680
So the string drawing is convenient,
but because it's called with no context,

00:44:28.680 --> 00:44:31.520
it does a lot of work repeatedly.

00:44:31.520 --> 00:44:35.600
So here, we can try using the text system
for some performance gain.

00:44:35.710 --> 00:44:37.240
And to do that,
let's look at the text system

00:44:37.240 --> 00:44:39.350
architecture rather quickly.

00:44:39.440 --> 00:44:41.120
you might have seen this before.

00:44:41.150 --> 00:44:43.270
The COCO-TEX system--

00:44:44.090 --> 00:44:46.960
is a network of objects.

00:44:47.030 --> 00:44:49.440
Typically when you're using
it in an interface builder,

00:44:49.440 --> 00:44:54.870
you're taking an instance of NSTextView,
dropping it into your application,

00:44:54.890 --> 00:44:58.000
and it creates everything else for you,
and then you're fiddling with that.

00:44:58.000 --> 00:45:02.000
But these other objects are also
available for you to use directly.

00:45:02.000 --> 00:45:05.980
TextStorage is the model object.

00:45:05.990 --> 00:45:09.000
It stores the characters
and their attributes.

00:45:09.000 --> 00:45:14.000
LayoutManager computes and stores
the glyphs and their locations.

00:45:14.000 --> 00:45:17.980
So the LayoutManager is sort of
like the controller in this picture.

00:45:18.540 --> 00:45:22.400
Text container provides
text area information.

00:45:22.400 --> 00:45:26.130
So in fact, in this picture,
you can imagine a layout manager with

00:45:26.130 --> 00:45:30.200
multiple text containers if you are doing
a multi-column text editing application,

00:45:30.200 --> 00:45:31.050
for instance.

00:45:31.130 --> 00:45:35.930
In the text view, the final piece,
the piece you see in interface builder,

00:45:35.930 --> 00:45:38.830
the visible piece,
is the piece that handles

00:45:38.830 --> 00:45:40.730
the display and editing.

00:45:41.520 --> 00:45:43.660
Now note that, again,
this allows us to do fairly

00:45:43.700 --> 00:45:44.980
sophisticated things.

00:45:45.050 --> 00:45:46.450
For instance,
you can have one text storage,

00:45:46.450 --> 00:45:47.890
you can have three layout managers.

00:45:47.990 --> 00:45:50.820
What this means is you can
have a same text document,

00:45:51.080 --> 00:45:53.570
but it has three different views on it.

00:45:53.600 --> 00:45:55.420
So one could be a wide view,
one could be a short view,

00:45:55.500 --> 00:45:58.000
one could be a view without fonts,
and so on.

00:45:58.140 --> 00:46:00.710
Similarly, multiple text containers,
as I said,

00:46:00.740 --> 00:46:03.150
allow you to have multiple pages,
multiple

00:46:03.340 --> 00:46:07.800
Turns out that here,
the interesting piece I want

00:46:07.800 --> 00:46:09.720
to use is the Layout Manager.

00:46:09.840 --> 00:46:11.800
It gets the text contents
from text storage,

00:46:11.800 --> 00:46:12.700
as I said.

00:46:12.700 --> 00:46:17.400
It converts these characters into glyphs,
and it computes the glyph locations.

00:46:17.400 --> 00:46:19.410
And what we really want in
this case is we want to use the

00:46:19.410 --> 00:46:22.180
glyphs and the glyph locations,
and we don't want this relay

00:46:22.180 --> 00:46:23.740
out to happen over and over.

00:46:23.780 --> 00:46:26.140
And then finally,
you would get a layout manager to draw

00:46:26.200 --> 00:46:29.930
these glyphs by calling this method
"draw glyphs for glyph range." And that's

00:46:29.990 --> 00:46:32.390
usually called by the text view layer.

00:46:32.660 --> 00:46:36.720
So let's see how we can make use of
Layout Manager in our application.

00:46:36.790 --> 00:46:39.460
First thing we want to do--
let's get rid of this-- is we

00:46:39.460 --> 00:46:43.470
want to go into our vrm_view.h,
which is the header file

00:46:43.470 --> 00:46:45.440
which declares the object.

00:46:45.470 --> 00:46:49.810
And we want to create three-- we want
to declare three new instance variables.

00:46:50.460 --> 00:46:52.630
Text Storage, Layout Manager,
and Text Container.

00:46:52.640 --> 00:46:54.440
So those are the three
objects we talked about.

00:46:54.440 --> 00:46:57.070
So instead of using TextView,
we don't need TextView.

00:46:57.280 --> 00:47:00.440
We're just going to use those
three objects at the bottom.

00:47:00.510 --> 00:47:01.200
So we create them.

00:47:01.200 --> 00:47:04.160
Let's save our header file,
and let's switch back.

00:47:04.170 --> 00:47:06.260
Now in the init method--

00:47:06.780 --> 00:47:08.700
where we create various stuff.

00:47:08.730 --> 00:47:12.340
We now want to go ahead and
create those three objects.

00:47:12.350 --> 00:47:15.140
And it turns out it's
fairly easy to create them.

00:47:15.650 --> 00:47:17.770
Text Storage Outlock In It,
Layout Manager Outlock In It,

00:47:17.950 --> 00:47:19.420
Text Container Outlock In It.

00:47:19.420 --> 00:47:21.880
We don't want to provide any
sophisticated attributes.

00:47:21.880 --> 00:47:22.480
You can do that.

00:47:22.480 --> 00:47:23.860
You can provide sizes.

00:47:23.900 --> 00:47:26.360
You can provide various other properties.

00:47:26.360 --> 00:47:28.940
We don't need to deal
with this right now.

00:47:28.940 --> 00:47:31.510
And then we want to add to the
Layout Manager the Text Container.

00:47:31.510 --> 00:47:33.370
We want to add to the
Storage the Layout Manager.

00:47:33.400 --> 00:47:36.080
Again,
the API says add and not set because

00:47:36.080 --> 00:47:37.930
you can have multiple Layout Managers.

00:47:37.930 --> 00:47:39.920
You can have multiple containers.

00:47:39.920 --> 00:47:43.660
So this is all we need to create
a subset of the text system.

00:47:43.660 --> 00:47:45.670
Again, note that when you create a
text view programmatically

00:47:45.770 --> 00:47:48.820
or through Interface Builder,
all this is done for you magically

00:47:48.840 --> 00:47:53.480
because that is really the most
common use of the text system.

00:47:54.680 --> 00:47:56.960
OK, now,
because we created those three objects,

00:47:56.960 --> 00:47:59.390
we should remember to release them.

00:47:59.440 --> 00:48:02.140
So whenever our object goes away,
we release the three things we created.

00:48:02.140 --> 00:48:03.960
That's fairly straightforward.

00:48:04.010 --> 00:48:05.450
Now comes the tricky part.

00:48:05.530 --> 00:48:09.000
Set string is where a new
string is provided for the worm.

00:48:09.040 --> 00:48:12.510
Note that this happens very rarely,
because the string is

00:48:12.510 --> 00:48:13.990
not really changing.

00:48:14.880 --> 00:48:17.290
So what we want to do is
whenever we get a new string,

00:48:17.380 --> 00:48:20.900
in addition to remembering that string,
we actually want to pour

00:48:20.900 --> 00:48:24.970
it into this text system,
that mini text object we created.

00:48:25.660 --> 00:48:28.230
And to do that,
I would tell the worm storage

00:48:28.240 --> 00:48:31.600
object that its string is
the worm string that I have.

00:48:31.620 --> 00:48:33.380
In addition,
I would tell the worm storage

00:48:33.600 --> 00:48:35.100
what the attributes are.

00:48:35.100 --> 00:48:38.100
Now, this worm text attributes
comes from up here,

00:48:38.100 --> 00:48:40.340
and again,
I said it's the style information.

00:48:40.340 --> 00:48:42.450
In this case,
it just stores the fact that

00:48:42.450 --> 00:48:44.360
the font is Lucida Grande 16.

00:48:44.360 --> 00:48:46.100
I'm not going to go into that.

00:48:46.100 --> 00:48:49.220
So, anytime a new string comes in,
we reinitialize our text system with

00:48:49.220 --> 00:48:51.100
the new string and the new attributes.

00:48:51.100 --> 00:48:51.940
That's it.

00:48:51.940 --> 00:48:54.090
That's all we need to do there.

00:48:54.140 --> 00:48:56.090
Okay, so that takes care of that piece.

00:48:56.090 --> 00:49:01.100
And finally, in the drawing,
instead of doing this string draw on rec,

00:49:01.100 --> 00:49:05.100
which we know is not fast enough,
we want to use Layout Manager to draw.

00:49:05.120 --> 00:49:08.110
Okay,
so instead of doing this character stuff,

00:49:08.110 --> 00:49:10.040
let's open up some space here.

00:49:10.040 --> 00:49:11.880
Let's push this to the top.

00:49:12.650 --> 00:49:14.490
I'm going to work in terms of glyphs.

00:49:14.590 --> 00:49:16.650
I'm going to ask the glyph location.

00:49:16.650 --> 00:49:17.920
And I'm going to do draw on glyphs.

00:49:17.920 --> 00:49:19.040
Now ignore this code here.

00:49:19.040 --> 00:49:21.240
I could explain it,
but it's really pretty straightforward.

00:49:21.290 --> 00:49:24.260
What's happening here is instead
of drawing the character,

00:49:24.260 --> 00:49:26.080
instead of drawing each
character one by one,

00:49:26.080 --> 00:49:29.630
as we would do down here,
we're now drawing each glyph one by one.

00:49:29.690 --> 00:49:31.970
And for that,
we're going to the layout manager.

00:49:32.070 --> 00:49:33.740
And I can get rid of this code.

00:49:33.740 --> 00:49:35.380
So the old code and the
new code are very similar.

00:49:35.380 --> 00:49:40.080
It's just that one is a slightly lower
level talking to the layout manager.

00:49:40.080 --> 00:49:41.590
And it turns out this is
all we really need to do.

00:49:41.590 --> 00:49:43.370
And again,
I'm saying all we really need to do,

00:49:43.460 --> 00:49:46.210
but this is actually fairly
sophisticated stuff because you

00:49:46.210 --> 00:49:50.180
have to dig down in there into the
tech system and it could get messy.

00:49:50.240 --> 00:49:56.140
But let's see if it gives
us the performance we want.

00:49:56.140 --> 00:49:56.590
Let's build and run.

00:50:05.900 --> 00:50:07.440
Okay.

00:50:07.440 --> 00:50:08.290
Oh, look at that.

00:50:08.410 --> 00:50:11.970
So I think that's good enough
for this person right now.

00:50:17.690 --> 00:50:19.640
At this point,
I'm getting really sick of the worm.

00:50:19.720 --> 00:50:25.020
Hey, that's sweet.

00:50:26.600 --> 00:50:43.600
[Transcript missing]

00:50:44.520 --> 00:50:46.000
There's this big white area.

00:50:46.000 --> 00:50:46.890
That's quite boring, right?

00:50:46.980 --> 00:50:48.860
So we can add some color to it.

00:50:48.910 --> 00:50:51.940
Now, if we go back to our draw rect,
which is here,

00:50:51.940 --> 00:50:55.560
one thing you notice is that
we do an sColorWhiteColorSet.

00:50:55.600 --> 00:50:56.690
That makes the background white.

00:50:56.730 --> 00:50:58.980
Well, obviously,
we could add pizzazz in there

00:50:58.980 --> 00:51:01.890
very quickly by making this red
or yellow or anything you want,

00:51:01.890 --> 00:51:05.390
but that wouldn't be enough pizzazz,
I don't think, for this person.

00:51:05.400 --> 00:51:07.770
So let's do something fancier.

00:51:07.770 --> 00:51:12.400
Instead of color, we might want to use
an image or a pattern.

00:51:12.400 --> 00:51:15.740
One good place to find
images or patterns--well,

00:51:15.740 --> 00:51:17.800
there's a cat, but other than that--

00:51:18.770 --> 00:51:24.200
If you go into the desktop
pictures folder on your disk,

00:51:24.210 --> 00:51:26.020
there's a bunch of nice pictures.

00:51:26.200 --> 00:51:27.480
Here's one.

00:51:27.530 --> 00:51:28.440
There's another one.

00:51:28.490 --> 00:51:29.210
So on.

00:51:29.320 --> 00:51:32.900
Now one that I like that will
work probably in this case is

00:51:32.940 --> 00:51:34.100
one of these ripple patterns.

00:51:34.100 --> 00:51:35.480
Now I don't know if you can see it there.

00:51:35.480 --> 00:51:37.540
It's a nice little pattern
with a little thing.

00:51:37.600 --> 00:51:39.530
And so instead of using an image,
let's use a pattern.

00:51:39.540 --> 00:51:41.550
And let's see how easy or hard that is.

00:51:41.890 --> 00:51:44.670
Now as I showed earlier,
we want to drag this image

00:51:45.240 --> 00:51:47.720
into our-- let's get this back.

00:51:47.770 --> 00:51:50.530
We want to drag this into our
application like we did earlier.

00:51:50.570 --> 00:51:52.480
Let's copy it in as resources.

00:51:52.510 --> 00:51:53.270
We want to copy it.

00:51:53.430 --> 00:51:54.560
We want to say add.

00:51:54.630 --> 00:52:01.330
So now again, this image, ripplesmos.jpg,
is part of my application now.

00:52:01.450 --> 00:52:03.620
And now let's go ahead and use it.

00:52:04.150 --> 00:52:08.010
Turns out, to use a pattern,
you can use NSColors.

00:52:08.260 --> 00:52:10.160
So therefore,
this logic here of setting a

00:52:10.260 --> 00:52:14.140
color and drawing with it doesn't
really need to change very much.

00:52:14.150 --> 00:52:18.370
Let's go back to VIRM view,
and let's add an instance variable.

00:52:19.500 --> 00:52:21.340
for the color.

00:52:21.340 --> 00:52:23.210
So now we have an additional
instance variable on top of

00:52:23.210 --> 00:52:27.920
everything else we did called color.

00:52:27.920 --> 00:52:32.640
Now back in our VermView implementation
where we create all this other stuff,

00:52:34.480 --> 00:52:37.460
Let's go ahead and create that color.

00:52:37.460 --> 00:52:41.320
That requires one somewhat long line,
but there it is.

00:52:41.480 --> 00:52:43.000
What we're doing here
is like we did before,

00:52:43.000 --> 00:52:46.560
we do an image named RipplesMoss,
which takes that image that

00:52:46.600 --> 00:52:48.400
corresponds to that thing.

00:52:48.500 --> 00:52:51.390
And when we make this call to NSColor
saying color with pattern image,

00:52:51.390 --> 00:52:55.400
that says create a color using
this image as the pattern.

00:52:55.540 --> 00:52:58.400
And then we retain it because
we're going to hold on to it,

00:52:58.400 --> 00:53:01.390
and that becomes this new color
instance variable we created.

00:53:01.480 --> 00:53:04.100
Now, again, being a good citizen,
you want to release

00:53:04.100 --> 00:53:05.220
that when you go away.

00:53:05.400 --> 00:53:09.370
And finally, down in our draw rect,
instead of this red color,

00:53:09.480 --> 00:53:13.390
which wasn't too creative,
we'll use color.

00:53:13.430 --> 00:53:14.400
Okay?

00:53:14.400 --> 00:53:16.120
Let me save.

00:53:23.770 --> 00:53:25.920
Look at that.

00:53:25.920 --> 00:53:28.410
Let's also set the speed down
to something nice and let's run.

00:53:28.430 --> 00:53:30.320
Actually,
you can set the speed to something high

00:53:30.340 --> 00:53:33.880
and you see that the frame rate actually
isn't really suffering because of this.

00:53:34.000 --> 00:53:35.990
Maybe just a bit,
but it's a whole pattern.

00:53:36.170 --> 00:53:38.690
Note that this is a pattern and
it's being drawn continuously.

00:53:38.690 --> 00:53:41.460
If I make the window larger,
you actually see the

00:53:41.460 --> 00:53:43.250
pattern again working there.

00:53:43.330 --> 00:53:47.400
Just by using an image for the pattern,
just with one extra line of code,

00:53:47.400 --> 00:53:51.310
you're able to use patterns instead
of colors in your application.

00:53:51.310 --> 00:53:52.620
That's fairly straightforward.

00:53:56.900 --> 00:53:59.900
OK, let me say some words about NSColor.

00:53:59.900 --> 00:54:02.240
NSColor, therefore,
not only represents colors,

00:54:02.240 --> 00:54:05.920
but represents meta colors,
catalog colors, patterns, et cetera.

00:54:05.920 --> 00:54:09.260
And to paint with any one of those,
you just do NSColorSet.

00:54:09.260 --> 00:54:11.320
And here are some of
the interesting methods.

00:54:11.320 --> 00:54:15.800
We just saw a color with pattern image.

00:54:15.800 --> 00:54:17.780
Another one, which we saw,
is white color.

00:54:17.780 --> 00:54:19.220
That just gives you the white color.

00:54:19.220 --> 00:54:22.320
You have red color, orange color,
blue color, whatever.

00:54:22.320 --> 00:54:24.440
You can create a color
with your own RGB values,

00:54:24.440 --> 00:54:25.040
obviously.

00:54:25.040 --> 00:54:28.620
That's color with calibrated red, so on,
RGB, alpha.

00:54:28.620 --> 00:54:30.000
That's what you're used to.

00:54:30.000 --> 00:54:33.120
And finally, we have meta colors,
like window background color.

00:54:33.120 --> 00:54:36.140
This is the color that represents
the background color of a window.

00:54:36.140 --> 00:54:40.000
It turns out that actually returns to
the Aqua pattern if you need to use it.

00:54:40.250 --> 00:54:43.520
So again, a use of pattern in colors.

00:54:43.520 --> 00:54:44.600
OK, question.

00:54:44.600 --> 00:54:48.120
Let's see how much more
time we have for questions.

00:54:48.120 --> 00:54:50.480
So how does the magic
typing assistant work?

00:54:50.510 --> 00:54:52.770
Glad you asked.

00:54:54.170 --> 00:54:56.260
Okay, the answer is services.

00:54:56.500 --> 00:54:58.000
Okay,
and some of you might have guessed that

00:54:58.000 --> 00:55:00.880
if you were seeing the little menu flash.

00:55:02.370 --> 00:55:04.910
Services allow applications
to provide their functionality

00:55:04.950 --> 00:55:07.280
to other applications.

00:55:07.280 --> 00:55:09.960
And this magic code we're using
is actually a modified version

00:55:09.960 --> 00:55:11.190
of the TextEdit application.

00:55:11.210 --> 00:55:15.980
All we did is we implemented this
service where every time you invoke it,

00:55:16.070 --> 00:55:20.100
it takes the next line from the currently
open document in TextEdit and pastes

00:55:20.100 --> 00:55:22.200
it into the current location I'm at.

00:55:22.340 --> 00:55:24.830
Now, I'm not going to go into detail
on services here because the next

00:55:24.950 --> 00:55:27.670
talk actually has a little more
technical discussion of services,

00:55:27.700 --> 00:55:29.130
so I'm going to leave it there.

00:55:29.190 --> 00:55:34.900
But let me just show you what
I mean here by this little feature.

00:55:37.200 --> 00:55:38.580
OK, I'm going to quit the worm.

00:55:38.590 --> 00:55:41.480
So here we are in Project Builder again.

00:55:41.490 --> 00:55:45.860
If I click here in text,
if I go to the Services menu,

00:55:45.990 --> 00:55:49.400
you'll see that there's the standard
services you're used to seeing.

00:55:49.400 --> 00:55:52.130
And then there's this TextEdit Plus item,
which is the app I wrote,

00:55:52.130 --> 00:55:53.780
the modified version of TextEdit.

00:55:53.790 --> 00:55:56.240
In addition to the
standard TextEdit items,

00:55:56.260 --> 00:55:59.760
there's a Get Next line,
Move Down a line, and Move Up a line.

00:55:59.890 --> 00:56:02.710
And it's been assigned key equivalents,
again through services.

00:56:02.750 --> 00:56:04.220
That's fairly easy to do.

00:56:04.220 --> 00:56:06.200
So every time I go ahead
and invoke the service,

00:56:06.290 --> 00:56:08.360
Get Next line, it gets me the next line.

00:56:08.360 --> 00:56:10.460
See,
that's the line I was supposed to type,

00:56:10.460 --> 00:56:11.840
but I did it by hand.

00:56:11.840 --> 00:56:13.770
Again, I can do it.

00:56:14.350 --> 00:56:33.300
and you can I can move up by hitting that
thing and it does the same line again and

00:56:33.300 --> 00:56:33.300
again you know you can get very fast you
can see that you can do anything you want

00:56:33.300 --> 00:56:33.300
and some services work by actually taking
the current text selection and working

00:56:33.300 --> 00:56:33.300
on and returning a new thing and so on.

00:56:33.300 --> 00:56:33.300
And again I'll leave the
discussion off to the next talk.

00:56:33.300 --> 00:56:33.300
Okay.

00:56:33.300 --> 00:56:33.300
Slides please.

00:56:34.460 --> 00:56:36.220
Okay,
so let's talk about what we did today.

00:56:36.220 --> 00:56:39.120
I think we're pretty much out of time.

00:56:39.120 --> 00:56:41.060
We added Undo to an unsuspecting app.

00:56:41.080 --> 00:56:43.220
We added a customizable
toolbar to TextEdit.

00:56:43.400 --> 00:56:45.750
We made a game draw much,
much faster that was like 8X.

00:56:45.750 --> 00:56:46.720
That's pretty good.

00:56:46.750 --> 00:56:50.220
And we also learned how to use
patterns to spiffy up any app.

00:56:50.280 --> 00:56:52.760
And we saw how useful services can be.

00:56:52.840 --> 00:56:55.340
So again,
a bunch of topics and a representative

00:56:55.380 --> 00:56:58.740
set of topics that apply to
actually a lot of applications.

00:57:00.020 --> 00:57:03.790
So what we really saw is how to enhance
apps with just a few lines of code.

00:57:03.920 --> 00:57:05.440
And again, user-visible way.

00:57:05.440 --> 00:57:07.340
And you can apply this
to any application.

00:57:07.340 --> 00:57:10.280
And you also saw how to do
fairly sophisticated things

00:57:10.400 --> 00:57:11.690
with a little bit more of code.

00:57:11.700 --> 00:57:14.630
I mean that 10 lines of code
you saw where we're using

00:57:14.630 --> 00:57:16.200
the text system in depth.

00:57:16.310 --> 00:57:17.950
That's actually code you
wouldn't normally use.

00:57:17.960 --> 00:57:21.370
But again, just by diving in a bit,
learning a few more classes, and again,

00:57:21.370 --> 00:57:22.660
there's a learning curve.

00:57:22.660 --> 00:57:24.930
But learning those few classes,
you're able to do a

00:57:24.930 --> 00:57:26.180
lot more than you can.

00:57:26.180 --> 00:57:27.740
And again, those text system objects,
for instance,

00:57:27.740 --> 00:57:29.680
can be plugged in in very creative
ways to create a lot of things.

00:57:29.680 --> 00:57:30.000
Thank you.

00:57:30.020 --> 00:57:34.130
fairly interesting text editors,
not just text editors.

00:57:34.760 --> 00:57:37.330
We have a saying in Cocoa where
we've been saying this for many

00:57:37.390 --> 00:57:39.330
years and I think it's still true.

00:57:39.330 --> 00:57:42.000
We like to make simple things
simple and complex things possible.

00:57:42.000 --> 00:57:47.960
So again, just with a few lines of code,
you can come on stage and make a demo,

00:57:48.070 --> 00:57:53.320
but by writing a bunch more code,
you can actually do fairly magical things

00:57:53.320 --> 00:57:53.320
that allows you to create a fairly large,
very full-featured application.

00:57:53.850 --> 00:57:56.790
Okay,
as far as the roadmap for other talks,

00:57:56.800 --> 00:57:59.750
now if you missed these first two talks,
I think they would be very useful

00:57:59.750 --> 00:58:02.760
if you're new to Cocoa and this is
the first Cocoa talk you went to.

00:58:02.760 --> 00:58:05.960
I would definitely recommend seeing
at least those two and maybe some of

00:58:05.960 --> 00:58:07.740
the project builder talks on video.

00:58:07.740 --> 00:58:09.560
They're quite handy.

00:58:09.560 --> 00:58:12.710
Interface builder is very,
we didn't see interface builder today,

00:58:12.710 --> 00:58:14.860
but it's very integral
to Cocoa development.

00:58:14.940 --> 00:58:19.000
And the Cocoa overview gives you a good
overview of the things Cocoa provides.

00:58:19.510 --> 00:58:22.250
Advanced Cocoa topics is right after
this one and that's going to be

00:58:22.250 --> 00:58:26.180
somewhat more substantial talk than
this where we're going to go into some

00:58:26.190 --> 00:58:29.990
of the advanced features in Cocoa,
file wrapper, et cetera,

00:58:30.000 --> 00:58:33.880
drag and drop printing, you know,
how to dive into those features.

00:58:33.880 --> 00:58:36.580
Our performance tools,
if you're more interested in

00:58:36.580 --> 00:58:38.740
learning more about sampler,
et cetera,

00:58:38.740 --> 00:58:41.680
is also at the same time or you
can catch that one on video.

00:58:41.680 --> 00:58:42.840
It's in room A2.

00:58:42.840 --> 00:58:44.600
And finally, we have a feedback forum.

00:58:44.600 --> 00:58:47.790
If you can't get your question answered
today or you have something to say,

00:58:47.790 --> 00:58:49.240
it's tomorrow afternoon at 5.

00:58:49.400 --> 00:58:50.880
five.

00:58:51.580 --> 00:58:55.280
and Heather Hickman is our technology
manager and the Cocoa feedback

00:58:55.370 --> 00:58:59.430
and the Cocoa development mailing
lists are available for your use.
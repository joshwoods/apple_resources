WEBVTT

00:00:02.730 --> 00:00:03.130
Thank you.

00:00:03.200 --> 00:00:09.050
Welcome to session 106.

00:00:09.070 --> 00:00:13.460
You know, the Carbon Event Manager is one
of the most important technologies

00:00:13.480 --> 00:00:15.690
that we've added to Carbon.

00:00:15.820 --> 00:00:20.350
Because it can simplify your code,
make it easier to write

00:00:20.680 --> 00:00:26.770
Carbon applications,
improve your performance,

00:00:26.770 --> 00:00:26.770
especially on Mac OS X,

00:00:27.240 --> 00:00:29.450
and it's the foundation for
most of the improvements that

00:00:29.510 --> 00:00:32.540
we're adding to the toolbox.

00:00:32.620 --> 00:00:37.420
So here to tell you all about it is the
manager of the high level toolbox team,

00:00:37.510 --> 00:00:39.770
Ed Voas.

00:00:53.490 --> 00:00:56.540
As Mark said,
Carbon Events is one of the most

00:00:56.540 --> 00:01:01.010
important technologies to learn
about as an application developer.

00:01:01.490 --> 00:01:06.000
The reason for this is that it permeates
everything we do in the toolbox.

00:01:06.040 --> 00:01:09.040
Every one of the toolbox managers,
like the Window Manager, Menu Manager,

00:01:09.040 --> 00:01:13.870
etc., deals with Carbon Events,
at least in some respect.

00:01:15.200 --> 00:01:19.700
It is the Alpha and the Omega.

00:01:19.790 --> 00:01:21.880
So what you're going to learn about
here is you're going to learn a

00:01:21.930 --> 00:01:23.600
brief overview of Carbon Events.

00:01:23.730 --> 00:01:27.200
We're going to try to talk about
basic fundamental principles,

00:01:27.310 --> 00:01:30.100
how it works, what makes it go.

00:01:30.230 --> 00:01:33.220
We'll also show you how easy
it is to actually build a

00:01:33.220 --> 00:01:35.570
Carbon Event-based application.

00:01:35.950 --> 00:01:38.840
and we'll also show you some
examples of how you can extend

00:01:38.840 --> 00:01:41.910
the toolbox via Carbon Events.

00:01:46.710 --> 00:01:52.300
So what Carbon Events is,
is a direct dispatching model.

00:01:52.370 --> 00:01:56.550
Events are dispatched directly
to objects in your application.

00:01:57.370 --> 00:02:00.440
This is in contrast to the
Wait Next Event model where it's

00:02:00.460 --> 00:02:03.800
up to you to pick up an event
and decide what to do with it.

00:02:03.870 --> 00:02:06.190
The Toolbox can do that for you.

00:02:07.060 --> 00:02:09.160
And with that,
the toolbox can also provide many,

00:02:09.160 --> 00:02:10.260
many default behaviors.

00:02:10.430 --> 00:02:12.960
All the things that make
a Mac application behave

00:02:12.960 --> 00:02:14.580
like a Mac application.

00:02:14.660 --> 00:02:18.350
But your applications can override
those default behaviors and extend it

00:02:18.350 --> 00:02:20.560
in ways that make sense for your app.

00:02:21.870 --> 00:02:24.980
And while we have a pure
Carbon Event-based model,

00:02:24.980 --> 00:02:29.300
you can also use Carbon Events in your
WaitNext Event-based applications.

00:02:29.300 --> 00:02:32.730
This is to allow you to actually start
installing handlers and eventually

00:02:32.730 --> 00:02:36.730
get to a point where you don't need
to call WaitNext Event anymore.

00:02:40.630 --> 00:02:43.060
So why did we do this?

00:02:43.130 --> 00:02:47.720
Well, first off, if you remember the
event record structure,

00:02:47.720 --> 00:02:52.250
our friend,
it only has a possibility of 16 events.

00:02:52.250 --> 00:02:57.710
And the reason for this is because
there's only 16 bits in an event mask.

00:02:57.960 --> 00:03:00.200
We wanted a system where we
could send hundreds of events,

00:03:00.250 --> 00:03:02.480
possibly thousands of events,
all different types.

00:03:02.500 --> 00:03:05.380
If you were to look in
carbontevents.h right now,

00:03:05.400 --> 00:03:08.390
you'd see hundreds of
events already existing.

00:03:11.770 --> 00:03:15.000
We also wanted to unify
different models that we had.

00:03:15.040 --> 00:03:18.670
We had event records for receiving
events by your application.

00:03:19.030 --> 00:03:24.720
We also had DefProx for
Windows controls and menus.

00:03:25.610 --> 00:03:28.050
And we also had different
notification callbacks that you

00:03:28.120 --> 00:03:30.370
can install for whatever they were.

00:03:30.560 --> 00:03:32.730
But each one of these was different.

00:03:32.730 --> 00:03:36.240
And every time we did install a new
callback or define a new callback,

00:03:36.310 --> 00:03:39.320
it had a different API,
you had to learn it, and

00:03:39.400 --> 00:03:41.200
is just mayhem.

00:03:41.260 --> 00:03:43.470
So what we're trying to do with
Carbon Events is unify all of that

00:03:43.700 --> 00:03:49.360
into one model that's easy to learn,
it's flexible, and it subsumes everything

00:03:49.360 --> 00:03:51.360
else that we've ever done.

00:03:52.460 --> 00:03:54.560
This also makes it simple
to write applications,

00:03:54.560 --> 00:03:58.400
not only because it's a simple model,
learn it once and you know it,

00:03:58.480 --> 00:04:03.400
but also because, as I mentioned,
the toolbox provides default behaviors.

00:04:03.560 --> 00:04:07.560
So you get to write the code that
matters for your application.

00:04:08.990 --> 00:04:12.280
And lastly, we wanted an API that would
encourage good performance,

00:04:12.280 --> 00:04:15.170
particularly on Mac OS X.

00:04:20.150 --> 00:04:22.920
So I mentioned we're going to show you
how to build a Carbon Event-based app.

00:04:22.920 --> 00:04:24.200
It's really simple.

00:04:24.210 --> 00:04:27.930
The easiest way to do that is with
Project Builder and Interface Builder.

00:04:27.960 --> 00:04:30.890
If you were here for the
last session before this one,

00:04:30.890 --> 00:04:32.940
that was with Interface Builder.

00:04:32.960 --> 00:04:36.000
That is really the star of this duo here.

00:04:36.040 --> 00:04:39.490
And that's what allows you to
throw together a Nib file and just

00:04:39.490 --> 00:04:41.470
have it run via Carbon Events.

00:04:41.800 --> 00:04:45.460
So what I'd like to do is actually bring
up somebody to show you how to do that.

00:04:45.540 --> 00:04:47.580
So here's one of the engineers
from the High Level Toolbox team,

00:04:47.750 --> 00:04:49.370
Guy Fulladin.

00:04:53.570 --> 00:04:55.880
So I'm going to show you a little
bit about what Ed was talking about

00:04:55.900 --> 00:04:58.980
with respect to Project Builder and
Interface Builder and how they make

00:04:58.980 --> 00:05:03.090
your life really easy when you want to
make a Carbon Event-based application.

00:05:03.910 --> 00:05:06.270
Project Builder supports a whole
bunch of different types of

00:05:06.270 --> 00:05:07.470
applications that you can make.

00:05:07.500 --> 00:05:11.180
I'm going to start off with a
nib-based Carbon application.

00:05:18.200 --> 00:05:18.740
There we go.

00:05:18.740 --> 00:05:22.440
All right.

00:05:22.520 --> 00:05:25.750
So you run the app, and it just works.

00:05:26.400 --> 00:05:28.820
Well, on a clean system.

00:05:28.980 --> 00:05:33.000
All the basic event handling
is taken care of for you.

00:05:33.000 --> 00:05:35.790
You can click on the window title
bar and drag your window around.

00:05:35.840 --> 00:05:37.030
You can resize it.

00:05:37.110 --> 00:05:43.230
You can select things from the menus
and you can quit the application.

00:05:43.230 --> 00:05:43.230
The best part, though,

00:05:44.400 --> 00:05:47.500
is the fact that this all
happens with virtually no code.

00:05:47.500 --> 00:05:48.430
This is just a page of code.

00:05:48.430 --> 00:05:50.720
This is all that there
is in the application.

00:05:50.720 --> 00:05:54.000
All it does is it opens
up the nib for the app,

00:05:54.050 --> 00:05:57.640
sets up a menu bar, creates a window,
cleans up after the nib,

00:05:57.700 --> 00:06:01.310
shows the window,
and runs the application event loop.

00:06:01.430 --> 00:06:05.740
And everything else is taken care
of by the Carbon Event Manager.

00:06:05.810 --> 00:06:06.210
Now, let's see.

00:06:06.240 --> 00:06:08.740
I guess I'm playing with fire here.

00:06:08.790 --> 00:06:11.600
I can open up the nib for this
window or for this application.

00:06:11.620 --> 00:06:14.050
And as you can see,
it's just a plain old normal blank

00:06:14.110 --> 00:06:16.090
window just like we got in the app.

00:06:16.160 --> 00:06:18.580
And I can throw some interface elements
into there with Interface Builder,

00:06:18.580 --> 00:06:19.330
so that's really cool.

00:06:19.370 --> 00:06:22.040
If you got to see the
session right before this,

00:06:22.090 --> 00:06:24.590
you got to see how much you
can construct of a Carbon app.

00:06:24.630 --> 00:06:26.800
I'm going to go ahead and throw
some edit text fields in here,

00:06:26.800 --> 00:06:29.680
make some a little bit bigger,
maybe put some static text in there.

00:06:29.680 --> 00:06:31.290
I've got a couple buttons.

00:06:31.290 --> 00:06:33.840
Maybe this is going to be an OK button.

00:06:33.900 --> 00:06:37.820
Change the name to OK,
make it the default button.

00:06:37.820 --> 00:06:38.490
Go up here.

00:06:38.530 --> 00:06:41.350
Let's say we want a button that
actually quits the application.

00:06:41.420 --> 00:06:43.140
I can change it to be Quit.

00:06:43.760 --> 00:06:46.030
And I can say, you know what?

00:06:46.060 --> 00:06:47.790
Have the Quit command in you.

00:06:47.900 --> 00:06:52.230
Save this nib, go back here,
and I guess if I'm lucky it'll rebuild,

00:06:52.230 --> 00:06:53.440
and I can run.

00:06:53.440 --> 00:06:54.720
And the interface just
comes up and works.

00:06:54.740 --> 00:06:55.750
I wrote no extra code.

00:06:55.780 --> 00:06:56.950
This is all just working.

00:06:57.000 --> 00:06:58.550
You can type into the text fields.

00:06:58.700 --> 00:06:59.890
You can hit Return.

00:06:59.890 --> 00:07:01.510
It flashes the OK button.

00:07:01.640 --> 00:07:03.400
I don't know if you
can see that up above.

00:07:03.400 --> 00:07:05.960
And the coolest bit,
since this Quit button has the

00:07:05.960 --> 00:07:08.210
Quit command associated with it,
if I click in it,

00:07:08.280 --> 00:07:11.200
the Quit command is propagated to
the application and the default

00:07:11.340 --> 00:07:14.960
Carbon Event Handlers just
quit the application for you.

00:07:14.960 --> 00:07:18.350
So that's just the very basics
of what Carbon Events and

00:07:18.450 --> 00:07:20.710
Interface Builder can do for you.

00:07:20.770 --> 00:07:22.510
But this shows that there's
a lot of power in the system

00:07:22.520 --> 00:07:24.780
that you can leverage,
and Ed's going to give you some more

00:07:24.780 --> 00:07:26.700
details on how you can leverage that.

00:07:26.990 --> 00:07:28.170
All right.

00:07:28.300 --> 00:07:32.100
So back in 1984,
I was still in high school,

00:07:32.120 --> 00:07:34.680
and this is the way
an application worked.

00:07:34.760 --> 00:07:37.020
Essentially everything was
done by the application,

00:07:37.020 --> 00:07:40.140
and the toolbox was
just there for support.

00:07:40.330 --> 00:07:42.800
So the application was
responsible for the event loop.

00:07:42.800 --> 00:07:45.340
The application was responsible
for dispatching events.

00:07:45.890 --> 00:07:48.990
And of course the application
did something with those

00:07:49.040 --> 00:07:51.750
events and their handlers.

00:07:53.540 --> 00:07:56.400
This is the new model.

00:07:56.400 --> 00:08:00.370
The toolbox is taking a much more
active role in driving an application.

00:08:00.400 --> 00:08:03.680
In this model,
the application calls that run

00:08:03.790 --> 00:08:06.400
application event loop API you saw.

00:08:06.400 --> 00:08:08.590
And it takes care of
dispatching the events.

00:08:08.590 --> 00:08:12.400
And all your application needs to
be responsible for is the handlers.

00:08:12.400 --> 00:08:18.420
And that's where your application lives
and that's where your value is added.

00:08:19.990 --> 00:08:22.070
So as we saw,
we have a lot of standard behaviors that

00:08:22.070 --> 00:08:24.380
we support in the toolbox naturally.

00:08:24.420 --> 00:08:27.320
Obviously, you can drag windows around,
you can resize them.

00:08:27.390 --> 00:08:29.390
If you had a proxy icon
in the window title,

00:08:29.460 --> 00:08:33.100
we would handle that automatically for
you with regards to dragging it around.

00:08:33.100 --> 00:08:36.250
We also will handle contextual
menu interception for you,

00:08:36.250 --> 00:08:39.760
so you don't have to worry about,
you know, control click will just

00:08:39.840 --> 00:08:41.860
tell you contextual menu,
do it.

00:08:41.960 --> 00:08:45.680
And the other thing is, with this model,
we could actually handle the contextual

00:08:45.820 --> 00:08:47.650
menu click ourselves if you didn't.

00:08:47.650 --> 00:08:49.880
And at that point, we could say, well,
we're going to do this.

00:08:49.980 --> 00:08:51.870
We could say, well,
we always want to put up a

00:08:51.870 --> 00:08:53.660
contextual menu when this happens.

00:08:53.660 --> 00:08:56.530
And maybe we'll implement something where
we start putting up a contextual menu,

00:08:56.530 --> 00:08:58.130
and then we'll send you
a Carbon Event saying,

00:08:58.130 --> 00:08:59.900
all right, we're doing a contextual menu.

00:08:59.900 --> 00:09:00.830
Please fill it in.

00:09:00.830 --> 00:09:01.710
Here's the menu.

00:09:01.710 --> 00:09:04.440
So there's a lot of power here.

00:09:04.620 --> 00:09:07.340
Obviously with menus,
we deal with tracking the menu bar,

00:09:07.350 --> 00:09:09.000
dealing with command keys.

00:09:09.000 --> 00:09:14.060
We deal with updating the
menu bar as necessary.

00:09:14.190 --> 00:09:18.040
And with controls, we'll automatically
handle all the tracking.

00:09:18.040 --> 00:09:20.690
We'll deal with focus
issues and the like.

00:09:22.060 --> 00:09:26.760
So, before I get into the real details,
I want to talk in general about

00:09:26.760 --> 00:09:29.980
how events flow through the system,
or at least through an

00:09:29.980 --> 00:09:31.460
application with Carbon Events.

00:09:31.460 --> 00:09:34.680
At the top of this diagram,
you see the Event Queue,

00:09:34.730 --> 00:09:36.560
and it has some events in it.

00:09:36.660 --> 00:09:40.060
Below that,
we have a diagram representing what

00:09:40.060 --> 00:09:44.900
the toolbox considers to be its
canonical containment hierarchy.

00:09:45.000 --> 00:09:46.920
At the bottom, we have the application.

00:09:46.920 --> 00:09:48.520
It is the container of everything.

00:09:49.040 --> 00:09:51.030
Above that, we have menus and windows.

00:09:51.030 --> 00:09:55.080
So, the owners of menus and
windows are the application.

00:09:55.290 --> 00:09:59.510
and each window can own controls
and each control can actually have

00:09:59.510 --> 00:10:04.940
sub-controls based on our standard
control manager control hierarchy.

00:10:05.070 --> 00:10:08.690
So what happens is an event
comes off the queue and then the

00:10:08.690 --> 00:10:12.030
toolbox looks at it and says,
"Okay, what kind of an event is it?

00:10:12.120 --> 00:10:16.720
Where should it go?" For this example,
we'll say it should go to a

00:10:16.720 --> 00:10:18.940
control that's right below it.

00:10:21.270 --> 00:10:26.700
Once it gets into the control,
it looks something like this.

00:10:26.730 --> 00:10:28.770
Each control has a target
associated with it,

00:10:28.770 --> 00:10:31.540
and this is the receptor
for a Carbon Event.

00:10:31.600 --> 00:10:36.620
Each target can have multiple event
handlers installed on that target,

00:10:36.630 --> 00:10:40.040
and they're installed
in the form of a stack.

00:10:40.040 --> 00:10:44.110
The last handler installed
is topmost on the stack.

00:10:44.190 --> 00:10:48.080
The last handler installed is the
first handler to get the events.

00:10:48.080 --> 00:10:52.750
That is how applications
override toolbox behaviors.

00:10:53.750 --> 00:10:55.860
So in this diagram,
essentially we have an application

00:10:55.860 --> 00:10:58.940
handler at the top called My Handler.

00:11:00.060 --> 00:11:02.700
Below that we have some handler
that was installed by the toolbox,

00:11:02.700 --> 00:11:05.010
possibly a standard handler.

00:11:05.240 --> 00:11:07.380
and then below that we
have an Object Handler.

00:11:07.410 --> 00:11:11.590
And this can be thought of as the actual
def proc that's driving this control.

00:11:12.290 --> 00:11:16.130
So we're going to go through a worst case
scenario where nothing wants this event.

00:11:16.140 --> 00:11:17.200
It's unwanted.

00:11:17.350 --> 00:11:20.580
You can feel bad about it.

00:11:20.580 --> 00:11:20.580
So,

00:11:21.180 --> 00:11:23.940
As this event goes through,
essentially we look at each handler,

00:11:23.940 --> 00:11:28.970
see if it was registered for this event,
and if it wasn't, we will bypass it.

00:11:29.520 --> 00:11:33.800
Or it might be that the handler
receives the event but decides at this

00:11:33.800 --> 00:11:35.540
time it doesn't want to handle it.

00:11:35.680 --> 00:11:38.980
So it basically reports,
"I haven't handled it."

00:11:39.810 --> 00:11:43.990
So if this happens for all the handlers,
it'll just fall through.

00:11:43.990 --> 00:11:46.610
And out of the object.

00:11:47.000 --> 00:11:49.940
At that point, the toolbox decides
where should it go next.

00:11:49.940 --> 00:11:52.400
And again,
it uses the standard containment

00:11:52.400 --> 00:11:54.000
hierarchy to decide that.

00:11:54.040 --> 00:11:56.530
So in this case,
it will go to the window next.

00:11:57.040 --> 00:12:02.300
and then if it isn't handled there,
it'll propagate out to the application.

00:12:02.330 --> 00:12:05.500
And this is where all
unhandled events will end up.

00:12:05.840 --> 00:12:10.510
Now if the application doesn't handle it,
it'll actually just get dropped.

00:12:10.560 --> 00:12:14.470
If you happen to be a
WaitNext Event-based app,

00:12:15.850 --> 00:12:18.160
If an event is unhandled
by any of your handles,

00:12:18.170 --> 00:12:20.890
it'll actually be returned to
WaitNextEvent as long as it was an event

00:12:20.990 --> 00:12:24.820
that could be returned to WaitNextEvent,
like a mouse click.

00:12:26.480 --> 00:12:29.080
Okay, details.

00:12:29.200 --> 00:12:31.750
The first thing you need to
know is about the Event Ref.

00:12:31.780 --> 00:12:36.420
The Event Ref is the replacement
for the old Event Record structure.

00:12:36.420 --> 00:12:39.270
And in grand toolbox tradition,
it's opaque.

00:12:39.310 --> 00:12:41.880
You have to use accessors to get at it.

00:12:42.340 --> 00:12:46.200
Each event is identified
by a class and a kind.

00:12:46.280 --> 00:12:50.900
So a mouse down event would
actually have a event class

00:12:51.630 --> 00:12:53.440
of K event class mouse.

00:12:53.540 --> 00:12:55.260
It's a mouse event.

00:12:55.260 --> 00:12:58.490
And the kind is just some
sub-event of that class.

00:12:58.500 --> 00:13:00.500
In this case, mouse down.

00:13:00.700 --> 00:13:03.900
Now, mouse down, all by its lonesome,
just knowing that the mouse

00:13:03.980 --> 00:13:05.500
went down isn't very useful.

00:13:05.500 --> 00:13:08.500
Usually you want to know
where it actually happened,

00:13:08.500 --> 00:13:10.990
what the modifier keys were,
things like that.

00:13:11.110 --> 00:13:12.500
Maybe what button was pressed.

00:13:12.590 --> 00:13:15.130
And the way we do that is we
have an extensible parameter

00:13:15.130 --> 00:13:16.490
mechanism on an event.

00:13:16.490 --> 00:13:19.010
So all of the things I just
mentioned can actually be added

00:13:19.130 --> 00:13:20.470
to the event as parameters.

00:13:20.500 --> 00:13:24.680
Each parameter can be accessed
through some mnemonic name,

00:13:24.680 --> 00:13:25.730
a constant.

00:13:26.350 --> 00:13:28.980
Each parameter can also have a type.

00:13:29.080 --> 00:13:31.910
So the mouse location is actually
stored as a QuickDrawPoint.

00:13:31.920 --> 00:13:36.240
So we would actually use a
constant representing that type,

00:13:36.240 --> 00:13:37.810
like type QDPoint.

00:13:39.620 --> 00:13:43.780
The important thing about an event
ref is it's not just one way.

00:13:43.810 --> 00:13:46.780
Event records were always
something happened.

00:13:46.790 --> 00:13:48.580
Mouse down,

00:13:48.890 --> 00:13:53.000
"Window activated", it's
always past tense kind of.

00:13:53.000 --> 00:13:54.820
Event refs can actually be used
in a much more active role.

00:13:54.820 --> 00:13:57.980
You can actually send an event
ref someplace to get information.

00:13:58.000 --> 00:14:01.670
The recipient of the event can actually
store information in the event ref,

00:14:01.670 --> 00:14:04.320
so that after you send the event,
you can extract the

00:14:04.320 --> 00:14:05.700
information out of that.

00:14:05.700 --> 00:14:09.760
One good example is hit
testing in a window.

00:14:09.760 --> 00:14:14.790
As I mentioned, we're trying to replace
defprox with Carbon events,

00:14:14.920 --> 00:14:20.840
and in fact, the native messaging model
for windows and controls in

00:14:21.050 --> 00:14:23.520
Mac OS X is Carbon events.

00:14:23.520 --> 00:14:29.430
We actually simulate the old proc
pointer based stuff on top of that.

00:14:31.030 --> 00:14:34.980
So when we're going to do hit testing,
what happens is we get the point.

00:14:35.020 --> 00:14:38.150
We actually send a hit test
Carbon Event to the window.

00:14:38.270 --> 00:14:41.180
The window then turns around and says,
"Okay, this part was hit." Stores

00:14:41.180 --> 00:14:42.400
it in the Carbon Event.

00:14:42.530 --> 00:14:45.140
So this way,
when the sender gets the event back,

00:14:45.140 --> 00:14:48.290
they can actually see,
they can extract that parameter and

00:14:48.540 --> 00:14:50.540
find out where the mouse was hit.

00:14:51.330 --> 00:14:53.190
Carbon Events are extensible.

00:14:53.190 --> 00:14:56.960
Extensible to the point that you
can actually create your own.

00:14:57.040 --> 00:15:01.180
You can use maybe your application
signature or whatever you want as

00:15:01.180 --> 00:15:04.690
your event class and then have your
own suite of events which you can

00:15:04.690 --> 00:15:06.300
send around in your application.

00:15:08.330 --> 00:15:11.400
The Event Queue is a little
different in Mac OS X.

00:15:11.490 --> 00:15:15.030
Under Mac OS 9, or traditional Mac OS,
the Event Queue is shared

00:15:15.150 --> 00:15:16.820
among all applications.

00:15:16.970 --> 00:15:19.060
On X, that's not the case.

00:15:19.150 --> 00:15:21.440
Each application gets
its own Event Queue.

00:15:21.540 --> 00:15:24.960
When events come into that
application via the Windows Server,

00:15:24.980 --> 00:15:28.100
they're queued up in that
application Event Queue.

00:15:28.770 --> 00:15:34.840
However, within an application,
we take it one step further in that each

00:15:34.900 --> 00:15:37.690
MP Task can get its own Event Queue.

00:15:37.710 --> 00:15:42.380
If you're running an MP Task and on that
MP Task you call Get Current Event Queue,

00:15:42.380 --> 00:15:45.960
you will get a private
Event Queue for that MP Task.

00:15:46.170 --> 00:15:48.760
You might hand the Queue
Ref for that queue to some

00:15:49.090 --> 00:15:52.020
other entity in the application,
and then you can start using that

00:15:52.120 --> 00:15:55.440
to actually post events between
threads using Carbon Events.

00:15:55.450 --> 00:16:00.940
Now, you might just use MP Primitives
to do messaging back and forth,

00:16:00.990 --> 00:16:04.890
but you can also use
Carbon Events as it adds a much

00:16:04.890 --> 00:16:09.010
more expressive method of events.

00:16:11.410 --> 00:16:14.290
In contrast, all cooperative threads,
including the main thread

00:16:14.290 --> 00:16:16.270
of the application,
share one event queue.

00:16:16.290 --> 00:16:18.080
And that's the main event queue.

00:16:18.180 --> 00:16:22.040
And that is the queue that receives
all the events from the Windows Server,

00:16:22.040 --> 00:16:23.070
as I mentioned.

00:16:25.570 --> 00:16:29.050
Whenever you're waiting on
an event queue for an event,

00:16:29.050 --> 00:16:32.370
this allows timers to fire.

00:16:32.470 --> 00:16:35.670
What the heck's a timer?

00:16:36.480 --> 00:16:39.520
is the replacement for the
Null Event processing mechanism

00:16:39.540 --> 00:16:41.100
through WaitNextEvent.

00:16:41.160 --> 00:16:43.450
And WaitNextEvent,
if you don't handle an event,

00:16:43.680 --> 00:16:44.400
you get a Null Event.

00:16:44.400 --> 00:16:46.040
I mean,
if there's no event for your application,

00:16:46.040 --> 00:16:46.890
you get a Null Event.

00:16:46.980 --> 00:16:49.550
And then you decide, oh,
I guess I should spend

00:16:49.550 --> 00:16:51.390
some time doing something.

00:16:51.450 --> 00:16:54.510
Timers allow you to just
request time explicitly.

00:16:55.030 --> 00:16:57.600
And as I mentioned,
they only will actually execute while

00:16:57.600 --> 00:16:59.110
you're waiting on an event queue.

00:16:59.370 --> 00:17:02.100
So these aren't asynchronous
with respect to your application.

00:17:02.100 --> 00:17:04.160
They're not running at interrupt
level or anything like that.

00:17:04.160 --> 00:17:05.490
They're running at task level.

00:17:05.520 --> 00:17:08.780
You can allocate memory, you can draw,
you can call the toolbox.

00:17:08.810 --> 00:17:10.800
They're at that level.

00:17:12.270 --> 00:17:14.770
The advantage of a timer is that
each object in your application

00:17:14.870 --> 00:17:18.960
can ask for its own share of
periodic time if it needs it.

00:17:19.060 --> 00:17:22.260
And the timers can be disabled.

00:17:22.350 --> 00:17:24.300
So for example,
if you have an edit text control or

00:17:24.310 --> 00:17:27.700
something which needs to blink the
cursor or perform some animation,

00:17:27.780 --> 00:17:30.630
when that goes inactive,
you might want to disable that.

00:17:30.730 --> 00:17:35.810
You can actually remove the timer and
stop using up that time because obviously

00:17:35.850 --> 00:17:37.670
there's nothing to animate anymore.

00:17:38.760 --> 00:17:44.460
Timers can be set to fire at intervals,
every half second, every second,

00:17:44.460 --> 00:17:45.540
or they can be one-shots.

00:17:45.560 --> 00:17:49.190
You can say,
"Call me back in 15 seconds."

00:17:51.190 --> 00:17:54.680
Timers can actually fire
while the mouse is down.

00:17:54.700 --> 00:17:59.050
And this is important to note because,
you know, obviously if you were

00:17:59.050 --> 00:18:02.420
processing a null event,
you weren't processing a click,

00:18:02.490 --> 00:18:03.430
so it's a little different.

00:18:03.570 --> 00:18:06.790
And so this means timers can actually
fire while you're tracking controls

00:18:06.790 --> 00:18:08.390
and while you're tracking the menu bar.

00:18:08.420 --> 00:18:09.480
So it's something to look out for.

00:18:11.500 --> 00:18:15.540
And Mac OS X finally has a
much more reliable heartbeat.

00:18:15.640 --> 00:18:19.100
Mac OS 9,
because it's cooperatively scheduled,

00:18:19.100 --> 00:18:23.450
any one application can steal the
processor for any amount of time.

00:18:23.450 --> 00:18:26.890
So you can't be guaranteed to
get a half second timer firing.

00:18:26.960 --> 00:18:29.760
It's much more reliable on Mac OS X.

00:18:31.750 --> 00:18:36.250
So as we saw in the example,
you drive your application to

00:18:36.340 --> 00:18:37.580
run application event loop.

00:18:37.600 --> 00:18:43.660
This is the pure Carbon Event-based--
Carbon Event API,

00:18:43.660 --> 00:18:44.920
whatever I'm trying to say.

00:18:44.940 --> 00:18:48.600
This is how you run a
Carbon Event-based app.

00:18:48.620 --> 00:18:52.100
Once you enter this API,
you will not exit until

00:18:52.160 --> 00:18:56.000
somebody-- sometimes a toolbox,
sometimes your own application--

00:18:56.070 --> 00:18:58.700
calls quit application event loop.

00:18:59.210 --> 00:19:01.850
And while you're in there,
that's what's driving your application.

00:19:02.000 --> 00:19:04.830
The toolbox then starts pulling
events off the event queue,

00:19:04.970 --> 00:19:07.990
sending them to your
handlers as appropriate.

00:19:09.030 --> 00:19:12.430
Alternatively, you can continue to call
WaitNext Event and while you

00:19:12.530 --> 00:19:15.400
are inside WaitNext Event,
events will be dispatched to any

00:19:15.400 --> 00:19:16.600
handlers that you have installed.

00:19:18.530 --> 00:19:21.680
And again, this allows you to start
installing handlers even in your

00:19:21.680 --> 00:19:25.280
wait-next-event-based application and
start adopting Carbon Events without

00:19:25.280 --> 00:19:28.000
having to go and reconvert your,
I mean, you know,

00:19:28.000 --> 00:19:31.400
just redo your entire application over
to be a pure Carbon Event-based app.

00:19:35.200 --> 00:19:37.060
So while we're in run
application event loop,

00:19:37.060 --> 00:19:41.700
we're inside waitnext-event,
we end up dispatching events.

00:19:41.740 --> 00:19:43.380
And where they go is event targets.

00:19:43.390 --> 00:19:44.520
And we saw a picture of one.

00:19:44.690 --> 00:19:49.110
Each target can have a
stack of handlers inside it.

00:19:49.160 --> 00:19:52.150
and they're typically attached
to toolbox objects like menus,

00:19:52.200 --> 00:19:54.860
windows, controls.

00:19:54.860 --> 00:19:56.540
We also have some special targets.

00:19:56.540 --> 00:19:58.520
One of them is called User Focus Target.

00:19:58.620 --> 00:20:02.230
We're going to talk about
that a little later.

00:20:02.240 --> 00:20:05.140
The other one is the Toolbox Dispatcher.

00:20:05.140 --> 00:20:09.330
Whenever run application event loop
pulls an event off the event queue,

00:20:09.450 --> 00:20:12.560
it just sends it to
the Toolbox Dispatcher.

00:20:12.560 --> 00:20:15.520
You can actually use this fact
to install a handler on the

00:20:15.630 --> 00:20:19.460
Toolbox Dispatcher to catch every
event as it was being processed.

00:20:19.500 --> 00:20:21.730
It does have its uses here and there.

00:20:22.100 --> 00:20:24.590
As I mentioned,
they have a stack of event handlers.

00:20:24.590 --> 00:20:26.500
And, of course,
the event handler is where

00:20:26.820 --> 00:20:27.920
your application lives.

00:20:28.100 --> 00:20:29.180
This is where you receive events.

00:20:29.210 --> 00:20:31.890
It's a simple callback.

00:20:32.130 --> 00:20:36.400
and You will only receive the
events that you register for.

00:20:36.400 --> 00:20:39.050
We don't support wildcarding,
and that was a conscious decision

00:20:39.080 --> 00:20:41.120
with performance in mind.

00:20:41.120 --> 00:20:44.040
We don't want to start sending
out events to any handler that

00:20:44.080 --> 00:20:46.200
could possibly deal with it.

00:20:51.430 --> 00:20:54.360
When you're inside your event handler,
you can choose to

00:20:54.420 --> 00:20:58.220
actually handle the event,
meaning do something with it,

00:20:58.220 --> 00:21:01.970
or not handle it,
meaning let it propagate to some other

00:21:01.970 --> 00:21:06.180
object or handler which does want it.

00:21:07.880 --> 00:21:12.820
The way it tells the toolbox whether it
handled it or not is by its result code.

00:21:12.940 --> 00:21:16.690
If your event handler returns
event not handled error,

00:21:16.990 --> 00:21:20.400
That's a key to the toolbox to say,
all right, nothing happened here,

00:21:20.400 --> 00:21:22.450
nothing to see here, please move along.

00:21:22.560 --> 00:21:25.480
So it sends the event off
to some other handler.

00:21:25.520 --> 00:21:29.890
If you return any other status code,
event propagation stops dead

00:21:30.320 --> 00:21:32.770
and the event is discarded.

00:21:36.700 --> 00:21:39.520
And once we leave a target,
we do propagation.

00:21:39.590 --> 00:21:41.740
We saw the diagram of our
containment hierarchy.

00:21:41.740 --> 00:21:45.330
That's what we use to decide
where events should go.

00:21:45.910 --> 00:21:48.180
So if an entire target
doesn't handle an event,

00:21:48.180 --> 00:21:50.160
we decide which target
to send it to next,

00:21:50.160 --> 00:21:51.870
and we redirect it.

00:21:52.430 --> 00:21:57.800
I mentioned that application target
is where all unhandled events end up.

00:21:57.820 --> 00:22:00.360
Now, that's not a complete rule.

00:22:00.360 --> 00:22:03.660
There are events which we will
not allow to propagate beyond

00:22:03.660 --> 00:22:05.520
the target which we send it.

00:22:05.530 --> 00:22:09.090
And the best example of those
are those events which replace

00:22:09.200 --> 00:22:10.640
the old defproc messages.

00:22:10.700 --> 00:22:15.410
There's no point sending a window
hit test event to the application.

00:22:15.510 --> 00:22:19.320
So we only send it to that window object.

00:22:19.340 --> 00:22:21.770
And I also mentioned--

00:22:22.960 --> 00:22:29.370
How your result code tells the
toolbox if we should propagate or not.

00:22:29.460 --> 00:22:33.520
We call that implicit propagation.

00:22:33.750 --> 00:22:36.830
You don't really need to do any action
on yourself to make the event propagate

00:22:36.910 --> 00:22:38.750
other than control your result code.

00:22:39.010 --> 00:22:42.840
However, you can do what I term
explicit propagation,

00:22:42.840 --> 00:22:45.430
which is you can actually say, "Alright,
I have this event,

00:22:45.560 --> 00:22:49.060
but I want the toolbox to do its
default processing right now because

00:22:49.060 --> 00:22:51.290
I'm going to do something after it."

00:22:52.090 --> 00:22:54.900
And you do that through an
API called Call Next Event Handler.

00:22:55.000 --> 00:22:57.840
So you would receive an event,
just call through,

00:22:57.850 --> 00:23:00.890
toolbox might do some default behavior,
and then you can follow up.

00:23:01.090 --> 00:23:03.710
So you can be implicit or explicit.

00:23:04.860 --> 00:23:07.100
All right, I touched on user focus.

00:23:07.130 --> 00:23:10.240
User focus is quite simply
where keyboard events go.

00:23:10.300 --> 00:23:16.570
And you can get the user focus
target by calling getUserFocusTarget.

00:23:17.910 --> 00:23:21.380
Back in Mac OS 8,
we introduced keyboard focus,

00:23:21.380 --> 00:23:22.420
which is great.

00:23:22.590 --> 00:23:25.700
So you have a window and you
have some concept of what the

00:23:26.350 --> 00:23:28.900
focus control is in that window.

00:23:29.400 --> 00:23:32.260
Well, from an event model standpoint,
that's all wonderful and all,

00:23:32.260 --> 00:23:36.650
but when we get a keyboard event,
which window should we even start with?

00:23:41.280 --> 00:23:45.370
So what we've done is we've
created this concept of user focus,

00:23:45.370 --> 00:23:47.400
which is the combination

00:23:48.070 --> 00:23:54.200
of the currently active document window
and any focus control in that window.

00:23:55.660 --> 00:23:59.740
If the currently active document
window doesn't have a focus control,

00:23:59.740 --> 00:24:03.400
that window is considered
to be the user focus.

00:24:03.870 --> 00:24:05.450
There are times, however,
when you actually want to

00:24:05.450 --> 00:24:08.260
redirect it to some other window,
which isn't the currently

00:24:08.260 --> 00:24:09.200
active document window.

00:24:09.590 --> 00:24:11.510
Best example would be a
floating palette which accepts

00:24:11.550 --> 00:24:12.950
some sort of keyboard input.

00:24:13.010 --> 00:24:14.260
You might want to redirect it there.

00:24:14.260 --> 00:24:18.070
And you can do so with an
API called Set User Focus Window.

00:24:19.570 --> 00:24:23.500
If you're using pure Carbon Events,
you don't really have to even worry

00:24:23.500 --> 00:24:27.490
about that because the toolbox will
manage that for you automatically.

00:24:30.170 --> 00:24:32.860
User Focus,
along with being the recipient

00:24:32.860 --> 00:24:37.970
of the keyboard events,
is also the recipient of HI commands.

00:24:38.580 --> 00:24:42.780
HICommands are merely the extension
of the old menu command concept

00:24:42.830 --> 00:24:45.470
we introduced in Mac OS 8.0.

00:24:45.860 --> 00:24:48.930
So a menu command is just
a position-independent way

00:24:48.990 --> 00:24:52.390
of identifying a menu item,
traditionally.

00:24:53.720 --> 00:24:57.800
So instead of knowing that when the
user selects Undo from the Edit menu,

00:24:57.830 --> 00:25:02.690
it's Menu ID 129, Item 1,
all you need to know is

00:25:02.750 --> 00:25:04.640
that the command is Undo.

00:25:04.700 --> 00:25:06.330
And it doesn't matter where
it is in the menu bar.

00:25:06.430 --> 00:25:08.890
As long as you get Undo,
you know what to do.

00:25:09.990 --> 00:25:11.560
When we were doing all
this Carbon Event work,

00:25:11.580 --> 00:25:13.820
though,
we decided it would be really good if we

00:25:13.830 --> 00:25:15.600
could share this with controls as well.

00:25:15.640 --> 00:25:20.250
And you saw an example of that where we
hooked up the quit command to a control.

00:25:20.380 --> 00:25:25.300
So the HICommand structure
is actually a little struct,

00:25:25.300 --> 00:25:26.550
is the encapsulation of that.

00:25:26.660 --> 00:25:29.520
So inside these structures,
it has the command ID as

00:25:29.520 --> 00:25:34.090
well as information about
where the command came from.

00:25:35.550 --> 00:25:40.280
The propagation path is a little
different based on whether

00:25:40.280 --> 00:25:44.340
the command was originated
from a control or from a menu.

00:25:44.390 --> 00:25:47.570
If from a control, we just follow the
standard control hierarchy,

00:25:47.570 --> 00:25:50.980
starting with the actual control
that originated the command.

00:25:52.020 --> 00:25:56.000
For menus,
we send the command to the menu

00:25:56.000 --> 00:25:59.440
which originated the command,
and if unhandled at that level,

00:25:59.520 --> 00:26:01.900
we then send it to the user focus.

00:26:01.930 --> 00:26:04.820
And that is probably what
makes the best sense.

00:26:04.970 --> 00:26:09.040
For example, if you're going to select
cut from the edit menu,

00:26:09.190 --> 00:26:13.900
the command should probably go
right to that focus control in the

00:26:13.900 --> 00:26:18.390
currently active document window,
wherever the user focus is basically.

00:26:21.000 --> 00:26:26.180
We also use HICommands to deal with
menu item enabling and disabling.

00:26:26.250 --> 00:26:29.980
We talk about this a little bit
more in the Windows and Menus

00:26:30.300 --> 00:26:31.780
talk tomorrow.

00:26:31.820 --> 00:26:34.570
But essentially,
whenever a menu is about to be displayed,

00:26:34.590 --> 00:26:37.740
for each item in the menu,
we send out K event command

00:26:37.740 --> 00:26:39.490
update status events.

00:26:39.540 --> 00:26:43.920
This is your cue to actually do
something with the command in the menu.

00:26:43.970 --> 00:26:46.350
You might want to
enable it or disable it.

00:26:46.740 --> 00:26:49.650
Maybe you want to add a check
mark or change its text.

00:26:49.650 --> 00:26:52.450
Maybe undo changes from
undo to undo typing.

00:26:52.450 --> 00:26:54.150
It's completely up to you.

00:26:54.150 --> 00:26:57.000
But we send this right
to the user focus saying,

00:26:57.010 --> 00:26:58.510
I'm about to show this.

00:26:58.510 --> 00:26:58.990
How should it appear?

00:26:59.260 --> 00:27:04.320
When the user selects one of these
menu items or clicks the control,

00:27:04.320 --> 00:27:06.310
we send out K event command process.

00:27:06.360 --> 00:27:09.040
And that's when you can
deal with the command.

00:27:09.100 --> 00:27:13.210
Commands are actually really useful for
doing simple inter-target messaging.

00:27:14.460 --> 00:27:18.430
So for example, you can have a window
with controls in it.

00:27:18.430 --> 00:27:23.400
And the controls in the window can all
have command IDs associated with it.

00:27:23.460 --> 00:27:27.270
And the window can be listening to all
the commands that the controls generate.

00:27:27.390 --> 00:27:31.390
So every time you click a
checkbox or drag a slider,

00:27:31.450 --> 00:27:33.190
the window can actually
pick that up and say,

00:27:33.190 --> 00:27:34.160
oh, checkbox is it.

00:27:34.160 --> 00:27:35.960
I've got to go do something.

00:27:37.180 --> 00:27:39.640
It's also important to use the standard
command IDs that we've defined in

00:27:39.640 --> 00:27:42.470
carbonevents.h whenever possible.

00:27:42.900 --> 00:27:45.380
We have a whole list of
them in there right now,

00:27:45.380 --> 00:27:49.900
and we're adding more as we speak.

00:27:49.900 --> 00:27:53.040
The reason for that is we want to be
able to share the menu bar between

00:27:53.040 --> 00:27:54.940
the toolbox and the application.

00:27:54.960 --> 00:27:57.230
If the toolbox has something,

00:27:57.700 --> 00:28:01.520
You know, up on screen at the time,
we need to enable and disable

00:28:01.520 --> 00:28:05.640
certain menu commands,
such as the Edit menu.

00:28:05.640 --> 00:28:08.450
We need to be able to
find those by command ID.

00:28:11.810 --> 00:28:16.580
There comes a time in every application's
life when you have to go modal.

00:28:16.630 --> 00:28:20.470
And typically, we've done that in the
past with modal dialog.

00:28:20.490 --> 00:28:23.230
So you call get new dialog,
you bring up your dialog and you

00:28:23.240 --> 00:28:25.580
call modal dialog and you sit there.

00:28:26.100 --> 00:28:29.100
Until the user hits
OK or Cancel or whatever.

00:28:29.120 --> 00:28:32.350
The way to do that in the
Carbon Event model is to call

00:28:32.440 --> 00:28:33.980
runAppModelLoopForWindow.

00:28:34.040 --> 00:28:37.480
So you can create any window,
be it NibBase, ResourceBase,

00:28:37.480 --> 00:28:38.540
we don't care.

00:28:38.540 --> 00:28:40.620
We just put it up on screen,
and then you call

00:28:40.620 --> 00:28:42.030
runAppModelLoopForWindow.

00:28:42.040 --> 00:28:45.280
Now, at some point,
somebody needs to call

00:28:45.570 --> 00:28:48.420
quitAppModelLoopForWindow so that you
can actually terminate from the call.

00:28:48.490 --> 00:28:50.340
It's very much like
runApplicationEventLoop,

00:28:50.340 --> 00:28:53.340
where you enter it,
and you will not exit it until somebody

00:28:53.490 --> 00:28:55.790
calls the appropriate quick call.

00:28:57.190 --> 00:29:00.970
And this is probably good
enough for most uses,

00:29:01.090 --> 00:29:03.220
especially if you're
pure Carbon Event-based.

00:29:03.220 --> 00:29:06.240
But you might have an application
which has a lot of legacy code

00:29:06.370 --> 00:29:09.020
and you can't necessarily do that.

00:29:09.020 --> 00:29:12.030
You need to drive the event
model yourself or drive the event

00:29:12.040 --> 00:29:13.820
loop while this thing is modal.

00:29:13.940 --> 00:29:17.840
So you can actually share our
modality environment while

00:29:17.840 --> 00:29:19.300
driving the events yourself.

00:29:19.300 --> 00:29:23.520
And you do that with begin and
end app modal state for window.

00:29:23.520 --> 00:29:27.300
And what I mean by our modal
environment is that whenever

00:29:27.300 --> 00:29:31.290
we enter this modal state,
we automatically take care of

00:29:31.300 --> 00:29:35.840
disabling the menu bar and then
dealing with the click situation.

00:29:35.840 --> 00:29:39.500
So we don't allow clicks outside
the window that happens to be modal.

00:29:39.500 --> 00:29:42.630
So by using begin and end
up modal state for window,

00:29:42.750 --> 00:29:46.940
you can actually use the toolbox's
canonical modality stuff.

00:29:46.940 --> 00:29:53.480
All right, we talked about performance.

00:29:53.480 --> 00:29:53.480
There are--

00:29:55.260 --> 00:29:59.080
A couple of ways that you can
actually tune your app for Mac OS X.

00:29:59.080 --> 00:30:03.830
And I mentioned that
Carbon Events help you do that.

00:30:04.950 --> 00:30:11.340
First thing is timers as opposed
to using Wait Next Event timeouts.

00:30:11.400 --> 00:30:15.750
Ideally, you should have your
Wait Next Event sleep time set to

00:30:15.950 --> 00:30:20.410
the maximum it can be and install
timers throughout your application.

00:30:21.600 --> 00:30:27.290
That actually goes a long way to helping
toward minimizing unnecessary idle time.

00:30:27.350 --> 00:30:28.600
Another thing is tracking loops.

00:30:28.740 --> 00:30:31.910
Tracking loops written
traditionally with while still down,

00:30:31.910 --> 00:30:34.670
you know, get mouse are very,
very bad on 10.

00:30:34.810 --> 00:30:36.890
They make everything else go slow.

00:30:37.040 --> 00:30:40.810
So what you need to do is
instead use track mouse location.

00:30:40.880 --> 00:30:43.680
We're actually going to show you an
example of that in a few minutes.

00:30:44.730 --> 00:30:47.480
Another thing is to try to
use notifications whenever

00:30:47.540 --> 00:30:50.100
possible as opposed to polling.

00:30:50.410 --> 00:30:53.880
We've done a lot of stuff in the
Carbon Event Model to try to send

00:30:53.880 --> 00:30:57.720
you Carbon Events when certain
things happen in your application.

00:30:59.200 --> 00:31:02.640
or sometimes outside of your application.

00:31:02.640 --> 00:31:06.900
For example,
one common polling situation is

00:31:07.170 --> 00:31:08.730
Pulling the process list.

00:31:09.020 --> 00:31:11.000
I want to know when the
process comes and goes.

00:31:11.150 --> 00:31:13.780
We actually have Carbon Events to
tell you when that happens.

00:31:13.830 --> 00:31:18.020
Rather than you sitting there in some
sort of loop or installing a timer to

00:31:18.020 --> 00:31:23.260
do this every millisecond or something,
you can just say, "Hey,

00:31:23.350 --> 00:31:30.030
let me know when an app gets launched
or let me know when an app quits."

00:31:30.710 --> 00:31:35.060
And if you have cases in your
application where you need to do

00:31:35.060 --> 00:31:39.790
polling and we don't have a solution,
please let us know because we're

00:31:39.790 --> 00:31:43.420
really trying to add as much
in the realm of notifications,

00:31:43.510 --> 00:31:45.540
notification events as possible.

00:31:49.300 --> 00:31:55.010
So we talked about how Carbon Events is
the native kind of defproc model

00:31:55.700 --> 00:32:00.200
for Mac OS X and Carbon in general.

00:32:01.600 --> 00:32:04.140
Toolbox Objects is what
allows us to do this.

00:32:04.320 --> 00:32:09.490
Toolbox Objects are
effectively an event handler.

00:32:09.740 --> 00:32:15.550
that you can define and register with the
Toolbox using Register Toolbox Object.

00:32:16.410 --> 00:32:20.610
With this, you can then,
in the Window and Control Managers,

00:32:20.770 --> 00:32:23.460
call Create Custom Window or
Create Custom Control,

00:32:23.460 --> 00:32:27.690
passing one of these Toolbox
Object refs that you register.

00:32:28.570 --> 00:32:32.130
And then that handler that you
associated with the Toolbox object

00:32:32.780 --> 00:32:37.770
will get called to deal with all the
events having to do with DefProx.

00:32:38.400 --> 00:32:42.640
This is the recommended method for doing
custom controls in Windows these days.

00:32:42.740 --> 00:32:47.140
The reason for that is quite simply
this is where we're spending our time.

00:32:47.260 --> 00:32:52.360
Carbon Events is like our
future and it's very flexible.

00:32:52.490 --> 00:32:56.510
Carbon Events,
we can add parameters and new events.

00:32:56.700 --> 00:33:18.100
[Transcript missing]

00:33:19.960 --> 00:33:22.260
So that was a lot of stuff.

00:33:22.320 --> 00:33:25.940
So what I'd like to do now is actually
bring up Guy again to show you a more

00:33:25.940 --> 00:33:30.380
detailed demo and show you about a
lot more of the power that we have.

00:33:30.380 --> 00:33:31.000
Oh, yes, power.

00:33:31.000 --> 00:33:33.620
GUY DUBROVSKY: All right,
cross your fingers for me.

00:33:37.090 --> 00:33:41.820
So the first demo I want to show
has to do with what Ed mentioned

00:33:42.100 --> 00:33:44.480
about eliminating polling.

00:33:47.610 --> 00:33:52.760
Got a small application here
which is based on that basic

00:33:52.760 --> 00:33:55.280
Carbon app that I showed you before.

00:33:55.380 --> 00:33:58.090
And I'm running another
application that's on the

00:33:58.090 --> 00:33:59.740
system which is a CPU gauge.

00:33:59.910 --> 00:34:03.800
This basic app has just a normal window
in it with a couple of bevel buttons.

00:34:03.800 --> 00:34:05.590
One of them's good, one of them's bad.

00:34:05.660 --> 00:34:09.090
And this app is almost as small
as the one I showed you before.

00:34:09.140 --> 00:34:12.650
I added one Carbon Event handler
to it to override mouse

00:34:12.650 --> 00:34:14.600
tracking for the bad control.

00:34:14.670 --> 00:34:17.850
And the reason I overrode it is
because the system already does the

00:34:17.850 --> 00:34:19.240
good thing with respect to polling.

00:34:19.240 --> 00:34:21.570
The system,
when it's about to track the mouse,

00:34:21.690 --> 00:34:22.860
does not sit in a spin loop.

00:34:22.940 --> 00:34:25.510
It calls track mouse location,
which will block and which will

00:34:25.510 --> 00:34:29.040
make sure the CPU doesn't get
used when it's not necessary.

00:34:29.130 --> 00:34:33.950
So what I did is I overrode the
click handling for the bad control,

00:34:33.950 --> 00:34:37.410
and I have a while still
down loop in the bad control.

00:34:37.490 --> 00:34:40.600
So if I click on it, you can actually see
the CPU just pin out.

00:34:40.740 --> 00:34:43.190
I'm not even moving the mouse,
but the CPU is using up absolutely

00:34:43.190 --> 00:34:44.600
everything it possibly can.

00:34:44.600 --> 00:34:46.840
If I was trying to download
something in the background,

00:34:46.840 --> 00:34:48.590
your download speed would be cut in half.

00:34:48.600 --> 00:34:50.080
You don't want to be doing this.

00:34:50.110 --> 00:34:52.410
What you really want to do
is either let the toolbox do

00:34:52.410 --> 00:34:55.010
the default behavior for you,
which as you can see,

00:34:55.080 --> 00:34:58.360
if I click and move around, you know,
I get a little bit of CPU usage,

00:34:58.360 --> 00:35:01.360
but if I click and hold it still,
I don't get any usage.

00:35:01.360 --> 00:35:05.590
So use track mouse location if
you're currently doing polling loops.

00:35:05.600 --> 00:35:13.190
Now, we'll go back to Magnify,
this time for real.

00:35:17.730 --> 00:35:20.140
Magnify is an app you may have seen.

00:35:20.140 --> 00:35:23.030
I think we've shown it previous years.

00:35:23.060 --> 00:35:26.010
It is a simple application which
magnifies the screen pixels that

00:35:26.080 --> 00:35:27.530
the mouse happens to be over.

00:35:27.670 --> 00:35:29.080
And we do this with a timer.

00:35:29.080 --> 00:35:33.070
Magnify updates once every so often,
grabbing the pixels from the screen

00:35:33.070 --> 00:35:34.680
and displaying it in the window.

00:35:34.770 --> 00:35:37.960
And it also has a Carbon Event Handler
on the window to handle window resizing.

00:35:38.220 --> 00:35:41.540
We always want the Magnify window to
be square just because we're that way.

00:35:41.540 --> 00:35:43.900
So even if I move the
mouse only horizontally,

00:35:43.900 --> 00:35:47.260
the window still
maintains its squareness.

00:35:51.100 --> 00:35:52.340
Let me show you.

00:35:52.340 --> 00:35:55.150
Oh, the one other thing I want to show
you about Magnify is we also offer

00:35:55.160 --> 00:35:58.440
a modal preferences dialog that
lets you configure various things.

00:35:58.480 --> 00:36:01.550
You can change the zoom level,
turn off the little info

00:36:01.550 --> 00:36:05.750
that gets showed in there,
make it float or not float.

00:36:07.060 --> 00:36:08.990
Let's make it not float for now.

00:36:09.160 --> 00:36:13.200
So let me show you a little bit of
the code and how we did all that.

00:36:23.400 --> 00:36:25.480
The first thing I want to show
you is how we did the timer.

00:36:25.480 --> 00:36:27.880
Timers, very simply,
are just a proc pointer

00:36:27.880 --> 00:36:30.710
that you register with us,
tell us how often you

00:36:30.770 --> 00:36:33.060
want to do something,
and then when your

00:36:33.190 --> 00:36:35.700
proc pointer is called,
you get to do whatever you want to do.

00:36:35.700 --> 00:36:37.200
So here's our event timer.

00:36:37.200 --> 00:36:39.820
We just called it
Magnify Event Loop Timer.

00:36:39.830 --> 00:36:41.920
It receives user data,
which is basically like a refcon,

00:36:41.930 --> 00:36:44.610
so if you have some global state
you need to reference or some per

00:36:44.610 --> 00:36:47.930
context state you need to reference,
you can receive it there.

00:36:48.080 --> 00:36:49.650
And our timer goes in there.

00:36:49.650 --> 00:36:51.070
We do some various things.

00:36:51.130 --> 00:36:55.680
We basically create a port so
we can grab some screen pixels.

00:36:55.680 --> 00:37:00.490
And we copy bits it, do various things,
and end up painting it into our window.

00:37:03.010 --> 00:37:04.810
So it's one thing to write this,
but you actually need to

00:37:04.810 --> 00:37:06.410
install the event-- oh,
you know what?

00:37:06.460 --> 00:37:08.160
Didn't want to hide.

00:37:08.160 --> 00:37:10.220
Need to do that.

00:37:10.220 --> 00:37:12.790
The way you install an event
loop timer is you create a

00:37:12.790 --> 00:37:14.900
UPP around your proc pointer.

00:37:15.080 --> 00:37:19.090
And you pass that UPP into
Install Event Loop Timer.

00:37:19.150 --> 00:37:21.520
You tell it which event loop you
want to install the timer on.

00:37:21.520 --> 00:37:22.920
And typically,
you're going to want to install your

00:37:22.980 --> 00:37:25.050
timers on the current event loop.

00:37:25.110 --> 00:37:28.390
And you tell it how often
you want it to fire.

00:37:28.520 --> 00:37:32.550
In this case, I have this timer firing
about once every 20 seconds.

00:37:32.630 --> 00:37:33.620
And that's it.

00:37:33.620 --> 00:37:36.310
The only thing you have to do after
that is just run the event loop,

00:37:36.330 --> 00:37:38.930
and your timer will automatically fire.

00:37:41.480 --> 00:37:46.350
So next I want to show you how
to write a basic event handler.

00:37:46.370 --> 00:37:49.140
Like I mentioned before,
we have a window handler which

00:37:49.150 --> 00:37:52.320
makes sure that our window
resizing always is square.

00:37:52.320 --> 00:37:56.580
And just like an event timer,
this is a simple callback proc pointer.

00:37:56.580 --> 00:38:00.990
You receive an event, a refcon,
and when your callback is called,

00:38:01.060 --> 00:38:03.840
you can extract parameters
from this event.

00:38:03.850 --> 00:38:07.190
In this case,
our window extracts parameters.

00:38:07.280 --> 00:38:09.960
The attributes from
this particular event.

00:38:09.990 --> 00:38:12.530
I know that this handler is
only registered for one event,

00:38:12.630 --> 00:38:15.790
so I can just dive right in to
extracting parameters without

00:38:15.800 --> 00:38:17.130
looking at the actual event type.

00:38:17.130 --> 00:38:19.200
But if I wrote a handler
to handle multiple events,

00:38:19.200 --> 00:38:22.490
you'd actually want to switch over
the type of event you're receiving.

00:38:22.500 --> 00:38:26.770
So a window bounds change event
actually contains some attributes which

00:38:26.770 --> 00:38:29.200
tells you how the bounds are changing.

00:38:29.200 --> 00:38:32.820
When the window bounds change,
the window might be resizing

00:38:32.820 --> 00:38:35.230
or it might just be moving,
i.e.

00:38:35.240 --> 00:38:36.160
the origin is changing.

00:38:36.160 --> 00:38:39.690
We only need to do work
when the size is changing.

00:38:39.690 --> 00:38:41.760
So I check the attributes to
make sure we're only going

00:38:41.760 --> 00:38:42.910
to do work when we need to.

00:38:42.920 --> 00:38:44.980
One other thing I want to point out.

00:38:45.080 --> 00:38:48.170
We have a result code that we're
going to return eventually.

00:38:48.210 --> 00:38:51.070
By default, this result code is
event not handled error.

00:38:51.100 --> 00:38:55.150
So if our handler ends up doing no work,
that tells the event subsystem to

00:38:55.150 --> 00:38:58.970
just go and do whatever default
processing you would have done.

00:38:59.640 --> 00:39:03.820
So going back,
we know that we're changing size.

00:39:03.820 --> 00:39:06.000
We get the current
bounds out of the event.

00:39:06.000 --> 00:39:08.640
That's the bounds that
the Window Manager figures

00:39:08.640 --> 00:39:10.480
you want to really use.

00:39:10.480 --> 00:39:11.560
But we take them out.

00:39:11.560 --> 00:39:14.010
We don't really want to use them because
we want to make the bounds square.

00:39:14.020 --> 00:39:17.500
So we go ahead and we do a little bit
of effort to make the bounds square.

00:39:17.500 --> 00:39:20.260
And then we stuff the current
bounds back into the event.

00:39:20.260 --> 00:39:21.960
And we set our result to no error.

00:39:21.960 --> 00:39:24.830
No error is an indication that
our handler handled the event.

00:39:24.840 --> 00:39:26.320
Don't call any default handlers.

00:39:26.320 --> 00:39:28.970
Just let this event finish now.

00:39:30.050 --> 00:39:33.260
So our handler exits,
the Window Manager ends up getting

00:39:33.260 --> 00:39:36.180
the bounds that we've changed
out of the event and it resizes

00:39:36.250 --> 00:39:38.600
our window to those bounds.

00:39:38.670 --> 00:39:41.310
And as you might imagine,
installing one of these event

00:39:41.310 --> 00:39:42.990
handlers is also very simple.

00:39:43.780 --> 00:39:47.200
You create a UPP for that handler.

00:39:47.200 --> 00:39:49.280
Oh, I keep hitting the wrong keys.

00:39:49.360 --> 00:39:51.140
And you call installWindowEventHandler.

00:39:51.140 --> 00:39:52.300
You pass it a window.

00:39:52.330 --> 00:39:53.690
You pass it the UPP.

00:39:53.760 --> 00:39:56.660
And you pass it the list of events that
you're interested in for that handler.

00:39:56.700 --> 00:40:01.460
And it just so happens that I am
only interested in the K event

00:40:01.630 --> 00:40:04.170
window bounds change event.

00:40:05.700 --> 00:40:07.730
Once you do that,
your handler is installed and

00:40:07.730 --> 00:40:10.780
anytime the window manager or whoever
might need to call that handler,

00:40:10.780 --> 00:40:13.700
anytime someone needs
to call that handler,

00:40:13.700 --> 00:40:15.680
it will be called.

00:40:17.120 --> 00:40:22.000
The last thing that I want to go
into is handling commands for menus.

00:40:22.000 --> 00:40:26.200
We just so happen to have the default
preferences command associated with

00:40:26.200 --> 00:40:28.550
the preferences item for our menu.

00:40:30.320 --> 00:40:33.440
We need to set up a handler to
handle that preferences item

00:40:33.440 --> 00:40:35.040
and display the modal dialog.

00:40:35.040 --> 00:40:37.110
In my main,

00:40:37.540 --> 00:40:40.030
First thing we do is we enable the
preferences command because we know we

00:40:40.030 --> 00:40:42.270
want to allow the user to select that.

00:40:42.300 --> 00:40:47.300
And next, after we do some more setup,
we install an application event handler.

00:40:47.460 --> 00:40:50.380
Now as Ed mentioned,
when you select a command from a menu,

00:40:50.430 --> 00:40:52.460
the first place that command
goes is the menu itself.

00:40:52.500 --> 00:40:56.250
Menus don't often handle commands,
and in this case our menu does not

00:40:56.330 --> 00:40:58.500
handle that command specifically.

00:40:58.690 --> 00:41:00.270
Then the command will
go to the user focus,

00:41:00.270 --> 00:41:01.500
which would be the window.

00:41:01.500 --> 00:41:04.550
Well, our window isn't particularly
interested in it,

00:41:04.620 --> 00:41:06.500
so the event ends up
propagating to the application.

00:41:06.510 --> 00:41:08.500
And that's where we want to handle it.

00:41:08.510 --> 00:41:10.500
And we have an application handler.

00:41:10.500 --> 00:41:12.660
Oh, you know I keep hitting that,
don't I?

00:41:16.260 --> 00:41:20.340
Just as you would expect,
we pull out the direct object

00:41:20.340 --> 00:41:25.580
out of the process command event,
and it happens to be of type HICommand.

00:41:25.690 --> 00:41:27.500
We look to see if it's
the preferences command,

00:41:27.500 --> 00:41:30.530
and if so, we do the preferences dialog.

00:41:31.030 --> 00:41:34.800
and the Preferences Dialog is
an excellent example of how

00:41:34.800 --> 00:41:36.440
you would do a modal dialog.

00:41:36.740 --> 00:41:38.720
First, we build the window via a nib.

00:41:38.800 --> 00:41:39.740
You don't have to build it via a nib.

00:41:39.740 --> 00:41:43.250
You can build it programmatically or via
resources or however you want to do it.

00:41:43.310 --> 00:41:45.550
We set up a

00:41:46.130 --> 00:41:49.080
and then we install a handler
under the window to handle commands

00:41:49.140 --> 00:41:51.840
that are going to be generated
by the controls in that window.

00:41:51.840 --> 00:41:53.600
And that's the pref handler.

00:41:53.600 --> 00:41:55.890
Then we position it on screen
as appropriate and we call

00:41:55.900 --> 00:41:57.440
run appmodeloop for window.

00:41:57.580 --> 00:41:59.940
Now when run appmodeloop for
window eventually returns,

00:41:59.940 --> 00:42:02.740
we dispose of the window,
we dispose of the event handler,

00:42:02.740 --> 00:42:04.640
and then we return from
the preferences function.

00:42:04.790 --> 00:42:08.700
So most of this work actually
happens inside the toolbox until

00:42:08.700 --> 00:42:10.950
our pref handler gets called.

00:42:11.170 --> 00:42:14.440
Our pref handler is going to get
called for commands associated

00:42:14.440 --> 00:42:17.250
with controls in the window.

00:42:17.300 --> 00:42:21.630
Just like handling menu commands,
we extract the direct object

00:42:21.630 --> 00:42:24.610
out of the command event,
take a look at the command ID,

00:42:24.610 --> 00:42:25.860
and we do various things.

00:42:25.860 --> 00:42:30.170
One of the interesting things is if
we see a magnification change command,

00:42:30.170 --> 00:42:34.700
we change our magnification factor
and tell the actual magnify window

00:42:34.710 --> 00:42:37.520
to update itself if it needs to.

00:42:37.520 --> 00:42:40.870
There are a couple of
standard commands for dialogs,

00:42:40.870 --> 00:42:44.140
and those are khicmdok and khicmdcancel.

00:42:44.140 --> 00:42:47.620
Those have been associated with the
OK and Cancel buttons in that dialog.

00:42:47.620 --> 00:42:50.420
When we see the OK button,
we write out our current settings

00:42:50.430 --> 00:42:53.820
to the preferences and we call
quit appmodeloop for window.

00:42:53.820 --> 00:42:56.780
That way, run appmodeloop for window will
exit and we can ultimately get out

00:42:56.860 --> 00:43:00.760
of do preferences and back into
the normal application processing.

00:43:00.980 --> 00:43:03.020
So this Magnify sample
code will be released,

00:43:03.070 --> 00:43:05.520
a sample code on the website,
very shortly,

00:43:05.520 --> 00:43:07.190
as soon as we can get it up there.

00:43:07.350 --> 00:43:11.290
Now those are just the basic
concepts for how you'd implement

00:43:11.370 --> 00:43:13.220
sort of Carbon Event handlers
and Carbon Event timers,

00:43:13.310 --> 00:43:17.920
but I want to show you the
true power of Carbon Events.

00:43:17.980 --> 00:43:21.310
We have another application
on here called Live Buttons.

00:43:21.830 --> 00:43:24.940
Now, Live Buttons looks a lot like
one of the earlier apps I built.

00:43:24.940 --> 00:43:26.830
It's just very simple,
kind of an ugly dialog.

00:43:26.880 --> 00:43:28.700
You know,
we've got some text fields in here.

00:43:28.700 --> 00:43:29.800
You know, we've got some buttons.

00:43:29.800 --> 00:43:32.560
You can pretend that this was,
I don't know, some kind of fine dialog.

00:43:32.560 --> 00:43:34.640
So you click search and it
goes off and does something.

00:43:34.640 --> 00:43:35.900
I mean,
we're not really doing anything here.

00:43:35.900 --> 00:43:37.260
We're just animating for fun.

00:43:37.320 --> 00:43:40.960
We've got an OK button, bevel button,
you know, a little disclosable area,

00:43:40.960 --> 00:43:41.950
stuff like that.

00:43:42.010 --> 00:43:45.370
And this is all being run by the toolbox.

00:43:45.470 --> 00:43:49.600
Now,
the cool thing is Live Buttons is set up

00:43:50.330 --> 00:43:54.780
such that we've installed Carbon event
handlers on all the controls in this

00:43:54.780 --> 00:43:57.200
window to intercept clicking and drawing.

00:43:57.260 --> 00:44:02.000
I can put it into this edit mode and
our handlers that we've installed know

00:44:02.060 --> 00:44:06.380
to intercept drawing by drawing blue
frames around each individual control and

00:44:06.380 --> 00:44:10.120
intercept clicking by giving you handles
that you can actually resize the controls

00:44:10.120 --> 00:44:11.930
and reposition things sort of live.

00:44:12.000 --> 00:44:14.290
You can move my button over here,
resize it so the

00:44:14.290 --> 00:44:17.460
HIV designers won't like it,
I'm going to move my bevel button

00:44:17.460 --> 00:44:19.090
around and do whatever I want.

00:44:19.210 --> 00:44:20.800
And as soon as you're
done fiddling with it,

00:44:20.800 --> 00:44:22.920
it's live button sample,
lets you turn off edit mode

00:44:22.920 --> 00:44:25.480
and you're back to normal.

00:44:25.520 --> 00:44:28.530
That's interesting,
but I can't--there we go.

00:44:32.840 --> 00:44:36.060
Now, on previous systems,
this sort of functionality would

00:44:36.060 --> 00:44:39.390
only be possible if you wrote lots
of extra code or patched the toolbox.

00:44:39.500 --> 00:44:42.570
But with Carbon Events,
we allow you to do things

00:44:42.570 --> 00:44:44.920
like this in a clean,
legal way.

00:44:45.320 --> 00:44:48.270
But Carbon Events certainly
aren't limited to just demo apps.

00:44:48.340 --> 00:44:50.800
If you've got a larger
document-based application,

00:44:50.800 --> 00:44:52.540
we can serve your needs too.

00:44:52.570 --> 00:44:53.640
Now this is simpler text.

00:44:53.640 --> 00:44:57.390
This is sort of a new version of
simple text that we're writing.

00:44:57.500 --> 00:45:35.100
[Transcript missing]

00:45:35.490 --> 00:45:38.330
and wire up functionality into
the font palette that just sends

00:45:38.440 --> 00:45:40.050
Carbon Events to the main window.

00:45:40.060 --> 00:45:41.700
So I can change the size over there,
I don't know,

00:45:41.700 --> 00:45:45.830
or change it with the pop-up or maybe
change it to bold and let's bring it

00:45:45.830 --> 00:45:48.900
back to 60 point and do stuff like that.

00:45:50.520 --> 00:45:53.180
Now, one other kind of cool thing
that we did in this sample is

00:45:53.180 --> 00:45:55.310
handling some window events.

00:45:55.380 --> 00:45:58.880
This font palette,
we set it up to handle the balance

00:45:59.250 --> 00:46:02.100
change Carbon Event to automatically
snap it to the edge of the window.

00:46:02.100 --> 00:46:03.780
I don't know if you can see
that jumping on the big screen,

00:46:03.820 --> 00:46:05.840
but as I get close it sort of
automatically snaps it there.

00:46:05.950 --> 00:46:08.800
A lot of applications like to group
their palettes together and you can

00:46:08.850 --> 00:46:10.610
override certain Carbon Events that way.

00:46:10.680 --> 00:46:14.330
But that's not the only thing you
can do with the balance change event.

00:46:14.340 --> 00:46:18.740
Now, balance change events are also
good for handling live resize.

00:46:18.740 --> 00:46:20.280
We decided to wire that up too.

00:46:20.280 --> 00:46:25.310
But then you can get really strange and
what if we only wanted this window to

00:46:25.310 --> 00:46:28.400
be displayed on a single monitor and as
the user moved it off you could actually

00:46:28.400 --> 00:46:31.160
scrunch it up in very weird ways.

00:46:31.160 --> 00:46:32.880
So you can do that too.

00:46:32.880 --> 00:46:35.980
There's all kinds of cool things
you can do with Carbon Events and

00:46:35.980 --> 00:46:37.240
they scale very well.

00:46:37.240 --> 00:46:38.800
I mean,
they're great for demos obviously,

00:46:38.840 --> 00:46:40.780
but you can fit them into
large scale applications.

00:46:40.780 --> 00:46:43.380
You can wire up little bits
of new functionality to

00:46:43.380 --> 00:46:44.300
take advantage of new tools.

00:46:44.300 --> 00:46:46.540
You can add little toolbox features
in such a way that it doesn't

00:46:46.550 --> 00:46:47.980
disrupt your existing application.

00:46:48.000 --> 00:46:49.050
So it's really cool.

00:46:49.080 --> 00:46:53.050
I'm going to hand it back over
to Ed for a couple more words.

00:46:57.500 --> 00:47:04.500
[Transcript missing]

00:47:05.540 --> 00:47:09.640
Well, item one,
start memorizing carbonevents.h.

00:47:09.640 --> 00:47:12.480
There will be a test at
the end of the conference.

00:47:12.500 --> 00:47:14.100
There's a lot of stuff in there.

00:47:14.100 --> 00:47:17.500
We have a lot of documentation
in the header itself to help

00:47:17.500 --> 00:47:19.710
you along and get you started.

00:47:19.740 --> 00:47:22.730
The Learning Carbon book has
some examples of how to write a

00:47:22.730 --> 00:47:25.260
Carbon Event-based application.

00:47:25.270 --> 00:47:29.730
I've submitted an article to
Mac Tech which goes into this stuff

00:47:29.830 --> 00:47:34.600
in way more detail than we can talk,
you know, in an hour about.

00:47:34.600 --> 00:47:38.100
And just start playing with, you know,
interface builder, project builder.

00:47:38.210 --> 00:47:40.480
Start building Carbon Event-based apps.

00:47:40.480 --> 00:47:42.100
It's really easy to start.

00:47:42.100 --> 00:47:42.100
You can just, you

00:47:42.280 --> 00:47:45.960
Create a default app and start installing
handles and see what you can do.

00:47:45.960 --> 00:47:50.400
I mean the little demo where you
drag the window to the corner of

00:47:50.420 --> 00:47:54.040
the screen and it kind of scrunches,
that took about 10 minutes to write.

00:47:54.170 --> 00:47:57.650
So, I mean this stuff is really
easy to do and like I said,

00:47:57.650 --> 00:48:01.340
there's just a lot of powerful
things you can do with not much code.

00:48:01.430 --> 00:48:04.370
And that means there's much more
time for you to spend doing the stuff

00:48:04.540 --> 00:48:06.340
that makes your applications great.

00:48:06.480 --> 00:48:10.370
And with that,
I'd like to bring out Mark Turner again

00:48:10.490 --> 00:48:12.240
to lead us through the roadmap and Q&A.

00:48:12.300 --> 00:48:13.810
Thanks.

00:48:18.930 --> 00:48:19.370
Thank you, Ed.

00:48:19.520 --> 00:48:20.690
Wow.

00:48:20.870 --> 00:48:25.700
Those were some kick-ass demos, huh?

00:48:26.090 --> 00:48:28.230
Thank you Guy.

00:48:28.230 --> 00:48:33.340
Okay, so here we are, 6 o'clock Tuesday.

00:48:33.340 --> 00:48:36.780
The next session you
should attend is tomorrow,

00:48:36.870 --> 00:48:37.870
Carbon Windows and Menus.

00:48:37.880 --> 00:48:42.790
Ed will be back to share with you some
great stuff about Windows and Menus,

00:48:43.110 --> 00:48:43.540
obviously.

00:48:43.540 --> 00:48:48.610
As you can see, the next two,
Controls and Appearance 1 and 2,

00:48:48.660 --> 00:48:50.900
a good pair of sessions to catch.

00:48:50.900 --> 00:48:54.150
And finally, I really recommend the
Carbon Performance Tuning

00:48:54.150 --> 00:48:55.740
session coming up on Thursday.

00:48:55.900 --> 00:49:00.990
If you attended the keynote
or Avi's presentation,

00:49:01.310 --> 00:49:05.670
basically every presentation on Monday,
we talked a lot about performance

00:49:05.710 --> 00:49:11.200
and how the characteristics of
your app's performance vary whether

00:49:11.200 --> 00:49:15.200
you're running on 8 or 9 or Mac OS X.

00:49:15.200 --> 00:49:20.260
And so, this Carbon Performance Tuning
session will give you a

00:49:20.260 --> 00:49:20.800
lot of useful information.

00:49:20.800 --> 00:49:25.580
useful information on how to
tune your app for Mac OS X.
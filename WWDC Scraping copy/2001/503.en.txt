---
Title:  Java Development Tools
Year:   2001
Web:    https://nonstrict.eu/wwdcindex/wwdc2001/503/

[!] This transcript was generated using Whisper, it has known transcription errors.
---

Good morning and welcome to the chaos here. As you can see, we've been frantically working to put all of these demos together for you. This session is something that Steve Llewellyn and I had talked about sort of as a showcase to all of you folks that are doing Java development as to what tools are available both from Apple's side and from third party's side.

And we wanted to put this together. I'll give you an agenda with who we're going to talk about today. We've got obviously Project Builder. We'll have Dave Ewing from the Project Builder team up here to demonstrate Project Builder. I'm not going to talk too much, just a little bit here this morning. We've actually got Scott Adler from our Java team at Apple who will be demoing on behalf of VMGear with a product, Optimizeit. We'll have Blake Stone. I'm sure some of you have already seen him in some of the earlier sessions.

Demonstrating JBuilder. And then we'll have some new things that I don't think have been seen anywhere, hopefully, from install, well actually from ZeroG, two products from them. And then lastly, we'll have MetroWorks showing the latest advances with Java and their Code Warrior product. So with trying to put together all of those demonstrations and all the various machines, we'll pray that the demo gods are with us today.

And everything goes off without a hitch. So with that, I'm going to go ahead and bring... Dave Ewing up to give you guys a demonstration. We're just going to have him walk through Project Builder and show you some of the great features that are Java specific with Project Builder. Thanks, Alan.

Thank you for the demos. So I was going to take a long time here knowing that I was first and didn't have to worry about time, but we've already started late, so I guess I've got to get going. There we go. So you guys have all seen Project Builder here. You're going to see it more in lots of other sessions, I'm sure. So the thing to note is that Project Builder does a lot of stuff.

Java is just one of them. I don't need to go through all this stuff. That slide is actually similar to slides in lots of other sessions, too. So why would you use Project Builder to do Java? Well, for one thing, it's a full Java integrated development environment. Java is a full class citizen in Project Builder. And another reason is that Project Builder, from the beginning, has supported all of the Mac OS X platform initiatives.

If you're building an application on Mac OS X, even if it's a Java application, you can do it the right way and build it as a bundle. Another thing you might use Java in Project Builder 4 is to do Cocoa development. Cocoa, most of the time people think of Objective-C with Cocoa, but actually Java is a very good way to do Cocoa.

With that, you can use Interface Builder to build your UI, even for Java, not just for Objective-C. Of course, Interface Builder supports Cocoa, not Swing, so that's something to remember. I know a lot of people get confused by that. The final thing I'll mention here is that if you have other source out there that's not Java, a bunch of C Source or C++, and you need to get to that too, you can use the Java native interface to get to it. and develop all that code in the same project together.

And with that, I'm actually going to demo just that, a JNI project here. Okay, so I have this little demo project here. It's actually very simple. It just has one C source file and one Java file. And if we look at the C source code, it does some heavy duty math here. It adds two numbers. Okay, it's a demo, right?

And if we go ahead and then, this will be built into a JNI library of course. Go ahead and look at the Java source file. Wow, copyright Apple 2000, it's an old demo. In the main class here, CalcEngine, it does a system load library on that JNI library. No big surprise if you do JNI. And at the very bottom, there's a main routine that, guess what, calls the native class. So, it calls the native function there.

Okay, well let's take a little look at how the targets are actually set up for this. We have one main target here that builds everything, and underneath that it has some dependencies set up to the other targets. The first one generates or compiles the Java sources, and then there's a JNI library that has to get built of course. And I actually have a third target here that generates Javadoc.

Now Project Builder doesn't actually have integrated Java doc support in it, but it's actually pretty easy to do that. So we just have a shell script build phase in this particular target that calls out to do the Java doc. Not the prettiest, but you know what? You can do it. And that's testament to the flexibility of Project Builder.

Okay, well let's go and look at the Java sources target. This one's somewhat interesting. I mean, it builds the Java source file. That's no big deal. The one thing it does do at the end is it also has a shell script build phase, and this one calls out to Java H.

Now, it's not really necessary to use Java H when you do JNI libraries, but it's a good idea because it allows you to keep your Java source code and your C source code in sync. So, that little C example that had, it actually had add and multiply. It had a few routines in it. It just doesn't know how to just add. You know, if you got out of sync, that file really does include the .h file that's used, that's generated here by Java H.

Okay, and then the final target I want to show you is actually the building of the JNI library. Not much here in the build phases. All it does is compile that C source file. No big deal. If we look at the settings, we see that it creates a file called lib calcengine.jnilib. That's what a JNI library looks like on Mac OS X. The final interesting thing in this panel here, down at the bottom, When you're building a JNI library, you want to set the library style to bundle.

And then the other tab, just to show you. When we run this little demo here, what we actually run is Java, the executable up here.

[Transcript missing]

Another thing to look at here is you can actually choose which debugger you want to use in Project Builder. So you can actually use GDB to debug the native code, and that's using GDB underneath in here, so you debug with the GUI in Project Builder. Or you can use the Java debugger.

And we're going to use the Java debugger, so I'm just going to do a quick... I've already built this project, so... At least I hope it's built. It was yesterday. Okay, so we stop here in the debugger. Standard pane to look at the variables for the local routine. This particular stack's not very interesting, just the main routine is on it. We have a pop-up here to switch between threads. And we can go to another thread, the reference handler. And... Oop, it's taking its time.

I should have been patient. I selected on something else. So anyhow, you can drill down into variables. Pretty standard stuff. Well, let's go ahead and continue to that other breakpoint. You can see in the console view up above, or perhaps you can see that it printed out that first print line. And we stopped at the second one that says the result is result. And you can look in the variable pane. And in fact, you can change that result if you want.

Okay, so we now have a new result. We can step and see that it printed out the new value. It's a good thing we used JNI for this demo. Got the wrong answer, didn't it? And you know what? That's about it. That's all I need to show here. I think you're going to see Project Builder in a lot of other places, so let's save a little time and get on with the other folks.

So we'll go ahead and invite Scott Adler up. Scott's going to talk a little bit about VMGear. Thanks a lot. It's actually really fun for me to be up here to show Optimizeit. The people from VMGear couldn't be here and they came by. We've been working with them to get all the profiling information into our new VM.

And they came to Apple and worked with us a little bit on getting up their product. And it's really fun because I've been doing Java programming for about five years and this tool is really useful. I don't know, are there people in the audience who have used this tool? A couple?

Okay, great. So it's an excellent tool for taking your Java application and just figuring out what's going on under the covers. So here's a little overview of what Optimizeit does. It's a good profiling solution. You can also fix all of your performance issues. Now, not all of them, but you'll be able to find the hotspots and determine what's really going on. So let's go to a little bit of what common Java performance problems are.

Now, there sort of are two different main areas of Java problems. One is memory allocation that might take a while. This has gotten a lot better in hotspot, so sometimes it's really good to run through an optimizer to see what's actually happening, how well hotspot's taking care of this for you.

But there are things like the cost of your garbage collections, whether you're allocating things in a tight loop. Sometimes hotspot takes care of that really well for you. Sometimes there are other things that are going on. So garbage collections really are the big thing. If you're somehow allocating a whole lot and you're hitting the top of your memory limit and the garbage collector is kicking in and you've got a multi-threaded application, it's going to stop all your threads because it has to go parse all these trees of relationships and then as soon as it's done, all your threads will be let go again. So you don't want to be garbage collecting a lot during your running if you have a UI going or something. The other thing is memory leaks. One of the promises of garbage collection is that you don't have memory leaks. The problem is we still make mistakes.

We still do things like write a program where we have things that are listening to other objects so they're linked together and they end up in this complex chain. And you do things like add action listener and you forget to remove action listener. Well, that's just as bad as not calling delete. So you want to find your references. You want to make sure that you're disconnecting things. You want to make sure that you're disconnecting things correctly when you delete objects.

And then the other big thing is unsuspected performance bottlenecks. And that's actually huge because you don't want to sit down and necessarily architect your code for ultimate performance when you don't know what your performance issues are. Obviously, you know some big things but you don't want to go and write this great tight algorithm that really isn't your bottleneck and spend like three months on that and then realize, well, actually it's your drawing code that's bad. So that's really useful. So you get to code, you know, code clean, code all your objects really well and then find out what your hotspots are and then go jump into them and send your performance engineers after that. So I'll run through a quick demo.

So what I have running here on number, guest one, and others. you instantiate their classes which then instantiate your classes. So they put a couple of hooks underneath you. And then what you, that's one way to start it. And then what you can do is you can connect to that remotely.

So what I have is I have this really, my CAN demo, this is a little bit of swing set I took in here, and just put some members of the team and I put some sorting on here so we can just play with a little bit of performance settings. Now this I ran just by calling the optimize it classes and then launching my class.

So now that this is up and running, I can go to optimize it, which I already started up just so I can be a little quicker. And here's optimize it's settings. And this comes up when you start up optimize it. You've got all these different settings. I'm not sure if you can read these that well, but there's application, applet, servlet, and remote application. So I'm doing the remote application.

Because it's pretty cool. It lets you start up your application separately from optimize it. And it lets you then connect to it. So right here I've got host name, which says local host. This could be two machine profiling. So if I didn't want optimize it to interfere with the profiling performance on the other machine, I can set up another machine and just connect to it over the net. So I also have here the source path set up to my source, and you'll see a little more about that later. So if I just attach to this program, now optimize it will come up.

. . . . And what it first does is it connects to the program. And let's get rid of my filter here. And it shows us the -- right here is what mode you're in. And it shows us that we're in memory allocation profiler mode. And we see all of the objects that have been allocated. And this is since it's booted up. So since this application started.

So we can see we have a ton of char arrays, strings, objects, and all this stuff. And this can be a little useful, but you tend to be able to do this. You tend to be overwhelmed by this. So you might want to jump down into things that are in your code. So I know that I have a class called sort something. Or wait, maybe it's not sort. It's called like table something.

So here are all my table demo classes. Now, if you know in this, this has all my interclasses also, which is kind of cool. They're anonymous interclasses, so they get these numbers if you know about how this works. So I see that I have two table demos, and I might want to say, you know, what's going on? Why are these around? Where were they allocated?

So I can just double-click on these, and I can see that I had two table demos, and this is really useful if you have hundreds, thousands of things, but it's showing me an allocation pathway to each object. So I can go here and say, okay, I've got two instances.

One of them was instantiated here, and I see, oh, this was done in SwingSet 2 preload first demo. And if I want to see, you know, what's actually going on there, I just double-click here, and this brings up the Optimizeit source code viewer, and I can see, oh, here's where it was.

It just made a new table demo. And if I want to see the other one and see, you know, why are these created in different places? I can look down here and see that I've actually got...

[Transcript missing]

It's now creating a whole new test window, and we should see a whole bunch of instances show up.

And what's interesting about this is that now I can look at just the things that have happened since I did that action, and I know I only did that one thing. And then I can, right here, is the garbage collector, and the garbage collector isn't running very often because we don't really need to.

So I can click here and run the garbage collector, and it should clean up a whole bunch of things. Not all of them because, obviously, name, color, there are a whole bunch in there. If we look down here, table demo, we should have, we got two more of them. I'm not sure exactly why, so we could go try to find out where they came from.

and we can see that we've got four of them. Now, I may only want to look at some others, so I go back here and... So I want to see just the allocations since I put my mark in. So I say show allocations and I see that I had two allocations and that might be confusing to me. Why did I have two? I only pressed new menu once. So I can go through here and see that I had an action performed swing set two and that was through my menu item.

And I also see that I'm loading a load demo. So that to me says that I've got some error in my code. I'm loading this twice for some reason when I have one menu item. So I can go track it down and fix it. The other interesting thing is if you are trying to find why things are sitting around in memory, you can go here to your and others.

Please join me in welcoming the next speakers. Alan Samuel, Dave Ewing, Scott Adler, Blake Stone, Eric Shapiro, Serge Beauchamp, Ravindranath Kurupati and others. Please join me in welcoming the next speakers. Please join me in welcoming the next speakers. to see like when you run the garbage collector, you should see garbage collector activity crank up and then back down.

Right here are some threads, whether they're active. If I actually go to my demo and tell it to sort, you should see I've threaded this little demo. So, you've got a thread right here that appears and disappears. These are the current number of threads they actually have and usually there's just one, your event, the guys waiting for your events.

Then you can also look at loading classes and see, you can see what classes, how many classes are loaded. So, if you have a dynamic loading application, you should see that you don't load everything right at the beginning and then when you start getting to more parts of your application, things get loaded. So, there's one other big portion of this which is the CPU profiler which is really cool and I'll be showing it at the Java performance demo.

That's 5:04, that's this afternoon. It basically lets you profile the whole application and it's really useful but I don't have enough time to show it here today, right now. So, come to 5:04 and you can see a little more about this. So, let's go back to the slides.

So I just want to run over what the strengths are of Optimizeit. The biggest thing is that you basically can profile your Java code without any recompiling. All you do is you run it using the Optimizeit runtime, basically. It's really easy to configure. It's easy to use. I didn't show it exactly back here, but when you first come up, you have a whole option to launch it all from Optimizeit. So if you don't want to launch it separately, you can just launch it right there. You can set up all your class paths and everything. Yeah, I'm done with that.

And then the other thing is that it's very scalable. Now, you may not have noticed it during the demo, but when I did things, it didn't automatically load everything that came in. So when I asked for object allocation graphs, it would only load them as I needed them. So that's really important when you've got a giant servlet runner that has maybe 20 threads running with hundreds or thousands of objects. You don't want to load all of your instance data all right at the beginning.

You just want to look at the portions that you're interested in. And if you're loading it all, it might take forever. So that's really important. It's a really good feature. And the other thing I wanted to mention about this, just two quick things. One is the UI for Optimizeit is done in IFC. I don't know if many of you know that, but that's why it doesn't look like Aqua. So I encourage you to encourage the other developers at VMGear to work on a swing version. And also that this needs the 131 VMGear.

So it needs DP1. You need to activate the hotspot VM, and there's information in the 131 release on how to do that. The other thing is they haven't committed to a specific release date. They've said fourth quarter. So again, send them email, find out when they're going to have releases, but it's an excellent tool. We use it internally because we have tons of Java code. Our Java implementation has lots of Java code, and we use it all the time. I had an engineer come into my office.

He ran through some of our graphics code and found in 20 minutes found something that was slowing us down like 20 times. So it's really useful. So that's about it. And here's the contact info for VMGear. Pretty much VMGear.com. It used to be intuitive if you used Optimizeit before.

Thank you, Scott. Next, I want to go ahead and bring up Blake Stone from Borland. He's going to give us another exciting demonstration for JBuilder. And then you've got a session later on tomorrow, is it? Today. Actually, it's today. Today, 5:00. I've got so many sessions, I can't remember.

Okay, thank you, Alan. I'm just going to jump into a couple of slides here, so we'll quickly run through those. And then we'll jump in and do a little bit of demonstration. I have to try to juggle some things. So you see some cool things during the Java address yesterday.

We'll show you a couple of interesting things here, but we'll save a lot of the really good stuff for the session at 5 o'clock. So if you want to see a lot of the new features of JBuilder 5, if you want to see things specific to web development, XML development, we'll defer those to the 5 o'clock session, and we'll focus on some of the basics of Java development here.

I wanted to talk a little bit about, specifically of course, JBuilder 5 for Mac OS X. The real focus of this product is not on saleability, marketability, buzzword compliance, but on extreme productivity. We are Java developers ourselves. JBuilder is written entirely in Java, so day by day we find out what makes us more productive, and we improve the tool to make you more productive as Java developers. So rapid coding and visual development are a big focus, and we'll look at that a little bit.

But integrated debugging and having just a state-of-the-art debugger that takes advantage of everything that we can get from the VM is a big piece of what we do. And of course, JDK 1.3.1 is an important piece of the debugging story, so that's underway. And of course, you'll have a developer preview of that shortly.

There's support in there for Java beans-based development, database development, XML, JSP. A lot of the really big things that our customers told us were important to them and that we see we need internally to manage our own systems are things like this. So we've got a lot of things we've put into JBuilder.

So it really covers a very broad spectrum of what the pure Java developer is really interested in. That's our primary focus is people doing pure Java development. The product, again, is really written entirely in Java. We have a tiny little stub that gets us launched, gets the VM kicked off. But then the product is Java and winds up being a wonderful torture test for Apple. So we've been working very closely with Apple to make sure that this enormous application works well on their VM. And it really is testament to the fact that we're working with Apple.

And it really is testament to the hard work they've done that it works because JBuilder has more classes in it than the whole JDK does. So we are not a small app. But we've done some work to specifically tailor it for Mac OS X. So I'll showcase a little bit of that as well. Yes, it's the same source code that we use elsewhere. But we like to make sure that it really looks nice and works well in the Aqua look and feel and added some features specifically for Macintosh users.

Where should I be aiming this? There we go. Feeding the Macintosh spirit was a critical sort of key theme for us. We don't need to produce a product that is some port, some popular Unix thing that you guys happen to get access to and should be happy about it.

Instead, we want you to really feel like this is something that is the way Macintosh users would have done it in the first place because you guys have a fantastic platform to work on and you really deserve the best tools possible. So, yeah, it's nice that you have the best-selling Java OS X.

We have IDE forthcoming for Mac OS X and we win tons of awards on that basis, but this is not sort of a stepchild of JBuilder on other platforms in a lot of ways. We showcased, of course, at a technology preview last year JBuilder 4. Well, what we're showcasing this year is JBuilder 5, which we announced last week.

So, this isn't a long porting process here. This is something we're keeping right up to date on. We are trying our very best here to get to the point where all the technologies are in place to release this and to give you the full product that you see elsewhere, a world-class product that really takes advantage of the platform.

It's been interesting that JBuilder on Mac OS X has been very tightly connected to WWDC. I've been happy to be here three years in a row now. The first year I was here, just talking to people, seeing, you know, is Java really important to Apple? Is this something you'd be interested in?

And talking to a lot of you to say, you know, do you remember Borland from the days when we had Macintosh products? And, you know, would you be excited about something like JBuilder? And we were told resoundingly that, yes, Java was important to the future of Apple. Just wait. There will be cool things happening.

And, of course, the Java 2 announcement was in the works at that point. And so we started doing a little bit of work in, I guess, the spring of last year to bring a tech demo last year. Now, the tech demo was obviously really early. We're running on a pre-release VM that's running on a pre-release operating system a good year ahead of when it would really be ready for prime time.

So we were happy to be able to get that level. But here, of course, we've given you all previews. You have a CD in your bag that will let you look at JBuilder. And please, please, please pull the updated VM before you consider what the performance and stability is like.

The updated VM should improve things dramatically over the one that shipped with Mac OS X. Our support from Apple has been phenomenal. Of course, Mac OS X itself provides a phenomenal foundation for Java 2. Without the robust multitasking, symmetric multiprocessing, multithreaded environment that Mac OS X is, Java 2 would be enormously difficult to put on the Mac. But Apple's enthusiasm and partnership has been a big piece of this. And a really key piece for us is JDK 1.3.1. A lot of people have asked, when are you going to ship?

What's holding you? And the answer really is that JDK 1.3.0, through no fault of Apple's, has some pretty enormous debugging issues. And Apple is working hard at integrating a lot of the fixes for those in 1.3.1. And when that release is available, that's when JBuilder really starts counting down to release. So we're looking forward to getting there.

We're going to be able to get there as fast as we possibly can. But this is the missing piece. This is also, of course, what you will get with the update, the developer preview release. So with that, let's just launch in and do a little bit of a demo. I didn't want to spend a lot of time on this, but if we can bring up demo 2 here.

I did want to showcase some of what I think is particularly exciting about JBuilder, not just the nifty Aqua icon. JBuilder itself, again, is really focused on developers. So rather than spending time hiding your code from you, we really spend a lot of time focusing on what we can do to make your coding environment especially effective.

So if you go into an arbitrary example and open a piece of source code, the source code takes up the majority of your screen, but we spent a lot of time finding ways to add value to the source code editor that we have. The source code editor provides, of course, the usual features you'd expect elsewhere, the ability to indent and unindent blocks of code, the ability to undo an infinite number of steps and redo an infinite number of steps, so just a high productivity editing environment. But a high productivity editing environment with keystrokes you're not comfortable with wouldn't be all that useful.

I will apologize. I've been using the keystrokes my mind is trained to use here. But we do provide two sets of keybindings specific to Macintosh customers. The Macintosh keybindings will use sort of a classical, more of a Project Builder, TextEdit type set of keystrokes, whereas for those of you who are familiar with BBEdit, CodeWarrior, what have you, we've also implemented those keybindings. And you can even go in and customize them. So if we've missed a keybinding, we can go in and customize it. And if you've missed out on some of your favorites, you can go in and tailor those keybindings to your need.

So, okay, that gets us productive right away in doing things in the editor. Let's see if we can get that back to where it was. But also we wanted to provide really rapid browsing mechanisms. So we provide a structural overview of your file here that says you have a class that has all of these members that you can quickly get to, but also that's dynamically updated. So as I define a new class, you can see that that new class simply shows up. As I go ahead and add members to it, then they'll show up.

And this is tracked in real time as you're coding. So I'm going to set a really low delay. We normally keep this delay higher to avoid driving you nuts with all the flickering going on. But as I type, you can see that we're actually able to parse the source code and keep that up to date.

So not only do we know about the members and so forth, but in order to figure out what the members are, we need to know whether your code is actually syntactically correct. And whenever you have something that is an illegal piece of code that doesn't follow the Java syntax rules, we can show you why, where that problem is, and help you get to it immediately, rather than having to go through a compile cycle to find that kind of thing.

So that's all pretty cool, but it helps you at sort of the Java syntactic level, and that's one part of the Java programming puzzle. The other major part of the puzzle are the libraries. They're huge. There are an enormous number of Java classes available. There are probably more classes being introduced every day than you can possibly learn in that day. So what you need are tools that help you with these things, and that's what we've provided here. We've provided technology, which we call Code Insight, that allows me to say, you know, if I'd like to create a new J button, then what are the possible constructors?

Well, there are constructors that take these various parameters. I need to pass an icon or an action or what have you. And let's say I want to go ahead and use something from the current scope. I can also get a list of things that are available in the current scope.

So if I want to pass a string that I already have declared, let's come up here and create a string foo that contains some information. And I don't remember the name of my local variable. Or I've used an extremely long local variable name. Then our Code Insight can assist you. For example, if I had this as my variable name.

Then I can just select it from a list by typing the first couple of characters and we get the rest. So that technology exists for browsing class names, for finding out about parameter types, for finding out about parameter names as well. You'll note that you get not just that this takes a string and an icon, but the string text and the icon icon.

Perhaps most importantly for the Code Insight technology, it's completely dynamic. It's not hard coded to understand particular JDK classes, but it understands any class you could possibly throw at it. So for example, if I come in and I say I'd like to create a new com.apple, it says, well here are the sub packages in com.apple.

There's no specific code for this at all. I just know that there's some classes out there and I can browse them. And I go and look for a completely unprepared here class and we'll see what constructors are there. And it turns out it's actually an interface. So there are no constructors. constructors.

But that's interesting in itself. If it's an interface, does it have any interesting constants or static members? Sure. So we can browse and discover all this stuff on the fly. We can discover it so completely on the fly that if I were to go ahead and declare right now my class foo with a public void bar method, and to come down here and create a new foo and go to invoke methods, look who shows up.

So we're parsing and analyzing all of your code on the fly all the time and that's a really key piece. The one other thing that I wanted to demonstrate really briefly, because I'm assuming I'm eating into other people's time if I don't stop this quickly, is the visual design aspect. Because if you're doing raw coding for Swing, it can take a long time to figure out how to get the effect you want.

But if you can just drag and drop components, you can get there really rapidly. So we provide a way of visually designing something that I can say I'd like a button here, I'd like a text field here, I would like a scrolling region with, say, a tree in it here.

And what we do behind the scenes is write the source code that you would have had to write in order to accomplish that. So you see here in JBInit, we have all the constructors and things that do set text. Here we go, for example, on the button, JButton1. But what's really unique to JBuilder's approach is what we call two-way tools.

We aren't just generating code for you. The code is the complete repository of our knowledge about the design. So if I go and actually change the code or do something really torturous, like actually put an expression in there and flip back to design, we'll go and actually have a look at your code and reproduce to reproduce what you've done.

So I hope that's enough to get you intrigued. We'll be in the Civic at 5 o'clock, and I certainly welcome all of you there. We'll hopefully have time to answer questions there, which we probably won't run into at this session. So thank you very much, Alan, and we'll see you later.

Okay, next we want to bring up Zero-G. We've got Eric and Michael. And you've got the clicker and you're set. Excellent. Morning, everybody. My name is Michael Acosta, and I'm the lead architect for InstallAnywhere. I'm here with Eric Shapiro, who is our founder of Zero-G. And we're really excited to be here, one, because we finally got our demo working not 15 minutes ago, but also because you've seen a lot of products here that are helping you to develop your Java applications. Once you're done developing your Java applications, you're going to need to ship them.

And you're going to need to keep them updated, maintained, configured on the machines. That's what Zero-G provides. And Eric's got some slides. He's going to show you. He's going to get the slides up. Can we get the slides back up here? Actually, I think your mic might not be working there.

So OK. So what we're going to do here-- you're just going to have to talk really loud, so I'm sure you can do that. What we're going to do here is we're going to show you a bunch of different things. We've been in doing Java development now for about five years. We've been partners with Apple during that entire time, focusing in on after you have completed your applications, after you've written them using any of the great tools out there. Some of the stuff that we've just seen, some of the stuff we're going to see.

What do you do next? You want to get it out to your users. You need to create a great installer for that. And we've got two products, one that some of you may have seen before, which is Install Anywhere, another product called Power Update, which we're introducing here and showing this on Mac OS X. We've been supporting Mac OS 9 and other platforms for the last several years.

So, the first thing I want to do is talk a little bit about InstallAnywhere. InstallAnywhere allows you to create a single installer. An installer that's entirely Java based and allows you to run that installation, installing your application on any Java platform. We've supported the Mac OS for a while, we support Windows, Linux, Solaris, HPUX, AIX, all across the board.

Pretty much anything you want to do with a single installer that gives you the same look and feel across all the platforms. Now I say look and feel, and really what I'm saying here is feel, because we're going to show you in just a minute here is how on the Macintosh it's incredibly important for us to have the look that people expect, the Aqua looks. We're going to show you that.

In addition to that is a technology that's part of InstallAnywhere called LaunchAnywhere. And as many of you know, it's incredibly difficult to convince your users how to run your Java applications. You may have developed on a Macintosh, you don't have a command line if you're using Mac OS 9, you do have a command line when you're using Mac OS X, but your Windows users have command lines and batch files and your Solaris users have those as well. And so what are they going to do? Well, our technology, which is called LaunchAnywhere, allows you to go ahead and create a single launcher technology that allows your users to double click the application just by clicking on an icon.

Now the other thing that we're going to be talking about here is... A little bit about the architecture here is about what you can do with InstallAnywhere. InstallAnywhere can build you an installer which can run from a CD-ROM or you can put it onto a deployment server, onto a web server, and you can do web installs. We're going to show you a little bit about that today.

It allows you to do installations right from the web browser. We don't have that working today with Mac OS X, but it will as soon as we get the new release that Blake was talking about just a little while ago as well, and so everybody will get that support as well.

Power Update is a new thing that a lot of people out there have said, okay, installation's great, but I've got to keep my software updated. How do I do that? Well, Apple's got a great technology software update, but it's not available to third parties. And what Power Update does for you is it gives you the ability to add software updating, live updating to your applications.

Not just Java applications, any kind of application at all. In fact, the focus of InstallAnywhere with our new release that's coming out is that you can install native applications on Mac OS X, and you can add Power Update to it, and you can get the live updating functionality that you would expect to get from software update as an example.

The Power Update architecture is a little bit more intense compared to InstallAnywhere in the sense that it does require a server component, Power Update Server, which is where you get your software updates from. And there's a management aspect to that as well, so you can say, "Here's the versions that I've got, here's the versions that I want my users to have, etc." Now, a real challenge for us has been, as we've been focusing on the great look and feel and trying to make sure that all this stuff looks great on the Macintosh, well, one of the things that we wanted to do, very important for us, is to show how great the Macintosh platform is as a Java server platform.

And, in fact, we'll be running the Power Update Server on our Mac OS X machines up here, and that's a J2EE application that's got the complete software stack running a Java web server, running a database, running the JSPs and servlets and all the connections and the reporting modules and all that, and we're running that up here as well.

and enough of me talking, let's go ahead into a demo. And what we're going to do here is we're going to do a side-by-side demo because this is really a combination of both a developer tool and an end-user experience. And again, it's really important for us to be having that end-user experience. So what we have here that you'll see on the screen is two different things.

On your left-hand side is the end-user experience. This is what your customers will see. On the right-hand side is the experience of what you as the software developer will see. And we're going to tag team our demos here. And I'm going to let Michael go ahead and take over first. If you could look over there while I log us into the developer system on this side.

Can you guys hear me? Yeah. Okay, good. Okay, what we have right here is an Internet Explorer, a web page. And this web page, when you actually build your installers for the various platforms, is automatically generated. And right where you see this right here, this is where the applet would typically be.

What the applet allows you to do is actually start the installation from the web. What that does is it will download it, it will fire it right off, so all they have to do is click on the button and get ready to go. Alternatively, we list all the different platforms that you've built for, and they can just download it directly.

Say they want to get something that's for another platform, and then just put it on a central server so they can go ahead and distribute it among the corporation, that's fine as well. But I've already downloaded one, got one ready to go, so I'm just going to go ahead and start that for you. Why don't we go ahead and quit those guys so that we don't get confused with the installer that runs in the web page. Okay.

[Transcript missing]

Now, what Michael just did there is the full installation talking about what we have installed, but it's important how you represent what that is. And so, a lot of us in the Macintosh like to see a representation of your files and what they're going to be. So again, over here what we see is on our Install tab, we have a representation of what your files will look like on the end user system.

This is really important because you don't know what that end user is going to have. You don't know what their directory structure is like, you don't know where their home folders are, you don't know if they're on a Solaris machine, a Windows machine, or of course a Macintosh. And so what you want to do is you want to set up your installer in a way where you're referring to things in a magical way, in a way where it determines what those folders are at runtime, at install time.

We happen to call those things magic folders. So, as you can see here, we have a bunch of files that we're installing. If you choose to take a file or a folder and you want to put it into a different location, you have this selection of all these different magic folders available to you, including ones for the Macintosh, including ones specifically for other platforms like Unix platforms, or as you can see here, we have some of the Windows platform locations on there as well. Or if you choose those here at the top, these are ones that are platform independent. So if you choose the desktop location, it will figure that out for whatever platform you're on. Mac OS Classic, Mac OS X, Windows, what have you.

And if we talk about things like shortcuts or program folders, what those are is we call them aliases, Unix people call them symbolic links, but basically what you can do is you can specify, you can say, "I want to install my shortcuts into wherever the default location is for that operating system." So when I go ahead over here to my platforms tab, I can see that, for instance here, for Windows, we have the default location for shortcuts go into the programs menu. But on Mac OS, the default alias location is on the desktop. Now you can choose this independently for each platform.

One additional thing, before we go back to Michael here, is the idea that you do sometimes have files, as we all know, even Java applications occasionally have something that you might need to add in, which is platform specific. Maybe it's a runtime library, or it's some kind of a launcher or something like we talked about before. Well, I can take any file here, and I can add a rule to it by simply saying, clicking on the rules tab here, saying check platform.

Now, if I only want that application to install on Mac OS and Mac OS X, I do that, and now this file here will only install on those platforms, allowing you to build, again, one single installer, which will run on all platforms for all languages around the world. So let's go ahead, I'm going to show you one more thing over here.

Leave it right here, because I actually want to point out one thing. The interesting thing about developing with InstallAnywhere, what makes it so easy, is when you do add your files in, it's basically what you see is what you get. And that's why I've switched over here to the list view.

If you look at the two views, you'll see that, although some of the things might be out of order because of the ordering, the sorting, what you see is what you get. They're basically the exact same. If you drop down com, you'll see they look exactly the same in between.

And that's really important so that you know that it's going to be laid out in the designer is exactly what you're going to get on the destination system. Great. Now, we also talked about the object. So, the idea that you can build this single installer for all platforms. And, as we know, the premier platform out there has Java included with it, but not all platforms out there are as...

[Transcript missing]

The next section here is where can I go and get those updates from.

This one here says where am I going to go and deliver those updates to the end user and is that version live. Now I've already made this version live here so let's go back to our overview and we'll see that that version is live, version 10, and user, could you please go check for updates.

So it's a very clean simple interface. There's actually several different interfaces that you can do. You can actually hook up Power Update directly into your application and run it silently in the background every time you launch your application for instance or as we do in InstallAnywhere you can add a check for updates, pull down menu.

So what I'm going to do is I'm going to go ahead and connect to the server. It's giving me feedback as to what's going on. Oh, sorry. And there is a new version of Office Suite available with Aqua. Excellent. Click Next. and it's been successfully updated. So if I go back and I launch Office Suite, let's see if this has worked.

Excellent. From Mac OS X. Excellent. And lo and behold, we've given you a little surprise. We also updated your toolbar there with the new Aqua look and feel for Office Suite. For those of you wondering, Office Suite is just a demo application. It actually is not a real product. But if you try InstallAnywhere, it does come with it, so you can play around with doing that. Okay, so that's our demo. I did want to leave you with one thing, a final thought.

I'm actually not going to be able to do it because it's licensed. Oh well, you won't be able to show the Easter egg that's built into InstallAnywhere. I have a very interesting Easter egg that I had written especially for this. But if you stop by our booth, we'll be giving demos. We're here until the end of the day today. And in addition, you can get more information on our website, www.zerog.com. Thanks a lot, everybody.

I'm going to go ahead and invite MetroWorks up here and give you a demo of the latest CodeWarrior tools. I'm Ravi Kurupati and Serge Beauchamp. We are the Java team in MetroWorks. As everybody knows, 95% of the people on Macintosh are CodeWarriors, and we would like to actually have the Java supporting CodeWarrior as much as we can.

But in the previous release of Java, when we released it, we had public beta, and then we made sure that our tools work on public beta. But the previous version of Java 6.0, all the support is not there on OS X. So what we have here in Early Access is all the Java support functionality on OS X.

So all the Java RAD stuff, we got it working on X, and the Java debugger performance is much improved now. So it's far better than what we had in OS 9. So there are a lot of improvements in the Early Access, and Serge will go through the technical details, and he will go through a quick demo, so as we have less time. Okay.

Hello, my name is Serge Beauchamp. I'm working for Metroix as a software engineer. I've been working on the RAD tools and the IDE over the past few months. I'm going to show you the new RAD tools that we have running on OS X. I'm going to go quite quick on the slides because we don't have much time left.

But basically, the new RAD tools are a very big improvement over the tools that we had on OS 9.2 and on OS X. So you can expect much better debugging time and full Java 2 support. We have a full suite of developing tools, including a text editor, debugger, compilers, file compare tools, a class browser that I'm going to show you right now. Okay.

So this demo, you're going to have to use the Java DP1 update for being able to run it. And unfortunately, you're going to have to grab a patch, a Java patch from the Metroix website with the LXS CD that you just got in the bag. Because we've been doing a few last minute fixes to make this run. Okay, so I'm going to show you a little demo. So this is the demo.

Althorad Demo. So we've been adjusting for Aqua all the MetaWorks IDE and how many of you guys have been using the MetaWorks tools for developing before? Okay, so yeah, I think most of you guys already know how it works. So I have this layout editor here, and what I did for this little demo is I built a jar file with the Java 2D demo from Sun. So I just built a jar file and I included the jar file and the component catalog here. So when I click on it, it lists all the files, all the classes that I can include in the layout editor.

So... So for example, if I drag any of them, it may do something useful and may do something not as useful, depending on what the class really does. So this is run at runtime, so the command has the opportunity to do whatever it wants. So what I'm going to do for this demo, I'm going to use a class that I already know, which is called Rotated3D. Edited, right here.

I'm going to set the name of it to, for example, Jimbo. I'm going to drag a button here and the label of it, I'm going to put start and Another button which is going to be stop. And I'm going to add two lines of code for making this demo work. In the action perform of this component, I will say Jimbo start. And this guy, I'm going to do Jimbo stop.

So that's pretty much all of it. And I'm going to run it. So the CodeWarriors generate automatically the jar file, and it creates automatically the MRJ App Builder application in the Finder. So it can be double clicked automatically.

[Transcript missing]

So the Java application starts. And we are using the terminal application for running the Java application.

So if you have a console application and you want to put some user input from the console, you actually do it from the actual terminal. So you have the exact feedback that you would run it through the terminal. So I can step here. And as you can see, this kind of performance was just a dream on the OS 9 and came just for free on the OS 10.

There's the little demo. So I can put start, and stop, and start. There it is. So inside our tools, we have the class browser, which is very useful, especially for Java code. So you can inspect all your classes and all the methods there is in it. So you can, for example, edit just a simple method.

You don't have to view all your source file at the same time. You can just inspect a small portion of it. And there's a little wizard that you can use to add a new method or add a class to it. So it's all done automatically and all generated source code for it.

There's also all the usual Code Warrior tools that you can find in it and you can use for Java. There's the File Compare tools that is very useful. And actually, some of our customers are using--I've been told are using-- our Java tools only for the File Compare functionality of it. So I can show you a little bit what it does. Just puts an evil modification in it so it can break. And... I can compare directories or I can compare files and it shows the modification.

and I can merge them or not like that. So it's very convenient. Also, you can build directly GNI application within CodeWarrio if you have the SQL tools with the same environment. You have your design application here that you can inspect all the classes. And basically, we have 15 seconds left and that was our demo for today. We will have a presentation at the Civic Center, so if you can come by and see our presentation with our CEO, that will give you more information about rituals. Thank you.

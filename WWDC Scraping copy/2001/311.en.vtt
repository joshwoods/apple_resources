WEBVTT

00:00:07.500 --> 00:00:08.530
Hello.

00:00:08.700 --> 00:00:12.720
My name is Rich Murphy,
and I'm the manager of the

00:00:12.720 --> 00:00:14.470
platform security group.

00:00:14.550 --> 00:00:18.590
This is session 311,
Web Enabling Your Application.

00:00:22.580 --> 00:00:26.160
During this session we're going
to be talking about URL access,

00:00:26.230 --> 00:00:30.140
giving an overview of the
functionality in the library,

00:00:30.230 --> 00:00:35.710
discussing the APIs,
talking about URL access on Mac OS X,

00:00:35.710 --> 00:00:41.500
and also talking about the
NSURL APIs and Cocoa Web Programming.

00:00:44.780 --> 00:00:46.870
During this session,
you're going to learn what

00:00:46.870 --> 00:00:50.680
you can do with URL access,
basically how it applies

00:00:50.680 --> 00:00:53.940
to your problems,
how you can incorporate URL access

00:00:53.940 --> 00:00:59.450
into your Carbon applications,
the limitations of URL access,

00:00:59.450 --> 00:01:02.490
and future plans for the APIs.

00:01:06.070 --> 00:01:07.110
What is URL access?

00:01:07.150 --> 00:01:11.870
URL access is an API that allows
you to easily access data on

00:01:11.870 --> 00:01:15.400
the Internet by the use of URLs.

00:01:15.740 --> 00:01:23.220
supports http, https, ftp,
and file type URLs, has downloading and

00:01:23.220 --> 00:01:27.040
uploading capabilities,
and it's a Carbon API that's available

00:01:27.040 --> 00:01:30.700
on both Mac OS 9 and Mac OS X.

00:01:34.610 --> 00:01:39.900
This slide indicates how we see
URL access actually being used.

00:01:39.990 --> 00:01:42.840
For the most part,
if you're building a Carbon application,

00:01:42.840 --> 00:01:44.830
you need to use URL access.

00:01:44.940 --> 00:01:50.690
URL access is available on both
platforms and will provide all the

00:01:50.690 --> 00:01:55.110
basic URL functionality or URL download
and upload functionality that you need.

00:01:57.240 --> 00:02:00.580
It's based on the Mac OS itself,
which provides all the networking

00:02:00.710 --> 00:02:03.530
functionality underneath,
actual socket access or file

00:02:03.620 --> 00:02:05.180
access and that sort of thing.

00:02:08.510 --> 00:02:11.920
On the Cocoa side, we have the CF APIs.

00:02:11.920 --> 00:02:16.590
Core Foundation, or CF,
provides an additional

00:02:16.590 --> 00:02:19.320
URL accessing type APIs.

00:02:21.000 --> 00:02:23.520
And they're also based on
the Mac OS X kernel and the

00:02:23.520 --> 00:02:25.180
networking functionality.

00:02:25.650 --> 00:02:28.320
capabilities of that.

00:02:31.660 --> 00:02:36.040
Here's some standard URL access features.

00:02:36.100 --> 00:02:39.530
We have an authentication dialog
that pops up whenever you need

00:02:39.590 --> 00:02:43.750
to actually authenticate or
log in to a remote server,

00:02:43.830 --> 00:02:50.100
whether you're doing ftp type
access or whether you're going to

00:02:50.180 --> 00:02:53.610
an authenticated http or https site.

00:02:53.770 --> 00:02:57.690
There's a progress dialog built
into the library that will come up

00:02:57.790 --> 00:03:00.640
and show you how much time is left.

00:03:00.690 --> 00:03:02.940
It includes file decoding capability.

00:03:02.940 --> 00:03:09.100
It links into doing dbin hexing and
also working with Apple single decoding.

00:03:09.100 --> 00:03:13.980
Additionally, in Mac OS 9,
it currently will,

00:03:14.300 --> 00:03:23.150
expand .sit files using the
Aladdin stuff and expander capabilities.

00:03:23.820 --> 00:03:30.290
It's scriptable using Apple Script,
has proxy and firewall support,

00:03:30.520 --> 00:03:35.770
And it also supports the keychain for
storing your authentication information.

00:03:40.730 --> 00:03:43.770
For http, we have download capability.

00:03:44.000 --> 00:03:46.640
We have the capability
of doing post and put,

00:03:46.660 --> 00:03:51.540
although it requires you to do a little
bit of additional work with the APIs.

00:03:51.630 --> 00:03:53.910
It auto redirects.

00:03:54.480 --> 00:03:59.030
You have full access to the server
response by taking a look at properties.

00:03:59.100 --> 00:04:02.070
It will also do proxy authentication.

00:04:06.290 --> 00:04:11.790
For ftp, URL access will also provide
upload of files and directories,

00:04:11.790 --> 00:04:14.730
or download of files and directories,
and it gives you the

00:04:14.730 --> 00:04:18.800
capability of getting directory
listings from the ftp server.

00:04:21.990 --> 00:04:25.800
For https,
we also include SSL version 3.0

00:04:25.910 --> 00:04:30.090
capability with 128-bit encryption.

00:04:33.710 --> 00:04:37.300
There are some functional gotchas
when you're using URL access.

00:04:37.400 --> 00:04:42.100
Basically, it doesn't bother to parse
the response of HTML.

00:04:42.190 --> 00:04:44.800
This can be a problem when
you're doing redirection,

00:04:44.870 --> 00:04:47.600
if you have a file not
found on the remote side,

00:04:47.680 --> 00:04:51.270
or when you have login failures
and that sort of thing.

00:04:51.360 --> 00:04:54.940
There are proxy limitations
for ftp uploading,

00:04:55.010 --> 00:04:59.000
when you're trying to send
a file up to an ftp server,

00:04:59.050 --> 00:05:02.910
or when you're doing ftp
directory downloading.

00:05:06.030 --> 00:05:10.560
There's a couple third party applications
that are actually using URL access,

00:05:10.560 --> 00:05:12.320
both in 9 and 10.

00:05:12.400 --> 00:05:17.680
iCab is currently using it in
order to download https sites,

00:05:17.680 --> 00:05:23.080
and Adobe uses it in Acrobat to
implement the web capture facility.

00:05:23.880 --> 00:05:27.120
There's also a fair number of
companies that are using the scripting

00:05:27.120 --> 00:05:31.870
capabilities to help manipulate files,
get them up to servers,

00:05:31.930 --> 00:05:34.610
and back down from servers as well.

00:05:38.190 --> 00:05:42.300
So the next thing we're going
to do is go over the APIs.

00:05:42.490 --> 00:05:45.010
There are synchronous APIs.

00:05:45.330 --> 00:05:48.370
They include a system event
procedure that allows you to trap

00:05:48.370 --> 00:05:52.200
system events and react to those.

00:05:52.350 --> 00:05:55.730
There's various flags that
you can specify to URL access,

00:05:55.730 --> 00:05:59.910
which will help modify its functionality.

00:06:00.270 --> 00:06:05.970
There's properties that can be set and
that sort of thing and interrogated

00:06:06.370 --> 00:06:11.220
in order to perform various operations
like http puts and posts or to get

00:06:11.400 --> 00:06:14.790
back information from an http server.

00:06:15.080 --> 00:06:18.640
There's the asynchronous API,
which allows you to start

00:06:18.680 --> 00:06:21.440
URL access off doing a transfer.

00:06:21.540 --> 00:06:26.060
And in those cases,
you want to be checking for events.

00:06:26.180 --> 00:06:30.410
Then there's various states that
URL access goes through that you can

00:06:30.410 --> 00:06:32.980
interrogate to see how it's working.

00:06:38.280 --> 00:06:42.800
The first of the synchronous
APIs is URL simple download.

00:06:42.830 --> 00:06:45.850
This is really the easiest
way to download a URL.

00:06:46.110 --> 00:06:49.780
If you're writing an application
that basically just needs to

00:06:49.980 --> 00:06:54.350
grab something off of a server,
this is really the function to use.

00:06:54.460 --> 00:06:57.600
All you have to do is
provide a source URL,

00:06:57.690 --> 00:07:02.860
a destination file spec or handle,
and then flags indicating how you

00:07:02.860 --> 00:07:06.030
want URL access to actually behave.

00:07:06.500 --> 00:07:09.400
If you're using this in an application
that needs to be interactive,

00:07:09.400 --> 00:07:13.270
you need to use this in a thread
because it is a synchronous API.

00:07:13.380 --> 00:07:17.400
It will block until the
transfer actually occurs.

00:07:21.420 --> 00:07:25.790
Here's an example of
using URL simple download.

00:07:25.880 --> 00:07:31.100
Notice here we've created a
little function called getURL,

00:07:31.110 --> 00:07:36.140
which takes a source URL as an
argument and a file spec in order

00:07:36.140 --> 00:07:43.310
to download the actual file to
a file on the Mac OS file system.

00:07:43.510 --> 00:07:48.700
We set some URL open flags for
passing into the actual function call,

00:07:48.790 --> 00:07:53.040
telling it to replace an
existing file if it's there,

00:07:53.350 --> 00:07:55.920
display the progress as
you're doing the download,

00:07:56.060 --> 00:07:59.070
and expand the file as it comes down.

00:08:00.360 --> 00:08:04.290
We call urlsimpledownload,
passing in the URL,

00:08:04.390 --> 00:08:09.440
passing in the destination file spec,
passing in nil to the memory argument,

00:08:09.440 --> 00:08:11.150
because we're not going
to download it to memory,

00:08:11.160 --> 00:08:15.710
passing in the flags,
and in this particular case,

00:08:15.710 --> 00:08:19.220
we aren't providing an event proc,
and so therefore we also don't

00:08:19.220 --> 00:08:20.700
need to provide a context.

00:08:20.700 --> 00:08:24.350
It makes the call,
and then it simply returns,

00:08:24.350 --> 00:08:26.340
along with its status.

00:08:26.390 --> 00:08:29.680
It will have downloaded all the data
into the file and that sort of thing,

00:08:30.110 --> 00:08:32.610
or return an error status.

00:08:37.440 --> 00:08:42.710
System event procedure can be used as
a parameter to the synchronous calls.

00:08:42.870 --> 00:08:47.910
This will allow any of the dialogues that
are displayed to become movable modal.

00:08:48.590 --> 00:08:52.940
Any update events will be passed through
to the procedure that you've passed in.

00:08:53.020 --> 00:08:56.490
If you don't have one of these,
the dialogs will become

00:08:56.490 --> 00:08:58.090
non-movable modal.

00:09:01.760 --> 00:09:05.000
The flags for URL access control
optional aspects of the transfer.

00:09:05.000 --> 00:09:08.400
As we saw a little bit earlier,
it had the replace existing

00:09:08.400 --> 00:09:12.020
flag or the display progress
flag and that sort of thing.

00:09:12.100 --> 00:09:16.670
These flags can be used in both the
synchronous and the asynchronous calls.

00:09:16.920 --> 00:09:19.690
and various calls will
accept different flags.

00:09:19.830 --> 00:09:23.190
Check the documentation online for that.

00:09:24.130 --> 00:09:29.260
Here are some sample flags that we have.

00:09:29.290 --> 00:09:31.640
The Replace Existing flag,
as I said earlier,

00:09:31.640 --> 00:09:37.340
will replace a file on the download
or the upload if it's already there.

00:09:37.430 --> 00:09:39.970
Displaying Progress.

00:09:40.540 --> 00:09:45.100
will happen if you pass in the
KURL display progress flag that

00:09:45.100 --> 00:09:46.960
will put up a little dialogue.

00:09:47.030 --> 00:09:51.880
DisplayAuth will actually invoke
the URL access authentication window

00:09:52.440 --> 00:09:55.980
to get your login and password.

00:09:56.350 --> 00:10:08.480
Expand File will invoke Aladdin Expander,
Stuff Expander.

00:10:08.480 --> 00:10:08.480
Bin Hex on the way up will
actually bin hex the file.

00:10:09.370 --> 00:10:12.110
and then there's the
no auto redirect flag.

00:10:12.120 --> 00:10:14.160
In other words,
come back with an error if

00:10:14.160 --> 00:10:17.510
you're being told to redirect.

00:10:21.020 --> 00:10:25.300
There's also, on the synchronous side,
there's a little bit more

00:10:25.320 --> 00:10:29.790
complex call if you want to,
called URL download.

00:10:30.390 --> 00:10:33.750
If you call URL access
through URL download,

00:10:33.860 --> 00:10:37.760
it takes a few more steps in
order to actually invoke the call,

00:10:37.760 --> 00:10:42.510
but it allows you a lot more creativity
or a lot more flexibility in what you

00:10:42.580 --> 00:10:43.770
can actually get out of the calls.

00:10:43.820 --> 00:10:48.140
You have to create a URL reference
using URL new reference

00:10:48.140 --> 00:10:50.410
and URL dispose reference.

00:10:51.500 --> 00:10:53.070
Once again,
this should be used in a thread

00:10:53.080 --> 00:10:56.200
since it's a synchronous call,
but once you have that reference,

00:10:56.200 --> 00:11:00.430
you can set various properties and
do additional manipulation of how

00:11:00.430 --> 00:11:02.320
URL access will actually be used.

00:11:06.590 --> 00:11:09.180
So as I said before,
if you use URL download,

00:11:09.270 --> 00:11:12.720
you can get and set properties
before and after the download.

00:11:12.800 --> 00:11:16.920
You can set things like the user password
if you want to or things like that.

00:11:16.990 --> 00:11:21.360
And you can also, after the call is made,
interrogate the URL reference in order

00:11:21.470 --> 00:11:25.410
to find out what the status was coming
back from the server a little bit

00:11:25.410 --> 00:11:27.870
better or in a little bit more detail.

00:11:30.380 --> 00:11:32.240
If you've actually threaded it,
you can monitor the

00:11:32.250 --> 00:11:35.740
state of the download,
or you can abort the download as it's

00:11:35.740 --> 00:11:38.740
progressing if it's taking too long.

00:11:41.000 --> 00:11:43.120
Here's an example of using URL download.

00:11:43.120 --> 00:11:48.710
In this particular case,
we've made another function, getURL,

00:11:48.710 --> 00:11:51.580
same as before,
taking a URL and passing in

00:11:51.580 --> 00:11:53.820
the file spec destination.

00:11:53.820 --> 00:11:57.510
You'll notice the call
to URL new reference,

00:11:57.520 --> 00:12:02.690
which actually allocates a URL ref,
which can later then be

00:12:02.690 --> 00:12:04.670
used in URL download.

00:12:04.680 --> 00:12:09.340
You'll notice the call structure
doesn't take a URL as the first thing.

00:12:09.340 --> 00:12:10.370
It takes a URL ref.

00:12:12.450 --> 00:12:21.290
and has the arguments shown here.

00:12:21.290 --> 00:12:21.290
After the call to URL download,
we do a URL dispose reference.

00:12:25.750 --> 00:12:30.340
On the synchronous upload side,
we have URL simple upload

00:12:30.640 --> 00:12:33.100
and then also URL upload.

00:12:33.340 --> 00:12:37.700
And they pair up the same way
the URL download calls pair up.

00:12:37.800 --> 00:12:40.030
URL simple upload is easy to use.

00:12:40.150 --> 00:12:43.650
URL simple upload is very easy to use.

00:12:43.730 --> 00:12:45.830
URL upload is a little
bit more difficult,

00:12:45.880 --> 00:12:48.510
gives you a little bit more flexibility.

00:12:49.410 --> 00:12:51.630
In this particular case,
you give the destination

00:12:51.630 --> 00:12:57.790
URL of where you want to go,
and a source file spec is provided.

00:12:57.870 --> 00:13:01.990
One of the limitations of this
is you can't upload from memory.

00:13:04.130 --> 00:13:06.540
Different flags apply to the upload side.

00:13:06.740 --> 00:13:09.500
And right now it's ftp only.

00:13:15.430 --> 00:13:21.130
For properties,
you can get the URL host or

00:13:21.330 --> 00:13:22.270
the URL actually passed in.

00:13:22.600 --> 00:13:25.100
or you can get the
resources it points to,

00:13:25.130 --> 00:13:29.370
meaning on the way back you can
check to see what the size was of

00:13:29.400 --> 00:13:33.130
the resource that was downloaded or
the resource name on the way down,

00:13:33.130 --> 00:13:37.610
which might have been specified by use
of the URL itself or you could have

00:13:37.610 --> 00:13:39.300
specified it through the file spec.

00:13:39.390 --> 00:13:43.290
Also the MIME type that
it ended up mapping to.

00:13:49.100 --> 00:13:51.260
In the download,
you can get the status string,

00:13:51.270 --> 00:13:55.000
checking to see how things went,
or you can get the total number of items.

00:13:55.000 --> 00:13:56.740
For instance,
if you've downloaded your directory,

00:13:56.740 --> 00:14:00.160
this would tell you how
many files actually got

00:14:00.250 --> 00:14:02.730
brought down in the download.

00:14:03.570 --> 00:14:07.840
For http specific properties,
you can get the request method,

00:14:07.870 --> 00:14:12.130
the response header body,
or a redirected URL.

00:14:17.320 --> 00:14:20.450
Properties are received
using URL get property.

00:14:20.460 --> 00:14:24.690
You specify the property that you're
asking for and give it a variable that

00:14:24.690 --> 00:14:26.170
you expect to have it come back in.

00:14:26.180 --> 00:14:29.590
In order to set properties,
you call URL set property.

00:14:29.600 --> 00:14:35.190
Any of these properties may change
as a result of the transfer itself.

00:14:35.240 --> 00:14:40.010
It may be that the username and
password might change as a result of

00:14:40.070 --> 00:14:45.230
actually redoing the authentication
from the auth dialog coming up,

00:14:45.230 --> 00:14:47.010
that sort of thing.

00:14:47.300 --> 00:14:50.510
Or it may be that other properties
are set as a result of the

00:14:50.510 --> 00:14:53.800
transfer from the http server
returning certain information.

00:14:57.140 --> 00:15:02.760
These are all the properties that
you can set before making the call.

00:15:02.760 --> 00:15:06.440
Once you have the URL reference,
you can set any one of these

00:15:06.440 --> 00:15:08.510
properties in the URL ref.

00:15:11.320 --> 00:15:17.400
Here's an example of using the properties
in order to do an http post operation.

00:15:18.560 --> 00:15:21.890
Notice before we said that
you could do a put or a post,

00:15:21.890 --> 00:15:23.480
but it requires a little bit more work.

00:15:23.600 --> 00:15:27.000
In this particular case,
we're going to end up doing a

00:15:27.000 --> 00:15:30.910
URL download in order to actually
post data up to the server.

00:15:31.000 --> 00:15:35.530
We make the new reference,
we fill out the request method

00:15:35.610 --> 00:15:38.080
property with a post request,

00:15:38.440 --> 00:15:43.440
We also set the property of the http
request body with the actual data

00:15:43.440 --> 00:15:45.540
we want to send up to the server.

00:15:45.710 --> 00:15:48.360
Then we just call urldownload,
which should have the full

00:15:48.360 --> 00:15:49.880
complement of arguments.

00:15:50.270 --> 00:15:52.270
Sorry about that.

00:15:52.270 --> 00:15:56.600
After the call we dispose the reference.

00:15:59.510 --> 00:16:04.200
The asynchronous
APIs need a URL reference.

00:16:04.270 --> 00:16:08.240
In order to do an asynchronous call,
you need to create a URL reference.

00:16:08.360 --> 00:16:11.900
The one call that you can
make for this is URL open.

00:16:12.040 --> 00:16:14.890
URL open will either do
an upload or a download,

00:16:14.940 --> 00:16:17.700
depending on what you've requested.

00:16:17.820 --> 00:16:23.200
You retrieve the data with URL get
buffer and URL release buffer.

00:16:24.030 --> 00:16:30.100
You monitor the state of the
transaction using URL get current state.

00:16:36.590 --> 00:16:40.430
Various reasons why you might
want to use the asynchronous APIs.

00:16:40.490 --> 00:16:42.660
If you're basically just
filtering something,

00:16:42.660 --> 00:16:44.400
you want to send it on through.

00:16:44.440 --> 00:16:45.210
That's a good reason.

00:16:45.440 --> 00:16:51.490
If you want to display your
own progress rather than having

00:16:51.510 --> 00:16:55.180
URL access provide the progress,
or if you don't want to include

00:16:55.180 --> 00:16:55.180
multiple threads in your application.

00:16:57.900 --> 00:17:03.880
Here's an example of an asynchronous
download using URL Open.

00:17:03.990 --> 00:17:07.800
So in this particular case,
we created a URL reference.

00:17:07.860 --> 00:17:11.330
We also set up a notify proc.

00:17:11.350 --> 00:17:16.440
with the notifyupp equals
new URL notifyupp with

00:17:16.520 --> 00:17:18.820
the function mynotifier,
which we'll just show

00:17:18.820 --> 00:17:21.280
you in the next slide.

00:17:23.000 --> 00:17:32.560
The URL open call includes the URL ref,
the flags, the notify proc pointer,

00:17:33.050 --> 00:17:38.150
and then the events mask that we
want to take a look at and also

00:17:38.150 --> 00:17:40.280
a pointer to the user context.

00:17:40.300 --> 00:17:43.780
In this particular case,
we're just setting up a little done flag.

00:17:43.900 --> 00:17:49.660
We have all of that in a do
while loop here and checking

00:17:49.760 --> 00:17:51.770
to see if we're done or not.

00:17:52.360 --> 00:17:56.400
and in order to give URL access
a little bit of time to work,

00:17:56.440 --> 00:17:58.500
it calls URL idle.

00:18:01.410 --> 00:18:04.500
Here's the notification routine
that we'd actually registered,

00:18:04.540 --> 00:18:05.260
my notifier.

00:18:05.260 --> 00:18:08.720
You notice that it's switching
based on the events coming in

00:18:08.720 --> 00:18:13.160
for a data available event,
in which case we just process the data,

00:18:13.160 --> 00:18:17.600
or in the particular cases of a completed
event or an error occurred event,

00:18:17.600 --> 00:18:21.200
we simply set done to true and
we break out of the routine.

00:18:28.830 --> 00:18:34.590
Here's the process data call that
gets called from the notify proc.

00:18:34.650 --> 00:18:39.240
Gets the current state,
gets the current buffer,

00:18:39.290 --> 00:18:43.160
does something with the buffer,
and then releases it.

00:18:48.390 --> 00:18:51.580
Events are always reported
to the notification routine.

00:18:51.810 --> 00:18:56.300
You can register for a subset or you can
actually handle all events coming in.

00:18:56.300 --> 00:19:00.080
If you need all the events,
use K URL All Buffer Events Mask.

00:19:00.650 --> 00:19:03.570
Otherwise,
you actually OR together the appropriate

00:19:03.570 --> 00:19:05.400
flags that you want to look at.

00:19:05.400 --> 00:19:09.150
In this particular case,
the completed event mask and the

00:19:09.210 --> 00:19:11.400
URL error occurred event mask.

00:19:14.020 --> 00:19:18.760
Here's a sample of all the events
that you can possibly be waiting for.

00:19:18.770 --> 00:19:22.060
Resource found, property changed,
and so on.

00:19:25.850 --> 00:19:29.780
Here's a case of an asynchronous download
where we're actually going to poll.

00:19:29.960 --> 00:19:33.410
So we set up to do the download.

00:19:34.540 --> 00:19:39.400
Call URL Open,
and then we go into a Do While loop.

00:19:39.620 --> 00:19:43.640
Basically what we do is we just check the
state by calling URL Get Current State,

00:19:43.640 --> 00:19:48.190
saving that into Current State,
and then check it against the various

00:19:48.190 --> 00:19:52.140
states that would be completed,
the URL Completed State and

00:19:52.140 --> 00:19:54.110
the Error Occurred event.

00:19:59.860 --> 00:20:05.110
The URL get current state function
itself reports the state of the transfer.

00:20:05.640 --> 00:20:09.500
Most states have some sort
of an event counterpart.

00:20:09.560 --> 00:20:14.330
You can't find out about property
change events by using states.

00:20:14.350 --> 00:20:18.800
So you can't tell about, for instance,
the http properties changing

00:20:18.800 --> 00:20:19.930
or something like that.

00:20:20.030 --> 00:20:22.940
There is no way to actually
signify that in a state.

00:20:23.090 --> 00:20:27.820
Checking states is useful in both the
asynchronous and the synchronous APIs,

00:20:27.900 --> 00:20:30.620
so that if you've used one
of the synchronous calls and

00:20:30.620 --> 00:20:33.420
gone off into another thread,
you can get the current

00:20:33.530 --> 00:20:35.320
state of a transfer.

00:20:38.430 --> 00:20:41.480
Here are some sample
states that are available.

00:20:41.480 --> 00:20:46.710
The connecting state, download state,
data available state, error occurred,

00:20:46.710 --> 00:20:48.950
and completed state.

00:20:51.650 --> 00:20:58.600
So in review, there is a synchronous
API using URL simple download,

00:20:58.600 --> 00:21:03.810
URL download, URL simple upload,
and URL upload.

00:21:03.890 --> 00:21:07.590
And then the asynchronous
API where you'd use URL open.

00:21:07.780 --> 00:21:11.450
various flags and properties and events
as we've seen help you manipulate

00:21:11.450 --> 00:21:14.410
how the transfer actually works.

00:21:17.870 --> 00:21:19.360
Some more programming gotchas.

00:21:19.440 --> 00:21:22.220
URL access currently is highly threaded.

00:21:22.390 --> 00:21:27.780
You have to call URL idle in order
to give URL access a chance to work.

00:21:28.360 --> 00:21:32.900
The set property function
sometimes expects C strings

00:21:32.900 --> 00:21:34.360
and sometimes Pascal strings.

00:21:34.360 --> 00:21:37.420
One of the things we're working
on in URL Access is updating

00:21:37.420 --> 00:21:38.580
some of the documentation.

00:21:38.580 --> 00:21:41.300
As we've started to use it,
we've had a transition period

00:21:41.300 --> 00:21:42.920
over the last couple of months.

00:21:42.920 --> 00:21:44.640
We have some new people working on it.

00:21:44.690 --> 00:21:47.140
We're finding that we need to actually
get a little bit more documentation.

00:21:47.140 --> 00:21:53.530
So expect that to be updated really soon,
I hope, as far as what properties are

00:21:54.280 --> 00:21:56.590
expected as C or Pascal strings.

00:21:58.560 --> 00:22:03.430
You also can't call URL Dispose
Reference from a notification routine.

00:22:07.630 --> 00:22:13.170
If you're using Mac OS less than 9.04,
the request body can't

00:22:13.170 --> 00:22:15.080
contain null bytes.

00:22:15.470 --> 00:22:18.970
The URL reference itself isn't reusable.

00:22:18.970 --> 00:22:23.250
And if you're using URL open,
the authentication dialog

00:22:24.420 --> 00:22:24.420
isn't currently supported.

00:22:28.160 --> 00:22:32.800
For Mac OS 9 versus Mac OS X,
there was some capability of having

00:22:33.320 --> 00:22:35.580
plug-ins for URL access in Mac OS 9.

00:22:35.580 --> 00:22:39.100
We no longer support that for Mac OS X.

00:22:39.100 --> 00:22:43.510
We've fixed some of the ways some of
the properties work in Mac OS X so

00:22:43.590 --> 00:22:46.390
they work a little bit more correctly.

00:22:46.390 --> 00:22:51.130
And currently the file protocol
is not available on Mac OS X.

00:22:54.340 --> 00:22:58.200
If you want to develop
applications on Mac OS 9,

00:22:58.410 --> 00:23:00.040
here's the URLs.

00:23:00.040 --> 00:23:03.740
If you want to work with
CarbonLib 1.02 or later,

00:23:03.740 --> 00:23:05.740
there's a URL for that.

00:23:05.740 --> 00:23:10.240
I think these are all available at the
end on one master URL at the very end,

00:23:10.240 --> 00:23:13.140
so you'll be able to get all those.

00:23:13.800 --> 00:23:18.100
If you want to develop on Mac OS X,
install Mac OS X.

00:23:18.100 --> 00:23:20.390
And currently,
link it with the system library

00:23:20.390 --> 00:23:21.930
framework's Carbon framework.

00:23:21.960 --> 00:23:23.590
We're all part of Carbon.

00:23:23.760 --> 00:23:27.390
And the latest documentation
is at the URL provided here.

00:23:30.420 --> 00:23:38.320
For future plans for Mac OS X,
we're working currently on a new

00:23:38.420 --> 00:23:43.160
URL access that will be a little bit
more targeted directly towards Mac OS X.

00:23:43.160 --> 00:23:47.450
We've had some problems where some things
aren't working quite properly using

00:23:47.640 --> 00:23:50.160
some of the old ways of working with 9.

00:23:50.160 --> 00:23:55.050
And this is giving us some performance
problems and some stability problems.

00:23:55.060 --> 00:23:59.120
So that's really been kind of an area of
focus over the last month or two months,

00:23:59.120 --> 00:23:59.900
actually.

00:24:00.300 --> 00:24:03.760
There will be a lot less
threads in the library.

00:24:03.800 --> 00:24:07.500
It'll hopefully be a lot more stable,
it appears to be so far.

00:24:07.500 --> 00:24:12.020
And it'll include streaming
upload and download capability.

00:24:14.520 --> 00:24:18.330
will actually be supporting
connection reuse in 10,

00:24:18.330 --> 00:24:23.230
so that if you have multiple
instances of going to an HTTP server,

00:24:23.270 --> 00:24:26.810
they'll actually be able to
pick up the same connection.

00:24:27.370 --> 00:24:47.030
Secure Transport will start to use the
security framework root certificates.

00:24:47.030 --> 00:24:47.030
This has been a problem for
people with their own self-signed

00:24:47.030 --> 00:24:47.030
certs and that sort of stuff,
trying to access secure servers.

00:24:47.030 --> 00:24:47.030
We've had problems where people
need to update for new root certs

00:24:47.030 --> 00:24:47.030
that are out in the environment.

00:24:50.310 --> 00:24:56.300
So in summary, URL access allows you to
access internet data by URLs.

00:24:56.590 --> 00:24:58.180
It is a Carbon API.

00:24:58.280 --> 00:25:01.440
It has fairly easy to use
synchronous APIs and pretty

00:25:01.440 --> 00:25:04.400
flexible asynchronous APIs.

00:25:06.120 --> 00:25:09.970
So, now next, in order to talk about
web access from Cocoa,

00:25:09.970 --> 00:25:14.950
Becky Willrich will be out here
to talk about the core frameworks.

00:25:17.700 --> 00:25:18.700
Thank you.

00:25:18.700 --> 00:25:22.700
Thanks very much, Richard.

00:25:22.700 --> 00:25:25.530
So I want to talk a little bit
about how you can do the same kinds

00:25:25.530 --> 00:25:29.610
of things as URL access provides
to Carbon from the Cocoa world.

00:25:29.690 --> 00:25:32.690
And I'm going to start
by talking about CFURL.

00:25:32.690 --> 00:25:36.870
CFURL is just a simple CF type
from Core Foundation that's

00:25:36.870 --> 00:25:38.900
used to represent URLs.

00:25:38.900 --> 00:25:42.140
I need to correct one
thing that Richard said.

00:25:42.250 --> 00:25:45.100
Core Foundation is not
part of the Cocoa APIs.

00:25:45.100 --> 00:25:48.560
It's part of the Carbon APIs,
and it's at a low level in the system

00:25:48.560 --> 00:25:49.810
where it can be leveraged from both.

00:25:49.900 --> 00:25:52.820
So CFURL is not a Cocoa-specific type.

00:25:52.820 --> 00:25:55.370
Now for those of you that
are working in Cocoa,

00:25:55.370 --> 00:25:57.900
you'll find that CFURL is
bridged to NSURL.

00:25:57.900 --> 00:26:03.390
So a CFURL is an NSURL,
and an NSURL is a CFURL.

00:26:03.620 --> 00:26:07.690
What CFURL does for you is it parses
the URL string and gives you access

00:26:07.820 --> 00:26:09.350
to all the different component pieces.

00:26:09.490 --> 00:26:12.030
It also handles your
internationalization issues,

00:26:12.340 --> 00:26:15.950
things like the percent encodings.

00:26:16.170 --> 00:26:19.840
Right, things like the percent
encodings in particular.

00:26:20.020 --> 00:26:22.710
And when you're working
with the CFURL APIs,

00:26:22.710 --> 00:26:25.280
you should be aware that unless
the encoding is explicitly

00:26:25.280 --> 00:26:28.130
specified in an argument,
we're assuming UTF-8.

00:26:28.180 --> 00:26:32.120
However, CFURL is a pure data class.

00:26:32.120 --> 00:26:35.170
In other words,
it does nothing but represent the string.

00:26:35.180 --> 00:26:38.970
There's no support in there
for doing the actual network

00:26:39.070 --> 00:26:41.310
I/O necessary to get the data.

00:26:43.380 --> 00:26:45.950
So just one more note on using CFURL.

00:26:45.980 --> 00:26:48.410
You'll find that a lot of
the core foundation APIs,

00:26:48.410 --> 00:26:54.040
and increasingly the Carbon APIs as well,
are taking CFURLs to represent files.

00:26:54.040 --> 00:26:58.250
This is trickier than it sounds
because in part of the encoding issues

00:26:58.260 --> 00:27:00.800
involved with high-bit characters.

00:27:00.800 --> 00:27:05.410
So whenever you create a file URL,
we recommend that you use the functions

00:27:05.410 --> 00:27:09.640
that are named with the word file,
and I've given some of those up there.

00:27:10.480 --> 00:27:12.960
And then for further compatibility
with the Carbon world,

00:27:13.030 --> 00:27:15.780
there are conversion routines
which will take a CFURL and

00:27:15.800 --> 00:27:17.460
convert it to the matching FSRef.

00:27:17.460 --> 00:27:20.900
One catch there, of course,
a CFURL can represent

00:27:20.900 --> 00:27:22.700
files that don't exist.

00:27:22.700 --> 00:27:25.400
FSRefs can't,
so in that case the conversion

00:27:25.400 --> 00:27:27.900
will fail and will return an error.

00:27:29.700 --> 00:27:32.810
Okay, so from that I'm going to
go on to talk about Cocoa.

00:27:32.840 --> 00:27:35.400
These are the topics
we're going to cover.

00:27:35.400 --> 00:27:38.680
We're going to start out by showing
how you can use URL access as

00:27:38.860 --> 00:27:40.650
Richard described it from Cocoa.

00:27:40.680 --> 00:27:44.060
Then we're going to look at
the specifics of using NSURL.

00:27:44.060 --> 00:27:46.660
From there we're going
to look at NSURL Handle,

00:27:46.660 --> 00:27:50.830
which is the class that actually does
the download work inside of Cocoa.

00:27:50.850 --> 00:27:54.880
And then finally we're going to talk
about how you can extend NSURL Handle

00:27:54.880 --> 00:27:58.650
to do your own downloads to support
different schemes and so on.

00:28:00.720 --> 00:28:04.920
So the first thing is you can in
fact use URL access from Cocoa,

00:28:05.170 --> 00:28:08.190
more or less as you would
from a Carbon application.

00:28:08.300 --> 00:28:11.280
There are two things that you have
to be very much aware of though.

00:28:11.470 --> 00:28:16.800
The first one is that you cannot use
any of the UI switches in URL access.

00:28:16.890 --> 00:28:19.360
That's because URL access
brings up Carbon panels,

00:28:19.430 --> 00:28:23.700
and Carbon panels and Cocoa panels
don't coexist very well.

00:28:23.960 --> 00:28:26.460
The second thing you have to
be aware of is that URL access

00:28:26.570 --> 00:28:28.560
uses thread manager threads.

00:28:28.560 --> 00:28:31.690
So when Richard talked about
URL access being highly threaded,

00:28:31.850 --> 00:28:35.400
those were all created via
the thread manager APIs.

00:28:35.400 --> 00:28:39.140
Well, the thread manager uses
cooperative threads,

00:28:39.140 --> 00:28:42.530
whereas people programming
Cocoa are more used to pthreads,

00:28:42.530 --> 00:28:44.400
which are not cooperative.

00:28:44.540 --> 00:28:47.040
When you use URL access,
you have to be prepared to work

00:28:47.050 --> 00:28:50.970
in the cooperative threading
world of the thread manager.

00:28:51.840 --> 00:28:53.600
So what does that mean?

00:28:53.600 --> 00:28:57.410
The first thing it means is
that you must call URL access

00:28:57.480 --> 00:28:59.330
from a thread manager thread.

00:28:59.440 --> 00:29:03.200
URL access is not prepared to be
called from a preemptive thread.

00:29:03.330 --> 00:29:05.700
The good news is the main thread counts.

00:29:05.850 --> 00:29:09.350
The bad news is if you call it
from another cooperative thread,

00:29:09.450 --> 00:29:11.700
the main thread has to be playing nice.

00:29:11.800 --> 00:29:14.890
That means the main thread
must be prepared to yield to

00:29:14.890 --> 00:29:17.040
the other cooperative threads.

00:29:17.780 --> 00:29:21.600
The other thing that means is if
you are using the asynchronous APIs,

00:29:21.600 --> 00:29:24.350
URL open,
you must remember to call URL idle for

00:29:24.350 --> 00:29:26.480
the same reasons that Richard described.

00:29:26.480 --> 00:29:29.630
If you don't call URL idle,
you won't be giving time to

00:29:29.630 --> 00:29:31.680
the other cooperative threads.

00:29:31.700 --> 00:29:35.450
The easiest way to do this from
Cocoa is on the main thread,

00:29:35.450 --> 00:29:40.290
post a notification to yourself with
the posting style post when idle.

00:29:40.300 --> 00:29:42.800
When you receive the notification,
you know that there are

00:29:42.800 --> 00:29:43.880
no events in the queue.

00:29:44.440 --> 00:29:48.560
So take the opportunity to call URL idle
and give up time to the other threads.

00:29:51.490 --> 00:29:54.120
Okay, so now we're going to do the
same thing that Richard did

00:29:54.140 --> 00:29:55.410
with the URL Access APIs.

00:29:55.430 --> 00:29:58.630
We're going to talk about the
synchronous ways you use NSURL and

00:29:58.630 --> 00:30:00.640
then the asynchronous ones.

00:30:00.790 --> 00:30:02.160
Synchronous one is very simple.

00:30:02.160 --> 00:30:07.200
You just send the URL the message
"Resource data using cache." Pass a

00:30:07.200 --> 00:30:12.850
flag yes or no depending on whether
you want NSURL itself to hold

00:30:12.950 --> 00:30:15.590
that data for future reference.

00:30:17.750 --> 00:30:20.930
The asynchronous APIs are
a little more complex.

00:30:20.990 --> 00:30:24.000
You send the message, load resource data,
notifying client,

00:30:24.000 --> 00:30:26.820
and then you pass whatever object
you wish to use as the client,

00:30:26.840 --> 00:30:28.700
using cache, yes or no.

00:30:28.700 --> 00:30:33.030
What that does is it starts an
asynchronous download in the background,

00:30:33.220 --> 00:30:37.060
and as events come in on that download,
your client is notified with

00:30:37.060 --> 00:30:38.980
the methods listed below.

00:30:38.980 --> 00:30:42.170
Those methods are provided
in an informal protocol,

00:30:42.170 --> 00:30:47.080
so you implement only the ones you're
interested in and the others get ignored.

00:30:47.700 --> 00:30:50.070
You can see the events there.

00:30:50.230 --> 00:30:54.490
You get told when resource data comes in,
when the download finishes,

00:30:54.570 --> 00:30:58.910
if the download was cancelled,
and if the download fails.

00:31:00.500 --> 00:31:24.500
[Transcript missing]

00:31:26.400 --> 00:31:30.460
So, one of the side effects, well,
one of the reasons for this

00:31:30.460 --> 00:31:34.550
is so that NSURL handle itself
can provide a more complex API,

00:31:34.550 --> 00:31:37.920
and when you need to do
more sophisticated URL work,

00:31:37.960 --> 00:31:40.500
you work directly with the NSURL handle.

00:31:40.500 --> 00:31:45.810
You can obtain a handle by passing
the message URL handle using cache,

00:31:45.810 --> 00:31:46.800
yes or no.

00:31:46.800 --> 00:31:49.920
Once you've got the handle,
you can manipulate it

00:31:49.920 --> 00:31:51.700
for more direct control.

00:31:52.620 --> 00:31:55.770
You can also use it to flush the cache,
so if you find,

00:31:55.770 --> 00:31:58.620
once you've used the data as
much times as you need to,

00:31:58.620 --> 00:32:01.310
you can then flush the
cache in empty memory.

00:32:01.320 --> 00:32:04.000
And for the full details,
I'm going to point you

00:32:04.000 --> 00:32:05.820
towards NSURL handle.h.

00:32:09.360 --> 00:32:12.950
So here's the good, the bad,
and the ugly.

00:32:13.070 --> 00:32:15.860
NSURL currently, well,
NSURL handle currently

00:32:15.860 --> 00:32:17.780
supports only http and file.

00:32:17.780 --> 00:32:20.700
Unlike URL access,
you're not going to find proxy

00:32:20.840 --> 00:32:24.440
or firewall support there,
nor are you going to find https.

00:32:24.440 --> 00:32:28.050
However, the good news is we
intend to do all of those,

00:32:28.160 --> 00:32:33.380
and the architecture itself is designed
to be extensible so that you can easily

00:32:33.420 --> 00:32:38.780
add new subclasses to NSURL handle
and thereby provide new functionality.

00:32:40.720 --> 00:32:42.480
So how do I do that?

00:32:42.540 --> 00:32:47.600
Well, what you do is you simply
subclass NSURL handle.

00:32:47.700 --> 00:32:52.740
Once you have written the subclass,
you register that subclass with NSURL,

00:32:52.740 --> 00:32:56.290
and once it's registered,
NSURL will automatically pick it up,

00:32:56.380 --> 00:33:02.350
and as it's messaged for its data,
it will start using your subclass.

00:33:03.350 --> 00:33:07.390
So, start by creating a subclass,
implement all the methods

00:33:07.390 --> 00:33:11.440
inside of nsurl_handle.h that
are marked to be overridden,

00:33:11.440 --> 00:33:16.080
and then call nsurl_handle
register_url_handle class

00:33:16.080 --> 00:33:18.170
to register your subclass.

00:33:19.510 --> 00:33:21.180
Here's a list of the methods to override.

00:33:21.200 --> 00:33:24.290
I'm not going to go through
them in great detail right now,

00:33:24.290 --> 00:33:26.290
but it gives you an idea of
the scope of the problem.

00:33:26.320 --> 00:33:29.190
There may be ten methods up there.

00:33:31.280 --> 00:33:33.570
From your subclass,
you should message the superclass

00:33:33.570 --> 00:33:37.630
occasionally to inform it,
basically, of the state of the download.

00:33:37.700 --> 00:33:39.900
The two methods you need
to use are the ones here.

00:33:39.990 --> 00:33:44.520
Background load did fail with reason,
so when your engine detects a failure,

00:33:44.520 --> 00:33:47.960
you need to message your superclass
to pass that information on.

00:33:48.020 --> 00:33:52.530
And did_load_bytes_load_completed,
which you use to tell the superclass

00:33:52.530 --> 00:33:57.110
that new bytes have arrived and whether
or not the download is now finished.

00:33:58.600 --> 00:34:02.040
That's all I have for you
today about NSURL and Cocoa.

00:34:02.040 --> 00:34:05.570
I'm going to ask Richard back
up here on the stage.

00:34:05.650 --> 00:34:06.520
and Thomas as well.

00:34:06.660 --> 00:34:12.420
Tom Weier is our DTS contact, excuse me,
Worldwide Developer Relations contact.

00:34:12.610 --> 00:34:16.420
So if you have questions about
either URL access or the Cocoa side,

00:34:16.500 --> 00:34:19.590
the NSURL and NSURL handle,
he's the guy to contact.
WEBVTT

00:00:04.570 --> 00:00:07.740
Thank you,
and thank you for coming this morning.

00:00:07.810 --> 00:00:09.460
We're on the fourth day of WWDC.

00:00:09.460 --> 00:00:13.000
I imagine a lot of you are beginning
to hit information overload.

00:00:13.060 --> 00:00:15.750
I hope you still have a lot of
energy because we have a lot

00:00:15.760 --> 00:00:17.360
to present in this session.

00:00:17.570 --> 00:00:20.910
Compilers are such an essential
part of development tools.

00:00:20.950 --> 00:00:22.740
We're all affected by their performance.

00:00:22.740 --> 00:00:24.660
We have a lot of things
to say about that.

00:00:24.690 --> 00:00:27.710
We'd be interested to know how
many people in the audience have

00:00:27.710 --> 00:00:30.340
downloaded the Darwin source set.

00:00:30.750 --> 00:00:32.250
Just raise your hands.

00:00:32.440 --> 00:00:34.280
About half, two-thirds.

00:00:34.280 --> 00:00:35.010
Okay.

00:00:35.060 --> 00:00:39.890
How many people actually contribute
to the Darwin repositories?

00:00:41.880 --> 00:00:42.910
A lot fewer.

00:00:43.010 --> 00:00:43.400
Okay?

00:00:43.520 --> 00:00:46.570
With no further ado,
I'd like to introduce John Graziao,

00:00:46.590 --> 00:00:49.470
the manager of the compiler team.

00:01:01.190 --> 00:01:05.090
So today we're going to be talking
about Mac OS X compiler technologies

00:01:05.140 --> 00:01:08.740
and I just wanted to say a
little bit about what those are.

00:01:08.740 --> 00:01:12.690
On my team,
we handle the compiler which is GCC,

00:01:13.580 --> 00:01:19.600
the assembler, the linker,
the dynamic loader which is responsible

00:01:19.600 --> 00:01:24.250
for starting up your application,
and a lot of utilities like Strip, NM,

00:01:24.280 --> 00:01:26.030
O'Tool, and a few others.

00:01:26.100 --> 00:01:31.280
The point that we want to make throughout
this talk is that while all of these

00:01:31.280 --> 00:01:36.640
are usable as command line tools,
the recommended way that we

00:01:36.640 --> 00:01:40.100
want for people to use GCC is
through Project Builder.

00:01:40.100 --> 00:01:43.910
We've got a lot of nice things in
Project Builder to integrate with it.

00:01:45.400 --> 00:01:47.750
So we're not going to cover
all of these things today,

00:01:47.750 --> 00:01:51.980
but what we will talk
about is how to use GCC,

00:01:52.210 --> 00:01:54.300
give you a little overview
of the architecture,

00:01:54.380 --> 00:01:58.670
touch a little bit on dynamic
linking and pre-binding.

00:02:00.400 --> 00:02:06.860
and also talk about some
of the upcoming features.

00:02:14.650 --> 00:02:16.200
Okay,
there's two slides on upcoming features,

00:02:16.280 --> 00:02:20.340
so don't get too excited.

00:02:20.340 --> 00:02:23.740
So the GNU C Compiler.

00:02:23.740 --> 00:02:26.600
This is the main compiler for Mac OS X,
and for those of you that

00:02:26.600 --> 00:02:30.640
are curious looking for it,
it's basically User Bin CC for

00:02:30.640 --> 00:02:32.710
Unix heads in the audience.

00:02:32.710 --> 00:02:35.550
It's free software by the
Free Software Foundation.

00:02:35.650 --> 00:02:39.460
If you're curious about that,
you can go to GNU.org on the

00:02:39.510 --> 00:02:41.850
web and look around there.

00:02:41.860 --> 00:02:45.660
It supports ANSI C, C++, and Objective C.

00:02:45.750 --> 00:02:48.340
It's got a very robust
C++ implementation,

00:02:48.340 --> 00:02:50.090
very robust C++ front end.

00:02:50.230 --> 00:02:55.420
It's got many years of work and testing,
compiles for tons and tons of platforms.

00:02:55.510 --> 00:02:58.600
It's basically the reference
compiler for many developers.

00:02:58.600 --> 00:03:01.640
It's used in education
all over the place.

00:03:01.640 --> 00:03:04.930
And the most important thing
is it compiles all of Mac OS X.

00:03:04.930 --> 00:03:08.160
Every piece of source code that
runs on Mac OS X is compiled.

00:03:08.160 --> 00:03:10.660
goes through GCC.

00:03:12.010 --> 00:03:15.200
So a little overview of GCC for those
of you that aren't familiar with it.

00:03:15.200 --> 00:03:16.960
It is a command line tool.

00:03:17.420 --> 00:03:23.820
And it basically takes C files and
puts out .o files or object files

00:03:23.900 --> 00:03:25.460
which we then send to the linker.

00:03:25.520 --> 00:03:29.220
But behind the scenes what's
actually going on is GCC is

00:03:29.320 --> 00:03:32.120
a driver that first invokes

00:03:35.600 --> 00:03:37.090
There we go.

00:03:37.140 --> 00:03:38.600
It's the only graphic I have today.

00:03:38.600 --> 00:03:39.600
I want it to work.

00:03:39.600 --> 00:03:45.000
It first invokes a preprocessor which
outputs preprocessed source code.

00:03:46.520 --> 00:03:50.240
That then is fed into the compiler,
which outputs assembler code.

00:03:50.240 --> 00:03:54.500
It then invokes the link, the assembler,
which outputs object code.

00:03:54.610 --> 00:03:57.830
And finally that goes to the linker,
which binds everything together and

00:03:57.920 --> 00:04:00.980
creates your application or your
library or whatever you're making.

00:04:01.010 --> 00:04:04.280
All this happens behind the scenes,
but the important thing to keep in mind

00:04:04.280 --> 00:04:07.440
is that there are a lot of switches,
if you look at the documentation,

00:04:07.460 --> 00:04:14.810
that can be sent to any portion of
these sub-processes to control a lot

00:04:14.810 --> 00:04:17.850
of what goes on during this process.

00:04:19.200 --> 00:04:22.680
So what we've done at Apple is
we've taken GCC and we've

00:04:22.740 --> 00:04:24.940
extended it in a few ways.

00:04:25.020 --> 00:04:27.860
We've added Project Builder Integration.

00:04:27.910 --> 00:04:29.040
We've added Objective-C.

00:04:29.040 --> 00:04:33.540
This has been added for a while,
but now I'd like to-- I'm happy to say

00:04:33.540 --> 00:04:37.740
that we are the owners of Objective-C for
the Free Software Foundation.

00:04:37.740 --> 00:04:40.140
We're the maintainers.

00:04:40.140 --> 00:04:42.730
We support our frameworks.

00:04:42.840 --> 00:04:46.170
We support our version
of pre-compiled headers.

00:04:46.410 --> 00:04:48.310
We have support in for
the Velocity Engine,

00:04:48.310 --> 00:04:51.500
which most of the compiler people
in the audience know as AltaVec.

00:04:51.620 --> 00:04:55.770
And of course we support
our Maco object file format.

00:04:56.350 --> 00:05:02.380
There's a few differences that
you have to keep in mind for GCC.

00:05:02.420 --> 00:05:08.620
The first one is that we have
some stricter ANSI C++ compliance.

00:05:08.740 --> 00:05:11.240
So if you're used to
compiling on Mac OS 9,

00:05:11.240 --> 00:05:13.980
you may find out that you get a few more
warnings and maybe a few more errors

00:05:14.550 --> 00:05:17.400
compiling your source code on Mac OS X.

00:05:17.450 --> 00:05:22.200
Mostly in the area of C++ syntax
and especially type checking.

00:05:22.260 --> 00:05:26.670
Another thing to keep in mind that will
bite a few people rarely is that our

00:05:26.810 --> 00:05:33.800
static initializers will execute possibly
in a different order from Mac OS 9.

00:05:34.060 --> 00:05:36.640
Because of the way that we link,
because of the fact that

00:05:36.730 --> 00:05:39.110
we have pre-binding,
which I'll talk about a little bit later,

00:05:39.150 --> 00:05:44.500
if you have static initializers which
have implicit reliance on one another,

00:05:44.500 --> 00:05:45.500
it's not explicit.

00:05:45.500 --> 00:05:47.220
If you have a dependency
graph that we can follow,

00:05:47.220 --> 00:05:48.000
we get that right.

00:05:48.000 --> 00:05:53.840
But if you have implicit dependencies
through global variables or something,

00:05:53.850 --> 00:05:57.990
you may find out that the behavior
will be a little different when

00:05:57.990 --> 00:05:57.990
you build and run on Mac OS X,
so that's something to be careful about.

00:05:59.300 --> 00:06:03.240
So, since public beta,
we've added a few things and

00:06:03.240 --> 00:06:05.650
done a lot of work on GCC.

00:06:05.830 --> 00:06:11.010
The first thing is we're
fully based now on GCC 295.2.

00:06:11.010 --> 00:06:16.650
We used to be running, I think,
the driver and the preprocessor from 272,

00:06:16.870 --> 00:06:19.920
and now we're running everything
in the 2952 code base.

00:06:19.920 --> 00:06:23.080
We've also added a lot
of C++ improvements,

00:06:23.200 --> 00:06:26.700
coalesce symbols,
zero overhead exceptions,

00:06:26.700 --> 00:06:31.350
and we've made precomps usable from C++,
which has a dramatic effect

00:06:31.440 --> 00:06:33.370
on compile time for C++.

00:06:34.060 --> 00:06:36.100
The first thing we added
is coalesced symbols.

00:06:36.100 --> 00:06:42.900
What this does is removes multiple
copies of functions that has been

00:06:42.950 --> 00:06:46.670
created through inlining and templates.

00:06:46.840 --> 00:06:52.840
What we've seen is the finder binary
went down about 300K from 2MB to 1.7MB.

00:06:52.860 --> 00:06:56.060
And we've seen similar
reductions in other C++ programs,

00:06:56.060 --> 00:06:57.960
especially PowerPlant programs.

00:06:58.010 --> 00:07:03.200
And this is giving us an overall
reduction in the system memory footprint.

00:07:03.200 --> 00:07:05.030
And you're going to hear
this theme returned to over

00:07:05.030 --> 00:07:06.500
and over through this talk.

00:07:06.530 --> 00:07:09.220
The most important thing you can
do to optimize your application on

00:07:09.290 --> 00:07:14.000
Mac OS X to make it run really fast is
to reduce the system memory footprint,

00:07:14.010 --> 00:07:17.770
reduce the working set in memory,
because you can optimize the

00:07:17.840 --> 00:07:20.400
CPU usage as much as you want,
but as soon as your app starts

00:07:20.400 --> 00:07:22.840
paging in and out through
the virtual memory system,

00:07:22.880 --> 00:07:24.750
you're going to get slower.

00:07:26.810 --> 00:07:31.980
So another thing we've done along this
route is added zero overhead exceptions.

00:07:31.980 --> 00:07:37.190
Before, what we do is put a set jump in,
a system call, when you have a try block.

00:07:37.330 --> 00:07:38.500
Now we've removed that.

00:07:38.520 --> 00:07:42.810
So try blocks are basically free,
as free as any code that's

00:07:42.810 --> 00:07:44.370
not inside of a try block.

00:07:44.450 --> 00:07:48.290
The common case is very fast,
so we've seen about 2x improvement

00:07:48.320 --> 00:07:49.580
in some real world apps.

00:07:49.650 --> 00:07:52.370
For leaf functions, we've actually seen
about a 20x improvement,

00:07:52.460 --> 00:07:56.390
if it's just a bare leaf function
that has a try block in it.

00:07:56.540 --> 00:07:58.020
We've also seen size reduction.

00:07:58.020 --> 00:08:01.780
We knocked the finder size down
by an additional 400k when we

00:08:01.780 --> 00:08:04.200
added zero overhead exceptions.

00:08:04.360 --> 00:08:08.440
The big thing to keep in mind, though,
is for throws, this will add a memory

00:08:08.440 --> 00:08:13.520
penalty and a speed penalty,
especially for the first time you throw,

00:08:13.600 --> 00:08:18.440
because we do page in a lot of code
to unwind the stack at that point.

00:08:18.490 --> 00:08:22.710
So our basic policy is we
treat exceptions as exceptional

00:08:22.800 --> 00:08:24.340
conditions for error messages.

00:08:24.340 --> 00:08:26.300
If you have something
that's in your main line,

00:08:26.300 --> 00:08:31.700
a processing that uses C++ exceptions,
you may see a slight performance

00:08:31.700 --> 00:08:34.100
lose with zero overhead exceptions.

00:08:34.160 --> 00:08:37.290
But the vast majority of people
are going to see a big win.

00:08:40.680 --> 00:08:46.870
What we've also added are
precompiled headers usable from C++.

00:08:47.180 --> 00:08:50.280
What we've seen in here is
compile times improve as much

00:08:50.390 --> 00:08:53.910
as 5x for Carbon applications.

00:08:54.950 --> 00:08:59.900
So the way that we did this is
precomps can be accessed from C++ now.

00:08:59.900 --> 00:09:07.290
We have an extra C++ aware precompiled
header in all of our umbrella frameworks.

00:09:07.410 --> 00:09:10.730
But they cannot contain C++ syntax
due to a limitation on the way

00:09:10.760 --> 00:09:12.840
that we do precompiled headers.

00:09:12.840 --> 00:09:18.100
And the other thing is that macros
and compiler flags have to match

00:09:18.180 --> 00:09:20.840
as with most precompiled headers.

00:09:20.980 --> 00:09:24.720
If you change a macro setting,
the precompiled header will

00:09:24.720 --> 00:09:25.490
not be able to be used.

00:09:25.500 --> 00:09:29.100
We'll have to go back to
the standard text header.

00:09:31.170 --> 00:09:36.210
So I'd like to talk a little bit
about how we use GCC on Mac OS X.

00:09:38.090 --> 00:09:39.730
So,
and some of the things I'm going to cover

00:09:39.730 --> 00:09:42.830
are just Project Builder Integration,
how you can use and take

00:09:42.910 --> 00:09:49.000
advantage of precompiled headers,
optimization, and I'll touch a little

00:09:49.000 --> 00:09:50.670
bit on Altevec as well.

00:09:53.850 --> 00:09:57.900
So GCC and Project Builder
have been designed for a while

00:09:57.900 --> 00:09:59.870
to work very well together.

00:09:59.870 --> 00:10:03.540
Project Builder is our preferred
way to use GCC on Mac OS X.

00:10:03.710 --> 00:10:05.930
It's got a lot of nice
integration for you.

00:10:05.930 --> 00:10:10.820
It handles most of the command
line switches with GUIs,

00:10:10.870 --> 00:10:12.570
most of the most common
command line switches,

00:10:12.640 --> 00:10:15.610
and there's also ways to access some
of the uncommon command line switches

00:10:15.610 --> 00:10:17.050
directly from Project Builder.

00:10:17.220 --> 00:10:21.380
It has integrated error messages
so that when GCC has an error,

00:10:21.460 --> 00:10:24.100
a syntax error,
it comes up in Project Builder.

00:10:24.100 --> 00:10:26.100
And those of you who have been
at the Project Builder session,

00:10:26.100 --> 00:10:29.210
how many of you have been at
the Project Builder session?

00:10:29.860 --> 00:10:36.570
So we didn't call that out this year just
because it's been around for a while now.

00:10:36.760 --> 00:10:40.520
But basically GCC actually sends
a message up to Project Builder

00:10:40.550 --> 00:10:43.940
and Project Builder will display
the error message and jump

00:10:43.940 --> 00:10:46.200
to the line in source code.

00:10:46.200 --> 00:10:52.640
GCC also provides source code indexing
information to Project Builder.

00:10:52.640 --> 00:10:56.590
So for any cross-reference information
that you need doing global searches

00:10:56.590 --> 00:11:00.610
or running the new class browser
that we have in Project Builder,

00:11:00.610 --> 00:11:06.490
all of that comes off of information
that the compiler supplies.

00:11:08.260 --> 00:11:10.070
Let's talk a little bit
about the Precompiler.

00:11:10.230 --> 00:11:15.450
The Precompiler creates a file of
preprocessed and tokenized headers.

00:11:15.480 --> 00:11:19.700
So it basically takes the group
of headers that we have for say

00:11:19.700 --> 00:11:24.430
Carbon or Cocoa and it tokenizes
them and puts them all into one

00:11:24.430 --> 00:11:26.190
big file that we can then access.

00:11:26.200 --> 00:11:29.260
The big thing for us is that
it not only does this which

00:11:29.300 --> 00:11:33.490
reduces some of our I/O costs and
reduces some of our lexing costs,

00:11:33.490 --> 00:11:38.360
but it also at compile time
selectively unparses the

00:11:38.400 --> 00:11:41.050
declarations based on what's used.

00:11:41.100 --> 00:11:45.640
Some of our measurements when
we're working on compile time,

00:11:45.950 --> 00:11:52.100
we see that 174,000 lines of
declarations get brought in from Carbon.

00:11:52.320 --> 00:11:57.320
So, not everyone uses, obviously,
even a small fraction of that.

00:11:57.520 --> 00:12:02.170
So, the big win in the precompiler is
it can selectively pull in those

00:12:02.290 --> 00:12:03.850
declarations that you're using.

00:12:03.860 --> 00:12:09.460
What this does is it reduces the size
of that pre-processed file that we

00:12:09.460 --> 00:12:15.730
generate and reduces the overall memory
footprint of the compiler itself so it

00:12:15.740 --> 00:12:16.900
doesn't have to push out the IDE to make
room for the parsing that it has to do.

00:12:20.350 --> 00:12:24.870
So when we're using precompiled headers,
we already supply you with precompiled

00:12:24.880 --> 00:12:28.900
headers for the frameworks that we
ship for the major umbrella frameworks.

00:12:28.950 --> 00:12:31.520
So Carbon and Cocoa already
have their precompiled headers.

00:12:31.560 --> 00:12:34.830
If anybody's gone nosing
around inside of the framework,

00:12:34.850 --> 00:12:38.900
you'll see a .p file living in there,
and now a .pp file,

00:12:38.900 --> 00:12:43.810
which is the C++ version of
those precompiled headers.

00:12:44.180 --> 00:12:47.610
Project Builder also supports creating
your own set of precompiled headers.

00:12:47.670 --> 00:12:49.860
You can actually have more
than one precompiled header.

00:12:49.890 --> 00:12:54.100
In a minute I'll bring Devang
up to show how we do that.

00:12:54.100 --> 00:12:58.100
And the preprocessor will automatically
find these precompiled headers,

00:12:58.100 --> 00:13:02.090
so you don't have to worry about
telling Project Builder or telling the

00:13:02.090 --> 00:13:04.100
preprocessor where these headers are.

00:13:04.100 --> 00:13:07.420
We'll look for them if they're
in the same spot as the .h

00:13:07.530 --> 00:13:09.180
that it was created from.

00:13:10.320 --> 00:13:14.200
So again, there are some limitations
to precompiled headers.

00:13:14.200 --> 00:13:19.340
Macro settings, compiler settings,
and the timestamps that they

00:13:19.340 --> 00:13:21.190
were built on have to match.

00:13:21.260 --> 00:13:25.510
If there's a change in them,
we have a fallback position where we

00:13:25.520 --> 00:13:29.110
go to using the text-based header,
which is going to slow

00:13:29.110 --> 00:13:30.200
down your compile times.

00:13:30.390 --> 00:13:38.030
They can be included from C++ files,
but they cannot contain C++ syntax.

00:13:39.810 --> 00:13:43.580
So I'd like to bring up Devang Patel
and we're going to go through how

00:13:43.580 --> 00:13:47.500
you create your own pre-compiled
header with Project Builder.

00:13:56.700 --> 00:14:02.580
So can we have demo two up
on both of the screens here?

00:14:04.790 --> 00:14:09.460
So what we have is just the
example project appearance sample,

00:14:09.460 --> 00:14:11.600
and we brought it up in Project Builder.

00:14:11.650 --> 00:14:16.880
And the first thing we've done is
we've pre-cooked a small header.

00:14:16.920 --> 00:14:20.840
And if those of you can read this,
what Devang's gone in and done is

00:14:20.850 --> 00:14:24.060
set a macro to be debug level two.

00:14:24.080 --> 00:14:30.110
What this is going to do is basically
break the relationship between this

00:14:30.110 --> 00:14:35.280
project and the pre-compiled header
that we ship with the Carbon Framework.

00:14:35.300 --> 00:14:39.050
So the compiler will fall back on
using the text-based header and bring

00:14:39.060 --> 00:14:42.060
in all 174,000 lines of declarations.

00:14:42.140 --> 00:14:43.720
So let's see what that looks like.

00:14:43.720 --> 00:14:45.840
We've basically just tweaked one file

00:14:50.690 --> 00:14:55.340
And let's go ahead and build that.

00:14:55.410 --> 00:14:58.170
So we're going ahead and building that,
and you're seeing as this happens that

00:14:58.180 --> 00:15:04.640
we get a lot of warnings saying that
we can't use the pre-compiled header.

00:15:04.690 --> 00:15:05.570
And there we're done.

00:15:05.570 --> 00:15:07.150
And that was one file,
just to compile all

00:15:07.150 --> 00:15:09.410
of those declarations.

00:15:12.410 --> 00:15:17.420
So, what to look for if you're seeing
slow compile times with C++ is

00:15:17.530 --> 00:15:19.180
definitely look for those warnings.

00:15:19.180 --> 00:15:23.240
Make sure that you're using
the precompiled header.

00:15:23.250 --> 00:15:26.710
Now what we're going to do is go to
the build settings for this target and

00:15:26.710 --> 00:15:28.980
actually make our own precompiled header.

00:15:28.990 --> 00:15:32.680
Now the first thing that's done,
that's a new feature in Project Builder,

00:15:32.710 --> 00:15:35.340
is that you can actually add an
implicitly included header so that

00:15:35.340 --> 00:15:39.480
every header comes into the project,
so that every source file in

00:15:39.480 --> 00:15:41.730
the project uses this header.

00:15:42.570 --> 00:15:44.230
Some people are softly clapping.

00:15:44.280 --> 00:15:45.600
This is a good thing.

00:15:45.600 --> 00:15:47.970
The other thing that we have is we've
got a switch that you can just click

00:15:48.040 --> 00:15:49.090
and you can precompile this header.

00:15:49.100 --> 00:15:53.360
You can obviously add as many of
these as you want to this table

00:15:53.360 --> 00:15:55.360
and you can precompile all of them.

00:15:55.620 --> 00:15:58.770
So what Devang has done is
he's actually clicked that

00:15:59.010 --> 00:16:00.860
he's going to precompile this.

00:16:00.970 --> 00:16:04.350
And what we'll do is go
back and click Build again.

00:16:04.350 --> 00:16:08.350
And you'll see that in addition
to doing some of the prep work,

00:16:08.380 --> 00:16:10.780
what it's saying now is it's
running precompile header.

00:16:10.980 --> 00:16:16.780
And it's actually creating the two
precomps that we'll use in this project.

00:16:18.100 --> 00:16:19.390
So that's done.

00:16:19.550 --> 00:16:23.820
So now let's go back and
run the same build again.

00:16:23.820 --> 00:16:28.220
So Devang's just going to
tweak this a little bit.

00:16:28.220 --> 00:16:30.280
And Command S.

00:16:34.050 --> 00:16:36.680
And there we go.

00:16:36.800 --> 00:16:40.420
So what we're seeing is on average about
5x improvement in your compile times

00:16:40.500 --> 00:16:41.860
when you're using a precompiled header.

00:16:42.000 --> 00:16:47.240
And this is, you know,
the sort of preferred way that a lot

00:16:47.240 --> 00:16:52.000
of IDEs get their compile times up
is by building precompiled headers.

00:16:52.010 --> 00:16:55.190
And the big thing for
you is getting out the,

00:16:55.190 --> 00:16:57.140
you know,
the huge amount of declarations we

00:16:57.140 --> 00:17:03.000
have in Carbon and Cocoa and being able
to get those in a tokenized fashion.

00:17:03.000 --> 00:17:08.000
You can selectively use them and speed
up your compile time significantly.

00:17:08.000 --> 00:17:10.240
Now the other thing that
Devang is highlighting,

00:17:10.240 --> 00:17:13.000
because we didn't have a slide on this,
is for those of you that are interested,

00:17:13.000 --> 00:17:16.970
there's a command line tool called PDUMP.

00:17:17.090 --> 00:17:20.000
If you're not able to use your
precompiled header for some reason,

00:17:20.000 --> 00:17:23.230
you can't figure it out,
or if you just want to poke around inside

00:17:23.230 --> 00:17:28.000
of the precomp and see what's in there,
you can use PDUMP.

00:17:28.000 --> 00:17:29.000
You can use PDUMP.

00:17:29.010 --> 00:17:34.000
And PDUMP-help, dash dash help,
which will give you a lot of information

00:17:34.000 --> 00:17:36.000
on what you can pull out of there.

00:17:36.000 --> 00:17:38.480
So it might be an interesting
exercise just to poke around inside

00:17:38.480 --> 00:17:42.910
the precomp and see what's in there
and how this stuff is recorded.

00:17:43.000 --> 00:17:49.000
So that's it for the demo.

00:17:49.000 --> 00:17:49.990
Thanks Devang.

00:17:59.230 --> 00:18:01.090
Let's talk about optimization.

00:18:01.090 --> 00:18:08.410
So the two things I want to talk
about here are controlling the

00:18:08.410 --> 00:18:14.390
compiler optimization levels
and actually what they do.

00:18:15.700 --> 00:18:17.540
So I'll warn you,
this will descend a little

00:18:17.540 --> 00:18:20.360
bit into compiler geekery,
but not much.

00:18:20.460 --> 00:18:24.400
So the first one is Optimization Level 0.

00:18:24.400 --> 00:18:27.300
It's basically the default for GCC.

00:18:27.300 --> 00:18:29.570
If you pass no optimization
flag on the command line,

00:18:29.570 --> 00:18:30.800
you get no optimization.

00:18:30.800 --> 00:18:36.280
You can also pass "-o 0." The reason they
have that is it allows you to override

00:18:36.280 --> 00:18:39.740
a previously passed optimization flag.

00:18:39.740 --> 00:18:41.420
It does no optimization.

00:18:42.540 --> 00:18:46.610
So what you get is
slower and bigger code,

00:18:46.730 --> 00:18:49.900
but code that you can

00:18:50.090 --> 00:18:52.700
easily follow in the debugger.

00:18:52.760 --> 00:18:56.860
It also gives you the
fastest turnaround time,

00:18:56.930 --> 00:18:59.010
but compared to something like
using a precompiled header versus

00:18:59.080 --> 00:19:02.000
not using a precompiled header,
it's basically in the noise.

00:19:02.190 --> 00:19:05.800
And it's the default setting for
Project Builder deployment builds,

00:19:05.800 --> 00:19:08.220
or Project Builder development builds.

00:19:08.330 --> 00:19:13.440
So when you set the build
style in Project Builder to

00:19:13.450 --> 00:19:17.070
be the development build,
what you get is unoptimized code.

00:19:19.720 --> 00:19:24.930
So Optimization Level 1,
basically -01 on the command line,

00:19:24.940 --> 00:19:26.720
turns on a bunch of basic optimizations.

00:19:26.740 --> 00:19:29.840
It turns on register allocation,
it turns on data flow analysis,

00:19:29.980 --> 00:19:33.840
dead code elimination,
some jump optimizations,

00:19:33.910 --> 00:19:35.510
and also peephole optimization.

00:19:35.610 --> 00:19:38.370
I won't get into, for those of you that
don't know what that is,

00:19:38.370 --> 00:19:39.510
don't worry about it.

00:19:39.610 --> 00:19:45.570
It basically turns on some sort of basic
level of statement level optimization.

00:19:45.600 --> 00:19:49.160
The key point here is that
it results in much smaller

00:19:49.170 --> 00:19:51.340
and faster code than level 0.

00:19:51.600 --> 00:19:57.590
So, for those of you that can
read the bottom line here,

00:19:57.610 --> 00:20:01.560
it says binary sizes can reduce as
much as 50%. We did some initial

00:20:01.560 --> 00:20:04.560
testing on the Finder front
end and a couple other things.

00:20:04.620 --> 00:20:05.600
We built them unoptimized.

00:20:05.600 --> 00:20:06.600
We built them with -01.

00:20:06.900 --> 00:20:11.780
And the size of the binary went
down by 50%, and you should

00:20:12.180 --> 00:20:15.590
expect that your code execution,
just raw CPU,

00:20:15.600 --> 00:20:20.220
throughput will go up by about a
factor of two between unoptimized

00:20:20.220 --> 00:20:23.600
code and optimizing it at -01.

00:20:29.670 --> 00:20:33.270
For Optimization Level 2,
this provides sort of

00:20:33.370 --> 00:20:35.310
function level optimizations.

00:20:35.640 --> 00:20:38.740
It brings in common
sub-expression elimination,

00:20:38.810 --> 00:20:42.950
loop optimization, strength reduction,
and it turns on the

00:20:42.950 --> 00:20:44.790
instruction scheduler.

00:20:45.050 --> 00:20:47.910
It produces faster,
though not necessarily smaller,

00:20:48.030 --> 00:20:49.210
code than -01.

00:20:49.290 --> 00:20:53.020
So we'll see some benchmarks that
rely on these optimizations going

00:20:53.360 --> 00:20:55.000
up by about 10 to 15 percent.

00:20:55.230 --> 00:20:59.000
But the code will not
get that much smaller.

00:20:59.000 --> 00:21:00.810
And in fact, in some cases,
if you have a lot of

00:21:00.810 --> 00:21:04.000
loop unrolling going on,
the code actually grows by a little bit.

00:21:04.000 --> 00:21:06.870
The other thing is,
because we're doing statement

00:21:07.310 --> 00:21:10.860
level optimization at this point,
we're doing things which

00:21:11.400 --> 00:21:14.160
will move statements around,
will move variable

00:21:14.160 --> 00:21:16.000
settings outside of loops.

00:21:16.110 --> 00:21:21.000
What you'll see in the debugger is
that sometimes as you're stepping,

00:21:21.000 --> 00:21:26.000
you may not go exactly where you
think the source code is going to go.

00:21:26.000 --> 00:21:29.250
You also may have trouble
finding variables that have

00:21:29.250 --> 00:21:31.000
been hoisted into registers.

00:21:35.730 --> 00:21:39.740
So the other optimization
level that we support inside

00:21:39.740 --> 00:21:44.060
of GCC is optimization level 3,
which turns on the inliner.

00:21:44.120 --> 00:21:47.490
So this is automatic function inlining,
not just when you say

00:21:47.490 --> 00:21:49.600
inline inside of C++.

00:21:49.720 --> 00:21:52.120
So in some cases,
this can result in faster code,

00:21:52.120 --> 00:21:55.600
but the thing to keep in mind is
it might increase your binary size.

00:21:55.600 --> 00:22:00.720
So you may get faster code on a benchmark
or faster code when you test one

00:22:00.820 --> 00:22:03.600
particular piece of your application.

00:22:03.610 --> 00:22:06.500
But overall,
you may bloat your binary enough

00:22:06.500 --> 00:22:10.280
that you start paging a little
more and cancel out the results

00:22:10.280 --> 00:22:12.500
of getting this extra inlining.

00:22:12.600 --> 00:22:14.560
So profiling is very important.

00:22:14.560 --> 00:22:17.900
Measuring this is very important
to see what kind of performance

00:22:18.220 --> 00:22:22.250
you're getting if you're using -03,
just to make sure that you're

00:22:22.250 --> 00:22:24.600
doing the right thing for
your particular application.

00:22:24.600 --> 00:22:28.440
And I'll point you to a session that's
happening in here at 5:00 today on the

00:22:28.560 --> 00:22:31.600
performance tools where Robert Bowditch
is going to get up and talk about

00:22:31.600 --> 00:22:31.600
some of the tools you can use to
make sure that you're doing the right

00:22:31.600 --> 00:22:31.600
thing for your particular application.

00:22:31.650 --> 00:22:34.670
talk about some of the tools you
can use to measure your application.

00:22:35.900 --> 00:22:39.720
And of course when we're talking
about doing automatic inlining,

00:22:39.720 --> 00:22:42.670
debugging will get, again,
a little more difficult

00:22:42.990 --> 00:22:47.040
for you when you're tracing
through inside of the debugger.

00:22:52.540 --> 00:22:57.400
So,
some recommendations for optimization.

00:22:57.420 --> 00:23:03.070
We always use internally no
optimization when we're building,

00:23:03.070 --> 00:23:05.160
when we're just doing development builds.

00:23:05.180 --> 00:23:08.600
This lets us get access to
all the stuff in the debugger.

00:23:08.620 --> 00:23:12.420
There's no statement movement
or anything that confuses us.

00:23:12.420 --> 00:23:16.550
It gives us the best turnaround time.

00:23:17.860 --> 00:23:23.710
It's generally what we recommend
for external developers as well.

00:23:24.030 --> 00:23:29.200
Our build style gives you -0 when you
choose the development build style.

00:23:29.200 --> 00:23:35.700
We also recommend for deployment
builds for most people to use -02.

00:23:35.850 --> 00:23:47.400
It doesn't have a big effect on
the size of your binary over -01,

00:23:47.540 --> 00:23:49.800
but turning on any
optimization is a big win.

00:23:49.800 --> 00:23:52.900
Turning on -02 gives you
that extra 10-15%. Again,

00:23:52.900 --> 00:23:57.090
it has that trade-off that if you're
using -02 and then trying to debug it,

00:23:57.090 --> 00:23:59.310
you may run into a couple
confusing situations.

00:23:59.400 --> 00:24:03.990
And again,
-03 when you have CPU critical cases,

00:24:04.000 --> 00:24:08.100
when you're trying to get that last
ounce of performance out of it,

00:24:08.280 --> 00:24:12.510
but definitely make sure that
you're not loading your binary

00:24:12.510 --> 00:24:17.000
to the point where it's not,
it's canceling out the

00:24:17.000 --> 00:24:20.510
results results of the change.

00:24:23.220 --> 00:24:28.920
So just a little bit on AltaVec in GCC.

00:24:30.210 --> 00:24:34.790
The big thing to keep in mind
is that we support all of the

00:24:34.790 --> 00:24:37.200
Altevec intrinsics in GCC.

00:24:37.220 --> 00:24:39.770
So if you're used to using
Altevec through Code Warrior,

00:24:39.820 --> 00:24:40.750
the same thing applies.

00:24:40.820 --> 00:24:44.100
You'll be able to use that same
code inside of Project Builder,

00:24:44.170 --> 00:24:45.200
inside of GCC.

00:24:45.200 --> 00:24:48.620
And again,
it requires though that you pass a

00:24:48.620 --> 00:24:53.960
-f Altevec flag to Project Builder,
which we can show you how to do.

00:24:53.960 --> 00:24:56.500
If I can bring Devang back up here.

00:24:58.700 --> 00:26:32.800
[Transcript missing]

00:26:33.080 --> 00:26:37.650
There's sort of a general
table called Build Settings.

00:26:37.650 --> 00:26:42.330
And for the compiler flags that
aren't represented inside of the GUI,

00:26:42.450 --> 00:26:45.900
you can actually get at
these through this table.

00:26:45.990 --> 00:26:49.000
This is sort of an
expert view for people.

00:26:49.000 --> 00:26:52.500
But all of these flags
basically correspond,

00:26:52.500 --> 00:26:56.130
all of these uppercase
variables on the left-hand side,

00:26:56.630 --> 00:27:00.990
correspond to variables that get passed
into our build system and expanded.

00:27:01.000 --> 00:27:05.520
Some of the stuff that you're going
to be interested in looking at are

00:27:05.630 --> 00:27:10.000
other C flags and other LD flags
and then optimization C flags.

00:27:10.000 --> 00:27:15.230
What you can do there is basically set,
here Devang is setting the

00:27:15.230 --> 00:27:17.990
-f altavec flag for those of
you that can see the font.

00:27:18.110 --> 00:27:22.200
The other thing that's nice if
you're really a gear head is you

00:27:22.200 --> 00:27:26.160
can pass in flags that turn on
and off any of the individual

00:27:26.160 --> 00:27:28.990
optimization passes that GCC does.

00:27:29.000 --> 00:27:31.670
So if you want to turn on loop
unrolling but you don't want

00:27:31.670 --> 00:27:33.900
to have strength reduction,
for example,

00:27:34.050 --> 00:27:38.740
you can pass in the individual
flags inside of these C flags.

00:27:39.000 --> 00:27:42.540
For those of you that are wondering
where are all these things documented,

00:27:42.540 --> 00:27:45.830
in the project builder release notes,
there's a build.html file.

00:27:46.000 --> 00:27:50.490
And if you go and look at that,
the settings that are listed here

00:27:50.490 --> 00:27:55.070
are all documented so you know
what's going to happen when you set

00:27:55.070 --> 00:27:57.920
some of these different settings.

00:27:58.170 --> 00:28:01.680
Again,
this is just basically an expert view,

00:28:01.750 --> 00:28:04.190
but if there are flags that
you want to get at that

00:28:04.280 --> 00:28:06.160
aren't represented in the GUI,
this is where you go.

00:28:06.160 --> 00:28:09.830
And you should be able to basically,
you know, for people who are used to

00:28:09.830 --> 00:28:12.740
using GCC from the command line,
this gives you access to all

00:28:12.860 --> 00:28:14.180
the flags that you want to use.

00:28:14.180 --> 00:28:17.580
So, thanks, Devang.

00:28:27.360 --> 00:28:31.780
So I want to say a couple
things on dynamic linking.

00:28:31.830 --> 00:28:34.130
This is something that happens
outside of the compiler.

00:28:34.160 --> 00:28:39.540
This happens with our dynamic
linking process called DYLD.

00:28:39.550 --> 00:28:42.400
And this is how your app starts up.

00:28:42.410 --> 00:28:49.060
Basically, when your app is compiled,
the references are not resolved.

00:28:49.090 --> 00:28:52.230
And this is how we actually
use shared libraries.

00:28:52.250 --> 00:28:54.450
Basically,
if you compile your app that has dynamic

00:28:54.540 --> 00:28:57.790
references into shared libraries,
when your app starts up,

00:28:57.790 --> 00:29:01.160
what happens is we first bind
the references to functions

00:29:01.750 --> 00:29:04.800
and data at startup time.

00:29:04.890 --> 00:29:09.440
The function references allow
us to do lazy initialization.

00:29:09.630 --> 00:29:13.110
So in the basic case,

00:29:13.570 --> 00:29:16.480
When you start up your application,
the function references are

00:29:16.490 --> 00:29:20.160
not resolved until you actually
call through to those functions.

00:29:20.280 --> 00:29:22.310
The thing to keep in mind
is that any data references,

00:29:22.390 --> 00:29:26.780
if you're referencing global data,
those references have to be resolved

00:29:26.780 --> 00:29:31.040
at startup time before you hit main
because we have no way to trap on first

00:29:31.040 --> 00:29:34.840
use and go and run any initialization
routines that have to happen.

00:29:34.960 --> 00:29:38.740
So if you're accessing data,
some library init routines may have to

00:29:38.740 --> 00:29:43.360
be run before main actually starts up.

00:29:44.080 --> 00:29:47.290
So the reason we're talking about
this is because I also want to mention

00:29:47.470 --> 00:29:49.940
this thing we have called pre-binding.

00:29:50.020 --> 00:29:53.640
What pre-binding does is it
actually sets the dynamic link

00:29:53.640 --> 00:29:55.660
addresses at static link time.

00:29:55.750 --> 00:29:58.890
So if you're running
against a shared library,

00:29:58.890 --> 00:30:01.660
the linker will actually go out
and grab those addresses and

00:30:01.660 --> 00:30:03.610
set them up at static link time.

00:30:03.730 --> 00:30:07.500
This can give you a dramatic improvement
in launch times because you're not

00:30:07.540 --> 00:30:10.840
having to search through the symbol
tables of the libraries at all.

00:30:10.900 --> 00:30:14.280
And most importantly,
again getting back to the memory theme,

00:30:14.320 --> 00:30:18.430
you're not having to page in those
symbol tables to do the search.

00:30:19.930 --> 00:30:22.800
The tradeoff is this gives
you no lazy initialization.

00:30:22.840 --> 00:30:27.570
All of this stuff has to
be set up at compile time.

00:30:27.570 --> 00:30:30.050
So we're just going out through
addresses at that point,

00:30:30.090 --> 00:30:31.880
so we can't trap on first use.

00:30:31.990 --> 00:30:40.250
So we have to actually initialize
the libraries and the modules

00:30:40.250 --> 00:30:40.250
before the app actually hits main.

00:30:40.840 --> 00:30:44.900
In a lot of cases, this doesn't give you
a dramatic slowdown.

00:30:44.900 --> 00:30:48.000
It's still a big win to do pre-binding,
but that's definitely

00:30:48.000 --> 00:30:51.480
something that is a trade-off.

00:30:52.140 --> 00:30:56.940
Applications are built by default
prebound in Project Builder.

00:30:56.960 --> 00:30:59.450
So this will give you prebinding if
you're building an application that

00:30:59.450 --> 00:31:01.660
links against the system libraries,
this will give you a

00:31:01.660 --> 00:31:03.100
prebound application.

00:31:03.100 --> 00:31:09.090
But the big thing to keep in mind is
that binaries which are prebound have

00:31:09.200 --> 00:31:12.570
to be updated when the libraries change.

00:31:12.980 --> 00:31:16.760
So, for those of you that have been
poking around the web and seeing

00:31:16.760 --> 00:31:20.890
this thing on what is all this
system optimization that's going on,

00:31:20.890 --> 00:31:24.740
I just downloaded the developer package
and it's optimizing my system again.

00:31:24.920 --> 00:31:28.170
What's basically happening is
it's going through and it's

00:31:28.170 --> 00:31:30.240
re-prebinding those binaries.

00:31:30.340 --> 00:31:32.780
So it goes through,
it looks for binaries on the system,

00:31:32.870 --> 00:31:38.240
and it basically fixes up the addresses
to the libraries as they've been updated.

00:31:38.740 --> 00:31:43.940
So, you know, once that's been run,
the libraries are prebound.

00:31:43.940 --> 00:31:48.860
The Mac OS X GM shipped prebound,
so running that on a stock

00:31:48.940 --> 00:31:51.700
Mac OS X GM system isn't
going to get you anything.

00:31:51.930 --> 00:31:56.300
But when libraries are updated,
going through and re-prebinding

00:31:56.300 --> 00:32:00.300
this actually is a way that helps
us fix up our binaries so that

00:32:00.300 --> 00:32:02.890
they run as fast as possible.

00:32:05.850 --> 00:32:09.810
Let's talk a little bit about
upcoming features in the compiler

00:32:09.810 --> 00:32:12.320
and in the compiler toolchain.

00:32:12.730 --> 00:32:15.600
So the first thing we're
going to talk about is GCC3,

00:32:15.620 --> 00:32:17.040
what's coming with that.

00:32:17.080 --> 00:32:20.670
We'll talk about a feature in the
linker called two-level namespace,

00:32:20.840 --> 00:32:23.510
which most of you who have worked in
the CFM world are already used to.

00:32:23.950 --> 00:32:27.800
And of course,
what a lot of you are here to

00:32:27.800 --> 00:32:34.610
hear about is Objective-C++,
and then we'll talk about some things

00:32:34.610 --> 00:32:34.610
that are coming further down the road.

00:32:34.610 --> 00:32:34.610
Soft applause for Objective-C++.

00:32:34.820 --> 00:32:37.160
So GCC3 is what we're
currently working on.

00:32:37.160 --> 00:32:41.120
We've got it building some of Mac OS X,
but not all of it right away.

00:32:41.240 --> 00:32:46.100
What this gives us is an
integrated preprocessor.

00:32:46.150 --> 00:32:50.480
It gives us some better C++ support,
better C++ compliance.

00:32:50.540 --> 00:32:55.280
It has a lot of code gen improvements,
especially for the PowerPC.

00:32:55.330 --> 00:32:57.920
And something to keep in mind for
people as we're rolling this out is

00:32:58.000 --> 00:33:01.190
it does give you C++ ABI changes.

00:33:01.200 --> 00:33:06.060
So if you're using a shared library
that contains exported C++ calls,

00:33:06.220 --> 00:33:09.250
exported C++ classes,
or anything like that,

00:33:09.270 --> 00:33:11.280
there will be ABI changes.

00:33:11.280 --> 00:33:17.890
You'll have to ship a new binary for
that if you compile it with GCC3.0.

00:33:19.770 --> 00:33:23.000
The other thing we've added
is two-level namespace.

00:33:23.270 --> 00:33:30.190
Before what we had on Mac OS X on public
beta and on GM is a flat namespace.

00:33:30.210 --> 00:33:33.490
So all of your libraries and
all of your applications,

00:33:33.620 --> 00:33:36.930
just basically all the symbols
went up into a big pool.

00:33:36.930 --> 00:33:39.770
And if there were any name collisions,
you basically lost at that point.

00:33:39.900 --> 00:33:42.000
The thing to keep in mind is
that if you're loading bundles,

00:33:42.080 --> 00:33:44.350
if you're loading plugins,
we actually have a two-level

00:33:44.350 --> 00:33:46.020
namespace implemented for plugins.

00:33:46.020 --> 00:33:49.670
So things like QuickTime and other
applications with load plugins

00:33:49.700 --> 00:33:50.970
already can take advantage of this.

00:33:51.040 --> 00:33:56.180
What we're doing is expanding this
feature to the rest of your binary

00:33:56.180 --> 00:33:59.000
the way that it works on Mac OS 9.

00:33:59.010 --> 00:34:03.090
So we link now by symbol
name and library name.

00:34:03.790 --> 00:34:07.030
What this does is it protects
against name collisions in modules.

00:34:07.030 --> 00:34:11.940
So if we add a new API to our libraries
that conflicts with a function

00:34:11.940 --> 00:34:15.100
that you call in your application,
it doesn't break your application now.

00:34:15.100 --> 00:34:19.270
So as we update libraries moving forward,
it won't mess up the applications

00:34:19.370 --> 00:34:20.440
that you already have.

00:34:20.700 --> 00:34:24.880
This also speeds dynamic linking
for non-prebound applications

00:34:24.880 --> 00:34:29.300
because instead of having to search
the entire set of symbol tables,

00:34:29.300 --> 00:34:32.370
we go right to the library
and we look for it there.

00:34:32.700 --> 00:34:36.320
The thing to keep in mind for
people who are used to compiling

00:34:36.320 --> 00:34:40.120
and the flat namespace coming over
from Mac OS X Server or having

00:34:40.120 --> 00:34:43.240
done some other Unix applications,
there is one restriction that

00:34:43.250 --> 00:34:43.700
you have to keep in mind.

00:34:43.750 --> 00:34:46.580
That if you reference a
symbol now out of a library,

00:34:46.580 --> 00:34:49.700
you have to explicitly
include it on the link line.

00:34:54.190 --> 00:34:57.740
So in case you're wondering
about compatibility,

00:34:57.800 --> 00:35:01.240
Mac OS X GM apps work just
fine on the new system.

00:35:01.260 --> 00:35:04.910
So we'll have a two-level
namespace system.

00:35:05.110 --> 00:35:08.320
Things that have shipped for
Mac OS X GM will work just fine.

00:35:08.320 --> 00:35:11.200
Two-level apps will also
work just fine on GM systems.

00:35:11.200 --> 00:35:15.240
So you build your app for two-level
namespace when this is rolled out

00:35:15.270 --> 00:35:18.380
and it'll run fine on Mac OS X GM.

00:35:18.400 --> 00:35:23.580
And any combination of flat and
two-level libraries will work as well.

00:35:23.580 --> 00:35:26.090
So you can have a two-level app
that links against a flat library

00:35:26.090 --> 00:35:28.760
that links against another,
you know, our system libraries,

00:35:28.820 --> 00:35:30.560
which will be two-level at that point.

00:35:30.590 --> 00:35:33.760
And that will all work just fine.

00:35:34.130 --> 00:35:38.130
So Kevin Enderby is the engineer
that worked on this and he did a

00:35:38.160 --> 00:35:41.280
really good job making sure that
all these corner cases got covered.

00:35:41.280 --> 00:35:44.740
He'll be on stage later so you can
ask him some questions about this.

00:35:48.080 --> 00:35:51.140
So now what I'd like to do is bring
up Zeb Laski who's the responsible

00:35:51.140 --> 00:35:57.310
engineer for Objective C++ and he's
going to walk you through what we've

00:35:57.310 --> 00:36:01.100
been doing on Objective C++ and
what some of the details are there.

00:36:01.200 --> 00:36:04.570
Welcome Zeb.

00:36:04.570 --> 00:36:04.570
Thank you much.

00:36:07.940 --> 00:36:08.700
Thank you.

00:36:08.700 --> 00:36:11.900
Well, as John mentioned,
I did do most of the work,

00:36:11.940 --> 00:36:17.170
so at least for the initial release,
if things break, you can blame me.

00:36:17.240 --> 00:36:19.470
So basically what I'd like to do
is just give you a really broad

00:36:19.470 --> 00:36:24.530
and really quick overview of what
Objective-C++ is and what it is not.

00:36:24.860 --> 00:36:26.690
So the most important
thing to remember—actually,

00:36:26.690 --> 00:36:28.070
there are two very important things.

00:36:28.150 --> 00:36:33.060
The first one is that it's really just
a combination of C++ and Objective-C,

00:36:33.120 --> 00:36:36.120
or perhaps more accurately,
it's a superimposition

00:36:36.150 --> 00:36:39.250
of Objective-C on C++,
with C++ sort of being

00:36:39.250 --> 00:36:40.660
the senior partner.

00:36:41.030 --> 00:36:44.700
And the reason we did
this is very simple.

00:36:44.860 --> 00:36:48.000
We would like to allow C++
programmers to utilize the

00:36:48.130 --> 00:36:51.180
numerous Objective-C frameworks
that we have on the system,

00:36:51.220 --> 00:36:54.980
most notably Cocoa.

00:36:55.030 --> 00:37:00.360
In conjunction with this rollout,
we concocted a new file extension, .mm,

00:37:00.490 --> 00:37:04.460
which should be used for
Objective-C++ source code.

00:37:04.660 --> 00:37:08.370
There's a timer here.

00:37:08.830 --> 00:37:13.570
Some of you who are coming over
from the next days might also have

00:37:13.880 --> 00:37:18.540
seen that .capm as an extension,
but we hereby declare this to be

00:37:18.720 --> 00:37:21.270
no longer politically correct.

00:37:21.470 --> 00:37:24.990
The HFS file system is case-preserving
but not case-sensitive.

00:37:25.070 --> 00:37:28.750
There are also other issues,
so we strongly encourage

00:37:28.760 --> 00:37:30.840
you to move away from .capm.

00:37:31.020 --> 00:37:34.260
A few words about the implementation
as it currently exists.

00:37:34.570 --> 00:37:37.320
It is a separate compiler,
a separate frontend

00:37:37.490 --> 00:37:40.520
that I was working on,
which is separate from the C++

00:37:40.530 --> 00:37:42.220
frontend and the other ones.

00:37:42.220 --> 00:37:46.180
And now I come to the
second important point,

00:37:46.180 --> 00:37:48.880
the first one being the
combination of the two languages.

00:37:49.060 --> 00:37:52.860
The second important point is
that an Objective-C++ program,

00:37:53.200 --> 00:37:56.540
once you compile and run it,
interacts with two runtimes:

00:37:56.780 --> 00:37:59.770
the C++ runtime and the
Objective-C runtime.

00:37:59.990 --> 00:38:03.270
Now I'm not sure how much you're
aware of one or the other,

00:38:03.390 --> 00:38:06.130
which direction you're coming from,
if you're coming from the C++ world,

00:38:06.130 --> 00:38:07.820
then you probably know
more about the first one.

00:38:07.830 --> 00:38:10.700
If you're coming from the
Cocoa/Next-Step world,

00:38:10.700 --> 00:38:12.690
you probably know more
about the second one.

00:38:12.710 --> 00:38:16.690
But the important thing here is that
these two runtimes are separate.

00:38:16.810 --> 00:38:19.020
They are different,
they have different semantics,

00:38:19.170 --> 00:38:22.700
and at least at present,
they are mutually unaware of one another,

00:38:22.700 --> 00:38:26.640
or as I like to say,
mutually oblivious of one another.

00:38:26.720 --> 00:38:30.310
Syntactically,
the Objective-C constructs and C++

00:38:30.310 --> 00:38:34.610
constructs are also separate in
the sense that you can easily tell

00:38:34.610 --> 00:38:38.020
just by looking at a construct
which language it belongs to,

00:38:38.120 --> 00:38:41.060
which of course makes life a lot
easier for us in implementing it,

00:38:41.200 --> 00:38:44.740
and also for you in terms of
figuring out what is what and

00:38:44.750 --> 00:38:46.680
what semantics go with it.

00:38:47.910 --> 00:38:52.460
So first off, I'd like to give you
sort of the good news,

00:38:52.470 --> 00:38:55.940
the ways in which you can
mix C++ and Objective-C code.

00:38:55.940 --> 00:38:58.570
So first of all,
you can declare an instance

00:38:58.570 --> 00:39:01.210
of an Objective-C object,
which is really a reference

00:39:01.290 --> 00:39:02.930
or a pointer to that object,
like in Java.

00:39:02.940 --> 00:39:06.510
You can declare that anywhere
you have a C++ declaration.

00:39:06.520 --> 00:39:09.010
So wherever you can
declare a C++ variable,

00:39:09.010 --> 00:39:11.900
you can declare these
Objective-C variables.

00:39:12.820 --> 00:39:16.600
Secondly, Objective-C classes,
the declarations of

00:39:16.600 --> 00:39:19.060
the classes themselves,
may contain within them

00:39:19.150 --> 00:39:22.250
C++ classes or C structs.

00:39:22.660 --> 00:39:26.430
There are some exceptions to that,
which I will get into later.

00:39:26.900 --> 00:39:30.450
Objective-C message sense,
which you see in this square

00:39:30.510 --> 00:39:33.610
bracket notation there,
if you haven't seen this before,

00:39:33.620 --> 00:39:35.480
this really is a typed expression.

00:39:35.540 --> 00:39:39.550
So you can use that anywhere you
have C++ expressions in your code,

00:39:39.740 --> 00:39:41.740
and an example is forthcoming.

00:39:42.410 --> 00:39:46.670
And finally,
Objective-C++ relies on the C++

00:39:46.670 --> 00:39:51.060
type checking semantics for some
of the lower level type checking.

00:39:51.060 --> 00:39:56.040
And the reason I bring this up is that
if you're used to Objective-C coding,

00:39:56.040 --> 00:39:58.500
it relies on C type checking.

00:39:58.560 --> 00:40:01.920
So for instance,
if you have a signed character and you

00:40:01.920 --> 00:40:06.020
assign it to an unsigned character in C,
that's usually fine.

00:40:06.180 --> 00:40:08.130
The C compiler will not complain.

00:40:08.580 --> 00:40:14.250
What you'll find here is that the
C++ part of Objective-C++ will,

00:40:14.320 --> 00:40:16.120
you know, raise its head and complain.

00:40:16.180 --> 00:40:20.180
In other words,
some code that is valid Objective-C code

00:40:20.180 --> 00:40:23.730
might not necessarily be valid
Objective-C++ code because of

00:40:23.790 --> 00:40:25.610
the increased C++ strictness.

00:40:26.940 --> 00:40:31.330
So here I concocted sort of a two
slide example showing you what an

00:40:31.390 --> 00:40:33.340
Objective C++ program looks like.

00:40:33.420 --> 00:40:37.440
And for ease of understanding,
I've color coded it so that the

00:40:37.440 --> 00:40:41.070
Objective C part of it is in blue
and the C++ part is in yellow.

00:40:41.300 --> 00:40:44.790
So you see first off,
we call this "Hello World"

00:40:44.800 --> 00:40:46.370
as we always should.

00:40:46.800 --> 00:40:51.800
Then we import "coco.h", that's
a typical Objective C thing.

00:40:52.050 --> 00:40:55.320
And by the way,
John mentioned before that you can

00:40:55.410 --> 00:40:58.110
use precompiled headers with C++ now.

00:40:58.480 --> 00:41:00.800
You will also be able to
use it with Objective C++.

00:41:00.810 --> 00:41:05.900
So there will be a "coco.pp" on your
system when this whole thing is released,

00:41:05.900 --> 00:41:07.760
so this will go very fast.

00:41:07.890 --> 00:41:11.800
Then in yellow you see a forward
declaration of a C++ class.

00:41:11.940 --> 00:41:15.940
Then we get to a declaration
of an Objective C class,

00:41:16.030 --> 00:41:19.170
which we call "println".
We derive it from NSObject,

00:41:19.270 --> 00:41:21.700
which is sort of the root
of the "coco" object.

00:41:21.820 --> 00:41:25.800
We have a pointer to the C++
class we previously mentioned.

00:41:25.950 --> 00:41:30.600
And then we declare prototypes
for two methods in Objective C.

00:41:30.770 --> 00:41:34.260
Then here,
this is the second part of the example.

00:41:34.360 --> 00:41:39.380
First we flash out the C++ class,
so you have Hello World.

00:41:39.530 --> 00:41:44.210
Here we have an ID,
a member variable of type ID,

00:41:44.210 --> 00:41:48.450
which is sort of analogous
to Java lang object,

00:41:48.540 --> 00:41:49.210
if you've used Java.

00:41:49.220 --> 00:41:52.470
It's sort of a generic pointer that
can point to any Objective-C object.

00:41:52.560 --> 00:41:55.480
And we define a constructor
and a destructor,

00:41:55.610 --> 00:41:58.790
so you can see in the
constructor for the C++ class,

00:41:58.790 --> 00:42:02.590
we actually allocate and init the
corresponding Objective-C class,

00:42:02.680 --> 00:42:05.050
and that is, by the way,
how you usually create an

00:42:05.050 --> 00:42:07.790
Objective-C object with
this alloc init idiom.

00:42:07.800 --> 00:42:12.970
And then we sort of, you know, we say hi,
so you call printf,

00:42:13.400 --> 00:42:17.160
which is a standard C function,
of course.

00:42:17.700 --> 00:42:20.150
Then you have SayHello,
which basically turns around

00:42:20.210 --> 00:42:23.970
and invokes a method called
SayHi in the Objective-C class.

00:42:24.230 --> 00:42:29.100
And down below, we have an implementation
of the Objective-C class,

00:42:29.140 --> 00:42:30.150
which is in blue.

00:42:30.340 --> 00:42:33.620
So you can sort of see the notation here.

00:42:33.890 --> 00:42:36.800
NSLog is also a standard Cocoa function.

00:42:36.800 --> 00:42:39.000
It's actually a C function,
if you really look at it.

00:42:39.120 --> 00:42:41.690
So it basically prints
"Hello World" on the screen.

00:42:41.800 --> 00:42:43.800
The example is sort of silly,
as all examples are,

00:42:43.800 --> 00:42:45.320
but it kind of shows you
how you can mix and match.

00:42:45.520 --> 00:42:49.090
So you can see within Objective-C,
we actually use p arrow

00:42:49.090 --> 00:42:51.800
SayHi to call the C++ method.

00:42:51.910 --> 00:42:56.800
And vice versa, from a C++ class,
you can invoke an Objective-C method.

00:42:58.400 --> 00:43:04.350
Okay, and now we get to the sort of the
important part of this talk in

00:43:04.510 --> 00:43:09.930
the sense that we'd like to sort
of emphasize why certain things

00:43:09.930 --> 00:43:12.300
cannot be done in Objective C++.

00:43:12.300 --> 00:43:14.920
And the reason most of these
things cannot be done is what

00:43:14.930 --> 00:43:18.260
I mentioned at the outset,
is that the runtimes are separate.

00:43:18.300 --> 00:43:20.880
Because they are separate,
they do not know of one another,

00:43:20.880 --> 00:43:23.300
and therefore certain
things really cannot happen.

00:43:23.300 --> 00:43:25.480
So, you know,
number one obviously you can't

00:43:25.550 --> 00:43:27.290
do is mix up class hierarchies.

00:43:27.300 --> 00:43:30.300
If you have a, you know,
hierarchy of C++ objects, that's fine.

00:43:30.300 --> 00:43:32.480
If you have a, you know,
a hierarchy of Objective C objects,

00:43:32.600 --> 00:43:33.300
that's fine too.

00:43:33.300 --> 00:43:36.960
You cannot mix them,
because it will just be very confusing

00:43:37.040 --> 00:43:39.300
for the compiler and the runtime.

00:43:39.300 --> 00:43:43.560
As far as exception handling,
we really encourage you to

00:43:43.560 --> 00:43:46.290
use the C++ runtime for this.

00:43:46.300 --> 00:43:50.300
The, you know, the try, throw,
catch paradigm.

00:43:50.300 --> 00:43:53.240
Objective C does have some set jump,
long jump based.

00:43:53.300 --> 00:43:56.300
Exceptions,
which are basically macros that expand.

00:43:56.300 --> 00:43:59.390
And we really do not
discourage you from using this,

00:43:59.460 --> 00:44:02.300
because C++ just won't know
what's going on when you do this.

00:44:02.300 --> 00:44:06.380
And one thing to keep in mind is
that when you use C++ exceptions,

00:44:06.440 --> 00:44:10.210
you have to clean up any Objective
C objects that you have lying around.

00:44:10.300 --> 00:44:13.120
So here you have a try block where we,
you know,

00:44:13.120 --> 00:44:15.300
instantiate an Objective C object.

00:44:15.300 --> 00:44:18.130
And then we have a catch
clause which frees it.

00:44:18.300 --> 00:44:21.280
And then you re-throw the C++
exception to be possibly caught by

00:44:21.290 --> 00:44:23.300
some other handler in an enclosure.

00:44:23.300 --> 00:44:25.060
So you can see that you
have a closing scope,

00:44:25.180 --> 00:44:26.300
you know, in your stack.

00:44:26.300 --> 00:44:29.730
You have to do this, because again,
the C++ runtime will not know

00:44:29.730 --> 00:44:33.300
about my obj that it's an Objective
C class or what to do with it.

00:44:33.650 --> 00:44:36.300
This is a recurring theme.

00:44:36.300 --> 00:44:39.290
C++ classes cannot receive
Objective C messages or vice versa.

00:44:39.300 --> 00:44:42.270
This is fairly trivial.

00:44:42.360 --> 00:44:45.450
I mean, you cannot,
the functions in C++ that you call an

00:44:45.450 --> 00:44:50.300
object and the methods in the Objective
C land are really semantically different.

00:44:50.300 --> 00:44:52.300
You cannot treat one as
if it were the other.

00:44:52.300 --> 00:44:54.300
The search mechanism is different.

00:44:54.300 --> 00:44:56.300
It's, they do not mix.

00:44:56.300 --> 00:44:58.300
So, I mean, and the compiler will
diagnose this correctly.

00:44:58.300 --> 00:45:01.300
So you shouldn't run
into any problems there.

00:45:01.300 --> 00:45:06.300
You cannot statically allocate
new or delete Objective C objects.

00:45:06.300 --> 00:45:08.300
And actually the new and delete
keywords should be in yellow,

00:45:08.300 --> 00:45:11.300
because that's in C++ construct.

00:45:11.300 --> 00:45:17.300
And the reason again is
if you create an object,

00:45:17.300 --> 00:45:20.340
you have to initialize
the Objective C object,

00:45:20.360 --> 00:45:21.300
which the C++ runtime
wouldn't know how to do.

00:45:21.300 --> 00:45:27.300
If you're familiar with
virtual functions in C++,

00:45:27.300 --> 00:45:31.300
there is always sort of a Vtable
pointer at the beginning of your object.

00:45:31.300 --> 00:45:34.300
Objective C has something analogous
that needs to be initialized.

00:45:34.300 --> 00:45:38.300
And C++, you know,
wouldn't know what to do with that.

00:45:38.300 --> 00:45:43.300
I believe this is my final
restriction type slide.

00:45:43.300 --> 00:45:50.300
I mentioned earlier that you can embed
C++ classes within Objective C classes,

00:45:50.300 --> 00:45:50.300
but there is a catch.

00:45:50.300 --> 00:45:53.290
You may not do this if you
have any virtual functions.

00:45:53.300 --> 00:45:56.410
Again, this is because you would
have a Vtable pointer,

00:45:56.410 --> 00:45:58.990
and in this case the Objective
C runtime wouldn't know what

00:45:59.010 --> 00:46:00.300
to do with the Vtable pointer.

00:46:00.300 --> 00:46:02.300
So this really goes both ways.

00:46:02.440 --> 00:46:07.300
If you have a non-virtual constructor,
like in the struct class 2 example there,

00:46:07.490 --> 00:46:09.250
we will let it slide.

00:46:09.450 --> 00:46:11.300
However,
we will give you a warning because

00:46:11.420 --> 00:46:13.300
that constructor won't be called.

00:46:13.300 --> 00:46:17.740
So if you're expecting to have
the class 2 member initialized,

00:46:17.740 --> 00:46:19.300
that won't happen.

00:46:19.300 --> 00:46:22.290
And the reason we allow this
is because in Objective C,

00:46:22.320 --> 00:46:25.300
you can put C structs in like this.

00:46:25.300 --> 00:46:28.300
And of course that's fine
because you don't expect any

00:46:28.300 --> 00:46:30.300
initialization semantics in C.

00:46:30.300 --> 00:46:32.300
Is this my final example?

00:46:32.300 --> 00:46:33.200
I believe so.

00:46:33.400 --> 00:46:35.290
So this is the most
important slide probably,

00:46:35.300 --> 00:46:38.300
how you get your hands on this stuff.

00:46:38.300 --> 00:46:41.300
We are really very close to
starting seeding this thing,

00:46:41.300 --> 00:46:42.300
having people try it out.

00:46:42.300 --> 00:46:47.390
And if you are interested in
being one of our early victims,

00:46:47.390 --> 00:46:48.300
and I'm really joking.

00:46:48.300 --> 00:46:50.300
It's actually quite stable at this point.

00:46:50.300 --> 00:46:53.170
We've used it as a C++ compiler
on our system very successfully.

00:46:53.300 --> 00:46:55.270
So I'm really proud of it.

00:46:55.330 --> 00:46:58.380
Anyway, if you're interested in
becoming a seed partner with us,

00:46:58.790 --> 00:47:01.440
please approach Godfrey,
our session manager,

00:47:01.440 --> 00:47:04.300
at the end of our session
here after the Q&A.

00:47:04.300 --> 00:47:09.300
And now I'll hand it back to
John for some closing thoughts.

00:47:15.250 --> 00:47:16.320
Thanks, Zem.

00:47:16.680 --> 00:47:20.770
I just want to say that we
brought Zem on in February,

00:47:20.770 --> 00:47:24.170
and he started on this in March,
basically using the old crufty

00:47:24.270 --> 00:47:27.280
2.72 Objective C++ implementation.

00:47:27.360 --> 00:47:32.990
Crufty because of the 2.72 C++
implementation in GCC was pretty bad.

00:47:33.000 --> 00:47:37.540
And he actually got this up and running,
and just last week we were able to

00:47:37.540 --> 00:47:41.380
compile the full Finder code base,
which is all PowerPlant as well,

00:47:41.380 --> 00:47:43.240
with this compiler.

00:47:43.400 --> 00:47:46.600
So it's not only compiling
all of our Objective C++ code,

00:47:46.720 --> 00:47:49.940
but it's also a real, honest-to-God,
C++ compiler.

00:47:49.940 --> 00:47:52.330
So Zem did a great job,
and I think we should give

00:47:52.330 --> 00:47:53.940
him a hand for agreeing this.

00:47:59.620 --> 00:48:09.800
So all of you who are interested
in bringing your C++ applications,

00:48:09.800 --> 00:48:14.110
your C++ Unix tools,
and putting a Cocoa front end on them,

00:48:14.140 --> 00:48:16.300
this is your path to success.

00:48:16.300 --> 00:48:17.600
This will get you there.

00:48:17.600 --> 00:48:18.600
And it's a very nice thing.

00:48:18.600 --> 00:48:21.220
I personally have written
a lot of Objective C++ code

00:48:21.350 --> 00:48:24.490
using the old compiler,
and I'm really looking forward to

00:48:24.490 --> 00:48:26.600
being able to use this new compiler.

00:48:26.600 --> 00:48:28.390
It's going to be really great.

00:48:30.000 --> 00:50:01.700
[Transcript missing]

00:50:04.160 --> 00:50:08.200
So, just to wind it up,
GCC is our road tested

00:50:08.200 --> 00:50:09.860
open compiler for Mac OS X.

00:50:09.860 --> 00:50:13.090
You can go out and get the
sources today if you want them.

00:50:13.110 --> 00:50:15.060
It works from the command line.

00:50:15.060 --> 00:50:17.090
It's a usable command line tool.

00:50:17.150 --> 00:50:18.100
It works even better
from Project Builder.

00:50:18.100 --> 00:50:22.740
We have a lot of support in there that
is actually difficult to access from the

00:50:22.740 --> 00:50:28.100
command line where we take advantage of
a lot of the things that the IDE provides

00:50:28.100 --> 00:50:30.830
and really use the features in GCC.

00:50:31.100 --> 00:50:34.190
And the big thing to keep in mind
is that Apple is fully committed

00:50:34.270 --> 00:50:36.060
to GCC as our main line compiler.

00:50:36.150 --> 00:50:40.100
We run all of Mac OS X through GCC.

00:50:40.100 --> 00:50:44.360
Every binary that you bring up when
you install the Mac OS X GM has

00:50:44.360 --> 00:50:47.100
been run through the GNU compiler.

00:50:47.100 --> 00:50:50.780
It does everything,
all of our Objective C, C++, C,

00:50:50.780 --> 00:50:55.100
and now it's going to be doing
all of our Objective C++ as well.

00:50:55.100 --> 00:50:59.450
So, with that,
turn it back over to Gautri.

00:51:05.600 --> 00:51:07.600
Thank you very much, John.

00:51:07.600 --> 00:51:10.580
A big hand for the team.

00:51:10.630 --> 00:51:11.590
I think they've done a fantastic job.

00:51:13.620 --> 00:51:16.600
Some information resources, as usual.

00:51:16.600 --> 00:51:20.080
Information pages for all the
Mac OS X tools are available

00:51:20.080 --> 00:51:23.470
at the Apple Developer website
under the Tools area.

00:51:23.600 --> 00:51:27.260
We also, for this scene,
because GCC is an open source project,

00:51:27.340 --> 00:51:31.400
we wanted to give you the pointer for
open source at the Apple web pages.

00:51:31.510 --> 00:51:36.700
And the GNU project web source as well,
since they're the baseline

00:51:36.700 --> 00:51:38.680
for all the GNU stuff.

00:51:38.790 --> 00:51:41.400
And another pointer also to
our mailing list main server.

00:51:41.400 --> 00:51:48.080
We have several mailing lists that
are germane to the development tasks.

00:51:48.470 --> 00:51:52.200
Project Builder Users is the one
that has been very heavily used.

00:51:52.200 --> 00:51:55.190
Got over 500 subscribers now.

00:51:55.280 --> 00:51:59.800
Cocoa Dev and Carbon Dev,
over a thousand, thank you Dave.

00:51:59.980 --> 00:52:04.790
Cocoa Dev and Carbon Dev are also
getting populated very rapidly as well.

00:52:05.690 --> 00:52:07.240
Roadmap for more tool sessions.

00:52:07.250 --> 00:52:09.510
A very important session
this afternoon at 5:00.

00:52:09.620 --> 00:52:12.920
Robert Bowditch in 7:05 will show
you how to use the performance

00:52:13.010 --> 00:52:14.760
tools that we're supplying on disk.

00:52:14.880 --> 00:52:17.140
This has tremendous benefit for everyone.

00:52:17.300 --> 00:52:23.690
Tomorrow, 7:06 in the main hall at 9:00,
debugging on Mac OS X using GDB.

00:52:23.770 --> 00:52:28.460
The Darwin Documentation Project and also
the feedback forum tomorrow afternoon

00:52:28.460 --> 00:52:32.290
are also very good opportunities for
you to talk to the development team

00:52:32.300 --> 00:52:35.350
and get more questions and answers.

00:52:36.020 --> 00:52:39.810
With that, and especially for the
Objective C++ seeding,

00:52:39.810 --> 00:52:42.270
this is my contact information on top.

00:52:42.360 --> 00:52:44.730
I would ask, again,
as we put in the slide,

00:52:44.800 --> 00:52:52.360
if you're looking to be a candidate
for as an Objective C++ seed site,

00:52:52.480 --> 00:52:55.650
that's a mouthful,
please put that in the subject

00:52:55.700 --> 00:52:59.440
line so that I can identify them
easily and manage the seed program.

00:52:59.440 --> 00:53:03.150
My group, Technology Management,
does all the management of

00:53:03.150 --> 00:53:05.010
seeding for Apple Computer.

00:53:05.330 --> 00:53:10.310
The Mac OS X Tools Feedback Address
sends your email directly to the

00:53:10.400 --> 00:53:14.200
key personnel in the development
teams in our tools groups.

00:53:14.210 --> 00:53:17.700
It's a good way to get
feature enhancements,

00:53:17.700 --> 00:53:20.200
ideas expressed directly to us.

00:53:20.200 --> 00:53:25.460
And the URL at the bottom of the screen,
which reappears on the Q&A slide,

00:53:25.460 --> 00:53:31.200
is a master page of all the
URLs organized by session for the show.

00:53:31.200 --> 00:53:33.510
So if there's one URL that
you should write down,

00:53:33.510 --> 00:53:36.200
you should write down the last
one because that will allow you

00:53:36.200 --> 00:53:39.420
to get to all the URLs and all
the information resources that we

00:53:39.760 --> 00:53:41.200
distribute throughout the entire show.
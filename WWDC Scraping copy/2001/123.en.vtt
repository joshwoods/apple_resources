WEBVTT

00:00:04.580 --> 00:00:06.400
just a little bit of what
we're going to cover today.

00:00:06.400 --> 00:00:09.630
We're going to build on the overview
and the using Cocoa session that

00:00:09.720 --> 00:00:14.730
you just saw and just dig a little
bit deeper for these issues.

00:00:14.840 --> 00:00:17.820
Drag and drop, printing, services,
things that Ali mentioned before.

00:00:17.900 --> 00:00:19.540
So I'm not going to waste any more time.

00:00:19.610 --> 00:00:23.110
Please help me bring to the
stage Cocoa Frameworks Engineer,

00:00:23.140 --> 00:00:24.210
Mark Piccirelli.

00:00:34.020 --> 00:00:36.760
The first thing we're going to
talk about is drag and drop.

00:00:36.760 --> 00:00:39.380
It's an important part of so
many programs' user interfaces

00:00:39.380 --> 00:00:41.700
because Cocoa has good,
straightforward support for it.

00:00:41.740 --> 00:00:45.540
We'll talk about how you register
drag targets in your application,

00:00:45.540 --> 00:00:48.950
how you provide drag feedback
when the user drags things

00:00:49.020 --> 00:00:51.680
over your program's windows,
how you handle drops when the

00:00:51.680 --> 00:00:55.430
user actually drops something,
how you initiate drag and drop

00:00:55.430 --> 00:00:59.440
operations in response to user
events in one of your programs' use.

00:00:59.440 --> 00:01:03.270
And for those of you who have been
programming after for a while,

00:01:03.280 --> 00:01:07.790
I'll briefly mention some of the new
drag and drop features in Mac OS X.

00:01:12.700 --> 00:01:16.270
So before the user can drag
anything onto your program,

00:01:16.270 --> 00:01:18.080
you have to register the
program's drop targets.

00:01:18.140 --> 00:01:20.900
Now you can register
windows as drop targets,

00:01:20.930 --> 00:01:25.120
but more typically you register specific
views in the windows of your program.

00:01:25.140 --> 00:01:29.080
To do this, you call NSView's register
for drag types method,

00:01:29.080 --> 00:01:32.300
passing it an array of
pasteboard data type names,

00:01:32.300 --> 00:01:36.520
indicating exactly what types the user
can drop onto your program's views.

00:01:37.140 --> 00:01:41.360
For example, if you subclass NSView,
you should call register for drag

00:01:41.450 --> 00:01:43.900
types in the views initializer method.

00:01:43.900 --> 00:01:46.720
If you do this,
it's also a good idea to call unregister

00:01:46.720 --> 00:01:48.890
drag types in the views dialog method.

00:01:48.900 --> 00:01:53.370
Now views that you register to be
drop targets must implement methods

00:01:53.370 --> 00:01:56.300
of the NSDraggingDestination protocol.

00:01:58.810 --> 00:02:02.320
The first one of these methods you have
to worry about is dragging entered.

00:02:02.490 --> 00:02:07.000
When the user drags something
into one of your program's views,

00:02:07.120 --> 00:02:10.000
Cocoa will send the view a
dragging entered message.

00:02:10.210 --> 00:02:12.920
This is your opportunity
to draw visual feedback,

00:02:13.040 --> 00:02:16.580
something like an insertion pointer
if the view is displaying text.

00:02:16.680 --> 00:02:19.470
And your view should also
determine what sort of drag

00:02:19.470 --> 00:02:20.660
operation this is going to be.

00:02:20.660 --> 00:02:21.920
Is copying being done?

00:02:21.920 --> 00:02:23.600
Is moving being done?

00:02:23.680 --> 00:02:25.940
Or if it's applicable,
is nothing being done because

00:02:25.940 --> 00:02:27.690
it's not allowed right now?

00:02:29.730 --> 00:02:33.350
The information that the view needs
to determine these kind of things is

00:02:33.510 --> 00:02:38.560
available in an NSDraggingInfo object,
an object that implements the methods

00:02:38.560 --> 00:02:40.540
of the NSDraggingInfo protocol.

00:02:40.580 --> 00:02:44.790
Every one of the methods in the
NSDraggingDestination protocol is past

00:02:44.790 --> 00:02:47.170
an instance of one of these objects.

00:02:47.390 --> 00:02:50.480
So I'll briefly talk about this
other protocol before bouncing

00:02:50.480 --> 00:02:53.180
back to NSDraggingDestination.

00:02:55.610 --> 00:02:58.440
So as I mentioned,
an NSDRAGON info object is passed to each

00:02:58.440 --> 00:03:01.600
of your NSDRAGON destination methods.

00:03:01.630 --> 00:03:04.280
Now remember what I mentioned
before about how your drop target

00:03:04.500 --> 00:03:07.930
has to determine exactly what
sort of drop operation this is.

00:03:07.980 --> 00:03:13.000
Part of the information it needs to
figure that out is based on what drag

00:03:13.000 --> 00:03:16.440
operations the dragging source supports.

00:03:16.460 --> 00:03:19.890
And your drop target can find that
out by consulting the dragging

00:03:19.940 --> 00:03:24.070
source operation mask method
of the NSDRAGON info protocol.

00:03:24.160 --> 00:03:28.540
It also might need access to the
data that's actually being dragged,

00:03:28.560 --> 00:03:32.290
and it can get access to that using
the dragging pasteboard method.

00:03:32.760 --> 00:03:35.620
Back to the methods of the
NSDragging destination protocol,

00:03:35.620 --> 00:03:38.490
which again, each one of them is passed
in NSDraggingInfoObject.

00:03:38.500 --> 00:03:44.170
DraggingUpdated, unlike DraggingEntered,
which is called just once when the user

00:03:44.170 --> 00:03:47.600
drags something onto one of your views,
is called over and over again as the

00:03:47.600 --> 00:03:49.920
user drags things around over your view.

00:03:49.920 --> 00:03:52.620
You should be redrawing the
visual feedback you're providing,

00:03:52.620 --> 00:03:53.080
if any.

00:03:53.080 --> 00:03:55.980
And if you do this, be efficient,
because this method is called over

00:03:55.980 --> 00:03:57.520
and over again as the mouse moves.

00:03:57.520 --> 00:03:59.910
So any flickering or delays
will be very noticeable.

00:04:00.660 --> 00:04:02.810
One thing you don't have to worry about,
one nice thing that

00:04:02.810 --> 00:04:05.240
Cocoa provides for you,
is auto-scrolling.

00:04:05.240 --> 00:04:09.050
If you've worked in other systems,
you know it's a lot of work to deal

00:04:09.050 --> 00:04:12.380
with the issue of the user dragging
something off the bottom of the view.

00:04:12.380 --> 00:04:13.790
You have to move the scroll bars around.

00:04:13.840 --> 00:04:15.010
It's a lot of work sometimes.

00:04:15.020 --> 00:04:17.010
In Cocoa, it's not a lot of work.

00:04:17.020 --> 00:04:19.520
If your view is a sub-view
and a scroll view,

00:04:19.520 --> 00:04:22.520
NSScrollView will take
care of all this for you.

00:04:22.540 --> 00:04:25.510
And the other method that's
involved in providing drag

00:04:25.510 --> 00:04:27.320
feedback is dragging exited.

00:04:27.320 --> 00:04:30.600
If the user drags something
away from your view,

00:04:31.120 --> 00:04:33.610
without actually dropping it,
your dragging exited

00:04:33.610 --> 00:04:34.660
method will be invoked.

00:04:34.660 --> 00:04:38.660
This is your opportunity to clear the
visual feedback that you've been drawing.

00:04:41.630 --> 00:04:44.490
Now if the user actually
does drop something,

00:04:44.770 --> 00:04:50.530
your drop target will be
sent a sequence of methods,

00:04:50.620 --> 00:04:53.840
prepare for drag operation,
perform drag operation,

00:04:53.900 --> 00:04:55.310
and conclude drag operation.

00:04:55.340 --> 00:04:58.650
If everything goes well,
all three of them will be sent.

00:04:58.660 --> 00:05:01.370
So you're wondering,
why are there three of them?

00:05:01.380 --> 00:05:02.440
Why isn't it just one method?

00:05:02.440 --> 00:05:05.830
Well, you really should do all the main
stuff and perform drag operation,

00:05:05.830 --> 00:05:09.030
but it's necessary to split a few
things off from the other things.

00:05:09.780 --> 00:05:12.420
For example,
in the case of a drag and drop

00:05:12.420 --> 00:05:16.610
operation that implies moving,
the source has to do things too.

00:05:16.620 --> 00:05:23.520
Once the dragging destination has
copied the drag data into its stuff,

00:05:23.520 --> 00:05:25.910
the dragging source has to delete it.

00:05:25.940 --> 00:05:28.780
And the way we make sure that
all this occurs safely is

00:05:28.780 --> 00:05:30.500
breaking this up like this.

00:05:30.500 --> 00:05:33.920
So perform drag operation,
your dragging destination is called,

00:05:33.920 --> 00:05:36.950
then the dragging source is told
that it can delete any information

00:05:37.290 --> 00:05:39.060
that was dragged if it needs to.

00:05:39.870 --> 00:05:45.300
And then your dragging destination's
conclude drag operation method is called.

00:05:47.610 --> 00:05:49.830
The other half of providing
drag and drop support in your

00:05:49.880 --> 00:05:54.740
Cocoa application is initiating drag
and drops in response to user events,

00:05:54.770 --> 00:05:56.170
when they pick something
up in one of your views.

00:05:56.200 --> 00:05:59.310
Well, historically,
the case of the user picking up file

00:05:59.390 --> 00:06:03.190
icons or something like that has been
common enough that we provide a specific

00:06:03.200 --> 00:06:04.720
method for it that you can see there.

00:06:04.720 --> 00:06:08.450
For everything else,
NSView has a convenience function,

00:06:08.460 --> 00:06:12.270
drag image at offset event
pasteboard source slide back.

00:06:12.320 --> 00:06:14.540
And I won't get into all those arguments.

00:06:14.540 --> 00:06:15.460
There's a bunch of them.

00:06:15.460 --> 00:06:17.070
They're all very well documented, too.

00:06:17.510 --> 00:06:19.960
But I will, too,
bring up two things that are important.

00:06:19.960 --> 00:06:23.980
We get a lot of questions about,
from developers,

00:06:24.160 --> 00:06:28.390
who need to take a snapshot of a
piece of their view to provide us

00:06:28.390 --> 00:06:29.990
that image that gets dragged around.

00:06:30.100 --> 00:06:33.970
I can't give you the entire
answer because it's pretty long,

00:06:33.970 --> 00:06:37.960
but the hardest to guess part of
it is to call NSBitmapImageRep in

00:06:38.120 --> 00:06:39.400
it with focusDirect.

00:06:39.400 --> 00:06:42.110
So that's your hint
about how to get that.

00:06:42.760 --> 00:06:50.030
Another thing you can do... Just as there
is an NSDraggingDestination protocol,

00:06:50.300 --> 00:06:52.430
Cocoa has an NSDraggingSource protocol.

00:06:52.500 --> 00:06:55.710
I won't get into it in too much
detail here because it's much less

00:06:55.710 --> 00:07:00.680
common to have to customize the
operation of the dragging source,

00:07:00.880 --> 00:07:01.990
but it's there.

00:07:03.630 --> 00:07:07.220
So, and if you've been working
with AppKit for a long time,

00:07:07.220 --> 00:07:10.900
say pre-Mac OS 10.0,
you should be aware that

00:07:10.900 --> 00:07:14.260
there are two new operations,
NSDragOperationMove and

00:07:14.260 --> 00:07:15.580
NSDragOperationDelete.

00:07:15.620 --> 00:07:20.300
That list that showed up on a
few slides ago included these.

00:07:20.300 --> 00:07:21.560
You might have been wondering
where they came from.

00:07:21.560 --> 00:07:24.250
They provide a little bit
richer semantics than just plain

00:07:24.360 --> 00:07:27.010
old NSDragOperationGeneric,
which was used before.

00:07:27.960 --> 00:07:30.900
And also, we now have drag and drop
in our text subsystem,

00:07:30.900 --> 00:07:36.460
so our text subsystem's classes have a
few new methods that you can override,

00:07:36.460 --> 00:07:40.810
and also the text subsystem classes'
delegate methods have a few additions,

00:07:40.810 --> 00:07:41.270
too.

00:07:49.920 --> 00:07:53.200
So the next thing I'll go into is
NS Table View because it's a good

00:07:53.200 --> 00:07:56.470
example of one of the sophisticated
controls that Cocoa provides.

00:07:56.500 --> 00:07:58.200
You've seen them all over.

00:07:58.200 --> 00:08:01.810
They display data in a table and
allow the user to edit values if

00:08:01.810 --> 00:08:05.990
you want to let them do that and
resize and rearrange columns.

00:08:06.670 --> 00:08:08.000
and real quick,
I'll go into what you have

00:08:08.000 --> 00:08:11.140
to do to provide the data
that the table view displays.

00:08:11.270 --> 00:08:13.810
Some of the things you can do
to handle the user events that

00:08:13.810 --> 00:08:15.040
can occur in a table view.

00:08:15.150 --> 00:08:17.980
And if you really need to
do serious customization,

00:08:17.980 --> 00:08:20.870
I'll introduce the concept
of table view cells.

00:08:21.320 --> 00:08:24.000
So, providing table view data,
another protocol,

00:08:24.080 --> 00:08:27.050
another thing that defines
a set of methods that you

00:08:27.050 --> 00:08:28.640
can implement if need be.

00:08:28.730 --> 00:08:33.300
The one for NS table data source,
and NS table data source is

00:08:33.300 --> 00:08:37.440
what an NS table view consults
to get the data it displays,

00:08:37.500 --> 00:08:40.380
includes two methods that you'll
almost certainly have to implement,

00:08:40.450 --> 00:08:43.340
number of rows in table view,
and table view object

00:08:43.340 --> 00:08:44.750
for table column row.

00:08:46.080 --> 00:08:49.500
Now, you can pretty much guess what the
first one is supposed to return.

00:08:49.500 --> 00:08:54.560
The second one can return pretty much
any object within the limitations

00:08:54.570 --> 00:08:56.190
of what the table view can handle.

00:08:56.200 --> 00:09:01.800
A standard NS table view can handle
strings and numbers with no trouble.

00:09:02.030 --> 00:09:06.780
and if you're letting the user edit
the data that shows up in a table view,

00:09:06.780 --> 00:09:10.730
you can implement table view set
object value for table column row,

00:09:10.750 --> 00:09:13.160
which is pretty easy too.

00:09:14.100 --> 00:09:17.860
So handling table view events.

00:09:17.860 --> 00:09:21.260
Just as table view-- well,
NS table view is unique

00:09:21.260 --> 00:09:24.240
in that it provides-- it
depends on these data sources.

00:09:24.440 --> 00:09:28.070
It is very common among Cocoa classes,
however, to depend on delegates.

00:09:28.110 --> 00:09:31.020
And NS table view defines
a set of delegate methods,

00:09:31.030 --> 00:09:33.200
much like many other Cocoa classes do.

00:09:33.450 --> 00:09:37.050
I'll single one out because it's a good
example of Cocoa providing flexibility

00:09:37.050 --> 00:09:39.240
without too much complexability.

00:09:39.250 --> 00:09:43.020
And that's table view will
display cell for table column row.

00:09:43.240 --> 00:09:48.040
and that is sent to your table views
delegate right before each time a

00:09:48.040 --> 00:09:50.320
table view is about to display a cell.

00:09:50.340 --> 00:09:53.540
And that's your option,
that's your opportunity to do simple

00:09:53.570 --> 00:09:57.820
things like setting up fonts or colors
for drawing and things like that.

00:09:57.940 --> 00:10:00.730
Affecting the display of the
cell without having to do

00:10:00.760 --> 00:10:02.750
anything too clever or difficult.

00:10:02.760 --> 00:10:06.220
And then the table view delegate
methods include a bunch of

00:10:06.220 --> 00:10:10.360
other things for controlling
selection and editing policies.

00:10:10.770 --> 00:10:13.790
Whether or not you're letting
the user select many different

00:10:13.790 --> 00:10:15.460
rows at one time or just one.

00:10:15.770 --> 00:10:18.240
Whether or not you're letting
the user edit things or not.

00:10:18.240 --> 00:10:20.000
So stuff like that.

00:10:20.000 --> 00:10:25.330
And there's also methods that provide,
one of the ways that your table view

00:10:25.330 --> 00:10:30.100
delegate can find out about user
events that occur in a table view.

00:10:30.380 --> 00:10:33.470
The next step of table view
customization is to provide your

00:10:33.470 --> 00:10:35.760
own kind of cells to the table view.

00:10:35.780 --> 00:10:38.930
So as I mentioned on an earlier slide,
by default,

00:10:38.930 --> 00:10:42.160
NS Table Views can display numbers
and strings without any trouble.

00:10:42.240 --> 00:10:45.330
And that's because they use
instances of one of our classes

00:10:45.340 --> 00:10:47.000
called NS Text Field Cells.

00:10:47.100 --> 00:10:49.430
Well, you can provide other
cells if you need to.

00:10:49.510 --> 00:10:51.640
And as you can see on the slide,
there's more than one way to do it.

00:10:51.640 --> 00:10:54.850
You can do it by overriding or
by setting things up after the

00:10:54.860 --> 00:10:57.240
table view has been instantiated.

00:10:57.240 --> 00:10:59.070
So if you do this,
if you're willing to provide

00:10:59.070 --> 00:11:01.180
your own kind of cells,
you can take total control

00:11:01.180 --> 00:11:05.760
of all the displaying,
of custom drawing, highlighting,

00:11:05.760 --> 00:11:07.730
and you can even have your
table view display objects

00:11:07.840 --> 00:11:12.090
other than numbers and strings,
whatever you need.

00:11:12.460 --> 00:11:15.890
So one thing you don't need to
provide new cells for is simple

00:11:15.990 --> 00:11:17.830
things like determining policy.

00:11:17.860 --> 00:11:21.380
If you just want to affect the
editability of an NS TableView cells,

00:11:21.380 --> 00:11:22.540
well, the delegate can do that.

00:11:22.590 --> 00:11:26.280
You don't have to, you know,
provide new cells for that.

00:11:27.300 --> 00:11:31.200
and no discussion of NS Table View would
be complete without mentioning

00:11:31.200 --> 00:11:34.210
its most well-known subclass,
NS Outline View,

00:11:34.210 --> 00:11:39.200
which displays pretty much the same
stuff but can display hierarchical data.

00:11:39.200 --> 00:11:42.640
I'm sure you've all seen these
around in programs like Mail and

00:11:42.710 --> 00:11:44.790
Project Builder and other places.

00:11:46.800 --> 00:11:47.620
and others.

00:11:47.700 --> 00:11:50.500
So very quickly,
NSOutlineView is not surprisingly

00:11:50.500 --> 00:11:52.140
a subclass of NSTableView.

00:11:52.230 --> 00:11:54.740
It follows a lot of the same patterns.

00:11:54.740 --> 00:11:56.780
The biggest difference is that
instead of getting its data

00:11:56.790 --> 00:12:00.870
from an NSTable data source,
it depends on an NSOutlineView data

00:12:00.870 --> 00:12:02.520
source for its data.

00:12:02.520 --> 00:12:06.470
An NSOutlineView data source,
the interface that's declared by it is

00:12:06.470 --> 00:12:11.660
very similar to NSTable data sources
with an important difference because the

00:12:11.690 --> 00:12:14.500
data can be hierarchically organized.

00:12:14.500 --> 00:12:18.280
It provides a few other methods
for determining whether or not an

00:12:18.280 --> 00:12:20.840
item has child items and if so,
how many there are.

00:12:22.350 --> 00:12:26.670
Another important distinction is
the fact that NS Table View or

00:12:26.680 --> 00:12:32.240
NS Table Data Source identifies
rows with a simple integer.

00:12:32.240 --> 00:12:33.240
And why not?

00:12:33.240 --> 00:12:34.240
That's the simplest way to do it.

00:12:34.240 --> 00:12:38.230
That's really not an option with
outline views because row indices,

00:12:38.240 --> 00:12:40.750
things like that,
are changing while the user is

00:12:40.980 --> 00:12:43.240
playing with the little disclosure
triangles and things like that.

00:12:43.240 --> 00:12:47.860
So all the items that are displayed in
an outline view and passed across the

00:12:47.860 --> 00:12:54.320
NS Outline View Data Source protocol
are identified by object references.

00:12:58.000 --> 00:13:00.020
Next topic I want to talk
to you about is printing.

00:13:00.020 --> 00:13:04.140
I want you to know what
you get for free in Cocoa.

00:13:04.140 --> 00:13:04.800
It's a bunch.

00:13:04.800 --> 00:13:08.940
I also want you to know the limits
of what you get for free because some

00:13:09.040 --> 00:13:10.840
people have trouble finding them.

00:13:10.840 --> 00:13:14.130
And I also want you to know that
when you go past those limits,

00:13:14.130 --> 00:13:17.500
even very advanced printing
in Cocoa is still pretty easy.

00:13:18.360 --> 00:13:21.540
So real quick, I'll go through what
views do automatically,

00:13:21.540 --> 00:13:25.580
what sort of printing they support
without much effort at all on your part.

00:13:25.590 --> 00:13:28.540
I'll talk about what you have to do if
you want to take control of the page

00:13:28.540 --> 00:13:30.160
setup that's involved in printing.

00:13:30.160 --> 00:13:33.950
I'll introduce the concept of print
operations and quickly summarize the

00:13:33.950 --> 00:13:36.120
things we do as far as pagination goes.

00:13:37.630 --> 00:13:39.500
Simple printing of views.

00:13:39.500 --> 00:13:41.500
Views can print themselves
without any trouble at all.

00:13:41.500 --> 00:13:43.500
Your review has a print method.

00:13:43.500 --> 00:13:47.620
For example, if you have a file menu
with a print item in it,

00:13:47.620 --> 00:13:51.950
and it's hooked up to the print action,
and it's sending the print

00:13:51.950 --> 00:13:55.910
action down the responder chain,
the first view on the responder chain

00:13:55.910 --> 00:13:58.470
will print itself when it sees that.

00:13:58.490 --> 00:14:01.500
So it'll take care of putting up the
print dialog and things like that.

00:14:01.500 --> 00:14:05.490
For its print setting,
it will use a shared NS Print Info.

00:14:05.500 --> 00:14:10.010
I'll take more on
NS Print Info in a second.

00:14:11.390 --> 00:14:13.940
Before I go on to more
advanced customization,

00:14:13.940 --> 00:14:16.940
let me just point out really quick,
if the only difference in your view,

00:14:16.940 --> 00:14:19.900
the only customization you're considering
is that you might want to do things

00:14:19.900 --> 00:14:22.900
a little differently on the screen
from what you see on the printer,

00:14:22.970 --> 00:14:30.460
well, there's a very easy way to find
out which of you is drawing

00:14:30.460 --> 00:14:31.580
to the printer or the screen,
and that's the current context

00:14:31.580 --> 00:14:31.580
drawing to screen method.

00:14:38.820 --> 00:14:40.560
So page setup.

00:14:40.570 --> 00:14:45.300
Very simple applications can just depend
on what Cocoa already has built into it.

00:14:45.350 --> 00:14:47.860
But if you're doing a more
full-featured application,

00:14:47.950 --> 00:14:49.390
you're going to have
to know a few classes.

00:14:49.420 --> 00:14:53.540
The first one of which is NS Print Info,
which encapsulates all the

00:14:53.540 --> 00:14:55.560
parameters of a print job.

00:14:55.600 --> 00:14:58.650
It includes, among other things,
all the things that the user

00:14:58.650 --> 00:15:01.400
can set up in a print panel,
or a print dialog rather,

00:15:01.400 --> 00:15:05.400
like page size and
orientation and scaling.

00:15:05.400 --> 00:15:10.800
The Cocoa class that actually
presents the print dialog or sheet,

00:15:10.900 --> 00:15:13.000
whichever, is called NS Page Layout.

00:15:13.000 --> 00:15:16.750
And you can see there are the two
methods that you use to do that.

00:15:16.980 --> 00:15:20.050
If your application is document based,
if you're using NS Document,

00:15:20.060 --> 00:15:22.540
you don't really have to
worry about too much of this.

00:15:22.540 --> 00:15:25.890
I try and start going to
what you don't get for free,

00:15:25.890 --> 00:15:28.440
but I immediately run into
what you do get for free again.

00:15:28.480 --> 00:15:30.410
NS Document will take
care of all this for you.

00:15:30.450 --> 00:15:35.580
So if it's a document based app,
you're nearly off the hook.

00:15:36.920 --> 00:15:38.060
Print operations.

00:15:38.060 --> 00:15:40.260
When you start taking
control of printing,

00:15:40.260 --> 00:15:41.880
you know,
not just letting a view print itself,

00:15:41.880 --> 00:15:42.880
you have to learn this class.

00:15:42.900 --> 00:15:43.900
NS print operation.

00:15:43.900 --> 00:15:46.850
An NS print operation is,
as the name implies,

00:15:46.850 --> 00:15:48.890
what actually does printing.

00:15:48.900 --> 00:15:52.130
So when you create it,
you specify an NS print info that

00:15:52.160 --> 00:15:56.030
contains the parameters of printing
and the view that's to be printed,

00:15:56.030 --> 00:15:57.890
and eventually you'll run it.

00:15:57.900 --> 00:15:59.770
Now which view should be printed?

00:15:59.900 --> 00:16:00.890
Well you have a couple of options.

00:16:00.890 --> 00:16:03.900
Text edit, for example,
and I do mean for example.

00:16:03.900 --> 00:16:05.900
You have the source code
so you can check this out.

00:16:05.900 --> 00:16:08.900
Print's one of the views
that's already on the screen.

00:16:08.900 --> 00:16:11.350
The one that you see in the window
is just the same view that gets

00:16:11.350 --> 00:16:12.900
printed by the print operation.

00:16:12.900 --> 00:16:15.880
Sketch, on the other hand,
another sample program,

00:16:15.940 --> 00:16:20.400
creates a view just for printing
and this view only lives for

00:16:20.400 --> 00:16:22.900
the lifetime of the print job.

00:16:22.900 --> 00:16:25.900
So there's advantages and
disadvantages to both ways.

00:16:25.900 --> 00:16:29.210
I suggest you check out the source
code for those two and there's

00:16:29.210 --> 00:16:30.900
plenty of pointers in there.

00:16:30.900 --> 00:16:32.170
So an NS document.

00:16:32.170 --> 00:16:34.900
NS document can't do everything for you.

00:16:34.900 --> 00:16:38.900
So if you're providing printing
in a document-based application,

00:16:39.000 --> 00:16:41.890
it does provide the obvious
place for you to do the printing.

00:16:41.900 --> 00:16:43.690
It's in the print showing
print panel method,

00:16:43.690 --> 00:16:44.900
which you should override.

00:16:44.900 --> 00:16:47.480
And if you do that,
and you create a print

00:16:47.480 --> 00:16:50.770
operation in there,
and you take the NS print info that the

00:16:50.850 --> 00:16:55.900
NS document was maintaining for you,
keeping around, and you set up your view,

00:16:55.900 --> 00:16:59.700
when you actually run the operation,
you should run it using the run

00:16:59.700 --> 00:17:03.890
modal print operation delegate did
run selector context info method.

00:17:03.900 --> 00:17:05.660
method.

00:17:07.080 --> 00:17:11.820
and that will take care of presenting
the sheet because of course we always

00:17:11.820 --> 00:17:14.220
prefer sheets when it's reasonable.

00:17:14.280 --> 00:17:18.000
It will take care of presenting the
sheet on the proper document window.

00:17:18.510 --> 00:17:22.750
So, and one more thing you should
know about printing is pagination.

00:17:22.750 --> 00:17:24.940
We have very flexible pagination.

00:17:24.940 --> 00:17:28.340
For simple cases,
even for cases that aren't so simple,

00:17:28.340 --> 00:17:31.580
you can set margins in the
NS Print Info and then set a few

00:17:31.580 --> 00:17:35.840
pagination modes that we support
on a horizontal and vertical basis.

00:17:35.870 --> 00:17:40.300
Fit pagination, for instance,
will scale a view to fit within one page.

00:17:40.300 --> 00:17:43.200
Clip pagination will
just clip it right there.

00:17:43.200 --> 00:17:47.420
And automatic pagination will
split up the view into pieces.

00:17:48.520 --> 00:17:50.500
And put them on a range of pages.

00:17:50.500 --> 00:17:53.490
For more complex situations,
when you have to take over,

00:17:53.500 --> 00:17:58.320
you can override the nose page
range method of the view that's

00:17:58.320 --> 00:18:01.490
being printed and return yes.

00:18:01.490 --> 00:18:04.500
You'll also have to return the
range of pages that's being printed.

00:18:04.500 --> 00:18:08.500
And then you should also
override NS view rect for page.

00:18:08.500 --> 00:18:11.710
And Cocoa's printing system
will call that repeatedly,

00:18:11.880 --> 00:18:15.500
finding out what piece of the view
should be drawn for each page.

00:18:15.500 --> 00:18:18.480
And during the printing process,
it will tell the view to draw that piece.

00:18:18.500 --> 00:18:20.700
on that page.

00:18:21.710 --> 00:18:24.600
One last thing I want to
mention is file wrappers.

00:18:24.600 --> 00:18:26.600
NS file wrapper, a class of ours.

00:18:26.940 --> 00:18:27.640
What is it?

00:18:27.640 --> 00:18:30.600
It holds the contents and attributes
of a file or a directory's

00:18:30.600 --> 00:18:32.020
worth of files in memory.

00:18:32.040 --> 00:18:33.860
Why is this worth mentioning?

00:18:33.860 --> 00:18:37.030
Well, because it's such an easy way
to manage file attachments.

00:18:37.040 --> 00:18:40.890
When you drag a file into text
edit or into a mail message,

00:18:40.890 --> 00:18:44.960
for instance, and the icon appears,
that's NS file wrapper

00:18:44.960 --> 00:18:47.760
managing all that for you,
making the icon available,

00:18:47.760 --> 00:18:49.130
taking care of things like that.

00:18:49.840 --> 00:18:52.240
It's also an easy way
to read file packages.

00:18:52.240 --> 00:18:55.520
If you're not familiar with the
concept of file packages yet,

00:18:55.580 --> 00:19:00.640
a file package is a directory on a
Mac OS X system that looks just like

00:19:00.700 --> 00:19:02.820
a document to the user in the finder.

00:19:02.840 --> 00:19:05.530
So it's a convenient way
to get a few things done,

00:19:05.530 --> 00:19:08.180
and file wrappers
support them very nicely.

00:19:08.180 --> 00:19:13.040
It does this because a file wrapper
can actually wrap a directory also.

00:19:13.040 --> 00:19:15.930
And when it does that,
you end up with a hierarchy of

00:19:15.930 --> 00:19:17.890
these NS file wrapper objects.

00:19:18.080 --> 00:19:23.430
And you get to the sub file
wrappers using directory entries,

00:19:23.430 --> 00:19:27.480
or dictionary entries,
as is common in Cocoa.

00:19:27.480 --> 00:19:30.480
And the operations on a
file wrapper are recursive,

00:19:30.480 --> 00:19:33.180
so if you're doing something
like copying an NS file wrapper,

00:19:33.180 --> 00:19:37.310
all the sub file wrappers
inside will be copied also.

00:19:38.410 --> 00:19:41.090
So what other kind of things can
you do with the file wrapper?

00:19:41.100 --> 00:19:42.770
As you might guess,
you might want to get the

00:19:42.840 --> 00:19:45.400
data that corresponds to the
file that's being wrapped.

00:19:45.550 --> 00:19:47.500
And you do that,
and of course it provides

00:19:47.500 --> 00:19:49.800
a method for that,
and it returns one of our

00:19:49.850 --> 00:19:51.400
NSData objects for that.

00:19:51.400 --> 00:19:55.500
You can get and set the file
attributes on a file wrapper,

00:19:55.650 --> 00:19:59.500
and get the icon also for displaying in
places like text edit or a mail message,

00:19:59.500 --> 00:20:02.400
wherever you're doing a file
attachment or something like that.

00:20:02.400 --> 00:20:05.810
One neat feature is that if a
file wrapper has been instantiated

00:20:05.810 --> 00:20:10.390
by just copying the contents of
something off of disk into memory,

00:20:10.560 --> 00:20:12.400
file wrapper will keep track of that.

00:20:12.460 --> 00:20:14.700
And if you need to,
you can ask the file wrapper to check

00:20:14.700 --> 00:20:16.390
to see if the copy on disk has changed.

00:20:16.390 --> 00:20:21.400
And if so, you can ask it to update
to that copy on disk also.

00:20:21.520 --> 00:20:25.740
And the last good thing you can do with
file wrappers is you can serialize,

00:20:25.740 --> 00:20:29.470
you can flatten them for putting
places like the pasteboard.

00:20:31.460 --> 00:20:35.020
At this point, please welcome to the
stage Doug Davidson so he

00:20:35.080 --> 00:20:37.220
can talk about services.

00:20:41.100 --> 00:20:42.840
Thanks, Mark.

00:20:42.840 --> 00:20:46.330
Now, we had a tantalizing glimpse of
services in the last session,

00:20:46.350 --> 00:20:49.100
so I'm here to tell you
something more about them.

00:20:49.140 --> 00:20:52.650
And to do that,
I want to start by describing

00:20:52.680 --> 00:20:55.100
services by comparison with
something that's not a service,

00:20:55.100 --> 00:20:58.080
and that is the bold menu
item in an application.

00:20:58.080 --> 00:21:01.380
Now,
when the user picks the bold menu item,

00:21:01.380 --> 00:21:05.080
you can think of what is happening as,
in effect,

00:21:05.080 --> 00:21:11.050
the current selection is being copied,
transformed so it is bold,

00:21:11.050 --> 00:21:13.150
and then pasted back in place.

00:21:13.160 --> 00:21:16.500
Now, that's a very simple operation.

00:21:16.500 --> 00:21:18.160
It's built into every application.

00:21:18.160 --> 00:21:21.700
But suppose you have some
custom operation that your

00:21:22.240 --> 00:21:25.480
application knows how to perform,
and you think it's so great

00:21:25.480 --> 00:21:28.030
that you want to provide it
not only in your application,

00:21:28.040 --> 00:21:28.040
but in your application as well.

00:21:28.040 --> 00:21:28.040
And you want to make sure that you're not
only providing it in your application,

00:21:28.040 --> 00:21:28.040
but you're also providing it
in your application as well.

00:21:28.040 --> 00:21:28.040
So, you can think of what's
happening in your application.

00:21:28.040 --> 00:21:28.040
Now,
when the user picks the bold menu item,

00:21:28.040 --> 00:21:28.040
you can think of what is happening as,
in effect,

00:21:28.040 --> 00:21:28.040
the current selection is being copied,
transforms so it is bold,

00:21:28.040 --> 00:21:28.040
and then paste it back in place.

00:21:28.040 --> 00:21:31.440
Now, that's a very simple operation,
but in every other application as well.

00:21:31.490 --> 00:21:34.080
Now, if you want to do that,
you can use a service.

00:21:34.150 --> 00:21:38.730
And the way it works is that
when that service is requested,

00:21:38.810 --> 00:21:42.100
the current selection is copied,
put on a special pasteboard,

00:21:42.100 --> 00:21:44.080
shipped off to your application.

00:21:44.080 --> 00:21:47.080
Your application will be launched
if it's not already running.

00:21:47.080 --> 00:21:50.060
And you perform your
special operation on it,

00:21:50.060 --> 00:21:54.240
put the result back on the pasteboard,
get shipped back to the

00:21:54.240 --> 00:21:57.770
originating application,
and then that's pasted back in.

00:21:58.030 --> 00:22:01.500
Now, not every service has to
follow this exact pattern.

00:22:01.540 --> 00:22:06.860
For example, the magic typer of the last
session didn't take any data,

00:22:06.860 --> 00:22:09.300
it just returned some
data on the pasteboard.

00:22:09.330 --> 00:22:13.100
Or there can be services that just
take data and don't return anything.

00:22:13.190 --> 00:22:17.350
And the thing that the
service takes or returns,

00:22:17.350 --> 00:22:20.340
it doesn't have to be text,
it can be any sort of thing

00:22:20.340 --> 00:22:22.980
that can be copied and pasted.

00:22:23.780 --> 00:22:28.460
So what does an application have
to do to support use of services?

00:22:28.460 --> 00:22:30.200
Well, this is Cocoa.

00:22:30.200 --> 00:22:32.650
The answer is absolutely nothing.

00:22:32.970 --> 00:22:34.960
The use of services is automatic.

00:22:35.090 --> 00:22:39.630
Your standard Cocoa menu, main menu,
will have a services menu in it.

00:22:39.770 --> 00:22:42.350
The app kit will automatically
populate it with entries for all the

00:22:42.380 --> 00:22:44.080
services available on the system.

00:22:44.170 --> 00:22:47.550
The user just picks it and the
rest happens automatically.

00:22:47.990 --> 00:22:51.590
There are a couple of
things you might want to do.

00:22:51.690 --> 00:22:55.360
It is possible to invoke services
programmatically if you want to.

00:22:55.440 --> 00:23:00.680
Also, if you have a custom view,
the things you need to do to support the

00:23:00.680 --> 00:23:04.010
use of services on it are essentially
the same sort of things that you

00:23:04.020 --> 00:23:05.490
need to do to support copy and paste.

00:23:05.500 --> 00:23:07.490
You need to be able to
take the current selection,

00:23:07.490 --> 00:23:10.050
put it on the pasteboard,
or take something from the pasteboard

00:23:10.050 --> 00:23:11.800
and put it in the current selection.

00:23:13.060 --> 00:23:16.190
Also,
if you have a custom pasteboard type,

00:23:16.190 --> 00:23:20.890
then you have to register that
so that the App Kit can know

00:23:20.930 --> 00:23:25.460
to check for any services that
might take or return that type.

00:23:27.480 --> 00:23:30.420
So the interesting question is,
what does your application have to

00:23:30.420 --> 00:23:32.340
do in order to provide a service?

00:23:32.340 --> 00:23:37.120
Now, in order to provide a service,
there are three things you have to do.

00:23:37.180 --> 00:23:40.670
First one is to implement
one single method.

00:23:40.670 --> 00:23:42.600
It looks something like this.

00:23:42.630 --> 00:23:46.400
And you'll be handed a pasteboard,
optionally some extra data.

00:23:46.400 --> 00:23:51.510
You take what comes in on the pasteboard,
transform it, put it back,

00:23:51.510 --> 00:23:52.230
and send it back.

00:23:52.260 --> 00:23:55.040
And if there's an error,
you can return an error string.

00:23:55.040 --> 00:23:57.540
There are some examples.

00:23:57.540 --> 00:24:00.250
For example, there's a simple service
example on your disk.

00:24:00.360 --> 00:24:02.600
TextEdit also provides a service.

00:24:02.600 --> 00:24:07.480
Here is just the basic skeleton
of what that service-providing

00:24:07.480 --> 00:24:13.890
method might look like.

00:24:14.470 --> 00:24:18.700
take the string off the pasteboard,
one line to perform your operation,

00:24:18.710 --> 00:24:23.100
and then two more lines to say what type
you're putting back on the pasteboard

00:24:23.100 --> 00:24:24.620
and put the value back on the pasteboard.

00:24:24.620 --> 00:24:26.150
That's all.

00:24:26.180 --> 00:24:27.000
That's point number one.

00:24:27.040 --> 00:24:32.650
So the second thing you need to do is
that when your application is launched,

00:24:32.650 --> 00:24:36.240
you need to register the object
that implements this method as the

00:24:36.240 --> 00:24:38.350
service provider for your application.

00:24:38.360 --> 00:24:40.810
There's one service
provider per application.

00:24:40.810 --> 00:24:43.360
That's point number two.

00:24:43.360 --> 00:24:48.600
And point number three is that
you need to add an entry to the

00:24:48.600 --> 00:24:53.610
Info.plist in your application bundle.

00:24:53.620 --> 00:24:58.080
And what that does is to describe the
service or possibly multiple services

00:24:58.080 --> 00:25:02.020
that your application provides,
saying what the name is,

00:25:02.020 --> 00:25:06.460
what types it will take,
what types it will return, menu items,

00:25:06.460 --> 00:25:08.280
and possibly keyboard equivalents.

00:25:08.360 --> 00:25:09.420
Thank you.

00:25:11.050 --> 00:25:12.000
Okay.

00:25:12.000 --> 00:25:15.640
Now next,
I'd like to discuss a few topics

00:25:15.640 --> 00:25:18.100
down at the foundation level.

00:25:19.340 --> 00:25:23.320
First of all, the runloop.

00:25:23.590 --> 00:25:27.090
Cocoa applications are
fundamentally event-driven.

00:25:27.130 --> 00:25:32.530
That is, events come in, they're handled,
and we go back and wait for

00:25:32.530 --> 00:25:33.840
the next event to come in.

00:25:34.090 --> 00:25:38.350
Now, the underlying machinery that
supports this is the runloop,

00:25:38.350 --> 00:25:40.730
NSRunloop, the foundation.

00:25:40.940 --> 00:25:45.840
And we call it a runloop because we
say that it runs and that it loops.

00:25:45.930 --> 00:25:49.530
But mainly what a
runloop does is it waits.

00:25:49.620 --> 00:25:51.980
It waits for something
interesting to happen.

00:25:52.060 --> 00:25:53.200
Then it tells you about it.

00:25:53.320 --> 00:25:54.140
You handle it.

00:25:54.220 --> 00:25:56.520
It goes back and it waits again.

00:25:56.610 --> 00:26:00.660
And the things it waits for can be
any of a wide variety of things.

00:26:00.780 --> 00:26:02.970
It might be the arrival
of a Mach message.

00:26:02.980 --> 00:26:06.120
It might be the arrival
of a network packet.

00:26:06.210 --> 00:26:09.590
It might just be the arrival
of some specific time.

00:26:09.750 --> 00:26:13.510
But what the runloop can do is to
wait for all of these things to

00:26:13.510 --> 00:26:18.760
gather efficiently without pulling,
without using any processor resources.

00:26:18.870 --> 00:26:21.750
And that turns out to be
a very powerful thing.

00:26:22.020 --> 00:26:22.900
and others.

00:26:22.900 --> 00:26:25.520
Now,
there's just one runloop per thread that

00:26:25.520 --> 00:26:27.880
does all the waiting for that thread.

00:26:27.880 --> 00:26:31.970
Typically in an AppKit-based application,
the AppKit will run the runloop

00:26:32.150 --> 00:26:33.710
for you in the main thread.

00:26:33.720 --> 00:26:37.150
You wouldn't have to do that,
but under other circumstances,

00:26:37.270 --> 00:26:43.040
you may wish to run the runloop
for your thread by yourself.

00:26:43.040 --> 00:26:46.380
Now, runloops can have modes.

00:26:46.380 --> 00:26:49.980
It may be that you don't want
to wait for every possible thing

00:26:49.980 --> 00:26:52.380
every time you run the runloop.

00:26:52.380 --> 00:26:56.870
For example, you might not want to have a
certain timer fire while you are,

00:26:56.870 --> 00:27:00.200
let us say, tracking mouse moves.

00:27:00.200 --> 00:27:07.240
So it is possible to run a runloop in
any -- in a number of different modes.

00:27:07.240 --> 00:27:12.610
And when you add a source to the runloop,
you register it for a single

00:27:12.610 --> 00:27:15.370
mode or a set of modes.

00:27:15.470 --> 00:27:18.070
And only those runloops that are
registered for the particular mode

00:27:18.080 --> 00:27:20.860
that is running are actually active.

00:27:20.860 --> 00:27:23.620
The default runloop that you would
use most of the time and that

00:27:23.740 --> 00:27:27.190
probably will be used most of the
time when the runloop is running,

00:27:27.200 --> 00:27:30.580
the AppKit has a couple
of others that you'll see.

00:27:30.580 --> 00:27:33.660
For example,
one that's used when a modal panel is up

00:27:33.660 --> 00:27:39.690
and another that's used typically when
it's tracking mouse moves in a widget.

00:27:39.700 --> 00:27:44.260
And you could register for all of
these together as the common modes.

00:27:46.480 --> 00:27:49.860
Now, runloop by itself is not
terribly interesting.

00:27:49.910 --> 00:27:51.760
What's interesting is
what you can do with it.

00:27:51.850 --> 00:27:54.150
That is, the things you can wait for.

00:27:54.210 --> 00:27:56.870
And one of the things I said
you could wait for was the

00:27:56.870 --> 00:27:58.490
arrival of a certain time.

00:27:58.570 --> 00:28:01.430
To do that, you use an NS timer.

00:28:01.510 --> 00:28:06.400
An NS timer can wait for a single
time or a repeating sequence of times.

00:28:06.500 --> 00:28:08.940
For example,
that silly worm in the last session

00:28:08.940 --> 00:28:15.280
was animated using a timer that waited
for a repeating sequence of times.

00:28:15.360 --> 00:28:19.530
And the way this works is that
when this timer is added to a

00:28:19.530 --> 00:28:23.840
runloop in a particular mode,
if the runloop is running in that mode,

00:28:23.890 --> 00:28:28.300
it checks to see if the time for
that timer to fire has arrived.

00:28:28.330 --> 00:28:30.590
And if it has, then it tells you.

00:28:30.590 --> 00:28:34.500
That is,
an object of your choice will be sent a

00:28:34.500 --> 00:28:38.110
method of your choice when that occurs.

00:28:38.910 --> 00:28:43.040
and of course if you have a one
shot timer it's automatically

00:28:43.040 --> 00:28:44.800
invalidated after it has fired.

00:28:44.800 --> 00:28:48.350
If you have a repeating timer then you
would have to invalidate it yourself

00:28:48.390 --> 00:28:51.150
when you no longer want it to be used.

00:28:53.920 --> 00:28:56.320
Among the other things
you could wait for,

00:28:56.320 --> 00:29:01.700
I said, were Mach messages,
network packets, things like that.

00:29:01.890 --> 00:29:05.640
If you really want to wait for raw
Mach messages or raw network packets,

00:29:05.640 --> 00:29:08.580
you can do that at the core
foundation level with some core

00:29:08.640 --> 00:29:09.740
foundation runloop sources.

00:29:09.740 --> 00:29:13.330
And I'll probably mention that tomorrow
in the core foundation session.

00:29:13.340 --> 00:29:17.520
At the foundation level,
we have a somewhat more

00:29:17.520 --> 00:29:22.480
abstracted object based on those,
and that is NSPort.

00:29:24.020 --> 00:29:29.750
And what NSPort allows you to do is to
send what's called an NSPort message

00:29:29.970 --> 00:29:32.220
from one Cocoa process to another.

00:29:32.220 --> 00:29:36.540
And the contents of a port
message is mainly just an NSData,

00:29:36.540 --> 00:29:37.860
a bag of bytes.

00:29:37.860 --> 00:29:41.350
It can also optionally include
some references to ports

00:29:41.350 --> 00:29:43.040
that can be sent across.

00:29:43.040 --> 00:29:47.300
And an NSPort message is sent.

00:29:47.640 --> 00:29:49.630
are all presented.

00:29:49.740 --> 00:29:56.600
I'm going to show you a little bit of the
process of how to use the Cocoa Topics.

00:29:56.600 --> 00:30:06.300
It's a fairly simple, easy-to-use,
but rather low-level,

00:30:06.400 --> 00:30:13.070
inter-process communication mechanism.

00:30:14.960 --> 00:30:19.010
A more interesting thing about MS Ports
is that they're the foundation of

00:30:19.010 --> 00:30:22.200
what's known as distributed objects.

00:30:22.260 --> 00:30:28.470
Now what distributed objects allows
you to do is to send method calls to

00:30:28.470 --> 00:30:34.610
objects transparently across thread,
process, and machine boundaries.

00:30:35.140 --> 00:30:36.710
What do I mean by that?

00:30:36.740 --> 00:30:40.300
It means, for example,
you can have safe interthread

00:30:40.300 --> 00:30:43.700
communication because you can
send a message that will be

00:30:43.700 --> 00:30:48.430
delivered to an object and be
delivered in another thread.

00:30:48.660 --> 00:30:54.140
or you can send a method to
an object in another process,

00:30:54.160 --> 00:30:56.490
maybe even a process running
on a different machine,

00:30:56.490 --> 00:30:58.730
and it will be delivered there.

00:30:59.540 --> 00:31:04.300
The fundamental object in distributed
objects is an NS connection,

00:31:04.300 --> 00:31:08.180
which runs from one
NS port to another NS port,

00:31:08.220 --> 00:31:10.740
and the messages are sent
across the connection.

00:31:10.760 --> 00:31:16.430
Now, one thing about NS port is that
in abstraction there are different

00:31:16.480 --> 00:31:21.100
subclasses of NS port to refer to
different transport mechanisms.

00:31:21.170 --> 00:31:23.430
For example,
there's one subclass that uses

00:31:23.430 --> 00:31:26.490
Mach messages for communication
on the local machine.

00:31:26.500 --> 00:31:31.770
There's another subclass that uses
TCP/IP for transport from one machine

00:31:31.770 --> 00:31:34.000
to another across the network.

00:31:34.000 --> 00:31:39.120
And depending on which subclass you
use when you create your connection,

00:31:39.120 --> 00:31:42.820
you can get either means of transport.

00:31:45.160 --> 00:31:47.800
And when you set up a connection,
one side,

00:31:47.800 --> 00:31:51.780
which is going to be the server,
sets one of its objects as the

00:31:51.790 --> 00:31:53.060
root object for the connection.

00:31:53.080 --> 00:31:54.660
It's vending that out.

00:31:54.700 --> 00:31:58.240
The other side, the client,
gets a proxy for that

00:31:58.240 --> 00:32:00.520
object with its connection.

00:32:00.520 --> 00:32:04.390
And then it can send methods
to the proxy as if it were

00:32:04.390 --> 00:32:07.030
sending them to the real object.

00:32:07.100 --> 00:32:11.750
The methods are forwarded across
the connection and delivered to that

00:32:11.750 --> 00:32:14.200
root object at the receiving end.

00:32:16.230 --> 00:32:21.120
and the way the two sides hook
up also depends on what sort of

00:32:21.200 --> 00:32:23.160
transport mechanism you're using.

00:32:23.160 --> 00:32:27.200
If you're on the local machine,
you can register connections by name.

00:32:27.210 --> 00:32:31.700
If you're going over TCP/IP,
you usually rendezvous based on

00:32:31.700 --> 00:32:35.650
a TCP port and an IP address.

00:32:36.740 --> 00:32:39.610
Now,
there are a number of examples of this

00:32:39.640 --> 00:32:43.630
in the documentation on NSConnection.

00:32:43.640 --> 00:32:46.120
And exactly how you use it depends
a little on what you're doing.

00:32:46.140 --> 00:32:50.620
But let me just give one brief
example of a connection that's used

00:32:50.620 --> 00:32:53.340
for inter-thread communication.

00:32:53.430 --> 00:32:58.040
So, on one side, the main thread,
what we're doing is

00:32:58.040 --> 00:33:02.450
first creating a port,
and then we create a connection

00:33:02.550 --> 00:33:05.110
that we'll receive with that port.

00:33:05.190 --> 00:33:09.380
We set ourselves, as it happens,
as the root object for that connection.

00:33:09.380 --> 00:33:11.230
That means we're vending ourselves out.

00:33:11.290 --> 00:33:13.690
We're going to get the messages.

00:33:13.770 --> 00:33:17.260
And then we create another thread,
and that other thread is going to

00:33:17.260 --> 00:33:19.440
send us messages on this connection.

00:33:19.490 --> 00:33:21.190
So we give it the port.

00:33:21.280 --> 00:33:25.260
Now, in that other thread,
we use that port to recreate a

00:33:25.270 --> 00:33:27.770
connection to send to that port.

00:33:27.940 --> 00:33:30.800
and we do whatever calculation
we want to in this thread.

00:33:30.800 --> 00:33:33.930
Maybe it takes a long time
to do this calculation.

00:33:34.080 --> 00:33:37.590
And then when we're done
with that calculation,

00:33:37.870 --> 00:33:40.300
We ask this connection
for the root proxy,

00:33:40.370 --> 00:33:43.990
and that gets a proxy
for that root object,

00:33:43.990 --> 00:33:46.000
the self on the other side.

00:33:46.070 --> 00:33:50.490
And then we just send a method to it,
server report result result.

00:33:50.550 --> 00:33:54.310
This normal Objective-C message then,
except that in this case,

00:33:54.330 --> 00:33:58.100
it's going to be delivered to
that other object in its thread,

00:33:58.150 --> 00:33:59.900
the main thread.

00:33:59.940 --> 00:34:03.140
So the result is safe
inter-thread communication.

00:34:05.180 --> 00:34:09.230
Okay, and I'd also like to talk
about a few other things in

00:34:09.290 --> 00:34:13.910
Foundation that are enabled,
although not immediately directly,

00:34:13.990 --> 00:34:16.100
by the runloop mechanism.

00:34:16.100 --> 00:34:21.570
So, NSURL in Foundation,
the basic use of NSURL is

00:34:21.590 --> 00:34:23.950
to encapsulate a URL.

00:34:23.950 --> 00:34:30.570
So you can have the scheme and the path
and all the other components of URL and

00:34:30.570 --> 00:34:33.100
analyze those and pass that around.

00:34:33.100 --> 00:34:39.110
But another thing you can do with
NSURL is you can do simple fetching of

00:34:39.110 --> 00:34:46.100
the contents of URL by default built in
for file colon and HTTP colon schemes.

00:34:46.100 --> 00:34:51.290
And this is a rather simple
mechanism and some limitations,

00:34:51.290 --> 00:34:55.070
but you can get notified when the
download starts or when various

00:34:55.140 --> 00:34:58.100
interesting things happen during it.

00:34:58.100 --> 00:35:01.460
There's also a slightly more complicated
mechanism if you want more detailed

00:35:01.520 --> 00:35:03.070
control over what's happening in NSURL.

00:35:03.140 --> 00:35:09.720
There's an NSURL handle that can give you
somewhat finer control and you can also

00:35:09.720 --> 00:35:13.100
subclass this if you want to handle other
schemes that you know how to handle.

00:35:16.320 --> 00:35:19.580
Another thing has to
do with Apple events.

00:35:19.580 --> 00:35:22.790
It's been mentioned earlier that
Cocoa provides a lot of support

00:35:22.790 --> 00:35:25.250
for Apple script for scripting.

00:35:25.250 --> 00:35:29.340
But it's also possible to
receive individual Apple events.

00:35:29.370 --> 00:35:30.770
It's very simple.

00:35:30.810 --> 00:35:34.800
There's a shared NSAppleEventManager,
one object,

00:35:34.800 --> 00:35:41.860
and all you do is register a particular
object and method to be called when a

00:35:41.970 --> 00:35:44.850
particular Apple event type arrives.

00:35:44.850 --> 00:35:47.490
And then you'll be
called with a selector,

00:35:47.550 --> 00:35:50.150
be given the Apple event,
and then be given a reply.

00:35:50.150 --> 00:35:52.030
And then you fill in the
reply and send it back.

00:35:52.030 --> 00:35:54.050
Very

00:35:56.760 --> 00:35:59.950
Okay, and finally,
I'd like to talk a little bit

00:36:00.000 --> 00:36:03.250
about exceptions in Foundation.

00:36:03.360 --> 00:36:08.620
Now, the Objective-C language does not
have a built-in exception mechanism,

00:36:08.620 --> 00:36:10.700
but the Foundation provides one.

00:36:10.920 --> 00:36:17.450
That is, an exception object,
NSException,

00:36:17.450 --> 00:36:19.480
and a means of raising exceptions
and a means of handling them.

00:36:19.870 --> 00:36:25.210
and these NS exceptions,
they have a name, a string name that's

00:36:25.210 --> 00:36:27.830
used to identify them,
and a reason,

00:36:27.860 --> 00:36:32.620
which is some reason that's supposed
to be intelligible to a programmer.

00:36:33.140 --> 00:36:34.100
and others.

00:36:34.100 --> 00:36:38.130
Now, in your own code,
you can use exceptions however you like,

00:36:38.220 --> 00:36:41.050
but as Cocoa uses them,
typically we use them only for

00:36:41.050 --> 00:36:46.220
really truly exceptional conditions,
things that can't really be handled,

00:36:46.220 --> 00:36:50.520
usually the result of
some programming error.

00:36:50.520 --> 00:36:52.980
We don't want you to have
to use exception handling

00:36:52.980 --> 00:36:57.950
contexts all over the place,
only in special cases.

00:36:57.950 --> 00:37:00.570
And, of course,
they can be handled at multiple levels.

00:37:00.590 --> 00:37:05.130
For example, typically the app kit will
catch exceptions occurring in

00:37:05.130 --> 00:37:08.990
its main event loop if they are
not caught at some lower level.

00:37:08.990 --> 00:37:12.490
If an exception really is not
handled at all at any level,

00:37:12.490 --> 00:37:16.560
then there's a default exception
handler that basically just exits

00:37:16.610 --> 00:37:19.700
the process or you can install your
own if you want some other behavior.

00:37:22.760 --> 00:37:25.160
So how do you raise an exception?

00:37:25.160 --> 00:37:29.160
The simplest way is by calling
a class method on NSException

00:37:29.200 --> 00:37:31.000
to raise with a name.

00:37:31.000 --> 00:37:33.660
You give it the name of
the exception and format,

00:37:33.660 --> 00:37:38.900
which is a printf style format string
and arguments to produce the reason,

00:37:38.910 --> 00:37:42.710
which is, as I said,
supposed to be intelligible

00:37:42.910 --> 00:37:44.860
to a programmer.

00:37:44.870 --> 00:37:48.650
And there is a slightly more
complicated way you have to do that.

00:37:48.650 --> 00:37:53.990
You can attach essentially arbitrary
user info data to the exception.

00:37:53.990 --> 00:37:56.680
So if you want to do that,
you can create the exception

00:37:56.690 --> 00:37:58.050
and then go ahead and raise it.

00:37:59.920 --> 00:38:02.130
How do you handle an exception?

00:38:02.210 --> 00:38:07.710
The way you do it is, first of all,
you start with an NSDuring,

00:38:07.710 --> 00:38:14.240
and then comes the block wherein
you try to perform the operation

00:38:14.350 --> 00:38:17.820
that might raise an exception,
an NSHandler,

00:38:17.820 --> 00:38:22.210
and then comes the exception
handling context where you would be

00:38:22.300 --> 00:38:27.860
sent to if an exception was raised,
and then NSHandler ends the block.

00:38:30.160 --> 00:38:34.100
Now, once you get into this
exception handling context,

00:38:34.100 --> 00:38:38.920
when an exception was raised,
there are four ways you can get out.

00:38:38.980 --> 00:38:41.980
One is you can just
fall through to the end,

00:38:41.980 --> 00:38:45.050
just keep going as if nothing happened.

00:38:45.190 --> 00:38:48.760
Or you can re-raise the
exception that was raised,

00:38:48.760 --> 00:38:50.080
just send it on.

00:38:50.080 --> 00:38:54.480
Or maybe you have a new exception
you want to raise that covers that.

00:38:54.480 --> 00:38:57.240
Or you can exit the method altogether.

00:38:57.240 --> 00:39:01.810
And there's an NSValue return
that's used if you're returning

00:39:01.820 --> 00:39:03.700
something from the method,
or an NSVoid return if

00:39:03.700 --> 00:39:04.810
the method returns void.

00:39:06.820 --> 00:39:11.370
and the way that you know what the
exception was that was raised is that

00:39:11.380 --> 00:39:16.340
there's a local variable whose context
is this exception handling block,

00:39:16.470 --> 00:39:17.440
local exception.

00:39:17.510 --> 00:39:21.420
And you can take that and then
save it if you want to use it

00:39:21.580 --> 00:39:24.100
later or possibly re-raise it.

00:39:24.940 --> 00:39:27.750
and let's see,
the only other thing I wanted to mention

00:39:27.760 --> 00:39:32.640
about these exceptions is that in Java,
they're wrapped as, I believe,

00:39:32.640 --> 00:39:34.800
a subclass of the runtime exception.

00:39:34.800 --> 00:39:41.750
And so next I want to turn the
stage over to Chuck Pisula.

00:39:50.950 --> 00:39:53.470
Okay, this is the section of the talk
where basically everyone's on the

00:39:53.470 --> 00:39:56.740
same foot because we're talking
about new features which even

00:39:56.760 --> 00:39:58.300
experienced people haven't seen before.

00:39:58.300 --> 00:40:02.580
So, I'm actually kind of lying a little
bit because some of these new features

00:40:02.580 --> 00:40:06.290
are really things that we had before,
hadn't been working for a while,

00:40:06.380 --> 00:40:07.320
and they're now back.

00:40:07.420 --> 00:40:08.820
So, let's get into these.

00:40:10.460 --> 00:40:15.400
First of all, let's talk about XML.

00:40:15.400 --> 00:40:20.510
Until now, Cocoa used to store what we
call plists in an ASCII format.

00:40:20.510 --> 00:40:24.360
We still store it in an ASCII format,
but that format's defined using XML.

00:40:24.360 --> 00:40:27.290
And when we did this,
we also added support for a

00:40:27.420 --> 00:40:31.620
number of types that developers
have been asking for for a while.

00:40:31.620 --> 00:40:35.940
So we can now do things like array, data,
date, some various other standard

00:40:35.950 --> 00:40:37.210
types that you want.

00:40:37.990 --> 00:40:41.310
And if you need to do anything
that's not in the standard list,

00:40:41.410 --> 00:40:44.310
you can always convert to
an NSString or an NSData.

00:40:45.960 --> 00:40:49.200
Cocoa now also has support for
dealing with HFS file types.

00:40:49.200 --> 00:40:56.670
Now, we added this support without
modifying any of our API that

00:40:56.670 --> 00:40:59.820
uses extension-based parameters.

00:40:59.820 --> 00:41:02.720
So, for instance,
if you want to bring up an open

00:41:02.790 --> 00:41:06.220
panel and tell it what types
you're allowing it to open,

00:41:06.220 --> 00:41:11.070
you can pass in strings which
represent HFS file types.

00:41:11.080 --> 00:41:13.920
And, again, we've done this without
modifying the API.

00:41:13.920 --> 00:41:17.380
So if you want to

00:41:17.770 --> 00:41:20.800
allow the Open Panel to open
some sort of HFS file type.

00:41:21.160 --> 00:41:26.610
You'd use one of the functions
like NSHFSFile for type code.

00:41:26.900 --> 00:41:31.010
You'd convert the OS type code
to an NSString and pass that

00:41:31.010 --> 00:41:33.360
into the extension-based API.

00:41:33.430 --> 00:41:37.660
So you can mix extensions
along with HFS file types.

00:41:42.150 --> 00:41:45.220
NSWorkspace is back and
mostly functional again.

00:41:45.370 --> 00:41:48.130
So there are parts that hadn't
been functioning for a while.

00:41:48.290 --> 00:41:52.660
The parts that still aren't
functioning are mostly OS specific.

00:41:52.760 --> 00:41:55.160
Those are the few exceptions.

00:41:55.240 --> 00:41:57.830
We've also added some new methods.

00:41:57.830 --> 00:42:00.360
Methods to open URLs,
check whether or not

00:42:00.440 --> 00:42:03.920
something is a file package,
and even methods to check

00:42:04.030 --> 00:42:06.350
for local mounted volumes.

00:42:07.600 --> 00:42:09.860
We now have support for
custom window shapes.

00:42:10.030 --> 00:42:13.870
The things you see like the
clock up there were done

00:42:13.980 --> 00:42:15.930
using a custom window shape.

00:42:16.040 --> 00:42:19.600
And what you,
the support that's needed to

00:42:19.600 --> 00:42:24.260
do this is the ability to first
set the alpha value of a window.

00:42:24.510 --> 00:42:28.270
Tell a window that it's opaque,
then what you would do is fill

00:42:28.310 --> 00:42:31.640
its content with clear color,
and anywhere you fill it with non-clear

00:42:31.640 --> 00:42:32.900
color would then be the window.

00:42:33.040 --> 00:42:36.570
So in this example above,
I initially told the window

00:42:36.570 --> 00:42:39.640
that it's not opaque,
filled it with clear color,

00:42:39.800 --> 00:42:42.980
and then drew using a clock image,
and then of course put

00:42:43.070 --> 00:42:44.550
the hands on top of it.

00:42:46.490 --> 00:42:49.570
and we've also added support
for you to turn off shadows.

00:42:49.650 --> 00:42:51.960
Now,
if you do your own custom window shades,

00:42:52.000 --> 00:42:54.330
you're of course going to have to
handle your own window dragging.

00:42:57.230 --> 00:42:59.920
We now have small controls.

00:42:59.920 --> 00:43:05.000
A number of controls that you're used
to seeing in Cocoa come in both flavors,

00:43:05.120 --> 00:43:07.160
buttons and check boxes.

00:43:07.380 --> 00:43:11.560
Larger things, even like the tab view,
like the example above,

00:43:11.560 --> 00:43:13.860
have normal and small variants.

00:43:15.070 --> 00:43:17.240
To choose small controls,
typically you're going to do

00:43:17.240 --> 00:43:18.540
it when you lay out your UI.

00:43:18.540 --> 00:43:21.230
So in Interface Builder,
you're going to check one box

00:43:21.290 --> 00:43:22.920
that says use small control.

00:43:22.920 --> 00:43:27.900
But you can also do this programmatically
by sending the set control size

00:43:27.900 --> 00:43:30.160
method using the small control size.

00:43:30.180 --> 00:43:33.610
Typically,
the set control size message will be

00:43:33.610 --> 00:43:36.720
sent actually to the cell of the control.

00:43:36.720 --> 00:43:39.610
So those of you who are
familiar with controls know that

00:43:39.710 --> 00:43:41.430
controls display using cells.

00:43:42.280 --> 00:43:46.610
And so the cell typically will be
the one that receives this message.

00:43:48.620 --> 00:43:49.890
and a status bar is back.

00:43:49.900 --> 00:43:52.680
It has no new API.

00:43:52.820 --> 00:43:54.400
Status items are really pretty simple.

00:43:54.620 --> 00:43:57.960
Sort of like the toolbar,
they have many similar attributes.

00:43:58.000 --> 00:44:01.000
You can set a target action, a title,
an image.

00:44:01.000 --> 00:44:05.000
You can associate a drop-down
menu and they can have tool tips.

00:44:05.200 --> 00:44:08.030
And also similar to the toolbar,
you can have your own

00:44:08.240 --> 00:44:10.000
custom views up there.

00:44:10.000 --> 00:44:13.450
So if you want to install your
own custom sort of status view,

00:44:13.760 --> 00:44:16.910
use the set view method.

00:44:17.720 --> 00:44:20.010
Typically,
you want to make sure that the status

00:44:20.050 --> 00:44:23.940
items are small things and you should
use them sparingly because there might

00:44:23.940 --> 00:44:25.540
not be a lot of space to display them.

00:44:25.920 --> 00:44:31.410
Currently,
these things are displayed in the menu,

00:44:31.500 --> 00:44:34.230
in the top menu of Mac OS X.

00:44:36.070 --> 00:44:37.880
Ennis MovieView is back.

00:44:37.880 --> 00:44:42.080
Ennis MovieView is a control
in Cocoa that you can use

00:44:42.080 --> 00:44:43.230
to play QuickTime movies.

00:44:43.240 --> 00:44:47.210
It encapsulates a movie object,
which is the

00:44:47.210 --> 00:44:50.390
QuickTime structure for movies.

00:44:50.400 --> 00:44:55.670
This movie object is now stored in
an Ennis Movie and can be accessed

00:44:55.780 --> 00:44:59.300
from the Ennis Movie object if
you want to do complicated things.

00:44:59.610 --> 00:45:03.500
Also, the movie controller is
stored by the Ennis MovieView.

00:45:03.500 --> 00:45:08.240
The movie controller is the little
controls at the bottom that allow you

00:45:08.290 --> 00:45:11.800
to drag your position in the movie,
press play or pause.

00:45:11.800 --> 00:45:15.550
You can access that directly if
you want to do more complex things

00:45:15.590 --> 00:45:17.720
than Ennis Movie allows you to do.

00:45:20.000 --> 00:45:25.540
As I said, NSMovie now wraps the
QuickTime movie structure.

00:45:25.820 --> 00:45:30.690
However, it's not an Objective-C wrapper
for all QuickTime APIs.

00:45:30.770 --> 00:45:34.460
So typically, if you need to do something
specific with your movie,

00:45:34.540 --> 00:45:37.490
you'll access the movie directly
and use QuickTime calls.

00:45:37.730 --> 00:45:41.780
You can initialize the
NSMovie in a number of ways.

00:45:43.020 --> 00:45:46.360
either from a QuickTime,
already created QuickTime movie

00:45:46.360 --> 00:45:50.130
object by URL or from the pasteboard.

00:45:50.200 --> 00:46:05.500
[Transcript missing]

00:46:05.710 --> 00:46:08.270
Currently there's no
support for allocating from

00:46:08.270 --> 00:46:10.380
a streaming type of source.

00:46:10.380 --> 00:46:12.880
If you need to do that,
you should create your QuickTime movie

00:46:12.880 --> 00:46:18.370
object using new movie from DataRef
and then hand it off to the NSMovie.

00:46:20.810 --> 00:46:25.740
NSOpenGL has a couple new methods,
in particular update and reshape.

00:46:25.920 --> 00:46:30.990
These are methods that those familiar
with OpenGL programming know that if,

00:46:31.010 --> 00:46:35.220
say, the size of your viewport changes,
you need to update certain

00:46:35.220 --> 00:46:36.530
viewing parameters.

00:46:36.640 --> 00:46:38.870
This is where you'll do that.

00:46:39.290 --> 00:46:42.450
Another note of interest,
if you're doing full

00:46:42.830 --> 00:46:45.210
screen OpenGL applications,

00:46:45.460 --> 00:46:52.380
In order to prevent the dock or possibly
the application menu from receiving

00:46:52.380 --> 00:46:57.070
mouth clicks or other things potentially,
you might need to provide a cover window.

00:46:57.080 --> 00:47:01.560
What you would do is make a window
and give it a window level which is

00:47:02.130 --> 00:47:06.800
higher than anything else so that
it would intercept the mouse events.

00:47:06.860 --> 00:47:10.470
And the window level you want to
give it is KCG overlay window level.

00:47:11.440 --> 00:47:15.110
Okay,
the toolbar is a completely new class.

00:47:15.190 --> 00:47:20.240
It comes along with a NS Toolbar
item class which is also brand new.

00:47:20.690 --> 00:47:24.400
The basic idea here is that the
toolbar represents the NS Toolbar

00:47:24.400 --> 00:47:27.030
represents the whole toolbar,
and it takes care of a

00:47:27.030 --> 00:47:29.760
number of tasks for you,
like synchronizing toolbars.

00:47:29.760 --> 00:47:33.010
If you make a change in one toolbar,
you want it to be reflected in all

00:47:33.010 --> 00:47:35.320
other toolbars with the same identifier.

00:47:35.320 --> 00:47:39.260
Again, Mail has three different
kinds of toolbars,

00:47:39.260 --> 00:47:43.820
so if I change the ordering of
my items in my Compose window,

00:47:43.820 --> 00:47:46.140
I want it to be reflected
in any other Compose window

00:47:46.210 --> 00:47:47.840
I currently have up immediately.

00:47:49.120 --> 00:47:53.570
NS Toolbar also takes care of archiving
the configuration out to disk and making

00:47:53.570 --> 00:47:56.020
sure when you create new toolbars,
they come up with that

00:47:56.020 --> 00:47:57.000
same configuration.

00:47:57.000 --> 00:48:02.070
In addition, NS Toolbar also will run the
customization sheet that you've

00:48:02.240 --> 00:48:06.300
seen drop down from Mail and
will control the display of that.

00:48:06.520 --> 00:48:10.460
All you need to typically do is provide
those delegate methods that if you're

00:48:10.460 --> 00:48:12.560
in the last session you heard about.

00:48:13.190 --> 00:48:17.170
Each item in the toolbar is
represented by an NSToolbarItem object.

00:48:17.340 --> 00:48:19.580
Again,
this is very similar to status bar items.

00:48:19.660 --> 00:48:22.820
They have some standard
attributes like images,

00:48:22.870 --> 00:48:27.690
labels, menus that can be associated
when you're in text-only mode.

00:48:27.840 --> 00:48:32.010
And they have, again,
target and action because target

00:48:32.020 --> 00:48:36.770
and action is typically how
controls communicate in Cocoa.

00:48:37.250 --> 00:48:40.000
And again,
if you need to provide your own

00:48:40.040 --> 00:48:43.560
kind of item that's not simply
a sort of standard button,

00:48:43.580 --> 00:48:47.970
something like the search field in
Mail can be provided as a custom view.

00:48:48.180 --> 00:48:51.000
Now we don't, in Cocoa again,
we give you lots for free,

00:48:51.000 --> 00:48:53.760
so we also have some standard
items that you can get for free.

00:48:53.760 --> 00:48:57.300
A separator toolbar item,
one that will pop up the color panel,

00:48:57.300 --> 00:48:58.200
and so forth.

00:49:01.790 --> 00:49:03.550
and a stepper is a new class.

00:49:03.730 --> 00:49:09.690
It's these small up and down
arrows that you see here.

00:49:09.690 --> 00:49:09.690
And

00:49:09.770 --> 00:49:14.000
Basically something that you'll use
if you want to have an incrementer.

00:49:14.000 --> 00:49:16.140
And you can set things
like a min and max value,

00:49:16.140 --> 00:49:19.540
the increment step size,
and whether it wraps or auto repeats.

00:49:23.380 --> 00:49:26.320
NS Image has a couple new methods.

00:49:26.320 --> 00:49:28.770
And the reason that we have
these new methods is that

00:49:29.220 --> 00:49:33.020
existing methods in NS Image

00:49:34.310 --> 00:49:37.540
typically did not pay attention,
respect the current transform.

00:49:37.540 --> 00:49:39.880
They simply blit the image to the screen.

00:49:39.880 --> 00:49:44.050
Now the new methods,
drawAtPoint and drawInRect,

00:49:44.050 --> 00:49:47.700
will pay attention to
the current transform.

00:49:47.700 --> 00:49:51.200
So if you want to do things
like scale or flip your image,

00:49:51.200 --> 00:49:52.500
things like that.

00:49:52.520 --> 00:49:56.430
And the additional parameters
that you see are for specifying

00:49:56.670 --> 00:50:00.120
the part of the source image that
you want to draw to the screen.

00:50:00.120 --> 00:50:01.600
You don't have to use the whole image.

00:50:01.760 --> 00:50:06.600
You could just use the whole image,
you know, 0, 0 to width by height.

00:50:06.600 --> 00:50:10.090
And then the remaining
parameters are the operation.

00:50:10.100 --> 00:50:15.470
You can specify a simple copy type of
compositing operation or a source over,

00:50:15.470 --> 00:50:16.100
so on.

00:50:16.120 --> 00:50:20.420
And the fractional amount of
the image that you want to draw.

00:50:20.420 --> 00:50:22.550
So it can be anywhere from 0 to 1.

00:50:22.560 --> 00:50:26.430
1 being fully opaque,
0 being fully transparent.

00:50:29.380 --> 00:50:31.930
There are a couple new graphics
features that we have that

00:50:32.150 --> 00:50:36.780
provide you finer control over
some of the display operations.

00:50:36.870 --> 00:50:40.790
In particular,
you can turn on and off anti-aliasing,

00:50:40.790 --> 00:50:44.800
and you can control the
granularity of image interpolation.

00:50:44.800 --> 00:50:49.810
And the types of values that you can use
for image interpolation are either none,

00:50:49.810 --> 00:50:52.530
low, high, or Cocoa's default.

00:50:54.990 --> 00:51:01.500
and this bitmap image rep also has some
new support for using color sync data.

00:51:01.550 --> 00:51:04.430
And the particulars of this,

00:51:04.690 --> 00:51:05.590
and others.

00:51:06.620 --> 00:51:07.160
So, let's go like this.

00:51:07.160 --> 00:51:11.640
NSBitmap Image Rep has a dictionary
of sort of arbitrary information

00:51:11.640 --> 00:51:13.820
that can be attached to it.

00:51:13.820 --> 00:51:16.320
One piece of information that
can now be attached to it is

00:51:16.330 --> 00:51:17.900
this color sync information.

00:51:17.900 --> 00:51:22.680
And the color sync information is
simply an NSData object and the

00:51:22.680 --> 00:51:29.240
key that you use to attach it is
NSImage color sync profile data.

00:51:29.290 --> 00:51:32.080
If you look at the NSBitmap
Image Rep documentation,

00:51:32.170 --> 00:51:36.130
you'll see that there's this
business about properties that can be

00:51:36.170 --> 00:51:39.000
associated with the Bitmap Image Rep.

00:51:42.670 --> 00:51:45.440
OK, so we shipped Mac OS X 10.0.

00:51:45.440 --> 00:51:47.440
Now we have to worry about
things like versioning.

00:51:47.440 --> 00:51:52.770
So this is new in that sense,
but we've always sort of had versioning.

00:51:52.940 --> 00:51:57.590
The important thing here is always test
your applications against old versions of

00:51:57.590 --> 00:51:59.800
the AppKit and old versions of Mac OS X.

00:51:59.800 --> 00:52:03.920
And you may potentially need to
check against what version number

00:52:03.920 --> 00:52:06.180
of the Cocoa frameworks you have.

00:52:06.240 --> 00:52:12.600
And the value you'll need to check is
this value called NSAppKitVersionNumber.

00:52:12.600 --> 00:52:16.600
For 10.0, the version number of
the Cocoa frameworks or

00:52:16.600 --> 00:52:18.730
AppKit sometimes we refer to it.

00:52:20.220 --> 00:52:24.000
The version number of AppKit was 577.0.

00:52:24.110 --> 00:52:25.740
Foundation would have
its own version number.

00:52:27.580 --> 00:52:33.970
and in 10.0,
we didn't declare the variable anywhere,

00:52:33.990 --> 00:52:35.410
so you're going to have to make
sure you declare it yourself

00:52:35.530 --> 00:52:36.540
if you want to reference it.

00:52:36.630 --> 00:52:39.400
And it's a double,
so you declare extern double

00:52:39.580 --> 00:52:41.250
NSAppKit version number.

00:52:41.260 --> 00:52:44.990
And the important thing here is
that when you're checking for,

00:52:44.990 --> 00:52:48.600
say, a new bug fix,
we may have said the bug fix

00:52:48.610 --> 00:52:54.250
for Super Widget A came out in
the next release of the AppKit.

00:52:54.720 --> 00:52:57.720
And you don't want to check
for greater than or equal to,

00:52:57.720 --> 00:53:01.710
well, greater than 577 to know
whether or not the fix is there.

00:53:01.720 --> 00:53:06.640
Because the next major
release may be 587.

00:53:06.640 --> 00:53:09.880
And this bug fix may have come
along somewhere in between,

00:53:09.880 --> 00:53:11.890
say, on a software update even.

00:53:11.900 --> 00:53:15.830
You want to make sure that you
compare against the specific

00:53:15.830 --> 00:53:19.000
number of where that fix is,
because you want it to work

00:53:19.000 --> 00:53:22.520
on the in-between releases,
not just...

00:53:23.150 --> 00:53:24.000
and others.

00:53:24.000 --> 00:53:25.000
The first thing I want to
talk about is the bug fixes.

00:53:25.000 --> 00:53:28.080
It's sort of hard to explain,
but there would be a window where if

00:53:28.080 --> 00:53:31.880
you're just checking greater than 577,
where the fix is not actually there,

00:53:31.890 --> 00:53:33.000
but you thought it was.

00:53:33.000 --> 00:53:36.300
So you want to check against
specific version numbers.

00:53:36.300 --> 00:53:40.580
For bug fixes or features, in fact,
that can be solely described by

00:53:40.580 --> 00:53:45.230
whether or not an object has a method,
through the beauty of Objective-C's

00:53:45.230 --> 00:53:48.960
very fast introspection,
you can actually just ask whether or

00:53:48.960 --> 00:53:51.100
not the object responds to the method.

00:53:51.170 --> 00:53:55.100
If the object responds to the method,
well then the feature's there.

00:53:55.100 --> 00:53:57.410
For all these things,
check the release notes and it

00:53:57.410 --> 00:54:00.540
should be clear what you need to
use for any particular situation.

00:54:02.320 --> 00:54:05.000
Finally,
we have the slide you've seen many times,

00:54:05.050 --> 00:54:05.640
documentation.

00:54:05.640 --> 00:54:07.280
There's release notes.

00:54:07.290 --> 00:54:09.800
You should always look to see, of course,
when those bug fixes were put in,

00:54:09.800 --> 00:54:16.450
what potentially what behaviors changed,
overview documentation,

00:54:16.450 --> 00:54:18.770
so on and so forth.

00:54:19.990 --> 00:54:21.940
and others.

00:54:21.960 --> 00:54:24.940
Example code, again,
you've probably seen this many times,

00:54:24.940 --> 00:54:26.930
I'm just going to flip through.

00:54:27.130 --> 00:54:29.450
The roadmap,
well basically you've missed it

00:54:29.450 --> 00:54:31.530
all except the feedback form.

00:54:31.790 --> 00:54:34.220
However, you've got the DVDs.

00:54:34.450 --> 00:54:36.880
If you haven't seen the
Cocoa Review Talk and

00:54:36.960 --> 00:54:38.520
you're new to Cocoa,
you should check that out.

00:54:38.600 --> 00:54:40.960
The Using Cocoa Talk,
those of you who weren't here the

00:54:40.960 --> 00:54:42.510
previous hour really missed out.

00:54:42.510 --> 00:54:44.170
It's full of lots of great demos.

00:54:44.180 --> 00:54:47.260
And the feedback form,
so if you have anything to say,

00:54:47.270 --> 00:54:48.830
come to that tomorrow.

00:54:50.800 --> 00:54:53.760
Finally,
Heather is always your person to contact.

00:54:53.760 --> 00:54:56.540
We have a feedback address if
you have comments or suggestions.

00:54:56.540 --> 00:55:01.540
And I'd highly recommend subscribing
to Apple's new Cocoa Development List.
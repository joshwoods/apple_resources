WEBVTT

00:00:05.900 --> 00:00:09.000
Good afternoon and welcome
to the USB Overview session.

00:00:09.090 --> 00:00:10.140
I'm Craig Keithley.

00:00:10.140 --> 00:00:12.560
I'm the USB and FireWire
Technology Manager within

00:00:12.560 --> 00:00:15.900
Apple's Worldwide
Developer Relations organization.

00:00:15.900 --> 00:00:17.900
And I'm pleased to see you here today.

00:00:18.080 --> 00:00:21.900
This session will cover some of
the basics of USB on Mac OS X.

00:00:21.900 --> 00:00:24.860
Before I bring up the engineers to
have them do their presentation,

00:00:24.940 --> 00:00:29.680
I want to talk a little bit about the
things that we like about USB in X and

00:00:29.680 --> 00:00:33.160
in general with our Digital Hub strategy.

00:00:33.800 --> 00:00:38.210
One of those things is the nature
of powering devices over USB.

00:00:38.210 --> 00:00:40.770
More importantly than powering devices,
recharging devices.

00:00:40.840 --> 00:00:43.420
So I brought with me here today

00:00:43.780 --> 00:00:47.700
A new cable,
this is a USB adapter cable for a Palm 5,

00:00:47.820 --> 00:00:50.690
has a sync button in it,
and it charges the Palm 5.

00:00:50.700 --> 00:00:54.040
You think about our iBook
commercial we're running where the

00:00:54.250 --> 00:00:57.190
gentleman's sitting in the middle
seat and he's playing with all

00:00:57.250 --> 00:00:59.070
his neat devices at 35,000 feet.

00:00:59.080 --> 00:01:03.130
It wouldn't be too cool if all
those devices required a power

00:01:03.230 --> 00:01:07.760
strip on the floor of the plane
with a 110-volt to 12-volt

00:01:07.880 --> 00:01:10.670
converter to run all those devices.

00:01:11.060 --> 00:01:14.570
So we really want you to look very
carefully at powering your devices

00:01:14.970 --> 00:01:17.240
over USB and charging them over USB.

00:01:18.670 --> 00:01:21.650
Some devices that are good about
this are things like the Zip Drive,

00:01:21.750 --> 00:01:23.360
some of the floppy drives.

00:01:23.360 --> 00:01:25.100
They receive power over the USB bus.

00:01:25.100 --> 00:01:27.730
They operate without the
need for an AC adapter.

00:01:27.770 --> 00:01:29.540
This is a great way to go.

00:01:29.610 --> 00:01:32.600
And if you can charge them,
that would be even better.

00:01:32.760 --> 00:01:35.600
Now as you know, we've been doing USB for
about four years now.

00:01:35.600 --> 00:01:37.600
We've got a lot of experience in it.

00:01:37.600 --> 00:01:40.560
We've got some of the best engineers in
the business working on USB for Mac OS X.

00:01:40.630 --> 00:01:42.600
We've made great progress.

00:01:42.600 --> 00:01:45.590
We know we have more
distance to go on this.

00:01:45.610 --> 00:01:48.610
So I want to leave you with a
couple of thoughts with regard to

00:01:48.610 --> 00:01:50.600
helping us move forward on USB on X.

00:01:50.600 --> 00:01:53.590
The first one is,
please use the bug reporting system.

00:01:53.590 --> 00:01:57.310
We do look at those bug
reports very seriously.

00:01:57.580 --> 00:01:59.590
Don't assume that we've
seen a bug report.

00:01:59.600 --> 00:02:02.020
Don't assume that if
it's happening to you,

00:02:02.020 --> 00:02:04.600
we must have seen it and
we must be fixing it.

00:02:04.600 --> 00:02:05.590
We want to have those in the database.

00:02:05.590 --> 00:02:07.600
We want to be working on them.

00:02:07.600 --> 00:02:08.570
We want to know about them.

00:02:08.600 --> 00:02:14.060
The other thought that I would share
with you is that we are working very

00:02:14.330 --> 00:02:16.050
aggressively on providing updates.

00:02:16.050 --> 00:02:18.820
You've watched us produce three
updates in the last 58 days.

00:02:18.940 --> 00:02:20.600
We will be doing more.

00:02:20.600 --> 00:02:23.890
So if you get your bug reports in,
there's a very good chance we'll

00:02:23.890 --> 00:02:25.600
be able to move forward on them.

00:02:25.690 --> 00:02:28.600
So with that, I'd like to bring up
Rhodes Hollowell and Dave Ferguson.

00:02:28.600 --> 00:02:33.600
Dave is the software engineering
manager for USB development on Mac OS X.

00:02:33.600 --> 00:02:36.590
And Rhodes Hollowell is our lead
engineer on USB development.

00:02:36.610 --> 00:02:38.590
Thanks very much.

00:02:42.960 --> 00:02:44.690
Good morning.

00:02:44.690 --> 00:02:46.960
Thank you, Craig.

00:02:47.060 --> 00:02:50.380
Well,
what we're going to talk about today

00:02:53.670 --> 00:02:58.010
So what you're going to learn in this
session is we're going to go over the

00:02:58.170 --> 00:03:02.940
USB hardware architecture as delivered
in Macintosh models that we ship today.

00:03:02.950 --> 00:03:06.810
I'll talk a little bit about
where the different ports go,

00:03:06.890 --> 00:03:09.640
numbers of controllers,
compatibility with different controllers,

00:03:09.720 --> 00:03:11.420
that sort of stuff.

00:03:11.440 --> 00:03:16.050
We'll talk about the driver
architecture in Mac OS X,

00:03:16.130 --> 00:03:19.640
specifically how it fits in
with I/O Kit and how that

00:03:19.790 --> 00:03:21.920
family fits with other families.

00:03:21.950 --> 00:03:26.820
We will talk about converting
your Mac OS 9 drivers into 10.

00:03:26.960 --> 00:03:31.420
So obviously you have a lot of experience
developing Mac OS 9 USB drivers.

00:03:31.430 --> 00:03:34.260
We have a lot of devices
and a lot of drivers.

00:03:34.470 --> 00:03:37.580
And so I know that people have
things and they want to get

00:03:37.650 --> 00:03:39.100
them converted over to OS X.

00:03:39.100 --> 00:03:43.490
And so what's the same, what's different,
what do you need to do to get started?

00:03:43.550 --> 00:03:46.050
In doing that,
we'll detail a little bit of

00:03:46.110 --> 00:03:49.640
the differences between kernel
mode and user mode drivers.

00:03:49.690 --> 00:03:51.910
And we'll talk about what happens today.

00:03:51.920 --> 00:03:56.700
When you have classic and you have
support for existing USB drivers,

00:03:56.890 --> 00:03:59.290
which USB devices can
be operated in classic?

00:03:59.420 --> 00:04:00.510
How do they work?

00:04:00.860 --> 00:04:04.590
How does classic and native
OS X drivers work together?

00:04:04.770 --> 00:04:09.280
And finally, we'll do a quick review
of Apple's class drivers,

00:04:09.500 --> 00:04:12.680
the drivers that we deliver so
you can deliver USB products

00:04:12.680 --> 00:04:16.020
that don't have any software
component at all that you need to,

00:04:16.100 --> 00:04:17.290
that a user needs to install.

00:04:17.530 --> 00:04:19.670
Just drivers that we bring.

00:04:20.920 --> 00:04:24.930
So,
universal serial bus hardware has been

00:04:25.230 --> 00:04:31.780
included in every Macintosh model since
we introduced the iMac in August of '98.

00:04:31.800 --> 00:04:39.800
Today, every single machine that we ship
has two independent USB buses.

00:04:39.800 --> 00:04:45.730
Both of those are OHCI,
open host controller

00:04:45.870 --> 00:04:47.560
interface compatible.

00:04:47.800 --> 00:04:50.800
Our software is compatible
with OHCI controllers,

00:04:50.800 --> 00:04:54.910
so in fact, in addition to the two
buses that we are supplying,

00:04:54.910 --> 00:05:00.170
it's also possible to install
PCI cards or Cardbus cards that

00:05:00.170 --> 00:05:02.800
have OHCI compliant controllers.

00:05:02.940 --> 00:05:07.800
And our software will detect those
cards and support the USB bus on that.

00:05:09.210 --> 00:05:14.090
Now, other USB hardware that we have
included with every machine

00:05:15.200 --> 00:05:22.040
In addition to the two independent buses,
we are also including hubs in both

00:05:22.070 --> 00:05:24.600
our monitors as well as the keyboards.

00:05:24.710 --> 00:05:28.240
Now, the hubs that are in the monitors
are all self-powered hubs.

00:05:28.340 --> 00:05:31.960
They provide more high-power ports,
just like the ports on

00:05:31.960 --> 00:05:33.300
the back of a machine.

00:05:33.430 --> 00:05:37.610
And the hubs that are in the
keyboards are bus-powered hubs,

00:05:37.920 --> 00:05:41.840
so they can only supply the 100
milliamps of power and are useful

00:05:41.850 --> 00:05:46.100
for some bus-powered devices,
usually other self-powered devices

00:05:46.100 --> 00:05:49.200
that it's just more convenient to
plug them in right on the keyboard.

00:05:49.310 --> 00:05:52.240
So controllers,
mice and stuff attached to a keyboard,

00:05:52.390 --> 00:05:55.530
other high-powered devices,
we've made it convenient to put ports

00:05:55.940 --> 00:05:59.380
on the back or on the sides of monitors.

00:06:02.230 --> 00:06:08.080
So let's talk about how the
I/O USB family in Mac OS X fits into

00:06:08.430 --> 00:06:11.040
the I/O Kit family architecture.

00:06:11.040 --> 00:06:14.930
This slide shows basically
I/O Kit as a large field with

00:06:15.210 --> 00:06:17.540
a whole series of families.

00:06:17.540 --> 00:06:20.930
We've denoted some of these families
with different colors indicating

00:06:20.930 --> 00:06:23.620
the type of family they are.

00:06:23.620 --> 00:06:30.060
The I/O USB family is one of these on
the left which is a transport family.

00:06:30.100 --> 00:06:33.180
It's one that actually transports
data over some type of bus.

00:06:33.350 --> 00:06:38.630
So I/O USB family, Firewire family,
SCSI family are all capable of

00:06:38.630 --> 00:06:41.640
transporting data over a specific bus.

00:06:41.640 --> 00:06:45.390
Things such as the I/O Serial family,
the SCSI architecture family,

00:06:45.390 --> 00:06:48.910
the audio family don't necessarily
have a specific hardware

00:06:48.990 --> 00:06:50.760
component associated with them.

00:06:50.760 --> 00:06:55.150
They're responsible more for managing
and converting data to transport over

00:06:55.230 --> 00:06:58.070
some other family's transport mechanism.

00:06:58.090 --> 00:07:00.080
I/O Kit includes a lot more
families than the I/O Kit.

00:07:00.080 --> 00:07:01.060
The I/O Kit includes a lot
more families than this.

00:07:01.130 --> 00:07:04.040
I'm just trying to give you a
sense of where USB fits into

00:07:04.040 --> 00:07:07.180
that family architecture.

00:07:08.990 --> 00:07:12.540
Okay, thank you Dave.

00:07:12.680 --> 00:07:15.900
So we're going to talk a little bit
about the I/O kernel driver stack.

00:07:15.900 --> 00:07:20.520
What happens when the system
detects that USB is present?

00:07:20.630 --> 00:07:25.050
So at the very early stage of
USB initialization there is an

00:07:25.050 --> 00:07:29.760
I/O PCI device that the system detects
and the PCI family is responsible

00:07:29.970 --> 00:07:36.200
for detecting this device and that
device is the USB controller chip.

00:07:36.240 --> 00:07:40.480
The USB driver is then matched
against that controller

00:07:40.480 --> 00:07:43.990
chip and the name of that,
the class of that driver

00:07:44.030 --> 00:07:46.680
is I/O USB controller.

00:07:46.710 --> 00:07:52.160
Now this driver then initializes
the USB controller chip and and

00:07:52.160 --> 00:07:55.980
instantiates an I/O USB device.

00:07:56.010 --> 00:07:59.010
This device represents the root hub.

00:07:59.230 --> 00:08:01.100
Inside the controller chip.

00:08:01.100 --> 00:08:07.100
So that USB PCI device is then matched
by I/O Kit and it loads another driver.

00:08:07.210 --> 00:08:10.050
And the name of that driver
is the Apple USB hub driver.

00:08:10.050 --> 00:08:12.680
So this driver loads against
any hub in the system,

00:08:12.800 --> 00:08:13.870
including the root hub.

00:08:14.330 --> 00:08:17.930
But in the case of the early
initialization of the root hub,

00:08:17.930 --> 00:08:21.040
it then scans the bus
looking for USB devices.

00:08:21.080 --> 00:08:26.100
So let's say we have a pair of
speakers plugged into this bus.

00:08:26.100 --> 00:08:32.840
Well, the I/O USB controller can have
more than one child or client

00:08:33.380 --> 00:08:35.800
that it is a provider for.

00:08:36.140 --> 00:08:40.170
And so it instantiates
another kernel object,

00:08:40.300 --> 00:08:45.120
C++ kernel object, the in I/O Kit called,
that is an I/O USB device

00:08:45.190 --> 00:08:46.970
representing these speakers.

00:08:47.100 --> 00:08:52.420
There is a driver inside the system
that matches against this device

00:08:52.510 --> 00:08:55.100
because it's a composite device.

00:08:55.100 --> 00:08:56.100
And that driver is then used to connect
the USB device to the I/O USB hub.

00:08:56.100 --> 00:08:58.990
And that driver sets the
configuration inside the device,

00:08:58.990 --> 00:09:01.100
which causes the interfaces to appear.

00:09:01.100 --> 00:09:06.060
So one of these interfaces is the
audio channel for these speakers.

00:09:06.150 --> 00:09:12.030
And so this I/O USB interface appears and
I/O Kit then matches a driver against it.

00:09:12.330 --> 00:09:16.100
And in this case, that driver is the
Apple USB audio driver.

00:09:16.100 --> 00:09:22.090
So this is just a quick overview of
the stack of the I/O Kit objects.

00:09:22.110 --> 00:09:25.100
We will go into some more detail today.

00:09:25.100 --> 00:09:28.000
and we will go into even
more detail on this tomorrow.

00:09:30.210 --> 00:09:36.090
Now, USB drivers are not
members of the USB family.

00:09:36.210 --> 00:09:40.680
They use the USB family for
their transport mechanism,

00:09:40.680 --> 00:09:43.850
and so they are clients
of the USB family,

00:09:43.910 --> 00:09:46.730
or in other words,
the USB family objects are the

00:09:46.910 --> 00:09:48.940
providers for these drivers.

00:09:49.100 --> 00:09:53.430
So here, for example,
is that same audio driver,

00:09:53.430 --> 00:09:58.060
and its provider is an
I/O USB interface object,

00:09:58.160 --> 00:10:04.370
but the driver is itself subclassed
from the I/O Audio Device class,

00:10:05.100 --> 00:10:09.970
which is a subclass of I/O Service,
I/O Service being the base

00:10:10.100 --> 00:10:13.910
class for all I/O Kit objects,
and so this driver is a

00:10:13.910 --> 00:10:16.490
member of the audio family.

00:10:16.920 --> 00:10:20.890
and in turn this driver may
have its own clients for what

00:10:21.040 --> 00:10:23.420
to do with this audio stream.

00:10:23.420 --> 00:10:28.420
Another example would be
the HID interface which then

00:10:28.420 --> 00:10:31.850
loads the HID driver which is
a member of the HID family.

00:10:31.900 --> 00:10:37.050
We represent this with these puzzle
pieces because there can be a different

00:10:37.160 --> 00:10:43.200
HID driver that is a subclass of the
I/O HID device class which uses a

00:10:43.200 --> 00:10:47.680
different transport mechanism than USB.

00:10:48.940 --> 00:10:54.440
Now, how does the API for
USB in Mac OS X compare

00:10:54.530 --> 00:10:58.010
with the API in Mac OS 9?

00:10:58.410 --> 00:11:02.590
Well,
many of the function names are similar,

00:11:02.590 --> 00:11:08.670
but in fact the API is vastly
different in the respect that in 9

00:11:08.670 --> 00:11:17.120
you have a parameter block interface,
whereas in 10 you have a series

00:11:17.120 --> 00:11:19.030
of C++ methods that you call

00:11:19.340 --> 00:11:20.740
you know, with C++.

00:11:20.890 --> 00:11:28.800
So, and also, in 10 -- in 9,
all calls to the API are

00:11:28.800 --> 00:11:30.060
asynchronous calls.

00:11:30.060 --> 00:11:34.220
You must provide a callback routine,
and everything happens asynchronously.

00:11:34.220 --> 00:11:40.630
In 10, there is a capability for making
synchronous calls to the usb stack.

00:11:40.630 --> 00:11:45.460
However, you must be careful about
making these synchronous calls,

00:11:45.460 --> 00:11:48.820
because it is -- there is a
potential to deadlock the system.

00:11:49.260 --> 00:11:52.860
Finally, in 9,
everything is -- all memory buffers are

00:11:52.910 --> 00:11:58.050
passed as held and locked memory buffers,
whereas in 10,

00:11:58.080 --> 00:12:02.430
it's possible to pass buffers
using an I/O Kit object class

00:12:02.590 --> 00:12:04.530
called I/O memory descriptor,
which we will get into

00:12:04.590 --> 00:12:05.700
in a little more detail.

00:12:07.530 --> 00:12:11.820
Now in the kernel,
the USB family provides three

00:12:12.210 --> 00:12:20.390
basic object classes that represent
the contents of a USB device.

00:12:20.390 --> 00:12:26.060
These three classes are I/O USB device,
which is an encapsulation, if you will,

00:12:26.060 --> 00:12:31.400
of the device descriptor
inside the physical device.

00:12:31.420 --> 00:12:33.390
Then there's the I/O USB interface class.

00:12:33.390 --> 00:12:38.600
This is an encapsulation of the
interface descriptor within a

00:12:38.830 --> 00:12:42.390
particular configuration of the device.

00:12:42.390 --> 00:12:47.510
So if a configuration has three
interface descriptors within it,

00:12:47.590 --> 00:12:53.190
there will be three I/O USB interface
objects which are created to represent

00:12:53.190 --> 00:12:55.400
those three interface descriptors.

00:12:55.400 --> 00:12:59.120
Finally, there's the I/O USB pipe object.

00:12:59.120 --> 00:13:05.260
This object encapsulates the contents
of an endpoint within an interface

00:13:05.260 --> 00:13:12.550
descriptor and it also provides the
channel between the client software

00:13:12.570 --> 00:13:16.000
and the endpoint on the device.

00:13:18.360 --> 00:13:21.630
From user space,
because Apple recommends that

00:13:21.810 --> 00:13:25.430
you write your drivers in
user space if at all possible,

00:13:25.430 --> 00:13:30.820
we provide access to these same objects,
but we do them using the

00:13:30.820 --> 00:13:33.430
I/O CF plug-in model.

00:13:33.610 --> 00:13:37.940
That is part of I/O Kit and
we have two plug-in types

00:13:38.070 --> 00:13:40.160
that we provide in user space.

00:13:40.160 --> 00:13:45.860
The I/O USB device interface and
the I/O USB interface interface.

00:13:45.860 --> 00:13:48.930
Now these names can become a mouthful.

00:13:48.940 --> 00:13:54.760
The I/O Kit team decided to call
these plug-ins device interfaces.

00:13:54.790 --> 00:13:58.440
And of course in USB there is already
the concept of a device as in a

00:13:58.440 --> 00:14:02.600
device descriptor and an interface
as in an interface descriptor.

00:14:02.600 --> 00:14:05.600
And so we actually had
device-device interfaces and

00:14:05.700 --> 00:14:09.600
interface-device interfaces and
that got to be a little much.

00:14:09.600 --> 00:14:13.870
So we called them the
I/O USB device interface and

00:14:13.870 --> 00:14:17.110
the I/O USB interface interface.

00:14:18.250 --> 00:14:19.850
How do the memory buffers compare?

00:14:20.020 --> 00:14:26.070
Well, as I said before, in Mac OS 9,
when you passed a memory buffer to USB,

00:14:26.110 --> 00:14:31.830
because it needed to use DMA to
transfer the actual data,

00:14:31.950 --> 00:14:34.880
you would have to lock the
memory and make sure that it was

00:14:34.880 --> 00:14:37.880
physically held and resident and
pass a pointer to this memory.

00:14:38.100 --> 00:14:41.760
In Mac OS X,
this is handled with a concept

00:14:41.840 --> 00:14:44.720
called an I/O memory descriptor.

00:14:45.160 --> 00:14:49.490
I/O memory descriptors are more flexible
than just straight memory buffers

00:14:49.860 --> 00:14:54.100
because they can provide access to memory
that is not necessarily contiguous.

00:14:54.100 --> 00:14:56.750
A piece of the memory can be over here,
and then the next piece of

00:14:56.760 --> 00:14:58.890
the memory can be over here,
and then another piece

00:14:58.900 --> 00:15:00.100
can be somewhere else.

00:15:00.100 --> 00:15:03.100
And the memory descriptor
can describe that,

00:15:03.170 --> 00:15:07.960
and then the USB engine can then
transfer the data into disk drive.

00:15:08.120 --> 00:15:10.100
So, these are all joint buffers.

00:15:10.400 --> 00:15:16.100
Also, if you are accessing,
passing the memory in from user space,

00:15:16.100 --> 00:15:20.500
the memory does not necessarily
need to be wired into the kernel

00:15:20.500 --> 00:15:23.010
address space in order to be used.

00:15:23.100 --> 00:15:27.060
These memory descriptors can
describe memory that is inaccessible

00:15:27.440 --> 00:15:31.980
from the kernel directly,
but is accessible using DMA.

00:15:32.100 --> 00:15:36.610
And this is a benefit because
wiring memory into kernel address

00:15:36.610 --> 00:15:38.100
space is a very accessible process.

00:15:38.160 --> 00:15:41.420
It is a very expensive operation,
and one that we hope

00:15:41.420 --> 00:15:43.010
to avoid at all costs.

00:15:45.160 --> 00:15:51.100
Now, user mode code that accesses
USB does in fact pass these

00:15:51.130 --> 00:15:57.040
buffers as straight memory buffers,
just pointers,

00:15:57.040 --> 00:16:01.050
but within the kernel the memory
descriptors are used to manipulate

00:16:01.180 --> 00:16:05.890
them and to get the physical
address for the DMA engine.

00:16:09.350 --> 00:16:13.940
As I said before,
with OS X it's possible to use

00:16:13.980 --> 00:16:19.380
synchronous I/O as opposed to having
every call in the API be asynchronous.

00:16:19.430 --> 00:16:22.420
This means that you can make
a call that will block your

00:16:22.420 --> 00:16:26.380
thread until the call completes.

00:16:27.860 --> 00:16:32.100
If you are writing a user land driver,
this is something that

00:16:32.100 --> 00:16:33.660
is always safe to do.

00:16:33.880 --> 00:16:36.790
You make a synchronous call,
your thread blocks,

00:16:36.790 --> 00:16:40.620
and when the call completes,
your thread picks up again.

00:16:40.830 --> 00:16:45.320
If you are running a kernel mode driver,
you must be careful that this synchronous

00:16:45.520 --> 00:16:47.700
call does not deadlock your thread.

00:16:48.080 --> 00:17:00.340
And there are specific guidelines to help
do that and we're learning more about

00:17:00.340 --> 00:17:00.340
how to document that as we go along.

00:17:00.790 --> 00:17:05.940
If you do make asynchronous calls,
then there's two methods for

00:17:06.060 --> 00:17:10.820
continuing the processing once
your callback routine is called.

00:17:11.220 --> 00:17:14.190
Within the kernel,
your callback routine will be called

00:17:14.190 --> 00:17:19.460
immediately upon the completion of
the routine and your execution thread

00:17:19.460 --> 00:17:24.900
will in fact pick up at your callback
routine once the processing is done.

00:17:25.010 --> 00:17:26.710
It's slightly different in user mode.

00:17:27.160 --> 00:17:32.950
There is no mechanism with Mac OS X and
with I/O Kit to make direct callbacks

00:17:33.640 --> 00:17:38.900
from kernel run threads to user threads.

00:17:39.180 --> 00:17:44.900
And so what happens is a Mach message
is posted on a port from the kernel side

00:17:44.900 --> 00:17:51.830
and then there's a user thread that will
check that port using the CF run loop

00:17:52.040 --> 00:17:54.900
technology for that callback message.

00:17:54.900 --> 00:18:00.400
And at that point dispatch
the callback routine.

00:18:01.860 --> 00:18:06.100
So how do drivers get matched
and loaded with Mac OS X?

00:18:06.100 --> 00:18:09.140
Well the first thing that happens
is when a device is plugged in,

00:18:09.180 --> 00:18:12.280
the hub driver that is controlling
the hub to which that device

00:18:12.280 --> 00:18:16.420
is attached notices the port,
turns it on,

00:18:16.420 --> 00:18:22.570
does typical USB enumeration things,
and creates the I/O USB device

00:18:22.840 --> 00:18:26.950
based on the information it
finds in the device descriptor.

00:18:27.310 --> 00:18:33.180
It then tells I/O Kit,
I have this new device,

00:18:33.730 --> 00:18:35.830
please find a driver for it.

00:18:35.960 --> 00:18:40.050
So first,
I/O Kit looks through its entire

00:18:40.050 --> 00:18:46.550
table of drivers that it knows
about and it creates a pool

00:18:46.550 --> 00:18:52.150
of drivers that are capable of
driving an I/O USB device object.

00:18:52.140 --> 00:19:00.000
It then passes the information from
the I/O USB device object into the

00:19:00.150 --> 00:19:05.640
USB family with the information
from the driver and it says,

00:19:05.640 --> 00:19:11.650
"Tell me what you think about this
driver running with this device."

00:19:11.750 --> 00:19:17.400
And the USB family does a scoring
system where the different drivers are

00:19:17.400 --> 00:19:24.350
scored based on the criteria specified
by the USB common class specification.

00:19:24.570 --> 00:19:30.330
This creates a ranked list and then
the I/O Kit goes through the drivers

00:19:30.330 --> 00:19:35.380
and can call the probe method such
that any driver in the list can say,

00:19:35.440 --> 00:19:38.640
no, I'm not interested in
controlling that device.

00:19:38.780 --> 00:19:44.240
So this is a three level matching
system and at the end there is an

00:19:44.240 --> 00:19:46.940
ordered list of drivers with a ranking.

00:19:47.000 --> 00:19:51.120
The I/O Kit then takes the top
driver in that ranking and says,

00:19:51.120 --> 00:19:52.840
okay, it's your device.

00:19:52.890 --> 00:19:55.180
And as long as that driver
comes back and says,

00:19:55.180 --> 00:19:57.690
I got it, it's mine, then that's it.

00:19:57.910 --> 00:20:00.240
If the driver comes back and says, oh,
no, I changed my mind,

00:20:00.240 --> 00:20:02.140
I'm not interested in
that device anymore,

00:20:02.190 --> 00:20:05.260
then the next driver
in the list is tried.

00:20:06.580 --> 00:20:10.100
So what happens when a driver,
when a USB device is removed?

00:20:10.100 --> 00:20:10.820
You unplug it.

00:20:10.910 --> 00:20:14.680
Well, the hub driver again notices
that the device has gone away,

00:20:14.680 --> 00:20:20.480
and it issues a terminate message
to the IO USB device object,

00:20:20.790 --> 00:20:25.900
which in turn sends a message
to each of its children,

00:20:25.900 --> 00:20:30.100
including a driver and potentially
any IO USB interface objects,

00:20:30.100 --> 00:20:34.360
which in turn send messages to
their children and so forth,

00:20:34.630 --> 00:20:38.480
so that the leaf node of
the tree gets notified,

00:20:38.480 --> 00:20:40.100
hey, it's time to go away.

00:20:40.100 --> 00:20:43.870
It cleans up,
and then that propagates back up,

00:20:43.880 --> 00:20:48.340
so that eventually the IO USB device
object cleans up and goes away.

00:20:49.750 --> 00:20:52.770
So if your driver is the
leaf node in this process,

00:20:53.050 --> 00:20:56.400
you get a message saying, hey,
it's time for you to stop

00:20:56.410 --> 00:20:59.870
doing any I/O because your
parent is about to go away.

00:21:00.510 --> 00:21:07.400
The driver then says, OK,
closes the parent,

00:21:07.540 --> 00:21:10.520
terminates its state machine,
and I/O Kit removes

00:21:10.520 --> 00:21:10.520
the driver from memory.

00:21:15.320 --> 00:21:21.300
So how do drivers, if you will,
work from user space?

00:21:21.330 --> 00:21:24.520
Apple, again,
recommends that you write your

00:21:24.520 --> 00:21:27.860
USB driver code to work in user space.

00:21:27.940 --> 00:21:32.300
However, you have to be aware
that user space drivers,

00:21:32.300 --> 00:21:34.520
which are really just

00:21:34.700 --> 00:21:40.990
Threads that run in user space and
are typically packaged as libraries,

00:21:40.990 --> 00:21:48.200
but in one sense they function just like
applications in that the matching has to,

00:21:48.260 --> 00:21:52.820
you know, they have to,
there's no automatic matching for them.

00:21:52.840 --> 00:21:56.230
So these drivers do not compete
with the kernel drivers,

00:21:56.230 --> 00:22:00.350
so if there is a user space driver
for a particular device and a kernel

00:22:00.350 --> 00:22:04.270
mode driver for a particular device,
the kernel mode driver ends up winning

00:22:04.270 --> 00:22:06.840
the race and controlling the device.

00:22:07.290 --> 00:22:13.030
User space drivers can
have code that's running,

00:22:13.030 --> 00:22:18.930
daemon code, for example,
that gets notified by I/O Kit whenever

00:22:19.120 --> 00:22:22.840
a new USB device appears in the system.

00:22:22.900 --> 00:22:26.050
However, once again,
this notification doesn't happen

00:22:26.160 --> 00:22:29.840
until after the kernel drivers get
a chance to control the device.

00:22:29.840 --> 00:22:30.840
And so, some of the things that
we've seen in the past,

00:22:30.840 --> 00:22:30.840
and I'm not going to go into
too much detail about this,

00:22:30.840 --> 00:22:30.840
but I'm going to go into a little
bit more detail about this,

00:22:30.840 --> 00:22:30.840
is that the kernel mode drivers
are not the only drivers

00:22:30.840 --> 00:22:30.840
that are running the device.

00:22:30.880 --> 00:22:31.840
The kernel mode drivers are not the only
drivers that are running the device.

00:22:31.840 --> 00:22:38.840
Sometimes it may be necessary to create
a dummy driver in the kernel which claims

00:22:38.840 --> 00:22:46.590
the device so that then later on some
user land code can take over that device.

00:22:48.840 --> 00:22:53.670
So if you are running in user code,
how do you find the device

00:22:53.670 --> 00:22:55.580
you're interested in?

00:22:55.690 --> 00:22:59.760
Well,
there are some I/O Kit service calls

00:22:59.860 --> 00:23:03.260
that you use to find your device.

00:23:03.440 --> 00:23:07.890
The first one,
here are some I/O Kit calls.

00:23:08.010 --> 00:23:12.030
The first one, I/O Service Matching,
says I want to create a matching

00:23:12.030 --> 00:23:18.830
dictionary that looks for any device in
the kernel whose type is I/O USB device.

00:23:19.500 --> 00:23:24.790
Then it calls I/O Service Git matching
services and it passes in this matching

00:23:24.790 --> 00:23:29.810
dictionary and I/O Kit returns an
iterator of all the devices that

00:23:29.810 --> 00:23:32.940
it found that match that criteria.

00:23:33.090 --> 00:23:36.000
Finally,
the user code can create a while loop

00:23:36.070 --> 00:23:40.330
that looks through all the devices
of this iterator and decide which

00:23:40.330 --> 00:23:44.990
ones it is interested in controlling,
if any.

00:23:47.590 --> 00:23:49.860
So how do we share a device?

00:23:49.860 --> 00:23:53.500
Well, Dave's going to talk about this.

00:23:53.590 --> 00:23:57.730
So let's talk a little bit
about device sharing now.

00:23:57.940 --> 00:24:03.560
The I/O Kit model for using a
particular object down in the kernel,

00:24:03.560 --> 00:24:07.240
whether it's a USB interface
or a USB device object,

00:24:07.240 --> 00:24:09.550
is that it's exclusive access.

00:24:09.720 --> 00:24:14.830
Only one thing can be accessing
that particular object at a time.

00:24:14.960 --> 00:24:19.850
The I/O USB family enforces
that by allowing only one

00:24:19.850 --> 00:24:22.900
entity to open that at a time.

00:24:22.900 --> 00:24:28.490
However, there are methods and mechanisms
by which tasks or threads can

00:24:28.490 --> 00:24:30.900
cooperatively share a device.

00:24:30.900 --> 00:24:33.290
And as we're all starting
to develop drivers and we're

00:24:33.290 --> 00:24:36.900
getting more user mode drivers,
people are interested in how we do that.

00:24:36.900 --> 00:24:38.780
And I want to talk a
little bit about that.

00:24:38.900 --> 00:24:44.800
The key is a message method
that your driver provides,

00:24:44.890 --> 00:24:47.900
whether it's a user mode
driver or a kernel mode driver.

00:24:48.020 --> 00:24:50.880
And there are two specific
messages that are passed.

00:24:50.910 --> 00:24:55.900
One is... . And this happens when
you have a particular device open.

00:24:55.910 --> 00:25:00.170
One is a message that says,
"I/O message service is requesting

00:25:00.260 --> 00:25:05.040
close." So this says that another entity
is attempting to open this device,

00:25:05.040 --> 00:25:09.900
and it's requesting that the entity that
currently has it open please close down.

00:25:09.900 --> 00:25:13.900
Now,
you don't have to close down at that.

00:25:13.900 --> 00:25:16.900
You can know that you have
I/O active at the time,

00:25:16.900 --> 00:25:17.870
and you don't want to do that.

00:25:17.930 --> 00:25:21.900
But if you are merely
keeping the device open,

00:25:21.900 --> 00:25:23.630
let's say in the middle of the night,
let's say in the example

00:25:23.630 --> 00:25:26.900
that it's a modem and you're
waiting for a call to come in,

00:25:26.900 --> 00:25:28.440
well,
the driver that's waiting for a call

00:25:28.560 --> 00:25:31.900
to come in can go ahead and close
up because a call hasn't come in,

00:25:31.900 --> 00:25:34.900
and another entity would like to
use it to make an outgoing call.

00:25:34.900 --> 00:25:40.440
So you can close that,
and you can get notifications whenever

00:25:40.570 --> 00:25:46.730
someone else closes a particular object,
a USB device or a USB interface object.

00:25:46.900 --> 00:25:51.650
The other message that can come in while
you have the object open is the "I/O

00:25:51.790 --> 00:25:57.130
message service is attempting open."
So this is where you can find out that

00:25:57.130 --> 00:26:00.870
another entity is trying to open you,
but he has not requested

00:26:01.000 --> 00:26:01.900
that you close down.

00:26:01.900 --> 00:26:04.900
He's not requested to grab the interface.

00:26:04.900 --> 00:26:07.860
He's just tried to open it
to see if it's available.

00:26:07.900 --> 00:26:11.840
In general,
a shared device would want to close down

00:26:11.940 --> 00:26:14.900
in that particular circumstance as well.

00:26:14.900 --> 00:26:19.900
So requesting close is kind of a
more urgent request to close down,

00:26:19.910 --> 00:26:24.900
attempting open is your clue that someone
else would like to access that device,

00:26:24.900 --> 00:26:26.860
and you should close
it if at all possible.

00:26:26.900 --> 00:26:34.930
Now, this sharing mechanism is really
how we intend for user mode control

00:26:35.100 --> 00:26:38.900
panels that want to set particular
states in a device might get to that,

00:26:38.900 --> 00:26:43.840
even though a kernel mode driver provides
most of the transport with the device.

00:26:43.960 --> 00:26:48.830
The user mode driver would
attempt to open that thing,

00:26:48.900 --> 00:26:52.900
that object,
and would do it with the claim flag,

00:26:52.930 --> 00:26:54.900
we're working on the
API to get that set up,

00:26:55.140 --> 00:26:58.780
that generates this "Services
requesting close" message,

00:26:58.980 --> 00:27:00.900
and that's how a driver knows.

00:27:00.900 --> 00:27:05.800
Now, this device sharing model also
works with USB in Classic.

00:27:05.910 --> 00:27:10.360
Classic is nothing more than
a particular application that

00:27:10.360 --> 00:27:15.860
is being a user mode driver,
okay, for one particular USB device

00:27:15.910 --> 00:27:17.900
object down in the kernel.

00:27:19.270 --> 00:27:22.100
Let's talk about the
Classic side for a moment,

00:27:22.110 --> 00:27:26.110
and then we'll talk about
how Classic uses Mac OS X.

00:27:27.980 --> 00:27:34.900
Classic presents the entire Mac OS 9.1
operating system to applications.

00:27:34.930 --> 00:27:38.690
That includes things like USB driver.

00:27:38.890 --> 00:27:44.900
Our entire Mac OS 9 USB stack is
living within the Classic environment.

00:27:44.990 --> 00:27:48.800
If you have an existing Classic driver
for a vendor-specific device,

00:27:49.300 --> 00:27:56.810
Classic can open that device object using
the user mode mechanism and can make

00:27:56.920 --> 00:28:01.920
that device available just as though
it were plugged into an OHCI controller

00:28:02.070 --> 00:28:04.900
directly attached to Classic.

00:28:04.970 --> 00:28:08.540
And the USB stack will do all
of the exact same enumeration,

00:28:08.540 --> 00:28:11.700
discover a device,
load a Classic driver exactly

00:28:11.710 --> 00:28:13.900
the same way it does in Mac OS 9.

00:28:13.900 --> 00:28:14.900
Right, right.

00:28:14.900 --> 00:28:19.100
So a driver shouldn't see any
difference between how a device

00:28:19.140 --> 00:28:25.900
behaves within Classic and how it
behaves in pure native Mac OS 9.1.

00:28:26.270 --> 00:28:34.380
Today, Classic attempts to capture
two different kinds of devices.

00:28:34.380 --> 00:28:38.100
The first is printer devices.

00:28:38.100 --> 00:28:44.070
Because we have the print center inside
of Mac OS X that has a USB client and

00:28:44.490 --> 00:28:50.880
already knows to talk to USB printing
devices for things that have 10

00:28:50.880 --> 00:28:55.960
native imaging drivers available,
it's already available for applications

00:28:56.010 --> 00:28:58.660
that want to print in Mac OS X.

00:28:58.660 --> 00:29:01.910
Some applications such as
Classic wouldn't have access

00:29:01.910 --> 00:29:05.880
to the Mac OS X print center,
so we decided to make printers

00:29:05.880 --> 00:29:08.040
available directly within Classic.

00:29:08.040 --> 00:29:11.420
And we just used whatever driver
was available within Classic,

00:29:11.430 --> 00:29:15.430
whether it be the Apple USB printer
class driver that we provide,

00:29:15.720 --> 00:29:18.770
or whether it's a vendor-specific
printer class driver,

00:29:18.770 --> 00:29:22.360
we allow that to load and match
the same way it always does.

00:29:22.360 --> 00:29:26.120
So within a Classic application,
you use the chooser to select which

00:29:26.250 --> 00:29:31.200
printer it is you want to print to,
and printing works by using

00:29:31.210 --> 00:29:33.980
the Classic USB emulation.

00:29:33.980 --> 00:29:37.650
The other type of device that
Classic will attempt to claim and

00:29:37.790 --> 00:29:40.500
control are vendor-specific devices.

00:29:40.500 --> 00:29:44.050
Any vendor-specific device
that wasn't claimed by a

00:29:44.050 --> 00:29:50.470
vendor-specific OS X native driver,
well it just defaults to going

00:29:50.470 --> 00:29:51.600
to the Classic user mode driver.

00:29:51.600 --> 00:29:55.350
Now, this can be a little tricky while
you're trying to develop your code,

00:29:55.350 --> 00:30:00.940
because you might have Classic loaded,
and Classic is loaded and running so

00:30:01.000 --> 00:30:05.950
that you can run some legacy application,
and meanwhile you're trying to

00:30:05.950 --> 00:30:10.120
do KMOD load of specific drivers,
and Classic keeps grabbing those

00:30:10.120 --> 00:30:15.070
devices every time you plug it in,
because it grabs vendor-specific

00:30:15.120 --> 00:30:17.460
devices and printer devices.

00:30:17.700 --> 00:30:20.090
Classic is migrating toward
using the sharing model,

00:30:20.150 --> 00:30:24.220
the same one I just
talked about right here.

00:30:24.220 --> 00:30:26.580
It's going to use and support
these exact same messages,

00:30:26.580 --> 00:30:31.020
so it's going to play fair with
all the other user mode drivers and

00:30:31.020 --> 00:30:33.420
all the other kernel mode drivers.

00:30:33.460 --> 00:30:40.910
As long as we all use this sharing model,
things are going to work great.

00:30:42.250 --> 00:30:46.950
The Apple Class drivers that we are
providing with Mac OS X is almost

00:30:47.300 --> 00:30:51.220
the full complement of drivers that
we're providing on 9 currently.

00:30:51.410 --> 00:30:55.090
The drivers that we are providing are
of course the Hub Class driver and

00:30:55.090 --> 00:31:00.660
the HID Class driver for HID devices,
mice, keyboards.

00:31:00.700 --> 00:31:06.350
We do have a new API available in
Mac OS X that we did not have in

00:31:06.410 --> 00:31:08.660
Mac OS 9 called the HID Manager.

00:31:08.700 --> 00:31:15.360
The HID Manager encapsulates a lot
of the same functionality that we had

00:31:15.360 --> 00:31:19.660
within the HID library within Mac OS 9.1.

00:31:19.700 --> 00:31:24.660
The HID library functionality is
rolled into this new HID Manager API.

00:31:24.660 --> 00:31:28.540
The HID Manager, in addition to working
with USB HID devices,

00:31:28.960 --> 00:31:32.360
also works with other HID devices
that might be attached to the

00:31:32.440 --> 00:31:36.610
system and actually makes them
look like USB HID devices.

00:31:36.670 --> 00:31:38.550
It uses USB's HID report.

00:31:38.710 --> 00:31:42.150
It uses HID reports and HID report
descriptors as a mechanism to describe

00:31:42.150 --> 00:31:43.630
the data that comes from a device.

00:31:44.020 --> 00:31:47.340
So ADB mice, you know,
if Mac OS X was running

00:31:47.340 --> 00:31:50.470
on a machine that had ADB,
an ADB mouse would actually show

00:31:50.560 --> 00:31:53.920
up in the HID Manager just like
it were kind of a USB device with

00:31:54.060 --> 00:31:57.650
an actual report descriptor and
reports and all of that information.

00:31:57.670 --> 00:32:02.470
The other drivers we're providing
include the Audio Class driver.

00:32:02.660 --> 00:32:06.290
The Audio Class driver
currently supports stereo,

00:32:06.310 --> 00:32:07.560
input, output.

00:32:07.730 --> 00:32:08.660
The HID driver is also
available in Mac OS X.

00:32:08.660 --> 00:32:08.660
The HID driver is also
available in Mac OS 9.1.

00:32:08.690 --> 00:32:12.660
Audio Class is one of the drivers
that was updated with the recent

00:32:12.660 --> 00:32:20.130
1002 and 1003 updates included new
USB Audio Class drivers and there's

00:32:20.130 --> 00:32:21.660
more on the way from the Audio team.

00:32:21.660 --> 00:32:24.820
Those guys are working really hard
trying to get all the support for

00:32:24.820 --> 00:32:26.650
all the devices that are out there.

00:32:26.660 --> 00:32:30.660
We have a Mass Storage Class driver.

00:32:30.700 --> 00:32:34.660
This does actually more than our
Storage Class driver in Mac OS 9 did.

00:32:34.660 --> 00:32:36.660
The Storage Class driver in 10
supports optical media as well.

00:32:36.680 --> 00:32:37.590
The Storage Class driver in 10
supports optical media as well.

00:32:37.690 --> 00:32:43.220
Because the Mass Storage team
has abstracted the

00:32:43.590 --> 00:32:49.200
SCSI architecture model family,
that was one of the families that

00:32:49.290 --> 00:32:52.520
we saw in the I/O Kit family,
it can actually support other

00:32:52.520 --> 00:32:55.660
devices that are attached via
USB as its transport mechanism,

00:32:55.660 --> 00:32:59.660
but actually are communicated
with SCSI commands.

00:33:00.300 --> 00:33:04.850
The storage class guys are
working on their stuff too.

00:33:04.850 --> 00:33:09.890
We're shy on a couple of things
that work pretty well on Mac OS 9.

00:33:10.260 --> 00:33:13.130
Manual eject and stuff is on its way.

00:33:13.220 --> 00:33:15.470
Communication devices.

00:33:15.630 --> 00:33:21.200
This is the exact same support
for abstract control model modems.

00:33:21.270 --> 00:33:26.000
You have that available in Mac OS X,
just like you did in 9.

00:33:26.400 --> 00:33:30.200
And of course we have
printing class support.

00:33:30.200 --> 00:33:36.180
What we had on Mac OS 9 was
printing class support for any

00:33:36.350 --> 00:33:38.200
imaging chooser type driver.

00:33:38.200 --> 00:33:41.980
And that included our
LaserWriter PostScript driver

00:33:42.090 --> 00:33:44.200
for PostScript printers.

00:33:44.200 --> 00:33:48.140
We include exactly the same functionality
on OS X and it's possible to write

00:33:48.230 --> 00:33:52.480
new print center imaging pieces
that plug in and still use our

00:33:52.620 --> 00:33:54.200
printing class transport mechanism.

00:33:54.200 --> 00:33:55.200
You just have to worry about the imaging.

00:33:55.200 --> 00:33:56.200
We'll handle that.

00:33:56.200 --> 00:33:58.630
you get the data to the printer.

00:33:59.490 --> 00:34:02.550
Okay, that about sums up our overview.

00:34:02.550 --> 00:34:06.400
We have a few slides here with where
you might turn for more information.

00:34:06.400 --> 00:34:10.890
In addition to the URLs here,
you don't need to copy those down.

00:34:10.900 --> 00:34:17.040
They're available on a specific
page off of the apple.com website.

00:34:17.150 --> 00:34:21.080
Places that we would point you to
include the USB Implementers Forum.

00:34:21.130 --> 00:34:26.060
USB Implementers Forum contains
the actual specs for USB,

00:34:26.200 --> 00:34:30.960
for the classes of drivers that
we've talked about Apple supporting.

00:34:31.000 --> 00:34:33.860
It includes information
about upcoming classes.

00:34:33.900 --> 00:34:37.640
I'm sure you're all familiar with
getting documentation off of there.

00:34:37.680 --> 00:34:43.960
You can find Mac OS X developer
information on developer.apple.com/macosx

00:34:44.180 --> 00:34:54.220
and USB information is available
on developer.apple.com/hardware/usb.

00:34:54.290 --> 00:35:00.300
We recently posted up there
Mac OS X SDK as well as

00:35:00.420 --> 00:35:03.860
our existing Mac OS 9 DDKs.

00:35:03.860 --> 00:35:06.810
Some people have been
somewhat surprised that the 10

00:35:06.810 --> 00:35:09.770
SDK doesn't have as much in it,
but actually it contains the

00:35:09.780 --> 00:35:11.140
same type of information.

00:35:11.140 --> 00:35:15.140
All we are really providing
is some example code and it

00:35:15.140 --> 00:35:21.960
automatically installs in
/developer/examples I believe.

00:35:21.960 --> 00:35:25.810
The other thing that gets installed
when you install our SDK is the

00:35:25.810 --> 00:35:26.860
absolute latest header file.

00:35:26.860 --> 00:35:31.540
You would need that if you're
compiling a USB project.

00:35:32.030 --> 00:35:34.420
Now, other USB drivers,
one of the things we did in our

00:35:34.420 --> 00:35:39.000
DDK is we separated out the actual
drivers that we used in OS 9 and

00:35:39.000 --> 00:35:41.200
made them available as sample code.

00:35:41.260 --> 00:35:43.700
Well,
all of the I/O USB family is available

00:35:43.700 --> 00:35:46.180
as sample code inside the Darwin project.

00:35:46.270 --> 00:35:50.060
So it's possible for you
to take a look at how any,

00:35:50.080 --> 00:35:53.670
well practically all of our USB drivers
are available in Darwin and all of the

00:35:53.670 --> 00:35:56.680
source code to the family is in Darwin.

00:35:56.710 --> 00:36:02.840
The USB team operates out of
that Darwin repository live,

00:36:02.910 --> 00:36:07.440
so when we check in some new
code or new fixes or new changes,

00:36:07.480 --> 00:36:10.620
they're actually available
in Darwin almost immediately.

00:36:10.640 --> 00:36:14.100
And you can check those out
and see what we're up to.

00:36:14.290 --> 00:36:18.140
We love bug reports that say
in this file on that line,

00:36:18.170 --> 00:36:20.420
that line right there is wrong.

00:36:20.450 --> 00:36:22.820
So feel free to send those to us.

00:36:23.200 --> 00:36:26.000
Okay, other sessions that you might
want to know about at WWDC.

00:36:26.040 --> 00:36:29.010
Yesterday you had the I/O Kit update.

00:36:29.080 --> 00:36:34.830
Right after this session we'll
have the I/O Kit storage drivers.

00:36:34.860 --> 00:36:40.180
There is a session on the image
capture framework tomorrow,

00:36:40.180 --> 00:36:40.880
tomorrow morning.

00:36:40.880 --> 00:36:45.010
And, of course,
our USB in-depth is available

00:36:45.700 --> 00:36:48.610
tomorrow at 3.30 p.m.

00:36:48.620 --> 00:36:49.860
That seems wrong.

00:36:49.860 --> 00:36:50.700
I thought it was 2 o'clock.

00:36:50.990 --> 00:36:54.460
Anyway, it's available tomorrow
in the Civic Auditorium,

00:36:54.460 --> 00:36:55.470
which is across the street.

00:36:56.790 --> 00:37:00.080
Finally,
we have our feedback forum on Thursday,

00:37:00.110 --> 00:37:01.590
an always popular event.

00:37:01.690 --> 00:37:03.780
We're looking forward to it.

00:37:04.110 --> 00:37:07.370
Okay,
if you want to contact somebody at Apple,

00:37:07.490 --> 00:37:10.080
Craig Keithley, he's the guy.

00:37:10.080 --> 00:37:11.880
He does USB and FireWire.

00:37:11.920 --> 00:37:13.890
There's his email address.

00:37:13.890 --> 00:37:18.270
And we have a developer mailing list
where developers help each other with

00:37:18.450 --> 00:37:21.350
questions and answers and the USB team,
when it has time,

00:37:21.360 --> 00:37:24.000
tries to provide a little
guidance there as well.

00:37:24.250 --> 00:37:30.810
So it's a good way to keep track
of what's going on with USB.
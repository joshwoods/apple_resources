WEBVTT

00:00:01.750 --> 00:00:02.940
Good morning, everyone.

00:00:02.960 --> 00:00:06.830
To present session 408,
OpenGL Advanced Optimization,

00:00:06.830 --> 00:00:14.840
I would like to introduce
OpenGL manager John Stauffer.

00:00:19.900 --> 00:00:20.110
Hi.

00:00:20.110 --> 00:00:25.260
So today we're going to talk about
advanced optimizations in OpenGL.

00:00:25.320 --> 00:00:30.260
So hopefully we'll learn a few things
about how OpenGL works and things you

00:00:30.260 --> 00:00:35.660
can do to try to tune your applications.

00:00:35.660 --> 00:00:35.670
So,

00:00:38.950 --> 00:00:43.200
So, what we'll learn is the key
components that you need to look

00:00:43.280 --> 00:00:47.030
at when you're trying to tune your
application for higher frame rates.

00:00:47.110 --> 00:00:52.120
The thing that I always like to start
talking about is application component.

00:00:52.370 --> 00:00:57.860
And the reason for that is that
about 75% of the time is spent in the

00:00:57.860 --> 00:00:59.790
application in a common OpenGL app.

00:00:59.790 --> 00:01:03.800
And so therefore,
since 75% of the time is spent there,

00:01:03.800 --> 00:01:07.800
that's where you have the potential
for getting the most benefit.

00:01:07.870 --> 00:01:10.750
So, if you don't tune your application,
obviously you're not going to get a

00:01:10.770 --> 00:01:13.800
lot out of OpenGL because you'll spend
too much time in the application.

00:01:13.800 --> 00:01:17.820
So, we'll spend some time just talking
about techniques for tuning your

00:01:17.820 --> 00:01:23.440
application to drive OpenGL better and
some hints on and tips on how to do that.

00:01:23.800 --> 00:01:25.770
The second thing is setup.

00:01:25.820 --> 00:01:31.050
So, how to properly set up OpenGL,
how to get some machine information,

00:01:31.190 --> 00:01:36.800
how to properly configure and scale
your application such that it will run

00:01:36.800 --> 00:01:36.800
well on the machine that you're using.

00:01:36.800 --> 00:01:37.790
The third thing is state management.

00:01:37.800 --> 00:01:45.020
So, state management basically is where
a large percent of the time that is

00:01:45.020 --> 00:01:51.790
spent in the actual OpenGL timeframe
is spent in state management.

00:01:51.810 --> 00:01:54.800
So, state management actually is more
important than a lot of people think.

00:01:54.800 --> 00:01:58.310
If you do a lot of thrashing
of state in OpenGL,

00:01:58.310 --> 00:02:02.800
you can actually decrease
your performance quite a bit.

00:02:02.800 --> 00:02:04.880
Texture management.

00:02:04.880 --> 00:02:05.800
Texture management is important.

00:02:05.880 --> 00:02:10.210
Texture management is important to keep
your application correctly scaled for the

00:02:10.210 --> 00:02:15.150
hardware so that you're not paging a lot,
you're not spending a lot

00:02:15.150 --> 00:02:20.770
of time running out of video
memory and paging on and off.

00:02:20.840 --> 00:02:21.720
Vertex operations.

00:02:21.970 --> 00:02:26.260
So, vertex operations are important
obviously to be able to get

00:02:26.340 --> 00:02:29.620
a lot of data to the card,
have an optimal format

00:02:29.620 --> 00:02:32.740
for sending the data,
keeping the data flow

00:02:32.740 --> 00:02:34.800
moving quickly to the card.

00:02:34.800 --> 00:02:35.800
Bye.

00:02:36.340 --> 00:02:37.440
Perfragment operations.

00:02:37.480 --> 00:02:40.010
So perfragment operations
are the operations that the

00:02:40.050 --> 00:02:41.080
card itself is going to do.

00:02:41.080 --> 00:02:43.930
So it's not CPU related,
but it's what the graphics

00:02:44.160 --> 00:02:47.200
card is going to have to do
to generate your final image.

00:02:47.430 --> 00:02:50.900
And there's some tips there to
offload some of the work the

00:02:50.900 --> 00:02:53.470
graphics card is going to need to do.

00:02:55.010 --> 00:02:56.100
Extensions.

00:02:56.100 --> 00:02:59.860
So a lot of times there's extensions
that you can utilize that are either

00:03:00.390 --> 00:03:05.130
directly geared towards optimizing
your application or will help you

00:03:05.390 --> 00:03:10.360
get the animation effect you're
looking for with a simpler path.

00:03:10.570 --> 00:03:13.890
So you won't have to do,
you can simplify your CPU work

00:03:14.040 --> 00:03:15.750
by utilizing an extension.

00:03:15.900 --> 00:03:19.270
Multi-CPU or multi-thread utilization.

00:03:19.270 --> 00:03:23.070
Obviously if there's a
machine that has two CPUs,

00:03:23.170 --> 00:03:28.180
it's an ideal situation to spawn
another thread and maybe move your

00:03:28.180 --> 00:03:30.900
graphics off to that other CPU.

00:03:30.900 --> 00:03:37.580
And lastly what we'll talk about briefly
is where to look for more information.

00:03:38.130 --> 00:03:43.290
So, starting off here,
just to get the image of

00:03:43.410 --> 00:03:47.080
what OpenGL looks like and
how data goes to OpenGL.

00:03:47.140 --> 00:03:49.080
It's important to think of
OpenGL as a data stream.

00:03:49.270 --> 00:03:53.180
So OpenGL fundamentally is a
data stream going to the card,

00:03:53.310 --> 00:03:57.510
and how the data is organized in
that stream is very important.

00:03:57.580 --> 00:04:03.280
Because it will give you hesitations if
you have too many operations of one type,

00:04:03.340 --> 00:04:08.380
or if you're flushing and breaking that
stream and causing discontinuities.

00:04:08.450 --> 00:04:12.260
So the fundamental type of data
that goes to OpenGL is vertices,

00:04:12.260 --> 00:04:14.660
which is your 3D data, and state.

00:04:14.730 --> 00:04:16.680
So you can fundamentally--
this is a simplistic view--

00:04:16.680 --> 00:04:19.840
but you can fundamentally break
it down into those two types of

00:04:19.840 --> 00:04:22.210
data sets that go to the card.

00:04:22.400 --> 00:04:25.710
And how that data, again,
gets organized and sent to the

00:04:25.800 --> 00:04:28.300
card can make a big difference.

00:04:29.280 --> 00:04:31.750
So, application.

00:04:31.770 --> 00:04:36.420
So, the thing to remember when
you're looking at writing an

00:04:36.420 --> 00:04:39.990
OpenGL application is first,
you have to decide obviously what type

00:04:40.000 --> 00:04:42.100
of performance you're looking for.

00:04:42.100 --> 00:04:46.180
And to do that,
you need to obviously decide what type

00:04:46.330 --> 00:04:49.100
of user interaction there's going to be.

00:04:49.100 --> 00:04:52.170
You know,
whether you need high frame rates

00:04:52.170 --> 00:04:57.100
because the user needs a fast response
time on the graphical feedback,

00:04:57.100 --> 00:04:59.080
which may mean you need 30, 50,
60 frames per second.

00:04:59.100 --> 00:05:03.150
You need to decide what type
of quality display in your

00:05:03.180 --> 00:05:06.070
application you're going to need.

00:05:06.650 --> 00:05:11.050
And obviously,
those two things can be related.

00:05:11.190 --> 00:05:15.500
So, adjusting the right quality with
the frame rate is going to give

00:05:15.500 --> 00:05:17.730
your user the best experience.

00:05:17.730 --> 00:05:19.730
So, it's important to keep those in mind.

00:05:19.740 --> 00:05:22.090
Your target platform.

00:05:22.090 --> 00:05:27.200
So, deciding what your ideal platform is
going to be and what you're going to

00:05:27.300 --> 00:05:29.080
run best on is going to be important.

00:05:29.080 --> 00:05:33.230
So, that you can potentially scale
your application to run well

00:05:33.230 --> 00:05:35.200
on those target platforms.

00:05:35.210 --> 00:05:38.980
And the things to remember about the
target platform are video memory size,

00:05:39.100 --> 00:05:43.220
how much system memory you're going
to be needing for the application,

00:05:43.220 --> 00:05:46.580
and potentially what graphics
cards in the system so that

00:05:47.060 --> 00:05:50.890
you can have the animation
effects that you're looking for.

00:05:52.470 --> 00:05:57.410
So the thing that a lot of applications
provide obviously is a mechanism

00:05:57.410 --> 00:06:02.400
for users to adjust the quality
settings within the application.

00:06:02.510 --> 00:06:09.260
And this is usually important such that
a user can himself or herself select the

00:06:09.260 --> 00:06:14.210
tradeoff they want between performance
and quality such that they can have

00:06:14.750 --> 00:06:19.350
some influence on their preferences
as to how fast the application will

00:06:19.350 --> 00:06:22.180
run or what the quality will look like.

00:06:25.320 --> 00:06:28.600
So the first thing we do,
and we do this a lot at Apple,

00:06:28.600 --> 00:06:33.170
is we'll take an application to try to
analyze where the time is being spent.

00:06:33.320 --> 00:06:35.990
We'll take the application,
and we will run it with

00:06:36.260 --> 00:06:38.080
a null layer of OpenGL.

00:06:38.080 --> 00:06:43.730
We'll try to figure out how fast OpenGL,
if OpenGL was infinitely fast,

00:06:43.890 --> 00:06:45.010
how fast would that application run?

00:06:45.020 --> 00:06:48.650
And this gives us an upper bounds,
and this helps us understand what the

00:06:49.030 --> 00:06:54.650
application itself is doing and what
profiling may be needed to be further

00:06:55.040 --> 00:06:56.810
done in the application to tune it.

00:06:56.870 --> 00:07:01.300
So two ways to, depending on your
programming environment,

00:07:01.300 --> 00:07:04.540
and just a reminder, actually,
all the code that I'm going to be

00:07:04.540 --> 00:07:07.860
showing today is Mac OS X Cocoa-based.

00:07:07.860 --> 00:07:11.140
I'm going to,
since we have limited slide space,

00:07:11.210 --> 00:07:13.340
I'm going to stick to
those function calls.

00:07:13.340 --> 00:07:16.960
So to no-op out the OpenGL layer,
there's a couple ways you can do

00:07:16.960 --> 00:07:18.000
it in your application very easily.

00:07:18.000 --> 00:07:21.520
For the CGL layer,
if you're programming straight

00:07:21.520 --> 00:07:24.210
to the core OpenGL layer,
you can simply set your

00:07:24.210 --> 00:07:27.240
OpenGL context to null,
and what that does is that actually,

00:07:27.240 --> 00:07:30.880
internal to OpenGL,
that will have OpenGL set all

00:07:30.980 --> 00:07:33.570
the entry points to a no-op,
so they will do nothing.

00:07:33.580 --> 00:07:39.420
And if you're at the app kit layer,
then you can use an app kit call

00:07:39.420 --> 00:07:42.350
just to clear the current context,
and it's equivalent

00:07:42.350 --> 00:07:45.000
to setting it to null,
and again, that will just set all

00:07:45.050 --> 00:07:47.710
the entry points to null,
to no-ops.

00:07:48.050 --> 00:07:52.680
And so what you want to do,
once you've done that, is you want to,

00:07:52.960 --> 00:07:57.770
measure the time that's spent in your
application to get a feel for what level

00:07:57.770 --> 00:08:00.380
of performance your application's at.

00:08:00.420 --> 00:08:05.520
And here we see a little code snippet
using get time a day to just quickly

00:08:05.520 --> 00:08:07.550
calculate time spent in the application.

00:08:07.560 --> 00:08:10.720
So once we've done that,
we can calculate an open loop,

00:08:10.720 --> 00:08:15.440
OpenGL no-op frames per second
that your application's capable of.

00:08:15.680 --> 00:08:18.900
So obviously if you're,
once you've gotten to this point,

00:08:18.900 --> 00:08:21.510
you realize that you've
no-opped OpenGL out,

00:08:21.670 --> 00:08:22.920
it's infinitely faster,
and you're able to do that.

00:08:22.920 --> 00:08:22.940
So that's a little bit of a tip there.

00:08:23.000 --> 00:08:25.580
It's infinitely fast,
and you're not achieving the frame

00:08:25.710 --> 00:08:28.120
rates that you would like to be at.

00:08:28.300 --> 00:08:32.910
You can immediately start, you know,
thinking about going into your

00:08:32.910 --> 00:08:34.590
application and tuning your application.

00:08:37.600 --> 00:08:40.310
What we do is you can
do a quick calculation.

00:08:40.420 --> 00:08:45.500
Assuming an average application spends
about 25% of the time in OpenGL,

00:08:45.500 --> 00:08:51.140
you can take that open loop frame rates
per second and just multiply it by .75.

00:08:51.230 --> 00:08:56.320
So lower that frame rate down and get
an estimate of what you're going to run,

00:08:56.320 --> 00:09:00.530
what your performance is going
to be once you enable OpenGL.

00:09:00.530 --> 00:09:00.530
And

00:09:01.200 --> 00:09:05.940
If this estimated frames per second
isn't where you want it to be again,

00:09:06.010 --> 00:09:08.120
you're going to have to start looking
at either OpenGL or you're going to have

00:09:08.150 --> 00:09:10.880
to start looking at your application.

00:09:10.910 --> 00:09:15.550
So to start tuning your application,
on OS X there's a variety

00:09:15.550 --> 00:09:17.200
of tools to do this.

00:09:17.200 --> 00:09:19.900
One tool that's very
useful is called Sampler.

00:09:19.990 --> 00:09:28.230
For anybody that hasn't used Sampler,
it's a tool that will--.

00:09:30.410 --> 00:09:31.040
So, it's a thread,
it's a threaded tool that will

00:09:31.040 --> 00:09:33.300
go out and look where your call
stack is at any given time.

00:09:33.580 --> 00:09:36.540
And it will generate a sample,
a heuristic of where the time is

00:09:36.540 --> 00:09:38.400
being spent in the application.

00:09:38.400 --> 00:09:40.940
So, this tool actually is very useful.

00:09:40.940 --> 00:09:43.150
It works for CFM apps and Mac OS apps.

00:09:43.450 --> 00:09:45.400
And it's part of the developer install.

00:09:45.400 --> 00:09:49.400
So, it's on your disk at
developer application sampler.

00:09:49.400 --> 00:09:51.060
And it's a very useful tool.

00:09:51.060 --> 00:09:54.320
We suggest everybody become
familiar with how to use it.

00:09:54.540 --> 00:09:57.390
And it will show you where all the hot
spots are in your application code.

00:09:57.400 --> 00:10:02.250
It will even show you where the hot
spots are in the operating system itself.

00:10:02.680 --> 00:10:07.790
But you may want to run this without
OpenGL and just run your application open

00:10:07.980 --> 00:10:11.680
loop and just stress your application
and find out where the hotspots are.

00:10:13.920 --> 00:10:17.060
Okay, so that was enough talking
about the application.

00:10:17.060 --> 00:10:23.330
So setting up OpenGL,
the first thing you need to do obviously

00:10:23.330 --> 00:10:29.290
is to go out and query for devices and
find what your--what devices you have,

00:10:29.290 --> 00:10:30.940
how many devices and such.

00:10:30.940 --> 00:10:35.530
So I've got a couple code snippets
up here that will show you in core

00:10:36.420 --> 00:10:41.870
graphics how to get your device--get
your main device and how to,

00:10:41.870 --> 00:10:45.980
from the main device,
generate an OpenGL display mask.

00:10:45.980 --> 00:10:49.740
So the first code snippet
here is just the main device.

00:10:49.740 --> 00:10:52.950
If you wanted to go
through all the devices,

00:10:53.070 --> 00:10:56.840
you could get all the active
display devices from core graphics,

00:10:56.960 --> 00:10:59.790
loop through them,
generate a display mask that

00:10:59.790 --> 00:11:04.200
represents all of the--all
the devices on the system.

00:11:04.200 --> 00:11:05.920
And really,
it's going to depend on whether

00:11:05.920 --> 00:11:11.220
you're a full screen or a windowed
application as to what you're going--what

00:11:11.290 --> 00:11:14.490
the right thing for you to do is.

00:11:17.510 --> 00:11:21.260
So what we can do with this information
is we can find out how much video memory

00:11:21.260 --> 00:11:24.300
is in the system on each graphics card.

00:11:24.300 --> 00:11:32.140
So here we've got a code snippet that
will query the renderer for video memory.

00:11:32.140 --> 00:11:36.400
And it goes through the loop
and it will look at each device,

00:11:36.400 --> 00:11:38.280
querying it for video memory size.

00:11:38.360 --> 00:11:42.240
And this is going to be important
because as we start to try to

00:11:42.370 --> 00:11:45.070
adjust or tune our application,
we're going to want to make sure

00:11:45.070 --> 00:11:47.790
that the amount of textures we have,
the resources we're going to

00:11:47.790 --> 00:11:51.180
be consuming on the card are
going to fit in video memory.

00:11:51.180 --> 00:11:55.590
So we're going to want to know
this usually up front if we have

00:11:55.590 --> 00:11:59.570
a texture intensive application.

00:12:03.000 --> 00:12:08.750
OK,
so when we look at the video memory size,

00:12:08.820 --> 00:12:11.890
there are several things
that we may want to adjust.

00:12:11.900 --> 00:12:13.900
Again,
we may want to adjust texture sizes,

00:12:13.910 --> 00:12:16.550
but we may also want to
adjust the screen resolution.

00:12:16.560 --> 00:12:19.420
If we're going to be switching
into a full screen mode,

00:12:19.460 --> 00:12:22.940
let's say, we're going to have the
opportunity for picking a screen

00:12:22.940 --> 00:12:25.080
depth and a screen resolution.

00:12:25.180 --> 00:12:30.640
If you have determined that your
application needs more video memory

00:12:30.640 --> 00:12:33.000
than is potentially available
in the current display mode,

00:12:33.070 --> 00:12:35.860
then you'll want to switch it down
to a 16-bit color potentially,

00:12:35.860 --> 00:12:38.300
or you'll want to switch
down the resolution,

00:12:38.330 --> 00:12:41.130
give the application more breathing
room on the graphics card,

00:12:41.130 --> 00:12:45.490
and that will help with keeping your
application out of a texture paging

00:12:45.490 --> 00:12:51.190
mode and give the-- a higher frame rate
during the running of the application.

00:12:51.750 --> 00:12:56.760
So the other thing you'll want to do
is to find out what CPU you're on.

00:12:56.830 --> 00:12:59.390
One thing that we find very
useful is internally to

00:12:59.430 --> 00:13:01.650
OpenGL obviously is using Altevec.

00:13:01.880 --> 00:13:06.450
And Altevec can give you substantial
performance boosts if you utilize it.

00:13:06.500 --> 00:13:10.600
So finding out if you're on
a G3 or a G4 is very useful.

00:13:10.810 --> 00:13:15.590
And tuning to that condition
can be very beneficial.

00:13:15.760 --> 00:13:18.870
The other thing to remember about
that is that typically the difference

00:13:18.870 --> 00:13:22.480
between a G3 and G4 is that G4 systems
are going to be faster and you may want

00:13:22.480 --> 00:13:28.780
to think about adjusting your data set
size to accommodate the faster systems.

00:13:30.550 --> 00:13:34.050
So quickly talking
about state management.

00:13:34.210 --> 00:13:39.280
So state management, again,
is the process of switching what mode

00:13:39.280 --> 00:13:46.070
OpenGL is running in to get your proper
configuration for drawing your graphics.

00:13:46.230 --> 00:14:02.260
The thing to remember with state
changes is you want to minimize those.

00:14:02.260 --> 00:14:02.260
What we have found is that
in a lot of applications,

00:14:02.260 --> 00:14:02.260
the amount of time that's
actually spent in OpenGL,

00:14:02.260 --> 00:14:02.260
a considerable portion of that is
actually doing state management.

00:14:02.260 --> 00:14:02.260
And if you...

00:14:02.950 --> 00:14:06.730
Unnecessarily changed state,
you can cause a lot of thrashing down on

00:14:06.740 --> 00:14:11.870
the card because OpenGL has to go through
a lot of setup to properly configure

00:14:11.870 --> 00:14:13.780
the graphics card for each state change.

00:14:13.970 --> 00:14:18.480
Some state changes are obviously
more expensive than others and

00:14:18.570 --> 00:14:21.900
we'll go through a few of those,
which ones to avoid.

00:14:21.900 --> 00:14:24.940
But in general,
you want to group your data to

00:14:24.940 --> 00:14:29.330
minimize state changes and that will
have a significant impact on what

00:14:29.330 --> 00:14:31.900
performance you can ultimately achieve.

00:14:32.140 --> 00:14:33.680
So,

00:14:34.070 --> 00:14:37.470
Some general calls you want to avoid.

00:14:37.600 --> 00:14:38.650
GL flush.

00:14:38.870 --> 00:14:42.730
So you want to avoid GL flush.

00:14:43.100 --> 00:14:47.400
Because what it actually does is, if you,
again, think about OpenGL as a command

00:14:47.520 --> 00:14:49.100
stream going to the graphics card.

00:14:49.280 --> 00:14:52.930
GL flush tells the graphics card,
terminate the current command stream,

00:14:52.990 --> 00:14:56.000
send it to the graphics
card and start me a new one.

00:14:56.020 --> 00:15:00.780
So you've just chopped that command
stream and sent it on its way.

00:15:00.780 --> 00:15:05.830
And the reason that you don't want
to do this necessarily is because

00:15:05.880 --> 00:15:09.650
there's only so many command buffers
that you can have allocated to

00:15:09.650 --> 00:15:11.640
your application at any given time.

00:15:11.760 --> 00:15:13.880
So if you sit there and
call GL flush a lot,

00:15:13.980 --> 00:15:17.660
you will use up the buffers that you
have available to your application

00:15:17.660 --> 00:15:20.990
and your application may be starved
for available space to stick,

00:15:21.120 --> 00:15:22.840
you know, put data on the stream.

00:15:22.960 --> 00:15:25.290
So unless you have to,
don't call GL flush.

00:15:25.390 --> 00:15:30.340
And there's actually very few
reasons they would call it.

00:15:30.340 --> 00:15:32.970
Usually you can find some other way
to do what you're looking to do.

00:15:33.070 --> 00:15:37.970
If you want the user to
see something immediately,

00:15:38.130 --> 00:15:40.280
usually you just call swap buffers to
get the data swapped to the screen.

00:15:40.280 --> 00:15:46.120
And swap buffers actually calls,
is implicitly calls a flush.

00:15:46.120 --> 00:15:49.760
So when you call swap,
it terminates the stream,

00:15:49.760 --> 00:15:52.920
sends it to the card and so
you don't necessarily have

00:15:53.070 --> 00:15:54.510
to call GL flush yourself.

00:15:54.920 --> 00:15:57.120
Another call that's even
more expensive is GL finish.

00:15:57.230 --> 00:16:00.550
So GL finish is like a GL flush,
except for it sends the data to

00:16:00.550 --> 00:16:04.120
the card and it actually will block
there waiting for the graphics

00:16:04.120 --> 00:16:05.900
card to finish its drawing.

00:16:05.910 --> 00:16:08.890
So once all the commands have
gone to the graphics card,

00:16:08.920 --> 00:16:08.920
finished, come back and return,
it will send the data to the card and

00:16:08.920 --> 00:16:08.920
it will block the data to the card.

00:16:08.980 --> 00:16:10.570
So once all the commands have gone
to the card and it has finished,

00:16:10.570 --> 00:16:11.800
come back and return,
then GL finish will actually

00:16:11.860 --> 00:16:12.650
return to your application.

00:16:12.680 --> 00:16:17.000
So an important performance
thing to keep in mind is that

00:16:17.000 --> 00:16:19.420
GL finish is very expensive.

00:16:19.700 --> 00:16:25.710
It can be a blocking call that
can take quite a while to return.

00:16:28.090 --> 00:16:32.280
So you want to avoid reading
data back from OpenGL.

00:16:32.370 --> 00:16:36.080
And when it comes to state management,
typically what you want to do is

00:16:36.310 --> 00:16:41.010
you want to keep the data in the
application that you will need later

00:16:41.010 --> 00:16:43.380
and not ask OpenGL for it back.

00:16:43.410 --> 00:16:47.650
Depending on the driver and
what you're reading back,

00:16:47.790 --> 00:16:49.860
it can get very expensive.

00:16:49.870 --> 00:16:53.780
Reading back data can actually be
the same cost of calling a GLFinish

00:16:53.780 --> 00:16:56.800
because if you're reading pixels back,
for instance,

00:16:56.800 --> 00:17:02.710
the pixels actually have to represent
the current state that you are expecting.

00:17:02.720 --> 00:17:04.240
And that is you've drawn
all these commands,

00:17:04.240 --> 00:17:06.710
you've issued all these drawing commands,
you're expecting the

00:17:06.770 --> 00:17:08.630
pixels to be in the buffer.

00:17:08.790 --> 00:17:11.030
Well, so OpenGL realizes this,
and when you try to

00:17:11.030 --> 00:17:13.560
read some pixels back,
it's going to have to call finish,

00:17:13.560 --> 00:17:16.100
wait till all the commands are finished,
wait till it's drawn everything,

00:17:16.230 --> 00:17:18.120
before it can give you
the valid pixels back.

00:17:18.300 --> 00:17:21.970
So you don't want to read the
frame buffer unless you have to,

00:17:22.520 --> 00:17:25.660
you don't want to be reading state.

00:17:25.880 --> 00:17:28.100
Some state can be expensive to read,
and you don't want to read

00:17:28.170 --> 00:17:31.960
textures unless you have to.

00:17:31.960 --> 00:17:35.510
They all can have varying penalties
depending on what mode you're running in.

00:17:36.320 --> 00:17:40.510
So what you also want to think
about when you're writing OpenGL is

00:17:40.510 --> 00:17:44.900
avoid complex state settings.

00:17:44.900 --> 00:17:49.440
If you don't know what
a state setting does,

00:17:49.580 --> 00:17:55.020
usually it's a bad idea to just
arbitrarily throw state changes in there.

00:17:55.020 --> 00:17:57.970
What you'll want to do is keep
the state as simple as possible,

00:17:58.220 --> 00:18:02.480
because this will help the graphics
card run in its most optimal mode.

00:18:02.480 --> 00:18:05.830
This will also usually lead to
less state thrashing when you

00:18:05.830 --> 00:18:08.610
are trying to transition from
one drawing routine to another,

00:18:08.610 --> 00:18:11.160
you won't have to do as much
state setup and teardown,

00:18:11.200 --> 00:18:13.160
so it'll lead to less state transition.

00:18:13.200 --> 00:18:17.190
So keeping it simple is
obviously a simplistic concept,

00:18:17.190 --> 00:18:19.840
but it's something to keep in mind.

00:18:20.550 --> 00:18:25.820
So some basic complex states that
you want to avoid are lighting,

00:18:25.870 --> 00:18:29.730
user clipping planes, and full scene,
well, anti-aliasing,

00:18:29.860 --> 00:18:33.400
like anti-aliasing lines,
anti-aliasing points, polyons.

00:18:33.400 --> 00:18:36.350
And the reason you want to avoid those is
because they can be very expensive to do.

00:18:36.550 --> 00:18:39.840
With modern hardware,
lighting and user clipping planes and

00:18:39.840 --> 00:18:42.360
even anti-aliasing lines are pretty fast.

00:18:42.440 --> 00:18:46.400
So again, it may depend on the particular
graphics card you're running on.

00:18:46.400 --> 00:18:49.900
But in general,
lighting is very computationally

00:18:49.980 --> 00:18:53.400
expensive and unless you
have a real need for it,

00:18:53.460 --> 00:18:54.400
you'll want to keep that disabled.

00:18:54.400 --> 00:18:56.680
Even on the high power
graphics cards today,

00:18:56.680 --> 00:19:00.180
if you start enabling lighting,
you will cause a graphics card to

00:19:00.320 --> 00:19:03.400
do more processing and you will
ultimately lower the performance.

00:19:03.400 --> 00:19:06.640
Now whether you actually see
that will depend on how fast,

00:19:06.640 --> 00:19:09.340
you know,
what kind of demands your application

00:19:09.340 --> 00:19:11.340
is putting on the graphics card.

00:19:11.460 --> 00:19:16.400
But those are very complex operations
for the graphics card to perform.

00:19:16.400 --> 00:19:17.930
phone.

00:19:20.450 --> 00:19:22.560
So texture management.

00:19:22.600 --> 00:19:25.940
So this is a very important topic because
a lot of games nowadays or applications

00:19:25.940 --> 00:19:32.200
in general are using a lot of textures
and how to properly manage those can be,

00:19:32.200 --> 00:19:35.290
make a big difference in the
application's performance.

00:19:35.400 --> 00:19:37.380
So several things to remember.

00:19:37.570 --> 00:19:40.400
Avoid uploading the
texture more than once.

00:19:40.580 --> 00:19:43.310
Ideally what you want to do is you
want to give OpenGL the texture

00:19:43.920 --> 00:19:48.390
and not keep handing it to OpenGL.

00:19:48.450 --> 00:19:52.390
Don't delete it and then give it
back to it later if at all possible.

00:19:52.560 --> 00:19:56.490
And instead let OpenGL do the management,
the bookkeeping of whether the texture

00:19:56.490 --> 00:19:58.400
should be in video memory or not.

00:19:59.070 --> 00:20:05.190
Avoid, so again, avoid keeping a copy.

00:20:05.190 --> 00:20:05.190
And that will save,

00:20:06.400 --> 00:20:10.700
Avoiding keeping a copy in the
application will save system memory.

00:20:10.700 --> 00:20:13.460
The thing to remember here is
that OpenGL will keep a copy.

00:20:13.600 --> 00:20:15.300
And so you're going to have two copies.

00:20:15.300 --> 00:20:18.420
If you keep one in the application
and one is going to be kept in OpenGL,

00:20:18.420 --> 00:20:22.110
you're going to have two
times that texture size.

00:20:22.290 --> 00:20:25.200
So it's best if you
delete yours if possible.

00:20:25.300 --> 00:20:30.040
So ways to get data, textures,
data into the graphics card

00:20:30.040 --> 00:20:32.070
or into the driver fast.

00:20:32.740 --> 00:20:37.880
There is an extension
called Apple Packed Pixel.

00:20:38.440 --> 00:20:43.300
So this is the fastest way to
get pixel data into OpenGL.

00:20:43.300 --> 00:20:46.100
And it's a very flexible format.

00:20:46.100 --> 00:20:50.450
It will support all the
standard OpenGL pixel types,

00:20:50.830 --> 00:20:52.180
Apple pixel types.

00:20:52.310 --> 00:20:54.300
It will also support a number
of rather complex formats.

00:20:54.300 --> 00:20:55.300
So you can see here,
I'm going to show you a few examples.

00:20:55.300 --> 00:20:57.280
There are a few odd types
that may be useful for you.

00:20:57.350 --> 00:21:02.970
You know, like 565 or 332,
depending on what your quality

00:21:02.970 --> 00:21:07.300
requirement is or whether
you don't need a high-rate,

00:21:07.300 --> 00:21:09.260
don't need a deep bit
depth per component.

00:21:09.320 --> 00:21:17.590
You can get away with some of the
smaller bits per pixel components.

00:21:18.600 --> 00:21:22.990
Minimize the, how often you change
your current texture.

00:21:23.020 --> 00:21:25.840
So changing your current texture
is actually one of the most

00:21:25.930 --> 00:21:29.020
expensive operations you can do.

00:21:29.020 --> 00:21:34.020
And what that means is that changing
your current texture is a GL bind call.

00:21:34.020 --> 00:21:36.560
And when you bind from
one texture to another,

00:21:36.620 --> 00:21:40.310
you're basically just causing
OpenGL to potentially reconfigure

00:21:40.310 --> 00:21:43.800
all of its texture combiners in
the hardware for the new texture.

00:21:43.800 --> 00:21:47.960
Because the new texture is going to
require different blending modes.

00:21:47.960 --> 00:21:51.640
And it can be fairly
expensive to do that setup.

00:21:51.640 --> 00:21:54.320
So typically what you want to do in
the application if you have a lot of

00:21:54.320 --> 00:21:59.980
data is you want to group your data
in groups with common texture types.

00:22:00.300 --> 00:22:03.480
So that's the best way to group the data,
such that you minimize

00:22:03.480 --> 00:22:04.770
your texture changes.

00:22:07.480 --> 00:22:10.690
So scale textures to your hardware size.

00:22:10.950 --> 00:22:15.010
So again, earlier we looked at
finding the VRAM size.

00:22:15.410 --> 00:22:18.680
So what you'll want to do is you
can do some basic rudimentary

00:22:18.680 --> 00:22:22.090
math in your application,
and just fundamentally try to scale your

00:22:22.090 --> 00:22:24.920
application to fit on the graphics card.

00:22:25.040 --> 00:22:27.330
So if you have a lot of textures,
you'll need to calculate how many

00:22:27.330 --> 00:22:31.220
you're going to need necessarily
on the graphics card at any time.

00:22:31.270 --> 00:22:34.280
It's not terribly
important to get it exact,

00:22:34.390 --> 00:22:38.310
but you would like to keep it
within a reasonable bounds.

00:22:38.320 --> 00:22:42.000
OpenGL is very efficient at paging.

00:22:42.130 --> 00:22:46.910
So what you'll not want to do is try to
keep OpenGL always out of a paging mode.

00:22:46.980 --> 00:22:53.080
You don't want to try to second guess the
exact size of the video memory available,

00:22:53.080 --> 00:22:56.000
and when exactly OpenGL is
going to go into paging mode.

00:22:56.000 --> 00:22:58.970
Because if you do that,
you're not going to let OpenGL grow

00:22:59.040 --> 00:23:02.430
and utilize some of the mechanisms
internally to the driver that will try

00:23:02.600 --> 00:23:04.800
to optimally page textures on and off.

00:23:05.360 --> 00:23:10.300
So OpenGL uses, internally,
for paging textures on and off,

00:23:10.430 --> 00:23:12.660
is called the LRU/MRU algorithm.

00:23:12.660 --> 00:23:15.720
That stands for least recently used,
most recently used.

00:23:15.720 --> 00:23:20.230
So depending on how committed you are,
how many textures are

00:23:20.240 --> 00:23:24.230
committed per scene,
whether you're over committed that scene,

00:23:24.230 --> 00:23:27.200
it will actually switch to
different mechanisms for

00:23:27.200 --> 00:23:31.420
paging textures on and off,
trying to optimally keep the

00:23:31.420 --> 00:23:35.120
right set on the graphics card,
and not unduly page them.

00:23:35.120 --> 00:23:38.360
So that algorithm actually
works pretty well.

00:23:38.360 --> 00:23:43.340
Also, particular to OS X,
is we built a mechanism that causes

00:23:43.440 --> 00:23:46.300
almost no CPU work to page a texture.

00:23:46.480 --> 00:23:49.780
So once a texture's in OpenGL,
and it had to get paged off,

00:23:49.900 --> 00:23:52.900
back into system memory, let's say,
it costs very little CPU work

00:23:53.040 --> 00:23:56.960
to get it back into the stream
and back uploaded onto OpenGL.

00:23:56.960 --> 00:24:01.120
So while it will cost a little
bit of memory bandwidth,

00:24:01.480 --> 00:24:03.490
while it's getting read
and it's getting processed,

00:24:03.670 --> 00:24:04.960
it's going to cost a lot of time.

00:24:04.960 --> 00:24:07.200
And if it gets read and it's
going to cost some AGP traffic,

00:24:07.200 --> 00:24:10.430
the CPU cycles spent are
going to be pretty minimal.

00:24:10.460 --> 00:24:15.000
So we find that letting OpenGL do the
paging isn't expensive for the CPU.

00:24:15.000 --> 00:24:17.240
The CPU can keep on going.

00:24:17.370 --> 00:24:21.680
And as long as you're not causing
too much bandwidth across the AGP,

00:24:21.720 --> 00:24:25.190
you can get away with a
fair amount of paging.

00:24:25.770 --> 00:24:28.880
So depending on what you're doing,
you're going to also want to

00:24:28.880 --> 00:24:30.200
split your textures into tiles.

00:24:30.440 --> 00:24:32.960
For,
and I've got a demo of this in a bit,

00:24:33.000 --> 00:24:35.880
where if you're doing,
wanting to do smooth

00:24:35.880 --> 00:24:40.340
animations of some sort,
trying to amortize the data stream

00:24:40.340 --> 00:24:45.500
as it goes to the card and trying to
keep the drawing moving while large

00:24:45.510 --> 00:24:48.080
images are moving up the stream.

00:24:48.130 --> 00:24:52.010
So again if you look at the whole
process of OpenGL as a big data stream,

00:24:52.120 --> 00:24:55.120
if you have a four megabyte texture,
that's a big block of data

00:24:55.120 --> 00:24:56.700
in the middle of your stream.

00:24:56.730 --> 00:25:00.280
So you can envision that under
some circumstances it would be

00:25:00.280 --> 00:25:04.070
good to interlace that upload
with some polygon drawing,

00:25:04.120 --> 00:25:08.620
maybe a frame here and there so
that you can amortize the texture

00:25:08.640 --> 00:25:14.210
upload time going across the
bus and keep animations flowing.

00:25:15.450 --> 00:25:20.960
So here's a little diagram
for texture management.

00:25:21.060 --> 00:25:24.770
One thing that we recommend on
OS X is to split your texture

00:25:24.840 --> 00:25:25.990
loading off to a separate thread.

00:25:26.020 --> 00:25:28.690
If you're going to be spooling
through a lot of textures,

00:25:28.780 --> 00:25:33.940
it's a good idea to maybe spawn a
thread that will do that work for you.

00:25:33.940 --> 00:25:35.990
And the reason for that is
that--there's a couple reasons.

00:25:35.990 --> 00:25:38.090
One is you can utilize a second CPU,
and two,

00:25:38.140 --> 00:25:43.790
you can utilize preemptive multitasking
to balance out the loading,

00:25:43.790 --> 00:25:47.870
the act of maybe reading
a texture from disk,

00:25:47.870 --> 00:25:50.960
the cost of loading it in OpenGL.

00:25:51.070 --> 00:25:56.080
You can use the preemptive capabilities
of OS X to spread that cost out so

00:25:56.080 --> 00:26:01.640
you don't end up with a single point
in your rendering stream or in your

00:26:01.640 --> 00:26:08.360
CPU cycles that are blocked trying to
get this texture uploaded and processed.

00:26:08.390 --> 00:26:09.260
So it's a good idea.

00:26:09.360 --> 00:26:11.810
So if we look at this,
this is a basic diagram of how to set

00:26:12.150 --> 00:26:14.800
up a two-threaded--or what happens
when you set up a two-threaded.

00:26:14.800 --> 00:26:18.980
Application,
one loading the OpenGL textures

00:26:18.980 --> 00:26:21.730
and one doing the drawing.

00:26:21.750 --> 00:26:25.200
So what happens is the first
thread is loading the textures,

00:26:25.410 --> 00:26:29.180
and those textures will get
processed and put into the driver,

00:26:29.210 --> 00:26:30.460
into the kernel driver.

00:26:30.460 --> 00:26:32.840
So the kernel will have
them at this point,

00:26:32.840 --> 00:26:35.360
and they will be sitting in the kernel
waiting to be uploaded to the card.

00:26:35.360 --> 00:26:40.890
So you'll have done most of the work
of CPU cycles on the primary thread

00:26:41.040 --> 00:26:44.500
of getting the data into the kernel.

00:26:44.500 --> 00:26:44.500
And then you can load the textures.

00:26:44.500 --> 00:26:46.850
So you'll have the first thread loaded,
and then you can have your second thread

00:26:47.220 --> 00:26:49.770
come along and issue the drawing plans.

00:26:49.800 --> 00:26:54.270
And as long as you have your thread
synchronization correctly organized,

00:26:54.430 --> 00:26:57.320
then your data will be there
by the time you need it,

00:26:57.330 --> 00:27:00.120
and everything will
just flow much smoother.

00:27:02.680 --> 00:27:04.600
I've got a demo of this.

00:27:04.730 --> 00:27:11.350
And this demo shows this basic
concept that the diagram had there.

00:27:22.050 --> 00:27:26.580
So what this demo tries to
show is a couple concepts.

00:27:26.580 --> 00:27:30.700
One is how to balance the--

00:27:31.390 --> 00:27:36.680
requirements of your application with
quality and smoothness of frame rate.

00:27:36.710 --> 00:27:40.590
So what we have here on the left
is we have a slider that will

00:27:40.700 --> 00:27:43.790
adjust the quality of these images.

00:27:43.800 --> 00:27:46.560
So for instance,
down here at the bottom I can get 64

00:27:46.560 --> 00:27:52.900
by 64 textures and up on the top I get
1024 by 1024 and everything in between.

00:27:52.900 --> 00:27:57.940
So what's interesting to look
at here is if you're trying

00:27:58.080 --> 00:28:00.600
to say write a screen saver,
for instance,

00:28:00.600 --> 00:28:03.960
and you're trying to get these
images up to the graphics card

00:28:03.960 --> 00:28:08.070
while maintaining smooth animation,
you'll see that we get a hesitation.

00:28:08.090 --> 00:28:12.320
And that hesitation is because one,
we only have one thread doing

00:28:12.360 --> 00:28:14.370
the loading and the animation.

00:28:14.370 --> 00:28:17.780
So we get a large hesitation while
we spool the texture off disk.

00:28:17.780 --> 00:28:22.740
We decompress that JPEG and we load it
into OpenGL and give it to the driver.

00:28:22.740 --> 00:28:26.830
So we can see that this isn't going
to lead to a very nice screen saver.

00:28:27.050 --> 00:28:30.420
So we start looking for
techniques to smooth that out.

00:28:30.420 --> 00:28:35.680
And one thing we can do is we can
spawn a thread and we can give the,

00:28:35.770 --> 00:28:39.780
that thread the job of spooling
the texture off of disk

00:28:40.260 --> 00:28:42.720
and loading it into OpenGL.

00:28:42.720 --> 00:28:47.900
So what we see now is we see that it's
a lot smoother but it's not perfect.

00:28:48.380 --> 00:28:53.340
So here's where you can start
deciding whether frame rate

00:28:53.350 --> 00:28:55.420
and quality are important.

00:28:55.480 --> 00:29:00.630
One thing you can do is obviously,
if you're not needing to

00:29:00.940 --> 00:29:05.080
achieve those kinds of rates
of uploading and animating,

00:29:05.080 --> 00:29:06.980
you can slow it down.

00:29:07.740 --> 00:29:09.850
and the hiccups are almost gone.

00:29:10.110 --> 00:29:13.920
The other thing you can do, obviously,
is if you want to stay relatively

00:29:13.920 --> 00:29:17.770
fast animations is you can
lower your image quality.

00:29:19.230 --> 00:29:22.100
So,
we're still going a little bit too fast

00:29:22.100 --> 00:29:25.950
to get absolutely smooth animation.

00:29:28.450 --> 00:29:33.000
But so you can see with this technique,
we've basically eliminated the

00:29:33.170 --> 00:29:37.150
pauses in the animation stream and
we're able to get smooth animations

00:29:37.230 --> 00:29:40.400
while we're spooling through
a large quantity of textures.

00:29:40.520 --> 00:29:43.400
This demo actually will spool
through 200 megabytes of textures,

00:29:43.400 --> 00:29:45.200
simulating a fairly large scenario.

00:29:45.400 --> 00:29:52.190
And then the third thing we can do,
after we decide a frame rate quality,

00:29:52.190 --> 00:29:55.080
we can also go to a tiled mode.

00:29:55.220 --> 00:29:59.960
So a tiled mode is an attempt
to split the texture into many

00:29:59.960 --> 00:30:04.310
pieces and to amortize the cost
of uploading that across the bus.

00:30:04.360 --> 00:30:07.110
Now I've had a little bit of a
problem with the tiling mode,

00:30:07.110 --> 00:30:09.150
so we're going to give it a shot though.

00:30:11.310 --> 00:30:16.430
So the tiling mode theoretically
now is using the primary

00:30:16.430 --> 00:30:20.220
thread to load the images.

00:30:21.650 --> 00:30:27.980
And then the drawing thread is-- well,
there we go.

00:30:28.100 --> 00:30:31.960
So I've got some thread
synchronization issues.

00:30:32.390 --> 00:30:36.600
It's an attempt to try to
amortize the cost of moving

00:30:36.600 --> 00:30:38.490
the data across to the card.

00:30:38.510 --> 00:30:41.680
So with the MP case,
as soon as we went to

00:30:41.680 --> 00:30:46.510
the multi-threaded case,
we offloaded the main thread,

00:30:46.770 --> 00:30:52.080
its job of loading all of the data
from disk and then giving it to OpenGL.

00:30:52.080 --> 00:30:55.240
But what we were not able to do in
the multi-threaded case is we're

00:30:55.290 --> 00:31:00.250
not able to amortize the cost of
moving that image across the bus,

00:31:00.340 --> 00:31:03.870
across the AGP up to the video memory.

00:31:03.880 --> 00:31:05.660
So we still see a small
hiccup in the MP case.

00:31:05.660 --> 00:31:10.120
So as soon as we go to tile mode,
what I've done here is I've

00:31:10.190 --> 00:31:14.270
taken a small piece of the tile,
a small piece of the texture,

00:31:14.270 --> 00:31:16.780
and I've uploaded one
small piece at a time.

00:31:16.790 --> 00:31:20.450
So I'm able to upload one small piece
per frame and that way not see a big

00:31:20.450 --> 00:31:24.810
four megabyte chunk of data in the data
stream as it goes to the graphics card.

00:31:24.820 --> 00:31:28.760
And done correctly,
you can make... Get a lot of data up to

00:31:28.760 --> 00:31:32.660
the system with very smooth animations.

00:31:32.660 --> 00:31:35.300
So again,
if you look at the different scenarios,

00:31:35.360 --> 00:31:39.340
looking at the stream case,
so there it is.

00:31:39.600 --> 00:31:43.590
Multi-threaded, it's a lot smoother.

00:31:45.900 --> 00:34:21.200
[Transcript missing]

00:34:21.260 --> 00:34:24.640
The deficit is that if you are
passing small amounts of data,

00:34:24.640 --> 00:34:29.830
there's a little bit of overhead
of logic to get into the routines.

00:34:29.960 --> 00:34:32.960
So you're not going to want to call
a compile vertex array with three

00:34:32.960 --> 00:34:37.670
vertices because you're better off going
to GL begin end because that's lower

00:34:37.670 --> 00:34:40.200
overhead for a small amount of data.

00:34:40.200 --> 00:34:43.950
So if you have large arrays of data,
let's say greater than 16,

00:34:43.950 --> 00:34:47.510
16 may be pushing the smaller end of it,
but say greater than

00:34:47.510 --> 00:34:51.150
16 vertices per array,
try using compile vertex array.

00:34:51.220 --> 00:34:54.150
It could probably get you some benefit.

00:34:55.150 --> 00:35:01.490
So looking at a chart here that
shows you primitives along the x-axis

00:35:01.610 --> 00:35:05.800
and number of triangles that you
can render per second along the y,

00:35:05.800 --> 00:35:09.900
you can see that the type of
primitive can make a large impact

00:35:10.000 --> 00:35:13.260
in the number of triangles that
you can send through the system.

00:35:13.270 --> 00:35:14.950
So down at the very bottom is polygons.

00:35:15.040 --> 00:35:20.240
Polygons is the most rudimentary
way to send data to OpenGL.

00:35:20.360 --> 00:35:25.480
And then near the upper end of
the spectrum is triangle strips.

00:35:25.500 --> 00:35:27.980
So triangle strips is the best
way to send data through the

00:35:27.980 --> 00:35:31.040
begin end immediate mode path.

00:35:31.150 --> 00:35:34.460
And then at the very far
right is compile vertex array.

00:35:34.520 --> 00:35:38.200
So you can see that compile vertex array,
if fed correctly,

00:35:38.240 --> 00:35:41.540
can give you substantial
boost in performance.

00:35:41.660 --> 00:35:45.180
Now the green bar shows what you
can do on a G3 and the blue and

00:35:45.180 --> 00:35:49.200
the orange bar shows you on a G4.

00:35:49.310 --> 00:35:53.740
There's not a huge difference,
but it can make a big difference

00:35:53.760 --> 00:35:55.850
ultimately in your performance.

00:35:56.100 --> 00:36:12.100
[Transcript missing]

00:36:13.930 --> 00:36:16.950
Okay, so looking at how to
potentially optimize OpenGL,

00:36:17.060 --> 00:36:20.540
I've got a number of slides here
to just basically walk through the

00:36:20.650 --> 00:36:24.020
process that everyone should look
at when they're trying to figure

00:36:24.020 --> 00:36:27.550
out how to simplify their code
and how to make it more optimal.

00:36:27.800 --> 00:36:32.300
So we start off with a basic loop
that is going through setting

00:36:32.400 --> 00:36:35.570
up a smooth shaded color mode,
setting up a color,

00:36:35.570 --> 00:36:36.800
and then drawing a triangle.

00:36:36.800 --> 00:36:38.800
So we're doing this every
time through the loop.

00:36:38.800 --> 00:36:42.800
So we're drawing one triangle,
we're doing a state change per triangle,

00:36:43.030 --> 00:36:46.800
and obviously we're not going to
get a lot of data through this

00:36:46.800 --> 00:36:50.800
because it breaks every rule we have,
and that is you're doing state

00:36:50.800 --> 00:36:54.880
changes and you're not passing
a lot of data per begin end.

00:36:55.550 --> 00:36:59.600
So the first thing we do is remove the
state changes out of the loop and that

00:36:59.880 --> 00:37:04.060
will obviously give you the benefit
that now we're passing a lot of data

00:37:04.060 --> 00:37:07.070
and we're not changing the state and
we're not causing OpenGL to have to

00:37:07.070 --> 00:37:08.730
do a lot of state management below.

00:37:08.730 --> 00:37:13.060
But we still haven't pulled any,
done any optimizations with

00:37:13.130 --> 00:37:15.500
how we're passing vertex data.

00:37:15.500 --> 00:37:20.380
So the next thing we do then is, well,
actually we simplify the state.

00:37:20.490 --> 00:37:22.500
And we simplify it by just
going to a flat shaded.

00:37:22.500 --> 00:37:25.460
So we notice that we're not
passing a color per vertex,

00:37:25.840 --> 00:37:28.310
meaning the color is
flat shaded triangles.

00:37:28.380 --> 00:37:30.500
So we're going to change that to flat.

00:37:30.500 --> 00:37:35.230
But then we pull the triangles out of the
loop and that's an attempt to maximize

00:37:35.230 --> 00:37:37.500
the amount of data per begin end.

00:37:37.500 --> 00:37:42.270
And by doing this we can increase
the performance by quite a bit.

00:37:42.500 --> 00:37:44.560
And in fact after this I have
another demonstration to

00:37:44.580 --> 00:37:45.470
show you the effect of this.

00:37:45.570 --> 00:37:47.500
So you can see the effect of that.

00:37:47.500 --> 00:37:50.850
It can be pretty dramatic
just doing that step alone.

00:37:51.350 --> 00:37:57.430
Then what we do is we try to simplify
the API that we're utilizing.

00:37:57.440 --> 00:37:59.190
Instead of passing all the
data through registers,

00:37:59.190 --> 00:38:03.650
we pass a vertex--a pointer to the data,
and it allows OpenGL to potentially

00:38:03.650 --> 00:38:05.100
optimize how it's copying the data.

00:38:05.590 --> 00:38:10.240
You're not doing a lot of register
setup to get the data through.

00:38:10.930 --> 00:38:13.450
Then we take the step of
realizing that what we're actually

00:38:13.450 --> 00:38:14.800
passing is a triangle strip.

00:38:14.800 --> 00:38:17.610
So we change the data type
to a triangle strip and we

00:38:17.620 --> 00:38:19.800
reorganize how we're passing it.

00:38:19.830 --> 00:38:22.830
And so now we've just reduced
the amount of data going to

00:38:23.090 --> 00:38:24.560
OpenGL by a factor of three.

00:38:24.690 --> 00:38:29.030
Again, getting a big performance boost
out of doing a step like that.

00:38:30.490 --> 00:38:36.210
And then what we do is we realize that we
have all the data actually in an array,

00:38:36.370 --> 00:38:40.260
so we start using a vertex
array and using draw elements

00:38:40.260 --> 00:38:42.380
to draw out of that array.

00:38:42.380 --> 00:38:45.130
So now we've eliminated
the loop altogether,

00:38:45.290 --> 00:38:48.950
and we are simply making five function
calls to handle all the drawing,

00:38:49.030 --> 00:38:51.330
whereas if we looked at the
beginning of the slides,

00:38:51.420 --> 00:38:55.510
we were probably making
hundreds or thousands.

00:38:55.520 --> 00:38:57.640
So we've eliminated all
the function call overhead,

00:38:57.640 --> 00:39:01.100
and we have given OpenGL an opportunity
to try to optimize internally

00:39:01.100 --> 00:39:07.120
for how it's going to want to
get the data into the command stream.

00:39:07.150 --> 00:39:10.710
So now I have another demo
showing some of that effect.

00:39:14.200 --> 00:39:20.500
[Transcript missing]

00:39:21.770 --> 00:39:28.210
So what this demo is is a
spherical mapped mesh that is

00:39:28.250 --> 00:39:31.180
being animated with a wave motion.

00:39:31.220 --> 00:39:36.300
And where we start this application
right now is in a mode where the

00:39:36.600 --> 00:39:40.400
application hasn't been tuned and
the rendering hasn't been tuned.

00:39:40.470 --> 00:39:43.360
And the way we can tell that is
that the red bar represents the

00:39:43.390 --> 00:39:45.720
time being spent in the application.

00:39:45.750 --> 00:39:50.660
The green bar simulates the time being
spent calculating the wave motion.

00:39:50.660 --> 00:39:53.620
And the blue bar is the
time being spent in OpenGL.

00:39:53.700 --> 00:39:57.530
So we can see we're spending
quite a bit of time in all these,

00:39:57.530 --> 00:39:59.740
we're spending most of the
time in the application.

00:39:59.820 --> 00:40:04.520
So a little experiment that's interesting
to run is if I take this application

00:40:04.520 --> 00:40:08.690
tuning slider and I bump it all the way
up so that the application becomes tuned,

00:40:08.810 --> 00:40:14.160
we can see we get about-- we go from
20 frames per second almost to 40.

00:40:14.480 --> 00:40:17.500
So we almost double our
frame rate by doing that.

00:40:18.300 --> 00:40:21.740
So now if I move this slide over here,
which simulates optimizing OpenGL through

00:40:21.740 --> 00:40:25.220
the basic steps I just went through,
the first one is individual triangles.

00:40:25.220 --> 00:40:33.420
The second one here has now moved
the begin end outside the loop,

00:40:33.570 --> 00:40:35.930
and it's passing as much data
as possible per begin end.

00:40:36.100 --> 00:40:40.580
So we can see that we immediately
get some performance out of that.

00:40:40.780 --> 00:40:44.760
We can see the blue bar is
changing by about a factor or two.

00:40:45.650 --> 00:40:48.310
But our OpenGL performance
hasn't changed a whole lot.

00:40:48.350 --> 00:40:51.030
It only went up about five frames.

00:40:51.040 --> 00:40:53.060
So by doing that step,
we didn't get a whole lot.

00:40:53.080 --> 00:40:55.860
Now if we go to the top one,
that's using vertex arrays.

00:40:55.880 --> 00:40:57.940
And again, it didn't change a whole lot.

00:41:00.710 --> 00:41:03.460
The interesting thing to learn about
this is that if we take the slider

00:41:03.460 --> 00:41:07.270
and we move it up for the application,
now we realize that we have

00:41:07.270 --> 00:41:12.700
gotten 100% improvement on just
optimizing the application.

00:41:12.700 --> 00:41:16.020
So optimizing one or the
other only got us a marginal

00:41:16.770 --> 00:41:20.700
improvement to a 2x improvement,
but if I optimize both,

00:41:20.700 --> 00:41:25.700
I go from 20 frames a second to 60,
so I get a 3x improvement.

00:41:25.700 --> 00:41:27.640
So the combined effect is very important.

00:41:27.720 --> 00:41:33.120
So it's important to realize that
where the time is being spent

00:41:33.340 --> 00:41:36.480
can be the application or OpenGL.

00:41:36.700 --> 00:41:40.390
So the second thing we can do then is,
like we've been showing here,

00:41:40.430 --> 00:41:41.530
is to spawn a thread.

00:41:41.700 --> 00:41:45.510
Now if we spawn a thread and we
move the green bar onto the thread,

00:41:45.680 --> 00:41:51.660
we can see that now we are
utilizing both CPUs in this machine.

00:41:51.860 --> 00:41:54.700
This machine is a dual 500.

00:41:54.700 --> 00:41:57.840
So now we are animating
at 200 frames a second,

00:41:57.840 --> 00:41:59.640
and we started off at 20.

00:41:59.700 --> 00:42:03.290
So we got a 10x improvement out of this.

00:42:03.620 --> 00:42:08.110
And so now it's animating silky smooth,
whereas before it was barely

00:42:08.110 --> 00:42:12.300
crawling along at 20 frames a second.

00:42:12.320 --> 00:42:15.860
So this is a good example of,
a basic example of where you

00:42:15.860 --> 00:42:20.340
can start from a pretty dismal
performance and do some simple things,

00:42:20.420 --> 00:42:26.400
and all of a sudden the whole application
comes alive and you're getting 1.5

00:42:26.400 --> 00:42:36.390
million triangles a second and able
to deliver a much better application.

00:42:45.720 --> 00:42:51.990
Okay, so now we've kind of talked
about the application setup.

00:42:52.290 --> 00:42:54.680
Basically how to drive OpenGL.

00:42:54.680 --> 00:42:59.800
And all those things are
fundamentally CPU-oriented operations.

00:42:59.800 --> 00:43:05.100
And that's a process of optimizing how
effectively you're utilizing the CPU.

00:43:05.100 --> 00:43:08.260
So now we're going to talk about
per-fragment operations a little bit.

00:43:08.260 --> 00:43:11.870
Per-fragment operations are fundamentally
what the graphics card's going to

00:43:11.870 --> 00:43:16.500
have to do to convert your data from
a triangle to the image that you,

00:43:16.510 --> 00:43:18.640
into the frame buffer.

00:43:18.640 --> 00:43:22.840
And what types of blending or
texturing operations need to be done.

00:43:22.980 --> 00:43:26.020
And there's a few things just to
keep in mind while you're doing this,

00:43:26.150 --> 00:43:28.240
while you're programming.

00:43:28.240 --> 00:43:32.380
One is to utilize multi-texture
instead of multi-pass.

00:43:32.380 --> 00:43:37.800
So basically all the graphics
cards on OS X that are accelerated

00:43:37.800 --> 00:43:41.260
on OS X today have multi-texture,
multiple texture units.

00:43:41.260 --> 00:43:44.530
So if you want to apply two textures,
let's say, you can do it in one pass.

00:43:44.530 --> 00:43:47.360
You can load two textures,
one in texture unit zero and

00:43:47.360 --> 00:43:50.010
one in the texture unit one,
and you can apply both

00:43:50.590 --> 00:43:51.980
textures simultaneously.

00:43:51.980 --> 00:43:54.060
And this actually has two benefits.

00:43:54.180 --> 00:43:56.880
One is that, again,
lowers the CPU overhead because your

00:43:56.880 --> 00:44:00.580
application's not having to loop
through the rendering twice and reissue

00:44:00.580 --> 00:44:03.450
drawing commands to do the second pass.

00:44:03.500 --> 00:44:06.640
But the second one is,
is that it helps the graphics card

00:44:06.640 --> 00:44:11.350
optimize its memory traffic because
you're not writing to the frame buffer on

00:44:11.570 --> 00:44:15.660
one pass and then having to come back on
a second pass and write the pixel again.

00:44:15.880 --> 00:44:18.170
Instead, you're allowing the app,
the graphics card to read two

00:44:18.170 --> 00:44:18.700
textiles out of the frame buffer
and then come back on the second

00:44:18.730 --> 00:44:18.840
pass and write the pixel again.

00:44:18.840 --> 00:44:18.840
Instead, you're allowing the app,
the graphics card to read two

00:44:18.840 --> 00:44:22.290
textiles out of the texture units,
out of the textures you've defined,

00:44:22.510 --> 00:44:25.160
combine them and write it
once out of the frame buffer.

00:44:25.160 --> 00:44:29.400
So it lowers the ultimate bandwidth that
you're consuming on the graphics card.

00:44:29.400 --> 00:44:31.910
So you can,
you can get performance a couple

00:44:31.920 --> 00:44:37.140
ways by going to a multi-texture
instead of multi-pass.

00:44:37.140 --> 00:44:41.990
So avoid, when possible,
obviously anything I'm gonna say here

00:44:42.230 --> 00:44:46.170
is just a suggestion of things to try
to work your way around and sometimes

00:44:46.300 --> 00:44:48.640
you're looking for an effect and
you have to do these operations.

00:44:48.680 --> 00:44:48.680
But, you know, I'm not gonna say that
you should do this.

00:44:48.680 --> 00:44:48.680
I'm not gonna say that
you should do this.

00:44:48.680 --> 00:44:48.680
I'm not gonna say that
you should do this.

00:44:48.680 --> 00:44:48.680
I'm not gonna say that
you should do this.

00:44:48.680 --> 00:44:48.780
I'm not gonna say that
you should do this.

00:44:48.780 --> 00:44:52.780
But avoid read, modify,
write operations on the frame buffer.

00:44:52.780 --> 00:44:55.930
So read, modify,
write operations are anything that will,

00:44:55.990 --> 00:45:01.560
requires the frame buffer value
to participate in the value that,

00:45:01.560 --> 00:45:08.020
participate in the color calculation
that will result and be finally

00:45:08.120 --> 00:45:09.720
put back into the frame buffer.

00:45:09.810 --> 00:45:12.080
So things that do that are blending.

00:45:12.120 --> 00:45:15.550
So if you're blending with the final
destination of the frame buffer,

00:45:15.550 --> 00:45:18.720
it's gonna have to read the frame buffer,
it's gonna have to read its text.

00:45:18.720 --> 00:45:18.720
It's gonna have to read the text.

00:45:18.720 --> 00:45:19.060
It's gonna have to read the textures.

00:45:19.060 --> 00:45:21.260
It's gonna have to combine it
all and then write it back out.

00:45:21.440 --> 00:45:25.410
So you're gonna get 2x the bandwidth.

00:45:25.500 --> 00:45:53.300
[Transcript missing]

00:45:57.040 --> 00:46:01.760
Okay, another thing that's important
to keep in mind is that modern

00:46:01.770 --> 00:46:06.500
graphics cards have the ability
to do high-level culling for you.

00:46:06.500 --> 00:46:11.160
So if you're drawing lots of triangles,
it can, ahead of time,

00:46:11.160 --> 00:46:12.750
cull those triangles out.

00:46:12.760 --> 00:46:18.240
And it's called Hierarchical Z.

00:46:18.240 --> 00:46:18.240
And Hierarchical Z will

00:46:18.400 --> 00:47:11.100
[Transcript missing]

00:47:12.870 --> 00:47:15.620
So, some of this is a review.

00:47:15.620 --> 00:47:18.080
We're going to talk about
OpenGL extensions and what

00:47:18.080 --> 00:47:19.820
OpenGL extensions can help you.

00:47:19.840 --> 00:47:22.190
We already talked about
CompileVertexArray,

00:47:22.200 --> 00:47:26.240
but just to review really quickly,
this is good for a large

00:47:26.310 --> 00:47:27.840
number of vertices.

00:47:27.840 --> 00:47:29.470
It reduces the number of transformations.

00:47:29.500 --> 00:47:31.620
It reduces memory traffic.

00:47:31.620 --> 00:47:35.520
It allows OpenGL to pre-compile
data into an AGP buffer ready

00:47:35.520 --> 00:47:37.390
for transmitting to the card.

00:47:37.400 --> 00:47:40.520
So, whenever possible, again,
use CompileVertexArray.

00:47:41.480 --> 00:47:42.300
Texture compression.

00:47:42.300 --> 00:47:44.940
Texture compression is also
a very good extension to use.

00:47:44.940 --> 00:47:50.370
It allows you to minimize the
system memory bandwidth of

00:47:50.430 --> 00:47:51.560
moving that texture around.

00:47:51.560 --> 00:47:53.700
It saves you system memory itself.

00:47:53.900 --> 00:47:57.740
It saves the bandwidth of moving
that texture up to the graphics card.

00:47:57.740 --> 00:48:01.120
And it also saves,
can benefit the graphics card

00:48:01.270 --> 00:48:07.340
itself by lowering the bandwidth
it takes to read the texture,

00:48:07.340 --> 00:48:11.890
a text will out,
and to render with it because it will

00:48:11.890 --> 00:48:16.860
do on the fly texture decompression
and it will better utilize the on

00:48:16.860 --> 00:48:18.810
cache memory on the graphics card.

00:48:18.820 --> 00:48:21.350
So, texture compression can be effective.

00:48:21.360 --> 00:48:24.900
It's really going to depend
on where your limitations,

00:48:24.900 --> 00:48:28.140
where your performance bottlenecks
are in your application,

00:48:28.140 --> 00:48:30.080
but it's a good one to keep in mind.

00:48:31.460 --> 00:48:35.470
Multitexture is the extension
for doing multitexturing,

00:48:35.470 --> 00:48:40.180
like we'd mentioned,
utilizing more than one texture unit.

00:48:40.520 --> 00:48:45.800
Apple Pack Pixel, again,
is the extension for the best way

00:48:45.800 --> 00:48:52.400
to pass pixel data to OpenGL and
allows you to get the most data,

00:48:52.400 --> 00:48:58.020
the best bandwidth utilization of
moving pixel data to the OpenGL system.

00:48:58.480 --> 00:49:00.400
And the other thing it does
actually is it saves system memory.

00:49:00.400 --> 00:49:04.960
So if you're able to store a texture in a
more optimal format for your application,

00:49:05.040 --> 00:49:10.640
let's say 1555,
obviously that's going to be half the

00:49:10.640 --> 00:49:16.020
memory utilization of an eight component,
eight bits per component texture.

00:49:16.160 --> 00:49:20.660
So that will give you some
system memory savings,

00:49:20.660 --> 00:49:24.760
some bandwidth savings,
and it'll also save video

00:49:24.760 --> 00:49:24.760
memory on the graphics card.

00:49:26.500 --> 00:49:28.280
So, quick summary.

00:49:28.530 --> 00:49:32.960
So, again,
going over some of the priorities.

00:49:33.250 --> 00:49:35.620
So,
the thing we always tell people is they,

00:49:35.750 --> 00:49:39.130
again, need to optimize their
application because 75% of the

00:49:39.130 --> 00:49:44.390
time is typically spent in the
application and 25% in OpenGL.

00:49:44.470 --> 00:49:48.310
So, optimizing your application is
going to be important and you won't

00:49:48.310 --> 00:49:52.400
get good performance until you've
gotten that to an acceptable level.

00:49:52.580 --> 00:49:55.400
Scale your application
to the target platform.

00:49:55.400 --> 00:49:59.400
Try to determine your VRAM,
how much video memory is available.

00:49:59.400 --> 00:50:02.400
Determine how much system
memory is available.

00:50:02.400 --> 00:50:05.080
Try to stay within acceptable
bounds that won't cause the

00:50:05.200 --> 00:50:06.400
system memory to go into paging.

00:50:06.400 --> 00:50:09.940
Determine maybe the number of
texture units on the graphics card

00:50:09.940 --> 00:50:13.240
so that you can do multi-texturing
instead of multi-pass.

00:50:13.240 --> 00:50:15.400
Look at your CPU type.

00:50:15.400 --> 00:50:19.080
Try to utilize a number of
OpenGL extensions that will help simplify

00:50:19.130 --> 00:50:21.390
how the data is being passed to OpenGL.

00:50:21.470 --> 00:50:22.390
So, that's the first thing.

00:50:22.480 --> 00:50:26.400
As well as potentially
give you better effects.

00:50:26.400 --> 00:50:30.100
Allow the user to adjust the graphic
settings such that if the user is

00:50:30.100 --> 00:50:34.400
experiencing problems on a particular
platform for one reason or another,

00:50:34.400 --> 00:50:40.070
allowing the user to vary the
quality settings such that they can

00:50:40.130 --> 00:50:44.350
get the performance that they are
looking for obviously is going to be

00:50:44.350 --> 00:50:46.400
a friendly thing to do for the user.

00:50:46.400 --> 00:50:49.620
It will give the user control
over some of the aspects of

00:50:49.620 --> 00:50:51.390
how the application runs.

00:50:51.400 --> 00:50:52.400
Okay.

00:50:53.060 --> 00:50:57.860
So for more information,
there's two good books on OpenGL.

00:50:57.880 --> 00:50:59.820
And anybody that's
doing OpenGL programming

00:50:59.860 --> 00:51:01.590
should have these books.

00:51:01.600 --> 00:51:05.440
One is the OpenGL programming guide,
and the other one is

00:51:05.440 --> 00:51:07.400
the reference manual.

00:51:07.480 --> 00:51:08.510
So these books are invaluable.

00:51:08.510 --> 00:51:09.950
They're very well written.

00:51:09.980 --> 00:51:14.230
And if you're just starting
OpenGL or whether you're an expert,

00:51:14.230 --> 00:51:18.780
these books are always sitting
right next to me on my desk.

00:51:19.070 --> 00:51:23.150
So for online help,
there's some good resources.

00:51:23.150 --> 00:51:27.100
You'll want to go to www.opengl.org.

00:51:27.100 --> 00:51:32.130
This is the official OpenGL web page,
and it's got all kinds of

00:51:32.140 --> 00:51:34.990
neat news announcements,
resources.

00:51:35.020 --> 00:51:38.000
It has lists of applications
that are utilizing OpenGL,

00:51:38.410 --> 00:51:40.000
documentation.

00:51:40.170 --> 00:51:44.850
It's got all the resources
you'll need for finding out

00:51:44.850 --> 00:51:47.000
what's the latest in OpenGL.

00:51:47.000 --> 00:51:52.730
And then there's the lists at apple.com
where you can join the Apple OpenGL list,

00:51:52.740 --> 00:51:57.690
and there's lots of Macintosh-specific
discussions going on in that list

00:51:58.220 --> 00:52:03.180
where you can participate or learn
from some of the discussions that

00:52:03.190 --> 00:52:06.820
are going on there or send an email
of your own and ask a particularly

00:52:06.830 --> 00:52:10.510
difficult problem that you need answered.

00:52:12.140 --> 00:52:16.010
And lastly,
we met Sergio at the beginning here,

00:52:16.260 --> 00:52:19.800
so if you have any questions
about OpenGL at Apple,

00:52:19.800 --> 00:52:21.450
you can contact Sergio.

00:52:21.490 --> 00:52:24.360
And here's his contact information.

00:52:24.590 --> 00:52:29.100
Sergio is our product
representative at Apple,

00:52:29.180 --> 00:52:37.130
and he can direct you to somebody in
Apple if he's not the right person or

00:52:37.130 --> 00:52:38.330
help you with some of your product needs.

00:52:40.230 --> 00:52:44.460
And lastly, we have--after this session,
we have advanced

00:52:44.460 --> 00:52:46.930
OpenGL rendering techniques.

00:52:47.040 --> 00:52:50.800
It's a very interesting
presentation that will go into

00:52:51.390 --> 00:52:55.100
utilizing some OpenGL extensions
for doing advanced rendering.

00:52:55.130 --> 00:53:01.040
I highly suggest it for people that
are looking for new techniques and some

00:53:01.420 --> 00:53:03.990
capabilities of graphics cards today.

00:53:04.090 --> 00:53:09.600
It'll show you some interesting
demos and some nice effects.
WEBVTT

00:00:05.190 --> 00:00:10.080
Thank you and welcome to session 116,
Mac OS file systems.

00:00:10.220 --> 00:00:13.990
The Mac OS has supported multiple
file systems for a long time now,

00:00:13.990 --> 00:00:18.000
and now with the UNIX foundation in OS X,
we support a whole

00:00:18.000 --> 00:00:20.370
plethora of file systems.

00:00:20.450 --> 00:00:23.060
And to tell you all about those
different file systems and

00:00:23.080 --> 00:00:27.070
how you should be using them,
I'd like to introduce the manager

00:00:27.070 --> 00:00:31.010
of the Core OS file systems group,
Clark Warner.

00:00:34.820 --> 00:00:35.960
I'm really glad to see all of you here.

00:00:35.960 --> 00:00:37.800
I know it's early and
I appreciate your coming.

00:00:37.800 --> 00:00:40.180
I hope we're going to have some
very useful information for you

00:00:40.180 --> 00:00:42.640
about the Mac OS X file system.

00:00:42.640 --> 00:00:43.640
We'll start with this.

00:00:43.720 --> 00:00:46.080
A welcome and a little idea
of some of the stuff that

00:00:46.080 --> 00:00:47.560
we're going to cover today.

00:00:47.560 --> 00:00:49.440
We're not going to talk
as much about futures,

00:00:49.440 --> 00:00:50.100
obviously.

00:00:50.230 --> 00:00:52.880
You've probably heard that as a theme
throughout the developers conference.

00:00:53.020 --> 00:00:55.980
The present is so much
more exciting this year.

00:00:55.980 --> 00:00:58.560
And we're not going to talk as much about
file system internals because we know

00:00:58.580 --> 00:01:02.800
that a lot of you are now in the process
of bringing your apps over to Mac OS X.

00:01:02.800 --> 00:01:04.870
So we're going to concentrate
on some of the things that your

00:01:04.870 --> 00:01:08.040
apps need to be prepared for when
they're using the file system.

00:01:08.040 --> 00:01:10.230
As Jason mentioned,
we have a number of different file

00:01:10.230 --> 00:01:13.980
systems in Mac OS X and they do
present some occasional wrinkles.

00:01:13.980 --> 00:01:16.110
We also are going to give you
some tips into how to improve

00:01:16.110 --> 00:01:18.690
the performance of your app,
especially with regard when

00:01:18.780 --> 00:01:20.490
it's--to its use of the file system.

00:01:20.530 --> 00:01:25.000
But we will talk a little bit about
some of the key issues in building file

00:01:25.000 --> 00:01:27.910
systems yourself to add to Mac OS X.

00:01:27.980 --> 00:01:30.400
If you went to the Darwin overview
session or probably any

00:01:30.400 --> 00:01:32.820
of the Core OS sessions,
you've seen this chart already.

00:01:32.820 --> 00:01:34.950
This is the key "You are here" graphic.

00:01:35.190 --> 00:01:38.660
If we were on an airplane now, you know,
we'd be saying, "This is to San Jose.

00:01:38.730 --> 00:01:41.620
If you're going to Hawaii,
get off now." We are part of the

00:01:41.620 --> 00:01:43.630
BSD kernel inside of the file system.

00:01:43.860 --> 00:01:47.020
Here's a blowup of what the file
system looks like internally.

00:01:47.020 --> 00:01:49.990
We support, basically,
at the Core OS level, the BSD,

00:01:50.130 --> 00:01:53.350
Berkeley Standard Software Distribution
System calls,

00:01:53.370 --> 00:01:54.860
with some extensions.

00:01:54.860 --> 00:01:56.860
Inside of the file system,
there is a big switch we call

00:01:56.880 --> 00:02:00.360
the virtual file system layer,
which separates the part of the file

00:02:00.360 --> 00:02:02.820
system which is dependent on the
underlying volume format or network.

00:02:02.820 --> 00:02:06.050
The network protocol from the part of
the file system which is independent.

00:02:06.190 --> 00:02:08.700
So the stuff above the
VFS layer is independent.

00:02:08.700 --> 00:02:10.240
The stuff below is dependent.

00:02:10.240 --> 00:02:13.010
And that's why you see our list
of file systems below underneath

00:02:13.120 --> 00:02:16.180
the virtual file system switch,
UFS, HFS, NFS.

00:02:16.180 --> 00:02:18.220
And we'll talk to you about
all of the various file systems

00:02:18.220 --> 00:02:19.720
that are supported in Mac OS X.

00:02:21.450 --> 00:02:23.090
Here's the outline of today's talk.

00:02:23.200 --> 00:02:27.080
There'll be something of a status update,
basically an indication of

00:02:27.080 --> 00:02:28.130
the file systems that we ship.

00:02:28.270 --> 00:02:30.590
We're going to do a demo of
a couple of the new ones.

00:02:30.600 --> 00:02:32.520
We're going to talk only
briefly about some of the

00:02:32.580 --> 00:02:34.130
different file system interfaces.

00:02:34.140 --> 00:02:36.700
We've covered that in a number
of years and there are a lot of

00:02:36.700 --> 00:02:39.930
sessions describing the application
frameworks for use in Mac OS X.

00:02:39.930 --> 00:02:43.370
But we will spend a fair amount of
time talking about the differences

00:02:43.370 --> 00:02:46.320
between the various file systems
that Mac OS X supports and

00:02:46.320 --> 00:02:49.630
again how that might affect
your application development.

00:02:50.080 --> 00:02:53.970
We'll talk about security because that's
been a large issue for a lot of folks.

00:02:54.280 --> 00:02:57.930
Mac OS X is a multi-user system with
per level file permissions and in that

00:02:58.000 --> 00:03:01.650
way it differs greatly from Mac OS 9
and you need to be ready for permissions

00:03:01.650 --> 00:03:03.670
errors potentially in your applications.

00:03:03.760 --> 00:03:06.380
We're going to talk about performance
considerations as I mentioned

00:03:06.380 --> 00:03:08.770
and we'll talk a little bit
about building new file systems.

00:03:08.780 --> 00:03:12.060
First status slide,
I think this is my third or fourth

00:03:12.060 --> 00:03:17.050
Worldwide Developers Conference session
talking about the interesting things

00:03:17.050 --> 00:03:18.860
we were going to do in Mac OS X.

00:03:18.870 --> 00:03:21.120
And the recent things we
had done in interim build A,

00:03:21.130 --> 00:03:22.580
B and so forth.

00:03:22.610 --> 00:03:25.610
This is the first time I get to say this.

00:03:30.200 --> 00:03:35.300
[Transcript missing]

00:03:36.850 --> 00:03:37.940
This is why I love this crowd.

00:03:37.940 --> 00:03:40.900
All right, so Mac OS X.

00:03:40.900 --> 00:03:44.080
We have three primary file systems.

00:03:44.080 --> 00:03:46.530
And when we say primary,
what we mean is they're fully

00:03:46.530 --> 00:03:49.630
read and write file systems,
and we can boot and root off of them.

00:03:49.640 --> 00:03:53.360
So we can boot and root off of the
Mac OS Extended Format File System,

00:03:53.360 --> 00:03:57.740
best known to those who know and love it
as HFS+. We can boot and root off of UFS,

00:03:57.760 --> 00:04:02.340
the Unix file system that we support
based on the Berkeley FAST file system.

00:04:02.340 --> 00:04:04.040
And we can boot and root off of NFS.

00:04:04.110 --> 00:04:06.220
In fact, we do that internally all
the time for installs.

00:04:06.700 --> 00:04:09.080
We also have some read and
write file systems that we

00:04:09.080 --> 00:04:12.300
don't boot and root off of,
but are otherwise first-class citizens.

00:04:12.300 --> 00:04:14.730
And that includes the
Mac OS Standard Format,

00:04:14.730 --> 00:04:17.290
otherwise known as HFS,
for legacy data that you

00:04:17.290 --> 00:04:18.530
may have on your Mac.

00:04:18.590 --> 00:04:22.710
The Apple File Protocol, an AFP client,
was delivered by the

00:04:22.790 --> 00:04:24.760
server team into Mac OS X.

00:04:24.760 --> 00:04:28.440
We have support for MS-DOS file system,
and specifically we mean

00:04:28.490 --> 00:04:31.540
FAT16 and FAT32 here,
which we did largely for

00:04:31.600 --> 00:04:34.720
digital cameras and so forth,
but also zip drives and removal

00:04:34.720 --> 00:04:36.670
media coming from your DOS machine.

00:04:36.680 --> 00:04:39.640
And WebDAV,
and we'll talk about WebDAV in more

00:04:39.640 --> 00:04:42.280
detail a little bit later on in the talk.

00:04:42.350 --> 00:04:45.940
There are also some read-only file
systems supported in Mac OS X,

00:04:45.950 --> 00:04:49.490
including ISO 9660,
which is used on lots of CD formats,

00:04:49.490 --> 00:04:52.200
especially to interchange
between Mac and Windows.

00:04:52.200 --> 00:04:54.350
We support the Universal Disk Format.

00:04:54.380 --> 00:04:55.860
Actually,
I don't think it's called that anymore.

00:04:55.860 --> 00:04:58.700
I think they just use the initials UDF,
sort of like KFC in

00:04:58.880 --> 00:05:00.160
Kentucky Fried Chicken.

00:05:00.160 --> 00:05:06.180
And CDDAFS, a file system written by the
CPU Software Group to support CD audio,

00:05:06.760 --> 00:05:10.270
CD audio drives, CD audio disks, rather,
music.

00:05:10.320 --> 00:05:14.220
ISO 9660, I should mention,
we can also boot and root from.

00:05:14.280 --> 00:05:18.010
I didn't mention it in the primary file
systems because it's not read and write.

00:05:18.240 --> 00:05:20.340
So I'm going to do a demo.

00:05:20.340 --> 00:05:21.820
I'd like to bring up
demo machine number one.

00:05:22.050 --> 00:05:25.730
And I'd also like to bring up my
lovely and talented assistant,

00:05:25.730 --> 00:05:26.900
Scott Roberts.

00:05:30.390 --> 00:05:33.300
You might have seen a demo
similar to this in the keynote.

00:05:33.300 --> 00:05:36.300
Avi got his digital camera up and
took a picture of the audience.

00:05:36.360 --> 00:05:39.000
I'm going to have Scott do
the same thing here.

00:05:42.180 --> 00:05:43.880
Thank you, Scott.

00:05:44.150 --> 00:05:47.160
Now,
it turns out I'm not a vice president.

00:05:47.210 --> 00:05:50.640
And as a result, I don't make as much
money as Avi Tavanian.

00:05:50.670 --> 00:05:53.730
And so I can't afford a really
nice fancy digital camera that has

00:05:53.730 --> 00:05:55.800
USB hot plug and so forth and so on.

00:05:55.860 --> 00:06:00.060
I have this camera that was given to me
as a gift by a friend of mine actually,

00:06:00.060 --> 00:06:03.590
a Kodak DC210+. And-- But the nice thing,
although it doesn't have

00:06:03.630 --> 00:06:07.060
USB connectivity and all that,
it does have this little compact flash

00:06:07.060 --> 00:06:08.920
card that it uses for memory storage.

00:06:09.090 --> 00:06:11.280
And we happen to have--

00:06:11.660 --> 00:06:14.790
A sand disk reader here
attached to our demo machine.

00:06:14.790 --> 00:06:18.760
And so I'm going to put
this little card in here.

00:06:18.760 --> 00:06:20.870
Let's pray a little bit.

00:06:22.530 --> 00:06:24.420
and you'll see the image
come up on the system.

00:06:24.420 --> 00:06:27.200
Now we're doing something differently
than Avi did because we're not here

00:06:27.200 --> 00:06:30.340
to show you image capture or any
of the fancy camera applications.

00:06:30.340 --> 00:06:32.990
I just want you to know that
this little compact flash card

00:06:33.320 --> 00:06:36.170
is formatted as an MS-DOS disk.

00:06:36.180 --> 00:06:40.040
And so we're looking at an MS-DOS volume
that's just loaded on our desktop.

00:06:40.070 --> 00:06:43.290
And if I bring up the
preview application,

00:06:46.200 --> 00:06:50.600
And I go here to the image that
Scott just took and open it up.

00:06:50.640 --> 00:06:52.720
There's a picture of you folks.

00:06:59.100 --> 00:07:00.240
I must have said something wrong.

00:07:00.240 --> 00:07:06.100
I don't know what.

00:07:06.780 --> 00:07:08.020
Okay.

00:07:08.020 --> 00:07:11.380
For our other demo, I wanted to show you
the WebDAV file system.

00:07:11.380 --> 00:07:14.340
I've got over here on
my other demo machine,

00:07:14.350 --> 00:07:16.880
I pre-configured it as a web server.

00:07:16.880 --> 00:07:21.250
I actually changed the configuration
file so that it would run the DAV module

00:07:21.330 --> 00:07:25.680
that actually ships in Mac OS X as
part of our Apache installation.

00:07:25.680 --> 00:07:32.080
So, host 2.162 is running WebDAV and I'm
going to bring up Internet Explorer here,

00:07:32.090 --> 00:07:32.890
which I should have pre-launched.

00:07:32.890 --> 00:07:37.580
Sorry to waste your folks' time.

00:07:37.580 --> 00:07:43.770
And I'm going to type in the URL.

00:07:49.720 --> 00:07:52.200
And you can see we have
our little Apache page.

00:07:52.240 --> 00:07:55.520
Now what I'm going to do is,
since I'm bored with looking

00:07:55.520 --> 00:07:57.870
at things in web browsers,
I'm going to mount this

00:07:57.870 --> 00:08:00.560
particular website as if it
were a volume on my desktop.

00:08:00.570 --> 00:08:04.380
I do that by hitting Command-K,
going to the Connect to Server dialog,

00:08:04.380 --> 00:08:07.740
and typing in the URL here instead.

00:08:13.130 --> 00:08:16.220
And now you notice I now have
the Apache website actually

00:08:16.220 --> 00:08:18.220
mounted as a volume on my desktop.

00:08:18.240 --> 00:08:19.660
Why is that interesting?

00:08:19.670 --> 00:08:22.140
Let me show you one thing that we can do.

00:08:22.160 --> 00:08:26.000
We took a movie,
actually last year's file system session,

00:08:26.050 --> 00:08:28.100
and we edited it and made
a small movie out of it.

00:08:28.100 --> 00:08:29.680
And we put it on the web server.

00:08:29.700 --> 00:08:32.270
And now instead of going to the
browser and trying to deal with

00:08:32.340 --> 00:08:35.890
the QuickTime plugins and so forth,
I'm just going to double click that

00:08:36.240 --> 00:08:37.460
movie and we'll show it for you now.

00:08:43.100 --> 00:08:45.730
Let me back it up a little bit here.

00:08:54.200 --> 00:08:57.200
Thank you.

00:08:57.240 --> 00:08:59.830
The stage police are watching me.

00:09:00.790 --> 00:09:07.110
And I've heard from my spies that when
I turn around to jump on the stage,

00:09:07.220 --> 00:09:08.340
something bad is going to happen to me.

00:09:08.470 --> 00:09:09.780
So I have to be careful.

00:09:09.780 --> 00:09:11.940
I've noticed that the stage
is higher this year than last,

00:09:11.940 --> 00:09:14.260
so I think I'm ready.

00:09:21.500 --> 00:09:25.260
I'm getting older.

00:09:25.260 --> 00:09:27.960
I can't do this kind of stuff every year.

00:09:29.300 --> 00:09:32.540
Okay, let me show you one more thing
that I think is pretty interesting.

00:09:32.830 --> 00:09:33.960
I'm going to go into BBEdit here.

00:09:33.960 --> 00:09:36.840
Now I haven't actually
completely rehearsed this demo.

00:09:36.840 --> 00:09:38.200
I was fooling around
with it before the show,

00:09:38.200 --> 00:09:40.080
but I thought it would be kind
of an interesting thing to do.

00:09:40.140 --> 00:09:44.070
So I'm going to bring up BBEdit
and I'm going to open up a

00:09:44.070 --> 00:09:46.030
file on the WebDAV server.

00:09:47.430 --> 00:09:53.280
It's going to be the
English HTML index file.

00:09:54.250 --> 00:09:57.500
And I see some text here that says,
let's see, if you can see this,

00:09:57.500 --> 00:10:00.860
it means the installation
of the Apache server went,

00:10:00.860 --> 00:10:02.240
OK, I don't like that text.

00:10:02.250 --> 00:10:09.840
The text I like is file systems rule.

00:10:11.060 --> 00:10:12.440
I like that much better.

00:10:12.480 --> 00:10:15.030
Now I'm going to go to the
web server here and refresh.

00:10:15.030 --> 00:10:17.840
And you can see file systems
rule up here in the top.

00:10:17.960 --> 00:10:21.590
So an interesting way to edit your
website is to enable DAV on it and

00:10:21.590 --> 00:10:25.000
then you can just use your favorite
editing tools and do whatever you like

00:10:25.000 --> 00:10:26.960
inside your favorite editing tool.

00:10:26.960 --> 00:10:29.430
When you save,
it's automatically populated

00:10:29.430 --> 00:10:31.090
right back up on the server.

00:10:36.630 --> 00:10:40.730
You know,
I had to have a plant for that applause.

00:10:40.860 --> 00:10:42.680
Okay,
let me talk just briefly about some of

00:10:42.680 --> 00:10:45.710
the file system interfaces in Mac OS X.

00:10:46.160 --> 00:10:48.530
This is the little file
system interface chart.

00:10:48.680 --> 00:10:51.130
You can see the three major
application environments,

00:10:51.280 --> 00:10:52.970
Classic, Carbon, and Cocoa on the top.

00:10:53.290 --> 00:10:57.100
They all have their own file
manager or file object interfaces,

00:10:57.100 --> 00:11:01.890
but they all come through the BSD layer,
and we've extended the BSD layer to

00:11:02.070 --> 00:11:06.060
allow access to file system metadata
that's not typically available in Unix,

00:11:06.110 --> 00:11:08.820
especially catalog information,
finder and creator,

00:11:08.930 --> 00:11:12.090
file type and creator type,
and things that you find on HFS+.

00:11:12.180 --> 00:11:15.940
And underneath all of that is our virtual
file system switch I mentioned before,

00:11:15.940 --> 00:11:20.580
and that's where additional file systems
that you might develop in Mac OS X or

00:11:20.580 --> 00:11:22.890
Stacks would layer into our system.

00:11:23.100 --> 00:11:26.070
So I won't go again into detail here,
but suffice it to say the

00:11:26.160 --> 00:11:28.150
Carbon File Manager is
still available to you.

00:11:28.160 --> 00:11:32.080
It has the Mac OS interface file
system interfaces carried forward.

00:11:32.080 --> 00:11:35.040
There's access by
volume reference number,

00:11:35.040 --> 00:11:37.700
directory, and ID still available.

00:11:37.700 --> 00:11:40.180
And Carbon does an interesting thing.

00:11:40.350 --> 00:11:43.790
Carbon provides HFS-style
semantics on file systems that

00:11:43.900 --> 00:11:45.670
don't normally support it.

00:11:45.800 --> 00:11:49.620
So if you're using UFS,
but your app is using Carbon,

00:11:49.620 --> 00:11:52.770
you'll still see resource forks
and you'll still see file IDs.

00:11:53.000 --> 00:11:55.090
The file IDs don't last across mounts.

00:11:55.160 --> 00:11:58.650
They're done in memory and kept for
you only while the mount exists.

00:11:58.780 --> 00:12:00.440
But nonetheless,
they're present if you do a

00:12:00.500 --> 00:12:01.740
call and you want to see them.

00:12:01.740 --> 00:12:05.360
So you're somewhat insulated if
you're using Carbon from some of

00:12:05.360 --> 00:12:06.780
the differences across file systems.

00:12:06.780 --> 00:12:09.090
We also, of course,
have the Cocoa environment with

00:12:09.090 --> 00:12:12.480
an object-oriented API and some
file objects that you can use.

00:12:12.480 --> 00:12:15.200
And as I mentioned,
the Berkeley Unix interfaces

00:12:15.200 --> 00:12:17.720
are available and can be
used by your app as well,

00:12:17.720 --> 00:12:22.000
even in a mixed environment with
the other application frameworks.

00:12:22.360 --> 00:12:26.270
I want to just briefly mention a couple
of the new calls that we added to

00:12:26.270 --> 00:12:30.530
the BSD layer for accessing HFS-style
metadata and those sorts of things that

00:12:30.590 --> 00:12:31.980
aren't typically available under Unix.

00:12:31.980 --> 00:12:34.720
Two major ones,
GetAdderList and SetAdderList,

00:12:34.720 --> 00:12:38.570
which roughly stand for
GetAttributeList and SetAttributeList.

00:12:38.600 --> 00:12:42.130
These are flexible calls designed to
retrieve various types of metadata,

00:12:42.130 --> 00:12:44.960
various different formats,
back to your application.

00:12:45.670 --> 00:12:47.310
Normally, you wouldn't call these.

00:12:47.320 --> 00:12:50.100
You'd probably call GetCatInfo
or SetCatInfo in Carbon,

00:12:50.100 --> 00:12:52.520
but they're available
to you if you need to.

00:12:52.520 --> 00:12:53.770
They are in our system.

00:12:53.780 --> 00:12:56.630
We also implemented a
call called SearchFS,

00:12:56.710 --> 00:12:59.880
which whose job is to do
fast catalog searching.

00:12:59.880 --> 00:13:02.740
It's supported in HFS+, although
most file systems don't support it.

00:13:02.800 --> 00:13:04.630
But it does allow for
fast catalog searching,

00:13:04.640 --> 00:13:07.760
and it was designed to support the
PBCAT search functionality in Carbon.

00:13:07.760 --> 00:13:12.340
We also have a call for
exchanging data between files.

00:13:12.400 --> 00:13:14.330
Those of you who have done
Carbon apps before are probably

00:13:14.330 --> 00:13:15.460
familiar with the exchange.

00:13:15.460 --> 00:13:19.690
We created a BSD-level call called
ExchangeData to do that same atomic

00:13:19.690 --> 00:13:22.050
transfer of data between two files.

00:13:22.100 --> 00:13:24.840
Finally,
we've added some options to FControl,

00:13:24.880 --> 00:13:27.220
which is a standard
Unix file system call,

00:13:27.220 --> 00:13:30.640
but we have some extensions to
allow behavior like allocating

00:13:30.640 --> 00:13:32.660
storage in advance of the LEOF.

00:13:32.660 --> 00:13:35.090
So data that's not part
of your file per se,

00:13:35.090 --> 00:13:37.520
but is part of the
file-allocated storage,

00:13:37.850 --> 00:13:41.460
which can be extended later
without additional allocation.

00:13:42.820 --> 00:13:45.570
Now we're at the file system
differences part of the talk.

00:13:45.570 --> 00:13:49.620
I'm going to grab a little cup of water
here because this is going to be a little

00:13:49.630 --> 00:13:52.290
longer and this stuff is important.

00:13:53.600 --> 00:16:29.200
[Transcript missing]

00:16:29.800 --> 00:16:31.960
Some of our file systems
support hard links,

00:16:32.000 --> 00:16:34.380
which is the ability to create
separate nodes in the file system

00:16:34.770 --> 00:16:37.140
pointing to the same data where
the nodes are essentially equal,

00:16:37.140 --> 00:16:40.620
not an alias from one
to the actual object.

00:16:40.740 --> 00:16:43.680
Some of our file systems have
storage for catalog data,

00:16:43.790 --> 00:16:45.130
catalog information.

00:16:45.190 --> 00:16:46.160
Some of them don't.

00:16:46.250 --> 00:16:49.530
Some of our file systems are multi-fork,
some of them aren't.

00:16:50.830 --> 00:16:53.890
I wanted to talk to you about web
dev in particular because web dev

00:16:53.890 --> 00:16:57.350
is a really good way of highlighting
some of the odd differences you

00:16:57.390 --> 00:16:59.230
might see between file systems.

00:16:59.260 --> 00:17:01.960
It's interesting that we have this sort
of file system agnostic architecture

00:17:02.010 --> 00:17:05.460
because it allows us to do things like
mount a web server as a file system,

00:17:05.460 --> 00:17:07.670
but there are going to be some gotchas.

00:17:07.940 --> 00:17:13.910
The web dev protocol does not have any
sort of dates besides modification dates.

00:17:13.920 --> 00:17:16.650
So if you wish to get the access
date of a file on the server,

00:17:16.720 --> 00:17:18.220
it's actually impossible.

00:17:18.220 --> 00:17:19.940
We have to sort of fake that information.

00:17:19.940 --> 00:17:22.700
So that's one classic difference.

00:17:22.700 --> 00:17:26.980
Inode numbers aren't a concept that is
supported in the web dev protocol either.

00:17:26.980 --> 00:17:29.480
Web dev, I should mention,
stands for web-based distributed

00:17:29.480 --> 00:17:30.760
authoring and versioning.

00:17:30.760 --> 00:17:34.490
The reason it came into existence was to
allow collaborative authoring on the web.

00:17:34.570 --> 00:17:40.340
I think it's original envisioning was
for people who are doing development in

00:17:40.360 --> 00:17:43.580
a web-based authoring tool to be able
to move things to and from the server

00:17:43.790 --> 00:17:46.170
and affect the files on the server,
but it wasn't originally

00:17:46.170 --> 00:17:47.300
a file systems protocol.

00:17:47.300 --> 00:17:49.080
That's something
Apple decided we could do.

00:17:49.080 --> 00:17:52.850
It was a simple protocol that was
created because the protocol added

00:17:52.860 --> 00:17:56.330
enough support in the way of a
consistent hierarchical namespace,

00:17:56.330 --> 00:17:59.840
some synchronization with locking,
and property management.

00:17:59.840 --> 00:18:02.960
But those properties do
not include inode numbers.

00:18:03.110 --> 00:18:05.250
And so,
very much like Carbon and file IDs,

00:18:05.370 --> 00:18:08.250
when we see a file in web dev,
we generate an inode number,

00:18:08.280 --> 00:18:11.640
and we remember that inode number
for the life of your mount.

00:18:11.720 --> 00:18:14.200
But if you unmount the web
dev volume and mount it again,

00:18:14.270 --> 00:18:16.620
the inode numbers for
files will not be the same.

00:18:17.350 --> 00:18:22.060
Also, we can't set live properties
in WebDAV through the protocol.

00:18:22.060 --> 00:18:24.580
Live properties are the ones that
are actually supported by the server.

00:18:24.580 --> 00:18:27.690
There's also a notion of dead properties
in WebDAV which are you can make up

00:18:27.690 --> 00:18:29.180
a property and store value in it.

00:18:29.260 --> 00:18:32.120
But real live properties like,
for example, the access time,

00:18:32.120 --> 00:18:35.070
those properties are actually on, sorry,
the modification time,

00:18:35.190 --> 00:18:38.070
those properties are actually on
the server and we want to respect

00:18:38.070 --> 00:18:40.330
those and return those to you,
but the servers will

00:18:40.330 --> 00:18:41.650
not let us change them.

00:18:41.690 --> 00:18:44.240
So you can't do a set mod time
on WebDAV and have it work.

00:18:44.330 --> 00:18:47.280
We'll have that silently fail
to keep apps from killing over.

00:18:47.300 --> 00:18:50.420
But be advised that you can see a
silent failure of a set mod time.

00:18:50.460 --> 00:18:53.620
The security model for WebDAV is
entirely different from what

00:18:53.620 --> 00:18:55.480
you'd expect from a file system.

00:18:55.490 --> 00:18:56.990
It's HTTP security.

00:18:57.010 --> 00:18:59.180
It's basic authentication
for us generally,

00:18:59.180 --> 00:19:02.270
which means that you try a request
and if the server doesn't like you,

00:19:02.370 --> 00:19:05.630
it gives you back a message that
says authorization denied and it's

00:19:05.630 --> 00:19:09.000
your job to find out the user's
username and password and try again,

00:19:09.000 --> 00:19:10.030
sending it across.

00:19:10.140 --> 00:19:13.800
But there is no way except for
testing an operation to determine

00:19:13.800 --> 00:19:17.280
if the user is going to be able
to do that operation or not.

00:19:17.300 --> 00:19:20.090
If you send a put across to the server,
which is the mechanism for

00:19:20.090 --> 00:19:22.010
taking a file and moving it up,
you don't know if it's

00:19:22.010 --> 00:19:23.100
going to succeed or fail.

00:19:23.100 --> 00:19:24.520
There isn't a pre-flight call,
if you will.

00:19:24.520 --> 00:19:25.970
You just have to do a put.

00:19:26.080 --> 00:19:29.020
So what happens in WebDAV is if
we get an authorization error,

00:19:29.110 --> 00:19:32.630
the daemon that supports the file
system puts up a dialog box that says,

00:19:32.690 --> 00:19:33.030
"Who are you?

00:19:33.250 --> 00:19:35.510
Please type your username and
password in." And then we'll

00:19:35.510 --> 00:19:36.780
send that across to the server.

00:19:36.850 --> 00:19:39.450
We'll keep doing that until
the user either gets it right,

00:19:39.450 --> 00:19:42.550
it times out after about five minutes,
or the user hits cancel.

00:19:42.560 --> 00:19:45.440
And if the user hits cancel,
an e-access error comes

00:19:45.440 --> 00:19:47.090
back from the file system.

00:19:47.370 --> 00:19:51.530
Likewise, unlike AFP or NFS,
which are typically run over

00:19:51.530 --> 00:19:56.010
local area networks and are
therefore usually reasonably fast,

00:19:56.150 --> 00:19:58.840
maybe not compared to local
items but in the absolute sense,

00:19:59.000 --> 00:20:00.870
WebDAV can be quite slow.

00:20:00.870 --> 00:20:04.000
It may be running over a 28K modem link,
you never know,

00:20:04.010 --> 00:20:07.580
because we're talking about an
internet file system after all.

00:20:07.980 --> 00:20:10.190
So we're not going to go through
all of the items on this chart.

00:20:10.260 --> 00:20:13.240
I just wanted to scare you a little
bit to give you an idea of how some

00:20:13.240 --> 00:20:15.030
of these file systems actually differ.

00:20:15.230 --> 00:20:17.320
Classic example,
HFS+ supports privileges.

00:20:17.380 --> 00:20:20.850
It has storage in the volume
format for privilege information.

00:20:20.910 --> 00:20:24.060
Supports the ability to get an error
back when you delete an open file.

00:20:24.170 --> 00:20:25.680
Supports access by ID.

00:20:25.830 --> 00:20:28.260
MS-DOS supports none of these things.

00:20:28.300 --> 00:20:30.930
WebDAV supports none
of these things either.

00:20:30.930 --> 00:20:32.210
NFS is sort of a mix.

00:20:32.680 --> 00:20:35.060
Same story with naming differences.

00:20:35.130 --> 00:20:37.360
Some file systems are
case sensitive like UFS,

00:20:37.360 --> 00:20:40.730
some are case insensitive
like HFS+. Some support

00:20:40.730 --> 00:20:42.440
Unicode fully and some don't.

00:20:42.480 --> 00:20:45.200
We make a particular mention
of the Unicode characteristic.

00:20:45.230 --> 00:20:49.590
HFS+ supports Unicode names
in a canonical form where the

00:20:49.710 --> 00:20:50.890
characters are decomposed.

00:20:51.000 --> 00:20:54.850
It's possible in Unicode to have, say,
an E with an accent represented as

00:20:54.850 --> 00:20:58.930
E with an accent as one character or
E followed by an accent character.

00:20:59.200 --> 00:21:00.920
There aren't that many
decomposed characters,

00:21:00.920 --> 00:21:01.780
but there are some.

00:21:01.870 --> 00:21:06.260
We always store all our file names
decomposed on the volume so that there

00:21:06.260 --> 00:21:09.960
will only be one element in a directory
that looks the same to the user.

00:21:09.960 --> 00:21:12.910
And so that we'll easily be
able to do name comparisons.

00:21:13.150 --> 00:21:14.500
But not all file systems do this.

00:21:14.540 --> 00:21:15.550
UFS does not.

00:21:15.600 --> 00:21:18.720
UFS does not interpret the bits
and we wind up storing things

00:21:18.740 --> 00:21:20.540
on UFS as UTF-8 characters.

00:21:20.560 --> 00:21:23.070
And so on UFS,
you actually could have two names

00:21:23.070 --> 00:21:26.650
that look identical to the user
but are actually slightly different

00:21:26.680 --> 00:21:28.590
in their byte representation.

00:21:28.600 --> 00:21:30.960
What this means for your application,
though,

00:21:30.970 --> 00:21:34.630
is if you have a composed character and
a name that you send to a create call,

00:21:34.630 --> 00:21:38.200
when you look at it again through
a directory listing on HFS+,

00:21:38.200 --> 00:21:39.260
it's going to be different.

00:21:39.360 --> 00:21:42.460
And on UFS, it'll be precisely the same.

00:21:43.290 --> 00:21:45.460
So having said that,
let me give you some tips as to

00:21:45.460 --> 00:21:48.530
how you can handle some of the
specific differences we've talked

00:21:48.530 --> 00:21:50.150
about today in your application.

00:21:50.210 --> 00:21:53.600
Number one, be consistent in your
use of case internally.

00:21:53.660 --> 00:21:56.690
We found with the Macintosh
applications environment,

00:21:56.750 --> 00:22:00.040
which was a Mac environment that
ran on Unix operating systems,

00:22:00.040 --> 00:22:03.160
that lots of Mac apps would keel
over when MAE was running on a

00:22:03.160 --> 00:22:06.760
case-sensitive file system and
that characteristic bled through.

00:22:06.810 --> 00:22:08.760
Reason being,
they would have files like preferences

00:22:08.830 --> 00:22:11.450
that they would open in one part of
their app with a capital P and they

00:22:11.450 --> 00:22:14.900
would open in another part of their app
with a small p and they wouldn't be the

00:22:14.900 --> 00:22:16.290
same and that would confuse the app.

00:22:16.360 --> 00:22:18.750
HFS+, they would be the same, UFS,
they wouldn't be.

00:22:18.860 --> 00:22:20.800
You'd either see a different
file or you'd get an E not exist

00:22:20.900 --> 00:22:23.970
error when you tried to access
the file but differ it in case.

00:22:24.090 --> 00:22:27.050
So make sure that in your app,
when you're referencing

00:22:27.100 --> 00:22:28.600
a hard-coded file,
if you do that,

00:22:28.600 --> 00:22:32.220
that you're using the same
case in all instances.

00:22:32.470 --> 00:22:35.000
Always use decomposed
names in your application.

00:22:35.000 --> 00:22:38.710
That way you'll never be surprised by
a name being slightly different on the

00:22:38.710 --> 00:22:41.910
way back out than it was on the way into
the file system when you created it.

00:22:42.000 --> 00:22:46.110
Be prepared for access
errors at random times.

00:22:46.200 --> 00:22:49.290
As I mentioned,
the WebDAV file system has a

00:22:49.300 --> 00:22:52.430
very odd permissions model,
and we're going to do things like

00:22:52.590 --> 00:22:55.500
put a file across which may happen
in an F-Sync or a flush files

00:22:55.500 --> 00:22:58.950
operation or on a close operation,
and we're going to discover at

00:22:58.950 --> 00:23:01.920
that time and not in advance that
the operation isn't permitted.

00:23:02.400 --> 00:23:05.230
If the user doesn't have a username
and password that allows them to do it,

00:23:05.230 --> 00:23:07.400
or if the server administrator
has cut their access,

00:23:07.400 --> 00:23:10.310
you can get back any access error
on a close call or on a flush files

00:23:10.320 --> 00:23:13.880
call with something which probably
hasn't ever happened to you before.

00:23:13.880 --> 00:23:16.260
So be prepared for access
errors at strange times,

00:23:16.260 --> 00:23:19.580
and you may want to be able to put
up a dialog that says access denied.

00:23:19.580 --> 00:23:22.380
You're going to probably see them
if you're running a Carbon app

00:23:22.380 --> 00:23:24.950
as an AFP permissions error
because that's how Carbon maps

00:23:24.950 --> 00:23:26.510
our access denied error codes.

00:23:26.580 --> 00:23:31.970
Also, do not rely on inode numbers,
and this is also true for file IDs.

00:23:32.450 --> 00:23:35.440
If you have a file system
that's unmounted and remounted,

00:23:35.440 --> 00:23:39.410
all the inode storage on a WebDAV volume,
all the file ID storage on UFS volume

00:23:39.480 --> 00:23:43.160
is kept in memory in big tables,
and there's no effort made to make that

00:23:43.160 --> 00:23:45.540
persistent across different mounts.

00:23:48.700 --> 00:23:52.860
We have one way to help you deal
with some of these differences and

00:23:52.860 --> 00:23:56.200
that is the PathConf system call.

00:23:56.200 --> 00:24:00.010
PathConf is designed to give you
characteristic information about

00:24:00.200 --> 00:24:01.400
the file system you're running on.

00:24:01.400 --> 00:24:04.400
It just takes a path and you give it a
selector that says you'd like to know

00:24:04.400 --> 00:24:07.120
if the file system is case sensitive
or if the file systems support,

00:24:07.120 --> 00:24:08.900
how long the names are that it supports.

00:24:08.900 --> 00:24:13.740
Those are the only two selectors that we
support right now in HFS+ on PathConf.

00:24:13.800 --> 00:24:15.560
Perhaps someday we'll expand that list.

00:24:15.680 --> 00:24:18.800
But you can use this call,
especially on HFS+ to know that you're

00:24:18.800 --> 00:24:21.430
on a case insensitive file system.

00:24:22.610 --> 00:24:26.750
So I'm going to now bring up Pat Dirks,
the CoreOS File Systems Technical Lead,

00:24:26.800 --> 00:24:31.710
to talk to you about some security issues
and some performance issues in Mac OS X.

00:24:37.550 --> 00:24:39.800
Well, the first thing to realize
is that in Mac OS X,

00:24:39.800 --> 00:24:40.630
it's a whole new world.

00:24:40.730 --> 00:24:45.040
It is multi-user to the core.

00:24:45.200 --> 00:24:49.460
There are permissions everywhere and the
core kernel enforces those permissions.

00:24:49.550 --> 00:24:53.100
There's no path around it or some
access path that's going to be different

00:24:53.130 --> 00:24:55.410
that's not going to be affected by it.

00:24:55.560 --> 00:24:58.640
The whole system is
fundamentally multi-user.

00:24:58.640 --> 00:25:01.530
The permissions in the system are
the standard Unix permissions.

00:25:01.550 --> 00:25:04.270
If you're familiar with those,
the next few slides are just

00:25:04.270 --> 00:25:05.660
going to be review for you.

00:25:05.680 --> 00:25:09.000
Hold on, there are a few gotchas in the
permission handling of HFS,

00:25:09.000 --> 00:25:13.770
but if you are familiar with Unix,
you should be very comfortable with

00:25:13.780 --> 00:25:16.790
the permissions model on our system.

00:25:16.810 --> 00:25:19.460
And we'll see that
diagram again in a moment.

00:25:19.460 --> 00:25:22.640
The permissions, for those of you who may
not be familiar with Unix,

00:25:22.650 --> 00:25:24.770
are in some ways similar to Apple Share.

00:25:24.770 --> 00:25:28.330
Apple Share's permission when we
were designing the AFP protocol are

00:25:28.580 --> 00:25:30.660
based on the Unix permissions model.

00:25:30.760 --> 00:25:33.080
And we made a few changes
from there to allow them to

00:25:33.080 --> 00:25:34.820
work on a folder-only basis.

00:25:34.860 --> 00:25:37.860
So, the permissions are based on
the Unix permissions model.

00:25:37.860 --> 00:25:38.300
And we made a few changes
from there to allow them to

00:25:38.300 --> 00:25:38.830
work on a folder-only basis.

00:25:38.860 --> 00:25:39.770
But they're fundamentally
inspired by the Unix model.

00:25:39.880 --> 00:25:42.290
So, instead of see files, see folders,
and make changes, you have read, write,

00:25:42.290 --> 00:25:43.080
and execute.

00:25:43.080 --> 00:25:46.420
And you have that for files and
you have that for directories.

00:25:46.420 --> 00:25:49.810
The catch is it applies to
files as well as folders.

00:25:49.830 --> 00:25:52.700
On an Apple Share file server,
the only permissions you ever had

00:25:52.710 --> 00:25:55.360
to worry about was the permissions
you had on a given folder.

00:25:55.360 --> 00:25:58.000
In Mac OS X,
you have to worry about the permissions

00:25:58.110 --> 00:25:59.700
on individual files as well.

00:25:59.700 --> 00:26:00.460
And the other difference
with AFP is that in AFP,

00:26:00.460 --> 00:26:00.980
you can have separate permissions.

00:26:00.980 --> 00:26:06.210
So,
you can have permissions for the world,

00:26:06.310 --> 00:26:09.900
the group that owns a particular folder,
and the owner of the folder.

00:26:09.920 --> 00:26:12.230
And whichever category you fit in,
you've got those rights.

00:26:12.350 --> 00:26:15.090
So, everybody started out with
the everyone permissions.

00:26:15.120 --> 00:26:17.620
And then if you were part of the group,
you also got the group's permissions.

00:26:17.620 --> 00:26:21.130
And if you were the owner of the object,
you also got the owner's permissions.

00:26:21.170 --> 00:26:23.840
In Mac OS X,
there's only one group that is matched.

00:26:23.840 --> 00:26:26.740
So, if you're the owner,
you get exactly the owner's permissions.

00:26:26.740 --> 00:26:29.070
And if you're in the group,
you get exactly the group's permissions.

00:26:29.070 --> 00:26:31.010
And if you're everyone else,
then you get the other permissions.

00:26:32.410 --> 00:26:38.420
So, those Unix permissions consist of an
owner ID that is saved with the object,

00:26:39.000 --> 00:26:42.270
a group ID that is saved with the object,
a set of permission bits

00:26:42.270 --> 00:26:45.810
which you see there,
and a few extra bits that are not divided

00:26:45.870 --> 00:26:49.740
up in separate categories for owner,
group, and other.

00:26:49.740 --> 00:26:53.720
And we'll cover in a moment what exactly
those bits mean in different cases.

00:26:53.720 --> 00:26:55.240
But that's basically it.

00:26:55.240 --> 00:26:57.940
Read, write,
execute in three groups and three

00:26:57.940 --> 00:27:01.690
special bits and some flags that
we'll cover in a moment as well.

00:27:02.400 --> 00:27:03.750
So.

00:27:06.060 --> 00:27:10.800
So every user is categorized in
one of three possible groups.

00:27:10.830 --> 00:27:14.280
Either the owner of the object,
the group that is

00:27:14.280 --> 00:27:18.600
associated with the object,
or everybody else.

00:27:18.600 --> 00:27:18.600
And

00:27:19.310 --> 00:27:22.620
Whichever group is most specific
determines the access that you get,

00:27:22.620 --> 00:27:23.040
as I said.

00:27:23.050 --> 00:27:24.240
Again, unlike Apple Share.

00:27:27.200 --> 00:27:31.300
So for each group, there is read, write,
and execute.

00:27:31.420 --> 00:27:35.800
Write translates very directly
to make changes in AFP.

00:27:35.800 --> 00:27:40.100
Read is the right to read a file or
list the contents of a directory.

00:27:40.100 --> 00:27:42.210
It's a bit like C file, C folders.

00:27:42.210 --> 00:27:43.420
That's where it gets a little weird.

00:27:43.420 --> 00:27:47.760
Execute applies most directly to files,
obviously.

00:27:47.760 --> 00:27:49.910
If it's an executable and
you have execute permissions,

00:27:49.910 --> 00:27:50.940
then you can execute it.

00:27:50.960 --> 00:27:53.440
It also applies to directories
as we'll see in a way,

00:27:53.440 --> 00:27:55.050
which is kind of a subtle case.

00:27:55.640 --> 00:28:00.810
For files, if you set the set UID bit,
then when you execute that binary,

00:28:00.810 --> 00:28:05.640
and it only makes sense on executables,
the program will run with the

00:28:05.650 --> 00:28:07.780
ID of the owner of that file.

00:28:07.780 --> 00:28:10.810
So you'll commonly hear
set UID root binaries.

00:28:10.810 --> 00:28:14.950
Those are files that are placed on the
system that will run as a privileged

00:28:14.950 --> 00:28:17.660
user in the system when they're executed.

00:28:17.660 --> 00:28:20.640
There's also set GID,
which is used less often,

00:28:20.640 --> 00:28:24.690
which runs with the group that
is associated with the object.

00:28:25.180 --> 00:28:27.450
Now in directories--

00:28:28.310 --> 00:28:32.730
It's probably easier to make sense
of these permissions if you think

00:28:32.740 --> 00:28:37.030
of directories as files listing
the contents of the directory,

00:28:37.050 --> 00:28:40.020
because that's how they
originally came about.

00:28:40.020 --> 00:28:45.510
Read is explicitly the permission to
enumerate the contents of the directory,

00:28:45.590 --> 00:28:47.940
to type ls and list the contents.

00:28:48.100 --> 00:28:49.850
Write is the right to make changes.

00:28:49.860 --> 00:28:51.850
It's very analogous
to AFP's make changes.

00:28:51.850 --> 00:28:54.380
This is make changes to the directory.

00:28:54.380 --> 00:28:57.970
So these are operations that would
require changes in the directory file.

00:28:58.480 --> 00:29:01.230
Creating a new file,
renaming a file that's in there,

00:29:01.230 --> 00:29:03.660
deleting a file, that sort of thing.

00:29:04.850 --> 00:29:11.440
You can set execute on a directory,
and that limits access a little bit.

00:29:11.440 --> 00:29:15.460
Without read, normally you have read
and execute together.

00:29:15.460 --> 00:29:18.670
If you give execute without read,
you retain the ability

00:29:18.670 --> 00:29:21.610
to open files in there,
provided you have permissions

00:29:21.610 --> 00:29:22.620
on the file itself.

00:29:22.620 --> 00:29:26.260
But you lose the ability to
list the directory contents.

00:29:26.260 --> 00:29:28.910
So it's almost sort of
a security-by-obscurity.

00:29:29.000 --> 00:29:32.080
If you know what the file name
is or your program has built in

00:29:32.080 --> 00:29:36.140
some file that it's referencing,
read is enough to get it open.

00:29:36.140 --> 00:29:39.460
But you need read in order to
enumerate the contents and look at it.

00:29:39.460 --> 00:29:43.600
So that's sort of an edge
case that you may run into.

00:29:43.610 --> 00:29:44.150
It's unusual.

00:29:45.750 --> 00:29:49.710
Finally, setting the sticky bit,
one of the special bits that

00:29:49.710 --> 00:29:53.110
is associated with an object,
means you can give write,

00:29:53.150 --> 00:29:57.070
but the ability to actually
make the changes is limited to

00:29:57.130 --> 00:29:58.890
the owner of the object itself.

00:29:58.920 --> 00:30:03.260
So it imposes one additional test
before you can actually make use

00:30:03.260 --> 00:30:06.640
of the write permission that you
would otherwise look to be granted.

00:30:10.290 --> 00:30:15.230
There are a special group of flags
associated with every object as well,

00:30:15.240 --> 00:30:18.340
and these exist only in one form.

00:30:18.540 --> 00:30:21.830
There's not a separate group of
flags for owner group and others.

00:30:21.830 --> 00:30:23.470
There's only one set of flags.

00:30:23.740 --> 00:30:30.130
And the most common one you'll see is
the immutable flag that takes the place

00:30:30.130 --> 00:30:32.680
of the lock bit that HFS always had.

00:30:32.720 --> 00:30:37.980
And that is in fact what setflock and
resetflock in the Carbon interfaces use

00:30:37.980 --> 00:30:40.430
to lock or unlock a particular file.

00:30:40.440 --> 00:30:43.730
You can see these flags if you
use the dash O option in LS if

00:30:43.730 --> 00:30:45.790
you find yourself in the shell.

00:30:45.800 --> 00:30:51.150
It will list U change if
the immutable bit is set.

00:30:51.230 --> 00:30:53.050
So that's a quick way that you
can tell if things are locked.

00:30:53.680 --> 00:30:56.830
And there's a chaflags command
that changes the flags and there's

00:30:56.830 --> 00:31:00.310
a chaflags system call that will
manipulate them at the BSD level.

00:31:00.360 --> 00:31:04.020
All these things are
accessible at the BSD level.

00:31:04.080 --> 00:31:07.260
There's nothing in Carbon or
Cocoa or something that is

00:31:07.310 --> 00:31:09.460
special above and beyond this.

00:31:09.920 --> 00:31:13.190
Everything is enforced at the
BSD level and everything is

00:31:13.380 --> 00:31:15.270
accessible at the BSD level.

00:31:15.510 --> 00:31:21.620
The other gotcha you may run into is that
when something has been marked immutable,

00:31:21.620 --> 00:31:22.920
it can't be moved.

00:31:23.040 --> 00:31:25.680
That used to not be true on Mac OS.

00:31:25.770 --> 00:31:29.570
You could lock a file and still
take it and move it somewhere.

00:31:30.300 --> 00:31:32.700
on servers, that was actually sort of an
awkward thing to do because you

00:31:32.700 --> 00:31:36.390
could lock something down and
somebody who had made changes could

00:31:36.390 --> 00:31:38.730
still make it disappear from you.

00:31:38.810 --> 00:31:39.890
That's no longer the case.

00:31:39.930 --> 00:31:42.710
When something is immutable,
it doesn't go anywhere

00:31:42.710 --> 00:31:44.160
and it doesn't change.

00:31:44.160 --> 00:31:48.400
Now these flags have the immutable
and the append flags have special

00:31:48.400 --> 00:31:52.870
variants of them that can be set only
if you are a specially privileged

00:31:52.870 --> 00:31:56.920
user and it can't be unset in
the normal running of the system.

00:31:56.920 --> 00:32:01.180
So if you are trying to protect
some particularly important file

00:32:01.180 --> 00:32:06.170
in the running of the system,
you can set a special system only

00:32:06.170 --> 00:32:10.000
immutable bit that is sort of stronger
even than the regular immutable

00:32:10.010 --> 00:32:11.960
bit and that you can't turn it off.

00:32:12.050 --> 00:32:15.030
So be careful if you try
this on your machine at home.

00:32:15.720 --> 00:32:17.570
You have to take the system
down to single user before

00:32:17.570 --> 00:32:19.570
you can clear that bit.

00:32:19.610 --> 00:32:22.710
Now, all the Unix aficionados wake up.

00:32:22.800 --> 00:32:25.330
This is the part where
things get different again.

00:32:25.560 --> 00:32:30.610
There is some special handling
on permissions for HFS+ volumes.

00:32:30.650 --> 00:32:35.940
We had a problem in that we wanted
people to be able to take disks and

00:32:36.050 --> 00:32:39.950
move them all around from system
to system and retain the same ease

00:32:39.950 --> 00:32:41.960
of use that they had in Mac OS 9.

00:32:42.020 --> 00:32:44.190
They could take a zip
disk from your system,

00:32:44.320 --> 00:32:48.440
take it over to somebody else's system,
and you wouldn't suddenly find that the

00:32:48.810 --> 00:32:53.630
permissions were all wacky just because
the numbers that were assigned for the

00:32:53.630 --> 00:32:58.180
user ID and group ID on your system
made no sense on the other system.

00:32:58.180 --> 00:32:58.180
So,

00:32:58.310 --> 00:33:03.980
The system very carefully uses the
permissions only on those disks

00:33:04.060 --> 00:33:09.050
that it knows are local or were
specifically requested that they be used.

00:33:09.110 --> 00:33:12.740
By default,
if you have an HFS+ disk that the

00:33:12.740 --> 00:33:16.710
system has never seen and you connect
it either by plugging in a ZIP disk or

00:33:16.810 --> 00:33:22.010
by plugging in a FireWire drive even,
the permissions will fall back

00:33:22.010 --> 00:33:26.300
to a scheme where the owner
and the group are ignored.

00:33:26.300 --> 00:33:33.420
You can get that same behavior on request
for any disk in the system through

00:33:33.490 --> 00:33:38.810
the finder's ignore permissions bit.

00:33:38.810 --> 00:33:38.810
We'll talk about that.

00:33:39.010 --> 00:33:44.950
So every disk is identified not
by name but by a special 64-bit

00:33:44.950 --> 00:33:47.220
identifier that we write on there.

00:33:47.220 --> 00:33:54.500
When a disk is being mounted,
the HFS code checks to see if this ID is

00:33:54.590 --> 00:33:59.280
one of a disk that it has seen before and
for whom permissions should be enabled.

00:33:59.280 --> 00:34:02.430
And if it finds that,
then it will enable the permissions

00:34:02.440 --> 00:34:05.470
and it will be used just like
you would see a UFS disk.

00:34:05.540 --> 00:34:07.700
You'll see owners, you'll see groups,
you'll see everything.

00:34:07.700 --> 00:34:11.720
If there is no entry for that system,
if it's completely unknown,

00:34:11.720 --> 00:34:15.610
or if the entry in there says the user
asked that the permissions not be used,

00:34:15.690 --> 00:34:21.060
then the handling switches over to ignore
all the user and group IDs on there,

00:34:21.060 --> 00:34:26.220
make them unknown, and replace the owner
with the logged in user.

00:34:26.220 --> 00:34:28.030
And that's done completely dynamically.

00:34:28.100 --> 00:34:32.080
If you have such a disconnected,
you log out, somebody else logs in,

00:34:32.080 --> 00:34:35.550
they are now the owner of all
the objects in that system.

00:34:35.550 --> 00:34:37.570
So it's not a static mapping.

00:34:37.570 --> 00:34:37.680
It's a static mapping.

00:34:37.700 --> 00:34:41.020
It's whoever is currently
logged in owns all that.

00:34:41.100 --> 00:34:45.610
So it's a very convenient way to
not trip over user or group settings

00:34:45.850 --> 00:34:48.210
that make no sense on your system.

00:34:48.260 --> 00:34:54.150
So the ignore permissions
checkbox in the finder.

00:34:54.420 --> 00:34:59.920
lets you elect to ignore this
and get the same sort of foreign

00:34:59.920 --> 00:35:02.950
disk behavior that you get.

00:35:03.620 --> 00:35:05.610
And it's the same underlying mechanism.

00:35:05.640 --> 00:35:09.930
What the ignore permissions bit
does is basically turn off the

00:35:09.930 --> 00:35:13.670
recognition of that disk in the
system and it will treat it without

00:35:13.670 --> 00:35:15.900
regard for the users and groups.

00:35:16.600 --> 00:35:17.800
It's called Ignore Permissions.

00:35:17.800 --> 00:35:20.930
Really the best way to think of it is
to think of it as ignore ownership.

00:35:24.300 --> 00:35:27.840
We'll take questions on this later.

00:35:27.840 --> 00:35:31.210
I wanted to bring up a few points
about performance in the system,

00:35:31.210 --> 00:35:34.800
and in particular,
the different ways that you can do I/O,

00:35:34.800 --> 00:35:37.880
a few general words that
we'll touch in a moment.

00:35:37.880 --> 00:35:42.640
But we want to cover the differences
between doing buffered file system I/O,

00:35:42.770 --> 00:35:46.020
doing direct memory
mapped I/O in the system,

00:35:46.170 --> 00:35:49.670
and using unbuffered file system
I/O and the differences between them

00:35:49.670 --> 00:35:51.660
and the implications of those things.

00:35:51.660 --> 00:35:55.060
I'll say a few words about zero fill,
which your application may have run into,

00:35:55.060 --> 00:35:57.480
which is something that you
see on Mac OS X that you

00:35:57.490 --> 00:36:00.260
never saw on Mac OS 9 before.

00:36:02.060 --> 00:36:04.670
In general,
this shouldn't be news to anybody,

00:36:04.670 --> 00:36:06.670
the fewer I/Os you do, the better.

00:36:06.670 --> 00:36:10.720
The more you can aggregate your
I/Os into a few large operations,

00:36:10.720 --> 00:36:12.470
the faster things will go.

00:36:12.690 --> 00:36:16.350
Even if you're doing small transfers,
the system will try to

00:36:16.350 --> 00:36:18.510
aggregate these on your behalf.

00:36:18.600 --> 00:36:20.650
If you're sequentially
reading through a file,

00:36:20.650 --> 00:36:24.410
the system will pick up on that and
it will read larger and larger chunks

00:36:24.460 --> 00:36:27.740
even ahead of where you currently are,
and as you're writing,

00:36:27.800 --> 00:36:31.510
it will save up writes to do single
large writes out to the disk to

00:36:31.810 --> 00:36:34.090
maximize the efficiency of your I/O.

00:36:34.090 --> 00:36:38.490
So that is why sequential operations are
so much better than random operations

00:36:38.600 --> 00:36:42.270
because even if your application is
only ever asking for 4K at a time,

00:36:42.270 --> 00:36:44.820
you'll be doing very large
transfers to the disk.

00:36:47.370 --> 00:36:52.080
The zero fill that we'll cover in
a moment is triggered when you are

00:36:52.080 --> 00:36:56.660
leaving areas of the file unwritten,
but you do become the owner of them.

00:36:56.660 --> 00:37:00.040
And it's best to avoid that because
it's really just wasted effort.

00:37:00.040 --> 00:37:02.110
You might as well write
the data sequentially.

00:37:02.150 --> 00:37:05.340
Don't skip ahead of the end of file,
for instance.

00:37:07.170 --> 00:37:09.880
This is basic buffered file system I/O.

00:37:09.900 --> 00:37:13.580
You see the device driver in the system,
which is doing the actual data transfer,

00:37:13.580 --> 00:37:16.280
the buffer cache and the
virtual memory system,

00:37:16.290 --> 00:37:21.480
which are part of the kernel that
govern all the data in the system.

00:37:21.550 --> 00:37:25.010
And in Mac OS X,
those are actually integrated and

00:37:25.010 --> 00:37:26.840
they coordinate with each other.

00:37:26.840 --> 00:37:31.300
So where there are cases where a
particular piece of a file or a

00:37:31.300 --> 00:37:36.650
page in the system is the same,
the buffer cache and the virtual memory

00:37:36.740 --> 00:37:40.980
system coordinate access to that page so
there's only ever one copy of the page.

00:37:40.980 --> 00:37:44.850
That means if you have something
mapped and you write that,

00:37:44.850 --> 00:37:49.380
you'll see those changes in the
mapping right away and vice versa.

00:37:49.400 --> 00:37:53.140
If you--if something gets paged out,
the read/write path will

00:37:53.140 --> 00:37:54.230
see that right away.

00:37:54.230 --> 00:37:57.160
It seems obvious in hindsight,
but it's an awful lot of work

00:37:57.180 --> 00:37:58.650
to make that work correctly.

00:37:58.650 --> 00:38:01.000
And finally,
there's a user application drawn

00:38:01.000 --> 00:38:03.180
there and you see the user application
with a page of memory in there.

00:38:03.180 --> 00:38:03.940
That's really--it's really--it's
really--it's really a great

00:38:03.940 --> 00:38:03.940
way to get the user to
understand the user application.

00:38:03.940 --> 00:38:03.940
So I think that's what we're going to do.

00:38:03.940 --> 00:38:03.940
So I think that's what we're going to do.

00:38:03.940 --> 00:38:04.290
So I think that's what we're going to do.

00:38:04.290 --> 00:38:04.660
So I think that's what we're going to do.

00:38:04.660 --> 00:38:08.880
So I think that's really the appearance
of a page that is managed on the user's

00:38:08.880 --> 00:38:11.440
behalf in the virtual memory system.

00:38:11.500 --> 00:38:12.460
You can think of it either way.

00:38:12.530 --> 00:38:14.990
You can think of the page as owned by
the user or you can think of the page

00:38:14.990 --> 00:38:16.540
as managed by VM on the user's behalf.

00:38:16.540 --> 00:38:18.520
It's really all the same thing.

00:38:18.630 --> 00:38:22.780
So in basic buffered I/O,
the data is first copied from the

00:38:22.780 --> 00:38:27.630
device driver into a buffer that
is set aside by the file system

00:38:27.910 --> 00:38:30.680
to hold blocks for that V node.

00:38:30.680 --> 00:38:30.680
So

00:38:30.800 --> 00:38:35.490
and those blocks are shared between
VM and the buffer cache as necessary.

00:38:35.490 --> 00:38:36.820
So that's the first copy.

00:38:36.870 --> 00:38:42.680
Then the file system will copy whatever
the user asked for to be copied either

00:38:42.680 --> 00:38:46.840
read or written into the user application
and there's a second copy made into the

00:38:46.840 --> 00:38:49.530
user pages that hold the user buffer.

00:38:49.640 --> 00:38:51.990
So it's completely flexible.

00:38:51.990 --> 00:38:54.240
You can read at any offset in the file.

00:38:54.240 --> 00:38:55.840
You can read any amount of data.

00:38:55.950 --> 00:38:57.620
But you do end up making two copies.

00:38:57.790 --> 00:39:01.320
First, a large page aligned copy for the
convenience of the system into the

00:39:01.340 --> 00:39:05.320
buffer cache and then a separate copy
from there into your user address

00:39:05.320 --> 00:39:07.590
space where the data really lives.

00:39:07.880 --> 00:39:11.700
And by the way, the user page ends up
being dirtied as a result,

00:39:11.700 --> 00:39:14.260
and we'll see in a moment
why that's important.

00:39:16.210 --> 00:39:18.590
But if you're going to be
reading a file over and over,

00:39:18.590 --> 00:39:20.050
or you're reading back
and forth through a file,

00:39:20.050 --> 00:39:23.930
it's a cost that's well worth making,
in addition to the flexibility you

00:39:23.930 --> 00:39:28.430
gain from the ability to align the
data or the size anywhere you want.

00:39:28.500 --> 00:39:31.800
The fact that the copy remains in
the buffer cache means the next time

00:39:31.800 --> 00:39:34.970
you hit either in that same page
or somewhere right around there,

00:39:34.970 --> 00:39:38.000
you'll probably find it in memory,
and you'll only end up doing

00:39:38.000 --> 00:39:41.050
the last copy from the buffer
cache into the user page.

00:39:41.070 --> 00:39:43.110
So there's an extra copy,
but it may be worth it

00:39:43.120 --> 00:39:44.720
under certain circumstances.

00:39:44.720 --> 00:39:48.210
And this is probably what
most of your I/O is like.

00:39:48.230 --> 00:39:51.970
This is ordinary, open, close, read,
write I/O.

00:39:54.160 --> 00:39:57.090
Instead of that,
you can do memory mapped I/O,

00:39:57.090 --> 00:40:00.030
and it's something that you
should consider as an option.

00:40:00.030 --> 00:40:02.930
When you're just reading files,

00:40:03.150 --> 00:40:07.020
It's a very efficient way to get data in,
and there are some advantages.

00:40:07.110 --> 00:40:09.800
Although it requires a
BSD VM call to set it up,

00:40:10.010 --> 00:40:14.040
so it may be tricky to do
from a CFM Carbon application,

00:40:14.110 --> 00:40:16.650
it's a very nice way to get the
data in because you only end up

00:40:16.650 --> 00:40:18.380
doing a single copy essentially.

00:40:18.390 --> 00:40:21.420
It goes straight from the device
driver into the VM system,

00:40:21.420 --> 00:40:25.450
and from there it's visible
to your user application.

00:40:25.450 --> 00:40:30.100
So there's only one copy made,
so you save a copy.

00:40:30.100 --> 00:40:30.100
In addition,

00:40:30.450 --> 00:40:34.820
The VM page is not marked dirty.

00:40:35.330 --> 00:40:38.240
All that's ever happened to that
page is something was read into it,

00:40:38.300 --> 00:40:42.860
unlike the user page that
was copied into a moment ago.

00:40:42.940 --> 00:40:48.060
So when the system needs more pages,
it doesn't have to go copying that

00:40:48.160 --> 00:40:50.450
user page out to swap storage.

00:40:50.470 --> 00:40:51.560
It's all set.

00:40:51.730 --> 00:40:54.690
It can just throw this away,
and it can read it in later if it

00:40:54.800 --> 00:40:56.830
should get page faulted in again.

00:40:57.770 --> 00:40:59.160
There are some disadvantages.

00:40:59.160 --> 00:41:01.040
Every transfer is at
least a whole page worth,

00:41:01.040 --> 00:41:03.110
so if you've got a file
with 10 bytes of data in it,

00:41:03.120 --> 00:41:04.490
it's obviously not worth mapping it.

00:41:04.500 --> 00:41:10.290
But it's a nice way to get some data
in and read through a lot of data.

00:41:10.300 --> 00:41:15.140
The VM system does the same clustering of
IO operations that I mentioned earlier.

00:41:15.140 --> 00:41:17.930
As you're touching through pages,
it will start paging in

00:41:17.930 --> 00:41:19.320
more and more in advance.

00:41:19.330 --> 00:41:22.820
So it's a very good way to read
in a sizable data file that you're

00:41:22.820 --> 00:41:25.040
just going to read sequentially.

00:41:25.040 --> 00:41:27.580
It's not good for write because
you can't extend a file.

00:41:27.600 --> 00:41:32.620
But it's a very good way to read data
in that you're only going to read

00:41:32.620 --> 00:41:34.600
and that you're reading sequentially.

00:41:34.600 --> 00:41:36.100
And it will save you a copy.

00:41:38.800 --> 00:41:42.150
Finally, there's something that's
almost a mixture of the two.

00:41:42.160 --> 00:41:44.390
You can choose to do unbuffered I.O.

00:41:44.400 --> 00:41:48.960
And it's actually very easy from
Carbon because it's the exact...

00:41:51.570 --> 00:41:56.650
I/O pause mode,
no cache bit that you can set on a

00:41:56.650 --> 00:42:00.580
read or write transfer in Carbon.

00:42:00.900 --> 00:43:06.800
[Transcript missing]

00:43:07.000 --> 00:43:10.000
Unlike memory mapping the page,
the page is dirtied,

00:43:10.050 --> 00:43:11.650
just like ordinary I/O would be.

00:43:11.800 --> 00:43:15.200
The page in the user space is marked
dirty because it's been copied into and

00:43:15.200 --> 00:43:17.300
it will be swapped out if necessary.

00:43:17.400 --> 00:43:22.380
But it's a good way to do I/O and
not fill up the buffer cache.

00:43:23.650 --> 00:43:27.490
If you're not likely to read or write,
to read the data again,

00:43:27.550 --> 00:43:28.510
it's a good thing to do.

00:43:28.640 --> 00:43:30.200
And you can write files this way.

00:43:30.270 --> 00:43:34.880
So if you're writing an output
file that your application

00:43:34.920 --> 00:43:39.600
isn't just about to reread,
this may be a good way to do your I/O.

00:43:42.680 --> 00:43:44.230
The zero fill I mentioned.

00:43:44.280 --> 00:43:50.650
The Mac OS X kernel tries to be very
careful not to let you read data

00:43:51.020 --> 00:43:53.980
that you haven't previously written.

00:43:54.060 --> 00:43:58.150
If you recall cases where some major
word processing application would

00:43:58.150 --> 00:44:02.350
inadvertently ship pieces of your hard
disk out along with your documents,

00:44:02.350 --> 00:44:05.060
you'll see why this is
a really nice feature.

00:44:05.460 --> 00:44:08.400
You have to be careful though,
because if you have a file

00:44:08.450 --> 00:44:10.960
that you're writing randomly,

00:44:11.270 --> 00:44:14.560
Uh, you'll end up,
if the first transfer is

00:44:14.680 --> 00:44:17.280
some distance into the file,
you'll end up zero filling

00:44:17.280 --> 00:44:19.480
the whole intervening space.

00:44:19.590 --> 00:44:22.270
Basically anything that
you can potentially read,

00:44:22.270 --> 00:44:26.200
you should consider,
you should either write,

00:44:26.340 --> 00:44:30.460
or the file system will write
with zeros on your behalf as

00:44:30.460 --> 00:44:32.830
part of the write transfer.

00:44:32.830 --> 00:44:32.830
So,

00:44:32.910 --> 00:44:38.040
Those cases are basically where you
use setEOF to make the file larger

00:44:38.040 --> 00:44:42.400
or where you do a write that skips
ahead past the end of file some

00:44:42.440 --> 00:44:45.200
distance and starts a transfer there,
creating this gap.

00:44:45.260 --> 00:44:47.280
That gap will be zero filled.

00:44:47.290 --> 00:44:50.330
So for those reasons,
sequentially writing a file,

00:44:50.330 --> 00:44:53.860
aside from all the benefits
I mentioned earlier of clustering

00:44:53.860 --> 00:44:56.080
the I.O., is far preferable.

00:44:59.200 --> 00:45:02.040
A word about the cost of caching.

00:45:02.110 --> 00:45:06.820
You should be careful when you decide
to cache data in your application,

00:45:07.040 --> 00:45:11.920
because in Mac OS X you are constantly
running with virtual memory enabled and

00:45:11.920 --> 00:45:15.990
what you think of as setting aside some
memory for this particular cache is

00:45:16.150 --> 00:45:18.070
really just that much more paged memory.

00:45:18.070 --> 00:45:22.570
In fact, you may end up doing a number of
I/O operations just to read the data in.

00:45:22.570 --> 00:45:25.240
You may have to page out some
other dirty page in the system

00:45:25.240 --> 00:45:27.350
to free up a page for your cache.

00:45:27.350 --> 00:45:31.220
You end up incurring the cost
of the actual transfer to read

00:45:31.220 --> 00:45:35.460
the page in and if this data
turns out not to be referenced,

00:45:35.610 --> 00:45:39.990
you may end up having to page out a
page that you dirtied by this cache.

00:45:41.340 --> 00:45:43.350
In addition,
you have to be very careful about

00:45:43.420 --> 00:45:45.380
how you structure the cache.

00:45:45.380 --> 00:45:48.150
This is not wired memory that's
sitting there for your behalf.

00:45:48.230 --> 00:45:52.320
If you have a cache data structure that
is just laid out very conveniently in

00:45:52.320 --> 00:45:55.950
memory but ends up skipping around from
this page to that sort of randomly,

00:45:55.950 --> 00:45:59.100
you end up touching all these pages
and you may end up doing page ins

00:45:59.100 --> 00:46:01.290
with every new page that you touch.

00:46:01.300 --> 00:46:05.940
So you have to be very careful that
you structure your cache in a way

00:46:05.940 --> 00:46:09.200
that minimizes the number of potential
page hits to get you to your data.

00:46:09.260 --> 00:46:12.980
All together,
it's very easy for an application cache

00:46:13.290 --> 00:46:16.880
to become much more expensive than simply
reading the data right back in from disk,

00:46:17.020 --> 00:46:20.400
especially if the data is something
that is mapped directly into memory,

00:46:20.400 --> 00:46:21.440
for instance.

00:46:21.460 --> 00:46:26.530
So think about it carefully and only
use caches for things that are truly

00:46:26.530 --> 00:46:30.740
hard to reconstruct or where you are
sure that the hit rate is actually very,

00:46:30.750 --> 00:46:31.590
very high.

00:46:33.600 --> 00:46:38.960
Well finally, Mac OS X is a good time to
rethink some of the fundamental

00:46:38.960 --> 00:46:42.600
assumptions behind your application.

00:46:42.690 --> 00:46:46.350
Think about the kind of data that
you're reading and the pattern that

00:46:46.350 --> 00:46:48.360
you're reading or writing the data in.

00:46:48.430 --> 00:46:51.910
And think about what mechanism
you might best use to get that

00:46:51.910 --> 00:46:54.200
I/O in and out of the system.

00:46:55.090 --> 00:46:58.900
Look at your application as it's
happening and figure out where the

00:46:58.900 --> 00:47:03.460
real bottlenecks are before you decide
where to spend your time and effort

00:47:03.500 --> 00:47:06.220
and trickiness and what to optimize.

00:47:06.260 --> 00:47:08.300
If the bulk of your application
is reading and writing files,

00:47:08.340 --> 00:47:10.040
it's obviously worth thinking about.

00:47:10.040 --> 00:47:12.370
If the bulk of the time is spent
waiting for the user to click on

00:47:12.370 --> 00:47:15.130
some cell somewhere or something,
then it may not be an issue at all.

00:47:17.410 --> 00:47:21.420
Look at the underlying assumptions that
went into your application because some

00:47:21.430 --> 00:47:24.540
of them may well be changed in Mac OS X.

00:47:24.700 --> 00:47:27.610
Some system calls that used to be
almost free on Mac OS X because

00:47:27.610 --> 00:47:31.440
they came straight out of memory
all the time may be reasonably

00:47:31.440 --> 00:47:34.060
expensive on Mac OS X all of a sudden.

00:47:34.150 --> 00:47:36.250
And again,
that's a reason to go back and look

00:47:36.330 --> 00:47:40.210
at your application in action and see
where the time is being spent because

00:47:40.210 --> 00:47:44.120
you may be surprised to find that you're
spending a lot of time doing things

00:47:44.230 --> 00:47:46.930
that you assumed would be almost free.

00:47:47.090 --> 00:47:50.230
And finally,
try to avoid making assumptions about

00:47:50.230 --> 00:47:54.710
how fast something will be to read
because you might be surprised what's

00:47:55.060 --> 00:47:58.380
actually somewhere remote over on a
network in somebody's home directory

00:47:58.380 --> 00:48:02.040
and the preference file you thought was
cheap actually turns out to be a very

00:48:02.040 --> 00:48:05.880
lengthy operation that might involve
automatically mounting some volume,

00:48:05.890 --> 00:48:08.830
getting access to the data, etc.

00:48:08.850 --> 00:48:11.690
So don't make assumptions
about what's fast,

00:48:11.770 --> 00:48:13.810
what's local, what's remote.

00:48:13.900 --> 00:48:15.920
It could be on a WebDAV volume
for all you know.

00:48:16.650 --> 00:48:20.500
So finally, there are some tools
that you should look at.

00:48:20.500 --> 00:48:21.830
There are some classic Unix tools.

00:48:21.840 --> 00:48:26.860
Top is a very nice tool for seeing
the size of your application,

00:48:26.860 --> 00:48:30.640
the amount of virtual memory
that it has allocated to it,

00:48:30.700 --> 00:48:33.520
how much of that is shared,
how much of that is private,

00:48:33.520 --> 00:48:36.360
and it gives you a little
peek into the system and will

00:48:36.470 --> 00:48:38.520
show you how fast paging I.O.

00:48:38.680 --> 00:48:44.640
is being done, how busy the system is,
what it's doing, what in your system is

00:48:44.640 --> 00:48:48.960
using the most CPU time,
all kinds of things.

00:48:49.030 --> 00:48:50.100
I recommend it highly.

00:48:50.110 --> 00:48:51.330
You should run it often.

00:48:51.340 --> 00:48:54.880
There's a time command,
which can be very interesting.

00:48:54.880 --> 00:49:00.230
It's limited to command line things,
but it will tell you how much system

00:49:00.230 --> 00:49:04.170
time and how much user time was spent
executing this particular application,

00:49:04.180 --> 00:49:09.880
along with the number of I.O.s that
were done on behalf of your application.

00:49:09.920 --> 00:49:14.170
So you can easily tell when
your application suddenly starts

00:49:14.170 --> 00:49:16.520
doing fewer reads or fewer I.O.

00:49:16.520 --> 00:49:18.810
transfers or more larger
ones or smaller ones,

00:49:18.810 --> 00:49:23.720
or whether the percentage of system
time versus user time is interesting.

00:49:23.720 --> 00:49:26.260
If the system is spending most
of its time in system time,

00:49:26.260 --> 00:49:29.140
you should think about what system calls
it's doing to cause that to happen.

00:49:29.160 --> 00:49:31.680
And similarly,
don't worry too much if most of the

00:49:31.820 --> 00:49:35.430
time is spent in the system because
your application's algorithms may not.

00:49:37.280 --> 00:49:38.410
B is relevant.

00:49:38.570 --> 00:49:40.640
So time can be interesting.

00:49:40.810 --> 00:49:44.080
Sample is I gather a
long-standing next step tool.

00:49:44.350 --> 00:49:49.640
It's a dynamically probes your
running application and takes a peak

00:49:49.640 --> 00:49:53.530
at where the system is currently
running and the stack at that time.

00:49:53.530 --> 00:49:56.810
And you can tell it to take a number
of samples over certain period of time

00:49:56.810 --> 00:50:00.150
and it will tell you what percentage
of time was spent in what routines

00:50:00.150 --> 00:50:03.970
and that may tell you where are the
hotspots in your application are.

00:50:04.150 --> 00:50:07.880
Tell you whether your application is
constantly waiting for I/O to come

00:50:07.880 --> 00:50:13.230
off disk or waiting for the user to
do something or all sorts of things.

00:50:13.240 --> 00:50:15.440
So sample is interesting.

00:50:15.540 --> 00:50:17.840
And finally,
FS usage which you may have seen

00:50:17.840 --> 00:50:22.180
demoed in other sessions as well is a
wonderful tool for getting down to the

00:50:22.180 --> 00:50:27.180
real nitty-gritty of exactly what your
application is doing and what the system

00:50:27.180 --> 00:50:29.300
is doing on behalf of your application.

00:50:29.410 --> 00:50:31.430
You may be making Carbon calls
and be unaware of the fact that

00:50:31.470 --> 00:50:32.620
you're running your application.

00:50:32.620 --> 00:50:32.620
So you can use this tool to get a
better understanding of what your

00:50:32.620 --> 00:50:32.620
application is doing and what the system
is doing on behalf of your application.

00:50:32.620 --> 00:50:32.620
You may be making Carbon calls
and be unaware of the fact that

00:50:32.620 --> 00:50:32.630
you're running your application.

00:50:32.630 --> 00:50:32.720
So you can use this tool to get a
better understanding of what your

00:50:32.720 --> 00:50:32.820
application is doing and what the system
is doing on behalf of your application.

00:50:32.820 --> 00:50:32.820
You may be making Carbon calls
and be unaware of the fact that

00:50:32.820 --> 00:50:32.880
you're running your application.

00:50:32.880 --> 00:50:32.880
You may be making Carbon calls
and be unaware of the fact that

00:50:32.880 --> 00:50:32.920
you're running your application.

00:50:32.920 --> 00:50:33.710
You may be making Carbon calls and
be unaware of the number of system

00:50:33.810 --> 00:50:38.360
calls that go on under the covers
to make that Carbon API happen.

00:50:38.360 --> 00:50:39.790
So.

00:50:40.000 --> 00:50:43.990
I'd like to bring up our
resident expert in bad demo code,

00:50:44.010 --> 00:50:46.390
my manager, Clark Warner.

00:50:46.800 --> 00:51:01.500
[Transcript missing]

00:51:05.830 --> 00:51:10.800
I'm going to bring up a copy of TextEdit,
which many of you, I imagine,

00:51:10.800 --> 00:51:15.030
have probably used by now.

00:51:15.100 --> 00:51:19.940
And let me bring up a copy
of the Process Viewer.

00:51:28.800 --> 00:51:33.840
I'll have to do this the hard way.

00:51:33.840 --> 00:51:35.320
All right.

00:51:39.340 --> 00:51:40.690
Okay.

00:51:40.810 --> 00:51:44.120
First I'm going to do my little Unix
command here to find out the PID number

00:51:44.510 --> 00:51:49.050
of the process that is TextEdit.

00:51:54.900 --> 00:51:56.810
It looks like 278.

00:51:56.980 --> 00:52:00.210
Let me change the font here to make
this a little bit more readable for you.

00:52:04.400 --> 00:52:19.000
[Transcript missing]

00:52:22.560 --> 00:52:23.160
What's that?

00:52:23.170 --> 00:52:24.500
Oh, thank you.

00:52:24.500 --> 00:52:28.190
Okay.

00:52:28.490 --> 00:52:34.220
Now I'm now monitoring all the behavior
of TextEdit and when I go back into,

00:52:34.220 --> 00:52:34.220
whoops.

00:52:35.500 --> 00:52:37.260
Let me bring it back.

00:52:37.260 --> 00:52:39.730
You can see as I click around
various things are happening.

00:52:39.800 --> 00:52:43.990
One of the things I'll do is open up
a file that I put on our demo volume.

00:52:44.020 --> 00:52:46.370
You can see a lot of
things are happening now.

00:52:47.900 --> 00:52:49.790
Here's 116 demos.

00:52:50.060 --> 00:52:50.700
Data file.

00:52:50.700 --> 00:52:51.890
Okay.

00:52:51.960 --> 00:52:54.360
So here's my opening of the data file.

00:52:55.470 --> 00:52:58.940
You'll notice there were a few page ins,
some opens, some fstats, some reads,

00:52:58.980 --> 00:53:02.080
but basically one read call
of a fairly large size.

00:53:02.300 --> 00:53:03.590
So that's not too bad.

00:53:03.660 --> 00:53:05.720
I'm going to close up this file here.

00:53:05.810 --> 00:53:07.810
Let me just show you.

00:53:11.400 --> 00:53:17.000
[Transcript missing]

00:53:18.350 --> 00:53:22.760
I think I would have woken up by now.

00:53:23.830 --> 00:53:23.860
The man page for FFS usage.

00:53:27.040 --> 00:53:30.900
One of the most interesting things about
the FS Usage program is the ability

00:53:30.900 --> 00:53:35.140
to see all of the actual Carbon file
system calls that are happening

00:53:35.150 --> 00:53:36.900
while the read calls are happening.

00:53:36.900 --> 00:53:40.240
If you notice here,
there's this temp file tracing.

00:53:40.240 --> 00:53:43.200
If you create in /temp this
file called file tracing,

00:53:43.240 --> 00:53:46.660
then you will actually see all the
Carbon calls as well as all of the

00:53:46.760 --> 00:53:48.400
BSD calls that are coming through.

00:53:48.400 --> 00:53:51.090
And to show you that briefly,

00:53:53.600 --> 00:53:55.940
I'll turn that on.

00:53:55.940 --> 00:54:00.120
And now I'm going to launch an
application that I call dumb text.

00:54:04.790 --> 00:54:08.250
ThumbText is the standard
simple text text editor hacked

00:54:08.410 --> 00:54:11.090
up to do one-byte file reads.

00:54:13.600 --> 00:54:16.320
Just to give you an idea of if
you guys wrote apps this way,

00:54:16.320 --> 00:54:19.830
this is how you can figure
it out before your boss does.

00:54:19.900 --> 00:54:21.970
Let me talk to you a little bit
about some of the key issues in

00:54:22.010 --> 00:54:24.220
building your own file system.

00:54:24.220 --> 00:54:26.840
One is, it's really not recommended.

00:54:26.840 --> 00:54:28.790
And the reason we say that--

00:54:29.300 --> 00:56:29.700
[Transcript missing]

00:56:29.880 --> 00:56:32.940
Funnels are acquired when a
thread enters a system call.

00:56:32.940 --> 00:56:35.280
They're released when the
thread returns to user mode.

00:56:35.280 --> 00:56:41.340
They're also released when a system call
reaches a voluntary yield point like I/O,

00:56:41.340 --> 00:56:43.240
allocating memory, and so forth.

00:56:43.270 --> 00:56:44.800
But they're held across
kernel preemption.

00:56:44.800 --> 00:56:49.490
So a BSD system call now can be preempted
in the kernel and something else can run,

00:56:49.520 --> 00:56:53.010
a user thread or a Mach thread or
an I/O Kit thread and so forth,

00:56:53.060 --> 00:56:56.280
but the BSD structures won't
change out from underneath

00:56:56.280 --> 00:56:58.210
the BSD kernel system call.

00:56:58.320 --> 00:56:59.800
So it's happy.

00:57:00.520 --> 00:57:03.870
We also split the funnel after we
developed the first one so that

00:57:03.870 --> 00:57:06.270
now networking operations in the
kernel are handled in the network

00:57:06.400 --> 00:57:09.200
funnel and all other operations
including file system operations

00:57:09.200 --> 00:57:10.460
are handled in the kernel funnel.

00:57:10.460 --> 00:57:13.750
We found that we actually could separate
network activity in the kernel from

00:57:13.750 --> 00:57:15.180
file system activity in the kernel.

00:57:15.180 --> 00:57:19.170
What this means though is if you
were writing a network file system,

00:57:19.170 --> 00:57:22.850
say, every time you went to use the
networking infrastructure in the kernel,

00:57:22.950 --> 00:57:25.450
you'd have to change your funnel,
switch from the kernel

00:57:25.540 --> 00:57:27.210
funnel to the network funnel.

00:57:27.220 --> 00:57:29.500
When you went back,
you'd have to switch back.

00:57:29.690 --> 00:57:31.710
Switching funnels is a blocking call.

00:57:31.720 --> 00:57:34.420
The entire world can change
from under you when you switch

00:57:34.420 --> 00:57:37.280
from the network funnel to the
kernel funnel and vice versa.

00:57:37.420 --> 00:57:39.340
All things you would have to know.

00:57:39.450 --> 00:57:42.000
Network funnel is for things like socket,
I/O,

00:57:42.000 --> 00:57:44.170
and find and accept calls and so forth.

00:57:44.280 --> 00:57:45.200
Kernel funnel for everything else.

00:57:45.530 --> 00:57:47.630
There are some calls, of course,
that can be called either from

00:57:47.630 --> 00:57:48.980
either funnel or from no funnel.

00:57:48.980 --> 00:57:52.490
Memory allocation and free, etc.

00:57:52.730 --> 00:57:55.050
So,
here are some need to knows if you wanted

00:57:55.120 --> 00:57:57.600
to build a kernel extension for Mac OS X.

00:57:57.600 --> 00:58:00.790
One, as we mentioned last year,
we built this thing we call

00:58:00.790 --> 00:58:03.500
the unified buffer cache,
which if you had built the file

00:58:03.500 --> 00:58:06.380
system prior to that would have
had to change to support it.

00:58:06.460 --> 00:58:10.220
Likewise, between public beta and now,
we introduced the split funnel.

00:58:10.240 --> 00:58:12.050
And of course,
we're going to be doing things

00:58:12.090 --> 00:58:14.830
to improve the performance of our
kernel and the functionality of

00:58:14.830 --> 00:58:16.070
our kernel on into the future.

00:58:16.070 --> 00:58:18.750
And some of those things are going to
require changes in the file system.

00:58:18.750 --> 00:58:20.420
And if you have one written,
you're going to have to

00:58:20.520 --> 00:58:21.340
be inside of the loop.

00:58:21.420 --> 00:58:23.420
You're going to have to contact Apple.

00:58:23.420 --> 00:58:27.060
There's other stuff that may be involved,
but we can only tell

00:58:27.060 --> 00:58:28.220
you so much in an hour.

00:58:28.260 --> 00:58:30.300
So the primary message is talk to Jason.

00:58:30.360 --> 00:58:32.290
If you're thinking about
building a file system,

00:58:32.360 --> 00:58:32.890
contact Apple.

00:58:32.890 --> 00:58:34.140
You're going to have to be in the loop.

00:58:34.140 --> 00:58:37.610
Now, we do a little demonstration here
because we like to bring concepts

00:58:37.610 --> 00:58:39.380
home at the file system session.

00:58:39.380 --> 00:58:42.420
And so, I am a rogue kernel
file system extension.

00:58:42.420 --> 00:58:45.410
And my compatriots here, Pat Dirks,
Scott Roberts,

00:58:45.410 --> 00:58:47.760
and Umesh Vaishampayan are the kernel.

00:58:47.760 --> 00:58:49.460
And this is me,
an inappropriately versioned

00:58:49.460 --> 00:58:50.240
kernel file system extension.

00:58:50.240 --> 00:58:52.030
So, I'm going to be using the
kernel file system extension,

00:58:52.030 --> 00:58:52.730
attempting to load.

00:58:52.890 --> 00:58:54.800
. .

00:59:12.100 --> 00:59:16.640
I think you get the picture.

00:59:16.650 --> 00:59:19.250
Here's some other sessions you may
be interested in at the show to

00:59:19.250 --> 00:59:22.910
help you with building applications
that are file system centric or even

00:59:22.930 --> 00:59:24.620
building file system extensions.

00:59:24.620 --> 00:59:27.800
Open source at Apple is
happening at 10:30 right

00:59:27.800 --> 00:59:29.920
after this session in Hall A2.

00:59:29.920 --> 00:59:33.290
There's a session on AFP Server and
the Apple Share Client file system

00:59:33.360 --> 00:59:37.940
in Mac OS X that's happening
tomorrow in this room at 3:30.

00:59:37.940 --> 00:59:40.950
There's a Carbon performance
tuning session happening in

00:59:40.950 --> 00:59:45.810
Hall 2 tomorrow at 2:00 and an
Apple Performance Tools session

00:59:45.810 --> 00:59:51.330
happening in Room A2 Thursday at
5:00 where you may get to look

00:59:51.330 --> 00:59:54.240
at your third demo of FS Usage.

00:59:54.240 --> 00:59:57.750
We think FS Usage is so important
that if you come to the Worldwide

00:59:57.750 --> 00:59:59.860
Developers Conference you
should see it at least twice,

00:59:59.870 --> 01:00:02.010
possibly three times.

01:00:02.450 --> 01:00:04.640
Likewise,
leveraging BSD services will happen in

01:00:04.640 --> 01:00:08.440
the Civic Auditorium Friday at 2 o'clock.

01:00:08.600 --> 01:00:11.100
The Darwin Kernel presentation,
which will give you an idea of how

01:00:11.100 --> 01:00:13.950
the kernel is structured internally,
the Mach kernel and some of the

01:00:13.950 --> 01:00:16.200
BSD kernel services outside of
file systems and networking,

01:00:16.200 --> 01:00:18.840
that's going to be at
the Civic Center at 3:30.

01:00:18.910 --> 01:00:22.240
And the Darwin Feedback
Forum will be Friday at 5:00.

01:00:22.320 --> 01:00:23.370
That's all we have for you today.

01:00:23.550 --> 01:00:26.370
I'm going to ask Jason Yao to come up,
and he's going to moderate

01:00:26.370 --> 01:00:27.200
our question and answer.

01:00:27.200 --> 01:00:30.240
I'm going to bring Pat Dirks,
Scott Roberts, Umesh Vaishampayan,

01:00:30.240 --> 01:00:33.790
and Don Brady up on stage from
the file systems and kernel team,

01:00:33.890 --> 01:00:35.220
and we'll take your questions.
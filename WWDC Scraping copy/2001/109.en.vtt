WEBVTT

00:00:01.420 --> 00:00:02.270
Welcome.

00:00:02.270 --> 00:00:03.960
Good crowd today.

00:00:04.060 --> 00:00:05.280
So that's me.

00:00:05.280 --> 00:00:07.310
I work in DTS.

00:00:07.750 --> 00:00:10.790
and today we're going to be talking
about a number of Mac OS X solutions

00:00:10.860 --> 00:00:12.080
for graphics for games.

00:00:12.270 --> 00:00:17.100
Rather than go through kind of a dry,
boring, line by line overview of the API,

00:00:17.100 --> 00:00:20.200
we're going to cover some
particular topics that are of

00:00:20.200 --> 00:00:22.100
interest to game developers.

00:00:22.210 --> 00:00:25.860
Both some traditional problems and
some things you might want to think

00:00:25.860 --> 00:00:27.600
about as you're moving to Mac OS X.

00:00:27.600 --> 00:00:29.560
We're going to talk
about display management.

00:00:29.600 --> 00:00:31.600
That's always a big problem.

00:00:31.600 --> 00:00:34.600
How to change the screen resolution,
how to change the bit depth,

00:00:34.600 --> 00:00:36.600
refresh rate, those kinds of things.

00:00:36.600 --> 00:00:39.600
We're going to talk about mixing
core graphics with Quick Draw.

00:00:39.600 --> 00:00:41.600
Some of you, maybe full screen apps,
maybe not,

00:00:41.680 --> 00:00:45.600
but some apps may want to start
using some of the core graphics APIs,

00:00:45.700 --> 00:00:49.600
perhaps to draw some anti-alias text,
or some other things like that,

00:00:49.600 --> 00:00:51.600
some of the advanced path features.

00:00:51.600 --> 00:00:54.600
We'll talk about how to mix that
with some existing Quick Draw code.

00:00:54.600 --> 00:00:56.600
We're going to cover a
few Quick Draw tidbits,

00:00:56.600 --> 00:01:02.600
some other things about differences with
Quick Draw on Mac OS X versus Mac OS 9.

00:01:02.900 --> 00:01:05.600
Another topic, tear-free blitting.

00:01:05.600 --> 00:01:08.130
We're going to talk about
what you can and can't do on

00:01:08.200 --> 00:01:10.600
Mac OS X and how to improve that.

00:01:10.710 --> 00:01:12.600
And some changes to OpenGL.

00:01:12.620 --> 00:01:14.600
OpenGL is a little bit different.

00:01:14.770 --> 00:01:17.600
Mostly we've added a bunch
of new features for X.

00:01:17.600 --> 00:01:21.100
And then we're also going to cover,
probably in more detail than

00:01:21.100 --> 00:01:23.600
some of the other sessions,
because this is the first one,

00:01:23.600 --> 00:01:26.600
we're going to cover the games
roadmap for WWDC this year.

00:01:28.500 --> 00:01:30.620
With that in mind,
we're not going to really be

00:01:30.620 --> 00:01:32.350
covering much about Quick Draw.

00:01:32.380 --> 00:01:36.350
I'm assuming you either know what
you need to know or you can find it.

00:01:36.460 --> 00:01:38.000
We're not going to cover
QuickTime in detail.

00:01:38.000 --> 00:01:39.400
There's some other sessions on that.

00:01:39.400 --> 00:01:43.400
I'm also not going to go through a
general introduction to core graphics.

00:01:43.400 --> 00:01:46.370
There are a number of other sessions
at this conference for that.

00:01:46.470 --> 00:01:50.150
And there are four more OpenGL sessions.

00:01:50.380 --> 00:01:52.630
So I'm not really going to
cover much beyond some real

00:01:52.630 --> 00:01:55.670
basic Mac OS X stuff for that.

00:01:56.970 --> 00:01:59.960
So let's get into the display management.

00:01:59.960 --> 00:02:02.920
As many of you know,
DrawSpocket's been around for a while.

00:02:02.920 --> 00:02:05.630
Works great on Mac OS 9.

00:02:05.760 --> 00:02:07.250
We've included it in Mac OS X.

00:02:07.470 --> 00:02:09.840
It's available for you to use.

00:02:09.840 --> 00:02:11.900
We've primarily put it in
there for ease of porting.

00:02:11.900 --> 00:02:15.100
A number of you have existing apps,
existing games that already

00:02:15.100 --> 00:02:17.070
use the DrawSpocket API.

00:02:17.100 --> 00:02:21.500
And we've got it in Mac OS X so you can
bring that code over almost directly.

00:02:21.500 --> 00:02:25.570
It is callable from CFM and Mac O,
so you don't have to worry about going

00:02:25.570 --> 00:02:30.160
through CFBundle APIs or anything
like that to get to it from CFM.

00:02:30.180 --> 00:02:33.310
One thing that is a bit different,
though, for some of you that were used

00:02:33.310 --> 00:02:36.600
to putting up a window on top
of DrawSpocket to just draw into

00:02:36.600 --> 00:02:41.730
that window to do your graphics,
on Mac OS X, you can't bring a window up

00:02:41.730 --> 00:02:43.490
on top of DrawSpocket anymore.

00:02:43.600 --> 00:02:47.300
So if you had been bringing a window up,
now you just need to get the front

00:02:47.300 --> 00:02:48.800
buffer and draw straight into that.

00:02:48.800 --> 00:02:51.400
It's a pretty standard C graph pointer.

00:02:51.430 --> 00:02:53.310
Not too hard to do.

00:02:53.320 --> 00:02:58.690
Another thing is we've removed some
APIs like the user select context,

00:02:58.690 --> 00:03:00.440
which used to let the
user select the display.

00:03:00.540 --> 00:03:04.280
So all of the GUI stuff is pretty
much gone out of DrawSpocket.

00:03:05.570 --> 00:03:09.060
Now the new API on Mac OS X for
doing display management is

00:03:09.060 --> 00:03:12.880
called CG Direct Display,
and that's part of Core Graphics.

00:03:13.000 --> 00:03:17.250
You'll find it under the
Application Services Umbrella Framework,

00:03:17.250 --> 00:03:20.970
and it lets you do a number of
different things that you would expect.

00:03:21.080 --> 00:03:22.710
You can enumerate displays.

00:03:22.790 --> 00:03:27.460
You can enumerate the available
video modes for a given display.

00:03:27.540 --> 00:03:31.690
You can capture displays so that
you control them completely.

00:03:31.810 --> 00:03:33.950
You can switch the video
modes on those displays.

00:03:34.050 --> 00:03:38.280
And you can also, if you really need to,
get access to screen memory directly.

00:03:38.400 --> 00:03:41.780
I'll show you some code on
how to do all of these things.

00:03:42.380 --> 00:03:46.460
So first of all, enumerating displays.

00:03:46.520 --> 00:03:50.630
You have an array of display IDs of,
you know, say you want to cover at least,

00:03:50.680 --> 00:03:52.290
say, eight displays or so.

00:03:52.520 --> 00:03:55.040
You get the active display list.

00:03:55.040 --> 00:03:58.040
That gives you a list of the
display IDs for each display

00:03:58.040 --> 00:04:00.040
that's active on the system.

00:04:00.040 --> 00:04:03.990
And it also returns you the actual
number of displays you found.

00:04:04.330 --> 00:04:07.030
If you didn't get an error,
you can then iterate through that

00:04:07.200 --> 00:04:10.890
array and look at each display in turn.

00:04:12.080 --> 00:04:15.580
Once you get a display ID,
what can you do with it?

00:04:15.580 --> 00:04:17.200
Well, you can find out a few
things about a display.

00:04:17.200 --> 00:04:20.330
You can find out pixels wide,
pixels high, those kinds of things,

00:04:20.330 --> 00:04:24.920
find out the number of bytes per row,
always very useful.

00:04:25.080 --> 00:04:28.880
Once you've captured a display,
you can also get the base address.

00:04:28.880 --> 00:04:31.130
This is the direct access
I was talking about before,

00:04:31.130 --> 00:04:33.310
but it's important to note,
this is only valid for

00:04:33.360 --> 00:04:34.240
a captured display.

00:04:34.240 --> 00:04:36.650
Once you've captured it,
the Windows server pretty much gives you

00:04:36.650 --> 00:04:38.810
control over it until you release it.

00:04:38.900 --> 00:04:40.350
Once you release it,
you can't draw directly

00:04:40.390 --> 00:04:41.470
to its bits anymore.

00:04:41.500 --> 00:04:43.410
Keep that in mind.

00:04:45.800 --> 00:04:48.250
You can also,
once you get a given display ID,

00:04:48.250 --> 00:04:51.290
you can ask it what the
available modes are.

00:04:51.320 --> 00:04:53.600
So when you get ready to switch,
you want to find out what

00:04:53.600 --> 00:04:55.400
modes does it support.

00:04:55.530 --> 00:05:00.350
CGDisplayAvailableModes
will return you a CFArrayRef

00:05:00.880 --> 00:05:04.370
And then, provided that's not null,
you can find out the number of

00:05:04.370 --> 00:05:07.130
modes that the display supports.

00:05:07.510 --> 00:05:09.900
and then loop through
each of those modes.

00:05:09.930 --> 00:05:13.000
That array is actually an
array of CFDictionary's.

00:05:13.130 --> 00:05:17.000
And each dictionary describes
one of the available modes.

00:05:17.140 --> 00:05:19.550
So what can we do with a mode dictionary?

00:05:20.230 --> 00:05:22.350
Glad you asked.

00:05:22.350 --> 00:05:25.540
For each mode you can get a
number of different values.

00:05:25.540 --> 00:05:29.770
The CG Direct Display header,
cgdirectdisplay.h describes

00:05:29.770 --> 00:05:33.720
in fair detail what you can
get out of that dictionary.

00:05:33.720 --> 00:05:37.720
Some things you can find out whether
that mode is actually usable for Aqua.

00:05:37.740 --> 00:05:40.480
As you know,
Aqua doesn't like to run in 640 by 480,

00:05:40.490 --> 00:05:41.840
doesn't like to run in 8 bit.

00:05:41.990 --> 00:05:45.990
This will tell you whether or not
that display mode supports Aqua.

00:05:46.300 --> 00:05:49.440
and here we just set a string.

00:05:49.440 --> 00:05:53.000
You can also get pretty
much any particular key,

00:05:53.000 --> 00:05:56.580
the keys are listed in that header
and find out the numeric value

00:05:56.580 --> 00:06:00.280
so you can find out refresh rate,
you can find out bit depth, width,

00:06:00.300 --> 00:06:02.610
height, those kinds of things.

00:06:02.980 --> 00:06:06.020
Once you've gone through your modes
that are available for a given display,

00:06:06.090 --> 00:06:07.250
presumably you pick one.

00:06:07.360 --> 00:06:10.590
Say you need 1024x768x16 bit.

00:06:10.590 --> 00:06:13.600
You found the mode that
identifies the one you want.

00:06:13.690 --> 00:06:15.830
Now we need to switch to it.

00:06:15.930 --> 00:06:18.770
Well, in order to be able
to switch back easily,

00:06:18.800 --> 00:06:21.350
you can get the current display mode.

00:06:21.450 --> 00:06:26.250
And that gives you a dictionary ref that
you can use to restore the mode later.

00:06:26.790 --> 00:06:28.630
Then you capture the display.

00:06:28.630 --> 00:06:30.260
And once you've captured it,
you've got control over it,

00:06:30.260 --> 00:06:32.040
as I mentioned.

00:06:32.110 --> 00:06:37.200
Then you can switch to whatever best
mode you've decided you want to use.

00:06:37.280 --> 00:06:38.240
You can also hide the cursor.

00:06:38.310 --> 00:06:43.440
Now, the ordering of these three,
capture, switch, and hide the cursor,

00:06:43.540 --> 00:06:44.400
is somewhat important.

00:06:44.530 --> 00:06:47.490
If you switch the mode
before you capture,

00:06:47.700 --> 00:07:07.000
[Transcript missing]

00:07:07.700 --> 00:07:09.600
and hiding the cursor is just
whether you want the cursor

00:07:09.600 --> 00:07:10.900
still visible during all this.

00:07:11.060 --> 00:07:14.250
Some people may want to hide it,
then capture, then switch.

00:07:14.510 --> 00:07:18.550
and once you've gotten all this done,
you've got the display to yourself.

00:07:18.650 --> 00:07:20.790
And your game code here.

00:07:21.140 --> 00:07:26.000
If you need to get a CGraph pointer
to do quick draw operations,

00:07:26.000 --> 00:07:29.970
you want to copy bits to this display,
whatever, you can use an API create

00:07:29.970 --> 00:07:32.000
new port for CG display ID.

00:07:32.000 --> 00:07:34.890
This API is actually in
the quick draw header,

00:07:35.060 --> 00:07:38.000
so don't go looking for it in the core
graphics header if you won't find it.

00:07:38.010 --> 00:07:40.940
And if you do create a port this way,
don't forget to call dispose

00:07:40.940 --> 00:07:43.500
port when you're done,
because as create might imply,

00:07:43.500 --> 00:07:46.790
it does create a new one and you're
responsible for releasing it.

00:07:48.270 --> 00:07:50.890
Once you're done with your game,
you need to shut down,

00:07:50.890 --> 00:07:54.110
and you pretty much reverse the order
of the operations that we did earlier.

00:07:54.160 --> 00:07:56.320
You put the cursor back.

00:07:56.680 --> 00:08:00.540
You switch back to the original mode on
that display and then you release the

00:08:00.600 --> 00:08:02.600
display to give it back to the system.

00:08:02.840 --> 00:08:04.790
Pretty straight forward stuff.

00:08:06.320 --> 00:08:08.460
So now I'd like to show you a quick demo.

00:08:08.480 --> 00:08:12.690
These are actually some little
demos written by one of our

00:08:12.690 --> 00:08:14.690
core graphics engineers,
but they illustrate

00:08:14.750 --> 00:08:15.400
the point pretty well.

00:08:15.530 --> 00:08:16.600
The first one is Mode.

00:08:16.600 --> 00:08:18.840
This is already up on
our sample code website.

00:08:19.280 --> 00:08:24.500
And all it does is use some
of the code we've described to

00:08:25.440 --> 00:08:28.950
Go out and simply ask
what display is available,

00:08:29.030 --> 00:08:30.280
what modes does it support.

00:08:30.300 --> 00:08:32.900
As you can see here,
currently we're running

00:08:32.900 --> 00:08:36.540
1024 by 768 by 32 bits,
30 hertz,

00:08:36.630 --> 00:08:39.570
and it supports a number of different

00:08:40.480 --> 00:08:44.230
and this is also listing for you
whether or not that particular

00:08:44.230 --> 00:08:46.400
mode supports Aqua or not.

00:08:46.500 --> 00:08:49.760
This is a good piece of code to look at,
especially if you're not too familiar

00:08:49.760 --> 00:08:53.030
with CFArrayRef and CFDictionaryRef and
how to manipulate those.

00:08:53.230 --> 00:08:57.640
This code has a very nice,
simple structure to go through those.

00:08:57.640 --> 00:08:59.710
That's one nice little one.

00:08:59.710 --> 00:09:04.340
And then, to give you a brief example of
drawing directly to the screen,

00:09:04.400 --> 00:09:06.950
this one called Color Bars.

00:09:07.170 --> 00:09:10.840
shows you how to just draw
straight to that base address.

00:09:10.840 --> 00:09:12.270
Very simple little demo.

00:09:12.320 --> 00:09:14.100
And here we're just
capturing this display,

00:09:14.100 --> 00:09:18.100
switching it into a mode, drawing some,
and then switching back.

00:09:18.730 --> 00:09:20.100
Nothing too complicated there.

00:09:20.100 --> 00:09:26.100
So moving back to the slides.

00:09:33.450 --> 00:09:37.080
and as I mentioned both of those demos
are already up on the sample code side

00:09:37.080 --> 00:09:39.280
if you'd like to go take a look at them.

00:09:41.080 --> 00:09:46.260
Along with display management comes
palette manipulation and gamma tables.

00:09:46.260 --> 00:09:50.290
For this you combine the CGDirect
palette API and the CGDirect display API.

00:09:50.300 --> 00:09:54.450
If you want to be able to create
palettes and manipulate them,

00:09:54.460 --> 00:09:59.300
switch palettes and also manipulate
the gamma tables on a given display.

00:09:59.770 --> 00:10:02.140
So creating palettes has a
number of different options.

00:10:02.210 --> 00:10:04.760
You can create a default one,
you can create it for a given

00:10:04.900 --> 00:10:08.700
display with a given capacity with
some samples you already provide.

00:10:08.700 --> 00:10:12.000
I believe those are float samples
and then there's also one for

00:10:12.000 --> 00:10:15.700
convenience function you can create
it directly with byte samples.

00:10:15.770 --> 00:10:19.570
And then of course you have to
release those once you're done

00:10:19.570 --> 00:10:21.900
with them with CG palette release.

00:10:23.380 --> 00:10:25.540
For manipulating them,
you can get a particular color,

00:10:25.540 --> 00:10:28.530
you can get the index for a given color,
you can set the color

00:10:28.530 --> 00:10:31.300
of a particular index,
you can compare palettes directly.

00:10:31.510 --> 00:10:37.430
You can also create a new palette from
an old palette blended with a color.

00:10:37.450 --> 00:10:39.460
So,
some nice little facilities there to make

00:10:39.460 --> 00:10:42.050
palette manipulation a little bit easier.

00:10:42.720 --> 00:10:45.720
and then of course you can ask a
display whether you can set the palette

00:10:45.720 --> 00:10:50.310
for that display and then you can
actually set it if it says you can.

00:10:50.310 --> 00:10:53.600
Some displays may not
support palettes at all.

00:10:54.820 --> 00:11:00.870
For Gamma, there's a few APIs here for
setting the transfer functions.

00:11:00.920 --> 00:11:02.900
And there's two ways
to do it in this API,

00:11:02.900 --> 00:11:06.780
either by a formula which just has a
few parameters or by a table of values.

00:11:06.870 --> 00:11:09.640
So if you happen to have your
whole Gamma specified in a table,

00:11:09.760 --> 00:11:12.800
you can very easily call set
display transfer by table.

00:11:12.800 --> 00:11:16.610
We also have a convenience
function to do it with bytes.

00:11:16.810 --> 00:11:18.750
So you can either use bytes or floats.

00:11:18.800 --> 00:11:22.350
You can also get the transfer
back and you can do it by

00:11:22.350 --> 00:11:24.800
formula as well with these APIs.

00:11:24.800 --> 00:11:26.790
We've got a quick little demo here.

00:11:26.880 --> 00:11:29.800
This one has not been posted yet,
but it should be soon after.

00:11:29.800 --> 00:11:35.800
And this is actually a direct port
of an old sample called Mac Gamma.

00:11:35.800 --> 00:11:40.790
Some of you may have
seen that demo before.

00:11:40.800 --> 00:11:42.800
It just runs through.

00:11:42.800 --> 00:11:45.870
and starts using those
APIs to mess with the gamma.

00:11:49.500 --> 00:11:53.800
I have an annoying little app,
but it's a good demo.

00:11:53.800 --> 00:11:56.920
Install it on your friend's machine
and then hide it and leave it running.

00:11:56.920 --> 00:12:02.990
Okay, so more slides.

00:12:05.520 --> 00:12:08.040
So that's a little bit
about display management.

00:12:08.090 --> 00:12:09.530
The basic capabilities are there.

00:12:09.530 --> 00:12:12.450
You can get the different displays,
find out what modes they support,

00:12:12.460 --> 00:12:16.650
switch to modes, manipulate those,
manipulate palettes and gammas.

00:12:16.850 --> 00:12:19.600
All of that facility is there for you.

00:12:20.960 --> 00:12:23.850
Now,
if you already have some quick draw code,

00:12:23.880 --> 00:12:25.870
you already do a lot of quick
draw drawing in your game,

00:12:25.870 --> 00:12:29.210
but you want to start adding a
little bit of CG code to your game.

00:12:29.660 --> 00:12:32.070
How do you go about doing that?

00:12:32.150 --> 00:12:34.190
First of all,
we're going to talk about if you've

00:12:34.210 --> 00:12:37.110
already got a quick draw port,
say you've used Carbon,

00:12:37.110 --> 00:12:39.550
create new window, you've got a window,
you can get the window port.

00:12:39.600 --> 00:12:42.600
Now you want to draw CG into that window.

00:12:42.710 --> 00:12:45.880
There's some pretty easy code
to use to get the core graphics

00:12:45.880 --> 00:12:47.600
context and start drawing.

00:12:47.600 --> 00:12:49.610
One thing you need to watch out for,
the coordinate systems

00:12:49.640 --> 00:12:50.590
are a little different.

00:12:50.600 --> 00:12:53.530
I'll talk about the differences
in the coordinate systems and

00:12:53.530 --> 00:12:54.600
what you need to watch out for.

00:12:54.600 --> 00:12:58.580
I'll talk about some things that are also
a little different with pixel addressing.

00:12:58.590 --> 00:13:03.160
And then we'll get into covering a little
bit of clipping and how clipping in

00:13:03.160 --> 00:13:05.820
core graphics differs from quick draw.

00:13:07.500 --> 00:13:10.490
So to create a CG context
for a given port,

00:13:10.520 --> 00:13:11.410
very simple.

00:13:11.470 --> 00:13:14.320
There's one call,
create CG context for port.

00:13:14.360 --> 00:13:17.460
You pass it to port,
point it to a context ref.

00:13:17.580 --> 00:13:18.360
Couldn't be simpler.

00:13:18.830 --> 00:13:20.710
Do your CG drawing.

00:13:20.710 --> 00:13:25.440
Don't forget to release the context
that you created when you're done.

00:13:27.520 --> 00:13:32.400
Once you've got that context,
how does the coordinate system differ?

00:13:32.400 --> 00:13:34.850
In Quick Draw,
as many of you are probably aware,

00:13:34.850 --> 00:13:36.350
the coordinate system,
the origin is in the

00:13:36.350 --> 00:13:37.780
upper left-hand corner.

00:13:37.880 --> 00:13:41.760
Positive X goes right,
positive Y goes down.

00:13:41.800 --> 00:13:44.610
For PostScript, PDF,
and of course Core Graphics,

00:13:44.610 --> 00:13:48.780
which is based on the PDF imaging model,
the origin is the bottom left.

00:13:48.780 --> 00:13:51.780
The positive Y axis points up.

00:13:52.110 --> 00:13:54.170
And unlike Quick Draw,
where you're pretty much

00:13:54.200 --> 00:13:56.600
always working with a port,
you can always get the port wrecked,

00:13:56.750 --> 00:13:59.000
find out what the bounds are,
width and height and everything,

00:13:59.140 --> 00:14:01.990
core graphics doesn't really have
a concept of a bounds of a context.

00:14:01.990 --> 00:14:05.000
And that's partly because it's
supposed to be very device independent,

00:14:05.000 --> 00:14:08.230
but also because once you start
applying transforms and things,

00:14:08.230 --> 00:14:12.060
it gets a little weird how do
you define a rectangular bounds.

00:14:12.060 --> 00:14:16.670
So in particular when you're working
with a window context or if you

00:14:16.830 --> 00:14:19.990
created an off screen context,
which I'll talk about in a little bit,

00:14:19.990 --> 00:14:22.100
you know what the bounds are already.

00:14:22.100 --> 00:14:24.100
So you pretty much just
have to remember those.

00:14:24.100 --> 00:14:27.130
You can't get them directly
from the context itself.

00:14:28.490 --> 00:14:32.400
So if the coordinates are different,
what can you do about it?

00:14:32.460 --> 00:14:36.570
Well, the easiest thing is with a few
simple calls in core graphics,

00:14:36.570 --> 00:14:41.500
you can actually change the
core graphics context coordinate

00:14:41.500 --> 00:14:43.400
system to match that to QuickDraw.

00:14:43.400 --> 00:14:45.330
And for people that are
used to thinking in nice,

00:14:45.600 --> 00:14:48.390
simple QuickDraw coordinates,
this is probably the easiest way to go.

00:14:48.390 --> 00:14:50.930
And as I mentioned,
you need to remember the bounds from the

00:14:50.930 --> 00:14:53.400
port or the view that you got it from.

00:14:53.470 --> 00:14:56.360
So the first call,
CG sync context with origin,

00:14:56.360 --> 00:14:59.400
CG sync context origin with port,
excuse me.

00:14:59.400 --> 00:15:03.060
That simply makes sure that if you've
called set origin in your port,

00:15:03.120 --> 00:15:05.490
in your QuickDraw port to
move the origin around,

00:15:05.550 --> 00:15:08.390
this will sync up the CG context
origin with that change.

00:15:08.670 --> 00:15:11.040
Then you call translate to
move the origin from the

00:15:11.330 --> 00:15:14.820
bottom left to the upper left,
and then you call scale to flip the

00:15:14.870 --> 00:15:17.400
y-axis so the positive y points down.

00:15:17.400 --> 00:15:20.800
So we've got a little bit
of code to do just that.

00:15:21.300 --> 00:15:24.960
In this first part,
we create our context again.

00:15:24.980 --> 00:15:27.840
We call sync origin with port.

00:15:27.890 --> 00:15:30.410
So we've got our port
and our context ref.

00:15:31.330 --> 00:15:34.330
Then we translate by the port height.

00:15:34.390 --> 00:15:37.490
And it's positive port height because
you're positive in terms of core

00:15:37.500 --> 00:15:39.200
graphics coordinate system right now.

00:15:39.200 --> 00:15:43.340
And then minus one on
the y-axis for the scale.

00:15:43.430 --> 00:15:46.650
We leave the x-axis alone,
so that moves the origin up

00:15:46.710 --> 00:15:48.200
and flips the y-axis down.

00:15:48.200 --> 00:15:51.290
One thing to note here,
and you'll probably run into this

00:15:51.290 --> 00:15:54.200
the first time you go through this,
I certainly hit it.

00:15:54.200 --> 00:15:56.170
This does make the
coordinate systems match,

00:15:56.170 --> 00:15:59.200
and so you can start thinking in
terms of quick draw coordinates again.

00:15:59.240 --> 00:16:03.200
But when you start using CG to draw text,
the text draws upside down.

00:16:03.200 --> 00:16:05.950
Because the text honors that
translation matrix that we've

00:16:05.950 --> 00:16:07.200
been manipulating there.

00:16:07.280 --> 00:16:09.860
And as soon as we scale
it by minus one on the y,

00:16:09.860 --> 00:16:12.540
core graphics says, "Okay,
I'll draw it upside down,

00:16:12.540 --> 00:16:15.200
no problem." Which is something you
never could really do in quick draw.

00:16:15.200 --> 00:16:18.040
It's one nice feature.

00:16:19.330 --> 00:16:22.370
So, and you can also rotate text too,
so that's also very nice.

00:16:22.510 --> 00:16:25.850
I hope you managed to get to some
of the core graphics sessions.

00:16:26.250 --> 00:16:29.340
So the CTM thing,
I mentioned it on this previous slide.

00:16:29.340 --> 00:16:32.830
You see translate CTM, scale CTM.

00:16:32.900 --> 00:16:34.600
What is that thing?

00:16:34.700 --> 00:16:36.790
That's the current transform matrix.

00:16:37.060 --> 00:16:38.860
And you can do a number
of fun things with that.

00:16:38.860 --> 00:16:43.050
You can do basic translations,
you can do scales, as we've already seen.

00:16:43.150 --> 00:16:45.700
You can also do rotations,
which is very nice.

00:16:45.700 --> 00:16:48.100
And you can do skews,
which are pretty much just

00:16:48.110 --> 00:16:49.890
arbitrary affine transforms.

00:16:51.700 --> 00:16:54.760
So what do those primitives look
like when you actually use them?

00:16:54.820 --> 00:16:57.160
Again, we get our context.

00:16:57.680 --> 00:17:00.600
Then scale is simply,
you take a scale on the

00:17:00.600 --> 00:17:03.520
X and a scale on the Y axis,
and those are floating point numbers,

00:17:03.520 --> 00:17:05.600
so you can scale by fractional scales.

00:17:05.600 --> 00:17:09.600
As you saw before, one pretty much means
don't change that axis.

00:17:09.600 --> 00:17:11.970
Minus one means flip
it upside down or left,

00:17:12.020 --> 00:17:12.590
right.

00:17:12.600 --> 00:17:14.610
Translate, much the same.

00:17:14.670 --> 00:17:18.150
You take a translate on the
X and a translate on the Y,

00:17:18.150 --> 00:17:19.990
moves your origin around.

00:17:20.360 --> 00:17:23.280
Rotation, again very simple,
very straightforward.

00:17:23.530 --> 00:17:26.100
Angle and radiance,
that rotates the CG context

00:17:26.180 --> 00:17:27.740
around its current origin.

00:17:27.740 --> 00:17:30.130
And then if you define
an affine transform,

00:17:30.130 --> 00:17:33.380
you can just concatenate that
with the current transform.

00:17:33.530 --> 00:17:37.190
So this is where you start getting
into skews and other things.

00:17:38.590 --> 00:17:40.670
So what does that all look like?

00:17:40.700 --> 00:17:45.650
I wrote a simple little app
here to show you what you can do

00:17:47.300 --> 00:17:59.100
[Transcript missing]

00:17:59.310 --> 00:18:00.800
Just calling draw graphic.

00:18:00.800 --> 00:18:03.960
I have a little routine that
draws graphic at the origin.

00:18:04.140 --> 00:18:06.300
Doesn't do anything exciting.

00:18:06.320 --> 00:18:08.960
But using scaling,

00:18:09.200 --> 00:18:11.880
over here, using translation.

00:18:11.880 --> 00:18:13.670
Oh,
and these are all rotated a little bit,

00:18:13.670 --> 00:18:15.300
so it's a little more interesting.

00:18:15.300 --> 00:18:18.890
You can do some basic
scaling and translation.

00:18:18.890 --> 00:18:20.710
And then this combines

00:18:21.010 --> 00:18:23.320
mostly rotation and translation.

00:18:23.360 --> 00:18:26.370
Good little rocket ship to
fly around in a figure eight.

00:18:27.830 --> 00:18:32.320
and in each of these cases I'm simply
manipulating the transform matrix,

00:18:32.360 --> 00:18:33.800
tweaking it a little bit,
doing a translation,

00:18:33.800 --> 00:18:36.100
doing a rotation and then calling
that one function and that function

00:18:36.100 --> 00:18:37.700
never changes to draw the graphic.

00:18:37.700 --> 00:18:41.250
So as far as it's concerned,
it's always drawing the rocket at the

00:18:41.250 --> 00:18:44.700
origin and it's always drawing it on the,
you know, straight up the Y axis.

00:18:44.700 --> 00:18:45.700
It doesn't have to care.

00:18:45.700 --> 00:18:49.010
The transform matrix and all
the CG operations take care

00:18:49.010 --> 00:18:53.490
of manipulating the pixels,
make things a little more interesting.

00:18:54.890 --> 00:18:59.790
and this sample code will be posting
pretty soon after WWDC as well.

00:18:59.800 --> 00:19:03.750
Alright.

00:19:14.080 --> 00:19:16.030
So as I mentioned in the beginning,
pixel addressing is a

00:19:16.030 --> 00:19:17.300
little bit different.

00:19:17.330 --> 00:19:23.660
Because Core Graphic Contexts tried
to abstract out away from the device,

00:19:24.080 --> 00:19:26.800
Some contexts don't have the
concept of a pixel really.

00:19:26.800 --> 00:19:29.930
If you're printing,
you can sometimes get to the pixel,

00:19:29.930 --> 00:19:31.380
sometimes not,
depending on if you're going to

00:19:31.380 --> 00:19:33.620
a PostScript or a Raster printer.

00:19:33.680 --> 00:19:38.680
If you're actually going to a PDF file,
for example, you know,

00:19:38.680 --> 00:19:41.050
they make a big deal out of
being able to write out PDF files

00:19:41.090 --> 00:19:44.760
from just about anything,
you can actually have a context that

00:19:44.760 --> 00:19:50.050
represents a PDF document and you can
draw a CG context calls into that context

00:19:50.050 --> 00:19:52.400
and it goes out into the PDF file.

00:19:52.400 --> 00:19:56.890
Well, there's no pixels that you can
get to behind that context.

00:19:57.170 --> 00:20:01.040
So if you want to be able to
say do some CG drawing and then

00:20:01.040 --> 00:20:04.090
get at the bits after that,
what do you do?

00:20:04.120 --> 00:20:06.690
Well, there's a thing called

00:20:07.690 --> 00:20:09.540
CG bitmap context create.

00:20:09.540 --> 00:20:13.150
That as you might imagine
creates a bitmap context.

00:20:13.150 --> 00:20:16.220
And you get to specify all of
the parameters for this bitmap.

00:20:16.300 --> 00:20:19.770
You can say what the data pointer
is to initialize it with some data.

00:20:19.770 --> 00:20:23.200
Or you can pass null and it will
allocate the data blank for you.

00:20:23.200 --> 00:20:26.580
You pass width and height,
bits per component, the color space.

00:20:26.660 --> 00:20:29.590
You define essentially how
each pixel is represented.

00:20:29.600 --> 00:20:34.590
And this gives you a bitmap that you
can then use CG calls and draw into.

00:20:34.600 --> 00:20:37.590
But you can also get
to the bits directly.

00:20:38.840 --> 00:20:41.430
So this is what it looks like.

00:20:41.470 --> 00:20:43.080
So you do bitmap context create.

00:20:43.080 --> 00:20:45.420
Instead of just doing
the create for the port,

00:20:45.420 --> 00:20:47.380
we do a bitmap context.

00:20:47.420 --> 00:20:50.520
Pass it in your initialization data,
a width and a height, bits per component,

00:20:50.560 --> 00:20:51.600
color space.

00:20:51.600 --> 00:20:54.220
Then alpha info tells it whether
there's an alpha at the beginning,

00:20:54.220 --> 00:20:57.660
an alpha at the end, no alpha at all,
those kinds of things.

00:20:57.660 --> 00:20:59.700
And at this point,
you can just proceed with your

00:20:59.700 --> 00:21:03.310
normal core graphics operations,
just like it's any other context.

00:21:03.960 --> 00:21:06.300
or as I mentioned you can access
the bits because you still

00:21:06.300 --> 00:21:07.590
know where the data pointer is.

00:21:07.590 --> 00:21:08.730
You still know where the bits are.

00:21:08.730 --> 00:21:12.400
So, you can go both ways there.

00:21:13.430 --> 00:21:17.900
Now, I mentioned that clipping
was also different.

00:21:18.020 --> 00:21:20.990
When you use that code that
I've showed you before to go

00:21:21.110 --> 00:21:24.750
from a port to a CG context,

00:21:25.940 --> 00:21:28.880
There are some things that
the context doesn't inherit.

00:21:28.880 --> 00:21:31.900
In fact, it inherits very little
of the Quick Draw state.

00:21:31.900 --> 00:21:32.890
Clipping is one of them.

00:21:32.900 --> 00:21:35.560
If you're using Clip Regions
in your Quick Draw port and you

00:21:35.560 --> 00:21:38.330
create a CG context and you start
drawing with CG drawing commands,

00:21:38.330 --> 00:21:39.900
it's going to draw all over everything.

00:21:39.900 --> 00:21:41.900
It's going to ignore the
Quick Draw Clip Region.

00:21:41.900 --> 00:21:43.890
So what do we do about that?

00:21:43.890 --> 00:21:48.080
Well, the straightforward way,
you grab the Clip Region from the

00:21:48.080 --> 00:21:53.900
CGraph port and then you call this
new call Clip CG Context to Region.

00:21:53.900 --> 00:21:59.110
And that simply takes the region you
give it from Quick Draw and actually

00:21:59.110 --> 00:22:01.540
turns that into a CG Clip Path.

00:22:03.420 --> 00:22:04.800
This one's a little bit more complicated.

00:22:04.800 --> 00:22:06.600
So again, we create our port.

00:22:06.700 --> 00:22:09.120
And now we want to make the clip match.

00:22:09.530 --> 00:22:12.640
This is an important step,
that new region.

00:22:12.640 --> 00:22:14.630
When I tried to do this
demo the first time,

00:22:14.720 --> 00:22:16.630
I forgot that.

00:22:17.770 --> 00:22:18.940
It didn't work very well.

00:22:18.940 --> 00:22:20.600
Let's just leave it at that.

00:22:20.610 --> 00:22:23.870
So you create a new region,
an empty region.

00:22:23.920 --> 00:22:25.300
You also need the bounds.

00:22:25.340 --> 00:22:28.130
And then you get the port clip region.

00:22:28.120 --> 00:22:30.660
and you clip the CG context to region.

00:22:30.710 --> 00:22:33.940
So, a couple of simple steps
and then you're also,

00:22:33.940 --> 00:22:36.090
you're done with the region so you
can dispose of it at that point.

00:22:36.100 --> 00:22:41.940
And at this point,
your CG context clip path matches the

00:22:41.940 --> 00:22:44.100
region that you had in Quick Draw.

00:22:44.100 --> 00:22:48.570
So let's do a quick
little demo of that one.

00:23:01.150 --> 00:23:03.800
same little rocket ship.

00:23:03.870 --> 00:23:08.600
It's entered the same demo.

00:23:08.600 --> 00:23:11.970
Except in this case, before I started,

00:23:12.210 --> 00:23:16.470
I set a clip,
or set the clip region in Quick Draw to a

00:23:16.470 --> 00:23:19.300
couple of ovals kind of X-ored together.

00:23:20.980 --> 00:23:23.340
And of course,
Quick Draw would honor that by default,

00:23:23.340 --> 00:23:26.020
but once you create the
context and start drawing these

00:23:26.020 --> 00:23:30.500
CG context images into that,
they're not gonna honor it.

00:23:30.500 --> 00:23:36.850
So you use this code that I've shown you,
pass in this clip region to CG,

00:23:36.850 --> 00:23:40.900
and it turns it into a clip path
and just does the right thing.

00:23:40.980 --> 00:23:44.850
And incidentally, it also clips,
because I clip before the erase

00:23:44.930 --> 00:23:48.990
of the back buffer to black,
so it clips that as well.

00:24:03.690 --> 00:24:06.370
So there are a few things about
Quick Draw on 10 that are a

00:24:06.370 --> 00:24:07.590
little different than on 9.

00:24:07.600 --> 00:24:20.780
One interesting thing you need to be a
little bit wary of is create new port,

00:24:20.780 --> 00:24:23.140
which you use to create a new graph port.

00:24:23.210 --> 00:24:24.650
At the moment,

00:24:25.800 --> 00:24:41.300
[Transcript missing]

00:24:41.420 --> 00:24:44.450
Another thing to note
is that in the past,

00:24:44.460 --> 00:24:47.900
especially for things where
you were using copy mask or

00:24:48.200 --> 00:24:51.300
seed fill and things like that,
you needed a graph port.

00:24:51.300 --> 00:24:54.790
You needed essentially a one
bit buffer to hold the mask.

00:24:54.790 --> 00:24:59.090
You used open port and create port,
or new port, excuse me.

00:24:59.100 --> 00:25:01.850
Well, those have been replaced
by create new port,

00:25:01.850 --> 00:25:05.100
but create new port can't create
black and white graph ports.

00:25:05.100 --> 00:25:27.300
[Transcript missing]

00:25:28.240 --> 00:25:30.970
Another thing that's different
about Quick Draw is because of the

00:25:30.970 --> 00:25:35.750
double buffered windows in Mac OS X,
you need this little thing

00:25:35.750 --> 00:25:37.280
called QD flush port buffer.

00:25:37.800 --> 00:25:40.890
and for the most part you may or
may not run into this depending

00:25:40.890 --> 00:25:43.330
on how you do your event loop,
but

00:25:43.350 --> 00:25:46.640
If you're used to not
calling wait next event,

00:25:46.640 --> 00:25:49.620
your game likes to take
over the whole machine,

00:25:49.620 --> 00:25:51.420
and you start doing quick
draw drawing in a loop,

00:25:51.450 --> 00:25:55.140
you may find that your animation
never appears on the screen.

00:25:55.140 --> 00:25:56.800
And you scratch your head for a while.

00:25:56.930 --> 00:26:00.220
Well, it turns out,
if you're not calling wait next event,

00:26:00.220 --> 00:26:03.680
which is when an implicit flush
of the back buffer occurs,

00:26:03.760 --> 00:26:05.790
you need to call QD flush port buffer.

00:26:05.810 --> 00:26:08.190
And that'll actually tell the
Windows system to flush the

00:26:08.190 --> 00:26:09.800
back buffer to the screen.

00:26:09.960 --> 00:26:14.150
And so if you're in a tight little
loop doing some animation or whatever,

00:26:14.180 --> 00:26:15.740
you need to call that.

00:26:16.370 --> 00:26:19.300
Another, I guess,
bonus of QD flush port buffer

00:26:19.710 --> 00:26:21.200
is when it comes to VBL syncing.

00:26:21.200 --> 00:26:25.000
I'll talk about this in a little bit,
but QD flush port buffer is also

00:26:25.000 --> 00:26:26.540
VBL synced where it's possible.

00:26:26.540 --> 00:26:29.410
It's not possible in all hardware.

00:26:31.760 --> 00:26:35.160
So that leads us directly
into tear-free blitting.

00:26:35.230 --> 00:26:36.410
A good goal.

00:26:36.510 --> 00:26:40.090
And for most of you out there,
we've got you covered.

00:26:40.170 --> 00:26:42.610
OpenGL itself can sync to the VBL,
and in fact,

00:26:42.700 --> 00:26:45.500
that's one of the best ways to do it,
because it's the card itself

00:26:45.500 --> 00:26:46.700
doing the VBL syncing.

00:26:46.700 --> 00:26:51.330
And there's one quick call,
AGL set integer on the context,

00:26:51.330 --> 00:26:55.310
set the swap interval to one,
and that will take care of telling

00:26:55.310 --> 00:26:59.700
OpenGL that you'd really like it
to only swap on the vertical blank.

00:26:59.700 --> 00:27:03.660
So for all of you full
screen OpenGL apps out there,

00:27:03.700 --> 00:27:04.700
there you go.

00:27:04.700 --> 00:27:08.370
Now for those of you that
are doing windowed apps,

00:27:08.940 --> 00:27:12.540
You can use the back buffer.

00:27:12.630 --> 00:27:14.530
This is also an important point.

00:27:14.590 --> 00:27:18.190
We already provide a back buffer,
so if you're doing your own

00:27:18.190 --> 00:27:20.290
double buffering system,

00:27:20.300 --> 00:27:29.800
[Transcript missing]

00:27:30.400 --> 00:27:35.200
So use our outback buffer and also when
you flush the back buffer for the window

00:27:35.200 --> 00:27:39.840
to the screen using QD flush port buffer
or if you're using the CG context,

00:27:39.850 --> 00:27:44.120
there's a CG context flush that's
essentially the same thing.

00:27:44.230 --> 00:27:48.670
We flush that sync to the VBL for
you when it's actually supported

00:27:48.670 --> 00:27:51.090
by the hardware on the machine.

00:27:51.300 --> 00:27:56.500
[Transcript missing]

00:27:59.530 --> 00:28:02.700
So along the lines of tear-free blitting,
some other things to watch out for.

00:28:02.740 --> 00:28:06.240
Since Mac OS X is a fully preemptive OS,
you don't always have

00:28:06.240 --> 00:28:07.500
control of the whole machine.

00:28:07.500 --> 00:28:10.490
You don't always have control of
when you get swapped in and out.

00:28:10.500 --> 00:28:14.820
So if you try to do direct screen access,
which you can do with the

00:28:14.820 --> 00:28:17.990
CG Direct Display API,
it's going to be very hard to sync

00:28:17.990 --> 00:28:21.500
to the VBO because the scheduler
is always trying to balance things

00:28:21.550 --> 00:28:23.500
and swap things in and out to
make sure everybody has time.

00:28:23.500 --> 00:28:27.500
You may be halfway through drawing
to the screen and get swapped out.

00:28:27.500 --> 00:28:29.500
That's the way things go.

00:28:29.500 --> 00:28:30.440
So that makes it very difficult.

00:28:30.490 --> 00:28:34.500
So if possible,
let us do the VBO syncing for you.

00:28:34.500 --> 00:28:38.560
We've got the best chance of making
it happen on the given hardware

00:28:38.560 --> 00:28:40.470
and we can do it very easily.

00:28:40.530 --> 00:28:47.490
So use the AGO set integer or use the
actual flushing of window buffers.

00:28:47.500 --> 00:28:50.500
Let us do the syncing for you.

00:28:51.700 --> 00:28:55.200
I've got a couple of quick demos of this.

00:28:55.210 --> 00:28:57.710
Give you a peek at

00:28:59.350 --> 00:29:01.300
What Novibelle syncing looks like.

00:29:01.410 --> 00:29:04.300
It actually tears pretty
bad on my machine here.

00:29:04.300 --> 00:29:09.470
That tears every now and then.

00:29:09.470 --> 00:29:09.470
Let's see if it'll do it for us.

00:29:10.950 --> 00:29:12.900
That's actually not bad.

00:29:12.900 --> 00:29:17.650
Figures the demo works
better than it's supposed to.

00:29:17.740 --> 00:29:18.870
Oh wait, I saw it.

00:29:18.890 --> 00:29:22.500
There it goes.

00:29:22.500 --> 00:29:24.330
That's better.

00:29:27.340 --> 00:29:29.540
No respect.

00:29:29.590 --> 00:29:35.360
That's what tearing looks like for those
of you that have never seen VBL tearing.

00:29:35.440 --> 00:29:40.360
So now if we actually use
the QD flush port buffer,

00:29:40.380 --> 00:29:42.650
we can sync to the VBL, right?

00:29:46.700 --> 00:29:48.700
Not exactly.

00:29:48.710 --> 00:29:52.020
And that's one of the things-- I was
initially very disappointed that this

00:29:52.020 --> 00:29:55.080
demo didn't work when I got here,
because I'd had this all planned,

00:29:55.100 --> 00:29:57.440
gone to the work to make
it sync very nicely,

00:29:57.540 --> 00:30:01.780
made sure that we could get nice,
smooth animation, no tearing.

00:30:01.810 --> 00:30:03.970
Get in the demo room, it doesn't work.

00:30:05.490 --> 00:30:08.840
Well, it turns out this brings up
a very interesting point.

00:30:08.910 --> 00:30:13.070
You can't always sync to the VBL,
no matter how much you want to.

00:30:13.200 --> 00:30:51.900
[Transcript missing]

00:30:52.900 --> 00:30:55.490
and be aware that no matter how
much you want to sync to the VBL,

00:30:55.490 --> 00:30:59.190
no matter how much you
want the demo to work,

00:30:59.190 --> 00:31:00.380
it may not.

00:31:07.200 --> 00:31:11.200
So let's talk a little bit
about a few OpenGL changes.

00:31:11.200 --> 00:31:18.230
Many of you are using OpenGL.

00:31:18.240 --> 00:31:21.140
Got some great games
out there using OpenGL.

00:31:21.150 --> 00:31:23.640
OpenGL and Mac OS X rocks,
good performance.

00:31:23.640 --> 00:31:26.800
But there are a few differences
that you need to be aware of.

00:31:26.800 --> 00:31:31.350
And we'll also talk a little bit
about how it's different with

00:31:31.420 --> 00:31:33.630
respect to using Withdraw Sprocket.

00:31:34.000 --> 00:31:42.400
[Transcript missing]

00:31:43.760 --> 00:31:45.400
So a few important differences.

00:31:45.410 --> 00:31:47.890
AGL full screen works.

00:31:47.910 --> 00:31:48.940
That's a big one.

00:31:48.940 --> 00:31:52.650
In the past, on Mac OS 9,
AGL full screen wasn't there.

00:31:53.100 --> 00:31:55.360
On Mac OS X you can call AGL full screen.

00:31:55.360 --> 00:31:57.900
I believe you can pass it
even the resolution you want,

00:31:57.900 --> 00:31:59.840
the bit depth,
and it does all the work for you.

00:32:00.020 --> 00:32:02.830
Very good way to get into full
screen mode in OpenGL in a hurry.

00:32:02.860 --> 00:32:07.070
OpenGL does all the
heavy lifting for you.

00:32:07.770 --> 00:32:11.230
We've also added a few new features.

00:32:11.240 --> 00:32:15.350
We have support for stencil
buffers and aux buffers.

00:32:15.430 --> 00:32:17.200
I'd like to point out stencil
buffers in particular.

00:32:17.200 --> 00:32:20.110
There's an OpenGL talk coming up.

00:32:20.730 --> 00:32:26.080
and I will be talking about how to do
dynamic shadows with stencil buffers.

00:32:26.080 --> 00:32:27.650
That's pretty cool.

00:32:27.690 --> 00:32:31.520
He's also got a few other
cool demos in there as well.

00:32:31.560 --> 00:32:33.760
So that's a good talk to go to.

00:32:33.770 --> 00:32:38.320
And I'll point you to that once
we get to the end of the talk.

00:32:38.690 --> 00:32:40.180
and then there's some new extensions.

00:32:40.300 --> 00:32:43.020
We support packed pixels now
and a few other good things.

00:32:43.110 --> 00:32:47.390
So for more information on those things,
go to the OpenGL sessions and they'll

00:32:47.460 --> 00:32:48.600
give you some more information.

00:32:48.600 --> 00:32:51.600
Another thing to note is
OpenGL is fully supported.

00:32:51.600 --> 00:32:53.590
You can call it from Carbon and Cocoa.

00:32:53.680 --> 00:32:56.840
From Carbon you can use all the AGL APIs.

00:32:56.840 --> 00:32:59.600
From Cocoa there's actually
some very good classes.

00:32:59.600 --> 00:33:03.770
For NSOpenGL there's NSOpenGL view
which makes it very easy to bring an

00:33:03.770 --> 00:33:09.800
OpenGL view into your window and get all
the information set up for OpenGL and

00:33:09.800 --> 00:33:12.190
then start making OpenGL calls.

00:33:13.290 --> 00:33:15.200
A few more differences.

00:33:15.200 --> 00:33:17.200
AGL update context is more critical.

00:33:17.200 --> 00:33:20.450
You need to call it when you
make changes to the context that

00:33:20.520 --> 00:33:23.170
OpenGL knows what's going on.

00:33:23.220 --> 00:33:25.810
I think in some cases you
could get away with not calling

00:33:25.810 --> 00:33:29.080
it everywhere on Mac OS 9,
but on 10 it's much more critical,

00:33:29.140 --> 00:33:30.200
you need to call it.

00:33:30.690 --> 00:33:34.310
And also, AGL set drawable.

00:33:34.560 --> 00:33:38.990
A number of people could get away
with calling AGL set drawable just

00:33:39.240 --> 00:33:41.480
passing in the window pointer.

00:33:41.540 --> 00:33:44.080
Because on Mac OS 9,
window pointer was pretty much

00:33:44.080 --> 00:33:46.500
the same as a C graph pointer.

00:33:46.500 --> 00:33:48.500
Well, Mac OS X,
they're not the same thing.

00:33:48.500 --> 00:33:51.570
And if you've got a window ref
on Mac OS X from a Carbon window,

00:33:51.590 --> 00:33:57.500
you need to make sure you call get window
port and pass that port to set drawable.

00:33:57.650 --> 00:34:00.500
Otherwise,
it's not going to do what you expect.

00:34:05.580 --> 00:34:09.650
So how do we make this
play with Drossproget?

00:34:09.750 --> 00:34:11.890
Well, on Mac OS 9,

00:34:12.110 --> 00:34:14.300
When you wanted to be able
to get hardware acceleration,

00:34:14.300 --> 00:34:16.350
multiple monitors,
be able to support all those things,

00:34:16.390 --> 00:34:19.760
typically what you would do is you would
create a window on top of DrawSprocket,

00:34:19.760 --> 00:34:20.500
as I mentioned earlier.

00:34:20.500 --> 00:34:22.130
Just create a full screen window,
it was black,

00:34:22.160 --> 00:34:23.470
nobody would know the difference.

00:34:23.490 --> 00:34:27.480
And you'd actually pass
that off to set drawable.

00:34:27.500 --> 00:34:30.160
And that would make sure it
took care of multiple monitors,

00:34:30.160 --> 00:34:32.500
hardware acceleration,
all the good things.

00:34:32.500 --> 00:34:34.500
On Mac OS X you don't
need to do that anymore.

00:34:34.500 --> 00:34:36.500
And in fact you can't.

00:34:36.660 --> 00:34:38.500
Because once you've taken over
the screen with DrawSprocket,

00:34:38.500 --> 00:34:40.440
it's the top most window.

00:34:40.500 --> 00:34:42.500
So you can't put a
window up on top of it.

00:34:42.500 --> 00:34:48.500
So what you need to do now is call
this DSPContextGetFrontBuffer.

00:34:48.500 --> 00:34:51.500
And that will return you a CGraphPointer.

00:34:51.500 --> 00:34:54.500
And that CGraphPointer you can
actually pass to AGLSetDrawable.

00:34:56.200 --> 00:35:09.200
[Transcript missing]

00:35:11.070 --> 00:35:16.040
So in a quick summary before we get
into more discussion of the roadmap,

00:35:16.230 --> 00:35:18.600
use DrawSpark or the CGDirect display.

00:35:18.610 --> 00:35:19.490
They're great.

00:35:19.500 --> 00:35:22.000
The APIs are there for you
to manipulate the displays,

00:35:22.020 --> 00:35:23.630
capture the displays.

00:35:23.700 --> 00:35:27.760
As I mentioned, CGDirect display takes
care of making sure that

00:35:28.100 --> 00:35:54.300
[Transcript missing]

00:35:54.770 --> 00:35:57.770
Another important thing to take
out of here is Mac OS X double

00:35:57.770 --> 00:36:00.070
buffers so you don't have to.

00:36:00.240 --> 00:36:01.170
and David Schmuck.

00:36:01.200 --> 00:36:03.900
So if you're already doing a bunch of
work to double buffer your drawing,

00:36:03.900 --> 00:36:05.200
we've got that covered for you.

00:36:05.200 --> 00:36:06.920
Every window is double buffered.

00:36:06.920 --> 00:36:09.080
When you draw into the window port,
you're actually drawing

00:36:09.200 --> 00:36:11.380
into the back buffer,
which also means don't

00:36:11.380 --> 00:36:12.620
forget to call flush.

00:36:12.640 --> 00:36:14.700
Make sure you call CG flush port buffer.

00:36:14.700 --> 00:36:20.360
Or if you're drawing in Quick Draw,
make sure you call QD flush port buffer.

00:36:20.360 --> 00:36:23.000
Also watch out for some of
those minor Quick Draw changes

00:36:23.010 --> 00:36:25.120
that I mentioned before.

00:36:25.120 --> 00:36:26.880
And OpenGL and Mac OS X.

00:36:26.880 --> 00:36:29.410
It's there, it works, it rocks.

00:36:29.410 --> 00:36:29.760
Use it.

00:36:31.110 --> 00:36:33.700
So let's take a look at all
of the games related sessions

00:36:33.740 --> 00:36:36.180
that are coming up this week.

00:36:37.130 --> 00:36:41.860
We're already into Tuesday afternoon,
but there's a few other sessions

00:36:41.860 --> 00:36:44.340
on that 17 session track that
I'm not going to call out.

00:36:44.340 --> 00:36:46.170
I'm just going to hit some
of the highlights here.

00:36:46.340 --> 00:36:47.710
OpenGL.

00:36:47.710 --> 00:36:53.590
Four very good OpenGL talks coming up
tomorrow afternoon and Thursday morning.

00:36:53.630 --> 00:36:54.910
You might want to look into those.

00:36:55.070 --> 00:36:59.520
High Performance 2D is going to show
you how to do some multi-texturing

00:36:59.520 --> 00:37:03.500
of large images and scrolling
of images and things for 2D.

00:37:03.570 --> 00:37:05.700
With the techniques that
Geoff's going to present,

00:37:05.700 --> 00:37:09.540
you can put together a really cool
side scroller and actually scroll all

00:37:09.540 --> 00:37:13.840
over the place in both directions.

00:37:13.930 --> 00:37:15.830
Right after that, in the same room,
we're going to cover

00:37:15.830 --> 00:37:16.860
geometry and modeling.

00:37:16.860 --> 00:37:20.800
Todd's going to take you through how
to go a little bit beyond that little

00:37:20.800 --> 00:37:24.510
spinning square demo that we have
in a lot of our sample apps to some

00:37:24.510 --> 00:37:27.590
more advanced modeling and animation.

00:37:28.310 --> 00:37:32.940
Then Thursday morning,
John Stauffer is going to cover

00:37:32.990 --> 00:37:36.120
some optimization techniques,
how to get more performance

00:37:36.120 --> 00:37:41.540
out of your OpenGL code,
and how to speed things up and also

00:37:41.540 --> 00:37:45.650
talk about some other interesting
aspects of OpenGL performance.

00:37:45.700 --> 00:37:48.870
And then right after that,
Thursday morning,

00:37:49.070 --> 00:37:51.160
we have advanced rendering.

00:37:51.200 --> 00:37:53.700
As I mentioned, we're going to cover some
stencil buffer techniques.

00:37:53.700 --> 00:37:59.340
Also going to cover bump mapping
and cubic environment mapping and

00:37:59.340 --> 00:38:01.930
I forget what the fourth one is,
but good stuff.

00:38:01.970 --> 00:38:03.150
All four of those are good.

00:38:03.190 --> 00:38:07.890
If you have some feedback for us as far
as OpenGL goes and the work we're doing,

00:38:07.890 --> 00:38:10.740
Thursday at 5,
come to the feedback forum.

00:38:10.770 --> 00:38:14.080
Make sure you come and
give us your feedback.

00:38:15.770 --> 00:38:17.530
But wait, there's more.

00:38:17.610 --> 00:38:19.900
So Input for Games.

00:38:20.030 --> 00:38:22.500
Friday at 10:30 in the morning,
Geoff's going to be talking

00:38:22.500 --> 00:38:24.010
about Input for Games.

00:38:24.010 --> 00:38:27.720
As many of you know,
Input Sprocket is not on Mac OS X,

00:38:27.750 --> 00:38:29.400
but we're going to be
talking about HID Manager,

00:38:29.400 --> 00:38:31.700
which is the Input Sprocket replacement.

00:38:31.700 --> 00:38:35.140
And then following that afternoon,
we're going to cover

00:38:35.140 --> 00:38:36.690
Sound and Networking.

00:38:36.770 --> 00:38:40.630
So we'll be talking a little bit
about the Carbon Sound Manager,

00:38:40.690 --> 00:38:43.880
about QuickTime,
also some about Core Audio and

00:38:43.880 --> 00:38:45.700
some things you can do with it.

00:38:45.700 --> 00:38:49.610
And then get into some Open Transport,
Open Play, things like that.

00:38:49.690 --> 00:38:53.690
And another feedback
forum Friday at 5:00.

00:38:53.760 --> 00:38:56.850
If you have some feedback for
us as far as games related

00:38:56.850 --> 00:39:00.470
technologies and things like that,
please come to the feedback

00:39:00.470 --> 00:39:02.670
session Friday at 5:00.

00:39:06.050 --> 00:39:07.160
And so who to contact.

00:39:07.340 --> 00:39:10.230
If you have contact information,
if you have questions,

00:39:10.240 --> 00:39:11.940
send it to DTS@apple.com.

00:39:11.940 --> 00:39:13.790
We'll be glad to help you out.
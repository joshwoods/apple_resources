WEBVTT

00:00:01.770 --> 00:00:04.950
Today's session is going to
be about describing at a high

00:00:05.000 --> 00:00:09.220
level what we have to offer in
three new Apple Java frameworks:

00:00:09.220 --> 00:00:15.520
Java Spelling Framework,
Java Speech Synthesis Framework,

00:00:15.520 --> 00:00:15.520
and Java Speech Recognition Framework.

00:00:17.870 --> 00:00:23.600
These APIs are free and they
will be available this week,

00:00:23.960 --> 00:00:24.800
surely by Friday.

00:00:24.800 --> 00:00:26.300
They're in the pipeline.

00:00:26.300 --> 00:00:30.680
We just need to put them on the web
from our Apple developers website

00:00:30.810 --> 00:00:36.400
and you can download them and use
them with Java and your favorite IDE,

00:00:36.400 --> 00:00:42.940
JBuilder that you got in the bag,
MetroWorks, ProjectBuilder,

00:00:42.950 --> 00:00:42.950
what have you,
and have some fun with them.

00:00:43.820 --> 00:00:47.430
We're not going to go into a lot of
detail about how Speech Synthesis

00:00:47.430 --> 00:00:51.100
and Speech Recognition work or
about all their capabilities.

00:00:51.100 --> 00:00:55.140
By that I mean the underlying
technologies built into OS X that

00:00:55.140 --> 00:00:58.700
have been around for a while
in different versions of OS 9,

00:00:58.700 --> 00:00:59.690
OS 8, etc.

00:01:00.040 --> 00:01:03.140
But you can find more information
about those things on our

00:01:03.140 --> 00:01:04.610
Apple Developers website.

00:01:04.950 --> 00:01:08.700
And we're assuming that you
all are familiar with Java.

00:01:08.700 --> 00:01:12.690
Now one thing we're going
to talk about is Java Beans.

00:01:12.700 --> 00:01:16.470
One of the things we've designed
into these APIs is to allow them

00:01:16.470 --> 00:01:18.700
to be used in visual builders.

00:01:18.700 --> 00:01:21.700
The premier example is JBuilder.

00:01:21.700 --> 00:01:25.780
And before we go on,
I just wanted to review

00:01:25.780 --> 00:01:28.680
exactly what a Java Bean is.

00:01:28.680 --> 00:01:36.610
So it's basically at a high level method
that was designed by Sun and its partners

00:01:36.680 --> 00:01:38.700
to be able to share discrete data.

00:01:38.700 --> 00:01:41.420
So Java Bean is a class that has
discrete components among third party

00:01:41.450 --> 00:01:45.700
developers and tool vendors so that
each tool can interoperate and use

00:01:45.700 --> 00:01:48.570
visually these discrete components.

00:01:48.700 --> 00:01:54.220
So technically a Java Bean is basically a
class that has certain method signatures

00:01:54.220 --> 00:01:59.700
or another class called a Bean Info that
is its pair that describes properties.

00:01:59.700 --> 00:02:01.700
It can also generate events.

00:02:01.700 --> 00:02:03.900
So for example,
the classic Bean would be a

00:02:03.900 --> 00:02:06.780
button and you could get an
action event on that button,

00:02:06.780 --> 00:02:07.700
for example.

00:02:07.700 --> 00:02:07.700
So Java Bean is a class that has
certain method signatures or another

00:02:07.700 --> 00:02:07.700
class called a Bean Info that is
its pair that describes properties.

00:02:07.700 --> 00:02:08.700
It can also generate events.

00:02:08.700 --> 00:02:08.700
So for example,
the classic Bean would be a

00:02:08.700 --> 00:02:08.700
button and you could get an
action event on that button,

00:02:08.700 --> 00:02:08.700
for example.

00:02:08.850 --> 00:02:12.900
And the Java Bean specification
also defines methods to provide

00:02:13.000 --> 00:02:14.700
editors and customizers.

00:02:14.780 --> 00:02:18.850
That is, something richer than you'd get
by default in a visual builder,

00:02:18.850 --> 00:02:22.700
such as just editing a string or
cranking up a number up and down,

00:02:22.700 --> 00:02:24.500
switching true to false, etc.

00:02:24.700 --> 00:02:27.660
And Java Beans, of course,
are part of the

00:02:27.660 --> 00:02:32.690
Mac OS X J2SE implementation,
part of all J2 implementations.

00:02:32.700 --> 00:02:37.930
So the first framework we'll discuss
is the Java Speech Framework.

00:02:38.240 --> 00:02:43.100
The Java Speech Framework is basically
layered upon the Synthesis and

00:02:43.240 --> 00:02:47.100
Recognition technologies built into OS X,
as I said before.

00:02:47.100 --> 00:02:48.980
These are from Carbon.

00:02:49.340 --> 00:02:53.090
They exist on Mac OS 9.1
and Carbon as well,

00:02:53.100 --> 00:02:55.100
the native versions.

00:02:55.100 --> 00:02:59.090
Of course,
we're running on OS X here today.

00:03:00.160 --> 00:03:02.690
So what are some of the differences
between what we're talking about

00:03:02.710 --> 00:03:05.160
today and the underlying technologies?

00:03:05.160 --> 00:03:07.220
Well,
the Java Speech API are object-based,

00:03:07.220 --> 00:03:13.880
whereas the Carbon API are C API,
native API.

00:03:13.880 --> 00:03:17.720
The Java frameworks provide
programmatic as well as visual

00:03:18.000 --> 00:03:20.460
programming for the frameworks.

00:03:20.460 --> 00:03:24.530
The Carbon API are only programmatic.

00:03:24.560 --> 00:03:26.570
Java Speech API are a higher level.

00:03:26.570 --> 00:03:30.910
The, the Carbon C API provides very,
very low level,

00:03:30.910 --> 00:03:35.000
every single possible thing
you'd ever want to do with

00:03:35.000 --> 00:03:38.100
Speech Syntheis or Speech Recognition.

00:03:38.100 --> 00:03:40.910
The Java Speech API are
only available on Mac OS X.

00:03:41.160 --> 00:03:45.660
The native API are available
on Carbon 7.5 and beyond.

00:03:47.190 --> 00:03:49.680
So, Speech Synthesis.

00:03:50.040 --> 00:03:53.140
Basically,
it's about converting text to speech.

00:03:53.140 --> 00:03:57.280
And we provide in our Java frameworks
about 99% coverage of the functionality

00:03:57.280 --> 00:03:59.830
you'll find in the Carbon API.

00:03:59.890 --> 00:04:01.020
It's architecturally neutral.

00:04:01.260 --> 00:04:03.860
Now, what we mean by that is,

00:04:04.070 --> 00:04:08.280
Speech synthesis provides
the ability to get callbacks.

00:04:08.280 --> 00:04:11.500
Instead of just saying, speak this text,
you may want to know when it's

00:04:11.570 --> 00:04:14.780
done speaking a particular word,
a sentence,

00:04:14.780 --> 00:04:17.000
when it's done speaking a part of a word.

00:04:17.000 --> 00:04:21.360
You can even stick other cues into
the string that it's speaking,

00:04:21.360 --> 00:04:25.000
and we'll go into that more later,
and get callbacks from

00:04:25.160 --> 00:04:26.280
the speech technology.

00:04:26.280 --> 00:04:30.910
Now, those callbacks won't necessarily
happen on the UI thread of whatever

00:04:31.030 --> 00:04:36.880
particular UI toolkit you're using,
Swing, NBT, IFC, Cocoa, etc.

00:04:36.960 --> 00:04:41.120
So what we've done is we've put in
a thread task handler and a default

00:04:41.120 --> 00:04:45.680
implementation for Swing to provide
that synchronization for you by default,

00:04:45.680 --> 00:04:52.450
and an abstraction in the task handler
interface that allows you to add your

00:04:52.450 --> 00:04:56.260
own synchronization between the speech
thread and the task handler interface.

00:04:56.280 --> 00:05:00.190
callback thread, and the UI thread.

00:05:00.500 --> 00:05:04.090
and we provide Java Beans and
customized property editors for

00:05:04.180 --> 00:05:06.990
tight integration with the Java IDs.

00:05:07.880 --> 00:05:12.740
So the main classes-- there are others,
but the main 2 classes of speech

00:05:13.580 --> 00:05:15.550
synthesis are the synthesizer itself.

00:05:15.560 --> 00:05:20.040
And it basically allows you to speak
the text and attach event listeners to

00:05:20.040 --> 00:05:22.740
the different events that it generates.

00:05:22.740 --> 00:05:27.120
The voice class which embodies all
the characteristics of a voice.

00:05:27.120 --> 00:05:32.120
Now Mac OS X as Mac OS IX and
in previous Mac OSes have,

00:05:32.120 --> 00:05:35.080
has built in voices,
about a half dozen different voices

00:05:35.080 --> 00:05:36.800
of different characteristics.

00:05:36.800 --> 00:05:39.520
One sounds like a robot,
one sounds like a young girl,

00:05:39.520 --> 00:05:42.560
one sounds like an older man, et cetera,
et cetera.

00:05:42.560 --> 00:05:44.550
All these voices have names.

00:05:44.560 --> 00:05:47.880
And the voice class allows you to
pick one of these voices by name,

00:05:48.280 --> 00:05:51.510
adjust its properties,
properties such as the rate

00:05:51.650 --> 00:05:57.200
with which the voice speaks,
its pitch, its volume, et cetera.

00:05:59.240 --> 00:06:04.600
We have three basic events we
generate from the speech synthesizer.

00:06:04.600 --> 00:06:05.990
The first event is the word event.

00:06:06.210 --> 00:06:10.530
You can listen for that event
whenever the synthesizer concludes

00:06:10.700 --> 00:06:12.610
speaking a particular word.

00:06:12.770 --> 00:06:14.660
You can also listen for the sync event.

00:06:14.740 --> 00:06:19.920
The sync event is something that you
can embed a cue for in the text you're

00:06:19.920 --> 00:06:22.330
asking the synthesizer to speak.

00:06:22.400 --> 00:06:24.220
I'll demonstrate that later.

00:06:24.330 --> 00:06:29.900
A phonem event, which is used to animate,
for example, the face.

00:06:29.900 --> 00:06:34.470
Let's say you wanted a computer
generated face with a mouth to really

00:06:34.810 --> 00:06:37.430
move with the sound of the word.

00:06:37.550 --> 00:06:38.780
You would use these callbacks.

00:06:39.100 --> 00:06:43.550
Again, you can find out detailed
information about that callback,

00:06:43.550 --> 00:06:47.550
those events,
in the speech synthesis documentation for

00:06:47.550 --> 00:06:50.550
Carbon on the Apple Developer website.

00:06:51.030 --> 00:06:53.220
So, you also have other events.

00:06:53.220 --> 00:06:56.160
Since you basically say,
here synthesizer, speak this text,

00:06:56.160 --> 00:06:59.600
and then your thread continues on,
you're not going to be able to

00:06:59.600 --> 00:07:02.660
listen for an exception right there
that may be generated down the road.

00:07:02.660 --> 00:07:04.920
Say the synthesizer itself is a problem.

00:07:04.920 --> 00:07:09.720
Say you embedded incorrectly some sync
event or some other embedded command,

00:07:09.720 --> 00:07:12.900
and we'll go into
embedded commands later.

00:07:12.900 --> 00:07:15.680
You can listen for error events.

00:07:15.680 --> 00:07:20.660
You can also listen for exactly when
the synthesizer begins speaking,

00:07:20.660 --> 00:07:25.390
when it finishes speaking,
whether that is someone stopped it,

00:07:25.470 --> 00:07:33.320
some other API just called stop,
stop talking, or it concluded itself,

00:07:33.320 --> 00:07:36.210
it read all the text,
and that would be the done event.

00:07:37.100 --> 00:07:40.370
So let's do a speech synthesis demo.

00:07:40.370 --> 00:07:48.770
And this demo is packaged
in the speech synthesis SDK.

00:07:49.490 --> 00:07:50.400
Let's launch it here.

00:07:50.400 --> 00:07:54.560
This is just a normal Java app
wrapped with MRJ App Builder.

00:07:54.610 --> 00:07:57.590
And it's built,
this is all Java with a swing,

00:07:57.600 --> 00:07:58.400
Aqua look and feel.

00:07:58.400 --> 00:08:04.600
And it's built to not only show,
not only be a little fun,

00:08:04.750 --> 00:08:05.640
but be educational.

00:08:05.640 --> 00:08:11.260
Because I'm assuming that
Java programmers that want to do

00:08:11.260 --> 00:08:17.170
speech synthesis don't necessarily know
all the capabilities of the synthesis

00:08:17.170 --> 00:08:19.350
system underneath on Mac OS X.

00:08:19.400 --> 00:08:20.720
So it's fun to play with.

00:08:20.720 --> 00:08:23.740
We'll go through and we'll
just ask it to speak something.

00:08:23.740 --> 00:08:28.050
We basically have a voice here, Agnes,
and we can see her age, 35,

00:08:28.050 --> 00:08:31.170
about a female,
etc., the rate that she speaks,

00:08:31.170 --> 00:08:35.860
the pitch, bass, and pitch modulation,
the volume that she speaks at.

00:08:36.110 --> 00:08:37.900
And we'll just ask her to speak.

00:08:37.930 --> 00:08:41.020
Isn't it nice to have a
computer that will talk to you?

00:08:41.020 --> 00:08:44.940
And maybe we want her to
speak a little faster.

00:08:44.940 --> 00:08:47.360
Isn't it nice to have a
computer that will talk to you?

00:08:47.580 --> 00:08:49.300
So you can play around.

00:08:49.490 --> 00:08:51.670
So we'll start with these
and see the different voices.

00:08:51.830 --> 00:08:55.260
We'll go through what's
some more interesting ones.

00:08:55.580 --> 00:09:06.960
And all of these strings, by the way,
are actually built into this system.

00:09:06.960 --> 00:09:14.930
For the particular voices you choose,
they particularly exemplify the type

00:09:15.000 --> 00:09:19.380
of voice that you have selected.

00:09:19.430 --> 00:09:20.370
So let's look at one more.

00:09:20.410 --> 00:09:23.240
Let's look at some really
alien sounding guys.

00:09:23.330 --> 00:09:25.360
That looks like a peaceful planet.

00:09:25.440 --> 00:09:26.520
So different voices.

00:09:26.560 --> 00:09:27.640
It's pretty interesting.

00:09:27.640 --> 00:09:30.440
And this, again,
is just the Java framework.

00:09:30.640 --> 00:09:35.570
Now, another thing that you can do with
speech synthesis is embed commands.

00:09:35.740 --> 00:09:39.980
So let's say, for example,
we have many commands that you can embed.

00:09:40.020 --> 00:09:45.460
An embedded command basically is
just a bracketed keyword in the text.

00:09:45.630 --> 00:09:48.310
That's how you send speech
synthesis embedded commands.

00:09:48.330 --> 00:09:51.320
That's not part of the... That's not
part of the Java speech framework.

00:09:51.320 --> 00:09:55.320
That is actually part of the underlying
speech synthesis technology on OS X.

00:09:55.320 --> 00:09:57.320
And you can do many things.

00:09:57.320 --> 00:10:01.850
You can change the emphasis of a
particular word if you really want to

00:10:01.940 --> 00:10:04.090
hit it heavily as the computer speaks it.

00:10:04.360 --> 00:10:07.310
You can change number mode, for example.

00:10:07.320 --> 00:10:08.310
And this is interesting.

00:10:08.310 --> 00:10:10.320
So let's go play with this for a minute.

00:10:10.320 --> 00:10:13.270
Speech synthesis is pretty intelligent.

00:10:13.430 --> 00:10:16.320
It tries to guess how it
should pronounce numbers.

00:10:16.320 --> 00:10:19.240
But sometimes you need it to
pronounce it single digits.

00:10:19.240 --> 00:10:21.210
Sometimes you need it to
pronounce it digit by digit.

00:10:21.430 --> 00:10:23.240
Other times you need it to read
it as if it was a whole number,

00:10:23.240 --> 00:10:26.240
say 502 instead of 502.

00:10:26.240 --> 00:10:28.240
But let's type something in.

00:10:28.240 --> 00:10:42.240
Let's say, "Please call me at 555-1234
at extension 1234." Or 5678.

00:10:42.420 --> 00:10:43.240
5678.

00:10:43.240 --> 00:10:46.240
Okay, so first we'll listen to the
computer speak this normally.

00:10:46.240 --> 00:10:49.160
Please call me at 555-1234
at extension 1234.

00:10:49.160 --> 00:10:53.160
Please call me at 555-1234
at extension 5678.

00:10:53.160 --> 00:10:54.480
So...

00:10:54.680 --> 00:10:56.440
And there was a little bit
of an interesting hiccup

00:10:56.510 --> 00:10:58.540
in the highlighting there.

00:10:58.540 --> 00:11:01.760
But it pronounced the
first number correctly.

00:11:01.760 --> 00:11:04.430
It recognized it as a phone number,
so it read it individually.

00:11:04.530 --> 00:11:08.060
But an extension number,
you wouldn't normally tell

00:11:08.060 --> 00:11:09.930
someone to call you at 5678.

00:11:09.980 --> 00:11:11.600
You'd say extension 5678.

00:11:11.600 --> 00:11:18.600
So we'll embed here the number command
to ask it to speak this literally.

00:11:18.600 --> 00:11:22.350
And then once we're done at
the other end of the number,

00:11:22.350 --> 00:11:26.600
so it returns to a normal number mode,
we'll insert the normal command again.

00:11:26.600 --> 00:11:27.590
And we'll ask it to speak that again.

00:11:27.720 --> 00:11:33.600
Please call me at 555-1234
at extension 5678.

00:11:34.600 --> 00:11:37.190
So you can do things like that
so it's a little more intelligent

00:11:37.190 --> 00:11:38.600
about what it's pronouncing.

00:11:38.810 --> 00:11:46.600
Another thing that... You can do is,
among all these embedded commands,

00:11:46.600 --> 00:11:50.600
is ask for a sync event,
as I mentioned a few slides earlier.

00:11:50.600 --> 00:11:54.600
Let's say you're using Speech Synthesis
to do a presentation or something,

00:11:54.600 --> 00:11:58.580
and after a certain
sentence or a certain word,

00:11:58.970 --> 00:12:01.600
certain paragraph, you want to present a
graphic on the screen.

00:12:01.620 --> 00:12:05.940
And then you want it to continue
on with what it's doing,

00:12:05.940 --> 00:12:10.600
or you want to sync in some
other way a UI with the speech.

00:12:10.600 --> 00:12:14.850
So let's say... Let's type
in a sentence such as,

00:12:14.850 --> 00:12:20.290
"You can buy product A for $10,000."

00:12:21.450 --> 00:12:24.640
is the Chief Executive Officer of
the Department of

00:12:24.640 --> 00:12:29.040
Communication and Technology at
the University of Minnesota.

00:12:29.040 --> 00:12:29.040
He is the Director of the Department of
Communication and Technology at

00:12:29.040 --> 00:12:29.040
the University of Minnesota.

00:12:29.040 --> 00:12:29.040
He is also the Director of
the Department of

00:12:29.040 --> 00:12:29.040
Communication and Technology at
the University of Minnesota.

00:12:29.450 --> 00:12:33.050
And then let's enter a sync command.

00:12:33.190 --> 00:12:39.750
And the way you enter a sync command,
this is sort of legacy OS 7.5 or so,

00:12:39.750 --> 00:12:46.230
OS 9-ish,
of how they had many four-letter keywords

00:12:46.300 --> 00:12:49.300
for different technologies in OS.

00:12:49.300 --> 00:12:51.710
So in this case,
since the roots of this are

00:12:51.710 --> 00:12:55.300
still in Carbon and earlier OSes,
even though I'm on OS X now,

00:12:55.300 --> 00:13:02.380
we basically need to add a four-letter
keyword to our sync event so

00:13:02.380 --> 00:13:05.370
that when we get a callback,
we'll know exactly which callback

00:13:05.370 --> 00:13:07.300
that was for for the sync event.

00:13:07.300 --> 00:13:09.280
So first I'll embed this here.

00:13:09.300 --> 00:13:13.580
And then, and by the way,
this is just a convenience,

00:13:13.580 --> 00:13:18.290
this whole mechanism I'm
using to embed these commands.

00:13:18.300 --> 00:13:19.300
This is just text.

00:13:19.300 --> 00:13:24.910
So I can actually just
cut and paste here.

00:13:25.750 --> 00:13:39.700
You can buy product for
$5 or product B for $10.

00:13:56.760 --> 00:14:12.000
And so, again,
you could use that to animate

00:14:12.090 --> 00:14:15.990
properly the shape of the
mouth of an animated head,

00:14:15.990 --> 00:14:16.660
for example.

00:14:16.920 --> 00:14:20.640
So that is speech synthesis.

00:14:20.720 --> 00:14:23.700
That's about all the capabilities
that are in speech synthesis.

00:14:24.700 --> 00:14:24.700
Of course, there are other features
that are in speech synthesis.

00:14:24.700 --> 00:14:24.700
For example,
there's the ability to animate

00:14:24.700 --> 00:14:24.700
the mouth of an animated head.

00:14:25.700 --> 00:14:25.700
And so, again,
you can use that to animate properly the

00:14:25.700 --> 00:14:25.700
shape of the mouth of an animated head,
for example.

00:14:25.700 --> 00:14:25.700
So that is speech synthesis.

00:14:25.700 --> 00:14:25.700
That's about all the capabilities
that are in speech synthesis.

00:14:25.700 --> 00:14:25.700
Of course, there are other features
that are in speech synthesis.

00:14:25.700 --> 00:14:25.700
For example,
there's the ability to animate

00:14:25.700 --> 00:14:25.700
the mouth of an animated head.

00:14:26.740 --> 00:14:27.600
There are variations
not shown in this demo.

00:14:27.700 --> 00:14:29.700
For example, you can pause the speech.

00:14:29.700 --> 00:14:34.660
You can choose to stop the
speech at a word break,

00:14:34.700 --> 00:14:39.700
at a sentence break immediately,
and what have you, and same for pausing.

00:14:39.860 --> 00:14:42.240
But let's continue on now.

00:14:43.710 --> 00:14:46.380
to Java Speech Recognition.

00:14:46.490 --> 00:14:50.520
And this is the nightmare demo,
because we've already tried it in here,

00:14:50.520 --> 00:14:53.530
and I feared this before
I even got in this room,

00:14:53.530 --> 00:14:56.600
and the acoustics,
even with none of you in here,

00:14:56.600 --> 00:15:00.530
really plays havoc with this microphone.

00:15:00.620 --> 00:15:02.480
But we'll give it a shot anyways.

00:15:02.480 --> 00:15:06.120
But first let's just talk
about Java Speech Recognition.

00:15:06.120 --> 00:15:09.160
So, Java Speech Recognition.

00:15:09.220 --> 00:15:12.060
It recognizes spoken language
contained in a language model,

00:15:12.070 --> 00:15:15.430
and we'll talk a little bit more
about a language model later.

00:15:15.650 --> 00:15:24.850
But that could be something, for example,
like call a meeting or a phone home.

00:15:24.880 --> 00:15:26.660
That's a simple language model in itself.

00:15:26.660 --> 00:15:30.410
We provide about seventy percent
coverage for speech recognition when

00:15:30.870 --> 00:15:33.700
compared to the Carbon Speech API.

00:15:33.730 --> 00:15:36.980
Again, we're architecture neutral,
as I said before,

00:15:36.980 --> 00:15:40.770
with speech synthesis so that you
can coordinate the recognition

00:15:40.770 --> 00:15:43.440
callbacks with your UI callbacks,
as a convenience.

00:15:43.440 --> 00:15:47.240
And again, we provide Java Beans and
Customized Property Editor for

00:15:47.240 --> 00:15:54.180
tight integration with visual IDEs,
such as JBuilder or MetroWorks.

00:15:54.230 --> 00:15:56.900
The two main classes for
Java Speech Recognition

00:15:57.020 --> 00:15:59.050
are the Recognizer,
and the Recognizer does

00:15:59.050 --> 00:16:00.320
about what you'd expect.

00:16:00.320 --> 00:16:03.780
It allows you to start recognition,
stop recognition,

00:16:03.780 --> 00:16:09.380
set a particular language model, listen,
add your listeners for events, etc.

00:16:09.380 --> 00:16:11.440
The second important class
is the language model.

00:16:11.440 --> 00:16:11.760
There are two different ways to do this.

00:16:11.820 --> 00:16:13.940
There are two different ways to
use the language model class.

00:16:13.940 --> 00:16:16.110
One is just, hey,
here's an array of different

00:16:16.110 --> 00:16:17.600
sentences I want you to listen for.

00:16:17.810 --> 00:16:21.450
Tell me when you get one of them,
and tell me which one you got,

00:16:21.450 --> 00:16:24.200
which one you recognized.

00:16:24.200 --> 00:16:27.580
Another one is more complex,
and it really is something

00:16:27.580 --> 00:16:30.280
that if we have time,
I'm going to demonstrate a bit,

00:16:30.430 --> 00:16:36.030
but it's still really an alpha stage for,
for a couple different reasons that'll

00:16:36.030 --> 00:16:39.980
probably be clear when we give that demo.

00:16:39.980 --> 00:16:41.930
The events that the Recognizer can use,
the Recognizer can

00:16:41.930 --> 00:16:43.140
generate are unrecognized.

00:16:43.170 --> 00:16:45.470
Hey, you know,
somebody said something but

00:16:45.470 --> 00:16:46.740
I don't really know what they said.

00:16:46.740 --> 00:16:48.710
I, it,
it didn't match up with anything in

00:16:48.710 --> 00:16:50.710
my language model that you gave me.

00:16:50.720 --> 00:16:53.720
And you would use that to do
something like ask the user

00:16:53.720 --> 00:16:56.720
to speak that phrase again.

00:16:56.720 --> 00:17:00.480
Another event that you can
listen for is the detected event.

00:17:00.550 --> 00:17:02.830
That just means someone
has started to speak,

00:17:03.110 --> 00:17:06.710
but the, but the Recognizer has not yet
completed recognizing what they said.

00:17:06.710 --> 00:17:09.180
They are not done saying
what they're saying.

00:17:09.180 --> 00:17:10.480
And the,
the other event is the done event.

00:17:10.500 --> 00:17:15.700
This means that the Recognizer
actually recognized what they said,

00:17:15.750 --> 00:17:17.930
and it can tell you
exactly what that was.

00:17:19.590 --> 00:17:24.110
So, Language Model and Editor.

00:17:24.110 --> 00:17:26.500
This is an example of a language model.

00:17:26.500 --> 00:17:31.000
The top model, TopLM,
is the top language model and it

00:17:31.000 --> 00:17:32.500
has two different possibilities.

00:17:32.500 --> 00:17:34.500
Call Person or Schedule Meeting.

00:17:34.500 --> 00:17:36.100
Now, Schedule Meeting is literal.

00:17:36.130 --> 00:17:37.500
Listen for the word Schedule Meeting.

00:17:37.500 --> 00:17:42.600
Call Person actually is a
concatenation of two other models.

00:17:42.600 --> 00:17:47.490
The Call Model, third line down,
and the Person Model.

00:17:47.500 --> 00:17:49.990
And the Call Model can be call, phone,
or dial.

00:17:49.990 --> 00:17:53.430
The Person Model could be literally Arlo,
Brent, Matt, or my wife.

00:17:53.500 --> 00:17:56.050
So, in this language model,
and then also you have in

00:17:56.050 --> 00:17:58.880
the Top Language Model with
Person or View Today Schedule,

00:17:58.880 --> 00:18:00.500
variations of the other two.

00:18:00.660 --> 00:18:05.390
So, in this language model,
you could possibly receive Dial Brent,

00:18:05.500 --> 00:18:07.500
which would be the first part
of the first language model.

00:18:07.500 --> 00:18:10.860
Or Schedule Meeting,
or View Today Schedule,

00:18:11.030 --> 00:18:14.490
or Schedule Meeting with Brent,
for example.

00:18:14.490 --> 00:18:17.500
So,
let's go to the Speech Recognition demo.

00:18:17.500 --> 00:18:18.440
Keep our fingers crossed.

00:18:18.490 --> 00:18:23.560
And this is the
Speech Recognition mic here.

00:18:25.270 --> 00:18:29.990
I'm going to start up Speech Recognizer.

00:18:30.160 --> 00:18:31.800
Now this is a very simple demo.

00:18:31.800 --> 00:18:34.860
It was actually something I used
to control my web browser,

00:18:34.890 --> 00:18:38.540
but right now I just have it
as a simple list that's going

00:18:38.540 --> 00:18:40.240
to pick up what I'm saying.

00:18:40.420 --> 00:18:45.800
So let's wait for it to start.

00:18:46.020 --> 00:18:49.710
Okay,
and if we can cut this mic for a second.

00:19:06.270 --> 00:19:09.850
So in the acoustics of this room,
some of the softer sounds I found were

00:19:09.850 --> 00:19:14.440
hard to pick up between this microphone
and the fans and all the computers

00:19:14.440 --> 00:19:16.200
and the different space in the room.

00:19:16.200 --> 00:19:19.200
But there we see the
speech recognition working.

00:19:19.200 --> 00:19:21.820
And by the way,
we're going to go into sample

00:19:21.820 --> 00:19:25.200
code and actually write some code,
take a look at some other code

00:19:25.200 --> 00:19:27.070
after we're done with these demos.

00:19:27.200 --> 00:19:29.200
Let me quit this here.

00:19:29.200 --> 00:19:32.220
And can we have the main
presentation board back?

00:19:32.220 --> 00:19:33.070
Thank you.

00:19:35.260 --> 00:19:41.400
So the last framework that I want to take
a look at is the Java Spelling Framework.

00:19:42.340 --> 00:19:46.750
The Java Spelling Framework is a set
of Java API that allows you to access

00:19:46.750 --> 00:19:50.430
the underlying Cocoa Spelling Service,
and it's built on the

00:19:50.430 --> 00:19:53.480
Cocoa Spelling Services,
which in turn are built

00:19:53.480 --> 00:19:54.990
on top of Mac OS X.

00:19:55.190 --> 00:20:00.330
It provides three levels of usage,
three styles or levels.

00:20:00.340 --> 00:20:03.640
One is just a simple set of
API you can call to ask it,

00:20:03.780 --> 00:20:05.730
is this particular
word spelled correctly,

00:20:05.730 --> 00:20:10.420
give me a list of suggested corrections,
modify the system dictionary.

00:20:10.420 --> 00:20:13.140
That is, I have a new word,
it should be in the dictionary,

00:20:13.230 --> 00:20:16.190
it's spelled correctly, it just isn't,
add it to the dictionary and that would

00:20:16.190 --> 00:20:19.440
be system-wide so that another Cocoa app
such as TextEdit would then pick up

00:20:19.550 --> 00:20:22.660
that word in its spell checking session.

00:20:22.660 --> 00:20:28.660
Another way to integrate is complete
integration with Swing text components.

00:20:28.660 --> 00:20:32.490
Now, I don't know if you're aware,
but in Swing, all text components derive

00:20:32.570 --> 00:20:33.980
from JTextComponent.

00:20:33.980 --> 00:20:39.580
And JTextComponent has a classic
model view controller paradigm design,

00:20:39.590 --> 00:20:43.340
and that makes it very easy for us to
tie in to all text widgets than in Swing,

00:20:43.340 --> 00:20:49.020
whether it's a one line unstylized text,
a multi-line unstylized text,

00:20:49.020 --> 00:20:52.640
or a fully stylized multi-line text.

00:20:52.640 --> 00:20:57.170
It also has an attraction for integrating
with non-swing text components.

00:20:58.480 --> 00:21:03.680
Now, its main classes are the
spelling checker itself,

00:21:03.680 --> 00:21:08.980
and this just basically has the simple
static API that you would call if you

00:21:08.990 --> 00:21:12.240
wanted to just roll all of this yourself.

00:21:12.240 --> 00:21:14.470
Another important class is
the misspelled word class.

00:21:14.470 --> 00:21:17.240
You'll receive that in callbacks
from the spelling panel,

00:21:17.240 --> 00:21:22.740
which we'll go into later,
that will say what word was misspelled,

00:21:22.740 --> 00:21:26.930
where it was in a group of text,
how long it is, etc., so that you can use

00:21:26.940 --> 00:21:28.240
that to mark up your text,
etc.

00:21:28.400 --> 00:21:31.270
If you're not using the
full-featured second mode of

00:21:31.270 --> 00:21:34.620
operation we described earlier,
which is full integration

00:21:34.620 --> 00:21:36.400
with Java text components.

00:21:36.540 --> 00:21:39.290
The word class,
which is a parent class of misspelled,

00:21:39.290 --> 00:21:41.790
it just indicates a
correctly spelled word.

00:21:42.410 --> 00:21:46.580
So this is a snapshot of the
classic spelling session.

00:21:46.580 --> 00:21:49.300
These are all Swing Aqua widgets.

00:21:49.300 --> 00:21:51.790
And as we can see,
we have our classic spelling

00:21:51.950 --> 00:21:55.320
panel on top of our demo,
and I'll show that in a second.

00:21:55.320 --> 00:21:59.290
And through this panel,
you can receive a bunch

00:21:59.290 --> 00:22:01.120
of different events.

00:22:01.520 --> 00:22:04.310
But let's see how we bring that panel up.

00:22:04.340 --> 00:22:09.280
So, in the case of the second usage,
just go to that session on a

00:22:09.420 --> 00:22:11.040
standard Java text component.

00:22:11.040 --> 00:22:13.660
It takes these two lines of code.

00:22:13.660 --> 00:22:16.820
And your text component
has to be nothing special.

00:22:16.830 --> 00:22:20.200
So you just instantiate the
JTextComponent driver and you ask it to

00:22:20.200 --> 00:22:22.740
check the spelling of the text widget.

00:22:22.830 --> 00:22:27.390
And you can still, if we go back,
you can still edit the underlying

00:22:27.400 --> 00:22:29.740
text component if you wish.

00:22:29.740 --> 00:22:35.690
And you can just close the spelling panel
and manage all of your dictionaries,

00:22:36.020 --> 00:22:36.500
etc.

00:22:36.500 --> 00:22:39.500
This spelling panel that's on
top now will appear as soon as

00:22:39.500 --> 00:22:41.680
you call driver.checkspelling.

00:22:43.230 --> 00:22:49.070
So another manner of checking the
spelling is with the inline popup

00:22:49.070 --> 00:22:50.960
and real time spell checking.

00:22:50.960 --> 00:22:55.020
In real time spell checking,
you will get cues for misspelled words,

00:22:55.030 --> 00:22:57.520
which are red dashed underlines,
just as you would in

00:22:57.520 --> 00:22:58.930
any Cocoa application.

00:22:59.010 --> 00:23:01.880
And by control clicking
on the misspelled words,

00:23:01.920 --> 00:23:05.100
you can get a list of
suggested corrections,

00:23:05.100 --> 00:23:11.950
and you can add and delete things
from the system dictionary.

00:23:13.620 --> 00:23:21.810
The Javaspelling Framework UI API,
which is to do with this window on top,

00:23:21.900 --> 00:23:26.910
allows you to integrate the
spell checking panel with

00:23:26.960 --> 00:23:28.560
some other text component.

00:23:28.730 --> 00:23:33.610
There is, since Swing didn't come along
for a while in Java's life,

00:23:33.750 --> 00:23:35.800
many different text widgets out there.

00:23:35.810 --> 00:23:38.480
And so you can still use,
for the most part,

00:23:38.590 --> 00:23:44.860
the Java Spelling Framework as
is with the spelling panel with

00:23:44.920 --> 00:23:47.800
your own custom text widget as
long as you do a few things.

00:23:48.140 --> 00:23:51.800
Now one is implementing
the JText component.

00:23:51.800 --> 00:23:54.190
JText component driver,
a new implementation of driver.

00:23:54.190 --> 00:23:58.180
JText component driver is the Swing,
default Swing implementation,

00:23:58.350 --> 00:24:01.470
and you would need to,
it implements the interface below driver,

00:24:01.570 --> 00:24:06.580
and you would need to implement your own
implementation of the driver interface.

00:24:06.580 --> 00:24:10.790
And then, once you did so,
you would tie in with the spelling panel,

00:24:10.790 --> 00:24:13.470
the class above,
and you would be able to have

00:24:13.470 --> 00:24:15.800
this spelling panel tied in
with your text component.

00:24:15.800 --> 00:24:19.960
Of course, you would have to handle the
highlighting and the misspelled word.

00:24:19.960 --> 00:24:21.400
You would just get queues.

00:24:21.400 --> 00:24:21.780
And the queues are the
same as the text component.

00:24:21.790 --> 00:24:27.240
The other queues you would get are
events generated by the spelling panel.

00:24:27.240 --> 00:24:28.750
One of the queues would
be an event called ignore.

00:24:28.780 --> 00:24:33.760
The user wants to ignore the
currently suggested misspelled word.

00:24:34.310 --> 00:24:34.780
Find next.

00:24:34.780 --> 00:24:38.780
These just basically all apply to
the buttons in that spelling panel.

00:24:38.780 --> 00:24:39.760
Correct.

00:24:39.760 --> 00:24:41.780
The user wants to
correct the misspelling.

00:24:41.780 --> 00:24:45.340
The correct event would have the
choice of the new correct spelling,

00:24:45.340 --> 00:24:47.400
and it would be your job,
if you were implementing

00:24:47.400 --> 00:24:51.750
this driver yourself,
to replace that text.

00:24:51.760 --> 00:24:57.740
Another event is found,
and it would be your job to

00:24:58.130 --> 00:25:02.240
highlight a misspelled word
when you receive that event.

00:25:02.240 --> 00:25:05.470
So let's take a look at
the spell checking demo.

00:25:13.130 --> 00:25:16.300
and we'll go through three
methods of doing this.

00:25:16.300 --> 00:25:20.400
So the first one is the
standard spell checking session.

00:25:20.500 --> 00:25:25.170
And as you can see,
we have a list of possible suggested

00:25:25.170 --> 00:25:28.290
corrections to the misspelled word.

00:25:28.300 --> 00:25:29.600
And it's picked the top one.

00:25:29.600 --> 00:25:33.360
The top one is always the
most likely to be correct.

00:25:33.360 --> 00:25:35.390
It's not always though,
and we'll see that.

00:25:35.490 --> 00:25:38.340
So in this case, I will choose that word.

00:25:38.470 --> 00:25:41.720
But for the third word,
I really want-- or the fourth word,

00:25:41.720 --> 00:25:44.700
I really want one, not the first.

00:25:44.700 --> 00:25:45.990
And I'll correct that then.

00:25:46.000 --> 00:25:47.700
And this is just your
typical spelling session.

00:25:47.700 --> 00:25:50.100
But the thing to remember
is that this is all Java.

00:25:50.100 --> 00:25:51.970
These are all Java widgets.

00:25:52.020 --> 00:25:57.100
This is all Swing accessing the
underlying Cocoa Spelling Service.

00:25:57.100 --> 00:25:58.190
We'll correct that.

00:25:58.530 --> 00:26:01.300
We'll correct that.

00:26:01.400 --> 00:26:08.490
And since this particular integration is
that first two line call using full swing

00:26:08.550 --> 00:26:12.430
integration with the spelling service,
when we have a word down below

00:26:12.430 --> 00:26:15.880
that needs to be highlighted,
the text panel scrolled for us,

00:26:16.010 --> 00:26:20.700
etc., we'll replace that word
and we'll replace the last word.

00:26:20.700 --> 00:26:25.710
So that is the first manner with
which you can check spelling.

00:26:25.770 --> 00:26:29.770
Now let's get back our
misspellings and start over.

00:26:29.950 --> 00:26:33.720
The second manner is just
to simply check them all.

00:26:33.920 --> 00:26:41.370
So it checks them all and again
puts a red underscore misspelling

00:26:41.420 --> 00:26:44.150
cue under all the misspelled words.

00:26:44.150 --> 00:26:47.890
And we can right click as we saw in the
presentation and select the correct word.

00:26:47.890 --> 00:26:49.840
We'll just select a few here.

00:26:49.900 --> 00:26:51.890
So you can do that as well.

00:26:51.890 --> 00:26:56.900
Let's get back a fresh copy and
go to the real time spell checker.

00:26:56.900 --> 00:27:02.580
And while that's coming up,
all of these calls are being made to

00:27:02.580 --> 00:27:06.920
check the spelling when it eventually
has a word that it wants to find

00:27:06.920 --> 00:27:07.900
out is this spelled correctly.

00:27:07.900 --> 00:27:14.890
It's taken from the world of Java in this
particular process and it's sent via DO.

00:27:14.890 --> 00:27:16.490
Now I don't know if you
know anything about DO,

00:27:16.520 --> 00:27:18.870
but DO is part of,
is a distributed objects

00:27:18.870 --> 00:27:19.900
mechanism in Cocoa.

00:27:19.900 --> 00:27:23.760
So it's packaged up in Cocoa,
sent over the wire to another

00:27:23.760 --> 00:27:25.890
process running on Mac OS X.

00:27:26.900 --> 00:27:28.400
So if you go to the Mac OS X,
the spell server,

00:27:28.550 --> 00:27:31.190
that spell server looks at the word,
finds it in the dictionary or doesn't,

00:27:31.190 --> 00:27:33.890
and sends back a response whether
it's spelled correctly or not.

00:27:33.890 --> 00:27:36.890
So all that happens pretty quickly.

00:27:36.890 --> 00:27:38.840
And to give you an example,
let's turn on the real

00:27:38.840 --> 00:27:39.890
time spell checker.

00:27:39.890 --> 00:27:41.900
And let's just type garbage at first.

00:27:41.900 --> 00:27:44.900
Let's just type blah, blah, blah, blah,
you know, who knows what this is.

00:27:44.900 --> 00:27:49.000
But as you can see, as I type,
it is checking every single

00:27:49.220 --> 00:27:51.870
correction I make to the document.

00:27:51.900 --> 00:27:54.890
And all of that is just
happening extremely rapidly.

00:27:54.930 --> 00:27:59.690
Now let's go back and let's
actually do something.

00:28:02.630 --> 00:28:05.720
Look at our classic sentence again.

00:28:05.720 --> 00:28:08.460
So since the real time
spell checker is still on,

00:28:08.460 --> 00:28:11.760
we can delete,
make our correction manually.

00:28:11.760 --> 00:28:14.600
We know that this for ISS, for example,
should be is.

00:28:14.860 --> 00:28:18.200
But we can also then do as we
did for the check all option,

00:28:18.200 --> 00:28:22.460
which is to ask it to give us a
list of suggested corrections.

00:28:22.570 --> 00:28:25.520
And we can correct it in this manner.

00:28:25.600 --> 00:28:30.520
So that is a demo of Java Spell Checking.

00:28:30.550 --> 00:28:31.590
So where to get the code?

00:28:31.630 --> 00:28:34.600
You'd go to Apple's
Java Developer website.

00:28:34.600 --> 00:28:36.600
Sometime this week,
I'd look by Friday and

00:28:36.730 --> 00:28:37.600
it'll definitely be there.

00:28:37.600 --> 00:28:42.050
But while we're on the subject of code,
let's see how easy it is just to

00:28:42.050 --> 00:28:44.490
roll some of these things our own.

00:28:44.800 --> 00:28:49.580
And let's see a bit about what I was
talking about when I said Java Beans.

00:28:49.600 --> 00:28:53.600
So let's launch JBuilder.

00:28:53.600 --> 00:28:57.600
. And let's close this
nice little app again.

00:29:11.800 --> 00:29:13.800
Let's get this guy up again.

00:29:13.800 --> 00:29:22.610
Since the demigods don't like me,
I think I'll begin to save incrementally.

00:29:29.200 --> 00:29:30.780
Okay.

00:29:30.820 --> 00:29:32.100
Okay, let's save all.

00:29:32.100 --> 00:29:33.520
Let's go back to the visual designer.

00:29:43.500 --> 00:29:47.500
Let's add our Speech Syntheis Bean again.

00:29:47.660 --> 00:29:49.500
Okay.

00:29:49.500 --> 00:29:51.340
And let's set the layout of this.

00:29:51.340 --> 00:29:54.690
This will be the world's
most horrible GUI.

00:29:55.310 --> 00:29:57.580
to Null, meaning XY.

00:29:57.660 --> 00:30:00.510
Let's go back to--

00:30:02.620 --> 00:30:09.600
"Let's add a button to
start Speech Synthesis,

00:30:09.860 --> 00:30:12.380
another one to stop it,

00:30:12.730 --> 00:30:18.740
And let's add a swing scroll panel.

00:30:18.780 --> 00:30:23.700
And inside of that,
let's add a text widget.

00:30:23.700 --> 00:30:26.740
And let's put some default text in it.

00:30:28.800 --> 00:30:34.400
[Transcript missing]

00:30:35.740 --> 00:30:38.940
And save again.

00:30:38.970 --> 00:30:42.520
And let's go and, you know,
we won't even bother

00:30:42.520 --> 00:30:43.700
naming those buttons.

00:30:43.870 --> 00:30:51.700
Let's go and ask the
synthesizer to begin speaking.

00:30:51.700 --> 00:30:52.700
So let's say this.

00:30:52.740 --> 00:30:54.690
I love this feature of JBuilder.

00:30:54.710 --> 00:30:55.700
It's just totally awesome.

00:30:55.700 --> 00:30:56.810
This is Code Insight.

00:30:56.810 --> 00:30:59.690
So especially during these demos,
this is really great.

00:30:59.700 --> 00:31:03.700
J synthesizer should be
down there somewhere.

00:31:03.700 --> 00:31:05.700
Did it name it just synthesizer?

00:31:05.700 --> 00:31:08.550
I think it did.

00:31:08.550 --> 00:31:10.000
Okay.

00:31:10.000 --> 00:31:10.000
Synthesizer1.

00:31:11.640 --> 00:31:19.980
Text and we'll get that text from
this dot j text area one dot git

00:31:23.400 --> 00:31:25.520
I can't get any easier than that.

00:31:25.520 --> 00:31:31.740
Well, I could write it itself,
but then I'd be out of a job.

00:31:31.740 --> 00:31:32.770
OK.

00:31:34.880 --> 00:31:38.780
Don't add that feature, Blake, please.

00:31:38.870 --> 00:31:41.390
So let's go back and add stop.

00:31:47.600 --> 00:31:55.100
[Transcript missing]

00:32:09.890 --> 00:32:09.890
Okay, let's run it.

00:32:09.890 --> 00:32:09.890
Obviously this is about the simplest
form of using the synthesizer,

00:32:09.890 --> 00:32:09.890
but you could also add callbacks to it,
but we'll just take a

00:32:09.890 --> 00:32:09.890
look at those events.

00:32:10.830 --> 00:32:12.040
So we can speak it.

00:32:12.060 --> 00:32:14.020
This is neat.

00:32:14.020 --> 00:32:18.400
Let's add a bunch of stuff
and hope that stop works,

00:32:18.440 --> 00:32:21.790
because otherwise it's going
to repeat this over and over.

00:32:25.400 --> 00:32:33.500
[Transcript missing]

00:32:33.840 --> 00:32:35.790
I actually knew it would work,
but thank you.

00:32:39.310 --> 00:32:42.460
So that is Speech Synthesis.

00:32:42.850 --> 00:32:46.460
So while we're in this demo,

00:32:47.320 --> 00:32:52.460
Let's add one more button
to the beauty of JBuilder.

00:32:52.490 --> 00:32:59.850
And let's add our spell checking button,
our spell checking bean.

00:32:59.900 --> 00:33:04.800
One more time.

00:33:04.800 --> 00:33:07.970
This.jtext.complete.

00:33:27.700 --> 00:33:37.700
"Let's try it again,
I love how fast it compiles.

00:33:37.700 --> 00:33:41.970
And let's type something
more interesting in.

00:33:43.200 --> 00:33:54.600
[Transcript missing]

00:33:56.600 --> 00:33:58.600
That's right.

00:33:58.600 --> 00:34:04.600
Let's bring up the spell checking panel,
that one line of text that we added.

00:34:04.600 --> 00:34:09.140
And let's see if it has
a guest for me here.

00:34:09.380 --> 00:34:10.690
Yes it does.

00:34:10.700 --> 00:34:13.300
Okay, so we'll do that and
correct that spelling.

00:34:13.300 --> 00:34:19.300
It doesn't have one for there,
so I'll just change it myself there.

00:34:19.300 --> 00:34:22.300
It does have one for that.

00:34:22.300 --> 00:34:25.300
For the heck of it,
let's just say ignore that one.

00:34:25.690 --> 00:34:32.420
And let's also say that
for whatever reason,

00:34:32.540 --> 00:34:35.280
we want that word to be
declared as spelled correctly.

00:34:35.300 --> 00:34:38.090
So let's learn it.

00:34:38.560 --> 00:34:40.110
and continue on.

00:34:40.360 --> 00:34:46.160
And then just kill our session here.

00:34:46.160 --> 00:34:51.160
And then we can just
continue on or whatever.

00:34:51.160 --> 00:34:53.110
Now let's open up.

00:34:53.260 --> 00:34:54.960
Let's quit that.

00:34:55.000 --> 00:34:58.970
So there are two examples
of easily incorporating the

00:34:58.970 --> 00:35:04.490
Speech Synthesis and Spell Checking
framework into your application.

00:35:04.490 --> 00:35:08.240
If we look again,
we need to look at the top

00:35:08.240 --> 00:35:11.200
of this application because
JBuilder did some things for us.

00:35:11.430 --> 00:35:15.670
It instantiated the JTEX component
driver when we added it to

00:35:15.670 --> 00:35:17.640
the application visually.

00:35:17.640 --> 00:35:21.700
It also did the same thing for
the synthesizer class as well.

00:35:23.200 --> 00:35:27.520
And then when we look
down at our code below,

00:35:27.520 --> 00:35:34.200
it just took one line of code to ask
the synthesizer to speak the text,

00:35:34.200 --> 00:35:36.680
another line of code
to ask it to stop it,

00:35:36.680 --> 00:35:40.130
one line of code to ask
it to check the spelling.

00:35:40.200 --> 00:35:43.870
And for checking the spelling,
they're also checking real

00:35:43.870 --> 00:35:46.700
time and check all API as well.

00:35:46.700 --> 00:35:52.370
So any way you slice it,
you have a couple lines of code that only

00:35:52.370 --> 00:35:53.100
would work if you had a specific code.

00:35:53.100 --> 00:35:53.100
So any way you slice it,
you have a couple lines of code

00:35:53.100 --> 00:35:54.530
that only would work if you
had would work on Mac OS X,

00:35:54.530 --> 00:35:56.550
but then again,
since there are only a couple of

00:35:56.550 --> 00:35:59.330
lines of code and because of the
types of frameworks they are,

00:35:59.400 --> 00:36:01.900
for example spell checking,
you might want to consider

00:36:01.900 --> 00:36:04.610
integrating them into your
application--your Java applications

00:36:04.610 --> 00:36:06.600
that you want to run on all platforms.

00:36:06.600 --> 00:36:09.370
The way--there are several
ways you could do this,

00:36:09.500 --> 00:36:11.890
but the benefit is that
it would basically run the

00:36:11.890 --> 00:36:13.200
same on all the platforms.

00:36:13.200 --> 00:36:16.800
It's just that when you got to
Mac OS X and your users ran it there,

00:36:16.910 --> 00:36:19.610
they'd also have, for example,
spell checking.

00:36:19.610 --> 00:36:21.920
So you might use,
since it's only a couple lines

00:36:21.920 --> 00:36:24.910
of code for spell checking
reflection to call this,

00:36:24.910 --> 00:36:28.300
you might also wrap it in another API,
build it on Mac OS X or build it

00:36:28.300 --> 00:36:32.640
on a platform that has these same
APIs stubbed out so you could compile

00:36:32.640 --> 00:36:38.000
and then run it on all of your systems
and simply when it ran on Mac OS X,

00:36:38.000 --> 00:36:43.640
it would have the spell checking
capabilities built into it.

00:36:43.640 --> 00:36:47.240
And same for basic speech synthesis,
although, you know,

00:36:47.520 --> 00:36:49.820
that may be more involved in your
application when you do that.

00:36:49.820 --> 00:36:49.820
So you might use--since it's
only a couple lines of code

00:36:49.820 --> 00:36:49.820
for spell checking reflection,
you might also wrap it in another API,

00:36:49.820 --> 00:36:49.820
build it on Mac OS X or build it
on a platform that has these same

00:36:49.820 --> 00:36:49.820
APIs stubbed out so you could compile
and then run it on all of your systems,

00:36:49.820 --> 00:36:52.730
and that's where you might
use speech synthesis.

00:36:52.790 --> 00:36:56.180
So those are the first two
easy frameworks to demo.

00:36:56.180 --> 00:37:00.780
Now the bleeding edge guy
is speech recognition.

00:37:00.780 --> 00:37:06.010
So let's actually go and open up
a new file--open up a file that

00:37:06.010 --> 00:37:11.880
was put on our system when we
installed the speech framework.

00:37:13.070 --> 00:37:14.300
Okay, let's see here.

00:37:14.300 --> 00:37:17.430
Do, do, do, do, where am I piloting here?

00:37:17.440 --> 00:37:20.240
Close that.

00:37:20.240 --> 00:37:22.140
Okay.

00:37:22.140 --> 00:37:24.000
Developer.

00:37:25.200 --> 00:37:34.200
[Transcript missing]

00:37:34.400 --> 00:37:39.400
Okay, let's look at example one.

00:37:39.400 --> 00:37:45.690
This is the sample code to the
speech recognition sample we saw.

00:37:45.690 --> 00:37:51.990
And for the most part, what it's doing is
instantiating the recognizer.

00:37:52.100 --> 00:38:57.900
[Transcript missing]

00:38:58.990 --> 00:39:02.560
The feedback frame,
what recognizer it should attach to,

00:39:02.560 --> 00:39:05.320
and it's gone and attached
to all the listeners,

00:39:05.340 --> 00:39:08.280
especially the done event listener,
so that it can highlight

00:39:08.280 --> 00:39:14.570
the correctly spelled,
or correctly spoken phrase.

00:39:14.570 --> 00:39:14.570
Now,

00:39:14.770 --> 00:39:19.260
The other thing that I wanted to
show you that is the real bleeding

00:39:19.260 --> 00:39:21.800
edge stuff-- let me close this file.

00:39:35.100 --> 00:39:39.480
Let's go back to the designer.

00:39:39.480 --> 00:39:47.000
And let's go and just add a recognition
bean to this little sample application.

00:39:47.290 --> 00:39:55.510
and take a look at the rough early
version of the language model customizer.

00:39:56.980 --> 00:40:01.180
So the thing that actually makes
this rough is that drag and drop,

00:40:01.720 --> 00:40:04.760
probably if you're
familiar with Java at all,

00:40:04.760 --> 00:40:08.580
you know,
is still in a rough state of affairs.

00:40:08.580 --> 00:40:10.650
Not only do we have
some bugs on our side,

00:40:10.650 --> 00:40:13.340
but there are just some bugs in
the shared code that all of the

00:40:13.340 --> 00:40:20.320
VM implementers share with Sun,
and I basically discovered those

00:40:20.320 --> 00:40:24.680
specific bugs while doing this editor,
and we need to get those

00:40:24.680 --> 00:40:28.010
changes fed back to Sun,
get them into the pipeline so

00:40:28.010 --> 00:40:30.390
everyone can benefit from them.

00:40:30.550 --> 00:40:36.140
But I will try to work,
struggle my way through this to give

00:40:36.140 --> 00:40:39.120
you a bit of an example of how it works.

00:40:39.210 --> 00:40:41.260
So I'm going to try to
recreate that first language

00:40:41.260 --> 00:40:44.540
model we had on the slides,
where we had a call person, for example,

00:40:44.540 --> 00:40:47.440
schedule a meeting with a person.

00:40:47.440 --> 00:40:51.880
So let's say for, first of all,
that we just wanted to say,

00:40:51.900 --> 00:40:55.510
"schedule meeting with
person." So we could say,

00:40:55.510 --> 00:40:59.420
we could add a new
language model down here.

00:41:01.150 --> 00:41:03.660
Oops, I need to add a new one first.

00:41:03.740 --> 00:41:06.120
Called Person.

00:41:06.190 --> 00:41:10.180
And we could say this is, let's see.

00:41:10.770 --> 00:41:15.810
We could say that this is Dan.

00:41:16.700 --> 00:41:25.590
Mickey and some of mine not in
the room and and then we could say

00:41:26.100 --> 00:41:27.340
We could drag this person.

00:41:27.340 --> 00:41:29.000
Now this is part of this feedback window.

00:41:29.000 --> 00:41:32.140
It's one of the bugs of...

00:41:33.130 --> 00:41:34.240
: Thank you, Steve.

00:41:34.320 --> 00:41:36.910
I'm going to go ahead and show
you a little bit of the code

00:41:37.260 --> 00:41:38.920
that I was referencing before.

00:41:38.920 --> 00:41:38.920
So we could type up here, "call person."

00:41:40.340 --> 00:41:45.300
And then I should be able to say,
call Dan or call Nikki.

00:41:45.300 --> 00:41:50.600
Now, the actual--we had a bit of a
difficulty with setting up the mic,

00:41:50.750 --> 00:41:54.390
so the development environment
for this sample is on this

00:41:54.400 --> 00:41:58.350
machine I'm sitting on here,
and the mic actually is

00:41:58.350 --> 00:42:04.270
attached to the other machine,
so I can't actually

00:42:04.270 --> 00:42:05.030
show you this working,
but trust me, it works.

00:42:05.230 --> 00:42:10.650
: I'm dragging it up,
it's only a problem.

00:42:10.650 --> 00:42:18.450
But you can go into a test mode
and build your language model.

00:42:18.450 --> 00:42:21.030
You could speak it, et cetera,
go back to edit mode

00:42:21.030 --> 00:42:21.030
to edit other things.

00:42:21.030 --> 00:42:21.030
Once you're done,
you can save it as a file somewhere.

00:42:21.630 --> 00:42:25.470
And it'll bring up the
OS X save dialog box,

00:42:25.580 --> 00:42:29.160
just save it somewhere, and say, okay,
you're done.

00:42:29.400 --> 00:42:32.460
And then if we go back
and we look at the source,

00:42:32.630 --> 00:42:37.230
JBuilder,
because JBuilder adheres to even the

00:42:37.230 --> 00:42:44.750
nitty-gritty of the Bean specification,
it's gone and used the

00:42:44.890 --> 00:42:48.790
Java Speech Recognition--Recognizer
Bean language model,

00:42:48.800 --> 00:42:54.420
BeanInfo and Bean, to allow us,
our framework, to add source code to the

00:42:54.550 --> 00:42:55.290
file that you're editing.

00:42:55.300 --> 00:42:56.800
That's pretty neat.

00:42:56.800 --> 00:42:59.950
In this case,
the source code we added was-- and

00:42:59.950 --> 00:43:05.850
allow me to just add this to two
lines so you can see it better.

00:43:06.130 --> 00:43:10.150
The source code that we
added was new language model,

00:43:10.150 --> 00:43:15.300
set data file for the particular file
that now contains our language model.

00:43:15.380 --> 00:43:19.350
And then we could listen
for those same phrases,

00:43:19.460 --> 00:43:24.490
call Dan, call Nikki,
out of that complex language model.

00:43:24.500 --> 00:43:27.990
Now more will be added to that so
that you can have easier ways to

00:43:27.990 --> 00:43:32.130
recognize a more complex model,
but that's the state of the situation

00:43:32.720 --> 00:43:35.490
with speech recognition at the moment.

00:43:35.500 --> 00:43:39.480
So speech recognition is provided as
one of those frameworks made freely

00:43:39.520 --> 00:43:42.000
available on our website as of this week.

00:43:42.000 --> 00:43:50.090
The way that I would recommend you
use it for the time being is with

00:43:51.030 --> 00:43:54.060
The simple language
model that we saw below,

00:43:54.060 --> 00:43:57.210
which is just setting a
simple set of phrases,

00:43:57.210 --> 00:44:01.000
listening for the recognition event,
the done event,

00:44:01.130 --> 00:44:07.000
and then getting the sentence out of that
event to see what the user has spoken.

00:44:07.000 --> 00:44:13.980
So that's a bit of code in taking a look
at how easy it is to use the frameworks.

00:44:14.020 --> 00:44:17.840
Of course, there's a lot more in the
frameworks than we've shown today.

00:44:18.240 --> 00:44:21.810
There are all sorts of interesting
things and callbacks and synthesis

00:44:21.810 --> 00:44:24.000
and recognition that you can get at.

00:44:24.000 --> 00:44:26.950
We've actually covered most of
the spelling framework as is.

00:44:27.020 --> 00:44:30.720
So again, you can get the code from
the developer website.

00:44:30.990 --> 00:44:33.980
And send me email if
you have any questions.
WEBVTT

00:00:03.190 --> 00:00:04.360
My name is Tim Chernia.

00:00:04.550 --> 00:00:08.920
I'm manager of the
QuickTime Pro Video team at Apple.

00:00:09.010 --> 00:00:11.480
So we're going to talk about Pro Video.

00:00:11.610 --> 00:00:13.980
So why Pro Video?

00:00:14.390 --> 00:00:17.490
Well,
it's good to have a team for Pro Video.

00:00:17.710 --> 00:00:21.170
QuickTime has a lot of customers
as you've probably seen either by

00:00:21.170 --> 00:00:23.990
seeing Tim's session this morning
or seeing the interactivity

00:00:24.080 --> 00:00:28.650
session that was just before mine,
or seeing the broadcasting

00:00:28.650 --> 00:00:29.670
session that follows.

00:00:29.870 --> 00:00:34.890
So QuickTime has a lot of customers,
but it's also the foundation of a lot

00:00:35.100 --> 00:00:39.440
of core high-end video technology,
shipping and apps from both

00:00:39.490 --> 00:00:43.560
Apple and other companies
such as Adobe and Media 100.

00:00:43.560 --> 00:00:46.120
So it has unique demands in that space.

00:00:46.960 --> 00:00:50.190
The demands tend to be it
must have high quality,

00:00:50.200 --> 00:00:52.810
it must have high performance,
it has to work well with

00:00:53.010 --> 00:00:54.700
the hardware that you get.

00:00:54.740 --> 00:00:59.440
We have hardware now from companies like
Matrox and Pinnacle and Digital Voodoo

00:00:59.440 --> 00:01:03.420
and Aurora which work using
QuickTime in the apps we talked about.

00:01:03.460 --> 00:01:06.560
And you have to have consistent
results because you're going to

00:01:06.660 --> 00:01:09.600
take this material and maybe go
on air or make it in a movie.

00:01:09.720 --> 00:01:11.000
So it's very, very important.

00:01:11.120 --> 00:01:13.930
So that's why we're
specializing in pro video,

00:01:13.980 --> 00:01:16.180
that's why we have a pro video team.

00:01:16.320 --> 00:01:18.320
So what about you guys?

00:01:18.340 --> 00:01:23.190
This session is targeted towards
developers who are writing video editing

00:01:23.190 --> 00:01:25.710
or video processing applications.

00:01:25.880 --> 00:01:30.180
It can be from the high end,
it can be from just simple ones

00:01:30.220 --> 00:01:35.350
which can make the experience of
using things like iMovie easier.

00:01:35.380 --> 00:01:39.200
It's also targeted towards codec
writers who are writing either

00:01:39.350 --> 00:01:42.650
software codecs or hardware codecs.

00:01:43.790 --> 00:01:48.300
and this will basically give
you some extra information.

00:01:48.390 --> 00:01:50.780
So the things we're going
to talk about today.

00:01:50.820 --> 00:01:54.080
We're going to talk about some
improvements we've done in QuickTime 5,

00:01:54.120 --> 00:01:57.120
which makes your rendering
experience better.

00:01:57.170 --> 00:02:01.220
We're going to talk about improvements
for supporting hardware cards,

00:02:01.240 --> 00:02:04.550
such as the ones I talked about,
and ways that you can take

00:02:04.600 --> 00:02:08.160
advantage of asynchronous
operations and multiprocessing on

00:02:08.160 --> 00:02:11.460
our high-end Macintosh systems.

00:02:11.500 --> 00:02:17.040
And some future things we're going
to do with our effects architecture.

00:02:17.060 --> 00:02:19.660
And finally,
some help in migrating your video

00:02:19.660 --> 00:02:23.690
hardware towards OS X as a platform.

00:02:24.260 --> 00:02:27.370
So, I'm going to talk about rendering.

00:02:27.370 --> 00:02:29.600
And when I talk about rendering,
I'm really talking about taking

00:02:29.660 --> 00:02:33.440
some compressed material,
decompressing it,

00:02:33.560 --> 00:02:35.890
and typically then you'd apply
some sort of effect to it,

00:02:35.900 --> 00:02:38.450
a video effect, let's say a blur,
and then recompress it back

00:02:38.520 --> 00:02:40.100
to the original material.

00:02:40.100 --> 00:02:43.160
That's a typical workflow
experience or experience inside

00:02:43.290 --> 00:02:45.390
a video editing app where you,
let's say,

00:02:45.390 --> 00:02:48.970
wanted to do a cross-resolve between two
streams of DV and you would render it.

00:02:49.090 --> 00:02:52.190
So you decompress the two streams of DV,
you combine them,

00:02:52.310 --> 00:02:56.780
you recompress it back to DV,
and then you can send it out FireWire.

00:02:57.370 --> 00:03:01.500
So the improvements we've
done in that space are we've

00:03:01.540 --> 00:03:03.960
improved some gamma processing.

00:03:03.960 --> 00:03:07.080
We've also added a new
pixel format called R408.

00:03:07.080 --> 00:03:09.690
And of course we've
improved the DV codec,

00:03:09.770 --> 00:03:13.360
which is something that Tim talked about,
and I'll show you some of

00:03:13.360 --> 00:03:14.920
the results we got there.

00:03:15.380 --> 00:03:19.280
So my favorite first topic is gamma.

00:03:19.290 --> 00:03:23.640
And I'm going to talk about
gamma sort of a little overview.

00:03:23.680 --> 00:03:25.610
But basically, gamma,
when I'm talking about it,

00:03:25.620 --> 00:03:31.220
I'm talking about the non-linearity
of intensity reproduction,

00:03:31.740 --> 00:03:35.560
which is basically that you have an input
value and you have an output intensity.

00:03:35.560 --> 00:03:38.960
And there's a relationship between the
input value and the output intensity.

00:03:38.960 --> 00:03:42.640
And it's not always linear
like the diagram at the right.

00:03:42.640 --> 00:03:43.450
It has a curve.

00:03:43.460 --> 00:03:45.400
It has a power curve.

00:03:45.400 --> 00:03:50.510
And this relationship could
apply to either the camera,

00:03:50.520 --> 00:03:53.470
a video camera,
or it could apply to just a

00:03:53.470 --> 00:03:57.080
CRT monitor or maybe a LCD monitor.

00:03:57.080 --> 00:03:59.260
It can also apply to
the system as a whole,

00:03:59.530 --> 00:04:05.240
for example,
the Macintosh or your television.

00:04:06.680 --> 00:04:11.320
So, the issue is that there's
different gamma for the different

00:04:11.360 --> 00:04:13.340
systems that QuickTime deals with.

00:04:13.340 --> 00:04:17.700
We have video, which has a gamma which
is established at 2.2,

00:04:17.700 --> 00:04:20.550
and the Macintosh,
the gamma is established at 1.8,

00:04:20.850 --> 00:04:24.810
and Windows is basically using
the native values of the CRT,

00:04:24.810 --> 00:04:26.440
which is 2.5.

00:04:26.670 --> 00:04:33.450
So, why is that a problem for video
rendering is that because QuickTime knows

00:04:33.530 --> 00:04:38.400
that videos such as DV is at 2.2,
and it wants to make it look correct

00:04:38.400 --> 00:04:41.800
when we display it on the Macintosh
for applications such as iMovie when

00:04:41.800 --> 00:04:45.960
you're doing the preview on the desktop,
we do a gamma correction stage to bring

00:04:45.980 --> 00:04:50.450
the image to look closer to what it
would look like if you had a NTSC monitor

00:04:50.570 --> 00:04:52.860
next to your Macintosh monitor.

00:04:52.860 --> 00:04:56.270
And so that works really, really well,
except it makes it a little bit

00:04:56.280 --> 00:04:56.430
more difficult to see what the
image is going to look like.

00:04:56.490 --> 00:04:58.440
So, we've come up with some
problems for video rendering.

00:04:58.440 --> 00:05:01.660
I'm going to show you the gamma
correction that I was talking

00:05:01.660 --> 00:05:03.440
about afterwards in my demo.

00:05:03.440 --> 00:05:07.950
So, the solution that we've come up with
is that we allow applications now

00:05:07.950 --> 00:05:10.410
to specify the gamma that they want.

00:05:10.460 --> 00:05:13.360
They can say, "I want you to give me what
the source gamma was," or,

00:05:13.450 --> 00:05:17.660
"I want you to make it gamma 2.0," or,
"I want you to make it gamma 2.2." So,

00:05:17.710 --> 00:05:22.440
not only can you specify what the gamma
would be via some gamma APIs we've done,

00:05:22.440 --> 00:05:24.440
you can also find out what
the gamma actually was,

00:05:24.440 --> 00:05:26.420
which is really useful.

00:05:26.420 --> 00:05:28.410
So, let's see how that works.

00:05:28.420 --> 00:05:31.860
And Codex can specify the
gamma that they prefer.

00:05:31.880 --> 00:05:35.140
They can say,
"My private or custom pixel format

00:05:35.140 --> 00:05:40.380
compression format has a gamma of,
let's say, 2.2," and, therefore,

00:05:40.470 --> 00:05:43.260
when you decompress it,
if you ask for the source gamma,

00:05:43.260 --> 00:05:44.340
it'll be 2.2.

00:05:44.530 --> 00:05:46.010
So, there's no more guessing.

00:05:46.010 --> 00:05:48.810
You can basically choose the
gamma that you want to process

00:05:48.810 --> 00:05:51.490
your video rendering in,
and you get what you want.

00:05:52.830 --> 00:05:56.460
So, pixel formats.

00:05:56.890 --> 00:05:59.580
Key thing about rendering is you
go from a compressed pixel format

00:05:59.670 --> 00:06:02.340
to some sort of a pixel format
you're going to do the rendering in.

00:06:02.380 --> 00:06:08.820
And the typical choices out
there would be RGB or YUV.

00:06:08.890 --> 00:06:11.980
RGB has its advantage in that
it's native for graphics.

00:06:12.050 --> 00:06:16.780
A lot of people have
used it for many years.

00:06:16.810 --> 00:06:20.660
It also has an optional alpha
channel So you can use it to

00:06:20.660 --> 00:06:22.900
do compositing fairly easily.

00:06:23.080 --> 00:06:26.650
YUV has the advantage that
it's native for video,

00:06:26.650 --> 00:06:29.140
and typically it's
stored in a 4:2:2 format,

00:06:29.250 --> 00:06:35.140
which means that there's two samples
of Luma for every chroma pair.

00:06:35.140 --> 00:06:38.870
The U and V refer to the chroma
and the Y refers to Luma.

00:06:39.100 --> 00:06:42.670
So it's sub-sampled,
which means it's good for storing.

00:06:42.700 --> 00:06:45.360
It kind of represents
what your eye can see.

00:06:45.620 --> 00:06:46.870
In other words,
your eye is more sensitive

00:06:46.950 --> 00:06:50.390
to luma compared to chroma.

00:06:50.870 --> 00:06:54.460
But it's basically, well,
it's hard for rendering,

00:06:54.460 --> 00:06:56.060
which is kind of my next slide.

00:06:56.060 --> 00:06:57.200
And of course, there's no alpha channel.

00:06:57.210 --> 00:07:01.600
So the problems with RGB and YUV,
RGB has the extra color space

00:07:01.740 --> 00:07:06.170
conversion to go back and forth
from YUV since the data would

00:07:06.370 --> 00:07:09.990
typically be native YUV for video.

00:07:10.500 --> 00:07:15.260
It also can clamp the video
because the color space is

00:07:15.300 --> 00:07:17.820
smaller than the YUV space.

00:07:18.980 --> 00:07:21.130
So with YUV, the problem is that
there's no alpha channel,

00:07:21.140 --> 00:07:25.520
so if you wanted to do compositing,
you're kind of out of luck.

00:07:25.520 --> 00:07:27.400
It's not really friendly for that.

00:07:27.480 --> 00:07:30.300
And it's also hard to process
because it's sub-sampled,

00:07:30.300 --> 00:07:33.800
so if you just wanted to move
your YUV image by one pixel,

00:07:33.890 --> 00:07:35.670
all of a sudden you have this
problem because you have to

00:07:35.670 --> 00:07:38.700
move the chroma and luma around,
or the chroma around,

00:07:38.700 --> 00:07:40.340
because it was sub-sampled.

00:07:40.410 --> 00:07:44.280
And also, the standard black value
for YUV video is 16,

00:07:44.280 --> 00:07:48.060
so every time you do an operation on YUV,
you're busy adding and

00:07:48.060 --> 00:07:51.390
subtracting 16 on it,
so we didn't quite like that.

00:07:51.530 --> 00:07:57.030
So QuickTime came up with R408,
and R408 is really nice.

00:07:57.060 --> 00:08:00.190
It's video-friendly,
which means it's YUV-based.

00:08:00.300 --> 00:08:02.930
It's not sub-sampled.

00:08:03.000 --> 00:09:38.100
[Transcript missing]

00:09:38.530 --> 00:09:41.500
So now I get to show you a little
demo of this stuff working.

00:09:41.500 --> 00:09:44.190
Let me switch to demo four, please.

00:09:45.920 --> 00:09:47.260
All right.

00:09:47.380 --> 00:09:51.030
So what I'm going to show
is a little application

00:09:52.920 --> 00:09:58.790
And what I'm doing in this application
is I'm taking a DV clip and I'm

00:09:58.850 --> 00:10:02.030
decompressing it to an off-screen
in a pixel format that I can choose.

00:10:02.100 --> 00:10:06.900
And I'm taking the resulting decompressed
image and recompressing it back to DV.

00:10:06.900 --> 00:10:11.940
And I take that DV frame and
I re-decompress it and keep doing that.

00:10:11.990 --> 00:10:14.100
In my tests I do it 60 times.

00:10:14.240 --> 00:10:18.720
So I basically can see the results
of a multi-generational render.

00:10:18.720 --> 00:10:24.300
So I can see the losses that we
had or have with the DV codec.

00:10:25.440 --> 00:10:29.400
So let me just open up a file.

00:10:29.400 --> 00:10:29.400
This is...

00:10:29.690 --> 00:10:33.900
Andrew, this is Kevin Mark's son,
and he's holding a

00:10:33.900 --> 00:10:36.900
ball which he's moving,
so you can see over here

00:10:36.900 --> 00:10:40.070
there's a lot of motion,
and that basically has interesting

00:10:40.070 --> 00:10:44.260
effects on the DV compression and
decompression that we were testing,

00:10:44.260 --> 00:10:47.300
and you can see that there's
a lot of detail in his hair,

00:10:47.320 --> 00:10:49.480
and so he's our test clip for today.

00:10:49.960 --> 00:10:54.130
And the first thing I wanted to
show is why we're using gamma,

00:10:54.390 --> 00:10:56.720
why we gamma correct DV.

00:10:56.720 --> 00:11:01.000
So this is a source clip, it's DV,
and right now we're gamma

00:11:01.060 --> 00:11:03.780
correcting it so that it looks
good on a Macintosh monitor,

00:11:03.780 --> 00:11:06.060
and I can turn that off,
and now it's off and it

00:11:06.060 --> 00:11:07.380
looks a lot brighter.

00:11:07.380 --> 00:11:11.020
And now what I'm doing is I'm
actually using the gamma APIs to

00:11:11.100 --> 00:11:14.710
specify what I want the gamma
of the display to look like.

00:11:14.790 --> 00:11:19.600
The gamma of actually not the display,
but of the PIX map, the port PIX map.

00:11:19.960 --> 00:11:23.200
So I can switch it back to video gamma,
and it's not gamma correcting,

00:11:23.270 --> 00:11:24.840
so it looks brighter, too bright.

00:11:25.230 --> 00:11:29.180
I can set it back to default gamma,
it looks dark.

00:11:29.490 --> 00:11:32.300
Natively,
it's going to use the default gamma,

00:11:32.320 --> 00:11:36.820
and we're going to show how you can use
the gamma APIs to fix up your rendering.

00:11:37.400 --> 00:11:40.680
So the first test I'm going to do
is I'm going to do a test where

00:11:40.680 --> 00:11:43.500
I render the clip through 2VUI.

00:11:43.560 --> 00:11:46.670
And when I did that,
you'll see the resulting clip

00:11:46.920 --> 00:11:50.900
degrades every step quite a lot
because I didn't actually set that

00:11:50.900 --> 00:11:53.300
I wanted to use 2.2 as my gamma.

00:11:53.400 --> 00:11:56.220
It's converting every
step on the decompression,

00:11:56.280 --> 00:12:00.920
but it's not properly
converting on the compression.

00:12:01.090 --> 00:12:05.450
So now I can do the same test on 2VUI.

00:12:06.920 --> 00:12:09.680
And now you'll see that it
looks basically perfectly.

00:12:09.680 --> 00:12:11.040
I can play this and it looks perfectly.

00:12:11.040 --> 00:12:13.300
I can scrub through it.

00:12:13.410 --> 00:12:15.960
And you see that I've
used the gamma API to say,

00:12:15.970 --> 00:12:20.510
please decompress this at 2.2
so that when I recompress it,

00:12:20.560 --> 00:12:21.270
there's no gamma shift.

00:12:21.500 --> 00:12:26.250
So I've avoided any gamma processing
at all in that rendering cycle.

00:12:27.070 --> 00:12:31.530
I want to talk a little bit about the
pixel format that I've chosen to use.

00:12:31.600 --> 00:12:36.700
So you're going to see two impacts
of me choosing R408 over RGB.

00:12:36.700 --> 00:12:39.780
And the first impact is performance
and the second one is quality.

00:12:39.800 --> 00:12:44.190
So I have two seconds of
video that I've just rendered,

00:12:44.190 --> 00:12:46.400
basically done this
multigenerational test to.

00:12:46.400 --> 00:12:48.580
One frame and I've done 60 frames.

00:12:48.600 --> 00:12:52.820
And so my two seconds of video
took 2.4 seconds to process

00:12:52.890 --> 00:12:55.540
on this machine through RGB.

00:12:55.600 --> 00:12:59.600
And so that's just a
little under real time.

00:12:59.600 --> 00:13:03.190
And you can see that if I go to the last
frame you can see some artifacts appear

00:13:03.690 --> 00:13:05.960
because of the losses going through RGB.

00:13:06.600 --> 00:13:09.750
And so that's not good.

00:13:10.580 --> 00:13:14.110
So we did the same test
going through R408,

00:13:14.140 --> 00:13:15.480
which is the YUV format.

00:13:15.480 --> 00:13:17.600
And the first thing that
is pretty impressive is it

00:13:17.600 --> 00:13:19.370
takes 1.4 milliseconds to do.

00:13:19.550 --> 00:13:24.390
So that's faster than real-time to do
the decompression and recompression.

00:13:24.390 --> 00:13:29.560
And the other thing that's really
notable about it is the quality.

00:13:29.700 --> 00:13:31.640
So I can't see that image change.

00:13:31.830 --> 00:13:33.820
In fact, it really doesn't.

00:13:34.530 --> 00:13:44.830
Transcript for this session:
"How to Use QuickTime for

00:13:44.830 --> 00:13:44.830
Video" by Tim Cherna

00:13:44.950 --> 00:13:48.040
That's all,
the stuff was all shown on QuickTime 5.

00:13:48.100 --> 00:13:50.540
So with QuickTime 4.1.2,
the first thing I can read,

00:13:50.540 --> 00:13:53.980
I guess you can't read,
but it took 5.8 seconds to do

00:13:53.980 --> 00:13:58.400
the same test versus 1.3 seconds
to do the test on QuickTime 5.

00:13:58.560 --> 00:14:02.020
So you can see the
improvements in performance.

00:14:02.040 --> 00:14:04.840
The other thing is, as we play it,
you can see that there's a fair

00:14:04.840 --> 00:14:12.350
lot of artifacts that we had in,
anyway, QuickTime 5 is much, much better.

00:14:13.570 --> 00:14:17.500
So, let me just quit these things
so that the next demos are good.

00:14:17.500 --> 00:14:23.650
And that's pretty much all
I'm going to talk about.

00:14:23.760 --> 00:14:25.590
Can we go back to the slides please?

00:14:26.500 --> 00:14:29.350
So now I'm going to ask Jean-Michel
Berthoud to come up and talk about

00:14:29.770 --> 00:14:32.280
some improvements in hardware support.

00:14:38.910 --> 00:14:43.940
Hi, my name is Jean-Michel Berthoud and
I work in the QuickTime Pro Video Group.

00:14:43.970 --> 00:14:46.990
And I'm going to talk about a
couple of features that we have

00:14:47.080 --> 00:14:52.880
added in QuickTime 5.0 in order
to improve hardware support.

00:14:52.990 --> 00:15:02.190
So the first thing that needs
to work is the remote control.

00:15:03.710 --> 00:15:05.810
Okay, that's called hardware improvement,
right?

00:15:05.870 --> 00:15:08.880
Okay,
so the first thing that QuickTime for

00:15:08.880 --> 00:15:14.700
use to do is to assume that all
codec can decompress right away.

00:15:14.700 --> 00:15:17.340
And for software implementation,
it's pretty easy to

00:15:17.450 --> 00:15:20.700
understand that you can start
decompressing whenever you want.

00:15:20.700 --> 00:15:23.880
When you have to deal
with a piece of hardware,

00:15:23.880 --> 00:15:25.900
it's much more difficult.

00:15:26.330 --> 00:15:28.890
Usually, I mean,
third-party developers have been able to

00:15:28.890 --> 00:15:32.530
manage to deal with this issue because

00:15:32.670 --> 00:15:35.070
I mean,
the time it was taking to set up their

00:15:35.220 --> 00:15:38.610
first decompression was not that much,
actually.

00:15:38.850 --> 00:15:41.460
But during the development
of QuickTime 5.0,

00:15:41.460 --> 00:15:45.760
we ran into some third party which
were trying to bring up their

00:15:45.760 --> 00:15:47.940
hardware and support QuickTime.

00:15:47.940 --> 00:15:52.340
And this time to decompress
the first frame was quite huge.

00:15:52.340 --> 00:15:56.350
And what was happening is that
QuickTime was getting upset because

00:15:56.410 --> 00:16:00.290
it was totally unable to understand
that the first frame was going to

00:16:00.290 --> 00:16:04.660
take a while to show up on screen,
but the next one after that will be fine.

00:16:04.660 --> 00:16:07.950
That's a concept that we
didn't have before 5.0.

00:16:08.700 --> 00:16:11.590
I'm trying again.

00:16:13.050 --> 00:16:14.570
Okay, that didn't work.

00:16:14.820 --> 00:16:20.000
So the solution was to make
QuickTime aware of this latency.

00:16:20.000 --> 00:16:25.460
And the way you are reporting this
latency is by using a new API that

00:16:25.700 --> 00:16:29.160
we have put on the Codec side,
which is called ImageCodec

00:16:29.160 --> 00:16:30.670
Get Decompress Latency.

00:16:30.720 --> 00:16:36.360
So basically your Codec does report
its internal pipeline duration

00:16:36.360 --> 00:16:40.800
and make QuickTime aware that it's
going to take you a long time to

00:16:40.890 --> 00:16:42.530
start decompressing the first frame.

00:16:42.570 --> 00:16:45.690
The next one,
which are coming after that,

00:16:45.690 --> 00:16:46.590
will be fine.

00:16:47.040 --> 00:16:53.220
So as soon as QuickTime, I mean,
use a codec which reports latency,

00:16:53.220 --> 00:16:56.800
what internally we're going to do,
we're going to start

00:16:56.920 --> 00:17:00.710
your video track earlier,
and the movie will start when your

00:17:00.710 --> 00:17:04.850
hardware pipeline is totally full,
so you have a chance to decompress

00:17:04.850 --> 00:17:07.120
the first frame at the right time.

00:17:07.600 --> 00:17:11.740
So that's what the new latency
support in QuickTime 5.0.

00:17:11.740 --> 00:17:18.740
And we also extended this
latency mechanism to audio track.

00:17:18.810 --> 00:17:22.510
So the concept is identical,
and the way QuickTime is

00:17:22.510 --> 00:17:26.760
talking to audio devices through
the sound output component.

00:17:26.920 --> 00:17:32.330
So we've added a new selector
called SI output latency.

00:17:32.740 --> 00:17:37.820
Using some get component get info
and same thing there if your audio

00:17:37.820 --> 00:17:42.320
device has some internal pipeline,
you just need to report that

00:17:42.320 --> 00:17:45.600
to QuickTime and will offset
the audio track as well.

00:17:45.600 --> 00:17:49.530
So QuickTime can deal with
different latency between

00:17:49.530 --> 00:17:51.700
audio track and video track.

00:17:51.700 --> 00:17:54.900
The only assumption that we
still have is that if all the

00:17:55.220 --> 00:17:59.990
video codecs in this video track
need to report the same latency.

00:18:01.500 --> 00:18:08.310
So another assumption that
QuickTime did have before FIBO.

00:18:10.810 --> 00:18:14.830
When you have a system which
has multiple codecs able to

00:18:14.900 --> 00:18:18.700
decompress the same kind of data,
we needed to choose one.

00:18:19.520 --> 00:18:20.700
Right?

00:18:20.700 --> 00:18:25.700
So, the one we chose, of course,
was the one which was the fastest one.

00:18:25.880 --> 00:18:28.490
Because every codec is
supposed to report their speed.

00:18:28.700 --> 00:18:31.370
I mean, internally,

00:18:31.670 --> 00:18:34.690
If you had two DV codecs
installed on your system,

00:18:34.690 --> 00:18:38.120
we were getting the speed for
each of these codecs and making

00:18:38.350 --> 00:18:42.870
the one we used the one claiming
that we were the fastest one.

00:18:42.880 --> 00:18:46.780
Of course, this scheme assumes that
these codecs don't lie,

00:18:46.780 --> 00:18:47.450
right?

00:18:47.450 --> 00:18:50.410
Well, they do.

00:18:51.300 --> 00:18:52.400
It's too bad, right?

00:18:52.400 --> 00:18:54.640
But they don't have
that much other option.

00:18:54.640 --> 00:18:58.200
Basically what's happening is that
you pay for this piece of hardware

00:18:58.200 --> 00:19:02.640
and you stick that in your system
and they want to be the one that

00:19:02.640 --> 00:19:04.900
QuickTime is going to use by default.

00:19:04.900 --> 00:19:08.120
And the only way for them to
make that happen was to claim

00:19:08.120 --> 00:19:10.570
that they are faster than,
for instance,

00:19:10.600 --> 00:19:12.980
the software upon implementation.

00:19:13.720 --> 00:19:16.530
But it was getting worse because
when you start having two pieces

00:19:16.530 --> 00:19:20.220
of hardware in the same machine,
I mean, everybody was trying to

00:19:20.220 --> 00:19:21.940
look at the other guy,
Kodak,

00:19:22.010 --> 00:19:25.460
figure out what their speed and claim
that they were faster than the other one,

00:19:25.460 --> 00:19:25.850
right?

00:19:25.860 --> 00:19:28.920
Of course,
that's not really a viable solution

00:19:28.920 --> 00:19:32.990
and we used to call that the Kodak
speed war internally whenever

00:19:32.990 --> 00:19:37.340
he was trying to claim that they
were faster than the other one.

00:19:37.850 --> 00:19:43.140
So what we did in 5.0 was to
finally let the application decide

00:19:43.160 --> 00:19:45.270
which codec they want to use when.

00:19:45.570 --> 00:19:48.990
So we did end up this codec war.

00:19:50.600 --> 00:19:52.740
At least we hope so.

00:19:52.880 --> 00:19:57.290
So the way an application can specify
this preferred codec is to use this new

00:19:57.290 --> 00:20:00.540
API called mediaset_preferred_codec.

00:20:00.630 --> 00:20:02.740
By using that,
you provide QuickTime a list

00:20:02.830 --> 00:20:05.280
of codecs you prefer to use.

00:20:05.430 --> 00:20:08.330
Internally,
what QuickTime is going to do is

00:20:08.330 --> 00:20:10.950
to still sort all of them by speed.

00:20:11.060 --> 00:20:13.560
At the end of the sort,
what we're going to do is put

00:20:13.560 --> 00:20:18.270
the codec you've given us in
this list at the top of the list.

00:20:19.640 --> 00:20:24.480
So it's definitely a much better
solution than the speed information,

00:20:24.480 --> 00:20:27.300
which was the only information
we had before in QuickTime.

00:20:27.310 --> 00:20:31.710
And it makes application setup
much easier when they decide

00:20:31.710 --> 00:20:35.740
to set up a user project,
trying to understand which piece of

00:20:36.010 --> 00:20:38.800
hardware or software they want to use.

00:20:38.800 --> 00:20:45.040
You might have your system setup,
for instance, doing a FireWire DB input,

00:20:45.040 --> 00:20:48.630
and have another piece of hardware
which is capable of sending

00:20:48.640 --> 00:20:53.380
DB data to an analog output,
and you really want to let the user

00:20:53.400 --> 00:20:58.060
and the application be able to select
which one they want to use at one point.

00:20:59.420 --> 00:21:04.000
So just one more thing
about hardware codec.

00:21:04.000 --> 00:21:09.870
If your hardware has implemented
a custom compression type,

00:21:09.870 --> 00:21:13.620
what's happening is that when
you create your content with

00:21:13.620 --> 00:21:17.490
this codec in your movie,
if your end user does have the

00:21:17.490 --> 00:21:20.290
hardware installed in your system,
you're fine.

00:21:20.300 --> 00:21:22.590
You can play back this movie.

00:21:22.910 --> 00:21:28.930
If you try to have this content play on a
system which doesn't have your hardware,

00:21:28.930 --> 00:21:33.210
then you need to provide a software
implementation of your hardware codec,

00:21:33.210 --> 00:21:33.800
right?

00:21:34.020 --> 00:21:39.160
Well, the problem is that the user has
no idea what he's looking for when

00:21:39.160 --> 00:21:41.800
he's running into a movie like that.

00:21:41.800 --> 00:21:43.800
He doesn't know where the
content has been altered,

00:21:43.800 --> 00:21:46.840
he doesn't know which
company is making what codec,

00:21:47.180 --> 00:21:50.630
so it's quite a bad
user experience for him.

00:21:51.260 --> 00:21:56.660
So the solution is to use our new
mechanism in QuickTime 5 to do

00:21:56.660 --> 00:21:58.800
this automatic component download.

00:21:58.810 --> 00:22:03.320
And all that you have to do if you have
a custom hardware codec is register

00:22:03.320 --> 00:22:06.040
your software implementation with Apple.

00:22:06.060 --> 00:22:10.100
And we will get it directly
from our own server as soon as

00:22:10.100 --> 00:22:12.570
your end user will run into it.

00:22:13.310 --> 00:22:17.520
So that's pretty much it about
hardware and QuickTime 5.0.

00:22:17.520 --> 00:22:21.700
Let's talk about MP and QuickTime on Mac.

00:22:21.700 --> 00:22:23.560
Thank you.

00:22:26.940 --> 00:22:28.320
Thank you Jean-Michel.

00:22:28.320 --> 00:22:32.520
My name is Sam Bushell and I'd like to
take a little time to talk to you about

00:22:32.700 --> 00:22:33.800
QuickTime on multiprocessor Macintoshes.

00:22:33.800 --> 00:22:38.750
Multiprocessor Macintoshes are great,
right?

00:22:38.800 --> 00:22:41.900
And they're great because
they have more processors.

00:22:41.990 --> 00:22:46.500
If you have more processors
than the other guy then you win!

00:22:46.570 --> 00:22:50.410
Well, maybe.

00:22:51.920 --> 00:22:54.980
In practice,
people want to buy a machine with

00:22:54.980 --> 00:22:59.160
two processors because they'd like
everything to run twice as fast.

00:22:59.280 --> 00:23:03.400
It turns out, if you're an engineer,
you probably have some idea of

00:23:03.540 --> 00:23:05.810
why it doesn't quite work so well.

00:23:07.330 --> 00:23:09.130
And so as engineers,
we have to do a little bit of work

00:23:09.160 --> 00:23:12.480
to make this hope satisfiable.

00:23:12.580 --> 00:23:16.820
Now, sometimes the user is running more
than one application at the same time,

00:23:16.920 --> 00:23:19.070
and those applications,
maybe several of them are

00:23:19.070 --> 00:23:20.540
doing compute-bound tasks.

00:23:20.640 --> 00:23:23.950
In that case, on Mac OS X,
we automatically get symmetric

00:23:23.950 --> 00:23:27.860
multiprocessing that'll schedule
and run all of the applications that

00:23:27.860 --> 00:23:30.350
are available to have work to do.

00:23:30.470 --> 00:23:35.680
And so that side of the problem is
pretty much sorted out for us now on 10.

00:23:35.680 --> 00:23:39.450
But sometimes only one
application is doing any work.

00:23:40.260 --> 00:23:41.700
In that case,
we have to do a bit more work

00:23:41.810 --> 00:23:45.310
to divide that work up across
the available processes.

00:23:45.760 --> 00:23:49.790
Now, in the QuickTime case, there are

00:23:51.160 --> 00:23:54.330
A bunch of different bits of
work to be done on the system,

00:23:54.370 --> 00:23:57.090
but the majority of them
tend to be done by codecs.

00:23:57.100 --> 00:24:00.980
And so the work that we've
done with QuickTime to support

00:24:01.180 --> 00:24:06.800
multiprocessor computers and
multiprocessing is primarily focused

00:24:06.860 --> 00:24:09.590
on making the codecs run faster.

00:24:10.290 --> 00:24:12.440
So it's a team effort.

00:24:12.440 --> 00:24:15.600
In QuickTime generally,
if you have an application

00:24:15.600 --> 00:24:18.100
that uses QuickTime and there
are some codecs involved,

00:24:18.150 --> 00:24:21.200
the application calls QuickTime,
QuickTime calls some component,

00:24:21.420 --> 00:24:26.190
the codec runs for a
while doing some work,

00:24:26.190 --> 00:24:26.190
and when it's done it
returns the application.

00:24:26.550 --> 00:24:31.080
So let's look at how this team
effort might be made faster to take

00:24:31.090 --> 00:24:34.700
advantage of dual-processor computer.

00:24:35.420 --> 00:24:38.240
If you're lucky,
you might be able to take the work

00:24:38.240 --> 00:24:42.690
that Kodak is doing and divide
it evenly across two processes.

00:24:42.860 --> 00:24:45.540
If you're not so lucky,
it might not be applicable,

00:24:45.570 --> 00:24:49.430
but it might be possible to run
that decompression or that Kodak

00:24:49.430 --> 00:24:53.330
work asynchronously and let the
application do some other work,

00:24:53.330 --> 00:24:58.010
maybe some other decompression for
the next frame at the same time.

00:24:58.520 --> 00:25:01.440
In more detail,
this is the first approach.

00:25:01.490 --> 00:25:07.390
If you can split up your work across
a bunch of multiprocessor tasks,

00:25:07.430 --> 00:25:09.380
then they can be run
all at the same time.

00:25:09.400 --> 00:25:12.400
And when they're all done,
they all return.

00:25:12.400 --> 00:25:16.320
So this is still a synchronous API.

00:25:16.320 --> 00:25:20.400
The application asks you to do the work,
and when you're done, you return.

00:25:20.410 --> 00:25:24.310
And you've taken up all of the
CPUs available in the meantime.

00:25:24.320 --> 00:25:27.920
This is the best situation because the
applications don't need to be revised.

00:25:27.990 --> 00:25:30.400
They can keep using
those synchronous APIs.

00:25:30.450 --> 00:25:33.170
And there are high performance
gains possible as we've

00:25:33.170 --> 00:25:34.790
demonstrated with the dbCodec.

00:25:34.910 --> 00:25:37.480
The trouble is it's harder.

00:25:37.480 --> 00:25:41.000
And it's not something you can
easily do with all algorithms.

00:25:41.130 --> 00:25:43.720
Sometimes step one has to
be done before step two,

00:25:43.720 --> 00:25:45.300
and step two has to be
done before step three.

00:25:45.300 --> 00:25:49.380
And so you can't do step one, two,
and three all at the same time.

00:25:49.480 --> 00:25:53.350
In those situations you
need to take a step back.

00:25:54.090 --> 00:25:58.160
Re-evaluate how you'd like to go,
and maybe it's okay to run the entire

00:25:58.160 --> 00:26:02.480
job that you want to do in a single
MP task asynchronously from what the

00:26:02.540 --> 00:26:04.590
rest of the application is doing.

00:26:04.710 --> 00:26:10.630
This is a smaller change to the codec,
and in fact it can be a really small

00:26:10.630 --> 00:26:12.550
change if QuickTime can help you out.

00:26:12.670 --> 00:26:15.780
The trouble is, it doesn't actually make
that task any faster.

00:26:15.860 --> 00:26:18.200
It just takes as long.

00:26:18.300 --> 00:26:20.740
Maybe if the application
has something else to do,

00:26:20.770 --> 00:26:21.920
then it's a win overall.

00:26:21.940 --> 00:26:24.210
But the corollary of this
is that in order to take

00:26:24.210 --> 00:26:28.180
advantage of this situation,
the applications do need to be revised

00:26:28.180 --> 00:26:34.230
and maybe restructured to take advantage
of this using asynchronous APIs.

00:26:34.550 --> 00:26:37.680
So in QuickTime 5,
we've used both approaches to taking

00:26:37.680 --> 00:26:42.880
advantage of multiprocessor computers.

00:26:43.800 --> 00:26:46.170
have revised the DV Compressor
and Decompressor,

00:26:46.170 --> 00:26:48.410
as you've probably heard
a number of times by now,

00:26:48.580 --> 00:26:53.010
to split up their work across the
available processes in the computer.

00:26:53.980 --> 00:26:56.430
We've revised some of
the other compressors and

00:26:56.430 --> 00:27:01.460
decompressors in QuickTime to
be able to run asynchronously.

00:27:01.520 --> 00:27:04.080
And I have a little demonstration
of this that I'd like to show you,

00:27:04.080 --> 00:27:06.180
which is over here on demo four.

00:27:08.260 --> 00:27:14.000
Now this is an application that I wrote
for debugging and analysis purposes,

00:27:14.000 --> 00:27:17.860
but I'd like to use it here as a
technology demonstration to give

00:27:17.860 --> 00:27:22.200
you an idea of something that
might be an applicable use of both

00:27:22.240 --> 00:27:26.500
of these kinds of technologies,
both the method A and method

00:27:26.550 --> 00:27:30.620
B for splitting up work on
a dual processor computer.

00:27:30.620 --> 00:27:35.680
We have back here is a dual
processor 500 megahertz G4,

00:27:35.680 --> 00:27:39.680
and my application,
you probably can't see all

00:27:39.680 --> 00:27:42.770
of the text on the screen,
it doesn't matter,

00:27:42.770 --> 00:27:46.390
it's not very interesting,
apart from the fact that it has a

00:27:46.460 --> 00:27:49.400
bunch of different bit rates listed.

00:27:49.400 --> 00:27:53.700
And we have a DV camera here,
and it's pointed at you,

00:27:53.700 --> 00:27:55.680
and this is what you look like.

00:27:57.500 --> 00:28:03.300
[Transcript missing]

00:28:03.900 --> 00:29:06.600
[Transcript missing]

00:29:08.920 --> 00:29:10.100
Modem rates.

00:29:10.100 --> 00:29:16.800
So you might have the first,
the 12 kilobit of video for a 28k modem,

00:29:16.800 --> 00:29:20.680
24 kilobit per second of
video for a 56k modem,

00:29:20.680 --> 00:29:26.420
something towards 80 kilobit per
second for a dual ISDN or some other

00:29:26.420 --> 00:29:30.980
hundred odd kilobit connection,
and something higher as well

00:29:30.980 --> 00:29:33.150
at full 30 frames per second.

00:29:33.150 --> 00:29:36.310
But if you're close enough,
then you can probably read that we're not

00:29:36.350 --> 00:29:38.680
currently achieving 25 frames per second.

00:29:38.680 --> 00:29:40.080
Which makes this look
like a foolish demo,

00:29:40.080 --> 00:29:43.820
except that I can point out that
the reason it's lagging behind is

00:29:43.820 --> 00:29:45.430
because it's showing you the answers.

00:29:45.490 --> 00:29:49.470
And if I turn off the preview so that you
don't get to see yourself on the screen,

00:29:49.470 --> 00:29:52.890
then we do reach 30 frames
per second pretty efficiently.

00:29:52.890 --> 00:29:56.340
And there's actually quite a bit of
CPU left available on the machine.

00:29:56.340 --> 00:30:01.040
So you could take,
what this demonstrates is that

00:30:01.300 --> 00:30:06.510
you could take QuickTime 501 and
a dual processor 500 megahertz G4,

00:30:06.600 --> 00:30:08.120
and you could prepare.

00:30:08.560 --> 00:30:13.190
So you could take a few of these,
multiple compression video streams,

00:30:13.190 --> 00:30:16.310
and then you could probably
broadcast them to a

00:30:17.220 --> 00:30:22.830
Streaming Reflectors,
which will go out to a

00:30:22.830 --> 00:30:22.830
wide range of people.

00:30:23.400 --> 00:30:25.580
All in one machine.

00:30:25.710 --> 00:30:27.520
This will be a useful product.

00:30:27.580 --> 00:30:31.360
And that's my demo.

00:30:37.750 --> 00:30:42.270
So among the developers here,
some of you are probably

00:30:42.270 --> 00:30:43.560
writing applications.

00:30:43.720 --> 00:30:46.960
Those of you who are,
the thing you can do on

00:30:47.920 --> 00:30:52.020
multiprocessor Macintoshes is
you can call QuickTime using

00:30:52.240 --> 00:30:56.600
the asynchronous compression
APIs instead of synchronous ones.

00:30:57.040 --> 00:31:00.320
If you're a codec author,
then you might want to accelerate

00:31:00.340 --> 00:31:03.690
your codec to take advantage
of multiprocessor machines,

00:31:03.690 --> 00:31:05.390
either using approach A or approach B.

00:31:05.390 --> 00:31:06.980
It's up to you.

00:31:07.100 --> 00:31:11.000
Let's have a look at these
asynchronous compression APIs first.

00:31:11.000 --> 00:31:16.400
QuickTime has always had an asynchronous
mode for the Image Compression

00:31:16.400 --> 00:31:19.000
Manager's compression API.

00:31:19.000 --> 00:31:21.490
Basically,
the last of these lots of parameters that

00:31:21.490 --> 00:31:25.260
describe what you want to compress and
how you want to compress and so forth.

00:31:25.260 --> 00:31:30.000
The very last parameter says,
is a completion routine.

00:31:30.000 --> 00:31:33.960
And this, you can pass nil,
in which case it won't

00:31:33.960 --> 00:31:37.040
return until it's done,
or you can pass a

00:31:37.040 --> 00:31:40.500
completion proc in RefCon,
in which case it is allowed

00:31:40.720 --> 00:31:43.950
to return immediately,
and when it's actually done

00:31:43.990 --> 00:31:47.890
with the compression activity,
then it will call your callback routine,

00:31:47.990 --> 00:31:49.000
and you'll know.

00:31:49.000 --> 00:31:51.330
Um,

00:31:52.080 --> 00:31:54.860
If this is safe to use,
even if a codec doesn't actually

00:31:54.860 --> 00:31:58.400
support asynchronous compression,
in that case,

00:31:58.480 --> 00:32:05.240
it will return after calling your
callback after everything is done.

00:32:06.620 --> 00:32:09.950
The trouble was that there wasn't,
that there's a missing piece here,

00:32:09.950 --> 00:32:13.440
because a lot of people who want to
write compression applications want

00:32:13.440 --> 00:32:17.430
to use a higher level service called
the standard compression component.

00:32:17.510 --> 00:32:22.380
This is the component that provides
a nice friendly dialog box that

00:32:22.380 --> 00:32:25.190
you've probably seen a hundred times.

00:32:25.600 --> 00:32:28.910
And that component only
had a synchronous API.

00:32:28.910 --> 00:32:33.850
So in QuickTime 5 we've added an
API analogous to the asynchronous

00:32:33.850 --> 00:32:35.940
compression in the ICM.

00:32:36.050 --> 00:32:39.070
I've said the word compression
a lot of times in that slide.

00:32:40.590 --> 00:32:42.890
So if you want to read more about that,
I recommend looking at the

00:32:42.890 --> 00:32:44.050
QuickTime 5 documentation.

00:32:44.080 --> 00:32:45.260
There's lots of good stuff there.

00:32:46.920 --> 00:32:50.140
If you're a codec author, then as I said,
you have the two choices.

00:32:50.230 --> 00:32:55.240
You can accelerate your codec by calling
the multiprocessor APIs yourself,

00:32:55.410 --> 00:33:00.920
creating some tasks,
when we call you to do some work,

00:33:01.150 --> 00:33:04.420
splitting that work up across your tasks,
and then waiting until they're

00:33:04.420 --> 00:33:08.060
all done and then returning,
or calling the completion routines.

00:33:08.200 --> 00:33:08.790
That's great.

00:33:09.010 --> 00:33:12.200
If you do that,
you're pretty much on your own.

00:33:14.120 --> 00:33:17.190
Although there were some pitfalls I'm
going to warn you about in a second

00:33:17.190 --> 00:33:19.840
that you should be careful to avoid.

00:33:19.940 --> 00:33:23.600
If you take approach B of running
the entire activity asynchronously

00:33:23.600 --> 00:33:28.020
and then calling the completion
routine when you're done,

00:33:28.090 --> 00:33:30.440
running the activity
on an MP task that is,

00:33:30.530 --> 00:33:33.540
if you're writing a decompressor
and it's based on the base codec,

00:33:33.640 --> 00:33:35.160
then QuickTime can help.

00:33:35.270 --> 00:33:39.710
All you need to do is write a
little bit of code that promises

00:33:39.840 --> 00:33:42.660
that your drawband call is MP safe.

00:33:42.910 --> 00:33:46.970
Since drawband calls for video
codecs generally have to be

00:33:46.970 --> 00:33:50.070
interrupt safe because they might
be called at deferred task time,

00:33:50.070 --> 00:33:51.190
this isn't a big leap.

00:33:51.330 --> 00:33:56.290
You really shouldn't be calling
any other APIs besides ones,

00:33:56.380 --> 00:34:00.590
just other functions defined in your
own sources in your drawband call.

00:34:00.730 --> 00:34:04.500
So generally those things,
as long as they're PowerPC native,

00:34:04.520 --> 00:34:06.490
are also safe to run in MP tasks.

00:34:06.790 --> 00:34:09.860
So if you write a little bit of code that
promises that everything's cool there,

00:34:09.940 --> 00:34:12.720
then we will run you in an MP task.

00:34:12.880 --> 00:34:18.420
If applicable,
if we're on a multiprocessor

00:34:18.420 --> 00:34:21.180
machine and trying to do an
asynchronous decompression.

00:34:21.180 --> 00:34:22.600
Subtitles by the Amara.org community

00:34:23.330 --> 00:34:28.280
So there are three pitfalls I'd like
to point out so you have in mind so

00:34:28.330 --> 00:34:30.540
you can avoid them moving forward.

00:34:31.130 --> 00:34:33.530
I've said that you shouldn't
call anything in drawband.

00:34:33.540 --> 00:34:36.200
Some of you who have read
the documentation on Apple's

00:34:36.200 --> 00:34:39.410
multiprocessing APIs will say,
no wait, I've read about this.

00:34:39.490 --> 00:34:42.530
You're allowed to call all of these
memory allocation routines and

00:34:42.600 --> 00:34:45.800
in fact in Mac OS 9.1 and later
you're allowed to call all sorts of

00:34:46.190 --> 00:34:47.790
other things like the file system.

00:34:47.790 --> 00:34:53.170
Well, you're not allowed to do
that from a codex drawband.

00:34:53.200 --> 00:34:54.560
routine.

00:34:54.600 --> 00:34:58.500
The reason is that the remote
procedure call that implements some

00:34:58.500 --> 00:35:01.400
of these allocations and other calls

00:35:02.820 --> 00:35:05.760
That remote procedure call
can only be serviced when

00:35:05.760 --> 00:35:10.500
someone in the blue task calls
waitnextevent or one of its friends.

00:35:10.510 --> 00:35:12.800
If that doesn't happen,
then you can deadlock.

00:35:12.840 --> 00:35:16.430
And sometimes codecs can be called in
situations where we can't let someone

00:35:16.500 --> 00:35:18.800
have a chance to call waitnextevent.

00:35:18.870 --> 00:35:22.730
So if you need to allocate memory,
do it as before,

00:35:22.950 --> 00:35:26.090
before doing anything in drawband.

00:35:26.300 --> 00:35:32.750
A second pitfall to avoid,
avoid using your own calls to

00:35:32.750 --> 00:35:37.640
the MP APIs entirely in a codec,
unless you're running

00:35:37.720 --> 00:35:39.300
on Mac OS 9.1 or later.

00:35:39.300 --> 00:35:42.300
The reason for this is that
any page faults you hit,

00:35:42.440 --> 00:35:45.950
if you're unlucky,
any page faults can only be serviced

00:35:46.380 --> 00:35:47.500
in one of those wetnext event calls.

00:35:47.560 --> 00:35:49.540
And as I said, they might not happen.

00:35:49.640 --> 00:35:53.020
This is fixed quite nicely
in Mac OS 9.1 and it's not a

00:35:53.020 --> 00:35:54.770
problem at all on Mac OS X.

00:35:55.700 --> 00:36:04.750
Finally, if you're writing a decompressor
and you divide your work up,

00:36:05.080 --> 00:36:06.640
Enter MP Tasks.

00:36:06.640 --> 00:36:08.840
You should be careful that you
don't have one of them right to one

00:36:08.840 --> 00:36:11.250
part of the screen and the other
right to another part of the screen,

00:36:11.390 --> 00:36:13.320
because you could see
unpleasant tearing artifacts,

00:36:13.380 --> 00:36:17.160
which can be annoying.

00:36:17.330 --> 00:36:19.590
Well, if you do that, you'll see.

00:36:20.880 --> 00:36:21.560
That's all for me.

00:36:21.690 --> 00:36:26.230
I'd like to hand over now to Tom Dowdy.

00:36:26.230 --> 00:36:26.230
Thank you.

00:36:29.730 --> 00:36:30.690
Thank you.

00:36:30.830 --> 00:36:34.730
So I'm yet another member of
the professional video team,

00:36:34.730 --> 00:36:38.870
and what I'm going to talk to you today
about is some upcoming changes we've

00:36:38.890 --> 00:36:41.460
got with QuickTime effects architecture.

00:36:41.480 --> 00:36:43.690
Now up to this point we've
been talking about things that

00:36:43.720 --> 00:36:46.720
are available in QuickTime 5,
you could take advantage of today.

00:36:46.730 --> 00:36:49.470
We're going to be showing off some
stuff that's going to be coming

00:36:49.470 --> 00:36:52.130
in future versions of QuickTime,
but the reason we're going to talk

00:36:52.210 --> 00:36:56.060
about this today is that some of
these features you'll be able to

00:36:56.060 --> 00:37:00.880
get ready for in advance of the
code actually being available.

00:37:00.880 --> 00:37:04.110
This is of interest to you either if
you're a developer that takes advantage

00:37:04.110 --> 00:37:07.660
of the built-in QuickTime effects,
or if you're a developer who

00:37:07.660 --> 00:37:10.460
creates QuickTime effects yourself.

00:37:11.230 --> 00:37:15.810
We're going to be talking about two new
optional specifications that effects

00:37:15.810 --> 00:37:19.700
can provide or applications can take
advantage of to allow the grouping

00:37:19.700 --> 00:37:24.150
of effects into classifications or
groupings that make sense either for

00:37:24.150 --> 00:37:26.140
the user or for you in the application.

00:37:26.250 --> 00:37:29.150
We're also going to talk about
a feature called effect presets,

00:37:29.190 --> 00:37:32.740
which allows an effect that has a large,
complicated set of parameters to

00:37:32.760 --> 00:37:37.160
provide the user with a very simple
user interface for getting to them.

00:37:37.250 --> 00:37:37.900
And that's enough of that.

00:37:37.900 --> 00:37:40.150
Let's do a demo right away.

00:37:41.400 --> 00:37:42.490
Can I have demo 4 please?

00:37:42.600 --> 00:37:46.240
So there's no point in showing
you something new without showing

00:37:46.240 --> 00:37:47.200
you what was there before.

00:37:47.200 --> 00:37:51.880
So this is the existing effects dialog
that's been provided since QuickTime 3.

00:37:51.900 --> 00:37:55.860
It's a standard way for applications
to get to parameters and features

00:37:55.860 --> 00:37:57.380
of the QuickTime effects.

00:37:57.400 --> 00:38:01.950
As you can see, effects can have a large
number of various parameters,

00:38:01.960 --> 00:38:06.280
and it's nice to have a standard way
to provide a user interface for this.

00:38:06.300 --> 00:38:09.600
But another thing you might
notice is that we do tend to have

00:38:09.600 --> 00:38:12.960
an awful lot of effects here,
and a big, long scrolling list

00:38:13.090 --> 00:38:15.670
is no fun for anybody,
particularly if you can't make

00:38:15.670 --> 00:38:18.300
it any bigger because you can't
resize the dialog or anything else.

00:38:18.300 --> 00:38:22.300
Well, let's get rid of that
and solve the problem.

00:38:25.970 --> 00:38:28.120
So one of the first things you'll
notice is that the list on the

00:38:28.120 --> 00:38:34.080
left-hand side here has been
grouped into classes of effects.

00:38:34.100 --> 00:38:37.190
Another thing you'll notice is that we've
got plenty of screen real estate now.

00:38:37.320 --> 00:38:40.860
So let's just make that dialogue
nice and big and widen that on out.

00:38:40.980 --> 00:38:43.180
We've got plenty of room now.

00:38:43.210 --> 00:38:45.030
Yay.

00:38:46.910 --> 00:38:50.640
We're in the 90s.

00:38:50.780 --> 00:38:53.390
So what a user can do is they
can choose particular effects

00:38:53.580 --> 00:38:54.900
they might be wanting to do.

00:38:54.900 --> 00:38:57.940
So for example, filtering,
they can see the effects that

00:38:58.060 --> 00:38:59.900
are classified as filters.

00:39:00.080 --> 00:39:02.640
Let's just go ahead
and pop these all open.

00:39:03.010 --> 00:39:06.900
will populate the whole dialogue there.

00:39:06.970 --> 00:39:13.300
This is information that's provided
by the effects and is available

00:39:13.300 --> 00:39:13.300
both to this particular dialogue
and also to your application.

00:39:13.600 --> 00:39:15.600
One of the other things I should point
out is that we're going along here,

00:39:15.600 --> 00:39:18.710
you might see some other
features that aren't exactly in

00:39:18.720 --> 00:39:20.310
my list that I originally had.

00:39:20.410 --> 00:39:23.460
For example, the resizing and the
regrowing of the split bars.

00:39:23.460 --> 00:39:26.040
You can pay attention to those and
decide whether or not we're actually

00:39:26.040 --> 00:39:27.330
going to do anything with them.

00:39:27.340 --> 00:39:29.570
We talked about presets.

00:39:29.710 --> 00:39:32.950
So here's an example of an effect
that's using the new preset features.

00:39:32.950 --> 00:39:35.910
This is the slide effect,
and it provides two presets

00:39:36.010 --> 00:39:39.100
for a slide from the top or
a slide up from the bottom.

00:39:39.100 --> 00:39:41.920
The user can simply choose
the preset that they want.

00:39:42.080 --> 00:39:45.220
They've got a picture that more or less
shows them what's going to happen and a

00:39:45.220 --> 00:39:47.300
name that probably helps them as well.

00:39:47.370 --> 00:39:51.260
What's actually behind each of the
presets is the full list of parameters

00:39:51.260 --> 00:39:53.300
that are available to the effect.

00:39:53.550 --> 00:39:57.630
User can go see that as well and see
that this particular slide is going

00:39:57.630 --> 00:40:01.940
with an angle from zero to zero,
which is a slide from the top.

00:40:02.140 --> 00:40:05.610
Users can still go to this
optional parameter section here

00:40:05.610 --> 00:40:07.440
with the custom and make a change.

00:40:07.440 --> 00:40:11.570
For example, set the starting angle here
and then set the ending angle

00:40:11.570 --> 00:40:13.100
to something nice and big.

00:40:13.280 --> 00:40:17.010
And now we've got a slide that's
kind of spiraling around there.

00:40:17.390 --> 00:40:20.810
Another example of an effect
that uses the presets is a

00:40:20.810 --> 00:40:23.540
new channel composite effect.

00:40:23.620 --> 00:40:24.900
Who knows whether we'll ship this or not?

00:40:24.910 --> 00:40:26.470
I'm just showing you.

00:40:26.770 --> 00:40:29.900
This is an effect that performs a
combining of channels from multiple

00:40:29.900 --> 00:40:31.550
sources to produce a new source.

00:40:31.830 --> 00:40:35.920
It's often done when you have maps
that have been pulled from video,

00:40:35.950 --> 00:40:38.700
particularly in the professional
video or film market,

00:40:38.770 --> 00:40:42.910
and you want to combine them
together to obtain an alpha track

00:40:43.240 --> 00:40:46.290
that you're then going to alpha
or composite with other tracks.

00:40:46.380 --> 00:40:48.830
When you do this,
the maps are sometimes pulled positive,

00:40:48.840 --> 00:40:49.750
pulled negative.

00:40:49.870 --> 00:40:52.500
The actual alpha value may
already be in the alpha channel.

00:40:52.500 --> 00:40:53.090
It might not.

00:40:53.090 --> 00:40:55.700
It might be down in the RGB values.

00:40:56.020 --> 00:40:58.750
So we provide mechanisms
for selecting these basic

00:40:58.850 --> 00:41:00.800
options that users would need.

00:41:01.030 --> 00:41:04.750
But if they want to,
hidden behind the presets are all

00:41:04.820 --> 00:41:06.640
the actual parameters that are used.

00:41:06.800 --> 00:41:10.130
So, for example,
you can pull the values from different

00:41:10.130 --> 00:41:13.590
channels and different things,
and you get very strange combinations.

00:41:13.680 --> 00:41:15.300
Once again, there's no reason for the
effect to have been written,

00:41:15.330 --> 00:41:20.290
with this limited set of
presets that we see here.

00:41:20.430 --> 00:41:24.070
But those presets are most commonly used,
so that users who don't need the

00:41:24.070 --> 00:41:26.610
more crazy features or optional
features of the effect don't

00:41:26.630 --> 00:41:28.590
need to be concerned with them.

00:41:30.450 --> 00:41:33.870
And I think that's all
I have to show here.

00:41:33.940 --> 00:41:34.590
That's it.

00:41:34.650 --> 00:41:36.670
So let's go back to slides.

00:41:42.800 --> 00:42:45.700
[Transcript missing]

00:42:47.570 --> 00:42:51.550
With the major class,
effects have been divided

00:42:51.550 --> 00:42:56.160
or classified as to what is
their function in this sense,

00:42:56.160 --> 00:43:00.870
and you can limit the scope of what
the user has to choose between.

00:43:01.030 --> 00:43:03.890
Like most of the options
that are in effects,

00:43:04.080 --> 00:43:07.260
the major class is defined by
an atom that's placed in the

00:43:07.370 --> 00:43:09.240
effect description container.

00:43:09.240 --> 00:43:12.180
Now you see here listed the
class type and ID for this and

00:43:12.180 --> 00:43:13.400
the values that we provide.

00:43:13.400 --> 00:43:16.400
Now in the case of the major class,
because applications are

00:43:16.400 --> 00:43:19.000
essentially going to be hard
coding themselves to certain

00:43:19.000 --> 00:43:22.990
classifications for the major class,
this list is rigid and has to be

00:43:23.120 --> 00:43:27.270
defined by Apple and agreed upon by both
components that are being implemented

00:43:27.410 --> 00:43:29.060
and applications that want to use it.

00:43:29.150 --> 00:43:31.750
So we've defined this list here,
which you can make use of.

00:43:31.820 --> 00:43:35.160
Now if you and your effect don't
define what your major class is,

00:43:35.230 --> 00:43:37.660
you're going to be grouped
into miscellaneous,

00:43:37.710 --> 00:43:40.160
which may or may not be what you want.

00:43:41.700 --> 00:43:44.700
So, if you're an effect
developer creating effects,

00:43:44.730 --> 00:43:47.230
you're going to be
wanting to add this atom.

00:43:47.310 --> 00:43:52.110
If you're an application developer that
needs to limit the effects the user sees

00:43:52.260 --> 00:43:57.270
to make the user's experience easier,
you can take advantage of this to do so.

00:43:57.730 --> 00:43:59.780
Effect Minor Class is
used for the UI grouping,

00:43:59.780 --> 00:44:01.920
like I said, and that was,
just to reiterate,

00:44:02.010 --> 00:44:05.860
that was used to make the twist-down
triangles in the dialogue you saw there.

00:44:05.860 --> 00:44:08.510
Once again, no surprise,
it's an atom that's placed in

00:44:08.510 --> 00:44:11.320
the effect description that
describes the minor class.

00:44:11.400 --> 00:44:15.110
You see here the atom types
and IDs that are used for that,

00:44:15.340 --> 00:44:19.300
and the contents is one of a number
of ones that Apple has defined here.

00:44:19.300 --> 00:44:21.960
We welcome input from
third-party developers.

00:44:21.960 --> 00:44:25.160
We've already solicited some already
as to what types of groupings

00:44:25.270 --> 00:44:26.760
that you would like to see.

00:44:26.760 --> 00:44:28.760
And any of the standard
ones you see here,

00:44:28.760 --> 00:44:31.790
Apple's going to be providing the,
will automatically interpret those and

00:44:31.840 --> 00:44:35.050
provide the strings to display to the
user within the standardized dialogue.

00:44:35.060 --> 00:44:39.390
So here's some, and here's some more.

00:44:40.940 --> 00:44:42.560
And here's some more.

00:44:42.620 --> 00:44:45.620
And once again, if you don't tell us what
kind of minor class you are,

00:44:45.620 --> 00:44:47.870
then you're miscellaneous.

00:44:49.820 --> 00:44:52.890
If you aren't happy with these,
unlike the major class,

00:44:53.060 --> 00:44:56.090
the minor classes can be
extended by the effect.

00:44:56.310 --> 00:45:01.480
You can supply a custom string that
corresponds to your minor class's name.

00:45:01.650 --> 00:45:05.040
The types and IDs of that
atom are specified here.

00:45:05.240 --> 00:45:09.700
And that string will then be used
in place of the standardized,

00:45:09.700 --> 00:45:14.500
I'm sorry, in place of your OS type
for your minor class,

00:45:14.610 --> 00:45:16.350
which you probably wouldn't
want to see in a scrolling list.

00:45:16.610 --> 00:45:18.790
If you, however,
specify a minor class that's

00:45:18.790 --> 00:45:22.120
one of the standardized ones,
we'll be supplying a string for that,

00:45:22.120 --> 00:45:24.690
so it's not something
you need to worry about.

00:45:26.200 --> 00:47:15.300
[Transcript missing]

00:47:17.490 --> 00:47:19.400
And with that,
I'm going to turn back over to Jean-Mi,

00:47:19.450 --> 00:47:22.710
who's going to talk a little
bit about hardware and OS X.

00:47:29.400 --> 00:47:30.240
I'm back again.

00:47:30.360 --> 00:47:34.360
So apparently somebody figured out
that with my first run of the slide,

00:47:34.480 --> 00:47:36.870
without any graphics
and without any demo,

00:47:36.870 --> 00:47:39.330
I couldn't make the
whole room fall asleep,

00:47:39.330 --> 00:47:41.920
so they gave me another chance this time.

00:47:41.920 --> 00:47:46.110
So we're going to talk
about hardware again,

00:47:46.110 --> 00:47:49.400
but this time related to Mac OS X.

00:47:49.410 --> 00:47:53.420
And what I'm going to try
to do is explain to you,

00:47:53.420 --> 00:47:57.520
if you are coming from
the Mac OS 9 world only,

00:47:57.520 --> 00:48:04.760
and you have been doing stuff
that was totally legitimate to do,

00:48:04.760 --> 00:48:04.920
at least nobody was
preventing you to not do that,

00:48:05.010 --> 00:48:10.550
how you should move your hardware
component to be able to run on Mac OS X.

00:48:10.920 --> 00:48:15.690
So first,
let's have the bad news out of our way.

00:48:15.870 --> 00:48:21.050
So you can no longer do direct access
from your component to your own hardware.

00:48:21.050 --> 00:48:24.600
That's definitely something you
could do online and you can no

00:48:24.600 --> 00:48:27.400
longer do as soon as you run on OS X.

00:48:27.480 --> 00:48:31.790
You need a driver layer abstraction.

00:48:31.790 --> 00:48:31.790
Before

00:48:31.950 --> 00:48:36.170
When I say before it's mostly on 9,
I mean you could make all this

00:48:36.260 --> 00:48:40.060
access from your own component
because 9 was basically,

00:48:40.060 --> 00:48:43.240
I mean,
having a flat space when everybody

00:48:43.240 --> 00:48:47.190
could access to anything,
anywhere in the entire system.

00:48:47.770 --> 00:48:53.230
So the need of a driver is
no longer an option for 10.

00:48:53.690 --> 00:48:57.980
And the last bad news is that bringing
up your own hardware and debugging it

00:48:58.240 --> 00:49:00.620
is a little bit more complicated on 10.

00:49:01.050 --> 00:49:04.600
Because basically you're going to have
to live with two different pieces.

00:49:04.600 --> 00:49:07.770
One is going to be in the kernel space,
which is your driver,

00:49:07.770 --> 00:49:11.100
and then you're going to need
some kind of debugging tool.

00:49:11.100 --> 00:49:13.820
And the other one is
the component itself,

00:49:14.010 --> 00:49:17.150
which lives in the user space,
and you have some different

00:49:17.690 --> 00:49:19.440
kind of tool to debug that.

00:49:19.570 --> 00:49:21.690
So, I mean,
bringing up your stuff is going to

00:49:21.690 --> 00:49:23.580
be a little bit more complicated.

00:49:23.600 --> 00:49:28.680
So, let's talk about the good news now.

00:49:30.720 --> 00:49:34.540
Well, if you already have an
existing driver layer on 9,

00:49:34.540 --> 00:49:37.600
or at least if you have a library
to make all your hardware,

00:49:37.600 --> 00:49:39.950
I'd say you're pretty
much almost all set.

00:49:40.030 --> 00:49:43.560
All that you're going to have
to do is move this piece to 10,

00:49:43.580 --> 00:49:46.390
and your component
should be up and running.

00:49:46.400 --> 00:49:52.220
If you don't have one today, even on 9,
we do recommend that you go through the

00:49:52.250 --> 00:49:57.720
exercise on 9 before you move to 10,
because you will be able not

00:49:57.880 --> 00:50:03.020
only to make sure that you've
isolated all your hardware access,

00:50:03.020 --> 00:50:07.040
and on top of that, moving forward,
you'll be able to maintain

00:50:07.040 --> 00:50:11.080
the same version for 9 and 10,
which will be something that

00:50:11.080 --> 00:50:13.060
your customer will appreciate.

00:50:15.690 --> 00:50:17.690
And the last thing is
that when you're done,

00:50:17.690 --> 00:50:20.460
you will probably never
want to come back to 9.

00:50:20.610 --> 00:50:22.830
I mean,
the memory prediction scheme built

00:50:22.940 --> 00:50:27.810
inside 10 is definitely going to help
you figure out all the issues you have

00:50:27.830 --> 00:50:31.400
been fighting for all over the years.

00:50:32.800 --> 00:50:35.620
So what's the Mac OS X driver model?

00:50:35.990 --> 00:50:39.310
Well, as I said before,
this driver belongs to the

00:50:39.410 --> 00:50:44.920
kernel space and unfortunately
components live in the user space.

00:50:45.590 --> 00:50:52.170
If your hardware is based on an
existing family like USB or FireWire,

00:50:52.170 --> 00:50:57.540
what you should do is provide a
driver using this family so the

00:50:57.540 --> 00:51:02.100
stuff you have to write on your
driver is much smaller than bringing

00:51:02.200 --> 00:51:04.630
up a full driver implementation.

00:51:04.820 --> 00:51:08.150
So if you deal with this kind of device,
you should take advantage of what

00:51:08.150 --> 00:51:09.660
OS X provides in terms of family.

00:51:09.660 --> 00:51:11.700
They are helping you
with a bunch of stuff.

00:51:11.700 --> 00:51:18.690
If you have a very high-end system that
OS X has not been able to modelize,

00:51:18.700 --> 00:51:19.020
right?

00:51:19.020 --> 00:51:20.690
We don't really know
what you are doing there.

00:51:20.790 --> 00:51:24.700
It's way too complicated
to put that on the OS side.

00:51:24.740 --> 00:51:27.660
Then you don't have that many choices.

00:51:27.660 --> 00:51:31.940
You have to implement the
NIOkit library or a CFPlugin.

00:51:31.940 --> 00:51:36.700
And the driver API you are coming
up with is your full responsibility.

00:51:36.700 --> 00:51:39.820
I mean,
nobody is going to decide what kind

00:51:39.820 --> 00:51:42.700
of API is going through this driver.

00:51:42.720 --> 00:51:43.700
It's up to you.

00:51:43.700 --> 00:51:46.660
And that's why I was talking about 9.

00:51:46.730 --> 00:51:49.180
I mean, if you can validate all
this stuff running 9,

00:51:49.180 --> 00:51:52.120
I mean, your life will be much
easier when you move to 10.

00:51:52.440 --> 00:51:54.520
So the big no-no is on Mac OS X, right?

00:51:54.640 --> 00:51:59.100
As I said, you cannot read write register
anymore or even physical PCI memory

00:51:59.320 --> 00:52:00.780
from within your component.

00:52:00.850 --> 00:52:04.970
It belongs to your space and
the OS will not let you do that.

00:52:04.980 --> 00:52:11.010
The other point which is less obvious
when you're trying to bring up your

00:52:11.480 --> 00:52:18.010
hardware on X is that QuickTime passed
some completion proc to some component,

00:52:18.010 --> 00:52:20.870
mostly codecs, video digitizer,
and all this stuff.

00:52:20.940 --> 00:52:24.860
And these completion procs
belong to the user space.

00:52:25.180 --> 00:52:30.400
They are within QuickTime,
which is in the user space as well.

00:52:30.600 --> 00:52:33.420
So if you were doing,
if you are calling this

00:52:33.420 --> 00:52:37.840
completion proc before from
your own internet handler on 9,

00:52:37.840 --> 00:52:38.870
everything was fine.

00:52:38.940 --> 00:52:40.890
You can no longer do that on 10.

00:52:40.940 --> 00:52:44.990
You're going to have to come
up with some new mechanism

00:52:44.990 --> 00:52:47.400
that we'll talk about later.

00:52:47.910 --> 00:52:51.840
And the last thing is that you
cannot hold the CPU anymore.

00:52:51.940 --> 00:52:56.740
This used to be something that you can
do from a component on OS 9 at least.

00:52:56.800 --> 00:53:03.140
But this OS is fully preemptive OS,
so a thread will preempt you not

00:53:03.260 --> 00:53:06.780
only to call another component,
but your own component will

00:53:06.780 --> 00:53:08.800
be called from another thread.

00:53:08.880 --> 00:53:12.210
So if you expect to hold the
CPU to execute a component

00:53:12.210 --> 00:53:15.540
of action on your hardware,
this is not doable from

00:53:15.540 --> 00:53:17.800
within your component anymore.

00:53:19.680 --> 00:53:21.900
So do you do all this stuff on 10?

00:53:21.900 --> 00:53:24.460
Well,
only access your hardware on your driver,

00:53:24.460 --> 00:53:26.240
as I said.

00:53:26.240 --> 00:53:29.530
And you are going to
have to create a thread,

00:53:29.630 --> 00:53:33.160
at least in your component,
to call all this QuickTime completion

00:53:33.290 --> 00:53:37.480
proc in order to manage to
live in the same user space.

00:53:37.480 --> 00:53:41.840
How you do that,
basically there is some services from

00:53:41.840 --> 00:53:45.830
the OS which allows you to send messages

00:53:46.040 --> 00:53:47.500
via Mac port.

00:53:47.800 --> 00:53:52.850
So your kernel thread will be
able to wake up your user space

00:53:53.010 --> 00:53:58.960
thread and you will be able to
call the QuickTime completion

00:53:59.040 --> 00:54:01.350
product safely in there.

00:54:02.730 --> 00:54:06.290
So, a couple of things to
know about this stuff.

00:54:06.380 --> 00:54:10.230
I mean, crossing kernel space
is not totally free.

00:54:10.300 --> 00:54:13.320
I mean, it doesn't take that long,
but it takes some time.

00:54:13.320 --> 00:54:18.400
So, when you're bringing your hardware,
make sure that you minimize the number

00:54:18.400 --> 00:54:21.980
of calls that you do to your own driver,
especially during the

00:54:21.980 --> 00:54:23.340
initialization process.

00:54:23.340 --> 00:54:25.870
I mean,
don't try to come up with API when

00:54:25.980 --> 00:54:29.800
you're going to set a bit per call,
so it's going to take forever

00:54:29.950 --> 00:54:32.000
to have your hardware ready.

00:54:33.030 --> 00:54:37.940
The last thing is that threads
are very cool as soon as you

00:54:37.950 --> 00:54:43.040
understand what you are doing,
but you should never forget

00:54:43.040 --> 00:54:46.260
that as soon as you add a
thread on your component side,

00:54:46.400 --> 00:54:50.200
you're going to add some
load on the OS side.

00:54:50.200 --> 00:54:53.310
So, before going ahead and
creating a new thread,

00:54:53.420 --> 00:54:56.990
think about, I mean,
trying to share them between all your

00:54:56.990 --> 00:55:02.260
components and your different piece of
component that you expose to QuickTime.

00:55:02.700 --> 00:55:03.750
Thank you.

00:55:04.910 --> 00:55:07.440
Well,
I guess that's pretty much it for our

00:55:07.440 --> 00:55:11.510
QuickTime for Professional Video session.

00:55:11.740 --> 00:55:16.440
We have a couple of other sessions
running today and tomorrow.

00:55:16.600 --> 00:55:23.100
And the one you should definitely
go is the QuickTime feedback forum,

00:55:23.100 --> 00:55:24.600
which is usually pretty packed.

00:55:24.600 --> 00:55:28.600
So if you have any questions
that you want us to answer,

00:55:28.600 --> 00:55:33.950
you should definitely be there and
be there early because you might

00:55:33.950 --> 00:55:36.490
not be able to get into the room.

00:55:38.030 --> 00:55:42.460
So if you have any questions about all
the stuff we have been talking about

00:55:42.460 --> 00:55:47.740
in this professional video session,
you should contact Jeff Lowe at

00:55:47.740 --> 00:55:51.910
jeffloew@apple.com and he will
be able to get in touch with us.

00:55:52.980 --> 00:55:55.720
So if you need more detailed
information about all the stuff

00:55:56.050 --> 00:55:58.900
that we've been talking about,
you should definitely go to

00:55:58.900 --> 00:56:02.090
developer.apple.com/quicktime.

00:56:02.130 --> 00:56:06.100
We have a full documentation
about what's new in QuickTime 5,

00:56:06.100 --> 00:56:10.880
and you will find in there all the stuff
we were specifically talking about.

00:56:10.880 --> 00:56:13.410
There is also another
place on this website,

00:56:13.410 --> 00:56:17.160
which is called the Ice Flows,
where you have some explanation

00:56:17.160 --> 00:56:19.930
about all this rendering,
this pixel format,

00:56:19.930 --> 00:56:22.790
and the effects stuff that
Tom has been talking about.

00:56:22.900 --> 00:56:28.510
If you didn't quite understand all
the stuff that Tim was talking about,

00:56:28.650 --> 00:56:33.900
about YUV space, gamma, off-road rate,
and all this issue behind that,

00:56:33.900 --> 00:56:37.430
we do recommend to read this
book from Charles Poynton,

00:56:37.430 --> 00:56:42.090
which is called "A Technical Introduction
to Digital Video." There is a

00:56:42.180 --> 00:56:45.800
lot of information in there to
understand why it's so painful

00:56:45.800 --> 00:56:48.570
to go through all this rendering process.

00:56:50.600 --> 00:56:54.930
And the last thing is about
our QuickTime event this

00:56:54.980 --> 00:56:58.720
October in Beverly Hills,
California.

00:56:58.720 --> 00:57:01.500
So if you do all this
stuff about QuickTime,

00:57:01.500 --> 00:57:03.500
you should definitely go there.

00:57:03.500 --> 00:57:06.500
It's a chance for you to meet other,
I mean, third-party developers.

00:57:06.500 --> 00:57:09.680
It's a chance to meet all the
QuickTime engineering crew,

00:57:09.680 --> 00:57:11.780
which is usually going over there.

00:57:11.780 --> 00:57:16.030
And it's a chance to hear
about what's new in QuickTime.

00:57:16.040 --> 00:57:18.200
And that's pretty much it.

00:57:18.200 --> 00:57:19.890
Thank you very much.
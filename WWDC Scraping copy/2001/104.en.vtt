WEBVTT

00:00:04.320 --> 00:00:08.060
Good afternoon and welcome to
Worldwide Developer Conference.

00:00:08.060 --> 00:00:09.910
I'm Craig Keithley.

00:00:10.060 --> 00:00:13.070
I'm the USB and FireWire technology
manager in Apple's Worldwide

00:00:13.070 --> 00:00:14.840
Developer Relations program.

00:00:14.950 --> 00:00:18.290
And I've been working on USB and
FireWire drivers and products

00:00:18.340 --> 00:00:20.460
probably for the last four years.

00:00:20.520 --> 00:00:24.660
I've worked on just about every different
kind of driver that exists at Apple.

00:00:24.770 --> 00:00:29.600
And it's been incredible to watch the
adoption of I/O Kit over the last year.

00:00:30.050 --> 00:00:33.100
I've worked with developers internal
to Apple and external to Apple,

00:00:33.130 --> 00:00:36.380
and all of them come to me and
tell me how powerful it is,

00:00:36.510 --> 00:00:38.080
how useful it is.

00:00:38.170 --> 00:00:41.690
The object inheritance model that we
have makes it easy to write drivers

00:00:41.690 --> 00:00:44.960
that leverage off of the families
that are in the operating system.

00:00:45.030 --> 00:00:48.030
And so to introduce this to you,
describe it to you in depth,

00:00:48.080 --> 00:00:50.920
I'd like to bring up Dean Reece.

00:00:50.920 --> 00:00:50.920
Dean?

00:00:58.540 --> 00:00:59.760
Hi, good afternoon.

00:00:59.820 --> 00:01:00.620
I'm Dean Reece.

00:01:00.700 --> 00:01:03.300
I manage the I/O Kit team at Apple.

00:01:03.310 --> 00:01:05.930
And I don't know how in-depth
we'll be able to get today,

00:01:05.990 --> 00:01:09.460
because I/O Kit covers a lot
of API and a lot of ground.

00:01:09.560 --> 00:01:11.940
But we'll definitely cover
as much of it as we can,

00:01:11.940 --> 00:01:17.930
and there's a whole lot of sessions
for the rest of the week that will

00:01:18.000 --> 00:01:19.740
hopefully give you the details you
need to be able to make your products.

00:01:20.490 --> 00:01:24.530
So in introduction,
we're going to talk about sort of

00:01:24.540 --> 00:01:27.120
the design and the scope of I/O Kit.

00:01:27.120 --> 00:01:28.210
I/O Kit is just one word.

00:01:28.220 --> 00:01:29.640
It doesn't really tell
you what all it covers.

00:01:29.640 --> 00:01:32.560
And it's actually important to
know what fits in I/O Kit and

00:01:32.610 --> 00:01:34.360
what doesn't fit in I/O Kit.

00:01:34.360 --> 00:01:37.430
We'll talk about kernel extension some,
because that's the basic unit of

00:01:37.450 --> 00:01:40.280
delivery for I/O Kit components.

00:01:40.280 --> 00:01:43.250
And I'm also going to spend a
little bit of time talking about how

00:01:43.410 --> 00:01:46.180
applications can get access to devices.

00:01:46.180 --> 00:01:47.800
This is very important, obviously.

00:01:47.800 --> 00:01:52.190
If somebody's porting any kind of
application that maybe wants to sync to

00:01:52.190 --> 00:01:57.220
a handheld device or touch any kind of
hardware that's out there where a higher

00:01:57.290 --> 00:01:59.370
level of abstraction is not appropriate.

00:01:59.400 --> 00:02:02.950
So we'll spend some time talking
about the various models for that.

00:02:04.540 --> 00:02:07.980
So it's only a couple
sessions into WWDC this year,

00:02:07.980 --> 00:02:09.760
but I'm sure you're already
familiar with this slide.

00:02:09.760 --> 00:02:12.930
We're going to be
focusing in on the bottom,

00:02:13.010 --> 00:02:15.080
the Darwin capsule there.

00:02:15.080 --> 00:02:19.650
And to expand on that a little bit,
this is the explosion

00:02:19.650 --> 00:02:23.400
of the Darwin kernel,
and there's a lot of components in there.

00:02:23.400 --> 00:02:27.270
I/O Kit is just one of them,
and drivers are built based on

00:02:27.270 --> 00:02:31.680
I/O Kit primitives and provide
services to the rest of the Core OS,

00:02:31.680 --> 00:02:35.050
the Darwin kernel, and the higher level
applications as well.

00:02:37.540 --> 00:02:39.180
So, what is I/O Kit?

00:02:39.320 --> 00:02:42.390
There's really three views of I/O Kit.

00:02:42.570 --> 00:02:46.220
To driver developers,
it's a framework that makes it as

00:02:46.310 --> 00:02:47.790
easy as possible to write a driver.

00:02:47.890 --> 00:02:50.470
That's our goal is to make it
as easy as possible to write

00:02:50.470 --> 00:02:51.780
a device driver for Mac OS X.

00:02:51.780 --> 00:02:55.070
And I've got in my definition
here correct Mac OS X drivers.

00:02:55.070 --> 00:02:58.800
We've had to spend a lot of time
thinking about the threading model and

00:02:58.800 --> 00:03:02.720
the memory management because it's very
different under Mac OS X than it was

00:03:02.720 --> 00:03:07.060
under classic Mac OS or even under other
operating systems out there in the world.

00:03:07.060 --> 00:03:10.130
So, what we wanted to do was put as
much of that knowledge into one

00:03:10.130 --> 00:03:13.720
framework as possible so you didn't
have to go and reinvent all of that.

00:03:13.720 --> 00:03:16.780
And that's one of the
fundamental goals of I/O Kit.

00:03:16.780 --> 00:03:21.200
To application developers,
I/O Kit presents an abstraction of

00:03:21.200 --> 00:03:23.790
hardware and a rendezvous mechanism.

00:03:23.810 --> 00:03:26.950
And by rendezvous mechanism,
I mean also arbitration where

00:03:26.960 --> 00:03:31.320
you can have one device being
shared between two applications.

00:03:31.320 --> 00:03:34.560
There's higher level abstraction services
built higher up in the operating system,

00:03:34.680 --> 00:03:37.750
but all of them ultimately boil
down to what I/O Kit allows for

00:03:37.750 --> 00:03:39.360
mutual exclusion of devices.

00:03:41.020 --> 00:03:43.490
And to the OS,
I/O Kit really serves as an

00:03:43.490 --> 00:03:46.280
abstraction of each attached device.

00:03:46.280 --> 00:03:49.000
That's sort of its simplest definition.

00:03:49.000 --> 00:03:54.080
It tries to provide an abstract object
for each device attached to the system.

00:03:56.010 --> 00:03:59.860
Now more from a development perspective,
I/O Kit is a framework and

00:03:59.860 --> 00:04:04.200
a collection of families for
developing Mac OS X drivers.

00:04:04.270 --> 00:04:05.340
Simply put, that's what it is.

00:04:05.340 --> 00:04:08.900
It's a library, but it's a very big
one with a lot of APIs.

00:04:08.900 --> 00:04:12.220
It's delivered on the
Mac OS X developer CD,

00:04:12.220 --> 00:04:16.910
so there's not a separate SDK or
KDK that you have to download if

00:04:16.910 --> 00:04:19.900
you've got the Mac OS X developer CD.

00:04:19.900 --> 00:04:20.900
You have I/O Kit.

00:04:20.920 --> 00:04:25.040
Now we will be occasionally
posting updates to our website,

00:04:25.040 --> 00:04:30.090
but basically go to the CD and you'll
find the developer package there that

00:04:30.090 --> 00:04:32.890
contains all of the APIs and I/O Kit.

00:04:34.380 --> 00:04:37.400
From a runtime perspective,
I/O Kit is part of the Darwin kernel.

00:04:37.410 --> 00:04:40.440
It's compiled into the kernel,
it executes in the kernel address space,

00:04:40.630 --> 00:04:45.280
and all of the APIs that I/O Kit presents
are present in the kernel.framework.

00:04:45.300 --> 00:04:48.260
That is all the in-kernel
APIs are present there.

00:04:48.310 --> 00:04:53.090
The APIs that we present to
application developers are

00:04:53.140 --> 00:04:56.270
present in the I/O Kit framework.

00:04:56.300 --> 00:05:00.640
Now the distinction here is,
as has been said in previous sessions,

00:05:00.640 --> 00:05:03.890
inside the kernel and outside the kernel,
development environments

00:05:03.890 --> 00:05:04.300
are very different.

00:05:04.300 --> 00:05:07.200
There are different APIs,
there are different rules for threading,

00:05:07.200 --> 00:05:10.350
for memory management,
and as a result we have to have

00:05:10.370 --> 00:05:13.140
two separate sets of APIs for that.

00:05:13.690 --> 00:05:18.470
The I/O Kit in kernel implementation
is an object-oriented design based

00:05:18.520 --> 00:05:20.970
on a subset of the C++ language.

00:05:21.030 --> 00:05:26.800
Now, the application level bits are
still object-oriented in nature,

00:05:26.800 --> 00:05:28.100
but they're straight C.

00:05:28.100 --> 00:05:31.310
We don't use C++ for the app-level APIs.

00:05:33.900 --> 00:05:37.900
Now, the question of course comes up,
when do I need to use Iocit and when not?

00:05:37.940 --> 00:05:42.040
Well, if you're developing a driver that
must run inside the Mac OS X kernel,

00:05:42.040 --> 00:05:43.580
and I'll spend a little
more time on that later,

00:05:43.580 --> 00:05:47.060
then you're probably going to be
living inside the Iocit framework.

00:05:47.060 --> 00:05:48.620
You're going to be
making use of Iocit APIs.

00:05:48.620 --> 00:05:52.870
And if you're developing
application that needs to directly

00:05:52.870 --> 00:05:55.870
access devices or drivers,
then you're going to make

00:05:55.870 --> 00:05:59.830
use of Iocit as well,
not necessarily by subclassing from it,

00:05:59.840 --> 00:06:03.380
but by making use of its user-level
APIs to get at the hardware.

00:06:03.380 --> 00:06:07.470
Now, not all drivers in
Mac OS X are Iocit drivers.

00:06:07.480 --> 00:06:08.230
This is important.

00:06:08.240 --> 00:06:13.440
Most of the imaging devices, scanners,
printers, cameras, things like that,

00:06:13.570 --> 00:06:15.640
are not managed inside of Iocit.

00:06:15.660 --> 00:06:17.690
We really only try to put
things in the kernel that need

00:06:17.770 --> 00:06:19.090
to be there for other reasons.

00:06:19.100 --> 00:06:21.820
And I'll dive into some of these
details a little bit later.

00:06:24.660 --> 00:06:28.870
The design goals of I/O Kit are
pretty straightforward.

00:06:28.910 --> 00:06:33.880
It's a very complex task writing a
driver for a system that can run on

00:06:33.990 --> 00:06:36.900
MP and have a preemptive scheduling.

00:06:36.950 --> 00:06:40.420
You have to deal with multiple
address spaces and also ideally

00:06:40.420 --> 00:06:43.000
be architecture neutral,
something that isn't tied to one

00:06:43.000 --> 00:06:46.670
particular platform because as you know,
evolution of platforms tends to

00:06:46.670 --> 00:06:50.520
maybe render some of those design
decisions inappropriate in a few years.

00:06:50.600 --> 00:06:55.920
So we've spent a lot of time
trying to hammer these things out.

00:06:56.010 --> 00:06:57.850
Drivers really focus on mechanism.

00:06:57.880 --> 00:07:01.130
When you write a device driver,
you're focusing entirely on the bits

00:07:01.240 --> 00:07:06.250
of code that are necessary to push
data in and out of a physical device.

00:07:06.330 --> 00:07:08.880
Ideally,
we'd like to keep policy out of drivers.

00:07:08.880 --> 00:07:11.600
The idea is a driver's there
to move data between the

00:07:11.600 --> 00:07:13.190
operating system and a device.

00:07:13.250 --> 00:07:15.680
And you really want policy
user experience issues to

00:07:15.720 --> 00:07:18.480
be driven at a higher level.

00:07:18.530 --> 00:07:20.640
And third-- this is an
important point though.

00:07:20.680 --> 00:07:26.750
Third party developers can extend
Mac OS X and I/O Kit just like Apple can.

00:07:26.830 --> 00:07:31.290
Through the Darwin open source community,
you can download 95% of the source

00:07:31.290 --> 00:07:33.830
code to I/O Kit and its families.

00:07:33.850 --> 00:07:36.090
You can develop new families.

00:07:36.250 --> 00:07:39.180
You can develop drivers
for existing families.

00:07:39.180 --> 00:07:40.300
It's a very flexible model.

00:07:40.300 --> 00:07:43.110
And we don't actually do anything
within Apple that we make it

00:07:43.200 --> 00:07:45.810
impossible for a third party to use.

00:07:48.320 --> 00:07:52.310
Now I/O Kit itself is, as I said, a very,
very large framework and

00:07:52.490 --> 00:07:56.680
it contains a lot of API,
a lot of surface area.

00:07:56.880 --> 00:07:59.660
Well, just for us to be able to
manage it and think about it,

00:07:59.700 --> 00:08:01.200
we had to subdivide it.

00:08:01.200 --> 00:08:05.260
And the way we did this is by dividing it
into families and then within families,

00:08:05.260 --> 00:08:06.440
multiple drivers.

00:08:06.460 --> 00:08:08.930
So I/O Kit, in and of itself,
is just a framework.

00:08:08.930 --> 00:08:11.390
It doesn't have any
intrinsic protocol support.

00:08:11.390 --> 00:08:13.960
SCSI is not part of the
I/O Kit meta-framework.

00:08:13.960 --> 00:08:15.460
It doesn't understand SCSI commands.

00:08:15.460 --> 00:08:19.060
The protocol specifics are
embedded into families.

00:08:19.240 --> 00:08:21.490
The idea here is you would have
a SCSI family that understands

00:08:21.500 --> 00:08:24.300
what it means to be a SCSI device
and a USB family that understands

00:08:24.300 --> 00:08:29.090
what it means to be a USB device.

00:08:29.090 --> 00:08:29.090
Underneath each one of those families,

00:08:29.430 --> 00:08:31.940
The I/O Kit are a collection of drivers,
some of them written by Apple,

00:08:31.940 --> 00:08:36.410
some of them written by third parties,
and all the device specifics

00:08:36.410 --> 00:08:38.320
are embedded in those drivers.

00:08:40.380 --> 00:08:43.700
Now, I-O-Kit families contain
classes that present an

00:08:43.700 --> 00:08:45.330
abstract view of a device type.

00:08:45.360 --> 00:08:49.430
That's basically what it's
trying to say there is a family

00:08:49.430 --> 00:08:53.280
presents the abstraction of
a type of device to the system.

00:08:53.280 --> 00:08:56.180
So if all disk drives
fundamentally look the same,

00:08:56.180 --> 00:08:59.180
the storage family would
present that abstraction,

00:08:59.180 --> 00:09:04.220
and everybody that builds a device driver
underneath that abstraction would inherit

00:09:04.220 --> 00:09:07.790
from it and therefore get sort of the
same appearance to the upper layers.

00:09:08.190 --> 00:09:11.130
In this way,
upper-level services can look and find

00:09:11.410 --> 00:09:13.320
things in I-O-Kit in a common way.

00:09:13.360 --> 00:09:16.210
A device driver from one vendor
doesn't look completely different from

00:09:16.210 --> 00:09:19.960
a device driver from another vendor if
they are for the same type of device.

00:09:19.960 --> 00:09:23.340
Device drivers inherit
the device-independent

00:09:23.390 --> 00:09:26.410
details from the family,
and then as a developer,

00:09:26.410 --> 00:09:28.520
you fill in the device-dependent pieces.

00:09:31.100 --> 00:09:35.560
So just to give you a shopping list
here of some of the common families,

00:09:35.750 --> 00:09:38.610
you can see kind of a naming theme here.

00:09:38.650 --> 00:09:40.240
And there's plenty more.

00:09:40.240 --> 00:09:41.670
This is probably a third of them.

00:09:41.680 --> 00:09:46.510
There's also ADB Family and other
somewhat more esoteric ones that

00:09:46.510 --> 00:09:47.980
you probably won't ever see.

00:09:47.980 --> 00:09:51.600
These are the ones I get most
questions about from developers.

00:09:54.260 --> 00:09:57.140
Now, from an object-oriented
class perspective,

00:09:57.400 --> 00:10:00.100
drivers in the I/O Kit universe
are leaf classes.

00:10:00.100 --> 00:10:05.090
That is, they don't intend to have any
other class inherit from them.

00:10:05.100 --> 00:10:09.270
Now, I/O Kit developers, excuse me,
the I/O Kit engineers at Apple who have

00:10:09.270 --> 00:10:13.260
built I/O Kit have had to write all
their code with the knowledge that you

00:10:13.510 --> 00:10:15.100
people are going to be subclassing them.

00:10:15.100 --> 00:10:18.100
So we've had to put a lot of
attention into the subclass interface.

00:10:18.230 --> 00:10:22.460
Now, that takes a good bit of discipline
and object-oriented experience

00:10:22.460 --> 00:10:26.100
to be able to design a class
that intends to be subclassed.

00:10:26.130 --> 00:10:29.100
So, fortunately, you don't have to bother
with that for drivers.

00:10:29.100 --> 00:10:32.100
Basically, you write,
you inherit from something we've written,

00:10:32.100 --> 00:10:35.550
you write the bits that you need to,
and you don't have to worry about

00:10:35.550 --> 00:10:37.100
third parties inheriting from you.

00:10:37.120 --> 00:10:40.290
Unless you want to,
and that's a whole other presentation.

00:10:40.700 --> 00:10:45.320
Your driver really should focus in on the
requirements of one particular device,

00:10:45.390 --> 00:10:48.660
or possibly a collection of
devices that are very similar.

00:10:50.960 --> 00:10:53.820
Now there's a data
structure that's in I/O Kit,

00:10:53.880 --> 00:10:56.480
it actually exists in
the kernel address space,

00:10:56.480 --> 00:10:57.800
called the I/O Registry.

00:10:57.800 --> 00:11:02.460
And it's important to understand that
the I/O Registry is not something

00:11:02.460 --> 00:11:03.750
that's brought in from a file.

00:11:03.870 --> 00:11:05.800
It's never archived on disk.

00:11:05.800 --> 00:11:10.800
It is literally the network of
active I/O Kit objects in the system.

00:11:10.800 --> 00:11:13.730
And it's roughly a tree structure.

00:11:13.800 --> 00:11:16.670
I say roughly, if you browse it through
any of our tools,

00:11:16.810 --> 00:11:20.800
like I/O Registry Explorer or I/O Reg,
it will appear as a tree structure.

00:11:20.800 --> 00:11:25.800
It is actually possible to
have one node have two parents.

00:11:25.800 --> 00:11:30.480
This is done for fan-in devices,
like a soft RAID might choose

00:11:30.480 --> 00:11:31.800
to use that for implementation.

00:11:31.800 --> 00:11:36.790
So the technical term,
I believe it's a directed acyclic graph,

00:11:36.910 --> 00:11:39.630
but basically a tree structure.

00:11:40.350 --> 00:11:42.970
Now what it does is it tracks
all of the relationships

00:11:42.980 --> 00:11:44.170
between the various objects.

00:11:44.270 --> 00:11:46.700
As I said,
the nodes in this graph are the actual

00:11:46.700 --> 00:11:50.300
objects that make up your drivers
and the other family components.

00:11:50.390 --> 00:11:52.300
And so there are links between them.

00:11:52.490 --> 00:11:54.300
There are planes within the I/O registry.

00:11:54.300 --> 00:11:57.890
There's a service plane,
which is the one you'll hear about 99% of

00:11:57.890 --> 00:12:00.280
the time when you're looking at I/O Kit.

00:12:00.410 --> 00:12:03.770
The service plane basically says,
"This object depends on this other

00:12:03.840 --> 00:12:07.300
object for some service." And the service
is usually named by the class name.

00:12:07.390 --> 00:12:11.290
So I/O PCI device provides a
service to some other driver,

00:12:11.290 --> 00:12:15.290
and the service it provides is
access to an I/O PCI device.

00:12:15.290 --> 00:12:19.590
I/O Kit tries to mimic the
physical world wherever possible.

00:12:23.200 --> 00:12:27.960
Also built into I/O Kit is
the basis for driver matching.

00:12:28.010 --> 00:12:31.800
Now, each family can override this
and can change the behavior.

00:12:31.800 --> 00:12:36.270
So the example I'm about to walk
through is going to be true,

00:12:36.330 --> 00:12:39.720
99% true, for every driver that you see,
but there's always going to

00:12:39.720 --> 00:12:40.540
be some slight variation.

00:12:40.540 --> 00:12:43.660
So you have to check with the header
files for your family and documentation

00:12:44.090 --> 00:12:46.940
that's available for whatever family
you're in to understand how the

00:12:46.970 --> 00:12:48.690
matching will be different for you.

00:12:49.480 --> 00:12:53.590
It's basically four stages,
and I'll walk through those

00:12:53.610 --> 00:12:55.190
in four future slides.

00:12:55.190 --> 00:12:59.790
But it's fundamentally a score system.

00:12:59.800 --> 00:13:03.240
So effectively you've got some set
of drivers identified as appropriate.

00:13:03.240 --> 00:13:06.190
We use scores to try to
figure out which one is best.

00:13:06.190 --> 00:13:08.420
It's very powerful and flexible.

00:13:08.420 --> 00:13:12.600
There's quite a lot that you
can do to change the way that

00:13:12.600 --> 00:13:15.000
matching occurs as needed.

00:13:15.300 --> 00:13:16.660
So step one, device discovery.

00:13:16.660 --> 00:13:20.030
This is really sort of
before the matching begins.

00:13:20.040 --> 00:13:25.990
But during boot,
or when a dynamic bus has been rescanned,

00:13:25.990 --> 00:13:27.700
we notice a new piece of hardware.

00:13:27.700 --> 00:13:32.430
In this case, I've written it up as a
PCI device discovered during boot.

00:13:32.430 --> 00:13:36.950
Well, the host controller driver
is going to create a nub,

00:13:36.950 --> 00:13:38.760
an IOPCI device nub.

00:13:39.080 --> 00:13:43.590
That's a term we kind of invented that
represents that piece of hardware.

00:13:43.590 --> 00:13:45.860
If there's five
PCI devices in the system,

00:13:45.860 --> 00:13:48.680
you'll have five separate
IOPCI device nubs,

00:13:48.680 --> 00:13:50.460
one that represents
each piece of hardware.

00:13:50.500 --> 00:13:53.920
And that nub will register
itself for matching.

00:13:53.920 --> 00:13:56.730
This is how matching gets kicked off.

00:13:58.920 --> 00:14:01.260
So in step two,
it's called class matching.

00:14:01.260 --> 00:14:04.140
This is something that's done
basically in I/O Kit innards.

00:14:04.140 --> 00:14:07.600
It's not something that the
family typically alters.

00:14:07.700 --> 00:14:12.310
Basically, I/O Kit starts with a list of
all drivers known to the system.

00:14:12.310 --> 00:14:15.050
Everything that's been
installed that we're aware of.

00:14:15.400 --> 00:16:13.300
[Transcript missing]

00:16:14.110 --> 00:16:17.460
At the end of this,
probe scores may have been adjusted.

00:16:17.460 --> 00:16:19.200
Now,
the device driver itself is not going

00:16:19.200 --> 00:16:21.460
to have adjusted its probe score,
but the family may have.

00:16:21.490 --> 00:16:23.850
The family at this point has got
a little more information than

00:16:23.850 --> 00:16:24.980
it did in the previous step.

00:16:25.030 --> 00:16:29.930
So it may have decided to promote
or move down in priority some driver

00:16:30.100 --> 00:16:32.500
based on family-specific criteria.

00:16:32.580 --> 00:16:39.300
I know that the USB family implements
the USB matching specification,

00:16:39.300 --> 00:16:40.460
and it does, in fact,
affect the probe score.

00:16:41.020 --> 00:16:44.140
So again, we have a list sorted by
score at the end of the step.

00:16:44.360 --> 00:16:47.010
Ideally, we're down to one driver.

00:16:47.100 --> 00:16:56.100
[Transcript missing]

00:16:56.320 --> 00:16:59.050
So each of the remaining
drivers is loaded and probed.

00:16:59.050 --> 00:17:02.920
And effectively,
they're given the opportunity in C or C++

00:17:02.920 --> 00:17:06.960
code to be able to talk to the device,
find out if it is

00:17:06.960 --> 00:17:10.450
appropriate for them or not,
adjust their own probe score, and return.

00:17:10.660 --> 00:17:13.650
They can say, this device is not
appropriate for me at all.

00:17:13.750 --> 00:17:16.600
Or they can say, it is appropriate,
but I want to raise my probe score or

00:17:16.600 --> 00:17:20.200
lower my probe score because I discovered
something about it that affects that.

00:17:20.200 --> 00:17:24.480
It's pretty rare that you would do that,
but as I said, this is pretty flexible.

00:17:24.920 --> 00:17:27.980
Now all the drivers that failed their
probe are unloaded at this point,

00:17:27.980 --> 00:17:29.850
they're clearly not of interest.

00:17:29.860 --> 00:17:36.030
But the remaining drivers are started,
starting with the highest probe score,

00:17:36.150 --> 00:17:40.040
and marching down the list until
one of them successfully starts.

00:17:40.040 --> 00:17:43.450
In general if you've passed
your probe you will successfully

00:17:43.500 --> 00:17:46.450
pass your start as well,
so it's generally the very first

00:17:46.450 --> 00:17:48.040
driver on the list at this point.

00:17:48.210 --> 00:17:51.470
But it is possible that you discover
something during start that causes

00:17:51.470 --> 00:17:53.040
you to bail on this hardware.

00:17:53.040 --> 00:17:56.790
And at that point,
we have a winning driver.

00:17:57.060 --> 00:18:00.980
We have a notion of match categories
that you might have noticed in

00:18:00.980 --> 00:18:04.980
some I/O Kit documentation in the
tutorials or some other places.

00:18:05.030 --> 00:18:06.520
In general, you won't need to use that.

00:18:06.560 --> 00:18:09.460
I bring this up only because I've
had a number of questions about it.

00:18:09.490 --> 00:18:13.570
The idea there was there
may be multiple drivers

00:18:14.410 --> 00:18:17.160
could usefully be attached to
one device at any given time.

00:18:17.160 --> 00:18:21.890
And the idea here is you could have one
piece of hardware that maybe is bimodal.

00:18:21.900 --> 00:18:26.000
It can operate as a tape drive,
or it can operate as a floor buffer,

00:18:26.000 --> 00:18:26.770
whatever.

00:18:26.780 --> 00:18:29.720
And effectively,
you can have the floor buffer

00:18:29.720 --> 00:18:32.820
driver be in one category,
and it can win for that category.

00:18:32.820 --> 00:18:35.610
And you can have the tape drive
driver be in a different category

00:18:35.610 --> 00:18:36.800
and win for that category.

00:18:36.800 --> 00:18:39.720
And you can only typically
have one driver actually

00:18:40.050 --> 00:18:42.780
accessing the device at a time,
so you'd have to go through

00:18:43.020 --> 00:18:45.710
open-close to be able to actually
acquire the device and use it.

00:18:45.760 --> 00:18:49.940
But that allows you to have
multifunction hardware share drivers.

00:18:49.960 --> 00:18:52.660
So if you need to do something like that,
if you have a really interesting

00:18:52.660 --> 00:18:56.320
multifunction device,
this may be one technique you can use.

00:18:56.320 --> 00:19:01.040
So this matching process, by the way,
is repeated independently

00:19:01.040 --> 00:19:02.380
for each match category.

00:19:02.380 --> 00:19:03.570
Thank you.

00:19:07.650 --> 00:19:10.890
Now, developing inside the
kernel is a bit of an art.

00:19:10.900 --> 00:19:14.600
It's not something that we encourage
all of our developers to do.

00:19:14.600 --> 00:19:17.940
Obviously, we want the kernel to
be as lean as possible,

00:19:18.010 --> 00:19:20.590
but it's also something that
isn't necessary in a lot of cases.

00:19:20.650 --> 00:19:23.600
We'll talk a little bit about what it
means to develop inside the kernel.

00:19:23.810 --> 00:19:26.600
For now,
you have to use Apple-provided tools.

00:19:26.600 --> 00:19:30.160
If you wanted to use Code Warrior or
some other tool for that,

00:19:30.300 --> 00:19:34.600
you'll have to contact the provider
of that tool and ask for that support.

00:19:34.600 --> 00:19:37.810
Apple is willing to work with other
tool vendors to show them what's

00:19:37.850 --> 00:19:42.600
needed to develop in this space,
but presently, you have to use our tools.

00:19:42.790 --> 00:19:45.540
When you want to do debugging,
you need to use a two-machine debugger.

00:19:45.730 --> 00:19:49.300
We have a debug
environment that uses GDB,

00:19:49.300 --> 00:19:52.960
and it uses two machines
connected over Ethernet.

00:19:52.960 --> 00:19:54.400
It's a very powerful environment.

00:19:54.490 --> 00:19:57.070
There's a lot you can do with it,
but it's probably different,

00:19:57.100 --> 00:19:59.040
unless you've already used GDB,
it's probably different than

00:19:59.040 --> 00:20:00.160
anything you're used to.

00:20:00.160 --> 00:20:02.170
So there's going to be
a learning curve there.

00:20:02.170 --> 00:20:05.030
Once you've learned it,
I think you'll find it very powerful.

00:20:05.560 --> 00:20:08.830
The fact that you can download
source code from Darwin means that

00:20:08.830 --> 00:20:14.710
you can actually do source code
level debugging within the kernel.

00:20:15.260 --> 00:20:18.250
Now,
we have restricted language features.

00:20:18.310 --> 00:20:21.900
Specifically, a lot of the libraries,
the standard POSIX libraries that

00:20:21.900 --> 00:20:25.090
Unix programmers are used to using,
aren't available in the kernel.

00:20:25.100 --> 00:20:31.220
Basically, it's a mini environment,
so to speak.

00:20:31.770 --> 00:20:33.980
We would encourage you to go and
look at the headers in the kernel

00:20:33.980 --> 00:20:36.030
framework to see what's available.

00:20:36.030 --> 00:20:38.450
There's also a tool called NM,
which will tell you all the symbols.

00:20:38.460 --> 00:20:41.290
So if you're a Unix developer,
there's some symbol you're used

00:20:41.290 --> 00:20:43.460
to using and you just want to
find out if it's in the kernel,

00:20:43.550 --> 00:20:44.900
it's a very easy way to find out.

00:20:44.910 --> 00:20:48.780
Run an NM on the kernel
and find out if it's there.

00:20:49.740 --> 00:20:54.000
Also, if you're developing an I/O Kit,
you're going to be using C++.

00:20:54.060 --> 00:20:57.600
C++ is available for other types
of kernel extensions as well,

00:20:57.610 --> 00:21:00.600
but it's pretty much required
for I/O Kit kernel extensions.

00:21:00.600 --> 00:21:04.600
We don't support a full-blown
C++ implementation.

00:21:04.760 --> 00:21:10.370
Our initial port of I/O Kit C++
was based on a movement called

00:21:10.370 --> 00:21:15.330
Embedded C++ from a few years ago,
and we're going to be evolving

00:21:15.330 --> 00:21:16.600
what that means to us.

00:21:16.600 --> 00:21:19.890
Basically,
some of the higher-level features

00:21:19.920 --> 00:21:23.600
like multiple inheritance,
exceptions, RTTI,

00:21:23.600 --> 00:21:25.530
these things are not available.

00:21:25.600 --> 00:21:30.590
Also, you really need to use our
constructor metaclasses.

00:21:30.590 --> 00:21:33.220
We have our own replacement
for RTTI that's used to

00:21:33.220 --> 00:21:36.600
maintain reference counting and
automatically unload drivers.

00:21:36.600 --> 00:21:39.600
It keeps track of a lot
of very important things.

00:21:39.600 --> 00:21:42.880
If you're writing a driver and
you're making use of objects that

00:21:42.890 --> 00:21:44.780
derive from the OSObject class,
which is the root of all I/O Kit objects,

00:21:44.780 --> 00:21:45.070
you can use the OSObject class
to make use of the objects that

00:21:45.070 --> 00:21:45.600
derive from the OSObject class,
which is the root of all I/O Kit objects.

00:21:45.600 --> 00:21:48.580
If you're writing a driver and
you're making use of objects that

00:21:48.600 --> 00:21:51.550
derive from the OSObject class,
you can use the OSObject class

00:21:51.550 --> 00:21:54.600
to make use of objects that
derive from the OSObject class.

00:21:54.600 --> 00:21:58.250
I know this has not been well documented,
and we're working on improving that,

00:21:58.250 --> 00:21:59.600
but it is very important.

00:22:00.010 --> 00:22:01.790
Otherwise,
you're going to get into situations

00:22:01.790 --> 00:22:04.960
that can cause panics and other
crashes because we may decide

00:22:04.960 --> 00:22:07.280
to unload your driver because
there's no references of it.

00:22:07.320 --> 00:22:11.610
Well, there are references of it,
but our runtime system doesn't know that.

00:22:13.790 --> 00:22:16.190
There's very limited user
interaction inside the kernel.

00:22:16.220 --> 00:22:19.900
You can't just communicate
with an app directly.

00:22:19.900 --> 00:22:22.260
You have to set up
explicit communications.

00:22:22.370 --> 00:22:24.390
Now we do have some basic facilities.

00:22:24.390 --> 00:22:27.890
We have this kernel user
notification center that allows

00:22:27.890 --> 00:22:31.300
you to pop up simple panels,
that allows you to possibly launch an

00:22:31.300 --> 00:22:33.300
application if you needed to have a GUI.

00:22:33.320 --> 00:22:36.090
But the code that actually
does that is not in the kernel.

00:22:36.170 --> 00:22:39.840
The code that would display on the
screen is outside of the kernel.

00:22:39.940 --> 00:22:42.640
So you can have your internal
component cooperate with

00:22:42.720 --> 00:22:46.500
something out in user space,
but you can't directly talk

00:22:46.500 --> 00:22:51.070
to Carbon APIs or toolbox
APIs or anything like that.

00:22:52.140 --> 00:22:54.900
Inside the kernel,
resources are much more costly

00:22:54.900 --> 00:22:55.930
than they are in user land.

00:22:55.940 --> 00:23:00.930
Now, the reason this is so is because
kernel memory is typically wired.

00:23:00.940 --> 00:23:03.090
If you allocate memory in the kernel,
unless you go out of

00:23:03.090 --> 00:23:05.330
your way to unwire it,
and that's tricky to do,

00:23:05.330 --> 00:23:06.620
that memory is wired.

00:23:06.620 --> 00:23:09.560
Now, that means that that memory
is permanently unavailable

00:23:09.560 --> 00:23:13.440
for other applications,
other components in the system to use.

00:23:13.440 --> 00:23:18.630
If that same amount of memory is
being used by some task in user space,

00:23:19.640 --> 00:23:22.740
when that task is not active,
those pages will page out,

00:23:22.750 --> 00:23:26.540
and that physical memory will become
available for some other entity to use.

00:23:28.570 --> 00:23:30.480
So basically,
you don't want to develop inside

00:23:30.510 --> 00:23:32.090
the kernel unless you have to.

00:23:32.100 --> 00:23:34.390
I think that's probably been made clear.

00:23:34.500 --> 00:23:37.190
The last important reason
is failures are fatal.

00:23:37.370 --> 00:23:41.660
We want Mac OS X to be the most
stable operating system on the planet.

00:23:41.720 --> 00:23:45.260
And obviously,
you want to try to contain failures.

00:23:45.260 --> 00:23:48.000
If an application crashes,
we want the application to crash

00:23:48.000 --> 00:23:49.780
and not affect anything else.

00:23:49.780 --> 00:23:52.440
If you've got something inside
the kernel and it crashes,

00:23:52.440 --> 00:23:54.240
it's going to probably
bring the whole system down,

00:23:54.240 --> 00:23:55.560
depending on the nature of the failure.

00:23:55.600 --> 00:23:57.780
But basically,
if you crash inside the kernel,

00:23:57.810 --> 00:23:59.790
You've crashed the system.

00:24:02.100 --> 00:24:04.210
That being said,
if you've decided to forge ahead

00:24:04.210 --> 00:24:07.100
and write code inside the kernel,
here's how you do it.

00:24:07.100 --> 00:24:09.090
You're going to have to
write a kernel extension,

00:24:09.290 --> 00:24:15.090
which is basically a package for binary
code to be delivered into the kernel.

00:24:15.100 --> 00:24:19.590
Now, you can write a kernel extension
that doesn't exist inside one of

00:24:19.590 --> 00:24:23.430
the three well-defined frameworks,
but it's not really going to do very

00:24:23.430 --> 00:24:25.090
much because nobody's going to call it.

00:24:25.100 --> 00:24:29.490
So, you really are going to be looking
at one of these three universes:

00:24:29.490 --> 00:24:32.980
the I/O Kit universe,
the kernel network extensions,

00:24:32.980 --> 00:24:35.090
NKE universe, or file system plug-ins.

00:24:35.100 --> 00:24:37.820
The three of them use
fairly different APIs,

00:24:37.820 --> 00:24:41.100
so I can't go into any
specifics for the latter two.

00:24:41.100 --> 00:24:43.810
But basically,
the idea is the kernel extensions

00:24:43.820 --> 00:24:47.260
are there to deliver binary code
into one of these universes,

00:24:47.260 --> 00:24:52.400
and then the APIs that are appropriate
in that space take over from there.

00:24:53.000 --> 00:24:57.030
An extension in classic
Mac OS is not necessarily a

00:24:57.030 --> 00:24:59.570
kernel extension on Mac OS X.

00:24:59.600 --> 00:25:04.190
If you've delivered functionality
in the past using an extension,

00:25:04.200 --> 00:25:06.640
it may not be appropriate
to do that on X.

00:25:06.640 --> 00:25:11.000
You need to stop and think about the
best way to package your functionality.

00:25:11.120 --> 00:25:14.560
So get inside the kernel
only if you have to.

00:25:16.110 --> 00:25:18.790
So a kernel extension is the
way to get into the kernel.

00:25:18.800 --> 00:25:21.440
If you want to do something a
little bit more interesting,

00:25:21.610 --> 00:25:25.000
kernel extensions can also serve as
libraries to other kernel extensions.

00:25:25.000 --> 00:25:28.400
It's a relatively straightforward
layering mechanism.

00:25:28.510 --> 00:25:32.320
So let's say that you're writing a
family of drivers for your company

00:25:32.430 --> 00:25:34.690
that share a common service library.

00:25:34.770 --> 00:25:38.890
So you've got a USB version of something
and a FireWire version of something,

00:25:38.890 --> 00:25:42.140
and 90% of the code is the same,
but you need to have some

00:25:42.140 --> 00:25:43.930
bus-specific code as well.

00:25:43.990 --> 00:25:48.840
You can write a library, effectively,
that contains that 90% common code.

00:25:48.910 --> 00:25:52.120
And then you can write a kernel
extension that depends on that

00:25:52.120 --> 00:25:54.440
library for the bus-specific details.

00:25:54.500 --> 00:25:57.140
And when you've done that,
you've basically just written a family.

00:25:57.150 --> 00:25:58.370
That's the way families work.

00:25:58.420 --> 00:26:03.290
They're just a library that has
leaf classes plugged into it.

00:26:03.590 --> 00:26:05.520
So how do you actually go
about writing a library?

00:26:05.600 --> 00:26:09.100
There's really only a couple things
you have to do that are unique.

00:26:09.240 --> 00:26:12.360
First off, you have to identify yourself
by a CFBundle identifier

00:26:12.480 --> 00:26:14.000
and a CFBundle version.

00:26:14.000 --> 00:26:16.810
These are properties in the PList.

00:26:17.000 --> 00:26:18.180
Not too onerous,
you have to do this whether

00:26:18.300 --> 00:26:21.290
you're writing a library or not,
all kernel extensions have that.

00:26:21.290 --> 00:26:25.660
But you indicate that you are a,
I didn't put it on the slide,

00:26:25.660 --> 00:26:29.660
you indicate that you're a
library by expressing the

00:26:29.660 --> 00:26:34.830
OS bundle compatible version,
which basically says this is the oldest

00:26:34.830 --> 00:26:36.900
version to which I'm binary compatible.

00:26:36.900 --> 00:26:41.400
And that is the clue to the system that,
aha, this is a library and somebody

00:26:41.400 --> 00:26:43.380
can try to link against this.

00:26:44.790 --> 00:26:48.020
Somebody wanting to make use of
a library indicates this through

00:26:48.030 --> 00:26:49.740
the OS Bundle Libraries property.

00:26:49.840 --> 00:26:53.870
Basically,
you list all the libraries on which you

00:26:53.870 --> 00:26:56.430
depend when you write a kernel extension.

00:26:57.310 --> 00:26:59.150
Here's a list of some of them.

00:26:59.240 --> 00:27:00.790
The list is very long.

00:27:00.880 --> 00:27:06.130
The first five on this list are
components of the kernel itself.

00:27:06.180 --> 00:27:09.460
You could say I depend on
com.apple.kernel and pick a version

00:27:09.460 --> 00:27:11.210
number based on one that we've shipped.

00:27:11.250 --> 00:27:15.180
And that basically means you're dependent
on some version of the whole kernel.

00:27:15.360 --> 00:27:17.760
Most of you won't need to do that
because you're only going to be

00:27:17.760 --> 00:27:23.730
including API from I/O Kit and
maybe from Mach and Libkern as well.

00:27:23.780 --> 00:27:29.760
But basically we've subdivided
the kernel into four other pieces:

00:27:29.760 --> 00:27:32.740
Mach, BSD, I/O Kit, and Libkern.

00:27:32.800 --> 00:27:35.630
And you need to list these explicitly
in your kernel extension when

00:27:35.630 --> 00:27:37.540
you're writing an I/O Kit driver.

00:27:37.580 --> 00:27:43.060
We recommend that I/O Kit drivers list
com.apple.kernel I/O Kit as a dependency,

00:27:43.110 --> 00:27:46.960
as well as libkern because that's
where all the OS objects are defined,

00:27:47.030 --> 00:27:51.080
and Mach because you're going to
be using primitives from Mach for

00:27:51.080 --> 00:27:53.100
return codes and things like that.

00:27:53.130 --> 00:27:55.680
You're also going to want to
list the specific family on which

00:27:55.680 --> 00:27:58.740
you depend if you are writing a
driver that depends on a family,

00:27:58.750 --> 00:28:00.210
which most of you will be.

00:28:00.220 --> 00:28:03.160
So for example,
if you're writing a driver

00:28:03.160 --> 00:28:07.510
for a USB controller card
that sits on a PCI bus,

00:28:07.570 --> 00:28:10.520
you would need to include the
PCI family and the USB family.

00:28:10.520 --> 00:28:12.320
They're the two families
that you depend on.

00:28:16.090 --> 00:28:21.180
So now to actually talk about
kernel extensions and how

00:28:21.180 --> 00:28:24.610
they exist on the file system,
we've got a series of slides

00:28:24.610 --> 00:28:25.680
here that explodes it.

00:28:25.720 --> 00:28:28.860
If you look at this,
this is a directory hierarchy.

00:28:28.880 --> 00:28:31.040
And you'll see that there's
only two files in here.

00:28:31.040 --> 00:28:33.180
The rest of it's all structure.

00:28:33.180 --> 00:28:36.350
We basically chose to mirror
the application bundle format,

00:28:36.430 --> 00:28:39.540
because all of our tools
are there to deal with it.

00:28:39.540 --> 00:28:41.420
Finder already knows
how to deal with these,

00:28:41.420 --> 00:28:42.920
and they have some nice
features about them.

00:28:43.010 --> 00:28:45.010
It's probably a little bit
more than strictly necessary

00:28:45.090 --> 00:28:49.000
for delivering drivers,
but it doesn't really cost anything.

00:28:49.090 --> 00:28:53.190
So there are really two files in a
typical kernel extension that are

00:28:53.190 --> 00:28:55.000
going to be interesting to you.

00:28:55.100 --> 00:28:57.340
The first one is this Info.plist.

00:28:57.450 --> 00:29:02.720
Every bundle of any description on
Mac OS X has one of these files.

00:29:02.730 --> 00:29:05.850
And basically, it is the--

00:29:05.820 --> 00:29:08.580
The I/O Kit is a table of
contents for the kernel extension.

00:29:08.580 --> 00:29:11.900
It provides information on what it is,
why it would need to be loaded.

00:29:11.900 --> 00:29:15.710
This is where the I/O Kit personalities
with the matching information goes.

00:29:15.790 --> 00:29:20.420
I've listed four basic properties
here that are pretty much going to

00:29:20.420 --> 00:29:23.200
be necessary for all I/O Kit drivers.

00:29:23.200 --> 00:29:25.200
The first is the C/F Bundle Identifier.

00:29:25.200 --> 00:29:27.200
The C/F Bundle Identifier
identifies your driver.

00:29:27.320 --> 00:29:31.950
We've gone with a reverse
DNS namespace because this doesn't

00:29:31.960 --> 00:29:35.180
really require Apple to put some kind
of a program together and police it.

00:29:35.780 --> 00:29:38.350
Basically,
if you can sign up for a domain name,

00:29:38.350 --> 00:29:40.200
put it in reverse order.

00:29:40.200 --> 00:29:42.870
For Apple,
we ship drivers and other components

00:29:42.950 --> 00:29:45.200
under the name com.apple.whatever.

00:29:45.380 --> 00:29:48.530
Obviously, unless you work for Apple,
you shouldn't be doing that.

00:29:48.530 --> 00:29:51.200
You should be providing
your own company name there.

00:29:51.200 --> 00:29:51.570
Once you get within
your company database,

00:29:51.570 --> 00:29:52.200
you can use the C/F Bundle
Identifier to identify your driver.

00:29:52.200 --> 00:29:54.700
The other thing that's important
is that within your company domain,

00:29:54.810 --> 00:29:57.200
you can decide whatever namespace
within that that you want.

00:29:57.200 --> 00:29:58.730
It's actually pretty flexible.

00:29:58.810 --> 00:30:01.190
It tends to be a little verbose,
but that's okay.

00:30:01.200 --> 00:30:05.020
This information is usually only thrown
around when we're loading drivers.

00:30:05.020 --> 00:30:08.390
Once they're loaded,
it's just sitting around as information.

00:30:08.600 --> 00:30:10.740
Your CFBundle version is
also going to be important.

00:30:10.740 --> 00:30:14.310
Our version checking code makes use
of this to know that it's getting the

00:30:14.310 --> 00:30:15.490
latest and greatest piece of software.

00:30:15.520 --> 00:30:21.500
So right now the format is specified
as a classic Mac OS Verse resource,

00:30:21.500 --> 00:30:23.500
something you're probably
familiar with already.

00:30:23.500 --> 00:30:27.310
OS bundle libraries,
this is where you list all of the

00:30:27.310 --> 00:30:29.780
libraries on which you depend.

00:30:29.790 --> 00:30:35.500
So com.apple I/O Kit.whateverfamily,
all the libraries that you care about.

00:30:35.500 --> 00:30:40.300
It's very important to understand
that Mac OS X as it's shipped so far

00:30:40.300 --> 00:30:43.500
doesn't enforce all of these properties.

00:30:43.500 --> 00:30:46.480
It makes note of them and it
does its best to use them,

00:30:46.510 --> 00:30:50.630
but we didn't have time to get all
of our drivers into compliance,

00:30:50.630 --> 00:30:53.490
so we have to allow them
to be a little bit fuzzy.

00:30:53.560 --> 00:30:57.750
Future releases of the Mac OS X operating
system are going to require that these

00:30:57.960 --> 00:31:00.350
be in order or your driver will not load.

00:31:00.500 --> 00:31:03.550
So for example,
if you don't have a CFBundle identifier,

00:31:03.550 --> 00:31:04.500
it won't load.

00:31:04.500 --> 00:31:05.500
I don't think it would load.

00:31:05.500 --> 00:31:07.490
It wouldn't load today actually
because that's key to a lot of things.

00:31:07.500 --> 00:31:10.500
If you don't have a bundle version,
it won't load.

00:31:10.530 --> 00:31:13.500
If you don't list any bundle libraries,
it won't load.

00:31:13.500 --> 00:31:15.930
Because by definition,
if all you're doing is

00:31:16.040 --> 00:31:19.500
calling into the kernel,
the kernel is acting as your library.

00:31:19.500 --> 00:31:22.500
You have to list at least
one thing as a dependency.

00:31:22.500 --> 00:31:25.500
Otherwise your kernel extension
could not call any API.

00:31:25.550 --> 00:31:28.770
And if nobody's calling you
and you're not calling anybody,

00:31:28.770 --> 00:31:31.180
it's kind of a useless kernel extension.

00:31:31.560 --> 00:31:33.710
And the fourth property here,
I/O Kit personalities,

00:31:33.830 --> 00:31:36.050
this is the only one
that's I/O Kit specific.

00:31:36.100 --> 00:31:40.500
This is where you would list all of
the personalities of your driver.

00:31:40.580 --> 00:31:41.500
This is a little subtle.

00:31:41.500 --> 00:31:44.420
By and large, your drivers will have
a single personality.

00:31:44.580 --> 00:31:48.980
That is, one set of matching criteria,
a few properties to help your driver

00:31:48.980 --> 00:31:50.500
get oriented when it gets loaded.

00:31:50.500 --> 00:31:53.440
But you could also have
multiple personalities.

00:31:53.480 --> 00:31:56.250
You could have, say,
two PCI cards that you ship that

00:31:56.250 --> 00:32:00.560
are similar but slightly different,
and they need different match criteria.

00:32:00.560 --> 00:32:04.050
Well, one driver could drive them,
but you could list two personalities,

00:32:04.050 --> 00:32:05.490
one for each of those flavors.

00:32:05.490 --> 00:32:08.390
It's very powerful.

00:32:08.610 --> 00:32:09.490
We use this ourselves.

00:32:09.500 --> 00:32:12.620
We have several
multi-personality drivers.

00:32:12.620 --> 00:32:16.390
As a very useful resource,
go into the extensions folder on 10

00:32:16.390 --> 00:32:18.710
and poke around and see what's there.

00:32:18.710 --> 00:32:22.530
Though I will warn you, as I said,
not all of our drivers are in spec.

00:32:22.620 --> 00:32:25.590
So we'll also look at the log
that comes out and see all

00:32:25.700 --> 00:32:27.610
the warnings that get posted.

00:32:27.620 --> 00:32:29.620
The warnings are on our drivers as well.

00:32:29.620 --> 00:32:31.400
well.

00:32:32.000 --> 00:32:36.560
The next file that's important here is
the binary that the KEXT is delivering.

00:32:36.660 --> 00:32:38.870
In this case I've
exploded the USB family,

00:32:39.220 --> 00:32:43.410
but this is the actual binary file.

00:32:44.780 --> 00:32:48.700
First and foremost, it's optional,
which may seem a little bit odd.

00:32:48.700 --> 00:32:50.570
The kernel extension is a
way to deliver binaries.

00:32:50.660 --> 00:32:52.710
What does it mean to have it be optional?

00:32:52.800 --> 00:32:56.960
We have a notion of a driverless
driver that is used occasionally,

00:32:57.040 --> 00:32:59.440
and this is where personalities come in.

00:32:59.500 --> 00:33:02.630
You're in your personality,
your I/O Kit personality,

00:33:02.680 --> 00:33:07.420
you will specify the class,
the basic class for your driver,

00:33:07.430 --> 00:33:10.640
and you'll also specify the
CFBundle identifier for the kernel

00:33:10.640 --> 00:33:14.190
extension that contains the binary code.

00:33:14.260 --> 00:33:18.350
You could write a driver that
depends on some other driver,

00:33:18.350 --> 00:33:21.920
and actually just instantiates
its classes directly.

00:33:21.980 --> 00:33:23.650
There are a few cases
where this is useful.

00:33:23.750 --> 00:33:27.100
Basically, you would put in some new
property in the personality.

00:33:27.180 --> 00:33:30.200
Maybe it's as simple as
changing the probe score.

00:33:30.200 --> 00:33:33.060
I want to use this driver over here,
but I want to make it

00:33:33.060 --> 00:33:37.040
slightly different matching,
and I want to have a higher probe score.

00:33:37.050 --> 00:33:39.130
Okay, enough said about that.

00:33:39.140 --> 00:33:42.160
If you do have a binary there,
it's going to be in the MacO format,

00:33:42.200 --> 00:33:43.700
which is the only format
the kernel will load.

00:33:43.700 --> 00:33:48.530
Please run strip-x on
it before shipping it.

00:33:48.700 --> 00:33:51.200
I've looked at some of the
drivers that have been posted.

00:33:51.200 --> 00:33:52.450
Obviously, I'm interested.

00:33:52.520 --> 00:33:54.920
Some developers have
forgotten to run this,

00:33:54.920 --> 00:33:58.080
and it means that their
download size is about 10 times

00:33:58.080 --> 00:33:59.700
larger than it needs to be.

00:33:59.710 --> 00:34:03.480
They're giving away all
their debugging symbols.

00:34:04.150 --> 00:34:06.030
It doesn't affect the runtime at all.

00:34:06.190 --> 00:34:07.950
We only load the important
pieces into the kernel.

00:34:08.040 --> 00:34:14.590
But if you want to have faster downloads,
strip-x is a good thing to do.

00:34:16.950 --> 00:34:23.020
Okay, last is this plugins folder inside
the kernel extension contents.

00:34:23.020 --> 00:34:24.900
And this is kind of neat.

00:34:24.950 --> 00:34:26.200
Again, it's optional.

00:34:26.200 --> 00:34:29.540
If you have a plugins folder,
it gives you a place to deliver

00:34:29.540 --> 00:34:31.680
other kernel extensions.

00:34:32.160 --> 00:34:35.430
The reason you'd want to do this is
for the drag and drop functionality.

00:34:35.430 --> 00:34:39.860
Let's say you've got a family, well,
family collection of three or four

00:34:39.860 --> 00:34:43.810
drivers that you always want to move
around together as a collection.

00:34:44.060 --> 00:34:48.050
What you can do is pick one that is
sort of the definitive KEXT and then

00:34:48.170 --> 00:34:51.760
put all of the other pieces as subkexts,
as we call them,

00:34:51.760 --> 00:34:54.000
inside the plugin folder.

00:34:54.020 --> 00:34:58.290
The advantage there is to the user,
it appears to be one kernel extension.

00:34:58.380 --> 00:35:02.360
To our loading system, however,
we consider every kernel extension equal,

00:35:02.450 --> 00:35:06.130
so we don't care whether it's
embedded or at the top level.

00:35:06.190 --> 00:35:07.250
That's actually important to note.

00:35:07.300 --> 00:35:10.590
The fact that it's embedded
doesn't mean anything at all.

00:35:10.600 --> 00:35:13.180
It's just a way to deliver it.

00:35:14.460 --> 00:35:17.630
Now, the Plugins folder can
contain other texts.

00:35:17.700 --> 00:35:21.010
It can also contain device
interface libraries.

00:35:21.050 --> 00:35:24.470
This would be typically if you're
writing a driver with some sort of

00:35:24.470 --> 00:35:27.400
a custom interface that applications
would need to get at directly.

00:35:27.470 --> 00:35:30.820
Or if you're writing a family and
you want to provide a user client or

00:35:30.840 --> 00:35:34.750
device interface for an application,
that's a handy place to

00:35:34.750 --> 00:35:36.620
store the bundle for that.

00:35:36.690 --> 00:35:38.860
And in the future,
there will probably be other

00:35:38.860 --> 00:35:40.910
things of interest that could
go in that Plugins folder.

00:35:40.930 --> 00:35:44.400
It's sort of a generic
place to put add-ons.

00:35:44.590 --> 00:35:46.630
Only one level of nesting is supported,
though.

00:35:46.650 --> 00:35:49.360
You can't have a kernel extension
inside a kernel extension

00:35:49.360 --> 00:35:50.870
inside a kernel extension.

00:35:51.010 --> 00:35:52.810
Well, we could have made this work.

00:35:53.040 --> 00:35:54.640
But there was very little use for it.

00:35:54.730 --> 00:35:56.470
The user sees the top level.

00:35:56.490 --> 00:35:57.480
That's our intent.

00:35:57.490 --> 00:36:00.230
You can package things internally.

00:36:00.320 --> 00:36:04.250
If we want to have more complex
relationships and organizations,

00:36:04.270 --> 00:36:05.940
send us notes on how you'd
like to have that done.

00:36:05.940 --> 00:36:09.190
I don't think creating a massive
tree inside the extensions folder is

00:36:09.190 --> 00:36:11.670
necessarily the right way to do that.

00:36:14.350 --> 00:36:17.200
All right, now I want to talk about
the user kernel boundary.

00:36:17.250 --> 00:36:21.880
This is new, I think,
to developers just coming in from 9,

00:36:21.890 --> 00:36:23.330
looking at 10.

00:36:23.400 --> 00:36:27.480
There are different places on Mac OS X,
different address spaces.

00:36:27.730 --> 00:36:29.390
Drivers live inside the kernel.

00:36:29.470 --> 00:36:31.120
Applications live outside the kernel.

00:36:31.290 --> 00:36:33.330
So anytime your app needs
to talk to a driver,

00:36:33.430 --> 00:36:35.600
you've got to cross that boundary.

00:36:35.600 --> 00:36:36.440
It's as simple as that.

00:36:36.440 --> 00:36:38.980
There's no way around it.

00:36:39.330 --> 00:36:43.990
Mac OS X and the Darwin kernel and
infrastructure provide a large number

00:36:44.000 --> 00:36:45.600
of ways to get across that boundary.

00:36:45.600 --> 00:36:48.700
If you can use a sufficiently
high abstraction,

00:36:48.700 --> 00:36:51.150
like a file system,
the file system provides

00:36:51.230 --> 00:36:52.200
that bridge for you.

00:36:52.200 --> 00:36:54.540
It makes use of BSD to cross that
bridge and get data out of the

00:36:54.540 --> 00:36:56.180
kernel and into your application.

00:36:56.220 --> 00:36:59.190
Networking,
Sockets does that for you as well.

00:36:59.230 --> 00:37:01.690
But if you can't use a high
level abstraction and you have

00:37:01.690 --> 00:37:05.560
to use a low level abstraction,
you've got to get directly at a device,

00:37:05.560 --> 00:37:09.860
you can use,
basically it's a CFPlugin interface

00:37:09.860 --> 00:37:12.410
that we use called a device interface.

00:37:14.330 --> 00:37:16.790
Oh, and the class,
the in-kernel class that you

00:37:16.790 --> 00:37:20.690
derive from is I/O User Client.

00:37:20.800 --> 00:37:24.760
The name derives from the fact
that from the kernel's perspective,

00:37:24.760 --> 00:37:26.440
the client is a user.

00:37:26.540 --> 00:37:29.550
Therefore, the object is a user client.

00:37:30.790 --> 00:37:35.300
So your code belongs outside the kernel
unless you must process interrupts.

00:37:35.300 --> 00:37:39.430
If you have to get at an interrupt,
you need to be inside the kernel.

00:37:39.440 --> 00:37:42.440
Unless you have to deliver
services to an in-kernel component,

00:37:42.440 --> 00:37:45.400
for example,
file systems live inside the kernel.

00:37:45.400 --> 00:37:48.140
So if you're writing a disk
driver and the disk is most likely

00:37:48.140 --> 00:37:51.100
going to be used by file systems,
it makes sense for that driver

00:37:51.100 --> 00:37:52.240
to live inside the kernel.

00:37:52.240 --> 00:37:54.880
It is possible, of course,
to put almost anything you

00:37:54.880 --> 00:37:58.130
want outside the kernel,
but then moving data means more

00:37:58.130 --> 00:38:01.190
user kernel boundary crossings,
and that costs a lot of time,

00:38:01.190 --> 00:38:04.290
so you're not going to get a
huge amount of performance.

00:38:04.310 --> 00:38:07.920
But if it's a really slow device,
you can have drivers live

00:38:07.940 --> 00:38:10.770
outside and tunnel back and forth
across the user kernel boundary.

00:38:13.080 --> 00:38:15.460
The other reason for putting
something inside the kernel would

00:38:15.460 --> 00:38:18.280
be if it provides a service that's
needed by a large number of clients

00:38:18.330 --> 00:38:20.400
and it's needed much of the time.

00:38:20.450 --> 00:38:23.360
Now,
this is kind of a judgment call here,

00:38:23.430 --> 00:38:26.200
but basically the kernel is
sort of the only guaranteed

00:38:26.200 --> 00:38:27.700
rendezvous mechanism on the system.

00:38:27.700 --> 00:38:32.790
An app running in Darwin or Cocoa or
Carbon can pretty much guarantee it's

00:38:32.790 --> 00:38:34.900
there and there are APIs to get at it.

00:38:34.900 --> 00:38:37.620
So if you've got a service that's
available inside the kernel,

00:38:37.620 --> 00:38:39.660
it's a convenient rendezvous mechanism.

00:38:39.720 --> 00:38:43.590
But if you only have one client
that needs to get at your device,

00:38:43.590 --> 00:38:47.370
or if it's only used 1% of the time,
why put it in the kernel?

00:38:47.530 --> 00:38:49.890
That memory is going to
be used all of the time,

00:38:49.890 --> 00:38:51.460
not just when it's in use.

00:38:52.040 --> 00:38:54.660
So an example there
might be a backup driver,

00:38:54.670 --> 00:38:57.800
a device driver that's
only used to do backups.

00:38:57.890 --> 00:38:59.690
Most people aren't backing
up all of the time.

00:38:59.710 --> 00:39:03.400
You could have one application that could
load such a driver when it needs it,

00:39:03.420 --> 00:39:07.040
or it could process it in
user space and then unload it

00:39:07.040 --> 00:39:09.240
when it's no longer needed.

00:39:12.630 --> 00:39:17.370
So the device interface model,
this is sort of the app view of I/O Kit.

00:39:17.430 --> 00:39:20.130
The device interface model
provides API access for

00:39:20.130 --> 00:39:21.500
many devices in the system.

00:39:21.500 --> 00:39:23.490
It doesn't provide
access for all devices.

00:39:23.500 --> 00:39:24.490
This is important.

00:39:24.500 --> 00:39:30.500
We don't provide access for applications
to directly get at the PCI bus.

00:39:30.500 --> 00:39:33.500
We do let you get at devices
hanging off the PCI bus,

00:39:33.500 --> 00:39:36.500
so if you've got a SCSI controller there,
you can talk to the SCSI bus,

00:39:36.500 --> 00:39:38.490
but you can't talk to the PCI bus.

00:39:38.490 --> 00:39:41.500
It's actually a security issue there.

00:39:41.500 --> 00:39:43.710
Also,
there are some devices it really doesn't

00:39:43.710 --> 00:39:47.330
make sense to get at from user space,
so we don't create the ability to cross

00:39:47.330 --> 00:39:49.490
that boundary for every kind of device.

00:39:49.490 --> 00:39:54.490
But the ability is there if we need
to make use of it in the future.

00:39:54.780 --> 00:39:57.610
The device interface model wraps
a number of Mach mechanisms.

00:39:57.700 --> 00:40:01.450
Basically, since Mach is the IPC model,
everything that we do is

00:40:01.470 --> 00:40:02.900
simply a wrapper for that.

00:40:02.910 --> 00:40:08.260
And our idea there is for I/O Kit to
make the most common uses of the

00:40:08.260 --> 00:40:10.990
Mach infrastructure easy to use.

00:40:11.000 --> 00:40:12.700
I/O User Client provides this.

00:40:12.810 --> 00:40:15.300
So, system calls.

00:40:15.500 --> 00:40:29.300
[Transcript missing]

00:40:30.150 --> 00:40:33.680
So to a driver,
this boundary crossing layer really

00:40:33.680 --> 00:40:37.390
looks like an in-kernel client,
a subclass of I/O user client.

00:40:37.530 --> 00:40:39.960
The object I/O user client
is inside the kernel.

00:40:40.000 --> 00:40:43.540
It's talking to the driver like
any other in-kernel component.

00:40:43.540 --> 00:40:47.900
It's just moving that data across the
user kernel boundary as its primary goal.

00:40:48.020 --> 00:40:51.590
To an application,
it looks like typically a CFPlugin,

00:40:51.670 --> 00:40:58.270
generally Maco binary,
that's the preferred format.

00:40:58.280 --> 00:40:58.280
But basically, it is

00:40:59.100 --> 00:41:00.400
There's proxies in both space.

00:41:00.480 --> 00:41:02.300
The proxy in the user
space is a CFPlugin,

00:41:02.300 --> 00:41:04.530
and the proxy in the kernel
space is an I/O user client.

00:41:04.550 --> 00:41:09.100
They're geared to talk to each other,
and your app talks to the CFBundle,

00:41:09.100 --> 00:41:12.400
the CFPlugin,
and the I/O Kit driver is going

00:41:12.400 --> 00:41:14.690
to talk to the user client.

00:41:14.890 --> 00:41:19.570
So, I'm going to go through a four-step
sequence here of how this works.

00:41:21.180 --> 00:41:22.870
So from an application,
the first thing to do is

00:41:22.980 --> 00:41:24.000
find the device of interest.

00:41:24.000 --> 00:41:26.700
And the way you do that is by
searching the I-O registry.

00:41:26.700 --> 00:41:30.030
There's a number of different ways to
search the I-O registry and discover

00:41:30.030 --> 00:41:34.000
the device or devices of interest,
but probably the most common and

00:41:34.150 --> 00:41:37.310
most useful one is I-O service
get matching services.

00:41:37.320 --> 00:41:42.170
This basically allows you to find all
of the instances of I-O SCSI device or

00:41:42.240 --> 00:41:44.060
all the instances of I-O USB device.

00:41:44.640 --> 00:41:48.330
And you can provide some further
match criteria that is driven

00:41:48.330 --> 00:41:51.320
actually very similarly to
the way driver matching works.

00:41:51.320 --> 00:41:54.320
But basically,
you find the devices of interest,

00:41:54.400 --> 00:41:57.420
and you get a list back,
and you use I-O Iterator Next to

00:41:57.420 --> 00:41:59.250
actually walk through that list.

00:41:59.260 --> 00:42:01.580
And when you find the
device you're interested in,

00:42:01.580 --> 00:42:02.560
you make note of it.

00:42:02.620 --> 00:42:04.480
And in step two...

00:42:06.400 --> 00:42:09.960
You're going to need to call
I/O Create Plugin Interface for Service,

00:42:09.960 --> 00:42:13.740
if this is a CFPlugin style user client.

00:42:13.820 --> 00:42:20.470
The technique here is to take the
cookie that you got from searching the

00:42:20.470 --> 00:42:22.930
I/O registry and request a session here.

00:42:22.940 --> 00:42:25.130
So you basically create
a plugin interface.

00:42:25.250 --> 00:42:28.700
This loads the CFBundle into
your application,

00:42:28.810 --> 00:42:32.710
and then you call Query Interface,
which actually returns an

00:42:32.710 --> 00:42:35.090
interface to the desired device.

00:42:38.310 --> 00:42:40.670
All right, at this point,
you actually don't own the device.

00:42:40.700 --> 00:42:44.310
You just have an interface to the device.

00:42:44.560 --> 00:42:46.480
I/O Kit has multiple layers here.

00:42:46.510 --> 00:42:51.490
Because we also have multiple
clients competing for devices.

00:42:51.550 --> 00:42:54.060
They might all want to have a
session going to the device,

00:42:54.060 --> 00:42:56.260
but they don't want to
keep it open all the time.

00:42:56.260 --> 00:42:58.990
They want to be a good citizen
and close it periodically to allow

00:42:58.990 --> 00:43:01.230
others the opportunity to use it.

00:43:01.240 --> 00:43:03.330
So in this case,
the details are family specific.

00:43:03.410 --> 00:43:09.160
But basically, it follows a pretty basic
open I/O close procedure here.

00:43:09.160 --> 00:43:11.630
There's nothing really surprising there.

00:43:11.650 --> 00:43:14.680
Ideally,
you call open as late as possible.

00:43:14.680 --> 00:43:17.460
And you call close as early
and as often as possible.

00:43:17.470 --> 00:43:19.280
Because as long as you
have a device open,

00:43:19.280 --> 00:43:21.160
nobody else is going to
be able to get at it.

00:43:21.180 --> 00:43:26.650
Each family will instrument
its own arbitration policy.

00:43:26.770 --> 00:43:30.810
But in general, assume mutual exclusion,
unless you've heard something else.

00:43:30.840 --> 00:43:33.510
And ideally,
if you're doing something to a

00:43:33.620 --> 00:43:35.990
device that only takes a few seconds,
open it.

00:43:36.040 --> 00:43:37.030
Do that I/O and close it.

00:43:37.120 --> 00:43:39.040
You only keep it open
if you really need to.

00:43:39.040 --> 00:43:42.580
Because it's in some volatile state
that you can't easily restore.

00:43:42.580 --> 00:43:46.260
Or it doesn't make sense for
it to trade owners briefly.

00:43:49.530 --> 00:43:54.000
And the last step is to release
the interface to the device.

00:43:54.000 --> 00:43:55.150
This just cleans things up.

00:43:55.250 --> 00:43:57.900
If your app crashes,
this gets done for you.

00:43:58.010 --> 00:44:01.900
But ideally,
you explicitly clean this up.

00:44:02.010 --> 00:44:02.890
There is a release note.

00:44:02.970 --> 00:44:04.910
I'm sorry,
I don't have a more specific reference,

00:44:04.980 --> 00:44:07.350
but if you go to the ADC website,
you should be able to

00:44:07.350 --> 00:44:08.780
search for this and find it.

00:44:08.950 --> 00:44:12.970
CFBundle and CFPlugins release
note describe a lot of the APIs,

00:44:12.970 --> 00:44:14.610
the app-level APIs.

00:44:16.480 --> 00:44:19.600
Now, I want to talk for a little while
about the different app models.

00:44:19.600 --> 00:44:25.560
I gave you a rundown of how to do that,
assuming that your app could

00:44:25.560 --> 00:44:27.980
talk to a Mako plug-in.

00:44:28.960 --> 00:44:32.200
But there's a number of different
application spaces on Mac OS X.

00:44:32.280 --> 00:44:35.900
So for starters,
let's take a classic application.

00:44:35.960 --> 00:44:40.090
Well, there's no direct I/O Kit access
for a classic application.

00:44:40.100 --> 00:44:42.400
It wouldn't be a compatibility
environment if it included

00:44:42.400 --> 00:44:44.040
all the I/O Kit APIs.

00:44:44.110 --> 00:44:46.370
So basically,
whatever is present in classic,

00:44:46.370 --> 00:44:50.550
whatever abstractions are there,
that's what you get.

00:44:50.610 --> 00:44:53.600
All communications go
through classic itself.

00:44:54.800 --> 00:44:56.520
The same is true for a pure Carbon app.

00:44:56.520 --> 00:45:00.200
If you're writing a Carbon app in
CFM and you're keeping it pure,

00:45:00.200 --> 00:45:04.200
you're only calling Carbon APIs,
you only get what's in Carbon.

00:45:15.850 --> 00:45:15.850
I mean, that's kind of the definition
of a pure Carbon app.

00:45:15.850 --> 00:45:15.850
So you go through the Carbon framework
and that's how you get down into

00:45:15.850 --> 00:45:15.850
the kernel and get at drivers.

00:45:15.850 --> 00:45:15.850
But there's not a
tremendous amount there.

00:45:16.810 --> 00:45:19.390
Now it starts to get a little
bit more interesting when you are

00:45:19.390 --> 00:45:23.600
willing to do Mac OS X specific
code in your application.

00:45:23.720 --> 00:45:27.700
And in this case we've got
a CFM Carbon application.

00:45:28.150 --> 00:45:30.600
which has basically two
ways to talk to I/O Kit.

00:45:30.740 --> 00:45:35.050
One is through Carbon in
places like I/O SCSI Action,

00:45:35.130 --> 00:45:38.130
where we've actually provided some
Carbon APIs for device access.

00:45:38.130 --> 00:45:39.990
You can make use of that.

00:45:40.110 --> 00:45:43.300
But you can also make use of
the plugin architecture that

00:45:43.300 --> 00:45:45.000
I described in the previous slides.

00:45:45.000 --> 00:45:48.490
Now the coloration here is
a little bit of a giveaway.

00:45:48.660 --> 00:45:52.670
The orange represents
parts of the Darwin kernel,

00:45:52.670 --> 00:45:54.000
things that Apple provides you.

00:45:54.000 --> 00:45:57.990
The purple is the app
environment that you're using.

00:45:57.990 --> 00:46:02.000
And the blue boxes on the top are the
boxes that represent code that you write.

00:46:02.000 --> 00:46:06.760
You write the application itself,
and you write the CFBundle that provides

00:46:06.760 --> 00:46:09.000
the interface down into I/O Kit.

00:46:09.000 --> 00:46:12.820
Now this is actually kind of handy
because it allows you to write a

00:46:12.830 --> 00:46:15.000
different plugin for running on Mac OS 9.

00:46:15.000 --> 00:46:19.440
So you can write one application
that runs on 9 or 10 and it

00:46:19.440 --> 00:46:23.970
would load an operating system
specific plugin to do its I/O.

00:46:26.730 --> 00:46:31.940
Now if you're writing a MacO Carbon app,
it actually eliminates a layer there.

00:46:31.940 --> 00:46:34.290
You don't have to have the
plug-in because you're not

00:46:34.290 --> 00:46:36.300
switching over from CFM to MacO.

00:46:36.300 --> 00:46:40.210
You can directly call the
plug-ins that I/O Kit provides.

00:46:40.210 --> 00:46:44.000
And of course you can still go
through the Carbon environment

00:46:44.000 --> 00:46:44.000
that's always available to you.

00:46:45.320 --> 00:46:47.140
And the same is true for a Cocoa app.

00:46:47.180 --> 00:46:49.740
Basically,
you can go through Cocoa or you

00:46:49.740 --> 00:46:51.700
can go through the CFPlugin.

00:46:51.700 --> 00:46:54.540
What I don't have up here
is a pure BSD application,

00:46:54.540 --> 00:46:59.360
but a BSD application has all the
CFPlugin stuff available to it,

00:46:59.360 --> 00:47:01.770
plus all the BSD APIs as well.

00:47:04.020 --> 00:47:08.140
So I don't have any other
details on I/O Kit for you today.

00:47:08.140 --> 00:47:11.710
What I do have is a rather lengthy
roadmap for other sessions,

00:47:11.710 --> 00:47:14.910
because that's where the details
are going to be conveyed to you.

00:47:14.990 --> 00:47:18.430
There are sessions on graphics,
actually right after this session.

00:47:18.470 --> 00:47:23.090
There is sessions on image capture,
sessions on

00:47:23.470 --> 00:47:26.860
Input devices, Firewire, USB.

00:47:26.860 --> 00:47:29.430
Spend a little time looking through
your guide if you haven't already and

00:47:29.430 --> 00:47:33.400
figure out which ones are going to
have information most relevant to you.

00:47:33.400 --> 00:47:36.540
There's a lot of details,
there's a lot of API that fits

00:47:36.550 --> 00:47:38.400
under the I/O Kit umbrella.

00:47:38.400 --> 00:47:42.650
And yet another page of them.
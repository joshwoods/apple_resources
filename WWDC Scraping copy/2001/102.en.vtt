WEBVTT

00:00:05.090 --> 00:00:07.840
So my name is Chuck Pisula,
and just like everybody

00:00:07.840 --> 00:00:09.880
else here from Apple today,
I'm here to help you.

00:00:09.890 --> 00:00:13.440
And in particular,
I'm here to help you learn about Cocoa.

00:00:15.340 --> 00:00:17.500
So, let's give you an idea, again,
what Cocoa is.

00:00:17.560 --> 00:00:20.650
It's an advanced object-oriented
framework designed from the ground

00:00:20.650 --> 00:00:25.050
up using objects and many powerful
object-oriented methodologies.

00:00:25.060 --> 00:00:28.540
It provides you a full feature set
for doing application development,

00:00:28.710 --> 00:00:31.400
and it integrates well with
other system components.

00:00:31.400 --> 00:00:32.820
It's not a standalone component.

00:00:32.820 --> 00:00:36.930
You can use any of the POSIX APIs or,
as you heard Scott say earlier,

00:00:36.930 --> 00:00:41.430
actually integrate with parts of Carbon,
like the print panels actually

00:00:41.430 --> 00:00:43.280
comes up through Carbon.

00:00:44.310 --> 00:00:47.220
And it's used by many important
Mac OS X applications.

00:00:47.500 --> 00:00:52.990
System Preferences was written in Cocoa,
the Mail application, Project Builder.

00:00:54.880 --> 00:00:57.740
Let me set the stage for what
you're going to learn today.

00:00:57.790 --> 00:01:01.590
My goal is to tell you
what makes Cocoa unique.

00:01:01.940 --> 00:01:03.850
By doing so,
we're going to talk about some of

00:01:03.850 --> 00:01:05.420
the important classes in Cocoa.

00:01:05.490 --> 00:01:06.960
We can't talk about all of them.

00:01:07.070 --> 00:01:08.220
There's a lot.

00:01:08.440 --> 00:01:11.480
And we're going to discuss some
of the main concepts and features,

00:01:11.490 --> 00:01:14.620
in particular those that make
Cocoa unique and powerful.

00:01:14.660 --> 00:01:17.870
Above all, I want you to learn
that Cocoa is powerful,

00:01:18.030 --> 00:01:21.160
easy to use,
and can make you more productive.

00:01:21.760 --> 00:01:22.680
Cocoa is powerful.

00:01:22.680 --> 00:01:25.100
It's an object-oriented framework
designed from the ground up,

00:01:25.100 --> 00:01:27.540
using objects and those
object-oriented methodologies.

00:01:27.550 --> 00:01:31.620
You'll notice some of these slides are
similar to earlier slides you saw today.

00:01:32.350 --> 00:01:34.780
I'll have to learn next year not
to do them so early so that they

00:01:34.950 --> 00:01:39.180
can't be reused by people before me.

00:01:39.370 --> 00:01:42.490
So they're designed for extensibility,
again, like Scott said, so that you,

00:01:42.490 --> 00:01:45.520
the developer,
can make changes without a lot of effort.

00:01:45.540 --> 00:01:50.140
And we use a dynamic runtime system
that makes many things easy to do

00:01:50.140 --> 00:01:52.310
that you might not even consider
doing with other frameworks.

00:01:52.380 --> 00:01:56.020
It's easy to use because we have
consistent APIs and conventions,

00:01:56.170 --> 00:01:58.060
again, in Objective-C and Java.

00:01:58.060 --> 00:02:00.400
And again,
those of you who are not familiar with

00:02:00.410 --> 00:02:02.570
Objective-C shouldn't be frightened.

00:02:02.580 --> 00:02:05.410
It's something that,
it's a small extension to the

00:02:05.410 --> 00:02:09.960
ANSI C-based language to support
things like objects and messaging.

00:02:09.960 --> 00:02:12.570
And if you're familiar with
object-oriented programming

00:02:12.570 --> 00:02:14.680
and the C-based language,
you should be able to

00:02:14.740 --> 00:02:15.880
learn it in a day or two.

00:02:18.190 --> 00:02:21.490
Now, we also have brought up this
line count thing many times.

00:02:21.590 --> 00:02:23.490
So one measure of
productivity is line count.

00:02:23.620 --> 00:02:26.610
It's not the only one,
but it's a measure of productivity.

00:02:27.110 --> 00:02:28.780
So what can Cocoa give you for free?

00:02:28.780 --> 00:02:31.850
Well, in fact, with no lines of code,
you can actually have a

00:02:31.850 --> 00:02:32.990
reasonable text editor.

00:02:33.010 --> 00:02:34.820
Now,
I know most of you out here are not in

00:02:34.920 --> 00:02:39.690
the business of writing text editors,
but what this means is that

00:02:39.760 --> 00:02:43.630
this is an example of what
Cocoa can give you for free.

00:02:43.640 --> 00:02:46.620
And the idea here is that although
you're not writing text editors,

00:02:46.700 --> 00:02:49.020
you want to get lots of stuff
for free so that you don't

00:02:49.170 --> 00:02:50.550
have to reinvent the wheel.

00:02:51.180 --> 00:02:55.150
This means you get more time to work
on features which make your product

00:02:55.150 --> 00:02:57.510
unique and helps you sell your product.

00:02:57.600 --> 00:03:01.220
So at this time, I'd like to bring
Doug Davidson up on stage.

00:03:01.220 --> 00:03:04.880
He's going to show you how to write a
no-line text editor and sort of show

00:03:05.050 --> 00:03:06.980
off what you get for free in Cocoa.

00:03:07.000 --> 00:03:08.120
Doug?

00:03:10.100 --> 00:03:11.660
Good afternoon, everyone.

00:03:11.730 --> 00:03:14.810
I'm here to show you how easy
it is to get started writing

00:03:14.870 --> 00:03:17.000
great applications with Cocoa.

00:03:17.000 --> 00:03:21.000
So we're going to write a
Cocoa application from scratch right now.

00:03:21.000 --> 00:03:24.910
So let's fire up
Project Builder and get started.

00:03:26.570 --> 00:03:30.820
This will be a
Cocoa document-based application,

00:03:30.910 --> 00:03:33.790
something along the lines of simple text.

00:03:35.500 --> 00:03:39.520
And we'll let Project Builder
create a project for us.

00:03:39.520 --> 00:03:44.270
Now, the main thing we get with
this project is a couple of

00:03:44.270 --> 00:03:46.380
interface definition files.

00:03:46.380 --> 00:03:50.470
So let's take a look at
those in Interface Builder.

00:03:54.710 --> 00:04:00.200
The first one has a window for us where
we can put the contents of our document.

00:04:00.230 --> 00:04:03.100
With Handy,
your document content is here.

00:04:03.140 --> 00:04:06.660
Since this is going to be a text editor,

00:04:07.070 --> 00:04:10.140
Well, the thing that I want to
put in here is a text view.

00:04:10.140 --> 00:04:13.430
So I'll just drag one in off the palette.

00:04:13.450 --> 00:04:16.940
And I'll position it the way I want.

00:04:17.900 --> 00:04:20.640
I want to size it the way I want.

00:04:20.640 --> 00:04:23.400
And I want it to grow
when my window grows.

00:04:23.490 --> 00:04:26.920
For that,
I have to set a couple of springs.

00:04:27.380 --> 00:04:32.800
And let's take a look at the
attributes our text view might have.

00:04:32.810 --> 00:04:34.480
We've already got-- it's editable.

00:04:34.480 --> 00:04:35.440
That's good.

00:04:35.440 --> 00:04:36.860
Multiple fonts allowed.

00:04:37.020 --> 00:04:38.050
That's also good.

00:04:38.070 --> 00:04:38.940
How about graphics?

00:04:38.980 --> 00:04:42.720
That would also be nice.

00:04:42.720 --> 00:04:42.720
And undo.

00:04:42.720 --> 00:04:42.720
That's useful.

00:04:48.000 --> 00:04:51.460
And the other one has our main menu.

00:04:51.460 --> 00:04:54.010
Let's also take a look at that.

00:04:54.640 --> 00:04:57.230
Here's our main menu.

00:04:57.260 --> 00:05:02.350
Now, since this is a text editor,
I think I would like to have a text menu.

00:05:02.360 --> 00:05:05.470
So I'll add that and a font menu.

00:05:10.300 --> 00:05:11.140
Let's see.

00:05:11.140 --> 00:05:12.300
Let's try building it.

00:05:12.300 --> 00:05:14.300
This is always a moment of truth.

00:05:14.300 --> 00:05:18.060
Built.

00:05:18.060 --> 00:05:19.300
That's good.

00:05:19.310 --> 00:05:22.900
Let's see if we can run it
straight from Project Builder.

00:05:24.790 --> 00:05:28.040
And here is our application.

00:05:28.070 --> 00:05:28.560
What did we get?

00:05:28.630 --> 00:05:34.730
We got a document window,
or maybe two or three,

00:05:34.730 --> 00:05:37.110
that we can type into.

00:05:41.000 --> 00:05:43.940
Let me make that a little bigger for you.

00:05:43.940 --> 00:05:48.490
That's better.

00:05:48.700 --> 00:05:52.720
And this has a lot of the standard text
type features that you might expect,

00:05:52.760 --> 00:06:00.580
like copy and paste or drag and drop.

00:06:01.500 --> 00:06:09.400
[Transcript missing]

00:06:10.600 --> 00:06:29.500
[Transcript missing]

00:06:37.700 --> 00:06:41.480
Or we can drag in inline images.

00:06:41.480 --> 00:06:44.290
Let me make that a little bigger.

00:06:47.300 --> 00:07:06.900
[Transcript missing]

00:07:16.000 --> 00:07:22.200
[Transcript missing]

00:07:23.170 --> 00:07:24.860
Built right in.

00:07:24.900 --> 00:07:32.890
And we also have a ruler with
some various formatting options.

00:07:41.600 --> 00:07:42.840
And there's one more thing.

00:07:42.840 --> 00:07:46.220
You notice this little close
button up here has a document

00:07:46.300 --> 00:07:47.150
dirty indicator in it.

00:07:47.220 --> 00:07:49.640
That means that our application
has automatically noticed

00:07:49.640 --> 00:07:50.840
that we edited this document.

00:07:50.840 --> 00:07:53.160
And if we try to close it,
it will ask us if we

00:07:53.190 --> 00:07:54.600
want to save changes.

00:07:54.600 --> 00:08:04.120
And it will bring up a save panel,
a little one or maybe a big one,

00:08:04.120 --> 00:08:04.120
whatever we like.

00:08:04.120 --> 00:08:04.120
You can try to save.

00:08:05.200 --> 00:08:08.040
Oops, didn't save the document.

00:08:08.040 --> 00:08:10.040
What's missing here?

00:08:10.080 --> 00:08:11.700
We didn't write any code.

00:08:11.700 --> 00:08:12.950
We forgot to add any code.

00:08:13.100 --> 00:08:16.200
Well, at this point,
I have to admit that Cocoa can't

00:08:16.230 --> 00:08:18.440
do absolutely everything for you.

00:08:18.600 --> 00:08:27.660
You would have to write a little code
to be able to open or save documents.

00:08:27.660 --> 00:08:27.660
But with an additional
less than 20 lines of code,

00:08:28.150 --> 00:08:31.190
This text editor would be able
to open and save documents

00:08:31.210 --> 00:08:34.680
in a variety of formats,
and we would have a full

00:08:34.680 --> 00:08:37.100
working text editor.

00:08:37.140 --> 00:08:38.970
Now back to you, Chuck.

00:08:44.240 --> 00:08:45.520
Thank you very much, Doug.

00:08:45.540 --> 00:08:49.920
Now, again, the point of the demo was
not to show you that you can

00:08:49.920 --> 00:08:50.980
write a text editor real easy.

00:08:50.980 --> 00:08:53.670
Well, you can, but most of you aren't
going to be doing that.

00:08:54.030 --> 00:08:57.120
The point was to show you that you get...

00:08:58.450 --> 00:08:59.660
Lots for free in Cocoa.

00:08:59.690 --> 00:09:01.830
And if you're like me,
you like getting stuff for free.

00:09:02.680 --> 00:09:05.020
Like Will Shipley was
up here earlier saying,

00:09:05.050 --> 00:09:08.220
you don't enjoy writing stuff
that's been done hundreds of times.

00:09:08.220 --> 00:09:09.830
You want to do new,
unique stuff that's going to

00:09:09.870 --> 00:09:11.070
make your product really cool.

00:09:11.080 --> 00:09:14.780
And that's what Cocoa allows you to do.

00:09:15.110 --> 00:09:18.490
So let's talk about some more, I guess,
more realistic applications,

00:09:18.490 --> 00:09:20.230
like some of the stuff you
guys are going to be writing.

00:09:20.240 --> 00:09:22.950
We have the mail application on Mac OS X.

00:09:22.950 --> 00:09:25.600
It was written in about
75,000 lines of code.

00:09:25.600 --> 00:09:28.400
Again, you see this probably
rehashed a couple times now,

00:09:28.400 --> 00:09:31.490
but I just want to reiterate
it because it's so important to

00:09:31.570 --> 00:09:36.220
understand that you get compact code
size and still lots of functionality.

00:09:36.220 --> 00:09:41.240
So of those 75,000 lines of code,
15,000 are actually comments.

00:09:42.350 --> 00:09:45.220
So that leaves us with
about 60,000 lines of code.

00:09:45.240 --> 00:09:48.150
Of that, 40,000 are written in
reusable frameworks.

00:09:48.160 --> 00:09:51.380
Now this means that they're
not specific to mail.

00:09:51.380 --> 00:09:55.040
We're actually reusing them throughout
Apple so that we write it one time and

00:09:55.040 --> 00:09:56.990
multiple applications get to use it.

00:09:57.040 --> 00:10:01.150
That leaves only 20,000 lines of code
for this mail application that are

00:10:01.150 --> 00:10:03.380
specific only to that mail application.

00:10:05.720 --> 00:10:07.500
Many of you are familiar with OmniWeb.

00:10:07.570 --> 00:10:10.770
OmniWeb is a full-featured
Cocoa application.

00:10:10.800 --> 00:10:14.850
It's a web browser, and it was written in
300,000 lines of code.

00:10:14.860 --> 00:10:17.310
Now, at first,
this might sound like a lot,

00:10:17.340 --> 00:10:21.050
but I've been told by the OmniWeb folks,
who are generous enough to

00:10:21.160 --> 00:10:25.470
give me the line counts,
that 120,000 lines of code are there only

00:10:25.560 --> 00:10:28.990
to support about five various plugins,
like Flash and so on.

00:10:29.440 --> 00:10:33.590
So that leaves us with half the
code only to support a couple

00:10:33.590 --> 00:10:35.740
of plugins that we're in C.

00:10:35.740 --> 00:10:39.950
That leaves about 170,000
lines of Cocoa code.

00:10:39.980 --> 00:10:44.800
Of that, 140,000 of them are written
as reusable frameworks.

00:10:44.860 --> 00:10:48.290
So you're noticing a theme here,
where typically in Cocoa,

00:10:48.290 --> 00:10:51.750
you're able to write your code,
some of it factored out

00:10:51.880 --> 00:10:53.750
into reusable frameworks.

00:10:53.790 --> 00:10:56.280
Now,
Omni actually posts this on your website.

00:10:56.280 --> 00:10:58.050
You can go and check
out the code yourselves.

00:10:58.630 --> 00:11:01.260
And they address things like networking,
the web, HTML,

00:11:01.280 --> 00:11:03.390
and some custom controls that they're on.

00:11:03.400 --> 00:11:06.180
So that leaves,
for a full-featured web browser,

00:11:06.270 --> 00:11:08.760
only 36,000 lines of code.

00:11:08.760 --> 00:11:12.470
Again, very compact, yet full-featured.

00:11:13.050 --> 00:11:15.460
Okay, so let's leave,
that's a bit of the motivation

00:11:15.460 --> 00:11:17.480
as to why you might be
interested in checking out Cocoa.

00:11:17.540 --> 00:11:19.220
Let's talk about where Cocoa fits.

00:11:19.220 --> 00:11:21.660
You've seen this many times.

00:11:21.660 --> 00:11:24.920
You've seen at the lowest level is
the cherry-flavored Darwin pill.

00:11:24.920 --> 00:11:28.970
Above that, we have maybe lime-flavored
graphics of Quartz,

00:11:29.150 --> 00:11:30.920
OpenGL, and QuickTime.

00:11:30.920 --> 00:11:35.100
And then, like Scott talked about,
we have many programming environments,

00:11:35.270 --> 00:11:38.180
one of which is Cocoa,
its own tasty little component.

00:11:39.500 --> 00:11:44.210
So Cocoa, in a little bit of detail,
it's actually divided up into two layers.

00:11:44.220 --> 00:11:46.860
We have the foundation,
which is typically non-UI classes,

00:11:46.860 --> 00:11:50.900
and the app kit,
which are the UI classes.

00:11:50.920 --> 00:11:55.820
And the app kit gains its graphic
capabilities from application service,

00:11:55.820 --> 00:11:58.300
which, again, is Quartz, QuickTime,
and OpenGL.

00:12:00.900 --> 00:12:02.820
Cocoa is full-featured.

00:12:03.220 --> 00:12:04.140
There's a lot of classes here.

00:12:04.140 --> 00:12:07.900
In fact, there are 220 or so classes.

00:12:08.000 --> 00:12:10.970
So we don't have time
to talk about all today.

00:12:11.220 --> 00:12:13.740
Some of you have already picked these up.

00:12:13.790 --> 00:12:15.770
If you go to Hall 2,
there's these references

00:12:15.780 --> 00:12:17.130
that you can use.

00:12:17.220 --> 00:12:19.410
I guess they're cheat sheets.

00:12:19.560 --> 00:12:23.000
Just try and hide them
conspicuously on tests.

00:12:23.070 --> 00:12:26.060
So again, we're not going to have time
to talk about all this today,

00:12:26.180 --> 00:12:28.900
and I just want to point out
what some of the stuff that

00:12:28.900 --> 00:12:30.500
we're not addressing today are.

00:12:30.600 --> 00:12:34.040
Cocoa is, again,
broken up into the foundation

00:12:34.060 --> 00:12:35.690
and app kit layers.

00:12:35.880 --> 00:12:38.070
APCAD addresses things
like windows and views,

00:12:38.320 --> 00:12:42.440
graphics and imaging,
events and system interaction,

00:12:42.480 --> 00:12:47.100
a number of classes for text handling,
which were shown off in the earlier demo.

00:12:47.180 --> 00:12:50.400
Then in the foundation level,
we have classes for basic

00:12:50.400 --> 00:12:53.330
storage and collections,
abstractions for dealing

00:12:53.480 --> 00:12:56.180
with file input and output,
for dealing with operating

00:12:56.200 --> 00:12:59.700
system mechanisms,
such as processes and threading,

00:12:59.800 --> 00:13:03.760
and networking and communication,
and then some others.

00:13:04.070 --> 00:13:08.240
Okay, so let's dive into the
foundation now in detail.

00:13:08.280 --> 00:13:11.980
At the root of the foundation
is a class called NSObject.

00:13:12.020 --> 00:13:13.700
In fact,
you'll notice that all classes in

00:13:13.780 --> 00:13:15.800
Cocoa start with the letters NS.

00:13:16.140 --> 00:13:18.580
Brief history lesson:
this actually stands for "Next Step"

00:13:18.610 --> 00:13:22.170
because Cocoa was a Next Step technology.

00:13:22.240 --> 00:13:25.910
So maybe this is a lesson for
including company names in your APIs.

00:13:26.030 --> 00:13:27.420
I don't know.

00:13:29.120 --> 00:13:34.170
Foundation, again, is below the UI level,
and it provides basic classes

00:13:34.190 --> 00:13:38.100
for storage and collections,
operating system abstractions to make

00:13:38.210 --> 00:13:42.450
dealing with the operating system easier,
and our core support for

00:13:42.450 --> 00:13:44.400
internationalization and localization.

00:13:44.400 --> 00:13:48.310
And while I talk about the Foundation,
I'm also going to touch on some topics

00:13:48.310 --> 00:13:53.060
which are important at that level,
in particular, memory management and the

00:13:53.160 --> 00:13:54.980
concept of mutability.

00:13:56.890 --> 00:14:01.050
So, we have basic storage and collection
classes for things like values,

00:14:01.050 --> 00:14:05.620
NSStrings, which store Unicode strings,
NSData for storing a bag of bytes,

00:14:05.620 --> 00:14:08.980
collections that you're typically
used to from CS-type classes,

00:14:09.180 --> 00:14:11.580
you know, arrays, dictionaries, and sets.

00:14:11.580 --> 00:14:16.640
And what's important about these are
that they have very consistent APIs,

00:14:16.640 --> 00:14:20.290
and they can be written to
files as property lists.

00:14:20.320 --> 00:14:22.810
Now, let me explain property
lists a little bit,

00:14:22.940 --> 00:14:25.160
because we've only
been talking about XML,

00:14:25.160 --> 00:14:26.410
not property lists.

00:14:26.930 --> 00:14:32.530
Now, property lists are basically a
simple object graph that we use

00:14:32.710 --> 00:14:34.110
when we write out the files.

00:14:34.440 --> 00:14:38.710
And these are defined using,
the format is defined using XML.

00:14:38.750 --> 00:14:41.730
In fact, if you're interested,
the DTT is on the system.

00:14:41.740 --> 00:14:43.760
Now,
property lists are a deal as a small,

00:14:43.840 --> 00:14:44.960
flexible data store.

00:14:45.070 --> 00:14:47.430
And for that reason,
as has been mentioned a couple times now,

00:14:47.460 --> 00:14:51.390
they're used throughout Cocoa and
Mac OS X for things like user

00:14:51.390 --> 00:14:54.200
preferences and configuration files.

00:14:55.200 --> 00:14:59.630
Now, we also have abstractions for
dealing with the operating system.

00:14:59.630 --> 00:15:01.390
And I use the term
"abstraction" a lot today,

00:15:01.490 --> 00:15:03.850
and I want to define what I mean by that.

00:15:03.950 --> 00:15:08.460
By abstraction,
I mean we have a higher-level interface

00:15:08.460 --> 00:15:12.140
to gaining access to this functionality.

00:15:12.250 --> 00:15:16.050
It doesn't mean that the
functionality is any less powerful.

00:15:16.180 --> 00:15:18.830
It just means that it's easier to use.

00:15:19.230 --> 00:15:22.640
Now, we have abstractions for dealing
with the operating system,

00:15:22.660 --> 00:15:24.920
such as threads and locks.

00:15:24.920 --> 00:15:28.970
For doing file input and output,
things like NSURL, or NSFileHandle,

00:15:29.010 --> 00:15:30.020
for dealing with files.

00:15:30.050 --> 00:15:33.250
We also have classes that
help you do networking,

00:15:33.250 --> 00:15:37.140
communication,
and for accessing system information.

00:15:38.410 --> 00:15:41.160
Now, there's lots of classes
and functionality here,

00:15:41.160 --> 00:15:46.290
but if your needs are exceptional,
you can always use any system-level

00:15:46.350 --> 00:15:50.700
framework or POSIX APIs,
for instance, so that, again,

00:15:50.700 --> 00:15:52.800
Cocoa is not a standalone product.

00:15:52.930 --> 00:15:56.060
You can use it with other
components in the system.

00:15:58.580 --> 00:16:01.480
Internationalization is
very important in Mac OS X.

00:16:01.600 --> 00:16:06.490
Obviously, we're able to ship seven
languages simultaneously.

00:16:07.180 --> 00:16:11.300
The way we're able to do this in
the Cocoa frameworks is through

00:16:11.300 --> 00:16:14.700
our support for Unicode data,
which is in NSString.

00:16:14.780 --> 00:16:17.780
Now those of you who are used
to using the Carbon APIs may

00:16:17.790 --> 00:16:19.330
have heard of CFString.

00:16:19.450 --> 00:16:22.040
NSString is a very, very similar class.

00:16:22.040 --> 00:16:26.230
It's basically just a small
shim on top of CFString.

00:16:26.710 --> 00:16:29.930
So NSString stores Unicode data,
which means it can support

00:16:30.050 --> 00:16:31.430
any language that Unicode can.

00:16:31.440 --> 00:16:34.170
And for that reason,
we use it throughout our

00:16:34.640 --> 00:16:36.430
APIs instead of basically char stars.

00:16:36.460 --> 00:16:39.960
Now typically,
localizing your application involves

00:16:39.960 --> 00:16:42.440
more than just converting strings.

00:16:42.440 --> 00:16:46.900
You also want to convert your images,
so a stop sign in the US might not

00:16:46.900 --> 00:16:50.440
make sense when you're running in some
other language or some other country.

00:16:50.440 --> 00:16:53.240
So you need to localize
things like images and,

00:16:53.250 --> 00:16:54.440
in fact, your UI.

00:16:54.440 --> 00:16:57.430
So NSBundle provides
our support for that.

00:16:57.470 --> 00:17:01.980
NSBundle is just a resource loading
mechanism that knows how to rummage

00:17:02.020 --> 00:17:06.610
around your app packaging system and
find the appropriate resources for the

00:17:06.650 --> 00:17:09.410
user's currently selected language.

00:17:10.110 --> 00:17:12.600
It's also just a general
resource loading mechanism,

00:17:12.640 --> 00:17:16.200
but for localization,
this is what you'd use it for.

00:17:17.700 --> 00:17:21.600
Okay, so that covers some of the
basic classes and functionality

00:17:21.600 --> 00:17:23.630
at the foundation level.

00:17:23.660 --> 00:17:25.500
Now I want to talk about some
of the concepts that apply

00:17:25.630 --> 00:17:26.600
at the foundation level.

00:17:28.860 --> 00:17:29.970
Memory management is important.

00:17:29.970 --> 00:17:33.520
Cocoa does not use automatic
garbage collection.

00:17:33.520 --> 00:17:37.660
However, it uses something just as
simple and easy to understand.

00:17:37.660 --> 00:17:38.830
It uses reference counting.

00:17:38.840 --> 00:17:42.990
So the basic idea is here that when
you send an object a retain message,

00:17:42.990 --> 00:17:45.370
that adds a reference to the object.

00:17:45.370 --> 00:17:47.380
When you send it a release,
that decrements the

00:17:47.390 --> 00:17:48.520
reference to an object.

00:17:48.520 --> 00:17:51.540
When the reference hits zero,
the object will get deallocated.

00:17:51.570 --> 00:17:54.540
Now, the basic rules of our
memory management is simple.

00:17:54.650 --> 00:17:58.660
By convention,
only creation methods return

00:17:58.660 --> 00:18:00.610
objects that have a retain on it.

00:18:00.660 --> 00:18:05.820
All other methods return objects that
temporarily don't have any references.

00:18:05.820 --> 00:18:08.820
If you want to keep that object around,
you send it a retain.

00:18:08.820 --> 00:18:10.780
When you're done with it,
send it a release.

00:18:10.780 --> 00:18:15.730
And again, once it has no references,
it goes away.

00:18:17.890 --> 00:18:21.640
Immutability is also a very
useful and important concept

00:18:21.640 --> 00:18:23.870
at the foundation level.

00:18:24.290 --> 00:18:27.780
Many classes in the foundation
are mutable classes,

00:18:27.800 --> 00:18:29.740
which means that they can be modified.

00:18:29.820 --> 00:18:33.240
Or we have some that are immutable,
meaning that they can't be modified.

00:18:33.380 --> 00:18:35.780
So why do we have a distinction?

00:18:36.210 --> 00:18:37.320
There's a couple reasons.

00:18:37.450 --> 00:18:40.780
Immutable objects can't be modified,
which means it's safe

00:18:40.780 --> 00:18:42.080
to pass them around.

00:18:42.170 --> 00:18:47.480
I can pass you an immutable array safely
if I know you can't add objects to it.

00:18:47.510 --> 00:18:50.290
I might need to know
that it's not changing,

00:18:50.290 --> 00:18:54.170
which means I can also return
immutable arrays from my API to

00:18:54.170 --> 00:18:58.490
external clients and safely know
that they won't be modified.

00:18:59.200 --> 00:19:02.170
Immutable classes could also
have more efficient algorithms.

00:19:02.310 --> 00:19:04.340
If I know an array is
not going to change,

00:19:04.400 --> 00:19:08.000
I might be able to do something
more efficient in my implementation.

00:19:08.130 --> 00:19:11.770
However, the drawback, of course, is,
well, they can't be modified.

00:19:12.150 --> 00:19:14.800
Not much use to pass around arrays
that you can't add things to.

00:19:14.800 --> 00:19:17.470
So, for that reason,
we also have mutable objects.

00:19:17.680 --> 00:19:20.550
And for that reason,
lots of classes at the foundation

00:19:20.550 --> 00:19:22.000
level come in both flavors.

00:19:22.000 --> 00:19:25.000
So,
we have NSStrings and NSMutableString.

00:19:25.020 --> 00:19:29.750
And, in fact,
you'll notice the same things, you know,

00:19:29.750 --> 00:19:33.620
similar classes at the
core foundation level.

00:19:33.860 --> 00:19:35.990
Mutable classes and non-mutable classes.

00:19:35.990 --> 00:19:35.990
So, it's a concept that we
use throughout Mac OS X.

00:19:37.060 --> 00:19:39.340
Okay,
so that covers non-UI functionality.

00:19:39.610 --> 00:19:40.970
I, myself, am a graphics guy.

00:19:41.100 --> 00:19:42.590
I love doing graphics.

00:19:42.590 --> 00:19:44.360
And we're all Mac programmers here.

00:19:44.410 --> 00:19:46.910
Who likes to do great graphics?

00:19:48.120 --> 00:19:50.100
Okay, everybody's third.

00:19:50.330 --> 00:19:52.040
Okay,
so the app kit again is where we have

00:19:52.120 --> 00:19:55.840
our UI level layer and our graphics.

00:19:56.160 --> 00:19:59.740
It provides the infrastructure
for drawing and handling events,

00:19:59.740 --> 00:20:01.930
and also provides many of the
components that you're going to use

00:20:02.040 --> 00:20:04.140
off the shelf in your application.

00:20:04.190 --> 00:20:06.750
We have basic controls like
buttons and check boxes,

00:20:06.810 --> 00:20:09.740
advanced controls like the toolbar,
and we also have standard

00:20:09.740 --> 00:20:14.340
dialogues like color panel,
save panel, open panels,

00:20:14.390 --> 00:20:20.120
and we have many advanced Aqua features
such as drawers and transparent sheets.

00:20:20.230 --> 00:20:23.380
And again, as you saw earlier today,
Cocoa features a very

00:20:23.380 --> 00:20:25.150
sophisticated text system.

00:20:26.410 --> 00:20:30.650
So here's a diagram showing some of the
classes that I'm going to touch on today.

00:20:30.770 --> 00:20:34.140
Again, only about five of those 220.

00:20:34.260 --> 00:20:37.240
I'm going to start by
talking about NS Application.

00:20:37.290 --> 00:20:42.160
Because everybody's writing application,
so everybody has exactly one

00:20:42.160 --> 00:20:44.600
instance of NS Application.

00:20:45.770 --> 00:20:49.270
Now, NS Application is important
because it manages your connection

00:20:50.260 --> 00:20:52.120
with the Windows Server.

00:20:52.220 --> 00:20:56.340
It'll set up the connection, and when the
Windows Server receives events,

00:20:56.420 --> 00:21:00.330
it'll dispatch them to the application,
who then will appropriately forward

00:21:00.330 --> 00:21:02.970
them off to whoever needs to get them.

00:21:03.690 --> 00:21:09.600
NS Application is also important because
it gives you hooks to customizing

00:21:09.600 --> 00:21:11.590
typical application behavior.

00:21:11.670 --> 00:21:15.430
So, for instance,
if you need to customize and do something

00:21:15.460 --> 00:21:19.380
special in application termination,
there's hooks for you to

00:21:19.630 --> 00:21:21.830
customize that behavior.

00:21:23.160 --> 00:21:26.440
Okay, everybody has an application,
so they got an NS application.

00:21:26.620 --> 00:21:29.000
Everybody also typically
will have Windows.

00:21:29.000 --> 00:21:33.110
And then Window is the guy who reserves
screen real estate and provides you

00:21:33.110 --> 00:21:35.980
a place to put your topmost view.

00:21:36.980 --> 00:21:41.760
Ennis Window is also the guy who
Application will forward events off to,

00:21:41.760 --> 00:21:45.690
and then it will figure out,
based on the event,

00:21:45.770 --> 00:21:47.190
who needs to receive that.

00:21:47.260 --> 00:21:51.210
So clicks go to the view under the mouse,
key events go to whichever view currently

00:21:51.210 --> 00:21:53.120
wants to receive keyboard events.

00:21:53.120 --> 00:21:55.800
Through some of the magic that
you heard Scott talk about,

00:21:55.800 --> 00:22:00.990
we can dispatch these keyboard events
off to dynamically figure out what

00:22:00.990 --> 00:22:02.940
object wants to handle keyboard events.

00:22:03.200 --> 00:22:05.570
And again,
Ennis Window is where you'll find our

00:22:05.690 --> 00:22:09.550
support for advanced features such
as drawers and transparent sheets.

00:22:12.830 --> 00:22:15.940
NSView is where you're
going to do your drawing.

00:22:15.940 --> 00:22:19.520
NSView handles lots of details
that you don't want to handle.

00:22:19.560 --> 00:22:22.180
So some of you might
really enjoy this stuff,

00:22:22.350 --> 00:22:26.260
but typically most people don't want to
worry about managing the view hierarchy,

00:22:26.270 --> 00:22:28.380
worrying about coordinate
system transformations,

00:22:28.380 --> 00:22:31.390
view to screen transforms,
or worrying about clipping.

00:22:31.400 --> 00:22:33.810
It's all done for you in Cocoa.

00:22:34.140 --> 00:22:38.230
Also,
NSView provides basic UI functionality

00:22:38.240 --> 00:22:40.630
that you're used to having around,
like, drag and drop,

00:22:40.630 --> 00:22:43.400
context-sensitive menus, and help tags.

00:22:45.380 --> 00:22:49.080
Again, off the shelf,
there are many instances of NSView that

00:22:49.080 --> 00:22:51.420
you can just use in your application,
such as NSTextView,

00:22:51.520 --> 00:22:53.830
which you saw Doug use earlier,
or NSMovieView,

00:22:53.830 --> 00:22:57.570
which plays QuickTime movies,
and there's a number of other views.

00:22:57.600 --> 00:23:01.210
Now, if you want to make your own view
that does your own whiz-bang,

00:23:01.380 --> 00:23:04.380
custom, really cool drawing,
all you need to do is subclass

00:23:04.480 --> 00:23:07.390
NSView and override the methods
that you're interested in.

00:23:07.400 --> 00:23:10.270
So if you want to draw,
which you're all going to do,

00:23:10.270 --> 00:23:11.710
you override drawRect.

00:23:11.800 --> 00:23:15.020
If you want to handle mouse-down events,
you override mouse-down.

00:23:15.300 --> 00:23:17.940
Any other event that you want to handle,
you just override that

00:23:17.970 --> 00:23:19.220
method in order to handle it.

00:23:21.680 --> 00:23:25.640
NSView is where you do your drawing,
and Cocoa provides you lots

00:23:25.780 --> 00:23:27.350
of options for drawing.

00:23:27.520 --> 00:23:31.420
In particular, we have NS Bezier Path,
which allows you to

00:23:31.430 --> 00:23:32.370
do path-based drawing.

00:23:32.440 --> 00:23:35.430
Lots of things that you're familiar
with with path-based drawing,

00:23:35.450 --> 00:23:40.320
such as curve to point, stroke fill,
set a dash pattern.

00:23:41.460 --> 00:23:45.200
NSImage is our class that provides
an abstraction over images.

00:23:45.200 --> 00:23:52.040
So we support images like TIFF, JPEG,
bitmaps, anything else that you typically

00:23:52.040 --> 00:23:54.100
would expect QuickTime to support.

00:23:54.480 --> 00:23:57.110
And the nice thing here is that
it's an abstraction on images,

00:23:57.110 --> 00:23:59.820
so we can add support for new images,
in fact, which we have in the past,

00:23:59.930 --> 00:24:05.000
like PDF, and your application gets that
new functionality without even

00:24:05.000 --> 00:24:07.380
knowing that it existed previously.

00:24:08.100 --> 00:24:12.000
We also have the ability to draw strings.

00:24:12.000 --> 00:24:14.230
So strings know how to draw themselves.

00:24:14.250 --> 00:24:16.640
A class I haven't mentioned
yet is NSAttributedString.

00:24:16.640 --> 00:24:20.030
That's our abstraction on styled text.

00:24:20.140 --> 00:24:22.600
We also have abstractions
for colors and fonts.

00:24:22.600 --> 00:24:25.650
And again, in the past we've added
functionality for things like

00:24:25.650 --> 00:24:29.040
pattern colors or true type fonts.

00:24:29.320 --> 00:24:33.090
And we've done this without
changing the API in those classes,

00:24:33.090 --> 00:24:36.590
so clients have been able to pick
up new functionality without having

00:24:36.590 --> 00:24:40.770
any idea that it would have existed
at some point in the future.

00:24:40.990 --> 00:24:43.730
And if you need to do your
own graphics transforms,

00:24:43.740 --> 00:24:46.210
we have NS Affine Transformation.

00:24:46.210 --> 00:24:49.340
Now, there's lots of options for drawing,
but if your needs are exceptional,

00:24:49.340 --> 00:24:51.900
you can always use Quartz drawing.

00:24:51.900 --> 00:24:53.850
Again,
Cocoa is not an isolated component.

00:24:53.900 --> 00:24:56.900
It can use other
components in the system.

00:24:57.090 --> 00:24:59.580
Sony CG functions can be used.

00:25:00.360 --> 00:25:03.240
At this point,
I'd like to bring Doug back up on stage.

00:25:03.290 --> 00:25:06.860
He's going to give you a demo on
how to actually subclass NSVU,

00:25:06.920 --> 00:25:09.480
how to draw, and how to handle events.

00:25:09.570 --> 00:25:09.570
Doug?

00:25:10.610 --> 00:25:11.840
Thanks, Chuck.

00:25:11.840 --> 00:25:12.480
OK.

00:25:12.480 --> 00:25:15.980
Now, this time, I promise we're actually
going to see some code.

00:25:16.010 --> 00:25:18.680
So what we're going to do
right now is what might be the

00:25:18.710 --> 00:25:21.250
beginnings of an image editor,
perhaps.

00:25:21.270 --> 00:25:24.890
We'll draw an image,
and we'll allow the user to click and

00:25:24.890 --> 00:25:27.480
drag to make a rectangle selection.

00:25:27.580 --> 00:25:29.770
So I've already created
the project for us.

00:25:29.780 --> 00:25:33.180
And here in Interface Builder,
instead of a text view,

00:25:33.180 --> 00:25:39.390
I put in a custom view and set it
to be my custom subclass of NSView.

00:25:42.500 --> 00:25:46.200
Back in Project Builder,
let's take a look.

00:25:46.200 --> 00:25:51.110
I've added a few lines already to the
implementation of my custom subclass.

00:25:51.180 --> 00:25:53.000
Actually, just two methods.

00:25:53.010 --> 00:25:56.940
For demo purposes,
I have hard-coded a specific image.

00:25:57.250 --> 00:26:00.930
Now, really, the only interesting line

00:26:01.340 --> 00:26:03.670
In this code so far is this one.

00:26:03.670 --> 00:26:07.700
And this is in our draw rect,
our custom draw rect method.

00:26:07.700 --> 00:26:11.890
And what this line says is
that we want to draw the entire

00:26:11.890 --> 00:26:13.630
image in our entire bounds.

00:26:13.630 --> 00:26:16.460
And that by itself is
enough to draw the image.

00:26:16.460 --> 00:26:20.680
But we also want to do the
click and drag selection thing.

00:26:20.680 --> 00:26:22.700
So let's add some lines.

00:26:22.700 --> 00:26:26.340
First of all,
I'm going to add a couple of instance

00:26:26.340 --> 00:26:33.830
variables to keep track of where
the user has clicked and dragged.

00:26:43.610 --> 00:26:46.280
Keep track of the start
point where the user started,

00:26:46.300 --> 00:26:49.480
click,
and the end point where they drag to.

00:26:50.500 --> 00:26:55.900
And next, what I need to do...

00:27:03.320 --> 00:27:08.140
is add just a couple of methods
to keep track of those things.

00:27:08.140 --> 00:27:11.100
So first of all,
I have my mouse down method.

00:27:11.100 --> 00:27:14.140
That's going to be called
automatically when the user clicks.

00:27:14.140 --> 00:27:18.350
And all that this method does is
to set both the start point and the

00:27:18.440 --> 00:27:23.520
end point to the location of that
mouse click in our view coordinates.

00:27:23.550 --> 00:27:26.580
And then we say that we
need to read Redisplayed.

00:27:26.830 --> 00:27:30.690
And then we have another method,
mouse dragged.

00:27:31.400 --> 00:27:34.490
Which will be automatically
called when the user drags.

00:27:34.490 --> 00:27:38.680
And all that does is to set the endpoint,
just the endpoint, to, again,

00:27:38.680 --> 00:27:43.120
to the location the mouse was
dragged to in the view's coordinates.

00:27:43.210 --> 00:27:47.370
Now, given these two points,
it's fairly straightforward to compute

00:27:47.370 --> 00:27:50.860
the rectangle that they determine,
and I have a little

00:27:50.860 --> 00:27:53.120
function that does that,
too.

00:27:56.350 --> 00:27:59.140
It's about as long as the
rest of the code in this app,

00:27:59.140 --> 00:27:59.900
actually.

00:27:59.900 --> 00:28:02.370
I'm going to insert that.

00:28:06.700 --> 00:28:14.820
The final thing we need to do is
actually draw that selection rectangle.

00:28:16.520 --> 00:28:21.160
So let me get that.

00:28:21.160 --> 00:28:24.240
I'm going to add that to our draw rect.

00:28:25.970 --> 00:28:30.290
And what this says is that if the start
point and the end point are not the same,

00:28:30.480 --> 00:28:34.530
then we set an appropriate color,
in this case red.

00:28:34.660 --> 00:28:37.400
and create a Bezier path.

00:28:37.400 --> 00:28:40.980
In this case, the path is just a rect,
being the rect determined

00:28:40.980 --> 00:28:42.510
by those points,
and stroke it.

00:28:42.560 --> 00:28:46.360
Simple enough.

00:28:46.360 --> 00:28:48.290
Let's see if it builds.

00:28:53.540 --> 00:28:57.500
Let's try running it.

00:28:57.500 --> 00:28:59.420
Now, here's our application.

00:28:59.530 --> 00:29:02.520
It draws the image that I've hard-coded.

00:29:02.790 --> 00:29:08.540
Notice again it scales nicely,
automatically, no code needed for that.

00:29:08.620 --> 00:29:13.130
And I click and drag,
there's my selection.

00:29:25.470 --> 00:29:29.610
Thank you again, Doug.

00:29:29.710 --> 00:29:32.600
OK,
so now I've talked about NS Application,

00:29:32.670 --> 00:29:34.710
NS Window, and NS View.

00:29:34.860 --> 00:29:39.040
And the attentive ones in the audience
have noticed I've skipped one class.

00:29:39.080 --> 00:29:40.750
That's everyone, right?

00:29:41.000 --> 00:29:45.600
NS Responder is the common
superclass of all these classes

00:29:45.600 --> 00:29:46.900
I've already talked about.

00:29:46.980 --> 00:29:50.300
And the reason is they all share
some similar functionality.

00:29:50.370 --> 00:29:54.460
In particular,
all NS Responders can receive events.

00:29:54.570 --> 00:29:57.620
And again,
events in Cocoa arrive as methods.

00:29:57.680 --> 00:30:00.560
So if you're interested
in keyboard events,

00:30:00.630 --> 00:30:04.310
your subclass of NS Responder
will override the key down

00:30:04.460 --> 00:30:07.970
event -- key down method,
excuse me.

00:30:08.230 --> 00:30:11.260
NS Responder also introduces
another important concept

00:30:11.520 --> 00:30:13.700
called the Responder Chain.

00:30:13.740 --> 00:30:18.780
And every subclass of NS Responder
can be in this Responder Chain.

00:30:18.820 --> 00:30:21.280
Now, the Responder Chain works like this.

00:30:21.300 --> 00:30:24.580
Every window knows who
its first responder is.

00:30:24.820 --> 00:30:28.180
Every responder knows who
its next responder is,

00:30:28.300 --> 00:30:29.410
and so on down the line.

00:30:29.410 --> 00:30:32.690
And so this forms a responder chain.

00:30:32.710 --> 00:30:35.040
What will happen is,
when events come into the system,

00:30:35.040 --> 00:30:37.660
they get dispatched, typically,
to the first responder.

00:30:37.930 --> 00:30:43.320
If it doesn't want to handle it,
it gets passed down the

00:30:43.320 --> 00:30:43.320
responder chain until it finds
someone that wants to handle it.

00:30:48.830 --> 00:30:52.320
So typically,
you're probably not interested in knowing

00:30:52.340 --> 00:30:58.340
about actual very low-level events
like mouse clicks or key-down events.

00:30:58.340 --> 00:31:01.030
You're really concerned with,
was this button clicked,

00:31:01.030 --> 00:31:03.620
or was the slider manipulated,
things like that.

00:31:03.620 --> 00:31:06.320
This is where NSControl comes into play.

00:31:06.320 --> 00:31:11.420
As you can see, NSControl is a subclass
of NSResponder and NSView,

00:31:11.430 --> 00:31:15.160
which means it inherits lots of
functionality from these classes.

00:31:15.160 --> 00:31:18.620
However,
NSControl has some important differences.

00:31:19.960 --> 00:31:23.060
NS Control is defined as something
that's typically triggered

00:31:23.060 --> 00:31:24.940
or activated by user action.

00:31:24.940 --> 00:31:28.830
Again, button clicks on a button,
a click on a button.

00:31:28.920 --> 00:31:32.780
Examples would be NS Button,
NS Text Field, or more advanced controls

00:31:32.780 --> 00:31:34.610
even like Outline Views.

00:31:35.070 --> 00:31:37.530
Now, again,
I said it inherits lots of functionality,

00:31:37.610 --> 00:31:40.900
but it also has some
important differences.

00:31:40.900 --> 00:31:43.940
Every control has a target
object and an action method.

00:31:44.040 --> 00:31:46.480
I'm going to get into this
in detail in a little bit,

00:31:46.550 --> 00:31:48.880
so let me just leave that for now.

00:31:49.200 --> 00:31:51.090
Controls also have values
that can be queried,

00:31:51.130 --> 00:31:54.400
so I might need to know that the
slider's current value is 0.5,

00:31:54.430 --> 00:31:58.370
or that a text field's current
string is something or other.

00:31:58.910 --> 00:32:02.010
Also, since controls are typically
things that I can click on,

00:32:02.140 --> 00:32:04.040
I need to be able to enable
them and disable them.

00:32:04.040 --> 00:32:06.600
So control has support for that.

00:32:07.010 --> 00:32:10.470
Target action is a very
important concept in Cocoa,

00:32:10.490 --> 00:32:13.090
and this is what makes some of
that magic that Scott Forstall was

00:32:13.160 --> 00:32:15.340
talking about earlier possible.

00:32:16.820 --> 00:32:19.640
The idea here is that when
a control is triggered,

00:32:19.700 --> 00:32:22.790
it has a target that is going
to tell I was triggered.

00:32:22.900 --> 00:32:27.640
So the target object is the guy
that gets sent an action method.

00:32:27.870 --> 00:32:31.750
In Cocoa, targets can be nil,
and when the target's nil,

00:32:31.750 --> 00:32:34.960
the message will go to
the first responder.

00:32:35.340 --> 00:32:38.270
And again, if the first responder doesn't
implement that action method,

00:32:38.280 --> 00:32:40.400
it goes down the chain until
it finds someone that wants it.

00:32:40.480 --> 00:32:43.870
So,
this is how cut is implemented in Cocoa,

00:32:43.920 --> 00:32:45.080
typically.

00:32:45.080 --> 00:32:50.140
When the user clicks and drags
down to the cut menu item,

00:32:50.140 --> 00:32:52.330
we haven't actually
hard-coded in a target.

00:32:52.340 --> 00:32:53.600
The target's nil.

00:32:53.600 --> 00:32:57.600
And so what will happen is,
the frontmost window, its first responder

00:32:57.600 --> 00:32:59.050
will get a cut message.

00:32:59.100 --> 00:33:02.030
If it doesn't actually implement cut,
it'll go down the chain until

00:33:02.030 --> 00:33:05.680
it finds your custom view,
which implements the cut message.

00:33:07.180 --> 00:33:10.220
So again,
you can imagine how much gory detail

00:33:10.220 --> 00:33:13.270
and management you'd have to do
if you had to actually manage who

00:33:13.270 --> 00:33:15.870
the current target was and keep
track of what window's in front.

00:33:15.920 --> 00:33:19.510
That's all taken care of you
through the beauty of the first

00:33:19.510 --> 00:33:22.710
responder chain and target action.

00:33:23.870 --> 00:33:25.930
At this point,
we'll bring Doug Davidson back

00:33:25.930 --> 00:33:27.690
up on stage,
and he's going to show you how

00:33:28.130 --> 00:33:30.400
target action works in Cocoa.

00:33:30.430 --> 00:33:31.750
Thanks, Chuck.

00:33:31.840 --> 00:33:35.020
So this time, we're going to build on
our previous example,

00:33:35.020 --> 00:33:39.350
and we're going to add an action
method to our custom view.

00:33:39.440 --> 00:33:42.370
And to do that,
we're going to pay a little

00:33:42.370 --> 00:33:44.800
closer attention to scaling.

00:33:44.880 --> 00:33:51.760
So I'm going to add a few

00:33:55.600 --> 00:33:57.050
A little bit more code here.

00:33:57.060 --> 00:34:06.240
Now, first of all, I have one method,
setScale.

00:34:06.240 --> 00:34:11.000
It will set the scale on our
view to some float value.

00:34:11.000 --> 00:34:17.160
Now, in Cocoa,
every view has two rectangle parameters.

00:34:17.160 --> 00:34:19.960
One is its frame,
which determines it in the

00:34:19.960 --> 00:34:22.140
external coordinate system.

00:34:22.410 --> 00:34:27.320
And the other is its bounds,
which determines its size in

00:34:27.320 --> 00:34:29.020
the internal coordinate system.

00:34:29.040 --> 00:34:33.380
So to scale this view,
all that we're doing is setting

00:34:33.380 --> 00:34:38.070
the frame size to be the
size times the scale factor,

00:34:38.070 --> 00:34:41.940
and setting the bound size
to be our original size,

00:34:41.940 --> 00:34:47.500
just the hard-coded size of the image,
and again saying that we need redisplay.

00:34:48.240 --> 00:34:51.760
And also, when we get loaded,
we want to set the default

00:34:51.760 --> 00:34:55.080
scale to some value of 1.

00:34:55.080 --> 00:34:58.750
Now, our action method is this one.

00:34:59.290 --> 00:35:01.740
called Take Scale From.

00:35:01.750 --> 00:35:06.200
And what that does is to set our
scale based on a value determined

00:35:06.200 --> 00:35:08.100
from the sender of the action method.

00:35:08.100 --> 00:35:10.780
In this case,
we're going to have the sender

00:35:10.780 --> 00:35:12.200
of the action method be a slider.

00:35:12.200 --> 00:35:16.630
The value of the slider is just
determined by the position of the slider.

00:35:16.630 --> 00:35:20.310
So the slider will tell the
view what its scale should be.

00:35:24.000 --> 00:35:28.830
Let's take a look at our
interface in Interface Builder.

00:35:28.840 --> 00:35:35.470
Now we're going to take our view,
and I want to group it into a scroll view

00:35:35.480 --> 00:35:38.270
so we make sure we can always see it.

00:35:39.400 --> 00:35:42.400
Let's make this window a little bigger.

00:35:42.400 --> 00:35:45.530
Move this thing around a bit.

00:35:45.560 --> 00:35:53.540
Now, here I'll get a slider, drag it on,
position it the way I want it.

00:35:56.500 --> 00:35:59.320
I've set some nice values for it.

00:35:59.340 --> 00:36:03.980
It goes from 0.5 to 1.5,
and it starts at 1.

00:36:04.800 --> 00:36:07.700
Now I need to hook this up.

00:36:07.780 --> 00:36:10.580
Here's the magic of Interface Builder.

00:36:12.800 --> 00:36:17.500
I'm going to drag,
saying that the target of

00:36:17.500 --> 00:36:21.440
my slider is my custom view,
and the method it's

00:36:21.480 --> 00:36:22.780
called is takeScaleFrom.

00:36:22.780 --> 00:36:28.730
Now let's see if this will build.

00:36:35.000 --> 00:36:41.500
[Transcript missing]

00:36:42.000 --> 00:36:45.460
And the slider tells the
view how to take its scale.

00:36:45.460 --> 00:36:48.500
If it's too big, we can scroll around.

00:36:48.500 --> 00:36:49.960
We can still make our selection.

00:36:49.960 --> 00:36:55.950
And we're all set.

00:36:59.900 --> 00:37:02.020
Thank you very much.

00:37:02.410 --> 00:37:06.100
Let me assure you that Doug doesn't
normally program using stickies.

00:37:08.130 --> 00:37:12.310
Some of the beauty of what
you saw here was that because,

00:37:12.330 --> 00:37:15.100
again,
Objective-C has very good introspection,

00:37:15.100 --> 00:37:21.980
Interface Builder knew that it has
these methods that it can wire together.

00:37:23.500 --> 00:37:27.640
So we've talked now a lot about
classes and specific functionality.

00:37:27.640 --> 00:37:31.540
And although that's some of
what makes Cocoa powerful,

00:37:31.600 --> 00:37:35.420
it's some of the concepts that
we use in Cocoa which make it

00:37:35.490 --> 00:37:37.030
really unique and powerful.

00:37:37.040 --> 00:37:40.960
So I want to talk about, in particular,
some design patterns that

00:37:41.050 --> 00:37:42.850
are used throughout Cocoa.

00:37:45.160 --> 00:37:49.500
In particular, the notifications,
sometimes referred to

00:37:49.500 --> 00:37:52.130
as the observer pattern,
delegation,

00:37:52.210 --> 00:37:54.890
and the model view controller paradigm.

00:37:55.080 --> 00:37:59.150
Notifications are a way to broadcast
happenings throughout an application

00:37:59.160 --> 00:38:00.960
or even to other applications.

00:38:01.000 --> 00:38:05.140
Those interested in knowing about a
happening will register as an observer.

00:38:05.770 --> 00:38:07.980
Typically, in Cocoa,
some of the things you can

00:38:07.980 --> 00:38:10.900
register as observers for are,
"Tell me when a window will

00:38:10.910 --> 00:38:14.790
close," or "Tell me when a text
did begin editing." However,

00:38:14.790 --> 00:38:18.740
you wouldn't expect notifications to be
used for really low-level things like

00:38:18.870 --> 00:38:21.230
"Disc did spin," or something like that.

00:38:22.960 --> 00:38:26.350
So observers have to register
with somebody to say,

00:38:26.390 --> 00:38:28.300
hey, tell me when this event happens.

00:38:28.480 --> 00:38:30.760
That guy is the notification center.

00:38:30.810 --> 00:38:35.120
Notification center is sort of the
glue that makes notifications work.

00:38:35.810 --> 00:38:40.820
What happens is, observers register with
the notification center,

00:38:41.110 --> 00:38:43.690
telling them the name of the
notification they're interested in and

00:38:43.700 --> 00:38:45.800
the object that they want to monitor.

00:38:45.900 --> 00:38:48.490
And also,
they provide a method to be called

00:38:48.490 --> 00:38:50.800
when the notification is posted.

00:38:51.350 --> 00:38:55.220
Now, you don't actually have to tell it
what object you want to monitor.

00:38:55.230 --> 00:38:57.660
You can say,
"The object I'm monitoring is

00:38:57.670 --> 00:39:00.930
nil." And when you do that,
you say, "I want to monitor all objects

00:39:00.990 --> 00:39:04.090
for a particular notification."
So I might want to know when any

00:39:04.090 --> 00:39:05.660
window in my application closed.

00:39:05.660 --> 00:39:08.150
I do this by specifying nil.

00:39:08.610 --> 00:39:10.590
Posters are the ones who
post the notification.

00:39:10.600 --> 00:39:14.500
They post the name and any additional
information which may be valuable.

00:39:14.500 --> 00:39:17.450
For instance, what window is closing.

00:39:19.120 --> 00:39:22.810
Delegation is a powerful design
pattern that allows one object

00:39:22.810 --> 00:39:25.000
to act on behalf of another.

00:39:25.130 --> 00:39:27.240
Typically,
it's a way to provide you a way

00:39:27.240 --> 00:39:31.670
to customize an object's behavior
without having to subclass.

00:39:31.780 --> 00:39:35.890
So, NS Application has a
number of delegate methods.

00:39:36.490 --> 00:39:40.390
One called Applications Should Terminate
and Applications Open File.

00:39:40.420 --> 00:39:44.100
So if I want to customize
my applications termination,

00:39:44.160 --> 00:39:46.630
I provide a delegate who
does some special work in

00:39:46.700 --> 00:39:48.680
Applications Should Terminate.

00:39:51.260 --> 00:39:54.660
Okay, so at first,
notification and delegation somewhat

00:39:54.670 --> 00:39:57.290
sound like similar concepts,
and they are because you're sending

00:39:57.320 --> 00:39:59.500
messages when things happen.

00:39:59.560 --> 00:40:02.200
But they have some important differences.

00:40:02.460 --> 00:40:06.680
With delegation, there can only be one
delegate per object.

00:40:06.740 --> 00:40:10.270
Much like with the Highlander,
there can be only one.

00:40:12.110 --> 00:40:14.200
However, there can be many observers.

00:40:14.260 --> 00:40:17.140
And because of this,
you'll notice that with our APIs,

00:40:17.200 --> 00:40:19.680
delegates typically
receive should messages.

00:40:19.750 --> 00:40:22.790
They're allowed to affect
behavior because there's only one.

00:40:23.020 --> 00:40:26.440
However, notification observers will
receive will or did type messages.

00:40:26.500 --> 00:40:29.020
There's no way for you to affect it.

00:40:29.430 --> 00:40:33.140
So let me give sort of a
contrived example of making a U.S.

00:40:33.140 --> 00:40:33.600
law.

00:40:33.600 --> 00:40:38.360
In this example, the House makes the law,
and we'll say the President's our

00:40:38.360 --> 00:40:42.020
delegate in this situation because
he's allowed to veto the law when

00:40:42.060 --> 00:40:44.590
he's asked should the law pass.

00:40:44.700 --> 00:40:48.870
Now once the law finally passes,
all of us out here as notification

00:40:48.870 --> 00:40:53.260
observers learn about it through
the notification the law did pass.

00:40:53.260 --> 00:40:54.130
It did pass.

00:40:54.130 --> 00:40:56.030
We don't have any way to affect it.

00:40:56.590 --> 00:41:00.170
Of course, there's always voting,
but we know sometimes that doesn't

00:41:00.230 --> 00:41:01.810
actually work in all places.

00:41:03.990 --> 00:41:09.820
Okay, so another design pattern that we
use throughout Cocoa and has already

00:41:09.820 --> 00:41:13.760
been mentioned a couple times is
the model-view-controller paradigm.

00:41:13.840 --> 00:41:18.400
In this paradigm,
the model stores the data.

00:41:18.500 --> 00:41:20.560
However, typically it's more than
just a simple data store.

00:41:20.560 --> 00:41:24.340
It knows how to perform intelligent
operations or business logic or

00:41:24.470 --> 00:41:26.170
things like that on the data.

00:41:26.570 --> 00:41:28.270
However, it's separate from the view.

00:41:28.280 --> 00:41:32.760
It doesn't know any particulars about
any view that it's being displayed in.

00:41:32.770 --> 00:41:35.800
The view knows nothing about the data.

00:41:36.270 --> 00:41:40.960
It just knows how to display
typically some simple types,

00:41:40.960 --> 00:41:42.080
but it's separated from--

00:41:42.360 --> 00:41:51.560
The Cocoa APIs are a powerful
tool for creating full-featured

00:41:51.560 --> 00:41:57.230
desktop applications for Mac OS X.

00:41:57.230 --> 00:41:57.230
The Cocoa APIs include low-level utility,
system interaction, internationalization,

00:41:57.230 --> 00:41:57.230
internet,
and platform independence classes,

00:41:57.230 --> 00:41:57.230
as well as a rich set of
user-interface components and a

00:41:57.230 --> 00:41:57.230
powerful and extensible text system.

00:41:57.230 --> 00:41:57.230
This session provides an
overview of Cocoa APIs.

00:41:57.290 --> 00:42:01.920
So I'm going to talk a little bit more
about it in the next couple slides,

00:42:01.920 --> 00:42:05.260
and I'll usually talk about
it and just call it MVC.

00:42:07.330 --> 00:42:12.840
Okay, so I'm going to hit on a number
of application-level topics,

00:42:12.840 --> 00:42:15.990
some which MVC affect and some which
are just application-level topics

00:42:16.110 --> 00:42:19.100
that you'll be interested in when
you're developing your application.

00:42:19.120 --> 00:42:21.990
In particular,
if you're writing a document

00:42:21.990 --> 00:42:25.360
sort of application,
Cocoa has a wonderful document

00:42:25.430 --> 00:42:29.270
architecture that you'll be
interested in knowing more about.

00:42:30.230 --> 00:42:33.860
Every application on Mac OS X should
have undo support and be scriptable.

00:42:33.860 --> 00:42:36.310
And typically,
you're going to want to be able

00:42:36.310 --> 00:42:40.690
to talk to the clipboard or have
preferences in your application.

00:42:42.910 --> 00:42:45.900
OK, document architecture.

00:42:46.110 --> 00:42:50.230
It provides you a number of standard
features that you want to have in an

00:42:50.230 --> 00:42:53.060
application that works with documents.

00:42:53.130 --> 00:42:57.740
As you saw earlier in Doug's demo,
we had a document-based application that

00:42:57.840 --> 00:43:00.860
ran open panels and save panels for us.

00:43:00.910 --> 00:43:02.900
We didn't write any code to do that.

00:43:02.960 --> 00:43:06.070
It also managed the
document edited status.

00:43:06.160 --> 00:43:10.380
Again, these are mundane things that you
typically don't want to have to reinvent.

00:43:10.830 --> 00:43:13.700
Now, for you to make a
document-based application,

00:43:13.700 --> 00:43:15.880
all you're going to have to
do is provide routines that

00:43:15.990 --> 00:43:18.120
can load and store the data.

00:43:18.120 --> 00:43:20.420
Again, stuff that we didn't
do in the earlier demo,

00:43:20.420 --> 00:43:24.130
but you provide the
custom logic to do that.

00:43:26.870 --> 00:43:29.640
Undo is very easy to do in Cocoa,
and for that reason,

00:43:29.760 --> 00:43:31.490
every application should be undoable.

00:43:31.490 --> 00:43:34.800
In fact, every Cocoa application,
as you heard before,

00:43:34.800 --> 00:43:36.560
already has undo support.

00:43:36.560 --> 00:43:40.320
In particular, the text system has
built-in undo support.

00:43:40.340 --> 00:43:43.130
And if you need to add
your own undo support,

00:43:43.130 --> 00:43:46.310
all you need to do is that
when your model changes,

00:43:46.310 --> 00:43:50.170
you register an undo operation
with the NSUndoManager.

00:43:50.540 --> 00:43:54.070
And again,
since undo typically wants to be

00:43:54.070 --> 00:43:59.140
registered when your model changes,
a good separation of your model and view

00:43:59.140 --> 00:44:01.600
will make undo easy for you to implement.

00:44:04.900 --> 00:44:07.520
Scripting is also very
easy to implement in Cocoa,

00:44:07.520 --> 00:44:10.840
and again, that means every application
should be scriptable.

00:44:10.900 --> 00:44:13.080
Cocoa provides a lot for you already.

00:44:13.120 --> 00:44:15.940
We handle events from the
Apple Script Standard Suite,

00:44:15.940 --> 00:44:17.980
such as Open Print and so on.

00:44:18.030 --> 00:44:21.920
The text system provides a number of the
classes that you need in the text suite.

00:44:21.980 --> 00:44:25.160
And if you need to add your
own support for scripting,

00:44:25.190 --> 00:44:27.170
which you're all going to do,

00:44:27.870 --> 00:44:29.060
You don't have to do a lot of work.

00:44:29.230 --> 00:44:31.670
You have to edit a plist,
which again is this

00:44:31.800 --> 00:44:36.560
XML-based file format,
and you need to write a method or two.

00:44:36.690 --> 00:44:40.180
So it's very easy to do, and again,
since scripting acts through

00:44:40.180 --> 00:44:44.210
interfaces through the model,
a good separation of the model and the

00:44:44.210 --> 00:44:46.350
view makes scripting easy to implement.

00:44:51.160 --> 00:44:53.740
Typically, your application also
wants to have preferences.

00:44:53.750 --> 00:44:57.470
When you need to store preferences
to disk or read them from disk,

00:44:57.530 --> 00:45:02.190
you can talk to the
NSUserDefaults object.

00:45:02.590 --> 00:45:05.330
It stores preferences
per user per application.

00:45:05.390 --> 00:45:08.040
It also allows you to
access system preferences.

00:45:08.140 --> 00:45:11.440
So anything you see stored in
the system prefs application,

00:45:11.470 --> 00:45:13.760
you can access through NSUserDefaults.

00:45:13.780 --> 00:45:16.060
And also,
if you have a suite of applications,

00:45:16.140 --> 00:45:20.600
NSUserDefaults allows you to
share preferences between them.

00:45:22.400 --> 00:45:25.540
If you need to implement cut, copy,
paste, or something similar,

00:45:25.540 --> 00:45:28.360
you need to talk to the
clipboard or provided data,

00:45:28.360 --> 00:45:29.040
right?

00:45:29.150 --> 00:45:32.440
And its pasteboard is the object
that gives that functionality.

00:45:32.530 --> 00:45:37.330
In particular,
the data can be provided either

00:45:37.330 --> 00:45:39.840
immediately or in a lazy fashion.

00:45:39.900 --> 00:45:41.580
And of course,
we all prefer to be lazy because

00:45:41.660 --> 00:45:43.920
if we have some huge data,
we don't want to have to

00:45:43.980 --> 00:45:45.850
compute it if it's never needed.

00:45:47.140 --> 00:45:50.490
And its pasteboard also has
filtering services so that you can

00:45:50.550 --> 00:45:52.390
convert to the requested formats.

00:45:52.580 --> 00:45:55.020
And in fact,
we provide conversion of Mac OS 9

00:45:55.020 --> 00:45:56.730
types for you automatically.

00:45:59.350 --> 00:46:01.780
Okay, we covered a lot of stuff today.

00:46:01.810 --> 00:46:03.380
I made this thinking it
might be earlier in the day.

00:46:03.380 --> 00:46:05.950
I guess it's actually time to eat.

00:46:07.690 --> 00:46:10.330
What I'm hoping you take from the
talk today is that Cocoa gives

00:46:10.330 --> 00:46:11.780
you lots of functionality.

00:46:11.820 --> 00:46:15.010
You don't have to reimplement mundane
tasks that aren't interesting to you

00:46:15.170 --> 00:46:17.300
and don't add value to your product.

00:46:17.400 --> 00:46:21.640
You get to spend time working on features
which will help sell your product.

00:46:21.710 --> 00:46:23.380
Cocoa has lots of powerful concepts.

00:46:23.500 --> 00:46:27.010
More than just the classes and
the functionality of the classes,

00:46:27.060 --> 00:46:31.500
we have powerful concepts that we use
which make Cocoa unique and powerful.

00:46:31.570 --> 00:46:35.630
And again, I love free stuff,
and Cocoa gives you lots of it.

00:46:36.560 --> 00:46:39.430
So it's day one,
and we've got a lot of sessions

00:46:39.530 --> 00:46:41.640
left if you're interested in Cocoa.

00:46:41.640 --> 00:46:44.810
In particular, I would highly recommend
going to the Using Cocoa talk.

00:46:44.920 --> 00:46:46.370
There will be lots of code demos there.

00:46:46.430 --> 00:46:47.480
We didn't show a lot today.

00:46:47.500 --> 00:46:48.560
We're going to show a lot more there.

00:46:48.560 --> 00:46:52.240
The Advanced Cocoa talk is
actually for beginners to

00:46:52.240 --> 00:46:55.940
Cocoa and Cocoa experience folks,
so everyone should feel

00:46:55.940 --> 00:46:57.090
free to attend to that.

00:46:57.260 --> 00:47:00.560
And if you have feedback,
come to the feedback session on Friday.

00:47:02.000 --> 00:47:04.320
There's also a couple more things
you might be interested in.

00:47:04.440 --> 00:47:07.900
The project builder talk coming up,
interface builder,

00:47:07.960 --> 00:47:11.330
and learning about things such as NSURL.

00:47:11.340 --> 00:47:15.780
Again, one of these foundation
classes that I talked about.

00:47:16.560 --> 00:47:19.790
There's lots of documentation on your CD.

00:47:19.820 --> 00:47:21.960
The first thing I would recommend
checking out if you're new to

00:47:21.960 --> 00:47:25.530
Cocoa is the concepts documentation,
because that, again,

00:47:25.530 --> 00:47:29.680
is what I think makes
Cocoa unique and really powerful.

00:47:30.560 --> 00:47:32.780
There's lots of information elsewhere.

00:47:32.830 --> 00:47:35.030
There's your O'Reilly
book that you can go grab.

00:47:35.030 --> 00:47:39.160
And actually,
there's lots of Cocoa enthusiasts out on

00:47:39.160 --> 00:47:45.010
the net that provide things like mailing
lists and fax and free frameworks.

00:47:47.210 --> 00:47:50.050
Again, Heather Hickman is your
contact for anything Cocoa.

00:47:50.100 --> 00:47:55.430
There's a new Cocoa Development mailing
list that if you're

00:47:55.570 --> 00:47:57.700
doing Cocoa Development,
you should look into subscribing.
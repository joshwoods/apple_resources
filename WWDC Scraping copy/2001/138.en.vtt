WEBVTT

00:00:00.950 --> 00:00:01.740
I'm Mark Turner.

00:00:01.740 --> 00:00:06.080
I'm the Carbon Technology Manager in
Worldwide Developer Relations.

00:00:06.790 --> 00:00:12.120
CoreFoundation, as the name implies,
provides a fundamental set

00:00:12.800 --> 00:00:16.930
of system services that are
widely used throughout Mac OS X.

00:00:17.210 --> 00:00:20.630
And they're available for
your use as well through both

00:00:20.630 --> 00:00:25.100
Carbon and Cocoa and any other
application running on Mac OS X.

00:00:25.200 --> 00:00:28.700
And a subset of these services are
also available to Carbon apps on

00:00:28.700 --> 00:00:31.370
Mac OS 8 and 9 through CarbonLib.

00:00:31.600 --> 00:00:36.280
So, this morning we're going to get
a great overview of some of the

00:00:36.350 --> 00:00:40.590
services that you might like to
take advantage of in CoreFoundation.

00:00:40.590 --> 00:00:46.380
And to begin with, I'd like to introduce
Chris Kane from the CoreFoundation

00:00:46.420 --> 00:00:48.500
team to start off our overview.

00:00:48.700 --> 00:00:50.500
Welcome, Chris.

00:00:56.500 --> 00:00:58.500
Welcome.

00:00:58.500 --> 00:01:01.640
This session will be an overview
of the CoreFoundation framework.

00:01:01.670 --> 00:01:05.240
It's going to explain what it is,
describe some of the

00:01:05.330 --> 00:01:09.030
functionality it contains,
and review some of the general

00:01:09.030 --> 00:01:11.500
concepts of usage of CoreFoundation.

00:01:11.580 --> 00:01:14.610
I'll begin with an overview.

00:01:18.490 --> 00:01:21.730
CoreFoundation is a low-level
framework within Mac OS X.

00:01:21.750 --> 00:01:26.240
It's used to implement Mac OS X and
contains functionality that you can also

00:01:26.240 --> 00:01:28.850
use in your frameworks and applications,
as Mark said.

00:01:28.860 --> 00:01:33.070
Both of the higher-level frameworks,
Cocoa and Carbon,

00:01:33.070 --> 00:01:35.640
use CoreFoundation quite a bit.

00:01:37.060 --> 00:01:41.270
Part of CoreFoundation, as Mark said,
is also available on

00:01:41.270 --> 00:01:44.900
Mac OS 9 and 8 via CarbonLib.

00:01:44.900 --> 00:01:48.590
This was done to ease porting of
carbonized apps to Mac OS X and

00:01:48.590 --> 00:01:52.400
to bring some of the features of
CoreFoundation to the libraries

00:01:52.400 --> 00:01:55.000
and applications on 8 and 9.

00:01:55.130 --> 00:02:00.880
For similar reasons,
part of CoreFoundation is

00:02:00.880 --> 00:02:01.310
also available from Darwin,
or within Darwin.

00:02:02.140 --> 00:02:07.040
The CoreFoundation APIs are
C APIs on Mac OS X.

00:02:07.040 --> 00:02:09.600
Through CarbonLib,
they are also available in the

00:02:09.600 --> 00:02:11.990
languages supported by CarbonLib.

00:02:12.070 --> 00:02:19.080
There are also C++ wrappers
for CoreFoundation in Apple's

00:02:19.080 --> 00:02:19.080
C++ frameworks for Mac OS X.

00:02:19.600 --> 00:02:23.460
Finally,
I'll briefly note that CoreFoundation

00:02:23.460 --> 00:02:28.330
is often simply just called CF,
and I'll probably slip up during my

00:02:28.330 --> 00:02:32.340
talk and use that abbreviation myself,
so it's good for you to

00:02:32.340 --> 00:02:34.120
know right off the bat.

00:02:35.440 --> 00:02:41.090
Now, why did I call CoreFoundation
a low-level framework?

00:02:41.760 --> 00:02:45.230
Well, partly that is due to where it
sits in the overall organizational

00:02:45.230 --> 00:02:47.940
structure of Mac OS X.

00:02:48.050 --> 00:02:51.140
Here we see the usual simplified
diagram of the structure of the

00:02:51.140 --> 00:02:54.170
system frameworks on Mac OS X.

00:02:55.060 --> 00:03:02.190
CoreFoundation slips in as part of
the core services umbrella framework.

00:03:02.350 --> 00:03:07.060
But I also called CoreFoundation a
low-level framework because it deals with

00:03:07.180 --> 00:03:13.490
some of the most basic building blocks
of your applications and your frameworks.

00:03:13.770 --> 00:03:15.700
These are the data structures
that you use to store

00:03:15.700 --> 00:03:19.110
information in your application.

00:03:19.190 --> 00:03:23.380
CoreFoundation provides several basic
opaque data structures that you can use

00:03:23.380 --> 00:03:25.920
rather than having to write your own.

00:03:26.160 --> 00:03:33.220
And CoreFoundation also provides several
higher-level application services,

00:03:33.220 --> 00:03:35.630
which are built upon
the basic data types.

00:03:35.690 --> 00:03:43.710
And again,
Apple system applications and system

00:03:43.710 --> 00:03:45.550
frameworks within Mac OS X use
these facilities quite extensively.

00:03:46.180 --> 00:03:50.390
One of the key aspects of CoreFoundation
is that it does not provide any

00:03:50.390 --> 00:03:53.670
graphics or media-related features.

00:03:53.760 --> 00:03:59.180
In the architecture of Mac OS X,
graphics and fonts and sounds

00:03:59.230 --> 00:04:06.580
and those sorts of things are
introduced in higher-level frameworks,

00:04:06.650 --> 00:04:09.580
frameworks at a higher level
than CoreFoundation within

00:04:09.580 --> 00:04:09.580
that architectural diagram.

00:04:13.070 --> 00:04:17.540
So let's begin by looking at
some of those basic data types.

00:04:17.540 --> 00:04:19.970
We start with CFString.

00:04:20.670 --> 00:04:24.200
A data type representing
strings of characters.

00:04:24.200 --> 00:04:29.360
Strings tend to be one of the most
common data structures in an application,

00:04:29.360 --> 00:04:33.820
and in Mac OS X,
CFStrings are certainly the most

00:04:33.820 --> 00:04:36.740
common CoreFoundation data type in use.

00:04:38.020 --> 00:04:42.260
Conceptually, a CFString is an array
of Unicode characters.

00:04:42.640 --> 00:04:47.030
However, because the implementation
is hidden behind the opaque

00:04:47.140 --> 00:04:52.320
CFString type and its functions,
a CFString can be smart about how

00:04:52.320 --> 00:04:57.050
it stores those characters and
use 8-bit encodings if possible or

00:04:57.150 --> 00:05:00.210
do other tricks for performance.

00:05:00.590 --> 00:05:05.070
This takes strings beyond
the traditional domain of,

00:05:05.260 --> 00:05:11.080
say, an array of 255 characters,
as in Pascal,

00:05:11.080 --> 00:05:19.120
in some encoding that is currently in
use in the system or in the application.

00:05:19.120 --> 00:05:23.020
By packaging up the characters,
the length,

00:05:23.020 --> 00:05:28.100
and a fixed encoding in one type,
use of strings in an

00:05:28.100 --> 00:05:29.500
application is simplified.

00:05:30.500 --> 00:05:34.350
And this makes things like
internationalization easier.

00:05:34.710 --> 00:05:39.460
Plus, by making the structure and nature
of a string more predictable,

00:05:39.460 --> 00:05:43.630
passing and sharing strings among
different parts of an application

00:05:43.810 --> 00:05:47.960
and frameworks is made much simpler.

00:05:47.960 --> 00:05:56.720
CFString has become the way to pass
string data between library APIs,

00:05:56.720 --> 00:06:00.880
framework APIs,
and applications in Mac OS X,

00:06:00.880 --> 00:06:06.070
and is a primary way in which
strings are just simply stored

00:06:06.070 --> 00:06:09.120
within an application as well.

00:06:10.870 --> 00:06:15.940
And as new APIs are introduced,
they are going to use CFStrings as their

00:06:15.940 --> 00:06:19.110
parameters and return values as well.

00:06:20.540 --> 00:06:23.690
Now,
CFString is an abstract data structure,

00:06:23.690 --> 00:06:27.730
so in addition to the opaque data type,
there are, of course,

00:06:27.730 --> 00:06:30.880
a bunch of functions,
a bunch of operations on CFStrings.

00:06:30.880 --> 00:06:34.990
First of all,
there are many ways to create a CFString.

00:06:34.990 --> 00:06:38.800
You can create them from a Pascal string,
from a C string.

00:06:38.800 --> 00:06:43.370
You can create them from an
array of bytes and an encoding.

00:06:43.370 --> 00:06:51.650
You can also create them from other data,
if you will, like ints and what have you,

00:06:51.650 --> 00:06:58.730
using formatting functionality similar
to the C language's printf function.

00:06:59.380 --> 00:07:02.700
There are also several ways to
extract the characters of a string

00:07:02.700 --> 00:07:08.440
and do encoding conversions,
for example, on byte data,

00:07:08.480 --> 00:07:12.340
converting them to and from strings.

00:07:12.340 --> 00:07:16.830
This is very handy when you're
getting information off the internet,

00:07:16.830 --> 00:07:23.980
for example, and need to convert that
WinLatin1 HTML page into something

00:07:23.980 --> 00:07:26.160
you can more directly use.

00:07:27.160 --> 00:07:30.880
There are also many other
common and useful operations.

00:07:30.880 --> 00:07:35.790
I give two examples here of
appending and concatenation

00:07:35.790 --> 00:07:38.720
and finding type operations.

00:07:40.170 --> 00:07:43.950
In addition to CFString,
CoreFoundation provides a number of

00:07:44.040 --> 00:07:47.880
other basic data type abstractions,
and here are some of them,

00:07:47.890 --> 00:07:49.110
not all of them.

00:07:49.110 --> 00:07:53.320
These are sometimes just simple
wrapper objects for simple data types.

00:07:53.320 --> 00:07:57.980
For example, CFBoolean represents
either true or false,

00:07:58.010 --> 00:08:01.020
and that's very straightforward.

00:08:01.020 --> 00:08:04.530
But most of the time,
these data structures also

00:08:04.530 --> 00:08:07.250
provide other useful operations.

00:08:07.250 --> 00:08:11.460
As an example,
there are a few types to represent dates

00:08:11.460 --> 00:08:16.330
and times provided by CoreFoundation,
and there are also some operations

00:08:16.470 --> 00:08:19.760
to work with the Gregorian
calendar representation of dates,

00:08:19.760 --> 00:08:22.560
you know, years, months, days, hours,
etc.

00:08:22.560 --> 00:08:29.050
These functions can do things like
figure out what day of the week it is,

00:08:29.370 --> 00:08:31.000
or what day of the week
it's the day of the week.

00:08:31.000 --> 00:08:35.970
what the date will be, say,
90 days from now.

00:08:36.330 --> 00:08:41.000
And those are just representative
examples of some of the functionality.

00:08:41.000 --> 00:08:46.670
Now, some of these types may seem to be
really too simple to be useful API,

00:08:46.680 --> 00:08:50.060
but they sometimes come in handy
when dealing with collections.

00:08:50.060 --> 00:08:53.440
And as we'll see in a bit,
many of these are central

00:08:53.440 --> 00:08:56.300
pieces of the property list
mechanism in CoreFoundation.

00:08:56.300 --> 00:09:00.860
But for now, I'm going to talk about the
collection data structures in CF,

00:09:00.910 --> 00:09:02.280
CoreFoundation.

00:09:02.720 --> 00:09:06.520
A collection is something that
groups together other objects,

00:09:06.520 --> 00:09:11.260
and it generally does not matter what
the type of those other objects is.

00:09:11.280 --> 00:09:14.770
In the case of the
CoreFoundation collections,

00:09:14.780 --> 00:09:18.260
it is most convenient to store
other CoreFoundation objects.

00:09:19.730 --> 00:09:22.510
However,
the operations of the collections

00:09:22.580 --> 00:09:25.990
with respect to the type of
data that they can hold can be

00:09:25.990 --> 00:09:30.720
configured with callback functions
to hold any pointer-sized values.

00:09:30.850 --> 00:09:35.290
For example, you can configure a
collection to hold integers.

00:09:35.370 --> 00:09:38.210
The callback functions determine
what happens when custom

00:09:38.250 --> 00:09:43.060
values are added and removed,
and how they are compared when

00:09:43.570 --> 00:09:48.750
comparison-type operations
are applied to a collection.

00:09:49.630 --> 00:09:54.030
The usefulness of these collections is
that they can manage the memory for you,

00:09:54.120 --> 00:09:56.980
and I'm going to begin by talking
about two of the collections,

00:09:56.980 --> 00:09:58.580
CFArray and CFDictionary.

00:09:58.580 --> 00:10:00.940
First we have the CFArray.

00:10:00.940 --> 00:10:05.830
Like an array in the C language,
the values are kept in order and

00:10:05.830 --> 00:10:11.030
are retrieved out of a CFArray using
a zero-based integer index.

00:10:11.180 --> 00:10:17.100
The diagram on the right is showing
this mapping from indices to values.

00:10:18.520 --> 00:10:23.670
Unlike a CFArray, though,
the values are kept compact in

00:10:23.670 --> 00:10:28.700
that if you remove an element
from the middle of an array,

00:10:28.710 --> 00:10:33.930
the values with higher indices are
shifted down one in order to keep the,

00:10:33.930 --> 00:10:38.510
what you might call the index space,
the indices that you would

00:10:38.540 --> 00:10:42.520
use to access elements,
keep those contiguous.

00:10:42.810 --> 00:10:51.400
In addition to using a
CFArray like an array,

00:10:51.400 --> 00:10:51.400
it is quite common to use
them as stacks and queues.

00:10:53.710 --> 00:10:57.560
The other collection I'm going
to review today is CFDictionary.

00:10:57.650 --> 00:11:02.140
With a CFArray, the pointer-sized values
were indexed by integer.

00:11:02.140 --> 00:11:07.180
In a CFDictionary,
the values are indexed by keys,

00:11:07.180 --> 00:11:11.050
and you can see this in the diagram,
which are themselves often

00:11:11.050 --> 00:11:16.970
other CoreFoundation objects,
but can be any pointer-sized values.

00:11:16.980 --> 00:11:21.720
In the diagram,
the strings are being used as the keys.

00:11:21.720 --> 00:11:25.710
If I asked for the
value with the name key,

00:11:25.710 --> 00:11:31.770
for example, at the top there,
the dictionary would return me value 1.

00:11:32.010 --> 00:11:41.440
A CFDictionary is somewhat
like a struct in C,

00:11:41.440 --> 00:11:42.840
although you don't want to go
and change all your structures in

00:11:42.840 --> 00:11:42.840
your C code to use CFDictionary's.

00:11:43.020 --> 00:11:48.320
There's a time and a place for
CFDictionary's and for structs.

00:11:48.410 --> 00:11:55.690
Also, unlike a CFArray,
the values in the dictionary are

00:11:55.820 --> 00:12:01.200
not kept in any particular order,
and this is because CFDictionary is

00:12:01.200 --> 00:12:01.200
based on hashing for fast access
performance to the elements.

00:12:01.870 --> 00:12:05.900
And again, to reiterate,
one of the principal values of these

00:12:05.920 --> 00:12:10.790
collections is that they take care of the
memory storage and algorithms for you.

00:12:10.890 --> 00:12:15.540
CFDictionary and CFArray are both
heavily used in the frameworks

00:12:15.540 --> 00:12:18.180
and applications of Mac OS X.

00:12:18.230 --> 00:12:22.020
And though it might surprise you,
CFDictionary actually tends to

00:12:22.150 --> 00:12:23.980
be more popular than CFArray.

00:12:24.160 --> 00:12:28.330
Dictionary just turns out to be a
very convenient way to structure

00:12:28.340 --> 00:12:30.980
data inside of an application.

00:12:32.960 --> 00:12:35.940
One of the ways in which
CoreFoundation uses these basic

00:12:36.100 --> 00:12:40.470
data types and collections
together is in property lists.

00:12:40.520 --> 00:12:44.520
A property list is a group
of CF objects of these types:

00:12:44.520 --> 00:12:52.570
CFString, CFData, CFNumber, CFBoolean,
CFDate, CFArray, and CFDictionary,

00:12:52.650 --> 00:12:58.240
and only objects of those seven types.

00:12:59.000 --> 00:13:02.360
An additional restriction is
that keys of a dictionary in a

00:13:02.360 --> 00:13:05.610
property list must be CFStrings,
that any dictionary

00:13:05.610 --> 00:13:07.300
within a property list.

00:13:07.300 --> 00:13:11.720
So any object or group of
objects which satisfies these

00:13:11.720 --> 00:13:14.560
constraints is a property list.

00:13:14.580 --> 00:13:18.770
For example,
a single CFString is a property list.

00:13:18.770 --> 00:13:22.880
A single CFNumber is a property list.

00:13:23.600 --> 00:13:27.090
But more often,
a property list is a collection

00:13:27.090 --> 00:13:29.720
or collection of collections.

00:13:29.720 --> 00:13:33.930
For example, you might have an array
with dictionaries in it,

00:13:33.960 --> 00:13:36.220
and the dictionaries may have
dictionaries inside them,

00:13:36.220 --> 00:13:41.030
and they have keys and values,
which are numbers and booleans and so on.

00:13:42.560 --> 00:13:47.230
The special thing about property lists,
this group of objects,

00:13:47.230 --> 00:13:51.090
special type of group,
is that there is a persistent,

00:13:51.140 --> 00:13:54.280
sometimes called
flattened representation,

00:13:54.280 --> 00:13:58.280
which is an XML-based representation.

00:13:58.280 --> 00:14:03.910
So if you have a property list in memory,
you can easily flatten it

00:14:03.910 --> 00:14:07.070
and write it to a file,
for example,

00:14:07.070 --> 00:14:10.390
or send it to another application.

00:14:11.760 --> 00:14:15.220
Later, you can, for example,
if you've written it to a file,

00:14:15.230 --> 00:14:18.650
read the file back in and
reproduce the original object

00:14:18.790 --> 00:14:24.420
graph by using CoreFoundation
to decode the XML representation

00:14:24.420 --> 00:14:26.900
back into the original objects.

00:14:26.900 --> 00:14:32.080
A file which contains a flattened
property list is itself often

00:14:32.110 --> 00:14:37.810
referred to as a property list,
and so the term is used for both on-disk

00:14:37.830 --> 00:14:43.400
representations of property lists,
and the in-memory representation

00:14:43.450 --> 00:14:45.540
of the actual objects in use.

00:14:45.540 --> 00:14:49.860
Property lists are used extensively
in Mac OS X as configuration

00:14:49.860 --> 00:14:53.880
files and for storage of
preferences and similar things.

00:14:53.880 --> 00:14:58.410
For example,
applications in Mac OS X are bundles,

00:14:58.410 --> 00:15:03.930
which are represented by CFBundle,
and inside of a bundle

00:15:03.930 --> 00:15:07.540
is a property list,
which is the configuration

00:15:07.540 --> 00:15:10.700
information for that CFBundle,
for that application.

00:15:11.080 --> 00:15:14.130
We'll be discussing
CFBundle later in this talk.

00:15:14.190 --> 00:15:16.520
I'm not going to go
into it more right now.

00:15:18.520 --> 00:15:22.060
Property lists are also often
simply a useful way of modeling

00:15:22.060 --> 00:15:24.130
information in an application.

00:15:24.240 --> 00:15:27.670
For example, a property list could
describe a print job,

00:15:27.670 --> 00:15:32.610
and a print server might keep
a CFArray as a queue of print

00:15:32.690 --> 00:15:35.620
jobs that need to be serviced.

00:15:36.520 --> 00:15:41.210
Here we have just a few of the property
lists of a fictitious print job.

00:15:41.320 --> 00:15:46.320
This is not taken from any
actual use on Mac OS X.

00:15:46.320 --> 00:15:50.320
Note that all of the keys in
the dictionary are strings.

00:15:50.320 --> 00:15:53.960
The keys are on the left,
but the values over on the right

00:15:54.080 --> 00:15:59.800
are a mixture of strings and
dates and booleans and numbers.

00:16:00.240 --> 00:16:06.340
The dictionary could also contain values
which are arrays or other dictionaries,

00:16:06.340 --> 00:16:13.470
but for space reasons,
we haven't shown that in this diagram.

00:16:13.470 --> 00:16:13.470
OK.

00:16:13.470 --> 00:16:13.470
Let me get that.

00:16:17.500 --> 00:16:25.980
Now that you've seen some examples
of what CoreFoundation contains,

00:16:25.980 --> 00:16:31.030
let's talk about some of
the overriding philosophies,

00:16:31.030 --> 00:16:31.030
concepts,
and conventions used in CoreFoundation.

00:16:31.260 --> 00:16:34.720
These are the keys to understanding
CoreFoundation really,

00:16:34.750 --> 00:16:39.620
because once you understand these,
you understand the basic operation

00:16:39.620 --> 00:16:41.760
of all CoreFoundation APIs.

00:16:41.800 --> 00:16:45.630
Often higher-level APIs,
which are based upon CoreFoundation,

00:16:45.700 --> 00:16:48.750
have also adopted these conventions.

00:16:48.770 --> 00:16:51.880
Picking up a new bit of
CoreFoundation APIs or those

00:16:51.880 --> 00:16:57.760
higher-level APIs which use the same
conventions is thus much simpler,

00:16:57.800 --> 00:17:03.320
and you only have to really concentrate
on what those specific APIs do,

00:17:03.350 --> 00:17:08.510
what their specific behaviors are,
and not

00:17:09.120 --> 00:17:13.040
You have to worry about figuring out what
the memory management conventions are,

00:17:13.040 --> 00:17:15.500
for example, for those APIs.

00:17:15.510 --> 00:17:21.020
In particular,
it is important to understand the

00:17:21.020 --> 00:17:27.530
memory management strategy and
conventions of CoreFoundation,

00:17:27.530 --> 00:17:27.530
because without that understanding,
you really cannot make

00:17:27.530 --> 00:17:27.530
proper use of CoreFoundation.

00:17:29.200 --> 00:17:32.310
The general philosophy behind
CoreFoundation was to create a

00:17:32.310 --> 00:17:39.200
high-performance general utility
API that could be used as a substrate,

00:17:39.230 --> 00:17:44.110
that is an underlying layer,
beneath both Carbon and Cocoa.

00:17:44.490 --> 00:17:48.540
We took many concepts that
were already in Cocoa and

00:17:48.540 --> 00:17:55.560
recast them down into a C API,
which could have wider utility.

00:17:55.560 --> 00:17:57.400
More people could make use of it.

00:17:57.610 --> 00:18:01.550
And at the same time,
we extended them with

00:18:01.550 --> 00:18:01.550
some additional features.

00:18:01.840 --> 00:18:06.710
The most important aspect to the
design was that the CoreFoundation

00:18:06.710 --> 00:18:08.580
API should be consistent.

00:18:08.580 --> 00:18:15.590
An API with a high degree of consistency
feels like a more unified and cohesive

00:18:15.590 --> 00:18:21.140
API than one without consistency,
and it is much simpler

00:18:21.140 --> 00:18:25.240
to use a cohesive API,
much more natural,

00:18:25.240 --> 00:18:30.680
and much more efficient.

00:18:30.680 --> 00:18:31.870
The coreFoundation API is a
very simple and easy-to-use API.

00:18:32.840 --> 00:18:37.900
We also decided to design the
API around object-oriented models.

00:18:38.010 --> 00:18:43.020
This gave us a way to logically structure
the API and a means to more easily

00:18:43.020 --> 00:18:45.780
separate interface from implementation.

00:18:45.780 --> 00:18:50.340
For example, nearly all data types in
CoreFoundation are opaque,

00:18:50.340 --> 00:18:53.530
and you don't know how
they are implemented.

00:18:53.540 --> 00:18:57.780
This also allows Apple to make
improvements in the implementation

00:18:57.780 --> 00:19:01.960
over time without being constrained
by open data structures.

00:19:03.020 --> 00:19:06.200
However,
it also means that all CoreFoundation

00:19:06.200 --> 00:19:10.750
objects are essentially going
to be allocated off the heap.

00:19:14.240 --> 00:19:18.350
In part to achieve the goal
of high performance API,

00:19:18.370 --> 00:19:22.140
we decided to limit the
types of validation and

00:19:22.140 --> 00:19:27.340
checking that the API does,
limit those to runtime errors.

00:19:27.490 --> 00:19:32.080
Thus, there's very little checking
of programming errors like

00:19:32.080 --> 00:19:34.560
passing in wrong parameters.

00:19:34.660 --> 00:19:37.710
In the production version of the library,

00:19:38.050 --> 00:19:43.450
Which is the one normally that
users are running against.

00:19:43.480 --> 00:19:48.900
We don't have a lot of these,
any programming error type checks.

00:19:48.900 --> 00:19:51.960
We put these instead in the
debug version of the library,

00:19:51.960 --> 00:19:57.100
which uses assertions and other
checks to look for these sorts of

00:19:57.100 --> 00:20:03.160
programming errors like passing in a
bad type of object or what have you.

00:20:03.160 --> 00:20:07.790
One of the ways to run against the
debug version of the library is

00:20:07.790 --> 00:20:12.390
explained in the CoreFoundation
release notes on the system.

00:20:15.730 --> 00:20:18.820
To ensure consistency,
we adopted several naming

00:20:18.820 --> 00:20:20.700
and argument conventions.

00:20:20.820 --> 00:20:23.740
A few of them are listed here,
not all of them, certainly.

00:20:23.740 --> 00:20:28.780
The abstract data types and most
higher-level functionality is

00:20:28.780 --> 00:20:33.200
grouped into classes or modules,
like in many object-oriented

00:20:33.200 --> 00:20:34.660
or modular languages.

00:20:34.660 --> 00:20:39.670
We've seen several examples already,
like CFString and CFNumber.

00:20:40.540 --> 00:20:44.450
The type of an instance of
such a class is named with the

00:20:44.450 --> 00:20:49.540
class name plus the term ref,
and that is an opaque reference

00:20:49.540 --> 00:20:52.750
to an object of that class.

00:20:52.940 --> 00:20:55.940
The operations on that
type are functions,

00:20:55.940 --> 00:21:00.340
then, that begin with the class name,
just as the type does,

00:21:00.340 --> 00:21:02.640
and then name the operation.

00:21:02.660 --> 00:21:05.810
So, in this example on the slide,
we have CFString,

00:21:05.810 --> 00:21:08.600
which is the name of the class,
appendFormat,

00:21:08.600 --> 00:21:10.790
which is the name of the operation.

00:21:11.820 --> 00:21:16.660
Another example would
be CFArray.getCount,

00:21:16.750 --> 00:21:19.380
which would return the
number of elements,

00:21:19.380 --> 00:21:24.280
the number of values in the CFArray at
the time you called that function.

00:21:26.160 --> 00:21:29.960
Also, in this object-oriented way,
the first argument to these

00:21:29.970 --> 00:21:33.920
operations is always the object
which is to be operated upon.

00:21:33.920 --> 00:21:38.330
So, for example,
in CFStringAppend format,

00:21:38.520 --> 00:21:43.910
you know that the first argument
is going to be a CFString.

00:21:44.640 --> 00:21:49.780
The exception, of course,
is functions which create new objects.

00:21:49.780 --> 00:21:51.590
We call these create functions.

00:21:52.280 --> 00:21:55.770
Obviously, in that case,
there's no object for

00:21:55.790 --> 00:21:57.940
them to operate upon.

00:21:57.940 --> 00:22:00.590
They're creating a new object.

00:22:03.430 --> 00:22:07.010
Two other object-oriented
concepts we adopted in

00:22:07.010 --> 00:22:11.410
CoreFoundation to limited extents,
because of course we're

00:22:11.430 --> 00:22:16.530
operating in the C language,
which is not naturally object-oriented,

00:22:16.530 --> 00:22:20.540
are polymorphism and introspection.

00:22:20.540 --> 00:22:23.790
A polymorphic function is
one which can operate on many

00:22:23.790 --> 00:22:25.660
different types of values.

00:22:26.620 --> 00:22:31.640
In CoreFoundation we have eight
functions which can accept

00:22:31.640 --> 00:22:37.060
references to any type of CF object.

00:22:37.440 --> 00:22:44.000
as their parameters.

00:22:44.000 --> 00:22:46.320
And of course, in some cases,
they also return CF types,

00:22:46.320 --> 00:22:46.320
which are CF objects.

00:22:47.060 --> 00:22:51.060
These are used to provide
general functionality across all

00:22:51.060 --> 00:22:52.440
of the core foundation types.

00:22:52.440 --> 00:22:54.560
Let's see.

00:22:54.560 --> 00:22:58.730
As an example,
to find out what type an object is,

00:22:58.750 --> 00:23:03.280
you would use the function cfgettypeid,
the introspection function

00:23:03.280 --> 00:23:06.130
there in the middle,
cfgettypeid,

00:23:06.130 --> 00:23:13.180
and pass it as an argument a cfobject,
or what you believe to be a cfobject.

00:23:13.540 --> 00:23:15.800
You would compare its return value.

00:23:15.800 --> 00:23:17.650
It returns a type code.

00:23:17.660 --> 00:23:21.960
You would compare that return value
with the type codes published by

00:23:21.960 --> 00:23:25.720
every core foundation type in its API.

00:23:28.450 --> 00:23:32.080
So, as I said earlier,
one of the most important things

00:23:32.080 --> 00:23:37.290
to understand about CoreFoundation
is its memory management strategy.

00:23:38.200 --> 00:23:47.630
Reference counting is used on
all CoreFoundation objects.

00:23:47.630 --> 00:23:47.630
For those of you who don't
know what that means,

00:23:48.520 --> 00:23:54.040
In short, reference counting means that
each object keeps track of the

00:23:54.040 --> 00:23:56.400
number of owners that it has.

00:23:56.400 --> 00:23:58.310
That's one way to think about it,
at least.

00:23:58.380 --> 00:24:02.290
When the number of owners
of an object is zero,

00:24:02.290 --> 00:24:05.030
the object can be destroyed.

00:24:05.100 --> 00:24:09.270
An object may have many different
logical owners in different

00:24:09.330 --> 00:24:12.270
parts of an application,
and generally they don't

00:24:12.300 --> 00:24:15.550
know about one another,
so reference counting is a way to

00:24:15.550 --> 00:24:22.180
make sure that an object does not get
destroyed while it is still in use,

00:24:22.200 --> 00:24:25.360
before it is no longer useful.

00:24:29.880 --> 00:24:41.760
So, CFRetain, which is one of the
polymorphic functions,

00:24:41.770 --> 00:24:43.300
is used to what we call take a reference,
or increment the reference

00:24:43.300 --> 00:24:43.300
count of a CF object.

00:24:43.860 --> 00:24:50.570
This is sometimes called having
a retain on the object as well,

00:24:50.590 --> 00:24:56.810
because CFRetain is used to
increment the reference count.

00:24:57.000 --> 00:25:01.110
The function CFRelease is used to give
up your part ownership in an object.

00:25:01.170 --> 00:25:06.150
CoreFoundation's objects automatically
destroy themselves when their

00:25:06.150 --> 00:25:07.800
reference count drops to zero.

00:25:07.800 --> 00:25:09.400
You don't need to do that.

00:25:09.500 --> 00:25:15.580
But you do need to get rid of
any references that you do have,

00:25:15.580 --> 00:25:15.580
and I'll be talking about that.

00:25:16.060 --> 00:25:20.380
If you have a variable which
is referencing a CoreFoundation

00:25:20.550 --> 00:25:24.530
object but no retain on the object,
it could be destroyed out

00:25:24.530 --> 00:25:28.210
from under you at any time,
and there is really no way to

00:25:28.220 --> 00:25:30.760
find out that this has happened.

00:25:30.760 --> 00:25:36.340
That's called a dangling reference,
and dangling references,

00:25:36.380 --> 00:25:45.560
just as in Mac OS 9 or any other system,
can cause app misbehavior or a crash.

00:25:46.100 --> 00:25:51.500
[Transcript missing]

00:25:52.170 --> 00:26:01.690
CFRetain is used to
explicitly take reference,

00:26:01.740 --> 00:26:03.610
but sometimes a retain is automatically
given to you when you get an object,

00:26:03.610 --> 00:26:03.610
say, as a return value.

00:26:03.680 --> 00:26:06.930
These automatic retains,
in addition to the ones you

00:26:06.930 --> 00:26:10.640
explicitly do with CFRetain,
must be released later when

00:26:10.640 --> 00:26:12.750
you no longer need the object.

00:26:12.820 --> 00:26:16.220
If you don't do that,
the memory is not going to be freed,

00:26:16.220 --> 00:26:19.860
and you're going to have a leak,
which will cause your app to use

00:26:19.860 --> 00:26:21.480
more memory than it needs to.

00:26:23.210 --> 00:26:25.430
So you have to know when
you need to explicitly make

00:26:25.520 --> 00:26:29.180
yourself an owner of an object,
and know when you have been

00:26:29.260 --> 00:26:31.280
given an ownership in an object.

00:26:31.290 --> 00:26:35.100
And this is a fundamental question
that arises for a developer.

00:26:35.100 --> 00:26:38.560
How do I own this particular object?

00:26:38.560 --> 00:26:41.530
To answer that question,
we develop conventions

00:26:41.530 --> 00:26:42.990
for CoreFoundation.

00:26:42.990 --> 00:26:45.790
As our example,
we're going to look at the naming

00:26:45.790 --> 00:26:49.600
convention for functions which
return CoreFoundation objects,

00:26:49.600 --> 00:26:52.820
as that is by far the most
significant convention.

00:26:54.320 --> 00:26:58.940
By convention in CoreFoundation,
if a function returns an object

00:26:58.940 --> 00:27:02.730
of a CoreFoundation type,
it uses the verb "get" if it

00:27:02.730 --> 00:27:07.390
is returning the object to you,
but not giving a retain on

00:27:07.390 --> 00:27:09.960
that object to you as well.

00:27:10.140 --> 00:27:13.190
That is,
it is not automatically returning a

00:27:13.260 --> 00:27:16.060
part ownership in that object to you.

00:27:16.210 --> 00:27:21.710
For example, CFDictionary get value

00:27:22.310 --> 00:27:25.390
would return the value
out of a CFDictionary,

00:27:25.390 --> 00:27:30.500
but would not give you a retain,
increment the reference count

00:27:30.500 --> 00:27:33.300
automatically on that object.

00:27:33.330 --> 00:27:40.690
And you should not release values
which are returned from get functions,

00:27:40.690 --> 00:27:40.690
or you will create a dangling reference.

00:27:40.980 --> 00:27:45.780
Functions which automatically do
retain a returned object for you

00:27:45.780 --> 00:27:51.980
use either the verbs copy or create,
depending on what the function's doing.

00:27:51.980 --> 00:27:56.180
Functions which create
new instances use create,

00:27:56.180 --> 00:27:57.520
for example.

00:27:57.520 --> 00:28:02.920
The objects you receive by calling
a create or copy function must

00:28:02.920 --> 00:28:08.010
have that retain released by you
when you are done with that object,

00:28:08.010 --> 00:28:09.700
or you're going to have a leak.

00:28:10.720 --> 00:28:13.980
This is so important it
really deserves repeating.

00:28:13.980 --> 00:28:20.510
Get functions never automatically
increment the reference count.

00:28:21.200 --> 00:28:29.190
Create functions and copy functions
always increment the reference count

00:28:29.190 --> 00:28:29.190
of objects that they are returning.

00:28:32.390 --> 00:28:35.950
So these conventions are for
the programmer's benefit.

00:28:35.960 --> 00:28:42.980
They're easy to remember,
and they're ways for you to know

00:28:42.980 --> 00:28:49.700
automatically when you see an API what
is happening with respect to the memory

00:28:49.700 --> 00:28:49.700
management of that returned object.

00:28:50.180 --> 00:28:55.490
The use of copy and create as verbs
should not be taken to mean that objects

00:28:55.540 --> 00:28:57.410
are always being copied or created.

00:28:57.410 --> 00:29:04.660
A copy or a new object would not be
created when it's not appropriate.

00:29:04.660 --> 00:29:08.660
For example,
sometimes it's done for efficiency.

00:29:09.800 --> 00:29:15.630
Another example would be a type which
kept a cache of all the objects,

00:29:15.630 --> 00:29:19.230
for example,
that it had created because it

00:29:19.230 --> 00:29:21.800
was uniquing them in some way.

00:29:21.800 --> 00:29:26.610
Create function might return
an object out of the cache

00:29:26.610 --> 00:29:29.390
rather than making a new one.

00:29:29.560 --> 00:29:35.980
But the reference count on that
returned object is always incremented,

00:29:35.980 --> 00:29:39.880
whether it's a cached
object or a new one.

00:29:39.980 --> 00:29:49.050
Well, and by the way, such a cache would
probably be implemented,

00:29:49.050 --> 00:29:49.590
often be implemented,
by using a CFDictionary,

00:29:49.590 --> 00:29:49.590
as I discussed earlier.

00:29:51.770 --> 00:29:53.820
Okay,
there's one final general facility that

00:29:53.820 --> 00:29:57.390
I'm going to discuss before we move on
to talking about some of the higher-level

00:29:57.390 --> 00:29:59.700
application services in CoreFoundation.

00:30:00.010 --> 00:30:02.680
That's what we call toll-free bridging.

00:30:02.760 --> 00:30:12.220
This is mostly a benefit for
Cocoa applications and frameworks,

00:30:12.220 --> 00:30:12.880
but it also helps a lot in a mixed
Cocoa and Carbon environment.

00:30:13.490 --> 00:30:18.310
Some of the basic data types in
CoreFoundation are bridged to

00:30:18.310 --> 00:30:22.630
their Cocoa counterparts such that
the CoreFoundation type and the

00:30:22.660 --> 00:30:25.060
Cocoa type are interchangeable.

00:30:25.060 --> 00:30:32.030
As the example at the bottom shows,
a simple cast is all that's needed

00:30:32.030 --> 00:30:39.540
to convert the Cocoa NSString to
a CoreFoundation CFStringRef,

00:30:39.790 --> 00:30:44.080
and vice versa, to convert a CFString to
a Cocoa NSString.

00:30:44.100 --> 00:30:50.290
This allows these CoreFoundation and
Cocoa objects to be easily shared

00:30:50.290 --> 00:30:54.500
and passed around the different
layers in the MACWIS10 architecture.

00:30:54.500 --> 00:30:59.720
The list of CoreFoundation bridge
types is in the Foundation release

00:30:59.720 --> 00:31:01.500
notes on the system.

00:31:01.500 --> 00:31:05.170
I haven't listed them here.

00:31:07.000 --> 00:31:09.990
Okay,
now I'd like to introduce Doug Davidson,

00:31:10.070 --> 00:31:12.580
who will take us through some
of the application services

00:31:12.580 --> 00:31:14.410
available from CoreFoundation.

00:31:14.420 --> 00:31:17.070
Doug?

00:31:22.310 --> 00:31:23.940
Thanks, Chris.

00:31:24.050 --> 00:31:28.700
So, first I'm going to talk briefly
about some basic application

00:31:28.700 --> 00:31:34.000
services available on both Mac OS 9
and Mac OS X that probably most

00:31:34.000 --> 00:31:35.730
applications are going to want to use.

00:31:35.730 --> 00:31:39.580
And then I'm going to go into
a little more depth on some

00:31:39.580 --> 00:31:44.690
advanced application services that
CoreFoundation provides on Mac OS X.

00:31:47.700 --> 00:31:49.900
So let's start with the
basic application services,

00:31:49.900 --> 00:31:53.350
CFBundle, CFPlugin, CFPreferences.

00:31:53.900 --> 00:33:06.700
[Transcript missing]

00:33:08.740 --> 00:33:13.600
CFBundle is the heart of
our localization strategy.

00:33:13.760 --> 00:33:16.710
This is what allows us to
ship Mac OS X simultaneously

00:33:16.710 --> 00:33:18.440
in many different languages.

00:33:18.440 --> 00:33:23.550
Because what CFBundle will do
is automatically provide you

00:33:23.640 --> 00:33:27.510
with the correctly localized
version of any particular resource

00:33:27.510 --> 00:33:31.510
based on the user's preferences.

00:33:32.450 --> 00:33:36.000
CFBundle also has some basic
code loading facilities.

00:33:36.000 --> 00:33:42.010
That is, it can load code and allow you
to look up symbols within it.

00:33:42.010 --> 00:33:45.650
And in particular,
it can do this transparently

00:33:45.840 --> 00:33:51.050
whether the code you're loading and
whether the code that is doing the

00:33:51.050 --> 00:33:53.880
loading is Maco or CFM on Mac OS X.

00:33:54.520 --> 00:33:58.230
Some of you have probably
already used this facility,

00:33:58.320 --> 00:34:01.950
for example,
to allow CFM executables on Mac OS X to

00:34:01.950 --> 00:34:04.420
use functionalities from Maco frameworks.

00:34:06.650 --> 00:34:10.680
Now,
the functionality that CFBundle provides

00:34:10.890 --> 00:34:13.770
is enough for basic loading of plug-ins.

00:34:13.770 --> 00:34:17.220
That is, you can load it and you can
look up entry points within it.

00:34:17.320 --> 00:34:21.200
But what it doesn't do is
manage the interface between the

00:34:21.350 --> 00:34:23.660
host and the plug-in for you.

00:34:23.780 --> 00:34:28.740
For that, we have a specialized kind
of CFBundle called CFPlugin.

00:34:29.050 --> 00:34:35.230
Now, it's possible you may already
have an interface between

00:34:35.280 --> 00:34:38.670
host and plug-in that you use,
and in that case,

00:34:38.670 --> 00:34:40.730
you might not be interested in CFPlugin.

00:34:40.730 --> 00:34:44.690
But if you're looking for such a thing,
you might want to consider CFPlugin.

00:34:44.690 --> 00:34:47.960
I'm not going to explain
in detail how it works now.

00:34:47.960 --> 00:34:54.360
It works,
the host looks up interfaces by UUIDs,

00:34:54.380 --> 00:35:01.190
where the interfaces are C++ or
COM style tables of function pointers,

00:35:01.190 --> 00:35:02.640
and those get passed back.

00:35:02.660 --> 00:35:07.220
The best place to learn about this is
through some examples that we have,

00:35:07.450 --> 00:35:12.340
both in the CoreFoundation documentation
on Mac OS X and in the CarbonLib SDK.

00:35:12.360 --> 00:35:18.410
You'll also find that there are a few
places on the system where... We use

00:35:18.410 --> 00:35:22.620
CFPlugin as our interface for plug-ins,
for example,

00:35:22.620 --> 00:35:26.270
for plug-ins for the printing
subsystem on Mac OS X.

00:35:29.170 --> 00:35:31.620
And finally, CFPreferences.

00:35:31.740 --> 00:35:38.300
This is our general facility for small,
flexible application preference storage.

00:35:38.300 --> 00:35:42.620
And these preferences are usually
both per user and per application,

00:35:42.620 --> 00:35:44.590
although there are other possibilities.

00:35:44.600 --> 00:35:48.530
And the way this works is
that any particular preference

00:35:48.830 --> 00:35:52.920
is referred to by a name,
which is just a CFString key.

00:35:54.090 --> 00:35:57.900
And the value of the preference
can be any property list type,

00:35:57.900 --> 00:35:59.580
so it's very flexible.

00:35:59.580 --> 00:36:05.340
All you do to store a preference is just
set that preference for the name key,

00:36:05.340 --> 00:36:09.120
the name, and you just look it up
by name when you want it.

00:36:09.120 --> 00:36:11.590
And CFPreferences takes
care of everything else,

00:36:11.650 --> 00:36:13.380
handles all the storage for you.

00:36:13.400 --> 00:36:16.170
Currently,
they're stored using the flattened

00:36:16.180 --> 00:36:18.740
XML representation for property lists.

00:36:20.600 --> 00:36:21.720
There are a couple of caveats.

00:36:21.820 --> 00:36:26.570
This is not intended for huge
caches or large chunks of binary

00:36:26.570 --> 00:36:29.770
data or anything like that.

00:36:29.940 --> 00:36:35.090
Also, you need to be sure that anything
your application absolutely

00:36:35.090 --> 00:36:36.960
relies on is not stored here.

00:36:36.960 --> 00:36:39.090
These are stored external
to the application,

00:36:39.090 --> 00:36:43.400
and it's possible that users
could erase their preferences.

00:36:43.400 --> 00:36:46.240
You should be prepared for the
possibility that preferences are

00:36:46.260 --> 00:36:48.100
missing or corrupted for some reason.

00:36:48.100 --> 00:36:52.140
But it is a very valuable
general facility.

00:36:52.140 --> 00:36:53.640
We use it all over the place.

00:36:53.640 --> 00:36:56.800
Many of our system preferences
are stored in this way.

00:36:57.310 --> 00:36:59.330
For example,
the user's language preferences

00:36:59.330 --> 00:37:03.820
that I mentioned in the case of
CFBundle are stored using CFPreferences.

00:37:07.090 --> 00:37:10.300
Okay,
next I want to go on to some advanced

00:37:10.300 --> 00:37:15.720
application services in Mac OS X,
starting with CFRunLoop,

00:37:15.770 --> 00:37:19.580
which is the basis for the rest of these,
and then I'll discuss some things

00:37:19.590 --> 00:37:21.660
that are enabled by CFRunLoop.

00:37:21.660 --> 00:37:23.900
So the RunLoop.

00:37:23.900 --> 00:37:25.230
What is a RunLoop?

00:37:27.210 --> 00:37:32.380
Carbon event-based applications
and Cocoa applications

00:37:32.430 --> 00:37:33.830
have something in common.

00:37:33.830 --> 00:37:36.960
That is,
they're both fundamentally event-driven.

00:37:36.960 --> 00:37:40.790
The way they work is, events come in,
they're passed to the

00:37:40.970 --> 00:37:43.700
application to be handled,
then controls return and you wait

00:37:43.700 --> 00:37:45.550
for something else to happen again.

00:37:45.550 --> 00:37:51.350
The fundamental mechanism that underlies
this in both cases is the RunLoop.

00:37:51.510 --> 00:37:56.380
- Now, we call it a run loop because we
say that it runs and that it loops,

00:37:56.520 --> 00:37:59.380
but mainly what it does is it waits.

00:37:59.380 --> 00:38:01.860
It waits for something
interesting to happen,

00:38:01.890 --> 00:38:06.470
tells you about it, you handle it,
and it goes back and waits again.

00:38:06.600 --> 00:38:10.460
And the thing it waits for can be
any of a wide variety of things.

00:38:10.460 --> 00:38:13.370
It might be the arrival
of a Mach message,

00:38:13.380 --> 00:38:17.170
it might be perhaps the
arrival of a network packet,

00:38:17.230 --> 00:38:21.380
it might be just the arrival
of some specific time.

00:38:21.910 --> 00:38:24.570
But the important thing about
the RunLoop is that it can

00:38:24.620 --> 00:38:28.680
wait for all of these things,
a wide variety of things simultaneously,

00:38:28.730 --> 00:38:33.400
efficiently, easily, without pulling,
without using processor resources.

00:38:33.400 --> 00:38:37.280
This turns out to be a
very powerful concept.

00:38:40.180 --> 00:38:45.100
Now, each thread has exactly
one RunLoop object.

00:38:45.200 --> 00:38:50.420
There may be many interfaces to it,
so CoreFoundation, through Carbon,

00:38:50.450 --> 00:38:53.240
through Cocoa, they're all dealing with
the same underlying object.

00:38:53.310 --> 00:38:54.640
You can use any or all of them.

00:38:55.140 --> 00:39:01.280
Typically,
you would want to use the highest level

00:39:01.280 --> 00:39:01.280
interface that suits your purposes.

00:39:01.500 --> 00:39:04.970
Often you'll be using it
through Carbon or Cocoa,

00:39:05.000 --> 00:39:09.470
but if you happen to be using
a CoreFoundation level source,

00:39:09.470 --> 00:39:13.420
something at the CoreFoundation
level that the RunLoop can wait for,

00:39:13.420 --> 00:39:16.740
then you would want to use the
CoreFoundation interface to it,

00:39:16.830 --> 00:39:18.060
which is CFRunLoop.

00:39:21.300 --> 00:39:26.450
Now, one thing about RunLoops is that you
may not want to wait for any possible

00:39:26.450 --> 00:39:29.590
type of event source at any given time.

00:39:29.600 --> 00:39:32.160
For example,
you might not want a certain timer

00:39:32.160 --> 00:39:35.940
to fire while you are tracking
mouse moves or something like that.

00:39:35.940 --> 00:39:40.890
So RunLoops have something called modes,
and at any given time,

00:39:40.890 --> 00:39:43.440
the RunLoop is running
in a specific mode,

00:39:43.440 --> 00:39:47.380
and any particular source is
registered with the RunLoop for

00:39:47.380 --> 00:39:49.420
only a certain set of modes.

00:39:50.760 --> 00:39:55.280
So, for example, in Cocoa,
there are a couple of specific

00:39:55.280 --> 00:39:57.870
defined modes that Cocoa uses.

00:39:57.900 --> 00:40:01.730
One, the modal panel RunLoop mode
is used when the modal panel

00:40:01.730 --> 00:40:03.660
is up and is waiting on that.

00:40:03.680 --> 00:40:07.860
There's another one that's used typically
when the mouse is being tracked.

00:40:07.860 --> 00:40:12.640
But normally, the RunLoop would be used
and run in the default mode.

00:40:12.660 --> 00:40:16.160
And when you register a
source with the RunLoop,

00:40:16.170 --> 00:40:20.250
you can register it with a
specific mode or set of modes,

00:40:20.320 --> 00:40:23.280
or you can choose to register
with the so-called common modes,

00:40:23.280 --> 00:40:27.900
which is a set of modes determined
by your application environment.

00:40:27.900 --> 00:40:30.470
In Cocoa,
it would be the default mode plus the

00:40:30.530 --> 00:40:32.920
modal panel and event tracking modes.

00:40:35.490 --> 00:40:38.240
Now, the RunLoop by itself is
not terribly interesting.

00:40:38.240 --> 00:40:40.990
What's interesting are the
things that it enables,

00:40:40.990 --> 00:40:42.690
the things you can do with it.

00:40:42.900 --> 00:40:51.200
So, at the CoreFoundation level,
some of the things that can wait for are,

00:40:51.200 --> 00:40:55.270
well, first of all,
you can use it to wait for raw

00:40:55.510 --> 00:40:59.300
Mach messages or raw network packets.

00:40:59.300 --> 00:41:02.870
And if you want to do that,
we have a CFMockPort for waiting

00:41:03.060 --> 00:41:08.620
for raw Mach messages or CFSocket
for waiting for events on a socket.

00:41:11.200 --> 00:41:16.240
That's useful, for example,
if you're in a Carbon or

00:41:16.240 --> 00:41:20.460
Cocoa application and you
want to wait for these things.

00:41:20.460 --> 00:41:23.630
You don't have to spawn a
separate thread to do that.

00:41:23.670 --> 00:41:24.920
You can simply be notified.

00:41:24.920 --> 00:41:27.750
You can get a function callback
within your main event loop.

00:41:31.980 --> 00:41:37.760
And I'm going to go into some other
CFRunLoop sources in just a moment.

00:41:37.790 --> 00:41:39.940
You can create your own.

00:41:39.940 --> 00:41:41.460
It is a little tricky to do so.

00:41:41.470 --> 00:41:45.780
So another thing I said you
could wait for is just the

00:41:45.780 --> 00:41:47.500
arrival of a specific time.

00:41:47.550 --> 00:41:51.680
And you can wait for a single
time or a repeating sequence of

00:41:51.700 --> 00:41:54.100
times with a CFRunLoop timer.

00:41:54.100 --> 00:42:00.100
What you do is you create the timer,
tell it what time or times to wait for,

00:42:00.140 --> 00:42:04.860
and you tell it what function will be
called back when that time arrives.

00:42:04.910 --> 00:42:10.690
And then you attach it to a run loop
in a given mode or set of modes.

00:42:10.740 --> 00:42:13.660
And when the run loop is
waiting in one of those modes,

00:42:13.660 --> 00:42:16.860
it checks to see if
your time has arrived.

00:42:16.900 --> 00:42:20.210
And if your time has arrived,
then you get a callback.

00:42:21.290 --> 00:42:24.880
Now, if you're waiting for a single time,
then the timer is automatically

00:42:25.000 --> 00:42:28.440
invalidated after that time has
arrived and the timer is fired.

00:42:28.440 --> 00:42:31.170
If you're waiting for a
repeating sequence of times,

00:42:31.170 --> 00:42:35.360
then you would have to invalidate the
timer yourself when you're done with it.

00:42:37.940 --> 00:42:41.140
Now, I talked about raw Mach messages.

00:42:41.140 --> 00:42:43.220
They have a lot of advantages.

00:42:43.220 --> 00:42:47.860
They're the fundamental low-level
local IPC mechanism in Mac OS X,

00:42:47.860 --> 00:42:51.300
and they're very powerful
and high performance,

00:42:51.300 --> 00:42:55.330
and they have a lot of flexibility,
but they can be difficult

00:42:55.460 --> 00:42:57.090
and tricky to use.

00:42:57.280 --> 00:43:01.260
So we also have a slightly,
just one higher level,

00:43:01.260 --> 00:43:05.990
one level up mechanism built on
top of them in CoreFoundation

00:43:05.990 --> 00:43:10.840
called CFMessagePort,
which is a high performance,

00:43:10.840 --> 00:43:14.240
low overhead local IPC mechanism.

00:43:15.600 --> 00:43:21.420
And you can use it either asynchronously,
sending messages one way,

00:43:21.420 --> 00:43:25.450
or synchronously,
sending a message and getting a reply.

00:43:26.480 --> 00:43:35.100
The way you use CFMessagePort is that you
create a local message port on one end,

00:43:35.100 --> 00:43:35.100
and

00:43:35.250 --> 00:43:39.320
And these built ports can be
advertised to other processes

00:43:39.370 --> 00:43:43.070
on the system with a name,
which again is just a CFString.

00:43:43.120 --> 00:43:46.850
And you create a remote
message port looked up by name

00:43:46.900 --> 00:43:51.510
to represent the other end,
the end to which you're sending.

00:43:51.840 --> 00:43:54.630
The message that you
send is just a CFData,

00:43:54.630 --> 00:43:59.880
that is a collection of bytes,
plus optionally a message ID, an integer.

00:43:59.880 --> 00:44:03.470
And the reply,
if you want to get a reply back,

00:44:03.470 --> 00:44:04.660
is a CFData.

00:44:04.660 --> 00:44:12.160
So what the intended receiver of
the message will do is to publish as

00:44:12.270 --> 00:44:15.160
API the protocol for this message.

00:44:16.680 --> 00:44:22.860
That is, how to interpret the data,
or the message ID of both,

00:44:22.910 --> 00:44:25.660
and whether there will be a reply
and how that should be interpreted.

00:44:27.150 --> 00:44:32.030
The sender would create a remote
message port to represent the port,

00:44:32.030 --> 00:44:37.020
the destination of the message,
and call CFMessagePort send request

00:44:37.030 --> 00:44:39.380
with the message to be sent.

00:44:39.380 --> 00:44:44.930
Then the receiver will be notified
within its RunLoop getting a callback,

00:44:44.990 --> 00:44:49.020
and if there's a reply,
the receiver would return the reply,

00:44:49.020 --> 00:44:53.680
and then the sender would get the reply,
and the message port send would return.

00:44:57.350 --> 00:45:02.680
Now, there's also another mechanism
that we have built on top of these,

00:45:02.680 --> 00:45:06.690
which is perhaps lesser known,
but very useful.

00:45:06.730 --> 00:45:10.140
And this is a broadcast
local IPC mechanism,

00:45:10.140 --> 00:45:12.300
CFNotificationCenter.

00:45:12.300 --> 00:45:21.620
And what this allows you to do is to post
happenings of any sort to an arbitrary,

00:45:21.670 --> 00:45:26.160
possibly unknown, set of receivers.

00:45:28.490 --> 00:45:32.190
These notifications are
identified by their name and

00:45:32.190 --> 00:45:34.940
optionally also by another string.

00:45:34.940 --> 00:45:37.040
The name, again, is just a CFString.

00:45:37.040 --> 00:45:40.820
Optionally also by another string
representing the object that sends them.

00:45:40.820 --> 00:45:45.570
And they can carry with them
essentially arbitrary data,

00:45:45.570 --> 00:45:47.850
again, a property list.

00:45:48.680 --> 00:45:52.220
In this case,
the sender would specify what sort of

00:45:52.220 --> 00:45:55.690
notifications it's going to send out,
what their names would be,

00:45:55.750 --> 00:45:58.390
and what sort of information
they would carry with them.

00:45:58.400 --> 00:46:02.240
And when the sender wants to
send one of these notifications,

00:46:02.240 --> 00:46:05.630
it simply posts it and goes on its way.

00:46:05.640 --> 00:46:09.440
It may choose whether the
notifications are going to be

00:46:09.440 --> 00:46:11.830
delivered immediately or not.

00:46:12.710 --> 00:46:16.020
The receivers,
if anyone on the system who wants

00:46:16.020 --> 00:46:19.900
to receive such a notification
simply registers to receive it.

00:46:19.900 --> 00:46:22.110
The sender doesn't have to
know anything about them.

00:46:22.110 --> 00:46:28.010
You register based on the name,
optionally also the string

00:46:28.020 --> 00:46:30.070
representing the sender.

00:46:30.740 --> 00:46:36.140
And you can choose whether you want to
receive these notifications immediately

00:46:36.140 --> 00:46:39.000
or whether you want them to be delayed.

00:46:39.000 --> 00:46:43.570
Because typically,
it's not necessary for all the receivers

00:46:43.580 --> 00:46:46.110
to get the notification at once,
and it's rather expensive

00:46:46.110 --> 00:46:48.260
to wake them all up,
wake up all these processes at

00:46:48.270 --> 00:46:50.040
once to deliver the notification.

00:46:50.040 --> 00:46:54.130
Often, it's enough if you will simply
get this notification the

00:46:54.200 --> 00:46:56.150
next time you become active.

00:46:57.870 --> 00:47:01.620
And if you, a notification might
be sent multiple times,

00:47:01.710 --> 00:47:05.090
you can choose to have
those coalesced if you like.

00:47:06.730 --> 00:47:09.460
So this is a very useful mechanism.

00:47:09.460 --> 00:47:18.150
It's not intended for large amounts of
data or very high volume or frequency.

00:47:18.550 --> 00:47:21.330
But it's useful in a
variety of circumstances,

00:47:21.400 --> 00:47:24.750
especially, for example,
in combination with other

00:47:24.750 --> 00:47:26.640
channels of information.

00:47:26.640 --> 00:47:30.680
For example, if you had a suite of
applications on the system that

00:47:30.780 --> 00:47:34.110
all shared a set of preferences,
and one application was going

00:47:34.110 --> 00:47:37.760
to change those preferences,
it could send out a notification to let

00:47:37.760 --> 00:47:42.040
all the other applications in the suite
know that the preferences have changed,

00:47:42.240 --> 00:47:46.100
and then at their convenience,
they could look up the changed value.

00:47:46.460 --> 00:47:51.160
Or if you had some area on the file
system that you were working with,

00:47:51.160 --> 00:47:53.930
and you changed it,
you could send out a notification

00:47:53.930 --> 00:47:56.220
to let any interested party
know that it had changed,

00:47:56.220 --> 00:47:59.340
and that they should go and look
it up and see what had happened.

00:48:04.100 --> 00:48:06.690
So now,
let's discuss where you can go for

00:48:06.700 --> 00:48:10.880
more information about CoreFoundation.

00:48:10.880 --> 00:48:14.460
There is documentation on
your system and online.

00:48:14.460 --> 00:48:19.280
There are a number of examples,
both with your Mac OS X Developer CD and

00:48:19.280 --> 00:48:21.270
in the CarbonLib SDKs.

00:48:21.920 --> 00:48:25.470
And you should not forget to
look at the release notes,

00:48:25.470 --> 00:48:29.460
which describe anything new or anything
that has changed in CoreFoundation.

00:48:29.460 --> 00:48:33.930
And there are some specialized
release notes that are more like

00:48:33.930 --> 00:48:38.660
discussions of topics in depth,
one on CFBundle and CFPlugin with

00:48:38.660 --> 00:48:42.920
some detailed examples of CFPlugin,
one describing the info

00:48:43.140 --> 00:48:47.620
dictionary in a bundle in detail,
and one on localization.

00:48:49.200 --> 00:48:52.580
And now I'd like to bring
Mark Turner back to wrap

00:48:52.580 --> 00:48:57.890
things up and start our Q&A.

00:49:09.910 --> 00:49:17.890
Let's take a quick look at, well,
I was going to say what the roadmap is,

00:49:17.890 --> 00:49:17.890
but let's talk about this.

00:49:18.210 --> 00:49:20.790
So yeah, as I said,
I'm the Carbon Technology Manager.

00:49:20.810 --> 00:49:25.710
Although CoreFoundation is obviously
not a carbon-specific technology,

00:49:25.820 --> 00:49:30.540
I'll be happy to take your questions
or comments about CoreFoundation.

00:49:30.540 --> 00:49:34.340
You can email me at mark@apple.com.

00:49:34.340 --> 00:49:39.560
There is the email address here,
which is read by the engineering team,

00:49:39.580 --> 00:49:42.670
so that's another great
place to send your feedback.

00:49:42.840 --> 00:49:47.700
And these two mailing lists I encourage
you to get on if you're not already.

00:49:47.700 --> 00:49:52.230
It's a great place to get your
questions answered and share

00:49:52.230 --> 00:49:55.760
your knowledge about Carbon,
Cocoa, and CoreFoundation.

00:49:55.760 --> 00:49:59.660
These lists are available if
you haven't been there before.

00:49:59.660 --> 00:50:04.960
There's a webpage at lists.apple.com
where you can sign up for a

00:50:04.970 --> 00:50:07.780
great many Apple mailing lists.

00:50:09.700 --> 00:50:15.700
And now, so here we are,
10 o'clock Friday morning.

00:50:15.860 --> 00:50:18.680
Most of these sessions
have gone by already,

00:50:18.680 --> 00:50:23.370
but I'd like to highlight them for
you so that you can look at them on

00:50:23.370 --> 00:50:26.470
ADC TV or on the DVDs when you get them.

00:50:26.500 --> 00:50:28.870
First being the Cocoa Overview.

00:50:28.870 --> 00:50:32.600
That's a great session just
for those of you who haven't

00:50:32.640 --> 00:50:35.050
gotten started yet with Cocoa.

00:50:36.300 --> 00:50:40.610
The Carbon Event Manager is another
overview session for Carbon developers.

00:50:40.610 --> 00:50:43.320
We really encourage you to look
into the Carbon Event Manager.

00:50:43.320 --> 00:50:48.990
It simplifies your code and gets you
much better performance on Mac OS X.

00:50:49.210 --> 00:50:52.440
And then the advanced
Cocoa Topics session,

00:50:52.440 --> 00:50:56.280
which we had yesterday,
for more information about the RunLoop

00:50:56.280 --> 00:50:59.140
and other things that Doug mentioned.

00:50:59.370 --> 00:51:05.260
And if you're here this afternoon,
the Cocoa Feedback Forum would

00:51:05.260 --> 00:51:09.540
be a great place to bring your
questions about Cocoa and,

00:51:09.540 --> 00:51:13.320
of course, CoreFoundation because many of
the same people will be there.
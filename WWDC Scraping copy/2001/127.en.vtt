WEBVTT

00:00:02.670 --> 00:00:03.600
Thank you.

00:00:03.600 --> 00:00:05.170
Thank you.

00:00:05.360 --> 00:00:09.580
So the good news is
that--can you all hear me?

00:00:09.670 --> 00:00:10.000
Yep.

00:00:10.200 --> 00:00:12.670
The spoken language technologies,
in case you haven't noticed,

00:00:13.070 --> 00:00:14.390
are in Mac OS X.

00:00:14.400 --> 00:00:15.100
We got them there.

00:00:15.120 --> 00:00:16.700
Thank you.

00:00:16.700 --> 00:00:20.740
What we're going to do today is describe
briefly the speech recognition and

00:00:20.790 --> 00:00:22.500
the speech synthesis that are there.

00:00:22.500 --> 00:00:25.740
We're going to give you guidelines
about where to use them in your

00:00:25.740 --> 00:00:29.220
applications and why you would want
to use them in your applications.

00:00:29.220 --> 00:00:32.680
And we're going to actually lead you
through the process of getting your

00:00:32.680 --> 00:00:34.800
applications talking and listening.

00:00:34.800 --> 00:00:39.700
So let's start off by doing a
demo of what we've got over here.

00:00:45.030 --> 00:00:48.420
Can we switch to-- oh,
I'm supposed to do it, aren't I?

00:00:48.420 --> 00:00:50.500
I'm supposed to do it.

00:00:50.500 --> 00:00:51.970
There we go.

00:00:53.600 --> 00:00:57.780
The user interface to speech
recognition is this round

00:00:57.780 --> 00:01:00.400
window that you may have seen.

00:01:00.400 --> 00:01:05.320
This replaces the face that some of
you might be familiar with in OS 9.

00:01:05.340 --> 00:01:07.330
It consists of three parts.

00:01:07.520 --> 00:01:11.720
The middle, you might be able to see,
says Escape.

00:01:11.720 --> 00:01:13.510
This shows you the listening mode.

00:01:13.540 --> 00:01:17.180
There are two different listening
modes with speech recognition,

00:01:17.180 --> 00:01:19.980
what we call Push-to-Talk mode
and Continuous Listening.

00:01:20.100 --> 00:01:22.430
In Push-to-Talk mode,
it's only listening when

00:01:22.430 --> 00:01:23.620
you hold down a key.

00:01:23.620 --> 00:01:27.270
It says ESC, which means that by default
it's the escape key.

00:01:27.440 --> 00:01:28.420
Users can configure that.

00:01:28.500 --> 00:01:31.750
In Continuous Listening mode,
it's listening all the time,

00:01:31.750 --> 00:01:34.500
and optionally you can
have it wait for a keyword,

00:01:34.650 --> 00:01:37.330
like computer,
before you speak your commands.

00:01:37.360 --> 00:01:41.180
I am using Push-to-Talk mode here,
and I recommend that you do

00:01:41.280 --> 00:01:43.200
as well when you're demoing.

00:01:43.300 --> 00:01:47.420
So that when you're
explaining things to people,

00:01:47.420 --> 00:01:51.760
it's not try to recognize commands,
that you're actually intending to

00:01:51.760 --> 00:01:54.230
other people and not to the computer.

00:01:55.360 --> 00:01:56.640
What time is it?

00:01:56.710 --> 00:01:58.840
It's 10:30.

00:01:58.920 --> 00:02:00.030
What day is it?

00:02:00.080 --> 00:02:03.200
It's Thursday, May 24th.

00:02:03.310 --> 00:02:04.950
Show me what to say.

00:02:06.280 --> 00:02:13.240
Okay, the other part of the feedback
is this speech commands window,

00:02:13.240 --> 00:02:14.270
which has two halves.

00:02:14.400 --> 00:02:19.760
The top half, which is scrollable,
shows what it has recognized,

00:02:19.760 --> 00:02:22.610
and if it speaks back to you,
what it says to you.

00:02:22.620 --> 00:02:25.310
The bottom half,
which also is scrollable,

00:02:25.450 --> 00:02:27.730
and all of which is
resizable by the user,

00:02:27.900 --> 00:02:28.380
at last.

00:02:28.540 --> 00:02:29.740
Thank you, Cocoa.

00:02:29.740 --> 00:02:33.230
Shows what you can say.

00:02:34.460 --> 00:02:37.810
There are now disclosure triangles,
so that it no longer scrolls

00:02:37.900 --> 00:02:39.560
off the bottom of the screen.

00:02:41.320 --> 00:02:43.170
The middle item there,
I don't know whether you can see,

00:02:43.430 --> 00:02:45.880
it says Speakable Items.

00:02:45.880 --> 00:02:48.630
That shows the commands that
can be spoken all of the time,

00:02:48.650 --> 00:02:50.660
no matter what application is running.

00:02:50.720 --> 00:02:54.240
I mentioned at the start,
I spoke what time is it, what day is it.

00:02:54.260 --> 00:02:56.110
There are items down in there.

00:02:57.080 --> 00:03:00.240
These are actually kept in
the Speakable Items folder.

00:03:00.240 --> 00:03:02.560
Let's take a look at it.

00:03:02.600 --> 00:03:04.990
Open the Speakable Items folder.

00:03:06.930 --> 00:03:09.820
There it is.

00:03:09.930 --> 00:03:14.380
So any item that is in this
Speakable Items folder can

00:03:14.380 --> 00:03:16.680
be launched by speaking it.

00:03:16.680 --> 00:03:18.900
And it's just the same
as double-clicking on it.

00:03:18.900 --> 00:03:26.560
Applications, aliases, documents,
servers, URLs, anything that you can

00:03:26.560 --> 00:03:31.500
launch by double-clicking,
you can now launch by speech on OS X.

00:03:31.500 --> 00:03:34.790
The real power of this is that users
can customize it to the way they

00:03:34.790 --> 00:03:39.180
work by dragging their own items
into the Speakable Items folder.

00:03:39.860 --> 00:03:43.770
In addition, just like in OS 9 now,
the Speakable Items folder

00:03:43.770 --> 00:03:48.520
itself contains a folder called
Application Speakable Items.

00:03:48.520 --> 00:03:54.760
This contains folders which
are named by applications.

00:03:54.760 --> 00:03:58.430
The items in those folders
are only speakable when that

00:03:58.430 --> 00:04:00.980
application is in the foreground.

00:04:01.960 --> 00:04:05.760
That's shown in the speech
commands window in the top item,

00:04:05.760 --> 00:04:07.040
the top disclosure triangle.

00:04:07.040 --> 00:04:10.250
So you see at the moment-- let me
close the others-- that it says finder,

00:04:10.250 --> 00:04:12.440
and the finder is in the foreground.

00:04:12.460 --> 00:04:18.820
Let me demonstrate this in action.

00:04:18.820 --> 00:04:18.920
I'll switch to my browser, and as I do,
you watch the items there change.

00:04:20.040 --> 00:04:22.880
Open my browser.

00:04:22.920 --> 00:04:26.160
There, so it now says Internet Explorer,
and there are some different items there.

00:04:26.200 --> 00:04:27.980
This is an opportunity
for you developers.

00:04:28.020 --> 00:04:32.240
You can make application-specific folders
for your applications and populate those

00:04:32.400 --> 00:04:36.580
folders with scripts or other commands
that control just your application.

00:04:36.620 --> 00:04:39.130
They won't be speakable
when your application itself

00:04:39.160 --> 00:04:41.000
is not in the foreground.

00:04:41.230 --> 00:04:43.880
Oh, I'd like to encourage you to
explore this by yourselves.

00:04:43.880 --> 00:04:46.300
I just want to show you one other thing.

00:04:47.380 --> 00:04:49.700
Hide this application.

00:04:49.700 --> 00:04:53.220
And that is that you may have
noticed we shipped one game,

00:04:53.220 --> 00:04:54.340
and that is chess.

00:04:54.340 --> 00:04:57.260
Oh, in telling you this,
I should point out,

00:04:57.260 --> 00:05:00.180
we keep track of all the
applications that you've launched

00:05:00.180 --> 00:05:03.080
since we started--actually,
restarted the machine,

00:05:03.130 --> 00:05:10.260
and you can switch to any application,
running or not, just by saying its name.

00:05:10.780 --> 00:05:10.890
Switch to

00:05:12.600 --> 00:05:15.050
So the chess application you
might have seen mentioned and

00:05:15.050 --> 00:05:18.660
demoed in the keynote on Monday,
one of the keynotes,

00:05:18.750 --> 00:05:21.320
as being an example of
a good user interface,

00:05:21.500 --> 00:05:22.390
Aqua quality.

00:05:22.480 --> 00:05:27.620
And one of the things about it is
that you can control it by speech.

00:05:27.710 --> 00:05:30.280
Porn D2 to D4.

00:05:32.960 --> 00:05:35.240
Knight B1 to C3.

00:05:35.240 --> 00:05:38.070
What's it going to do to that?

00:05:38.280 --> 00:05:39.000
Let's see.

00:05:39.030 --> 00:05:39.900
It's thinking.

00:05:39.940 --> 00:05:41.490
It's thinking harder than I am.

00:05:41.490 --> 00:05:44.140
But it's a better player than I am, too.

00:05:44.160 --> 00:05:50.030
One of the things I like about
this is there's one thing I can

00:05:50.130 --> 00:05:53.570
do with this that I can't do when
I'm playing with real people,

00:05:53.570 --> 00:05:53.570
and that's the following.

00:05:53.570 --> 00:05:53.570
I can say, take back move.

00:05:53.820 --> 00:05:55.950
Whoa.

00:05:56.120 --> 00:05:58.590
My 12-year-old son does not let me
do that when I'm playing with him.

00:05:58.590 --> 00:06:01.420
Okay, let's move on.

00:06:06.130 --> 00:06:07.990
So what speech is there in Mac OS X?

00:06:07.990 --> 00:06:09.140
Bear with me.

00:06:09.370 --> 00:06:11.470
There are a lot of people at
this conference this year who

00:06:11.470 --> 00:06:13.450
are new to the Mac OS platform.

00:06:13.460 --> 00:06:16.440
Some of you who are already
familiar with the platform

00:06:16.440 --> 00:06:18.330
will know already what we have.

00:06:18.380 --> 00:06:23.180
So here's just a brief mention for
those that aren't yet familiar with it.

00:06:23.240 --> 00:06:26.160
We have Speech Synthesis
and Speech Recognition.

00:06:26.160 --> 00:06:30.220
The Speech Synthesis will take any text
and convert it into audible speech.

00:06:30.790 --> 00:06:32.140
There are 22 different voices.

00:06:32.140 --> 00:06:37.220
They range from adult male and adult
female through to voices that sing and

00:06:37.610 --> 00:06:40.290
sound like aliens and novelty voices.

00:06:40.320 --> 00:06:42.270
And we have Speech Recognition.

00:06:42.270 --> 00:06:43.880
There are a number of
characteristics about the

00:06:43.990 --> 00:06:45.430
Speech Recognition that are important.

00:06:45.440 --> 00:06:48.820
First is it's speaker independent.

00:06:48.820 --> 00:06:52.260
That means you don't have
to train it to your voice.

00:06:52.260 --> 00:06:55.260
You just take it out of
the box and it just works.

00:06:55.280 --> 00:07:00.280
The Mac was and remains the only
computer platform I know of that

00:07:00.280 --> 00:07:03.680
you can just take out of the box,
put on the desk, and command by voice.

00:07:03.680 --> 00:07:06.340
It's continuous speech.

00:07:06.340 --> 00:07:10.080
You don't have to pause between words.

00:07:12.230 --> 00:07:13.680
It uses a far-field microphone.

00:07:13.680 --> 00:07:15.760
This is a technical point,
but a very important point.

00:07:15.790 --> 00:07:19.640
Speech recognition is very
sensitive to background noise.

00:07:19.640 --> 00:07:24.350
So sensitive that all other recognizers
that I know of require that the users

00:07:24.380 --> 00:07:28.820
purchase and use a noise-canceling,
close-talking, head-mounted microphone.

00:07:28.820 --> 00:07:33.050
We tune up our recognizer to work
with the in-built microphones that

00:07:33.140 --> 00:07:37.260
are built into the iMacs and the
other CPUs that Apple delivers.

00:07:37.320 --> 00:07:39.980
That means that we are getting
the background noise that other

00:07:39.980 --> 00:07:41.430
recognizers aren't getting.

00:07:41.780 --> 00:07:46.490
So we have several layers of software
to adaptively model and subtract

00:07:46.490 --> 00:07:48.810
and deal with that background noise.

00:07:50.710 --> 00:07:54.470
But there are limits on how much
background noise we can deal with.

00:07:54.610 --> 00:07:58.760
So we've tuned it up to work well in the
situations where most of our users are

00:07:58.760 --> 00:08:02.320
using their computers-- in the office,
at home.

00:08:02.370 --> 00:08:05.700
If you have users or customers
who are using speech recognition

00:08:05.700 --> 00:08:08.220
in noisy environments,
such as in classrooms,

00:08:08.510 --> 00:08:11.370
then it might be pushing the
limits of the head-mounted

00:08:11.370 --> 00:08:13.340
microphones a little bit too far.

00:08:13.340 --> 00:08:16.530
One such environment, for example,
is giving a presentation in an

00:08:16.530 --> 00:08:21.110
auditorium with a 300-watt sound
system that's providing a slapback

00:08:21.180 --> 00:08:23.560
echo from the back of the hall.

00:08:23.660 --> 00:08:26.550
And so this is one of those
environments where I've been using

00:08:26.550 --> 00:08:28.480
this head-mounted microphone.

00:08:28.540 --> 00:08:30.830
This one is produced by VXI.

00:08:30.970 --> 00:08:33.580
They have worked quite a lot with
us over the last couple of years

00:08:33.580 --> 00:08:37.180
to optimize their microphones to
work with our speech recognition.

00:08:37.250 --> 00:08:39.840
And so you can direct your users,
if you want to,

00:08:39.910 --> 00:08:42.280
those as an alternative solution.

00:08:42.350 --> 00:08:47.360
Our speech technologies currently
are US English only on OS X.

00:08:47.460 --> 00:08:48.040
So what's new?

00:08:48.080 --> 00:08:52.540
In speech synthesis,
we've done a few things.

00:08:52.690 --> 00:08:56.570
We merged the Macintalk 3 and
the Macintalk Pro codebases

00:08:56.660 --> 00:08:58.180
into a single codebase.

00:08:58.200 --> 00:09:00.080
This has got a couple of advantages.

00:09:00.130 --> 00:09:03.560
One is it means that we have, at last,
a totally new codebase.

00:09:03.690 --> 00:09:08.990
We have divested ourselves of deep,
intricate, uninterpretable legacy code

00:09:08.990 --> 00:09:13.120
and positioned ourselves to,
at last, be able to fold in the research

00:09:13.310 --> 00:09:17.240
improvements that we've been making in
speech synthesis in the last few years.

00:09:17.280 --> 00:09:20.010
So we've got ourselves into a
new platform ready to go forward.

00:09:20.240 --> 00:09:23.830
An immediate benefit right
now is that you get consistent

00:09:23.920 --> 00:09:25.580
behavior across voices.

00:09:25.600 --> 00:09:31.200
A lot of developers have said to me that
they change from one voice to another,

00:09:31.230 --> 00:09:34.540
and words are pronounced differently,
or the intonation is different,

00:09:34.620 --> 00:09:36.640
or that will no longer happen.

00:09:36.920 --> 00:09:40.330
All the pro voices are now
just the high-quality versions.

00:09:40.330 --> 00:09:45.500
So what was Victoria high-quality
in OS 9 is now called Victoria,

00:09:45.500 --> 00:09:48.260
and there is no lower-quality
version in OS X.

00:09:48.260 --> 00:09:51.220
That means the speech is crisper,
it's easier to understand,

00:09:51.220 --> 00:09:53.870
it's more robust in the
presence of background noise.

00:09:53.980 --> 00:09:56.100
People can understand it
without it being so loud.

00:09:56.100 --> 00:09:59.450
And we've improved the
pronunciation in a number of ways.

00:09:59.540 --> 00:10:03.870
We've enlarged the dictionary
from about 20,000 words to about,

00:10:03.870 --> 00:10:05.870
what, 120,000?

00:10:07.630 --> 00:10:10.020
Jerome's work down here.

00:10:10.380 --> 00:10:13.660
The morphological
decomposition is now recursive.

00:10:13.660 --> 00:10:15.820
If you want to know what that means,
ask us in the question time.

00:10:15.820 --> 00:10:16.440
It's fascinating.

00:10:16.440 --> 00:10:19.610
Really, really, it's way cool.

00:10:19.610 --> 00:10:23.120
It's a multiplier on the
effectiveness of the dictionary.

00:10:23.120 --> 00:10:26.730
And the letter-to-sound rules
are now automatically trained

00:10:26.860 --> 00:10:31.460
based on the new large dictionary,
rather than handwritten based

00:10:31.460 --> 00:10:34.050
on one linguist's intuitions.

00:10:35.220 --> 00:10:37.400
For speech recognition,
we also have a benefit here.

00:10:37.460 --> 00:10:41.460
We have factored out that pronunciation
subsystem from the speech synthesis

00:10:41.460 --> 00:10:44.600
and made it a separate subsystem
that's now shared between speech

00:10:44.600 --> 00:10:46.140
synthesis and speech recognition.

00:10:46.140 --> 00:10:48.570
This means, first of all,
it reduces the overall RAM,

00:10:48.640 --> 00:10:51.880
which improves performance of
everything running on the platform.

00:10:51.880 --> 00:10:55.420
It means the recognition is more
accurate because the pronunciation

00:10:55.450 --> 00:10:59.060
subsystem is expecting the correct
pronunciations for more words.

00:10:59.220 --> 00:11:04.940
And it gives consistent behavior across
speech recognition and speech synthesis.

00:11:05.100 --> 00:11:08.510
Developers have said to me,
I was prototyping some spoken

00:11:08.510 --> 00:11:11.520
commands for my application,
and one of the commands was

00:11:11.750 --> 00:11:13.110
not recognized very well.

00:11:13.120 --> 00:11:15.440
And I thought that perhaps the
recognizer was not listening

00:11:15.440 --> 00:11:16.860
for the correct pronunciation.

00:11:16.860 --> 00:11:19.420
So to find out what the
recognizer was listening for,

00:11:19.420 --> 00:11:22.080
I typed my command into
your text-to-speech system,

00:11:22.080 --> 00:11:26.020
and sure enough, it was spoken with an
incorrectly pronounced word.

00:11:26.060 --> 00:11:29.040
Well, up until today,
that's been irrelevant.

00:11:29.040 --> 00:11:31.900
Now it is relevant.

00:11:32.900 --> 00:11:35.170
Now, if you want to know whether
the recognizer is expecting

00:11:35.490 --> 00:11:38.540
the correct pronunciation,
then type the word or the command

00:11:38.700 --> 00:11:41.300
into the speech synthesis,
and it will tell you the way

00:11:41.430 --> 00:11:44.290
the recognizer thinks people
will pronounce that word.

00:11:44.320 --> 00:11:47.520
The user interface has
been completely revised,

00:11:47.720 --> 00:11:48.880
as I showed you.

00:11:49.070 --> 00:11:51.390
And there's an improvement
to speakable items.

00:11:51.400 --> 00:11:55.040
We've added XML-based command
files that you associate a spoken

00:11:55.230 --> 00:11:57.580
command with a keystroke sequence.

00:11:57.580 --> 00:12:00.760
Kevin Ai can later in this presentation
show you that in some more detail.

00:12:02.670 --> 00:12:06.880
I want to talk about why you should
use speech in your applications.

00:12:06.880 --> 00:12:10.600
There are two classes of applications,
I think, from our perspective.

00:12:10.600 --> 00:12:12.900
There are applications that
are centered around speech,

00:12:13.000 --> 00:12:16.160
where speech technology is central to
the user's experience and central to

00:12:16.160 --> 00:12:19.120
the value that application delivers.

00:12:19.120 --> 00:12:21.570
And then there's a huge
number of applications,

00:12:21.570 --> 00:12:24.010
I think most of you write,
for which speech is not

00:12:24.010 --> 00:12:25.520
centrally relevant at all.

00:12:25.800 --> 00:12:28.570
And I'd like you to think about
places that you can use speech

00:12:28.570 --> 00:12:29.960
in those applications as well.

00:12:30.050 --> 00:12:30.900
Chess is an example.

00:12:30.900 --> 00:12:33.980
Speech is not really relevant to chess,
but we added it and people say, "Hey,

00:12:34.000 --> 00:12:38.020
that's cool." If you add
speech to your application,

00:12:38.020 --> 00:12:40.320
then you'll increase the
number of potential users and

00:12:40.810 --> 00:12:42.440
that increases your market.

00:12:42.600 --> 00:12:47.200
For example, younger users will find your
application more approachable.

00:12:47.520 --> 00:12:51.360
People with disabilities will be
able to use your applications.

00:12:51.360 --> 00:12:54.520
And people who are less familiar
with computation will be less scared

00:12:54.520 --> 00:12:56.990
of trying out your application.

00:12:58.360 --> 00:13:00.700
Speech is a very natural
form of communication.

00:13:00.700 --> 00:13:02.680
We've all been talking and
listening since we were,

00:13:02.680 --> 00:13:04.370
what, two years old?

00:13:04.390 --> 00:13:06.580
Wait, one and a half years old?

00:13:07.430 --> 00:13:10.680
Speech enables you in your
application to move beyond

00:13:11.010 --> 00:13:12.840
the limits of point and click.

00:13:12.840 --> 00:13:14.500
There's nothing wrong
with point and click.

00:13:14.500 --> 00:13:17.500
In fact, it's very good at letting you
control things that you can

00:13:17.500 --> 00:13:21.000
see on the user interface and
reach with a single gesture.

00:13:21.000 --> 00:13:23.260
But there are lots of things that
you want people to control that they

00:13:23.260 --> 00:13:25.980
can't see to point to to click on.

00:13:26.010 --> 00:13:28.080
Speech gives you a way to get past that.

00:13:28.080 --> 00:13:30.780
If you think about it, clicking--

00:13:31.000 --> 00:13:32.220
It's rather like grunting.

00:13:32.220 --> 00:13:39.240
We're turning our back on, what,
about 200,000 years of human evolution.

00:13:39.240 --> 00:13:44.210
Because when I click on things,
I'm just going, uh, uh, uh.

00:13:46.550 --> 00:13:47.000
That's true.

00:13:47.000 --> 00:13:51.860
I'd like to think that we've
come somewhat further than that.

00:13:51.980 --> 00:13:56.040
Similarly, speech output, I think,
can be a lot better than just beep.

00:13:56.160 --> 00:13:58.380
So many of us are still
using alert sounds.

00:13:58.480 --> 00:14:02.200
Well, beep was the mentality of 1960s,
when all the computers had

00:14:02.200 --> 00:14:03.410
was this tiny little speaker.

00:14:03.440 --> 00:14:04.840
We've come forward since then.

00:14:05.170 --> 00:14:10.050
Speech gives you a way to bring
yourselves into the 21st century.

00:14:10.730 --> 00:14:13.250
And conversation is an
appropriate modality for

00:14:13.580 --> 00:14:15.400
delegating tasks to a computer.

00:14:15.400 --> 00:14:17.530
We'll illustrate that a bit more shortly.

00:14:17.540 --> 00:14:21.530
So what are some of the ways that you can
use speech synthesis in your application?

00:14:21.540 --> 00:14:23.290
One is notifications.

00:14:23.320 --> 00:14:28.070
We recommend that you judiciously
get the user's attention back if

00:14:28.180 --> 00:14:30.560
the user's attention has wandered
away from your applications.

00:14:30.560 --> 00:14:33.410
Some of you may have known
about or experienced talking

00:14:33.730 --> 00:14:35.410
alerts that we did in OS 9.

00:14:35.760 --> 00:14:40.410
Now, there's a slider that lets you set
how long between the delay between an

00:14:40.490 --> 00:14:42.910
alert coming up and it being spoken.

00:14:42.920 --> 00:14:46.070
You may want that longer or
shorter than the default,

00:14:46.070 --> 00:14:49.440
but the point is you normally
should not hear any speech,

00:14:49.660 --> 00:14:52.890
except when your attention wanders
and the computer wants your attention,

00:14:52.900 --> 00:14:55.330
and then if you don't respond,
it gets your attention back.

00:14:56.820 --> 00:15:00.020
You can use notifications
for asynchronous events.

00:15:00.190 --> 00:15:03.550
For example,
in the AOL Instant Messenger,

00:15:03.670 --> 00:15:06.670
if your buddies enter your chat room,
then it will announce that

00:15:06.820 --> 00:15:07.740
with our speech synthesis.

00:15:07.760 --> 00:15:11.220
It will say,
Buddy Smith just entered the room.

00:15:11.750 --> 00:15:15.720
You can use speech synthesis to give
additional feedback for younger users,

00:15:15.770 --> 00:15:18.010
and we have found,
and our users have found,

00:15:18.010 --> 00:15:23.580
that applications for the 6 to 12
space become accessible for the K3 to

00:15:23.660 --> 00:15:27.060
6 space if they don't change anything
but just read out the text messages

00:15:27.300 --> 00:15:29.330
that they're putting up on the screens.

00:15:29.360 --> 00:15:32.710
And you can use speech
synthesis for proofreading.

00:15:32.720 --> 00:15:34.450
For example,
you have an application where

00:15:34.800 --> 00:15:36.700
people are entering data,
say a spreadsheet,

00:15:36.750 --> 00:15:39.170
and people are entering
budget figures in a column.

00:15:39.940 --> 00:15:43.160
Allow them to select that column and
have it read back so they can just

00:15:43.160 --> 00:15:46.790
check what they were entering to make
sure that there aren't any errors.

00:15:49.280 --> 00:15:52.620
Speech will give your
application more accessibility

00:15:52.960 --> 00:15:54.850
for those with disabilities.

00:15:54.890 --> 00:15:57.800
I think that's pretty obvious.

00:15:57.800 --> 00:15:59.860
And it's really cool in games.

00:15:59.860 --> 00:16:02.040
You saw that we did it with chess.

00:16:02.040 --> 00:16:05.590
There are a lot of games already
that are using speech for things like

00:16:05.710 --> 00:16:08.120
cheat codes and changing weapons.

00:16:08.120 --> 00:16:10.420
Use speech for
non-time-dependent control.

00:16:10.420 --> 00:16:12.560
I don't think it would be
appropriate to use speech

00:16:12.720 --> 00:16:15.830
recognition in your game to say,
"Fire, now!

00:16:15.850 --> 00:16:18.810
Quick, quick, left, quick, right!

00:16:18.810 --> 00:16:23.360
No, no, left!" But you can do it for that
as well if you want to try it.

00:16:23.360 --> 00:16:26.340
In noisy games,
these headsets are probably the

00:16:26.340 --> 00:16:29.360
right thing to do so the speech
recognition doesn't confuse your

00:16:29.500 --> 00:16:36.040
commands with . There are a lot of
people who are successfully using

00:16:36.250 --> 00:16:37.020
speech in education applications.

00:16:37.100 --> 00:16:41.460
I think there are a lot more of you
with education applications that

00:16:41.510 --> 00:16:44.490
could take advantage of All right.

00:16:44.930 --> 00:16:52.640
One example would be the DyneEd product,
which is using speech recognition

00:16:52.640 --> 00:16:55.800
for pronunciation correction
for adults learning English.

00:16:55.800 --> 00:16:57.130
It's way cool.

00:16:57.130 --> 00:16:58.750
Check it out.

00:16:59.160 --> 00:17:01.930
You can use speech to enhance
the web browsing experience.

00:17:02.030 --> 00:17:05.280
For navigating within a browser,
if those of you who've explored will see

00:17:05.280 --> 00:17:08.490
that we actually ship a couple of spoken
commands for Internet Explorer that

00:17:08.490 --> 00:17:10.040
let you do some simple navigation.

00:17:10.080 --> 00:17:12.410
If you have a browser,
you can do a much better job

00:17:12.410 --> 00:17:14.030
than we do by working within it.

00:17:14.140 --> 00:17:17.790
For example,
people could speak the links,

00:17:17.840 --> 00:17:21.510
jump to pages by topic,
read out web pages.

00:17:21.760 --> 00:17:23.840
And there's a big
opportunity with voice XML.

00:17:23.840 --> 00:17:28.820
The enterprise industry that's
moving more and more of its

00:17:28.820 --> 00:17:32.540
information onto web access is
now doing two or three different

00:17:32.540 --> 00:17:34.530
versions of all of their websites.

00:17:34.540 --> 00:17:38.730
They're doing the HTML version,
they're doing a WAP version for

00:17:39.050 --> 00:17:43.280
portable digital assistants to
access their stuff via wireless,

00:17:43.300 --> 00:17:45.940
and they're making voice
XML versions so that people can

00:17:45.940 --> 00:17:49.330
ring up the web page and have the
information read out over the phone.

00:17:49.340 --> 00:17:53.440
The way this is done is by... an
extra set of tags that are in the web

00:17:53.440 --> 00:17:58.880
pages that are just the thing that you
need to interpret for speech access.

00:17:58.970 --> 00:18:02.910
And you can do that on the
desktop with a Mac using our APIs.

00:18:02.960 --> 00:18:05.890
It would be pretty straightforward
because the infrastructure and

00:18:05.900 --> 00:18:09.710
the hard work has all been done
for you by the web developers.

00:18:10.890 --> 00:18:13.380
We recommend that you think about
using speech for form filling as

00:18:13.460 --> 00:18:16.580
an alternative to people filling
out things with pop-up menus.

00:18:16.580 --> 00:18:20.290
You can now have people speak
the contents of each field,

00:18:20.340 --> 00:18:24.640
and you can use a constrained
language model for each field to

00:18:24.770 --> 00:18:26.660
increase the recognition accuracy.

00:18:26.660 --> 00:18:31.160
For example, the person could say,
create a new customer record,

00:18:31.170 --> 00:18:34.690
and the computer could then respond,
what type?

00:18:34.760 --> 00:18:38.420
And then narrow down its search to
just the alternative customer records.

00:18:38.620 --> 00:18:41.060
The person could say, corporate account.

00:18:41.100 --> 00:18:43.540
And then the next field
would be payment schedule,

00:18:43.540 --> 00:18:45.730
and the person could then say, 30 days.

00:18:45.820 --> 00:18:49.610
And at that stage,
the recognition model was

00:18:49.710 --> 00:18:55.170
changed again to just listen
for possible payment schedules.

00:18:55.180 --> 00:18:58.140
Okay.

00:18:58.140 --> 00:19:00.840
There are a lot of tasks
where people's eyes are busy,

00:19:00.840 --> 00:19:02.060
their hands are busy.

00:19:02.060 --> 00:19:03.820
For example,
you're in a graphics program.

00:19:03.840 --> 00:19:04.660
You're drawing.

00:19:04.660 --> 00:19:05.880
You've got the mouse down.

00:19:05.880 --> 00:19:08.040
You're putting a line across an object.

00:19:08.200 --> 00:19:10.120
And you want to move it around,
send it to the back,

00:19:10.120 --> 00:19:11.160
or change the brush size.

00:19:11.240 --> 00:19:13.400
When the eyes are busy
and the hands are busy,

00:19:13.400 --> 00:19:16.510
speech gives you another way for
your users to control your app.

00:19:18.110 --> 00:19:20.480
So at this stage,
I'd like to invite Sal Soghoian up.

00:19:20.630 --> 00:19:22.870
Sal Soghoian is the
AppleScript product manager,

00:19:22.870 --> 00:19:25.660
and he's going to show you some way
cool ways that he's been using speech.

00:19:25.660 --> 00:19:28.490
Sal.

00:19:30.220 --> 00:19:31.200
Is this on?

00:19:31.200 --> 00:19:32.200
Great.

00:19:32.200 --> 00:19:34.000
Hi.

00:19:34.000 --> 00:19:37.360
This is amazing that I got up
this early for this whole thing.

00:19:37.790 --> 00:19:40.700
Those that know me know that
it's an impressive feat.

00:19:40.700 --> 00:19:45.110
What we're going to be showing today is,
can you switch me to this,

00:19:45.110 --> 00:19:46.910
or me switch me to this?

00:19:47.450 --> 00:19:48.940
is how to use AppleScript with speech.

00:19:49.000 --> 00:19:53.750
That's one of the best integrations
on Mac OS is the ability to use

00:19:53.750 --> 00:19:56.160
these two technologies together.

00:19:56.210 --> 00:19:59.740
And on Mac OS 9,
we introduced the ability to have

00:19:59.740 --> 00:20:03.850
a script listen for a response
and based upon the user's response

00:20:04.000 --> 00:20:05.940
perform a different set of actions.

00:20:05.980 --> 00:20:09.630
And incorporated a technology
called the SpeechListener.

00:20:09.770 --> 00:20:13.010
So I'm going to show a couple
scripts today that use this

00:20:13.010 --> 00:20:15.060
technology on Mac OS X.

00:20:15.150 --> 00:20:19.420
And both scripts will involve a
conversation to get a task done.

00:20:19.490 --> 00:20:24.800
The first one is a rather straightforward
example where I ask the script for some

00:20:24.800 --> 00:20:29.820
music and it prompts me with a series of
questions and we have some music played.

00:20:29.940 --> 00:20:34.290
So let's see if my voice is back where
it should be and we'll try this out.

00:20:34.400 --> 00:20:36.480
Some music please.

00:20:40.900 --> 00:20:50.500
[Transcript missing]

00:21:01.100 --> 00:21:10.310
So in this example, the script starts up,
it got the information about

00:21:10.320 --> 00:21:12.980
which artists were available,
held it into memory,

00:21:12.980 --> 00:21:15.480
and said which artist or category.

00:21:15.480 --> 00:21:17.800
When I said Christine Kane,
it matched that,

00:21:17.900 --> 00:21:21.720
then queried and found out which songs
were available by Christine Kane,

00:21:21.720 --> 00:21:25.740
held that into memory,
and then said which song I said Tucson,

00:21:25.740 --> 00:21:29.690
that matched, and then it had the
song play with iTunes.

00:21:29.700 --> 00:21:33.030
So this is a simple example.

00:21:36.620 --> 00:21:39.040
You've got to program in a certain
amount of grief with these things,

00:21:39.140 --> 00:21:40.500
just to keep you honest.

00:21:40.700 --> 00:21:45.160
So there's an example of being able to
carry on a conversation with a script.

00:21:45.280 --> 00:21:48.020
It's a limited conversation,
but it is a way of gathering

00:21:48.060 --> 00:21:50.130
information and moving forward.

00:21:50.140 --> 00:21:54.090
And the, uh, hide this application.

00:21:54.460 --> 00:21:57.800
In the next example,
I'm going to use a program

00:21:57.910 --> 00:21:59.670
from BiApp Systems.

00:21:59.810 --> 00:22:02.280
It's called GoTreef,
and one of the things that this

00:22:02.280 --> 00:22:05.700
application does is it accesses
information over the Internet.

00:22:05.700 --> 00:22:09.570
And I'm going to use a
script acting as a person,

00:22:09.690 --> 00:22:11.500
a personality called Victoria.

00:22:11.500 --> 00:22:19.100
And Victoria will act independently
of the speech recognition speakable

00:22:19.100 --> 00:22:22.640
items in that she will have her
own set of scripts that she's

00:22:22.640 --> 00:22:24.690
going to use in conversing with me.

00:22:24.700 --> 00:22:25.430
So here we go.

00:22:25.430 --> 00:22:27.700
Let's try this out and
see if she's awake too.

00:22:28.600 --> 00:22:29.700
Victoria?

00:22:29.750 --> 00:22:31.900
Yes, Sal?

00:22:32.910 --> 00:22:34.700
Show my newspaper.

00:22:34.930 --> 00:22:36.700
Here you go.

00:22:37.510 --> 00:22:38.690
Something else?

00:22:39.900 --> 00:22:42.100
Clear all stories.

00:22:42.100 --> 00:22:46.240
All stories have been
removed from your newspaper.

00:22:46.240 --> 00:22:46.900
Add multiples.

00:22:46.900 --> 00:22:48.690
Anything else?

00:22:49.880 --> 00:22:52.640
Add multiple stories.

00:22:52.720 --> 00:22:55.040
Ready.

00:22:55.110 --> 00:22:57.240
Motley Fool.

00:22:57.310 --> 00:22:59.590
Adding Motley Fool.

00:23:01.330 --> 00:23:02.700
Ready.

00:23:02.800 --> 00:23:05.200
Apple Stock Quote.

00:23:05.310 --> 00:23:07.850
Adding Apple Stock Quote.

00:23:09.710 --> 00:23:11.260
Ready.

00:23:11.270 --> 00:23:13.640
Apple Top Story.

00:23:13.640 --> 00:23:16.350
Adding Apple Top Story.

00:23:18.200 --> 00:23:27.800
[Transcript missing]

00:23:28.640 --> 00:23:29.450
Not right now.

00:23:29.450 --> 00:23:31.880
Not right now.

00:23:32.490 --> 00:23:34.380
Goodbye.

00:23:41.410 --> 00:23:44.060
So in this instance,
when the script was called Victoria,

00:23:44.220 --> 00:23:47.320
which exists in the Speakable Items,
when the script loads up,

00:23:47.320 --> 00:23:50.710
it goes to a subfolder in the
Speakable Items folder called Tasks.

00:23:51.050 --> 00:23:53.560
And within that folder
are individual scripts,

00:23:53.560 --> 00:23:55.950
the names of which she holds into memory.

00:23:55.960 --> 00:23:58.510
When I say show my newspaper,
she loads that script

00:23:58.750 --> 00:24:00.150
and then executes that.

00:24:00.300 --> 00:24:02.470
So you have a script running a script.

00:24:02.600 --> 00:24:06.460
And all of the commands that
Victoria were doing are not included in

00:24:06.550 --> 00:24:09.170
the standard Speakable Items commands.

00:24:09.310 --> 00:24:10.110
They are subsets.

00:24:10.230 --> 00:24:12.170
So you can create these
individual personalities.

00:24:12.180 --> 00:24:15.750
So that's just two examples of how
you can use AppleScript in speech.

00:24:15.850 --> 00:24:17.810
And if you're interested
in how to do this,

00:24:17.900 --> 00:24:20.520
the AppleScript website
has a complete overview.

00:24:20.520 --> 00:24:24.140
It has an AppleScript guidebook of how
to use speech and AppleScript together.

00:24:24.340 --> 00:24:24.590
Thank you.

00:24:29.580 --> 00:24:31.830
Some issues.

00:24:31.840 --> 00:24:34.220
If you're going to include
speech in your application,

00:24:34.220 --> 00:24:37.700
then there's a few things
that you need to keep in mind.

00:24:37.700 --> 00:24:40.040
Educate your users about how to speak.

00:24:40.040 --> 00:24:43.110
A good example would be go to
the speech preference panel

00:24:43.120 --> 00:24:44.320
and turn on speakable items.

00:24:44.320 --> 00:24:48.130
And you'll see a sheet come down,
and you'll see how we explained to users

00:24:48.140 --> 00:24:51.700
that they shouldn't pause and so on.

00:24:51.800 --> 00:24:54.220
Let them know about background
noise being a problem.

00:24:54.220 --> 00:24:57.330
You might want to refer them
to head-mounted microphones.

00:24:57.430 --> 00:25:01.620
We train the speech recognizer
on North American English.

00:25:01.650 --> 00:25:05.160
And so officially,
that's what we say we support.

00:25:05.270 --> 00:25:07.260
That happens that it
is somewhat forgiving.

00:25:07.260 --> 00:25:09.740
And so I'm Australian.

00:25:09.750 --> 00:25:12.390
In our group, we have Jerome from France.

00:25:12.570 --> 00:25:13.760
We have Devang.

00:25:13.760 --> 00:25:14.570
Where are you, Devang?

00:25:14.740 --> 00:25:16.520
Native Gujarati speaker.

00:25:16.550 --> 00:25:19.640
We have Matthias,
who speaks Swiss German as

00:25:19.640 --> 00:25:20.580
native language.

00:25:20.620 --> 00:25:25.400
We even have Tom from the
Bronx and understands all of us.

00:25:25.690 --> 00:25:27.620
But again, there are limits.

00:25:27.800 --> 00:25:29.080
And localization is an issue.

00:25:29.340 --> 00:25:32.170
Currently, as I said, we are US only.

00:25:33.040 --> 00:25:35.200
So it's time to code.

00:25:35.200 --> 00:25:37.310
For Speech Programming 101,
I'd like to invite Matthias

00:25:37.320 --> 00:25:39.080
Neeracher up onto the stage.

00:25:39.080 --> 00:25:40.670
Matthias.

00:25:45.520 --> 00:25:48.440
Okay, now that Kim has told you
what to do with speech,

00:25:48.440 --> 00:25:52.820
Kevin and I are going to
talk about how to do this.

00:25:53.410 --> 00:25:56.340
Using our speech technologies
in Mac OS X is pretty simple.

00:25:56.340 --> 00:25:59.140
We are installed in every
install of Mac OS X.

00:25:59.140 --> 00:26:02.100
To use us,
just link with Carbon Framework,

00:26:02.100 --> 00:26:08.440
or if you have a Carbon-based
application with Carbon Lib.

00:26:09.370 --> 00:26:13.440
Our APIs are identical for Cocoa,
for Carbon,

00:26:13.440 --> 00:26:16.710
the same APIs that you used on Mac OS 9.

00:26:16.710 --> 00:26:22.320
You can use them from Objective-C,
from C, or from pretty much any language

00:26:22.960 --> 00:26:25.100
that we ship on Mac OS X.

00:26:25.570 --> 00:26:27.980
Let's start with speech synthesis.

00:26:28.040 --> 00:26:31.530
Let's say you want your
application to say something.

00:26:31.670 --> 00:26:34.070
How difficult can this be?

00:26:34.260 --> 00:26:35.750
Turns out it's not difficult at all.

00:26:35.750 --> 00:26:41.080
It's a single line,
and you will get... Hello, world.

00:26:41.080 --> 00:26:43.120
Okay, that was simple enough.

00:26:43.220 --> 00:26:45.600
If you want to have a
little bit more control,

00:26:45.600 --> 00:26:50.310
you open a speech channel,
giving a voice.

00:26:50.440 --> 00:26:55.480
This can either be something that you
get from a menu you give to the user,

00:26:55.480 --> 00:26:59.080
or if you pass in null,
you get the default voice.

00:26:59.910 --> 00:27:02.790
You probably shouldn't hard-code
a voice unless you know exactly

00:27:02.930 --> 00:27:04.340
why you would want to do this.

00:27:04.480 --> 00:27:07.460
Then you can adjust
parameters as you like them,

00:27:07.460 --> 00:27:11.790
and once you have them to your liking,
you can speak the actual

00:27:11.890 --> 00:27:14.270
text by calling speakText.

00:27:16.010 --> 00:27:20.930
All of these calls are asynchronous,
so it will actually return control to

00:27:20.930 --> 00:27:23.550
you before the text is entirely spoken.

00:27:26.490 --> 00:27:28.010
We offer a lot of control.

00:27:28.320 --> 00:27:32.430
You can control the speech rate
to speak slower for younger users,

00:27:32.560 --> 00:27:34.770
for instance,
or quicker in a game situation,

00:27:34.860 --> 00:27:35.750
for instance.

00:27:35.760 --> 00:27:41.000
We can control the speech pitch,
modulation, so it sounds more lively,

00:27:41.000 --> 00:27:45.230
the volume, to customize the way speech
sounds in your application.

00:27:45.320 --> 00:27:50.400
We also give you callback routines,
so when you have a screen reader,

00:27:50.500 --> 00:27:54.340
you can highlight words on
screen as they are spoken,

00:27:54.840 --> 00:27:57.320
or if you have an animated
character on screen,

00:27:57.470 --> 00:28:01.360
you can animate the lips of the
character as the phonemes are spoken.

00:28:01.360 --> 00:28:04.350
You can see many of these
options in action in our

00:28:04.350 --> 00:28:08.810
Cocoa Speech Synthesis example,
which ships on the developer CD.

00:28:10.910 --> 00:28:13.020
Most of these controls,
you actually don't have to

00:28:13.020 --> 00:28:16.110
write any code because you
can simply embed them in text.

00:28:16.200 --> 00:28:20.390
So, for instance, in this sentence,
if you want to emphasize the word next,

00:28:20.390 --> 00:28:25.530
you just embed an emphasis
command in front of the word.

00:28:25.600 --> 00:28:28.500
Don't meet till next Tuesday.

00:28:28.500 --> 00:28:32.770
This is very important because
to really have speech synthesis

00:28:32.770 --> 00:28:37.530
work for you the best it can,
you should customize what is spoken.

00:28:38.960 --> 00:28:40.780
Basically,
your application just knows a lot

00:28:40.780 --> 00:28:44.940
more about how things should be spoken
than our engines can know by default.

00:28:44.940 --> 00:28:49.340
So, there are a number of things you can
and should do with your application.

00:28:49.420 --> 00:28:51.840
First of all,
you should filter the text that is

00:28:51.890 --> 00:28:54.140
passed on to the text-to-speech engine.

00:28:54.140 --> 00:28:57.840
For instance,
if you have a stock ticker application

00:28:57.840 --> 00:29:02.180
and you come across the acronym AAPL,
what you should do is tell

00:29:02.180 --> 00:29:06.300
the text-to-speech engine to
say Apple Computer instead.

00:29:06.640 --> 00:29:09.840
Second,
you should customize the pronunciation

00:29:09.970 --> 00:29:12.590
of words that don't come out right.

00:29:12.710 --> 00:29:16.530
And last of all, you should customize the
intonation of what is spoken.

00:29:18.570 --> 00:29:23.140
Now, we try to have a huge dictionary,
as Kim already said,

00:29:23.390 --> 00:29:27.260
but even the biggest dictionary
cannot possibly handle all the words,

00:29:27.340 --> 00:29:29.510
and not all proper names especially.

00:29:29.600 --> 00:29:32.120
For instance, my first name is tricky.

00:29:32.120 --> 00:29:35.990
It's certainly, our system cannot
pronounce it by default.

00:29:36.180 --> 00:29:38.810
In the past,
some developers have just used

00:29:39.330 --> 00:29:43.220
funny spellings to get it to
work approximately the right way,

00:29:43.270 --> 00:29:44.000
like this.

00:29:44.180 --> 00:29:46.140
My name is Matthias.

00:29:47.190 --> 00:29:49.660
Sounds almost right,
but we don't recommend this,

00:29:50.110 --> 00:29:53.760
because if you use words that are
not part of the English language,

00:29:53.760 --> 00:29:56.950
or strange combinations,
we might change in the future

00:29:57.060 --> 00:29:58.570
how this is pronounced.

00:29:58.580 --> 00:30:03.170
Second, this is not a very precise way
of specifying what you want said.

00:30:03.180 --> 00:30:07.890
So, instead, what you should do is use
embedded commands to temporarily

00:30:07.890 --> 00:30:11.940
switch to phoneme input,
using the phoneme notation.

00:30:11.940 --> 00:30:17.200
We describe this notation
in inside Macintosh speech.

00:30:17.710 --> 00:30:20.670
It's explained with examples on a page.

00:30:20.700 --> 00:30:23.770
It doesn't take very long at
all to learn how to use it,

00:30:23.770 --> 00:30:25.440
and the result is something like this.

00:30:25.440 --> 00:30:27.440
My name is Matthias.

00:30:28.040 --> 00:30:29.440
Sounds somewhat better.

00:30:30.640 --> 00:30:33.320
Second,
you should customize the intonation of

00:30:33.320 --> 00:30:37.840
the text you pass on to text-to-speech,
because the written words alone are not

00:30:37.840 --> 00:30:40.460
always enough to convey the meaning.

00:30:40.460 --> 00:30:44.330
For instance, if you see this sentence,
you can read it as,

00:30:44.650 --> 00:30:46.940
John only introduced Mary to Bill.

00:30:46.940 --> 00:30:49.650
He didn't introduce her to anybody else.

00:30:49.780 --> 00:30:53.760
You could read it as,
John only introduced Mary to Bill.

00:30:53.760 --> 00:30:56.200
He didn't introduce Caroline to him.

00:30:56.200 --> 00:30:59.960
Or you can read it as,
John only introduced Mary to Bill.

00:31:00.600 --> 00:31:02.390
He didn't ask her to marry him.

00:31:02.400 --> 00:31:06.520
So,
these distinctions can be very important.

00:31:06.520 --> 00:31:08.990
So, you should...

00:31:09.510 --> 00:31:11.150
Annotate the text you pass on.

00:31:11.150 --> 00:31:18.000
Our system tries to do the best it can to
find out how a sentence should be spoken,

00:31:18.000 --> 00:31:21.930
but this can be very difficult,
if not impossible,

00:31:21.930 --> 00:31:23.130
to do in the general case.

00:31:23.220 --> 00:31:27.780
Your application has domain knowledge
of much of the text that is spoken and

00:31:27.860 --> 00:31:30.460
has the potential to do much better.

00:31:31.280 --> 00:31:34.660
For instance,
take a flight reservation system.

00:31:34.660 --> 00:31:37.230
At the end, it gives a confirmation text.

00:31:37.240 --> 00:31:39.470
And I'm going to play you
two different versions of

00:31:39.570 --> 00:31:41.080
saying this confirmation text.

00:31:41.160 --> 00:31:46.020
First of all, it's not annotated at all,
and the second is annotated.

00:31:46.020 --> 00:31:49.920
I'm not going to say anything
between the two versions.

00:31:49.920 --> 00:31:54.800
Your first flight is with
Alaskan Airlines Flight 2762

00:31:54.890 --> 00:32:00.110
departing from San Jose on Monday,
May 24th at 6.10 landing

00:32:00.110 --> 00:32:00.920
in San Francisco.

00:32:01.410 --> 00:32:06.540
Thank you for using TTS Travel.

00:32:09.420 --> 00:32:13.700
Your first flight is
with Alaskan Airlines,

00:32:13.700 --> 00:32:15.990
flight 2762.

00:32:16.100 --> 00:32:22.000
Departing from San Jose on Monday,
May 24th at 6:10 p.m., landing

00:32:22.130 --> 00:32:25.740
in San Francisco at 7:10 p.m.

00:32:25.890 --> 00:32:32.070
Thank you for choosing TTS Travel.

00:32:32.980 --> 00:32:34.010
So did you hear a difference?

00:32:34.020 --> 00:32:37.080
Raise your hand if you heard a
difference between the two versions.

00:32:37.080 --> 00:32:37.540
Excellent.

00:32:37.540 --> 00:32:38.970
I see that the hands are up.

00:32:39.300 --> 00:32:41.860
So we did this with quite
a bit of annotation.

00:32:41.890 --> 00:32:47.400
And this can basically be distilled
to five principles of how to improve

00:32:47.400 --> 00:32:51.070
the intonation of the spoken elements.

00:32:51.120 --> 00:32:54.980
The first principle is let the
user catch up by adding pauses at

00:32:55.040 --> 00:32:57.980
strategically important points.

00:32:58.210 --> 00:33:02.800
Add punctuation wherever appropriate,
and appropriate does not mean appropriate

00:33:02.880 --> 00:33:04.800
in the sense of English grammar.

00:33:04.800 --> 00:33:08.600
Nobody is going to see what is spoken,
so feel free to add a comma if you

00:33:08.670 --> 00:33:11.340
think a pause is necessary at a point.

00:33:11.440 --> 00:33:14.190
Break up larger sentences
into smaller ones,

00:33:14.420 --> 00:33:21.650
and insert some explicit pauses with the
silence command at major pause points.

00:33:21.860 --> 00:33:24.210
So in our example,

00:33:24.350 --> 00:33:29.280
We added punctuation, we added pauses.

00:33:29.280 --> 00:33:32.490
All of this lets the user catch up.

00:33:32.890 --> 00:33:39.030
Second principle is to let familiar
things go into the background by

00:33:39.030 --> 00:33:42.290
de-emphasizing repeated words.

00:33:42.420 --> 00:33:45.430
For instance,
if the minutes are identical,

00:33:45.430 --> 00:33:48.790
you should de-emphasize
the second instance.

00:33:48.950 --> 00:33:54.240
Also, de-emphasize items inferable from
your overall application scenario.

00:33:54.240 --> 00:33:58.520
You know that you're booking a flight,
so you don't have to emphasize this word.

00:33:58.830 --> 00:34:02.770
Third principle is to liven
it up simply by adding an

00:34:02.770 --> 00:34:05.090
exclamation point at the end.

00:34:05.770 --> 00:34:09.170
Fourth principle is to focus
the user's attention by

00:34:09.170 --> 00:34:12.140
emphasizing the important words.

00:34:12.240 --> 00:34:17.050
This can be done with an emphasis
command or simply by inserting a

00:34:17.050 --> 00:34:20.670
colon before the most important item.

00:34:22.300 --> 00:34:27.700
And fifth, and maybe most important,
use paragraph intonation.

00:34:28.370 --> 00:34:32.460
Group your sentences together
into intonational paragraphs.

00:34:32.600 --> 00:34:36.640
And the first sentence in this paragraph,
you should raise the pitch range

00:34:36.790 --> 00:34:39.100
and then reset it for the rest.

00:34:39.240 --> 00:34:44.450
This makes quite a bit of difference
for longer texts that are read.

00:34:45.000 --> 00:34:49.780
You raise the pitch base and
increase the pitch modulation,

00:34:49.840 --> 00:34:53.570
and then decrease it
after the first sentence.

00:34:54.870 --> 00:34:58.620
And between paragraphs,
add an extra pause.

00:34:58.940 --> 00:35:02.990
So to summarize, you should--

00:35:04.470 --> 00:35:07.300
Customize the pronunciation
of words that you say.

00:35:07.320 --> 00:35:10.320
If you notice that a word
you have hardcoded in your

00:35:10.400 --> 00:35:13.620
application gets mispronounced,
use phoneme mode to get

00:35:13.620 --> 00:35:14.560
it pronounced correctly.

00:35:14.560 --> 00:35:19.530
You should customize the intonation
of the text that is said,

00:35:19.530 --> 00:35:24.900
which helps the user understand the
text a lot better and gives the user a

00:35:24.900 --> 00:35:27.340
much better overall speech experience.

00:35:29.220 --> 00:35:34.140
Now, let's move on to speech recognition
with my colleague Kevin Aiitken,

00:35:34.300 --> 00:35:37.480
who is not lazy at all, I might add.

00:35:43.930 --> 00:35:44.940
Can you all hear me?

00:35:45.030 --> 00:35:46.000
Yes, I can hear myself.

00:35:46.020 --> 00:35:50.680
Well, my manager, Kim,
has actually assured me that

00:35:50.750 --> 00:35:53.280
this is not necessarily a
commentary on my work ethic,

00:35:53.310 --> 00:35:54.560
so I feel better.

00:35:54.560 --> 00:35:59.950
But if you're like me, once in a while,
I do feel a little bit lazy.

00:35:59.960 --> 00:36:02.970
And at those times,
I just love having a simple

00:36:03.050 --> 00:36:05.400
solution to be really productive.

00:36:06.240 --> 00:36:10.940
And so in the next 15 minutes or so,
I'm going to show you two easy

00:36:10.940 --> 00:36:14.430
methods that you can use to add
spoken commands to your application.

00:36:14.460 --> 00:36:17.040
And so hopefully,
in an afternoon's worth of work,

00:36:17.040 --> 00:36:20.940
you can walk into your manager's office
or your co-worker's office and say,

00:36:20.940 --> 00:36:25.430
Oh, by the way, our Mac OS X application
understands spoken commands.

00:36:25.460 --> 00:36:27.090
So let's get started.

00:36:30.370 --> 00:36:34.020
So as I mentioned,
I'm going to provide two methods.

00:36:34.080 --> 00:36:38.220
So the first method is to use
the Speakable Items application

00:36:38.220 --> 00:36:40.300
that's built into Mac OS X.

00:36:40.300 --> 00:36:43.200
As Kim demoed in the beginning,
it's designed for end users,

00:36:43.200 --> 00:36:46.320
so they can easily add spoken
commands to any application.

00:36:46.330 --> 00:36:49.500
And so you as a developer
can use this also.

00:36:49.560 --> 00:36:52.430
So it's great because you don't
have to write any speech code.

00:36:52.640 --> 00:36:56.020
Speakable Items takes care of this
for you by taking a list of items,

00:36:56.020 --> 00:36:58.740
building a language model,
and then waiting for

00:36:58.740 --> 00:37:00.060
the recognition result.

00:37:00.320 --> 00:37:04.710
And as Sal showed in his demonstration,
it understands how to execute

00:37:04.720 --> 00:37:08.360
AppleScript so that you can easily send
Apple events to your application or

00:37:08.360 --> 00:37:10.150
even other applications for that matter.

00:37:11.960 --> 00:37:13.830
Now,
the second method I'm going to describe

00:37:14.190 --> 00:37:15.890
is to use the Speech Recognition API.

00:37:15.900 --> 00:37:19.900
You may be familiar
with this in Mac OS 9.

00:37:19.900 --> 00:37:21.900
It gives you a little
bit more flexibility.

00:37:21.900 --> 00:37:26.020
You can have multiple command lists,
so you can have one set of commands for

00:37:26.020 --> 00:37:28.870
when the user has selected an object,
and one set of commands

00:37:28.980 --> 00:37:29.890
when they haven't.

00:37:29.900 --> 00:37:33.370
And I'm going to show you in a little
bit an example that gives you a really

00:37:33.370 --> 00:37:38.220
easy three-step approach to adding
spoken commands to your application

00:37:38.220 --> 00:37:40.890
using the Speech Recognition API.

00:37:41.170 --> 00:37:43.200
Well,
one of the things that both of these

00:37:43.200 --> 00:37:46.030
methods have in common are commands.

00:37:46.100 --> 00:37:50.820
And so let's talk just for a second
about what makes a good command.

00:37:51.120 --> 00:37:54.390
Well, commands are like menu items,
but we suggest that they're normally

00:37:55.020 --> 00:37:57.040
from three to six words long.

00:37:57.040 --> 00:38:00.600
The longer, the better, generally,
because the recognition system

00:38:00.770 --> 00:38:03.790
can understand them easier,
and they're more unique

00:38:03.790 --> 00:38:05.830
amongst your other commands.

00:38:05.840 --> 00:38:08.990
But you don't want them too long
to where the user has a hard

00:38:08.990 --> 00:38:10.860
time speaking them fluently.

00:38:11.760 --> 00:38:15.220
Also, you should avoid single words,
and especially words like hot, cut,

00:38:15.220 --> 00:38:19.680
and quit, because those are oftentimes
misrecognized or they sound a

00:38:19.680 --> 00:38:22.760
light to the recognition system.

00:38:24.980 --> 00:38:28.440
The other important item is that
you should test your commands,

00:38:28.750 --> 00:38:31.780
especially test them together
to make sure they're not

00:38:31.970 --> 00:38:35.420
confused with each other,
and test them with the global commands

00:38:35.420 --> 00:38:37.420
that are shipped with Mac OS X.

00:38:37.510 --> 00:38:40.980
And to prototype your commands,
you can use speakable IAMs or the

00:38:40.980 --> 00:38:44.990
SR Language Modeler application
that you'll find on a developer CD.

00:38:45.780 --> 00:38:49.740
Okay, let's talk about Method 1
in a little more depth.

00:38:49.740 --> 00:38:52.860
And this is using the
Speakable Items application.

00:38:53.180 --> 00:38:55.740
So the first thing, as I mentioned,
you want to create a number of items.

00:38:55.740 --> 00:38:59.880
You can easily do this by bringing
your application to the foreground

00:39:00.280 --> 00:39:03.630
and speaking the command,
make this application speakable.

00:39:03.640 --> 00:39:06.290
That creates a folder in the
speakable items directory,

00:39:06.290 --> 00:39:08.640
as Kim showed you earlier,
inside that application

00:39:08.720 --> 00:39:10.140
speakable items folder.

00:39:10.140 --> 00:39:13.970
And then you can begin adding
your items as he showed you.

00:39:13.980 --> 00:39:18.890
So once you have all your items together,
the next thing is you want to bundle

00:39:18.890 --> 00:39:21.330
those inside of your application.

00:39:22.140 --> 00:39:24.290
So I'm going to show you a
little bit of an example.

00:39:24.570 --> 00:39:28.860
You can use Project Builder to easily
copy these files into your application

00:39:28.860 --> 00:39:30.360
bundle at the time you build it.

00:39:30.460 --> 00:39:34.710
And then finally,
you need to install those items.

00:39:36.420 --> 00:39:38.380
Now, we really suggest that you
install them at runtime.

00:39:38.380 --> 00:39:40.960
This gives you a couple
of added benefits.

00:39:41.040 --> 00:39:44.480
It allows your application to
be drag-and-drop installed,

00:39:44.480 --> 00:39:47.320
so therefore,
in order to support speakable items,

00:39:47.320 --> 00:39:50.420
you don't have to have a separate
installer to install the items.

00:39:50.440 --> 00:39:54.310
And it's great for Mac OS X support
for multiple users,

00:39:54.310 --> 00:39:58.240
because after your application
has been installed,

00:39:58.240 --> 00:40:00.660
let's say the administrator
creates new users,

00:40:01.110 --> 00:40:04.230
well, that new user is just going to
get those speakable items the next

00:40:04.420 --> 00:40:06.400
time they run your application,
because you'll

00:40:06.400 --> 00:40:07.430
automatically install them.

00:40:09.500 --> 00:40:11.690
Well, let's talk about items real quick.

00:40:11.830 --> 00:40:13.370
Kim briefly mentioned those.

00:40:13.630 --> 00:40:15.750
It's basically any file
that can be opened.

00:40:15.880 --> 00:40:19.230
But there's really two types
that are best for you developers.

00:40:19.400 --> 00:40:23.320
The first are AppleScript files,
as I talked about, that allow you to send

00:40:23.320 --> 00:40:25.400
Apple events to your application.

00:40:25.420 --> 00:40:29.400
The other one that Kim mentioned
are the new XML-based command files,

00:40:29.400 --> 00:40:32.560
and they allow you to send keyboard
events to your application so

00:40:32.560 --> 00:40:37.810
that you can activate menus or
controls via keyboard shortcuts.

00:40:40.170 --> 00:40:44.700
Well, one of the things that I wanted to
do in preparing for this WWDC this

00:40:44.850 --> 00:40:49.730
year is create an example that
really showed how easy it is to add

00:40:49.730 --> 00:40:51.360
spoken commands to your application.

00:40:51.460 --> 00:40:55.300
I really wanted to make it
as simple as copy-paste-go.

00:40:55.300 --> 00:40:58.690
So, as you saw in Sal's demonstration,
you use iTunes,

00:40:58.690 --> 00:41:02.280
and that's a really pretty
good real-world application.

00:41:02.350 --> 00:41:04.820
It's shipping,
and you can see how those are

00:41:04.940 --> 00:41:07.120
integrated into the application.

00:41:07.170 --> 00:41:11.800
Well, since I can't ship or give you
the source code for iTunes,

00:41:11.800 --> 00:41:14.680
I thought, well,
let me create a clone of it.

00:41:14.760 --> 00:41:18.850
So, I've named mine Fotoons,
courtesy of our

00:41:18.850 --> 00:41:21.590
French person in the group.

00:41:21.630 --> 00:41:24.540
And it's up on the web right now.

00:41:24.560 --> 00:41:26.280
You can go grab it at this URL.

00:41:26.280 --> 00:41:32.590
And hopefully you can either
grab it this week or right now,

00:41:32.600 --> 00:41:35.110
or when you get back and
start taking a look at it.

00:41:35.220 --> 00:41:40.340
It's really... I believe it shows
a really easy way of getting going.

00:41:40.340 --> 00:41:44.470
So, let me go show it to you.

00:41:44.500 --> 00:41:45.530
Here we go.

00:41:51.300 --> 00:42:01.400
[Transcript missing]

00:42:04.330 --> 00:42:08.450
So let me show you the application,
my clone of iTunes real quick.

00:42:08.930 --> 00:42:12.630
It has the identical menu items.

00:42:12.630 --> 00:42:15.020
And the window is, you know,
pretty close.

00:42:15.110 --> 00:42:19.760
I mean, if you haven't done anything
in Cocoa or Interface Builder,

00:42:19.850 --> 00:42:23.690
I basically took 15 minutes,
threw all the menus in there,

00:42:23.690 --> 00:42:26.240
laid out the window,
and pretty much got an

00:42:26.360 --> 00:42:28.050
automatic resizing window.

00:42:28.220 --> 00:42:29.810
It's really awesome.

00:42:30.870 --> 00:42:34.880
Okay, let me show you that it really
is listening for commands.

00:42:41.440 --> 00:42:43.500
Show commands window.

00:42:43.500 --> 00:42:45.740
Show speech commands window.

00:42:45.740 --> 00:42:47.620
Oh, okay.

00:42:47.860 --> 00:42:50.060
That's the first.

00:42:50.060 --> 00:42:51.540
Display visual.

00:42:51.540 --> 00:42:54.600
Oops, let me bring this forward.

00:42:54.610 --> 00:42:56.780
Get song info.

00:42:58.080 --> 00:43:02.090
Get Song Info.

00:43:02.240 --> 00:43:02.450
There we go.

00:43:02.450 --> 00:43:03.500
As you see, it doesn't do anything.

00:43:03.500 --> 00:43:04.960
It just shows the command down below.

00:43:05.370 --> 00:43:05.720
Okay.

00:43:05.720 --> 00:43:07.980
So it really is Photons.

00:43:07.980 --> 00:43:09.000
Okay.

00:43:09.000 --> 00:43:13.900
Let's switch into Project Builder,
and I'll show you how this is set up.

00:43:14.050 --> 00:43:16.000
Let me try the command.

00:43:16.000 --> 00:43:17.990
Switch to Project Builder.

00:43:17.990 --> 00:43:19.840
Yay.

00:43:19.840 --> 00:43:21.990
Okay.

00:43:21.990 --> 00:43:21.990
Cool.

00:43:23.350 --> 00:43:25.940
I'll move those out of the way
so we can see the window here.

00:43:25.970 --> 00:43:29.950
I'll put this down since I'll
be giving it more commands.

00:43:30.460 --> 00:43:34.140
Okay, so let me show you real quick.

00:43:35.740 --> 00:43:38.120
What this basic object looks
like that manages the window.

00:43:38.120 --> 00:43:38.840
It's really simple.

00:43:38.840 --> 00:43:42.970
It has a couple of instance variables,
and then it pretty much has a method

00:43:42.970 --> 00:43:46.740
for each one of the menu items,
and a couple extras to handle some

00:43:46.740 --> 00:43:48.640
of the controls in the window.

00:43:48.640 --> 00:43:50.020
So it's really simple.

00:43:50.020 --> 00:43:52.950
All these methods do is
basically display at the bottom

00:43:53.120 --> 00:43:55.220
of that window what's happening.

00:43:55.220 --> 00:43:59.140
Okay, so as I mentioned,
the first step was creating the items.

00:43:59.140 --> 00:44:01.070
So we've created those items.

00:44:01.070 --> 00:44:04.860
The next step is we need to include
them in our application bundle.

00:44:05.680 --> 00:44:11.150
So what we'll do is we'll
go to the active target.

00:44:11.650 --> 00:44:17.290
And the way we do this is we
use a file copies build phase.

00:44:17.710 --> 00:44:19.660
And so we include those down here.

00:44:19.660 --> 00:44:21.070
Let me show you where you do that.

00:44:21.270 --> 00:44:24.200
And here, if you haven't already seen it,
you go New Build Phase,

00:44:24.240 --> 00:44:26.540
and you go New Copy Build Phase.

00:44:26.540 --> 00:44:29.300
It's not highlighted right at
the moment because I haven't

00:44:29.300 --> 00:44:31.140
selected a particular item.

00:44:31.200 --> 00:44:34.580
But as you can see,
I've included the items here.

00:44:34.620 --> 00:44:37.020
I have two sets of items.

00:44:37.100 --> 00:44:39.660
I have the command files,
the majority of them.

00:44:39.770 --> 00:44:45.420
And so I'm saying place these in a folder
named Command Files inside the resources

00:44:45.530 --> 00:44:47.700
directory of the application bundle.

00:44:47.770 --> 00:44:53.560
And then I have a single AppleScript file
that I've included in here as well.

00:44:53.720 --> 00:44:56.670
Okay, so now Project Builder
has made that easy.

00:44:57.050 --> 00:45:00.370
Now they're being copied when I build it,
being copied inside

00:45:00.370 --> 00:45:01.620
the application bundle.

00:45:01.880 --> 00:45:05.460
The next task is to
install them at runtime.

00:45:05.600 --> 00:45:09.450
So we've tried to simplify this
a lot by providing a single

00:45:09.450 --> 00:45:11.970
routine that you can call.

00:45:12.290 --> 00:45:12.880
So here it is.

00:45:13.050 --> 00:45:15.600
Install speakable items
for this application.

00:45:15.620 --> 00:45:19.390
You'll pass in the name of those
folders that you placed your items

00:45:19.480 --> 00:45:20.920
into your resources directory.

00:45:20.920 --> 00:45:23.640
And then you'll call it,
and it's smart enough to go out,

00:45:23.640 --> 00:45:24.840
creates the folder.

00:45:24.840 --> 00:45:27.780
If the folder's already there,
it doesn't create it again.

00:45:27.780 --> 00:45:30.940
In the case of this demo,
I actually call this routine

00:45:30.940 --> 00:45:33.840
every time it's startup,
but you could choose to

00:45:33.840 --> 00:45:36.510
call it lazily later,
or you could call it in

00:45:36.620 --> 00:45:40.130
response to a user specifying
it in a preferences dialog,

00:45:40.130 --> 00:45:41.740
or something like that.

00:45:42.430 --> 00:45:46.100
The rest of this file has a
tutorial or documentation in more

00:45:46.100 --> 00:45:50.170
depth than I've talked about here,
about creating the items,

00:45:50.300 --> 00:45:52.360
adding those items to
your application bundle,

00:45:52.640 --> 00:45:55.920
and then how to call this
routine and special notes.

00:45:56.020 --> 00:45:57.730
So it's all there.

00:45:58.360 --> 00:46:03.960
Okay,
let's go back to the slides for a second.

00:46:05.800 --> 00:46:07.460
Okay, great.

00:46:07.520 --> 00:46:10.560
So let's touch on the second
method for a minute here,

00:46:10.920 --> 00:46:13.340
and that's using the
Speech Recognition API.

00:46:13.340 --> 00:46:15.960
Well, you know,
just like the previous example,

00:46:15.960 --> 00:46:18.580
I want to make it a copy, paste,
and go solution.

00:46:18.580 --> 00:46:23.200
So we're trying to provide some really
simple routines that you can use.

00:46:23.240 --> 00:46:26.540
So what I've done is I've broken
down the process of recognition,

00:46:26.540 --> 00:46:29.530
setting up for recognition,
and handling the recognition

00:46:29.530 --> 00:46:30.700
into three easy steps.

00:46:30.810 --> 00:46:34.670
And you'll see in a minute where
I provide you with a single routine

00:46:34.670 --> 00:46:36.880
to execute each one of these steps.

00:46:36.900 --> 00:46:41.830
So let's talk a minute about basically
what the recognition process looks like.

00:46:41.900 --> 00:46:45.280
This is a very simplified version of
it and a graphical version of it that

00:46:45.310 --> 00:46:49.980
just kind of cements it in your mind
as to what this example is doing,

00:46:49.980 --> 00:46:53.070
and in general,
what recognition process is.

00:46:53.100 --> 00:46:55.870
what happens during that.

00:46:56.240 --> 00:47:00.600
Okay, so step one,
we provide a routine that basically

00:47:00.600 --> 00:47:04.200
sets up all the recognition objects and
instantiates the recognition system,

00:47:04.200 --> 00:47:07.680
a recognizer object,
a language model object,

00:47:07.970 --> 00:47:10.660
hooks them all together,
and that's all set up and ready to go.

00:47:10.660 --> 00:47:13.950
Something that most,
virtually every developer

00:47:13.950 --> 00:47:18.060
has to do when they adopt the
Apple Speech Recognition API.

00:47:18.060 --> 00:47:21.900
The second step is that you need to
tell it what commands to listen for.

00:47:22.420 --> 00:47:27.040
So in the routine that we give,
you pass in the recognizer object,

00:47:27.040 --> 00:47:29.280
and then you pass in
an array of commands.

00:47:29.280 --> 00:47:33.010
It basically gives the recognizer
object those commands to display

00:47:33.010 --> 00:47:34.920
in the speech commands window.

00:47:34.920 --> 00:47:37.910
Then you also pass in the
language model object,

00:47:37.930 --> 00:47:41.490
and it gives the commands to
that so the recognition engine

00:47:41.490 --> 00:47:43.340
knows what to listen for.

00:47:43.340 --> 00:47:46.140
And then for the third step,
you need to implement

00:47:46.140 --> 00:47:49.920
one Apple Event Handler,
the SpeechDone Apple Event Handler.

00:47:50.670 --> 00:47:52.960
And so now,
your application is just sitting there,

00:47:52.960 --> 00:47:56.030
you've set up, it's running,
ready to handle the

00:47:56.100 --> 00:47:57.720
user's spoken command.

00:47:57.720 --> 00:48:01.770
So when the user says something,
the recognition engine passes

00:48:01.770 --> 00:48:05.930
this off to the recognizer object,
it then sends an Apple Event to

00:48:05.930 --> 00:48:07.240
your application.

00:48:07.340 --> 00:48:09.080
In this case, play this song.

00:48:09.080 --> 00:48:13.610
So we provide you a single routine,
you pass in the Apple Event that you get,

00:48:13.610 --> 00:48:15.080
and it returns an ID.

00:48:15.080 --> 00:48:18.530
And then you can take this ID and map
it through a switch statement or a

00:48:18.580 --> 00:48:20.620
table lookup or however you'd like.

00:48:20.620 --> 00:48:23.040
To a particular action or routine.

00:48:23.180 --> 00:48:27.220
Okay,
so let's go back to Project Builder.

00:48:27.220 --> 00:48:30.000
And I'll show you how this is done.

00:48:39.300 --> 00:50:35.700
[Transcript missing]

00:50:36.960 --> 00:50:40.180
Then I call the routine to set
up speech recognition that we

00:50:40.280 --> 00:50:43.130
provide in that utility file.

00:50:43.630 --> 00:50:47.940
I create an array of the commands
because I need that to pass to the

00:50:47.950 --> 00:50:49.940
add commands routine that we provide.

00:50:50.020 --> 00:50:53.460
And then finally,
I call our SR start listening

00:50:53.560 --> 00:50:58.250
routine that's part of the API,
and now the application

00:50:58.340 --> 00:50:59.850
is up and running.

00:51:00.150 --> 00:51:03.840
Page down here,
this is the Apple Event Handler.

00:51:03.880 --> 00:51:05.580
Just a couple of lines of code.

00:51:05.820 --> 00:51:08.580
I call the routine that we provide
in the utility file to convert

00:51:08.580 --> 00:51:09.960
the Apple Event into the ID.

00:51:09.960 --> 00:51:12.970
And then through the
wonders of Objective-C,

00:51:12.970 --> 00:51:16.970
I just use it as an index into a
table and then basically go off to

00:51:17.010 --> 00:51:19.620
the appropriate method selector.

00:51:21.170 --> 00:51:23.530
So that's pretty much it.

00:51:23.530 --> 00:51:26.700
I really urge you to go out and
grab this and see how this can

00:51:26.700 --> 00:51:29.210
be applied to your application.

00:51:29.340 --> 00:51:34.660
So let me summarize real quick.

00:51:36.300 --> 00:51:40.120
So we saw in the first method,
using the Speakable Iams application,

00:51:40.200 --> 00:51:44.720
that's really easy because you don't
have to write any additional speech code.

00:51:44.720 --> 00:51:48.110
All you need to do is include those
Iams inside your application bundle

00:51:48.110 --> 00:51:51.520
and then install them at runtime
with the routine that we provide.

00:51:51.520 --> 00:51:54.960
The second method is using
the Speech Recognition API.

00:51:54.960 --> 00:51:58.160
As I explained,
that's an easy three-step process

00:51:58.400 --> 00:52:02.520
that we give you a single routine
to execute each one of those steps.

00:52:03.720 --> 00:52:06.250
So I've discussed a lazy way to do it.

00:52:06.790 --> 00:52:10.830
There's more things you can do
with the Speech Recognition API,

00:52:10.850 --> 00:52:13.870
and Matthias is going to come up here
and talk about what to do if you're

00:52:13.870 --> 00:52:15.480
feeling a little bit more ambitious.

00:52:15.480 --> 00:52:17.470
So thank you.

00:52:21.030 --> 00:52:22.120
Thank you, Kevin.

00:52:22.170 --> 00:52:25.100
My manager assures me that
overachievers does not necessarily

00:52:25.100 --> 00:52:27.970
apply to my performance either.

00:52:29.270 --> 00:52:33.990
So Kevin has shown you how to get 95%
of the benefits with 5% of the work.

00:52:34.080 --> 00:52:39.760
However, there are some situations where
you might need the extra 5%.

00:52:39.760 --> 00:52:41.530
One example of this is Chess.

00:52:41.580 --> 00:52:43.770
You've seen it demoed.

00:52:43.870 --> 00:52:45.020
It ships with Mac OS X.

00:52:45.020 --> 00:52:49.300
As of this week, you can get the source
code from this URL here.

00:52:49.300 --> 00:52:54.150
You will find the speech-related
code in Chess Listener.

00:52:55.040 --> 00:53:00.300
And Chess illustrates important
lessons in language model design.

00:53:00.300 --> 00:53:03.190
Now you might think,
the language model of

00:53:03.200 --> 00:53:05.100
Chess is not very complex,
right?

00:53:05.330 --> 00:53:08.480
Pawn, D2 to D4, all simple sentences.

00:53:08.480 --> 00:53:12.840
The problem is, if you just do this as a
list of possible moves,

00:53:12.840 --> 00:53:15.400
it gets out of hand pretty quickly.

00:53:15.400 --> 00:53:19.560
If you do the math,
you find out that if you just have

00:53:19.560 --> 00:53:25.010
a model with all the possible moves,
you end up with more than 24,000 moves.

00:53:25.080 --> 00:53:26.890
And clearly this is unacceptable.

00:53:27.050 --> 00:53:31.280
It doesn't help accuracy,
plus you're not doing the user

00:53:31.330 --> 00:53:35.040
any favor if you're listening
to stuff like Rook A1 to H8.

00:53:35.040 --> 00:53:37.040
This won't do him any good at all.

00:53:37.120 --> 00:53:41.130
In fact,
it turns out that in each Chess position,

00:53:41.340 --> 00:53:45.040
there are only 20 to 30 moves
that are actually legal.

00:53:45.040 --> 00:53:48.970
So there is no reason whatsoever
to include the extra moves.

00:53:49.170 --> 00:53:53.040
Performance is going to go way up,
and user satisfaction

00:53:53.040 --> 00:53:53.040
is going to go way up.

00:53:53.110 --> 00:53:54.130
So you can't do that.

00:53:54.240 --> 00:53:58.670
going to go up if you
only include legal moves.

00:53:59.110 --> 00:54:02.460
However, you shouldn't quite
over-constraint your model.

00:54:02.520 --> 00:54:05.100
There are some illegal moves
which are still plausible.

00:54:05.220 --> 00:54:09.880
For instance, people frequently put their
king into check accidentally,

00:54:09.880 --> 00:54:11.930
even experienced chess players.

00:54:12.060 --> 00:54:17.730
So what you would want to do is to leave
a move like this in so you can say,

00:54:17.730 --> 00:54:20.880
I heard you, but I won't do it.

00:54:22.300 --> 00:54:26.900
Another technique that we use in
chess is to use prefabricated parts.

00:54:27.040 --> 00:54:31.140
There are not so many words that are
actually used in this language model,

00:54:31.140 --> 00:54:35.850
so we fabricate them at
startup by calling srNewWord

00:54:36.100 --> 00:54:38.060
to get these word objects.

00:54:38.180 --> 00:54:41.260
And then when we come to
a position and see that,

00:54:41.260 --> 00:54:45.340
for instance,
pawn d2 to d4 would be appropriate,

00:54:45.620 --> 00:54:51.660
we simply grab these prefabricated
objects and paste them together.

00:54:52.460 --> 00:54:54.710
to form this

00:54:55.570 --> 00:54:58.120
This command.

00:54:58.230 --> 00:55:02.500
So to summarize,
for complex language models,

00:55:02.500 --> 00:55:06.110
you will want to constrain your
language model to only those commands

00:55:06.250 --> 00:55:09.180
which are plausible in each situation.

00:55:09.190 --> 00:55:14.570
And consequently,
you adapt the language model

00:55:14.570 --> 00:55:14.570
when the situation changes.

00:55:15.150 --> 00:55:18.260
Furthermore, in very complex situations,
you might consider using

00:55:18.410 --> 00:55:24.690
prefabricated language objects to
quickly get your list of commands.

00:55:24.760 --> 00:55:28.490
To build these language models,
we've included a tool

00:55:28.490 --> 00:55:32.730
called SR Language Modeler,
which helps you to quickly experiment

00:55:32.730 --> 00:55:37.060
with different language models,
how well they work for your users.

00:55:38.260 --> 00:55:43.340
SR Language Modeler allows both live
microphone tests for rapid turnaround,

00:55:43.350 --> 00:55:46.810
if you want to try something or
grab somebody into your office

00:55:46.900 --> 00:55:48.840
to have him try something.

00:55:48.840 --> 00:55:53.360
If you want to do systematic
scientific research tests,

00:55:53.480 --> 00:55:57.320
you can record your users
saying these commands,

00:55:57.320 --> 00:56:01.540
record them into AIFF files,
and feed those files into

00:56:01.600 --> 00:56:06.510
SR Language Modeler to get a systematic
evaluation of how well this performs.

00:56:08.600 --> 00:56:14.100
This tool and all of our sample code,
which we shipped with Mac OS X,

00:56:14.140 --> 00:56:19.940
you will find on the developer
CD in the examples/speech folder.

00:56:20.000 --> 00:56:25.520
And we encourage you to start with that
if you want to do anything with speech.

00:56:25.810 --> 00:56:30.940
So let me now turn our session
back over to our fearless leader,

00:56:30.940 --> 00:56:32.090
Kim Silverman.

00:56:36.850 --> 00:56:40.200
For some values of fearless.

00:56:40.290 --> 00:56:42.350
So to summarize,
speech synthesis and speech

00:56:42.430 --> 00:56:43.900
recognition are there.

00:56:43.970 --> 00:56:46.260
We've given you a conceptual
overview of the APIs,

00:56:46.260 --> 00:56:50.000
and I tried to give you some ideas
about why you would want to use them.

00:56:50.030 --> 00:56:56.510
And Matthias and Kevin have followed
up with how to use them well.

00:56:56.710 --> 00:56:59.470
So, I want to encourage you all
to speech enable your apps.

00:56:59.600 --> 00:57:01.930
At this stage,
I'd like to single out just a couple

00:57:01.930 --> 00:57:03.570
of developers who've been doing this.

00:57:03.580 --> 00:57:06.430
You might remember Thinking Home,
which got the

00:57:06.500 --> 00:57:08.360
Apple Design Award last year.

00:57:08.360 --> 00:57:13.430
They've ported their application to OS X,
and they added speech to it,

00:57:13.510 --> 00:57:15.560
and they found that that adds
a lot of value to their users.

00:57:15.560 --> 00:57:17.460
I was talking to one of their
developers on the phone yesterday.

00:57:17.460 --> 00:57:19.310
He said that they're
getting a lot of feedback,

00:57:19.440 --> 00:57:21.820
saying that users just think it's
great when they can walk into

00:57:21.820 --> 00:57:26.660
the room and say things like,
"Dim the lights in the living room," or,

00:57:26.660 --> 00:57:30.000
"Turn the upstairs thermostat to cool."

00:57:30.200 --> 00:57:33.830
The folk who are working on OmniWeb,
you may have seen their

00:57:33.830 --> 00:57:35.380
cool browser on OS X.

00:57:35.380 --> 00:57:39.140
They've been experimenting also with
using speech to integrate speech

00:57:39.140 --> 00:57:43.000
into the browsing experience for
those that don't want to or can't

00:57:43.000 --> 00:57:45.550
deal with the keyboard and the mouse.

00:57:45.550 --> 00:57:47.930
We saw a prototype of that this morning.

00:57:48.040 --> 00:57:49.610
It's looking really good.

00:57:49.610 --> 00:57:52.490
They've got some great
ideas about how to do it.

00:57:52.910 --> 00:57:55.600
So,
I'm going to give you guidelines of good,

00:57:55.600 --> 00:57:58.220
better, and best about how to put
speech into your apps.

00:57:58.500 --> 00:57:59.530
Good is the easy way.

00:57:59.580 --> 00:58:06.900
Use speech recognition to allow people to
speak the visible controls on the screen,

00:58:06.900 --> 00:58:09.590
things that they would normally
manipulate and say them.

00:58:09.680 --> 00:58:13.470
And use speech synthesis to
speak simple alerts and alert

00:58:13.840 --> 00:58:15.530
panels when they come up.

00:58:15.580 --> 00:58:19.460
You can do these, by the way,
with either the speakable items

00:58:19.460 --> 00:58:22.280
framework or by calling the API directly.

00:58:22.800 --> 00:58:26.130
If you want to go better,
then use delegation.

00:58:26.200 --> 00:58:27.400
I've mentioned this a few times.

00:58:27.400 --> 00:58:28.860
You've probably inferred what I mean.

00:58:28.880 --> 00:58:31.180
Normally,
when we interact with a computer,

00:58:31.180 --> 00:58:36.660
we specify explicitly each step we
want the computer to take in order

00:58:36.660 --> 00:58:38.560
to reach a goal that we have in mind.

00:58:38.660 --> 00:58:42.710
With delegation,
we delegate the goal to the computer and

00:58:42.850 --> 00:58:47.750
have it figure out the steps about how to
get there and then execute them for us.

00:58:47.760 --> 00:58:52.760
So, group what would be otherwise
multiple interactive actions

00:58:52.800 --> 00:58:55.100
into one spoken command.

00:58:55.140 --> 00:59:00.590
For speech synthesis,
start to customize your texts using the

00:59:00.590 --> 00:59:02.340
guidelines that Matthias went through.

00:59:03.240 --> 00:59:08.080
If you want any help on those,
read back information to your users.

00:59:08.110 --> 00:59:11.880
And if you want to be best,
then move to interactive

00:59:12.120 --> 00:59:14.800
spoken dialogues,
like you saw Sal demonstrating,

00:59:14.840 --> 00:59:17.360
where you delegate a goal to
the computer or your agent,

00:59:17.370 --> 00:59:20.680
and it then comes back and asks
you questions to refine that goal.

00:59:20.730 --> 00:59:25.320
And think about using
speech for form filling.

00:59:25.420 --> 00:59:26.190
So that's it.

00:59:26.430 --> 00:59:27.170
Thanks a lot for coming.

00:59:27.220 --> 00:59:27.660
I am always--
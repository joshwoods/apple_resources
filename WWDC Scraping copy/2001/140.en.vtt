WEBVTT

00:00:01.310 --> 00:00:06.370
Surprised more people than I thought
would survive till this time on Friday.

00:00:06.370 --> 00:00:09.870
Thanks to the Marquis de Sade,
we're here to talk about the

00:00:09.970 --> 00:00:12.690
kernel at 3:30 on Friday.

00:00:13.040 --> 00:00:14.530
No exciting demos to give.

00:00:14.690 --> 00:00:17.360
It's just me, you,
and hopefully we can cover some topics

00:00:17.430 --> 00:00:19.080
that you guys are really concerned about.

00:00:19.160 --> 00:00:23.660
So, let's get this thing going here.

00:00:25.650 --> 00:00:26.240
Where is it?

00:00:26.260 --> 00:00:27.330
Oh, there it is.

00:00:27.400 --> 00:00:28.440
Okay.

00:00:28.440 --> 00:00:29.480
It's over here.

00:00:29.550 --> 00:00:30.600
So what are you going to learn today?

00:00:30.600 --> 00:00:39.700
Well,
the main thing you're going to learn is

00:00:39.700 --> 00:00:39.930
what the basic kernel services are that
are available to you as programmers.

00:00:40.010 --> 00:00:43.810
You're also going to learn some
of the layering that goes on above

00:00:43.820 --> 00:00:45.660
those services inside of our system.

00:00:45.660 --> 00:00:49.930
One of the things that we've been
able to talk about for the last few

00:00:49.930 --> 00:00:54.450
years here at WWDC is this really
cool kernel technology we have.

00:00:54.520 --> 00:00:58.730
This year part of the message is, yeah,
we have really cool technology.

00:00:58.730 --> 00:00:59.750
Don't use it.

00:00:59.750 --> 00:01:02.810
So how are you going to use it?

00:01:02.860 --> 00:01:04.800
Well, you're going to use the layers
that are built above it.

00:01:05.540 --> 00:01:07.840
You're going to mostly be
writing Carbon applications

00:01:07.840 --> 00:01:08.970
or Cocoa applications.

00:01:08.970 --> 00:01:12.980
Some of you are going to be writing
BSD applications and wrapping them

00:01:12.980 --> 00:01:17.250
as you just saw to give them the user
experience of a higher level application.

00:01:17.260 --> 00:01:22.730
We want to show you how some of those
services are layered above ours.

00:01:24.680 --> 00:01:27.970
What you're going to learn is when
it's safe to directly call some

00:01:28.060 --> 00:01:36.650
of our services and when it's not
safe to call some of our services,

00:01:36.650 --> 00:01:39.630
what those higher level services are
that are available to you through the

00:01:39.630 --> 00:01:39.630
higher frameworks to use those instead.

00:01:39.840 --> 00:01:40.040
right?

00:01:40.040 --> 00:01:44.160
And one of the key things that this
session is going to teach you is,

00:01:44.160 --> 00:01:47.520
although you're not going to be
directly programming to very many

00:01:47.520 --> 00:01:51.320
of our services in the kernel,
when it comes time to do debugging,

00:01:51.320 --> 00:01:55.240
you're going to have to know
what's happening at those

00:01:55.240 --> 00:01:58.660
lower levels of the system,
because the debuggers tend to jump

00:01:58.660 --> 00:02:02.160
you in at some of the lowest levels,
and you have to work your way back up.

00:02:02.160 --> 00:02:07.060
And so if you don't know how
a thread is tied to some of

00:02:07.060 --> 00:02:11.790
the higher level services,
then you're going to be in trouble.

00:02:12.780 --> 00:02:16.700
Again, the same thing when you're
trying to tune your application.

00:02:16.700 --> 00:02:20.800
You have to understand how
everything is put together,

00:02:20.800 --> 00:02:30.490
how the low-level services are used by
the frameworks that you're writing to

00:02:30.490 --> 00:02:30.490
in order to get the correct performance
characteristics that you're looking for.

00:02:31.200 --> 00:02:35.170
What you're not going to learn here,
we're not going to talk about

00:02:35.170 --> 00:02:37.350
how to build file system kecks.

00:02:37.350 --> 00:02:39.770
There was another session,
a lot of people come to

00:02:39.770 --> 00:02:42.520
the kernel session saying,
great, I'm going to learn all about

00:02:42.520 --> 00:02:43.640
how to program in the kernel.

00:02:43.640 --> 00:02:47.210
Well, you're going to learn about
the services we provide,

00:02:47.370 --> 00:02:50.570
and some of those are available
to kecks writers as well,

00:02:50.570 --> 00:02:54.280
but then they're wrapped in a
whole different set of services,

00:02:54.280 --> 00:02:57.700
obscuring some of ours,
promoting some of their own.

00:02:58.210 --> 00:03:01.990
We're not here to specifically talk
about how to write one of those.

00:03:03.300 --> 00:03:10.170
Right, nor are we here to talk about how
to write a network kernel extension.

00:03:10.170 --> 00:03:10.170
The networking sessions
covered most of that.

00:03:10.370 --> 00:03:12.840
And in general,
we're not here to talk about

00:03:12.840 --> 00:03:14.290
how to write in the kernel.

00:03:14.290 --> 00:03:18.520
While a lot of this applies,
the same services are

00:03:18.520 --> 00:03:21.530
available in the kernel,
again, you're going to tend to be in one

00:03:21.530 --> 00:03:25.170
of those specialized environments,
either an IOCit extension or

00:03:25.170 --> 00:03:28.900
a file system extension or
potentially a network text.

00:03:29.360 --> 00:03:31.450
And when you're in each
of those environments,

00:03:31.500 --> 00:03:33.410
the view on these services is different.

00:03:33.410 --> 00:03:36.240
You can do some of these things,
you can't do some of these things

00:03:36.240 --> 00:03:39.830
that we're going to talk about,
and some of the in-kernel programming

00:03:39.830 --> 00:03:43.960
environment access to these services
are spelled a little bit differently

00:03:43.960 --> 00:03:46.200
or take a few different parameters.

00:03:46.200 --> 00:03:48.250
We're not going to get into those.

00:03:48.260 --> 00:03:52.120
All right,
so who would this book be for then,

00:03:52.120 --> 00:03:53.560
this session?

00:03:53.560 --> 00:03:57.240
And it's for all those people who are
out there writing applications today,

00:03:57.240 --> 00:03:59.320
right, that they need to understand.

00:04:00.070 --> 00:04:04.580
And the kernel services that it's
using will tell you how to get the

00:04:04.650 --> 00:04:10.020
best performance and how to understand
all of that is what we're here for.

00:04:10.040 --> 00:04:13.280
Same thing, text developers,
you may learn a little bit,

00:04:13.290 --> 00:04:16.830
but you're not going to learn the
details of how to do your work.

00:04:16.940 --> 00:04:19.380
And power users, I mean,
when you run some of

00:04:19.380 --> 00:04:22.300
the performance tools,
hopefully some of you made it

00:04:22.300 --> 00:04:25.500
to the performance section,
performance tool section,

00:04:25.500 --> 00:04:28.580
you're going to see a lot of
things going on in the system,

00:04:28.580 --> 00:04:29.340
right?

00:04:29.340 --> 00:04:33.600
It helps to understand how they're put
together with the lower level services.

00:04:33.600 --> 00:04:36.800
Where Darwin is the
lowest level of Mac OS X,

00:04:36.800 --> 00:04:42.600
everything that happens in Mac OS X,
to some extent or another, is mitigated,

00:04:42.600 --> 00:04:46.090
managed, controlled by the Darwin layer.

00:04:46.100 --> 00:04:50.560
And in the Darwin layer, right,
the kernel part is the

00:04:50.580 --> 00:04:52.540
most critical part.

00:04:52.560 --> 00:04:57.760
Okay, so some of the general truths about
being in a Mac OS X application.

00:04:57.760 --> 00:04:59.260
Okay, so some of the general truths about
being in a Mac OS X application.

00:04:59.360 --> 00:05:03.480
One of the first things that every
application that's a native application

00:05:03.480 --> 00:05:05.160
in Mac OS X is a BSD process.

00:05:06.510 --> 00:05:08.430
All right,
it's not that some of them are,

00:05:08.490 --> 00:05:09.350
some of them aren't.

00:05:09.400 --> 00:05:16.730
If you can see them,
if they're an application,

00:05:16.730 --> 00:05:16.730
you can see them and manage them
and control them as BSD processes.

00:05:16.950 --> 00:05:20.870
And because of the way we
implemented our kernel,

00:05:21.030 --> 00:05:24.930
all processes are actually
Mach tasks as well.

00:05:24.930 --> 00:05:29.140
So inside of the Darwin Kernel
there's a layering of Mach and BSD.

00:05:29.140 --> 00:05:32.480
And so every process is a Mach task.

00:05:32.510 --> 00:05:35.350
It owns and controls a Mach task.

00:05:36.990 --> 00:05:40.520
One of the things you're also going to
notice and be very tempted by is the fact

00:05:40.640 --> 00:05:45.680
that the APIs for all of these different
layers tend to be available everywhere.

00:05:45.680 --> 00:05:49.460
If you happen to be writing
Carbon's EFM application,

00:05:49.540 --> 00:05:52.180
well, then maybe not everywhere.

00:05:52.180 --> 00:05:55.480
But other than that,
you look at the headers and you

00:05:55.480 --> 00:05:59.810
look at the frameworks and there's
a lot of APIs available to you.

00:05:59.810 --> 00:06:04.690
And one of the things you have to
do is try to stick to the highest

00:06:04.810 --> 00:06:10.050
level service that you can for what
programming environment you're in.

00:06:10.080 --> 00:06:12.170
Use the services available there.

00:06:12.190 --> 00:06:15.080
They tend to map onto
the lower level services.

00:06:15.080 --> 00:06:19.070
And if you stick to those,
you're going to be much better off.

00:06:21.600 --> 00:06:25.290
What you've seen probably a few
times already today is this picture

00:06:25.290 --> 00:06:29.340
of the Darwin Kernel where it talks
about file systems and networking

00:06:29.340 --> 00:06:33.260
and the IOCit drivers that are
available and that you can write.

00:06:33.260 --> 00:06:37.100
We're not really here to talk
about those bubbles that are there.

00:06:37.100 --> 00:06:40.210
We're here to talk about the background.

00:06:40.240 --> 00:06:41.640
Everything else.

00:06:41.750 --> 00:06:45.830
The services that the kernel provides
that lets those things and all the

00:06:45.830 --> 00:06:48.210
applications do what they have to do.

00:06:49.160 --> 00:06:52.460
Again, you've traditionally seen this
division of the Mach kernel

00:06:52.460 --> 00:06:54.340
versus the BSD part of the kernel.

00:06:54.340 --> 00:06:59.190
We tend to think of those as,
while there is a distinction and we

00:06:59.190 --> 00:07:04.440
try to keep the formal layering there,
what we're concerned about is the

00:07:04.440 --> 00:07:08.970
services that the kernel provides
to you as developers and how to make

00:07:09.240 --> 00:07:13.340
those services the best matching
to the semantics of the higher

00:07:13.390 --> 00:07:15.920
level applications that we can.

00:07:15.920 --> 00:07:20.720
We tend to say, "Well,
we don't have these distinctions.

00:07:20.720 --> 00:07:29.110
What we have is one kernel that provides
these services in a layered fashion."

00:07:29.480 --> 00:07:32.420
And the basic services
are process management,

00:07:32.420 --> 00:07:37.620
threading, scheduler, file management,
not necessarily the file systems itself

00:07:37.750 --> 00:07:45.740
but everything that the file systems
use in order to interact with the

00:07:45.770 --> 00:07:48.720
rest of the system in managing files,
virtual memory,

00:07:48.720 --> 00:07:48.720
inter-process communication and security.

00:07:48.800 --> 00:07:51.070
So why don't we start digging
through some of these things.

00:07:51.120 --> 00:07:52.880
Oh, wait, first, that's right, I forgot.

00:07:52.880 --> 00:07:54.680
Where do all these things come from?

00:07:54.680 --> 00:07:55.620
Right.

00:07:55.620 --> 00:08:00.090
Well, the kernel is actually a
collection of technologies from

00:08:00.090 --> 00:08:02.920
essentially three groups of places.

00:08:02.920 --> 00:08:09.130
The Mach 3.0 provides the foundation
for a lot of what goes on in the kernel,

00:08:09.290 --> 00:08:13.320
especially virtual memory, scheduling,
and IPC.

00:08:15.320 --> 00:08:18.490
The BSD portion,
the main BSD portion of our code,

00:08:18.500 --> 00:08:21.560
was picked up from the
4.4 Lights project,

00:08:21.630 --> 00:08:25.400
right, and that gives us a process
model of our scheduling,

00:08:25.420 --> 00:08:28.040
our file access,
and then we picked up most

00:08:28.120 --> 00:08:31.980
of the networking code from
various flavors of free BSD.

00:08:35.430 --> 00:08:40.950
Right, so let's dig in and start talking
about process management in Darwin.

00:08:41.280 --> 00:08:45.960
At the very fundamental level,
every process is a Mach task and

00:08:45.960 --> 00:08:49.270
every application is a process.

00:08:49.270 --> 00:08:51.290
At the very lowest level
you have a Mach task.

00:08:51.370 --> 00:08:57.490
A Mach task is the unit of resource
ownership as far as Mach is concerned.

00:08:58.460 --> 00:09:02.350
Every task owns threads,
it controls them,

00:09:02.410 --> 00:09:06.460
it has virtual memory space and
is managed through that Mach task,

00:09:06.540 --> 00:09:10.700
and it has a port name space
to collect all the IPC rights

00:09:11.060 --> 00:09:13.580
that are usable by that task.

00:09:13.760 --> 00:09:16.660
All right, and so traditionally
you can create tasks,

00:09:16.820 --> 00:09:19.670
you can spend them, resume them,
and create new threads in them and get

00:09:19.670 --> 00:09:21.320
all kinds of information about them.

00:09:21.320 --> 00:09:23.940
You can also,
one of the things people tend to do

00:09:23.960 --> 00:09:26.860
is create exception handlers for them,
all right,

00:09:26.860 --> 00:09:31.090
so that you can catch exceptions that
happen in a task and process those.

00:09:31.090 --> 00:09:34.870
And you can also get death notification
and be told when certain tasks

00:09:34.870 --> 00:09:36.870
that you have to handle to go away.

00:09:37.840 --> 00:09:41.910
Well, that's a nice set of services,
right, but typically you won't be

00:09:42.070 --> 00:09:43.400
able to use those directly.

00:09:43.400 --> 00:09:46.180
I mean,
you actually can create a Mach task

00:09:46.180 --> 00:09:50.420
all by itself in the system,
but you can't manage it, right.

00:09:50.420 --> 00:09:54.420
It's just this free-floating
entity that no one else can see,

00:09:54.420 --> 00:09:57.990
use, manipulate,
so it's highly discouraged to ever

00:09:57.990 --> 00:10:01.040
create a Mach task all by itself,
right.

00:10:01.050 --> 00:10:03.850
Instead,
you would tend to create a BSD process,

00:10:03.860 --> 00:10:06.680
right,
and you do that through the standard.

00:10:08.060 --> 00:10:12.670
BSD APIs, you know, VFork, Exec, right,
create them and destroy them,

00:10:12.670 --> 00:10:14.490
and you go ahead and exit.

00:10:14.500 --> 00:10:19.630
But the BSD process gives you these
additional resources to go along

00:10:19.630 --> 00:10:25.300
with your task besides giving you the
ability to manage them and name them,

00:10:25.300 --> 00:10:26.140
right.

00:10:26.140 --> 00:10:28.270
They give you the signal handlers,
they give you file descriptors,

00:10:28.340 --> 00:10:29.970
they give you a whole
collection of resources.

00:10:29.980 --> 00:10:35.670
And what happens is when
you have a BSD process,

00:10:35.670 --> 00:10:37.460
right,
and you go look at the BSD process,

00:10:37.460 --> 00:10:37.460
you can see that there's a
lot of resources that you

00:10:37.460 --> 00:10:37.460
can use to manage them.

00:10:37.460 --> 00:10:40.140
So you can look at the Mach task
APIs that are available,

00:10:40.140 --> 00:10:40.670
right.

00:10:40.730 --> 00:10:42.010
A whole bunch of them go away.

00:10:42.060 --> 00:10:46.660
If you try to terminate a Mach task
that actually is part of a BSD process,

00:10:46.740 --> 00:10:50.800
that'll just return you an error
because the BSD part of the system

00:10:50.800 --> 00:10:54.740
doesn't have a chance to clean up and
do the management that it would do,

00:10:54.740 --> 00:10:55.400
right.

00:10:55.400 --> 00:10:57.090
And so we don't allow that to happen.

00:10:58.710 --> 00:11:03.140
of similarly creating new ones.

00:11:03.140 --> 00:11:05.700
We don't allow you to do that
or we prefer you not do that.

00:11:05.700 --> 00:11:07.440
Everything else is risky.

00:11:07.440 --> 00:11:09.500
You can go ahead and
create exception handlers.

00:11:09.500 --> 00:11:16.600
You can go ahead and get info on the
process itself or the task itself or get

00:11:16.600 --> 00:11:22.890
a list of threads or control threads,
create threads, but you shouldn't do

00:11:22.890 --> 00:11:22.890
anything else with the task.

00:11:23.200 --> 00:11:27.100
But again, a lot of you will not be
programming BSD processes.

00:11:27.100 --> 00:11:30.900
You're actually going to be programming
applications out at the higher level.

00:11:30.930 --> 00:11:34.220
Either Carbon, Cocoa, Java, whatever.

00:11:34.220 --> 00:11:37.540
And they add additional set
of resources and additional

00:11:37.540 --> 00:11:39.490
set of APIs for managing them.

00:11:39.500 --> 00:11:42.110
Actually many sets of
APIs for managing them.

00:11:42.870 --> 00:11:46.520
One of the things that happens
when you create those higher level

00:11:46.520 --> 00:11:50.550
applications is they all talk to a
common process management service

00:11:50.550 --> 00:11:52.670
that's a part of the core service.

00:11:52.670 --> 00:11:54.480
Core services in the system.

00:11:54.480 --> 00:11:57.020
And it does all of the
management for you.

00:11:57.050 --> 00:12:01.760
And so you tend,
that's how you get things that pop up in,

00:12:01.860 --> 00:12:03.620
actually.

00:12:05.500 --> 00:12:08.330
When you're looking at the tools
that are available at that level,

00:12:08.330 --> 00:12:11.400
you have the dock and you have
force quit and all those things.

00:12:11.400 --> 00:12:15.620
CPS, the core process service,
is the thing that lets you

00:12:15.620 --> 00:12:20.610
manage processes and the larger
applications all register with that.

00:12:20.620 --> 00:12:24.770
Process viewer will actually
let you view and introspect just

00:12:24.870 --> 00:12:27.820
any BSD process in the system.

00:12:27.820 --> 00:12:29.320
The same with top and PS.

00:12:30.260 --> 00:12:34.130
And if you really want to see what's
going on down at the lower levels,

00:12:34.130 --> 00:12:37.880
you can use Zprint,
which is a tool that talks to the

00:12:37.880 --> 00:12:39.900
kernel's zone management system.

00:12:39.920 --> 00:12:44.230
And will basically print out
statistics on how many of every kind

00:12:44.230 --> 00:12:46.620
of resource that the kernel has.

00:12:46.620 --> 00:12:49.630
And in those lists is all
of the Mach services and the

00:12:49.630 --> 00:12:51.920
Mach resources that are available.

00:12:51.920 --> 00:12:55.420
So you'll see how many Mach tasks,
how many Mach threads are

00:12:55.690 --> 00:12:56.930
being managed as well.

00:12:56.940 --> 00:12:59.920
And so you can actually see and inspect
some of the Mach level resources.

00:13:00.260 --> 00:13:01.240
With that tool.

00:13:01.240 --> 00:13:06.680
So this is how you manage processes
and handle exceptions and all

00:13:06.680 --> 00:13:09.280
of that is all at this level.

00:13:09.280 --> 00:13:13.860
One of the things you have to be
very careful about is although

00:13:13.860 --> 00:13:19.370
BSD processes have limits on the number
of open files and a lot of the other

00:13:19.370 --> 00:13:21.060
resources that are available to you.

00:13:21.080 --> 00:13:26.000
One of the things that's not implemented
in the kernel that shipped was 10.0.

00:13:26.000 --> 00:13:30.240
Is any ability to limit the
resource allocations at the bottom.

00:13:30.260 --> 00:13:30.800
And that's what we're going to
be looking at in the Mach level.

00:13:30.840 --> 00:13:34.240
So any thread can go ahead
and allocate these resources.

00:13:34.240 --> 00:13:35.680
Right.

00:13:35.680 --> 00:13:38.410
And we don't have any limits on
the amount of those resources

00:13:38.420 --> 00:13:40.020
you can go ahead and allocate.

00:13:40.020 --> 00:13:43.330
And so if you have a runaway process.

00:13:43.340 --> 00:13:44.280
Right.

00:13:44.340 --> 00:13:47.990
That's just leaking a port or
leaking some kernel resource over

00:13:47.990 --> 00:13:50.060
and over and over and over again.

00:13:50.080 --> 00:13:51.150
Right.

00:13:51.160 --> 00:13:53.520
Over time, the application may die.

00:13:53.520 --> 00:13:56.430
That's certainly one outcome
that might come from this.

00:13:56.440 --> 00:13:59.440
But another outcome from
that particular problem.

00:13:59.440 --> 00:14:00.070
Is that.

00:14:00.260 --> 00:14:03.890
It may actually just lock up the system
and eventually panic the system because

00:14:03.890 --> 00:14:05.760
you've ran out of kernel resources.

00:14:05.760 --> 00:14:07.530
In order to provide that.

00:14:07.580 --> 00:14:12.240
So what you have to do is even though
you are writing a Carbon application

00:14:12.710 --> 00:14:14.660
or a Cocoa application.

00:14:14.660 --> 00:14:16.830
You need to take some of these tools.

00:14:17.170 --> 00:14:18.050
Top and PS.

00:14:18.080 --> 00:14:19.600
In this case, top.

00:14:19.680 --> 00:14:20.690
If you were looking for leaks.

00:14:20.800 --> 00:14:21.730
Right.

00:14:21.850 --> 00:14:23.720
And just watch your application running.

00:14:23.720 --> 00:14:26.790
And if you happen to see
something leaking away.

00:14:26.800 --> 00:14:28.540
You need to address that.

00:14:33.100 --> 00:14:37.180
Within a process,
you obviously have threads.

00:14:37.180 --> 00:14:40.340
At the lowest level,
you have a Mach thread.

00:14:40.360 --> 00:14:42.530
Mach does all the
scheduling in the system.

00:14:42.540 --> 00:14:46.520
Mach threads are the primary
threading resource in the system.

00:14:46.540 --> 00:14:50.220
One really interesting thing about
Mach threads that confuses a lot of

00:14:50.320 --> 00:14:55.400
people is that they actually have
no resources other than scheduling

00:14:55.460 --> 00:14:57.620
attributes and a register state.

00:14:57.640 --> 00:14:59.090
That's it.

00:14:59.240 --> 00:15:00.570
That is what a Mach thread is.

00:15:01.690 --> 00:15:06.390
Everything else you think about a thread,
stacks and per-thread

00:15:06.390 --> 00:15:10.570
data and things like that,
Mach doesn't know anything about those.

00:15:10.600 --> 00:15:15.060
It's all expected to be wrapped
by some higher level service.

00:15:17.450 --> 00:15:20.380
And again, at the Mach level,
and an interesting thing is

00:15:20.380 --> 00:15:23.450
you can actually register for
exception handling and death

00:15:23.450 --> 00:15:25.500
notification at the thread level.

00:15:25.500 --> 00:15:31.700
And those kind of APIs still are
usable even when you look at it in the

00:15:31.790 --> 00:15:35.510
context of a BSD thread or a P thread.

00:15:36.380 --> 00:15:40.320
BOSX threads are the thing
that provides the resources at

00:15:40.320 --> 00:15:42.420
the user level for a thread.

00:15:42.440 --> 00:15:45.230
They provide the stack for a thread.

00:15:45.260 --> 00:15:51.910
They provide the thread-specific
data implementation.

00:15:53.100 --> 00:15:57.050
Those are the APIs you can use
to create them and manage them.

00:15:57.050 --> 00:16:01.130
But again, you may or may not just be
stopping at a BSD process.

00:16:01.130 --> 00:16:04.440
You may be writing a
Carbon or a Cocoa application.

00:16:04.440 --> 00:16:07.930
And in those cases,
you tend to not write to Pthreads.

00:16:07.990 --> 00:16:11.850
You're going to write to create
an NS thread inside of Cocoa or

00:16:11.850 --> 00:16:15.630
you're going to create an
NP task in a Carbon application.

00:16:15.630 --> 00:16:17.120
Well, those are BSD.

00:16:17.130 --> 00:16:18.470
They are Pthreads.

00:16:18.470 --> 00:16:21.590
Each and every one of those is a Pthread.

00:16:23.100 --> 00:16:29.180
And so you can have the breadth
of services available to you

00:16:29.190 --> 00:16:32.250
from each of those layers.

00:16:32.260 --> 00:16:36.820
Again, at the thread level,
if you tried to destroy a Mach thread

00:16:36.820 --> 00:16:41.120
right out from underneath of a Pthread,
you can do it.

00:16:41.270 --> 00:16:42.600
Your application is free to do that.

00:16:42.600 --> 00:16:43.990
It can do that to its own threads.

00:16:44.000 --> 00:16:47.770
You're going to leave the Pthread
code implementation in a lurch.

00:16:47.770 --> 00:16:49.930
So you better not do that.

00:16:49.940 --> 00:16:50.930
But you could.

00:16:52.340 --> 00:16:55.680
One nice thing about Pthreads,
the way the higher level

00:16:55.680 --> 00:16:58.210
application services,
threading services,

00:16:58.210 --> 00:17:01.900
wrap around the Pthread level,
is that almost everything you can

00:17:01.900 --> 00:17:05.330
do to a Pthread you can do on those
higher level services and they

00:17:05.330 --> 00:17:07.410
tend to work well with each other.

00:17:09.910 --> 00:17:12.560
Right, and so, well,
how do I view threads in my system?

00:17:12.560 --> 00:17:13.720
How do I tune for it?

00:17:13.840 --> 00:17:15.960
How do I take care of the
threading in my system?

00:17:15.960 --> 00:17:17.390
And here's some tools you can do it.

00:17:17.520 --> 00:17:20.140
ThreadViewer, if anyone was at the
performance tools meeting,

00:17:20.140 --> 00:17:24.260
session yesterday,
you saw them going and actually showing

00:17:24.260 --> 00:17:27.950
ThreadViewer as an application that
they were debugging during that process.

00:17:28.000 --> 00:17:31.380
Well, at the end of that meeting,
the end of that session,

00:17:31.380 --> 00:17:33.870
they decided that they were going
to release that ThreadViewer

00:17:33.910 --> 00:17:35.340
to people as soon as possible.

00:17:35.400 --> 00:17:38.530
So that's going to be a really
nice application for viewing

00:17:38.530 --> 00:17:43.840
threads in the system in a
graphical way at a higher level.

00:17:43.840 --> 00:17:46.790
Because up until that point, well,
you could sample threads

00:17:46.790 --> 00:17:49.610
with the sample app,
but that's kind of not something

00:17:49.660 --> 00:17:53.100
you would do ongoing and just
watch your application go.

00:17:53.100 --> 00:17:57.510
It's typically you've noticed a problem,
right, and you would fire up Sampler and

00:17:57.510 --> 00:18:00.520
go off and do what you needed to do,
right?

00:18:00.520 --> 00:18:03.600
And TopMPS,
I know I've had Top running on

00:18:03.620 --> 00:18:06.680
the side of my system forever,
right?

00:18:06.780 --> 00:18:08.190
But it's a lot.

00:18:08.200 --> 00:18:09.500
It's like drinking from a fire hose.

00:18:09.500 --> 00:18:10.520
That's a lot of information.

00:18:10.520 --> 00:18:12.740
It doesn't give you a graphical bang.

00:18:12.740 --> 00:18:15.140
There's something going on there
that I really need to worry about.

00:18:16.650 --> 00:18:18.240
some of the tips.

00:18:18.360 --> 00:18:25.330
Well, in Mac OS X,
we promote people to lazy init as

00:18:25.330 --> 00:18:28.240
much as possible in their system,
right?

00:18:28.240 --> 00:18:31.720
If you have a framework or
anything else in your system,

00:18:31.720 --> 00:18:33.810
you really want to delay initializing it.

00:18:33.880 --> 00:18:37.590
One of the problems with the big bounces,
the bounce marks when you're

00:18:37.700 --> 00:18:41.510
launching an application in X,
is that a lot of the code brought

00:18:41.510 --> 00:18:46.270
over from IX basically had this model,
initialize everything once up front,

00:18:46.280 --> 00:18:50.500
right, as much as you can,
and then we'll use it later, right,

00:18:50.670 --> 00:18:51.450
almost for free.

00:18:51.460 --> 00:18:55.030
Well, in X,
what you're doing is initializing

00:18:55.030 --> 00:19:00.100
it all up front once each time
each application launches,

00:19:00.100 --> 00:19:00.990
right?

00:19:01.000 --> 00:19:04.110
And so one of the services you
can use to get around that problem

00:19:04.120 --> 00:19:07.320
is this pthreadonce facility,
which basically,

00:19:07.320 --> 00:19:12.160
at the front of each major
access point into your service,

00:19:12.160 --> 00:19:15.500
right, you can put a pthreadonce,
call the initialization

00:19:15.500 --> 00:19:17.670
routine at the front of that,
right?

00:19:17.680 --> 00:19:20.910
And the pthreads code will guarantee
that the very first time you call one

00:19:20.910 --> 00:19:25.020
of your functions that has this in it,
it'll go call the initialization routine,

00:19:25.020 --> 00:19:29.310
but it won't ever allow it to
be called again from that code.

00:19:29.340 --> 00:19:32.360
So that way you can delay
your initialization until the

00:19:32.380 --> 00:19:33.970
very first time you're called.

00:19:35.540 --> 00:19:41.460
Also, a lot of people like to create
their own debuggers or their

00:19:41.460 --> 00:19:42.740
own debugging environment.

00:19:42.740 --> 00:19:50.560
They tend to want to get the exceptions
from an application as it's running,

00:19:50.560 --> 00:19:54.040
filter them through their
own set of interfaces,

00:19:54.040 --> 00:19:58.820
and decide whether or not to let the
system see the rest of them later.

00:19:59.840 --> 00:20:04.860
You can catch exceptions at
any one of three places in Mac.

00:20:04.880 --> 00:20:08.080
You can catch exceptions
at the thread level,

00:20:08.080 --> 00:20:10.930
at the task level,
and you can actually catch

00:20:10.930 --> 00:20:13.450
them at the widest level,
the host level.

00:20:13.460 --> 00:20:17.090
BSD tends to hook itself
at the host level.

00:20:17.120 --> 00:20:23.690
When a process or a thread runs along
and executes an invalid instruction,

00:20:23.690 --> 00:20:26.810
it's going to send an
exception down this chain.

00:20:26.820 --> 00:20:28.700
It's going to first send
the exception message.

00:20:28.840 --> 00:20:30.720
It's going to send it out
to the thread level handler.

00:20:30.720 --> 00:20:34.790
If the thread level
handler says he handled it,

00:20:34.790 --> 00:20:36.190
then fine.

00:20:36.210 --> 00:20:38.980
We'll just let the thread continue
and we'll go on from there.

00:20:38.980 --> 00:20:42.640
If he didn't, then we're going to send
it on to the next level,

00:20:42.640 --> 00:20:45.180
to the process level, the task level.

00:20:45.180 --> 00:20:47.320
There's another handler sitting there.

00:20:47.320 --> 00:20:49.060
If there is one,
then we'll send it to him.

00:20:49.060 --> 00:20:51.060
Then same thing down below.

00:20:51.060 --> 00:20:53.760
Well, BSD tends to be at the task level.

00:20:53.760 --> 00:20:57.000
You're going to see debuggers like
GDB and things like that are going

00:20:57.000 --> 00:20:58.700
to be sitting at the task level.

00:20:58.840 --> 00:21:00.690
BSD is at the host.

00:21:00.700 --> 00:21:02.200
GDB is at the task.

00:21:02.230 --> 00:21:04.710
If you want to be able to
intercept and get in there

00:21:04.710 --> 00:21:07.120
and do something on your own,
then you would tend to do

00:21:07.150 --> 00:21:08.010
it at the thread level.

00:21:12.470 --> 00:21:15.620
So now that we have threads,
we obviously have to schedule them.

00:21:15.640 --> 00:21:18.640
And how do we schedule them?

00:21:18.640 --> 00:21:23.740
Well, this has been somewhat of a
mystery inside of Mac OS X.

00:21:23.740 --> 00:21:27.240
There's obviously something
going on with this banding.

00:21:27.240 --> 00:21:30.000
You can see different threads being
assigned different priorities,

00:21:30.000 --> 00:21:34.750
but we've been messing with this,
tuning it,

00:21:34.820 --> 00:21:39.620
and so we've been kind of adverse to
putting out exactly what the banding

00:21:39.620 --> 00:21:40.840
is that we have in the system.

00:21:41.380 --> 00:21:43.520
But now that you're trying
to write real applications,

00:21:43.520 --> 00:21:46.760
you're going to need to know.

00:21:47.040 --> 00:21:49.120
Some of you are writing
multimedia applications,

00:21:49.120 --> 00:21:52.660
and you really need to know how to
get to be a fixed priority process,

00:21:52.660 --> 00:21:54.440
how to set your priority.

00:21:54.460 --> 00:21:57.730
Well, these are actually the
bands that we have.

00:21:57.800 --> 00:22:00.570
At the very highest,
so we have a range from 0 to 127.

00:22:00.600 --> 00:22:04.430
The very highest level are what
we call time-constrained threads.

00:22:04.440 --> 00:22:08.640
And so any thread that's registered
as a time-constrained thread,

00:22:08.640 --> 00:22:10.080
and you don't have to be privileged.

00:22:10.080 --> 00:22:13.000
You don't have to be privileged to say
you want a time-constrained thread.

00:22:13.020 --> 00:22:16.840
They will run up in that
highest band somewhere,

00:22:16.840 --> 00:22:19.010
and that we won't tell you.

00:22:19.060 --> 00:22:22.220
But it's based on the time
constraints that you provide,

00:22:22.220 --> 00:22:25.120
and then we marry that with
a bunch of other information

00:22:25.140 --> 00:22:28.830
and decide what priority you
actually get within that band.

00:22:28.840 --> 00:22:31.760
But they tend to run at a
fixed priority in that band.

00:22:31.780 --> 00:22:36.280
So they'll just run, run, run, run, run,
run, run if they have things to do.

00:22:36.300 --> 00:22:39.660
And since they're a much higher
band than most other applications,

00:22:40.080 --> 00:22:41.500
obviously we're going
to schedule those first.

00:22:41.520 --> 00:22:44.720
We're also going to
preemptively schedule those.

00:22:44.720 --> 00:22:49.400
And so even if something else lowers,
running along in the kernel,

00:22:49.400 --> 00:22:52.260
doing a kernel service,
if one of these comes along,

00:22:52.260 --> 00:22:53.190
we're going to schedule it.

00:22:53.200 --> 00:22:57.670
Well, that leads into a concern,
obviously,

00:22:57.800 --> 00:23:01.270
is that if any application can do this,
and can set one of these

00:23:01.270 --> 00:23:04.960
threads up really high,
then obviously any application

00:23:04.960 --> 00:23:07.910
can kill the system,
and there's no way you'd get it back if

00:23:07.910 --> 00:23:09.870
it just runs up there forever and ever.

00:23:10.080 --> 00:23:14.420
Well, we actually have limits to what can
happen in a time-constrained thread.

00:23:14.420 --> 00:23:17.690
And so if you're running for too
long in a time-constrained thread,

00:23:17.700 --> 00:23:24.460
then you get bumped back into the
normal application band for a while,

00:23:24.460 --> 00:23:28.080
and then if you settle down,
then we'll put you back into

00:23:28.090 --> 00:23:29.880
the time-constrained band.

00:23:29.880 --> 00:23:33.520
If you don't ever settle down,
then you just stay down there

00:23:33.520 --> 00:23:35.570
in the normal application band.

00:23:37.030 --> 00:23:39.630
And actually when you're in
the application in the time

00:23:39.630 --> 00:23:43.230
constraint band you're actually
scheduled above the kernel threads.

00:23:43.230 --> 00:23:44.190
Above I.O.

00:23:44.190 --> 00:23:44.910
threads.

00:23:44.990 --> 00:23:48.830
So your stuff will happen before
we'll handle disk activity.

00:23:48.830 --> 00:23:53.890
It will be the first thing
the kernel will go and run.

00:23:55.070 --> 00:23:58.690
And then below the kernel and
I/O is the core services threads,

00:23:58.810 --> 00:24:01.840
things like the GUI managers.

00:24:01.860 --> 00:24:06.480
So if you're running a time-constrained
thread and it's just chewing away,

00:24:06.690 --> 00:24:07.110
guess what?

00:24:07.230 --> 00:24:10.000
You might even have trouble
moving that mouse around.

00:24:10.000 --> 00:24:15.640
You might have trouble selecting that
application to kill it if it runs away.

00:24:15.700 --> 00:24:20.060
That's why if it's run away,
it will get bumped down so that the

00:24:20.060 --> 00:24:23.600
core service threads have a chance
to run and go ahead and get you.

00:24:24.170 --> 00:24:26.370
For the rest of the threads,
they tend to be grouped

00:24:26.370 --> 00:24:27.520
into two categories.

00:24:27.530 --> 00:24:32.270
It's GUI-based threads and regular
kind of background activity,

00:24:32.270 --> 00:24:35.160
regular BSD process kind of threads.

00:24:35.160 --> 00:24:39.960
And the GUI ones tend to be
a little bit higher in the

00:24:39.960 --> 00:24:42.960
bands than the default ones.

00:24:42.960 --> 00:24:47.860
But all of these threads
are priority adjusted.

00:24:47.860 --> 00:24:51.630
So as they run and take time,
they tend to start at their base

00:24:51.720 --> 00:24:54.080
and work their way down as they go.

00:24:54.100 --> 00:24:55.930
They consume CPU under contention.

00:24:55.930 --> 00:24:59.260
So if they're consuming CPU and
nobody else is contending for the CPU,

00:24:59.340 --> 00:25:00.020
they're fine.

00:25:00.080 --> 00:25:02.680
They'll just stay, stay, stay, stay,
stay.

00:25:02.680 --> 00:25:05.520
As soon as they start contending
for the CPU with other threads

00:25:05.620 --> 00:25:08.600
and other things want to run,
they get nicked a little bit each

00:25:08.600 --> 00:25:11.960
time this happens until those
other threads get a chance to run.

00:25:11.960 --> 00:25:15.730
And then as a few quantums
expire and they've been nicked,

00:25:15.730 --> 00:25:18.300
then they drift back up and drift down.

00:25:18.420 --> 00:25:22.200
So every thread tends to
balance itself in this group.

00:25:22.240 --> 00:25:24.080
And that's the standard.

00:25:24.100 --> 00:25:28.800
policy in the system is
to timeshare and adjust.

00:25:29.500 --> 00:25:33.410
One of the things you can
do in that category is

00:25:35.100 --> 00:25:37.160
assign precedence to your threads.

00:25:37.230 --> 00:25:40.280
So if I have two priority,
two normal application threads,

00:25:40.360 --> 00:25:43.030
but I always want this one
to have precedence over this

00:25:43.030 --> 00:25:51.060
one within my application,
then you can use the precedence policy

00:25:51.060 --> 00:25:51.060
setting to give an ordering to those.

00:25:51.990 --> 00:25:55.680
And like I said, we have,
we can take those threads and

00:25:55.680 --> 00:25:59.980
schedule them fully preemptively,
both kernel and user.

00:25:59.980 --> 00:26:01.840
So we have a fully preemptive kernel.

00:26:01.840 --> 00:26:04.670
If you're a time-constrained thread,
you will interrupt things right

00:26:04.670 --> 00:26:07.060
out of the kernel and we'll
switch to you immediately.

00:26:07.060 --> 00:26:12.180
And we can obviously balance
those across multiple CPUs.

00:26:12.730 --> 00:26:15.600
When you're at the BSD process level,
well, you have a few more things

00:26:15.670 --> 00:26:17.100
that come out for you.

00:26:17.190 --> 00:26:21.840
You have the ability to set nice
and if you've noticed in Mac OS X,

00:26:21.880 --> 00:26:23.600
that actually doesn't do anything.

00:26:23.620 --> 00:26:27.720
But the later versions,
soon you will see a version

00:26:27.720 --> 00:26:29.600
that has that fixed.

00:26:29.600 --> 00:26:31.930
At the Pthread level,
you can set your own

00:26:31.930 --> 00:26:33.600
scheduling attributes.

00:26:33.660 --> 00:26:38.350
Those will feed into the
precedence and into the timeshare

00:26:38.370 --> 00:26:41.520
and standard policy constraints.

00:26:43.400 --> 00:26:47.240
and Alan at the higher level, right,
you have management going on even

00:26:47.240 --> 00:26:49.630
beyond what the Mach level manages.

00:26:49.680 --> 00:26:53.000
So if you're writing cooperative
threads or you have deferred threads

00:26:53.500 --> 00:26:58.090
inside of your Carbon application,
Carbon is actually getting

00:26:58.090 --> 00:27:04.400
involved there and trying to make
sure that those things run even

00:27:04.400 --> 00:27:04.900
though they're each a Mach thread.

00:27:04.900 --> 00:27:04.900
He's trying to make sure
they run in the right order.

00:27:07.100 --> 00:27:10.320
Again, some of the standard
tools to look at things.

00:27:10.320 --> 00:27:14.590
But the big tip here is don't use the
old APIs for setting things as round

00:27:14.590 --> 00:27:19.220
robin or timeshare that are still
available in the Mach kernel you have.

00:27:19.360 --> 00:27:27.790
Use the new get policy,
set policy APIs that take the

00:27:27.790 --> 00:27:27.790
precedence and the time constraint.

00:27:29.810 --> 00:27:31.950
So now that we've got
scheduling enabled to run,

00:27:31.950 --> 00:27:34.580
let's see what we can do with
anything outside of ourselves.

00:27:34.590 --> 00:27:37.100
And for that we need to
access files typically.

00:27:37.100 --> 00:27:40.990
Inside of the file management
system of the whole kernel,

00:27:40.990 --> 00:27:43.860
Mach task actually has
no concept of file.

00:27:43.880 --> 00:27:48.140
So you would think that Mach is really
not involved in this discussion,

00:27:48.140 --> 00:27:49.580
but that's not true.

00:27:49.580 --> 00:27:55.420
Every file in the system really
is managed and controlled.

00:27:55.420 --> 00:27:59.300
The cache for the data of that
application is managed and controlled.

00:27:59.840 --> 00:28:02.450
By Mach through what's called VM objects.

00:28:02.460 --> 00:28:08.300
So Mach manages the cache in the system,
the VM page cache,

00:28:08.300 --> 00:28:11.870
and all of our file system activity.

00:28:13.000 --> 00:28:17.390
goes through the VM page cache
to do what it needs to do.

00:28:17.480 --> 00:28:20.470
So as you're reading from files,
reading files off a desk,

00:28:20.520 --> 00:28:24.520
those files are stored
in the regular VM cache.

00:28:24.520 --> 00:28:28.500
We don't have a file system cache
and a VM cache for things that are,

00:28:28.600 --> 00:28:32.260
you know, applications that are
mapped into your program.

00:28:32.330 --> 00:28:34.060
We have one cache.

00:28:34.360 --> 00:28:37.160
Read, read, read, read, read.

00:28:37.160 --> 00:28:41.350
It all goes into one pile and it
pushes things off the end of the pile.

00:28:44.100 --> 00:29:38.800
[Transcript missing]

00:29:38.800 --> 00:29:44.800
Some really good tools to tune
your use of files is FS Usage.

00:29:44.800 --> 00:29:48.430
It's a tool that will basically,
as you're accessing a file,

00:29:48.440 --> 00:29:52.990
it will spew out what's going on,
every access, every read, write, open,

00:29:52.990 --> 00:29:57.490
close, either by a particular application
or by any application overall.

00:29:57.500 --> 00:30:00.650
And so you can get basically
a real-time view of everything

00:30:00.650 --> 00:30:02.870
that's going on file activity-wise.

00:30:02.880 --> 00:30:05.920
Also, there's another tool, LSOF.

00:30:06.030 --> 00:30:07.280
It's another command line tool.

00:30:07.280 --> 00:30:08.420
Both of these are command line.

00:30:08.800 --> 00:30:11.800
And it will basically list
every open file in the system.

00:30:11.800 --> 00:30:15.860
And who has it open,
what file descriptor number

00:30:15.860 --> 00:30:17.570
it is within that process.

00:30:17.620 --> 00:30:19.220
It's a very useful tool.

00:30:20.600 --> 00:30:26.780
Big tip, because we have this one cache
that handles all mapped files,

00:30:26.900 --> 00:30:30.420
all your libraries, all your frameworks,
all your executables,

00:30:30.420 --> 00:30:34.720
it's also the cache where you
handle all the reading of files,

00:30:34.730 --> 00:30:37.050
reading and writing of files.

00:30:37.060 --> 00:30:41.010
If you happen to be reading
something once and only once,

00:30:41.020 --> 00:30:44.740
spewing in a big image file
or something like that that

00:30:44.740 --> 00:30:48.550
you're going to process once,
you don't need that file

00:30:48.550 --> 00:30:50.070
in the cache anymore.

00:30:50.200 --> 00:30:51.440
You've got it in your application.

00:30:51.460 --> 00:30:55.510
Having a copy of it in your
application and having the original

00:30:55.510 --> 00:30:59.410
one in the cache just means we are
taking up double the space in VM,

00:30:59.410 --> 00:31:02.010
at least temporarily, for that data.

00:31:02.040 --> 00:31:05.500
Whenever you can,
use the no cache options.

00:31:05.500 --> 00:31:08.820
At the Carbon level,
you have no cache reads and writes.

00:31:08.880 --> 00:31:11.670
At the BSD level,
we actually have an F control

00:31:11.670 --> 00:31:15.400
that you can specify to say
these are no cache operations.

00:31:15.400 --> 00:31:18.380
You really need to use
the no cache operations.

00:31:19.800 --> 00:31:23.380
Otherwise,
as you run through memory with big files,

00:31:23.380 --> 00:31:26.970
you can push really important
pieces of the system,

00:31:26.970 --> 00:31:29.350
like the system framework
and everything that you use,

00:31:29.350 --> 00:31:31.320
and your own code, right out of memory.

00:31:31.340 --> 00:31:31.420
Thank you.

00:31:33.010 --> 00:31:36.330
One thing that also gets people
every once in a while is that while

00:31:36.460 --> 00:31:40.320
you typically were able to open in a
Carbon application as many files as you

00:31:40.320 --> 00:31:44.490
wanted until you hit the system limit,
in BSD there's a soft limit

00:31:44.490 --> 00:31:48.280
for the number of open per
process and that's 256.

00:31:49.100 --> 00:31:54.310
And so as you open FSRefs
inside of Carbon applications,

00:31:54.310 --> 00:31:57.150
you may end up running into this limit.

00:31:57.160 --> 00:31:58.300
Typically it's a bug.

00:31:58.300 --> 00:32:03.150
Typically it's because you're forgetting
to close them and you just open,

00:32:03.150 --> 00:32:08.310
open, open, open, open,
and eventually you'll hit the 256 limit.

00:32:08.320 --> 00:32:11.740
We basically, you have that limit now.

00:32:11.740 --> 00:32:17.300
You can change it with an assist control,
or sorry, a

00:32:18.490 --> 00:32:23.030
Yeah, there's an API at the BSD level
to basically up the limit for you,

00:32:23.100 --> 00:32:23.840
right?

00:32:23.840 --> 00:32:26.100
The same thing can happen
at a system-wide level.

00:32:26.100 --> 00:32:29.810
We have a system-wide level of
number of V nodes which are the

00:32:29.810 --> 00:32:34.110
open file descriptors up there,
the open file handles, right?

00:32:34.130 --> 00:32:37.940
And those are, you know,
there's a system-wide limit determined

00:32:37.940 --> 00:32:42.080
at boot time based on the amount of
memory in the system and essentially,

00:32:42.140 --> 00:32:44.760
you know, some other tunable parameters.

00:32:44.760 --> 00:32:47.770
Well, you can tune those up as
well with assist control.

00:32:50.260 --> 00:32:52.840
Now we have files and we
talked a little bit about VM.

00:32:52.840 --> 00:32:57.710
But we need to talk about the
rest of what happens with VM.

00:32:57.710 --> 00:33:03.560
The Mach VM pretty much controls the
virtual memory in all of Mac OS X.

00:33:03.560 --> 00:33:08.280
BSD provides some wrapper services to
that but it's mostly managed by Mach.

00:33:09.440 --> 00:33:09.920
Right.

00:33:09.970 --> 00:33:13.040
Mach provides the protected
address spaces that Mac OS X,

00:33:13.040 --> 00:33:14.320
you know, is promoted.

00:33:14.480 --> 00:33:16.760
Here we have protected address spaces.

00:33:16.760 --> 00:33:17.680
Right.

00:33:17.750 --> 00:33:20.710
One nice thing about the way
Mach does it is you have basically

00:33:20.790 --> 00:33:24.760
extreme flexibility in how you
want to assemble an address space.

00:33:25.130 --> 00:33:25.500
Right.

00:33:25.540 --> 00:33:27.390
You can put stuff here, there,
everywhere.

00:33:27.400 --> 00:33:30.340
It's really wonderful when you're
trying to emulate an old system.

00:33:30.340 --> 00:33:31.190
Well, guess what?

00:33:31.190 --> 00:33:32.980
That's exactly what we're trying to do.

00:33:32.980 --> 00:33:35.460
It's one of the key
benefits of using Mach VM.

00:33:36.400 --> 00:33:38.000
Is that you can put,
if stuff had to be up there,

00:33:38.000 --> 00:33:38.920
you can put it up there.

00:33:38.940 --> 00:33:41.200
there.

00:33:42.010 --> 00:33:46.810
It also provides controlled sharing
of resources so you can map things

00:33:46.810 --> 00:33:49.700
in exclusively into one application.

00:33:49.700 --> 00:33:52.850
You can map them in,
copy on right into one but read right

00:33:52.850 --> 00:33:56.350
into the other so you can write into
your piece of memory and the other

00:33:56.350 --> 00:33:58.160
guy can see it but can't modify it.

00:33:58.160 --> 00:34:01.470
Or you can map things in,
read right into both.

00:34:01.550 --> 00:34:06.700
So it's a really flexible way
of putting systems together.

00:34:07.940 --> 00:34:08.770
What does it look like?

00:34:08.860 --> 00:34:13.530
In the picture before,
we showed a VM object and we showed

00:34:13.680 --> 00:34:15.060
cache pages sitting off of it.

00:34:15.060 --> 00:34:17.660
We showed this thing called a VNode.

00:34:17.660 --> 00:34:22.320
The VNode from the Mach view of things
is just an abstract memory manager.

00:34:22.320 --> 00:34:23.960
It doesn't understand what that is.

00:34:23.960 --> 00:34:26.700
It just has a protocol to talk to it.

00:34:27.260 --> 00:34:30.820
Anybody can be one of
those and provide services.

00:34:30.820 --> 00:34:32.430
As long as you do,
we'll do the right thing.

00:34:32.440 --> 00:34:34.780
Here you have two address spaces.

00:34:35.020 --> 00:34:39.140
Each one of which has some
portion of an object mapped in.

00:34:39.140 --> 00:34:43.120
In this case,
they have the same object mapped in,

00:34:43.120 --> 00:34:45.540
the same part of the same object,
but they have it mapped at

00:34:45.540 --> 00:34:46.630
two different addresses.

00:34:46.660 --> 00:34:50.440
One's up at zero and the other
one's somewhere down inside.

00:34:50.440 --> 00:34:55.530
You're running along and all of a
sudden one of the guys takes a fault

00:34:55.740 --> 00:34:57.050
because the page isn't existing.

00:34:58.470 --> 00:35:01.460
So we send a message, basically,
not send a message,

00:35:01.460 --> 00:35:05.070
but the address space queries the
virtual memory object and says,

00:35:05.070 --> 00:35:06.800
do I have this page cached?

00:35:06.800 --> 00:35:07.710
Well, guess what?

00:35:07.710 --> 00:35:10.440
No, I don't have this page cached,
so let me put a placeholder in

00:35:10.440 --> 00:35:13.320
case somebody else comes along
and tries to do the same thing.

00:35:13.320 --> 00:35:15.990
I won't do this again,
which is sending a request

00:35:16.060 --> 00:35:18.570
to the memory object,
and the memory object

00:35:18.570 --> 00:35:21.590
sends back a data page,
and then we make that data page

00:35:21.590 --> 00:35:23.800
available in the application.

00:35:25.240 --> 00:35:27.470
So now all of a sudden,
you can go on and run.

00:35:27.470 --> 00:35:28.800
But look what happened.

00:35:28.810 --> 00:35:32.600
Over in the other address space,
the guy with the same area mapped in,

00:35:32.690 --> 00:35:35.140
but in a different part
of his address space,

00:35:35.140 --> 00:35:37.330
well, we have the page cached now.

00:35:37.330 --> 00:35:40.070
He doesn't have the
page available to him.

00:35:43.340 --> 00:35:46.880
250 objects that these
guys share in common,

00:35:46.880 --> 00:35:51.330
each one would have to have
250 entries pointing at,

00:35:51.330 --> 00:35:53.770
you know, each of the individual objects.

00:35:53.780 --> 00:35:55.850
Well,
if you're absolutely sure that you're

00:35:55.850 --> 00:35:58.280
going to have a whole bunch of them,
objects that are in common

00:35:58.280 --> 00:36:01.160
between two applications,
you can set up what's

00:36:01.160 --> 00:36:04.480
called a shared region,
which basically is a

00:36:04.480 --> 00:36:06.720
recursive address space.

00:36:06.720 --> 00:36:11.140
You can have an address space entry
that points at another address

00:36:11.150 --> 00:36:12.640
space for any portion of it.

00:36:13.320 --> 00:36:13.630
Right?

00:36:13.640 --> 00:36:18.140
And we tend to use this in our system,
and I'll show you what for in a second.

00:36:18.140 --> 00:36:19.120
Right?

00:36:19.120 --> 00:36:22.510
But we have two of them
that we put into place,

00:36:22.520 --> 00:36:25.380
one that tends to be sitting at
7 bazillion and the other one

00:36:25.380 --> 00:36:26.590
that's sitting at 8 bazillion.

00:36:26.600 --> 00:36:27.420
Right?

00:36:27.420 --> 00:36:31.440
One is directly mapped shared
by each of the applications,

00:36:31.440 --> 00:36:35.640
and another is mapped copy on
write by each of the applications.

00:36:35.640 --> 00:36:38.770
And so let's get rid of that copy
on write one because it's a little

00:36:38.770 --> 00:36:39.800
confusing right for the moment.

00:36:39.800 --> 00:36:40.780
Right?

00:36:40.780 --> 00:36:43.280
And what's backing that
shared address space?

00:36:43.300 --> 00:36:46.100
Well, the same stuff that was backing
the other address space.

00:36:46.100 --> 00:36:46.720
Right?

00:36:46.720 --> 00:36:49.270
A reference to a memory object,
which has some cached

00:36:49.380 --> 00:36:53.760
pages associated with it,
and a reference off to some manager

00:36:53.760 --> 00:36:57.270
that knows how to fill in the data
that it doesn't already have cached.

00:36:57.280 --> 00:37:00.460
So now you come along and you
take a fault on that address.

00:37:00.460 --> 00:37:01.800
Right?

00:37:01.800 --> 00:37:07.000
It queries the shared address space,
and the shared address space then

00:37:07.000 --> 00:37:09.610
doesn't have the page either,
so it basically queries

00:37:09.610 --> 00:37:10.770
the object itself.

00:37:12.920 --> 00:37:15.140
And we go, "Nope, we don't have it,
so let's put a placeholder

00:37:15.140 --> 00:37:18.710
in place." And we put the
placeholder in the shared region.

00:37:19.100 --> 00:37:19.650
Well, guess what?

00:37:19.740 --> 00:37:21.680
Because it's truly
shared by the other guys,

00:37:21.750 --> 00:37:25.490
the placeholder actually shows
up in everybody at the same time.

00:37:25.560 --> 00:37:27.880
Right,
we sent the request onto the pager,

00:37:27.880 --> 00:37:31.330
and when he sends the data back, wham,
the data shows up in every

00:37:31.360 --> 00:37:33.250
address space at the same time.

00:37:34.630 --> 00:37:36.420
What do we use that for?

00:37:36.450 --> 00:37:40.830
Well, if you take a dump of a
typical Mac OS application,

00:37:40.830 --> 00:37:42.190
this is the layout you're going to see.

00:37:42.190 --> 00:37:45.280
Down at zero,
we tend to have a guard page

00:37:45.280 --> 00:37:49.270
that will catch zero faults,
zero references,

00:37:49.290 --> 00:37:52.050
and raise an exception for you.

00:37:52.060 --> 00:37:54.230
If you don't like that idea,
you can go ahead and

00:37:54.230 --> 00:37:55.430
put another page there.

00:37:55.430 --> 00:37:56.030
It's fine.

00:37:56.030 --> 00:37:57.130
Just replace that.

00:37:57.130 --> 00:37:59.200
But that's the typical behavior.

00:38:00.420 --> 00:38:03.790
Starting on the first page on
up to the first gigabyte is

00:38:04.140 --> 00:38:08.240
typically your application where
the application itself is mapped,

00:38:08.330 --> 00:38:11.010
where the heaps and stuff tend to come.

00:38:11.040 --> 00:38:15.740
But heaps can be there and you can
fill up basically any of the space,

00:38:15.740 --> 00:38:19.390
any of the holes in here
with memory that you like.

00:38:19.450 --> 00:38:23.020
So if you have a heap manager
like ours that basically says,

00:38:23.020 --> 00:38:25.900
get me hunks,
and then I'll subdivide them.

00:38:25.940 --> 00:38:26.720
Right.

00:38:26.720 --> 00:38:30.360
Once you run out of space between
the application and one gig,

00:38:30.360 --> 00:38:34.160
if you have more than that,
in heaps it'll go and find spots.

00:38:34.160 --> 00:38:38.420
Basically the first fit for
another chunk going on up the line.

00:38:39.890 --> 00:38:44.460
But if you notice it's seven and
eight bazillion respectively.

00:38:44.510 --> 00:38:47.300
There's a read-only section
and a copy-on-write section.

00:38:47.530 --> 00:38:53.480
Well this is where all the frameworks
tend to fall that your applications use.

00:38:53.550 --> 00:38:58.210
So we have 70 some odd frameworks
that are a standard part of Mac OS X.

00:38:58.220 --> 00:39:04.580
If we had to map those into each
application separately and manage them

00:39:04.580 --> 00:39:12.350
separately and relocate them separately,
we would do a lot of extra overhead

00:39:12.360 --> 00:39:15.060
as each application launched.

00:39:15.110 --> 00:39:19.540
So what we do instead is have a
shared region that points off at all

00:39:19.690 --> 00:39:22.480
the shared text of an application.

00:39:22.590 --> 00:39:24.920
We relocate it once if
it has to be relocated,

00:39:24.920 --> 00:39:28.320
but typically it doesn't because
a lot of our system is pre-bound,

00:39:28.320 --> 00:39:31.050
our libraries, and they sit and point
off in that one area.

00:39:31.060 --> 00:39:39.900
And then we map the data part of that,
add another 256 meg off of that and

00:39:39.900 --> 00:39:43.040
copy-on-write into each application.

00:39:43.050 --> 00:39:46.480
So as each one takes a,
writes particular parts of the data,

00:39:46.480 --> 00:39:48.590
they get their own copy.

00:39:49.310 --> 00:39:53.740
By doing this at 256 meg offsets,
we actually get to take advantage of

00:39:53.800 --> 00:39:58.610
something that happens in the PowerPC,
which is that you can actually truly

00:39:58.690 --> 00:40:04.600
share TLB entries and everything like
that on a 256 meg boundary with people.

00:40:05.000 --> 00:40:08.320
So at the 7 bazillion where
all the frameworks are,

00:40:08.330 --> 00:40:13.250
we're actually sharing TLB entries and
everything between every application.

00:40:13.250 --> 00:40:17.400
Unless that application goes
in and replaces a library or

00:40:17.400 --> 00:40:21.840
overloads a library or says,
use a different library for me,

00:40:21.840 --> 00:40:25.730
then we have to relocate the other
parts of that collection of libraries,

00:40:25.730 --> 00:40:29.070
at which point you get your own
private copy and it behaves like a

00:40:29.070 --> 00:40:31.680
traditional old-fashioned application.

00:40:33.360 --> 00:40:39.570
So how do you go ahead and
debug the VM services you have?

00:40:39.590 --> 00:40:43.090
Well, one of the best tools you've
got available to you if you are

00:40:43.090 --> 00:40:46.540
watching at the tool session
yesterday is malloc-debug.

00:40:46.540 --> 00:40:51.660
It's a wonderful thing to see
individual parts of your heap being

00:40:51.660 --> 00:40:55.080
leaked away and whether or not
you're actually using them anymore

00:40:55.080 --> 00:40:56.560
and whether they could be reclaimed.

00:40:58.250 --> 00:41:01.820
But that doesn't catch memory allocations
that happen outside of the heap manager.

00:41:01.820 --> 00:41:05.620
And there's lots of reasons why
memory would be allocated outside

00:41:05.670 --> 00:41:08.170
the heap manager and directly
fill up your address space.

00:41:08.900 --> 00:41:12.060
And there's this tool called
VM Map which will actually just

00:41:12.060 --> 00:41:16.380
give you a dump of all the,
it's a command line tool, sorry,

00:41:16.380 --> 00:41:19.610
that will give you a dump of
all the mappings in your system,

00:41:19.610 --> 00:41:22.720
in your application,
and you can find the ones that

00:41:22.720 --> 00:41:26.760
you don't seem to realize,
you don't remember having, right,

00:41:26.760 --> 00:41:29.060
and start investigating those.

00:41:29.080 --> 00:41:32.490
And what you'll tend to find is
that something sent you a piece of

00:41:32.490 --> 00:41:35.060
memory and you just forgot about it,
right?

00:41:35.060 --> 00:41:37.460
Something in the system sent
it to you out of line in a

00:41:37.460 --> 00:41:38.870
message or some other way.

00:41:38.900 --> 00:41:42.100
Or you allocated a hunk
directly with VM allocate,

00:41:42.160 --> 00:41:48.560
right, instead of using the malloc tools,
and you just let it dangle, all right?

00:41:48.880 --> 00:41:50.730
and that will show you those.

00:41:50.770 --> 00:41:52.780
You can also see those in top.

00:41:52.790 --> 00:41:54.790
The place you go first is top.

00:41:54.830 --> 00:41:56.800
You watch your application running.

00:41:56.990 --> 00:42:06.320
If you see the number of memory entries
going up and up and up and up and up,

00:42:06.320 --> 00:42:07.740
you're probably forgetting to
deallocate something that you

00:42:07.740 --> 00:42:07.740
really needed to deallocate.

00:42:08.860 --> 00:42:14.030
One of the things that happens is
when you do one of those VM allocates,

00:42:14.220 --> 00:42:17.350
they tend to start at zero
and find the first fit.

00:42:17.400 --> 00:42:22.420
When you're looking through
your address map and you see

00:42:22.420 --> 00:42:28.420
a bunch of entries up by zero,
these are probably pieces of memory

00:42:28.420 --> 00:42:31.580
that were allocated with VM allocate
and you might want to look at those.

00:42:31.580 --> 00:42:35.960
Another really important tip goes
along with the no cache option is

00:42:36.000 --> 00:42:39.640
if you map things into your address
space or you malloc a big hunk of

00:42:39.640 --> 00:42:44.140
memory or you allocate it and you
use it and now you're done with it.

00:42:44.140 --> 00:42:47.390
But you really don't want to keep
allocating it and deallocating

00:42:47.390 --> 00:42:49.340
it because maybe it's expensive.

00:42:49.340 --> 00:42:51.260
You want to kill it.

00:42:51.390 --> 00:42:53.120
Kill it out of the cache.

00:42:53.120 --> 00:42:56.710
There's a couple of ways you can do that.

00:42:56.770 --> 00:43:00.480
There's an msync option at the
POSIX level that lets you kill pages.

00:43:00.480 --> 00:43:03.450
There's another one at the
Mach level called vmmsync.

00:43:03.480 --> 00:43:05.880
They're really usable interchangeably.

00:43:05.880 --> 00:43:07.940
It depends on what API set you want.

00:43:07.960 --> 00:43:09.700
want to stick to.

00:43:09.710 --> 00:43:11.800
But you'd need to kill them.

00:43:12.380 --> 00:43:12.600
Okay.

00:43:12.600 --> 00:43:14.420
So we talked about all these things.

00:43:14.440 --> 00:43:16.800
We've got, you know,
tasks and threads and address

00:43:16.840 --> 00:43:20.120
spaces and they're all protected,
but when you have a protected address

00:43:20.190 --> 00:43:23.750
space in a protected environment,
you need to communicate somehow.

00:43:23.750 --> 00:43:26.900
And so that brings us
to the IPC services.

00:43:29.000 --> 00:43:34.190
And again, Mach plays a big part in the
IPC services of Mac OS X.

00:43:34.190 --> 00:43:37.260
Not so much in what
happens at the BSD level,

00:43:37.260 --> 00:43:39.760
so in a BSD process it
might not be that important.

00:43:39.760 --> 00:43:43.190
But in Mac OS X in general,
it actually becomes very important.

00:43:44.810 --> 00:43:49.400
So, an address, sorry,
the basic idea of IPC service

00:43:49.400 --> 00:43:51.440
in Mac OS X is Mach IPC.

00:43:51.440 --> 00:43:56.690
Mach IPC manages rights in port
namespaces associated with each task.

00:43:56.720 --> 00:43:58.430
You have rights to ports.

00:43:58.490 --> 00:44:01.980
It's kind of like an open
file descriptor inside of BSD,

00:44:02.100 --> 00:44:04.890
but instead it's a
communications channel,

00:44:04.890 --> 00:44:07.220
a small one, called a Mach port.

00:44:08.300 --> 00:44:10.440
So,
here I have a Mach port in this second

00:44:10.440 --> 00:44:13.760
task that gives me the right to send a
message to the front end of the Mac OS X.

00:44:15.690 --> 00:44:18.670
What's really nice about Mac OS X,
or about Mach IPC,

00:44:18.670 --> 00:44:22.030
is that if you have memory and
you have other port rights,

00:44:22.030 --> 00:44:26.860
you can collect those together and send
them in messages over to the other task.

00:44:27.270 --> 00:44:29.280
And so you can do really
flexible communication.

00:44:29.280 --> 00:44:32.300
So I've got a piece of memory
in my address space in task two,

00:44:32.340 --> 00:44:34.530
and I've got another
port right in task two,

00:44:34.530 --> 00:44:36.640
one that I own the receive right for.

00:44:37.080 --> 00:44:40.150
And what I do is I build a little
message that basically contains,

00:44:40.150 --> 00:44:43.110
you know, some general description
of what I'm sending.

00:44:43.600 --> 00:44:43.780
But I don't have to send it to
the front end of the Mac OS X.

00:44:44.100 --> 00:44:46.130
But it also contains a reference
to each of these things.

00:44:46.820 --> 00:44:49.710
And I send it over to
the port that I have,

00:44:49.710 --> 00:44:53.770
and when it's received over in task one,
guess what?

00:44:53.830 --> 00:44:56.700
Now he has new virtual memory,
and he has new port rights.

00:44:58.000 --> 00:45:01.790
He can use the port right I just
gave him to send a message back to

00:45:01.790 --> 00:45:03.220
me saying I'm done what I'm doing.

00:45:03.220 --> 00:45:08.160
All the RPC and the interaction that
goes on inside of Mac OS X or a large

00:45:08.790 --> 00:45:11.770
portion of it happens via this mechanism.

00:45:12.240 --> 00:45:16.070
When you want to open a
window in a GUI application,

00:45:16.070 --> 00:45:19.230
well,
the frameworks inside of your application

00:45:19.230 --> 00:45:23.820
talk to the core graphics server,
the Windows server, by sending a message,

00:45:23.820 --> 00:45:26.500
a Mach message over there
saying we need to do something.

00:45:26.500 --> 00:45:29.390
And what they do is they arrange
to have a piece of shared memory in

00:45:29.550 --> 00:45:33.010
common to do most of the communication,
but then they are constantly sending

00:45:33.070 --> 00:45:36.470
messages back and forth to each other
about what the state of that is.

00:45:39.110 --> 00:45:42.960
So again,
you have this inside of each task.

00:45:43.060 --> 00:45:45.990
You have a collection of these ports,
right?

00:45:46.050 --> 00:45:48.540
And they can represent, you know,
just a basic message queue.

00:45:48.540 --> 00:45:51.480
There's also variants
that are like semaphores,

00:45:51.500 --> 00:45:52.740
lock sets, right?

00:45:52.810 --> 00:45:55.310
They're handles to things
that the kernel implements.

00:45:55.310 --> 00:45:57.820
And they can be collected in sets.

00:45:57.930 --> 00:46:01.840
And that collection in
sets is really important.

00:46:02.220 --> 00:46:04.500
Because if you look
inside of an application,

00:46:04.520 --> 00:46:07.480
a GUI application in Mac OS X,
you're going to see at least

00:46:07.480 --> 00:46:10.200
one of these CF run loop things,
right,

00:46:10.200 --> 00:46:14.980
which is the basic primitive of the
event mechanism inside of Mac OS X.

00:46:14.980 --> 00:46:18.980
And a CF run loop is actually just
a wrapper around a Mach port set,

00:46:18.980 --> 00:46:21.820
right, or a collection of Mach port sets.

00:46:21.890 --> 00:46:25.680
So you may have many port sets and
the CF run loops own some of them

00:46:25.770 --> 00:46:28.030
and put some port rights into them.

00:46:28.030 --> 00:46:32.030
And each of those port rights represents
something that can drive events.

00:46:32.100 --> 00:46:36.330
a source of events that your
application may need to deal with.

00:46:36.610 --> 00:46:38.710
So he's already got a
bunch in this port set,

00:46:38.710 --> 00:46:41.480
but as time goes on,
he adds more and more and more.

00:46:41.480 --> 00:46:45.950
And what you realize is while
you're talking to a lot of things

00:46:46.020 --> 00:46:50.000
inside of Mac OS X via ports,
every once in a while you're talking

00:46:50.090 --> 00:46:54.420
to a traditional BSD application
or you're talking to a traditional,

00:46:54.460 --> 00:46:56.810
you know, who knows, right?

00:46:56.890 --> 00:46:59.290
There's lots of other ways you
can communicate with things,

00:46:59.300 --> 00:47:03.870
but you need to somehow, you know,
most applications feed that back into the

00:47:03.880 --> 00:47:07.950
run loop so that your application can see
the events driven by these other sources.

00:47:07.960 --> 00:47:11.740
While you can't be
sitting at a single wait,

00:47:11.750 --> 00:47:16.740
right, when you do a CF run loop wait,
right, it sits on a port set

00:47:16.800 --> 00:47:19.280
waiting for a message,
right?

00:47:19.280 --> 00:47:23.020
If that isn't coming in via a port set,
that thread isn't going to see it.

00:47:23.020 --> 00:47:25.510
Or through a port,
it's not going to see it.

00:47:25.640 --> 00:47:28.380
So that thread can act,
that run loop can actually

00:47:28.400 --> 00:47:32.490
create worker threads for the
kinds of IPC that he doesn't,

00:47:32.490 --> 00:47:37.460
that isn't port-based receives the,
in this case, off of a socket,

00:47:37.460 --> 00:47:40.100
receives the message off a socket
or the data off a socket and

00:47:40.100 --> 00:47:44.230
tickles another port inside the
port set to wake the run loop up.

00:47:47.360 --> 00:47:50.990
Some of those other sources
that you can get things on.

00:47:51.060 --> 00:47:55.010
At the BSD level you have sockets
and POSIX semaphores and you

00:47:55.030 --> 00:47:57.300
have Pthread synchronizers.

00:47:57.300 --> 00:48:01.300
Right now the Pthread
synchronizers are intratask only,

00:48:01.300 --> 00:48:05.730
but as time goes on they'll
become intertask as POSIX says

00:48:05.850 --> 00:48:07.660
they're allowed to be.

00:48:07.660 --> 00:48:12.300
And then they're going to have
to feed into this mechanism as

00:48:12.300 --> 00:48:14.300
well if you want to be able to
receive them in a single place.

00:48:16.210 --> 00:48:21.440
And then what happens at the outer
level again is you have a port set

00:48:21.480 --> 00:48:26.080
that's wrapped by a run loop that
becomes the foundation of your event

00:48:26.080 --> 00:48:28.400
queue inside of your application.

00:48:28.400 --> 00:48:32.280
And so as you're watching
your applications,

00:48:32.280 --> 00:48:36.590
your main thread is going to
be calling wait next event.

00:48:36.620 --> 00:48:37.550
Hopefully not.

00:48:37.550 --> 00:48:39.560
Hopefully it's using Carbon events.

00:48:39.560 --> 00:48:42.950
But if it is calling wait next event,
that's going to be

00:48:43.030 --> 00:48:44.660
calling CF run loop run.

00:48:44.800 --> 00:48:48.040
We'll see if run loop actually built
up one of these port sets of all the

00:48:48.040 --> 00:48:50.070
things that can drive events into it.

00:48:50.140 --> 00:48:53.490
And then that's calling
Mach message trap,

00:48:53.500 --> 00:48:57.760
typically Mach message override trap,
doing a receive waiting

00:48:57.760 --> 00:48:58.830
for stuff to come in.

00:48:58.880 --> 00:49:02.300
So you're going to see that over
and over and over and over again

00:49:02.300 --> 00:49:04.160
in each of your applications.

00:49:09.640 --> 00:49:13.340
Again, when you're looking in Sampler,
you're going to see that kind of thing.

00:49:13.450 --> 00:49:15.300
You're also going to see it in SC usage.

00:49:15.300 --> 00:49:19.740
If you run SC usage at the bottom,
it tends to list all the

00:49:20.200 --> 00:49:23.820
threads and what they're doing,
what they're currently waiting on.

00:49:23.860 --> 00:49:25.980
And you're going to see
Mach message over write trap,

00:49:25.980 --> 00:49:28.440
Mach message over write trap,
Mach message over write trap,

00:49:28.440 --> 00:49:29.830
Mach message over write trap.

00:49:29.860 --> 00:49:34.830
They're all coming in on run loops
of some sort or another or directly

00:49:34.830 --> 00:49:37.210
receiving on a Mach message.

00:49:37.200 --> 00:49:44.170
Ports represent almost
everything in Mac or in Mac OS X,

00:49:44.170 --> 00:49:46.190
a large portion of things.

00:49:46.190 --> 00:49:50.880
So again, if you have a window open,
the handle for the window is a port.

00:49:50.920 --> 00:49:58.920
So when you look at the CG debug stuff,
it has a list down the side of

00:49:58.920 --> 00:50:01.320
the ports that it has open to
represent each one of those windows.

00:50:01.730 --> 00:50:04.990
And if you're tempted
to use the IPC directly,

00:50:05.000 --> 00:50:07.280
the Mach IPC, we prefer you not.

00:50:07.280 --> 00:50:08.560
There's a tool called MIG.

00:50:08.590 --> 00:50:12.190
It's Mach interface generator.

00:50:12.400 --> 00:50:17.420
And it's basically an IDL compiler
that wraps around Mach messaging

00:50:17.430 --> 00:50:21.810
and you can specify routines that go
both directions or one-way messages

00:50:21.810 --> 00:50:25.300
and it generates wrapper routines
that generate those messages for you

00:50:25.300 --> 00:50:28.640
and receive those messages for you
so you don't have to understand and

00:50:28.640 --> 00:50:30.960
manipulate the low-level messaging.

00:50:31.140 --> 00:50:33.830
It's just a nice convenience.

00:50:34.680 --> 00:50:38.850
Okay, so now we have the ability to
communicate but we're supposed

00:50:38.850 --> 00:50:40.420
to have a secure system here.

00:50:40.420 --> 00:50:42.070
How do we do that?

00:50:42.110 --> 00:50:45.160
Well, again,
a lot comes back to those ports.

00:50:45.230 --> 00:50:48.860
Ports are restricted.

00:50:48.860 --> 00:50:52.480
You can't just invent a port
name inside of Mac and say I want

00:50:52.580 --> 00:50:54.670
to send a message to that port.

00:50:54.690 --> 00:50:58.480
Somebody has to give you that port,
a send write to that

00:50:58.740 --> 00:51:00.580
port in the first place.

00:51:00.580 --> 00:51:03.120
Some of them are registered
globally where you can just

00:51:03.120 --> 00:51:04.470
look them up and get them.

00:51:04.600 --> 00:51:08.330
So you can send some common service
a message saying I want to do

00:51:08.330 --> 00:51:10.780
something and it'll respond to that.

00:51:12.000 --> 00:51:15.920
But in a lot of ways, a lot of cases,
they aren't registered globally.

00:51:15.920 --> 00:51:20.650
So maybe you'll talk to a service through
a global port and it will send you back

00:51:20.650 --> 00:51:26.780
a port that only you can talk to it
to directly manipulate your Windows.

00:51:26.780 --> 00:51:30.280
That's why inside of the
Windows server communication,

00:51:30.280 --> 00:51:34.360
you get a new port per window because
it only wants you and only you to

00:51:34.360 --> 00:51:36.800
be able to manipulate that window.

00:51:36.800 --> 00:51:39.870
And the port write mechanism
allows that to happen without

00:51:39.900 --> 00:51:41.690
him doing anything on his side.

00:51:42.000 --> 00:51:43.500
I received a message on that port.

00:51:43.500 --> 00:51:46.680
It must be him or somebody he
delegated to send this message.

00:51:46.680 --> 00:51:47.230
I'll do it.

00:51:47.380 --> 00:51:49.550
So they're pre-authorized.

00:51:49.580 --> 00:51:56.090
And in fact, Mach part of Mac OS X has no
authorization facility at all.

00:51:57.420 --> 00:52:01.270
It basically says if you've got that
port and you send a message on it,

00:52:01.270 --> 00:52:03.990
we'll do what that message says to do.

00:52:04.270 --> 00:52:09.010
Those ports represent things
inside of the kernel as well.

00:52:09.040 --> 00:52:13.580
If you have a task or a thread or
any of those other kernel resources,

00:52:13.610 --> 00:52:16.390
they're represented by unique ports.

00:52:16.460 --> 00:52:19.740
You get a hold of one of those ports,
a thread port, you send a message to

00:52:19.740 --> 00:52:20.910
it saying terminate.

00:52:20.950 --> 00:52:22.040
Guess what?

00:52:22.110 --> 00:52:23.390
It'll terminate.

00:52:25.020 --> 00:52:28.070
You've got to be careful
about sending your ports out,

00:52:28.070 --> 00:52:31.300
but it's also a really nice
mechanism to say we're not going

00:52:31.300 --> 00:52:34.810
to just say that APIs are available
and usable by the application

00:52:34.900 --> 00:52:37.080
themselves like threading APIs.

00:52:37.080 --> 00:52:41.000
If that application wants to send
its thread port over to a friend,

00:52:41.000 --> 00:52:45.480
that friend can issue all the threading
APIs itself directly on that port and

00:52:45.480 --> 00:52:50.210
will treat it at the kernel level just
like the application had done it itself.

00:52:50.240 --> 00:52:53.080
The same thing with
managing the port space.

00:52:53.080 --> 00:52:54.930
The port space is
represented by the task.

00:52:55.060 --> 00:52:59.780
Getting things in and out of your own
port space is done with that same thing.

00:52:59.780 --> 00:53:05.590
The only nod to authorization that the
mock-level services provide is that each

00:53:05.710 --> 00:53:10.360
message that's sent is sent with a tag,
some kind of security tag

00:53:10.520 --> 00:53:14.260
on it that basically says,
I don't know what this is,

00:53:14.260 --> 00:53:19.690
but somebody said five was associated
with the guy who sent this message,

00:53:19.690 --> 00:53:22.560
so I'm going to send five along.

00:53:22.560 --> 00:53:25.000
Well, what happens?

00:53:25.000 --> 00:53:29.050
What happens is the BSD layer is
the guy who says what five means.

00:53:29.070 --> 00:53:33.340
He provides the identification
and authorization in the system.

00:53:33.690 --> 00:53:39.170
Identification is UIDs
inside the BSD world.

00:53:39.340 --> 00:53:40.530
user IDs.

00:53:40.710 --> 00:53:50.840
You have user IDs and effective
user IDs and you have group IDs and

00:53:50.840 --> 00:53:50.840
effective group IDs and you have,
you know, correct collection of groups

00:53:50.840 --> 00:53:50.840
that you're allowed to be in.

00:53:51.010 --> 00:53:57.220
Right, and whatever BSD says,
this task has as a security

00:53:57.300 --> 00:53:59.210
token is what gets sent along.

00:53:59.300 --> 00:54:02.970
Well, BSD is also the guy who maintains
permissions at the file level,

00:54:02.970 --> 00:54:08.080
makes sense because he's the guy who
implements the file systems at his level.

00:54:08.210 --> 00:54:13.200
All the authorization to gain access
to files is done by the BSD layer.

00:54:13.200 --> 00:54:16.380
He does somewhat similar
to what Mac does.

00:54:16.690 --> 00:54:21.310
Once he has given access to
something through the file system,

00:54:21.310 --> 00:54:24.310
he has a file descriptor which
is basically the access point,

00:54:24.340 --> 00:54:27.200
the restricted access point,
and permissions are associated

00:54:27.200 --> 00:54:28.200
with that file descriptor.

00:54:28.200 --> 00:54:33.350
It's pre-cached authorizations.

00:54:35.100 --> 00:54:40.420
But BSD semantics and
Mach semantics alone aren't

00:54:40.420 --> 00:54:43.740
enough for Mac OS X in general.

00:54:43.740 --> 00:54:48.700
You have applications that
want to run as a general user,

00:54:48.700 --> 00:54:51.500
a regular old user that need
to do privileged things.

00:54:51.500 --> 00:54:55.170
Sometimes we have a privileged
server that's just sitting over there

00:54:55.170 --> 00:54:56.920
waiting to do that thing for you.

00:54:57.830 --> 00:55:02.800
And other times we have a server
that is privileged to do specific

00:55:02.830 --> 00:55:10.650
things and will authorize you each
time to do that one particular thing

00:55:10.700 --> 00:55:14.980
through the new authorization API that
happens as a core service API.

00:55:14.980 --> 00:55:19.460
Also at that level you have keychains
and keychain management and all

00:55:19.460 --> 00:55:23.670
that stuff is done up above the
basic primitives of the BSD file and

00:55:23.740 --> 00:55:26.240
UID stuff and the Mach port stuff.

00:55:29.630 --> 00:55:33.470
Again, FS usage is nice because
it shows you what kind of

00:55:33.470 --> 00:55:35.820
access you're doing to a file.

00:55:35.820 --> 00:55:39.100
LSOF will tell you what kind
of accesses you have to a file.

00:55:39.100 --> 00:55:43.130
VM map will tell you what kind of
permissions you have on certain memory.

00:55:43.170 --> 00:55:48.300
So if you have read, write, or read,
write, copy on write so that when you

00:55:48.300 --> 00:55:52.710
actually touch the thing you get a
unique copy instead of being able

00:55:52.790 --> 00:55:55.180
to write to the actual main store.

00:55:55.180 --> 00:55:58.810
So you can get a feel for what's
going on in the system that way.

00:56:01.080 --> 00:56:06.330
One thing to do is take a nod from
the Mach part and the BSD part

00:56:06.330 --> 00:56:08.790
which is to cache authorizations.

00:56:08.840 --> 00:56:13.010
If you have to do some of your own work,
well yes you could set up a server

00:56:13.010 --> 00:56:17.280
that receives messages and just
constantly looks at the security token

00:56:17.280 --> 00:56:21.230
on the bottom of a message and says
well am I allowed to take this from

00:56:21.230 --> 00:56:23.730
this guy because he says he's five.

00:56:23.760 --> 00:56:28.420
Do I allow five to do
this or do I say no?

00:56:28.420 --> 00:56:30.910
That's kind of awkward to keep in mind.

00:56:31.000 --> 00:56:34.160
You keep doing that over
and over and over again.

00:56:34.160 --> 00:56:38.380
You would prefer to establish a unique
connection with each of your clients

00:56:38.510 --> 00:56:43.420
in that situation and receive only and
pass out the send write on the other

00:56:43.420 --> 00:56:48.220
side only to that one guy and then every
time a message comes in on that you

00:56:48.220 --> 00:56:50.910
allow him to go ahead and access it.

00:56:53.370 --> 00:56:55.860
Alright, so those were the basic
services inside the kernel.

00:56:55.860 --> 00:56:59.350
Where can you get more information
about how this stuff all really

00:56:59.350 --> 00:57:02.950
works because this was far too much
and far too quick to get too much of

00:57:02.950 --> 00:57:05.010
anything totally useful out of it?

00:57:05.080 --> 00:57:08.410
Well, there's a good resource
right on the developer CD and

00:57:08.410 --> 00:57:10.910
if you've installed that,
now it's right on the disk of

00:57:10.980 --> 00:57:13.490
your system and most people
don't even realize it's there.

00:57:13.500 --> 00:57:16.400
Under the developer section
there's a documentation section.

00:57:16.400 --> 00:57:18.240
Under that there's a kernel section.

00:57:19.460 --> 00:57:22.130
And there's descriptions,
there's a basic description

00:57:22.130 --> 00:57:25.060
of the kernel services again,
some more details about

00:57:25.140 --> 00:57:27.850
how they're managed,
what the APIs are.

00:57:27.860 --> 00:57:31.410
And especially on this particular part,
there's a reference to something

00:57:31.440 --> 00:57:33.100
called the OSF documentation.

00:57:33.100 --> 00:57:37.090
Well,
our Mach kernel is the OSF Mach kernel

00:57:37.090 --> 00:57:42.650
and so if you click through that link,
you're going to go ahead and

00:57:42.660 --> 00:57:46.660
find the documentation for the
Mach APIs that we have in our system.

00:57:46.660 --> 00:57:47.920
They're not 100% accurate.

00:57:47.920 --> 00:57:49.440
They're quite a few years old.

00:57:49.440 --> 00:57:53.390
And we've made some changes internally,
but they're pretty good and it

00:57:53.460 --> 00:57:57.490
gives you a really good idea of how
the Mach part of the system works.

00:57:57.760 --> 00:58:00.100
There's obviously the
Darwin open source pages.

00:58:00.100 --> 00:58:01.090
You can go to those.

00:58:01.090 --> 00:58:03.500
And the Mac OS X homepage.

00:58:03.500 --> 00:58:07.820
And our tech writers have
renamed the book on me.

00:58:07.850 --> 00:58:12.690
It's the design and implementation of
the 4.4 BSD operating system by McKusick.

00:58:12.720 --> 00:58:15.020
It's great for the BSD side of things.

00:58:15.020 --> 00:58:16.120
All right.

00:58:16.120 --> 00:58:19.340
Where can you learn more here today?

00:58:22.160 --> 00:58:22.340
Sorry.

00:58:22.340 --> 00:58:26.230
But for those of people who are
watching via the DVD later on,

00:58:26.230 --> 00:58:28.600
you can go look up these sessions.

00:58:28.620 --> 00:58:30.790
The performance tool
session was really good.

00:58:30.800 --> 00:58:34.420
It shows you how to see the effects
of all of these interactions inside

00:58:34.420 --> 00:58:36.690
of an application that you're writing.

00:58:36.690 --> 00:58:38.650
The same thing with the debugging stuff.

00:58:38.650 --> 00:58:41.060
So when you get your CD later,
go look at the debugging

00:58:41.130 --> 00:58:42.410
and the performance stuff.

00:58:42.510 --> 00:58:43.930
They're really important.

00:58:43.930 --> 00:58:48.690
You just saw the leveraging the
BSD more than likely if you were here.

00:58:48.690 --> 00:58:52.100
And in a few minutes
you'll get to do feedback.
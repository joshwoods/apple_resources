WEBVTT

00:00:03.360 --> 00:00:04.660
Good afternoon.

00:00:04.700 --> 00:00:07.930
It's good to see so many people
here who have checked out of

00:00:07.980 --> 00:00:11.500
their hotels looking for a nice,
cool, dark place to catch some rest

00:00:11.550 --> 00:00:15.000
before they take their flight back
to wherever it is they came from.

00:00:15.000 --> 00:00:18.980
Have you guys caught all the other
WebObjects sessions this week?

00:00:19.040 --> 00:00:20.570
Catch some good sessions?

00:00:20.580 --> 00:00:22.810
Who caught...

00:00:23.880 --> 00:00:25.790
Who caught Steve Heyman's presentation?

00:00:25.810 --> 00:00:27.750
Come on.

00:00:27.790 --> 00:00:27.800
Steve Heyman?

00:00:27.800 --> 00:00:29.800
And then we had James Dempsey singing,
right?

00:00:29.800 --> 00:00:31.800
Okay.

00:00:32.060 --> 00:00:33.800
Well,
are there any Canadians in the room?

00:00:33.900 --> 00:00:34.780
Yeah?

00:00:35.000 --> 00:00:35.800
Well, I'm not Canadian.

00:00:35.800 --> 00:00:41.930
I'm from New Orleans, Louisiana,
and I'm not going to sing or

00:00:41.930 --> 00:00:43.800
play the guitar or anything.

00:00:43.820 --> 00:00:46.730
We're going to talk about some really
interesting stuff about WebObjects.

00:00:46.800 --> 00:00:48.800
Now, a guy came up to me
yesterday and he said,

00:00:48.830 --> 00:00:52.960
"Fitz, what is it that makes WebObjects,
an application server,

00:00:52.960 --> 00:00:55.800
better than all the other application
servers out there?" And I said,

00:00:55.830 --> 00:00:56.800
"How should I know, Bob?

00:00:56.800 --> 00:00:57.800
You're the product manager."

00:01:01.320 --> 00:01:05.580
Thank you for your jaded applause.

00:01:05.680 --> 00:01:10.200
Anyway, we're going to talk about making
your WebObjects applications faster.

00:01:10.200 --> 00:01:11.600
We have a couple of goals.

00:01:11.630 --> 00:01:13.310
We're going to finally
eliminate performance

00:01:13.340 --> 00:01:16.140
bottlenecks in your components,
in your application,

00:01:16.170 --> 00:01:17.700
in your enterprise object model.

00:01:17.700 --> 00:01:19.850
We're going to talk about three areas.

00:01:19.940 --> 00:01:23.250
We're going to talk about the tools
needed to identify trouble spots,

00:01:23.250 --> 00:01:25.470
including tools that
ship with WebObjects.

00:01:25.520 --> 00:01:28.170
We're going to talk about certain
types of bottlenecks to look for

00:01:28.170 --> 00:01:29.760
in your WebObjects application.

00:01:29.760 --> 00:01:32.270
And then we're going to talk
about certain techniques which

00:01:32.270 --> 00:01:36.460
you can use from the get-go
that will eliminate bottlenecks.

00:01:37.870 --> 00:01:41.660
We're going to talk about
when to do performance tuning.

00:01:41.800 --> 00:01:42.450
Do you do it now?

00:01:42.500 --> 00:01:43.500
Do you do it later?

00:01:43.520 --> 00:01:44.570
Do you wait till you finish your app?

00:01:44.670 --> 00:01:46.400
Do you start from the beginning?

00:01:46.400 --> 00:01:48.340
We're going to talk about some
tools that ship with WebObjects

00:01:48.340 --> 00:01:49.930
that make things a lot easier.

00:01:49.960 --> 00:01:51.040
Playback.

00:01:51.050 --> 00:01:53.750
WoEvents, WoEstats,
other methods to measuring

00:01:53.800 --> 00:01:55.780
performance of your app.

00:01:55.850 --> 00:01:58.590
We're going to discuss specifically
WebObjects and UOF techniques

00:01:59.000 --> 00:02:00.780
to improve your performance.

00:02:00.860 --> 00:02:03.300
There's a lot of other techniques out
there which we're not going to focus

00:02:03.640 --> 00:02:06.450
on related to programming in general,
but those are for

00:02:06.460 --> 00:02:07.540
definitely another session.

00:02:07.560 --> 00:02:10.560
And last,
when it's time to upgrade your hardware.

00:02:10.560 --> 00:02:13.460
When it's time to get
more RAM in that machine,

00:02:13.460 --> 00:02:15.820
when it's time to get more processors,
when it's time to

00:02:15.820 --> 00:02:17.140
increase your processors.

00:02:17.540 --> 00:02:20.370
Fortunately, WebObjects, I'm sorry,
increased the number of machines

00:02:20.370 --> 00:02:21.510
you have for app servers.

00:02:22.100 --> 00:02:24.970
Fortunately,
WebObjects makes it really easy to

00:02:24.970 --> 00:02:27.530
add machines to your server farm.

00:02:29.050 --> 00:02:31.740
Now, I'm a big fan of Donald Knuth.

00:02:31.740 --> 00:02:34.240
I used to be a big LaTeX fan
about eight or nine years ago.

00:02:34.240 --> 00:02:35.440
Anybody else here use LaTeX?

00:02:35.510 --> 00:02:40.000
Way back in the old days when XML wasn't
even really the cool buzzword yet.

00:02:41.680 --> 00:02:43.560
Premature optimization
is the root of all evil.

00:02:43.610 --> 00:02:46.690
Now, I put this in here specifically
because that is one of the

00:02:46.690 --> 00:02:48.190
things that I am most guilty of.

00:02:48.280 --> 00:02:50.900
When I sit down,
we get a design for application,

00:02:50.900 --> 00:02:52.770
we start coding,
and I just want everything

00:02:52.770 --> 00:02:53.640
to be really pretty.

00:02:53.640 --> 00:02:54.790
We've got a nice clean slate.

00:02:54.840 --> 00:02:56.130
I want it to be fast.

00:02:56.230 --> 00:02:59.620
I want to make sure I don't do anything
that is a performance bottleneck.

00:03:00.290 --> 00:03:02.230
Unfortunately,
that's not the time nor the place

00:03:02.230 --> 00:03:03.760
for doing that kind of work.

00:03:06.000 --> 00:03:07.900
You want to work towards
functional stability.

00:03:07.990 --> 00:03:11.020
You have a specification,
you create your application.

00:03:11.020 --> 00:03:14.400
You want to get functionally stable
before you start optimizing things.

00:03:14.500 --> 00:03:17.010
Because you never know when you're
going to add or remove functionality.

00:03:17.220 --> 00:03:20.540
You may optimize something that doesn't
even wind up in your final application.

00:03:20.700 --> 00:03:24.650
You may optimize something that is
buried in a myriad of other heavy

00:03:24.980 --> 00:03:29.380
duty methods and it turns out that
it was just a waste of your time.

00:03:30.030 --> 00:03:35.090
You don't want to sacrifice good design
and maintainability for optimizing.

00:03:35.100 --> 00:03:38.760
You don't want to wind up loosing
everything into a single method that

00:03:38.760 --> 00:03:43.140
is 375,000 lines long just because
it goes 10 milliseconds faster

00:03:43.160 --> 00:03:45.000
on your little performance meter.

00:03:45.150 --> 00:03:46.990
Speed is not everything.

00:03:46.990 --> 00:03:51.550
Optimization is about making your
application faster but making your

00:03:51.550 --> 00:03:53.790
development time just as fast.

00:03:53.850 --> 00:03:55.130
It's also about maintainability.

00:03:56.420 --> 00:03:59.810
Another thing I'll talk about is a big
carpenter adage which is measure twice,

00:03:59.880 --> 00:04:00.580
cut once.

00:04:00.580 --> 00:04:03.670
I usually cut my finger first.

00:04:03.680 --> 00:04:08.260
You want to measure, modify,
and then measure again.

00:04:08.600 --> 00:04:10.660
So create a controlled environment.

00:04:10.720 --> 00:04:11.930
This is really important.

00:04:12.000 --> 00:04:14.090
Create a controlled environment.

00:04:14.100 --> 00:04:14.780
Do a measurement.

00:04:14.780 --> 00:04:17.980
Make a change that you think
might be an improvement.

00:04:17.980 --> 00:04:21.540
Run your controlled test again
with no other change in it.

00:04:21.610 --> 00:04:26.300
And then you can get conclusive evidence
as to what helps and what hinders.

00:04:28.500 --> 00:04:32.340
Our technology framework
provides a number of different

00:04:32.340 --> 00:04:35.790
very handy things to help you

00:04:35.980 --> 00:04:37.530
measure your performance.

00:04:37.670 --> 00:04:40.400
WoEvent profiles methods
in your components.

00:04:40.450 --> 00:04:44.680
It's an extremely precise method
for measuring what parts of

00:04:44.690 --> 00:04:46.900
your application take more time.

00:04:47.280 --> 00:04:48.880
There is also WoeStats.

00:04:48.890 --> 00:04:51.950
WoEstats is a very,
very enlightening thing to

00:04:51.950 --> 00:04:53.750
have on your application.

00:04:53.900 --> 00:04:57.280
You can pull that up and tell
at a quick look on one page

00:04:57.280 --> 00:05:01.630
what components are faster,
what components are slower.

00:05:01.720 --> 00:05:03.360
You can see mean time.

00:05:03.360 --> 00:05:06.790
You can see the slowest
access or the fastest access.

00:05:06.940 --> 00:05:09.940
It tells you a lot about what
your components are doing.

00:05:10.110 --> 00:05:13.440
The Playback Manager can
simulate multiple users.

00:05:13.620 --> 00:05:16.210
You set an NSUser default
in the command line,

00:05:16.330 --> 00:05:19.480
run your application with
the recording enabled,

00:05:19.490 --> 00:05:22.440
and then when you quit the application,
then you can play back

00:05:22.440 --> 00:05:27.110
this session with one user,
simulate 10 users, simulate 200 users

00:05:27.110 --> 00:05:29.190
hammering your application.

00:05:29.420 --> 00:05:32.570
Lastly, and one of my personal
favorites is SQL debugging.

00:05:32.570 --> 00:05:37.020
We all know that EOF generates
SQL to talk to your database.

00:05:37.020 --> 00:05:40.560
I'm really happy to say that I haven't
put a line of SQL in an application

00:05:40.560 --> 00:05:42.430
since I started using WebObjects.

00:05:42.460 --> 00:05:45.220
And that was one of the things that
really made my life hell before

00:05:45.300 --> 00:05:46.870
I discovered this technology.

00:05:47.850 --> 00:05:50.860
This shows you exactly all the
SQL that WebObjects generates

00:05:50.860 --> 00:05:53.750
and sends to your database,
as well as information about

00:05:53.750 --> 00:05:55.380
what WebObjects gets back.

00:05:55.380 --> 00:05:57.980
WebObjects gets back commit messages.

00:05:57.980 --> 00:06:01.110
It gets back, it says,
beginning internal transaction,

00:06:01.110 --> 00:06:03.170
finishing internal transaction.

00:06:03.190 --> 00:06:05.000
It'll tell you how
many rows it gets back.

00:06:05.000 --> 00:06:07.680
It'll tell you when it's committed
changes to your database.

00:06:10.410 --> 00:06:12.640
So before we get started
measuring and testing,

00:06:12.660 --> 00:06:14.130
we need to come up with
a test environment.

00:06:14.140 --> 00:06:18.790
So you want to have your test environment
mirror your deployment environment.

00:06:18.800 --> 00:06:23.270
If your deployment environment is
two Sun Enterprise 10,000s with 64

00:06:23.270 --> 00:06:27.660
processors and 4 terabytes of RAM,
you don't want to make your test

00:06:27.660 --> 00:06:30.770
system an old G3 that you found
in the back closet with about

00:06:30.820 --> 00:06:34.470
32 megabytes of RAM running
something completely different.

00:06:34.480 --> 00:06:36.780
You want to go for the
same operating system.

00:06:36.780 --> 00:06:39.370
If you're deploying on Solaris,
test on Solaris.

00:06:39.500 --> 00:06:42.520
If you're deploying on Mac OS X,
test on Mac OS X.

00:06:42.520 --> 00:06:46.290
Don't switch and modify and change
your environment in midstream.

00:06:46.300 --> 00:06:50.130
You want to attempt to mirror
the number and kinds of servers.

00:06:50.140 --> 00:06:53.290
Now, this is something that is
a little difficult to do,

00:06:53.580 --> 00:06:56.360
especially for really
large-scale deployments.

00:06:56.360 --> 00:06:59.110
If you've got a half a million
dollars worth of big iron you're

00:06:59.110 --> 00:07:02.040
running your deployment on,
you obviously can't afford

00:07:02.100 --> 00:07:04.100
that for your test environment.

00:07:04.520 --> 00:07:08.600
However, what you want to do is try and
mirror it as closely as possible.

00:07:08.700 --> 00:07:11.310
Try a particular scaled-down
test environment of your

00:07:11.310 --> 00:07:12.760
deployment environment.

00:07:14.120 --> 00:07:17.900
And lastly, you want to isolate the test
environment from your users.

00:07:17.900 --> 00:07:20.270
You don't want to have your
test environment running in

00:07:20.310 --> 00:07:23.700
the same segment of your LAN as
your production environment.

00:07:23.860 --> 00:07:25.930
You don't want them
sharing the same database,

00:07:25.940 --> 00:07:26.680
for example.

00:07:26.740 --> 00:07:29.750
And I've seen that happen where
a test environment uses the same

00:07:29.750 --> 00:07:31.910
database as the production environment.

00:07:31.910 --> 00:07:36.200
You're not going to get,
you have so many variables

00:07:36.240 --> 00:07:38.250
other than what you're testing,
you're not going to get any

00:07:38.250 --> 00:07:38.250
conclusive results at all.

00:07:43.790 --> 00:07:45.900
Now,
so we've got our test environment set up.

00:07:45.990 --> 00:07:48.600
We've gone out and bought more hardware.

00:07:48.600 --> 00:07:51.530
Now we're going to determine
what pages are important.

00:07:51.540 --> 00:07:54.820
You have an application with 20, 30, 40,
100 pages.

00:07:54.820 --> 00:07:55.930
Make a list of the pages.

00:07:56.000 --> 00:07:59.420
What pages are going to be frequented
every time someone comes into the app?

00:08:00.220 --> 00:08:03.860
For example, your main page,
that's something you should work at

00:08:03.860 --> 00:08:07.860
to make blisteringly fast because
first impressions are paramount.

00:08:07.870 --> 00:08:10.120
When a user comes in and they
see your application's front

00:08:10.170 --> 00:08:12.230
page takes half a minute to load,
no matter how fast the

00:08:12.320 --> 00:08:14.240
rest of the app is,
they're still going to be left

00:08:14.240 --> 00:08:17.230
with that initial thought like,
God, I got here and it took me half

00:08:17.280 --> 00:08:18.750
an hour to get to the front page.

00:08:20.960 --> 00:08:23.090
Establish acceptance criteria.

00:08:23.090 --> 00:08:27.480
What you want to do is decide
what is acceptable and acceptable

00:08:27.480 --> 00:08:28.590
speed for my application.

00:08:28.590 --> 00:08:31.730
If you decide that you want every
page to return in half a second,

00:08:32.060 --> 00:08:33.810
well, then work to meet that goal.

00:08:33.810 --> 00:08:36.410
If you want every page to return
in a minute and your users will put

00:08:36.410 --> 00:08:39.760
up with that and not go elsewhere,
well, then that's a goal to work for too.

00:08:40.610 --> 00:08:42.980
You might want to work
on a big query page.

00:08:42.980 --> 00:08:46.950
Say you have a query page that returns
thousands of objects or raw roads,

00:08:46.960 --> 00:08:48.310
as we'll discuss later on.

00:08:48.310 --> 00:08:50.400
Maybe that should return in five seconds.

00:08:50.600 --> 00:08:55.350
There are certain cases where
a longer wait is acceptable.

00:08:55.620 --> 00:08:58.500
Decide how many users you
want to support concurrently.

00:08:58.520 --> 00:09:02.240
Is this application a small data
entry app for a small company

00:09:02.530 --> 00:09:06.670
where you're going to have 20 or
30 people working on it a week?

00:09:06.720 --> 00:09:09.620
Or is it a large online store or
an online presence where you're

00:09:09.620 --> 00:09:12.860
going to have hundreds of users
hitting the app at the same time?

00:09:12.900 --> 00:09:16.170
Determine what you want to test for.

00:09:16.990 --> 00:09:20.490
Next, create test cases which
exercise the important pages.

00:09:20.600 --> 00:09:23.860
Chris is going to give us a little
demo of using Woe Playback and then

00:09:23.860 --> 00:09:27.460
checking with Woe Stats and Woe
Events to see the speed of certain pages.

00:09:27.490 --> 00:09:31.650
So you might want to create specific
isolated cases for certain pages

00:09:31.750 --> 00:09:33.790
that are critical to your app.

00:09:35.820 --> 00:09:41.580
Okay, now we're going to talk about
preparing your test cases.

00:09:41.580 --> 00:09:41.580
Enabling recording for your application.

00:09:42.280 --> 00:09:44.360
The Woe Recording Path.

00:09:44.360 --> 00:09:47.750
So if you have your application,
you've finished your feature complete,

00:09:47.900 --> 00:09:49.720
you're ready to do a
little bit of optimization,

00:09:49.720 --> 00:09:52.720
you set the command line argument,
Woe Recording Path,

00:09:52.720 --> 00:09:53.910
you set it to a directory.

00:09:53.910 --> 00:09:57.640
In our case,
we use temp slash foo dot rec.

00:09:57.730 --> 00:10:01.770
This is our directory where the
WebObjects Application will write

00:10:01.880 --> 00:10:05.190
out a series of transactions,
requests and response,

00:10:05.460 --> 00:10:07.650
which records your visiting the app.

00:10:08.440 --> 00:10:10.180
Manually execute a test case.

00:10:10.180 --> 00:10:12.830
Set up that variable,
set up that NSUserDefault

00:10:12.960 --> 00:10:15.940
in your application,
launch the application,

00:10:16.350 --> 00:10:19.140
execute the test case,
stop the application.

00:10:19.140 --> 00:10:24.710
Now you can repeat this with different
directories for each test case.

00:10:24.720 --> 00:10:28.230
You can point the Woe Recording Path at
different directories and say this test

00:10:28.230 --> 00:10:30.070
case is going to test the big fetch page.

00:10:30.070 --> 00:10:31.900
This is going to test the main page.

00:10:31.950 --> 00:10:35.520
This is going to test a simulated
user walking through the application,

00:10:35.520 --> 00:10:38.410
finding something and then going
back to another part to purchase.

00:10:38.440 --> 00:10:40.630
purchase something, for example.

00:10:42.550 --> 00:10:45.540
Now, when you run your test cases,
so now that we've enabled

00:10:45.720 --> 00:10:47.720
that user default,
we're going to pull that

00:10:47.770 --> 00:10:49.840
off of the command line,
and we're going to run the app

00:10:49.870 --> 00:10:51.720
like we would run it in deployment.

00:10:51.750 --> 00:10:55.020
Now, there's certain defaults that you're
going to want to enable or disable

00:10:55.310 --> 00:10:57.940
when you deploy your application.

00:10:58.090 --> 00:11:00.860
First is Woe Caching Enabled.

00:11:01.600 --> 00:11:05.330
Woe Caching Enabled,
which defaults to No,

00:11:05.330 --> 00:11:09.290
is what allows you to do rapid
development on your application.

00:11:09.290 --> 00:11:13.440
It allows you to make changes to
your .wad and your .html files,

00:11:13.440 --> 00:11:17.000
save them, and reload them in your
browser and see it immediately.

00:11:17.000 --> 00:11:20.030
By setting this to Yes,
WebObjects knows that it's safe to

00:11:20.030 --> 00:11:22.000
cache these templates in memory.

00:11:22.000 --> 00:11:24.350
So you'll get a small hit the
first time WebObjects reads

00:11:24.400 --> 00:11:26.990
the templates off the disk,
but it will cache them next time

00:11:27.040 --> 00:11:31.060
it will just follow a pointer,
a reference.

00:11:31.060 --> 00:11:32.320
I'm sorry.

00:11:32.320 --> 00:11:36.310
In memory to retrieve that information.

00:11:36.460 --> 00:11:38.150
Woe debugging enabled.

00:11:38.170 --> 00:11:40.740
You want to set that to no, especially,
most especially,

00:11:40.740 --> 00:11:43.680
if you use woeapplication.debugstring.

00:11:43.810 --> 00:11:44.900
That's a great method to use.

00:11:44.900 --> 00:11:48.410
You can put tons of debugging print
statements in your application,

00:11:48.450 --> 00:11:49.900
which you'll see in your console.

00:11:49.940 --> 00:11:52.550
And then when you deploy,
kick this over to no

00:11:52.620 --> 00:11:54.000
and go your merry way.

00:11:54.030 --> 00:11:55.160
You won't see any of those.

00:11:55.160 --> 00:11:56.970
You'll still see log strings.

00:11:57.020 --> 00:12:00.910
You'll still see printlns and whatnot,
but it'll turn those off for you.

00:12:01.090 --> 00:12:03.420
Last but not least,
and it's something that I want to

00:12:03.490 --> 00:12:08.000
say with a little bit of a caveat,
is Woe allows current request handling.

00:12:08.180 --> 00:12:10.400
That defaults to No.

00:12:10.550 --> 00:12:12.560
Now what this enables,
if you turn this on,

00:12:12.560 --> 00:12:14.850
is multi-threading in your application.

00:12:14.910 --> 00:12:19.100
This can provide a dramatic speed up,
but I strongly,

00:12:19.220 --> 00:12:22.700
strongly encourage you to be familiar
with the caveats of multi-threaded

00:12:22.700 --> 00:12:24.430
programming before you turn this on.

00:12:24.460 --> 00:12:27.810
In my experience,
multi-threading bugs are extremely

00:12:27.810 --> 00:12:30.360
difficult to track down and,
believe me,

00:12:30.370 --> 00:12:34.900
it's something that you don't want to end
up working with if you're not familiar

00:12:35.060 --> 00:12:37.600
with multi-threading programming.

00:12:39.380 --> 00:12:42.850
So now that we've got all that set up,
we're going to disable the recording,

00:12:43.000 --> 00:12:45.720
start more than one instance if
you're looking at a large deployment,

00:12:45.860 --> 00:12:47.810
start one instance if you're
looking at a small deployment,

00:12:47.810 --> 00:12:49.360
whatever your test environment is.

00:12:49.360 --> 00:12:52.740
Run the playback,
run one playback concurrently, two,

00:12:52.990 --> 00:12:55.260
run one at a time, run them serially.

00:12:55.260 --> 00:12:58.000
Let the system achieve steady state.

00:12:58.240 --> 00:13:00.160
Now this is very important.

00:13:00.710 --> 00:13:04.970
You have to remember that
your application contains

00:13:04.970 --> 00:13:07.590
methods that start and stop.

00:13:07.670 --> 00:13:12.260
A new session is created and it lives
for a certain period of time and dies.

00:13:12.420 --> 00:13:15.700
The session death and birth are
something that's very important

00:13:15.700 --> 00:13:19.910
to your application because your
application is going to run all day,

00:13:19.910 --> 00:13:21.010
24/7.

00:13:21.400 --> 00:13:25.170
So what you want to do is let it reach
a point where sessions are expiring

00:13:25.170 --> 00:13:27.350
and new sessions are being created.

00:13:27.360 --> 00:13:31.790
So it will create a sort of a steady,
receive a sort of a steady state.

00:13:34.200 --> 00:13:36.280
So we've run our application,
we've done our playback,

00:13:36.360 --> 00:13:38.290
we've been recording,
we've done our playback.

00:13:38.290 --> 00:13:42.080
Now we're going to take a look and
see what kind of information we can

00:13:42.080 --> 00:13:44.050
find out about this application.

00:13:44.170 --> 00:13:47.360
First we're going to look
at a couple of pages.

00:13:47.460 --> 00:13:50.290
We have Woe Stats and Woe Events set up.

00:13:50.630 --> 00:13:52.280
Now, these are direct actions.

00:13:52.420 --> 00:13:54.880
They are out of the box now, disabled.

00:13:54.880 --> 00:13:57.750
You need to set a password
for them to use them at all,

00:13:57.800 --> 00:13:59.240
which we've done in our sample app.

00:13:59.300 --> 00:14:02.400
And the Woe Stats is something
you can just go to at any

00:14:02.400 --> 00:14:05.580
point after you've hit the app,
and it's going to give you this

00:14:05.580 --> 00:14:08.820
aggregate data that's collected about
your application on a component level.

00:14:08.820 --> 00:14:11.580
Now, a component, as we know,
can be as big as a page,

00:14:11.580 --> 00:14:12.950
as small as a character.

00:14:12.960 --> 00:14:15.840
So, it'll give you information
on all of those.

00:14:15.840 --> 00:14:19.180
You might want to pay
attention to the page ones.

00:14:19.210 --> 00:14:21.260
You might want to pay attention
to a certain subcomponent

00:14:21.260 --> 00:14:22.400
that's taking a lot of time.

00:14:24.290 --> 00:14:25.390
Configure event recording.

00:14:25.390 --> 00:14:27.790
Now, event recording is something
you need to go in and turn on.

00:14:27.790 --> 00:14:30.200
There's several different
buttons you can set to say,

00:14:30.200 --> 00:14:33.050
these are the kind of events I want
you to gather information about.

00:14:33.070 --> 00:14:37.920
WebObjects can amass an incredible
amount of events in a second.

00:14:37.920 --> 00:14:39.620
I don't even remember what the number is.

00:14:39.620 --> 00:14:41.860
Maybe NQ and one of the guys
from engineering can say.

00:14:41.860 --> 00:14:46.820
But it's blisteringly fast and has
very little effect on your application.

00:14:47.500 --> 00:14:51.090
So, you go to World Events Setup, say,
tell me what these events are,

00:14:51.090 --> 00:14:53.730
do your playback,
and then you can come back and look

00:14:53.750 --> 00:14:57.310
at the World Event Display page to
see sub-transaction times all the way

00:14:57.570 --> 00:14:59.470
down to the method granular level.

00:14:59.480 --> 00:15:01.970
Now,
for those of you who have been around

00:15:01.970 --> 00:15:06.480
doing WebObjects work since the old
days when we used that other language,

00:15:06.490 --> 00:15:10.000
anyway, there were tools available
for you called gprof,

00:15:10.110 --> 00:15:10.760
gmon.

00:15:10.760 --> 00:15:12.930
You'd have to build your
app in profile mode.

00:15:13.030 --> 00:15:14.770
You'd have to run your application.

00:15:14.820 --> 00:15:16.780
You'd have to quit your application.

00:15:16.780 --> 00:15:17.480
You'd have to run it through.

00:15:17.480 --> 00:15:18.090
You'd have to run another program.

00:15:18.100 --> 00:15:20.240
And you'd get this really nice
information that told you about this.

00:15:20.240 --> 00:15:22.940
Well, that's really great,
but that's something that

00:15:22.940 --> 00:15:24.280
you had to prepare for.

00:15:24.280 --> 00:15:25.090
You had to sit down.

00:15:25.100 --> 00:15:26.200
It was very time consuming.

00:15:26.200 --> 00:15:28.400
This is something that
happens on the fly,

00:15:28.400 --> 00:15:30.160
in the product, out of the box.

00:15:32.730 --> 00:15:34.400
So we've done that.

00:15:34.420 --> 00:15:38.600
Now we can use WoeStats to find the pages
that don't meet our acceptance criteria.

00:15:38.600 --> 00:15:40.590
Maybe we found a page
that takes 10 seconds.

00:15:40.670 --> 00:15:42.050
Well, let's look into why.

00:15:42.060 --> 00:15:43.820
What's taking so long on that page?

00:15:43.820 --> 00:15:45.700
Is it a method that's very expensive?

00:15:45.700 --> 00:15:47.170
Is it a fetch to the database?

00:15:47.170 --> 00:15:49.280
Is it a multiple fetch to the database?

00:15:50.320 --> 00:15:51.780
Well, event display,
after you find out what

00:15:51.850 --> 00:15:54.040
pages are giving you trouble,
can tell you what methods on

00:15:54.040 --> 00:15:55.480
that page are giving you trouble.

00:15:55.480 --> 00:15:58.470
Who's taking the most
time in your application?

00:15:58.470 --> 00:16:01.090
You can evaluate,
and you should evaluate the times

00:16:01.140 --> 00:16:04.350
relative to the total time that
your application is running.

00:16:04.350 --> 00:16:07.150
Pay attention to what is used the most.

00:16:07.150 --> 00:16:10.520
If you have a page that's hit once
a day in the corner and it's really

00:16:10.580 --> 00:16:14.110
expensive and it takes 20 minutes,
you might not want to dedicate

00:16:14.110 --> 00:16:15.880
resources to fixing that page.

00:16:15.920 --> 00:16:19.080
You may instead want to
dedicate resources to making

00:16:19.100 --> 00:16:20.120
the front page faster.

00:16:20.140 --> 00:16:23.540
or the query that everyone does.

00:16:24.420 --> 00:16:27.100
Now I'm going to ask Chris Mine,
senior consulting engineer

00:16:27.100 --> 00:16:31.430
with Apple Eye Services,
to come up and give us a demo about

00:16:31.430 --> 00:16:34.530
using wall recording and playback.

00:16:34.530 --> 00:16:34.530
Chris?

00:16:42.840 --> 00:16:43.910
So we need the guest one.

00:16:43.960 --> 00:16:49.640
Thanks.

00:16:49.690 --> 00:16:51.640
So we're going to skip
the recording portion,

00:16:51.670 --> 00:16:53.610
because we did that earlier.

00:16:53.760 --> 00:16:56.240
But just to show you what
that looks like as a result,

00:16:56.240 --> 00:16:59.160
use the whole recording path.

00:16:59.160 --> 00:17:01.740
And we created this--

00:17:02.330 --> 00:17:06.240
As a result of going through our
application in a typical usage fashion,

00:17:06.240 --> 00:17:07.300
we ended up with this recording.

00:17:07.300 --> 00:17:09.340
And inside here are a number of files.

00:17:09.340 --> 00:17:12.050
You can see the request and
response is making up transactions.

00:17:12.080 --> 00:17:16.530
So this only has eight transactions,
or excuse me, nine transactions in it.

00:17:16.560 --> 00:17:20.530
And then we'll just look at one
of the contents of one of these.

00:17:23.730 --> 00:17:28.910
You may be able to tell from that
that it's a typical HTTP request.

00:17:29.140 --> 00:17:33.510
It's just recording the request that came
in from the browser that the app got,

00:17:33.510 --> 00:17:36.890
and then afterwards it records
the response it sends out.

00:17:36.940 --> 00:17:45.350
So that should look a
lot like an HTML page.

00:17:53.680 --> 00:17:57.940
So then I've already got
this application running.

00:17:57.940 --> 00:18:00.250
Actually, it's this one here.

00:18:05.620 --> 00:18:07.830
And then from a command line,
I'm just going to start up

00:18:08.050 --> 00:18:10.800
our playback where it's going
to read from that directory,

00:18:10.860 --> 00:18:13.980
send each of the requests
to the application,

00:18:13.980 --> 00:18:18.710
and then compare the result with
what it gets back this time.

00:18:22.300 --> 00:18:26.440
So we can see up here that it's going
along doing some logging to show you

00:18:26.440 --> 00:18:27.540
that it's actually hitting the app.

00:18:27.620 --> 00:18:30.100
In this case,
we only have one playback going,

00:18:30.100 --> 00:18:32.950
and we have only one
application instance.

00:18:33.540 --> 00:18:36.740
And down here,
you can see some of the results and the

00:18:36.740 --> 00:18:38.150
information that's coming back for us.

00:18:38.180 --> 00:18:41.650
So you can see it's got
perhaps the requests.

00:18:41.700 --> 00:18:46.180
It'll go through zero through eight,
and then it starts over.

00:18:46.180 --> 00:18:47.840
So the next one will be a new session.

00:18:47.840 --> 00:18:50.800
So each time it gets to
the initial request again,

00:18:50.800 --> 00:18:53.600
that's going to the main page again,
and that's starting a new session.

00:18:53.600 --> 00:18:57.190
And then you can see
the transaction times.

00:19:03.260 --> 00:19:05.200
Let me stop that for a second.

00:19:05.200 --> 00:19:08.090
Over here,
this is the comparison of the bytes

00:19:08.090 --> 00:19:11.140
that it expected to get versus the
bytes that it actually did get.

00:19:11.180 --> 00:19:14.690
So that can, in some respects,
you can tell if there's a

00:19:14.690 --> 00:19:18.150
real problem with your app,
maybe a defect of sorts.

00:19:18.230 --> 00:19:20.750
If it's returning back
something wildly different,

00:19:20.750 --> 00:19:23.310
that might well be an error page,
something dramatically

00:19:23.310 --> 00:19:24.600
different than what it expected.

00:19:24.600 --> 00:19:29.370
So let me start that running
again and go have a look at

00:19:29.460 --> 00:19:35.510
the... well stats information.

00:19:41.790 --> 00:19:44.900
So we got the login page
as mentioned before.

00:19:44.900 --> 00:19:46.630
By default, this will come up.

00:19:46.740 --> 00:19:49.360
If you haven't set up your app
to allow you to log in here,

00:19:49.360 --> 00:19:49.950
you can't.

00:19:49.950 --> 00:19:52.710
There isn't a command
line option for that.

00:19:52.740 --> 00:19:55.840
It's kind of a security feature.

00:19:57.590 --> 00:19:59.120
And there's a lot of
information in this page.

00:19:59.120 --> 00:20:02.740
We're only interested
today in part of it.

00:20:02.870 --> 00:20:04.570
So I'll just go down to that bit.

00:20:04.660 --> 00:20:07.590
This happens to be, you can see here,
there's two major sections.

00:20:07.590 --> 00:20:11.120
There's component action
statistics and the direct actions.

00:20:11.120 --> 00:20:13.060
As you can see,
there are no component actions,

00:20:13.060 --> 00:20:15.990
and that's because this app relies
exclusively on direct actions.

00:20:20.120 --> 00:20:22.130
We see here on the left the page names.

00:20:22.170 --> 00:20:27.860
It doesn't give you anything that's
at a subpage level in this view.

00:20:29.160 --> 00:20:35.620
And then I'd like to point out these
minimum and maximum times over here.

00:20:35.660 --> 00:20:38.600
You can see that it's not
terribly obvious on this hardware

00:20:38.600 --> 00:20:41.030
because it's ripping fast,
but on my laptop it showed a

00:20:41.030 --> 00:20:45.000
dramatically different value
for the max and for the min.

00:20:45.000 --> 00:20:48.010
I mean, this one's still pretty large,
but it just goes to show

00:20:48.010 --> 00:20:51.090
that maybe on the first hit,
first time you hit the

00:20:51.210 --> 00:20:54.080
main direct action,
the default direct action,

00:20:54.080 --> 00:20:56.850
it might take a lot longer
for something to happen,

00:20:57.040 --> 00:21:00.490
but then over time, this average is going
to go lower and lower.

00:21:01.970 --> 00:21:06.950
And you can see there the
0.01 versus the half a second.

00:21:16.360 --> 00:21:21.540
So another thing we should
be able to see in here,

00:21:21.540 --> 00:21:24.600
what we just saw there is that
our session timeout is very short.

00:21:24.610 --> 00:21:31.460
I think we set it to about 15 seconds
just to demonstrate this other feature.

00:21:34.650 --> 00:21:37.980
which is the current active
sessions versus the maximum.

00:21:38.010 --> 00:21:43.360
So here we have 163 sessions created.

00:21:44.070 --> 00:21:46.590
But our current active
session is only 68.

00:21:46.700 --> 00:21:49.400
It's likely to stay
at 68 for a long time.

00:21:49.420 --> 00:21:52.180
It might fluctuate, go up or down one.

00:21:52.180 --> 00:21:55.830
But it shows this app's essentially
being driven at a steady state.

00:21:56.350 --> 00:21:58.580
Which is essentially what we want,
because otherwise information

00:21:58.580 --> 00:22:01.800
we get about CPU usage and
information we get about RAM usage

00:22:01.800 --> 00:22:03.300
would be pretty much irrelevant.

00:22:03.300 --> 00:22:09.860
So now go on to the WoEvent display.

00:22:15.180 --> 00:22:19.180
So here's the event logging
that Fitz referred to.

00:22:19.180 --> 00:22:22.010
We're just going to look
at component events.

00:22:27.640 --> 00:22:30.140
Then once you set up what
events you're interested in,

00:22:30.150 --> 00:22:32.790
you can actually display those events.

00:22:32.800 --> 00:22:36.490
In this case,
we're going to just reset this.

00:22:41.150 --> 00:22:44.500
To get a fresh view.

00:22:44.620 --> 00:22:47.040
So our playback is still running,
so this information is

00:22:47.040 --> 00:22:49.160
still getting updated.

00:22:50.930 --> 00:22:53.120
And you can see that for
the component events,

00:22:53.180 --> 00:22:56.800
there's the pages,
but it's also the subpage

00:22:56.800 --> 00:22:58.990
components as well.

00:23:00.250 --> 00:23:05.440
There's different sorting capabilities
to show these events in different ways.

00:23:05.570 --> 00:23:09.190
So we'll group them by page.

00:23:09.240 --> 00:23:11.520
Then we can see something like

00:23:14.300 --> 00:23:17.790
Oh, perhaps that the add movie page
takes what seems like an awful

00:23:17.790 --> 00:23:20.590
long time for the number of
calls relative to anything else.

00:23:20.620 --> 00:23:24.820
So if you were going to get
some sort of speed increase,

00:23:24.820 --> 00:23:27.370
you might look for something
in here on an app-wide basis.

00:23:27.380 --> 00:23:32.320
Something else that's worth noting
is that if these times per call

00:23:32.320 --> 00:23:35.920
are below what your criteria is,
then you're pretty much done.

00:23:35.920 --> 00:23:38.530
So this just tells you you don't
have any performance tuning to do,

00:23:38.570 --> 00:23:40.830
which is pretty much the
case in this application.

00:23:43.510 --> 00:23:50.280
But you can drill down in
here and see where the cost of

00:23:50.280 --> 00:23:52.220
rendering a component comes from.

00:23:52.220 --> 00:23:57.000
So at the bottom of things we see the
WD footer costs pretty much nothing.

00:23:57.000 --> 00:24:00.880
So maybe I had to turn my attention to
the WD table element if I were going to

00:24:00.880 --> 00:24:03.450
look for a place to pick up some speed.

00:24:12.840 --> 00:24:13.870
Okay, and that's it.

00:24:35.650 --> 00:24:38.140
Now we're going to,
and now we've talked about

00:24:38.140 --> 00:24:40.590
ways of measuring your
performance of your application,

00:24:40.600 --> 00:24:45.220
we're going to talk about techniques for
improving the speed of your application,

00:24:45.220 --> 00:24:48.940
techniques specific to WebObjects
and the Enterprise Object Framework.

00:24:50.530 --> 00:24:52.800
Now, maybe we could review this week.

00:24:52.800 --> 00:24:55.920
We talked about there were two
enterprise object adapters available.

00:24:55.930 --> 00:24:59.820
There were the JDBC adapter
and the-- anyone else remember?

00:24:59.820 --> 00:25:01.680
The NUN adapter.

00:25:01.680 --> 00:25:04.980
Now, the NUN adapter is extremely fast.

00:25:04.980 --> 00:25:07.620
There are absolutely zero
round trips to the database.

00:25:07.620 --> 00:25:11.820
And however, it's not quite as useful
as the JDBC adapter.

00:25:12.130 --> 00:25:15.070
We want to reduce trips to the database.

00:25:15.860 --> 00:25:19.980
EOF writes, as I said before,
the SQL and sends it to the database,

00:25:19.980 --> 00:25:23.150
and the database sends back, well, data.

00:25:23.820 --> 00:25:29.410
Sometimes,
EOF will ask for the database for

00:25:29.410 --> 00:25:31.750
data in a not so intelligent manner,
we might say.

00:25:31.760 --> 00:25:34.860
It might repeatedly ask the database
for little bits of data that it could

00:25:35.110 --> 00:25:36.660
have just asked for all at once.

00:25:36.660 --> 00:25:39.640
So to find out where
these problems exist,

00:25:39.660 --> 00:25:43.380
we turn on the user default,
EOAdapterDebugEnable.

00:25:43.650 --> 00:25:46.920
Now for those of you who use print
statements in your application to

00:25:46.920 --> 00:25:54.500
see what some value of something is,
where some sort of value changes,

00:25:54.500 --> 00:25:57.070
or where you are currently
in the request response loop,

00:25:57.240 --> 00:25:59.660
you'll see a number of print
statements go by on your console.

00:25:59.660 --> 00:26:01.700
When you turn on
EO Adapt or Debug Enabled,

00:26:01.700 --> 00:26:04.100
you are going to see more
stuff on your console than

00:26:04.100 --> 00:26:05.810
you ever knew what to do with.

00:26:05.860 --> 00:26:09.390
You're going to see when
EO F first logs into your database.

00:26:09.400 --> 00:26:11.590
You're going to see every
round trip thereafter.

00:26:12.010 --> 00:26:15.530
tons and tons and tons of
fun things to look through.

00:26:16.420 --> 00:26:18.870
Now, when you look at this
information that UF tells you,

00:26:18.870 --> 00:26:22.040
perhaps you'll see that there's
multiple round trips for your database

00:26:22.040 --> 00:26:25.110
for one request response loop.

00:26:25.140 --> 00:26:28.980
Maybe you're fetching, for our example,
those of you who are familiar

00:26:28.980 --> 00:26:32.830
with the movies database,
I'm not creative enough to come up with

00:26:32.850 --> 00:26:35.380
election results and stuff like that.

00:26:35.380 --> 00:26:36.900
So I grab the movie database.

00:26:36.930 --> 00:26:37.370
It ships.

00:26:37.410 --> 00:26:39.180
It's in the Java business logic examples.

00:26:39.180 --> 00:26:40.820
It's tried and it's true.

00:26:42.200 --> 00:26:45.740
When I fetch movies,
and then perhaps I navigate some

00:26:45.750 --> 00:26:49.010
of these faults one at a time,
as each fault fires,

00:26:49.020 --> 00:26:51.580
it might make a separate
trip to the database.

00:26:51.580 --> 00:26:54.530
And it's extremely inefficient because
we all know that each round trip to

00:26:54.530 --> 00:26:56.140
the database is pretty expensive.

00:26:56.140 --> 00:26:58.270
So we're going to talk about
ways that you can optimize that.

00:26:58.320 --> 00:27:00.880
One is to use batch faulting.

00:27:00.900 --> 00:27:03.640
Tell EOF that when you
fire off one fault,

00:27:03.690 --> 00:27:05.550
go get a whole bunch more.

00:27:05.560 --> 00:27:08.230
We're going to use prefetching.

00:27:08.280 --> 00:27:12.180
Tell EOF, when you fetch these entities,
I want you to fetch these entities.

00:27:12.180 --> 00:27:14.220
relationships at the same
time just because we're going

00:27:14.220 --> 00:27:15.130
to be using it pretty soon.

00:27:17.310 --> 00:27:19.120
We could use a shared editing context.

00:27:19.130 --> 00:27:20.980
This was a recent addition
to WebObjects last year.

00:27:20.980 --> 00:27:22.430
Fantastic.

00:27:22.720 --> 00:27:24.900
People were already doing this,
putting an editing context in their

00:27:24.900 --> 00:27:26.030
application and talking to it.

00:27:26.040 --> 00:27:29.300
This is a really intelligent editing
context that has relations to each

00:27:29.300 --> 00:27:30.970
editing context in the session.

00:27:30.980 --> 00:27:34.210
You could put reference data
into the shared editing context,

00:27:34.210 --> 00:27:37.940
fetch it when your application starts up,
and never fetch it again.

00:27:37.940 --> 00:27:41.440
Or, well, there's a little detail on
that I won't go into right now,

00:27:41.440 --> 00:27:43.820
but it will refresh your data eventually.

00:27:44.570 --> 00:27:46.740
So if you have a WoW pop-up
containing all the cities

00:27:46.750 --> 00:27:50.610
that your company may service,
or a WoW pop-up containing something like

00:27:50.630 --> 00:27:54.450
all the products in your product line,
and something that doesn't change

00:27:54.450 --> 00:27:57.180
or changes very infrequently,
it might be a great candidate

00:27:57.180 --> 00:27:58.660
for shared editing context.

00:27:58.660 --> 00:28:00.490
Make your app read-only.

00:28:00.590 --> 00:28:02.490
This is extremely fast.

00:28:02.490 --> 00:28:07.680
If you have an application, a scenario,
for example, where you have a back-office

00:28:07.680 --> 00:28:11.490
application where users enter data,
where they change data,

00:28:11.490 --> 00:28:14.320
where they delete data,
and then a front-end application.

00:28:14.460 --> 00:28:16.280
You can actually go ahead and put
everything in the shared editing context.

00:28:16.300 --> 00:28:18.180
And your application will rarely have
to go back to the database for anything.

00:28:18.180 --> 00:28:19.470
Not only is it extremely fast,
but it's extremely memory

00:28:19.570 --> 00:28:21.440
efficient because you don't
have all these duplicate copies.

00:28:21.440 --> 00:28:26.120
Remember,
each editing context that contains an

00:28:26.120 --> 00:28:30.000
object has another copy of that object.

00:28:30.000 --> 00:28:33.200
For very good reason, mind you.

00:28:33.200 --> 00:28:38.150
But when there's situations
where you can avoid that,

00:28:38.320 --> 00:28:41.430
you certainly would want to.

00:28:41.460 --> 00:28:44.260
Last, you want to avoid heraldry.

00:28:44.460 --> 00:28:46.450
You want to avoid recurring
fetches of reference data.

00:28:46.460 --> 00:28:49.460
Certainly, the shared editing context
takes care of that for us.

00:28:49.460 --> 00:28:52.500
Another thing we can do is
reduce the amount of data

00:28:52.520 --> 00:28:54.600
that we get from the database.

00:28:54.820 --> 00:28:58.700
You can use raw rows for non-object
data and very large fetches.

00:28:58.800 --> 00:29:02.700
Raw rows are, as you'll see,
they're a big speed improvement

00:29:02.700 --> 00:29:09.780
on just a standard fetch,
because they fetch the information

00:29:09.780 --> 00:29:12.700
into EOF just as always.

00:29:12.700 --> 00:29:14.070
The information is
fetched in the database,

00:29:14.070 --> 00:29:17.040
columns and rows, put into a dictionary,
but instead of taking the next step

00:29:17.100 --> 00:29:20.180
and creating your enterprise objects,
objects with the business

00:29:20.240 --> 00:29:23.700
logic built into them,
you just get this raw data.

00:29:23.700 --> 00:29:25.700
Just straight attributes.

00:29:25.850 --> 00:29:28.700
There's occasions where it's
very convenient to have that.

00:29:29.430 --> 00:29:32.740
Use fetch limits or don't
allow unrestricted searches.

00:29:32.930 --> 00:29:34.780
Now,
I have to say right now that my favorite

00:29:34.780 --> 00:29:36.330
search engine out there is Google.

00:29:36.420 --> 00:29:39.780
You know, you go to that,
I find obscure error messages,

00:29:39.780 --> 00:29:41.570
I type the error message into Google,
and it comes back with a

00:29:41.600 --> 00:29:42.900
page with the answer on it,
you know?

00:29:42.900 --> 00:29:44.340
I mean, who, anybody else does this?

00:29:44.480 --> 00:29:44.870
Anyone else?

00:29:44.900 --> 00:29:47.940
Cough or something, you know?

00:29:47.940 --> 00:29:49.690
Is anybody still awake out there?

00:29:49.730 --> 00:29:51.300
My goodness.

00:29:51.460 --> 00:29:53.290
Shouldn't have eaten those big lunches.

00:29:53.300 --> 00:29:56.050
It only gives you,
you can search for the word

00:29:56.120 --> 00:29:58.500
"apple" and you'll get hundreds
of thousands of responses.

00:29:58.500 --> 00:30:02.500
It'll say, "Found four bajillion pages."
And it's only going to show you 200.

00:30:02.500 --> 00:30:05.940
Encourages you, as a user,
to refine your search.

00:30:06.100 --> 00:30:09.940
Maybe you want to look for "apple
computer." "Apple computer G4."

00:30:09.940 --> 00:30:12.680
"Apple computer G4 with a cinema
display." Maybe I'll optimize

00:30:12.680 --> 00:30:13.940
your programming experience.

00:30:13.940 --> 00:30:16.970
Um...

00:30:17.850 --> 00:30:19.640
Don't allow unrestricted searches.

00:30:19.700 --> 00:30:23.600
Make the user enter
some sort of criteria.

00:30:23.600 --> 00:30:24.800
Now this isn't always necessary.

00:30:24.800 --> 00:30:28.010
If you have a company with 50 employees
and they have search on last name,

00:30:28.010 --> 00:30:30.150
search on first name, sure,
let them hit return,

00:30:30.160 --> 00:30:33.520
let them get all 50 employees and
surf around to the heart's content.

00:30:33.520 --> 00:30:37.580
If you work for a big company
that has 200,000 employees,

00:30:37.580 --> 00:30:39.250
this might not work so well.

00:30:39.250 --> 00:30:43.220
An unrestricted search might allow
them to fetch your whole database,

00:30:43.220 --> 00:30:47.040
at which point your DBA is going
to come hunt you down and kill you.

00:30:47.800 --> 00:30:51.140
And then you're also going to
run a memory in your machine.

00:30:52.720 --> 00:30:56.060
So now, I'm going to go ahead and give
you a little demo of some of

00:30:56.060 --> 00:30:59.670
the things that we did here.

00:30:59.830 --> 00:31:01.340
So, let's see.

00:31:01.340 --> 00:31:04.620
We should have two different
screens coming up shortly.

00:31:08.940 --> 00:31:12.560
Now those of you who have been to
the WebObjects sessions this week,

00:31:12.670 --> 00:31:14.900
you guys have probably seen
some really cool demos,

00:31:14.900 --> 00:31:15.790
some really cool graphics.

00:31:15.790 --> 00:31:19.560
You saw XM Elementary, you know,
we got movie mechanics.

00:31:19.560 --> 00:31:22.990
You know, I have to confess,
when I finished writing this

00:31:22.990 --> 00:31:27.170
demo yesterday at about 11.30,
it looked like, you know,

00:31:27.260 --> 00:31:30.550
W3C Consortium around like 1994,
you know,

00:31:30.550 --> 00:31:33.220
gray background with the big HRs across.

00:31:33.220 --> 00:31:35.800
We handed all this stuff
over to Matt Furlick.

00:31:35.800 --> 00:31:38.440
A lot of you know Matt Furlick,
who really made this stuff look great.

00:31:38.440 --> 00:31:40.540
Let's hear it for Matt.

00:31:45.500 --> 00:31:49.310
Okay, so what I have here is an
application called Moving Mechanics,

00:31:49.310 --> 00:31:51.400
which I've already cranked up
and done some fun stuff with.

00:31:51.470 --> 00:31:53.140
So I'm going to stop it for starters.

00:31:54.580 --> 00:31:56.490
And, yeah, I didn't even mean that.

00:31:56.500 --> 00:31:59.640
And now we're going to
start the application again.

00:31:59.640 --> 00:32:03.240
And when it decides to start up here,
there it goes.

00:32:04.780 --> 00:32:06.880
We have a couple of different
defaults that I've set up in here.

00:32:06.880 --> 00:32:10.220
In fact, I could probably still go ahead
and take a look at this thing here.

00:32:10.220 --> 00:32:10.740
Let's see.

00:32:10.740 --> 00:32:11.670
Optimization.

00:32:11.720 --> 00:32:14.300
Did I click that right?

00:32:14.300 --> 00:32:15.520
Optimization targets.

00:32:15.520 --> 00:32:17.170
Yeah.

00:32:20.900 --> 00:32:22.590
Anyone?

00:32:22.670 --> 00:32:23.700
Resize?

00:32:23.710 --> 00:32:25.730
Oh, it's way down here hiding, right?

00:32:25.800 --> 00:32:27.490
There we go.

00:32:30.510 --> 00:32:35.110
Okay, you'll see I have EO Adaptive
Debug enabled to yes.

00:32:35.190 --> 00:32:37.660
I've got it set to WOL port
1729 because I'm hitting it

00:32:37.660 --> 00:32:38.640
from this machine over here.

00:32:38.790 --> 00:32:40.400
And then WOL auto open in browser.

00:32:40.430 --> 00:32:43.240
No, I'm not a big fan of the
auto open in browser thing.

00:32:43.240 --> 00:32:46.520
So let's go back to where we were.

00:32:46.950 --> 00:32:52.050
So the application is launched here and
you'll see it says welcome application.

00:32:52.050 --> 00:32:54.460
It gives you this URL and
some other information.

00:32:54.520 --> 00:32:57.470
And the first thing it tells you
here is connecting with dictionary.

00:32:57.480 --> 00:32:58.100
Okay?

00:32:58.100 --> 00:32:59.690
It's connected to our database.

00:32:59.710 --> 00:33:02.500
It began an internal transaction,
fetched five rows.

00:33:02.500 --> 00:33:03.020
Okay?

00:33:03.020 --> 00:33:07.490
Now the first example we're going to
do here is our shared editing context.

00:33:07.580 --> 00:33:08.100
Ah ha.

00:33:08.100 --> 00:33:09.480
See it showed me.

00:33:09.480 --> 00:33:12.080
Shared editing context example.

00:33:12.330 --> 00:33:12.650
Okay?

00:33:12.730 --> 00:33:14.590
We're going to take a shared
editing context using objects

00:33:14.590 --> 00:33:16.780
from a shared editing context
versus a shared editing context.

00:33:16.800 --> 00:33:18.530
Versus using objects that
we're just going to straight

00:33:18.530 --> 00:33:19.480
fetch from the database.

00:33:19.500 --> 00:33:22.020
So as you see we have those five objects.

00:33:22.070 --> 00:33:26.160
So when I click on this, alright,
you notice up here, no change.

00:33:28.100 --> 00:34:25.100
[Transcript missing]

00:34:25.390 --> 00:34:26.760
Let's talk about what these do.

00:34:26.790 --> 00:34:28.540
The shared editing context.

00:34:28.540 --> 00:34:31.380
Fetch is the data at the
beginning of your application

00:34:31.480 --> 00:34:32.540
when your application starts.

00:34:32.540 --> 00:34:33.840
No round trip to the database.

00:34:33.840 --> 00:34:35.360
It's way fast.

00:34:35.360 --> 00:34:37.190
And it's great for reference data.

00:34:37.200 --> 00:34:39.990
The regular fetch is just a
plain old fetch and it requires,

00:34:39.990 --> 00:34:42.210
at the least,
a round trip to the database.

00:34:42.220 --> 00:34:45.360
And as you can see, there's a lot faster.

00:34:45.360 --> 00:34:50.260
Shared editing context, again,
this is basically following a reference.

00:34:50.280 --> 00:34:52.770
And the regular fetch
talks to the database.

00:34:53.440 --> 00:34:55.280
So now we'll move on to something
a little more interesting,

00:34:55.280 --> 00:34:57.300
batch fetching and pre-faulting.

00:34:58.560 --> 00:35:01.230
So let me see,
can I see a clap or make a noise?

00:35:01.310 --> 00:35:04.190
Who's used the batch fetching
and pre-faulting here?

00:35:04.700 --> 00:35:06.470
That's faulting and prefetching.

00:35:06.470 --> 00:35:10.650
Okay, so we're going to have some people
who already know the answer to this,

00:35:10.670 --> 00:35:10.980
right?

00:35:10.980 --> 00:35:13.140
So we have three ways
of getting this data.

00:35:13.140 --> 00:35:14.200
We do a regular fetch.

00:35:14.200 --> 00:35:17.640
Now, the way this component works
is I'm fetching all movies

00:35:17.640 --> 00:35:20.400
out of the movies database,
all 88 of them,

00:35:20.400 --> 00:35:25.620
and then I'm iterating through the movies
and I'm touching the roles relationship.

00:35:25.620 --> 00:35:27.060
Each movie has a role.

00:35:27.060 --> 00:35:29.400
Indiana Jones, for example,
has Harrison Ford,

00:35:29.400 --> 00:35:32.480
has the role of Indiana Jones and
the role of Marion and whatnot.

00:35:32.480 --> 00:35:34.500
I'm triggering that fault.

00:35:34.700 --> 00:35:35.790
For each movie.

00:35:35.850 --> 00:35:38.740
So iterating, triggering those faults.

00:35:38.870 --> 00:35:41.230
Now, we have a regular fetch,
which it just goes through,

00:35:41.240 --> 00:35:43.310
does the fetch and then
triggers those faults.

00:35:43.310 --> 00:35:48.190
We have batch faulting on,
which sets the batch faulting

00:35:48.190 --> 00:35:51.660
on the roles relationship to 25.

00:35:51.660 --> 00:35:56.730
So what that tells EOF is that when
you fetch these bunch of movies,

00:35:57.520 --> 00:35:59.920
And you navigate to this
particular relationship,

00:35:59.920 --> 00:36:02.560
go ahead and get some extra
stuff while you're there.

00:36:02.560 --> 00:36:04.980
You know,
you run into the grocery to pick up milk,

00:36:05.050 --> 00:36:08.390
pick up some butter, you know,
is it a stick of butter, a loaf of milk,

00:36:08.390 --> 00:36:10.090
a loaf of bread and a gallon of milk?

00:36:10.120 --> 00:36:12.850
Pick up some other stuff while
you're there because it's

00:36:12.850 --> 00:36:14.480
likely we're going to need this.

00:36:14.500 --> 00:36:18.060
And last but not least, pre-fetching,
which is a very particular thing,

00:36:18.230 --> 00:36:21.220
which says when we fetch the movies,
I want you to pre-fetch these

00:36:21.220 --> 00:36:23.800
certain attributes of the
movies while you're there.

00:36:24.150 --> 00:36:24.320
Okay?

00:36:24.320 --> 00:36:26.570
So, we have these three things.

00:36:26.690 --> 00:36:28.720
Regular fetch, batch faulting,
pre-fetching.

00:36:28.720 --> 00:36:30.280
Who thinks the regular fetch
is going to be fastest?

00:36:30.280 --> 00:36:31.720
Anyone?

00:36:31.720 --> 00:36:33.740
Thanks, Mark.

00:36:33.780 --> 00:36:36.790
Who thinks batch faulting
is going to be the fastest?

00:36:36.790 --> 00:36:37.960
Come on, it's a little racier.

00:36:37.960 --> 00:36:38.960
Anyone think batch faulting?

00:36:38.960 --> 00:36:40.540
You all know that
pre-fetching is at the bottom,

00:36:40.540 --> 00:36:41.660
so it's the fastest, right?

00:36:41.660 --> 00:36:43.610
All right, who thinks pre-fetch is
going to be the fastest?

00:36:43.610 --> 00:36:45.620
All right, all right.

00:36:45.620 --> 00:36:48.560
Okay,
so let's see what's going to happen here.

00:36:49.420 --> 00:36:49.940
Regular fetch.

00:36:49.970 --> 00:36:50.480
Look at that.

00:36:50.580 --> 00:36:51.790
Oh, my God, would you look at that.

00:36:51.790 --> 00:36:57.380
Every one of those big lines that begin,
from begin internal transaction,

00:36:57.400 --> 00:36:59.360
to commit internal transaction.

00:36:59.390 --> 00:37:00.400
It's a round trip to the database.

00:37:00.400 --> 00:37:02.960
Now, man, I can't even,
that was a lot of round

00:37:02.960 --> 00:37:03.780
trips to the database.

00:37:03.780 --> 00:37:04.150
Look at that.

00:37:06.030 --> 00:37:06.940
88 to be precise.

00:37:06.940 --> 00:37:09.230
Let's find out how long that took.

00:37:09.320 --> 00:37:11.840
That took 7.04 seconds.

00:37:11.840 --> 00:37:14.760
Now mind you,
on my laptop this takes like 20 seconds.

00:37:14.780 --> 00:37:16.420
Batch faulting.

00:37:16.640 --> 00:37:16.920
Look at that.

00:37:17.000 --> 00:37:18.150
Look at that.

00:37:19.730 --> 00:37:23.330
Now, we saw a good number of
transactions go by here,

00:37:23.340 --> 00:37:24.560
but they're a little different looking.

00:37:24.560 --> 00:37:25.840
Right there.

00:37:25.840 --> 00:37:28.360
You see here,
this is some information I put in here.

00:37:28.360 --> 00:37:29.410
Whoa, whoa, it's still going.

00:37:29.410 --> 00:37:30.150
What's it doing now?

00:37:31.720 --> 00:37:33.480
Hello.

00:37:33.510 --> 00:37:35.480
Someone telling me to do this machine?

00:37:35.530 --> 00:37:41.000
Anyway, let's see what that comes out to.

00:37:47.980 --> 00:37:48.220
Okay.

00:37:48.220 --> 00:37:54.930
So anyway, here we have this transaction
here that fetches...

00:37:55.600 --> 00:37:57.840
In this case, 84 rows.

00:37:57.840 --> 00:38:00.240
It fetches,
it has a big or select statement.

00:38:00.240 --> 00:38:04.980
Select the role where the movie
ID is this or this or this or this.

00:38:04.980 --> 00:38:09.020
So it comes back with a whole bunch more
of these relationships on the first shot.

00:38:09.050 --> 00:38:10.280
Pre-fetching.

00:38:10.360 --> 00:38:10.960
Boom.

00:38:11.030 --> 00:38:12.550
Right back at you.

00:38:12.550 --> 00:38:14.170
How many fetches was that?

00:38:14.370 --> 00:38:14.600
Two.

00:38:14.600 --> 00:38:16.430
Now look at the difference from that.

00:38:16.480 --> 00:38:18.760
A regular fetch where you're faulting,
you're doing multiple round

00:38:18.760 --> 00:38:19.600
trips to the database.

00:38:19.600 --> 00:38:21.370
Many, many,
many round trips to the database.

00:38:21.370 --> 00:38:22.220
Seven seconds here.

00:38:22.220 --> 00:38:25.580
2.23 seconds for batch faulting
and 0.5 seconds for batch faulting.

00:38:25.640 --> 00:38:27.510
52 seconds for pre-fetching.

00:38:27.510 --> 00:38:30.790
Now, here's something that's
interesting about this.

00:38:30.820 --> 00:38:33.490
Some people out there might be saying,
well, geez,

00:38:33.530 --> 00:38:37.200
of course the first one's slowest
because then you fetched it all in.

00:38:37.200 --> 00:38:39.900
In sleep, in this component,
I'm invalidating all objects

00:38:39.990 --> 00:38:42.580
in my editing context,
which pretty much wipes everything

00:38:42.580 --> 00:38:45.200
clean and makes the EOF do
everything all over again.

00:38:45.210 --> 00:38:49.320
So we'll try this again just to show you
that there's nothing funny going on here.

00:38:49.320 --> 00:38:51.950
It's actually going to the
database again each time.

00:38:51.950 --> 00:38:55.580
It's going to be a little faster because
certain things are cached and happy.

00:38:55.610 --> 00:38:57.290
and what not.

00:38:58.010 --> 00:39:00.660
So, batch fetching,
2.40 seconds this time,

00:39:00.660 --> 00:39:04.910
and last but not least, the prefetching,
39 seconds, 0.39 seconds.

00:39:04.920 --> 00:39:06.920
Let's talk a little more about them.

00:39:07.380 --> 00:39:09.270
Regular fetch,
one round tip to the database

00:39:09.400 --> 00:39:10.760
for each fault fired.

00:39:10.760 --> 00:39:13.500
It can be extremely inefficient, very,
very time consuming.

00:39:13.500 --> 00:39:17.440
Batch faulting, it's defining the
relationship in question.

00:39:17.440 --> 00:39:19.910
Now, this is the difference between
batch faulting and prefetching.

00:39:19.940 --> 00:39:23.110
Batch faulting,
you can define that programmatically

00:39:23.110 --> 00:39:25.330
or in EOModeler per relationship.

00:39:25.870 --> 00:39:28.680
You define it once in EOModeler,
and your applications use your model,

00:39:28.680 --> 00:39:30.560
and they just go their merry way,
and it just happens.

00:39:30.580 --> 00:39:33.670
To many relationships only,
you can't do batch faulting

00:39:33.670 --> 00:39:35.340
on a 2-1 relationship.

00:39:36.860 --> 00:39:39.830
This fetches, again, the next n objects
whenever a fault is fired.

00:39:39.880 --> 00:39:42.230
So, for example, in this demo,
we set batch faulting across

00:39:42.230 --> 00:39:43.790
the roles relationship to 25.

00:39:43.880 --> 00:39:46.880
So, it fetches one,
it faults in one relationship,

00:39:46.890 --> 00:39:48.700
and it gets the next 25.

00:39:48.700 --> 00:39:50.010
Last is prefetching.

00:39:50.120 --> 00:39:54.120
It's used on a fetch specification,
so you have to consciously go in

00:39:54.120 --> 00:39:58.660
when you create a new fetch and say,
I want you to prefetch these things.

00:39:59.240 --> 00:40:02.300
When you get the movie,
I want you to prefetch the director,

00:40:02.300 --> 00:40:04.230
and I want you to prefetch the roles.

00:40:04.230 --> 00:40:08.210
Or, and you can prefetch
multiple relationships.

00:40:08.270 --> 00:40:13.090
It adds only one round trip to
your original fetch and it's very,

00:40:13.090 --> 00:40:14.200
very fast.

00:40:14.210 --> 00:40:15.200
So enough of that.

00:40:15.200 --> 00:40:17.790
We'll move on to probably
another one of my favorites,

00:40:17.810 --> 00:40:19.200
raw rows.

00:40:19.200 --> 00:40:23.200
Now, raw rows and objects.

00:40:23.200 --> 00:40:24.200
I just kind of blew it.

00:40:24.200 --> 00:40:25.200
I hit the button already.

00:40:25.220 --> 00:40:28.200
So what I'm selecting here are all
the movie rolls in the database.

00:40:28.200 --> 00:40:30.190
I wanted something with more data.

00:40:30.200 --> 00:40:33.200
Obviously, I don't have that much
data in this database.

00:40:33.200 --> 00:40:36.470
The difference is seemingly small
when you have a small amount of data,

00:40:36.870 --> 00:40:41.150
but when you have a lot of data,
the difference is really, really big.

00:40:41.530 --> 00:40:44.400
So, I just fetched the raw rows,
inadvertently,

00:40:44.490 --> 00:40:46.320
and let's take a look and see
what the time was on that.

00:40:46.360 --> 00:40:47.530
.08 seconds.

00:40:47.560 --> 00:40:50.290
Now, I'm going to fetch objects.

00:40:50.360 --> 00:40:53.400
Now, raw rows fetches rows
out of the database,

00:40:53.400 --> 00:40:54.660
every column in the row.

00:40:54.660 --> 00:40:56.700
In this case,
I'm fetching every column in the row.

00:40:56.700 --> 00:40:59.840
You can write SQL and only
fetch certain columns,

00:40:59.840 --> 00:41:00.140
if you wish.

00:41:00.140 --> 00:41:03.550
You can fetch the primary key
and maybe the title of something.

00:41:03.550 --> 00:41:05.400
But in this case,
I've fetched everything.

00:41:05.400 --> 00:41:08.390
It gave me back a bunch of dictionaries.

00:41:08.770 --> 00:41:12.050
Objects, I fetched the information
from the database.

00:41:12.170 --> 00:41:15.690
You get all attributes for each object,
and they're wrapped

00:41:15.690 --> 00:41:17.640
in Enterprise Objects,
and boom,

00:41:17.640 --> 00:41:18.940
you have your Enterprise Objects.

00:41:18.940 --> 00:41:21.340
So, let's see how fast that goes.

00:41:21.340 --> 00:41:22.940
.13 seconds.

00:41:22.940 --> 00:41:26.840
Now, we'll click it a couple times here
to sort of let things normalize

00:41:26.840 --> 00:41:28.340
out and see what the difference is.

00:41:28.490 --> 00:41:30.400
The difference, it depends.

00:41:30.400 --> 00:41:34.400
You'll see different speeds,
but in the most part,

00:41:34.400 --> 00:41:35.390
it tends to come up.

00:41:35.400 --> 00:41:35.400
.3 seconds.

00:41:35.410 --> 00:41:39.400
So, about 50% or so of speed improvement.

00:41:39.400 --> 00:41:42.900
If you tweak out your raw row fetch,
you can see a really,

00:41:42.900 --> 00:41:44.400
really huge improvement.

00:41:44.400 --> 00:41:47.350
Now, there is a fantastic,
fantastic article that I used

00:41:47.370 --> 00:41:50.900
for reference on this on Stepwise
written by Malcolm Crawford,

00:41:50.900 --> 00:41:54.730
and I think he's sitting right there,
that tells you in great, great detail.

00:41:54.910 --> 00:41:56.100
Thank you, Malcolm.

00:41:56.100 --> 00:41:58.190
Yeah, there you go.

00:41:58.190 --> 00:41:58.190
There you go.

00:41:59.240 --> 00:42:01.130
Malcolm, as we all know,
has done a number of

00:42:01.140 --> 00:42:02.360
good services this week.

00:42:02.830 --> 00:42:06.360
Let's talk a little more...

00:42:07.090 --> 00:42:08.700
Let's talk a little more
about what these do.

00:42:08.740 --> 00:42:09.720
Raw rows.

00:42:10.000 --> 00:42:11.800
Raw rows don't instantiate
enterprise objects.

00:42:11.800 --> 00:42:13.190
You just get back dictionaries.

00:42:13.260 --> 00:42:14.200
Key value.

00:42:14.220 --> 00:42:15.610
Title, Indiana Jones.

00:42:15.760 --> 00:42:16.870
Director, George Lucas.

00:42:16.880 --> 00:42:18.390
It was Lucas, wasn't it?

00:42:18.530 --> 00:42:19.480
Music, John Williams.

00:42:19.480 --> 00:42:20.630
OK.

00:42:20.710 --> 00:42:21.880
It's very fast.

00:42:21.890 --> 00:42:23.960
Doesn't have to select all columns.

00:42:23.960 --> 00:42:26.240
Objects is just a plain old fetch.

00:42:26.250 --> 00:42:28.340
It creates objects for
all the EOs it fetches.

00:42:28.540 --> 00:42:30.500
And it can be slow for
very large fetches,

00:42:30.500 --> 00:42:34.260
especially when you're dealing
with tens of thousands of objects.

00:42:34.470 --> 00:42:37.750
I'm not going to take a look
at WoEvents setup right now,

00:42:37.750 --> 00:42:40.600
but I will really quickly see if
I can hit on WoEstats and see what

00:42:40.640 --> 00:42:43.300
it tells me about this application
of mine that I was running.

00:42:43.300 --> 00:42:47.400
Okay, so here we are.

00:42:47.400 --> 00:42:51.250
We have Be Nice and Share,
which is my little shared editing

00:42:51.670 --> 00:42:53.800
context demo with an average time.

00:42:53.800 --> 00:42:56.760
That's basically pretty fast because
even the non-shared part is only

00:42:56.760 --> 00:42:58.220
fetching a little bit of data.

00:42:59.990 --> 00:43:01.720
There's the venerable main.

00:43:02.080 --> 00:43:03.840
RoundTrips.

00:43:03.910 --> 00:43:05.970
RoundTrips is where we did the
different kinds of fetching,

00:43:05.970 --> 00:43:07.410
batch faulting, and prefetching.

00:43:07.420 --> 00:43:08.260
Look at that.

00:43:08.260 --> 00:43:09.590
The max is 7.2.

00:43:09.620 --> 00:43:10.170
You see that?

00:43:10.250 --> 00:43:12.890
That was the roundtrip where
we went and batched and we

00:43:12.890 --> 00:43:14.450
single faulted everything in.

00:43:14.460 --> 00:43:17.100
And last but not least, RawRows,
which was basically

00:43:17.530 --> 00:43:20.900
pretty fast because again,
we're just fetching the object.

00:43:20.960 --> 00:43:24.160
A single fetch, as you can see,
we fetched 450 rolls.

00:43:24.160 --> 00:43:26.060
Still, that was very fast.

00:43:26.060 --> 00:43:27.460
Let me just kick something over here.

00:43:27.460 --> 00:43:29.720
And so it was very fast
because we just fetched.

00:43:29.750 --> 00:43:31.720
I did one roundtrip to the database.

00:43:31.720 --> 00:43:34.690
So that's about it.

00:43:34.760 --> 00:43:36.710
Let's get back to the slides now.

00:43:36.720 --> 00:43:39.100
Thank you.

00:43:44.520 --> 00:43:46.500
Okay.

00:43:46.500 --> 00:43:47.880
You know,
I had to get a Star Trek joke in,

00:43:47.890 --> 00:43:52.640
but I'm not a big Star Trek Voyager fan,
you know, so I went with the classic,

00:43:52.640 --> 00:43:53.840
right?

00:43:55.240 --> 00:44:00.240
Lazy instantiation.

00:44:00.250 --> 00:44:06.220
I took a programming
WebObjects 2 class at Apple.

00:44:06.220 --> 00:44:07.740
In fact, I took programming WebObjects 1.

00:44:07.740 --> 00:44:10.980
But programming WebObjects 2
was taught by Kai Christensen.

00:44:10.980 --> 00:44:12.830
It was an absolutely fantastic teacher.

00:44:12.840 --> 00:44:13.860
Anyone had Kai for a teacher?

00:44:13.860 --> 00:44:15.890
Thank you.

00:44:16.300 --> 00:44:17.420
It was the greatest class.

00:44:17.420 --> 00:44:18.670
I didn't fall asleep once.

00:44:19.110 --> 00:44:22.980
Kai said something to me that
just absolutely killed me.

00:44:22.980 --> 00:44:26.020
He said, when you're programming,
he says,

00:44:26.020 --> 00:44:30.820
you want to cook your steak until
it's smoking and then 10 seconds less.

00:44:30.820 --> 00:44:33.660
And I said, Kai,
what the hell does that mean?

00:44:33.700 --> 00:44:39.100
He said, you want to wait to the absolute
last second to do something.

00:44:39.100 --> 00:44:42.150
If you don't have to do it,
don't do it because it may turn out,

00:44:42.150 --> 00:44:44.250
you know, 20 feet away from here.

00:44:44.440 --> 00:44:45.580
You don't have to do it.

00:44:45.940 --> 00:44:47.040
Use lazy instantiation.

00:44:47.040 --> 00:44:48.460
This is an example here.

00:44:48.460 --> 00:44:51.100
We have Shatner's ego,
which is going to take a long time

00:44:51.100 --> 00:44:53.540
to get because it's really big,
as we all know.

00:44:53.540 --> 00:44:56.810
So the first time it's called,
it checks this private

00:44:56.810 --> 00:44:59.550
instance variable to say,
is this null?

00:44:59.580 --> 00:45:03.210
If it's null, it goes ahead, fetches it,
squirrels it away in the

00:45:03.210 --> 00:45:06.220
instance variable for the next
time someone comes through,

00:45:06.220 --> 00:45:07.180
and then returns it.

00:45:07.280 --> 00:45:08.750
Huge bonus.

00:45:08.800 --> 00:45:10.300
It's a great little trick to use.

00:45:10.300 --> 00:45:13.850
Back to EOF stuff.

00:45:13.920 --> 00:45:15.810
Subclass EO generic records.

00:45:15.820 --> 00:45:16.970
Instead of EO custom object.

00:45:17.000 --> 00:45:21.520
EO generic record has a couple of
little tweaks to the key value code

00:45:21.520 --> 00:45:25.010
and the way it stores the information
for the attributes of your EO.

00:45:25.020 --> 00:45:28.540
It's blisteringly fast,
especially in WebObjects 5.

00:45:28.540 --> 00:45:31.040
It's absolutely incredible
what they've done with this.

00:45:32.720 --> 00:45:33.250
Don't overwrite.

00:45:33.300 --> 00:45:36.020
Now, another thing that Eogeneric
Record does as well is,

00:45:36.130 --> 00:45:42.410
by default, deferred faulting is enabled.

00:45:42.420 --> 00:45:47.440
Now, let's say we fetch a movie,
and it has several attributes.

00:45:47.450 --> 00:45:49.660
It has role, it has a link to director.

00:45:49.660 --> 00:45:53.070
What we used to do in the old days,
back in the 1990s,

00:45:53.070 --> 00:45:56.450
we used to create a fault for
each one of these attributes.

00:45:56.480 --> 00:45:59.770
Now, if a movie,
let's say it has 10 possible faults,

00:45:59.770 --> 00:46:02.340
and we fetch 1,000 movies, okay?

00:46:02.600 --> 00:46:06.560
So, we've just had to create 1,000 movie
objects plus 10,000 fault objects.

00:46:06.580 --> 00:46:11.980
Now, the Eogeneric Record, by default,
creates one shared fault for

00:46:11.980 --> 00:46:14.380
all these different faults.

00:46:16.120 --> 00:46:17.640
That's an incredible speed-up
because you don't have to create

00:46:17.640 --> 00:46:19.740
all these additional objects,
even though the fault objects were small.

00:46:19.760 --> 00:46:22.550
Next, and this one seemed a
little bit obvious to you,

00:46:22.550 --> 00:46:24.980
but I've seen some people
do some weird stuff.

00:46:24.980 --> 00:46:26.580
Don't override value for key.

00:46:26.580 --> 00:46:28.940
Key value coding,
one of my greatest friends

00:46:28.940 --> 00:46:31.970
in the WebObjects framework,
patented key value coding,

00:46:31.980 --> 00:46:35.420
as we all know, and we know that software
patents are evil as well.

00:46:35.570 --> 00:46:36.900
Don't override that.

00:46:38.500 --> 00:46:41.440
Value for key and take value
for key are called incredibly

00:46:41.440 --> 00:46:44.400
often in enterprise objects,
in your woke components,

00:46:44.400 --> 00:46:46.920
and they're optimized to
be as fast as possible,

00:46:46.920 --> 00:46:49.220
something you don't want to override.

00:46:49.220 --> 00:46:51.510
Certainly, if you're debugging and you
want to put something in there,

00:46:51.510 --> 00:46:53.090
print statement,
but make sure you rip that whole

00:46:53.090 --> 00:46:54.190
thing out when you're done.

00:46:56.200 --> 00:47:14.800
[Transcript missing]

00:47:14.990 --> 00:47:16.840
This is one of the things
that really blew my mind when

00:47:16.840 --> 00:47:18.310
someone explained it to me.

00:47:18.310 --> 00:47:20.900
They said, when you synchronize,
when you go through the

00:47:20.900 --> 00:47:23.400
request response loop,
if you put a simple string in your page,

00:47:23.400 --> 00:47:24.780
it's going to print out
the title of a movie.

00:47:24.800 --> 00:47:27.470
Or something,
or you have your own subcomponent,

00:47:27.490 --> 00:47:31.490
let's say it's a custom subcomponent
that takes in a name or something.

00:47:31.490 --> 00:47:36.780
We all know the request response loop,
big fans of the request response loop,

00:47:36.780 --> 00:47:37.470
Awake.

00:47:37.850 --> 00:47:41.650
Take values from request, invoke action,
append to response, and sleep.

00:47:42.160 --> 00:47:45.240
Those three middle ones--
take values from request,

00:47:45.290 --> 00:47:47.300
invoke action,
append to response-- there's

00:47:47.300 --> 00:47:48.460
a lot of stuff going on there.

00:47:48.460 --> 00:47:51.150
And one of the things that goes
on in those three methods are

00:47:51.150 --> 00:47:55.420
variable synchronization from
parent component to child component.

00:47:55.440 --> 00:47:58.640
What that means is that
take values gets called,

00:47:58.660 --> 00:47:59.650
boom, synchronize.

00:47:59.690 --> 00:48:02.420
Pass the value into the child component,
pull it back out.

00:48:02.470 --> 00:48:04.380
Do it again, invoke action, pass it in,
pull it out.

00:48:04.460 --> 00:48:07.040
Do it again, append to response,
pass it in, pull it out.

00:48:08.220 --> 00:48:10.350
That's like six method calls there.

00:48:10.410 --> 00:48:12.500
If you have a subcomponent
that you're using everywhere,

00:48:12.500 --> 00:48:15.180
say a button bar component that
just has some buttons on it that

00:48:15.190 --> 00:48:17.560
you want to pull some information
down from the parent for,

00:48:17.560 --> 00:48:20.470
say it's just a footer,
and we'll talk about a way of even

00:48:20.470 --> 00:48:23.600
making that footer faster in a moment,
and you just need a little bit

00:48:23.600 --> 00:48:26.910
of information from the page,
you might want to say, look,

00:48:26.910 --> 00:48:29.940
WebObjects don't synchronize
these variables for me,

00:48:29.940 --> 00:48:32.710
but instead I'm going to
take care of it myself.

00:48:32.720 --> 00:48:36.100
And then in the appropriate method
of the three above that I mentioned,

00:48:36.190 --> 00:48:38.770
you can pull or push out
that value that you need.

00:48:40.420 --> 00:48:43.600
Now, if you want to talk even faster,
we can talk about using

00:48:43.600 --> 00:48:45.410
stateless components.

00:48:47.300 --> 00:48:49.710
Now, a stateless component,
whenever a component's instantiated,

00:48:49.720 --> 00:48:50.680
you get a new component.

00:48:50.680 --> 00:48:52.740
You say, you know, page with name, boom,
new component.

00:48:52.740 --> 00:48:55.430
You put a component into a page,
when that page gets instantiated,

00:48:55.430 --> 00:48:57.680
that subcomponent, boom,
gets instantiated.

00:48:57.680 --> 00:49:01.550
If you say that component's stateless,
WebObjects knows that this is

00:49:01.550 --> 00:49:04.680
a component that's not going
to change based on a session or

00:49:04.770 --> 00:49:06.930
based on something a user's done.

00:49:06.930 --> 00:49:08.300
It's a stateless component.

00:49:08.300 --> 00:49:12.100
It loads it up once and it reuses
it over and over and over again.

00:49:12.580 --> 00:49:16.830
So, if you have 700 users in your website
and you have that little footer that

00:49:16.850 --> 00:49:20.300
has the big legal disclaimer in it,
make that stateless and you don't

00:49:20.590 --> 00:49:22.660
have 700 of those lying around.

00:49:22.670 --> 00:49:23.610
You have one.

00:49:23.650 --> 00:49:26.650
Not only is it faster,
but you use less memory.

00:49:30.190 --> 00:49:32.870
Now, in the end here,
we've sort of thrown a couple

00:49:32.870 --> 00:49:36.310
little miscellaneous things,
some of which aren't necessarily

00:49:36.310 --> 00:49:37.460
related to WebObjects.

00:49:37.500 --> 00:49:40.490
But, session timeout.

00:49:40.590 --> 00:49:44.050
Chris showed you before we had our
session timeout set to 15 seconds.

00:49:44.130 --> 00:49:47.520
That's pretty extreme,
but you might want to see what

00:49:47.520 --> 00:49:49.990
the typical user experience
is in your application.

00:49:50.120 --> 00:49:54.090
When a session times out,
that memory is available to the garbage

00:49:54.090 --> 00:49:56.690
collector to be picked up eventually.

00:49:56.780 --> 00:49:59.210
So, that means that when
your session gets bigger,

00:49:59.210 --> 00:50:02.930
bigger, bigger,
it can squish it back down a little more.

00:50:03.050 --> 00:50:05.150
Fetch outside the request response loop.

00:50:05.160 --> 00:50:07.130
If a loser logs in,
then you need to get some

00:50:07.130 --> 00:50:09.420
database on that user,
but you don't need it right

00:50:09.420 --> 00:50:10.540
away in that first page.

00:50:10.840 --> 00:50:15.520
You might want to do a delayed action
to fetch that or to put it in sleep or

00:50:15.520 --> 00:50:20.560
somewhere safe to put it outside that
the user's not going to be waiting.

00:50:20.680 --> 00:50:24.370
Index your database.

00:50:24.370 --> 00:50:26.290
I'm a big fan of getting
someone else to do this for me.

00:50:26.500 --> 00:50:29.210
You can notice a marked improvement,
especially if you're just using

00:50:29.550 --> 00:50:33.010
single attribute primary keys,
which is what we all know and love

00:50:33.040 --> 00:50:34.260
with the Enterprise Objects Framework.

00:50:34.300 --> 00:50:37.720
Offload images and static
data to another server.

00:50:37.720 --> 00:50:39.600
If you've got an application
that's serving up,

00:50:39.600 --> 00:50:44.040
I just experienced this recently,
QuickTime VRs, 300, 400 kilobyte VRs,

00:50:44.040 --> 00:50:46.070
and you've got 200,000 of these things.

00:50:46.080 --> 00:50:50.420
Well, you don't want your same web server
that's serving up your web app

00:50:50.420 --> 00:50:52.500
to be serving up these images.

00:50:52.520 --> 00:50:54.580
You might want to have
an additional web server,

00:50:54.580 --> 00:50:55.970
vrs.yourcompany.com.

00:50:56.720 --> 00:50:58.600
images.yourcompany.com.

00:50:58.600 --> 00:51:03.160
Have that serve up the static images and
VRs and sound files and God knows what.

00:51:03.180 --> 00:51:05.100
Check your HTML.

00:51:06.850 --> 00:51:07.610
Check the HTML.

00:51:07.700 --> 00:51:11.780
This is, wow,
this is like really obvious to me now,

00:51:11.780 --> 00:51:13.240
but wasn't obvious to me at the time.

00:51:13.240 --> 00:51:16.090
I had a page that we designed for
this client of ours with all these

00:51:16.160 --> 00:51:19.140
nested tables and it looked just the
way they wanted it and I was like,

00:51:19.140 --> 00:51:20.920
oh, thank God that's over with.

00:51:20.950 --> 00:51:23.780
And then we hit the page and
it just took forever to render.

00:51:23.780 --> 00:51:24.670
It took forever.

00:51:24.780 --> 00:51:27.920
This was back in like years ago, 1999,
I think.

00:51:29.970 --> 00:51:30.600
Check the HTML.

00:51:30.600 --> 00:51:32.570
See if you can't optimize your HTML.

00:51:32.650 --> 00:51:34.540
See if it's actually compliant.

00:51:34.540 --> 00:51:36.840
Run HTML, run a linting program over it.

00:51:36.840 --> 00:51:38.500
Make sure it's valid HTML.

00:51:38.500 --> 00:51:40.440
Remove extraneous tables.

00:51:40.460 --> 00:51:42.550
Do as much as you can
with as little as you can.

00:51:42.560 --> 00:51:47.720
And last but not least, there's Java,
there's Java performance tuning

00:51:47.720 --> 00:51:50.160
things like OptimizeIt or JProbe.

00:51:50.330 --> 00:51:54.410
I believe OptimizeIt is
currently available on Mac OS X.

00:51:56.110 --> 00:51:58.150
Now lastly, but not least,
we'll talk a little bit

00:51:58.150 --> 00:51:59.430
about what we've learned.

00:51:59.430 --> 00:52:01.740
We talked about determining
where the bottlenecks lie.

00:52:01.740 --> 00:52:03.620
Measure, modify, measure.

00:52:03.620 --> 00:52:05.630
Remember, again,
in a controlled environment,

00:52:05.640 --> 00:52:06.790
change is only one thing.

00:52:06.800 --> 00:52:09.500
We talked about WebObjects
and EOF techniques.

00:52:09.550 --> 00:52:11.880
We have batch faulting, prefetching.

00:52:11.880 --> 00:52:15.520
We have synchronizing bindings,
not synchronizing bindings,

00:52:15.520 --> 00:52:18.320
stateless components, that sort of thing.

00:52:19.000 --> 00:52:21.310
General programming techniques,
lazy instantiation.

00:52:21.310 --> 00:52:23.290
Upgrade your hardware.

00:52:23.290 --> 00:52:24.530
Huge thing, right here.

00:52:24.600 --> 00:52:28.170
If you're running your application
and you're hitting swap in

00:52:28.170 --> 00:52:30.090
a deployment environment,
you're doomed.

00:52:30.110 --> 00:52:33.970
There's nothing that you can sit
down and optimize and improve that,

00:52:33.990 --> 00:52:36.700
the second that your
machines run out of RAM.

00:52:36.700 --> 00:52:39.590
And oftentimes,
you'll discover that hardware is a

00:52:39.590 --> 00:52:41.900
lot cheaper than developer manpower.

00:52:43.380 --> 00:52:49.180
So with that, I want to let you know
that if you hurry up,

00:52:49.220 --> 00:52:50.580
please don't run.

00:52:50.680 --> 00:52:53.540
The WebObjects lab is open for another
20 minutes downstairs in room K.

00:52:55.690 --> 00:52:58.950
The only session left for WebObjects
Track is the feedback forum,

00:52:58.950 --> 00:53:00.600
which is going to start at 3:30.

00:53:00.600 --> 00:53:04.580
And there's your contact information,
which I'm sure is all new to you.
WEBVTT

00:00:03.400 --> 00:00:07.560
I want to welcome you to Introduction
to Data Modeling and Connectivity.

00:00:07.560 --> 00:00:10.050
I'd like to introduce Steve Minehr.

00:00:16.710 --> 00:00:18.270
Good morning.

00:00:18.390 --> 00:00:19.180
Thank you for coming.

00:00:19.200 --> 00:00:21.060
My name's Steve Minear.

00:00:21.210 --> 00:00:23.900
I'm a WebObjects engineer.

00:00:23.950 --> 00:00:26.760
I don't have any songs for you today
like some of our other sessions,

00:00:26.860 --> 00:00:31.800
sorry about that,
but my mother is Canadian, if that helps.

00:00:34.950 --> 00:00:39.300
So, as an introduction,
we're going to talk about

00:00:39.330 --> 00:00:40.560
two major things today.

00:00:40.560 --> 00:00:45.780
First, using EOModeler to map relational
data into Java objects.

00:00:45.860 --> 00:00:49.130
And then secondly,
we'll be talking about the JDBC adapter,

00:00:49.130 --> 00:00:51.790
which is our main
adapter for WebObjects 5.

00:00:51.800 --> 00:00:54.650
So, before we get going,
can I ask how many people have used

00:00:54.650 --> 00:00:56.860
WebObjects and used EOModeler before?

00:00:56.860 --> 00:00:57.730
Can you raise your hand?

00:00:57.740 --> 00:00:59.860
Okay, so most of you have seen this.

00:00:59.970 --> 00:01:02.300
This is an introductory talk,
so there might not be

00:01:02.330 --> 00:01:03.520
that much new for you.

00:01:03.650 --> 00:01:05.800
If you need some extra coffee,
you can grab it now.

00:01:05.800 --> 00:01:08.520
Come back for the second half and
find out about the JDBC adapter,

00:01:08.600 --> 00:01:10.080
which is new for WebObjects 5.

00:01:13.680 --> 00:01:14.590
Okay, what you'll learn.

00:01:14.590 --> 00:01:17.550
We'll talk about, first of all, model,
what a model is,

00:01:17.650 --> 00:01:20.400
how it contains entities, attributes,
and relationships,

00:01:20.400 --> 00:01:23.920
and we'll explain how you
create those and what they mean.

00:01:23.920 --> 00:01:26.420
And we'll talk a bit about
fetch specifications,

00:01:26.440 --> 00:01:30.370
which is how you query the database,
pull objects into your application.

00:01:32.310 --> 00:01:37.000
We'll talk about entity inheritance,
how to model inheritance,

00:01:37.010 --> 00:01:39.160
some of the pros and cons
involved in inheritance.

00:01:39.160 --> 00:01:43.690
And finally,
we'll talk about the JDBC adapter.

00:01:46.900 --> 00:01:48.960
This slide,
if you went to the introduction

00:01:49.510 --> 00:01:53.180
to Enterprise Objects Framework,
this slide is supposed to encapsulate

00:01:53.180 --> 00:01:54.900
that whole hour in one slide.

00:01:54.900 --> 00:01:56.020
Okay?

00:01:56.020 --> 00:02:00.620
So at the top,
we have a database view of data.

00:02:00.620 --> 00:02:04.110
So that cylinder is a...

00:02:04.800 --> 00:02:10.970
tabular data we have rows and columns in
there so we're using Neo model to define

00:02:10.970 --> 00:02:17.470
how we translate from the tabular data in
the database into our object and that's

00:02:17.840 --> 00:02:23.950
matching up columns into attributes and
taking the rows and creating dictionaries

00:02:24.090 --> 00:02:28.500
first and then into real enterprise
objects so the what we're trying to

00:02:28.500 --> 00:02:32.380
suggest there is we have to do some
type coercion to go back and forth from

00:02:32.780 --> 00:02:37.220
the database native types into the proper
Java types and the types that we use

00:02:37.690 --> 00:02:43.500
in EOF and web objects and finally at
the end we get the EO and the EO is

00:02:43.500 --> 00:02:46.780
enterprise object is what you want to
interact with it'll be living in an

00:02:46.780 --> 00:02:50.910
editing context and for most web object
applications all you have to worry about

00:02:50.910 --> 00:02:55.280
is your EOs you're not too worried about
your database but we're talking about

00:02:55.410 --> 00:02:58.930
in this talk how we set up the model
to do this mapping so you don't have

00:02:58.930 --> 00:03:03.320
to think about it anymore once you're
once you're writing your application code

00:03:06.030 --> 00:03:07.840
So what is an EOModel?

00:03:07.850 --> 00:03:12.340
Well, it's, if you're familiar with
entity relationship diagrams,

00:03:12.390 --> 00:03:16.820
it's a tool that,
or a model is an object that

00:03:16.820 --> 00:03:17.890
does the mapping for you.

00:03:17.890 --> 00:03:23.900
It describes both the relational
data and the object that you want to

00:03:23.900 --> 00:03:25.940
transform that relational data into.

00:03:25.940 --> 00:03:30.070
We declare entities,
which does a mapping from a particular

00:03:30.470 --> 00:03:32.940
table into particular objects.

00:03:32.940 --> 00:03:37.280
The connection dictionary defines
how you make that connection

00:03:37.280 --> 00:03:38.940
to your particular datasource.

00:03:38.940 --> 00:03:41.940
And we'll talk more about what goes
in a connection dictionary later.

00:03:41.940 --> 00:03:45.940
Stored procedures are
also declared in a model.

00:03:45.940 --> 00:03:48.940
There are places where you can use
your database's stored procedure

00:03:48.940 --> 00:03:53.940
to fetch rows back from the
database and create EOs that way.

00:03:54.030 --> 00:03:55.940
Or sometimes you might
want to be doing deletions.

00:03:55.940 --> 00:03:58.500
So if you're using a special lead
or some special logic that's already

00:03:58.650 --> 00:04:02.320
been encapsulated in your database,
you need to use that because whoever

00:04:02.320 --> 00:04:07.750
controls the database doesn't want to
give you direct access to the tables.

00:04:07.970 --> 00:04:10.450
And finally,
we have named fetch specifications.

00:04:10.550 --> 00:04:14.590
So a model can contain
pre-built fetch specifications.

00:04:14.620 --> 00:04:18.490
And if you went to the
introduction to EOF talk,

00:04:18.660 --> 00:04:20.100
you learned more about
fetch specifications.

00:04:20.100 --> 00:04:23.720
We'll talk about how our
EOModeler tool can help you

00:04:23.830 --> 00:04:26.620
create those fetch specifications.

00:04:26.780 --> 00:04:28.930
You already know how to use them
if you went to the other talk,

00:04:28.950 --> 00:04:31.600
and we have a lot more information
in our documentation about

00:04:31.600 --> 00:04:33.810
using fetch specifications.

00:04:34.960 --> 00:04:37.380
All right,
so for our first demonstration,

00:04:37.380 --> 00:04:41.230
we're going to bring up Ernest Kim,
and he'll be running EOModeler just

00:04:41.230 --> 00:04:43.480
to give us a view of our sample data.

00:04:50.880 --> 00:04:54.560
So for this first view,
we're showing a diagram view.

00:04:54.560 --> 00:04:57.080
We'll get into more details
about EOModeler in a minute,

00:04:57.080 --> 00:05:00.130
but just give us something
concrete to talk about.

00:05:00.140 --> 00:05:03.440
We've created a very small database,
just a few entities and

00:05:03.440 --> 00:05:04.840
a few relationships.

00:05:04.840 --> 00:05:11.390
The idea here is we have a course entity,
which represents a course that

00:05:11.410 --> 00:05:12.440
someone's teaching in school.

00:05:12.440 --> 00:05:15.340
There's some professor who's
the instructor for that course,

00:05:15.340 --> 00:05:18.260
and then there are students
who are enrolled in the course.

00:05:19.040 --> 00:05:22.690
This diagram view is showing,
first of all, the different entities,

00:05:22.690 --> 00:05:24.950
which are in the boxes,
the attributes that

00:05:24.950 --> 00:05:27.510
belong to those entities,
and then the arrows are

00:05:27.510 --> 00:05:31.170
suggesting the relationships
between the different entities.

00:05:31.180 --> 00:05:33.540
There's a lot more you can
do in the diagram view.

00:05:33.590 --> 00:05:37.680
You can control which things are labeled,
which attributes are being viewed.

00:05:37.680 --> 00:05:41.050
There's different ways you can
filter this and save layouts.

00:05:41.120 --> 00:05:44.300
But for our purposes right now,
I think this gives you a general idea

00:05:44.420 --> 00:05:48.050
of what we're going to be talking about,
and when we do something concrete,

00:05:48.480 --> 00:05:51.910
you'll understand that we just
have a few entities involved.

00:05:52.140 --> 00:05:53.980
There's also some inheritance.

00:05:53.980 --> 00:06:00.780
This person is really an abstract
superclass or abstract entity

00:06:01.010 --> 00:06:03.280
that some of the other entities,
the student and professor,

00:06:03.300 --> 00:06:04.240
are going to inherit from.

00:06:04.240 --> 00:06:06.240
We just want to show you
that for inheritance.

00:06:06.240 --> 00:06:10.540
This might not be the way you design
your school administrative system,

00:06:10.540 --> 00:06:13.530
but it'll give you a suggestion
of what you can do in EOModeler.

00:06:13.540 --> 00:06:16.670
So what is an EO entity?

00:06:17.130 --> 00:06:21.090
Well, at the basic level,
we map a table into a class.

00:06:21.170 --> 00:06:26.650
So you have a database
with your rows and columns,

00:06:26.650 --> 00:06:27.860
and you have a Java class.

00:06:27.860 --> 00:06:33.300
You have to declare how you take
that raw data and turn it into an EO.

00:06:33.300 --> 00:06:36.030
Then EOF does all the work for you.

00:06:36.760 --> 00:06:41.730
So there are various aspects and
settings you can put on an EO entity.

00:06:41.990 --> 00:06:43.520
First, you can mark it abstract.

00:06:43.730 --> 00:06:46.870
Abstract means that you're never
going to actually instantiate

00:06:47.000 --> 00:06:48.110
an object of this class.

00:06:48.120 --> 00:06:50.730
It's just there principally
for inheritance.

00:06:50.740 --> 00:06:52.240
There can be a parent entity.

00:06:52.240 --> 00:06:55.940
Again, if you're using inheritance,
one entity can inherit from another.

00:06:56.050 --> 00:06:58.950
It'll get all the attributes
from the parent entity.

00:07:00.770 --> 00:07:07.820
The restricting qualifier allows you to
filter the rows from a particular table

00:07:08.200 --> 00:07:09.600
when you're fetching your entities.

00:07:09.760 --> 00:07:13.600
So we also use this when
we're modeling inheritance.

00:07:13.680 --> 00:07:17.700
Basically, instead of saying,
"My entities are every row in

00:07:17.700 --> 00:07:21.790
this table," we put some kind of
qualifier on that and it restricts

00:07:21.860 --> 00:07:23.630
it to a subset of those rows.

00:07:23.660 --> 00:07:27.060
We'll talk about that
during the demonstration.

00:07:27.540 --> 00:07:29.310
You can also mark an entity as read-only.

00:07:29.380 --> 00:07:32.610
Depending on your application,
that might speed things up a little bit.

00:07:32.670 --> 00:07:36.390
That means we'll never be
writing anything to that entity.

00:07:36.520 --> 00:07:39.700
It's really just there for some
kind of bookkeeping purposes.

00:07:39.700 --> 00:07:41.160
You've already pre-built everything.

00:07:41.160 --> 00:07:43.840
And you can cache an entity.

00:07:43.840 --> 00:07:46.720
That changes the behavior of
EOF a bit where we know we have

00:07:46.720 --> 00:07:48.580
everything in memory that we need.

00:07:48.580 --> 00:07:52.500
We can do searches in memory instead
of going to the database all the time.

00:07:52.820 --> 00:07:56.780
But the last two are used
just in special circumstances.

00:07:56.790 --> 00:08:00.700
In general, your entities will not be
read-only and won't be cached,

00:08:00.700 --> 00:08:04.020
and you'll be wanting to write
data back to the database.

00:08:07.190 --> 00:08:09.100
All right,
so let's go back and look at EOModeler

00:08:09.180 --> 00:08:13.260
and we'll take a closer look at entities.

00:08:13.400 --> 00:08:16.640
So this is the way we
typically open up EOModeler.

00:08:16.690 --> 00:08:21.110
The model name is at the
top left of the tree view.

00:08:21.280 --> 00:08:23.530
Then we have a list of
entities down below.

00:08:23.660 --> 00:08:28.360
Over to the right we have a table
which declares the entity names,

00:08:28.390 --> 00:08:31.350
what table it goes to,
and what kind of class

00:08:31.350 --> 00:08:33.150
you want to instantiate.

00:08:33.230 --> 00:08:37.260
And by default we'll give
you an EOGeneric record,

00:08:37.260 --> 00:08:40.200
which is our convenient holder of data.

00:08:40.200 --> 00:08:42.190
It has no particular business logic.

00:08:42.270 --> 00:08:45.630
In most of your applications
you'll be creating your own

00:08:45.630 --> 00:08:49.270
special class to hold your EOs,
and you'll have some business

00:08:49.280 --> 00:08:50.950
logic associated with that.

00:08:55.210 --> 00:08:58.800
Okay, so now we've selected the course.

00:08:58.980 --> 00:09:05.200
So in the course you can see a list of
entities and relationships to the side.

00:09:05.200 --> 00:09:08.180
We'll talk about those more in a minute.

00:09:08.770 --> 00:09:10.410
I like to browse some data.

00:09:10.530 --> 00:09:16.120
So what Ernest just did,
he clicked on the icon that looks

00:09:16.180 --> 00:09:19.310
like a database cylinder with a
little magnifying glass on it.

00:09:19.380 --> 00:09:20.400
So that's browsing data.

00:09:20.400 --> 00:09:23.940
This is a good way just to
test that your data is there.

00:09:23.940 --> 00:09:25.540
You set up your model.

00:09:25.540 --> 00:09:30.990
It's an immediate validation that things
look right for talking to your database.

00:09:31.070 --> 00:09:33.020
And you can see what kind of
values you have in the database.

00:09:33.020 --> 00:09:35.930
Here you can also,
just for your convenience,

00:09:35.930 --> 00:09:38.840
you can have a qualifier
and filter this list.

00:09:38.870 --> 00:09:42.310
So if you have a lot of data and
you just want to take a look,

00:09:42.320 --> 00:09:45.950
see what's in there,
you might do some experiments here.

00:09:45.950 --> 00:09:49.000
So Ernest is adding a qualifier,
title like F*.

00:09:49.000 --> 00:09:50.590
So star is the wild card.

00:09:50.650 --> 00:09:55.700
So now you see there's only one course in
their formal logic which matched that F*.

00:09:55.700 --> 00:09:58.750
You can wipe that out,
have an unqualified query,

00:09:58.840 --> 00:10:01.420
and we'll get all the classes.

00:10:01.420 --> 00:10:05.290
So for our demonstration here,
we're only using two classes.

00:10:05.430 --> 00:10:07.130
It's a very small database.

00:10:07.180 --> 00:10:14.610
Let's show the inspector on the class.

00:10:17.290 --> 00:10:18.860
So this is the first panel.

00:10:18.860 --> 00:10:20.780
There's multiple panels
in our inspectors,

00:10:20.780 --> 00:10:24.050
and it really pays for you to
spend some time playing EOModeler.

00:10:24.170 --> 00:10:28.100
Make sure you go to the inspector on all
the different types of model objects.

00:10:28.180 --> 00:10:32.660
There's lots of settings you can
change in the different inspectors,

00:10:32.670 --> 00:10:36.210
and it's worth spending a little time
experimenting and getting to know

00:10:36.210 --> 00:10:38.300
what all those different things mean.

00:10:38.370 --> 00:10:40.430
So in this first panel,

00:10:40.900 --> 00:10:43.480
We have the name, the table name,
the class.

00:10:43.590 --> 00:10:48.090
Those are all immediately
available anyway in the table view.

00:10:48.230 --> 00:10:50.590
and then we have a
list of the properties.

00:10:50.590 --> 00:10:52.000
And this is just another way of editing.

00:10:52.000 --> 00:10:55.180
You can do all this work
in the table view also.

00:10:55.210 --> 00:10:59.650
We'll talk about the different
properties a bit later.

00:11:01.380 --> 00:11:03.750
So now we're looking at
the professor entity,

00:11:03.750 --> 00:11:07.600
and we're looking at the second panel,
the advanced entity inspector.

00:11:07.680 --> 00:11:10.760
And this entity uses inheritance.

00:11:10.900 --> 00:11:16.400
So the first thing you can
notice is in the parent box,

00:11:16.570 --> 00:11:20.000
We've selected person and there's a
little mark there indicating that the

00:11:20.100 --> 00:11:23.750
person is the parent for the professor.

00:11:24.120 --> 00:11:28.180
All your other entities will be
listed here and only one of them

00:11:28.180 --> 00:11:32.170
will be selected as parent or
maybe none if you have no parent.

00:11:32.490 --> 00:11:35.480
And then the other thing is because
of the way we're setting up our

00:11:35.480 --> 00:11:38.760
table with single table inheritance,
which we'll talk about later,

00:11:38.820 --> 00:11:40.900
we have a restricting qualifier.

00:11:41.000 --> 00:11:43.400
So when we fetch

00:11:43.890 --> 00:11:48.740
The professors out of the database were
going to be hitting the person table,

00:11:48.740 --> 00:11:55.510
and we're only interested in rows that
satisfy this qualifier where ptype = 1.

00:11:56.990 --> 00:12:02.690
So an EO entity contains, first of all,
a whole list of EO attributes.

00:12:02.750 --> 00:12:05.800
And each attribute is mapping
a column into an instance

00:12:05.960 --> 00:12:09.720
field of your Java object,
or an IVAR if you're

00:12:09.760 --> 00:12:12.190
used to the Objective-C.

00:12:12.820 --> 00:12:16.700
Now you have several
aspects to an EO attribute.

00:12:16.700 --> 00:12:21.700
The first thing to consider is whether or
not this attribute is a class property.

00:12:21.700 --> 00:12:27.770
A class property of your EO means
that when we fetch from the database,

00:12:27.770 --> 00:12:33.360
we want to fetch this column
and create a corresponding value

00:12:33.480 --> 00:12:36.700
in your EO for that column,
or for this attribute.

00:12:36.700 --> 00:12:40.590
If it's not marked as a class property,
it's there so that we know what

00:12:40.610 --> 00:12:44.370
to do when we're generating SQL,
but it's not declared

00:12:44.500 --> 00:12:46.490
as part of your class.

00:12:48.290 --> 00:12:53.380
Many things that you put in there,
especially foreign keys or primary keys,

00:12:53.380 --> 00:12:57.120
you wouldn't want to mark as a class
property because it doesn't really

00:12:57.120 --> 00:12:58.790
contribute to your business logic.

00:12:58.800 --> 00:13:03.000
You're not going to be
using that value when you're

00:13:03.420 --> 00:13:06.170
programming or creating your EOs.

00:13:06.180 --> 00:13:09.520
But EOF needs the primary keys
and foreign keys for when we're

00:13:09.860 --> 00:13:13.010
creating SQL and doing some of
the bookkeeping for you when we

00:13:13.010 --> 00:13:14.430
write values back to the database.

00:13:14.440 --> 00:13:16.760
So those attributes are declared,
but they're not marked

00:13:16.820 --> 00:13:17.800
as class properties.

00:13:18.200 --> 00:13:20.760
The next one is a primary key.

00:13:20.760 --> 00:13:24.720
A primary key is a special
attribute that uniquely identifies

00:13:25.360 --> 00:13:30.260
this row in the database or
this EO in your editing context.

00:13:30.440 --> 00:13:33.850
We use the primary keys when
we're creating what we call a

00:13:33.850 --> 00:13:37.720
global ID so that we always know
how to get to that EO again.

00:13:37.720 --> 00:13:42.310
And again, when we're doing faulting,
we need to know that primary key so that

00:13:42.490 --> 00:13:45.930
we know when we need to get this object,
we'll be able to go to

00:13:45.930 --> 00:13:47.250
the database and fetch it.

00:13:51.600 --> 00:13:54.280
So the next aspect is allows null.

00:13:54.290 --> 00:13:58.560
And this corresponds directly to
what the databases allow you to do.

00:13:58.600 --> 00:14:01.600
You can mark an attribute
whether or not it allows null.

00:14:01.600 --> 00:14:04.160
If it allows null,
then if you don't set it,

00:14:04.300 --> 00:14:05.590
we can write a null into the database.

00:14:05.600 --> 00:14:08.600
In some cases,
you don't want to allow null.

00:14:08.600 --> 00:14:11.860
You want to insist that your user
has set a value there or that your

00:14:11.860 --> 00:14:15.600
application logic depends on having
some value in that attribute.

00:14:15.600 --> 00:14:20.520
So you mark it, you leave it off so
it doesn't allow null.

00:14:21.600 --> 00:14:26.000
The external type is the type
that the database is using.

00:14:26.000 --> 00:14:28.760
It's the type name that's
specific to the database.

00:14:28.760 --> 00:14:30.890
So Oracle might have a varchar2.

00:14:30.900 --> 00:14:35.730
Not every database uses that
term for the external name.

00:14:35.730 --> 00:14:39.940
So we need to know those external names
for when we're creating tables for you.

00:14:39.940 --> 00:14:42.610
Most of the time,
if you've done reverse engineering,

00:14:42.610 --> 00:14:45.480
you don't have to worry too
much about the external name.

00:14:45.500 --> 00:14:48.740
But if you're switching from
one database to another,

00:14:48.740 --> 00:14:51.500
your set of external
names might be different.

00:14:51.590 --> 00:14:55.230
And it's worth knowing what database
you're talking to so that you get

00:14:55.310 --> 00:14:59.000
those external names right and you
understand the details about the

00:14:59.000 --> 00:15:01.490
meaning behind different external names.

00:15:01.500 --> 00:15:07.000
Not every database treats even
the similar terms the same way.

00:15:08.980 --> 00:15:12.410
The value class is the class
that you want this attribute

00:15:12.760 --> 00:15:14.830
to be expressed as in your EO.

00:15:14.860 --> 00:15:18.030
So when we talk about a
VARCHAR in the database,

00:15:18.030 --> 00:15:22.320
the external type is VARCHAR, in your EO,
typically that would be a string.

00:15:22.320 --> 00:15:28.080
So we have mappings for most
of the common value classes.

00:15:28.080 --> 00:15:32.900
We'll declare something number and
map it to the appropriate number.

00:15:34.120 --> 00:15:40.200
The value type is the other column
that helps us determine exactly,

00:15:40.200 --> 00:15:43.620
in the case of numbers,
exactly what type of

00:15:43.620 --> 00:15:45.390
number to instantiate.

00:15:45.400 --> 00:15:48.700
So that might be a small i,
meaning integer.

00:15:48.700 --> 00:15:53.960
Some things are ambiguous if we just
are saying we're mapping to number.

00:15:53.960 --> 00:15:56.230
We need to create a
concrete class of number,

00:15:56.250 --> 00:15:58.360
and the value type will help us do that.

00:15:58.400 --> 00:16:01.720
There are also a couple of other
cases where the value type has special

00:16:01.840 --> 00:16:03.500
meaning to a particular adapter.

00:16:04.000 --> 00:16:09.510
But maybe these things are attributes,
aspects of attributes

00:16:09.510 --> 00:16:11.140
that you use less often.

00:16:11.140 --> 00:16:13.040
You can mark an attribute read only.

00:16:13.040 --> 00:16:16.700
That means you don't
intend to ever modify it.

00:16:16.860 --> 00:16:21.500
And we will, EOF will raise an error if
you do try to modify it.

00:16:21.560 --> 00:16:23.320
You can have custom formatting.

00:16:23.320 --> 00:16:28.220
So you can have special format
strings that define how you get the

00:16:28.220 --> 00:16:30.980
values in and out of the database.

00:16:31.040 --> 00:16:33.380
I think this is used less often.

00:16:33.380 --> 00:16:33.700
But.

00:16:34.070 --> 00:16:38.300
There may be some special cases where
the values were formatted a strange way,

00:16:38.300 --> 00:16:41.610
and you really want to store and
retrieve things slightly differently.

00:16:43.460 --> 00:16:47.150
The derived attribute is almost
a whole other kind of attribute.

00:16:47.240 --> 00:16:52.340
Instead of mapping just directly
to some column in the database,

00:16:52.390 --> 00:16:54.390
you can have a SQL expression.

00:16:54.400 --> 00:16:59.600
So when you're fetching,
you can have some combination of logic

00:16:59.680 --> 00:17:05.400
that is evaluated at the database,
and we pull a value out of that.

00:17:05.400 --> 00:17:07.330
Usually, we can't update that value.

00:17:07.350 --> 00:17:14.760
So if you have some kind of attribute,
say salary, which is multiplying some

00:17:14.760 --> 00:17:19.340
monthly salary by 12,
you could have a SQL expression,

00:17:19.340 --> 00:17:22.920
monthly star 12,
and we'll fetch that for you and do

00:17:22.920 --> 00:17:25.400
the calculation on the database side.

00:17:25.400 --> 00:17:27.310
So there can be an advantage there.

00:17:27.360 --> 00:17:31.600
Or if you need some special
function that exists in SQL that

00:17:31.730 --> 00:17:35.390
is inconvenient to program in Java,
you can do that with the SQL expression.

00:17:35.400 --> 00:17:38.170
with a derived attribute.

00:17:39.110 --> 00:17:43.050
Flattened attributes are attributes
that belong to a different entity,

00:17:43.050 --> 00:17:47.660
but we've crossed a relationship to
get to this particular attribute.

00:17:47.660 --> 00:17:51.350
And we want to think of this
attribute as belonging to our EO,

00:17:51.350 --> 00:17:56.440
even though in our model we're actually
storing the value somewhere else.

00:17:56.540 --> 00:18:00.740
So when we see more about relationships,
we'll see how that fits in.

00:18:00.740 --> 00:18:05.070
But you can imagine an alias that
we've crossed one relationship,

00:18:05.090 --> 00:18:08.240
we're getting the value
out of another table,

00:18:08.790 --> 00:18:12.720
but we're storing it and treating
it in our Java object as if

00:18:12.770 --> 00:18:15.010
it were directly part of that.

00:18:15.060 --> 00:18:20.410
So it's a way of changing the model
to fit your application logic,

00:18:20.470 --> 00:18:23.870
even though your database layout
may be a little bit different.

00:18:25.780 --> 00:18:32.700
And Custom Value Class is a
capability for mapping the raw data

00:18:32.700 --> 00:18:37.890
from the database into some more
sophisticated object that isn't,

00:18:37.890 --> 00:18:40.350
well, that is defined by you
and your application.

00:18:40.360 --> 00:18:44.500
It's not one of our standard
objects such as string or a number.

00:18:44.500 --> 00:18:47.600
It's something that you're defining.

00:18:47.600 --> 00:18:52.320
You want to do a mapping
from our raw data into that.

00:18:52.420 --> 00:18:54.840
We're going to talk about that
more in a minute after the demo.

00:18:58.230 --> 00:19:01.350
All right, so let's go back to EOModeler.

00:19:01.350 --> 00:19:03.340
We'll go back to the computer.

00:19:07.600 --> 00:19:09.920
Okay,
so we want to talk about attributes,

00:19:09.920 --> 00:19:12.040
and we'll review some of the terms here.

00:19:14.580 --> 00:19:20.230
So we've selected person,
and we see just three attributes.

00:19:20.270 --> 00:19:24.500
The first thing,
the first column in the attribute

00:19:24.540 --> 00:19:27.320
viewer is a little key icon.

00:19:27.320 --> 00:19:30.820
I'm not sure if that's clear to everyone,
audience.

00:19:30.830 --> 00:19:33.470
The key indicates that
this is a primary key.

00:19:33.510 --> 00:19:35.180
And so we're using person ID.

00:19:35.420 --> 00:19:39.460
And this is pretty typical, I think,
that you'll have some kind of number

00:19:39.460 --> 00:19:43.930
or an integer as your primary key.

00:19:44.230 --> 00:19:46.180
It's not a class property.

00:19:46.200 --> 00:19:50.960
So the second column is that diamond,
is indicating which things are going

00:19:50.960 --> 00:19:53.770
to be mapped directly into my EO,
what things can I use

00:19:53.880 --> 00:19:55.200
for my business logic.

00:19:55.200 --> 00:20:00.020
In this case, the person ID is really an
artifact of how we store data

00:20:00.220 --> 00:20:02.100
in a relational database.

00:20:02.300 --> 00:20:05.600
It's not something that
you need typically to worry

00:20:05.600 --> 00:20:09.280
about in your business logic,
so we won't mark that

00:20:09.290 --> 00:20:11.460
as a class property.

00:20:12.960 --> 00:20:16.860
The next column is the locking bit.

00:20:17.110 --> 00:20:19.830
This determines when we're
doing optimistic locking,

00:20:19.840 --> 00:20:23.910
when we've made an update or about
to make an update to the database,

00:20:24.140 --> 00:20:26.990
what values do we want to check
to make sure nothing's changed and

00:20:26.990 --> 00:20:28.820
that we're safe to do this update.

00:20:28.820 --> 00:20:32.870
So EOF, as you probably have heard
from the introduction to

00:20:33.040 --> 00:20:38.060
Enterprise Object Frameworks on Tuesday,
keeps snapshots of all the data

00:20:38.110 --> 00:20:40.540
that we fetch out of the database.

00:20:41.720 --> 00:20:44.820
And things that are marked for locking,
we're going to check.

00:20:44.820 --> 00:20:47.440
When you do an update,
we're going to check that all these other

00:20:47.520 --> 00:20:51.350
things that you marked for locking are
still the same value in the database.

00:20:51.360 --> 00:20:55.020
If someone else had changed
that row in the database and

00:20:55.020 --> 00:20:58.410
we're about to update it,
our update will fail because

00:20:58.410 --> 00:21:00.040
of the optimistic locking.

00:21:00.080 --> 00:21:04.300
And that is determined by which
attributes you care about.

00:21:04.480 --> 00:21:07.780
Most of the time,
you want to lock on all your attributes

00:21:08.230 --> 00:21:12.070
because you want to be safe and make
sure that your application is only

00:21:12.070 --> 00:21:16.620
writing data that it fetched and it's
in complete control of the database.

00:21:16.620 --> 00:21:20.350
There may be some attributes
that you don't want to lock on,

00:21:20.430 --> 00:21:23.520
particularly blobs or
any kind of large object.

00:21:23.590 --> 00:21:26.870
It's very expensive to compare those.

00:21:26.920 --> 00:21:30.100
It turns out we can't generate
SQL to do the comparison.

00:21:30.100 --> 00:21:32.860
For normal attributes,
in our where clause,

00:21:32.860 --> 00:21:37.200
we'll generate the SQL and make sure that
we're updating the right row for you.

00:21:37.200 --> 00:21:42.160
But if you have something that's a blob,
a large kind of object in your database,

00:21:42.160 --> 00:21:46.340
EOF is forced to pull
that all into memory,

00:21:46.340 --> 00:21:50.600
do an in-memory comparison of that blob,
and then do the update to be safe.

00:21:50.610 --> 00:21:52.110
And you don't normally want that.

00:21:52.170 --> 00:21:53.800
It's really bad for performance.

00:21:53.850 --> 00:22:00.120
So if you have anything that's large,
I would say don't mark it for locking.

00:22:02.570 --> 00:22:07.430
Then we talked about the
value class and the first,

00:22:07.550 --> 00:22:09.020
so we have string and number.

00:22:09.020 --> 00:22:12.680
Number in Java is abstract,
so we have to...

00:22:13.940 --> 00:22:17.400
Let's say something more particular
about what number to instantiate.

00:22:17.440 --> 00:22:22.080
So the value type,
in this case we have a little i,

00:22:22.080 --> 00:22:24.800
meaning let's transfer
this as an integer.

00:22:24.800 --> 00:22:30.200
And we're inheriting this concept
really from our Objective-C days

00:22:30.230 --> 00:22:33.750
where we needed more information here.

00:22:33.920 --> 00:22:36.500
We're still doing the same
kind of thing in our models.

00:22:36.530 --> 00:22:39.990
We're still storing some
Objective-C information even though

00:22:39.990 --> 00:22:42.690
we're doing pure Java for our EOs.

00:22:43.720 --> 00:22:46.340
The external type we talked about,
so we have two examples,

00:22:46.340 --> 00:22:47.420
the VARCHAR and the number.

00:22:47.420 --> 00:22:51.850
This is going against an Oracle database,
so the VARCHAR2 is the Oracle normal

00:22:51.980 --> 00:22:54.260
type to use for VARCHAR.

00:22:54.260 --> 00:22:59.510
Some different, depending on your type,
you might have a width or you

00:22:59.700 --> 00:23:02.360
might have a scale and a precision.

00:23:02.360 --> 00:23:06.880
There'll be other columns
you can fill out for those.

00:23:08.630 --> 00:23:11.070
Just for your information,
when people first look at modeler,

00:23:11.070 --> 00:23:14.600
sometimes they don't see everything
they want to see about particular

00:23:14.600 --> 00:23:17.080
aspects of the attribute.

00:23:17.340 --> 00:23:20.080
There's a little pop-up
menu down there to the left.

00:23:20.100 --> 00:23:22.970
This controls what you see in EOModeler.

00:23:23.090 --> 00:23:27.180
So as you can see, we can,
let's show allows null.

00:23:28.920 --> 00:23:33.730
So now, that column there with the
zero is the allow null column.

00:23:33.730 --> 00:23:36.380
You can make that disappear if
you don't want to view that.

00:23:36.660 --> 00:23:38.680
Usually if setup allows null,
you don't need to look

00:23:38.680 --> 00:23:39.240
at it all the time.

00:23:39.240 --> 00:23:41.800
If you hit the delete key
when that column is selected,

00:23:41.820 --> 00:23:42.450
it's being hidden.

00:23:42.460 --> 00:23:43.800
We're not taking anything away.

00:23:43.800 --> 00:23:44.690
We're just hiding it from you.

00:23:44.700 --> 00:23:49.230
When you're first using EOModeler,
sometimes this is a bit confusing since

00:23:49.230 --> 00:23:53.330
your model looked one way and you've
done some things to rearrange it.

00:23:53.460 --> 00:23:56.660
It might not come back
the same way you expected.

00:23:56.660 --> 00:23:58.460
Or you might not be able to find things.

00:23:58.820 --> 00:24:03.130
If you get in that situation,
use the popup or use the inspector.

00:24:03.130 --> 00:24:07.770
Most of these values are
available in the inspector.

00:24:12.440 --> 00:24:14.460
So we talked a little bit
about the custom value class.

00:24:14.460 --> 00:24:16.440
That's another aspect to an attribute.

00:24:16.440 --> 00:24:21.390
And what this does is maps your
value into a particular class.

00:24:21.500 --> 00:24:23.380
So this is at the attribute level.

00:24:23.380 --> 00:24:25.180
This is just a value in the attribute.

00:24:25.180 --> 00:24:26.700
This is not talking about an EO.

00:24:26.700 --> 00:24:33.380
This is just a custom class for
holding some value of your attribute.

00:24:33.380 --> 00:24:37.610
So if you're doing this,
you need to have a factory method.

00:24:38.280 --> 00:24:39.640
So in this, this is an example.

00:24:39.700 --> 00:24:42.220
It might be called,
if your class is called custom,

00:24:42.220 --> 00:24:45.280
you might have a factory method
called custom with string.

00:24:45.280 --> 00:24:48.680
The idea here is a string will be passed.

00:24:48.800 --> 00:24:51.390
This is a string that we've
pulled out of the database.

00:24:51.400 --> 00:24:53.500
We're passing it to your method.

00:24:53.500 --> 00:24:56.240
Your method will give us back
one of your custom objects.

00:24:56.240 --> 00:24:59.340
So you'll just map this in the inspector.

00:25:01.030 --> 00:25:03.190
You need a conversion method,
so when we're writing things

00:25:03.190 --> 00:25:07.100
back into the database,
we have your custom value.

00:25:07.180 --> 00:25:11.280
EOF doesn't naturally know how
to put that into the database.

00:25:11.380 --> 00:25:15.860
You'll tell us to use your method,
in this example, custom as string.

00:25:15.990 --> 00:25:19.010
We will send custom as
string to your object.

00:25:19.120 --> 00:25:21.500
Your object has to respond to
that and give us back a string.

00:25:21.500 --> 00:25:25.210
Then we know how to put the
string in the database for you.

00:25:26.160 --> 00:25:30.000
And the third aspect to a custom
value class is the init argument.

00:25:30.000 --> 00:25:33.400
For the init argument,
we've been doing an example where

00:25:33.400 --> 00:25:34.990
your init argument is a string.

00:25:35.000 --> 00:25:40.400
It could also be an NSData,
if you have some large raw data,

00:25:40.400 --> 00:25:44.650
we'd map it to NSData,
or a Java byte array.

00:25:48.800 --> 00:25:51.800
All right,
let's talk about EORrelationships.

00:25:51.860 --> 00:25:56.920
A relationship basically maps a
foreign key into another object.

00:25:57.060 --> 00:26:01.150
And we saw earlier how
relationships were formed.

00:26:01.220 --> 00:26:08.210
We described them in our diagram view
as arrows from one entity to another.

00:26:08.390 --> 00:26:13.610
You've probably seen in other talks
where you match up a foreign key

00:26:13.760 --> 00:26:16.770
to a primary key in another table.

00:26:16.850 --> 00:26:20.680
When we talk about relationships,
we're talking in EOF about a

00:26:20.680 --> 00:26:22.880
one-directional relationship.

00:26:22.880 --> 00:26:25.880
So we say to one or to many.

00:26:25.880 --> 00:26:30.270
A to one is a relationship where
the destination is a single object.

00:26:30.360 --> 00:26:36.820
So in our example,
a course has an instructor.

00:26:36.860 --> 00:26:39.870
So the course has a to one
relationship to the instructor.

00:26:39.880 --> 00:26:41.810
There's just one
instructor for our course.

00:26:41.820 --> 00:26:46.470
A to many relationship is where the
destination is actually an array.

00:26:46.810 --> 00:26:49.370
of other objects.

00:26:50.060 --> 00:26:55.260
In our example,
a student might be enrolled

00:26:55.270 --> 00:26:58.280
in multiple courses,
or a professor might

00:26:58.530 --> 00:27:00.210
teach multiple courses.

00:27:00.410 --> 00:27:04.040
In those cases, we'll create the array.

00:27:04.040 --> 00:27:07.160
We need to know the destination type,
but we'll create an array

00:27:07.160 --> 00:27:08.750
of those objects for you.

00:27:08.900 --> 00:27:15.360
And typically, EOF works well if there's
an inverse relationship,

00:27:15.360 --> 00:27:17.240
so something going back the other way.

00:27:17.240 --> 00:27:22.090
There are several places where
EOF wants to figure out how to make an

00:27:22.090 --> 00:27:27.880
update going back from the destination
object into the source object.

00:27:27.880 --> 00:27:31.380
And it's pretty natural when
you're modeling things to think

00:27:31.430 --> 00:27:35.520
of some of these relationships as
a pair of one-way relationships.

00:27:35.520 --> 00:27:37.770
So you have an inverse
for most relationships.

00:27:38.170 --> 00:27:40.220
But that's not required.

00:27:41.680 --> 00:27:44.260
So we have a little diagram
here where you can see the

00:27:44.260 --> 00:27:45.990
course has one instructor.

00:27:45.990 --> 00:27:51.990
The donuts are the EOs,
and I think that's very common notation,

00:27:52.110 --> 00:27:54.600
graphical notation in our documentation.

00:27:54.600 --> 00:27:56.590
The arrows represent the relationships.

00:27:56.590 --> 00:27:59.710
The little box of two
things is an NSArray,

00:27:59.710 --> 00:28:02.590
and you can see how the courses map.

00:28:07.280 --> 00:28:10.080
So then advanced relationships,
some other aspects you

00:28:10.080 --> 00:28:11.040
can set on a relationship.

00:28:11.040 --> 00:28:14.210
The first thing to think
about in your relationship is,

00:28:14.310 --> 00:28:15.500
is this optional or mandatory?

00:28:15.600 --> 00:28:19.600
Do you require,
to have a fully formed EO,

00:28:19.600 --> 00:28:23.900
do you require that it has some
connection across this relationship?

00:28:23.900 --> 00:28:25.720
Does there have to be
a destination value,

00:28:25.820 --> 00:28:26.590
or can it be null?

00:28:26.600 --> 00:28:28.740
If it can be null,
then it's an optional relationship.

00:28:28.740 --> 00:28:33.130
If you require that there's some
value there for your business logic,

00:28:33.130 --> 00:28:36.740
and just for your,
the semantics of your application,

00:28:36.740 --> 00:28:38.280
then it's marked mandatory.

00:28:38.300 --> 00:28:39.980
And EOF will enforce that.

00:28:39.980 --> 00:28:43.950
If something's marked mandatory,
and for some reason your code or

00:28:44.030 --> 00:28:49.500
your user doesn't set a value there,
EOF will raise an exception.

00:28:50.200 --> 00:28:55.910
Propagate Primary Key is another
aspect of a relationship.

00:28:55.910 --> 00:29:02.320
And what this says is that when
you're inserting a new object at the

00:29:02.320 --> 00:29:02.320
destination of this relationship,

00:29:02.820 --> 00:29:07.180
It can inherit a primary key
value from the source object.

00:29:07.260 --> 00:29:09.540
Now, this is something you
have to think about.

00:29:09.730 --> 00:29:14.060
Typically, you want your objects to have
independent primary keys,

00:29:14.200 --> 00:29:18.620
but there are some cases where it's very
convenient to propagate the primary key,

00:29:18.620 --> 00:29:20.890
especially when we're doing
some kind of correlation table

00:29:21.130 --> 00:29:27.330
and setting up a many-to-many,
and we'll show that in our live demo.

00:29:27.750 --> 00:29:32.340
The delete rules tell EOF what
to do when you delete an object.

00:29:32.380 --> 00:29:35.780
There are a couple of
different possibilities.

00:29:35.780 --> 00:29:39.600
We'll talk about those in a minute
when we're showing the live EOModeler.

00:29:39.600 --> 00:29:44.760
But you can imagine one possibility
is just to cascade the delete.

00:29:44.790 --> 00:29:49.060
If you delete a source object,
you want to follow that relationship,

00:29:49.060 --> 00:29:52.650
delete the destination object, and so on.

00:29:53.220 --> 00:29:54.830
Another possibility is to nullify.

00:29:54.830 --> 00:29:56.960
So if you're deleting
the destination object,

00:29:56.960 --> 00:30:00.180
the source object just wants
to get a null marked where

00:30:00.330 --> 00:30:02.700
that relationship used to be.

00:30:03.600 --> 00:30:09.120
Owns destination implies a
stronger bond between the source

00:30:09.190 --> 00:30:10.820
object and the destination object.

00:30:10.860 --> 00:30:13.660
In fact,
it's so strong that if the destination

00:30:13.780 --> 00:30:17.700
object is not part of this relationship,
it has no reason for being,

00:30:17.700 --> 00:30:20.080
and it's going to be
automatically deleted.

00:30:20.080 --> 00:30:23.690
This can be very convenient
to keep you from having to

00:30:23.850 --> 00:30:26.070
write too much business logic.

00:30:26.080 --> 00:30:30.520
If you set a new value for the
destination of some relationship,

00:30:30.520 --> 00:30:34.900
the old value will just go away
without any extra code on your part,

00:30:34.900 --> 00:30:37.460
if you've marked the
relationship owns destination.

00:30:37.460 --> 00:30:40.440
But there are other times where
you don't want to do that.

00:30:40.440 --> 00:30:41.920
You don't want to
automatically delete things.

00:30:41.920 --> 00:30:43.930
You want to control that,
let that object live

00:30:43.930 --> 00:30:45.070
for some other reason.

00:30:46.800 --> 00:30:48.700
And finally, batch faulting.

00:30:48.800 --> 00:30:51.680
Now we haven't talked about faulting,
but if you've gone to any of the

00:30:51.690 --> 00:30:54.710
other EOF talks or maybe some
of the other WebObjects talks,

00:30:54.770 --> 00:30:56.900
you may know about faulting already.

00:30:56.900 --> 00:30:59.800
And most of you, I think,
have used WebObjects, so you understand.

00:30:59.800 --> 00:31:02.550
The idea of faulting is a fault
is kind of a placeholder object.

00:31:02.640 --> 00:31:07.910
When we fetch the objects to begin with,
they have relationships to other objects.

00:31:07.970 --> 00:31:11.880
We're not going to fetch all of those
objects and recursively load up the whole

00:31:11.890 --> 00:31:15.120
database into our editing context memory.

00:31:15.120 --> 00:31:20.590
What we do is we fetch the objects
that are immediately desired

00:31:20.590 --> 00:31:23.300
from the fetch specification.

00:31:23.380 --> 00:31:26.540
Then for all the relationships,
we put in placeholder objects,

00:31:26.540 --> 00:31:27.450
which we call faults.

00:31:27.600 --> 00:31:30.660
When you touch a fault,
it will magically become

00:31:30.660 --> 00:31:32.530
the EO that you want to use.

00:31:32.620 --> 00:31:36.120
So your business logic doesn't
have to worry about faults.

00:31:36.260 --> 00:31:42.360
But when we're creating these objects,
it's important that they're

00:31:42.480 --> 00:31:46.180
marked specially as faults,
and there's some performance

00:31:46.180 --> 00:31:48.380
issues about pulling in the faults.

00:31:48.460 --> 00:31:51.890
If we touch a fault,
we have to make one round trip to the

00:31:51.980 --> 00:31:54.460
database to bring the values back.

00:31:54.460 --> 00:31:59.460
It turns out it's very common that when
you touch one fault of a certain type,

00:31:59.460 --> 00:32:04.450
your application typically might touch
several other faults of that type.

00:32:04.520 --> 00:32:09.450
So to make that perform better,
we have a concept of batch faulting.

00:32:09.460 --> 00:32:13.530
You can set on the relationship
how many of these faults you

00:32:13.530 --> 00:32:16.500
want to bring back at once,
and we'll make one round

00:32:16.540 --> 00:32:18.840
trip to the database,
and maybe you marked it for

00:32:18.840 --> 00:32:21.460
10 as your batch faulting.

00:32:21.460 --> 00:32:24.460
It's kind of a hint to EOF, "Okay,
if you hit this fault,

00:32:24.460 --> 00:32:29.460
bring the next 10 with you." That will
improve performance in many cases.

00:32:29.460 --> 00:32:32.800
All right, let's go back to EOModeler.

00:32:36.510 --> 00:32:38.260
And we'll take a look at
some of the relationships we

00:32:38.260 --> 00:32:41.800
have defined in this model.

00:32:41.800 --> 00:32:45.710
Selected student.

00:32:46.190 --> 00:32:48.560
A list of relationships here.

00:32:48.730 --> 00:32:53.220
First, Advisor is a 2-1 relationship.

00:32:53.220 --> 00:32:55.180
Let's inspect that.

00:32:56.010 --> 00:33:02.100
So in the inspector we can
see the destination entity

00:33:02.100 --> 00:33:05.410
is marked as professor,
it's marked as a 2-1,

00:33:05.410 --> 00:33:09.540
and the joins tell us which columns
or which attributes we're going

00:33:09.540 --> 00:33:12.900
to use to match up those values.

00:33:12.950 --> 00:33:17.780
And you can see how that maps directly
into the SQL we have to generate.

00:33:17.930 --> 00:33:22.300
For a 2.1,
the source object holds a foreign

00:33:22.300 --> 00:33:23.820
key into the destination object.

00:33:23.820 --> 00:33:26.760
So at the destination side
is typically the primary key

00:33:26.760 --> 00:33:27.760
is what you want to join on.

00:33:29.480 --> 00:33:31.890
All right,
so now this is showing a to-many.

00:33:32.140 --> 00:33:33.850
The destination is enrollment.

00:33:33.990 --> 00:33:36.880
Enrollment is really a correlation table.

00:33:36.950 --> 00:33:39.760
There's not that much
interesting about enrollment,

00:33:39.860 --> 00:33:44.190
but it's a way of forming the
many-to-many relationship between

00:33:44.230 --> 00:33:47.400
students and the courses they're taking.

00:33:47.400 --> 00:33:52.400
So our purpose here is just to form the,
we want to form the to-many.

00:33:52.400 --> 00:33:56.590
We're going to use this to
flatten another relationship.

00:33:57.290 --> 00:34:03.300
On the student side,
the source for the join is the person ID,

00:34:03.300 --> 00:34:06.280
and the destination
side is the student ID.

00:34:06.920 --> 00:34:10.010
So the enrollment,
if you think about when

00:34:10.070 --> 00:34:12.820
we saw the diagram view,
the enrollment had a 2-1 relationship.

00:34:12.820 --> 00:34:16.970
The inverse of this was
back to the student.

00:34:18.950 --> 00:34:20.560
So this is a little bit simpler.

00:34:20.560 --> 00:34:21.400
We have a definition.

00:34:21.400 --> 00:34:24.690
It says to enrollment, dot to course.

00:34:24.770 --> 00:34:26.980
So what we're doing is
we're following the first

00:34:26.980 --> 00:34:29.600
relationship to the enrollments.

00:34:29.700 --> 00:34:31.360
That will get us to an enrollment object.

00:34:31.590 --> 00:34:35.410
Then an enrollment object has
another relationship to a course.

00:34:36.020 --> 00:34:40.100
By doing this flattened relationship,
we make that jump to

00:34:40.100 --> 00:34:43.570
enrollments to course,
and now the to-many relationship

00:34:44.300 --> 00:34:47.360
is actually an array of
courses for this student.

00:34:47.400 --> 00:34:52.010
So when we're modeling this,
what we cared about were the courses.

00:34:52.020 --> 00:34:54.610
We didn't want to think
so much about enrollments.

00:34:54.620 --> 00:34:59.340
They're there really just to form the
correlation table to map correctly

00:34:59.600 --> 00:35:01.620
into the relational database.

00:35:01.900 --> 00:35:06.030
But at our object level,
we want to program and deal in

00:35:06.030 --> 00:35:08.520
courses directly from the student.

00:35:08.520 --> 00:35:11.480
Okay,
we want to change gears a little bit now,

00:35:11.480 --> 00:35:15.060
and we've talked about
what's involved in a model.

00:35:15.060 --> 00:35:17.400
Now let's talk about how you
create a model and tables.

00:35:17.400 --> 00:35:21.660
So the EOModeler tool can do
what we call reverse engineering.

00:35:21.660 --> 00:35:27.130
Reverse engineering is a way
of interrogating the database,

00:35:27.350 --> 00:35:31.820
finding out what tables already exist,
and creating the proper entities

00:35:31.820 --> 00:35:33.750
and mappings for all the attributes.

00:35:33.790 --> 00:35:36.080
We do that automatically for you.

00:35:36.140 --> 00:35:37.050
It's a good starting point.

00:35:37.050 --> 00:35:40.420
In many applications,
you already have your data.

00:35:40.420 --> 00:35:42.250
Someone else has defined
the data for you,

00:35:42.280 --> 00:35:44.500
and you're going to put
a web interface on that.

00:35:44.500 --> 00:35:48.720
So you want to get access
to the database tables,

00:35:48.720 --> 00:35:49.780
reverse engineer.

00:35:49.780 --> 00:35:51.450
Maybe you don't need all the tables.

00:35:51.680 --> 00:35:57.060
You'll pick a list of the tables
you want to use and let EOModeler

00:35:57.060 --> 00:36:00.770
create those entities and attributes.

00:36:00.770 --> 00:36:01.740
That's a good starting point.

00:36:01.740 --> 00:36:05.360
After you've done that,
you'll want to go inspect your model.

00:36:05.360 --> 00:36:07.610
Maybe you don't need all the attributes.

00:36:07.660 --> 00:36:08.320
You'll take some out.

00:36:08.320 --> 00:36:10.880
Maybe you'll need to form
some other relationships.

00:36:10.880 --> 00:36:13.110
You might want to flatten
some relationships.

00:36:13.190 --> 00:36:16.820
There's quite a bit you can still
do after you reverse engineered,

00:36:16.820 --> 00:36:18.880
but it's a good starting point.

00:36:19.000 --> 00:36:24.260
It saves you from having to type a lot
of detail that you already know and has

00:36:24.260 --> 00:36:26.130
already been declared in the database.

00:36:26.140 --> 00:36:28.780
Now, not everyone wants to
go in that direction.

00:36:28.880 --> 00:36:32.920
For some applications, you're in charge.

00:36:32.920 --> 00:36:35.170
You get to define the data format.

00:36:35.200 --> 00:36:38.970
So you might start with the
EOModel and experiment a bit.

00:36:38.990 --> 00:36:43.890
You'll just create some entities,
declare all the information you need,

00:36:43.900 --> 00:36:45.820
all the things we've talked about,
especially the attributes

00:36:46.180 --> 00:36:49.150
and the external types,
and EOModeler will generate the

00:36:49.220 --> 00:36:52.780
SQL that's necessary to create
those corresponding tables.

00:36:52.780 --> 00:36:55.220
We'll show you that in a minute.

00:36:55.970 --> 00:36:59.970
EOModeler can also create
Java source code for you.

00:37:00.030 --> 00:37:04.130
So you've declared your entities,
all your attributes.

00:37:04.230 --> 00:37:08.200
Your entities are going to correspond
to a particular class that you

00:37:08.200 --> 00:37:09.900
want to use for business logic.

00:37:09.920 --> 00:37:13.900
Your attributes map into the
instance fields of that class.

00:37:13.900 --> 00:37:18.690
We'll create the basics
of the Java source.

00:37:19.040 --> 00:37:23.850
Typically, you'll start with that and
then add more business logic.

00:37:25.020 --> 00:37:28.560
And then the other aspect
of EOModeler has a feature

00:37:28.640 --> 00:37:30.260
called schema synchronization.

00:37:30.320 --> 00:37:34.500
So schema synchronization,
it's a way of matching up what's

00:37:34.500 --> 00:37:37.860
in your database to what's
in your model and vice versa.

00:37:37.940 --> 00:37:41.510
It gives you some options
about what to do with missing

00:37:41.510 --> 00:37:43.630
fields or additional fields.

00:37:43.650 --> 00:37:47.130
It's a way of synchronizing
your model with your database.

00:37:51.780 --> 00:37:52.820
So, editing a model.

00:37:52.820 --> 00:37:55.420
The typical things that you
might want to change in a model.

00:37:55.570 --> 00:37:57.770
First of all, switch adapter.

00:37:58.120 --> 00:38:02.320
So you've done your application,
you've used one kind of datasource.

00:38:02.320 --> 00:38:06.990
Let's say you started with OpenBase,
and for some reason you want to change,

00:38:07.000 --> 00:38:09.180
you have another database server,
an Oracle server.

00:38:09.180 --> 00:38:13.340
You want to use SwitchAdapter
to modify your model to work

00:38:13.630 --> 00:38:15.860
with your new datasource.

00:38:15.960 --> 00:38:21.060
In particular, when you do SwitchAdapter,
even if you choose JDBC,

00:38:21.310 --> 00:38:26.320
which we'll talk about later,
SwitchAdapter will work

00:38:26.450 --> 00:38:28.590
through your model,
all your attributes,

00:38:28.600 --> 00:38:33.760
fix up your external types to map
to that particular datasource.

00:38:33.760 --> 00:38:37.040
This is important.

00:38:37.360 --> 00:38:41.090
In our previous releases,
people would have separate adapters,

00:38:41.100 --> 00:38:42.760
an Oracle adapter or a Sybase adapter.

00:38:42.810 --> 00:38:46.650
Now we're going to be using one adapter,
but the mechanism for adapting

00:38:46.800 --> 00:38:52.520
or changing your model into a new
datasource is still to use SwitchAdapter.

00:38:53.100 --> 00:38:56.210
SetAdapterInfo is a simpler operation.

00:38:56.210 --> 00:38:58.390
At this point, you're just editing the
connection dictionary.

00:38:58.390 --> 00:39:01.990
You're not going to make any other
changes immediately to your model.

00:39:02.040 --> 00:39:05.280
So, this can be a little bit
confusing when we're using JDBC.

00:39:05.280 --> 00:39:07.230
We'll talk about that in a minute.

00:39:07.240 --> 00:39:11.630
If you change your,
if you just use SetAdapterInfo

00:39:11.630 --> 00:39:17.530
and change something that's
significant about your datasource,

00:39:17.540 --> 00:39:20.490
it would be better to use SwitchAdapter
to make sure that everything

00:39:20.490 --> 00:39:21.900
in your model gets changed.

00:39:24.250 --> 00:39:25.850
And of course,
when you're editing a model,

00:39:25.860 --> 00:39:28.960
as we've seen, there are lots of fields
that you can change.

00:39:29.000 --> 00:39:31.190
You make all your changes to your
attributes and your entities.

00:39:31.480 --> 00:39:32.350
Just use EOModel.

00:39:32.450 --> 00:39:34.700
Click on something,
type something else over it.

00:39:34.780 --> 00:39:35.920
That's how you make a change.

00:39:35.920 --> 00:39:37.100
And use the inspectors.

00:39:37.150 --> 00:39:40.300
There's sometimes more information
available in the inspector than

00:39:40.370 --> 00:39:41.910
we can show in the table view.

00:39:41.910 --> 00:39:46.910
So that's another way of changing
information about your model.

00:39:47.350 --> 00:39:50.020
And the final bullet is
editing fetch specifications.

00:39:50.060 --> 00:39:53.200
We have a fetch specification
builder built into EOModeler.

00:39:53.250 --> 00:39:57.730
You can associate fetch specifications
directly with an entity,

00:39:58.070 --> 00:40:03.340
give it a name, and that's available to
your code at runtime.

00:40:03.340 --> 00:40:06.840
And it's a very easy way
to fetch other objects.

00:40:06.840 --> 00:40:09.350
You've already set up a fetch
specification or a template

00:40:09.350 --> 00:40:10.740
for a fetch specification.

00:40:10.740 --> 00:40:16.670
You can use qualifier variables to fetch
particular information that you want.

00:40:17.200 --> 00:40:21.060
So we'll look at the fetch
specification builder in a minute.

00:40:21.060 --> 00:40:23.040
Okay.

00:40:23.140 --> 00:40:27.130
Let's go back to EOModeler.

00:40:34.330 --> 00:40:39.380
So as we mentioned, for tables,
we wanted to-- we have course selected.

00:40:39.670 --> 00:40:41.800
We want to show the SQL generation panel.

00:40:41.800 --> 00:40:43.600
There's a little SQL button.

00:40:43.600 --> 00:40:47.230
We'll turn off those two
about dropping tables.

00:40:47.260 --> 00:40:49.640
But we're going to slide down here.

00:40:49.660 --> 00:40:54.260
You can see we've generated some
SQL to create this table for you.

00:40:54.260 --> 00:40:59.370
And then we're also generating some SQL,
in this case to go against Oracle to

00:40:59.450 --> 00:41:03.260
create a sequence so that we can create
primary keys using that sequence.

00:41:03.260 --> 00:41:08.080
And we have a little code here that's
trying to figure out what the next

00:41:08.080 --> 00:41:10.910
value should be in that sequence,
in case you already have

00:41:10.950 --> 00:41:13.130
data in your database.

00:41:14.680 --> 00:41:17.270
We're not going to do it now,
but there's a button at the bottom

00:41:17.400 --> 00:41:19.020
that says to execute the SQL.

00:41:19.020 --> 00:41:20.200
That would go create the table.

00:41:20.200 --> 00:41:21.440
We already have the table.

00:41:21.440 --> 00:41:24.800
If you already have a table created,
Oracle will give you some errors.

00:41:24.800 --> 00:41:28.430
They're pretty soft errors,
so you can just continue past that.

00:41:28.480 --> 00:41:33.580
The tables button is a convenient way
to check what's already in my database.

00:41:33.580 --> 00:41:37.500
And if you wanted to create something,
you can see it kind of reinforces

00:41:37.590 --> 00:41:40.730
that things worked correctly
if you click on that tables

00:41:40.730 --> 00:41:42.720
button and just get your list.

00:41:43.320 --> 00:41:46.370
When you're dealing with Oracle,
of course, these tables belong to the

00:41:46.390 --> 00:41:47.860
particular user that logged in.

00:41:47.860 --> 00:41:52.740
Different databases will have different
ways of deciding what the table space is.

00:41:56.110 --> 00:42:00.620
Okay, so that gives you a general idea
of what you can do for creating,

00:42:00.700 --> 00:42:04.680
and we talked earlier about
reverse engineering tables.

00:42:04.680 --> 00:42:06.740
All right,
let's get back and talk a little

00:42:06.740 --> 00:42:08.560
bit about EOFET specification.

00:42:10.510 --> 00:42:13.670
So, you use a fetch specification
when you want to get data out

00:42:13.670 --> 00:42:16.660
of your database and create EOs.

00:42:18.230 --> 00:42:24.390
It fetches objects from the database
into your editing context by using,

00:42:24.390 --> 00:42:27.800
by filtering according to the
EOQualifier that you assign

00:42:28.070 --> 00:42:29.020
to your fetch specification.

00:42:29.020 --> 00:42:31.800
And the EOQualifier,
I think you've seen in

00:42:31.930 --> 00:42:35.580
the introduction to EOF,
how you form an EOQualifier.

00:42:35.580 --> 00:42:40.680
It's a query language that's a simple
kind of object-oriented query language.

00:42:40.680 --> 00:42:44.170
You can use key value coding,
have key paths involved

00:42:44.170 --> 00:42:45.660
in your qualifier.

00:42:45.850 --> 00:42:51.540
So we'll do the joins across multiple
tables for you automatically.

00:42:51.630 --> 00:42:55.040
You don't have to think too much
about where all your data is located.

00:42:55.040 --> 00:42:58.220
Just work at the object level,
crossing relationships,

00:42:58.220 --> 00:43:00.930
and referring to attributes
by their key name.

00:43:02.530 --> 00:43:05.420
One thing you can set on a
fetch specification is the

00:43:05.420 --> 00:43:06.880
notion of is it deep or not.

00:43:06.910 --> 00:43:10.400
And this has to do with when
we're using entity inheritance.

00:43:10.400 --> 00:43:15.660
A deep fetch specification
will fetch not only the entity

00:43:15.660 --> 00:43:18.690
that it's been assigned to,
but also all the subentities.

00:43:18.800 --> 00:43:23.080
So in our case,
we had person as the parent

00:43:23.080 --> 00:43:26.900
class for professor and student.

00:43:26.900 --> 00:43:31.440
So if you try to fetch person,
we'll fetch all the persons,

00:43:31.440 --> 00:43:34.940
we'll fetch all the professors,
and fetch all the students.

00:43:35.030 --> 00:43:38.940
And then we'll filter according
to whatever your qualifier is.

00:43:40.470 --> 00:43:44.710
We also use fetch specifications
for shared objects.

00:43:44.760 --> 00:43:50.360
In the EO Entity Inspector,
you can see where you can mark whether

00:43:50.360 --> 00:43:54.980
or not you want to move objects
into the shared editing context

00:43:55.040 --> 00:43:56.430
when you first load up this model.

00:43:56.440 --> 00:44:00.760
I think we'll talk about this in the
advanced EOF session later today.

00:44:00.840 --> 00:44:03.300
I think that begins at 3.30.

00:44:04.520 --> 00:44:08.070
So if you're using shared objects,
you'll want to use a

00:44:08.070 --> 00:44:10.260
named fetch specification.

00:44:10.260 --> 00:44:12.940
You might want to share all
the objects of this entity,

00:44:13.010 --> 00:44:16.620
or you might want to filter that and
use a fetch specification just to get

00:44:16.620 --> 00:44:20.050
certain objects moved automatically
into the shared editing context.

00:44:22.140 --> 00:44:25.860
And finally, we have inside EOModeler,
there's a Fetch Specification Builder,

00:44:25.900 --> 00:44:27.130
and we'll take a look at that.

00:44:27.210 --> 00:44:29.230
Select Professor.

00:44:30.200 --> 00:44:34.140
If you hit the little plus sign there,
it expands the professor.

00:44:34.140 --> 00:44:37.690
You can see all the relationships
below it and the stored procedures.

00:44:37.720 --> 00:44:41.140
So the stored procedure has
a slightly different icon.

00:44:41.920 --> 00:44:43.820
By clicking on that,
we're showing the Fetch

00:44:43.820 --> 00:44:45.040
Specification Builder.

00:44:45.060 --> 00:44:49.220
And we have a Fetch
Specification already there.

00:44:49.220 --> 00:44:49.880
We want to browse.

00:44:49.880 --> 00:44:51.940
Let's browse data and
see what we get back.

00:44:51.980 --> 00:44:54.520
So this was a very simple
Fetch Specification.

00:44:54.520 --> 00:45:00.580
We just wanted to see all the
professors whose name began with J.

00:45:00.580 --> 00:45:03.820
So we can change that easily.

00:45:03.820 --> 00:45:07.430
We'll close that if you want to...

00:45:08.250 --> 00:45:11.510
You can edit that, let's say we want a W.

00:45:11.510 --> 00:45:14.190
You can put whatever you want
in there and go browse again.

00:45:14.200 --> 00:45:20.290
This is an easy way to test your fetch
specification right there in the builder.

00:45:24.090 --> 00:45:28.120
Let's take a look at some of the other
tabs in the Fetch Specification Builder.

00:45:28.120 --> 00:45:31.970
We talked about Fetch Specifications
in some of our other EOF talks.

00:45:32.070 --> 00:45:38.910
The sort ordering allows you to choose
how your results are going to be ordered.

00:45:39.040 --> 00:45:45.000
So you might order by name, in this case,
office, location, whatever.

00:45:45.000 --> 00:45:50.000
You can choose several of these different
attributes and we'll order on those.

00:45:50.000 --> 00:45:54.000
You can even follow a key path
and we'll order according to

00:45:54.000 --> 00:45:56.760
the results in that key path.

00:45:57.710 --> 00:45:59.570
The next tab is prefetching.

00:45:59.890 --> 00:46:04.980
Now the idea here is when we're fetching
some objects with a fetch specification,

00:46:05.400 --> 00:46:09.380
there are some related objects
that we might know because of our

00:46:09.380 --> 00:46:12.900
application logic that we're likely
to touch these other objects.

00:46:12.980 --> 00:46:16.330
So I told you before that
normally when we fetch an object,

00:46:16.330 --> 00:46:19.080
we create a fault for the relationships.

00:46:19.980 --> 00:46:24.440
If you set up prefetching, you can say,
well, I really know I'm going

00:46:24.550 --> 00:46:27.270
to need that object,
so don't just make a fault.

00:46:27.300 --> 00:46:29.840
On some of these objects,
we want you to prefetch,

00:46:29.930 --> 00:46:32.860
we want you to go get the real
object so we have that in memory

00:46:32.860 --> 00:46:34.640
as a result of this one fetch.

00:46:34.640 --> 00:46:37.900
We might actually have to go to
the database a couple of times,

00:46:37.900 --> 00:46:41.300
but we can group things and give
you a bit better performance if

00:46:41.300 --> 00:46:45.020
you have prefetching turned on
for things that you actually need.

00:46:45.020 --> 00:46:47.940
And that, again,
would be following some kind

00:46:47.990 --> 00:46:51.710
of relationship and saying,
get me that object at the end of

00:46:51.780 --> 00:46:56.570
this relationship whenever you
fetch this fetch specification.

00:46:57.600 --> 00:48:28.100
[Transcript missing]

00:48:28.530 --> 00:48:32.330
and you can decide which
attributes to fetch.

00:48:32.420 --> 00:48:37.250
We have a couple of choices there,
whether we fetch all of the attributes

00:48:37.250 --> 00:48:43.160
as raw rows or we just fetch a certain
set of the attributes as raw rows.

00:48:43.220 --> 00:48:46.510
But the usual thing is most of the
time you want to fetch enterprise

00:48:46.540 --> 00:48:50.500
objects and have EOF do the special
work to keep track of those objects

00:48:50.500 --> 00:48:52.960
for you so you don't have to think
about updating your database.

00:48:52.990 --> 00:48:57.580
You just change the object, save changes,
and everything happens magically.

00:48:57.820 --> 00:48:59.700
The next panel, options.

00:48:59.930 --> 00:49:02.700
All right,
so there's a couple of extra options

00:49:02.700 --> 00:49:04.560
you can set on a fetch specification.

00:49:04.560 --> 00:49:07.510
First thing is a fetch limit.

00:49:07.720 --> 00:49:08.300
How many rows?

00:49:08.300 --> 00:49:11.320
There might be a case where you
only want to get so many rows,

00:49:11.320 --> 00:49:14.840
you're not sure how many are out there,
but let's stop at some limit.

00:49:14.900 --> 00:49:19.970
When you're doing desktop applications,
it makes sense to prompt on a limit.

00:49:20.080 --> 00:49:24.350
You might pull back the first
100 rows and let the user decide,

00:49:24.380 --> 00:49:26.950
okay, I'll get the next 100.

00:49:28.680 --> 00:49:32.260
These other things about
doing deep inheritance fetch,

00:49:32.260 --> 00:49:36.460
fetching distinct rows,
basically adds distinct when

00:49:36.460 --> 00:49:40.710
we're generating the SQL,
we'll add a distinct so you don't

00:49:40.710 --> 00:49:43.380
get duplicates in your result set.

00:49:44.120 --> 00:49:45.800
We can lock the objects.

00:49:45.800 --> 00:49:47.680
I don't recommend you use that,
but if you're,

00:49:47.680 --> 00:49:49.670
especially if you're doing a
desktop kind of application,

00:49:49.670 --> 00:49:51.330
you really know you own the database.

00:49:51.330 --> 00:49:54.500
You can lock the database,
the objects in the database

00:49:54.890 --> 00:49:56.100
whenever you fetch them.

00:49:56.100 --> 00:49:57.970
If you're doing a web application,
you don't want to do that.

00:49:58.140 --> 00:50:02.090
It's going to hurt performance and
it'll cause you other problems.

00:50:02.240 --> 00:50:08.220
So don't, don't lock your fetch
specifications in general,

00:50:08.220 --> 00:50:08.220
but if you know that you need it,
it's there.

00:50:08.550 --> 00:50:11.630
Refresh refetched objects.

00:50:11.810 --> 00:50:17.600
Usually, if EOF already has an object and
you run another fetch specification,

00:50:17.600 --> 00:50:20.850
getting back that same object,
EOF won't do anything

00:50:20.950 --> 00:50:23.120
special because it says,
we already have that.

00:50:23.120 --> 00:50:23.770
It's in our cache.

00:50:24.240 --> 00:50:27.620
If you set this,
then what you're telling EOF is, well,

00:50:27.850 --> 00:50:30.800
when you fetch this fetch
specification for me,

00:50:30.800 --> 00:50:34.240
even if I've already seen these
objects and think I know about them,

00:50:34.240 --> 00:50:37.220
I want you to refresh them,
give me whatever's in the database

00:50:37.220 --> 00:50:39.440
instead of what I already have in memory.

00:50:41.870 --> 00:50:43.760
And finally,
require all variable bindings.

00:50:43.980 --> 00:50:45.860
We didn't talk so much
about variable bindings.

00:50:45.860 --> 00:50:49.800
In the other introduction to EOF talk,
they discussed variable bindings.

00:50:49.800 --> 00:50:54.000
But you can set placeholder variables
in your fetch specifications.

00:50:54.000 --> 00:50:56.140
So they're not fully
formed at this point,

00:50:56.140 --> 00:50:58.800
but you're going to do a
binding using your code.

00:50:58.800 --> 00:51:04.040
You'll set up a dictionary to bind those
query or qualifier variables and create

00:51:04.220 --> 00:51:06.730
a new fetch specification at runtime.

00:51:06.740 --> 00:51:10.980
So that can be really convenient to use
the fetch specification as a template

00:51:10.980 --> 00:51:12.640
for other fetches that you want to do.

00:51:14.700 --> 00:51:18.080
Okay, and then the final
panel is the SQL panel.

00:51:18.080 --> 00:51:20.400
And in this case,
we can see the raw SQL that's

00:51:20.400 --> 00:51:21.360
going to be generated.

00:51:21.360 --> 00:51:24.510
You can decide for a
complicated fetch specification,

00:51:24.510 --> 00:51:26.880
you could say, well, you know,
I could optimize that.

00:51:26.910 --> 00:51:28.660
I could write better SQL than EOF.

00:51:28.660 --> 00:51:33.640
So if you can do that,
then you say use the raw SQL expression.

00:51:33.640 --> 00:51:35.330
You give us an expression.

00:51:35.330 --> 00:51:40.390
It has to return the result set the
same way EOF would have returned it.

00:51:41.260 --> 00:51:45.050
I don't recommend you do this
unless you really know that you

00:51:45.140 --> 00:51:50.280
can get the best result and it's
much better than EOF can do.

00:51:50.280 --> 00:51:51.690
This is hard to maintain.

00:51:51.690 --> 00:51:54.880
When you change your objects,
EOF will do the right thing with

00:51:54.880 --> 00:51:56.780
all your fetch specifications.

00:51:56.780 --> 00:52:00.360
But, you know,
your raw SQL won't know the difference.

00:52:02.520 --> 00:52:05.540
And you can also mark stored
procedures to use to do your fetch.

00:52:05.540 --> 00:52:08.400
Instead of doing SQL at all,
you might call a stored procedure.

00:52:08.400 --> 00:52:11.320
Alright, we need to talk quickly
about inheritance.

00:52:11.320 --> 00:52:13.400
There's three kinds of inheritance.

00:52:13.400 --> 00:52:15.400
We're talking about entities that
are inheriting from other entities.

00:52:15.400 --> 00:52:17.990
As we've already
indicated in our example,

00:52:17.990 --> 00:52:21.530
we have a generic person,
and then professor and student

00:52:21.530 --> 00:52:23.330
both inherit from person.

00:52:23.400 --> 00:52:25.620
So, vertical inheritance.

00:52:25.620 --> 00:52:29.400
For vertical inheritance,
at the database level,

00:52:29.570 --> 00:52:34.400
we're mapping all the columns that
are common into the superclass.

00:52:34.400 --> 00:52:36.760
So we have one table for person,
which is holding the

00:52:36.760 --> 00:52:38.400
person ID in the last.

00:52:38.400 --> 00:52:41.400
Then we're creating for a professor,
which is a subentity of person,

00:52:41.400 --> 00:52:45.200
we have another database table,
the professor table.

00:52:45.490 --> 00:52:48.370
It has just the attributes
that are special to professor.

00:52:48.400 --> 00:52:52.300
It also has to have the same primary key
so we can match those up and do a join.

00:52:52.400 --> 00:52:55.390
But what's special for a professor
is that he has an office.

00:52:55.860 --> 00:52:58.400
Student, what's special about a student
is he has this advisor ID in

00:52:58.400 --> 00:52:58.400
the middle of the table.

00:52:58.400 --> 00:52:58.400
So he can see what's
going on in the table.

00:52:58.400 --> 00:52:58.400
So he can see what's
going on in the table.

00:52:58.400 --> 00:52:58.830
So he can see what's
going on in the table.

00:52:58.830 --> 00:52:59.400
So he can see what's
going on in the table.

00:52:59.400 --> 00:52:59.400
So he can see what's
going on in the table.

00:52:59.400 --> 00:53:03.640
the database we're going to use that as
the foreign key to map to our advisor

00:53:03.640 --> 00:53:07.510
object so for vertical inheritance
which is kind of the most natural if

00:53:07.630 --> 00:53:11.970
you're coming from an object or a point
of view everything that's common is in

00:53:11.980 --> 00:53:15.820
the superclass and then things that are
specific are mapped to specific tables

00:53:15.820 --> 00:53:20.400
we have to do a join to create a real
eo so we want to fetch a particular

00:53:20.940 --> 00:53:25.040
professor we have to fetch the parts
of the professor that are stored in the

00:53:25.130 --> 00:53:28.440
person table and then the parts that are
stored in the professor table join those

00:53:28.440 --> 00:53:31.610
up to make one EO for the professor.

00:53:31.960 --> 00:53:38.770
Another way to do inheritance is
to push those common attributes

00:53:39.140 --> 00:53:40.570
down into the other tables.

00:53:40.580 --> 00:53:42.960
So at this point,
we call it horizontal inheritance.

00:53:42.960 --> 00:53:48.910
We've taken things that were vertical,
pushed them down into, in this case,

00:53:48.990 --> 00:53:51.240
the professor table.

00:53:51.240 --> 00:53:53.560
Now it has everything
associated with a professor.

00:53:53.560 --> 00:53:59.090
So it has the person ID, the last name,
and the office, all in that one table.

00:53:59.900 --> 00:54:02.290
So now if we're fetching a professor,
we only have to fetch

00:54:02.360 --> 00:54:03.450
against that one table.

00:54:03.460 --> 00:54:07.780
If we're fetching a student,
we have a separate student table.

00:54:07.780 --> 00:54:11.220
He has a person ID, last name,
those are the common parts,

00:54:11.290 --> 00:54:13.160
and then he has a special advisor ID.

00:54:13.160 --> 00:54:14.540
Again, it's in that one table.

00:54:14.540 --> 00:54:17.690
If we're doing a deep fetch on person,
which is,

00:54:17.690 --> 00:54:21.790
now we're going to mark person abstract,
we might have had persons

00:54:22.050 --> 00:54:23.170
that weren't abstract.

00:54:23.170 --> 00:54:26.680
In our example, person's abstract,
so we don't have to worry about

00:54:26.680 --> 00:54:28.700
actually hitting a person table.

00:54:29.000 --> 00:54:32.770
If you might have generic persons,
then we'd have to fetch

00:54:32.770 --> 00:54:36.140
against that table first,
then we'd have to fetch each of

00:54:36.140 --> 00:54:39.510
the subentities individually,
and join all those results

00:54:39.510 --> 00:54:41.300
back to do a deep fetch.

00:54:42.310 --> 00:54:46.250
So that again could be a bit slower.

00:54:46.350 --> 00:54:50.440
A special case of inheritance is what
we call single table inheritance.

00:54:50.590 --> 00:54:55.190
In this case,
we make one database table with the

00:54:55.670 --> 00:55:00.180
union of all the attributes that
might be anywhere in this hierarchy.

00:55:00.470 --> 00:55:07.150
By doing this, we can do a deep fetch by
using one select statement

00:55:07.150 --> 00:55:09.730
against the database table.

00:55:09.730 --> 00:55:13.160
And then EOF has to figure out,
as we're pulling rows back, well,

00:55:13.160 --> 00:55:16.130
is this a professor, is this a student,
maybe this is a generic person.

00:55:16.140 --> 00:55:18.300
We can do that one select,
pull them back,

00:55:18.300 --> 00:55:21.560
and figure out which ones they are,
give you your result set.

00:55:21.590 --> 00:55:25.660
So if you're doing inheritance
and you don't have too complicated

00:55:25.660 --> 00:55:31.090
of an inheritance hierarchy,
I recommend you use single table

00:55:31.090 --> 00:55:33.500
inheritance for performance reasons.

00:55:33.500 --> 00:55:39.910
You will have to leave some columns null,
right, because even though the student

00:55:40.020 --> 00:55:45.170
has a row in the database,
the student doesn't have an office.

00:55:45.170 --> 00:55:47.290
So that would have to be
null for that student.

00:55:47.300 --> 00:55:51.690
So you need to have a little
bit of flexibility in how you're

00:55:51.700 --> 00:55:54.360
defining your table in order to
make single table inheritance work.

00:55:54.360 --> 00:55:58.200
We've also added an extra column called
ptype that's special for the database.

00:55:58.200 --> 00:56:00.290
That's special for
single table inheritance.

00:56:00.440 --> 00:56:08.270
We're using ptype to declare exactly
what type of value we have in that row.

00:56:08.440 --> 00:56:11.830
So we're using a 1 to be a professor,
a 2 to be a student.

00:56:11.900 --> 00:56:15.370
EOF needs some kind of restricting
qualifier that we talked about

00:56:15.400 --> 00:56:20.200
earlier to know exactly how to
create the right kind of EO for you.

00:56:21.240 --> 00:56:25.170
Okay, we're going to go back to the demo,
and I think we have

00:56:25.170 --> 00:56:26.580
to be very brief here.

00:56:33.950 --> 00:56:36.220
I think actually since
we're running low on time,

00:56:36.220 --> 00:56:37.580
I want to save time for questions.

00:56:37.580 --> 00:56:41.320
So we'll just show this to you quickly
and then I think we'll end after that.

00:56:42.950 --> 00:56:46.290
So we can see here,
Ernest has brought up two different

00:56:46.340 --> 00:56:47.840
viewers on the same model.

00:56:47.900 --> 00:56:52.900
And you can see person has the
common types just like our graph.

00:56:52.900 --> 00:56:56.840
The student has one extra attribute,
advisor.

00:56:56.910 --> 00:57:01.930
The other things that are common
to the superclass are actually,

00:57:02.000 --> 00:57:05.400
the other attributes are written in
italic type to suggest that you're

00:57:05.400 --> 00:57:07.890
inheriting these from the person.

00:57:08.000 --> 00:57:10.160
So let's just inspect student.

00:57:14.120 --> 00:57:16.890
So in this inspector,
the important thing is

00:57:16.890 --> 00:57:18.640
restricting qualifier,
ptype equals 2.

00:57:18.640 --> 00:57:19.540
That's how we distinguish.

00:57:19.670 --> 00:57:20.760
We're in single table.

00:57:20.820 --> 00:57:22.540
We pull an individual row out.

00:57:22.560 --> 00:57:24.550
What kind of EO should we create?

00:57:24.750 --> 00:57:27.680
We're going to use that ptype
equal 2 restricting qualifier

00:57:27.680 --> 00:57:29.280
to know this thing is a student.

00:57:29.280 --> 00:57:30.710
It's not an generic person.

00:57:30.710 --> 00:57:32.140
It's not a professor.

00:57:32.330 --> 00:57:34.850
And you can see the parent
was marked as a person.

00:57:34.850 --> 00:57:38.090
So that's how we're determining
what we're inheriting from.

00:57:38.150 --> 00:57:39.640
You only had to add the advisor.

00:57:39.750 --> 00:57:43.490
You didn't have to declare
all those other attributes.

00:57:44.180 --> 00:57:47.030
So maybe we can just,
let's just browse person

00:57:47.040 --> 00:57:49.370
and that will finish it.

00:57:49.450 --> 00:57:51.970
So if we browse data for person,
you can see everything's

00:57:52.110 --> 00:57:54.040
stored in one database table.

00:57:54.040 --> 00:57:56.650
The p-type column is different.

00:57:56.660 --> 00:57:59.530
Worcester and Jeeves
are actually professors,

00:57:59.530 --> 00:58:02.960
they're type 1,
and Fink-Nottle and Little are students,

00:58:02.990 --> 00:58:03.960
they're type 2.

00:58:05.220 --> 00:58:07.720
Okay, I think I'm gonna wrap up here.

00:58:07.870 --> 00:58:10.350
There's more you can do with EOModeler.

00:58:10.350 --> 00:58:13.620
I'm going to be in the lab after
the talk and we'll have other people

00:58:13.620 --> 00:58:16.490
in the lab all during the day,
so you can come experiment with models

00:58:16.490 --> 00:58:19.490
and ask particular questions about
how you want to model certain objects.

00:58:19.500 --> 00:58:22.490
Can we go back to the slides, please?

00:58:24.600 --> 00:58:25.570
Okay.

00:58:25.610 --> 00:58:31.820
We've run late, so I have to whiz through
the adapter information.

00:58:32.210 --> 00:58:34.670
The important thing to
know is for WebObjects 5,

00:58:34.840 --> 00:58:36.740
the JDBC adapter is the adapter.

00:58:36.740 --> 00:58:38.070
This is the one we're giving you.

00:58:38.120 --> 00:58:44.370
The nice thing about JDBC is it gets
to all kinds of different databases.

00:58:44.370 --> 00:58:44.370
We have...

00:58:44.980 --> 00:58:48.620
We have great connectivity
because we're using JDBC.

00:58:48.770 --> 00:58:51.710
Almost every database vendor
is delivering a JDBC driver.

00:58:52.010 --> 00:58:53.130
We can talk to that.

00:58:53.240 --> 00:58:58.440
We've done specific work
with Oracle and OpenBase,

00:58:58.450 --> 00:59:03.770
but other things can be
added to our JDBC adapter.

00:59:04.210 --> 00:59:09.400
One thing about JDBC,
JDBC doesn't really stand for anything.

00:59:09.440 --> 00:59:12.580
It's just a bunch of letters
that Sun had trademarked,

00:59:12.680 --> 00:59:18.790
but you can think of it as ODBC for Java.

00:59:19.900 --> 00:59:25.160
So in your connection dictionary,
the important thing is to set a JDBC URL.

00:59:25.160 --> 00:59:28.100
That's determined by your
database vendor or the particular

00:59:28.100 --> 00:59:30.040
JDBC driver you're using.

00:59:30.040 --> 00:59:34.660
You need to know the details of that,
and that can be a little bit complicated.

00:59:34.660 --> 00:59:37.400
We have two examples here
of Oracle and OpenBase.

00:59:37.400 --> 00:59:40.800
If you're using some other driver,
figure out from the documentation

00:59:40.800 --> 00:59:42.360
how you want to address that.

00:59:42.400 --> 00:59:45.560
Our plugin is our way of adding
special behavior that works

00:59:45.560 --> 00:59:47.560
for that particular datasource.

00:59:47.560 --> 00:59:51.080
By default,
we'll guess it by looking at the

00:59:51.170 --> 00:59:53.770
subprotocol in your JDBC URL.

00:59:53.800 --> 00:59:57.820
And you can programmatically
decide to use certain plugins

00:59:57.820 --> 01:00:00.060
for a subprotocol name.

01:00:00.060 --> 01:00:01.650
So you have some control of
that in your application.

01:00:01.660 --> 01:00:04.710
The driver, again,
we'll try to guess that.

01:00:04.870 --> 01:00:08.560
If you're using Oracle,
we'll guess the right plugin.

01:00:08.560 --> 01:00:11.660
The plugin will guess which
driver to try to load.

01:00:11.660 --> 01:00:14.580
You have to make sure that
driver is available at runtime,

01:00:14.580 --> 01:00:20.620
and the easiest place to do that is to
put it into your Java VM's X directory.

01:00:20.620 --> 01:00:26.960
So on MacOSX,
that would be in library/java/home/lib/x.

01:00:26.970 --> 01:00:30.460
This is documented on different
platforms where you can put these things.

01:00:30.460 --> 01:00:31.960
You can put it in your
class path anywhere.

01:00:31.960 --> 01:00:34.520
Just make it available at runtime.

01:00:34.900 --> 01:00:37.350
We can experiment with models
and if we don't have time

01:00:37.360 --> 01:00:41.130
for all the questions here,
I'll be in the lab after this talk.

01:00:42.160 --> 01:00:45.400
So the other talks that
are coming up today,

01:00:45.400 --> 01:00:49.690
DirectWeb's right after this,
the Advanced Enterprise Objects Framework

01:00:49.770 --> 01:00:53.410
is a really good talk if you want to
get more into advanced topics in EUF.
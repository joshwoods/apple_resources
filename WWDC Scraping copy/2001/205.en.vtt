WEBVTT

00:00:02.950 --> 00:00:03.800
Good morning.

00:00:04.250 --> 00:00:07.800
Welcome to session 205, I/O Kit:
PCI Drivers & Open Firmware.

00:00:07.860 --> 00:00:08.630
My name is Mark Tozer.

00:00:08.640 --> 00:00:10.800
I'm Desktop Technology Manager.

00:00:11.080 --> 00:00:14.690
Today we're going to go over a
couple areas here with I/O Kit,

00:00:14.810 --> 00:00:19.030
specifically with the
PCI driver development and

00:00:19.030 --> 00:00:22.890
assistance in also determining
how to get into open firmware,

00:00:23.070 --> 00:00:23.800
what to look at open firmware.

00:00:23.800 --> 00:00:28.820
We'll actually have some demos of looking
at a couple of PCI cards and actually

00:00:28.830 --> 00:00:31.800
looking at the open firmware code there.

00:00:31.960 --> 00:00:35.640
So today we'll start off the
morning with Wayne Flansburg

00:00:35.640 --> 00:00:38.120
who will give this presentation.

00:00:41.940 --> 00:00:42.900
Good morning.

00:00:43.010 --> 00:00:46.900
Let's begin.

00:00:46.900 --> 00:00:51.350
We think the session audience should be
people that are interested in generic

00:00:51.610 --> 00:00:55.900
PCI cards and hardware developers.

00:00:55.900 --> 00:01:01.230
And we think the audience also might
include people that are writing drivers

00:01:01.380 --> 00:01:05.700
for that and hardware testers and just
people that are generally interested

00:01:05.700 --> 00:01:09.090
in low level PCI stuff and booting.

00:01:09.920 --> 00:01:13.390
So what is a generic PCI device?

00:01:13.480 --> 00:01:15.850
Well, it doesn't belong to a framework.

00:01:15.970 --> 00:01:22.750
That's the biggest thing is you
don't have a FireWire framework or

00:01:22.750 --> 00:01:29.500
a USB framework or any framework
at all except I/O service,

00:01:29.620 --> 00:01:31.490
which is quite a lot.

00:01:31.770 --> 00:01:34.300
Your device is unique
to your application.

00:01:34.390 --> 00:01:38.670
Nobody's going to try to install
their driver or run their

00:01:38.670 --> 00:01:41.490
application onto your device.

00:01:41.560 --> 00:01:47.500
Your device could be a sonar device,
a radar device, something that isn't

00:01:47.640 --> 00:02:03.400
Mark Tozer-Vilchez, Wayne Flansburg,
Josh de Cesare, Steve Martin, Jason Seng

00:02:04.070 --> 00:02:08.330
So the session agenda is basically
we're going to look at OpenFirm,

00:02:08.340 --> 00:02:09.980
we're going to boot a device.

00:02:09.980 --> 00:02:11.780
We're going to boot one computer.

00:02:11.880 --> 00:02:15.000
We're going to stop in the
OpenFirm or user interface.

00:02:15.100 --> 00:02:18.340
And we're going to look at some devices
and we're going to look at some support

00:02:18.340 --> 00:02:20.000
nodes that are important to you.

00:02:20.000 --> 00:02:24.840
And then we're going to go and
look at the same stuff over again,

00:02:24.840 --> 00:02:28.000
but this time using the I/O registry.

00:02:28.130 --> 00:02:32.040
And then we're going to talk
about a generic PCI driver and

00:02:32.040 --> 00:02:34.390
finally we'll have a Q&A session.

00:02:35.200 --> 00:03:37.700
[Transcript missing]

00:03:38.290 --> 00:03:42.280
So we're going to start
with the open firmware.

00:03:42.280 --> 00:03:44.480
The device tree,
we're going to look at nodes in there.

00:03:44.480 --> 00:03:46.210
We're going to look at
configuration variables.

00:03:46.400 --> 00:03:52.360
Configuration variables have some
very important aspects for you that

00:03:52.490 --> 00:03:54.200
we'd like to talk to you about today.

00:03:54.200 --> 00:03:58.200
And we're going to show you how to,
from open firmware user interface,

00:03:58.540 --> 00:04:02.700
using your reg properties,
how to actually read

00:04:02.700 --> 00:04:04.800
your configuration space.

00:04:04.800 --> 00:04:10.800
And we're doing this because we want
you to be able to get a new computer,

00:04:10.960 --> 00:04:13.870
plug your device in there,
and make sure before you do

00:04:13.870 --> 00:04:17.400
anything that your device is
recognized and built correctly

00:04:17.400 --> 00:04:20.390
into the open firmware device tree.

00:04:20.400 --> 00:04:23.950
And we're going to mention
something about security.

00:04:24.570 --> 00:04:28.590
So the device tree is a block
diagram of the motherboard,

00:04:28.590 --> 00:04:29.190
but it's more.

00:04:29.300 --> 00:04:32.070
As I mentioned earlier,
it has the support nodes in it,

00:04:32.260 --> 00:04:38.200
but it also, OpenFirmware,
during its building of the device tree,

00:04:38.200 --> 00:04:44.440
goes out and looks at all the PCI slots,
and if it finds a card in there,

00:04:44.630 --> 00:04:47.730
builds the node for you
or allows you to build it.

00:04:47.780 --> 00:04:53.500
And in there you have your properties,
your words, and if you have children,

00:04:53.540 --> 00:04:55.620
they'll also show up in there.

00:04:55.620 --> 00:04:59.970
Your words are only present,
they're optional,

00:04:59.980 --> 00:05:05.560
if you have a device that is
participating in the boot process,

00:05:05.610 --> 00:05:09.420
such as an Ethernet
device or display device.

00:05:09.600 --> 00:05:25.490
Mark Tozer-Violchez, Wayne Flansburg,
Josh de Cesare, Steve Martin, Jason Seng

00:05:25.700 --> 00:05:29.860
this is a block diagram of the
target machine we have up here.

00:05:29.860 --> 00:05:33.740
This is one of our
latest desktop machines,

00:05:33.740 --> 00:05:36.120
and we're not going to
boot it up entirely,

00:05:36.120 --> 00:05:40.710
but when you buy this machine,
you can get the developer note for

00:05:40.920 --> 00:05:47.090
that machine off of our web page,
and in that developer note,

00:05:47.100 --> 00:05:48.840
you can look at this block diagram.

00:05:48.840 --> 00:05:54.120
The reason this is important to you is
many people will come to DTS and say,

00:05:54.380 --> 00:05:57.300
with this last machine,
my device stopped working.

00:05:57.300 --> 00:05:59.070
What did you change?

00:05:59.180 --> 00:06:02.060
Well, you don't really have to ask us.

00:06:02.180 --> 00:06:05.410
We're going to try to teach you
enough so you can get a reasonably

00:06:05.580 --> 00:06:09.790
quick look with knowing very little
about open firmware and everything

00:06:09.790 --> 00:06:16.150
else so that you can see what may
have changed and start from there.

00:06:16.160 --> 00:06:19.120
So we're hoping to give
you some leverage there.

00:06:20.720 --> 00:06:22.160
Now we're going to display your node.

00:06:22.160 --> 00:06:23.950
We're using Telnet to do that.

00:06:24.100 --> 00:06:25.400
Last year we used Telnet.

00:06:25.500 --> 00:06:28.340
This year we-- or last
year we didn't use Telnet.

00:06:28.450 --> 00:06:34.440
This year we're using Telnet and we're
going to show you your whole tree,

00:06:34.440 --> 00:06:37.480
including your node,
from the Mac OS X host system

00:06:37.480 --> 00:06:39.400
that is connected up to it.

00:06:39.400 --> 00:06:43.880
And like I said earlier,
we'll display your words, properties,

00:06:43.880 --> 00:06:47.790
and children, if you have children
and if you have words,

00:06:47.800 --> 00:06:49.200
but you definitely have properties.

00:06:50.110 --> 00:06:57.490
This is from the PCI bus
binding to IEEE 1275.

00:06:57.490 --> 00:07:02.000
It's just one section that we took out,
but it's extremely important.

00:07:02.000 --> 00:07:06.000
I'd like to talk about
that just for a moment.

00:07:06.000 --> 00:07:09.290
This is difficult to read,
so I'm not going to go

00:07:09.290 --> 00:07:15.000
into it in great detail,
but what you see here is the bits.

00:07:15.000 --> 00:07:22.000
From 00 to 31, and you see FIS high,
FIS mid, and FIS low.

00:07:22.000 --> 00:07:26.560
FIS high is really very,
very important to you because it is

00:07:26.560 --> 00:07:31.540
how all the bridge controllers route
messages from your virtual memory

00:07:31.540 --> 00:07:40.000
space on the host bus down through
the hierarchy of ASICs on your bus.

00:07:40.000 --> 00:07:42.550
Forgetting this N, P,
and T thing that are there

00:07:42.550 --> 00:07:44.000
for a lot of legacy devices.

00:07:44.000 --> 00:07:50.130
You have a space code,
which is either configuration space,

00:07:50.130 --> 00:07:52.000
memory space, or I/O space.

00:07:52.000 --> 00:07:55.000
But you also have 8 bits for your bus.

00:07:55.000 --> 00:08:00.100
So you can have 256 buses,
and you can have 32 devices on a bus,

00:08:00.660 --> 00:08:07.360
and you can have 8 functions per device,
and you can have 256

00:08:07.360 --> 00:08:09.810
registers per device.

00:08:10.000 --> 00:08:13.000
So how do we get that
message down to you?

00:08:13.000 --> 00:08:15.000
We set it down to you in FIS high.

00:08:15.010 --> 00:08:20.120
And we put that out onto the PCI bus,
and the controllers know

00:08:20.760 --> 00:08:24.070
enough to recognize that this
message that's coming down,

00:08:24.070 --> 00:08:28.000
and they got one clock period to do this,
30 nanoseconds today I guess.

00:08:28.000 --> 00:08:31.990
They got one clock period to
say that this is not for me,

00:08:31.990 --> 00:08:36.670
or this is for me,
or it's for my children.

00:08:37.000 --> 00:08:39.520
And if it's for my children,
it changes the type of message

00:08:39.520 --> 00:08:41.850
and sends it down through
the bridge to the network.

00:08:42.250 --> 00:08:44.970
So that's how we get there.

00:08:45.000 --> 00:08:51.000
And then FIS mid and FIS low
are the 64-bit addresses.

00:08:51.000 --> 00:08:56.460
Presently, we only have a 32-bit bus,
but the standard allows for

00:08:56.520 --> 00:09:00.000
going to 64 bits in the future.

00:09:00.000 --> 00:09:07.080
So today you'll see that all the H's,
the FIS mid, is always 0.

00:09:07.680 --> 00:09:12.310
and now I'm going to ask
Steve Martin to come up and demo

00:09:12.900 --> 00:09:15.080
using Telnet in a host computer

00:09:21.110 --> 00:09:25.290
What we've done here is we've put
a machine in Open Firmware already.

00:09:25.290 --> 00:09:27.370
Open Firmware,
we're at a pretty low level.

00:09:27.370 --> 00:09:31.100
We don't really have the ability
to cut and paste or scroll back up.

00:09:31.300 --> 00:09:33.930
And we don't have much of a
way to save any of our data.

00:09:34.100 --> 00:09:40.100
What we've done with this machine
is we've used the Telnet app on 10

00:09:40.100 --> 00:09:45.690
in the terminal program to link back
in to the Open Firmware machine to

00:09:45.690 --> 00:09:50.100
give us an interface that allows
us to save and capture our data.

00:09:50.100 --> 00:09:54.100
So what I'm going to do here is what
Wayne was showing on the slide above.

00:09:54.100 --> 00:10:00.770
I'm going to select the root node
of the device that we're looking at.

00:10:01.350 --> 00:10:07.280
and that's the dev is the word that
select that used is used to select

00:10:07.280 --> 00:10:12.530
our device and I'll list that and
what you can see here is that this

00:10:12.600 --> 00:10:19.390
is roughly a representation in text
of the same hardware block diagram

00:10:20.580 --> 00:10:22.990
that Wayne was showing before.

00:10:24.100 --> 00:10:28.840
We have children,
those are the indented text and we'll

00:10:28.840 --> 00:10:35.600
go down here to where is it right about.

00:10:36.120 --> 00:10:42.690
Here is our PCI bridge and we have
two cards on this machine and they

00:10:42.920 --> 00:10:47.240
show up right here and right here.

00:10:47.430 --> 00:10:49.560
We'll select that one.

00:10:49.900 --> 00:11:05.000
[Transcript missing]

00:11:06.200 --> 00:11:46.700
[Transcript missing]

00:11:50.900 --> 00:11:59.800
Note here that we have the vendor ID,
the device ID, and the revision ID.

00:11:59.880 --> 00:12:04.440
Are we going to go to the
slide that shows the... No,

00:12:04.440 --> 00:12:04.930
I don't think so.

00:12:05.090 --> 00:12:05.800
Mark Tozer- Okay.

00:12:06.040 --> 00:12:10.190
Well,
I want you to note those and we'll go...

00:12:11.110 --> 00:12:14.680
Use a word that is actually,
we've got a Q&A up on it,

00:12:14.680 --> 00:12:20.330
it's QA 1036 called Cregs,
that will put this in a format that you'd

00:12:20.340 --> 00:12:27.090
be used to seeing in a configuration
register dump from your card.

00:12:27.200 --> 00:12:31.090
And we'll use Fizz High,
this is Fizz High right here under the

00:12:31.090 --> 00:12:33.640
Reg node that Wayne was talking about.

00:12:36.820 --> 00:12:44.690
So I'll use that fishigh to start
this word as an input for this word.

00:12:44.720 --> 00:12:47.460
That's one.

00:12:47.480 --> 00:12:49.490
That's .crigs.

00:12:58.710 --> 00:12:59.440
There you go.

00:12:59.590 --> 00:13:09.920
And you noticed here in the block
diagram up above that the vendor ID

00:13:10.790 --> 00:13:16.620
and the device ID are the same
as the first two entries here.

00:13:16.620 --> 00:13:21.510
This is in a format that comes
right out of the PCI spec.

00:13:21.860 --> 00:13:23.540
and Wayne, you want to?

00:13:23.630 --> 00:13:26.980
Yeah, let's go back to this machine,
which is two.

00:13:27.600 --> 00:13:30.360
Let's go to the next slide.

00:13:30.380 --> 00:13:33.150
This is the PCI configuration space.

00:13:33.220 --> 00:13:40.010
Now that demo we just showed you,
it's difficult to show a demo like

00:13:40.010 --> 00:13:44.600
this to an audience for the first time,
but we do have the demo replicated,

00:13:44.600 --> 00:13:47.890
as Steve said,
on the site so you can stop

00:13:47.890 --> 00:13:50.190
on your own and look at it.

00:13:50.420 --> 00:13:58.030
You as a PCI developer must supply a
PCI configuration space of 64 headers.

00:13:58.210 --> 00:14:04.120
The blue ones are mandatory.

00:14:04.120 --> 00:14:04.120
So the device ID and the

00:14:04.800 --> 00:14:13.110
The device ID and the vendor ID are,
as you saw, in mine.

00:14:13.500 --> 00:14:25.400
[Transcript missing]

00:14:26.900 --> 00:15:32.300
[Transcript missing]

00:15:33.210 --> 00:15:40.450
The end input parameter
on the stack for .cregs.

00:15:40.450 --> 00:15:47.260
And if you look at this
before you go any further,

00:15:47.260 --> 00:15:48.390
if you just get into the
Open Firmware user interface and

00:15:48.390 --> 00:15:48.390
go down and do this kind of stuff,
and you find out that

00:15:49.040 --> 00:15:52.490
This doesn't look like
I thought it would look.

00:15:52.630 --> 00:15:53.510
Don't boot.

00:15:53.840 --> 00:15:54.940
Don't go any further.

00:15:55.190 --> 00:15:57.300
The damage is already done.

00:15:57.410 --> 00:16:01.860
And it's very important that you
know how to see that your device tree

00:16:01.860 --> 00:16:08.140
was built correctly because OS X or
any client of open firmware believes

00:16:08.140 --> 00:16:10.130
that the device tree is correct.

00:16:10.270 --> 00:16:13.790
And if it isn't, then the game's over.

00:16:14.930 --> 00:16:24.460
So let's look at some of the support
nodes that are going to-- oh,

00:16:24.460 --> 00:16:24.460
wrong thing.

00:16:24.460 --> 00:16:24.460
Some of the support nodes.

00:16:24.860 --> 00:16:27.690
I'm going to have Steve,
we're bouncing back and forth

00:16:27.760 --> 00:16:30.740
because you've got to talk about
this stuff and then show the example.

00:16:30.920 --> 00:16:33.590
Steve in a moment is
going to do printenv.

00:16:33.710 --> 00:16:36.880
For the Unix people out there
you've probably noticed that dev

00:16:37.340 --> 00:16:45.080
and slash and ls and now printenv
looks a lot like Unix stuff.

00:16:45.810 --> 00:16:49.270
and we're going to look at
those words that word and we're

00:16:49.270 --> 00:16:52.770
going to look at three of the

00:16:53.660 --> 00:17:00.020
Mark Tozer-Violchez, Wayne Flansburg,
Josh de Cesare, Steve Martin, Jason Seng

00:17:01.910 --> 00:17:03.560
Is that what you wanted?

00:17:03.670 --> 00:17:03.910
Yes.

00:17:04.190 --> 00:17:08.820
What got printed here was all
the configuration variables.

00:17:08.970 --> 00:17:13.320
These are the open firmware configuration
variables and they're mentioned in

00:17:13.320 --> 00:17:16.460
IEEE 1275 and in that PCI binding.

00:17:16.660 --> 00:17:20.630
And you'll see things that
are probably important to you.

00:17:20.720 --> 00:17:21.950
Some of these are.

00:17:22.400 --> 00:17:25.640
One of the devices,
there's two columns here.

00:17:25.660 --> 00:17:29.970
One column, the far column,
is what's stored in boot ROM,

00:17:29.970 --> 00:17:31.620
factory defaults.

00:17:31.660 --> 00:17:35.660
The other column is current.

00:17:35.660 --> 00:17:38.850
So if you were in OS X and you
were in the terminal app and you

00:17:38.850 --> 00:17:42.660
started setting some configuration
variables and you wanted to see

00:17:42.660 --> 00:17:47.740
that those were actually set,
you could shut the machine off,

00:17:47.740 --> 00:17:52.390
boot back into open firmware,
and type printenv.

00:17:52.890 --> 00:17:57.190
Print ENV and you can see what
the current values are and in

00:17:57.190 --> 00:17:59.800
fact if you set it correctly.

00:17:59.800 --> 00:18:03.550
We're going to be looking at boot device
later with the boot picker because

00:18:04.120 --> 00:18:06.940
that's also a very important device.

00:18:07.010 --> 00:18:11.490
It's the only one that's off scale over
there and the real important thing is

00:18:11.970 --> 00:18:18.200
that that comma separates one from the
other and it's a very important device.

00:18:20.460 --> 00:18:22.620
and we'll tell you more about that later.

00:18:22.740 --> 00:18:26.370
One other one that's important too,
a lot of people want to know about

00:18:26.490 --> 00:18:28.890
what is and what isn't in NVRAM.

00:18:29.000 --> 00:18:34.670
NVRAM is in here and because on this
machine it doesn't show anything,

00:18:34.670 --> 00:18:38.160
there isn't anything in NVRAM.

00:18:38.280 --> 00:18:41.210
And even if we were to put
something in NVRAM right now,

00:18:41.450 --> 00:18:48.610
that script would not be used unless
you set the use NVRAM RC question

00:18:48.700 --> 00:18:53.790
mark variable to turn it on.

00:18:54.030 --> 00:18:57.710
So let's look at the aliases node.

00:19:06.010 --> 00:19:14.000
The importance here is that open firmware
has to be able to move down a path.

00:19:14.000 --> 00:19:18.990
And the path, when it looks at a
string that you give it,

00:19:19.060 --> 00:19:23.600
it's either going to start
with a slash or it isn't.

00:19:23.600 --> 00:19:27.370
If it starts with a slash,
it's an absolute path.

00:19:27.560 --> 00:19:30.000
But you can see some of
these paths are terrible.

00:19:30.000 --> 00:19:31.590
And if we stood up
here and tried to type,

00:19:31.690 --> 00:19:35.700
we'd die of old age before
we maybe got the right one.

00:19:35.780 --> 00:19:38.450
So these aliases are very important.

00:19:38.500 --> 00:19:40.900
But there's a caveat with aliases.

00:19:40.990 --> 00:19:44.870
And that is that the aliases on
one machine might not be the same

00:19:44.970 --> 00:19:46.900
aliases on the other machine.

00:19:47.030 --> 00:19:51.270
And although you can create your own,
and we expect you would if you were doing

00:19:51.270 --> 00:19:54.690
a lot of booting and stuff like that,
you need to check this.

00:19:54.810 --> 00:19:56.780
So devalias is another command.

00:19:56.800 --> 00:20:00.660
And all of this stuff,
we're not giving you anything that we

00:20:00.660 --> 00:20:03.600
haven't put out on the internet already.

00:20:03.790 --> 00:20:07.550
So there's two other nodes
that are very important.

00:20:07.600 --> 00:20:10.200
And that's the chosen
and the options node.

00:20:10.200 --> 00:20:14.670
But let's look at the options node first.

00:20:30.480 --> 00:20:35.280
One of the things you'll notice on
your own spare time is what we did

00:20:35.280 --> 00:20:39.960
was we dev down to the options node
and then we listed the properties.

00:20:40.060 --> 00:20:43.900
But when we said printenv,
we saw these properties.

00:20:44.040 --> 00:20:48.160
So printenv is a nice way to
print the environmental variables,

00:20:48.160 --> 00:20:50.460
but they're really
configuration variables and

00:20:50.460 --> 00:20:53.730
they live in the options node.

00:20:53.830 --> 00:20:57.700
And you need to know that
because people don't.

00:20:57.800 --> 00:21:03.240
And it's very important and you
can very quickly see what are

00:21:03.280 --> 00:21:05.200
your configuration variables.

00:21:05.290 --> 00:21:09.300
The other node that's of
importance is the chosen node.

00:21:09.410 --> 00:21:11.050
You wanted us to do something?

00:21:11.380 --> 00:21:18.650
When we're done, we put stuff that we did
for you in the chosen node.

00:21:26.520 --> 00:21:28.900
The Mac Address.

00:21:28.920 --> 00:21:31.350
Every Ethernet card has
to have a Mac address.

00:21:31.650 --> 00:21:34.490
So you stuff your machine with

00:21:34.880 --> 00:21:49.770
Mark Tozer-Violchez, Wayne Flansburg,
Josh de Cesare, Steve Martin, Jason Seng

00:21:50.070 --> 00:21:50.950
This one.

00:21:51.020 --> 00:21:56.710
I don't know which one that points to,
but at least that's the one.

00:22:01.130 --> 00:22:04.280
This machine has never
been set up entirely,

00:22:04.280 --> 00:22:06.950
but your boot path and
your boot arguments,

00:22:07.000 --> 00:22:09.260
if you had them, would have been there.

00:22:09.560 --> 00:22:12.170
So those three nodes, the

00:22:15.000 --> 00:22:22.100
The choices node, the chosen node,
and the options node are

00:22:22.100 --> 00:22:22.100
all very important to you.

00:22:23.200 --> 00:23:09.400
[Transcript missing]

00:23:09.780 --> 00:23:12.730
When Open Firmware boots up,
if you're holding down the command

00:23:12.770 --> 00:23:17.410
option PR keys for parameter RAM,
which would set those defaults

00:23:17.410 --> 00:23:20.820
back that I showed you for
the configuration variables,

00:23:20.820 --> 00:23:26.080
Open Firmware first checks to see if the
amount of memory you have in the machine

00:23:26.080 --> 00:23:31.380
is different than when it's shut down,
i.e., you had three sticks when you shut

00:23:31.380 --> 00:23:36.110
down and now you only have two sticks,
it will unset the security for you.

00:23:36.350 --> 00:23:39.520
The good news is that it comes benign.

00:23:39.520 --> 00:23:43.260
If you don't know how to set it,
you can use the machine forever

00:23:43.790 --> 00:23:45.240
and it will never bite you.

00:23:45.260 --> 00:23:48.700
It will always just sit
there and do nothing.

00:23:48.820 --> 00:23:52.060
So that's a good feature of it.

00:23:52.200 --> 00:24:23.700
[Transcript missing]

00:24:24.230 --> 00:24:27.360
If you have a number of
SCSI devices out there,

00:24:27.360 --> 00:24:31.750
and if there are SCSI people here,
I have to ask you afterwards

00:24:31.890 --> 00:24:34.200
to come up and see me.

00:24:34.250 --> 00:24:37.930
And I want to get your business card
and give you my business card because

00:24:37.930 --> 00:24:41.200
Paul's group has a request of the SCSI.

00:24:41.330 --> 00:24:45.030
They want a new feature
placed into the SCSI drivers.

00:24:45.200 --> 00:24:49.200
Whenever Open Firmware goes out,
it doesn't know it's connected to SCSI.

00:24:49.260 --> 00:24:53.150
So if you have a bunch of
SCSI devices connected up,

00:24:53.200 --> 00:24:57.220
it's going to have to go,
"Are you there?" 1, 2, 3, 4, 5, 6, 7, oh,

00:24:57.260 --> 00:24:58.190
nobody's there.

00:24:58.260 --> 00:25:01.130
"Are you there?" And it's got
to do it a number of times,

00:25:01.360 --> 00:25:05.170
and that adds considerable to
the amount of time to boot.

00:25:05.200 --> 00:25:08.590
Basically,
the firmware goes off and looks at the

00:25:08.590 --> 00:25:13.840
boot device configuration variable,
and it goes out there and

00:25:13.840 --> 00:25:16.200
tries to use it first.

00:25:16.220 --> 00:25:16.690
And also, since Open Firmware is
not connected to SCSI,

00:25:16.690 --> 00:25:17.200
it's going to have to
do it a number of times.

00:25:17.200 --> 00:25:18.180
And that adds considerable to
the amount of time to boot.

00:25:18.220 --> 00:25:18.720
Basically,
the firmware goes off and looks at the

00:25:18.720 --> 00:25:19.200
boot device configuration variable,
and it goes out there and

00:25:19.200 --> 00:25:19.200
tries to use it first.

00:25:19.220 --> 00:25:21.200
And so it's not using interrupts.

00:25:21.340 --> 00:25:25.750
Although Command Period, I think,
will tell the boot

00:25:25.750 --> 00:25:30.180
picker to stop picking,
looking for boot devices,

00:25:30.640 --> 00:25:32.940
Command Period won't
be honored instantly,

00:25:33.060 --> 00:25:36.170
because it might be out
waiting for a SCSI device.

00:25:36.200 --> 00:25:38.460
But when it's done,
it comes back to see if

00:25:38.460 --> 00:25:40.200
there were some key presses.

00:25:40.200 --> 00:25:44.320
So basically,
the boot picker displays the Rescan

00:25:44.630 --> 00:25:48.200
and the Boot buttons and searches the
device tree for all the bootable volume.

00:25:48.200 --> 00:25:49.700
volume.

00:25:50.370 --> 00:25:54.740
Very interesting address.

00:25:54.800 --> 00:25:58.140
This is a hybrid syntax in this.

00:25:58.230 --> 00:26:01.290
Remember the slash said it
was an absolute address.

00:26:01.510 --> 00:26:02.710
That's the PCI.

00:26:02.800 --> 00:26:05.040
That's the node name.

00:26:05.300 --> 00:26:09.390
The @8k is the unit address.

00:26:09.740 --> 00:26:13.150
That's in 1275.

00:26:13.150 --> 00:26:17.300
I think it's in section 3.2.1.1.

00:26:17.300 --> 00:26:21.420
This slash says now I'm going
down to the Mac I/O chip,

00:26:21.560 --> 00:26:26.300
which is the chip that goes out and has
all the ATA drives and everything else.

00:26:26.300 --> 00:26:29.270
And it's at that unit address.

00:26:29.410 --> 00:26:32.300
Then it goes down to this
ATI drive at that unit address

00:26:32.300 --> 00:26:36.760
and comes all the way down here.

00:26:36.760 --> 00:26:36.760
And then,

00:26:37.930 --> 00:26:41.340
This part of it here,
notice you have forward slashes

00:26:41.420 --> 00:26:44.510
and back slashes from here on out.

00:26:44.790 --> 00:26:57.880
Mark Tozer-Violchez, Wayne Flansburg,
Josh de Cesare, Steve Martin, Jason Seng

00:26:58.300 --> 00:27:16.600
[Transcript missing]

00:27:17.460 --> 00:27:22.960
and he's going to basically show you the

00:27:24.070 --> 00:27:25.740
The I/O registry and its planes.

00:27:25.980 --> 00:27:29.740
This is another very,
very important aspect.

00:27:29.790 --> 00:27:37.310
The device tree in OS 9 mapped
pretty close to the name registry,

00:27:37.310 --> 00:27:39.700
but the I/O registry is much more.

00:27:39.840 --> 00:27:56.220
Mark Tozer-Violchez, Wayne Flansburg,
Josh de Cesare, Steve Martin,

00:27:56.220 --> 00:27:58.680
Jason Seng The I/O registry
and its planes.

00:27:58.680 --> 00:27:58.680
This is another very,
very important aspect.

00:27:58.680 --> 00:27:58.680
The device tree in OS 9 mapped
pretty close to the name registry,

00:27:58.680 --> 00:27:58.680
but the I/O registry is much more.

00:27:59.130 --> 00:28:04.120
Jason,
show them the IO Registry Explorer,

00:28:04.120 --> 00:28:05.390
please.

00:28:05.600 --> 00:28:16.400
[Transcript missing]

00:28:16.900 --> 00:28:50.800
[Transcript missing]

00:28:51.200 --> 00:29:33.700
[Transcript missing]

00:29:42.510 --> 00:29:44.640
Which options did you want to highlight?

00:29:44.670 --> 00:29:48.780
One of the things I needed to learn, yes,
one of the things I needed to

00:29:49.400 --> 00:29:52.540
learn was objects and classes.

00:29:52.570 --> 00:29:58.690
Who supported whom and where
did you get your providers from?

00:29:59.000 --> 00:30:02.660
So let me switch back over
to my machine for a second.

00:30:02.760 --> 00:30:05.480
And you want to determine
who your provider is,

00:30:05.480 --> 00:30:10.100
and you want to determine your class,
and you want it to read some variables.

00:30:10.210 --> 00:30:13.900
And you're inheriting,
because you don't have a

00:30:13.900 --> 00:30:19.820
framework of particular importance
like FireWire or something,

00:30:19.820 --> 00:30:21.760
you're inheriting from I/O Service.

00:30:21.860 --> 00:30:25.270
But you can be provided
by I/O PCI device,

00:30:25.270 --> 00:30:29.160
AGP device, PCI Bridge,
and Cardbus device.

00:30:29.210 --> 00:30:35.710
And for all the PCI knowledgeable
people in the audience,

00:30:35.710 --> 00:30:39.020
those are all PCI devices.

00:30:41.420 --> 00:30:49.740
So show them the I/O Ridge with
a minus B so we can see the

00:30:49.740 --> 00:30:56.650
BOL properties and a minus P so
we see the I/O device tree plane.

00:30:58.420 --> 00:31:03.230
No need to worry if
you're not a C++ expert.

00:31:03.360 --> 00:31:04.030
I'm not.

00:31:04.410 --> 00:31:09.260
I was immediately able to find the
objects in the tree because they

00:31:09.260 --> 00:31:11.750
supplied me with the -b option.

00:31:11.750 --> 00:31:15.000
And I'm also seeing
who's providing for me.

00:31:15.430 --> 00:31:16.990
That's a big, big help.

00:31:17.020 --> 00:31:20.940
All we want to do is get you
started because we know that

00:31:21.010 --> 00:31:23.600
most of the questions that
you're asking right now is,

00:31:23.600 --> 00:31:28.530
"How do I get started?" Once you've
got all the information,

00:31:28.620 --> 00:31:32.870
we get talented PCI devices all the time.

00:31:33.790 --> 00:31:39.360
Jason, show them I/O PCI device.h.

00:31:39.360 --> 00:31:40.380
And then that'll be it.

00:31:40.490 --> 00:31:43.740
We'll go into the next
part of the session.

00:31:43.920 --> 00:31:47.940
And the headers you'll be
interested in are the IOPCIDevice.h,

00:31:47.940 --> 00:31:53.330
IOPCIDbridge, IOAGPDevice,
and the Cardbus headers are

00:31:53.330 --> 00:31:55.440
in the kernel framework.

00:31:56.820 --> 00:32:00.890
Show them the,
show them that header file,

00:32:00.990 --> 00:32:06.070
iopcidevice.h, the bottom header file,
right there.

00:32:06.190 --> 00:32:08.980
Go down to the FISHI strut.

00:32:09.020 --> 00:32:10.680
There it is, right there.

00:32:10.680 --> 00:32:13.750
Get that strut right there.

00:32:13.860 --> 00:32:16.280
Remember how I showed you?

00:32:17.650 --> 00:32:28.760
Fizz High.

00:32:28.760 --> 00:32:28.760
Look at it.

00:32:28.760 --> 00:32:28.760
Nine never had this.

00:32:28.760 --> 00:32:28.760
Ten has it.

00:32:28.760 --> 00:32:28.760
There it is.

00:32:28.760 --> 00:32:28.760
And it's in Little Indian and Big Indian.

00:32:28.760 --> 00:32:28.760
You don't even have to
get out of bed anymore.

00:32:30.780 --> 00:32:37.800
I was told not to be talking like that,
but I guess I won that one.

00:32:39.040 --> 00:32:40.000
Well that's it.

00:32:40.000 --> 00:32:41.940
I'm not going to talk
anymore and Jason and I are

00:32:41.940 --> 00:32:43.600
going to get off the stage.

00:32:43.600 --> 00:32:55.760
And we're going to turn
the podium over to Josh.

00:33:11.210 --> 00:33:12.200
Good morning, everyone.

00:33:12.200 --> 00:33:13.500
My name is Josh de Cesare.

00:33:13.500 --> 00:33:18.990
I work in the Mac OS X CoreOS group
on various things,

00:33:18.990 --> 00:33:23.630
but primarily I've been working on
platform architecture and various

00:33:23.630 --> 00:33:27.560
aspects of how I/O Kit interfaces
with the rest of the kernel.

00:33:27.640 --> 00:33:31.090
And today I'm going to talk to
you about how you can write a

00:33:31.120 --> 00:33:35.580
lot of the things that you would
use to write generic PCI drivers.

00:33:36.390 --> 00:33:40.760
So, in writing a generic PCI driver,
you're going to have to pay

00:33:40.760 --> 00:33:44.250
attention to several things,
including how your driver

00:33:44.250 --> 00:33:48.300
gets matched in the system,
both active and passive matching,

00:33:48.370 --> 00:33:53.540
how you initialize your driver,
how your driver would process events,

00:33:53.540 --> 00:33:57.360
also how you would create a user
client so that you can handle

00:33:57.630 --> 00:34:00.300
requests from various sources.

00:34:00.300 --> 00:34:02.900
Now, also,
since you're not part of one of the

00:34:02.900 --> 00:34:06.770
built-in frameworks that we provide,
you're going to have to design

00:34:06.770 --> 00:34:10.300
the interface between your
application and your driver.

00:34:10.300 --> 00:34:13.300
So we need to talk a little
bit about how that's done.

00:34:13.650 --> 00:34:15.950
Additionally,
we also want to tell you a little bit

00:34:15.950 --> 00:34:19.880
about how to deliver your driver so
that it'll be there when you need it.

00:34:20.940 --> 00:34:24.020
First off, we're going to talk
about passive matching.

00:34:24.080 --> 00:34:28.610
So in your driver, there's going to be an
Info.plist file that contains all

00:34:28.610 --> 00:34:33.660
the properties that describe your
driver to the rest of the system.

00:34:33.690 --> 00:34:37.290
One of those properties in there
is the I/O Kit personalities.

00:34:37.390 --> 00:34:42.060
You'll have one personality
for each way your driver works.

00:34:42.070 --> 00:34:45.000
And all the personalities
have some similar properties.

00:34:45.090 --> 00:34:46.970
For matching,
the important properties are

00:34:47.000 --> 00:34:50.230
things like the I/O Provider class,
which tells the system

00:34:50.230 --> 00:34:53.620
what kind of device you're
interested in being attached to.

00:34:53.620 --> 00:34:56.220
In the case of most of your drivers,
you're going to be interested

00:34:56.220 --> 00:35:00.120
in having your I/O provider
class be I/O PCI device.

00:35:00.230 --> 00:35:02.500
Tell the system that you're
only interested in PCI devices.

00:35:02.630 --> 00:35:07.540
You're not interested in getting
attached to USB devices or block devices,

00:35:07.680 --> 00:35:10.110
just the PCI devices.

00:35:10.540 --> 00:35:16.540
I/O Name Match will allow you to have
your driver matched against the name,

00:35:16.640 --> 00:35:22.810
compatible, or model properties that
OpenFirmware or the Fcode for your

00:35:22.810 --> 00:35:24.920
device left in the device tree.

00:35:25.010 --> 00:35:29.840
So if you know that your device
in the device tree is going

00:35:29.910 --> 00:35:34.360
to be called "My Company,
My Device," you can use the

00:35:34.360 --> 00:35:36.290
I/O Name Match to do that.

00:35:36.740 --> 00:35:40.620
Additionally,
the different provider types can also

00:35:40.620 --> 00:35:46.830
provide their own kinds of matching,
and IOPCI family does that as well.

00:35:46.840 --> 00:35:48.840
It has several kinds of matching.

00:35:48.840 --> 00:35:53.720
There's IOPCI match,
which lets you match on some combination

00:35:53.720 --> 00:36:00.100
of the device and vendor IDs.

00:36:00.270 --> 00:36:04.210
There's also a primary and secondary
match that allows you to match

00:36:04.210 --> 00:36:08.720
exclusively against either the
sub-vendor and sub-device IDs or

00:36:08.880 --> 00:36:11.860
the regular vendor and device IDs.

00:36:12.140 --> 00:36:17.260
There's also an IOPCI class matching
key which allow you to match

00:36:17.260 --> 00:36:19.430
against certain classes of device.

00:36:19.530 --> 00:36:25.180
So if you were writing a
USB something or other,

00:36:25.180 --> 00:36:28.930
or USB host controller,
it would have a class code and

00:36:28.930 --> 00:36:30.260
you could use that to do that.

00:36:30.310 --> 00:36:35.130
But mostly what you guys are going
to be using is either the IOPCI match

00:36:35.230 --> 00:36:40.160
to use the vendor and device ID,
or name match if you have Fcode that

00:36:40.280 --> 00:36:43.070
puts a particular name on your device.

00:36:43.490 --> 00:36:47.930
There are also other possible
matching keys and you can

00:36:47.930 --> 00:36:51.270
find those in iokitkeys.h.

00:36:51.580 --> 00:36:55.850
The other major property you're going
to be interested in is IO Probescore.

00:36:55.980 --> 00:37:00.740
Probescore allows several phases of
matching to be adjusted in which order

00:37:00.740 --> 00:37:04.500
the various drivers are going to get
attempted to attach to various devices.

00:37:04.500 --> 00:37:07.560
You can use the probescore to
say that your driver should be

00:37:07.570 --> 00:37:09.500
given preference over another.

00:37:09.500 --> 00:37:12.500
In the case that your company has
two devices that are very similar,

00:37:12.500 --> 00:37:17.610
maybe same device and vendor IDs,
it might have other variances,

00:37:17.630 --> 00:37:20.500
it might have other properties,
or various things going on.

00:37:20.500 --> 00:37:23.570
You could use IO Providerscore
to help make sure that one

00:37:23.600 --> 00:37:25.500
driver wins against the other.

00:37:25.500 --> 00:37:28.210
Both would potentially still
have the chance to run,

00:37:28.330 --> 00:37:32.490
which is what we're going to
look at next in active matching.

00:37:33.510 --> 00:37:37.200
So one thing to keep in mind about
the passive matching is it's passive,

00:37:37.200 --> 00:37:40.400
meaning that your driver
didn't get to run any code.

00:37:40.430 --> 00:37:42.300
Active matching is different.

00:37:42.520 --> 00:37:45.710
You will get, your driver will be loaded,
it will be linked into the system,

00:37:45.710 --> 00:37:49.400
and it will be given the opportunity
to run your probe method.

00:37:49.420 --> 00:37:53.600
Now, the thing you note at the bottom
there is it's not normally needed.

00:37:53.600 --> 00:37:57.390
Most devices, or most drivers just
don't need a probe method.

00:37:57.400 --> 00:38:02.190
You can do what you need to get your
driver loaded using the passive matching.

00:38:03.050 --> 00:38:05.290
So what does probe allow you to do?

00:38:05.510 --> 00:38:08.370
It allows you to access
your device's hardware.

00:38:08.430 --> 00:38:10.410
But that also means
that when you're done,

00:38:10.410 --> 00:38:13.300
you have to make sure that you
leave your hardware in a safe state.

00:38:13.440 --> 00:38:15.580
You don't want to leave it such
that it's going to be trying to

00:38:15.580 --> 00:38:20.720
interrupt the system or holding the
bus locked or any other strange stuff.

00:38:20.830 --> 00:38:24.220
You have to make sure that you
left it in a safe state when you're

00:38:24.220 --> 00:38:28.170
done because some other driver may
also get the opportunity to probe.

00:38:29.020 --> 00:38:31.460
You must free any resources you've used.

00:38:31.460 --> 00:38:35.600
If you allocate any large chunk of
memory or attach to various other

00:38:35.600 --> 00:38:40.290
providers in the system or hold locks,
you need to make sure you release all

00:38:40.290 --> 00:38:43.970
of those because some other driver
could get probed after you get probed

00:38:43.970 --> 00:38:45.750
and it turns out they might win.

00:38:45.890 --> 00:38:49.150
So you want to make sure that
you've left everything else okay.

00:38:49.950 --> 00:38:52.820
Another thing you can do with Probe,
and this is one of the more important

00:38:52.820 --> 00:38:57.280
things that Probe does for you,
is it can allow you to bind multiple

00:38:57.280 --> 00:39:00.780
devices to a single driver instance.

00:39:00.920 --> 00:39:05.970
Most people don't need to do this,
but there are certain multifunction

00:39:05.970 --> 00:39:08.900
PCI devices that the two functions
serve different purposes.

00:39:08.940 --> 00:39:12.900
Say the first function is a video device,
the second function is an audio device,

00:39:12.990 --> 00:39:14.890
but you want them handled
by the same driver.

00:39:14.900 --> 00:39:19.100
So by returning one driver instance
for both of the two Probes,

00:39:19.230 --> 00:39:20.750
you can get that bound.

00:39:20.900 --> 00:39:23.000
And I've got an example
of that that's in Darwin,

00:39:23.000 --> 00:39:25.900
and I'll talk a little bit more
about where to find that later.

00:39:27.220 --> 00:39:31.020
Just want to reiterate again,
probe is not normally needed.

00:39:31.040 --> 00:39:33.950
You can do almost everything you
need to do just using property

00:39:33.950 --> 00:39:37.590
matching from the passive schemes.

00:39:39.020 --> 00:39:42.260
So now that your driver has been
matched and the system decides that

00:39:42.260 --> 00:39:46.570
you're the one that wants to try,
you're going to get started.

00:39:47.380 --> 00:39:51.510
One thing to remember is that
start can also be used as an

00:39:51.510 --> 00:39:53.890
even later version of probe.

00:39:53.920 --> 00:39:58.010
Since almost every driver
will have a start routine,

00:39:58.010 --> 00:40:01.550
you also have the opportunity
of returning false from your

00:40:01.570 --> 00:40:04.500
start routine to say that
you're not actually interested.

00:40:04.600 --> 00:40:06.790
Again,
sort of the same rules apply with probe.

00:40:06.800 --> 00:40:09.950
If you did allocate any resources,
you need to make sure to let

00:40:10.060 --> 00:40:13.090
them go and make sure your
hardware is in a safe state.

00:40:13.880 --> 00:40:21.120
So we're going to focus here on a driver
whose provider is an I/O PCI device.

00:40:21.130 --> 00:40:27.000
Now this I/O PCI device, the nub you get,
provides you access to your hardware.

00:40:27.000 --> 00:40:28.640
It provides it in several forms.

00:40:28.640 --> 00:40:33.400
It provides a way to get mappings
for memory space and I/O space.

00:40:33.410 --> 00:40:35.980
And these are done through
a couple of these methods,

00:40:35.980 --> 00:40:39.390
the Get Device Memory with
Index or with Register,

00:40:39.580 --> 00:40:41.470
also I/O Device Memory.

00:40:41.550 --> 00:40:44.760
Now I've got a lot of these class names,
property names,

00:40:44.760 --> 00:40:46.720
or method calls coming up.

00:40:46.720 --> 00:40:50.420
And we're going to try to make sure that
these slides are available for you later

00:40:50.420 --> 00:40:52.980
so you don't have to copy them down.

00:40:53.050 --> 00:40:55.560
And these will just serve as sort
of crib notes for later when you're

00:40:55.560 --> 00:40:59.170
trying to go through and figure
out how to put it all together.

00:41:00.140 --> 00:41:04.580
So for configuration cycles, as you saw,
there's the Cregs demo earlier

00:41:04.580 --> 00:41:07.100
that lets you look at what your
configuration registers are.

00:41:07.230 --> 00:41:12.700
You can read and write your configuration
registers by using the config.read32,

00:41:12.700 --> 00:41:17.050
write32,
and various other methods on your NUB.

00:41:17.700 --> 00:41:39.300
[Transcript missing]

00:41:41.500 --> 00:41:45.740
So once you've figured out how
you want to map your device,

00:41:45.750 --> 00:41:50.040
you need to figure out how it's going
to be used by the rest of the system.

00:41:50.070 --> 00:41:53.220
And we have several classes
that will help you do this.

00:41:53.280 --> 00:41:57.180
In particular,
these are the I/O Work Loop and the

00:41:57.180 --> 00:42:00.270
various I/O Event Source subclasses.

00:42:00.940 --> 00:42:04.880
and the subclasses that are likely to
be most useful for you are I/O Interrupt

00:42:04.950 --> 00:42:08.400
Event Source and I/O Filter Interrupt
Event Source for event processing,

00:42:08.490 --> 00:42:13.030
Timer Event Source for timers,
and I/O Command Gate is sort of a

00:42:13.030 --> 00:42:15.930
catch-all that lets you sync stuff up.

00:42:16.250 --> 00:42:18.490
There's also the I/O command pool.

00:42:18.590 --> 00:42:23.500
Sort of helps you manage
resources for within your driver.

00:42:23.500 --> 00:42:28.590
And I/O's register service helps
you make your driver available

00:42:28.590 --> 00:42:30.470
for the rest of the system.

00:42:30.860 --> 00:42:33.490
So a little more on register service.

00:42:33.610 --> 00:42:37.160
So when you call register
service on your driver instance,

00:42:37.180 --> 00:42:41.290
your driver will get it added to
the matching system and the matching

00:42:41.290 --> 00:42:44.310
system will come through and try
to find all the devices that might

00:42:44.310 --> 00:42:45.900
be interested in attaching to you.

00:42:45.900 --> 00:42:49.760
Now most of the time you're not actually
going to have other drivers attaching to

00:42:49.760 --> 00:42:54.640
your driver because you're sort of the,
you're what we call a leaf

00:42:54.910 --> 00:42:56.650
node in the service plane.

00:42:56.960 --> 00:43:07.130
Mark Tozer-Vilchez, Wayne Flansburg,
Josh de Cesare, Steve Martin, Jason Seng

00:43:09.150 --> 00:43:12.810
Also can be used to let other
drivers in the system know

00:43:12.810 --> 00:43:14.200
that your driver is ready.

00:43:14.250 --> 00:43:19.840
You might have two different devices
for your product and you want to make

00:43:19.900 --> 00:43:24.390
sure that one driver references the
other or will wait for the other.

00:43:25.100 --> 00:43:32.060
So you can have the second driver do
wait for service and that will come back

00:43:32.190 --> 00:43:37.150
or stop blocking as soon as the other
driver has called register service.

00:43:38.550 --> 00:43:46.310
So after your driver's been initialized,
you want to be able to process events.

00:43:46.390 --> 00:43:49.100
So here's a little bit more about
some of these classes that we

00:43:49.100 --> 00:43:51.520
provide for event processing.

00:43:51.680 --> 00:43:54.780
So the I/O work loop allows
you to serialize access to all

00:43:54.780 --> 00:43:56.490
of your driver's resources.

00:43:56.610 --> 00:43:59.150
It's meant to simplify everything.

00:43:59.320 --> 00:44:03.700
Keeps you from having to have
tons of little locks to lock this,

00:44:03.700 --> 00:44:04.860
lock that.

00:44:05.500 --> 00:44:07.700
It also makes it easier
to access your hardware.

00:44:07.700 --> 00:44:11.400
You don't have to worry that two threads,
one maybe a client thread,

00:44:11.400 --> 00:44:14.240
maybe your thread, are accessing your
hardware at the same time.

00:44:14.380 --> 00:44:17.850
As long as you use the various
accessor methods through the

00:44:17.850 --> 00:44:23.720
various event sources or work loop,
you will not have to worry about

00:44:24.220 --> 00:44:29.010
having two threads try to talk to
your hardware at the same time.

00:44:29.960 --> 00:44:35.360
The work loop also provides a thread
for various I/O event source actions.

00:44:35.370 --> 00:44:38.600
We'll talk about that a
little bit more later.

00:44:39.590 --> 00:44:44.900
and the work loop also supplies
itself as a choke point when your

00:44:44.900 --> 00:44:48.950
clients need to tell you to stop,
they're not ready to receive callbacks,

00:44:48.950 --> 00:44:53.060
or other things in the stack need
to tell you to stop for a moment.

00:44:53.940 --> 00:44:57.760
So each of the event sources can
be added to the work loop and any

00:44:57.760 --> 00:45:01.100
time an event source fires and
says that it's got something to do,

00:45:01.100 --> 00:45:05.670
the work loop will serialize any other
outstanding events to make sure only one

00:45:05.670 --> 00:45:08.130
of these is happening at any given time.

00:45:08.420 --> 00:45:12.290
and each of these event
sources will execute an action.

00:45:12.310 --> 00:45:16.150
This action will normally be
executed on whatever client

00:45:16.150 --> 00:45:20.210
thread generated the trigger,
but they can also happen

00:45:20.280 --> 00:45:24.870
on the work loops thread,
but only one at a time.

00:45:25.290 --> 00:45:30.130
So, in a little bit more detail
on the types of event sources

00:45:30.140 --> 00:45:34.490
you're going to be using,
primarily if your PCI device

00:45:34.500 --> 00:45:38.850
is likely to have an interrupt,
you'll want to have some way of

00:45:38.850 --> 00:45:41.200
getting at it easily in your driver.

00:45:41.200 --> 00:45:44.860
We do provide lower level interrupt
services that will let you control,

00:45:44.860 --> 00:45:48.200
enable, and disable on your interrupt,
register interrupt handlers,

00:45:48.200 --> 00:45:52.120
but we do suggest that you use these
higher level constructs because they

00:45:52.120 --> 00:45:54.190
will simplify many things for you.

00:45:54.200 --> 00:45:57.290
The two types of interrupt
event sources we have are the

00:45:57.290 --> 00:46:01.200
basic interrupt event source,
it's a proxy for the device interrupt,

00:46:01.200 --> 00:46:04.190
it makes it so you don't actually
have to talk to the device interrupt,

00:46:04.190 --> 00:46:07.190
you'll get notified when things happen.

00:46:07.280 --> 00:46:10.720
It also handles behind the
scenes enabling and disabling

00:46:10.720 --> 00:46:12.680
your interrupt as required.

00:46:12.960 --> 00:46:16.490
And the action will get--
so when an interrupt occurs,

00:46:16.580 --> 00:46:19.010
this action will happen on a thread.

00:46:19.170 --> 00:46:21.970
You don't have to worry about
running an interrupt context.

00:46:22.080 --> 00:46:25.240
So when this thing does happen,
you can block if you have to.

00:46:25.240 --> 00:46:27.300
You can allocate memory if you have to.

00:46:27.420 --> 00:46:28.790
You can take locks.

00:46:28.950 --> 00:46:33.040
You don't have to worry about running
in a very restricted environment.

00:46:33.130 --> 00:46:37.190
The one thing to keep in mind with
the I/O Interrupt Event Source is

00:46:37.190 --> 00:46:41.150
that if you've got a level-sensitive
interrupt like a PCI device would,

00:46:41.260 --> 00:46:45.540
when your interrupt
happens in the hardware,

00:46:45.700 --> 00:46:49.470
the low-level interrupt controller
stuff will process this interrupt

00:46:50.020 --> 00:46:51.960
and cause a thread to get scheduled.

00:46:52.070 --> 00:46:55.400
In the meantime,
your interrupt will be disabled.

00:46:55.530 --> 00:46:57.980
So if other interrupts
come in for your device,

00:46:58.110 --> 00:47:00.060
they won't be able to do anything.

00:47:00.060 --> 00:47:02.660
You won't get notified of them happening.

00:47:02.720 --> 00:47:07.420
Until your interrupt action finishes.

00:47:07.480 --> 00:47:11.020
So if you want to have the ability
to take multiple interrupts

00:47:11.050 --> 00:47:14.160
at once from your device,
or potentially if you're sharing

00:47:14.160 --> 00:47:18.540
an interrupt with several devices,
if you've got a single PCI card

00:47:18.560 --> 00:47:21.810
that has a bridge on it and then
several of your devices behind it,

00:47:21.810 --> 00:47:24.100
they'd be sharing the
one physical interrupt.

00:47:24.210 --> 00:47:27.540
So to make sure that one device can
get an interrupt while the other one's

00:47:27.540 --> 00:47:30.380
processing an interrupted thread level,
we provide this

00:47:30.380 --> 00:47:32.260
I/O Filter Interrupt Event Source.

00:47:32.260 --> 00:47:36.820
It has the same basic features as a
regular I/O Interrupt Event Source,

00:47:37.030 --> 00:47:40.190
but it also allows you to
supply a filter function that

00:47:40.200 --> 00:47:42.220
runs at the interrupt level.

00:47:42.220 --> 00:47:44.440
Now,
in that this is a real interrupt handler,

00:47:44.650 --> 00:47:47.030
you cannot allocate memory,
you cannot take locks,

00:47:47.030 --> 00:47:50.220
you cannot do anything that
would otherwise block the system.

00:47:50.220 --> 00:47:54.200
Otherwise, the system will deadlock.

00:47:54.810 --> 00:47:57.830
Now what this filter function does
allow you to do is quickly interrogate

00:47:57.880 --> 00:48:01.900
your hardware to determine whether
or not the interrupt is for you.

00:48:02.040 --> 00:48:04.890
Also it allows you to say
process the interrupt.

00:48:05.050 --> 00:48:08.800
If you can process the interrupt very
quickly you can do that and you may

00:48:08.800 --> 00:48:13.100
not even have to send this interrupt,
cause the interrupt action to

00:48:13.190 --> 00:48:15.880
cause your work loop thread to go.

00:48:16.410 --> 00:48:18.420
You can,
in a lot of cases where you might want

00:48:18.420 --> 00:48:22.620
to do that is if you're implementing some
sort of software DMA where you have a lot

00:48:22.620 --> 00:48:25.720
of high frequency interrupts coming in,
you just want to quickly take

00:48:25.780 --> 00:48:29.590
a bite off of a FIFO and put
it into a buffer somewhere.

00:48:29.710 --> 00:48:32.710
And maybe when your buffer
is starting to approach full,

00:48:32.710 --> 00:48:36.170
then you might want to decide that
you should cause your interrupt

00:48:36.170 --> 00:48:39.320
action to fire and let the
higher level parts of your driver

00:48:39.320 --> 00:48:41.380
process the rest of the interrupt.

00:48:43.720 --> 00:48:47.010
So there's also the
I/O timer event source.

00:48:47.010 --> 00:48:48.250
You can use it in two ways.

00:48:48.380 --> 00:48:50.340
The first way is a lot easier.

00:48:50.400 --> 00:48:52.260
It's basically to schedule a timeout.

00:48:52.420 --> 00:48:56.860
Suppose a client issues a transaction
in your driver and you want to make sure

00:48:56.860 --> 00:49:03.650
that after some number of milliseconds to
seconds that a notification is sent back

00:49:03.730 --> 00:49:05.660
up to say that it just didn't complete.

00:49:05.690 --> 00:49:10.430
You can, at the same time that you issue
the transaction to your hardware,

00:49:10.500 --> 00:49:13.800
you can also set up one of
these timer event sources.

00:49:14.010 --> 00:49:19.510
When the timer event source fires,
it gives you an opportunity to see if the

00:49:19.510 --> 00:49:24.550
transaction is done or if it isn't done,
you can set an error up.

00:49:24.820 --> 00:49:29.140
Now one thing to keep track of is that
these timer event sources are one shots.

00:49:29.150 --> 00:49:32.840
It won't get rearmed unless
you explicitly rearm it.

00:49:32.960 --> 00:49:36.750
So if you're going to attempt to use
one of these for a periodic timer,

00:49:36.750 --> 00:49:40.760
you need to, after every time it fires,
you need to rearm it.

00:49:42.170 --> 00:49:44.190
Another one is the I/O command gate.

00:49:44.270 --> 00:49:45.890
This isn't really like
a lot of the others.

00:49:45.930 --> 00:49:48.440
It doesn't have an explicit
action attached with it,

00:49:48.440 --> 00:49:50.100
and it doesn't really have a trigger.

00:49:50.400 --> 00:49:55.740
But it does have a way for you to
execute any function as if it were

00:49:55.740 --> 00:49:58.930
being executed by your work loop.

00:49:59.100 --> 00:50:02.090
Now it's not going to get shuttled
over to the work loop thread.

00:50:02.100 --> 00:50:04.080
It'll execute on whatever thread
you've called the function on,

00:50:04.120 --> 00:50:05.100
so it's efficient.

00:50:05.100 --> 00:50:08.160
But it will block if necessary
in case the work loop is in

00:50:08.160 --> 00:50:10.100
the middle of doing something.

00:50:10.100 --> 00:50:13.970
This allows you, in many cases,
to take an I/O request coming

00:50:13.970 --> 00:50:19.040
into your driver that could be
happening on multiple processors

00:50:19.160 --> 00:50:23.010
or in many different ways,
and schedule the function that

00:50:23.010 --> 00:50:26.990
actually causes the I/O to be put
into your driver by saying run

00:50:27.130 --> 00:50:34.100
action command on your command gate,
and it will get serialized appropriately.

00:50:35.860 --> 00:50:37.660
The command pool is mostly a helper.

00:50:37.660 --> 00:50:40.590
It's not likely to be used
by most of your drivers,

00:50:40.640 --> 00:50:41.600
but is there if you need it.

00:50:41.840 --> 00:50:44.800
Basically, it lets you allocate
some number of commands.

00:50:44.880 --> 00:50:47.550
Each one of these commands would
hopefully have the total amount

00:50:47.550 --> 00:50:54.090
of memory needed to process
completely one of your commands.

00:50:54.180 --> 00:50:57.020
At the same time,
you don't want to pre-allocate too

00:50:57.150 --> 00:51:01.120
much memory since every piece of memory
you pre-allocate isn't going to be

00:51:01.120 --> 00:51:03.510
available for the rest of the system.

00:51:03.980 --> 00:51:07.050
This is an important notion
if your driver is somehow

00:51:07.050 --> 00:51:08.700
related to the paging path.

00:51:08.850 --> 00:51:13.090
Because if the paging system is trying
to free up memory or put stuff on disk,

00:51:13.190 --> 00:51:15.720
there's no memory to be allocated,
you can't be allocating memory in

00:51:15.720 --> 00:51:18.170
your driver while it's doing that.

00:51:18.610 --> 00:51:24.410
The I/O command pool can be told to block
when there isn't anything available.

00:51:24.460 --> 00:51:27.620
Also, it can be set up to just return
you an error to say that there is

00:51:27.620 --> 00:51:29.100
no memory available at this time.

00:51:29.100 --> 00:51:32.170
And you can, if you wanted to,
return an error or you could

00:51:32.240 --> 00:51:35.520
block on some other higher
level construct in your driver.

00:51:35.660 --> 00:51:39.090
It's also synchronized with
a work loop to make sure that

00:51:39.090 --> 00:51:41.380
things don't get out of sequence.

00:51:42.430 --> 00:51:47.620
So now that you've got a basic
notion of the classes that are used

00:51:47.680 --> 00:51:51.830
to process events in your driver,
you need to figure out what sort

00:51:51.840 --> 00:51:56.570
of event or how you start getting
these events to your driver.

00:51:57.230 --> 00:51:59.650
So there's a couple ways to do that.

00:51:59.770 --> 00:52:01.900
One of them is basically generic,
sort of generically

00:52:01.900 --> 00:52:03.100
through property access.

00:52:03.160 --> 00:52:05.610
The other is through user clients.

00:52:05.940 --> 00:52:10.000
Now the property access stuff is done
through basically gets or sets on

00:52:10.000 --> 00:52:15.140
properties in your driver's dictionary.

00:52:15.210 --> 00:52:17.280
And this is a very easy thing to do.

00:52:17.280 --> 00:52:18.260
It's connectionless.

00:52:18.370 --> 00:52:20.400
There's no clients to think about.

00:52:20.460 --> 00:52:24.460
It's kind of high overhead because
as you come from outside the kernel,

00:52:24.540 --> 00:52:28.270
it has to get wrapped
through a serialized,

00:52:28.290 --> 00:52:30.000
it's actually a chunk of text.

00:52:30.050 --> 00:52:32.650
It comes into the kernel,
it gets parsed again,

00:52:32.650 --> 00:52:34.490
and created into a dictionary.

00:52:34.570 --> 00:52:38.960
And consequently,
it's also rather low bandwidth,

00:52:39.120 --> 00:52:41.090
but it's easy.

00:52:41.890 --> 00:52:45.140
To make your driver participate in this,
the two methods that you need to

00:52:45.140 --> 00:52:47.220
override are serialized properties.

00:52:47.380 --> 00:52:51.660
This allows you to find out when somebody
is trying to get properties from you and

00:52:51.720 --> 00:52:53.800
potentially return different properties.

00:52:53.870 --> 00:52:59.310
Also, set properties allows you to take
or accept a dictionary from user

00:52:59.310 --> 00:53:04.190
space and then add it dynamically
into whatever dictionary.

00:53:04.860 --> 00:53:08.330
Now, if you're doing a more
complicated system,

00:53:08.430 --> 00:53:11.700
you're probably going to have
to use an IO user client.

00:53:11.840 --> 00:53:14.670
They're somewhat more complicated,
so we're going to be trying to

00:53:14.670 --> 00:53:18.700
provide some examples for you,
give you a baseline of what to do.

00:53:18.700 --> 00:53:20.670
It's connection-based,
so you'll always know who

00:53:20.670 --> 00:53:23.700
all of your clients are,
you'll know if clients go away,

00:53:23.700 --> 00:53:26.620
and you'll also have everything
you need to serialize clients

00:53:26.620 --> 00:53:29.700
to make sure that they're not
trying to talk to you all at once.

00:53:29.700 --> 00:53:34.900
It's very low overhead,
and it can be very high bandwidth.

00:53:35.330 --> 00:53:39.150
It allows you to map memory from
a user process into the kernel's

00:53:39.160 --> 00:53:40.900
address space if necessary.

00:53:40.950 --> 00:53:44.130
You could DMA into the buffers,
you could copy memory around,

00:53:44.130 --> 00:53:45.790
you can do pretty much whatever you need.

00:53:45.900 --> 00:53:50.780
You can also export new
API through to user space.

00:53:51.130 --> 00:53:54.500
And the major property that you need
to be interested in for doing this

00:53:54.590 --> 00:53:57.500
is the GIO user client class key.

00:53:57.660 --> 00:54:00.820
Basically,
you add a new property to your driver's

00:54:00.820 --> 00:54:04.800
dictionary that says the name of the
class that should be instantiated

00:54:04.800 --> 00:54:07.760
when a user client request comes in.

00:54:10.750 --> 00:54:14.400
So how do you access
your application from,

00:54:14.730 --> 00:54:17.160
or your driver from an application?

00:54:17.220 --> 00:54:23.010
And this is done pretty similarly
for Cocoa or Carbon applications.

00:54:23.540 --> 00:54:27.000
Ultimately, they would have to link
against the I/O Kit framework.

00:54:27.000 --> 00:54:29.990
And how this linking is done is a
little bit complicated depending

00:54:29.990 --> 00:54:31.500
on whether you're Cocoa or Carbon.

00:54:31.500 --> 00:54:35.500
If you saw the
I/O Kit overview on Monday,

00:54:35.500 --> 00:54:39.690
there was some stuff where you
had to have a CF plug-in and

00:54:39.700 --> 00:54:43.900
various other things in between
to get back and forth between the

00:54:44.140 --> 00:54:47.500
Mac OS context and CFM context.

00:54:47.500 --> 00:54:51.520
But it boils down to you link
with the I/O Kit framework,

00:54:51.620 --> 00:54:56.370
it provides you all the APIs that
you need to shuttle back and forth

00:54:56.370 --> 00:54:58.950
across the user kernel boundary.

00:54:59.490 --> 00:55:02.820
It also provides a set of
matching functions that you

00:55:02.900 --> 00:55:04.660
can use to find your device.

00:55:04.660 --> 00:55:08.220
After register service has
been called in your driver,

00:55:08.220 --> 00:55:12.190
these user space commands will
be able to find your device.

00:55:13.140 --> 00:55:17.250
Now if you're trying to use the get and
set property interfaces to your driver,

00:55:17.270 --> 00:55:20.250
the two functions that you're going to
be interested in using from user space

00:55:20.270 --> 00:55:25.540
are ioRegistryEntryCreateCFProperties
and ioRegistryEntrySetCFProperties.

00:55:25.600 --> 00:55:29.170
These allow you to pass a dictionary
from user space into the kernel

00:55:29.290 --> 00:55:35.000
and have it end up going to the
driver in the set properties.

00:55:35.010 --> 00:55:38.190
Or if you're getting,
it allows you to ask the kernel

00:55:38.190 --> 00:55:42.040
to provide you a dictionary from
serialized properties in your

00:55:42.040 --> 00:55:44.580
driver that you can then use.

00:55:45.210 --> 00:55:48.300
Now if you're going to be
creating a user client,

00:55:48.300 --> 00:55:53.080
after you have found the device,
you'll want to use I/O Service Open,

00:55:53.080 --> 00:55:57.830
which will cause in the kernel the
user client class to be created

00:55:58.140 --> 00:56:01.290
and you can then go from there.

00:56:01.600 --> 00:56:18.500
[Transcript missing]

00:56:19.140 --> 00:56:32.690
Mark Tozer-Violchez, Wayne Flansburg,
Josh de Cesare, Steve Martin, Jason Seng

00:56:34.350 --> 00:56:38.120
So the other topic we need to
talk about is driver delivery.

00:56:38.120 --> 00:56:41.040
So now that you've got a driver,
you need to figure out how

00:56:41.040 --> 00:56:42.580
to get it into the system.

00:56:42.900 --> 00:56:44.680
This can be done in a couple of ways.

00:56:44.770 --> 00:56:48.430
The standard driver format that
you're going to be using is a KEXT.

00:56:48.440 --> 00:56:50.660
It's the standard CFBundle.

00:56:50.680 --> 00:56:53.260
It has the usual properties in it.

00:56:53.260 --> 00:56:56.850
The two that are very interesting for us,
of course, are the Info.plist file

00:56:56.850 --> 00:57:00.860
that gives the properties,
including the I/O Kit personalities.

00:57:00.860 --> 00:57:04.580
And there's also the
binary for the driver.

00:57:04.650 --> 00:57:06.190
So this whole thing is directory-based.

00:57:06.330 --> 00:57:08.570
It's not a flat file,
which makes it rather difficult

00:57:08.720 --> 00:57:11.310
to put in the ROM on a PCI card.

00:57:11.330 --> 00:57:15.300
So we've also provided another
method for storing drivers.

00:57:15.300 --> 00:57:17.040
This is a .mkext.

00:57:17.040 --> 00:57:19.380
We call it a multi-kext.

00:57:19.380 --> 00:57:21.700
It can contain multiple KEXTs.

00:57:21.700 --> 00:57:24.380
Normally, for your device,
you're only going to be putting

00:57:24.540 --> 00:57:26.270
one KEXT inside your mkext.

00:57:26.330 --> 00:57:27.900
It turns into a flat file.

00:57:27.900 --> 00:57:28.710
It's compressed.

00:57:28.790 --> 00:57:35.340
It's also checksummed and is
very easy for use in a ROM.

00:57:35.610 --> 00:57:40.280
It only contains an
Info.plist and a drivers binary.

00:57:42.810 --> 00:57:45.090
So how do you create this .mkext?

00:57:45.210 --> 00:57:47.580
First thing you need to do is you
need to strip the debugging symbols

00:57:47.580 --> 00:57:49.700
and local symbols from your driver.

00:57:49.700 --> 00:57:53.450
This will reduce the size
of your binary by about 90%.

00:57:53.610 --> 00:57:54.690
It will also simplify things.

00:57:54.700 --> 00:57:57.480
You don't have to worry about other
people looking at your debugging

00:57:57.480 --> 00:58:01.690
symbols or gaining other information
about the internals of your driver.

00:58:01.700 --> 00:58:04.920
To do this,
you use the strip command with the dash

00:58:04.920 --> 00:58:07.590
lowercase x and point it to your driver.

00:58:07.700 --> 00:58:11.430
It then goes through and removes
everything that isn't needed.

00:58:12.340 --> 00:58:16.640
It's very important to do this because
obviously the ROM space in your card

00:58:16.640 --> 00:58:20.300
is limited and this will greatly extend
the size of the driver that you can,

00:58:20.370 --> 00:58:24.580
the actual working size of the driver
that you can put in the ROM in your card.

00:58:24.990 --> 00:58:26.540
So how do you create the mkext?

00:58:26.650 --> 00:58:30.050
Well, first you have to run,
after you strip the driver,

00:58:30.050 --> 00:58:32.740
then you can run this
mkext cache utility.

00:58:32.810 --> 00:58:39.600
And this utility will take a KEXT or
potentially a list of KEXTs and

00:58:39.600 --> 00:58:43.840
put them inside your driver,
and create an mkext out of them.

00:58:44.320 --> 00:58:47.940
It will compress them and
checksum them to further

00:58:47.970 --> 00:58:50.500
reduce the size of your MCaxed.

00:58:50.900 --> 00:58:53.940
Now that you've got an mkext,
you need to know what to do with it.

00:58:54.000 --> 00:58:57.420
So this involves the Fcode that
you've written for your driver.

00:58:57.540 --> 00:59:00.910
Now Mac OS X uses basically
the same Fcode as Mac OS 9.

00:59:01.000 --> 00:59:07.310
Really there's only optionally two
properties to add that are needed.

00:59:08.000 --> 00:59:15.840
and these are the driver, APL, Mac OS X,
PowerPC property that's very similar

00:59:15.840 --> 00:59:20.340
to the Mac OS 9 version of the
driver from that you're used to.

00:59:20.340 --> 00:59:23.540
It's a property in the device tree.

00:59:23.540 --> 00:59:30.040
You use encode file to put it there and
there's an example there of what a sample

00:59:30.040 --> 00:59:31.270
string for how you would create it.

00:59:31.340 --> 00:59:35.860
This causes the entire contents
of the mkext to be created as

00:59:35.940 --> 00:59:40.310
a property inside your driver,
or inside the driver's properties.

00:59:40.340 --> 00:59:44.470
Now this can take up a lot
of space in the registry,

00:59:44.560 --> 00:59:52.630
so one way you can get around this is by
using the driver-reg/apl/macosx property.

00:59:52.990 --> 00:59:57.560
This would just be a reference in
the property list for where to find

00:59:57.560 --> 00:59:59.090
the driver in your expansion ROM.

00:59:59.130 --> 01:00:02.360
Now obviously you have to have
an expansion ROM to do this,

01:00:02.360 --> 01:00:06.000
and unfortunately there aren't any
good tools to do that right now,

01:00:06.100 --> 01:00:10.750
but it is possible to do and in the
future we hope to have better tools.

01:00:11.630 --> 01:00:15.700
Another topic I just wanted to
briefly mention is firmware updates.

01:00:15.700 --> 01:00:19.500
So if later,
after you've already released your card,

01:00:19.500 --> 01:00:21.590
you want to be able to
update the firmware,

01:00:21.590 --> 01:00:23.240
this is a sample of one
way you could do it.

01:00:23.260 --> 01:00:25.500
There are many different
ways you could do this.

01:00:25.600 --> 01:00:28.490
And I want to talk about this a little
bit because it is different than 9.

01:00:28.500 --> 01:00:32.720
Obviously in Mac OS X you can't actually
access your hardware from an application,

01:00:32.720 --> 01:00:34.320
you have to go through a driver.

01:00:34.500 --> 01:00:36.890
So this means that the
hardware access done to,

01:00:37.010 --> 01:00:40.500
say, flash the ROM on your card,
has to be done by the driver.

01:00:40.500 --> 01:00:44.770
The firmware update application
just turns into a pretty front end.

01:00:45.720 --> 01:00:48.590
You, one way or another,
have to pass the firmware image

01:00:48.780 --> 01:00:50.700
from user space to the driver.

01:00:50.710 --> 01:00:51.640
This can be done in chunks.

01:00:51.700 --> 01:00:55.770
It can be done all at
once by having a driver,

01:00:55.770 --> 01:00:59.590
by creating a dummy driver that just
contains a property that is the image

01:00:59.610 --> 01:01:01.700
that somehow attaches to your driver.

01:01:01.700 --> 01:01:05.590
Or you could use set property interface
to put the chunks across one at a time.

01:01:05.710 --> 01:01:09.480
You could also even use a user
client to have the chunk of

01:01:09.490 --> 01:01:12.700
address space in your user client.

01:01:12.710 --> 01:01:18.650
You could use a user client
to have the chunk of address

01:01:18.650 --> 01:01:18.650
space in your user client.

01:01:18.850 --> 01:01:22.760
You can have your user application
have the entire firmware

01:01:22.760 --> 01:01:26.030
image in its memory space,
then you could have your user client map

01:01:26.150 --> 01:01:31.470
that address space into the kernel that
your driver could then take advantage of.

01:01:31.860 --> 01:01:34.200
Once you're in the driver,
it will write these chunks

01:01:34.490 --> 01:01:36.390
into the flash on your card.

01:01:36.400 --> 01:01:39.820
You could also have it update
properties so that your application

01:01:39.820 --> 01:01:42.670
could have a barbershop poll giving
you a little bit of progress.

01:01:42.800 --> 01:01:46.800
And that's pretty much
the basic idea of that.

01:01:49.030 --> 01:01:51.000
So we're going to find some examples.

01:01:51.000 --> 01:01:53.630
The one thing that we really want
to stress is the first thing you

01:01:53.630 --> 01:01:56.590
need to do if you're going to be
writing I/O Kit drivers is you need

01:01:57.160 --> 01:01:59.300
to sign up as a Darwin developer.

01:01:59.330 --> 01:02:03.050
You need to go to the
publicsource.apple.com website

01:02:03.150 --> 01:02:04.730
to find out how to do that.

01:02:04.830 --> 01:02:08.500
And in there you can find out how to
get access to everything inside Darwin.

01:02:08.730 --> 01:02:11.980
Three things of interest
inside Darwin that's topical to

01:02:11.980 --> 01:02:14.100
today's discussion are X and U.

01:02:14.100 --> 01:02:17.300
This is the actual kernel's source.

01:02:17.410 --> 01:02:22.620
You can find inside here all the headers
and source to various pieces of I/O Kit.

01:02:22.780 --> 01:02:24.460
This will be a valuable resource.

01:02:24.550 --> 01:02:27.200
It also serves as many examples
for how to do certain things.

01:02:27.200 --> 01:02:32.270
I've also been working on an
example generic PCI driver.

01:02:32.300 --> 01:02:35.400
Unfortunately, it's not quite done,
but it's got a pretty good going so far.

01:02:35.510 --> 01:02:39.550
You can find this in I/O Kit examples,
Kernel, I/O Kit, generic,

01:02:39.550 --> 01:02:40.600
and generic PCI.

01:02:40.610 --> 01:02:47.410
I will be posting updates or references
on how to find it and status reports

01:02:47.410 --> 01:02:52.600
to the Darwin developer mailing list,
so you should all sign up for that.

01:02:54.070 --> 01:02:57.240
Additionally,
a couple years ago I wrote a simple

01:02:57.920 --> 01:03:02.500
driver for a BrookTree 878 device.

01:03:02.510 --> 01:03:07.020
It's one of these devices that has
both a video and an audio function,

01:03:07.120 --> 01:03:10.040
and the driver is available inside
Darwin to serve as a somewhat more

01:03:10.110 --> 01:03:12.810
complicated example of how to do that.
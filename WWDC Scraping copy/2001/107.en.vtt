WEBVTT

00:00:03.740 --> 00:00:04.600
Good morning, everyone.

00:00:04.600 --> 00:00:08.180
I'd like to welcome you to session 107,
which is 2D graphics using Quartz.

00:00:08.240 --> 00:00:12.140
Today we're going to talk about one of
the most exciting aspects of Mac OS X,

00:00:12.140 --> 00:00:14.120
which is the Quartz graphics technology.

00:00:14.120 --> 00:00:16.800
And for many developers,
you're abstracted from it.

00:00:16.800 --> 00:00:19.880
If you're using Carbon,
you often develop with QuickDraw.

00:00:19.880 --> 00:00:25.000
If you're using Cocoa,
you're using the NS Graphics and SBAZIA,

00:00:25.000 --> 00:00:26.920
those abstractions.

00:00:27.000 --> 00:00:30.160
But what we want to talk
about is the Quartz 2D API,

00:00:30.270 --> 00:00:33.540
because we really believe
that every application can

00:00:33.550 --> 00:00:39.300
benefit from being powered by
PuzzScript and PDF-style graphics.

00:00:39.300 --> 00:00:43.170
And also given the ability
to create and consume PDFs as

00:00:43.170 --> 00:00:45.380
well as an imported format.

00:00:45.380 --> 00:00:49.750
So I'd like to introduce Haroon Sheikh,
who's the Quartz 2D engineering manager,

00:00:49.750 --> 00:00:52.570
and he's going to take the
presentation from here.

00:00:58.600 --> 00:01:01.700
Thank you, Travis.

00:01:01.760 --> 00:01:02.620
Good day, everyone.

00:01:02.620 --> 00:01:03.740
Welcome to this session.

00:01:03.740 --> 00:01:09.250
So we're going to be focusing
on 2D graphics using Quartz.

00:01:09.590 --> 00:01:13.530
Our agenda for today is basically
going into detail about what Quartz is,

00:01:13.550 --> 00:01:16.100
look at the architecture,
see where it's used in the system,

00:01:16.100 --> 00:01:19.740
where you might be using it indirectly,
where you might want

00:01:19.740 --> 00:01:20.750
to focus on using it.

00:01:20.820 --> 00:01:26.080
The bulk of the presentation is going
to be focusing on the Quartz API.

00:01:26.080 --> 00:01:31.320
We'll conclude the session with a demo
demonstrating the power of Quartz.

00:01:34.190 --> 00:01:37.820
So fundamentally, Quartz is the graphics
system on Mac OS X.

00:01:38.020 --> 00:01:40.720
So it's responsible for
the Aqua look and feel.

00:01:40.720 --> 00:01:42.080
It participates in that.

00:01:42.130 --> 00:01:45.280
All of your window management
is handled by Quartz.

00:01:45.480 --> 00:01:48.600
Rendering is part of
the printing workflow.

00:01:48.600 --> 00:01:54.300
So it plays a very important
role throughout Mac OS X.

00:01:56.810 --> 00:01:58.940
So looking at the system
architecture slide,

00:01:58.940 --> 00:02:03.960
you'll notice that Quartz is
in the application services

00:02:04.010 --> 00:02:05.240
layer right above Darwin.

00:02:05.240 --> 00:02:10.860
At that level, we've got Quartz, OpenGL,
and QuickTime.

00:02:10.860 --> 00:02:14.610
Looking at that in a little more detail,

00:02:15.480 --> 00:02:20.890
You'll notice that Quick Draw, QuickTime,
and OpenGL are not only peers to Quartz,

00:02:20.890 --> 00:02:24.750
but at the same time,
they're also sitting on top of Quartz.

00:02:24.790 --> 00:02:30.780
And the reason for that is Quartz is
really composed of two components,

00:02:30.780 --> 00:02:36.320
Quartz 2D, which is our focus today,
and the Quartz compositor.

00:02:36.720 --> 00:02:40.060
So in the graphics and imaging overview,
we've talked a little

00:02:40.060 --> 00:02:41.430
bit about both of them.

00:02:41.590 --> 00:02:44.900
The Quartz compositor is responsible
for all your Windows server,

00:02:44.900 --> 00:02:48.610
window management needs in the system.

00:02:48.920 --> 00:02:52.360
It effectively handles the
compositing of multimedia,

00:02:52.380 --> 00:02:56.390
your windows, your menus,
blending them appropriately

00:02:56.670 --> 00:03:02.570
with the rest of the system
and sending that to on screen.

00:03:02.720 --> 00:03:07.190
on the Quartz 2D side, that's your--

00:03:08.610 --> 00:03:11.970
That's the rendering library,
and that's the focus of this talk today.

00:03:12.050 --> 00:03:14.110
It's a low-level rendering library.

00:03:14.210 --> 00:03:16.040
It's based on the PDF imaging model.

00:03:16.190 --> 00:03:22.880
So hopefully most of you were
at the PDF and Mac OS X session

00:03:22.880 --> 00:03:26.040
right before this one,
which discussed PDF and

00:03:26.040 --> 00:03:28.080
the imaging model.

00:03:28.660 --> 00:03:32.630
Quartz 2D in itself,
because it is based on the imaging

00:03:32.630 --> 00:03:38.280
model and the way we've architected it,
is resolution and device independent.

00:03:38.460 --> 00:03:42.110
So you do not have to worry
about what the device is.

00:03:42.170 --> 00:03:44.230
That's abstracted for you.

00:03:44.230 --> 00:03:47.090
All you have to do is
draw to the context,

00:03:47.090 --> 00:03:48.940
which I'll get into.

00:03:48.940 --> 00:03:56.150
And the resolution,
high fidelity output can be achieved

00:03:56.150 --> 00:04:05.390
by Quartz minting the resolution of
your data throughout the workflow.

00:04:05.710 --> 00:04:08.200
We also incorporate ColorSync and ATS.

00:04:08.490 --> 00:04:14.620
ATS is Apple type services,
so that's for all your font management.

00:04:14.620 --> 00:04:19.120
ColorSync is incorporated also,
so that allows you to get high fidelity

00:04:19.460 --> 00:04:22.860
color managed output onto your device.

00:04:22.860 --> 00:04:29.470
Quartz does all the work working
with ColorSync to achieve that.

00:04:31.220 --> 00:04:33.530
So let's have a look at
where Quartz is used.

00:04:33.540 --> 00:04:39.980
You may already be
using Quartz indirectly.

00:04:39.980 --> 00:04:44.820
There's a Cocoa application, Carbon,
or Java applications.

00:04:44.820 --> 00:04:50.020
They all sit on top of Quartz,
and so they're using Quartz indirectly.

00:04:50.020 --> 00:04:57.860
In Cocoa, as Travis was mentioning,
most of the NS Bezier path classes,

00:04:57.860 --> 00:05:05.080
NS image classes,
they take advantage of the Quartz API.

00:05:05.080 --> 00:05:10.560
So the functionality in
Cocoa is very similar to Quartz.

00:05:12.410 --> 00:05:15.200
So you're taking advantage
of Quartz indirectly there.

00:05:15.210 --> 00:05:21.470
On the Carbon side, if you do some things
like draw theme text,

00:05:21.760 --> 00:05:25.010
that goes through ATSUI,
which does all of its text

00:05:25.010 --> 00:05:26.890
rendering through Quartz.

00:05:26.960 --> 00:05:30.880
And also,
when you're printing from Carbon,

00:05:31.180 --> 00:05:34.260
you're printing to a Quickdraw port.

00:05:34.580 --> 00:05:37.140
Internally,
what we do is we translate the

00:05:37.240 --> 00:05:41.410
Quickdraw calls into Quartz
calls for your printing needs.

00:05:41.780 --> 00:05:46.480
Java 2D graphics are also
implemented on top of Quartz,

00:05:46.520 --> 00:05:50.140
so they're handled
natively on the system.

00:05:50.810 --> 00:05:55.040
You may want to directly access Quartz.

00:05:55.040 --> 00:05:59.030
And what you want to do there
is you want to access it through

00:05:59.030 --> 00:06:01.640
the Core Graphics framework.

00:06:01.850 --> 00:06:05.290
Core Graphics is our
internal name for Quartz.

00:06:05.440 --> 00:06:08.190
Quartz is more the marketing name.

00:06:08.290 --> 00:06:12.750
Core Graphics is part of the
application services framework.

00:06:17.330 --> 00:06:20.950
When would you want to
actually use Quartz?

00:06:21.080 --> 00:06:22.990
From Carbon,

00:06:23.340 --> 00:06:28.820
The Quickdraw model has been
around for the last 10-15 years,

00:06:28.840 --> 00:06:32.080
but the Quartz imaging
model is much more richer,

00:06:32.080 --> 00:06:33.200
much more advanced.

00:06:33.390 --> 00:06:40.160
So that's an opportunity for you to take
advantage of advanced 2D graphics through

00:06:40.630 --> 00:06:43.670
Carbon instead of using Quickdraw.

00:06:43.990 --> 00:06:49.520
We also have two other APIs that
I won't be discussing too much today.

00:06:49.520 --> 00:06:53.130
One is the Full Screen Access API,
and that's if you want to

00:06:53.160 --> 00:06:59.260
access the screen for gaming
or for changing display depths.

00:06:59.280 --> 00:07:01.050
That's available.

00:07:01.060 --> 00:07:03.980
There's another API for remote access.

00:07:03.980 --> 00:07:09.970
So applications like Timbuk2,
where you want to access a remote system

00:07:10.030 --> 00:07:14.300
and get information about the contents
on screen or be able to send events,

00:07:14.300 --> 00:07:15.320
that's also available.

00:07:15.320 --> 00:07:16.910
That's also part of Quartz.

00:07:19.320 --> 00:07:22.830
In general,
when you're working with Carbon, Cocoa,

00:07:22.830 --> 00:07:29.120
or Java, those frameworks will be the
ones that you go to for all

00:07:29.120 --> 00:07:30.200
your window management needs.

00:07:30.340 --> 00:07:34.830
Quartz doesn't provide
that to you explicitly.

00:07:34.840 --> 00:07:39.870
They're done implicitly through
those high-level frameworks.

00:07:41.660 --> 00:07:46.370
So let's get into the API itself.

00:07:46.380 --> 00:07:48.530
It's a C-based interface,
and the reason for that is

00:07:48.580 --> 00:07:55.180
because we're servicing Cocoa,
Carbon, and Java.

00:07:55.240 --> 00:07:59.260
So you've got Objective-C, C++,
and Java that's interacting

00:07:59.260 --> 00:07:59.670
with the system.

00:07:59.680 --> 00:08:03.470
We decided to choose a simple
C-based interface that can service

00:08:03.500 --> 00:08:05.810
all three of those clients.

00:08:06.160 --> 00:08:11.000
And so those who are familiar with
the core foundation naming convention,

00:08:11.090 --> 00:08:15.000
Quartz relies on the same naming
convention for all of its API.

00:08:15.030 --> 00:08:18.170
And the convention is
basically a two-letter keyword

00:08:18.180 --> 00:08:21.810
representing the framework that
you're working on and class,

00:08:21.810 --> 00:08:22.970
verb, and object.

00:08:23.110 --> 00:08:26.040
So in our case,
CG represents the framework.

00:08:26.040 --> 00:08:29.120
So all of Quartz calls
will begin with CG.

00:08:29.490 --> 00:08:33.130
So as an example, CG context draw image.

00:08:33.320 --> 00:08:34.800
It's straightforward.

00:08:34.820 --> 00:08:38.830
What that really does is it
draws an image into a CG context.

00:08:39.720 --> 00:08:43.880
So here's a list of the
classes that we'll be talking

00:08:43.880 --> 00:08:45.330
about that Quartz provides.

00:08:45.410 --> 00:08:47.480
These are not classes in the C++ term.

00:08:47.480 --> 00:08:50.460
These are just a collection of things
that we'll be discussing today.

00:08:53.910 --> 00:08:59.170
So the first thing you want to do is
you want to interact with the device.

00:08:59.660 --> 00:09:01.900
A Xig context is your
connection to the device.

00:09:02.120 --> 00:09:05.130
So this is synonymous to a quick report.

00:09:05.890 --> 00:09:11.300
On the Quartz side,
that connection is an abstraction.

00:09:11.330 --> 00:09:15.300
So you do not have to worry
about the details of the device,

00:09:15.310 --> 00:09:18.880
what the resolution is,
or whether it's a printer,

00:09:18.880 --> 00:09:21.020
or whether it is on screen.

00:09:21.020 --> 00:09:26.920
From your perspective,
you want to basically send down your

00:09:26.920 --> 00:09:31.950
data in as rich a format as possible,
and Quartz will be

00:09:31.950 --> 00:09:36.210
responsible for making,
because it knows about the device,

00:09:36.240 --> 00:09:39.560
it will translate the data
appropriately to that device,

00:09:39.560 --> 00:09:42.170
render it, save it out into PDF,
or whatever,

00:09:42.270 --> 00:09:44.340
depending on what the device is.

00:09:44.380 --> 00:09:51.000
So that, the important point there is,
you can send the same information to,

00:09:51.020 --> 00:09:54.230
whatever device, through the same API,
make the same calls,

00:09:54.240 --> 00:09:55.240
and it'll be handled for you.

00:09:57.470 --> 00:10:02.540
One thing also that's
part of the CG context is

00:10:02.990 --> 00:10:05.440
State is also part of that context.

00:10:05.470 --> 00:10:09.360
So what I mean by state is
it's similar to Quick Draw,

00:10:09.360 --> 00:10:13.760
where you're changing, setting the color,
you're setting the font.

00:10:13.770 --> 00:10:15.440
You set that into the CG context.

00:10:15.440 --> 00:10:26.900
And until you change it again,
the state is maintained.

00:10:27.270 --> 00:10:30.830
So you can also save the state.

00:10:31.690 --> 00:10:34.020
So,
if you want to make changes to the state,

00:10:34.020 --> 00:10:37.220
for example, change the font color or
change the text color,

00:10:37.220 --> 00:10:40.170
or change the CTM,
change the color space information,

00:10:40.170 --> 00:10:43.010
do your drawing and then if
you want you can then restore

00:10:43.010 --> 00:10:45.830
it and when you restore it,
you're restoring it back to

00:10:45.830 --> 00:10:47.480
the state that you saved it at.

00:10:47.480 --> 00:10:51.900
You do not have to worry about restoring
all of the changes that you made.

00:10:51.900 --> 00:10:56.360
So, this way, this allows you to cleanly
get back to a state that,

00:10:56.480 --> 00:10:59.850
which undoes, under,
undoes the old state.

00:11:00.900 --> 00:11:03.730
all of the modifications
that you might have done.

00:11:06.010 --> 00:11:12.730
So the context that we support,
if you're working on screen,

00:11:12.750 --> 00:11:14.660
you're working with Cocoa or Carbon.

00:11:14.660 --> 00:11:20.540
So Cocoa and Carbon will
create a context for you.

00:11:20.620 --> 00:11:23.060
So on Cocoa side, you've got an NSView.

00:11:23.060 --> 00:11:25.740
You can actually get the
graphics context for that view.

00:11:25.740 --> 00:11:28.780
On the Carbon side,
you're working with a QuickDraw port.

00:11:30.000 --> 00:11:34.280
On QuickDraw,
you can actually make a function call

00:11:34.280 --> 00:11:38.070
to get at the context for that port.

00:11:38.130 --> 00:11:42.480
When you're printing,
you're also working with contexts.

00:11:42.500 --> 00:11:46.860
And those are created for
you from the printing system.

00:11:46.860 --> 00:11:51.920
Those could be a PostScript context,
or those could be a Raster context,

00:11:51.920 --> 00:11:53.480
depending on what the printer device is.

00:11:53.500 --> 00:11:58.120
In those cases, in the first two cases,
the context is created for you.

00:11:58.120 --> 00:11:59.860
We do provide two options.

00:12:00.000 --> 00:12:02.430
There are other contexts that
you can create explicitly.

00:12:02.770 --> 00:12:05.460
One is the CG bitmap, a PDF context.

00:12:05.460 --> 00:12:08.050
This is where you are trying
to generate a PDF document.

00:12:08.100 --> 00:12:11.360
So in order to generate a PDF document,
it's easy.

00:12:11.430 --> 00:12:14.900
All you do is create a PDF context
and now start drawing all of

00:12:14.900 --> 00:12:16.500
your things into that context.

00:12:16.510 --> 00:12:20.230
And it will, all of that,
all of the drawings that you,

00:12:20.250 --> 00:12:23.030
calls that you make will now
be saved into a PDF document.

00:12:23.040 --> 00:12:27.600
At the same time, if you choose to,
you could also create a bitmap context,

00:12:27.600 --> 00:12:29.880
which this is an off-screen context,
where you can create a bitmap context.

00:12:29.920 --> 00:12:32.770
Where everything will be rendered
into that off-screen bitmap.

00:12:32.780 --> 00:12:36.460
You could make the same set of
calls into that same context.

00:12:36.460 --> 00:12:41.160
And instead of being saved out to PDF,
because it is now a different context,

00:12:41.160 --> 00:12:43.700
you can now render the same set of calls.

00:12:46.390 --> 00:12:51.250
So now that you've got a context,
let's look at the drawing primitives that

00:12:51.330 --> 00:12:53.340
you would want to draw into that context.

00:12:53.590 --> 00:12:55.200
Basically, there's four in number.

00:12:55.200 --> 00:12:58.540
You've got vector geometry,
which is all of your line art,

00:12:58.550 --> 00:13:02.680
2D line art, things like your rectangle,
ellipse, paths.

00:13:03.280 --> 00:13:07.340
You've got text and images,
and then finally a PDF document.

00:13:07.340 --> 00:13:10.150
So on the previous slide
I had talked about,

00:13:10.280 --> 00:13:11.760
you know,
if you want to create a PDF document,

00:13:11.760 --> 00:13:14.930
and now we also allow you to take
a PDF document and draw that into

00:13:15.000 --> 00:13:16.940
a context as yet another primitive.

00:13:19.440 --> 00:13:23.440
The drawing operations are done
using the painter's algorithm.

00:13:23.440 --> 00:13:25.970
And that's basically,
you draw something onto a

00:13:25.980 --> 00:13:28.880
canvas or onto the device,
and you lay down ink for

00:13:28.880 --> 00:13:30.220
one drawing primitive.

00:13:30.220 --> 00:13:34.190
And then you lay down ink for the next
one on top and continue to do that.

00:13:34.200 --> 00:13:36.900
So it's a bottom to
top drawing operation.

00:13:36.980 --> 00:13:39.970
Things above you obscure
things below you.

00:13:40.690 --> 00:13:44.260
And in order to maintain
resolution independence,

00:13:44.440 --> 00:13:47.460
all of our drawing operations
support floating point coordinates.

00:13:47.510 --> 00:13:53.930
So you can even, with that,
you can define your shapes,

00:13:53.940 --> 00:13:57.620
define your positioning in the
coordinate system using floating points,

00:13:57.620 --> 00:14:01.420
and the appropriate translations
are done to the device,

00:14:01.420 --> 00:14:05.640
and that allows for high precision
and high fidelity output.

00:14:08.610 --> 00:14:12.660
So let's look at the first primitive,
which is vector geometry.

00:14:12.660 --> 00:14:15.680
Fundamentally,
vector geometry is represented

00:14:15.680 --> 00:14:17.010
as a path in Quartz.

00:14:18.910 --> 00:14:24.300
What you want to do there is you first
want to define the path into the context.

00:14:24.300 --> 00:14:29.740
The definition constructs that
internally in the context.

00:14:29.740 --> 00:14:32.430
And the next thing you
want to do is draw it.

00:14:32.430 --> 00:14:33.820
So drawing is simple.

00:14:33.820 --> 00:14:36.410
There's just one called
CG Context Draw Path.

00:14:36.780 --> 00:14:41.580
There are other convenience functions
that allow you to draw paths and shapes,

00:14:41.580 --> 00:14:45.660
but that's one that you would
probably use more explicitly.

00:14:47.090 --> 00:14:50.790
On the definition side, though,

00:14:51.320 --> 00:14:55.100
It's very similar to PostScript,
the PDF imaging model.

00:14:55.100 --> 00:14:59.680
Basically what you do is you begin a
path that destroys any paths that you

00:14:59.680 --> 00:15:02.140
might have in the context already.

00:15:03.000 --> 00:15:07.870
The first thing we want to do
after that is move to a point.

00:15:07.880 --> 00:15:10.240
You can also do line 2, curve 2.

00:15:10.340 --> 00:15:13.500
Curve 2 is a cubic Bezier curve.

00:15:13.500 --> 00:15:16.500
A chord curve 2 is a
quadratic Bezier curve.

00:15:16.510 --> 00:15:20.120
And if you choose to,
you may also want to close the path,

00:15:20.270 --> 00:15:23.350
because there's a difference between
an open path and a closed path in

00:15:23.410 --> 00:15:26.000
terms of how it will get rendered.

00:15:26.200 --> 00:15:29.940
So as an example,
I'm going to try and just draw

00:15:29.940 --> 00:15:36.460
a simple button-like shape
using some of these APIs.

00:15:36.830 --> 00:15:40.100
The first thing to keep in
mind is I'll be illustrating

00:15:40.100 --> 00:15:43.650
what the path will look like,
but the path isn't really being drawn

00:15:43.650 --> 00:15:45.450
into the context as I step through this.

00:15:45.460 --> 00:15:48.890
It's really being
collected into the context,

00:15:48.890 --> 00:15:53.960
so the illustration is just to show
what the context is collecting.

00:15:53.960 --> 00:15:58.280
You begin a path, you move to a point in
your coordinate system,

00:15:58.280 --> 00:16:03.160
and if you can see, that's just a point,
I've just illustrated that there.

00:16:04.360 --> 00:16:08.740
The move to sets the current
point in the context.

00:16:08.820 --> 00:16:12.660
Then you can perform a line to,
and that draws a line from the

00:16:12.660 --> 00:16:16.640
current point to the point that
you specify on the line to.

00:16:19.100 --> 00:16:23.310
Next thing I'm going to do is call
a curve to where I specify two

00:16:23.410 --> 00:16:27.270
control points and a final endpoint,
and that defines a cubic Bezier

00:16:27.390 --> 00:16:31.380
curve from the current point
to the endpoint specified.

00:16:31.580 --> 00:16:34.220
And similarly, as I keep going on,
the line to and the curve to.

00:16:34.220 --> 00:16:37.760
And as a result,
I'm able to define a shape.

00:16:37.770 --> 00:16:41.270
I can also explicitly
close that path also.

00:16:41.380 --> 00:16:45.430
So here's a sequence
that defines that shape.

00:16:45.740 --> 00:16:49.010
You don't necessarily have to go through
that sequence for some of the more

00:16:49.110 --> 00:16:51.680
common primitives that you are used to.

00:16:51.680 --> 00:16:53.650
For example, rectangle lines and arcs.

00:16:53.660 --> 00:16:55.810
Arcs can be used to define circles.

00:16:55.860 --> 00:16:58.880
We provide convenience functions,
which I haven't listed,

00:16:58.880 --> 00:17:00.250
but they're available.

00:17:00.260 --> 00:17:01.810
You don't have to construct all of those.

00:17:01.840 --> 00:17:04.250
For example, for a rectangle,
you don't have to do a move to, line to,

00:17:04.300 --> 00:17:05.460
line to, line to, line to.

00:17:05.460 --> 00:17:07.640
There's a simple convenience
function for that.

00:17:07.680 --> 00:17:10.290
Once you define the shape,
now you want to draw it.

00:17:10.420 --> 00:17:13.500
There are a few drawing
operations that you can do to it.

00:17:13.610 --> 00:17:15.690
You want to fill it,
you may want to clip it,

00:17:15.770 --> 00:17:17.310
and you may want to stroke it.

00:17:17.400 --> 00:17:21.580
So fill is really defining the content
of that shape that you've defined.

00:17:21.580 --> 00:17:24.500
There's a fill and an EO fill.

00:17:24.500 --> 00:17:25.980
I'll show you the
difference between the two.

00:17:27.770 --> 00:17:30.410
Instead of filling,
you could also choose to set the content

00:17:30.540 --> 00:17:32.710
of that shape to be a clipping region.

00:17:32.720 --> 00:17:38.060
Once you set a clip for a shape,
any drawing operation that you

00:17:38.070 --> 00:17:42.680
might do from that point onwards,
while the clip is currently

00:17:42.680 --> 00:17:46.080
set in the context,
all those drawing operations

00:17:46.080 --> 00:17:50.140
will be effectively clipped to
that shape that you've defined.

00:17:52.640 --> 00:17:57.450
You can also stroke the outline of
that shape with a pen effectively,

00:17:57.450 --> 00:18:00.430
and we provide for various
stroking parameters.

00:18:00.440 --> 00:18:03.630
You can set the width,
what happens at line joints,

00:18:03.630 --> 00:18:06.100
you can define that,
what happens at the end of a

00:18:06.100 --> 00:18:08.100
path in terms of the line cap.

00:18:08.140 --> 00:18:12.890
You can set the miter limits
and also specify line dash

00:18:13.180 --> 00:18:19.070
parameters to control the dashing,
effectively define a dot

00:18:19.070 --> 00:18:22.380
dash pattern on that line.

00:18:23.190 --> 00:18:24.850
So here are examples of paths.

00:18:24.940 --> 00:18:28.560
So on the top left,
you will see two open paths.

00:18:28.840 --> 00:18:31.560
One is a simple line,
one with a dash pattern,

00:18:31.560 --> 00:18:36.200
one using cubic Bezier curves,
using the curve tool.

00:18:36.200 --> 00:18:40.560
A more complicated
example on your top right.

00:18:40.560 --> 00:18:42.330
And here's the two stars.

00:18:42.430 --> 00:18:46.500
They illustrate the difference
between a fill and an EO fill.

00:18:47.190 --> 00:18:50.330
So on the bottom left,
the one which is not filled,

00:18:50.330 --> 00:18:53.220
on the center,
that's an EO fill because it's

00:18:53.220 --> 00:18:57.040
an even odd filling rule that
defines how things are filled.

00:18:57.040 --> 00:19:00.010
The other star is based
on the winding rule,

00:19:00.010 --> 00:19:02.840
which is the standard fill operation.

00:19:02.840 --> 00:19:10.940
Paths can be composed of sub-paths also,
and those paths can be disjoint.

00:19:10.940 --> 00:19:15.130
So as an example,
you could also do a donut-like shape

00:19:15.200 --> 00:19:18.200
where the sub-paths are really...
disjoint from the other one.

00:19:18.200 --> 00:19:20.810
And to do something like that,
all you do is perform

00:19:20.810 --> 00:19:23.000
another move-to operation.

00:19:24.080 --> 00:19:30.250
So with those path constructs,
you can actually generate

00:19:30.350 --> 00:19:33.430
really complicated 2D line art.

00:19:34.150 --> 00:19:38.900
Text is similar in nature because
characters are nothing more than...

00:19:38.930 --> 00:19:42.890
we work directly with outline fonts,
so...

00:19:43.060 --> 00:19:47.780
A glyph is really effectively
a path defined in the font.

00:19:47.820 --> 00:19:50.780
But you don't have to
work at it at that level.

00:19:50.780 --> 00:20:01.680
We provide glyph and drawing functions
to draw your text onto a context.

00:20:02.160 --> 00:20:04.200
And we support outline fonts.

00:20:04.200 --> 00:20:08.900
And most of these are coming from
our leveraging ATS on the system.

00:20:08.900 --> 00:20:15.080
There's two types, Type 1, OpenType,
CID fonts for systems which

00:20:15.090 --> 00:20:20.870
have a huge number of glyphs
in the order of thousands.

00:20:20.880 --> 00:20:25.190
Primarily Chinese, Japanese, Korean,
Vietnamese take advantage of that.

00:20:26.870 --> 00:20:31.000
And similarly to paths,
one thing you can do is fill it,

00:20:31.100 --> 00:20:33.710
stroke it, and clip it also.

00:20:37.160 --> 00:20:42.820
Text can, the functionality that we
provide is at the glyph level.

00:20:42.820 --> 00:20:45.830
That's the basic functionality,
that's the main functionality

00:20:45.830 --> 00:20:47.500
that Quartz provides.

00:20:47.500 --> 00:20:52.860
We also provide simple text
drawing functionality where it's

00:20:53.080 --> 00:20:56.040
primarily Mac Roman encoding.

00:20:56.040 --> 00:20:59.640
But for Unicode support,
what you really want to do is

00:21:00.020 --> 00:21:02.260
take advantage of Atsui above us.

00:21:02.600 --> 00:21:07.520
That will handle all of your
Unicode needs and your layout needs.

00:21:09.110 --> 00:21:13.320
So let's have a look at how the
APIs that you would want to use here.

00:21:13.360 --> 00:21:17.400
First thing you want to do
is create a CG font ref.

00:21:17.600 --> 00:21:23.880
That can come from a platform font,
for example, ATS font ref.

00:21:23.910 --> 00:21:27.140
There's another function that allows
you to select a font by name also.

00:21:28.340 --> 00:21:31.320
Once you've selected the
font into the context,

00:21:31.320 --> 00:21:33.790
effectively you do two things next.

00:21:33.920 --> 00:21:37.640
You set the text drawing mode,
one of the three types that I mentioned.

00:21:37.640 --> 00:21:39.040
Those could be mixed also.

00:21:39.040 --> 00:21:41.540
You might want to fill and
stroke or fill and set the clip.

00:21:41.750 --> 00:21:43.350
And then you just draw your text.

00:21:43.470 --> 00:21:45.960
There's the two types
that I was mentioning.

00:21:45.960 --> 00:21:49.560
If you want to draw text explicitly
or you want to draw glyphs.

00:21:49.560 --> 00:21:56.220
The context maintains a
current text position.

00:21:56.220 --> 00:21:58.060
So when you just do a draw text.

00:21:58.140 --> 00:22:01.810
Or sorry,
when you do a show text or a show glyph,

00:22:01.820 --> 00:22:05.210
it starts the text off at the current
text drawing position and draws

00:22:05.250 --> 00:22:07.010
your text from that point onwards.

00:22:07.020 --> 00:22:11.560
You could also and once the text
has been drawn to the context,

00:22:11.560 --> 00:22:14.590
it updates the text drawing position.

00:22:14.650 --> 00:22:19.360
You can explicitly also draw text
at by not by specifying the point

00:22:19.360 --> 00:22:22.150
that you want to start it at also.

00:22:23.020 --> 00:22:26.060
So that covers text,
and that's our second

00:22:26.090 --> 00:22:28.400
primitive in the system.

00:22:28.590 --> 00:22:30.740
The next one I'll focus on is images.

00:22:30.740 --> 00:22:34.430
We've got support for various
types of image formats,

00:22:34.510 --> 00:22:38.440
primarily through the various
color spaces that we support.

00:22:38.440 --> 00:22:41.190
So we support RGB, LAB, CMYK images.

00:22:41.250 --> 00:22:44.180
You can draw all of these into a context.

00:22:44.180 --> 00:22:47.320
And because we also work
heavily with ColorSync,

00:22:47.320 --> 00:22:52.100
we also support ICC profile-based
images or ICC profile-based color spaces

00:22:52.100 --> 00:22:54.720
that you can associate with an image.

00:22:55.120 --> 00:22:58.000
And it will be appropriately
color managed for you when

00:22:58.000 --> 00:22:59.720
you render it into a context.

00:23:01.710 --> 00:23:05.150
We support an alpha channel,
and an alpha channel is nothing

00:23:05.150 --> 00:23:06.600
more than another channel.

00:23:06.600 --> 00:23:09.470
So in an example where
you've got an RGB image,

00:23:09.480 --> 00:23:14.270
the alpha channel will be yet
another component in that,

00:23:14.400 --> 00:23:17.040
and that represents the transparency
for that color component.

00:23:18.430 --> 00:23:20.380
The data could also be
pre-multiplied or not,

00:23:20.390 --> 00:23:28.580
which effectively means it determines
whether the color values have been

00:23:28.580 --> 00:23:30.450
pre-multiplied by the alpha or not.

00:23:30.520 --> 00:23:32.480
So that's provided in the system also.

00:23:34.530 --> 00:23:41.200
Also, we also can create images which are
one-bit or eight-bit image masks.

00:23:41.200 --> 00:23:44.180
Once you create an image like that,
you can also draw that into a context.

00:23:44.180 --> 00:23:48.440
Once you draw that image,
what you're effectively doing is the

00:23:48.450 --> 00:23:52.180
current color that's been set into the
context will be drawn through that mask.

00:23:52.180 --> 00:23:56.040
So that's another interesting feature
that we've got in Quartz also.

00:23:57.170 --> 00:23:58.530
So using images are very simple.

00:23:58.600 --> 00:24:01.830
First thing you want to do is
basically create a CG image graph,

00:24:01.840 --> 00:24:04.490
and you want to call it
CG image create function.

00:24:04.600 --> 00:24:07.680
And when you're creating that image,
you're specifying all the

00:24:07.680 --> 00:24:09.600
parameters that define that image.

00:24:09.600 --> 00:24:12.920
You're specifying the width, the height,
how many bits there

00:24:12.920 --> 00:24:17.000
are in that component,
bits per pixel, the color space,

00:24:17.000 --> 00:24:20.600
whether it's RGB, LAMP, CMYK, whatnot.

00:24:20.900 --> 00:24:46.900
[Transcript missing]

00:24:47.950 --> 00:24:49.690
Once you're done creating that image,
and it's very simple

00:24:49.690 --> 00:24:52.470
from that point onwards,
you just draw that CG context,

00:24:52.660 --> 00:24:56.250
call the CG context draw image call,
and you specify a rectangle that

00:24:56.270 --> 00:24:57.840
you want the image to be drawn into.

00:25:00.790 --> 00:25:03.650
PDF documents are very similar
in nature in the sense that

00:25:03.780 --> 00:25:06.690
they're as simple as images.

00:25:06.860 --> 00:25:11.060
First thing you want to do
is create a PDF document ref.

00:25:11.140 --> 00:25:15.760
You can create a PDF document
ref from a file on disk,

00:25:15.760 --> 00:25:18.480
or if you've got one in memory,
you can create a PDF document ref.

00:25:18.510 --> 00:25:20.920
You've got functions for that.

00:25:22.070 --> 00:25:27.240
Once you've got that PDF document that
effectively points to the document,

00:25:27.540 --> 00:25:31.160
all you want to do is just
draw that into a context.

00:25:31.160 --> 00:25:35.950
And the function that you use there
is a CG context draw PDF document.

00:25:36.180 --> 00:25:38.880
We also provide some convenience
functions that allow you to get

00:25:38.910 --> 00:25:43.100
the bounding box or the number
of pages in that PDF document.

00:25:43.100 --> 00:25:45.180
So those are provided.

00:25:46.690 --> 00:25:49.480
So now that we've covered all
of the drawing primitives,

00:25:49.500 --> 00:25:54.490
you may want to do some neat
effects while you're drawing.

00:25:54.720 --> 00:25:58.510
One thing that you might want to
do is look at the transformation

00:25:58.590 --> 00:26:01.120
model that we've got in Quartz.

00:26:01.590 --> 00:26:08.660
The initial coordinate system is
anchored at an origin on the bottom left.

00:26:08.950 --> 00:26:11.040
So your 0, 0 is at the bottom left.

00:26:11.220 --> 00:26:13.620
This is different from QuickDraw,
if you're familiar with that,

00:26:13.640 --> 00:26:14.880
which is at your top left.

00:26:14.880 --> 00:26:20.330
And it's anchored in the bottom left,
and it's like a Cartesian graph,

00:26:20.380 --> 00:26:25.220
so it's increasing Y upwards
and X increasing to your right.

00:26:28.550 --> 00:26:30.290
That's your initial coordinate system.

00:26:30.350 --> 00:26:34.730
That's the coordinate system that
you get when you get a context.

00:26:34.760 --> 00:26:39.910
And now you can modify that by applying
a transformation onto that context.

00:26:40.430 --> 00:26:42.050
So there are transformations like,
you know,

00:26:42.060 --> 00:26:46.980
the simple examples are rotations,
translate, scales, you may want to skew.

00:26:46.980 --> 00:26:51.100
You could even build up complex
transformations yourself.

00:26:51.120 --> 00:26:53.400
So we provide two mechanisms for that.

00:26:53.400 --> 00:26:59.440
One is that you draw--you set the
transform as in the--modify the

00:26:59.440 --> 00:27:04.960
current CTM that's inside the context
directly by making context calls.

00:27:04.960 --> 00:27:09.110
And the other thing you do is you
can--we've got affine transform

00:27:09.110 --> 00:27:15.100
classes that allow you to--that
allow you to build up a transform.

00:27:15.140 --> 00:27:17.650
And then you can--once you've
built the appropriate transform,

00:27:17.690 --> 00:27:18.890
you can set that into the context.

00:27:21.360 --> 00:27:25.440
So let me just go into that
and show it as an example.

00:27:25.440 --> 00:27:29.960
So here is the default coordinate system.

00:27:30.010 --> 00:27:33.800
So let's say we're just
drawing a unit square.

00:27:34.100 --> 00:27:40.900
[Transcript missing]

00:27:42.830 --> 00:27:48.180
If we were to modify the
CTM prior to drawing the path,

00:27:48.310 --> 00:27:50.630
prior to drawing the rectangle,
and let's say we're just

00:27:50.730 --> 00:27:55.110
doing a rotate operation,
so it's going to rotate about the origin,

00:27:55.150 --> 00:27:57.640
Notice the new coordinate system.

00:27:58.040 --> 00:27:59.290
It started out like this.

00:27:59.290 --> 00:28:00.780
It's now rotated.

00:28:00.780 --> 00:28:03.680
So now any drawing operations
you do from that point onwards,

00:28:03.680 --> 00:28:06.780
for example, are rectangle,
are now relative to that new

00:28:06.790 --> 00:28:08.940
coordinate system that's in place.

00:28:10.960 --> 00:28:14.800
Let's say you were to also insert,
before drawing the path,

00:28:14.810 --> 00:28:17.630
you were also to draw, apply a scale.

00:28:17.630 --> 00:28:23.420
So now we're building on that rotation
that we had applied earlier and now

00:28:23.490 --> 00:28:26.060
we're performing a scale on top of that.

00:28:26.270 --> 00:28:29.380
And similarly,
if you were to perform a translate,

00:28:29.380 --> 00:28:33.970
but you translate in the X direction,
it's not X relative to the

00:28:33.970 --> 00:28:37.070
original coordinate system,
it's relative to the most recent,

00:28:37.260 --> 00:28:42.040
effectively to the current transformation
matrix that's in the system.

00:28:42.040 --> 00:28:46.700
So you'll notice that it's, in this case,
it's translating to the top right,

00:28:46.700 --> 00:28:51.440
even though what we may have specified
is a translation in the X direction.

00:28:53.180 --> 00:28:57.400
So using this, you can actually build up
really complex transformations.

00:28:57.510 --> 00:29:02.650
Notice you do not have to do
the calculations and calculate

00:29:02.660 --> 00:29:04.090
the points for that rectangle.

00:29:04.250 --> 00:29:07.340
You can still continue to draw
your rectangle as if it was in

00:29:07.340 --> 00:29:10.080
the original coordinate system.

00:29:10.080 --> 00:29:12.800
It's just applied based on the
current transformation that is

00:29:12.800 --> 00:29:17.030
set up for you or that you might
have set up explicitly yourself.

00:29:19.240 --> 00:29:23.600
So we've talked about transformations.

00:29:23.600 --> 00:29:26.130
We've talked about
some of the primitives.

00:29:26.170 --> 00:29:29.370
One thing I want to get into next
is the color spaces that we support.

00:29:29.410 --> 00:29:34.230
So when you're trying to
draw vector geometry or text,

00:29:34.310 --> 00:29:39.120
you want to be able to draw that
with a variety of color spaces.

00:29:39.140 --> 00:29:40.660
And here are the ones that we support.

00:29:40.660 --> 00:29:44.880
So the first one is a
device-based color spaces.

00:29:44.880 --> 00:29:49.780
These are color spaces where you
know what the destination device is.

00:29:49.780 --> 00:29:52.100
These are usually very
simple for people to create,

00:29:52.100 --> 00:29:54.100
and that's what most people end up using.

00:29:54.100 --> 00:29:56.080
But that's not what we
recommend necessarily.

00:29:56.080 --> 00:29:59.760
So in this case, you've got RGB, gray,
and CMYK.

00:29:59.760 --> 00:30:03.530
You know what the destination is,
and you're telling Quartz you do

00:30:03.530 --> 00:30:05.580
not want it to be color managed.

00:30:05.580 --> 00:30:10.260
Alternately,
what we recommend is for people to use

00:30:10.430 --> 00:30:16.580
calibrated color spaces or even go as far
as tagging your data with an ICC profile.

00:30:16.580 --> 00:30:21.800
So you create these color spaces
from a profile or from a calibrated

00:30:21.800 --> 00:30:23.500
space where you've specified.

00:30:24.150 --> 00:30:29.300
You know, things like the gamma and the
white point for that color space.

00:30:29.320 --> 00:30:34.470
And once that color space is set,
your drawing operations for your text

00:30:34.610 --> 00:30:39.690
and your vector geometry will then be
color managed for you appropriately.

00:30:39.700 --> 00:30:43.820
There's the LAB color
space also that we support.

00:30:43.820 --> 00:30:49.120
And the last one is an index color space,
which is nothing more.

00:30:49.120 --> 00:30:52.780
You have to have a reference color space,
for example, the RGB color space.

00:30:52.780 --> 00:30:54.060
And you.

00:30:54.060 --> 00:30:57.440
You build up an array of colors.

00:30:57.440 --> 00:30:59.660
And your.

00:31:00.160 --> 00:31:05.220
The color that you specify is done
through an index into that color table.

00:31:05.220 --> 00:31:09.440
So this is very similar
to GIF or palettes images.

00:31:11.970 --> 00:31:17.020
So in order to work with
color using our API,

00:31:17.020 --> 00:31:18.800
what you want to do is
create a color space.

00:31:18.800 --> 00:31:21.350
It's one of the ones
from the previous slides.

00:31:21.470 --> 00:31:26.300
Once you've created a color space,
if you want to set that for the-- you

00:31:26.300 --> 00:31:29.200
can do it for both fill and stroke.

00:31:29.280 --> 00:31:33.020
So you can make calls to
set the fill color space,

00:31:33.020 --> 00:31:36.240
and you can make calls to
set the stroke color space.

00:31:36.500 --> 00:31:38.880
Now that that is selected
into the context,

00:31:38.880 --> 00:31:43.290
when you're specifying the colors,
you pass it an array of color values

00:31:43.310 --> 00:31:46.080
for the component of that color space.

00:31:46.110 --> 00:31:49.870
For example, in RGB,
you'd be specifying the R, G,

00:31:49.960 --> 00:31:53.320
and B components as an
array of color values.

00:31:55.390 --> 00:31:58.190
We also allow you to add alpha values.

00:31:58.340 --> 00:32:02.800
So when you set the color,
you can also pass in an alpha value.

00:32:02.820 --> 00:32:05.600
And that leads us to transparency.

00:32:07.250 --> 00:32:09.040
You can set a global
alpha into the context.

00:32:09.080 --> 00:32:13.180
So what that means is when
you set an alpha value,

00:32:13.220 --> 00:32:16.280
all of the drawing that you do from
that point onwards will inherit

00:32:16.630 --> 00:32:19.580
that transparency value effectively.

00:32:19.680 --> 00:32:23.900
So it will be composited for
you to the appropriate device.

00:32:24.600 --> 00:32:27.840
Alternately,
you can also set that on the fill

00:32:27.940 --> 00:32:30.200
or on the stroke explicitly also.

00:32:30.200 --> 00:32:35.930
The global alpha can be applied
to PDF documents that you might

00:32:35.930 --> 00:32:37.050
want to render into the context.

00:32:37.090 --> 00:32:39.150
It would apply to text,
to all of the primitives

00:32:39.150 --> 00:32:40.410
that we've talked about.

00:32:41.940 --> 00:32:46.300
Whereas the fill and stroke ones only
apply to text and to vector geometry.

00:32:48.800 --> 00:32:54.380
Transparency is supported on screen
context and for BitNap context because

00:32:54.380 --> 00:33:00.530
the appropriate compositing is done for
you when you specify the alpha value.

00:33:01.430 --> 00:33:07.090
On the PDF context,
we currently do not support transparency.

00:33:07.130 --> 00:33:12.870
The transparency model in PDF is
part of the 1.4 spec that we

00:33:12.870 --> 00:33:14.540
currently have not implemented.

00:33:14.540 --> 00:33:22.460
The 1.4 spec is currently not published,
and we're working with

00:33:22.460 --> 00:33:25.550
Adobe to track that spec.

00:33:25.600 --> 00:33:28.300
We currently support 1.2 and 1.3.

00:33:28.300 --> 00:33:35.640
A lot of what we support in terms of the
PDF specification was discussed in the

00:33:35.640 --> 00:33:39.530
PDF and Mac OS X talk prior to this one.

00:33:39.540 --> 00:33:43.790
And because PDF plays an important
role in the printing workflow,

00:33:44.060 --> 00:33:48.240
because that's the spool file,
you will also not get transparency

00:33:48.250 --> 00:33:50.380
on your printing contacts.

00:33:52.980 --> 00:33:56.190
So that's something to keep in mind
because it will work on screen,

00:33:56.190 --> 00:34:01.440
but until we add support for it
on the PDF and the printing side,

00:34:01.440 --> 00:34:04.100
you will not get that necessarily
on the printed output.

00:34:06.310 --> 00:34:10.010
So one thing, other thing I wanted to
cover was data provider,

00:34:10.090 --> 00:34:12.780
data managers,
and examples of those are data

00:34:12.780 --> 00:34:14.300
providers and data consumers.

00:34:14.300 --> 00:34:20.240
This is nothing more than a way for
Quartz to provide data to you or

00:34:20.240 --> 00:34:23.640
for you to provide data to Quartz.

00:34:23.640 --> 00:34:27.250
So in the example of an image
where you were creating an image,

00:34:27.400 --> 00:34:29.570
you're trying to provide the...

00:34:30.900 --> 00:34:33.440
The bitmap bits to Quartz.

00:34:33.440 --> 00:34:39.560
So you first have to create a
data provider and pass that in.

00:34:39.560 --> 00:34:44.710
You're passing in the memory pointer
if that happens to be the one,

00:34:44.710 --> 00:34:49.480
that happens to be the type of data
provider that you're working with.

00:34:49.890 --> 00:34:53.700
If you're also working with
a PDF document that you have

00:34:53.710 --> 00:34:55.920
on disk or something else,
you do the same thing.

00:34:55.920 --> 00:35:01.620
You have to create a data provider that
allows Quartz to get at the data that

00:35:01.830 --> 00:35:04.870
resides on disk or wherever it may lie.

00:35:04.880 --> 00:35:06.840
So we provide convenience functions.

00:35:06.840 --> 00:35:12.230
Most likely you've got the file loaded
already or it's already on disk.

00:35:12.630 --> 00:35:17.490
So we've got convenience functions that
allow you to create data providers and

00:35:17.490 --> 00:35:21.020
data consumers from memory and from disk.

00:35:21.050 --> 00:35:24.340
And we use the CFURL mechanism
for defining the path for that.

00:35:28.190 --> 00:35:33.090
And some miscellaneous items.

00:35:33.100 --> 00:35:39.100
One thing, if you're drawing on screen,
you have to understand that

00:35:39.110 --> 00:35:41.860
you're drawing into a back buffer.

00:35:41.860 --> 00:35:43.050
It's buffered for you.

00:35:43.060 --> 00:35:45.990
There's double buffering
that's applied to the system.

00:35:46.000 --> 00:35:49.510
You're not drawing directly to screen.

00:35:49.620 --> 00:35:51.640
So you would want to do
a flushing operation.

00:35:51.700 --> 00:35:58.860
So if you wanted to see that drawing
operation immediately onto the screen.

00:35:58.860 --> 00:36:01.980
There's also another function
called CGContextSynchronize.

00:36:01.990 --> 00:36:06.890
And that's primarily similar to flushing,
except it allows you to synchronize

00:36:06.900 --> 00:36:12.510
drawing from multiple components
so that they're all atomically

00:36:12.640 --> 00:36:13.920
flushed at the same time.

00:36:13.940 --> 00:36:18.630
You may want to call into a plug-in,
for example,

00:36:18.710 --> 00:36:20.660
to do some drawing into a context.

00:36:20.750 --> 00:36:26.680
But you don't want the
drawing to appear immediately.

00:36:26.680 --> 00:36:30.000
So you'd expect that
plug-in to synchronize.

00:36:30.000 --> 00:36:38.530
And then you may then choose to flush
the contents on your own when you're

00:36:38.530 --> 00:36:43.300
ready to flush the appropriate pieces.

00:36:43.300 --> 00:36:45.840
Once they're all done drawing,
you want to have that

00:36:45.840 --> 00:36:47.460
appear atomically on screen.

00:36:47.460 --> 00:36:49.920
You don't want things to
flash onto the screen.

00:36:49.970 --> 00:36:53.470
So that's another function
that you can take advantage of.

00:36:55.580 --> 00:37:00.140
If you're working with QuickDraw,
you're probably imaging through

00:37:00.140 --> 00:37:04.300
the QuickDraw APIs already,
but you may choose to also

00:37:04.330 --> 00:37:06.420
work with CG at the same time.

00:37:06.420 --> 00:37:09.760
So there would be some interactions
if you're trying to do imaging

00:37:09.760 --> 00:37:12.210
at both at the same time,
or if you want to,

00:37:12.540 --> 00:37:16.630
given a QuickDraw port,
how do you get at a CG context for that?

00:37:16.660 --> 00:37:21.170
So those interactions are actually
discussed in the Graphics and Imaging

00:37:21.170 --> 00:37:23.900
Tips and Tricks talks on Friday morning.

00:37:24.460 --> 00:37:27.610
So that's a very important talk
if you're working with Carbon or

00:37:27.740 --> 00:37:29.620
if you're working with QuickDraw.

00:37:29.620 --> 00:37:32.480
It focuses on two aspects.

00:37:32.540 --> 00:37:35.480
One is the QuickDraw CG and
printing interaction,

00:37:35.480 --> 00:37:39.680
and also discusses performance
issues related to flushing,

00:37:39.680 --> 00:37:42.260
and we've got some tools
that will help you there.

00:37:44.580 --> 00:37:50.100
Now I want to bring up
Andrew Barnes to do a demo that

00:37:50.100 --> 00:37:53.330
demonstrates the power of Quartz.

00:38:04.330 --> 00:38:06.620
So as Haroon indicated,
there are four types of objects.

00:38:06.650 --> 00:38:09.780
There's line art, text, images,
and PDF documents.

00:38:09.780 --> 00:38:14.700
This demo is going to demonstrate how
to draw all four of these documents,

00:38:14.700 --> 00:38:17.160
or draw all four of these things,
as well as it's going to go

00:38:17.160 --> 00:38:18.600
through some code examples.

00:38:19.970 --> 00:38:21.520
When I was in the audience,
I saw a lot of people

00:38:21.520 --> 00:38:22.800
taking a lot of notes.

00:38:22.800 --> 00:38:26.210
This, the code fragments that I'm
going to be showing you are

00:38:26.210 --> 00:38:29.840
probably going to be available,
or definitely I'm going to make sure

00:38:29.840 --> 00:38:33.100
they are available on our website so
you don't have to take down the notes

00:38:33.100 --> 00:38:34.820
because it's a fair chunk of code.

00:38:36.600 --> 00:38:40.440
So the first thing we're going to
start off with is just normal line art.

00:38:40.900 --> 00:38:47.660
We have a little demonstration
here and we show the Apple logo,

00:38:47.870 --> 00:38:49.230
which is a nice logo.

00:38:49.250 --> 00:38:53.200
Should have made it yellow in
keeping with today's color.

00:39:17.430 --> 00:39:17.430
So it's the Apple logo.

00:39:17.430 --> 00:39:17.430
So here is a stroked rectangle,
our favorite star that does some

00:39:17.430 --> 00:39:17.430
strange things to show EO Phil,
and some stroking where the dash pattern.

00:39:17.430 --> 00:39:17.430
Dashing is just basically
a way to show the

00:39:17.610 --> 00:39:20.340
In the API, it's specified as an array
of floating point values.

00:39:20.340 --> 00:39:25.190
They basically specify how much to go on,
how much to go off, how much to go on,

00:39:25.190 --> 00:39:26.220
how much to go off.

00:39:26.220 --> 00:39:29.450
And there's an extra phase parameter
that allows you to take your start

00:39:29.450 --> 00:39:31.420
point and move it through that array.

00:39:31.440 --> 00:39:36.500
So for an example,
we are going to move things around.

00:39:36.560 --> 00:39:40.180
So as you can see, I'm just adjusting the
phase based on some number.

00:39:40.180 --> 00:39:44.760
And so all of this stuff is all--
it rotates like normal scales.

00:39:47.500 --> 00:39:52.950
So let's see how we do that.

00:39:54.270 --> 00:39:56.870
Let's start off with something
pretty straightforward.

00:39:56.990 --> 00:40:00.690
It's going to be-- every object that's
ever drawn in this little demonstration

00:40:00.690 --> 00:40:05.250
program is going to have a draw state,
specifies a transformation,

00:40:05.260 --> 00:40:08.480
specifies some alpha,
specifies a bounding box of the

00:40:08.480 --> 00:40:10.740
object in the object's user space.

00:40:10.740 --> 00:40:13.520
So if I were drawing an
object that was a unit,

00:40:13.680 --> 00:40:16.620
let's say a glyph,
I placed a glyph inside of a unit square,

00:40:16.660 --> 00:40:19.480
the bounding box would
basically be 0 to 1,

00:40:19.480 --> 00:40:19.980
1.

00:40:19.980 --> 00:40:21.310
So we do that.

00:40:21.600 --> 00:40:24.750
We keep track of this information
associated with the object so that

00:40:24.790 --> 00:40:27.530
we can adjust the transformation
such that our particular point

00:40:27.530 --> 00:40:29.860
that we want on the screen,
which is point A,

00:40:29.890 --> 00:40:32.880
is going to be mapped at the
center of that bounding box.

00:40:32.960 --> 00:40:36.170
So that bounding box information is
kept in track with the object so the

00:40:36.170 --> 00:40:38.760
object can do its proper transformation.

00:40:38.840 --> 00:40:40.370
And then there's a progress indicator.

00:40:40.580 --> 00:40:43.170
For instance,
that little dashing movement thing

00:40:43.170 --> 00:40:44.500
was done with a progress indicator.

00:40:44.500 --> 00:40:47.830
So that's-- it's just an extra
piece of data that gets added on.

00:40:47.900 --> 00:40:54.360
So as Haroon indicated,
there is-- the transformation state.

00:40:54.410 --> 00:40:59.770
Now, there's a current transformation
that exists on the context,

00:40:59.900 --> 00:41:02.260
PDF or raster context.

00:41:02.310 --> 00:41:05.490
And you have to set
your transformation up.

00:41:05.570 --> 00:41:08.600
So given a draw state,
which was this other stuff before with x,

00:41:08.600 --> 00:41:10.240
y, width, and height,
where you simply go through

00:41:10.240 --> 00:41:12.600
very basic stuff like translate,
rotate, scale,

00:41:12.690 --> 00:41:16.420
and this is the little piece of
code that will make sure that your

00:41:16.420 --> 00:41:19.790
bounding box is centered at that point.

00:41:19.860 --> 00:41:21.600
So it just basically
translates and moves.

00:41:21.600 --> 00:41:23.100
It's a little bit of
a half kind of thing.

00:41:23.100 --> 00:41:25.550
So if you have a draw state,
you can get back a transform.

00:41:25.700 --> 00:41:27.310
Now--

00:41:28.240 --> 00:41:32.630
If you have a draw state and you
want to apply this transformation,

00:41:32.630 --> 00:41:34.760
there's a little piece of dubious
code in here that basically says,

00:41:34.760 --> 00:41:37.220
OK, if your transform is null,
then just take the matrix.

00:41:37.220 --> 00:41:39.690
But that's just to show you
that you can either be working

00:41:39.800 --> 00:41:43.000
with a transform object,
which a lot of people like working with.

00:41:43.060 --> 00:41:44.660
They would just be able
to modify the transform,

00:41:44.660 --> 00:41:46.630
and they keep the transform
associated with their object,

00:41:46.630 --> 00:41:47.660
and they move that around.

00:41:47.660 --> 00:41:48.900
And then they say, OK, draw with this.

00:41:48.920 --> 00:41:51.860
Or they keep the parameters explicit,
you know, x, y, width, and height.

00:41:51.860 --> 00:41:55.920
Or, sorry, x, y, angle, and scale,
and then you basically apply the two.

00:41:56.160 --> 00:41:58.120
So in both cases,
we're going to apply this

00:41:58.120 --> 00:41:59.360
to our current context.

00:41:59.360 --> 00:42:01.140
In this particular case,
we have a transform.

00:42:01.140 --> 00:42:02.880
You concatenate the transform
with the current CTM.

00:42:02.880 --> 00:42:05.180
So if you start off with an
upright and you do some rotation,

00:42:05.180 --> 00:42:07.890
something kind of goes there,
and then you can draw your object.

00:42:07.900 --> 00:42:11.980
In the other case, it's like, OK,
I've got my explicit components.

00:42:11.980 --> 00:42:15.510
I can either build a transform, right,
by concatenating all

00:42:15.540 --> 00:42:17.970
these things together,
or I can apply them

00:42:18.030 --> 00:42:19.910
directly to the context,
right?

00:42:19.920 --> 00:42:22.160
And in that way,
I'm actually modifying the

00:42:22.160 --> 00:42:24.640
current CTM as a series,
as a bunch of steps.

00:42:25.600 --> 00:42:28.180
So that's what that code does,
which is basically the same

00:42:28.180 --> 00:42:29.530
as this other code on top.

00:42:29.540 --> 00:42:34.660
So, OK,
so now we are going to draw a path.

00:42:34.700 --> 00:42:37.480
So there are two things
we can do with a path.

00:42:37.500 --> 00:42:38.990
We can either fill it
or we can stroke it.

00:42:40.760 --> 00:42:45.120
For this current demo,
the only thing that is really applicable

00:42:45.290 --> 00:42:47.490
to the fill state is the color.

00:42:47.500 --> 00:42:51.730
Once you get a fill state, our operation,
if it wants to apply a fill color,

00:42:51.730 --> 00:42:54.640
is going to say apply fill
color or fill state apply,

00:42:54.640 --> 00:42:58.340
and that will basically apply
the color space and the color.

00:42:58.340 --> 00:43:00.100
Those are pretty straightforward.

00:43:00.780 --> 00:43:02.760
The stroke state is a
little bit more complicated.

00:43:02.760 --> 00:43:05.210
Stroking is obviously
going to be a color.

00:43:05.210 --> 00:43:08.530
You can set the fill and the
stroke color independently.

00:43:08.530 --> 00:43:11.620
When you're stroking,
you're going to be using

00:43:11.620 --> 00:43:15.720
the line state or the line
parameters inside of the context.

00:43:15.720 --> 00:43:19.440
There is the line width and the joining.

00:43:19.440 --> 00:43:25.600
There are joins that are rounded
versus miter joins or butt joins.

00:43:25.600 --> 00:43:28.910
Then there's capping,
which is when you stop a segment,

00:43:28.970 --> 00:43:30.620
what happens to the end?

00:43:30.660 --> 00:43:32.650
Does it get rounded or
it just gets chopped?

00:43:32.730 --> 00:43:33.840
Or what happens to the join?

00:43:33.840 --> 00:43:39.800
And then there's this dash array,
which is this array where you set

00:43:39.800 --> 00:43:43.120
your points for your phase and you
specify a sequence of on and off.

00:43:46.410 --> 00:43:50.300
This stroke state is basically passed
to the object if it needs to stroke

00:43:50.300 --> 00:43:52.560
and basically just does those things.

00:43:52.560 --> 00:43:56.720
Set the line joint, the cap, the width,
set the dashes, and set the color.

00:43:56.730 --> 00:43:58.840
Pretty straightforward.

00:43:59.280 --> 00:44:01.430
So now we're talking about paths.

00:44:01.510 --> 00:44:03.620
For the purposes of this demo,
it's very simple.

00:44:03.760 --> 00:44:07.500
It's just an array of segment
types and array of coordinates.

00:44:07.500 --> 00:44:09.410
And all this little
tiny loop goes through.

00:44:09.430 --> 00:44:12.120
It's just say, if it's a move 2,
pick the two coordinates off.

00:44:12.140 --> 00:44:12.660
Put them on.

00:44:12.660 --> 00:44:15.020
If it's a line 2, curve 2,
four coordinates.

00:44:15.110 --> 00:44:17.500
So it's very straightforward.

00:44:17.500 --> 00:44:20.760
Again, this will be in the website.

00:44:21.680 --> 00:44:27.040
So now our path example goes in and says,
OK, I've got a path object

00:44:27.040 --> 00:44:28.120
and I want to draw.

00:44:28.200 --> 00:44:32.180
So all it has to do is
apply its transform,

00:44:32.190 --> 00:44:36.360
code that you saw above,
apply its fill state,

00:44:36.420 --> 00:44:43.920
apply its stroke state, set the alpha,
if anybody sets any alpha, begin a path,

00:44:43.930 --> 00:44:48.400
enumerate the path segments,
and then draw your path.

00:44:48.410 --> 00:44:51.190
And then you're done, pretty much.

00:44:51.360 --> 00:44:53.520
So a lot of these parameters
have default values.

00:44:53.520 --> 00:44:55.420
For instance,
unless you're doing something

00:44:55.420 --> 00:44:58.120
strange with stroking,
you really don't have to set the

00:44:58.120 --> 00:45:02.080
cap and the join or the dashes if
you're just doing a straight line.

00:45:02.080 --> 00:45:09.200
But the other caveat to this is
that if you're unsure of what

00:45:09.200 --> 00:45:11.920
your state in your context is,
you must set it.

00:45:11.920 --> 00:45:15.410
I mean, you can't really assume that,
oh my gosh, the font size is going

00:45:15.410 --> 00:45:16.440
to be the correct size.

00:45:16.440 --> 00:45:21.040
And then, OK, I'll just show some
text or show something.

00:45:21.040 --> 00:45:23.540
But you're not always sure
where that thing came from.

00:45:23.540 --> 00:45:26.880
But if you are sure,
you definitely do not have to do it.

00:45:26.880 --> 00:45:30.350
If you make modifications,
as Haroun indicated,

00:45:30.360 --> 00:45:33.400
to the current graphic state,
you can bracket it by a save

00:45:33.400 --> 00:45:35.900
and a restore so that you can
make little tiny twiddling.

00:45:35.900 --> 00:45:37.960
I can change the color
or change the dashing.

00:45:37.960 --> 00:45:40.600
Then you can restore your changes,
which just revert the context

00:45:40.600 --> 00:45:43.580
back or revert the current state
back to what it was before.

00:45:43.580 --> 00:45:46.600
So whenever these functions or
this function or all of these

00:45:46.700 --> 00:45:49.260
demo functions are called,
what I do is I basically do

00:45:49.260 --> 00:45:50.710
my bracket and I do my end.

00:45:51.040 --> 00:45:56.890
With reference to the synchronize call,
you could possibly do-- I could

00:45:56.890 --> 00:45:59.930
either do a flush here if I wanted
to flush each object independently,

00:45:59.940 --> 00:46:02.440
or I could do a synchronize, which says,
I'm finished drawing my stuff.

00:46:02.440 --> 00:46:03.380
Synchronize it.

00:46:03.410 --> 00:46:04.940
And let's move on.

00:46:04.940 --> 00:46:06.860
OK, so in saying that, let's move on.

00:46:07.080 --> 00:46:08.290
So we move to our second demo.

00:46:08.420 --> 00:46:11.740
So we're saying our second demo is text.

00:46:11.740 --> 00:46:13.720
So we can fill and stroke text.

00:46:13.720 --> 00:46:15.580
And we can think text.

00:46:15.580 --> 00:46:17.140
And we can stroke.

00:46:17.140 --> 00:46:20.480
And of course, you can rotate, scale.

00:46:20.480 --> 00:46:23.420
You know, usual stuff.

00:46:23.420 --> 00:46:25.560
And--

00:46:26.680 --> 00:46:30.520
So let's go to our little demo.

00:46:30.580 --> 00:46:34.270
So now we're moving on to this case.

00:46:34.930 --> 00:46:37.550
Broken up into two sections.

00:46:37.640 --> 00:46:41.130
First section has to do with text.

00:46:41.700 --> 00:46:46.020
Text, in this particular example,
this is slightly misnamed,

00:46:46.040 --> 00:46:50.580
but it really has to do with a
ASCII string of text with some encoding.

00:46:50.660 --> 00:46:52.980
For this particular example,
it's going to be macro encoding.

00:46:52.980 --> 00:46:54.530
So we're going to get
some string of text,

00:46:54.530 --> 00:46:56.790
and we're just going to say, OK,
I want to deal with the string

00:46:56.860 --> 00:46:59.100
of text in macro encoding.

00:46:59.360 --> 00:47:04.190
So, like the path example,
it's pretty straightforward.

00:47:04.200 --> 00:47:07.100
You know, when the object comes in,
it has a draw state,

00:47:07.180 --> 00:47:08.350
has a text rendering mode.

00:47:08.350 --> 00:47:10.830
That's how you're able
to get the strokes.

00:47:10.830 --> 00:47:14.240
It has a font size, a character,
you know, and some text.

00:47:16.580 --> 00:47:21.890
So basically, when the draw happens,
we apply the transformation,

00:47:21.900 --> 00:47:25.090
which was the whole rotation scale thing.

00:47:25.100 --> 00:47:28.320
Then we apply the fill state,
the stroke state, set the alpha,

00:47:28.420 --> 00:47:31.600
select the font by name with its size.

00:47:33.150 --> 00:47:34.400
And the encoding.

00:47:34.400 --> 00:47:36.930
In this case, it's macro and encoding.

00:47:36.930 --> 00:47:40.700
It's a parameter because it
could be not macro and encoding.

00:47:40.700 --> 00:47:42.580
And then we set the text mode.

00:47:42.590 --> 00:47:47.510
In that example you saw that, right,
there was stroking and filling and there,

00:47:47.510 --> 00:47:49.030
I think there are four.

00:47:49.030 --> 00:47:52.390
There is filling, stroking,
filling and stroking.

00:47:52.420 --> 00:47:54.030
And clipping, I think.

00:47:54.030 --> 00:47:56.060
Actually, no, there are six.

00:47:56.060 --> 00:48:00.200
But you can look at that in the
documentation or in the header files,

00:48:00.200 --> 00:48:01.560
actually.

00:48:02.200 --> 00:48:06.520
So once we're done with that,
then we can say show text at point,

00:48:06.520 --> 00:48:07.200
right?

00:48:07.200 --> 00:48:11.390
Or show text or some other,
a whole bunch of text type operators

00:48:11.390 --> 00:48:15.340
that take an ASCII string and send
it through some particular encoding

00:48:15.340 --> 00:48:17.220
that's indicated by the font.

00:48:17.290 --> 00:48:19.470
The select font is really
a convenience function.

00:48:19.530 --> 00:48:23.550
As you'll see in the next example,
select font basically calls the font

00:48:23.550 --> 00:48:27.560
API to find the font by a particular
name and then apply an encoding onto

00:48:27.570 --> 00:48:32.200
a font and then set the font into the
context and then set the font's scale.

00:48:32.200 --> 00:48:35.400
So in the second example,
we're going to deal with glyphs.

00:48:35.460 --> 00:48:39.390
Glyphs are basically
actual indices of text.

00:48:40.160 --> 00:48:42.800
Outlines inside of a particular font.

00:48:42.800 --> 00:48:44.020
They're not Unicode.

00:48:44.020 --> 00:48:45.730
They're not...

00:48:45.830 --> 00:48:47.860
They're not anything that's portable.

00:48:47.860 --> 00:48:50.060
It's really particular
to a particular font.

00:48:50.060 --> 00:48:54.520
Now, typically,
a lot of layout engines will decide

00:48:54.520 --> 00:48:58.240
to take arbitrary Unicode text
or Kanji text or something like

00:48:58.240 --> 00:49:01.670
that and transform them into glyphs
associated with a particular font.

00:49:01.700 --> 00:49:06.600
And at the lowest level of API,
you really are going to be just

00:49:06.600 --> 00:49:09.620
drawing an array of glyphs that
are matched with a particular font.

00:49:09.900 --> 00:49:12.990
So any particular text run,
after it's been figured out that you

00:49:12.990 --> 00:49:16.150
have to do this and swivel it around
and put kerning and stuff like that,

00:49:16.180 --> 00:49:19.480
you'll end up with just a bunch of
arrays of glyphs and their positions and

00:49:19.480 --> 00:49:21.480
the font for which they're coming from.

00:49:21.500 --> 00:49:25.000
So this example shows how
to draw with just glyph IDs.

00:49:25.020 --> 00:49:28.150
You can use at sui to do
all of this layout stuff.

00:49:28.270 --> 00:49:28.900
That's what it's for.

00:49:28.900 --> 00:49:33.020
And you'll be able to take Unicode text
and convert it to glyph IDs and fonts,

00:49:33.050 --> 00:49:35.140
and then you'll be able
to use those with CG.

00:49:35.140 --> 00:49:38.440
So like all the examples,
they come with a fill state,

00:49:38.560 --> 00:49:39.510
stroke state.

00:49:39.910 --> 00:49:41.520
Text mode, to pretty usual.

00:49:41.520 --> 00:49:43.860
Now we're going to get a font ID case,
right?

00:49:43.860 --> 00:49:46.970
So if you get a font ref, sorry,
not font ID, font ref.

00:49:47.000 --> 00:49:49.960
You get a font ref, and you have a size,
and you have the glyph array.

00:49:52.610 --> 00:49:56.890
Like all the other examples before,
you apply a transform,

00:49:56.960 --> 00:50:00.900
apply the fill state, stroke state,
set the font, set the color.

00:50:00.950 --> 00:50:03.170
Here it was explicit.

00:50:03.180 --> 00:50:05.490
Instead of the select
font mechanism by name,

00:50:05.540 --> 00:50:07.580
you actually got the font
and you got the size.

00:50:07.580 --> 00:50:10.000
You can say set the font, set the size.

00:50:10.150 --> 00:50:12.140
Set the text rendering mode
and show glyphs at point.

00:50:12.150 --> 00:50:15.600
Same like show text at point,
except it takes glyphs.

00:50:16.120 --> 00:50:18.340
So hopefully everybody's
happy with there.

00:50:18.340 --> 00:50:19.580
I haven't lost anything.

00:50:19.600 --> 00:50:21.030
Anybody?

00:50:21.090 --> 00:50:22.880
So now we're going to go
to the second example.

00:50:22.880 --> 00:50:24.340
So now we're talking about images.

00:50:24.340 --> 00:50:25.340
We have an alpha logo.

00:50:25.340 --> 00:50:29.600
You know, of course, all the cases,
it's all the same object, right?

00:50:29.610 --> 00:50:31.740
So it's like very--

00:50:34.400 --> 00:50:35.950
And we can fade things out.

00:50:36.060 --> 00:50:41.400
So images are--

00:50:42.900 --> 00:50:53.000
[Transcript missing]

00:50:54.840 --> 00:50:59.490
When the image is called to draw,
you simply apply the transform.

00:50:59.490 --> 00:51:01.690
You set the alpha, which is how you're
able to get the fading,

00:51:01.700 --> 00:51:06.390
and you draw the image
with the image box.

00:51:06.410 --> 00:51:06.410
So let me sort of...

00:51:07.210 --> 00:51:12.860
Both images and PDF documents have
the same parameter called the rect.

00:51:12.860 --> 00:51:15.260
It basically specifies
a destination rect.

00:51:15.260 --> 00:51:18.920
For both PDF documents and images,
there seem to be objects

00:51:18.920 --> 00:51:21.360
that are in a unit square.

00:51:21.360 --> 00:51:24.450
And what you do with that
rectangle is you basically say,

00:51:24.450 --> 00:51:28.000
okay, I got this thing that's here,
which is like a unit square,

00:51:28.000 --> 00:51:31.220
and I want to take it and put
it at this particular point.

00:51:31.220 --> 00:51:35.100
So if you were to have an image
and it was 600 by 800 and you

00:51:35.100 --> 00:51:37.080
wanted to do with no transform,
you would have to do with a unit square.

00:51:37.100 --> 00:51:39.230
When you set the
transform to be identity,

00:51:39.260 --> 00:51:45.110
you'd be able to take the image and
draw the image at the correct location.

00:51:45.300 --> 00:51:51.500
[Transcript missing]

00:51:53.740 --> 00:51:57.280
But we won't go to that just
yet because I lost my step.

00:51:57.540 --> 00:52:00.810
Here's a PDF document.

00:52:00.830 --> 00:52:03.470
You know, here's a nice little chicken.

00:52:03.740 --> 00:52:05.080
There's no smoke and mirrors here.

00:52:05.080 --> 00:52:07.080
This is real line art being rendered.

00:52:07.080 --> 00:52:08.370
And our document.

00:52:08.380 --> 00:52:11.870
And go down.

00:52:16.000 --> 00:52:22.760
So there is just chicken document,
Mac OS datasheet, or Mac OS.

00:52:22.760 --> 00:52:26.880
So documents are like images,
they take the same bounding rack,

00:52:26.880 --> 00:52:30.040
to draw to the destination,
and they practically do the same thing.

00:52:30.040 --> 00:52:32.240
You apply a transform, you set the alpha,
and you draw the document.

00:52:32.240 --> 00:52:34.900
Very straightforward.

00:52:35.060 --> 00:52:36.060
Don't worry about this piece of code.

00:52:36.060 --> 00:52:42.340
That basically does our tracking
for our progress indicator.

00:52:42.340 --> 00:52:48.950
Which allows us to page
through our document.

00:52:51.500 --> 00:52:58.500
[Transcript missing]

00:52:58.750 --> 00:53:04.510
Another example that uses
PDF documents and images.

00:53:04.510 --> 00:53:10.030
And what it tries to
demonstrate is color matching.

00:53:10.080 --> 00:53:15.250
Now, here's an example of an image
that was rendered off screen.

00:53:15.260 --> 00:53:17.380
It's a PDF document.

00:53:17.820 --> 00:53:20.540
Basically, that was rendered off-screen.

00:53:20.540 --> 00:53:24.990
And the result of that
memory was switched around.

00:53:25.000 --> 00:53:28.120
We lied and we said,
it's really a BGR image.

00:53:28.150 --> 00:53:29.730
So we rendered RGB data.

00:53:29.740 --> 00:53:32.310
And then we said, oh yeah,
forget the RGB.

00:53:32.520 --> 00:53:36.400
We're just going to
call these triples BGR.

00:53:36.400 --> 00:53:42.800
And basically, this image is essentially
the result of that.

00:53:42.800 --> 00:53:47.500
It's just an image that got
rendered as if it was a BGR data.

00:53:47.500 --> 00:53:51.070
And this is why all the reds are blues.

00:53:51.250 --> 00:53:55.870
This particular case is a
slightly different example.

00:53:56.170 --> 00:53:59.100
This is basically a PDF document.

00:53:59.130 --> 00:54:00.640
Of course, it does that rotations.

00:54:00.680 --> 00:54:03.720
The media box is kind of different.

00:54:03.740 --> 00:54:05.820
That lays down CMYK colors.

00:54:05.820 --> 00:54:09.310
And on the screen,
you see cyan as electric cyan.

00:54:09.330 --> 00:54:12.860
Now,
what we want to do is we want to say, OK,

00:54:12.890 --> 00:54:15.120
we would like to draw this PDF document.

00:54:15.170 --> 00:54:18.430
We really want to proof
it on a CMYK printer.

00:54:18.490 --> 00:54:21.340
So we have a CMYK profile,
which we got from ColorSync.

00:54:21.390 --> 00:54:24.030
We load it up, and we created a color
space object from it.

00:54:24.180 --> 00:54:27.400
And then we said, OK,
I want you to draw this

00:54:27.400 --> 00:54:32.940
document inside this off-screen
context with this profile,

00:54:32.980 --> 00:54:35.260
which is this ColorSync CMYK profile.

00:54:35.330 --> 00:54:38.720
And that's why the cyan looks a little
bit like what it should look when you

00:54:38.720 --> 00:54:43.160
print this electric cyan on a printer.

00:54:44.030 --> 00:54:46.690
Now that you've finished the two
simple cases of draw document,

00:54:46.700 --> 00:54:52.920
draw image, we go into slightly more
complicated example.

00:54:53.060 --> 00:55:00.670
We get the document, the media box,
and we get the images color space,

00:55:00.680 --> 00:55:04.760
which is the color space to use,
and we get the context as color space,

00:55:04.760 --> 00:55:11.550
which is the color space to use for
drawing onto your off-screen image.

00:55:12.500 --> 00:55:15.090
So basically the first time through,
if there's no context,

00:55:15.090 --> 00:55:16.050
then let's make one.

00:55:16.060 --> 00:55:19.960
So we go and compute the width, height,
blah, blah, blah, blah, blah, blah, blah.

00:55:20.040 --> 00:55:21.950
And here we say,
I've got a piece of memory and

00:55:21.950 --> 00:55:23.450
I want to create a data provider.

00:55:23.450 --> 00:55:25.770
As Haroon indicated,
we have these data managers and

00:55:25.770 --> 00:55:29.440
they allow you to create objects
that can consume and produce memory.

00:55:29.560 --> 00:55:32.120
This particular case,
we want to create a consumer.

00:55:32.120 --> 00:55:34.710
So the data provider is
a direct access sort of,

00:55:34.710 --> 00:55:38.070
here's a sheet of memory, it's this size,
and we have a little

00:55:38.070 --> 00:55:41.570
release function that says,
okay, when you're done with it and

00:55:41.570 --> 00:55:44.600
everything's all released,
go call this method or this

00:55:44.730 --> 00:55:47.530
function to free the memory up,
which is as soon as you

00:55:47.530 --> 00:55:50.170
get the data pointer,
we just call free.

00:55:51.550 --> 00:55:55.800
So once we create this data provider,
then we say, okay,

00:55:55.800 --> 00:56:02.690
now that we have our data provider,
I want to create this image definition.

00:56:06.400 --> 00:56:10.000
We have to specify the width and heights,
the bits per pixel.

00:56:10.000 --> 00:56:13.060
In this particular case,
we're just using RGB 8-bit.

00:56:13.090 --> 00:56:14.770
So bits per sample is going to be 8.

00:56:14.800 --> 00:56:16.510
Bits per pixel is going to be 32.

00:56:16.730 --> 00:56:19.600
Robites is going to be
width of the image times 4.

00:56:19.600 --> 00:56:22.310
And we're saying that the
alpha is pre-multiplied first.

00:56:22.420 --> 00:56:24.520
We're using an ARGB format.

00:56:24.520 --> 00:56:28.820
And the color space,
no rendering attempt for the image.

00:56:28.980 --> 00:56:31.970
So that's how you would create
an image from a bunch of memory,

00:56:31.970 --> 00:56:33.820
which you can see this in an example.

00:56:33.820 --> 00:56:36.190
When you look at the header files,
it would be a little bit more obvious.

00:56:36.230 --> 00:56:40.180
Two of these parameters here are a
little bit-- don't worry about them.

00:56:40.180 --> 00:56:42.150
They basically are decode parameters.

00:56:42.160 --> 00:56:47.790
We do allow the ability to decode
images from one bit depth through

00:56:47.790 --> 00:56:52.790
some transformation that's
linear and produce other bits.

00:56:52.860 --> 00:56:58.960
So I can take a 2-bit image and map my
2 bits to 8-bit and expand the scale.

00:56:58.960 --> 00:57:02.870
Or I can move the 2 bits and say,
I want you to only populate

00:57:02.880 --> 00:57:05.140
the range from 128 to 255.

00:57:05.200 --> 00:57:06.040
And that's what those decodes are.

00:57:06.040 --> 00:57:07.220
Those decode things do.

00:57:07.220 --> 00:57:10.890
When you see them in the documentation,
you'll say, OK, yeah,

00:57:10.890 --> 00:57:13.120
that's what that was for.

00:57:13.120 --> 00:57:14.480
So now we have our image.

00:57:14.480 --> 00:57:19.090
Then the second thing that we need to do
is we have to create our bitmap context,

00:57:19.160 --> 00:57:21.940
which is the context we want to draw to.

00:57:21.940 --> 00:57:23.660
It's an off-screen context.

00:57:23.660 --> 00:57:26.200
We're going to use the same memory
that we handed to the image.

00:57:26.200 --> 00:57:29.310
And we're going to say, OK,
create a bitmap context with the correct

00:57:29.310 --> 00:57:31.300
width and height and the bits per sample.

00:57:31.300 --> 00:57:33.980
And we're going to say,
here's the color space to use.

00:57:33.980 --> 00:57:35.860
We use this particular case.

00:57:35.860 --> 00:57:38.160
For the CMYK case.

00:57:38.160 --> 00:57:40.180
So we said, OK, here's a CMYK.

00:57:40.180 --> 00:57:45.460
What we want to do is we're
going to use the CMYK to draw.

00:57:45.460 --> 00:57:48.840
And because you've handed the
data provider off to the image,

00:57:48.840 --> 00:57:52.540
you can just release it because
the image has reference to it.

00:57:52.560 --> 00:57:55.040
So once we've done all of
that the first time through,

00:57:55.040 --> 00:57:56.130
you didn't have a context.

00:57:56.140 --> 00:57:56.980
You didn't have any memory.

00:57:56.980 --> 00:57:58.040
You didn't have an image.

00:57:58.040 --> 00:58:02.360
You just run through that little tiny
thing and it creates a life-size image

00:58:02.360 --> 00:58:04.820
and context to draw into that image.

00:58:04.820 --> 00:58:07.320
So now every time we
get-- new stuff coming in,

00:58:07.400 --> 00:58:13.360
a different page or whatever,
we basically say, have our offscreen,

00:58:13.410 --> 00:58:16.580
set our transformations so that
we're basically trying to say

00:58:16.880 --> 00:58:20.970
whatever the media size of the
document that we're trying to render,

00:58:20.980 --> 00:58:23.160
we want it to fit smack dab
in the middle of the image.

00:58:23.300 --> 00:58:26.200
Because I only provided
10 pixels by 10 pixels,

00:58:26.250 --> 00:58:28.340
and I wanted to draw on the 10 pixels.

00:58:28.340 --> 00:58:31.920
So we translate the context
so it's correctly positioned.

00:58:31.980 --> 00:58:36.210
We draw, basically, we erase the context,
or you clear it.

00:58:36.340 --> 00:58:38.040
In this particular case,
we're recording alpha.

00:58:38.040 --> 00:58:40.380
So we want to issue a clear,
which will clear out both the

00:58:40.500 --> 00:58:41.790
alpha and the data planes.

00:58:41.800 --> 00:58:44.780
And then we just draw a document
like the example before.

00:58:45.010 --> 00:58:47.800
But remember,
we're going to an offscreen context.

00:58:47.840 --> 00:58:51.800
So once a document is drawn, then we say,
OK, great.

00:58:51.940 --> 00:58:54.400
We have our little offscreen image.

00:58:54.460 --> 00:58:56.500
They're both referencing both
the image and the context.

00:58:56.510 --> 00:58:58.310
We're referencing the
same piece of memory.

00:58:58.420 --> 00:58:59.660
Basically take that.

00:58:59.660 --> 00:59:00.660
Then we say, OK, great.

00:59:00.660 --> 00:59:01.600
We're ready to draw.

00:59:01.610 --> 00:59:02.850
We apply our transform.

00:59:02.870 --> 00:59:04.060
We set our alpha.

00:59:04.060 --> 00:59:05.320
And we draw our image.

00:59:05.320 --> 00:59:09.310
And that's how, basically,

00:59:10.300 --> 00:59:16.700
[Transcript missing]

00:59:17.000 --> 00:59:35.800
[Transcript missing]

00:59:36.780 --> 00:59:43.410
random PDF document with an alpha
image being drawn with samples.

00:59:49.360 --> 00:59:52.560
Okay, so I just wanted to finish off by
talking about some of the documentation.

00:59:52.560 --> 00:59:56.120
There's a Quartz primer that's
available for you on our website.

00:59:56.120 --> 01:00:00.750
TechPubs is currently working
on drawing with Quartz,

01:00:00.860 --> 01:00:02.920
part of the Inside Mac OS X series.

01:00:02.920 --> 01:00:06.300
And at the moment, if all fails,
you can always go back to the headers,

01:00:06.400 --> 01:00:10.580
and those are available in the
Core Graphics framework as part of

01:00:10.580 --> 01:00:12.670
the Application Services framework.

01:00:12.700 --> 01:00:15.400
That's what you want to go off to.

01:00:15.960 --> 01:00:20.810
And I want to invite Travis back
up to discuss the roadmap.

01:00:23.200 --> 01:00:29.190
I want to quickly do the road map so
we have some time for some Q and A.

01:00:29.210 --> 01:00:33.460
Obviously, we've already gone and done
the PDF courts of Mac OS X and

01:00:33.460 --> 01:00:37.060
the drawing--actually,
no, they've revised it.

01:00:37.060 --> 01:00:40.220
So, the next session that might
be of interest is drawing

01:00:40.300 --> 01:00:41.870
Unicode text with Atsui.

01:00:41.930 --> 01:00:45.700
I know that we mentioned
text handling in the session,

01:00:45.700 --> 01:00:49.780
but for the built-in text handling
inside courts is very simple.

01:00:49.780 --> 01:00:54.140
We mentioned a lot of it's at the glyph
level and based on Mac Roman encoding.

01:00:54.210 --> 01:00:57.090
If you're developing applications,
you're going to want to use more

01:00:57.090 --> 01:01:00.640
advanced text and so what we strongly
suggest you do is you use higher level

01:01:00.640 --> 01:01:02.930
frameworks such as Atsui and MLTE.

01:01:02.960 --> 01:01:06.780
That will be covered in the
drawing Unicode text with Atsui.

01:01:06.780 --> 01:01:08.730
We also have an interesting
technology called image capture which

01:01:08.840 --> 01:01:11.160
you've already seen demonstrated.

01:01:11.160 --> 01:01:14.900
Allows your applications to
work with digital cameras.

01:01:15.370 --> 01:01:18.410
Then we go over to a
very interesting session,

01:01:18.500 --> 01:01:22.750
118, which is Color Sync,
which is we'll go into depth and

01:01:22.750 --> 01:01:26.280
describe how color management works
in conjunction with Quartz to deliver

01:01:26.320 --> 01:01:30.060
fully color managed content on the
user screen and output devices.

01:01:30.080 --> 01:01:33.690
Unlike previously with Quick Draw,
where you really did not have a

01:01:33.690 --> 01:01:37.660
color managed drawing environment,
Quartz is fully integrated with color

01:01:37.660 --> 01:01:39.760
managed as was demonstrated by Andrew.

01:01:40.700 --> 01:01:44.240
This is very important because we
feel that the fidelity on screen and

01:01:44.380 --> 01:01:47.980
on print is valuable to all users
of all classes of applications.

01:01:48.000 --> 01:01:52.820
So you should definitely check
out the Color Sync presentation.

01:01:52.820 --> 01:01:55.480
Next, we have another text on Mac OS X.

01:01:55.480 --> 01:01:59.050
This will again cover Quartz
and how it relates to the

01:01:59.050 --> 01:02:01.360
other text APIs in the system.

01:02:01.360 --> 01:02:03.480
Then we have a very
interesting demonstration.

01:02:03.480 --> 01:02:07.460
If you are doing high
performance 2D work where you,

01:02:07.460 --> 01:02:11.300
for example, using large bitmaps,
you can tell the performance

01:02:11.330 --> 01:02:12.290
of Quartz is quite good.

01:02:12.300 --> 01:02:14.600
If you need even greater performance,
you should check out the

01:02:14.650 --> 01:02:15.960
OpenGL and high performance 2D.

01:02:16.060 --> 01:02:18.060
And we also have a printing session.

01:02:18.080 --> 01:02:20.060
The printing session
will talk about Carbon,

01:02:20.060 --> 01:02:25.150
BSD, and Cocoa printing.

01:02:25.870 --> 01:02:28.030
And then on the final day,
we have a very important

01:02:28.090 --> 01:02:31.500
session for Carbon developers,
the graphics and imaging tips and tricks.

01:02:31.500 --> 01:02:36.330
This session will provide a lot of
information to enable Carbon developers

01:02:36.470 --> 01:02:41.380
to look seriously at using Quartz 2D for
their graphics as opposed to Quick Draw.

01:02:41.420 --> 01:02:43.970
And then finally,
we have the feedback forum.
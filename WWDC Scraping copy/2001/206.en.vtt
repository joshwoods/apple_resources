WEBVTT

00:00:01.630 --> 00:00:05.320
Good afternoon and welcome to
the FireWire in Depth session.

00:00:05.360 --> 00:00:08.170
Yesterday in the FireWire
overview session,

00:00:08.170 --> 00:00:11.590
we reviewed the Macintosh
FireWire hardware,

00:00:11.590 --> 00:00:16.410
as well as demonstrated the
FireWire software stack on Mac OS X.

00:00:17.110 --> 00:00:21.180
Today we'd like to go into more
details regarding FireWire driver

00:00:21.180 --> 00:00:25.770
development for Mac OS X so we
can see a lot of exciting FireWire

00:00:25.770 --> 00:00:28.710
devices for the Macintosh platform.

00:00:29.250 --> 00:00:33.000
With that said, I'd like to turn it
over to Eric Anderson,

00:00:33.090 --> 00:00:36.100
Engineering Manager for the
FireWire Software Development team.

00:00:36.100 --> 00:00:39.780
Thank you, Greg.

00:00:55.890 --> 00:01:00.960
You know this is a USB device,
so... I just meant I'm

00:01:00.960 --> 00:01:02.640
not familiar with it.

00:01:03.020 --> 00:01:07.290
Okay, yesterday we talked at length
about just all things FireWire,

00:01:07.290 --> 00:01:11.100
that we have it on all of our products,
all of the great devices

00:01:11.100 --> 00:01:14.120
that you guys have made,
1394B, where we're going,

00:01:14.120 --> 00:01:17.710
and we told you that Mac OS X has
lots of good FireWire services.

00:01:17.720 --> 00:01:20.460
So today,
we're going to talk in-depth about all

00:01:20.460 --> 00:01:22.860
of those FireWire services on Mac OS X.

00:01:22.860 --> 00:01:26.570
In particular,
the message I want to give all of

00:01:26.570 --> 00:01:31.940
you is that we are providing the
tools you need to develop drivers,

00:01:31.940 --> 00:01:35.330
applications, plug-ins for FireWire,
for Mac OS X,

00:01:35.470 --> 00:01:39.240
and we'll spend a lot of time
going through how that works.

00:01:39.240 --> 00:01:41.950
In particular,
we'll have some in-depth discussion

00:01:42.060 --> 00:01:45.500
of how driver loading works and
how driver matching is done.

00:01:45.500 --> 00:01:47.690
Of course, it's very important to
have your driver in-depth.

00:01:47.720 --> 00:01:49.290
You want to have your
driver match your device.

00:01:49.300 --> 00:01:50.280
Otherwise, what's the point?

00:01:50.280 --> 00:01:53.040
We'll tell you where to find the SDK.

00:01:53.040 --> 00:01:54.480
It's right there on the slide.

00:01:54.480 --> 00:01:56.320
It'll be on the slide at the end also.

00:01:56.320 --> 00:01:57.820
You don't have to scramble
to write that down.

00:01:59.300 --> 00:02:00.950
And we'll talk about source.

00:02:00.960 --> 00:02:02.500
There's the URL for Darwin.

00:02:02.500 --> 00:02:05.430
Much of the FireWire
family is in open source.

00:02:05.480 --> 00:02:09.040
We've already started to receive
feedback from some of our developers,

00:02:09.120 --> 00:02:10.520
bug fixes, comments.

00:02:10.530 --> 00:02:11.430
That's terrific.

00:02:11.440 --> 00:02:13.380
That's exactly how it's supposed to work.

00:02:13.390 --> 00:02:14.430
Please keep that up.

00:02:18.890 --> 00:02:24.690
Okay, the FireWire API in Mac OS X is
very similar to what's in Mac OS 9,

00:02:24.780 --> 00:02:26.760
because you need to do the same things.

00:02:26.760 --> 00:02:31.150
It's been changed mechanically
to fit within I/O Kit C++,

00:02:31.160 --> 00:02:33.800
but all the concepts
are basically the same.

00:02:33.800 --> 00:02:36.490
We have asynchronous,
isochronous services for

00:02:36.520 --> 00:02:38.380
sending and receiving packets.

00:02:38.380 --> 00:02:41.270
It's based on forming a
command and then sending it.

00:02:41.270 --> 00:02:43.200
It's just done in an I/O Kit way.

00:02:44.420 --> 00:02:48.300
The isochronous transport, in particular,
uses the same DCL mechanism

00:02:48.310 --> 00:02:49.890
that we used in Mac OS 9.

00:02:49.900 --> 00:02:53.460
If you have existing DCLs,
it should be very easy to adapt

00:02:53.460 --> 00:02:55.340
them to work with Mac OS X.

00:02:57.450 --> 00:02:59.700
We have the same SBP-2 service layer.

00:02:59.700 --> 00:03:01.930
In fact, it was ported over directly.

00:03:01.990 --> 00:03:04.900
This makes it easier to write
drivers for devices like disks,

00:03:04.900 --> 00:03:09.430
cameras, printers,
scanners that use the SBP-2 protocol.

00:03:09.620 --> 00:03:13.240
has all the same features,
unlimited logical units, unlimited orbs,

00:03:13.240 --> 00:03:15.360
and it's not tied to storage.

00:03:15.360 --> 00:03:18.360
It's an all-purpose SBP-2 interface.

00:03:18.590 --> 00:03:20.650
Finally,
we have something new in Mac OS X because

00:03:20.650 --> 00:03:23.900
it didn't really apply in Mac OS 9,
and that's a user client,

00:03:23.920 --> 00:03:25.720
more properly known
as a device interface.

00:03:25.720 --> 00:03:29.440
This allows you to talk to your
FireWire devices from application space,

00:03:29.440 --> 00:03:32.720
which is much easier than writing
code to go inside the kernel.

00:03:32.720 --> 00:03:35.330
I'll talk about that later.

00:03:37.120 --> 00:03:39.870
Specifically,
we have user clients for both SBP-2

00:03:39.870 --> 00:03:43.540
and for just plain generic FireWire,
and you can use those interchangeably.

00:03:43.540 --> 00:03:45.700
You can use them both at once.

00:03:45.700 --> 00:03:49.040
We have an SDK available
with extensive sample code.

00:03:49.150 --> 00:03:51.420
It shows how to write in user space.

00:03:51.420 --> 00:03:53.780
There's an SBP-2 Cocoa application.

00:03:53.780 --> 00:03:55.570
There's command line applications.

00:03:55.570 --> 00:03:57.720
A bunch of good stuff in there.

00:03:58.180 --> 00:04:01.420
And significantly,
not only is this SDK now available,

00:04:01.420 --> 00:04:04.870
but it's available for free
public download to anybody.

00:04:04.870 --> 00:04:09.170
You don't need to have access
through Apple's developer relations

00:04:09.180 --> 00:04:12.000
program like was necessary
with Mac OS 9 for many years.

00:04:12.000 --> 00:04:15.520
So we're doing everything we can to get
this out and make it available to you.

00:04:15.520 --> 00:04:22.000
Now let's talk in more detail about
what's in there and how it works.

00:04:25.740 --> 00:04:30.370
IO FireWire family is the core
of FireWire services in Mac OS X.

00:04:30.370 --> 00:04:36.660
Its job is basically the same as what
FireWire support did in Mac OS 9.

00:04:36.660 --> 00:04:41.220
It's a central point of communication
for all things FireWire.

00:04:41.220 --> 00:04:45.850
If you have multiple devices,
multiple drivers, multiple applications,

00:04:45.880 --> 00:04:49.240
they all want to communicate
on a single FireWire bus.

00:04:49.240 --> 00:04:52.900
The FireWire family's job is to let
them all do that at the same time

00:04:52.900 --> 00:04:54.960
without interfering with each other.

00:04:54.960 --> 00:04:56.690
So it's a multiplexing point.

00:04:58.370 --> 00:05:01.760
In Mac OS X,
the FireWire family is implemented as a

00:05:01.790 --> 00:05:05.370
dynamically loadable kernel extension,
also known as a KEXT.

00:05:05.370 --> 00:05:08.830
It will be loaded whenever
there's a FireWire bus that

00:05:08.840 --> 00:05:11.030
needs this software service.

00:05:11.330 --> 00:05:13.040
There's three main parts to the core.

00:05:13.040 --> 00:05:16.480
Iofirewirefamily KEXT is
the FireWire services,

00:05:16.480 --> 00:05:20.900
and there are two hardware drivers for
the two kinds of FireWire interface

00:05:20.910 --> 00:05:22.840
that we have shipped in our products.

00:05:22.840 --> 00:05:27.430
AppleLynx KEXT is a driver for
the older PCI-Lynx interface that

00:05:27.460 --> 00:05:30.160
was used in the blue and white G3.

00:05:30.160 --> 00:05:35.580
AppleFWOHCI KEXT is the driver for
the industry standard 1394 open

00:05:35.580 --> 00:05:40.490
host controller interface that we
ship in all of our products today.

00:05:41.300 --> 00:05:44.240
In Mac OS 9,
these two drivers were bundled

00:05:44.240 --> 00:05:47.250
together into the file FireWireEnabler.

00:05:47.260 --> 00:05:50.470
In Mac OS X, to fit within the way that
I/O Kit loads drivers,

00:05:50.470 --> 00:05:54.440
they're present as independent
KEXTs within the extensions folder.

00:05:56.810 --> 00:06:00.440
We have some additional FireWire
services that come along as part

00:06:00.450 --> 00:06:02.820
of the standard installation.

00:06:02.860 --> 00:06:06.580
IO FireWire DV is the standard
device driver for DV cameras,

00:06:06.580 --> 00:06:09.120
very similar to what we had in Mac OS 9.

00:06:09.200 --> 00:06:10.150
It's also a KEXT.

00:06:10.200 --> 00:06:11.380
I'll talk more about this later.

00:06:11.380 --> 00:06:15.380
It may not really belong in the kernel,
but that's where it is now.

00:06:15.520 --> 00:06:22.080
I/O FireWire SBP-2 KEXT is the service
layer that provides the SBP-2 API.

00:06:22.120 --> 00:06:26.210
In Mac OS 9, this was simply built
in to FireWire support.

00:06:26.320 --> 00:06:29.500
In Mac OS X, to be consistent with the
way that I/O Kit works,

00:06:29.550 --> 00:06:36.850
it's provided as a separate KEXT,
but it will load whenever an SBP-2

00:06:36.850 --> 00:06:38.150
device is around and provide you with the
API to allow you to talk to that device.

00:06:38.490 --> 00:06:40.620
Finally, as I mentioned,
we have user clients,

00:06:40.630 --> 00:06:43.980
or device interfaces,
for both ordinary FireWire

00:06:43.980 --> 00:06:48.560
and for SBP-2 in particular,
to make all of these services available

00:06:48.560 --> 00:06:52.540
out in user land to minimize your
need to write code in the kernel.

00:06:56.520 --> 00:07:02.990
This picture shows where FireWire fits
in the grander scheme of Mac OS X.

00:07:05.380 --> 00:07:08.960
Down at the bottom,
you can see that drivers for FireWire

00:07:08.960 --> 00:07:12.510
exist at the very bottom of the
kernel within the I/O Kit framework.

00:07:12.620 --> 00:07:15.890
That's where I/O FireWire
family is located and also

00:07:16.170 --> 00:07:19.480
the OHCI or LINX drivers,
depending on what hardware

00:07:19.480 --> 00:07:20.970
you have in your system.

00:07:21.390 --> 00:07:26.060
The figure shows that above
them is the BSD layer,

00:07:26.060 --> 00:07:27.900
where you find things
like the file system.

00:07:27.900 --> 00:07:31.650
Some kinds of FireWire drivers
will go up to that layer.

00:07:31.650 --> 00:07:34.390
For example,
a mass storage driver goes to the

00:07:34.450 --> 00:07:38.470
file system because it provides a
block storage device on which the file

00:07:38.470 --> 00:07:43.160
system actually implements directories
and structures to store your files.

00:07:43.720 --> 00:07:46.910
But other kinds of driver
may bypass the BSD system,

00:07:46.910 --> 00:07:49.760
as shown by this path
over here to the right.

00:07:49.770 --> 00:07:53.210
For example,
the DV driver goes straight to QuickTime,

00:07:53.210 --> 00:07:56.870
which is an application-level service,
so BSD really isn't

00:07:56.870 --> 00:07:58.780
involved in the DV driver.

00:08:00.200 --> 00:08:04.110
Also up on top,
I've shown Carbon and Cocoa because

00:08:04.110 --> 00:08:06.400
these are places that,
using the user clients,

00:08:06.400 --> 00:08:08.290
you can access FireWire services.

00:08:08.300 --> 00:08:11.380
So you don't need to go down in
the very bottom of the kernel.

00:08:11.440 --> 00:08:13.680
You can write up in application space.

00:08:20.720 --> 00:08:25.050
Now I'm going to show in much more
detail what elements are in the stack

00:08:25.090 --> 00:08:30.340
of FireWire services and how they get
built up when a device is plugged in,

00:08:30.380 --> 00:08:33.620
so that you'll find out where
your driver exists within all

00:08:33.630 --> 00:08:36.210
of these layers of software.

00:08:36.710 --> 00:08:39.040
Everything begins with an IOPCI device.

00:08:39.040 --> 00:08:43.550
The PCI family will have discovered
a FireWire interface of some kind,

00:08:43.560 --> 00:08:47.100
probably on a PCI card, built-in,
or on a CardBus card,

00:08:47.100 --> 00:08:51.320
and will create an IOPCI device
object corresponding to it.

00:09:07.400 --> 00:09:07.720
In I/O Kit, the information in that
object matches to Apple,

00:09:07.720 --> 00:09:07.980
in this case we'll use
the example of OpenHCI.

00:09:07.980 --> 00:09:08.610
It matches to Apple FireWire OHCI,
which is a subclass of IO FireWire Link.

00:09:09.690 --> 00:09:12.540
IO FireWire Link has all of the
functions that would be needed

00:09:12.540 --> 00:09:14.200
for any FireWire interface.

00:09:14.200 --> 00:09:20.260
Apple FireWire OHCI has specific
hardware control for the OpenHCI.

00:09:21.020 --> 00:09:21.980
It's DMA engine,
so it's not a DMA engine.

00:09:21.980 --> 00:09:24.160
The PCI links, for example,
are quite different from PCI links.

00:09:24.160 --> 00:09:28.150
Those two are loaded as one, as a unit,
that will provide the device

00:09:28.150 --> 00:09:32.660
driver layer service for actually
controlling the FireWire hardware.

00:09:34.410 --> 00:09:38.600
In response to having those loaded,
the next layer up is instantiated.

00:09:38.600 --> 00:09:44.670
IO FireWire Controller,
which is a subclass of IO FireWire Bus,

00:09:44.670 --> 00:09:46.840
this is where the family exists.

00:09:46.840 --> 00:09:49.630
All of the family services
are provided in this layer,

00:09:49.630 --> 00:09:53.810
and it's invoked when there's actual
hardware for it to provide services for.

00:09:57.150 --> 00:10:00.080
Pushing IO FireWire Controller now
down to the bottom of the picture will

00:10:00.080 --> 00:10:01.490
keep building up from where we were.

00:10:04.880 --> 00:10:10.430
The family will scan the bus looking for
devices that we might load drivers for.

00:10:10.780 --> 00:10:16.260
For every device on the bus that
at least has a configuration ROM,

00:10:16.640 --> 00:10:20.400
will be presenting a session
on the FireWire device.

00:10:20.400 --> 00:10:24.700
This session will be focused
on the FireWire device itself.

00:10:24.700 --> 00:10:27.500
We will create an I/O FireWire device.

00:10:27.500 --> 00:10:31.950
This corresponds to a device with
a node ID that's out there on the

00:10:31.950 --> 00:10:36.990
bus that's actually responding to
our requests to read the config ROM.

00:10:36.990 --> 00:10:41.110
I/O FireWire device itself is
a subclass of I/O FireWire NUB,

00:10:41.110 --> 00:10:41.110
which is just a more general object
for talking to FireWire devices.

00:10:44.700 --> 00:10:47.270
The IO FireWire device
layer will scan the config

00:10:47.270 --> 00:10:49.760
ROM looking for unit directories.

00:10:49.760 --> 00:10:54.130
In a FireWire device,
a unit directory publishes information

00:10:54.130 --> 00:10:56.360
about what that device does.

00:10:56.360 --> 00:11:01.660
A disk drive has an SPP2 unit directory
that says it speaks the SPP2 protocol.

00:11:01.660 --> 00:11:05.990
Within there are further details
about the fact that it's a disk drive,

00:11:05.990 --> 00:11:08.340
or a DVD-RAM,
or some other kind of device.

00:11:08.340 --> 00:11:13.330
A DV camcorder has a unit directory
that says it speaks the AVC command set.

00:11:13.850 --> 00:11:16.240
And then there's further
information within about exactly

00:11:16.240 --> 00:11:17.360
what kind of device it is.

00:11:20.850 --> 00:11:24.830
The IOFireWire device layer's
job is to scan the config ROM,

00:11:24.920 --> 00:11:28.410
finding hopefully at least one,
maybe more, unit directories,

00:11:28.410 --> 00:11:30.840
and it will create this
IOFireWire unit object,

00:11:30.840 --> 00:11:33.670
which itself is also a
subclass of IOFireWireNub.

00:11:36.190 --> 00:11:40.130
I/O FireWire Unit actually
gives us the first hint about

00:11:40.130 --> 00:11:42.260
what this device really does.

00:11:42.280 --> 00:11:46.650
So I/O FireWire Unit further scans
the config ROM and puts information

00:11:46.850 --> 00:11:51.710
in the I/O registry that's used
to match a driver to this device.

00:11:51.980 --> 00:11:54.240
pushing IO FireWire
Unit down to the bottom.

00:11:54.240 --> 00:11:57.910
Let me show the example of how
things load for a disk drive.

00:11:59.810 --> 00:12:04.090
From the unit directory,
we learn that the device is SBP-2.

00:12:04.100 --> 00:12:08.130
It has a spec ID and software version
that indicate the SBP-2 protocol.

00:12:08.140 --> 00:12:13.400
Consequently, the IO FireWire SBP-2
target layer gets loaded.

00:12:13.400 --> 00:12:17.060
This is the general service
layer for an SBP-2 device.

00:12:17.100 --> 00:12:21.560
It will further scan the
configuration ROM to discover SBP-2

00:12:21.560 --> 00:12:24.230
logical units within that device.

00:12:25.000 --> 00:12:30.470
For each logical unit that it finds,
it will create IO FireWire SBP-2 LUN,

00:12:30.470 --> 00:12:32.640
LUN being short for Logical Unit.

00:12:34.730 --> 00:12:38.950
Finally, the LUN will match against a
particular driver for the actual

00:12:38.950 --> 00:12:40.590
device that you've plugged in.

00:12:40.590 --> 00:12:43.540
In the case of a hard drive,
Apple provides a

00:12:43.540 --> 00:12:44.700
standard built-in driver.

00:12:44.700 --> 00:12:48.820
If you use Mac OS 9 and
you remember the API call

00:12:48.820 --> 00:12:55.020
FWGetLocalFWReferenceIDFromFWReferenceID,
you'll love this.

00:12:57.090 --> 00:13:00.100
will talk about Apple FireWire
Mass Storage Drivers,

00:13:00.100 --> 00:13:04.290
which is a subclass of IO FireWire
Serial Bus Protocol Transport.

00:13:04.460 --> 00:13:08.360
Together, these are Apple's standard
driver for mass storage devices.

00:13:08.360 --> 00:13:12.530
It covers hard drives, magneto-optical,
CD-ROM, and various other

00:13:12.540 --> 00:13:14.760
standard kinds of devices.

00:13:16.160 --> 00:13:18.990
This puzzle piece architecture,
you probably recognize this from the

00:13:18.990 --> 00:13:20.700
USB and the storage presentations.

00:13:20.700 --> 00:13:24.690
The puzzle piece edge that's
sticking out the right-hand side of

00:13:24.810 --> 00:13:28.200
Apple FireWire mass storage drivers
indicates that this is a layer

00:13:28.200 --> 00:13:29.900
that you might want to subclass.

00:13:30.500 --> 00:13:33.860
If you have your own device that
has vendor-unique functionality that

00:13:33.860 --> 00:13:37.270
makes it better than somebody else's,
you don't have to write an entire

00:13:37.270 --> 00:13:38.840
new driver for your device.

00:13:38.860 --> 00:13:42.100
You can start with Apple FireWire
mass storage drivers,

00:13:42.100 --> 00:13:45.550
or perhaps just IO FireWire
serial bus protocol transport,

00:13:45.550 --> 00:13:49.830
and subclass the unique functionality
of your device at this level.

00:13:53.750 --> 00:13:55.960
Suppose your device isn't in the kernel.

00:13:56.060 --> 00:13:59.580
Suppose you want to communicate
to it from user space.

00:13:59.620 --> 00:14:02.820
If you went to the I/O Kit summary,
you've probably heard that we

00:14:02.820 --> 00:14:06.460
recommend avoiding writing drivers
in the kernel if you possibly can.

00:14:06.460 --> 00:14:10.360
It's much easier to debug things
in user space than in the kernel.

00:14:10.430 --> 00:14:13.190
So we provide a user client,
which is a piece of software that

00:14:13.190 --> 00:14:16.220
can bridge the user kernel gap.

00:14:16.910 --> 00:14:21.300
Going back down to IO FireWire
Device and IO FireWire Unit,

00:14:21.300 --> 00:14:23.340
if you want to talk to a
device from user space,

00:14:23.340 --> 00:14:28.220
then IO FireWire User Client
will be loaded within the kernel

00:14:28.220 --> 00:14:29.930
as the driver for a device.

00:14:29.930 --> 00:14:33.310
This is basically just a bunch
of glue that knows how to talk

00:14:33.370 --> 00:14:35.140
up into application space.

00:14:36.470 --> 00:14:39.980
Pushing User Client down to the bottom,
now we reach the user kernel boundary.

00:14:39.980 --> 00:14:43.650
Above here, we have IO FireWire Lib.

00:14:43.760 --> 00:14:45.460
This is another piece provided by Apple.

00:14:45.460 --> 00:14:48.030
It's the counterpart to
IO FireWire User Client.

00:14:49.280 --> 00:14:52.780
IO FireWire Lib can be used by
a CFPlugin that you provide.

00:14:52.780 --> 00:14:56.970
The CFPlugin is written in user space
and runs in an application context

00:14:56.980 --> 00:15:01.310
and can talk to IO FireWire Lib to
communicate with a FireWire device.

00:15:02.780 --> 00:15:04.480
Typically,
it would be loaded by an application.

00:15:04.480 --> 00:15:08.270
As an example,
if you have a FireWire scanner,

00:15:08.280 --> 00:15:10.140
your application might be
something like Photoshop.

00:15:10.140 --> 00:15:13.690
Your CFPlugin might be a
plugin for the particular kind

00:15:13.820 --> 00:15:15.800
of scanner that was found.

00:15:15.800 --> 00:15:18.890
So this gives you a flexible
architecture for dealing with

00:15:18.890 --> 00:15:22.170
multiple kinds of device,
perhaps multiple applications,

00:15:22.170 --> 00:15:25.150
without rewriting a lot of
code over and over again.

00:15:25.940 --> 00:15:29.570
It's not shown here on the slide,
but if you had some really unique

00:15:29.570 --> 00:15:33.630
FireWire device that was only ever
going to talk to a single application,

00:15:33.630 --> 00:15:37.220
like maybe some kind of FireWire
salad shooter or something,

00:15:37.220 --> 00:15:40.350
you could connect this up
directly to IO FireWire Lib.

00:15:40.420 --> 00:15:42.400
You don't have to use
the plugin architecture,

00:15:42.400 --> 00:15:45.940
but most people want to write something
that's flexible that can talk to multiple

00:15:45.940 --> 00:15:47.600
applications or multiple devices.

00:15:47.600 --> 00:15:49.550
Use the plugin architecture for that.

00:15:52.920 --> 00:15:55.580
And again, this is the area where
you could write software.

00:15:55.580 --> 00:15:57.980
You could write the application,
you could write the plugins,

00:15:57.980 --> 00:16:00.100
the rest below is provided by Apple.

00:16:03.410 --> 00:16:06.290
Now let's talk about more details
about the individual objects that

00:16:06.290 --> 00:16:07.560
you saw as we built up the stack.

00:16:07.600 --> 00:16:11.900
IO FireWire Controller is the
heart of the FireWire family.

00:16:11.900 --> 00:16:15.800
This is where all the logic exists
to manage a FireWire interface.

00:16:15.800 --> 00:16:19.620
As I mentioned before,
a single FireWire interface

00:16:19.620 --> 00:16:23.080
may support multiple devices,
multiple applications,

00:16:23.080 --> 00:16:27.240
multiple protocols, all going through the
same hardware interface.

00:16:27.460 --> 00:16:31.020
IO FireWire Controller provides
the services to actually talk

00:16:31.020 --> 00:16:34.350
to that hardware to multiplex
the different requests.

00:16:34.380 --> 00:16:37.080
It also provides the
bus management services.

00:16:38.590 --> 00:16:41.630
So some of the things that are common
that have to be shared by all drivers,

00:16:41.630 --> 00:16:43.220
address space management.

00:16:43.220 --> 00:16:48.740
Some kinds of FireWire drivers will
allocate FireWire address space.

00:16:48.740 --> 00:16:53.350
That's a range of memory in the Macintosh
that can be addressed over FireWire.

00:16:54.100 --> 00:16:57.350
Drivers for DV and SBP don't
need to do this by themselves,

00:16:57.350 --> 00:17:01.250
typically, but if you design your own
protocol or if you're doing a

00:17:01.250 --> 00:17:05.180
shared memory kind of application,
you might allocate some FireWire

00:17:05.180 --> 00:17:08.060
address space so that other
devices on the bus can read and

00:17:08.060 --> 00:17:09.780
write memory in the Macintosh.

00:17:09.780 --> 00:17:12.890
That address space is a shared resource,
so it's handed out by

00:17:12.890 --> 00:17:14.340
IO FireWire controller.

00:17:15.910 --> 00:17:19.250
Packet transmission and
reception all flows through here.

00:17:19.300 --> 00:17:22.730
When a packet comes into the Macintosh,
at this layer we can look at it,

00:17:22.960 --> 00:17:25.390
figure out who it's for,
hand it to one of the appropriate

00:17:25.390 --> 00:17:26.970
drivers that's loaded on the system.

00:17:26.980 --> 00:17:30.010
Likewise,
when software wants to transmit packets,

00:17:30.010 --> 00:17:33.130
this is the layer where they
get queued up and transmitted

00:17:33.130 --> 00:17:35.010
one by one on the FireWire bus.

00:17:36.460 --> 00:17:40.760
If you want to write a protocol driver,
IO FireWire Controller will be

00:17:40.810 --> 00:17:42.260
the provider for your driver.

00:17:42.260 --> 00:17:47.140
A protocol driver is software that
loads once for each FireWire bus,

00:17:47.140 --> 00:17:51.240
as opposed to an ordinary FireWire
driver which loads once for each

00:17:51.240 --> 00:17:53.590
instance of your device on the bus.

00:17:53.940 --> 00:17:58.250
A protocol driver might be used
if you're speaking a protocol

00:17:58.250 --> 00:18:02.700
like TCP/IP or perhaps MLan,
where you really just want

00:18:02.700 --> 00:18:06.350
one driver on the Mac,
not several drivers talking

00:18:06.350 --> 00:18:07.880
to each FireWire bus.

00:18:08.720 --> 00:18:13.290
And as I mentioned earlier,
Apple Lynx and Apple FW-OHCI are

00:18:13.290 --> 00:18:16.550
subclasses of IO FireWire
Controller that know how to talk

00:18:16.550 --> 00:18:20.060
to the specific DMA controllers in
the products that we've shipped.

00:18:23.160 --> 00:18:26.940
I mentioned IO FireWire Device,
that this is created for any device

00:18:26.940 --> 00:18:30.690
on the bus where we are able to
read at least the bus information

00:18:30.690 --> 00:18:32.260
block from the config ROM.

00:18:32.260 --> 00:18:35.310
There will be one of these per device.

00:18:35.320 --> 00:18:39.370
IO FireWire Device keeps track
of the node ID in a device,

00:18:39.370 --> 00:18:45.050
which may change from time to time due
to dynamic reconfiguration of the bus.

00:18:45.860 --> 00:18:48.490
IO FireWire Device also
discovers the vendor ID,

00:18:48.490 --> 00:18:52.420
which is in the root directory,
and publishes this in the IO registry so

00:18:52.420 --> 00:18:54.820
that you can use it for driver matching.

00:18:54.820 --> 00:18:59.150
But the main job for IO FireWire
Device is to scan the configuration

00:18:59.150 --> 00:19:04.120
ROM on the device that it is attached to,
looking for unit directories,

00:19:04.120 --> 00:19:07.030
and when it finds them,
publish those unit directories

00:19:07.030 --> 00:19:10.100
in the IO registry so that
driver loading can continue.

00:19:13.060 --> 00:19:14.160
I/O FireWire Unit.

00:19:14.200 --> 00:19:17.400
This is what's created
by I/O FireWire device.

00:19:17.490 --> 00:19:20.090
For each unit directory
discovered in the config ROM,

00:19:20.120 --> 00:19:22.540
there's one I/O FireWire unit.

00:19:22.590 --> 00:19:25.500
The unit will find and
publish the unit spec ID,

00:19:25.500 --> 00:19:32.540
unit software version, and again,
the vendor ID in the I/O registry

00:19:32.540 --> 00:19:34.690
so that this information can be
used for continued driver matching.

00:19:35.100 --> 00:19:41.970
An ordinary FireWire device
driver in the kernel will have

00:19:41.970 --> 00:19:41.970
IO FireWire unit as its provider.

00:19:43.300 --> 00:19:52.800
Both IO FireWire Device and IO FireWire
Unit derive from IO FireWire Nub.

00:19:52.800 --> 00:19:56.240
If you want to find out how these work,
you should definitely look in the Nub,

00:19:56.250 --> 00:19:58.870
which is where a lot of
the activity takes place.

00:20:01.180 --> 00:20:04.960
Now, what kinds of things do we
put in the I/O registry?

00:20:05.050 --> 00:20:07.590
There are two service
planes that FireWire uses.

00:20:07.590 --> 00:20:09.600
There's the primary
I/O Kit service plane.

00:20:09.600 --> 00:20:13.100
That's what you get by default
when you run I/O Registry Explorer.

00:20:13.100 --> 00:20:16.890
You can find the I/O FireWire
controller in there,

00:20:16.890 --> 00:20:19.600
hanging off of the
corresponding PCI node.

00:20:19.600 --> 00:20:25.620
You can find I/O FireWire device,
if you have any devices on your bus.

00:20:25.700 --> 00:20:27.590
And if you do, you can probably also
find I/O FireWire unit.

00:20:28.580 --> 00:20:33.190
There's also an IO FireWire plane
created by FireWire in the registry.

00:20:33.360 --> 00:20:35.310
This is where we store
some FireWire-specific

00:20:35.370 --> 00:20:36.950
information about bus topology.

00:20:36.950 --> 00:20:42.570
And you can find FireWire controller
and FireWire device objects in there.

00:20:44.830 --> 00:20:46.780
Okay,
now I'd like to give a demonstration of

00:20:46.780 --> 00:20:50.030
some of the things that we've included
in our software development kit.

00:20:50.040 --> 00:20:55.350
So if I can have Demo 1 up on the screen.

00:20:55.350 --> 00:20:55.350
Thank you.

00:20:58.240 --> 00:21:00.760
I can't see you all really well,
but I'd like to see a show of hands.

00:21:00.760 --> 00:21:05.610
How many people have downloaded,
installed, and used one of our

00:21:05.610 --> 00:21:08.100
FireWire SDKs for Mac OS X?

00:21:08.100 --> 00:21:08.760
Can you raise your hands?

00:21:08.760 --> 00:21:15.090
So most of you haven't,
but thank you for everyone who did.

00:21:15.810 --> 00:21:18.880
What I'd like to show you now is
some of what we have in the SDK.

00:21:19.030 --> 00:21:24.200
We have spent a lot of time
trying to provide a foolproof,

00:21:24.370 --> 00:21:29.500
straightforward SDK with sample code,
with examples, pre-compiled binaries,

00:21:29.610 --> 00:21:33.360
step-by-step instructions
that you just can't fail.

00:21:33.360 --> 00:21:36.310
Let me show you how easy this is to use.

00:21:36.370 --> 00:21:40.590
I have a CD here with
the FireWire SDK on it.

00:21:40.780 --> 00:21:43.300
You would probably download
this from our website.

00:21:43.300 --> 00:21:46.580
I'm simply going to drag
it into my home directory.

00:21:49.770 --> 00:21:52.790
Here it is, ioFireWireSDK7.sith.

00:21:52.820 --> 00:21:53.600
This is the latest one.

00:21:53.600 --> 00:21:57.560
Simply double-click on the
archive file and it will expand.

00:22:01.180 --> 00:22:05.020
and now we have a standard
Mac OS X installer.

00:22:05.020 --> 00:22:07.640
For those of you who started
with FireWire SDK number one,

00:22:07.640 --> 00:22:11.700
you may recall some very tedious
steps for how to install the software.

00:22:11.780 --> 00:22:13.890
If you went through those,
you probably learned some

00:22:13.890 --> 00:22:18.620
useful things about how Unix
works and how we store KEXTs.

00:22:18.620 --> 00:22:20.000
But we've made it quite a bit easier now.

00:22:20.000 --> 00:22:22.340
You can simply use the installer.

00:22:23.330 --> 00:22:26.030
Pick a drive on which
you'd like to install.

00:22:26.060 --> 00:22:31.140
Choose a directory within that drive,
such as Apple is the local user here.

00:22:31.140 --> 00:22:33.530
We'll put it in the Documents folder.

00:22:36.000 --> 00:22:37.850
Select Install,
and in just a few seconds,

00:22:37.850 --> 00:22:40.460
the SDK will be installed,
and you'll be ready to go.

00:22:44.480 --> 00:22:47.090
There, that was a lot easier than going
through that script we used to have.

00:22:47.120 --> 00:22:53.310
So the SDK is now in my
Documents folder as FireWire SDK.

00:22:55.320 --> 00:22:56.420
Here's some of the things in here.

00:22:56.430 --> 00:23:01.760
Readme.txt and readme.rtf,
these are exactly the same file.

00:23:01.760 --> 00:23:05.740
Open this one if you're
running in Classic or Mac OS 9.

00:23:05.740 --> 00:23:08.170
Open this one if you're
running in Mac OS X.

00:23:08.180 --> 00:23:13.030
This has step-by-step instructions for
how to walk you through installing,

00:23:13.030 --> 00:23:16.150
building, running, everything in the SDK.

00:23:16.160 --> 00:23:18.560
You can't fail if you just
follow them line by line.

00:23:18.560 --> 00:23:20.000
It's very straightforward.

00:23:20.000 --> 00:23:21.820
We've tried it over and over again.

00:23:22.780 --> 00:23:25.020
Let me show you some of the
highlights of what's in here.

00:23:25.020 --> 00:23:26.740
Let's start in the Tools folder.

00:23:28.160 --> 00:23:32.040
IO Registry Explorer, this is a standard
Mac OS X developer tool.

00:23:32.040 --> 00:23:34.590
It's provided in the
standard developer install.

00:23:34.660 --> 00:23:37.490
We've made a very minor change
that makes it a little more

00:23:37.490 --> 00:23:39.420
convenient to use on FireWire.

00:23:39.500 --> 00:23:42.680
I'll run this and show you what's
changed and also show you how to navigate

00:23:42.700 --> 00:23:45.830
around and find FireWire objects.

00:23:46.060 --> 00:23:49.210
Actually, before I do that,
I'm going to turn on this FireWire camera

00:23:49.210 --> 00:23:50.720
so that we have somebody to talk to.

00:24:02.790 --> 00:24:05.010
Within the Registry Explorer,
you will have to dig a

00:24:05.020 --> 00:24:07.100
little ways to find FireWire.

00:24:07.140 --> 00:24:10.700
Registry Explorer is very similar to
Display Name Registry for Mac OS 9,

00:24:10.700 --> 00:24:15.540
except it's organized more
like Mac OS X's Finder view

00:24:15.540 --> 00:24:18.690
that has these rows of columns.

00:24:19.400 --> 00:24:23.300
Power Mac 3.4 is the actual
hardware we're running on.

00:24:23.300 --> 00:24:26.240
If we look inside the platform expert,
we find various kinds of device.

00:24:26.240 --> 00:24:30.470
This PCI bus, I just happen to know,
has FireWire on it.

00:24:30.510 --> 00:24:33.790
You might try the other two
first if you can't find it.

00:24:34.030 --> 00:24:35.520
Here's FireWire over here.

00:24:35.580 --> 00:24:36.640
FireWire at E.

00:24:36.640 --> 00:24:40.560
And this system, since it's our G4,
has an open HCI in it.

00:24:42.360 --> 00:24:44.500
Starting here,
you may have spotted what we

00:24:44.500 --> 00:24:47.900
changed in this particular
version of Registry Explorer.

00:24:47.900 --> 00:24:52.780
These numbers that are shown in
decimal are also shown in hex.

00:24:52.780 --> 00:24:55.660
It's a very little thing, but...

00:24:59.020 --> 00:25:00.280
Here's where it really starts to matter.

00:25:00.280 --> 00:25:03.480
If you go into IO FireWire
controller and look at your node ID,

00:25:03.480 --> 00:25:09.110
65473, I don't know if that's right,
but FFC1 is clearly node

00:25:09.110 --> 00:25:11.180
1 on the FireWire bus.

00:25:11.180 --> 00:25:13.560
So having hex in here
should be helpful to you.

00:25:15.390 --> 00:25:17.790
So these are the things that you
saw in the stack that built up.

00:25:18.150 --> 00:25:22.640
Apple FW-OHCI,
which is an IO FireWire controller.

00:25:22.640 --> 00:25:28.520
It has discovered this camera on the
bus that created an IO FireWire device.

00:25:28.520 --> 00:25:32.810
Within the device you can see
things like the vendor name,

00:25:32.810 --> 00:25:37.020
the model because they provided
a string in there for us,

00:25:37.020 --> 00:25:38.260
the node ID.

00:25:38.460 --> 00:25:42.160
This device has a unit directory,
so IO FireWire unit was created.

00:25:42.160 --> 00:25:44.950
The user client also gets
tacked on at this point.

00:25:44.950 --> 00:25:49.140
Here in the unit,
you can see the unit spec ID, A02D,

00:25:49.140 --> 00:25:53.180
which specifies the
1394 trade association,

00:25:53.180 --> 00:25:57.200
and the unit software version, 1001 HEX.

00:25:57.200 --> 00:26:00.810
This specifies the AVC command set,
which is reasonable because

00:26:00.810 --> 00:26:02.260
this is a DV camcorder.

00:26:02.260 --> 00:26:07.640
And in fact, we loaded the IO FWDV driver
against this device.

00:26:09.530 --> 00:26:13.370
So you can see that IO Registry
provides information similar

00:26:13.370 --> 00:26:16.920
to Display Name Registry,
and it has the details that

00:26:16.920 --> 00:26:21.320
you'll need to figure out what
we thought of your device,

00:26:21.320 --> 00:26:23.770
what we thought its unit contained,
its vendor was,

00:26:23.770 --> 00:26:27.880
so that you can find the information to
enter in Project Builder for matching

00:26:28.090 --> 00:26:32.060
your device so that your driver can
load correctly against your device.

00:26:36.760 --> 00:26:40.300
One of the other tools
provided in the SDK is HackTV.

00:26:40.370 --> 00:26:43.100
This is just a standard
QuickTime sample code.

00:26:43.100 --> 00:26:48.400
It's a little application that
will receive video from the camera.

00:26:48.430 --> 00:26:49.790
There's actually two files provided.

00:26:49.800 --> 00:26:52.700
HackTVStructure.Sketch is
a really simple picture.

00:26:52.700 --> 00:26:57.070
If you attended our kitchen in Tokyo,
I think William drew this on the fly,

00:26:57.070 --> 00:26:58.400
and so we put this in the SDK.

00:26:58.400 --> 00:27:02.240
It just shows the layers
of things inside HackTV,

00:27:02.240 --> 00:27:05.520
how all the parts are working together.

00:27:06.670 --> 00:27:11.320
Hack TV itself will open up a connection
to the camera and display video from it.

00:27:11.390 --> 00:27:14.610
So here you can see the DVs coming in,
just like the iMovie demo

00:27:14.610 --> 00:27:17.550
that we showed yesterday,
except this is running in just a

00:27:17.550 --> 00:27:20.200
simple standard QuickTime sample code.

00:27:29.380 --> 00:27:33.480
CarbonVid Out app is a similar
application that can take a DV file

00:27:33.480 --> 00:27:36.170
and export it back to a camera.

00:27:36.180 --> 00:27:39.240
And you can watch it play
at full 30 frames per second

00:27:39.290 --> 00:27:41.020
on the screen on the camera.

00:27:42.650 --> 00:27:45.500
UUID generator is a small
tool that you may need to use.

00:27:45.500 --> 00:27:47.790
You can read about the
details when you get to that.

00:27:50.530 --> 00:27:55.760
Backing up to the top of the SDK,
this directory source contains

00:27:55.760 --> 00:28:00.410
full source code to the IO FireWire
family and IO FireWire SBP-2,

00:28:00.410 --> 00:28:01.640
including all of the user clients.

00:28:01.660 --> 00:28:03.470
So you can find out exactly what we did.

00:28:03.470 --> 00:28:05.850
A few of you have even found
bugs and reported those.

00:28:05.850 --> 00:28:07.010
We're fixing all that.

00:28:07.010 --> 00:28:11.490
All the other goodies
are here in Examples.

00:28:11.680 --> 00:28:14.960
There's a number of programs,
sample code, to show you how to use

00:28:14.960 --> 00:28:16.330
FireWire on Mac OS X.

00:28:18.300 --> 00:28:20.320
Let's start with SBP-2 sample project.

00:28:20.320 --> 00:28:24.040
Let me show you just how
easy it is to compile,

00:28:24.040 --> 00:28:26.980
build, and run our sample code for SBP-2.

00:28:26.980 --> 00:28:29.190
This is a Cocoa application.

00:28:29.190 --> 00:28:31.400
I'll open it up in
Project Builder and build it.

00:28:31.440 --> 00:28:35.880
This application talks to
an arbitrary SBP-2 device.

00:28:35.880 --> 00:28:38.340
To build the application,
all you do is click on the

00:28:38.340 --> 00:28:40.730
hammer in Project Builder,
wait a moment while it

00:28:40.760 --> 00:28:41.870
compiles everything.

00:28:41.980 --> 00:28:44.760
You can see there's a fair
amount of stuff in here.

00:28:44.760 --> 00:28:50.030
This application will talk to
this FireWire disk drive and

00:28:50.030 --> 00:28:54.580
will serve as a sample for how
to gain access to your device,

00:28:54.600 --> 00:28:57.780
how to form an orb and
send it to your device,

00:28:57.780 --> 00:29:00.970
how to get data back,
and it shows how to do it all in

00:29:00.970 --> 00:29:03.000
Project Builder with Cocoa as well.

00:29:03.000 --> 00:29:05.530
It'll take just a moment to build.

00:29:18.630 --> 00:29:21.600
Sorry, the question was,
do you have Code Warrior sample code?

00:29:21.600 --> 00:29:22.920
And we don't have any at this time.

00:29:22.920 --> 00:29:24.600
We'd certainly like to add that, however.

00:29:24.600 --> 00:29:26.490
If one of you has
already figured that out,

00:29:26.490 --> 00:29:29.070
we'd be happy to throw it in the
SDK if you just send it to us.

00:29:29.070 --> 00:29:30.990
Otherwise, we'll take care of that.

00:29:30.990 --> 00:29:33.550
Ignore that build warning, and it's done.

00:29:33.550 --> 00:29:37.080
We've built the SBP-2 sample,
and you can find it here in this

00:29:37.080 --> 00:29:39.860
directory that was created called build.

00:29:41.200 --> 00:29:43.560
Here's an application, text, and plug-in.

00:29:43.610 --> 00:29:44.590
I'm going to skip a few steps.

00:29:44.640 --> 00:29:47.200
I've already installed these in the
system folder so that they'll load.

00:29:47.200 --> 00:29:52.990
Now, nothing's here because I didn't
actually plug in the drive.

00:30:01.980 --> 00:30:05.740
So the app has found an SBP-2 device.

00:30:05.740 --> 00:30:10.860
In fact, it found the IO FireWire SBP-2
LUN object that I told you about earlier,

00:30:10.860 --> 00:30:14.370
corresponding to the single logical
unit that's present in a disk drive.

00:30:14.370 --> 00:30:18.010
We will select that,
and we get a window that allows

00:30:18.010 --> 00:30:21.290
us to log into the device,
which I will do.

00:30:21.830 --> 00:30:25.360
The device spins up in response to that,
and now that it's spinning,

00:30:25.360 --> 00:30:27.860
we can press this button to
read a block from the device.

00:30:27.860 --> 00:30:32.420
This simply reads block 0 and dumps
it out completely raw in this window.

00:30:32.420 --> 00:30:34.120
Cocoa makes this really easy to do.

00:30:37.800 --> 00:30:40.840
Nothing in here was specific
to a disk drive except actually

00:30:40.840 --> 00:30:42.420
the read block zero command.

00:30:42.420 --> 00:30:46.540
So, you can use this application and code
as a starting point for talking to

00:30:46.540 --> 00:30:53.360
just about any kind of SBP-2 device.

00:30:53.360 --> 00:30:55.740
There's other things in the SDK.

00:30:59.940 --> 00:31:01.960
I'm going to go into the
pre-built binaries folder,

00:31:02.010 --> 00:31:05.210
but all of this is provided
as source code as well.

00:31:05.560 --> 00:31:10.310
FWUtil is a very simple command line
program that can read quadlets out

00:31:10.360 --> 00:31:13.760
of your FireWire device just to show
you how to start talking to a device.

00:31:13.760 --> 00:31:17.400
IO FireWire Lib Demo is similar,
except it shows the entire

00:31:17.400 --> 00:31:19.280
config ROM of your device.

00:31:19.280 --> 00:31:24.460
FireWire Packet Queue Test can send
packets between two Macintosh systems.

00:31:24.460 --> 00:31:28.110
Notifier provides you with some sample
code for how to get notification

00:31:28.110 --> 00:31:31.260
when things happen on the bus,
like a device appearing.

00:31:32.520 --> 00:31:37.490
Read Test and Write Test are
isochronous sample code that use the

00:31:37.610 --> 00:31:40.920
DV driver to capture and export DV.

00:31:40.920 --> 00:31:44.110
It does it right from the command line,
as opposed to Hack TV,

00:31:44.110 --> 00:31:46.380
which does it in a nice GUI application.

00:31:46.380 --> 00:31:48.320
So let's take a look at some of these.

00:31:48.320 --> 00:31:54.900
Oops.

00:31:54.900 --> 00:32:01.100
Trust you can all see this.

00:32:19.210 --> 00:32:21.450
So using the terminal,
I'm going to run some of the

00:32:21.450 --> 00:32:24.620
programs that are provided in
the pre-built binaries folder.

00:32:24.670 --> 00:32:27.670
We'll start with FWUtil.

00:32:28.590 --> 00:32:30.500
This is a really simple program.

00:32:30.500 --> 00:32:33.340
The device it's talking to, I believe,
is this hard drive.

00:32:33.380 --> 00:32:35.390
Might be the camera.

00:32:35.450 --> 00:32:38.860
You can use commands similar
to what was in Firebug.

00:32:42.050 --> 00:32:45.110
I'm going to read a quadlet
out of the configuration ROM.

00:32:45.120 --> 00:32:50.890
This particular quadlet is the first 32
bits of the serial number of the device.

00:32:55.190 --> 00:32:57.130
Here's the next 32 bits.

00:32:57.180 --> 00:32:59.500
This looks like it's the
disk drive because I--no,

00:32:59.500 --> 00:33:00.130
this is the camera.

00:33:00.170 --> 00:33:04.010
85 is Canon's vendor ID,
so we've read the serial number out of

00:33:04.010 --> 00:33:06.970
this device using this command line tool.

00:33:07.120 --> 00:33:10.090
Not terribly useful,
but all the source code is provided so

00:33:10.100 --> 00:33:14.290
that you can adapt this into something
that your customers would actually use.

00:33:16.660 --> 00:33:20.190
IO FireWire libdemo I mentioned
earlier reads the entire config ROM all

00:33:20.190 --> 00:33:21.780
at once and dumps it out in hex.

00:33:21.780 --> 00:33:23.220
It's extremely easy to use.

00:33:28.370 --> 00:33:30.710
There you can see, in fact,
it's dumped them out for both

00:33:30.840 --> 00:33:34.400
devices on the FireWire bus,
the camera and the disk drive.

00:33:34.400 --> 00:33:37.540
One of them seems to have
a lot of empty space,

00:33:37.540 --> 00:33:39.640
but all of the data is here.

00:33:42.810 --> 00:33:45.100
So as you can see,
we have a lot of stuff in the SDK.

00:33:45.100 --> 00:33:46.880
It's all completely ready to use.

00:33:46.880 --> 00:33:48.830
It's been pre-compiled,
so you can just run it.

00:33:48.830 --> 00:33:52.020
Building it in Project Builder
is just a single click.

00:33:52.110 --> 00:33:57.160
Some of the command line tools are
built by compiling them in Terminal,

00:33:57.160 --> 00:34:02.380
but there are step-by-step,
there being one-step, instructions in the

00:34:02.470 --> 00:34:04.180
SDK for how to do that.

00:34:09.880 --> 00:34:11.880
Okay, that's all the highlights
for things in the SDK.

00:34:11.880 --> 00:34:16.820
Hopefully,
what you'll take away from this

00:34:16.820 --> 00:34:19.440
is that it's all ready to use.

00:34:19.440 --> 00:34:24.010
We believe you can ship,
you can develop drivers, applications,

00:34:24.010 --> 00:34:27.060
user space code,
and ship it to customers for

00:34:27.060 --> 00:34:29.670
FireWire with what we've got here.

00:34:29.680 --> 00:34:31.720
Of course,
we're working on bringing you more,

00:34:31.720 --> 00:34:33.720
but we've got quite a
bit to offer in this SDK.

00:34:33.720 --> 00:34:35.900
Okay, let's go back to the slides.

00:34:39.800 --> 00:34:42.880
I think I went too far.

00:34:48.260 --> 00:34:52.160
So I'd like to continue talking
about some of the objects that are

00:34:52.160 --> 00:34:56.360
in Mac OS X's FireWire services
that you will be using when you

00:34:56.380 --> 00:34:58.240
write code for these devices.

00:34:58.550 --> 00:35:02.670
I-O-F-W-Command is the sort of
all-purpose object for sending

00:35:02.840 --> 00:35:05.000
commands to a FireWire device.

00:35:05.000 --> 00:35:08.940
It's similar to the FireWire
command object in Mac OS 9,

00:35:08.940 --> 00:35:11.890
except there's, again,
mechanical changes to fit within

00:35:11.960 --> 00:35:13.520
C++ and fit within I-O-Kit.

00:35:15.990 --> 00:35:20.250
The IOFW command object provides all
of the services you need for making

00:35:20.320 --> 00:35:23.820
synchronous or asynchronous commands,
for handling callbacks

00:35:23.880 --> 00:35:24.730
when things are finished.

00:35:24.730 --> 00:35:29.010
It's all handled in a common
way through this class.

00:35:29.340 --> 00:35:32.250
There are a number of derived
classes for sending particular

00:35:32.260 --> 00:35:33.900
kinds of commands to a device.

00:35:33.900 --> 00:35:38.640
In particular, IOFW Async command
handles all of your read,

00:35:38.640 --> 00:35:40.400
write, and lock operations.

00:35:40.400 --> 00:35:45.650
IOFW Bus command handles commands
that apply to the FireWire bus,

00:35:45.650 --> 00:35:50.940
such as allocating local address
space or other bus resources.

00:35:54.060 --> 00:36:01.280
The class IofwIsocChannel corresponds
to a channel command object in Mac OS 9.

00:36:01.280 --> 00:36:06.340
An isochronous channel object
exists corresponding to one active

00:36:06.340 --> 00:36:09.550
isochronous channel on the FireWire bus.

00:36:11.150 --> 00:36:14.210
The purpose for the existence
of the channel is to keep

00:36:14.210 --> 00:36:18.800
track of the actual resources,
the bandwidth and the channel number,

00:36:18.850 --> 00:36:19.840
across bus resets.

00:36:19.840 --> 00:36:24.270
It also serves as a common reference
point for everyone who's doing something,

00:36:24.270 --> 00:36:27.480
sending or receiving,
on that isochronous channel.

00:36:27.480 --> 00:36:33.460
So associated with it are
IOFWISOC port class objects.

00:36:33.460 --> 00:36:40.500
A port corresponds to an actual point
of talking or listening on a channel.

00:36:41.100 --> 00:36:43.200
If a channel is going to
do anything interesting,

00:36:43.200 --> 00:36:48.660
it probably has at least one listening
port and exactly one talking port.

00:36:50.750 --> 00:36:56.110
You can subclass IOFW-ISOCH port
to provide the mechanisms that are

00:36:56.190 --> 00:37:01.990
specific to your device for starting
and stopping communication on a channel.

00:37:01.990 --> 00:37:06.700
When a channel is started,
each of its ports will be called so

00:37:06.720 --> 00:37:11.190
that it can do port-specific things
to start operating on the channel.

00:37:11.190 --> 00:37:14.640
The transmitter could start
a DCL program to send data.

00:37:14.640 --> 00:37:19.010
The receiver might program registers in
a device that cause it to pick up the

00:37:19.040 --> 00:37:22.050
data and do something useful with it.

00:37:24.300 --> 00:37:29.120
Similarly,
IOFW local Isoch port is a port

00:37:29.120 --> 00:37:33.940
on a channel that is corresponding
to hardware on the Macintosh.

00:37:33.940 --> 00:37:39.220
Generally, if you have a channel,
you will have one local Isoch port on it,

00:37:39.220 --> 00:37:43.500
unless you're acting as a manager for
two other devices who think they're

00:37:43.520 --> 00:37:44.910
talking to each other on the bus.

00:37:44.920 --> 00:37:50.290
A local port corresponds,
or has a DCL program attached to it.

00:37:50.660 --> 00:37:53.290
This is the same service
that we had in Mac OS 9.

00:37:53.300 --> 00:37:56.760
DCL stands for
Data Stream Control Language,

00:37:56.760 --> 00:38:01.520
and it's an abstract programming
language where you build a structure in

00:38:01.520 --> 00:38:06.080
memory describing on a packet-by-packet
basis how you're going to send

00:38:06.080 --> 00:38:08.090
or receive isochronous data.

00:38:08.100 --> 00:38:13.570
We take that DCL program and compile it
into a DMA program that runs on the kind

00:38:13.580 --> 00:38:19.120
of hardware that we have in the Mac,
whether it's OpenHCI or PCI-Linux.

00:38:19.120 --> 00:38:20.610
So your driver needs no knowledge.

00:38:20.660 --> 00:38:23.300
knowledge of the hardware specifics.

00:38:23.500 --> 00:38:28.220
The DCL programs in Mac OS X use the same
opcodes and same structure as Mac OS 9.

00:38:28.220 --> 00:38:34.080
It should be very easy to adapt an
existing DCL to work in Mac OS X.

00:38:36.910 --> 00:38:38.790
Okay, more about user clients.

00:38:38.880 --> 00:38:41.560
Formally,
this is called a device interface,

00:38:41.560 --> 00:38:43.780
but everyone calls it a user client,
so I will too.

00:38:43.780 --> 00:38:47.630
A user client, as I said before,
is a layer of software that

00:38:47.630 --> 00:38:51.360
allows you to talk to FireWire
devices from application space.

00:38:51.360 --> 00:38:54.520
There's many good reasons for doing this.

00:38:55.330 --> 00:38:59.110
In order to hook up to your device,
you may need to put a

00:38:59.150 --> 00:39:01.200
stub KEXT in the kernel.

00:39:01.200 --> 00:39:05.830
This could be as simple as an empty
KEXT with a little bit of XML to

00:39:05.840 --> 00:39:10.460
match your device in order to
give you control over your device.

00:39:10.730 --> 00:39:15.440
For example, if you wanted to talk to a
device that also matched against

00:39:15.440 --> 00:39:19.530
Apple's standard disk driver,
you might create a stub KEXT that

00:39:19.530 --> 00:39:23.530
gets a higher probe score or a
tighter match that would enable you

00:39:23.570 --> 00:39:28.600
to win over our disk driver and then
talk to your device from user space.

00:39:28.850 --> 00:39:32.030
We provide complete access to
the FireWire services in the

00:39:32.030 --> 00:39:34.010
kernel through the user client.

00:39:34.020 --> 00:39:37.120
So if your device doesn't
have to be in the kernel

00:39:37.120 --> 00:39:42.260
because of OS-specific reasons,
put it in user space.

00:39:42.260 --> 00:39:44.420
Some drivers simply have
to go in the kernel.

00:39:44.420 --> 00:39:47.320
If you have a mass storage device
that's going to mount a file system,

00:39:47.320 --> 00:39:48.620
that has to be in the kernel.

00:39:48.620 --> 00:39:52.610
But if you have some kind of printer,
scanner, digital video device,

00:39:52.620 --> 00:39:54.780
all of those can go up in user space.

00:39:56.140 --> 00:39:59.680
Isochronous services will be available
very soon in the user client.

00:39:59.760 --> 00:40:02.130
They're not yet in the SDK,
but that's our number one thing

00:40:02.130 --> 00:40:03.700
that we're working on right now.

00:40:03.700 --> 00:40:07.070
Probably in the next week or two,
we will post another SDK with

00:40:07.070 --> 00:40:09.610
Isochronous services for the user client.

00:40:13.570 --> 00:40:16.400
The IO FireWire SBP-2 family
I talked about before.

00:40:16.400 --> 00:40:17.840
It's the service layer.

00:40:17.840 --> 00:40:19.990
It's ported almost
directly from Mac OS 9,

00:40:19.990 --> 00:40:23.540
so it's very similar in how it works,
although it's been cleaned up

00:40:23.650 --> 00:40:26.370
to fit properly in I/O Kit,
so there's no strange

00:40:26.370 --> 00:40:28.080
legacy Mac OS 9 issues.

00:40:29.850 --> 00:40:33.180
This layer is used by the
Apple FireWire disk driver.

00:40:33.180 --> 00:40:36.280
Last year,
we had a monolithic demonstration disk

00:40:36.310 --> 00:40:40.490
driver to show that it could be done,
but all of the mass storage layer

00:40:40.490 --> 00:40:44.620
SBP-2 had been rolled up into
one big mess and made a driver.

00:40:44.620 --> 00:40:47.770
It worked, but it was not sustainable,
so we've broken that up

00:40:47.850 --> 00:40:49.180
into discrete layers.

00:40:49.440 --> 00:40:53.240
This is what's in Mac OS X today,
and it's what's used

00:40:53.270 --> 00:40:55.290
by our standard driver.

00:40:56.460 --> 00:40:58.960
I mentioned before,
IO FireWire Serial Bus Protocol.

00:40:58.980 --> 00:41:03.130
transport KEXT and
applefirewiremassstoragedrivers KEXT.

00:41:03.130 --> 00:41:05.860
That's the Apple software that
provides a standard driver.

00:41:05.860 --> 00:41:08.970
You can subclass that or replace
it if you need to provide a

00:41:08.970 --> 00:41:10.720
driver for your own device.

00:41:12.270 --> 00:41:17.100
One particular function of IO FireWire
SBP-2 is it knows how to read the

00:41:17.100 --> 00:41:21.840
config ROM of an SBP-2 device and
find SBP-2 specific information

00:41:21.840 --> 00:41:23.850
to use for driver matching.

00:41:23.850 --> 00:41:29.150
SBP-2 devices publish a command set,
a command set spec ID, logical units,

00:41:29.220 --> 00:41:33.150
various other information
that is specific to SBP-2.

00:41:33.150 --> 00:41:35.710
You wouldn't find it in a camcorder.

00:41:35.710 --> 00:41:39.390
So IO FireWire SBP-2 is the
layer that digs that out,

00:41:39.390 --> 00:41:42.180
publishes it in the IO Registry.

00:41:42.200 --> 00:41:45.250
And then allows I/O Kit to
perform more precise device

00:41:45.290 --> 00:41:47.500
matching using that information.

00:41:51.310 --> 00:41:53.860
We have a user client for SBP-2.

00:41:53.890 --> 00:41:57.670
This gives you all of the SBP-2 services
that are available in the kernel and

00:41:57.680 --> 00:41:59.500
makes them available in user space.

00:41:59.500 --> 00:42:02.620
If you want to write a
driver for FireWire printer,

00:42:02.620 --> 00:42:07.170
FireWire scanner, FireWire still camera,
you'll probably be using the SBP-2

00:42:07.170 --> 00:42:09.220
user client in application space.

00:42:10.290 --> 00:42:13.380
You can use this by itself,
or you can use it in combination with

00:42:13.380 --> 00:42:15.080
the ordinary FireWire user client.

00:42:15.080 --> 00:42:19.170
If you have some device that has
additional functions outside of SBP-2,

00:42:19.170 --> 00:42:22.390
you can talk to them with normal
FireWire commands using the

00:42:22.420 --> 00:42:24.340
normal FireWire user client.

00:42:24.340 --> 00:42:28.660
So you can use one or the other, or both,
depending on the needs of your device.

00:42:32.490 --> 00:42:33.760
I/O FireWire DV.

00:42:33.970 --> 00:42:37.000
This is the standard DV device
driver that we provide.

00:42:37.000 --> 00:42:40.400
It provides services very
similar to what was in Mac OS 9.

00:42:40.400 --> 00:42:43.390
It is a device driver for DV cameras.

00:42:43.390 --> 00:42:48.390
It can transmit and receive frame
accurate 30 frames per second DV.

00:42:48.390 --> 00:42:52.270
It supports normal DV and the new
SDL mode that is present in that

00:42:52.280 --> 00:42:54.390
Canon camera I showed you earlier.

00:42:54.400 --> 00:42:57.440
Presently,
I/O FireWire DV lives in the kernel.

00:42:57.440 --> 00:43:02.210
It lives there because we don't have the
Isochronous API out in user space yet,

00:43:02.210 --> 00:43:04.400
so putting it in the kernel worked.

00:43:04.400 --> 00:43:07.390
We would like to move that out to user
space and we're going to try to do that.

00:43:07.410 --> 00:43:11.600
We certainly recommend if you're
developing an Isochronous driver,

00:43:11.600 --> 00:43:13.350
try to do it in user space.

00:43:14.120 --> 00:43:17.200
If you want to use IO FireWire DV,
you can access it through

00:43:17.270 --> 00:43:20.580
QuickTime using the Sequence Grabber,
just like you would in Mac OS 9.

00:43:20.580 --> 00:43:23.120
And there's a lot of
sample code in the SDK,

00:43:23.130 --> 00:43:26.040
as I showed you earlier,
that can get you started

00:43:26.040 --> 00:43:27.350
on how to do that.

00:43:30.530 --> 00:43:31.980
Okay, so what do we have that's new?

00:43:31.980 --> 00:43:35.960
We've actually gotten quite a lot done
since last year when we told you about

00:43:35.960 --> 00:43:38.260
FireWire and Mac OS X for the first time.

00:43:38.260 --> 00:43:40.760
This year,
in the shipping version of Mac OS X,

00:43:40.760 --> 00:43:42.770
we have full support for OpenHCI.

00:43:42.770 --> 00:43:45.300
Last year,
we were really working best on the blue

00:43:45.300 --> 00:43:47.280
and white G3 with the old PCI links.

00:43:47.280 --> 00:43:49.480
Now we fully support all the hardware.

00:43:50.200 --> 00:43:53.510
The SBP-2 service layer and the
standard Apple Disk Driver are

00:43:53.510 --> 00:43:55.230
completely new since last year.

00:43:55.290 --> 00:43:57.080
They're very full-featured.

00:43:57.080 --> 00:44:01.460
The user client for FireWire and the
SBP-2 user client are also all new.

00:44:01.460 --> 00:44:04.700
We now have a standard DV driver
and QuickTime component.

00:44:04.700 --> 00:44:07.740
As you may have seen yesterday
in the intro to FireWire,

00:44:07.740 --> 00:44:09.910
iMovie is running just fine on Mac OS X.

00:44:09.940 --> 00:44:12.820
We couldn't show any kind
of DV at all last year.

00:44:12.820 --> 00:44:13.840
FireWire booting.

00:44:14.040 --> 00:44:15.590
There's not a whole lot to say here.

00:44:15.600 --> 00:44:17.870
You can boot from FireWire
devices in Mac OS X.

00:44:17.870 --> 00:44:19.690
Just go into the preferences.

00:44:20.200 --> 00:44:23.390
pick a FireWire device and boot from it.

00:44:24.150 --> 00:44:24.890
SDKs.

00:44:24.920 --> 00:44:28.780
We have published a bunch of
FireWire SDKs for Mac OS X already.

00:44:28.780 --> 00:44:31.680
In a major change from what
we were doing on Mac OS 9,

00:44:31.680 --> 00:44:33.680
we've made these free
and completely available.

00:44:33.680 --> 00:44:35.130
Anyone can download them.

00:44:35.130 --> 00:44:36.440
Just go to our website.

00:44:39.500 --> 00:44:41.180
Here's what we're going to
be working on for the future.

00:44:41.180 --> 00:44:43.490
As I mentioned,
the isochronous services in the

00:44:43.490 --> 00:44:45.130
user client aren't quite done yet.

00:44:45.140 --> 00:44:47.680
There was no corresponding
service in Mac OS 9.

00:44:47.680 --> 00:44:48.600
This is something new.

00:44:48.600 --> 00:44:50.280
We're making good progress on it.

00:44:50.280 --> 00:44:53.420
We expect to have an SDK out within
a week or two that you can try.

00:44:53.420 --> 00:44:57.050
In particular,
we intend to provide a sample code

00:44:57.050 --> 00:44:59.630
for a DCAM camera device driver.

00:45:21.040 --> 00:45:25.910
We have more sample code in general,
more documentation,

00:45:25.920 --> 00:45:28.950
we've added HeaderDoc, more tools.

00:45:28.950 --> 00:45:29.980
We also have a bunch of other
tools that we're going to be using.

00:45:30.220 --> 00:45:33.600
of bug fixes coming in the next SDK.

00:45:34.560 --> 00:45:37.420
Here's some general areas that we're
going to work on over the next year.

00:45:37.420 --> 00:45:42.460
1394.3, also known as the
Peer-to-Peer Data Transport.

00:45:42.460 --> 00:45:46.920
This is a protocol layer
that sits on top of SBP-2.

00:45:46.920 --> 00:45:49.740
This was invented by
the printer community.

00:45:49.740 --> 00:45:52.390
It's suitable for printers
and may be useful for other

00:45:52.430 --> 00:45:53.880
kinds of devices as well.

00:45:53.880 --> 00:45:57.960
It provides multiple streams
or pipes of communication over

00:45:57.960 --> 00:46:00.140
a single SBP-2 connection.

00:46:00.680 --> 00:46:02.740
If you have a device,
I don't believe there's

00:46:02.770 --> 00:46:04.780
any shipping today,
but if you have a device

00:46:04.780 --> 00:46:07.300
that uses this protocol,
you could write software for

00:46:07.310 --> 00:46:09.090
it with the SBP-2 user client.

00:46:09.090 --> 00:46:13.440
But part of what you invent there
would be common to any PPDT device,

00:46:13.440 --> 00:46:17.880
so we will provide a standard layer
to make that even easier to do.

00:46:19.880 --> 00:46:24.990
IEEE 12.12.R is a revision to
the specification that says

00:46:24.990 --> 00:46:27.350
how config ROMs are laid out.

00:46:27.380 --> 00:46:32.300
In particular, it contains a new service
called instance directories.

00:46:32.300 --> 00:46:35.400
This is a slightly different
way to describe the functions

00:46:35.500 --> 00:46:39.080
in your device as opposed to the
unit directory that we use today.

00:46:39.260 --> 00:46:42.940
Many of the consumer electronics
vendors felt it would be better to

00:46:42.940 --> 00:46:47.080
describe a device based on its function
rather than based on its protocol,

00:46:47.080 --> 00:46:51.260
so an instance directory tells you
what kind of functions a device has.

00:46:51.260 --> 00:46:54.890
We plan to add support for that since
devices are starting to appear that have

00:46:54.900 --> 00:46:56.870
this kind of data in their config ROM.

00:46:56.870 --> 00:47:00.920
This would give you an alternate way
of loading device drivers for a device.

00:47:00.920 --> 00:47:04.480
The purpose of instance directories is
to be a better way to discover functions,

00:47:04.480 --> 00:47:07.770
so it's natural to make it available
for driver matching and loading.

00:47:07.780 --> 00:47:11.760
Finally, as I talked about yesterday
at the intro section,

00:47:11.760 --> 00:47:15.390
we're going to be spending a
lot of time working on 1394B,

00:47:15.510 --> 00:47:17.940
or more precisely,
our hardware folks are going to be

00:47:17.940 --> 00:47:20.110
spending a lot of time working on 1394B.

00:47:20.140 --> 00:47:23.740
Almost nothing changed in software,
so we'll make a few little touch-ups

00:47:23.740 --> 00:47:25.590
and then ship that out to you.

00:47:27.570 --> 00:47:32.000
In conclusion, for Mac OS X,
we have extensive FireWire services.

00:47:32.000 --> 00:47:34.900
We believe it's really the equal
of what we had in Mac OS 9.

00:47:34.900 --> 00:47:37.660
Everything is there for you to
start writing drivers today.

00:47:37.660 --> 00:47:39.400
Please pick up the SDK.

00:47:39.420 --> 00:47:43.150
Here's the URL again that
provides information for both

00:47:43.330 --> 00:47:45.600
the SDK and our mailing list.

00:47:45.610 --> 00:47:47.390
This is a public mailing list.

00:47:47.410 --> 00:47:48.760
Anybody can subscribe.

00:47:48.760 --> 00:47:51.380
The exact details are at this URL.

00:47:52.210 --> 00:47:54.980
All we ask is that if you do
have confidential information,

00:47:54.980 --> 00:47:57.820
maybe we've sent you a seed unit
or you're working on some new

00:47:57.820 --> 00:48:00.690
product that nobody knows about,
please don't talk about

00:48:00.690 --> 00:48:01.830
it on the mailing list.

00:48:01.840 --> 00:48:03.400
You can ask general questions.

00:48:03.400 --> 00:48:07.260
Sometimes people do ask secret questions,
and I remove the secret information and

00:48:07.290 --> 00:48:09.310
post the response on the mailing list.

00:48:09.320 --> 00:48:11.180
The response so far has been quite good.

00:48:11.180 --> 00:48:14.580
Many of you have been answering each
other's questions on the mailing list,

00:48:14.580 --> 00:48:15.560
which is great.

00:48:15.560 --> 00:48:17.860
We do what we can to
answer questions as well.

00:48:17.860 --> 00:48:20.360
So if you're not participating,
please sign up and please

00:48:20.370 --> 00:48:22.070
participate in that mailing list.

00:48:22.120 --> 00:48:23.300
Thank you.

00:48:23.540 --> 00:48:26.180
Finally, as I said,
much of our source code is open source.

00:48:26.180 --> 00:48:26.860
It's in Darwin.

00:48:26.860 --> 00:48:28.740
It's also all provided in our SDK.

00:48:28.790 --> 00:48:32.180
If you do find a bug or you find
something that could be done better,

00:48:32.180 --> 00:48:34.930
a feature you'd like to add,
let us know about it.

00:48:34.940 --> 00:48:37.510
Use the standard Darwin mechanism
to submit your change.

00:48:37.510 --> 00:48:40.890
We've already picked up and incorporated
some changes that you've sent in.

00:48:44.300 --> 00:48:45.880
Related sessions here at WWDC.

00:48:45.880 --> 00:48:48.200
Yesterday there was a
very good presentation on

00:48:48.200 --> 00:48:50.100
storage drivers in I/O Kit.

00:48:50.100 --> 00:48:54.440
This is information that you'd need if
you're writing or subclassing drivers

00:48:54.650 --> 00:48:56.700
for storage devices on FireWire.

00:48:56.700 --> 00:49:00.410
If you missed the presentation yesterday,
I believe there will be a

00:49:00.470 --> 00:49:03.740
DVD series available from
WWDC so you can catch it there.

00:49:04.730 --> 00:49:08.390
Tomorrow at this same time, 2 o'clock,
we will have our feedback forum,

00:49:08.390 --> 00:49:11.920
combined FireWire and USB,
that's in room J1 down at the complete

00:49:11.920 --> 00:49:15.820
opposite end of the convention
center from where we were yesterday.

00:49:15.820 --> 00:49:17.330
That is like open mic night.

00:49:17.520 --> 00:49:20.060
You can just come and
say whatever you want.

00:49:20.060 --> 00:49:23.480
Tell us what you like,
what you don't like, ask questions,

00:49:23.480 --> 00:49:25.180
it's completely open.

00:49:25.180 --> 00:49:29.340
We just want your feedback for whether or
not we're meeting your needs in Mac OS X.

00:49:29.340 --> 00:49:34.180
Finally, tomorrow night, starting at 7,
back at Apple in the piano bar.

00:49:34.420 --> 00:49:35.450
I think it says 6 there.

00:49:35.450 --> 00:49:38.690
We will have a FireWire
and USB plug fest.

00:49:38.690 --> 00:49:42.000
So there's a big Apple party
at the Apple campus tomorrow.

00:49:42.000 --> 00:49:44.710
Come on by the piano bar,
it's in building 4 right out

00:49:44.740 --> 00:49:45.920
front by the parking lot.

00:49:45.940 --> 00:49:47.130
That's where we'll be.

00:49:47.130 --> 00:49:49.480
Bring your FireWire
device or your USB device.

00:49:49.480 --> 00:49:51.760
You can hang out with FireWire engineers.

00:49:51.760 --> 00:49:54.150
If you do have bugs,
we will have all the engineers

00:49:54.150 --> 00:49:55.660
there with the source code.

00:49:55.660 --> 00:49:59.800
We'll try to look at things as well as
we can between taking big chugs of beer.
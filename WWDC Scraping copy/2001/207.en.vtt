WEBVTT

00:00:02.610 --> 00:00:05.650
Good afternoon and welcome
to the USB In-Deepth session.

00:00:05.700 --> 00:00:14.200
We're going to go into USB both for user
client and kernel level development.

00:00:14.400 --> 00:00:15.240
I'm Craig Keithley.

00:00:15.240 --> 00:00:17.440
I'm the USB and FireWire
technology manager.

00:00:17.440 --> 00:00:18.950
Actually, I'm one of two.

00:00:19.060 --> 00:00:21.980
Greg Mullins, also in my group,
is another USB and FireWire

00:00:22.060 --> 00:00:23.300
technology manager.

00:00:23.400 --> 00:00:26.550
So with this session,
we'll go into what's

00:00:26.610 --> 00:00:28.350
involved with writing

00:00:28.800 --> 00:00:40.700
[Transcript missing]

00:00:46.000 --> 00:00:47.440
Thank you, Craig.

00:00:47.440 --> 00:00:53.770
We have a lot of topics to cover today,
so why don't we just get right on it.

00:00:54.620 --> 00:01:00.790
Today we're going to give you an overview
of the IOUSB Family class in Mac OS X,

00:01:00.810 --> 00:01:04.760
talk a little bit about the
objects that we have and how

00:01:04.760 --> 00:01:07.240
we use them in the kernel.

00:01:07.240 --> 00:01:13.880
We're going to go into some detail
into writing kernel and USB drivers

00:01:13.880 --> 00:01:19.910
and how to decide whether to be
in the kernel or in user space.

00:01:21.340 --> 00:01:27.220
A very critical part of
writing drivers is how to match

00:01:27.480 --> 00:01:30.630
your device to your driver.

00:01:30.640 --> 00:01:34.580
So we're also going to go into
quite a bit of detail into that.

00:01:34.580 --> 00:01:40.000
And at the end of the session,
we'll show some demos on how

00:01:40.000 --> 00:01:45.280
to debug USB drivers in the
kernel and in user space.

00:01:49.700 --> 00:01:53.500
As you probably know,
you will need to use Project Builder,

00:01:53.580 --> 00:01:56.530
which is Apple's integrated
development environment,

00:01:56.580 --> 00:02:00.780
to write both kernel
and user space drivers.

00:02:00.780 --> 00:02:06.900
If you are writing user space drivers,
you will be able to use

00:02:06.900 --> 00:02:11.290
the debugging features of
Project Builder to debug your driver.

00:02:12.310 --> 00:02:15.330
Unfortunately,
if you are a kernel space driver,

00:02:15.400 --> 00:02:19.840
you will have to get down and
dirty with GDB and terminal and

00:02:19.840 --> 00:02:21.230
debug your drivers that way.

00:02:24.810 --> 00:02:30.820
Later on, I'm going to talk about whether
you should write a user space

00:02:31.110 --> 00:02:33.000
or a kernel space driver.

00:02:33.000 --> 00:02:37.980
This is the first decision that you
have to make when you decide that you're

00:02:37.980 --> 00:02:40.180
writing a USB driver for Mac OS X.

00:02:40.180 --> 00:02:46.980
So it's very important to know
what you're going to do there.

00:02:47.620 --> 00:02:52.610
If you are in the kernel,
you will be able to use IOCAD's

00:02:52.690 --> 00:02:54.620
object-oriented features.

00:02:54.620 --> 00:02:58.140
So for example,
if you are writing a driver

00:02:58.140 --> 00:03:02.140
that is going to be subclass
from our mass storage driver,

00:03:02.140 --> 00:03:07.290
you will only have to write the
methods that you're overriding to

00:03:07.360 --> 00:03:11.240
implement your device-specific features.

00:03:11.240 --> 00:03:14.930
So it's a very convenient
way of doing it.

00:03:15.290 --> 00:03:20.640
Rhoaads will talk later on about
user space drivers in some detail.

00:03:20.640 --> 00:03:23.700
And as was mentioned in the
previous session on Firewire,

00:03:23.700 --> 00:03:34.010
we use the device interface model in
order to communicate between user space

00:03:34.010 --> 00:03:34.010
and our internal I/O USB family objects.

00:03:35.980 --> 00:03:39.500
The USB family is in the kernel.

00:03:39.860 --> 00:03:44.660
There's four or five
objects that we provide.

00:03:44.750 --> 00:03:51.010
They are delivered as a kernel extension
that goes in the extensions folder.

00:03:51.070 --> 00:03:57.240
We use this facility to
update USB without having to

00:03:57.240 --> 00:04:02.010
give you a whole new kernel.

00:04:02.750 --> 00:04:09.100
User space drivers can obviously
access the internal objects through

00:04:09.100 --> 00:04:13.850
the device user or the device interface
client that I mentioned earlier.

00:04:16.110 --> 00:04:20.610
This slide gives you just a
brief description of the internal

00:04:20.610 --> 00:04:23.540
objects for the IOUSB family.

00:04:23.590 --> 00:04:26.960
Those are the ones in purple.

00:04:26.960 --> 00:04:30.380
And in a later slide I will
talk in some detail about them.

00:04:30.380 --> 00:04:39.420
I just wanted to give you an
overview of where we fit within the

00:04:39.420 --> 00:04:39.420
user space and the kernel space.

00:04:41.590 --> 00:04:46.240
So let's talk a little more
about kernel mode USB drivers.

00:04:46.390 --> 00:04:52.500
How do you decide whether you're going
to be in the kernel or in user space?

00:04:52.710 --> 00:04:58.140
If at all possible,
you should not be in the kernel.

00:04:58.350 --> 00:05:01.390
However,
in some cases you don't have a chance.

00:05:01.490 --> 00:05:06.990
If you are writing a vendor-specific
driver for a keyboard,

00:05:07.220 --> 00:05:14.080
You need to be in the kernel because
at boot time if you're going into

00:05:14.170 --> 00:05:16.860
single user mode in the machine,
you need to have a keyboard.

00:05:16.860 --> 00:05:20.910
There's no user land processes
running at that time,

00:05:20.910 --> 00:05:22.830
so you have to be there.

00:05:22.840 --> 00:05:34.370
The other condition is if your
clients live in the kernel.

00:05:34.430 --> 00:05:37.680
For example,
mass storage or networking clients,

00:05:37.850 --> 00:05:42.200
the file system or the TCP/IP stack,
they are in the kernel.

00:05:42.280 --> 00:05:48.500
You have to be in the kernel,
and so you don't have a choice.

00:05:49.090 --> 00:05:55.470
Again, if you haven't gotten the message,
we really recommend that you write

00:05:55.470 --> 00:05:59.570
your drivers in the user space.

00:05:59.720 --> 00:06:02.250
They are a lot easier to debug.

00:06:02.440 --> 00:06:06.370
If you're in the kernel,
it's really easy to panic the machine,

00:06:06.370 --> 00:06:08.320
and users don't like that.

00:06:08.320 --> 00:06:13.890
So try to write user space drivers.

00:06:17.170 --> 00:06:21.760
Just like all other I/O Kit drivers,
USB drivers are written

00:06:21.760 --> 00:06:24.820
in the subset of C++.

00:06:24.830 --> 00:06:31.300
The base class of all
I/O Kit drivers is I/O service.

00:06:32.280 --> 00:06:37.010
When you write the driver in order
to load it against your device,

00:06:37.010 --> 00:06:42.000
you will need to provide a matching
dictionary so that we can load it.

00:06:42.140 --> 00:06:45.040
Later on,
we're going to show you on the demo

00:06:45.040 --> 00:06:50.170
machines the different fields that go
into a dictionary and how we decide on

00:06:50.200 --> 00:06:52.670
how to match it against your device.

00:06:53.730 --> 00:06:59.500
The driver itself that Project Builder
makes is a KEXT package that

00:07:00.030 --> 00:07:02.880
goes in the extensions folder.

00:07:02.880 --> 00:07:07.040
And as we mentioned earlier
in the previous presentation,

00:07:07.040 --> 00:07:12.580
the IO USB Family or your driver can
include sub-drivers in the one package.

00:07:16.950 --> 00:07:22.590
This slide just gives you
an overview of the different

00:07:24.560 --> 00:07:27.230
USB family objects
that are in the kernel,

00:07:27.280 --> 00:07:33.240
the I/O USB device, I/O USB interface,
and I/O USB pipe.

00:07:33.240 --> 00:07:36.780
I'm going to talk in more detail
about each after this slide.

00:07:37.040 --> 00:07:42.120
We also have two other

00:07:42.520 --> 00:07:47.220
The objects which are the
I/O USB device user client and

00:07:47.220 --> 00:07:50.100
I/O USB interface user clients.

00:07:50.100 --> 00:07:56.000
These are the user client objects
that are used to communicate between

00:07:56.410 --> 00:07:59.550
user space and our internal objects.

00:08:00.930 --> 00:08:10.010
When you plug in a USB device into a bus,
our family will create a

00:08:10.030 --> 00:08:15.060
I/O USB device object for that device.

00:08:15.070 --> 00:08:21.900
The provider of that device will
be the I/O USB controller class.

00:08:21.900 --> 00:08:27.640
The I/O USB device object
is an abstraction of the

00:08:27.640 --> 00:08:30.760
physical I/O USB device.

00:08:30.760 --> 00:08:40.140
This class provides methods for
accessing the device descriptor

00:08:40.350 --> 00:08:42.690
fields of the USB device.

00:08:42.900 --> 00:08:49.880
We also provide methods for getting the
configuration descriptor of the device

00:08:49.930 --> 00:08:51.900
and also for setting the configuration.

00:08:51.900 --> 00:08:55.930
configuration for that device.

00:08:56.220 --> 00:09:01.770
Once you set the
configuration for the device,

00:09:01.770 --> 00:09:08.470
that family will go ahead and
create I/O USB interface objects

00:09:08.600 --> 00:09:14.860
for all of the interfaces that are
in that particular configuration.

00:09:14.890 --> 00:09:20.920
The I/O USB device class will
be the provider for all these

00:09:20.920 --> 00:09:24.190
I/O USB interface objects.

00:09:25.370 --> 00:09:29.810
Again, there is going to be one
I/O USB interface object for

00:09:29.810 --> 00:09:41.740
each interface in the particular
configuration description of the device.

00:09:42.220 --> 00:09:49.100
The interface objects are an
abstraction of a USB interface.

00:09:49.100 --> 00:09:56.150
The methods that we provide for the
USB interface are those that allow you

00:09:56.150 --> 00:10:00.530
to access the fields of the interface
descriptor and also allow you to

00:10:00.530 --> 00:10:06.100
set alternate interfaces if they
are available for your interface.

00:10:06.160 --> 00:10:12.060
When we create the
I/O USB interface object,

00:10:12.100 --> 00:10:19.800
we will also instantiate
I/O USB pipe objects for each

00:10:20.050 --> 00:10:25.680
of the pipes in the interface.

00:10:25.720 --> 00:10:31.270
There will be one for the default
control endpoint and we'll also

00:10:31.270 --> 00:10:35.720
create however many objects.

00:10:35.720 --> 00:10:38.600
The I/O USB pipe objects are those
that are needed to match against

00:10:38.600 --> 00:10:44.710
all the other endpoints that are
specified in the interface descriptor.

00:10:44.720 --> 00:10:49.400
The methods that we provide for
the I/O USB pipe objects are

00:10:49.400 --> 00:10:54.480
those that are needed to actually
communicate with the device.

00:10:54.480 --> 00:10:58.560
So we have the read pipe,
we have the write pipe,

00:10:58.680 --> 00:11:05.280
we also provide methods
to get status on the pipe,

00:11:05.280 --> 00:11:07.560
to clear the... a possible
stall in the pipe,

00:11:07.640 --> 00:11:08.880
etc.

00:11:10.840 --> 00:11:15.840
The other two objects that we have,
as I mentioned before,

00:11:15.870 --> 00:11:21.640
are the IOUsbDeviceUserClient
and the IOUsbInterfaceUserClient.

00:11:21.640 --> 00:11:26.140
And these provide the
necessary glue for a user task,

00:11:26.140 --> 00:11:29.970
user driver,
to talk to the internal objects.

00:11:31.840 --> 00:11:39.170
You could tell whether you actually
have a user task attached to your

00:11:39.710 --> 00:11:45.770
device driver or your interface driver
by using the IOU Register Explorer,

00:11:46.260 --> 00:11:50.460
going down the tree to
find your driver node.

00:11:50.460 --> 00:11:56.820
And you can then see if there is actually
one of these user clients attached to it.

00:12:00.150 --> 00:12:04.940
The convention that we use in
our family for the Apple Supply

00:12:04.940 --> 00:12:06.990
drivers is the following.

00:12:07.300 --> 00:12:12.110
If the driver starts
with the I/O letters,

00:12:12.200 --> 00:12:18.820
we intend that you could subclass that
driver and add functionality just by

00:12:18.820 --> 00:12:24.300
defining new methods or overriding
some of the base class methods.

00:12:24.310 --> 00:12:28.980
If the driver starts with the word Apple,
that is ours and you're

00:12:28.980 --> 00:12:31.150
not allowed to subclass it.

00:12:31.330 --> 00:12:36.120
However,
if you have a vendor-specific device,

00:12:36.250 --> 00:12:43.470
you could just get our code adapted
to what your device does and use it

00:12:43.720 --> 00:12:47.010
that way and create your own driver.

00:12:47.700 --> 00:12:53.660
This is a list of the USB drivers
that we provide in the kernel.

00:12:53.800 --> 00:12:55.300
These are all the Apple ones.

00:12:55.350 --> 00:12:59.780
It's the standard mouse, keyboard,
hub driver.

00:12:59.780 --> 00:13:05.470
We provide, just like in Mac OS 9,
a composite class driver that will

00:13:06.090 --> 00:13:10.170
just look at that configuration,
find the first configuration,

00:13:10.240 --> 00:13:17.150
and do a set configuration on that device
to create the interfaces for that device.

00:13:19.940 --> 00:13:25.020
The two subclassable kernel drivers
that we provide are the HIT driver

00:13:25.460 --> 00:13:27.530
and the mass storage class driver.

00:13:27.540 --> 00:13:35.150
Again, the nice thing about living in the
kernel and being able to use these

00:13:35.170 --> 00:13:40.550
drivers is that if your device
just is a little different than

00:13:40.650 --> 00:13:46.870
one of the devices that we support,
you can just use C++ and override

00:13:47.090 --> 00:13:52.980
those methods that you need to change,
and you have a lot simpler

00:13:52.980 --> 00:13:57.380
driver than starting and
writing everything from scratch.

00:14:00.150 --> 00:14:03.760
Those of you who attended the
USB overview session yesterday probably

00:14:03.760 --> 00:14:05.380
will recognize the following two slides.

00:14:05.480 --> 00:14:09.960
We are including them here because
we think it's really important to

00:14:10.400 --> 00:14:18.300
understand how the driver stack of
the USB drivers is built up and in the

00:14:18.300 --> 00:14:20.680
next slide how it all fits together.

00:14:20.680 --> 00:14:30.860
So again, the IO PCI family will discover
the OHCI USB controller and it

00:14:31.040 --> 00:14:34.020
will load a driver for that device.

00:14:34.230 --> 00:14:38.010
That is our IO USB controller driver.

00:14:38.330 --> 00:14:41.540
During startup,
this controller driver will

00:14:41.620 --> 00:14:49.840
instantiate a I/O USB device for
the root hub of that controller.

00:14:50.010 --> 00:14:59.170
We use IOPKID methods to match a driver
against that device and we have the...

00:14:59.810 --> 00:15:08.600
The Hub driver sits there waiting
for devices to get plugged in.

00:15:08.600 --> 00:15:13.120
For example, if you suddenly plugged
in a pair of speakers,

00:15:13.120 --> 00:15:18.720
the Apple USB Hub driver will notice,
it will enumerate those speakers,

00:15:18.720 --> 00:15:25.710
and it will create an I/O USB device
and attach it to the I/O USB controller.

00:15:26.290 --> 00:15:31.260
In this case, for this example,
speakers are usually a

00:15:31.340 --> 00:15:33.840
composite class device.

00:15:33.870 --> 00:15:37.840
So the composite class
driver will go ahead and load

00:15:38.110 --> 00:15:40.780
against this I/O USB device.

00:15:40.910 --> 00:15:48.210
It will do a set configuration on it,
which as I mentioned earlier,

00:15:48.210 --> 00:15:49.430
will load the

00:15:50.600 --> 00:16:11.970
Create the I/O USB interfaces
for that device.

00:16:11.970 --> 00:16:11.970
In this case,
I'm only showing one of those interfaces.

00:16:11.970 --> 00:16:11.970
Again, we use the I/O Kit matching
code to ask for a driver to be

00:16:11.970 --> 00:16:11.970
matched against this interface,
and we have the Apple USB audio

00:16:11.970 --> 00:16:11.970
device driver loaded against it.

00:16:12.200 --> 00:16:15.440
So this is how this works.

00:16:15.440 --> 00:16:20.130
And any device that you plug in
will do the same thing and will

00:16:20.470 --> 00:16:25.930
try to find drivers for it and
instantiate them for your device

00:16:25.930 --> 00:16:29.050
as long as they're in the kernel.

00:16:30.940 --> 00:16:36.600
This driver is, oh sorry,
this slide is here to show a

00:16:36.600 --> 00:16:43.790
distinction between being a driver and

00:16:44.910 --> 00:16:50.260
The distinction that we want to
make is who your provider is and

00:16:50.320 --> 00:16:53.100
what member of which family you are.

00:16:53.160 --> 00:16:57.360
For example,
the Apple USB audio device is a

00:16:57.360 --> 00:17:00.940
member of the IEO audio device.

00:17:00.940 --> 00:17:04.930
This is the base class
from which they derive.

00:17:05.420 --> 00:17:10.610
They get their behavior, their API,
from the...

00:17:10.620 --> 00:17:13.460
IOU Audio Device Family.

00:17:13.460 --> 00:17:19.800
However, when they actually want to send
data to the pair of speakers,

00:17:19.800 --> 00:17:25.530
they use the IOU USB Family as the
transport mechanism to get that data

00:17:25.980 --> 00:17:28.430
from memory down to the speakers.

00:17:28.700 --> 00:17:30.970
So it's sort of a dual relationship.

00:17:31.100 --> 00:17:35.970
You are a member of the family,
but you are a client of

00:17:35.980 --> 00:17:40.580
the transport family,
which in this case is the IOU USB Family.

00:17:40.600 --> 00:17:46.140
But it could be another mechanism,
another family.

00:17:46.140 --> 00:17:48.770
If there were FireWire speakers,
you could have FireWire.

00:17:51.810 --> 00:17:55.260
In this example,
the Apple USB audio device

00:17:55.580 --> 00:18:01.540
is a leaf node driver,
so it is not intended to be subclassed.

00:18:01.680 --> 00:18:08.150
However, if we had a head driver
attached to an interface,

00:18:08.150 --> 00:18:11.860
like for the buttons of a speaker,
as you've seen in other slides,

00:18:12.010 --> 00:18:15.300
it has a little puzzle piece,
which means that you could

00:18:15.440 --> 00:18:22.090
subclass that driver and add
the functionality that you need.

00:18:24.640 --> 00:18:30.840
In Mac OS 9, we had a DDK that provided
some example drivers.

00:18:30.840 --> 00:18:36.780
Some of them, or most of them,
we used internally at some point,

00:18:36.820 --> 00:18:41.960
but they weren't the live sources
that we were using to release

00:18:41.960 --> 00:18:44.300
the USB stack on Mac OS 9.

00:18:44.520 --> 00:18:46.600
That has changed with Mac OS X.

00:18:46.600 --> 00:18:48.010
We are open sourced.

00:18:48.010 --> 00:18:50.160
We live in the Darwin repository.

00:18:50.280 --> 00:18:55.760
So our live IOSB family
sources are there.

00:18:55.760 --> 00:18:58.890
The module name is the IOSB family.

00:18:58.890 --> 00:19:00.790
No surprise there.

00:19:00.800 --> 00:19:06.380
If you haven't gone and become a
member of the open source project so

00:19:06.400 --> 00:19:12.020
that you can check out the sources,
you should go ahead and do it.

00:19:12.380 --> 00:19:12.970
Download it.

00:19:13.060 --> 00:19:14.500
Look at it.

00:19:14.500 --> 00:19:15.660
Look at the source.

00:19:15.660 --> 00:19:16.880
Look at the drivers.

00:19:16.880 --> 00:19:18.420
Borrow whatever you need.

00:19:18.420 --> 00:19:20.150
Tell us where we have the bugs.

00:19:20.180 --> 00:19:24.460
It would be nice if you said, you know,
line 23 of such and such a file.

00:19:24.460 --> 00:19:27.570
But it is there for you to look at.

00:19:27.570 --> 00:19:32.510
And we went through a lot of
effort to get this out into

00:19:32.560 --> 00:19:35.290
the open source community.

00:19:35.290 --> 00:19:40.600
So you are more than welcome
to go ahead and look at it.

00:19:42.320 --> 00:19:43.850
Okay.

00:19:43.940 --> 00:19:46.370
I/O USB family driver matching.

00:19:46.470 --> 00:19:49.740
If we cannot drive your driver,
if we cannot match your

00:19:49.740 --> 00:19:52.810
driver to your device,
then game over.

00:19:52.810 --> 00:19:54.290
Why have the driver?

00:19:54.300 --> 00:20:00.120
So it's very critical that we explain
it so that you can get it right.

00:20:00.120 --> 00:20:07.300
And the first item that you have
to decide is are you going to be,

00:20:07.430 --> 00:20:10.300
other than being in
kernel versus user space,

00:20:10.300 --> 00:20:13.300
but once you have decided
that you are a kernel driver,

00:20:13.300 --> 00:20:18.090
you need to decide whether
you're a device driver or whether

00:20:18.090 --> 00:20:20.310
you're a composite driver.

00:20:20.410 --> 00:20:23.500
You will specify in
your driver personality,

00:20:23.500 --> 00:20:26.430
and we'll show you a demo where
that goes in a little bit,

00:20:26.770 --> 00:20:33.160
whether you need to specify
the I/O provider class.

00:20:35.420 --> 00:20:42.900
Other I/O Kit drivers use the
I/O probe score inside the personality

00:20:43.030 --> 00:20:48.100
to give a hint to I/O Kit of
how important this driver is,

00:20:48.200 --> 00:20:50.560
what the ranking is.

00:20:50.960 --> 00:20:54.640
In the I/O USB family,
we do not use and you do not need

00:20:54.770 --> 00:20:58.290
to provide the I/O probe score.

00:20:58.380 --> 00:21:05.580
This is because USB and the USB specs
have a very definite set of criteria

00:21:06.140 --> 00:21:13.090
that spell out how multiple drivers are
ranked and which one has the highest

00:21:13.090 --> 00:21:18.620
rank and which one has the lowest rank,
so that if we find n drivers,

00:21:18.620 --> 00:21:22.530
we can rank them and we can tell I/O Kit,
"Okay, try this."

00:21:24.100 --> 00:21:40.100
[Transcript missing]

00:21:40.130 --> 00:21:44.160
and I/O Kit will load that
driver first and give it a first

00:21:44.190 --> 00:21:47.540
shot at controlling that device.

00:21:47.660 --> 00:21:50.850
So again,
the USB Common Class Specification

00:21:51.580 --> 00:21:57.480
is the document that details exactly
what fields you need to have in your

00:21:57.480 --> 00:22:04.540
personality to match against drivers.

00:22:04.820 --> 00:22:09.590
Just by chance,
here I have a copy of the table

00:22:09.660 --> 00:22:18.620
that is used by the common class
spec to specify device as opposed

00:22:18.750 --> 00:22:20.680
to interface driver rankings.

00:22:20.680 --> 00:22:26.400
All the fields in the boxes are
fields of the USB device descriptor.

00:22:27.170 --> 00:22:30.220
At the top level,
with the highest possible

00:22:30.530 --> 00:22:36.170
rank that a driver can have,
is a driver that specifies the product,

00:22:36.250 --> 00:22:40.420
the vendor, and the,
it's called BCD device,

00:22:40.420 --> 00:22:43.110
but it's the release
number of the device.

00:22:43.200 --> 00:22:47.290
One step lower,
we have the vendor and the product that

00:22:47.420 --> 00:22:52.880
will just match against all drivers
of that vendor and product ID without

00:22:53.190 --> 00:22:55.980
caring about that release number.

00:22:57.550 --> 00:23:04.590
Down in the orange boxes we have
what we call the class drivers.

00:23:04.600 --> 00:23:14.990
These are classes that are not vendor
specific and that is what the 0xff means.

00:23:15.210 --> 00:23:20.600
You can match against the class,
the subclass,

00:23:20.910 --> 00:23:25.890
and the protocol in the next to
last item or just device subclass.

00:23:26.230 --> 00:23:33.300
So as we're going to show you,
you're going to specify these and this

00:23:33.450 --> 00:23:43.800
is what the USB Family uses to generate
a probe score for I/O Kit to decide which

00:23:43.800 --> 00:23:44.190
driver is the highest ranked driver.

00:23:47.570 --> 00:23:52.700
As was mentioned in
the overview yesterday,

00:23:52.700 --> 00:23:57.680
once I/O Kit has a list of
drivers that match to a device,

00:23:57.680 --> 00:24:01.810
it will give each driver a shot
at denying whether they want to

00:24:01.890 --> 00:24:08.290
control that device or not by calling
the probe method of that driver.

00:24:09.140 --> 00:24:15.090
The default implementation for probe
method is to just return success,

00:24:15.100 --> 00:24:19.580
so you don't even need to implement it,
but it is just here to give you a

00:24:19.580 --> 00:24:22.840
shot at denying control of the device.

00:24:24.480 --> 00:24:26.630
Later on,
you'll still get another shot at

00:24:26.630 --> 00:24:28.530
denying control of that device.

00:24:29.130 --> 00:24:34.710
Once the ordered list of drivers with
the higher one at the top and the lowest

00:24:34.720 --> 00:24:40.240
ranking one at the bottom is created,
I/O Kit will call the start method

00:24:40.240 --> 00:24:44.200
for the highest ranked driver first.

00:24:44.880 --> 00:24:47.620
This tells you that your
driver is really starting.

00:24:47.620 --> 00:24:51.880
You can do all your stuff that
you need to do to get your

00:24:51.880 --> 00:24:54.660
driver in working condition.

00:24:54.660 --> 00:24:58.960
If you return false from this method,
then I/O Kit will go, okay, well,

00:24:58.960 --> 00:25:00.150
he didn't want it.

00:25:00.150 --> 00:25:02.430
Let's try the next one in the list.

00:25:02.480 --> 00:25:10.410
So you get this second shot at it,
but now I'm going to show you, or here,

00:25:10.440 --> 00:25:13.950
Rhoads is going to help me out.

00:25:14.500 --> 00:25:19.500
If we could have demo one
machine on the slides.

00:25:19.500 --> 00:25:24.570
I'm going to show you how to
specify the matching dictionary.

00:25:24.580 --> 00:25:28.250
So we have the project builder.

00:25:28.480 --> 00:25:32.260
This is a sample vendor
specific driver that we wrote.

00:25:32.440 --> 00:25:39.850
And this pane that we see up
there is the bundle settings tab

00:25:40.130 --> 00:25:43.750
of the project builder target.

00:25:43.800 --> 00:25:51.170
In there we have an
I/O Kit personality dictionary entry.

00:25:51.240 --> 00:25:57.490
This is where the matching criteria,
among other things, is going to live.

00:25:57.840 --> 00:26:04.990
The first item that I'm going to talk
about here is the CFBundle identifier.

00:26:05.350 --> 00:26:09.970
This string needs to match the
CFBundle identifier that is

00:26:10.070 --> 00:26:12.240
declared in the upper level.

00:26:12.240 --> 00:26:15.420
The best way to do it is
just to copy and paste.

00:26:15.480 --> 00:26:19.790
Because if it doesn't match,
your driver won't get loaded.

00:26:21.160 --> 00:26:24.670
The next field is the I/O class field.

00:26:25.040 --> 00:26:30.820
This is the class of the driver that

00:26:30.910 --> 00:26:32.440
That you're going to use.

00:26:32.510 --> 00:26:36.100
So here we have the
header file where the C++,

00:26:36.120 --> 00:26:41.490
my software vendor,
my software company class is defined.

00:26:41.610 --> 00:26:45.580
That is what you need
to put in that entry.

00:26:45.780 --> 00:26:49.420
Next,
you need to tell us whether you are a

00:26:49.500 --> 00:26:52.660
device driver or an interface driver.

00:26:52.660 --> 00:26:58.430
And so you specify I/O USB device
or I/O USB interface.

00:26:58.480 --> 00:27:03.640
In this case,
we have a vendor-specific device driver,

00:27:03.730 --> 00:27:06.050
so we have I/O USB device.

00:27:06.340 --> 00:27:11.810
Now, we don't have here,
but Rhoaads is going to type in.

00:27:11.810 --> 00:27:17.500
We decided to make this a
vendor-specific device driver,

00:27:17.500 --> 00:27:23.820
and we're going to type in the
common class spec fields that

00:27:23.820 --> 00:27:27.740
are required for that device.

00:27:27.740 --> 00:27:35.980
And it is the ID product, it's a number,
and the ID vendor, and it's a number.

00:27:35.980 --> 00:27:43.230
Those numbers correspond to the,
obviously, the product and device fields

00:27:43.300 --> 00:27:47.470
of the device descriptor.

00:27:48.330 --> 00:27:54.590
Finally, we have this I/O Kit debug
dictionary entry.

00:27:54.690 --> 00:27:59.470
This is used internally within
I/O Kit to put debugging

00:27:59.470 --> 00:28:04.320
information out to the console,
to the system log.

00:28:04.450 --> 00:28:10.950
It helps some in debugging
why your driver doesn't load

00:28:11.270 --> 00:28:12.960
from an I/O Kit perspective.

00:28:12.960 --> 00:28:16.320
However, right now it just says
that matching failed.

00:28:16.360 --> 00:28:22.110
It is also used internally within
I/O Kit for other features.

00:28:22.160 --> 00:28:26.390
It is actually a bit field
of different features,

00:28:26.390 --> 00:28:32.110
but if you put 65, 535 in it,
it will match to all the features

00:28:32.170 --> 00:28:34.270
and it will put out a lot of data.

00:28:34.400 --> 00:28:35.630
Amen.

00:28:35.980 --> 00:28:41.520
We do realize that right now it is
very frustrating to determine why your

00:28:42.340 --> 00:28:47.700
seemingly good driver is not loading
against your device when you plug it in.

00:28:47.740 --> 00:28:53.980
We are very aware of this and it's
not going to stay like that for long.

00:28:54.960 --> 00:28:59.850
We will use the I/O Kit debug field
to actually put some meaningful

00:28:59.850 --> 00:29:07.630
information out to the system log to
give you an idea of what was going on

00:29:07.770 --> 00:29:09.340
when we tried to match your driver.

00:29:09.340 --> 00:29:14.290
The final two...

00:29:15.300 --> 00:29:22.970
Two entries in the bundle settings
tab here are the OS bundle libraries.

00:29:23.120 --> 00:29:25.100
This is a dependency entry.

00:29:25.520 --> 00:29:32.780
It tells I/O Kit that this driver
is dependent on the com.apple

00:29:33.640 --> 00:29:39.130
I/O Kit.iousbfamily version 1.8.

00:29:39.280 --> 00:29:43.910
If you were depending in the
future against an API that was

00:29:44.000 --> 00:29:50.820
introduced in version 1.8.7,
you would put here 1.8.7 and

00:29:50.820 --> 00:29:59.590
I/O Kit wouldn't even load you if the
iOSB Family version 1.8.7 was not around.

00:29:59.980 --> 00:30:04.310
So that way you don't have to
do runtime checks whether a

00:30:04.330 --> 00:30:10.610
particular API is available
like you used to do in Mac OS 9.

00:30:11.910 --> 00:30:17.550
The final property is the
OS Bundle required property.

00:30:18.260 --> 00:30:27.590
There is a driver matching that goes on
very early on during the boot process.

00:30:27.640 --> 00:30:33.570
This property tells IOCAD which
drivers need to participate

00:30:33.680 --> 00:30:35.740
in this early driver matching.

00:30:35.970 --> 00:30:39.560
For example,
our mouse and our keyboard drivers

00:30:39.570 --> 00:30:43.270
have this property because you,
as I mentioned earlier,

00:30:43.380 --> 00:30:46.700
need the keyboard to go
into single user mode.

00:30:47.000 --> 00:30:50.180
The reason I mention it here
is because if you are writing a

00:30:50.180 --> 00:30:55.600
vendor-specific keyboard or mouse driver,

00:30:55.710 --> 00:31:00.640
And you want to override
our USB class driver,

00:31:01.120 --> 00:31:04.050
you need to also put that property there.

00:31:04.060 --> 00:31:06.310
If not,
what's going to happen is the early

00:31:06.310 --> 00:31:10.900
on driver matching during boot
time will load our class driver.

00:31:10.900 --> 00:31:16.430
And then when I/O Kit, well,
I/O Kit then won't even scan your

00:31:16.770 --> 00:31:21.560
keyboard or your mouse for a driver
because it already has one loaded.

00:31:22.880 --> 00:31:27.360
So you need to specify that
if that is what you are doing.

00:31:27.360 --> 00:31:30.340
If we could go to the slides now again.

00:31:36.360 --> 00:31:42.770
This slide shows you which
I/O Kit methods are called during

00:31:42.770 --> 00:31:46.090
the two-step driver loading process.

00:31:46.160 --> 00:31:52.370
The first step is when I/O Kit is
looking for drivers for a device.

00:31:52.500 --> 00:31:56.840
As I mentioned earlier,
the probe method is here,

00:31:56.840 --> 00:32:03.350
which gives you a chance
to deny your matching.

00:32:03.960 --> 00:32:06.910
You get the init, the attach,
the probe method,

00:32:07.030 --> 00:32:08.860
and then you get detached again.

00:32:08.930 --> 00:32:11.020
Once I/O Kit decided
that you are the one,

00:32:11.020 --> 00:32:16.290
that you are the driver who is
going to control that device,

00:32:16.540 --> 00:32:22.640
You get an attach method again and
then you'll get the start method.

00:32:22.760 --> 00:32:26.800
The thing to take out of this
slide is that your attach method

00:32:26.890 --> 00:32:30.600
will get called more than once,
so you have to be

00:32:30.600 --> 00:32:33.550
prepared to deal with it.

00:32:33.840 --> 00:32:39.230
When your device gets disconnected,
we get the following

00:32:39.350 --> 00:32:41.560
termination sequence.

00:32:41.560 --> 00:32:47.740
You first get a message method with
the KIO services terminated message.

00:32:47.740 --> 00:32:51.880
This is your clue that your
provider is going to go away.

00:32:51.880 --> 00:32:55.800
You need to cease and desist
all I/O to your device.

00:32:55.800 --> 00:32:58.970
You need to stop everything,
return from it,

00:32:58.970 --> 00:33:03.010
then you'll get a terminate
message followed by the other,

00:33:03.010 --> 00:33:06.730
sorry, a terminate method call
followed by all the other ones

00:33:06.730 --> 00:33:11.100
that I list here in the slide.

00:33:11.100 --> 00:33:14.480
The key there is the first
notice that you get that your

00:33:14.480 --> 00:33:22.040
device has been unplugged is
this services terminated message.

00:33:22.060 --> 00:33:25.710
If you had your provider open
your device or your interface,

00:33:26.050 --> 00:33:28.960
you need to close it at that time.

00:33:29.170 --> 00:33:32.510
Now if we could go back
to the demo machines,

00:33:32.550 --> 00:33:38.100
we have a vendor specific driver
that is a very dummy driver.

00:33:38.160 --> 00:33:44.410
All it does is it spits out IO logs,
which by the way an IO log will print

00:33:44.550 --> 00:33:51.230
a message in the system console every
time that the message is called.

00:33:51.310 --> 00:33:52.980
Fernando Urbinan,
Rhoaads Hollowell And this is just

00:33:52.980 --> 00:33:58.530
to prove you that it's not smoke and
mirrors and we are actually calling all

00:33:58.530 --> 00:34:02.350
those methods in the order that we said.

00:34:02.580 --> 00:34:08.400
So here we have a security dongle
and Rhoaads here is going to load

00:34:08.490 --> 00:34:14.680
the driver so that it's available
for when we plug in the device.

00:34:14.760 --> 00:34:17.670
Fernando Urbinan,
Rhoaads Hollowell He'll then open or do

00:34:17.670 --> 00:34:21.280
a tail on the console log so that it's
available for when we plug in the device.

00:34:21.280 --> 00:34:22.860
Fernando Urbinan,
Rhoaads Hollowell So that we see

00:34:22.970 --> 00:34:26.980
any messages that get displayed when
we go ahead and plug the device.

00:34:26.980 --> 00:34:30.980
Fernando Urbinan,
Rhoaads Hollowell And it crashes, no.

00:34:36.610 --> 00:34:38.740
There we go.

00:34:38.830 --> 00:34:41.500
We get the init method
followed by the attach,

00:34:41.560 --> 00:34:45.250
the probe, the detach,
and again the attach method

00:34:45.690 --> 00:34:49.630
and finally the start and we
successfully start and there we go.

00:34:49.640 --> 00:34:54.310
Now when we disconnect the device,
we unplug it, boom,

00:34:54.400 --> 00:35:00.350
we get all the other methods and
your driver after a minute or so will

00:35:00.640 --> 00:35:03.900
actually get unloaded from memory.

00:35:04.600 --> 00:35:10.100
So now I'll give keyspan to
Rhoaads and he'll tell you

00:35:10.100 --> 00:35:12.530
more about user space drivers.

00:35:12.610 --> 00:35:15.970
Alright,
we need to go back to the slides please.

00:35:25.000 --> 00:39:20.200
[Transcript missing]

00:39:20.660 --> 00:39:26.740
There is also a user client object
and a device interface or an interface

00:39:26.770 --> 00:39:32.160
object used to communicate with an
IOU USB interface object in the kernel.

00:39:32.160 --> 00:39:38.120
Unfortunately,
there is some confusion because the

00:39:38.120 --> 00:39:46.090
generic name of these objects in user
space are device interface objects.

00:39:46.740 --> 00:39:52.800
The term "USB" is used in the
USB world because of the use of device

00:39:52.800 --> 00:39:56.740
descriptors and interface descriptors.

00:39:56.780 --> 00:40:05.050
So what we really have with USB is
IOU USB device-device interfaces and

00:40:05.050 --> 00:40:07.980
IOU USB interface-device interfaces.

00:40:07.980 --> 00:40:12.340
Which of course is difficult to say,
much less fit on a PowerPoint slide.

00:40:12.340 --> 00:40:16.700
So we have shortened that to be
device interface and interface object.

00:40:16.740 --> 00:40:19.440
and an interface interface.

00:40:20.540 --> 00:40:22.920
So,
what do you need to do if you're going to

00:40:22.920 --> 00:40:25.480
write your USB driver code in user space?

00:40:25.480 --> 00:40:29.580
Well, you need to use two
frameworks in particular.

00:40:29.580 --> 00:40:34.630
The core foundation framework,
which gets you access to things

00:40:34.770 --> 00:40:37.560
like CFPlugins and CF run loops.

00:40:37.660 --> 00:40:42.580
And the I/O Kit framework,
which gets you access to

00:40:42.580 --> 00:40:47.640
the I/O Kit functions as
well as the USB functions,

00:40:47.640 --> 00:40:51.630
which are part of the I/O Kit framework.

00:40:51.910 --> 00:40:57.030
This mechanism uses, as I've said before,
the CF plug-in model and the two

00:40:57.030 --> 00:41:02.380
plug-ins provided by USB are the
IOUsb device interface plug-in and

00:41:02.540 --> 00:41:05.340
the IOUsb interface interface plug-in.

00:41:05.360 --> 00:41:11.080
We do not provide an interface
plug-in for the IOUsb pipe object.

00:41:11.080 --> 00:41:17.600
This is encapsulated within the
plug-in for the interface mostly,

00:41:17.600 --> 00:41:22.360
although there is one pipe in the device,
which is the default control pipe.

00:41:22.400 --> 00:41:25.590
But the other pipes are
all part of the interface.

00:41:25.590 --> 00:41:28.880
In the kernel,
those pipe objects are instantiated

00:41:28.880 --> 00:41:31.030
when the interface is opened.

00:41:31.040 --> 00:41:35.310
And then you have access to methods
within the interface interface.

00:41:35.360 --> 00:41:38.740
And then you have access to methods
within the interface interface plug-in

00:41:38.870 --> 00:41:42.910
to determine the characteristics of
a pipe and to then send and receive

00:41:42.910 --> 00:41:45.580
data over any of the given pipes.

00:41:47.640 --> 00:41:54.500
The I/O Kit API is in, as I've said,
in the I/O Kit framework and it's in,

00:41:54.500 --> 00:41:58.330
much of it is in the I/O Kit lib.h file.

00:41:58.340 --> 00:42:03.010
The plugin API that we use is
also in the I/O Kit framework

00:42:03.440 --> 00:42:06.180
and it is in IOCF plugin.h.

00:42:06.180 --> 00:42:12.680
And then finally the USB interface
API is in the I/O Kit framework in the

00:42:12.860 --> 00:42:17.070
USB subfolder and it's in Iousblib.h.

00:42:17.630 --> 00:42:23.040
Again, the two interfaces we provide
for USB drivers are the Iousb

00:42:23.050 --> 00:42:28.710
device interface and the
Iousb interface interface.

00:42:29.900 --> 00:42:33.620
So, if you're running in user space,
you need to communicate

00:42:33.740 --> 00:42:36.870
with a kernel object,
either an I/O USB device object

00:42:36.960 --> 00:42:39.510
or an I/O USB interface object.

00:42:39.610 --> 00:42:41.010
So how do you do that?

00:42:41.040 --> 00:42:45.130
Well, the first step is to find
the correct kernel object.

00:42:45.450 --> 00:42:51.470
These procedures, by the way,
are outlined in a document available from

00:42:51.470 --> 00:42:58.270
the website called Accessing Hardware

00:42:58.480 --> 00:43:01.700
From applications or
something along those lines.

00:43:01.840 --> 00:43:03.750
So what are the steps involved?

00:43:03.750 --> 00:43:08.420
Well, first you have to, from user space,
you have to obtain a Mach port that

00:43:08.630 --> 00:43:11.220
you use to communicate with the kernel.

00:43:11.220 --> 00:43:15.600
Then you have to create a matching
dictionary that's very similar to

00:43:15.600 --> 00:43:20.080
the matching dictionary we showed
in the demo of the personality.

00:43:20.970 --> 00:43:24.440
And the same rules apply to
this matching dictionary.

00:43:24.450 --> 00:43:28.940
You must fill in fields from either
the device descriptor or the interface

00:43:28.940 --> 00:43:35.490
descriptor based on whether your driver
is looking to be a class type driver

00:43:35.490 --> 00:43:38.200
or a vendor specific type driver.

00:43:38.330 --> 00:43:41.140
So you add these fields by
adding qualifications to

00:43:41.140 --> 00:43:44.460
this matching dictionary,
and then you ask I/O Kit to give you

00:43:44.460 --> 00:43:51.310
a kernel iterator of kernel objects
that match your particular dictionary.

00:43:52.310 --> 00:43:54.410
So how do we obtain the master port?

00:43:54.510 --> 00:44:01.990
Well, the API is defined in Mac.h and
it's just a call to IOMasterPort.

00:44:01.990 --> 00:44:04.260
When you're done,
you should deallocate that port to

00:44:04.280 --> 00:44:05.870
tell I/O Kit you're done using it.

00:44:05.880 --> 00:44:08.660
So how do I create the
matching dictionary?

00:44:08.660 --> 00:44:11.560
Well,
it depends on whether you're looking for

00:44:11.560 --> 00:44:14.170
an IOUsb device or an IOUsb interface.

00:44:14.600 --> 00:44:18.400
In the device case,
you ask for an IOService matching

00:44:18.400 --> 00:44:21.320
dictionary with the device class name.

00:44:21.320 --> 00:44:25.140
If you're looking for an interface,
you ask for the dictionary

00:44:25.240 --> 00:44:27.070
with the interface class name.

00:44:27.820 --> 00:44:30.840
Then you add qualifications
to the matching dictionary.

00:44:30.900 --> 00:44:32.900
Again, these are the qualifications.

00:44:32.900 --> 00:44:34.440
We showed a table earlier.

00:44:34.550 --> 00:44:39.920
They are from the section 3.10 of
the USB Common Class specification.

00:44:39.920 --> 00:44:44.060
And in the current shipping
version of the I/O USB Family,

00:44:44.060 --> 00:44:50.800
the one in 10.03 and in
10.02 and 10.01 and 10.0,

00:44:50.900 --> 00:44:53.020
we're very strict with
this matching dictionary.

00:44:53.020 --> 00:44:56.540
What that means is that
if you want to match,

00:44:56.540 --> 00:45:01.340
say, the second line,
which was ID vendor and ID product,

00:45:01.410 --> 00:45:05.360
you must include both of those
fields in your matching dictionary.

00:45:05.360 --> 00:45:10.350
And you may not include any additional
fields in your matching dictionary,

00:45:10.350 --> 00:45:13.610
such as the device class
or the device subclass,

00:45:13.620 --> 00:45:17.100
or else your matching
dictionary will fail.

00:45:17.200 --> 00:45:22.100
So, and you also need to be aware when
creating these matching dictionaries

00:45:22.190 --> 00:45:27.030
of the different rules in this section
of the common class specification

00:45:27.400 --> 00:45:33.900
for matching against I/O USB device
objects and I/O USB interface objects.

00:45:34.570 --> 00:45:37.530
Once you've added the qualifications
to your matching dictionary,

00:45:37.530 --> 00:45:43.440
the next step is to get a list
of services within the kernel.

00:45:43.440 --> 00:45:47.420
These are the kernel objects that
are subclasses of I/O service,

00:45:47.440 --> 00:45:52.960
like every kernel object,
I/O Kit kernel object is.

00:45:53.050 --> 00:45:57.620
And I/O Kit will return to you an
iterator of all of these services.

00:45:57.740 --> 00:46:01.890
You then can access these
services one at a time.

00:46:02.140 --> 00:46:07.920
to determine if it is in fact the
object that you wish to control.

00:46:08.270 --> 00:46:14.900
So to use this I/O service T that
I/O gives you back through this iterator,

00:46:14.900 --> 00:46:20.880
you then can call I/O create
plugin interface for service.

00:46:20.880 --> 00:46:24.760
This is the call that
instantiates the pair of objects,

00:46:24.840 --> 00:46:29.440
the device interface or interface
interface on the user side with the

00:46:29.440 --> 00:46:33.960
device user client or the interface
user client on the kernel side.

00:46:33.960 --> 00:46:38.570
This call creates those two objects,
sets up that communication channel and

00:46:38.570 --> 00:46:44.350
allows you to then communicate with the
object that you want to communicate with.

00:46:44.780 --> 00:46:49.870
So if you were creating a user client,
if you were looking for a user

00:46:49.940 --> 00:46:55.310
client for the USB device object,
you would use the first call here with

00:46:55.310 --> 00:46:58.260
KIOUSB device user client type ID.

00:46:58.260 --> 00:47:02.050
And if you were interested
in the interface instead,

00:47:02.110 --> 00:47:05.920
you would do KIOUSB interface
user client type ID.

00:47:05.920 --> 00:47:12.240
These big long constant names,
by the way, are defined in IOUSBLib.h.

00:47:14.010 --> 00:47:20.870
Once you have this IOCF plugin interface,
this is actually a very small interface

00:47:20.900 --> 00:47:26.020
that does not quite yet represent the
device or interface you're looking for.

00:47:26.020 --> 00:47:31.000
You have to then call a function called
query interface to say I'm looking

00:47:31.080 --> 00:47:35.450
for this particular type of interface,
whether it's the device interface

00:47:35.500 --> 00:47:36.980
or the interface interface.

00:47:40.350 --> 00:47:42.940
Now let's say I have an
I/O USB device interface.

00:47:43.070 --> 00:47:44.000
What can I do with it?

00:47:44.130 --> 00:47:49.500
Well, this would be pieces of a
standard initialization sequence.

00:47:49.500 --> 00:47:51.460
You would open the device.

00:47:51.540 --> 00:47:54.230
You would then get a
pointer to the configuration

00:47:54.370 --> 00:47:56.210
descriptors for this device.

00:47:56.330 --> 00:48:00.630
You might then find the configuration
value out of one of those configuration

00:48:00.630 --> 00:48:03.300
descriptors and call set configuration.

00:48:03.300 --> 00:48:06.230
And then once you've
called set configuration,

00:48:06.230 --> 00:48:10.660
you would be interested mostly in
looking at the different interfaces

00:48:10.660 --> 00:48:13.300
that have now appeared on this device.

00:48:13.300 --> 00:48:16.300
So you would create
an interface iterator.

00:48:16.300 --> 00:48:20.320
And this would in turn return to
you I/O service T tokens for the

00:48:20.320 --> 00:48:24.540
various interfaces attached to
this device and you could create

00:48:24.540 --> 00:48:30.300
interface interfaces for each of them
to find the one you're looking for.

00:48:30.400 --> 00:48:33.240
When you're done, of course,
you should close that USB device.

00:48:33.300 --> 00:48:36.290
and release the interface.

00:48:37.620 --> 00:48:41.550
So, now that I have an
I/O USB interface interface,

00:48:41.630 --> 00:48:43.090
what might I do with it?

00:48:43.250 --> 00:48:47.430
Well, you would call USB interface
open to obtain exclusive

00:48:47.530 --> 00:48:49.500
access to this interface.

00:48:49.500 --> 00:48:54.170
You could then find out how many
endpoints this interface has in it.

00:48:54.350 --> 00:48:58.500
You might choose an alternate interface
if you know that there is one.

00:48:58.500 --> 00:49:02.490
You might get the properties of
each of the pipes in this interface.

00:49:02.490 --> 00:49:07.090
You could then call read pipe
and write pipe to read and write

00:49:07.090 --> 00:49:11.090
data across this pipe to the
endpoint you're interested in.

00:49:11.200 --> 00:49:14.820
And when you're done,
you would close the interface,

00:49:14.930 --> 00:49:20.120
close the I/O USB interface,
and then release the interface interface.

00:49:21.530 --> 00:49:25.560
How do you do asynchronous I/O?

00:49:25.560 --> 00:49:28.850
From user space,
you don't need to be careful about doing

00:49:28.950 --> 00:49:31.880
synchronous I/O versus asynchronous I/O.

00:49:31.960 --> 00:49:38.360
Because the user space threads are
never running on the work loop,

00:49:38.360 --> 00:49:42.060
it's okay to do synchronous
I/O all the time.

00:49:42.160 --> 00:49:44.850
If, however,
you want to do asynchronous I/O,

00:49:45.020 --> 00:49:48.300
then you need to take your interface,
whether it's the device interface

00:49:48.300 --> 00:49:52.800
or the interface interface,
and create an async event source and add

00:49:52.800 --> 00:49:56.440
that event source to your CF run loop.

00:49:56.440 --> 00:50:01.330
And documentation for CF run
loop is in CF run loop dot h.

00:50:01.430 --> 00:50:06.590
And you would then call CF run
loop run and your event source

00:50:06.590 --> 00:50:12.020
and possibly more than one event
source would then get processed.

00:50:12.080 --> 00:50:16.350
By that CF run loop,
calling back the callback routines

00:50:16.350 --> 00:50:18.740
for your asynchronous calls.

00:50:19.680 --> 00:50:24.390
Again,
the USB specific header file in the

00:50:24.390 --> 00:50:28.600
I/O Kit framework is listed above.

00:50:28.900 --> 00:50:33.640
As I said,
it's in the I/O Kit framework and it

00:50:33.640 --> 00:50:39.050
provides the API for both the device
interface and the interface interface.

00:50:39.700 --> 00:52:16.700
[Transcript missing]

00:52:16.880 --> 00:52:20.260
Okay, now we're going to switch to the
demo machines and we're going

00:52:20.380 --> 00:52:27.240
to do a little bit of debugging,
a little bit of a demo on how to debug.

00:52:27.240 --> 00:52:33.210
We're going to show you first how
easy it is to debug a user mode

00:52:33.210 --> 00:52:38.250
driver or application and then we're
going to actually attempt to do

00:52:38.250 --> 00:52:45.720
a two machine debugging for kernel
mode driver using both machines.

00:52:46.300 --> 00:52:48.040
Do you have a breakpoint?

00:52:48.040 --> 00:52:49.540
No, no breakpoints.

00:52:49.570 --> 00:52:52.680
Okay, so here is my user space driver.

00:52:52.680 --> 00:52:56.180
It's actually just
written as a Unix tool.

00:52:56.240 --> 00:52:59.040
So of course it has the main routine.

00:52:59.090 --> 00:53:03.250
And what I'm going to do here is
I'm going to go ahead and just

00:53:03.550 --> 00:53:08.760
put a breakpoint right there.

00:53:08.760 --> 00:53:12.200
Is it built?

00:53:12.200 --> 00:53:13.750
Go ahead and build it.

00:53:13.790 --> 00:53:18.640
I'm going to go ahead and rebuild the
driver just to make sure that it's built.

00:53:23.580 --> 00:53:28.940
And then I'm going to hit the debug
can to show you that here I am.

00:53:28.960 --> 00:53:30.600
I'm at this line of code.

00:53:30.600 --> 00:53:32.090
I'm creating my master port.

00:53:32.170 --> 00:53:34.140
I have all my arguments up here.

00:53:34.140 --> 00:53:38.790
This is the project builder interface to
GDB for those of you who haven't seen it.

00:53:38.840 --> 00:53:40.620
So I create my master port.

00:53:40.690 --> 00:53:44.470
I create my,
let me scroll this up a little bit.

00:53:44.470 --> 00:53:47.360
I create the matching dictionary.

00:53:47.370 --> 00:53:50.940
I'm saying I'm looking
for an IOSB device.

00:53:50.940 --> 00:53:53.320
I'm going to go ahead
and plug the device in.

00:53:53.500 --> 00:53:54.530
Well,

00:53:59.700 --> 00:54:05.580
Let's see, I need to-- I can actually
see-- where is it?

00:54:08.840 --> 00:54:12.230
I can actually show you the console,
the GDB console and the printout

00:54:12.230 --> 00:54:15.560
statements that we stick in here,
you know, appear on that console.

00:54:15.690 --> 00:54:17.870
So I create the matching dictionary.

00:54:17.910 --> 00:54:23.960
I add the property for the
vendor name and the product name,

00:54:23.960 --> 00:54:27.220
which are really the
vendor ID and product ID.

00:54:27.220 --> 00:54:31.910
Someone has filed a bug with
us that those are terrible

00:54:31.910 --> 00:54:34.580
constant names and I agree.

00:54:34.580 --> 00:54:40.930
I create a notification for this
particular type of device and

00:54:40.930 --> 00:54:45.530
at this point I think I actually
will have been notified about it

00:54:45.530 --> 00:54:47.380
because I've already plugged it in.

00:54:47.410 --> 00:54:54.810
So what I'm going to do is I'm going to
go into my notification routine and...

00:55:00.000 --> 00:55:06.270
I'm going to set a break point at the
call to create the plug-in interface.

00:55:07.460 --> 00:55:10.240
And I'm going to continue.

00:55:10.250 --> 00:55:10.960
OK.

00:55:11.120 --> 00:55:14.540
So now I'm at the Create Plugin
Interface for Service.

00:55:14.560 --> 00:55:18.980
And I'm going to go ahead and
bring up the IO Registry Explorer.

00:55:37.720 --> 00:55:39.650
So this is the device I just plugged in.

00:55:39.690 --> 00:55:41.300
It's called USB Token.

00:55:41.300 --> 00:55:48.350
That's the name string
that's inside the device.

00:55:48.710 --> 00:55:52.590
What we can see here is that there is no
user client attached to this device yet.

00:55:52.700 --> 00:55:58.080
This user client init object is used
to tell I/O Kit which object to create

00:55:58.440 --> 00:56:01.600
when someone asks for a user client.

00:56:01.600 --> 00:56:06.110
So now if I go back to my debug
statement here and create the

00:56:06.230 --> 00:56:08.600
plugin interface for service.

00:56:08.730 --> 00:56:15.590
Now if I go back to I/O... Well,
it should have created it.

00:56:15.590 --> 00:56:18.600
Hold on.

00:56:18.600 --> 00:56:20.600
Oh, I need to do the query interface.

00:56:20.600 --> 00:56:23.600
That's got to be what it is.

00:56:23.600 --> 00:56:29.490
Well, looks like I/O registry is not...

00:56:36.970 --> 00:56:38.840
Okay, there's the device user client.

00:56:38.840 --> 00:56:41.060
I don't know why this version
of IO registry is not updating,

00:56:41.060 --> 00:56:46.380
but there's the IO device user client,
which is the kernel side object

00:56:46.440 --> 00:56:51.230
of the device interface pair,
so that I now have a user mode

00:56:51.230 --> 00:56:56.030
application communicating with
this IO USB device object.

00:56:56.460 --> 00:57:02.030
So then what I will do is
I will call get the vendor,

00:57:02.420 --> 00:57:07.640
get the product,
and get the release number.

00:57:07.640 --> 00:57:11.380
We can see that the vendor,
if I look in my variables here,

00:57:11.380 --> 00:57:14.970
the vendor is 1209,
which is what I expected,

00:57:14.970 --> 00:57:19.220
and the product is 768,
which is also what I expected.

00:57:19.220 --> 00:57:22.550
I do a little test to make
sure it's what I expected,

00:57:22.730 --> 00:57:23.510
and it is.

00:57:23.560 --> 00:57:26.200
And so I open this device
using the USB drive.

00:57:26.470 --> 00:57:28.430
I'm going to do a quick
device open function.

00:57:28.500 --> 00:57:32.000
Then I'm going to configure this device.

00:57:32.060 --> 00:57:36.350
And so I'm going to first determine
how many configurations there are,

00:57:36.450 --> 00:57:39.680
and I can see that
there's one configuration.

00:57:39.740 --> 00:57:43.630
And I'm going to then get
the configuration descriptor

00:57:43.740 --> 00:57:46.300
pointer for this configuration.

00:57:46.310 --> 00:57:50.330
And here is the configuration
description pointer.

00:57:50.340 --> 00:57:52.680
The configuration value that
I'm going to end up calling

00:57:52.710 --> 00:57:55.160
set configuration with is a 1.

00:57:55.190 --> 00:57:58.290
And I call set configuration.

00:57:58.330 --> 00:58:03.270
And now,
IO Registry Explorer does update.

00:58:03.300 --> 00:58:05.610
And when I go and I look,

00:58:05.910 --> 00:58:12.070
In fact, now I have an interface
associated with this device,

00:58:12.090 --> 00:58:13.070
attached to this device.

00:58:13.100 --> 00:58:17.310
That interface appeared in the kernel
because I made a set configuration call.

00:58:17.310 --> 00:58:19.740
But I didn't make it
directly in the kernel.

00:58:19.740 --> 00:58:23.600
I made it from user space and it
went through the device interface

00:58:23.600 --> 00:58:25.760
and created the configuration.

00:58:25.760 --> 00:58:29.560
So that's pretty much the end
of this user debugging demo,

00:58:29.560 --> 00:58:34.960
but you can see that it's pretty simple
to debug this using Project Builder

00:58:34.960 --> 00:58:41.290
and GDB because you're in user
space and you're not trying to

00:58:41.300 --> 00:58:43.420
step through code in the kernel.

00:58:43.420 --> 00:58:46.930
So that's the user space driver demo.

00:58:47.150 --> 00:58:49.950
Again, it's much easier,
so we highly recommend that

00:58:50.080 --> 00:58:52.100
that's where you put your driver.

00:58:52.680 --> 00:58:56.870
However,
in the case where you really need

00:58:56.880 --> 00:59:06.400
to be doing a kernel mode driver,
for example, a mouse driver,

00:59:06.400 --> 00:59:08.590
keyboard driver, mass storage driver,
and so forth,

00:59:10.130 --> 00:59:14.500
We're going to show you the
techniques that you need to use to

00:59:14.510 --> 00:59:16.680
do two-machine debugging with GDB.

00:59:16.680 --> 00:59:21.750
This stuff is defined
in an I-O-Kit document,

00:59:21.750 --> 00:59:24.990
debugging an I-O-Kit driver
or something like that,

00:59:25.080 --> 00:59:29.220
that goes through these steps,
but we're just going to show you that,

00:59:29.340 --> 00:59:30.870
in fact, it can be done.

00:59:30.880 --> 00:59:35.650
So the first step that you need to do
when trying to set up a two-machine

00:59:35.650 --> 00:59:39.830
debugging environment is you have
to know the hardware Ethernet

00:59:39.830 --> 00:59:41.860
address of the other machine.

00:59:41.860 --> 00:59:46.800
You look at the ARP table,
for those of you who are Unix people,

00:59:46.800 --> 00:59:49.070
and you say,
and the first thing you've got

00:59:49.070 --> 00:59:51.920
to do is you have to delete the
ARP entry for the other machine.

00:59:51.920 --> 00:59:53.350
So I'm going to do that.

00:59:53.400 --> 00:59:59.950
Then you have to create a static
entry for that IP address.

01:00:03.110 --> 01:00:05.240
For that Ethernet,
that IP address to that

01:00:05.400 --> 01:00:06.850
hardware Ethernet address.

01:00:06.890 --> 01:00:12.900
All of this again is documented in
the debugging kernel driver document.

01:00:12.940 --> 01:00:16.420
Now that I have that connection,
it's a permanent

01:00:16.560 --> 01:00:20.660
connection in my ARP table,
which you can see.

01:00:20.660 --> 01:00:23.100
And so now if I have
the driver over here.

01:00:23.100 --> 01:00:23.780
Can we have demo two?

01:00:23.780 --> 01:00:25.940
I can talk to it.

01:00:25.940 --> 01:00:28.020
So can we split the screen and
put demo two on one of them?

01:00:31.380 --> 01:00:35.270
Okay, he's going to load a driver and
we have a debug statement in

01:00:35.280 --> 01:00:39.300
the start method of this driver.

01:00:39.300 --> 01:00:44.830
He's going to plug it in.

01:00:44.830 --> 01:00:53.440
And he's frozen because he's
got this debug statement.

01:00:53.440 --> 01:00:53.440
So,

01:01:02.340 --> 01:01:09.560
So I'm going to load GDB and then
I'm going to say target remote KDP.

01:01:09.600 --> 01:01:11.230
This is in that document again.

01:01:11.280 --> 01:01:19.920
And then I'm going to attach
to this other machine.

01:01:23.640 --> 01:01:25.360
I am now connected to that other machine.

01:01:25.360 --> 01:01:29.490
I can do a back trace and I can
see that I'm in a debugger call,

01:01:29.500 --> 01:01:35.950
but I need the symbols for my driver.

01:01:39.240 --> 01:01:44.150
I will use a command
called show all Kmods,

01:01:44.150 --> 01:01:47.960
which shows me all of the kernel
modules that are loaded on this machine.

01:01:48.050 --> 01:01:49.820
So that would be--

01:01:51.090 --> 01:01:53.900
That one.

01:01:53.900 --> 01:02:00.590
And then I'm going to say, okay, oops.

01:02:03.330 --> 01:02:05.700
Here's the address of my driver.

01:02:05.700 --> 01:02:08.280
And now I need to create
symbols for this driver,

01:02:08.300 --> 01:02:10.330
which I built on this machine.

01:02:10.370 --> 01:02:22.200
So I do KMODSIMS.

01:02:31.700 --> 01:02:35.600
And because it is dependent
on the I/O USB Family.

01:02:35.600 --> 01:02:44.240
And I need to know the
address of the I/O USB Family,

01:02:44.350 --> 01:02:46.630
so that's in here as well.

01:02:46.920 --> 01:02:53.450
So you can see that debugging is
somewhat more painful when in the kernel.

01:03:32.600 --> 01:03:35.500
Okay, I gotta get the address again.

01:03:35.500 --> 01:03:39.430
Okay.

01:03:42.610 --> 01:03:47.680
Now I have a symbol file for this,
and so I add this symbol file to my...

01:03:50.770 --> 01:03:52.860
to my GDB session.

01:03:52.910 --> 01:03:56.770
And now if I do a back trace,
I can actually see all my line numbers.

01:03:56.790 --> 01:04:00.830
And it didn't put it in.

01:04:00.880 --> 01:04:01.860
Well, OK.

01:04:02.100 --> 01:04:04.130
So we are out of time.

01:04:04.540 --> 01:04:08.640
Basically, I can then,
I'm attached to this thing,

01:04:08.640 --> 01:04:10.310
I can go ahead and continue.

01:04:10.310 --> 01:04:12.400
So this machine is now
up and running again.

01:04:12.400 --> 01:04:13.350
You can see by that.

01:04:13.390 --> 01:04:15.650
And he can unplug the device.

01:04:15.650 --> 01:04:18.350
And oh, it kernel panicked.

01:04:18.350 --> 01:04:20.980
Well, we were actually expecting that.

01:04:23.100 --> 01:04:24.020
We did that on purpose.

01:04:24.020 --> 01:04:29.780
And if you look at the back trace,
you can actually see where it terminated.

01:04:29.780 --> 01:04:31.580
And if I had the symbols
working properly,

01:04:31.580 --> 01:04:34.090
which we're out of time to do,
we put a line of code in

01:04:34.100 --> 01:04:36.020
there that dereferenced null.

01:04:36.020 --> 01:04:38.900
And we did that on purpose
to try to debug it.

01:04:39.110 --> 01:04:41.100
But again,
we do need to answer some questions.

01:04:41.100 --> 01:04:45.030
So we've taken five minutes of
question and answer time to do this.

01:04:45.030 --> 01:04:48.620
But that's the process you have to go
through to do two machine debugging.

01:04:48.620 --> 01:04:50.060
So it's somewhat more painful.

01:04:50.060 --> 01:04:52.980
And we recommend doing
user mode whenever you can.

01:04:53.000 --> 01:04:54.060
Okay.
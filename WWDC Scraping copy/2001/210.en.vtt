WEBVTT

00:00:03.340 --> 00:00:07.390
Well, last year I got up here,
I was across the street,

00:00:07.390 --> 00:00:11.420
and showed you what I'd been working
on for the last few months on OS X.

00:00:11.420 --> 00:00:15.640
And it all was kind of basically working,
but there were a lot of underlying

00:00:15.640 --> 00:00:20.080
things that we were kind of unsure about
in the kernel scheduling and all that.

00:00:20.120 --> 00:00:24.260
And I'm really happy now because
not only did we finish everything

00:00:24.540 --> 00:00:29.170
that we were showing last year,
but it's really performing well.

00:00:29.760 --> 00:00:33.060
And towards the end of the session,
I'll have some demos that show

00:00:33.060 --> 00:00:37.920
you exactly how well MIDI is
performing for us on OS X.

00:00:39.500 --> 00:00:42.550
So before I get there,
I'm just going to give you

00:00:42.570 --> 00:00:46.900
some introduction to the
system services for MIDI,

00:00:46.910 --> 00:00:52.500
some of our design thoughts
and challenges that we had

00:00:52.560 --> 00:00:54.370
in getting MIDI running.

00:00:54.380 --> 00:00:58.260
I'm going to go through the basic
concepts of the API and some of

00:00:58.260 --> 00:01:03.380
the objects you'll use in that API,
along with a lot of examples

00:01:03.380 --> 00:01:05.720
as I go through the API.

00:01:05.720 --> 00:01:08.360
And at the end, I'll have some demos.

00:01:10.440 --> 00:01:16.900
- So in the large picture of things,
MIDI's a fairly low level service.

00:01:16.910 --> 00:01:20.440
It's not in the kernel like I/O Kit is.

00:01:20.440 --> 00:01:24.540
MIDI through its drivers
talks to I/O Kit.

00:01:24.610 --> 00:01:26.800
to do MIDI.io.

00:01:26.850 --> 00:01:29.560
But as we saw in the previous session,
there are some higher level

00:01:29.560 --> 00:01:33.760
services like the audio toolbox,
which gives you ways

00:01:33.770 --> 00:01:39.830
to send MIDI sequences,
edit MIDI sequences and send them

00:01:39.830 --> 00:01:42.320
through to the MIDI hardware layer.

00:01:42.690 --> 00:01:46.720
QuickTime is another example of
a higher level service that on

00:01:46.720 --> 00:01:50.090
OS 9 is layered on top of MIDI.

00:01:50.110 --> 00:01:53.480
And we've done some work to get
it layered on top of MIDI on 10.

00:01:53.480 --> 00:01:55.540
And I'm not sure if it actually works.

00:01:55.540 --> 00:01:59.720
There's a component in the
current build of OS 10.

00:01:59.720 --> 00:02:03.840
And I'm not sure if it actually works,
but it will at some point.

00:02:05.340 --> 00:02:10.780
So some examples of the kinds
of MIDI hardware that we expect

00:02:10.780 --> 00:02:12.780
to be seeing drivers for.

00:02:12.900 --> 00:02:16.890
People are mostly using
USB MIDI interfaces these days.

00:02:16.960 --> 00:02:21.300
We're also seeing some USB synthesizers
like this Roland device I have here.

00:02:21.300 --> 00:02:24.580
It's connected directly
to my PowerBook with USB.

00:02:24.580 --> 00:02:28.340
We're still seeing
PCI cards that do MIDI.

00:02:28.340 --> 00:02:35.130
And we're starting to see with
devices from Yamaha and others

00:02:35.130 --> 00:02:38.170
some MIDI FireWire devices.

00:02:39.120 --> 00:02:44.700
For the purposes of the MIDI API,
we don't really concern ourselves with

00:02:44.700 --> 00:02:49.880
things that connect to MIDI interfaces,
like traditional MIDI devices,

00:02:49.880 --> 00:02:54.880
drum machines, keyboards, samplers,
things that have traditional

00:02:54.880 --> 00:02:55.960
MIDI cables on them.

00:02:55.960 --> 00:02:58.550
So when I talk about a
MIDI device in the API,

00:02:58.560 --> 00:03:01.890
I'm talking about one of these
things that connects directly to

00:03:01.890 --> 00:03:07.090
the computer and is controlled
by a driver on the computer.

00:03:07.300 --> 00:03:10.970
So when I talk about an
external MIDI device,

00:03:10.970 --> 00:03:15.680
that's a traditional MIDI device
with a five pin connector on it.

00:03:17.410 --> 00:03:23.150
So here are the goals that went into
our design for the MIDI services.

00:03:23.320 --> 00:03:29.000
On Mac OS 9,
we started to see these trends towards

00:03:29.020 --> 00:03:33.860
hardware and software developers
kind of doing their own thing to

00:03:33.940 --> 00:03:37.460
make their own products work together
in a kind of closed system way.

00:03:37.460 --> 00:03:42.190
And while that's okay, I mean,
there's some innovation that

00:03:42.260 --> 00:03:44.660
goes on when people do that.

00:03:44.660 --> 00:03:50.340
It's also a bit antithetical to the
spirit of MIDI in the first place,

00:03:50.340 --> 00:03:53.140
which was that you could take a bunch
of gear from different manufacturers,

00:03:53.300 --> 00:03:56.050
plug it in together,
and it would all work.

00:03:56.060 --> 00:04:02.120
So what we want to do on 10
is try to support this kind of

00:04:02.140 --> 00:04:08.330
interoperability that we've had in
the past with support for things

00:04:08.400 --> 00:04:10.620
like timestamped MIDI interfaces.

00:04:12.780 --> 00:04:16.460
And to get people to actually use
our services instead of trying to

00:04:16.460 --> 00:04:22.210
hack down to the lowest levels of
the hardware or the OS like we've had

00:04:22.210 --> 00:04:26.010
to as MIDI developers in the past.

00:04:26.600 --> 00:04:31.900
Our goals are to really get performance
where it needs to be with good,

00:04:31.900 --> 00:04:35.590
highly accurate timing,
both on recording of input

00:04:35.600 --> 00:04:37.100
and performing outgoing MIDI.

00:04:37.100 --> 00:04:43.020
Our goals are to have really low
latency with three times of under

00:04:43.040 --> 00:04:48.740
a millisecond and low jitter in
the hundreds of microseconds range.

00:04:48.740 --> 00:04:51.670
And I think we're pretty
close to those numbers,

00:04:51.670 --> 00:04:54.370
as I'll show you at
the end of the session.

00:04:54.530 --> 00:05:00.040
We want to present to the user
a single system-wide state.

00:05:00.050 --> 00:05:05.740
We don't necessarily want to dictate
the user interface because MIDI users

00:05:05.740 --> 00:05:07.740
might be using a fairly simple program.

00:05:07.740 --> 00:05:14.140
They don't want a user interface designed
for helping him name his 55 synthesizers.

00:05:14.140 --> 00:05:17.140
But then again,
there are people with 55 synthesizers

00:05:17.140 --> 00:05:18.730
and they want to name them all.

00:05:18.730 --> 00:05:28.360
And so we've taken the middle path by
providing a central system database but

00:05:28.380 --> 00:05:31.640
not imposing a user interface on the way.

00:05:31.640 --> 00:05:33.380
Sorry about that.

00:05:33.380 --> 00:05:39.150
Skipping ahead rather quickly here.

00:05:42.100 --> 00:05:47.160
A single system-wide state so that
all your MIDI programs will see the

00:05:47.160 --> 00:05:50.070
same devices with the same properties.

00:05:50.070 --> 00:05:54.160
And developers can add their
own properties to the devices

00:05:54.160 --> 00:05:56.560
to make the system extensible.

00:05:59.600 --> 00:06:04.350
So towards those goals,
we have a driver model so that the

00:06:04.370 --> 00:06:07.370
hardware manufacturers can write drivers.

00:06:07.370 --> 00:06:10.160
The MIDI server,
which we'll get to in a moment,

00:06:10.160 --> 00:06:11.640
loads those drivers.

00:06:11.640 --> 00:06:15.650
And then all the applications can
share their access to that hardware.

00:06:15.650 --> 00:06:18.540
Everybody can send to that
same destination at once.

00:06:18.540 --> 00:06:21.520
Everybody can receive
from a source at once.

00:06:22.300 --> 00:06:26.390
And like I just mentioned,
we have a central device database.

00:06:26.390 --> 00:06:30.840
And we provide for time-stamped
input and scheduled MIDI output.

00:06:30.840 --> 00:06:35.760
And we also have some features
for inter-process communication.

00:06:35.760 --> 00:06:39.020
So if you have, for instance,
a software synthesizer,

00:06:39.020 --> 00:06:42.430
you could create it as a virtual
MIDI destination and have it

00:06:42.430 --> 00:06:46.580
show up to other applications as
something you could send MIDI to.

00:06:46.580 --> 00:06:49.940
Some other uses of that
might be MIDI effects.

00:06:49.940 --> 00:06:51.740
And so I'll get to that.

00:06:52.300 --> 00:06:53.680
And then we'll get to
the rest of the talk.

00:06:53.680 --> 00:06:57.260
So those are the major features.

00:07:01.100 --> 00:07:04.000
Here's a picture that gives
you an overview of how things

00:07:04.040 --> 00:07:05.200
are actually implemented.

00:07:05.200 --> 00:07:13.440
The horizontal gray lines
are address space boundaries,

00:07:13.440 --> 00:07:15.540
which are kind of challenges
for the implementation.

00:07:15.540 --> 00:07:18.680
That's where we have to move
data between address spaces

00:07:18.680 --> 00:07:20.540
in a really efficient manner.

00:07:20.540 --> 00:07:25.770
And I'm happy to say I think we're
doing that really well right now.

00:07:26.780 --> 00:07:31.110
At the lower level,
we've got the kernel with I/O Kit.

00:07:31.300 --> 00:07:38.480
Above that, we've got MIDI drivers,
which are typically I/O Kit user clients.

00:07:38.480 --> 00:07:42.810
And they're loaded and managed
by a MIDI server process.

00:07:43.510 --> 00:07:47.150
which gets loaded automatically
by the core MIDI framework which

00:07:47.150 --> 00:07:51.940
your applications link with
in their own address spaces.

00:07:52.300 --> 00:07:54.260
On the right,
I've got QuickTime here linking

00:07:54.260 --> 00:07:58.020
with core MIDI just as an example
of how QuickTime is just another

00:07:58.020 --> 00:08:02.020
application in this model.

00:08:02.110 --> 00:08:06.720
So yeah, the core MIDI framework
is the purple boxes there.

00:08:06.720 --> 00:08:13.120
And that manages communication with the
MIDI server using Mach messaging to very

00:08:13.130 --> 00:08:18.610
efficiently move your data back and forth
between your application and the server.

00:08:22.880 --> 00:08:25.360
So those MIDI frameworks
such as CoreMIDI,

00:08:25.390 --> 00:08:27.300
there's actually two of them.

00:08:27.300 --> 00:08:29.800
They're implemented as Mac OS libraries.

00:08:29.800 --> 00:08:34.230
There's the CoreMIDI framework,
which is what applications link with.

00:08:34.230 --> 00:08:39.660
And as I just mentioned,
that framework allows your clients,

00:08:39.700 --> 00:08:44.410
it implements the API to the
MIDI server using Mac messaging

00:08:44.410 --> 00:08:46.480
to the server process.

00:08:46.960 --> 00:08:50.620
There's also a second framework
called CoreMIDI Server,

00:08:50.620 --> 00:08:53.590
which is for the benefit
of driver writers.

00:08:53.590 --> 00:08:59.320
This framework actually contains the
entire implementation of the MIDI server.

00:08:59.320 --> 00:09:04.560
The MIDI server itself is a main
function that jumps into this framework.

00:09:04.560 --> 00:09:08.480
And the framework loads drivers,
and then the drivers can link to the

00:09:08.480 --> 00:09:10.870
framework to make callbacks into it.

00:09:10.880 --> 00:09:15.420
So that way drivers have access
to almost the entire API.

00:09:20.560 --> 00:09:24.400
I'm not going to go deeply into the
process of how to create a driver.

00:09:24.400 --> 00:09:25.760
It's a little more esoteric.

00:09:25.760 --> 00:09:31.100
There aren't as many of you who are going
to be interested in writing drivers,

00:09:31.100 --> 00:09:35.650
but it's helpful for application
writers to know what the MIDI drivers

00:09:35.650 --> 00:09:39.780
are doing because they kind of show --
they kind of set up all the information

00:09:39.780 --> 00:09:43.780
that you end up seeing in your
application and you'll have to figure

00:09:43.780 --> 00:09:49.500
out about installing them and that
kind of stuff as you start developing.

00:09:49.500 --> 00:09:53.750
Apple is going to provide and
does provide in 10.0 a MIDI driver

00:09:53.750 --> 00:09:56.770
for the USB MIDI class standard.

00:09:57.200 --> 00:09:58.160
That's in the build now.

00:09:58.160 --> 00:10:01.290
Unfortunately, no devices that I know of
are shipping that use it,

00:10:01.330 --> 00:10:07.700
but someone's got to do something first,
so we're providing that driver.

00:10:07.700 --> 00:10:11.660
For other pieces of MIDI hardware,

00:10:12.700 --> 00:10:16.030
We expect manufacturers
to be creating drivers.

00:10:16.040 --> 00:10:20.770
I know that several of you hardware
manufacturers are doing that.

00:10:20.770 --> 00:10:25.130
And I would ask you application
developers who are eager for drivers

00:10:25.130 --> 00:10:29.080
to get in touch with the people
who make hardware and ask them to

00:10:29.080 --> 00:10:33.110
please give you a beta driver or
something so you can develop and

00:10:33.110 --> 00:10:35.510
then you'll buy their hardware.

00:10:36.780 --> 00:10:39.790
So, any case,
drivers get installed into the

00:10:39.790 --> 00:10:42.410
system library extensions folder.

00:10:42.430 --> 00:10:44.260
They're managed by the
MIDI servers I mentioned.

00:10:44.260 --> 00:10:50.000
They use the CFPlugin mechanism,
which is a little daunting at first,

00:10:50.000 --> 00:10:54.540
but we've got some example code
that makes it fairly easy to get

00:10:54.540 --> 00:10:57.400
your first driver up and running.

00:10:57.400 --> 00:11:01.500
And for most drivers,
no kernel extensions are necessary.

00:11:01.500 --> 00:11:10.580
A USB MIDI driver, for instance,
works entirely as a USB user client,

00:11:10.580 --> 00:11:14.070
so there's no kernel
extension needed there.

00:11:16.630 --> 00:11:20.940
The basic functions of the MIDI driver,
there aren't very many.

00:11:20.940 --> 00:11:25.600
All it really has to do is look for
hardware and once it's found it,

00:11:25.600 --> 00:11:31.440
send and receive many messages,
typically using I/O Kit.

00:11:32.180 --> 00:11:34.820
When it finds hardware,
it creates these objects

00:11:34.870 --> 00:11:38.470
called the MIDI device,
the MIDI entity,

00:11:38.470 --> 00:11:42.500
and MIDI endpoint objects,
and it sets their properties.

00:11:42.500 --> 00:11:45.940
And those are objects that
you'll see in your application.

00:11:45.940 --> 00:11:50.590
So let's look at what those look like.

00:11:51.300 --> 00:11:55.880
From the bottom up,
there's a MIDI endpoint,

00:11:55.890 --> 00:11:59.580
and it's simply a
MIDI source or destination.

00:11:59.810 --> 00:12:03.540
It's a single 16-channel stream,
so you don't have to worry

00:12:03.540 --> 00:12:06.400
about channel 72 on something.

00:12:06.400 --> 00:12:13.430
You basically speak the standard
MIDI protocol over that stream.

00:12:16.850 --> 00:12:23.000
The next layer up is the MIDI entity,
which groups endpoints together.

00:12:23.410 --> 00:12:28.440
This is useful when applications
want to get an idea of which

00:12:28.440 --> 00:12:32.100
endpoints go with each other.

00:12:32.100 --> 00:12:34.930
From the point of view of, for instance,
a patch librarian program,

00:12:34.930 --> 00:12:40.020
it's nice to be able to send messages
to a device and get messages back.

00:12:40.070 --> 00:12:43.850
In a totally flexible world,
you could have the user say, yeah,

00:12:43.900 --> 00:12:48.500
the out goes out port one,
but I'm getting the in

00:12:48.500 --> 00:12:51.620
back in on port eight.

00:12:51.750 --> 00:12:55.700
To provide useful defaults for people,
it's nice to be able to group the

00:12:55.730 --> 00:13:00.070
endpoints like that so that an
application can make reasonable

00:13:00.070 --> 00:13:05.010
default assumptions about how to
talk bidirectionally to a device.

00:13:05.760 --> 00:13:12.580
So an entity, and this is a term borrowed
from the USB MIDI class spec,

00:13:12.610 --> 00:13:16.400
an entity is really just one
subcomponent of a device.

00:13:16.400 --> 00:13:21.930
So some examples of that would be,
for instance, an 8-in,

00:13:21.940 --> 00:13:27.430
8-out multiport interface
like eMagix Uniter 8 could be

00:13:27.430 --> 00:13:32.310
seen as having eight entities,
each with one source endpoint

00:13:32.310 --> 00:13:35.140
and one destination endpoint.

00:13:36.660 --> 00:13:42.810
Another example would be a hypothetical
device that had a pair of MIDI ports in

00:13:42.810 --> 00:13:45.640
it and it had a general MIDI synth in it.

00:13:45.640 --> 00:13:49.250
And conceptually,
those are two distinct entities

00:13:49.250 --> 00:13:53.810
and your software might want
to present them as such.

00:13:54.850 --> 00:13:59.400
- So the next level in the hierarchy
above the entity is the device,

00:13:59.400 --> 00:14:02.730
which is something that you
would represent by an icon if

00:14:02.730 --> 00:14:06.800
you were going to try to draw a
graphical view of what's there.

00:14:06.820 --> 00:14:11.890
Devices are created and
controlled by drivers and they

00:14:11.890 --> 00:14:14.830
contain the entity objects.

00:14:18.340 --> 00:14:22.570
So now that we've seen those
basic objects that the driver

00:14:22.570 --> 00:14:27.900
populates the system with,
we can start to look at how you

00:14:27.900 --> 00:14:33.480
begin to sign into the system and
build the objects through which you

00:14:33.480 --> 00:14:38.010
communicate with the MIDI sources
and destinations in the system.

00:14:38.490 --> 00:14:43.250
So with OMS and MIDI Manager,
actually you had to say OMS sign

00:14:43.250 --> 00:14:46.780
in or MIDI sign in before
anything else would work.

00:14:46.780 --> 00:14:49.980
That's not totally true here.

00:14:49.980 --> 00:14:53.130
You can actually interrogate the
system before making these calls,

00:14:53.130 --> 00:14:56.770
but pretty early on in your program,
because you won't be able to do any I.O.

00:14:56.770 --> 00:15:00.440
until you've done this,
you'll want to call a MIDI client create,

00:15:00.480 --> 00:15:05.440
passing it a name and a function pointer.

00:15:06.660 --> 00:15:11.990
In this case, it's called my notify proc,
and this function will be called

00:15:12.000 --> 00:15:16.920
back to tell you about when
things change in the system.

00:15:17.120 --> 00:15:22.390
The last argument to MIDI client
create is the client ref,

00:15:22.390 --> 00:15:26.310
which you'll store somewhere in
your program and use in other calls.

00:15:27.700 --> 00:15:30.940
- Once you've, oh, sorry,
I'm skipping ahead of myself.

00:15:30.940 --> 00:15:35.700
A little more about the notify proc
that you passed to MIDI client create.

00:15:35.700 --> 00:15:40.530
It gets called back in the same thread
which called MIDI client create,

00:15:40.540 --> 00:15:44.200
which should ideally be
your program's main thread.

00:15:45.000 --> 00:15:51.080
We may have some more fine-grained
notifications in the future,

00:15:51.080 --> 00:15:55.510
but right now there's only one
which says something changed.

00:15:55.510 --> 00:15:59.640
And that may be a device arrived,
a device disappeared,

00:15:59.640 --> 00:16:03.900
some endpoints on a device
disappeared or appeared,

00:16:03.900 --> 00:16:06.780
or the name of something changed.

00:16:07.840 --> 00:16:10.860
That's what this message here is,
KMIDI message setup change.

00:16:10.860 --> 00:16:12.960
Something about the system has changed.

00:16:12.960 --> 00:16:17.170
So if you're caching in your
program's variables a picture

00:16:17.190 --> 00:16:21.930
of what's in the MIDI system,
this is your message to say, okay,

00:16:21.980 --> 00:16:26.060
it's time for you to resynchronize your
variables with what's in the MIDI system.

00:16:29.800 --> 00:16:33.740
Once you've created your MIDI client,
then you create MIDI port objects.

00:16:33.740 --> 00:16:39.260
And these are objects through which your
client actually sends and receives MIDI.

00:16:39.260 --> 00:16:42.200
Not to be confused with
MIDI hardware ports,

00:16:42.240 --> 00:16:44.980
like you would see on a MIDI interface.

00:16:44.980 --> 00:16:48.830
These are more like,
if you remember MIDI Manager,

00:16:48.830 --> 00:16:53.920
the little virtual triangles on
the ins and outs of your program.

00:16:55.150 --> 00:16:57.140
Another analogy is Mach ports.

00:16:57.140 --> 00:17:02.480
Those are your program's
communication receptacles,

00:17:02.490 --> 00:17:06.390
you can think of them as.

00:17:09.500 --> 00:17:16.500
To create an output port,
before I mention that,

00:17:16.500 --> 00:17:19.640
one thing to know about output
ports is you only need one to

00:17:19.650 --> 00:17:22.520
be able to send to all of the
MIDI destinations in the system.

00:17:22.520 --> 00:17:26.520
One port can send to seven
different destinations.

00:17:26.540 --> 00:17:30.600
One of the arguments when you send is
which destination you're sending to.

00:17:30.600 --> 00:17:34.820
The only time you need to create
multiple ports is if you have a

00:17:34.820 --> 00:17:37.500
kind of component-oriented program.

00:17:37.500 --> 00:17:44.420
Maybe you've got five different
separately coded parts of your program,

00:17:44.480 --> 00:17:49.320
and they're all acting very
independently of each other.

00:17:49.320 --> 00:17:53.810
You would, in that case,
perhaps have five output ports,

00:17:53.820 --> 00:17:57.240
each sending in a separate thread, even.

00:17:57.240 --> 00:18:02.410
And what would happen is that the
MIDI server... would then merge

00:18:02.410 --> 00:18:04.790
the output of those five ports.

00:18:04.800 --> 00:18:09.640
So, in any cases where you're
sending in multiple threads,

00:18:09.640 --> 00:18:12.780
especially where system-exclusive
messages are involved,

00:18:12.800 --> 00:18:15.720
you need to be using separate ports.

00:18:15.720 --> 00:18:19.810
As a really common example,
you might have a MIDI-through

00:18:19.890 --> 00:18:23.710
process in your program that's
taking everything that's coming

00:18:23.720 --> 00:18:26.100
in and sending it right back out.

00:18:26.140 --> 00:18:29.300
And elsewhere in your program,
you might have...

00:18:29.300 --> 00:18:46.100
[Transcript missing]

00:18:48.250 --> 00:18:51.770
Similarly,
MIDI input ports may receive input

00:18:51.880 --> 00:18:54.790
from all of the sources in the system.

00:18:55.430 --> 00:19:02.010
A port is basically a binding,
well it's an object that contains

00:19:02.040 --> 00:19:07.000
a connection point for input
and it gets bound to something

00:19:07.000 --> 00:19:13.890
called a MIDI read proc,
which is a function that will get

00:19:13.910 --> 00:19:14.590
called when input arrives at that port.

00:19:14.800 --> 00:19:19.800
So the arguments to MIDI input
port create are a name,

00:19:19.800 --> 00:19:25.800
a function pointer called
myreadproc in this case,

00:19:25.800 --> 00:19:30.160
a null refcon or user
client data pointer,

00:19:30.160 --> 00:19:35.660
and then you get back the MIDI port ref,
which is your input port,

00:19:35.660 --> 00:19:39.180
and you would save that
away for use in other calls.

00:19:43.650 --> 00:19:48.360
Okay, before we look at how to
actually perform MIDI I/O,

00:19:48.360 --> 00:19:52.390
let's look at the data
structures in which MIDI messages

00:19:52.410 --> 00:19:54.410
are sent and received.

00:19:55.430 --> 00:19:58.930
We have this thing called
a MIDI packet list,

00:19:58.950 --> 00:20:06.070
which provides a list of time stamped
packets to or from one endpoint.

00:20:06.250 --> 00:20:11.640
You'll use this both in
receiving MIDI and sending MIDI.

00:20:11.640 --> 00:20:16.190
It's a variable length structure,
which in turn contains multiple

00:20:16.190 --> 00:20:18.190
variable length structures.

00:20:18.200 --> 00:20:24.200
The first argument is simply
the number of packets,

00:20:24.260 --> 00:20:29.300
and then it's followed by
MIDI packet structures,

00:20:29.300 --> 00:20:30.600
which are variable length.

00:20:30.600 --> 00:20:33.710
There can be any number of those.

00:20:36.770 --> 00:20:42.710
The MIDI packet structure contains
one or more simultaneous MIDI events.

00:20:42.800 --> 00:22:03.200
[Transcript missing]

00:22:03.500 --> 00:22:07.490
There's a limitation that we don't want
you to mix system-exclusive messages

00:22:07.510 --> 00:22:11.620
with other MIDI messages within a packet.

00:22:13.010 --> 00:22:18.100
About the variable length
nature of these packets.

00:22:18.100 --> 00:22:23.100
The first half of the slide shows
an incorrect example of how to

00:22:23.100 --> 00:22:26.270
read through a MIDI packet list.

00:22:26.340 --> 00:22:31.020
And what's incorrect about it is that
it's treating that packet member of

00:22:31.020 --> 00:22:34.560
the structure as a fixed length object.

00:22:34.560 --> 00:22:37.310
It's just, you know,
it's treating the packet

00:22:37.390 --> 00:22:40.360
list as an array of packets,
but that doesn't work because

00:22:40.360 --> 00:22:41.840
the packets are variable length.

00:22:41.840 --> 00:22:46.270
So the right way to do it is
to first get a pointer to the

00:22:46.270 --> 00:22:50.630
first packet in the packet list,
walk through each of

00:22:50.640 --> 00:22:54.850
the packets in the list,
and then you use a very efficient

00:22:54.850 --> 00:22:59.800
helper macro called MIDI packet next
to get to the next packet in the list.

00:23:04.210 --> 00:23:07.480
and because these variable
length structures are a

00:23:07.480 --> 00:23:10.190
little annoying to deal with,
we've also provided some

00:23:10.190 --> 00:23:13.200
convenience functions for
when you're building them up.

00:23:13.200 --> 00:23:17.510
There's MIDI packet list init
and MIDI packet list add.

00:23:17.520 --> 00:23:21.350
The way they work in this example,

00:23:22.070 --> 00:23:28.650
We're creating a 1K buffer on the stack
and casting it to a MIDI packet list.

00:23:29.600 --> 00:23:31.950
So basically we're saying,
here's a MIDI packet list

00:23:31.950 --> 00:23:34.840
that can be up to 1K in size.

00:23:34.840 --> 00:23:39.270
Then with MIDI packet list in it,
we're setting it up so that

00:23:39.270 --> 00:23:41.600
it contains no packets.

00:23:41.610 --> 00:23:46.110
We're getting back a pointer to
the first empty packet in the list.

00:23:46.600 --> 00:23:50.520
Then when we call MIDI packet
list add to add a node on event,

00:23:50.540 --> 00:23:56.430
that node on event with its timestamp
gets appended to the packet list.

00:23:56.440 --> 00:24:01.470
And if we have an array or if
we have a list of 50 nodes that

00:24:01.470 --> 00:24:05.540
we want to add or other events,
50 events that we want to

00:24:05.560 --> 00:24:09.180
add to this packet list,
we can successfully attempt to

00:24:09.200 --> 00:24:14.220
call MIDI packet list add until
it returns null in curr packet.

00:24:14.480 --> 00:24:18.720
And that's our clue that the packet has
become full and it's time to send it.

00:24:21.000 --> 00:24:26.560
So that's a useful way to build up a
packet dynamically with correct syntax.

00:24:28.800 --> 00:24:32.380
And this is just a summary
of the last two slides,

00:24:32.400 --> 00:24:34.610
the convenience functions.

00:24:38.160 --> 00:24:44.040
Okay, now that we've looked at the actual
format of our MIDI data and we know

00:24:44.040 --> 00:24:50.040
about the MIDI endpoints and sources and
destinations that we see in the system,

00:24:50.040 --> 00:24:55.540
we can look at the functions for
getting information about those

00:24:55.540 --> 00:24:59.150
sources and destinations and
actually communicating with them.

00:24:59.810 --> 00:25:03.980
This example here shows the two
functions for iterating through all of

00:25:04.020 --> 00:25:06.240
the MIDI destinations in the system.

00:25:06.240 --> 00:25:08.640
There's
MIDI_GET_NUMBER_OF_DESTINATIONS and

00:25:08.640 --> 00:25:11.990
MIDI_GET_DESTINATION,
which just takes an

00:25:11.990 --> 00:25:16.560
index as its argument,
a zero-based index.

00:25:16.850 --> 00:25:19.560
And in this example,
we're calling MIDI send,

00:25:19.560 --> 00:25:22.640
which is the basic I want
to send MIDI function,

00:25:22.640 --> 00:25:24.190
obviously.

00:25:24.200 --> 00:25:29.450
It's MIDI sends first argument is
the output port that you created

00:25:29.540 --> 00:25:31.700
at the beginning of your program.

00:25:31.700 --> 00:25:33.900
The second argument is a destination.

00:25:33.900 --> 00:25:36.700
And the third argument
is a MIDI packet list.

00:25:36.700 --> 00:25:38.980
So in this example,
we're sending some arbitrary

00:25:39.100 --> 00:25:43.550
MIDI packet list to all of the
destinations in the system.

00:25:45.390 --> 00:25:49.200
And here's a pretty parallel
example of how to find all the

00:25:49.200 --> 00:25:54.770
MIDI sources in the system and
establish input connections to them.

00:25:55.300 --> 00:26:01.500
The calls to iterate through
the sources are MIDI get number

00:26:01.500 --> 00:26:01.500
of sources and MIDI get source.

00:26:02.250 --> 00:26:06.490
And input's a little different
from output in that we can

00:26:06.490 --> 00:26:09.200
always send to any destination.

00:26:09.200 --> 00:26:10.980
There's no big deal about that.

00:26:10.980 --> 00:26:14.790
But when we want to get
input from a source,

00:26:14.790 --> 00:26:18.020
we have to tell the system,
I want to listen to that source.

00:26:18.020 --> 00:26:20.860
Because otherwise,
we might have a situation where three

00:26:20.860 --> 00:26:23.780
or four MIDI programs are running,
and there are five

00:26:23.780 --> 00:26:27.050
MIDI controllers connected,
and someone's banging on

00:26:27.050 --> 00:26:30.110
all those controllers,
and yet each program only wants

00:26:30.110 --> 00:26:31.970
to be listening to one of them.

00:26:32.200 --> 00:26:39.490
And it's best for system overhead if
clients are only delivered messages

00:26:39.560 --> 00:26:43.180
from the sources that they're
actually interested in listening to.

00:26:43.180 --> 00:26:47.030
So we require,
before a client gets any input,

00:26:47.100 --> 00:26:51.880
that it will explicitly ask
for input from that source.

00:26:51.880 --> 00:26:55.480
So that's what that call
MIDI port connect source does.

00:26:55.480 --> 00:26:58.450
There's a parallel call
MIDI port disconnect source.

00:26:58.460 --> 00:27:02.180
The last argument to
MIDI port connect source is,

00:27:02.200 --> 00:27:06.800
a reference constant,
which will come back to your read proc.

00:27:06.800 --> 00:27:10.730
And if you'll recall,
the read proc was an argument

00:27:10.790 --> 00:27:14.000
when you set up your input port.

00:27:15.800 --> 00:27:19.180
- So at the bottom there's the
prototype for the MIDI read proc,

00:27:19.180 --> 00:27:23.280
which is your callback
function to receive MIDI.

00:27:23.400 --> 00:27:28.020
It gets called back in a very high
priority thread that gets created on

00:27:28.020 --> 00:27:31.590
your behalf by the core MIDI framework.

00:27:34.110 --> 00:27:38.040
You need to be aware of any possible
synchronization issues with the data

00:27:38.040 --> 00:27:40.750
that you're accessing in that thread.

00:27:46.800 --> 00:27:49.400
Okay,
so we've looked at how to walk through

00:27:49.400 --> 00:27:54.280
the sources and destinations in the
system and send and receive MIDI to them.

00:27:54.300 --> 00:27:59.710
We can also look at the higher
level structures in the system,

00:27:59.740 --> 00:28:03.290
which are the devices and
entities that the drivers created.

00:28:03.300 --> 00:28:06.480
Using MIDI get number of devices,
MIDI get device,

00:28:06.490 --> 00:28:09.960
MIDI get number of entities,
and MIDI get entity.

00:28:09.960 --> 00:28:12.910
That's all really pretty straightforward.

00:28:13.780 --> 00:28:16.420
So why would you want to do that?

00:28:16.500 --> 00:28:20.750
There are times when you want
to walk through the endpoints,

00:28:20.770 --> 00:28:25.310
the actual MIDI sources and destinations,
and those will exclude the

00:28:25.310 --> 00:28:30.700
endpoints of any device which is
temporarily absent from the system,

00:28:30.700 --> 00:28:31.190
which is good.

00:28:31.200 --> 00:28:35.460
It will include virtual endpoints
created by other applications,

00:28:35.460 --> 00:28:36.400
which is good.

00:28:36.400 --> 00:28:41.470
And that's what you want to do when
you're trying to figure out what sources

00:28:41.470 --> 00:28:43.640
and destinations you can talk to.

00:28:43.700 --> 00:28:47.930
Now, there are other times when you
might want to draw the user a

00:28:47.940 --> 00:28:49.700
picture of what's out there.

00:28:49.700 --> 00:28:52.590
You know, I see this device,
I see that device,

00:28:52.590 --> 00:28:55.440
it's got these entities in it,
and so forth.

00:28:55.440 --> 00:29:00.260
And that's when you would walk through
the devices and entities in the system.

00:29:00.260 --> 00:29:03.780
You will see the devices which
might be temporarily absent.

00:29:03.780 --> 00:29:07.360
You won't see any virtual endpoints
because they're not really

00:29:07.360 --> 00:29:09.670
associated with any devices at all.

00:29:09.720 --> 00:29:12.510
And so again,
that's useful if you want to

00:29:12.510 --> 00:29:13.680
present some sort of configuration.

00:29:13.700 --> 00:29:16.160
configuration view of the system.

00:29:20.420 --> 00:29:23.900
So speaking of devices, entities,
and endpoints,

00:29:23.910 --> 00:29:27.520
they all have these properties.

00:29:27.520 --> 00:29:31.140
The core audio framework
has properties on devices.

00:29:31.140 --> 00:29:34.640
As we saw,
the audio units have properties.

00:29:34.640 --> 00:29:41.120
This is a concept that we've
used rather pervasively as a way

00:29:41.170 --> 00:29:45.800
to extensively add information
about the objects in the system.

00:29:46.060 --> 00:29:50.780
Typically,
drivers will set attributes or properties

00:29:50.780 --> 00:29:54.080
on their objects when they create them.

00:29:54.080 --> 00:29:57.640
And typically, applications will just
read these attributes.

00:29:57.640 --> 00:30:02.290
But the system is extensible
in that applications can add

00:30:02.290 --> 00:30:07.590
their own custom properties to
devices if they want to do that.

00:30:10.300 --> 00:30:15.150
An important feature of the property
system is that properties are

00:30:15.150 --> 00:30:20.860
inherited down the hierarchy from
devices to entities to endpoints.

00:30:20.900 --> 00:30:25.050
So in this example,
you can see that the device, the entity,

00:30:25.050 --> 00:30:28.020
and the endpoint all
have different names.

00:30:28.210 --> 00:30:30.460
The device's name is X999.

00:30:30.460 --> 00:30:35.930
The entity's name is port1,
and the endpoint's name is port1n.

00:30:35.930 --> 00:30:41.930
But you can see that the manufacturer
and model name are defined by the device,

00:30:41.930 --> 00:30:46.650
and neither the entity nor the
endpoint override those properties.

00:30:46.660 --> 00:30:50.290
And so you could ask the endpoint,
what is your manufacturer?

00:30:50.310 --> 00:30:54.320
And it would say, well, I don't know,
but I know that my device's

00:30:54.340 --> 00:30:59.470
manufacturer is XCorp,
so I guess that's mine.

00:31:00.200 --> 00:31:06.980
and similarly the endpoint is inheriting
the SysX ID of 17 from the entity.

00:31:10.400 --> 00:31:15.110
So some of the common properties
that we define are obviously the

00:31:15.130 --> 00:31:18.630
name of the entity or object.

00:31:18.640 --> 00:31:22.100
Devices have manufacturer
and model names and SysX IDs,

00:31:22.100 --> 00:31:25.110
as I just mentioned in
the previous example.

00:31:25.250 --> 00:31:29.720
Some other slightly obscure but actually
kind of important properties that

00:31:29.720 --> 00:31:35.780
I'll get into a little later are the
maximum transmission speed to a device.

00:31:36.450 --> 00:31:40.160
And this is important when you're
sending SysEx because MIDI is a

00:31:40.160 --> 00:31:43.200
one-way protocol in a lot of cases.

00:31:43.200 --> 00:31:46.830
In a lot of cases,
there are devices that you send,

00:31:46.850 --> 00:31:52.240
you know, 100K of samples to,
and you just expect it to catch them all.

00:31:52.250 --> 00:31:55.540
And you're not going to have any
way of knowing from the sending end

00:31:55.540 --> 00:31:57.390
whether it actually got it or not.

00:31:57.620 --> 00:32:03.260
Before we had high-speed transport
media other than the MIDI cable,

00:32:03.260 --> 00:32:08.120
this wasn't really an issue because the
MIDI cable could only go at its speed.

00:32:08.120 --> 00:32:12.890
But now that we have things
like USB devices in between our

00:32:12.890 --> 00:32:18.860
computer and our MIDI cables,
it's important that the computer not

00:32:18.860 --> 00:32:27.620
send more than 31,250 bytes per second,
the speed of MIDI, to an old MIDI device.

00:32:27.620 --> 00:32:31.250
So that's a property of a
device that we can interrogate,

00:32:31.250 --> 00:32:35.080
and I'll show you some examples
of using that a bit later.

00:32:35.080 --> 00:32:42.450
Another property that you may see...
on some devices is a request from its

00:32:42.450 --> 00:32:49.720
driver that you schedule its events
a little bit ahead of time for it.

00:32:49.740 --> 00:32:52.920
And that's something else
I'll get into in a moment.

00:32:55.660 --> 00:32:59.700
So continuing just on
properties in general,

00:32:59.760 --> 00:33:03.340
here's an example of how to get
a string property of a device.

00:33:03.340 --> 00:33:08.250
We use MIDI object get string property,
and that works for any of

00:33:08.350 --> 00:33:12.810
the objects in the hierarchy,
devices, endpoints, or entities.

00:33:13.020 --> 00:33:18.280
We're passing the K MIDI property name
constant to say which property we want.

00:33:18.310 --> 00:33:22.680
We're getting back a
core foundation string,

00:33:22.690 --> 00:33:27.640
CF name in this example,
converting it to a C string and using

00:33:27.650 --> 00:33:30.400
printf to put it on the console.

00:33:30.540 --> 00:33:35.740
One important thing that's illustrated
here is that a number of the MIDI calls,

00:33:35.740 --> 00:33:41.560
I think it's all in the property world,
will return core foundation objects.

00:33:41.560 --> 00:33:46.400
And when you get a core foundation
object back from a MIDI API,

00:33:46.400 --> 00:33:50.240
it's your responsibility to
release it because you're being

00:33:50.240 --> 00:33:52.190
given a new reference to it.

00:33:53.260 --> 00:33:55.390
But fortunately,
things are a little easier with

00:33:55.550 --> 00:33:59.530
numeric properties because we just
simply return a signed integer for

00:33:59.530 --> 00:34:03.700
things like this property here,
which is the advanced scheduling

00:34:03.700 --> 00:34:06.660
time in microseconds for a device.

00:34:06.660 --> 00:34:11.810
And this is what I referred to a
moment ago about how some drivers wish,

00:34:11.810 --> 00:34:14.980
when possible,
for you to schedule their output

00:34:14.990 --> 00:34:16.800
a little bit into the future.

00:34:19.700 --> 00:34:26.110
I will talk about that in a moment,
but first we have to understand

00:34:26.170 --> 00:34:31.600
how the MIDI system expresses time.

00:34:32.250 --> 00:34:36.820
We have a type called a MIDI timestamp,
which is simply an

00:34:36.820 --> 00:34:40.390
unsigned 64-bit integer.

00:34:40.510 --> 00:34:47.260
It's equivalent to host time, I'm sorry,
uptime, except that uptime returns a

00:34:47.260 --> 00:34:51.820
structure containing two 32-bit
values that you have to...

00:34:52.040 --> 00:34:58.840
We've chosen to use 64-bit integers
because you end up doing a lot of math

00:34:58.910 --> 00:35:05.820
with these numbers and it's no fun
converting them to structures in Mac.

00:35:06.130 --> 00:35:10.650
So we've got our own versions of these
calls that used to be in driver services

00:35:10.660 --> 00:35:15.460
to get the current host time and to
convert it back and forth to nanoseconds.

00:35:15.460 --> 00:35:20.160
And again, the host time is what in the
old days we called uptime.

00:35:20.160 --> 00:35:24.780
I guess you can still call it uptime,
but we call it the host time.

00:35:25.100 --> 00:35:31.690
That's the basic timestamp that we
use everywhere in the MIDI services.

00:35:34.300 --> 00:35:39.720
So when we schedule our MIDI output,
we can either say send it right

00:35:39.720 --> 00:35:44.540
now by passing a timestamp of zero,
or you can say I want to

00:35:44.540 --> 00:35:51.060
schedule this at some time in the
future using a MIDI timestamp.

00:35:51.960 --> 00:35:55.560
And what that will do is
in the server process,

00:35:55.560 --> 00:36:00.410
it will add the event
or events to a schedule.

00:36:00.700 --> 00:36:04.460
This schedule runs in a
Mach real-time priority thread,

00:36:04.460 --> 00:36:08.700
which means it wakes up really
darn close to when it's supposed

00:36:08.700 --> 00:36:15.410
to and will propagate your outgoing
MIDI message to the driver to be sent.

00:36:17.120 --> 00:36:21.100
One thing to be aware of is that you
shouldn't schedule further in advance

00:36:21.100 --> 00:36:25.400
than you're willing to really commit to,
because at the moment there isn't

00:36:25.400 --> 00:36:27.060
a way to unschedule anything.

00:36:27.060 --> 00:36:30.420
So if the user clicks stop and
you've scheduled two minutes of

00:36:30.420 --> 00:36:33.870
MIDI to be played into the future,
it's going to play unless you

00:36:33.950 --> 00:36:35.680
shut the whole system down.

00:36:35.680 --> 00:36:39.660
This is intended just to give
you a tiny bit of breathing room.

00:36:39.660 --> 00:36:43.430
I would say 100 milliseconds
is the outer bound of how far

00:36:43.440 --> 00:36:45.460
ahead you'd want to schedule.

00:36:47.100 --> 00:36:50.480
I'm aware of developers
scheduling at smaller intervals.

00:36:50.480 --> 00:36:56.380
Anything over a couple of milliseconds
will take a little bit of strain

00:36:56.380 --> 00:36:58.940
off the system and is helpful.

00:36:58.940 --> 00:37:03.280
It's not essential to do,
but this is all in the interests

00:37:03.280 --> 00:37:08.420
of getting really highly precise
timing out of MIDI hardware that

00:37:08.420 --> 00:37:11.340
supports scheduling in advance.

00:37:13.350 --> 00:37:17.860
and such devices that do have that
feature of being able to accept

00:37:17.860 --> 00:37:23.490
scheduled output in advance will put
that property for a minimum advance

00:37:23.500 --> 00:37:25.700
scheduling time on their devices.

00:37:25.700 --> 00:37:29.830
So you as an application writer
can check that property and say,

00:37:29.840 --> 00:37:34.220
oh, okay, this guy wants his MIDI,
you know, 1,500 microseconds in advance

00:37:34.230 --> 00:37:35.500
or whatever his number is.

00:37:36.140 --> 00:37:41.080
And that's your hint that you
can make that piece of hardware

00:37:41.130 --> 00:37:45.400
perform better by giving it its
data that much further in advance.

00:37:48.700 --> 00:37:55.310
Similarly, our incoming messages get time
stamped with the same host clock time,

00:37:55.330 --> 00:37:58.680
audio get current hardware time.

00:37:59.110 --> 00:38:01.840
If you want to schedule
your own timing tasks,

00:38:01.840 --> 00:38:05.750
you can use the multiprocessing
services in Carbon.

00:38:08.600 --> 00:38:11.790
And I touched on this
a couple slides ago.

00:38:11.790 --> 00:38:16.930
It's best to schedule your output
a few milliseconds in advance and

00:38:16.930 --> 00:38:22.800
combine your multiple MIDI events
that happen fairly close together in

00:38:22.800 --> 00:38:24.740
time with a single call to MIDI send.

00:38:24.740 --> 00:38:26.970
You don't have to do this.

00:38:26.970 --> 00:38:28.930
You're still going to be
able to get pretty good

00:38:28.930 --> 00:38:30.420
performance without doing this.

00:38:30.480 --> 00:38:34.360
But when you do do this,
you are reducing the system load

00:38:34.400 --> 00:38:37.800
and there's yet more CPU time
available for other things like,

00:38:37.800 --> 00:38:42.710
you know, intense DSP operations.

00:38:43.510 --> 00:38:47.090
We are getting really good latencies,
as I'm going to show you later on,

00:38:47.090 --> 00:38:50.780
in moving the data around
from place to place.

00:38:50.780 --> 00:38:54.320
But it is more efficient
when you can bunch up your

00:38:54.340 --> 00:38:56.800
messages just the tiniest bit.

00:38:59.020 --> 00:39:04.140
And these are some of the figures we're
starting to see in some of our tests.

00:39:04.150 --> 00:39:08.390
Just in the software stack,
the MIDI through time is usually

00:39:08.420 --> 00:39:11.000
well under one millisecond.

00:39:11.000 --> 00:39:16.180
And our scheduler wake up jitter is
in the realm of 100 microseconds.

00:39:16.180 --> 00:39:20.920
So if you say I want the scheduler
to wake up at such and such a time,

00:39:20.920 --> 00:39:25.200
these are tests I've run on
my titanium power book here.

00:39:25.200 --> 00:39:28.240
That's around the time
I'm seeing right now.

00:39:29.330 --> 00:39:35.110
Before I actually show you some demos
that illustrate some of our timing,

00:39:35.120 --> 00:39:39.640
I'd like to touch on a
couple of other things here.

00:39:39.640 --> 00:39:42.860
We have some inter-process
communication features so that

00:39:42.860 --> 00:39:50.230
your app can create virtual sources
and destinations which other apps,

00:39:50.290 --> 00:39:54.090
including your own,
will see just as if they were

00:39:54.090 --> 00:39:54.090
regular sources and destinations.

00:39:54.950 --> 00:39:58.980
Here's an example of how
to create a virtual source.

00:39:58.980 --> 00:40:02.570
You need to have that client ref that you
created at the beginning of the program,

00:40:02.570 --> 00:40:03.090
my client.

00:40:03.090 --> 00:40:05.140
You give your source a name.

00:40:05.140 --> 00:40:08.050
You get back an endpoint reference to it.

00:40:09.460 --> 00:40:13.540
And when you want to emanate
data from your virtual source,

00:40:13.540 --> 00:40:17.840
you make a call called MIDI received,
which might seem like a

00:40:17.840 --> 00:40:21.470
strange name at first,
but if you realize, okay,

00:40:21.470 --> 00:40:27.280
I'm mimicking what happens in a driver
when it receives data from a real source,

00:40:27.280 --> 00:40:27.280
you can do that.

00:40:27.620 --> 00:40:31.200
You're saying, okay,
I'm pretending I'm receiving data,

00:40:31.200 --> 00:40:33.280
but I'm a virtual source.

00:40:33.280 --> 00:40:35.000
So that's why it's called MIDI received.

00:40:35.000 --> 00:40:38.360
It's the same function a driver calls
when it gets data from a real source.

00:40:40.600 --> 00:40:44.690
So you just pass out the virtual
source endpoint and the packet

00:40:44.690 --> 00:40:46.460
list of data you want to send.

00:40:46.460 --> 00:40:51.630
And any clients who are listening to that
virtual source will receive that data.

00:40:53.560 --> 00:40:57.060
Virtual destinations are
the same but backwards.

00:40:57.080 --> 00:41:05.530
You create a virtual destination,
pass it to your client, give it a name,

00:41:05.530 --> 00:41:05.530
and then you create a
virtual destination.

00:41:05.720 --> 00:41:10.760
You pass it a read proc,
which will get called when other clients

00:41:10.760 --> 00:41:13.710
send data to your virtual destination.

00:41:15.310 --> 00:41:21.180
We saw earlier in the talk how a read
proc looks and how it gets called.

00:41:23.350 --> 00:41:30.160
And the other slightly obscure but
kind of important thing to go over

00:41:30.220 --> 00:41:35.710
here is what happens when you need to
send large system exclusive messages,

00:41:35.710 --> 00:41:40.190
as is common in patch librarian
and sample transfer applications.

00:41:41.810 --> 00:41:45.800
You basically need to slow
down how fast you're sending

00:41:45.800 --> 00:41:48.130
the data from the computer.

00:41:48.280 --> 00:41:50.990
And there's two ways to do that.

00:41:51.030 --> 00:41:54.400
One is to check that
property on the device,

00:41:54.400 --> 00:41:58.990
KMIDI property max SysX speed,
and do your own math to break

00:41:58.990 --> 00:42:03.880
up the message into chunks
so that over time you say,

00:42:03.880 --> 00:42:09.880
okay, every second I'm not going to
send more than 3,125 bytes.

00:42:10.920 --> 00:42:12.360
That's one way to do it.

00:42:12.780 --> 00:42:16.220
Another way to do it is
to call MIDI send SysX,

00:42:16.220 --> 00:42:19.760
which runs its own little
thread and does that for you.

00:42:19.760 --> 00:42:25.310
Here's a brief example of how to do that.

00:42:25.600 --> 00:42:29.000
This function is an example
of how to call MIDI Send SysX.

00:42:29.000 --> 00:42:34.040
You fill out a MIDI Send SysX request
structure with your destination,

00:42:34.040 --> 00:42:37.240
a pointer to your system
exclusive message,

00:42:37.340 --> 00:42:41.400
its length,
and a pointer to a completion function

00:42:41.400 --> 00:42:46.680
that will get called when the last
bit of that message has been sent.

00:42:47.630 --> 00:42:51.520
Then you call midi send sysx,
passing it your request,

00:42:51.520 --> 00:42:57.080
and it will go off and
asynchronously go send that data.

00:42:57.080 --> 00:42:59.880
As with all asynchronous
functions like this,

00:42:59.880 --> 00:43:03.710
and those of you who've been
programming Macintosh for a long

00:43:03.710 --> 00:43:08.610
time all know about the problems of
param blocks with asynchronous calls,

00:43:08.800 --> 00:43:13.400
you want to keep around that sysx
send request until it's completed.

00:43:13.420 --> 00:43:16.680
You know,
this was a bad example in that it's a

00:43:16.750 --> 00:43:22.090
local variable and I'm only vindicated
by the fact that I'm actually pulling

00:43:22.090 --> 00:43:27.730
at the end of the function to see if the
request is complete before I'm allowing

00:43:27.850 --> 00:43:30.960
that request to fall off the stack.

00:43:30.960 --> 00:43:33.730
More typically you might put the
send request in a global variable

00:43:33.730 --> 00:43:38.130
or somewhere else it's going to
persist beyond the function in

00:43:38.170 --> 00:43:41.030
which you call midi send sysx.

00:43:42.630 --> 00:43:46.360
As you saw when I was polling at
the end of the function on the

00:43:46.360 --> 00:43:49.700
complete member of that structure,

00:43:49.870 --> 00:43:53.460
You can look at that to tell
when the function is complete.

00:43:53.460 --> 00:43:58.390
You can also look at the number of
bytes to send because if you initially

00:43:58.390 --> 00:44:03.180
said I want to send 1,000 bytes,
as those bytes actually get sent,

00:44:03.180 --> 00:44:05.100
that number in the
structure will decrement.

00:44:05.100 --> 00:44:08.990
So you can watch the progress if
you want to put up a progress bar.

00:44:09.600 --> 00:44:13.280
and David But going back
to the complete flag,

00:44:13.280 --> 00:44:16.940
you can set that to true
and the system will say,

00:44:16.980 --> 00:44:21.630
"Okay, I'm not going to send any more of
this." You can abort the request.

00:44:21.890 --> 00:44:28.230
And the core MIDI framework will
implement this by running a medium

00:44:28.240 --> 00:44:29.850
priority thread within your app.

00:44:29.850 --> 00:44:33.700
It's a little higher priority
than your user interface,

00:44:33.700 --> 00:44:37.240
but it's not a Mach real-time
thread by any means.

00:44:37.240 --> 00:44:43.640
Okay, let's go over to the demo machine,
please.

00:44:43.640 --> 00:44:51.550
I have two or three things
I'd like to show you here.

00:45:01.520 --> 00:45:06.740
This is a program that will play audio.

00:45:11.410 --> 00:45:20.480
If I just say... And I can have it
play just directly to the audio how.

00:45:20.720 --> 00:45:25.810
Using the hardware timing
characteristics and play that

00:45:25.900 --> 00:45:27.800
sound file as it really should be.

00:45:27.800 --> 00:45:34.130
But I can also play this audio
file synchronized to MIDI timecode

00:45:34.130 --> 00:45:36.580
in this example program.

00:45:36.670 --> 00:45:40.140
Since I don't have a MIDI timecode
source piece of hardware

00:45:40.140 --> 00:45:44.250
that was easy to carry here,
this is the least gear

00:45:44.250 --> 00:45:46.610
I've ever taken to a gig.

00:45:47.400 --> 00:45:52.580
And so we have in this window here,

00:45:53.000 --> 00:45:58.420
and David A virtual source,
which is a MIDI timecode generator.

00:45:58.430 --> 00:46:01.570
And as we see here in the video,

00:46:01.830 --> 00:46:14.270
Playback Controller,
we have two choices of sync source.

00:46:14.270 --> 00:46:14.270
We have the SK500,
which won't send us any

00:46:14.270 --> 00:46:14.270
MIDI timecode and won't let us sync.

00:46:14.270 --> 00:46:14.270
But we also have this virtual
destination sync source.

00:46:15.340 --> 00:46:17.440
So this is stopped.

00:46:17.440 --> 00:46:22.300
I can start the file player and it's
not going to start playing because

00:46:22.300 --> 00:46:25.150
I haven't started the MIDI timecode yet.

00:46:29.380 --> 00:46:30.260
This is unplugged.

00:46:30.260 --> 00:46:31.500
I'm going to plug it in right now, OK?

00:46:31.500 --> 00:46:35.660
Got it now?

00:46:35.710 --> 00:46:47.080
So that's playing back
synchronized to the MIDI timecode.

00:46:47.080 --> 00:46:48.780
I can very speed it.

00:46:48.780 --> 00:46:50.990
I can slow down the rate.

00:47:10.900 --> 00:47:30.600
[Transcript missing]

00:47:32.000 --> 00:47:33.780
and Bobby Tavanian's keynote.

00:47:33.780 --> 00:47:37.690
I've been adding features
to it since then.

00:47:42.740 --> 00:47:46.840
We've got several components here.

00:47:46.840 --> 00:47:50.820
At the top, we just have a simple
MIDI through generator.

00:47:52.240 --> 00:47:54.900
Here we have a MIDI file player.

00:47:54.920 --> 00:47:58.830
It can send through to
the Mac OS X music synth,

00:47:58.830 --> 00:48:02.010
which is the DLS,
the downloadable sample synth

00:48:02.040 --> 00:48:05.940
that Chris mentioned in his talk.

00:48:05.940 --> 00:48:17.790
So let's just open a MIDI file
and send it to the internal synth.

00:48:36.840 --> 00:48:40.750
What's interesting about this is that
this MIDI file player was designed

00:48:40.750 --> 00:48:42.800
for playing to external hardware.

00:48:42.800 --> 00:48:46.420
So it's waking up and saying,
"Play this now!" And the software

00:48:46.580 --> 00:48:48.360
synth is responding that quickly.

00:48:48.360 --> 00:48:53.590
We've got it programmed to be
processing in 64 sample frame chunks,

00:48:53.590 --> 00:48:57.150
which is every one and
a half milliseconds.

00:48:59.260 --> 00:49:01.840
Another little thing I'd like
to show you is that this is

00:49:01.860 --> 00:49:04.080
my new feature in the program.

00:49:04.120 --> 00:49:07.320
I wrote a little MIDI arpeggiator.

00:49:12.300 --> 00:49:19.200
[Transcript missing]

00:49:35.100 --> 00:49:37.740
The impressive thing about
this to me is that if I set

00:49:37.790 --> 00:49:42.440
it up with some drum sounds,
we can start to get a sense

00:49:42.450 --> 00:49:48.940
of how precisely the Mac is
spitting out the sound.

00:49:48.940 --> 00:50:04.560
I don't know if I want
to have fun with that.

00:50:05.100 --> 00:50:06.620
Thank you.

00:50:33.000 --> 00:50:37.980
So here I'd like to trigger some
sounds being locally played here.

00:50:37.990 --> 00:50:42.400
Let me make sure I have local control on.

00:50:55.770 --> 00:50:58.460
Can you tell me for sure that
both the computer and the keyboard

00:50:58.460 --> 00:51:00.940
are getting level right now?

00:51:00.940 --> 00:51:05.300
Okay, here we go.

00:51:05.300 --> 00:51:07.090
Now this is the computer alone.

00:51:18.890 --> 00:51:21.800
Pretty similar on both of
them and is really percussive.

00:51:21.800 --> 00:51:28.650
Okay, this is the Macintosh alone.

00:51:48.200 --> 00:52:05.400
[Transcript missing]

00:52:06.100 --> 00:52:10.750
On this test, I'm playing a sound
on the piano keyboard.

00:52:10.750 --> 00:52:14.390
The lower graph

00:52:15.630 --> 00:52:18.880
is the note just being
triggered from the keyboard.

00:52:18.920 --> 00:52:20.710
The upper graph,

00:52:21.400 --> 00:52:26.780
That note is traveling over USB from
the keyboard to the computer,

00:52:26.780 --> 00:52:30.680
into I/O Kit,
up to the MIDI server process,

00:52:30.680 --> 00:52:35.440
up to a MIDI through application,
back down to the MIDI server,

00:52:35.530 --> 00:52:41.550
back down through I/O Kit in the kernel,
back over USB to the keyboard.

00:52:41.620 --> 00:52:47.790
And we're getting one to two milliseconds
of delay between those two notes.

00:52:54.010 --> 00:52:58.500
This is the one I meant
to show you first.

00:52:58.620 --> 00:53:03.180
Here I was triggering-- actually,
this is a slightly different test.

00:53:03.180 --> 00:53:04.020
I lied.

00:53:04.020 --> 00:53:07.680
This is a different test I did yesterday.

00:53:07.730 --> 00:53:13.720
But here I'm triggering both a
square wave being synthesized

00:53:13.850 --> 00:53:15.810
through the audio HAL.

00:53:17.450 --> 00:53:19.840
The Roland keyboard playing a rim shot.

00:53:19.850 --> 00:53:24.040
And I'm taking excruciating steps
to make sure that they're being

00:53:24.150 --> 00:53:26.380
triggered at the exact same time.

00:53:26.420 --> 00:53:29.300
So from that time,

00:53:30.700 --> 00:53:34.200
We're only hearing one millisecond
of difference between when the sound

00:53:34.200 --> 00:53:37.900
comes out of the Macintosh and when
the sound comes out of the synthesizer.

00:53:37.900 --> 00:53:41.070
The synthesizer being triggered
by MIDI is getting it first and,

00:53:41.070 --> 00:53:43.290
you know,
it's optimized for this kind of thing.

00:53:43.300 --> 00:53:47.360
But it's still only in the realm of
under two milliseconds between the

00:53:47.360 --> 00:53:50.610
time we're telling the computer,
play this bit of audio,

00:53:50.610 --> 00:53:52.850
and the time it comes out the speaker.

00:53:52.860 --> 00:53:54.330
I think that's pretty impressive.

00:53:54.360 --> 00:53:58.980
I think it's a testimony to the guys
in the kernel and the IOCit team.

00:54:00.320 --> 00:54:03.980
It's just an amazing system and I'm
really proud of what they've done.

00:54:03.980 --> 00:54:06.020
It's made it all possible for us.

00:54:15.100 --> 00:54:24.620
So to sum up here, the MIDI services are
available in system 10.0.x.

00:54:24.620 --> 00:54:28.760
There is some existing documentation
in the framework header files.

00:54:28.760 --> 00:54:32.600
I believe one of them is
currently HeaderDoc'd.

00:54:32.600 --> 00:54:36.620
The application one, the driver one,
is a little sketchier.

00:54:36.620 --> 00:54:39.100
But all that's about to change.

00:54:39.100 --> 00:54:41.170
At least on the application side,
we're going to have some

00:54:41.170 --> 00:54:42.600
really extensive documentation.

00:54:43.100 --> 00:54:48.950
Those of you who are working on hardware,
there's an example driver.

00:54:48.950 --> 00:54:52.520
And you can get in touch with
developer relations and us,

00:54:52.550 --> 00:54:55.290
and we can help you with
problems if you have questions

00:54:55.340 --> 00:54:57.220
about driver documentation.

00:54:59.410 --> 00:55:02.230
There are some examples
in developer examples,

00:55:02.330 --> 00:55:04.300
core audio MIDI.

00:55:04.300 --> 00:55:09.500
As Bill has been mentioning,
we are getting an SDK out soon.

00:55:09.500 --> 00:55:12.300
We're hoping to improve
our documentation.

00:55:12.300 --> 00:55:14.920
There should be some
more out really soon now.

00:55:14.920 --> 00:55:18.300
Thank you very much.

00:55:27.200 --> 00:55:32.440
If we can have the slides machine up,
that would be good.

00:55:32.510 --> 00:55:39.000
I have just a brief walkthrough of
some of the Java code that does a

00:55:39.000 --> 00:55:44.380
similar thing to what Doug's demo did,
just to sort of see the MIDI side

00:55:44.380 --> 00:55:47.040
of what I showed last session,
and then we'll do some Q&A.

00:55:47.200 --> 00:55:51.070
It'll

00:55:51.600 --> 01:00:34.400
[Transcript missing]

01:00:34.760 --> 01:00:38.800
Then I'm going to look to see if
there's a note on or a note off command,

01:00:38.800 --> 01:00:41.390
and basically just
send that to the synth.

01:00:41.400 --> 01:00:43.490
If it's not a note on
or note off command,

01:00:43.500 --> 01:00:47.810
then I'm going to do some parsing
based on the MIDI spec of whether

01:00:47.840 --> 01:00:52.050
it's going to have a two- or
three-byte data segment to it,

01:00:52.120 --> 01:00:53.410
and then just send that.

01:00:53.440 --> 01:00:58.550
Then all I do is send that
MIDI event to the music synth.

01:00:58.560 --> 01:01:02.780
It's a fairly simple code to just
pull the MIDI data out of that packet.

01:01:02.920 --> 01:01:06.110
There could be more than one
MIDI message in that packet,

01:01:06.120 --> 01:01:08.640
so there's a little bit of work
you have to do to just parse it.

01:01:08.720 --> 01:01:11.520
Then I just send that MIDI data.

01:01:11.520 --> 01:01:13.750
If you look at the
interface of the program,

01:01:13.760 --> 01:01:17.000
it lets you do some
alternate stuff on channels.

01:01:17.040 --> 01:01:21.160
It lets you do some stuff
with transposing the data

01:01:21.160 --> 01:01:22.640
and all that kind of stuff.

01:01:22.700 --> 01:01:28.220
This example is a little bit
revised from what's available in

01:01:28.220 --> 01:01:31.590
your developer section of your CD,
and we'll put this up on the

01:01:31.590 --> 01:01:32.720
website as part of the SDM.

01:01:32.920 --> 01:01:36.680
You can go to the CDK next week to
help you along with the Java stuff.

01:01:36.730 --> 01:01:39.220
It's actually pretty similar
to the C stuff anyway.

01:01:39.220 --> 01:01:41.660
If we could just go back
to slides very quickly.

01:01:45.530 --> 01:01:50.860
So that's just the same thing
as I went through last session.

01:01:50.860 --> 01:01:53.840
There's Java doc available
for this as well.

01:01:53.840 --> 01:01:58.490
And it's really architectural rather
than language sort of specific

01:01:58.560 --> 01:02:02.690
documentation that we're generating
that will be available on the website.

01:02:02.870 --> 01:02:07.730
And the Java API presents the
same functionality as the C API.

01:02:07.770 --> 01:02:11.810
Resources, we've got a mailing list,
list.apple.com,

01:02:11.880 --> 01:02:16.420
and there's also developer website,
developer.apple.com/audio.

01:02:16.730 --> 01:02:18.800
We're still in the process
of getting that website up,

01:02:18.900 --> 01:02:21.790
so if you look at it
today or over the weekend,

01:02:21.810 --> 01:02:24.020
it may not be the same as
what it will be next week.

01:02:24.100 --> 01:02:27.600
So you might want to
check next week as well.

01:02:27.790 --> 01:02:29.080
And we'll be getting stuff out.

01:02:29.190 --> 01:02:32.940
There's some related session information,
and as with the end of Friday,

01:02:32.940 --> 01:02:36.000
DVD people, you should look at it.

01:02:36.070 --> 01:02:38.060
Freeze, pause that frame.

01:02:38.060 --> 01:02:42.730
If you're doing any hardware development,
FireWire USB, if you're doing any sort

01:02:42.730 --> 01:02:45.780
of PCI development that's
got to do with audio,

01:02:45.900 --> 01:02:47.700
you can contact Craig Keithley.

01:02:47.890 --> 01:02:50.340
He's the developer
relations person for that.

01:02:50.370 --> 01:02:53.250
If you're interested in
getting access for seeding,

01:02:53.250 --> 01:02:55.540
you can contact us at audio@apple.com.

01:02:55.590 --> 01:02:58.350
And I'd like to thank you
all very much for coming,

01:02:58.350 --> 01:03:00.610
especially late Friday afternoon.
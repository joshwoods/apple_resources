WEBVTT

00:00:00.640 --> 00:00:06.130
Please welcome John Burkey,
Java Class' Team Technical Lead.

00:00:14.000 --> 00:00:14.920
Hi everybody.

00:00:14.970 --> 00:00:18.220
So I'm going to talk about
a lot of things today.

00:00:18.220 --> 00:00:20.960
Let me grab my little clicker.

00:00:20.960 --> 00:00:26.740
We're going to divide the
talk into three sections.

00:00:26.780 --> 00:00:30.700
And this is how I work it.

00:00:30.700 --> 00:00:30.700
There's me.

00:00:31.960 --> 00:00:36.210
And so our three sections are
we do a features overview of

00:00:36.210 --> 00:00:39.790
what Mac OS X Java is about,
the Java 2D and things like that.

00:00:39.860 --> 00:00:43.100
That's, I think, important because we've
got a mixed crowd here,

00:00:43.140 --> 00:00:43.790
I think.

00:00:43.800 --> 00:00:48.510
Tips and techniques for how to
make your apps high quality,

00:00:48.550 --> 00:00:51.460
high speed,
and including some of the things that

00:00:51.460 --> 00:00:54.610
are different about our platform,
which is why they're really important.

00:00:54.620 --> 00:00:58.000
And also our update, which is coming up,
and the exciting new technology

00:00:58.000 --> 00:00:59.370
that's part of the update.

00:00:59.380 --> 00:01:01.780
And then we'll go to Q&A at the end.

00:01:01.900 --> 00:01:06.450
So first of all, can I have a show of
hands for Java developers?

00:01:06.460 --> 00:01:08.550
Everybody's a Java developer, good.

00:01:08.560 --> 00:01:12.020
And so how about a show of hands
of people who are Mac OS X people

00:01:12.030 --> 00:01:13.800
who just heard about Java.

00:01:15.340 --> 00:01:16.140
A couple.

00:01:16.140 --> 00:01:16.390
So cool.

00:01:16.540 --> 00:01:17.040
Partisan crowd.

00:01:17.070 --> 00:01:19.290
So, great.

00:01:19.300 --> 00:01:25.980
So this is Gerard Ziemski,
and he'll be assisting me today.

00:01:26.880 --> 00:01:29.020
So, Mac OS X Java.

00:01:29.150 --> 00:01:30.790
Finally we have Java 2.

00:01:30.850 --> 00:01:31.500
It's been a long time coming.

00:01:36.420 --> 00:01:39.680
We've worked really hard and
Sun's been really great to work

00:01:39.710 --> 00:01:42.120
with and we finally have Java 2.

00:01:42.150 --> 00:01:46.760
And as you guys know,
a big part of that is Java 2D.

00:01:47.830 --> 00:01:50.640
Java Graphics,
from sort of the Mac OS X perspective,

00:01:50.640 --> 00:01:54.300
I like to look at it as,
just like Quartz, it's PDF rendering.

00:01:54.300 --> 00:01:59.420
It's, you know, general shapes,
a lot of different things that PDF has,

00:01:59.420 --> 00:02:03.940
and because we are on top of Quartz,
we can actually generate PDF, too.

00:02:03.940 --> 00:02:05.330
We'll talk more about
that in a little while.

00:02:05.340 --> 00:02:09.000
Also,
we're an object API on top of Quartz.

00:02:09.000 --> 00:02:11.570
I just want to point that
out because I think we have

00:02:11.590 --> 00:02:14.840
some really good advantages,
a really good one-two punch,

00:02:14.840 --> 00:02:18.140
because we have Quartz,
which is our OS graphics system,

00:02:18.140 --> 00:02:20.670
and we have Java 2D,
which is a great object wrapper,

00:02:20.670 --> 00:02:22.810
and I think together
they work really well.

00:02:22.820 --> 00:02:24.090
I'll go into that, too.

00:02:24.100 --> 00:02:27.020
And also,
this is actually really important.

00:02:27.020 --> 00:02:31.490
Again, you're a partisan, but, you know,
the way we build these things is we use

00:02:31.490 --> 00:02:35.120
the other APIs to build the nice API,
as far as I'm concerned.

00:02:35.120 --> 00:02:37.560
And so what you guys get,
which is just great,

00:02:37.560 --> 00:02:38.960
is you get the same API.

00:02:39.060 --> 00:02:40.500
You get the same API with
just a few lines of code.

00:02:40.500 --> 00:02:42.480
You can render to screen,
render to offscreen,

00:02:42.540 --> 00:02:43.790
you can render to printers.

00:02:43.800 --> 00:02:45.430
I think that's really great.

00:02:45.510 --> 00:02:47.620
I was a Java developer
for a long time before,

00:02:47.620 --> 00:02:51.090
as long as any, whatever, three years,
right, before I came to Apple,

00:02:51.160 --> 00:02:54.370
and that was one of the best things
I thought about Java was that just

00:02:54.370 --> 00:02:58.020
you whip out a few lines of code
and you can render almost anywhere.

00:02:58.020 --> 00:02:59.150
So I really like that.

00:03:02.200 --> 00:03:06.140
So, to the features,
what I'm going to do is first just

00:03:06.200 --> 00:03:09.810
cover sort of each of these real quick,
and then we'll go to the

00:03:09.820 --> 00:03:11.720
Java 2D demo and just point them out.

00:03:11.720 --> 00:03:13.460
We wanted to sort of cover
that because some of this

00:03:13.590 --> 00:03:14.750
technology is still pretty new.

00:03:14.750 --> 00:03:17.260
It's just good to do a quick summary.

00:03:17.610 --> 00:03:20.880
So general paths and shapes.

00:03:20.910 --> 00:03:24.020
A quick way to say that is that

00:03:24.310 --> 00:03:26.550
Basically,
any shape you can do with Bezier, Pass,

00:03:26.580 --> 00:03:29.760
and Quadratics,
you can do with the General Path API.

00:03:29.760 --> 00:03:36.040
And that goes from lines and rectangles
all the way up to the kind of things

00:03:36.050 --> 00:03:37.600
you'll see in the Java 2D demo.

00:03:37.600 --> 00:03:40.160
So that means,
for the first time in Java,

00:03:40.160 --> 00:03:43.500
we can do all the things we need to
do to do professional applications.

00:03:43.500 --> 00:03:48.630
Then we can take those shapes, whatever,
from rectangles all the way up,

00:03:48.690 --> 00:03:50.660
and we can fill them
with whatever we want.

00:03:52.160 --> 00:03:57.280
What I like about Sun's APIs is what
they tend to do is define a nice,

00:03:57.320 --> 00:04:02.710
real, open, easy-to-customize API,
and then they tend to have an example

00:04:02.710 --> 00:04:04.760
or two that is the common use.

00:04:04.760 --> 00:04:08.080
So in the case of custom fills,
we have textures and gradients,

00:04:08.080 --> 00:04:11.250
and they've defined these for us,
and they work just great.

00:04:11.390 --> 00:04:13.950
And we actually, as a team,
try to optimize those cases

00:04:13.950 --> 00:04:17.160
so that you can get the best
performance using the built-in ones,

00:04:17.160 --> 00:04:19.480
because we can guess a lot
better about how things work.

00:04:20.120 --> 00:04:23.580
So then on top of that,
we have completely custom fills.

00:04:23.580 --> 00:04:27.000
You can actually define your own paint,
actually, it's called in Java 2D,

00:04:27.000 --> 00:04:28.950
and do whatever you want for your paint.

00:04:28.960 --> 00:04:29.720
So that's really nice.

00:04:29.720 --> 00:04:32.120
You supply, you know,
maybe there's some new way to do

00:04:32.120 --> 00:04:33.940
filling that we don't know about yet.

00:04:33.940 --> 00:04:34.990
You can do whatever you want in there.

00:04:35.000 --> 00:04:37.010
But textures and
gradients work just great.

00:04:37.040 --> 00:04:39.490
Custom strokes.

00:04:39.500 --> 00:04:41.520
So same kind of idea here.

00:04:41.520 --> 00:04:42.420
This is really good, I think.

00:04:42.420 --> 00:04:46.390
What you can do is you can define,
you can stroke an arbitrary line

00:04:46.390 --> 00:04:48.550
or curve with any shape you want.

00:04:48.580 --> 00:04:52.020
You basically... You can be
called back and you can say,

00:04:52.020 --> 00:04:54.690
hey, this is the shape I want you
to spray all over my line.

00:04:54.700 --> 00:04:58.180
However, they also have basic stroke,
which is one of these

00:04:58.220 --> 00:05:00.490
ones they have built in,
and that lets you do

00:05:00.490 --> 00:05:02.120
dashes and line widths,
et cetera.

00:05:02.120 --> 00:05:05.980
So custom compositing, same kind of idea.

00:05:05.980 --> 00:05:07.360
You define the blit.

00:05:07.500 --> 00:05:10.100
So it's like having copy
bits for all us old Mac guys.

00:05:10.100 --> 00:05:11.770
But you can do whatever you want.

00:05:11.860 --> 00:05:12.340
So that's great.

00:05:12.520 --> 00:05:13.450
And it's all in Java.

00:05:13.460 --> 00:05:15.540
So that's great, too,
because you don't have to deal with all

00:05:15.540 --> 00:05:17.900
the kind of things you run into when
you run off the end of your blitter,

00:05:17.900 --> 00:05:18.360
et cetera.

00:05:18.360 --> 00:05:19.310
So that's nice.

00:05:20.140 --> 00:05:21.950
You know, of course it doesn't work,
but at least you get an

00:05:21.960 --> 00:05:23.160
exception instead of a crash.

00:05:23.160 --> 00:05:27.880
So and then also, this is another one of
these that has one built in.

00:05:27.880 --> 00:05:29.440
It's got alpha compositing built in.

00:05:29.440 --> 00:05:32.650
And, of course,
with the different engines

00:05:32.650 --> 00:05:37.020
that we use to implement this,
that operation is built in.

00:05:37.040 --> 00:05:40.270
So we'll get more into what
I mean by that in a minute.

00:05:40.280 --> 00:05:44.160
But the main thing is that
you've got custom compositing.

00:05:44.160 --> 00:05:46.270
You can define to do whatever
you want to do when you blit.

00:05:46.410 --> 00:05:47.990
And you've got alpha
compositing built in.

00:05:48.000 --> 00:05:50.250
Porta-deft compositing rules,
which is what... The court

00:05:50.250 --> 00:05:50.950
supports natively.

00:05:50.960 --> 00:05:53.750
And, of course,
it's completely portable code.

00:05:53.760 --> 00:05:54.430
You guys know that.

00:05:54.440 --> 00:05:54.880
Partisan.

00:05:57.620 --> 00:06:00.240
So, we'll do a quick overview
of the Java 2D demo.

00:06:00.240 --> 00:06:01.240
This is the Sun demo.

00:06:01.240 --> 00:06:03.100
I just wanted to do a quick
overview of the features.

00:06:03.100 --> 00:06:04.880
Gerard, do you want to start it up?

00:06:04.880 --> 00:06:05.230
Oh, you got it up.

00:06:05.280 --> 00:06:05.480
Great.

00:06:07.640 --> 00:06:11.000
So we're just going to
do a few of the panels.

00:06:11.000 --> 00:06:12.520
Most people have seen this,
but we're just going to

00:06:12.630 --> 00:06:13.340
point out a few things.

00:06:13.340 --> 00:06:16.530
So you'll see in this one,
this is the stroking stuff we were

00:06:16.570 --> 00:06:18.480
talking about in the last slide.

00:06:18.500 --> 00:06:20.000
They call it lines here.

00:06:20.000 --> 00:06:21.760
And you'll notice that you can do dashes.

00:06:21.760 --> 00:06:24.180
That's all basic strokes
in the top right.

00:06:24.200 --> 00:06:27.040
You can do the different types of caps.

00:06:27.040 --> 00:06:32.140
You can build that thing.

00:06:32.140 --> 00:06:34.680
The arrows are thick lines
with different kinds of caps.

00:06:34.680 --> 00:06:37.340
They're just giving good examples of
different kinds of things you can do.

00:06:37.500 --> 00:06:39.690
You can switch it.

00:06:42.830 --> 00:06:45.590
So here's Arcs and Curves,
and the most interesting

00:06:45.590 --> 00:06:47.660
one is where the cursor is.

00:06:47.730 --> 00:06:50.560
That's a Bezier animation,
and what's interesting

00:06:50.560 --> 00:06:51.800
is there's a gradient.

00:06:51.970 --> 00:06:57.190
Phil, why don't you click on that
and make that the big boy?

00:06:57.680 --> 00:07:01.750
and then, yeah, stop it for a sec.

00:07:01.800 --> 00:07:05.850
And then switch the draw choice to, yeah.

00:07:06.800 --> 00:07:15.800
[Transcript missing]

00:07:16.080 --> 00:07:20.180
So you saw a texture and a dash stroke.

00:07:20.340 --> 00:07:21.800
So that's pretty cool.

00:07:21.800 --> 00:07:23.500
You define the shape and then
you decide how to fill it,

00:07:23.500 --> 00:07:24.340
how to stroke it.

00:07:24.340 --> 00:07:27.350
And the stroke really is in a way,
both a geometry,

00:07:27.370 --> 00:07:29.360
because you can do dashes
and things like that,

00:07:29.360 --> 00:07:30.700
and a fill for that geometry.

00:07:30.700 --> 00:07:32.760
So that's pretty flexible.

00:07:32.760 --> 00:07:34.760
And all via object API, of course.

00:07:34.780 --> 00:07:38.080
So go to the next one,
I forget which we had.

00:07:41.360 --> 00:07:42.300
So this is a good one, too.

00:07:42.300 --> 00:07:45.700
I think they do a good job of
making them informative and playful.

00:07:45.700 --> 00:07:49.890
So the guy in the top left
is actually an animated GIF.

00:07:49.960 --> 00:07:51.010
That's why he marches.

00:07:51.020 --> 00:07:52.010
So that's cool.

00:07:52.010 --> 00:07:53.780
It's built into the images.

00:07:53.780 --> 00:07:57.030
If you draw any animated GIF,
if you put it into an image icon,

00:07:57.030 --> 00:07:59.140
et cetera, they'll animate,
which is kind of cool.

00:07:59.140 --> 00:08:03.480
But anyway, why don't you yank those
sliders on the top right one?

00:08:03.480 --> 00:08:08.420
There's some built-in image operations,
too, and they do different

00:08:08.490 --> 00:08:10.480
kinds of operations.

00:08:11.300 --> 00:08:14.600
On the images, you can do color mixtures
and some other things.

00:08:14.600 --> 00:08:15.450
So that's pretty cool.

00:08:15.450 --> 00:08:16.540
There's several built-in.

00:08:16.540 --> 00:08:17.540
You can define your own again, too.

00:08:17.540 --> 00:08:18.190
So that's pretty neat.

00:08:18.240 --> 00:08:22.320
And then, of course,
I guess that's some kind of sheer filter,

00:08:22.320 --> 00:08:26.070
warp image, but it's doing some kind
of sheer transform matrix.

00:08:26.080 --> 00:08:27.980
And I think we had one more, right?

00:08:29.300 --> 00:08:31.330
and I'm just trying to stay light
because we have a lot to cover,

00:08:31.330 --> 00:08:32.260
so we're just going to
do a quick overview.

00:08:32.260 --> 00:08:36.070
So here is another pretty
big part of Java 2D and,

00:08:36.070 --> 00:08:36.760
of course, Quartz.

00:08:36.760 --> 00:08:39.580
Why don't you mess with the scale, shear,
and rotate?

00:08:39.580 --> 00:08:42.290
I know this is all obvious,
but I'm just pointing it out.

00:08:42.320 --> 00:08:45.600
So there's the scale, of course,
the shear, and the rotate.

00:08:45.600 --> 00:08:47.320
These are all built in.

00:08:47.320 --> 00:08:47.920
They're all standard.

00:08:47.920 --> 00:08:49.580
It's standard PDF kind of language.

00:08:49.580 --> 00:08:52.620
There's a transform matrix,
and I find transform, 3x2,

00:08:52.620 --> 00:08:54.940
just like in Quartz,
just like in several other things.

00:08:54.940 --> 00:08:55.460
It's great.

00:08:55.520 --> 00:08:57.450
It's standard,
and because it's Object API with

00:08:57.450 --> 00:08:59.370
garbage-collected objects,
you don't have to worry about

00:08:59.430 --> 00:09:01.280
the kind of things they have to
worry about in the native APIs,

00:09:01.280 --> 00:09:01.960
so I like that.

00:09:01.960 --> 00:09:06.420
So also, good news for us Mac OS X guys.

00:09:06.450 --> 00:09:10.360
The Quartz engine does really
well against the other platforms

00:09:10.480 --> 00:09:11.480
and this kind of stuff.

00:09:11.480 --> 00:09:15.120
We've measured a lot against
Windows machines for these kinds

00:09:15.120 --> 00:09:18.050
of Bezier animations and things,
and at the high end,

00:09:18.050 --> 00:09:21.970
we do really well with this engine,
so we're really happy with that

00:09:21.980 --> 00:09:23.810
because they did a lot of great work.

00:09:23.910 --> 00:09:26.280
They're a lot more knowledgeable
than we are about graphics,

00:09:26.280 --> 00:09:26.980
and graphics.

00:09:27.280 --> 00:09:30.920
And we were able to take the Sun engine,
put it aside,

00:09:30.920 --> 00:09:33.610
and hook up to the Quartz engine instead,
and it was really great.

00:09:33.640 --> 00:09:38.450
So you can... Yeah,
we can go back to slides.

00:09:38.460 --> 00:09:39.690
Thank you.

00:09:42.870 --> 00:09:47.980
So let me just click over here.

00:09:48.200 --> 00:09:51.490
Back to the Mac OS X bonuses,
which I started to cover.

00:09:51.490 --> 00:09:52.400
It's Quartz.

00:09:52.400 --> 00:09:55.550
It's not a ported,
used every once in a while engine,

00:09:55.550 --> 00:09:58.700
which as good as Sun's engine is,
that is what it is.

00:09:58.700 --> 00:10:02.900
They avoid using it whenever they can,
whereas in Quartz, actually,

00:10:02.900 --> 00:10:06.370
it's the OS graphic system,
so we have a lot greater fidelity

00:10:06.510 --> 00:10:08.690
and a lot more resources behind it.

00:10:08.700 --> 00:10:11.080
And that's really great for us Java guys,
because as I said,

00:10:11.080 --> 00:10:13.130
the smart guys work on that
in Graff and Eno's group,

00:10:13.130 --> 00:10:14.780
and they do all the hard work there.

00:10:14.780 --> 00:10:17.890
So a couple of things that I think
are great for us Java guys,

00:10:18.030 --> 00:10:21.140
though, is there's no raw
Quartz function calling.

00:10:21.140 --> 00:10:25.300
The other ways to use Quartz always
involve calling C APIs and pointers.

00:10:25.300 --> 00:10:26.470
So we get to avoid that.

00:10:26.470 --> 00:10:29.500
We get the same fidelity and all
the same access to everything.

00:10:29.500 --> 00:10:32.420
And on top of it, we get things like
compositing and strokes.

00:10:32.490 --> 00:10:35.980
We get custom things built into
Java that aren't available in other APIs.

00:10:36.050 --> 00:10:37.250
That's pretty cool.

00:10:37.260 --> 00:10:40.070
So it's a real good... One,
two of the built-in

00:10:40.070 --> 00:10:42.160
Apple technologies in Java 2D.

00:10:42.160 --> 00:10:44.060
Print to PDF comes for free.

00:10:44.060 --> 00:10:45.580
That's pretty cool.

00:10:45.580 --> 00:10:47.910
Even if you don't hook it
up in some way in your app,

00:10:47.910 --> 00:10:50.680
every time you print,
as I'm sure most of you have noticed,

00:10:50.680 --> 00:10:52.470
there's always that preview to PDF.

00:10:52.470 --> 00:10:55.660
In fact, that's always generated,
so there's always PDF there.

00:10:55.660 --> 00:10:56.860
It's pretty cool.

00:10:56.860 --> 00:11:00.820
And then we'll go into more
Mac OS X bonuses in the third section.

00:11:06.900 --> 00:11:08.800
This next section is on performance.

00:11:08.800 --> 00:11:10.790
It's tips and techniques you can do.

00:11:10.800 --> 00:11:12.560
There are some of these
that are really important,

00:11:12.560 --> 00:11:15.220
some of these are more nuance-y,
but I think they're all worth mentioning.

00:11:15.240 --> 00:11:20.490
The four major areas are image creation,
that's actually one

00:11:20.490 --> 00:11:25.860
of the most important,
rendering hints, double buffering,

00:11:25.860 --> 00:11:28.430
and live window resizing.

00:11:33.040 --> 00:11:37.500
So image creation,
the key high-level message here is

00:11:37.500 --> 00:11:41.540
you want to use create-compatible
image or the 1.1 create image.

00:11:41.540 --> 00:11:44.190
I'm going to show that
in code in just a sec.

00:11:44.200 --> 00:11:47.280
But I also want to mention that
there's a whole pile of image types

00:11:47.280 --> 00:11:49.500
that are really cool that we have now.

00:11:49.500 --> 00:11:51.790
But the fact is we will
optimize first for the ones

00:11:51.790 --> 00:11:53.500
that are native on our platform.

00:11:53.500 --> 00:11:56.310
And so these aren't going
to be optimized for first.

00:11:57.540 --> 00:12:01.240
And importantly, there's sort of a little
thing that all of us do,

00:12:01.250 --> 00:12:05.580
right, is we set up our app and
getting close to shipping,

00:12:05.580 --> 00:12:08.770
and then we want to squeeze a little
extra performance out of our app.

00:12:08.850 --> 00:12:13.340
So usually what I do is I rig up
my performance analysis tools,

00:12:13.340 --> 00:12:17.280
either just timing or some tool,
hopefully, like we now have

00:12:17.280 --> 00:12:18.640
optimized in our platform.

00:12:18.640 --> 00:12:21.980
And then I look and see, well,
where's my soft spots, right?

00:12:21.980 --> 00:12:25.180
So when I find something
that just feels slow,

00:12:25.180 --> 00:12:26.340
I go work on it.

00:12:26.390 --> 00:12:27.520
So one of the things that people will do.

00:12:27.540 --> 00:12:28.460
One of the things that people will
do is they'll go in here and say,

00:12:28.460 --> 00:12:32.170
hey, I'm in a Windows machine,
so BGR must be really fast.

00:12:32.180 --> 00:12:33.500
And sometimes it will be.

00:12:33.540 --> 00:12:35.590
On our platform, it won't be.

00:12:35.600 --> 00:12:39.130
And I would really prefer if you always
call it create compatible image because

00:12:39.130 --> 00:12:42.880
we're working really hard to figure out,
based on what's going on underneath you,

00:12:42.880 --> 00:12:44.220
to give you the right stuff.

00:12:44.220 --> 00:12:48.740
And if you're going to do image
manipulation via the pixels directly,

00:12:48.740 --> 00:12:51.300
I can totally understand where you
want to grab an ARGB or something

00:12:51.300 --> 00:12:52.540
like that to make it simple.

00:12:52.540 --> 00:12:57.020
The good news is that one in particular
is actually a native image format anyway,

00:12:57.020 --> 00:12:57.510
so it will be fine.

00:12:57.570 --> 00:12:57.850
It's pretty fast.

00:12:57.860 --> 00:13:00.510
But if you're not doing
direct image manipulation,

00:13:00.510 --> 00:13:01.680
it's best not to guess.

00:13:01.680 --> 00:13:04.090
Because we're trying our
best to pick the right one.

00:13:04.100 --> 00:13:06.170
So I think I said that enough.

00:13:06.180 --> 00:13:10.260
So now what we're going to do,
if we can go to demo three.

00:13:16.960 --> 00:13:19.340
So we'll just do some
little code snippets.

00:13:19.400 --> 00:13:24.130
Let me just... This is JBuilder.

00:13:34.200 --> 00:14:59.000
[Transcript missing]

00:15:01.200 --> 00:15:03.960
I don't think I need
to run the thing now.

00:15:03.960 --> 00:15:05.530
I'll run it once each way.

00:15:05.530 --> 00:15:07.380
You'll see everything works the same.

00:15:07.380 --> 00:15:11.520
This particular demo is meant
to be simple and not beautiful,

00:15:11.620 --> 00:15:13.200
so excuse me for my graphics.

00:15:17.510 --> 00:15:19.260
Very nice.

00:15:19.400 --> 00:15:22.340
So the green box is rendered.

00:15:22.340 --> 00:15:24.410
I'll show you that in the code.

00:15:25.100 --> 00:15:34.900
[Transcript missing]

00:15:35.400 --> 00:15:54.900
[Transcript missing]

00:15:55.620 --> 00:15:57.360
So now what we're doing is
we're making an image again,

00:15:57.390 --> 00:16:00.570
except that instead of guessing,
we're being maybe too

00:16:00.570 --> 00:16:03.990
clever for ourselves,
and we're making the image ourselves.

00:16:04.010 --> 00:16:09.350
Looks exactly the same, RGB,
but maybe too much information.

00:16:09.620 --> 00:16:14.990
So again, just to reinforce,
it's best to call Create Image or

00:16:14.990 --> 00:16:21.120
get Graphics Configuration
and Create Compatible Image.

00:16:21.120 --> 00:16:23.570
So back to slides.

00:16:30.800 --> 00:16:31.800
and the code.

00:16:31.800 --> 00:16:33.650
So rendering hints.

00:16:33.740 --> 00:16:40.200
These are interesting and
this is more of a nuance,

00:16:40.200 --> 00:16:41.100
but as we move forward we'll be taking
advantage of these more and more.

00:16:41.300 --> 00:18:31.600
[Transcript missing]

00:18:38.300 --> 00:18:44.270
Okay, so... let me get organized.

00:18:44.440 --> 00:18:47.510
So, what we did here was...

00:18:51.000 --> 00:18:55.440
Sorry, just indenting is a little weird.

00:18:55.440 --> 00:19:00.020
What we did here was
we just drew two lines.

00:19:00.320 --> 00:19:03.460
and I just wanted to show you the
anti-aliasing hand for primitives.

00:19:03.460 --> 00:19:05.200
I'm just going to run that.

00:19:05.200 --> 00:19:07.200
It's going to build it.

00:19:07.200 --> 00:19:08.880
I love the speed here.

00:19:08.880 --> 00:19:13.190
This is what we use every day
because of the productivity.

00:19:13.190 --> 00:19:13.190
So anyway,

00:19:14.170 --> 00:19:16.590
So there's one line that's
antialiased and one line that's not.

00:19:16.750 --> 00:19:18.100
I just wanted to show
how that hint worked.

00:19:18.100 --> 00:19:22.100
And so I'll flip the thing off,
and we'll see it the other way.

00:19:22.100 --> 00:19:24.100
And then I'll just delve into
the hints here while I'm here,

00:19:24.100 --> 00:19:28.100
because JBuilder provides a good
assist for this particular thing.

00:19:28.100 --> 00:19:31.310
So I'll flip this off.

00:19:34.320 --> 00:19:36.440
Oops, I think I debugged.

00:19:36.440 --> 00:19:37.080
Stop that.

00:19:37.080 --> 00:19:39.960
Okay.

00:19:39.960 --> 00:19:41.380
So here's running.

00:19:47.500 --> 00:19:53.570
and John Burkey, Gerard Ziemski.

00:19:54.960 --> 00:19:58.090
and David This is a great
feature of JBuilder.

00:19:58.090 --> 00:20:00.620
I'm not giving a JBuilder demo,
but it's just perfect for this.

00:20:00.620 --> 00:20:02.900
So let's say I want to
do a different hint.

00:20:02.900 --> 00:20:06.900
I'm just going to copy this.

00:20:06.900 --> 00:20:08.580
And oops.

00:20:08.580 --> 00:20:10.890
So be there in a sec.

00:20:13.160 --> 00:20:14.740
I'm just going to hit dot here.

00:20:14.740 --> 00:20:16.640
Here's all the sun hints right here.

00:20:17.100 --> 00:20:20.880
Here's the different keys.

00:20:20.880 --> 00:20:23.240
We've got color rendering,
default quality speed,

00:20:23.240 --> 00:20:25.960
as I mentioned before, dithering,
fractional metrics,

00:20:25.960 --> 00:20:32.440
interpolation for when we blit images,
how we do the pixel smoothing.

00:20:32.440 --> 00:20:36.410
There's the rendering quality speed,
stroke.

00:20:36.430 --> 00:20:39.320
There's a whole bunch of them.

00:20:39.400 --> 00:20:40.890
So that's really cool, though.

00:20:40.890 --> 00:20:42.860
Easy way to demo the
hints to show you that.

00:20:42.880 --> 00:20:44.360
There are quite a lot of them.

00:20:44.360 --> 00:20:47.420
We ignore most of them now,
but we will be adding them as we go.

00:20:47.420 --> 00:20:50.820
As I said,
we definitely do the antialiasing one.

00:20:50.820 --> 00:20:54.720
So I'm going to put that
back in and then do,

00:20:54.720 --> 00:20:57.190
I'll just grab all this.

00:21:07.300 --> 00:21:37.700
[Transcript missing]

00:21:43.300 --> 00:21:45.300
So can we go back to slides?

00:21:45.300 --> 00:21:50.970
So there's rendering hints.

00:21:52.590 --> 00:21:55.110
Again,
anti-aliasing and text anti-aliasing.

00:21:55.110 --> 00:21:57.020
I should just point this out.

00:21:57.120 --> 00:22:00.630
Some of the old 1.0 applets,
like there's an old clock,

00:22:00.640 --> 00:22:02.260
there's a second hand that sweeps.

00:22:02.260 --> 00:22:06.980
Does the erase with white or draw
myself again with white to erase?

00:22:06.980 --> 00:22:09.740
On 10, that leaves a blurred trail.

00:22:09.740 --> 00:22:12.960
And that's because on 10,
anti-aliasing is on by default

00:22:12.960 --> 00:22:14.960
where on other platforms it isn't.

00:22:15.000 --> 00:22:18.530
And when you do erase
with white on top of,

00:22:18.530 --> 00:22:22.480
let's say, a draw with black,
let's say of an anti-aliasing,

00:22:22.500 --> 00:22:24.720
you don't get coverage
over all the pixels,

00:22:24.720 --> 00:22:26.590
so it doesn't just stamp it all out.

00:22:26.650 --> 00:22:28.480
So because of that,
you'll leave trails if

00:22:28.480 --> 00:22:29.690
you use that technique.

00:22:29.710 --> 00:22:31.920
The graphic systems
are pretty fast today,

00:22:31.920 --> 00:22:34.840
so we'll get more into that in a minute,
as I was saying.

00:22:34.840 --> 00:22:38.260
So I would recommend not using that
technique for rendering anymore.

00:22:38.260 --> 00:22:40.400
That was something we
did in the old days.

00:22:43.290 --> 00:22:44.190
Double buffering.

00:22:44.200 --> 00:22:45.420
This is important.

00:22:45.420 --> 00:22:51.380
We mentioned this last year,
but I want to emphasize it because

00:22:51.380 --> 00:22:53.930
there's another trick that we were
able to do under the covers that,

00:22:53.990 --> 00:22:55.700
again,
we'll talk about in the third section

00:22:55.700 --> 00:22:58.500
that became possible because of this.

00:22:58.500 --> 00:23:01.840
So the deal is that on Mac OS X,
double buffering is taken care

00:23:01.840 --> 00:23:03.490
of by the operating system.

00:23:03.490 --> 00:23:06.660
As you guys know,
Swing is double buffered as well.

00:23:06.660 --> 00:23:10.260
What we do to Swing is we
rip out its double buffering,

00:23:10.260 --> 00:23:14.520
and we make it draw directly to
our OS double buffer instead.

00:23:14.520 --> 00:23:17.410
So as far as Swing is concerned,
it's drawing directly to screen.

00:23:17.410 --> 00:23:20.250
Your code will still look like it's
drawing double buffered because

00:23:20.330 --> 00:23:22.790
we manipulated the Swing state
so that it says what it does,

00:23:22.810 --> 00:23:25.880
which is that it is double buffered,
even though the double buffering is

00:23:25.880 --> 00:23:27.960
implemented differently underneath.

00:23:28.200 --> 00:23:30.960
Then we tell the internals of the Swing
code that we're single buffered so that

00:23:30.960 --> 00:23:32.570
they don't create images everywhere.

00:23:32.570 --> 00:23:37.050
Not a big deal from your level,
and the JCK also agrees that we're double

00:23:37.050 --> 00:23:39.600
buffered like we're supposed to be.

00:23:39.600 --> 00:23:40.130
So that's good.

00:23:40.200 --> 00:23:41.260
Everything works the same.

00:23:41.260 --> 00:23:44.970
The difference is, though,
is because it's an OS double buffer,

00:23:45.010 --> 00:23:46.300
we get two things.

00:23:46.300 --> 00:23:49.890
The first thing we get is that
the Quartz engine does dirtiness

00:23:49.890 --> 00:23:51.760
for dirty region detection.

00:23:57.900 --> 00:24:12.020
So we can't get rid of dirtiness.

00:24:12.030 --> 00:24:12.030
We can't get rid of the dirtiness.

00:24:12.030 --> 00:24:12.030
We can't get rid of the dirtiness.

00:24:12.030 --> 00:24:12.030
So we can't get rid of the dirtiness.

00:24:12.030 --> 00:24:12.030
So we can't get rid of the dirtiness.

00:24:12.700 --> 00:24:13.960
As I said, we take care of Swing.

00:24:13.960 --> 00:24:17.500
A lot of people did double
buffering in Java out of Swing.

00:24:17.500 --> 00:24:20.300
It's really important that you examine
your code and get rid of that because

00:24:20.300 --> 00:24:21.760
you're triple buffered right now.

00:24:21.760 --> 00:24:25.630
So that's a memory thing, which,
as all of us know, memory is the biggest

00:24:25.630 --> 00:24:27.310
thing to deal with in Java.

00:24:27.320 --> 00:24:28.840
We don't want to be any
bigger than we have to be.

00:24:28.840 --> 00:24:32.450
And especially with a real virtual
machine underneath us and a real

00:24:32.450 --> 00:24:36.320
virtual memory system underneath that,
memory can be kind of a sketchy

00:24:36.320 --> 00:24:39.580
thing when you're always going
to have the right amount.

00:24:39.580 --> 00:24:42.330
What you don't want to do is
triple buffer for performance.

00:24:42.700 --> 00:24:45.060
And then use all that extra resources
and end up hitting the disk.

00:24:45.080 --> 00:24:46.130
So that's bad.

00:24:46.140 --> 00:24:48.880
So that's cool.

00:24:48.880 --> 00:24:52.930
I'm not good at this.

00:24:58.600 --> 00:25:03.710
Oh, I think I turned it around.

00:25:03.810 --> 00:25:06.880
So anyway,
next thing is live window resizing.

00:25:06.880 --> 00:25:09.210
We have that on as a feature for 10.

00:25:09.210 --> 00:25:13.220
It's as much a feature for you
guys as it's a feature for us.

00:25:13.220 --> 00:25:17.020
We do our job in our apps
and in our services to make

00:25:17.020 --> 00:25:19.990
this as easy as possible,
but certainly it's true that if your

00:25:20.080 --> 00:25:25.470
main panel takes six seconds to render,
it's not going to be live.

00:25:25.600 --> 00:25:28.260
Just pointing this out,
because it's different

00:25:28.260 --> 00:25:29.730
than other platforms.

00:25:29.730 --> 00:25:32.600
Of course,
if you're doing a big complicated scene,

00:25:32.600 --> 00:25:36.690
like maybe a terrain render or something,
you can do a simple quick pass,

00:25:36.690 --> 00:25:39.590
or you can keep the thing from last
time and stretch it or something.

00:25:39.640 --> 00:25:41.590
There's a lot of games you can play.

00:25:41.600 --> 00:26:04.800
[Transcript missing]

00:26:05.500 --> 00:26:06.100
A few more.

00:26:06.240 --> 00:26:09.290
This came up in our list,
so I wanted to point it out.

00:26:09.330 --> 00:26:11.330
All graphics objects are created equal.

00:26:11.370 --> 00:26:14.020
Every graphics object is the
same class in the system.

00:26:14.030 --> 00:26:15.390
They're all 2D objects.

00:26:15.390 --> 00:26:17.250
It doesn't matter where you get them.

00:26:17.250 --> 00:26:20.150
They have different implementation
plug-ins underneath,

00:26:20.150 --> 00:26:22.910
but that's all invisible to you,
and there's really no way

00:26:22.910 --> 00:26:24.320
for you to affect that.

00:26:26.300 --> 00:26:28.730
So every graphics object can
be casted to a graphics 2D.

00:26:28.730 --> 00:26:30.150
Again, that came up in the list.

00:26:30.150 --> 00:26:31.590
That's why I'm mentioning it.

00:26:31.600 --> 00:26:35.060
Also, the more complicated the clip,
the slower the graphics speed.

00:26:35.060 --> 00:26:40.000
That'll become really apparent in a sec,
but I hope it makes sense.

00:26:40.040 --> 00:26:43.340
Actually, just to be real clear,
the other UI frameworks always

00:26:43.390 --> 00:26:46.100
use the painter's algorithm,
which is the draw my guys

00:26:46.110 --> 00:26:48.670
who are my parents first,
draw the children last,

00:26:48.670 --> 00:26:51.410
so they don't have to deal
with clipped rendering.

00:26:51.420 --> 00:26:53.830
And Swing does that as well.

00:26:53.840 --> 00:26:56.230
Swing is like Power Plant.

00:26:56.360 --> 00:26:58.640
Mac App and Cocoa,
they all do the same thing.

00:26:58.640 --> 00:26:59.520
They use the painter's algorithm.

00:26:59.520 --> 00:27:05.680
ADBT, for reasons, long,
complicated reasons,

00:27:05.680 --> 00:27:07.660
some of which I agree with,
some of which I don't,

00:27:07.670 --> 00:27:12.560
has thread-safe pre-clipped rendering.

00:27:12.560 --> 00:27:14.490
So you can actually,
just to be real clear,

00:27:14.560 --> 00:27:18.080
you can stick two heavyweight buttons in
a parent view and make three threads and

00:27:18.080 --> 00:27:21.600
have them all render into the children
and the parent all at the same time,

00:27:21.600 --> 00:27:23.570
and we'll clip it all for
you and make everything work.

00:27:23.580 --> 00:27:25.150
It won't always be fast, though.

00:27:25.170 --> 00:27:29.990
So, um, it's better to watch the clip.

00:27:30.090 --> 00:27:31.400
Don't draw through too much clip.

00:27:31.420 --> 00:27:34.480
Watch out for too many repaints.

00:27:34.530 --> 00:27:37.680
I know that's obvious,
but we all know of many examples where

00:27:37.700 --> 00:27:41.010
we're pinning way more than we need to.

00:27:41.020 --> 00:27:43.560
And especially with double buffering,
because there's not as much flicker,

00:27:43.560 --> 00:27:44.800
you tend to maybe miss them.

00:27:44.800 --> 00:27:48.110
So, certainly we have,
that's one of the things

00:27:48.130 --> 00:27:49.420
that we're always working on,
too.

00:27:49.420 --> 00:27:51.410
So,

00:27:51.950 --> 00:27:54.340
So last thing, of course, is profile.

00:27:54.340 --> 00:27:57.350
Then cache the expensive stuff.

00:27:57.560 --> 00:27:59.560
Metrics is one of those ones
that's been around for a while.

00:27:59.560 --> 00:28:02.960
If you have one of
those complicated views,

00:28:02.960 --> 00:28:07.130
I don't recommend double buffering,
but I can imagine in some weird

00:28:07.130 --> 00:28:10.000
cases you would do that just
because you've got one piece of

00:28:10.000 --> 00:28:11.240
thing that you just want to render.

00:28:11.240 --> 00:28:14.640
For example,
maybe you want to do a really

00:28:14.640 --> 00:28:18.390
beautiful icon that has a piece of
artwork and maybe some tags on top,

00:28:18.440 --> 00:28:19.590
sort of like what Mail does.

00:28:19.600 --> 00:28:22.220
They put that stamp on top with
the little five or whatever

00:28:22.220 --> 00:28:23.490
mail messages you have.

00:28:23.590 --> 00:28:26.300
Maybe you want to do that and then throw
that into an image because you just

00:28:26.300 --> 00:28:27.940
don't want to have that code execute.

00:28:28.040 --> 00:28:31.260
That's one way to save yourself
some computational time.

00:28:31.300 --> 00:28:35.460
So those are all things you can do.

00:28:37.600 --> 00:28:38.960
So, this is the third section.

00:28:38.960 --> 00:28:42.440
So that's it for tips
and techniques for now.

00:28:44.010 --> 00:28:44.720
This is really exciting.

00:28:44.720 --> 00:28:48.240
This is our new update,
and it's momentarily

00:28:48.240 --> 00:28:51.820
available as a DR release,
DP release, developer preview.

00:28:51.820 --> 00:28:54.700
And we're really excited about this.

00:28:54.700 --> 00:28:56.200
We've been working really hard this fall.

00:28:56.200 --> 00:28:57.100
Excuse me, this spring.

00:28:57.100 --> 00:28:59.520
Seems like the year goes by really quick,
I guess.

00:28:59.520 --> 00:29:00.300
This spring.

00:29:00.300 --> 00:29:04.700
And a lot of the stuff that
we really wanted to get into

00:29:04.700 --> 00:29:07.330
Mac OS X Final is made in here.

00:29:07.340 --> 00:29:09.320
And we're really excited about it.

00:29:09.320 --> 00:29:10.240
Three things.

00:29:10.260 --> 00:29:12.230
Cutting-edge technology,
which you'll see in a sec.

00:29:12.910 --> 00:29:13.920
Much better correctness.

00:29:13.920 --> 00:29:17.500
We've been working very hard with
our partners to iron out our wrinkles

00:29:17.500 --> 00:29:19.280
that we have in Mac OS X Final.

00:29:19.280 --> 00:29:20.540
And then performance.

00:29:20.540 --> 00:29:22.300
Performance has been a big deal.

00:29:22.300 --> 00:29:24.360
John, the update's live now.

00:29:24.360 --> 00:29:25.900
The update is live now.

00:29:25.940 --> 00:29:27.640
Yay.

00:29:36.140 --> 00:29:36.790
So that's great to hear.

00:29:36.790 --> 00:29:41.550
So this is some of the things that
we concentrated on the update.

00:29:41.560 --> 00:29:45.620
Heavyweight ADBT was a big
thing that we had an issue with.

00:29:45.760 --> 00:29:52.440
I feel for Mac OS X Final,
specifically properly rendering deep

00:29:52.440 --> 00:29:59.970
hierarchies of heavyweight ADBT panels,
et cetera, with card layouts, et cetera.

00:29:59.970 --> 00:30:03.160
We worked really hard to
get those bugs ironed out,

00:30:03.160 --> 00:30:05.520
and I think you'll be pretty
happy with how far we've come.

00:30:05.520 --> 00:30:08.900
Swing, we've made a lot of progress.

00:30:08.900 --> 00:30:13.490
Leanne Rucker is a person who is
a Sun employee who works on our

00:30:13.490 --> 00:30:17.190
campus and bleeds the rainbow colors,
I think, more than we do.

00:30:17.190 --> 00:30:19.830
And she's been working very,
very hard on making our Aqua look

00:30:19.920 --> 00:30:21.280
and feel really amazing.

00:30:21.280 --> 00:30:22.890
So that's been really great.

00:30:22.890 --> 00:30:25.960
You'll see some of the results
of that in a little bit.

00:30:25.960 --> 00:30:27.650
Printing works much better.

00:30:27.710 --> 00:30:30.430
All the image formats will
be supported when we ship.

00:30:30.460 --> 00:30:31.960
We made some progress on there.

00:30:31.960 --> 00:30:33.680
This update, they're not all in.

00:30:33.680 --> 00:30:34.970
They will be in when we ship.

00:30:35.000 --> 00:30:36.660
Those are those ones that
I was mentioning earlier.

00:30:36.670 --> 00:30:38.840
We'll get to those real soon.

00:30:38.840 --> 00:30:41.330
And we've wiped out a
whole bunch of bugs.

00:30:41.370 --> 00:30:44.160
We're really interested in your
feedback on this release because

00:30:44.160 --> 00:30:48.060
we're going to push real hard
to get the rest of them nailed.

00:30:48.060 --> 00:30:50.500
So, more on the update.

00:30:50.500 --> 00:30:52.640
Oh, here we go, the demo.

00:30:52.640 --> 00:31:00.320
So what we're going to show you here
is a side-by-side before he starts it.

00:31:00.320 --> 00:31:00.320
So, we're

00:31:00.410 --> 00:31:05.540
We've been working really hard to
hardware accelerate Java Graphics.

00:31:05.600 --> 00:31:10.400
So what you'll see is a before and
after of the hardware acceleration.

00:31:10.400 --> 00:31:13.710
So Gerard,
why don't you do the software first?

00:31:14.910 --> 00:31:18.650
And we just did some,
I just picked an image off my disk.

00:31:18.680 --> 00:31:24.320
But what we did here, this is important,
is, as we'll talk about more in a minute,

00:31:24.320 --> 00:31:27.740
we picked the primitives that are used
a lot in UIs here for our testing,

00:31:27.740 --> 00:31:31.840
and this is actually a result of a piece
of code that we had for doing profiling.

00:31:31.840 --> 00:31:34.360
So we did,
as you may be able to see on the screen,

00:31:34.360 --> 00:31:39.740
we did images, rectangles, lines,
and glyphs, glyphs being text.

00:31:39.740 --> 00:31:42.360
Those are the four most
important things in the UI.

00:31:42.850 --> 00:31:46.430
So what's important to me,
and those of us who have been

00:31:46.440 --> 00:31:48.900
working really hard on this,
is that this is actually what's

00:31:48.900 --> 00:31:50.460
important for UI rendering.

00:31:50.460 --> 00:31:52.080
So now we can do the hardware.

00:31:52.080 --> 00:31:55.760
So, a little bit faster.

00:31:55.760 --> 00:31:57.200
Thank you.

00:32:01.800 --> 00:32:08.870
So, ten times faster in text lines.

00:32:08.900 --> 00:32:10.800
I'm not even sure what
that ends up being.

00:32:10.800 --> 00:32:14.260
That looks like a hundred times faster.

00:32:14.260 --> 00:32:16.800
For rectangles, we're talking ten times.

00:32:16.800 --> 00:32:20.800
Images, we're talking more like,
that's a big number, 200 probably.

00:32:20.800 --> 00:32:24.090
That's possible because of the
stuff we'll talk about in a minute,

00:32:24.160 --> 00:32:27.800
and it'll become more apparent of
where that performance comes from.

00:32:27.800 --> 00:32:29.750
So you want to hit the
hard-roll one more time,

00:32:29.750 --> 00:32:31.120
just in case they missed it?

00:32:31.800 --> 00:32:33.430
- Okay.

00:32:33.450 --> 00:32:34.880
- Ray.

00:32:34.880 --> 00:32:34.880
- Okay.

00:32:36.400 --> 00:32:39.460
So let's go back to slides, right?

00:32:39.480 --> 00:32:40.870
Yeah, back to slides.

00:32:40.930 --> 00:32:42.700
So I'll talk about how
we did that and why,

00:32:42.710 --> 00:32:43.880
et cetera.

00:32:45.610 --> 00:32:49.610
So, first of all, here's the other number
that's interesting.

00:32:49.620 --> 00:32:51.500
This is the caffeine mark for Mac OS X.

00:32:51.500 --> 00:33:01.490
We went from being kind of
slow to pretty competitive.

00:33:02.320 --> 00:33:04.300
This is really exciting.

00:33:04.300 --> 00:33:07.610
We're the only platform with
hardware-accelerated swing.

00:33:07.660 --> 00:33:10.520
and John Burkey:
That's because of the double buffering

00:33:10.530 --> 00:33:12.220
thing I talked about earlier.

00:33:12.330 --> 00:33:16.230
The reason why is that because we removed
the double buffer from swings code,

00:33:16.310 --> 00:33:19.470
where they actually allocate
an image and then render to it,

00:33:19.470 --> 00:33:21.660
and we use the OS,
then over the summer and

00:33:21.660 --> 00:33:23.960
the fall and the spring,
it took us a while to

00:33:23.960 --> 00:33:26.580
get this all worked out,
we switched to a hardware

00:33:26.610 --> 00:33:29.790
buffer so our hardware pen can
render into the back buffer.

00:33:29.790 --> 00:33:32.800
So you get the advantage of a
double buffer where you don't

00:33:32.800 --> 00:33:35.410
get to flicker all that stuff,
but you also get the

00:33:35.420 --> 00:33:37.600
advantage of a hardware pen.

00:33:40.020 --> 00:33:43.140
We worked very closely with
Peter Graffagnino's Quartz team on this.

00:33:43.140 --> 00:33:47.130
They were very, very helpful.

00:33:47.200 --> 00:33:49.150
In fact,
we went to SIGGRAPH with them last

00:33:49.190 --> 00:33:53.560
year and started talking about this
over interesting New Orleans drinks.

00:33:53.560 --> 00:34:00.960
And had a base plan then and started
talking about how to do this.

00:34:00.960 --> 00:34:05.340
And then we started designing an
architecture that would handle the

00:34:05.340 --> 00:34:06.760
kind of things we need to do here.

00:34:06.760 --> 00:34:10.550
So, of course, double buffering,
as I mentioned.

00:34:10.700 --> 00:34:11.890
So this is what we've done.

00:34:11.900 --> 00:34:14.550
This is sort of the details.

00:34:14.630 --> 00:34:16.700
All primitives are hardware-accelerated.

00:34:16.730 --> 00:34:22.690
What that means is lines, rectangles,
ovals, recent event.

00:34:22.840 --> 00:34:25.640
All those things that you do,
they're the methods hanging

00:34:25.640 --> 00:34:26.880
off the graphics object.

00:34:26.970 --> 00:34:27.930
They're all hardware-accelerated.

00:34:27.930 --> 00:34:31.700
95% of all text rendering
is hardware-accelerated.

00:34:31.700 --> 00:34:33.410
And I'll talk more
about that in a minute.

00:34:33.420 --> 00:34:39.670
I say 95% because we will back down
on either hard ligature cases for

00:34:39.670 --> 00:34:42.460
nationalized text or very large fonts.

00:34:42.460 --> 00:34:46.780
That's because we build hardware
caches in VRAM for our glyphs.

00:34:46.800 --> 00:34:49.510
And so we don't want to build hardware
caches with fonts that are this big,

00:34:49.600 --> 00:34:49.970
right?

00:34:50.010 --> 00:34:51.560
That would be a really
big hardware cache.

00:34:51.560 --> 00:34:53.420
So we've backed down on those cases.

00:34:53.420 --> 00:34:56.840
And general path tessellations
being done right now,

00:34:56.840 --> 00:35:01.620
that's really cool because especially
for polygonal shapes and then moving

00:35:01.620 --> 00:35:04.340
towards the general path cases,
we'll be able to

00:35:04.340 --> 00:35:05.560
hardware-accelerate those too.

00:35:05.560 --> 00:35:09.850
So I'm really excited about that because
I think it would be great if we had

00:35:09.850 --> 00:35:13.910
the Java 2D API and all the power it
gives you in terms of being able to

00:35:13.910 --> 00:35:16.780
specify really great things visually
and actually have it in the system.

00:35:16.780 --> 00:35:19.250
So we're excited to have
that hardware-accelerated.

00:35:19.250 --> 00:35:21.250
That would be sort of
a first in object APIs.

00:35:21.270 --> 00:35:23.880
And then hardware double buffering,
as I mentioned.

00:35:24.000 --> 00:35:26.700
And the fourth one's very important.

00:35:26.700 --> 00:35:29.700
This is actually our biggest sweet spot.

00:35:29.700 --> 00:35:35.260
We upload all static images and even
have image dirtiness detection in there.

00:35:35.270 --> 00:35:38.920
So as long as you don't
grab the pixels directly,

00:35:39.220 --> 00:35:42.890
We can tell if you rendered
to an image recently,

00:35:42.910 --> 00:35:46.600
and we will only upload on
demand as you dirty the pixels.

00:35:46.600 --> 00:35:50.340
So what this does is keep our bus
traffic to a minimum and draw basically

00:35:50.340 --> 00:35:52.390
blit images from VRAM to VRAM.

00:35:52.430 --> 00:35:56.060
That's what the cards are really good at,
so you get optimal performance.

00:35:56.060 --> 00:36:00.620
That's why we get 200, 400 times,
you'll see some more demos in a sec,

00:36:00.620 --> 00:36:03.120
difference in artwork rendering.

00:36:03.120 --> 00:36:06.560
That's really important,
because although it does make good demos,

00:36:06.560 --> 00:36:08.980
it also speeds up your UI.

00:36:08.980 --> 00:36:12.950
I know some of you probably saw
the JBuilder before and after

00:36:13.010 --> 00:36:15.560
where he showed that he could
slide the slider back and forth.

00:36:15.560 --> 00:36:18.660
What was cool about that was that
the way Swing implements the slider

00:36:18.660 --> 00:36:22.030
is it actually repaints the entire
view on each side of the slider.

00:36:22.160 --> 00:36:24.260
So when we accelerate that,
and it's that much different,

00:36:24.260 --> 00:36:27.860
that means we've basically accelerated
the whole UI by that amount.

00:36:27.860 --> 00:36:29.860
So it's not some simple blit.

00:36:29.870 --> 00:36:31.760
It's not like a scrolling operation.

00:36:31.760 --> 00:36:34.940
And that's because when you
have separators like that,

00:36:34.940 --> 00:36:37.320
they could choose to scale
their content based on size.

00:36:37.320 --> 00:36:38.860
They don't have to
slide it out of the way.

00:36:38.860 --> 00:36:40.620
So that's really important.

00:36:40.620 --> 00:36:43.410
We may go over that
again in a minute too.

00:36:44.440 --> 00:36:47.720
So, the reason why we did this,
we took careful measurement,

00:36:47.800 --> 00:36:52.280
profiling typical apps with our
profiling tools last summer,

00:36:52.280 --> 00:36:56.660
and we built prototypes in the summer,
and basically post the

00:36:56.660 --> 00:36:59.170
New Orleans SIGGraph,
we built prototypes with

00:36:59.170 --> 00:37:00.800
the guys on the Quartz team.

00:37:00.800 --> 00:37:05.140
And then, based on that information,
took some other easy wins and tried to

00:37:05.140 --> 00:37:07.160
find out if we could actually do this.

00:37:07.160 --> 00:37:09.720
At that point,
we re-architected the graphics

00:37:09.720 --> 00:37:12.570
subsystem so that we could
plug in separate engines,

00:37:12.570 --> 00:37:17.190
and we'll get into that in a sec,
and then started profiling our

00:37:17.190 --> 00:37:20.610
UI rendering system because if
you want to seriously render UI,

00:37:20.660 --> 00:37:24.550
you have to let it have access
to the hardware pen as well.

00:37:24.560 --> 00:37:27.530
So, we'll get that in a sec, too.

00:37:27.530 --> 00:37:27.530
We did a project plan

00:37:28.190 --> 00:37:30.890
So here's the new Java 2D implementation.

00:37:30.900 --> 00:37:35.870
The main things to notice are,
there's sort of two things

00:37:35.870 --> 00:37:37.260
I want to talk about here.

00:37:37.260 --> 00:37:42.270
The first is that from your Java app,
you basically talk to sort of the

00:37:42.270 --> 00:37:46.730
graphics system you've always dealt with,
but then what we do underneath is

00:37:46.730 --> 00:37:50.060
we plug in different pens based on
what surface you're rendering to.

00:37:50.120 --> 00:37:54.760
So we've got a printer pen on one side,
we've got the hardware pen on the other.

00:37:54.790 --> 00:37:58.930
Printer pen generates PDF,
hardware pen generates

00:37:58.950 --> 00:38:01.500
calls to the hardware cards.

00:38:01.500 --> 00:38:04.480
And then the guys in the middle
do the stuff that's actually

00:38:04.520 --> 00:38:08.850
very similar to the printer pen,
that they generate PDF-like stuff

00:38:08.850 --> 00:38:11.400
and renders to those surfaces.

00:38:11.460 --> 00:38:15.630
That's very important because we manage
the graphics state separately from

00:38:15.630 --> 00:38:19.580
the actual rendering so that we can
switch pens on the fly and that we

00:38:19.580 --> 00:38:21.220
can pick the right tool for the job.

00:38:21.220 --> 00:38:25.720
And then this middle section
is very important too.

00:38:25.720 --> 00:38:25.750
As I was mentioning,
static-accelerated Java graphics

00:38:25.750 --> 00:38:25.760
are very important.

00:38:25.760 --> 00:38:26.110
They're very important to us.

00:38:26.110 --> 00:38:27.400
They're very important to us because
they're very important to us as well.

00:38:27.510 --> 00:38:30.650
And static images are cached in
hardware and glyphs are as well

00:38:30.650 --> 00:38:33.680
because glyphs are really images,
right?

00:38:33.760 --> 00:38:38.450
What we do is we pre-render our
text using Quartz into a hardware

00:38:38.500 --> 00:38:42.540
cache and then we use the engine
to put it to the screen on demand.

00:38:42.540 --> 00:38:45.220
So it's, in effect,
another hardware cache,

00:38:45.250 --> 00:38:46.140
just like an image.

00:38:46.140 --> 00:38:49.250
And we try to manage that as well as
we can so that your images are hot,

00:38:49.250 --> 00:38:50.750
so that your UI renders quick.

00:38:50.750 --> 00:38:53.200
And then the primitives,
as quickly as possible

00:38:53.200 --> 00:38:55.360
in the screen case,
get to the hardware pen

00:38:55.360 --> 00:38:56.730
and execute card calls.

00:38:56.740 --> 00:39:01.900
So that's that.

00:39:01.950 --> 00:39:03.860
If you have questions about that,
we can talk about that in Q&A.

00:39:05.610 --> 00:39:07.500
So this is the second part of the piece.

00:39:07.500 --> 00:39:14.580
And after we built the first part,
we ran into a lot of profiling with--

00:39:15.100 --> 00:40:04.900
[Transcript missing]

00:40:09.750 --> 00:40:12.880
So, this is where I,
my other tips and technique thing,

00:40:12.880 --> 00:40:15.940
which is great for a lot of reasons.

00:40:15.960 --> 00:40:20.040
I know it's always been true in
the past that ADBT was the fastest

00:40:20.040 --> 00:40:23.140
way to do stuff on your platforms,
but as of now on Mac OS X,

00:40:23.140 --> 00:40:26.980
Swing will always be the fastest
GUI framework to use for Java.

00:40:26.980 --> 00:40:29.200
It will always be faster than ADBT.

00:40:29.200 --> 00:40:33.570
The reason why is because we put a
hardware surface across the entire

00:40:33.570 --> 00:40:38.310
window and render with a hardware pen
basically always if Swing is active.

00:40:39.000 --> 00:40:42.120
We will turn our hardware pen off
very quickly if ADBT is active.

00:40:42.120 --> 00:40:44.140
Only real simple hierarchies will work.

00:40:44.140 --> 00:40:45.750
That gets back to the clipping thing.

00:40:45.760 --> 00:40:48.770
We fall off very quickly if the
clip gets complicated because

00:40:48.770 --> 00:40:50.240
hardware surfaces are rectangular.

00:40:50.240 --> 00:40:53.730
So, we're sort of, that's just how it is.

00:40:53.740 --> 00:40:57.040
I think the good news is
that Swing is really fast,

00:40:57.040 --> 00:41:00.600
and it's very competitive with any
other Swing implementation anywhere.

00:41:00.600 --> 00:41:05.050
The bad news is that ADBT won't
be accelerated that way.

00:41:05.060 --> 00:41:06.340
There's just not much we can do there.

00:41:08.400 --> 00:41:09.640
So, that's pretty important.

00:41:09.640 --> 00:41:12.050
Swing will always work
best first because,

00:41:12.100 --> 00:41:14.230
again, the rendering path is very simple.

00:41:14.310 --> 00:41:16.330
It's painter algorithm like
the other UI frameworks,

00:41:16.330 --> 00:41:19.610
and the state is much easier to manage.

00:41:19.890 --> 00:41:21.880
and David It's a much
richer UI framework,

00:41:21.880 --> 00:41:25.190
so there are some serious
advantages to using it over ADBT.

00:41:25.190 --> 00:41:27.550
I think you guys all know that,
but what's cool is now it's

00:41:27.610 --> 00:41:29.360
actually the faster one too.

00:41:29.360 --> 00:41:34.820
And it uses the same rendering
layer for the widgets as ADBT does.

00:41:34.820 --> 00:41:37.450
So in almost all cases,
you'll be calling the same

00:41:37.450 --> 00:41:39.440
rendering code anyway,
so there's not really much

00:41:39.440 --> 00:41:41.230
point to using the peers.

00:41:43.300 --> 00:41:49.180
So, I'm just going to show
an example of that.

00:41:51.400 --> 00:41:53.400
Yes, it is.

00:41:53.400 --> 00:41:53.790
Okay.

00:41:53.870 --> 00:41:58.560
So this is a little sneak
preview of what will happen next.

00:41:58.670 --> 00:42:02.820
This is a piece of code and
it's a swing app that I built

00:42:02.820 --> 00:42:04.160
in JBL using their wizards.

00:42:04.160 --> 00:42:07.160
And I'm just going to cheat
and just go like this.

00:42:07.160 --> 00:42:08.600
You can see my cursor.

00:42:08.600 --> 00:42:11.400
I'm going to take this J panel
and make it into a panel.

00:42:11.450 --> 00:42:16.670
And I'm going to run.

00:42:22.310 --> 00:42:23.800
Did I hit right?

00:42:23.800 --> 00:42:24.040
Yeah.

00:42:24.040 --> 00:42:24.890
The image will take a sec.

00:42:24.950 --> 00:42:31.000
This image is 11 megabytes uncompressed.

00:42:31.710 --> 00:42:36.000
and so I don't know how many
of you recognize this image,

00:42:36.000 --> 00:42:38.840
but one of the hardware acceleration
talks was using this yesterday,

00:42:38.840 --> 00:42:40.600
so we thought it would
be cool to use it too.

00:42:40.760 --> 00:42:46.600
Anyway, this is with a heavyweight
peer sitting in the middle.

00:42:46.600 --> 00:42:48.910
So, you know, it feels kind of fast,
maybe.

00:42:48.920 --> 00:42:52.540
It's so hard to know with these kind of
demos until you see the before and after.

00:42:52.540 --> 00:42:55.530
So what I'll do is stop it.

00:42:57.100 --> 00:42:59.000
and you'll see what it's
supposed to be doing.

00:42:59.000 --> 00:43:03.100
So now I'm gonna go back
here and I'll just do one do.

00:43:03.100 --> 00:43:08.580
Just a sec.

00:43:16.440 --> 00:43:19.160
So again, all I did here was I just made
it back into a swing panel.

00:43:19.180 --> 00:43:22.160
So that means it'll be
a normal swing setup.

00:43:22.160 --> 00:43:24.000
The frame that contains it is a J frame.

00:43:24.000 --> 00:43:25.340
That's a swing frame.

00:43:25.340 --> 00:43:28.150
And this image panel,
which is a real simple piece of code,

00:43:28.150 --> 00:43:28.810
is a J panel.

00:43:28.810 --> 00:43:30.180
So that's normal swing.

00:43:31.700 --> 00:43:33.360
So now you'll see how
it's supposed to work.

00:43:33.360 --> 00:43:35.000
Oops.

00:43:35.050 --> 00:43:38.740
So this is what you should expect.

00:43:38.740 --> 00:43:41.660
And this is what you saw yesterday
at the hardware acceleration demo.

00:43:41.660 --> 00:43:45.710
Big image took a sec to load.

00:43:48.410 --> 00:43:49.800
You see the CPU.

00:43:49.800 --> 00:43:51.180
It's a busy boy.

00:43:51.180 --> 00:43:52.910
It'll be a sec here.

00:44:02.800 --> 00:44:04.880
and David So, a little bit better.

00:44:04.880 --> 00:44:12.540
So,
I know that's sort of cheating because

00:44:12.560 --> 00:44:15.360
I took a swing app and made it into
an ADBT app and then turned it back.

00:44:15.360 --> 00:44:17.360
So, that's obviously,
if you have ADBT apps,

00:44:17.360 --> 00:44:18.840
you'd have a lot more work to do.

00:44:18.960 --> 00:44:21.030
But the point is there is
light at the end of the tunnel.

00:44:21.060 --> 00:44:24.640
You do get speed out of it in addition
to all the additional functionality.

00:44:24.640 --> 00:44:28.390
So, I think that's a pretty good
reason to think about it anyway.

00:44:37.400 --> 00:44:38.400
Back to slides.

00:44:38.400 --> 00:44:40.950
Oh, oops.

00:44:40.980 --> 00:44:42.960
Did I do that?

00:44:47.810 --> 00:44:51.180
Okay, so actually,
we're going to go to our next demo.

00:44:51.180 --> 00:44:51.920
Come on out, Scott.

00:44:51.920 --> 00:44:56.760
And I forgot, this is the surprise demo,
which is why I was surprised, too.

00:44:56.760 --> 00:44:59.150
So this is what happened.

00:44:59.180 --> 00:45:02.960
Yesterday,
we saw the hardware acceleration demo,

00:45:02.960 --> 00:45:05.560
and we thought it was really cool.

00:45:05.560 --> 00:45:10.210
They showed that 11 megabyte,
2,500 or so by 1,500 pixel image,

00:45:10.210 --> 00:45:12.570
that's what we were just
rendering that fast,

00:45:12.570 --> 00:45:14.860
being rendered very fast by hardware.

00:45:14.860 --> 00:45:17.670
So we thought, really cool,
we'll do that, too.

00:45:17.830 --> 00:45:20.630
So we rigged it up,
and then about 10.30 last night,

00:45:20.640 --> 00:45:24.060
which is why we looked a little tired,
we thought, well, geez, actually,

00:45:24.060 --> 00:45:26.680
we have a 1.7 gigahertz P4 in our office.

00:45:26.680 --> 00:45:29.600
So why not see how fast
it does at the same thing?

00:45:29.600 --> 00:45:31.200
So this isn't a benchmark.

00:45:31.200 --> 00:45:35.220
This is just, we had a machine,
and we said, well, let's rig it up.

00:45:35.300 --> 00:45:38.860
So Scott's on a Dell 1.7 gigahertz.

00:45:38.860 --> 00:45:42.720
Oh, yeah,
can we switch to the demo machines,

00:45:42.720 --> 00:45:43.930
the split?

00:45:45.420 --> 00:45:47.990
We'll go back in a minute.

00:45:47.990 --> 00:45:50.880
So, Scott's on a 1.7 gigahertz.

00:45:50.880 --> 00:45:54.030
You got a mic you can talk about.

00:45:57.100 --> 00:46:58.700
[Transcript missing]

00:47:07.300 --> 00:47:13.690
I'm getting about a blazing 7.3,
7.7 frames per second.

00:47:13.700 --> 00:47:15.100
He's at 305.

00:47:15.100 --> 00:47:15.700
Go ahead, Gerard.

00:47:15.700 --> 00:47:19.700
I'm getting around 300 frames per second.

00:47:19.810 --> 00:47:22.010
Well, 400.

00:47:23.500 --> 00:47:37.200
[Transcript missing]

00:47:41.520 --> 00:47:44.730
It's not really fair.

00:47:44.790 --> 00:47:49.660
So what this demonstrates is that there's
an architectural performance issue here.

00:47:49.660 --> 00:47:54.670
Because we use static image VRAM upload,
we can actually deal with very

00:47:54.670 --> 00:47:56.580
large images very effectively.

00:47:56.580 --> 00:47:58.490
There's very little bus traffic going on.

00:47:58.530 --> 00:48:02.790
And because the hardware cards do
this kind of operation natively,

00:48:02.790 --> 00:48:04.480
we take advantage of them.

00:48:04.580 --> 00:48:06.260
The other implementations
may do that someday,

00:48:06.260 --> 00:48:07.880
but we're doing it now.

00:48:07.930 --> 00:48:08.220
John?

00:48:08.280 --> 00:48:08.810
Yeah.

00:48:08.820 --> 00:48:10.290
We have one more thing we want to show.

00:48:10.300 --> 00:48:11.880
Go ahead, sorry.

00:48:11.880 --> 00:48:12.560
Surprise.

00:48:12.560 --> 00:48:15.660
We developed this actually
on John's PowerBook.

00:48:15.660 --> 00:48:18.470
And Gerard wanted to show you guys.

00:48:18.480 --> 00:48:20.720
Because we're running on
this really cool machine.

00:48:20.720 --> 00:48:22.430
I think it has a video card in it.

00:48:22.460 --> 00:48:25.520
But that's the Rage 128 Mobility.

00:48:25.520 --> 00:48:29.160
And you can see the frame
rate is almost identical.

00:48:29.160 --> 00:48:30.420
Can you read what it says there?

00:48:30.420 --> 00:48:33.800
The frame rate is almost
500 frames per second.

00:48:33.800 --> 00:48:34.400
And this is Rage 128 Mobility.

00:48:34.400 --> 00:48:36.880
OK, so it's higher than what we're
getting out of this thing.

00:48:36.880 --> 00:48:39.800
It's not dependent on having
a huge-- Can you see it now?

00:48:40.300 --> 00:48:44.210
It's the same demo.

00:48:49.800 --> 00:48:51.300
So this is architectural performance.

00:48:51.300 --> 00:48:54.740
As I said,
our software is built differently.

00:48:54.740 --> 00:48:57.800
It's optimized because of the engines
we have underneath us on Mac OS X,

00:48:57.800 --> 00:49:01.680
and because of that optimization,
we make it an unfair race.

00:49:01.680 --> 00:49:06.040
Our CPU and our graphics card
work really well together,

00:49:06.040 --> 00:49:09.060
and that's just how it goes on Mac OS X.

00:49:09.200 --> 00:49:10.860
That's it for the demos.

00:49:10.860 --> 00:49:14.380
I just want to close with a slide on...

00:49:15.890 --> 00:49:18.800
So, sort of three things.

00:49:18.850 --> 00:49:21.190
The promise of Java and Mac OS X.

00:49:21.220 --> 00:49:23.200
Of course, you just saw performance.

00:49:23.200 --> 00:49:25.200
We have an object
framework access to Quartz.

00:49:25.200 --> 00:49:25.860
That's really cool.

00:49:25.860 --> 00:49:29.500
You've got easy objects to
use to a great Quartz API.

00:49:29.500 --> 00:49:32.860
You've got Swing, which is a very rich
cross-platform UI framework.

00:49:32.860 --> 00:49:34.200
The code runs anywhere.

00:49:34.200 --> 00:49:35.910
So, we'll go to Q&A.

00:49:35.910 --> 00:49:38.070
We'll take any questions.

00:49:38.200 --> 00:49:51.300
[Transcript missing]
WEBVTT

00:00:01.500 --> 00:00:03.890
It's been a great year for
Darwin and open source,

00:00:04.000 --> 00:00:07.030
starting with Mac OS X shipping
on March 24th,

00:00:07.040 --> 00:00:12.570
and we have great contributions and
signed ups for Darwin open source,

00:00:12.570 --> 00:00:14.990
and we'll be sharing a lot of these
accolades and the numbers with

00:00:14.990 --> 00:00:16.900
you as well throughout the week.

00:00:16.900 --> 00:00:20.800
So without further ado,
I'd like to kick it off by introducing

00:00:20.880 --> 00:00:24.440
the Director of Core OS Engineering,
Brett Halle.

00:00:31.700 --> 00:00:33.600
So good afternoon.

00:00:33.600 --> 00:00:35.400
First session after lunch.

00:00:35.400 --> 00:00:38.990
Hopefully you guys
won't fall asleep on me.

00:00:39.070 --> 00:00:41.600
We have a lot of technical
material in this session,

00:00:41.600 --> 00:00:44.130
so we'll try and get over it.

00:00:44.250 --> 00:00:49.880
The focus of this session is
to basically give an overview

00:00:49.880 --> 00:00:52.910
of what Darwin is all about.

00:00:53.010 --> 00:00:56.250
I'm sure you've seen this picture
numerous times just this morning.

00:00:56.400 --> 00:00:59.970
Our focus again really is on
that bottom layer of the system.

00:00:59.980 --> 00:01:03.000
There's a huge amount of
technology that exists there.

00:01:03.000 --> 00:01:06.370
As we talk about it today,
I think it's important to

00:01:06.460 --> 00:01:10.390
note that we will use some
terms quite interchangeably.

00:01:10.800 --> 00:01:14.000
Darwin is the Core OS of Mac OS X.

00:01:14.000 --> 00:01:17.310
We talk a lot about Darwin,
we talk a lot about Mac OS X,

00:01:17.310 --> 00:01:19.000
they are the same thing.

00:01:19.000 --> 00:01:21.000
They are not two different
piles of technology,

00:01:21.000 --> 00:01:23.000
they are one and the same.

00:01:23.000 --> 00:01:26.590
From that perspective,
it's important to note that

00:01:26.850 --> 00:01:29.000
Darwin is also open source.

00:01:29.000 --> 00:01:32.980
As we talk about the open source
aspects of Darwin and the technology,

00:01:33.070 --> 00:01:36.260
it's the same pile of code,
the same technology that

00:01:36.350 --> 00:01:38.000
ships as part of Mac OS X.

00:01:38.070 --> 00:01:40.480
Again, they are one and the same.

00:01:40.970 --> 00:01:44.540
So how in the world do you
describe the Core OS or the

00:01:44.540 --> 00:01:46.900
operating system of Mac OS X?

00:01:47.070 --> 00:01:49.560
Interestingly enough,
it's technology that tends

00:01:49.560 --> 00:01:50.900
not to be very visible.

00:01:50.900 --> 00:01:53.900
If we're really doing our job well,
you don't really see us.

00:01:53.900 --> 00:01:57.260
So you might consider that
we're certainly kind of the

00:01:57.260 --> 00:01:58.900
foundation of the system.

00:01:58.960 --> 00:02:02.970
We kind of deal with the plumbing
and the piping and the wiring,

00:02:02.970 --> 00:02:05.860
if you will,
that holds Mac OS X together.

00:02:06.080 --> 00:02:09.850
Again, if we're doing our job well,
you don't see the Core OS.

00:02:09.940 --> 00:02:12.440
You as the developers will
interact with it at a very

00:02:12.440 --> 00:02:17.090
high degree of interactivity,
but the developers should rarely,

00:02:17.090 --> 00:02:19.870
if ever,
be aware that the Core OS is there.

00:02:21.100 --> 00:02:26.610
The architecture of Darwin is
very unusual in that we've taken

00:02:26.610 --> 00:02:32.450
basically best of class technologies
and brought them together to bring

00:02:32.900 --> 00:02:35.500
the base of Mac OS X together.

00:02:35.500 --> 00:02:38.220
And there's a number of
different technologies that

00:02:38.220 --> 00:02:39.970
we'll talk about in this session.

00:02:40.220 --> 00:02:42.950
This technology comes from
a number of different areas:

00:02:42.950 --> 00:02:47.050
academia, the open source community,
and certainly some significant

00:02:47.050 --> 00:02:48.600
history at Apple and Next.

00:02:48.690 --> 00:02:54.210
And there's probably thousands of person
years worth of development and testing

00:02:54.600 --> 00:02:56.930
and usage in much of this code base.

00:02:57.980 --> 00:03:01.630
We've taken all that technology
and we've again kind of brought it

00:03:01.630 --> 00:03:06.290
together in a very unusual combination,
but tuned it toward the customer base and

00:03:06.290 --> 00:03:08.900
developer base that's unique to Mac OS X.

00:03:08.910 --> 00:03:12.750
So you've certainly heard a lot of
focus around things like UNIX or

00:03:12.750 --> 00:03:14.700
certainly the heritage Mac OS.

00:03:14.760 --> 00:03:18.490
We've actually brought aspects of these
technologies together to support both

00:03:18.550 --> 00:03:23.680
of these environments and to really
focus on our customer base directly.

00:03:24.350 --> 00:03:27.300
From that perspective,
there's an awful lot of untapped

00:03:27.300 --> 00:03:29.490
potential that exists in the system.

00:03:29.490 --> 00:03:32.170
We'll talk a lot about more
of that during the week,

00:03:32.170 --> 00:03:32.940
of course.

00:03:33.070 --> 00:03:36.590
But in terms of providing the
modern operating system base,

00:03:36.750 --> 00:03:37.270
this is it.

00:03:37.490 --> 00:03:41.630
This is the base that really
enables all those capabilities.

00:03:41.730 --> 00:03:44.140
And because of the
power that exists there,

00:03:44.140 --> 00:03:48.900
I think we're enabling you to create
applications that you couldn't do

00:03:48.900 --> 00:03:51.690
on previous versions of Mac OS.

00:03:52.420 --> 00:03:55.250
From a feature perspective,
you could consider that Darwin or

00:03:55.360 --> 00:03:59.300
the Core OS is responsible for the
preemption aspects of the system,

00:03:59.330 --> 00:04:01.300
the memory protection.

00:04:01.550 --> 00:04:04.810
Basically,
it's responsible for managing and

00:04:04.810 --> 00:04:10.300
coordinating the multiple address
spaces that represent the system.

00:04:10.330 --> 00:04:14.310
Each of the applications in the system
exists in a separate address space.

00:04:14.500 --> 00:04:17.830
It supports the application environments,
provides all that plumbing and

00:04:17.830 --> 00:04:21.440
wiring and stuff that allows the
application environments to exist on

00:04:21.440 --> 00:04:25.900
the system and to be able to do their,
export their particular brand,

00:04:25.900 --> 00:04:30.520
if you will, of memory management and
such up to the application.

00:04:31.760 --> 00:04:34.140
The Core OS is inherently
device independent.

00:04:34.140 --> 00:04:35.930
And what I mean by that,
and that seems kind of

00:04:35.930 --> 00:04:39.690
an obvious statement,
but that we don't actually have

00:04:39.690 --> 00:04:44.680
any particular preference to
any I/O or device architecture.

00:04:44.850 --> 00:04:48.120
We realize that technology
in the I/O space is evolving

00:04:48.120 --> 00:04:51.090
at a fairly furious rate,
and we've tried to make sure

00:04:51.090 --> 00:04:53.700
that we have a design that
will enable us to move forward,

00:04:53.700 --> 00:04:57.240
and be able to take advantage of the
fact that we make the whole widget,

00:04:57.300 --> 00:05:00.700
and to be able to enable new
hardware and new technology together,

00:05:00.700 --> 00:05:02.700
new software technology.

00:05:02.700 --> 00:05:04.700
It's a very flexible base.

00:05:04.700 --> 00:05:07.580
As we talk about the
pieces of the Core OS,

00:05:07.580 --> 00:05:11.650
you'll see that they were designed to
support a number of different kinds

00:05:11.760 --> 00:05:15.700
of categories of application spaces,
and hardware spaces, and such.

00:05:15.700 --> 00:05:20.700
And we've really kind of tried to
leverage that flexibility of the system

00:05:20.700 --> 00:05:23.700
to give us a base which we expect
will last for the rest of the system.

00:05:23.700 --> 00:05:25.900
the next 10, 20 years.

00:05:26.540 --> 00:05:29.400
The CoreOS is also
designed to be scalable,

00:05:29.400 --> 00:05:32.580
and you can interpret this
in a couple of key ways.

00:05:32.580 --> 00:05:35.340
It's scalable from the
hardware's perspective,

00:05:35.380 --> 00:05:41.400
in that we support certainly various
classes of processor architectures,

00:05:41.400 --> 00:05:47.400
G3, G4, but also be able to support
multiple processors in a system,

00:05:47.480 --> 00:05:51.460
so support for symmetric multiprocessing
from that level of scalability.

00:06:07.530 --> 00:06:07.610
The CoreOS is also
designed to be scalable,

00:06:07.610 --> 00:06:07.610
and you can interpret this
in a couple of key ways.

00:06:07.610 --> 00:06:07.610
It's scalable from the
hardware's perspective,

00:06:07.610 --> 00:06:07.610
in that we support certainly various
classes of processor architectures,

00:06:07.610 --> 00:06:07.610
G3, G4, but also be able to support
multiple processors in a system,

00:06:07.610 --> 00:06:07.610
so support for symmetric multiprocessing
from that level of scalability.

00:06:07.700 --> 00:06:38.400
[Transcript missing]

00:06:38.810 --> 00:06:42.240
and being an OS,
and things like networking and all that,

00:06:42.240 --> 00:06:47.560
there's more Budsworth than you can
imagine that's a part of the system.

00:06:48.200 --> 00:06:51.360
So we're going to spend a little bit and
actually do a tour of the Core OS and the

00:06:51.360 --> 00:06:54.100
various components that are part of it.

00:06:54.180 --> 00:06:57.420
And first of all,
this kind of gives you a bit

00:06:57.430 --> 00:07:01.190
of an exploded view of that
Darwin layer of the system,

00:07:01.190 --> 00:07:03.100
and there's a number of
pieces that make it up.

00:07:03.100 --> 00:07:07.100
We're going to start first by spending
some time in talking about Mach.

00:07:07.100 --> 00:07:11.100
Mach is kind of the actual
foundation layer of the system.

00:07:11.100 --> 00:07:13.760
It's designed, in fact,
as an OS foundation

00:07:13.760 --> 00:07:16.100
and abstraction layer,
if you will.

00:07:16.100 --> 00:07:18.380
And it's responsible for
managing the processor and

00:07:18.510 --> 00:07:20.080
memory resources of the system.

00:07:20.100 --> 00:07:25.150
It's basically the piece of the system
that actually schedules the processor,

00:07:25.200 --> 00:07:28.100
a given application or thread in
the system for being able to run.

00:07:28.100 --> 00:07:31.030
And it's important to
note that at this very,

00:07:31.030 --> 00:07:34.060
very basic level of the system,
the threading is,

00:07:34.090 --> 00:07:36.540
the threads are considered to be,
you know,

00:07:36.670 --> 00:07:39.100
an essential building block of Mac OS X.

00:07:39.100 --> 00:07:41.390
That scheduling and the various
services that go with it are

00:07:41.390 --> 00:07:44.050
actually supported all the way down
to the very base of the system.

00:07:44.130 --> 00:07:48.030
It's not a tacked on the top concept.

00:07:48.100 --> 00:07:52.300
Mach is also responsible for
handling the memory protection,

00:07:52.380 --> 00:07:56.100
the memory management, basically,
if you will,

00:07:56.100 --> 00:07:59.090
both the processor and memory
resources of the system,

00:07:59.100 --> 00:08:03.420
all the VM capabilities and such.

00:08:03.570 --> 00:08:07.600
Because Mac keeps everything
abstracted as far as how memory is

00:08:07.600 --> 00:08:11.640
concerned and the various address
spaces that exist in the system,

00:08:11.650 --> 00:08:16.640
it also has to provide some very key
and basic services so that there's

00:08:16.640 --> 00:08:20.850
a way for user level applications
and the kernel to be able to

00:08:20.850 --> 00:08:23.250
communicate back and forth together.

00:08:23.340 --> 00:08:26.350
And that's done through
something called IPC,

00:08:26.420 --> 00:08:28.940
Inter-Process Communication, RPC,
remote procedure calls,

00:08:28.960 --> 00:08:33.230
that is a fundamental, again,
key building block of Mach.

00:08:33.300 --> 00:08:36.350
And it's the way Mach uses to
be able to communicate with any

00:08:36.350 --> 00:08:38.060
other portion of the system.

00:08:39.930 --> 00:08:41.870
Mark is inherently policy neutral.

00:08:41.940 --> 00:08:45.280
It's, again,
it's designed to be a very much a,

00:08:45.400 --> 00:08:49.870
an abstraction layer to the processor
and memory architecture of the system,

00:08:49.990 --> 00:08:53.200
and it doesn't actually have any
concept of things like file systems

00:08:53.200 --> 00:08:56.940
or I/O or networking or anything,
security policies, things like that.

00:08:57.150 --> 00:08:58.290
That's not Mark's job.

00:08:58.300 --> 00:09:02.780
It really is designed to be a
very low-level abstraction layer.

00:09:02.800 --> 00:09:06.840
The Mach we use in Mac OS X is based on,
for those of you that

00:09:06.840 --> 00:09:12.700
follow this technology,
is based on a Mach 3.0 plus a bunch

00:09:12.820 --> 00:09:16.340
of stuff that has been added to it
by the various players that have been

00:09:16.340 --> 00:09:17.800
participating in its development.

00:09:17.800 --> 00:09:20.980
It's derived from a Mach that
was developed at CMU.

00:09:21.130 --> 00:09:24.510
Avi Tavenian, of course,
was one of the original team

00:09:24.510 --> 00:09:26.570
members of the Mach team at CMU.

00:09:26.880 --> 00:09:30.800
But it was taken on by the
OSF Research Institute a number of years.

00:09:30.800 --> 00:09:33.200
In fact,
Apple funded a lot of that development

00:09:33.200 --> 00:09:34.800
work at the Research Institute.

00:09:34.800 --> 00:09:39.750
And when we took it in and
incorporated it as part of Mac OS X,

00:09:39.750 --> 00:09:44.960
of course, we've done considerable amount
of work to enhance the 3.0 base

00:09:44.960 --> 00:09:47.790
beyond even those starting points.

00:09:47.800 --> 00:09:54.040
It, as very much from its original design
point for Mach was to actually be

00:09:54.040 --> 00:09:56.800
able to support things like SMP.

00:09:56.800 --> 00:09:58.800
And some of the work that was
done in 3.0 and later also,

00:09:58.800 --> 00:10:04.480
has architectural support for being
able to deal with various mechanisms

00:10:04.480 --> 00:10:07.800
and facilities for supporting real time.

00:10:07.800 --> 00:10:11.050
And we'll talk about that a little
bit more and certainly more in the

00:10:11.050 --> 00:10:12.790
Kernel session later this week.

00:10:15.290 --> 00:10:19.200
The wall is talking to us.

00:10:19.200 --> 00:10:25.340
The Mac OS X also has built into it,
because it's responsible for

00:10:25.340 --> 00:10:28.190
managing the processor resources,
the capability of supporting

00:10:28.190 --> 00:10:30.200
multiple scheduling policies.

00:10:30.200 --> 00:10:37.350
For example, built into the Mac OS X is
the ability to schedule,

00:10:37.350 --> 00:10:41.370
certainly either kind of the
real-time scheduling or fixed

00:10:41.370 --> 00:10:45.180
priority-based scheduling,
or time-sharing-based policy scheduling.

00:10:45.200 --> 00:10:48.610
And there's actually the ability to
support other types of scheduling

00:10:48.610 --> 00:10:50.190
policies within the system.

00:10:50.200 --> 00:10:53.610
Mark also tries to abstract
the mechanisms for being able

00:10:53.610 --> 00:10:57.020
to deal with the other half
of the virtual memory system.

00:10:57.200 --> 00:11:00.190
So VM certainly,
if you look at the management of memory,

00:11:00.240 --> 00:11:03.200
there's the managing the actual,
you know,

00:11:03.200 --> 00:11:06.200
parceling out of the address space
that's available for a given application.

00:11:06.210 --> 00:11:09.670
But there's also the other aspect of it,
which is what to do when you

00:11:09.670 --> 00:11:12.200
try and access more memory
than you actually have.

00:11:12.200 --> 00:11:15.100
You have physical RAM installed
in your system for.

00:11:15.360 --> 00:11:21.420
And Mark actually interacts with a
number of external interfaces to be

00:11:21.420 --> 00:11:26.400
able to support being able to store,
to be able to handle the

00:11:26.400 --> 00:11:30.110
backing store for the OS,
either on the file system or,

00:11:30.210 --> 00:11:35.190
and certainly is capable of other
kinds of backing storage solutions.

00:11:35.200 --> 00:11:37.580
Mark is also, again,
this is kind of repeating here,

00:11:37.670 --> 00:11:39.200
but it's very much designed
to be a system that's designed

00:11:39.200 --> 00:11:39.660
to be able to handle the OS,
and it's very much designed

00:11:39.660 --> 00:11:40.200
to be able to handle the OS.

00:11:40.200 --> 00:11:41.200
So, I'm going to go ahead and show
you a little bit of the Mac OS X.

00:11:41.200 --> 00:11:43.190
So, it's very much designed
to be very modular.

00:11:43.400 --> 00:11:47.200
Mac was intended to have
OS personalities put on top of it.

00:11:47.200 --> 00:11:49.160
Again, it's policy neutral.

00:11:49.220 --> 00:11:52.200
So, it's, you know, it's interface layer,
it's abstraction layer is assessed,

00:11:52.200 --> 00:11:54.540
and it assumes that there's
some other OS and other

00:11:54.540 --> 00:11:56.050
OS technologies that sit on it.

00:11:56.220 --> 00:11:59.960
And that's very much a key
part of its design space.

00:12:00.650 --> 00:12:03.000
Now this is all fine and interesting,
this is all down at the

00:12:03.000 --> 00:12:05.130
very base of the system,
but if you're writing an

00:12:05.200 --> 00:12:08.450
application for Mac OS X,
what does Mach mean to you?

00:12:08.500 --> 00:12:12.500
Well, it's important to note that all
process models of the system,

00:12:12.500 --> 00:12:14.820
in other words,
the things that actually kind

00:12:14.820 --> 00:12:18.030
of handle the scheduling and
the kind of environment which

00:12:18.100 --> 00:12:21.980
your application rests within,
are all fundamentally built

00:12:21.980 --> 00:12:23.360
on top of Mach primitives.

00:12:23.820 --> 00:12:27.500
Those Mach primitives
are tasks and threads.

00:12:27.500 --> 00:12:31.470
And whether you're using Carbon,
or whether you're using Classic,

00:12:31.550 --> 00:12:36.690
or you're using Cocoa,
all of those application environments

00:12:36.690 --> 00:12:40.240
are fundamentally built on
these particular abstractions.

00:12:40.820 --> 00:12:44.290
All memory management is also
built on top of Mach Primitives.

00:12:44.320 --> 00:12:47.770
So at the very lowest level again,
there's management of, if you will,

00:12:47.780 --> 00:12:51.700
VM objects and the handling of virtual
memory and the paging services.

00:12:51.700 --> 00:12:56.700
And at your application,
you're probably dealing with things more

00:12:56.700 --> 00:13:02.260
like Malik or other kinds of services,
GetPointer or NewPointer, rather,

00:13:02.260 --> 00:13:05.640
depending on the type of
application that you're using.

00:13:05.810 --> 00:13:08.870
But fundamentally,
when it gets right down to actually

00:13:08.870 --> 00:13:12.440
managing the memory at the OS level,
Mach is responsible.

00:13:13.090 --> 00:13:16.530
And again, as I mentioned before,
with Mach built on this concept

00:13:16.620 --> 00:13:20.020
of inter-process communication,
that all kernel-to-user,

00:13:20.020 --> 00:13:23.160
and user-to-kernel,
and user-to-user communication,

00:13:23.160 --> 00:13:27.480
and what I mean by user-to-user is user
space from a more process architecture,

00:13:27.480 --> 00:13:29.870
processor architecture perspective.

00:13:30.030 --> 00:13:32.190
So that all that communication
that exists in the system

00:13:32.300 --> 00:13:34.970
between applications,
and between applications in the OS,

00:13:34.970 --> 00:13:37.500
are done,
built on top of these Mach primitives.

00:13:37.720 --> 00:13:42.940
Basically, inter-process communication,
RPC, or what you'll end up hearing a lot,

00:13:42.940 --> 00:13:45.980
and mentioned in a number
of the documentation,

00:13:45.980 --> 00:13:47.170
is Mach ports.

00:13:47.580 --> 00:13:50.850
Now to get into this a little
bit more and give you a sense of

00:13:50.890 --> 00:13:55.630
exactly how the system actually
uses some of these facilities,

00:13:55.700 --> 00:13:58.700
I want to invite Joe Sokol up on stage.

00:13:58.750 --> 00:14:03.810
And what we're going to do is
show you that as you're running

00:14:03.810 --> 00:14:07.570
the applications on your system,
that there's actually the ability to

00:14:07.570 --> 00:14:11.890
look at the system much more from a,
if you will, a systems perspective to see

00:14:11.890 --> 00:14:16.420
kind of the impact of your
application at the OS level.

00:14:17.100 --> 00:14:23.520
Okay, so many of you are
probably familiar with...

00:14:23.760 --> 00:14:27.640
With the applica- with
TOP running on UNIX,

00:14:27.710 --> 00:14:31.690
which is capable of showing you a
lot of stuff going on in the system.

00:14:31.860 --> 00:14:34.910
What we're going to do here
today is just kind of take a look

00:14:34.910 --> 00:14:39.790
at a simple little Carbon app,
because that's kind of the,

00:14:39.790 --> 00:14:44.700
a runtime environment that isn't quite
so used to running on top of UNIX.

00:14:44.700 --> 00:14:49.010
And to show you that, in fact,
just because it's Carbon, right,

00:14:49.010 --> 00:14:52.700
it actually is making use of
a lot of these Mac services.

00:14:52.700 --> 00:14:55.710
So you're going to see the
fact that their threads,

00:14:55.710 --> 00:14:58.690
their ports,
being allocated on your behalf.

00:14:58.700 --> 00:15:03.540
And we're going to take a little
look at some characteristics of

00:15:03.540 --> 00:15:08.690
performance or lack of performance
that we'd like you to avoid.

00:15:12.910 --> 00:15:17.840
So the little app is called
Wait Next Event Loop.

00:15:17.840 --> 00:15:22.650
And the first thing we're going to take
a look at is what it means to have an app

00:15:22.790 --> 00:15:29.370
that is basically not only compute bound,
but basically running through--

00:15:29.370 --> 00:15:34.960
take a slightly different view
here-- a lot of system calls.

00:15:34.960 --> 00:15:38.840
Okay, so the Wait Next Event in the
Carbon Runtime is actually

00:15:39.160 --> 00:15:42.900
implemented with a few
Mach calls and a few BSD calls.

00:15:42.910 --> 00:15:45.490
But when you amplify that,
if you're just sitting in the loop doing

00:15:45.500 --> 00:15:50.190
a Wait Next Event with a zero timeout,
basically you get really,

00:15:50.190 --> 00:15:51.680
really busy on the system.

00:15:51.680 --> 00:15:55.510
Now this has basically
three bad aspects to it.

00:15:55.520 --> 00:15:57.520
The first one is kind of obvious.

00:15:57.520 --> 00:16:01.420
In a time-sharing system,
our little test app here,

00:16:01.570 --> 00:16:04.220
his priority is diving way down.

00:16:04.220 --> 00:16:04.960
And it's going to stay down.

00:16:04.960 --> 00:16:06.960
Because he's never blocking.

00:16:06.960 --> 00:16:11.920
So you might not like the responsiveness
you get in this app over time.

00:16:11.960 --> 00:16:14.660
Secondly,
one that you might not think about

00:16:14.660 --> 00:16:18.520
so much is you're keeping a number
of pages hot all the time because

00:16:18.570 --> 00:16:20.980
you're constantly executing them.

00:16:20.980 --> 00:16:24.920
So those are pages that the
VM system might have been able to,

00:16:24.920 --> 00:16:28.120
you know,
steal and actually give to a foreground

00:16:28.240 --> 00:16:30.960
application that really needs them.

00:16:31.110 --> 00:16:34.930
So it's continuing to put
pressure and competing for memory.

00:16:34.960 --> 00:16:39.740
And then the third thing is all of our

00:16:40.010 --> 00:16:45.950
The power management is actually driven
and triggered off of our idle loop,

00:16:46.040 --> 00:16:52.000
which is an actual Mach thread that gets
run when there's nothing else to run.

00:16:52.020 --> 00:16:56.980
So that is where we make the decisions
to put the system into nap or doze

00:16:56.980 --> 00:17:00.000
mode to reduce the power consumption.

00:17:00.000 --> 00:17:03.560
Not the deep sleep,
but these other modes that allow us

00:17:03.560 --> 00:17:06.000
to cut back on power consumption.

00:17:06.000 --> 00:17:10.000
The application itself is basically
implementing an idle loop.

00:17:10.210 --> 00:17:13.990
That does not allow us to
enter into those modes.

00:17:14.000 --> 00:17:19.540
Another thing that we can look
at with TOP is some of the

00:17:19.690 --> 00:17:22.000
other resource utilization.

00:17:22.170 --> 00:17:25.550
So again,
you can see that this is a very simple,

00:17:25.560 --> 00:17:29.000
dumb,
hello world style Carbon application.

00:17:29.140 --> 00:17:35.000
And we've managed to allocate
him two threads and 61 ports.

00:17:35.000 --> 00:17:39.960
So these are things that are happening
as part of the Carbon runtime model.

00:17:40.000 --> 00:17:47.190
So another thing we can show is,
let's go and cut down on the amount of,

00:17:47.190 --> 00:17:50.650
let me flip back here real quick, sorry.

00:17:51.470 --> 00:17:53.400
This is a little bit easier to see.

00:17:53.400 --> 00:17:57.790
In terms of the CPU utilization
and the number of system calls,

00:17:57.800 --> 00:18:01.800
we've now simply made the wait
next event wait for one tick.

00:18:01.830 --> 00:18:03.740
So instead of it just
being strictly pulled,

00:18:03.740 --> 00:18:08.400
even just going to a one tick wait
really reduces the load on the system.

00:18:08.450 --> 00:18:14.330
If we go to something that's a
little more approaching infinity,

00:18:14.330 --> 00:18:16.400
then of course it goes real quiescent.

00:18:16.400 --> 00:18:20.710
So even if you can't construct the app
to be purely an event driven model,

00:18:20.830 --> 00:18:24.860
if you have an event loop,
if you can at least make the times

00:18:24.860 --> 00:18:29.260
that you're blocking for long,
that really helps in terms of

00:18:29.260 --> 00:18:31.780
relieving pressure in the system.

00:18:32.090 --> 00:18:38.650
Alright,
so now we want to show a memory leak.

00:18:39.630 --> 00:18:43.560
So again,
TOP can be used to see things like

00:18:43.560 --> 00:18:47.100
memory leaks going on in the system.

00:18:47.100 --> 00:18:51.600
You'll notice under the Rprivate,
which is the resident private column,

00:18:51.630 --> 00:18:54.260
that all of a sudden we have
a little plus sign sticking

00:18:54.350 --> 00:18:55.550
out there on the right.

00:18:55.600 --> 00:19:00.700
And what that's indicating is that
that actually is a growing size there,

00:19:00.700 --> 00:19:03.600
so you can see the size going up slowly.

00:19:03.600 --> 00:19:07.260
This is basically a
4K leak once a second.

00:19:07.610 --> 00:19:11.860
Now if we were to be leaking
every time around that event loop,

00:19:11.860 --> 00:19:18.180
we don't really enforce any kind
of real upper limits on the amount

00:19:18.180 --> 00:19:19.600
of memory that an app can obtain.

00:19:19.630 --> 00:19:26.050
So it is probably a good idea on
your part to watch your app and make

00:19:26.100 --> 00:19:29.600
sure that it doesn't have any leaks.

00:19:29.600 --> 00:19:33.100
Because over time, maybe the app stays up
for a long period of time,

00:19:33.110 --> 00:19:35.600
of course that would
just keep going larger,

00:19:35.600 --> 00:19:35.600
going longer and longer.

00:19:35.600 --> 00:19:40.340
Growing larger and larger over
that period of time to the

00:19:40.340 --> 00:19:45.580
point where you might run out
of paging space on the system.

00:19:45.610 --> 00:19:47.560
So an app can approach
3 gigabytes in size.

00:19:47.600 --> 00:19:49.600
Thank you, Joe.

00:19:49.600 --> 00:19:51.600
All right.

00:19:51.600 --> 00:19:53.600
So.

00:19:59.820 --> 00:20:01.800
Back to slides here.

00:20:01.800 --> 00:20:05.900
So I think it's important to
realize that even though you may

00:20:05.900 --> 00:20:09.570
be thinking of your application
in terms of the Carbon API space,

00:20:09.570 --> 00:20:13.800
or if you're writing a new app in Cocoa,
that there actually is a lot going

00:20:13.800 --> 00:20:16.910
on in the system under the covers,
and that there are actually tools that

00:20:17.220 --> 00:20:23.790
you can use to be able to tell what the
actual resource usage and the effects,

00:20:23.810 --> 00:20:26.790
if you will, of your application are
on the rest of the system.

00:20:26.800 --> 00:20:30.310
If you're interested in learning
more about the Darwin kernel,

00:20:30.310 --> 00:20:33.890
there's a session later this week
on Friday that I encourage you to

00:20:33.890 --> 00:20:35.800
go to over in the Civic Center.

00:20:35.910 --> 00:20:41.920
And this particular session will not
only cover the Mach aspect of the system,

00:20:41.920 --> 00:20:46.640
but will also talk quite a bit
about the BSD kernel as well.

00:20:47.320 --> 00:20:51.440
Moving on in our tour now
into the I/O Kit space.

00:20:51.440 --> 00:20:58.130
I/O Kit is an object-oriented framework
that's basically designed to try and

00:20:58.190 --> 00:21:02.200
ease the process for developing and
implementing drivers on Mac OS X.

00:21:02.200 --> 00:21:06.710
It has a lot of kind of native
or inherent capabilities that

00:21:06.780 --> 00:21:09.200
are part of that framework.

00:21:09.200 --> 00:21:13.200
Support for things like plug and
play and dynamic device management.

00:21:13.200 --> 00:21:15.660
And of course, again,
those things sound like, you know,

00:21:15.660 --> 00:21:18.640
mom and apple pie kinds of things,
but it's very important to note that,

00:21:18.690 --> 00:21:23.340
again, from the very basis of the system,
that the I/O system is intended to be

00:21:23.340 --> 00:21:28.200
able to support devices that can come
and go as far as the system is concerned.

00:21:28.200 --> 00:21:33.280
That the I/O system itself has no
inherent policy in terms of the,

00:21:33.280 --> 00:21:35.710
you know,
kind of the arrival or the departure

00:21:35.710 --> 00:21:37.200
of given devices on the system.

00:21:37.200 --> 00:21:40.110
That policy is actually
managed up much higher,

00:21:40.110 --> 00:21:42.200
you know, in the system space.

00:21:42.200 --> 00:21:45.580
For example, whether the file system
has a dependency on a,

00:21:45.580 --> 00:21:49.180
you know, volume that happens to
exist on a particular disk.

00:21:49.290 --> 00:21:53.820
But I/O Kit itself supports the ability
for devices to come and go in the system

00:21:53.820 --> 00:21:56.200
and is a very inherent capability.

00:21:56.200 --> 00:22:00.580
Another important aspect of
I/O Kit that's really there from the

00:22:00.580 --> 00:22:03.200
core is support for power management.

00:22:03.200 --> 00:22:07.830
It's that it's expected that all
devices and parts of the system

00:22:07.830 --> 00:22:11.200
participate and are involved in the
process of managing power on the system.

00:22:11.200 --> 00:22:15.190
And we'll talk a little bit
more about that in a minute.

00:22:15.400 --> 00:22:19.200
And as well, I/O Kit is intended to be
very modular and extensible.

00:22:19.200 --> 00:22:22.040
We don't know what kind of
devices may appear five,

00:22:22.130 --> 00:22:23.200
ten years from now.

00:22:23.220 --> 00:22:26.350
And we've tried to make sure that the
basic architecture for I/O Kit can

00:22:26.390 --> 00:22:32.200
be very flexible as new I/O and
device technology come on the scene.

00:22:34.450 --> 00:22:37.620
In addition to that basic capability,
of course,

00:22:37.620 --> 00:22:41.830
I/O Kit does support and provide
the abstractions for all the common,

00:22:41.840 --> 00:22:44.390
you know, class of devices that
exist in the system,

00:22:44.400 --> 00:22:46.900
things like SCSI and ATA and
USB and stuff like that.

00:22:47.070 --> 00:22:50.840
And those are all done through another
aspect of the framework called families,

00:22:50.840 --> 00:22:53.210
and we'll talk about
that in a minute as well.

00:22:54.220 --> 00:22:55.590
Again, I/O Kit is a framework.

00:22:55.660 --> 00:22:58.290
It's actually an
object-oriented framework,

00:22:58.340 --> 00:22:59.100
C++ based.

00:22:59.240 --> 00:23:03.190
And it provides basically the common
kernel services and facilities for

00:23:03.230 --> 00:23:05.540
being able to support I/O in the system.

00:23:05.700 --> 00:23:09.710
And it also has the facilities to
be able to enable the communication

00:23:09.710 --> 00:23:14.610
from the kernel to the user space,
so that the actual I/O can get

00:23:14.610 --> 00:23:17.090
up to where the applications
can take advantage of it.

00:23:17.210 --> 00:23:20.330
In many cases, that's done through other
layers of abstraction,

00:23:20.330 --> 00:23:24.100
but the inherent capability for being
able to do that is built into I/O Kit.

00:23:24.100 --> 00:23:28.660
I/O Kit, in effect,
models the physical world, if you will.

00:23:28.690 --> 00:23:32.100
As you think about your computer,
there's a motherboard, and there's chips,

00:23:32.120 --> 00:23:38.190
and there's potentially a PCI bridge,
and potentially PCI cards,

00:23:38.190 --> 00:23:40.490
and a graphics card,
or a SCSI card that's in there.

00:23:40.630 --> 00:23:45.200
And I/O Kit actually is responsible
for being able to develop that model,

00:23:45.200 --> 00:23:47.100
if you will, of all those devices.

00:23:47.120 --> 00:23:51.310
And then, once it has that model,
being able to actually connect

00:23:51.510 --> 00:23:55.100
up the appropriate driver
to that given hardware,

00:23:55.100 --> 00:23:58.100
so that the rest of the system
can actually talk to it.

00:23:59.500 --> 00:24:02.700
The protocol specifics for any
particular class of devices

00:24:02.700 --> 00:24:04.570
is something we call families.

00:24:04.600 --> 00:24:09.800
A family basically is, if you will,
a domain appropriate abstraction

00:24:09.800 --> 00:24:11.830
for a particular device.

00:24:11.900 --> 00:24:16.380
A good example of this is if you would
compare something like SCSI and audio,

00:24:16.380 --> 00:24:20.360
they're pretty, very separate,
very radically different approach,

00:24:20.530 --> 00:24:22.900
views if you will, on I/O.

00:24:22.910 --> 00:24:27.770
You're probably not as interested in
setting the volume of your SCSI disk,

00:24:27.770 --> 00:24:28.900
for example.

00:24:28.900 --> 00:24:34.600
So the families actually provide the
appropriate API set and capabilities for

00:24:34.600 --> 00:24:37.600
that particular kind of device space.

00:24:38.830 --> 00:24:42.630
The actual device specifics
themselves exist in drivers.

00:24:42.720 --> 00:24:46.200
So that's the part of the system
that directly talks to the hardware.

00:24:46.270 --> 00:24:50.110
And they, in and of themselves,
then communicate with the families,

00:24:50.110 --> 00:24:53.030
and then the families with
the rest of the system.

00:24:53.910 --> 00:24:57.300
As I mentioned, power management is a
very key part of Mac OS X.

00:24:57.300 --> 00:25:00.630
You guys were at the keynote
this morning and saw Avi's demo,

00:25:00.630 --> 00:25:05.970
and it's really quite amazing to see
something like the titanium effectively

00:25:05.970 --> 00:25:08.740
be awake before you can open it.

00:25:08.840 --> 00:25:14.060
I've heard a number of refrigerator door
kinds of stories of trying to make sure,

00:25:14.060 --> 00:25:15.800
is it really off or not?

00:25:15.870 --> 00:25:19.850
But it's because of the architecture
for power management that that

00:25:19.850 --> 00:25:21.770
actually becomes possible.

00:25:21.820 --> 00:25:24.770
It's integral to the
I/O Kit architecture.

00:25:24.800 --> 00:25:27.800
And it's based on this
concept of power planes.

00:25:27.800 --> 00:25:30.650
Much like I mentioned that I/O Kit tries
to model the physical world,

00:25:30.810 --> 00:25:33.940
from the power management perspective,
there's another model that models kind

00:25:33.940 --> 00:25:35.800
of the power distribution in the system.

00:25:35.990 --> 00:25:38.770
And they may not correspond
on a one-to-one basis.

00:25:38.820 --> 00:25:41.000
Depending on how the
hardware is designed,

00:25:41.060 --> 00:25:44.730
the interdependencies at a power
level actually may be different.

00:25:44.800 --> 00:25:49.070
But I/O Kit's responsible for
trying to keep that abstraction and

00:25:49.070 --> 00:25:51.780
that set of relationships together.

00:25:52.060 --> 00:25:56.600
It's important to note that for Mac OS X,
the way we are able to get the speed and

00:25:56.600 --> 00:26:01.160
performance out of wakeup is because of
the full architecture of both I/O Kit as

00:26:01.170 --> 00:26:02.970
well as the rest of the system.

00:26:03.000 --> 00:26:08.000
That the kernel itself is multi-threaded,
the system itself is multi-threaded,

00:26:08.000 --> 00:26:11.110
and that the process of waking
up the system is actually done

00:26:11.110 --> 00:26:12.980
as much in parallel as possible.

00:26:13.000 --> 00:26:15.510
And as a result,
you're able to actually enable

00:26:15.510 --> 00:26:18.930
the parts of the system that are
necessary to get that application

00:26:19.000 --> 00:26:21.000
up and going as quickly as possible.

00:26:21.000 --> 00:26:23.550
As long as it doesn't have
any inherent dependency on,

00:26:23.550 --> 00:26:26.670
you know, the disk or a networking device
which may take a little bit

00:26:26.670 --> 00:26:29.250
longer to come up to speed,
you're able to get up and

00:26:29.250 --> 00:26:31.990
use and interact with your
system at a UI level very,

00:26:32.020 --> 00:26:32.840
very quickly.

00:26:33.000 --> 00:26:36.420
If you're familiar,
certainly with Mac OS 9, in waking up,

00:26:36.550 --> 00:26:40.000
sometimes it can take a pretty
substantially long period of time.

00:26:40.030 --> 00:26:43.000
And part of the reason for that is
the fact that the system is very,

00:26:43.000 --> 00:26:43.000
very fast.

00:26:43.000 --> 00:26:46.350
The system is very serially dependent
on making sure that all those

00:26:46.350 --> 00:26:50.990
components actually are fully awake
before you can access any part of it.

00:26:51.100 --> 00:26:54.430
In addition, things like AppleTalk,
for example, have to go through the

00:26:54.430 --> 00:26:55.900
process of renegotiating.

00:26:55.900 --> 00:26:57.930
If you happen to have
AppleTalk enabled on 9,

00:26:57.930 --> 00:27:00.150
have to go through the
process of renegotiating node

00:27:00.150 --> 00:27:02.590
numbers and such like that,
which end up having to be done

00:27:02.590 --> 00:27:04.290
before the system can fully wake up.

00:27:04.630 --> 00:27:08.270
On 10, again, because these things
can be done in parallel,

00:27:08.280 --> 00:27:12.800
for those parts of the system that aren't
dependent on having to use AppleTalk,

00:27:12.800 --> 00:27:16.760
for example, if you have that enabled,
you don't have to wait for that

00:27:16.760 --> 00:27:19.000
particular renegotiation to occur
before you can use the system.

00:27:20.170 --> 00:27:23.000
From the application perspective,
you probably won't deal

00:27:23.010 --> 00:27:24.470
with I/O Kit much directly.

00:27:24.630 --> 00:27:28.690
Most of the devices are actually handled
through other layers of abstraction.

00:27:28.920 --> 00:27:32.330
Certainly, if you're interested in disks,
chances are the way you're accessing

00:27:32.330 --> 00:27:36.660
those disks are through file systems,
or networking through either

00:27:36.660 --> 00:27:40.500
your OT interfaces from Carbon,
or from Sockets,

00:27:40.500 --> 00:27:43.350
or other network services that may exist.

00:27:44.890 --> 00:27:48.710
From the application perspective,
you probably won't deal

00:27:48.710 --> 00:27:50.560
with I/O Kit much directly.

00:27:50.560 --> 00:27:55.670
Most of the devices are actually handled
through other layers of abstraction.

00:27:55.670 --> 00:28:00.160
Certainly, if you're interested in disks,
chances are the way you're

00:28:00.160 --> 00:28:03.690
accessing those disks are
through a network service.

00:28:03.970 --> 00:28:08.160
Certainly, if you're interested in disks,
chances are the way you're

00:28:08.400 --> 00:28:12.180
accessing those disks are
through a network service.

00:28:13.500 --> 00:28:16.360
There are a lot of sessions
for I/O Kit this week.

00:28:16.370 --> 00:28:18.970
So if you're interested
in various aspects of it,

00:28:19.040 --> 00:28:21.900
be it FireWire or USB,
or the storage drivers,

00:28:21.900 --> 00:28:24.400
or the basic architecture,
I encourage you to go to that.

00:28:24.400 --> 00:28:26.860
And in fact,
immediately after this session,

00:28:26.860 --> 00:28:29.780
there's another overview,
because I couldn't possibly get

00:28:29.780 --> 00:28:31.400
into enough detail on I/O Kit here.

00:28:31.400 --> 00:28:36.130
But I encourage you to go to that session
if you're interested in working either

00:28:36.130 --> 00:28:41.350
at the device level or interested in
devices from an application perspective.

00:28:42.380 --> 00:28:46.060
Moving on now in our tour to
the BSD portion of the system.

00:28:46.180 --> 00:28:49.240
And this is where that power
of UNIX comes into play.

00:28:49.300 --> 00:28:53.300
So there's two aspects
that we look at for BSD,

00:28:53.300 --> 00:28:57.490
and it helps us kind of
manage the different views and

00:28:57.490 --> 00:28:59.260
responsibilities that exist.

00:28:59.300 --> 00:29:02.300
The first is the BSD from
the kernel perspective.

00:29:02.430 --> 00:29:06.490
And the BSD in the kernel is
one that's based on BSD 4.4,

00:29:06.490 --> 00:29:11.110
with a lot of intense integration
that exists between it and

00:29:11.110 --> 00:29:12.300
Mach and it and I/O Kit.

00:29:12.300 --> 00:29:15.300
So if you look at the kernel
environment for Mac OS X,

00:29:15.340 --> 00:29:20.170
it's basically the BSD kernel, I/O Kit,
and Mach are the three key pieces

00:29:20.320 --> 00:29:23.640
that make up the kernel environment.

00:29:24.610 --> 00:29:28.370
The BSD kernel is what actually
provides the OS personality,

00:29:28.380 --> 00:29:31.500
if you will,
APIs and services for the system.

00:29:31.500 --> 00:29:35.990
Much like Mac is completely agnostic
as far as the policy is concerned,

00:29:36.130 --> 00:29:39.900
BSD's responsibility is actually
to manage the policy of the OS.

00:29:39.920 --> 00:29:43.090
So it actually provides the
application process model,

00:29:43.090 --> 00:29:46.230
the support for things like
signals and tracking of file

00:29:46.230 --> 00:29:48.190
descriptors and things like that.

00:29:48.530 --> 00:29:51.320
When your application
dies or gets torn down,

00:29:51.320 --> 00:29:54.740
it's BSD's job to make sure
that all those resources are

00:29:54.740 --> 00:29:56.530
all reclaimed and handled.

00:29:56.700 --> 00:30:00.700
It also is responsible for the
basic security policy of the system.

00:30:00.830 --> 00:30:04.690
So, if you will, that's the concept of
multiple users on the system,

00:30:04.870 --> 00:30:08.610
or even when you take it down
to the file system level,

00:30:08.610 --> 00:30:13.530
being able to manage access to
individual files or pieces of data.

00:30:13.950 --> 00:30:18.250
That basic security policy is a very
inherent part of the BSD system.

00:30:18.330 --> 00:30:20.830
It's a very important part of the
BSD environment and is enforced,

00:30:20.830 --> 00:30:22.300
again, down at the kernel level.

00:30:22.300 --> 00:30:26.300
It's also important to note that
both the file systems architecture

00:30:26.300 --> 00:30:30.300
and the networking architecture
for Mac OS X basically fit

00:30:30.300 --> 00:30:32.660
inside the BSD kernel space.

00:30:32.750 --> 00:30:36.680
They are both based on
the BSD implementations.

00:30:36.700 --> 00:30:40.650
And we'll talk more about both file
systems and networking in a few minutes.

00:30:41.560 --> 00:30:48.330
The system framework is basically how
we try to describe or abstract the

00:30:48.470 --> 00:30:51.710
set of interfaces that BSD provides.

00:30:51.910 --> 00:30:57.340
And it's basically the system calls and,
if you will, POSIX level interfaces

00:30:57.380 --> 00:31:01.260
and BSD system APIs,
if you will, for the system.

00:31:01.440 --> 00:31:06.210
If you're accessing things
like porting a BSD application,

00:31:06.460 --> 00:31:10.890
this is actually the APIs that
you're most likely will write to.

00:31:11.050 --> 00:31:16.250
The application environments
themselves tend to be written

00:31:16.250 --> 00:31:18.400
on top of this API set.

00:31:18.440 --> 00:31:21.890
The system framework is also responsible
for other kinds of services as well.

00:31:21.890 --> 00:31:25.400
Things like Pthreads, the math library,
the basic C libraries.

00:31:25.470 --> 00:31:28.430
Basically,
the very low level sort of APIs and

00:31:28.530 --> 00:31:33.040
services that you expect to be
able to support an OS environment.

00:31:33.500 --> 00:31:40.320
The user environment is kind of another,
if you will, almost a fourth application

00:31:40.320 --> 00:31:42.200
environment that exists on the system.

00:31:42.330 --> 00:31:44.560
You've probably seen all the
other architectural diagrams,

00:31:44.560 --> 00:31:50.560
and they refer to Classic, and Carbon,
and Cocoa, or potentially even Java.

00:31:50.790 --> 00:31:53.570
It's important to note that in terms
of the actual system architecture,

00:31:53.570 --> 00:31:56.240
there's actually one more,
and it's the BSD user environment.

00:31:56.370 --> 00:31:59.950
It's where things like the shells
and command line scripts and

00:32:00.050 --> 00:32:02.040
things like that actually run.

00:32:02.190 --> 00:32:05.890
It's where a lot of the
network administration client

00:32:05.930 --> 00:32:07.940
tools actually execute.

00:32:07.940 --> 00:32:12.360
They're things that are kind of common
command line tools and facilities

00:32:12.360 --> 00:32:14.610
that come from the BSD community.

00:32:14.870 --> 00:32:19.490
It also has a huge number of various
file tools for creating directories and

00:32:19.490 --> 00:32:24.480
copying files and that kind of thing,
as well as tools for being able

00:32:24.480 --> 00:32:28.790
to kill other processes or top,
like we showed you a few minutes ago.

00:32:28.870 --> 00:32:33.800
All these things are available and
exist within the BSD user environment.

00:32:33.800 --> 00:32:37.480
It's also where some very key
and important system services

00:32:37.750 --> 00:32:41.800
or network administrative
services exist in the system.

00:32:42.000 --> 00:32:49.740
Things like NetInfo, DNS services, Bind,
Network Time Protocol Server, System Log,

00:32:49.850 --> 00:32:51.800
and things like Apache.

00:32:51.800 --> 00:32:53.980
It may be important to
note here that if you,

00:32:54.280 --> 00:32:58.190
for example, are running the client
environment and you happen to

00:32:58.190 --> 00:33:01.640
turn on personal web sharing,
that it's actually Apache that ends up

00:33:01.640 --> 00:33:03.800
getting launched and run on the system.

00:33:03.800 --> 00:33:07.800
Probably the single most used
web server on the planet.

00:33:07.800 --> 00:33:10.800
But all that stuff
exists behind the scenes.

00:33:10.810 --> 00:33:14.050
and it helps support the system.

00:33:14.810 --> 00:33:17.690
From a developer's perspective,
it's important to note that you

00:33:17.690 --> 00:33:21.250
really want to be kind of aware
of how BSD influences your life.

00:33:21.510 --> 00:33:24.230
Certainly, again, it contributes to the
process model of the system.

00:33:24.380 --> 00:33:28.360
The support for things like signals
and management of file descriptors

00:33:28.360 --> 00:33:33.050
and other important OS resources are
all managed by the BSD process model.

00:33:33.220 --> 00:33:36.100
But there's also things like
environment variables and things

00:33:36.100 --> 00:33:39.330
like that that are also available,
kind of the standard things you

00:33:39.330 --> 00:33:41.060
would expect from a UNIX process.

00:33:41.200 --> 00:33:43.860
It's also responsible
for the security policy,

00:33:43.950 --> 00:33:44.370
again.

00:33:44.620 --> 00:33:48.060
And remember, those will impact the way
your application behaves.

00:33:48.060 --> 00:33:50.490
And from that perspective,
you should be aware that

00:33:50.720 --> 00:33:53.650
things that you maybe have been
used to doing under Mac OS 9,

00:33:53.650 --> 00:33:57.550
you know, that the security policy of
the system actually plays a

00:33:57.560 --> 00:33:59.300
significant role here under Mac OS X.

00:33:59.650 --> 00:34:02.110
Whether or not you can access
certain files and places that

00:34:02.110 --> 00:34:04.680
you can write into the system,
things like that.

00:34:06.000 --> 00:34:08.110
It's also important to
step back a bit from that,

00:34:08.230 --> 00:34:10.390
from the application perspective,
and look at BSD from the

00:34:10.390 --> 00:34:11.690
developer perspective.

00:34:11.830 --> 00:34:15.270
There are a ton of tools that
exist in this environment.

00:34:15.400 --> 00:34:18.470
Now certainly we'd try
and discourage the BSD,

00:34:18.470 --> 00:34:22.280
kind of, UNIX user experience for
our typical end users,

00:34:22.500 --> 00:34:24.810
but from a developer perspective,
this is an incredibly

00:34:24.910 --> 00:34:26.400
powerful part of the system.

00:34:26.410 --> 00:34:29.550
As you saw with Top,
there's ways to actually look at the

00:34:29.550 --> 00:34:31.850
system kind of from behind the scenes.

00:34:31.850 --> 00:34:35.560
This particular setup we had was
actually two systems we telneted

00:34:35.560 --> 00:34:38.990
into the system that was running
the application to run Top,

00:34:39.030 --> 00:34:43.350
so we could observe it without
impacting the UI in any particular way.

00:34:43.410 --> 00:34:46.340
Kind of being able to
put instrument probes,

00:34:46.340 --> 00:34:48.030
if you will, on the system.

00:34:48.400 --> 00:34:50.820
But there's a huge number of other
tools that are available there that

00:34:50.820 --> 00:34:54.150
might help building your applications,
or just managing your

00:34:54.150 --> 00:34:56.400
development resources.

00:34:56.400 --> 00:35:01.380
and the environment that you work in.

00:35:02.170 --> 00:35:08.860
In porting UNIX applications to Mac OS X,
it's important to note that there's a

00:35:08.860 --> 00:35:11.100
lot of options that are available here.

00:35:11.100 --> 00:35:13.270
Later this week,
there'll be a session that'll

00:35:13.270 --> 00:35:16.100
actually show you a couple of
ways that you can approach this.

00:35:16.100 --> 00:35:20.820
If you happen to have your favorite
UNIX tools or other things that

00:35:20.820 --> 00:35:24.230
you might want to use on Mac OS X,
porting them over to X is

00:35:24.350 --> 00:35:26.100
actually fairly straightforward.

00:35:26.100 --> 00:35:31.170
In fact, you can actually use a kind of a
stepping stone approach to getting

00:35:31.170 --> 00:35:33.100
applications on the Mac OS X.

00:35:33.100 --> 00:35:35.100
If you happen to have
one that even has a GUI,

00:35:35.100 --> 00:35:40.100
there's a third-party X Windows server,
for example, that's available.

00:35:40.100 --> 00:35:43.440
So if you want to port over an
X-based application and get that

00:35:43.510 --> 00:35:47.740
up and running very quickly,
and then spend the time to actually

00:35:47.750 --> 00:35:52.070
wrap it in something like Cocoa to
replace it with a more aqua-friendly,

00:35:52.120 --> 00:35:55.100
more user-friendly application.

00:35:55.100 --> 00:35:59.710
That's a user-friendly experience
that ends up being a very easy

00:35:59.710 --> 00:36:01.100
thing to do under Mac OS X.

00:36:01.100 --> 00:36:05.200
It's also interesting to note
that it's also very possible,

00:36:05.200 --> 00:36:08.100
and something we actually
do a lot ourselves,

00:36:08.100 --> 00:36:11.100
of being able to use UNIX tools
from within a GUI application.

00:36:11.100 --> 00:36:18.100
Many of our control panels, for example,
are actually, you know,

00:36:18.100 --> 00:36:20.040
execute command line
tools in the background.

00:36:20.100 --> 00:36:24.100
They actually, you know,
are able to launch and interact with

00:36:24.100 --> 00:36:24.100
a UNIX command line application.

00:36:24.100 --> 00:36:26.100
So you can actually use that in a
very easy command line environment.

00:36:26.100 --> 00:36:28.100
Again,
that's completely hidden from the user.

00:36:28.100 --> 00:36:31.030
Apache is an excellent example of that.

00:36:31.100 --> 00:36:35.100
If you go out and get an Apache manual
of how to do full system administration,

00:36:35.100 --> 00:36:39.050
there's some pretty thick books out
there for administrating the various

00:36:39.170 --> 00:36:41.100
configuration files and stuff.

00:36:41.100 --> 00:36:43.210
Your user should never
have to deal with that,

00:36:43.210 --> 00:36:46.910
and it's possible to actually wrap
that kind of power in something

00:36:46.940 --> 00:36:49.100
that's very easy for them to use.

00:36:51.590 --> 00:36:54.210
There's a number of sessions
also that are related to the

00:36:54.210 --> 00:36:55.660
BSD aspect of the system.

00:36:55.900 --> 00:36:58.500
Leveraging BSD services
later part of the week,

00:36:58.500 --> 00:37:01.700
we'll actually go through and
demo porting some UNIX tools and

00:37:01.700 --> 00:37:04.160
wrapping them in a Cocoa application.

00:37:04.470 --> 00:37:08.500
But there's also a couple of
other important sessions as well.

00:37:08.880 --> 00:37:13.170
Threading on Mac OS X,
and I will talk about the Pthreads and

00:37:13.250 --> 00:37:15.900
some of the other threading options
that you have available on the system.

00:37:16.110 --> 00:37:20.700
And as well, support for directory
services and such on Mac OS X.

00:37:22.960 --> 00:37:24.800
Moving on now to File Systems.

00:37:24.800 --> 00:37:28.430
Whoops, sorry about that.

00:37:29.050 --> 00:37:32.030
File Systems, of course,
is a lot more complex than just

00:37:32.030 --> 00:37:34.000
this little blob on the diagram.

00:37:34.000 --> 00:37:37.940
It's actually a lot of very,
very broad range of file systems

00:37:37.940 --> 00:37:40.600
that are supported within the system.

00:37:40.770 --> 00:37:47.620
And this is all based on basically
the BSD file system architecture.

00:37:48.280 --> 00:37:50.660
It's important to note that the
file system's implementation is

00:37:50.740 --> 00:37:55.360
part of the BSD kernel environment,
and it's based on the VFS design.

00:37:55.400 --> 00:37:59.310
If you go out and get your
favorite BSD UNIX text,

00:37:59.380 --> 00:38:02.750
it actually is a great reference
for being able to learn

00:38:02.750 --> 00:38:04.390
about the VFS architecture.

00:38:04.500 --> 00:38:10.530
But it's basically a stackable
virtual file system model,

00:38:10.530 --> 00:38:14.200
which we've extended both from
the basic POSIX interfaces,

00:38:14.320 --> 00:38:19.490
beyond that, to be able to support more
rich file systems such as HFS+.

00:38:20.310 --> 00:38:23.410
It can support virtually any
kind of file system type.

00:38:23.670 --> 00:38:25.690
In fact, on Mac OS X,
we support a huge number

00:38:25.690 --> 00:38:27.070
of file system types today.

00:38:27.410 --> 00:38:30.490
And there are third parties
that are also been making file

00:38:30.570 --> 00:38:32.170
system services available.

00:38:32.510 --> 00:38:36.330
Recently,
I read that the Andrew file system,

00:38:36.330 --> 00:38:39.910
for example,
has been ported now to Mac OS X.

00:38:40.790 --> 00:38:43.830
We've also extended those file
system interfaces to be able

00:38:43.910 --> 00:38:45.550
to take advantage of Unicode.

00:38:45.710 --> 00:38:50.600
So you'll find that there are
UTF-8 interfaces available so that

00:38:50.600 --> 00:38:54.520
you can be able to take advantage
of localized file names and such.

00:38:54.910 --> 00:38:59.290
But it's also really important to note
that from a way we've designed Mac OS X,

00:38:59.290 --> 00:39:01.300
much like how we've
approached the I/O system,

00:39:01.300 --> 00:39:06.640
that we have no particular file
system affinity at the OS level.

00:39:06.790 --> 00:39:10.730
In that we don't particularly
care whether or not it's

00:39:10.820 --> 00:39:12.990
HFS+, whether it's UFS.

00:39:13.150 --> 00:39:16.510
We are intentionally trying to design
the architecture of the system so that

00:39:16.510 --> 00:39:20.240
it can be flexible across a number of
different file system architectures.

00:39:20.360 --> 00:39:25.260
As you move up the application chain,
more of those high level services

00:39:25.260 --> 00:39:29.480
and capabilities are exported
through your applications.

00:39:31.900 --> 00:39:34.950
The file system is responsible
for enforcing the file system

00:39:34.950 --> 00:39:36.780
security policy of the system.

00:39:36.780 --> 00:39:40.230
Again, unlike Mac OS 9 in this respect,
there's a concept of security

00:39:40.340 --> 00:39:41.800
that does exist in the system.

00:39:41.800 --> 00:39:46.270
Your ability to write to a given file,
rename, even execute privileges all exist

00:39:46.270 --> 00:39:48.600
and are enforced by the file system.

00:39:48.790 --> 00:39:52.080
There's a concept of users and
groups that is throughout the system,

00:39:52.080 --> 00:39:55.590
and the access control is all
managed by this aspect of the system.

00:39:55.600 --> 00:40:00.160
The application environments themselves
tend to provide the abstracted level

00:40:00.260 --> 00:40:02.600
of interfaces that you'll tend to use.

00:40:02.600 --> 00:40:05.740
If you're writing a Carbon app,
you're using the file manager,

00:40:05.740 --> 00:40:09.550
and things like resource forks and
things like that are fairly fluidly

00:40:09.550 --> 00:40:11.600
part of that particular environment.

00:40:11.600 --> 00:40:14.250
If you're writing in Cocoa,
you're going to be using

00:40:14.250 --> 00:40:17.650
something like NSFile,
and where the use of resource forks

00:40:17.650 --> 00:40:21.600
is not the typical way of writing
an application in this space.

00:40:21.600 --> 00:40:24.580
Or if you're porting a BSD application,
you'll end up using the POSIX plugin.

00:40:24.610 --> 00:40:27.640
plus plus APIs.

00:40:28.020 --> 00:40:31.560
And what I mean by the POSIX++ is
just the POSIX plus the extensions

00:40:31.560 --> 00:40:34.230
that we've provided for Mac OS X.

00:40:34.650 --> 00:40:37.700
Now to talk a little bit more,
give you a better idea of

00:40:37.810 --> 00:40:40.850
what the implications are of
file systems in the system,

00:40:41.120 --> 00:40:44.130
has Joe to come back up again?

00:40:46.560 --> 00:40:49.300
And again, much like Mach,
where there's a lot going on behind

00:40:49.390 --> 00:40:53.600
the scenes on your application,
the same is true for file systems.

00:40:58.460 --> 00:41:03.660
Okay, so we're going to talk a little
bit about a tool called FS Usage.

00:41:03.670 --> 00:41:08.570
Let me get the top out of the way here.

00:41:11.150 --> 00:41:16.640
That basically is something that
you're probably not familiar with.

00:41:16.640 --> 00:41:19.840
I don't believe it shows
up on other UNIX systems.

00:41:19.870 --> 00:41:22.840
It's something that we developed here.

00:41:22.900 --> 00:41:26.630
But it will give you a comprehensive
list of all the files and

00:41:26.630 --> 00:41:29.650
directories being touched,
and the size of the

00:41:29.650 --> 00:41:32.610
I/Os that are going on,
the amount of time that you're

00:41:32.690 --> 00:41:35.350
waiting for that I/O to complete.

00:41:35.660 --> 00:41:42.000
There's also on the far left there,
you can see a current clock

00:41:42.090 --> 00:41:45.440
with millisecond precision.

00:41:45.520 --> 00:41:49.360
And then the name of the task that's
actually causing the I/Os to occur.

00:41:49.360 --> 00:41:53.650
So it's both comprehensive,
both in kind of a global manner

00:41:53.650 --> 00:41:57.500
if you're looking at the,
basically allowing to look at all of the

00:41:57.500 --> 00:41:58.940
tasks that are running in the system.

00:41:58.940 --> 00:42:01.850
Or you can focus it in
on a particular task.

00:42:02.000 --> 00:42:05.140
But I find it more interesting to look
at it with more of the global method.

00:42:05.140 --> 00:42:08.650
Just because there are lots of things
that are happening on the system that

00:42:08.730 --> 00:42:12.220
you trigger when the application does
something that you might not be aware of.

00:42:12.410 --> 00:42:15.510
Because a lot of the services
are tied in directly to some

00:42:15.510 --> 00:42:17.390
of these higher level calls.

00:42:17.470 --> 00:42:21.190
It's useful for exposing
redundancies of access.

00:42:21.270 --> 00:42:23.040
Pretty obvious.

00:42:23.130 --> 00:42:26.540
And as I alluded to earlier,
it can show you where your app

00:42:26.540 --> 00:42:28.750
is blocking or waiting for I/Os.

00:42:28.780 --> 00:42:33.640
So if the app feels sluggish,
you can use this tool to determine

00:42:33.750 --> 00:42:34.680
whether or not it's doing something.

00:42:34.680 --> 00:42:38.680
It's due to lots of wait time for I/Os.

00:42:38.720 --> 00:42:40.960
And it'll even show you where
you're waiting for synchronous

00:42:41.120 --> 00:42:42.040
page ins to complete.

00:42:42.100 --> 00:42:46.830
So where the app's trying to page
fault some of its code in or its data.

00:42:46.880 --> 00:42:50.850
And then one other interesting aspect,
which you can,

00:42:51.010 --> 00:42:55.460
I would suggest reading the man page
so you can see how to turn this on.

00:42:55.570 --> 00:43:01.230
But there's a little back door trap
that basically enables the display

00:43:01.230 --> 00:43:04.150
of the higher level Carbon calls.

00:43:04.250 --> 00:43:09.220
So for you Carbon developers out there
who are curious as to what system calls,

00:43:09.220 --> 00:43:12.200
what Unix system calls we turn
a lot of these higher level

00:43:12.220 --> 00:43:16.180
Carbon file manager calls into.

00:43:16.180 --> 00:43:17.780
FS usage will show you that.

00:43:17.780 --> 00:43:21.690
It will actually show you
the encompassing or the calls

00:43:21.870 --> 00:43:26.170
being encompassed by these
various higher level calls.

00:43:26.480 --> 00:43:30.100
So we do something like open the.

00:43:30.300 --> 00:43:54.800
[Transcript missing]

00:43:59.910 --> 00:44:03.510
So again, it's worth noting here that
for much of the things that are

00:44:03.510 --> 00:44:07.580
going on in your applications,
that down deep underneath

00:44:07.580 --> 00:44:11.840
that application,
there's a lot of OS facilities in

00:44:11.960 --> 00:44:13.960
play to make those things possible.

00:44:14.120 --> 00:44:17.740
And there are a lot of very powerful and
useful tools on Mac OS X that you can

00:44:17.740 --> 00:44:24.240
take advantage of to be able to see the
system from this kind of perspective.

00:44:24.250 --> 00:44:27.080
If you're interested in learning
more about the file system,

00:44:27.080 --> 00:44:30.210
there's a whole session on that as
well on Wednesday in the morning.

00:44:30.340 --> 00:44:32.700
I encourage you to go to that.

00:44:32.750 --> 00:44:34.430
Clark is always quite entertaining.

00:44:34.450 --> 00:44:39.990
Moving on in our tour now to networking.

00:44:42.010 --> 00:44:45.330
For networking on the Mac OS X, again,
networking is part of the

00:44:45.330 --> 00:44:46.970
BSD kernel environment.

00:44:46.970 --> 00:44:50.560
And it's based on the,
as Avi put this morning,

00:44:50.750 --> 00:44:54.940
the kind of network, the reference stack,
if you will,

00:44:55.080 --> 00:44:57.470
for IP in the internet world.

00:44:57.720 --> 00:45:02.270
We're based on the 4/4 TCP/IP stack,
which we've actually

00:45:02.270 --> 00:45:04.940
synced up with FreeBSD 3.2.

00:45:04.940 --> 00:45:09.110
And this is a Sockets
API based environment.

00:45:09.430 --> 00:45:12.500
It comes with quite a lot of
powerful capabilities built

00:45:12.500 --> 00:45:14.230
into the networking stack.

00:45:14.580 --> 00:45:16.770
Certainly support for
things like multi-homing,

00:45:16.770 --> 00:45:20.140
and routing, and firewall,
and network address translation,

00:45:20.140 --> 00:45:21.300
or NAT mechanisms.

00:45:21.300 --> 00:45:26.130
These are all pretty basic services
that exist in our networking stack.

00:45:26.900 --> 00:45:30.560
Another very key one, however,
is this concept of auto-configuration.

00:45:30.560 --> 00:45:32.990
And again, Avi touched on that in
the keynote this morning.

00:45:33.260 --> 00:45:37.550
But it's a very important part of
our architecture and a key part of

00:45:37.610 --> 00:45:42.090
foundation that we're working on
as we move forward with Mac OS X.

00:45:43.960 --> 00:45:46.670
For the networking environment,
the way that you actually

00:45:46.670 --> 00:45:50.280
go about extending that is
through something we call NKEs,

00:45:50.280 --> 00:45:52.550
or Network Kernel Extensions.

00:45:52.650 --> 00:45:56.760
There's basically a model that
we've developed for being able to

00:45:56.760 --> 00:46:00.000
extend or enhance the capabilities
of our networking stack.

00:46:00.070 --> 00:46:03.640
Much like you can create drivers
for a given piece of hardware,

00:46:03.700 --> 00:46:08.180
or you can write a file system
kernel extension for being able to

00:46:08.180 --> 00:46:13.900
support new and exotic file systems,
there's also ways for you to be able to

00:46:13.900 --> 00:46:17.140
extend the networking aspect of Mac OS X.

00:46:17.280 --> 00:46:19.980
One important part of the
architecture for our networking is

00:46:19.980 --> 00:46:22.200
actually how we support Classic.

00:46:22.380 --> 00:46:27.330
And a very key part of that architecture
of the system is to be able to support so

00:46:27.440 --> 00:46:31.720
that the virtual environments above us,
for example, like Classic,

00:46:31.820 --> 00:46:34.800
or maybe something like a
virtual PC-like environment,

00:46:34.970 --> 00:46:39.200
can actually share the core networking
services and configuration and setup.

00:46:39.200 --> 00:46:42.990
So it's not necessary to have
multiple IP addresses for each virtual

00:46:43.000 --> 00:46:45.420
environment that exists on the system.

00:46:46.110 --> 00:46:50.820
We also support access of networking
through an open transport layer that

00:46:50.820 --> 00:46:53.340
exists for porting Carbon applications.

00:46:53.460 --> 00:46:57.230
Things like Internet Explorer and
things like that all use the open

00:46:57.290 --> 00:47:01.010
transport services that we provide
as Carbon as a way to get their

00:47:01.010 --> 00:47:02.990
app over quickly onto Mac OS X.

00:47:03.130 --> 00:47:08.870
We also support PPP and PPP over Ethernet
as key services that exist in Mac OS X.

00:47:09.170 --> 00:47:12.780
And PPPoE is something
that's new for Mac OS.

00:47:13.240 --> 00:47:17.530
The ability to be able to
inherently be able to connect to

00:47:17.730 --> 00:47:20.300
your DSL or cable modem provider.

00:47:21.950 --> 00:47:24.920
Also built into Mac OS X is
the support for DHCP,

00:47:24.920 --> 00:47:26.890
both the client and server.

00:47:26.980 --> 00:47:30.830
So this is actually used in
different situations depending

00:47:30.830 --> 00:47:32.040
on how Mac OS X is set up.

00:47:32.100 --> 00:47:36.230
Certainly as a full server environment,
you can administrate and manage

00:47:36.230 --> 00:47:38.630
DHCP for things like Netboot and stuff.

00:47:38.940 --> 00:47:41.900
But it's also used for being
able to do ad-hoc networking.

00:47:42.960 --> 00:47:47.520
Also built into Mac OS X is
the support for DHCP,

00:47:47.520 --> 00:47:50.400
both the client and server.

00:47:50.400 --> 00:47:56.180
So this is actually used in
different situations depending

00:47:56.180 --> 00:47:58.600
on how Mac OS X is set up.

00:47:58.770 --> 00:48:04.580
But it's also used for being
able to do ad-hoc networking.

00:48:05.440 --> 00:48:11.640
Mobility is a very key part of the
direction of our networking architecture.

00:48:11.640 --> 00:48:14.810
Networking under Mac OS X is already
incredibly rich and powerful through

00:48:14.810 --> 00:48:18.930
the multi-homing and other aspects,
but one area that has not been

00:48:18.940 --> 00:48:23.010
historically been well known
in UNIX networking is the

00:48:23.010 --> 00:48:25.060
ability to deal with mobility.

00:48:25.060 --> 00:48:28.140
And that's something that we
consider to be very critical.

00:48:28.310 --> 00:48:30.860
So we've actually spent quite
a bit of time developing a

00:48:30.860 --> 00:48:34.200
very flexible architecture for
being able to handle mobility,

00:48:34.240 --> 00:48:37.200
be able to support things like
automatic network configuration,

00:48:37.390 --> 00:48:41.000
being able to deal both configuration
and reconfiguration based on the

00:48:41.000 --> 00:48:43.430
link level detection that exists.

00:48:43.560 --> 00:48:47.800
So if you have a portable and you
unplug that cable out of the back,

00:48:47.930 --> 00:48:51.010
it'll automatically notice the
fact that you've removed the cable,

00:48:51.010 --> 00:48:54.700
and if you have an airport,
it'll automatically and silently

00:48:54.700 --> 00:48:57.920
convert over completely to
be able to use the airport if

00:48:57.920 --> 00:49:01.400
you're using DHCP configuration.

00:49:01.400 --> 00:49:04.290
And all of this support is very dynamic.

00:49:05.100 --> 00:49:20.400
[Transcript missing]

00:49:20.720 --> 00:49:23.400
But another key aspect of
it is the ability to support

00:49:23.400 --> 00:49:25.440
application level notification.

00:49:25.440 --> 00:49:29.860
Our mail program is the
first example of this use,

00:49:29.860 --> 00:49:34.100
where an application can
actually be aware of the ability

00:49:34.100 --> 00:49:38.300
of network connectivity and
accessibility to the network.

00:49:38.300 --> 00:49:41.390
So if you actually have had
a chance to play with mail,

00:49:41.450 --> 00:49:44.860
if you remove the cable out of
the back of your system or lose

00:49:44.860 --> 00:49:48.980
connectivity to the internet,
mail will automatically go offline.

00:49:49.100 --> 00:49:51.980
It detects the fact that you
no longer have a connection

00:49:51.980 --> 00:49:53.340
and does the right thing.

00:49:53.620 --> 00:49:57.700
And when you plug it back in, again,
it will automatically be involved

00:49:57.700 --> 00:50:00.790
in the process of reconfiguring
itself and reconnecting it

00:50:00.790 --> 00:50:02.300
to the appropriate servers.

00:50:02.340 --> 00:50:06.230
And this is the kind of behavior
we'd like to see as we move on

00:50:06.230 --> 00:50:08.300
and move forward with Mac OS X.

00:50:08.310 --> 00:50:09.330
Mm-hmm.

00:50:09.580 --> 00:50:12.990
There are a number of sessions
for networking this week.

00:50:13.190 --> 00:50:16.130
Networking Overview exists tomorrow,
and a number of other

00:50:16.130 --> 00:50:18.890
networking sessions tomorrow,
both the Kernel

00:50:18.890 --> 00:50:22.940
extensions for networking,
as well as the Configuration and

00:50:22.940 --> 00:50:25.070
Mobility session as well tomorrow.

00:50:25.220 --> 00:50:28.480
And then there's a feedback
form later this week.

00:50:29.770 --> 00:50:33.270
So take a little side trip here and
talk about how the Core OS and G4

00:50:33.270 --> 00:50:36.480
architecture actually play together.

00:50:36.830 --> 00:50:40.510
This is certainly kind of outside
of the architectural space

00:50:40.940 --> 00:50:44.450
of thinking of the Core OS,
but it's an important part and

00:50:44.460 --> 00:50:48.710
impacts actually our design space for
Mac OS X in terms of how we get some

00:50:48.710 --> 00:50:51.690
incredible performance on the system.

00:50:51.800 --> 00:50:55.720
First and foremost, of course,
is support for the Velocity Engine for

00:50:55.720 --> 00:50:58.610
all the AlteVec unit of the processor.

00:50:58.800 --> 00:51:02.700
And there's a number of libraries
that are available on Mac OS X.

00:51:02.780 --> 00:51:06.530
There's a VDSP library,
which is responsible for basically signal

00:51:06.830 --> 00:51:11.700
processing and fast Fourier transforms
and convolutions and things like that.

00:51:11.700 --> 00:51:15.340
And that library has
existed on Mac OS 9.1,

00:51:15.340 --> 00:51:17.700
but is also available on Mac OS X.

00:51:17.730 --> 00:51:20.960
New for Mac OS X, however,
is a new library called VBLAS,

00:51:20.960 --> 00:51:23.840
the Vector Basic Linear
Algebra Subroutines,

00:51:23.840 --> 00:51:29.650
which basically handle support for
things like large matrix manipulation.

00:51:29.840 --> 00:51:31.570
Basically, this kind of thing is
used to control the VBLAS.

00:51:31.740 --> 00:51:36.180
This kind of thing is used for
things like MP3 coding and decoding,

00:51:36.180 --> 00:51:39.680
MPEG,
speech recognition and image processing.

00:51:39.720 --> 00:51:43.630
Those are common places where this
kind of library would be used.

00:51:43.700 --> 00:51:48.690
And this particular service
is only available on Mac OS X.

00:51:48.700 --> 00:51:54.590
It's important to note that from
this library on a 500 MHz G4,

00:51:54.740 --> 00:51:58.290
this is where we get some of the
really amazing performance numbers

00:51:58.720 --> 00:52:00.700
that are possible because of the G4s.

00:52:00.700 --> 00:52:03.700
2.2 Giga Flops of performance.

00:52:03.700 --> 00:52:05.860
Again,
this kind of stuff is used in things

00:52:05.860 --> 00:52:07.690
like iTunes and stuff like that.

00:52:08.010 --> 00:52:11.700
There's also a number of other
vector libraries that are available.

00:52:11.700 --> 00:52:15.750
Math, the VMathlib,
which is basically a basic math

00:52:15.750 --> 00:52:18.700
library that's been AltaVec tuned.

00:52:18.700 --> 00:52:22.890
Vector Operations and BasicOps,
which is kind of an extension

00:52:22.930 --> 00:52:26.690
to the basic instruction set,
if you will, for the velocity engine.

00:52:26.740 --> 00:52:28.700
And Bignum, which is a sports,
basically large, VLT engine.

00:52:28.700 --> 00:52:29.700
And that's where we get
the most performance.

00:52:29.700 --> 00:52:34.010
you know, 10, 24-bit multiplies,
that kind of thing.

00:52:34.540 --> 00:52:38.870
The other aspect of the G4 worth noting,
and how it plays with

00:52:38.870 --> 00:52:42.460
Mac OS X and the Core OS,
is in multiprocessors.

00:52:42.500 --> 00:52:46.490
Mac OS X inherently supports true SMP.

00:52:46.490 --> 00:52:49.720
This is really
differentiated from Mac OS 9,

00:52:49.720 --> 00:52:54.500
whereas if you have an application,
and you happen to have it on an MP box,

00:52:54.500 --> 00:52:58.500
then unless you've specifically written
your application to use the MP API,

00:52:58.500 --> 00:53:02.590
you won't actually benefit
from any significant degree

00:53:02.590 --> 00:53:04.470
by having an MP system.

00:53:04.550 --> 00:53:08.430
The Mac OS X is very different in that
the system itself takes advantage of

00:53:08.430 --> 00:53:12.500
the processors that are available,
and scales automatically.

00:53:12.750 --> 00:53:16.500
Each thread in the system is capable
of running on a separate processor.

00:53:16.500 --> 00:53:20.200
Again, Mach at the very lowest levels
of the system is the part of the

00:53:20.360 --> 00:53:24.500
system responsible for handling the
scheduling and processor management,

00:53:24.500 --> 00:53:28.040
and will automatically make
sure that each thread on the

00:53:28.340 --> 00:53:32.500
system runs on whatever processor
resources are available.

00:53:32.500 --> 00:53:34.500
This means if you have a single
application with multiple threads,

00:53:34.500 --> 00:53:38.500
each of those threads might actually
run on a different processor.

00:53:38.530 --> 00:53:42.460
And that's really important to note,
because that really tends to be a

00:53:42.460 --> 00:53:45.500
great way of finding situations where
you may not necessarily be doing your

00:53:45.500 --> 00:53:48.410
multithreading in the best possible way,
and doing the locking and

00:53:48.430 --> 00:53:49.500
things that need to occur.

00:53:49.500 --> 00:53:52.590
I encourage,
if you have a multithreaded application,

00:53:52.590 --> 00:53:55.500
that you find a way to test
and run it on an MP system.

00:53:55.500 --> 00:53:58.440
If you're using,
and tend to want to be able

00:53:58.520 --> 00:54:00.500
to take advantage of that,
there's a number of ways through the

00:54:00.500 --> 00:54:03.490
different application environments,
that take advantage of it.

00:54:03.620 --> 00:54:07.440
Certainly the MP APIs for Carbon,
an interesting enough classic,

00:54:07.500 --> 00:54:11.920
as well as NSThread for Cocoa,
and the Pthreads package

00:54:11.990 --> 00:54:13.500
for BSD applications.

00:54:13.500 --> 00:54:16.480
So there's a number of abstractions
that you can use to be able to

00:54:16.500 --> 00:54:18.490
take advantage of multiple threads.

00:54:19.490 --> 00:54:22.290
It's important also to note
kind of how the system itself

00:54:22.290 --> 00:54:24.400
deals with MP on the system.

00:54:24.620 --> 00:54:26.750
Again,
Mach is designed very much from the

00:54:26.750 --> 00:54:31.180
beginning to take advantage of the
multiple processors and to be able

00:54:31.180 --> 00:54:33.400
to deal with things like threads.

00:54:33.400 --> 00:54:37.330
UNIX is not quite as
evolved in the same way.

00:54:37.390 --> 00:54:40.380
From its heritage,
it's actually designed to run more

00:54:40.380 --> 00:54:42.390
on uniprocessor-based systems.

00:54:42.400 --> 00:54:46.330
We've done quite a bit of work to be
able to take advantage of MP on Mac OS X,

00:54:46.520 --> 00:54:49.400
and we'll be doing a lot
more as time progresses.

00:54:49.400 --> 00:54:52.890
But it's important that if you're
actually doing work on Mac OS X that

00:54:52.890 --> 00:54:56.400
you know that the BSD environment
and how it manages itself across

00:54:56.400 --> 00:54:59.400
multiple processors is a key part
of how the system is designed.

00:54:59.400 --> 00:55:03.070
I encourage you to go to the session
later this week where there's more

00:55:03.200 --> 00:55:05.360
discussion on this particular issue.

00:55:05.450 --> 00:55:07.400
Particularly if you're doing
file systems and networking,

00:55:07.400 --> 00:55:11.380
you'll find that there's this concept of
funnels that are involved for managing

00:55:11.380 --> 00:55:12.400
what parts of the system are running.

00:55:12.400 --> 00:55:16.350
system actually are involved
and run on which processors.

00:55:17.640 --> 00:55:19.500
Since we're talking about
things in the kernel,

00:55:19.500 --> 00:55:23.490
there's this concept that I've used a
number of times now of kernel extensions.

00:55:23.650 --> 00:55:29.590
And basically, these are modules of code,
if you will, code fragments that allow,

00:55:29.600 --> 00:55:32.600
if you will,
a plug-in model for the kernel.

00:55:32.600 --> 00:55:36.530
Allows things like drivers and
network kernel extensions and file

00:55:36.530 --> 00:55:42.600
system plug-ins to actually be loaded
and managed as part of Mac OS X.

00:55:42.670 --> 00:55:46.430
Really important thing to note that
a Mac OS X kernel extension is not

00:55:46.430 --> 00:55:48.370
the same as a Mac OS 9 extension.

00:55:48.660 --> 00:55:53.100
We have very explicit usage models for
these particular kinds of extensions.

00:55:53.100 --> 00:55:55.330
If you're doing a driver,
or you need to be able to

00:55:55.330 --> 00:55:58.100
create a new file system,
this is the place that you

00:55:58.100 --> 00:55:59.980
would use a Mac OS X extension.

00:56:00.150 --> 00:56:03.250
Many things that were used,
that were extensions in a

00:56:03.250 --> 00:56:07.100
Mac OS 9 are not appropriate to
be done as a kernel extension.

00:56:07.230 --> 00:56:10.200
You really should only
do them if you have to.

00:56:11.460 --> 00:56:14.610
It basically is the plug-in
model for the kernel.

00:56:14.630 --> 00:56:17.640
And we try and keep the
structure of these things much

00:56:17.730 --> 00:56:21.460
like an application bundle,
in the sense that we have bundles that

00:56:21.460 --> 00:56:25.400
have property lists and the binaries
for the actual thing that gets loaded.

00:56:25.510 --> 00:56:29.890
And there's tools and stuff for loading
and unloading these things in the system.

00:56:30.400 --> 00:56:35.290
As well as some common APIs and
things that are supported for this.

00:56:35.420 --> 00:56:37.570
The other APIs, however,
beyond the basic loading and

00:56:37.630 --> 00:56:41.060
initialize and finalize capabilities,
are all actual APIs that

00:56:41.060 --> 00:56:42.800
are very domain specific.

00:56:42.930 --> 00:56:46.970
That's why I said this is really not a
general mechanism for extending Mac OS X.

00:56:47.150 --> 00:56:49.890
It's really only used for things
like drivers and file system

00:56:49.890 --> 00:56:52.260
plugins and networking services.

00:56:52.300 --> 00:56:55.810
When you're developing inside the kernel,
should you be one of these people

00:56:55.810 --> 00:56:58.760
writing a kernel extension,
it's really important to note

00:56:58.820 --> 00:57:00.290
that the rules change a bit.

00:57:00.300 --> 00:57:03.650
One, you tend to have to deal
with things through a two

00:57:03.650 --> 00:57:07.290
system debugging environment,
two machine debugging.

00:57:07.440 --> 00:57:09.540
The language features that
you have available are much,

00:57:09.540 --> 00:57:10.390
much more limited.

00:57:10.390 --> 00:57:12.890
We don't support
Objective C in the kernel.

00:57:12.980 --> 00:57:17.450
That C++ that exists there is
actually a very strict subset

00:57:17.450 --> 00:57:20.840
of the full C++ standard,
so there are things like multiple

00:57:20.840 --> 00:57:23.910
inheritance and exceptions and
things like that are not the kind

00:57:23.910 --> 00:57:27.950
of thing that we really encourage
or in some cases even support.

00:57:28.060 --> 00:57:30.430
Obviously,
when you're down at the kernel level,

00:57:30.430 --> 00:57:32.460
there is no direct user interaction.

00:57:32.570 --> 00:57:35.190
Some cases you're at interrupt level,
you certainly aren't going to be able

00:57:35.190 --> 00:57:36.530
to talk to the user at that point.

00:57:36.630 --> 00:57:38.690
You don't have access
to things like Aqua.

00:57:38.810 --> 00:57:42.550
There are interesting logging tools
and other things that you can use so

00:57:42.550 --> 00:57:46.330
that you can get information to you
while you're writing your applications,

00:57:46.330 --> 00:57:49.420
but it's definitely not a
user interaction solution.

00:57:49.500 --> 00:57:53.700
Resources in the kernel are
considerably more costly here.

00:57:53.810 --> 00:57:56.660
When you're dealing with an application,
if it allocates memory,

00:57:56.920 --> 00:57:59.400
even if you run out of the
available physical memory,

00:57:59.460 --> 00:58:02.360
the OS itself will, you know,
through VM and through backing storage,

00:58:02.360 --> 00:58:05.710
will do its best to try and
support your application.

00:58:05.840 --> 00:58:07.850
If you're in the kernel
and you use lots of memory,

00:58:07.850 --> 00:58:11.370
you're stealing away actual physical
RAM from the rest of the system,

00:58:11.370 --> 00:58:12.710
and it's very expensive.

00:58:12.850 --> 00:58:14.480
So if you're writing in
this particular space,

00:58:14.580 --> 00:58:18.260
you should always use the least
amount that you possibly can.

00:58:18.410 --> 00:58:20.740
Failures in the kernel are fatal.

00:58:20.800 --> 00:58:23.400
Obviously,
one of the reasons we want to discourage

00:58:23.400 --> 00:58:27.420
development of things like kernel
extensions is this is one area where you

00:58:27.430 --> 00:58:29.460
can introduce instability in the system.

00:58:29.530 --> 00:58:32.260
If you have a driver that goes wild,
you can just as easily crash it.

00:58:32.270 --> 00:58:35.480
You can crash the system that
way as you can under Mac OS 9.

00:58:35.500 --> 00:58:38.170
So that's why there are very
explicit cases where we support

00:58:38.310 --> 00:58:41.800
extension of the kernel,
but we discourage all other types

00:58:41.860 --> 00:58:44.290
of extensions from this level.

00:58:44.700 --> 00:58:49.060
Moving on to the open
source aspect of Darwin,

00:58:49.240 --> 00:58:52.910
I think it's important to note again that
virtually all of the components that are

00:58:52.910 --> 00:58:55.600
available in the Core OS are open source.

00:58:55.600 --> 00:58:59.450
A couple of very rare exceptions,
things like some of the drivers that

00:58:59.450 --> 00:59:02.570
are licensed from third parties,
things like that.

00:59:02.600 --> 00:59:07.060
And that we actually very actively
are involved in actually feeding

00:59:07.180 --> 00:59:09.600
code back to our upstream providers.

00:59:09.600 --> 00:59:11.520
So it's not a,
we've just taken code from the

00:59:11.520 --> 00:59:14.600
community and have integrated it
in and are just running with it.

00:59:14.600 --> 00:59:18.990
We actually work for things like
BSD and Apache and other things that

00:59:18.990 --> 00:59:22.090
if we find bug fixes or other things,
that we actually feed those

00:59:22.090 --> 00:59:25.250
fixes back to the BSD community,
their Apache community,

00:59:25.340 --> 00:59:26.600
or other providers.

00:59:26.600 --> 00:59:31.180
We are actually very actively trying
to make sure that there's a community

00:59:31.180 --> 00:59:33.480
involvement here in open source.

00:59:33.600 --> 00:59:35.370
Excuse me.

00:59:35.590 --> 00:59:38.740
And that's important that this
community is very cooperative.

00:59:38.740 --> 00:59:41.820
For example,
things like security fixes that come in.

00:59:41.870 --> 00:59:44.920
Some of the patches that were part
of some recent software updates

00:59:45.040 --> 00:59:48.380
were actually fixes that came in
from the external community that we

00:59:48.380 --> 00:59:50.190
rolled into these software updates.

00:59:50.210 --> 00:59:52.880
Or even platform fixes.

00:59:52.880 --> 00:59:57.070
We ended up getting from one
of the bug reports that was

00:59:57.070 --> 01:00:01.460
submitted to our support group,
actually included a bug fix right

01:00:01.460 --> 01:00:04.600
in as part of the submission.

01:00:04.650 --> 01:00:07.680
So it's really important to note
from a perspective of open source,

01:00:07.680 --> 01:00:09.860
this is something we take very seriously.

01:00:09.860 --> 01:00:11.260
It's not an experiment.

01:00:11.260 --> 01:00:14.960
It's very much a part of how
we do business in the Core OS.

01:00:14.960 --> 01:00:19.680
And that our developers are involved
in the mailing list in the community to

01:00:19.680 --> 01:00:24.220
actively make this a two-way process.

01:00:24.460 --> 01:00:29.610
And that you as developers can
actively participate in this process.

01:00:29.940 --> 01:00:33.200
It's important to note again that our
repositories and things like that,

01:00:33.200 --> 01:00:35.800
actually many of them are
outside Apple's firewall.

01:00:35.800 --> 01:00:38.130
That we actually have people
outside of Apple that do not,

01:00:38.130 --> 01:00:39.960
are not under our payroll,
don't work for us,

01:00:39.960 --> 01:00:42.820
who actually have commit
access to these repositories.

01:00:43.090 --> 01:00:48.290
That people can actually be involved
in the process of developing and

01:00:48.290 --> 01:00:51.080
involving the Darwin codebase.

01:00:51.600 --> 01:00:56.040
There's a couple of sessions
later this week that I encourage

01:00:56.040 --> 01:00:58.040
you to participate in.

01:00:58.040 --> 01:01:00.600
One is the Open Source at
Apple on Wednesday,

01:01:00.600 --> 01:01:04.210
talking a little bit more about
Darwin from an open source perspective

01:01:04.290 --> 01:01:07.320
and other open source projects,
as well as a Birds of a Feather

01:01:07.330 --> 01:01:09.260
session tomorrow evening.

01:01:10.150 --> 01:01:11.730
And finally,
I'd like to give you a handful

01:01:11.730 --> 01:01:14.300
of things to think about as
you kind of go from this point,

01:01:14.300 --> 01:01:16.100
hopefully off to all
these other sessions.

01:01:16.600 --> 01:01:19.050
One is that,

01:01:19.260 --> 01:01:21.560
You know, it's our intention,
even though we have all

01:01:21.560 --> 01:01:24.820
this power under the hood,
that the user experience of UNIX is

01:01:24.830 --> 01:01:27.190
something that we really want to hide.

01:01:27.290 --> 01:01:31.190
The goal is not to make Emacs
the ideal user interface.

01:01:31.200 --> 01:01:35.680
From our perspective,
this is really an optional environment

01:01:35.690 --> 01:01:38.200
for power users and developers.

01:01:38.200 --> 01:01:41.200
This should not be the
typical behavior of Mac OS X.

01:01:41.200 --> 01:01:44.060
But this is something that you as
developers should take advantage of.

01:01:44.290 --> 01:01:47.310
But always keep in mind,
and I'll give you some examples

01:01:47.310 --> 01:01:49.200
of how we've actually evolved
the system in this way,

01:01:49.200 --> 01:01:53.040
is that the concept of root under
Mac OS X is something that we've

01:01:53.040 --> 01:01:55.080
really tried to move away from.

01:01:55.200 --> 01:01:59.270
It's possible to actually set up your
system so that you have a root user,

01:01:59.330 --> 01:02:01.030
but you have to go to some work,
and you have to really know

01:02:01.100 --> 01:02:02.200
what you're doing in advance.

01:02:02.200 --> 01:02:06.420
But this is part of the model that
we've tried to apply as Mac OS X,

01:02:06.420 --> 01:02:11.200
is how to provide as much power as a
UNIX-based environment can possibly have,

01:02:11.420 --> 01:02:13.200
without having to create
end users that are heavy.

01:02:14.200 --> 01:02:17.560
to be knowledgeable UNIX administrators.

01:02:18.220 --> 01:02:20.600
Be careful that you
don't repeat bad habits.

01:02:20.600 --> 01:02:24.550
Under Mac OS X,
there's a lot of different

01:02:24.590 --> 01:02:26.720
ways to approach things,
and you can probably solve

01:02:26.720 --> 01:02:30.100
virtually any problem you have
with the mechanisms that are there,

01:02:30.170 --> 01:02:31.670
but think about them before you do it.

01:02:31.820 --> 01:02:34.560
Don't just jump into the only
way you can solve a problem

01:02:34.560 --> 01:02:37.720
is by using shared memory,
because you end up recreating the

01:02:37.780 --> 01:02:41.300
same set of problems of stability
that have existed in the past.

01:02:41.480 --> 01:02:44.300
There are other ways to be able to
communicate between multiple applications

01:02:44.300 --> 01:02:45.650
that are running on the system.

01:02:45.700 --> 01:02:48.000
Shared memory, for example,
should be avoided.

01:02:48.000 --> 01:02:50.920
And it's really important
to look at the system,

01:02:50.920 --> 01:02:55.280
you know, to have a very systems view
when you're writing your apps.

01:02:55.520 --> 01:02:59.220
Tools like what we showed with Top and
FSUsers and stuff allows you to get a

01:02:59.220 --> 01:03:03.280
sense of how your application actually
impacts the rest of the system.

01:03:03.460 --> 01:03:05.630
There's a lot of other threads
and processes and things that

01:03:05.630 --> 01:03:06.800
are running on the computer.

01:03:07.050 --> 01:03:09.850
And in order to be able to make
sure that the system behaves

01:03:09.850 --> 01:03:10.560
well with local applications,
you need to have a system that is able to

01:03:10.560 --> 01:03:10.800
communicate with multiple applications.

01:03:10.800 --> 01:03:12.990
And if you're able to do that,
and you're able to do it well with

01:03:12.990 --> 01:03:15.540
lots of different things occurring,
you need to take a few minutes and

01:03:15.540 --> 01:03:18.300
actually look and to see how your
application affects the system.

01:03:18.620 --> 01:03:21.850
Always use the highest level
of abstraction possible.

01:03:21.940 --> 01:03:25.630
Again, there usually are very
appropriate services to use,

01:03:25.630 --> 01:03:28.300
either the Carbon level or
the Cocoa level or whatever,

01:03:28.400 --> 01:03:32.570
and that you should only get involved
in using BSD services or mock-level

01:03:32.670 --> 01:03:36.070
APIs or services if that's the
only way to solve a given problem.

01:03:36.310 --> 01:03:38.740
Don't just jump right
in and use VM Allocate,

01:03:38.740 --> 01:03:41.520
for example, for doing memory management.

01:03:41.690 --> 01:03:44.450
There usually are a lot of other
things in the abstraction layers

01:03:44.450 --> 01:03:47.940
that exist that are helping to
manage those resources and make sure

01:03:48.330 --> 01:03:51.010
that they are handled appropriately.

01:03:52.140 --> 01:03:55.170
And remember that open source
is an incredibly powerful tool.

01:03:55.340 --> 01:03:58.510
This is something that we're doing
which we think is pretty novel in

01:03:58.510 --> 01:04:04.200
terms of adopting open source in a
very big way as part of the major

01:04:04.200 --> 01:04:06.440
aspect of the product that we sell.

01:04:06.680 --> 01:04:09.390
Again, this is not a little
interesting side project.

01:04:09.610 --> 01:04:13.120
Steve put it very clearly,
we're betting Apple very much

01:04:13.120 --> 01:04:17.030
on the success of Mac OS X,
and open source is a very key part

01:04:17.030 --> 01:04:19.530
of the lower portion of that system.

01:04:28.000 --> 01:04:28.000
Get involved in it,
help participate in it.

01:04:28.000 --> 01:04:28.000
There's a lot of email lists
and ability to actually

01:04:28.000 --> 01:04:28.030
contribute code and other things.

01:04:28.030 --> 01:04:28.030
Help make the system better.

01:04:28.490 --> 01:04:31.060
And also remember that
there's an incredible amount

01:04:31.060 --> 01:04:32.560
of power that exists here.

01:04:32.700 --> 01:04:36.200
One of the big changes between
Mac OS 9 and 10 is this introduction

01:04:36.200 --> 01:04:38.270
of a modern operating system.

01:04:38.430 --> 01:04:40.100
Well,
this is that modern operating system.

01:04:40.100 --> 01:04:43.900
The ability to do threading,
and being able to do lots

01:04:43.900 --> 01:04:47.070
of things in parallel,
and things in the background,

01:04:47.160 --> 01:04:51.040
important leverage UNIX applications,
and multiple application environments.

01:04:51.060 --> 01:04:54.730
And so this is all an incredibly
powerful aspect of Mac OS X,

01:04:54.830 --> 01:04:56.100
and something that you
want to think about,

01:04:56.100 --> 01:04:59.760
because I think it will enable
you to take that next big step.

01:05:02.320 --> 01:05:05.000
And lastly, I want to remind people that
there is a feedback forum.

01:05:05.000 --> 01:05:08.270
We'd love to hear your
comments on Darwin and things,

01:05:08.320 --> 01:05:10.190
ways that you think
we can make it better.

01:05:10.300 --> 01:05:14.040
So I encourage you to come to the,
if you're here at the

01:05:14.040 --> 01:05:18.940
last part of the session,
5 o'clock on Friday, we'll be here.
WEBVTT

00:00:01.120 --> 00:00:02.170
Welcome.

00:00:02.170 --> 00:00:05.640
We're going to have session 136,
Sound and Networking for Games.

00:00:05.640 --> 00:00:07.280
I'd like to welcome you all.

00:00:07.280 --> 00:00:10.390
David Hill and Todd Previt will
be giving this presentation.

00:00:10.420 --> 00:00:12.800
We're going to do a tag
team event right here.

00:00:12.800 --> 00:00:15.870
I think David's going to lead it off
talking about some sound and specific

00:00:15.950 --> 00:00:20.680
sound and games issues and talking about
both core graphics and sound manager.

00:00:20.680 --> 00:00:21.880
Then Todd will follow up.

00:00:21.900 --> 00:00:25.290
We're talking about networking,
talking about all the various networking

00:00:25.310 --> 00:00:28.350
services we have across the OS for games.

00:00:28.360 --> 00:00:32.480
Without further ado,
David Hill for of sound.

00:00:43.720 --> 00:00:49.600
So as Jeff mentioned, Todd and I will be
splitting this session.

00:00:49.640 --> 00:00:53.330
I'm going to start out,
give you kind of a brief overview of the

00:00:53.430 --> 00:00:58.190
APIs that we have available on Mac OS X.

00:00:58.580 --> 00:01:01.980
and cover some of your options,
cover a little bit about how to

00:01:02.150 --> 00:01:05.530
set up and initialize each one.

00:01:06.020 --> 00:01:09.940
Then talk briefly about how to play back,
you know, sound sample,

00:01:09.940 --> 00:01:11.680
that's actually going
to be in core audio,

00:01:11.680 --> 00:01:13.700
and talk about MP3 playback.

00:01:13.710 --> 00:01:18.370
And for that I'll leverage QuickTime to
do the one-page MP3 player.

00:01:19.440 --> 00:01:22.520
Then Todd's going to come up a
little later and talk about a number

00:01:22.530 --> 00:01:25.660
of different networking issues,
BSD sockets, addressing,

00:01:25.710 --> 00:01:28.640
setup and initialization,
and some of the network technologies

00:01:28.640 --> 00:01:31.480
you might want to look into
using for your games on Mac OS X.

00:01:31.480 --> 00:01:36.230
And finally,
finish up with some tips and tricks.

00:01:37.700 --> 00:01:41.130
So as far as the technologies
we're going to cover today,

00:01:41.130 --> 00:01:43.400
as I said, I'm going to start out with
the Carbon Sound Manager,

00:01:43.400 --> 00:01:46.030
tell you a little bit about
what's changed and what hasn't.

00:01:46.040 --> 00:01:49.470
I'm going to talk briefly
about QuickTime and Core Audio,

00:01:49.470 --> 00:01:52.650
and then Todd's going to
be covering Open Transport,

00:01:52.650 --> 00:01:55.790
NetSprocket, OpenPlay,
and some BSD sockets.

00:01:55.880 --> 00:01:57.210
BSD Sockets

00:01:59.540 --> 00:02:02.690
So the Carbon Sound Manager.

00:02:02.710 --> 00:02:07.710
We brought the Sound Manager across
from Mac OS 8 and 9 to help

00:02:07.710 --> 00:02:09.420
make your jobs a lot easier.

00:02:09.420 --> 00:02:13.350
It's callable both from CFM and Mako,
which makes it really nice since

00:02:13.350 --> 00:02:17.890
you can create a CFM app that
uses the Carbon Sound Manager that

00:02:18.250 --> 00:02:20.170
For the most part,
with no real changes at all,

00:02:20.170 --> 00:02:23.280
we'll run on 8 and 9,
and it will also run on Mac OS X.

00:02:25.300 --> 00:02:27.960
It's also accessible
from Carbon and Cocoa.

00:02:27.960 --> 00:02:32.190
So, Cocoa has its own NSSound class,
but if for some reason you already

00:02:32.190 --> 00:02:36.060
have Carbon Sound Manager code or you
need a little bit more control than

00:02:36.060 --> 00:02:38.800
NSSound gives you or what have you,
you can actually call it from Cocoa.

00:02:38.800 --> 00:02:39.680
That works just fine.

00:02:39.680 --> 00:02:42.830
One of the new things we've
added as far as Mac OS X is the

00:02:42.880 --> 00:02:47.400
Carbon Sound Manager actually now
supports variable bitrate decoding.

00:02:47.400 --> 00:02:49.730
That's a big issue for
MP3s and things like that,

00:02:49.730 --> 00:02:53.330
where they start to try to actually vary
the bitrate to improve the compression

00:02:53.330 --> 00:02:54.950
that you get with your sounds.

00:02:57.230 --> 00:03:00.960
However, we have had to remove several
APIs for one reason or another.

00:03:00.960 --> 00:03:05.560
Probably the biggest one that
we've heard people complain about

00:03:05.560 --> 00:03:07.100
is the SoundPlay Double Buffer.

00:03:07.100 --> 00:03:10.760
A number of people were using that
one to do a real easy ping pong back

00:03:10.760 --> 00:03:13.100
and forth between two sound buffers.

00:03:13.100 --> 00:03:17.100
That one is no longer present
in the Carbon Sound Manager.

00:03:17.100 --> 00:03:19.550
In order to help you,
for those of you that

00:03:19.550 --> 00:03:22.840
were using that API,
we've got a very good sample called

00:03:22.840 --> 00:03:26.100
the Carbon SoundPlay Double Buffer.

00:03:26.100 --> 00:03:28.070
I encourage you to check that out.

00:03:28.110 --> 00:03:33.240
It's on the SampleCode website,
developer.apple.com/samplecode,

00:03:33.590 --> 00:03:37.090
probably under the sound section there.

00:03:37.110 --> 00:03:38.090
It's a pretty good sample.

00:03:38.210 --> 00:03:41.090
It explains how to use the
Carbon Sound Manager and

00:03:41.090 --> 00:03:44.580
some other APIs to do pretty
much the same thing that the

00:03:44.580 --> 00:03:47.100
SoundPlay Double Buffer did before.

00:03:48.160 --> 00:03:53.050
We've also removed some
of the disk-based APIs,

00:03:53.070 --> 00:03:56.270
the ones that play directly from
a file and things like that.

00:03:56.280 --> 00:03:59.350
And wavetable synthesis
is no longer there,

00:03:59.350 --> 00:04:00.640
for an example.

00:04:01.880 --> 00:04:05.890
For the really curious among you,
there are some other changes

00:04:05.890 --> 00:04:10.990
under the hood between Mac OS 8
and 9 and Mac OS X that your app

00:04:11.130 --> 00:04:12.540
probably shouldn't care about.

00:04:12.570 --> 00:04:15.730
But I thought I'd mention them for
those of you that are interested.

00:04:15.830 --> 00:04:21.750
On Mac OS 8 and 9, the sound manager was
this big global thing.

00:04:22.210 --> 00:04:24.570
It was actually only
one on the whole system.

00:04:24.570 --> 00:04:27.790
And the hardware model was provided
by the sound manager itself.

00:04:27.790 --> 00:04:31.000
It had to know about all the different
sound hardware on every single machine

00:04:31.000 --> 00:04:35.010
and figure out what machine you were
running on and do the right thing.

00:04:35.020 --> 00:04:37.950
On Mac OS X, however,
the sound manager is per process.

00:04:37.970 --> 00:04:40.710
And in talking to the audio guys,
it shouldn't make any

00:04:40.950 --> 00:04:42.090
difference to your app.

00:04:42.140 --> 00:04:45.380
Pretty much you're either changing, say,
the volume on a sound channel,

00:04:45.390 --> 00:04:48.210
which is local to your app,
or you're changing the global volume,

00:04:48.250 --> 00:04:49.550
which is still global.

00:04:49.550 --> 00:04:51.700
So you shouldn't really
care about that one either.

00:04:52.310 --> 00:04:55.480
Another interesting point is
the hardware model on Mac OS X,

00:04:55.480 --> 00:04:59.180
the Carbon sound manager is actually
a layer on top of core audio.

00:04:59.180 --> 00:05:02.390
So that will introduce a
slight performance hit,

00:05:02.390 --> 00:05:03.190
perhaps.

00:05:03.190 --> 00:05:08.400
But again, your app shouldn't really
care one way or the other.

00:05:10.500 --> 00:05:13.100
So I thought I'd step through just
real briefly for those that haven't

00:05:13.110 --> 00:05:15.400
seen the Carbon Sound Manager,
want to know what it looks like.

00:05:15.480 --> 00:05:17.250
We can step through a little bit of code.

00:05:17.280 --> 00:05:20.160
Really just a few slides here.

00:05:20.160 --> 00:05:25.960
So one important thing you need to have
if you're using the buffer and callback

00:05:26.010 --> 00:05:28.910
scheme is you need a sound callback.

00:05:28.980 --> 00:05:31.340
And I've prototyped it
up there at the top.

00:05:31.340 --> 00:05:34.800
It takes the sound channel
parameter and the sound command.

00:05:35.800 --> 00:05:37.680
And then when you actually
want to create a channel,

00:05:37.680 --> 00:05:39.690
the channel is the thing that
you actually send your sound

00:05:39.690 --> 00:05:42.140
commands to to play your buffers.

00:05:42.200 --> 00:05:45.990
You pass it a pointer to a sound channel,
you pass it,

00:05:45.990 --> 00:05:49.090
in this case we're telling it
we want to send sampled sound,

00:05:49.090 --> 00:05:53.190
we want a stereo channel,
and then we pass in that callback.

00:05:56.330 --> 00:06:00.060
When you get ready to play a sound,
you need to tell the sound manager

00:06:00.060 --> 00:06:02.300
what format that sound is in.

00:06:02.360 --> 00:06:06.300
So in this case,
we're filling out a header structure.

00:06:06.300 --> 00:06:08.300
Then these are just some of
the interesting parameters.

00:06:08.300 --> 00:06:11.300
You have a pointer to the
sound data you're playing,

00:06:11.300 --> 00:06:16.300
how many channels are in that sound data,
the sample rate,

00:06:16.300 --> 00:06:19.230
and we also tell it that this
is an extended sound header,

00:06:19.300 --> 00:06:22.260
which lets you do some additional things.

00:06:22.300 --> 00:06:25.300
You can set the base frequency.

00:06:25.300 --> 00:06:28.300
I think number of frames is an
extended sound manager thing.

00:06:28.300 --> 00:06:31.160
Samples per buffer and sample size.

00:06:31.340 --> 00:06:36.100
So we're playing 16-bit stereo,
44 kilohertz sound in this case.

00:06:38.110 --> 00:06:41.470
So once you've got the channel set
up and you've got the header set up,

00:06:41.480 --> 00:06:45.480
you need to actually send those
commands to the sound channel.

00:06:45.990 --> 00:06:49.660
And the first block of code there,
we set up what's called a buffer command.

00:06:49.660 --> 00:06:52.190
So the buffer command simply
tells the sound manager,

00:06:52.190 --> 00:06:54.740
here's a block of sound data
that I want you to play.

00:06:54.910 --> 00:06:58.840
And we pass the header,
pointed to the header that we've

00:06:58.840 --> 00:07:03.730
just created that describes in
detail the format of the sound.

00:07:03.900 --> 00:07:07.650
And we pass that to the sound
channel with the sound do command.

00:07:08.470 --> 00:07:13.550
The second block of code there,
in order to know when that

00:07:13.880 --> 00:07:17.350
buffer of sound is completed,
so that you can queue up

00:07:17.350 --> 00:07:20.650
the next buffer of sound,
you can pass in a callback command.

00:07:20.660 --> 00:07:23.750
I believe we have a bunch
of samples that do this.

00:07:23.810 --> 00:07:25.550
QuickTime does this
kind of sound playing.

00:07:25.550 --> 00:07:30.020
You pass in a callback command,
the parameters don't really matter,

00:07:30.110 --> 00:07:34.260
and you pass that to the sound channel
through much the same as you did before.

00:07:34.260 --> 00:07:37.390
One interesting thing to note,
and this confused me at first when

00:07:37.390 --> 00:07:41.620
I first started looking at this API,
you're giving it a callback command,

00:07:41.620 --> 00:07:43.960
but you're not telling
it what to callback.

00:07:44.190 --> 00:07:46.260
If you remember,
we actually passed that in

00:07:46.280 --> 00:07:47.790
when we created the channel.

00:07:47.820 --> 00:07:50.830
One sound callback is set per channel.

00:07:50.860 --> 00:07:52.960
It's not per callback command.

00:07:52.960 --> 00:07:57.430
You have to have all your callbacks
on a particular channel go through

00:07:57.430 --> 00:07:59.720
one actual callback function.

00:08:01.410 --> 00:08:03.120
And then once you're
done with the channel,

00:08:03.140 --> 00:08:05.260
after you've sent a number of buffers,
played whatever you want to,

00:08:05.260 --> 00:08:07.760
don't forget to dispose it.

00:08:10.100 --> 00:08:12.380
So moving on to QuickTime.

00:08:12.400 --> 00:08:14.140
I'll put in a little plug
for QuickTime here since

00:08:14.160 --> 00:08:15.640
this is a game session.

00:08:15.790 --> 00:08:19.200
QuickTime is really good for complicated
sound data like MP3s and MIDIs.

00:08:19.200 --> 00:08:21.390
They do all the heavy lifting for you.

00:08:21.420 --> 00:08:23.520
But it's also really good
for still image loading.

00:08:23.540 --> 00:08:28.500
Anybody that saw Jeff's 2D,
high performance 2D OpenGL talk,

00:08:28.560 --> 00:08:31.940
he uses QuickTime to
do the image loading.

00:08:31.940 --> 00:08:34.000
So he doesn't care what format it's in.

00:08:34.030 --> 00:08:37.350
He just says QuickTime,
let me load in this image,

00:08:37.350 --> 00:08:39.980
whatever format, JPEG, BMP,
whatever format.

00:08:40.000 --> 00:08:41.160
PNG, whatever.

00:08:41.160 --> 00:08:43.700
And QuickTime does all that work for him,
puts it into a buffer.

00:08:43.700 --> 00:08:46.440
Then he can hand that directly
to OpenGL as a texture.

00:08:46.440 --> 00:08:47.650
So it's really good for that.

00:08:47.700 --> 00:08:50.520
It's especially a good way to get some
things prototyped and up and running.

00:08:50.520 --> 00:08:52.620
If you want to do your
own graphic format later,

00:08:52.620 --> 00:08:53.180
you can.

00:08:53.180 --> 00:08:57.260
But at least to get you started,
QuickTime is a great way to get started.

00:08:57.260 --> 00:08:58.660
And of course, movie playing.

00:08:58.660 --> 00:09:00.510
Of course, QuickTime is famous for that.

00:09:00.510 --> 00:09:02.460
But I thought I'd throw
it on there anyway.

00:09:04.420 --> 00:09:08.880
So as promised,
here's a one-page MP3 player.

00:09:08.880 --> 00:09:11.300
To get QuickTime started, enter movies.

00:09:11.890 --> 00:09:14.390
And in this case,
we've passed it in a file spec

00:09:14.460 --> 00:09:16.700
of the file we want to play.

00:09:16.700 --> 00:09:19.570
And in my demo code that
I'll show you in a minute,

00:09:19.570 --> 00:09:23.720
we actually just use Nav Services,
get us a file, pass it in here.

00:09:23.720 --> 00:09:27.300
We open the movie file,
say create a movie from the file.

00:09:27.300 --> 00:09:30.650
And that will give us for that refnum
that we get out of open movie file,

00:09:30.650 --> 00:09:32.020
it will give us a movie.

00:09:34.310 --> 00:09:37.200
And then we'll fill out
the movie structure that we

00:09:37.220 --> 00:09:38.980
can pass to the other APIs.

00:09:38.980 --> 00:09:40.260
And then deploy it.

00:09:40.540 --> 00:09:42.370
Really simple.

00:09:42.370 --> 00:09:42.370
We start the movie.

00:09:43.720 --> 00:09:47.840
As long as a movie is not done,
we call MoviesTask.

00:09:47.950 --> 00:09:49.760
Then when we're done,
we dispose the movie,

00:09:49.840 --> 00:09:52.440
close the movie file, and exit movies.

00:09:52.440 --> 00:09:53.200
We're done.

00:09:53.320 --> 00:09:55.280
It's all it takes to play an MP3.

00:09:55.380 --> 00:09:57.900
Really simple stuff.

00:09:57.900 --> 00:10:00.500
I'll prove it.

00:10:00.580 --> 00:10:03.310
We can go to the Demo 2 machine.

00:10:06.560 --> 00:10:11.000
This is a real simple app,
essentially the basic

00:10:11.180 --> 00:10:15.680
Carbon template from Project Builder.

00:10:15.790 --> 00:10:18.750
Threw in pretty much
that code you saw there.

00:10:38.940 --> 00:10:42.270
Now there are some more
in-depth samples on our website

00:10:42.330 --> 00:10:44.020
again for how to play MP3s.

00:10:44.040 --> 00:10:48.900
If you want some more control over
how it's decoded and how it's played,

00:10:48.900 --> 00:10:50.360
check out our sample code site.

00:10:50.360 --> 00:10:53.900
I know there's some that more directly
use the Carbon Sound Manager and

00:10:53.900 --> 00:10:56.490
QuickTime together to play
some more detailed things.

00:10:56.490 --> 00:10:58.350
Let's go back to the slides.

00:10:58.350 --> 00:11:00.490
Thank you.

00:11:03.530 --> 00:11:06.970
Let's talk about the new guy, Core Audio.

00:11:07.030 --> 00:11:09.530
So the number of Core Audio sessions,
I think one has already occurred

00:11:09.530 --> 00:11:10.460
and two more are coming up.

00:11:10.480 --> 00:11:12.180
I'll tell you about them in a little bit.

00:11:12.230 --> 00:11:15.230
But I wanted to go over kind of a
high-level look at Core Audio so

00:11:15.230 --> 00:11:17.230
that you could get a feel for
what it is and whether you should

00:11:17.280 --> 00:11:19.560
be looking at it for your game.

00:11:19.750 --> 00:11:22.940
So Core Audio is a pretty
low-level interface.

00:11:22.940 --> 00:11:26.650
It provides a number of capabilities
built into the architecture.

00:11:26.710 --> 00:11:28.080
Some of these are ready to go now.

00:11:28.080 --> 00:11:29.700
Some of them haven't been exposed yet.

00:11:29.700 --> 00:11:31.700
But for one, audio device sharing.

00:11:31.700 --> 00:11:35.130
Of course, you want to make it easy for
different devices to share,

00:11:35.130 --> 00:11:37.690
different processes to
share the same device.

00:11:37.710 --> 00:11:40.580
If you have, say,
an MP3 player playing and your game

00:11:40.610 --> 00:11:43.740
comes up and wants to be playing audio
and then the system wants to beep to

00:11:43.760 --> 00:11:46.690
tell you something important happens,
everything has to be able to share it.

00:11:46.700 --> 00:11:49.900
In the example code that
I'll show you in a bit,

00:11:49.900 --> 00:11:54.700
we just pretty much ask Core Audio for
the default output device.

00:11:54.700 --> 00:11:57.340
We say,
whatever sound goes to by default,

00:11:57.340 --> 00:11:58.700
that's cool for us.

00:11:58.850 --> 00:12:02.690
There are other calls that you can
use to get more interesting info,

00:12:02.690 --> 00:12:06.220
actually get a list of the
different audio devices available,

00:12:06.220 --> 00:12:07.370
things like that.

00:12:07.690 --> 00:12:10.430
Core Audio also provides some
facilities for real-time audio

00:12:10.540 --> 00:12:12.730
inter-process communication.

00:12:12.760 --> 00:12:15.810
And that would essentially
let multiple processes sort of

00:12:15.820 --> 00:12:17.550
pipe audio data between them.

00:12:17.560 --> 00:12:21.500
So if you had one app that was generating
some audio and you wanted to send it to,

00:12:21.500 --> 00:12:26.080
say, an app that was recording that
in some format or whatever,

00:12:26.080 --> 00:12:29.100
you could actually chain them together.

00:12:29.130 --> 00:12:30.600
And that's on a process basis.

00:12:30.600 --> 00:12:32.660
They also have a lower level,
what they call the audio

00:12:32.660 --> 00:12:35.240
unit and component model,
where you can actually have

00:12:35.240 --> 00:12:39.090
audio processing units and string
them together within your app.

00:12:39.100 --> 00:12:42.190
So you might, in your app,
create a reverb unit and

00:12:42.200 --> 00:12:45.730
some other units together,
chain them together,

00:12:45.730 --> 00:12:48.300
and then start sending audio through it.

00:12:51.810 --> 00:12:54.120
One of the other interesting
things about Qua Audio is it's

00:12:54.120 --> 00:12:55.700
designed with low latency.

00:12:55.700 --> 00:12:59.040
It's supposed to be able to handle
really low latency and also synchronize

00:12:59.040 --> 00:13:03.020
output between different sounds.

00:13:03.460 --> 00:13:07.900
And one interesting note there
is you can actually control,

00:13:07.900 --> 00:13:09.620
for the most part,
the latency in your app.

00:13:09.650 --> 00:13:13.320
Unlike the sound manager,
with core audio you can actually

00:13:13.320 --> 00:13:16.390
set for a given device what
you want the buffer size to be.

00:13:16.400 --> 00:13:19.870
And on 9 there was always a big
problem between VM on and VM off for

00:13:19.920 --> 00:13:23.010
games and the Carbon sound manager,
or actually just the

00:13:23.010 --> 00:13:24.630
regular sound manager.

00:13:24.630 --> 00:13:27.400
With VM on, the system would make
the buffer much bigger.

00:13:27.400 --> 00:13:30.130
And so if you decided to
change what you were playing,

00:13:30.130 --> 00:13:32.790
you'd have to wait for that
buffer to complete before

00:13:32.800 --> 00:13:34.210
the next buffer got going.

00:13:34.380 --> 00:13:38.400
On core audio, on Mac OS X,
that's not a problem.

00:13:38.400 --> 00:13:41.400
You can set the buffer as
big or as small as you want.

00:13:41.400 --> 00:13:46.530
Now one gotcha with core audio is that
core audio uses floating point samples.

00:13:47.820 --> 00:13:50.360
Now that does greatly simplify
your application code,

00:13:50.400 --> 00:13:52.410
especially in the demo I'll
show you where we're generating

00:13:52.420 --> 00:13:53.700
tones and things like that.

00:13:53.860 --> 00:13:56.930
It's really easy to generate,
but it does make the drivers work

00:13:56.930 --> 00:13:59.700
a little bit harder because the
existing hardware we have right now

00:13:59.700 --> 00:14:02.740
sends integer data to the cards.

00:14:02.820 --> 00:14:06.880
Also, if you're coming from, say,
a conversion where you have wave

00:14:06.880 --> 00:14:10.310
sounds and some things like that
coming from Windows or some other

00:14:10.310 --> 00:14:13.810
platform that are 8 or 16 bit integers,

00:14:13.990 --> 00:14:18.070
You're probably going to have to
convert your samples on the fly,

00:14:18.070 --> 00:14:21.450
or you can pre-convert them
and store them on disk.

00:14:21.700 --> 00:14:41.200
[Transcript missing]

00:14:44.420 --> 00:14:49.250
So, in the Carbon Sound Manager,
you got sound samples into

00:14:49.250 --> 00:14:53.000
the system using the buffer
commands and the callbacks.

00:14:53.000 --> 00:14:56.840
That was your basic mechanism for
getting sound into that system.

00:14:56.940 --> 00:14:58.950
With Core Audio,

00:14:59.300 --> 00:15:01.960
You deal with these
things called I/O procs.

00:15:01.960 --> 00:15:06.040
And so for a given device,
you can install one or more

00:15:07.800 --> 00:15:09.130
Ioprox.

00:15:09.130 --> 00:15:15.340
And your Ioprox, when they get called,
get a number of very

00:15:15.340 --> 00:15:16.760
interesting parameters.

00:15:16.760 --> 00:15:19.390
They get a number of timestamps.

00:15:19.390 --> 00:15:21.870
As I mentioned,
Core Audio was designed so that you

00:15:21.870 --> 00:15:23.840
could actually synchronize audio.

00:15:23.840 --> 00:15:25.840
Well,
if you're going to synchronize audio,

00:15:25.840 --> 00:15:28.250
you need to know a lot of stuff,
like what time is it now,

00:15:28.250 --> 00:15:31.420
as far as the sound system is concerned,
and when are you going to play this

00:15:31.530 --> 00:15:33.630
sound that I'm getting ready to hand you.

00:15:33.630 --> 00:15:34.800
You've asked me to fill this buffer.

00:15:34.890 --> 00:15:36.570
When's that buffer actually
going to get played?

00:15:36.590 --> 00:15:37.610
So you get that information.

00:15:37.700 --> 00:15:41.080
You'll get some input buffers back.

00:15:41.080 --> 00:15:43.700
As the name implies,
it's both input and output, Brock.

00:15:43.700 --> 00:15:46.270
So you get some input buffers
if the device is actually

00:15:46.280 --> 00:15:47.630
needing to send you data.

00:15:47.840 --> 00:15:49.140
That's where that will come in.

00:15:49.140 --> 00:15:53.850
And then there's a chunk of
output buffers that you can

00:15:53.930 --> 00:15:59.210
use to put your samples in and
send the data out to the card.

00:15:59.490 --> 00:16:02.400
That last bullet there,
if you need to know

00:16:02.510 --> 00:16:06.360
what the stream is like,
you need to know how many channels or

00:16:06.510 --> 00:16:10.150
sample rate and those kinds of things,
you can actually make a call to get the

00:16:10.160 --> 00:16:13.160
KAudioDevicePropertyStream configuration.

00:16:13.260 --> 00:16:15.800
Yet another API with really long names.

00:16:15.800 --> 00:16:18.570
You can make this call and it will
fill out a structure for you that will

00:16:18.600 --> 00:16:22.060
give you very detailed information
about what this I/O proc is going

00:16:22.130 --> 00:16:24.480
to get and what the stream is like.

00:16:26.740 --> 00:16:28.060
Now for the people that
are really curious,

00:16:28.110 --> 00:16:32.490
we can go into how the actual
audio gets to the device.

00:16:32.610 --> 00:16:37.660
For each device on the system,
there's one real-time Mach thread

00:16:37.700 --> 00:16:39.810
that's pretty high priority.

00:16:39.810 --> 00:16:43.970
And it takes care of actually calling
all the IOPROCs when the system

00:16:43.970 --> 00:16:46.380
needs to move stuff back and forth.

00:16:46.380 --> 00:16:49.330
And essentially that device
starts that thread up with

00:16:49.330 --> 00:16:51.420
the first IOPROC you install.

00:16:51.420 --> 00:16:53.770
As soon as you activate the
device with the first IOPROC,

00:16:53.770 --> 00:16:57.080
the device is up and this thread's
running and calling your IOPROC.

00:16:57.100 --> 00:17:02.170
And the thread stays running until you
actually remove your last IOPROC and

00:17:02.170 --> 00:17:04.450
then it shuts back down again.

00:17:05.830 --> 00:17:08.000
So let's look a little bit at
what that thread looks like.

00:17:08.000 --> 00:17:10.350
This is some real high-level pseudo code.

00:17:10.500 --> 00:17:13.490
Essentially it loops until it's done.

00:17:13.590 --> 00:17:15.830
It sleeps until it has something to do.

00:17:15.840 --> 00:17:18.360
It can tell when the next input
or output needs to happen.

00:17:18.450 --> 00:17:19.570
It sleeps until then.

00:17:19.570 --> 00:17:23.360
Then it looks to see if the device
has input coming back into the system.

00:17:23.360 --> 00:17:26.230
If it does,
it will calculate exactly when that

00:17:26.230 --> 00:17:29.560
input was sampled and then copy
that data into the input buffers to

00:17:29.600 --> 00:17:32.350
get ready to hand to the I/O procs.

00:17:34.000 --> 00:17:35.900
Then it says, okay,
does the device have output?

00:17:35.980 --> 00:17:38.310
Has somebody installed an
I/O proc to send data out?

00:17:38.470 --> 00:17:40.740
Okay, well,
let's calculate when that output

00:17:40.740 --> 00:17:42.980
is actually going to be sent.

00:17:43.210 --> 00:17:46.340
Clear out the output buffers to
prepare for calling the I/O procs.

00:17:46.340 --> 00:17:49.290
And then call all the I/O procs
that are installed for this device.

00:17:49.320 --> 00:17:51.820
As I mentioned,
a particular process can install

00:17:51.820 --> 00:17:55.130
more than one and you can have
multiple processes sharing a device,

00:17:55.130 --> 00:17:58.650
so there might be a number of
I/O procs actually installed here.

00:18:01.170 --> 00:18:04.220
Once it's called all the I/O procs,
you've got, say,

00:18:04.220 --> 00:18:07.330
a handful of I/O procs that
have filled out their buffers.

00:18:07.440 --> 00:18:09.730
Somebody's got to mix them to send
them out to the output stream.

00:18:09.740 --> 00:18:12.010
That's when Core Audio comes
along and actually mixes all

00:18:12.010 --> 00:18:14.760
those I/O proc buffers together.

00:18:14.820 --> 00:18:17.440
And then it sends it out to
the card and loops back around.

00:18:17.440 --> 00:18:20.890
So it spends its entire lifetime
just gathering the input,

00:18:21.000 --> 00:18:23.740
clearing the buffers,
getting the-- out and calling I/O procs

00:18:23.740 --> 00:18:25.540
and then sending the data out.

00:18:28.320 --> 00:18:29.660
Let's look at some code.

00:18:29.830 --> 00:18:31.440
This is the basic idea.

00:18:31.440 --> 00:18:34.270
If you're a Carbon CFM app,

00:18:34.920 --> 00:18:36.430
You've got to load
Core Audio by CFBundle.

00:18:36.430 --> 00:18:38.680
Core Audio is not available from CFM.

00:18:38.680 --> 00:18:43.560
So there's some good sample code
on the web at our sample code site,

00:18:43.560 --> 00:18:45.800
and actually in the
CarbonLib SDK as well,

00:18:45.800 --> 00:18:49.540
about how to call CFM,
or how to call Mako routines from CFM.

00:18:49.560 --> 00:18:52.980
Once you've got access
to the Core Audio system,

00:18:52.980 --> 00:18:55.680
you can make some calls to
gather device information.

00:18:55.700 --> 00:18:58.690
You can set up the device
properties the way you want them,

00:18:58.690 --> 00:19:00.660
make sure the buffer size
is correct and everything.

00:19:00.660 --> 00:19:04.520
You add in your IOD proc,
and then you start the device.

00:19:04.800 --> 00:19:07.250
And as soon as you start the device,
it starts calling your

00:19:07.250 --> 00:19:08.910
I/O proc asking for data.

00:19:10.910 --> 00:19:14.880
So a brief diversion
into the bundle APIs.

00:19:14.880 --> 00:19:17.320
If you have a URL, say,
to the Core Audio Bundle,

00:19:17.330 --> 00:19:22.350
and this applies to any framework bundle,
you can get a reference for the

00:19:22.380 --> 00:19:24.680
bundle using CFBundleCreate.

00:19:25.220 --> 00:19:29.210
You load the executable for that
bundle to make sure it's in memory.

00:19:29.290 --> 00:19:32.260
Then you can get a function pointer for,
in this case,

00:19:32.260 --> 00:19:36.060
some non-existent CA func name
is the name of the function.

00:19:36.060 --> 00:19:44.610
You get a function pointer for that
using CFBundleGetFunctionPointerForName.

00:19:44.610 --> 00:19:44.610
Hard to miss what that does.

00:19:45.420 --> 00:19:48.300
Once you've got access to that API,
then you need to start calling them.

00:19:48.320 --> 00:19:51.300
So you can call audio
hardware get property.

00:19:51.300 --> 00:19:55.290
And in this case, we're asking it for the
default output device.

00:19:55.370 --> 00:19:58.380
Core Audio guys recommend you actually
use the default output device,

00:19:58.380 --> 00:20:00.300
unless you have a specific reason not to.

00:20:00.360 --> 00:20:02.630
If you want to actually look
at the APIs and query for the

00:20:02.660 --> 00:20:04.300
different output devices you can.

00:20:04.300 --> 00:20:07.380
But this one will be a real
easy way to just tell you,

00:20:07.420 --> 00:20:11.020
"Okay, what's the basic output device
that I need to use?" This will

00:20:11.020 --> 00:20:13.390
give you an output device ID.

00:20:13.750 --> 00:20:16.660
From there you can get and
set some properties on it.

00:20:16.690 --> 00:20:18.330
As I mentioned before,
you could get the configuration

00:20:18.330 --> 00:20:19.280
for the stream and things.

00:20:19.350 --> 00:20:23.180
In this case, all we need to do is,
we just want to say we need k samples

00:20:23.240 --> 00:20:28.280
per buffer and each sample is a float,
so we set that buffer size in there.

00:20:28.280 --> 00:20:31.770
I don't even remember
what I used in my code.

00:20:32.660 --> 00:20:35.300
Then we have to install our I/O proc.

00:20:35.340 --> 00:20:41.810
And the I/O proc is actually
mostly input parameters.

00:20:42.300 --> 00:20:44.800
The top two-thirds there
is the parameter list.

00:20:44.800 --> 00:20:46.740
And as you can see, you get a device ID.

00:20:46.790 --> 00:20:50.320
So you can actually have the same
proc installed on multiple devices.

00:20:50.340 --> 00:20:53.530
So this will tell you which device
is actually asking for data.

00:20:53.540 --> 00:20:56.380
You get the timestamp from
the audio system to say,

00:20:56.500 --> 00:20:58.610
here's what time it is now.

00:20:58.820 --> 00:21:03.750
The input data and the input timestamp
when that data was actually sampled.

00:21:03.970 --> 00:21:05.880
Then you have the ones that I've
highlighted there that are more

00:21:05.880 --> 00:21:07.260
interesting for our discussion.

00:21:07.260 --> 00:21:09.520
The output data,
the time when that data is

00:21:09.550 --> 00:21:12.500
actually going to be played,
and some client data that

00:21:12.590 --> 00:21:15.190
you can actually pass in when
you install the I/O proc.

00:21:15.300 --> 00:21:18.090
And then down there at the
bottom I put just a real simple,

00:21:18.150 --> 00:21:20.410
you know, for each sample frame,
you know,

00:21:20.410 --> 00:21:22.650
the frame being left and right stereo,
whatever.

00:21:22.710 --> 00:21:26.450
For each sample frame, for each channel,
either the left channel

00:21:26.450 --> 00:21:30.200
or the right channel,
fill in that output data buffer there.

00:21:32.320 --> 00:21:36.200
Once you've got your I/O proc installed,
all you have to do is start the device.

00:21:36.200 --> 00:21:39.200
So you say start the
device with that I/O proc.

00:21:39.200 --> 00:21:43.480
A caveat here, as soon as you call this,
it's going to start

00:21:43.480 --> 00:21:45.200
calling your I/O proc.

00:21:45.200 --> 00:21:47.680
So beware,
make sure that you don't do this and then

00:21:47.740 --> 00:21:51.200
expect to be able to set up a few more
structures or whatever for the I/O proc.

00:21:51.200 --> 00:21:54.590
It's already going to call you,
so be ready for it.

00:21:56.120 --> 00:22:01.090
So let's take a look
at a simple demo here.

00:22:01.120 --> 00:22:06.000
And my colleagues have voted this
the most annoying demo at WWDC.

00:22:06.000 --> 00:22:11.060
So we'll show you the simple tone demo.

00:22:11.060 --> 00:22:15.000
Let's make that a little softer.

00:22:15.000 --> 00:22:15.000
So here we have...

00:22:17.600 --> 00:22:23.100
So this is a simple Cocoa app
that I wired up in...

00:22:23.300 --> 00:22:25.300
Not too long, big plug for Cocoa here.

00:22:25.300 --> 00:22:26.340
Really easy stuff to play with.

00:22:26.340 --> 00:22:30.330
Good for prototyping

00:23:04.300 --> 00:23:11.640
This one we can play a little bit
more with some other things you

00:23:11.640 --> 00:23:13.890
learned in music theory class.

00:23:55.100 --> 00:23:57.700
Simply generating the
waveform on the fly,

00:23:57.700 --> 00:24:02.660
some simple sine waves, square waves,
sawtooth.

00:24:02.660 --> 00:24:05.120
Really easy stuff.

00:24:05.120 --> 00:24:07.000
We'll be posting the sample
code in the next week,

00:24:07.000 --> 00:24:14.940
probably, so you can take a good look
at how to use core audio,

00:24:14.940 --> 00:24:18.810
get some real simple stuff going,
and annoy your neighbor.

00:24:18.820 --> 00:24:21.340
Especially for those of
you that work in cubes.

00:24:26.240 --> 00:24:28.620
I was actually working on that
app a little bit during Jeff's

00:24:28.620 --> 00:24:32.910
OpenGL early bird session,

00:24:35.300 --> 00:24:37.300
Okay.

00:24:37.370 --> 00:24:40.060
So to wrap this up, real quick,
high level, you know,

00:24:40.060 --> 00:24:41.600
we've talked about several
different interfaces.

00:24:41.600 --> 00:24:45.210
Core Audio and Sound Manager are
great if you've got raw sound samples

00:24:45.210 --> 00:24:48.390
that you just want to throw out,
get out to the card, play them.

00:24:48.400 --> 00:24:51.890
If you've got something more
complicated like MIDI or MP3,

00:24:51.890 --> 00:24:55.340
QuickTime is a really easy way
to get that up and running.

00:24:55.340 --> 00:24:56.340
Take a look at the API.

00:24:56.340 --> 00:24:57.360
It's really simple.

00:24:57.360 --> 00:24:59.430
If you want to do the heavy lifting,
you can,

00:24:59.430 --> 00:25:03.120
but QuickTime already has done an awful
lot of work to get that nice and neat.

00:25:03.120 --> 00:25:04.920
So you might want to take a
look at the QuickTime API.

00:25:07.000 --> 00:25:11.850
And coming up, actually, luckily,
there's still two audio sessions

00:25:11.930 --> 00:25:14.500
coming up in this very room at 3.30.

00:25:14.500 --> 00:25:17.470
We've got the audio processing
and sequencing services.

00:25:17.480 --> 00:25:21.100
And then for those of you that are more
interested in some of the more powerful

00:25:21.150 --> 00:25:24.520
MIDI services that Mac OS X provides,
at 5 o'clock in this room,

00:25:24.520 --> 00:25:26.500
we've got 2.10 MIDI on Mac OS X.

00:25:26.500 --> 00:25:30.970
And then since this is a game session,
if you have games feedback for us,

00:25:30.980 --> 00:25:33.420
if we're doing something well,
if we're not doing something well,

00:25:33.420 --> 00:25:35.820
if there's something you'd
like to see more of or less of,

00:25:35.820 --> 00:25:39.040
what have you,
please come to the feedback forum in J1,

00:25:39.040 --> 00:25:41.770
which is next door,
and give us our games feedback

00:25:41.770 --> 00:25:43.160
on games technologies.

00:25:46.090 --> 00:25:47.800
And that's it for my part.

00:25:47.840 --> 00:25:48.980
Now I'll turn it over to Todd.

00:25:48.980 --> 00:25:50.980
Where did Todd go?

00:25:50.980 --> 00:25:52.970
There he is.

00:25:55.700 --> 00:25:57.170
Thank you.

00:25:57.170 --> 00:26:02.220
He wasn't kidding about those demos,
was he?

00:26:04.140 --> 00:26:05.100
Hi, my name's Todd Previt.

00:26:05.100 --> 00:26:09.980
I'm the 3D graphics and de
facto networking DTS engineer.

00:26:12.310 --> 00:26:16.630
So I'm going to recap one of the things
that one of David's slides went over,

00:26:16.630 --> 00:26:19.430
which is what we're going to
learn about networking today.

00:26:19.650 --> 00:26:23.330
I'm going to go through
BSD sockets in the most detail,

00:26:23.410 --> 00:26:29.750
including accessing it from both
CFM and Carbon and from Cocoa.

00:26:29.820 --> 00:26:33.600
Then I'm going to go through some
simple setup and initialization code.

00:26:33.600 --> 00:26:36.530
I'm also going to discuss some
of the networking technologies

00:26:36.600 --> 00:26:40.180
that are available on 10 that
are better suited to gaming as

00:26:40.180 --> 00:26:44.300
opposed to things like URL access,
which is more designed for

00:26:44.300 --> 00:26:46.280
mainstream applications.

00:26:46.350 --> 00:26:49.500
I'm going to go through some tips
and tricks for network gaming.

00:26:49.710 --> 00:26:51.500
It's kind of a misnomer.

00:26:51.500 --> 00:26:56.150
It's more like a porting guide,
kind of give you some idea

00:26:56.150 --> 00:26:58.770
of how things map over to 10.

00:27:01.960 --> 00:27:03.210
So what do we have for networking on 10?

00:27:03.210 --> 00:27:07.840
Well, first of all,
there's Carbon Open Transport.

00:27:07.840 --> 00:27:10.870
As that name would imply,
Open Transport has been

00:27:10.980 --> 00:27:12.280
carbonized for OS X.

00:27:12.430 --> 00:27:16.020
It's all there,
all the functionality that you need.

00:27:16.020 --> 00:27:18.060
And that is one of the
options you can use.

00:27:18.060 --> 00:27:21.870
NetSprocket Open Play,
we've gotten a lot of questions

00:27:21.870 --> 00:27:24.140
about this very recently.

00:27:24.140 --> 00:27:29.780
And NetSprocket and Open Play are
now also available on Mac OS X.

00:27:29.860 --> 00:27:32.010
And of course, there's Sockets,
which which is available

00:27:32.020 --> 00:27:33.190
in the BSD layer.

00:27:35.500 --> 00:27:40.980
So OpenTransport's available on 10 mainly
as an easy path for existing applications

00:27:40.980 --> 00:27:43.250
to move over to Mac OS X from OS 8 and 9.

00:27:43.260 --> 00:27:46.030
Again, as I said,
all of the functionality

00:27:46.190 --> 00:27:49.230
of OS 9 is there,
so you don't have to worry about, well,

00:27:49.320 --> 00:27:50.620
what are the differences?

00:27:50.620 --> 00:27:53.300
The whole thing has been taken and
just pulled right over directly.

00:27:54.710 --> 00:27:58.700
The OpenTransport frameworks are
all built on top of sockets now,

00:27:58.700 --> 00:28:02.130
as opposed to whichever
underlying layer they used on 9.

00:28:02.170 --> 00:28:05.260
I don't know offhand.

00:28:05.450 --> 00:28:08.540
This has been included for
API compatibility only.

00:28:08.670 --> 00:28:14.180
There's no additional functionality that
you get from OpenTransport on Mac OS X.

00:28:15.970 --> 00:28:21.390
Open Transport uses threads to
emulate any of the asynchronous mode

00:28:21.390 --> 00:28:22.950
stuff that was available on OS 9.

00:28:22.960 --> 00:28:29.240
You do incur about a 10% performance
hit for using Open Transport as

00:28:29.240 --> 00:28:30.900
opposed to using sockets directly.

00:28:30.900 --> 00:28:34.980
And the protocol subset that is
supported by Open Transport on 10

00:28:34.980 --> 00:28:40.180
is much smaller than it was on 9,
supporting only TCP IP, DDP, ZIP,

00:28:40.180 --> 00:28:42.440
and NBP for Apple Talk.

00:28:46.540 --> 00:28:51.470
OpenPlay Netsproket is a derivative,
well, not a derivative,

00:28:51.470 --> 00:28:55.080
but it's the evolution of
Netsproket from traditional Mac OS.

00:28:55.100 --> 00:28:59.770
Apple open sourced it some time back,
and since then it's kind of

00:28:59.830 --> 00:29:02.950
developed into two different areas,
that being OpenPlay and

00:29:02.950 --> 00:29:03.860
Netsproket itself.

00:29:03.880 --> 00:29:05.560
They are both open source APIs.

00:29:05.560 --> 00:29:09.860
They are now cross-platform,
available Mac and Windows.

00:29:09.860 --> 00:29:13.010
I believe there was a Linux Unix
version that was supposed to be coming,

00:29:13.080 --> 00:29:15.280
but I couldn't find much
information on that.

00:29:16.400 --> 00:29:19.800
And it also has been
carbonized from Mac OS X.

00:29:21.150 --> 00:29:24.180
So with Netsprocket,
what they did was they made it the

00:29:24.180 --> 00:29:29.110
high-level interface that is now,
instead of built on top of OpenTransport,

00:29:29.110 --> 00:29:31.160
I believe is what Netsprocket
used to be based on,

00:29:31.160 --> 00:29:34.140
it now sits on top of their own API,
which is OpenPlay,

00:29:34.290 --> 00:29:36.650
which I'll discuss in just a few minutes.

00:29:36.870 --> 00:29:40.470
It does maintain most of the
API compatibility with NetSprocket,

00:29:40.470 --> 00:29:44.670
although as I understand there are
some differences between the two.

00:29:45.340 --> 00:29:48.400
No new documentation is
available for NetSprocket,

00:29:48.550 --> 00:29:53.540
but you can still use the 173, I believe,
is the current version of NetSprocket

00:29:53.540 --> 00:29:55.020
documentation that is available.

00:29:55.020 --> 00:29:57.990
That is still the most current.

00:30:00.500 --> 00:30:02.070
So what exactly is OpenPlay?

00:30:02.150 --> 00:30:08.230
OpenPlay is the low-level interface
that they've developed for use

00:30:08.300 --> 00:30:10.800
on both Windows and Macintosh.

00:30:10.800 --> 00:30:23.370
It's sort of akin to sockets in
that it doesn't have a lot of...

00:30:26.470 --> 00:30:29.360
One of these days I'll think of the words
that I'm trying to come up with here.

00:30:29.390 --> 00:30:34.080
It's fairly streamlined, fairly simple,
and there's just not a lot

00:30:34.080 --> 00:30:39.060
to it as far as being overly
friendly with a user interface.

00:30:39.060 --> 00:30:44.190
They left most of that
functionality up to Netsprocket.

00:30:45.520 --> 00:30:49.020
It's been called a
network module manager.

00:30:49.130 --> 00:30:53.200
So what exactly is a
network module manager?

00:30:53.410 --> 00:30:54.780
It's a protocol manager.

00:30:54.780 --> 00:30:59.880
You tell it which protocols you want to
use and what you want to do with them.

00:30:59.880 --> 00:31:01.940
It sets them up and then you can
access them either directly through

00:31:01.940 --> 00:31:06.180
the open play calls or you can go
through the high level NetSprocket

00:31:06.180 --> 00:31:09.420
interface and access them that way.

00:31:12.680 --> 00:31:15.900
provides three basic services,
which is configuration, data transfer,

00:31:15.980 --> 00:31:17.810
and enumeration.

00:31:18.560 --> 00:31:22.100
Now, in the documentation it says it
also provides human interface

00:31:22.450 --> 00:31:25.980
and miscellaneous functions,
but neither one of those I could

00:31:25.980 --> 00:31:27.410
find a whole lot of information on.

00:31:27.580 --> 00:31:31.480
I think the user--the human interface
they're referring to was Netsprocket,

00:31:31.620 --> 00:31:34.620
but again,
couldn't find much out on that.

00:31:34.920 --> 00:31:40.300
Configuration-wise, just as I said,
it'll set up the protocol stacks for you.

00:31:40.300 --> 00:31:43.380
You can do all your initialization
right through Open Play,

00:31:43.380 --> 00:31:44.660
just as you can through sockets.

00:31:44.660 --> 00:31:47.190
Data transfer,
it's what communicates with the drivers,

00:31:47.190 --> 00:31:49.780
with all the network drivers,
sends it down to the hardware

00:31:49.930 --> 00:31:51.200
and spits it out on the wire.

00:31:51.200 --> 00:31:53.960
And enumeration,
it will go through all of the

00:31:53.960 --> 00:31:57.530
available network interfaces,
including any sort of serial

00:31:57.790 --> 00:31:59.980
dial-up or Ethernet interfaces.

00:32:00.000 --> 00:32:03.790
It will enumerate them for you so you
can select whichever one you want to use.

00:32:04.910 --> 00:32:08.960
This is kind of a graphical
representation of how OpenPlay and

00:32:08.960 --> 00:32:12.400
NetSprocket function together,
with the high-level interface sitting

00:32:12.430 --> 00:32:17.350
on top of the Network Module Manager,
and Network Module Manager calling down

00:32:17.390 --> 00:32:23.930
into the various protocol stacks and
device interfaces that are available.

00:32:26.380 --> 00:32:29.660
There's a little more
information on OpenPlay.

00:32:29.690 --> 00:32:32.660
The URL is for Apple's
open source website.

00:32:32.740 --> 00:32:36.870
You can access it right there.

00:32:36.950 --> 00:32:38.510
There is a complete set of documentation.

00:32:38.640 --> 00:32:39.930
Well, okay.

00:32:40.110 --> 00:32:42.250
Not exactly complete,
but there is a set of documentation

00:32:42.250 --> 00:32:43.580
that goes along with OpenPlay.

00:32:43.580 --> 00:32:45.890
It is freely downloadable right now.

00:32:45.900 --> 00:32:49.340
I believe the version is 2.0.

00:32:49.900 --> 00:32:53.460
and David Hill, who are the founders of
Sound and Networking,

00:32:53.460 --> 00:32:55.010
are the founders of Sound and Networking.

00:32:55.520 --> 00:32:57.350
And there are two sample apps.

00:32:57.370 --> 00:33:00.460
I believe MiniPlay and MiniTest
are the two apps that I saw in

00:33:00.460 --> 00:33:03.970
there that I was able to look at.

00:33:03.990 --> 00:33:07.520
Again, it's all been carbonized,
so they should all just build

00:33:07.540 --> 00:33:09.700
and compile right out of the box.

00:33:11.200 --> 00:33:12.880
This is going to be the real
meat of our discussion here,

00:33:12.880 --> 00:33:13.950
which is BSD Sockets.

00:33:13.950 --> 00:33:17.220
It is the standard Unix networking API.

00:33:17.220 --> 00:33:20.400
It's available across every
implementation of Unix out there.

00:33:20.400 --> 00:33:23.420
The interface itself
has not changed in many,

00:33:23.420 --> 00:33:24.420
many years.

00:33:26.070 --> 00:33:30.630
However, there have been some supersets
of it made for Windows,

00:33:30.710 --> 00:33:36.000
and I thought SGI with Irix had another
implementation of Sockets that had

00:33:36.040 --> 00:33:41.070
more of a higher level user interface
to it than Straight Sockets did.

00:33:41.080 --> 00:33:44.200
One of the key things about
Sockets is that all of the

00:33:44.200 --> 00:33:46.090
functions are synchronous.

00:33:46.110 --> 00:33:47.830
They are blocking calls.

00:33:47.900 --> 00:33:49.700
Anytime you actually
call one of these things,

00:33:49.700 --> 00:33:51.680
you're going to have to
wait until it completes.

00:33:51.680 --> 00:33:54.980
As you'll see later on,
with certain functions such as DNS,

00:33:55.470 --> 00:33:58.460
when you do get host by
name or get host by address,

00:33:58.460 --> 00:34:00.750
you're going to sit there waiting
for a while if you've got some

00:34:00.810 --> 00:34:02.160
slow DNS servers in your pathway.

00:34:05.310 --> 00:34:10.380
This is sort of how a Sockets
application will look from a high level.

00:34:10.380 --> 00:34:15.550
Both the server and client will both call
Socket to create Sockets for themselves.

00:34:15.700 --> 00:34:18.790
Sockets are just file descriptors,
is really all they are

00:34:19.150 --> 00:34:21.040
across any operating system.

00:34:21.160 --> 00:34:25.690
So they're pretty much going
to function the same way any

00:34:25.690 --> 00:34:28.640
time you're accessing Sockets.

00:34:28.640 --> 00:34:30.230
For a server,
it's important to call bind.

00:34:30.330 --> 00:34:33.720
What bind does is bind takes a
local--the local address of the

00:34:33.720 --> 00:34:36.910
server and associates it with
that Socket so that any incoming

00:34:36.910 --> 00:34:41.220
connections to that server will say,
"Oh, here's the server we're looking for.

00:34:41.220 --> 00:34:43.060
Here's the address I want.

00:34:43.120 --> 00:34:47.180
You're the one." And that's how a client
and server can establish an association.

00:34:48.680 --> 00:34:53.050
The server will then call listen,
as listen is what sets up the socket so

00:34:53.120 --> 00:34:56.080
that it will accept incoming connections.

00:34:57.140 --> 00:35:01.650
And that, it would be on the client side,
the reference for that would be connect,

00:35:01.650 --> 00:35:03.600
where the client actually goes
out over the network and says,

00:35:03.600 --> 00:35:05.920
all right,
this is the server I'm looking for,

00:35:05.920 --> 00:35:07.420
where are you?

00:35:07.420 --> 00:35:11.850
The server that's now in listen
mode will hear that incoming

00:35:11.860 --> 00:35:15.420
connection and then provided,
of course,

00:35:15.420 --> 00:35:20.290
that the connection is correct and
the server is set up to handle a

00:35:20.290 --> 00:35:24.040
connection from that particular client,
it will call accept.

00:35:24.100 --> 00:35:27.870
Accept basically tells the server that,
yes, or excuse me,

00:35:27.870 --> 00:35:32.660
accept is the server's way of saying,
all right, client, you're good to go,

00:35:32.660 --> 00:35:34.730
I'll accept your connection.

00:35:34.790 --> 00:35:38.250
Accept will create, as its return value,
it creates a new socket in

00:35:38.330 --> 00:35:40.640
a connection-oriented mode.

00:35:40.640 --> 00:35:44.150
It would actually create
a new socket that is now

00:35:44.150 --> 00:35:49.560
associated with that end of the,
with the incoming client's socket.

00:35:49.560 --> 00:35:53.350
So you've now got an
endpoint-to-endpoint connection.

00:35:53.970 --> 00:35:56.500
Once you've established that
association between those two sockets,

00:35:56.500 --> 00:36:00.420
you're now free to send and receive data
back and forth between client and server.

00:36:01.000 --> 00:36:03.700
When you're done,
once all the data has been transmitted

00:36:03.700 --> 00:36:06.400
that needs to be transmitted,
both sides call close to

00:36:06.400 --> 00:36:07.630
get rid of the socket.

00:36:07.640 --> 00:36:09.540
Or excuse me,
that will close the connection

00:36:09.540 --> 00:36:11.050
that will not destroy the socket.

00:36:11.060 --> 00:36:13.030
How you do that,
I'll show you in a moment.

00:36:15.900 --> 00:36:18.350
So how are we going to
initialize the Sockets interface?

00:36:18.420 --> 00:36:25.270
Well, CFM Carbon applications are
going to need to load the Sockets

00:36:25.270 --> 00:36:28.870
framework through CFBundle.

00:36:28.870 --> 00:36:31.340
David showed you how to do
that in the sound portion.

00:36:31.340 --> 00:36:35.140
I've also included a URL up
here at the bottom of the page

00:36:35.140 --> 00:36:38.930
that if you look for the sample,
call Mako framework,

00:36:38.970 --> 00:36:44.650
that will tell you how to load a Mako
framework from a Carbon CFM application.

00:36:46.150 --> 00:36:48.880
Mako Carbon Applications,
all you have to do is include the system

00:36:48.960 --> 00:36:50.660
framework and it's right in there.

00:36:50.660 --> 00:36:55.700
If you wanted access to the
actual--if you wanted to see what

00:36:55.700 --> 00:37:01.890
the header files actually look like,
they're in the SIS subfolder of the

00:37:01.890 --> 00:37:08.980
system framework and there's SockIO,
Sockets.h and SocketVar.h are the three

00:37:09.020 --> 00:37:10.310
header files that you're going to want
to look at mainly if you're curious.

00:37:12.630 --> 00:37:14.740
Cocoa applications have two options.

00:37:14.770 --> 00:37:18.220
Naturally,
you can use the NSSockets framework,

00:37:18.220 --> 00:37:21.580
or you can load the system framework and
access them directly as I just described.

00:37:21.640 --> 00:37:24.300
Either way works just as well.

00:37:24.300 --> 00:37:27.090
The NSSockets framework, I believe,
is obviously set up for

00:37:27.200 --> 00:37:29.100
an Objective-C interface.

00:37:29.100 --> 00:37:31.110
So it's really six of one,
half dozen of the other,

00:37:31.110 --> 00:37:34.000
depending on which one you want to use.

00:37:36.200 --> 00:37:39.320
So creating sockets,
as I mentioned before,

00:37:39.320 --> 00:37:42.740
both servers and clients will
need to create sockets in order

00:37:42.740 --> 00:37:44.990
to communicate over the network.

00:37:45.270 --> 00:37:49.070
Per connection, you need one socket.

00:37:49.070 --> 00:37:55.250
Now with multicasting, multihoming,
and a couple of things like UDP,

00:37:55.250 --> 00:37:59.340
for instance, you can actually,
because it's a connectionless protocol,

00:37:59.340 --> 00:38:04.470
UDP is capable of sending messages
to different hosts on the network.

00:38:04.580 --> 00:38:07.610
For instance, with UDP,
if you had four servers

00:38:07.610 --> 00:38:11.490
out there and one client,
if all of them were using UDP,

00:38:11.510 --> 00:38:13.400
the client would be able to
send a message to server one,

00:38:13.400 --> 00:38:16.050
server two, server three,
and server four without establishing

00:38:16.050 --> 00:38:19.940
a connection in between all of them
because UDP is a connectionless protocol.

00:38:19.940 --> 00:38:23.360
It uses what's called a datagram
that includes in it the,

00:38:23.360 --> 00:38:26.560
or as a parameter to the send
function or send to function,

00:38:26.560 --> 00:38:30.050
it includes the address of the server
that you want to talk to or the

00:38:30.160 --> 00:38:32.280
destination that you want to talk to.

00:38:32.280 --> 00:38:33.810
So every time you send a message,
you're telling, "Okay,

00:38:33.870 --> 00:38:35.000
I'm sending this one to server one.

00:38:35.000 --> 00:38:38.610
Now I'm going to send this one to
server four." That's already included

00:38:38.760 --> 00:38:40.940
right there in the send to function.

00:38:41.420 --> 00:38:45.010
The socket function returns
a socket descriptor,

00:38:45.010 --> 00:38:46.970
as I mentioned earlier.

00:38:46.980 --> 00:38:49.300
The socket descriptor is
just a file descriptor.

00:38:49.300 --> 00:38:52.300
If you really look at it,
it's just an int.

00:38:52.300 --> 00:38:55.570
So, very simple data type.

00:38:57.370 --> 00:38:58.970
So how are you going to create sockets?

00:38:59.010 --> 00:39:04.240
This is a little-- this code here,
you can use this code directly,

00:39:04.250 --> 00:39:06.580
and you'll create
sockets of various types.

00:39:06.580 --> 00:39:10.280
The top one is a SOC stream
that's used with the protocol TCP,

00:39:10.280 --> 00:39:14.510
which will create a connection-oriented,
data stream-oriented socket.

00:39:14.920 --> 00:39:18.800
These are useful for things
like doing file transfers,

00:39:18.810 --> 00:39:21.100
if you're going to send
contiguous blocks of data.

00:39:21.100 --> 00:39:29.430
So if you wanted to stream audio out,
you'd probably want to use TCP.

00:39:29.490 --> 00:39:31.930
TCP is a reliable protocol,
which means it does its error

00:39:31.930 --> 00:39:33.240
checking and correcting.

00:39:33.240 --> 00:39:34.350
It will do resends.

00:39:34.400 --> 00:39:37.210
There is a little caveat to that.

00:39:37.260 --> 00:39:42.150
TCP is under no obligation whatsoever to
let you know that it's doing resends or

00:39:42.150 --> 00:39:43.640
let you know that it's dropped packets.

00:39:44.140 --> 00:39:45.000
So what does that mean?

00:39:45.000 --> 00:39:49.680
Well, you can be sending your data
happily to a TCP socket,

00:39:49.680 --> 00:39:52.340
and it will be humming along just fine.

00:39:52.340 --> 00:39:53.780
The other end won't be
receiving any of it.

00:39:53.960 --> 00:39:55.790
You won't know about it,
and neither will they.

00:39:55.810 --> 00:39:57.710
All they see is no more
data is coming through.

00:39:57.720 --> 00:40:00.810
TCP will just stop resending.

00:40:02.070 --> 00:40:03.000
That's it.

00:40:03.200 --> 00:40:04.500
That's all you get.

00:40:04.620 --> 00:40:08.760
So there's really no way to make TCP/IP,
or excuse me,

00:40:08.760 --> 00:40:11.750
TCP tell you that it's now doing
error checking and correcting and

00:40:11.750 --> 00:40:14.310
trying to reestablish its connection.

00:40:14.470 --> 00:40:16.270
There's no functionality
for that whatsoever,

00:40:16.270 --> 00:40:19.200
which means it can be kind
of dangerous to use if you

00:40:19.340 --> 00:40:22.280
have real-time critical data.

00:40:22.980 --> 00:40:23.750
So what's your option?

00:40:23.750 --> 00:40:25.000
UDP.

00:40:25.000 --> 00:40:29.320
UDP is connectionless,
but it is unreliable.

00:40:29.320 --> 00:40:32.480
What you have to do is implement a
reliability protocol on top of UDP.

00:40:32.480 --> 00:40:34.080
Fairly easy to do.

00:40:34.080 --> 00:40:38.030
All you have to do is, as you're sending
messages back and forth,

00:40:38.150 --> 00:40:42.970
you just make sure that both the client
and server have some method of saying,

00:40:43.070 --> 00:40:44.580
all right, I sent a message.

00:40:44.580 --> 00:40:45.380
Did you get it?

00:40:45.470 --> 00:40:48.000
Client responds, I got the message.

00:40:48.000 --> 00:40:50.900
And then you just kind of
loop back and forth on that.

00:40:51.940 --> 00:40:54.360
Whenever one of them does
not receive a message,

00:40:54.580 --> 00:40:57.930
all you have to do is say, all right,
resend, and you retransmit the same data.

00:40:57.940 --> 00:41:02.030
It does require a little bit of work,
although most of the time,

00:41:02.030 --> 00:41:05.120
if you're talking about network gaming,
where you really need to be

00:41:05.130 --> 00:41:07.580
sending data back and forth,
and it doesn't matter,

00:41:07.580 --> 00:41:10.210
if you miss message five and
you're now on message 11,

00:41:10.260 --> 00:41:12.960
message five is probably irrelevant
out-of-date information anyway,

00:41:12.960 --> 00:41:14.200
so there's no need to resend.

00:41:14.200 --> 00:41:16.410
You drop it,
you interpolate between where

00:41:16.530 --> 00:41:18.700
you were and where you are,
and you move on.

00:41:18.830 --> 00:41:20.280
For instance, that would be for
something like movement.

00:41:22.960 --> 00:41:27.740
The last thing is an ICMP, which is
Internet Control Message Protocol.

00:41:27.740 --> 00:41:32.890
You would use this for any sort of, well,
Internet Control Message.

00:41:33.100 --> 00:41:34.430
Things like pings.

00:41:34.430 --> 00:41:36.970
Pings are all done through ICMP.

00:41:40.320 --> 00:41:43.400
So establishing connections.

00:41:43.510 --> 00:41:48.240
Well, the first thing you need
is you need an address.

00:41:48.240 --> 00:41:52.940
And Sockets defines
the SOC ADDR structure,

00:41:52.950 --> 00:41:58.660
which has a name, it's got a port,
and an address.

00:41:59.020 --> 00:42:02.150
Those are the three things that you
need to establish the association

00:42:02.150 --> 00:42:04.010
that you need for a connection.

00:42:04.010 --> 00:42:07.340
That applies to both
TCP connection-oriented and

00:42:07.340 --> 00:42:12.320
UDP connectionless associations.

00:42:16.650 --> 00:42:18.380
Generally speaking,
you're going to need the length too,

00:42:18.380 --> 00:42:22.980
which is why you do the
size of the address,

00:42:22.980 --> 00:42:27.500
just for the purposes of sending it
to some of the initialization and

00:42:27.520 --> 00:42:28.850
sending functions that Sockets has.

00:42:34.270 --> 00:42:37.140
You'll see int backlog.

00:42:37.170 --> 00:42:39.480
That's used down there
in the listen function,

00:42:39.620 --> 00:42:42.300
where when the server calls
listen on a particular socket,

00:42:42.300 --> 00:42:45.010
it needs to know how many
connections you want to queue

00:42:45.010 --> 00:42:46.800
before it starts dropping them.

00:42:47.590 --> 00:42:50.890
If you specify that to zero,
it will process connections

00:42:50.960 --> 00:42:52.050
as they come in.

00:42:52.050 --> 00:42:54.770
There's only one problem with that,
is that if you're

00:42:54.840 --> 00:42:56.350
processing a connection,
if you're in the middle of

00:42:56.460 --> 00:42:58.440
processing a connection,
then it's not going to be

00:42:58.440 --> 00:43:00.930
paying attention to what's
going on in that socket.

00:43:00.930 --> 00:43:03.900
So a connection can come in and
it will just automatically drop.

00:43:03.990 --> 00:43:06.290
So generally you want to set it
to something like two or three.

00:43:06.290 --> 00:43:11.790
If you have an extremely busy server,
you want to set that up higher so it

00:43:11.800 --> 00:43:12.770
will actually queue the connections
up and you don't lose any of them.

00:43:13.390 --> 00:43:18.200
Bind, right above it,
what bind does is it will

00:43:18.200 --> 00:43:23.670
associate the socket address that
you've specified with the socket.

00:43:23.770 --> 00:43:25.080
So for a server, what does that mean?

00:43:25.280 --> 00:43:28.080
As I said before,
it means that now the server

00:43:28.080 --> 00:43:30.280
has an idea of who it is.

00:43:30.380 --> 00:43:34.840
So when there's connections coming
in for that specific address,

00:43:34.840 --> 00:43:40.560
the server knows that it's referring to
itself and will then continue to call it.

00:43:40.830 --> 00:43:45.360
It will continue to accept
incoming connections because

00:43:45.360 --> 00:43:47.660
it now has some identity.

00:43:47.660 --> 00:43:50.810
You can call bind on the client side.

00:43:51.600 --> 00:43:54.260
That's useful for a couple
of different things.

00:43:54.260 --> 00:43:59.960
If you have a UDP connection,
you have a UDP connectionless

00:44:00.990 --> 00:44:02.370
association,
on a client side,

00:44:02.460 --> 00:44:07.700
it's kind of strange because a UDP socket
will accept input from anywhere.

00:44:07.700 --> 00:44:10.990
So some random guy on the net sends
a package out that happens to have,

00:44:10.990 --> 00:44:13.740
or sends a datagram out that happens
to have your address in it because

00:44:13.740 --> 00:44:16.020
they erroneously specified it.

00:44:16.020 --> 00:44:18.430
Unless you're locked in,
your client's going to pick that up

00:44:18.430 --> 00:44:20.020
and it's going to read that data in.

00:44:20.020 --> 00:44:21.700
So how do you prevent
that from happening?

00:44:21.700 --> 00:44:23.080
Well, you call bind.

00:44:23.200 --> 00:44:24.970
What bind does on the
client side is it says,

00:44:24.970 --> 00:44:29.630
"All right, I'm only going to use this
socket to transmit data to and

00:44:30.040 --> 00:44:35.080
from this address." It will not
accept data from anywhere else.

00:44:35.080 --> 00:44:39.910
It will only accept datagrams
from the address that you specify.

00:44:40.100 --> 00:44:44.320
This does not mean that you cannot
re-associate that socket later if,

00:44:44.320 --> 00:44:46.980
for instance,
your client wants to communicate

00:44:46.980 --> 00:44:48.340
with a couple of different servers.

00:44:48.390 --> 00:44:50.060
There's a little more work involved.

00:44:50.130 --> 00:44:53.380
You'd have to actually shut down the
connection and destroy the association,

00:44:53.380 --> 00:44:56.900
recreate your socket,
and then continue to send or continue

00:44:56.910 --> 00:44:58.880
to communicate with a new server.

00:44:58.880 --> 00:45:01.260
But it can be done.

00:45:07.880 --> 00:45:10.170
So again, onto the Accept function.

00:45:10.180 --> 00:45:13.020
This is only used on the server side.

00:45:13.080 --> 00:45:15.770
It can be used when you're talking
about a client-server architecture.

00:45:15.770 --> 00:45:17.960
If you have a client
that is also a server,

00:45:18.000 --> 00:45:20.730
you can use Accept,
although it's usually easier if

00:45:20.800 --> 00:45:24.000
you're doing client-server to
just go peer-to-peer as opposed

00:45:24.000 --> 00:45:25.900
to having the separation there.

00:45:27.040 --> 00:45:32.710
If you don't call Accept, excuse me,
if you call Accept from a server,

00:45:32.750 --> 00:45:34.200
it will create a new socket.

00:45:34.200 --> 00:45:38.650
So now you're going
to have a wider array.

00:45:43.010 --> 00:45:46.330
What you would end up with is you'd end
up with a whole bunch of sockets that

00:45:46.340 --> 00:45:47.700
are associated with the same client.

00:45:47.700 --> 00:45:50.900
So you'd kind of get this crisscrossed
network that ends up being,

00:45:50.900 --> 00:45:54.090
you'd end up with
peer-to-peer at that point.

00:45:58.960 --> 00:46:02.580
So Sockets, excuse me,
Accept takes the socket that you want

00:46:02.650 --> 00:46:05.400
to accept the incoming connection on.

00:46:05.400 --> 00:46:09.580
It accepts, it also takes the address
and the address length.

00:46:10.020 --> 00:46:13.890
It will have that information
because when the server receives the

00:46:13.890 --> 00:46:17.870
incoming connection from the client,
the incoming address from the client

00:46:17.920 --> 00:46:19.380
is actually transmitted to the server.

00:46:19.380 --> 00:46:21.690
That's where you will get
that information from.

00:46:21.730 --> 00:46:25.480
Now, when the accept function returns,
it does return a new socket.

00:46:25.750 --> 00:46:29.000
If you want to communicate with the
client on the other end of that socket,

00:46:29.050 --> 00:46:30.820
that is the socket that you use.

00:46:30.820 --> 00:46:34.390
The listening socket on the server,
you shouldn't be transmitting more

00:46:34.390 --> 00:46:38.170
data on because it's sitting there
just waiting for incoming connections.

00:46:42.860 --> 00:46:44.200
So here we'll go through
the connect function.

00:46:44.360 --> 00:46:46.200
This is again for connection oriented.

00:46:46.300 --> 00:46:50.100
For UDP it's slightly different.

00:46:50.160 --> 00:46:54.190
The socket that you pass in there
is the client's local socket.

00:46:54.290 --> 00:46:57.290
The address that you pass in is the
address that you want to connect to,

00:46:57.350 --> 00:46:58.550
not the address of the client.

00:46:58.560 --> 00:47:02.400
I suppose you could connect to yourself
if you wanted to do a loopback,

00:47:02.400 --> 00:47:06.540
but that would be entirely
application-specific.

00:47:06.540 --> 00:47:09.280
You also send it, as I mentioned earlier,
the address length.

00:47:09.290 --> 00:47:12.500
This is one of those
functions that requires that.

00:47:12.500 --> 00:47:15.830
It needs to know how much data
you're actually passing into it.

00:47:16.420 --> 00:47:20.740
Connect only returns--Connect does not
return anything but error codes that

00:47:20.850 --> 00:47:23.840
will return zero if no error occurs.

00:47:23.840 --> 00:47:29.480
You can use getLastError, I believe,
will give you the last

00:47:29.480 --> 00:47:31.140
socket error that occurred.

00:47:31.240 --> 00:47:33.290
You have to be careful with
that because that's not updated.

00:47:33.390 --> 00:47:35.500
It's only updated when an error occurs.

00:47:35.500 --> 00:47:41.530
So if you call getLastError,
if--when a function returns zero,

00:47:41.530 --> 00:47:42.660
you get the last error
that actually occurred.

00:47:46.750 --> 00:47:49.960
One of the little caveats about
Connect is that Connect assigns the

00:47:49.960 --> 00:47:52.500
local address if you don't call bind.

00:47:52.530 --> 00:47:53.690
Normally that's fine.

00:47:53.860 --> 00:47:57.700
Unless you wanted to assign
your client a different address,

00:47:57.830 --> 00:47:59.650
there wouldn't be much
of a problem with that.

00:47:59.710 --> 00:48:04.500
The reason that it doesn't do this,
I believe, is for when you wanted to

00:48:04.500 --> 00:48:06.700
do dynamic address updating.

00:48:06.700 --> 00:48:11.200
That's getting way, way off topic.

00:48:11.280 --> 00:48:14.090
That's not something I want to go into.

00:48:15.660 --> 00:48:17.290
So sending and receive data.

00:48:17.290 --> 00:48:19.810
You've got a couple of
different functions.

00:48:19.810 --> 00:48:23.630
For connection-oriented sockets,
you'll be using send and receive.

00:48:23.830 --> 00:48:27.490
There's also two other functions
that are send to and receive from.

00:48:27.490 --> 00:48:31.620
Those are mainly used with UDP because
one of their parameters is the address

00:48:31.620 --> 00:48:33.900
that you want to communicate to or from.

00:48:33.900 --> 00:48:38.180
With a connection-oriented socket,
both functions perform identically.

00:48:38.180 --> 00:48:39.600
There's no difference.

00:48:39.790 --> 00:48:44.360
You're simply passing in an address,
but you've already got a connection.

00:48:45.600 --> 00:48:48.380
The connection that's established is
already associated with that address,

00:48:48.380 --> 00:48:49.720
so the extra input is just discarded.

00:48:49.720 --> 00:48:56.810
You can use both of them synonymously
with a connection-oriented socket,

00:48:56.810 --> 00:48:58.800
GCP, streaming.

00:49:00.610 --> 00:49:02.000
which is usually not a bad
idea if you're going to be

00:49:02.000 --> 00:49:03.100
changing protocols on the fly.

00:49:03.100 --> 00:49:04.990
You should probably use
send to and receive from.

00:49:05.070 --> 00:49:07.000
There's slightly more
overhead involved with them,

00:49:07.000 --> 00:49:10.290
but it's not significant
enough to worry about.

00:49:10.850 --> 00:49:16.360
So as parameters, send takes the socket
that you want to send on.

00:49:16.990 --> 00:49:19.140
For a client, that would be the only
socket that it has.

00:49:19.140 --> 00:49:23.100
For a server, that would be the socket
for a streaming server,

00:49:23.100 --> 00:49:26.000
for a TCP server,
that would be the socket that

00:49:26.060 --> 00:49:28.880
is associated with a client
you want to communicate with.

00:49:28.920 --> 00:49:34.140
If you have a wide array of
clients and you want to broadcast

00:49:34.140 --> 00:49:39.420
a message to all of them using TCP,
you'd have to iterate through each

00:49:39.420 --> 00:49:39.420
socket and send the same data on
each socket before you could move on.

00:49:39.820 --> 00:49:42.840
It also takes a pointer to a buffer,
which is just a buffer of

00:49:42.840 --> 00:49:47.890
bytes that it will read in and
splatter out on the network.

00:49:48.090 --> 00:49:48.950
Bytes is the byte count.

00:49:49.010 --> 00:49:53.000
That's how many bytes of data
are in the buffer at the time.

00:49:53.000 --> 00:49:57.000
And you just pass that along with
any flags that you might have.

00:49:57.000 --> 00:50:00.000
Flags are not terribly important.

00:50:00.000 --> 00:50:04.080
Only if you're going to be sending
things like out-of-band data,

00:50:04.080 --> 00:50:07.000
which is beyond the
scope of this discussion,

00:50:07.000 --> 00:50:09.000
is flags really important.

00:50:09.000 --> 00:50:10.900
Most of the time you can just pass zero.

00:50:11.390 --> 00:50:13.670
Receive, on the other hand,
is the socket that you want

00:50:13.670 --> 00:50:14.800
to receive the data on.

00:50:15.240 --> 00:50:17.990
Again, for a server,
you're going to have to iterate through

00:50:17.990 --> 00:50:22.300
all of the sockets that you've created
with Accept in order to get all of the

00:50:22.300 --> 00:50:25.730
data that's incoming from the clients,
which can be kind of slow.

00:50:25.740 --> 00:50:29.110
This is why it's recommended
that for real-time games,

00:50:29.130 --> 00:50:32.240
for real-time data like that,
you want to use UDP.

00:50:32.240 --> 00:50:34.800
It gives the server one socket
that it has to read data in on.

00:50:34.850 --> 00:50:39.100
Granted, the buffer is large,
but you can read data in a lot faster

00:50:39.100 --> 00:50:43.120
from a single large buffer than
you can from 300 buffers having to

00:50:43.120 --> 00:50:49.570
loop through each one and call the
same data input routines every time.

00:50:50.210 --> 00:50:52.510
Receive takes the same number
of parameters and the same

00:50:52.510 --> 00:50:56.500
kinds of parameters as send.

00:50:56.500 --> 00:50:58.790
The receive buffer, however,
is not a pointer to the

00:50:58.790 --> 00:51:00.140
buffer that the data is in.

00:51:00.140 --> 00:51:03.040
It is a pointer to the buffer that
the data will be transferred into.

00:51:03.040 --> 00:51:06.620
If you do not have a data buffer that
is large enough to accommodate the data,

00:51:06.620 --> 00:51:07.580
this function will fail.

00:51:07.600 --> 00:51:13.160
It will come back with the,
forget the error message

00:51:13.160 --> 00:51:16.540
that it fails with,
but it fails with something similar

00:51:16.540 --> 00:51:19.150
to your data buffer is not big enough,
so reallocate it.

00:51:19.820 --> 00:51:22.980
To get around that, you can do a,
if you pass in as one

00:51:22.980 --> 00:51:25.920
of the flags to receive,
I think that you can

00:51:25.920 --> 00:51:28.140
pass in message peak,
which will tell you exactly

00:51:28.140 --> 00:51:29.600
how much data is in the buffer.

00:51:29.600 --> 00:51:32.930
So you can do that before you
read it in every time and allocate

00:51:32.930 --> 00:51:34.350
your buffer dynamically like that.

00:51:34.400 --> 00:51:37.780
So shutdown and cleanup.

00:51:40.780 --> 00:51:44.680
All these functions take, or close,
close just shuts down the socket.

00:51:44.850 --> 00:51:45.690
That's all it does.

00:51:45.700 --> 00:51:49.000
And it just accepts,
it only takes as a parameter the

00:51:49.030 --> 00:51:51.610
socket that you want to close.

00:51:51.910 --> 00:51:52.530
Very simple.

00:51:52.540 --> 00:51:57.610
Shutdown, on the other hand,
is a little more in-depth.

00:51:57.690 --> 00:52:00.850
With shutdown,
you can tell it what you want to do

00:52:00.850 --> 00:52:05.720
with any residual data that's remaining
on the send or receive buffers.

00:52:06.480 --> 00:52:10.390
A lot of times you'll want to
flush and clear any residual data.

00:52:10.400 --> 00:52:12.900
You want to get those
last few bytes in or out.

00:52:13.260 --> 00:52:17.210
So you want to use shutdown.

00:52:17.250 --> 00:52:20.860
A lot of times,
the extra control that Shutdown

00:52:20.860 --> 00:52:23.200
does offer is quite useful.

00:52:23.290 --> 00:52:28.360
I call Shutdown in my network
applications more often than

00:52:28.410 --> 00:52:30.120
I just simply call Close.

00:52:35.710 --> 00:52:39.730
Your port number is going to be
assigned based on your address.

00:52:39.740 --> 00:52:44.360
Both of them are actually
going to clear your port.

00:52:44.360 --> 00:52:48.390
Once the socket is closed or shut down,
that will free the

00:52:50.420 --> 00:52:55.510
So a few little tips
and tricks for Mac OS X.

00:52:55.650 --> 00:52:57.380
For open transport applications,
what can you do?

00:52:57.380 --> 00:52:59.990
I know there's a lot of existing open
transport applications out there.

00:53:00.020 --> 00:53:01.610
So there's two options.

00:53:01.610 --> 00:53:03.620
You can use the OT shim that's there.

00:53:03.730 --> 00:53:04.700
It does work.

00:53:04.700 --> 00:53:09.110
But your other option is to
port it directly to sockets.

00:53:09.130 --> 00:53:12.230
As I said, OT on X sits right on
top of the sockets layer,

00:53:12.240 --> 00:53:15.900
and you do incur about a 10%
performance hit to use OT as opposed

00:53:16.010 --> 00:53:17.880
to going directly to sockets.

00:53:18.700 --> 00:53:21.490
I'm going to go through a couple
of slides in a moment that will

00:53:21.490 --> 00:53:25.290
show you how OT maps to sockets if,
in fact, you do want to port your

00:53:25.310 --> 00:53:27.290
OT app to sockets directly.

00:53:29.240 --> 00:53:32.360
For Windows and Unix applications,
Unix apps are going to be pretty

00:53:32.360 --> 00:53:34.300
much a straightforward port.

00:53:34.300 --> 00:53:36.530
I don't think there's any
semantic differences between our

00:53:36.640 --> 00:53:40.860
implementation of sockets and
the standard Unix implementation.

00:53:40.860 --> 00:53:42.840
Winsock applications,
there are some notable differences

00:53:42.840 --> 00:53:46.560
which I will go through momentarily.

00:53:46.580 --> 00:53:51.680
And there's also Direct Play applications
which aren't going to really

00:53:51.680 --> 00:53:54.100
translate across to anything,
but I can give you some suggestions

00:53:54.120 --> 00:53:56.290
as to where you might want to look.

00:53:59.920 --> 00:54:05.440
So using OTCM is again
the easy way onto 9,

00:54:05.850 --> 00:54:09.520
or from 8 and 9 onto 10.

00:54:09.600 --> 00:54:13.620
Porting to sockets would
be my recommendation.

00:54:13.690 --> 00:54:15.600
So how are you going to do that?

00:54:16.150 --> 00:54:20.450
Well, here's some of the,
on the left-hand side of this slide,

00:54:20.450 --> 00:54:23.520
you'll see some of the

00:54:23.720 --> 00:54:30.890
Open Transport Functions.

00:54:30.890 --> 00:54:30.890
On the right,
you'll see their sort of brother

00:54:30.890 --> 00:54:30.890
that lives in Sockets Land.

00:54:31.250 --> 00:54:35.080
So OT endpoint,
that's just a socket as far

00:54:35.080 --> 00:54:37.700
as we're concerned here.

00:54:37.700 --> 00:54:42.330
Bind and connect,
map over to bind and connect for

00:54:42.400 --> 00:54:45.790
sockets for an active OT connection.

00:54:45.910 --> 00:54:50.800
Now I'm not exactly sure
what the difference is.

00:54:50.810 --> 00:54:50.810
I'm not really an OT guy.

00:54:50.970 --> 00:54:56.780
These two obviously map pretty
well right over to Sockets.

00:54:57.940 --> 00:55:03.540
So for sending data, again,
there's an extra send,

00:55:03.540 --> 00:55:05.420
which is send message,
which is datagram-oriented.

00:55:05.420 --> 00:55:08.820
It's a function call that
I'm not too familiar with.

00:55:08.890 --> 00:55:10.770
I tend to stick to send
and send to myself.

00:55:10.800 --> 00:55:16.490
But I'm assuming that they're going to be
fairly simple and probably more similar

00:55:16.500 --> 00:55:18.370
to send to than they would be to send.

00:55:18.380 --> 00:55:21.660
That is, they take the address parameter
and they'll take probably

00:55:21.660 --> 00:55:24.060
the length of the address,
I would assume.

00:55:27.480 --> 00:55:28.820
And receiving is the same way.

00:55:28.860 --> 00:55:35.650
So disconnecting and cleaning up.

00:55:43.710 --> 00:55:48.830
As I said, you can use Shutdown.

00:55:48.910 --> 00:55:52.940
One of the interesting things about
this is the SetSockOp SO Linger.

00:55:53.510 --> 00:55:56.160
What exactly does that do?

00:55:56.160 --> 00:55:59.800
Setting that SOC option, S-O-L-I-N-G-E-R,
means that the socket is going to stick

00:55:59.800 --> 00:56:02.800
around until you actively close it.

00:56:03.180 --> 00:56:07.680
and until any remaining data is
read or received from that socket.

00:56:07.680 --> 00:56:10.180
That's just all it means.

00:56:10.180 --> 00:56:14.440
As opposed to if you simply
called shut down or close,

00:56:14.440 --> 00:56:18.070
you can actually just kill it right
there and not read any of the data in.

00:56:19.820 --> 00:56:26.360
So I mentioned before a little
something about synchronous operations.

00:56:26.360 --> 00:56:29.200
These two functions,
getHostByName and getHostByAddress,

00:56:29.200 --> 00:56:33.100
they're both blocking functions,
which means that they're going to

00:56:33.290 --> 00:56:35.690
stall until they actually get a return.

00:56:36.320 --> 00:56:39.300
There's a way around that,
which is by placing these in their own

00:56:39.400 --> 00:56:42.490
threads and letting that thread go off
and wait however long it wants to while

00:56:42.490 --> 00:56:43.940
you continue with your application.

00:56:43.940 --> 00:56:48.700
That's the recommended way of
emulating async mode on Mac OS X or

00:56:48.750 --> 00:56:50.460
on any Sockets implementation,
for that matter.

00:56:52.260 --> 00:56:54.430
Another point to note about
these is you can't cancel them.

00:56:54.450 --> 00:56:56.320
So once you go in, there's no going back.

00:56:56.450 --> 00:56:58.720
You've got to wait until it finishes.

00:57:02.680 --> 00:57:04.950
So with Direct Play,
Direct Play is obviously

00:57:04.950 --> 00:57:06.410
specific to Windows directly.

00:57:06.410 --> 00:57:14.200
There's no other API like it out there,
say for something like NetSprocket that

00:57:14.200 --> 00:57:16.900
is kind of the same high-level type API.

00:57:17.720 --> 00:57:20.080
You can port Direct Play to NetSprocket.

00:57:20.080 --> 00:57:23.950
I'll be perfectly honest with you,
I've never looked into doing that,

00:57:24.020 --> 00:57:26.500
so I don't know how much
work would be involved,

00:57:26.560 --> 00:57:31.100
but I would assume that it's probably
not going to be the easiest thing to do,

00:57:31.120 --> 00:57:34.720
but it is an option if you're
willing to go down that path.

00:57:36.720 --> 00:57:37.940
Winsock is much more interesting.

00:57:37.940 --> 00:57:42.060
Winsock mostly maps
onto Sockets directly.

00:57:42.060 --> 00:57:45.210
By mostly, I mean that there are some
functions in Winsock that are

00:57:45.290 --> 00:57:46.910
specific to Winsock itself.

00:57:50.460 --> 00:57:51.240
So what are the differences?

00:57:51.240 --> 00:57:54.430
Sockets has no
asynchronous functionality.

00:57:54.710 --> 00:57:57.280
I just mentioned before how to
deal with that little caveat.

00:57:57.280 --> 00:58:01.580
There are also no predefined startup or
shutdown routines because they're not

00:58:01.650 --> 00:58:05.760
necessary on Mac OS X or on any Sockets
implementation aside from Windows,

00:58:05.760 --> 00:58:06.610
I believe.

00:58:07.360 --> 00:58:12.510
Like WSA Startup, WSA Cleanup,
WSA Async Select is another one that's

00:58:12.510 --> 00:58:18.140
used a lot to generate the asynchronous
message modes that Winsock uses.

00:58:18.140 --> 00:58:22.010
None of these things are available.

00:58:22.350 --> 00:58:27.290
and David Hill,
are not part of the standard Sockets API,

00:58:27.310 --> 00:58:31.990
which is the standard
cross-platform Sockets API.

00:58:32.010 --> 00:58:35.510
They are only available on Windows.

00:58:35.910 --> 00:58:39.070
Any functions that are
prefixed by the WSA,

00:58:39.210 --> 00:58:42.400
those are all specific to Windows itself.

00:58:42.400 --> 00:58:45.010
So if you're looking for
cross-platform compatibility,

00:58:45.010 --> 00:58:47.860
those are things that you'll
want to try to use less.

00:58:50.900 --> 00:58:55.700
The last bullet on this
slide is kind of interesting.

00:58:55.810 --> 00:58:59.690
Windows defines a data type of socket,
all uppercase.

00:59:01.250 --> 00:59:03.900
The standard socket data
type is just an int,

00:59:03.900 --> 00:59:04.880
it's a file descriptor.

00:59:04.910 --> 00:59:07.820
So why does Windows redefine the socket?

00:59:07.820 --> 00:59:08.910
That's a good question.

00:59:08.910 --> 00:59:11.600
Because I don't rightly know.

00:59:13.740 --> 00:59:15.290
I do know that it causes
a lot of problems,

00:59:15.290 --> 00:59:19.080
Oak, because when I was first
writing network applications,

00:59:19.080 --> 00:59:23.180
I was using the socket data type very
heavily until I found out that you can

00:59:23.180 --> 00:59:25.880
just cast an int to the same thing,
and it still works.

00:59:25.880 --> 00:59:27.630
Yet,
I don't have to go through the effort

00:59:27.760 --> 00:59:30.730
of recoding every time I move my
Windows code to another platform.

00:59:30.740 --> 00:59:34.000
So just one of those
little interesting tidbits.

00:59:34.090 --> 00:59:36.080
I stay away from the socket definition.

00:59:40.000 --> 00:59:42.340
So kind of as a summary,
I went through the networking

00:59:42.340 --> 00:59:45.150
technologies that are
available on Mac OS X.

00:59:45.360 --> 00:59:47.550
Those include OpenTransport,
which is fully carbonized,

00:59:47.690 --> 00:59:50.680
OpenPlay and NetSprocket, again,
which are carbonized and

00:59:50.680 --> 00:59:52.100
are also open source.

00:59:52.190 --> 00:59:55.400
And I also went through
Sockets in relative detail.

00:59:55.480 --> 01:00:00.340
I went through the initialization
of it and how to set up your Sockets

01:00:00.340 --> 01:00:03.940
application and kind of give you a
general idea of how a client-server

01:00:04.010 --> 01:00:06.390
application is going to work.

01:00:08.270 --> 01:00:11.930
Went through some of the little tips,
tricks, and caveats for networking

01:00:11.930 --> 01:00:14.760
on Mac OS X and bringing your
network applications to OS X.

01:00:14.760 --> 01:00:19.030
And one of the more important things was
illustrating the differences between an

01:00:19.030 --> 01:00:22.950
API such as Winsock that is specific to
the Windows platform and the Sockets API,

01:00:22.950 --> 01:00:24.440
which is a standard Unix definition.

01:00:27.570 --> 01:00:29.090
So for a little more
information on networking,

01:00:29.100 --> 01:00:32.340
there's two series of books that
I would highly recommend to anybody

01:00:32.340 --> 01:00:33.540
who's very interested in networking.

01:00:33.540 --> 01:00:36.570
The top one is Unix
Network Programming by Stevens.

01:00:36.580 --> 01:00:38.260
Excellent series of books.

01:00:38.260 --> 01:00:43.300
The first one, Volume 1,
goes into a lot of detail about how the

01:00:43.380 --> 01:00:46.880
networking subsystem operates on Unix.

01:00:46.880 --> 01:00:51.340
It goes into the whole basis for TCPIP,
and there's a lot of

01:00:51.340 --> 01:00:53.510
great information in it.

01:00:53.870 --> 01:00:56.240
Volume 2 is more about
inter-process communication,

01:00:56.240 --> 01:01:03.340
which is using sockets as pipes for
talking between applications on the

01:01:03.340 --> 01:01:04.700
same server or on different servers.

01:01:06.440 --> 01:01:09.360
The TCP/IP series,
it's called Internetworking

01:01:09.380 --> 01:01:13.230
with TCP/IP by Comer,
is another great series on networking.

01:01:13.320 --> 01:01:17.540
The first one is the
principles and practices,

01:01:17.540 --> 01:01:18.840
the second one is...

01:01:19.240 --> 01:01:20.100
Anybody know?

01:01:20.100 --> 01:01:21.000
I don't remember.

01:01:21.080 --> 01:01:24.480
Actually,
I don't remember what two and three are.

01:01:24.500 --> 01:01:26.100
But they're really good, I know that.

01:01:26.100 --> 01:01:27.200
Because I own them all.

01:01:27.220 --> 01:01:31.470
There's also some things that some...

01:01:33.160 --> 01:01:34.100
Mailing lists.

01:01:34.100 --> 01:01:37.140
That one escaped me for a moment.

01:01:37.140 --> 01:01:39.680
There's three mailing lists
in particular at Apple that

01:01:40.060 --> 01:01:43.130
are maintained at Apple that
you'll want to look at if you're

01:01:43.130 --> 01:01:44.340
interested in more networking stuff.

01:01:44.340 --> 01:01:45.970
The Open Play Developers List.

01:01:46.030 --> 01:01:48.900
That one obviously relates
specifically to Open Play and

01:01:48.900 --> 01:01:50.330
that open source project.

01:01:50.400 --> 01:01:54.920
Not terribly active, but it seems to be
generating more interest now.

01:01:54.920 --> 01:01:56.820
The Open Transport Developers List.

01:01:56.830 --> 01:01:58.510
I'm not sure how active that is.

01:01:58.520 --> 01:02:00.500
As I said,
I'm not really an open transport guy.

01:02:01.980 --> 01:02:04.120
From what I understand,
it's still pretty busy.

01:02:04.120 --> 01:02:06.200
Then there's also the
Darwin Developers List.

01:02:06.240 --> 01:02:09.540
Make sure you have a lot of room on
your hard drive if you're downloading

01:02:09.540 --> 01:02:11.300
this list because it is busy.

01:02:11.300 --> 01:02:13.540
Probably on the order
of 100 messages a day.

01:02:13.540 --> 01:02:17.400
That's where a lot of the kernel level
networking stuff gets discussed if you

01:02:17.400 --> 01:02:19.650
really want to delve that deeply into it.

01:02:21.890 --> 01:02:24.350
So my roadmap,
well it's not really a roadmap

01:02:24.490 --> 01:02:27.920
because it refers to everything that
happened in the beginning of the week.

01:02:28.030 --> 01:02:30.380
But I put it up here just for anybody
who wants to reference the sessions

01:02:30.420 --> 01:02:31.660
once the DVDs finally come out.

01:02:31.890 --> 01:02:34.200
300 was the networking overview.

01:02:34.200 --> 01:02:37.160
You might recognize some of the
content from one or two of my

01:02:37.160 --> 01:02:39.190
slides from the 300 session.

01:02:39.200 --> 01:02:41.320
We kind of had the same things there.

01:02:41.640 --> 01:02:43.700
The extensible kernel
networking services,

01:02:43.760 --> 01:02:46.440
again that's going to be more
for people who are interested

01:02:46.440 --> 01:02:49.250
in the Darwin development stuff
and the kernel level stuff.

01:02:49.350 --> 01:02:53.010
Networking configuration mobility,
that's more user level network

01:02:53.020 --> 01:02:57.250
configuration as opposed to
programmatic network configuration.

01:02:57.730 --> 01:03:01.220
Network services location.

01:03:01.930 --> 01:03:03.070
I don't remember what that one was about.

01:03:03.090 --> 01:03:05.520
Oh, check it out on the DVD.

01:03:05.520 --> 01:03:06.120
Somebody let me know.

01:03:07.110 --> 01:03:12.650
And AFP is 3.0 and
Apple Share is just that.

01:03:12.720 --> 01:03:14.500
It's AFP on Mac OS X.
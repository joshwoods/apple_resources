WEBVTT

00:00:01.700 --> 00:00:04.450
Thank you, Tony.

00:00:04.530 --> 00:00:05.700
Thank you.

00:00:05.760 --> 00:00:07.550
Good morning.

00:00:07.620 --> 00:00:11.220
Welcome to session 609,
Developing Desktop Applications

00:00:11.220 --> 00:00:12.760
with WebObjects.

00:00:12.800 --> 00:00:14.910
I'm Ron Lue-Saang,
and I'm an engineer with

00:00:14.980 --> 00:00:16.700
the WebObjects group.

00:00:16.790 --> 00:00:20.310
So everyone that we've told,
come to session 609 and you'll find out

00:00:20.310 --> 00:00:22.810
about desktop applications with EOF.

00:00:22.810 --> 00:00:24.970
Now you're finally here.

00:00:24.970 --> 00:00:27.090
This is what you came for.

00:00:27.160 --> 00:00:29.020
So to start things off,

00:00:29.560 --> 00:00:33.780
I want to emphasize that WebObjects
offers incredibly powerful database

00:00:33.780 --> 00:00:36.630
connectivity for desktop applications.

00:00:36.720 --> 00:00:38.580
It's not just about web applications.

00:00:38.670 --> 00:00:46.330
We also offer incredibly powerful desktop
application connectivity to databases.

00:00:46.770 --> 00:00:50.320
To that, there are two architectures
that WebObjects supports.

00:00:50.360 --> 00:00:56.250
Two-tier architectures with Cocoa EOF,
where your Cocoa client talks

00:00:56.360 --> 00:00:58.270
directly to your database.

00:00:58.550 --> 00:01:02.050
We also offer three-tier
applications where,

00:01:02.180 --> 00:01:05.670
using Java Client or
direct-to-Java Client,

00:01:05.710 --> 00:01:10.350
your Swing-based application speaks
to a WebObjects application server,

00:01:10.370 --> 00:01:13.510
which in turn speaks to your database.

00:01:14.410 --> 00:01:19.300
So what you'll learn today,
I'll go over the architecture

00:01:19.300 --> 00:01:22.190
of Cocoa EOF and some of the
functionality that it provides.

00:01:22.190 --> 00:01:26.480
And then I'll ask Andreas Wendker
to come out and talk about

00:01:26.490 --> 00:01:29.370
Java Client and its architecture.

00:01:30.780 --> 00:01:33.410
So first, Cocoa EOF.

00:01:33.440 --> 00:01:36.580
This is kind of the overview of what

00:01:36.620 --> 00:01:39.040
layers Cocoa EOF has.

00:01:39.050 --> 00:01:43.840
Of course, there's Cocoa and EOF,
as the name implies.

00:01:43.870 --> 00:01:47.220
Cocoa, if you haven't heard,
is Apple's incredible technology.

00:01:47.280 --> 00:01:51.940
It's a set of object-oriented
advanced APIs for building

00:01:52.140 --> 00:01:55.180
Mac OS X native applications.

00:01:55.220 --> 00:01:59.760
And then, of course, there's EOF,
our Enterprise Objects Framework.

00:01:59.950 --> 00:02:04.130
And here I've set out
two special parts of EOF,

00:02:04.220 --> 00:02:07.000
first being the JDBC adapter.

00:02:07.270 --> 00:02:10.260
The JDBC adapter is what actually
connects to all of our databases.

00:02:10.300 --> 00:02:17.320
Any database for which we have the
appropriate JDBC version 2 driver,

00:02:17.430 --> 00:02:21.020
we can talk to that database using EOF.

00:02:21.660 --> 00:02:24.950
The other layer there
is EO Interface Cocoa,

00:02:24.950 --> 00:02:30.400
which actually bridges the
two worlds of EOF and Cocoa.

00:02:30.460 --> 00:02:34.010
So in a little more detail, first Cocoa.

00:02:35.200 --> 00:02:38.340
Cocoa and EOF work together.

00:02:38.340 --> 00:02:41.620
The Cocoa part provides
all the application logic.

00:02:41.680 --> 00:02:46.180
So everything that you get that you're
used to with a regular Cocoa application,

00:02:46.180 --> 00:02:48.010
you get in Cocoa EOF.

00:02:48.110 --> 00:02:51.540
This includes all of the cool
widgets that you're used to,

00:02:51.550 --> 00:02:55.050
all of the views, the windows, the menus,
the matrices,

00:02:55.050 --> 00:02:57.410
all the widgets that you're used to.

00:02:57.980 --> 00:03:01.270
And then, of course,
the responder chain that you're

00:03:01.390 --> 00:03:04.580
used to for receiving events,
the run loop for getting

00:03:04.630 --> 00:03:08.520
events from the user interface,
and we even support custom views.

00:03:08.520 --> 00:03:11.460
It's everything that you expect
from Cocoa as a Cocoa application.

00:03:15.360 --> 00:03:23.290
Now, how does data get from Cocoa and
into EOF and back and forth?

00:03:23.470 --> 00:03:30.200
The general idea of the data flow is,
let's say you've got an application

00:03:30.200 --> 00:03:33.950
that displays some values in a table.

00:03:34.420 --> 00:03:41.050
So if you edit the value in the table,
Cocoa will fire an event off to a class,

00:03:41.180 --> 00:03:43.330
an object, in EO Interface Cocoa.

00:03:43.340 --> 00:03:47.830
This object has already set
itself as the delegate for any

00:03:48.000 --> 00:03:50.360
edits in the user interface.

00:03:50.360 --> 00:03:53.000
So it gets the event.

00:03:53.060 --> 00:03:55.720
It realizes, oh, something has changed.

00:03:55.720 --> 00:03:57.340
I'll tell EOF about it.

00:03:57.360 --> 00:04:02.580
And the value is then set in the business
object in EOF where you can save it or

00:04:02.580 --> 00:04:05.360
something happens in your business logic.

00:04:05.360 --> 00:04:09.340
And maybe something changes because
of that one change from the UI.

00:04:09.360 --> 00:04:13.360
Well, EOF then says, something's changed.

00:04:13.360 --> 00:04:18.050
And EO Interface Cocoa gets that
event from EOF and then pushes the

00:04:18.080 --> 00:04:22.030
value back into the user interface,
setting the display value

00:04:22.040 --> 00:04:23.360
in Cocoa in your UI.

00:04:23.360 --> 00:04:27.300
So that's a pretty simple setup, right?

00:04:27.360 --> 00:04:31.220
You've got Cocoa, you've got EOF,
and you've got EO Interface

00:04:31.330 --> 00:04:33.690
Cocoa that bridges the two worlds.

00:04:34.940 --> 00:04:39.560
Speaking of bridges,
we do still use the Java bridge.

00:04:39.580 --> 00:04:43.240
If you're new to Cocoa development
or new to WebObjects,

00:04:43.240 --> 00:04:50.290
the bridge is a cool technology
developed by Apple for allowing your

00:04:50.300 --> 00:04:52.860
Java code to access Objective-C classes.

00:04:53.980 --> 00:04:57.920
In the Objective-C world of Cocoa,
where Cocoa is really

00:04:58.190 --> 00:05:03.380
implemented in Objective-C,
there's a wrapper of Java APIs so

00:05:03.380 --> 00:05:10.470
that you can actually use NSWindow,
NSApplication, all the NSFoundation and

00:05:10.660 --> 00:05:15.410
AppKit utilities classes in Java.

00:05:16.260 --> 00:05:22.500
So while Cocoa is available in
Java and implemented in Objective-C,

00:05:22.530 --> 00:05:24.710
EOF now is all Java.

00:05:24.810 --> 00:05:27.790
In WebObjects 5,
EOF is implemented in all Java,

00:05:27.850 --> 00:05:33.600
which is different from previous versions
where there was also a bridge for EOF.

00:05:34.420 --> 00:05:38.560
But now that we're pure Java,
all of your custom business logic

00:05:38.690 --> 00:05:41.590
must also be written in Java.

00:05:41.770 --> 00:05:44.370
This works out well for you
anyway since once you've written

00:05:44.370 --> 00:05:47.690
your business logic in Java,
you can use that business logic in

00:05:47.720 --> 00:05:50.010
any other WebObjects application.

00:05:50.100 --> 00:05:53.810
HTML-based applications,
Cocoa applications,

00:05:53.860 --> 00:05:57.250
or Java Client applications,
the same business logic can move

00:05:57.250 --> 00:05:59.290
between the three architectures.

00:06:00.170 --> 00:06:03.640
And as I said, your custom business logic
has to be written in Java,

00:06:03.680 --> 00:06:07.350
but your application logic,
everything that takes care

00:06:07.350 --> 00:06:10.760
of the Cocoa interaction
with the human interface,

00:06:10.820 --> 00:06:13.120
that can be written in
Java or Objective-C.

00:06:13.120 --> 00:06:14.240
You still have a choice there.

00:06:16.700 --> 00:06:24.090
Now, actually, so if you have worked with
Cocoa or WebObjects in the past,

00:06:24.160 --> 00:06:26.620
you may think, oh, no, not the bridge.

00:06:26.670 --> 00:06:31.190
The bridge has been kind of a
source of headaches in the past.

00:06:31.680 --> 00:06:33.300
We don't believe it's
much of an issue anymore.

00:06:33.300 --> 00:06:35.440
There's two main reasons for this.

00:06:35.440 --> 00:06:39.630
The first being it's been
rewritten for Mac OS X.

00:06:39.630 --> 00:06:42.720
It takes advantage of Java 2 on Mac OS X.

00:06:42.720 --> 00:06:44.540
It's much better.

00:06:44.540 --> 00:06:47.800
And the second,
most important thing is we

00:06:47.800 --> 00:06:49.890
hardly cross the bridge.

00:06:50.220 --> 00:06:54.420
Again, since we don't have to use
the bridge in every EOF call,

00:06:54.420 --> 00:06:58.060
and most of the calls that
actually go across the bridge

00:06:58.060 --> 00:07:02.400
are just in EO Interface Cocoa,
we don't use the bridge much at all.

00:07:02.440 --> 00:07:04.780
The two worlds of EOF and
Cocoa are pretty well separated,

00:07:04.800 --> 00:07:06.400
very well separated.

00:07:06.440 --> 00:07:09.250
So this works out well for
stability as well as performance,

00:07:09.250 --> 00:07:13.130
since you don't pay the hit
of morphing objects from the

00:07:13.130 --> 00:07:16.470
Java world to Objective-C and back.

00:07:16.480 --> 00:07:19.400
That doesn't happen
nearly as much anymore.

00:07:19.960 --> 00:07:23.500
But it is still there,
so you need to be aware of the

00:07:23.500 --> 00:07:26.860
different memory models between Java's,
of course,

00:07:26.860 --> 00:07:31.820
garbage collected memory model and the
Objective-C memory model where you have

00:07:31.820 --> 00:07:34.870
to explicitly retain or release objects.

00:07:35.740 --> 00:07:38.350
So what that means is you can
occasionally be using a pure

00:07:38.350 --> 00:07:44.530
Java object in your bridge Java method,
and the bridge will decide

00:07:44.560 --> 00:07:47.850
to forget about your object.

00:07:48.320 --> 00:07:52.490
Well, we offer some utilities,
two utility methods to help with that,

00:07:52.560 --> 00:07:56.950
to make sure that the bridge doesn't
automatically clear out your objects.

00:07:57.200 --> 00:08:03.170
RetainObject and ReleaseObject are
two methods in IOCocoa utilities.

00:08:03.600 --> 00:08:07.950
And Eococoa Utilities
lives in Eointerface Cocoa.

00:08:07.950 --> 00:08:11.590
These two methods help you do the
retain and release calls that you

00:08:11.590 --> 00:08:14.840
would normally do in Objective-C,
except you can do them

00:08:14.840 --> 00:08:16.610
on your Java objects now.

00:08:18.700 --> 00:08:23.740
So back to our original
graph of Cocoa and EOF.

00:08:23.820 --> 00:08:26.660
So there you have Cocoa,
two special parts of EOF,

00:08:26.790 --> 00:08:30.510
the JDBC adapter and EO Interface Cocoa.

00:08:30.600 --> 00:08:34.080
Well, of course,
EOF has more layers than just this.

00:08:34.460 --> 00:08:39.420
We also have EO Control, EO Access,
and EO Interface in there.

00:08:39.470 --> 00:08:41.680
And in a little more detail,
I'd like to go through

00:08:41.680 --> 00:08:45.430
exactly what it does,
what EOF is doing here.

00:08:46.110 --> 00:08:49.380
So the first layer there, EO Control.

00:08:49.440 --> 00:08:51.220
EO Control is really the core of EOF.

00:08:51.360 --> 00:08:55.100
It's what handles all
of your business logic.

00:08:55.100 --> 00:08:57.510
It's where your business logic lives.

00:08:57.850 --> 00:09:05.100
And as such, there's the editing context,
EO editing context, which handles,

00:09:05.100 --> 00:09:09.420
it holds all of your business
objects for EO control.

00:09:09.420 --> 00:09:13.390
And it maintains an object graph
of all of your business objects.

00:09:13.400 --> 00:09:16.350
So that means it can track
changes to the objects as well

00:09:16.410 --> 00:09:20.800
as relationships in the objects,
insert new objects, delete objects.

00:09:20.800 --> 00:09:24.760
All of the change tracking can
be handled in EO editing context.

00:09:25.660 --> 00:09:29.670
So that includes undo and
redo support and everything.

00:09:29.870 --> 00:09:33.760
And of course,
EO Control is also very performant.

00:09:33.770 --> 00:09:36.990
So we offer things like faulting,
which allows you to not fetch

00:09:37.210 --> 00:09:39.520
your entire database into your
application when you're not

00:09:39.530 --> 00:09:42.590
actually using all of those rows.

00:09:42.890 --> 00:09:46.800
So that's a little brief
overview of EO Control.

00:09:46.820 --> 00:09:49.330
We also have EO Access.

00:09:49.440 --> 00:09:52.650
EO Access is the part
of EOF that actually

00:09:52.810 --> 00:09:55.320
Connects to Data Sources.

00:09:55.320 --> 00:09:58.920
And it's built, as you saw,
on an adapter architecture

00:09:58.990 --> 00:10:01.970
where our default adapter,
the JDBC adapter,

00:10:02.000 --> 00:10:04.800
is what talks to databases
using JDBC2 drivers.

00:10:04.800 --> 00:10:08.830
But you can also slip in your
special adapter classes here,

00:10:08.830 --> 00:10:12.780
your special adapter layer,
to connect using JNDI to

00:10:12.780 --> 00:10:18.870
LDAP servers or XML adapters,
whatever custom data sources

00:10:18.890 --> 00:10:20.500
you can come up with.

00:10:21.630 --> 00:10:25.540
And the real functionality of EO access,
of course, is object relational mapping.

00:10:25.540 --> 00:10:30.970
So that means mapping all of the
relational rows in your data source

00:10:31.020 --> 00:10:34.550
to real objects in EO control.

00:10:34.800 --> 00:10:38.840
And that mapping between the
two is held in an EO model file,

00:10:38.840 --> 00:10:40.970
which you build with EO Modeler.

00:10:41.680 --> 00:10:46.160
Each EO model contains a
definition of all of the

00:10:46.160 --> 00:10:50.110
attributes of your business object,
as well as the mapping from your business

00:10:50.120 --> 00:10:56.510
object attributes to individual columns,
let's say, in your database.

00:10:59.460 --> 00:11:04.130
Another important layer
to EOF is EO Interface.

00:11:04.210 --> 00:11:07.390
All the classes in this layer are
responsible for actually displaying

00:11:07.390 --> 00:11:08.860
data in the user interface.

00:11:08.920 --> 00:11:15.780
This is where EO Display Group lives.

00:11:15.780 --> 00:11:15.780
EO Display Group

00:11:16.120 --> 00:11:16.880
You'll use most.

00:11:16.940 --> 00:11:20.440
It's our common gateway
to multiple data sources.

00:11:20.440 --> 00:11:25.740
It wraps an array of business objects
that it gets from its data source,

00:11:25.740 --> 00:11:27.400
which is typically an editing context.

00:11:27.400 --> 00:11:31.560
And it handles coordinating
updates of the user interface,

00:11:31.560 --> 00:11:34.630
getting the values from
the EOs it contains,

00:11:34.650 --> 00:11:37.840
and setting them in your Cocoa interface.

00:11:37.840 --> 00:11:45.320
Or actually, any widget interface,
Cocoa or Swing, as you'll see later.

00:11:49.720 --> 00:11:53.380
So EO Display Groups work
with EO Associations for

00:11:53.480 --> 00:11:58.020
updating the user interface,
keeping the user interface in sync

00:11:58.120 --> 00:12:00.470
with all of your business objects.

00:12:00.780 --> 00:12:05.120
EO Associations are the parts that
actually connect display groups

00:12:05.270 --> 00:12:07.460
to widgets in your user interface.

00:12:07.460 --> 00:12:10.430
So that means we've
got text associations,

00:12:10.430 --> 00:12:13.800
for example,
to display data in your databases

00:12:13.800 --> 00:12:19.250
that comes up as text or even dates,
numbers, so that things are formatted

00:12:19.250 --> 00:12:20.800
properly in the user interface.

00:12:21.060 --> 00:12:24.920
We also have other
associations for displaying,

00:12:24.990 --> 00:12:29.000
let's say,
images in NS Image Views or handling all

00:12:29.100 --> 00:12:32.240
the data in tables and table columns.

00:12:32.240 --> 00:12:37.100
So the associations really keep
the display group connected

00:12:37.120 --> 00:12:39.560
to your interface widgets.

00:12:39.580 --> 00:12:42.840
But there are also other
associations that can connect display

00:12:42.900 --> 00:12:44.820
groups to other display groups.

00:12:44.820 --> 00:12:50.780
As an example,
there are Master Detail Associations.

00:12:51.060 --> 00:12:57.520
Which can connect a master display
group in which you're fetching possibly

00:12:57.640 --> 00:13:00.530
all of the people in your database.

00:13:00.680 --> 00:13:05.380
And it connects that display
group to a detailed display group,

00:13:05.380 --> 00:13:09.490
which could be displaying all of
the addresses for those people.

00:13:09.650 --> 00:13:14.970
This means that once you've selected a
person in your persons display group,

00:13:15.630 --> 00:13:19.880
The association will automatically tell
the detail display group to display

00:13:19.880 --> 00:13:21.640
that person's address information.

00:13:21.640 --> 00:13:26.040
All of these are available
just in EO Interface.

00:13:26.040 --> 00:13:30.680
And don't let all of the
talk about Cocoa fool you.

00:13:30.680 --> 00:13:35.000
We also keep EO Interface very
separated from the details

00:13:35.000 --> 00:13:37.340
of any specific widget set.

00:13:37.360 --> 00:13:41.280
It's abstracted away from all
of the details using plugins.

00:13:42.140 --> 00:13:46.280
So you can actually use EO interface in,

00:13:46.500 --> 00:13:49.240
In Java Client applications
as well as Cocoa applications,

00:13:49.240 --> 00:13:52.280
it's widget set agnostic.

00:13:52.960 --> 00:13:55.210
So why all the layer talk, though?

00:13:55.400 --> 00:14:00.210
Well, as I said just now,
knowing that EO Interface doesn't

00:14:00.210 --> 00:14:05.320
depend on any specific widget set code,
doesn't depend on Cocoa, let's say,

00:14:05.320 --> 00:14:10.430
you know that when you code,
when you write code, write, let's say,

00:14:10.430 --> 00:14:13.250
new associations,
that you can use them any

00:14:13.250 --> 00:14:15.230
place EO Interface is used.

00:14:15.230 --> 00:14:20.730
So new associations can be used
in Java Client or Cocoa Client.

00:14:24.630 --> 00:14:27.000
So the plugins, though,
that do know about the

00:14:27.000 --> 00:14:31.350
widget set specific details
live in EO Interface Cocoa.

00:14:31.670 --> 00:14:37.450
All the plugins in this layer know
how to handle targets and actions and

00:14:37.450 --> 00:14:45.590
know how to connect up to become data
sources or delegates of certain widgets.

00:14:46.400 --> 00:14:52.000
They all handle certain specific tasks,
typically type morphing,

00:14:52.000 --> 00:14:59.230
so that an image association plugin
will know that NSData coming from

00:14:59.240 --> 00:15:05.690
EO interface can be displayed as
an NS image in an NS image view.

00:15:05.890 --> 00:15:10.410
And it knows how to do set and get,
so set object value and object

00:15:10.410 --> 00:15:12.790
value with Cocoa widgets.

00:15:12.800 --> 00:15:21.790
And it also, there are many plugins that
also handle events from Cocoa.

00:15:22.380 --> 00:15:28.250
So that they can register as delegates
for methods and as data sources.

00:15:30.030 --> 00:15:32.900
And of course, this plugin set is
extendable to other widgets.

00:15:32.900 --> 00:15:36.130
We know that you all have widgets
that you may like that aren't

00:15:36.290 --> 00:15:38.480
available with the default Cocoa set.

00:15:38.520 --> 00:15:44.420
So you can build your own NS views,
custom views, your own custom widgets,

00:15:44.470 --> 00:15:49.680
and create a plugin for it that you
can use in your Cocoa EOF applications.

00:15:53.010 --> 00:15:57.820
So how does everything,
how do all the layers interact when

00:15:57.820 --> 00:16:00.000
you're actually trying to do something?

00:16:00.000 --> 00:16:03.300
Let's take another example of

00:16:04.060 --> 00:16:07.560
trying to fetch objects
into the user interface.

00:16:07.610 --> 00:16:12.100
So a Cocoa widget,
I hope you can all read this actually,

00:16:12.100 --> 00:16:17.450
a Cocoa widget will fire off an
event to the plugin that's registered

00:16:17.550 --> 00:16:20.120
for it in EO Interface Cocoa.

00:16:20.560 --> 00:16:24.920
The plugin sees, oh,
something's changed and

00:16:25.220 --> 00:16:27.500
tells its association.

00:16:27.900 --> 00:16:30.530
The association, in turn,
makes sure that the display

00:16:30.570 --> 00:16:34.390
group qualifies for your fetch,
let's say.

00:16:35.320 --> 00:16:39.600
The display group then goes
and tells its editing context,

00:16:39.610 --> 00:16:45.260
gives it a new fetch specification,
and the editing context

00:16:45.290 --> 00:16:48.870
goes to its data source,
which is the database

00:16:48.870 --> 00:16:50.750
context in EO Access.

00:16:51.570 --> 00:17:02.310
EO Access will fetch any new objects
that it needs to and change that raw

00:17:02.310 --> 00:17:02.310
row data into full enterprise objects,
into your business objects.

00:17:02.890 --> 00:17:09.090
And then any subset that's related to the
fetch will be sent to the display group.

00:17:09.170 --> 00:17:12.400
So the display group now contains
a certain subset of the EOs in your

00:17:12.400 --> 00:17:15.240
editing context that it fetched for.

00:17:15.290 --> 00:17:17.550
The display group then, of course,
tells the association.

00:17:17.620 --> 00:17:22.150
New values have come
in and the association

00:17:22.460 --> 00:17:27.410
gets those values and hands them off to
the plugin that it's associated with.

00:17:27.890 --> 00:17:34.090
The plugin takes the value that it's
related to and knows how to do set

00:17:34.210 --> 00:17:39.160
and get methods in Cocoa to put the
values into your user interface.

00:17:39.160 --> 00:17:43.470
So it's a pretty simple chain
up and down the Cocoa EOF stack,

00:17:43.470 --> 00:17:46.200
with Cocoa at the top
and EOF at the bottom,

00:17:46.330 --> 00:17:49.940
and that thin layer of
EO interface Cocoa in the middle.

00:17:51.030 --> 00:17:54.880
So I'm going to ask Andreas Wendker
to come out and give a demo,

00:17:54.880 --> 00:17:59.380
show you exactly what
Cocoa EOF applications look like.

00:18:06.240 --> 00:18:08.460
- So here we've got a
pretty simple model.

00:18:08.460 --> 00:18:13.730
Maybe kind of hard to read back there,
but it's based around a person and

00:18:13.730 --> 00:18:16.820
some information about that person.

00:18:18.660 --> 00:18:21.140
So that's the model we're going
to use in our application.

00:18:21.180 --> 00:18:24.600
So we just go to Project Builder
and create a new project.

00:18:24.730 --> 00:18:28.070
One of the types that you can choose
here is Cocoa EOF Application.

00:18:28.070 --> 00:18:32.160
You go ahead and you do everything
you would with a normal project.

00:18:32.160 --> 00:18:35.170
You name it,
you choose a place for it to live.

00:18:35.490 --> 00:18:37.390
And then you add any
frameworks that you need.

00:18:37.430 --> 00:18:40.960
We're going to skip frameworks
and directly add a model.

00:18:44.780 --> 00:18:47.590
So the one we're going to choose,
the layout that we're going to

00:18:47.590 --> 00:18:50.390
choose is a master detail layout.

00:18:51.020 --> 00:18:53.880
All you do is you choose your main
entity and any attributes that

00:18:53.880 --> 00:18:55.350
you'd want to show in your tables.

00:18:55.350 --> 00:18:59.680
The master detail layout, by the way,
by default shows you a table for

00:18:59.810 --> 00:19:03.720
your master display group and another
table for your detail display group.

00:19:03.730 --> 00:19:09.120
You choose your master entity and your
detail entity and all the attributes

00:19:09.200 --> 00:19:11.790
you want to show in those tables.

00:19:14.560 --> 00:19:18.600
So we go ahead and we
build the project for you.

00:19:18.600 --> 00:19:23.080
And as you can see,
this is really just a Cocoa application

00:19:23.240 --> 00:19:24.380
with a few extra things in it.

00:19:24.460 --> 00:19:28.650
We've got our main.m,
we've got our main menu.nib,

00:19:28.660 --> 00:19:32.420
and actually we've added
a few other frameworks.

00:19:32.480 --> 00:19:36.600
We've added Java EO Cocoa,
as well as some of the standard EOF jars

00:19:36.600 --> 00:19:39.270
that you'll get with WebObjects 5.

00:19:39.280 --> 00:19:40.760
Oops.

00:19:40.760 --> 00:19:43.150
We've added our education model.

00:19:45.790 --> 00:19:49.460
And to show you the nib,
this is the nib that we build for you,

00:19:49.460 --> 00:19:54.530
that our assistant builds for you by
default using master detail template.

00:19:54.700 --> 00:20:00.260
We fill in all of the details
of putting in table names,

00:20:00.320 --> 00:20:05.220
table column names,
and labels for your forms.

00:20:05.660 --> 00:20:10.900
And of course give you the ability to do
some of the simplest things you would do.

00:20:10.980 --> 00:20:14.200
Add and remove objects,
fetch new objects,

00:20:14.200 --> 00:20:16.390
and save back to the database.

00:20:16.560 --> 00:20:19.150
You can tweak the nib and
add anything you want,

00:20:19.150 --> 00:20:20.620
edit it any way you want.

00:20:20.660 --> 00:20:23.300
It's really just a Cocoa nib.

00:20:23.340 --> 00:20:27.420
So you can see Andreas is here
just beautifying some of the names.

00:20:30.600 --> 00:20:43.800
[Transcript missing]

00:20:54.800 --> 00:20:57.990
So remember, we've written no code,
and then all of a sudden,

00:20:57.990 --> 00:21:02.110
we have a Cocoa application that can
talk to EOF and talk to our database,

00:21:02.240 --> 00:21:05.190
browsing live data in our database.

00:21:06.490 --> 00:21:12.430
Editing values, saving values,
the whole nine yards

00:21:12.490 --> 00:21:14.910
without any code so far.

00:21:24.730 --> 00:21:26.850
- But of course,
you're probably not gonna just sit there

00:21:26.850 --> 00:21:29.340
and use our Assistant-built application.

00:21:29.420 --> 00:21:31.080
You can add stuff.

00:21:31.140 --> 00:21:34.520
You can add even other display
groups that we may have missed

00:21:34.670 --> 00:21:36.820
from building it in our Assistant.

00:21:36.930 --> 00:21:41.400
So you can simply drag a new
display group from EOModeler.

00:21:41.930 --> 00:21:45.060
and wire it up in Interface Builder.

00:21:45.090 --> 00:21:48.260
This is another one of the
beautiful things that we can do

00:21:48.320 --> 00:21:51.050
with WebObjects that we've added.

00:21:51.660 --> 00:21:55.100
The functionality that we've
added to Interface Builder,

00:21:55.190 --> 00:21:58.630
being able to connect these
display groups to the widgets.

00:22:00.510 --> 00:22:05.620
So we can choose a pop-up and
connect it to person type.

00:22:05.680 --> 00:22:11.480
So we can now choose from a pop-up
list what type of person we're editing.

00:22:11.480 --> 00:22:14.130
So we can edit the person.

00:22:15.340 --> 00:22:19.640
And as you can see,
you can actually traverse relationships,

00:22:19.640 --> 00:22:22.170
so person to person type.

00:22:23.770 --> 00:22:26.740
And notice that
Andreas hasn't recompiled.

00:22:26.780 --> 00:22:30.440
You may be aware of the test interface
functionality of Interface Builder.

00:22:30.480 --> 00:22:33.240
Well,
you can still use that with Cocoa EOF.

00:22:33.240 --> 00:22:40.590
No more recompiling, simply run it,
right?

00:22:47.600 --> 00:22:49.590
Back to the slides.

00:22:49.680 --> 00:22:51.660
So I'll hand it off to Andreas now,
and he'll talk a little

00:22:51.660 --> 00:22:53.350
bit about Java Client.

00:22:53.360 --> 00:22:54.540
Thanks, Andreas.

00:22:54.540 --> 00:22:56.490
ANDREAS WENKER: Thank you, Ron.

00:23:02.410 --> 00:23:05.130
So my name is Andreas Wendker,
and I'm the manager of the

00:23:05.130 --> 00:23:06.840
WebObjects rapid development team.

00:23:06.840 --> 00:23:09.540
And I'm going to use the rest
of the session to introduce you

00:23:09.540 --> 00:23:11.990
to our Java client technology.

00:23:12.310 --> 00:23:16.220
So Java Client is another technology
inside WebObjects you can use

00:23:16.260 --> 00:23:18.500
to develop desktop applications.

00:23:18.510 --> 00:23:21.200
It has a lot of things in
common with Cocoa and EUF,

00:23:21.220 --> 00:23:23.370
but there are also a
couple of differences.

00:23:23.420 --> 00:23:27.900
One of these differences is that
Java Client is implemented in pure Java.

00:23:27.960 --> 00:23:31.240
For the user interface,
we use the Java Foundation Classes,

00:23:31.240 --> 00:23:34.950
or Swing, and that basically makes
Java Client platform independent

00:23:34.990 --> 00:23:39.880
in the sense that it runs on all
platforms that support JDK 1.3.

00:23:40.180 --> 00:23:42.800
The other important difference
between Java Client and

00:23:42.800 --> 00:23:45.500
Cocoa EUF is that Java Client
uses a three-tier architecture,

00:23:45.500 --> 00:23:46.840
not a two-tier architecture.

00:23:46.840 --> 00:23:50.060
So we have a client that
displays the user interface

00:23:50.060 --> 00:23:52.080
and interacts with the user.

00:23:52.080 --> 00:23:54.270
We have a server that
accesses the database,

00:23:54.270 --> 00:23:56.610
and we have a database
that stores the data.

00:23:56.620 --> 00:23:59.210
Now,
it's important to know that the client

00:23:59.210 --> 00:24:01.680
never directly accesses the database.

00:24:01.680 --> 00:24:04.400
All the database access
goes through the server,

00:24:04.400 --> 00:24:07.700
so the server has full control
over what the client can do with

00:24:07.700 --> 00:24:09.780
the database and what it can't do.

00:24:10.100 --> 00:24:13.110
The other thing interesting
about Java Client is that it

00:24:13.170 --> 00:24:17.050
uses HTTP as the communication
protocol between client and server.

00:24:17.060 --> 00:24:22.280
So you basically get the connectivity of
an HTML application running in a browser.

00:24:22.280 --> 00:24:25.720
You can access the server
from anywhere in the world,

00:24:25.720 --> 00:24:28.560
but you get a much richer user interface.

00:24:30.390 --> 00:24:33.280
Let's take a look at what we have
to do with the architecture to

00:24:33.280 --> 00:24:34.550
make this work with Java Client.

00:24:34.560 --> 00:24:38.560
You already know that instead of Cocoa,
we use Java Client.

00:24:38.580 --> 00:24:43.420
Out with Cocoa, and in, sorry,
I said we use Swing.

00:24:43.440 --> 00:24:44.460
In with Swing.

00:24:44.480 --> 00:24:49.710
Using Swing also means that we
need to use a new plugin layer.

00:24:49.720 --> 00:24:53.200
We have this plugin layer that
connects the Interface layer and Cocoa,

00:24:53.200 --> 00:24:55.650
and we have a new plugin
layer that connects the

00:24:55.650 --> 00:24:57.480
Interface layer and JFC Swing.

00:24:57.480 --> 00:24:59.280
This new layer is called
EU Interface Swing.

00:25:00.760 --> 00:25:04.310
I also mentioned that we don't
access the database directly anymore.

00:25:04.320 --> 00:25:07.570
So we don't use EU access
into the JDBC adapter.

00:25:07.570 --> 00:25:10.660
Instead, we use a layer that we call
EU distribution that takes care

00:25:10.660 --> 00:25:11.730
of connecting to the server.

00:25:11.730 --> 00:25:16.570
Also, for your convenience,
we added another layer.

00:25:17.740 --> 00:25:19.400
It's called EU Application.

00:25:19.400 --> 00:25:21.760
I'll talk more about it in a minute.

00:25:21.820 --> 00:25:25.640
Something you should notice is that the
EU Control and the EU Interface layer

00:25:25.640 --> 00:25:27.700
stay the same in both architectures.

00:25:27.700 --> 00:25:30.900
Code that you write against the
EU Interface or the EU Control layer,

00:25:30.900 --> 00:25:35.870
that mostly means your business logic,
can be used in both architectures.

00:25:37.210 --> 00:25:39.600
Now let's take a look at these new
layers in a little more detail.

00:25:39.610 --> 00:25:43.830
The EU application layer exists
because Swing doesn't offer us all

00:25:43.930 --> 00:25:46.340
the functionality that Cocoa gives us.

00:25:46.340 --> 00:25:49.680
Swing is a relatively plain widget set.

00:25:49.680 --> 00:25:52.430
It has a lot of user interface
elements like text fields,

00:25:52.430 --> 00:25:55.260
buttons, windows,
but it doesn't help you a lot

00:25:55.260 --> 00:25:58.700
with higher level tasks like
simply starting your application.

00:25:58.700 --> 00:26:02.470
Or tasks like implementing
a document management,

00:26:02.470 --> 00:26:06.310
maybe managing user defaults,
or handling menus.

00:26:07.100 --> 00:26:10.700
We created the application layer
to help you out with these tasks.

00:26:10.700 --> 00:26:14.720
It's a layer that provides you a
lot of utilities that you can use

00:26:14.740 --> 00:26:16.970
to manage your user interface.

00:26:17.530 --> 00:26:21.400
And another very important feature of
the application layer is that we added

00:26:21.400 --> 00:26:25.900
the ability to load interface files
that you created in Interface Builder.

00:26:25.920 --> 00:26:30.000
That's actually pretty cool because you
can use the same tool to create user

00:26:30.000 --> 00:26:34.290
interfaces for both Cocoa applications
as well as Java Client applications.

00:26:34.300 --> 00:26:37.510
There's just a little problem
with that because out of the box,

00:26:37.510 --> 00:26:40.590
Interface Builder doesn't allow
you to edit Swing lib files,

00:26:40.620 --> 00:26:41.290
right?

00:26:41.300 --> 00:26:43.480
You can only edit
Cocoa or Carbon lib files.

00:26:43.480 --> 00:26:45.590
So how do we deal with that?

00:26:45.800 --> 00:26:50.120
Well, we ordered an extension that
translates a Cocoa interface

00:26:50.120 --> 00:26:53.140
file into a Swing interface file,
right?

00:26:53.140 --> 00:26:55.760
You don't really see this translation.

00:26:55.760 --> 00:26:58.240
It just happens for you
whenever you save your lib file.

00:26:58.240 --> 00:27:01.060
But what it means is that you
can create the interface in

00:27:01.060 --> 00:27:04.680
Interface Builder and then use it
in the Java Client application.

00:27:04.680 --> 00:27:06.600
And we will show you how that looks.

00:27:08.590 --> 00:27:10.940
Now let's talk about
the distribution layer.

00:27:10.970 --> 00:27:15.290
The distribution layer replaces the
EU access layer as the data access layer.

00:27:15.420 --> 00:27:21.380
So clients fetch business objects,
not from the database, but they fetch the

00:27:21.520 --> 00:27:23.000
objects from the server.

00:27:23.000 --> 00:27:25.460
And if they have changes
that they want to save,

00:27:25.510 --> 00:27:28.210
they also save the changes
through the server.

00:27:28.480 --> 00:27:30.580
And on top of exchanging
business objects,

00:27:30.650 --> 00:27:33.320
the distribution layer gives
you a convenient API to do

00:27:33.320 --> 00:27:34.560
remote method invocations.

00:27:34.560 --> 00:27:38.360
So if you have something that you
need for your client application to

00:27:38.360 --> 00:27:41.620
deal with some kind of resources or so
that is independent of business logic,

00:27:41.670 --> 00:27:46.190
the distribution layer has an API that
you can use to contact the server.

00:27:47.600 --> 00:27:52.200
So the complete picture
then looks like that.

00:27:52.250 --> 00:27:57.500
So there are a lot of boxes,
but the important piece is that we

00:27:57.690 --> 00:28:03.470
basically pushed the EU Access layer
and the JDBC adapter to the server side.

00:28:03.850 --> 00:28:07.640
And the server is actually a pretty
normal WebObjects application.

00:28:07.650 --> 00:28:10.160
We use eVaccess and JDBC adapter
to access the database.

00:28:10.200 --> 00:28:12.780
We have eO-Control to
manage business logic.

00:28:12.790 --> 00:28:15.680
We have WebObjects to deal
with things like sessions.

00:28:15.720 --> 00:28:18.690
And we also have a server-side
component for the distribution layer,

00:28:18.710 --> 00:28:21.030
which plugs into WebObjects
and makes sure the Java client

00:28:21.030 --> 00:28:23.060
works fine with WebObjects.

00:28:24.870 --> 00:28:28.360
Something that is very interesting
about our distribution layer is

00:28:28.380 --> 00:28:32.280
that it uses a copy distribution
mechanism for business objects.

00:28:32.280 --> 00:28:36.340
That's very different from what most
other technologies for three-tier use.

00:28:36.340 --> 00:28:39.390
Most other technologies use
some kind of a client stub.

00:28:39.400 --> 00:28:43.150
What that means is that the client
business object is just some kind

00:28:43.150 --> 00:28:46.040
of an extension to the object
that really lives on the server,

00:28:46.040 --> 00:28:49.110
and the client has to ask the
server for every little detail.

00:28:49.120 --> 00:28:51.360
So there's a lot of
communication going on.

00:28:51.360 --> 00:28:54.990
In our distribution layer,
business objects are actually

00:28:54.990 --> 00:28:58.160
copied when they are fetched
from the server to the client,

00:28:58.160 --> 00:29:01.440
and they live as fully functional
objects on the client side.

00:29:03.950 --> 00:29:08.580
I think a good way to think
about Java Client is that editing

00:29:08.580 --> 00:29:12.570
contexts on the client side behave
like a nested editing context

00:29:12.570 --> 00:29:15.650
to an editing context living in
the session on your server side.

00:29:15.650 --> 00:29:16.950
What does that mean?

00:29:17.000 --> 00:29:20.300
Well,
those of you familiar with EOF probably

00:29:20.330 --> 00:29:24.020
know that an EO editing context,
which I, by the way,

00:29:24.040 --> 00:29:27.170
abbreviated with EC in this diagram,
is just a special form

00:29:27.170 --> 00:29:28.660
of an object store.

00:29:28.660 --> 00:29:31.420
An object stores have parents.

00:29:31.420 --> 00:29:34.330
The parent object store is
the object that is really

00:29:34.330 --> 00:29:36.470
responsible for providing data.

00:29:36.860 --> 00:29:39.320
In the normal case,
if you're just on the server,

00:29:39.320 --> 00:29:43.170
if you write an HTML-based application,
the parent object stuff in editing

00:29:43.170 --> 00:29:46.780
context is a database context,
abbreviated DC in this diagram.

00:29:49.300 --> 00:29:53.120
With Java Client,
we introduced a new type of object store,

00:29:53.120 --> 00:29:55.220
which is called the
Distributed Object Store,

00:29:55.250 --> 00:29:55.680
DOS.

00:29:55.680 --> 00:29:59.040
The Distributed Object Store lives
on the client side,

00:29:59.050 --> 00:30:03.530
and its task is to connect the editing
contexts on your client side to the

00:30:03.530 --> 00:30:06.190
editing contexts on your server side.

00:30:07.250 --> 00:30:11.530
So as you can see from this diagram,
the only way for your business objects

00:30:11.560 --> 00:30:15.990
or your business data to get from the
client into the database is through

00:30:15.990 --> 00:30:17.710
the editing context on the server side.

00:30:17.720 --> 00:30:19.720
And that's where you
have all the control.

00:30:19.740 --> 00:30:23.390
So you can control exactly
what goes to the database.

00:30:25.070 --> 00:30:27.070
Let's take another look at
this diagram just quickly.

00:30:27.080 --> 00:30:29.920
I want to point out again that the
control layer that's really important is

00:30:29.920 --> 00:30:33.120
used on both sides of the architecture.

00:30:35.830 --> 00:30:39.600
Now with Java Client,
you have the choice to either

00:30:39.600 --> 00:30:43.440
use the same identical business
logic on both client and server,

00:30:43.440 --> 00:30:46.690
or you can use what we call
petition business logic.

00:30:46.740 --> 00:30:51.190
Petition business logic means that the
implementation of your business logic,

00:30:51.220 --> 00:30:54.890
of your business objects on
client and server is different.

00:30:54.900 --> 00:30:57.840
And it can be different in two ways.

00:30:58.060 --> 00:31:02.500
You can limit the visibility
of properties to the server so

00:31:02.500 --> 00:31:06.400
that you don't even send to the
client what you don't want to see.

00:31:06.460 --> 00:31:09.730
And also you can use
different implementations

00:31:09.730 --> 00:31:11.960
for the two business objects.

00:31:12.000 --> 00:31:16.440
So you can actually force the client to
make roundtrips to the server and use

00:31:16.440 --> 00:31:18.990
an implementation it provides there.

00:31:19.690 --> 00:31:22.100
That adds a lot of value
to your application,

00:31:22.120 --> 00:31:25.300
and it adds value in two areas,
in the area of security and

00:31:25.300 --> 00:31:27.040
in the area of performance.

00:31:27.040 --> 00:31:30.200
I think the area of security
is pretty obvious because you

00:31:30.210 --> 00:31:32.980
don't send any data to the client
that you don't want it to see,

00:31:32.980 --> 00:31:35.790
and you don't even send compiled
code to the client that you

00:31:35.790 --> 00:31:37.160
don't want it to know about.

00:31:37.270 --> 00:31:40.380
Because since we use Java,
you will know that the code can

00:31:40.390 --> 00:31:42.870
actually be pretty easily decompiled.

00:31:42.880 --> 00:31:45.900
So if you have code that you
consider secure or secret,

00:31:45.910 --> 00:31:48.360
and you don't want to
send it to the client,

00:31:48.770 --> 00:31:51.340
But then you can keep it
on the server and force the

00:31:51.340 --> 00:31:53.320
client to invoke the head code.

00:31:54.230 --> 00:31:58.210
The other area is performance.

00:31:58.240 --> 00:32:01.070
Business Project Petitioning helps
you with performance because if

00:32:01.140 --> 00:32:05.260
you have the great server with 500
processors and lots of gigahertz,

00:32:05.300 --> 00:32:10.220
then you can make your clients use the
high computing power of your server.

00:32:10.710 --> 00:32:12.760
Today, that probably doesn't matter
that much anymore because

00:32:12.760 --> 00:32:14.200
most clients are fast enough.

00:32:14.200 --> 00:32:17.350
But more importantly,
you can use business logic to avoid

00:32:17.350 --> 00:32:20.400
that too much data is transferred
between client and server.

00:32:20.400 --> 00:32:24.470
You can minimize the amount of
communication between client

00:32:25.200 --> 00:32:28.290
So if you have an algorithm,
some kind of computation that

00:32:28.290 --> 00:32:31.350
requires you to look at a lot of data,
but you don't really want to

00:32:31.350 --> 00:32:34.300
display that data on the client,
you just want to display the entries out,

00:32:34.300 --> 00:32:38.320
then the right thing to do is to
execute that computation on the server,

00:32:38.340 --> 00:32:42.390
fetch the objects that you need for
the computation only on the server,

00:32:42.390 --> 00:32:46.050
and then just send the entries out,
which is much smaller.

00:32:51.080 --> 00:32:55.320
With Java Client,
you have two different options to deploy.

00:32:55.370 --> 00:32:57.630
You can deploy the
client as an application,

00:32:57.630 --> 00:33:00.340
as a full desktop application
with an icon that you can

00:33:00.340 --> 00:33:04.150
double-click on the desktop,
or you can deploy as an applet embedded

00:33:04.150 --> 00:33:06.590
in some HTML running inside a browser.

00:33:06.610 --> 00:33:10.510
I would like to take a moment and
compare these two options for you.

00:33:12.020 --> 00:33:15.660
The most compelling advantage of
the applet is the simplicity of the

00:33:15.660 --> 00:33:19.960
installation process because there
is basically no installation process.

00:33:20.300 --> 00:33:23.170
When applets start,
they download all the classes that

00:33:23.180 --> 00:33:27.440
they need to execute the program
from the server side and then execute

00:33:27.440 --> 00:33:29.560
the program inside the browser.

00:33:29.610 --> 00:33:32.840
With applications,
you have to install a start program on

00:33:32.870 --> 00:33:37.340
the client machine and all the classes
that you need to execute the client.

00:33:37.390 --> 00:33:43.100
So you have to give your end users
some kind of an installer that just

00:33:43.230 --> 00:33:46.750
puts the application on the desktop.

00:33:48.060 --> 00:33:50.900
Now,
if you want to upgrade your application,

00:33:50.900 --> 00:33:52.200
you get into a lot of trouble.

00:33:52.200 --> 00:33:55.240
So if you have some bug fixes,
you get in a lot of trouble with

00:33:55.270 --> 00:33:57.780
desktop applications because now
you have to make sure that all your

00:33:57.860 --> 00:33:59.170
clients install the new version.

00:33:59.170 --> 00:34:01.670
With Applets,
that's so much easier because you

00:34:01.670 --> 00:34:03.060
just upgrade it on the server.

00:34:03.060 --> 00:34:07.050
The next time the client launches,
the new classes are downloaded and

00:34:07.060 --> 00:34:09.590
the client has automatically updated.

00:34:10.660 --> 00:34:13.560
Nevertheless,
applications score much higher

00:34:13.560 --> 00:34:15.560
in the area of user experience.

00:34:15.560 --> 00:34:20.140
It's just so much nicer for users to
start an application from the desktop,

00:34:20.210 --> 00:34:24.490
to not have to wait 30 seconds until
all the classes are downloaded,

00:34:24.550 --> 00:34:27.100
and to have an application
that is actually fully embedded

00:34:27.240 --> 00:34:28.860
in your desktop environment.

00:34:28.860 --> 00:34:33.530
Applications you can hide,
you can minimize windows,

00:34:33.570 --> 00:34:37.220
you have access to service menus,
et cetera.

00:34:37.220 --> 00:34:37.220
You don't have that with Appless.

00:34:39.700 --> 00:34:43.890
You will also find that applications
perform a little better than applets,

00:34:43.950 --> 00:34:47.690
and the reason is that
they are very isolated.

00:34:47.770 --> 00:34:51.240
Applications run as standalone processes,
while applets,

00:34:51.240 --> 00:34:56.170
all the applets running in one browser,
share the VM, the other code.

00:34:56.190 --> 00:35:03.080
That can have all kinds of
negative side effects on both

00:35:03.080 --> 00:35:03.080
performance as well as stability.

00:35:04.500 --> 00:35:08.540
From your perspective as the developer,
applications also have the

00:35:08.540 --> 00:35:11.670
advantage that you don't have to
deal with security restrictions.

00:35:11.720 --> 00:35:14.170
In Applets,
there's a security manager installed

00:35:14.230 --> 00:35:16.500
which prevents the application,
the program,

00:35:16.540 --> 00:35:22.970
from accessing your file system,
from accessing certain system parameters.

00:35:23.070 --> 00:35:24.810
You don't have to deal with
that in an application.

00:35:24.820 --> 00:35:27.780
So if you have the need to store
something in the file system,

00:35:27.820 --> 00:35:30.950
it's much easier for you to
do that as an application.

00:35:31.310 --> 00:35:33.040
But the users might see
that a little different.

00:35:33.040 --> 00:35:35.080
That's why I've got a little
dot here in this diagram.

00:35:35.080 --> 00:35:38.340
From the user's perspective,
applets are usually

00:35:38.340 --> 00:35:40.150
executed as untrusted code.

00:35:40.160 --> 00:35:45.480
And the Java VM ensures that the
program can't mess with the computer.

00:35:45.480 --> 00:35:47.900
So users might see that a
little different than you.

00:35:47.900 --> 00:35:51.750
But we think that in the environments
where you install Java Client,

00:35:51.770 --> 00:35:55.630
where you use Java Client applications,
which is mostly intranet,

00:35:55.630 --> 00:35:58.960
it probably doesn't matter so
much because your user should

00:35:59.110 --> 00:36:01.020
trust the system administrator.

00:36:01.200 --> 00:36:04.220
that the software is a good software.

00:36:04.900 --> 00:36:07.850
Another advantage that might come in
handy with applications is that you have

00:36:07.990 --> 00:36:10.670
full control over all the VM parameters.

00:36:10.710 --> 00:36:12.900
Let's say you need a
very large heap size.

00:36:12.900 --> 00:36:15.420
You can adjust the heap size with
an application because you have

00:36:15.440 --> 00:36:17.260
control over the start program.

00:36:17.270 --> 00:36:19.130
You can't in applets.

00:36:20.510 --> 00:36:24.780
So now I would like to ask
Ron to come out and give you

00:36:24.780 --> 00:36:27.600
a demo of our Java client.

00:36:29.680 --> 00:36:33.040
We are basically going to create the same
application that we created with Cocoa,

00:36:33.040 --> 00:36:34.200
the Java Client.

00:36:34.200 --> 00:36:36.980
So we go into Project Builder,
we create a new project,

00:36:36.980 --> 00:36:42.970
choose a different kind of project type,
give it a different name.

00:36:44.330 --> 00:36:45.430
Then we add some frameworks.

00:36:45.460 --> 00:36:47.290
This time we actually do add a framework.

00:36:47.290 --> 00:36:49.100
It's called Java Client Class Loader.

00:36:49.100 --> 00:36:50.600
It's just for the demo purposes.

00:36:50.640 --> 00:36:52.300
It's not part of WebObjects 5.

00:36:52.300 --> 00:36:54.850
It just makes our demos here really easy.

00:36:54.850 --> 00:36:57.860
So we choose the same model.

00:37:00.600 --> 00:37:02.140
Thank you for your time.

00:37:02.140 --> 00:37:03.680
I hope you did for Cocoa.

00:37:03.680 --> 00:37:06.270
And then there's something interesting.

00:37:06.270 --> 00:37:08.300
This is different than in Cocoa.

00:37:08.300 --> 00:37:11.640
It asks us for a so-called
interface controller class.

00:37:11.710 --> 00:37:16.240
The interface controller class is a class
that we generate in the Assistant and

00:37:16.320 --> 00:37:20.760
it's a very convenient class for you
that helps you to manage user interfaces

00:37:20.760 --> 00:37:23.280
and to especially load interface files.

00:37:23.280 --> 00:37:27.350
So the Assistant creates,
for every interface file that you create,

00:37:27.350 --> 00:37:27.350
you also create an
interface controller class.

00:37:27.460 --> 00:37:28.700
Now we will do the same thing.

00:37:28.700 --> 00:37:30.590
The rest of the system
is basically the same.

00:37:30.600 --> 00:37:34.000
We choose the master detail layout.

00:37:34.030 --> 00:37:36.670
Choose person as the main entity.

00:37:40.400 --> 00:37:45.710
Last name, first name, person type,
table.

00:37:47.750 --> 00:37:50.170
Last name and first name
for the form attributes.

00:37:50.170 --> 00:37:56.300
We choose addresses as the
relationship we want to display.

00:37:56.300 --> 00:37:59.940
And we pick a few attributes that
we want to display in the table

00:37:59.940 --> 00:38:02.840
for the addresses and in the form.

00:38:09.500 --> 00:38:10.500
And that's it.

00:38:10.500 --> 00:38:17.100
So this project now looks a little more
complicated than the one for Cocoa.

00:38:17.100 --> 00:38:19.660
The reason is that now we have
a full WebObjects application.

00:38:19.660 --> 00:38:23.560
So we have all the components that,
you know, we are familiar with

00:38:23.560 --> 00:38:24.850
from the server side.

00:38:24.880 --> 00:38:28.920
And actually, projects with WebObjects
have two different targets.

00:38:28.920 --> 00:38:32.920
One is the application server target,
the other one is the web server target.

00:38:32.920 --> 00:38:36.140
The application server target
contains all the objects and resources

00:38:36.140 --> 00:38:39.400
that you need on the server side,
the web server target,

00:38:39.400 --> 00:38:41.210
the ones for the client side.

00:38:41.230 --> 00:38:43.580
And these little donuts
here on the left side,

00:38:43.580 --> 00:38:47.100
they basically show you to
which target a file belongs.

00:38:47.100 --> 00:38:48.790
So as you can see,
we have a normal application,

00:38:48.870 --> 00:38:51.820
we have an application class,
a session class, a direct action class.

00:38:51.820 --> 00:38:55.510
And if you look inside
the main.vod for a second,

00:38:55.510 --> 00:38:55.510
you can see that

00:38:56.310 --> 00:39:00.760
We can see that we use a VoJava
Client Applet and we specify the

00:39:00.760 --> 00:39:03.890
interface controller class name here,
which is the interface we want to load.

00:39:03.900 --> 00:39:08.200
So this is our connection
from Java Client,

00:39:08.200 --> 00:39:10.600
from the client side, into the server,
that we use a special

00:39:10.610 --> 00:39:12.030
class VoJava Client Applet.

00:39:12.040 --> 00:39:14.300
Now let's take a look at the client side.

00:39:16.900 --> 00:39:17.890
- So there are two files.

00:39:17.980 --> 00:39:20.660
There's the code,
the Java Client Interface

00:39:20.660 --> 00:39:24.180
controller class,
and there's the interface file,

00:39:24.190 --> 00:39:26.370
why don't we open that in ID.

00:39:28.000 --> 00:39:31.340
So it's basically the same interface
file that we had for Cocoa,

00:39:31.340 --> 00:39:34.170
and Ron is going to beautify it again.

00:39:39.900 --> 00:39:43.140
- So we give the vendor a better title.

00:39:43.140 --> 00:39:47.450
We modify a few of the labels.

00:40:00.400 --> 00:40:02.400
That's all I have to do.

00:40:02.400 --> 00:40:03.400
Be safe.

00:40:03.400 --> 00:40:09.290
Now we go back to Project Builder
and actually compile it.

00:40:10.010 --> 00:40:13.870
This will take a little longer than with
Cocoa because now we have a client and

00:40:13.870 --> 00:40:16.460
a server side that needs to be compiled.

00:40:30.990 --> 00:40:34.660
Okay, and Ron is now starting the
server side of the application.

00:40:34.660 --> 00:40:37.740
The nice thing about this little
framework that we added is

00:40:37.740 --> 00:40:41.010
that it hard codes some of the
port numbers we want to use,

00:40:41.010 --> 00:40:43.890
and it allows us to use a little
start program that we wrote,

00:40:43.890 --> 00:40:47.700
which is our Java Client Launcher,
and then we can just enter the URL,

00:40:47.700 --> 00:40:50.530
and it happens to be the right one,
and now our client

00:40:50.530 --> 00:40:52.130
connects to the server.

00:41:00.320 --> 00:41:01.720
And this is the client application.

00:41:01.720 --> 00:41:03.120
So as you can see,
it looks pretty similar

00:41:03.180 --> 00:41:05.070
to what we had with Cocoa.

00:41:05.080 --> 00:41:10.520
We have a table, we can enter values,
we can change values.

00:41:10.520 --> 00:41:12.650
It just behaves the same way.

00:41:15.600 --> 00:41:17.300
and all that without writing code.

00:41:17.300 --> 00:41:22.190
Okay, we want to show you,

00:41:25.480 --> 00:41:29.400
If you want to just
show you something else.

00:41:29.400 --> 00:41:33.120
In earlier releases of WebObjects,
the slip-fetch installation

00:41:33.430 --> 00:41:36.590
had a bunch of problems.

00:41:37.200 --> 00:41:41.190
It's still a little problematic because
there are these two different worlds,

00:41:41.200 --> 00:41:44.140
Cocoa and Swing,
and they don't always match exactly.

00:41:44.140 --> 00:41:47.910
But we think that Interface Builder
is really the greatest tool on the

00:41:47.910 --> 00:41:50.040
planet to create user interfaces.

00:41:50.040 --> 00:41:53.960
And it's especially the only tool
that allows us to set up connections.

00:41:53.960 --> 00:41:56.640
And in UAF, we really need connections.

00:41:56.640 --> 00:41:58.100
We need to set up all these associations.

00:41:58.120 --> 00:42:02.290
So Interface Builder is really the best
choice for us to generate interfaces.

00:42:03.160 --> 00:42:08.490
And with WebObjects 5,
you try to fix all the bugs and...

00:42:08.600 --> 00:42:12.490
We would like to show that to you
by just overlaying the interface

00:42:12.590 --> 00:42:16.040
file and the running application,
and then minimizing the

00:42:16.040 --> 00:42:17.480
window in the interface files.

00:42:17.480 --> 00:42:19.470
As you can see--

00:42:26.600 --> 00:42:27.940
As you can see, it maps pretty well.

00:42:27.940 --> 00:42:32.330
There are a few differences,
just maybe Swing draws the text one pixel

00:42:32.360 --> 00:42:34.610
higher in a button than Cocoa does or so.

00:42:34.670 --> 00:42:36.620
But basically,
if you overlay the two Nib files,

00:42:36.620 --> 00:42:39.960
it looks pretty much the same.

00:42:39.960 --> 00:42:41.820
OK.

00:42:41.860 --> 00:42:44.130
Can we go back to the slides, please?

00:42:49.320 --> 00:42:53.730
With Java Client,
we also have a technology we

00:42:53.850 --> 00:42:55.740
call Direct-to-Java Client.

00:42:55.740 --> 00:42:58.920
Direct-to-Java Client
is an infrastructure

00:42:59.200 --> 00:43:02.720
that helps you developing
Java Client applications

00:43:02.770 --> 00:43:05.390
very easily and very rapidly.

00:43:05.410 --> 00:43:08.600
It does so by providing you with
a lot of predefined application

00:43:08.600 --> 00:43:11.550
functionality that you can make use of.

00:43:11.660 --> 00:43:16.940
And it relieves you from the burden
to create user interfaces by hand.

00:43:16.970 --> 00:43:20.920
Instead, it actually generates the user
interfaces dynamically for you.

00:43:20.920 --> 00:43:25.010
And it does that by analyzing the
EU model and coming up with a good

00:43:25.040 --> 00:43:28.350
scheme to display and edit your data.

00:43:28.390 --> 00:43:31.090
And we would actually like to give
you a short demo about that as well.

00:43:31.090 --> 00:43:33.930
We will have a full session
about it later this afternoon,

00:43:33.930 --> 00:43:36.300
but we'd like to show
it to you here as well.

00:43:36.300 --> 00:43:39.430
So if you could go back
to the demo machine.

00:43:43.900 --> 00:43:46.220
So we go back to Project Builder again.

00:43:46.220 --> 00:43:48.400
We create a new project.

00:43:48.400 --> 00:43:49.410
Choose a different project type.

00:43:49.500 --> 00:43:51.900
This time it's direct to Java Client.

00:43:51.900 --> 00:43:57.270
And we give it a better name.

00:44:01.000 --> 00:44:03.840
We will add our little Java Client
class loader framework,

00:44:03.840 --> 00:44:05.070
just so that our demos are easy.

00:44:05.090 --> 00:44:11.430
And we choose the same model again.

00:44:18.300 --> 00:44:21.500
And the last option is to build
and launch the application

00:44:21.500 --> 00:44:23.200
automatically for us.

00:44:23.200 --> 00:44:26.190
So Ron,
if you expand all the groups again.

00:44:27.930 --> 00:44:30.400
So you see there's still
a WebObjects application.

00:44:30.400 --> 00:44:35.640
The one thing that is different about it
is that if you go to the main.bot again,

00:44:38.360 --> 00:44:40.470
It now uses another application class.

00:44:40.500 --> 00:44:42.290
It's the EU Dynamic Application.

00:44:42.390 --> 00:44:46.530
That's just a special class that
makes sure that your client does

00:44:46.530 --> 00:44:49.290
something sensible even if you
didn't give it any interface file.

00:44:49.300 --> 00:44:51.030
As you can see here,
there is not a single

00:44:51.040 --> 00:44:52.300
interface file defined.

00:44:52.300 --> 00:44:55.630
There's actually not a single
file related to the client

00:44:55.650 --> 00:44:57.300
that you have to create.

00:44:58.410 --> 00:45:02.240
So the program automatically
compiled and launched for us.

00:45:02.240 --> 00:45:06.440
And now we will use our Java Client
Launch again to connect.

00:45:06.440 --> 00:45:10.360
And the reason why this works so simple
is that we have this little framework.

00:45:17.030 --> 00:45:20.160
This is the application we get.

00:45:20.200 --> 00:45:24.200
As you can see, this application here has
a little more complex UI.

00:45:24.200 --> 00:45:28.390
We have query interface for
persons and departments.

00:45:28.390 --> 00:45:31.750
We see much more entities in our model.

00:45:31.750 --> 00:45:35.600
We can search for persons
and then we can open them.

00:45:35.600 --> 00:45:38.750
If you open them,
you get detailed windows.

00:45:39.910 --> 00:45:41.660
Why don't you make that?

00:45:41.670 --> 00:45:46.570
And maybe you can switch
around to addresses,

00:45:46.640 --> 00:45:47.490
phone numbers.

00:45:47.560 --> 00:45:50.110
So as you can see,
with just a very few steps,

00:45:50.190 --> 00:45:54.540
we were able to create a fairly
complex UI that allows us to browse

00:45:54.540 --> 00:45:58.460
the whole database and display and
edit all the values in your database.

00:45:58.460 --> 00:45:59.460
Okay, thank you, Ron.

00:45:59.460 --> 00:46:07.410
And I think -- oops,
can we go back to the slides, please?

00:46:17.200 --> 00:46:19.920
Before we go into question and answers,
I would like to take a moment

00:46:19.920 --> 00:46:22.550
and compare the two technologies
that we introduced to you.

00:46:22.600 --> 00:46:26.070
Ron introduced the two-tier
Cocoa EOF applications,

00:46:26.070 --> 00:46:29.400
and I talked about the three-tier
Java Client applications.

00:46:29.440 --> 00:46:31.020
What are the differences?

00:46:31.280 --> 00:46:35.100
Well,
Cocoa is a Mac OS X only technology.

00:46:35.100 --> 00:46:39.640
So Cocoa EOF applications you
can only deploy on Mac OS X.

00:46:39.660 --> 00:46:43.040
With Java Client,
you're basically platform independent.

00:46:43.050 --> 00:46:46.630
You just need a platform
that supports the JDK 1.3.

00:46:46.880 --> 00:46:52.000
But if you want to give your users the
optimal user experience on Mac OS X,

00:46:52.000 --> 00:46:55.560
you would have to use Cocoa.

00:46:56.590 --> 00:46:58.990
Platform independent,
but that also means it's not

00:46:59.010 --> 00:47:01.140
specially designed for the Mac.

00:47:01.140 --> 00:47:05.060
So if you want the best user
experience for your users on Mac OS X,

00:47:05.060 --> 00:47:07.100
then you have to use Cocoa.

00:47:07.240 --> 00:47:10.700
Java Client and Swing still gives
you very good user experience,

00:47:10.700 --> 00:47:12.890
and especially with all
these optimizations that

00:47:12.970 --> 00:47:17.230
Steve Nero's team is working on,
the applications get faster and faster,

00:47:17.230 --> 00:47:20.420
and it's really hard to,
it starts to get really hard

00:47:20.430 --> 00:47:22.730
to distinguish Cocoa and Swing.

00:47:26.400 --> 00:47:30.150
When it comes to deployment,
you have to have an installation on the

00:47:30.150 --> 00:47:32.840
client machine with Cocoa applications.

00:47:32.840 --> 00:47:35.340
With Java Client,
you have two different options.

00:47:35.340 --> 00:47:38.040
You can deploy as an
application or as an applet.

00:47:38.040 --> 00:47:41.170
We usually recommend to deploy as
an application because the user

00:47:41.170 --> 00:47:44.540
experience is so much better,
the performance is a little better,

00:47:44.540 --> 00:47:49.310
and you can tune all the parameters,
but you have both options.

00:47:49.570 --> 00:47:53.500
From the administration perspective,
Cocoa applications, you know,

00:47:53.500 --> 00:47:56.490
it's like every other
desktop application.

00:47:56.520 --> 00:47:58.750
The Java client is a little
more complicated because now

00:47:58.750 --> 00:48:00.000
you suddenly have two things.

00:48:00.000 --> 00:48:02.000
You have a server that
you need to administer,

00:48:02.000 --> 00:48:03.610
you need to make sure
that it performs well,

00:48:03.630 --> 00:48:05.500
and you have to have,
and you have a client.

00:48:05.500 --> 00:48:08.950
So it's a little more complicated,
a little more work for you.

00:48:10.550 --> 00:48:14.060
Performance of
Cocoa applications is just fine.

00:48:14.090 --> 00:48:17.790
The performance of Java Client
applications is still fine,

00:48:17.840 --> 00:48:23.520
but you have to make sure that you
partition your business logic correctly

00:48:23.530 --> 00:48:27.930
so that the communication between client
and server doesn't become a bottleneck.

00:48:28.020 --> 00:48:30.330
Also, with Swing,
the user interface is a little

00:48:30.330 --> 00:48:31.800
more sluggish than Cocoa.

00:48:31.860 --> 00:48:33.950
I personally don't think it matters.

00:48:33.960 --> 00:48:35.580
It's really close enough.

00:48:37.640 --> 00:48:42.190
When it comes to security,
Cocoa applications you can only use in

00:48:42.190 --> 00:48:45.640
the intranet because the application
directly accesses your database.

00:48:45.640 --> 00:48:48.290
You don't want to give that to
anybody outside your company.

00:48:48.300 --> 00:48:51.980
Java Client gives you all the
tools you need to make your

00:48:51.980 --> 00:48:56.950
clients or your database secure,
but there are still these complications

00:48:56.950 --> 00:49:02.190
with either installing the application or
you face this 30-second at least download

00:49:02.350 --> 00:49:04.690
time of classes if you deploy a snaplet.

00:49:04.700 --> 00:49:08.260
So that's why we think it's not
really a technology that is suitable

00:49:08.260 --> 00:49:10.220
for high-traffic internet sites.

00:49:10.220 --> 00:49:14.270
And Java Client is also
mostly an intranet technology.

00:49:14.280 --> 00:49:18.790
The reason why I wrote Intranet++
is that since you have all the

00:49:18.940 --> 00:49:23.550
tools to make it secure enough,
you can actually use it in what

00:49:23.550 --> 00:49:26.390
I call controlled environments.

00:49:26.400 --> 00:49:29.890
So let's say you're a software company,
you have a bug tracking system

00:49:29.980 --> 00:49:32.920
where you lock all your bugs,
and you have a few customers,

00:49:32.920 --> 00:49:36.060
a few preferred customers,
that you want to give a direct

00:49:36.060 --> 00:49:37.500
login into your database.

00:49:37.500 --> 00:49:40.800
It makes perfect sense to give
them a Java Client application.

00:49:40.800 --> 00:49:43.570
But as I said, it has to be a controlled
environment because of the

00:49:43.650 --> 00:49:45.180
installation complications.

00:49:48.140 --> 00:49:54.910
Okay, so we still have some time, but...

00:49:56.710 --> 00:49:58.760
We care a lot about desktop applications.

00:49:58.760 --> 00:50:03.730
We care so much about it that we give
you two technologies to implement them.

00:50:03.730 --> 00:50:05.970
We introduce to you the
Cocoa UF applications,

00:50:05.970 --> 00:50:09.100
which are two-tier, and we introduce
Java Client applications,

00:50:09.100 --> 00:50:10.440
which are three-tier.

00:50:10.440 --> 00:50:14.180
With both architectures,
you get incredibly powerful database

00:50:14.290 --> 00:50:16.660
connectivity for your desktop apps.

00:50:17.780 --> 00:50:21.420
Something to keep in mind is that
the business logic code you write

00:50:21.480 --> 00:50:23.490
can be used in all architectures.

00:50:23.490 --> 00:50:26.260
It can be used in Java Client,
it can be used in Cocoa,

00:50:26.260 --> 00:50:29.320
and it can be used in a
WebObjects HTML application.

00:50:32.920 --> 00:50:33.760
Who has not seen that?

00:50:33.800 --> 00:50:35.660
Good.

00:50:35.660 --> 00:50:43.480
The sessions I recommend to you related
to this topic are session number 606,

00:50:43.480 --> 00:50:46.170
later this afternoon,
about direct-to-Java client,

00:50:46.170 --> 00:50:49.220
and number 614 tomorrow,
advanced Java client.
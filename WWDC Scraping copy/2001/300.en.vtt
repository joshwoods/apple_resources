WEBVTT

00:00:09.070 --> 00:00:10.540
Good morning.

00:00:10.590 --> 00:00:12.490
My name is Tom Weier.

00:00:12.500 --> 00:00:15.400
I'm the Network and
Communications Technology Manager in

00:00:15.400 --> 00:00:16.340
Developer Relations.

00:00:16.340 --> 00:00:19.800
I want to welcome you to Session 300.

00:00:19.800 --> 00:00:22.340
This is Networking Overview.

00:00:22.340 --> 00:00:27.130
As you heard yesterday,
the networking in Mac OS X is pretty

00:00:27.130 --> 00:00:31.610
much the core of a variety of services
that are layered on top of it.

00:00:31.620 --> 00:00:34.250
It's an extremely
high-performance subsystem.

00:00:35.150 --> 00:00:39.210
With that,
I'd like to introduce the manager

00:00:39.220 --> 00:00:44.000
of Mac OS X CoreOS Networking,
Vincent Lubet.

00:00:52.500 --> 00:00:54.730
Thank you.

00:00:54.730 --> 00:00:57.940
So here is what we are
going to go through today.

00:00:57.940 --> 00:01:03.350
So obviously an overview of the different
components of Mac OS X networking.

00:01:03.400 --> 00:01:08.640
We're going to talk also a great
deal about APIs because they are,

00:01:08.660 --> 00:01:12.870
I guess some of you are more
familiar with the Mac OS,

00:01:12.870 --> 00:01:18.830
classic Mac OS networking and we're
going to talk more about some of the new

00:01:18.830 --> 00:01:22.480
stuff that you will discover on Mac OS X.

00:01:23.560 --> 00:01:27.200
A number of hints and tips,
especially for developers

00:01:27.580 --> 00:01:29.480
who come from Mac OS 9.

00:01:29.480 --> 00:01:35.360
The architecture of the system is quite
different and there are many things that

00:01:35.640 --> 00:01:40.930
work well on Mac OS 9 that don't work
or have severe impact on performance,

00:01:40.940 --> 00:01:42.000
for example.

00:01:42.080 --> 00:01:43.900
And we'll go over that.

00:01:43.900 --> 00:01:48.490
And we'll talk also briefly
about future directions.

00:01:49.650 --> 00:01:54.940
So maybe you've already seen this graph,
this picture.

00:01:55.020 --> 00:02:01.000
So the core of the networking
lies in the kernel.

00:02:01.000 --> 00:02:05.580
Its networking really is a
subsystem of the BSD kernel.

00:02:05.580 --> 00:02:10.920
The Darwin kernel, if you will,
has three main components.

00:02:10.920 --> 00:02:15.690
The BSD kernel,
which provides a lot of the APIs for

00:02:15.690 --> 00:02:20.040
the core services and the upper layers.

00:02:20.040 --> 00:02:24.090
We have the I/O Kit,
which provides access to the hardware.

00:02:24.150 --> 00:02:26.470
For example,
that's where you will find the

00:02:26.470 --> 00:02:29.900
Ethernet drivers in the I/O Kit.

00:02:29.900 --> 00:02:37.300
And the Mac kernel is the
basic core of the kernel that

00:02:37.310 --> 00:02:43.960
provides the basic services,
like scheduling, memory management,

00:02:43.960 --> 00:02:45.120
and things like that.

00:02:47.030 --> 00:02:52.690
So some of the features of Mac OS X.

00:02:52.900 --> 00:02:58.250
It comes with TCP and
AppleTalk protocol stacks.

00:02:58.250 --> 00:03:03.140
It comes with also links layers,
so PPP built in with

00:03:03.140 --> 00:03:08.130
serial support and PPPoE,
especially important

00:03:08.130 --> 00:03:10.460
today for access DSL.

00:03:10.460 --> 00:03:15.100
And other type of link layers, of course,
is Ethernet.

00:03:15.250 --> 00:03:17.500
So it's come built in
with Ethernet support.

00:03:17.540 --> 00:03:24.970
Another important feature of
Mac OS X is the dynamic configuration.

00:03:24.970 --> 00:03:40.330
And that's a core of the ease of use we
want to bring to a Unix-based system.

00:03:41.790 --> 00:03:48.690
Some of the problems that people see in
BSD or Unix-like implementation is that

00:03:48.750 --> 00:03:51.770
people have to type a lot of commands.

00:03:51.770 --> 00:03:52.440
It's command-line oriented.

00:03:52.440 --> 00:03:55.410
With Mac OS X, we went away with that.

00:03:55.410 --> 00:03:56.680
It's dynamic.

00:03:56.680 --> 00:04:01.100
You don't need to restart
to change the configuration.

00:04:01.180 --> 00:04:03.100
That's very important.

00:04:04.780 --> 00:04:09.190
Another thing, it also provides for an
extensible architecture.

00:04:09.190 --> 00:04:13.510
So again, it ties into the ease of use,
especially the kernel.

00:04:13.520 --> 00:04:18.070
And we have the ability to add
functionality to the kernel

00:04:18.070 --> 00:04:21.740
without having to recompile,
which is the kernel,

00:04:21.740 --> 00:04:30.510
which is usually the kind of the model
that you have on BSD or many BSD systems.

00:04:30.810 --> 00:04:35.820
So the ongoing goals we set for
ourselves for the networking

00:04:35.820 --> 00:04:38.220
experience in Mac OS X,
of course, is ease of use.

00:04:38.220 --> 00:04:44.780
Something that users are being, you know,
when they come from the classic Mac OS,

00:04:44.780 --> 00:04:49.330
they really often don't think
about configuring the network.

00:04:49.420 --> 00:04:52.260
And that's one of our
goals also for Mac OS X,

00:04:52.350 --> 00:04:53.460
performance.

00:04:53.460 --> 00:04:58.130
And I think that because of the...

00:04:58.850 --> 00:05:03.510
Underlying networking stack,
I think that we're pretty

00:05:03.660 --> 00:05:04.940
well off already today.

00:05:04.940 --> 00:05:11.400
So, better extensibility
and standard compliance,

00:05:11.400 --> 00:05:15.820
of course,
which means TCP/IP and we'll see that

00:05:15.860 --> 00:05:20.680
we have plans to get new protocols.

00:05:22.120 --> 00:05:26.640
So it's best, the kernel especially part
is based on FreeBSD 2.0.

00:05:26.780 --> 00:05:31.720
So it's a robust and
proven implementation.

00:05:31.720 --> 00:05:35.160
It's used by

00:05:35.480 --> 00:05:40.360
Typically,
it's used by large companies for servers,

00:05:40.360 --> 00:05:47.140
which shows that it can stand
a lot of abuse and heavy loads.

00:05:47.160 --> 00:05:51.040
It has a popular API,
which is the Sockets API.

00:05:51.040 --> 00:05:58.130
One of the important points is that it's
easy to port Unix-like applications.

00:05:59.780 --> 00:06:10.500
There's a lot of code out there,
and you can reuse available

00:06:10.820 --> 00:06:15.700
code and even learn by example
by looking at open source.

00:06:15.700 --> 00:06:20.320
Some various open source implementations.

00:06:21.450 --> 00:06:30.100
So we brought some enhancement
to the 3BSD implementations.

00:06:30.180 --> 00:06:35.100
First of all,
the kernel is multithreaded and MPCV.

00:06:35.100 --> 00:06:39.890
Multithreaded means that we can run--

00:06:40.590 --> 00:06:48.240
We can take advantage, for example,
of multiprocessor architecture that has

00:06:50.900 --> 00:06:52.540
That's a totally different
model from Mac OS 9,

00:06:52.540 --> 00:06:53.700
especially for the networking.

00:06:53.700 --> 00:06:58.910
So we'll see that some of the
assumptions that you could make on

00:06:58.910 --> 00:07:02.330
Mac OS 9 are no more true on 10.

00:07:02.330 --> 00:07:05.160
And it's not only for the kernel pieces,
but also it has impact

00:07:05.160 --> 00:07:06.620
on the applications.

00:07:08.810 --> 00:07:12.480
So we have tuned also the network
buffer allocation so that on

00:07:12.490 --> 00:07:18.230
the typical client system,
we don't use too much way of memory,

00:07:18.230 --> 00:07:20.650
which is a very critical resource.

00:07:22.500 --> 00:07:29.100
But of course, the buffer allocation
can stretch and grow.

00:07:29.100 --> 00:07:32.520
For example,
if you have your configuration like

00:07:32.620 --> 00:07:35.170
a server or something like that.

00:07:35.740 --> 00:07:37.800
So part of the announcement.

00:07:37.800 --> 00:07:37.810
We have a lot of information about
the network buffer allocation.

00:07:37.870 --> 00:07:37.920
So part of the announcement.

00:07:38.520 --> 00:07:41.890
We bought to the FreeBSD kernel
is this extensibility.

00:07:41.900 --> 00:07:46.980
That means that you don't
need to recompile the kernel.

00:07:47.320 --> 00:07:53.450
The session in the session 304 will go
in more detail and it's session 304.

00:07:53.460 --> 00:07:57.080
It's just after this one in room J,
if I remember well,

00:07:57.080 --> 00:07:58.460
which is the opposite end.

00:08:02.520 --> 00:08:07.300
Dynamic configuration is
very important for us.

00:08:07.300 --> 00:08:14.200
That means that you don't need to
restart when you reconfigure your system.

00:08:14.220 --> 00:08:16.170
But we went even further than that.

00:08:16.200 --> 00:08:21.480
It means that as the
kernel supports multi-link,

00:08:21.480 --> 00:08:26.880
multi-homing, out-of-the-box,

00:08:27.400 --> 00:08:30.400
We came up with this idea
of automatic configuration.

00:08:30.400 --> 00:08:34.220
So we don't use multi-homing
really in the sense,

00:08:34.220 --> 00:08:36.700
by default, on a client system.

00:08:36.700 --> 00:08:41.540
We don't use multi-homing really
to do routing or things like that.

00:08:41.540 --> 00:08:45.280
But one of the important
features we have,

00:08:45.320 --> 00:08:47.680
for example,
is that if you have the classic

00:08:47.730 --> 00:08:52.640
example we come up with,
it's that you can have several network

00:08:52.640 --> 00:08:54.700
interfaces active at the same time.

00:08:54.700 --> 00:08:57.920
And the typical use,
you come to your office and

00:08:57.940 --> 00:09:02.900
you plug in the ethernet,
the ethernet becomes your main interface.

00:09:02.900 --> 00:09:05.820
If you have airport and you
unplug the ethernet cable,

00:09:05.830 --> 00:09:09.040
the airport interface will
pick up automatically.

00:09:09.040 --> 00:09:12.460
And that's without any user interaction.

00:09:12.560 --> 00:09:15.080
So that's very, very important for us.

00:09:15.080 --> 00:09:22.800
I think that that's something that
really shows the benefit of multi-homing.

00:09:22.800 --> 00:09:26.360
And this afternoon,
there will be the session 303 that's

00:09:26.360 --> 00:09:30.750
going to talk a lot more about
network configuration and mobility.

00:09:31.200 --> 00:10:35.200
[Transcript missing]

00:10:36.100 --> 00:10:49.000
[Transcript missing]

00:10:51.140 --> 00:10:54.820
So, I mean,
the important thing is that Classic and

00:10:54.820 --> 00:10:57.180
Darwin share the same IP address.

00:10:57.180 --> 00:11:00.400
It's, again, something that

00:11:00.990 --> 00:11:04.790
Without that,
it would be almost impossible if Classic,

00:11:04.870 --> 00:11:07.170
for example,
had to add a separate address.

00:11:07.220 --> 00:11:09.100
It would become a nightmare.

00:11:09.100 --> 00:11:12.860
You couldn't, for example,
usually connect to your ISP because

00:11:12.860 --> 00:11:17.300
usually you have only one
address assigned by the server.

00:11:17.300 --> 00:11:19.710
Mac OS X

00:11:20.220 --> 00:11:24.500
So that means that the TCP and
UDP port space are shared

00:11:24.500 --> 00:11:28.280
between those two environments.

00:11:28.280 --> 00:11:33.330
And something we've done also,
we took a great deal of effort to

00:11:33.360 --> 00:11:41.100
make sure that when you ping a system,
we reply with only one ICMP reply.

00:11:41.100 --> 00:11:44.620
That was something that was brought
to our attention a few years ago,

00:11:44.620 --> 00:11:45.770
one of the sessions.

00:11:45.780 --> 00:11:53.340
So we took your feedback
and made sure it's right.

00:11:53.340 --> 00:11:55.490
In Classic,
there's no user configuration.

00:11:55.510 --> 00:12:02.660
The configuration of the TCP/IP in
OpenTransport in Classic is done

00:12:02.660 --> 00:12:04.840
automatically behind the scene.

00:12:04.840 --> 00:12:07.920
So the TCP/IP control panel is read-only.

00:12:07.920 --> 00:12:11.970
One important thing to note is
that Classic and Darwin do not

00:12:11.980 --> 00:12:15.200
share the Apple Talk address.

00:12:15.200 --> 00:12:19.170
And usually, that's not really a problem.

00:12:19.420 --> 00:12:25.280
So one of the important core of the
classic networking implementation is

00:12:25.330 --> 00:12:28.580
this global UDP and TCP port space.

00:12:28.580 --> 00:12:34.200
So basically how it works is that,
for example, when a classic application

00:12:34.250 --> 00:12:40.660
does bind to grab a port,
it does some special call into Darwin.

00:12:40.660 --> 00:12:44.600
And the same for Mac OS applications.

00:12:44.600 --> 00:12:48.900
When they bind,
they call into this global port space.

00:12:49.370 --> 00:12:55.620
And it's in a way similar
to NAT in some sense.

00:12:55.620 --> 00:13:00.660
But the thing is that the
clients are on the same machine.

00:13:00.660 --> 00:13:02.950
It's not really NAT,
but it's similar to NAT.

00:13:02.960 --> 00:13:06.570
And of course, we have this component,
kernel extension,

00:13:06.570 --> 00:13:11.700
maybe you've seen on your system,
which is called shared IP, which handles,

00:13:11.700 --> 00:13:16.470
it's a filter really at the lower
level of the stack that handles

00:13:16.470 --> 00:13:18.900
incoming and outgoing traffic.

00:13:18.900 --> 00:13:23.620
And for incoming packet,
it calls into this global port space

00:13:23.740 --> 00:13:28.840
to see to which end to send the packet.

00:13:33.210 --> 00:13:38.370
So now we're going to talk a little
bit more about the APIs for the

00:13:38.370 --> 00:13:39.900
different application environments.

00:13:39.900 --> 00:13:45.710
I forgot to put Java there,
but of course we support Java.

00:13:45.760 --> 00:13:52.610
But we think that for Mac OS X,
really the primary, I mean,

00:14:10.370 --> 00:14:10.370
If you use classic,
you don't have to do anything.

00:14:10.370 --> 00:14:10.370
If your application, if your plan is to
continue to use classic,

00:14:10.370 --> 00:14:10.370
it works, you know, 100% fidelity.

00:14:10.370 --> 00:14:10.370
So going to talk more
about Carbon and Cocoa.

00:14:10.370 --> 00:14:10.370
And so we

00:14:12.400 --> 00:14:17.350
We see three different types
of APIs in Mac OS X and we're

00:14:17.390 --> 00:14:19.750
going through all of them.

00:14:19.760 --> 00:14:26.480
The first kind are the URL-oriented APIs,
easy to use.

00:14:26.480 --> 00:14:29.190
The other ones are the
Open Transport APIs,

00:14:29.350 --> 00:14:30.880
really for Carbon.

00:14:31.030 --> 00:14:37.350
And the last one is the BSD Sockets API,
which is the native APIs for

00:14:37.350 --> 00:14:39.910
networking on Mac OS X.

00:14:40.620 --> 00:14:44.610
The URL-oriented APIs are for,
what we say,

00:14:44.620 --> 00:14:47.980
norm-centric applications mainly.

00:14:47.980 --> 00:14:53.300
That means that one of the
great benefits of those APIs is

00:14:53.300 --> 00:14:56.300
that it's easy to download.

00:14:56.560 --> 00:15:02.770
some URL so basically you you let's
say you have a URL you pass it to the

00:15:02.780 --> 00:15:08.570
API and that's going to download it
locally on the system and tells you when

00:15:08.570 --> 00:15:13.450
it's done so you don't have to know about
the protocol it themselves you don't

00:15:13.550 --> 00:15:20.020
have to deal with ftp the details of ftp
or HTTP it's all done for you and they

00:15:20.270 --> 00:15:28.440
are basically so three sets I mean three
three kinds of API says an NSURL API for

00:15:28.560 --> 00:15:34.670
Cocoa application URL access for
Carbon and classic of course and

00:15:34.670 --> 00:15:39.620
a new one that's kind of bridging
those two application development

00:15:39.620 --> 00:15:45.960
that are the CFURL access for can be
used both by Carbon and Cocoa application

00:15:46.150 --> 00:15:53.130
and you will learn more about about
those if you go to the session 311.

00:15:53.510 --> 00:15:57.670
So I won't go into any more details,
especially because I don't

00:15:57.670 --> 00:15:59.220
know them very well.

00:15:59.900 --> 00:16:36.600
[Transcript missing]

00:16:37.310 --> 00:16:44.680
The OT implementation of Mac OS X is
layered on top of sockets.

00:16:44.680 --> 00:16:50.680
It's a framework,
part of the core services framework.

00:16:50.680 --> 00:16:57.350
It uses threads to
emulate asynchronous mode,

00:16:57.350 --> 00:17:00.720
which means also that

00:17:01.250 --> 00:17:06.330
Implementing OpenTransport can also
take advantage of multiprocessors.

00:17:06.340 --> 00:17:10.200
It can do some of the background work
that can be done on another processor

00:17:10.200 --> 00:17:15.660
while your application is accessing
some APIs from another processor.

00:17:15.670 --> 00:17:22.400
Something very important to
note is that OpenTransport 10

00:17:22.400 --> 00:17:25.660
is layered on top of Socket.

00:17:25.660 --> 00:17:32.060
That means that you're going to
incur overhead compared to similar

00:17:32.060 --> 00:17:35.660
code that uses straight sockets.

00:17:35.660 --> 00:17:37.660
It really depends.

00:17:37.660 --> 00:17:39.960
Roughly it's 5-10% overhead.

00:17:40.120 --> 00:17:47.660
Depending on what the code is doing,
it can be far worse.

00:17:47.660 --> 00:17:52.840
Sometimes it can be even better
because sometimes you can take

00:17:52.930 --> 00:17:55.660
advantage of multiprocessors.

00:17:55.660 --> 00:17:59.220
You can take advantage of the fact
that some of the worker threads in

00:17:59.280 --> 00:18:01.660
the background run on another CPU.

00:18:01.660 --> 00:18:09.190
But for a typical application,
10% is common.

00:18:11.160 --> 00:18:17.480
So here it starts to
go into more details,

00:18:17.480 --> 00:18:20.780
but important gotchas.

00:18:23.500 --> 00:18:27.210
When we designed Carbon,
we didn't think that Carbon was

00:18:27.210 --> 00:18:28.990
just a compatibility layer.

00:18:29.000 --> 00:18:35.000
So the goal was not
to be just compatible.

00:18:35.240 --> 00:18:42.280
We were thinking that developers bringing
their application to Mac OS X and

00:18:42.420 --> 00:18:50.280
already moving the application from
just the Mac OS toolbox to Carbon had

00:18:50.390 --> 00:18:54.000
already to... sometimes it's a big step.

00:18:54.000 --> 00:19:00.000
And we're not always thinking that,
you know, then going the further steps,

00:19:00.000 --> 00:19:04.000
which would be to use Cocoa,
would be always easy.

00:19:04.010 --> 00:19:10.000
So we were thinking that it was very
important to provide for performance.

00:19:10.100 --> 00:19:14.280
The Carbon implementation on Mac OS X,
the OT framework,

00:19:14.340 --> 00:19:18.000
was meant to perform well.

00:19:18.270 --> 00:19:24.000
Which means that... So there's
a flip side to that.

00:19:24.010 --> 00:19:31.000
It's that it's not a
high-fidelity implementation.

00:19:31.130 --> 00:19:36.500
Especially because of
the preemptive nature of

00:19:36.500 --> 00:19:39.000
Mac OS X and the multi-threading.

00:19:39.000 --> 00:19:45.000
So, for example, in Carbon,
there's no interrupt level.

00:19:45.000 --> 00:19:51.970
A part of the... of Open Transport is
using... notifiers and default tasks

00:19:52.010 --> 00:19:59.000
that on classic run in the background
at the software interrupt level.

00:19:59.000 --> 00:20:01.000
That does not really exist on Mac OS X.

00:20:01.000 --> 00:20:03.990
You only have threads.

00:20:04.000 --> 00:20:06.000
There's no interrupt level.

00:20:06.000 --> 00:20:11.780
And one of the things
that we did is that we...

00:20:11.810 --> 00:20:21.110
I really decided that it was worth
for the performance implication that,

00:20:21.230 --> 00:20:25.080
for example,
a notifier run just as another thread.

00:20:25.080 --> 00:20:31.200
A notifier has no higher priority,
if you want, than the main event loop or

00:20:31.350 --> 00:20:33.900
other cooperative threads.

00:20:35.560 --> 00:20:42.360
The only solution that we could have
done to work around this problem

00:20:42.360 --> 00:20:47.180
was to really have notifier being
serialized with cooperative threads.

00:20:47.180 --> 00:20:51.580
That means notifiers would be
just another cooperative thread.

00:20:51.580 --> 00:20:54.390
That would make a very
easy port of application,

00:20:54.480 --> 00:20:57.000
but the performance would greatly suffer.

00:20:57.000 --> 00:21:02.200
Because you don't want the networking
activity to be dependent on,

00:21:02.200 --> 00:21:05.120
for example, some UI.

00:21:05.560 --> 00:21:08.320
Or some other lengthy task.

00:21:08.320 --> 00:21:12.310
So that means that it's very,
very important when porting

00:21:12.430 --> 00:21:17.240
your application that you think
about protecting your data.

00:21:17.240 --> 00:21:20.730
Making sure that if you're using
asynchronous mode and notifiers,

00:21:20.770 --> 00:21:27.370
you have to be sure that you use
the right primitive to ensure you

00:21:27.370 --> 00:21:33.270
to serialize the access from the
cooperative threads and the notifier.

00:21:33.650 --> 00:21:39.350
Luckily, in Open Transport API,
there are already a bunch of

00:21:39.360 --> 00:21:41.890
primitives that can help that.

00:21:41.960 --> 00:21:46.920
The main ones are really
OTEnterNotifier and OTLeaveNotifier

00:21:46.920 --> 00:21:49.760
that define really critical sections.

00:21:49.800 --> 00:21:53.730
When you call OTEnterNotifier
from your main event,

00:21:53.730 --> 00:21:57.820
for example,
that prevents the notifier to run

00:21:57.820 --> 00:22:01.000
until you call OTLeaveNotifier.

00:22:01.580 --> 00:22:07.210
That's really the most useful of the...

00:22:07.700 --> 00:22:25.400
[Transcript missing]

00:22:25.640 --> 00:22:27.860
For example,
maybe from your notifier you can

00:22:27.880 --> 00:22:32.680
just set a flag to signal the
main event loop to do something,

00:22:32.680 --> 00:22:34.280
that something happened
at the networking.

00:22:34.280 --> 00:22:37.840
That's fine to use with
OT atomic operations.

00:22:37.860 --> 00:22:40.660
And finally also...

00:22:42.460 --> 00:22:49.240
One primitive I really like are the LIFO.

00:22:49.240 --> 00:22:55.840
They are pretty powerful to handle
a set of queries and queues.

00:22:55.840 --> 00:23:02.870
They are sometimes a little bit obscure,
but can be very, very useful.

00:23:04.540 --> 00:23:10.100
So other gotchas, if you want,
or at least this one,

00:23:10.100 --> 00:23:14.820
are the recommendations.

00:23:14.840 --> 00:23:19.880
So if you bring your open
transport application,

00:23:20.330 --> 00:23:25.610
What are the best ways to
use Open Transport APIs?

00:23:26.730 --> 00:23:31.510
You're certainly aware there's
a new kind of library that

00:23:31.510 --> 00:23:37.020
has been developed by DTS,
Quinn especially,

00:23:37.020 --> 00:23:45.240
which was OTMP that provides some kind
of framework or a library that allows

00:23:45.240 --> 00:23:49.940
to use open transport from MP threads.

00:23:49.940 --> 00:23:52.640
The only downside is that it's
not available on Mac OS 8.

00:23:53.500 --> 00:23:58.220
But otherwise, it's very powerful and it
runs great on both 9 and 10.

00:23:59.540 --> 00:24:09.090
Otherwise, especially for Mac OS X,
it's very important not to poll.

00:24:09.120 --> 00:24:15.160
The mod,
if you're using synchronous endpoint,

00:24:15.170 --> 00:24:20.850
you should use a synchronous blocking
mod with sync_idol event so that your

00:24:20.890 --> 00:24:24.450
cooperative threads can be called back.

00:24:24.670 --> 00:24:31.650
And lastly, the asynchronous mode with
Notifier is certainly the mode,

00:24:31.680 --> 00:24:35.640
the open transport mode,
that is the most efficient.

00:24:35.640 --> 00:24:46.070
So if your application relies heavily
on networking and gets a lot of data,

00:24:46.070 --> 00:24:52.110
or is a server kind of application,
certainly it's...

00:24:52.210 --> 00:24:56.480
It's worth the effort of
using asynchronous mode.

00:24:56.480 --> 00:24:57.470
And it's available.

00:24:57.520 --> 00:25:02.440
So if you're doing that online,
it will run just great on 10,

00:25:02.500 --> 00:25:06.600
provided that you make sure
that you serialize the access to

00:25:06.600 --> 00:25:11.930
the data that's shared between
cooperative rights and the notifier.

00:25:12.020 --> 00:25:14.680
So I will repeat that several times here.

00:25:14.680 --> 00:25:20.640
But what's important on
Mac OS X is not to poll.

00:25:20.640 --> 00:25:23.420
If some of you went to the
Darwin Overview yesterday,

00:25:23.420 --> 00:25:29.680
there was a demonstration of a
simple Carbon application that was

00:25:29.830 --> 00:25:37.200
using different well-known pitfalls.

00:25:37.200 --> 00:25:42.160
One of them is to use, for example,
wait next event with a

00:25:42.160 --> 00:25:45.360
timeout of value of 0.

00:25:45.360 --> 00:25:50.640
And you could see with the tools that
are available from the BSD layers,

00:25:50.640 --> 00:25:57.510
is that you could see that the
CPU is used as 100%. If it's

00:25:57.510 --> 00:26:01.460
the only application and the
only thread really that runs,

00:26:01.460 --> 00:26:05.000
you see, oh, what's the point?

00:26:05.000 --> 00:26:10.860
We will see that also it has
also some implication about,

00:26:10.880 --> 00:26:14.220
for example,
when the system can go to sleep,

00:26:14.220 --> 00:26:16.020
light sleep like those and now.

00:26:16.020 --> 00:26:16.960
And it uses more power.

00:26:17.000 --> 00:26:20.460
It's important for power boost,
for example, and battery life.

00:26:20.460 --> 00:26:26.370
Another thing is that there's
open transport as this call called

00:26:26.480 --> 00:26:31.180
OT idle that's in the documentation,
we say, shouldn't be used.

00:26:31.180 --> 00:26:36.570
And really, on 10,
if you use OT idle in some way to--

00:26:36.640 --> 00:26:39.380
you have a tight loop and you say,
OK, I will be good.

00:26:39.380 --> 00:26:40.940
I will call OT idle.

00:26:40.940 --> 00:26:44.140
That's going to add a
great deal of latency.

00:26:44.140 --> 00:26:49.830
We took really great care
on 10 to make it very,

00:26:49.830 --> 00:26:49.830
very--

00:26:50.100 --> 00:26:51.500
Inefficient.

00:26:51.500 --> 00:26:54.690
So it will slow down your
application and it will block it.

00:26:54.800 --> 00:26:57.700
So if you want to block, for example,
if it's a way for you to block,

00:26:57.710 --> 00:27:01.770
it will block your application
for a while and your thread

00:27:01.770 --> 00:27:03.420
at least for a while.

00:27:06.300 --> 00:27:12.000
[Transcript missing]

00:27:12.240 --> 00:27:19.490
The main reason for the surprise
is that flow control is much

00:27:19.490 --> 00:27:22.200
more common on Mac OS X.

00:27:22.200 --> 00:27:29.380
The reason is mainly because on
Mac OS X you have a split address space,

00:27:29.420 --> 00:27:36.450
so data has to be copied from
the user space to the kernel.

00:27:36.810 --> 00:27:40.180
In the kernel, memory is very expensive.

00:27:40.190 --> 00:27:45.740
So it's a resource that we don't
want to over-- to be abused

00:27:45.810 --> 00:27:49.700
because it impacts all the
different subsystems in the kernel.

00:27:49.780 --> 00:27:53.720
Everything is shared.

00:27:53.720 --> 00:27:53.720
So by default, the--

00:27:54.450 --> 00:27:59.720
The socket buffer size,
which are equivalent to the send buff

00:27:59.720 --> 00:28:05.020
and the receive buff in the streams,
are really, on Mac OS 9,

00:28:05.020 --> 00:28:08.100
they are not really enforced.

00:28:08.100 --> 00:28:11.980
And on Mac OS X,
the equivalent are strictly enforced.

00:28:11.980 --> 00:28:16.310
That means that if you set
a socket buffer size of 4K,

00:28:16.430 --> 00:28:20.940
that's just the amount of data
that you can copy at once.

00:28:22.010 --> 00:28:26.090
That means that if you send data,
you will, for example,

00:28:26.100 --> 00:28:32.260
an OTCend call will return much
more frequently the OKOTflow error.

00:28:32.260 --> 00:28:36.420
And your application should
be ready to handle that.

00:28:37.740 --> 00:28:46.700
A way to work around that is to
use these XTI options and both,

00:28:46.700 --> 00:28:50.750
but it has an impact
on the overall system.

00:28:51.820 --> 00:28:55.910
Also,
differences from the implementation of

00:28:55.910 --> 00:29:02.260
the Open Transport Framework content is
that concern the timer and default task.

00:29:02.260 --> 00:29:06.220
So, again, there are

00:29:06.800 --> 00:29:11.240
In a way,
it's to be performance sensitive.

00:29:11.240 --> 00:29:15.100
They are not implemented with the
default task manager and the time

00:29:15.100 --> 00:29:20.070
manager that are provided by the Carbon

00:29:21.250 --> 00:29:22.520
the Carbon layer.

00:29:22.520 --> 00:29:26.480
And instead,
they are serialized with the notifier.

00:29:26.480 --> 00:29:30.980
And we've done that because we
noticed that many applications,

00:29:30.980 --> 00:29:33.160
that's what is important.

00:29:33.270 --> 00:29:37.820
Why they would use the
Open Transport time manager

00:29:37.820 --> 00:29:39.320
and default task manager.

00:29:39.320 --> 00:29:41.700
It's not because they were
better than the time manager

00:29:41.700 --> 00:29:44.350
or the default task manager.

00:29:44.360 --> 00:29:47.660
It's just because they were
relying on the fact that,

00:29:47.660 --> 00:29:52.300
online, they are serialized also
with the notifier callbacks.

00:29:52.300 --> 00:29:55.310
So that's--

00:29:55.840 --> 00:29:58.920
is the main reason,
but it might have some subtle

00:29:58.920 --> 00:30:01.200
implications for some applications.

00:30:01.210 --> 00:30:03.600
So you should review that.

00:30:04.120 --> 00:30:11.050
Another thing is that for AppleTalk,
Carbon is the only API that

00:30:11.100 --> 00:30:15.300
allows to access AppleTalk.

00:30:15.400 --> 00:30:19.900
It supports only a subset of AppleTalk.

00:30:20.040 --> 00:30:27.260
It supports those protocols, DDP, ZIP,
and NBP.

00:30:30.720 --> 00:30:34.930
We know that it's not
for all the developers,

00:30:34.930 --> 00:30:38.820
it's not enough,
but that's what we were able to do.

00:30:38.820 --> 00:30:42.650
And one of the things is
that we got requests from,

00:30:42.650 --> 00:30:46.620
why for example,
NBP is that many applications,

00:30:46.660 --> 00:30:52.090
many developers still use NBP to register
services and to provide maybe for

00:30:52.090 --> 00:30:54.730
copy protection and things like that.

00:30:56.340 --> 00:31:00.100
And frankly,
that was relatively easy to do,

00:31:00.140 --> 00:31:02.440
so that's why we've done.

00:31:02.440 --> 00:31:07.140
Providing, supporting higher level,
we got a lot of requests,

00:31:07.140 --> 00:31:11.090
I mean a lot of requests,
we got many requests to support

00:31:11.120 --> 00:31:14.920
higher level protocols and
we still don't have that.

00:31:17.400 --> 00:31:23.500
So now I'm going to talk
briefly about the Socket API.

00:31:23.640 --> 00:31:27.260
That's the native API for Mac OS X.

00:31:27.300 --> 00:31:32.260
That means that that's the one where
you're the closest to the system.

00:31:32.260 --> 00:31:37.080
And if you can,
I would encourage you to use this API.

00:31:38.320 --> 00:31:43.240
One of the benefits is that there's a
lot of publicly available code out there,

00:31:43.240 --> 00:31:44.320
open source.

00:31:44.320 --> 00:31:50.560
There's many codes to learn from.

00:31:50.560 --> 00:31:54.770
There's also a lot of books.

00:31:54.780 --> 00:32:02.270
One of my favorites is the Unix
Network Programming by Richard Stevens.

00:32:02.270 --> 00:32:05.530
It's really kind of the Bible.

00:32:05.530 --> 00:32:07.740
It's a great book.

00:32:08.320 --> 00:32:14.740
And something very important,
especially if you're porting

00:32:14.790 --> 00:32:18.190
your application from Mac OS 9,
is that

00:32:18.450 --> 00:32:22.660
Because you have sockets in Mac OS X,
maybe you should also review your

00:32:22.660 --> 00:32:26.610
code and making sure that if you have

00:32:26.820 --> 00:32:30.650
If you have a layer that's sockets
like layer in your application,

00:32:30.650 --> 00:32:32.990
maybe it would be time to get rid of it.

00:32:32.990 --> 00:32:35.680
You know,
instead of having this socket like

00:32:35.680 --> 00:32:40.190
emulation layer on top of open transport,
that's called open transport.

00:32:40.200 --> 00:32:43.110
If you go just through
directly open transport,

00:32:43.110 --> 00:32:46.800
you will get you will see a
lot of performance benefit.

00:32:48.870 --> 00:32:55.860
And for example, one of the requests that
we got from developers the

00:32:55.860 --> 00:33:00.440
past years were to include,
to add socket API,

00:33:00.440 --> 00:33:04.130
socket support into open
transport on Mac OS 9.

00:33:04.130 --> 00:33:10.530
So it's not going to happen, but I mean,
now you have to, on Mac OS X,

00:33:10.530 --> 00:33:13.800
you have the socket API available.

00:33:14.290 --> 00:33:20.680
So I'm going to talk briefly for the
people who know the Open Transport API.

00:33:20.680 --> 00:33:24.530
I'm going to show that it's very easy.

00:33:24.560 --> 00:33:29.260
There's almost one-to-one correspondence
between the Open Transport core

00:33:29.260 --> 00:33:31.000
and the Socket's core.

00:33:31.000 --> 00:33:39.790
So for example, for endpoints,
the one that you use for your TCP, UDP--

00:33:41.780 --> 00:33:48.570
So, they are called endpoint providers in
the Open Transport documentation and

00:33:48.790 --> 00:33:52.180
they are sockets file descriptor in BSD.

00:33:52.180 --> 00:33:56.200
And usually,
so to make an active connection,

00:33:56.210 --> 00:34:01.640
like a client would do, what you do,
you call OT bind with a queue

00:34:01.640 --> 00:34:07.430
length of zero and then you call
OT connect to the distant site.

00:34:08.020 --> 00:34:14.210
And in BSD, the bind is really optional.

00:34:14.300 --> 00:34:17.980
You don't need to call bind,
but you can bind to get an ephemeral

00:34:18.040 --> 00:34:20.040
port and then you can just call connect.

00:34:20.050 --> 00:34:21.320
Very simple.

00:34:21.320 --> 00:34:26.730
For passive connection, like for servers,

00:34:26.800 --> 00:34:33.990
With OpenTransport,
you bind with a QLens greater than zero.

00:34:35.350 --> 00:34:39.050
On 10,
the queue length is called the back

00:34:39.050 --> 00:34:42.310
load and it's found in the listen call.

00:34:42.310 --> 00:34:44.960
So that's where there's
a little mismatch.

00:34:44.960 --> 00:34:51.200
But usually those operations are done
in series so it's really easy to do.

00:34:51.200 --> 00:34:56.050
So on 10 you call otlisten to set
the endpoint in listening mode and

00:34:56.130 --> 00:35:01.200
when the incoming connection comes,
you're notified and you call otxm.

00:35:01.200 --> 00:35:03.180
On 10, you call otxm.

00:35:03.200 --> 00:35:07.200
BSD sockets, it's roughly the same
except the accept call.

00:35:07.200 --> 00:35:09.050
So the backlog,
the queue length become the

00:35:09.050 --> 00:35:10.200
backlog in the listen call.

00:35:10.200 --> 00:35:13.200
And accept returns a file descriptor.

00:35:13.200 --> 00:35:18.190
With otxm you pass the listener
endpoint and the acceptor endpoint.

00:35:18.280 --> 00:35:23.200
But it's very, very similar.

00:35:23.200 --> 00:35:26.140
Sending and receiving data.

00:35:26.140 --> 00:35:30.770
So for example,
depending on the... For example,

00:35:30.770 --> 00:35:33.200
with OpenTransport,
depending on the type of endpoint,

00:35:33.220 --> 00:35:37.380
whether it's connection
oriented or datagram oriented,

00:35:37.380 --> 00:35:40.200
you have different APIs to
send and receive data.

00:35:40.200 --> 00:35:48.610
So otxm would be for TCP, for example,
and otxm-u-data would be

00:35:48.610 --> 00:35:51.200
for UDP to send datagrams.

00:35:51.200 --> 00:35:53.180
On BSD, it's a little bit different.

00:35:53.270 --> 00:35:59.200
There's no real strong affinity
between the type of endpoint and

00:35:59.200 --> 00:36:02.300
the type of... the type of socket.

00:36:02.400 --> 00:36:58.000
[Transcript missing]

00:36:59.100 --> 00:37:05.880
So disconnecting and closing,
so that's also on Open Transport,

00:37:05.880 --> 00:37:11.520
you have the send disconnect that
for TCP is going to send a reset.

00:37:11.520 --> 00:37:16.020
If you have to do that on BSD,
you use the linger option,

00:37:16.020 --> 00:37:18.190
specifying abort.

00:37:18.280 --> 00:37:25.220
For an orderly disconnect,
you would send, if you're a client,

00:37:25.220 --> 00:37:29.920
depending on your protocol,
the order may depend.

00:37:29.920 --> 00:37:32.770
But usually you call send
orderly disconnect and then

00:37:32.770 --> 00:37:34.400
receive orderly disconnect.

00:37:34.400 --> 00:37:40.390
If you want to wait until notification
that the other side is disconnected.

00:37:42.840 --> 00:37:45.980
For BSD, pretty much the same.

00:37:45.980 --> 00:37:49.170
It's called shutdown
write and shutdown read.

00:37:49.200 --> 00:37:52.790
And then finally,
you call otcloseprovider when

00:37:52.790 --> 00:37:55.380
you're done with your endpoint.

00:37:55.380 --> 00:37:58.400
And when you're done with
socket file descriptor,

00:37:58.410 --> 00:37:59.860
you just call close.

00:38:02.550 --> 00:38:09.840
In many cases, if you see a simple
sample code from Unix,

00:38:09.870 --> 00:38:13.860
you see that they don't call close,
but it's because file descriptors

00:38:13.860 --> 00:38:17.090
are closed automatically
when the process exits.

00:38:17.100 --> 00:38:21.310
Similar to what happens
also on OpenTransport,

00:38:21.320 --> 00:38:23.380
but close is the one.

00:38:26.150 --> 00:38:30.280
So again,
so if you bring an application from

00:38:30.280 --> 00:38:33.850
Open Transport you want to use Socket,
you will have certainly to do some

00:38:33.860 --> 00:38:36.780
name to address resolution to use DNS.

00:38:36.940 --> 00:38:43.790
So the APIs we have in BSD are
called get host by name for

00:38:43.790 --> 00:38:46.510
name to address resolution.

00:38:46.690 --> 00:38:52.600
and getOSbyAddress adder for the reverse.

00:38:52.650 --> 00:38:57.650
One important thing to note is
that those are non-reentrant APIs,

00:38:57.750 --> 00:39:01.940
so that's a well-known
limitation of those APIs.

00:39:01.950 --> 00:39:06.400
That means that they return a pointer.

00:39:06.470 --> 00:39:14.050
So the information that the
resolver library gets is--

00:39:14.500 --> 00:39:20.200
So those APIs return a pointer to
a structure that is in the library.

00:39:20.200 --> 00:39:23.680
So that's why if you have two
threads calling those APIs at once,

00:39:23.680 --> 00:39:27.080
you may end up with inconsistent results.

00:39:27.080 --> 00:39:34.840
And another limitation or things to
know is that those are blocking codes,

00:39:34.840 --> 00:39:38.170
and they are not cancelable,
quite different from maybe what

00:39:38.260 --> 00:39:43.910
you can use with OpenTransport,
where you could cancel access to

00:39:43.910 --> 00:39:49.000
APIs to the internet service provider.

00:39:49.000 --> 00:39:52.060
That's not possible with BSD.

00:39:52.430 --> 00:39:55.550
And which means also is
that Open Transport on 10,

00:39:55.560 --> 00:39:57.440
we have similar limitations.

00:39:57.440 --> 00:40:01.320
I mean, we try to work around them,
but...

00:40:01.800 --> 00:40:07.900
[Transcript missing]

00:40:08.200 --> 00:40:22.000
[Transcript missing]

00:40:23.750 --> 00:40:27.810
Here we're going to talk about
the different ways to use

00:40:27.870 --> 00:40:29.200
the different tasking models.

00:40:29.210 --> 00:40:36.370
So that's the terminology that is
used inside Macintosh networking.

00:40:36.600 --> 00:40:40.360
If you move your application,
you can use really the... So if

00:40:40.360 --> 00:40:45.270
you're using synchronous blocking
endpoints in cooperative threads,

00:40:45.280 --> 00:40:50.480
for example, or MP task,
it's very simple to convert that

00:40:50.490 --> 00:40:53.700
code to use the Socket's equivalent.

00:40:53.700 --> 00:40:57.240
We saw there's almost
one-to-one matching.

00:40:57.240 --> 00:41:03.000
There are a few things to know,
but it's very simple.

00:41:03.900 --> 00:41:09.510
If you're using asynchronous endpoint,
there's no callback in BSD,

00:41:09.510 --> 00:41:12.060
so you don't have notifiers.

00:41:12.060 --> 00:41:19.220
But still, what you do usually is that
you use the select system call

00:41:19.250 --> 00:41:24.250
that allows you to multiplex,
to wait for events on

00:41:24.250 --> 00:41:26.760
several endpoints at once.

00:41:26.760 --> 00:41:31.060
So usually you have a thread
blocked on the select call that

00:41:31.060 --> 00:41:33.580
blocks on several endpoints.

00:41:33.900 --> 00:41:37.780
So it's not callback,
it's more multiplexing,

00:41:37.780 --> 00:41:40.400
but it achieves the same results.

00:41:40.900 --> 00:41:43.080
For example,
the Open Transport framework is

00:41:43.080 --> 00:41:47.260
using that to wait for events.

00:41:47.260 --> 00:41:51.870
And when the select call returns,
that's what's going to trigger

00:41:51.870 --> 00:41:53.620
the call to the notifier.

00:41:56.800 --> 00:42:02.440
So there are three kinds of events
that the select call can handle.

00:42:02.440 --> 00:42:06.780
Read event, if a socket file descriptor
is ready for read,

00:42:06.780 --> 00:42:08.900
means data is available.

00:42:08.900 --> 00:42:13.480
Write, so if you are in a
situation of flow control,

00:42:13.480 --> 00:42:19.670
and you can put the file descriptor
in the right file descriptor set,

00:42:19.670 --> 00:42:21.040
there are sets.

00:42:21.740 --> 00:42:24.760
And when the flow control
situation is lifted,

00:42:24.760 --> 00:42:28.330
you're going to select "will wake
up" and the bit will be set for

00:42:28.330 --> 00:42:32.930
that file descriptor saying "now
you can send data". And finally,

00:42:32.930 --> 00:42:36.460
exception is used for out-of-band data.

00:42:36.460 --> 00:42:39.270
That's how you can be,
if your protocol is

00:42:39.280 --> 00:42:45.860
using TCP expedited data,
you will be notified that expedited

00:42:45.860 --> 00:42:50.230
data is available if this bit is set.

00:42:50.360 --> 00:43:16.710
The Stephen's book has a
great deal of explanation.

00:43:18.780 --> 00:43:24.940
One important thing to know is that
the BSD implementation of SELECT is

00:43:24.940 --> 00:43:29.300
used by many Unix derivatives.

00:43:29.300 --> 00:43:36.370
But with BSD-like systems,
the SELECT handles non-blocking connect.

00:43:36.390 --> 00:43:40.400
So when you're making a connection,
you don't have to block your thread

00:43:40.480 --> 00:43:42.530
until the connection is complete.

00:43:42.540 --> 00:43:46.680
You can just set the file
descriptor to non-blocking.

00:43:46.750 --> 00:43:52.310
And the SELECT will wake up
when the connection is complete.

00:43:52.410 --> 00:43:56.000
That is not obvious because
not all the Unix support that,

00:43:56.000 --> 00:43:58.760
but Darwin, we have that,
and it's very useful.

00:43:58.760 --> 00:44:01.920
And again, the Open Transport Framework
is using that.

00:44:01.940 --> 00:44:06.680
That means that while OT Connect is
non-blocking in Carbon.

00:44:08.810 --> 00:44:21.310
So now we're going to go through
another list of the hints and the tips.

00:44:21.340 --> 00:44:23.810
Especially if you are
performance conscious,

00:44:23.810 --> 00:44:30.200
and we would like you to
be performance conscious,

00:44:30.200 --> 00:44:30.200
is that

00:44:31.850 --> 00:44:39.590
The most important thing that's going to
kill performance on Mac OS X is polling.

00:44:39.590 --> 00:44:42.800
Polling makes use of 100% of the CPU.

00:44:42.800 --> 00:44:45.800
So if you run the top
command from a shell script,

00:44:45.800 --> 00:44:51.880
you can see if your process
application is using 100% of the CPU,

00:44:51.880 --> 00:44:52.800
it means that it's polling.

00:44:52.800 --> 00:44:54.860
And it's very common to poll.

00:44:54.880 --> 00:44:57.700
So there are many different ways to poll.

00:44:57.840 --> 00:45:01.330
For example,
using wait_next_event with a timeout

00:45:01.330 --> 00:45:04.800
of 0 is a way to poll because the
thread is going to run constantly.

00:45:04.800 --> 00:45:07.560
But many,
many times when you're doing I/O,

00:45:07.560 --> 00:45:08.750
you tend to poll.

00:45:08.830 --> 00:45:11.800
And something that you could
get away with on Mac OS,

00:45:11.800 --> 00:45:16.800
the classic Mac OS,
is not going to work well on 10.

00:45:16.800 --> 00:45:22.800
So it hurts other processors
because it steals CPU cycle away.

00:45:22.800 --> 00:45:25.710
And it uses more power.

00:45:25.800 --> 00:45:28.800
So we are energy conscious in California.

00:45:28.800 --> 00:45:31.750
So it's not only because
it's going raw power,

00:45:31.750 --> 00:45:34.800
but also it's very
important for notebooks.

00:45:34.800 --> 00:45:41.790
Many of you have because if
you're blocking one of the,

00:45:41.800 --> 00:45:46.790
and if there's no activity in the CPU,
a thread is going to run in the

00:45:46.790 --> 00:45:48.800
kernel that's the idle thread.

00:45:48.800 --> 00:45:52.800
And that's the one that's going to
trigger the conservation mode of the CPU.

00:45:52.800 --> 00:45:57.790
So the power piece is going to
put the chip in doze or nap mode

00:45:57.790 --> 00:46:00.800
according to the level of inactivity.

00:46:00.800 --> 00:46:04.990
So that's not the real sleep, you know,
that's not going to trigger the

00:46:04.990 --> 00:46:07.580
sleep like the sleep command.

00:46:07.800 --> 00:46:13.800
But still it's going to affect
the battery life of notebooks.

00:46:13.940 --> 00:46:17.800
So the model for Mac OS X is blocking.

00:46:17.800 --> 00:46:21.800
So you block your threads
and wait for an event.

00:46:23.070 --> 00:46:25.960
Use blocking threads.

00:46:26.010 --> 00:46:27.940
If you use threads,
what we've seen sometimes is

00:46:27.940 --> 00:46:31.080
that people tend to still use,
for example,

00:46:31.080 --> 00:46:36.900
cooperative threads or MP threads,
but they still have some polling loop.

00:46:36.900 --> 00:46:43.560
So they are just going, before calling,
instead of blocking in an OT receive,

00:46:43.570 --> 00:46:49.620
they are going to have a little while
loop there to check for some flag.

00:46:49.620 --> 00:46:55.230
And that's not going to do any good
because if you're putting in an

00:46:55.240 --> 00:47:04.940
MP thread or in a regular P thread,
you're going to use 100% of the CPU.

00:47:05.700 --> 00:47:15.800
[Transcript missing]

00:47:16.010 --> 00:47:20.100
Maybe it won't be good
to use many many threads.

00:47:20.100 --> 00:47:22.550
Threads is a resource.

00:47:22.560 --> 00:47:28.200
It has a stack, it has a scheduling,
it gets into the scheduler.

00:47:28.200 --> 00:47:34.380
So instead, if for your application you
are using many many endpoints,

00:47:34.380 --> 00:47:37.600
like maybe a server,
you should multiplex.

00:47:37.600 --> 00:47:41.730
So you should use the select
routine if you are using BSD,

00:47:41.730 --> 00:47:44.800
and otherwise use notifier for Carbon.

00:47:49.090 --> 00:47:51.240
So again, so buffer size.

00:47:51.240 --> 00:47:56.380
And that really applies
both for Carbon and sockets.

00:47:56.380 --> 00:48:01.790
That's an important,
very important aspect of the performance

00:48:01.880 --> 00:48:05.660
for networking application on Mac OS X.

00:48:05.700 --> 00:48:10.240
So there are--

00:48:11.900 --> 00:48:15.440
For example,
we saw that some Carbon applications

00:48:15.440 --> 00:48:21.750
that have been imported
have one or the other of the

00:48:23.300 --> 00:48:27.540
Use buffer sizes that are
wrong in opposite ends.

00:48:27.570 --> 00:48:30.500
Some of them are using too small buffers.

00:48:30.500 --> 00:48:38.080
So the pathological case is to call
OT receive for one character at a time.

00:48:38.080 --> 00:48:41.160
That's going to-- you're going
to have a lot of switch between

00:48:41.160 --> 00:48:43.160
user space and the kernel.

00:48:43.160 --> 00:48:46.820
And that's an expensive operation.

00:48:46.830 --> 00:48:51.640
And so instead, you should-- and frankly,
if you're doing something like

00:48:51.640 --> 00:48:57.310
a telnet-like and at very,
very low throughput,

00:48:57.310 --> 00:49:00.600
you can get away with.

00:49:00.600 --> 00:49:05.410
But usually-- but that would be really
the only-- and it would because it

00:49:05.410 --> 00:49:08.580
simplifies maybe your state machine.

00:49:08.580 --> 00:49:14.960
But otherwise, I would really encourage
you to use larger buffers.

00:49:14.960 --> 00:49:18.900
On the other end,
if you pass too large buffers,

00:49:18.900 --> 00:49:24.010
you're going-- so not only are you
going to get in flow control situation

00:49:24.030 --> 00:49:28.010
that are sometimes difficult to handle,
but you're also going to

00:49:28.110 --> 00:49:29.600
start the VM for buffers.

00:49:29.670 --> 00:49:35.940
So it's-- so you should
pay attention to that.

00:49:35.940 --> 00:49:40.150
You should pay attention not only
to the size of the buffer you pass

00:49:40.240 --> 00:49:47.840
to the send and receive codes,
but also to get the right-- I mean,

00:49:47.920 --> 00:49:50.140
the appropriate size
for the socket buffer,

00:49:50.140 --> 00:49:52.320
the size of the buffer that
the kernel is going to use.

00:49:52.320 --> 00:50:02.300
So the question is,
so what is the correct buffer size?

00:50:02.320 --> 00:50:04.480
Unfortunately, there's not--

00:50:18.530 --> 00:50:18.530
Thank you, Vincent.

00:50:18.530 --> 00:50:18.530
I think that was a very
simple reply to that question.

00:50:18.530 --> 00:50:18.530
It really depends on many factors.

00:50:18.530 --> 00:50:18.530
It depends on the bandwidth
to the destination.

00:50:18.530 --> 00:50:18.530
If your application is

00:50:18.630 --> 00:50:22.890
It's really going to be
mainly used on the LAN.

00:50:22.890 --> 00:50:27.200
I would recommend that you increase,
for example, the socket buffer size.

00:50:27.300 --> 00:50:36.500
Because, for example, over gigabit,
you have a lot of bandwidth and

00:50:36.500 --> 00:50:39.200
using large buffer size is going to

00:50:40.270 --> 00:50:45.280
to decrease the number of context
switches and overall the Ethernet driver

00:50:45.280 --> 00:50:48.480
will be able to pump the data very,
very fast.

00:50:48.480 --> 00:50:52.070
But if you're using large
buffer size over a PPP link,

00:50:52.080 --> 00:50:56.960
for example, if your application,
maybe you think it's going to be used

00:50:56.960 --> 00:51:02.470
over the Internet by a client using PPP,
using two large socket buffers means that

00:51:02.480 --> 00:51:07.520
you're going to just have data sitting
there in the kernel for no good use.

00:51:07.520 --> 00:51:09.180
So it's going to be a very,
very difficult task.

00:51:09.910 --> 00:51:16.140
To steal some wired memory away from
maybe other processes or application.

00:51:17.090 --> 00:51:19.510
And also it depends on the protocol.

00:51:19.510 --> 00:51:19.510
So

00:51:19.900 --> 00:51:25.220
For bulk data transfer, normally,
of course, larger is better.

00:51:25.220 --> 00:51:28.020
But for transaction,
maybe you're more looking

00:51:28.020 --> 00:51:29.680
at responsiveness.

00:51:29.680 --> 00:51:37.900
And having too large buffers may
hurt the interactivity there.

00:51:37.900 --> 00:51:39.600
It depends also on the number of clients.

00:51:39.600 --> 00:51:44.780
So if you're a server, again,
and if you're serving a very

00:51:44.780 --> 00:51:48.300
large number of clients,
I would recommend that you don't

00:51:48.300 --> 00:51:49.740
use too large second buffers.

00:51:49.740 --> 00:51:56.290
Because, again, if you have many,
many clients using large buffer size,

00:51:56.290 --> 00:52:01.360
you're going to increase the
amount of wired memory use.

00:52:01.360 --> 00:52:06.550
And overall, there will be more paging
and less-- and in the kernel,

00:52:06.550 --> 00:52:10.390
less wired memory to be used
maybe for the drivers or

00:52:10.390 --> 00:52:12.980
other layers of the system.

00:52:13.010 --> 00:52:19.680
So the important thing is that
you have to analyze the need.

00:52:19.690 --> 00:52:20.560
It's not always easy.

00:52:20.560 --> 00:52:21.430
We all recognize that.

00:52:21.490 --> 00:52:26.680
But you have to analyze the need
specific to your application.

00:52:26.680 --> 00:52:32.040
And still,
there is many application what they do.

00:52:32.040 --> 00:52:34.640
For example, they download files.

00:52:34.640 --> 00:52:41.910
And they're going to set the
file for a cache or on the disk.

00:52:42.810 --> 00:52:47.170
Also, we've seen that with many
networking applications that kind

00:52:47.180 --> 00:52:49.080
of feel sluggish on Mac OS X.

00:52:49.080 --> 00:52:55.250
And it's not because they don't use the
right parameter on the networking side,

00:52:55.260 --> 00:52:58.220
but it's just because they
write in too small chunks,

00:52:58.220 --> 00:52:58.940
too disk.

00:52:58.960 --> 00:53:04.940
And typically,
we recommend that here it's also,

00:53:04.940 --> 00:53:08.090
I guess,
if you talk to the file system guys,

00:53:08.100 --> 00:53:10.050
they will tell you, oh,
it's more complicated than that.

00:53:10.140 --> 00:53:13.570
But a good rule of thumb is
to use something like 32K to

00:53:13.570 --> 00:53:17.910
buffer in your application,
32K before calling the

00:53:17.930 --> 00:53:20.260
write to write to disk.

00:53:23.080 --> 00:53:28.360
Also, an important aspect of Mac OS X is
that it's multi-homing.

00:53:28.400 --> 00:53:31.870
So it has several implications.

00:53:31.870 --> 00:53:38.610
And it's kind of an
FAQ from the Carbon list.

00:53:38.990 --> 00:53:42.400
The system does not have
a single IP address.

00:53:42.580 --> 00:53:50.800
The presence of an IP address
doesn't mean that you are able to

00:53:50.800 --> 00:53:54.080
connect to the internet or not.

00:53:54.080 --> 00:54:01.260
It may be that TCP/IPs
IP addresses change over time,

00:54:01.260 --> 00:54:06.080
so do not cache IP addresses
over a long period of time.

00:54:06.080 --> 00:54:11.860
For example, for FTP clients,
your application will

00:54:12.030 --> 00:54:18.920
be up most of the time,
but the IP address may change.

00:54:19.060 --> 00:54:22.840
Don't cache the IP address,
just call the available API,

00:54:22.840 --> 00:54:29.300
get_sock_name for BSD or get_prot_address
for OpenTransport Carbon.

00:54:29.510 --> 00:54:35.570
Multihoming means that if you
bind to a specific address,

00:54:35.580 --> 00:54:41.400
you will be able to send and
receive data only for that address.

00:54:41.410 --> 00:54:49.400
Certainly in a multihoming environment,
many server configurations on purpose

00:54:49.400 --> 00:54:52.400
have several interfaces active at a time.

00:54:52.400 --> 00:54:56.400
For example, MultiPort, Ethernet,
and Carb.

00:54:56.400 --> 00:54:56.400
They all have a different IP address.

00:54:56.400 --> 00:55:02.400
And certainly you don't want to
limit access to just one interface.

00:55:02.550 --> 00:55:07.400
So servers should bind to any IP address.

00:55:07.400 --> 00:55:14.400
They are both available, constant,
in the BSD and Carbon OpenTransport.

00:55:14.670 --> 00:55:19.400
And usually for clients,
they really should bind to nil.

00:55:19.400 --> 00:55:21.400
They are very, very little.

00:55:21.400 --> 00:55:24.390
There are a few exceptions.

00:55:24.410 --> 00:55:27.400
It may depend on the
protocol you're relying on.

00:55:27.400 --> 00:55:32.540
But usually the typical call
for OpenTransport is you call

00:55:32.540 --> 00:55:35.510
otbind and it passes nil.

00:55:35.760 --> 00:55:38.850
For sockets,
you just don't have to call bind.

00:55:38.900 --> 00:55:42.880
You can just write the connect.

00:55:42.900 --> 00:55:45.910
After you create your socket,
you can just call connect.

00:55:45.910 --> 00:55:52.570
The connect call will automatically pick
up an ephemeral port if you use TCP,

00:55:52.570 --> 00:55:53.900
IP, or UDP.

00:55:58.100 --> 00:56:20.400
[Transcript missing]

00:56:20.510 --> 00:56:25.020
So the idea is not to,
if you're downloading and if you

00:56:25.160 --> 00:56:29.100
want to provide some feedback to the
user about maybe the amount of data

00:56:29.100 --> 00:56:33.870
that is downloaded all the time,
do not update the HI every

00:56:33.870 --> 00:56:35.480
time you get a packet.

00:56:35.480 --> 00:56:38.320
That's much too fast.

00:56:38.320 --> 00:56:39.690
Usually it's much too fast.

00:56:39.700 --> 00:56:46.080
So maybe it's okay, you know,
if you only over PPP you will get

00:56:46.080 --> 00:56:49.480
data at a relatively low rate.

00:56:49.880 --> 00:56:54.610
But if you start to run your
application on a LAN with Ethernet,

00:56:54.740 --> 00:57:00.210
you will see that your application
just spends time updating the amount

00:57:00.210 --> 00:57:04.170
of data or running a little icon or
running a dog or something like that.

00:57:04.240 --> 00:57:06.940
So it's very costly.

00:57:06.940 --> 00:57:10.590
So instead you should use
reasonable delays that are more

00:57:10.590 --> 00:57:12.720
based on the user perception.

00:57:12.720 --> 00:57:17.620
If you see numbers
flashing over your eyes,

00:57:17.620 --> 00:57:22.240
it's not going to bring... It's not
going to bring a lot of information.

00:57:25.500 --> 00:57:27.400
What's a reasonable delay?

00:57:27.400 --> 00:57:30.610
I'm not an expert in
human universe design,

00:57:30.610 --> 00:57:34.090
but if I remember well,
something like something visible,

00:57:34.130 --> 00:57:40.560
you know, something at a rate higher than
50 or 60 hertz is too fast.

00:57:40.560 --> 00:57:46.890
So, and if you think of it, you know,
updating an account, you know,

00:57:46.940 --> 00:57:52.710
at something higher than maybe two
or three times a second is too much.

00:57:52.710 --> 00:57:55.060
And the same for the sliders, you know,
they can,

00:57:55.140 --> 00:58:03.380
they may be more smoother if you choose,
if you pass the rate of the HCI,

00:58:03.380 --> 00:58:05.780
of the update.

00:58:06.940 --> 00:58:07.460
The list.

00:58:07.500 --> 00:58:11.970
So if you came the previous year, we had,
especially for Mac OS,

00:58:11.970 --> 00:58:15.200
the classic Mac OS networking,
we had a long list of all the

00:58:15.200 --> 00:58:17.660
things that we were working on.

00:58:17.660 --> 00:58:23.400
And here in Mac OS X, so we were starting
the list from scratch.

00:58:23.400 --> 00:58:26.430
That means that we
have an implementation,

00:58:26.430 --> 00:58:30.250
a product already out,
but we have already some ideas,

00:58:30.250 --> 00:58:33.240
we got some feedback,
and there are stuff we

00:58:33.340 --> 00:58:35.360
would like to do on our own.

00:58:35.360 --> 00:58:41.030
But really what we need and what we'd
like to hear from you and from our user

00:58:41.030 --> 00:58:44.380
is the things we should add or improve.

00:58:44.380 --> 00:58:50.180
So the list is currently blank,
and certainly next year it will be

00:58:50.180 --> 00:58:53.200
filled with a lot of neat stuff.

00:58:54.880 --> 00:58:59.080
I'm going to briefly
talk about the future,

00:58:59.180 --> 00:59:02.090
so what we have in the plan.

00:59:02.220 --> 00:59:06.710
If you came in the last two
years and you've heard us

00:59:06.760 --> 00:59:13.910
talking about IPv6 and IPsec,
and they are still in our plan,

00:59:14.300 --> 00:59:19.470
If you're familiar with Darwin,
you can see that we have the Kame

00:59:19.470 --> 00:59:22.300
implementation of IPv6 and IPsec.

00:59:22.310 --> 00:59:23.500
So that's what we're using.

00:59:23.500 --> 00:59:29.400
If you... You will see that it's...

00:59:30.300 --> 00:59:31.420
It's relatively easy.

00:59:31.420 --> 00:59:35.990
Last year we had a package
that you could install on DP2,

00:59:35.990 --> 00:59:39.580
if I remember well,
where you could install IPv6 and IPsec.

00:59:39.580 --> 00:59:43.680
But building a Darwin kernel
became so easy that maybe that's,

00:59:43.680 --> 00:59:47.420
if you're really interested,
that's something that you can tackle.

00:59:47.420 --> 00:59:53.420
What we're missing there
is really the higher level.

00:59:53.420 --> 00:59:56.340
So the library, the HI is not there.

00:59:56.470 --> 00:59:59.940
So that's one of the main
reasons why we were not able

01:00:00.040 --> 01:00:02.480
to put that in Mac OS X 1.0.

01:00:02.500 --> 01:00:06.140
Another thing that we're
working on is ZeroConf.

01:00:06.170 --> 01:00:10.810
So ZeroConf is an IETF...

01:00:12.150 --> 01:00:19.530
RFC Maybe Stuart That allows,
provides to the TCP/IP some of the

01:00:19.530 --> 01:00:23.360
great benefits of Apple Talk which
are automatic configuration.

01:00:23.410 --> 01:00:28.340
It means that once we have
zero conf in Mac OS X,

01:00:28.340 --> 01:00:35.660
you will be able to plug to PC and
they will acquire address automatically

01:00:35.660 --> 01:00:42.360
and you will be able to exchange data
with your peer without any interaction.

01:00:42.360 --> 01:00:46.940
We are also still,
one of the ongoing goals

01:00:46.940 --> 01:00:49.460
is performance tuning.

01:00:49.460 --> 01:00:53.660
So we are just going to
continue to work on that.

01:00:53.660 --> 01:01:00.800
Better extensibility and also
something very important is the

01:01:00.900 --> 01:01:03.660
replacement for the network setup API.

01:01:03.660 --> 01:01:07.030
And if you come to... to
this afternoon session,

01:01:07.050 --> 01:01:10.660
3:03, we will talk about that.

01:01:10.660 --> 01:01:12.160
Which platform do you appear in?

01:01:12.210 --> 01:01:14.560
It's called...

01:01:17.210 --> 01:01:21.500
So the session maybe is the next slide.

01:01:21.500 --> 01:01:23.690
So OK.

01:01:23.770 --> 01:01:26.860
It's called Network Configuration
and Mobility.

01:01:29.520 --> 01:01:30.080
So let me back up.

01:01:30.100 --> 01:01:31.610
We'll come back here.

01:01:31.720 --> 01:01:36.410
So we have a number of additional
resources available on the web.

01:01:36.410 --> 01:01:41.170
So of course,
the developer page for Mac OS X.

01:01:41.170 --> 01:01:44.110
A lot of information.

01:01:44.160 --> 01:01:47.930
For classic networking and Carbon,
there's a lot of information

01:01:47.930 --> 01:01:50.340
in the open transport page.

01:01:50.500 --> 01:01:54.420
So if you're carbonizing,
you will see a lot of link.

01:01:54.420 --> 01:01:58.000
It would be a good starting point
to get a link of information.

01:01:58.500 --> 01:02:06.320
So,
Darwin is a good source of information.

01:02:06.320 --> 01:02:06.320
And there's a...

01:02:06.840 --> 01:02:12.610
An active community there and if
you subscribe to the development

01:02:12.620 --> 01:02:16.230
list you will see that there's a
lot of interest from developers,

01:02:16.230 --> 01:02:17.700
a lot of people contribute to Darwin.

01:02:17.700 --> 01:02:23.920
And finally because of the
roots of the networking stacks,

01:02:23.920 --> 01:02:30.700
also in the FreeBSD site you will
see a lot of information that maybe

01:02:30.700 --> 01:02:34.280
if you need to use some tools,
some mind page or some how-tos, how to's,

01:02:34.280 --> 01:02:38.370
you will see a lot of
information on the FreeBSD site.

01:02:39.790 --> 01:02:42.460
Finally, the related sessions.

01:02:42.460 --> 01:02:45.240
So 300, that's this session.

01:02:45.240 --> 01:02:48.010
Networking in the Kernel,
that's a session that we're going to

01:02:48.010 --> 01:02:54.160
have just after this in the room J2,
the opposite side of the building.

01:02:54.160 --> 01:03:00.750
Network Configuration and Mobility,
that's a very interesting session.

01:03:01.070 --> 01:03:05.600
And on Thursday at 10:30 we're
going to have the feedback forum.

01:03:05.600 --> 01:03:09.870
So for all the questions we
couldn't answer today in the Q&A,

01:03:09.870 --> 01:03:13.350
please come back and talk to us there.

01:03:14.800 --> 01:03:22.060
Web Enabling Your Applications for
high-level URL-oriented APIs Thursday at

01:03:22.060 --> 01:03:32.700
5:00 pm Sound on Networking for Games J2
Friday If you are a game developer,

01:03:32.700 --> 01:03:34.700
you should attend this session.

01:03:34.700 --> 01:03:39.700
That's a wrap-up of this session.
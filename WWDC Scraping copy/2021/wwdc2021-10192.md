# Wwdc2021 10192

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

What‘s new in SwiftJoin us for an update on Swift. Discover the latest language advancements that make your code easier to read and write. Explore the growing number of APIs available as Swift packages. And we'll introduce you to Swift's async/await syntax, structured concurrency, and actors.ResourcesDiversity in SwiftDocCPackage CollectionsSwift Algorithms on GitHubSwift Argument Parser on GitHubSwift AWS Lambda Runtime on GitHubSwift Collections on GitHubSwift Compiler Driver on GitHubSwift EvolutionSwift ForumsSwift Mentorship ProgramSwift Numerics on GitHubSwift Package IndexSwift System on GitHubThe Swift Programming Language: ConcurrencyHD VideoSD VideoRelated VideosWWDC21Build interactive tutorials using DocCDiscover and curate Swift Packages using CollectionsElevate your DocC documentation in XcodeExplore structured concurrency in SwiftHost and automate your DocC documentationMeet async/await in SwiftMeet DocC documentation in XcodeMeet the Swift Algorithms and Collections packagesProtect mutable state with Swift actorsSwift concurrency: Behind the scenesWhat's new in SwiftUIWrite a DSL in Swift using result buildersWWDC20Explore numerical computing in SwiftUse Swift on AWS Lambda with Xcode

Join us for an update on Swift. Discover the latest language advancements that make your code easier to read and write. Explore the growing number of APIs available as Swift packages. And we'll introduce you to Swift's async/await syntax, structured concurrency, and actors.

Diversity in Swift

DocC

Package Collections

Swift Algorithms on GitHub

Swift Argument Parser on GitHub

Swift AWS Lambda Runtime on GitHub

Swift Collections on GitHub

Swift Compiler Driver on GitHub

Swift Evolution

Swift Forums

Swift Mentorship Program

Swift Numerics on GitHub

Swift Package Index

Swift System on GitHub

The Swift Programming Language: Concurrency

HD VideoSD Video

HD Video

SD Video

Build interactive tutorials using DocC

Discover and curate Swift Packages using Collections

Elevate your DocC documentation in Xcode

Explore structured concurrency in Swift

Host and automate your DocC documentation

Meet async/await in Swift

Meet DocC documentation in Xcode

Meet the Swift Algorithms and Collections packages

Protect mutable state with Swift actors

Swift concurrency: Behind the scenes

What's new in SwiftUI

Write a DSL in Swift using result builders

Explore numerical computing in Swift

Use Swift on AWS Lambda with Xcode

Search this video…♪ ♪Hi! I'm Nicole, and welcome to "What's new in Swift."Swift 5.5 is our best release yet!The Swift language continues to evolve at a rapid pace,with many new features, including Swift Concurrency,a new model for asynchronous and concurrent programmingdesigned to make concurrent programming in Swiftconvenient, efficient, and safe.In addition, we've made it easier than everto develop in Swift, thanks to advancesin the package experience, new standard library packages,and features enhancing the developer experience.As important as these advances are,the heart of the Swift project is not code,but a community of peopleworking towards the goals of the Swift project.This is why it is important that we investin our community, as well as our software.I'd like to start things off by talking aboutan important Swift community initiative.Diversity is a core value of the Swift community.Research shows that diverse open source projectsare more productive and make better decisions.Including people from all backgroundsand with diverse perspectives helps a community thrive.We, and other members of the Swift community,saw the opportunity to encourage active engagementin the Swift ecosystem and community from a wider rangeof developers with our Diversity in Swift initiative.The mission of Diversity in Swift is to fosteran inclusive Swift communityby elevating a wide variety of voicesand making it easier for developers to start learningor contributing to Swift, regardless of their background.As part of this initiative,we have expanded the swift.org blogto include posts that recognize and highlight the contributionsfrom a wide range of developers within our community.We have also created community groupsin the Swift forums for developers to connectwith others who may have had similar experiencesor faced similar barriers.To get involved with Diversity in Swift,or find out more,please visit swift.org/diversity.We also want to help developers already in the communitygrow and reach their goals with Swift.To make contributing to Swift open source projectsmore approachable, we recently announcedthe Swift mentorship program to help newcomers getdirect support and guidance from regular contributors.This program isn't limited to Apple's projects.It also encompasses the entire ecosystemof Swift packages and open source tools.Next, I'd like to talk about packages.Packages are a fundamental building blockfor building software, allowing youto conveniently take advantage of an ever-growing arrayof open source code.Members of the Swift communityhave come up with some great solutionsto help developers find packages,like the Swift Package Index.The Swift Package Index is a pagecreated by the community that helps you findpackages which support the Swift Package Manager.Now, in Swift 5.5 and Xcode 13, we are providingadditional ways for you to find and access packages,by providing integrated Xcode tooling supportto make it even faster and easier to use packagesin your project as part of your development workflow.This year, we are introducing Swift Package Collections,curated lists of Swift packages you can useboth from the command line and from Xcode 13.With package collections, you no longer need to searchfor packages on the Internet,or copy and paste URLs to add them.You can now simply browse a collection and add packagesfrom a new package search screen in Xcode.Package collections are simple JSON filesyou can publish anywhere.Package collections are meant to allow anyone to buildcurated lists of packages for different use cases.For example, an instructor for a computer science classcan put together a set of packagesthat helps teach the concepts of that class,or someone can put together a collection of packagesthat are good for a particular domain or task,or that are used by their organization.We're excited to see all the different waysin which people will use collections.We have a great presentation on package collectionsthat I recommend you check out to learn more.Package collections includesome powerful tooling support in Xcode.You are now just an import away from using your favorite APIs.When you try to import a module that cannot be found,Xcode will check if any of the packagesin the package collections that you have configuredprovide that module and provide you the opportunityto automatically start using that package.Once you choose to use a package,all configuration is handled for youbased on the information in the package collection.Package collections are also searchable,making it easy to find packages to meet your use case.If you are interested in trying out package collections today,there are some already available,including a package collection of the Swift Packagesthat Apple publishes on GitHub.Xcode comes pre-wired to use the Apple collection.If you are interested in learning moreabout package collections, including collectionsalready available from the community,check out the new swift.org blog poston package collections.Speaking of your favorite APIs, Apple publishesa growing family of open source Swift packages.In addition to some big enhancementsto your favorite packages, this year,we launched four more new packages.First, I'd like to tell you about Swift Collections.Swift Collections is a new open source packageof data structures that complements those availablein the Swift Standard Library.The initial version of Swift Collectionscomes with implementations for threeof the most frequently requested data structures:Deque, OrderedSet, and OrderedDictionary.Deque is like an Array, except that it supportsefficient insertion and removal at both ends.OrderedSet is a powerful hybrid of an Array and a Set.Like Array, OrderedSet maintains its elements in orderand supports random access.Like a Set, OrderedSet ensures each elementappears only once and provides efficient membership testing.And last is OrderedDictionary, which is a useful alternativeto Dictionary when order is important,or we need random access to elements.Next, let's talk about Swift Algorithms.Swift Algorithms is a new open source packageof Sequence and Collection algorithms.We've already added over 40 algorithms to Swift Algorithmsfor things like generating all the combinations or permutationsof a collection of elements, or iterating the elementsof a sequence by two or three or in groupsdetermined by a predicate,or selecting the five smallest elements in a collection,the five largest, or just any five at random.It takes a little investment to learn the vocabulary,but once you do, it can be striking to discoverjust how many algorithms are hiding in plain sight.If you want to learn more, we have a sessionwhich describes how the new Swift Algorithmsand Collections packages can help you make your codeclearer, faster, and more correct.Now, let's talk about Swift System.Last fall, we open-sourced Swift System,a library providing idiomatic,low-level interfaces to system calls.System is available on Apple platforms,Linux, and even Windows.We recently added powerful new APIsto System's FilePath typefor performing common path manipulation operations.These include the ability to query or set extensions,add and remove components, and perform path normalization.A path can be decomposed into its rootand its relative components.FilePath's ComponentView is a collectionof structured path components, meaning it comes with supportfor many of Swift's generic algorithms right out of the box.And when targeting Windows, Windows paths,with their complex root components,are fully supported by all the new FilePath APIs.Next, let's talk about Swift Numerics.Swift Numerics received a number of big additions this year.We brought Float16 to iOS, tvOS, and watchOS last year.This year, we added Float16 support to Apple Silicon Macsand the ability to make Float16-based complex numbers.Another addition this year is complex number supportfor all the elementary functions,like log, sine, and cosine.Because these implementations are written in Swift,they are frequently more efficientthan a traditional C library and allow for optimizationsthat would otherwise not be possible.Finally, let's talk about Swift ArgumentParser.We've continued to refine Swift ArgumentParser this year,with enhancements like the ability to generatecode-completion scripts for the Fish shell,joined short options, and improved error messages.We also passed an important milestonethis spring when ArgumentParser was adoptedby the Swift Package Manager in Xcode 12.5.That's right!If you've used the Swift Package Managercommand-line tool recently,you've used Swift ArgumentParser.Next, I'd like to talk about some work we've doneto support Swift on server development.Last year, we added support for a number of platforms,including Amazon Linux.This year, we've followed up on that work by investingin performance and functionality for Swift server applications.We started by enabling static linking on Linux,which improves application startup time,as well as simplifies the deploymentof server applications,which can now be deployed as a single file.Also, in Swift 5.5, the JSON encoding and decodingused on Linux were reimplemented from scratch,resulting in performance gains for most common use cases.Finally, we've enhanced and optimized the performanceof the AWS Lambda runtime library itself.All this work made Swift programs running on AWS Lambdastart 33% faster,as well as 40% faster invocation timefor a lambda routed via AWS API Gateway.In addition to optimizingthe AWS runtime library performance,we refactored it to use our new async/await modelinstead of closures.Improving the Swift developer experienceis another key focus in Swift 5.5.I'd like to start by talking about documentation.Providing great documentation is key for creating a smoothand enjoyable experience for users of a framework.This year, we are introducing DocC,a documentation compiler that's deeply integratedinside Xcode 13, to help you teach developershow to use your Swift framework or package.It's now easier than ever to write and sharegreat documentation.DocC is built from the ground up,using tools and technologies that you already know and love,such as markdown comments in your Swift source code,so that you can easily write and diff your documentation.We have four fantastic sessions to show youevery aspect of DocC documentation in Xcode.I highly recommend you check them out.And now, I'm thrilled to announcethat Swift DocC will be open-sourced later this year.Open-sourcing Swift DocC will allow developersto more easily generate great documentationon all of Swift's supported platforms.In Swift 5.5, we invested in qualityand performance improvements in the type checker.One result of this is you will see fewer"expression too complex" errors when compiling your code.We also sped up the performancefor type checking of array literals.In this release, we're also enhancing developer productivitywith three major improvements to speed up incremental builds.First of all, we now support incremental imports,meaning we now no longer rebuild every source filethat imports a module when that module changes.In addition, we now computethe module dependency graph up frontso that we can quickly start incremental buildsof only what has changed.Finally, we've extended selective recompilationto work with extensions, meaning fewer recompilationswhen you change the body of an extension.Using the SwiftDriver open source project as an example,on the average, with incremental importsin Swift 5.5, we now recompileless than a tenth as many files when imported modules change,and the build time is decreased by about a third.The performance improvements from incremental importsmeans that you can now modularize your projectand change an imported modulewithout a large penalty in build performance.And by the way, some of these performance improvementswere made possible by an important milestonefor the Swift project,the first part of the compiler to be written in Swift.This is the Swift Driver, the program that coordinatesthe compilation of Swift source code.This project began in late 2019 and, as of Xcode 13,is now the default for Swift compilation.Finally, let's talk about improvements we've madeto make memory management in Swift more efficient,so Swift programs reclaim memory more quickly.Swift class instances useAutomatic Reference Counting, ARC,to track how many references there areto a particular object at any given time.In most cases, this means that memory managementjust works in Swift, and you don't needto think about memory management yourself.ARC automatically frees upthe memory used by class instanceswhen those instances are no longer needed.To do this, the Swift compiler inserts a retain operationany time a new reference is createdand a release operationwhenever a new reference stops being used.This year, we introduced a new wayto track references inside the compilerthat allows the compiler to significantly reducethe number of retain and release operations.We've seen measurable performance and code sizeimprovements from this change.We've added an Xcode setting, Optimize Object Lifetimes,that will allow you to see the effect of this new,more aggressive ARC optimization on your code.For more information on ARC,please check out the "ARC in Swift" session.These are just some of the improvementsbrought to you by Swift 5.5.Next, Tim will talk to you about Swift Concurrencyand other evolutions in the Swift language.Thanks, Nicole.We're all very excited about Swift Concurrency,but before I get to that, I want to discuss a numberof other changes we've made to Swiftto simplify and improve everyday programming.Here's a list of the ergonomic improvementswe've made this year.The SE numbers identify Swift Evolution proposals.Each of these proposals was written by a memberof the community, discussed on the Swift Evolution forum,and approved by the Swift Core Teambefore being accepted into the language.All SE proposals, whether accepted, rejected,or still in discussion, can be foundin the Swift Evolution repository on GitHub.Let's look at a few of these changes.First, Result Builders.When SwiftUI was first announced,it introduced a new syntax that could be usedto quickly and easily describe complex object hierarchies.This past year, that syntax was standardized and refinedthrough the Swift Evolution process so that it could bemore easily used in a wide variety of contexts.If you'd like to take advantage of this powerful technology,we have a session specifically devotedto using Result Builders.The Codable protocolis a convenient way to serialize your data,but it's long suffered from a notable omission.Consider this two-case Enum.In order to make it conform to Codable, you used to haveto manually implement all of this boilerplate.Now, you just need to declare the Codable conformance,and the compiler will do all of that work for you.We also made some key improvementsto Swift's type checker.As you know, type inference in Swiftmeans you can omit redundant type information.Here, it lets you shorten Coffee.regulardown to just .regular.But Enum-like structures are also represented in other ways.For example, you might have a collection of typesthat conform to a protocoland want to use instances of those types in your API.You can now refer to instances of those typesusing the same dot-notation that you use for Enums,by declaring a few static properties on your protocol.This is enabled by improvements to Swift's type checkerthat allows it to reason more generallyabout static properties in generic contexts,including chained property referencessuch as the .large here.This allows library authors to build sophisticated genericdata models with natural and easy-to-use Enum-like APIs.Property wrappers were also improved this year.Property wrappers are a convenient toolfor applying common semantics to properties.Many of you have implemented your own property wrappersusing the @propertyWrapper annotation on a struct.Here's an example that adds the requirementthat the property not be empty.With the implementation of SE-0293,those same property wrappers can now be usedon function and closure parameters.Cumulatively, these and other changesto the language can simplify a lot of common coding problems.Let's look at them together in the contextof a simple SwiftUI code sample.Here's a SwiftUI View that has a single property,holding an array of settings, and a body that presentsa list of those settings, with a toggle next to each one.Let's review this code and see howthe new Swift 5.5 features can simplify it.First, that Toggle() initializer is obviously duplicated.This duplication used to be necessary,but we've relaxed the use of #if to allow it to surroundpostfix expressions, such as the toggleStylemodifiers here, which allows usto factor out that redundancy.SwiftUI has also been updated to take advantage of the newtype checker improvements I mentioned earlier.So you can use natural dot-notationin many more places.It's--it's a little awkwardto specify indexes for the settings arrayand then index the array within the closure.We'd rather just step through the values.Now you can pass the projected bindingdirectly into the List constructor,which can then iterate over the array values.The new support for property wrapper argumentslets us write the closure argument with a dollar sign,which will give us a bound setting in our closure.That, in turn, allows us to accessboth the wrapped value and the binding.And finally, the Swift compiler now transparently convertsbetween CGFloat and Double,which allows you to eliminate many redundant numericconversions when working with Apple platform APIs.As you see, our continuing effortto refine the core language is making the code you writeevery day simpler than ever and creating more opportunitiesfor library authors to build rich and easy-to-use APIs.For more information about some of the many waysthat SwiftUI programming has been improved this year,please watch the "What's new in SwiftUI" session.Of course, the highlight of Swift 5.5is a set of interlocking featuresto support asynchronous and concurrent programming.I'll introduce these in a moment, but first,let me briefly explain what I mean by "asynchronous"and "concurrent."Software projects are composedout of blocks of code that execute in some order.In the simplest case, those blocks execute,one after the other in a simple sequence.But other structures are common as well.For example, networking APIs are often designedin an asynchronous style.In these APIs, after you've sent a requestto the remote server, there may be a long delayuntil you receive a response and need to do more work.Ideally, your code would be suspendedduring this delay so it does not use any resourcesuntil you are able to act on the response.In contrast, concurrent code is whenyou have two or more blocks of codethat you would like to have running at the same time.These are often independent but related operations.Processing several frames of a video, for instance,or running the next iterationof an ML classifier at the same timethat you're updating the UIwith the previous set of results.With those ideas in mind,let's look at a simple asynchronous programming examplewithout using Swift's new features.If you've done much iOS or macOS programming,you may have written code similar to this many times.This uses Foundation's URLSession classto make a network call.The dataTask method is an asynchronous operation.You call it with a closure argument.When the result becomes available,your closure will be called with the results to process.Using closures in this way to express asynchronous coderesults in a somewhat awkward order of operations, though,as you can see by walking through this code.First, there's some initial setup,and the dataTask method gives us back a task handle.Then we resume the task handleto start the background operation.The fetchImage function actually returns at this point.Whoever called us must be ready to continue,even though we haven't actually done the workwe were asked to do.Later, after the network operation finishes,this closure will have a chance to deal with the results.Hopefully, everything goes well, and we cancall our completion handler with the final result.Besides the somewhat awkward order of execution,using completion handlers also prevents usfrom using try/catch error handling.Notice how dataTask provides an extra error parameterto its completion handler and how we have to invokeour completion handler with every possible error.To see how Swift 5.5 improves this,let's take a look at this one line of code.Notice how this call returns a task,an abstract handlethat represents the background operation.That's not really what we want.We just want to get the data.So let's push that idea a bit and see where we end up.Since we're dealing with HTTP,we also need to capture some response metadata.So the function is really going to return a pair,with the actual data as the first itemand additional information as the second.By structuring this as a function callthat returns the data, we can now usetry/catch error handling to eliminatea lot of the boilerplate from the previous example.We just need a bit of syntax to tell the compilerthat our function can be suspendedas soon as the data method beginsand that we won't be able to finish the assignmentuntil that operation has completed.Which is exactly what the new await keyword does.Let's look at that in context.Here's what our fetchImage function looks like now.As you see, this code is now much easier to follow.Control flows from top to bottom,we no longer need nested closures,and we can use try/catch error handling.The await keyword indicates a pointwhere this fetchImage function can be suspended,set aside to not rununtil some event happens that allows it to continue.In this case, as soon as URLSessioninitiates the request,our function will be suspended by the Swift runtimewhile the operation is carried out elsewhere.When the final result is ready,whether that's a successful response or a thrown error,only then will our function be resumed.If it's a successful response, we'll completethe initialization of the data and response variables.If it's a thrown error,we'll pass that back to whoever called us.An asynchronous function does not useany resources while it's suspended.In particular, it's not blocking a thread.This allows the Swift runtime to reuse the threadthis function was running on for other work.This allows a very few threads to be sharedamong many asynchronous processes.Syntactically, the async and await keywordsare used similarly to throws and try.async decorates the function declaration to indicatethat this function must be compiled to support suspension.Use the await keyword to mark any callto an async function, method, or closure.Of course, the full mechanism is a lot more interestingthan what I've shown here.You can watch the "Meet async/await in Swift"and "Swift concurrency: Behind the scenes" sessionsto learn more about how all of this works.Next, let's take a look at Swift's new concurrency support,which builds on the async/await concepts I just described.Here's a function that renders three different imagesand then combines them.As written here, these operations are sequential.The background, foreground, and title images will berendered one after the other, with each one startingonly after the previous one has completed.We'd like for the rendering operations to occur in parallel.But just running them in different threadsisn't enough: we also need the merge operationto be held, until we have all three results.This is similar, in some respects,to the asynchronous coding I was just talking about.So we mark this function "async"so that it will be able to suspend if it needs to waitfor results that are being computed in other threads.Next, we use the async let syntaxto run the first two operations in parallel.async let looks a lot like a variable initialization,and that's basically what it is.But this initialization will run in parallelwith other code until you try to use the results.Because the background and foreground variablesare being initialized with async let,Swift's runtime will, if necessary,suspend the merge operation until those values are ready.We mark the merge function with the await keywordto indicate this.The most important point about this codeis that the background tasks cannot outlive this function.Put another way, this function cannotand will not return if either of the two background tasksis still running.If an error is thrown from anywhereinside this function, the Swift runtime willstill wait for the background tasks to complete.Here, I've highlighted a try marker that indicatesthe computation of the title image may throw,but the same applies to all thrown errors,even if they occur in a separate thread.In order to keep things responsive,when there is a thrown error, the Swift runtime will signalunfinished tasks to give them a chance to complete early.Our session on structured concurrencyprovides more details, including a full discussionof this cancellation mechanism and more flexible alternativesto the async let syntax I've discussed here.In the previous section, I showed how Swift 5.5makes it easy to run operations on multiple threadsin a disciplined, structured fashion.Of course, that's not quite enough.Whenever two separate threads share data,you run the risk that the data will be inconsistent,or even corrupted.Swift's new actor construct helps protect your dataagainst such problems.Again, let's start with an example of codeyou may have written yourself.Here's a class that collects statistics.It contains a counter, and various other codewill call the increment method to update that counterwhenever something interesting happens.Unfortunately, this code doesn't work wellin a multi-threaded system.If two or more threads call the increment methodat the same time, you can end up with a badly-corrupted count.Changing this class into a Swift actorprotects against such corruption.Actors work by suspending any operation that might causedata corruption until it's safe to make that particular change.This means you generally need to use awaitwhen you call an actor method from outside of the actor.Actors also work seamlessly with async/await.Marking this publish method as async allows itto be suspended while waiting on network operations.While it's suspended, other methods can runon this actor without waiting for the network operationto complete and without risk of data corruption.Actors are reference types, like classes,but they obey a number of rules designed to ensurethat actors are safe to use in a multi-threaded environment.By packaging your data into actors,you are clearly stating that you expect this datato be accessed concurrentlyand that you want the Swift compiler and runtimeto coordinate access so that no corruption is possible.And, of course, we have a full sessiondevoted specifically to Swift's new actor construct.There, you can find out how to take advantageof the full range of capabilities this brings.Before we wrap up, let's talk a little bitabout the future of Swift.We believe the three key conceptswe've introduced in Swift 5.5--asynchronous functions,structured concurrency, and actors--are a good basis for creating safeand high-performance code.For Swift 6, we're already researching waysfor the compiler to catch more kinds of concurrency mistakesearlier in the development processand give you more detailed errorsand guidance in fixing those issues.Our goal, quite simply, is to entirely eliminatethe most common kinds of concurrency bugs,in order to make asynchronous and concurrent programmingno more complex than any other kind of programming.And, of course, as we continue to improvethe compiler's understanding of these concepts,we also expect code using these new constructsto become even more efficient than it is today.Swift is an open, collaborative effort that welcomes your input.To help make Swift 6 even better,tell us about your experiences with Swift 5.5.How well are these new features working for youin real-world app development?Try one of the compiler snapshotsthat you can find on swift.org.We provide these snapshots so you can install them into Xcodeand try out new features as we're developing them.By using these snapshots,you can help guide the next version of Swift.The Swift forums are the lifebloodof the project.Each of the features I've discussed started lifeby being pitched on the Swift Evolution forum,where a diverse group of people helped to refine itinto a working proposal.We also have forums devoted to many other aspects of Swift,including a help area for new users and a placeto exchange news of interest to the Swift community.There are many other ways you can make Swift better,and we are eager to engage even more people,such as through the new Mentorship Programthat Nicole mentioned at the beginning of this session.The only requirement is a sincere desireto help improve Swift for everyone in our community.I look forward to hearing from you,and I hope you enjoy the conference.[upbeat music]

♪ ♪Hi! I'm Nicole, and welcome to "What's new in Swift."Swift 5.5 is our best release yet!The Swift language continues to evolve at a rapid pace,with many new features, including Swift Concurrency,a new model for asynchronous and concurrent programmingdesigned to make concurrent programming in Swiftconvenient, efficient, and safe.In addition, we've made it easier than everto develop in Swift, thanks to advancesin the package experience, new standard library packages,and features enhancing the developer experience.

As important as these advances are,the heart of the Swift project is not code,but a community of peopleworking towards the goals of the Swift project.This is why it is important that we investin our community, as well as our software.I'd like to start things off by talking aboutan important Swift community initiative.Diversity is a core value of the Swift community.Research shows that diverse open source projectsare more productive and make better decisions.Including people from all backgroundsand with diverse perspectives helps a community thrive.We, and other members of the Swift community,saw the opportunity to encourage active engagementin the Swift ecosystem and community from a wider rangeof developers with our Diversity in Swift initiative.The mission of Diversity in Swift is to fosteran inclusive Swift communityby elevating a wide variety of voicesand making it easier for developers to start learningor contributing to Swift, regardless of their background.As part of this initiative,we have expanded the swift.org blogto include posts that recognize and highlight the contributionsfrom a wide range of developers within our community.We have also created community groupsin the Swift forums for developers to connectwith others who may have had similar experiencesor faced similar barriers.To get involved with Diversity in Swift,or find out more,please visit swift.org/diversity.We also want to help developers already in the communitygrow and reach their goals with Swift.To make contributing to Swift open source projectsmore approachable, we recently announcedthe Swift mentorship program to help newcomers getdirect support and guidance from regular contributors.This program isn't limited to Apple's projects.It also encompasses the entire ecosystemof Swift packages and open source tools.Next, I'd like to talk about packages.Packages are a fundamental building blockfor building software, allowing youto conveniently take advantage of an ever-growing arrayof open source code.Members of the Swift communityhave come up with some great solutionsto help developers find packages,like the Swift Package Index.The Swift Package Index is a pagecreated by the community that helps you findpackages which support the Swift Package Manager.Now, in Swift 5.5 and Xcode 13, we are providingadditional ways for you to find and access packages,by providing integrated Xcode tooling supportto make it even faster and easier to use packagesin your project as part of your development workflow.

This year, we are introducing Swift Package Collections,curated lists of Swift packages you can useboth from the command line and from Xcode 13.With package collections, you no longer need to searchfor packages on the Internet,or copy and paste URLs to add them.You can now simply browse a collection and add packagesfrom a new package search screen in Xcode.Package collections are simple JSON filesyou can publish anywhere.Package collections are meant to allow anyone to buildcurated lists of packages for different use cases.For example, an instructor for a computer science classcan put together a set of packagesthat helps teach the concepts of that class,or someone can put together a collection of packagesthat are good for a particular domain or task,or that are used by their organization.We're excited to see all the different waysin which people will use collections.We have a great presentation on package collectionsthat I recommend you check out to learn more.Package collections includesome powerful tooling support in Xcode.You are now just an import away from using your favorite APIs.When you try to import a module that cannot be found,Xcode will check if any of the packagesin the package collections that you have configuredprovide that module and provide you the opportunityto automatically start using that package.Once you choose to use a package,all configuration is handled for youbased on the information in the package collection.Package collections are also searchable,making it easy to find packages to meet your use case.If you are interested in trying out package collections today,there are some already available,including a package collection of the Swift Packagesthat Apple publishes on GitHub.Xcode comes pre-wired to use the Apple collection.

If you are interested in learning moreabout package collections, including collectionsalready available from the community,check out the new swift.org blog poston package collections.Speaking of your favorite APIs, Apple publishesa growing family of open source Swift packages.In addition to some big enhancementsto your favorite packages, this year,we launched four more new packages.First, I'd like to tell you about Swift Collections.

Swift Collections is a new open source packageof data structures that complements those availablein the Swift Standard Library.The initial version of Swift Collectionscomes with implementations for threeof the most frequently requested data structures:Deque, OrderedSet, and OrderedDictionary.

Deque is like an Array, except that it supportsefficient insertion and removal at both ends.OrderedSet is a powerful hybrid of an Array and a Set.Like Array, OrderedSet maintains its elements in orderand supports random access.Like a Set, OrderedSet ensures each elementappears only once and provides efficient membership testing.

And last is OrderedDictionary, which is a useful alternativeto Dictionary when order is important,or we need random access to elements.Next, let's talk about Swift Algorithms.Swift Algorithms is a new open source packageof Sequence and Collection algorithms.

We've already added over 40 algorithms to Swift Algorithmsfor things like generating all the combinations or permutationsof a collection of elements, or iterating the elementsof a sequence by two or three or in groupsdetermined by a predicate,or selecting the five smallest elements in a collection,the five largest, or just any five at random.

It takes a little investment to learn the vocabulary,but once you do, it can be striking to discoverjust how many algorithms are hiding in plain sight.

If you want to learn more, we have a sessionwhich describes how the new Swift Algorithmsand Collections packages can help you make your codeclearer, faster, and more correct.Now, let's talk about Swift System.Last fall, we open-sourced Swift System,a library providing idiomatic,low-level interfaces to system calls.System is available on Apple platforms,Linux, and even Windows.We recently added powerful new APIsto System's FilePath typefor performing common path manipulation operations.These include the ability to query or set extensions,add and remove components, and perform path normalization.A path can be decomposed into its rootand its relative components.FilePath's ComponentView is a collectionof structured path components, meaning it comes with supportfor many of Swift's generic algorithms right out of the box.

And when targeting Windows, Windows paths,with their complex root components,are fully supported by all the new FilePath APIs.Next, let's talk about Swift Numerics.Swift Numerics received a number of big additions this year.We brought Float16 to iOS, tvOS, and watchOS last year.This year, we added Float16 support to Apple Silicon Macsand the ability to make Float16-based complex numbers.Another addition this year is complex number supportfor all the elementary functions,like log, sine, and cosine.Because these implementations are written in Swift,they are frequently more efficientthan a traditional C library and allow for optimizationsthat would otherwise not be possible.Finally, let's talk about Swift ArgumentParser.We've continued to refine Swift ArgumentParser this year,with enhancements like the ability to generatecode-completion scripts for the Fish shell,joined short options, and improved error messages.We also passed an important milestonethis spring when ArgumentParser was adoptedby the Swift Package Manager in Xcode 12.5.That's right!If you've used the Swift Package Managercommand-line tool recently,you've used Swift ArgumentParser.Next, I'd like to talk about some work we've doneto support Swift on server development.Last year, we added support for a number of platforms,including Amazon Linux.This year, we've followed up on that work by investingin performance and functionality for Swift server applications.

We started by enabling static linking on Linux,which improves application startup time,as well as simplifies the deploymentof server applications,which can now be deployed as a single file.Also, in Swift 5.5, the JSON encoding and decodingused on Linux were reimplemented from scratch,resulting in performance gains for most common use cases.Finally, we've enhanced and optimized the performanceof the AWS Lambda runtime library itself.All this work made Swift programs running on AWS Lambdastart 33% faster,as well as 40% faster invocation timefor a lambda routed via AWS API Gateway.In addition to optimizingthe AWS runtime library performance,we refactored it to use our new async/await modelinstead of closures.Improving the Swift developer experienceis another key focus in Swift 5.5.I'd like to start by talking about documentation.Providing great documentation is key for creating a smoothand enjoyable experience for users of a framework.This year, we are introducing DocC,a documentation compiler that's deeply integratedinside Xcode 13, to help you teach developershow to use your Swift framework or package.It's now easier than ever to write and sharegreat documentation.

DocC is built from the ground up,using tools and technologies that you already know and love,such as markdown comments in your Swift source code,so that you can easily write and diff your documentation.

We have four fantastic sessions to show youevery aspect of DocC documentation in Xcode.I highly recommend you check them out.And now, I'm thrilled to announcethat Swift DocC will be open-sourced later this year.Open-sourcing Swift DocC will allow developersto more easily generate great documentationon all of Swift's supported platforms.

In Swift 5.5, we invested in qualityand performance improvements in the type checker.One result of this is you will see fewer"expression too complex" errors when compiling your code.We also sped up the performancefor type checking of array literals.

In this release, we're also enhancing developer productivitywith three major improvements to speed up incremental builds.First of all, we now support incremental imports,meaning we now no longer rebuild every source filethat imports a module when that module changes.In addition, we now computethe module dependency graph up frontso that we can quickly start incremental buildsof only what has changed.Finally, we've extended selective recompilationto work with extensions, meaning fewer recompilationswhen you change the body of an extension.Using the SwiftDriver open source project as an example,on the average, with incremental importsin Swift 5.5, we now recompileless than a tenth as many files when imported modules change,and the build time is decreased by about a third.The performance improvements from incremental importsmeans that you can now modularize your projectand change an imported modulewithout a large penalty in build performance.And by the way, some of these performance improvementswere made possible by an important milestonefor the Swift project,the first part of the compiler to be written in Swift.This is the Swift Driver, the program that coordinatesthe compilation of Swift source code.This project began in late 2019 and, as of Xcode 13,is now the default for Swift compilation.Finally, let's talk about improvements we've madeto make memory management in Swift more efficient,so Swift programs reclaim memory more quickly.Swift class instances useAutomatic Reference Counting, ARC,to track how many references there areto a particular object at any given time.In most cases, this means that memory managementjust works in Swift, and you don't needto think about memory management yourself.ARC automatically frees upthe memory used by class instanceswhen those instances are no longer needed.To do this, the Swift compiler inserts a retain operationany time a new reference is createdand a release operationwhenever a new reference stops being used.This year, we introduced a new wayto track references inside the compilerthat allows the compiler to significantly reducethe number of retain and release operations.We've seen measurable performance and code sizeimprovements from this change.We've added an Xcode setting, Optimize Object Lifetimes,that will allow you to see the effect of this new,more aggressive ARC optimization on your code.For more information on ARC,please check out the "ARC in Swift" session.

These are just some of the improvementsbrought to you by Swift 5.5.Next, Tim will talk to you about Swift Concurrencyand other evolutions in the Swift language.Thanks, Nicole.We're all very excited about Swift Concurrency,but before I get to that, I want to discuss a numberof other changes we've made to Swiftto simplify and improve everyday programming.

Here's a list of the ergonomic improvementswe've made this year.The SE numbers identify Swift Evolution proposals.Each of these proposals was written by a memberof the community, discussed on the Swift Evolution forum,and approved by the Swift Core Teambefore being accepted into the language.All SE proposals, whether accepted, rejected,or still in discussion, can be foundin the Swift Evolution repository on GitHub.Let's look at a few of these changes.First, Result Builders.When SwiftUI was first announced,it introduced a new syntax that could be usedto quickly and easily describe complex object hierarchies.This past year, that syntax was standardized and refinedthrough the Swift Evolution process so that it could bemore easily used in a wide variety of contexts.If you'd like to take advantage of this powerful technology,we have a session specifically devotedto using Result Builders.The Codable protocolis a convenient way to serialize your data,but it's long suffered from a notable omission.Consider this two-case Enum.In order to make it conform to Codable, you used to haveto manually implement all of this boilerplate.Now, you just need to declare the Codable conformance,and the compiler will do all of that work for you.

We also made some key improvementsto Swift's type checker.As you know, type inference in Swiftmeans you can omit redundant type information.Here, it lets you shorten Coffee.regulardown to just .regular.But Enum-like structures are also represented in other ways.For example, you might have a collection of typesthat conform to a protocoland want to use instances of those types in your API.You can now refer to instances of those typesusing the same dot-notation that you use for Enums,by declaring a few static properties on your protocol.This is enabled by improvements to Swift's type checkerthat allows it to reason more generallyabout static properties in generic contexts,including chained property referencessuch as the .large here.This allows library authors to build sophisticated genericdata models with natural and easy-to-use Enum-like APIs.

Property wrappers were also improved this year.

Property wrappers are a convenient toolfor applying common semantics to properties.Many of you have implemented your own property wrappersusing the @propertyWrapper annotation on a struct.Here's an example that adds the requirementthat the property not be empty.With the implementation of SE-0293,those same property wrappers can now be usedon function and closure parameters.

Cumulatively, these and other changesto the language can simplify a lot of common coding problems.Let's look at them together in the contextof a simple SwiftUI code sample.Here's a SwiftUI View that has a single property,holding an array of settings, and a body that presentsa list of those settings, with a toggle next to each one.Let's review this code and see howthe new Swift 5.5 features can simplify it.First, that Toggle() initializer is obviously duplicated.This duplication used to be necessary,but we've relaxed the use of #if to allow it to surroundpostfix expressions, such as the toggleStylemodifiers here, which allows usto factor out that redundancy.SwiftUI has also been updated to take advantage of the newtype checker improvements I mentioned earlier.So you can use natural dot-notationin many more places.It's--it's a little awkwardto specify indexes for the settings arrayand then index the array within the closure.We'd rather just step through the values.Now you can pass the projected bindingdirectly into the List constructor,which can then iterate over the array values.The new support for property wrapper argumentslets us write the closure argument with a dollar sign,which will give us a bound setting in our closure.That, in turn, allows us to accessboth the wrapped value and the binding.And finally, the Swift compiler now transparently convertsbetween CGFloat and Double,which allows you to eliminate many redundant numericconversions when working with Apple platform APIs.As you see, our continuing effortto refine the core language is making the code you writeevery day simpler than ever and creating more opportunitiesfor library authors to build rich and easy-to-use APIs.For more information about some of the many waysthat SwiftUI programming has been improved this year,please watch the "What's new in SwiftUI" session.Of course, the highlight of Swift 5.5is a set of interlocking featuresto support asynchronous and concurrent programming.I'll introduce these in a moment, but first,let me briefly explain what I mean by "asynchronous"and "concurrent."Software projects are composedout of blocks of code that execute in some order.In the simplest case, those blocks execute,one after the other in a simple sequence.But other structures are common as well.For example, networking APIs are often designedin an asynchronous style.In these APIs, after you've sent a requestto the remote server, there may be a long delayuntil you receive a response and need to do more work.Ideally, your code would be suspendedduring this delay so it does not use any resourcesuntil you are able to act on the response.In contrast, concurrent code is whenyou have two or more blocks of codethat you would like to have running at the same time.These are often independent but related operations.Processing several frames of a video, for instance,or running the next iterationof an ML classifier at the same timethat you're updating the UIwith the previous set of results.With those ideas in mind,let's look at a simple asynchronous programming examplewithout using Swift's new features.If you've done much iOS or macOS programming,you may have written code similar to this many times.This uses Foundation's URLSession classto make a network call.The dataTask method is an asynchronous operation.You call it with a closure argument.When the result becomes available,your closure will be called with the results to process.Using closures in this way to express asynchronous coderesults in a somewhat awkward order of operations, though,as you can see by walking through this code.First, there's some initial setup,and the dataTask method gives us back a task handle.Then we resume the task handleto start the background operation.The fetchImage function actually returns at this point.Whoever called us must be ready to continue,even though we haven't actually done the workwe were asked to do.Later, after the network operation finishes,this closure will have a chance to deal with the results.Hopefully, everything goes well, and we cancall our completion handler with the final result.Besides the somewhat awkward order of execution,using completion handlers also prevents usfrom using try/catch error handling.Notice how dataTask provides an extra error parameterto its completion handler and how we have to invokeour completion handler with every possible error.To see how Swift 5.5 improves this,let's take a look at this one line of code.Notice how this call returns a task,an abstract handlethat represents the background operation.That's not really what we want.We just want to get the data.So let's push that idea a bit and see where we end up.Since we're dealing with HTTP,we also need to capture some response metadata.So the function is really going to return a pair,with the actual data as the first itemand additional information as the second.By structuring this as a function callthat returns the data, we can now usetry/catch error handling to eliminatea lot of the boilerplate from the previous example.We just need a bit of syntax to tell the compilerthat our function can be suspendedas soon as the data method beginsand that we won't be able to finish the assignmentuntil that operation has completed.Which is exactly what the new await keyword does.Let's look at that in context.Here's what our fetchImage function looks like now.As you see, this code is now much easier to follow.Control flows from top to bottom,we no longer need nested closures,and we can use try/catch error handling.The await keyword indicates a pointwhere this fetchImage function can be suspended,set aside to not rununtil some event happens that allows it to continue.

In this case, as soon as URLSessioninitiates the request,our function will be suspended by the Swift runtimewhile the operation is carried out elsewhere.When the final result is ready,whether that's a successful response or a thrown error,only then will our function be resumed.If it's a successful response, we'll completethe initialization of the data and response variables.If it's a thrown error,we'll pass that back to whoever called us.An asynchronous function does not useany resources while it's suspended.In particular, it's not blocking a thread.This allows the Swift runtime to reuse the threadthis function was running on for other work.This allows a very few threads to be sharedamong many asynchronous processes.

Syntactically, the async and await keywordsare used similarly to throws and try.async decorates the function declaration to indicatethat this function must be compiled to support suspension.Use the await keyword to mark any callto an async function, method, or closure.Of course, the full mechanism is a lot more interestingthan what I've shown here.You can watch the "Meet async/await in Swift"and "Swift concurrency: Behind the scenes" sessionsto learn more about how all of this works.Next, let's take a look at Swift's new concurrency support,which builds on the async/await concepts I just described.

Here's a function that renders three different imagesand then combines them.As written here, these operations are sequential.The background, foreground, and title images will berendered one after the other, with each one startingonly after the previous one has completed.We'd like for the rendering operations to occur in parallel.But just running them in different threadsisn't enough: we also need the merge operationto be held, until we have all three results.This is similar, in some respects,to the asynchronous coding I was just talking about.So we mark this function "async"so that it will be able to suspend if it needs to waitfor results that are being computed in other threads.Next, we use the async let syntaxto run the first two operations in parallel.async let looks a lot like a variable initialization,and that's basically what it is.But this initialization will run in parallelwith other code until you try to use the results.Because the background and foreground variablesare being initialized with async let,Swift's runtime will, if necessary,suspend the merge operation until those values are ready.We mark the merge function with the await keywordto indicate this.The most important point about this codeis that the background tasks cannot outlive this function.Put another way, this function cannotand will not return if either of the two background tasksis still running.If an error is thrown from anywhereinside this function, the Swift runtime willstill wait for the background tasks to complete.Here, I've highlighted a try marker that indicatesthe computation of the title image may throw,but the same applies to all thrown errors,even if they occur in a separate thread.In order to keep things responsive,when there is a thrown error, the Swift runtime will signalunfinished tasks to give them a chance to complete early.Our session on structured concurrencyprovides more details, including a full discussionof this cancellation mechanism and more flexible alternativesto the async let syntax I've discussed here.In the previous section, I showed how Swift 5.5makes it easy to run operations on multiple threadsin a disciplined, structured fashion.Of course, that's not quite enough.Whenever two separate threads share data,you run the risk that the data will be inconsistent,or even corrupted.Swift's new actor construct helps protect your dataagainst such problems.Again, let's start with an example of codeyou may have written yourself.Here's a class that collects statistics.It contains a counter, and various other codewill call the increment method to update that counterwhenever something interesting happens.Unfortunately, this code doesn't work wellin a multi-threaded system.If two or more threads call the increment methodat the same time, you can end up with a badly-corrupted count.Changing this class into a Swift actorprotects against such corruption.Actors work by suspending any operation that might causedata corruption until it's safe to make that particular change.This means you generally need to use awaitwhen you call an actor method from outside of the actor.Actors also work seamlessly with async/await.Marking this publish method as async allows itto be suspended while waiting on network operations.While it's suspended, other methods can runon this actor without waiting for the network operationto complete and without risk of data corruption.Actors are reference types, like classes,but they obey a number of rules designed to ensurethat actors are safe to use in a multi-threaded environment.By packaging your data into actors,you are clearly stating that you expect this datato be accessed concurrentlyand that you want the Swift compiler and runtimeto coordinate access so that no corruption is possible.And, of course, we have a full sessiondevoted specifically to Swift's new actor construct.There, you can find out how to take advantageof the full range of capabilities this brings.Before we wrap up, let's talk a little bitabout the future of Swift.We believe the three key conceptswe've introduced in Swift 5.5--asynchronous functions,structured concurrency, and actors--are a good basis for creating safeand high-performance code.For Swift 6, we're already researching waysfor the compiler to catch more kinds of concurrency mistakesearlier in the development processand give you more detailed errorsand guidance in fixing those issues.Our goal, quite simply, is to entirely eliminatethe most common kinds of concurrency bugs,in order to make asynchronous and concurrent programmingno more complex than any other kind of programming.And, of course, as we continue to improvethe compiler's understanding of these concepts,we also expect code using these new constructsto become even more efficient than it is today.

Swift is an open, collaborative effort that welcomes your input.To help make Swift 6 even better,tell us about your experiences with Swift 5.5.How well are these new features working for youin real-world app development?Try one of the compiler snapshotsthat you can find on swift.org.We provide these snapshots so you can install them into Xcodeand try out new features as we're developing them.By using these snapshots,you can help guide the next version of Swift.The Swift forums are the lifebloodof the project.Each of the features I've discussed started lifeby being pitched on the Swift Evolution forum,where a diverse group of people helped to refine itinto a working proposal.We also have forums devoted to many other aspects of Swift,including a help area for new users and a placeto exchange news of interest to the Swift community.There are many other ways you can make Swift better,and we are eager to engage even more people,such as through the new Mentorship Programthat Nicole mentioned at the beginning of this session.The only requirement is a sincere desireto help improve Swift for everyone in our community.I look forward to hearing from you,and I hope you enjoy the conference.[upbeat music]

6:16 -Deque

6:25 -Ordered set

6:42 -Ordered dictionary

7:39 -Swift Algorithms

7:52 -Swift System

8:06 -FilePath manipulation APIs

9:01 -Float16 support on Apple silicon Macs

9:05 -Complex elementary functions

11:07 -AWS Lambda runtime now with async/await

14:52 -Memory management

17:04 -Codable synthesis for enums with associated values: A two-case enum

17:11 -Codable synthesis for enums with associated values: Before

17:15 -Codable synthesis for enums with associated values: After

17:26 -Static member lookup

17:49 -Flexible static member lookup

18:25 -Property wrappers on parameters

19:02 -Ergonomic improvements in SwiftUI code: Before

19:37 -Ergonomic improvements in SwiftUI code: After

22:20 -Asynchronous programming with async/await: Before

23:58 -Asynchronous programming with async/await: URLSession.shared.data(for:)

24:40 -Asynchronous programming with async/await: After

27:06 -Structured concurrency

29:26 -Actors

## Code Samples

```swift
import
 Collections


var
 colors: 
Deque
 
=
 [
"red"
, 
"yellow"
, 
"blue"
]

colors.prepend(
"green"
)
colors.append(
"orange"
)

// `colors` is now ["green", "red", "yellow", "blue", “orange"]


colors.popFirst() 
// "green"

colors.popLast() 
// "orange"


// `colors` is back to ["red", "yellow", "blue"]
```

```swift
import
 Collections


var
 buildingMaterials: 
OrderedSet
 
=
 [
"straw"
, 
"sticks"
, 
"bricks"
]


for
 i 
in
 
0
 
..<
 buildingMaterials.count {
    
print
(
"Little piggie #
\(i)
 built a house of 
\(buildingMaterials[i])
"
)
}

// Little piggie #0 built a house of straw


// Little piggie #1 built a house of sticks


// Little piggie #2 built a house of bricks


buildingMaterials.append(
"straw"
) 
// (inserted: false, index: 0)
```

```swift
import
 Collections


var
 responses: 
OrderedDictionary
 
=
 [
200
: 
"OK"
, 
403
: 
"Forbidden"
, 
404
: 
"Not Found"
]


for
 (code, phrase) 
in
 responses {
    
print
(
"
\(code)
 (
\(phrase)
)"
)
}

// 200 (OK)


// 403 (Forbidden)


// 404 (Not Found)
```

```swift
import
 Algorithms


let
 testAccounts 
=
 [ 
...
 ]


for
 testGroup 
in
 testAccounts.uniquePermutations(ofCount: 
0
...
) {
    
try
 validate(testGroup)
}


let
 randomGroup 
=
 testAccounts.randomSample(count: 
5
)
```

```swift
import
 System


let
 fd: 
FileDescriptor
 
=
 
try
 .open(
    
"/tmp/a.txt"
, .writeOnly,
    options: [.create, .truncate], permissions: .ownerReadWrite)

try
 fd.closeAfter {
    
try
 fd.writeAll(
"Hello, WWDC!
\n
"
.utf8)
}
```

```swift
import
 System


var
 path: 
FilePath
 
=
 
"/tmp/WWDC2021.txt"


print
(path.lastComponent)         
// "WWDC2021.txt"



print
(path.extension)             
// "txt"

path.extension 
=
 
"pdf"
            
// path == "/tmp/WWDC2021.pdf"

path.extension 
=
 
nil
              
// path == "/tmp/WWDC2021"


print
(path.extension)             
// nil


path.push(
"../foo/bar/./"
)        
// path == "/tmp/wwdc2021/../foo/bar/."

path.lexicallyNormalize()         
// path == "/tmp/foo/bar"


print
(path.ends(with: 
"foo/bar"
)) 
// true!
```

```swift
import
 Numerics


let
 x: 
Float16
 
=
 
1.5


let
 y 
=
 
Float16
.exp(x)
```

```swift
import
 Numerics


let
 z 
=
 
Complex
(
0
, 
Float16
.pi) 
// πi


let
 w 
=
 
Complex
.exp(z)         
// exp(πi) ≅ -1
```

```swift
import
 AWSLambdaRuntime

import
 AWSLambdaEvents


@main


struct
 
HelloWorld
: 
LambdaHandler
 
{
    
typealias
 
In
 
=
 
APIGatewayV2Request

    
typealias
 
Out
 
=
 
APIGatewayV2Response

    
func
 
handle
(
event
: 
In
, 
context
: 
Lambda
.
Context
)
 
async
 
throws
 -> 
Out
 {
        .
init
(statusCode: .ok, body: 
"Hello World"
)
    }
}
```

```swift
class
 
Traveler
 
{
    
var
 destination: 
String

}


func
 
test
()
 {
    
let
 traveler1 
=
 
Traveler
(destination: 
"Unknown"
)
    
// retain

    
let
 traveler2 
=
 traveler1
    
// release

    traveler2.destination 
=
 
"Big Sur"

    
// release

    
print
(
"Done traveling"
)
}
```

```swift
enum
 
Command
 
{
    
case
 load(key: 
String
)
    
case
 store(key: 
String
, value: 
Int
)
}
```

```swift
// You used to have to manually implement all of this boilerplate.



enum
 
Command
: 
Codable
 
{
    
case
 load(key: 
String
)
    
case
 store(key: 
String
, value: 
Int
)

    
init
(
from
 
decoder
: 
Decoder
)
 
throws
 {
        
let
 container 
=
 
try
 decoder.container(keyedBy: 
CodingKeys
.
self
)
        
if
 container.allKeys.count 
!=
 
1
 {
            
let
 context 
=
 
DecodingError
.
Context
(
                codingPath: container.codingPath,
                debugDescription: 
"Invalid number of keys found, expected one."
)
            
throw
 
DecodingError
.typeMismatch(
Command
.
self
, context)
        }

        
switch
 container.allKeys.first.unsafelyUnwrapped {
        
case
 .load:
            
let
 nested 
=
 
try
 container.nestedContainer(
                keyedBy: 
LoadCodingKeys
.
self
,
                forKey: .load)
            
self
 
=
 .load(
                key: 
try
 nested.decode(
String
.
self
, forKey: .key))
        
case
 .store:
            
let
 nested 
=
 
try
 container.nestedContainer(
                keyedBy: 
StoreCodingKeys
.
self
,
                forKey: .store)
            
self
 
=
 .store(
                key: 
try
 nested.decode(
String
.
self
, forKey: .key),
                value: 
try
 nested.decode(
Int
.
self
, forKey: .value))
        }
    }

    
func
 
encode
(
to
 
encoder
: 
Encoder
)
 
throws
 {
        
var
 container 
=
 encoder.container(keyedBy: 
CodingKeys
.
self
)
        
switch
 
self
 {
        
case
 
let
 .load(key):
            
var
 nested 
=
 container.nestedContainer(keyedBy: 
LoadCodingKeys
.
self
, 
                                                   forKey: .load)
            
try
 nested.encode(key, forKey: .key)
        
case
 
let
 .store(key, value):
            
var
 nested 
=
 container.nestedContainer(keyedBy: 
StoreCodingKeys
.
self
, 
                                                   forKey: .store)
            
try
 nested.encode(key, forKey: .key)
            
try
 nested.encode(value, forKey: .value)
        }
    }

    
/// Contains keys for all cases of the enum.

    
enum
 
CodingKeys
: 
CodingKey
 
{
        
case
 load
        
case
 store
    }

    
/// Contains keys for all associated values of `case load`.

    
enum
 
LoadCodingKeys
: 
CodingKey
 
{
        
case
 key
    }

    
/// Contains keys for all associated values of `case store`.

    
enum
 
StoreCodingKeys
: 
CodingKey
 
{
        
case
 key
        
case
 value
    }
}
```

```swift
enum
 
Command
: 
Codable
 
{
    
case
 load(key: 
String
)
    
case
 store(key: 
String
, value: 
Int
)
}
```

```swift
enum
 
Coffee
 
{
    
case
 regular
    
case
 decaf
}


func
 
brew
(
_
 
coffee
: 
Coffee
)
 { 
...
 }

brew(.regular)
```

```swift
protocol
 
Coffee
 
{ 
...
 }

struct
 
RegularCoffee
: 
Coffee
 
{ }

struct
 
Cappuccino
: 
Coffee
 
{ }

extension
 
Coffee
 
where
 
Self
 == 
Cappucino
 
{
    
static
 
var
 cappucino: 
Cappucino
 { 
Cappucino
() }
}


func
 
brew
<
CoffeeType
: 
Coffee
>(
_
 
coffee
: 
CoffeeType
)
 { 
...
 }

brew(.cappucino.large)
```

```swift
@propertyWrapper


struct
 
NonEmpty
<
Value
: 
Collection
> 
{
    
init
(
wrappedValue
: 
Value
)
 {
        
precondition
(
!
wrappedValue.isEmpty)
        
self
.wrappedValue 
=
 wrappedValue
    }

    
var
 wrappedValue: 
Value
 {
        
willSet
 { 
precondition
(
!
newValue.isEmpty) }
    }
}


func
 
logIn
(
@NonEmpty
 
_
 
username
: 
String
)
 {
    
print
(
"Logging in: 
\(username)
"
)
}
```

```swift
// Instead of writing this...



import
 SwiftUI


struct
 
SettingsView
: 
View
 
{
    
@State
 
var
 settings: [
Setting
]

    
private
 
let
 padding 
=
 
10.0


    
var
 body: 
some
 
View
 {
        
List
(
0
 
..<
 settings.count) { index 
in

            
#if
 os(macOS)
            
Toggle
(settings[index].displayName, isOn: 
$settings
[index].isOn)
                .toggleStyle(
CheckboxToggleStyle
())
            
#else

            
Toggle
(settings[index].displayName, isOn: 
$settings
[index].isOn)
                .toggleStyle(
SwitchToggleStyle
())
            
#endif

        }
        .padding(
CGFloat
(padding))
    }
}
```

```swift
// You can now write this.



import
 SwiftUI


struct
 
SettingsView
: 
View
 
{
    
@State
 
var
 settings: [
Setting
]

    
private
 
let
 padding 
=
 
10.0


    
var
 body: 
some
 
View
 {
        
List
(
$settings
) { 
$setting
 
in

            
Toggle
(setting.displayName, isOn: 
$setting
.isOn)
              
#if
 os(macOS)
              .toggleStyle(.checkbox)
              
#else

              .toggleStyle(.switch)
              
#endif

        }
        .padding(padding)
    }
}
```

```swift
// Instead of writing this...



func
 
fetchImage
(
id
: 
String
, 
completion
: (
UIImage
?, 
Error
?) -> 
Void
)
 {
    
let
 request 
=
 
self
.imageURLRequest(for: id)
    
let
 task 
=
 
URLSession
.shared.dataTask(with: request) {
        data, urlResponse, error 
in

        
if
 
let
 error 
=
 error {
            completion(
nil
, error)
        } 
else
 
if
 
let
 httpResponse 
=
 urlResponse 
as?
 
HTTPURLResponse
,
                httpResponse.statusCode 
!=
 
200
 {
            completion(
nil
, 
MyTransferError
())
        } 
else
 
if
 
let
 data 
=
 data, 
let
 image 
=
 
UIImage
(data: data) {
            completion(image, 
nil
)
        } 
else
 {
            completion(
nil
, 
MyOtherError
())
        }
    }
   task.resume()
}
```

```swift
let
 (data, response) 
=
 
try
 
await
 
URLSession
.shared.data(for: request)
```

```swift
// You can now write this.



func
 
fetchImage
(
id
: 
String
)
 
async
 
throws
 -> 
UIImage
 {
    
let
 request 
=
 
self
.imageURLRequest(for: id)
    
let
 (data, response) 
=
 
try
 
await
 
URLSession
.shared.data(for: request)
    
if
 
let
 httpResponse 
=
 response 
as?
 
HTTPURLResponse
,
       httpResponse.statusCode 
!=
 
200
 {
        
throw
 
TransferFailure
()
    }
    
guard
 
let
 image 
=
 
UIImage
(data: data) 
else
 {
        
throw
 
ImageDecodingFailure
()
    }
    
return
 image
}
```

```swift
func
 
titleImage
()
 
async
 
throws
 -> 
Image
 {
    
async
 
let
 background 
=
 renderBackground()
    
async
 
let
 foreground 
=
 renderForeground()
    
let
 title 
=
 
try
 renderTitle()
    
return
 
try
 
await
 merge(background,
                           foreground,
                           title)
}
```

```swift
actor 
Statistics
 {
    
private
 
var
 counter: 
Int
 
=
 
0

    
func
 
increment
()
 {
        counter 
+=
 
1

    }
    
func
 
publish
()
 
async
 {
        
await
 sendResults(counter)
    }
}


var
 statistics 
=
 
Statistics
()

await
 statistics.increment()
```


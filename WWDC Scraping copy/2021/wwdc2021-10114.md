# Wwdc2021 10114

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Meet StoreKit 2StoreKit 2 delivers powerful, Swift-native APIs for in-app purchases and auto-renewable subscriptions. Learn how you can easily implement in-app purchases and subscriptions, and discover APIs for retrieving product information, handling transactions, determining product entitlements and customer status, as well as comprehensive testing support in Xcode.ResourcesApp Store Server APIApp Store Server NotificationsHuman Interface Guidelines: In-app purchaseImplementing a store in your app using the StoreKit APIIn-app purchase overviewIntroducing StoreKit 2JWS documentation (RFC 7515)Learn more about designing subscriptionsStoreKitHD VideoSD VideoRelated VideosWWDC23Meet StoreKit for SwiftUIWhat’s new in StoreKit 2 and StoreKit Testing in XcodeWWDC22Implement proactive in-app purchase restoreWhat's new in StoreKit testingWhat's new with in-app purchaseWWDC21Manage in-app purchases on your serverSupport customers and handle refundsTuesday@WWDC21WWDC20What’s new with in-app purchaseWWDC19In-App Purchases and Using Server-to-Server Notifications

StoreKit 2 delivers powerful, Swift-native APIs for in-app purchases and auto-renewable subscriptions. Learn how you can easily implement in-app purchases and subscriptions, and discover APIs for retrieving product information, handling transactions, determining product entitlements and customer status, as well as comprehensive testing support in Xcode.

App Store Server API

App Store Server Notifications

Human Interface Guidelines: In-app purchase

Implementing a store in your app using the StoreKit API

In-app purchase overview

Introducing StoreKit 2

JWS documentation (RFC 7515)

Learn more about designing subscriptions

StoreKit

HD VideoSD Video

HD Video

SD Video

Meet StoreKit for SwiftUI

What’s new in StoreKit 2 and StoreKit Testing in Xcode

Implement proactive in-app purchase restore

What's new in StoreKit testing

What's new with in-app purchase

Manage in-app purchases on your server

Support customers and handle refunds

Tuesday@WWDC21

What’s new with in-app purchase

In-App Purchases and Using Server-to-Server Notifications

Search this video…♪ Bass music playing ♪♪Ross LeBeau: Hi, and welcome to WWDC21.My name is Ross LeBeau,and I'm an engineer on the StoreKit team.Today, we're going to be talking about StoreKit,and this is actually one of three sessionsdesigned to help you implement client-side code,build out your server for in-app purchase,and support your customers and handle refunds.This session is Meet StoreKit 2,and you can find the other two sessions here at WWDC21.This session will focus on client-side featuresand implementation.So let's get started!Since StoreKit was introduced in iOS 3,it's created great opportunities for you and your businesses.Today, it exists on four Apple platformsand supports everything from games to news apps,indie titles to international hits.Over the years, we've introduced great featuressuch as offer codes, Family Sharing,and StoreKit testing in Xcode.But this year, we decided to go back to the beginning.Today, I'm excited to introduce you to StoreKit 2!StoreKit 2 is a brand new set of modern and flexible Swift APIsfor working with In-App Purchaseacross iOS, macOS, tvOS, and watchOS.We've taken a new look at StoreKitwith a Swift-first mindset.We embraced some of the newest language features,like Swift concurrency using the async/await pattern,to create simple yet powerful APIs.We've also made some huge updatesto the in-app purchase transactions,making them much easier to work with,while also providing more information and high security.And we've added more powerful APIsspecifically for subscriptionsin order to give you deeper insight that you can useto grow your business.StoreKit 2 APIs live inside the same StoreKit frameworkthat exists todayand focus on the core in-app purchase experiencerather than replacing every API.The new StoreKit 2 APIs are comprised of five major areas:Products, Purchases, Transaction info,Transaction history, and subscription status.Today I'm going to give you an overview of each of these areas,and my colleague Jakob will be showing you how to usethe corresponding StoreKit 2 APIs in real code.So first, let's start with the building blocks of StoreKit:products and purchases.The StoreKit 2 product struct is a supercharged versionof the StoreKit product object you're used to.To start, we've added additional data to it,such as the product typeand extended subscription information.With StoreKit 2, we're making it easier to do thingslike find out if the customer is eligiblefor your introductory offer.We're also making StoreKit 2 productsforward-compatible with new features.We've accomplished this by adding a wrapping typecalled BackingValuethat allows you to retrieve data contained in the productby subscripting the products directly.This means that if we add data to products in the future,you'll always be able to access them in StoreKit 2,even on SDKs and devices running operating systemsthat have older versions of StoreKit 2.This means that you can use the latest featuresto provide new functionalityto a larger section of your customer base.With StoreKit 2, you request products by callinga static function on the product type itself.This requests product metadata from the App Storejust like the existing SKProductsRequest does.But thanks to the new Swift concurrency async/await pattern,the StoreKit 2 product request requires just one line of code.Similarly, purchasing a product in StoreKit 2is another simple, one-line task.Purchase is now an instance method on the product type,meaning you can take those products you just retrievedand call purchase directly on them.Since the purchase method also uses async/await,you get the result of your purchase inline in your code.Now we know that not every purchase is the same.If you want to modify purchase behaviorbeyond the default settings, StoreKit 2 has Purchase options.A Purchase option is an itemthat describes a single property of a purchase.You can compose Purchase options into a setwhich you pass into the purchase method.StoreKit 2 includes purchase options for thingssuch as quantity and promotional offers.And in StoreKit 2, we're adding a new optioncalled App account token.The App account token is a way for you to keep trackof which of your app's user accountsbegan and completed a transaction.It’s an opaque token that you generatewhich you can link to accounts that your app owns.It's easy to generate an App account token,because the only requirement is that it conformsto the UUID format.You send up an App account token on the purchaseas a Purchase option,and this token is returned in the transaction infofor that purchase.The App account token stays in the transaction info forever,even across devices.If your app supports its own account system,this can help you keep track of which purchaseseach in-app account has made,regardless of the Apple ID or devicethat was used to purchase them.So, we've talked about getting products from the App Storeand initiating a purchase;now what happens when that purchase completes?As you might expect,StoreKit is going to return a successful transaction to youalong with cryptographically signed information.Sounds familiar, right?Well, StoreKit 2 is bringing the biggest updateto in-app purchase transactions ever.To start, StoreKit 2 will be providingan individually signed object for every transaction.Not only that, but starting in StoreKit 2,in-app purchase transaction info will now be providedin a very common, easy-to-work-with format: JSON.And since we know that secure cryptographic signingis an important part of StoreKit purchases,we're now using a common standard used across the webknown as JSON Web Signature.Plus, all the information contained in the signed objectwill now be available through native StoreKit APIs,making it easy to work with this data in your app's code.In fact, we'll show you just how easy it is.Here's Jakob with a demonstration of these APIsin real code.Jakob Swank: Hi, I'm Jakob.I'm an engineer on the StoreKit team.I'm really excited today to be showing you how easy it isto get up and running with StoreKit 2 in your app.On the right, I have an app I'm building called Pocket Cars.You can download the sample code for this appin the resources section of this session and follow along.The app has two main views.There's a view for my collected cars and a view for my store.Let's go over to the store.Currently, my store is emptybecause I have no products available for sale.I'm going to go ahead and implement those now.To get up and running quickly,I'm using StoreKit testing in Xcode.This allows me to build and test my storebefore defining products in App Store Connect.In my Xcode project,I've already created a StoreKit configuration filedefining the products I want to sell.This is the same configuration file I was using for StoreKit;I don't need to change or migrate anything.Here, I also have a plistcontaining all my product identifiers.It's included as a resource file built into my appso I can use it at runtime.To display these products in my store,I first need to make a product requestusing a set of the product identifiers I want to display.With StoreKit 2, I can do thissimply by calling a static method on the Product struct.After I receive the products from the App Store,I want to separate them by type.I can do this easily with StoreKit 2since the Product type now provides a propertyfor the type as it's defined on the App Store server.In my app, I'm selling three types of products:fuel, cars, and a navigation package.Fuel is a consumable product -- once I use it, it's gone --so I'll put all the consumables in to the fuel array.Cars are a non-consumable.Once I purchase a car, I own it forever.So I'll put all the non-consumablesinto the cars array.The navigation package is a subscription productwith three levels of service.My customers can subscribe to one level of service at a time,and they are billed periodically.Also, they can upgrade or downgrade at any timeif they want to change their level of service.The App Store will return a Productfor each level of service,so I'll put all the auto-renewable subscriptionsinto the subscriptions array.I also want to sort my products within each type by price,lowest to highest.Let's run my app and check out what I've done so far.Now I'll navigate to the store.Wow!Before, my store was empty,but now it's looking pretty greatwith all my products displayed.With just one line of code,I was able to request my app's products from the App Store,then I was able to group and sort those productsbased only on the metadata I receivedwhich made it easy to build my store UI.Now my products are looking great,but if I tap a buy button, nothing happens.That's because the purchase method in my storedoesn't do anything.It should initiate the purchase with StoreKit.We can do this simply by calling the purchase methodon the product.As Ross mentioned,StoreKit 2 was built from the ground upto use the new concurrency capabilities of Swift.This allows my app to keep the code for purchasingand processing the result of that purchaseall within the same contextin order to keep my code easy to read.When a purchase completes, a PurchaseResult is returned.This PurchaseResult lets me knowwhether the purchase was successfulor if it completed in some other non-error state,such as the user cancelled the purchaseor the purchase needs some extra bank validationor approval from a parent.To handle each case, I'll just switch over them.If the PurchaseResult is in the success state,I also get a verification result.A verification result contains two cases:verified and unverified.In StoreKit 2, the transaction type contains the JWS payloadwhich represents the signed transaction.Every time my app receives a transaction from StoreKit 2,the transaction has passed through a verification processto confirm whether the payload is signed by the App Storefor my app for this device.You heard that right.StoreKit 2 does transaction verification for you.Of course, how I choose to handle the verification resultis entirely up to me and the needs of my business.For my app, I'm going to make surethis transaction I received from StoreKit has been verified.Here in my store, I'll create a checkVerified methodI can use for any VerificationResult.If the result is unverified,I throw my own failedVerification errorto alert other parts of my app.If the result is verified,I unwrap the transaction and return it to the caller.Now I can use this checkVerified methodon the results of the purchase.Finally, with my transaction verified,I deliver the content to my user.After the user has the content,I need to make sure I tell StoreKitto finish the transaction.Then I need to return it so my UI can get updated.My app has an account database I maintain.I want to include my app's current logged in userwith the StoreKit purchaseso this information is always available to my appwhen it gets the App Store signed transaction.I can do this by creating an appAccountToken purchase optionusing a tokenized version of my logged-in accountand passing that option to the purchase method.OK.We're all set with my purchase method implementation.Let's run my app again.Now we're back in my store,and I'm feeling pretty adventurous.So I'm going to purchase a motorcyclebecause I've always wanted one.There's the payment sheet from StoreKitshowing me the purchase has been initiated properly.I'll tap to confirm the purchase.StoreKit then displays an alertshowing the purchase was successful.After I dismiss that alert,my buy button changes to a green checkmarkshowing my app trusts the transactionand my motorcycle has been delivered.There's one more important thing I want to note here.As I said previously,sometimes a customer will have to dosome extra verification on their accountor they'll need a parent's approvalbefore a purchase will complete.In these cases,the purchase result I receive from product.purchase()will be in a pending state.This means after the customer completesthe account verification or their parent gives approval,my app should update the UI to reflect the completed purchase.To listen for these transaction updates,I need to iterate over a static propertyon the transaction type.This property is an infinite async sequence.That means it will continue iteratingover transaction updates as they come in from StoreKituntil I choose to cancel or break out of the for loop.Here I'm creating a detach taskwhich will return a task handle I can useto explicitly cancel my update listenerwhen the store is deallocated.Just like all transactions I receive from StoreKit 2,I want to check if the verification result is verifiedbefore delivering content to the user.I can use my previously defined checkVerified method.And, just like with a purchase response,once I have my verified transaction,I need to deliver the content to my user.And of course, I always need to finish my transactions.It's very important I start my transaction update listeneras soon as my app launches so I don't miss a single one.I'm going to do this as soon as my store is created,which happens right around app launch.In order to test my update listener,I'm going to enable Ask To Buy in my Xcode test environmentto simulate a purchase response in a pending state.To do this, I select my StoreKit configuration fileand in the Editor menu, I select Enable Ask To Buy.Let's run my app again and do a purchase.This time, after I confirm on the payment sheet,I see a new alert from StoreKit saying I need to ask permissionto complete the purchase.I'll go ahead and tap Ask.The purchase response is returned to my appin a pending state.To approve the purchase, I'm going to openthe StoreKit testing in Xcode transaction managerand click the Approve button in the top-right corner.Great!Immediately after I approved the transaction,my update listener received the verification resultand the UI immediately changed to show the approved purchase.Now I have a brand-new, standard 5-seater to cruise around in.I just showed you how easy it is to request products,start a purchase,react to different purchase results,verify the integrity of a transaction,and receive updates from the App Store for pending transactions,all using StoreKit 2.Now let's go back to Ross for an introductionon working with your user's transaction historyand subscription status.Ross: Wow!  It’s pretty amazing to see these new APIs in action.And automatic validation, what more could you want?What's that?You love cryptographyand you still want to validate the data yourself?Not to worry.StoreKit 2's automatic validationraises the bar for security,but it isn't meant to completely replace your own validation.As always, security lies on a spectrumof strength, time, and complexity.I'll give you the scoop on validation a bit later.First, if you're as excited about StoreKit 2 transactionsas I am, you'll love to hearthat we're giving you lots of new ways to work with them.We're adding a new set of APIsfor querying completed transactionsin the user's transaction history.In StoreKit 2, you can accessall of the user's past transactionswith a single API call.You can also access the latest transaction for a product.So if you want to see just the most recent renewalof a subscription, you can.And we know that the number one thing you need to knowis what products the user has paid for access to right now.So we've distilled that informationinto a single function called CurrentEntitlements.Current entitlements contains all of the non-consumablesin the user's transaction history,as well as all of the subscription transactionsthat are currently active.With this, you have all of the information you needto unlock everything the user has paid for in your app.And since this represents only thingsthat the user should have access to right now,any transactions that have been revokedare not included in the response.Consumables are also not included,since they’re not a persistent part of the transaction history.Now, you must be thinking, "I can't wait!When can I start calling these in my app?"Well, with StoreKit 2,every transaction a user has ever completedis available to your app as soon as you ask for it.This means that when a user installs your appon a new device, you'll be able to tellwhich products they are entitled to get access toon the very first time your app is opened.Furthermore, transaction history will automatically updateacross users' devices.When your customer makes a purchase on one device,your app will be able to see the purchaseon every other device it's installed on.In fact, if your app is runningwhen a purchase is made on another device,you'll be notified about the new transaction.Jakob mentioned that it's importantto listen for transactions as soon as your app starts,and this is just one more reason that's true.So, all of this meansthat users won't need to restore completed transactionswhen your app is reinstalled or downloaded on a new device.Everything should automatically be fetched by StoreKitand stay up to date.But people use their Apple devices in millions of waysin millions of places.In the rare case that a user thinksthey should have a transaction but you don't see it,you can use the App Store sync API.This immediately resynchronizes all StoreKit 2 transactions.This is a replacement for therestoreCompletedTransactions API,and you should provide UI in your appthat allows users to initiate the sync.However, thanks to StoreKit 2's automatic synchronization,it should be very rarethat a user needs to initiate a sync manually.Automatic synchronization should cover the majority of cases.If a user does need to initiate a manual sync,they will be required to authenticate their account.For this reason,you should only use this API in response to user input.Finally, all transactions made using StoreKit 2 APIsare available in the original StoreKit APIs,and vice versa.So if your app has existing transactions,you will be able to see them in the StoreKit 2 APIsas soon as you start using them.New purchases made with the original StoreKit APIswill be available via StoreKit 2 APIs immediately,and purchases made with StoreKit 2will also be available inside the unified receiptwhen it is refreshed.In addition to transaction history,StoreKit 2 is also adding waysfor you to get detailed informationabout a user's subscription status.The subscription status has three parts.The first is the latest transaction.This conveniently lets you access the last transactionthat occurred for this subscription,and it's the same as if you calledthe latest transaction we talked about at earlier.The second is the renewal state.This is an enumeration that tells youthe current state of the subscription.If you just want to know what's going onwith the subscription right now, just look at this value.It'll tell you if it's currently subscribed,expired, in the grace period, and more.We've designed it to give you a single place to lookin order to make it easy to base app logic off this value.And the final part of the subscription status is the renewal info.This is where you can see all of the detailsabout a user's subscription.It contains all kinds of informationthat isn't in the transaction infobecause this data can actually change without a transaction.For example, in the renewal info,you can find the auto-renew status,which tells you if the user has auto-renew turned on or offfor this subscription.You can even see the product IDthat their auto-renewal is set for.So if a user has recently downgraded their subscription,you can see that right here,and maybe use that as an opportunity to present themwith a winback offer to stay at the higher tier.If the subscription is already expired,you can use the renewal info to see the expiration reason.And the full renewal info has all this data and more,plus another critical feature.That's right, all you cryptography buffs,the renewal info is signed using JWS!Just like the transaction info,the renewal info is a critical part of unlocking serviceand making marketing decisions.So we're giving you the confidence to knowthat it's valid and directly from Apple.And, to answer the questionthat I'm sure is running through your head right now,yes, StoreKit 2 will automatically validatethe renewal info for you.One final thing to know about the subscription status APIsis that they return an array of statuses.This is because, in some cases,users can have multiple subscriptionsto the same product.For example, a user may have subscribed to your product,and then also receive a subscriptionthrough Family Sharing.You should check the arrayto see what the highest level of service they're entitled to is.Now I'll hand it back to Jakob to show you what it looks liketo work with these transaction historyand subscription status APIs in your app code.Jakob: Thanks, Ross.Let's go back to the app I've been working onand update it to use the new transaction historyand subscription status APIs Ross just talked about.You'll notice the motorcycle I previously purchaseddoesn't have a green check,and after I navigate away from my store view, then back,the standard 5-seater doesn't have a green check either.As a user, I can't tell what I've already purchased.This is a problem easily solved with StoreKit 2.At any time, my app can query StoreKitfor which products have been purchasedso I can keep my app's UI always up to date.Over in my Store.swift file,the isPurchased method currently returns only false.Let's fix that with a simple callto Transaction.latest(for:).Then pass in my product identifierto get the most recent transaction.This StoreKit method returns another verification resulttelling me the transaction has passed throughStoreKit 2's verification check.I'll confirm the transaction is verified and unwrap itusing the checkVerified method I wrote previously.Then, I'll make sure my app doesn't deliver contentfor a transaction that has been refundedby checking revocationDate equals nil.Also, subscriptions where my customer has upgradedto a higher level of service in the middle of the periodwill have the isUpgraded flag set to true.I want to make sure my app is deliveringthe highest level of service my customer has subscribed to,so the isPurchased method should ignoreany upgraded transactions.For a subscription product,the transaction type tells only part of the story.In addition to the date of the transactionand the expiration date of the subscription,I also want to know when the next renewal date is,and whether my customer has turned off the auto-renewalfor their subscriptionor whether their next renewal periodwill change the level of service they're subscribed to.To get all this information,StoreKit 2 offers a subscription status API.In my SubscriptionsView.swift file,the updateSubscriptionStatus methodis responsible for getting the subscription statusfrom StoreKit and displaying it to the user.Because all of my subscription productsbelong to the same group, I can use any of themto get the current status for the group.I'll just choose the first subscription productfrom the store.Once I have a product,I can get the status property from the subscription.It's that easy.As Ross mentioned, it's possible for a userto be paying for their own personal subscriptionwhile they also have a subscription being sharedby a family member.So the status property will return an arraycontaining all the statuses for each subscription.Now, they could have a standard tier shared with themwhile they've personally subscribed to the pro tier.I want to make sure my user is able to getthe highest level of service they have access to,so I'll iterate through each status.Next, I'll check whether the statushas a state of expired or revoked.I want to ignore these casesand not display anything to the user.For all other cases, I'll get the renewalInfoand make sure it's verifiedusing the checkVerified method on my store.Once I confirm the renewalInfo is verified,I'll compare the level of serviceto the previous products.This check will get the corresponding productfor the subscription status,then it will compare with any previous product,and if it's a higher tier, we set highestStatusand highestProduct to the new subscription.Once I've checked all my statusesand I've determined the highest level of service,I'll set the status and current subscription of my view.Let's build and run now.Over in my store view,the products I previously purchasednow show a green checkmark to indicate I already own themand I don't need to buy them again.Let's see what happenswhen I purchase one of my subscription products.After I confirm the purchase,the status is displayed right in my store.I can let my user know what they're subscribed toand when their subscription will renewall using APIs built into StoreKit 2.Now how about this My Cars view?It should show all of my purchased products,but currently it's empty.To fill this in, I could iterate through all my products,then get the latest transaction for each,check the transaction's expiration dateand whether it has been refunded,but that sounds like a lot.Thankfully, I can use the power of StoreKit 2and a new, simple, and convenient APIto get all my user's valid transactionscalled currentEntitlements.Over in the My Cars view, I have this methodto refresh my purchased products when the view is loaded.Just like with transaction updates,I iterate over the current entitlements.But unlike transaction updates,the current entitlement's async sequence is finite,so it won't wait in the for loop forever,delivering new entitlements as the user makes more purchases.For each entitlement,I want to check the verification resultas I do with every other transaction.Once I know they're verified,I'll filter the entitlements into different arraysby switching over the productType property,just like I did with my original product request.Current entitlements will only return transactionsfor non-consumable and auto-renewable products.I can ignore any other product typeto complete my switch statementand keep the Swift compiler happy.Once I have the transaction,I need to get the associated product to display in my UI.For non-consumable transactions,I'll search the cars product array for the product identifiermatching this transaction.And likewise, I'll search the subscriptions product arrayto match any auto-renewable transactions.Let's run again and check out my UI.Now, when I go into the My Cars view,I see everything I've purchased.All my cars are grouped together at the topand my subscription is below.Now my app has a full working store and it looks awesome!And that's how you can use the transaction historyand subscription status APIs to make informed decisionsin your app about what UI your users see.Now let's go back to Ross who will talk more in depthon the JSON Web Signature object.Ross: Thanks again for the fantastic demo, Jakob.You can really see how the new transactionand subscription APIs come in handy.Now that we've seen the two waysthat StoreKit 2 uses JWS for security,I promised we'd take a closer look at itand how you can do your own validation.JSON Web Signature is comprised of three parts.The first is the header,which contains metadata about the object.This contains crucial informationsuch as which algorithm is used for signingand where to find the certificateused to validate the signature.StoreKit 2 currently uses an ECDSA algorithm,which is supported natively in Swift with CryptoKit.For the certificate, StoreKit 2 uses the x5c header,which indicates that the entire certificate chainis included in the JWS data.This means that no internet connection is necessaryin order to validate these JWS signatures.The next part of the JWS data is the payload.This is the main information such as transaction ID,product ID, purchase date, and so on.Once you've validated the signature,this is where you go to read all the data you want to knowabout the transaction or subscription.And the final part of the JWS data is the signature itself.This is generated using both the header and the payload.Validating the JWS signatureis a well-documented part of the standard,so I recommend going straight to the original sourceif you're interested in writing your own implementation.I've included a link to this document in the resourcesassociated with this session.Once you've validated the signature from the JWS data,there are just a couple more things you should doto make sure the signed info is valid for your appand the current device.First, you should make sure that the bundle IDpresent in the signed info payloadmatches the bundle ID of your app.We recommend that for added security,you embed your app's bundle ID somewhere in the app,rather than relying on an API call,and use that value to compare it to the bundle ID in the payload.And the final thing you should dois perform a device validation check.This ensures that the signed info was actually generatedfor the device it currently on.Use the StoreKit 2 API AppStore.deviceVerificationIDto retrieve the current device verification identifier.Then, take the device verification noncefrom the signed infoand append the device verification identifieryou just got from StoreKit.Perform a SHA384 hash on this value and compare the resultto the device verification field from the signed info.If they match, then the signed info was generatedfor this device and your signed info validation is complete.One final thing to note is that these new JWS objectsare for in-app purchase only.So if you need to validate the app receipt,you should use the existing API and process for that.And of course, we are offering new App Store server APIsfor these new JWS objects,so you can retrieve and validate them directly on your server.Well, I hope you were as excited to meet StoreKit 2as we were to introduce it to you today.StoreKit 2 is making in-app purchase even betterwith new APIs that give you more informationand are easier to use than ever.This includes new JSON-based info objectsfor each transaction,as well as APIs to give you transaction detailsand historical transaction data in your native code.Combine that with the new subscription status APIs,and StoreKit 2 unlocks a wealth of possibilitiesfor your in-app purchases.To learn even more about in-app purchase,I encourage you to watch these other sessionsfor server-side coding and supporting customers.Jakob and I are thrilledwe could introduce you to StoreKit 2.Thanks for joining us at WWDC21!♪

♪ Bass music playing ♪♪Ross LeBeau: Hi, and welcome to WWDC21.My name is Ross LeBeau,and I'm an engineer on the StoreKit team.Today, we're going to be talking about StoreKit,and this is actually one of three sessionsdesigned to help you implement client-side code,build out your server for in-app purchase,and support your customers and handle refunds.This session is Meet StoreKit 2,and you can find the other two sessions here at WWDC21.This session will focus on client-side featuresand implementation.So let's get started!Since StoreKit was introduced in iOS 3,it's created great opportunities for you and your businesses.Today, it exists on four Apple platformsand supports everything from games to news apps,indie titles to international hits.Over the years, we've introduced great featuressuch as offer codes, Family Sharing,and StoreKit testing in Xcode.But this year, we decided to go back to the beginning.Today, I'm excited to introduce you to StoreKit 2!StoreKit 2 is a brand new set of modern and flexible Swift APIsfor working with In-App Purchaseacross iOS, macOS, tvOS, and watchOS.We've taken a new look at StoreKitwith a Swift-first mindset.We embraced some of the newest language features,like Swift concurrency using the async/await pattern,to create simple yet powerful APIs.We've also made some huge updatesto the in-app purchase transactions,making them much easier to work with,while also providing more information and high security.And we've added more powerful APIsspecifically for subscriptionsin order to give you deeper insight that you can useto grow your business.StoreKit 2 APIs live inside the same StoreKit frameworkthat exists todayand focus on the core in-app purchase experiencerather than replacing every API.The new StoreKit 2 APIs are comprised of five major areas:Products, Purchases, Transaction info,Transaction history, and subscription status.Today I'm going to give you an overview of each of these areas,and my colleague Jakob will be showing you how to usethe corresponding StoreKit 2 APIs in real code.So first, let's start with the building blocks of StoreKit:products and purchases.The StoreKit 2 product struct is a supercharged versionof the StoreKit product object you're used to.To start, we've added additional data to it,such as the product typeand extended subscription information.With StoreKit 2, we're making it easier to do thingslike find out if the customer is eligiblefor your introductory offer.We're also making StoreKit 2 productsforward-compatible with new features.We've accomplished this by adding a wrapping typecalled BackingValuethat allows you to retrieve data contained in the productby subscripting the products directly.This means that if we add data to products in the future,you'll always be able to access them in StoreKit 2,even on SDKs and devices running operating systemsthat have older versions of StoreKit 2.This means that you can use the latest featuresto provide new functionalityto a larger section of your customer base.With StoreKit 2, you request products by callinga static function on the product type itself.This requests product metadata from the App Storejust like the existing SKProductsRequest does.But thanks to the new Swift concurrency async/await pattern,the StoreKit 2 product request requires just one line of code.Similarly, purchasing a product in StoreKit 2is another simple, one-line task.Purchase is now an instance method on the product type,meaning you can take those products you just retrievedand call purchase directly on them.Since the purchase method also uses async/await,you get the result of your purchase inline in your code.Now we know that not every purchase is the same.If you want to modify purchase behaviorbeyond the default settings, StoreKit 2 has Purchase options.A Purchase option is an itemthat describes a single property of a purchase.You can compose Purchase options into a setwhich you pass into the purchase method.StoreKit 2 includes purchase options for thingssuch as quantity and promotional offers.And in StoreKit 2, we're adding a new optioncalled App account token.The App account token is a way for you to keep trackof which of your app's user accountsbegan and completed a transaction.It’s an opaque token that you generatewhich you can link to accounts that your app owns.It's easy to generate an App account token,because the only requirement is that it conformsto the UUID format.You send up an App account token on the purchaseas a Purchase option,and this token is returned in the transaction infofor that purchase.The App account token stays in the transaction info forever,even across devices.If your app supports its own account system,this can help you keep track of which purchaseseach in-app account has made,regardless of the Apple ID or devicethat was used to purchase them.So, we've talked about getting products from the App Storeand initiating a purchase;now what happens when that purchase completes?As you might expect,StoreKit is going to return a successful transaction to youalong with cryptographically signed information.Sounds familiar, right?Well, StoreKit 2 is bringing the biggest updateto in-app purchase transactions ever.To start, StoreKit 2 will be providingan individually signed object for every transaction.Not only that, but starting in StoreKit 2,in-app purchase transaction info will now be providedin a very common, easy-to-work-with format: JSON.And since we know that secure cryptographic signingis an important part of StoreKit purchases,we're now using a common standard used across the webknown as JSON Web Signature.Plus, all the information contained in the signed objectwill now be available through native StoreKit APIs,making it easy to work with this data in your app's code.In fact, we'll show you just how easy it is.Here's Jakob with a demonstration of these APIsin real code.Jakob Swank: Hi, I'm Jakob.I'm an engineer on the StoreKit team.I'm really excited today to be showing you how easy it isto get up and running with StoreKit 2 in your app.On the right, I have an app I'm building called Pocket Cars.You can download the sample code for this appin the resources section of this session and follow along.The app has two main views.There's a view for my collected cars and a view for my store.Let's go over to the store.Currently, my store is emptybecause I have no products available for sale.I'm going to go ahead and implement those now.To get up and running quickly,I'm using StoreKit testing in Xcode.This allows me to build and test my storebefore defining products in App Store Connect.In my Xcode project,I've already created a StoreKit configuration filedefining the products I want to sell.This is the same configuration file I was using for StoreKit;I don't need to change or migrate anything.Here, I also have a plistcontaining all my product identifiers.It's included as a resource file built into my appso I can use it at runtime.To display these products in my store,I first need to make a product requestusing a set of the product identifiers I want to display.With StoreKit 2, I can do thissimply by calling a static method on the Product struct.After I receive the products from the App Store,I want to separate them by type.I can do this easily with StoreKit 2since the Product type now provides a propertyfor the type as it's defined on the App Store server.In my app, I'm selling three types of products:fuel, cars, and a navigation package.Fuel is a consumable product -- once I use it, it's gone --so I'll put all the consumables in to the fuel array.Cars are a non-consumable.Once I purchase a car, I own it forever.So I'll put all the non-consumablesinto the cars array.The navigation package is a subscription productwith three levels of service.My customers can subscribe to one level of service at a time,and they are billed periodically.Also, they can upgrade or downgrade at any timeif they want to change their level of service.The App Store will return a Productfor each level of service,so I'll put all the auto-renewable subscriptionsinto the subscriptions array.I also want to sort my products within each type by price,lowest to highest.Let's run my app and check out what I've done so far.

Now I'll navigate to the store.Wow!Before, my store was empty,but now it's looking pretty greatwith all my products displayed.With just one line of code,I was able to request my app's products from the App Store,then I was able to group and sort those productsbased only on the metadata I receivedwhich made it easy to build my store UI.Now my products are looking great,but if I tap a buy button, nothing happens.That's because the purchase method in my storedoesn't do anything.It should initiate the purchase with StoreKit.We can do this simply by calling the purchase methodon the product.As Ross mentioned,StoreKit 2 was built from the ground upto use the new concurrency capabilities of Swift.This allows my app to keep the code for purchasingand processing the result of that purchaseall within the same contextin order to keep my code easy to read.When a purchase completes, a PurchaseResult is returned.This PurchaseResult lets me knowwhether the purchase was successfulor if it completed in some other non-error state,such as the user cancelled the purchaseor the purchase needs some extra bank validationor approval from a parent.To handle each case, I'll just switch over them.If the PurchaseResult is in the success state,I also get a verification result.A verification result contains two cases:verified and unverified.In StoreKit 2, the transaction type contains the JWS payloadwhich represents the signed transaction.Every time my app receives a transaction from StoreKit 2,the transaction has passed through a verification processto confirm whether the payload is signed by the App Storefor my app for this device.You heard that right.StoreKit 2 does transaction verification for you.Of course, how I choose to handle the verification resultis entirely up to me and the needs of my business.For my app, I'm going to make surethis transaction I received from StoreKit has been verified.Here in my store, I'll create a checkVerified methodI can use for any VerificationResult.If the result is unverified,I throw my own failedVerification errorto alert other parts of my app.If the result is verified,I unwrap the transaction and return it to the caller.Now I can use this checkVerified methodon the results of the purchase.Finally, with my transaction verified,I deliver the content to my user.After the user has the content,I need to make sure I tell StoreKitto finish the transaction.Then I need to return it so my UI can get updated.My app has an account database I maintain.I want to include my app's current logged in userwith the StoreKit purchaseso this information is always available to my appwhen it gets the App Store signed transaction.I can do this by creating an appAccountToken purchase optionusing a tokenized version of my logged-in accountand passing that option to the purchase method.OK.We're all set with my purchase method implementation.Let's run my app again.

Now we're back in my store,and I'm feeling pretty adventurous.So I'm going to purchase a motorcyclebecause I've always wanted one.There's the payment sheet from StoreKitshowing me the purchase has been initiated properly.I'll tap to confirm the purchase.StoreKit then displays an alertshowing the purchase was successful.After I dismiss that alert,my buy button changes to a green checkmarkshowing my app trusts the transactionand my motorcycle has been delivered.There's one more important thing I want to note here.As I said previously,sometimes a customer will have to dosome extra verification on their accountor they'll need a parent's approvalbefore a purchase will complete.In these cases,the purchase result I receive from product.purchase()will be in a pending state.This means after the customer completesthe account verification or their parent gives approval,my app should update the UI to reflect the completed purchase.To listen for these transaction updates,I need to iterate over a static propertyon the transaction type.

This property is an infinite async sequence.That means it will continue iteratingover transaction updates as they come in from StoreKituntil I choose to cancel or break out of the for loop.Here I'm creating a detach taskwhich will return a task handle I can useto explicitly cancel my update listenerwhen the store is deallocated.Just like all transactions I receive from StoreKit 2,I want to check if the verification result is verifiedbefore delivering content to the user.I can use my previously defined checkVerified method.And, just like with a purchase response,once I have my verified transaction,I need to deliver the content to my user.And of course, I always need to finish my transactions.It's very important I start my transaction update listeneras soon as my app launches so I don't miss a single one.I'm going to do this as soon as my store is created,which happens right around app launch.In order to test my update listener,I'm going to enable Ask To Buy in my Xcode test environmentto simulate a purchase response in a pending state.To do this, I select my StoreKit configuration fileand in the Editor menu, I select Enable Ask To Buy.Let's run my app again and do a purchase.

This time, after I confirm on the payment sheet,I see a new alert from StoreKit saying I need to ask permissionto complete the purchase.I'll go ahead and tap Ask.The purchase response is returned to my appin a pending state.To approve the purchase, I'm going to openthe StoreKit testing in Xcode transaction managerand click the Approve button in the top-right corner.

Great!Immediately after I approved the transaction,my update listener received the verification resultand the UI immediately changed to show the approved purchase.Now I have a brand-new, standard 5-seater to cruise around in.I just showed you how easy it is to request products,start a purchase,react to different purchase results,verify the integrity of a transaction,and receive updates from the App Store for pending transactions,all using StoreKit 2.Now let's go back to Ross for an introductionon working with your user's transaction historyand subscription status.Ross: Wow!  It’s pretty amazing to see these new APIs in action.And automatic validation, what more could you want?What's that?You love cryptographyand you still want to validate the data yourself?Not to worry.StoreKit 2's automatic validationraises the bar for security,but it isn't meant to completely replace your own validation.As always, security lies on a spectrumof strength, time, and complexity.I'll give you the scoop on validation a bit later.First, if you're as excited about StoreKit 2 transactionsas I am, you'll love to hearthat we're giving you lots of new ways to work with them.We're adding a new set of APIsfor querying completed transactionsin the user's transaction history.In StoreKit 2, you can accessall of the user's past transactionswith a single API call.You can also access the latest transaction for a product.So if you want to see just the most recent renewalof a subscription, you can.And we know that the number one thing you need to knowis what products the user has paid for access to right now.So we've distilled that informationinto a single function called CurrentEntitlements.Current entitlements contains all of the non-consumablesin the user's transaction history,as well as all of the subscription transactionsthat are currently active.With this, you have all of the information you needto unlock everything the user has paid for in your app.And since this represents only thingsthat the user should have access to right now,any transactions that have been revokedare not included in the response.Consumables are also not included,since they’re not a persistent part of the transaction history.Now, you must be thinking, "I can't wait!When can I start calling these in my app?"Well, with StoreKit 2,every transaction a user has ever completedis available to your app as soon as you ask for it.This means that when a user installs your appon a new device, you'll be able to tellwhich products they are entitled to get access toon the very first time your app is opened.Furthermore, transaction history will automatically updateacross users' devices.When your customer makes a purchase on one device,your app will be able to see the purchaseon every other device it's installed on.In fact, if your app is runningwhen a purchase is made on another device,you'll be notified about the new transaction.Jakob mentioned that it's importantto listen for transactions as soon as your app starts,and this is just one more reason that's true.So, all of this meansthat users won't need to restore completed transactionswhen your app is reinstalled or downloaded on a new device.Everything should automatically be fetched by StoreKitand stay up to date.But people use their Apple devices in millions of waysin millions of places.In the rare case that a user thinksthey should have a transaction but you don't see it,you can use the App Store sync API.This immediately resynchronizes all StoreKit 2 transactions.This is a replacement for therestoreCompletedTransactions API,and you should provide UI in your appthat allows users to initiate the sync.However, thanks to StoreKit 2's automatic synchronization,it should be very rarethat a user needs to initiate a sync manually.Automatic synchronization should cover the majority of cases.If a user does need to initiate a manual sync,they will be required to authenticate their account.For this reason,you should only use this API in response to user input.Finally, all transactions made using StoreKit 2 APIsare available in the original StoreKit APIs,and vice versa.So if your app has existing transactions,you will be able to see them in the StoreKit 2 APIsas soon as you start using them.New purchases made with the original StoreKit APIswill be available via StoreKit 2 APIs immediately,and purchases made with StoreKit 2will also be available inside the unified receiptwhen it is refreshed.In addition to transaction history,StoreKit 2 is also adding waysfor you to get detailed informationabout a user's subscription status.The subscription status has three parts.The first is the latest transaction.This conveniently lets you access the last transactionthat occurred for this subscription,and it's the same as if you calledthe latest transaction we talked about at earlier.The second is the renewal state.This is an enumeration that tells youthe current state of the subscription.If you just want to know what's going onwith the subscription right now, just look at this value.It'll tell you if it's currently subscribed,expired, in the grace period, and more.We've designed it to give you a single place to lookin order to make it easy to base app logic off this value.And the final part of the subscription status is the renewal info.This is where you can see all of the detailsabout a user's subscription.It contains all kinds of informationthat isn't in the transaction infobecause this data can actually change without a transaction.For example, in the renewal info,you can find the auto-renew status,which tells you if the user has auto-renew turned on or offfor this subscription.You can even see the product IDthat their auto-renewal is set for.So if a user has recently downgraded their subscription,you can see that right here,and maybe use that as an opportunity to present themwith a winback offer to stay at the higher tier.If the subscription is already expired,you can use the renewal info to see the expiration reason.And the full renewal info has all this data and more,plus another critical feature.That's right, all you cryptography buffs,the renewal info is signed using JWS!Just like the transaction info,the renewal info is a critical part of unlocking serviceand making marketing decisions.So we're giving you the confidence to knowthat it's valid and directly from Apple.And, to answer the questionthat I'm sure is running through your head right now,yes, StoreKit 2 will automatically validatethe renewal info for you.One final thing to know about the subscription status APIsis that they return an array of statuses.This is because, in some cases,users can have multiple subscriptionsto the same product.For example, a user may have subscribed to your product,and then also receive a subscriptionthrough Family Sharing.You should check the arrayto see what the highest level of service they're entitled to is.Now I'll hand it back to Jakob to show you what it looks liketo work with these transaction historyand subscription status APIs in your app code.Jakob: Thanks, Ross.Let's go back to the app I've been working onand update it to use the new transaction historyand subscription status APIs Ross just talked about.You'll notice the motorcycle I previously purchaseddoesn't have a green check,and after I navigate away from my store view, then back,the standard 5-seater doesn't have a green check either.As a user, I can't tell what I've already purchased.This is a problem easily solved with StoreKit 2.At any time, my app can query StoreKitfor which products have been purchasedso I can keep my app's UI always up to date.Over in my Store.swift file,the isPurchased method currently returns only false.Let's fix that with a simple callto Transaction.latest(for:).Then pass in my product identifierto get the most recent transaction.This StoreKit method returns another verification resulttelling me the transaction has passed throughStoreKit 2's verification check.I'll confirm the transaction is verified and unwrap itusing the checkVerified method I wrote previously.Then, I'll make sure my app doesn't deliver contentfor a transaction that has been refundedby checking revocationDate equals nil.Also, subscriptions where my customer has upgradedto a higher level of service in the middle of the periodwill have the isUpgraded flag set to true.I want to make sure my app is deliveringthe highest level of service my customer has subscribed to,so the isPurchased method should ignoreany upgraded transactions.For a subscription product,the transaction type tells only part of the story.In addition to the date of the transactionand the expiration date of the subscription,I also want to know when the next renewal date is,and whether my customer has turned off the auto-renewalfor their subscriptionor whether their next renewal periodwill change the level of service they're subscribed to.To get all this information,StoreKit 2 offers a subscription status API.In my SubscriptionsView.swift file,the updateSubscriptionStatus methodis responsible for getting the subscription statusfrom StoreKit and displaying it to the user.Because all of my subscription productsbelong to the same group, I can use any of themto get the current status for the group.I'll just choose the first subscription productfrom the store.Once I have a product,I can get the status property from the subscription.It's that easy.As Ross mentioned, it's possible for a userto be paying for their own personal subscriptionwhile they also have a subscription being sharedby a family member.So the status property will return an arraycontaining all the statuses for each subscription.Now, they could have a standard tier shared with themwhile they've personally subscribed to the pro tier.I want to make sure my user is able to getthe highest level of service they have access to,so I'll iterate through each status.Next, I'll check whether the statushas a state of expired or revoked.I want to ignore these casesand not display anything to the user.For all other cases, I'll get the renewalInfoand make sure it's verifiedusing the checkVerified method on my store.Once I confirm the renewalInfo is verified,I'll compare the level of serviceto the previous products.This check will get the corresponding productfor the subscription status,then it will compare with any previous product,and if it's a higher tier, we set highestStatusand highestProduct to the new subscription.Once I've checked all my statusesand I've determined the highest level of service,I'll set the status and current subscription of my view.Let's build and run now.

Over in my store view,the products I previously purchasednow show a green checkmark to indicate I already own themand I don't need to buy them again.Let's see what happenswhen I purchase one of my subscription products.

After I confirm the purchase,the status is displayed right in my store.I can let my user know what they're subscribed toand when their subscription will renewall using APIs built into StoreKit 2.Now how about this My Cars view?It should show all of my purchased products,but currently it's empty.To fill this in, I could iterate through all my products,then get the latest transaction for each,check the transaction's expiration dateand whether it has been refunded,but that sounds like a lot.Thankfully, I can use the power of StoreKit 2and a new, simple, and convenient APIto get all my user's valid transactionscalled currentEntitlements.Over in the My Cars view, I have this methodto refresh my purchased products when the view is loaded.Just like with transaction updates,I iterate over the current entitlements.But unlike transaction updates,the current entitlement's async sequence is finite,so it won't wait in the for loop forever,delivering new entitlements as the user makes more purchases.For each entitlement,I want to check the verification resultas I do with every other transaction.Once I know they're verified,I'll filter the entitlements into different arraysby switching over the productType property,just like I did with my original product request.Current entitlements will only return transactionsfor non-consumable and auto-renewable products.I can ignore any other product typeto complete my switch statementand keep the Swift compiler happy.Once I have the transaction,I need to get the associated product to display in my UI.For non-consumable transactions,I'll search the cars product array for the product identifiermatching this transaction.And likewise, I'll search the subscriptions product arrayto match any auto-renewable transactions.Let's run again and check out my UI.

Now, when I go into the My Cars view,I see everything I've purchased.All my cars are grouped together at the topand my subscription is below.Now my app has a full working store and it looks awesome!And that's how you can use the transaction historyand subscription status APIs to make informed decisionsin your app about what UI your users see.Now let's go back to Ross who will talk more in depthon the JSON Web Signature object.Ross: Thanks again for the fantastic demo, Jakob.You can really see how the new transactionand subscription APIs come in handy.Now that we've seen the two waysthat StoreKit 2 uses JWS for security,I promised we'd take a closer look at itand how you can do your own validation.JSON Web Signature is comprised of three parts.The first is the header,which contains metadata about the object.This contains crucial informationsuch as which algorithm is used for signingand where to find the certificateused to validate the signature.StoreKit 2 currently uses an ECDSA algorithm,which is supported natively in Swift with CryptoKit.For the certificate, StoreKit 2 uses the x5c header,which indicates that the entire certificate chainis included in the JWS data.This means that no internet connection is necessaryin order to validate these JWS signatures.The next part of the JWS data is the payload.This is the main information such as transaction ID,product ID, purchase date, and so on.Once you've validated the signature,this is where you go to read all the data you want to knowabout the transaction or subscription.And the final part of the JWS data is the signature itself.This is generated using both the header and the payload.Validating the JWS signatureis a well-documented part of the standard,so I recommend going straight to the original sourceif you're interested in writing your own implementation.I've included a link to this document in the resourcesassociated with this session.Once you've validated the signature from the JWS data,there are just a couple more things you should doto make sure the signed info is valid for your appand the current device.First, you should make sure that the bundle IDpresent in the signed info payloadmatches the bundle ID of your app.We recommend that for added security,you embed your app's bundle ID somewhere in the app,rather than relying on an API call,and use that value to compare it to the bundle ID in the payload.And the final thing you should dois perform a device validation check.This ensures that the signed info was actually generatedfor the device it currently on.Use the StoreKit 2 API AppStore.deviceVerificationIDto retrieve the current device verification identifier.Then, take the device verification noncefrom the signed infoand append the device verification identifieryou just got from StoreKit.Perform a SHA384 hash on this value and compare the resultto the device verification field from the signed info.If they match, then the signed info was generatedfor this device and your signed info validation is complete.One final thing to note is that these new JWS objectsare for in-app purchase only.So if you need to validate the app receipt,you should use the existing API and process for that.And of course, we are offering new App Store server APIsfor these new JWS objects,so you can retrieve and validate them directly on your server.Well, I hope you were as excited to meet StoreKit 2as we were to introduce it to you today.StoreKit 2 is making in-app purchase even betterwith new APIs that give you more informationand are easier to use than ever.This includes new JSON-based info objectsfor each transaction,as well as APIs to give you transaction detailsand historical transaction data in your native code.Combine that with the new subscription status APIs,and StoreKit 2 unlocks a wealth of possibilitiesfor your in-app purchases.To learn even more about in-app purchase,I encourage you to watch these other sessionsfor server-side coding and supporting customers.Jakob and I are thrilledwe could introduce you to StoreKit 2.Thanks for joining us at WWDC21!♪

## Code Samples


# Wwdc2021 10030

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Develop advanced web contentDevelop in JavaScript, WebGL, or WebAssembly? Learn how the latest updates to Safari and WebKit — including language changes to class syntax — can help simplify your development process, enhance performance, and improve security. We'll explore several web APIs that can help provide better interoperability and bring new capabilities to your web content.ResourcesIntroducing Storage Access APISafari Release NotesSafari Technology PreviewWebKit Open Source ProjectHD VideoSD VideoRelated VideosWWDC21Coordinate media playback in Safari with Group ActivitiesDesign for Safari 15Discover Web Inspector improvementsExplore Safari Web Extension improvementsExplore WKWebView additionsMeet privacy-preserving ad attributionMeet Safari Web Extensions on iOS

Develop in JavaScript, WebGL, or WebAssembly? Learn how the latest updates to Safari and WebKit — including language changes to class syntax — can help simplify your development process, enhance performance, and improve security. We'll explore several web APIs that can help provide better interoperability and bring new capabilities to your web content.

Introducing Storage Access API

Safari Release Notes

Safari Technology Preview

WebKit Open Source Project

HD VideoSD Video

HD Video

SD Video

Coordinate media playback in Safari with Group Activities

Design for Safari 15

Discover Web Inspector improvements

Explore Safari Web Extension improvements

Explore WKWebView additions

Meet privacy-preserving ad attribution

Meet Safari Web Extensions on iOS

Search this video…♪ Bass music playing ♪♪Sihui Liu: Hello. Welcome to “Develop advanced web content.”I'm Sihui, and I am an engineer on the Safari and WebKit team.I am happy to share with you the important updateswe have made in WebKit and Safarifor web developers in the past year.The things I'm about to sharegenerally fall into three categories.First, I will walk you through new features and enhancementsin JavaScript.Then I will give you an overview of the updates in WebAssembly.And finally, I will introduce you to some new web APIsthat can add additional capabilitiesto your web content.There is a lot to cover,so let’s begin with our news in JavaScript.Each year, there are hundreds of changes madein our JavaScript engine.I will cover some of the most important onesyou need know if you work with JavaScript.They are: new class field syntax,weak references that enables smarter memory management,new usage of the await keyword,support for modules in workers,and interfaces added to Internationalization API family.To put you in the picture of these new features,I'm going to use a simple stopwatch as example.The stopwatch has only one button.Click it once, it begins counting.Click it again, it will stopand give you the duration passed.Keep this in mindand we will implement it later in JavaScript.Now, let’s take a look at the new class field syntax.We have new private class fields and methodsthat let you define real private memberswhose access is protected by the language.You will see an error if you break the access rules.We also add support for static fields,which allows you to declare a class memberthat can be accessedwithout creating an instance of the class.Now you have the basic idea.Let’s check how it can be used with the stopwatch example.If you are asked to implement the stopwatch class,your implementation may look like this.StopwatchWithOneButton has only one methodnamed click().It checks startTime variable.If start time is unset, the click means to start,so it will set the start time.If start time is already set, the click means to stop,so it will calculate a duration and reset the start time.You can see startTime comes with an underscore prefix.This is a naming convention commonly used to denotethat the variable should only be used inside of the class.But that does not actually prevent the start timefrom being accessed publicly.The new private syntax can help fix this.Just replace the underscore with hash,and you can declare a real private instance field.The encapsulation is enforced by the language.There is also support for private methods.For example, to make click() methods more structured,we can create two private methodsstart() and stop()to replace the highlighted content, like this.By adding the hash prefix to methods,we make sure the member functions can only be accessedfrom inside of the class.The new private syntax also applies to static fieldslike startedStopwatchCount.Here, startedStopwatchCount can only be modifiedby stopwatch objects at start or stop times.Of course, if you want startedStopwatchCountto be accessed everywhere,you can declare it as public static field,without the hash prefix.Public static field is also available in WebKit now.Private instance fields, methods,private static fields, and public static fields;that’s our new class field support.And let’s continue to another feature,weak references.Weak references allow you to hold referenceto a JavaScript object in a waythat does not prevent garbage collection.Unlike WeakMap and WeakSet,you can get the underlying objectwithout already having a reference to it.The support also includesnotification on garbage collection,so you may perform some cleanup task if you need to.And let’s see how it can be used.We just implemented the stopwatch class.Now imagine you have created multiple stopwatch objectsfor different tasks.For testing, you need to click all of them at a time.How would you do that?An intuitive way is to keepa set of all stopwatch instances.When the stopwatch is created, add it to the set.Then in clickAllStopwatches function,iterate the set and click each stopwatch.But there is an issue with this approach.We know JavaScript objectshold strong reference by default, so in this caseall stopwatch objects cannot be garbage collectedbecause the set still has reference to them.Of course, we don’t want to keep all stopwatch objects aroundjust for testing.This is not great for memory use.Now, you may suggest just replacing Set with WeakSet,but WeakSet is not iterable.So what would you do?We can solve it with the new interface WeakRef,which holds weak references to an object.We still have the set,but this time we add WeakRef of stopwatch objects to the set.In clickAllStopwatches function,we check if the object still existsby dereferencing it before clicking.This seems to solve our issue, but there is another problem:we don’t remove garbage-collected stopwatchesfrom the set in a timely manner,and the set can grow quite large before our next click test.Now what should we do?Another new interface -- FinalizationRegistry --may help in this case.With it, you can specify a callback to be invokedat when some object is garbage collected.Here we create a finalizationRegistry objectwith removeStopwatch function, so this function is calledevery time an object is collected.Then, we register stopwatch objects to the registry.Each stopwatch is bound with an identifier,so removeStopwatch knows which stopwatch to remove.Good, now garbage-collected stopwatches will be removedfrom allStopwatches.The usage of weak references sounds not that hard, right?But be aware that garbage collection in JavaScriptis very complicated,and there is a lot of uncertainty.For example,the object you think should be collectedmay not actually be collected until a long time after,and you may not get the callback from FinalizationRegistryright way because it runs on event loop.Therefore, make sure you fully understand the syntaxand its expected behavior before use.Let’s move on from weak referencesto the next feature, top-level await.This is a new feature for modules.It enables you to use the await keywordoutside of the async function.In this case, the module itself is like a big async function,so an async module can blockthe execution of the module importing them.Let me show you an example with our stopwatch class.This is the class we just created.To illustrate a use of top-level await,let’s make it a module and export the class.This is an HTML file that contains an inline module.It imports the stopwatch module using dynamic import.The import function returns a promise,so we can use then or catch methods to perform actionsafter import is done.With top-level await,you can remove the chaining methodsand write the code in a synchronous way.This can make your code easier to follow.Also, because imported modules are evaluated at load time,so an async module can block execution of modulesdepending on it.That means if stopwatch module runs async operationsand waits for result,the stopwatch variable here will be initializedafter stopwatch module finishes execution.Top-level await has made it easierto do dependency management.But again, this feature is only available in modules,so if the script is not a module, like this......you will see a syntax error in Web Inspector.Speaking of modules, there’s another related feature:module workers.Workers has some well-known benefits.It can run scripts in a background thread,so resources can be utilized more efficiently.With this new support,workers now share the benefits of modules,including dynamic import, optimized loading and execution,and dependency management.It is more beneficial and easier for you to move heavy workfrom main thread to background thread now.Modules is now available in different types of workers,including web worker, service worker, and worklet.To create a module worker,for web workers and service worker,you need to specify type to be module in the options.For a worklet like Audio Worklet,you can use addModule function.It’s quite easy to create a module workerthat helps speed up your application.Last in JavaScript sectionis updates on the Internationalization API.This API provides language-based formatting.It is useful if your web content is built for usersin different locales.To show you how it can be used,I built this stopwatch records page because, you know,stopwatch needs to keep up with timesand our feature releases.This page shows us details about a single use of stopwatch,including duration, start time, event, participants,and the available languages of the page.Now, let’s dive into each sectionand take a closer look of each interface.First is NumberFormat.NumberFormat provideslanguage-sensitive number formatting,and it is used to format the duration.Constructor of NumberFormat takes two optional parameters:language and options.Here I set the language to Englishand I make two options object,which specify different minimum numbers of digits.After creating two NumberFormat objectswith language and options,we can use them to format the duration numbers.Here, if number is not milliseconds,I use Format1 to keep two digits;otherwise I use Format2 to keep three digits.As you can see, the format methodautomatically adds padding zeroes for us.There are many different options you can utilizeto create formats you need, such as style,where you can specify value to be currency or unit.Next is DateTimeFormat,which enables language-sensitive date and time formatting.The usage is similar to NumberFormat.First, set the language.Then, set the options.In the options, I set different stylesfor date and time.The DateTimeFormat objectprovides a fine-grained configurationthat even allows you to specify style for second or millisecond.After that, we can create a DateTimeFormat objectwith parameters,and use it to format our start time.The result is represented in English.You can see date is more detailedbecause it has the long style.Next one is Segmenter.It enables you to dolanguage-sensitive string splitting.I used it to find keywords in the event sentence.This is the Chinese version of the stopwatch records page.First, I declare a short list of keywords I want to highlight.The event string even includes a Unicodefor the Celsius degree symbol.Here we specify Chinese as language.In options, the granularity is set to be a word.The other possible values are grapheme and sentence.Then we create a Segmenterand use it to split the string with segment method.We can iterate the result objects to get all segments.Check and see if each segmentis contained in the keyword list to mark it.Segmenter is quite useful for interpreting languages,like Chinese, where the word boundary is not that obvious.The next is ListFormat,which enables language-sensitive list formatting.The same as before,we can specify language and options.ListFormat does not have as many optionsas the other interfaces.The most useful ones I found are type and style.With language and options, we can create a ListFormatand format the participants list we have.As you can see,because the type is conjunction and the style is long,the format method adds a comma and a word “and” in the result.The last one is DisplayNames.It provides consistent translation of display namesfor language, region, and script.Here I specify language to be Japanese.DisplayNames can take language code as input.In the options, we set type as language.Then we can create DisplayNames object.And here, using of method,we can get the translated result.Even though this page is built in English,Japanese users can know what languages are supported.And this is how I built the stopwatch records pagewith new internationalization interfaces.To refresh your memory, here is the list of thingswe’ve just looked at in the JavaScript section.Following that, our next stop is updates in WebAssembly.We’ve been shipping our WebAssembly enginefor a while, but in case you’re not familiar with it,let me begin by filling in with some backgroundof WebAssembly.WebAssembly is a binary instruction formatfor a stack-based virtual machine.It is a type of a code that can be run in modern web browserswith performance close to native code.WebAssembly is designed to be a portable compilation targetfor programming languages like C, C++, or Rust,so WebAssembly can help us deploy applicationswritten in those languages on the web.In most use cases of WebAssembly,it runs alongside with JavaScript.They can communicate with each otherthrough the WebAssembly API.WebAssembly can provide near-native performance,and makes powerful frameworks available on the web.JavaScript can manipulate the DOMand offers powerful web APIs.They can be good additions to each other.A good example of WebAssembly use is Funky Karts.It is a game converted from C++ to WebAssembly with Emscripten.As you can see, it gets to run very smoothly in Safari.This year, we’ve upgraded our WebAssembly enginewith following features: new memory instructionsthat give you better performance on bulk memory operations,like copying or initializing blocks of memory;new instructions to tell user processnot to trap on exception, like positive overflowwhen converting between float and int;new sign-extension operatorsthat let you extend a signed integer;implementation of the latest proposal to convertbetween WebAssembly type i64 and JavaScript BigInt,which is simpler than previous solutionsand can make your code run faster;new reference types that allows WebAssembly modulesto hold references to JavaScript and DOM objects,passing them as arguments and storing them;and finally, streaming download and compilation of WebAssemblythat shortens overall execution time.These are the highlights of our new WebAssembly features.We hope they will help your development.Now, let's move from powerful low-level codeto some high-level APIs.In this section,we are going to explore the new web APIs.My goal is to not only let you knowabout the new featuresbut also make you feel you are ready to use them,so you will see some good examples.But this will not be a complete tutorial,so remember to check official documentation before use.This is a preview of features I will talk about.Some of them are completely newlike Speech Recognitionand some of them are already there,but we have some updates we’d like to share,like Storage Access.Now, let’s dig into each of them.We know to make the web content attractive,it’s very important to provide amazing visual experience.With WebGL2 being available in WebKit and Safari,it’s easier for you to createbeautiful, interactive web content.Here is a good example of what can be donewith WebGL2.After the Flood is an interactive demodeveloped by PlayCanvas.You can see the gentle wind sways the tree.It looks vivid in Safari.So what is WebGL2?WebGL is a very widely used low-level APIfor rendering 2D and 3D graphics.WebGL2 is an upgrade of WebGLthat eliminates fallbacksand introduces some cool new features.It adds 3D textures to allow rendering volumetric effectslike cloud.It has sampler objects that give you more flexibilityabout how to use textures in shaders.It provides transform feedback that helps you implementperformance particle systems on the GPU.There are so many great new features in WebGL2.And more importantly,WebGL2 is now available in Safari on all Apple devices.That means you can build a beautiful sitethat looks great everywhere.And let’s get more familiar with WebGL2 with an example:creating an orange square.And this is the JavaScript code you need to write for it.If you have not used WebGL before,this may not be as easy as you would have imagined.As I mentioned, because WebGL is a low-level API,it can be very verbose.But don’t worry; there are many great libraries and frameworksthat can help simplify your development.With them, it’s not that hard to create a nice squareor something more complicated than that.Now, if you already use WebGL in you web content,there is also a good news.We have improved our supportby migrating backend from OpenGL to Metal.That means iOS Simulator is now able to use the GPUfor web content,making it a much more accurate representationof what your users will see.Also, you can use Metal tools,such as the Xcode Frame Debugger,to analyze your WebGL code now.Besides creating content with WebGL,another common way to provide great visual experienceis through video.Not all browsers have the same kind of supportfor media formats,so sometimes it might be tricky for you to decidewhich format you are going to use.To make things easier for you, this year,we have increased our support for WebM,a common media format on the web.For a start, the support is only for streaming playback.In macOS 11.3, we added support for playing WebM filescontaining VP8 or VP9 video and Vorbis audio.And in macOS 12,we add support for files containing Opus audio.Last year, we started supporting WebM played throughMedia Source Extensions on macOS.Now, we’re bringing that support to iPadOS 15.To check if WebM is supported in your code,you can use MediaCapabilities API,which lets you detect the exact media configurationyou want to use.The configuration on the screenis supported in the latest Safari,and that means VP9 is also supported now.With support for this video-coding format,we expect more web content to be availablein Safari and WebKit apps.You can use VP9 in both streaming and WebRTC.It works on macOS and iPadOS.Regarding support on different devices,it is available on all Apple silicon Macs.For the others, you can check with MediaCapabilities API,just like what we just saw for WebM.Now, if your site has WebM or VP9 content,I encourage you to check how it worksin the latest Safari and WebKit;but if you are still deciding which media format to use,we would recommend H.264 or HEVC.H.264 is mature and well-supportedacross browsers.HEVC has great support for high-quality videos.They both come with hardware acceleration that can providesmoother playback and longer playback battery life.Talking about hosting video content,a common case is that we don’t own the content;instead, we get it from a third party.For example, I see this nice video on video.domain.To make it appear on my site, main.domain,I can load this video source from video.domain,or I just create iframes of video.domain.For security reasons, third-party iframes or resourcesdo not have access to first-party storage by default.And that means if the resource requestfor video.domain is initiated from main.domain,it will not include the cookies of video.domain.This can be a problem when web servers of video.domainonly want to serve content to authenticated users.And no cookies means no authentication.The Storage Access API solves this issue.It enables third-party iframes to request permissionto access first-party cookies.If user grants the permission, the third-party video.domainwill be able to access its first-party cookies.The Storage Access API has been available in WebKit and Safarifor over three years.To improve interoperability,this year we have added two new features.First, access is granted on a per-page scope.It means once permission is granted for a third party,it is extended to all its subresourceson the same page.You don't have to make a request for each iframe.Second, we allow nested iframes to make requests.This means iframes inside of iframescan also request access to first-party cookies,which was not possible before.To learn more about the new usage,please check our blog post“Updates to the Storage Access API” at webkit.org.Now we know how to load or import video contentfrom a third party with user permission if needed.How about creating something on your own?With the new Media Recorder API, it’s very easy to do that.Media Recorder API enables you to capture datafrom media elements, which includesHTML media elements like video tagor MediaStream objects.You can use it to record from user’s input devices.You can specify desired options,such as the container's MIME typeor desired bit rates of tracks.The API is simple.It is comprised of a single major interface,MediaRecorder, which does all the workof collecting the data from source and delivering it to you.Let me show you an example.I used MediaRecorder API to build this web appcalled "Voice Memo."This is my first voice memo.Click the button, it starts recording from microphone.Click again, it stops recording and offers playback.This is my first voice memo.That is fun.And now let’s check the implementation.We have two major functions:startRecording and stopRecording.In startRecording,we get the input media stream for microphone.Then we create a MediaRecorder object with that.We listen to two events of the media recorder.And then we can start the recorder with start method.To stop recording, we just need to call stop methodon mediaRecorder object.Here are the two event handlers.When some captured data is available,we store it in an array.When the recording is stopped,we make a blob with collected data in an array,and send it to an existing audio element for playback.Just like that, you can create a functional voice recorder.After you collect the audio data,you may want to edit it.In this case, you can put the new Audio Worklet APIto good use.The Audio Worklet interface is part of Web Audio API,which you may already be familiar withif you have done audio processing on the web before.It allows us to run scriptssuch as JavaScript or WebAssembly codeto process audio on the audio-rendering threadsupporting custom AudioNodes.Compared with ScriptProcessorNodethe previous solution to run custom scriptit reduces the hopping between rendering threadand main thread and ensures low latency.With Audio Worklet,I added a new capability to my Voice Memo.This is my distorted voice.If Distortion box is checked for recording,some distortion effect will be applied to the audio.This is my distorted voiceThat sounds cool,and let’s take a look at how it is implemented.I modified the startRecording functionto add audio processing.We still need to get the MediaStreamfor audio input first.To use Audio Worklet API, there are four basic steps.Step one: create a source.Step two: create an AudioWorkletNodeand bind it with an Audio Worklet processorwhich performs audio processing.The processor is implemented in a module,and we will look at it later.Step three: create a destination.Step four: connect the path from source to destination.This time, MediaRecorder takes the outputfrom AudioWorklet as sourceand it records the distorted audio.This is the audio-processing module.We implement the DistortionProcessor class here.It must extend the AudioWorkletProcessor classand must provide the implementationfor process function.The inputs are the audio samples coming into Audio Worklet,and outputs are the resulting samples after processing.You can use different algorithms to create output.Here, I use a custom function called distort()to calculate a value based on input.Process function returns true,meaning the processor node is active.That’s the basic structure of the process function.After creating the processor class,we need to globally register it under a specified name,so it can be used to construct AudioWorkletNode.Just like that, you can apply sound effectsto your audio data.So far we have discussedabout producing and processing audio data.How about storing it or sharing it to somewhere elsefor your record?I guess you don’t want to lose the recordingafter you quit the browser.With updates to Web Share API this year,it’s quite easy to do that.Web Share is not new in WebKit and Safari.If you choose to share a link on a web page in Safari,a share sheet will show up with sharing targetslike Messages, Mail, or AirDrop.The share sheet that matches well with the system styleis created with Web Share API.This year, we have added support for file sharing.It means you can share image, video, audio,or other types of file with this API now.Let’s add the sharing capability to Voice Memo.If the Save box is checked,Voice Memo will create an audio file with captured dataand display a Share button to let us share the file.Here, I want to share the memo file by email.With just one click, a nice draft is createdwith the memo file attached.And let’s check the code.This is the stop event handler we sawin the MediaRecorder example.First, let’s make the blob variablein stop event handler global,so it can be used by the share function.The share function is the click event handlerof the share button.It converts a blob to a file and gives it a file name.The file is put in an arraybecause that’s the expected input type.Then we check if the API is availableand if the file can be shared with canShare method.If check is passed,we call navigator.share with the file array.There are options you can specify,like title and description text.It’s as easy as that to make your web app to share fileslike a native app does.Well, if you don’t actually want to interact with audio data,but just want the text of itfor example, in the case of voice commandthere is also a new API for you.That’s Speech Recognition.Like its name suggested, Speech Recognition APIcaptures live audio and transcribes it to text.It also gives you probabilities and alternatives of transcript.It uses the same speech engine as Siri,and it gets all the benefits:multiple languages support and great accuracy.That also means your user will need to turn on Sirior Dictation in System Preferences or Settingsto make the API available.Recognition can be server based,so we put up a privacy prompt when recognition serviceis used for the first time in the app.Users can change the permissionin System Preferences or Settings.Now, let’s update Voice Memo with this new capability.If the Recognition box is checked,it means generating a transcript for the recording.This is my Voice Memo transcript.Period.And let’s check the code.The usage is a bit like media recorder.Here we have two major functions:startRecognition and stopRecognition.You need to createa webkitSpeechRecognition object first.Yes, we still keep the WebKit prefix for nowfor compatibility, so don’t forget to add it.Then you can set some properties of the recognition,like continuous, which asks recognition to keep goinguntil it is stopped.We listen to result and end events.With recognition object,we can call start method to startand call stop method to stop.On result event, we collect finalTranscript to a string.Here, I only pick the first item of the resultsbecause the transcription alternatives are sortedbased on probabilities.When recognition stops, I use a custom log functionto print the transcript to the screen.Like that, you can add recognition capabilityto your web content within just a few lines.It’s been a long journey,and there’s one last web API I think worth mentioning.You may have noticed that on macOS and iOS,the Now Playing widget can show you media states in Safari.It’s convenient,but it usually does not contain much information.For example, this only shows the title of web page;no information about what audio is being played.There is a new web API that can help you improve this situation:the Media Session API.Media Session API lets you communicate media statesbetween web page and other platform components.If you want your user to view or control media statesoutside of the web page, like in the Now Playing widget,this is the API you need to know.For more details about Media Session API,please check our WWDC session"Coordinate media playback on the web with GroupActivities."And these are the new features we have just explored.I hope you feel you have learned something of it.And your homework todayis to implement your own Voice Memowith these new APIs.I'm just kidding,but we do have a few things we hope you can doto help us bring you the best development experiencein WebKit and Safari.Please try out the new features in the latest WebKit and Safariand file bug reports at bugs.webkit.org.You can take a sneak peek of new featuresor features under active developmentwith Safari Technology Preview.If you are interested in web technologiesthat are used in WebKit or Safari,or interested in joining the WebKit community,webkit.org is a good source.If you want to get fresh updates about WebKit,or if you have any question for us,don’t forget to follow us or tag us on Twitter.Thanks for watching this session,and I hope you have a great time at WWDC!♪

♪ Bass music playing ♪♪Sihui Liu: Hello. Welcome to “Develop advanced web content.”I'm Sihui, and I am an engineer on the Safari and WebKit team.I am happy to share with you the important updateswe have made in WebKit and Safarifor web developers in the past year.The things I'm about to sharegenerally fall into three categories.First, I will walk you through new features and enhancementsin JavaScript.Then I will give you an overview of the updates in WebAssembly.And finally, I will introduce you to some new web APIsthat can add additional capabilitiesto your web content.There is a lot to cover,so let’s begin with our news in JavaScript.Each year, there are hundreds of changes madein our JavaScript engine.I will cover some of the most important onesyou need know if you work with JavaScript.They are: new class field syntax,weak references that enables smarter memory management,new usage of the await keyword,support for modules in workers,and interfaces added to Internationalization API family.To put you in the picture of these new features,I'm going to use a simple stopwatch as example.The stopwatch has only one button.Click it once, it begins counting.Click it again, it will stopand give you the duration passed.Keep this in mindand we will implement it later in JavaScript.Now, let’s take a look at the new class field syntax.We have new private class fields and methodsthat let you define real private memberswhose access is protected by the language.You will see an error if you break the access rules.We also add support for static fields,which allows you to declare a class memberthat can be accessedwithout creating an instance of the class.Now you have the basic idea.Let’s check how it can be used with the stopwatch example.If you are asked to implement the stopwatch class,your implementation may look like this.StopwatchWithOneButton has only one methodnamed click().It checks startTime variable.If start time is unset, the click means to start,so it will set the start time.If start time is already set, the click means to stop,so it will calculate a duration and reset the start time.You can see startTime comes with an underscore prefix.This is a naming convention commonly used to denotethat the variable should only be used inside of the class.But that does not actually prevent the start timefrom being accessed publicly.The new private syntax can help fix this.Just replace the underscore with hash,and you can declare a real private instance field.The encapsulation is enforced by the language.There is also support for private methods.For example, to make click() methods more structured,we can create two private methodsstart() and stop()to replace the highlighted content, like this.By adding the hash prefix to methods,we make sure the member functions can only be accessedfrom inside of the class.The new private syntax also applies to static fieldslike startedStopwatchCount.Here, startedStopwatchCount can only be modifiedby stopwatch objects at start or stop times.Of course, if you want startedStopwatchCountto be accessed everywhere,you can declare it as public static field,without the hash prefix.Public static field is also available in WebKit now.Private instance fields, methods,private static fields, and public static fields;that’s our new class field support.And let’s continue to another feature,weak references.Weak references allow you to hold referenceto a JavaScript object in a waythat does not prevent garbage collection.Unlike WeakMap and WeakSet,you can get the underlying objectwithout already having a reference to it.The support also includesnotification on garbage collection,so you may perform some cleanup task if you need to.And let’s see how it can be used.We just implemented the stopwatch class.Now imagine you have created multiple stopwatch objectsfor different tasks.For testing, you need to click all of them at a time.How would you do that?An intuitive way is to keepa set of all stopwatch instances.When the stopwatch is created, add it to the set.Then in clickAllStopwatches function,iterate the set and click each stopwatch.But there is an issue with this approach.We know JavaScript objectshold strong reference by default, so in this caseall stopwatch objects cannot be garbage collectedbecause the set still has reference to them.Of course, we don’t want to keep all stopwatch objects aroundjust for testing.This is not great for memory use.Now, you may suggest just replacing Set with WeakSet,but WeakSet is not iterable.So what would you do?We can solve it with the new interface WeakRef,which holds weak references to an object.We still have the set,but this time we add WeakRef of stopwatch objects to the set.In clickAllStopwatches function,we check if the object still existsby dereferencing it before clicking.This seems to solve our issue, but there is another problem:we don’t remove garbage-collected stopwatchesfrom the set in a timely manner,and the set can grow quite large before our next click test.Now what should we do?Another new interface -- FinalizationRegistry --may help in this case.With it, you can specify a callback to be invokedat when some object is garbage collected.Here we create a finalizationRegistry objectwith removeStopwatch function, so this function is calledevery time an object is collected.Then, we register stopwatch objects to the registry.Each stopwatch is bound with an identifier,so removeStopwatch knows which stopwatch to remove.Good, now garbage-collected stopwatches will be removedfrom allStopwatches.The usage of weak references sounds not that hard, right?But be aware that garbage collection in JavaScriptis very complicated,and there is a lot of uncertainty.For example,the object you think should be collectedmay not actually be collected until a long time after,and you may not get the callback from FinalizationRegistryright way because it runs on event loop.Therefore, make sure you fully understand the syntaxand its expected behavior before use.Let’s move on from weak referencesto the next feature, top-level await.This is a new feature for modules.It enables you to use the await keywordoutside of the async function.In this case, the module itself is like a big async function,so an async module can blockthe execution of the module importing them.Let me show you an example with our stopwatch class.This is the class we just created.To illustrate a use of top-level await,let’s make it a module and export the class.This is an HTML file that contains an inline module.It imports the stopwatch module using dynamic import.The import function returns a promise,so we can use then or catch methods to perform actionsafter import is done.With top-level await,you can remove the chaining methodsand write the code in a synchronous way.This can make your code easier to follow.Also, because imported modules are evaluated at load time,so an async module can block execution of modulesdepending on it.That means if stopwatch module runs async operationsand waits for result,the stopwatch variable here will be initializedafter stopwatch module finishes execution.Top-level await has made it easierto do dependency management.But again, this feature is only available in modules,so if the script is not a module, like this...

...you will see a syntax error in Web Inspector.Speaking of modules, there’s another related feature:module workers.Workers has some well-known benefits.It can run scripts in a background thread,so resources can be utilized more efficiently.With this new support,workers now share the benefits of modules,including dynamic import, optimized loading and execution,and dependency management.It is more beneficial and easier for you to move heavy workfrom main thread to background thread now.Modules is now available in different types of workers,including web worker, service worker, and worklet.To create a module worker,for web workers and service worker,you need to specify type to be module in the options.For a worklet like Audio Worklet,you can use addModule function.It’s quite easy to create a module workerthat helps speed up your application.Last in JavaScript sectionis updates on the Internationalization API.This API provides language-based formatting.It is useful if your web content is built for usersin different locales.To show you how it can be used,I built this stopwatch records page because, you know,stopwatch needs to keep up with timesand our feature releases.This page shows us details about a single use of stopwatch,including duration, start time, event, participants,and the available languages of the page.Now, let’s dive into each sectionand take a closer look of each interface.First is NumberFormat.NumberFormat provideslanguage-sensitive number formatting,and it is used to format the duration.Constructor of NumberFormat takes two optional parameters:language and options.Here I set the language to Englishand I make two options object,which specify different minimum numbers of digits.After creating two NumberFormat objectswith language and options,we can use them to format the duration numbers.Here, if number is not milliseconds,I use Format1 to keep two digits;otherwise I use Format2 to keep three digits.As you can see, the format methodautomatically adds padding zeroes for us.There are many different options you can utilizeto create formats you need, such as style,where you can specify value to be currency or unit.Next is DateTimeFormat,which enables language-sensitive date and time formatting.The usage is similar to NumberFormat.First, set the language.Then, set the options.In the options, I set different stylesfor date and time.The DateTimeFormat objectprovides a fine-grained configurationthat even allows you to specify style for second or millisecond.After that, we can create a DateTimeFormat objectwith parameters,and use it to format our start time.The result is represented in English.You can see date is more detailedbecause it has the long style.Next one is Segmenter.It enables you to dolanguage-sensitive string splitting.I used it to find keywords in the event sentence.This is the Chinese version of the stopwatch records page.First, I declare a short list of keywords I want to highlight.The event string even includes a Unicodefor the Celsius degree symbol.Here we specify Chinese as language.In options, the granularity is set to be a word.The other possible values are grapheme and sentence.Then we create a Segmenterand use it to split the string with segment method.We can iterate the result objects to get all segments.Check and see if each segmentis contained in the keyword list to mark it.Segmenter is quite useful for interpreting languages,like Chinese, where the word boundary is not that obvious.The next is ListFormat,which enables language-sensitive list formatting.The same as before,we can specify language and options.ListFormat does not have as many optionsas the other interfaces.The most useful ones I found are type and style.With language and options, we can create a ListFormatand format the participants list we have.As you can see,because the type is conjunction and the style is long,the format method adds a comma and a word “and” in the result.The last one is DisplayNames.It provides consistent translation of display namesfor language, region, and script.Here I specify language to be Japanese.DisplayNames can take language code as input.In the options, we set type as language.Then we can create DisplayNames object.And here, using of method,we can get the translated result.Even though this page is built in English,Japanese users can know what languages are supported.And this is how I built the stopwatch records pagewith new internationalization interfaces.To refresh your memory, here is the list of thingswe’ve just looked at in the JavaScript section.Following that, our next stop is updates in WebAssembly.We’ve been shipping our WebAssembly enginefor a while, but in case you’re not familiar with it,let me begin by filling in with some backgroundof WebAssembly.WebAssembly is a binary instruction formatfor a stack-based virtual machine.It is a type of a code that can be run in modern web browserswith performance close to native code.WebAssembly is designed to be a portable compilation targetfor programming languages like C, C++, or Rust,so WebAssembly can help us deploy applicationswritten in those languages on the web.In most use cases of WebAssembly,it runs alongside with JavaScript.They can communicate with each otherthrough the WebAssembly API.WebAssembly can provide near-native performance,and makes powerful frameworks available on the web.JavaScript can manipulate the DOMand offers powerful web APIs.They can be good additions to each other.A good example of WebAssembly use is Funky Karts.It is a game converted from C++ to WebAssembly with Emscripten.As you can see, it gets to run very smoothly in Safari.This year, we’ve upgraded our WebAssembly enginewith following features: new memory instructionsthat give you better performance on bulk memory operations,like copying or initializing blocks of memory;new instructions to tell user processnot to trap on exception, like positive overflowwhen converting between float and int;new sign-extension operatorsthat let you extend a signed integer;implementation of the latest proposal to convertbetween WebAssembly type i64 and JavaScript BigInt,which is simpler than previous solutionsand can make your code run faster;new reference types that allows WebAssembly modulesto hold references to JavaScript and DOM objects,passing them as arguments and storing them;and finally, streaming download and compilation of WebAssemblythat shortens overall execution time.These are the highlights of our new WebAssembly features.We hope they will help your development.Now, let's move from powerful low-level codeto some high-level APIs.In this section,we are going to explore the new web APIs.My goal is to not only let you knowabout the new featuresbut also make you feel you are ready to use them,so you will see some good examples.But this will not be a complete tutorial,so remember to check official documentation before use.This is a preview of features I will talk about.Some of them are completely newlike Speech Recognitionand some of them are already there,but we have some updates we’d like to share,like Storage Access.Now, let’s dig into each of them.We know to make the web content attractive,it’s very important to provide amazing visual experience.With WebGL2 being available in WebKit and Safari,it’s easier for you to createbeautiful, interactive web content.Here is a good example of what can be donewith WebGL2.After the Flood is an interactive demodeveloped by PlayCanvas.You can see the gentle wind sways the tree.It looks vivid in Safari.So what is WebGL2?WebGL is a very widely used low-level APIfor rendering 2D and 3D graphics.WebGL2 is an upgrade of WebGLthat eliminates fallbacksand introduces some cool new features.It adds 3D textures to allow rendering volumetric effectslike cloud.It has sampler objects that give you more flexibilityabout how to use textures in shaders.It provides transform feedback that helps you implementperformance particle systems on the GPU.There are so many great new features in WebGL2.And more importantly,WebGL2 is now available in Safari on all Apple devices.That means you can build a beautiful sitethat looks great everywhere.And let’s get more familiar with WebGL2 with an example:creating an orange square.And this is the JavaScript code you need to write for it.If you have not used WebGL before,this may not be as easy as you would have imagined.As I mentioned, because WebGL is a low-level API,it can be very verbose.But don’t worry; there are many great libraries and frameworksthat can help simplify your development.With them, it’s not that hard to create a nice squareor something more complicated than that.Now, if you already use WebGL in you web content,there is also a good news.We have improved our supportby migrating backend from OpenGL to Metal.That means iOS Simulator is now able to use the GPUfor web content,making it a much more accurate representationof what your users will see.Also, you can use Metal tools,such as the Xcode Frame Debugger,to analyze your WebGL code now.Besides creating content with WebGL,another common way to provide great visual experienceis through video.Not all browsers have the same kind of supportfor media formats,so sometimes it might be tricky for you to decidewhich format you are going to use.To make things easier for you, this year,we have increased our support for WebM,a common media format on the web.For a start, the support is only for streaming playback.In macOS 11.3, we added support for playing WebM filescontaining VP8 or VP9 video and Vorbis audio.And in macOS 12,we add support for files containing Opus audio.Last year, we started supporting WebM played throughMedia Source Extensions on macOS.Now, we’re bringing that support to iPadOS 15.To check if WebM is supported in your code,you can use MediaCapabilities API,which lets you detect the exact media configurationyou want to use.The configuration on the screenis supported in the latest Safari,and that means VP9 is also supported now.With support for this video-coding format,we expect more web content to be availablein Safari and WebKit apps.You can use VP9 in both streaming and WebRTC.It works on macOS and iPadOS.Regarding support on different devices,it is available on all Apple silicon Macs.For the others, you can check with MediaCapabilities API,just like what we just saw for WebM.Now, if your site has WebM or VP9 content,I encourage you to check how it worksin the latest Safari and WebKit;but if you are still deciding which media format to use,we would recommend H.264 or HEVC.H.264 is mature and well-supportedacross browsers.HEVC has great support for high-quality videos.They both come with hardware acceleration that can providesmoother playback and longer playback battery life.Talking about hosting video content,a common case is that we don’t own the content;instead, we get it from a third party.For example, I see this nice video on video.domain.To make it appear on my site, main.domain,I can load this video source from video.domain,or I just create iframes of video.domain.For security reasons, third-party iframes or resourcesdo not have access to first-party storage by default.And that means if the resource requestfor video.domain is initiated from main.domain,it will not include the cookies of video.domain.This can be a problem when web servers of video.domainonly want to serve content to authenticated users.And no cookies means no authentication.The Storage Access API solves this issue.It enables third-party iframes to request permissionto access first-party cookies.If user grants the permission, the third-party video.domainwill be able to access its first-party cookies.The Storage Access API has been available in WebKit and Safarifor over three years.To improve interoperability,this year we have added two new features.First, access is granted on a per-page scope.It means once permission is granted for a third party,it is extended to all its subresourceson the same page.You don't have to make a request for each iframe.Second, we allow nested iframes to make requests.This means iframes inside of iframescan also request access to first-party cookies,which was not possible before.To learn more about the new usage,please check our blog post“Updates to the Storage Access API” at webkit.org.Now we know how to load or import video contentfrom a third party with user permission if needed.How about creating something on your own?With the new Media Recorder API, it’s very easy to do that.Media Recorder API enables you to capture datafrom media elements, which includesHTML media elements like video tagor MediaStream objects.You can use it to record from user’s input devices.You can specify desired options,such as the container's MIME typeor desired bit rates of tracks.The API is simple.It is comprised of a single major interface,MediaRecorder, which does all the workof collecting the data from source and delivering it to you.Let me show you an example.I used MediaRecorder API to build this web appcalled "Voice Memo."This is my first voice memo.Click the button, it starts recording from microphone.Click again, it stops recording and offers playback.This is my first voice memo.That is fun.And now let’s check the implementation.We have two major functions:startRecording and stopRecording.In startRecording,we get the input media stream for microphone.Then we create a MediaRecorder object with that.We listen to two events of the media recorder.And then we can start the recorder with start method.To stop recording, we just need to call stop methodon mediaRecorder object.Here are the two event handlers.When some captured data is available,we store it in an array.When the recording is stopped,we make a blob with collected data in an array,and send it to an existing audio element for playback.Just like that, you can create a functional voice recorder.After you collect the audio data,you may want to edit it.In this case, you can put the new Audio Worklet APIto good use.The Audio Worklet interface is part of Web Audio API,which you may already be familiar withif you have done audio processing on the web before.It allows us to run scriptssuch as JavaScript or WebAssembly codeto process audio on the audio-rendering threadsupporting custom AudioNodes.Compared with ScriptProcessorNodethe previous solution to run custom scriptit reduces the hopping between rendering threadand main thread and ensures low latency.With Audio Worklet,I added a new capability to my Voice Memo.This is my distorted voice.If Distortion box is checked for recording,some distortion effect will be applied to the audio.This is my distorted voiceThat sounds cool,and let’s take a look at how it is implemented.I modified the startRecording functionto add audio processing.We still need to get the MediaStreamfor audio input first.To use Audio Worklet API, there are four basic steps.Step one: create a source.Step two: create an AudioWorkletNodeand bind it with an Audio Worklet processorwhich performs audio processing.The processor is implemented in a module,and we will look at it later.Step three: create a destination.Step four: connect the path from source to destination.This time, MediaRecorder takes the outputfrom AudioWorklet as sourceand it records the distorted audio.This is the audio-processing module.We implement the DistortionProcessor class here.It must extend the AudioWorkletProcessor classand must provide the implementationfor process function.The inputs are the audio samples coming into Audio Worklet,and outputs are the resulting samples after processing.You can use different algorithms to create output.Here, I use a custom function called distort()to calculate a value based on input.Process function returns true,meaning the processor node is active.That’s the basic structure of the process function.After creating the processor class,we need to globally register it under a specified name,so it can be used to construct AudioWorkletNode.Just like that, you can apply sound effectsto your audio data.So far we have discussedabout producing and processing audio data.How about storing it or sharing it to somewhere elsefor your record?I guess you don’t want to lose the recordingafter you quit the browser.With updates to Web Share API this year,it’s quite easy to do that.Web Share is not new in WebKit and Safari.If you choose to share a link on a web page in Safari,a share sheet will show up with sharing targetslike Messages, Mail, or AirDrop.The share sheet that matches well with the system styleis created with Web Share API.This year, we have added support for file sharing.It means you can share image, video, audio,or other types of file with this API now.Let’s add the sharing capability to Voice Memo.If the Save box is checked,Voice Memo will create an audio file with captured dataand display a Share button to let us share the file.Here, I want to share the memo file by email.With just one click, a nice draft is createdwith the memo file attached.And let’s check the code.This is the stop event handler we sawin the MediaRecorder example.First, let’s make the blob variablein stop event handler global,so it can be used by the share function.The share function is the click event handlerof the share button.It converts a blob to a file and gives it a file name.The file is put in an arraybecause that’s the expected input type.Then we check if the API is availableand if the file can be shared with canShare method.If check is passed,we call navigator.share with the file array.There are options you can specify,like title and description text.It’s as easy as that to make your web app to share fileslike a native app does.Well, if you don’t actually want to interact with audio data,but just want the text of itfor example, in the case of voice commandthere is also a new API for you.That’s Speech Recognition.Like its name suggested, Speech Recognition APIcaptures live audio and transcribes it to text.It also gives you probabilities and alternatives of transcript.It uses the same speech engine as Siri,and it gets all the benefits:multiple languages support and great accuracy.That also means your user will need to turn on Sirior Dictation in System Preferences or Settingsto make the API available.Recognition can be server based,so we put up a privacy prompt when recognition serviceis used for the first time in the app.Users can change the permissionin System Preferences or Settings.Now, let’s update Voice Memo with this new capability.If the Recognition box is checked,it means generating a transcript for the recording.This is my Voice Memo transcript.Period.And let’s check the code.The usage is a bit like media recorder.Here we have two major functions:startRecognition and stopRecognition.You need to createa webkitSpeechRecognition object first.Yes, we still keep the WebKit prefix for nowfor compatibility, so don’t forget to add it.Then you can set some properties of the recognition,like continuous, which asks recognition to keep goinguntil it is stopped.We listen to result and end events.With recognition object,we can call start method to startand call stop method to stop.On result event, we collect finalTranscript to a string.Here, I only pick the first item of the resultsbecause the transcription alternatives are sortedbased on probabilities.When recognition stops, I use a custom log functionto print the transcript to the screen.Like that, you can add recognition capabilityto your web content within just a few lines.It’s been a long journey,and there’s one last web API I think worth mentioning.You may have noticed that on macOS and iOS,the Now Playing widget can show you media states in Safari.It’s convenient,but it usually does not contain much information.For example, this only shows the title of web page;no information about what audio is being played.There is a new web API that can help you improve this situation:the Media Session API.Media Session API lets you communicate media statesbetween web page and other platform components.If you want your user to view or control media statesoutside of the web page, like in the Now Playing widget,this is the API you need to know.For more details about Media Session API,please check our WWDC session"Coordinate media playback on the web with GroupActivities."And these are the new features we have just explored.I hope you feel you have learned something of it.And your homework todayis to implement your own Voice Memowith these new APIs.I'm just kidding,but we do have a few things we hope you can doto help us bring you the best development experiencein WebKit and Safari.Please try out the new features in the latest WebKit and Safariand file bug reports at bugs.webkit.org.You can take a sneak peek of new featuresor features under active developmentwith Safari Technology Preview.If you are interested in web technologiesthat are used in WebKit or Safari,or interested in joining the WebKit community,webkit.org is a good source.If you want to get fresh updates about WebKit,or if you have any question for us,don’t forget to follow us or tag us on Twitter.Thanks for watching this session,and I hope you have a great time at WWDC!♪

## Code Samples


# Wwdc2021 10194

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Swift concurrency: Update a sample appDiscover Swift concurrency in action: Follow along as we update an existing sample app. Get real-world experience with async/await, actors, and continuations. We'll also explore techniques for migrating existing code to Swift concurrency over time.

To get the most out of this code-along, we recommend first watching “Meet async/await in Swift” and “Protect mutable state with Swift actors” from WWDC21.

Note: To create an async task in Xcode 13 beta 3 and later, use the Task initializer instead.ResourcesThe Swift Programming Language: ConcurrencyUpdating an App to Use Swift ConcurrencyHD VideoSD VideoRelated VideosWWDC22Create a more responsive media appEliminate data races using Swift ConcurrencyVisualize and optimize Swift concurrencyWWDC21Explore structured concurrency in SwiftMeet async/await in SwiftProtect mutable state with Swift actorsSwift concurrency: Behind the scenesWhat's new in SwiftUIWWDC20Build complications in SwiftUI

Discover Swift concurrency in action: Follow along as we update an existing sample app. Get real-world experience with async/await, actors, and continuations. We'll also explore techniques for migrating existing code to Swift concurrency over time.

To get the most out of this code-along, we recommend first watching “Meet async/await in Swift” and “Protect mutable state with Swift actors” from WWDC21.

Note: To create an async task in Xcode 13 beta 3 and later, use the Task initializer instead.

The Swift Programming Language: Concurrency

Updating an App to Use Swift Concurrency

HD VideoSD Video

HD Video

SD Video

Create a more responsive media app

Eliminate data races using Swift Concurrency

Visualize and optimize Swift concurrency

Explore structured concurrency in Swift

Meet async/await in Swift

Protect mutable state with Swift actors

Swift concurrency: Behind the scenes

What's new in SwiftUI

Build complications in SwiftUI

Search this video…♪ Bass music playing ♪♪Ben Cohen: Hi, I'm Ben from the Swift team,and in this video,I'm going to walk through porting an existing applicationover to use Swift's new concurrency features.We'll see how these new featureshelp you write clearer asynchronous code,and protect against possible race conditions,as well as look at some techniquesfor gradually moving your code to this new way of operating.I'm going to be using an app called Coffee Tracker,and it's based on a talk from WWDC 2020about creating and updating watch complications.This is a simple app that lets you trackall the coffee you've drunk today,as well as a complication to show your current caffeine levelon a watch face.It's a nice example to use for our purposesbecause although it's a small app,it shows lots of different things we want to think about,including how concurrency works with SwiftUI,delegate callbacks from the watch SDK, some I/O,and interfacing with asynchronous APIsin Apple's SDK.Now let's take a quick tour of the app.It's roughly broken up into three layers.First, there's the UI layer.This is mostly SwiftUI views,but in this we can also consider thingslike the complication data source as part of the UI layer.Next there's the model layerthat comprises a couple of simple value typesto represent caffeine drinks,as well as a model type called "Coffee model."Now, this is what you might call the UI Model.That is, the place where you hold data for displayby the UI layer.It's an observable object that feeds our SwiftUI view,and all of the updates on itwill need to be made on the main thread.I'm referring to it as a UI modelbecause it might not be the full modelof all of your application's data.It might just be a projection of your data modelor a subset of it;just what you need to display on the UI at this moment.Finally, we have what you can think of as the back-end layer:processing that happens -- probably in the background --to populate your model or talk to the world outside your app.In our case, that's represented by this HealthKitController typethat manages communication to HealthKitto save and load the user's caffeine intake.Now, before we start looking at code,let's talk about how concurrency is managed in the app.This architecture looks fairly clean,but when we layer on how concurrency is handled,we get a much messier picture.This app is essentially broken up into three concurrent queueson which code can be executing.Work in the UI and on the model is done in the main queue.The app also has a dispatch queuefor doing work in the background.And finally, certain callbacks into completion handlers --like those returning results from HealthKit --are done on arbitrary queues.This is a pretty common situation.What seems like a simple application architectureignores a lot of the hidden complexityin how it handles concurrency.Now, for a quick spoiler.In adopting Swift concurrency,we're going to go from this ad hoc concurrency architectureto something that will look like this.We're going to put our UI views and model on what's calledthe main actor.We're going to create new actors to operate in the background,and these types will pass thread-safe valuesbetween each other using the async/await feature.When we're done, the concurrency architectureshould be as clear and easy to describeas the type architecture.Now we've used a few terms here you might not be familiar with,like "async/await" and "actors,"and we'll explain them briefly as we use them in code.But for a more in-depth explanation of these features,there are several other talks availablethat go into much more detail.So now we've seen the overall architecture,let's dive into the code.Here we have the different files.First, of some Swift UI views.And then we have our watch complication controller'sextension delegate.We have the simple model type that represents a caffeine drinkand a CoffeeData UI model that holds an array of these drinks.And finally, we have the HealthKitController.And it's in this layer I'm going to get startedintroducing some of Swift's new concurrency featuresinto our app.The HealthKitController contains a few different callsinto the HealthKit SDK that take completion handlers.Let's start by looking at this controller's save operation.So I just hit Control-6,and that brings up the list of functions in this file,and we're going to go to the save operation.Now, before we even get into the new concurrency features,let's talk a little bit about thread safety in Swift today.This code accesses some variables,isAvailable and store.Now, it looks like we're only reading these variablesin this function.Is that safe?Well no, not if other code could be writing to themat the same time.To know whether or not this code is thread-safe,I need more information than just looking at this function.There's no use of dispatch queues or locks in it,so whatever makes this code thread-safe --assuming it is -- must be elsewhere.Maybe the caller serializes all calls to savethrough a queue.Or maybe the app is constructed in some way that means it's OK.But I can't know this just by looking at this function.Being able to do that --to look at this function and know certain thingswithout having to go look at other parts of my program --is what we call local reasoning,and it's a really important goal for Swift.For example, Swift's emphasis on value typesis about local reasoning.Unlike a reference type,you don't have to worry that a value type you've been passedis being mutated elsewhere in your program.A lot of the language featuresbeing introduced for concurrency in Swift 5.5are about giving you more opportunityto reason locally about your code.Now, as it happens,this function is entirely thread-safe,but I figured that out myself;the compiler isn't helping me spot these issues.So down here, we have a call to the HealthKit SDKto save a caffeineSample into the user's health data.And this takes a completion handler,and that completion handler takes two values:success or error.If the operation succeeds, there's no error;the error will be nil.This means we need to remember to check the status and then,when appropriate, unwrap the optional error down here.Now, this isn't normally how we handle errors in Swift.This would be much betteras a method that can throw on failure.But that approach doesn't work with completion handlers.But now, with async methods,we can have asynchronous functions that can throw.This HealthKit save method now has an async equivalentthat does exactly that,so let's switch over to using it.To do that, first we remove the completion handler,and we write "await" in front of the method call.This reminds us that it's an async function call,and the code will suspend at this pointand allow other code to run.We'll come back to why this is important a little bit later.So if we compile, now that we've done this,we see that the compiler is telling us that we need a "try."And this is a big benefit of async functions;they can throw.There's no more having to rememberto check an optional error.So we can add a "try" in front of this method call,and we want to handle the error right away.So we wrap this call in a do block...and then catch the error.We can remove this guard.And now that we're catching the error,it's no longer optional, so we can remove the unwrap.This also means we can rearrange our codeto keep the happy path at the topso we can move the success logging lineup right underneath the saveand then just handle the error logging in the cache.Notice that save no longer returns a value.Returning success/failure was really duplicativewith the error,so our new function only either throwsor it's succeeded.Now that we've added the try-catch,we're getting one more error from the compiler.We're calling an asynchronous function,but we're calling it from within a synchronous function.This does not work.Asynchronous functions have a capabilitythat synchronous functions don't have:the ability to give up control of the thread they're running onwhile they await.To do this,they have a separate way of handling their stack frame,and this isn't compatible with synchronous functions.So one option is to make this function async instead.So we can just add the async keywordafter the function definition.And now, this file compiles.But the whole project doesn't compile yet.Making this function async has pushed the problem up a levelto where it's being called.Here in my data model,I'm now getting that same compiler errorbecause this function isn't async.Now I could keep going up the chain, but for now,let's see another technique to keep the changes localized.To call my async function,I'm going to spin off a new asynchronous taskwhich will be allowed to call async functions.This async task is very similar to calling asyncon the global dispatch queue.You can't return a value back from it to the outer functionbecause the block executes concurrently.So whatever you do with the detached closureneeds to be self-contained.In this case, we're just calling save,which doesn't return a value, so that's fine.You also need to be careful that you're not touchingglobal state that might get mutated simultaneouslyfrom other threads.And this is where it was relevantthat save was completely thread-safe,otherwise we might be accidentally introducingnew race conditions by adding this new task.Now that we've put it inside an async task,our awaited function compiles,and we've finished our first use of async/await in this app,we could run it right now.Let's do another one of those refactorsand this time, look at some other techniqueswhen migrating to async.So let's have a look at the call to request authorizationof access to the user's health data.This similarly calls HealthKit with a completion handler.But unlike before, this function takes, itself,a completion handler.What I'm going to do is I'm going to createa second version of the function to become asyncwhile keeping the completion handler version.That way other parts of our codethat call it with a completion handlercan keep on working while we refactor.I can do this easily by using the "Create Async Alternative"refactoring action.That's available in the Code Action menu --which I can bring up with Command-Shift-A --and choose the option to add the async alternative.So this has added a second async versionof the original call.And it's replaced the original completion handler codewith code that creates a new async task......and then just awaits the async version of the function.Notice that the async refactoringhas added a deprecation warning to the original one.These are going to help guide me to parts of my codethat could next benefit from refactoringto call this new async version.Let's undo and go back for a momentto that original completion handler version.Inside this requestAuthorization callback,this callback can happen on an arbitrary thread.So you need to know that the code inside it is thread-safe.But I don't think it is.This assignment here might happen simultaneouslywith other code reading this value on other threads.And there's another example of a lack of local reasoningin this code.After that assignment, this completion handler is called,and I have no idea whether the codeinside that completion handler is thread-safe.I'd have to go and lookat all of the call sites to this functionto look at how their completion handlers are writtento know that this is OK.Now, let's redo again and see the refactored version.Now remember,an async task also runs on an arbitrary threadsimilar to a dispatch callback.So this forwarding version has similar problemsto the completion handler version we had before.We haven't made our code any safer quite yet.We'll fix this soonby introducing actors into our code.But for now, we should notethat just because we've converted this function to asyncdoes not mean we're free from race conditions.In fact, you should be aware of the risk of introducingnew race conditions into your codeif you only perform refactoring to introduce async functions.Now let's look at this new async function.The refactoring action has already convertedthe call with a completion handler hereto call the new async version of this SDK API.But converting this function to asynchas highlighted something interesting.Here, when we were using the completion handler technique,we had a return without calling the completion handler.And this was probably a bug.The caller would have been left hanging.But with async functions, you must return a value,so now we're getting a compilation error,which we can resolve just by returning false for failure.And just like before,this new async version of requestAuthorizationdoesn't actually return a value,it either succeeds or it throws.So we just need to delete this return value.And instead on this path,we need to assume that it succeeded......and on the failure path, we need to return false.If I try and compile now,the project compiles because the old code elsewherecan still continue to call the completion handler versionand we're now seeing these deprecation warningswhen we're doing that, which can lead usto a next place that we might want to refactor.OK, let's do one more async conversion.Let's find the function to load data from HealthKit.We'll start -- just like before --by creating a stub for the old code to call.Then moving to the async version,incidentally, this one takes an optional completion handlerthe async equivalent of thiswould be to make this function have a discardable result.So next, we start moving down, replacing any useof the completion handler with returns.So for example, we can delete this completion handlerand just return false.But once we move a little further,we start to hit a snag,and it has to do with how the HealthKit query API is arranged.Here, there's a completion handlerbut it's on this query object; whereas really,what I want to await is the execution of the queryall the way down here at the bottom of the function.Incidentally, this hopping up and down around the functionis another thing that async/awaitis great at helping resolve.So what I want to do is create a single async functionthat both creates the query and then executes it.We're going to do that nowusing a technique called a continuation.So I'm to go back up to the top of this functionand I'm going to create a helper functioncalled "queryHealthKit."I could do all of this work inside the existing functionbut it might get a little bit messy,so I like to keep it separate in a helper function.This function will be async, so we can await it,and it will throw because the query operation can fail.And this function is going to return the useful values herethat are currently being passed intothe completion handler on the query.So I'm going to take the logic for performing the query,cut it, and move it into the helper function.And I'm also going to take the execution of the queryand move that too.Now, I need to somehow invert this codeso that it can await the completion handlerand return these values passed into the completion handlerback from my new asynchronous function.And this is where I use a continuation.So in this function, we're going to returnthe results of trying to await a call to awithCheckedThrowingContinuation function.And this takes a block that takes a continuation.And we're going to move this code inside that blockand then within the block, we're going to use the continuationto pass data back out of this function eitherby using the continuationto resume throwing the error here......or......to resume returning the values that we receivedinto the completion handler.Now that we have this awaitable function,we can use it in our original code.So we assign the results from calling the function.And we need to handle the error that can be thrown.In fact, actually, I'm going to go up hereand take this bit of logging and do that in the handler.And then we just need to move all of this success codeup into the happy path.Finally, we need to address this closure.Here, we're using dispatch async back to the main thread.But we've ditched our completion handler,so there's no way of relaying this informationback to the main thread using it.We need a different way.To resolve this, we're going to make our first use of actors.In Swift's concurrency model,there is a global actor called the main actorthat coordinates all of its operations on the main thread.We can replace our dispatch main.async callwith a call to main actor's run function.And this takes a block of code to run on the main actor.run is an async function, so we need to await it.Awaiting it is necessarybecause this function may need to suspenduntil the main thread is ready to process this operation.But because we await it,we can just remove our completion handler,and instead, return a value.OK, finally, the compiler is now giving me an errorabout a captured variable.This is a new error that only occursinside asynchronous functions.Because closures in Swift capture variables by reference,when you capture a mutable variable --in this case, our newDrinks array --you create the possibility for shared mutable state,and that can be the source of race conditions.So when doing this,you need to ensure that you're making a copy of this value.One way to do this is to add newDrinksto the closure's capture list, like this.But often it's better to just avoid this problemby not having mutable variables in the first place.Here, we can do this by changing the code above instead.It's written this way because samples is optional.But instead what we could dois change newDrinks to an immutable valueand either set the value here in the if branchor an add an "else"to set it to the empty array.We could also have done this with a nil coalescing operatorif we prefer.Since this value is now declared with let instead of var,it's immutable and that resolves the issuewithout needing to make an additional capture.Now let's keep talking about the main actorby taking a look at this functionthat needed to be called on the main thread.At the top of this function,there's something that's a really great idea:there's an assert that the functionis correctly running on the main thread.If you had ever made a mistake and called this functionwithout wrapping itin a dispatch async to the main thread,you'd get an error in your debug builds,and you should definitely adopt this practicein some of your existing code.But this approach does have some limitations.You might forget to put an asserteverywhere it's needed,and you can't assert on access to stored properties,or at least not without lots of boilerplate.It's much better if the compiler can enforcesome of these rules for you,so you can't make mistakes like this at all.And that's how we use the main actor.I can annotate functions with "@MainActor."And that will require that the caller switchto the main actor before this function is run.Now that I've done this, I can remove the assertionbecause the compiler won't let this function be called anywhereother than on the main thread.We can prove that this is workingby going back to the callerand moving this call outside of this MainActor.run block.And you see the compiler tells us, no,we can't call that from herebecause we're not on the main actor.Here's a way to think about this feature:it's a lot like optional values.We used to have values like pointersand had to remember check for nil,but it was easy to forget,and it's much better to let the compiler make surethis check always happensalong with some language syntactic sugarto make it easier.Here, we're doing a similar thing,only instead of enforcing nil checks,it's enforcing what actor you're running on.Now that we've put this function on the main actor,we don't, strictly speaking, need this MainActor.run anymore.If you're outside of an actor,you can always run functions on that actor by awaiting them.And in fact, that's what the compiler is telling us here.It's saying that we need an await keywordin order to make the switch over to the main actorto run this function.So if we add it,then the code will compileeven without this call being inside the run block.Here, we're using await on a synchronous function --updateModel is synchronous --but the await indicates that the function we're inmay need to suspend to get itself onto the main actor.Think of this as similar to makinga DispatchQueue.sync call, except with await,your function suspends instead of blockingand then resumes after the call to the main thread is complete.So, we don't need it here anymore,but this MainActor.run techniqueis still important for another reason.At each await,your function might suspend and other code might run.That's the point of awaiting:to let other code run instead of blocking.In this case, we only had one function to await,so it doesn't really matter,but sometimes you might want to run multiple callson the main thread.For example, if you're working on UI updates,such as updating entries in a table view,you might not want the main run loopto turn in between the operations you perform.In that case, you would want to use MainActor.runto group together multiple calls to the main actorto ensure that each ranwithout any possible suspensions in between.So, we're now using the main actorto protect the code that needs to run on the main thread.But what about other code in this class?In particular, the code that mutates local variables,like the query anchor that we saw assigned to here.How can we guarantee those are free from race conditions?Or one way would be to just put everythingin the HealthKitController on the main actor.If I go to the HealthKit controller definition,and just write "@MainActor"here on the class instead of on individual methods,that would protect every method on this type,and every stored property on it would be coordinatedon the main thread.And for a simple application like this one,that would probably be an OK choice.But that also seems a little bit wrong.This HealthKitController is really the back end of our app;it seems unnecessary to be doing all of its workon the main thread.We want to leave that threadfree to do UI-focused activities.So instead, we can change this classto, itself, be an actor.Unlike the main actor, which is a global actor,this actor type can be instantiated multiple times.In my project, I'm still only going to create one of them,but there are many other uses of actorswhere you might instantiatemultiple copies of the same actor.For example, you might make each room in a chat serverbe its own actor.So now that we've made this class into an actor,let's see what the compiler says.OK. So we're getting some compilation errors.Now let's take a pause here and talk about compiler errors.These errors are guiding you towards the places in your codeyou need to update when you're migrating codeto the new concurrency model.When you get these errors,make sure you understand what they're telling you.Resist the temptation to mash the fix-it buttonwhen you're not sure how or why it'll fix the issue.One thing to be wary ofis getting into a cascade of errors.Sometimes you'll make a change --like converting a class to be an actorlike we just did, or making a method async --and it'll generate some compiler errors.So you go to the site of those errors,and it's tempting to make more changes to fix those errors,like making that method async or putting it on the main actor.The trouble is that this can lead to even more errors,and quickly, you can feel overwhelmed.Instead, use techniques like we're using herein this walk-through,and try and keep the change isolatedand done one step at a time with your project compilingand running in between.Add shims to allow your old code to keep working,even though you might end up deleting them later.That way, you can gradually move out from a point,tidying up the code as you go.Incidentally, what I did here is first convertthe HealthKitController's methods to asyncand then make it into an actor.And I find it works out easiest if you do it that way around,rather than starting with the actor conversion.OK, so let's look at these errors by jumping down to them.They're down here on the functionwe put on the main actor.And this makes sense, because in this function,we're touching a stored propertyof our new HealthKitController actor,the model property.The actor protects its state and won't let functions,not on the actor -- such as this functionthat we've explicitly put on the main actor --touch its stored properties.Now looking at this function,it looks like the only state on the actor that it touchesis the model object.Everything else is passed in as a function argument.And to me,this suggests that this function belongs on the model;that the model here actually ought to be self.So let's move it to the model.So we can take this function, cut it,go over to our CoffeeData UI model,and paste it in.It's going to be internal rather than private,so it can be called from the HealthKitController.And we just need to go throughand remove all references to the modelbecause that's now self.Finally, we need to go to where it was being called......and replace self here with a call to the model.So now, this HealthKitController file compiles,and I get a new set of errors from other files.Let's look at those errors.So here we're calling into those completion handler shimsthat we called earlierto allow us to keep passing in the completion handlereven though we've rewritten this function to the async.These functions are now being protected by the actorso I can't call them directly.But they don't touch any other part of the actor's stateif we look at them.All they're doing is spinning off a taskand then awaiting a call to the async version of the function.Since they don't touch any part of the actor's internal state,I can mark them as what's called "nonisolated."Do the same down here.Marking something as nonisolated tells the compilerthat you're not going to touch any of the isolated state,and therefore, this function can be called from anywhere.The switch over to the actor is actually happening automaticallywhen we await the call into the async version of the function.Note that the compiler will checkthat this nonisolated claim is true.If I were to try and access some state of the actor --such as, for example,printing out the authorization status --the compiler will stop me.So now, I've completed my workconverting the HealthKitControllerinto an actor that protects its internal statefrom race conditions.Next, let's follow those deprecation breadcrumbsto the next file to work on,which is our CoffeeData model type.Now this class implements ObservableObject,and it has a Published property.Any updates to properties that are published to a SwiftUI Viewmust be done on the main thread,so this class is probably a good candidateto put on the main actor.But there's also this background DispatchQueuefor doing some work in the background.Let's have a look at how that's used.And it's just in two functions: load and save.That makes sense; you probably don't wantto do your loading and saving on the main thread.When you see a pattern like this --where a queue is being usedto coordinate some specific activities,but the rest of the class needs to be on the main thread --that's a sign that you want to factor that background codeout into a separate actor.So let's do that.So let's go to the top of the file and createa new private actor......which we'll call "CoffeeDataStore."And let's open CoffeeData in another window.and start moving code across into our new actor.So we can give it its own logger.And let's tweak the categoryso we can tell when the actor is in use.And next, instead of this DispatchQueue,we're going to instantiate a copy of our new actor.Next, let's go to the save operation,and move that over.So we can take this function......cut it from here, and move it into the actor.Let's start by compiling and seeing what issues come up.So first, there's this currentDrinks property.This was a property of the model typebefore we moved this method out of the model into its actor.So how can we access it now?Well, the way actors relay informationis they pass values between each other.So we should have this functiontake currentDrinks as an argument.This argument to savereceives the list of currentDrinks to savethat's passed in by the model type.So that resolves that.Next, savedDrinks.This is a copy of the values last savedto avoid saving unnecessarily when nothing has changed.This value is mutated by both the saveand the load function,so it definitely needs protecting by the actor.So let's find it in our model......and move it over.OK, what's next?All right, this property dataURL,that's actually being used just by the load and save operation,so we can just move it over to be a private helperon the actor.OK, last issues to resolve.Now, here we're getting errors, and if we look,it appears that there's a closurethat's capturing some state from the actor,so we need to fix that.So why is there a closure here?Well, if you look down,it's because the same piece of codeis getting called in two places.And it turns out the compiler has flaggedsomething really interesting for us.What this code is doing is checking if the watch extensionis running in the background.And the idea is, if it's running in the background already,then don't go into the background queue;just stay on the main threadand perform the task of saving synchronously.But this doesn't seem right.You should never block the main threadto perform an I/O operation like saving,even when your app is running in the background.Why does the app do this?Well, we can trace it backto where the save operation is being called.It's being called from a didSetdown here on currentDrinks.And that fires so that whenever the property is assigned,it saves the new values.Now, didSets are super convenient,but they can be a little too tempting.Let's look at all of the callers of the currentDrinks property.If we drill in all the way down here......we find that the save operationis ultimately synchronousbecause of the way it's being called from this functionwhich is the call to handle background tasksfrom the WatchKit extension.Now this handle API has a contract.You're supposed to do all of your work, and then,when all your work is done, call thissetTaskCompletedWithSnapshot method.And you must guarantee all your work is donewhen you call thisbecause your watch app will be suspended.You can't have some I/O operation,like our save operation,still running when you say that you're done.This is a perfect example of how asynchronyforces global reasoning throughout your code.Let's visualize what's happening here.We start in handle(backgroundTasks:)which calls the load from HealthKit function.This takes a completion handler.But then we switch to updateModel(),which is performed synchronously,and so synchronously calls didSet,which synchronously saves.Once this is done, the completion handler is calledand that notifies WatchKit that it's all done.It's the synchronous parts that force us to performsynchronous I/O on the main thread.How can we fix this?To fix it with completion handlers,you'd have to update each currently synchronous methodto now take a completion handler.But you can't do that with a didSet;it doesn't take arguments, it just fires automaticallywhen you update the property.But the good news is that all our async refactoringis going to pay off now, because updating functionsfrom synchronous to be async is way easier.So first, let's goto the published property, currentDrinks,and let's change it to a private(set)so that we know all mutation is happening only from this file.And then let's take this didSet operationand instead move that logic into a new function......called "drinksUpdated()."We'll make it async,because it's going to call our save operation on our actor.And that needs to be an await......on the CoffeeData store,into which we're going to pass the new currentDrinks value.Then, we need to go to where currentDrinks is updatedand ensure we call drinksUpdated afterwards.Now in this function, there's one thing to note.It's important that this operation --that takes a copy of currentDrinks,mutates it, and then writes it back --all happens atomically.And this is why the await keyword is vital;it indicates that at this point, this operation might suspend,and other functions --functions that might also update currentDrinks -- could run.So we need to make sure that our entire mutationand writeback happens before any awaits,otherwise, other functions comingand mutating currentDrinks could lead to an inconsistent state.So this function needs to be async.We can go to our save operation and eliminatethis unnecessary background and foreground branchand just do the operation on the actor every time.OK. Finally, let's look at the load operation.Now here, the logic is splitbetween code that needs to run in the backgroundand code that needs to run on the main thread.So let's first take the first half --the background portion -- and move that into the actor.Now doing this, we notice another possible race condition.savedValues here was being mutated on the main queue,but if you remember the save operation,it was both read and written from the background queue.Now, as it happens, the way the app was constructed,the load only ever happened on startup, so this was fine.But again, that's relying on global reasoning,and it's the kind of assumption that can break in subtle wayswhen you make future changes.It's much better to let the actor ensure the programwill always be correct.So we're going to fix that now.So first, let's remove this queue management......reindent the function, remove this other queue management.And just like with save,we need a way to pass back the loaded values,which we do just by returning a valuefrom this load function on the actor.So now, let's hop back to the original load.And we've moved this logic, so we can just delete it...and replace it with a call to await......loading the drinks from the actor.Now, because we're awaiting the actor,that means this function needs to be async.And while we're here,we can clean up these deprecation warnings.And finally, because this load is now async,we need to await it here.And because we're awaiting it here,we need to create a task.But at this point, if we just used an async task,we're potentially introducing a new race condition.Remember, outside of an actor,this new task just runs on an arbitrary thread.We shouldn't mutate shared state,like currentDrinks, from an arbitrary thread.Now, one way to resolve thiswould be to put the load function on the main actor,But it's much better to move the entire of model typeto the main actor.So we go to our CoffeeModel definitionand add "MainActor" to our model type.By putting the model on the main actor,we're now guaranteeing that all accessto CoffeeData's propertiesare going to be made from the main thread.And this is good because, as we noted earlier,it's an observable object and it has a published property.And properties published to SwiftUImust only be updated on the main thread.It also means any calls to async from the actorwill also run on the actor.so we can remove any other "MainActor" annotationssuch as the one we added earlier.So now you might notice that when we compilewe don't hit any compilation errors,unlike when we moved other thingsinto an actor earlier.And that's because the places we're calling into our modelare things like SwiftUI views.For example, let's go to DrinkListView.Now, this type displays a list of buttons on the screen.And then it calls addDrink, which is on our model type.But this DrinkListView is itself also on the main actor.And so its methods......can call into the CoffeeData model without an await.What is it that determinesthat this SwiftUI view is on the main actor?Well, it's inferred from its use of EnvironmentObject here.Any SwiftUI view that accesses shared state --such as environmental objects or an observed object --will always be on the main actor.Elsewhere......we're also accessing our modelfrom this extension delegate call.Since this extension delegateis guaranteed to be called on the main thread,it's been annotated by WatchKit as running on the main actor,and so it can also call into our model type directly.Finally, now that we're here, let's refactor this methodand get rid of this deprecated completion handler usage.We can instead wrap this section in a new asynchronous task.Remember, this handler is running on the main thread,so when we create a task,that task will also be running on the main thread.And inside this new task, we can now await......our call to load new data from HealthKit.And a really nice thing aboutgetting rid of completion handlersis you can now compose functions together.So if you wanted, you could just move this awaitdirectly into the if statement.Once this function call returns,we know that all our work is complete because, inside it,we will awaiting the save operation.And so, we can now confidently callbackground.Task.setTaskCompletedknowing that we finished all of our I/O operations.We now have this nice, structured, top-down approachto waiting for an asynchronous operationbefore completing any more work.Incidentally, this structured approach to concurrencyis another really important part of Swift's concurrency feature.To learn more, watch the associated talk,which covers how you can take advantage of this featureto structure more complex examples,such as waiting on multiple asynchronous operationsto complete before continuing.If, while you watch this talk,you wondered exactly how some of these new features work,check out our under-the-hood talkthat explores some of the technology in detail.So let's recap.We've taken some code that had sound type architecturebut complex concurrency architecturethat had some hidden race conditionsthat were really hard to spot.And with the help of the new concurrency features,we've rearchitected it so that the concurrencyand type architecture are nicely aligned.And the compiler helped us findsome hidden potential race conditions along the way.There's a lot more to Swift 5.5 we haven't covered,like structured concurrency with task groups,async sequences,and some great new asynchronous APIs in the SDK.There's also a few more refactoringswe didn't do in this projectthat you might want to try yourself.The best way to learn these techniquesis to try them out in your own apps,so have fun and enjoy these cleaner, safer ways to code.♪

♪ Bass music playing ♪♪Ben Cohen: Hi, I'm Ben from the Swift team,and in this video,I'm going to walk through porting an existing applicationover to use Swift's new concurrency features.We'll see how these new featureshelp you write clearer asynchronous code,and protect against possible race conditions,as well as look at some techniquesfor gradually moving your code to this new way of operating.

I'm going to be using an app called Coffee Tracker,and it's based on a talk from WWDC 2020about creating and updating watch complications.This is a simple app that lets you trackall the coffee you've drunk today,as well as a complication to show your current caffeine levelon a watch face.It's a nice example to use for our purposesbecause although it's a small app,it shows lots of different things we want to think about,including how concurrency works with SwiftUI,delegate callbacks from the watch SDK, some I/O,and interfacing with asynchronous APIsin Apple's SDK.Now let's take a quick tour of the app.It's roughly broken up into three layers.First, there's the UI layer.This is mostly SwiftUI views,but in this we can also consider thingslike the complication data source as part of the UI layer.Next there's the model layerthat comprises a couple of simple value typesto represent caffeine drinks,as well as a model type called "Coffee model."Now, this is what you might call the UI Model.That is, the place where you hold data for displayby the UI layer.It's an observable object that feeds our SwiftUI view,and all of the updates on itwill need to be made on the main thread.I'm referring to it as a UI modelbecause it might not be the full modelof all of your application's data.It might just be a projection of your data modelor a subset of it;just what you need to display on the UI at this moment.Finally, we have what you can think of as the back-end layer:processing that happens -- probably in the background --to populate your model or talk to the world outside your app.In our case, that's represented by this HealthKitController typethat manages communication to HealthKitto save and load the user's caffeine intake.Now, before we start looking at code,let's talk about how concurrency is managed in the app.This architecture looks fairly clean,but when we layer on how concurrency is handled,we get a much messier picture.This app is essentially broken up into three concurrent queueson which code can be executing.Work in the UI and on the model is done in the main queue.The app also has a dispatch queuefor doing work in the background.And finally, certain callbacks into completion handlers --like those returning results from HealthKit --are done on arbitrary queues.This is a pretty common situation.What seems like a simple application architectureignores a lot of the hidden complexityin how it handles concurrency.Now, for a quick spoiler.In adopting Swift concurrency,we're going to go from this ad hoc concurrency architectureto something that will look like this.We're going to put our UI views and model on what's calledthe main actor.We're going to create new actors to operate in the background,and these types will pass thread-safe valuesbetween each other using the async/await feature.When we're done, the concurrency architectureshould be as clear and easy to describeas the type architecture.Now we've used a few terms here you might not be familiar with,like "async/await" and "actors,"and we'll explain them briefly as we use them in code.But for a more in-depth explanation of these features,there are several other talks availablethat go into much more detail.So now we've seen the overall architecture,let's dive into the code.

Here we have the different files.First, of some Swift UI views.And then we have our watch complication controller'sextension delegate.We have the simple model type that represents a caffeine drinkand a CoffeeData UI model that holds an array of these drinks.And finally, we have the HealthKitController.And it's in this layer I'm going to get startedintroducing some of Swift's new concurrency featuresinto our app.The HealthKitController contains a few different callsinto the HealthKit SDK that take completion handlers.Let's start by looking at this controller's save operation.So I just hit Control-6,and that brings up the list of functions in this file,and we're going to go to the save operation.Now, before we even get into the new concurrency features,let's talk a little bit about thread safety in Swift today.This code accesses some variables,isAvailable and store.Now, it looks like we're only reading these variablesin this function.Is that safe?Well no, not if other code could be writing to themat the same time.To know whether or not this code is thread-safe,I need more information than just looking at this function.There's no use of dispatch queues or locks in it,so whatever makes this code thread-safe --assuming it is -- must be elsewhere.Maybe the caller serializes all calls to savethrough a queue.Or maybe the app is constructed in some way that means it's OK.But I can't know this just by looking at this function.Being able to do that --to look at this function and know certain thingswithout having to go look at other parts of my program --is what we call local reasoning,and it's a really important goal for Swift.For example, Swift's emphasis on value typesis about local reasoning.Unlike a reference type,you don't have to worry that a value type you've been passedis being mutated elsewhere in your program.A lot of the language featuresbeing introduced for concurrency in Swift 5.5are about giving you more opportunityto reason locally about your code.Now, as it happens,this function is entirely thread-safe,but I figured that out myself;the compiler isn't helping me spot these issues.So down here, we have a call to the HealthKit SDKto save a caffeineSample into the user's health data.And this takes a completion handler,and that completion handler takes two values:success or error.If the operation succeeds, there's no error;the error will be nil.This means we need to remember to check the status and then,when appropriate, unwrap the optional error down here.Now, this isn't normally how we handle errors in Swift.This would be much betteras a method that can throw on failure.But that approach doesn't work with completion handlers.But now, with async methods,we can have asynchronous functions that can throw.

This HealthKit save method now has an async equivalentthat does exactly that,so let's switch over to using it.To do that, first we remove the completion handler,and we write "await" in front of the method call.

This reminds us that it's an async function call,and the code will suspend at this pointand allow other code to run.We'll come back to why this is important a little bit later.So if we compile, now that we've done this,we see that the compiler is telling us that we need a "try."And this is a big benefit of async functions;they can throw.There's no more having to rememberto check an optional error.

So we can add a "try" in front of this method call,and we want to handle the error right away.So we wrap this call in a do block...and then catch the error.We can remove this guard.And now that we're catching the error,it's no longer optional, so we can remove the unwrap.This also means we can rearrange our codeto keep the happy path at the topso we can move the success logging lineup right underneath the saveand then just handle the error logging in the cache.

Notice that save no longer returns a value.Returning success/failure was really duplicativewith the error,so our new function only either throwsor it's succeeded.

Now that we've added the try-catch,we're getting one more error from the compiler.We're calling an asynchronous function,but we're calling it from within a synchronous function.This does not work.Asynchronous functions have a capabilitythat synchronous functions don't have:the ability to give up control of the thread they're running onwhile they await.To do this,they have a separate way of handling their stack frame,and this isn't compatible with synchronous functions.So one option is to make this function async instead.So we can just add the async keywordafter the function definition.And now, this file compiles.

But the whole project doesn't compile yet.Making this function async has pushed the problem up a levelto where it's being called.

Here in my data model,I'm now getting that same compiler errorbecause this function isn't async.Now I could keep going up the chain, but for now,let's see another technique to keep the changes localized.To call my async function,I'm going to spin off a new asynchronous taskwhich will be allowed to call async functions.This async task is very similar to calling asyncon the global dispatch queue.You can't return a value back from it to the outer functionbecause the block executes concurrently.So whatever you do with the detached closureneeds to be self-contained.In this case, we're just calling save,which doesn't return a value, so that's fine.You also need to be careful that you're not touchingglobal state that might get mutated simultaneouslyfrom other threads.And this is where it was relevantthat save was completely thread-safe,otherwise we might be accidentally introducingnew race conditions by adding this new task.

Now that we've put it inside an async task,our awaited function compiles,and we've finished our first use of async/await in this app,we could run it right now.

Let's do another one of those refactorsand this time, look at some other techniqueswhen migrating to async.So let's have a look at the call to request authorizationof access to the user's health data.This similarly calls HealthKit with a completion handler.But unlike before, this function takes, itself,a completion handler.What I'm going to do is I'm going to createa second version of the function to become asyncwhile keeping the completion handler version.That way other parts of our codethat call it with a completion handlercan keep on working while we refactor.I can do this easily by using the "Create Async Alternative"refactoring action.That's available in the Code Action menu --which I can bring up with Command-Shift-A --and choose the option to add the async alternative.So this has added a second async versionof the original call.

And it's replaced the original completion handler codewith code that creates a new async task...

...and then just awaits the async version of the function.Notice that the async refactoringhas added a deprecation warning to the original one.These are going to help guide me to parts of my codethat could next benefit from refactoringto call this new async version.Let's undo and go back for a momentto that original completion handler version.Inside this requestAuthorization callback,this callback can happen on an arbitrary thread.So you need to know that the code inside it is thread-safe.But I don't think it is.This assignment here might happen simultaneouslywith other code reading this value on other threads.And there's another example of a lack of local reasoningin this code.After that assignment, this completion handler is called,and I have no idea whether the codeinside that completion handler is thread-safe.I'd have to go and lookat all of the call sites to this functionto look at how their completion handlers are writtento know that this is OK.Now, let's redo again and see the refactored version.Now remember,an async task also runs on an arbitrary threadsimilar to a dispatch callback.So this forwarding version has similar problemsto the completion handler version we had before.We haven't made our code any safer quite yet.We'll fix this soonby introducing actors into our code.But for now, we should notethat just because we've converted this function to asyncdoes not mean we're free from race conditions.In fact, you should be aware of the risk of introducingnew race conditions into your codeif you only perform refactoring to introduce async functions.Now let's look at this new async function.The refactoring action has already convertedthe call with a completion handler hereto call the new async version of this SDK API.

But converting this function to asynchas highlighted something interesting.Here, when we were using the completion handler technique,we had a return without calling the completion handler.And this was probably a bug.The caller would have been left hanging.But with async functions, you must return a value,so now we're getting a compilation error,which we can resolve just by returning false for failure.

And just like before,this new async version of requestAuthorizationdoesn't actually return a value,it either succeeds or it throws.So we just need to delete this return value.And instead on this path,we need to assume that it succeeded......and on the failure path, we need to return false.If I try and compile now,the project compiles because the old code elsewherecan still continue to call the completion handler versionand we're now seeing these deprecation warningswhen we're doing that, which can lead usto a next place that we might want to refactor.OK, let's do one more async conversion.Let's find the function to load data from HealthKit.We'll start -- just like before --by creating a stub for the old code to call.Then moving to the async version,incidentally, this one takes an optional completion handlerthe async equivalent of thiswould be to make this function have a discardable result.So next, we start moving down, replacing any useof the completion handler with returns.So for example, we can delete this completion handlerand just return false.But once we move a little further,we start to hit a snag,and it has to do with how the HealthKit query API is arranged.Here, there's a completion handlerbut it's on this query object; whereas really,what I want to await is the execution of the queryall the way down here at the bottom of the function.Incidentally, this hopping up and down around the functionis another thing that async/awaitis great at helping resolve.So what I want to do is create a single async functionthat both creates the query and then executes it.We're going to do that nowusing a technique called a continuation.So I'm to go back up to the top of this functionand I'm going to create a helper functioncalled "queryHealthKit."I could do all of this work inside the existing functionbut it might get a little bit messy,so I like to keep it separate in a helper function.This function will be async, so we can await it,and it will throw because the query operation can fail.And this function is going to return the useful values herethat are currently being passed intothe completion handler on the query.So I'm going to take the logic for performing the query,cut it, and move it into the helper function.And I'm also going to take the execution of the queryand move that too.Now, I need to somehow invert this codeso that it can await the completion handlerand return these values passed into the completion handlerback from my new asynchronous function.And this is where I use a continuation.So in this function, we're going to returnthe results of trying to await a call to awithCheckedThrowingContinuation function.And this takes a block that takes a continuation.And we're going to move this code inside that blockand then within the block, we're going to use the continuationto pass data back out of this function eitherby using the continuationto resume throwing the error here......or......to resume returning the values that we receivedinto the completion handler.

Now that we have this awaitable function,we can use it in our original code.

So we assign the results from calling the function.And we need to handle the error that can be thrown.In fact, actually, I'm going to go up hereand take this bit of logging and do that in the handler.

And then we just need to move all of this success codeup into the happy path.Finally, we need to address this closure.

Here, we're using dispatch async back to the main thread.But we've ditched our completion handler,so there's no way of relaying this informationback to the main thread using it.We need a different way.To resolve this, we're going to make our first use of actors.In Swift's concurrency model,there is a global actor called the main actorthat coordinates all of its operations on the main thread.We can replace our dispatch main.async callwith a call to main actor's run function.And this takes a block of code to run on the main actor.run is an async function, so we need to await it.Awaiting it is necessarybecause this function may need to suspenduntil the main thread is ready to process this operation.But because we await it,we can just remove our completion handler,and instead, return a value.OK, finally, the compiler is now giving me an errorabout a captured variable.

This is a new error that only occursinside asynchronous functions.Because closures in Swift capture variables by reference,when you capture a mutable variable --in this case, our newDrinks array --you create the possibility for shared mutable state,and that can be the source of race conditions.So when doing this,you need to ensure that you're making a copy of this value.One way to do this is to add newDrinksto the closure's capture list, like this.But often it's better to just avoid this problemby not having mutable variables in the first place.Here, we can do this by changing the code above instead.It's written this way because samples is optional.But instead what we could dois change newDrinks to an immutable valueand either set the value here in the if branchor an add an "else"to set it to the empty array.We could also have done this with a nil coalescing operatorif we prefer.Since this value is now declared with let instead of var,it's immutable and that resolves the issuewithout needing to make an additional capture.

Now let's keep talking about the main actorby taking a look at this functionthat needed to be called on the main thread.

At the top of this function,there's something that's a really great idea:there's an assert that the functionis correctly running on the main thread.If you had ever made a mistake and called this functionwithout wrapping itin a dispatch async to the main thread,you'd get an error in your debug builds,and you should definitely adopt this practicein some of your existing code.But this approach does have some limitations.You might forget to put an asserteverywhere it's needed,and you can't assert on access to stored properties,or at least not without lots of boilerplate.It's much better if the compiler can enforcesome of these rules for you,so you can't make mistakes like this at all.And that's how we use the main actor.I can annotate functions with "@MainActor."And that will require that the caller switchto the main actor before this function is run.

Now that I've done this, I can remove the assertionbecause the compiler won't let this function be called anywhereother than on the main thread.We can prove that this is workingby going back to the callerand moving this call outside of this MainActor.run block.And you see the compiler tells us, no,we can't call that from herebecause we're not on the main actor.Here's a way to think about this feature:it's a lot like optional values.We used to have values like pointersand had to remember check for nil,but it was easy to forget,and it's much better to let the compiler make surethis check always happensalong with some language syntactic sugarto make it easier.Here, we're doing a similar thing,only instead of enforcing nil checks,it's enforcing what actor you're running on.

Now that we've put this function on the main actor,we don't, strictly speaking, need this MainActor.run anymore.If you're outside of an actor,you can always run functions on that actor by awaiting them.And in fact, that's what the compiler is telling us here.It's saying that we need an await keywordin order to make the switch over to the main actorto run this function.So if we add it,then the code will compileeven without this call being inside the run block.Here, we're using await on a synchronous function --updateModel is synchronous --but the await indicates that the function we're inmay need to suspend to get itself onto the main actor.Think of this as similar to makinga DispatchQueue.sync call, except with await,your function suspends instead of blockingand then resumes after the call to the main thread is complete.

So, we don't need it here anymore,but this MainActor.run techniqueis still important for another reason.At each await,your function might suspend and other code might run.That's the point of awaiting:to let other code run instead of blocking.In this case, we only had one function to await,so it doesn't really matter,but sometimes you might want to run multiple callson the main thread.For example, if you're working on UI updates,such as updating entries in a table view,you might not want the main run loopto turn in between the operations you perform.In that case, you would want to use MainActor.runto group together multiple calls to the main actorto ensure that each ranwithout any possible suspensions in between.

So, we're now using the main actorto protect the code that needs to run on the main thread.But what about other code in this class?In particular, the code that mutates local variables,like the query anchor that we saw assigned to here.

How can we guarantee those are free from race conditions?Or one way would be to just put everythingin the HealthKitController on the main actor.If I go to the HealthKit controller definition,and just write "@MainActor"here on the class instead of on individual methods,that would protect every method on this type,and every stored property on it would be coordinatedon the main thread.And for a simple application like this one,that would probably be an OK choice.But that also seems a little bit wrong.This HealthKitController is really the back end of our app;it seems unnecessary to be doing all of its workon the main thread.We want to leave that threadfree to do UI-focused activities.So instead, we can change this classto, itself, be an actor.Unlike the main actor, which is a global actor,this actor type can be instantiated multiple times.In my project, I'm still only going to create one of them,but there are many other uses of actorswhere you might instantiatemultiple copies of the same actor.For example, you might make each room in a chat serverbe its own actor.So now that we've made this class into an actor,let's see what the compiler says.OK. So we're getting some compilation errors.Now let's take a pause here and talk about compiler errors.These errors are guiding you towards the places in your codeyou need to update when you're migrating codeto the new concurrency model.When you get these errors,make sure you understand what they're telling you.Resist the temptation to mash the fix-it buttonwhen you're not sure how or why it'll fix the issue.One thing to be wary ofis getting into a cascade of errors.Sometimes you'll make a change --like converting a class to be an actorlike we just did, or making a method async --and it'll generate some compiler errors.So you go to the site of those errors,and it's tempting to make more changes to fix those errors,like making that method async or putting it on the main actor.The trouble is that this can lead to even more errors,and quickly, you can feel overwhelmed.Instead, use techniques like we're using herein this walk-through,and try and keep the change isolatedand done one step at a time with your project compilingand running in between.Add shims to allow your old code to keep working,even though you might end up deleting them later.That way, you can gradually move out from a point,tidying up the code as you go.Incidentally, what I did here is first convertthe HealthKitController's methods to asyncand then make it into an actor.And I find it works out easiest if you do it that way around,rather than starting with the actor conversion.OK, so let's look at these errors by jumping down to them.They're down here on the functionwe put on the main actor.And this makes sense, because in this function,we're touching a stored propertyof our new HealthKitController actor,the model property.The actor protects its state and won't let functions,not on the actor -- such as this functionthat we've explicitly put on the main actor --touch its stored properties.Now looking at this function,it looks like the only state on the actor that it touchesis the model object.Everything else is passed in as a function argument.And to me,this suggests that this function belongs on the model;that the model here actually ought to be self.So let's move it to the model.So we can take this function, cut it,go over to our CoffeeData UI model,and paste it in.

It's going to be internal rather than private,so it can be called from the HealthKitController.And we just need to go throughand remove all references to the modelbecause that's now self.Finally, we need to go to where it was being called......and replace self here with a call to the model.So now, this HealthKitController file compiles,and I get a new set of errors from other files.Let's look at those errors.So here we're calling into those completion handler shimsthat we called earlierto allow us to keep passing in the completion handlereven though we've rewritten this function to the async.These functions are now being protected by the actorso I can't call them directly.But they don't touch any other part of the actor's stateif we look at them.All they're doing is spinning off a taskand then awaiting a call to the async version of the function.Since they don't touch any part of the actor's internal state,I can mark them as what's called "nonisolated."Do the same down here.Marking something as nonisolated tells the compilerthat you're not going to touch any of the isolated state,and therefore, this function can be called from anywhere.The switch over to the actor is actually happening automaticallywhen we await the call into the async version of the function.Note that the compiler will checkthat this nonisolated claim is true.If I were to try and access some state of the actor --such as, for example,printing out the authorization status --the compiler will stop me.

So now, I've completed my workconverting the HealthKitControllerinto an actor that protects its internal statefrom race conditions.Next, let's follow those deprecation breadcrumbsto the next file to work on,which is our CoffeeData model type.Now this class implements ObservableObject,and it has a Published property.Any updates to properties that are published to a SwiftUI Viewmust be done on the main thread,so this class is probably a good candidateto put on the main actor.

But there's also this background DispatchQueuefor doing some work in the background.Let's have a look at how that's used.

And it's just in two functions: load and save.That makes sense; you probably don't wantto do your loading and saving on the main thread.When you see a pattern like this --where a queue is being usedto coordinate some specific activities,but the rest of the class needs to be on the main thread --that's a sign that you want to factor that background codeout into a separate actor.So let's do that.So let's go to the top of the file and createa new private actor......which we'll call "CoffeeDataStore."And let's open CoffeeData in another window.and start moving code across into our new actor.So we can give it its own logger.

And let's tweak the categoryso we can tell when the actor is in use.And next, instead of this DispatchQueue,we're going to instantiate a copy of our new actor.Next, let's go to the save operation,and move that over.So we can take this function...

...cut it from here, and move it into the actor.

Let's start by compiling and seeing what issues come up.So first, there's this currentDrinks property.This was a property of the model typebefore we moved this method out of the model into its actor.So how can we access it now?Well, the way actors relay informationis they pass values between each other.So we should have this functiontake currentDrinks as an argument.This argument to savereceives the list of currentDrinks to savethat's passed in by the model type.So that resolves that.

Next, savedDrinks.This is a copy of the values last savedto avoid saving unnecessarily when nothing has changed.This value is mutated by both the saveand the load function,so it definitely needs protecting by the actor.So let's find it in our model......and move it over.

OK, what's next?All right, this property dataURL,that's actually being used just by the load and save operation,so we can just move it over to be a private helperon the actor.

OK, last issues to resolve.Now, here we're getting errors, and if we look,it appears that there's a closurethat's capturing some state from the actor,so we need to fix that.So why is there a closure here?Well, if you look down,it's because the same piece of codeis getting called in two places.And it turns out the compiler has flaggedsomething really interesting for us.What this code is doing is checking if the watch extensionis running in the background.And the idea is, if it's running in the background already,then don't go into the background queue;just stay on the main threadand perform the task of saving synchronously.But this doesn't seem right.You should never block the main threadto perform an I/O operation like saving,even when your app is running in the background.Why does the app do this?Well, we can trace it backto where the save operation is being called.

It's being called from a didSetdown here on currentDrinks.And that fires so that whenever the property is assigned,it saves the new values.Now, didSets are super convenient,but they can be a little too tempting.Let's look at all of the callers of the currentDrinks property.If we drill in all the way down here...

...we find that the save operationis ultimately synchronousbecause of the way it's being called from this functionwhich is the call to handle background tasksfrom the WatchKit extension.Now this handle API has a contract.You're supposed to do all of your work, and then,when all your work is done, call thissetTaskCompletedWithSnapshot method.And you must guarantee all your work is donewhen you call thisbecause your watch app will be suspended.You can't have some I/O operation,like our save operation,still running when you say that you're done.This is a perfect example of how asynchronyforces global reasoning throughout your code.Let's visualize what's happening here.We start in handle(backgroundTasks:)which calls the load from HealthKit function.This takes a completion handler.But then we switch to updateModel(),which is performed synchronously,and so synchronously calls didSet,which synchronously saves.Once this is done, the completion handler is calledand that notifies WatchKit that it's all done.It's the synchronous parts that force us to performsynchronous I/O on the main thread.How can we fix this?To fix it with completion handlers,you'd have to update each currently synchronous methodto now take a completion handler.But you can't do that with a didSet;it doesn't take arguments, it just fires automaticallywhen you update the property.But the good news is that all our async refactoringis going to pay off now, because updating functionsfrom synchronous to be async is way easier.So first, let's goto the published property, currentDrinks,and let's change it to a private(set)so that we know all mutation is happening only from this file.And then let's take this didSet operationand instead move that logic into a new function......called "drinksUpdated()."We'll make it async,because it's going to call our save operation on our actor.And that needs to be an await......on the CoffeeData store,into which we're going to pass the new currentDrinks value.Then, we need to go to where currentDrinks is updatedand ensure we call drinksUpdated afterwards.Now in this function, there's one thing to note.It's important that this operation --that takes a copy of currentDrinks,mutates it, and then writes it back --all happens atomically.And this is why the await keyword is vital;it indicates that at this point, this operation might suspend,and other functions --functions that might also update currentDrinks -- could run.So we need to make sure that our entire mutationand writeback happens before any awaits,otherwise, other functions comingand mutating currentDrinks could lead to an inconsistent state.

So this function needs to be async.We can go to our save operation and eliminatethis unnecessary background and foreground branchand just do the operation on the actor every time.

OK. Finally, let's look at the load operation.Now here, the logic is splitbetween code that needs to run in the backgroundand code that needs to run on the main thread.

So let's first take the first half --the background portion -- and move that into the actor.

Now doing this, we notice another possible race condition.

savedValues here was being mutated on the main queue,but if you remember the save operation,it was both read and written from the background queue.Now, as it happens, the way the app was constructed,the load only ever happened on startup, so this was fine.But again, that's relying on global reasoning,and it's the kind of assumption that can break in subtle wayswhen you make future changes.It's much better to let the actor ensure the programwill always be correct.

So we're going to fix that now.So first, let's remove this queue management...

...reindent the function, remove this other queue management.And just like with save,we need a way to pass back the loaded values,which we do just by returning a valuefrom this load function on the actor.So now, let's hop back to the original load.

And we've moved this logic, so we can just delete it...

and replace it with a call to await......loading the drinks from the actor.

Now, because we're awaiting the actor,that means this function needs to be async.And while we're here,we can clean up these deprecation warnings.And finally, because this load is now async,we need to await it here.And because we're awaiting it here,we need to create a task.But at this point, if we just used an async task,we're potentially introducing a new race condition.Remember, outside of an actor,this new task just runs on an arbitrary thread.We shouldn't mutate shared state,like currentDrinks, from an arbitrary thread.

Now, one way to resolve thiswould be to put the load function on the main actor,But it's much better to move the entire of model typeto the main actor.So we go to our CoffeeModel definitionand add "MainActor" to our model type.By putting the model on the main actor,we're now guaranteeing that all accessto CoffeeData's propertiesare going to be made from the main thread.And this is good because, as we noted earlier,it's an observable object and it has a published property.And properties published to SwiftUImust only be updated on the main thread.It also means any calls to async from the actorwill also run on the actor.so we can remove any other "MainActor" annotationssuch as the one we added earlier.So now you might notice that when we compilewe don't hit any compilation errors,unlike when we moved other thingsinto an actor earlier.And that's because the places we're calling into our modelare things like SwiftUI views.

For example, let's go to DrinkListView.Now, this type displays a list of buttons on the screen.And then it calls addDrink, which is on our model type.But this DrinkListView is itself also on the main actor.And so its methods...

...can call into the CoffeeData model without an await.What is it that determinesthat this SwiftUI view is on the main actor?Well, it's inferred from its use of EnvironmentObject here.Any SwiftUI view that accesses shared state --such as environmental objects or an observed object --will always be on the main actor.

Elsewhere...

...we're also accessing our modelfrom this extension delegate call.

Since this extension delegateis guaranteed to be called on the main thread,it's been annotated by WatchKit as running on the main actor,and so it can also call into our model type directly.

Finally, now that we're here, let's refactor this methodand get rid of this deprecated completion handler usage.We can instead wrap this section in a new asynchronous task.

Remember, this handler is running on the main thread,so when we create a task,that task will also be running on the main thread.

And inside this new task, we can now await......our call to load new data from HealthKit.And a really nice thing aboutgetting rid of completion handlersis you can now compose functions together.So if you wanted, you could just move this awaitdirectly into the if statement.

Once this function call returns,we know that all our work is complete because, inside it,we will awaiting the save operation.And so, we can now confidently callbackground.Task.setTaskCompletedknowing that we finished all of our I/O operations.We now have this nice, structured, top-down approachto waiting for an asynchronous operationbefore completing any more work.Incidentally, this structured approach to concurrencyis another really important part of Swift's concurrency feature.To learn more, watch the associated talk,which covers how you can take advantage of this featureto structure more complex examples,such as waiting on multiple asynchronous operationsto complete before continuing.

If, while you watch this talk,you wondered exactly how some of these new features work,check out our under-the-hood talkthat explores some of the technology in detail.So let's recap.We've taken some code that had sound type architecturebut complex concurrency architecturethat had some hidden race conditionsthat were really hard to spot.And with the help of the new concurrency features,we've rearchitected it so that the concurrencyand type architecture are nicely aligned.And the compiler helped us findsome hidden potential race conditions along the way.There's a lot more to Swift 5.5 we haven't covered,like structured concurrency with task groups,async sequences,and some great new asynchronous APIs in the SDK.There's also a few more refactoringswe didn't do in this projectthat you might want to try yourself.The best way to learn these techniquesis to try them out in your own apps,so have fun and enjoy these cleaner, safer ways to code.♪

0:07:34 -Call the async version of the HKHealthKitStore save(_:) method

0:09:38 -Change save(drink:) to be an async function

0:10:15 -Create a new asynchronous task

0:12:13 -Add an async alternative for requestAuthorization(completionHandler:)

0:14:55 -Update the async version of requestAuthorization()

0:15:43 -Add an async alternative for loadNewDataFromHealthKit(completionHandler:)

0:17:43 -Create a queryHealthKit() helper function that uses a continuation

0:20:17 -Update the async version of loadNewDataFromHealthKit()

0:25:09 -Annotate updateModel(newDrinks:deletedDrinks:) with @MainActor

0:26:43 -Remove MainActor.run from the call site of updateModel(newDrinks:deletedDrinks:)

0:29:24 -Change HealthKitController to be an actor

0:32:31 -Move updateModel(newDrinks:deletedDrinks:) to CoffeeData

0:33:18 -Update the call site of updateModel(newDrinks:deletedDrinks:)

0:34:01 -Mark the deprecated completion handler methods as nonisolated

0:36:20 -Create a private CoffeeDataStore actor for loading and saving

0:36:43 -Add a dedicated logger for CoffeeDataStore

0:37:05 -Add an instance of the actor to CoffeeData

0:38:37 -Move the savedValue property from CoffeeData to CoffeeDataStore

0:39:00 -Move the dataURL property from CoffeeData to CoffeeDataStore

0:42:42 -Move the didSet for currentDrinks to a new async function

0:44:00 -Update addDrink(mgCaffeine:onData:) to call drinksUpdated()

0:44:09 -Update updateModel(newDrinks:deletedDrinks:) to call drinksUpdated()

0:44:17 -Mark the updateModel(newDrinks:deletedDrinks:) method as async

0:45:26 -Complete the move of the save() method into CoffeeDataStore

0:46:20 -Move the top part of the load() method into CoffeeDataStore

0:48:01 -Update the load() method in CoffeeData to use the actor

0:49:08 -Update the CoffeeData initializer to use an async task

0:50:03 -Annotate CoffeeData with @MainActor

0:52:18 -Replace the completion handler usage in the handle(_:) method of ExtensionDelegate

## Code Samples

```swift
do
 {
    
try
 
await
 store.save(caffeineSample)
    
self
.logger.debug(
"
\(mgCaffeine)
 mg Drink saved to HealthKit"
)
} 
catch
 {
    
self
.logger.error(
"Unable to save 
\(caffeineSample)
 to the HealthKit store: 
\(error.localizedDescription)
"
)
}
```

```swift
public
 
func
 
save
(
drink
: 
Drink
)
 
async
 {
```

```swift
Task
 { 
await
 
self
.healthKitController.save(drink: drink) }
```

```swift
@available
(
*
, deprecated, message: 
"Prefer async alternative instead"
)

public
 
func
 
requestAuthorization
(
completionHandler
: 
@escaping
 (
Bool
) -> 
Void
 )
 {
    
Task
 {
        
let
 result 
=
 
await
 requestAuthorization()
        completionHandler(result)
    }
}
```

```swift
public
 
func
 
requestAuthorization
()
 
async
 -> 
Bool
 {
    
guard
 isAvailable 
else
 { 
return
 
false
 }

    
do
 {
        
try
 
await
 store.requestAuthorization(toShare: types, read: types)
        
self
.isAuthorized 
=
 
true

        
return
 
true

    } 
catch
 
let
 error {
        
self
.logger.error(
"An error occurred while requesting HealthKit Authorization: 
\(error.localizedDescription)
"
)
        
return
 
false

    }
}
```

```swift
@available
(
*
, deprecated, message: 
"Prefer async alternative instead"
)

public
 
func
 
loadNewDataFromHealthKit
(
completionHandler
: 
@escaping
 (
Bool
) -> 
Void
 
=
 { 
_
 
in
 })
 {
    
Task
 { completionHandler(
await
 
self
.loadNewDataFromHealthKit()) }
}
```

```swift
private
 
func
 
queryHealthKit
()
 
async
 
throws
 -> ([
HKSample
]
?
, [
HKDeletedObject
]
?
, 
HKQueryAnchor
?) {
    
return
 
try
 
await
 withCheckedThrowingContinuation { continuation 
in

        
// Create a predicate that only returns samples created within the last 24 hours.

        
let
 endDate 
=
 
Date
()
        
let
 startDate 
=
 endDate.addingTimeInterval(
-
24.0
 
*
 
60.0
 
*
 
60.0
)
        
let
 datePredicate 
=
 
HKQuery
.predicateForSamples(withStart: startDate, end: endDate, options: [.strictStartDate, .strictEndDate])

        
// Create the query.

        
let
 query 
=
 
HKAnchoredObjectQuery
(
            type: caffeineType,
            predicate: datePredicate,
            anchor: anchor,
            limit: 
HKObjectQueryNoLimit
) { (
_
, samples, deletedSamples, newAnchor, error) 
in


            
// When the query ends, check for errors.

            
if
 
let
 error 
=
 error {
                continuation.resume(throwing: error)
            } 
else
 {
                continuation.resume(returning: (samples, deletedSamples, newAnchor))
            }
        }
        store.execute(query)
    }
}
```

```swift
@discardableResult


public
 
func
 
loadNewDataFromHealthKit
()
 
async
 -> 
Bool
 {
    
    
guard
 isAvailable 
else
 {
        logger.debug(
"HealthKit is not available on this device."
)
        
return
 
false

    }
    
    logger.debug(
"Loading data from HealthKit"
)

    
do
 {
        
let
 (samples, deletedSamples, newAnchor) 
=
 
try
 
await
 queryHealthKit()

        
// Update the anchor.

        
self
.anchor 
=
 newAnchor

        
// Convert new caffeine samples into Drink instances.

        
let
 newDrinks: [
Drink
]
        
if
 
let
 samples 
=
 samples {
            newDrinks 
=
 
self
.drinksToAdd(from: samples)
        } 
else
 {
            newDrinks 
=
 []
        }

        
// Create a set of UUIDs for any samples deleted from HealthKit.

        
let
 deletedDrinks 
=
 
self
.drinksToDelete(from: deletedSamples 
??
 [])

        
// Update the data on the main queue.

        
await
 
MainActor
.run {
            
// Update the model.

            
self
.updateModel(newDrinks: newDrinks, deletedDrinks: deletedDrinks)
        }
        
return
 
true

    } 
catch
 {
        
self
.logger.error(
"An error occurred while querying for samples: 
\(error.localizedDescription)
"
)
        
return
 
false

    }
}
```

```swift
@MainActor


private
 
func
 
updateModel
(
newDrinks
: [
Drink
], 
deletedDrinks
: 
Set
<
UUID
>)
 {
```

```swift
await
 
self
.updateModel(newDrinks: newDrinks, deletedDrinks: deletedDrinks)
```

```swift
actor 
HealthKitController
 {
```

```swift
@MainActor


public
 
func
 
updateModel
(
newDrinks
: [
Drink
], 
deletedDrinks
: 
Set
<
UUID
>)
 {

    
guard
 
!
newDrinks.isEmpty 
&&
 
!
deletedDrinks.isEmpty 
else
 {
        logger.debug(
"No drinks to add or delete from HealthKit."
)
        
return

    }

    
// Remove the deleted drinks.

    
var
 drinks 
=
 currentDrinks.filter { deletedDrinks.contains(
$0
.uuid) }

    
// Add the new drinks.

    drinks 
+=
 newDrinks

    
// Sort the array by date.

    drinks.sort { 
$0
.date 
<
 
$1
.date }

    currentDrinks 
=
 drinks
}
```

```swift
await
 model
?
.updateModel(newDrinks: newDrinks, deletedDrinks: deletedDrinks)
```

```swift
@available
(
*
, deprecated, message: 
"Prefer async alternative instead"
)
nonisolated 
public
 
func
 
requestAuthorization
(
completionHandler
: 
@escaping
 (
Bool
) -> 
Void
 )
 {
    
// ...

}


@available
(
*
, deprecated, message: 
"Prefer async alternative instead"
)
nonisolated 
public
 
func
 
loadNewDataFromHealthKit
(
completionHandler
: 
@escaping
 (
Bool
) -> 
Void
 
=
 { 
_
 
in
 })
 {
    
// ...

}
```

```swift
private
 actor 
CoffeeDataStore
 {

}
```

```swift
let
 logger 
=
 
Logger
(subsystem: 
"com.example.apple-samplecode.Coffee-Tracker.watchkitapp.watchkitextension.CoffeeDataStore"
, category: 
"ModelIO"
)
```

```swift
private
 
let
 store 
=
 
CoffeeDataStore
()
```

```swift
private
 
var
 savedValue: [
Drink
] 
=
 []
```

```swift
private
 
var
 dataURL: 
URL
 {
    
get
 
throws
 {
        
try
 
FileManager

            .default
            .url(for: .documentDirectory,
                 in: .userDomainMask,
                 appropriateFor: 
nil
,
                 create: 
false
)
            
// Append the file name to the directory.

            .appendingPathComponent(
"CoffeeTracker.plist"
)
    }
}
```

```swift
@Published
 
public
 
private(set)
 
var
 currentDrinks: [
Drink
] 
=
 []


private
 
func
 
drinksUpdated
()
 
async
 {
    logger.debug(
"A value has been assigned to the current drinks property."
)

    
// Update any complications on active watch faces.

    
let
 server 
=
 
CLKComplicationServer
.sharedInstance()
    
for
 complication 
in
 server.activeComplications 
??
 [] {
        server.reloadTimeline(for: complication)
    }

    
// Begin saving the data.

    
await
 store.save(currentDrinks)
}
```

```swift
// Save drink information to HealthKit.


Task
 {
    
await
 
self
.healthKitController.save(drink: drink)
    
await
 
self
.drinksUpdated()
}
```

```swift
await
 drinksUpdated()
```

```swift
@MainActor


public
 
func
 
updateModel
(
newDrinks
: [
Drink
], 
deletedDrinks
: 
Set
<
UUID
>)
 
async
 {
```

```swift
// Begin saving the drink data to disk.


func
 
save
(
_
 
currentDrinks
: [
Drink
])
 {

    
// Don't save the data if there haven't been any changes.

    
if
 currentDrinks 
==
 savedValue {
        logger.debug(
"The drink list hasn't changed. No need to save."
)
        
return

    }

    
// Save as a binary plist file.

    
let
 encoder 
=
 
PropertyListEncoder
()
    encoder.outputFormat 
=
 .binary

    
let
 data: 
Data


    
do
 {
        
// Encode the currentDrinks array.

        data 
=
 
try
 encoder.encode(currentDrinks)
    } 
catch
 {
        logger.error(
"An error occurred while encoding the data: 
\(error.localizedDescription)
"
)
        
return

    }

    
// Save the data to disk as a binary plist file.

    
do
 {
        
// Write the data to disk.

        
try
 data.write(to: 
self
.dataURL, options: [.atomic])

        
// Update the saved value.

        
self
.savedValue 
=
 currentDrinks

        
self
.logger.debug(
"Saved!"
)
    } 
catch
 {
        
self
.logger.error(
"An error occurred while saving the data: 
\(error.localizedDescription)
"
)
    }
}
```

```swift
func
 
load
()
 -> [
Drink
] {
    logger.debug(
"Loading the model."
)

    
var
 drinks: [
Drink
]

    
do
 {
        
// Load the drink data from a binary plist file.

        
let
 data 
=
 
try
 
Data
(contentsOf: 
self
.dataURL)

        
// Decode the data.

        
let
 decoder 
=
 
PropertyListDecoder
()
        drinks 
=
 
try
 decoder.decode([
Drink
].
self
, from: data)
        logger.debug(
"Data loaded from disk"
)
    } 
catch
 
CocoaError
.fileReadNoSuchFile {
        logger.debug(
"No file found--creating an empty drink list."
)
        drinks 
=
 []
    } 
catch
 {
        
fatalError
(
"*** An unexpected error occurred while loading the drink list: 
\(error.localizedDescription)
 ***"
)
    }

    
// Update the saved value.

    savedValue 
=
 drinks
    
return
 drinks
}
```

```swift
func
 
load
()
 
async
 {
    
var
 drinks 
=
 
await
 store.load()

    
// Drop old drinks

    drinks.removeOutdatedDrinks()

    
// Assign loaded drinks to model

    currentDrinks 
=
 drinks

    
// Load new data from HealthKit.

    
let
 success 
=
 
await
 
self
.healthKitController.requestAuthorization()
    
guard
 success 
else
 {
        logger.debug(
"Unable to authorize HealthKit."
)
        
return

    }

    
await
 
self
.healthKitController.loadNewDataFromHealthKit()
}
```

```swift
Task
 { 
await
 load() }
```

```swift
@MainActor


class
 
CoffeeData
: 
ObservableObject
 
{
```

```swift
// Check for updates from HealthKit.


let
 model 
=
 
CoffeeData
.shared


Task
 {
    
let
 success 
=
 
await
 model.healthKitController.loadNewDataFromHealthKit()

    
if
 success {
        
// Schedule the next background update.

        scheduleBackgroundRefreshTasks()
        
self
.logger.debug(
"Background Task Completed Successfully!"
)
    }

    
// Mark the task as ended, and request an updated snapshot, if necessary.

    backgroundTask.setTaskCompletedWithSnapshot(success)
}
```


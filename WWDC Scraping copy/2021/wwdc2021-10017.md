# Wwdc2021 10017

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Bring Core Data concurrency to Swift and SwiftUIDiscover how Core Data is adopting the new concurrency capabilities of Swift 5.5, leading to more concise, efficient, and safe asynchronous code. We'll show you how to update Core Data in your apps to work with concurrency, and detail the many other improvements throughout the framework that make working with Swift and SwiftUI more expressive and powerful.ResourcesLoading and Displaying a Large Data FeedHD VideoSD VideoRelated VideosWWDC21Build apps that share data through CloudKit and Core DataMeet async/await in SwiftShowcase app data in SpotlightThere and back again: Data transfer on Apple WatchWhat's new in SwiftUI

Discover how Core Data is adopting the new concurrency capabilities of Swift 5.5, leading to more concise, efficient, and safe asynchronous code. We'll show you how to update Core Data in your apps to work with concurrency, and detail the many other improvements throughout the framework that make working with Swift and SwiftUI more expressive and powerful.

Loading and Displaying a Large Data Feed

HD VideoSD Video

HD Video

SD Video

Build apps that share data through CloudKit and Core Data

Meet async/await in Swift

Showcase app data in Spotlight

There and back again: Data transfer on Apple Watch

What's new in SwiftUI

Search this video…♪ ♪Hello, everybody.I'm Michael LeHew from the Core Data team.And today, I'm really excited to talk to youabout some of the enhancements the team has madeto make working with Core Data and Swifta truly excellent experience.I'm going to start with a reviewof how Core Data is a great solutionfor your customers’ data persistence needsacross all Apple platforms.I'll then follow up with a discussionon some of the ways that Core Data has adoptedthe new concurrency opportunitiesin the Swift runtime.Next, I'll cover some of the enhancementswe've made to Core Data APIsto make your code more expressive in Swift.And then conclude the discussion with an explorationof the dynamic capabilities that Core Data is addingto our existing SwiftUI supportthat we introduced in 2020.Let's start at the beginning, though,where regardless of which Apple platform you are developing for,you simply have an application.At some point, your applicationis going to eventually encounter user data,and you'll likely need to store it somewhere.A great choice for that needis to use Core Data.Core Data is Apple's hallmark frameworkfor application developers who desire to persisttheir users' data in a robust and feature-rich way.The framework takes care of many of the complexitiesof appropriately managing user data,from the way it was represented as an object graph in memoryto how it's modeled in storage.The framework also goes through great effortsto manage important runtime considerations,like memory use and latency.The capabilities provided by the framework are scalable too.You can start with a simple, locally-persisted storeand expand to use multiple execution contextsto improve performance, and even createpowerful shared data experiences through CloudKit.Core Data also works across all Apple-supported platforms.And I'd really like to emphasize this last point.Once you start using Core Data, everything you learn will workon each of our platforms, from your Mac,to your iPhone, or even your Apple Watch.And, of course, Core Dataworks great in Swift too.Over the past few years,we've been continuing to enhance Core Data APIto be as expressive as possible in Swift.And this is a pretty exciting year for Swiftwith the introductionof the all-new concurrency featuresin the language and runtime.Since its inception,Core Data has always cared about running code concurrently,and there's a really good reason for this.Persisting data requires reading and writingto some external storage media,and this makes supporting the new concurrency modela natural fit.Let's explore how this works in the contextof our Earthquakes sample application.This application reads a data feedfrom the US Geological Surveyand uses Core Data to store informationabout recent earthquakes,such as their magnitude, location,and the date for which the event occurred.Architecturally, Earthquakes is a Swift applicationthat has a view context to drive the UIand a background contextto ingest the data provided by the USGS.Our sample has a local container for our applicationand gathers quake data from the USGS's JSON feed.As we download data, we hand it off to our JSON parserand then import it into our background contextto be turned into managed objectsand saved to our local store.The view context then merges the changesto magically update our UI.In 2020, we focused on how to efficiently handle this datathrough the use of batch operations.Now, however, I'd like to focuson how we perform these operations concurrently.In particular,I'd like to focus on the three steps that we taketo import data into the application.Step one is to download the raw data,and upon successful download,the application needs to convert itto our specific local representation.And finally, save the new objectsinto the persistent store.Let's go ahead and convert this to high-level code.I've abstracted each operationinto its own function or closure.The app first retrieves the raw data from the server,processes it into a convenient local representation,and then imports the objects into Core Databy making a batch insert requeston the background managed object context.Written like this, it is a bit easierto visualize potential bottlenecks.Loading data over the network would be a great opportunityto consider doing our work asynchronously.Converting might also be a place to consider.Additionally, importing the datainto our persistent store seems quite opportune.Historically, though, in all of these cases,you would need to implementany such asynchronous mechanism yourselfor lean heavilyupon a framework-specific implementation.Let's talk about Core Data's specific abstraction.In the case of Core Data, when you call performAndWait,the managed object contextwill execute the provided closurewithin its own protected execution environment.This can potentially tie up the calling threaduntil the work is complete.If we were to visualize this,we can imagine three blocks of codewhich I've labeled BEFORE, DURING, and AFTER.When our code runs,first the code labeled BEFORE gets a chance to executeon the originating thread.We then call performAndWait,and the calling thread will blockuntil the work that happens DURING the closure completes.When that work is done, the code described AFTER will execute.Of course, if you don't need to waitfor the closure to finish,we've always offered a fully asynchronous variant.But new this year, Swift has gainedpowerful concurrency model with deep language integrationwhich allows Core Data to more accurately describethe intention of our API.The syntax is a bit different.You ask to await the results of the perform,but the mental model for using this new APIis exactly the samethat managed object has always supported.The benefit, however, is that the concurrencyis no longer a hidden implementation detail,but instead deeply integratedinto the Swift language.Because of this,the compiler can automatically preventmany common concurrency bugs,such as data races and deadlocks,and even efficiently make use of resourceswhen tasks are known to be awaiting results.Let's go back to the codeand see what using this in practice is like.As we saw, you ask to await an async-declared function.This has the potentialto suspend the calling execution contextuntil the async function yields control by returning.It also seamlessly workswith Swift's existing structured error handlingby routing any thrown errors to the calling frame,just as you would expect.Now that we've seen an exampleof calling an asynchronous function,let's take a look at how they're declaredby looking at Core Data's brand-new wayto perform asynchronous workwithin a managed object context.There is quite a bit of functionality packedinto this small stanza of Swift code,but I'm only gonna talk about a few important details,and then we'll jump into showinghow you can use it in practice.Starting with the declaration of the new perform overload.You can see it's genericbased on the kind of results that it can returnand is decorated with the new async keyword,which opts this functioninto the new concurrency capabilities in Swift.Perhaps the most significant facet of this new APIis that the provided closure now allows youto throw an error or return a value,saving you the effort of routing these backto the calling frame by hand.Let's see how cool this isby exploring a few different scenarios.Historically, since the concurrency was hidinginside of our implementation, one of the only waysto route errors outside of a performAndWaitwas to close over an optionaland then check it afterwards.This could be more complicated if you were usingthe fully asynchronous versions of performbecause you'd need to do a lot of plumbingby passing completion handlers aroundand making sure you used them consistently.With the new concurrency model in Swift,all of that plumbing is handled for you!Just try and await your asynchronous work,and if an error occurs, just throw it,and things will unwind to the calling frame naturally.So now, we focused on errors,but what about results?Well, everything I've described works exactly the same.Let's look at a concrete example.Let's sketch out what we wanna do before jumping into the code.For this example, I'd like to configurea fetch request to identify the number of earthquakesthat have happened in the last five hours.As a sentence,this is a straightforward task to describe.But in code, we're going to need to reorder things a bit.We'll first need to figure out when five hours ago was,for which we can use the Calendar APIsto calculate this in a robust way.We'll then configure a fetch requestwith a predicate in terms of that dateand ask for a count result type.In code, it looks pretty much like our plan.We use Calendar's offset APIto calculate five hours before now,and then configure a Quake FetchRequestto return a count result with a predicatethat matches the dates that we care about.Historically, returning resultsfollowed a similar pattern to the way we captured errors.You would close over any state that you needed to mutate,perform your computations in the managed object context,and then later, use the result after regaining control.Now, we can simply just tryand await the result of our perform calland return the result for perform directlyto our calling frame.The rest of the code is exactly the same.It's only the by-hand value routing that we avoidalong with any potential bugs or nuancesthat that code may have had.This new code is quite succinct and expressive.It is worth mentioning, however,that there are times where you should be cautious.Let's look at a different example to see why.This example attempts to returnthe most recent earthquake as a managed object.While the new API makes it really easy to return values,it is not safe to return managed objectsthat are already registered to a managed object context.It is only valid to refer to such registered objectswithin the closure of a call to perform.Instead, if you need to refer to a managed objectbetween different execution contexts,either make use of the object ID and refetch as needed,or make use of the dictionary representation optionof the fetch request.Now before we look at one more example,I'd like to cover a detail that I haven't talked about yet.And that detail is the ScheduledTaskType.So far, every async perform that we have seenhas been in terms of the default value for this option:.immediate.There is a second option called .enqueued,and to understand the differencebetween these two scheduling approaches,it helps to think about what specifically happensinside a managed object contextwhen you ask to schedule work.As we've seen, .immediate behaves a lotlike a Swift-async-aware version of performAndWait.If you're running on a different execution contextand ask to await work performed on the background context,you will wait until it is scheduled and completed.If you're already on the same execution context, however,the work will be optimistically scheduled right away..enqueued, on the other hand, is a bit simpler.It simply always just appends the requested workto the end of the contexts' work set,regardless of the affinity of the originating call site.Let's go ahead and look at one more example.All of these async featurescan be adopted by you as well.Here, I factored the import logicthat we have been talking aboutinto a new importQuakes function,decorated with the new async keyword.This function is, in turn,implemented in terms of other async functionality.Now anyone can await upon this new functionto take advantage of the new concurrency features in Swift.Let's summarize what we've seen so far.Taken altogether, this new API brings the supportfor Swift's structured concurrencyright into Core Data.The new variants of the perform APIare just Swift concurrency-aware versionsof the existing Core Data APIyou already know and love.We strongly encourage you to take advantageof this new API in your applications.Further, NSManagedObjectContext is notthe only type in Core Data that supports performing taskswithin its protected concurrency domain.We're also adding similar API to bothNSPersistentContainer and NSPersistentStoreCoordinator.The general shape and behavior of these APIs are quite similarto what I've already described.But with all that concurrent power,I would be remiss to not offer the adviceof using existing debugging toolsavailable at your disposal.Of course, the Xcode-providedaddress and thread sanitizers are incredibly helpfulfor catching bugs you might not even know existed.These can both be found in the Diagnostics paneof the scheme editor's Run settings.Each sanitizer detects different kinds of issues,including validating safe memory use assumptionsand appropriate use of data from multiple threads.It's always a good idea to qualify your applicationsand their associated tests with both sanitizersbefore you release your software to your community of users.And while the sanitizers are useful in all contexts,I also wanna highlight that Core Dataprovides a special runtime flagthat you can enable to get more domain-specific help.By enabling this option, Core Data will turn on a numberof useful assertions to validate internal locksand confirm appropriate use of various Core Data types.Adopting Swift concurrency supportis not the only change made to Core Data this year.Every new API that we are introducing,from CloudKit sharingto the new Spotlight integration,has been crafted with its presentationin Swift in mind.This year, we have a separate sessionfor each of these topics,and I encourage you to check them out.We additionally made a pass throughout the entire frameworkto identify other placeswhere we can make improvements in Swift,and I'd like to show you a few of these now,starting with the kindsof different persistent stores that we support.Recall, persistent stores describehow you physically want to store your customers' data.Core Data currently provides four such stores:XML, binary,in-memory, and SQLite.And you use these identifiers all the time.New this year, we've gone aheadand gave these more natural names in Swift.The existing names will continue to work,but the new API that consumes thesewill be a lot more ergonomic to usedue to the shorter namesand ability to autocomplete these symbols.Of course, persistent stores are notthe only thing in Core Data that concerns itself with types.After all, the framework is all about storing typed data,and such types are described with attribute descriptions.And this year, we're addinga new extensible enumeration to attribute descriptionthat provides a much more natural syntaxfor working with their types.Let's take a look at these in actionby writing a unit test that can validate that our runtime modelmatches what we designed in the Xcode model builder.For simplicity, we'll just try to validatea single runtime type defined by our earthquake object model,but you can imagine how this would scale.This might seem like a small test to write,but it's a good thing to validateas it could speed up more interesting diagnosesin the future.To write this test,we'll write a quick helper functionin terms of the new attribute type.Let's go ahead and describe this function now.We'll start with the signature, which expects an attribute name,the entity description that we care about, and the type,described in terms of the new AttributeType enumeration.The definition of this utility is fairly straightforward.We first validate that we have an attributewith the provided name,failing the test if we can't find it.And then we validate that the typeof the attribute is as expected.And that's really all there is to it.We could repeat this for each entity and propertyand enjoy peace of mindthat our runtime behavior matches the model we defined.And this is just a samplingof some of the ergonomic improvements that we've madeto Core Data enumerations in Swift this year.Up till now, I've been focusingon a lot of lower-level framework interactionsand how they manifest in Swift,but what about presenting data to your users?In 2020, we introduced a number of conveniencesfor working with Core Data in SwiftUI.And now, my colleague, Scott,has quite a bit to share with youabout the new enhancements we are introducing this year.Scott?Thanks, Michael!There are a bunch of improvementsto the experience of using Core Datawith SwiftUI this year,starting with lazy entity resolution in fetch requests,which relaxes the requirementthat apps have their Core Data stacks set upbefore they construct their views.Also this year, fetch requests pick updynamic configuration for their sort descriptors and predicates.And there's a new kind of fetch request in townthat supports sectioned fetching.I'm going to walk through each of theseusing our Earthquakes sample appthat Michael mentioned earlier in the talk,starting with lazy entity resolution.Probably in your app,you have some code like this.This container property here isn't really necessaryto support the code in this type,or even the broader app.All that stuff gets what it needsfrom the QuakesProvider type directly.No, this property existsto make sure the Core Data stackhas been set up before any of the viewsin the environment try to refer to any entitiesbefore the model has been loaded.See herethat the environment view modifier is calledafter ContentView has been initialized.This trick isn't necessary anymorewhen deploying against this year's SDKs.The FetchRequest property wrapper now looks up entitiesby name lazily at fetch-time,at which point the environment has guaranteedthat the Core Data stack has been set up,so it's now safe to delete this property...And just refer to...the QuakesProvider shared containerdirectly in the environment call.Moving on to some new APIs,FetchRequest now supports dynamic configuration.There are two new properties on the wrapped valuefor directly changing the request's predicateas well as its sort descriptors,which are expressed bothwith the NSSortDescriptors that you're used toas well as a new SortDescriptor value typethat provides more convenience and safetywhen fetching entitieswith automatically generated managed object subclasses.And finally, there's a configuration bindingwith the same set of properties as the wrapped valuefor easier integration with views.Before this new API,I would've had to design my viewsso the sort and predicate parameterswere passed through a view's initializer,but that made it really trickyto support things like configuring my fetch requestusing controls in a toolbar.This friction is eliminatedby these new dynamic configuration properties,and I'd love to show you how to use themby adding sorting and filteringto the Earthquakes sample app.Let's look at sort descriptors first.By default, the Earthquakes app sorts by recency,but I'd also like to order them by magnitude,so I'm going to add a menuthat lets me control the results' order.I'll start by adding a static array of tuples...containing the sort descriptors I'd like to supportas well as names for them.See here that they're also using the new SortDescriptor type.I'll also want a bit of state to trackwhich sort order I am currently using.I've already created a type for this,so I'll add it as a property of the content view.Now I'll add a toolbar menu to the list view...That modifies the selected sortas well as an onChange modifierthat updates the fetch request's sort descriptors.Now in the preview, we can see the new menu,and I can use it to sort the earthquakes by magnitude.Great!Now to add filtering.I'd like to filter based on the earthquake's place.The first thing I needis some state for the search field's text.And I'll makea binding property...for the search field that updates the fetch request.With those in place, all I need is the UI.Conveniently...searchable takes a binding to a string,so we can just plop that right in here.Now in our preview, we can narrow downall the earthquakes near a place matching a sandwichby just typing "sandwich" in this new field here.And that's dynamic configuration for FetchRequest.Another commonly requested piece of functionalityis support for sectioned fetching,which arrives this year as a new property wrapper typecalled SectionedFetchRequest.This type supports the samenew dynamic configuration properties as FetchRequest,but it gets initialized with an additional parameter,a key path to a property that identifies the section,a lot like NSFetchedResultsController.But unlike the fetched results controller,the property that identifies the sectioncan have any type you like, so long as it's hashable.This gets encoded in the type systemusing an additional generic parameteron SectionedFetchRequest.Finally, this new type wrapsa two-dimensional result type.SectionedFetchResults is a collection of sections,each of which is itself a collection of results.Each section also has a property with the section identifier.This is really easy to adopt,so I'm going to add sectioned fetchingto the Earthquakes app.First, I update my FetchRequest declaration.Quake already has a property for day,so I'm going to use that for the sectioning key path.Next, I need to update the body property...To match the new sectioned results type.The outer loop here iterates over the sections,so I'm emitting a Section view here,and each section itself is a collection of Quakes,so this inner ForEach iterates over the section,just like I was iterating over the results before.If we look over at the preview, I've now got earthquakesordered by time and sectioned by day.And SwiftUI even gives me automatic supportfor collapsing sections.This new SectionedFetchRequest type supports the samedynamic configuration properties as FetchRequestas well as an additional configuration propertyfor the section identifier key path.This is super important because it's not actually safefor us to change the sorting anymore.It could cause the sections to be discontiguousbecause time and earthquake magnitudearen't perfectly correlated,which is probably for the best.To fix this, I need to update the sorts up top...so each has a corresponding section identifier key path.Next, down in the toolbar...I need to update the section identifier key patheach time I update the sort descriptors.But here's the important part.Changes to the request are committedwhenever the results getter is called,so to update both the sorting and the sectioning safely...I need to update the configuration on a referenceto the results that I've pulled into a local.Now in the preview,we can see that changing the orderalso changes the sectioning.We can flip between earthquakes ordered by time,sectioned by day,and earthquakes ordered and sectioned by magnitude.And there we have it: lazy stack initialization,dynamic configuration, and sectioned fetching,all easily applied to an existing appusing iOS 15 and macOS Monterey.So, to recap, Core Data is your one-stop shopfor managing your app's data persistence needsacross all of Apple's platforms.It harnesses the new concurrency featuresavailable in Swift through a new perform API,and still has powerful thread safety debugging built right in.It's got new enumeration interfaces that make storeand attribute types even more natural to use in Swift,plus CloudKit sharing and Spotlight integration.And it's easier than ever to connect your datato your views using SwiftUIwith dynamic configuration and sectioned fetching.There's lots more new stuff to learnrelated to these topics.We suggest checking out the collections"Simplify with SwiftUI and Meet Swift Concurrency."And that's it!I'm really looking forward to seeingwhat you all build with these new APIs.[upbeat music]

♪ ♪Hello, everybody.I'm Michael LeHew from the Core Data team.And today, I'm really excited to talk to youabout some of the enhancements the team has madeto make working with Core Data and Swifta truly excellent experience.I'm going to start with a reviewof how Core Data is a great solutionfor your customers’ data persistence needsacross all Apple platforms.I'll then follow up with a discussionon some of the ways that Core Data has adoptedthe new concurrency opportunitiesin the Swift runtime.Next, I'll cover some of the enhancementswe've made to Core Data APIsto make your code more expressive in Swift.And then conclude the discussion with an explorationof the dynamic capabilities that Core Data is addingto our existing SwiftUI supportthat we introduced in 2020.Let's start at the beginning, though,where regardless of which Apple platform you are developing for,you simply have an application.At some point, your applicationis going to eventually encounter user data,and you'll likely need to store it somewhere.A great choice for that needis to use Core Data.Core Data is Apple's hallmark frameworkfor application developers who desire to persisttheir users' data in a robust and feature-rich way.The framework takes care of many of the complexitiesof appropriately managing user data,from the way it was represented as an object graph in memoryto how it's modeled in storage.The framework also goes through great effortsto manage important runtime considerations,like memory use and latency.The capabilities provided by the framework are scalable too.You can start with a simple, locally-persisted storeand expand to use multiple execution contextsto improve performance, and even createpowerful shared data experiences through CloudKit.Core Data also works across all Apple-supported platforms.And I'd really like to emphasize this last point.Once you start using Core Data, everything you learn will workon each of our platforms, from your Mac,to your iPhone, or even your Apple Watch.

And, of course, Core Dataworks great in Swift too.Over the past few years,we've been continuing to enhance Core Data APIto be as expressive as possible in Swift.And this is a pretty exciting year for Swiftwith the introductionof the all-new concurrency featuresin the language and runtime.Since its inception,Core Data has always cared about running code concurrently,and there's a really good reason for this.Persisting data requires reading and writingto some external storage media,and this makes supporting the new concurrency modela natural fit.Let's explore how this works in the contextof our Earthquakes sample application.This application reads a data feedfrom the US Geological Surveyand uses Core Data to store informationabout recent earthquakes,such as their magnitude, location,and the date for which the event occurred.Architecturally, Earthquakes is a Swift applicationthat has a view context to drive the UIand a background contextto ingest the data provided by the USGS.Our sample has a local container for our applicationand gathers quake data from the USGS's JSON feed.

As we download data, we hand it off to our JSON parserand then import it into our background contextto be turned into managed objectsand saved to our local store.The view context then merges the changesto magically update our UI.In 2020, we focused on how to efficiently handle this datathrough the use of batch operations.Now, however, I'd like to focuson how we perform these operations concurrently.In particular,I'd like to focus on the three steps that we taketo import data into the application.Step one is to download the raw data,and upon successful download,the application needs to convert itto our specific local representation.And finally, save the new objectsinto the persistent store.Let's go ahead and convert this to high-level code.I've abstracted each operationinto its own function or closure.The app first retrieves the raw data from the server,processes it into a convenient local representation,and then imports the objects into Core Databy making a batch insert requeston the background managed object context.

Written like this, it is a bit easierto visualize potential bottlenecks.Loading data over the network would be a great opportunityto consider doing our work asynchronously.Converting might also be a place to consider.Additionally, importing the datainto our persistent store seems quite opportune.

Historically, though, in all of these cases,you would need to implementany such asynchronous mechanism yourselfor lean heavilyupon a framework-specific implementation.Let's talk about Core Data's specific abstraction.

In the case of Core Data, when you call performAndWait,the managed object contextwill execute the provided closurewithin its own protected execution environment.This can potentially tie up the calling threaduntil the work is complete.

If we were to visualize this,we can imagine three blocks of codewhich I've labeled BEFORE, DURING, and AFTER.

When our code runs,first the code labeled BEFORE gets a chance to executeon the originating thread.We then call performAndWait,and the calling thread will blockuntil the work that happens DURING the closure completes.When that work is done, the code described AFTER will execute.

Of course, if you don't need to waitfor the closure to finish,we've always offered a fully asynchronous variant.But new this year, Swift has gainedpowerful concurrency model with deep language integrationwhich allows Core Data to more accurately describethe intention of our API.The syntax is a bit different.You ask to await the results of the perform,but the mental model for using this new APIis exactly the samethat managed object has always supported.The benefit, however, is that the concurrencyis no longer a hidden implementation detail,but instead deeply integratedinto the Swift language.Because of this,the compiler can automatically preventmany common concurrency bugs,such as data races and deadlocks,and even efficiently make use of resourceswhen tasks are known to be awaiting results.Let's go back to the codeand see what using this in practice is like.

As we saw, you ask to await an async-declared function.This has the potentialto suspend the calling execution contextuntil the async function yields control by returning.

It also seamlessly workswith Swift's existing structured error handlingby routing any thrown errors to the calling frame,just as you would expect.Now that we've seen an exampleof calling an asynchronous function,let's take a look at how they're declaredby looking at Core Data's brand-new wayto perform asynchronous workwithin a managed object context.There is quite a bit of functionality packedinto this small stanza of Swift code,but I'm only gonna talk about a few important details,and then we'll jump into showinghow you can use it in practice.Starting with the declaration of the new perform overload.You can see it's genericbased on the kind of results that it can returnand is decorated with the new async keyword,which opts this functioninto the new concurrency capabilities in Swift.Perhaps the most significant facet of this new APIis that the provided closure now allows youto throw an error or return a value,saving you the effort of routing these backto the calling frame by hand.Let's see how cool this isby exploring a few different scenarios.Historically, since the concurrency was hidinginside of our implementation, one of the only waysto route errors outside of a performAndWaitwas to close over an optionaland then check it afterwards.This could be more complicated if you were usingthe fully asynchronous versions of performbecause you'd need to do a lot of plumbingby passing completion handlers aroundand making sure you used them consistently.With the new concurrency model in Swift,all of that plumbing is handled for you!Just try and await your asynchronous work,and if an error occurs, just throw it,and things will unwind to the calling frame naturally.

So now, we focused on errors,but what about results?Well, everything I've described works exactly the same.Let's look at a concrete example.

Let's sketch out what we wanna do before jumping into the code.For this example, I'd like to configurea fetch request to identify the number of earthquakesthat have happened in the last five hours.As a sentence,this is a straightforward task to describe.But in code, we're going to need to reorder things a bit.

We'll first need to figure out when five hours ago was,for which we can use the Calendar APIsto calculate this in a robust way.We'll then configure a fetch requestwith a predicate in terms of that dateand ask for a count result type.In code, it looks pretty much like our plan.We use Calendar's offset APIto calculate five hours before now,and then configure a Quake FetchRequestto return a count result with a predicatethat matches the dates that we care about.Historically, returning resultsfollowed a similar pattern to the way we captured errors.You would close over any state that you needed to mutate,perform your computations in the managed object context,and then later, use the result after regaining control.

Now, we can simply just tryand await the result of our perform calland return the result for perform directlyto our calling frame.The rest of the code is exactly the same.It's only the by-hand value routing that we avoidalong with any potential bugs or nuancesthat that code may have had.This new code is quite succinct and expressive.

It is worth mentioning, however,that there are times where you should be cautious.Let's look at a different example to see why.This example attempts to returnthe most recent earthquake as a managed object.While the new API makes it really easy to return values,it is not safe to return managed objectsthat are already registered to a managed object context.It is only valid to refer to such registered objectswithin the closure of a call to perform.Instead, if you need to refer to a managed objectbetween different execution contexts,either make use of the object ID and refetch as needed,or make use of the dictionary representation optionof the fetch request.Now before we look at one more example,I'd like to cover a detail that I haven't talked about yet.And that detail is the ScheduledTaskType.So far, every async perform that we have seenhas been in terms of the default value for this option:.immediate.There is a second option called .enqueued,and to understand the differencebetween these two scheduling approaches,it helps to think about what specifically happensinside a managed object contextwhen you ask to schedule work.As we've seen, .immediate behaves a lotlike a Swift-async-aware version of performAndWait.If you're running on a different execution contextand ask to await work performed on the background context,you will wait until it is scheduled and completed.

If you're already on the same execution context, however,the work will be optimistically scheduled right away.

.enqueued, on the other hand, is a bit simpler.It simply always just appends the requested workto the end of the contexts' work set,regardless of the affinity of the originating call site.Let's go ahead and look at one more example.All of these async featurescan be adopted by you as well.Here, I factored the import logicthat we have been talking aboutinto a new importQuakes function,decorated with the new async keyword.This function is, in turn,implemented in terms of other async functionality.

Now anyone can await upon this new functionto take advantage of the new concurrency features in Swift.Let's summarize what we've seen so far.Taken altogether, this new API brings the supportfor Swift's structured concurrencyright into Core Data.The new variants of the perform APIare just Swift concurrency-aware versionsof the existing Core Data APIyou already know and love.We strongly encourage you to take advantageof this new API in your applications.

Further, NSManagedObjectContext is notthe only type in Core Data that supports performing taskswithin its protected concurrency domain.We're also adding similar API to bothNSPersistentContainer and NSPersistentStoreCoordinator.The general shape and behavior of these APIs are quite similarto what I've already described.But with all that concurrent power,I would be remiss to not offer the adviceof using existing debugging toolsavailable at your disposal.Of course, the Xcode-providedaddress and thread sanitizers are incredibly helpfulfor catching bugs you might not even know existed.These can both be found in the Diagnostics paneof the scheme editor's Run settings.Each sanitizer detects different kinds of issues,including validating safe memory use assumptionsand appropriate use of data from multiple threads.It's always a good idea to qualify your applicationsand their associated tests with both sanitizersbefore you release your software to your community of users.

And while the sanitizers are useful in all contexts,I also wanna highlight that Core Dataprovides a special runtime flagthat you can enable to get more domain-specific help.By enabling this option, Core Data will turn on a numberof useful assertions to validate internal locksand confirm appropriate use of various Core Data types.

Adopting Swift concurrency supportis not the only change made to Core Data this year.Every new API that we are introducing,from CloudKit sharingto the new Spotlight integration,has been crafted with its presentationin Swift in mind.This year, we have a separate sessionfor each of these topics,and I encourage you to check them out.We additionally made a pass throughout the entire frameworkto identify other placeswhere we can make improvements in Swift,and I'd like to show you a few of these now,starting with the kindsof different persistent stores that we support.Recall, persistent stores describehow you physically want to store your customers' data.Core Data currently provides four such stores:XML, binary,in-memory, and SQLite.And you use these identifiers all the time.New this year, we've gone aheadand gave these more natural names in Swift.The existing names will continue to work,but the new API that consumes thesewill be a lot more ergonomic to usedue to the shorter namesand ability to autocomplete these symbols.Of course, persistent stores are notthe only thing in Core Data that concerns itself with types.After all, the framework is all about storing typed data,and such types are described with attribute descriptions.

And this year, we're addinga new extensible enumeration to attribute descriptionthat provides a much more natural syntaxfor working with their types.Let's take a look at these in actionby writing a unit test that can validate that our runtime modelmatches what we designed in the Xcode model builder.

For simplicity, we'll just try to validatea single runtime type defined by our earthquake object model,but you can imagine how this would scale.This might seem like a small test to write,but it's a good thing to validateas it could speed up more interesting diagnosesin the future.To write this test,we'll write a quick helper functionin terms of the new attribute type.Let's go ahead and describe this function now.We'll start with the signature, which expects an attribute name,the entity description that we care about, and the type,described in terms of the new AttributeType enumeration.

The definition of this utility is fairly straightforward.We first validate that we have an attributewith the provided name,failing the test if we can't find it.And then we validate that the typeof the attribute is as expected.And that's really all there is to it.We could repeat this for each entity and propertyand enjoy peace of mindthat our runtime behavior matches the model we defined.

And this is just a samplingof some of the ergonomic improvements that we've madeto Core Data enumerations in Swift this year.

Up till now, I've been focusingon a lot of lower-level framework interactionsand how they manifest in Swift,but what about presenting data to your users?In 2020, we introduced a number of conveniencesfor working with Core Data in SwiftUI.And now, my colleague, Scott,has quite a bit to share with youabout the new enhancements we are introducing this year.Scott?Thanks, Michael!There are a bunch of improvementsto the experience of using Core Datawith SwiftUI this year,starting with lazy entity resolution in fetch requests,which relaxes the requirementthat apps have their Core Data stacks set upbefore they construct their views.Also this year, fetch requests pick updynamic configuration for their sort descriptors and predicates.

And there's a new kind of fetch request in townthat supports sectioned fetching.I'm going to walk through each of theseusing our Earthquakes sample appthat Michael mentioned earlier in the talk,starting with lazy entity resolution.

Probably in your app,you have some code like this.This container property here isn't really necessaryto support the code in this type,or even the broader app.All that stuff gets what it needsfrom the QuakesProvider type directly.No, this property existsto make sure the Core Data stackhas been set up before any of the viewsin the environment try to refer to any entitiesbefore the model has been loaded.See herethat the environment view modifier is calledafter ContentView has been initialized.This trick isn't necessary anymorewhen deploying against this year's SDKs.The FetchRequest property wrapper now looks up entitiesby name lazily at fetch-time,at which point the environment has guaranteedthat the Core Data stack has been set up,so it's now safe to delete this property...

And just refer to...

the QuakesProvider shared containerdirectly in the environment call.Moving on to some new APIs,FetchRequest now supports dynamic configuration.There are two new properties on the wrapped valuefor directly changing the request's predicateas well as its sort descriptors,which are expressed bothwith the NSSortDescriptors that you're used toas well as a new SortDescriptor value typethat provides more convenience and safetywhen fetching entitieswith automatically generated managed object subclasses.

And finally, there's a configuration bindingwith the same set of properties as the wrapped valuefor easier integration with views.Before this new API,I would've had to design my viewsso the sort and predicate parameterswere passed through a view's initializer,but that made it really trickyto support things like configuring my fetch requestusing controls in a toolbar.This friction is eliminatedby these new dynamic configuration properties,and I'd love to show you how to use themby adding sorting and filteringto the Earthquakes sample app.Let's look at sort descriptors first.By default, the Earthquakes app sorts by recency,but I'd also like to order them by magnitude,so I'm going to add a menuthat lets me control the results' order.

I'll start by adding a static array of tuples...

containing the sort descriptors I'd like to supportas well as names for them.See here that they're also using the new SortDescriptor type.

I'll also want a bit of state to trackwhich sort order I am currently using.I've already created a type for this,so I'll add it as a property of the content view.Now I'll add a toolbar menu to the list view...

That modifies the selected sortas well as an onChange modifierthat updates the fetch request's sort descriptors.

Now in the preview, we can see the new menu,and I can use it to sort the earthquakes by magnitude.Great!Now to add filtering.I'd like to filter based on the earthquake's place.The first thing I needis some state for the search field's text.And I'll makea binding property...

for the search field that updates the fetch request.

With those in place, all I need is the UI.Conveniently...

searchable takes a binding to a string,so we can just plop that right in here.

Now in our preview, we can narrow downall the earthquakes near a place matching a sandwichby just typing "sandwich" in this new field here.

And that's dynamic configuration for FetchRequest.Another commonly requested piece of functionalityis support for sectioned fetching,which arrives this year as a new property wrapper typecalled SectionedFetchRequest.This type supports the samenew dynamic configuration properties as FetchRequest,but it gets initialized with an additional parameter,a key path to a property that identifies the section,a lot like NSFetchedResultsController.

But unlike the fetched results controller,the property that identifies the sectioncan have any type you like, so long as it's hashable.This gets encoded in the type systemusing an additional generic parameteron SectionedFetchRequest.Finally, this new type wrapsa two-dimensional result type.SectionedFetchResults is a collection of sections,each of which is itself a collection of results.Each section also has a property with the section identifier.

This is really easy to adopt,so I'm going to add sectioned fetchingto the Earthquakes app.First, I update my FetchRequest declaration.

Quake already has a property for day,so I'm going to use that for the sectioning key path.

Next, I need to update the body property...

To match the new sectioned results type.

The outer loop here iterates over the sections,so I'm emitting a Section view here,and each section itself is a collection of Quakes,so this inner ForEach iterates over the section,just like I was iterating over the results before.

If we look over at the preview, I've now got earthquakesordered by time and sectioned by day.And SwiftUI even gives me automatic supportfor collapsing sections.

This new SectionedFetchRequest type supports the samedynamic configuration properties as FetchRequestas well as an additional configuration propertyfor the section identifier key path.This is super important because it's not actually safefor us to change the sorting anymore.It could cause the sections to be discontiguousbecause time and earthquake magnitudearen't perfectly correlated,which is probably for the best.To fix this, I need to update the sorts up top...

so each has a corresponding section identifier key path.

Next, down in the toolbar...

I need to update the section identifier key patheach time I update the sort descriptors.

But here's the important part.Changes to the request are committedwhenever the results getter is called,so to update both the sorting and the sectioning safely...

I need to update the configuration on a referenceto the results that I've pulled into a local.

Now in the preview,we can see that changing the orderalso changes the sectioning.We can flip between earthquakes ordered by time,sectioned by day,and earthquakes ordered and sectioned by magnitude.

And there we have it: lazy stack initialization,dynamic configuration, and sectioned fetching,all easily applied to an existing appusing iOS 15 and macOS Monterey.

So, to recap, Core Data is your one-stop shopfor managing your app's data persistence needsacross all of Apple's platforms.It harnesses the new concurrency featuresavailable in Swift through a new perform API,and still has powerful thread safety debugging built right in.

It's got new enumeration interfaces that make storeand attribute types even more natural to use in Swift,plus CloudKit sharing and Spotlight integration.And it's easier than ever to connect your datato your views using SwiftUIwith dynamic configuration and sectioned fetching.

There's lots more new stuff to learnrelated to these topics.We suggest checking out the collections"Simplify with SwiftUI and Meet Swift Concurrency."And that's it!I'm really looking forward to seeingwhat you all build with these new APIs.[upbeat music]

20:36 -FetchRequest dynamic configuration: sort descriptors

21:33 -FetchRequest dynamic configuration: predicates

23:26 -SectionedFetchRequest

24:56 -SectionedFetchRequest dynamic configuration: sort descriptors

## Code Samples

```swift
private
 
let
 sorts 
=
 [(
    name: 
"Time"
,
    descriptors: [
SortDescriptor
(\
Quake
.time, order: .reverse)]
), (
    name: 
"Time"
,
    descriptors: [
SortDescriptor
(\
Quake
.time, order: .forward)]
), (
    name: 
"Magnitude"
,
    descriptors: [
SortDescriptor
(\
Quake
.magnitude, order: .reverse)]
), (
    name: 
"Magnitude"
,
    descriptors: [
SortDescriptor
(\
Quake
.magnitude, order: .forward)]
)]


struct
 
ContentView
: 
View
 
{
    
@FetchRequest
(sortDescriptors: [
SortDescriptor
(\
Quake
.time, order: .reverse)])
    
private
 
var
 quakes: 
FetchedResults
<
Quake
>

    
@State
 
private
 
var
 selectedSort 
=
 
SelectedSort
()

    
var
 body: 
some
 
View
 {
        
List
(quakes) { quake 
in

            
QuakeRow
(quake: quake)
        }
        .toolbar {
            
ToolbarItem
(placement: .primaryAction) {
                
SortMenu
(selection: 
$selectedSort
)
                .onChange(of: selectedSort) { 
_
 
in

                    
let
 sortBy 
=
 sorts[selectedSort.index]
                    quakes.sortDescriptors 
=
 sortBy.descriptors
                }
            }
        }
    }

    
struct
 
SelectedSort
: 
Equatable
 
{
        
var
 by 
=
 
0

        
var
 order 
=
 
0

        
var
 index: 
Int
 { by 
+
 order }
    }

    
struct
 
SortMenu
: 
View
 
{
        
@Binding
 
private
 
var
 selectedSort: 
SelectedSort


        
init
(
selection
: 
Binding
<
SelectedSort
>)
 {
            _selectedSort 
=
 selection
        }

        
var
 body: 
some
 
View
 {
            
Menu
 {
                
Picker
(
"Sort By"
, selection: 
$selectedSort
.by) {
                    
ForEach
(
Array
(
stride
(from: 
0
, to: sorts.count, by: 
2
)), id: \.
self
) { index 
in

                        
Text
(sorts[index].name).tag(index)
                    }
                }
                
Picker
(
"Sort Order"
, selection: 
$selectedSort
.order) {
                    
let
 sortBy 
=
 sorts[selectedSort.by 
+
 selectedSort.order]
                    
let
 sortOrders 
=
 sortOrders(for: sortBy.name)
                    
ForEach
(
0
..<
sortOrders.count, id: \.
self
) { index 
in

                        
Text
(sortOrders[index]).tag(index)
                    }
                }
            } label: {
                
Label
(
"More"
, systemImage: 
"ellipsis.circle"
)
            }
            .pickerStyle(
InlinePickerStyle
())
        }
        
        
private
 
func
 
sortOrders
(
for
 
name
: 
String
)
 -> [
String
] {
            
switch
 name {
            
case
 
"Magnitude"
:
                
return
 [
"Highest to Lowest"
, 
"Lowest to Highest"
]
            
case
 
"Time"
:
                
return
 [
"Newest on Top"
, 
"Oldest on Top"
]
            
default
:
                
return
 []
            }
        }
    }
}
```

```swift
struct
 
ContentView
: 
View
 
{
    
@FetchRequest
(sortDescriptors: [
SortDescriptor
(\
Quake
.time, order: .reverse)])
    
private
 
var
 quakes: 
FetchedResults
<
Quake
>

    
@State
 
private
 
var
 searchText 
=
 
""

    
var
 query: 
Binding
<
String
> {
        
Binding
 {
            searchText
        } 
set
: { newValue 
in

            searchText 
=
 newValue
            quakes.nsPredicate 
=
 newValue.isEmpty
                               
?
 
nil

                               : 
NSPredicate
(format: 
"place CONTAINS %@"
, newValue)
        }
    }

    
var
 body: 
some
 
View
 {
        
List
(quakes) { quake 
in

            
QuakeRow
(quake: quake)
        }
        .searchable(text: query)
    }
}
```

```swift
extension
 
Quake
 
{
    
lazy
 
var
 dateFormatter: 
DateFormatter
 
=
 {
        
let
 formatter 
=
 
DateFormatter
()
        formatter.dateFormat 
=
 
"MMMM d, yyyy"

        
return
 formatter
    }()

    
@objc
 
var
 day: 
String
 {
        
return
 dateFormatter.string(from: time)
    }
}


struct
 
ContentView
: 
View
 
{
    
@SectionedFetchRequest
(
        sectionIdentifier: \.day,
        sortDescriptors: [
SortDescriptor
(\
Quake
.time, order: .reverse)])
    
private
 
var
 quakes: 
SectionedFetchResults
<
String
, 
Quake
>

    
var
 body: 
some
 
View
 {
        
List
 {
            
ForEach
(quakes) { section 
in

                
Section
(header: 
Text
(section.id)) {
                    
ForEach
(section) { quake 
in

                        
QuakeRow
(quake: quake)
                    }
                }
            }
        }
    }
}
```

```swift
extension
 
Quake
 
{
    
lazy
 
var
 dateFormatter: 
DateFormatter
 
=
 {
        
let
 formatter 
=
 
DateFormatter
()
        formatter.dateFormat 
=
 
"MMMM d, yyyy"

        
return
 formatter
    }()

    
@objc
 
var
 day: 
String
 {
        
return
 dateFormatter.string(from: time)
    }
  
    
@objc
 
var
 magnitude_str: 
String
 {
        
return
 
"
\(magnitude)
"

    }
}


private
 
let
 sorts 
=
 [(
    name: 
"Time"
,
    descriptors: [
SortDescriptor
(\
Quake
.time, order: .reverse)],
    section: \
Quake
.day
), (
    name: 
"Time"
,
    descriptors: [
SortDescriptor
(\
Quake
.time, order: .forward)],
    section: \
Quake
.day
), (
    name: 
"Magnitude"
,
    descriptors: [
SortDescriptor
(\
Quake
.magnitude, order: .reverse)],
    section: \
Quake
.magnitude_str
), (
    name: 
"Magnitude"
,
    descriptors: [
SortDescriptor
(\
Quake
.magnitude, order: .forward)],
    section: \
Quake
.magnitude_str
)]


struct
 
ContentView
: 
View
 
{
    
@SectionedFetchRequest
(
        sectionIdentifier: \.day,
        sortDescriptors: [
SortDescriptor
(\
Quake
.time, order: .reverse)])
    
private
 
var
 quakes: 
SectionedFetchResults
<
String
, 
Quake
>

    
@State
 
private
 
var
 selectedSort 
=
 
SelectedSort
()

    
var
 body: 
some
 
View
 {
        
List
 {
            
ForEach
(quakes) { section 
in

                
Section
(header: 
Text
(section.id)) {
                    
ForEach
(section) { quake 
in

                        
QuakeRow
(quake: quake)
                    }
                }
            }
        }
        .toolbar {
            
ToolbarItem
(placement: .primaryAction) {
                
SortMenu
(selection: 
$selectedSort
)
                .onChange(of: selectedSort) { 
_
 
in

                    
let
 sortBy 
=
 sorts[selectedSort.index]
                    
let
 config 
=
 quakes
                    config.sectionIdentifier 
=
 sortBy.section
                    config.sortDescriptors 
=
 sortBy.descriptors
                }
            }
        }
    }

    
struct
 
SelectedSort
: 
Equatable
 
{
        
var
 by 
=
 
0

        
var
 order 
=
 
0

        
var
 index: 
Int
 { by 
+
 order }
    }

    
struct
 
SortMenu
: 
View
 
{
        
@Binding
 
private
 
var
 selectedSort: 
SelectedSort


        
init
(
selection
: 
Binding
<
SelectedSort
>)
 {
            _selectedSort 
=
 selection
        }

        
var
 body: 
some
 
View
 {
            
Menu
 {
                
Picker
(
"Sort By"
, selection: 
$selectedSort
.by) {
                    
ForEach
(
Array
(
stride
(from: 
0
, to: sorts.count, by: 
2
)), id: \.
self
) { index 
in

                        
Text
(sorts[index].name).tag(index)
                    }
                }
                
Picker
(
"Sort Order"
, selection: 
$selectedSort
.order) {
                    
let
 sortBy 
=
 sorts[selectedSort.by 
+
 selectedSort.order]
                    
let
 sortOrders 
=
 sortOrders(for: sortBy.name)
                    
ForEach
(
0
..<
sortOrders.count, id: \.
self
) { index 
in

                        
Text
(sortOrders[index]).tag(index)
                    }
                }
            } label: {
                
Label
(
"More"
, systemImage: 
"ellipsis.circle"
)
            }
            .pickerStyle(
InlinePickerStyle
())
        }
        
        
private
 
func
 
sortOrders
(
for
 
name
: 
String
)
 -> [
String
] {
            
switch
 name {
            
case
 
"Magnitude"
:
                
return
 [
"Highest to Lowest"
, 
"Lowest to Highest"
]
            
case
 
"Time"
:
                
return
 [
"Newest on Top"
, 
"Oldest on Top"
]
            
default
:
                
return
 []
            }
        }
    }
}
```


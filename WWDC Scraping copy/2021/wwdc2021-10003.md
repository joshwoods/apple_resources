# Wwdc2021 10003

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

There and back again: Data transfer on Apple WatchAdvances in Apple Watch give you more ways to communicate to and from your app, and new audiences to consider. Learn what strategies are available for data communication and how to choose the right tool for the job. Compare and contrast the benefits of using technologies such as iCloud Keychain, Watch Connectivity, Core Data, and more.ResourcesDownloading files from websitesKeeping your complications up to dateKeeping your watchOS content up to dateSharing access to keychain items among a collection of appsSupporting Associated DomainsWCSessionHD VideoSD VideoRelated VideosWWDC21Bring Core Data concurrency to Swift and SwiftUIBuild apps that share data through CloudKit and Core DataWWDC20AutoFill everywhereKeep your complications up to dateWWDC19Streaming Audio on watchOS 6

Advances in Apple Watch give you more ways to communicate to and from your app, and new audiences to consider. Learn what strategies are available for data communication and how to choose the right tool for the job. Compare and contrast the benefits of using technologies such as iCloud Keychain, Watch Connectivity, Core Data, and more.

Downloading files from websites

Keeping your complications up to date

Keeping your watchOS content up to date

Sharing access to keychain items among a collection of apps

Supporting Associated Domains

WCSession

HD VideoSD Video

HD Video

SD Video

Bring Core Data concurrency to Swift and SwiftUI

Build apps that share data through CloudKit and Core Data

AutoFill everywhere

Keep your complications up to date

Streaming Audio on watchOS 6

Search this videoâ€¦- Hi! Welcome to WWDC.My name is Anne Hitchcock,and I'm an engineer on the Watch Frameworks team.I'm excited to be here todayto talk about data transfer strategies on Apple Watch.Since its introduction,Apple Watch has become increasingly independent.Series 3 was the first Apple Watch availablewith cellular capability.Independent Watch Apps in watchOS 6gave you the ability to write appsthat didn't require an iOS companionand could be purchased from the App Storeon your customers' Watches.With the introduction of Family Setup in watchOS 7,your customers have more independence than ever,without having a companion iPhone.But these new capabilities present us,as developers,new challenges in the way we think about communicatingwith our Watch apps.Fortunately, we have lots of great options.Today we're going to talk about those optionsand how we pick the right one for the job.I'm going to give you an overview of toolswe have for data communication in Watch appsand discuss how to evaluate which one will bethe right choice for your task.We can broadly group the tools into a few categories.iCloud allows us to share with all our devicesand gives us server storage.We can use this in our appsusing Keychain with iCloud Synchronizationand CoreData with CloudKit.If we need to transfer data between paired devices,we can use Watch Connectivity.To communicate directly with servers,we can use URL sessions or sockets.But first, we'll talk aboutthe questions you can askto pick the right one.When I think about how I'm going to communicatefrom my Watch app, I think about a few things.What kind of data is it?And where is the data now, and where do I need it to be?Is the interaction reliant on a companion iOS app?Do I want to support Family Setup?And when does the data need to be at its destination?Can it wait to let the system optimize performanceand battery usage for my customer?How frequently is the data going to change?Based on my answers to these questions,I can start going through my toolboxto evaluate how to craft the right solutionfor my data transfer task.Let's look at what capabilitieswe get from the Keychain with iCloud Synchronization.Keychain provides secure storage for passwords,keys, and other sensitive credentials.And with iCloud Keychain Synchronization,introduced in watchOS 6.2,these keychain items can be synchronizedto all of a person's devices.There are two ways you can benefitfrom iCloud Synchronization in your app:by using Password autofill with Associated Domainsand Shared Keychain items.Password autofill allows you to use Keychain synchronizationwith very little code.First, add the Associated Domains capabilityto your target.For your Watch app,add the capability to the WatchKit Extension Target.Add a webcredentials entry with your domain name.Add the apple-app-site-association fileto your web server.The file must be accessible via HTTPS without redirects.The file is JSON format with no file extension,and it should be placed in the./well-known directory on your server.Check out the documentation onlinefor "Supporting Associated Domains" for complete details.Add text content typesto your text fields and secure fields.Your options for autofill areusername, email address, password, and new password.For new passwords,the system will prompt the person to save,and a record will be added or updatedin the Keychain for your site.AutoFill suggestions have been availablesince watchOS 6.2and are even betterwith the new text-editing experience in watchOS 8.For more information about using password autofill,check out the "Autofill everywhere" sessionin the Developer app or online.Another way you can share datausing Keychain synchronizationis by sharing Keychain items among your apps.As we discussed,the Keychain is secure storage for sensitive data,like passwords, keys, and credentials.You can also store other small bits of shared datain the Keychain,such as a person's preference for a startup screen,as long as the information isn't changing frequently.The data stored in the Keychainwill be synchronized to all of the person's devices.Let's look at how we can store and retrievean OAuth 2 token in the Keychain,and share that with a group of our apps.First, we need to add the Keychain Sharingor App Groups capability,all the apps we want to share these keychain items.This is required to share the items,and helps ensure the security and privacyof your customers' informationby preventing access by other apps.For your Watch app,add the capability to your Watch Extension target.In this example,I'm going to add the Keychain Sharing capabilityand add my app to a Keychain Group.All of my apps that are going to sharethe Keychain items need to also share this group.Now, let's look at the codeto store an OAuth 2 token in the Keychain.To store a token,we'll update the item if it exists,and add it if it doesn't.I've created an OAuth 2 token structto contain the token data,like the token string, expiration, and refresh token.I made the token struct conform to codableto make it easy to store and retrieve.We create a query dictionary.This is the set of attributes that match an existing itemif we already have one saved for this server and account.Note the synchronizable attribute herethat is set to "true."It's important that we include this attribute in our queryto indicate that we want our item to synchronizeto all of our customer's devices.We'll encode the token as data,and set that Data as the value for our Keychain itemin the attributes dictionary.Then, update the item in the Keychainwith the query and attributes.We always need to check the result codereturned from the Keychain API.We'll first check to seeif the Keychain said that the item was not found.If so, we'll call another function we wroteto add it to the Keychain.We'll look at that in a moment.Otherwise, we'll make sure there was no error.To do that, we check for the success result.If the update function returned success,then our token was updated in the Keychain.Now, let's look at the add function.To add the token to the Keychain,we'll set up a dictionary with all the attributes.This includes the attributeswe used to find an existing item,plus the token data.Then, we'll call the Keychain API'sadd function with the attributes.And check the return codeto make sure it succeeded.To retrieve the token information from the Keychain,we'll set up a query dictionary to find the item we want.We'll include the same set of keys and values we includedto find the item before in the update function.Plus, we include some attributesto tell the Keychain APIwhether we want the item attributes returned(we don't)and whether we want the item data returned(we do).The Keychain "copy matching" functionsearches using our queryand populates the reference we provided as "item."Before we try to access the retrieved item,we'll check the return code to ensure it was found.Then, as always,we check the return code for success.Get the dictionary that was copied for the item,get the token data we requested from the dictionary,and decode the data as our OAuth 2 token type.And now, we've successfully saved, updated,and retrieved an OAuth 2 token to the Keychain,and it's shared with all the appsin our Keychain Sharing Group.There's one more Keychain storage functionI want to share with you.Just like anywhere that you store somethingon your customers' devices,you should remove it when you're done with it.We'll set up our querywith our now-familiar attributes to search.Call the Keychain API's delete function with our query.And, as always, check for success.In the case of delete, not found is successful.Now, we finish cleaning up after we're done with the data.Keychain services with iCloud Keychain synchronizationare a great way for your app to share small pieces of datathat don't change frequently,and that data will be synchronizedto all of a person's devices.Use Associated Domains to easily addpassword autofill functionality to your app.You can also store and retrieve valuesdirectly to the Keychainand share them with your other appsusing Keychain Sharing or App Groups.iCloud Keychain Synchronizationdoesn't rely on having an iOS companion app,and it supports Family Setup.The items are synchronized when possiblebased on network availability, battery,and other system conditions.Be aware that customerscan disable iCloud Keychain synchronizationand that it isn't available in all regions.CoreData with CloudKitsynchronizes your local databaseto all of your customer's other devicesthat share your app's CloudKit container.CoreData integration with SwiftUIsimplifies accessing and displaying datafrom your database in your Watch application.You can quickly get too much dataon a Watch this wayif you're developing a multi-platform application.Think carefullyabout what information your customerreally needs on their Watch.Consider using multiple configurationsin your Core Data modelto segment data that makes sense to have in your Watch appfrom data that is appropriate for your apprunning on a devicewith more storage and battery capacity.CloudKit and Core Data are powerful tools.The integration of Core Data with SwiftUImakes it easier to use Core Data features in your apps.You can provide the managed object context"to your Views with the environment value,and use the fetch request property wrapperto get results from your database.Those results can be used in SwiftUI Listsand other views.Core Data with CloudKit provides uswith a way to share structured datathat can be synchronized to all of a person's devicesand backed up on iCloud.It doesn't rely on having a companion iPhone appand does support Family Setup.Synchronization of Core Data changeshappens based on network availabilityand system conditions.Don't expect it to be instantaneous,but CloudKit will handle optimizing performanceof this synchronization for your app.To learn more about using Core Data with CloudKitin your app, check out"Build apps that share data through CloudKit and Core Data"and "Bring Core Data concurrency to Swift and SwiftUI"in the Developer app or online.You might already be familiar with Watch Connectivity,and you might have used it before.But I'd like to give you more detailsand some best practices to help you be successful.Watch Connectivity allows you to send databetween your Watch app and its companion iPhone appwhen both devices are within Bluetooth rangeor on the same Wi-Fi network.It's best used for optimizing your customer's experiencewhen they have both your phone and Watch apps installed,and for sharing data that is only available on one device.For example, if someone has launched your iPhone appand has downloaded the latest data,you can share that data with your Watch appto keep your complications currentand allow your Watch app to startwith that same datathe next time it launches.This will feel more responsive for your customersand minimizes the duplicate data downloadsyour apps need to do.Watch Connectivity has a diverse set of features,so it's helpful to know what's availableand when to use each one.But first, I want to share a few tipsto help you succeedif you decide that Watch Connectivityis the right tool for your task.Since Watch Connectivity is a tool to communicatebetween two devices,it's going to require us to knowabout a few preconditionsand handle some errors.These are some things you can do to ensureyour Watch Connectivity communication works smoothly.Activate your watch connectivity sessionas early in your app life cycle as possible,preferably when your app finishes launchingin your app or extension delegate.This makes your app available to receive informationfrom its counterpart app as soon as possible.Understand reachability.None of the background communicationrequires your counterpart appto be reachable when you send data.But interactive messagingdoes have reachability requirements,and we'll discuss them then.It will save you time to understand them.All of the watch connectivity session delegate functionsare called on a non-main serial queue.If you need to do any work from these functionsto update your user interface,make sure you do that on the main queue.Now, let's talk about the differentWatch Connectivity featuresand when to use each one.The application contextis a single property list dictionarythat is sent to the counterpart appin the background,with the goal of being availablewhen the app wakes up.If you update the application contextbefore the previous dictionary is sent,it is replaced by the new value.Application context is useful for keeping contentup to date on the counterpart appwhen you have new data,and for data that may update frequently.User info transferalso sends a property list dictionaryto the counterpart app in the background,but it's a little different than application context.Instead of being a single dictionarythat is replaced each time you update it,each user info dictionary transferis queued and deliveredin the order that you enqueued it.You can also access the queueto cancel a transfer.File transfer is similar to user info transfer,and once you've done one, the other will feel familiar.Files are queued to be sent to the counterpart app,and sent when power and other conditions permit.You can access the queue to cancel a transfer.The files are placed in the document inboxfor the receiving app when they are transferred.Each file will be deleted from the inbox when you returnfrom the did receive file callback in your session delegate.Make sure you move the fileor otherwise quickly process itbefore you return from this method.One helpful thing to remember about this:since this callback is calledon a non-main serial queue,if you call an async method to process the filefrom the inbox,you will most likely run into a problembecause the file will be gone.The timing of file transfersis based on system conditions,and, of course,larger files may take longer to transfer.transferCurrentComplicationUserInfo(_:)is a special case of the user info transfer functionalityto send complication-related data to the Watch.It's transferred as soon as possible,ahead of other user info transfers,as long as you have complication transfersremaining in your budget.This immediate transferallows you to keep your active complications currentfor your customers when you have updated data from your phone.You can check your remaining budget,and if you transfer current complication infowith no remaining budget, it will still be sent.It will just use the normal user info transfer queue.You can use sendMessageto send data to your counterpart appand get a reply.This is for interactive messagingwhen your counterpart app is reachable.Whether you're sending a dictionary or data,keep your messages small.We also recommend that you opt to include a reply handlerfor your sendMessage calls.A short reply allows you to verifythat the counterpart app did receive the messageand that the data was correct.When you include that reply handleron your sendMessage,also make sure you implementthe version of the did receive messageor did receive data delegate callback functionin the counterpart app that includes a reply handler.Otherwise, you'll get an error when you send the message.Now that we've heard about sendMessage,let's revisit the concept of reachability.Both of your apps need to be reachableto send messages.You can check the isReachable propertyon the Watch Connectivity sessionto determine if your counterpart app is reachablefor live, non-background messaging.But what does it mean to be reachable?Both devices need to be within range of each othervia Bluetooth or on the same Wi-Fi network.For the WatchKit Extension to be reachable,it must be either running in the foregroundor running in the background with a high priority,as it does when performinglong-running background sessions.The iOS app doesn't have this foreground requirement.If you send a message from your Watch appto your iOS app,and your iOS app is not in the foreground,your iOS app will be activatedin the background to receive the message.This means that your iOS appis reachable from your Watch Extensionfar more of the time than vice versa.Watch Connectivity is a good wayto provide your customers with an experiencethat feels timely, responsive, and intuitivewhen they have installed both your iPhone and Watch apps.Since Watch Connectivity is specifically communicatingbetween a phone and a paired Watch,don't use it to support apps for Family Setup.Data transfer is dependenton the availability of the companion devicevia Bluetooth or Wi-Fi.Real-time communication using sendMessagerequires the counterpart to be reachable.Remember that your counterpart appwon't be reachable a lot of the time,especially when you're trying to communicateto your Watch app.Background transfers aren't delivered immediately.Think of them like posting a letter:you drop it in the box,but you're not sure exactly when it's going to be there.For more information about Watch Connectivity,check out "Introducing Watch Connectivity"in the Developer app or online.Now, we're going to talk about a couple of waysto communicate directly with servers.For most use cases,the best option is URL sessions.Depending on the interaction and type of data,you might be able to defer communicationor might need to do it right away.So, we have different configurations for URL sessionsto allow them to be run in the background or foreground.Let's look at when you should use each of these options.You should use background sessions wherever possible.This might not be our first instinctas developers,where we might want to just go aheadand get or send data right away.But really think about it.Foreground sessions need to completewhile your app is in the foregroundor front-most,and for all but the shortest tasks,this isn't enough time.Think about your customers' experienceif their communication task fails.So, please be considerate of your customersand carefully evaluate each communication taskand ask, "Can I do this in the background?"Background URL sessions are the right choicefor any time communication can be delayedand for large data transfers.You can also send a push notificationto your app to indicate that new data is availableand initiate a background update.The exact timing of your background transferwill depend on system conditions.Let's walk through an example of sending some datato a server in the background.For example,if I have some settings for my applicationthat I want to store through my web server,when my customer saves those,I can save them on the Watchand then send them to the server in the background.To do that, I've made a background URL session classto handle the work of the server communication.Our URL session will have a background configurationwith a unique identifier we can use to find it later.Set the sends launch events property to trueto indicate that the sessionshould launch your app in the backgroundwhen tasks on your session need to be handled.Note that if you're transferring a large amount of data,you should set the isDiscretionary propertyof the URL session configuration to trueto let the system schedule the transferat an optimal time for the device for best performance.In this case,you should also let your customers knowthat their downloads might not happenuntil they're connected to Wi-Fi and power.When we're ready to send the data,we need to enqueue the transferto schedule the background session.We'll create and configure a URL requestwith the contents for our Settings update to our server.Then, we'll create a task for our request on the session.In this simplified example,I'm only adding one task to my session,but you can add multiple requeststo your session for efficiency.Set the earliestBeginDate to start the download later.Note that the system will determine the actual timeour task starts based on background budget,network, and system conditions.Your app can receiveup to four background refresh tasks per hour,if you have a complication on the active watch face,so schedule your tasks at least 15 minutes apartto prevent them from being delayed by the system.I'm holding on to this sessionin a list of in-progress sessions.This will become important later,when the system lets me knowthat my URL request has completed.Calling "resume" on the task actually starts it,so it's important that you call this.Finally, I set my status to queuedin case there are observers for the session.The system will notify our appwhen our background request has been processedusing a background task sent to our Extension Delegate.In order for us to handle that task,we need to create a class that conformsto WK extension delegateand implement the handle(_ backgroundTasks:) function.For Background URL Session Refresh tasks,we'll try to find our sessionin our list of in-progress requests.If we have it, we'll call a function on the sessionto add the background refresh taskto the list for the session,so we can let the system know we've completed itas soon as we've finished processing the data.I'll show you this in a moment.If we don't find the session in our list,we need to mark the task as completed.It is very important that you always setyour background refresh task completedas soon as you're done.There's one more thing we need to doto get our background task calls:we need to connect our extension delegate to our App.To do thiswe're going to use the WK extension delegate adaptorproperty wrapperwith our Extension Delegate class,and add a property to our app.Now, the system will call our extension delegateto handle our background tasks.In our extension delegate,we called this function to add our background taskto our existing session.Add this task to our list of background tasksso we can mark it completedas soon as we're done processing the URL data.Now, we've wired up the whole round trip,and all we have left to do is get our dataand let the system know we're done.Our URL session download delegatewill get called when our request completes.Process the data received in the file from the download task.It's important that you either move this iteminto a directory accessible to your appor quickly process the data from the file.When this task completes,the downloaded file will be deleted.We're removing this session from the list of in-process sessions,since we won't get any more background tasks for itfrom the extension delegate,and we're setting the status to completedin case there are any observers.Finally, we're setting our background task completed.This lets the system knowwe've completed our background processing.Making sure you do thisisn't just being a good Watch app citizen.It prevents the system from terminating your appfor exceeding its background limits.And that's it!We're all done sending our settingsin the background and getting any updates.Note that in a full implementation,you'll want to handle errors and authentication challenges,but this gives you the basic steps.Use foreground URL sessions for quick server communicationwhile a person is interacting with your app.A good example of thisis getting the latest workout listor the meditation of the day.Foreground URL sessions are a less-power-efficient wayto get and send data,and a two-and-a-half minute timeout is enforced.But in practice, you should try to target foreground sessionsto interactions that are much quicker than that limit.URL sessions are the best methodfor general purpose communicationdirectly with servers.They don't rely on a companion iPhone app,and you can use them with apps supporting Family Setup.Use background sessionsfor anywhere you can possibly delay the data transfer,and always for transferring larger amounts of data.To learn more about URL sessions,check out "Keep your complications up to date"and "Background execution demystified"in the Developer app or online.In addition to URL sessions,if you're building a streaming audio app,sockets are another option to communicatedirectly with servers.You can use HTTP Live Streamingor Web Sockets in Watch appsin the context of your active streaming audio session.For more information on using Sockets, check outthe "Streaming Audio on watchOS 6" sessionin the Developer app or online.We've covered a lot,so let's summarize how we can choosefrom among all the options we've seen.For small pieces of sensitive datathat can be synced to all a person's devices,choose Keychain with iCloud Synchronization.To store databases in iCloudand share with all a person's devices,choose Core Data with CloudKit.To optimize the experience for companion iPhone and Watch apps,or to share data that is available only on one devicein companion apps, choose Watch Connectivity.To communicate directly with servers,choose URL sessions.For streaming audio apps, you can also use sockets.To support customers who are using Family Setupor to use cellular data transfer,make sure you choose Keychain with iCloud Synchronization,Core Data with CloudKit,URL sessions, or sockets.Think about the type of data,its source and destination,and your customer audiencebefore choosing a solutionto help you pick the right tool for the job.And always test your app on devices,not connected to the debugger, before you deploy itto verify its behavior in real-world conditions.Thank you for comingto learn about all the great toolswe have for data transfer in your Watch apps.We can't wait to see what you build next.[music]

- Hi! Welcome to WWDC.My name is Anne Hitchcock,and I'm an engineer on the Watch Frameworks team.I'm excited to be here todayto talk about data transfer strategies on Apple Watch.

Since its introduction,Apple Watch has become increasingly independent.Series 3 was the first Apple Watch availablewith cellular capability.

Independent Watch Apps in watchOS 6gave you the ability to write appsthat didn't require an iOS companionand could be purchased from the App Storeon your customers' Watches.With the introduction of Family Setup in watchOS 7,your customers have more independence than ever,without having a companion iPhone.But these new capabilities present us,as developers,new challenges in the way we think about communicatingwith our Watch apps.Fortunately, we have lots of great options.Today we're going to talk about those optionsand how we pick the right one for the job.

I'm going to give you an overview of toolswe have for data communication in Watch appsand discuss how to evaluate which one will bethe right choice for your task.We can broadly group the tools into a few categories.

iCloud allows us to share with all our devicesand gives us server storage.We can use this in our appsusing Keychain with iCloud Synchronizationand CoreData with CloudKit.

If we need to transfer data between paired devices,we can use Watch Connectivity.

To communicate directly with servers,we can use URL sessions or sockets.But first, we'll talk aboutthe questions you can askto pick the right one.

When I think about how I'm going to communicatefrom my Watch app, I think about a few things.

What kind of data is it?And where is the data now, and where do I need it to be?Is the interaction reliant on a companion iOS app?Do I want to support Family Setup?And when does the data need to be at its destination?Can it wait to let the system optimize performanceand battery usage for my customer?How frequently is the data going to change?Based on my answers to these questions,I can start going through my toolboxto evaluate how to craft the right solutionfor my data transfer task.

Let's look at what capabilitieswe get from the Keychain with iCloud Synchronization.

Keychain provides secure storage for passwords,keys, and other sensitive credentials.And with iCloud Keychain Synchronization,introduced in watchOS 6.2,these keychain items can be synchronizedto all of a person's devices.

There are two ways you can benefitfrom iCloud Synchronization in your app:by using Password autofill with Associated Domainsand Shared Keychain items.

Password autofill allows you to use Keychain synchronizationwith very little code.First, add the Associated Domains capabilityto your target.For your Watch app,add the capability to the WatchKit Extension Target.Add a webcredentials entry with your domain name.

Add the apple-app-site-association fileto your web server.The file must be accessible via HTTPS without redirects.The file is JSON format with no file extension,and it should be placed in the./well-known directory on your server.Check out the documentation onlinefor "Supporting Associated Domains" for complete details.Add text content typesto your text fields and secure fields.Your options for autofill areusername, email address, password, and new password.For new passwords,the system will prompt the person to save,and a record will be added or updatedin the Keychain for your site.

AutoFill suggestions have been availablesince watchOS 6.2and are even betterwith the new text-editing experience in watchOS 8.

For more information about using password autofill,check out the "Autofill everywhere" sessionin the Developer app or online.

Another way you can share datausing Keychain synchronizationis by sharing Keychain items among your apps.

As we discussed,the Keychain is secure storage for sensitive data,like passwords, keys, and credentials.You can also store other small bits of shared datain the Keychain,such as a person's preference for a startup screen,as long as the information isn't changing frequently.The data stored in the Keychainwill be synchronized to all of the person's devices.

Let's look at how we can store and retrievean OAuth 2 token in the Keychain,and share that with a group of our apps.

First, we need to add the Keychain Sharingor App Groups capability,all the apps we want to share these keychain items.This is required to share the items,and helps ensure the security and privacyof your customers' informationby preventing access by other apps.For your Watch app,add the capability to your Watch Extension target.In this example,I'm going to add the Keychain Sharing capabilityand add my app to a Keychain Group.All of my apps that are going to sharethe Keychain items need to also share this group.

Now, let's look at the codeto store an OAuth 2 token in the Keychain.To store a token,we'll update the item if it exists,and add it if it doesn't.I've created an OAuth 2 token structto contain the token data,like the token string, expiration, and refresh token.I made the token struct conform to codableto make it easy to store and retrieve.We create a query dictionary.This is the set of attributes that match an existing itemif we already have one saved for this server and account.

Note the synchronizable attribute herethat is set to "true."It's important that we include this attribute in our queryto indicate that we want our item to synchronizeto all of our customer's devices.We'll encode the token as data,and set that Data as the value for our Keychain itemin the attributes dictionary.Then, update the item in the Keychainwith the query and attributes.

We always need to check the result codereturned from the Keychain API.We'll first check to seeif the Keychain said that the item was not found.If so, we'll call another function we wroteto add it to the Keychain.We'll look at that in a moment.Otherwise, we'll make sure there was no error.To do that, we check for the success result.If the update function returned success,then our token was updated in the Keychain.

Now, let's look at the add function.To add the token to the Keychain,we'll set up a dictionary with all the attributes.This includes the attributeswe used to find an existing item,plus the token data.Then, we'll call the Keychain API'sadd function with the attributes.And check the return codeto make sure it succeeded.

To retrieve the token information from the Keychain,we'll set up a query dictionary to find the item we want.We'll include the same set of keys and values we includedto find the item before in the update function.Plus, we include some attributesto tell the Keychain APIwhether we want the item attributes returned(we don't)and whether we want the item data returned(we do).The Keychain "copy matching" functionsearches using our queryand populates the reference we provided as "item."Before we try to access the retrieved item,we'll check the return code to ensure it was found.

Then, as always,we check the return code for success.Get the dictionary that was copied for the item,get the token data we requested from the dictionary,and decode the data as our OAuth 2 token type.And now, we've successfully saved, updated,and retrieved an OAuth 2 token to the Keychain,and it's shared with all the appsin our Keychain Sharing Group.

There's one more Keychain storage functionI want to share with you.Just like anywhere that you store somethingon your customers' devices,you should remove it when you're done with it.We'll set up our querywith our now-familiar attributes to search.Call the Keychain API's delete function with our query.And, as always, check for success.In the case of delete, not found is successful.Now, we finish cleaning up after we're done with the data.

Keychain services with iCloud Keychain synchronizationare a great way for your app to share small pieces of datathat don't change frequently,and that data will be synchronizedto all of a person's devices.Use Associated Domains to easily addpassword autofill functionality to your app.

You can also store and retrieve valuesdirectly to the Keychainand share them with your other appsusing Keychain Sharing or App Groups.iCloud Keychain Synchronizationdoesn't rely on having an iOS companion app,and it supports Family Setup.The items are synchronized when possiblebased on network availability, battery,and other system conditions.

Be aware that customerscan disable iCloud Keychain synchronizationand that it isn't available in all regions.

CoreData with CloudKitsynchronizes your local databaseto all of your customer's other devicesthat share your app's CloudKit container.CoreData integration with SwiftUIsimplifies accessing and displaying datafrom your database in your Watch application.

You can quickly get too much dataon a Watch this wayif you're developing a multi-platform application.Think carefullyabout what information your customerreally needs on their Watch.

Consider using multiple configurationsin your Core Data modelto segment data that makes sense to have in your Watch appfrom data that is appropriate for your apprunning on a devicewith more storage and battery capacity.

CloudKit and Core Data are powerful tools.The integration of Core Data with SwiftUImakes it easier to use Core Data features in your apps.You can provide the managed object context"to your Views with the environment value,and use the fetch request property wrapperto get results from your database.Those results can be used in SwiftUI Listsand other views.Core Data with CloudKit provides uswith a way to share structured datathat can be synchronized to all of a person's devicesand backed up on iCloud.It doesn't rely on having a companion iPhone appand does support Family Setup.Synchronization of Core Data changeshappens based on network availabilityand system conditions.Don't expect it to be instantaneous,but CloudKit will handle optimizing performanceof this synchronization for your app.

To learn more about using Core Data with CloudKitin your app, check out"Build apps that share data through CloudKit and Core Data"and "Bring Core Data concurrency to Swift and SwiftUI"in the Developer app or online.

You might already be familiar with Watch Connectivity,and you might have used it before.But I'd like to give you more detailsand some best practices to help you be successful.

Watch Connectivity allows you to send databetween your Watch app and its companion iPhone appwhen both devices are within Bluetooth rangeor on the same Wi-Fi network.It's best used for optimizing your customer's experiencewhen they have both your phone and Watch apps installed,and for sharing data that is only available on one device.

For example, if someone has launched your iPhone appand has downloaded the latest data,you can share that data with your Watch appto keep your complications currentand allow your Watch app to startwith that same datathe next time it launches.This will feel more responsive for your customersand minimizes the duplicate data downloadsyour apps need to do.Watch Connectivity has a diverse set of features,so it's helpful to know what's availableand when to use each one.But first, I want to share a few tipsto help you succeedif you decide that Watch Connectivityis the right tool for your task.Since Watch Connectivity is a tool to communicatebetween two devices,it's going to require us to knowabout a few preconditionsand handle some errors.These are some things you can do to ensureyour Watch Connectivity communication works smoothly.Activate your watch connectivity sessionas early in your app life cycle as possible,preferably when your app finishes launchingin your app or extension delegate.This makes your app available to receive informationfrom its counterpart app as soon as possible.

Understand reachability.None of the background communicationrequires your counterpart appto be reachable when you send data.But interactive messagingdoes have reachability requirements,and we'll discuss them then.It will save you time to understand them.

All of the watch connectivity session delegate functionsare called on a non-main serial queue.If you need to do any work from these functionsto update your user interface,make sure you do that on the main queue.

Now, let's talk about the differentWatch Connectivity featuresand when to use each one.The application contextis a single property list dictionarythat is sent to the counterpart appin the background,with the goal of being availablewhen the app wakes up.If you update the application contextbefore the previous dictionary is sent,it is replaced by the new value.

Application context is useful for keeping contentup to date on the counterpart appwhen you have new data,and for data that may update frequently.User info transferalso sends a property list dictionaryto the counterpart app in the background,but it's a little different than application context.Instead of being a single dictionarythat is replaced each time you update it,each user info dictionary transferis queued and deliveredin the order that you enqueued it.You can also access the queueto cancel a transfer.

File transfer is similar to user info transfer,and once you've done one, the other will feel familiar.Files are queued to be sent to the counterpart app,and sent when power and other conditions permit.You can access the queue to cancel a transfer.

The files are placed in the document inboxfor the receiving app when they are transferred.Each file will be deleted from the inbox when you returnfrom the did receive file callback in your session delegate.Make sure you move the fileor otherwise quickly process itbefore you return from this method.

One helpful thing to remember about this:since this callback is calledon a non-main serial queue,if you call an async method to process the filefrom the inbox,you will most likely run into a problembecause the file will be gone.The timing of file transfersis based on system conditions,and, of course,larger files may take longer to transfer.

transferCurrentComplicationUserInfo(_:)is a special case of the user info transfer functionalityto send complication-related data to the Watch.It's transferred as soon as possible,ahead of other user info transfers,as long as you have complication transfersremaining in your budget.This immediate transferallows you to keep your active complications currentfor your customers when you have updated data from your phone.You can check your remaining budget,and if you transfer current complication infowith no remaining budget, it will still be sent.It will just use the normal user info transfer queue.

You can use sendMessageto send data to your counterpart appand get a reply.This is for interactive messagingwhen your counterpart app is reachable.Whether you're sending a dictionary or data,keep your messages small.We also recommend that you opt to include a reply handlerfor your sendMessage calls.A short reply allows you to verifythat the counterpart app did receive the messageand that the data was correct.When you include that reply handleron your sendMessage,also make sure you implementthe version of the did receive messageor did receive data delegate callback functionin the counterpart app that includes a reply handler.Otherwise, you'll get an error when you send the message.

Now that we've heard about sendMessage,let's revisit the concept of reachability.Both of your apps need to be reachableto send messages.You can check the isReachable propertyon the Watch Connectivity sessionto determine if your counterpart app is reachablefor live, non-background messaging.But what does it mean to be reachable?Both devices need to be within range of each othervia Bluetooth or on the same Wi-Fi network.For the WatchKit Extension to be reachable,it must be either running in the foregroundor running in the background with a high priority,as it does when performinglong-running background sessions.The iOS app doesn't have this foreground requirement.If you send a message from your Watch appto your iOS app,and your iOS app is not in the foreground,your iOS app will be activatedin the background to receive the message.

This means that your iOS appis reachable from your Watch Extensionfar more of the time than vice versa.

Watch Connectivity is a good wayto provide your customers with an experiencethat feels timely, responsive, and intuitivewhen they have installed both your iPhone and Watch apps.Since Watch Connectivity is specifically communicatingbetween a phone and a paired Watch,don't use it to support apps for Family Setup.

Data transfer is dependenton the availability of the companion devicevia Bluetooth or Wi-Fi.Real-time communication using sendMessagerequires the counterpart to be reachable.Remember that your counterpart appwon't be reachable a lot of the time,especially when you're trying to communicateto your Watch app.Background transfers aren't delivered immediately.Think of them like posting a letter:you drop it in the box,but you're not sure exactly when it's going to be there.

For more information about Watch Connectivity,check out "Introducing Watch Connectivity"in the Developer app or online.Now, we're going to talk about a couple of waysto communicate directly with servers.For most use cases,the best option is URL sessions.Depending on the interaction and type of data,you might be able to defer communicationor might need to do it right away.So, we have different configurations for URL sessionsto allow them to be run in the background or foreground.Let's look at when you should use each of these options.

You should use background sessions wherever possible.This might not be our first instinctas developers,where we might want to just go aheadand get or send data right away.

But really think about it.Foreground sessions need to completewhile your app is in the foregroundor front-most,and for all but the shortest tasks,this isn't enough time.Think about your customers' experienceif their communication task fails.

So, please be considerate of your customersand carefully evaluate each communication taskand ask, "Can I do this in the background?"Background URL sessions are the right choicefor any time communication can be delayedand for large data transfers.You can also send a push notificationto your app to indicate that new data is availableand initiate a background update.The exact timing of your background transferwill depend on system conditions.Let's walk through an example of sending some datato a server in the background.For example,if I have some settings for my applicationthat I want to store through my web server,when my customer saves those,I can save them on the Watchand then send them to the server in the background.

To do that, I've made a background URL session classto handle the work of the server communication.

Our URL session will have a background configurationwith a unique identifier we can use to find it later.Set the sends launch events property to trueto indicate that the sessionshould launch your app in the backgroundwhen tasks on your session need to be handled.

Note that if you're transferring a large amount of data,you should set the isDiscretionary propertyof the URL session configuration to trueto let the system schedule the transferat an optimal time for the device for best performance.

In this case,you should also let your customers knowthat their downloads might not happenuntil they're connected to Wi-Fi and power.

When we're ready to send the data,we need to enqueue the transferto schedule the background session.We'll create and configure a URL requestwith the contents for our Settings update to our server.

Then, we'll create a task for our request on the session.In this simplified example,I'm only adding one task to my session,but you can add multiple requeststo your session for efficiency.Set the earliestBeginDate to start the download later.Note that the system will determine the actual timeour task starts based on background budget,network, and system conditions.Your app can receiveup to four background refresh tasks per hour,if you have a complication on the active watch face,so schedule your tasks at least 15 minutes apartto prevent them from being delayed by the system.

I'm holding on to this sessionin a list of in-progress sessions.This will become important later,when the system lets me knowthat my URL request has completed.

Calling "resume" on the task actually starts it,so it's important that you call this.

Finally, I set my status to queuedin case there are observers for the session.The system will notify our appwhen our background request has been processedusing a background task sent to our Extension Delegate.In order for us to handle that task,we need to create a class that conformsto WK extension delegateand implement the handle(_ backgroundTasks:) function.For Background URL Session Refresh tasks,we'll try to find our sessionin our list of in-progress requests.If we have it, we'll call a function on the sessionto add the background refresh taskto the list for the session,so we can let the system know we've completed itas soon as we've finished processing the data.I'll show you this in a moment.

If we don't find the session in our list,we need to mark the task as completed.It is very important that you always setyour background refresh task completedas soon as you're done.There's one more thing we need to doto get our background task calls:we need to connect our extension delegate to our App.To do thiswe're going to use the WK extension delegate adaptorproperty wrapperwith our Extension Delegate class,and add a property to our app.Now, the system will call our extension delegateto handle our background tasks.In our extension delegate,we called this function to add our background taskto our existing session.Add this task to our list of background tasksso we can mark it completedas soon as we're done processing the URL data.Now, we've wired up the whole round trip,and all we have left to do is get our dataand let the system know we're done.Our URL session download delegatewill get called when our request completes.Process the data received in the file from the download task.It's important that you either move this iteminto a directory accessible to your appor quickly process the data from the file.When this task completes,the downloaded file will be deleted.We're removing this session from the list of in-process sessions,since we won't get any more background tasks for itfrom the extension delegate,and we're setting the status to completedin case there are any observers.

Finally, we're setting our background task completed.This lets the system knowwe've completed our background processing.Making sure you do thisisn't just being a good Watch app citizen.It prevents the system from terminating your appfor exceeding its background limits.And that's it!We're all done sending our settingsin the background and getting any updates.Note that in a full implementation,you'll want to handle errors and authentication challenges,but this gives you the basic steps.Use foreground URL sessions for quick server communicationwhile a person is interacting with your app.A good example of thisis getting the latest workout listor the meditation of the day.Foreground URL sessions are a less-power-efficient wayto get and send data,and a two-and-a-half minute timeout is enforced.But in practice, you should try to target foreground sessionsto interactions that are much quicker than that limit.URL sessions are the best methodfor general purpose communicationdirectly with servers.They don't rely on a companion iPhone app,and you can use them with apps supporting Family Setup.Use background sessionsfor anywhere you can possibly delay the data transfer,and always for transferring larger amounts of data.

To learn more about URL sessions,check out "Keep your complications up to date"and "Background execution demystified"in the Developer app or online.

In addition to URL sessions,if you're building a streaming audio app,sockets are another option to communicatedirectly with servers.You can use HTTP Live Streamingor Web Sockets in Watch appsin the context of your active streaming audio session.

For more information on using Sockets, check outthe "Streaming Audio on watchOS 6" sessionin the Developer app or online.

We've covered a lot,so let's summarize how we can choosefrom among all the options we've seen.

For small pieces of sensitive datathat can be synced to all a person's devices,choose Keychain with iCloud Synchronization.To store databases in iCloudand share with all a person's devices,choose Core Data with CloudKit.To optimize the experience for companion iPhone and Watch apps,or to share data that is available only on one devicein companion apps, choose Watch Connectivity.To communicate directly with servers,choose URL sessions.For streaming audio apps, you can also use sockets.To support customers who are using Family Setupor to use cellular data transfer,make sure you choose Keychain with iCloud Synchronization,Core Data with CloudKit,URL sessions, or sockets.

Think about the type of data,its source and destination,and your customer audiencebefore choosing a solutionto help you pick the right tool for the job.And always test your app on devices,not connected to the debugger, before you deploy itto verify its behavior in real-world conditions.Thank you for comingto learn about all the great toolswe have for data transfer in your Watch apps.We can't wait to see what you build next.[music]

4:20 -Password Autofill

6:25 -Store Item in Keychain

7:59 -Add Item to Keychain

8:25 -Retrieve Item from Keychain

9:39 -Remove Item from Keychain

11:59 -Core Data SwiftUI View

23:04 -Background URL Session Configuration

24:22 -Enqueue the background data transfer

25:45 -WatchKit Extension Delegate

26:43 -Connect the WatchKit Extension Delegate to the App

27:07 -Store the Background Refresh Task it can be completed

27:31 -Process Downloaded Data

## Code Samples

```swift
struct
 
LoginView
: 
View
 
{
    
    
@State
 
private
 
var
 username 
=
 
""

    
@State
 
private
 
var
 password 
=
 
""

    
    
var
 body: 
some
 
View
 {
        
Form
 {
            
TextField
(
"User:"
, text: 
$username
)
                .textContentType(.username)
            
            
SecureField
(
"Password"
, text: 
$password
) 
                .textContentType(.password)
            
            
Button
 {
                processLogin()
            } label: {
                
Text
(
"Login"
)
            }
            
            
Button
(role: .cancel) {
                cancelLogin()
            } label: {
                
Label
(
"Cancel"
, systemImage: 
"xmark.circle"
)
            }
        }
    }
    
    
private
 
func
 
cancelLogin
()
 {
        
// Implement your cancel logic here

    }
    
    
private
 
func
 
processLogin
()
 {
        
// Implement your login logic here

    }
}
```

```swift
func
 
storeToken
(
_
 
token
: 
OAuth2Token
, 
for
 
server
: 
String
, 
account
: 
String
)
 
throws
 {
    
let
 query: [
String
: 
Any
] 
=
 [
      kSecClass 
as
 
String
: kSecClassInternetPassword,
      kSecAttrServer 
as
 
String
: server,
      kSecAttrAccount 
as
 
String
: account,
      kSecAttrSynchronizable 
as
 
String
: 
true
,
    ]
    
    
let
 tokenData 
=
 
try
 encodeToken(token)
    
let
 attributes: [
String
: 
Any
] 
=
 [kSecValueData 
as
 
String
: tokenData]
    
    
let
 status 
=
 
SecItemUpdate
(query 
as
 
CFDictionary
, attributes 
as
 
CFDictionary
)
    
    
guard
 status 
!=
 errSecItemNotFound 
else
 {
        
try
 addTokenData(tokenData, for: server, account: account)
        
return

    }
    
    
guard
 status 
==
 errSecSuccess 
else
 {
        
throw
 
OAuthKeychainError
.updateError(status)
    }
}
```

```swift
func
 
addTokenData
(
_
 
tokenData
: 
Data
,
                  
for
 
server
: 
String
,
                  
account
: 
String
)
 
throws
 {
    
let
 attributes: [
String
: 
Any
] 
=
 [
      kSecClass 
as
 
String
: kSecClassInternetPassword,
      kSecAttrServer 
as
 
String
: server,
      kSecAttrAccount 
as
 
String
: account,
      kSecAttrSynchronizable 
as
 
String
: 
true
,
      kSecValueData 
as
 
String
: tokenData,
    ]
    
    
let
 status 
=
 
SecItemAdd
(attributes 
as
 
CFDictionary
, 
nil
)
    
    
guard
 status 
==
 errSecSuccess 
else
 {
        
throw
 
OAuthKeychainError
.addError(status)
    }
}
```

```swift
func
 
retrieveToken
(
for
 
server
: 
String
, 
account
: 
String
)
 
throws
 -> 
OAuth2Token
? {
    
let
 query: [
String
: 
Any
] 
=
 [
      kSecClass 
as
 
String
: kSecClassInternetPassword,
      kSecAttrServer 
as
 
String
: server,
      kSecAttrAccount 
as
 
String
: account,
      kSecAttrSynchronizable 
as
 
String
: 
true
,
      kSecReturnAttributes 
as
 
String
: 
false
,
      kSecReturnData 
as
 
String
: 
true
,
    ]
        
    
var
 item: 
CFTypeRef
?
    
let
 status 
=
 
SecItemCopyMatching
(query 
as
 
CFDictionary
,
                                     
&
item)
        
    
guard
 status 
!=
 errSecItemNotFound 
else
 {
        
// No token stored for this server account combination.

        
return
 
nil

    }
    
    
guard
 status 
==
 errSecSuccess 
else
 {
        
throw
 
OAuthKeychainError
.retrievalError(status)
    }
    
    
guard
 
let
 existingItem 
=
 item 
as?
 [
String
 : 
Any
] 
else
 {
        
throw
 
OAuthKeychainError
.invalidKeychainItemFormat
    }
    
    
guard
 
let
 tokenData 
=
 existingItem[kSecValueData 
as
 
String
] 
as?
 
Data
 
else
 {
        
throw
 
OAuthKeychainError
.missingTokenDataFromKeychainItem
    }
    
    
do
 {
        
return
 
try
 
JSONDecoder
().decode(
OAuth2Token
.
self
, from: tokenData)
    } 
catch
 {
        
throw
 
OAuthKeychainError
.tokenDecodingError(error.localizedDescription)
    }
}
```

```swift
func
 
removeToken
(
for
 
server
: 
String
, 
account
: 
String
)
 
throws
 {
    
let
 query: [
String
: 
Any
] 
=
 [
      kSecClass 
as
 
String
: kSecClassInternetPassword,
      kSecAttrServer 
as
 
String
: server,
      kSecAttrAccount 
as
 
String
: account,
      kSecAttrSynchronizable 
as
 
String
: 
true
,
    ]
  
    
let
 status 
=
 
SecItemDelete
(query 
as
 
CFDictionary
)
    
    
guard
 status 
==
 errSecSuccess 
||
 status 
==
 errSecItemNotFound 
else
 {
        
throw
 
OAuthKeychainError
.deleteError(status)
    }
}
```

```swift
import
 CoreData

import
 SwiftUI


struct
 
CoreDataView
: 
View
 
{
    
    
@Environment
(\.managedObjectContext) 
private
 
var
 viewContext
    
    
@FetchRequest
(
        sortDescriptors: [
NSSortDescriptor
(keyPath: \
Setting
.itemKey, ascending: 
true
)],
        animation: .easeIn)
    
private
 
var
 settings: 
FetchedResults
<
Setting
>
    
    
var
 body: 
some
 
View
 {
        
List
 {
            
ForEach
(settings) { setting 
in

                
SettingRow
(setting)
            }
        }
    }
}
```

```swift
class
 
BackgroundURLSession
: 
NSObject
, 
ObservableObject
, 
Identifiable
 
{
    
private
 
let
 sessionIDPrefix 
=
 
"com.example.backgroundURLSessionID."

    
    
enum
 
Status
 
{
        
case
 notStarted
        
case
 queued
        
case
 inProgress(
Double
)
        
case
 completed
        
case
 failed(
Error
)
    }
    
    
private
 
var
 url: 
URL


    
/// Data to send with the URL request.

    
///

    
/// If this is set, the HTTP method for the request will be POST

    
var
 body: 
Data
?
    
    
/// Optional content type for the URL request

    
var
 contentType: 
String
?
    
    
private(set)
 
var
 id 
=
 
UUID
()
    
    
/// The current status of the session

    
@Published
 
var
 status 
=
 
Status
.notStarted
    
    
/// The downloaded data (populated when status == .completed)

    
@Published
 
var
 downloadedURL: 
URL
?
    
    
private
 
var
 backgroundTasks 
=
 [
WKURLSessionRefreshBackgroundTask
]()
    
    
private
 
lazy
 
var
 urlSession: 
URLSession
 
=
 {
        
let
 config 
=
 
URLSessionConfiguration
.background(withIdentifier: sessionID)
            
// Set isDiscretionary = true if you are sending or receiving large 

            
// amounts of data. Let Watch users know that their transfers might 

            
// not start until they are connected to Wi-Fi and power.

            config.isDiscretionary 
=
 
false

            config.sessionSendsLaunchEvents 
=
 
true

            
return
 
URLSession
(configuration: config,
                              delegate: 
self
, delegateQueue: 
nil
)
        }()
    
    
private
 
var
 sessionID: 
String
 {
        
"
\(sessionIDPrefix)
\(id.uuidString)
"

    }
    
    
/// Initialize the session

    
/// - Parameter url: The URL for the Background URL Request

    
init
(
url
: 
URL
)
 {
        
self
.url 
=
 url
        
super
.
init
()
    }

}
```

```swift
// This is a member of the BackgroundURLSession class in the example. 


// Enqueue the URLRequest to send in the background. 


func
 
enqueueTransfer
()
 {
    
var
 request 
=
 
URLRequest
(url: url)
    request.httpBody 
=
 body
    
if
 body 
!=
 
nil
 {
        request.httpMethod 
=
 
"POST"

    }
    
if
 
let
 contentType 
=
 contentType {
        request.setValue(contentType, forHTTPHeaderField: 
"Content-type"
)
    }
    
let
 task 
=
 urlSession.downloadTask(with: request)
    task.earliestBeginDate 
=
 nextTaskStartDate
  
    
BackgroundURLSessions
.sharedInstance().sessions[sessionID] 
=
 
self

  
    task.resume()
    status 
=
 .queued
}
```

```swift
class
 
ExtensionDelegate
: 
NSObject
, 
WKExtensionDelegate
 
{
    
    
func
 
applicationDidFinishLaunching
()
 {
        
// For Watch Connectivity, activate your WCSession as early as possible

        
WatchConnectivityModel
.shared.activateSession()
    }
    
    
func
 
applicationDidBecomeActive
()
 {
        
// Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.

    }
    
    
func
 
applicationWillResignActive
()
 {
        
// Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.

        
// Use this method to pause ongoing tasks, disable timers, etc.

    }
    
    
func
 
handle
(
_
 
backgroundTasks
: 
Set
<
WKRefreshBackgroundTask
>)
 {
        
// Sent when the system needs to launch the application in the background to process tasks. Tasks arrive in a set, so loop through and process each one.

        
for
 task 
in
 backgroundTasks {
            
// Use a switch statement to check the task type

            
switch
 task {
            
case
 
let
 backgroundTask 
as
 
WKApplicationRefreshBackgroundTask
:
                
// Be sure to complete the background task once youâ€™re done.

                backgroundTask.setTaskCompletedWithSnapshot(
false
)
            
case
 
let
 snapshotTask 
as
 
WKSnapshotRefreshBackgroundTask
:
                
// Snapshot tasks have a unique completion call, make sure to set your expiration date

                snapshotTask.setTaskCompleted(restoredDefaultState: 
true
, estimatedSnapshotExpiration: 
Date
.distantFuture, userInfo: 
nil
)
            
case
 
let
 connectivityTask 
as
 
WKWatchConnectivityRefreshBackgroundTask
:
                
// Be sure to complete the connectivity task once youâ€™re done.

                connectivityTask.setTaskCompletedWithSnapshot(
false
)
            
case
 
let
 urlSessionTask 
as
 
WKURLSessionRefreshBackgroundTask
:
                
if
 
let
 session 
=
 
BackgroundURLSessions
.sharedInstance()
                        .sessions[urlSessionTask.sessionIdentifier] {
                    session.addBackgroundRefreshTask(urlSessionTask)
                } 
else
 {
                    
// There is no model for this session, just set it complete

                    urlSessionTask.setTaskCompletedWithSnapshot(
false
)
                }
            
case
 
let
 relevantShortcutTask 
as
 
WKRelevantShortcutRefreshBackgroundTask
:
                
// Be sure to complete the relevant-shortcut task once you're done.

                relevantShortcutTask.setTaskCompletedWithSnapshot(
false
)
            
case
 
let
 intentDidRunTask 
as
 
WKIntentDidRunRefreshBackgroundTask
:
                
// Be sure to complete the intent-did-run task once you're done.

                intentDidRunTask.setTaskCompletedWithSnapshot(
false
)
            
default
:
                
// make sure to complete unhandled task types

                task.setTaskCompletedWithSnapshot(
false
)
            }
        }
    }
}
```

```swift
@main


struct
 
MyWatchApp
: 
App
 
{
    
    
@WKExtensionDelegateAdaptor
(
ExtensionDelegate
.
self
) 
var
 extensionDelegate
    
    
@SceneBuilder
 
var
 body: 
some
 
Scene
 {
        
WindowGroup
 {
            
NavigationView
 {
                
ContentView
()
            }
        }
    }
}
```

```swift
// This is a member of the BackgroundURLSession class in the example. 


// Add the Background Refresh Task to the list so it can be set to completed when the URL task is done.


func
 
addBackgroundRefreshTask
(
_
 
task
: 
WKURLSessionRefreshBackgroundTask
)
 {
    backgroundTasks.append(task)
}
```

```swift
extension
 
BackgroundURLSession
 : 
URLSessionDownloadDelegate
 
{
    
    
private
 
func
 
saveDownloadedData
(
_
 
downloadedURL
: 
URL
)
 {
        
// Move or quickly process this file before you return from this function.

        
// The file is in a temporary location and will be deleted.

    }
    
    
func
 
urlSession
(
_
 
session
: 
URLSession
,
                    
downloadTask
: 
URLSessionDownloadTask
,
                    
didFinishDownloadingTo
 
location
: 
URL
)
 {
        saveDownloadedData(location)
      
        
// We don't need more updates on this session, so let it go.

        
BackgroundURLSessions
.sharedInstance().sessions[sessionID] 
=
 
nil

      
        
DispatchQueue
.main.async {
            
self
.status 
=
 .completed
        }
        
        
for
 task 
in
 backgroundTasks {
            task.setTaskCompletedWithSnapshot(
false
)
        }
    }
}
```


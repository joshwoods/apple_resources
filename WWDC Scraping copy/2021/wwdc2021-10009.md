# Wwdc2021 10009

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Build a workout app for Apple WatchBuild a workout app from scratch using SwiftUI and HealthKit during this code along. Learn how to support the Always On state using timelines to update workout metrics. Follow best design practices for workout apps.ResourcesBuild a workout app for Apple WatchHD VideoSD VideoRelated VideosWWDC23Build a multi-device workout appWWDC21What's new in SwiftUIWhat's new in watchOS 8

Build a workout app from scratch using SwiftUI and HealthKit during this code along. Learn how to support the Always On state using timelines to update workout metrics. Follow best design practices for workout apps.

Build a workout app for Apple Watch

HD VideoSD Video

HD Video

SD Video

Build a multi-device workout app

What's new in SwiftUI

What's new in watchOS 8

Search this video…♪ Bass music playing ♪♪Brady White: Hi, I’m Brady.I’m an engineer on the Fitness team.Thanks for joining me.There are lots of great workout apps already availablein the App Store.Apple Watch is an amazing devicecapable of tracking all sorts of fitness activity.It can track distance and elevationon those challenging bike rides.You can monitor your heart rate and energy burnedduring intense workouts.For swimming, it can even detect stroke type and count laps.All of this and more is available for youto build a great workout app.Let’s take a look at what we will be covering today.This session is a Code-Along.We'll go over what that means and how you can participate.We'll build our workout views in SwiftUI.Then, we'll integrate HealthKit to our views.We'll also show you how to support the Always On state.I'm excited, let's get started.This session is a code-along.We will build a workout app together from scratch.While you get your Xcode ready,let's cover a couple of concepts.What is a workout app?A workout app tracks fitness activityduring a workout.A workout can be started with a single tap.While the workout is in session, live metrics are displayed,such as elapsed time, energy burned, heart rate,and distance.When the workout ends,a summary shows the metrics recorded for the workout.This is what we will build today.Let’s get started building our workout views.Let’s open Xcode and start a new project.Click Create a new Xcode project,watchOS, Watch App,click Next.Give your workout app a name, such as "MyWorkouts".Ensure Interface is SwiftUI, and language is Swiftand click Next.Find a location for your project and click Create.Let’s hide the inspector and resize our canvas.Let’s click Resume to see what our app looks like,using Xcode previews.Great, our SwiftUI app is ready.Let’s provide a way for someone to start their workoutwith a StartView.A workout can be started with just a single tap.The list view with carousel-style layoutwill provide a list of workouts that scrolls verticallywith a great depth effect.Our list of workouts will include bike, run, and walk.Let’s create our StartView.Let’s rename "ContentView" to "StartView".Command-click on ContentView,click Rename,Enter "StartView" as the new name.Notice that in MyWorkoutsApp.swiftStartView is now NavigationView’s root view.Click Rename.Let’s define an array of workout typesto display in our StartView’s list.First, let’s import HealthKitto get access to HKWorkoutActivityType.Next, let’s add our array of workout types.Our workout list will have HKWorkoutActivityTypesof cycling, running, and walking.Let’s make HKWorkoutActivityTypeaccessible to our listby extending the HKWorkoutActivityType enumto conform to the identifiable protocoland add a name variable.The ID-computed variable will return the rawValue of the enum.The name variable will switch through the casesto return a name like “Run”, “Bike”, or “Walk”.Let’s add a List view to our StartView’s bodyto display the list of workouts.The list uses the workoutTypes variable as its model.A NavigationLink is displayed for each workoutType.A NavigationLink defines a destinationfor a navigation-based interface.For now, the destination will be a text view.We'll set these navigation links up laterto make sure they are tracking the right workout.Padding makes the navigation links tallerto give them a larger tap area to easily start a workout.The list uses a carousel listStyleto provide a depth effect when scrolling.The navigationBarTitle will display “Workouts”.Let’s click Resume to see a preview of our StartView.Click Live Preview to be able to scroll.Scroll up to see the carousel ListStyle depth effect.Looks great.The workout session will be presented as a modal experience.During a workout, people typically needonly session-specific functionality.They don't need to review the list of workoutsor access other parts of your app.Offering the most important items in a modal experiencecan help people manage their sessionwhile minimizing distraction.People who use workout apps on Apple Watchexpect the views to be in this order.On the left, our controls view has buttonsthat control the in-progress sessionsuch as End, Pause, and Resume.In the center, metrics appear on a dedicated screenthat people can read at a glance.On the right, media playback controlsallow media to be controlled during a workout.A TabView on watchOS switches between multiple child viewswhen someone swipes left or right.A TabView also provides a page indicatorat the bottom of the view.A TabView will work great to display our in-session views.Let’s create a SessionPagingView with a TabViewfor our three workout session views.Click File > New > File...SwiftUI View, click Next,name this "SessionPagingView" and click Create.Let’s create a Tab enum to model each view that can be selectedin our TabView.The Tab enum has three cases:controls, metrics, and nowPlaying.We’ve also added a @State variable named "selection"to provide the binding for the TabView’s selection.Selection’s default value will be metrics,so that when the workout starts, the metrics view is displayed.Let’s add the TabView.The TabView’s selection parameter uses a bindingto our selection state variable.Text views are placeholders for each viewuntil they are created.Each of the views have a tag so they can be selected.Let’s click Resumeand see what our SessionPagingView looks like.Click Live Preview to be able to swipe between the views.Notice the Metrics text view is displayed first,because SessionPagingView's selection variable'sdefault value is metrics.Swiping to the left shows the Controls text view.Swiping all the way to the rightshows the Now Playing text view.Great!While the workout is running, live metrics are displayed.When a session requires movement, like running,your app should use large font sizes and arrange textso that the most important information is easy to read.Our MetricsView will display elapsed time, active energy,current heart rate, and distance.HealthKit has many more HKQuantityTypesavailable for you to use.Let’s create the MetricsView.Click File > New > FileSwiftUI View, click Next,name this "MetricsView" and click Create.A VStack will contain our four metric Text views.The Text views have default values for nowuntil we connect these Text views to our model.Let’s make elapsed time the focal point by giving ita yellow foregroundColor and semibold fontWeight.The active energy text view creates a measurementusing a default value in energy unit kilocalories.The Measurement uses a new formatted functionwhich abbreviates the unit,usage is workout for workout energy burned,and numberFormat has zero fractionLengthto trim fractions.The heart rate text view uses a default valueformatted with fractionLength zero.It appends “bpm” -- for beats per minute --to the formatted string.The distance text view uses a default valuewith UnitLength.meters.The measurement is formatted with abbreviated units.usage is road, which displays naturally progressingimperial or metric units based on locale.We’ll use a system font of title with rounded design,monospacedDigits, and lowercaseSmallCaps.We want our metrics to be aligned to the leading edge,so we’ve given the VStack a frame view modifierwith maxWidth infinity, and leading alignment.We want to allow content of this VStackto extend all the way to the bottom of the screen.To allow this, we ignore the bottom safe area.We want our metrics to be alignedto the navigation bar title,so we've used scenePadding() to do this.We want our elapsed time Text viewto format the elapsed time properlyand hide or show subseconds based on the Always On state.To do this, let’s create an ElapsedTimeViewand create a custom ElapsedTimeFormatter.Click File > New > File,SwiftUI View, click Next,name it "ElapsedTimeView", and click Create.Our ElapsedTimeView has elapsedTime,which is a TimeInterval, defaulted to zero.showSubseconds is a Boolean argument defaulted to true.timeFormatter is an ElapsedTimeFormatterstate variable that we define below.The View’s body contains a Text viewthat casts the elapsedTime to an NSNumberso that the timeFormatter can use it.Text view has a semibold fontWeight.When showSubseconds changes, the timeFormatter’sshowSubseconds variable also changes.The ElapsedTimeFormatter is a custom formatterthat uses a DateComponentsFormatter.We want elapsed time to show minutes and secondsand pad zeros.The showSubseconds variabledictates if subseconds are shown.We override the string for value function,which returns an optional String.The first guard ensures the value is a TimeInterval.The second guard ensures the componentsFormatterreturned a string.If showSubseconds is true, calculate the subsecondsby getting the truncatedRemainderby dividingBy 1, then multiplying by 100.Use a localized decimalSeparator,then return a formattedString, appending the subseconds.If showSubseconds is false, then just returnthe formattedString without subseconds.Click resume to see a preview of our ElapsedTimeView.Looks good.Minutes has zeros padded on the left side of the colon.Seconds has zeros padded on the right side of the colon.Subseconds are displayed after the decimal.Let’s add the ElapsedTimeView to MetricsView.Click MetricsView.Replace the elapsed time Text viewwith the ElapsedTimeView.Let’s preview our MetricsView.Looks great!The ControlsView has buttonsthat control the in-progress session,such as End, Pause, and Resume.When the End button is tapped,the workout summary will be displayed.When the Pause button is tapped, the workout will pauseand the MetricsView will be displayed.Let’s create the ControlsView.Click File > New > File,SwiftUI View,name this "ControlsView" and click Create.Let’s add the End and Pause buttons.An HStack contains two VStackswhere each VStack contains a button and a text view.The End button’s label is an Image with systemName “xmark”.The button has a red tint and uses title2 fontto increase the size of the symbol.The text view below has an “End” string.The pause button uses an image with systemName “pause”.It has a yellow tint.The text view below has a “Pause” string.Click Resume to preview the ControlsView.Looks great.The NowPlayingView provides media playback controlswhile the workout is in session.This includes controls for third-party appsthat are currently playing media.Let’s add the NowPlayingView.Select SessionPagingView.The NowPlayingView is provided by WatchKit.Let’s import WatchKit.Let’s replace our text views with ControlsView, MetricsView,and the NowPlayingView.The NowPlayingView is a SwiftUI view provided by WatchKit.It’s that simple.Click Resume to see a preview of SessionPagingView.In Preview, we can see our MetricsView.Swipe to the left to see the ControlsView.Swipe all the way to the right......to see the NowPlayingView.Let’s go back to our StartView and change the destinationof the NavigationLink to SessionPagingView.Select StartView.Update the destination to SessionPagingView.A Summary screen confirms that a workout is finishedand displays the recorded information.We will enhance the summary by including Activity Ringsso that people can easily check their current progress.Let’s create the Summary view.Click File > New > File,SwiftUI View, click Next,name this "SummaryView" and click Create.Let’s create a custom SummaryMetricViewthat describes the metric and its value.SummaryMetricView takes a title that describes the metricand a value string of the metric.Body contains the two text views and a divider.The text view showing the metric valueuses a title system font with rounded designand lowercaseSmallCaps.It uses the accentColor as its foregroundColor.Let’s create the workout duration formatterfor the SummaryView.durationFormatter is a DateComponentsFormatterthat displays hours, minutes, and seconds separated by colonsand pads zeros.Let’s add the SummaryMetricViews and the Done buttonto our SummaryView.A ScrollView and VStack contain our four SummaryMetricViewsand Done button.Total Time text view uses the durationFormatterto display hours, minutes, and seconds,separated by colons.Total Distance SummaryMetricView uses Measurementwith a default value that is formattedusing an abbreviated unit.usage is road, which displays naturally progressingimperial or metric units based on locale.Total Energy SummaryMetricView uses Measurementwith a default value and energy unit of kilocalories.It is formatted using an abbreviated unit.usage is workout for workout energy,and numberFormat has a precision with fractionLength zero.Average Heart Rate SummaryMetricViewuses a default valueformatted with number precision, fractionLength of zero,and appends "bpm" for beats per minute.We’ll provide actual workout values laterfor the SummaryMetricViews.We want the text views and dividersto align to the navigation bar titleso we've used .scenePadding() on the VStack.The navigationTitle will be "Summary"and will display inline in the navigation bar.Next let’s add Activity Rings to the workout summary.Click File > New > File,Swift File, click Next,name this "ActivityRingsView" and click Create.Import HealthKit to get access to the HKHealthStore.Import SwiftUI to get access to WKInterfaceObjectRepresentable.The ActivityRingsView struct conforms toWKInterfaceObjectRepresentable.The healthStore constant is assigned at initialization.Two functions are required to conform to the protocol:makeWKInterfaceObject and updateWKInterfaceObject.Inside makeWKInterfaceObject,we declare the activityRingsObjectwhich is a WKInterfaceActivityRing.Next we create the predicate for the HKActivitySummaryQueryand use date components for today.Then we create the query and handle the result,which sets the activity summary on the activityRingsObjecton the main queue.Then execute the query on the HKHealthStore.Finally, return the activityRingsObject.Let’s add the ActivityRingsView to the SummaryView.Click SummaryView.Let's import HealthKit to get access to HKHealthStore.Next, let's add a Text view and an ActivityRingsViewabove the Done button.We’ve added a Text view and an ActivityRingsViewswith a frame width and height of 50.We’ll create an HKHealthStore for now.Later, we’ll reuse one.Let’s preview our SummaryView. Click Resume.Click Live Preview to be able to scroll.See each of our SummaryMetricViews,Activity Rings,and Done button.Let’s talk about HealthKit integration.HealthKit provides built-in functionalityto track fitness activity during the workoutand save that workout to HealthKit.This saves you time as a developer,and your customers will have all their workoutssaved to one location.HK workout session prepares the device’s sensorsfor data collection so that you can accurately collect datathat’s relevant to the workout, like calories and heart rate.It also allows your application to run in the backgroundwhen the workout is active.HKLiveWorkoutBuilder will create and save an HKWorkout object.It automatically collects samplesand events for you.To learn more, check outthe “New ways to work with workouts” session.Let’s see what the data flow will be for our app.WorkoutManager will be responsiblefor interfacing with HealthKit.It interfaces with an HKWorkoutSessionto start, pause, and end the workout.It interfaces with an HKLiveWorkoutBuilderto listen for workout samples and provide that datato our views.WorkoutManager will be an environment object.An environment object invalidates the current viewwhenever the observable object changes.We will assignMyWorkoutsApp’s NavigationViewthe WorkoutManager environmentObject,which will propagate WorkoutManager to viewsin the NavigationView’s view hierarchy.Views will then declare an @EnvironmentObjectto gain access to WorkoutManager in the environment.Let’s create the WorkoutManager.Click File > New > File,Swift File, click Next,name this "WorkoutManager" and click Create.Import HealthKitso that WorkoutManager has access to HealthKit’s APIs.Then define the WorkoutManager class which is an NSObjectthat conforms to the ObservableObject protocol.We want to give all of our views access to WorkoutManager.We do this by assigning WorkoutManageras an environment objecton MyWorkoutsApp’s NavigationView.Select MyWorkoutsApp.Add workoutManager as a StateObject.Add the environmentObject view modifierto the NavigationView.When a NavigationView is assigned an environmentObject,it automatically passes the environmentObjectto views in its view hierarchy.Let’s set up our navigation model.Select WorkoutManager.WorkoutManager will manage the selected workout,which is an optional HKWorkoutActivityType.We’ve added the selectedWorkout variableto track the selected workout.Now our StartView’s NavigationLinkneeds to bind its selectionto WorkoutManager’s selectedWorkout.Select StartView.Add workoutManager EnvironmentObject to StartView.Let’s update NavigationLink with tag and selection.tag is the workoutType.selection is a binding to selectedWorkouton workoutManager.Now, whenever a workout is tapped,selectedWorkout on workoutManager will update.Now let’s start an HKWorkoutSessionand HKLiveWorkoutBuilder when a workout is selected.Select WorkoutManager.Add the HKHealthStore, HKWorkoutSession,and HKLiveWorkoutBuilder.Now, let’s create a startWorkout function to start the workout.The startWorkout function takes a workoutType parameter.A HKWorkoutConfiguration is created using the workoutType.For our app, all of our workouts will be outdoor.Note that location type determines howthe HKWorkoutSession and HKLiveWorkoutBuilder behaves.For example, an outdoor cycling activitygenerates accurate location data,while an indoor cycling activity does not.Create the HKWorkoutSession using the healthStoreand configuration.Assign builder to the session’s associatedWorkoutBuilder.This is done in a do-catch block to handle any errors thrown.Assign the builder’s dataSource to an HKLiveWorkoutDataSourceusing the healthStore and workoutConfiguration.An HKLiveWorkoutDataSource automatically provides live datafrom an active workout session.Create a startDate,call startActivity on the session,and beginCollection on the builder.Whenever selectedWorkout changes,let’s call startWorkout.selectedWorkout can be nil.Use a guard statement to only call startWorkoutwhen selectedWorkout is not nil.Before our app can create a workout session,we need to set up HealthKit and request authorizationto read and share any health data our app intends to use.Let's add a function to request authorization.For workout sessions, we must request permissionto share workout types.We also want to read any data types automatically recordedby Apple Watch as part of the session.We also want permission to read the Activity Rings summary.Then call requestAuthorization on the healthStore.Let’s have the StartView request authorizationfrom HealthKit when the view appears.Click StartView.On appear, workoutManager’srequestAuthorization function will be called.Let’s enable HealthKit for our extension.Select MyWorkouts's project file......MyWorkouts WatchKit Extension,Signing & Capabilities.Select Add Capability, scroll down, select HealthKit.Apps with an active workout sessioncan run in the background, so you need to addthe background modes capability to your WatchKit Extension.Workout sessions requirethe Workout processing background mode.Select Add Capability,Background Modes.Select Workout processing.We need to add usage descriptionsto our WatchKit Extension’s Info.plist file.Select Info.plist.Select the last row, then press Return.Use the NSHealth ShareUsageDescription key.Describe why your app needs to read the requested data.Press Return.Use the NSHealth UpdateUsageDescription key.Describe the data your app intends to write.Let’s build and run our appto see our app request permission from HealthKit.Click Run.Our app has requested HealthKit authorization.Scroll down and click Review.Select All Requested Data Below.See that our app has requested to share Workouts.See our provided explanation.Tap Next.Our app has requested read access.Select All Requested Data Below.See the data types that our app has requested read access to.See our provided explanation.Tap Done.Now that the workout session can start,we need to control the HKWorkoutSession.Select WorkoutManager.Let's add our session state control logic.A @Published variable named "running"tracks if the session is running.The pause and resume functions pause and resume the session.The togglePause function will either pauseor resume the session based on if the session is running.The endWorkout function will end the session.Let’s extend WorkoutManagerto be an HKWorkoutSessionDelegateto listen for changes to the session state.The workoutSession didChangeTo toState fromStatewith Date function is calledwhenever the session state changes.Our running variable will updatebased on if the toState is running and is dispatchedto the main queue for UI updates.When the session transitions to ended,call endCollection on the builderwith the end date provided to stop collecting workout samples.Once endCollection finishes, call finishWorkoutto save the HKWorkout to the Health database.Make sure to assign WorkoutManageras the HKWorkoutSession delegate.Now let’s have the ControlsViewpause, resume, and end the session.Select ControlsView.Add workoutManager as an EnvironmentObjectso that our view can control the session.Have the End button’s action call endWorkouton workoutManager.The Pause/Resume button needs to pause or resume the sessionand update its image and text based on the session state.The button’s action calls workoutManager’stogglePause function to pause or resume the session.The button’s Image’s systemName is either "pause" or "play",based on workoutManager’s running variable.The text below the button shows either “Pause” or “Resume”,also based on workoutManager’s running variable.Let’s update our SessionPagingViewto display the workout name in the navigation bar.Select SessionPagingView.The SessionPagingView needs accessto the WorkoutManager environment variable,so let’s add that.Now let’s configure our navigation bar.The navigation titleis the WorkoutManager’s selectedWorkout’s name.The navigation bar’s back button is hidden,because we don’t want someone to go back to the StartViewwhile they are in a workout.When the NowPlayingView is shown,we want to hide the navigation bar.When someone pauses or resumes their workout,they shouldn’t need to swipe to the MetricsView.We can do this for themby adding an onChange view modifier.When WorkoutManager’s running published variable changes,the displayMetricsView function is called.displayMetricsView sets the selection state variableto metrics withAnimation.Now that the workout can end,let’s add the ability to show and dismiss the SummaryView.Click WorkoutManager.Add a published variable named "showingSummaryView"which is a Boolean defaulted to false.This variable will provide a binding to a sheet’s selectionon our app’s navigation view.In endWorkout, set showingSummaryView to true.Let’s add the SummaryView as a Sheetto MyWorkoutsApp’s NavigationView.Click MyWorkoutsApp.Add a sheet view modifier to NavigationView.The isPresented parameter is a bindingto workoutManager’s showingSummaryView.The sheet’s content is a SummaryView.In SummaryView,let’s add the ability to dismiss the sheet.Click SummaryView.Add the dismiss Dnvironment variable.In the Done button’s action, call dismiss().Let’s run our application to start and end the sessionand see the SummaryView displayed.Click Stop to stop the previous run.Click Run.Tap the Run workout.Default metric values will still be displayed in-sessionand in the summary.We'll set that up later.Swipe to the left.Tap Pause.Notice the MetricsView is displayed.Swipe to the left.Notice the button now shows "Resume".Tap End.Our workout summary displays as a sheet.Scroll down.Tap Done.The sheet is dismissed and the StartView is displayed.Let’s get our MetricsView and SummaryViewto show actual workout metrics.WorkoutManager will expose published workout metricsthat MetricsView and SummaryView can observe.Select WorkoutManager.Let’s add the Published metric variables to WorkoutManager.averageHeartRate will be used by SummaryView.heartRate, activeEnergy, and distance will be observedby MetricsView.WorkoutManager needs to observe workout samplesadded to the builder by being an HKLiveWorkoutBuilderDelegate.Let’s do this now.First, let’s assign the builder’s delegateas WorkoutManager.Now let’s make WorkoutManagerconform to the HKLiveWorkout BuilderDelegate protocol.We’ve extended WorkoutManagerto conform to the HKLiveWorkout BuilderDelegate protocol.workoutBuilderDidCollectEvent is calledwhenever the builder collects an event.We will leave this function empty for our app.workoutBuilder didCollectDataOf collectedTypesis called whenever the builder collects new samples.We will iterate over each type in collectedTypes.The guard ensures the collected type is an HKQuantityType.Statistics are read from the builder for that quantity type.updateForStatistics --a function we will create shortly --will be called, which updates the published metric values.Let’s create the updateForStatistics function.updateForStatistics takes an optional HKStatistics object.A guard early returns if statistics is nil.Dispatch the metric updates asynchronouslyto the main queue.Switch through each quantity type.For heartRate, we want beats per minute,so we use a count HKUnit divided by a minute HKUnit.Assign heartRate as the mostRrecentQuantity’sdoubleValue for beats per minute.Assign averageHeartRate as statistics.averageQuantity’sdoubleValue for beats per minute.For the activeEnergyBurned quantityType,use the kilocalorie energyUnit.Assign activeEnergy as the sumQuantity’s doubleValuefor the energyUnit.For walking, running, and cycling distanceget the sumQuantity’s doubleValue for meterUnit.Now let’s have MetricsView use metric valuesfrom the WorkoutManager.Select MetricsView.Add workoutManager as an Environment variable.Let's update our views to use metric valuesfrom WorkoutManager.The ElapsedTimeViewuses the workoutManager’s builder’s elapsedTime.The activeEnergy Text view’s Measurementuses workoutManager’s activeEnergy.The heartRate Text view uses workoutManager’s heartRate.The distance text view’s Measurementuses workoutManager’s distance.The builder’s elapsed time variable isn’t published,so our view currently will not updatewhen builder’s elapsedTime updates.What we can do is wrap the VStack in a TimelineView.TimelineView is new this year.A TimelineView updates over time in line with its schedule.watchOS apps now support Always On state.TimelineViews make our view aware of changesto the Always On context.To learn more, check out the “What’s new in watchOS 8”and "What's new in SwiftUI" sessions.Apps can be in either active state or Always On state.Apps with active workout sessions can update, at most,once every second in Always On state.This means the MetricsView needs to hide subsecondsin Always On state.Other design considerations should be madefor Always On state,such as hiding the page indicator controlsto simplify the view.Our TimelineView needs a custom TimelineSchedulethat changes its interval based on the TimelineScheduleModedictated by the Always On context.Let’s create our custom TimelineSchedule.MetricsTimelineSchedule has a startDatefor when the schedule should start.Its initializer takes a startDate.MetricsTimelineScheduleimplements the entries function to producePeriodicTimelineSchedule entries.The function creates a PeriodicTimelineScheduleusing the startDate.The interval is determined by the TimelineScheduleMode.When the TimelineScheduleMode is lowFrequency,the TimelineSchedule interval is one second.When the TimelineScheduleMode is normal,the interval is 30 times per second.Let’s wrap our VStack in a TimelineView.The TimelineView uses our MetricsTimelineSchedule,using the builder’s startDate.ElapsedTimeView’s showSubseconds is determinedby the TimelineView’s context.cadence.When cadence is live, subseconds are shown.Otherwise subseconds are hidden in Always On state.Let’s run our application to see the metricsupdating during the workout.Click Stop to stop the current run.Click Run.Tap the Run workout.Notice that elapsed time is incrementing.The watchOS simulator automaticallysimulates collecting live workout samples for you.Calories are accruing.Heart rate is updating.Distance is accumulating.Let’s try the Always On state by clicking the Lock buttonon the simulator.Notice subseconds are hidden and metrics updateonly once per second.Click the Unlock button to return to active state.Swipe left and end the workout.The SummaryView still needs the actual HKWorkout values.Let’s do this now.First, let’s add the HKWorkout to the WorkoutManagerto be used in the SummaryView.Select WorkoutManager.Add a HKWorkout Published variable.When the builder has finished saving the workout,assign the workout to WorkoutManagerwhen builder’s finishWorkout function completes.We do this assignment on the main queue for UI updates.When the SummaryView dismisses, we need to reset our model.Let’s create a resetWorkout function that does this.The resetWorkout function resets all of our model variablesback to an initial state.Let’s call resetWorkout when the summary dismisses.This is done in the didSet of showingSummaryView.Let’s display a progress view when the workout ends,while the workout is saving,before displaying the SummaryView.Let’s go to our SummaryView.Click SummaryView.First, add the workoutManager EnvironmentObjectto SummaryView.We want to display the ProgressViewuntil workoutManager has the HKWorkout assignedwhen the builder finishes saving the workout.If workoutManager’s workout is nil,then display the ProgressViewwith the text showing “Saving workout”,and hide the navigation bar.We've also updated ActivityRingsViewto use workoutManager’s HKHealthStore.You only need a single HKHealthStore per app.Let’s update our SummaryMetricViewsto use the HKWorkout values.The Total Time metric view uses the workout duration.The totalDistance metric viewuses the workout’s total distance.The Total Energy metric viewuses the workout’s totalEnergyBurned.The Average Heart Rate metric viewuses the workoutManager’s averageHeartRate.If you want to save average heart rate for later,you can add it as metadata to the builderbefore saving the workout.Let’s update our SessionPagingViewto react to Always On state.Select SessionPagingView.Add the isLuminanceReduced Environment variable.During Always On state,we want to hide the TabView’s page indicatorand ensure the MetricsView is displayed.We’ve set the tabViewStyle's indexDisplayModeto either never or automatic, based on isLuminanceReduced.When isLuminanceReduced changes,call the displayMetricsView functionto display the MetricsView.Let’s run our app in the simulator and try it out.Click Stop to stop the last run.Click Run.Select the Run workout.Notice metrics are updating live from the builder.Swipe left. Tap Pause.Notice metrics have stopped updating,because the workout is paused.Swipe left. Tap Resume.Metrics resume updating.Swipe right, see the NowPlayingView.Swipe left.Click Lock to trigger the Always On state.Notice subseconds are hiddenand page control indicators are hidden.Click Unlock to resume active state.Swipe left, tap End.The workout saves.The summary is displayed.Scroll down to view each of the metrics.Activity Rings will populate based on the amount of energy,exercise minutes, and stand hours.Tap Done.We are taken back to the start view,ready for our next workout.You saw how easy it is to use SwiftUIto implement a fully functioning workout appintegrated with HealthKit that supports the Always On state.We can’t wait to see what great workout apps you’ll build next!♪

♪ Bass music playing ♪♪Brady White: Hi, I’m Brady.I’m an engineer on the Fitness team.Thanks for joining me.There are lots of great workout apps already availablein the App Store.Apple Watch is an amazing devicecapable of tracking all sorts of fitness activity.It can track distance and elevationon those challenging bike rides.You can monitor your heart rate and energy burnedduring intense workouts.For swimming, it can even detect stroke type and count laps.All of this and more is available for youto build a great workout app.Let’s take a look at what we will be covering today.This session is a Code-Along.We'll go over what that means and how you can participate.We'll build our workout views in SwiftUI.Then, we'll integrate HealthKit to our views.We'll also show you how to support the Always On state.I'm excited, let's get started.This session is a code-along.We will build a workout app together from scratch.While you get your Xcode ready,let's cover a couple of concepts.What is a workout app?A workout app tracks fitness activityduring a workout.A workout can be started with a single tap.While the workout is in session, live metrics are displayed,such as elapsed time, energy burned, heart rate,and distance.When the workout ends,a summary shows the metrics recorded for the workout.This is what we will build today.Let’s get started building our workout views.Let’s open Xcode and start a new project.Click Create a new Xcode project,watchOS, Watch App,click Next.Give your workout app a name, such as "MyWorkouts".Ensure Interface is SwiftUI, and language is Swiftand click Next.Find a location for your project and click Create.

Let’s hide the inspector and resize our canvas.

Let’s click Resume to see what our app looks like,using Xcode previews.Great, our SwiftUI app is ready.Let’s provide a way for someone to start their workoutwith a StartView.A workout can be started with just a single tap.The list view with carousel-style layoutwill provide a list of workouts that scrolls verticallywith a great depth effect.Our list of workouts will include bike, run, and walk.Let’s create our StartView.Let’s rename "ContentView" to "StartView".Command-click on ContentView,click Rename,Enter "StartView" as the new name.Notice that in MyWorkoutsApp.swiftStartView is now NavigationView’s root view.Click Rename.Let’s define an array of workout typesto display in our StartView’s list.First, let’s import HealthKitto get access to HKWorkoutActivityType.

Next, let’s add our array of workout types.

Our workout list will have HKWorkoutActivityTypesof cycling, running, and walking.Let’s make HKWorkoutActivityTypeaccessible to our listby extending the HKWorkoutActivityType enumto conform to the identifiable protocoland add a name variable.

The ID-computed variable will return the rawValue of the enum.

The name variable will switch through the casesto return a name like “Run”, “Bike”, or “Walk”.Let’s add a List view to our StartView’s bodyto display the list of workouts.

The list uses the workoutTypes variable as its model.

A NavigationLink is displayed for each workoutType.A NavigationLink defines a destinationfor a navigation-based interface.For now, the destination will be a text view.We'll set these navigation links up laterto make sure they are tracking the right workout.

Padding makes the navigation links tallerto give them a larger tap area to easily start a workout.

The list uses a carousel listStyleto provide a depth effect when scrolling.

The navigationBarTitle will display “Workouts”.Let’s click Resume to see a preview of our StartView.

Click Live Preview to be able to scroll.Scroll up to see the carousel ListStyle depth effect.Looks great.The workout session will be presented as a modal experience.During a workout, people typically needonly session-specific functionality.They don't need to review the list of workoutsor access other parts of your app.Offering the most important items in a modal experiencecan help people manage their sessionwhile minimizing distraction.People who use workout apps on Apple Watchexpect the views to be in this order.On the left, our controls view has buttonsthat control the in-progress sessionsuch as End, Pause, and Resume.In the center, metrics appear on a dedicated screenthat people can read at a glance.On the right, media playback controlsallow media to be controlled during a workout.A TabView on watchOS switches between multiple child viewswhen someone swipes left or right.A TabView also provides a page indicatorat the bottom of the view.A TabView will work great to display our in-session views.Let’s create a SessionPagingView with a TabViewfor our three workout session views.Click File > New > File...SwiftUI View, click Next,name this "SessionPagingView" and click Create.

Let’s create a Tab enum to model each view that can be selectedin our TabView.

The Tab enum has three cases:controls, metrics, and nowPlaying.We’ve also added a @State variable named "selection"to provide the binding for the TabView’s selection.Selection’s default value will be metrics,so that when the workout starts, the metrics view is displayed.Let’s add the TabView.

The TabView’s selection parameter uses a bindingto our selection state variable.Text views are placeholders for each viewuntil they are created.Each of the views have a tag so they can be selected.Let’s click Resumeand see what our SessionPagingView looks like.

Click Live Preview to be able to swipe between the views.

Notice the Metrics text view is displayed first,because SessionPagingView's selection variable'sdefault value is metrics.Swiping to the left shows the Controls text view.Swiping all the way to the rightshows the Now Playing text view.Great!While the workout is running, live metrics are displayed.When a session requires movement, like running,your app should use large font sizes and arrange textso that the most important information is easy to read.Our MetricsView will display elapsed time, active energy,current heart rate, and distance.HealthKit has many more HKQuantityTypesavailable for you to use.Let’s create the MetricsView.Click File > New > FileSwiftUI View, click Next,name this "MetricsView" and click Create.

A VStack will contain our four metric Text views.

The Text views have default values for nowuntil we connect these Text views to our model.

Let’s make elapsed time the focal point by giving ita yellow foregroundColor and semibold fontWeight.

The active energy text view creates a measurementusing a default value in energy unit kilocalories.The Measurement uses a new formatted functionwhich abbreviates the unit,usage is workout for workout energy burned,and numberFormat has zero fractionLengthto trim fractions.

The heart rate text view uses a default valueformatted with fractionLength zero.It appends “bpm” -- for beats per minute --to the formatted string.

The distance text view uses a default valuewith UnitLength.meters.The measurement is formatted with abbreviated units.usage is road, which displays naturally progressingimperial or metric units based on locale.

We’ll use a system font of title with rounded design,monospacedDigits, and lowercaseSmallCaps.

We want our metrics to be aligned to the leading edge,so we’ve given the VStack a frame view modifierwith maxWidth infinity, and leading alignment.

We want to allow content of this VStackto extend all the way to the bottom of the screen.To allow this, we ignore the bottom safe area.

We want our metrics to be alignedto the navigation bar title,so we've used scenePadding() to do this.

We want our elapsed time Text viewto format the elapsed time properlyand hide or show subseconds based on the Always On state.To do this, let’s create an ElapsedTimeViewand create a custom ElapsedTimeFormatter.Click File > New > File,SwiftUI View, click Next,name it "ElapsedTimeView", and click Create.

Our ElapsedTimeView has elapsedTime,which is a TimeInterval, defaulted to zero.showSubseconds is a Boolean argument defaulted to true.timeFormatter is an ElapsedTimeFormatterstate variable that we define below.

The View’s body contains a Text viewthat casts the elapsedTime to an NSNumberso that the timeFormatter can use it.Text view has a semibold fontWeight.When showSubseconds changes, the timeFormatter’sshowSubseconds variable also changes.

The ElapsedTimeFormatter is a custom formatterthat uses a DateComponentsFormatter.We want elapsed time to show minutes and secondsand pad zeros.The showSubseconds variabledictates if subseconds are shown.

We override the string for value function,which returns an optional String.The first guard ensures the value is a TimeInterval.

The second guard ensures the componentsFormatterreturned a string.

If showSubseconds is true, calculate the subsecondsby getting the truncatedRemainderby dividingBy 1, then multiplying by 100.Use a localized decimalSeparator,then return a formattedString, appending the subseconds.

If showSubseconds is false, then just returnthe formattedString without subseconds.Click resume to see a preview of our ElapsedTimeView.

Looks good.Minutes has zeros padded on the left side of the colon.Seconds has zeros padded on the right side of the colon.Subseconds are displayed after the decimal.Let’s add the ElapsedTimeView to MetricsView.Click MetricsView.

Replace the elapsed time Text viewwith the ElapsedTimeView.

Let’s preview our MetricsView.Looks great!The ControlsView has buttonsthat control the in-progress session,such as End, Pause, and Resume.When the End button is tapped,the workout summary will be displayed.When the Pause button is tapped, the workout will pauseand the MetricsView will be displayed.Let’s create the ControlsView.Click File > New > File,SwiftUI View,name this "ControlsView" and click Create.

Let’s add the End and Pause buttons.

An HStack contains two VStackswhere each VStack contains a button and a text view.

The End button’s label is an Image with systemName “xmark”.The button has a red tint and uses title2 fontto increase the size of the symbol.The text view below has an “End” string.

The pause button uses an image with systemName “pause”.It has a yellow tint.The text view below has a “Pause” string.Click Resume to preview the ControlsView.

Looks great.

The NowPlayingView provides media playback controlswhile the workout is in session.This includes controls for third-party appsthat are currently playing media.Let’s add the NowPlayingView.Select SessionPagingView.

The NowPlayingView is provided by WatchKit.Let’s import WatchKit.

Let’s replace our text views with ControlsView, MetricsView,and the NowPlayingView.

The NowPlayingView is a SwiftUI view provided by WatchKit.It’s that simple.Click Resume to see a preview of SessionPagingView.

In Preview, we can see our MetricsView.Swipe to the left to see the ControlsView.Swipe all the way to the right......to see the NowPlayingView.

Let’s go back to our StartView and change the destinationof the NavigationLink to SessionPagingView.Select StartView.

Update the destination to SessionPagingView.

A Summary screen confirms that a workout is finishedand displays the recorded information.We will enhance the summary by including Activity Ringsso that people can easily check their current progress.Let’s create the Summary view.Click File > New > File,SwiftUI View, click Next,name this "SummaryView" and click Create.

Let’s create a custom SummaryMetricViewthat describes the metric and its value.

SummaryMetricView takes a title that describes the metricand a value string of the metric.

Body contains the two text views and a divider.The text view showing the metric valueuses a title system font with rounded designand lowercaseSmallCaps.It uses the accentColor as its foregroundColor.Let’s create the workout duration formatterfor the SummaryView.

durationFormatter is a DateComponentsFormatterthat displays hours, minutes, and seconds separated by colonsand pads zeros.Let’s add the SummaryMetricViews and the Done buttonto our SummaryView.

A ScrollView and VStack contain our four SummaryMetricViewsand Done button.

Total Time text view uses the durationFormatterto display hours, minutes, and seconds,separated by colons.

Total Distance SummaryMetricView uses Measurementwith a default value that is formattedusing an abbreviated unit.usage is road, which displays naturally progressingimperial or metric units based on locale.

Total Energy SummaryMetricView uses Measurementwith a default value and energy unit of kilocalories.It is formatted using an abbreviated unit.usage is workout for workout energy,and numberFormat has a precision with fractionLength zero.

Average Heart Rate SummaryMetricViewuses a default valueformatted with number precision, fractionLength of zero,and appends "bpm" for beats per minute.We’ll provide actual workout values laterfor the SummaryMetricViews.We want the text views and dividersto align to the navigation bar titleso we've used .scenePadding() on the VStack.

The navigationTitle will be "Summary"and will display inline in the navigation bar.Next let’s add Activity Rings to the workout summary.Click File > New > File,Swift File, click Next,name this "ActivityRingsView" and click Create.

Import HealthKit to get access to the HKHealthStore.Import SwiftUI to get access to WKInterfaceObjectRepresentable.

The ActivityRingsView struct conforms toWKInterfaceObjectRepresentable.The healthStore constant is assigned at initialization.

Two functions are required to conform to the protocol:makeWKInterfaceObject and updateWKInterfaceObject.

Inside makeWKInterfaceObject,we declare the activityRingsObjectwhich is a WKInterfaceActivityRing.

Next we create the predicate for the HKActivitySummaryQueryand use date components for today.Then we create the query and handle the result,which sets the activity summary on the activityRingsObjecton the main queue.

Then execute the query on the HKHealthStore.Finally, return the activityRingsObject.Let’s add the ActivityRingsView to the SummaryView.Click SummaryView.

Let's import HealthKit to get access to HKHealthStore.

Next, let's add a Text view and an ActivityRingsViewabove the Done button.

We’ve added a Text view and an ActivityRingsViewswith a frame width and height of 50.We’ll create an HKHealthStore for now.Later, we’ll reuse one.Let’s preview our SummaryView. Click Resume.

Click Live Preview to be able to scroll.

See each of our SummaryMetricViews,Activity Rings,and Done button.Let’s talk about HealthKit integration.HealthKit provides built-in functionalityto track fitness activity during the workoutand save that workout to HealthKit.This saves you time as a developer,and your customers will have all their workoutssaved to one location.HK workout session prepares the device’s sensorsfor data collection so that you can accurately collect datathat’s relevant to the workout, like calories and heart rate.It also allows your application to run in the backgroundwhen the workout is active.HKLiveWorkoutBuilder will create and save an HKWorkout object.It automatically collects samplesand events for you.To learn more, check outthe “New ways to work with workouts” session.Let’s see what the data flow will be for our app.WorkoutManager will be responsiblefor interfacing with HealthKit.It interfaces with an HKWorkoutSessionto start, pause, and end the workout.It interfaces with an HKLiveWorkoutBuilderto listen for workout samples and provide that datato our views.WorkoutManager will be an environment object.An environment object invalidates the current viewwhenever the observable object changes.We will assignMyWorkoutsApp’s NavigationViewthe WorkoutManager environmentObject,which will propagate WorkoutManager to viewsin the NavigationView’s view hierarchy.Views will then declare an @EnvironmentObjectto gain access to WorkoutManager in the environment.Let’s create the WorkoutManager.Click File > New > File,Swift File, click Next,name this "WorkoutManager" and click Create.

Import HealthKitso that WorkoutManager has access to HealthKit’s APIs.

Then define the WorkoutManager class which is an NSObjectthat conforms to the ObservableObject protocol.We want to give all of our views access to WorkoutManager.We do this by assigning WorkoutManageras an environment objecton MyWorkoutsApp’s NavigationView.Select MyWorkoutsApp.

Add workoutManager as a StateObject.

Add the environmentObject view modifierto the NavigationView.

When a NavigationView is assigned an environmentObject,it automatically passes the environmentObjectto views in its view hierarchy.Let’s set up our navigation model.Select WorkoutManager.

WorkoutManager will manage the selected workout,which is an optional HKWorkoutActivityType.

We’ve added the selectedWorkout variableto track the selected workout.Now our StartView’s NavigationLinkneeds to bind its selectionto WorkoutManager’s selectedWorkout.Select StartView.

Add workoutManager EnvironmentObject to StartView.

Let’s update NavigationLink with tag and selection.

tag is the workoutType.selection is a binding to selectedWorkouton workoutManager.Now, whenever a workout is tapped,selectedWorkout on workoutManager will update.Now let’s start an HKWorkoutSessionand HKLiveWorkoutBuilder when a workout is selected.Select WorkoutManager.

Add the HKHealthStore, HKWorkoutSession,and HKLiveWorkoutBuilder.Now, let’s create a startWorkout function to start the workout.

The startWorkout function takes a workoutType parameter.A HKWorkoutConfiguration is created using the workoutType.For our app, all of our workouts will be outdoor.Note that location type determines howthe HKWorkoutSession and HKLiveWorkoutBuilder behaves.For example, an outdoor cycling activitygenerates accurate location data,while an indoor cycling activity does not.Create the HKWorkoutSession using the healthStoreand configuration.

Assign builder to the session’s associatedWorkoutBuilder.This is done in a do-catch block to handle any errors thrown.

Assign the builder’s dataSource to an HKLiveWorkoutDataSourceusing the healthStore and workoutConfiguration.An HKLiveWorkoutDataSource automatically provides live datafrom an active workout session.

Create a startDate,call startActivity on the session,and beginCollection on the builder.Whenever selectedWorkout changes,let’s call startWorkout.

selectedWorkout can be nil.Use a guard statement to only call startWorkoutwhen selectedWorkout is not nil.Before our app can create a workout session,we need to set up HealthKit and request authorizationto read and share any health data our app intends to use.Let's add a function to request authorization.

For workout sessions, we must request permissionto share workout types.

We also want to read any data types automatically recordedby Apple Watch as part of the session.We also want permission to read the Activity Rings summary.

Then call requestAuthorization on the healthStore.Let’s have the StartView request authorizationfrom HealthKit when the view appears.Click StartView.

On appear, workoutManager’srequestAuthorization function will be called.Let’s enable HealthKit for our extension.Select MyWorkouts's project file...

...MyWorkouts WatchKit Extension,Signing & Capabilities.Select Add Capability, scroll down, select HealthKit.

Apps with an active workout sessioncan run in the background, so you need to addthe background modes capability to your WatchKit Extension.Workout sessions requirethe Workout processing background mode.Select Add Capability,Background Modes.Select Workout processing.We need to add usage descriptionsto our WatchKit Extension’s Info.plist file.Select Info.plist.

Select the last row, then press Return.

Use the NSHealth ShareUsageDescription key.

Describe why your app needs to read the requested data.Press Return.Use the NSHealth UpdateUsageDescription key.

Describe the data your app intends to write.

Let’s build and run our appto see our app request permission from HealthKit.Click Run.

Our app has requested HealthKit authorization.Scroll down and click Review.

Select All Requested Data Below.

See that our app has requested to share Workouts.See our provided explanation.Tap Next.Our app has requested read access.Select All Requested Data Below.See the data types that our app has requested read access to.

See our provided explanation.Tap Done.

Now that the workout session can start,we need to control the HKWorkoutSession.Select WorkoutManager.

Let's add our session state control logic.

A @Published variable named "running"tracks if the session is running.

The pause and resume functions pause and resume the session.The togglePause function will either pauseor resume the session based on if the session is running.

The endWorkout function will end the session.Let’s extend WorkoutManagerto be an HKWorkoutSessionDelegateto listen for changes to the session state.

The workoutSession didChangeTo toState fromStatewith Date function is calledwhenever the session state changes.

Our running variable will updatebased on if the toState is running and is dispatchedto the main queue for UI updates.

When the session transitions to ended,call endCollection on the builderwith the end date provided to stop collecting workout samples.Once endCollection finishes, call finishWorkoutto save the HKWorkout to the Health database.Make sure to assign WorkoutManageras the HKWorkoutSession delegate.

Now let’s have the ControlsViewpause, resume, and end the session.Select ControlsView.

Add workoutManager as an EnvironmentObjectso that our view can control the session.

Have the End button’s action call endWorkouton workoutManager.

The Pause/Resume button needs to pause or resume the sessionand update its image and text based on the session state.

The button’s action calls workoutManager’stogglePause function to pause or resume the session.

The button’s Image’s systemName is either "pause" or "play",based on workoutManager’s running variable.The text below the button shows either “Pause” or “Resume”,also based on workoutManager’s running variable.Let’s update our SessionPagingViewto display the workout name in the navigation bar.Select SessionPagingView.

The SessionPagingView needs accessto the WorkoutManager environment variable,so let’s add that.Now let’s configure our navigation bar.The navigation titleis the WorkoutManager’s selectedWorkout’s name.The navigation bar’s back button is hidden,because we don’t want someone to go back to the StartViewwhile they are in a workout.When the NowPlayingView is shown,we want to hide the navigation bar.When someone pauses or resumes their workout,they shouldn’t need to swipe to the MetricsView.We can do this for themby adding an onChange view modifier.

When WorkoutManager’s running published variable changes,the displayMetricsView function is called.displayMetricsView sets the selection state variableto metrics withAnimation.Now that the workout can end,let’s add the ability to show and dismiss the SummaryView.Click WorkoutManager.

Add a published variable named "showingSummaryView"which is a Boolean defaulted to false.

This variable will provide a binding to a sheet’s selectionon our app’s navigation view.In endWorkout, set showingSummaryView to true.

Let’s add the SummaryView as a Sheetto MyWorkoutsApp’s NavigationView.Click MyWorkoutsApp.

Add a sheet view modifier to NavigationView.

The isPresented parameter is a bindingto workoutManager’s showingSummaryView.The sheet’s content is a SummaryView.In SummaryView,let’s add the ability to dismiss the sheet.Click SummaryView.

Add the dismiss Dnvironment variable.

In the Done button’s action, call dismiss().

Let’s run our application to start and end the sessionand see the SummaryView displayed.Click Stop to stop the previous run.

Click Run.

Tap the Run workout.

Default metric values will still be displayed in-sessionand in the summary.We'll set that up later.Swipe to the left.Tap Pause.Notice the MetricsView is displayed.Swipe to the left.

Notice the button now shows "Resume".Tap End.

Our workout summary displays as a sheet.Scroll down.Tap Done.The sheet is dismissed and the StartView is displayed.Let’s get our MetricsView and SummaryViewto show actual workout metrics.WorkoutManager will expose published workout metricsthat MetricsView and SummaryView can observe.Select WorkoutManager.

Let’s add the Published metric variables to WorkoutManager.

averageHeartRate will be used by SummaryView.heartRate, activeEnergy, and distance will be observedby MetricsView.WorkoutManager needs to observe workout samplesadded to the builder by being an HKLiveWorkoutBuilderDelegate.Let’s do this now.First, let’s assign the builder’s delegateas WorkoutManager.

Now let’s make WorkoutManagerconform to the HKLiveWorkout BuilderDelegate protocol.

We’ve extended WorkoutManagerto conform to the HKLiveWorkout BuilderDelegate protocol.workoutBuilderDidCollectEvent is calledwhenever the builder collects an event.We will leave this function empty for our app.

workoutBuilder didCollectDataOf collectedTypesis called whenever the builder collects new samples.We will iterate over each type in collectedTypes.The guard ensures the collected type is an HKQuantityType.Statistics are read from the builder for that quantity type.updateForStatistics --a function we will create shortly --will be called, which updates the published metric values.Let’s create the updateForStatistics function.

updateForStatistics takes an optional HKStatistics object.A guard early returns if statistics is nil.

Dispatch the metric updates asynchronouslyto the main queue.Switch through each quantity type.For heartRate, we want beats per minute,so we use a count HKUnit divided by a minute HKUnit.Assign heartRate as the mostRrecentQuantity’sdoubleValue for beats per minute.Assign averageHeartRate as statistics.averageQuantity’sdoubleValue for beats per minute.

For the activeEnergyBurned quantityType,use the kilocalorie energyUnit.Assign activeEnergy as the sumQuantity’s doubleValuefor the energyUnit.

For walking, running, and cycling distanceget the sumQuantity’s doubleValue for meterUnit.Now let’s have MetricsView use metric valuesfrom the WorkoutManager.Select MetricsView.

Add workoutManager as an Environment variable.

Let's update our views to use metric valuesfrom WorkoutManager.

The ElapsedTimeViewuses the workoutManager’s builder’s elapsedTime.

The activeEnergy Text view’s Measurementuses workoutManager’s activeEnergy.

The heartRate Text view uses workoutManager’s heartRate.

The distance text view’s Measurementuses workoutManager’s distance.

The builder’s elapsed time variable isn’t published,so our view currently will not updatewhen builder’s elapsedTime updates.What we can do is wrap the VStack in a TimelineView.

TimelineView is new this year.A TimelineView updates over time in line with its schedule.watchOS apps now support Always On state.TimelineViews make our view aware of changesto the Always On context.To learn more, check out the “What’s new in watchOS 8”and "What's new in SwiftUI" sessions.Apps can be in either active state or Always On state.Apps with active workout sessions can update, at most,once every second in Always On state.This means the MetricsView needs to hide subsecondsin Always On state.Other design considerations should be madefor Always On state,such as hiding the page indicator controlsto simplify the view.Our TimelineView needs a custom TimelineSchedulethat changes its interval based on the TimelineScheduleModedictated by the Always On context.Let’s create our custom TimelineSchedule.

MetricsTimelineSchedule has a startDatefor when the schedule should start.Its initializer takes a startDate.

MetricsTimelineScheduleimplements the entries function to producePeriodicTimelineSchedule entries.The function creates a PeriodicTimelineScheduleusing the startDate.The interval is determined by the TimelineScheduleMode.When the TimelineScheduleMode is lowFrequency,the TimelineSchedule interval is one second.When the TimelineScheduleMode is normal,the interval is 30 times per second.Let’s wrap our VStack in a TimelineView.

The TimelineView uses our MetricsTimelineSchedule,using the builder’s startDate.ElapsedTimeView’s showSubseconds is determinedby the TimelineView’s context.cadence.When cadence is live, subseconds are shown.Otherwise subseconds are hidden in Always On state.Let’s run our application to see the metricsupdating during the workout.Click Stop to stop the current run.Click Run.

Tap the Run workout.Notice that elapsed time is incrementing.The watchOS simulator automaticallysimulates collecting live workout samples for you.Calories are accruing.Heart rate is updating.Distance is accumulating.Let’s try the Always On state by clicking the Lock buttonon the simulator.

Notice subseconds are hidden and metrics updateonly once per second.Click the Unlock button to return to active state.Swipe left and end the workout.The SummaryView still needs the actual HKWorkout values.Let’s do this now.First, let’s add the HKWorkout to the WorkoutManagerto be used in the SummaryView.Select WorkoutManager.Add a HKWorkout Published variable.

When the builder has finished saving the workout,assign the workout to WorkoutManagerwhen builder’s finishWorkout function completes.

We do this assignment on the main queue for UI updates.When the SummaryView dismisses, we need to reset our model.Let’s create a resetWorkout function that does this.

The resetWorkout function resets all of our model variablesback to an initial state.Let’s call resetWorkout when the summary dismisses.This is done in the didSet of showingSummaryView.

Let’s display a progress view when the workout ends,while the workout is saving,before displaying the SummaryView.Let’s go to our SummaryView.Click SummaryView.First, add the workoutManager EnvironmentObjectto SummaryView.

We want to display the ProgressViewuntil workoutManager has the HKWorkout assignedwhen the builder finishes saving the workout.

If workoutManager’s workout is nil,then display the ProgressViewwith the text showing “Saving workout”,and hide the navigation bar.

We've also updated ActivityRingsViewto use workoutManager’s HKHealthStore.You only need a single HKHealthStore per app.Let’s update our SummaryMetricViewsto use the HKWorkout values.

The Total Time metric view uses the workout duration.

The totalDistance metric viewuses the workout’s total distance.

The Total Energy metric viewuses the workout’s totalEnergyBurned.

The Average Heart Rate metric viewuses the workoutManager’s averageHeartRate.If you want to save average heart rate for later,you can add it as metadata to the builderbefore saving the workout.Let’s update our SessionPagingViewto react to Always On state.Select SessionPagingView.

Add the isLuminanceReduced Environment variable.

During Always On state,we want to hide the TabView’s page indicatorand ensure the MetricsView is displayed.

We’ve set the tabViewStyle's indexDisplayModeto either never or automatic, based on isLuminanceReduced.When isLuminanceReduced changes,call the displayMetricsView functionto display the MetricsView.Let’s run our app in the simulator and try it out.Click Stop to stop the last run.Click Run.

Select the Run workout.Notice metrics are updating live from the builder.Swipe left. Tap Pause.Notice metrics have stopped updating,because the workout is paused.Swipe left. Tap Resume.Metrics resume updating.Swipe right, see the NowPlayingView.Swipe left.Click Lock to trigger the Always On state.Notice subseconds are hiddenand page control indicators are hidden.Click Unlock to resume active state.

Swipe left, tap End.

The workout saves.The summary is displayed.Scroll down to view each of the metrics.Activity Rings will populate based on the amount of energy,exercise minutes, and stand hours.Tap Done.We are taken back to the start view,ready for our next workout.

You saw how easy it is to use SwiftUIto implement a fully functioning workout appintegrated with HealthKit that supports the Always On state.We can’t wait to see what great workout apps you’ll build next!♪

3:17 -StartView - import HealthKit

3:25 -StartView - workoutTypes

3:26 -StartView - HKWorkoutActivityType identifiable and name

4:22 -StartView - body

6:55 -SessionPagingView - Tab enum and selection

7:20 -SessionPagingView - TabView

9:02 -MetricsView - VStack and TextViews

11:42 -ElapsedTimeView - ElapsedTimeView and ElapsedTimeFormatter

13:56 -MetricsView - replace TextView with ElapsedTimeView

14:47 -ControlsView - Stacks, Buttons and TextViews

16:05 -SessionPagingView - import WatchKit

16:09 -SessionPagingView - TabView using actual views

17:08 -StartView - NavigationLink to use SessionPagingView

17:50 -SummaryView - SummaryMetricView

18:27 -SummaryView - durationFormatter

18:45 -SummaryView - body

21:00 -ActivityRingsView

22:15 -SummaryView - add ActivityRingsView

22:28 -SummaryView - import HealthKit

25:22 -WorkoutManager

25:53 -MyWorkoutsApp - add workoutManager @StateObject

26:00 -MyWorkoutsApp - .environmentObject to NavigationView

26:25 -WorkoutManager - selectedWorkout

26:49 -StartView  - add workoutManager

26:56 -StartView - Add tag and selection to NavigationLink

27:32 -WorkoutManager - Add healthStore, session, builder

27:42 -WorkoutManager - startWorkout(workoutType:)

29:06 -WorkoutManager - selectedWorkout didSet

29:35 -WorkoutManager - requestAuthorization from HealthKit

30:20 -StartView - requestAuthorization onAppear

31:30 -Privacy - Health Share Usage Description - Key

31:38 -Privacy - Health Share Usage Description - Value

31:47 -Privacy - Health Update Usage Description - Key

31:54 -Privacy - Health Update Usage Description - Value

33:29 -WorkoutManager - session state control

34:11 -WorkoutManager - HKWorkoutSessionDelegate

34:58 -WorkoutManager - assign HKWorkoutSessionDelegate in startWorkout()

35:22 -ControlsView - workoutManager environmentObject

35:33 -ControlsView - End Button action

35:43 -ControlsView - Pause / Resume Button and Text

36:30 -SessionPagingView - add workoutManager environment variable

36:42 -SessionPagingView - navigationBar

37:10 -SessionPagingView - onChange of workoutManager.running

37:45 -WorkoutManager - showingSummaryView

37:59 -WorkoutManager - showingSummaryView true in endWorkout

38:22 -MyWorkoutApp - add summaryView sheet to NavigationView

38:49 -SummaryView - add dismiss environment variable

38:58 -SummaryView  - add dismiss() to done button

40:25 -WorkoutManager - Metric publishers

40:48 -WorkoutManager - assigned as HKLiveWorkoutBuilderDelegate in startWorkout()

41:05 -WorkoutManager - add HKLiveWorkoutBuilderDelegate extension

42:01 -WorkoutManager - add updateForStatistics()

43:25 -MetricsView - add workoutManager as environment variable to MetricsView

43:35 -MetricsView - VStack with Text bound to workoutManager variables

45:51 -MetricsView - MetricsTimelineSchedule

46:38 -MetricsView - TimelineView wrapping VStack

48:23 -WorkoutManager - workout: HKWorkout added

48:38 -WorkoutManager - assign HKWorkout in finishWorkout

48:57 -WorkoutManager - resetWorkout()

49:21 -WorkoutManager - add resetWorkout to showingSummaryView didSet

49:48 -SummaryView - add workoutManager

50:06 -SummaryView  - add ProgressView

50:43 -SummaryView - SummaryMetricViews using HKWorkout values

51:45 -SessionPagingView - add isLuminanceReduced

51:57 -SessionPagingView - add tabViewStyle and onChangeOf based on isLuminanceReduced

## Code Samples

```swift
import
 HealthKit
```

```swift
var
 workoutTypes: [
HKWorkoutActivityType
] 
=
 [.cycling, .running, .walking]
```

```swift
extension
 
HKWorkoutActivityType
: 
Identifiable
 
{
    
public
 
var
 id: 
UInt
 {
        rawValue
    }

    
var
 name: 
String
 {
        
switch
 
self
 {
        
case
 .running:
            
return
 
"Run"

        
case
 .cycling:
            
return
 
"Bike"

        
case
 .walking:
            
return
 
"Walk"

        
default
:
            
return
 
""

        }
    }
}
```

```swift
List
(workoutTypes) { workoutType 
in

    
NavigationLink
(
        workoutType.name,
        destination: 
Text
(workoutType.name)
    ).padding(
        
EdgeInsets
(top: 
15
, leading: 
5
, bottom: 
15
, trailing: 
5
)
    )
}
.listStyle(.carousel)
.navigationBarTitle(
"Workouts"
)
```

```swift
@State
 
private
 
var
 selection: 
Tab
 
=
 .metrics


enum
 
Tab
 
{
    
case
 controls, metrics, nowPlaying
}
```

```swift
TabView
(selection: 
$selection
) {
    
Text
(
"Controls"
).tag(
Tab
.controls)
    
Text
(
"Metrics"
).tag(
Tab
.metrics)
    
Text
(
"Now Playing"
).tag(
Tab
.nowPlaying)
}
```

```swift
VStack
(alignment: .leading) {
    
Text
(
"03:15.23"
)
        .foregroundColor(
Color
.yellow)
        .fontWeight(.semibold)
    
Text
(
        
Measurement
(
            value: 
47
,
            unit: 
UnitEnergy
.kilocalories
        ).formatted(
            .measurement(
                width: .abbreviated,
                usage: .workout,
                numberFormat: .numeric(precision: .fractionLength(
0
))
            )
        )
    )
    
Text
(
        
153
.formatted(
            .number.precision(.fractionLength(
0
))
        )
        
+
 
" bpm"

    )
    
Text
(
        
Measurement
(
            value: 
515
,
            unit: 
UnitLength
.meters
        ).formatted(
            .measurement(
                width: .abbreviated,
                usage: .road
            )
        )
    )
}
.font(.system(.title, design: .rounded)
        .monospacedDigit()
        .lowercaseSmallCaps()
)
.frame(maxWidth: .infinity, alignment: .leading)
.ignoresSafeArea(edges: .bottom)
.scenePadding()
```

```swift
struct
 
ElapsedTimeView
: 
View
 
{
    
var
 elapsedTime: 
TimeInterval
 
=
 
0

    
var
 showSubseconds: 
Bool
 
=
 
true

    
@State
 
private
 
var
 timeFormatter 
=
 
ElapsedTimeFormatter
()

    
var
 body: 
some
 
View
 {
        
Text
(
NSNumber
(value: elapsedTime), formatter: timeFormatter)
            .fontWeight(.semibold)
            .onChange(of: showSubseconds) {
                timeFormatter.showSubseconds 
=
 
$0

            }
    }
}


class
 
ElapsedTimeFormatter
: 
Formatter
 
{
    
let
 componentsFormatter: 
DateComponentsFormatter
 
=
 {
        
let
 formatter 
=
 
DateComponentsFormatter
()
        formatter.allowedUnits 
=
 [.minute, .second]
        formatter.zeroFormattingBehavior 
=
 .pad
        
return
 formatter
    }()
    
var
 showSubseconds 
=
 
true


    
override
 
func
 
string
(
for
 
value
: 
Any
?
)
 -> 
String
? {
        
guard
 
let
 time 
=
 value 
as?
 
TimeInterval
 
else
 {
            
return
 
nil

        }

        
guard
 
let
 formattedString 
=
 componentsFormatter.string(from: time) 
else
 {
            
return
 
nil

        }

        
if
 showSubseconds {
            
let
 hundredths 
=
 
Int
((time.truncatingRemainder(dividingBy: 
1
)) 
*
 
100
)
            
let
 decimalSeparator 
=
 
Locale
.current.decimalSeparator 
??
 
"."

            
return
 
String
(format: 
"%@%@%0.2d"
, formattedString, decimalSeparator, hundredths)
        }

        
return
 formattedString
    }
}
```

```swift
ElapsedTimeView
(
    elapsedTime: 
3
 
*
 
60
 
+
 
15.24
,
    showSubseconds: 
true

).foregroundColor(
Color
.yellow)
```

```swift
HStack
 {
    
VStack
 {
        
Button
 {
        } label: {
            
Image
(systemName: 
"xmark"
)
        }
        .tint(
Color
.red)
        .font(.title2)
        
Text
(
"End"
)
    }
    
VStack
 {
        
Button
 {
        } label: {
            
Image
(systemName: 
"pause"
)
        }
        .tint(
Color
.yellow)
        .font(.title2)
        
Text
(
"Pause"
)
    }
}
```

```swift
import
 WatchKit
```

```swift
ControlsView
().tag(
Tab
.controls)

MetricsView
().tag(
Tab
.metrics)

NowPlayingView
().tag(
Tab
.nowPlaying)
```

```swift
destination: 
SessionPagingView
()
```

```swift
struct
 
SummaryMetricView
: 
View
 
{
    
var
 title: 
String

    
var
 value: 
String


    
var
 body: 
some
 
View
 {
        
Text
(title)
        
Text
(value)
            .font(.system(.title2, design: .rounded)
                    .lowercaseSmallCaps()
            )
            .foregroundColor(.accentColor)
        
Divider
()
    }
}
```

```swift
@State
 
private
 
var
 durationFormatter: 
DateComponentsFormatter
 
=
 {
    
let
 formatter 
=
 
DateComponentsFormatter
()
    formatter.allowedUnits 
=
 [.hour, .minute, .second]
    formatter.zeroFormattingBehavior 
=
 .pad
    
return
 formatter
}()
```

```swift
ScrollView
(.vertical) {
    
VStack
(alignment: .leading) {
        
SummaryMetricView
(
            title: 
"Total Time"
,
            value: durationFormatter.string(from: 
30
 
*
 
60
 
+
 
15
) 
??
 
""

        ).accentColor(
Color
.yellow)
        
SummaryMetricView
(
            title: 
"Total Distance"
,
            value: 
Measurement
(
                value: 
1625
,
                unit: 
UnitLength
.meters
            ).formatted(
                .measurement(
                    width: .abbreviated,
                    usage: .road
                )
            )
        ).accentColor(
Color
.green)
        
SummaryMetricView
(
            title: 
"Total Energy"
,
            value: 
Measurement
(
                value: 
96
,
                unit: 
UnitEnergy
.kilocalories
            ).formatted(
                .measurement(
                    width: .abbreviated,
                    usage: .workout,
                    numberFormat: .numeric(precision: .fractionLength(
0
))
                )
            )
        ).accentColor(
Color
.pink)
        
SummaryMetricView
(
            title: 
"Avg. Heart Rate"
,
            value: 
143

                .formatted(
                    .number.precision(.fractionLength(
0
))
                )
            
+
 
" bpm"

        ).accentColor(
Color
.red)
        
Button
(
"Done"
) {
        }
    }
    .scenePadding()
}
.navigationTitle(
"Summary"
)
.navigationBarTitleDisplayMode(.inline)
```

```swift
import
 HealthKit

import
 SwiftUI


struct
 
ActivityRingsView
: 
WKInterfaceObjectRepresentable
 
{
    
let
 healthStore: 
HKHealthStore


    
func
 
makeWKInterfaceObject
(
context
: 
Context
)
 -> 
some
 
WKInterfaceObject
 {
        
let
 activityRingsObject 
=
 
WKInterfaceActivityRing
()

        
let
 calendar 
=
 
Calendar
.current
        
var
 components 
=
 calendar.dateComponents([.era, .year, .month, .day], from: 
Date
())
        components.calendar 
=
 calendar

        
let
 predicate 
=
 
HKQuery
.predicateForActivitySummary(with: components)

        
let
 query 
=
 
HKActivitySummaryQuery
(predicate: predicate) { query, summaries, error 
in

            
DispatchQueue
.main.async {
                activityRingsObject.setActivitySummary(summaries
?
.first, animated: 
true
)
            }
        }

        healthStore.execute(query)

        
return
 activityRingsObject
    }

    
func
 
updateWKInterfaceObject
(
_
 
wkInterfaceObject
: 
WKInterfaceObjectType
, 
context
: 
Context
)
 {

    }
}
```

```swift
Text
(
"Activity Rings"
)

ActivityRingsView
(
    healthStore: 
HKHealthStore
()
).frame(width: 
50
, height: 
50
)
```

```swift
import
 HealthKit


class
 
WorkoutManager
: 
NSObject
, 
ObservableObject
 
{

}
```

```swift
@StateObject
 
var
 workoutManager 
=
 
WorkoutManager
()
```

```swift
.environmentObject(workoutManager)
```

```swift
var
 selectedWorkout: 
HKWorkoutActivityType
?
```

```swift
@EnvironmentObject
 
var
 workoutManager: 
WorkoutManager
```

```swift
,
tag: workoutType,
selection: 
$workoutManager
.selectedWorkout
```

```swift
let
 healthStore 
=
 
HKHealthStore
()

var
 session: 
HKWorkoutSession
?

var
 builder: 
HKLiveWorkoutBuilder
?
```

```swift
func
 
startWorkout
(
workoutType
: 
HKWorkoutActivityType
)
 {
    
let
 configuration 
=
 
HKWorkoutConfiguration
()
    configuration.activityType 
=
 workoutType
    configuration.locationType 
=
 .outdoor

    
do
 {
        session 
=
 
try
 
HKWorkoutSession
(healthStore: healthStore, configuration: configuration)
        builder 
=
 session
?
.associatedWorkoutBuilder()
    } 
catch
 {
        
// Handle any exceptions.

        
return

    }

    builder
?
.dataSource 
=
 
HKLiveWorkoutDataSource
(
        healthStore: healthStore,
        workoutConfiguration: configuration
    )

    
// Start the workout session and begin data collection.

    
let
 startDate 
=
 
Date
()
    session
?
.startActivity(with: startDate)
    builder
?
.beginCollection(withStart: startDate) { (success, error) 
in

        
// The workout has started.

    }
}
```

```swift
{
    
didSet
 {
        
guard
 
let
 selectedWorkout 
=
 selectedWorkout 
else
 { 
return
 }
        startWorkout(workoutType: selectedWorkout)
    }
}
```

```swift
// Request authorization to access HealthKit.


func
 
requestAuthorization
()
 {
    
// The quantity type to write to the health store.

    
let
 typesToShare: 
Set
 
=
 [
        
HKQuantityType
.workoutType()
    ]

    
// The quantity types to read from the health store.

    
let
 typesToRead: 
Set
 
=
 [
        
HKQuantityType
.quantityType(forIdentifier: .heartRate)
!
,
        
HKQuantityType
.quantityType(forIdentifier: .activeEnergyBurned)
!
,
        
HKQuantityType
.quantityType(forIdentifier: .distanceWalkingRunning)
!
,
        
HKQuantityType
.quantityType(forIdentifier: .distanceCycling)
!
,
        
HKObjectType
.activitySummaryType()
    ]

    
// Request authorization for those quantity types.

    healthStore.requestAuthorization(toShare: typesToShare, read: typesToRead) { (success, error) 
in

        
// Handle error.

    }
}
```

```swift
.onAppear {
    workoutManager.requestAuthorization()
}
```

```swift
NSHealthShareUsageDescription
```

```swift
Your
 workout related data will be used to display your saved workouts 
in
 
MyWorkouts
.
```

```swift
NSHealthUpdateUsageDescription
```

```swift
Workouts
 tracked by 
MyWorkouts
 on 
Apple
 
Watch
 will be saved to 
HealthKit
.
```

```swift
// MARK: - State Control



// The workout session state.


@Published
 
var
 running 
=
 
false



func
 
pause
()
 {
    session
?
.pause()
}


func
 
resume
()
 {
    session
?
.resume()
}


func
 
togglePause
()
 {
    
if
 running 
==
 
true
 {
        pause()
    } 
else
 {
        resume()
    }
}


func
 
endWorkout
()
 {
    session
?
.end()
}
```

```swift
// MARK: - HKWorkoutSessionDelegate


extension
 
WorkoutManager
: 
HKWorkoutSessionDelegate
 
{
    
func
 
workoutSession
(
_
 
workoutSession
: 
HKWorkoutSession
,
                        
didChangeTo
 
toState
: 
HKWorkoutSessionState
,
                        
from
 
fromState
: 
HKWorkoutSessionState
,
                        
date
: 
Date
)
 {
        
DispatchQueue
.main.async {
            
self
.running 
=
 toState 
==
 .running
        }

        
// Wait for the session to transition states before ending the builder.

        
if
 toState 
==
 .ended {
            builder
?
.endCollection(withEnd: date) { (success, error) 
in

                
self
.builder
?
.finishWorkout { (workout, error) 
in

                }
            }
        }
    }

    
func
 
workoutSession
(
_
 
workoutSession
: 
HKWorkoutSession
, 
didFailWithError
 
error
: 
Error
)
 {

    }
}
```

```swift
session
?
.delegate 
=
 
self
```

```swift
workoutManager.endWorkout()
```

```swift
Button
 {
    workoutManager.togglePause()
} label: {
    
Image
(systemName: workoutManager.running 
?
 
"pause"
 : 
"play"
)
}
.tint(
Color
.yellow)
.font(.title2)

Text
(workoutManager.running 
?
 
"Pause"
 : 
"Resume"
)
```

```swift
.navigationTitle(workoutManager.selectedWorkout
?
.name 
??
 
""
)
.navigationBarBackButtonHidden(
true
)
.navigationBarHidden(selection 
==
 .nowPlaying)
```

```swift
.onChange(of: workoutManager.running) { 
_
 
in

        displayMetricsView()
    }
}


private
 
func
 
displayMetricsView
()
 {
    withAnimation {
        selection 
=
 .metrics
    }
}
```

```swift
@Published
 
var
 showingSummaryView: 
Bool
 
=
 
false
 {
    
didSet
 {
        
// Sheet dismissed

        
if
 showingSummaryView 
==
 
false
 {
            selectedWorkout 
=
 
nil

        }
    }
}
```

```swift
showingSummaryView 
=
 
true
```

```swift
.sheet(isPresented: 
$workoutManager
.showingSummaryView) {
    
SummaryView
()
}
```

```swift
@Environment
(\.dismiss) 
var
 dismiss
```

```swift
dismiss()
```

```swift
// MARK: - Workout Metrics


@Published
 
var
 averageHeartRate: 
Double
 
=
 
0


@Published
 
var
 heartRate: 
Double
 
=
 
0


@Published
 
var
 activeEnergy: 
Double
 
=
 
0


@Published
 
var
 distance: 
Double
 
=
 
0
```

```swift
builder
?
.delegate 
=
 
self
```

```swift
// MARK: - HKLiveWorkoutBuilderDelegate


extension
 
WorkoutManager
: 
HKLiveWorkoutBuilderDelegate
 
{
    
func
 
workoutBuilderDidCollectEvent
(
_
 
workoutBuilder
: 
HKLiveWorkoutBuilder
)
 {
    }

    
func
 
workoutBuilder
(
_
 
workoutBuilder
: 
HKLiveWorkoutBuilder
, 
didCollectDataOf
 
collectedTypes
: 
Set
<
HKSampleType
>)
 {
        
for
 type 
in
 collectedTypes {
            
guard
 
let
 quantityType 
=
 type 
as?
 
HKQuantityType
 
else
 { 
return
 }

            
let
 statistics 
=
 workoutBuilder.statistics(for: quantityType)

            
// Update the published values.

            updateForStatistics(statistics)
        }
    }
}
```

```swift
func
 
updateForStatistics
(
_
 
statistics
: 
HKStatistics
?)
 {
    
guard
 
let
 statistics 
=
 statistics 
else
 { 
return
 }

    
DispatchQueue
.main.async {
        
switch
 statistics.quantityType {
        
case
 
HKQuantityType
.quantityType(forIdentifier: .heartRate):
            
let
 heartRateUnit 
=
 
HKUnit
.count().unitDivided(by: 
HKUnit
.minute())
            
self
.heartRate 
=
 statistics.mostRecentQuantity()
?
.doubleValue(for: heartRateUnit) 
??
 
0

            
self
.averageHeartRate 
=
 statistics.averageQuantity()
?
.doubleValue(for: heartRateUnit) 
??
 
0

        
case
 
HKQuantityType
.quantityType(forIdentifier: .activeEnergyBurned):
            
let
 energyUnit 
=
 
HKUnit
.kilocalorie()
            
self
.activeEnergy 
=
 statistics.sumQuantity()
?
.doubleValue(for: energyUnit) 
??
 
0

        
case
 
HKQuantityType
.quantityType(forIdentifier: .distanceWalkingRunning), 
HKQuantityType
.quantityType(forIdentifier: .distanceCycling):
            
let
 meterUnit 
=
 
HKUnit
.meter()
            
self
.distance 
=
 statistics.sumQuantity()
?
.doubleValue(for: meterUnit) 
??
 
0

        
default
:
            
return

        }
    }
}
```

```swift
VStack
(alignment: .leading) {
    
ElapsedTimeView
(
        elapsedTime: workoutManager.builder
?
.elapsedTime 
??
 
0
,
        showSubseconds: 
true

    ).foregroundColor(
Color
.yellow)
    
Text
(
        
Measurement
(
            value: workoutManager.activeEnergy,
            unit: 
UnitEnergy
.kilocalories
        ).formatted(
            .measurement(
                width: .abbreviated,
                usage: .workout,
                numberFormat: .numeric(precision: .fractionLength(
0
))
            )
        )
    )
    
Text
(
        workoutManager.heartRate
            .formatted(
                .number.precision(.fractionLength(
0
))
            )
        
+
 
" bpm"

    )
    
Text
(
        
Measurement
(
            value: workoutManager.distance,
            unit: 
UnitLength
.meters
        ).formatted(
            .measurement(
                width: .abbreviated,
                usage: .road
            )
        )
    )
}
```

```swift
private
 
struct
 
MetricsTimelineSchedule
: 
TimelineSchedule
 
{
    
var
 startDate: 
Date


    
init
(
from
 
startDate
: 
Date
)
 {
        
self
.startDate 
=
 startDate
    }

    
func
 
entries
(
from
 
startDate
: 
Date
, 
mode
: 
TimelineScheduleMode
)
 -> 
PeriodicTimelineSchedule
.
Entries
 {
        
PeriodicTimelineSchedule
(
            from: 
self
.startDate,
            by: (mode 
==
 .lowFrequency 
?
 
1.0
 : 
1.0
 
/
 
30.0
)
        ).entries(
            from: startDate,
            mode: mode
        )
    }
}
```

```swift
TimelineView
(
    
MetricsTimelineSchedule
(
        from: workoutManager.builder
?
.startDate 
??
 
Date
()
    )
) { context 
in

    
VStack
(alignment: .leading) {
        
ElapsedTimeView
(
            elapsedTime: workoutManager.builder
?
.elapsedTime 
??
 
0
,
            showSubseconds: context.cadence 
==
 .live
        ).foregroundColor(
Color
.yellow)
        
Text
(
            
Measurement
(
                value: workoutManager.activeEnergy,
                unit: 
UnitEnergy
.kilocalories
            ).formatted(
                .measurement(
                    width: .abbreviated,
                    usage: .workout,
                    numberFormat: .numeric(precision: .fractionLength(
0
))
                )
            )
        )
        
Text
(
            workoutManager.heartRate
                .formatted(
                    .number.precision(.fractionLength(
0
))
                )
            
+
 
" bpm"

        )
        
Text
(
            
Measurement
(
                value: workoutManager.distance,
                unit: 
UnitLength
.meters
            ).formatted(
                .measurement(
                    width: .abbreviated,
                    usage: .road
                )
            )
        )
    }
    .font(.system(.title, design: .rounded)
            .monospacedDigit()
            .lowercaseSmallCaps()
    )
    .frame(maxWidth: .infinity, alignment: .leading)
    .ignoresSafeArea(edges: .bottom)
    .scenePadding()
}
```

```swift
@Published
 
var
 workout: 
HKWorkout
?
```

```swift
DispatchQueue
.main.async {
    
self
.workout 
=
 workout
}
```

```swift
func
 
resetWorkout
()
 {
    selectedWorkout 
=
 
nil

    builder 
=
 
nil

    session 
=
 
nil

    workout 
=
 
nil

    activeEnergy 
=
 
0

    averageHeartRate 
=
 
0

    heartRate 
=
 
0

    distance 
=
 
0

}
```

```swift
resetWorkout()
```

```swift
if
 workoutManager.workout 
==
 
nil
 {
    
ProgressView
(
"Saving workout"
)
        .navigationBarHidden(
true
)
} 
else
 {
    
ScrollView
(.vertical) {
        
VStack
(alignment: .leading) {
            
SummaryMetricView
(
                title: 
"Total Time"
,
                value: durationFormatter.string(from: 
30
 
*
 
60
 
+
 
15
) 
??
 
""

            ).accentColor(
Color
.yellow)
            
SummaryMetricView
(
                title: 
"Total Distance"
,
                value: 
Measurement
(
                    value: 
1625
,
                    unit: 
UnitLength
.meters
                ).formatted(
                    .measurement(
                        width: .abbreviated,
                        usage: .road
                    )
                )
            ).accentColor(
Color
.green)
            
SummaryMetricView
(
                title: 
"Total Calories"
,
                value: 
Measurement
(
                    value: 
96
,
                    unit: 
UnitEnergy
.kilocalories
                ).formatted(
                    .measurement(
                        width: .abbreviated,
                        usage: .workout,
                        numberFormat: .numeric(precision: .fractionLength(
0
))
                    )
                )
            ).accentColor(
Color
.pink)
            
SummaryMetricView
(
                title: 
"Avg. Heart Rate"
,
                value: 
143
.formatted(
                    .number.precision(.fractionLength(
0
))
                )
                
+
 
" bpm"

            )
            
Text
(
"Activity Rings"
)
            
ActivityRingsView
(healthStore: workoutManager.healthStore)
                .frame(width: 
50
, height: 
50
)
            
Button
(
"Done"
) {
                dismiss()
            }
        }
        .scenePadding()
    }
    .navigationTitle(
"Summary"
)
    .navigationBarTitleDisplayMode(.inline)
}
```

```swift
SummaryMetricView
(
    title: 
"Total Time"
,
    value: durationFormatter
        .string(from: workoutManager.workout
?
.duration 
??
 
0.0
) 
??
 
""

).accentColor(
Color
.yellow)

SummaryMetricView
(
    title: 
"Total Distance"
,
    value: 
Measurement
(
        value: workoutManager.workout
?
.totalDistance
?

            .doubleValue(for: .meter()) 
??
 
0
,
        unit: 
UnitLength
.meters
    ).formatted(
        .measurement(
            width: .abbreviated,
            usage: .road
        )
    )
).accentColor(
Color
.green)

SummaryMetricView
(
    title: 
"Total Energy"
,
    value: 
Measurement
(
        value: workoutManager.workout
?
.totalEnergyBurned
?

                        .doubleValue(for: .kilocalorie()) 
??
 
0
,
        unit: 
UnitEnergy
.kilocalories
    ).formatted(
        .measurement(
            width: .abbreviated,
            usage: .workout,
            numberFormat: .numeric(precision: .fractionLength(
0
))
        )
    )
).accentColor(
Color
.pink)

SummaryMetricView
(
    title: 
"Avg. Heart Rate"
,
    value: workoutManager.averageHeartRate
        .formatted(
            .number.precision(.fractionLength(
0
))
        )
    
+
 
" bpm"

).accentColor(
Color
.red)
```

```swift
@Environment
(\.isLuminanceReduced) 
var
 isLuminanceReduced
```

```swift
.tabViewStyle(
    
PageTabViewStyle
(indexDisplayMode: isLuminanceReduced 
?
 .never : .automatic)
)
.onChange(of: isLuminanceReduced) { 
_
 
in

    displayMetricsView()
}
```


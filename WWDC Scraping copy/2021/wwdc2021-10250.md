# Wwdc2021 10250

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Create custom symbolsDiscover how you can create custom iconography with the latest rendering modes in SF Symbols 3. We'll help you learn how to draw, edit, and annotate symbols, as well as explore more advanced techniques to improve the design process.

For a primer on working with custom symbol templates, we recommend first watching “Introducing SF Symbols” from WWDC19.ResourcesDownload SF SymbolsHuman Interface Guidelines: SF SymbolsHD VideoSD VideoRelated VideosWWDC21Explore the SF Symbols 3 appSF Symbols in SwiftUISF Symbols in UIKit and AppKitWhat’s new in SF Symbols

Discover how you can create custom iconography with the latest rendering modes in SF Symbols 3. We'll help you learn how to draw, edit, and annotate symbols, as well as explore more advanced techniques to improve the design process.

For a primer on working with custom symbol templates, we recommend first watching “Introducing SF Symbols” from WWDC19.

Download SF Symbols

Human Interface Guidelines: SF Symbols

HD VideoSD Video

HD Video

SD Video

Explore the SF Symbols 3 app

SF Symbols in SwiftUI

SF Symbols in UIKit and AppKit

What’s new in SF Symbols

Search this video…Hello, and welcome to WWDC.My name is Mike,and today we're going to walk throughhow to create a custom symbolthat takes advantage of the new featuresintroduced in SF Symbols 3.First, we'll recap what a custom symbol isand when you may want to use one.Custom symbols involve working with an SVG template.With SF Symbols 3, we have an all new template version,so we'll discuss the changes from previous versions.We'll walk through how to generate templates,edit your symbols, and prepare themfor rendering modes other than monochrome.We'll cover annotation, the process of addingrendering mode data to your symbols.We'll discuss some more advanced techniquesthat can drastically impact your workflows.And lastly, we'll wrap up by covering exportingfor Xcode and distributing your custom symbols.Let's get started. So, what is a custom symbol?Well, SF Symbols were introduced in 2019.In the initial release,there were more than 1,500 symbolsavailable to use in your apps.Since then, the library of symbols has only grown.Two years later, with SF Symbols 3,it totals over 3,000 symbols.Now, these symbols cover a wide varietyof subjects and categories.But your app may have a specific needthat isn't fully captured by an existing SF Symbolsuch as a teacup in a circle.This is where custom symbols come in.If you need a custom symbol, you would draw it as a seriesof vector paths and place it in a custom symbol template.The template is in the SVG format,and includes your designs and some guides.This template is the mechanism for your own symbolsto take advantage of all the featuresthat SF Symbols have to offer.This includes typographic alignmentto make sure your symbols look good next to text,margins for making sure symbols are optically centeredwith one another when used in lists and table views...Multiple weights to match text and adjust to featuressuch as accessibility bold on iOS...And lastly, three weight-matched scalesto adjust to the context of different UI elements.So those are the highlightsof SF Symbols and custom symbols.To review the basics of a custom symbol template,it's recommended to watch"Introducing SF Symbols" from WWDC 2019.To learn more about the design detailsbehind SF Symbols, check out"What's new in SF Symbols" from WWDC 2021.Now that we know when to use a custom symbol,let's review the template that makes them possible.To go along with the new featuresin SF Symbols 3, there's a new versionof the template, version 3.0.This version of the templatehas some important new capabilitiescompared to version 2.0,and it requires Xcode 13 or greater.In 3.0, the left-margin and right-margin guidelineshave more explicit names, indicating the design variantthat they correspond to.These margins, for example, have the suffix "Regular-M."This means that for additional controlover optical alignment you can add marginsto any variant in the template,and as long as they have a suffix matching oneof the design variants, they will be respected.More importantly, this format of the templateis able to embed information on how a symbol should lookin different rendering modes.We can embed data for existing modes,such as monochrome and multicolor,as well as data used by the new hierarchicaland palette modes.On top of all of this, the 3.0 templatesupports some advanced functionalitythat can empower you to accomplish moreby doing less.We'll talk about this in detailin the "advanced techniques" section.For the full specification of the new template,check out our updated documentation atDeveloper.Apple.com/SF-Symbols.Now that we're familiar with the new template,let's work on a custom symbol.So I'm working on a card game appwith some of my colleagues, and the SF Symbols apphas us covered for a lot of symbols that we need.There are four suits as well as a stackthat we can use to represent a deck of cards.The only thing missing is something we could useto represent the Queen of Hearts,which will play a special role in our app.I'm picturing a symbol of a crown with a heart on top.I can start by opening the SF Symbols appso I can customize an existing SF Symbol.This way, I'll have some point of referencefor stem thickness, scale, and alignment.If I search for "crown" in the SF Symbols app,I notice that we havea nice, unfilled version available.This will be a great starting point.All I need to add is the heart on top.I can select "crown," and from the contextual menuselect Duplicate as Custom Symbol.And under the Custom Symbols section in the sidebar,there's now a cell for the crown I just duplicated."Custom.crown" is a bit vague, so I'll rename it."Queen.heart" is much more descriptiveof what I have in mind.Now, this is a good way to start a new custom symbol,but you may have some symbols from past yearsas 1.0 and 2.0 custom symbol templates.That's not a problem.You can drop the existing symbol on the app,and it will automatically get addedto the current collection and up-convertedto a 3.0 template.Once the symbol is in my collection,whether I copied an SF Symbol, like "crown,"or imported a custom symbol like "Teacup.circle,"I can export it for editing in my design app of choicesuch as Sketch, Illustrator, or Figma.To do so, I can select File Export Template,or Command + E.This will export a 3.0 template in monochromeso that I can customize it.For symbols that originate in the SF Symbols app,you have two options for the initial setupof your 3.0 template: static and variable.Which setup you choose depends on your design goals.The static setup should be familiar,as it looks similar to a 2.0 template.There are 27 sets of paths and one setof explicit margins on regular in the medium scale.If you are targeting a particular weight and scale,or only plan on designing one or two variantsof your symbol, this setup will work well.The variable setup, on the other hand,will generate a 3.0 template that has three setsof paths and three sets of margins.If you plan on supporting all design variants,you may be interested in starting with this setup,since it gives you the minimum numberof design variants needed to generate the other 24.This requires that all your pathshave a very high level of compatibility and consistency.But don't worry about this now.We'll revisit these requirements and this setupof the template later in detail.For now, I'll export a static setupsince I'm only going to draw one or two variants.With my template open in my design application,I'm ready to begin editing.Like working with a 2.0 template,I can delete design variants I don't needand only design a few to start.For templates that don't have compatible paths,Regular-Medium is still required,so I'll start with that.I'll make room for the hearton the middle spire of the crown.And I want this symbol to look good in multicolor mode,so I'll adjust the paths so that I can assign colorsto particular parts of my symbol later.With these adjustments, I now have a single closed shapefor the hollow part of the crown.Next, I'll focus on the heart.Now, as I edit my symbol, I may use strokes to matchthe stem thickness of Regular-Mediumsince I am working on a stroked symbol.This gives me flexibility as I iterateon the proportions and size of the heart.But notice, I make sure to convertany live strokes to paths once I'm happy with the design.Converting to paths ensures that the stroked shapescan be filled with color later.Another benefit of converting to pathsis that I can make some minor optical adjustmentsfor when a stroke isn't precise enough.Like here, on the top half of the heart,the stroke is too large and round on the inside.Since I converted to paths,I can fine tune the curve to look less clunky.Now that I have one design variant drawn,this is a good time to talk about some itemsto keep in mind if you want your symbolto support rendering modes other than monochrome.Avoid using live strokes in the final design.Instead, make sure to convert any strokesto paths so that the resulting shapescan take on colors or hierarchy groups.Avoid using open paths.These are paths that have a start pointand an end point that do not connect.Since there's no closed fill area,these shapes will be unable to take on any colors.Instead, make sure all shapes in your designare closed with a defined fill area.Avoid special fills involving more than one colorsuch as gradients or effects like drop shadows.If these are present, they will overrideany multicolor or hierarchical datayou create for your symbol.Instead, stick to standard, flat fillswith no additional effects.Now, if we jump back to my design tool,the template is pretty bare.I may want to add semibold so that the symbolresponds to the accessibility bold featureon iOS.To do this, it's recommend to copy an existing drawingyou have to the desired layer and adjust it from there.This is a good habit to get into as it will resultin the same number of paths being usedacross your design variants.Preserving the number of pathsacross all design variantsis a requirement if you want to producea symbol with multicolor or hierarchical data.In this example, I've colored the pathsto indicate their number and order.Both design variants have four paths.The first two paths make up the folder,then we have a circle as the third path,and a plus sign as the fourth path.As a result, these two drawings look great in multicolor.These drawings also have four paths present,but, if you pay close attention, you'll notice I've shuffledthe order of the paths on the right.The main stroke of the folder is the first path in the drawingon the left,but the third path in the drawing on the right.When designs have the same number of pathsbut in different orders,they are likely to render very differently.And if we were to render these drawingsin multicolor, they don't match up.The green of the plus badge is being applied to the folderin the design variant on the right.Back to the Queen.heart symbol.It looks great so far.And since I was careful in how I created my design variants,I can make it even better by annotating itto support multicolor and hierarchical modes.Before I can do that, I'll need to importmy symbol back into the app.I can simply drop it on the existing cellwe have to update it in the SF Symbols app.Now, you're not required to annotate your symbols,but if you want to control your symbol's appearancein rendering modes other than monochrome,it's a good idea.To annotate, you'll use the individual pathsthat make up your symbol as your building blocks.From these, you create a set of layersfor each rendering mode.A layer is simply a collection of pathswith some associated rendering data.Here I have a layer for the crown with seven paths,and a layer for the heart with two paths.Layers in multicolor mode get assigned a color,and layers in hierarchical mode get assigned a hierarchy group.Layers have an explicit z-order where the layers on topwill block out the layers below.This is no different from creating layersin a design application.To begin annotating, I select my symbolin the app and enter the gallery view.In the inspector on the right,I can select the rendering mode tabso I can preview and annotate my symbol.I can choose between monochrome,hierarchical, palette, and multicolor.When in a mode other than monochrome,you will be able to add and edit your layerscorresponding to the active mode.And in the center we have our preview.Here we can interact with all the pathswe have at our disposal and assign them to layers.I'll start with the multicolor rendering mode first.I'll create a new layer for the crown.Then, I can select a color for the layer.For multicolor layers, I can choosefrom various system colors, or use my own custom color.It's recommended to use system-provided colorswhenever possible, as they will adapt to changesin the system's appearance to look great in light mode,dark mode, high contrast modes, and different vibrancy contexts.I'll use system yellow for the crown.And that's one layer done. Now, just for the heart.I'll add that on its own layer in red.I want to add a bit more depth to my crown in multicolor modeby setting colors on the hollow partsof my symbol.A path can be used in any number of layers.So, to achieve a stroked and filled effect,I've added a layerwith the paths that I want transparentand set it to a lower opacity.I'll do the same for the heart as well.That looks great.Next, I'll move onto hierarchical.I can construct my layers like before,but instead of colors, I assign hierarchical groupsranging from primary to tertiary.The hierarchical data will be usedin the hierarchical and palette rendering modes.I'll add a layer for my crown in secondary.And the heart in primary.I can see in the preview that a bitof the crown shows through the heartwhere they overlapbecause the heart isn't fully opaque.This is a common problem when workingwith overlapping shapes.To control how these overlaps get rendered,each layer has a toggle on the right.If inactive, transparent layers will blendwith the layers below, as shown on the left.This is the default behavior.If active, transparent layerswill clear what's behind themand render as if the other layersdon't exist, as shown on the right.With the clear behind toggle set,now my symbol behaves as expected.The hierarchical annotation data also gets usedby the palette rendering mode, so I'll make sureour layer interaction looks good there as well.This looks great.The cyan layer is transparent but since clear behindis enabled, we can't see any of the indigo crown behind it.In the palette rendering mode, I can assign two to three colorsto my symbol, instead of just onelike in hierarchical.Let's review the difference in how these two modes interprethierarchical annotations to apply color.Hierarchical uses one color and will apply itto your symbol's layers,varying the opacity based on the hierarchy level.In this case, we have a symbol with a primary groupand a tertiary group.Palette takes two to three colors,and the behavior will differ slightlybased on the number of colors passed.Passing two colors will distribute the colorsamong the available hierarchy groupsregardless of their level.For this symbol, since we only have two groups,the first color is applied to the primary groupand the second color is applied to the tertiary group.If you pass three colors, then each one is appliedto the corresponding hierarchy group.The first color is assigned to primary,the second to secondary, and third to tertiary.If you need to continue editing a symbolyou've already annotated,you would export a templateand edit the monochrome representationin your design tool.Then reimport the symbol and verifyyour annotations still render as expected.Special care must be taken when modifyingthe paths of an annotated symbolif you wish to retain your annotation data.Since this data requires the same number of pathsacross designs, you can safely add, remove, and adjust points.But removing or reordering whole pathswill make your design go out of syncwith its annotation data.In these cases, you will need to reannotatethe symbol to account for its new path structure.Now, I have my symbol in two design variants,and it's annotated so it will look greatin other rendering modes.I could stop here, but what if I need to supportother combinations of scale and weight?In this section, we'll talk about techniquesfor working with custom symbols that can save you timeif you plan on drawing three or more design variants.In the past, I would continue filling out the restof the variants in the template one by one,adjusting the paths to match the desired weight and scale.But now, with SF Symbols 3,there's a much better way to do this.If you provide just three design variantswith compatible data,you get the rest of the template for free.This is the structure of the SVG you will getwhen asking for a 3.0 variable template.Let's dive into the requirementsfor producing compatible designs.First, we checkfor what we refer to as design sources.These are Ultralight-Small,Regular-Small, and Black-Small.If those are present, then paths are assessedacross the sources to see if they match up.Let's focus on the Regular-Small sourceand the Black-Small source for a comparison.Across design variants, all paths must havethe same number and orderexactly as we discussed earlier with annotation requirements.I've colored the paths of the crown hereto indicate their order.There are nine paths, and they all match up.For example, the two paths for the heartare the eighth and ninth path in both design variants.So far, so good.Next, we'll check inside the corresponding pathsacross design variants.Let's compare the outside path for the heartof the regular source and the black source.Each path is constructed from a series of points.We have 24 points for the regular source in red,and 24 points for the black source in blue.To be compatible, points must match one-to-onebetween the corresponding paths.Each pair of matching points create an imaginary line,and moving each point along its respective lineallows us to blend between the two compatible paths.Since each point in the regular sourcecorresponds to a point in the black source,we can do just that.We'll focus in on the smaller heartin red and observe the pathas it blends with the larger heart in blue.Blending is what allows for a new pathto be generated anywhere between the compatible paths.This blending is known as "interpolation."Now that we know how interpolation worksat the point level, let's zoom outand apply it to the entire symbol.You'll notice that any weight between ultralight,regular, and black can be computed.This is the mechanism for the weight compensationnecessary to generatethe medium and large scale design variantsfor your symbols.Let's recap those requirements.For a symbol to be considered interpolatable,it needs three things.First, the three design sources.Ultralight-Small, Regular-Small, and Black-Small.Second, path compatibility.All paths must match between the sources.And lastly, point compatibility.All matching paths must have the same number of points.So how would I go about making one of theseinterpolatable symbols?Well, instead of a static setup, I would start by exportinga 3.0 template from the SF Symbols appwith a variable setup.This way, I have margins and outlinesfor the three source designs.I would start with Regular-Small and add my heart on top,as we did earlier for Regular-Medium.This time it is just for a smaller scale.Since interpolation has very strict requirements,it's recommended to getthe initial Regular-Small design variantinto good shape before working on the other sources.When you do go to work on the Ultralight-Smalland Black-Small sources, it is best to copyand paste the Regular-Small pathsand only reposition the points from there.This is critical to make sure your custom symbolis capable of generating the other design variants.So let's review that one more time.When you want your symbol to be interpolatable,avoid adding or removing points,as this will break compatibility.Instead, only adjust the existing points.Moving points and control points is fine,since this preserves the compatibilitybetween designs.Once ready, I can drop my updated templateon my custom symbols cell in the app,and annotate it just like I did before.Since I was careful in drawing my sources,I have all 27 variants covered,and I'm all set to hand this off to get implemented.Now that we've covered ways to createyour custom symbol, let's talk about next stepssuch as how to distribute your symbol.When distributing your symbol, you have two options.You can export a 2.0 template or a 3.0 template.2.0 templates should only be usedif you plan on back deploying to an older OS such as iOS 14.It only contains monochrome so make sureyour symbol makes sense when used in that mode.Converting to a 2.0 template is a lossy operation.Annotation data and explicit margins are removedsince the older OS will not understand them.3.0 can embed all the multicolor and hierarchical datayou've added, as well as any custom margins,but it is not backwards compatible.Careful here, this template is nota source artifact for editing.Current design tools may not be entirely compatiblewith the embedded annotation data.If you need to make more edits to your symbolor share it with a colleague,it should be imported back into the SF Symbols app.From there, you can workon the monochrome representation without riskof dropping your annotations.The 3.0 template that you export should gostraight to Xcode or back to the SF Symbols app.If your minimum deployment target is iOS 14,you will need to export both a 2.0 and a 3.0 templateand use the appropriate asset based on a version check.If your minimum deployment targetis iOS15 or later,you only need to export a 3.0 template.If you are sharing a symbolwith a colleague, export a 3.0 template.They can then import that into their SF Symbols appto continue editing and annotating.We covered a lot of content today,so let's do a quick recap.We talked about the new 3.0 custom symbol template,the features it supports, and how to edit it.We covered how to prepare your symbols for annotationand add multicolor and hierarchical data.We explored a more advanced workflowthat opts into some stricter requirementsto take advantage of interpolation.And we just finished talking abouthow to distribute your symbols.Once you've delivered your symbols,they are ready to be used by the OS.There are some new APIs you can usefor rendering your symbol in the appropriate mode.To learn more about calling SF Symbolsand custom symbols in code,check out "SF Symbols in UIKit and AppKit"and "SF Symbols in SwiftUI," both from WWDC 2021.That's custom symbols from start to finish.I hope you enjoy creating and annotating your own symbols.[upbeat music]

Hello, and welcome to WWDC.My name is Mike,and today we're going to walk throughhow to create a custom symbolthat takes advantage of the new featuresintroduced in SF Symbols 3.First, we'll recap what a custom symbol isand when you may want to use one.Custom symbols involve working with an SVG template.With SF Symbols 3, we have an all new template version,so we'll discuss the changes from previous versions.

We'll walk through how to generate templates,edit your symbols, and prepare themfor rendering modes other than monochrome.

We'll cover annotation, the process of addingrendering mode data to your symbols.

We'll discuss some more advanced techniquesthat can drastically impact your workflows.

And lastly, we'll wrap up by covering exportingfor Xcode and distributing your custom symbols.Let's get started. So, what is a custom symbol?Well, SF Symbols were introduced in 2019.

In the initial release,there were more than 1,500 symbolsavailable to use in your apps.Since then, the library of symbols has only grown.Two years later, with SF Symbols 3,it totals over 3,000 symbols.Now, these symbols cover a wide varietyof subjects and categories.But your app may have a specific needthat isn't fully captured by an existing SF Symbolsuch as a teacup in a circle.This is where custom symbols come in.

If you need a custom symbol, you would draw it as a seriesof vector paths and place it in a custom symbol template.The template is in the SVG format,and includes your designs and some guides.

This template is the mechanism for your own symbolsto take advantage of all the featuresthat SF Symbols have to offer.This includes typographic alignmentto make sure your symbols look good next to text,margins for making sure symbols are optically centeredwith one another when used in lists and table views...

Multiple weights to match text and adjust to featuressuch as accessibility bold on iOS...

And lastly, three weight-matched scalesto adjust to the context of different UI elements.So those are the highlightsof SF Symbols and custom symbols.To review the basics of a custom symbol template,it's recommended to watch"Introducing SF Symbols" from WWDC 2019.To learn more about the design detailsbehind SF Symbols, check out"What's new in SF Symbols" from WWDC 2021.Now that we know when to use a custom symbol,let's review the template that makes them possible.To go along with the new featuresin SF Symbols 3, there's a new versionof the template, version 3.0.This version of the templatehas some important new capabilitiescompared to version 2.0,and it requires Xcode 13 or greater.

In 3.0, the left-margin and right-margin guidelineshave more explicit names, indicating the design variantthat they correspond to.

These margins, for example, have the suffix "Regular-M."This means that for additional controlover optical alignment you can add marginsto any variant in the template,and as long as they have a suffix matching oneof the design variants, they will be respected.

More importantly, this format of the templateis able to embed information on how a symbol should lookin different rendering modes.We can embed data for existing modes,such as monochrome and multicolor,as well as data used by the new hierarchicaland palette modes.On top of all of this, the 3.0 templatesupports some advanced functionalitythat can empower you to accomplish moreby doing less.We'll talk about this in detailin the "advanced techniques" section.For the full specification of the new template,check out our updated documentation atDeveloper.Apple.com/SF-Symbols.

Now that we're familiar with the new template,let's work on a custom symbol.So I'm working on a card game appwith some of my colleagues, and the SF Symbols apphas us covered for a lot of symbols that we need.There are four suits as well as a stackthat we can use to represent a deck of cards.The only thing missing is something we could useto represent the Queen of Hearts,which will play a special role in our app.I'm picturing a symbol of a crown with a heart on top.I can start by opening the SF Symbols appso I can customize an existing SF Symbol.This way, I'll have some point of referencefor stem thickness, scale, and alignment.If I search for "crown" in the SF Symbols app,I notice that we havea nice, unfilled version available.This will be a great starting point.All I need to add is the heart on top.

I can select "crown," and from the contextual menuselect Duplicate as Custom Symbol.And under the Custom Symbols section in the sidebar,there's now a cell for the crown I just duplicated."Custom.crown" is a bit vague, so I'll rename it.

"Queen.heart" is much more descriptiveof what I have in mind.Now, this is a good way to start a new custom symbol,but you may have some symbols from past yearsas 1.0 and 2.0 custom symbol templates.That's not a problem.You can drop the existing symbol on the app,and it will automatically get addedto the current collection and up-convertedto a 3.0 template.

Once the symbol is in my collection,whether I copied an SF Symbol, like "crown,"or imported a custom symbol like "Teacup.circle,"I can export it for editing in my design app of choicesuch as Sketch, Illustrator, or Figma.To do so, I can select File Export Template,or Command + E.This will export a 3.0 template in monochromeso that I can customize it.

For symbols that originate in the SF Symbols app,you have two options for the initial setupof your 3.0 template: static and variable.Which setup you choose depends on your design goals.

The static setup should be familiar,as it looks similar to a 2.0 template.There are 27 sets of paths and one setof explicit margins on regular in the medium scale.If you are targeting a particular weight and scale,or only plan on designing one or two variantsof your symbol, this setup will work well.The variable setup, on the other hand,will generate a 3.0 template that has three setsof paths and three sets of margins.If you plan on supporting all design variants,you may be interested in starting with this setup,since it gives you the minimum numberof design variants needed to generate the other 24.This requires that all your pathshave a very high level of compatibility and consistency.

But don't worry about this now.We'll revisit these requirements and this setupof the template later in detail.For now, I'll export a static setupsince I'm only going to draw one or two variants.With my template open in my design application,I'm ready to begin editing.

Like working with a 2.0 template,I can delete design variants I don't needand only design a few to start.

For templates that don't have compatible paths,Regular-Medium is still required,so I'll start with that.

I'll make room for the hearton the middle spire of the crown.And I want this symbol to look good in multicolor mode,so I'll adjust the paths so that I can assign colorsto particular parts of my symbol later.With these adjustments, I now have a single closed shapefor the hollow part of the crown.Next, I'll focus on the heart.

Now, as I edit my symbol, I may use strokes to matchthe stem thickness of Regular-Mediumsince I am working on a stroked symbol.This gives me flexibility as I iterateon the proportions and size of the heart.

But notice, I make sure to convertany live strokes to paths once I'm happy with the design.Converting to paths ensures that the stroked shapescan be filled with color later.Another benefit of converting to pathsis that I can make some minor optical adjustmentsfor when a stroke isn't precise enough.Like here, on the top half of the heart,the stroke is too large and round on the inside.Since I converted to paths,I can fine tune the curve to look less clunky.

Now that I have one design variant drawn,this is a good time to talk about some itemsto keep in mind if you want your symbolto support rendering modes other than monochrome.

Avoid using live strokes in the final design.Instead, make sure to convert any strokesto paths so that the resulting shapescan take on colors or hierarchy groups.

Avoid using open paths.These are paths that have a start pointand an end point that do not connect.Since there's no closed fill area,these shapes will be unable to take on any colors.Instead, make sure all shapes in your designare closed with a defined fill area.

Avoid special fills involving more than one colorsuch as gradients or effects like drop shadows.If these are present, they will overrideany multicolor or hierarchical datayou create for your symbol.Instead, stick to standard, flat fillswith no additional effects.Now, if we jump back to my design tool,the template is pretty bare.

I may want to add semibold so that the symbolresponds to the accessibility bold featureon iOS.To do this, it's recommend to copy an existing drawingyou have to the desired layer and adjust it from there.

This is a good habit to get into as it will resultin the same number of paths being usedacross your design variants.

Preserving the number of pathsacross all design variantsis a requirement if you want to producea symbol with multicolor or hierarchical data.

In this example, I've colored the pathsto indicate their number and order.Both design variants have four paths.The first two paths make up the folder,then we have a circle as the third path,and a plus sign as the fourth path.

As a result, these two drawings look great in multicolor.

These drawings also have four paths present,but, if you pay close attention, you'll notice I've shuffledthe order of the paths on the right.

The main stroke of the folder is the first path in the drawingon the left,but the third path in the drawing on the right.When designs have the same number of pathsbut in different orders,they are likely to render very differently.

And if we were to render these drawingsin multicolor, they don't match up.The green of the plus badge is being applied to the folderin the design variant on the right.

Back to the Queen.heart symbol.It looks great so far.And since I was careful in how I created my design variants,I can make it even better by annotating itto support multicolor and hierarchical modes.

Before I can do that, I'll need to importmy symbol back into the app.I can simply drop it on the existing cellwe have to update it in the SF Symbols app.

Now, you're not required to annotate your symbols,but if you want to control your symbol's appearancein rendering modes other than monochrome,it's a good idea.

To annotate, you'll use the individual pathsthat make up your symbol as your building blocks.

From these, you create a set of layersfor each rendering mode.A layer is simply a collection of pathswith some associated rendering data.Here I have a layer for the crown with seven paths,and a layer for the heart with two paths.

Layers in multicolor mode get assigned a color,and layers in hierarchical mode get assigned a hierarchy group.

Layers have an explicit z-order where the layers on topwill block out the layers below.This is no different from creating layersin a design application.To begin annotating, I select my symbolin the app and enter the gallery view.In the inspector on the right,I can select the rendering mode tabso I can preview and annotate my symbol.

I can choose between monochrome,hierarchical, palette, and multicolor.When in a mode other than monochrome,you will be able to add and edit your layerscorresponding to the active mode.

And in the center we have our preview.Here we can interact with all the pathswe have at our disposal and assign them to layers.

I'll start with the multicolor rendering mode first.

I'll create a new layer for the crown.

Then, I can select a color for the layer.For multicolor layers, I can choosefrom various system colors, or use my own custom color.It's recommended to use system-provided colorswhenever possible, as they will adapt to changesin the system's appearance to look great in light mode,dark mode, high contrast modes, and different vibrancy contexts.I'll use system yellow for the crown.

And that's one layer done. Now, just for the heart.I'll add that on its own layer in red.

I want to add a bit more depth to my crown in multicolor modeby setting colors on the hollow partsof my symbol.

A path can be used in any number of layers.So, to achieve a stroked and filled effect,I've added a layerwith the paths that I want transparentand set it to a lower opacity.

I'll do the same for the heart as well.

That looks great.Next, I'll move onto hierarchical.

I can construct my layers like before,but instead of colors, I assign hierarchical groupsranging from primary to tertiary.The hierarchical data will be usedin the hierarchical and palette rendering modes.

I'll add a layer for my crown in secondary.

And the heart in primary.

I can see in the preview that a bitof the crown shows through the heartwhere they overlapbecause the heart isn't fully opaque.This is a common problem when workingwith overlapping shapes.

To control how these overlaps get rendered,each layer has a toggle on the right.

If inactive, transparent layers will blendwith the layers below, as shown on the left.This is the default behavior.If active, transparent layerswill clear what's behind themand render as if the other layersdon't exist, as shown on the right.

With the clear behind toggle set,now my symbol behaves as expected.The hierarchical annotation data also gets usedby the palette rendering mode, so I'll make sureour layer interaction looks good there as well.

This looks great.The cyan layer is transparent but since clear behindis enabled, we can't see any of the indigo crown behind it.

In the palette rendering mode, I can assign two to three colorsto my symbol, instead of just onelike in hierarchical.Let's review the difference in how these two modes interprethierarchical annotations to apply color.

Hierarchical uses one color and will apply itto your symbol's layers,varying the opacity based on the hierarchy level.In this case, we have a symbol with a primary groupand a tertiary group.Palette takes two to three colors,and the behavior will differ slightlybased on the number of colors passed.Passing two colors will distribute the colorsamong the available hierarchy groupsregardless of their level.For this symbol, since we only have two groups,the first color is applied to the primary groupand the second color is applied to the tertiary group.

If you pass three colors, then each one is appliedto the corresponding hierarchy group.The first color is assigned to primary,the second to secondary, and third to tertiary.

If you need to continue editing a symbolyou've already annotated,you would export a templateand edit the monochrome representationin your design tool.Then reimport the symbol and verifyyour annotations still render as expected.Special care must be taken when modifyingthe paths of an annotated symbolif you wish to retain your annotation data.Since this data requires the same number of pathsacross designs, you can safely add, remove, and adjust points.

But removing or reordering whole pathswill make your design go out of syncwith its annotation data.In these cases, you will need to reannotatethe symbol to account for its new path structure.Now, I have my symbol in two design variants,and it's annotated so it will look greatin other rendering modes.I could stop here, but what if I need to supportother combinations of scale and weight?In this section, we'll talk about techniquesfor working with custom symbols that can save you timeif you plan on drawing three or more design variants.

In the past, I would continue filling out the restof the variants in the template one by one,adjusting the paths to match the desired weight and scale.But now, with SF Symbols 3,there's a much better way to do this.If you provide just three design variantswith compatible data,you get the rest of the template for free.This is the structure of the SVG you will getwhen asking for a 3.0 variable template.Let's dive into the requirementsfor producing compatible designs.First, we checkfor what we refer to as design sources.These are Ultralight-Small,Regular-Small, and Black-Small.If those are present, then paths are assessedacross the sources to see if they match up.Let's focus on the Regular-Small sourceand the Black-Small source for a comparison.

Across design variants, all paths must havethe same number and orderexactly as we discussed earlier with annotation requirements.I've colored the paths of the crown hereto indicate their order.There are nine paths, and they all match up.

For example, the two paths for the heartare the eighth and ninth path in both design variants.So far, so good.Next, we'll check inside the corresponding pathsacross design variants.Let's compare the outside path for the heartof the regular source and the black source.Each path is constructed from a series of points.We have 24 points for the regular source in red,and 24 points for the black source in blue.

To be compatible, points must match one-to-onebetween the corresponding paths.Each pair of matching points create an imaginary line,and moving each point along its respective lineallows us to blend between the two compatible paths.

Since each point in the regular sourcecorresponds to a point in the black source,we can do just that.

We'll focus in on the smaller heartin red and observe the pathas it blends with the larger heart in blue.

Blending is what allows for a new pathto be generated anywhere between the compatible paths.This blending is known as "interpolation."Now that we know how interpolation worksat the point level, let's zoom outand apply it to the entire symbol.

You'll notice that any weight between ultralight,regular, and black can be computed.

This is the mechanism for the weight compensationnecessary to generatethe medium and large scale design variantsfor your symbols.

Let's recap those requirements.For a symbol to be considered interpolatable,it needs three things.

First, the three design sources.Ultralight-Small, Regular-Small, and Black-Small.

Second, path compatibility.

All paths must match between the sources.And lastly, point compatibility.All matching paths must have the same number of points.

So how would I go about making one of theseinterpolatable symbols?Well, instead of a static setup, I would start by exportinga 3.0 template from the SF Symbols appwith a variable setup.This way, I have margins and outlinesfor the three source designs.

I would start with Regular-Small and add my heart on top,as we did earlier for Regular-Medium.This time it is just for a smaller scale.

Since interpolation has very strict requirements,it's recommended to getthe initial Regular-Small design variantinto good shape before working on the other sources.

When you do go to work on the Ultralight-Smalland Black-Small sources, it is best to copyand paste the Regular-Small pathsand only reposition the points from there.

This is critical to make sure your custom symbolis capable of generating the other design variants.So let's review that one more time.

When you want your symbol to be interpolatable,avoid adding or removing points,as this will break compatibility.

Instead, only adjust the existing points.Moving points and control points is fine,since this preserves the compatibilitybetween designs.

Once ready, I can drop my updated templateon my custom symbols cell in the app,and annotate it just like I did before.Since I was careful in drawing my sources,I have all 27 variants covered,and I'm all set to hand this off to get implemented.Now that we've covered ways to createyour custom symbol, let's talk about next stepssuch as how to distribute your symbol.

When distributing your symbol, you have two options.You can export a 2.0 template or a 3.0 template.

2.0 templates should only be usedif you plan on back deploying to an older OS such as iOS 14.It only contains monochrome so make sureyour symbol makes sense when used in that mode.

Converting to a 2.0 template is a lossy operation.Annotation data and explicit margins are removedsince the older OS will not understand them.

3.0 can embed all the multicolor and hierarchical datayou've added, as well as any custom margins,but it is not backwards compatible.

Careful here, this template is nota source artifact for editing.Current design tools may not be entirely compatiblewith the embedded annotation data.If you need to make more edits to your symbolor share it with a colleague,it should be imported back into the SF Symbols app.From there, you can workon the monochrome representation without riskof dropping your annotations.

The 3.0 template that you export should gostraight to Xcode or back to the SF Symbols app.If your minimum deployment target is iOS 14,you will need to export both a 2.0 and a 3.0 templateand use the appropriate asset based on a version check.

If your minimum deployment targetis iOS15 or later,you only need to export a 3.0 template.

If you are sharing a symbolwith a colleague, export a 3.0 template.They can then import that into their SF Symbols appto continue editing and annotating.We covered a lot of content today,so let's do a quick recap.We talked about the new 3.0 custom symbol template,the features it supports, and how to edit it.

We covered how to prepare your symbols for annotationand add multicolor and hierarchical data.

We explored a more advanced workflowthat opts into some stricter requirementsto take advantage of interpolation.And we just finished talking abouthow to distribute your symbols.

Once you've delivered your symbols,they are ready to be used by the OS.There are some new APIs you can usefor rendering your symbol in the appropriate mode.

To learn more about calling SF Symbolsand custom symbols in code,check out "SF Symbols in UIKit and AppKit"and "SF Symbols in SwiftUI," both from WWDC 2021.That's custom symbols from start to finish.I hope you enjoy creating and annotating your own symbols.[upbeat music]

## Code Samples


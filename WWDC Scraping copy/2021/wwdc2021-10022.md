# Wwdc2021 10022

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Demystify SwiftUIPeek behind the curtain into the core tenets of SwiftUI philosophy: Identity, Lifetime, and Dependencies. Find out about common patterns, learn the principles that drive the framework, and discover how you can use them to guarantee correctness and performance for your app.ResourcesHD VideoSD VideoRelated VideosWWDC23Demystify SwiftUI performanceWWDC22SwiftUI on iPad: Organize your interfaceWWDC21Discover concurrency in SwiftUISwiftUI Accessibility: Beyond the basicsWhat's new in SwiftUIWWDC20Data Essentials in SwiftUIWWDC19SwiftUI Essentials

Peek behind the curtain into the core tenets of SwiftUI philosophy: Identity, Lifetime, and Dependencies. Find out about common patterns, learn the principles that drive the framework, and discover how you can use them to guarantee correctness and performance for your app.

HD VideoSD Video

HD Video

SD Video

Demystify SwiftUI performance

SwiftUI on iPad: Organize your interface

Discover concurrency in SwiftUI

SwiftUI Accessibility: Beyond the basics

What's new in SwiftUI

Data Essentials in SwiftUI

SwiftUI Essentials

Search this video…♪ Bass music playing ♪♪Matt Ricketson: Hi, I'm Matt,and later on I'll be joined by Luca and Raj.Today, we're going to demystify SwiftUI.Now, we've heard it many times beforethat SwiftUI is a declarative UI framework.That means that you describe what you wantfor your app at a high level,and SwiftUI decides exactly how to make it happen.Now, most of the time, this works great!And that's when SwiftUI feels magical.But there will always be those momentswhen SwiftUI does something that you might not expect.And in those moments, it helps to understanda bit more about what SwiftUI is doing behind the scenesto build a better intuition for how to get the resultsyou're looking for.So today's question is,When SwiftUI looks at your code, what does it see?The answer is three things:identity, lifetime, and dependencies.Identity is how SwiftUI recognizes elementsas the same or distinct across multiple updates of your app.Lifetime is how SwiftUI tracks the existence of viewsand data over time.And dependencies are how SwiftUI understandswhen your interface needs to be updated and why.Together, these three concepts inform how SwiftUI decideswhat needs to change, how, and when,resulting in the dynamic user interface you see onscreen.Today, we'll talk about each of these three concepts in more depth.Let's start with identity,and I have a few friends here to help me.These Ruby Spaniels are adorable,but they're also the subject of a deep philosophical question.Are these two different dogs?Or are these, in fact, two pictures of the same dog?The truth is, it's impossible to say!We just don't have enough information.But this question of whether things are the same or differentis at the heart of what we call "identity."Identity isn't just important for dogs though.It's also a critical aspectof how SwiftUI understands your app.Let's look at an example.This is an app I made called "Good Dog, Bad Dog,"which helps me keep trackof whether my furry friend has been on her best behavior.It's pretty simple.I can just tap anywhere on the screento flip between the good and bad states.So what does identity have to do with my app?Well, it's actually very similar to that philosophical questionwe just asked about the dogs.Looking at those icons, do those seem like two different views,completely distinct from each other?Or could they be the same view,just in a different place and with a different color?That distinction actually matters a great dealbecause it changes how our interfacetransitions from one state to another.Let's say those icons are, in fact, different views.That means the icons should transition independently,such as fading in and out.But what if they're, in fact, the same view?That would instead imply that the viewshould slide across the screen during the transitionbecause it's the same viewmoving from one location to the other.So connecting views across different states is important,because that's how SwiftUI understandshow to transition between them.This is the key concept behind view identity.Views that share the same identityrepresent different states of the same conceptual UI element.In contrast, views that represent distinct UI elementswill always have different identities.Later in the talk, Luca and Raj will talk aboutthe practical impacts of view identityon your app's data and update cycle.For now, let's look at how identityis represented in your code, focusing onthe two different types of identity used by SwiftUI.First, explicit identity:using custom or data-driven identifiers.And second, structural identity: distinguishing viewsby their type and position in the view hierarchy.Now, to help understand these concepts,let me introduce you to some more of my friends.OK, remember that it can be difficult to tell dogs apart,especially when they look the same.So what kind of extra informationwould help us identify our dogs?One way would be to simply ask for their names.If two dogs look the same and also share the same name,then I'd say it's pretty likelythat they're, in fact, the same dog.But if they have different names,then we can guarantee that they are,in fact, different dogs.Assigning names or identifiers like thisis a form of explicit identity.Explicit identity is powerful and flexible,but does require that someone, somewherekeeps track of all those names.One form of explicit identityyou may already be used to is pointer identity,which is used throughout UIKit and AppKit.Now, SwiftUI doesn't use pointer identity,but learning about it will help you better understandhow and why SwiftUI works differently.Let's take a quick look.Consider a UIKit or AppKit view hierarchy, like this one.Since UIViews and NSViews are classes,they each have a unique pointer to their memory allocation.The pointer is a natural source of explicit identity.We can refer to individual views just using their pointer,and if two views share the same pointer,we can guarantee that they are really the same view.But SwiftUI doesn't use pointersbecause SwiftUI views are value types,commonly represented as structs instead of classes.In the "SwiftUI essentials" talk from 2019,we discussed why SwiftUI uses value typesinstead of classes for its views,so I recommend watching that talk to learn more.For now, the important thing to know is thatvalue types do not have a canonical reference thatSwiftUI can use as a persistent identity for its views.Instead, SwiftUI relies on other forms of explicit identity.For example, consider this list of rescue dogs.The id parameter used here is a form of explicit identity.The dog tag ID of each rescue dog is usedto explicitly identify its corresponding view in the list.If the collection of rescue dogs changes,SwiftUI can use those IDs to understand what exactly changedand generate the correct animations within the list.In this case, SwiftUI was even able to correctly animate viewsmoving between different sections.Let's look at a more advanced example.Here, we're using a ScrollViewReaderto jump to the top of the view using a button at the bottom.The id(_:) modifier provides a way to explicitly identify a viewusing a custom identifier --in this case, our header view at the top of the page.Then we can pass that identifierto the scroll view proxy's scrollTo(_:) methodto tell SwiftUI to go to that specific view.What's great about this is thatwe don't have to explicitly identify every view,just the ones we need to refer to elsewhere in the code,like our header text.By comparison, the ScrollViewReader,ScrollView, backstory Text, and Bbuttondo not need explicit identifiers.But just because their identity isn't explicit,that doesn't mean these views have no identity at allbecause every view has an identity,even if it's not explicit.This is where structural identity comes in.SwiftUI uses the structure of your view hierarchyto generate implicit identities for your viewsso you don't have to.Now, let me bring in some more of my friendsto help explain what I mean by that.Let's say we have two similar dogsbut we don't know their names,but we still need to identify each one.Well, suppose these are very good dogsand they're capable of sitting very still.If we can guarantee they don't move,we could identify them just based on where they're sitting,like "The dog on the left" or "The dog on the right".We're using the relative arrangement of our subjectsto distinguish them from each other --that's structural identity.SwiftUI leverages structural identity throughout its API,and a classic example is when you use if statementsand other conditional logic within your View code.The structure of the conditional statementgives us a clear way to identify each view.The first view only shows when the condition is true,while the second view only shows when the condition is false.That means we can always tell which view is which,even if they happen to look similarly.However, this only works if SwiftUI can statically guaranteethat these views stay where they are and never swap places.SwiftUI accomplishes this by looking at the type structureof your view hierarchy.When SwiftUI looks at your views,it sees their generic types --in this case, our if statement translated intoa _ConditionalContent view,which is generic over its true and false content.This translation is powered by a ViewBuilder,which is a type of result builder in Swift.The View protocol implicitly wraps its body propertyin a ViewBuilder, which constructs a single generic viewfrom the logic statements in our property.The some View return type of our body propertyis a placeholder that represents this static composite type,hiding it away so it doesn't clutter up our code.Using this generic type, SwiftUI can guaranteethat the true view will always be the AdoptionDirectory,while the False view will always be the DogList,allowing them to be assigned an implicit, stable identitybehind the scenes.In fact, this is the key to understandingthe Good Dog, Bad Dog app from earlier.With the code on the top, we have an if statementthat defines different views for each conditional branch.This will cause the views to transition in and outbecause SwiftUI understands that each branch of the if statementrepresents a different view with a distinct identity.Alternatively, we could just have a single PawViewthat changes its layout and color.When it transitions to a different state,the view will smoothly slide to its next position.That's because we're modifying a single viewwith a consistent identity.Both of these strategies can work,but SwiftUI generally recommends the second approach.By default, try to preserve identityand provide more fluid transitions.This also helps preserve your view's lifetime and state,which Luca will talk about in more detail later on.Now that we understand structural identity,we need to talk about its evil nemesis, AnyView.To understand the impact of using AnyView,let's look at the effect that it hason the structure of your views.Earlier we wrote this if statementto switch between the AdoptionDirectoryand the DogList.When SwiftUI looks at this code,it sees the generic type structure on the right.Now let's look at a different example,one that uses AnyView extensively.This is a helper function I've writtento get a view that represents a dog's breed.Each conditional branch in the functionreturns a different kind of view,so I've wrapped them all in AnyViewsbecause Swift requires a single return typefor the whole function.Unfortunately, this also means that SwiftUI can't seethe conditional structure of my code.Instead, it just sees an AnyViewas a return type of the function.This is because AnyView is what's calleda "type-erasing wrapper type" --it hides the type of the view it is wrappingfrom its generic signature.But perhaps more importantly,this code is also just really hard to readfor us mere humans.Let's see if we can simplify this codeand also make more of its structure visible to SwiftUI.First, it looks like this branch is conditionally addinga SheepView alongside our BorderCollieViewif there are sheep nearby.We can simplify this by conditionally adding the viewinside the HStack rather thanconditionally adding the HStack around our views.With that change, it's now easy to seethat we're just returning a single view from each branch,so our local dogView variable isn't necessary.Instead, we can replace it with return statementsinside of each branch.As we saw earlier, normal SwiftUI View codecan use if statements that return different types of views.But if we just try deleting the return statementsand AnyViews from our code,we see some errors and warnings appear.This is because SwiftUI requires a single return typefrom our helper function.So how can we avoid these errors?Recall that the body property of a view is special,because the View protocol implicitly wraps itin a ViewBuilder.This translates the logic in the propertyinto a single, generic view structure.Now, Swift does not infer helper functionsto be view builders by default, but we can opt into thatby manually applying the ViewBuilder attribute ourselves.And that allows us to remove the return statementsand the AnyView wrappers without any warnings or errors.OK, our code is looking pretty good now!We've gotten rid of all of the AnyViews,making it easier to read than before.And if we look at the type signature of the result,it now exactly replicates the conditional logicof our function with a tree of conditional content,providing SwiftUI with a much richer perspectiveof the view and the identities of its components.But there's one more small improvement we can make.The top level of our function is just matchingagainst different cases of the dog's breed.This seems like an excellent use case for a switch statement,which are also supported by view builders.Now it's even easier to quickly understandall the different cases of our view.And because switch statements are really just syntactic sugarfor conditional statements,our resulting view's type signature on the rightremains exactly the same.Stepping back, we just showed youhow AnyViews erase type information from your code,and walked through how to get rid of unnecessary AnyViewsby leveraging view builders.In general, we recommend avoiding AnyViewswhenever possible.Having too many AnyViews will often make codeharder to read and understand.Traditional control flow statementslike if/else and switch make it much easierto see the different possible states of a view.And because AnyView hides static type informationfrom the compiler,it can sometimes prevent helpful diagnostic errors and warningsfrom being surfaced in your code.Finally, keep in mind that using AnyView when you don't need tocan result in worse performance.When possible, use generics to preserve static type informationrather than passing AnyViews around your code.And with that, we've finished introducing the basic typesof view identity in SwiftUI.With explicit identity,we can tie the identity of our views to our data,or provide custom identifiers to refer to specific views.And with structural identity,we've learned how SwiftUI can identify our viewsjust based on their type and positionwithin the view hierarchy.And now I'll hand things over to Lucato discuss how the identity of your viewsis related to their lifetime and state.Luca Bernardi: Thanks, Matt.Now that we understand how SwiftUI identifies your views,let's explore how identityties into the lifetime of your views and data.This will help you better understand how SwiftUI works.To help illustrate this,I'm also going to bring in a friend.This is Theseus.Isn't he adorable, too?Someone will say more adorable, but I digress.It is very intuitive for us to think thatonce we name our favorite pet,he'll always be the same adorable cat,even when he is in different statesand he moves throughout the day.When we look at him one moment, he might be sleepyand a moment later, being a proper cat,he's annoyed by my presence -- but he'll always be Theseus.This is the essence of connecting identity to lifetime.Identity allows us to define a stable elementfor different values over time.In other words, it allows us to introduce continuity over time.You might be wondering, how does this apply to SwiftUI?So let's bring back a cat-friendly versionof the app Matt was working on.Just like Theseus can be in different statesat different moments in time, our views are alsoin different states throughout their lifetime.Every single state is a different value for our view.Identity connects these different valuesas a single entity -- a view -- over time.Let's look at some code to clarify this.Here we have a simple viewthat displays the intensity of purring.Spoiler: Theseus is pretty loud.Through the evaluation of body,SwiftUI will create a new value for this view;in this case, with an intensity value of 25.Theseus is getting hungry and wants more attention.body is invoked again with a higher intensity,and the new value for the view is created.These are two distinct valuescreated from the same view definition.SwiftUI will keep around a copy of the valueto perform a comparison and know if the view has changed.But after that, the value is destroyed.What it is important to understand here is thatthe view value is different from the view identity.View values are ephemeraland you should not rely on their lifetime.But what you can control is their identity.When a view is first created and it appears,SwiftUI assigns it an identity using a combinationof the techniques discussed before.Over time, driven by updates,new values for the view are created.But from SwiftUI's perspective, these represent the same view.Once the identity of the view changesor the view is removed, its lifetime ends.Whenever we talk about the lifetime of a view,we are referring to the duration of the identityassociated with that view.Being able to connectthe identity of a view with its lifetimeis fundamental to understand how SwiftUI persists your state.So let's bring State and StateObject into the picture.When SwiftUI is looking at your viewand sees a State or a StateObject,it knows that it needs to persist that piece of datathroughout the view's lifetime.In other words, State and StateObjectare the persistent storageassociated with your view's identity.At the beginning of a view's identity,when it's created for the first time,SwiftUI is going to allocate storage in memoryfor State and StateObject using their initial values.Here we are focusing on the title state.Throughout the lifetime of the view,SwiftUI will persist this storage as it gets mutatedand the view's body is re-evaluated.Let's look at a concrete example of how changes in identityaffect the persistence of state.This is an interesting example because we have the same viewbut in two separate branches.If you remember from before,because of structural identity,the two views are considered to have different identities.Matt has discussed how this affects animations,but this also has a profound impacton the persistence of your state.Let's see this in practice.When we first evaluate body and we enter the true branch,SwiftUI will allocate persistent storage for the statewith its initial value.Throughout the lifetime of this view,SwiftUI persists the stateas it gets mutated by various actions.But what happens if the value of dayTime changesand we enter the false branch?SwiftUI knows this is a different viewwith a distinct identity.It creates new storage for the false view,starting with the state's initial value,and the storage for the true view is deallocated right after.But what if we go back to the true branch?Well, that's a new view again, so SwiftUI creates new storage,starting again from the state's initial value.The takeaway here is that whenever the identity changes,the state is replaced.Let me pause here for a moment and make surethat you understand this important point:the persistence of your stateis tied to the lifetime of your views.This is a very powerful concept because we can clearly separatewhat is the essence of a view -- its state --and tie that to its identity.Everything else can be derived from it.And your data is so important that SwiftUI has a setof data-driven constructs that use the identity of your dataas a form of explicit identity for your views.The canonical example of this is ForEach.Let's now take a look at all of the different waysyou can initialize a ForEach.This will help us build a better intuition around this type.The simplest form of ForEach is one that takes a constant range.This is a very convenient initializer,especially when you are getting startedprototyping some new UI.SwiftUI is going to use the offset in this rangeto identify the views produced by the view builder.By requiring a constant range,we guarantee that the identities are stablefor the lifetime of the view.In fact, it is an error to use this initializerwith a dynamic range.And new this year, you will see a warningwhen providing a non-constant range.Let's make things more interestingand bring in a dynamic collection of data.This initializer takes a collectionand a keypath to a property serving as an identifier.This property must be hashable because SwiftUIis going to use its value to assign an identityto all the views generated from the elements of the collection.Later, Raj is going to show you some examplesof how choosing a stable identity affectsthe performance and correctness of your app.This idea of providing a stable identity for your datais so important that the standard librarydefines the Identifiable protocolto describe this capability.And SwiftUI takes full advantage of this protocol,allowing you to omit the key pathand use the identifier provided by the protocol requirementto define the identity associated with your dataand your views.Something that I really love about Swift is thatwe can take advantage of its type systemto precisely describe the constraints of the problemthat we are solving.So indulge with me in taking a lookat the definition of the initializer we are using here.There are a lot of interesting things in this short definition,so let's try to unpack them.ForEach needs two main pieces: a collection --here indicated by the generic argument Data --and a way to generate a viewfrom each element of the collection.The shape of this initializer should give you the intuitionthat ForEach defines a relationshipbetween a collection of data and a collection of views.But actually, the most interesting part hereis that we constrain the elements of the collectionto be Identifiable.Again, the purpose of the Identifiable protocolis to allow for your typeto provide a stable notion of identityso that SwiftUI can keep track of your datathroughout its lifetime.In fact, this is very similar to the conceptsof identity and lifetime that we discussed earlier.SwiftUI views that takes an Identifiable typeand a view builder are data-driven components.These views use the identity of the datathat you provide to scope the lifetimeof the views associated to it.Choosing a good identifier is your opportunityto control the lifetime of your views and data.So let's recap what we have discussed in this section.Views values are ephemeraland you should not rely on their lifetime.But their identity is not,and is what gives them continuity over time.You are in control of the identity of your views,and you can use identityto clearly scope the lifetime of state.And finally, SwiftUI takes full advantageof the Identifiable protocol for data-driven components,so it's important to choose a stable identifier for your data.And now continuing the tradition,I'm going to hand it over to Raj. Raj?Raj Ramamurthy: Thanks, Luca!So far, we've explained what identity isand how it ties into a view's lifetime.Next, I'm going to dive into how SwiftUI updates the UI.The goal is to give you a better mental modelfor how to structure SwiftUI code.I'm also going to show a few examplesoutlining everything at the end.To kick this discussion of dependencies off,let's look at a view.Here's a simple view.It shows a button that rewards a dog with a treat.Sorry, Luca, but I'm more of a dog person.Let's focus on the structure of the view.First, let's look at the top.There are two properties:one for a dog and another for a treat.These properties are dependencies of the view.A dependency is just an input to the view.When a dependency changes,the view is required to produce a new body.The body is where you build the hierarchy for the view.Diving into this view's hierarchy,we have a button with an action.Actions are what trigger changes to a view's dependencies.Let's swap the code out for an equivalent diagram.Here's a diagram of our DogView.When we tap on the button,it dispatches an action to reward the dog.Our dog gulps down the treat in a flash.And that results in a change to the dog --maybe he wants another.Because the dependency changed, DogView produces a new body.To learn more about the general conceptsof data flow in SwiftUI, check out"Data essentials in SwiftUI" from WWDC 2020.Next, let's simplify this diagram a bit.Focusing in on the view hierarchy,notice how our views form a tree-like structure.And if we add the dog and treat dependencies back at the top,it still looks like a tree.However, the DogView is not the only view with dependencies.In SwiftUI, each view can have its own set of dependencies.So far, this still looks like a tree.But note, there can be multiple viewsdependent on the same state or other data.For example, one of the descendantsmight depend on the dog, too.And this could happen for one of our other dependencies.So we started with a tree, but this structureonly loosely resembles a tree now.In fact, if we rearrange it to avoid overlapping lines,we end up with this structure,which reveals that this is actually a graph, not a tree.In fact, we call this structure the "dependency graph".This structure is important because it allows SwiftUIto efficiently update only those viewsthat require a new body.Take, for example, the dependency at the bottom.If we examine this dependency, it has two dependent views.The secret of the graph is that if the dependency changes,only those views will be invalidated.SwiftUI will call each view's body,producing a new body value for each view.SwiftUI will instantiate the valuesof each invalidated view's body.That may result in more dependencies changing,but not always!Because views are value types,SwiftUI can efficiently compare themto only update the right subset of views.This is another way to look at what Luca discussed earlier.A view's value is short-lived.The struct value is just used for comparison,but the view itself has a longer lifetime.And that's how we can avoid generating a new bodyfor the view in the center.An identity is the backbone of the dependency graph.As Matt said, every view has identity,whether specified explicitly or structurally.That identity is how SwiftUIroutes changes to the right viewsand efficiently updates the UI.There are many kinds of dependencies.We saw a few examples earlier with the treat propertyand the dog binding,but you can also form dependencies by usingthe environment, state,or any of the observable object property wrappers.Next, I'd like to talk about how to improvethe use of identity in your views.This will help SwiftUI better understand your code.As Luca said, the lifetime of a viewis the duration of its identity,and that means the stability of an identifier is crucial.An identifier that isn't stablecan result in a shorter view lifetime.And having a stable identifier also helps performance,since SwiftUI doesn't need to continuallycreate storage for the viewand churn through updating the graph.As you saw earlier, SwiftUI uses lifetimeto manage persisted storage, so stable identifiersare also important for avoiding loss of state.Let's turn to a code exampleto explain the importance of identifier stability.In this example, I have a list of my favorite pets.We've got an identifier on our pet struct.But there's actually a bug;every time I get a new pet, everything on screen flashes!Let's stop for a second and look at this code.Can you spot where the bug is?The bug is here, in our Identifiable conformance.If you didn't pass the test, don't worry;there are no treats in this section.The problem is that this identifier isn't stable,so anytime the data changes, we get a new identifier.What if instead, we used the indices of our pets array?Unfortunately, this has a similar problem.By using the indices, views are now identified bythe position of their respective pet in the collection.If I decide I have a new first favorite pet,all the other pets will change their identity,which could cause a bad bug.In this example, the button inserts a new elementat index zero, but because the last index is the new one,we get an insertion at the end instead of the start.This is because, like computed random identifiers,indices are not a stable form of identity.In this example, we need to use a stable identifier,like one from a databaseor derived from stable properties of the pet.Any persistent identifier is a great choice.Now our animation looks great!But stability isn't the only property we needfor good identifiers.Another property of good identifiers is uniqueness.Each identifier should map to a single view.This ensures that animations look great,performance is smooth,and the dependencies of your hierarchyare reflected in the most efficient form.Let's look at another example.In this example, I'm working on a viewwith all of my pet's favorite treats.Each treat has a name, an emoji, and an expiration date.I've chosen to identify each treat by its name.At this point -- I'm sure you can guess --we have a bug here, too.What happens when we havemore than one of the same kind of treat?I don't know about you,but I like to buy dog biscuits in bulk.When I add them to the jar, they might not show up!The problem is that the name of a treatis not a unique identifier for it.Instead, we can use a serial numberor other unique ID per treat.And this ensures all the right data is shown in our jar.It will also ensure better animationsand better performance.When SwiftUI needs an identifier, it needs your help!Please be careful when using random identifiers,especially in computed properties.In general, you want all of your identifiers to be stable.An identifier shouldn't change over time;a new identifier represents a new item with a new lifetime.And lastly, identifiers need to be unique.Multiple views can't share an identifier.SwiftUI relies on these propertiesto make your app run smoothly and bug-free.Now that we've talked about explicit identity,I'd like to move on to structural identity.In this example, I'm working on the treat jar from earlier.As a responsible pet lover,I only feed my pets the finest, unexpired foods.To help me tell when treats have gone bad,I've added a new modifier that optionally dims a treat cellwhen the treat is expired.I've highlighted the cell that's dimmed.Let's dive into the modifier.You can see that in the modifier, I have a dateand compare it to the current dateto know when to dim the view.This seems fine at first blush,but there's a subtle problem here.If the condition changes and our treat becomes expired,we end up with a new identity because there is a branch here.As Matt discussed, branches are a form of structural identity.This means we have two copies of the contentinstead of a single, optionally modified copy.Note that the branch here is in a modifier.For clarity, I've put the modifier and its use siteon the same slide, but in your project,you might have branches like this across fileswithout even being aware of it!Of course, everything we've discussed hereapplies to views and view modifiers.So how can we avoid this?Well, one way is to fold the branches togetherand move the condition inside the opacity modifier, like so.By removing this branch,we've correctly described this viewas having a single identity.Furthermore, moving the conditioninside the opacity modifier can help performance,because we've tightly scoped the dependent code.Now when the condition changes,only the opacity needs to change.The trick to this is that when the condition is true,we have an opacity of 1, which looks like this.An opacity of 1 has no effect.We call modifiers like this "inert modifiers,"because they don't affect the rendered result.SwiftUI modifiers are cheap,so there is little inherent cost with this pattern.Because there is no resulting visual effect,the framework can efficiently prune away the modifier,further reducing its cost.Branches are great,and they exist in SwiftUI for a reason.But when used unnecessarily, they can cause poor performance,surprising animations,and, as Luca showed, even loss of state.When you introduce a branch, pause for a secondand consider whether you're representingmultiple views or two states of the same view.As we saw, it often works better to use an inert modifierinstead of a branch to identify a single view.Here are just a few examples of inert modifiers.I especially love transformEnvironmentfor conditionally writing to the environment.Putting everything together,we've shown you today that identityis one of the secrets to amazing performance.We've discussed explicit and structural identity,and how you can take advantage of eachto improve your app.From identity, we can derive a view's lifetime,which controls its associated storage, transitions, and more.And we've also explained that SwiftUIuses identity and lifetime to form dependencies,which are represented by a graphthat can efficiently update the UI.Along with demystifying SwiftUI,we've given you some tips and tricksto avoid bugs and improve performance in your apps.And now that you've learned these tricks,take a tour through your code to see if they can help you.Thank you, and keep building great apps!♪

♪ Bass music playing ♪♪Matt Ricketson: Hi, I'm Matt,and later on I'll be joined by Luca and Raj.

Today, we're going to demystify SwiftUI.

Now, we've heard it many times beforethat SwiftUI is a declarative UI framework.

That means that you describe what you wantfor your app at a high level,and SwiftUI decides exactly how to make it happen.

Now, most of the time, this works great!And that's when SwiftUI feels magical.

But there will always be those momentswhen SwiftUI does something that you might not expect.

And in those moments, it helps to understanda bit more about what SwiftUI is doing behind the scenesto build a better intuition for how to get the resultsyou're looking for.

So today's question is,When SwiftUI looks at your code, what does it see?The answer is three things:identity, lifetime, and dependencies.

Identity is how SwiftUI recognizes elementsas the same or distinct across multiple updates of your app.

Lifetime is how SwiftUI tracks the existence of viewsand data over time.

And dependencies are how SwiftUI understandswhen your interface needs to be updated and why.

Together, these three concepts inform how SwiftUI decideswhat needs to change, how, and when,resulting in the dynamic user interface you see onscreen.

Today, we'll talk about each of these three concepts in more depth.

Let's start with identity,and I have a few friends here to help me.

These Ruby Spaniels are adorable,but they're also the subject of a deep philosophical question.

Are these two different dogs?Or are these, in fact, two pictures of the same dog?The truth is, it's impossible to say!We just don't have enough information.

But this question of whether things are the same or differentis at the heart of what we call "identity."Identity isn't just important for dogs though.

It's also a critical aspectof how SwiftUI understands your app.

Let's look at an example.

This is an app I made called "Good Dog, Bad Dog,"which helps me keep trackof whether my furry friend has been on her best behavior.

It's pretty simple.

I can just tap anywhere on the screento flip between the good and bad states.

So what does identity have to do with my app?Well, it's actually very similar to that philosophical questionwe just asked about the dogs.

Looking at those icons, do those seem like two different views,completely distinct from each other?Or could they be the same view,just in a different place and with a different color?That distinction actually matters a great dealbecause it changes how our interfacetransitions from one state to another.

Let's say those icons are, in fact, different views.

That means the icons should transition independently,such as fading in and out.

But what if they're, in fact, the same view?That would instead imply that the viewshould slide across the screen during the transitionbecause it's the same viewmoving from one location to the other.

So connecting views across different states is important,because that's how SwiftUI understandshow to transition between them.

This is the key concept behind view identity.

Views that share the same identityrepresent different states of the same conceptual UI element.

In contrast, views that represent distinct UI elementswill always have different identities.

Later in the talk, Luca and Raj will talk aboutthe practical impacts of view identityon your app's data and update cycle.

For now, let's look at how identityis represented in your code, focusing onthe two different types of identity used by SwiftUI.

First, explicit identity:using custom or data-driven identifiers.

And second, structural identity: distinguishing viewsby their type and position in the view hierarchy.

Now, to help understand these concepts,let me introduce you to some more of my friends.

OK, remember that it can be difficult to tell dogs apart,especially when they look the same.

So what kind of extra informationwould help us identify our dogs?One way would be to simply ask for their names.

If two dogs look the same and also share the same name,then I'd say it's pretty likelythat they're, in fact, the same dog.

But if they have different names,then we can guarantee that they are,in fact, different dogs.

Assigning names or identifiers like thisis a form of explicit identity.

Explicit identity is powerful and flexible,but does require that someone, somewherekeeps track of all those names.

One form of explicit identityyou may already be used to is pointer identity,which is used throughout UIKit and AppKit.

Now, SwiftUI doesn't use pointer identity,but learning about it will help you better understandhow and why SwiftUI works differently.

Let's take a quick look.

Consider a UIKit or AppKit view hierarchy, like this one.

Since UIViews and NSViews are classes,they each have a unique pointer to their memory allocation.

The pointer is a natural source of explicit identity.

We can refer to individual views just using their pointer,and if two views share the same pointer,we can guarantee that they are really the same view.

But SwiftUI doesn't use pointersbecause SwiftUI views are value types,commonly represented as structs instead of classes.

In the "SwiftUI essentials" talk from 2019,we discussed why SwiftUI uses value typesinstead of classes for its views,so I recommend watching that talk to learn more.

For now, the important thing to know is thatvalue types do not have a canonical reference thatSwiftUI can use as a persistent identity for its views.

Instead, SwiftUI relies on other forms of explicit identity.

For example, consider this list of rescue dogs.

The id parameter used here is a form of explicit identity.

The dog tag ID of each rescue dog is usedto explicitly identify its corresponding view in the list.

If the collection of rescue dogs changes,SwiftUI can use those IDs to understand what exactly changedand generate the correct animations within the list.

In this case, SwiftUI was even able to correctly animate viewsmoving between different sections.

Let's look at a more advanced example.

Here, we're using a ScrollViewReaderto jump to the top of the view using a button at the bottom.

The id(_:) modifier provides a way to explicitly identify a viewusing a custom identifier --in this case, our header view at the top of the page.

Then we can pass that identifierto the scroll view proxy's scrollTo(_:) methodto tell SwiftUI to go to that specific view.

What's great about this is thatwe don't have to explicitly identify every view,just the ones we need to refer to elsewhere in the code,like our header text.

By comparison, the ScrollViewReader,ScrollView, backstory Text, and Bbuttondo not need explicit identifiers.

But just because their identity isn't explicit,that doesn't mean these views have no identity at allbecause every view has an identity,even if it's not explicit.

This is where structural identity comes in.

SwiftUI uses the structure of your view hierarchyto generate implicit identities for your viewsso you don't have to.

Now, let me bring in some more of my friendsto help explain what I mean by that.

Let's say we have two similar dogsbut we don't know their names,but we still need to identify each one.

Well, suppose these are very good dogsand they're capable of sitting very still.

If we can guarantee they don't move,we could identify them just based on where they're sitting,like "The dog on the left" or "The dog on the right".

We're using the relative arrangement of our subjectsto distinguish them from each other --that's structural identity.

SwiftUI leverages structural identity throughout its API,and a classic example is when you use if statementsand other conditional logic within your View code.

The structure of the conditional statementgives us a clear way to identify each view.

The first view only shows when the condition is true,while the second view only shows when the condition is false.

That means we can always tell which view is which,even if they happen to look similarly.

However, this only works if SwiftUI can statically guaranteethat these views stay where they are and never swap places.

SwiftUI accomplishes this by looking at the type structureof your view hierarchy.

When SwiftUI looks at your views,it sees their generic types --in this case, our if statement translated intoa _ConditionalContent view,which is generic over its true and false content.

This translation is powered by a ViewBuilder,which is a type of result builder in Swift.

The View protocol implicitly wraps its body propertyin a ViewBuilder, which constructs a single generic viewfrom the logic statements in our property.

The some View return type of our body propertyis a placeholder that represents this static composite type,hiding it away so it doesn't clutter up our code.

Using this generic type, SwiftUI can guaranteethat the true view will always be the AdoptionDirectory,while the False view will always be the DogList,allowing them to be assigned an implicit, stable identitybehind the scenes.

In fact, this is the key to understandingthe Good Dog, Bad Dog app from earlier.

With the code on the top, we have an if statementthat defines different views for each conditional branch.

This will cause the views to transition in and outbecause SwiftUI understands that each branch of the if statementrepresents a different view with a distinct identity.

Alternatively, we could just have a single PawViewthat changes its layout and color.

When it transitions to a different state,the view will smoothly slide to its next position.

That's because we're modifying a single viewwith a consistent identity.

Both of these strategies can work,but SwiftUI generally recommends the second approach.

By default, try to preserve identityand provide more fluid transitions.

This also helps preserve your view's lifetime and state,which Luca will talk about in more detail later on.

Now that we understand structural identity,we need to talk about its evil nemesis, AnyView.

To understand the impact of using AnyView,let's look at the effect that it hason the structure of your views.

Earlier we wrote this if statementto switch between the AdoptionDirectoryand the DogList.

When SwiftUI looks at this code,it sees the generic type structure on the right.

Now let's look at a different example,one that uses AnyView extensively.

This is a helper function I've writtento get a view that represents a dog's breed.

Each conditional branch in the functionreturns a different kind of view,so I've wrapped them all in AnyViewsbecause Swift requires a single return typefor the whole function.

Unfortunately, this also means that SwiftUI can't seethe conditional structure of my code.

Instead, it just sees an AnyViewas a return type of the function.

This is because AnyView is what's calleda "type-erasing wrapper type" --it hides the type of the view it is wrappingfrom its generic signature.

But perhaps more importantly,this code is also just really hard to readfor us mere humans.

Let's see if we can simplify this codeand also make more of its structure visible to SwiftUI.

First, it looks like this branch is conditionally addinga SheepView alongside our BorderCollieViewif there are sheep nearby.

We can simplify this by conditionally adding the viewinside the HStack rather thanconditionally adding the HStack around our views.

With that change, it's now easy to seethat we're just returning a single view from each branch,so our local dogView variable isn't necessary.

Instead, we can replace it with return statementsinside of each branch.

As we saw earlier, normal SwiftUI View codecan use if statements that return different types of views.

But if we just try deleting the return statementsand AnyViews from our code,we see some errors and warnings appear.

This is because SwiftUI requires a single return typefrom our helper function.

So how can we avoid these errors?Recall that the body property of a view is special,because the View protocol implicitly wraps itin a ViewBuilder.

This translates the logic in the propertyinto a single, generic view structure.

Now, Swift does not infer helper functionsto be view builders by default, but we can opt into thatby manually applying the ViewBuilder attribute ourselves.

And that allows us to remove the return statementsand the AnyView wrappers without any warnings or errors.

OK, our code is looking pretty good now!We've gotten rid of all of the AnyViews,making it easier to read than before.

And if we look at the type signature of the result,it now exactly replicates the conditional logicof our function with a tree of conditional content,providing SwiftUI with a much richer perspectiveof the view and the identities of its components.

But there's one more small improvement we can make.

The top level of our function is just matchingagainst different cases of the dog's breed.

This seems like an excellent use case for a switch statement,which are also supported by view builders.

Now it's even easier to quickly understandall the different cases of our view.

And because switch statements are really just syntactic sugarfor conditional statements,our resulting view's type signature on the rightremains exactly the same.

Stepping back, we just showed youhow AnyViews erase type information from your code,and walked through how to get rid of unnecessary AnyViewsby leveraging view builders.

In general, we recommend avoiding AnyViewswhenever possible.

Having too many AnyViews will often make codeharder to read and understand.

Traditional control flow statementslike if/else and switch make it much easierto see the different possible states of a view.

And because AnyView hides static type informationfrom the compiler,it can sometimes prevent helpful diagnostic errors and warningsfrom being surfaced in your code.

Finally, keep in mind that using AnyView when you don't need tocan result in worse performance.

When possible, use generics to preserve static type informationrather than passing AnyViews around your code.

And with that, we've finished introducing the basic typesof view identity in SwiftUI.

With explicit identity,we can tie the identity of our views to our data,or provide custom identifiers to refer to specific views.

And with structural identity,we've learned how SwiftUI can identify our viewsjust based on their type and positionwithin the view hierarchy.

And now I'll hand things over to Lucato discuss how the identity of your viewsis related to their lifetime and state.

Luca Bernardi: Thanks, Matt.

Now that we understand how SwiftUI identifies your views,let's explore how identityties into the lifetime of your views and data.

This will help you better understand how SwiftUI works.

To help illustrate this,I'm also going to bring in a friend.

This is Theseus.

Isn't he adorable, too?Someone will say more adorable, but I digress.

It is very intuitive for us to think thatonce we name our favorite pet,he'll always be the same adorable cat,even when he is in different statesand he moves throughout the day.

When we look at him one moment, he might be sleepyand a moment later, being a proper cat,he's annoyed by my presence -- but he'll always be Theseus.

This is the essence of connecting identity to lifetime.

Identity allows us to define a stable elementfor different values over time.

In other words, it allows us to introduce continuity over time.

You might be wondering, how does this apply to SwiftUI?So let's bring back a cat-friendly versionof the app Matt was working on.

Just like Theseus can be in different statesat different moments in time, our views are alsoin different states throughout their lifetime.

Every single state is a different value for our view.

Identity connects these different valuesas a single entity -- a view -- over time.

Let's look at some code to clarify this.

Here we have a simple viewthat displays the intensity of purring.

Spoiler: Theseus is pretty loud.

Through the evaluation of body,SwiftUI will create a new value for this view;in this case, with an intensity value of 25.

Theseus is getting hungry and wants more attention.

body is invoked again with a higher intensity,and the new value for the view is created.

These are two distinct valuescreated from the same view definition.

SwiftUI will keep around a copy of the valueto perform a comparison and know if the view has changed.

But after that, the value is destroyed.

What it is important to understand here is thatthe view value is different from the view identity.

View values are ephemeraland you should not rely on their lifetime.

But what you can control is their identity.

When a view is first created and it appears,SwiftUI assigns it an identity using a combinationof the techniques discussed before.

Over time, driven by updates,new values for the view are created.

But from SwiftUI's perspective, these represent the same view.

Once the identity of the view changesor the view is removed, its lifetime ends.

Whenever we talk about the lifetime of a view,we are referring to the duration of the identityassociated with that view.

Being able to connectthe identity of a view with its lifetimeis fundamental to understand how SwiftUI persists your state.

So let's bring State and StateObject into the picture.

When SwiftUI is looking at your viewand sees a State or a StateObject,it knows that it needs to persist that piece of datathroughout the view's lifetime.

In other words, State and StateObjectare the persistent storageassociated with your view's identity.

At the beginning of a view's identity,when it's created for the first time,SwiftUI is going to allocate storage in memoryfor State and StateObject using their initial values.

Here we are focusing on the title state.

Throughout the lifetime of the view,SwiftUI will persist this storage as it gets mutatedand the view's body is re-evaluated.

Let's look at a concrete example of how changes in identityaffect the persistence of state.

This is an interesting example because we have the same viewbut in two separate branches.

If you remember from before,because of structural identity,the two views are considered to have different identities.

Matt has discussed how this affects animations,but this also has a profound impacton the persistence of your state.

Let's see this in practice.

When we first evaluate body and we enter the true branch,SwiftUI will allocate persistent storage for the statewith its initial value.

Throughout the lifetime of this view,SwiftUI persists the stateas it gets mutated by various actions.

But what happens if the value of dayTime changesand we enter the false branch?SwiftUI knows this is a different viewwith a distinct identity.

It creates new storage for the false view,starting with the state's initial value,and the storage for the true view is deallocated right after.

But what if we go back to the true branch?Well, that's a new view again, so SwiftUI creates new storage,starting again from the state's initial value.

The takeaway here is that whenever the identity changes,the state is replaced.

Let me pause here for a moment and make surethat you understand this important point:the persistence of your stateis tied to the lifetime of your views.

This is a very powerful concept because we can clearly separatewhat is the essence of a view -- its state --and tie that to its identity.

Everything else can be derived from it.

And your data is so important that SwiftUI has a setof data-driven constructs that use the identity of your dataas a form of explicit identity for your views.

The canonical example of this is ForEach.

Let's now take a look at all of the different waysyou can initialize a ForEach.

This will help us build a better intuition around this type.

The simplest form of ForEach is one that takes a constant range.

This is a very convenient initializer,especially when you are getting startedprototyping some new UI.

SwiftUI is going to use the offset in this rangeto identify the views produced by the view builder.

By requiring a constant range,we guarantee that the identities are stablefor the lifetime of the view.

In fact, it is an error to use this initializerwith a dynamic range.

And new this year, you will see a warningwhen providing a non-constant range.

Let's make things more interestingand bring in a dynamic collection of data.

This initializer takes a collectionand a keypath to a property serving as an identifier.

This property must be hashable because SwiftUIis going to use its value to assign an identityto all the views generated from the elements of the collection.

Later, Raj is going to show you some examplesof how choosing a stable identity affectsthe performance and correctness of your app.

This idea of providing a stable identity for your datais so important that the standard librarydefines the Identifiable protocolto describe this capability.

And SwiftUI takes full advantage of this protocol,allowing you to omit the key pathand use the identifier provided by the protocol requirementto define the identity associated with your dataand your views.

Something that I really love about Swift is thatwe can take advantage of its type systemto precisely describe the constraints of the problemthat we are solving.

So indulge with me in taking a lookat the definition of the initializer we are using here.

There are a lot of interesting things in this short definition,so let's try to unpack them.

ForEach needs two main pieces: a collection --here indicated by the generic argument Data --and a way to generate a viewfrom each element of the collection.

The shape of this initializer should give you the intuitionthat ForEach defines a relationshipbetween a collection of data and a collection of views.

But actually, the most interesting part hereis that we constrain the elements of the collectionto be Identifiable.

Again, the purpose of the Identifiable protocolis to allow for your typeto provide a stable notion of identityso that SwiftUI can keep track of your datathroughout its lifetime.

In fact, this is very similar to the conceptsof identity and lifetime that we discussed earlier.

SwiftUI views that takes an Identifiable typeand a view builder are data-driven components.

These views use the identity of the datathat you provide to scope the lifetimeof the views associated to it.

Choosing a good identifier is your opportunityto control the lifetime of your views and data.

So let's recap what we have discussed in this section.

Views values are ephemeraland you should not rely on their lifetime.

But their identity is not,and is what gives them continuity over time.

You are in control of the identity of your views,and you can use identityto clearly scope the lifetime of state.

And finally, SwiftUI takes full advantageof the Identifiable protocol for data-driven components,so it's important to choose a stable identifier for your data.

And now continuing the tradition,I'm going to hand it over to Raj. Raj?Raj Ramamurthy: Thanks, Luca!So far, we've explained what identity isand how it ties into a view's lifetime.

Next, I'm going to dive into how SwiftUI updates the UI.

The goal is to give you a better mental modelfor how to structure SwiftUI code.

I'm also going to show a few examplesoutlining everything at the end.

To kick this discussion of dependencies off,let's look at a view.

Here's a simple view.

It shows a button that rewards a dog with a treat.

Sorry, Luca, but I'm more of a dog person.

Let's focus on the structure of the view.

First, let's look at the top.

There are two properties:one for a dog and another for a treat.

These properties are dependencies of the view.

A dependency is just an input to the view.

When a dependency changes,the view is required to produce a new body.

The body is where you build the hierarchy for the view.

Diving into this view's hierarchy,we have a button with an action.

Actions are what trigger changes to a view's dependencies.

Let's swap the code out for an equivalent diagram.

Here's a diagram of our DogView.

When we tap on the button,it dispatches an action to reward the dog.

Our dog gulps down the treat in a flash.

And that results in a change to the dog --maybe he wants another.

Because the dependency changed, DogView produces a new body.

To learn more about the general conceptsof data flow in SwiftUI, check out"Data essentials in SwiftUI" from WWDC 2020.

Next, let's simplify this diagram a bit.

Focusing in on the view hierarchy,notice how our views form a tree-like structure.

And if we add the dog and treat dependencies back at the top,it still looks like a tree.

However, the DogView is not the only view with dependencies.

In SwiftUI, each view can have its own set of dependencies.

So far, this still looks like a tree.

But note, there can be multiple viewsdependent on the same state or other data.

For example, one of the descendantsmight depend on the dog, too.

And this could happen for one of our other dependencies.

So we started with a tree, but this structureonly loosely resembles a tree now.

In fact, if we rearrange it to avoid overlapping lines,we end up with this structure,which reveals that this is actually a graph, not a tree.

In fact, we call this structure the "dependency graph".

This structure is important because it allows SwiftUIto efficiently update only those viewsthat require a new body.

Take, for example, the dependency at the bottom.

If we examine this dependency, it has two dependent views.

The secret of the graph is that if the dependency changes,only those views will be invalidated.

SwiftUI will call each view's body,producing a new body value for each view.

SwiftUI will instantiate the valuesof each invalidated view's body.

That may result in more dependencies changing,but not always!Because views are value types,SwiftUI can efficiently compare themto only update the right subset of views.

This is another way to look at what Luca discussed earlier.

A view's value is short-lived.

The struct value is just used for comparison,but the view itself has a longer lifetime.

And that's how we can avoid generating a new bodyfor the view in the center.

An identity is the backbone of the dependency graph.

As Matt said, every view has identity,whether specified explicitly or structurally.

That identity is how SwiftUIroutes changes to the right viewsand efficiently updates the UI.

There are many kinds of dependencies.

We saw a few examples earlier with the treat propertyand the dog binding,but you can also form dependencies by usingthe environment, state,or any of the observable object property wrappers.

Next, I'd like to talk about how to improvethe use of identity in your views.

This will help SwiftUI better understand your code.

As Luca said, the lifetime of a viewis the duration of its identity,and that means the stability of an identifier is crucial.

An identifier that isn't stablecan result in a shorter view lifetime.

And having a stable identifier also helps performance,since SwiftUI doesn't need to continuallycreate storage for the viewand churn through updating the graph.

As you saw earlier, SwiftUI uses lifetimeto manage persisted storage, so stable identifiersare also important for avoiding loss of state.

Let's turn to a code exampleto explain the importance of identifier stability.

In this example, I have a list of my favorite pets.

We've got an identifier on our pet struct.

But there's actually a bug;every time I get a new pet, everything on screen flashes!Let's stop for a second and look at this code.

Can you spot where the bug is?The bug is here, in our Identifiable conformance.

If you didn't pass the test, don't worry;there are no treats in this section.

The problem is that this identifier isn't stable,so anytime the data changes, we get a new identifier.

What if instead, we used the indices of our pets array?Unfortunately, this has a similar problem.

By using the indices, views are now identified bythe position of their respective pet in the collection.

If I decide I have a new first favorite pet,all the other pets will change their identity,which could cause a bad bug.

In this example, the button inserts a new elementat index zero, but because the last index is the new one,we get an insertion at the end instead of the start.

This is because, like computed random identifiers,indices are not a stable form of identity.

In this example, we need to use a stable identifier,like one from a databaseor derived from stable properties of the pet.

Any persistent identifier is a great choice.

Now our animation looks great!But stability isn't the only property we needfor good identifiers.

Another property of good identifiers is uniqueness.

Each identifier should map to a single view.

This ensures that animations look great,performance is smooth,and the dependencies of your hierarchyare reflected in the most efficient form.

Let's look at another example.

In this example, I'm working on a viewwith all of my pet's favorite treats.

Each treat has a name, an emoji, and an expiration date.

I've chosen to identify each treat by its name.

At this point -- I'm sure you can guess --we have a bug here, too.

What happens when we havemore than one of the same kind of treat?I don't know about you,but I like to buy dog biscuits in bulk.

When I add them to the jar, they might not show up!The problem is that the name of a treatis not a unique identifier for it.

Instead, we can use a serial numberor other unique ID per treat.

And this ensures all the right data is shown in our jar.

It will also ensure better animationsand better performance.

When SwiftUI needs an identifier, it needs your help!Please be careful when using random identifiers,especially in computed properties.

In general, you want all of your identifiers to be stable.

An identifier shouldn't change over time;a new identifier represents a new item with a new lifetime.

And lastly, identifiers need to be unique.

Multiple views can't share an identifier.

SwiftUI relies on these propertiesto make your app run smoothly and bug-free.

Now that we've talked about explicit identity,I'd like to move on to structural identity.

In this example, I'm working on the treat jar from earlier.

As a responsible pet lover,I only feed my pets the finest, unexpired foods.

To help me tell when treats have gone bad,I've added a new modifier that optionally dims a treat cellwhen the treat is expired.

I've highlighted the cell that's dimmed.

Let's dive into the modifier.

You can see that in the modifier, I have a dateand compare it to the current dateto know when to dim the view.

This seems fine at first blush,but there's a subtle problem here.

If the condition changes and our treat becomes expired,we end up with a new identity because there is a branch here.

As Matt discussed, branches are a form of structural identity.

This means we have two copies of the contentinstead of a single, optionally modified copy.

Note that the branch here is in a modifier.

For clarity, I've put the modifier and its use siteon the same slide, but in your project,you might have branches like this across fileswithout even being aware of it!Of course, everything we've discussed hereapplies to views and view modifiers.

So how can we avoid this?Well, one way is to fold the branches togetherand move the condition inside the opacity modifier, like so.

By removing this branch,we've correctly described this viewas having a single identity.

Furthermore, moving the conditioninside the opacity modifier can help performance,because we've tightly scoped the dependent code.

Now when the condition changes,only the opacity needs to change.

The trick to this is that when the condition is true,we have an opacity of 1, which looks like this.

An opacity of 1 has no effect.

We call modifiers like this "inert modifiers,"because they don't affect the rendered result.

SwiftUI modifiers are cheap,so there is little inherent cost with this pattern.

Because there is no resulting visual effect,the framework can efficiently prune away the modifier,further reducing its cost.

Branches are great,and they exist in SwiftUI for a reason.

But when used unnecessarily, they can cause poor performance,surprising animations,and, as Luca showed, even loss of state.

When you introduce a branch, pause for a secondand consider whether you're representingmultiple views or two states of the same view.

As we saw, it often works better to use an inert modifierinstead of a branch to identify a single view.

Here are just a few examples of inert modifiers.

I especially love transformEnvironmentfor conditionally writing to the environment.

Putting everything together,we've shown you today that identityis one of the secrets to amazing performance.

We've discussed explicit and structural identity,and how you can take advantage of eachto improve your app.

From identity, we can derive a view's lifetime,which controls its associated storage, transitions, and more.

And we've also explained that SwiftUIuses identity and lifetime to form dependencies,which are represented by a graphthat can efficiently update the UI.

Along with demystifying SwiftUI,we've given you some tips and tricksto avoid bugs and improve performance in your apps.

And now that you've learned these tricks,take a tour through your code to see if they can help you.

Thank you, and keep building great apps!♪

## Code Samples


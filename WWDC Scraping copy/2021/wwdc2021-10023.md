# Wwdc2021 10023

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Direct and reflect focus in SwiftUIWith device input — as with all things in life — where you put focus matters. Discover how you can move focus in your app with SwiftUI, programmatically dismiss the keyboard, and build large navigation targets from small views. Together, these APIs can help you simplify your app's interface and make it more powerful for people to find what they need.ResourcesInput and event modifiersHD VideoSD VideoRelated VideosWWDC22Use SwiftUI with AppKitWWDC21Support Full Keyboard Access in your iOS appWhat's new in SwiftUI

With device input — as with all things in life — where you put focus matters. Discover how you can move focus in your app with SwiftUI, programmatically dismiss the keyboard, and build large navigation targets from small views. Together, these APIs can help you simplify your app's interface and make it more powerful for people to find what they need.

Input and event modifiers

HD VideoSD Video

HD Video

SD Video

Use SwiftUI with AppKit

Support Full Keyboard Access in your iOS app

What's new in SwiftUI

Search this video…♪ Bass music playing ♪♪Tanu Singhal: Hello, everyone.My name is Tanu, and I'm a SwiftUI engineeron the Apple TV team.Today, we'll talk about some new waysof working with focus in SwiftUI.One of the great things about SwiftUIis how much functionality you get for free,right out of the box.Built-in components base their default behavioron SwiftUI's knowledge of platform conventions,resulting in an overall experiencethat is sensible and familiar in various contexts.We see this intelligence at work when we look at focus.Focus is the system that lets your apptake input from keyboards, remotes, game controllers,accessible switch controls, and other sources that --unlike touch inputs --are not tied to specific screen coordinates.Often, the focus view is drawn with special embellishments,making it easy for people to predictwhere their input will be directed.For the most part, SwiftUI manages focus on your behalf.When someone clicks in a text fieldor presses the Tab keyor when someone taps an adjustable watch complicationor swipes on the Siri Remote,SwiftUI decides how focus is affectedand how its next placement is indicated.This is great for simple caseswhere the right behavior can be decided by convention.There are, however, some cases where you may wanta more accelerated experience around focus.In this example from the Notes app,when we select the new note button,we want focus to automatically move to the newly created note.This type of behavior certainly requires custom implementation.Over here, we have a scenario in which we want to move focusfrom a button on the bottom-left sideto content near the top of the screenwhen a user swipes right on the remote.Since the Music button and the App tilesare not adjacent to each other,SwiftUI cannot automatically guess where to move focus.It needs more informationbefore distant focus targets can be linked.And in this example from iOS,we simply want the keyboard to go awaywhen a user selects an event.Thanks to new APIs we're introducing this year,you can now do all of this in SwiftUI.In this talk, we will focus on two kinds of use cases.We'll see how we can move focus to a particular viewwithout any direct input,and we'll make large navigation targets out of small viewsso that nothing is out of the user's reach.Let's first look an example where we may want to move focusto help direct the user's attention.We're so ready to go on a vacation,and we've started working on a vacation planner app.This app works across all Apple platforms,and it allows you to browse destinationsas well as book trips.When you launch this app, we present an email field,a password field, and a Sign in with Apple buttonso you can log into your account.On this login screen, if we discover that the email enteredwas not in the correct format,we want to programmatically move focus back to the email field.To accomplish this behavior,we'll use the FocusState APIs.The existing code for our login viewcontains a VStack that has a TextField and a SecureField.Now, we'll add a FocusState property wrapper to this view.FocusState is a new API that we have introduced this year!This is a special type of state that changesdepending on the current location of focus.We'll use FocusState to hold an identifierfor the field that is focused.The focusedField variable is of an enum type that we createdfor this example.You can use strings, integers,or any other hashable value type for FocusState.Note that the FocusState value is optional.In general, types used for FocusStatemust be both hashable and optional,with nil used for cases where focusis in an unrelated part of the screen.Next we'll add a focused modifierto the TextField and the SecureField.Also new this year, this modifier creates a linkbetween the placement of focusand the value of the focusedField property.This simple link is a powerful tool,because it means you can use the current placement of focusfor making other decisions in your app.We can watch that play out in our login form.When the screen first appears, nothing has focus,so the value of focusedField is nil.But if someone then taps on the email text field,that field gains focus and the keyboard appears.Since the focused text field is bound to a FocusState value,the value of focusedField will automatically be updatedto hold the identifier for the email text field.The link between focus placement and FocusState works both ways.This means that we are not limitedto reacting to focus changes;we can move focus programmaticallyjust by updating our FocusState property.So for example, if we programmatically set the valueof focusedField to .password,SwiftUI will know that our SecureFieldis associated with the new value we're settingand focus will automatically move to the password field.Now that our focus bindings are in place,we can put them to work.In the Vacation Planner app, when a user submits their data,we want to validate it.If the email is not in the expected format,we set the focusedField to email.This will send focus back to the email text field,if it's not there already.Further, we'd like to highlight the email field with a borderif the email was invalid.We want this border to appearonly while focus is on the email field.To do that, we can easily read the value of focusedFieldwhen we create the border.Let's see how this all comes together.Note the email field doesn't have a valid address.Focus is currently on the password field.When we hit Go, the onSubmit callback is triggeredwhere the focusedField is set.This causes the cursor to move back to the email field.While the email field is focused,we see the red border around it.However, once we move focus away from the email field,our focusedField is no longer equal to the email identifier,and so the red border disappears.In the scenario where all the form data is valid,we want to simply dismiss the keyboard.To dismiss the keyboard,we will set our FocusState variable to nil.Since the focusedField is an optional,we use nil to indicate that focus has left this view.In the video, notice that the email address has been updated.This time when we submit, the keyboard gets dismissedsince we have set the FocusState variable to nil.We've seen how it can be helpfulto programmatically control focuswhen our app has text fields.However, FocusStates are not just for text fields.They can be used to programmatically control focusfor any focusable view on iOS, tvOS, watchOS, or macOS!In the next section, we'll discuss the roleof focus-based navigation in our apps.Let's take a look at the tvOS versionof our Vacation Planner app.We have leveraged the extra space on TVby adding photos from some destinationsthat you may want to visit.You can view more photosby clicking the Browse Photos buttoneven before you've logged in.Notice that focus is initially on the Email field.If we swipe right on the Siri Remote,we'd expect focus to move to the Browse Photos button.However, that doesn't work by default.This is because directional focus navigationis based on adjacency relationships.When swiping to move focus, focus will only move if there issomething adjacent and focusable in the given direction.Take a look at the focusable views in this app.Since there's no focusable viewadjacent to the login fields on the left,the button on the bottom is unreachable.To make this screen navigable,we will extend the Browse button's focusable area,so it becomes adjacent to the login fields.This is done using the new FocusSections API.Let's see how easy that is.Here we have a simplified versionof the Vacation Planner code for TV.It contains an HStack with two VStacks;one for the login fields,and another VStack for the image and the button.We want to create a larger logical focus targetaround the button so focus can behaveas if the button was adjacent to the login fields.This can be done by simply adding a focusSection() modifierto the VStack that contains the button.When focusSection() modifier is added to any view,the frame of that view becomes capable of accepting focusif it contains any focusable subviews.Since we also want to move focus back to the login fieldswhen swiping left on the button,we'll add another focusSection() modifier to the first VStack.Now when we run this app, users can move focusbetween the input fields and the Browse buttonby swiping left and right on the remote.As we wrap things up,I'd encourage you to think about focus,which can often look different on different platforms.SwiftUI has great default behaviorsbuilt in for most cases.The new focus states and FocusSections APIscan help you take advantage of focusto create even more streamlined experiences.As you work on your apps,take a moment to observe the many waysin which focus impacts user behavior.We hope this session has equipped you with the toolsthat'll help users focus on what's most important.Thanks for watching, and have an awesome WWDC!♪

♪ Bass music playing ♪♪Tanu Singhal: Hello, everyone.

My name is Tanu, and I'm a SwiftUI engineeron the Apple TV team.

Today, we'll talk about some new waysof working with focus in SwiftUI.

One of the great things about SwiftUIis how much functionality you get for free,right out of the box.

Built-in components base their default behavioron SwiftUI's knowledge of platform conventions,resulting in an overall experiencethat is sensible and familiar in various contexts.

We see this intelligence at work when we look at focus.

Focus is the system that lets your apptake input from keyboards, remotes, game controllers,accessible switch controls, and other sources that --unlike touch inputs --are not tied to specific screen coordinates.

Often, the focus view is drawn with special embellishments,making it easy for people to predictwhere their input will be directed.

For the most part, SwiftUI manages focus on your behalf.

When someone clicks in a text fieldor presses the Tab keyor when someone taps an adjustable watch complicationor swipes on the Siri Remote,SwiftUI decides how focus is affectedand how its next placement is indicated.

This is great for simple caseswhere the right behavior can be decided by convention.

There are, however, some cases where you may wanta more accelerated experience around focus.

In this example from the Notes app,when we select the new note button,we want focus to automatically move to the newly created note.

This type of behavior certainly requires custom implementation.

Over here, we have a scenario in which we want to move focusfrom a button on the bottom-left sideto content near the top of the screenwhen a user swipes right on the remote.

Since the Music button and the App tilesare not adjacent to each other,SwiftUI cannot automatically guess where to move focus.

It needs more informationbefore distant focus targets can be linked.

And in this example from iOS,we simply want the keyboard to go awaywhen a user selects an event.

Thanks to new APIs we're introducing this year,you can now do all of this in SwiftUI.

In this talk, we will focus on two kinds of use cases.

We'll see how we can move focus to a particular viewwithout any direct input,and we'll make large navigation targets out of small viewsso that nothing is out of the user's reach.

Let's first look an example where we may want to move focusto help direct the user's attention.

We're so ready to go on a vacation,and we've started working on a vacation planner app.

This app works across all Apple platforms,and it allows you to browse destinationsas well as book trips.

When you launch this app, we present an email field,a password field, and a Sign in with Apple buttonso you can log into your account.

On this login screen, if we discover that the email enteredwas not in the correct format,we want to programmatically move focus back to the email field.

To accomplish this behavior,we'll use the FocusState APIs.

The existing code for our login viewcontains a VStack that has a TextField and a SecureField.

Now, we'll add a FocusState property wrapper to this view.

FocusState is a new API that we have introduced this year!This is a special type of state that changesdepending on the current location of focus.

We'll use FocusState to hold an identifierfor the field that is focused.

The focusedField variable is of an enum type that we createdfor this example.

You can use strings, integers,or any other hashable value type for FocusState.

Note that the FocusState value is optional.

In general, types used for FocusStatemust be both hashable and optional,with nil used for cases where focusis in an unrelated part of the screen.

Next we'll add a focused modifierto the TextField and the SecureField.

Also new this year, this modifier creates a linkbetween the placement of focusand the value of the focusedField property.

This simple link is a powerful tool,because it means you can use the current placement of focusfor making other decisions in your app.

We can watch that play out in our login form.

When the screen first appears, nothing has focus,so the value of focusedField is nil.

But if someone then taps on the email text field,that field gains focus and the keyboard appears.

Since the focused text field is bound to a FocusState value,the value of focusedField will automatically be updatedto hold the identifier for the email text field.

The link between focus placement and FocusState works both ways.

This means that we are not limitedto reacting to focus changes;we can move focus programmaticallyjust by updating our FocusState property.

So for example, if we programmatically set the valueof focusedField to .password,SwiftUI will know that our SecureFieldis associated with the new value we're settingand focus will automatically move to the password field.

Now that our focus bindings are in place,we can put them to work.

In the Vacation Planner app, when a user submits their data,we want to validate it.

If the email is not in the expected format,we set the focusedField to email.

This will send focus back to the email text field,if it's not there already.

Further, we'd like to highlight the email field with a borderif the email was invalid.

We want this border to appearonly while focus is on the email field.

To do that, we can easily read the value of focusedFieldwhen we create the border.

Let's see how this all comes together.

Note the email field doesn't have a valid address.

Focus is currently on the password field.

When we hit Go, the onSubmit callback is triggeredwhere the focusedField is set.

This causes the cursor to move back to the email field.

While the email field is focused,we see the red border around it.

However, once we move focus away from the email field,our focusedField is no longer equal to the email identifier,and so the red border disappears.

In the scenario where all the form data is valid,we want to simply dismiss the keyboard.

To dismiss the keyboard,we will set our FocusState variable to nil.

Since the focusedField is an optional,we use nil to indicate that focus has left this view.

In the video, notice that the email address has been updated.

This time when we submit, the keyboard gets dismissedsince we have set the FocusState variable to nil.

We've seen how it can be helpfulto programmatically control focuswhen our app has text fields.

However, FocusStates are not just for text fields.

They can be used to programmatically control focusfor any focusable view on iOS, tvOS, watchOS, or macOS!In the next section, we'll discuss the roleof focus-based navigation in our apps.

Let's take a look at the tvOS versionof our Vacation Planner app.

We have leveraged the extra space on TVby adding photos from some destinationsthat you may want to visit.

You can view more photosby clicking the Browse Photos buttoneven before you've logged in.

Notice that focus is initially on the Email field.

If we swipe right on the Siri Remote,we'd expect focus to move to the Browse Photos button.

However, that doesn't work by default.

This is because directional focus navigationis based on adjacency relationships.

When swiping to move focus, focus will only move if there issomething adjacent and focusable in the given direction.

Take a look at the focusable views in this app.

Since there's no focusable viewadjacent to the login fields on the left,the button on the bottom is unreachable.

To make this screen navigable,we will extend the Browse button's focusable area,so it becomes adjacent to the login fields.

This is done using the new FocusSections API.

Let's see how easy that is.

Here we have a simplified versionof the Vacation Planner code for TV.

It contains an HStack with two VStacks;one for the login fields,and another VStack for the image and the button.

We want to create a larger logical focus targetaround the button so focus can behaveas if the button was adjacent to the login fields.

This can be done by simply adding a focusSection() modifierto the VStack that contains the button.

When focusSection() modifier is added to any view,the frame of that view becomes capable of accepting focusif it contains any focusable subviews.

Since we also want to move focus back to the login fieldswhen swiping left on the button,we'll add another focusSection() modifier to the first VStack.

Now when we run this app, users can move focusbetween the input fields and the Browse buttonby swiping left and right on the remote.

As we wrap things up,I'd encourage you to think about focus,which can often look different on different platforms.

SwiftUI has great default behaviorsbuilt in for most cases.

The new focus states and FocusSections APIscan help you take advantage of focusto create even more streamlined experiences.

As you work on your apps,take a moment to observe the many waysin which focus impacts user behavior.

We hope this session has equipped you with the toolsthat'll help users focus on what's most important.

Thanks for watching, and have an awesome WWDC!♪

3:38 -Slide 13 - Textfield and Securefield

3:49 -Slide 14 - Focus State

4:07 -Slide 15 - Focus Field

4:32 -Slide 17 - focused modifiers

6:07 -Slide 25 - onSubmit

6:25 -Slide 26 - border

7:17 -Slide 29 - dismiss keyboard with nil

9:24 -tv code

9:47 -focus section 1

10:06 -focus section 2

## Code Samples

```swift
import
 SwiftUI

import
 AuthenticationServices


struct
 
ContentView
: 
View
 
{

    
@State
 
private
 
var
 email: 
String
 
=
 
""

    
@State
 
private
 
var
 password: 
String
 
=
 
""


    
var
 body: 
some
 
View
 {
        
ZStack
 {
            
Image
(
"backgroundImage"
)
                .resizable()
                .opacity(
0.7
)
                .ignoresSafeArea()

            
VStack
(alignment: .center) {
                
Text
(
"Vacation Planner"
)
                    .font(.custom(
"Baskerville-SemiBoldItalic"
, size: 
60
))
                    .foregroundColor(.black.opacity(
0.8
))
                    .frame(alignment: .top)

                
Spacer
(minLength: 
30
)

                
TextField
(
"Email"
, text: 
$email
)
                    .submitLabel(.next)
                    .textContentType(.emailAddress)
                    .keyboardType(.emailAddress)
                    .padding()
                    .frame(height: 
50
)
                    .background(
Color
.white.opacity(
0.9
))
                    .cornerRadius(
15
)
                    .padding(
10
)

                
SecureField
(
"Password"
, text: 
$password
)
                    .submitLabel(.go)
                    .padding()
                    .frame(height:
50
)
                    .textContentType(.password)
                    .background(
Color
.white.opacity(
0.9
))
                    .cornerRadius(
15
)
                    .padding(
10
)

                
Spacer
().frame(height: 
20
)

                
HStack
 {
                    
Rectangle
().frame(height: 
1
)
                    
Text
(
"or"
).bold().padding()
                    
Rectangle
().frame(height: 
1
)
                }
                .foregroundColor(.black.opacity(
0.7
))
                
                
Spacer
().frame(height: 
20
)

                
SignInWithAppleButton
(.signIn) { request 
in

                    request.requestedScopes 
=
 [.fullName, .email]
                } onCompletion: { result 
in

                    
switch
 result {
                    
case
 .success (
_
):
                        
print
(
"Authorization successful."
)
                    
case
 .failure (
let
 error):
                        
print
(
"Authorization failed: "
 
+
 error.localizedDescription)
                    }
                }
                .frame(height: 
50
)
                .cornerRadius(
15
)

                
Spacer
().frame(height: 
20
)

            }
            .frame(width: 
280
, height: 
500
, alignment: .bottom)
        }
    }

}
```

```swift
import
 SwiftUI

import
 AuthenticationServices


struct
 
ContentView
: 
View
 
{

    
@FocusState
 
private
 
var
 focusedField: 
Field
?
    
@State
 
private
 
var
 email: 
String
 
=
 
""

    
@State
 
private
 
var
 password: 
String
 
=
 
""


    
var
 body: 
some
 
View
 {
        
ZStack
 {
            
Image
(
"backgroundImage"
)
                .resizable()
                .opacity(
0.7
)
                .ignoresSafeArea()

            
VStack
(alignment: .center) {
                
Text
(
"Vacation Planner"
)
                    .font(.custom(
"Baskerville-SemiBoldItalic"
, size: 
60
))
                    .foregroundColor(.black.opacity(
0.8
))
                    .frame(alignment: .top)

                
Spacer
(minLength: 
30
)

                
TextField
(
"Email"
, text: 
$email
)
                    .submitLabel(.next)
                    .textContentType(.emailAddress)
                    .keyboardType(.emailAddress)
                    .padding()
                    .frame(height: 
50
)
                    .background(
Color
.white.opacity(
0.9
))
                    .cornerRadius(
15
)
                    .padding(
10
)

                
SecureField
(
"Password"
, text: 
$password
)
                    .submitLabel(.go)
                    .padding()
                    .frame(height:
50
)
                    .textContentType(.password)
                    .background(
Color
.white.opacity(
0.9
))
                    .cornerRadius(
15
)
                    .padding(
10
)

                
Spacer
().frame(height: 
20
)

                
HStack
 {
                    
Rectangle
().frame(height: 
1
)
                    
Text
(
"or"
).bold().padding()
                    
Rectangle
().frame(height: 
1
)
                }
                .foregroundColor(.black.opacity(
0.7
))
                
                
Spacer
().frame(height: 
20
)

                
SignInWithAppleButton
(.signIn) { request 
in

                    request.requestedScopes 
=
 [.fullName, .email]
                } onCompletion: { result 
in

                    
switch
 result {
                    
case
 .success (
_
):
                        
print
(
"Authorization successful."
)
                    
case
 .failure (
let
 error):
                        
print
(
"Authorization failed: "
 
+
 error.localizedDescription)
                    }
                }
                .frame(height: 
50
)
                .cornerRadius(
15
)

                
Spacer
().frame(height: 
20
)

            }
            .frame(width: 
280
, height: 
500
, alignment: .bottom)
        }
    }

}
```

```swift
import
 SwiftUI

import
 AuthenticationServices


enum
 
Field
: 
Hashable
 
{
    
case
 email
    
case
 password
}


struct
 
ContentView
: 
View
 
{

    
@FocusState
 
private
 
var
 focusedField: 
Field
?
    
@State
 
private
 
var
 email: 
String
 
=
 
""

    
@State
 
private
 
var
 password: 
String
 
=
 
""


    
var
 body: 
some
 
View
 {
        
ZStack
 {
            
Image
(
"backgroundImage"
)
                .resizable()
                .opacity(
0.7
)
                .ignoresSafeArea()

            
VStack
(alignment: .center) {
                
Text
(
"Vacation Planner"
)
                    .font(.custom(
"Baskerville-SemiBoldItalic"
, size: 
60
))
                    .foregroundColor(.black.opacity(
0.8
))
                    .frame(alignment: .top)

                
Spacer
(minLength: 
30
)

                
TextField
(
"Email"
, text: 
$email
)
                    .submitLabel(.next)
                    .textContentType(.emailAddress)
                    .keyboardType(.emailAddress)
                    .padding()
                    .frame(height: 
50
)
                    .background(
Color
.white.opacity(
0.9
))
                    .cornerRadius(
15
)
                    .padding(
10
)

                
SecureField
(
"Password"
, text: 
$password
)
                    .submitLabel(.go)
                    .padding()
                    .frame(height:
50
)
                    .textContentType(.password)
                    .background(
Color
.white.opacity(
0.9
))
                    .cornerRadius(
15
)
                    .padding(
10
)

                
Spacer
().frame(height: 
20
)

                
HStack
 {
                    
Rectangle
().frame(height: 
1
)
                    
Text
(
"or"
).bold().padding()
                    
Rectangle
().frame(height: 
1
)
                }
                .foregroundColor(.black.opacity(
0.7
))
                
                
Spacer
().frame(height: 
20
)

                
SignInWithAppleButton
(.signIn) { request 
in

                    request.requestedScopes 
=
 [.fullName, .email]
                } onCompletion: { result 
in

                    
switch
 result {
                    
case
 .success (
_
):
                        
print
(
"Authorization successful."
)
                    
case
 .failure (
let
 error):
                        
print
(
"Authorization failed: "
 
+
 error.localizedDescription)
                    }
                }
                .frame(height: 
50
)
                .cornerRadius(
15
)

                
Spacer
().frame(height: 
20
)

            }
            .frame(width: 
280
, height: 
500
, alignment: .bottom)
        }
    }

}
```

```swift
import
 SwiftUI

import
 AuthenticationServices


enum
 
Field
: 
Hashable
 
{
    
case
 email
    
case
 password
}


struct
 
ContentView
: 
View
 
{

    
@FocusState
 
private
 
var
 focusedField: 
Field
?
    
@State
 
private
 
var
 email: 
String
 
=
 
""

    
@State
 
private
 
var
 password: 
String
 
=
 
""


    
var
 body: 
some
 
View
 {
        
ZStack
 {
            
Image
(
"backgroundImage"
)
                .resizable()
                .opacity(
0.7
)
                .ignoresSafeArea()

            
VStack
(alignment: .center) {
                
Text
(
"Vacation Planner"
)
                    .font(.custom(
"Baskerville-SemiBoldItalic"
, size: 
60
))
                    .foregroundColor(.black.opacity(
0.8
))
                    .frame(alignment: .top)

                
Spacer
(minLength: 
30
)

                
TextField
(
"Email"
, text: 
$email
)
                    .submitLabel(.next)
                    .textContentType(.emailAddress)
                    .keyboardType(.emailAddress)
                    .padding()
                    .frame(height: 
50
)
                    .background(
Color
.white.opacity(
0.9
))
                    .cornerRadius(
15
)
                    .padding(
10
)
                    .focused(
$focusedField
, equals: .email)

                
SecureField
(
"Password"
, text: 
$password
)
                    .submitLabel(.go)
                    .padding()
                    .frame(height:
50
)
                    .textContentType(.password)
                    .background(
Color
.white.opacity(
0.9
))
                    .cornerRadius(
15
)
                    .padding(
10
)
                    .focused(
$focusedField
, equals: .password)

                
Spacer
().frame(height: 
20
)

                
HStack
 {
                    
Rectangle
().frame(height: 
1
)
                    
Text
(
"or"
).bold().padding()
                    
Rectangle
().frame(height: 
1
)
                }
                .foregroundColor(.black.opacity(
0.7
))
                
                
Spacer
().frame(height: 
20
)

                
SignInWithAppleButton
(.signIn) { request 
in

                    request.requestedScopes 
=
 [.fullName, .email]
                } onCompletion: { result 
in

                    
switch
 result {
                    
case
 .success (
_
):
                        
print
(
"Authorization successful."
)
                    
case
 .failure (
let
 error):
                        
print
(
"Authorization failed: "
 
+
 error.localizedDescription)
                    }
                }
                .frame(height: 
50
)
                .cornerRadius(
15
)

                
Spacer
().frame(height: 
20
)

            }
            .frame(width: 
280
, height: 
500
, alignment: .bottom)
        }
    }

}
```

```swift
import
 SwiftUI

import
 AuthenticationServices


enum
 
Field
: 
Hashable
 
{
    
case
 email
    
case
 password
}


struct
 
ContentView
: 
View
 
{

    
@FocusState
 
private
 
var
 focusedField: 
Field
?
    
@State
 
private
 
var
 email: 
String
 
=
 
""

    
@State
 
private
 
var
 password: 
String
 
=
 
""

    
@State
 
private
 
var
 submittedEmail: 
String
 
=
 
""


    
var
 body: 
some
 
View
 {
        
ZStack
 {
            
Image
(
"backgroundImage"
)
                .resizable()
                .opacity(
0.7
)
                .ignoresSafeArea()

            
VStack
(alignment: .center) {
                
Text
(
"Vacation Planner"
)
                    .font(.custom(
"Baskerville-SemiBoldItalic"
, size: 
60
))
                    .foregroundColor(.black.opacity(
0.8
))
                    .frame(alignment: .top)

                
Spacer
(minLength: 
30
)

                
TextField
(
"Email"
, text: 
$email
)
                    .submitLabel(.next)
                    .textContentType(.emailAddress)
                    .keyboardType(.emailAddress)
                    .padding()
                    .frame(height: 
50
)
                    .background(
Color
.white.opacity(
0.9
))
                    .cornerRadius(
15
)
                    .padding(
10
)
                    .focused(
$focusedField
, equals: .email)

                
SecureField
(
"Password"
, text: 
$password
)
                    .submitLabel(.go)
                    .padding()
                    .frame(height:
50
)
                    .textContentType(.password)
                    .background(
Color
.white.opacity(
0.9
))
                    .cornerRadius(
15
)
                    .padding(
10
)
                    .focused(
$focusedField
, equals: .password)

                
Spacer
().frame(height: 
20
)

                
HStack
 {
                    
Rectangle
().frame(height: 
1
)
                    
Text
(
"or"
).bold().padding()
                    
Rectangle
().frame(height: 
1
)
                }
                .foregroundColor(.black.opacity(
0.7
))
                
                
Spacer
().frame(height: 
20
)

                
SignInWithAppleButton
(.signIn) { request 
in

                    request.requestedScopes 
=
 [.fullName, .email]
                } onCompletion: { result 
in

                    
switch
 result {
                    
case
 .success (
_
):
                        
print
(
"Authorization successful."
)
                    
case
 .failure (
let
 error):
                        
print
(
"Authorization failed: "
 
+
 error.localizedDescription)
                    }
                }
                .frame(height: 
50
)
                .cornerRadius(
15
)

                
Spacer
().frame(height: 
20
)

            }
            .frame(width: 
280
, height: 
500
, alignment: .bottom)
            .onSubmit {
                submittedEmail 
=
 email
                
if
 
!
isEmailValid {
                    focusedField 
=
 .email
                }
            }
        }
    }
  
    
private
 
var
 isEmailValid : 
Bool
 {
        
let
 regex 
=
 
"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+
\\
.[A-Za-z]{2,64}"

        
let
 predicate 
=
 
NSPredicate
(format:
"SELF MATCHES %@"
, regex)
        
return
 submittedEmail.isEmpty 
||
 predicate.evaluate(with: submittedEmail)
    }

}
```

```swift
import
 SwiftUI

import
 AuthenticationServices


enum
 
Field
: 
Hashable
 
{
    
case
 email
    
case
 password
}


struct
 
ContentView
: 
View
 
{

    
@FocusState
 
private
 
var
 focusedField: 
Field
?
    
@State
 
private
 
var
 email: 
String
 
=
 
""

    
@State
 
private
 
var
 password: 
String
 
=
 
""

    
@State
 
private
 
var
 submittedEmail: 
String
 
=
 
""


    
var
 body: 
some
 
View
 {
        
ZStack
 {
            
Image
(
"backgroundImage"
)
                .resizable()
                .opacity(
0.7
)
                .ignoresSafeArea()

            
VStack
(alignment: .center) {
                
Text
(
"Vacation Planner"
)
                    .font(.custom(
"Baskerville-SemiBoldItalic"
, size: 
60
))
                    .foregroundColor(.black.opacity(
0.8
))
                    .frame(alignment: .top)

                
Spacer
(minLength: 
30
)

                
TextField
(
"Email"
, text: 
$email
)
                    .submitLabel(.next)
                    .textContentType(.emailAddress)
                    .keyboardType(.emailAddress)
                    .padding()
                    .frame(height: 
50
)
                    .background(
Color
.white.opacity(
0.9
))
                    .cornerRadius(
15
)
                    .padding(
10
)
                    .focused(
$focusedField
, equals: .email)
                    .border(
Color
.red,
                            width: (focusedField 
==
 .email 
&&

                                    
!
isEmailValid) 
?
 
2
 : 
0
)

                
SecureField
(
"Password"
, text: 
$password
)
                    .submitLabel(.go)
                    .padding()
                    .frame(height:
50
)
                    .textContentType(.password)
                    .background(
Color
.white.opacity(
0.9
))
                    .cornerRadius(
15
)
                    .padding(
10
)
                    .focused(
$focusedField
, equals: .password)

                
Spacer
().frame(height: 
20
)

                
HStack
 {
                    
Rectangle
().frame(height: 
1
)
                    
Text
(
"or"
).bold().padding()
                    
Rectangle
().frame(height: 
1
)
                }
                .foregroundColor(.black.opacity(
0.7
))
                
                
Spacer
().frame(height: 
20
)

                
SignInWithAppleButton
(.signIn) { request 
in

                    request.requestedScopes 
=
 [.fullName, .email]
                } onCompletion: { result 
in

                    
switch
 result {
                    
case
 .success (
_
):
                        
print
(
"Authorization successful."
)
                    
case
 .failure (
let
 error):
                        
print
(
"Authorization failed: "
 
+
 error.localizedDescription)
                    }
                }
                .frame(height: 
50
)
                .cornerRadius(
15
)

                
Spacer
().frame(height: 
20
)

            }
            .frame(width: 
280
, height: 
500
, alignment: .bottom)
            .onSubmit {
                submittedEmail 
=
 email
                
if
 
!
isEmailValid {
                    focusedField 
=
 .email
                }
            }
        }
    }
  
    
private
 
var
 isEmailValid : 
Bool
 {
        
let
 regex 
=
 
"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+
\\
.[A-Za-z]{2,64}"

        
let
 predicate 
=
 
NSPredicate
(format:
"SELF MATCHES %@"
, regex)
        
return
 submittedEmail.isEmpty 
||
 predicate.evaluate(with: submittedEmail)
    }

}
```

```swift
import
 SwiftUI

import
 AuthenticationServices


enum
 
Field
: 
Hashable
 
{
    
case
 email
    
case
 password
}


struct
 
ContentView
: 
View
 
{

    
@FocusState
 
private
 
var
 focusedField: 
Field
?
    
@State
 
private
 
var
 email: 
String
 
=
 
""

    
@State
 
private
 
var
 password: 
String
 
=
 
""

    
@State
 
private
 
var
 submittedEmail: 
String
 
=
 
""


    
var
 body: 
some
 
View
 {
        
ZStack
 {
            
Image
(
"backgroundImage"
)
                .resizable()
                .opacity(
0.7
)
                .ignoresSafeArea()

            
VStack
(alignment: .center) {
                
Text
(
"Vacation Planner"
)
                    .font(.custom(
"Baskerville-SemiBoldItalic"
, size: 
60
))
                    .foregroundColor(.black.opacity(
0.8
))
                    .frame(alignment: .top)

                
Spacer
(minLength: 
30
)

                
TextField
(
"Email"
, text: 
$email
)
                    .submitLabel(.next)
                    .textContentType(.emailAddress)
                    .keyboardType(.emailAddress)
                    .padding()
                    .frame(height: 
50
)
                    .background(
Color
.white.opacity(
0.9
))
                    .cornerRadius(
15
)
                    .padding(
10
)
                    .focused(
$focusedField
, equals: .email)
                    .border(
Color
.red,
                            width: (focusedField 
==
 .email 
&&

                                    
!
isEmailValid) 
?
 
2
 : 
0
)

                
SecureField
(
"Password"
, text: 
$password
)
                    .submitLabel(.go)
                    .padding()
                    .frame(height:
50
)
                    .textContentType(.password)
                    .background(
Color
.white.opacity(
0.9
))
                    .cornerRadius(
15
)
                    .padding(
10
)
                    .focused(
$focusedField
, equals: .password)

                
Spacer
().frame(height: 
20
)

                
HStack
 {
                    
Rectangle
().frame(height: 
1
)
                    
Text
(
"or"
).bold().padding()
                    
Rectangle
().frame(height: 
1
)
                }
                .foregroundColor(.black.opacity(
0.7
))
                
                
Spacer
().frame(height: 
20
)

                
SignInWithAppleButton
(.signIn) { request 
in

                    request.requestedScopes 
=
 [.fullName, .email]
                } onCompletion: { result 
in

                    
switch
 result {
                    
case
 .success (
_
):
                        
print
(
"Authorization successful."
)
                    
case
 .failure (
let
 error):
                        
print
(
"Authorization failed: "
 
+
 error.localizedDescription)
                    }
                }
                .frame(height: 
50
)
                .cornerRadius(
15
)

                
Spacer
().frame(height: 
20
)

            }
            .frame(width: 
280
, height: 
500
, alignment: .bottom)
            .onSubmit {
                submittedEmail 
=
 email
                
if
 
!
isEmailValid {
                    focusedField 
=
 .email
                } 
else
 {
                    focusedField 
=
 
nil

                    
// Show progress indicator, and log in.

                }
            }
        }
    }
  
    
private
 
var
 isEmailValid : 
Bool
 {
        
let
 regex 
=
 
"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+
\\
.[A-Za-z]{2,64}"

        
let
 predicate 
=
 
NSPredicate
(format:
"SELF MATCHES %@"
, regex)
        
return
 submittedEmail.isEmpty 
||
 predicate.evaluate(with: submittedEmail)
    }

}
```

```swift
import
 SwiftUI

import
 AuthenticationServices



struct
 
ContentView
: 
View
 
{

    
@State
 
private
 
var
 email: 
String
 
=
 
""

    
@State
 
private
 
var
 password: 
String
 
=
 
""


    
var
 body: 
some
 
View
 {
        
HStack
 {
            
VStack
(alignment: .leading) {
                
Spacer
(minLength:
60
).frame(height: 
150
)
                
Text
(
"Vacation
\n
Planner"
)
                    .font(.custom(
"Baskerville-SemiBoldItalic"
, size: 
60
))
                    .foregroundColor(
Color
.black.opacity(
0.8
))
                    .lineLimit(
nil
)
                    .multilineTextAlignment(.center)
                    .padding(.horizontal, 
40
)

                
Spacer
().frame(height:
80
)

                
TextField
(
"Email"
, text: 
$email
)
                    .submitLabel(.next)
                    .textContentType(.emailAddress)
                    .keyboardType(.emailAddress)

                
Spacer
().frame(height:
30
)

                
SecureField
(
"Password"
, text: 
$password
)
                    .submitLabel(.go)
                    .textContentType(.password)

                
HStack
 {
                    
Rectangle
().frame(height: 
1
)
                    
Text
(
"or"
).bold().padding()
                    
Rectangle
().frame(height: 
1
)
                }
                .foregroundColor(
Color
.black.opacity(
0.7
))

                
Spacer
().frame(height: 
20
)

                
SignInWithAppleButton
(.signIn) { request 
in

                    request.requestedScopes 
=
 [.fullName, .email]
                } onCompletion: { result 
in

                    
switch
 result {
                    
case
 .success (
_
):
                        
print
(
"Authorization successful."
)
                    
case
 .failure (
let
 error):
                        
print
(
"Authorization failed: "
 
+
 error.localizedDescription)
                    }
                }
                .frame(height: 
50
)
                
Spacer
()
            }
            .frame(width: 
350
, alignment: .center)

            
VStack
 {
                
Image
(photoName)
                    .resizable()
                    .frame(width: 
1400
)
                    .aspectRatio(contentMode: .fit)
                    .ignoresSafeArea(edges: [.trailing])
                
BrowsePhotosButton
()
            }
        }.preferredColorScheme(.light)
    }
}
```

```swift
import
 SwiftUI

import
 AuthenticationServices



struct
 
ContentView
: 
View
 
{

    
@State
 
private
 
var
 email: 
String
 
=
 
""

    
@State
 
private
 
var
 password: 
String
 
=
 
""


    
var
 body: 
some
 
View
 {
        
HStack
 {
            
VStack
(alignment: .leading) {
                
Spacer
(minLength:
60
).frame(height: 
150
)
                
Text
(
"Vacation
\n
Planner"
)
                    .font(.custom(
"Baskerville-SemiBoldItalic"
, size: 
60
))
                    .foregroundColor(
Color
.black.opacity(
0.8
))
                    .lineLimit(
nil
)
                    .multilineTextAlignment(.center)
                    .padding(.horizontal, 
40
)

                
Spacer
().frame(height:
80
)

                
TextField
(
"Email"
, text: 
$email
)
                    .submitLabel(.next)
                    .textContentType(.emailAddress)
                    .keyboardType(.emailAddress)

                
Spacer
().frame(height:
30
)

                
SecureField
(
"Password"
, text: 
$password
)
                    .submitLabel(.go)
                    .textContentType(.password)

                
HStack
 {
                    
Rectangle
().frame(height: 
1
)
                    
Text
(
"or"
).bold().padding()
                    
Rectangle
().frame(height: 
1
)
                }
                .foregroundColor(
Color
.black.opacity(
0.7
))

                
Spacer
().frame(height: 
20
)

                
SignInWithAppleButton
(.signIn) { request 
in

                    request.requestedScopes 
=
 [.fullName, .email]
                } onCompletion: { result 
in

                    
switch
 result {
                    
case
 .success (
_
):
                        
print
(
"Authorization successful."
)
                    
case
 .failure (
let
 error):
                        
print
(
"Authorization failed: "
 
+
 error.localizedDescription)
                    }
                }
                .frame(height: 
50
)
                
Spacer
()
            }
            .frame(width: 
350
, alignment: .center)

            
VStack
 {
                
Image
(photoName)
                    .resizable()
                    .frame(width: 
1400
)
                    .aspectRatio(contentMode: .fit)
                    .ignoresSafeArea(edges: [.trailing])
                
BrowsePhotosButton
()
            }
            .focusSection()
        }.preferredColorScheme(.light)
    }
}
```

```swift
import
 SwiftUI

import
 AuthenticationServices



struct
 
ContentView
: 
View
 
{

    
@State
 
private
 
var
 email: 
String
 
=
 
""

    
@State
 
private
 
var
 password: 
String
 
=
 
""


    
var
 body: 
some
 
View
 {
        
HStack
 {
            
VStack
(alignment: .leading) {
                
Spacer
(minLength:
60
).frame(height: 
150
)
                
Text
(
"Vacation
\n
Planner"
)
                    .font(.custom(
"Baskerville-SemiBoldItalic"
, size: 
60
))
                    .foregroundColor(
Color
.black.opacity(
0.8
))
                    .lineLimit(
nil
)
                    .multilineTextAlignment(.center)
                    .padding(.horizontal, 
40
)

                
Spacer
().frame(height:
80
)

                
TextField
(
"Email"
, text: 
$email
)
                    .submitLabel(.next)
                    .textContentType(.emailAddress)
                    .keyboardType(.emailAddress)

                
Spacer
().frame(height:
30
)

                
SecureField
(
"Password"
, text: 
$password
)
                    .submitLabel(.go)
                    .textContentType(.password)

                
HStack
 {
                    
Rectangle
().frame(height: 
1
)
                    
Text
(
"or"
).bold().padding()
                    
Rectangle
().frame(height: 
1
)
                }
                .foregroundColor(
Color
.black.opacity(
0.7
))

                
Spacer
().frame(height: 
20
)

                
SignInWithAppleButton
(.signIn) { request 
in

                    request.requestedScopes 
=
 [.fullName, .email]
                } onCompletion: { result 
in

                    
switch
 result {
                    
case
 .success (
_
):
                        
print
(
"Authorization successful."
)
                    
case
 .failure (
let
 error):
                        
print
(
"Authorization failed: "
 
+
 error.localizedDescription)
                    }
                }
                .frame(height: 
50
)
                
Spacer
()
            }
            .frame(width: 
350
, alignment: .center)
            .focusSection()

            
VStack
 {
                
Image
(photoName)
                    .resizable()
                    .frame(width: 
1400
)
                    .aspectRatio(contentMode: .fit)
                    .ignoresSafeArea(edges: [.trailing])
                
BrowsePhotosButton
()
            }
            .focusSection()
        }.preferredColorScheme(.light)
    }
}
```


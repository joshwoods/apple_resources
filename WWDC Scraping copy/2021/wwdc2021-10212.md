# Wwdc2021 10212

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Analyze HTTP traffic in InstrumentsLearn to use the Instruments Network template to record and analyze your app's HTTP traffic. We'll show you how to explore and visualize the behavior of sessions, tasks, and individual HTTP requests to ensure data is transmitted efficiently and respects people's privacy.ResourcesAnalyzing HTTP traffic with InstrumentsHD VideoSD VideoRelated VideosWWDC23Beyond the basics of structured concurrencyWWDC21Accelerate networking with HTTP/3 and QUICApple’s privacy pillars in focusReduce network delays for your appUse async/await with URLSessionWWDC19Getting Started with Instruments

Learn to use the Instruments Network template to record and analyze your app's HTTP traffic. We'll show you how to explore and visualize the behavior of sessions, tasks, and individual HTTP requests to ensure data is transmitted efficiently and respects people's privacy.

Analyzing HTTP traffic with Instruments

HD VideoSD Video

HD Video

SD Video

Beyond the basics of structured concurrency

Accelerate networking with HTTP/3 and QUIC

Apple’s privacy pillars in focus

Reduce network delays for your app

Use async/await with URLSession

Getting Started with Instruments

Search this video…Welcome! My name is Kacper.I'm a Performance Tools Engineer at Apple, and today,together with Sergio, we'll be talking about the newHTTP Traffic Instrument available in Instruments 13.This Instrument, contained in the Network template,allows you to inspect HTTP trafficcoming from your applicationthrough the Apple Networking stack.This approach comes with multiple benefits.It just works on all Apple devices.The entire traffic going through the URL loading systemis exposed, even the ones sentwith the new HTTP/3 protocol or over VPN.Because of the system integration,it attributes traffic to processes running on it,and since it's instrumentingApple Networking frameworks, it even reveals requestshitting the on-disk cache or networking errors.All of this exposed in the contextof higher-level API concepts that you are familiar with,such as URLSessions and URLSessionTasks.This tool will help you understandhow your usage of the APItranslates to the lifetime of network requests.In this hands-on session, we will first get you familiarwith how the Instruments UI reflectsthe API concepts you are using.After this quick introduction, we will transition to four demosthat will illustrate how you can use the toolto detect both performance and correctness problems.And even if your app seems to work flawlessly,you will learn how to verify that it doeswhat you think by auditing the traffic coming from it.Let's get started with how the Networking API mapsto the Instruments visualization.This is how the HTTP Traffic traceis displayed in Instruments when I recordedmy system traffic using the Network template.Navigation is structured around the track hierarchy,and that's what we will cover in detail first.The HTTP Traffic Instrument located at the top levelshows you an overview of how manyURLSession tasks were running in your traceat any given time, ideal for detecting spotswith increased HTTP Traffic activity in your app's lifetime.The next hierarchy level shows a breakdownof activity by process.In addition to traffic from all of the debuggable processes,it allows you to inspectbackground traffic initiated by them.Contained below each process are all URLSessions used by it.And these correspondto the URLSession objects you create in code.The graph at this level allows you to inspectall individual task intervals.To get a better mapping between your session objectsand the visualization, you can name them in code by settingthe sessionDescription property on a session instance.On the last level, the traffic is broken downby requested domains.Graphs on this level show more details about tasks,including individual transactions that make upthe tasks and their states.To get a better understanding of what tasksand transactions are, let's analyze an example.Here are a few tasks that are loading datafrom the selected domain.Let's focus on one of themto analyze the structure of a task.This single task interval has a lot of information.We can represent this in a more abstract manner to understandhow Instruments visualization maps to the API being used.At the top level, we have a task object.A task is made up of one or more transactions.A transaction is a pair of an HTTP requestand the corresponding response.The task level is the representation of howyour code interacts with the API of the URL Loading System.When you create a task and call resume on it,the task interval starts.And it endsright before your completion block is called.Each task can be given a semantic name usingthe taskDescription property, which will be usedto label the interval in Instruments.We also show the task identifier as part of the task label.You can use it to cross-referencethe task with other data.If your task finishes with an error,its description will be presentedon the interval label for easier debugging.As we mentioned before, a task can be made upof multiple transactions.Let's talk about these now.Here we have a task to load the start page of apple.com.However, this URL is not the canonical URL.The task requests apple.com,but the preferred domain is www.apple.com.When we create this task, the URL loading systeminitially creates a request to apple.com.Shortly after, it receives a redirect responsefrom the server,stating that the preferred URL is actually www.apple.com.By default, we follow redirects, so instead of returningthe 301 response, the URL loading systemwill create a new transaction to now load the preferred URL.The response from this second, successful transactionis what is returned back to the task.As mentioned before, a transaction representsthe combination of the HTTP request and response.It aligns with what URLSession does under the hoodto handle your taskand contains all of the information of the HTTP layer,like the requested URL,information about the transferred data,and much more.Just like for the task, the transaction labelgives you an overview of the transaction.Mainly, you get information aboutthe request and the response.The track hierarchy tells you the domainthat is requested, while you can findthe path and query on the label itself.In addition to that, the interval labeldisplays the HTTP version,the HTTP Method,and whether the request sent an Authorizationor a Cookie header.These are often useful to understandauthentication flows at a glance.For the response, you get the status code,whether the response contained a cookie,and the content type of the response.How long the request and the response took,as well as more detailed timing informationabout other work that is part of the transactionis captured by the transaction states.Let's analyze them in the contextof a containing task.The start of the transaction is the point in timewhen the URL Loading Systemcreates the transaction for making this request.It first checks whether we have a valid cached response already.And if that's not the case, it will try to schedulethe request on a connection.Next, the transaction may have to wait a bitin the Blocked state, waiting for an available connection.The Sending Request state starts when the transactionis finally handled by a connection.It ends once we send the last byteof the request onto the network.Next, the transaction goes into an idleWaiting for Response state,followed by Receiving Response, which will track the spanfrom the first to the last byte received from the server.The whole transaction will complete shortlyafter the last byte is received, once the URL Loading systemhas determined whether this was a successful response.In practice, the cache lookup and sending statefor a GET request are usually much shorter,so it's more likely to appear like this.To show you some practical examples,I would like to hand over to my colleague, Sergio.He will walk you through an app he recently started developingto illustrate how the HTTP Instrument can help youwith fixing performance and correctness issues.Thanks, Kacper. Hello, everyone.My name is Sergio Lopez, and I've been workingon this app for dog lovers.Think of it like a social media platform but for dog pictures...only!People can post images of dogs and you geta stream of the most recent uploads!So when I open the app, it loadsseveral new dog images, but I noticed that it takesquite some time for them to finish loading.Let's profile the app with the new HTTP Trafficinstrument to help us improve this situation.In the "Product" menu, I'll choosethe "Profile" option to profile my app in Instruments.This will build my app in the release configuration,to ensure I'm profiling my app as it would run for my users,with all optimizations turned on.Once the build is finished,Instruments will launch automatically.Upon starting, the standard template chooserof Instruments is displayed.In our case, I wanna choose the Networktemplate on the bottom left, which gives us more informationabout general network connections my app makes,but also contains the new HTTP Tracing functionality.The track area now contains two tracks, one for each instrument.The bottom track is the existing Network Connections instrument,and the top track is the new HTTP Traffic instrument.We'll focus on this new instrument today.All I need to do now is hit "record."Instruments will then start my app and start recording.Before you can use this tool,you need to confirm that you understandthe implications of capturing the networking traffic.It's very powerful, especially if you record all processes.The data captured includes everything that is sent,which may be personal and sensitive information,even up to user credentials.So, you should be very careful with the resulting trace files,and we want you to be aware.So let me confirm this.The app was launchedand the images were slow to load.I will now stop the recording.Let's zoom in to the data we recordedby using Option-click and draggingover the area covering our HTTP traffic.Clicking on the disclosure indicatorin the "HTTP Traffic" track on the top leftwill reveal the full track hierarchythat Kacper described earlier.I'll also increase the track height to show all intervals.At the top, there's the first taskthat queries the server for the list of images,which appear on the "Latest" section of the app.When this task completes, we create a new task to loada thumbnail for every image on the list that we received.I will now click-drag over the area covering the time frameit took to fetch the list of images,followed by the many requeststo retrieve each individual image.By click-dragging over this area,a tool tip will be displayed,showing the duration of the selected time range.Overall, it took more than 7 secondsto finish loading the initial screen.The first few images load fairly quick.But as I scroll down, tasks that were started latertook longer to complete,as noted by the increasing blocked states in purple.Seems like a congestion issue, where we have too manyrequests in parallel.Let's investigate one of the later tasks.By hovering over the task, the tool tip shows usthe duration of the taskand any of the child intervals we are hovering over.This task was blocked for the majority of the time.To understand why it was blocked,let's switch the track displayto the "HTTP Transactions by Connection" view.In the track sidebar on the left,under the domain name, there's a downwards arrowwe can click to switch the track display.Currently, we are drawing "Tasks."Let's switch to displaying "HTTP Transactions by Connection."This view will only display the transactions,and instead of grouping them by task, we can nowfind out which connection they got scheduled on.The transactions are grouped by the connection they used.Overall, there were six connectionsavailable to handle these transactions.Let's analyze the transactionsissued on Connection 1 and investigatesome of the thumbnail loading transactions further.From the top down, it's noticeablethat each transaction is taking longer to complete.The purple blocked state for eachsuccessive transaction is increasing.In fact, there's a pretty clear staircase pattern here.Each transaction is blocked, until the previous transactionon the same connection has finished.Only then can it send its request.This pattern repeats for each subsequent transaction.This is called "Head of Line Blocking"and is one of the problems of using HTTP/1.The frustrating part is that these transactionsaren't doing anything for the majority of the time.Instead, they spend most of their time blocked or waitingfor the response from the server.We could be sending another requestfor the next transaction in line while waiting for the responseof a previous transaction on the same connection,but that's not supported by HTTP/1.Head-of-line blocking is one of the main limitationsof HTTP/1, and one of the main improvementsof HTTP/2 is to avoid that effect by multiplexingseveral requests to the same server onto a single connection.In HTTP/2, we can actually start sendinga second request while the first one is waiting for its response.Your app does not need to do anything to support it.All Apple platforms support HTTP/2,and starting in iOS 15and macOS Monterey, HTTP/3 is supported as well.The client will pick the most modern HTTP versionthe server supports.If you wanna learn more about the differences between HTTP/1and HTTP/2,and the additional benefits HTTP/3 provides,please watch the "Accelerate networkingwith HTTP/3 and QUIC" session.I've taken this trace, showed it to our server folks,and managed to convince them that we shouldreally support HTTP/2.Now, let's run my app with the newserver enhancements.Wow, this already feels faster!Let's confirm this with Instruments.So here's a trace I recordedafter we turned on server support for HTTP/2.In the domain-specific track, none of our thumbnail-loadingtasks seem to be blocked anymore for an extended amount of time.That's good!Let's switch to the "HTTP Transactionsby Connection" view again.The first thing we notice is that there isonly one connection.This is because we no longer need multiple connectionsto send concurrent requests, which also means we only needto pay the connection setup cost once.Focusing on the individual thumbnail-loading transactions,we notice that they basically spendno time in the "blocked" state.In fact, the amount of time is so smallthat it's not visible at this zoom level.Eventually all transactions finish sendingtheir requests and are left waiting for a response.As I scroll down, we can notice that responsesare making progress at the same time.All in all,we are done with all requests in under 3 seconds.This is twice as fast as before.Now that I've talked to the server folksand switched from HTTP/1.1 to HTTP/2,our images are loading much faster.Let me relaunch the app and show you what else we can do.When I tap on an image, the app loads the full-resolutionpicture and shows how far away this photo was taken from me.There's also a heart icon at the top rightthat allows you to favorite that specific picture.To do so, I need an account.I allow people to use the app and browse the pictureswithout an account, but to save favorited images,sync them between devices,and to upload new pictures, you need an account.So let me log in here.Great. Let me favorite another picture.Oh, this dog looks cute! Let me add it to my favorites.Wait, why do I have to log in again if I just did?This isn't right.My app should remember my log-in.This worked before.I'm gonna dismiss the log-in screen,as I don't want to log in again.I previously recorded a trace fileafter reproducing the issue.Let me open it with instruments to analyze the recording.On the left, there's the task that correspondsto when I pressed the favorite button for the first time.To the right of it, there's the task that wasissued after I returned to the latest tab,and the stream of images were refreshed.Then, there's the task to load the full-resolution imageafter I tapped on another dog picture.And to the far right, there's the task correspondingto the second time I tapped the favorite button.The first task interval actually contains two transactions.The first transaction received a 401-status code.This was expected since we were not logged in.The transaction is drawn in orange to indicatethat this is not a success on the HTTP level.Then, there's a large, empty area in the task,which represents the time I spententering the user name and password.As soon as I'm done entering these credentials,we retry the transaction.The green color of the interval and the 201-status codeindicates it succeeded this time.This interaction of an authentication challenge,entering a password, and retrying the transactionis another case the URL Loading system handles for us,so these two transactions belong to the same task object.Zooming out, we find the second attemptat favoriting an image on the right.The task object is displayed in gray, as my dismissingof the log-in screen caused the task to be canceled,which is also visible in its label.The transaction interval is displayed in orange,as we got a 401 response from the server again.This task occurred after I attempted to likeanother dog picture and wasprompted with the log-in for a second time.We use a very basic log-in system, where the user sendstheir credentials the first time, but once the serververified the user credentials, it sets a cookie,identifying the user, such that no credentialsneed to be provided on following requests.So I would've expected this task to have sent the proper cookie.Let's determine whether that happened.As Kacper explained earlier, there should be a smallcookie icon here next to the HTTP method,had this transaction sent a Cookie header.But there's no such icon here, which means no cookie was sent.So that part isn't working.Now the question is, did the server notprovide us with a cookie, or is the client notsending one, even though it got one?To find out, we need to investigatethe previous transaction, and checkwhether we got a cookie from the server.Here is the previous transaction,the successful one from the first log-in request.This one does have a cookie icon in the response portionof the transaction label, so the server did send a cookie.That's interesting.So why didn't we send the cookie in the next transaction?To get more information about this transactionand investigate the cookie in detail,I will switch to the "Transactions" listin the detail view at the bottom.The transaction is already selected here,since the time cursor is placed inside of it in the track view.The extended detail view in the bottom rightshows all request and response headersof the currently-selected transaction.And here is the Set-Cookie header that we expect.At first glance, this cookie seems fine.But oh, wait, do you see the expiry date?It's March 2020. That's in the past!So the server did send a cookie,but it's an expired cookie.No one likes expired cookies!This will lead the URLSession to not send the cookie,as it will only send cookies that are still valid.This is a server-side bug.I could send the trace file over to our server folksfor them to investigate the issue and have it resolved.Now that we fixed the cookie issue, I can favoritea couple more pictures without being prompted to log in.In addition to the "Latest" tab,there's also a "Favorite" tab, where we display a listof all the dog images that the user has favorited.Let's switch to that tab.Great, there are a few favorites here that I added yesterday,but for some reason, my recent favorites aren't showing up.Let's try again.Let's pick this dog, who seems to be enjoying a bath,and let me favorite it.Let's go back to my favorites and check if it appears.Hm, it's still not there.Let's use Instruments again to figure out what's going on.I prepared a trace file for this already.I expect to find a task loading the list of favoritesin the track view, but it's not visible at first glance.Let me choose the track for my server domain,to display only the requests issued to that domain.We could then go to the detail view at the bottom,which contains a list of all tasks for this domain.There's quite a few requests here.Let me use the detail filter at the bottom leftto search for all requests related to "Favorites,"so I can verify whether we even made a request.Upon filtering, the results show we sentseveral requests to load the list of favorites here.Let's focus on the track view.The cursor got positioned at the start of the task I selecteddown in the detail view, so that makes it fairly easyto find it in the track view above.Let's zoom in to double-check.So this was the first time we loadedthe list of favorites on the initial app launch.This is fine.Here, I favorited a new image, and after that,we loaded the favorites again.Well, there's a task interval here, but it's very short.Yeah, this GET request only took a couple of milliseconds.That's too fast to get a server response.Let's switch to the "HTTP transactionsby connection" view again to get more details.The first thing we notice is that this transactionis not executed on a Connection, but on "Local Cache."This shows us that the request was never sent on the network,but rather loaded from the local cache.This also explains why there is no "Waiting for Response" state,since the transaction did not wait for a server.So that's the problem: our request is cached,so we don't actually ask the server,and always get the cached response back.One way to fix this would be to tell the server to seta cache-control header, to never cache this response.What we want is to reload the images every time the usergoes to the favorites tab and new images have been added.What we don't want is to load the whole listof images if there was no such change.A good trade-off would be if we could ask the server,"Hey, did anything change?If so, please let me know."That's actually something we can doby setting a cache-policy on the request.To update the code, let me go back to the task viewand select the task in question.For each URLSession Task that got executed here...We display the backtrace on the right,where "resume" was called on the task.It was resumed in the method sync,in the ImageCollection type.Let me open this in Xcode to make the change here.Here, I have my URLRequest,and now I wanna set my cache policy.The cache policy I want is reloadRevalidatingCacheData,which means that we ignore the local cacheand will make a request to the server to checkwhether our cache is still valid.If so, the server will send a 304 response codeto let us know to use the local cache.If not, it will send the new data back.Let's give it a try.So these are my current favorited images,and the dog taking a bath has been added.Let's add another one.Now, let's check the "Favorite" tab.The image I just favorited now properly appears.OK, great! That's fixed now as well.Back to my colleague Kacper to cover checkingthat your app and dependencies behave like you'd expect.Just like Sergio showed before,when I click on the "Favorite" tabwithout being logged in, the log-in view is presented.We already added Sign In with Appleto make the log-in experience seamless.However, our company has several pet-themed apps,and another team is working on a shared log-in SDK to allowusers to reuse their account between the applications.This SDK is currently in development,and the other team has asked us whether it couldreplace our classic log-in screen.I got the SDK binary, called Pets,which is distributed as an xcframeworkso that it can be used on all platforms.Integrating it into my Xcode project is as easy as draggingand dropping it in the embedded frameworks section.Now, all that is left is to add a button to our existing view.I will navigate to the source code of our Log-inView.I will first import the framework,and then add the button to our SwiftUI VStack,just below the Sign In with Apple.Let's refresh our Swift UI Preview.Here it is."Sign In with Pets" buttonappeared on the preview, exactly where I want it.That was, indeed, a really easy integration.I am curious to check how quick this new log-in method will be.And to measure this, I'll profile my applicationwith Instruments by using Product Profile Action.I am choosing Network template.And clicking "record" buttonin the toolbar to launch the app.My app has now launched.I can now switch to the Log-in View.Instruments is showing all of the networking trafficoccurring in the meantime.I will expand it to inspect my app's URL session.Here it is.But wait.I would expect only my main app URLSession to be here,but seems that the Pets framework we just integratedis making requests from its own session,without me even clicking on the log-in button.That's unexpected.Let's stop the recording right now to investigate it further.I will zoom in to a few first requests,using option-click and drag.There's many requests to some analytics endpoint,and to get more details, I can click on this"Pets Sign On Network" sessionand list all of them in the detail view.All of them are POST requests, and when I click on one,I can see the backtrace on the right that tells uswhich part of the code the request originated from.So seems that request is going through CFNetwork,invoked by Pets, just as expected.But when we navigate deeper,it seems like CoreLocation is being involved.That's really suspicious, especially becauseI didn't perform any action to trigger it.I wonder if my location is being sent backto the server and that's why CoreLocationand CFNetwork are in the same backtrace.I will verify that by inspectingthe corresponding HTTP transactions for these tasks.To do this, I will switch detailfrom the list of tasks to the list of transactions.And select one of them.In the extended detail on the bottom right,it's visible that this request contains somepretty standard headers, nothing to worry about.But wait, look at the request body.It's including my location coordinates,and that's really bad.Sending this information violates users' privacy.We don't want to gather their locationwithout their consent and without a good reason.So far, our app only requests this permission for legitimatepurposes that make the user experience better.At this point, I will not go any furtherwith this SDK integration.Instead, I will file a bug reporton the other team to inform themabout this unacceptable behavior that I detected.And I can even use this Instruments traceto generate necessary information for the bug report.Let's save it on my desktop first.I will name it "PrivacyViolation"and hit "save."xctrace, command line tool bundled with Instruments,can be used to export this traceto the HTTP Archive format, which is an industry standardfor exchange of information about HTTP Traffic.To do this, I can simply run xctrace export command,with input of my trace, and HAR export flag.Let's run it now.This command generates a file that I can now attachin the bug report.Someone receiving it can inspect the recorded informationin any tool that supports HAR, even if they don't haveInstruments installed on their machine.HAR itself is a JSON-based format,so it can also be openedin the text editor or easily processed using scripts.And even though it doesn't containinstruments-specific details,like URLSessions or backtraces, that still should be enoughfor the other team to investigate this issue.And that's how you can use HTTP Traffic Instrumentto diagnose source and content of traffic coming fromyour application to make sure that you are in controlof what your app does at runtime.Now that you're familiar with using the newHTTP Traffic Instrument, go ahead and target your appsto detect problems just like the ones we showed you today.For easier debugging and having more context while doing so,name your URLSession and task objects.Always aim for adopting latest networking protocols.And even if you don't find any performance or correctnessissues with your app, go ahead and verifyby how much data you're sendingto get rid of any unnecessary traffic.Thank you for watching today, and we hope you havea great time tracing your app's HTTP traffic.[upbeat music]

Welcome! My name is Kacper.I'm a Performance Tools Engineer at Apple, and today,together with Sergio, we'll be talking about the newHTTP Traffic Instrument available in Instruments 13.This Instrument, contained in the Network template,allows you to inspect HTTP trafficcoming from your applicationthrough the Apple Networking stack.

This approach comes with multiple benefits.It just works on all Apple devices.The entire traffic going through the URL loading systemis exposed, even the ones sentwith the new HTTP/3 protocol or over VPN.Because of the system integration,it attributes traffic to processes running on it,and since it's instrumentingApple Networking frameworks, it even reveals requestshitting the on-disk cache or networking errors.All of this exposed in the contextof higher-level API concepts that you are familiar with,such as URLSessions and URLSessionTasks.This tool will help you understandhow your usage of the APItranslates to the lifetime of network requests.In this hands-on session, we will first get you familiarwith how the Instruments UI reflectsthe API concepts you are using.

After this quick introduction, we will transition to four demosthat will illustrate how you can use the toolto detect both performance and correctness problems.And even if your app seems to work flawlessly,you will learn how to verify that it doeswhat you think by auditing the traffic coming from it.Let's get started with how the Networking API mapsto the Instruments visualization.This is how the HTTP Traffic traceis displayed in Instruments when I recordedmy system traffic using the Network template.Navigation is structured around the track hierarchy,and that's what we will cover in detail first.The HTTP Traffic Instrument located at the top levelshows you an overview of how manyURLSession tasks were running in your traceat any given time, ideal for detecting spotswith increased HTTP Traffic activity in your app's lifetime.The next hierarchy level shows a breakdownof activity by process.In addition to traffic from all of the debuggable processes,it allows you to inspectbackground traffic initiated by them.Contained below each process are all URLSessions used by it.And these correspondto the URLSession objects you create in code.The graph at this level allows you to inspectall individual task intervals.To get a better mapping between your session objectsand the visualization, you can name them in code by settingthe sessionDescription property on a session instance.

On the last level, the traffic is broken downby requested domains.Graphs on this level show more details about tasks,including individual transactions that make upthe tasks and their states.

To get a better understanding of what tasksand transactions are, let's analyze an example.

Here are a few tasks that are loading datafrom the selected domain.Let's focus on one of themto analyze the structure of a task.

This single task interval has a lot of information.We can represent this in a more abstract manner to understandhow Instruments visualization maps to the API being used.

At the top level, we have a task object.A task is made up of one or more transactions.

A transaction is a pair of an HTTP requestand the corresponding response.

The task level is the representation of howyour code interacts with the API of the URL Loading System.When you create a task and call resume on it,the task interval starts.And it endsright before your completion block is called.

Each task can be given a semantic name usingthe taskDescription property, which will be usedto label the interval in Instruments.We also show the task identifier as part of the task label.You can use it to cross-referencethe task with other data.If your task finishes with an error,its description will be presentedon the interval label for easier debugging.As we mentioned before, a task can be made upof multiple transactions.Let's talk about these now.Here we have a task to load the start page of apple.com.However, this URL is not the canonical URL.The task requests apple.com,but the preferred domain is www.apple.com.When we create this task, the URL loading systeminitially creates a request to apple.com.Shortly after, it receives a redirect responsefrom the server,stating that the preferred URL is actually www.apple.com.

By default, we follow redirects, so instead of returningthe 301 response, the URL loading systemwill create a new transaction to now load the preferred URL.The response from this second, successful transactionis what is returned back to the task.

As mentioned before, a transaction representsthe combination of the HTTP request and response.It aligns with what URLSession does under the hoodto handle your taskand contains all of the information of the HTTP layer,like the requested URL,information about the transferred data,and much more.

Just like for the task, the transaction labelgives you an overview of the transaction.Mainly, you get information aboutthe request and the response.

The track hierarchy tells you the domainthat is requested, while you can findthe path and query on the label itself.

In addition to that, the interval labeldisplays the HTTP version,the HTTP Method,and whether the request sent an Authorizationor a Cookie header.These are often useful to understandauthentication flows at a glance.

For the response, you get the status code,whether the response contained a cookie,and the content type of the response.How long the request and the response took,as well as more detailed timing informationabout other work that is part of the transactionis captured by the transaction states.Let's analyze them in the contextof a containing task.The start of the transaction is the point in timewhen the URL Loading Systemcreates the transaction for making this request.It first checks whether we have a valid cached response already.And if that's not the case, it will try to schedulethe request on a connection.

Next, the transaction may have to wait a bitin the Blocked state, waiting for an available connection.

The Sending Request state starts when the transactionis finally handled by a connection.It ends once we send the last byteof the request onto the network.Next, the transaction goes into an idleWaiting for Response state,followed by Receiving Response, which will track the spanfrom the first to the last byte received from the server.

The whole transaction will complete shortlyafter the last byte is received, once the URL Loading systemhas determined whether this was a successful response.In practice, the cache lookup and sending statefor a GET request are usually much shorter,so it's more likely to appear like this.

To show you some practical examples,I would like to hand over to my colleague, Sergio.He will walk you through an app he recently started developingto illustrate how the HTTP Instrument can help youwith fixing performance and correctness issues.Thanks, Kacper. Hello, everyone.My name is Sergio Lopez, and I've been workingon this app for dog lovers.Think of it like a social media platform but for dog pictures...only!People can post images of dogs and you geta stream of the most recent uploads!So when I open the app, it loadsseveral new dog images, but I noticed that it takesquite some time for them to finish loading.

Let's profile the app with the new HTTP Trafficinstrument to help us improve this situation.In the "Product" menu, I'll choosethe "Profile" option to profile my app in Instruments.

This will build my app in the release configuration,to ensure I'm profiling my app as it would run for my users,with all optimizations turned on.Once the build is finished,Instruments will launch automatically.Upon starting, the standard template chooserof Instruments is displayed.

In our case, I wanna choose the Networktemplate on the bottom left, which gives us more informationabout general network connections my app makes,but also contains the new HTTP Tracing functionality.

The track area now contains two tracks, one for each instrument.The bottom track is the existing Network Connections instrument,and the top track is the new HTTP Traffic instrument.We'll focus on this new instrument today.All I need to do now is hit "record."Instruments will then start my app and start recording.

Before you can use this tool,you need to confirm that you understandthe implications of capturing the networking traffic.It's very powerful, especially if you record all processes.The data captured includes everything that is sent,which may be personal and sensitive information,even up to user credentials.So, you should be very careful with the resulting trace files,and we want you to be aware.So let me confirm this.

The app was launchedand the images were slow to load.

I will now stop the recording.

Let's zoom in to the data we recordedby using Option-click and draggingover the area covering our HTTP traffic.

Clicking on the disclosure indicatorin the "HTTP Traffic" track on the top leftwill reveal the full track hierarchythat Kacper described earlier.

I'll also increase the track height to show all intervals.

At the top, there's the first taskthat queries the server for the list of images,which appear on the "Latest" section of the app.

When this task completes, we create a new task to loada thumbnail for every image on the list that we received.

I will now click-drag over the area covering the time frameit took to fetch the list of images,followed by the many requeststo retrieve each individual image.

By click-dragging over this area,a tool tip will be displayed,showing the duration of the selected time range.Overall, it took more than 7 secondsto finish loading the initial screen.

The first few images load fairly quick.But as I scroll down, tasks that were started latertook longer to complete,as noted by the increasing blocked states in purple.Seems like a congestion issue, where we have too manyrequests in parallel.Let's investigate one of the later tasks.

By hovering over the task, the tool tip shows usthe duration of the taskand any of the child intervals we are hovering over.This task was blocked for the majority of the time.

To understand why it was blocked,let's switch the track displayto the "HTTP Transactions by Connection" view.

In the track sidebar on the left,under the domain name, there's a downwards arrowwe can click to switch the track display.

Currently, we are drawing "Tasks."Let's switch to displaying "HTTP Transactions by Connection."This view will only display the transactions,and instead of grouping them by task, we can nowfind out which connection they got scheduled on.

The transactions are grouped by the connection they used.Overall, there were six connectionsavailable to handle these transactions.Let's analyze the transactionsissued on Connection 1 and investigatesome of the thumbnail loading transactions further.From the top down, it's noticeablethat each transaction is taking longer to complete.The purple blocked state for eachsuccessive transaction is increasing.In fact, there's a pretty clear staircase pattern here.

Each transaction is blocked, until the previous transactionon the same connection has finished.Only then can it send its request.This pattern repeats for each subsequent transaction.

This is called "Head of Line Blocking"and is one of the problems of using HTTP/1.

The frustrating part is that these transactionsaren't doing anything for the majority of the time.Instead, they spend most of their time blocked or waitingfor the response from the server.We could be sending another requestfor the next transaction in line while waiting for the responseof a previous transaction on the same connection,but that's not supported by HTTP/1.Head-of-line blocking is one of the main limitationsof HTTP/1, and one of the main improvementsof HTTP/2 is to avoid that effect by multiplexingseveral requests to the same server onto a single connection.

In HTTP/2, we can actually start sendinga second request while the first one is waiting for its response.Your app does not need to do anything to support it.All Apple platforms support HTTP/2,and starting in iOS 15and macOS Monterey, HTTP/3 is supported as well.The client will pick the most modern HTTP versionthe server supports.If you wanna learn more about the differences between HTTP/1and HTTP/2,and the additional benefits HTTP/3 provides,please watch the "Accelerate networkingwith HTTP/3 and QUIC" session.I've taken this trace, showed it to our server folks,and managed to convince them that we shouldreally support HTTP/2.Now, let's run my app with the newserver enhancements.

Wow, this already feels faster!Let's confirm this with Instruments.So here's a trace I recordedafter we turned on server support for HTTP/2.In the domain-specific track, none of our thumbnail-loadingtasks seem to be blocked anymore for an extended amount of time.That's good!Let's switch to the "HTTP Transactionsby Connection" view again.

The first thing we notice is that there isonly one connection.This is because we no longer need multiple connectionsto send concurrent requests, which also means we only needto pay the connection setup cost once.Focusing on the individual thumbnail-loading transactions,we notice that they basically spendno time in the "blocked" state.In fact, the amount of time is so smallthat it's not visible at this zoom level.Eventually all transactions finish sendingtheir requests and are left waiting for a response.As I scroll down, we can notice that responsesare making progress at the same time.

All in all,we are done with all requests in under 3 seconds.This is twice as fast as before.Now that I've talked to the server folksand switched from HTTP/1.1 to HTTP/2,our images are loading much faster.Let me relaunch the app and show you what else we can do.When I tap on an image, the app loads the full-resolutionpicture and shows how far away this photo was taken from me.There's also a heart icon at the top rightthat allows you to favorite that specific picture.To do so, I need an account.I allow people to use the app and browse the pictureswithout an account, but to save favorited images,sync them between devices,and to upload new pictures, you need an account.So let me log in here.

Great. Let me favorite another picture.Oh, this dog looks cute! Let me add it to my favorites.Wait, why do I have to log in again if I just did?This isn't right.My app should remember my log-in.This worked before.I'm gonna dismiss the log-in screen,as I don't want to log in again.

I previously recorded a trace fileafter reproducing the issue.Let me open it with instruments to analyze the recording.On the left, there's the task that correspondsto when I pressed the favorite button for the first time.

To the right of it, there's the task that wasissued after I returned to the latest tab,and the stream of images were refreshed.

Then, there's the task to load the full-resolution imageafter I tapped on another dog picture.

And to the far right, there's the task correspondingto the second time I tapped the favorite button.

The first task interval actually contains two transactions.

The first transaction received a 401-status code.This was expected since we were not logged in.The transaction is drawn in orange to indicatethat this is not a success on the HTTP level.

Then, there's a large, empty area in the task,which represents the time I spententering the user name and password.

As soon as I'm done entering these credentials,we retry the transaction.The green color of the interval and the 201-status codeindicates it succeeded this time.This interaction of an authentication challenge,entering a password, and retrying the transactionis another case the URL Loading system handles for us,so these two transactions belong to the same task object.

Zooming out, we find the second attemptat favoriting an image on the right.The task object is displayed in gray, as my dismissingof the log-in screen caused the task to be canceled,which is also visible in its label.The transaction interval is displayed in orange,as we got a 401 response from the server again.This task occurred after I attempted to likeanother dog picture and wasprompted with the log-in for a second time.We use a very basic log-in system, where the user sendstheir credentials the first time, but once the serververified the user credentials, it sets a cookie,identifying the user, such that no credentialsneed to be provided on following requests.So I would've expected this task to have sent the proper cookie.Let's determine whether that happened.As Kacper explained earlier, there should be a smallcookie icon here next to the HTTP method,had this transaction sent a Cookie header.But there's no such icon here, which means no cookie was sent.So that part isn't working.Now the question is, did the server notprovide us with a cookie, or is the client notsending one, even though it got one?To find out, we need to investigatethe previous transaction, and checkwhether we got a cookie from the server.Here is the previous transaction,the successful one from the first log-in request.This one does have a cookie icon in the response portionof the transaction label, so the server did send a cookie.That's interesting.So why didn't we send the cookie in the next transaction?To get more information about this transactionand investigate the cookie in detail,I will switch to the "Transactions" listin the detail view at the bottom.

The transaction is already selected here,since the time cursor is placed inside of it in the track view.

The extended detail view in the bottom rightshows all request and response headersof the currently-selected transaction.

And here is the Set-Cookie header that we expect.At first glance, this cookie seems fine.But oh, wait, do you see the expiry date?It's March 2020. That's in the past!So the server did send a cookie,but it's an expired cookie.No one likes expired cookies!This will lead the URLSession to not send the cookie,as it will only send cookies that are still valid.

This is a server-side bug.I could send the trace file over to our server folksfor them to investigate the issue and have it resolved.Now that we fixed the cookie issue, I can favoritea couple more pictures without being prompted to log in.In addition to the "Latest" tab,there's also a "Favorite" tab, where we display a listof all the dog images that the user has favorited.Let's switch to that tab.

Great, there are a few favorites here that I added yesterday,but for some reason, my recent favorites aren't showing up.Let's try again.Let's pick this dog, who seems to be enjoying a bath,and let me favorite it.Let's go back to my favorites and check if it appears.

Hm, it's still not there.Let's use Instruments again to figure out what's going on.I prepared a trace file for this already.I expect to find a task loading the list of favoritesin the track view, but it's not visible at first glance.Let me choose the track for my server domain,to display only the requests issued to that domain.We could then go to the detail view at the bottom,which contains a list of all tasks for this domain.

There's quite a few requests here.Let me use the detail filter at the bottom leftto search for all requests related to "Favorites,"so I can verify whether we even made a request.

Upon filtering, the results show we sentseveral requests to load the list of favorites here.Let's focus on the track view.

The cursor got positioned at the start of the task I selecteddown in the detail view, so that makes it fairly easyto find it in the track view above.Let's zoom in to double-check.

So this was the first time we loadedthe list of favorites on the initial app launch.This is fine.

Here, I favorited a new image, and after that,we loaded the favorites again.

Well, there's a task interval here, but it's very short.

Yeah, this GET request only took a couple of milliseconds.That's too fast to get a server response.Let's switch to the "HTTP transactionsby connection" view again to get more details.

The first thing we notice is that this transactionis not executed on a Connection, but on "Local Cache."This shows us that the request was never sent on the network,but rather loaded from the local cache.This also explains why there is no "Waiting for Response" state,since the transaction did not wait for a server.

So that's the problem: our request is cached,so we don't actually ask the server,and always get the cached response back.One way to fix this would be to tell the server to seta cache-control header, to never cache this response.What we want is to reload the images every time the usergoes to the favorites tab and new images have been added.What we don't want is to load the whole listof images if there was no such change.A good trade-off would be if we could ask the server,"Hey, did anything change?If so, please let me know."That's actually something we can doby setting a cache-policy on the request.

To update the code, let me go back to the task viewand select the task in question.

For each URLSession Task that got executed here...

We display the backtrace on the right,where "resume" was called on the task.

It was resumed in the method sync,in the ImageCollection type.Let me open this in Xcode to make the change here.

Here, I have my URLRequest,and now I wanna set my cache policy.

The cache policy I want is reloadRevalidatingCacheData,which means that we ignore the local cacheand will make a request to the server to checkwhether our cache is still valid.If so, the server will send a 304 response codeto let us know to use the local cache.If not, it will send the new data back.Let's give it a try.

So these are my current favorited images,and the dog taking a bath has been added.Let's add another one.

Now, let's check the "Favorite" tab.The image I just favorited now properly appears.OK, great! That's fixed now as well.Back to my colleague Kacper to cover checkingthat your app and dependencies behave like you'd expect.Just like Sergio showed before,when I click on the "Favorite" tabwithout being logged in, the log-in view is presented.We already added Sign In with Appleto make the log-in experience seamless.However, our company has several pet-themed apps,and another team is working on a shared log-in SDK to allowusers to reuse their account between the applications.This SDK is currently in development,and the other team has asked us whether it couldreplace our classic log-in screen.I got the SDK binary, called Pets,which is distributed as an xcframeworkso that it can be used on all platforms.Integrating it into my Xcode project is as easy as draggingand dropping it in the embedded frameworks section.Now, all that is left is to add a button to our existing view.I will navigate to the source code of our Log-inView.

I will first import the framework,and then add the button to our SwiftUI VStack,just below the Sign In with Apple.

Let's refresh our Swift UI Preview.

Here it is."Sign In with Pets" buttonappeared on the preview, exactly where I want it.That was, indeed, a really easy integration.I am curious to check how quick this new log-in method will be.And to measure this, I'll profile my applicationwith Instruments by using Product Profile Action.

I am choosing Network template.And clicking "record" buttonin the toolbar to launch the app.

My app has now launched.I can now switch to the Log-in View.Instruments is showing all of the networking trafficoccurring in the meantime.I will expand it to inspect my app's URL session.

Here it is.But wait.I would expect only my main app URLSession to be here,but seems that the Pets framework we just integratedis making requests from its own session,without me even clicking on the log-in button.That's unexpected.Let's stop the recording right now to investigate it further.

I will zoom in to a few first requests,using option-click and drag.

There's many requests to some analytics endpoint,and to get more details, I can click on this"Pets Sign On Network" sessionand list all of them in the detail view.

All of them are POST requests, and when I click on one,I can see the backtrace on the right that tells uswhich part of the code the request originated from.

So seems that request is going through CFNetwork,invoked by Pets, just as expected.But when we navigate deeper,it seems like CoreLocation is being involved.That's really suspicious, especially becauseI didn't perform any action to trigger it.I wonder if my location is being sent backto the server and that's why CoreLocationand CFNetwork are in the same backtrace.

I will verify that by inspectingthe corresponding HTTP transactions for these tasks.To do this, I will switch detailfrom the list of tasks to the list of transactions.And select one of them.

In the extended detail on the bottom right,it's visible that this request contains somepretty standard headers, nothing to worry about.But wait, look at the request body.It's including my location coordinates,and that's really bad.Sending this information violates users' privacy.We don't want to gather their locationwithout their consent and without a good reason.So far, our app only requests this permission for legitimatepurposes that make the user experience better.At this point, I will not go any furtherwith this SDK integration.Instead, I will file a bug reporton the other team to inform themabout this unacceptable behavior that I detected.And I can even use this Instruments traceto generate necessary information for the bug report.Let's save it on my desktop first.

I will name it "PrivacyViolation"and hit "save."xctrace, command line tool bundled with Instruments,can be used to export this traceto the HTTP Archive format, which is an industry standardfor exchange of information about HTTP Traffic.To do this, I can simply run xctrace export command,with input of my trace, and HAR export flag.Let's run it now.

This command generates a file that I can now attachin the bug report.Someone receiving it can inspect the recorded informationin any tool that supports HAR, even if they don't haveInstruments installed on their machine.

HAR itself is a JSON-based format,so it can also be openedin the text editor or easily processed using scripts.And even though it doesn't containinstruments-specific details,like URLSessions or backtraces, that still should be enoughfor the other team to investigate this issue.

And that's how you can use HTTP Traffic Instrumentto diagnose source and content of traffic coming fromyour application to make sure that you are in controlof what your app does at runtime.Now that you're familiar with using the newHTTP Traffic Instrument, go ahead and target your appsto detect problems just like the ones we showed you today.For easier debugging and having more context while doing so,name your URLSession and task objects.

Always aim for adopting latest networking protocols.And even if you don't find any performance or correctnessissues with your app, go ahead and verifyby how much data you're sendingto get rid of any unnecessary traffic.Thank you for watching today, and we hope you havea great time tracing your app's HTTP traffic.[upbeat music]

## Code Samples


# Wwdc2021 10053

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Qualities of a great Mac Catalyst appDiscover best practices, tools, and techniques to help craft the best possible Mac Catalyst app. We'll take you through key considerations when you bring your iPad app to macOS, explore detailed code examples for refining your interface and experience, and show you how to distribute your Mac app to everyone.

To get the most out of this session, we recommend a basic familiarity with Mac Catalyst. Watch “What's new in Mac Catalyst” from WWDC21 to get an overview of the latest features for bringing your iPad app to Mac. And for more on improving your macOS experience, watch “Optimize the interface of your Mac Catalyst app” from WWDC20.ResourcesAccessibility design for Mac CatalystAdding Menus and Shortcuts to the Menu Bar and User InterfaceBring an iPad App to the Mac with Mac CatalystBuilding and improving your app with Mac CatalystHuman Interface Guidelines: Mac CatalystMac CatalystHD VideoSD VideoRelated VideosWWDC21Focus on iPad keyboard navigationMeet the UIKit button systemQualities of great iPad and iPhone apps on Macs with M1Take your iPad apps to the next levelWhat's new in Mac CatalystWhat's new in UIKitWWDC20Optimize the interface of your Mac Catalyst app

Discover best practices, tools, and techniques to help craft the best possible Mac Catalyst app. We'll take you through key considerations when you bring your iPad app to macOS, explore detailed code examples for refining your interface and experience, and show you how to distribute your Mac app to everyone.

To get the most out of this session, we recommend a basic familiarity with Mac Catalyst. Watch “What's new in Mac Catalyst” from WWDC21 to get an overview of the latest features for bringing your iPad app to Mac. And for more on improving your macOS experience, watch “Optimize the interface of your Mac Catalyst app” from WWDC20.

Accessibility design for Mac Catalyst

Adding Menus and Shortcuts to the Menu Bar and User Interface

Bring an iPad App to the Mac with Mac Catalyst

Building and improving your app with Mac Catalyst

Human Interface Guidelines: Mac Catalyst

Mac Catalyst

HD VideoSD Video

HD Video

SD Video

Focus on iPad keyboard navigation

Meet the UIKit button system

Qualities of great iPad and iPhone apps on Macs with M1

Take your iPad apps to the next level

What's new in Mac Catalyst

What's new in UIKit

Optimize the interface of your Mac Catalyst app

Search this video…♪ Bass music playing ♪♪Owen Monsma: Hello, and welcome to"Qualities of a great Mac Catalyst app."My name is Owen Monsma, and I'm a Cocoa engineer.And I'll be joined later by my colleagueDave Rahardja from UIKit.Today we're going to go over three important considerationsfor making an amazing Catalyst app.First, we'll cover some high-level changesthat happen when you migrate to a Mac Catalyst app.Next, we'll dive into some specific code modificationsyou can make to improve your app experience on Mac.And we'll end with information about app distribution.So let's begin with migrating your app to Mac Catalyst.The first step toward a great Catalyst appis having a great iPad app, and your app already runswith no additional changes on Macs with M1.If you have an M1 Mac, you can try this right awaywith the Designed for iPad run destination in Xcode.By adopting these features on iPad,your Mac app will have a great head start.If your app supports multitasking on iPad,you can automatically get multiple window support on Mac.And if you use UIMenuBuilder,your menus are automatically picked upin your app's menu bar, and by contextual menuswith a secondary click on your views.We also automatically bridge system behaviorslike copy/paste and drag and drop.To learn more about how your iPad app runs as-is on M1 Macs,check out our video,"Qualities of great iPad and iPhone apps on Macs with M1."But you're here because you want to take things further.By checking the Mac checkbox,you gain the ability to distribute to all Macs,and get access to additional APIs to further refine your app.So let's do it with our app, Trip Planner!In our Xcode project settings,we check the Mac option under Deployment Info.Notice to the right, an additional pop-up appears,letting us choose between a scaled iPad interfaceand a Mac optimized interface.We will examine this choice more in a little bit.For now, let's click build and run in the Xcode toolbar.And our app builds and runs!Now, if your app failed to build,there are a few things to investigate.Certain deprecated frameworks and classesare unavailable for Mac Catalyst,so now is the time to modernize.Not only will this get your app running on Mac,but it will improve your iOS app, too.Moving from OpenGLES to Apple's own Metal frameworkunlocks the full power of the GPU.The Contacts framework replaced the deprecated AddressBookand is a forward-looking, thread-safe wayto handle contacts.And UIWebView is deprecatedand has been superseded by WKWebView.Also, make sure to check your third-party dependencies.If those frameworks are distributedas an XCFramework bundle,make sure that they provide a Mac binary to link against.As you begin work on your Mac app,watch for compiler warnings when building your project,and monitor the console log for runtime messages.These warnings tell you how to fix your codeso it runs well as a Mac Catalyst process.And remember to only use supported APIso your app continues to run on future macOS releases.It's also important to be aware of the lifecycle eventsthat your app will receive when running on a Mac.If your app currently relies on lifecycle eventscalled on your app delegate,you should instead monitor scene lifecyclesso your app can respond to eventsspecific to the content of each window on the desktop.Remember, a Mac Catalyst app will not receive thesceneDidEnterBackground event as often as an iPad app.Scenes enter the background statewhen a desktop window is minimized or closed.If your app uses sceneDidEnterBackgroundto perform some routine work like autosaving a document,using a timer insteadwill ensure this action is taken regularly.Finally, remember that your Catalyst appmay have zero scenesbut continue to run in the foreground.This state happens when all your app's windows have been closed,but your app's name remains visible in the menu bar.Now let's decide whether to optimize our interface for Mac.This is one of the most important decisions to makewhen you first begin bringing your app over.Using Mac idiom is recommended to make your appfeel the most at home on Mac,but it does require some additional work.In the Mac idiom, your app will run at 100 percent scale,giving you pixel-perfect text and images,and native AppKit controls.If you want, you can add new Mac-specific assetsin your asset catalogto take advantage of this additional detail.It's good practice to provide both 1x and 2x assetsto support all monitor resolutions.Be aware, the size metrics of many of your controlswill change, so it is important to adjust your app's layoutto accommodate.For custom controls in your app, you have an additional choice.Automatically, you get the Mac style of control.But now you can opt out your buttons and slidersfrom this conversion to use customization APIsthat are unavailable on Mac controls.If you use any custom assets --like setting the thumb on a UISlider --they will appear larger than expected by default,so you may need to scale them or provide new assets.Also keep in mind that Mac users expect AppKit-style controls,so custom controls should be used sparingly.For more detail on the Mac idiom,check out our video,"Optimize the interface of your Mac Catalyst app."Because a Catalyst app in the Mac idiomtakes on AppKit control styles, both the appearanceand behavior of some of your controls will change.In our video, "What's new in Mac Catalyst,"we introduced the new pop-up button stylewhich rounds out our suite of Mac button types.Let's dive into what makes these controls differentand how the system picks which one to use.Understanding these controlsand where they are commonly foundwill help you make informed choicesabout their use in your app.The default UIButton type is UIButton type .system.With this button type, the button automaticallytakes on the expected appearance for its context.In the Mac idiom,this means it becomes a bordered push button.Pull-down buttons are a Mac-native controlused to provide a list of possible actions,and are drawn with a single-arrow indicator.A good example is the PDF pull-down in the print dialog,which presents actions such as Save as PDF or Send in Mail.To get a pull-down button,make sure that you have assigned a UI menu to your buttonvia its menu property, and additionally setshowsMenuAsPrimaryAction to true.Your button will take on the pull-down lookand present the menu on a click.And new to Catalyst with macOS Montereyare pop-up buttons.Pop-up buttons look similar to pull-down buttonsbut have a double-arrow indicator,and they do something slightly different.Where the pull-down triggers an action,a pop-up button is used to selectone of a set of mutually exclusive options.For example, selecting the day of the week.The title in the button then updatesto reflect the selection.This is a good, Mac-friendly choiceto replace a UIPickerView in your app.Getting this control is similar to a pull-down button,but the property changesSelectionAsPrimaryActionmust also be true.Finally, checkboxes are used to representa non-exclusive binary toggle,and are a more mouse-friendly alternative to a switch.And as it turns out,you get the checkbox with no additional work!Just make sure that the switch has a title set,and keep in mind the title propertyis only supported in the Mac idiom.By default, the switchhas a preferredStyle of automatic,and you can verify at runtimewhether it is a switch or a checkboxusing the read-only style property.Now, to dive into some specific code changes,let's hand things off to my colleague, Dave.Dave Rahardja: Hi everyone, my name is Dave,and I'm an engineer on the UIKit team.Let's talk about some specific things you can doto make your Mac Catalyst app feel more at home.A Mac Catalyst app may have accessto a lot more screen real estate.Your app's windows can be resized much larger on a Macthan on an iPad, and can be shown full screen.Take a moment to resize your app's windowsand pay attention to its layout.Make sure you're using the additional spaceto show more content and controlsto make your apps easier to use.Live resizing will put your app's layout performanceto the test.Your app should do the least amount of work possibleduring layout to keep your app's windows responsiveduring resizing.Take special note of interactions in your appthat rely on modal presentations and popovers.With a larger display area,you can make these interactions always availableby showing them as child views.Now, let's talk about pointer input devices.Remember that not all Macs have a trackpad,and some Macs are connected to input devicesthat don't support scrolling.If your views rely on a pinch or rotate gesture to work,make sure that all of its capabilities are accessibleusing a mouse without scroll input.Add additional buttons or other controlsto your Mac Catalyst app's viewto make sure all of its functionality is accessible.Additionally, detecting keyboard modifierson tap or pan gesture recognizerscan sometimes provide faster accessto your view's functionality.For example, allowing Shift-pan to zoom.Let's talk about keyboard shortcuts and the main menu.The main menu of a Mac app is a great placeto discover all the actions available in your app,as well as their associated keyboard shortcuts.If your app already supports keyboard shortcutsby returning key commands from its responders,add these commands to the main menuusing the menu builder API instead.Moving all your keyboard shortcuts to the main menumakes them discoverableeven when they are not currently enabled.What's more, using the MenuBuilder APIto organize your shortcuts on Mac Catalystalso organizes them on the iPad shortcuts overlay.As you build out your main menu,be sure to add all the actions neededto interact with your app.Actions performed with gestures on an iPadshould also be accessibleby selecting items from the main menu.Adding keyboard shortcuts to your menu itemswill provide even quicker access to these actions.Because menu bar and key command actionsare routed starting from the first responder,make sure that the viewsthat would be the target of those actionscan become first responder and can accept focus.You can do this by having your views return truefor the canBecomeFirstResponder and canBecomeFocused properties.Since a Mac app must rely less on direct manipulation of views,and more on the user selecting a viewand then selecting an action from the main menu,the ability for more of your app's viewsto become first responder and focusedbecomes more important on Mac Catalyst.For more information about focus and first responders,check out the video, "Focus on iPad keyboard navigation."While we're on the subject of responders,be sure to leave the responder chain unmodified in your app.In other words, don't override nextResponder.Leaving the responder chain unmodifiedensures that Mac Catalyst can route your actionsto the appropriate targets.If your app has to handle certain actionsusing objects that are not in its responder chain,use the target(for Action:, withSender:) functionto delegate these actionsto the appropriate object instead.Let's go over the code.In this example, our view delegatesthe setAsFavorite action to a model object,while allowing other actionsto continue to propagate up the responder chain.Now let's talk about scenesand how they work in a Mac Catalyst app.A Mac app may have many desktop windowsopen at the same time.In a Mac Catalyst app, each of these windowsis paired with a UIWindowScene.Your app may offer windows that have different functions.For example, it may have a document window,a detail viewer window, a message composer window,and so on.The best way to organize these different scene functionsis by defining a scene configurationfor each type of window.To define scene configurations,add them to your Info.plistunder the Application Scene Manifest entry.Under the Application Session Role array,create one configuration for each type of sceneyour app supports.Give each of these configurations a nameand choose the scene class, delegate class,and storyboard that will be instantiatedwhen the scene is created.Now that we've defined our scene configurations,let's discuss how we can use themto create a new scene of a particular configuration.In this example, we want to create a new detail viewer scenewhen a view is double-clicked.The first thing we do is define a new user activity typefor requesting a detail viewer scene.We'll call it viewDetailActivityType.When we create that new user activity,we want to pass along an identifierfor the item that we want to show in detail.To do that, we define an itemIDKeythat will hold that information in the user info dictionary.Then, in our double-click event handler,we create a new NSUserActivity object of the appropriate type,and set its userInfo property to a dictionaryholding the itemID that we want to show.Finally, we call the UIApplicationrequestSceneSessionActivation function,passing in the user activity we just created.This will cause the system to create our new scene.So now we know how to request a new scenefor a particular user activity type.Now let's talk about how to use that informationto load the appropriate scene configuration.We respond to scene creation requests by implementingthe application configurationForConnectingfunction in the application delegate.In our implementation, we examineif the incoming scene request contains any user activities.The request can contain multiple user activities,but for this code example,we'll just examine the first one.If there is an activity we need to handle,we then check its activityType.Here, we test if it's equal to the viewDetailActivityType.If so, we return the scene configuration namedDetailViewer.This will cause the system to check in our Info.plistfor a configuration of that name,and load the appropriate scene and scene delegate classes,and display the specified storyboardin a new desktop window.If no specific scene configuration should be loaded,we fall back to returning the default configuration.There is one more thing to do.Remember that we saved the itemIDfor the item to be shown?We still need to set that value on the view controllerof the scene that we just created.We do that in our SceneDelegate class.The scene willConnectTo session function is calledjust before the scene is about to be shown on the desktop.The user activity that was passedinto our application delegate is also passed into this functionin the scene delegate.We can now extract the itemID from its userInfo dictionaryand set it on our new view controller.Using NSUserActivity to configure new scenes alsomakes it easier for your app to support state restoration.If your scene delegate responds tothe stateRestorationActivity (for Scene:) callback,the returned user activity will be saved by the systemwhen your app exits.If state restoration is enabled in System Preferences,the next time your app is launched,the system will recreate your scenesand pass each scene's user activity objectto your app delegate's applicationconfigurationForConnecting SceneSession function.This is the same function that is called when your appcreates new scenes, as covered earlier.By using a consistent set of activity types,you can use the same code to selectthe appropriate scene configuration when your appcreates new desktop windows and during state restoration.There is one thing you need to add to your scene delegateso your app can handle both new scene requestsand state restoration with the same code,and that is to modify your scene willConnect session functionin your scene delegate so that it falls backto the stateRestorationActivityif the activity in the scene connection options is nil.Now your app is ready to handle new scene requestsand state restoration.For more information on state restoration,check out the "Introducing Multiple Windows on iPad" video.Next, let's talk about your app's toolbar.A great Mac app uses its windows' toolbarsto present frequently used actionsand other navigation options for quick access.Unlike toolbars on iOS,the toolbar on a Mac Catalyst app's desktop windowdoes not change as view controllers appear and disappearin the Split View controller or a navigation controller.Because toolbars are strongly associated with scenes,the best place to configure your toolbaris in your scene delegate subclass.One important item usually found on the toolbaris the sharing button.Adding an NSSharingServicePicker ToolbarItem to your toolbarallows your app to share the main content shown in your sceneusing the Mac's standard sharing menu.In macOS Monterey, we have added the ability for the buttonto automatically use the activity items configurationshared by your scene.Notice that this is the same configurationthat the new Share This function of Siri uses on iOS.A good way to provide a sharing configurationfor your scene is to return an objectfrom your RootViewController'sactivityItemsConfiguration property.On Mac Catalyst,an NSSharingServicePicker ToolbarItemin your app's toolbarautomatically uses this property.On iOS, Siri uses the same property to share datausing Share This.Of course, the toolbar is not the only placeyour app can offer items to share.Often, you'd want to allow sharing of imagesor other items through a context menu.To do this, return an activityItemsConfigurationobject from your viewthen add a contextMenuInteraction.Here are the results, on both Mac Catalyst and iPad.On Mac Catalyst, note that a Copy action and a Share menuare automatically added.And when your app runs on iPad,a Copy and Share action are added.Tapping the Share actionautomatically presents the share sheet.Using the Activity Items Configuration APIallows your app to declare what its views can shareso the system can display the appropriate UI on each platform.Now that we've talked about how your app can share its data,let's talk about how your app can import imagesfrom an iPhone or iPad using Continuity Camera.If your app uses a UITextView to display rich text,Continuity Camera support is automatically enabledin macOS Monterey.A right-click on a text view will show a context menuwith an option to take a photo on your iPhone or iPadand automatically add it as an attachment.To add support for Continuity Camera to any view,simply return a UIPasteConfiguration objectthat accepts images from your view'spasteConfiguration property,then add a UI contextMenuInteraction.Then implement the paste(itemProviders:) functionto load and paste the incoming objects --in this case, images.As a bonus, returning a paste configurationfrom your view not only enables Continuity Camerawhen the configuration accepts images,it also automatically enables a Paste actionin the context menuand allows your view to accept incoming drags,both on Mac Catalyst and iPad.So those are some specific things you can doto help make your app a great Mac Catalyst app.Now let's go back to Owen to talk about distribution.Owen: Thanks, Dave.When it comes to releasing your app,the big thing to remember is that Mac Catalyst appsare Mac apps, and can be distributedthrough all the same means as any other Mac app.You can publish your app on the Mac App Store,with the option for Universal Purchaseso your existing iOS customers automatically get your Mac app.You have access to TestFlight for beta releases of your appand to get early feedback on new builds.You can also use App Notarizationand distribute it yourself.And if you develop a framework,use XCFrameworks to distribute cross-platform,bundling together binaries for all platforms.Today, we've covered the process of building your iOS app for Macwith Mac Catalyst,and highlighted some important decisionsand changes to make along the way.Now it's time to consider your own projects.It's easy to get your app running on Mac,and with just a little bit of work,you can make your app feel right at homeand make it available to a whole new set of excited customers.Thank you!♪

♪ Bass music playing ♪♪Owen Monsma: Hello, and welcome to"Qualities of a great Mac Catalyst app."My name is Owen Monsma, and I'm a Cocoa engineer.

And I'll be joined later by my colleagueDave Rahardja from UIKit.

Today we're going to go over three important considerationsfor making an amazing Catalyst app.

First, we'll cover some high-level changesthat happen when you migrate to a Mac Catalyst app.

Next, we'll dive into some specific code modificationsyou can make to improve your app experience on Mac.

And we'll end with information about app distribution.

So let's begin with migrating your app to Mac Catalyst.

The first step toward a great Catalyst appis having a great iPad app, and your app already runswith no additional changes on Macs with M1.

If you have an M1 Mac, you can try this right awaywith the Designed for iPad run destination in Xcode.

By adopting these features on iPad,your Mac app will have a great head start.

If your app supports multitasking on iPad,you can automatically get multiple window support on Mac.

And if you use UIMenuBuilder,your menus are automatically picked upin your app's menu bar, and by contextual menuswith a secondary click on your views.

We also automatically bridge system behaviorslike copy/paste and drag and drop.

To learn more about how your iPad app runs as-is on M1 Macs,check out our video,"Qualities of great iPad and iPhone apps on Macs with M1."But you're here because you want to take things further.

By checking the Mac checkbox,you gain the ability to distribute to all Macs,and get access to additional APIs to further refine your app.

So let's do it with our app, Trip Planner!In our Xcode project settings,we check the Mac option under Deployment Info.

Notice to the right, an additional pop-up appears,letting us choose between a scaled iPad interfaceand a Mac optimized interface.

We will examine this choice more in a little bit.

For now, let's click build and run in the Xcode toolbar.

And our app builds and runs!Now, if your app failed to build,there are a few things to investigate.

Certain deprecated frameworks and classesare unavailable for Mac Catalyst,so now is the time to modernize.

Not only will this get your app running on Mac,but it will improve your iOS app, too.

Moving from OpenGLES to Apple's own Metal frameworkunlocks the full power of the GPU.

The Contacts framework replaced the deprecated AddressBookand is a forward-looking, thread-safe wayto handle contacts.

And UIWebView is deprecatedand has been superseded by WKWebView.

Also, make sure to check your third-party dependencies.

If those frameworks are distributedas an XCFramework bundle,make sure that they provide a Mac binary to link against.

As you begin work on your Mac app,watch for compiler warnings when building your project,and monitor the console log for runtime messages.

These warnings tell you how to fix your codeso it runs well as a Mac Catalyst process.

And remember to only use supported APIso your app continues to run on future macOS releases.

It's also important to be aware of the lifecycle eventsthat your app will receive when running on a Mac.

If your app currently relies on lifecycle eventscalled on your app delegate,you should instead monitor scene lifecyclesso your app can respond to eventsspecific to the content of each window on the desktop.

Remember, a Mac Catalyst app will not receive thesceneDidEnterBackground event as often as an iPad app.

Scenes enter the background statewhen a desktop window is minimized or closed.

If your app uses sceneDidEnterBackgroundto perform some routine work like autosaving a document,using a timer insteadwill ensure this action is taken regularly.

Finally, remember that your Catalyst appmay have zero scenesbut continue to run in the foreground.

This state happens when all your app's windows have been closed,but your app's name remains visible in the menu bar.

Now let's decide whether to optimize our interface for Mac.

This is one of the most important decisions to makewhen you first begin bringing your app over.

Using Mac idiom is recommended to make your appfeel the most at home on Mac,but it does require some additional work.

In the Mac idiom, your app will run at 100 percent scale,giving you pixel-perfect text and images,and native AppKit controls.

If you want, you can add new Mac-specific assetsin your asset catalogto take advantage of this additional detail.

It's good practice to provide both 1x and 2x assetsto support all monitor resolutions.

Be aware, the size metrics of many of your controlswill change, so it is important to adjust your app's layoutto accommodate.

For custom controls in your app, you have an additional choice.

Automatically, you get the Mac style of control.

But now you can opt out your buttons and slidersfrom this conversion to use customization APIsthat are unavailable on Mac controls.

If you use any custom assets --like setting the thumb on a UISlider --they will appear larger than expected by default,so you may need to scale them or provide new assets.

Also keep in mind that Mac users expect AppKit-style controls,so custom controls should be used sparingly.

For more detail on the Mac idiom,check out our video,"Optimize the interface of your Mac Catalyst app."Because a Catalyst app in the Mac idiomtakes on AppKit control styles, both the appearanceand behavior of some of your controls will change.

In our video, "What's new in Mac Catalyst,"we introduced the new pop-up button stylewhich rounds out our suite of Mac button types.

Let's dive into what makes these controls differentand how the system picks which one to use.

Understanding these controlsand where they are commonly foundwill help you make informed choicesabout their use in your app.

The default UIButton type is UIButton type .system.

With this button type, the button automaticallytakes on the expected appearance for its context.

In the Mac idiom,this means it becomes a bordered push button.

Pull-down buttons are a Mac-native controlused to provide a list of possible actions,and are drawn with a single-arrow indicator.

A good example is the PDF pull-down in the print dialog,which presents actions such as Save as PDF or Send in Mail.

To get a pull-down button,make sure that you have assigned a UI menu to your buttonvia its menu property, and additionally setshowsMenuAsPrimaryAction to true.

Your button will take on the pull-down lookand present the menu on a click.

And new to Catalyst with macOS Montereyare pop-up buttons.

Pop-up buttons look similar to pull-down buttonsbut have a double-arrow indicator,and they do something slightly different.

Where the pull-down triggers an action,a pop-up button is used to selectone of a set of mutually exclusive options.

For example, selecting the day of the week.

The title in the button then updatesto reflect the selection.

This is a good, Mac-friendly choiceto replace a UIPickerView in your app.

Getting this control is similar to a pull-down button,but the property changesSelectionAsPrimaryActionmust also be true.

Finally, checkboxes are used to representa non-exclusive binary toggle,and are a more mouse-friendly alternative to a switch.

And as it turns out,you get the checkbox with no additional work!Just make sure that the switch has a title set,and keep in mind the title propertyis only supported in the Mac idiom.

By default, the switchhas a preferredStyle of automatic,and you can verify at runtimewhether it is a switch or a checkboxusing the read-only style property.

Now, to dive into some specific code changes,let's hand things off to my colleague, Dave.

Dave Rahardja: Hi everyone, my name is Dave,and I'm an engineer on the UIKit team.

Let's talk about some specific things you can doto make your Mac Catalyst app feel more at home.

A Mac Catalyst app may have accessto a lot more screen real estate.

Your app's windows can be resized much larger on a Macthan on an iPad, and can be shown full screen.

Take a moment to resize your app's windowsand pay attention to its layout.

Make sure you're using the additional spaceto show more content and controlsto make your apps easier to use.

Live resizing will put your app's layout performanceto the test.

Your app should do the least amount of work possibleduring layout to keep your app's windows responsiveduring resizing.

Take special note of interactions in your appthat rely on modal presentations and popovers.

With a larger display area,you can make these interactions always availableby showing them as child views.

Now, let's talk about pointer input devices.

Remember that not all Macs have a trackpad,and some Macs are connected to input devicesthat don't support scrolling.

If your views rely on a pinch or rotate gesture to work,make sure that all of its capabilities are accessibleusing a mouse without scroll input.

Add additional buttons or other controlsto your Mac Catalyst app's viewto make sure all of its functionality is accessible.

Additionally, detecting keyboard modifierson tap or pan gesture recognizerscan sometimes provide faster accessto your view's functionality.

For example, allowing Shift-pan to zoom.

Let's talk about keyboard shortcuts and the main menu.

The main menu of a Mac app is a great placeto discover all the actions available in your app,as well as their associated keyboard shortcuts.

If your app already supports keyboard shortcutsby returning key commands from its responders,add these commands to the main menuusing the menu builder API instead.

Moving all your keyboard shortcuts to the main menumakes them discoverableeven when they are not currently enabled.

What's more, using the MenuBuilder APIto organize your shortcuts on Mac Catalystalso organizes them on the iPad shortcuts overlay.

As you build out your main menu,be sure to add all the actions neededto interact with your app.

Actions performed with gestures on an iPadshould also be accessibleby selecting items from the main menu.

Adding keyboard shortcuts to your menu itemswill provide even quicker access to these actions.

Because menu bar and key command actionsare routed starting from the first responder,make sure that the viewsthat would be the target of those actionscan become first responder and can accept focus.

You can do this by having your views return truefor the canBecomeFirstResponder and canBecomeFocused properties.

Since a Mac app must rely less on direct manipulation of views,and more on the user selecting a viewand then selecting an action from the main menu,the ability for more of your app's viewsto become first responder and focusedbecomes more important on Mac Catalyst.

For more information about focus and first responders,check out the video, "Focus on iPad keyboard navigation."While we're on the subject of responders,be sure to leave the responder chain unmodified in your app.

In other words, don't override nextResponder.

Leaving the responder chain unmodifiedensures that Mac Catalyst can route your actionsto the appropriate targets.

If your app has to handle certain actionsusing objects that are not in its responder chain,use the target(for Action:, withSender:) functionto delegate these actionsto the appropriate object instead.

Let's go over the code.

In this example, our view delegatesthe setAsFavorite action to a model object,while allowing other actionsto continue to propagate up the responder chain.

Now let's talk about scenesand how they work in a Mac Catalyst app.

A Mac app may have many desktop windowsopen at the same time.

In a Mac Catalyst app, each of these windowsis paired with a UIWindowScene.

Your app may offer windows that have different functions.

For example, it may have a document window,a detail viewer window, a message composer window,and so on.

The best way to organize these different scene functionsis by defining a scene configurationfor each type of window.

To define scene configurations,add them to your Info.plistunder the Application Scene Manifest entry.

Under the Application Session Role array,create one configuration for each type of sceneyour app supports.

Give each of these configurations a nameand choose the scene class, delegate class,and storyboard that will be instantiatedwhen the scene is created.

Now that we've defined our scene configurations,let's discuss how we can use themto create a new scene of a particular configuration.

In this example, we want to create a new detail viewer scenewhen a view is double-clicked.

The first thing we do is define a new user activity typefor requesting a detail viewer scene.

We'll call it viewDetailActivityType.

When we create that new user activity,we want to pass along an identifierfor the item that we want to show in detail.

To do that, we define an itemIDKeythat will hold that information in the user info dictionary.

Then, in our double-click event handler,we create a new NSUserActivity object of the appropriate type,and set its userInfo property to a dictionaryholding the itemID that we want to show.

Finally, we call the UIApplicationrequestSceneSessionActivation function,passing in the user activity we just created.

This will cause the system to create our new scene.

So now we know how to request a new scenefor a particular user activity type.

Now let's talk about how to use that informationto load the appropriate scene configuration.

We respond to scene creation requests by implementingthe application configurationForConnectingfunction in the application delegate.

In our implementation, we examineif the incoming scene request contains any user activities.

The request can contain multiple user activities,but for this code example,we'll just examine the first one.

If there is an activity we need to handle,we then check its activityType.

Here, we test if it's equal to the viewDetailActivityType.

If so, we return the scene configuration namedDetailViewer.

This will cause the system to check in our Info.plistfor a configuration of that name,and load the appropriate scene and scene delegate classes,and display the specified storyboardin a new desktop window.

If no specific scene configuration should be loaded,we fall back to returning the default configuration.

There is one more thing to do.

Remember that we saved the itemIDfor the item to be shown?We still need to set that value on the view controllerof the scene that we just created.

We do that in our SceneDelegate class.

The scene willConnectTo session function is calledjust before the scene is about to be shown on the desktop.

The user activity that was passedinto our application delegate is also passed into this functionin the scene delegate.

We can now extract the itemID from its userInfo dictionaryand set it on our new view controller.

Using NSUserActivity to configure new scenes alsomakes it easier for your app to support state restoration.

If your scene delegate responds tothe stateRestorationActivity (for Scene:) callback,the returned user activity will be saved by the systemwhen your app exits.

If state restoration is enabled in System Preferences,the next time your app is launched,the system will recreate your scenesand pass each scene's user activity objectto your app delegate's applicationconfigurationForConnecting SceneSession function.

This is the same function that is called when your appcreates new scenes, as covered earlier.

By using a consistent set of activity types,you can use the same code to selectthe appropriate scene configuration when your appcreates new desktop windows and during state restoration.

There is one thing you need to add to your scene delegateso your app can handle both new scene requestsand state restoration with the same code,and that is to modify your scene willConnect session functionin your scene delegate so that it falls backto the stateRestorationActivityif the activity in the scene connection options is nil.

Now your app is ready to handle new scene requestsand state restoration.

For more information on state restoration,check out the "Introducing Multiple Windows on iPad" video.

Next, let's talk about your app's toolbar.

A great Mac app uses its windows' toolbarsto present frequently used actionsand other navigation options for quick access.

Unlike toolbars on iOS,the toolbar on a Mac Catalyst app's desktop windowdoes not change as view controllers appear and disappearin the Split View controller or a navigation controller.

Because toolbars are strongly associated with scenes,the best place to configure your toolbaris in your scene delegate subclass.

One important item usually found on the toolbaris the sharing button.

Adding an NSSharingServicePicker ToolbarItem to your toolbarallows your app to share the main content shown in your sceneusing the Mac's standard sharing menu.

In macOS Monterey, we have added the ability for the buttonto automatically use the activity items configurationshared by your scene.

Notice that this is the same configurationthat the new Share This function of Siri uses on iOS.

A good way to provide a sharing configurationfor your scene is to return an objectfrom your RootViewController'sactivityItemsConfiguration property.

On Mac Catalyst,an NSSharingServicePicker ToolbarItemin your app's toolbarautomatically uses this property.

On iOS, Siri uses the same property to share datausing Share This.

Of course, the toolbar is not the only placeyour app can offer items to share.

Often, you'd want to allow sharing of imagesor other items through a context menu.

To do this, return an activityItemsConfigurationobject from your viewthen add a contextMenuInteraction.

Here are the results, on both Mac Catalyst and iPad.

On Mac Catalyst, note that a Copy action and a Share menuare automatically added.

And when your app runs on iPad,a Copy and Share action are added.

Tapping the Share actionautomatically presents the share sheet.

Using the Activity Items Configuration APIallows your app to declare what its views can shareso the system can display the appropriate UI on each platform.

Now that we've talked about how your app can share its data,let's talk about how your app can import imagesfrom an iPhone or iPad using Continuity Camera.

If your app uses a UITextView to display rich text,Continuity Camera support is automatically enabledin macOS Monterey.

A right-click on a text view will show a context menuwith an option to take a photo on your iPhone or iPadand automatically add it as an attachment.

To add support for Continuity Camera to any view,simply return a UIPasteConfiguration objectthat accepts images from your view'spasteConfiguration property,then add a UI contextMenuInteraction.

Then implement the paste(itemProviders:) functionto load and paste the incoming objects --in this case, images.

As a bonus, returning a paste configurationfrom your view not only enables Continuity Camerawhen the configuration accepts images,it also automatically enables a Paste actionin the context menuand allows your view to accept incoming drags,both on Mac Catalyst and iPad.

So those are some specific things you can doto help make your app a great Mac Catalyst app.

Now let's go back to Owen to talk about distribution.

Owen: Thanks, Dave.

When it comes to releasing your app,the big thing to remember is that Mac Catalyst appsare Mac apps, and can be distributedthrough all the same means as any other Mac app.

You can publish your app on the Mac App Store,with the option for Universal Purchaseso your existing iOS customers automatically get your Mac app.

You have access to TestFlight for beta releases of your appand to get early feedback on new builds.

You can also use App Notarizationand distribute it yourself.

And if you develop a framework,use XCFrameworks to distribute cross-platform,bundling together binaries for all platforms.

Today, we've covered the process of building your iOS app for Macwith Mac Catalyst,and highlighted some important decisionsand changes to make along the way.

Now it's time to consider your own projects.

It's easy to get your app running on Mac,and with just a little bit of work,you can make your app feel right at homeand make it available to a whole new set of excited customers.

Thank you!♪

6:50 -System button

7:06 -Pull-down button

7:44 -Pop-up button

8:24 -Checkbox

13:20 -Delegating actions

14:43 -Requesting a new scene

15:57 -Responding to a new scene request

17:13 -Setting item ID on new scene's root view controller

17:47 -Saving state for later restoration

17:57 -State restoration

18:42 -Handle both new scene requests and state restoration

20:20 -Provide sharing configuration for the scene

20:56 -Support sharing through context menu

22:08 -Supporting continuity camera

## Code Samples

```swift
let
 button 
=
 
UIButton
(type: .system)
button.setTitle(
"Button"
, for: .normal)
```

```swift
button.menu 
=
 
UIMenu
(
...
)
button.showsMenuAsPrimaryAction 
=
 
true
```

```swift
button.menu 
=
 
UIMenu
(
...
)
button.showsMenuAsPrimaryAction 
=
 
true

button.changesSelectionAsPrimaryAction 
=
 
true
```

```swift
let
 checkbox 
=
 
UISwitch
()

if
 checkbox.style 
==
 .checkbox {
    checkbox.title 
=
 
"Checkbox"

}
```

```swift
final
 
class
 
MyView
: 
UIView
 
{
    
override
 
func
 
target
(
forAction
 
action
: 
Selector
, 
withSender
 
sender
: 
Any
?
)
 -> 
Any
?
 {
        
if
 action 
==
 
#selector
(
Model
.setAsFavorite(
_
:)) {
            
return
 myModel
        } 
else
 {
            
return
 
super
.target(forAction: action, withSender: sender)
        }
    }
}
```

```swift
let
 viewDetailActivityType 
=
 
"viewDetail"


let
 itemIDKey 
=
 
"itemID"



final
 
class
 
MyView
: 
UIView
 
{
    
@objc
 
func
 
viewDoubleClicked
(
_
 
sender
: 
Any
?
)
 {
        
let
 userActivity 
=
 
NSUserActivity
(activityType: viewDetailActivityType)
        userActivity.userInfo 
=
 [itemIDKey: selectedItem.itemID]
        
UIApplication
.shared.requestSceneSessionActivation(
nil
,
            userActivity: userActivity,
            options: 
nil
,
            errorHandler: { error 
in
 
//...

        })
    }
    
//...

}
```

```swift
let
 viewDetailActivityType 
=
 
"viewDetail"



final
 
class
 
AppDelegate
: 
UIApplicationDelegate
 
{
    
func
 
application
(
_
 
application
: 
UIApplication
, 
        
configurationForConnecting
 
session
: 
UISceneSession
, 
        
options
: 
UIScene
.
ConnectionOptions
)
 -> 
UISceneConfiguration
 {
        
if
 
let
 activity 
=
 options.userActivities.first {
            
if
 activity.activityType 
==
 viewDetailActivityType {
                
return
 
UISceneConfiguration
(name: 
"DetailViewer"
, sessionRole:session.role)
            }
        }
        
return
 
UISceneConfiguration
(name: 
"Default Configuration"
,
            sessionRole: session.role)
    }
    
//...

}
```

```swift
let
 itemIDKey 
=
 
"itemID"



final
 
class
 
SceneDelegate
: 
UIWindowSceneDelegate
 
{
    
func
 
scene
(
_
 
scene
: 
UIScene
, 
willConnectTo
 
session
: 
UISceneSession
,
        
options
: 
UIScene
.
ConnectionOptions
)
 {
        
if
 
let
 userActivity 
=
 connectionOptions.userActivities.first {
            
if
 
let
 itemId 
=
 userActivity.userInfo
?
[itemIDKey] 
as?
 
ItemIDType
 {
               
// Set item ID on new view controller

            }
        }
        
//...

    }
    
//...
```

```swift
final
 
class
 
SceneDelegate
: 
UIWindowSceneDelegate
 
{
    
func
 
stateRestorationActivity
(
for
 
scene
: 
UIScene
)
 -> 
NSUserActivity
? {
        
//...

    }
}
```

```swift
final
 
class
 
AppDelegate
: 
UIApplicationDelegate
 
{
    
func
 
application
(
_
 
application
: 
UIApplication
, 
        
configurationForConnecting
 
session
: 
UISceneSession
, 
        
options
: 
UIScene
.
ConnectionOptions
)
 -> 
UISceneConfiguration
 {
        
//...

    }
}
```

```swift
let
 itemIDKey 
=
 
"itemID"



final
 
class
 
SceneDelegate
: 
UIWindowSceneDelegate
 
{
    
func
 
scene
(
_
 
scene
: 
UIScene
, 
willConnectTo
 
session
: 
UISceneSession
,
        
options
 
connectionOptions
: 
UIScene
.
ConnectionOptions
)
 {
        
if
 
let
 userActivity 
=
 connectionOptions.userActivities.first 
??

            session.stateRestorationActivity {
            
if
 
let
 itemId 
=
 userActivity.userInfo
?
[itemIDKey] 
as?
 
ItemIDType
 {
               
// Set item ID on new view controller

            }
        }
    }
}
```

```swift
final
 
class
 
RootViewController
: 
UIViewController
 
{
    
override
 
var
 activityItemsConfiguration: 
UIActivityItemsConfigurationReading
? {
      
get
 { 
UIActivityItemsConfiguration
(objects: [image]) }
      
//...

    }
}
```

```swift
final
 
class
 
MyView
: 
UIView
 
{
    
override
 
var
 activityItemsConfiguration: 
UIActivityItemsConfigurationReading
? {
      
get
 { 
UIActivityItemsConfiguration
(objects: images) }
      
//...

    }

    
func
 
viewDidLoad
()
 {
      
let
 contextMenuInteraction 
=
 
UIContextMenuInteraction
(delegate: 
self
)
      addInteraction(contextMenuInteraction)
    }
}
```

```swift
final
 
class
 
MyView
: 
UIView
 
{
    
override
 
var
 pasteConfiguration: 
UIPasteConfiguration
? {
      
get
 { 
UIPasteConfiguration
(forAcceptingClass: 
UIImage
.
self
) }
      
//...

    }

    
func
 
willMove
(
toWindow
: 
UIWindow
)
 {
       addInteraction(contextMenuInteraction)
    }

    
override
 
func
 
paste
(
itemProviders
: [
NSItemProvider
])
 {
       
for
 itemProvider 
in
 itemProviders {
            
if
 itemProvider.canLoadObject(ofClass: 
UIImage
.
self
) {
                
if
 
let
 image 
=
 
try?
 
await
 itemProvider.loadObject(ofClass:
UIImage
.
self
) {
                    insertImage(image)
                }          
                
//...
```


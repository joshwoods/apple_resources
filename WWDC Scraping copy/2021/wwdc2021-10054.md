# Wwdc2021 10054

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

What's new in AppKitExplore the latest advancements in Mac app development with AppKit. We'll show how you can enhance your app's design with new control features and SF Symbols 3, build powerful text experiences using TextKit 2, and harness the latest Swift features in your app.ResourcesAppKitHuman Interface Guidelines: SF SymbolsIntroducing SF SymbolsHD VideoSD VideoRelated VideosWWDC21Meet async/await in SwiftMeet TextKit 2Protect mutable state with Swift actorsSF Symbols in SwiftUI

Explore the latest advancements in Mac app development with AppKit. We'll show how you can enhance your app's design with new control features and SF Symbols 3, build powerful text experiences using TextKit 2, and harness the latest Swift features in your app.

AppKit

Human Interface Guidelines: SF Symbols

Introducing SF Symbols

HD VideoSD Video

HD Video

SD Video

Meet async/await in Swift

Meet TextKit 2

Protect mutable state with Swift actors

SF Symbols in SwiftUI

Search this video…♪ Bass music playing ♪♪Jeff Nadeau: Hi, and welcome to "What's new in AppKit."I'm Jeff Nadeau.I work on AppKit,and I've got some great updates to share with you.macOS Monterey includes some great new featuresand enhancements for Mac apps.There's really something for everyone in this release,including updates to our user interface design,enhancements to many of our controls,a big update to SF Symbols,an all-new text engine called TextKit 2,powerful new Swift language features,and automation with Shortcuts,which is now available on the Mac.Let's dive right in, starting with some updateson the design of the macOS user interface.We're thrilled by the response to the system-wide redesignthat debuted in macOS Big Sur.So many of our favorite apps have updatedto adopt the new design in only a few short months.In macOS Monterey,we've continued to iterate and refine this new design,so you'll notice a few new touches across the system.Some of them are big and noticeable,like popovers that now appear and recedewith a brand-new animation,or sliders that now smoothly glide into positionwhen you click them.There are also much more subtle changes,like refined metrics in toolbar controls,and spring-loading support on the Search button,so it's easy to drag in text and tokens.And increased spacing between table sectionsto improve clarity.We've continued to iterate and enhance the new designdown to the smallest details.And that leads me to some control enhancementsthat you can use to refine your own designs.The first big one is control tinting.We've enabled custom tinting of individual buttons,segmented controls, and sliders.Each of these controls accepts a custom tint colorusing one of these APIs: bezelColor,selectedSegmentColor, and trackFillColor.We introduced these APIs in macOS Sierrato allow tinting of individual controls in the Touch Bar.And starting in macOS Monterey,they're functional for in-window controls as well.To recap, most controls draw using the accent color,which is configurable in System Preferences.This allows people to theme their Macto match their favorite color.The Multicolor option allows each app to defineits own custom color.For pervasive theming,you can define a custom accent colorin your app's asset catalog.The new tinting API provides a way to override the colorfor one specific control.This is great for controls where you'd like to applya semantically meaningful color.For example, if your app uses a specific shade of orangeto distinguish a preorder from a normal purchase,you can reinforce that design using a tinted button.Another example would be a video conferencing app,where the Start and End Call buttonsperform two of the most meaningful actions in the app.Tinting them green and red adds emphasisand it makes their function instantly recognizable.One important note is that tinted buttonsalways show their tint color in every active state,unlike ordinary push buttons which are white or gray.This puts your tint color front and center.However, take care in your design not to create confusionwith the default button,which also uses a colorful appearance.Finally, it's important to convey your controls' purposeusing more than just color.You want to make sure that people who have difficultlydistinguishing between colors can still easily identifythe purpose of a given control,so be sure to provide a clear label or icon.Another important button design changeis that push buttons no longer highlightusing the accent color on click.This brings them in line with other clickable elements,like segmented control segments, slider knobs, and steppers.This is an important change,because if you're doing any custom drawingthat assumes a colorful appearance while highlighted --say, if you're choosing to draw white content over top --it might not look correct on macOS Monterey.Instead of checking for the highlight state,you can drive your drawing decisions usingthe interiorBackgroundStyle property.This property reflects the underlying styleof the button bezel, so it'll always return .normalfor colorless states, and it'll return .emphasizedfor those colorful emphasis states,like tinted buttons, default buttons,and buttons that are toggled into an "on" state.Finally, we've updatedthe Flexible Push style of button --previously known as Regular Square --to serve as a variable-height push button.It now supports all of the same configurationsas an ordinary push button, which means that it can serveas the default button, and you can tint it.The corner radius and content padding now match thoseof a standard push button at each control size,so they'll fit in great with your other controls,but their vertically resizable designmeans that they can accommodate larger iconsor text with line breaks.While the vast majority of push buttons should continueto use the standard fixed-height style,this newly expanded style offers some flexibilityfor those special cases when you need to accommodatetaller content.Another very important control update comes in the formof automatic localization for menu keyboard shortcuts.There are a lot of keyboard layouts out there in the world,and that can make localizing keyboard shortcutsfairly complex.Some key combinations are hard to reach on some keyboards,and others can't be typed at all.In addition, some directional keyboard shortcutsreally ought to mirror in right-to-left languages.The great news is, in macOS Monterey,AppKit can do it for you.Here's an example of a shortcutthat could benefit from localization: Command-backslash.While this works fine on a US English keyboard,it's actually impossible to type on a Japanese keyboard,which doesn't have a backslash key at all.Starting in macOS Monterey,the system remaps the shortcut automatically,providing an equivalent shortcut that's natural to type.Another common case is a keyboard shortcutthat has directional meaning.For example, Safari uses Command-square bracketsto go backward and forward in history.In a right-to-left language,using the left bracket to go backward isn't very intuitive,so AppKit now automatically swaps it to the right bracketwhen running in a right-to-left language.This behavior applies to brackets, braces,parentheses, and arrow keys.In some cases, you might want to disable this mirroring behavior.For example, if your menu item has absolute directionality --like align left, for example --you'd want to use the left bracketeven in a right-to-left language.We've provided an opt-out for cases just like this.You can control this behavior using some new propertieson NSMenuItem.allowsAutomaticKey EquivalentMirroringlets you control the mirroring behaviorfor directional keys like  brackets,and allowsAutomaticKey EquivalentLocalizationcontrols all of the localization features,including keyboard mapping and mirroring.If you've already carefully localizedyour keyboard shortcuts, or if your application hasa heavily custom implementation of keyboard shortcut bindings,you might want to disable this feature for your entire app.To do that,you can implement this application delegate method,applicationShouldAutomatically LocalizeKeyEquivalents,and return false.Most apps won't need to use this.The individual menu item APIs are strongly preferredfor opting out specific items,and most apps shouldn't need to opt out at all.Next up, some big enhancements to symbol images.We brought SF Symbols to macOS in Big Sur,opening up a massive repertoire of beautiful,typographically balanced symbol images to all Mac apps.In macOS Monterey, we've built a new generation of symbol APIsand tooling that we call SF Symbols 3.It's a huge update that spans every aspectof the symbol image workflow,and it's all available to your AppKit applications.SF Symbols 3 expands the capabilitiesof the SF Symbols app for previewing, exporting,and importing symbol images.It also comes with an updated formatfor annotating custom symbols, which allows you to definedistinct layers within a symbol image,and we've expanded our APIs in AppKit, UIKit, and SwiftUIto allow to you to individually color each layer of a symbol.In Big Sur, we offered two distinct rendering modesfor symbols.First, there was the traditional Template style,which draws using a single tint color or effectover the entire symbol.The second is Multicolor,which draws more like a full-color image,drawing each path element using a color that's definedin the symbol image itself.In SF Symbols 3, we've added two new rendering modeswhich take advantage of the layer informationprovided by the new symbol image format.The first, Hierarchical, draws using a single color,while putting emphasis on specific parts of the symbolwhile deemphasizing others.And the second, Palette, lets you assign any color you'd liketo each layer of the symbol.You can access these rendering modes using new APIon NSImage.SymbolConfiguration.I'm representing the NSColor parameters as dotsto show how they correspond with the rendered symbol.The Hierarchical rendering mode take a single color,which is applied to the symbol layers with decreasing opacity.The Palette mode accepts an array of colorswhich are applied to the layers verbatim.You can also create a configurationthat prefers the Multicolor rendering mode.We've also added a new API that lets you mapfrom one base symbol into one of its variants.For example, you could map the heart symbolto its filled variant,or an inscribed variant like circle,or even to the variant that has a slash through it.This is really useful for situations whereyou prefer a particular style of symbolfor a particular context.For example, you might have a picker controlwhere you prefer outlines for the unselected states,but a filled style for your selection.Normally, this control would needtwo different image properties to specify the selectedand unselected versions of the image.But with the variants API, it could just accepta single base symbol and derive the filled state automatically.This control could call image(with: .fill)to prefer a filled symbol in its selection state,and it'll automatically choose the right version of the symbolwhenever a filled variant is available.There are constants for each type of symbol variant,and you can combine themto request multiple variants together,like circle and fill.This was just a brief introduction to the featuresof SF Symbols 3.There's a new collection of videos where you can getthe full details on everything that's newacross the entire symbols workflow.Be sure to add them to your watch list.macOS Monterey also features a huge update to the text systemin the form of TextKit 2.TextKit is the text layout and rendering enginefor all Apple devices, and it's a great text enginewith a proven track record.TextKit is a linear text layout engine,which means that it typesets a block of textfrom beginning to end.As we've evolved our platforms and technologies,we've found a lot of cases where nonlinear text layoutwould serve us much better.So we went back to the basicsand created a new version of TextKitand that's TextKit 2.We had a few key goals for TextKit 2.As always, we want to provide the very best experiencefor international text of every script and layout.We also want to make it easierto mix text with other types of content.And finally, TextKit 2 is designed to be super fast,efficiently shaping and rendering text,whether it's a short labelor scrolled partway through a massive document.TextKit 2 coexists with TextKit 1,so you can choose which engine to use for a given text view.Now I'm going to let you in on a secret.You're already running TextKit 2 on your Macbecause starting in Big Sur,TextEdit uses it for plain text documents,and AppKit text fields use TextKit 2for most configurations.So you've actually been getting a sneak peek this entire time.One of the key differences in TextKit 2is that it always uses a nonlinear layout system.That means that it can perform text layoutat a more granular level,which allows it to avoid unnecessary work.For example, if we have a large documentwhere only a portion of the text is scrolled to be visible,a linear system still has to lay out all of the previous textin order to show this region.By comparison, a nonlinear system like TextKit 2can start layout at the nearest paragraph boundary.For large documents, this is a huge speedup.The new layout engine provides a robust setof customization points, making it simpleto extend the layout system and add your own behaviors.The nonlinear layout system also lends itself wellto mixing nontext elements into your text layout.And it does all of this while improving performancefor even the largest documents.To learn more, check out "Meet TextKit 2,"which goes into full detail about the design of the new APIand how to use it.Next up, I'd like to share some updates about AppKit in Swiftstarting with concurrency.Swift 5.5 introduces some importantlanguage-level features for managing concurrency.The first, async/await, allows for asynchronous method callsthat behave a lot like coroutines.The second, actor types, protect mutable state from data racesby isolating accesses to a single thread of execution.AppKit works great with both of these new features.For async/await,many asynchronous methods in AppKit --that is, methods that take a continuationas a completion handler block -- have been transformed in the SDKto offer async variants as well.One simple example is NSColorSampler,which allows the user to pick a color from anywhere onscreen.This call is asynchronous because it waits for the userto pick the color they'd like,and then it runs the completion handler when they're done.With async/await,you can express this as an async function call.It yields its thread of executionwhile it's waiting for the asynchronous work to complete,and then it picks right back up where it left off.You can even do it from within a guard statement.Now, the continuation -- the work to be done next --is no longer nested inside a completion handler block.Instead, the code reads naturally in sequence.Actors work to protect state from concurrent accessby isolating it to a single thread of execution.If that sounds familiar,it's because most of AppKit's state,like the view hierarchy and responder chain,should also be accessed from a single thread of execution,specifically the main thread.This restriction fits the actor model nicely,so we've introduced the concept of a MainActor,which is a type that has to be accessed from the main thread.In AppKit, we've designated NSResponderincluding its subclasses of NSView,ViewController, WindowController,and Application, plus NSCell, Alert, Document,and DocumentController as MainActors.Code running in a MainActor can freely call methodson other MainActor types,since you know that you're already on the main thread.However, code that's not running in the MainActormust use the new async/await features to perform that UI workin the context of the MainActor.By enforcing this at the compiler level,Swift can help you avoid a common source of bugswhen mixing concurrency with UI code.The Swift concurrency videos go into great depthabout this powerful new language feature.You don't want to miss them.Also new in Swift 5.5is a value-typed version of AttributedString.On top of providing value semantics,it also has type-safe attributes and great Swift ergonomicsfor enumerating and manipulating ranges of attributes.When you're using AttributedString with AppKit,you'll automatically get access to the attributesthat are relevant to our text drawing system;things like foreground color, paragraph style, and so on.You can convert between struct AttributedStringand the reference-typed NSAttributedString,so you can interoperate with APIsthat use NSAttributedString.The "What's new in Foundation" video goes into more detailon AttributedString's design and how to use it.Our last Swift enhancement has to do with driving updatesto your NSViews.It uses Swift's property wrapper featureto dramatically reduce the boilerplatethat's common in view properties.Let's go over an example.Here's a custom viewthat's configurable via a handful of properties.And while this looks fine,the reality is that our view's property declarationsare much more likely to contain a lot of didSetsand extra side effects,because it's so common that you need to redraw,or layout, or update your constraintswhen something changes.Now, that's a lot of boilerplate.So we made this scenario betterby creating a new Swift property wrapper just for this case.It's called Invalidating.It's nested under NSView, and it allows you to specifyone or more aspects of the view to invalidatewhen the wrapped property changes.All of the didSets and brackets fall away,making it easier to focus on the definitionof the property itself.AppKit provides several built-in invalidation cases:display, layout, constraints, intrinsic content size,and restorable state.Since these invalidations only make sense on views,we've constrained the property wrapperso that it only works on subclasses of NSView.We also require that the value conforms to Equatable.We use this conformanceto check for meaningful changes in valuebefore performing a potentially expensive redraw or layout pass.If you'd like to do something custom,you can even define your own invalidationby conforming a type to the NSViewInvalidating protocol.Finally, Shortcuts.In macOS Monterey, we're excited to bring the full powerof Shortcuts to the Mac,and that includes integrating Shortcuts with your AppKit apps.The great news is, if you app supports Services,then it already supports Shortcuts,and Shortcuts appear in all of the same placeswhere you can access Services today.If you're new to this functionality,it's really easy to adopt.AppKit decides which shortcuts are contextually-appropriateby checking the responder chain.It asks each responder whether it can provide or receivethe types of data expected by each shortcut.We express this using a pasteboard type,which in most cases, corresponds to a uniform type identifier.All you have to do is implement the validRequestorfor sendType and returnType method.And if you can accept or provide the specified types,return an object conforming tothe NSServicesMenuRequestor protocol.In most cases, you'll just implement that protocol directlyand then return self.Once a Shortcut is invoked,you'll get calls to write and/or read datafrom a special pasteboard that the Shortcut usesfor its input and output.And that's it!It's that easy to integrate your app with Shortcuts.We've also brought Siri Intents to macOS.You can now handle Intentsby creating an Intents Extension in Xcode.Or, if you need to handle them from your main application,you can return an Intent handler from your application delegate.In your app delegate, implement theapplication handlerFor intent: method,returning a handler object for any intent that you can handle.Every type of intent has its own handler protocolthat the returned object must conform to,so check the Intents framework documentationfor more details on implementing a handler object.Now that you're equipped with all of this new information,what's next?First, think about how features like control tintingand SF Symbols 3 can help you enhance the design of your app.Next, if your app uses TextKitto create a custom text experience,watch the "Meet TextKit 2" video and try out the new API.You're going to love how easy it isto express custom layouts and rich content with TextKit 2.The that way your app manages concurrency is a key partof its architecture,and Swift's new concurrency featureswill be a huge improvement in this area.Now is the time to start planningfor how features like async/await will shapethe way your app manages its concurrent workloads.Finally, get your app ready for Shortcutsby adopting AppKit's automation features.Thanks for your time and attention.We hope you enjoy all of these great enhancementsin macOS Monterey.♪

♪ Bass music playing ♪♪Jeff Nadeau: Hi, and welcome to "What's new in AppKit."I'm Jeff Nadeau.I work on AppKit,and I've got some great updates to share with you.macOS Monterey includes some great new featuresand enhancements for Mac apps.There's really something for everyone in this release,including updates to our user interface design,enhancements to many of our controls,a big update to SF Symbols,an all-new text engine called TextKit 2,powerful new Swift language features,and automation with Shortcuts,which is now available on the Mac.Let's dive right in, starting with some updateson the design of the macOS user interface.We're thrilled by the response to the system-wide redesignthat debuted in macOS Big Sur.So many of our favorite apps have updatedto adopt the new design in only a few short months.In macOS Monterey,we've continued to iterate and refine this new design,so you'll notice a few new touches across the system.Some of them are big and noticeable,like popovers that now appear and recedewith a brand-new animation,or sliders that now smoothly glide into positionwhen you click them.There are also much more subtle changes,like refined metrics in toolbar controls,and spring-loading support on the Search button,so it's easy to drag in text and tokens.And increased spacing between table sectionsto improve clarity.We've continued to iterate and enhance the new designdown to the smallest details.And that leads me to some control enhancementsthat you can use to refine your own designs.The first big one is control tinting.We've enabled custom tinting of individual buttons,segmented controls, and sliders.Each of these controls accepts a custom tint colorusing one of these APIs: bezelColor,selectedSegmentColor, and trackFillColor.We introduced these APIs in macOS Sierrato allow tinting of individual controls in the Touch Bar.And starting in macOS Monterey,they're functional for in-window controls as well.To recap, most controls draw using the accent color,which is configurable in System Preferences.This allows people to theme their Macto match their favorite color.The Multicolor option allows each app to defineits own custom color.For pervasive theming,you can define a custom accent colorin your app's asset catalog.The new tinting API provides a way to override the colorfor one specific control.This is great for controls where you'd like to applya semantically meaningful color.For example, if your app uses a specific shade of orangeto distinguish a preorder from a normal purchase,you can reinforce that design using a tinted button.Another example would be a video conferencing app,where the Start and End Call buttonsperform two of the most meaningful actions in the app.Tinting them green and red adds emphasisand it makes their function instantly recognizable.One important note is that tinted buttonsalways show their tint color in every active state,unlike ordinary push buttons which are white or gray.This puts your tint color front and center.However, take care in your design not to create confusionwith the default button,which also uses a colorful appearance.Finally, it's important to convey your controls' purposeusing more than just color.You want to make sure that people who have difficultlydistinguishing between colors can still easily identifythe purpose of a given control,so be sure to provide a clear label or icon.Another important button design changeis that push buttons no longer highlightusing the accent color on click.This brings them in line with other clickable elements,like segmented control segments, slider knobs, and steppers.This is an important change,because if you're doing any custom drawingthat assumes a colorful appearance while highlighted --say, if you're choosing to draw white content over top --it might not look correct on macOS Monterey.Instead of checking for the highlight state,you can drive your drawing decisions usingthe interiorBackgroundStyle property.This property reflects the underlying styleof the button bezel, so it'll always return .normalfor colorless states, and it'll return .emphasizedfor those colorful emphasis states,like tinted buttons, default buttons,and buttons that are toggled into an "on" state.Finally, we've updatedthe Flexible Push style of button --previously known as Regular Square --to serve as a variable-height push button.It now supports all of the same configurationsas an ordinary push button, which means that it can serveas the default button, and you can tint it.The corner radius and content padding now match thoseof a standard push button at each control size,so they'll fit in great with your other controls,but their vertically resizable designmeans that they can accommodate larger iconsor text with line breaks.While the vast majority of push buttons should continueto use the standard fixed-height style,this newly expanded style offers some flexibilityfor those special cases when you need to accommodatetaller content.Another very important control update comes in the formof automatic localization for menu keyboard shortcuts.There are a lot of keyboard layouts out there in the world,and that can make localizing keyboard shortcutsfairly complex.Some key combinations are hard to reach on some keyboards,and others can't be typed at all.In addition, some directional keyboard shortcutsreally ought to mirror in right-to-left languages.The great news is, in macOS Monterey,AppKit can do it for you.Here's an example of a shortcutthat could benefit from localization: Command-backslash.While this works fine on a US English keyboard,it's actually impossible to type on a Japanese keyboard,which doesn't have a backslash key at all.Starting in macOS Monterey,the system remaps the shortcut automatically,providing an equivalent shortcut that's natural to type.Another common case is a keyboard shortcutthat has directional meaning.For example, Safari uses Command-square bracketsto go backward and forward in history.In a right-to-left language,using the left bracket to go backward isn't very intuitive,so AppKit now automatically swaps it to the right bracketwhen running in a right-to-left language.This behavior applies to brackets, braces,parentheses, and arrow keys.In some cases, you might want to disable this mirroring behavior.For example, if your menu item has absolute directionality --like align left, for example --you'd want to use the left bracketeven in a right-to-left language.We've provided an opt-out for cases just like this.You can control this behavior using some new propertieson NSMenuItem.allowsAutomaticKey EquivalentMirroringlets you control the mirroring behaviorfor directional keys like  brackets,and allowsAutomaticKey EquivalentLocalizationcontrols all of the localization features,including keyboard mapping and mirroring.If you've already carefully localizedyour keyboard shortcuts, or if your application hasa heavily custom implementation of keyboard shortcut bindings,you might want to disable this feature for your entire app.To do that,you can implement this application delegate method,applicationShouldAutomatically LocalizeKeyEquivalents,and return false.Most apps won't need to use this.The individual menu item APIs are strongly preferredfor opting out specific items,and most apps shouldn't need to opt out at all.Next up, some big enhancements to symbol images.We brought SF Symbols to macOS in Big Sur,opening up a massive repertoire of beautiful,typographically balanced symbol images to all Mac apps.In macOS Monterey, we've built a new generation of symbol APIsand tooling that we call SF Symbols 3.It's a huge update that spans every aspectof the symbol image workflow,and it's all available to your AppKit applications.SF Symbols 3 expands the capabilitiesof the SF Symbols app for previewing, exporting,and importing symbol images.It also comes with an updated formatfor annotating custom symbols, which allows you to definedistinct layers within a symbol image,and we've expanded our APIs in AppKit, UIKit, and SwiftUIto allow to you to individually color each layer of a symbol.In Big Sur, we offered two distinct rendering modesfor symbols.First, there was the traditional Template style,which draws using a single tint color or effectover the entire symbol.The second is Multicolor,which draws more like a full-color image,drawing each path element using a color that's definedin the symbol image itself.In SF Symbols 3, we've added two new rendering modeswhich take advantage of the layer informationprovided by the new symbol image format.The first, Hierarchical, draws using a single color,while putting emphasis on specific parts of the symbolwhile deemphasizing others.And the second, Palette, lets you assign any color you'd liketo each layer of the symbol.You can access these rendering modes using new APIon NSImage.SymbolConfiguration.I'm representing the NSColor parameters as dotsto show how they correspond with the rendered symbol.The Hierarchical rendering mode take a single color,which is applied to the symbol layers with decreasing opacity.The Palette mode accepts an array of colorswhich are applied to the layers verbatim.You can also create a configurationthat prefers the Multicolor rendering mode.

We've also added a new API that lets you mapfrom one base symbol into one of its variants.For example, you could map the heart symbolto its filled variant,or an inscribed variant like circle,or even to the variant that has a slash through it.This is really useful for situations whereyou prefer a particular style of symbolfor a particular context.For example, you might have a picker controlwhere you prefer outlines for the unselected states,but a filled style for your selection.Normally, this control would needtwo different image properties to specify the selectedand unselected versions of the image.But with the variants API, it could just accepta single base symbol and derive the filled state automatically.This control could call image(with: .fill)to prefer a filled symbol in its selection state,and it'll automatically choose the right version of the symbolwhenever a filled variant is available.There are constants for each type of symbol variant,and you can combine themto request multiple variants together,like circle and fill.This was just a brief introduction to the featuresof SF Symbols 3.There's a new collection of videos where you can getthe full details on everything that's newacross the entire symbols workflow.Be sure to add them to your watch list.macOS Monterey also features a huge update to the text systemin the form of TextKit 2.TextKit is the text layout and rendering enginefor all Apple devices, and it's a great text enginewith a proven track record.TextKit is a linear text layout engine,which means that it typesets a block of textfrom beginning to end.As we've evolved our platforms and technologies,we've found a lot of cases where nonlinear text layoutwould serve us much better.So we went back to the basicsand created a new version of TextKitand that's TextKit 2.We had a few key goals for TextKit 2.As always, we want to provide the very best experiencefor international text of every script and layout.We also want to make it easierto mix text with other types of content.And finally, TextKit 2 is designed to be super fast,efficiently shaping and rendering text,whether it's a short labelor scrolled partway through a massive document.TextKit 2 coexists with TextKit 1,so you can choose which engine to use for a given text view.Now I'm going to let you in on a secret.You're already running TextKit 2 on your Macbecause starting in Big Sur,TextEdit uses it for plain text documents,and AppKit text fields use TextKit 2for most configurations.So you've actually been getting a sneak peek this entire time.One of the key differences in TextKit 2is that it always uses a nonlinear layout system.That means that it can perform text layoutat a more granular level,which allows it to avoid unnecessary work.For example, if we have a large documentwhere only a portion of the text is scrolled to be visible,a linear system still has to lay out all of the previous textin order to show this region.By comparison, a nonlinear system like TextKit 2can start layout at the nearest paragraph boundary.For large documents, this is a huge speedup.The new layout engine provides a robust setof customization points, making it simpleto extend the layout system and add your own behaviors.The nonlinear layout system also lends itself wellto mixing nontext elements into your text layout.And it does all of this while improving performancefor even the largest documents.To learn more, check out "Meet TextKit 2,"which goes into full detail about the design of the new APIand how to use it.Next up, I'd like to share some updates about AppKit in Swiftstarting with concurrency.Swift 5.5 introduces some importantlanguage-level features for managing concurrency.The first, async/await, allows for asynchronous method callsthat behave a lot like coroutines.The second, actor types, protect mutable state from data racesby isolating accesses to a single thread of execution.AppKit works great with both of these new features.For async/await,many asynchronous methods in AppKit --that is, methods that take a continuationas a completion handler block -- have been transformed in the SDKto offer async variants as well.One simple example is NSColorSampler,which allows the user to pick a color from anywhere onscreen.This call is asynchronous because it waits for the userto pick the color they'd like,and then it runs the completion handler when they're done.With async/await,you can express this as an async function call.It yields its thread of executionwhile it's waiting for the asynchronous work to complete,and then it picks right back up where it left off.You can even do it from within a guard statement.Now, the continuation -- the work to be done next --is no longer nested inside a completion handler block.Instead, the code reads naturally in sequence.Actors work to protect state from concurrent accessby isolating it to a single thread of execution.If that sounds familiar,it's because most of AppKit's state,like the view hierarchy and responder chain,should also be accessed from a single thread of execution,specifically the main thread.This restriction fits the actor model nicely,so we've introduced the concept of a MainActor,which is a type that has to be accessed from the main thread.In AppKit, we've designated NSResponderincluding its subclasses of NSView,ViewController, WindowController,and Application, plus NSCell, Alert, Document,and DocumentController as MainActors.Code running in a MainActor can freely call methodson other MainActor types,since you know that you're already on the main thread.However, code that's not running in the MainActormust use the new async/await features to perform that UI workin the context of the MainActor.By enforcing this at the compiler level,Swift can help you avoid a common source of bugswhen mixing concurrency with UI code.The Swift concurrency videos go into great depthabout this powerful new language feature.You don't want to miss them.Also new in Swift 5.5is a value-typed version of AttributedString.On top of providing value semantics,it also has type-safe attributes and great Swift ergonomicsfor enumerating and manipulating ranges of attributes.When you're using AttributedString with AppKit,you'll automatically get access to the attributesthat are relevant to our text drawing system;things like foreground color, paragraph style, and so on.You can convert between struct AttributedStringand the reference-typed NSAttributedString,so you can interoperate with APIsthat use NSAttributedString.The "What's new in Foundation" video goes into more detailon AttributedString's design and how to use it.Our last Swift enhancement has to do with driving updatesto your NSViews.It uses Swift's property wrapper featureto dramatically reduce the boilerplatethat's common in view properties.Let's go over an example.Here's a custom viewthat's configurable via a handful of properties.And while this looks fine,the reality is that our view's property declarationsare much more likely to contain a lot of didSetsand extra side effects,because it's so common that you need to redraw,or layout, or update your constraintswhen something changes.Now, that's a lot of boilerplate.So we made this scenario betterby creating a new Swift property wrapper just for this case.It's called Invalidating.It's nested under NSView, and it allows you to specifyone or more aspects of the view to invalidatewhen the wrapped property changes.All of the didSets and brackets fall away,making it easier to focus on the definitionof the property itself.

AppKit provides several built-in invalidation cases:display, layout, constraints, intrinsic content size,and restorable state.Since these invalidations only make sense on views,we've constrained the property wrapperso that it only works on subclasses of NSView.We also require that the value conforms to Equatable.We use this conformanceto check for meaningful changes in valuebefore performing a potentially expensive redraw or layout pass.If you'd like to do something custom,you can even define your own invalidationby conforming a type to the NSViewInvalidating protocol.Finally, Shortcuts.In macOS Monterey, we're excited to bring the full powerof Shortcuts to the Mac,and that includes integrating Shortcuts with your AppKit apps.The great news is, if you app supports Services,then it already supports Shortcuts,and Shortcuts appear in all of the same placeswhere you can access Services today.If you're new to this functionality,it's really easy to adopt.AppKit decides which shortcuts are contextually-appropriateby checking the responder chain.It asks each responder whether it can provide or receivethe types of data expected by each shortcut.We express this using a pasteboard type,which in most cases, corresponds to a uniform type identifier.All you have to do is implement the validRequestorfor sendType and returnType method.And if you can accept or provide the specified types,return an object conforming tothe NSServicesMenuRequestor protocol.In most cases, you'll just implement that protocol directlyand then return self.Once a Shortcut is invoked,you'll get calls to write and/or read datafrom a special pasteboard that the Shortcut usesfor its input and output.And that's it!It's that easy to integrate your app with Shortcuts.We've also brought Siri Intents to macOS.You can now handle Intentsby creating an Intents Extension in Xcode.Or, if you need to handle them from your main application,you can return an Intent handler from your application delegate.In your app delegate, implement theapplication handlerFor intent: method,returning a handler object for any intent that you can handle.Every type of intent has its own handler protocolthat the returned object must conform to,so check the Intents framework documentationfor more details on implementing a handler object.Now that you're equipped with all of this new information,what's next?First, think about how features like control tintingand SF Symbols 3 can help you enhance the design of your app.Next, if your app uses TextKitto create a custom text experience,watch the "Meet TextKit 2" video and try out the new API.You're going to love how easy it isto express custom layouts and rich content with TextKit 2.The that way your app manages concurrency is a key partof its architecture,and Swift's new concurrency featureswill be a huge improvement in this area.Now is the time to start planningfor how features like async/await will shapethe way your app manages its concurrent workloads.Finally, get your app ready for Shortcutsby adopting AppKit's automation features.Thanks for your time and attention.We hope you enjoy all of these great enhancementsin macOS Monterey.♪

4:18 -Determining a button's background style

14:40 -Pick a color

## Code Samples

```swift
class
 
NSButtonCell
 
{
    
/*
        Use to adjust your drawing for the underlying state of the bezel

        Returns .normal for colorless states

        Returns .emphasized for colorful/emphasis states
    */

    
var
 interiorBackgroundStyle: 
NSBackgroundStyle

}
```

```swift
@IBAction
 
func
 
pickColor
(
_
 
sender
: 
Any
?
)
 {
    
Task
 {
        
guard
 
let
 color 
=
 
await
 
NSColorSampler
().sample() 
else
 { 
return
 }
        textField.textColor 
=
 color
    }
}
```


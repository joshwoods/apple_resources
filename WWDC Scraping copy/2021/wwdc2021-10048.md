# Wwdc2021 10048

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Principles of great widgetsExplore the foundations of great widgets by keeping them relevant and customizable. Learn how to keep widgets up to date with timeline entries and TimelineReloadPolicies. Discover how to adapt your widget to different presentation environments and physical location. And lastly, find out how to create customizable widgets that someone can personalize to their liking.ResourcesKeeping a widget up to dateMaking a configurable widgetHD VideoSD VideoRelated VideosWWDC22Complications and widgets: ReloadedWWDC21Wednesday@WWDC21What's new in SwiftUIWhat's new in watchOS 8WWDC20Add configuration and intelligence to your widgetsBuild SwiftUI views for widgetsDesign great widgetsMeet WidgetKit

Explore the foundations of great widgets by keeping them relevant and customizable. Learn how to keep widgets up to date with timeline entries and TimelineReloadPolicies. Discover how to adapt your widget to different presentation environments and physical location. And lastly, find out how to create customizable widgets that someone can personalize to their liking.

Keeping a widget up to date

Making a configurable widget

HD VideoSD Video

HD Video

SD Video

Complications and widgets: Reloaded

Wednesday@WWDC21

What's new in SwiftUI

What's new in watchOS 8

Add configuration and intelligence to your widgets

Build SwiftUI views for widgets

Design great widgets

Meet WidgetKit

Search this video…♪ ♪Hello, my name is Brett Cato,and I’m an engineer on the System Experience team.Today we’re going to be talking about principlesof great widgets, diving into some hot topicsto help you build the best widgets possible.In iOS 14, we introduced WidgetKit.WidgetKit allows you to create beautiful,dynamic, multiplatform widgets right on the user’sHome Screen on iOS, iPadOS, and macOS.Now, before we get started, if you missed any of the talksfrom WWDC 2020, there are some really great ones,like “Meet WidgetKit,” which provides an introductionto the WidgetKit framework and its core concepts.“Widgets code-along” is a three-part seriesof building a widget with increasing complexityfrom basic to advanced.“Building SwiftUI views for widgets” detailshow to get the most out of SwiftUI to buildadaptable views for your widgets.Lastly, “Design great widgets” explores design considerationsfrom our human interface group with many, many examples.Today we’re gonna touch on two topics for great widgets:keeping them relevantand enabling widget customization.So let’s get started with relevance.There’s three types of relevancethat we’re gonna discuss in depthto make sure your widget is up to dateand can adapt to its environment.We’re gonna talk about time, presentation,and location relevance.At the heart of WidgetKit is the timeline.This is the core mechanism of Widgetsto stay relevant throughout the day.A timeline is composed of one or more timeline entries.In this example, you can see three such entries,one at 9:00 AM, 9:30 AM, and 10:00 AM.Now, when the system asks your widget for a timeline,the resulting timeline will be archived and its entriesrendered at specific times you specify into the future.This lets the system have your user interface readyat a moment’s notice to be displayedright when the user needs it.Let’s look at some examples of timelines,starting from the most simplistic,and look at the type of content that might be in them.Here’s an example of the simplest timelinewith just a single entry: Screen Time.Now, because Screen Time can’t predict or forecast datainto the futureand it’s strictly based on the statistical historyof how the user’s device has been used,it really can’t leverage multiple entriesin its timeline very well, so it just uses a single entry.This is the most simplistic timeline that you can have.That said, though, not all widgets needto be single entry, and in fact, in most cases,I’d encourage you to consider and question why you aren’toffering multiple entries in your timeline.If you have forward-looking content,have important dates or deadlines, or can forecastyour content into the future, your widget should really betaking advantage of multiple entries in your timeline.Here’s another example from Weather.As you can see, Weather’s timeline providesmultiple entries to last hours throughout the day.Now, the first entry here is the most accuratebecause it represents the current weather,and all the other subsequent entries representforecast data at times later in the day.This extra forecast data is super usefulas widget reloads aren’t guaranteed to reloadat the exact time that you specify.And if a reload doesn’t hit that target dateexactly when it’s desired, then now the system hasadditional forecasted contentto tide over the user experience.Here’s an example from Photos.You can see that the Photos timelineprovides a number of personal and relevant photosto appear at specific times of the day.For me, these are some really, really great memories.And now, while the widget reloadsonly a couple times a day, it really gives the feelingof being lively throughout by presentingnew and fresh content from these multiple timeline entries.As you can see here, even if you don’t havedata that’s forecastable like weather,as in this example with Photos, you can still incorporatecontent that’s relevant to the user in a waythat can surprise and delight by leveragingthese multiple entries in your timeline.Now, because some widgets are viewed more than others,we decided to give widgets a fairness factor for updates.We call this an update budget.Budgets are allocated and accumulated through the day,and they’re heavily influenced by user viewing habits.A frequently viewed widget can be expected to receivesomewhere in the ballpark of around 40 to 70background updates per day, which translates to an updateroughly every 15 to 30 minutes if spaced evenlyduring the normal hours that a user is awake.However, of course not all reloads have to beevenly spaced like this, and our goal was to enableand support a varied update cadencefor different requirements.For example, maybe you have a sports widgetthat’s largely idle until an upcoming gamefor a favorite team, and then it can receive a burstof score updates before, during, and even after the game.WidgetKit’s smart, and it may withhold updateswhen the user isn’t using the devicefor extended periods of time like when the user’s sleeping.Otherwise, widget updates may be withhelduntil budgets become available for a particular widget.All that said, though, reloads are notan every second operation.Widgets are not about creatinga live running experience on the Home Screen.Now, there’s numerous ways that your widgetswill refresh throughout the day.And we’re gonna walk through each of these brieflyto understand what they are,how they work, and how they functionrelative to the budget that we just introduced.The first is the TimelineReloadPolicy,which is API in WidgetKit.This is the core mechanismfor your reloads to occur automatically.When you provide a timeline,you also provide a reload policy alongside it.This reload policy informs the system when you’d liketo automatically refresh your widget in the background.These automatic updates are budgeted and debitedfrom your widget’s current available budget.Next is the WidgetCenter reload API.This is an API to refresh your widget when events occurthat would invalidate your widget’s existing data.Now, normally, requests using this API wouldconsume available budget, meaning that updateswon’t occur until budget is available.However, there are a few situational exceptions that willmake these reloads occur both immediately and budget-free.These are when your container app is foreground to the useror when your app is participating in a user session,like Navigation or Now Playing audio.This API is really supplemental to the automaticbackground updates from the TimelineReloadPolicy API.Your widgets can also updatewhen a significant location change has occurred.When the system detects a significant location changeand your widget uses location,the system will grant you a budget-free update.This refresh occurs when the user next views your widgetso that location can be resolved appropriately.Now, note that this is not guaranteed to happenright when the location change occursbut, rather, the next time the user views the widget.We’ll talk a little bit more on location later.The system can refresh your widget, too,if its presentation environment changes.For example, maybe the user changesan Accessibility preference like dynamic text or bold text,there’s a language or region change,an iCloud or App Store account change,significant time change, and more.Lastly, due to budgeting, if a user has a widgetthat’s rarely seen, it may not receiveas many updates as you, the developer, may prefer.The system knows what dates are in your timeline,what your preferred refresh time is,and general view history from the user.The system may grant a budget-free reloadif it thinks the data may be stalewhen it’s viewed by the user.Of course, all these system-initiated updatesare always budget-free.As we learned just a moment ago, each timeline comes pairedwith a reload policy that describeswhen it should automatically update in the background.WidgetKit offers three choices here: atEnd,afterDate, and never.Which of these three reload policiesare appropriate for your widget?Let’s dive in to talk about each one,with some examples for context, and we’ll talk about gotchason what to be mindful about with each one.The first policy we’ll discuss is the atEnd reload policy.This policy will mark your widget eligibleto be refreshed when the timeline comes to an end,that is, of course, when the last entry becomes relevant.In this case, it’s at 10:30 AM.Note, too, that this time is simplythe time that the widget becomes eligible for refreshing,and it doesn’t guarantee that it’ll refreshexactly at this time.Further, if using atEnd with widgets that havesingle-entry timelines, like the Screen Time examplewe talked about before, the system will choosean appropriate time for your widget.atEnd is recommended if your widget already has contentthat extends beyond the life of its current timeline.I kind of like to think about itlike viewing windows into your content.Let’s look at an example.Outlined here is the current timelinefor the Calendar widget on June 7th.It has four entries.I’ve included its past and future content to helpshowcase the windows.And as we change the timeline for June 8th,you can see what I meanby viewing a window into its content.And again for the timeline for June 9th.We’re just changing the perspective on the datathat’s already available and provided by the user.This type of content is really where usingthe atEnd policy shines.Now, some examples of widgets that use the atEnd policyinclude Reminders, Calendar, Photos, Tips, and more.Again, these are all widgets with endless content well knowninto the future where you can simply view a window into it.It’s not really a great fit for single-entry timelinesbecause the system’s gonna choose a reload time for you,and it’s probably not what you want.AtEnd is also not recommended if your timeline hasprojected content that loses relevance or accuracy over time.We simply want your content to bethe most relevant that it can be,and if we wait until the end of the timelinewhen things are the least relevantto become eligible for updating,then it just doesn’t lead to the best user experience.So that’s atEnd. Now, let’s talk about afterDate.The afterDate reload policy makes your widgeteligible for reloading after the date that’s specified.With afterDate, you’re really in full controlof the eligibility time.In this example, let’s pretend the timelineis valid from 9:00 AM to roughly 11:00 AM.A widget reload policy date of 9:30 AM was chosenbecause the widget’s forecast datastarts to lose accuracy around 9:45 or so.This gives the widget plenty of runway after 9:30to still show its forecast data,even if it’s not reloaded immediately at 9:30.afterDate is most appropriate for content that can changeunpredictably or unexpectedly throughout the dayas well as for data whose accuracy or relevancechanges periodically.Some examples of widgets that use afterDateinclude Stocks, Weather, News, Mail, and more.These are all widgets with content that canchange unpredictably or unexpectedly through the day.Now, with afterDate, you have to really be carefulof a few potential issues.Be cautious of near-immediate reloads.It can be valid to specify a date a minute or so awaybut usually only for very narrow windows of time.Asking for too many refreshes at this level of resolutioncan starve yourself of reloads later.Also be careful if you align widgets refresh datesacross devices.For example, the U.S. Stock Market opensat 9:30 AM on the East Coastand you schedule a refresh at exactly 9:30 AMto fetch that initial data for the day from servers.Remember, your widget could be on thousandsor even many millions of devices,potentially even multiple timeson each of those devices as well.And if you have to have time-aligned data pullslike this, you really should consideradding some level of random jitter to these datesin addition to hitting caching servers.These are especially important to considerto avoid any potentially unplanned or unnecessary costs.Lastly, let’s talk about my favorite reload policy,which is never.The never reload policy is the simplest policybecause it never automatically reloads.If your widget’s content can only changethrough its container application being foregroundor through discrete events like push notifications,then never is a great choice for your widget.When using the never policy, you can keep your widgetup to date solely with the WidgetCenter reload APIfrom your container or other accessory extensions.This really minimizes reloads to happenonly when necessary and it keeps minimal impactto your budget and to the user’s battery life.Never is also appropriate if your widget requiresan explicit user condition in your appthat hasn’t yet been satisfied.For example, maybe logging in to a serviceor purchasing some specific content.Consider never if your widget can’t produce meaningful contentbefore these types of conditions are met in your app.Good examples of widgets that use the never policyinclude TV, Notes, Music,Podcasts, Contacts, and more.These are all widgets and apps that requireuser interaction in the app to drive content changesor they receive pushes for those content updates.In summary, leverage timeline entries to your advantage.Choose the correct reload policy for your widget,and use WidgetCenter’s reload APIto reload timeline events on discrete events.All right, let’s move on to presentation relevance.Your widget may be presented in specific contextson iOS or macOS that could resultin your widget changing appearance.The widget may sometimes be rerenderedwithout any timeline updates.And great widgets will always adaptto these presentation environments appropriately.So we’re gonna talk about color schemes,Dark and Light Mode, partial privacy redactions,which are new in iOS 15, and full-on privacy redactions.WidgetKit will automatically handle shifting your contentbetween Light and Dark Mode as the system settings change.This is because we use the power of SwiftUI.Now think about how you want your widgetto look in these respective contexts.Here you can see examples of Notes and Calendarin both the light and dark schemes.Remember, though, that not all widgets necessarilyhave to conform to Light and Dark Mode by changingtheir background and text colors.There are a few widgets, like Music and Stocks,for example, that don’t change their colors.If your application design is agnosticof this high contrast content of dark and light styles,then feel free to continuewhatever color scheme makes sense for your widget.You can also preview color scheme changesto your widget in Xcode through Xcode Previews.Here’s a quick example of previewinga systemSmall widget in Light Mode.And now in Dark Mode.All we had to do was add the colorSchemeenvironment override to previewhow our widget would look in this environment.And if you want the system standard background colorfor Light and Dark Mode as shown here,then use BackgroundStyle for your fill.Widgets are also subjected to presentation environmentsthat can be privacy sensitive, like the Lock Screen on iOS.New in iOS 15, widgets can now redactpartial content in these situations.Now, that may sound really confusing,so let’s give an example to seewhat the heck I’m talking about here.Let’s pretend we had a banking widgetwhere I’m showing the balance available in a specific account.In this case, I have $128.45 available in my account.Now, when we go to the Lock Screen and lock the device,this account balance still appears in iOS 14because WidgetKit really had no way to dynamically redactthe balance information when the device became locked.However, that’s now changed in iOS 15,and you may now contextually markspecific views to be redacted in these situations.Now, to show you how to do that, all we do is, we simply insertthe .privacySensitive view modifieron the text representing the balance amount.So when not passcode locked, as you can see here,the view still renders the balance amountas you’d expect.But when we now lock the device,the balance amount becomes masked, or redacted.Be aware, too, that this modifier can beapplied to any view, including container viewslike hstacks and vstacks.And if applied to a container,the entire container will be redacted.If your app leverages complete data protection that can’t betouched while an iOS device is passcode locked, for example,maybe your app is using Health data and you skippedbuilding a widget or were scared to include itbecause you thought it had to be shown on the Lock Screen,then this feature is really for you.WidgetKit can automatically replaceyour active timeline content with your placeholder contentwhen the device is passcode lockedfor a full redaction of content.And it can even withhold updates for the durationwhile the device is passcode locked.This is all possible when you adoptthe default-data-protection entitlement listed here.Your timeline data will be stored per your wishesin that data class on the device.We really take your data privacy seriously here.Lastly, I want to talk about location relevancy.Widgets, like your app, can also providecontextual informationfor our current physical locationor just simply locations that are relevantto the user in one way or another.If your application uses location normally,then it’s likely that your widget should too.Because widgets can have multiple instanceson the Home screen and in Notification Centeron the Mac, consider offering pre-selectedand even searchable locations for your widgetsin addition to using the current locationjust like we do with the Weather widgetthrough the power of Intents.Now, to fetch current location in your widget,there’s only a few steps required.First, you need to specifythe NSWidgetUsesLocation key in your Info.plist.This lets the system know that you’ll beusing location from your widget extension.Secondly, use the CLLocationManageras you would normally, except this timefrom your TimelineProvider in your widget extension.Consider the resolution your widget requires,as it’s faster to resolve coarse location,and it can result in a better user experienceif you don’t need super precise location.In general, the more precise the location requested,the longer it’s gonna take to resolve.Lastly, you can check whether the widget is authorizedfor location updates by using the isAuthorizedForWidgetUpdatesAPI on the CLLocationManager.This’ll tell you whether the user has grantedyour widget permission to use location or not.Speaking of permissions,let’s look at location permissionsfor widgets in more detail to see how they work.Permissions for the widget are generally sharedwith its app container.Here, you can see a list of the available locationpermissions available from the Settings app.If the user selects “While using app,”the user’s location is available to the widgetonly when the widget’s container appis foreground to the user or other situations that wouldconsider the app to be in-use, like being in a nav session.If the user selects “While using app or widgets,”then location is available just the same as beforewith “While using app,” but with an additional allowancespecific to the widget.This allows the widget permissions to receive locationup to 15 minutes after a widget was last viewed.And when location can’t be resolved with either of thesetwo permissions set, consider alternate content,potentially even prior content if it’s available,or simply indicatingthat the location couldn’t be resolved.If the user selects “Always” for the permission,the widget will always have available permissionto access location.Finally, let’s talk about building customizable widgets.We’re gonna talk about size, kind, and configurationas a means for users to personalizetheir widget experience.Now, widgets come in all different sizes.And it’s recommended to support as many sizes as you canso that users have choice when placing their widgets.Remember that small variances do exist in sizing between devices,and it’s best to use system standard padding,margins, text styles, and text sizes when possible.Now, if you look at this iPad,it’s really transformed into a content showcase.If it’s not obvious, a new size has been added in iOS 15specifically for the iPad, and we call it Extra Large.Here it is so you can see it better.It’s the same height as the large widget but widerto showcase even more content that’s available on the iPad.And here’s how you add it to your widget.Here I’ve added it to an existing widget configthat already supports the systemLarge family.By default, if you don’t specifysupported families on your widget configuration,then the new size will be supported automaticallyif you build with the iOS 15 SDK, or later.The next axis for personalizationis the widget kind.Kinds of widgets offer different perspectivesinto your data or content.So think about what kinds of widgetsmight make the most sense in your app.The best way to describe these is really by example.Here’s an example from Clock.On the left, we have a City widgetthat tracks the time of a single city,and on the right, a World Clock widgetthat can accommodate many different citiesin the same view.Here’s another example from Stocks.On the left, there’s a stock Symbol widgetthat shows the stock price for a given stock--in this case, Apple--and on the right, an Overview widget.The Overview widget will show a series of stocksreflected in the user’s Stocks app.So how do you publish these different kinds of widgets?Well, to publish multiple kinds of widgets is super trivial.Using that Stocks example from before,here I have a Symbol widget and an Overview widgetin the top left.To publish these, you just return the differentwidget configurations in a WidgetBundle objectand include the @main attribute to the WidgetBundle.It’s that easy.Note that the order that widgets are definedin the bundle is also very important.This order reflects how your widgetswill appear in the widget gallery.So make sure that the first widget listedis your hero use case.Lastly, it’s not possibleto dynamically publish or dynamically retractthe availability of a widget once your app is installed.So some care and thought should be appliedaround the support of your widgets over time.The last axis for customizabilityis through configuration.And widgets support two types:static and Intent-based configurations.Static widget configurations deliverthe same content for each widget instance.Remember that Stocks Overview example from before?Well, each one’s gonna show the exact same contenteven if they’re in different locations on the user’s device.Static widgets are super simple,and they’re elegant widget definitions because they takeno configuration or setup from the user.On the other hand, Intent widget configurationsdeliver user-configured content for each instance.Check out these Stock Symbol widgets on the right.This user has configured many different instances,each showcasing a different stock.Now, this is some pretty sweet stuff.And a user could even combine these all into a stackof widgets on their Home Screen to flip through to save space.So how are these configured by the user, you might ask.Well, from a user’s perspective,the system will provide all the surrounding UI pieces.And after tapping on a widget in Edit modethat supports Intents,the configuration platter is shown.It presents a list of parameters from the Intentthat the user can configure.And in this example, there’s a single parameterfor the Symbol to track and its valueis currently the string AAPL for the Apple stock.Now, once a user taps on a parameter,an input controller appearsto collect the input from the user.And once completed, the widget will update automatically.Now, there’s a ton of customization that you can dowith an Intent, and there’s a great talkfrom WWDC 2020 that I’ll share in a moment to help youget started if you want an Intent configuration.In the meantime, let’s just quickly highlightwhat the differences are between coding a widgetbased on Intents versus a static configuration.The static configuration’s really simple.You just instantiate a StaticConfiguration objectwith the standard TimelineProvider.Let’s contrast that with an Intent configuration.All that’s different here is that the StaticConfigurationis replaced by an IntentConfiguration,and the TimelineProvider is replacedby an IntentTimelineProvider.Each of these has a slightly modified interfaceto support Intents, and this is so you can receivethe user-configured Intent when populating your timeline.For a more detailed look at creating and configuringIntents for widgets, including an overviewon the various data types supportedand what they look like from the config UI,check out the “Add configuration and intelligenceto your widgets” talk from WWDC 2020.To wrap up, we’ve reviewed how great widgetsmake use of their timeline entries,master their reload policy, and adapt to their presentationand potentially physical environments.Plan to offer different sizes, kinds,and configurations to give a dynamicand personalizable experience to your users.Thank you.

♪ ♪Hello, my name is Brett Cato,and I’m an engineer on the System Experience team.Today we’re going to be talking about principlesof great widgets, diving into some hot topicsto help you build the best widgets possible.In iOS 14, we introduced WidgetKit.WidgetKit allows you to create beautiful,dynamic, multiplatform widgets right on the user’sHome Screen on iOS, iPadOS, and macOS.

Now, before we get started, if you missed any of the talksfrom WWDC 2020, there are some really great ones,like “Meet WidgetKit,” which provides an introductionto the WidgetKit framework and its core concepts.“Widgets code-along” is a three-part seriesof building a widget with increasing complexityfrom basic to advanced.“Building SwiftUI views for widgets” detailshow to get the most out of SwiftUI to buildadaptable views for your widgets.Lastly, “Design great widgets” explores design considerationsfrom our human interface group with many, many examples.

Today we’re gonna touch on two topics for great widgets:keeping them relevantand enabling widget customization.So let’s get started with relevance.There’s three types of relevancethat we’re gonna discuss in depthto make sure your widget is up to dateand can adapt to its environment.We’re gonna talk about time, presentation,and location relevance.At the heart of WidgetKit is the timeline.This is the core mechanism of Widgetsto stay relevant throughout the day.A timeline is composed of one or more timeline entries.In this example, you can see three such entries,one at 9:00 AM, 9:30 AM, and 10:00 AM.Now, when the system asks your widget for a timeline,the resulting timeline will be archived and its entriesrendered at specific times you specify into the future.This lets the system have your user interface readyat a moment’s notice to be displayedright when the user needs it.Let’s look at some examples of timelines,starting from the most simplistic,and look at the type of content that might be in them.

Here’s an example of the simplest timelinewith just a single entry: Screen Time.Now, because Screen Time can’t predict or forecast datainto the futureand it’s strictly based on the statistical historyof how the user’s device has been used,it really can’t leverage multiple entriesin its timeline very well, so it just uses a single entry.This is the most simplistic timeline that you can have.That said, though, not all widgets needto be single entry, and in fact, in most cases,I’d encourage you to consider and question why you aren’toffering multiple entries in your timeline.If you have forward-looking content,have important dates or deadlines, or can forecastyour content into the future, your widget should really betaking advantage of multiple entries in your timeline.Here’s another example from Weather.As you can see, Weather’s timeline providesmultiple entries to last hours throughout the day.Now, the first entry here is the most accuratebecause it represents the current weather,and all the other subsequent entries representforecast data at times later in the day.This extra forecast data is super usefulas widget reloads aren’t guaranteed to reloadat the exact time that you specify.And if a reload doesn’t hit that target dateexactly when it’s desired, then now the system hasadditional forecasted contentto tide over the user experience.

Here’s an example from Photos.You can see that the Photos timelineprovides a number of personal and relevant photosto appear at specific times of the day.For me, these are some really, really great memories.And now, while the widget reloadsonly a couple times a day, it really gives the feelingof being lively throughout by presentingnew and fresh content from these multiple timeline entries.As you can see here, even if you don’t havedata that’s forecastable like weather,as in this example with Photos, you can still incorporatecontent that’s relevant to the user in a waythat can surprise and delight by leveragingthese multiple entries in your timeline.

Now, because some widgets are viewed more than others,we decided to give widgets a fairness factor for updates.We call this an update budget.Budgets are allocated and accumulated through the day,and they’re heavily influenced by user viewing habits.A frequently viewed widget can be expected to receivesomewhere in the ballpark of around 40 to 70background updates per day, which translates to an updateroughly every 15 to 30 minutes if spaced evenlyduring the normal hours that a user is awake.However, of course not all reloads have to beevenly spaced like this, and our goal was to enableand support a varied update cadencefor different requirements.For example, maybe you have a sports widgetthat’s largely idle until an upcoming gamefor a favorite team, and then it can receive a burstof score updates before, during, and even after the game.

WidgetKit’s smart, and it may withhold updateswhen the user isn’t using the devicefor extended periods of time like when the user’s sleeping.Otherwise, widget updates may be withhelduntil budgets become available for a particular widget.All that said, though, reloads are notan every second operation.Widgets are not about creatinga live running experience on the Home Screen.Now, there’s numerous ways that your widgetswill refresh throughout the day.And we’re gonna walk through each of these brieflyto understand what they are,how they work, and how they functionrelative to the budget that we just introduced.The first is the TimelineReloadPolicy,which is API in WidgetKit.This is the core mechanismfor your reloads to occur automatically.When you provide a timeline,you also provide a reload policy alongside it.This reload policy informs the system when you’d liketo automatically refresh your widget in the background.These automatic updates are budgeted and debitedfrom your widget’s current available budget.

Next is the WidgetCenter reload API.This is an API to refresh your widget when events occurthat would invalidate your widget’s existing data.Now, normally, requests using this API wouldconsume available budget, meaning that updateswon’t occur until budget is available.However, there are a few situational exceptions that willmake these reloads occur both immediately and budget-free.These are when your container app is foreground to the useror when your app is participating in a user session,like Navigation or Now Playing audio.

This API is really supplemental to the automaticbackground updates from the TimelineReloadPolicy API.Your widgets can also updatewhen a significant location change has occurred.When the system detects a significant location changeand your widget uses location,the system will grant you a budget-free update.This refresh occurs when the user next views your widgetso that location can be resolved appropriately.Now, note that this is not guaranteed to happenright when the location change occursbut, rather, the next time the user views the widget.We’ll talk a little bit more on location later.The system can refresh your widget, too,if its presentation environment changes.For example, maybe the user changesan Accessibility preference like dynamic text or bold text,there’s a language or region change,an iCloud or App Store account change,significant time change, and more.Lastly, due to budgeting, if a user has a widgetthat’s rarely seen, it may not receiveas many updates as you, the developer, may prefer.The system knows what dates are in your timeline,what your preferred refresh time is,and general view history from the user.The system may grant a budget-free reloadif it thinks the data may be stalewhen it’s viewed by the user.Of course, all these system-initiated updatesare always budget-free.As we learned just a moment ago, each timeline comes pairedwith a reload policy that describeswhen it should automatically update in the background.WidgetKit offers three choices here: atEnd,afterDate, and never.Which of these three reload policiesare appropriate for your widget?Let’s dive in to talk about each one,with some examples for context, and we’ll talk about gotchason what to be mindful about with each one.

The first policy we’ll discuss is the atEnd reload policy.This policy will mark your widget eligibleto be refreshed when the timeline comes to an end,that is, of course, when the last entry becomes relevant.In this case, it’s at 10:30 AM.Note, too, that this time is simplythe time that the widget becomes eligible for refreshing,and it doesn’t guarantee that it’ll refreshexactly at this time.Further, if using atEnd with widgets that havesingle-entry timelines, like the Screen Time examplewe talked about before, the system will choosean appropriate time for your widget.atEnd is recommended if your widget already has contentthat extends beyond the life of its current timeline.I kind of like to think about itlike viewing windows into your content.Let’s look at an example.Outlined here is the current timelinefor the Calendar widget on June 7th.It has four entries.I’ve included its past and future content to helpshowcase the windows.And as we change the timeline for June 8th,you can see what I meanby viewing a window into its content.

And again for the timeline for June 9th.We’re just changing the perspective on the datathat’s already available and provided by the user.This type of content is really where usingthe atEnd policy shines.

Now, some examples of widgets that use the atEnd policyinclude Reminders, Calendar, Photos, Tips, and more.Again, these are all widgets with endless content well knowninto the future where you can simply view a window into it.It’s not really a great fit for single-entry timelinesbecause the system’s gonna choose a reload time for you,and it’s probably not what you want.AtEnd is also not recommended if your timeline hasprojected content that loses relevance or accuracy over time.We simply want your content to bethe most relevant that it can be,and if we wait until the end of the timelinewhen things are the least relevantto become eligible for updating,then it just doesn’t lead to the best user experience.So that’s atEnd. Now, let’s talk about afterDate.The afterDate reload policy makes your widgeteligible for reloading after the date that’s specified.With afterDate, you’re really in full controlof the eligibility time.In this example, let’s pretend the timelineis valid from 9:00 AM to roughly 11:00 AM.A widget reload policy date of 9:30 AM was chosenbecause the widget’s forecast datastarts to lose accuracy around 9:45 or so.This gives the widget plenty of runway after 9:30to still show its forecast data,even if it’s not reloaded immediately at 9:30.

afterDate is most appropriate for content that can changeunpredictably or unexpectedly throughout the dayas well as for data whose accuracy or relevancechanges periodically.

Some examples of widgets that use afterDateinclude Stocks, Weather, News, Mail, and more.These are all widgets with content that canchange unpredictably or unexpectedly through the day.Now, with afterDate, you have to really be carefulof a few potential issues.Be cautious of near-immediate reloads.It can be valid to specify a date a minute or so awaybut usually only for very narrow windows of time.Asking for too many refreshes at this level of resolutioncan starve yourself of reloads later.

Also be careful if you align widgets refresh datesacross devices.For example, the U.S. Stock Market opensat 9:30 AM on the East Coastand you schedule a refresh at exactly 9:30 AMto fetch that initial data for the day from servers.Remember, your widget could be on thousandsor even many millions of devices,potentially even multiple timeson each of those devices as well.And if you have to have time-aligned data pullslike this, you really should consideradding some level of random jitter to these datesin addition to hitting caching servers.These are especially important to considerto avoid any potentially unplanned or unnecessary costs.Lastly, let’s talk about my favorite reload policy,which is never.The never reload policy is the simplest policybecause it never automatically reloads.If your widget’s content can only changethrough its container application being foregroundor through discrete events like push notifications,then never is a great choice for your widget.When using the never policy, you can keep your widgetup to date solely with the WidgetCenter reload APIfrom your container or other accessory extensions.This really minimizes reloads to happenonly when necessary and it keeps minimal impactto your budget and to the user’s battery life.Never is also appropriate if your widget requiresan explicit user condition in your appthat hasn’t yet been satisfied.For example, maybe logging in to a serviceor purchasing some specific content.Consider never if your widget can’t produce meaningful contentbefore these types of conditions are met in your app.Good examples of widgets that use the never policyinclude TV, Notes, Music,Podcasts, Contacts, and more.These are all widgets and apps that requireuser interaction in the app to drive content changesor they receive pushes for those content updates.In summary, leverage timeline entries to your advantage.Choose the correct reload policy for your widget,and use WidgetCenter’s reload APIto reload timeline events on discrete events.All right, let’s move on to presentation relevance.Your widget may be presented in specific contextson iOS or macOS that could resultin your widget changing appearance.The widget may sometimes be rerenderedwithout any timeline updates.And great widgets will always adaptto these presentation environments appropriately.So we’re gonna talk about color schemes,Dark and Light Mode, partial privacy redactions,which are new in iOS 15, and full-on privacy redactions.

WidgetKit will automatically handle shifting your contentbetween Light and Dark Mode as the system settings change.This is because we use the power of SwiftUI.Now think about how you want your widgetto look in these respective contexts.Here you can see examples of Notes and Calendarin both the light and dark schemes.Remember, though, that not all widgets necessarilyhave to conform to Light and Dark Mode by changingtheir background and text colors.There are a few widgets, like Music and Stocks,for example, that don’t change their colors.If your application design is agnosticof this high contrast content of dark and light styles,then feel free to continuewhatever color scheme makes sense for your widget.

You can also preview color scheme changesto your widget in Xcode through Xcode Previews.Here’s a quick example of previewinga systemSmall widget in Light Mode.

And now in Dark Mode.All we had to do was add the colorSchemeenvironment override to previewhow our widget would look in this environment.And if you want the system standard background colorfor Light and Dark Mode as shown here,then use BackgroundStyle for your fill.

Widgets are also subjected to presentation environmentsthat can be privacy sensitive, like the Lock Screen on iOS.New in iOS 15, widgets can now redactpartial content in these situations.Now, that may sound really confusing,so let’s give an example to seewhat the heck I’m talking about here.

Let’s pretend we had a banking widgetwhere I’m showing the balance available in a specific account.In this case, I have $128.45 available in my account.

Now, when we go to the Lock Screen and lock the device,this account balance still appears in iOS 14because WidgetKit really had no way to dynamically redactthe balance information when the device became locked.However, that’s now changed in iOS 15,and you may now contextually markspecific views to be redacted in these situations.Now, to show you how to do that, all we do is, we simply insertthe .privacySensitive view modifieron the text representing the balance amount.So when not passcode locked, as you can see here,the view still renders the balance amountas you’d expect.But when we now lock the device,the balance amount becomes masked, or redacted.

Be aware, too, that this modifier can beapplied to any view, including container viewslike hstacks and vstacks.And if applied to a container,the entire container will be redacted.

If your app leverages complete data protection that can’t betouched while an iOS device is passcode locked, for example,maybe your app is using Health data and you skippedbuilding a widget or were scared to include itbecause you thought it had to be shown on the Lock Screen,then this feature is really for you.

WidgetKit can automatically replaceyour active timeline content with your placeholder contentwhen the device is passcode lockedfor a full redaction of content.And it can even withhold updates for the durationwhile the device is passcode locked.This is all possible when you adoptthe default-data-protection entitlement listed here.Your timeline data will be stored per your wishesin that data class on the device.We really take your data privacy seriously here.Lastly, I want to talk about location relevancy.Widgets, like your app, can also providecontextual informationfor our current physical locationor just simply locations that are relevantto the user in one way or another.

If your application uses location normally,then it’s likely that your widget should too.Because widgets can have multiple instanceson the Home screen and in Notification Centeron the Mac, consider offering pre-selectedand even searchable locations for your widgetsin addition to using the current locationjust like we do with the Weather widgetthrough the power of Intents.Now, to fetch current location in your widget,there’s only a few steps required.First, you need to specifythe NSWidgetUsesLocation key in your Info.plist.This lets the system know that you’ll beusing location from your widget extension.Secondly, use the CLLocationManageras you would normally, except this timefrom your TimelineProvider in your widget extension.Consider the resolution your widget requires,as it’s faster to resolve coarse location,and it can result in a better user experienceif you don’t need super precise location.In general, the more precise the location requested,the longer it’s gonna take to resolve.

Lastly, you can check whether the widget is authorizedfor location updates by using the isAuthorizedForWidgetUpdatesAPI on the CLLocationManager.This’ll tell you whether the user has grantedyour widget permission to use location or not.Speaking of permissions,let’s look at location permissionsfor widgets in more detail to see how they work.Permissions for the widget are generally sharedwith its app container.Here, you can see a list of the available locationpermissions available from the Settings app.

If the user selects “While using app,”the user’s location is available to the widgetonly when the widget’s container appis foreground to the user or other situations that wouldconsider the app to be in-use, like being in a nav session.

If the user selects “While using app or widgets,”then location is available just the same as beforewith “While using app,” but with an additional allowancespecific to the widget.This allows the widget permissions to receive locationup to 15 minutes after a widget was last viewed.And when location can’t be resolved with either of thesetwo permissions set, consider alternate content,potentially even prior content if it’s available,or simply indicatingthat the location couldn’t be resolved.

If the user selects “Always” for the permission,the widget will always have available permissionto access location.Finally, let’s talk about building customizable widgets.We’re gonna talk about size, kind, and configurationas a means for users to personalizetheir widget experience.Now, widgets come in all different sizes.And it’s recommended to support as many sizes as you canso that users have choice when placing their widgets.Remember that small variances do exist in sizing between devices,and it’s best to use system standard padding,margins, text styles, and text sizes when possible.

Now, if you look at this iPad,it’s really transformed into a content showcase.If it’s not obvious, a new size has been added in iOS 15specifically for the iPad, and we call it Extra Large.

Here it is so you can see it better.It’s the same height as the large widget but widerto showcase even more content that’s available on the iPad.And here’s how you add it to your widget.Here I’ve added it to an existing widget configthat already supports the systemLarge family.

By default, if you don’t specifysupported families on your widget configuration,then the new size will be supported automaticallyif you build with the iOS 15 SDK, or later.

The next axis for personalizationis the widget kind.Kinds of widgets offer different perspectivesinto your data or content.So think about what kinds of widgetsmight make the most sense in your app.The best way to describe these is really by example.Here’s an example from Clock.On the left, we have a City widgetthat tracks the time of a single city,and on the right, a World Clock widgetthat can accommodate many different citiesin the same view.Here’s another example from Stocks.On the left, there’s a stock Symbol widgetthat shows the stock price for a given stock--in this case, Apple--and on the right, an Overview widget.The Overview widget will show a series of stocksreflected in the user’s Stocks app.So how do you publish these different kinds of widgets?Well, to publish multiple kinds of widgets is super trivial.

Using that Stocks example from before,here I have a Symbol widget and an Overview widgetin the top left.To publish these, you just return the differentwidget configurations in a WidgetBundle objectand include the @main attribute to the WidgetBundle.It’s that easy.Note that the order that widgets are definedin the bundle is also very important.This order reflects how your widgetswill appear in the widget gallery.So make sure that the first widget listedis your hero use case.Lastly, it’s not possibleto dynamically publish or dynamically retractthe availability of a widget once your app is installed.So some care and thought should be appliedaround the support of your widgets over time.

The last axis for customizabilityis through configuration.And widgets support two types:static and Intent-based configurations.Static widget configurations deliverthe same content for each widget instance.Remember that Stocks Overview example from before?Well, each one’s gonna show the exact same contenteven if they’re in different locations on the user’s device.Static widgets are super simple,and they’re elegant widget definitions because they takeno configuration or setup from the user.

On the other hand, Intent widget configurationsdeliver user-configured content for each instance.Check out these Stock Symbol widgets on the right.This user has configured many different instances,each showcasing a different stock.Now, this is some pretty sweet stuff.And a user could even combine these all into a stackof widgets on their Home Screen to flip through to save space.

So how are these configured by the user, you might ask.Well, from a user’s perspective,the system will provide all the surrounding UI pieces.And after tapping on a widget in Edit modethat supports Intents,the configuration platter is shown.It presents a list of parameters from the Intentthat the user can configure.And in this example, there’s a single parameterfor the Symbol to track and its valueis currently the string AAPL for the Apple stock.Now, once a user taps on a parameter,an input controller appearsto collect the input from the user.And once completed, the widget will update automatically.Now, there’s a ton of customization that you can dowith an Intent, and there’s a great talkfrom WWDC 2020 that I’ll share in a moment to help youget started if you want an Intent configuration.In the meantime, let’s just quickly highlightwhat the differences are between coding a widgetbased on Intents versus a static configuration.

The static configuration’s really simple.You just instantiate a StaticConfiguration objectwith the standard TimelineProvider.Let’s contrast that with an Intent configuration.All that’s different here is that the StaticConfigurationis replaced by an IntentConfiguration,and the TimelineProvider is replacedby an IntentTimelineProvider.Each of these has a slightly modified interfaceto support Intents, and this is so you can receivethe user-configured Intent when populating your timeline.For a more detailed look at creating and configuringIntents for widgets, including an overviewon the various data types supportedand what they look like from the config UI,check out the “Add configuration and intelligenceto your widgets” talk from WWDC 2020.

To wrap up, we’ve reviewed how great widgetsmake use of their timeline entries,master their reload policy, and adapt to their presentationand potentially physical environments.Plan to offer different sizes, kinds,and configurations to give a dynamicand personalizable experience to your users.Thank you.

15:46 -Xcode Previews for Widget Views with Color Scheme Overrides

16:34 -Widget Partial Privacy Redactions - Banking Example

23:08 -WidgetBundle Example

25:43 -Static Widget Configuration Example

25:55 -Intent Widget Configuration Example

## Code Samples

```swift
struct
 
MyWidgetEntryView
 : 
View
 
{
    
var
 date: 
Date


    
var
 body: 
some
 
View
 {
        
ZStack
 {
            
Rectangle
().fill(
BackgroundStyle
())
            
VStack
 {
                
Text
(
"Hello"
)
            }
        }
    }
}


struct
 
MyWidget_Previews
: 
PreviewProvider
 
{
    
static
 
var
 previews: 
some
 
View
 {
        
MyWidgetEntryView
(date: 
Date
())
            .previewContext(
WidgetPreviewContext
(family: .systemSmall))
            .environment(\.colorScheme, .dark)
    }
}
```

```swift
struct
 
MyWidgetEntryView
 : 
View
 
{

    
var
 body: 
some
 
View
 {
        
ZStack
 {
            
Rectangle
().fill(
BackgroundStyle
())
            
VStack
(alignment: .leading) {
                
Text
(
"Balance"
)
                    .font(.largeTitle)
                    .fontWeight(.bold)
                    .foregroundColor(
Color
.blue)
                
Text
(
"$128.45"
)
                    .privacySensitive()
                    .font(.title2)
                    .foregroundColor(
Color
.gray)
            }
        }
    }
}
```

```swift
struct
 
IndividualSymbolWidget
 : 
Widget
 
{
    
var
 body: 
some
 
WidgetConfiguration
 {
    
…

}
}


struct
 
StocksOverviewWidget
 : 
Widget
 
{
    
var
 body: 
some
 
WidgetConfiguration
 {
    
…

    }
}


@main


struct
 
MyWidgetBundle
: 
WidgetBundle
 
{
    
var
 body: 
some
 
Widget
 {
        
// Order of these widgets defines the order in the Widget Gallery

        
IndividualSymbolWidget
()
        
StocksOverviewWidget
()
    }
}
```

```swift
@main


public
 
struct
 
SampleWidget
: 
Widget
 
{
    
public
 
var
 body: 
some
 
WidgetConfiguration
 {
        
StaticConfiguration
(kind: 
"com.sample.myStaticSampleWidgetKind"
,
                            provider: 
Provider
()) { entry 
in

                                
SampleWidgetEntryView
(entry: entry)
                            }
        .configurationDisplayName(
"My Widget"
)
        .description(
"This is an example widget."
)
    }
}


public
 
struct
 
Provider
: 
TimelineProvider
 
{
    
public
 
func
 
timeline
(
with
 
context
: 
Context
,
                         
completion
: 
@escaping
 (
Timeline
<
Entry
>) -> ())
 {
        
let
 entry 
=
 
SimpleEntry
(date: 
Date
())
        
// 
TODO:
 Generate a timeline entry

        completion(timeline)
    }
}
```

```swift
@main


public
 
struct
 
SampleWidget
: 
Widget
 
{
    
public
 
var
 body: 
some
 
WidgetConfiguration
 {
        
IntentConfiguration
(kind: 
"com.sample.myIntentSampleWidgetKind"
,
                            intent: 
SampleConfigurationIntent
.
self

                            provider: 
Provider
()) { entry 
in

                                
SampleWidgetEntryView
(entry: entry)
                            }
        .configurationDisplayName(
"My Widget"
)
        .description(
"This is an example widget."
)
    }
}


public
 
struct
 
Provider
: 
IntentTimelineProvider
 
{
    
public
 
func
 
timeline
(
for
 
configuration
: 
SampleConfigurationIntent
, 
with
 
context
: 
Context
,
                         
completion
: 
@escaping
 (
Timeline
<
Entry
>) -> ())
 {
        
let
 entry 
=
 
SimpleEntry
(date: 
Date
(), configuration: configuration)
        
// generate a timeline

        completion(timeline)
    }
}
```


# Wwdc2021 10223

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Create accessible experiences for watchOSDiscover how you can build a top-notch accessibility experience for watchOS when you support features like larger text sizes, VoiceOver, and AssistiveTouch. We'll take you through adding visual and motor accessibility support to a SwiftUI app built for watchOS, including best practices around API integration, experience, and more.ResourcesAccessibility for DevelopersCreate accessible experiences for watchOSHD VideoSD VideoRelated VideosWWDC21SwiftUI Accessibility: Beyond the basicsTuesday@WWDC21WWDC20Make your app visually accessibleWWDC19Accessibility in SwiftUI

Discover how you can build a top-notch accessibility experience for watchOS when you support features like larger text sizes, VoiceOver, and AssistiveTouch. We'll take you through adding visual and motor accessibility support to a SwiftUI app built for watchOS, including best practices around API integration, experience, and more.

Accessibility for Developers

Create accessible experiences for watchOS

HD VideoSD Video

HD Video

SD Video

SwiftUI Accessibility: Beyond the basics

Tuesday@WWDC21

Make your app visually accessible

Accessibility in SwiftUI

Search this video…♪ Bass music playing ♪♪Daniel Sykes-Turner: Hi, my name is Daniel Sykes-Turnerand I'm an accessibility engineer.In this talk, my colleague Virata and Iare going to go oversome of the accessibility features on watchOSand how you as a developer can build your watch appsto support the people who use these features.In today's talk,you'll first be introduced to accessibility on watchOS.Then I'll dive into the accessibility APIsand show you what you can do to supportdifferent types of visual accessibility.And finally, Virata will walk you throughhow motor accessibility works on the watchand what you can do to support it.Let's get started with accessibility on watchOS.Accessibility is about people using their devicesin the way that's best for them.And that means, to give your app the best user experience,accessibility must be considered.On the Apple Watch, we have a large suite of accessibility featuresthat can make using your app easier.For example, assistive technologies such as VoiceOverallow people with visual impairmentsfull use of their Apple Watchby navigating a screen using a series of gestures and tapswhile content is read back to them.And brand new on watchOS this year is AssistiveTouch,which has been reimaginedspecifically for the Apple Watch.AssistiveTouch allows those with motor impairmentsto use their Apple Watchwithout the need to touch the screen at all.Virata will show you how this works later onand what you can do to support it.watchOS also offers several display accommodationssuch as Reduce Motion, Bold Text,and also new this year, large accessibility text sizes.Let's talk about visual accessibility on watchOS.Supporting accessibility with the right APIs will ensurethat VoiceOver functions correctly for your users,regardless of whether your app is writtenwith WatchKit or SwiftUI.This talk will focus on accessibility for SwiftUI.However, know that all the principles you learn herewill apply to WatchKit as well.And when making your apps accessible,don't forget about complications and notifications.Complications and dynamic notificationsalso need to support our assistive technologies,as they act as another pathdelivering content from your app.Now, isn't the best way to learn something newto build an app?Luckily I've become quite investedin growing plants at home so I decided to go aheadand build an app to help take care of them.Now, it's not quite finished, but on the main screen hereI have all the information on my plants,including an upcoming schedule of plant care tasks:water in five days, fertilize in seven days,and keep in a medium amount of sunlight.I have a few other plants in the list here, too.Then for each plant, I have two buttons that I can useto log a task such as when I water or fertilize.And by tapping on the cell, I can adjust the number of daysbetween watering and fertilizing.Since this is an informative app,each cell contains a fair amount of text.Here I'm showing you what the app looks likewhen the system text size is at its default size;it looks pretty good.But if I change the system text size to extra small,as shown on the left, you'll notice thatwhile the buttons and the task list text resizes,the plant name title stays the same size.Then when I move up to accessibility extra largeon the right, the task list text sizehas grown so large that it has truncatedand no longer fits all the information on the screen.Let's take a look at how our app can better supportDynamic Type.If I inspect the code for my PlantView,I have a VStack with the title and other content inside.Notice the font I've used for my titleis using a fixed font size.That's definitely going to stop my title from changing size.Rather than using a fixed font size,I should be using one of the 11 text styles provided.The text styles on the left are displayedat the default system text size.And when scaled up to the largest text size,they grow to the size of the text styles on the right.By using a text style,the system will automatically adjust the font sizewith the system text size settings.So if I take a look at my PlantView code again,I can make that change quickly and easilyby changing my title font to the title3 text stylefor a smaller-sized title.Next let's fix the truncating text in the task list.In the code for my PlantTaskLabel,I'm assigning a lineLimit of 1 to everything in the HStack,which only allows the text to expand over a single line.To give your UI the flexibility to adjustto as many lines as needed, set the lineLimitto the maximum number of lines you need to support.Or remove it to allow an unlimited number of lines.Now we're making progress.But while the UI certainly is largerand there's no more truncation,in the process it's become a lot more crowded.And it's still not easy to read the information on the screen.Sometimes layouts for larger text stylesjust need to be structured differently.So when building the layout, I'll createan Environment property wrapper on the sizeCategoryto get updates whenever this changes.Next, I just need to adjust my UIto depend on the sizeCategory.In this case, the text in the task liststarts wrapping somewhere around extraExtraLarge.So if the size category is less than this,I'll use the PlantView we've seen before.But if it's larger, I'll use this new vertical plant viewthat stacks each of my labels and buttons,giving them much more space to grow.That looks much better.With the introduction of large accessibility text styleson the watch, we expect to see a lot more peoplemaking use of Dynamic Type --and so should you!For people setting up their Apple Watch,they will now see the option to customize the text sizewhen getting started.And if they don't make any changes,the watch will automatically pickthe closest size to what is used on the phone.So to recap Dynamic Type, there are three key thingsto make sure watch apps behave greatwith larger text sizes.First, you want to make sure to always use a text style,not a fixed font size.Second, allow your text to wrap to avoid truncating.And third, when necessary,switch to a vertically stacked layoutwhen the content becomes too crowded.Since this only scratches the surface on large text,I'd strongly recommend you check out the talk,"Building apps with Dynamic Type"to really step up your game.And to learn even more about making great visual experiences,be sure to check out the talk,"Make your app visually accessible."OK, so visually, that works great.But what if I weren't a visual user?Let's turn on VoiceOverand have a listen to what the experience is like.VoiceOver: WWDaisy.Daisy, image.Drop, image.Five days.Leaf, image.Seven days.Brightness higher, image.Medium.Drop, fill, button.Leaf, fill, button.Daniel: OK, so there are definitelysome improvements we can make.The first would be to reduce the number of elementsthat can be interacted with.At the moment, this is a rather complex view.Each cell has four labels, four images, and two buttons.And currently, to get to the second plant,I have to navigate past every item in the first plant cell.Also the image icons for water, fertilize, and sunlightwere read out as separate elements to the text,and their labels didn't even make sense for our context.Lastly, the two buttons at the bottomwere using the default labelsprovided by the symbols being used.So the first issue we talked aboutis that I have to navigate through too many itemsjust to move from plant one to plant two.When I created my NavigationLink,I did this by specifyingaccessibilityElement grouping of the children as .contain,just to understand the accessibility stateof each element.But since this is looking good,I'll remove this line, and NavigationLinkwill combine all the accessibility informationfrom the children automatically.Now the cell is treated as a single elementand the content read out is, "WWDaisy. Five days.Seven days. Medium. Button."That task list still needs some work so next,let's provide some context to the upcoming plant-care tasksby giving each a better label.The label is determined by the PlantTask.So inside my PlantTaskLabel struct,I'll just alter the accessibilityLabelto return a different string for each plant task.This is the same technique that I'll useto put labels on my buttons.Now the content is read out as,"WWDaisy. Watering in five days. Fertilizing in seven days.Keep in medium sunlight. Button."And the water and fertilize buttons will be read out as,"Log watering, button" and, "Log fertilizing, button."So far, a lot of work is done for us automatically,with only a few additional modifiers being needed.In fact, with SwiftUI,most of your accessibility comes for free.You'll probably just write a few lines of code.But every now and then,you might need to build a custom control.I did by building a custom counterso that I could adjust the wateringand fertilizing frequency for my plants.Let's take a look.VoiceOver: Watering frequency in days, heading.Remove, button.Eight.Add, button. Add.Daniel: So while this technically works,it's not the ideal experience.The goal here is to turn these three itemsinto a single accessible element.To do this, I'll begin by usingour accessibilityElement modifier.This will create a new higher-level element;but this time, I will ignore all the children.This is actually the default behaviorfor accessibilityElement.So I can leave the parameters blankto get the same behavior.And because I'm ignoring the children,this discards the Add and Remove button labelsalong with the accessibility actionsthat were provided automatically.Instead, I'll use accessibilityAdjustableActionto allow the user to increment or decrement the valueby swiping up or down on the counter.And now that I've only got one element,I'll give it a single label using the name of the task.This will end up as "Watering Frequency"or "Fertilizing Frequency."Finally, I'll give it a value.The accessibilityValue is read out each time it changes,while the label will only be read outwhen navigating to the element.VoiceOver: Watering frequency in days, heading.Watering frequency. Eight days. Adjustable.Nine days.Daniel: Great. That works much better.As you just saw, SwiftUI made it easyto make our watch app accessible to VoiceOver.And what's great is that because this is SwiftUI,the same code works on macOS and iOS as well.To learn more about designinga fantastic experience with SwiftUI,be sure to check out the talk, "Accessibility in SwiftUI."And to learn about the brand-new tools and APIs when workingwith SwiftUI accessibility, check out the talk,"SwiftUI accessibility: Beyond the basics."Now, before we move on from visual accessibility,I'd like to highlight two more things:complications and notifications.Complications are a high-traffic window into your app,so, of course, they also need to provide informationin an accessible way.There are many different types of complicationsbut most of them will be made upof three different components: text, images, and symbols.Text will be picked up by VoiceOver automatically,but if your text contains abbreviations,make sure to add accessibility labelswith the nonabbreviated versions.Here we expand the abbreviated, "Wednesday Mar 9"to its full form of, "Wednesday, March 9th."Image-based complications are also very common.Be sure to provide accessibility labels here too;otherwise, the image name will be used instead."Moon" isn't nearly as descriptive as,"A real-time view of the moon. Third quarter."Certain iconography such as SF Symbolsmay come with a default accessibility labelsuch as "Drop, fill", but just make surethat the label that comes with the symbolis the one that makes the most sense for you."Water in three days" makes much more sense for me.As for notifications, these are another way your appmay send a lot of information to your user.So while some notifications are fairly straightforward,others such as dynamic notificationscan have complex viewsand so will need the same accessibility supportthat you've provided for your app.And now I'll turn you over to Viratato tell you all about motor accessibility.Virata Yindeeyoungyeon: Well, thank you, Daniel.My name is Virata Yindeeyoungyeon.I am an engineer on the Accessibility team.Today, I am very excited to talk aboutmotor-accessibility support on Apple Watch.But before we dive into the presentation,let me give you a quick glance of our new feature.Without touching the screen and only using hand gesture,I am able to navigate from the watch faceto the Control Center to the Do Not Disturb button,and then turn it on.It is that simple.This year, we are very excitedto bring AssistiveTouch to Apple Watch.AssistiveTouch allows full use of your Apple Watchwithout touch,using only the hand that the Apple Watch is on.People can use hand gestures or hand motionsto navigate a cursor around the screen.They can bring up a menu to access additional functionalitybased on the screen content.For some people, this may be the only waythey can interact with their Apple Watch.For people with motor impairmentssuch as missing limbs, loss of functions of hands or arms,AssistiveTouch will enable more optionsto allow control and performing actions on Apple Watch.Now let's see an exampleon how people can use AssistiveTouch.The primary way to use AssistiveTouchis through hand gestures.People are able to perform different gesturesuch as clench to tap,double-clench to bring up the action menu,pinch to navigate to the next element,double-pinch to navigate back to the previous element.For those who are not able to use hand gestures,an alternative is using hand motions.By tilting their wrist, people are ableto move the onscreen pointer and interact with the UI elements.Similar to AssistiveTouch on iOS,with Dwell Control you can perform an actionby resting the pointer over an elementfor a set amount of time.Now let's get into more detail on how AssistiveTouch works.AssistiveTouch is made up of two main features:the cursor and the action menu.When you turn on AssistiveTouch,you see a cursor appear on the screen.The cursor will focus on each element on the screenone at a time, in order from top left to bottom right.The cursor highlights the elementfor further interactions.For more actions on the focused element,you can bring up the action menuto perform system or custom actions.AssistiveTouch action menu comes withdefault system actions that allow control of the devicesuch as pressing on the Digital Crown,scrolling navigation, gesture interactions,and much more.You can also add custom actions to this menu as well.So now we know how AssistiveTouch works.Let's take a look at how we can support it in your application.We'll go over these following topics.First, we'll learn what focusable elements arein your view and how we can modify them.Then we'll take a look at the cursor frameand how we can change the frame size.Last, we'll talk more about how to customize the action menu.Let's begin with focusable elements.This table gives a general overviewof which elements are focusable by AssistiveTouch.Only interactive elements that respondto user interaction are focusable.SwiftUI provides built-in control elementsto handle user interactions;these elements are interactive and focusable.In your view, if you have a button,a toggle, or a NavigationLink,these elements can be focused by default.Actionable elements are focusable by AssistiveTouchbecause they have an action or are defined to be interactive.A text element can become interactive and focusableby attaching a tap gesture action.You can also add an accessibilityActionto an element as well.If you define an element to have an actionable trait,like a button or adjustable,then it will be treated as interactiveand would be focused by AssistiveTouch.Some elements are not focusable.Static elements such as a label or a textthat do not respond to user interactionwill not be focusable by AssistiveTouch.Elements with user interaction disabled are also not focusable.So let's see an example.In this view, we have a label header,text with drink information,Accept and Cancel button elements.Only the two buttons are focusable,while the label and text are not.Let's take a look at the code for this view.A tap gesture is attached to the main VStack,indicating that you can tap on this viewto show the drink detailed view.However, the static elements inside the VStackdo not become focusable unless explicitly declared.Here, only the Accept and Cancel buttons are focusable.So how would a user know that they can tap on the viewto show the drink detail view?To provide a better user experience,I would like to highlight the drink information text elementto show that it is interactable and a tap can be performed.This can be done by setting "true" toaccessibilityRespondsToUser Interaction modifier.After applying the modifier,we now have three focusable elements in this view:the drink information text,Accept and Cancel button elements.Now let's learn more about AssistiveTouch cursor frame.As you can see, the focused elementsare important for AssistiveTouch to highlight if the elementis intractable or an action can be performed.The AssistiveTouch cursor frameis the same as the element's tappable area;elements with small tappable areawill have a small cursor frameand it might clip the content inside.We can make this cleaner by adding paddingand having the borders match the shape of the objectto prevent clipping.In this example,a NavigationLink with the ellipsis imageis highlighted with a small circlefrom the AssistiveTouch cursor.We can improve on thisby increasing the size of the tappable area,which also changes the AssistiveTouch cursor frame.By providing a path to the contentShape modifier,you can change the tappable areaand the cursor frame of the element.For this NavigationLink, I set the tappable area shapeto be a circle one-and-a-half times the size of the element.As a result, the AssistiveTouch cursor frame is largerand the element is much easier to see on the screen.Now let's take a look at AssistiveTouch action menu.AssistiveTouch action menusurfaces default system actions and custom actions in your viewto show in the action menu lists.If the focus element has custom actions,those actions will be prioritizedand shown at the beginning of the listso it's more convenient to interact.If the element is adjustable,the decrement and increment actions are shown.If an accessibility group element contains custom actions,then those actions will be surfacedwhen focusing on the group element.If you have already added custom actions for VoiceOverin the element, that's great!These actions will automatically show upin the AssistiveTouch action menu as well.The custom actions will be shown as an icon.The default image will bethe first letter of the custom action name.If you want to provide an image for your custom action icon,you can add a label with an imageto the accessibilityAction modifier.Well, that's the end of our session.Now you have a better understandingof accessibility features on Apple Watch.Remember to add Dynamic Type, VoiceOver,and AssistiveTouch support in your application.You have the tools to use these APIsand make your watchOS applicationaccessible for everyone.Well, thank you for your time and enjoy the rest of WWDC!♪

♪ Bass music playing ♪♪Daniel Sykes-Turner: Hi, my name is Daniel Sykes-Turnerand I'm an accessibility engineer.In this talk, my colleague Virata and Iare going to go oversome of the accessibility features on watchOSand how you as a developer can build your watch appsto support the people who use these features.In today's talk,you'll first be introduced to accessibility on watchOS.Then I'll dive into the accessibility APIsand show you what you can do to supportdifferent types of visual accessibility.And finally, Virata will walk you throughhow motor accessibility works on the watchand what you can do to support it.Let's get started with accessibility on watchOS.Accessibility is about people using their devicesin the way that's best for them.And that means, to give your app the best user experience,accessibility must be considered.On the Apple Watch, we have a large suite of accessibility featuresthat can make using your app easier.For example, assistive technologies such as VoiceOverallow people with visual impairmentsfull use of their Apple Watchby navigating a screen using a series of gestures and tapswhile content is read back to them.And brand new on watchOS this year is AssistiveTouch,which has been reimaginedspecifically for the Apple Watch.AssistiveTouch allows those with motor impairmentsto use their Apple Watchwithout the need to touch the screen at all.Virata will show you how this works later onand what you can do to support it.watchOS also offers several display accommodationssuch as Reduce Motion, Bold Text,and also new this year, large accessibility text sizes.Let's talk about visual accessibility on watchOS.Supporting accessibility with the right APIs will ensurethat VoiceOver functions correctly for your users,regardless of whether your app is writtenwith WatchKit or SwiftUI.This talk will focus on accessibility for SwiftUI.However, know that all the principles you learn herewill apply to WatchKit as well.And when making your apps accessible,don't forget about complications and notifications.Complications and dynamic notificationsalso need to support our assistive technologies,as they act as another pathdelivering content from your app.Now, isn't the best way to learn something newto build an app?Luckily I've become quite investedin growing plants at home so I decided to go aheadand build an app to help take care of them.Now, it's not quite finished, but on the main screen hereI have all the information on my plants,including an upcoming schedule of plant care tasks:water in five days, fertilize in seven days,and keep in a medium amount of sunlight.I have a few other plants in the list here, too.Then for each plant, I have two buttons that I can useto log a task such as when I water or fertilize.And by tapping on the cell, I can adjust the number of daysbetween watering and fertilizing.Since this is an informative app,each cell contains a fair amount of text.Here I'm showing you what the app looks likewhen the system text size is at its default size;it looks pretty good.But if I change the system text size to extra small,as shown on the left, you'll notice thatwhile the buttons and the task list text resizes,the plant name title stays the same size.Then when I move up to accessibility extra largeon the right, the task list text sizehas grown so large that it has truncatedand no longer fits all the information on the screen.Let's take a look at how our app can better supportDynamic Type.If I inspect the code for my PlantView,I have a VStack with the title and other content inside.Notice the font I've used for my titleis using a fixed font size.That's definitely going to stop my title from changing size.Rather than using a fixed font size,I should be using one of the 11 text styles provided.The text styles on the left are displayedat the default system text size.And when scaled up to the largest text size,they grow to the size of the text styles on the right.By using a text style,the system will automatically adjust the font sizewith the system text size settings.So if I take a look at my PlantView code again,I can make that change quickly and easilyby changing my title font to the title3 text stylefor a smaller-sized title.Next let's fix the truncating text in the task list.In the code for my PlantTaskLabel,I'm assigning a lineLimit of 1 to everything in the HStack,which only allows the text to expand over a single line.To give your UI the flexibility to adjustto as many lines as needed, set the lineLimitto the maximum number of lines you need to support.Or remove it to allow an unlimited number of lines.Now we're making progress.But while the UI certainly is largerand there's no more truncation,in the process it's become a lot more crowded.And it's still not easy to read the information on the screen.Sometimes layouts for larger text stylesjust need to be structured differently.So when building the layout, I'll createan Environment property wrapper on the sizeCategoryto get updates whenever this changes.Next, I just need to adjust my UIto depend on the sizeCategory.In this case, the text in the task liststarts wrapping somewhere around extraExtraLarge.So if the size category is less than this,I'll use the PlantView we've seen before.But if it's larger, I'll use this new vertical plant viewthat stacks each of my labels and buttons,giving them much more space to grow.That looks much better.With the introduction of large accessibility text styleson the watch, we expect to see a lot more peoplemaking use of Dynamic Type --and so should you!For people setting up their Apple Watch,they will now see the option to customize the text sizewhen getting started.And if they don't make any changes,the watch will automatically pickthe closest size to what is used on the phone.So to recap Dynamic Type, there are three key thingsto make sure watch apps behave greatwith larger text sizes.First, you want to make sure to always use a text style,not a fixed font size.Second, allow your text to wrap to avoid truncating.And third, when necessary,switch to a vertically stacked layoutwhen the content becomes too crowded.Since this only scratches the surface on large text,I'd strongly recommend you check out the talk,"Building apps with Dynamic Type"to really step up your game.And to learn even more about making great visual experiences,be sure to check out the talk,"Make your app visually accessible."OK, so visually, that works great.But what if I weren't a visual user?Let's turn on VoiceOverand have a listen to what the experience is like.

VoiceOver: WWDaisy.Daisy, image.Drop, image.Five days.Leaf, image.Seven days.Brightness higher, image.Medium.Drop, fill, button.Leaf, fill, button.Daniel: OK, so there are definitelysome improvements we can make.The first would be to reduce the number of elementsthat can be interacted with.At the moment, this is a rather complex view.Each cell has four labels, four images, and two buttons.And currently, to get to the second plant,I have to navigate past every item in the first plant cell.Also the image icons for water, fertilize, and sunlightwere read out as separate elements to the text,and their labels didn't even make sense for our context.Lastly, the two buttons at the bottomwere using the default labelsprovided by the symbols being used.So the first issue we talked aboutis that I have to navigate through too many itemsjust to move from plant one to plant two.When I created my NavigationLink,I did this by specifyingaccessibilityElement grouping of the children as .contain,just to understand the accessibility stateof each element.But since this is looking good,I'll remove this line, and NavigationLinkwill combine all the accessibility informationfrom the children automatically.Now the cell is treated as a single elementand the content read out is, "WWDaisy. Five days.Seven days. Medium. Button."That task list still needs some work so next,let's provide some context to the upcoming plant-care tasksby giving each a better label.The label is determined by the PlantTask.So inside my PlantTaskLabel struct,I'll just alter the accessibilityLabelto return a different string for each plant task.This is the same technique that I'll useto put labels on my buttons.Now the content is read out as,"WWDaisy. Watering in five days. Fertilizing in seven days.Keep in medium sunlight. Button."And the water and fertilize buttons will be read out as,"Log watering, button" and, "Log fertilizing, button."So far, a lot of work is done for us automatically,with only a few additional modifiers being needed.In fact, with SwiftUI,most of your accessibility comes for free.You'll probably just write a few lines of code.But every now and then,you might need to build a custom control.I did by building a custom counterso that I could adjust the wateringand fertilizing frequency for my plants.Let's take a look.VoiceOver: Watering frequency in days, heading.Remove, button.Eight.Add, button. Add.Daniel: So while this technically works,it's not the ideal experience.The goal here is to turn these three itemsinto a single accessible element.To do this, I'll begin by usingour accessibilityElement modifier.This will create a new higher-level element;but this time, I will ignore all the children.This is actually the default behaviorfor accessibilityElement.So I can leave the parameters blankto get the same behavior.And because I'm ignoring the children,this discards the Add and Remove button labelsalong with the accessibility actionsthat were provided automatically.Instead, I'll use accessibilityAdjustableActionto allow the user to increment or decrement the valueby swiping up or down on the counter.And now that I've only got one element,I'll give it a single label using the name of the task.This will end up as "Watering Frequency"or "Fertilizing Frequency."Finally, I'll give it a value.The accessibilityValue is read out each time it changes,while the label will only be read outwhen navigating to the element.

VoiceOver: Watering frequency in days, heading.Watering frequency. Eight days. Adjustable.Nine days.Daniel: Great. That works much better.As you just saw, SwiftUI made it easyto make our watch app accessible to VoiceOver.And what's great is that because this is SwiftUI,the same code works on macOS and iOS as well.To learn more about designinga fantastic experience with SwiftUI,be sure to check out the talk, "Accessibility in SwiftUI."And to learn about the brand-new tools and APIs when workingwith SwiftUI accessibility, check out the talk,"SwiftUI accessibility: Beyond the basics."Now, before we move on from visual accessibility,I'd like to highlight two more things:complications and notifications.Complications are a high-traffic window into your app,so, of course, they also need to provide informationin an accessible way.There are many different types of complicationsbut most of them will be made upof three different components: text, images, and symbols.Text will be picked up by VoiceOver automatically,but if your text contains abbreviations,make sure to add accessibility labelswith the nonabbreviated versions.Here we expand the abbreviated, "Wednesday Mar 9"to its full form of, "Wednesday, March 9th."Image-based complications are also very common.Be sure to provide accessibility labels here too;otherwise, the image name will be used instead."Moon" isn't nearly as descriptive as,"A real-time view of the moon. Third quarter."Certain iconography such as SF Symbolsmay come with a default accessibility labelsuch as "Drop, fill", but just make surethat the label that comes with the symbolis the one that makes the most sense for you."Water in three days" makes much more sense for me.As for notifications, these are another way your appmay send a lot of information to your user.So while some notifications are fairly straightforward,others such as dynamic notificationscan have complex viewsand so will need the same accessibility supportthat you've provided for your app.And now I'll turn you over to Viratato tell you all about motor accessibility.Virata Yindeeyoungyeon: Well, thank you, Daniel.My name is Virata Yindeeyoungyeon.I am an engineer on the Accessibility team.Today, I am very excited to talk aboutmotor-accessibility support on Apple Watch.But before we dive into the presentation,let me give you a quick glance of our new feature.Without touching the screen and only using hand gesture,I am able to navigate from the watch faceto the Control Center to the Do Not Disturb button,and then turn it on.It is that simple.This year, we are very excitedto bring AssistiveTouch to Apple Watch.AssistiveTouch allows full use of your Apple Watchwithout touch,using only the hand that the Apple Watch is on.People can use hand gestures or hand motionsto navigate a cursor around the screen.They can bring up a menu to access additional functionalitybased on the screen content.For some people, this may be the only waythey can interact with their Apple Watch.For people with motor impairmentssuch as missing limbs, loss of functions of hands or arms,AssistiveTouch will enable more optionsto allow control and performing actions on Apple Watch.Now let's see an exampleon how people can use AssistiveTouch.The primary way to use AssistiveTouchis through hand gestures.People are able to perform different gesturesuch as clench to tap,double-clench to bring up the action menu,pinch to navigate to the next element,double-pinch to navigate back to the previous element.For those who are not able to use hand gestures,an alternative is using hand motions.By tilting their wrist, people are ableto move the onscreen pointer and interact with the UI elements.Similar to AssistiveTouch on iOS,with Dwell Control you can perform an actionby resting the pointer over an elementfor a set amount of time.

Now let's get into more detail on how AssistiveTouch works.AssistiveTouch is made up of two main features:the cursor and the action menu.When you turn on AssistiveTouch,you see a cursor appear on the screen.The cursor will focus on each element on the screenone at a time, in order from top left to bottom right.The cursor highlights the elementfor further interactions.For more actions on the focused element,you can bring up the action menuto perform system or custom actions.AssistiveTouch action menu comes withdefault system actions that allow control of the devicesuch as pressing on the Digital Crown,scrolling navigation, gesture interactions,and much more.You can also add custom actions to this menu as well.So now we know how AssistiveTouch works.Let's take a look at how we can support it in your application.We'll go over these following topics.First, we'll learn what focusable elements arein your view and how we can modify them.Then we'll take a look at the cursor frameand how we can change the frame size.Last, we'll talk more about how to customize the action menu.Let's begin with focusable elements.This table gives a general overviewof which elements are focusable by AssistiveTouch.Only interactive elements that respondto user interaction are focusable.SwiftUI provides built-in control elementsto handle user interactions;these elements are interactive and focusable.In your view, if you have a button,a toggle, or a NavigationLink,these elements can be focused by default.Actionable elements are focusable by AssistiveTouchbecause they have an action or are defined to be interactive.A text element can become interactive and focusableby attaching a tap gesture action.You can also add an accessibilityActionto an element as well.If you define an element to have an actionable trait,like a button or adjustable,then it will be treated as interactiveand would be focused by AssistiveTouch.Some elements are not focusable.Static elements such as a label or a textthat do not respond to user interactionwill not be focusable by AssistiveTouch.Elements with user interaction disabled are also not focusable.So let's see an example.In this view, we have a label header,text with drink information,Accept and Cancel button elements.Only the two buttons are focusable,while the label and text are not.Let's take a look at the code for this view.A tap gesture is attached to the main VStack,indicating that you can tap on this viewto show the drink detailed view.However, the static elements inside the VStackdo not become focusable unless explicitly declared.Here, only the Accept and Cancel buttons are focusable.So how would a user know that they can tap on the viewto show the drink detail view?To provide a better user experience,I would like to highlight the drink information text elementto show that it is interactable and a tap can be performed.This can be done by setting "true" toaccessibilityRespondsToUser Interaction modifier.After applying the modifier,we now have three focusable elements in this view:the drink information text,Accept and Cancel button elements.Now let's learn more about AssistiveTouch cursor frame.As you can see, the focused elementsare important for AssistiveTouch to highlight if the elementis intractable or an action can be performed.The AssistiveTouch cursor frameis the same as the element's tappable area;elements with small tappable areawill have a small cursor frameand it might clip the content inside.We can make this cleaner by adding paddingand having the borders match the shape of the objectto prevent clipping.In this example,a NavigationLink with the ellipsis imageis highlighted with a small circlefrom the AssistiveTouch cursor.We can improve on thisby increasing the size of the tappable area,which also changes the AssistiveTouch cursor frame.By providing a path to the contentShape modifier,you can change the tappable areaand the cursor frame of the element.For this NavigationLink, I set the tappable area shapeto be a circle one-and-a-half times the size of the element.As a result, the AssistiveTouch cursor frame is largerand the element is much easier to see on the screen.Now let's take a look at AssistiveTouch action menu.AssistiveTouch action menusurfaces default system actions and custom actions in your viewto show in the action menu lists.If the focus element has custom actions,those actions will be prioritizedand shown at the beginning of the listso it's more convenient to interact.If the element is adjustable,the decrement and increment actions are shown.If an accessibility group element contains custom actions,then those actions will be surfacedwhen focusing on the group element.If you have already added custom actions for VoiceOverin the element, that's great!These actions will automatically show upin the AssistiveTouch action menu as well.The custom actions will be shown as an icon.The default image will bethe first letter of the custom action name.If you want to provide an image for your custom action icon,you can add a label with an imageto the accessibilityAction modifier.Well, that's the end of our session.Now you have a better understandingof accessibility features on Apple Watch.Remember to add Dynamic Type, VoiceOver,and AssistiveTouch support in your application.You have the tools to use these APIsand make your watchOS applicationaccessible for everyone.Well, thank you for your time and enjoy the rest of WWDC!♪

4:48 -Dynamic Type for PlantView

5:00 -Line limits for PlantTaskLabel

5:48 -Alternate layouts for PlantContainerView

8:56 -Element grouping for PlantCellView

9:38 -Accessibility labels for PlantTaskLabel

10:03 -Accessibility labels for PlantButton

11:07 -Custom control accessibility for PlantTaskFrequency

19:50 -Make static element focusable

21:12 -AssistiveTouch cursor frame

22:48 -AssistiveTouch Action Menu

## Code Samples

```swift
struct
 
PlantView
: 
View
 
{
    
@Binding
 
var
 plant: 
Plant

    
    
var
 body: 
some
 
View
 {
        
VStack
(alignment: .leading) {
            
Text
(plant.name)
                .font(.title3)
            
HStack
() {
                
PlantImage
(plant: plant)
                
PlantTaskList
(plant: 
$plant
)
            }
            
PlantTaskButtons
(plant: 
$plant
)
        }
    }
}
```

```swift
struct
 
PlantTaskLabel
: 
View
 
{
    
let
 task: 
PlantTask

    
@Binding
 
var
 plant: 
Plant


    
var
 body: 
some
 
View
 {
        
HStack
 {
            
Image
(systemName: task.systemImageName)
                .imageScale(.small)
            
Text
(plant.stringForTask(task: task))
        }
        .lineLimit(
3
)
        .font(.caption2)
    }
}
```

```swift
struct
 
PlantContainerView
: 
View
 
{
    
@Environment
(\.sizeCategory) 
var
 sizeCategory
    
@Binding
 
var
 plant: 
Plant

    
    
var
 body: 
some
 
View
 {
        
if
 sizeCategory 
<
 .extraExtraLarge {
            
PlantViewHorizontal
(plant: 
$plant
)
        } 
else
 {
            
PlantViewVertical
(plant: 
$plant
)
        }
    }
}
```

```swift
struct
 
PlantCellView
: 
View
 
{
    
@EnvironmentObject
 
var
 plantData: 
PlantData

    
var
 plant: 
Plant

    
    
var
 plantIndex: 
Int
 {
        plantData.plants.firstIndex(where: { 
$0
.id 
==
 plant.id })
!

    }
    
    
var
 body: 
some
 
View
 {
        
NavigationLink
(destination: 
PlantEditView
(plant: plant).environmentObject(plantData)) {
            
PlantContainerView
(plant: 
$plantData
.plants[plantIndex])
                .padding()
        }
    }
}
```

```swift
struct
 
PlantTaskLabel
: 
View
 
{
    
let
 task: 
PlantTask

    
@Binding
 
var
 plant: 
Plant


    
var
 body: 
some
 
View
 {
        
HStack
 {
            
Image
(systemName: task.systemImageName)
                .imageScale(.small)
            
Text
(plant.stringForTask(task: task))
                .accessibilityLabel(plant.accessibilityStringForTask(task: task))
        }
        .lineLimit(
3
)
        .font(.caption2)
    }
}
```

```swift
struct
 
PlantButton
: 
View
 
{
    
let
 task: 
PlantTask

    
let
 action: () -> 
Void

    
@State
 
private
 
var
 isTapped: 
Bool
 
=
 
false

    
    
var
 body: 
some
 
View
 {
        
Button
(action: {
            
self
.isTapped.toggle()
            
DispatchQueue
.main.asyncAfter(deadline: .now() 
+
 
0.5
) {
                
self
.isTapped.toggle()
            }
            action()
        }) {
            
Image
(systemName: task.systemImageFillName)
                .foregroundColor(task.color)
                .scaleEffect(isTapped 
?
 
1.5
 : 
1
)
                .animation(
nil
, value: 
0
)
                .rotationEffect(.degrees(isTapped 
?
 
360
 : 
0
))
                .animation(.spring(), value: 
0
)
                .imageScale(.large)
        }
        .buttonStyle(
BorderedButtonStyle
())
        .accessibilityLabel(
"Log 
\(task.name)
"
)
    }
}
```

```swift
struct
 
PlantTaskFrequency
: 
View
 
{
    
let
 task: 
PlantTask

    
@Binding
 
var
 plant: 
Plant

    
let
 increment: () -> 
Void

    
let
 decrement: () -> 
Void

    
    
var
 value: 
Int
 {
        
switch
 task {
        
case
 .water:
            
return
 plant.wateringFrequency
        
case
 .fertilize:
            
return
 plant.fertilizingFrequency
        
default
:
            
return
 
0

        }
    }
    
    
var
 body: 
some
 
View
 {
        
Section
(header: 
Text
(
"
\(task.name)
 frequency in days"
), content: {
            
CustomCounter
(value: value, increment: increment, decrement: decrement)
                .accessibilityElement()
                .accessibilityAdjustableAction { direction 
in

                    
switch
 direction {
                    
case
 .increment:
                        increment()
                    
case
 .decrement:
                        decrement()
                    default:
                        
break

                    }
                }
                .accessibilityLabel(
"
\(task.name)
 frequency"
)
                .accessibilityValue(
"
\(value)
 days"
)
        })
    }
}
```

```swift
struct
 
FreeDrinkView
: 
View
 
{
    
@State
 
var
 didCancel 
=
 
false

    
@State
 
var
 didAccept 
=
 
false

    
@State
 
var
 showDetail 
=
 
false

    
    
var
 body: 
some
 
View
 {
        
VStack
(spacing:
10
) {
            
FreeDrinkTitleView
()
            
            
FreeDrinkInfoView
()
                .accessibilityRespondsToUserInteraction(
true
)
            
            
HStack
 {
                
CancelButton
(buttonTapped: 
$didCancel
)
                
AcceptButton
(buttonTapped: 
$didAccept
)
            }
        }
        .onTapGesture {
            showDetail.toggle()
        }
        .sheet(isPresented: 
$showDetail
, onDismiss: dismiss) {
            
DrinkDetailModalView
()
        }
    }
}
```

```swift
struct
 
DrinkView
: 
View
 
{
    
var
 currentDrink:
DrinkInfo

    
    
var
 body: 
some
 
View
 {
        
HStack
(alignment: .firstTextBaseline) {
            
DrinkInfoView
(drink:currentDrink)
            
            
Spacer
()
            
            
NavigationLink
(destination: 
EditView
()) {
                
Image
(systemName: 
"ellipsis"
)
                    .symbolVariant(.circle)
            }
            .contentShape(
Circle
().scale(
1.5
))
        }
    }
}
```

```swift
PlantContainerView
(plant: plant)
    .padding()
    .accessibilityElement(children: .combine)
    .accessibilityAction {
        
// Edit action

    } label: {
        
Label
(
"Edit"
, systemImage: 
"ellipsis.circle"
)
    }
```


# Wwdc2021 10182

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Sync files to the cloud with FileProvider on macOSFind out how you can use the FileProvider framework to build a comprehensive cloud sync solution. We'll show you how to approach building a file provider extension, and explore how you can effortlessly integrate your extension with file system features such as safe save, disk space management, Finder integration and more.ResourcesFile ProviderReplicated File Provider extensionSynchronizing files using file provider extensionsHD VideoSD VideoRelated VideosTech TalksBring desktop class sync to iOS with FileProvider

Find out how you can use the FileProvider framework to build a comprehensive cloud sync solution. We'll show you how to approach building a file provider extension, and explore how you can effortlessly integrate your extension with file system features such as safe save, disk space management, Finder integration and more.

File Provider

Replicated File Provider extension

Synchronizing files using file provider extensions

HD VideoSD Video

HD Video

SD Video

Bring desktop class sync to iOS with FileProvider

Search this video…♪ ♪Hi.I’m Johannes Fortmann from the Cloud File Providers team,and I’m here to show you file providers on macOS.If you’re a cloud storage vendor syncing your users’ filesto macOS, you’re in the right talk.After the introduction, we’re going to talk aboutsome of the user flows involved with syncing files.We’ll then run through one of the flows in Xcodeand discuss the orderin which you will implement support for each of them.We’ll have a quick overviewof additional optional integration pointsand your next steps.First off, let’s talk about what file providers can do for you.The File Provider framework allows you to integrateyour cloud storage into the file system on macOS.It uses new APFS features to allowon-demand downloads of user files and folders.The API is entirely in user space.We’re deprecating kernel extensions on macOS,so this is a good alternative for youif you were relying on FUSE or KAUTHto intercept syscalls or download files on demand.All you have to do is handle uploads,downloads, and tell us what changed remotely.The system will tell you what changed locallyand handle all the rest.All of this functionality is well integratedwith the system and in particular in Finder.Your provider will show up in the sidebar.File status will be shown and tracked in Finder,and there are several customizable integration pointswith the UI.You implement an app extensionthat integrates with the system.Its life cycle is driven by user actions.Initially, you create a domain which representsthe file tree that the user can access in your cloud storage.The system will expose that domainin the Finder sidebar and create a root directoryfor the domain in the file system.At this point, no actual data is on the device,but the user can already start interacting with the root.How does this work?The root is what we call a dataless directory.It’s a new kind of object in APFS,and there are APIs to recognize them and interact with them.But more importantly, dataless objects arefully transparent to processes who happen upon them unprepared.Reads trigger downloads,and files lose their dataless propertybefore the reads are allowed to resume.In this presentation, we will see how the File Providerframework allows you to implement callbacksthat get called when processes read dataless files.Let’s have a look at some user flowsto get sync up and running.We’re going to look at four key flows that coverboth sync down and sync up.In each flow, you’ll see that the systemcalls your extension whenever it needs new data.We’ll show you that you can talk to your cloud serverto pull that data and, finally,call a completion handler to reply.First, we’re going to look at what happenswhen a dataless file is read.When the kernel detects a read accessto a dataless file,that syscall is pausedwhile your extension is calledto fetch the contents of the file.Your extension’s fetchContents method is called.Typically, you will implement it to perform a download.When the download completes, it calls a completion handler.The contents of the file are handedto the system which fills in the formerly dataless filewithout invalidating the open file descriptor.The system then unpauses the read access.Now that the file is no longer dataless,subsequent reads won’t have to involve your extension.Enumerating a directory works very similarly.The kernel detects a readdir call and pauses it.It calls your extension to enumeratethe items in that directory.You fetch the metadata for these items from your server.And you reply with a number of items.The enumeration is paginated.You can return less than the full set of items,and the system will pick up enumeratingfrom where it left off.Once all pages have been enumerated,the system will allow the original call to go through.Like in the file case,once the directory has been enumerated,subsequent readdir calls will use the contentsfrom disk and not have to involve your extension.But what if those contents change remotely?Well, you will have to inform the system of the remote change.Let’s look at how that works.If there’s a remote change,your server can send a push notification to the Mac.In response to that push notification,you signal the systemthat there are changes that need to be enumeratedfrom a special enumerator, the .workingSet.The system will turn around and enumeratethe items that have changed in the .workingSet.A continuation token called the syncAnchoris used to enumerate only the new changes.This token is defined by your extension.The system keeps track of the syncAnchorit last enumerated to.It will call your enumeratorwith the enumerateChanges(from syncAnchor:) method.In response, you return changed items,and once you’re done, give us a new syncAnchorthat we can use next time around.The system will asynchronously goand update the user-visible files.We use an APFS compare-and-swap featurewhich makes sure that local changes aren’t lostin the process.Furthermore, the system integrateswith file coordinationand other advisory locking mechanismsto coordinate with applications.With these three mechanisms, we are able to sync filesfrom the cloud and keep them in syncin case of remote changes.The last flow deals with syncing up local changes to the cloud.The system detects when local items have changedand calls a modifyItem method on your extension,passing in the exact set of fields that have changed.It aggregates low-level events into eventsthat are meaningful for sync.For example, the kernel detects safe saves and remapsyour item identifiers to the new file IDs transparently.The system will also zip package files for you if you requestand present you with consistent package-level changes.In response to the modifyItem call,you will update the state of the item server-side.If the contents of the file have changed,the system will hand you a clone of the changed file so you canupload a consistent version even in the event of further changes.When done, you call a completion handler.The completion handler is used to update the version identifierof the item and confirms deliveryof the change to your extension.The completion handler also takes the final stateof the item as a parameter.Updating an item in the cloud may change its state,for example, if it conflicts with a remote change.Since you pass the final state back,the system is able to update the local stateof the item to match the truth in the cloud.There is a fifth flow: eviction.The system will evict local files automaticallyand without involving your file provider extensionwhen there is an urgent need for disk space.That might happen, for example,when the user is recording a videoor downloading a software update.The system will evict the minimum setof least recently used files necessary to free upthe disk space required to write those new files.Let’s review the transitions.Eviction turns a local file into a dataless file,and download turns a dataless file into a local file.Files can start dataless if they are created remotelyor not if they are created locally.But not all files can be evicted.The system will only evict a filethat you report as uploadedso that it can be downloaded again.So there really are two sorts of local files:uploaded and non-uploaded files.After a local edit, the new version of the fileneeds to be uploaded, so we’re back in a non-evictable state.In this presentation so far,we have seen how your file provider extension is invokedby the system to download files upon accessand to upload files after local edits.While you’re not involvedin disk-pressure triggered eviction,there are methods to triggeror prevent eviction from your extension.This was a lot of theory.Let’s have a look at one of the flows in practice.We’ve written an app that runs a small local file serverand embeds a file provider extensionthat operates against that server.It’s called FruitBasket.I’ve already logged in to that server,so there’s an entry for the root folder here in the sidebar.I’ve also selected the root folder which caused the systemto make dataless entries for the items in that folder.You can tell that the items are datalessfrom the cloud download icon next to the file name.We’re going to use ‘cat’ on the command lineto read a file.Since the file is dataless,this will cause a content fetch in our extension.I’ve already attached to the extension in Xcodeand set a breakpoint to intercept this content fetch.‘cat’ is running, and our breakpoint has hit.Since we are blocking the completionof the content fetch,the read in our Terminal window is also blocked.Note how in the Finder window, the cloud icon has been replacedby a progress indicator.The system has a consistent view of the download status.Of course, since we are actually blockedin the debugger rather than busy downloading,the progress isn’t updating.Let’s continue.I’ve set a second breakpointjust before we call the completion handler.At this time, our provider has downloadedthe contents of the file to a local URL on disk.Once we call the completion handler,the system will swap out the contentsof the user-visible file with what we’ve downloaded.Let’s unblock the system by continuing in Xcode.The status in Finder updates to show the file as being local,and the read that the cat process was blocked on succeeds.I’ve still got the breakpoints set,but now that the file is local,I can run ‘cat’ again without hitting the breakpoint.Those reads are going against a regular local fileand don’t involve our extension.Of course, this is just a small partof the feature set of our sample file provider.We’ve covered the full feature set of the API,and we are publishing the source code as part of this session.Let’s talk about how you can approach implementingthe flows that we’ve talked about.First of all, we’re going to wantto tell the system that we’re ready to sync.This will make an entry show up in the sidebar in Finder.We call these entries domains, and they usually correspondto a login session on your cloud server.Each domain has a unique identifier,and to make it show up, you create a new instanceand add it via the manager object.You can also remove a domain.You’d usually do this when the user logs out,but it’s also going to be usefulduring your initial development and testing.With the domain showing up in Finder,the system will request enumeration of itemsas soon as you navigate to the entry.So let’s implement that next.Our first step here is to implement an item class.Its instances represent the individual entriesthat we’re going to enumerate.Then we implement an enumerator that calls the systemwith our items when the system requests it.At this point, we can look at directoriesby navigating to our sidebar entry.Of course, all the files in those directorieswill be dataless.Let’s change that by implementingcontent fetch.The fetchContents method is called by the systemwhen we open one of the dataless files.Our job is to download the file contents to a location on disk,then call the completion handler with that location’s URL.The system will use the contents to fill the dataless fileand then clean them up for us.To allow our directory structure to stay in sync,we’ll implement another type of enumerator.This one syncs remote changes.The system calls the currentSyncAnchor method firstto get a sync anchor.You return a data object that describesa change cursor for your database.Whenever you signal that something has changed,the system will ask for changessince the last anchor you provided.You can then return the changes and finally a new anchor.The last step is to allow sync up of changes.If the system detects changes to the local files,it will call one of three methods to create,modify, or delete an existing item.We’ll have a quick look at the create method.The system hands you the new item that it asks you to create.This is a system item, although it followsthe same protocol as your own items.The system will also hand you a set of fieldsthat are of interest on the item.For example, the item may or may nothave extended attributes attached to it,and there are fields to describe that.If the content field is set, the system will pass youa file URL with the contents.Items that describe folders or symlinkswill not have contents.Your job is to upload the new local item’s datato the server and then call the completion handlerwith the resulting remote item.And that’s it.At this point, you have a functionalfile provider on macOS providing files on demand,propagating local changes to the cloudand remote changes to the Mac.There are a lot of additional optional APIsin the File Provider framework,which allow finer integration with the system.Let’s have a have a look.Icon decorations can be used to visually decorateitems in Finder.You can badge a file icon,emboss a folder, or indicate sharing status.You provide custom artwork for the decorationsvia a UTType declared in your app.Contextual menu actions allow the user to executecustom actions on your files via the contextual menu.There are UI and non-UI variants.You can define which files these actions apply towith NSPredicates declared in your extension’s Info.plist.Pre-flight alerts allow you to warn the userbefore they take an actionwhich may have unintended consequences.The alert UI and the criteria to activate the alertare configured in the Info.plist as well.So what are your next steps?Well, first of all, you can downloadthe session’s sample code.It’s very comprehensive,and it’ll give you a lot of pointers.Add a target to your existing app for the new extension.There is an Xcode template that will help you get going.From there, all you have to do is implementthe method stubs in the order we’ve discussed,and you’ll be up and running in no time.Thank you for watching this session.We look forward to seeingyour file provider
extensions on macOS.

♪ ♪Hi.I’m Johannes Fortmann from the Cloud File Providers team,and I’m here to show you file providers on macOS.If you’re a cloud storage vendor syncing your users’ filesto macOS, you’re in the right talk.After the introduction, we’re going to talk aboutsome of the user flows involved with syncing files.We’ll then run through one of the flows in Xcodeand discuss the orderin which you will implement support for each of them.We’ll have a quick overviewof additional optional integration pointsand your next steps.First off, let’s talk about what file providers can do for you.

The File Provider framework allows you to integrateyour cloud storage into the file system on macOS.It uses new APFS features to allowon-demand downloads of user files and folders.The API is entirely in user space.We’re deprecating kernel extensions on macOS,so this is a good alternative for youif you were relying on FUSE or KAUTHto intercept syscalls or download files on demand.

All you have to do is handle uploads,downloads, and tell us what changed remotely.The system will tell you what changed locallyand handle all the rest.All of this functionality is well integratedwith the system and in particular in Finder.Your provider will show up in the sidebar.File status will be shown and tracked in Finder,and there are several customizable integration pointswith the UI.You implement an app extensionthat integrates with the system.Its life cycle is driven by user actions.Initially, you create a domain which representsthe file tree that the user can access in your cloud storage.The system will expose that domainin the Finder sidebar and create a root directoryfor the domain in the file system.At this point, no actual data is on the device,but the user can already start interacting with the root.How does this work?The root is what we call a dataless directory.It’s a new kind of object in APFS,and there are APIs to recognize them and interact with them.But more importantly, dataless objects arefully transparent to processes who happen upon them unprepared.Reads trigger downloads,and files lose their dataless propertybefore the reads are allowed to resume.In this presentation, we will see how the File Providerframework allows you to implement callbacksthat get called when processes read dataless files.

Let’s have a look at some user flowsto get sync up and running.We’re going to look at four key flows that coverboth sync down and sync up.In each flow, you’ll see that the systemcalls your extension whenever it needs new data.

We’ll show you that you can talk to your cloud serverto pull that data and, finally,call a completion handler to reply.First, we’re going to look at what happenswhen a dataless file is read.

When the kernel detects a read accessto a dataless file,that syscall is pausedwhile your extension is calledto fetch the contents of the file.Your extension’s fetchContents method is called.Typically, you will implement it to perform a download.When the download completes, it calls a completion handler.The contents of the file are handedto the system which fills in the formerly dataless filewithout invalidating the open file descriptor.The system then unpauses the read access.Now that the file is no longer dataless,subsequent reads won’t have to involve your extension.Enumerating a directory works very similarly.The kernel detects a readdir call and pauses it.It calls your extension to enumeratethe items in that directory.You fetch the metadata for these items from your server.And you reply with a number of items.The enumeration is paginated.You can return less than the full set of items,and the system will pick up enumeratingfrom where it left off.Once all pages have been enumerated,the system will allow the original call to go through.Like in the file case,once the directory has been enumerated,subsequent readdir calls will use the contentsfrom disk and not have to involve your extension.

But what if those contents change remotely?Well, you will have to inform the system of the remote change.Let’s look at how that works.If there’s a remote change,your server can send a push notification to the Mac.In response to that push notification,you signal the systemthat there are changes that need to be enumeratedfrom a special enumerator, the .workingSet.The system will turn around and enumeratethe items that have changed in the .workingSet.A continuation token called the syncAnchoris used to enumerate only the new changes.This token is defined by your extension.The system keeps track of the syncAnchorit last enumerated to.It will call your enumeratorwith the enumerateChanges(from syncAnchor:) method.In response, you return changed items,and once you’re done, give us a new syncAnchorthat we can use next time around.The system will asynchronously goand update the user-visible files.We use an APFS compare-and-swap featurewhich makes sure that local changes aren’t lostin the process.Furthermore, the system integrateswith file coordinationand other advisory locking mechanismsto coordinate with applications.

With these three mechanisms, we are able to sync filesfrom the cloud and keep them in syncin case of remote changes.The last flow deals with syncing up local changes to the cloud.The system detects when local items have changedand calls a modifyItem method on your extension,passing in the exact set of fields that have changed.It aggregates low-level events into eventsthat are meaningful for sync.For example, the kernel detects safe saves and remapsyour item identifiers to the new file IDs transparently.The system will also zip package files for you if you requestand present you with consistent package-level changes.

In response to the modifyItem call,you will update the state of the item server-side.If the contents of the file have changed,the system will hand you a clone of the changed file so you canupload a consistent version even in the event of further changes.

When done, you call a completion handler.The completion handler is used to update the version identifierof the item and confirms deliveryof the change to your extension.The completion handler also takes the final stateof the item as a parameter.Updating an item in the cloud may change its state,for example, if it conflicts with a remote change.Since you pass the final state back,the system is able to update the local stateof the item to match the truth in the cloud.

There is a fifth flow: eviction.The system will evict local files automaticallyand without involving your file provider extensionwhen there is an urgent need for disk space.That might happen, for example,when the user is recording a videoor downloading a software update.The system will evict the minimum setof least recently used files necessary to free upthe disk space required to write those new files.Let’s review the transitions.Eviction turns a local file into a dataless file,and download turns a dataless file into a local file.Files can start dataless if they are created remotelyor not if they are created locally.But not all files can be evicted.The system will only evict a filethat you report as uploadedso that it can be downloaded again.So there really are two sorts of local files:uploaded and non-uploaded files.After a local edit, the new version of the fileneeds to be uploaded, so we’re back in a non-evictable state.

In this presentation so far,we have seen how your file provider extension is invokedby the system to download files upon accessand to upload files after local edits.While you’re not involvedin disk-pressure triggered eviction,there are methods to triggeror prevent eviction from your extension.

This was a lot of theory.Let’s have a look at one of the flows in practice.

We’ve written an app that runs a small local file serverand embeds a file provider extensionthat operates against that server.It’s called FruitBasket.I’ve already logged in to that server,so there’s an entry for the root folder here in the sidebar.I’ve also selected the root folder which caused the systemto make dataless entries for the items in that folder.You can tell that the items are datalessfrom the cloud download icon next to the file name.

We’re going to use ‘cat’ on the command lineto read a file.Since the file is dataless,this will cause a content fetch in our extension.I’ve already attached to the extension in Xcodeand set a breakpoint to intercept this content fetch.

‘cat’ is running, and our breakpoint has hit.Since we are blocking the completionof the content fetch,the read in our Terminal window is also blocked.Note how in the Finder window, the cloud icon has been replacedby a progress indicator.The system has a consistent view of the download status.Of course, since we are actually blockedin the debugger rather than busy downloading,the progress isn’t updating.

Let’s continue.I’ve set a second breakpointjust before we call the completion handler.

At this time, our provider has downloadedthe contents of the file to a local URL on disk.Once we call the completion handler,the system will swap out the contentsof the user-visible file with what we’ve downloaded.Let’s unblock the system by continuing in Xcode.The status in Finder updates to show the file as being local,and the read that the cat process was blocked on succeeds.

I’ve still got the breakpoints set,but now that the file is local,I can run ‘cat’ again without hitting the breakpoint.Those reads are going against a regular local fileand don’t involve our extension.

Of course, this is just a small partof the feature set of our sample file provider.We’ve covered the full feature set of the API,and we are publishing the source code as part of this session.Let’s talk about how you can approach implementingthe flows that we’ve talked about.First of all, we’re going to wantto tell the system that we’re ready to sync.This will make an entry show up in the sidebar in Finder.We call these entries domains, and they usually correspondto a login session on your cloud server.Each domain has a unique identifier,and to make it show up, you create a new instanceand add it via the manager object.You can also remove a domain.You’d usually do this when the user logs out,but it’s also going to be usefulduring your initial development and testing.With the domain showing up in Finder,the system will request enumeration of itemsas soon as you navigate to the entry.So let’s implement that next.Our first step here is to implement an item class.Its instances represent the individual entriesthat we’re going to enumerate.Then we implement an enumerator that calls the systemwith our items when the system requests it.At this point, we can look at directoriesby navigating to our sidebar entry.Of course, all the files in those directorieswill be dataless.Let’s change that by implementingcontent fetch.The fetchContents method is called by the systemwhen we open one of the dataless files.Our job is to download the file contents to a location on disk,then call the completion handler with that location’s URL.The system will use the contents to fill the dataless fileand then clean them up for us.To allow our directory structure to stay in sync,we’ll implement another type of enumerator.This one syncs remote changes.The system calls the currentSyncAnchor method firstto get a sync anchor.You return a data object that describesa change cursor for your database.Whenever you signal that something has changed,the system will ask for changessince the last anchor you provided.You can then return the changes and finally a new anchor.The last step is to allow sync up of changes.If the system detects changes to the local files,it will call one of three methods to create,modify, or delete an existing item.We’ll have a quick look at the create method.The system hands you the new item that it asks you to create.This is a system item, although it followsthe same protocol as your own items.The system will also hand you a set of fieldsthat are of interest on the item.For example, the item may or may nothave extended attributes attached to it,and there are fields to describe that.If the content field is set, the system will pass youa file URL with the contents.Items that describe folders or symlinkswill not have contents.Your job is to upload the new local item’s datato the server and then call the completion handlerwith the resulting remote item.

And that’s it.At this point, you have a functionalfile provider on macOS providing files on demand,propagating local changes to the cloudand remote changes to the Mac.There are a lot of additional optional APIsin the File Provider framework,which allow finer integration with the system.Let’s have a have a look.

Icon decorations can be used to visually decorateitems in Finder.You can badge a file icon,emboss a folder, or indicate sharing status.You provide custom artwork for the decorationsvia a UTType declared in your app.

Contextual menu actions allow the user to executecustom actions on your files via the contextual menu.There are UI and non-UI variants.You can define which files these actions apply towith NSPredicates declared in your extension’s Info.plist.

Pre-flight alerts allow you to warn the userbefore they take an actionwhich may have unintended consequences.The alert UI and the criteria to activate the alertare configured in the Info.plist as well.

So what are your next steps?Well, first of all, you can downloadthe session’s sample code.It’s very comprehensive,and it’ll give you a lot of pointers.Add a target to your existing app for the new extension.There is an Xcode template that will help you get going.From there, all you have to do is implementthe method stubs in the order we’ve discussed,and you’ll be up and running in no time.Thank you for watching this session.We look forward to seeingyour file provider
extensions on macOS.

## Code Samples


# Wwdc2021 10057

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Take your iPad apps to the next levelMake even better iPad apps: Learn how you can adopt prominent scenes for uninterrupted, focused interactions. Help people stay engaged and fast with keyboard shortcuts and the keyboard shortcut interface. Explore how the latest in pointer enhancements can help your app boost productivity.ResourcesAdding hardware keyboard support to your appAdding Menus and Shortcuts to the Menu Bar and User InterfaceEnhancing your iPad app with pointer interactionsHuman Interface Guidelines: Pointing devicesUIKitHD VideoSD VideoRelated VideosWWDC21Focus on iPad keyboard navigationQualities of a great Mac Catalyst appQualities of great iPad and iPhone apps on Macs with M1What's new in UIKitWWDC20Build for the iPadOS pointerDesign for the iPadOS pointerSupport hardware keyboards in your appWWDC19Introducing Multiple Windows on iPadTargeting Content with Multiple Windows

Make even better iPad apps: Learn how you can adopt prominent scenes for uninterrupted, focused interactions. Help people stay engaged and fast with keyboard shortcuts and the keyboard shortcut interface. Explore how the latest in pointer enhancements can help your app boost productivity.

Adding hardware keyboard support to your app

Adding Menus and Shortcuts to the Menu Bar and User Interface

Enhancing your iPad app with pointer interactions

Human Interface Guidelines: Pointing devices

UIKit

HD VideoSD Video

HD Video

SD Video

Focus on iPad keyboard navigation

Qualities of a great Mac Catalyst app

Qualities of great iPad and iPhone apps on Macs with M1

What's new in UIKit

Build for the iPadOS pointer

Design for the iPadOS pointer

Support hardware keyboards in your app

Introducing Multiple Windows on iPad

Targeting Content with Multiple Windows

Search this video…♪ Bass music playing ♪♪Chris Donegan: Hi, I'm Chris, an engineer on UIKit.I'll be joined later by my colleagues Anant and Mohammed.iPad is the primary device for many peopledue to its power and capabilities.In this video, you'll learn about some exciting new featuresyou should use to take your iPad app to the next level.First, I'll show you the latest advancementsin multitasking and scenes.Then, Anant will walk you throughthe powerful changes to keyboard shortcuts.Finally, Mohammed will show you the latest enhancementsto the system pointer.Let's get right into multitasking.iPadOS 13 introduced the abilityto run multiple instances of your app's UI.In iPadOS 15, we're improving this experiencewith new APIs for scene presentationas well as enhanced state restoration.These enhancements build uponthe existing UIScene infrastructure.If you haven't adopted UIScene,check out "Introducing Multiple Windows on iPad."Let's briefly go over the key concepts.A scene represents a single instance of your app's UI.The structure of a scene's componentsis defined by a scene configuration.At a minimum, it defines the scene's role and delegate class.You can also provide a name, storyboard, and scene subclass.Scene configurations can either be declared in your Info.plist,or created at runtimeusing the UISceneConfiguration object.The content of a scene is represented byan NSUserActivity.These activities are used for requesting scenesas well as for state restoration.A scene is managed by a scene delegate.The delegate is responsible for setting up the UI,responding to lifecycle events,as well as saving and restoring state.Finally, a scene is tracked by a scene session.The scene itself can be disconnected and reconnectedby the system when it's in the background.The scene session tracks the sceneregardless of its connection stateand persists between launches.The session can be thought of as the representationin the system app switcher.Each item in the switcher corresponds to a scene session.When requesting a scene from the system,you can provide an options objectfor customizing the request.iPadOS 15 has a new options subclassspecifically for window scenes.Using this subclass allows you to specifya presentation style.Window scene presentation stylesinfluence how the scene is presentedrelative to other scenes in the workspace.There are three possible values:prominent, standard, and automatic.This is a scene using the prominent presentation style.It's presented modally in the current workspacewith the scenes behind it dimmed.Because it's modal,it should provide Cancel, Close, or Done buttons.This new style can be thought ofas a staging ground for new scenes.It can be repositioned like any other sceneusing the new multitasking controls,and it can also be moved into the app shelf for later.When considering if this style is appropriate for a scene,there are some guidelines to keep in mind.First, prominent scenes should be useful on their own.They should not be usedfor providing options or tools for another scene.They should provide a Done or Close button,and they should be dedicated to specific contentwithin your app like a document or file.This dedicated content scope must be definedin the scene's activation conditions.For more information on activation conditions,check out "Targeting Content with Multiple Windows."This example shows how Safari is opening a new sceneusing the standard style.They are presented side by side, allowing interaction with each,and both provide the full functionality of the main scene.You can also specify automatic as the style.This value tells the system that it should choosethe best style based on how it was requested.iPadOS 15 not only providesa way to customize presentation using styles,it also makes it easier for people to open their contentin new scenes.On the Mac, it's common to find an Open in New Window itemin context menus.You should bring this familiar experienceto your iPad app by using UIWindowScene.ActivationAction.It's a new UIAction subclass for requesting scenesthat can be used in menus, buttons, and bar button items.To add this functionality to your app,start by initializing a UIWindowScene.ActivationAction.It's initialized with a closure that is executedwhen the item is selected.The closure should return an activation configurationwith a user activity for the new scene's content.Finally, put the action in a menu and you're good to go.On iPad and Mac Catalyst,the menu shows an Open in New Window itemthat, when selected, will present a new scene.On iPhone, the item is automatically hiddenbecause multiple scenes are not supported.If you would rather show another item in its place,you can provide an alternate action.Let's update the previous example to offer one.To do this, start by creating the alternate action.The new action's title and image are shownwhen multiple windows are not available.Then, update the initializer of the scene activation actionby passing the new action as the alternate.With an alternate action provided,the menus on iPad and Mac Catalyststill show the Open in New Window itembut on iPhone, the Show Details item is visible;all done without a single condition in your code.Adding these menu items is a clear and familiar wayfor people to open their content in new scenes.But it's not the only way.iPad is a touch-first deviceand it's easy to open scenes with a single gesture.In the Notes app,pinching out on a cell opens the note in a new scene.The scene interactively animatesfrom the cell to its final position.There are two ways of offering this functionalityin your app.If you're using a collection view,there's a new delegate method.For other views, use UIWindowScene ActivationInteraction.Both of these are only for presenting sceneswith a prominent style.To support this gesture in your collection view,implement the new delegate method namedsceneActivationConfiguration ForItemAt indexPath.It's very similar to the context menu example from earlier.Create the user activity for the new scene's content,then return an activation configurationwith that activity.You may not want every cell to support opening a new scene.To prevent the gesture from beginning,just return nil.To support this gesture on other views,create a UIWindowScene .ActivationInteraction.It's created with a closure that accepts two arguments:the interaction itselfand the point of the interaction in the view's coordinate space.These can be used to create specific user activitiesfor different regions of the view.The closure should return an activation configurationwith the user activity.The interaction also takes an error handler.While the interaction is disabled on platformsthat don't support multiple scenes,errors can still occur due to configuration issuesor a lack of system resources.You've probably noticed that all of these waysof presenting window scenesuse the same activation configuration object.Its only requirement is a user activity,but it also contains scene request optionsand a targeted preview.If these are not provided,the system will do its best to create them for you.However, you can explicitly provide themto refine the experience.As an example, these collection view cellshave a thumbnail, title, and caption.When the cell is pinched out, a scene is presentedwhich mainly displays the larger versionof the thumbnail's content.Notice that the new sceneis transitioning from the cell as a whole.It would look betterif it transitioned from just the thumbnail.To achieve this effect,the activation configuration is created as before.Then, check if the cell is a thumbnail cell.If so, use the cell's thumbnail viewto create a targeted preview and set it on the configuration.By providing a custom preview on the activation configuration,the transition is much more polished.Let's take a closer look.Now, rather than transitioning from the cell itself,it transitions from the thumbnail,leaving the rest of the cell in place.Activation configurations allow you to requestany of your app's scenes.However, you may simply want to display a filewithout having to build a scene yourself.iPadOS 15 makes this very easy.There's a special subclassof UIWindowScene .ActivationConfigurationcalled "QLPreviewScene ActivationConfiguration".Returning a preview scene configurationrequests a system-managed preview scene.There's no scene delegate and no callbacks to worry about,but your app must declare supportfor multiple windows in the Info.plist.Providing polished and convenient waysfor people to open content in new scenes is important.But it's equally as importantto save and restore the scene's stateso returning to them later on is a seamless experience.When a scene moves to the background,the system will ask the scene's delegatefor an NSUserActivity to represent its state.This activity could be the root view controller's activityif it supports Handoff, or one created on the spot.Here, a user activity is createdsaving the contents of a text fieldin the activity's user info dictionary.To give the best experience,the scene state should go beyond just the content.You should also save the visual and interaction statelike scroll position, cursor position,and first responder status.Rather than saving each of these independently,UITextField and UITextView now havean interactionState property.This property provides a single objectcontaining all of the interaction state.The object doesn't contain the content itself,it's additional informationfor you to save in the user activity.I've updated the previous exampleby saving the interaction state of the text field.Now, by saving both the content and the interaction state,the user activity contains enough informationto be accurately restored.On iPadOS 14, restoring state can be a little tricky.If you tried to restore state when the scene was connecting,you'd notice that the storyboard and views weren't fully loaded.If you restored later,when the scene was transitioning to the foreground,you had to track whether or not it was for the first time.iPadOS 15 solves this problem with a new delegate methodexplicitly for restoring state.It's called after the scene is connectedand the storyboard has been loaded,but before the first transition to foreground.Regardless of whether your app uses storyboards,you should use this new callback for restoring state.Restoring state from the activitysaved in the previous examplestarts with the system calling sceneRestoreInteractionState.Then, restoring the content of the text field.Finally, restoring its interaction state.It's critical that the content be restoredbefore the interaction state.Lastly, synchronously restoring state can be complex.You may need to access a database or load a fileand don't want empty UI during that time.To account for this,iPadOS 15 allows your app to request a short-term extension.During this extension,the launch image will remain visiblewhile still allowing the main RunLoop to execute.Once your content is loaded,the app should signal to complete the restoration.This extension is short and not intended to be usedfor potentially long-running tasks like network access.If your app fails to signal completion,or takes too long, it will be closed by the system.To use extended state restoration,start by requesting an extension from the scene.Then, kick off your asynchronous work.Once the content is loaded,restore it and tell the scene to complete restoration.The scene will then display your freshly restored UI.Supporting multitasking in your app makes it shine,but to be a true next-level iPad app,there's more to do.And now, over to Anant.Anant Jain: Thank you, Chris!My name is Anant and I'm a UIKit engineer.People love that iPad is light enough to hold in their handswhile still being able to attach to a physical keyboardat a moment's notice.They expect your app to keep up with themby having great keyboard support.iPadOS 15 introduces several new featuresto bring your app's keyboard shortcuts to the next level.iPadOS 15 features a totally new interfacefor discovering keyboard shortcuts.It structures each command into familiar categories,bringing increased paritybetween the iPad and Mac Catalyst versionsof your app.The menu offers a convenient search featurethat can be brought up from anywhere across the system.You can even tap on a shortcut to trigger it.If you need a refresher on how to support keyboard shortcutswith UIKeyCommand, including how commandsare dispatched to the responder chain,check out "Support hardware keyboards in your app."On Mac Catalyst, apps each have a global menucalled the main menu, which is displayedin the menu bar at the top of the screen.The main menu consists of several category submenus,like File and Edit, and these category menusin turn contain further submenus with all the app's commands.On iPadOS 15, we've broughtthe main menu system to iPad apps.The new shortcut interface,which appears by holding down the Command key,displays this menu.Now, the main menu system is represented a bit differentlyon the iPad compared to the Mac.The Mac displays the full submenu hierarchywithin each category,whereas the iPad flattens those hierarchies.Disabled and non-performable commandsappear grayed out on the Mac,whereas they are hidden on the iPad.Furthermore, the iPad shortcut menuis designed to help discover keyboard shortcuts in an app.It won't display keyless commandslike the Mac menu bar does.By default, the main menu containsall the system category menus like File and Edit.These include all the system commands,like Undo and Redo,Paste and Match Style, and so on.iPadOS 15 adds the Print commandto this list of system commands, which apps can get by addingthe UIApplication SupportsPrintCommand keyto their Info.plist.Now that iPad apps on iPadOS 15 support the main menu system,they can use the UIMenuBuilder APIto customize it, just like Mac Catalyst apps.In fact, if you already havea Mac Catalyst version of your app,you've already done most of the work.Apps should use the builderto add all supported key commands to their main menus.This is a change from how apps would previouslydeclare keyboard shortcuts:by overriding the keyCommands property on UIResponder,or by calling addKeyCommand(_:) on a view controller.Commands defined this way do still work,but they'll appear in a separateuncategorized section of the new interface.Apps should remove key command declarations like thisand instead add them to the main menu.To customize the main menu,override buildMenu(withbuilder:) in your AppDelegate.UIKit calls this method at app launchand passes in a UIMenuBuilder object.Apps should check if the builderis modifying the main menu system.If so, they can use the builder to make customizations.Suppose an app wants some key commands in the File menufor working with tabs.The app simply creates a submenu using the UIMenu APIand adds the desired key commandsas that menu's children.Then the app calls the insertChild methodon the builder objectto insert the submenu into the File menu.To reference an existing element in the main menu system --like the File menu, in this case --apps should specify the element's identifier.The built-in system menu identifiersare defined as constants under UIMenu.Identifier.Apps can easily create their own menu categories, too.Here, the app creates a Bookmarks menu --once again, using the UIMenu API.Then, the app uses the builderto insert that menu into the root menu --in this case, after the system View menu.That's all it takes!Now, the builder can be usedto make further insertions into the Bookmarks menu,just as it would with the File menu.Just pass in the new menu's identifier,which UIKit automatically generates.Now, I keep mentioning identifiers.UIMenuBuilder will enforce that each elementin the main menu system has a unique identifier,including individual commands.Suppose an app inserts key commandsto display content either as a list or as a grid.Both commands share the same action:changeViewMode(_:).In the main menu system,commands are implicitly identified by their actions,so both of these commands share the same identifier.UIMenuBuilder won't allow both commands to be insertedunless they have different identifiers.One way to distinguish these commandsis to give them different propertyList values.But a better way is to simply give each commanda unique action describing what it specifically does.The builder also enforces that keyboard shortcut combinationsin the main menu are unique.Suppose an app inserts a Get Info key commandon Command-I.Because the system Italic shortcut in the text style menushares the same shortcut, this insertion will also fail.Once again, there are two solutions.The app can change the Get Info shortcut to somethingthat doesn't collide with an existing shortcut,such as Control-Command-I.Alternatively, the app can tell the builderto remove the text style commands if they're not needed.If an insertion includes a duplicate,then UIMenuBuilder fails that insertionand logs an error in the console showing eitherthe duplicated key commands or the shared identifiers.If you're finding your insertions aren't appearing,chances are there's a duplicate somewhere,so look for logs like this in the console.After the call to buildMenu(with builder:)finishes, the app's main menu appearsin the Mac menu bar and the iPad shortcut overlay.There is one problem, though.The app added a submenu with commandsto sort bookmarks either by name or by date.But because the iPad shortcut overlaydoesn't display the submenu hierarchy,it's not clear what these shortcuts do on iPadOS.For situations like this, set a more descriptivediscoverability title on the key commands.iPadOS prefers the discoverability titleover the regular title if both are provided.Now, I mentioned earlier that individual respondersshould avoid declaring keyboard shortcutsand instead declare them in the main menu system.However, responders should still implement action methodsfor main menu commands.When key commands are triggered,UIKit automatically dispatches the action to a responder.UIKit does this by traversing the app's responder chain.As soon as it finds a responder that can perform the action,it calls that responder's action method.If nothing in the chain can perform the action,then the key command isn't performable.If you're new to UIResponder concepts,"Support hardware keyboards in your app"has a fantastic introduction to how it works."Qualities of a great Mac Catalyst app"also dives into a bit more detail.When UIKit performs a responder search along the chain,it calls two useful UIResponder methods.Apps can override these methods in their respondersto improve their key commands.The first is canPerformAction (_:withSender:),which UIKit uses to checkif a responder can perform an action.By default, this returns trueif the responder implements that action method;otherwise, it returns false.Responders can override this to add custom logic.For example, a web browser can tell UIKitthat the closeTab command isn't performableif there are no open tabs.Since UIKit can't find a target responder for that action,the command will be non-performableand it won't be shown in the shortcut interface.Note that overrides for this methodmust call super for unhandled cases.The other useful method is validate(_ command:).When UIKit finds a target responder for a key command,it calls this method on that responderand passes in a copy of the command.Responders can override validate(_ command:)to update the appearance of the commandfor the current state of the app.Here, the app updates the titleof the toggleBookmark(_:) commandbased on whether or not the current page is bookmarked.The title set in this methodwill reflect in the shortcut interface when it appears.In iPadOS 15, UIKit is introducinga major change to the responder chain.When apps adopt keyboard navigationwith the focus system,then responder traversal will begin at the focused itemrather than the first responder.This change plays incredibly well with key commands.Photos, for example, allows usersto work with their photo library using just the keyboard.When users focus a cell in the grid,they can hit the Space bar to view that photo.They can even hit Command-C to copy that photofor pasting into another app.Each cell implements various key command actions,and since responder traversal starts at the focused item,then the key commands target the cell.In short, the focus system levels up key commandsand the responder chain.Take advantage of it to supportpowerful contextual shortcuts in your app.To learn more, check out"Focus on iPad keyboard navigation."Finally, iPadOS 15 and macOS 12introduce keyboard shortcut localization.When you build your app with these SDKs,the system automatically localizes shortcut modifiersand inputs for each keyboard layout.Take the Command-backslash shortcut, for example.While the shortcut works on a US keyboard,it's impossible to perform on a Japanese keyboard,since that layout has no backslash key.So the system will remap the shortcut for Japanese keyboards.This means apps should notlocalize shortcut modifiers or inputs,and instead let the system do the work.Apps can also opt out of automatic localization,either at the app-wide level or on a per-shortcut basis.When the system localizes shortcuts,it also mirrors them for right-to-left layouts.For example, a shortcut to navigate backwardswith Command-left bracketis flipped to Command-right bracket.If a shortcut shouldn't be mirrored,set the command's allowsAutomaticMirroringproperty to false to disable mirroringwithout disabling automatic localization entirely.iPadOS 15 is a huge release for keyboard shortcuts.There's a ton of other enhancementson top of everything we've covered today.So you've adopted all the new Multitasking features,and you've built great keyboard support.Now, Mohammed will give you a few pointersto take your iPad app to the highest level.Mohammed Jisrawi: Thanks, Anant! Hi, I'm Mohammed.Let's talk about the improvementsiPadOS 15 brings to the system pointer.iPadOS 13.4 introduced an adaptive system pointerthat bridges between the touch-based UI of the iPadand the precision of a mouse or trackpad.If you're new to pointer interactions,take a moment to familiarize yourself with themand check out these previous videos."Build for the iPadOS pointer"breaks down the pointer interaction APIs."Design for the iPadOS Pointer"dives into the design philosophy behind themand discusses best practices when adopting them in your app.iPadOS 15 brings over some familiar Mac user interactionsin a way that's consistent with the iPad's design language.It also introduces some new conceptsthat enhance usability and clarity.The first of these additions is band selection,a new pointer-specific multiselection experiencethat should be familiar to anyone who's used a Mac.In iPadOS 15, when you click and drag in a collection view,the pointer stretches into a rectangle,and the collection view selects the itemsthat the rectangle encompasses.Of course this translates naturallyto the familiar Mac UI on Mac Catalyst apps.This interaction is built into non-list UICollectionViews.Any UICollectionView that supports the existingone- and two-finger multiselection gesturesvia the shouldBeginMultiple SelectionInteraction APIgets this behavior automatically in iPadOS 15.For anything other than a UICollectionView,the new UIBandSelectionInteraction APIallows you to easily adopt this experience in your app.Since the selection logic is completely up to you,you're able to support custom selection behaviorsand have your UI react to the changing selectionin any way you choose.To get started, instantiate the interactionwith a selection handler to be called as the pointer movesand the interaction's state changes.Once it's created, add the interaction to your viewas you would any other UIInteraction.In the handler, you can implementyour custom selection logic by responding to changesin the interaction's state and selectionRect.Here we have a simple implementationthat sets the selection to the itemswithin the interaction's selectionRectwhile the pointer is moving.It then finalizes the selection sessionwhen the primary mouse button is releasedand the interaction ends.In addition to basic selection,UICollectionView's built-in band selectionsupports some common keyboard shortcutsout of the box.Holding Shift at the start of the drag, for example,causes items to be added to an existing selectionrather than replacing the currently selected items.Holding Command toggles the selection state of itemsin the selection rect.This can be implemented in custom UIusing the interaction's initialModifierFlags property,which provides the keys held at the start of the drag.Since it's a set of all the pressed modifiers,you can respond to arbitrary key combinationsto support custom or more advanced behaviorthat's specific to your app.The second addition to the system pointeris the ability to attach accessories.Accessories communicate additional informationand provide contextual hints by combining secondary shapeswith the primary pointer.For instance, in the example on the left,the two arrows indicate that this viewcan be dragged horizontally.In the example on the right,the plus provides some additional contextfor this Add to Cart button.There are a few key distinctions between accessoriesand using a custom pointer shape.Accessories are visually separateand secondary to the main pointer.This is emphasized by the fact that they may be renderedwith a different appearanceand animate separately from the main pointer.They are independent units which can be combinedand positioned around the pointerto communicate different ideas.Since they are independent,they can be combined with any pointer style.Here's a demonstration of how the same set of accessories --two arrows indicating draggability --can be combined with different pointer styles.On the left, they're combined with a lift effectwhere the pointer merges with the view and lifts it up.In the middle, they're alongside a highlight effect,where the pointer turns into a rounded rectangleand goes under the view.On the right, they appear with the default system pointerusing the new UIPointerStyle.system() API.So we're able to provide this additional contextwhile still using the ideal effect for the situation,without sacrificing the liveliness of the pointer,and while still maintaining its deep relationshipwith the app's UI.Just like it animates between pointer styles,the system will automatically animate the appearanceand disappearance of accessories.It'll also seamlessly animatebetween accessory shapes and position.The act of transitioning accessorieswhile a given effect is active can be meaningful.Such a transition can be used to communicatea change in state or behavior in the underlying UI.In the example on the left,the transition from a plus to a no signmay indicate that an operation that was previously possibleis no longer permitted.Pointer accessories are composed of a UIPointerShapeand a UIPointerAccessory.Position,which describes the desired positionas an offset from the pointer's midpointand an angle from the top.For convenience, UIKit provides some predefined valuesfor positions around the pointer.If the predefined positions don't quite fit your needs,you can use them as a starting pointand customize individual properties.This example starts with the topRight positionand customizes the offset.You can also define entirely custom positions,as in this example,which creates a position with a custom offset and angle.To set up the example we saw at the beginning of this segment,we'll create a UITargetedPreview with our viewand use that to create a UIPointerStylewith a lift effect.Then we'll set the style's new accessories propertyto an array that contains our two arrow accessories.UIKit provides a premade arrow accessory,so we can just create two of thosepositioned on the left and right sides of the effect.So now when the pointer hovers over this view,the two arrows animate out as the view lifts,hinting that it can be dragged.If you've ever tried to implementthis sort of interactionwhere a view with a pointer effect is draggable,you've probably noticed something like this.When the pointer reaches the edge of the pointer region,it disengages from the lifted view and the effect ends.This is usually desirable, since it prevents the pointerfrom sticking to views as it moves around.However, in scenarios like this, the ideal experiencewould be for the pointer effect to remain stableand latch to the view and follow it along as it's dragged.To better enable these sorts of interactions,iPadOS 15 introduces the concept of latchingAxeson UIPointerRegion.When a region latches along a given axis,its pointer effect follows the pointer along the axiswhen the primary mouse button is pressed.A horizontally latching region lets you drag freelyalong the x-axis while still rubberbanding along the y-axis.A vertically latching onelets you drag freely along the y-axis.And one that latches along bothlets you drag freely along both axes.These new tools can be used to buildsome really powerful new experiences.Here they are combined in a document editing applike Pages or Keynote.This image can be selected using band selection.Selecting the image causes dragging indicators to appear,and when the pointer hovers over an indicator,accessories appear to hint athow the image will be resized if it's dragged.And finally, latching allows the pointer effect and accessoriesto follow the axis-locked resize gesture.These are just some of the enhancementsiPadOS 15 brings to the iPad.Take advantage of them where applicableto really maximize the utility of your app.Adopt prominent scenes to give people a focused,uninterrupted view of your app's content.Empower them to achieve complex tasks quicklywith the new keyboard shortcuts menu,and boost their productivity with the new pointer features.Thanks for watching!♪

♪ Bass music playing ♪♪Chris Donegan: Hi, I'm Chris, an engineer on UIKit.

I'll be joined later by my colleagues Anant and Mohammed.

iPad is the primary device for many peopledue to its power and capabilities.

In this video, you'll learn about some exciting new featuresyou should use to take your iPad app to the next level.

First, I'll show you the latest advancementsin multitasking and scenes.

Then, Anant will walk you throughthe powerful changes to keyboard shortcuts.

Finally, Mohammed will show you the latest enhancementsto the system pointer.

Let's get right into multitasking.

iPadOS 13 introduced the abilityto run multiple instances of your app's UI.

In iPadOS 15, we're improving this experiencewith new APIs for scene presentationas well as enhanced state restoration.

These enhancements build uponthe existing UIScene infrastructure.

If you haven't adopted UIScene,check out "Introducing Multiple Windows on iPad."Let's briefly go over the key concepts.

A scene represents a single instance of your app's UI.

The structure of a scene's componentsis defined by a scene configuration.

At a minimum, it defines the scene's role and delegate class.

You can also provide a name, storyboard, and scene subclass.

Scene configurations can either be declared in your Info.plist,or created at runtimeusing the UISceneConfiguration object.

The content of a scene is represented byan NSUserActivity.

These activities are used for requesting scenesas well as for state restoration.

A scene is managed by a scene delegate.

The delegate is responsible for setting up the UI,responding to lifecycle events,as well as saving and restoring state.

Finally, a scene is tracked by a scene session.

The scene itself can be disconnected and reconnectedby the system when it's in the background.

The scene session tracks the sceneregardless of its connection stateand persists between launches.

The session can be thought of as the representationin the system app switcher.

Each item in the switcher corresponds to a scene session.

When requesting a scene from the system,you can provide an options objectfor customizing the request.

iPadOS 15 has a new options subclassspecifically for window scenes.

Using this subclass allows you to specifya presentation style.

Window scene presentation stylesinfluence how the scene is presentedrelative to other scenes in the workspace.

There are three possible values:prominent, standard, and automatic.

This is a scene using the prominent presentation style.

It's presented modally in the current workspacewith the scenes behind it dimmed.

Because it's modal,it should provide Cancel, Close, or Done buttons.

This new style can be thought ofas a staging ground for new scenes.

It can be repositioned like any other sceneusing the new multitasking controls,and it can also be moved into the app shelf for later.

When considering if this style is appropriate for a scene,there are some guidelines to keep in mind.

First, prominent scenes should be useful on their own.

They should not be usedfor providing options or tools for another scene.

They should provide a Done or Close button,and they should be dedicated to specific contentwithin your app like a document or file.

This dedicated content scope must be definedin the scene's activation conditions.

For more information on activation conditions,check out "Targeting Content with Multiple Windows."This example shows how Safari is opening a new sceneusing the standard style.

They are presented side by side, allowing interaction with each,and both provide the full functionality of the main scene.

You can also specify automatic as the style.

This value tells the system that it should choosethe best style based on how it was requested.

iPadOS 15 not only providesa way to customize presentation using styles,it also makes it easier for people to open their contentin new scenes.

On the Mac, it's common to find an Open in New Window itemin context menus.

You should bring this familiar experienceto your iPad app by using UIWindowScene.ActivationAction.

It's a new UIAction subclass for requesting scenesthat can be used in menus, buttons, and bar button items.

To add this functionality to your app,start by initializing a UIWindowScene.ActivationAction.

It's initialized with a closure that is executedwhen the item is selected.

The closure should return an activation configurationwith a user activity for the new scene's content.

Finally, put the action in a menu and you're good to go.

On iPad and Mac Catalyst,the menu shows an Open in New Window itemthat, when selected, will present a new scene.

On iPhone, the item is automatically hiddenbecause multiple scenes are not supported.

If you would rather show another item in its place,you can provide an alternate action.

Let's update the previous example to offer one.

To do this, start by creating the alternate action.

The new action's title and image are shownwhen multiple windows are not available.

Then, update the initializer of the scene activation actionby passing the new action as the alternate.

With an alternate action provided,the menus on iPad and Mac Catalyststill show the Open in New Window itembut on iPhone, the Show Details item is visible;all done without a single condition in your code.

Adding these menu items is a clear and familiar wayfor people to open their content in new scenes.

But it's not the only way.

iPad is a touch-first deviceand it's easy to open scenes with a single gesture.

In the Notes app,pinching out on a cell opens the note in a new scene.

The scene interactively animatesfrom the cell to its final position.

There are two ways of offering this functionalityin your app.

If you're using a collection view,there's a new delegate method.

For other views, use UIWindowScene ActivationInteraction.

Both of these are only for presenting sceneswith a prominent style.

To support this gesture in your collection view,implement the new delegate method namedsceneActivationConfiguration ForItemAt indexPath.

It's very similar to the context menu example from earlier.

Create the user activity for the new scene's content,then return an activation configurationwith that activity.

You may not want every cell to support opening a new scene.

To prevent the gesture from beginning,just return nil.

To support this gesture on other views,create a UIWindowScene .ActivationInteraction.

It's created with a closure that accepts two arguments:the interaction itselfand the point of the interaction in the view's coordinate space.

These can be used to create specific user activitiesfor different regions of the view.

The closure should return an activation configurationwith the user activity.

The interaction also takes an error handler.

While the interaction is disabled on platformsthat don't support multiple scenes,errors can still occur due to configuration issuesor a lack of system resources.

You've probably noticed that all of these waysof presenting window scenesuse the same activation configuration object.

Its only requirement is a user activity,but it also contains scene request optionsand a targeted preview.

If these are not provided,the system will do its best to create them for you.

However, you can explicitly provide themto refine the experience.

As an example, these collection view cellshave a thumbnail, title, and caption.

When the cell is pinched out, a scene is presentedwhich mainly displays the larger versionof the thumbnail's content.

Notice that the new sceneis transitioning from the cell as a whole.

It would look betterif it transitioned from just the thumbnail.

To achieve this effect,the activation configuration is created as before.

Then, check if the cell is a thumbnail cell.

If so, use the cell's thumbnail viewto create a targeted preview and set it on the configuration.

By providing a custom preview on the activation configuration,the transition is much more polished.

Let's take a closer look.

Now, rather than transitioning from the cell itself,it transitions from the thumbnail,leaving the rest of the cell in place.

Activation configurations allow you to requestany of your app's scenes.

However, you may simply want to display a filewithout having to build a scene yourself.

iPadOS 15 makes this very easy.

There's a special subclassof UIWindowScene .ActivationConfigurationcalled "QLPreviewScene ActivationConfiguration".

Returning a preview scene configurationrequests a system-managed preview scene.

There's no scene delegate and no callbacks to worry about,but your app must declare supportfor multiple windows in the Info.plist.

Providing polished and convenient waysfor people to open content in new scenes is important.

But it's equally as importantto save and restore the scene's stateso returning to them later on is a seamless experience.

When a scene moves to the background,the system will ask the scene's delegatefor an NSUserActivity to represent its state.

This activity could be the root view controller's activityif it supports Handoff, or one created on the spot.

Here, a user activity is createdsaving the contents of a text fieldin the activity's user info dictionary.

To give the best experience,the scene state should go beyond just the content.

You should also save the visual and interaction statelike scroll position, cursor position,and first responder status.

Rather than saving each of these independently,UITextField and UITextView now havean interactionState property.

This property provides a single objectcontaining all of the interaction state.

The object doesn't contain the content itself,it's additional informationfor you to save in the user activity.

I've updated the previous exampleby saving the interaction state of the text field.

Now, by saving both the content and the interaction state,the user activity contains enough informationto be accurately restored.

On iPadOS 14, restoring state can be a little tricky.

If you tried to restore state when the scene was connecting,you'd notice that the storyboard and views weren't fully loaded.

If you restored later,when the scene was transitioning to the foreground,you had to track whether or not it was for the first time.

iPadOS 15 solves this problem with a new delegate methodexplicitly for restoring state.

It's called after the scene is connectedand the storyboard has been loaded,but before the first transition to foreground.

Regardless of whether your app uses storyboards,you should use this new callback for restoring state.

Restoring state from the activitysaved in the previous examplestarts with the system calling sceneRestoreInteractionState.

Then, restoring the content of the text field.

Finally, restoring its interaction state.

It's critical that the content be restoredbefore the interaction state.

Lastly, synchronously restoring state can be complex.

You may need to access a database or load a fileand don't want empty UI during that time.

To account for this,iPadOS 15 allows your app to request a short-term extension.

During this extension,the launch image will remain visiblewhile still allowing the main RunLoop to execute.

Once your content is loaded,the app should signal to complete the restoration.

This extension is short and not intended to be usedfor potentially long-running tasks like network access.

If your app fails to signal completion,or takes too long, it will be closed by the system.

To use extended state restoration,start by requesting an extension from the scene.

Then, kick off your asynchronous work.

Once the content is loaded,restore it and tell the scene to complete restoration.

The scene will then display your freshly restored UI.

Supporting multitasking in your app makes it shine,but to be a true next-level iPad app,there's more to do.

And now, over to Anant.

Anant Jain: Thank you, Chris!My name is Anant and I'm a UIKit engineer.

People love that iPad is light enough to hold in their handswhile still being able to attach to a physical keyboardat a moment's notice.

They expect your app to keep up with themby having great keyboard support.

iPadOS 15 introduces several new featuresto bring your app's keyboard shortcuts to the next level.

iPadOS 15 features a totally new interfacefor discovering keyboard shortcuts.

It structures each command into familiar categories,bringing increased paritybetween the iPad and Mac Catalyst versionsof your app.

The menu offers a convenient search featurethat can be brought up from anywhere across the system.

You can even tap on a shortcut to trigger it.

If you need a refresher on how to support keyboard shortcutswith UIKeyCommand, including how commandsare dispatched to the responder chain,check out "Support hardware keyboards in your app."On Mac Catalyst, apps each have a global menucalled the main menu, which is displayedin the menu bar at the top of the screen.

The main menu consists of several category submenus,like File and Edit, and these category menusin turn contain further submenus with all the app's commands.

On iPadOS 15, we've broughtthe main menu system to iPad apps.

The new shortcut interface,which appears by holding down the Command key,displays this menu.

Now, the main menu system is represented a bit differentlyon the iPad compared to the Mac.

The Mac displays the full submenu hierarchywithin each category,whereas the iPad flattens those hierarchies.

Disabled and non-performable commandsappear grayed out on the Mac,whereas they are hidden on the iPad.

Furthermore, the iPad shortcut menuis designed to help discover keyboard shortcuts in an app.

It won't display keyless commandslike the Mac menu bar does.

By default, the main menu containsall the system category menus like File and Edit.

These include all the system commands,like Undo and Redo,Paste and Match Style, and so on.

iPadOS 15 adds the Print commandto this list of system commands, which apps can get by addingthe UIApplication SupportsPrintCommand keyto their Info.plist.

Now that iPad apps on iPadOS 15 support the main menu system,they can use the UIMenuBuilder APIto customize it, just like Mac Catalyst apps.

In fact, if you already havea Mac Catalyst version of your app,you've already done most of the work.

Apps should use the builderto add all supported key commands to their main menus.

This is a change from how apps would previouslydeclare keyboard shortcuts:by overriding the keyCommands property on UIResponder,or by calling addKeyCommand(_:) on a view controller.

Commands defined this way do still work,but they'll appear in a separateuncategorized section of the new interface.

Apps should remove key command declarations like thisand instead add them to the main menu.

To customize the main menu,override buildMenu(withbuilder:) in your AppDelegate.

UIKit calls this method at app launchand passes in a UIMenuBuilder object.

Apps should check if the builderis modifying the main menu system.

If so, they can use the builder to make customizations.

Suppose an app wants some key commands in the File menufor working with tabs.

The app simply creates a submenu using the UIMenu APIand adds the desired key commandsas that menu's children.

Then the app calls the insertChild methodon the builder objectto insert the submenu into the File menu.

To reference an existing element in the main menu system --like the File menu, in this case --apps should specify the element's identifier.

The built-in system menu identifiersare defined as constants under UIMenu.Identifier.

Apps can easily create their own menu categories, too.

Here, the app creates a Bookmarks menu --once again, using the UIMenu API.

Then, the app uses the builderto insert that menu into the root menu --in this case, after the system View menu.

That's all it takes!Now, the builder can be usedto make further insertions into the Bookmarks menu,just as it would with the File menu.

Just pass in the new menu's identifier,which UIKit automatically generates.

Now, I keep mentioning identifiers.

UIMenuBuilder will enforce that each elementin the main menu system has a unique identifier,including individual commands.

Suppose an app inserts key commandsto display content either as a list or as a grid.

Both commands share the same action:changeViewMode(_:).

In the main menu system,commands are implicitly identified by their actions,so both of these commands share the same identifier.

UIMenuBuilder won't allow both commands to be insertedunless they have different identifiers.

One way to distinguish these commandsis to give them different propertyList values.

But a better way is to simply give each commanda unique action describing what it specifically does.

The builder also enforces that keyboard shortcut combinationsin the main menu are unique.

Suppose an app inserts a Get Info key commandon Command-I.

Because the system Italic shortcut in the text style menushares the same shortcut, this insertion will also fail.

Once again, there are two solutions.

The app can change the Get Info shortcut to somethingthat doesn't collide with an existing shortcut,such as Control-Command-I.

Alternatively, the app can tell the builderto remove the text style commands if they're not needed.

If an insertion includes a duplicate,then UIMenuBuilder fails that insertionand logs an error in the console showing eitherthe duplicated key commands or the shared identifiers.

If you're finding your insertions aren't appearing,chances are there's a duplicate somewhere,so look for logs like this in the console.

After the call to buildMenu(with builder:)finishes, the app's main menu appearsin the Mac menu bar and the iPad shortcut overlay.

There is one problem, though.

The app added a submenu with commandsto sort bookmarks either by name or by date.

But because the iPad shortcut overlaydoesn't display the submenu hierarchy,it's not clear what these shortcuts do on iPadOS.

For situations like this, set a more descriptivediscoverability title on the key commands.

iPadOS prefers the discoverability titleover the regular title if both are provided.

Now, I mentioned earlier that individual respondersshould avoid declaring keyboard shortcutsand instead declare them in the main menu system.

However, responders should still implement action methodsfor main menu commands.

When key commands are triggered,UIKit automatically dispatches the action to a responder.

UIKit does this by traversing the app's responder chain.

As soon as it finds a responder that can perform the action,it calls that responder's action method.

If nothing in the chain can perform the action,then the key command isn't performable.

If you're new to UIResponder concepts,"Support hardware keyboards in your app"has a fantastic introduction to how it works.

"Qualities of a great Mac Catalyst app"also dives into a bit more detail.

When UIKit performs a responder search along the chain,it calls two useful UIResponder methods.

Apps can override these methods in their respondersto improve their key commands.

The first is canPerformAction (_:withSender:),which UIKit uses to checkif a responder can perform an action.

By default, this returns trueif the responder implements that action method;otherwise, it returns false.

Responders can override this to add custom logic.

For example, a web browser can tell UIKitthat the closeTab command isn't performableif there are no open tabs.

Since UIKit can't find a target responder for that action,the command will be non-performableand it won't be shown in the shortcut interface.

Note that overrides for this methodmust call super for unhandled cases.

The other useful method is validate(_ command:).

When UIKit finds a target responder for a key command,it calls this method on that responderand passes in a copy of the command.

Responders can override validate(_ command:)to update the appearance of the commandfor the current state of the app.

Here, the app updates the titleof the toggleBookmark(_:) commandbased on whether or not the current page is bookmarked.

The title set in this methodwill reflect in the shortcut interface when it appears.

In iPadOS 15, UIKit is introducinga major change to the responder chain.

When apps adopt keyboard navigationwith the focus system,then responder traversal will begin at the focused itemrather than the first responder.

This change plays incredibly well with key commands.

Photos, for example, allows usersto work with their photo library using just the keyboard.

When users focus a cell in the grid,they can hit the Space bar to view that photo.

They can even hit Command-C to copy that photofor pasting into another app.

Each cell implements various key command actions,and since responder traversal starts at the focused item,then the key commands target the cell.

In short, the focus system levels up key commandsand the responder chain.

Take advantage of it to supportpowerful contextual shortcuts in your app.

To learn more, check out"Focus on iPad keyboard navigation."Finally, iPadOS 15 and macOS 12introduce keyboard shortcut localization.

When you build your app with these SDKs,the system automatically localizes shortcut modifiersand inputs for each keyboard layout.

Take the Command-backslash shortcut, for example.

While the shortcut works on a US keyboard,it's impossible to perform on a Japanese keyboard,since that layout has no backslash key.

So the system will remap the shortcut for Japanese keyboards.

This means apps should notlocalize shortcut modifiers or inputs,and instead let the system do the work.

Apps can also opt out of automatic localization,either at the app-wide level or on a per-shortcut basis.

When the system localizes shortcuts,it also mirrors them for right-to-left layouts.

For example, a shortcut to navigate backwardswith Command-left bracketis flipped to Command-right bracket.

If a shortcut shouldn't be mirrored,set the command's allowsAutomaticMirroringproperty to false to disable mirroringwithout disabling automatic localization entirely.

iPadOS 15 is a huge release for keyboard shortcuts.

There's a ton of other enhancementson top of everything we've covered today.

So you've adopted all the new Multitasking features,and you've built great keyboard support.

Now, Mohammed will give you a few pointersto take your iPad app to the highest level.

Mohammed Jisrawi: Thanks, Anant! Hi, I'm Mohammed.

Let's talk about the improvementsiPadOS 15 brings to the system pointer.

iPadOS 13.4 introduced an adaptive system pointerthat bridges between the touch-based UI of the iPadand the precision of a mouse or trackpad.

If you're new to pointer interactions,take a moment to familiarize yourself with themand check out these previous videos.

"Build for the iPadOS pointer"breaks down the pointer interaction APIs.

"Design for the iPadOS Pointer"dives into the design philosophy behind themand discusses best practices when adopting them in your app.

iPadOS 15 brings over some familiar Mac user interactionsin a way that's consistent with the iPad's design language.

It also introduces some new conceptsthat enhance usability and clarity.

The first of these additions is band selection,a new pointer-specific multiselection experiencethat should be familiar to anyone who's used a Mac.

In iPadOS 15, when you click and drag in a collection view,the pointer stretches into a rectangle,and the collection view selects the itemsthat the rectangle encompasses.

Of course this translates naturallyto the familiar Mac UI on Mac Catalyst apps.

This interaction is built into non-list UICollectionViews.

Any UICollectionView that supports the existingone- and two-finger multiselection gesturesvia the shouldBeginMultiple SelectionInteraction APIgets this behavior automatically in iPadOS 15.

For anything other than a UICollectionView,the new UIBandSelectionInteraction APIallows you to easily adopt this experience in your app.

Since the selection logic is completely up to you,you're able to support custom selection behaviorsand have your UI react to the changing selectionin any way you choose.

To get started, instantiate the interactionwith a selection handler to be called as the pointer movesand the interaction's state changes.

Once it's created, add the interaction to your viewas you would any other UIInteraction.

In the handler, you can implementyour custom selection logic by responding to changesin the interaction's state and selectionRect.

Here we have a simple implementationthat sets the selection to the itemswithin the interaction's selectionRectwhile the pointer is moving.

It then finalizes the selection sessionwhen the primary mouse button is releasedand the interaction ends.

In addition to basic selection,UICollectionView's built-in band selectionsupports some common keyboard shortcutsout of the box.

Holding Shift at the start of the drag, for example,causes items to be added to an existing selectionrather than replacing the currently selected items.

Holding Command toggles the selection state of itemsin the selection rect.

This can be implemented in custom UIusing the interaction's initialModifierFlags property,which provides the keys held at the start of the drag.

Since it's a set of all the pressed modifiers,you can respond to arbitrary key combinationsto support custom or more advanced behaviorthat's specific to your app.

The second addition to the system pointeris the ability to attach accessories.

Accessories communicate additional informationand provide contextual hints by combining secondary shapeswith the primary pointer.

For instance, in the example on the left,the two arrows indicate that this viewcan be dragged horizontally.

In the example on the right,the plus provides some additional contextfor this Add to Cart button.

There are a few key distinctions between accessoriesand using a custom pointer shape.

Accessories are visually separateand secondary to the main pointer.

This is emphasized by the fact that they may be renderedwith a different appearanceand animate separately from the main pointer.

They are independent units which can be combinedand positioned around the pointerto communicate different ideas.

Since they are independent,they can be combined with any pointer style.

Here's a demonstration of how the same set of accessories --two arrows indicating draggability --can be combined with different pointer styles.

On the left, they're combined with a lift effectwhere the pointer merges with the view and lifts it up.

In the middle, they're alongside a highlight effect,where the pointer turns into a rounded rectangleand goes under the view.

On the right, they appear with the default system pointerusing the new UIPointerStyle.system() API.

So we're able to provide this additional contextwhile still using the ideal effect for the situation,without sacrificing the liveliness of the pointer,and while still maintaining its deep relationshipwith the app's UI.

Just like it animates between pointer styles,the system will automatically animate the appearanceand disappearance of accessories.

It'll also seamlessly animatebetween accessory shapes and position.

The act of transitioning accessorieswhile a given effect is active can be meaningful.

Such a transition can be used to communicatea change in state or behavior in the underlying UI.

In the example on the left,the transition from a plus to a no signmay indicate that an operation that was previously possibleis no longer permitted.

Pointer accessories are composed of a UIPointerShapeand a UIPointerAccessory.Position,which describes the desired positionas an offset from the pointer's midpointand an angle from the top.

For convenience, UIKit provides some predefined valuesfor positions around the pointer.

If the predefined positions don't quite fit your needs,you can use them as a starting pointand customize individual properties.

This example starts with the topRight positionand customizes the offset.

You can also define entirely custom positions,as in this example,which creates a position with a custom offset and angle.

To set up the example we saw at the beginning of this segment,we'll create a UITargetedPreview with our viewand use that to create a UIPointerStylewith a lift effect.

Then we'll set the style's new accessories propertyto an array that contains our two arrow accessories.

UIKit provides a premade arrow accessory,so we can just create two of thosepositioned on the left and right sides of the effect.

So now when the pointer hovers over this view,the two arrows animate out as the view lifts,hinting that it can be dragged.

If you've ever tried to implementthis sort of interactionwhere a view with a pointer effect is draggable,you've probably noticed something like this.

When the pointer reaches the edge of the pointer region,it disengages from the lifted view and the effect ends.

This is usually desirable, since it prevents the pointerfrom sticking to views as it moves around.

However, in scenarios like this, the ideal experiencewould be for the pointer effect to remain stableand latch to the view and follow it along as it's dragged.

To better enable these sorts of interactions,iPadOS 15 introduces the concept of latchingAxeson UIPointerRegion.

When a region latches along a given axis,its pointer effect follows the pointer along the axiswhen the primary mouse button is pressed.

A horizontally latching region lets you drag freelyalong the x-axis while still rubberbanding along the y-axis.

A vertically latching onelets you drag freely along the y-axis.

And one that latches along bothlets you drag freely along both axes.

These new tools can be used to buildsome really powerful new experiences.

Here they are combined in a document editing applike Pages or Keynote.

This image can be selected using band selection.

Selecting the image causes dragging indicators to appear,and when the pointer hovers over an indicator,accessories appear to hint athow the image will be resized if it's dragged.

And finally, latching allows the pointer effect and accessoriesto follow the axis-locked resize gesture.

These are just some of the enhancementsiPadOS 15 brings to the iPad.

Take advantage of them where applicableto really maximize the utility of your app.

Adopt prominent scenes to give people a focused,uninterrupted view of your app's content.

Empower them to achieve complex tasks quicklywith the new keyboard shortcuts menu,and boost their productivity with the new pointer features.

Thanks for watching!♪

4:56 -Build an "Open in New Window" action

5:43 -Use an alternate action with UIWindowScene.ActivationAction

6:58 -Present a scene from a collection view with a gesture

7:28 -Present a scene from a custom view with a gesture

8:53 -Customize scene transition preview

10:18 -Save scene state

11:16 -Save scene state with interaction state

12:13 -Restore scene state

13:15 -Restore scene state asynchronously

17:15 -Modify the main menu

17:37 -Add key commands to the main menu

18:19 -Add a custom menu category

22:38 -Customizing key command performability

23:26 -Customizing key command appearance

28:47 -Supporting multi-selection using UIBandSelectionInteraction

33:01 -Customizing a predefined pointer accessory position

33:14 -Creating a custom pointer accessory position

33:27 -Pointer Accessories

## Code Samples

```swift
let
 
<
#newSceneAction#
>
 
=
 
UIWindowScene
.
ActivationAction
({ 
_
 
in


    
// Create the user activity that represents the new scene content.

    
let
 userActivity 
=
 
NSUserActivity
(activityType: 
<
#
User
 
Activity
 
Type
#
>
)

    
// Return the activation configuration.

    
return
 
UIWindowScene
.
ActivationConfiguration
(userActivity: userActivity)

})
```

```swift
// Create an action to use when multiple scenes are not available.


let
 alternateAction 
=
 
UIAction
(title: 
<
#
Alternate
 
Action
 
Title
#
>
,
                               image: 
<
#
Alternate
 
Action
 
Image
#
>
,
                             handler: { 
_
 
in

    
<
#
Perform
 
Alternate
 
Action
#
>

})


// Create the scene activation action with the alternate.


let
 newSceneAction 
=
 
UIWindowScene
.
ActivationAction
(alternate: alternateAction) { 
_
 
in


    
// Create the user activity that represents the new scene content.

    
let
 userActivity 
=
 
NSUserActivity
(activityType: 
<
#
Scene
 
Activity
 
Type
#
>
)

    
// Return the activation configuration.

    
return
 
UIWindowScene
.
ActivationConfiguration
(userActivity: userActivity)
}
```

```swift
func
 
collectionView
(
_
 
collectionView
: 
UICollectionView
,
                    
sceneActivationConfigurationForItemAt
 
indexPath
: 
IndexPath
,
                    
point
: 
CGPoint
)
 -> 
UIWindowScene
.
ActivationConfiguration
? {

    
// Get the item's user activity.

    
guard
 
let
 itemActivity 
=
 
<
#
User
 
Activity
#
>
 
else
 {
        
// Return nil if item can’t be opened in a dedicated scene.

        
return
 
nil

    }

    
// Return the activation configuration.

    
return
 
UIWindowScene
.
ActivationConfiguration
(userActivity: itemActivity)
}
```

```swift
// Create an activation interaction.


let
 newSceneInteraction 
=
 
UIWindowScene
.
ActivationInteraction
 { interaction, point 
in

    
// Get the activity for specific point in view.

    
guard
 
let
 userActivity 
=
 
<
#
User
 
Activity
#
>
 
else
 { 
return
 
nil
 }

    
// Return an activation configuration.

    
return
 
UIWindowScene
.
ActivationConfiguration
(userActivity: userActivity)

} errorHandler: { error 
in

    
// Present the content in another manner.

    
<
#
Present
 
Content
#
>

}


// Add interaction to the view.


<
#
View
#
>
.addInteraction(newSceneInteraction)
```

```swift
// Create the activation configuration.


let
 itemActivity 
=
 
NSUserActivity
(activityType: 
<
#
User
 
Activity
 
Type
#
>
)

let
 configuration 
=
 
UIWindowScene
.
ActivationConfiguration
(userActivity: itemActivity)


// If the cell has a subview to use as the preview, create the custom preview.


if
 
let
 cell 
=
 collectionView.cellForItem(at: indexPath) 
as?
 
<
#
Expected
 
Cell
 
Class
#
>
 {
    configuration.preview 
=
 
UITargetedPreview
(view: cell
.<
#
Subview
 
For
 
Preview
#
>
)
}


// Return the activation configuration.


return
 configuration
```

```swift
func
 
stateRestorationActivity
(
for
 
scene
: 
UIScene
)
 -> 
NSUserActivity
? {
    
guard
 
let
 viewController 
=
 
self
.window
?
.rootViewController 
as?
 
<
#
Expected
 
View
 
Controller
 
Class
#
>
 
else
 {
        
return
 
nil

    }

    
let
 stateActivity 
=
 
NSUserActivity
(activityType: 
<
#
State
 
Restoration
 
Activity
 
Type
#
>
)

    stateActivity.addUserInfoEntries(from: [
        
// Save content of a text field.

        
<
#
Content
 
Key
#
>
: viewController
.<
#
Text
 
Field
#
>
.text
    ])

    
return
 stateActivity
}
```

```swift
func
 
stateRestorationActivity
(
for
 
scene
: 
UIScene
)
 -> 
NSUserActivity
? {
    
guard
 
let
 viewController 
=
 
self
.window
?
.rootViewController 
as?
 
<
#
Expected
 
View
 
Controller
 
Class
#
>
 
else
 {
        
return
 
nil

    }

    
let
 stateActivity 
=
 
NSUserActivity
(activityType: 
<
#
State
 
Restoration
 
Activity
 
Type
#
>
)

    stateActivity.addUserInfoEntries(from: [
        
// Save content of a text field.

        
<
#
Content
 
Key
#
>
: viewController
.<
#
Text
 
Field
#
>
.text,

        
// Save interaction state of a text field.

        
<
#
Interaction
 
State
 
Key
#
>
: viewController
.<
#
Text
 
Field
#
>
.interactionState
    ])

    
return
 stateActivity
}
```

```swift
func
 
scene
(
_
 
scene
: 
UIScene
, 
restoreInteractionState
 
stateRestorationActivity
: 
NSUserActivity
)
 {
    
guard
 
let
 viewController 
=
 window
?
.rootViewController 
as?
 
<
#
Expected
 
View
 
Controller
 
Class
#
>
,
          
let
 userInfo 
=
 stateRestorationActivity.userInfo
    
else
 { 
return
 }

    
if
 
let
 content 
=
 userInfo[
<
#
Content
 
Key
#
>
] 
as?
 
String
 {
        
// Restore the content first.

        viewController
.<
#
Text
 
Field
#
>
.text 
=
 content

        
// Then, restore the text field’s interaction state.

        
if
 
let
 interactionState 
=
 userInfo[
<
#
Interaction
 
State
 
Key
#
>
] {
            viewController
.<
#
Text
 
Field
#
>
.interactionState 
=
 interactionState
        }
    }
}
```

```swift
func
 
scene
(
_
 
scene
: 
UIScene
, 
restoreInteractionState
 
stateRestorationActivity
: 
NSUserActivity
)
 {
    
guard
 
let
 viewController 
=
 window
?
.rootViewController 
as?
 
<
#
Expected
 
View
 
Controller
 
Class
#
>
 
else
 { 
return
 }

    
// Request an extension.

    scene.extendStateRestoration()

    
// Fetch content asynchronously.

    
<
#
self
.someAsyncFunction#
>
 { result 
in

        
<
#
Restore
 
Content
#
>


        
// Signal that state has been restored.

        scene.completeStateRestoration()
    }
}
```

```swift
override
 
func
 
buildMenu
(
with
 
builder
: 
UIMenuBuilder
)
 {
    
super
.buildMenu(with: builder)
    
    
// Ensure the builder is modifying the main menu.

    
guard
 builder.system 
==
 .main 
else
 { 
return
 }
    
    
// Use the builder to modify the main menu...

}
```

```swift
// Create a menu with key commands.


let
 tabMenu 
=
 
UIMenu
(options: .displayInline, children: [
    
UIKeyCommand
(title: 
NSLocalizedString
(
"New Tab"
, 
...
),
                 action: #selector(
BrowserViewController
.newTab(
_
:)),
                 input: 
"t"
,
                 modifierFlags: .command),
    
UIKeyCommand
(
...
)
])


// Insert tabMenu into the File menu.

builder.insertChild(tabMenu, atStartOfMenu: .file)
```

```swift
// Create a "Bookmarks" menu.


let
 bookmarksMenu 
=
 
UIMenu
(title: 
NSLocalizedString
(
"Bookmarks"
, 
...
),
                           children: [
...
])


// Insert the Bookmarks menu into the root menu, after View.

builder.insertSibling(bookmarksMenu, afterMenu: .view)


// Insert another menu into the Bookmarks menu.


let
 sortBookmarksMenu 
=
 
UIMenu
(
...
)
builder.insertChild(sortBookmarksMenu, atEndOfMenu: bookmarksMenu.identifier)
```

```swift
override
 
func
 
canPerformAction
(
_
 
action
: 
Selector
, 
withSender
 
sender
: 
Any
?
)
 -> 
Bool
 {
    
if
 action 
==
 
#selector
(closeTab(
_
:)) {
        
return
 
!
openTabs.isEmpty
    } 
else
 {
        
return
 
super
.canPerformAction(action, withSender: sender)
    }
}
```

```swift
override
 
func
 
validate
(
_
 
command
: 
UICommand
)
 {
    
if
 command.action 
==
 
#selector
(toggleBookmark(
_
:)) {
        
if
 currentTab.isInBookmarks {
            command.title 
=
 
NSLocalizedString
(
"Add to Bookmarks"
, 
...
)
        } 
else
 {
            command.title 
=
 
NSLocalizedString
(
"Remove from Bookmarks"
, 
...
)
        }
    } 
else
 {
        
return
 
super
.validate(command)
    }
}
```

```swift
// Support multi-selection using UIBandSelectionInteraction.



let
 selectionInteraction 
=
 
UIBandSelectionInteraction
 { [
weak
 
self
] interaction 
in

    
guard
 
let
 strongSelf 
=
 
self
 
else
 { 
return
 }
            
    
// Handle selection by responding to interaction state.

    
if
 interaction.state 
==
 .selecting {
        strongSelf.selectItemsInRect(interaction.selectionRect)
    } 
    
else
 
if
 interaction.state 
==
 .ended {
        strongSelf.finalizeSelection()
    }
}

view.addInteraction(selectionInteraction)
```

```swift
var
 position 
=
 
UIPointerAccessory
.
Position
.topRight
position.offset 
=
 
40.0
```

```swift
let
 position 
=
 
UIPointerAccessory
.
Position
(offset: 
23.0
, angle: .pi 
*
 
1.25
)
```

```swift
// Attach two arrow accessories to a lift pointer effect.



func
 
pointerInteraction
(
_
 
interaction
: 
UIPointerInteraction
, 
styleFor
 
region
: 
UIPointerRegion
)
 -> 
UIPointerStyle
?
{
    
let
 preview 
=
 
UITargetedPreview
(view: 
self
)
    
let
 style 
=
 
UIPointerStyle
(effect: .lift(preview))

    
if
 
#available
(
iOS
 
15.0
, 
*
) {
        style.accessories 
=
 [
            .arrow(.left),
            .arrow(.right)
        ]
    }

    
return
 style
}
```


# Wwdc2021 10061

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Meet TextKit 2Meet TextKit 2: Apple's next-generation text engine, redesigned for improved correctness, safety, and performance. Discover how TextKit 2 can help you provide a better text experience for international audiences, create more diverse layouts by mixing text content with visual content, and ensure smooth scrolling performance. We'll introduce the latest APIs, dive into some practical examples, and provide guidance for modernizing your apps.ResourcesTextKitUsing TextKit 2 to interact with textHD VideoSD VideoRelated VideosWWDC22What's new in TextKit and text viewsWWDC21What's new in AppKitWhat's new in UIKit

Meet TextKit 2: Apple's next-generation text engine, redesigned for improved correctness, safety, and performance. Discover how TextKit 2 can help you provide a better text experience for international audiences, create more diverse layouts by mixing text content with visual content, and ensure smooth scrolling performance. We'll introduce the latest APIs, dive into some practical examples, and provide guidance for modernizing your apps.

TextKit

Using TextKit 2 to interact with text

HD VideoSD Video

HD Video

SD Video

What's new in TextKit and text views

What's new in AppKit

What's new in UIKit

Search this videoâ€¦Donna: Hi.I'm Donna Tom, and I'm a TextKit engineer.My colleague Chris Willmore will join me later in this video.We're introducing TextKit 2,Apple's next-generation text engine.To understand what TextKit 2 is all about,let's briefly review the original TextKit,which we'll call TextKit 1.TextKit 1 is a text enginethat drives text layout and displayacross all of Apple's platforms.Text controls in UIKit and AppKit use TextKit 1to manage the storage and control the layoutof text content.TextKit 1 first appeared on the system in OpenStepover 20 years ago.It's grown and evolved with us over the yearsfrom macOS 10.0to iOS 7to macOS 11 and iOS 14.It's pretty amazingthat TextKit 1 still powers so much essential functionalityacross all Apple devices.Technology design and engineering principleshave changed a lot over the decades.Since TextKit 1 is tied to its original principles,it's become more challenging over the yearsto provide APIs that integrate wellwith our newer technologieswhile still delivering a high standard of performance.That's why we've built TextKit 2.TextKit 2 is Apple's next-generation text engine,built on a set of forward-looking design principles.And guess what?You're already using TextKit 2 on your Mac.In Big Sur,we updated many of the text components across the OSto use TextKit 2 behind the scenes.Big surprise:you've been using TextKit 2 since macOS 11.Now, let's briefly review the architecturethat let us do this.TextKit 2 coexists with TextKit 1.Just like its predecessor,TextKit 2 is built on top of Foundation,Quartz, and Core Text.Text controls in UIKit and AppKitare built on top of TextKit 2.TextKit 2 also loosely retains the MVC designof its predecessor.The view portion remains in the view objectsof the UIKit and AppKit frameworks,while there are new versions of our old friends,NSTextStorage and NSLayoutManager.In addition to these new versions,there are many more new classes and protocolsjoining the model and controller layers.There are a quite a few of them, but don't be alarmed.These new components are simple,focused, and powerful in combination.They make it easier for you to expresswhat you want to do with your textand worry less about how the system accomplisheswhat you want.Now that we've gotten an architectural viewof the system,let's dive into the details.First, we're going to discuss the core design principlesof TextKit 2and how these principles will change the way you thinkabout customizing the storage,layout, and display of text in your apps.After that,Chris will walk you througha TextKit 2 sample app we've createdto collaborate on a book of recipes.This app uses the new TextKit 2 classesto lay out and display text in CALayers.Here, you'll get to learnhow the design principles work in practice.Finally,we'll cover some important technical detailsfor modernizing your apps for TextKit 2.So let's get started with the design principles.The core high-level design principles of TextKit 2are correctness, safety, and performance.We've taken a balanced approach.All three principles are important,so there is no priority to the orderin which we discuss them.Each of these high-level design principlesinforms a specific design change in the system.For correctness, TextKit 2 abstracts away glyph handling.For safety,TextKit 2 places a heavier focus on value semantics.And for performance,TextKit 2 uses viewport-based layoutand rendering.We'll begin with correctness.In this area, we've abstracted away glyph handlingto provide a consistent experiencefor international text.Apple devices are used everywhere around the world,so it's really important to provide correct layout,rendering, and interaction for textin all languages and scripts.We want everyone to be able to read and interactwith text on their devices.And the design of some of the TextKit 1 APIsmakes it difficult to work with international textin a way that's universally correct.To understand why,we first need to understandwhat a glyph is.A glyph is a visual representationof a variable numberof characters.In many Western languages,one glyph usually representsone character,but this is not always true.You can have multiple glyphs representing a single character,or it could be the other way around.A single glyph could representmultiple characters.This single glyphused to representmultiple charactersis called a ligature.There aren't too many ligaturesin Western languages,and they don't usually affectthe legibility of the text.You can still read itjust fine without ligatures.But that's not truefor all languages.Scripts like Arabicand Devanagariuse lots of ligatures,and they do affect the legibility.Check out this word in Arabic script.It's an Urdu word that means "moment."Now take a momentto compare these two renderings.The full word,drawn with ligatures on the right,appears very differentfrom the individual characterson the left.Native readers of the languagewould consider the version on the left to be illegible.Many of the APIs in TextKit 1require working with a glyph index or range.For example,to get the bounding rectangle of some text,you need to know the glyph range of the text you want.If the text is in a Western language,figuring out the right glyph range isn't too bad.In this English example,it's pretty easy to find the glyph rangefor the first four characters of the text.Now consider Kannada,a script and languagespoken by millions of people in India.Not only does it use lots of ligatures,the glyphs can be reordered and combinedin all sorts of interesting ways.This Kannada word meaning "October"features a split vowel at character index four,so that gets split up into two glyphs.Then the one on the left gets reorderedbetween the glyphs representing characters one and twobefore the ligature for two is applied.The glyph representing the character at index threealso gets substituted to a conjoining form.In the final word,it's drawn below one of the glyphsin the split vowel.Now,if you didn't understand any of what I just said,that is totally OK.These are detailsthat the framework should be handling for youso that you can focus on building your app.The point is,it's not possibleto find the glyph rangefor the first four charactersof text like this.There is no single glyph rangethat will representthose four characters.And since many TextKit 1 APIsrequire a glyph range,using those APIscan potentially breaklayout and renderingfor complex scripts like this.And that's why TextKit 2 abstracts away glyph handling.TextKit 2 renders all text with Core Text--so you'll automatically get correct renderingfor complex scripts.You won't have to manage glyphs at all with TextKit 2.Instead, you use higher-level objectsto control text layout and interactions.Meet NSTextSelection,one of these higher-level objects.It contains all the necessary contextto represent a text selection,such as its granularity,its affinity,and the possibly disjoint ranges of textthat make up the selection.These properties on NSTextSelectionare read only,so you won't modify instances of the selection objectto change them.Instead,you use an instance of NSTextSelectionNavigationto perform actions on text selections,receiving new instances of NSTextSelectionthat represent the resulting selection.You can ask the navigation objectto give you selectionsresulting from tapor mouse-down eventsat a point on the screenor get a new selection resultingfrom navigating forwardor backward.This makes it easierto do things, like extend the selection forwardby one wordand get the correct result,accounting for bidirectional textin right-to-left languages.Now I wanna call your attentionto something interestingabout these new selection APIs.This method takesa NSTextLocation.This is another new objectin TextKit 2.Meet NSTextLocation and NSTextRange.These are very similar to the UITextPositionand UITextRange classes from UIKit,except you're not required to subclass them.Most of the time,you'll use the default location and range objectswith TextKit 2.Using objects instead of integersallows for more expressive document modelsbecause the ranges are defined in terms of locationsrelative to each other.The HTML document object modelis a good example of this.Since it has nested elements,a location needs to representboth the absolute positionin the documentand also the positionin the visible text.This can't be expressedwith a single numerical index.And that's it for correctness.Next up is safety.In this area, we've designed TextKit 2with a greater emphasis on value semanticsto better align with the goals of technologieslike Swift and SwiftUI.And when I say "value semantics,"I'm not talking about value types.We did not make NSLayoutManager into a struct.Value types keep a unique copy of their data,which prevents mutation of that data.This makes your code safer and more stableby removing unintended sharingand associated side effects.But value typesare not the only way to get this benefit.Immutable classes have propertiesthat cannot be changed after initialization,which also prevents mutation of their data.These classes behave like value types,so we refer to them as having value semantics.If you want to change the datain one of these objects,you have to make a brand-new instanceto replace the original one.And many of the classesin TextKit 2are designed in this way.To illustrate the benefits of this design change,let's refresh our memory on the design of TextKit 1.The flow of textfrom the storage to the screenused to work like this.Updates to the text storage notified the layout manager,which would then generate glyphs,position them, and draw them directly into the view.With this approach of drawing glyphs directly into the view,it's difficult to figure outwhere to separate the textto create spaces for custom drawing.To understand what I mean by that,check out this sneak-peek screenshotfrom the sample app,where I've left some comments on a recipe.Notice how the comment appearsright underneath the recipe it's referring toand it's drawn with this distinct, bubble-shaped,indigo background and white text.What approach should we taketo insert comments in the correct placeand make them look different from the rest of the text?You might expect to do thisby dividing the recipe text into meaningful units,or elements,putting each comment in its own element,and positioning each commentafter the recipe it's related to,while providing instructions for how to draw the comments.With TextKit 1, the reality is quite different.You have to worry about a lot of details,like finding the glyph index,making sure that the glyph is not in the middle of a grapheme cluster,adjusting that glyph index if it is,changing the line spacing,and possibly customizing the line-fragment geometry.And these details are not relevantto what you're trying to do.So with TextKit 2,we're aiming to make the expectation into reality.We've changed the flow of text through the systemto make approaches like this possible.Here's how that flow works in TextKit 2.Updates to the text storage go through a new objectcalled the content manager.The content manager divides the text up into elementsand keeps track of them.When it's time for layout,the text layout manager asks the content managerfor the elements.Then the text layout manager lays out the elementsinto the text containerand generates layout fragmentsthat contain the layout and positioning information.When it's time for display,the layout fragments are handed offto the ViewportLayoutController,which coordinates the positioningand layout of those fragmentsin your rendering surface of choice,whether it's a view or a layer.As you can tell,there are a lot of new objects involved in this process.And this is where the emphasis on value semantics comes in.You control the layout and display of your textby hooking into the system at the right pointand obtaining the information you needfrom objects that use value semantics.To make changes,you create new instancesof the value objectswith the changes you wantand give them backto the system.The system uses the valuesfrom your replacement objectsfor layout and display.So now, let's meet these new objectsand identifythe different points of the systemwhere you can receive or replace them.We'll start with the storage objects.Meet NSTextElement.Elements are the building blocks of your document.Each element represents a portion of the contentand contains a rangethat describes where it is in the document.And elements have value semantics.Their properties, including the range,are immutable and cannot be changedafter creating the element.Modeling the document as a series of elementsrather than a series of charactersgives us a lot more power.We gain the ability to easily distinguishwhat kind of content a given element represents,whether it's a paragraph of text,an attachment,or some other custom type.And we can make decisions on how to lay out elementsbased on their type.Now let's meet NSTextContentManager.The content manager knows how to generate elementsfrom the text contentand keeps track of the ranges of those elementswithin the overall document.It also knows how to work with the backing storeand how to generate new elementswith updated rangeswhen the content in the backing store changes.Think of the content manager as a wrapperfor the backing store.The content manager provides an interfacefor translating the raw data into elements.NSTextContentManager and NSTextElementare both abstract types,so you could subclass themif you need to use a custom document modelor a custom backing store.The headers and documentation provide guidanceon how to do this.But most of the time,you can use the default ones that TextKit 2 provides.Meet NSTextContentStorage and NSTextParagraph.These are the default content manager and element types.NSTextContentStorage is a content managerthat uses an NSTextStorage as the backing store.It knows how to divide the contents of the text storageinto paragraph elements,which are instances of NSTextParagraph.NSTextContentStorage also knowshow to generate updated paragraph elementswhen the text in the text storage changes.This brings me to an important point.When making changes to the underlying text storage,you should wrap your updates in thisperformEditingTransaction method.This ensuresthat the other parts of the TextKit 2 systemare notified of your changes.You can do some cool stuffwith the content storage delegateswithout having to implementa full NSTextContentManager subclass.Later in this video,Chris will cover how to use content delegatesto change the comment font and colorwithout modifying the text storageand how to hide comments altogether.So stay tuned for more details.OK.Now we understand how TextKit 2 creates elementsfrom your text content.That takes care of the first two stepsfrom our new approach.The content storage automaticallydivides the text into paragraph elements,and it knowshow to create new paragraphs for the new comments.Next,let's figure out how we can accomplishthe last two steps:the positioning and display of comments.Returning to our flow diagram,we need to get layout informationfor our comment elements.There are new layout objects to help us with these tasks.Let's meet them now.Meet NSTextLayoutManager.The text layout manager controls the text layout process.NSTextLayoutManager is similarto the old NSLayoutManager from TextKit 1with one major difference:NSTextLayoutManager does not deal with glyphs.Instead,NSTextLayoutManager takes text elements,lays them out into the text container,and generates layout fragments for those elements.You work with layout fragmentsto get layout information for text elements.So now let's learn about layout fragments.Meet NSTextLayoutFragment.A layout fragment contains layout informationfor one or more text elements.Just like elements,they use value semanticsand their properties are immutable.So the text layout managerwill create layout fragments for each of our comment elements,and then we can use the informationfrom the layout fragmentsto position and display them.Layout fragments communicate layout informationthrough three properties:an array of textLineFragments,the layoutFragmentFrame,and the renderingSurfaceBounds.If you want to customize or change the layout,it's essential to understand the information you getwith each of these properties.So we'll go over that next.For the first property,we'll meet NSTextLineFragment.Line fragments contain measurement informationfor each line of text in the layout fragment.These are usefulfor obtaining geometric informationfor specific linesor for counting the number of lines in a layout fragment.The second property, the layout fragment frame,describes how the text in the layout fragmentis laid out inside the text container area.In TextKit 2,text layout is basically stacking upthe layout fragment frames within the container.Think of these frames like tiles.The system is dividing up the text container areainto tiles, where each layout fragmentis a single tile.Empty lines have their own layout fragment frame,as shown in the diagram.In general, layout fragment framesare useful for positioning other views in your UInear the fragment contentsor for calculating the total height of the text content.Now, this frame does not accurately representthe space neededto draw the text itself.That information comesfrom the third property.The rendering surface boundsdescribes the area requiredto draw the text.This is the rectangleyou want to useto get the size of the textin the view's coordinate space.And this is differentfrom the layout fragment framebecause the text can overshootthe edges of the fragment frame.This happens with diacriticsor, as shown here,with long descendersin italic fonts.Notice how the bottom-left edge of the Jsticks out just a little bitfrom the layout fragment frame.It doesn't stick out that much,so here's a more extreme example.Some fonts, like Zapfino,have glyphs that extend very faroutside the typographic bounds.The rendering surface boundswill be much largerthan the layout fragment framein this case.Now that we understand the layout informationthat layout fragments provide,let's back up a bitand talk about how to use this informationto customize the layout of text elements.Since layout fragments are immutable,you can't directly change the layout informationon a fragment.Going back to our flow diagram,we need to hook into the layout processand create new instancesof NSTextLayoutFragmentwith the information we want to change.And you hook into the layout processusing this delegate methodon NSTextLayoutManager.This method gets called during the layout processwhen the text layout manageris generating the layout fragmentsfrom the elements.Here you have an opportunityto create your own layout fragmentfor an element.That takes care of the last two stepsin our approach to the comment problem.We'll handle the positioning and custom drawingof our comment layout fragmentby using a subclass of NSTextLayoutFragmentand providing instances of our custom fragmentin the text layout manager delegate.Later in this video,Chris will demonstrate how this is done in our sample app.And that's safety.Now let's move on to performance.Performance is one of the greatest challengesfor any text engine.TextKit 2 is extremely fastfor an incredibly wide range of scenarios,from quickly rendering labels that are only a few lines eachto laying out documents that are hundreds of megabytesbeing scrolled through at interactive rates.And for these scenarios,when you're scrolling through these really large documentsat variable rates,noncontiguous text layoutis absolutely essential for great performance.Let's review the differencebetween contiguous and noncontiguous layout.This diagram shows a documentwhere the yellow rectanglerepresents the visible content areaon the screen.Contiguous layout startsat the very beginning of the documentand goes in orderfrom the beginning to the end of the text.So if you scroll to some point in the middle of the document,contiguous layout performs layoutfor all of the text that came before that point.This includes all the textthat's been scrolled off the screen,all the way back to the beginning.And if there's a lot of text,the performance can be slowand you can get animation hiccups when scrolling.In the worst case, it can hang.In contrast,noncontiguous layout meanswe can lay out a piece of the textanywhere within the documentwithout laying out the pieces that come before it.Now when you scroll to the middle of the document,layout happens for that visible area right away.This improves performanceby performing layout only for the portions of textthat are visible on the screen,plus an additional over-scroll region,resulting in a smoother scrolling experience.And layout in TextKit 2 is always noncontiguous.In contrast,noncontiguous layout is optional in TextKit 1.It's enabled using a boolean propertyon NSLayoutManager.This API is simple, but because it is simple,it can't express information about the state of the layoutat the time you request layout information.Noncontiguous layout relies on estimatesthat may change lateronce other portions of the documenthave been laid out.With TextKit 1,you can only turn noncontiguous layout on or off.There is no ability to controlwhich parts of the document get laid outand no way to know when layout finishesand the layout estimates are updated to the real values.The TextKit 2 API is richer and more expressive.TextKit 2 gives you consistent layout informationfor elements in the visible content areaand notifies youwhen the layout updates for that visible area.This area is called the viewport.You manage the viewport by adjusting or relocating it,and you receive callbacks before, during,and after viewport layout.For optimum performance,your code should focuson working with layout informationinside the viewport area.Avoid requesting layout informationfor elements outside the viewport when possible.The layout informationfor elements outside the viewportmight not be accurateunless you explicitly askto ensure layout for the text rangescorresponding to those elements.This call can be expensive, especially for large documents.Revisiting our flow diagram from earlier,there's another new controller classto help us manage the viewport.Meet NSTextViewportLayoutController.This is the source of truth for viewport layout information.It talks to the text layout managerto get layout fragmentsfor elements within the viewport area.You can access the viewport layout controllerthrough the property on the text layout manager.Now that we've met the viewport layout controller,let's talk about how to participatein the viewport layout process.The viewport layout controllercalls three important methods on its delegateduring the viewport layout process:TextViewportLayoutController WillLayout,textViewportControllerconfigureRenderingSurface FortextLayoutFragment,and textViewportLayoutController DidLayout.First,the viewport layout controller calls the willLayout methodbefore laying out elements in the viewport.Here is where you do any setup workto prepare for layout,such as clearing out the contentsof the view or layer.Next,the viewport layout controller calls configureRenderingSurfacefor every layout fragment that's visible in the viewport.Here is where you update the geometryof each fragment view or layer.Finally,the viewport layout controllercalls the didLayout methodafter it's finished laying outall of the layout fragmentsvisible in the viewport.And here's where you performany needed updatesafter viewport layoutis finished,like if you wantedto adjust the viewport to make the last elementfully visible on the screen.And that sums it up for performance.Now I'll hand it off to Christo show you how to use TextKit 2 in practice.Thank you, Donna.We wrote a sample appthat demonstrates some of the different waysyou can use TextKit 2to lay out and interact with text in your app.You can download the sample code used in this video.Let's open it up and try it out.We're using this collaboration appto review a book of recipesso we can figure outwhat we want to make for lunch.Scrolling through the recipes works as expected,but something special is happening behind the scenes:Only the paragraphs that are visible in the viewportare being drawn.And instead of every paragraphbeing renderedon the same big surface,each paragraph is being rendered into its own layer.If I click the Show Bounds buttonin the toolbar here,these colored rectangles appear.The orange rectangle shows the bounds of each layer.Drawing textinto separate layerslets us implement a fun feature:I can leave comments on the recipes.Now, I think an egg sandwich sounds pretty good,so I'm going to double-click on this paragraphand type, "hey this sounds pretty good,"and hit Enterto insert the comment.I've just inserteda new paragraphinto the document.The bubble background is being drawnby a custom subclassof NSTextLayoutFragmentcalled BubbleLayoutFragment.More on that later.What's special is,as I insert commentsinto the document,all of the paragraphsbelow the commentmove to make room for it.If you didn't catch itthe first time,I'm going to click this turtle buttonin the toolbar to enable Slow Mode.Let's add another comment."Yeah let's make it for lunch today."After I hit Enter,the comment is addedto the document below it,and all paragraphs below itanimate slowly.If you wantto hide all the comments,you can clickthe Toggle Comments buttonin the toolbar.This is not actually editingthe underlying document.It's instead askingthe text content managerto skip commentswhen enumerating text elementsfor layout.TextKit 2 works just as well on iOS as it does on macOS.This means the TextKit 2 parts of the macOS appcan be reused on iOS.Let's run it on iPad.We've used those parts to write an iOS versionof our collaboration appwith all the same functionality.I'm long-pressing on a paragraph to leave a comment,then typing, "hey that sounds good"...and hitting Enter.Just like the app on macOS,I can tapthe comment Show/Hide buttonto hide all comments.I've just gone through an appthat uses TextKit 2to lay out, draw, and interact with text.Now let's go over some of the code in the sample appand how TextKit 2 makes it possible.The app demonstrates a lot of the functionalitythat TextKit 2 provides,but I want to focus on two areas for now:how it lays out the text in the viewportusing NSViewportLayoutControllerand how it implements the custom hiding behaviorand rendering of the comments.When the text layout manager is about to lay out the documenteither because it changed,the container size was changed,or a previously unseen portion of the documenthas moved into the viewport,it calls textViewportLayout ControllerWillLayouton its viewport layout delegate.We're using it hereto clear out all the text sublayersand open an animation transaction.For each text elementthat the text layout managerlays out,it calls textViewportLayoutController,configureRenderingSurfaceFor textLayoutFragment.Here we're getting a layerto displaythe text layout fragment in,updating its geometry,animating itto its new position,if possible,and adding itas sublayer of the view.When the layout manager is done laying out,it will call textViewportLayout ControllerDidLayout.We commit the animation transaction,update the selection highlights,and update the content sizeso the scroll thumb is placed correctly.Now let's talk about the comments.TextKit 2 provides several hooksthat you can use to customize layout elementand layout fragment generation.I'm gonna show youhow we take comments in the document,set custom attributes like font and color for display,and draw the bubble behind them.For each paragraph in the document,the text content storage gives its delegate a chanceto customize the attributes on that paragraph.In our implementation,we're setting a custom font and color on commentswithout having to alter the font or colorof the underlying text storage.The text content manager also gives its delegatethe chance to decide which text elements will be shownto the text layout manager during layout.Returning false for a text elementprevents it from being displayed.Here we're hiding commentsby choosing not to enumerate themwithout having to actually delete themfrom the underlying text storage.The text layout manager has a delegate too.By implementing textLayoutManager,textLayoutFragmentFor location in textElement,the delegate can generate a custom text layout fragmentinstead of the defaultNSTextLayoutFragment instancefor a given NSTextElement.In this case,when it encounters an NSTextElementthat represents a comment,it creates a BubbleLayoutFragment,which is a custom subclass of NSTextLayoutFragment.BubbleLayoutFragment overrides the draw methodof NSTextLayoutFragmentto draw the background bubblebefore callingthe base class implementationto draw the text on top.Note that the textis being renderedwith the custom fontand text colorthat we set earlier.I've gone over how the sample app uses TextKit 2to perform viewport-based animated layout of textand how it renders comments in those colorful bubbles,going all the way from custom attributesin the text storageto custom drawing.But there's a lot more in the sample codethat takes advantage of new API provided by TextKit 2,including interpreting mouse eventsto determine the text selection,rendering the text selection highlight,placing the comment popoverat a particular paragraph in the document,and estimating the document height.You can find further discussionof all of these topics in the sample code.Let's go back to Donnato talk about preparing your apps for TextKit 2.Thanks, Chris.That's a fantastic example of how TextKit 2 works in practice.Now that we've gone over what TextKit 2 can do,let's discuss some approaches for app modernization.Everything we've talked about so farapplies to creating your own TextKit 2 stackto use with a generic view or layer.All of the new classes are availablein UIKit with iOS 15 and in AppKit with macOS 12.So if you wanna go this route,you can start writing new code with TextKit 2 today.On the other hand,many apps use the built-in text controls, like text view,to take advantage of all the great, free functionality,like accessibility supportand selection and editing services.Some of these controls have already been updatedto use TextKit 2.If your app uses the built-in controls,there are a few additional detailsto be aware of.Maintaining compatibility is as important to usas it is to you.Since TextKit 1 is such an integral partof the built-in text controls,we're going to great lengths to maintain compatibilityfor apps that are using them.This is why only some controls use TextKit 2 automaticallyin iOS 15 and macOS 12.Additionally,some controls require taking extra steps to use TextKit 2in these OS versions.For AppKit developers,NSTextView does not use TextKit 2 automatically.If you want to use TextKit 2 with a NSTextView,you need to opt in programmaticallyat creation time.This is how to do it.First, create a text layout manager.Next, create a text container.Then associate the text containerwith the text layout managerusing the textContainer property on NSTextLayoutManager.Finally,create your NSTextView using the designated initializerwith the text container.Now you'll have a text view that uses TextKit 2.You can access the text layout managerand text content storagewith new properties on NSTextView.There's just one thing to be careful of.Recall that NSTextView has a layoutManager propertythat allows getting and setting its NSLayoutManager.NSLayoutManager is a TextKit 1 objectand it's not compatible with the TextKit 2 stack.A text view can't have both a layout managerand a text layout manager at the same time.So here's the deal.We added a special compatibility modefor NSTextViewthat switches it to TextKit 1when needed.The text viewcan automatically detectwhether it needsto use this modeand replaceits NSTextLayoutManagerwith NSLayoutManager.For optimum performance,the text view will remainin compatibility modefrom that point forward.Even if you opted in to TextKit 2,your text view will automatically switchto TextKit 1if you explicitly call the layoutManager propertyon your text view or text container.The text view will also switchif it encounters text content that is not yet supportedor detects other conditions that require TextKit 1.And this can happen for field editors as well.Field editors for NSTextField use TextKit 2 by default.But if your text field subclass is requesting layout informationfrom the field editor's layout manager,the field editor will switch to TextKit 1for all text fields in that window.The system will issue notificationsbefore and after a text view switches to TextKit 1.You can observe these notificationsto receive this information.The notification objects contain a referenceto the exact text view that changed modes.For complete detailson the TextKit 1 compatibility mode for AppKit,please refer to the documentationon the Apple Developer portal.For UIKit developers,UITextField uses TextKit 2 automatically in iOS 15.UITextView with TextKit 2 is not available in iOS 15.We're working to ensure maximum compatibilityfor all applications that use UITextView,and there are quite a lot of them.In the meantime,you can review your existing codefor uses of UITextView's layoutManager propertyand think about how to express your intent with TextKit 2.That way,you'll be ready to transition once it's available.And that's a wrap.Now you've met TextKit 2,Apple's new text engine to take us into the future.We look forward to seeing what you'll buildwith TextKit 2.Thanks for watching.[upbeat music]

Donna: Hi.I'm Donna Tom, and I'm a TextKit engineer.My colleague Chris Willmore will join me later in this video.We're introducing TextKit 2,Apple's next-generation text engine.

To understand what TextKit 2 is all about,let's briefly review the original TextKit,which we'll call TextKit 1.TextKit 1 is a text enginethat drives text layout and displayacross all of Apple's platforms.Text controls in UIKit and AppKit use TextKit 1to manage the storage and control the layoutof text content.

TextKit 1 first appeared on the system in OpenStepover 20 years ago.It's grown and evolved with us over the yearsfrom macOS 10.0to iOS 7to macOS 11 and iOS 14.

It's pretty amazingthat TextKit 1 still powers so much essential functionalityacross all Apple devices.Technology design and engineering principleshave changed a lot over the decades.Since TextKit 1 is tied to its original principles,it's become more challenging over the yearsto provide APIs that integrate wellwith our newer technologieswhile still delivering a high standard of performance.

That's why we've built TextKit 2.TextKit 2 is Apple's next-generation text engine,built on a set of forward-looking design principles.And guess what?You're already using TextKit 2 on your Mac.In Big Sur,we updated many of the text components across the OSto use TextKit 2 behind the scenes.Big surprise:you've been using TextKit 2 since macOS 11.Now, let's briefly review the architecturethat let us do this.

TextKit 2 coexists with TextKit 1.

Just like its predecessor,TextKit 2 is built on top of Foundation,Quartz, and Core Text.Text controls in UIKit and AppKitare built on top of TextKit 2.TextKit 2 also loosely retains the MVC designof its predecessor.The view portion remains in the view objectsof the UIKit and AppKit frameworks,while there are new versions of our old friends,NSTextStorage and NSLayoutManager.

In addition to these new versions,there are many more new classes and protocolsjoining the model and controller layers.There are a quite a few of them, but don't be alarmed.These new components are simple,focused, and powerful in combination.

They make it easier for you to expresswhat you want to do with your textand worry less about how the system accomplisheswhat you want.

Now that we've gotten an architectural viewof the system,let's dive into the details.

First, we're going to discuss the core design principlesof TextKit 2and how these principles will change the way you thinkabout customizing the storage,layout, and display of text in your apps.

After that,Chris will walk you througha TextKit 2 sample app we've createdto collaborate on a book of recipes.

This app uses the new TextKit 2 classesto lay out and display text in CALayers.Here, you'll get to learnhow the design principles work in practice.

Finally,we'll cover some important technical detailsfor modernizing your apps for TextKit 2.

So let's get started with the design principles.

The core high-level design principles of TextKit 2are correctness, safety, and performance.We've taken a balanced approach.All three principles are important,so there is no priority to the orderin which we discuss them.

Each of these high-level design principlesinforms a specific design change in the system.

For correctness, TextKit 2 abstracts away glyph handling.

For safety,TextKit 2 places a heavier focus on value semantics.

And for performance,TextKit 2 uses viewport-based layoutand rendering.

We'll begin with correctness.In this area, we've abstracted away glyph handlingto provide a consistent experiencefor international text.Apple devices are used everywhere around the world,so it's really important to provide correct layout,rendering, and interaction for textin all languages and scripts.

We want everyone to be able to read and interactwith text on their devices.And the design of some of the TextKit 1 APIsmakes it difficult to work with international textin a way that's universally correct.

To understand why,we first need to understandwhat a glyph is.A glyph is a visual representationof a variable numberof characters.

In many Western languages,one glyph usually representsone character,but this is not always true.

You can have multiple glyphs representing a single character,or it could be the other way around.A single glyph could representmultiple characters.

This single glyphused to representmultiple charactersis called a ligature.

There aren't too many ligaturesin Western languages,and they don't usually affectthe legibility of the text.You can still read itjust fine without ligatures.

But that's not truefor all languages.Scripts like Arabicand Devanagariuse lots of ligatures,and they do affect the legibility.Check out this word in Arabic script.

It's an Urdu word that means "moment."Now take a momentto compare these two renderings.

The full word,drawn with ligatures on the right,appears very differentfrom the individual characterson the left.

Native readers of the languagewould consider the version on the left to be illegible.

Many of the APIs in TextKit 1require working with a glyph index or range.For example,to get the bounding rectangle of some text,you need to know the glyph range of the text you want.

If the text is in a Western language,figuring out the right glyph range isn't too bad.

In this English example,it's pretty easy to find the glyph rangefor the first four characters of the text.

Now consider Kannada,a script and languagespoken by millions of people in India.

Not only does it use lots of ligatures,the glyphs can be reordered and combinedin all sorts of interesting ways.

This Kannada word meaning "October"features a split vowel at character index four,so that gets split up into two glyphs.

Then the one on the left gets reorderedbetween the glyphs representing characters one and twobefore the ligature for two is applied.

The glyph representing the character at index threealso gets substituted to a conjoining form.

In the final word,it's drawn below one of the glyphsin the split vowel.Now,if you didn't understand any of what I just said,that is totally OK.

These are detailsthat the framework should be handling for youso that you can focus on building your app.

The point is,it's not possibleto find the glyph rangefor the first four charactersof text like this.

There is no single glyph rangethat will representthose four characters.

And since many TextKit 1 APIsrequire a glyph range,using those APIscan potentially breaklayout and renderingfor complex scripts like this.

And that's why TextKit 2 abstracts away glyph handling.TextKit 2 renders all text with Core Text--so you'll automatically get correct renderingfor complex scripts.

You won't have to manage glyphs at all with TextKit 2.Instead, you use higher-level objectsto control text layout and interactions.

Meet NSTextSelection,one of these higher-level objects.

It contains all the necessary contextto represent a text selection,such as its granularity,its affinity,and the possibly disjoint ranges of textthat make up the selection.

These properties on NSTextSelectionare read only,so you won't modify instances of the selection objectto change them.Instead,you use an instance of NSTextSelectionNavigationto perform actions on text selections,receiving new instances of NSTextSelectionthat represent the resulting selection.

You can ask the navigation objectto give you selectionsresulting from tapor mouse-down eventsat a point on the screenor get a new selection resultingfrom navigating forwardor backward.This makes it easierto do things, like extend the selection forwardby one wordand get the correct result,accounting for bidirectional textin right-to-left languages.

Now I wanna call your attentionto something interestingabout these new selection APIs.

This method takesa NSTextLocation.This is another new objectin TextKit 2.

Meet NSTextLocation and NSTextRange.

These are very similar to the UITextPositionand UITextRange classes from UIKit,except you're not required to subclass them.

Most of the time,you'll use the default location and range objectswith TextKit 2.

Using objects instead of integersallows for more expressive document modelsbecause the ranges are defined in terms of locationsrelative to each other.The HTML document object modelis a good example of this.Since it has nested elements,a location needs to representboth the absolute positionin the documentand also the positionin the visible text.This can't be expressedwith a single numerical index.

And that's it for correctness.Next up is safety.

In this area, we've designed TextKit 2with a greater emphasis on value semanticsto better align with the goals of technologieslike Swift and SwiftUI.

And when I say "value semantics,"I'm not talking about value types.We did not make NSLayoutManager into a struct.

Value types keep a unique copy of their data,which prevents mutation of that data.This makes your code safer and more stableby removing unintended sharingand associated side effects.But value typesare not the only way to get this benefit.

Immutable classes have propertiesthat cannot be changed after initialization,which also prevents mutation of their data.

These classes behave like value types,so we refer to them as having value semantics.If you want to change the datain one of these objects,you have to make a brand-new instanceto replace the original one.And many of the classesin TextKit 2are designed in this way.

To illustrate the benefits of this design change,let's refresh our memory on the design of TextKit 1.The flow of textfrom the storage to the screenused to work like this.

Updates to the text storage notified the layout manager,which would then generate glyphs,position them, and draw them directly into the view.

With this approach of drawing glyphs directly into the view,it's difficult to figure outwhere to separate the textto create spaces for custom drawing.

To understand what I mean by that,check out this sneak-peek screenshotfrom the sample app,where I've left some comments on a recipe.

Notice how the comment appearsright underneath the recipe it's referring toand it's drawn with this distinct, bubble-shaped,indigo background and white text.

What approach should we taketo insert comments in the correct placeand make them look different from the rest of the text?You might expect to do thisby dividing the recipe text into meaningful units,or elements,putting each comment in its own element,and positioning each commentafter the recipe it's related to,while providing instructions for how to draw the comments.

With TextKit 1, the reality is quite different.

You have to worry about a lot of details,like finding the glyph index,making sure that the glyph is not in the middle of a grapheme cluster,adjusting that glyph index if it is,changing the line spacing,and possibly customizing the line-fragment geometry.

And these details are not relevantto what you're trying to do.So with TextKit 2,we're aiming to make the expectation into reality.We've changed the flow of text through the systemto make approaches like this possible.

Here's how that flow works in TextKit 2.

Updates to the text storage go through a new objectcalled the content manager.

The content manager divides the text up into elementsand keeps track of them.When it's time for layout,the text layout manager asks the content managerfor the elements.

Then the text layout manager lays out the elementsinto the text containerand generates layout fragmentsthat contain the layout and positioning information.

When it's time for display,the layout fragments are handed offto the ViewportLayoutController,which coordinates the positioningand layout of those fragmentsin your rendering surface of choice,whether it's a view or a layer.

As you can tell,there are a lot of new objects involved in this process.And this is where the emphasis on value semantics comes in.

You control the layout and display of your textby hooking into the system at the right pointand obtaining the information you needfrom objects that use value semantics.

To make changes,you create new instancesof the value objectswith the changes you wantand give them backto the system.The system uses the valuesfrom your replacement objectsfor layout and display.

So now, let's meet these new objectsand identifythe different points of the systemwhere you can receive or replace them.We'll start with the storage objects.

Meet NSTextElement.Elements are the building blocks of your document.Each element represents a portion of the contentand contains a rangethat describes where it is in the document.And elements have value semantics.Their properties, including the range,are immutable and cannot be changedafter creating the element.

Modeling the document as a series of elementsrather than a series of charactersgives us a lot more power.We gain the ability to easily distinguishwhat kind of content a given element represents,whether it's a paragraph of text,an attachment,or some other custom type.And we can make decisions on how to lay out elementsbased on their type.

Now let's meet NSTextContentManager.

The content manager knows how to generate elementsfrom the text contentand keeps track of the ranges of those elementswithin the overall document.It also knows how to work with the backing storeand how to generate new elementswith updated rangeswhen the content in the backing store changes.

Think of the content manager as a wrapperfor the backing store.

The content manager provides an interfacefor translating the raw data into elements.

NSTextContentManager and NSTextElementare both abstract types,so you could subclass themif you need to use a custom document modelor a custom backing store.The headers and documentation provide guidanceon how to do this.But most of the time,you can use the default ones that TextKit 2 provides.

Meet NSTextContentStorage and NSTextParagraph.These are the default content manager and element types.NSTextContentStorage is a content managerthat uses an NSTextStorage as the backing store.

It knows how to divide the contents of the text storageinto paragraph elements,which are instances of NSTextParagraph.NSTextContentStorage also knowshow to generate updated paragraph elementswhen the text in the text storage changes.This brings me to an important point.

When making changes to the underlying text storage,you should wrap your updates in thisperformEditingTransaction method.This ensuresthat the other parts of the TextKit 2 systemare notified of your changes.

You can do some cool stuffwith the content storage delegateswithout having to implementa full NSTextContentManager subclass.

Later in this video,Chris will cover how to use content delegatesto change the comment font and colorwithout modifying the text storageand how to hide comments altogether.So stay tuned for more details.

OK.Now we understand how TextKit 2 creates elementsfrom your text content.That takes care of the first two stepsfrom our new approach.

The content storage automaticallydivides the text into paragraph elements,and it knowshow to create new paragraphs for the new comments.

Next,let's figure out how we can accomplishthe last two steps:the positioning and display of comments.

Returning to our flow diagram,we need to get layout informationfor our comment elements.There are new layout objects to help us with these tasks.Let's meet them now.

Meet NSTextLayoutManager.The text layout manager controls the text layout process.

NSTextLayoutManager is similarto the old NSLayoutManager from TextKit 1with one major difference:NSTextLayoutManager does not deal with glyphs.

Instead,NSTextLayoutManager takes text elements,lays them out into the text container,and generates layout fragments for those elements.

You work with layout fragmentsto get layout information for text elements.So now let's learn about layout fragments.

Meet NSTextLayoutFragment.A layout fragment contains layout informationfor one or more text elements.Just like elements,they use value semanticsand their properties are immutable.

So the text layout managerwill create layout fragments for each of our comment elements,and then we can use the informationfrom the layout fragmentsto position and display them.

Layout fragments communicate layout informationthrough three properties:an array of textLineFragments,the layoutFragmentFrame,and the renderingSurfaceBounds.

If you want to customize or change the layout,it's essential to understand the information you getwith each of these properties.So we'll go over that next.

For the first property,we'll meet NSTextLineFragment.Line fragments contain measurement informationfor each line of text in the layout fragment.

These are usefulfor obtaining geometric informationfor specific linesor for counting the number of lines in a layout fragment.

The second property, the layout fragment frame,describes how the text in the layout fragmentis laid out inside the text container area.In TextKit 2,text layout is basically stacking upthe layout fragment frames within the container.Think of these frames like tiles.The system is dividing up the text container areainto tiles, where each layout fragmentis a single tile.

Empty lines have their own layout fragment frame,as shown in the diagram.In general, layout fragment framesare useful for positioning other views in your UInear the fragment contentsor for calculating the total height of the text content.

Now, this frame does not accurately representthe space neededto draw the text itself.That information comesfrom the third property.The rendering surface boundsdescribes the area requiredto draw the text.This is the rectangleyou want to useto get the size of the textin the view's coordinate space.And this is differentfrom the layout fragment framebecause the text can overshootthe edges of the fragment frame.This happens with diacriticsor, as shown here,with long descendersin italic fonts.Notice how the bottom-left edge of the Jsticks out just a little bitfrom the layout fragment frame.It doesn't stick out that much,so here's a more extreme example.

Some fonts, like Zapfino,have glyphs that extend very faroutside the typographic bounds.

The rendering surface boundswill be much largerthan the layout fragment framein this case.

Now that we understand the layout informationthat layout fragments provide,let's back up a bitand talk about how to use this informationto customize the layout of text elements.

Since layout fragments are immutable,you can't directly change the layout informationon a fragment.

Going back to our flow diagram,we need to hook into the layout processand create new instancesof NSTextLayoutFragmentwith the information we want to change.

And you hook into the layout processusing this delegate methodon NSTextLayoutManager.This method gets called during the layout processwhen the text layout manageris generating the layout fragmentsfrom the elements.Here you have an opportunityto create your own layout fragmentfor an element.

That takes care of the last two stepsin our approach to the comment problem.We'll handle the positioning and custom drawingof our comment layout fragmentby using a subclass of NSTextLayoutFragmentand providing instances of our custom fragmentin the text layout manager delegate.

Later in this video,Chris will demonstrate how this is done in our sample app.

And that's safety.Now let's move on to performance.

Performance is one of the greatest challengesfor any text engine.TextKit 2 is extremely fastfor an incredibly wide range of scenarios,from quickly rendering labels that are only a few lines eachto laying out documents that are hundreds of megabytesbeing scrolled through at interactive rates.And for these scenarios,when you're scrolling through these really large documentsat variable rates,noncontiguous text layoutis absolutely essential for great performance.

Let's review the differencebetween contiguous and noncontiguous layout.

This diagram shows a documentwhere the yellow rectanglerepresents the visible content areaon the screen.

Contiguous layout startsat the very beginning of the documentand goes in orderfrom the beginning to the end of the text.

So if you scroll to some point in the middle of the document,contiguous layout performs layoutfor all of the text that came before that point.

This includes all the textthat's been scrolled off the screen,all the way back to the beginning.And if there's a lot of text,the performance can be slowand you can get animation hiccups when scrolling.In the worst case, it can hang.

In contrast,noncontiguous layout meanswe can lay out a piece of the textanywhere within the documentwithout laying out the pieces that come before it.

Now when you scroll to the middle of the document,layout happens for that visible area right away.

This improves performanceby performing layout only for the portions of textthat are visible on the screen,plus an additional over-scroll region,resulting in a smoother scrolling experience.

And layout in TextKit 2 is always noncontiguous.

In contrast,noncontiguous layout is optional in TextKit 1.

It's enabled using a boolean propertyon NSLayoutManager.This API is simple, but because it is simple,it can't express information about the state of the layoutat the time you request layout information.

Noncontiguous layout relies on estimatesthat may change lateronce other portions of the documenthave been laid out.With TextKit 1,you can only turn noncontiguous layout on or off.

There is no ability to controlwhich parts of the document get laid outand no way to know when layout finishesand the layout estimates are updated to the real values.

The TextKit 2 API is richer and more expressive.

TextKit 2 gives you consistent layout informationfor elements in the visible content areaand notifies youwhen the layout updates for that visible area.

This area is called the viewport.You manage the viewport by adjusting or relocating it,and you receive callbacks before, during,and after viewport layout.

For optimum performance,your code should focuson working with layout informationinside the viewport area.Avoid requesting layout informationfor elements outside the viewport when possible.

The layout informationfor elements outside the viewportmight not be accurateunless you explicitly askto ensure layout for the text rangescorresponding to those elements.This call can be expensive, especially for large documents.

Revisiting our flow diagram from earlier,there's another new controller classto help us manage the viewport.

Meet NSTextViewportLayoutController.This is the source of truth for viewport layout information.It talks to the text layout managerto get layout fragmentsfor elements within the viewport area.You can access the viewport layout controllerthrough the property on the text layout manager.

Now that we've met the viewport layout controller,let's talk about how to participatein the viewport layout process.

The viewport layout controllercalls three important methods on its delegateduring the viewport layout process:TextViewportLayoutController WillLayout,textViewportControllerconfigureRenderingSurface FortextLayoutFragment,and textViewportLayoutController DidLayout.

First,the viewport layout controller calls the willLayout methodbefore laying out elements in the viewport.Here is where you do any setup workto prepare for layout,such as clearing out the contentsof the view or layer.

Next,the viewport layout controller calls configureRenderingSurfacefor every layout fragment that's visible in the viewport.Here is where you update the geometryof each fragment view or layer.

Finally,the viewport layout controllercalls the didLayout methodafter it's finished laying outall of the layout fragmentsvisible in the viewport.

And here's where you performany needed updatesafter viewport layoutis finished,like if you wantedto adjust the viewport to make the last elementfully visible on the screen.And that sums it up for performance.Now I'll hand it off to Christo show you how to use TextKit 2 in practice.Thank you, Donna.We wrote a sample appthat demonstrates some of the different waysyou can use TextKit 2to lay out and interact with text in your app.You can download the sample code used in this video.Let's open it up and try it out.We're using this collaboration appto review a book of recipesso we can figure outwhat we want to make for lunch.Scrolling through the recipes works as expected,but something special is happening behind the scenes:Only the paragraphs that are visible in the viewportare being drawn.

And instead of every paragraphbeing renderedon the same big surface,each paragraph is being rendered into its own layer.

If I click the Show Bounds buttonin the toolbar here,these colored rectangles appear.The orange rectangle shows the bounds of each layer.Drawing textinto separate layerslets us implement a fun feature:I can leave comments on the recipes.Now, I think an egg sandwich sounds pretty good,so I'm going to double-click on this paragraphand type, "hey this sounds pretty good,"and hit Enterto insert the comment.

I've just inserteda new paragraphinto the document.The bubble background is being drawnby a custom subclassof NSTextLayoutFragmentcalled BubbleLayoutFragment.More on that later.

What's special is,as I insert commentsinto the document,all of the paragraphsbelow the commentmove to make room for it.If you didn't catch itthe first time,I'm going to click this turtle buttonin the toolbar to enable Slow Mode.

Let's add another comment.

"Yeah let's make it for lunch today."After I hit Enter,the comment is addedto the document below it,and all paragraphs below itanimate slowly.If you wantto hide all the comments,you can clickthe Toggle Comments buttonin the toolbar.This is not actually editingthe underlying document.It's instead askingthe text content managerto skip commentswhen enumerating text elementsfor layout.

TextKit 2 works just as well on iOS as it does on macOS.This means the TextKit 2 parts of the macOS appcan be reused on iOS.Let's run it on iPad.

We've used those parts to write an iOS versionof our collaboration appwith all the same functionality.I'm long-pressing on a paragraph to leave a comment,then typing, "hey that sounds good"...and hitting Enter.

Just like the app on macOS,I can tapthe comment Show/Hide buttonto hide all comments.

I've just gone through an appthat uses TextKit 2to lay out, draw, and interact with text.Now let's go over some of the code in the sample appand how TextKit 2 makes it possible.

The app demonstrates a lot of the functionalitythat TextKit 2 provides,but I want to focus on two areas for now:how it lays out the text in the viewportusing NSViewportLayoutControllerand how it implements the custom hiding behaviorand rendering of the comments.

When the text layout manager is about to lay out the documenteither because it changed,the container size was changed,or a previously unseen portion of the documenthas moved into the viewport,it calls textViewportLayout ControllerWillLayouton its viewport layout delegate.We're using it hereto clear out all the text sublayersand open an animation transaction.

For each text elementthat the text layout managerlays out,it calls textViewportLayoutController,configureRenderingSurfaceFor textLayoutFragment.Here we're getting a layerto displaythe text layout fragment in,updating its geometry,animating itto its new position,if possible,and adding itas sublayer of the view.

When the layout manager is done laying out,it will call textViewportLayout ControllerDidLayout.We commit the animation transaction,update the selection highlights,and update the content sizeso the scroll thumb is placed correctly.

Now let's talk about the comments.TextKit 2 provides several hooksthat you can use to customize layout elementand layout fragment generation.I'm gonna show youhow we take comments in the document,set custom attributes like font and color for display,and draw the bubble behind them.

For each paragraph in the document,the text content storage gives its delegate a chanceto customize the attributes on that paragraph.In our implementation,we're setting a custom font and color on commentswithout having to alter the font or colorof the underlying text storage.

The text content manager also gives its delegatethe chance to decide which text elements will be shownto the text layout manager during layout.

Returning false for a text elementprevents it from being displayed.Here we're hiding commentsby choosing not to enumerate themwithout having to actually delete themfrom the underlying text storage.

The text layout manager has a delegate too.By implementing textLayoutManager,textLayoutFragmentFor location in textElement,the delegate can generate a custom text layout fragmentinstead of the defaultNSTextLayoutFragment instancefor a given NSTextElement.In this case,when it encounters an NSTextElementthat represents a comment,it creates a BubbleLayoutFragment,which is a custom subclass of NSTextLayoutFragment.

BubbleLayoutFragment overrides the draw methodof NSTextLayoutFragmentto draw the background bubblebefore callingthe base class implementationto draw the text on top.Note that the textis being renderedwith the custom fontand text colorthat we set earlier.

I've gone over how the sample app uses TextKit 2to perform viewport-based animated layout of textand how it renders comments in those colorful bubbles,going all the way from custom attributesin the text storageto custom drawing.But there's a lot more in the sample codethat takes advantage of new API provided by TextKit 2,including interpreting mouse eventsto determine the text selection,rendering the text selection highlight,placing the comment popoverat a particular paragraph in the document,and estimating the document height.You can find further discussionof all of these topics in the sample code.Let's go back to Donnato talk about preparing your apps for TextKit 2.Thanks, Chris.That's a fantastic example of how TextKit 2 works in practice.Now that we've gone over what TextKit 2 can do,let's discuss some approaches for app modernization.

Everything we've talked about so farapplies to creating your own TextKit 2 stackto use with a generic view or layer.

All of the new classes are availablein UIKit with iOS 15 and in AppKit with macOS 12.So if you wanna go this route,you can start writing new code with TextKit 2 today.

On the other hand,many apps use the built-in text controls, like text view,to take advantage of all the great, free functionality,like accessibility supportand selection and editing services.Some of these controls have already been updatedto use TextKit 2.If your app uses the built-in controls,there are a few additional detailsto be aware of.Maintaining compatibility is as important to usas it is to you.Since TextKit 1 is such an integral partof the built-in text controls,we're going to great lengths to maintain compatibilityfor apps that are using them.This is why only some controls use TextKit 2 automaticallyin iOS 15 and macOS 12.

Additionally,some controls require taking extra steps to use TextKit 2in these OS versions.For AppKit developers,NSTextView does not use TextKit 2 automatically.

If you want to use TextKit 2 with a NSTextView,you need to opt in programmaticallyat creation time.

This is how to do it.First, create a text layout manager.Next, create a text container.Then associate the text containerwith the text layout managerusing the textContainer property on NSTextLayoutManager.Finally,create your NSTextView using the designated initializerwith the text container.Now you'll have a text view that uses TextKit 2.

You can access the text layout managerand text content storagewith new properties on NSTextView.There's just one thing to be careful of.

Recall that NSTextView has a layoutManager propertythat allows getting and setting its NSLayoutManager.

NSLayoutManager is a TextKit 1 objectand it's not compatible with the TextKit 2 stack.

A text view can't have both a layout managerand a text layout manager at the same time.

So here's the deal.We added a special compatibility modefor NSTextViewthat switches it to TextKit 1when needed.The text viewcan automatically detectwhether it needsto use this modeand replaceits NSTextLayoutManagerwith NSLayoutManager.For optimum performance,the text view will remainin compatibility modefrom that point forward.

Even if you opted in to TextKit 2,your text view will automatically switchto TextKit 1if you explicitly call the layoutManager propertyon your text view or text container.

The text view will also switchif it encounters text content that is not yet supportedor detects other conditions that require TextKit 1.

And this can happen for field editors as well.Field editors for NSTextField use TextKit 2 by default.But if your text field subclass is requesting layout informationfrom the field editor's layout manager,the field editor will switch to TextKit 1for all text fields in that window.

The system will issue notificationsbefore and after a text view switches to TextKit 1.You can observe these notificationsto receive this information.

The notification objects contain a referenceto the exact text view that changed modes.

For complete detailson the TextKit 1 compatibility mode for AppKit,please refer to the documentationon the Apple Developer portal.

For UIKit developers,UITextField uses TextKit 2 automatically in iOS 15.

UITextView with TextKit 2 is not available in iOS 15.

We're working to ensure maximum compatibilityfor all applications that use UITextView,and there are quite a lot of them.In the meantime,you can review your existing codefor uses of UITextView's layoutManager propertyand think about how to express your intent with TextKit 2.That way,you'll be ready to transition once it's available.

And that's a wrap.Now you've met TextKit 2,Apple's new text engine to take us into the future.We look forward to seeing what you'll buildwith TextKit 2.Thanks for watching.[upbeat music]

32:22 -Responding to layout updates: textViewportLayoutControllerWillLayout()

32:47 -Responding to layout updates: textViewportLayoutController(_:configureRenderingSurfaceFor:)

33:10 -Responding to layout updates: textViewportLayoutControllerDidLayout()

33:47 -Overriding text attributes for comments

34:06 -Hiding comments

34:28 -Generating special layout fragments for comments

34:58 -Drawing the comment bubble

37:26 -Opting NSTextView in to TextKit 2

## Code Samples

```swift
func
 
textViewportLayoutControllerWillLayout
(
_
 
controller
: 
NSTextViewportLayoutController
)
 {
    contentLayer.sublayers 
=
 
nil

    
CATransaction
.begin()
}
```

```swift
private
 
func
 
animate
(
_
 
layer
: 
CALayer
, 
from
 
source
: 
CGPoint
, 
to
 
destination
: 
CGPoint
)
 {
    
let
 animation 
=
 
CABasicAnimation
(keyPath: 
"position"
)
    animation.fromValue 
=
 source
    animation.toValue 
=
 destination
    animation.duration 
=
 slowAnimations 
?
 
2.0
 : 
0.3

    layer.add(animation, forKey: 
nil
)
}


private
 
func
 
findOrCreateLayer
(
_
 
textLayoutFragment
: 
NSTextLayoutFragment
)
 -> (
TextLayoutFragmentLayer
, 
Bool
) {
    
if
 
let
 layer 
=
 fragmentLayerMap.object(forKey: textLayoutFragment) 
as?
 
TextLayoutFragmentLayer
 {
        
return
 (layer, 
false
)
    } 
else
 {
        
let
 layer 
=
 
TextLayoutFragmentLayer
(layoutFragment: textLayoutFragment, padding: padding)
        fragmentLayerMap.setObject(layer, forKey: textLayoutFragment)
        
return
 (layer, 
true
)
    }
}


func
 
textViewportLayoutController
(
_
 
controller
: 
NSTextViewportLayoutController
,
                                  
configureRenderingSurfaceFor
 
textLayoutFragment
: 
NSTextLayoutFragment
)
 {
    
let
 (layer, layerIsNew) 
=
 findOrCreateLayer(textLayoutFragment)
    
if
 
!
layerIsNew {
        
let
 oldPosition 
=
 layer.position
        
let
 oldBounds 
=
 layer.bounds
        layer.updateGeometry()
        
if
 oldBounds 
!=
 layer.bounds {
            layer.setNeedsDisplay()
        }
        
if
 oldPosition 
!=
 layer.position {
            animate(layer, from: oldPosition, to: layer.position)
        }
    }
    
if
 layer.showLayerFrames 
!=
 showLayerFrames {
        layer.showLayerFrames 
=
 showLayerFrames
        layer.setNeedsDisplay()
    }
    
    contentLayer.addSublayer(layer)
}
```

```swift
func
 
textViewportLayoutControllerDidLayout
(
_
 
controller
: 
NSTextViewportLayoutController
)
 {
    
CATransaction
.commit()
    updateSelectionHighlights()
    updateContentSizeIfNeeded()
    adjustViewportOffsetIfNeeded()
}
```

```swift
func
 
textContentStorage
(
_
 
textContentStorage
: 
NSTextContentStorage
, 
textParagraphWith
 
range
: 
NSRange
)
 -> 
NSTextParagraph
? {
    
// In this method, we'll inject some attributes for display, without modifying the text storage directly.

    
var
 paragraphWithDisplayAttributes: 
NSTextParagraph
? 
=
 
nil

    
    
// First, get a copy of the paragraph from the original text storage.

    
let
 originalText 
=
 textContentStorage.textStorage
!
.attributedSubstring(from: range)
    
if
 originalText.attribute(.commentDepth, at: 
0
, effectiveRange: 
nil
) 
!=
 
nil
 {
        
// Use white colored text to make our comments visible against the bright background.

        
let
 displayAttributes: [
NSAttributedString
.
Key
: 
AnyObject
] 
=
 [.font: commentFont, .foregroundColor: commentColor]
        
let
 textWithDisplayAttributes 
=
 
NSMutableAttributedString
(attributedString: originalText)
        
// Use the display attributes for the text of the comment itself, without the reaction.

        
// The last character is the newline, second to last is the attachment character for the reaction.

        
let
 rangeForDisplayAttributes 
=
 
NSRange
(location: 
0
, length: textWithDisplayAttributes.length 
-
 
2
)
        textWithDisplayAttributes.addAttributes(displayAttributes, range: rangeForDisplayAttributes)
        
        
// Create our new paragraph with our display attributes.

        paragraphWithDisplayAttributes 
=
 
NSTextParagraph
(attributedString: textWithDisplayAttributes)
    } 
else
 {
        
return
 
nil

    }
    
// If the original paragraph wasn't a comment, this return value will be nil.

    
// The text content storage will use the original paragraph in this case.

    
return
 paragraphWithDisplayAttributes
}
```

```swift
func
 
textContentManager
(
_
 
textContentManager
: 
NSTextContentManager
,
                        
shouldEnumerate
 
textElement
: 
NSTextElement
,
                        
with
 
options
: 
NSTextElementProviderEnumerationOptions
)
 -> 
Bool
 {
    
// The text content manager calls this method to determine whether each text element should be enumerated for layout.

    
// To hide comments, tell the text content manager not to enumerate this element if it's a comment.

    
if
 
!
showComments {
        
if
 
let
 paragraph 
=
 textElement 
as?
 
NSTextParagraph
 {
            
let
 commentDepthValue 
=
 paragraph.attributedString.attribute(.commentDepth, at: 
0
, effectiveRange: 
nil
)
            
if
 commentDepthValue 
!=
 
nil
 {
                
return
 
false

            }
        }
    }
    
return
 
true

}
```

```swift
func
 
textLayoutManager
(
_
 
textLayoutManager
: 
NSTextLayoutManager
,
                       
textLayoutFragmentFor
 
location
: 
NSTextLocation
,
                       
in
 
textElement
: 
NSTextElement
)
 -> 
NSTextLayoutFragment
 {
    
let
 index 
=
 textLayoutManager.offset(from: textLayoutManager.documentRange.location, to: location)
    
// swiftlint:disable force_cast

    
let
 commentDepthValue 
=
 textContentStorage
!
.textStorage
!
.attribute(.commentDepth, at: index, effectiveRange: 
nil
) 
as!
 
NSNumber
?
    
if
 commentDepthValue 
!=
 
nil
 {
        
let
 layoutFragment 
=
 
BubbleLayoutFragment
(textElement: textElement, range: textElement.elementRange)
        layoutFragment.commentDepth 
=
 commentDepthValue
!
.uintValue
        
return
 layoutFragment
    } 
else
 {
        
return
 
NSTextLayoutFragment
(textElement: textElement, range: textElement.elementRange)
    }
}
```

```swift
var
 commentDepth: 
UInt
 
=
 
0



private
 
var
 tightTextBounds: 
CGRect
 {
    
var
 fragmentTextBounds 
=
 
CGRect
.null
    
for
 lineFragment 
in
 textLineFragments {
        
let
 lineFragmentBounds 
=
 lineFragment.typographicBounds
        
if
 fragmentTextBounds.isNull {
            fragmentTextBounds 
=
 lineFragmentBounds
        } 
else
 {
            fragmentTextBounds 
=
 fragmentTextBounds.union(lineFragmentBounds)
        }
    }
    
return
 fragmentTextBounds
}


// Return the bounding rect of the chat bubble, in the space of the first line fragment.


private
 
var
 bubbleRect: 
CGRect
 { 
return
 tightTextBounds.insetBy(dx: 
-
3
, dy: 
-
3
) }


private
 
var
 bubbleCornerRadius: 
CGFloat
 { 
return
 
20
 }


private
 
var
 bubbleColor: 
Color
 { 
return
 .systemIndigo }


private
 
func
 
createBubblePath
(
with
 
ctx
: 
CGContext
)
 -> 
CGPath
 {
    
let
 bubbleRect 
=
 
self
.bubbleRect
    
let
 rect 
=
 
min
(bubbleCornerRadius, bubbleRect.size.height 
/
 
2
, bubbleRect.size.width 
/
 
2
)
    
return
 
CGPath
(roundedRect: bubbleRect, cornerWidth: rect, cornerHeight: rect, transform: 
nil
)
}


override
 
var
 renderingSurfaceBounds: 
CGRect
 {
    
return
 bubbleRect.union(
super
.renderingSurfaceBounds)
}


override
 
func
 
draw
(
at
 
renderingOrigin
: 
CGPoint
, 
in
 
ctx
: 
CGContext
)
 {
    
// Draw the bubble and debug outline.

    ctx.saveGState()
    
let
 bubblePath 
=
 createBubblePath(with: ctx)
    ctx.addPath(bubblePath)
    ctx.setFillColor(bubbleColor.cgColor)
    ctx.fillPath()
    ctx.restoreGState()
    
    
// Draw the text on top.

    
super
.draw(at: renderingOrigin, in: ctx)
}
```

```swift
var
 scrollView: 
NSScrollView
!

var
 containerSize 
=
 
CGSize
.zero

var
 textContainer 
=
 
NSTextContainer
()


// Important: Keep a reference to text storage since NSTextView weakly references it.


var
 textContentStorage 
=
 
NSTextContentStorage
()


override
 
func
 
viewDidLoad
()
 {
    
super
.viewDidLoad()
    
    scrollView 
=

        
NSScrollView
(frame: 
NSRect
(origin: 
CGPoint
(),
                                   size: 
CGSize
(width: view.bounds.width, height: view.bounds.height)))
    scrollView.translatesAutoresizingMaskIntoConstraints 
=
 
false

    view.addSubview(scrollView)
    
    
NSLayoutConstraint
.activate([
        scrollView.leadingAnchor.constraint(equalTo: (view.leadingAnchor)),
        scrollView.trailingAnchor.constraint(equalTo: (view.trailingAnchor)),
        scrollView.topAnchor.constraint(equalTo: (view.topAnchor)),
        scrollView.bottomAnchor.constraint(equalTo: (view.bottomAnchor))
        ])
    
    setUpScrollView(scrollsHorizontally: 
false
)
}


func
 
setUpScrollView
(
scrollsHorizontally
: 
Bool
)
 {
    scrollView.borderType 
=
 .noBorder
    scrollView.hasVerticalScroller 
=
 
true

    scrollView.hasHorizontalScroller 
=
 scrollsHorizontally
    
    setUpTextContainer(scrollsHorizontally: scrollsHorizontally)
    setUpTextView(scrollsHorizontally: scrollsHorizontally)
}


func
 
setUpTextContainer
(
scrollsHorizontally
: 
Bool
)
 {
    
let
 contentSize 
=
 scrollView.contentSize
    
if
 scrollsHorizontally {
        containerSize 
=
 
NSSize
(width: 
CGFloat
.greatestFiniteMagnitude, height: 
CGFloat
.greatestFiniteMagnitude)
        textContainer.containerSize 
=
 containerSize
        textContainer.widthTracksTextView 
=
 
false

    }
    
else
 {
        containerSize 
=
 
NSSize
(width: contentSize.width, height: 
CGFloat
.greatestFiniteMagnitude)
        textContainer.containerSize 
=
 containerSize
        textContainer.widthTracksTextView 
=
 
true

    }
}


func
 
setUpTextView
(
scrollsHorizontally
: 
Bool
)
 {
    
let
 textLayoutManager 
=
 
NSTextLayoutManager
()
    textLayoutManager.textContainer 
=
 textContainer

    textContentStorage.addTextLayoutManager(textLayoutManager)

    
// Workaround: Pass textLayoutManager.textContainer to the NSTextView initializer

    
let
 textView 
=
 
NSTextView
(frame: scrollView.contentView.bounds, textContainer: textLayoutManager.textContainer)

    textView.isEditable 
=
 
true

    textView.isSelectable 
=
 
true

    textView.minSize 
=
 
CGSize
()
    textView.maxSize 
=
 containerSize
    textView.isVerticallyResizable 
=
 
true

    textView.isHorizontallyResizable 
=
 scrollsHorizontally
    textContentStorage.performEditingTransaction {
        textView.textStorage
?
.append(
NSAttributedString
(string: 
"Text content..."
))
    }
    scrollView.documentView 
=
 textView
}
```


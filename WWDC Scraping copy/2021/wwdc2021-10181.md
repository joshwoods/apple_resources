# Wwdc2021 10181

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Ultimate application performance survival guidePerformance optimization can seem like a daunting task — with many metrics to track and tools to use. Fear not: Our survival guide to app performance is here to help you understand tooling, metrics, and paradigms that can help smooth your development process and contribute to a great experience for people using your app.ResourcesAnalyzing the performance of your shipping appApp Store Connect APIImproving app responsivenessMetricKitXCTestHD VideoSD VideoRelated VideosWWDC23Optimize app power and performance for spatial computingWWDC21Detect and diagnose memory issuesDiagnose Power and Performance regressions in your appTriage TestFlight crashes in Xcode OrganizerUnderstand and eliminate hangs from your appWWDC20Diagnose performance issues with the Xcode OrganizerEliminate animation hitches with XCTestIdentify trends with the Power and Performance APIWhat's new in MetricKitTech TalksExplore UI animation hitches and the render loopWWDC19Getting Started with Instruments

Performance optimization can seem like a daunting task — with many metrics to track and tools to use. Fear not: Our survival guide to app performance is here to help you understand tooling, metrics, and paradigms that can help smooth your development process and contribute to a great experience for people using your app.

Analyzing the performance of your shipping app

App Store Connect API

Improving app responsiveness

MetricKit

XCTest

HD VideoSD Video

HD Video

SD Video

Optimize app power and performance for spatial computing

Detect and diagnose memory issues

Diagnose Power and Performance regressions in your app

Triage TestFlight crashes in Xcode Organizer

Understand and eliminate hangs from your app

Diagnose performance issues with the Xcode Organizer

Eliminate animation hitches with XCTest

Identify trends with the Power and Performance API

What's new in MetricKit

Explore UI animation hitches and the render loop

Getting Started with Instruments

Search this video…Hi, everyone.My name is Shefali Saboo,and I'm a performance tools engineer here at Apple.I'll be your guide as we navigateapplication performance together.Today's journey will be a thrilling tourthrough the world of performance.Your apps play a significant rolein the overall software experience on our devices.Continuing to optimize your apps and improve performancemeans your users will use your app more often,stay more engaged,and will use your app for a longer period of time.Optimizing for performance can seem like a daunting taskwith many metrics to track and tools to use.But fear not.This survival guide will get you up to speedon tooling, metrics, and paradigmsthat can help take your development to the next leveland ensure the best possible customer experience.I'm so excited to be your guideas we walk through our performance toolsand the great things that you can do with them.There will be five major tools that we'll be covering today:the Xcode Organizer, MetricKit,Instruments, XCTest,and the App Store Connect API.We'll start with a quick introduction of the key metrics.Then step through some common problemsin each domain areaand ways to resolve and prevent them.And finally, we'll end with some next steps.Performance optimization is like a long river with many stops.There are a few different tools needed for navigation,and at each of the stops, there's something new to learn.Let's take a trip down the river.First, a quick introduction.Let's take a look at the different performance metricswe'll cover today.There are currently eight key things to trackfor application performance:Battery Usage, Launch Time,Hang Rate, Memory,Disk Writes, Scrolling,Terminations, and MXSignposts.All of these can be tracked through our toolset.I'm a developer for an appcalled MealPlanner that allows users to tracktheir meals for the week and save cool recipes.Here's an example of a poor user experience within my app,specifically in the form of scroll hitches.Notice the slow, skipping, and jittery scroll?On the flip side, here's the same applicationwith a seamless user experience and no hitches.We can already see that there's quite a differencebetween the two experiences,and this smooth scroll is what we want to help you achievethrough performance optimizations.Each performance metric has its own unique setof paradigms and common tooling.Let's jump right into some common problemsin each domain areaand ways to resolve and prevent them.Our first stop along the river is battery usage.If your app is draining a lot of battery,here's what a user will see on their end.This is the Battery UI.It shows users how much of their overall battery drainan app on their device contributed towards,as well as its foreground and background activity.Why should you care about improving battery life?Easy.Users prioritize using appsthat allow them to use their devicesthroughout the day without needing to recharge.By optimizing for battery life,users can use their devices and your appfor a longer period of time.That, in and of itself, is a win.There are many different subsystemsto pay attention to when it comesto optimizing battery life.The top three to make note ofare CPU, Networking, and Location.I can track and triage the battery life of my appusing a few different tools during developmentor after a version has already released.While I'm developing and testing a new feature at my desk,I'll build and run my code through Xcode,and click on the Debug navigator,which looks like a little spray bottle,to see the various gauges Xcode has to offer.The one I'll pay close attention to is the Energy Gauge.The Energy Gauge allows me to track my CPU usageas I'm testing my app and shows me regionsof high CPU utilizationand CPU Wake Overhead.High CPU utilization iswhen CPU use is greater than 20%,and CPU Wake Overhead is regionswhere the CPU wakes from an idle state,and there's an incurred energy cost.It's common to see a spike in CPUwhen my app is drawing the user interface,processing data from the network,or performing calculations,but once those tasks are complete and my app is waitingfor the user to perform their next action,I should see the CPU usage be at, or near, zero.From here, I can also click Time Profileto profile my app in Instrumentsand see the thermal state, CPU usage,and active call stacks for the profiled duration.I can also use the Location Energy Modelto measure the impact of Core Locationand make sure my app isn't using the locationwhen it shouldn't be.Occasionally, there might be a bug in a betaor released version of my appthat's tough to reproduce at my deskor may need more logging and context to debug.MetricKit, which operates on-deviceas an all-in-one performance telemetry framework,can help me narrow down the root causeand provide me valuable insightsinto problems my customers are facing.To use MetricKit, all I need to do is addand implement a custom class called AppMetrics in my appand conform this new classto the MXMetricManagerSubscriber protocol.I can then add a reference to my custom classto the manager.And remove a reference to my custom class on deinit,which is a recommended best practice.I can process this datain the corresponding didReceive methods.If done strategically,I can augment much of the same dataI'll find in the Organizer,such as the energy logs and CPU metrics,with contextual data from MetricKitabout what may have been going wrong when the problem occurred.A simple version of this data is available to you,with no extra effort,thanks to our on-device analytics pipeline.As users use your app,we collect performance data from consented devices.This data is then aggregated on our serversand sent back to you through one of our many tools,like the Xcode Organizer.Accessing the Xcode Organizer to see performance datafor a version of my app that's already in the app storeis as easy as navigating to the menu barwhile Xcode is open, going to window,and clicking Organizer to launch.Once I'm here, I can click on the battery usage metricto view aggregated data for my appacross the last 16 app versions,as well as a detailed breakdownby major subcomponent to the right of the chart.If the newest version of my app has a major regression,I'll know about itright after a version shows up in the Organizer,if I navigate to the Regression pane,which is new in Xcode 13.This new regressions pane isolates all the metricsthat have increased significantlyin the most recent version of my appso I can see all the things I need to focus on in one place.To determine what areas of my app caused the issues,I can also use Energy Organizer under Reportsto view regions of high CPU useand logs that were collected from consented user devices.This provides a more detailed lookinto what was happening in my app.I can get all of this databy querying the App Store Connect API as welland running my own analysis on the JSON payloadthat is returned with my requested data.All of these tools will make it easy for me to catch and resolvea lot of the battery usage regressions in my app.To learn more about battery life optimizations,check out the "Improving Battery Life and Performance" talkfrom 2019, and to learn moreabout using Instruments, check outthe "Analyze HTTP Traffic in Instruments" talk this year.Our next stop is Hang Rate and Scrolling,two metrics that convey that my app wasn't responsive.A hang is when the app is unresponsiveto user input or actionsfor at least 250 milliseconds.Hangs in the app can lead customersto force quit the application from the app switcherand are a major impediment to the user's experiencein your app and should be prioritized.Stuttering scrolls occur when new content isn't readyfor the next screen refresh.These will lead to an unenjoyable user experienceand overall frustration,resulting in users spending less time in your app.As an app developer,the goal is to maximize the amount of user engagement,so this is a great place to start optimizing.Remember that smooth scroll we showed you earlier?Aiming for this is in the best interest of your users.I can track hangs and my scrolling metricsin the Xcode Organizerby navigating to their respective views.A sign that I need to pay close attentionto what my app is doingis if I notice either of the chartstrending upwards or, in the case of scrolling,if I notice that the graph is showing more yellow and red barsinstead of green ones, like in this graph here.According to the key to the right of the chart,the red bar is indicative of the poor scroll experiencewe saw in the video earlierand should be fixed immediately.This data is now also availablethrough the App Store Connect API.I can use Instruments to detect the cause of my hangsby using the Thread State or System Call Traces.The Thread State Trace instrument shows a timelineof the thread's state and when the OShas scheduled the thread to run.I can see how long a thread was blocked forin the details section.The System Call Trace shows a narrativethat details the system calls enteredand how long they took.To verify that I'm not releasing app versionswith bugs that will affect my users' scroll experience,I can write a performance test with XCTestthat launches and scrolls through my app.In this test, I'm specifying that I wantto measure the scrollDeceleration submetric,and in the body of the measure block,I'm swiping up with the scroll velocityI expect in my app.Since this measure block runs five times by default,I'll reset the application state between runsby using the XCTMeasureOptions.I can pass this into my measure block,stop measuring,and then reset my application state.Sometimes, reproducing responsiveness issuesin forced test cases may not be easy.Luckily, MetricKit,when deployed in my production application,can allow me to collect telemetryand diagnostics for these issuesat the time they occur.In the case of hangs, in iOS 14,MetricKit would deliver these diagnostics to meat a 24-hour cadence.New in iOS 15 and macOS 12,I will now receive all diagnostics, including hangs,in my app immediately after an issue occurs.Using these instant diagnosticsin conjunction with my own telemetry,I can quickly root causeand resolve the most pressing responsiveness problems.In the case of scroll hitches,iOS 15 introduces a new API within MetricKitto tag custom animations using MXSignpost.MXSignpost is a wrapper API shipped with MetricKitthat allows me to markcritical code sections for telemetry.Using the MXSignpostAnimation- IntervalBegin API,I'll be able to strategically markthe beginning of custom animations.Using the MXSignpost end API,I can mark the end of the animationand collect hitch-rate telemetry during that interval.These two functions will not only capturegranular performance data for this interval,but will also capture any hitches that occur.To learn more about howto understand and eliminate hangs,I recommend checking outthe "Understand and Eliminate Hangs from your App" talkthis year.For in-depth details on how to identifyscroll hitch issues, I recommend checking outthe "Eliminate Hitches Using XCTest" talkand the "Explore UI Animation Hitches and the Render Loop"tech talks from 2020.We're approaching the halfway mark nowas we now move on to discussing Disk Writes.Writing to disk can wear out my users' NAND,which will lead to poor device health.Writes also take a lot of timeand can lead to poor user experienceand slow performance if done frequently,so it's important to batch these writes.Before releasing my app version, I can profile my appusing the File Activity template in Instruments.This records file system use in the form of system calls,so I can easily identify places in my app's codewhere I'm accessing the file system.There are many ways to be good citizensof the system and limit writing to disk.Some common ones are batching your write operations,using Core Data for frequently-changing data,and avoiding rapid file creation and deletion.In addition to profiling my app,I can also write performance tests with XCTestto measure the disk usage of my appto prevent code with excessive Disk Writesfrom running on user devices.This is as simple as passing an instanceof XCTStorageMetricto the measureWithMetric APIand then invoking the code that writes to disk.The test measures the amount of datawritten to disk by the code in the blockand shows me the result within Xcode itself.I can set a baseline of the amount of dataI expect to be written to diskso that the test fails if the code in the block exceeds that.This will help me ensurethat I'm not putting out any buggy code.If I've already released a version of my appwith high Disk Writes, I can use the Organizerto track its performance on user devices.The Disk Writes metric shows me the trendof how many writes the current version of my app is doingcompared to the previously released versions.Spikes in the graph can indicate that my app has bugsthat are causing a high amount of writes.I should identify the top sources of these writes,understand them, and look for ways reduce them.I can look for the sources of these writesby taking a look at the Disk Writes Reports.These are a collection of exception reportsthat are generated when my appwrites more than 1 GB in a 24-hour period.The stack trace shows me where in my codeI was doing excessive writes,and, new in Xcode 13,I can also get additional details called Insights,which point me to some easy optimizationsI can make to be a good citizen of the systemand reduce some of the writes in my app.All of this data is now also available to methrough the App Store Connect API.I can also obtain these reports in MetricKitat the time they occur in my application.If I'm using MetricKit to monitor my app's disk usage,I can book-end critical Disk Write pathswith MXSignpost intervalsto collect more granular telemetry,which can help me discover opportunities for optimization.To learn more about how to seamlessly identifyand resolve Disk Write issues,be sure to tune in to the "Diagnose Powerand Performance Regressions in your App" talk this year.As we approach the next stop,we'll be discussing launch time and terminations.Launch time is the amount of timebetween when the user taps your app iconand when the first frame gets rendered in your app.If your user spends a long timewaiting for your app to launch,that can lead to unintentional frustration for the user,and extended launch timescan lead to the system terminating your app.When the system terminates your app,your user will experience the entire launch flowfrom the beginning, which takes much longerthan resuming from a background running state.Process exits can happen for many different reasons,like hitting and exceeding the system memory limitor timing out on launch.Every time your app terminates for one of these reasons,it goes through the full launch flowthe next time your user taps your app icon,and that not only takes a long time,but is also a frustrating experience,especially if it's happening frequently.If you're not restoring state,this can also add to the frustration of a userhaving to find their place againor recreate lost work.I just released a new version of my appwith a feature that allows my usersto add pictures and detailed recipes for their meals.Let's see what the launch time for my app looks likewith this new feature and what it looked like before.This is what the user will see when they try to launchmy app now that it has the new feature in it.Notice how much time was spent attemptingto render the first frame?My app was suspendedbefore we even had a chance to use it.In comparison, here's what the launch looked likebefore that feature was added.It's almost like my app anticipated a launchand had the first frame ready to display.From these two examples,I already know that the first incredibly slow launchis not what I want my users to rememberwhen they think of my app.So I'll need to fix this as soon as possible.Since the launch issue is already in a versionof my app that users are using,I can start by going to the Organizerand taking a look at the Launch Timeand new Terminations panes.Looking at launch times will give me an ideaof what the average "time to first frame" of my app isover the last 16 versions,so I can see how fast it wasbefore my new feature was added.I can also go to the Terminations paneto see how frequently my app is being terminatedby the system because of how long it's taking to launch.After looking at the Organizer, it actually looks like this isa pretty bad bug that was introduced with my new feature,and it's hitting a lot of my users.Let's take a look at how I can go about fixing this.I can test this issue at my deskby using the App Launch template in Instrumentsto profile my app's launch time.This template runs my app for five seconds,during which it gathers a time profileand Thread State Trace of what was going onwhile the app was launching, so I can figure outwhy the threads were blocked and fix that.I can also measure launch times in a performance XCTestby using the XCTApplicationsLaunchMetricin a measure block similar to what we saw earlier.If I want to do my own analytics,with MetricKit implemented in my app,I'll receive termination telemetryas part of the daily metric payload by default.For more information on state restorationto avoid data loss when your app is terminated,check out the "Why is my App Getting Killed?" talkfrom 2020.Yay, we've done it.We're at our final stop before we wrap up our journey.Our final stop is Memory.Memory is a shared resourcebetween apps, the OS, and kernel.If your app exceeds the memory limit,it will be terminated by the system,and the next time the user goes to launch it,it'll launch from the beginning, which takes much longerthan resuming from a background running state.The new feature in my app allows developersto add pictures and descriptions to their meals,which means that there's a chancethat the memory use gets a little high.If this happens, there's a chancethat my app can get terminated for exceeding the memory limit,so I should keep an eye on the Memoryand Terminations metrics in the Organizerto make sure that isn't the case.It looks like it's not being terminated,but there's a large spike in memory usein this new version of my app,according to the peak memoryand memory at suspension charts in the Organizer.I can profile the memory use of my appby using the Leaks, Allocations,and VM Tracker templates in Instruments.Leaks will examine my process's heapand check for leaked memory.Allocations will analyzethe memory life cycle of my app.And VM Tracker will show the virtual memory spaceof my app over time.I can also use MetricKit to get the same informationand run my own analysis on it.In addition to using my daily metric payloadsthat contain termination and memory telemetry,I can also instrument MXSignpostsaround critical code sectionsto capture more granular telemetry about memory usage.To learn more about detecting and understandinghow to resolve memory regressionsbefore they make it into your application, check outthe "Detect and Diagnose Memory Issues" talk this year.Before I send you on your way,let's wrap up what we've seen here todayand go over some next steps.We understand how challenging it can beto identify performance optimizations.Over the last few years,developers have used these same toolsthat we provide to youto make significant performance optimizations.A great example is Snapchat,an app that millions of people use every day.Snapchat has a long-standing dedicationto improving the launch experience of their appand driving down terminations.In the last year, we've seen a 99% reductionin undesirable terminations for Snapchat.We think that's incredible,and using the performance toolsand data we've discussed here today,you can accomplish this too.If you're new to performance tools,I recommend taking a moment to check outthe "Diagnose Performance Issues with the Xcode Organizer"and "What's New in MetricKit" talks from 2020,as well as the "Identify Trends with the Powerand Performance API" talk from 2020and the "Getting Started with Instruments" talkfrom 2019.After digging into all of these metrics and tools,we're hoping that you're well equippedwith the resources you'll needto ship the most performant apps in the App Store.Your users will thank you for thisas they enjoy a seamless user experience.There was a lot of material covered here,so as a fun exercise, I recommendyou use the Xcode Organizerto see trending data on your app's performance.Explore and play with the different templatesoffered in Instruments.Challenge yourself to write XCTeststo catch issues before they're released.And broaden the scope of your analytics with MetricKit.There's so much our tools have to offerwhen it comes to optimizing for performance,so don't hesitate to get your hands dirtyand explore all that comes with them.Thank you for joining me on today's journey,and I hope you have a wonderful time at this year's conference.[upbeat music]

Hi, everyone.My name is Shefali Saboo,and I'm a performance tools engineer here at Apple.

I'll be your guide as we navigateapplication performance together.Today's journey will be a thrilling tourthrough the world of performance.Your apps play a significant rolein the overall software experience on our devices.Continuing to optimize your apps and improve performancemeans your users will use your app more often,stay more engaged,and will use your app for a longer period of time.Optimizing for performance can seem like a daunting taskwith many metrics to track and tools to use.But fear not.This survival guide will get you up to speedon tooling, metrics, and paradigmsthat can help take your development to the next leveland ensure the best possible customer experience.I'm so excited to be your guideas we walk through our performance toolsand the great things that you can do with them.There will be five major tools that we'll be covering today:the Xcode Organizer, MetricKit,Instruments, XCTest,and the App Store Connect API.We'll start with a quick introduction of the key metrics.

Then step through some common problemsin each domain areaand ways to resolve and prevent them.

And finally, we'll end with some next steps.Performance optimization is like a long river with many stops.There are a few different tools needed for navigation,and at each of the stops, there's something new to learn.Let's take a trip down the river.First, a quick introduction.Let's take a look at the different performance metricswe'll cover today.There are currently eight key things to trackfor application performance:Battery Usage, Launch Time,Hang Rate, Memory,Disk Writes, Scrolling,Terminations, and MXSignposts.All of these can be tracked through our toolset.

I'm a developer for an appcalled MealPlanner that allows users to tracktheir meals for the week and save cool recipes.

Here's an example of a poor user experience within my app,specifically in the form of scroll hitches.Notice the slow, skipping, and jittery scroll?On the flip side, here's the same applicationwith a seamless user experience and no hitches.

We can already see that there's quite a differencebetween the two experiences,and this smooth scroll is what we want to help you achievethrough performance optimizations.Each performance metric has its own unique setof paradigms and common tooling.Let's jump right into some common problemsin each domain areaand ways to resolve and prevent them.Our first stop along the river is battery usage.

If your app is draining a lot of battery,here's what a user will see on their end.This is the Battery UI.It shows users how much of their overall battery drainan app on their device contributed towards,as well as its foreground and background activity.Why should you care about improving battery life?Easy.Users prioritize using appsthat allow them to use their devicesthroughout the day without needing to recharge.By optimizing for battery life,users can use their devices and your appfor a longer period of time.That, in and of itself, is a win.There are many different subsystemsto pay attention to when it comesto optimizing battery life.The top three to make note ofare CPU, Networking, and Location.I can track and triage the battery life of my appusing a few different tools during developmentor after a version has already released.While I'm developing and testing a new feature at my desk,I'll build and run my code through Xcode,and click on the Debug navigator,which looks like a little spray bottle,to see the various gauges Xcode has to offer.The one I'll pay close attention to is the Energy Gauge.The Energy Gauge allows me to track my CPU usageas I'm testing my app and shows me regionsof high CPU utilizationand CPU Wake Overhead.High CPU utilization iswhen CPU use is greater than 20%,and CPU Wake Overhead is regionswhere the CPU wakes from an idle state,and there's an incurred energy cost.It's common to see a spike in CPUwhen my app is drawing the user interface,processing data from the network,or performing calculations,but once those tasks are complete and my app is waitingfor the user to perform their next action,I should see the CPU usage be at, or near, zero.From here, I can also click Time Profileto profile my app in Instrumentsand see the thermal state, CPU usage,and active call stacks for the profiled duration.I can also use the Location Energy Modelto measure the impact of Core Locationand make sure my app isn't using the locationwhen it shouldn't be.Occasionally, there might be a bug in a betaor released version of my appthat's tough to reproduce at my deskor may need more logging and context to debug.MetricKit, which operates on-deviceas an all-in-one performance telemetry framework,can help me narrow down the root causeand provide me valuable insightsinto problems my customers are facing.To use MetricKit, all I need to do is addand implement a custom class called AppMetrics in my appand conform this new classto the MXMetricManagerSubscriber protocol.

I can then add a reference to my custom classto the manager.And remove a reference to my custom class on deinit,which is a recommended best practice.

I can process this datain the corresponding didReceive methods.If done strategically,I can augment much of the same dataI'll find in the Organizer,such as the energy logs and CPU metrics,with contextual data from MetricKitabout what may have been going wrong when the problem occurred.A simple version of this data is available to you,with no extra effort,thanks to our on-device analytics pipeline.As users use your app,we collect performance data from consented devices.This data is then aggregated on our serversand sent back to you through one of our many tools,like the Xcode Organizer.Accessing the Xcode Organizer to see performance datafor a version of my app that's already in the app storeis as easy as navigating to the menu barwhile Xcode is open, going to window,and clicking Organizer to launch.

Once I'm here, I can click on the battery usage metricto view aggregated data for my appacross the last 16 app versions,as well as a detailed breakdownby major subcomponent to the right of the chart.

If the newest version of my app has a major regression,I'll know about itright after a version shows up in the Organizer,if I navigate to the Regression pane,which is new in Xcode 13.This new regressions pane isolates all the metricsthat have increased significantlyin the most recent version of my appso I can see all the things I need to focus on in one place.To determine what areas of my app caused the issues,I can also use Energy Organizer under Reportsto view regions of high CPU useand logs that were collected from consented user devices.This provides a more detailed lookinto what was happening in my app.I can get all of this databy querying the App Store Connect API as welland running my own analysis on the JSON payloadthat is returned with my requested data.All of these tools will make it easy for me to catch and resolvea lot of the battery usage regressions in my app.To learn more about battery life optimizations,check out the "Improving Battery Life and Performance" talkfrom 2019, and to learn moreabout using Instruments, check outthe "Analyze HTTP Traffic in Instruments" talk this year.Our next stop is Hang Rate and Scrolling,two metrics that convey that my app wasn't responsive.A hang is when the app is unresponsiveto user input or actionsfor at least 250 milliseconds.Hangs in the app can lead customersto force quit the application from the app switcherand are a major impediment to the user's experiencein your app and should be prioritized.

Stuttering scrolls occur when new content isn't readyfor the next screen refresh.These will lead to an unenjoyable user experienceand overall frustration,resulting in users spending less time in your app.As an app developer,the goal is to maximize the amount of user engagement,so this is a great place to start optimizing.

Remember that smooth scroll we showed you earlier?Aiming for this is in the best interest of your users.I can track hangs and my scrolling metricsin the Xcode Organizerby navigating to their respective views.A sign that I need to pay close attentionto what my app is doingis if I notice either of the chartstrending upwards or, in the case of scrolling,if I notice that the graph is showing more yellow and red barsinstead of green ones, like in this graph here.According to the key to the right of the chart,the red bar is indicative of the poor scroll experiencewe saw in the video earlierand should be fixed immediately.This data is now also availablethrough the App Store Connect API.I can use Instruments to detect the cause of my hangsby using the Thread State or System Call Traces.The Thread State Trace instrument shows a timelineof the thread's state and when the OShas scheduled the thread to run.I can see how long a thread was blocked forin the details section.

The System Call Trace shows a narrativethat details the system calls enteredand how long they took.To verify that I'm not releasing app versionswith bugs that will affect my users' scroll experience,I can write a performance test with XCTestthat launches and scrolls through my app.In this test, I'm specifying that I wantto measure the scrollDeceleration submetric,and in the body of the measure block,I'm swiping up with the scroll velocityI expect in my app.Since this measure block runs five times by default,I'll reset the application state between runsby using the XCTMeasureOptions.I can pass this into my measure block,stop measuring,and then reset my application state.Sometimes, reproducing responsiveness issuesin forced test cases may not be easy.Luckily, MetricKit,when deployed in my production application,can allow me to collect telemetryand diagnostics for these issuesat the time they occur.In the case of hangs, in iOS 14,MetricKit would deliver these diagnostics to meat a 24-hour cadence.New in iOS 15 and macOS 12,I will now receive all diagnostics, including hangs,in my app immediately after an issue occurs.Using these instant diagnosticsin conjunction with my own telemetry,I can quickly root causeand resolve the most pressing responsiveness problems.In the case of scroll hitches,iOS 15 introduces a new API within MetricKitto tag custom animations using MXSignpost.MXSignpost is a wrapper API shipped with MetricKitthat allows me to markcritical code sections for telemetry.

Using the MXSignpostAnimation- IntervalBegin API,I'll be able to strategically markthe beginning of custom animations.Using the MXSignpost end API,I can mark the end of the animationand collect hitch-rate telemetry during that interval.These two functions will not only capturegranular performance data for this interval,but will also capture any hitches that occur.To learn more about howto understand and eliminate hangs,I recommend checking outthe "Understand and Eliminate Hangs from your App" talkthis year.For in-depth details on how to identifyscroll hitch issues, I recommend checking outthe "Eliminate Hitches Using XCTest" talkand the "Explore UI Animation Hitches and the Render Loop"tech talks from 2020.We're approaching the halfway mark nowas we now move on to discussing Disk Writes.Writing to disk can wear out my users' NAND,which will lead to poor device health.Writes also take a lot of timeand can lead to poor user experienceand slow performance if done frequently,so it's important to batch these writes.

Before releasing my app version, I can profile my appusing the File Activity template in Instruments.This records file system use in the form of system calls,so I can easily identify places in my app's codewhere I'm accessing the file system.There are many ways to be good citizensof the system and limit writing to disk.Some common ones are batching your write operations,using Core Data for frequently-changing data,and avoiding rapid file creation and deletion.In addition to profiling my app,I can also write performance tests with XCTestto measure the disk usage of my appto prevent code with excessive Disk Writesfrom running on user devices.This is as simple as passing an instanceof XCTStorageMetricto the measureWithMetric APIand then invoking the code that writes to disk.The test measures the amount of datawritten to disk by the code in the blockand shows me the result within Xcode itself.I can set a baseline of the amount of dataI expect to be written to diskso that the test fails if the code in the block exceeds that.This will help me ensurethat I'm not putting out any buggy code.

If I've already released a version of my appwith high Disk Writes, I can use the Organizerto track its performance on user devices.The Disk Writes metric shows me the trendof how many writes the current version of my app is doingcompared to the previously released versions.Spikes in the graph can indicate that my app has bugsthat are causing a high amount of writes.I should identify the top sources of these writes,understand them, and look for ways reduce them.

I can look for the sources of these writesby taking a look at the Disk Writes Reports.These are a collection of exception reportsthat are generated when my appwrites more than 1 GB in a 24-hour period.The stack trace shows me where in my codeI was doing excessive writes,and, new in Xcode 13,I can also get additional details called Insights,which point me to some easy optimizationsI can make to be a good citizen of the systemand reduce some of the writes in my app.All of this data is now also available to methrough the App Store Connect API.I can also obtain these reports in MetricKitat the time they occur in my application.If I'm using MetricKit to monitor my app's disk usage,I can book-end critical Disk Write pathswith MXSignpost intervalsto collect more granular telemetry,which can help me discover opportunities for optimization.To learn more about how to seamlessly identifyand resolve Disk Write issues,be sure to tune in to the "Diagnose Powerand Performance Regressions in your App" talk this year.As we approach the next stop,we'll be discussing launch time and terminations.Launch time is the amount of timebetween when the user taps your app iconand when the first frame gets rendered in your app.

If your user spends a long timewaiting for your app to launch,that can lead to unintentional frustration for the user,and extended launch timescan lead to the system terminating your app.When the system terminates your app,your user will experience the entire launch flowfrom the beginning, which takes much longerthan resuming from a background running state.

Process exits can happen for many different reasons,like hitting and exceeding the system memory limitor timing out on launch.

Every time your app terminates for one of these reasons,it goes through the full launch flowthe next time your user taps your app icon,and that not only takes a long time,but is also a frustrating experience,especially if it's happening frequently.

If you're not restoring state,this can also add to the frustration of a userhaving to find their place againor recreate lost work.

I just released a new version of my appwith a feature that allows my usersto add pictures and detailed recipes for their meals.Let's see what the launch time for my app looks likewith this new feature and what it looked like before.

This is what the user will see when they try to launchmy app now that it has the new feature in it.Notice how much time was spent attemptingto render the first frame?My app was suspendedbefore we even had a chance to use it.In comparison, here's what the launch looked likebefore that feature was added.It's almost like my app anticipated a launchand had the first frame ready to display.From these two examples,I already know that the first incredibly slow launchis not what I want my users to rememberwhen they think of my app.So I'll need to fix this as soon as possible.Since the launch issue is already in a versionof my app that users are using,I can start by going to the Organizerand taking a look at the Launch Timeand new Terminations panes.Looking at launch times will give me an ideaof what the average "time to first frame" of my app isover the last 16 versions,so I can see how fast it wasbefore my new feature was added.I can also go to the Terminations paneto see how frequently my app is being terminatedby the system because of how long it's taking to launch.

After looking at the Organizer, it actually looks like this isa pretty bad bug that was introduced with my new feature,and it's hitting a lot of my users.Let's take a look at how I can go about fixing this.I can test this issue at my deskby using the App Launch template in Instrumentsto profile my app's launch time.This template runs my app for five seconds,during which it gathers a time profileand Thread State Trace of what was going onwhile the app was launching, so I can figure outwhy the threads were blocked and fix that.I can also measure launch times in a performance XCTestby using the XCTApplicationsLaunchMetricin a measure block similar to what we saw earlier.If I want to do my own analytics,with MetricKit implemented in my app,I'll receive termination telemetryas part of the daily metric payload by default.For more information on state restorationto avoid data loss when your app is terminated,check out the "Why is my App Getting Killed?" talkfrom 2020.Yay, we've done it.We're at our final stop before we wrap up our journey.Our final stop is Memory.Memory is a shared resourcebetween apps, the OS, and kernel.If your app exceeds the memory limit,it will be terminated by the system,and the next time the user goes to launch it,it'll launch from the beginning, which takes much longerthan resuming from a background running state.The new feature in my app allows developersto add pictures and descriptions to their meals,which means that there's a chancethat the memory use gets a little high.If this happens, there's a chancethat my app can get terminated for exceeding the memory limit,so I should keep an eye on the Memoryand Terminations metrics in the Organizerto make sure that isn't the case.It looks like it's not being terminated,but there's a large spike in memory usein this new version of my app,according to the peak memoryand memory at suspension charts in the Organizer.

I can profile the memory use of my appby using the Leaks, Allocations,and VM Tracker templates in Instruments.Leaks will examine my process's heapand check for leaked memory.Allocations will analyzethe memory life cycle of my app.And VM Tracker will show the virtual memory spaceof my app over time.I can also use MetricKit to get the same informationand run my own analysis on it.In addition to using my daily metric payloadsthat contain termination and memory telemetry,I can also instrument MXSignpostsaround critical code sectionsto capture more granular telemetry about memory usage.

To learn more about detecting and understandinghow to resolve memory regressionsbefore they make it into your application, check outthe "Detect and Diagnose Memory Issues" talk this year.Before I send you on your way,let's wrap up what we've seen here todayand go over some next steps.We understand how challenging it can beto identify performance optimizations.Over the last few years,developers have used these same toolsthat we provide to youto make significant performance optimizations.

A great example is Snapchat,an app that millions of people use every day.Snapchat has a long-standing dedicationto improving the launch experience of their appand driving down terminations.

In the last year, we've seen a 99% reductionin undesirable terminations for Snapchat.We think that's incredible,and using the performance toolsand data we've discussed here today,you can accomplish this too.

If you're new to performance tools,I recommend taking a moment to check outthe "Diagnose Performance Issues with the Xcode Organizer"and "What's New in MetricKit" talks from 2020,as well as the "Identify Trends with the Powerand Performance API" talk from 2020and the "Getting Started with Instruments" talkfrom 2019.After digging into all of these metrics and tools,we're hoping that you're well equippedwith the resources you'll needto ship the most performant apps in the App Store.Your users will thank you for thisas they enjoy a seamless user experience.There was a lot of material covered here,so as a fun exercise, I recommendyou use the Xcode Organizerto see trending data on your app's performance.Explore and play with the different templatesoffered in Instruments.Challenge yourself to write XCTeststo catch issues before they're released.And broaden the scope of your analytics with MetricKit.

There's so much our tools have to offerwhen it comes to optimizing for performance,so don't hesitate to get your hands dirtyand explore all that comes with them.Thank you for joining me on today's journey,and I hope you have a wonderful time at this year's conference.[upbeat music]

5:46 -Using MetricKit

10:29 -Testing Scroll performance

11:53 -Using mxSignpostAnimationIntervalBegin

13:51 -Using XCTest to Measure Disk Usage

21:19 -Collect memory telemetry

## Code Samples

```swift
class
 
AppMetrics
: 
MXMetricManagerSubscriber
 
{
	
init
()
 {
		
let
 shared 
=
 
MXMetricManager
.shared
		shared.add(
self
)
	}

	
deinit
 {
		
let
 shared 
=
 
MXMetricManager
.shared
		shared.remove(
self
)
	}

	
// Receive daily metrics

	
func
 
didReceive
(
_
 
payloads
: [
MXMetricPayload
])
 {
		
// Process metrics

	}

	
// Receive diagnostics

	
func
 
didReceive
(
_
 
payloads
: [
MXDiagnosticPayload
])
 {
		
// Process metrics

	}
}
```

```swift
func
 
testScrollingAnimationPerformance
()
 
throws
 {
        
    app.launch()
    app.staticTexts[
"Meal Planner"
].tap()
    
let
 foodCollection 
=
 app.collectionViews.firstMatch

    
let
 measureOptions 
=
 
XCTMeasureOptions
()
    measureOptions.invocationOptions 
=
 [.manuallyStop]
        
    measure(metrics: [
XCTOSSignpostMetric
.scrollDecelerationMetric],
    options: measureOptions) {
        foodCollection.swipeUp(velocity: .fast)
        stopMeasuring()
        foodCollection.swipeDown(velocity: .fast)
    }
}
```

```swift
func
 
startAnimating
()
 {
	
// Mark the beginning of animations

	mxSignpostAnimationIntervalBegin(
		log: 
MXMetricManager
.makeLogHandle(category: 
"animation_telemetry"
), 
		name: 
"custom_animation”)
	}

	func animationDidComplete() {
	// Mark the end of the animation to receive the collected hitch rate telemetry
	mxSignpost(OSSignpostType.end, 
		log: MXMetricManager.makeLogHandle(category: "
animation_telemetry
"), 
		name: "
custom_animation
")
}
```

```swift
// Example performance XCTest



func
 
testSaveMeal
()
 {
	
let
 app 
=
 
XCUIApplication
()
	
let
 options 
=
 
XCTMeasureOptions
()
	options.invocationOptions 
=
 [.manuallyStart]

	measure(metrics: [
XCTStorageMetric
(application: app)], options: options) {
		app.launch()
		startMeasuring()

		
let
 firstCell 
=
 app.cells.firstMatch
		firstCell.buttons[
"Save meal"
].firstMatch.tap()

		
let
 savedButton 
=
 firstCell.buttons[
"Saved"
].firstMatch
		
XCTAssertTrue
(savedButton.waitForExistence(timeout: 
2
))
	}
}
```

```swift
// Collect memory telemetry



func
 
saveAppAssets
()
 {
	mxSignpost(
OSSignpostType
.begin, 
		log: 
MXMetricManager
.makeLogHandle(category: 
"memory_telemetry"
), 
		name: 
"custom_memory"
)

	
// save app metadata


	mxSignpost(
OSSignpostType
.end, 
		log: 
MXMetricManager
.makeLogHandle(category: 
"memory_telemetry"
), 
		name: 
"custom_memory"
)
}
```


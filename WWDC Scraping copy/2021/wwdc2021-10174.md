# Wwdc2021 10174

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Manage in-app purchases on your serverDiscover the latest updates to managing in-app purchases on your server. Explore how you can use servers to track status changes, handle refunds, and manage subscriber status. Learn about App Store server APIs around status and in-app purchase transactions, and find out how App Store server notifications can help you track more customer lifecycle events. We'll also take you through managing Family Sharing for in-app purchases, and the latest improvements to testing in-app purchases in the sandbox environment.ResourcesApp Store Server APIApp Store Server NotificationsAuto-renewable subscriptions overviewHuman Interface Guidelines: In-app purchaseIn-app purchase overviewIntroducing StoreKit 2StoreKitHD VideoSD VideoRelated VideosWWDC22Explore in-app purchase integration and migrationWhat's new in StoreKit testingWhat's new with in-app purchaseWWDC21Meet StoreKit 2Support customers and handle refundsWWDC20What’s new with in-app purchaseWWDC19In-App Purchases and Using Server-to-Server Notifications

Discover the latest updates to managing in-app purchases on your server. Explore how you can use servers to track status changes, handle refunds, and manage subscriber status. Learn about App Store server APIs around status and in-app purchase transactions, and find out how App Store server notifications can help you track more customer lifecycle events. We'll also take you through managing Family Sharing for in-app purchases, and the latest improvements to testing in-app purchases in the sandbox environment.

App Store Server API

App Store Server Notifications

Auto-renewable subscriptions overview

Human Interface Guidelines: In-app purchase

In-app purchase overview

Introducing StoreKit 2

StoreKit

HD VideoSD Video

HD Video

SD Video

Explore in-app purchase integration and migration

What's new in StoreKit testing

What's new with in-app purchase

Meet StoreKit 2

Support customers and handle refunds

What’s new with in-app purchase

In-App Purchases and Using Server-to-Server Notifications

Search this video…Hello, and welcome to WWDC.I'm Tori, and I'm so excited to talk to youabout the new features we have coming for your serverand to help set some guidelines for running an effective serverto track the status of all of your in-app purchases.So, let's dive right in.This session is part two of a three-session seriesfocusing on in-app purchases.If you've not already watched "Meet StoreKit 2"or "Support customers and handle refunds,"I recommend you take a look after this sessionso you can get the full story.For this session, we're going to focus onthe server and how you can build your serverto manage your in-app purchases.To get us started in this session, let's first talk aboutsome of the reasons it's useful to have a server.Having a server is useful for several reasons,and, in the case of in-app purchase,most of them revolve around tracking status.When you have a server, we're able to notify you in real timewhen the status of one of your in-app purchases changesthrough App Store server notifications,and you can call us on-demandto check status at any time using server-to-server APIs.Having a server allows you to validatecustomer access to your content, even if their device is offlineor if the status changes outside the app,so you know if your customeris still subscribed after a renewalor if the coins they bought in your game have been refunded.If you already have a server, you may have set one upfor some of these reasons.If you don't have a server and are thinking of building one,these are strong reasons to consider,as they give you more control of your content.Even when you have a server,our story still begins on an iPhone, iPad,or other device with an in-app purchase.When you send information about that purchase to your server,including things like the transactionId,originalTransactionId, and the receipt,you're now able to track that purchase from your serverby communicating directly with our server.Today, this involves using APIs like verifyReceiptor frameworks like App Store server notifications.We only want to make integrating with our servereven better for you,which brings us to today's content.I'll review all of the changeswe have coming on the server sideand how you can integrate with theseto build a better, stronger server.To start with, I will go through validating accesswith App Store Receipts,tracking status with App Store Server APIs,then I will dive intohow you can track status passivelywith App Store server notifications.I will also go over what this meansfor managing family sharingand how you can test your server in sandbox.Let's get started with validating statususing receipts.Today, our receipts are in the unified app receipt format.To get the JSON version of the receipt,you either have to doan on-device receipt verification in your app or,since we're talking about the server,call our server-to-server verifyReceipt endpoint.When you call us server-to-server,you get this decoded receipt, plus any new transactionsin a latest_receipt_info section,upcoming renewal informationin a pending_renewal_info section,and a latest_receipt.This receipt can be huge, and it contains transactionfrom your entire app, whether they are non-consumables,consumables, subscriptions, or non-renewing subscriptions.This provides you with a ton of information,but we wonder if it can be too much.Additionally, with StoreKit 2,we're introducing new signed transactions in a JWS,or JSON web signature,format on the client side, and we want to providethe same thing to you on the server.Why did we decide to introduce signed transactions?At Apple, we care about security.Using JWS to sign these transactionswill increase securitythrough signing and signature verification.Additionally, the transactions are easyto decode and to verify, so much so that you can do iton your server without having to call us.Let's take a look at these signed transactions now.Our signed transactions consist of three stringsseparated by a period.The first string is a base64-encoded JSON header,then a base64-encoded JSON payload,followed by a signature.If you base64 decode the header,it contains the signing algorithm we used,as well as an x5C claim.This contains the certificate chain you needto verify the signature.We'll get back to verifying the signature in a bit.Next, if you base64 decode the payload,you'll see the receipt JSON.That means all you need to do to decode the transactionis base64 decode the payload,a simple operation that you can do on your ownon your server.Let's take a quick look at the decoded transaction.Just glancing at it, you may notice that somedata types have changed from strings in the previous receiptto more appropriate data types, like numbers or booleans.Also notice that we have reduced date formatsto only one, milliseconds since epoch.We've also added a few new fields.We've added a field called "type,"which tells you the content type the transaction applies to.We also added a field called "appAccountToken."When you provide this value to StoreKit at buy timein your StoreKit 2 app, we persist it on the serverto return it in each of your transactions.We will also return thisnot only in the new signed transactions,but also in our existing unified app receiptfor each transaction.The next two fields I want to call out herearen't really new, but rather renamed.We have renamed cancellation_dateand cancellation_reason to revocation_dateand revocation_reason to make it more clearthat the presence of these fields indicate that serviceshould be revoked, as of the revocation date.These last two fields may look newbut are really a simplificationof some information from our previous receipt.We've combined isTrialPeriod, isIntroOfferPeriod,promotionalOfferIdentifier, and offerCodeRefNameinto offerType and offerIdentifier.offerType tells you what type of offer your customerhas applied to this period, with 1 for an intro offer,2 for a subscription offer, and 3 for an offer code.If the offer type is 2 or 3, you'll also see a valuein the offer identifier fieldwith either the promotional offer IDor the offerCodeRefName.Now, I want to talk about verifyingthe signature portion of the signed transaction info.Verifying the signature is an option for you to validatethat the transaction came from Apple and is trustworthy.If you only want to see the contents of the transaction,this step is not required.However, to verify the signature,you will need to use the claims availablein the header portion of the signed transaction info.Use the alg claim to know what signing algorithm we used,and use the certificate chain in the array in the x5c claim.Once you have these two things,you can use your favorite cryptographic libraryto verify the signature of the signed transaction info.So that covers our changes for App Store Receipts,or, as we call them now, signed transactions.Now, let's move on to how you can check status with APIs.So while you don't need an API like today's verifyReceiptto verify the validity of your signed transactionsor to decode the transactions,we still wanted to build APIsthat would help you on your server.That is why we're introducing a brand-new libraryof App Store Server APIs this year at WWDCthat will provide you with some new featurespreviously unavailable to you on your serverand will also make use of our new signed transactions.So we're going to talk about two brand-new APIsright now: the subscription status API,and the in-app purchase history API.First, I wanna talk about the subscription status API.The subscription status API provides the latest statusof your auto-renewable subscriptions,indicated by an originalTransactionIdfrom your app.With this API, you'll get a quick answeras to your subscriber's status.You'll quickly know whether their subscriptionis active, expired, in a grace period,or other states, with one simple check.Let's take a look at it now.The request to this API is simple, requiring onlyan originalTransactionId in the URL.The response from this API contains a statusfor every subscription your customer is subscribed toin your app,grouped by a subscriptionGroupIdentifier.For each subscriptionGroupIdentifier,we provide a list of the latest transactions, with an entryfor each originalTransactionId in the subscription group.Each entry in this array contains a status,the originalTransactionId,the signedTransactionInfo,and a signedRenewalInfo,also signed in a JWS format.Let's take a closer look at that status field now.The status field will give you a quick answeras to the status of your subscriptionso you can know whether tounlock service for your subscriber.We're starting with five possible values for status:1, meaning that the subscription is active;2, meaning that the subscription is expired;3, meaning that the subscription is in a billing retry period;4, meaning that the subscription is in a grace period;and 5, meaning that the subscription accesshas been revoked due to a cancellationor some other event.Looking at the status field gives you a quick answerabout your subscription.For more information on that status,you can look at the payload of the signed transaction infoand the payload of the signed renewal info.To decode the signedRenewalInfo, follow the same stepsas you would for the signed transaction infoby base64 decoding the payload portion.You can additionally verify the signatureof the signedRenewalInfo in the same manner,using the header.Once decoded, you will see something like this.The renewal info contains the same fields we offerin the pending renewal info section of verifyReceipt todaywith some updates such as including only one date formatand making some fields booleans or numbers where applicable.We will also be adding our new fields offerTypeand offerIdentifier to the signedRenewalInfo.This will let you know if the customer plans toredeem an offer at their next renewal.In addition to the subscription status API,we want to provide a way for you to get all of the transactionsassociated with your app,much like we provide in the latest_receipt_info sectionof verifyReceipt today.For this reason, we're also addingan in-app purchase history API.The in-app purchase history API will provide the history of alltransactions for your app, much like you receivein the latest_receipt_info section of verifyReceipt today.The key difference here is each transactionwill be in the new signed transaction info format,and the API will be paginatedto control the size of the response you receivefrom the App Store.The initial request for this is,like the subscription status API, quite simple.We require only an originalTransactionIdfrom you to process your request.In the response you'll receive app metadata,like your app's Apple ID and bundle ID,and an array of the latest 20 transactions for your appin our new signed transaction info format.We return 20 signed transaction infos to you per request.If you have more transactions, look to the hasMoreand revision values in the response.hasMore will be trueif there are more transactions remaining for your app.In this case, make another request,passing the revision token as a query parameter,to get the next 20 transactions.Repeat this until hasMore is false.Now let's pivot and talk abouthow all of the App Store Server APIswill be consistent with each other.They will all be behind JWT — or JSON web token — authentication,support our new signed transactions,and feature JSON request and response formats.And best of all, they all key off of an originalTransactionIdthat you provide in the request, rather than requiringa receipt and a shared secret in the request.Now, I want to cover JWT authentication.All of our new App Store Server APIswill make use of JSON Web Token, or JWT, authentication.We chose this to increase the securityof communication between our server and yours.To generate this JWT, you will need to downloada private key from App Store Connect.This process will automatically registerthe public key with our server.Then you must sign the token using the ES256 algorithmbefore calling our server.To generate your private key in App Store Connect,navigate to the Users and Access pageand visit the Keys tab.Select the in-app purchase keys option,and you'll see a page like this.Add a key and give it a name.Save the key in a safe place,as you can only download it once,and take note of the key ID.Now, let's take a look at what this JWT actually looks like.A JWT consists of three parts:a header, a payload, and a signature.In the header, you should include the key IDof your private keyand the algorithm used for signing.We require an elliptic curve signaturewith a SHA 256 hash, or ES256.You will also include the type of the token,which, in this case, is always JWT.The payload should include your issuer ID.You can find this value in App Store Connect.You will include the time the token was issuedand the time it should expire, in seconds since epoch.The difference between these two times should beno more than an hour.Include the audience, which is always appstoreconnect-v1.You'll have to generate a nonce, or a one-time unique string.Finally, you'll have to include the bundle identifierof your app.Once you have all of this information,you have to implement the signing of this tokenusing the ES256 algorithm,or an elliptic curve signature with a SHA 256 hash.Before I move on, let's review the key takeawaysof our App Store Server APIs.First, we've separated determining statusfrom looking up the history of transactions,as these are separate functions.Next, these APIs requireonly the originalTransactionId in the request,meaning that you can take the signed transactions you receive,either from your app or from a response from our server,store the fields you're interested in,including originalTransactionId,and then get rid of the signed transaction info.There is no need to store signed transactions anymoreas we have guided you to do with receipts in the past.So that covers how you can check your customer statuswith our new App Store Server APIs.Now, I want to go over how we are makingour App Store server notifications consistentand how you can track status using notifications.Let's first start with a quick reviewof App Store server notifications.We've discussed App Store server notificationsfor a few years now, so let's review why they're useful.With App Store server notifications,you can receive notificationswhen the status of one of your transactions changesdirectly from the App Store.When you receive the notification,you can update your status immediately,without your customer having to open the app on their phone.With App Store server notifications,you also don't need to call us for status.We'll just tell you when something changes.They are one of the most powerful toolsyour server can take advantage of.Our goal for this yearis to make App Store server notificationseven more powerful by making use of our new,easy-to-use signed transactions.In addition to this, we will update the notificationsto make sure only one notification is sentfor one user action,we will update the payload,and the entire payload will be signedusing JWS to enhance security.We'll also allow you to opt in to the v2 notificationswhen you're ready and will continue sendingthe existing notifications for some time.This is our current notification offering for v1 notifications.There are 11 total types,including everything from INITIAL_BUY to REVOKE.With v2 notifications,we're deprecating four of our notification types:INITIAL_BUY, INTERACTIVE_RENEWAL,CANCEL, and PRICE_INCREASE_CONSENT.But we're adding five new types: SUBSCRIBED, OFFER_REDEEMED,EXPIRED, GRACE_PERIOD_EXPIRED, and PRICE_INCREASE.In addition to the new notification types,we're adding a new field called "substate" to the notification.This will help you narrow a more general notification typeto a specific user action.Currently, substates apply tosix of our v2 notification types:SUBSCRIBED, DID_CHANGE_RENEWAL_STATUS,DID_CHANGE_RENEWAL_PREFERENCES,OFFER_REDEEMED, EXPIRED,and PRICE_INCREASE.Let's take a look at some examplesof how substates apply to these notification types.First, I want to talk about the SUBSCRIBED notificationand its substates.When a customer makes a first-time purchase,you will receive SUBSCRIBED with a substate of INITIAL_BUY.When a customer resubscribes to the same SKUor a different SKU,you will receive SUBSCRIBED with a substate of RESUBSCRIBE,as long as the subscriptionis within the same subscription group.One of our new notification typeswithout an equivalent typein v1 App Store server notificationsis the OFFER_REDEEMED notification.So I want to take a look at this example.OFFER_REDEEMED is receivedwhenever a customer redeems a promotional offer.If the customer redeems an offer for a first-time purchase,you'll receive OFFER_REDEEMED with a substate of INITIAL_BUY.If the customer redeems an offer to resubscribeto the same inactive subscription,you'll receive OFFER_REDEEMED with a substate of RESUBSCRIBE.If the customer redeems an offerto upgrade their active subscription,you'll receive OFFER_REDEEMED with a substate of UPGRADE.If the customer redeems an offerto downgrade their active subscription,you'll receive OFFER_REDEEMED with a substate of DOWNGRADE.Additionally, if the customer redeems an offerto resubscribe to their active subscriptionafter canceling within the same period,you will receive OFFER_REDEEMEDwith a substate of AUTO_RENEW_ENABLED.Now, let's look at EXPIRED.With the new EXPIRED notification type,you'll receive EXPIRED when the subscription expiresafter the customer has disabled auto renewwith a substate of VOLUNTARY.If a subscription expires because the billing retry periodhas ended without a successful recovery,you will receive EXPIRED with a substate of BILLING_RETRY.Additionally, if a subscription expires because the customerhas not consented to a price increase,you'll receive EXPIRED with a substate of PRICE_INCREASE.So combining the v2 notification types,plus their applicable substates,we now cover over 20 differentcustomer life cycle events.Just looking at the notification type should be enoughto get a general idea of what has changed in your purchase,but looking at the substatewill help you get a more specific stateif you want to go into more detail.Now let's take a quick look at the new payload.For v2 notifications we will always includethe same set of fields,regardless of the notification type.The notification type, the subtype,the notification version,which will be 2 if you subscribed to v2 notifications,the environment the notification applies to,some app metadata like bundle ID,the app Apple ID, and bundle version,the latest transaction for the affected in-appin our new signedTransactionInfo format,and the latest renewal info for the in-appin our new signedRenewalInfo format.These changes will make the notifications easier to parseand hopefully easier to adoptas they make use of our new signed transactionsand only contain informationabout the affected in-app purchase.As I mentioned earlier,the entire payload will be signedto increase the security and trustworthinessof our notifications.The payload we just saw is unsigned for readability,but the signing will be similarto how we are signing transactions and renewal infoin a JWS format.We want you to be able to opt in to v2 notificationswhen you're ready.For this reason, we're adding an optionto the notification URL in App Store Connectto allow you to selectyour App Store server notification version.To do this, go to your App's pageand scroll to the newApp Store Server Notifications section.If you select the production server URL,you now have the option to choose version 1or version 2 App Store server notifications.When these changes launch later this year,you'll be able to opt into version 2 App Store server notifications.So now, I want to go over some example scenariosusing our new App Store server notifications,starting with the first-time purchase of a subscription.For a first-time subscription purchase in your app,you'll receive a signed transaction infoas a result of the purchase.You can choose to verify this on your appand send the originalTransactionIdand other relevant fields to your serveror send the signed transaction infoto your server for verificationand choose which fields to store in your database at that time.Around the same time, you'll receivea SUBSCRIBED notification with a substate of INITIAL_BUY.Now that the signed transaction info in the notificationcontains the app account token,you can immediately link this notificationto your in-app user,even if communication is lost between your serverand your app after the purchase.There's no need to call our serverto verify the signed transaction info.You may call our server at any timeif you wish to check the status or in-app purchase history APIby sending us the originalTransactionId.Now I've covered purchasing a subscription.Let's move onto subscription renewal.Now we've reached the renewal of this subscription.If this subscription renews successfully,you will receive a notification type DID_RENEW.You can look at the signed transaction infoand the signed renewal info in the payloadto verify the next renewal date of your subscriptionand your customer's renewal preferencesfor their next renewal.You can also schedule a jobto call our subscription status APIto check the status of your subscriptionat its renewal time as a fail-over mechanism.Once again, there's no need to call usto verify the transaction you receive in the notification.Of course, auto-renew doesn't always go according to plan,especially if there is a billing issue.So now, I want to cover grace period and billing retry.Now let's suppose that your subscriptiondid not renew as expected.When this happens, we notify youwith a DID_FAIL_TO_RENEW notification.If you have grace period enabledand the subscription exits the grace periodwithout renewing successfully, we send youa GRACE_PERIOD_EXPIRED notification,and you can know that your customerhas entered the billing retry period.If the subscription still is not recoveredduring the billing retry period,we'll send you an EXPIRED notificationwith a substage of BILLING_RETRY.If we recover the billing of the subscriptionduring the grace period or the billing retry period,we'll send you a DID_RECOVER notification.No matter the outcome of the renewal,we notify you of the result with a v2 notification,containing a signed transaction info and signed renewal info.You can call the subscription status or history APIat any point in this processto double check your subscription status.Now, we realize subscriptionsare not the only thing customers will purchase in your app.So now let's pivot and cover what to expectduring a first-time purchase of a consumable.For a first-time purchase for a consumable on your app,you'll receive a signed transaction infoas a result of the purchase.You can choose to verify this on your appand send the originalTransactionIdand other relevant fields to your serveror send the signed transaction info to your serverfor verificationand choose which fields to store in your database at that time.Keep note of the originalTransactionId always,as you might need it later.For consumables and other content typeslike non-consumables and non-renewing subscriptions,not much changes over the life cycle of that purchaseunless the customer requests a refund.So I want to cover that case now.Now, suppose your customer requests a refundfor their consumable purchase.We'll send you a REFUND notification,containing the revocation date and revocation reasonin the signed transaction info.You can know to stop providing accessto the consumable purchase after the revocation date.Should you be concerned about the statusof your consumable purchase at any time,you can call the in-app history APIand look for it in the response.Canceled consumables will always be included,so you will know if the transaction status has changed.Now I want to talk about outages.Sometimes, despite best efforts,you may experience an outage on your server.Now I'll cover how you can help your serverrecover from an outage.If you experience an outage on your serverand you miss App Store server notifications,you'll want to know what has changed in the interim.The in-app history API is your solution here.Simply call the API for each customer,providing any originalTransactionIdfrom your app, and you'll getthe latest history of transactions for your appso you can update your server.You can then call the subscription status APIto get the latest subscription statusfor each of your subscriptions.Now I want to cover one final case--migrating to signed transactions on your server.This is especially importantif you'll be ready to update your server before your appor if you're still receiving the unified app receiptfrom older versions of your app.Migrating to signed transactions on your server is easy,as it only requires an originalTransactionId.You can easily convert the unified app receiptsyour server receives from your app to JWS receiptsso your server can be compatible with our App Store server APIsand App Store server notifications.To do this, first call verifyReceiptwith the unified app receiptand pull all of the unique originalTransactionIdsfrom the response.Call the in-app purchase history APIfor one of these originalTransactionIdsto get the history for your app in signed transactions.Then call the subscription status APIfor a subscription originalTransactionIdto get signed transactions and signedRenewalInformationfor all of your customer subscriptions.Write down any relevant datafrom the payload of the signed transaction,and you're all set to continue using these APIsand to receive v2 App Store server notifications.So now I've covered all of the changes we have comingfor App Store Server Notificationsand how you can use notificationsto check your customer status.Now I want to talk about how we are making iteven easier for you to manage family sharingfor in-app purchases from your server.Family sharing for in-app purchases is currently supportedfor auto-renewable subscriptions and non-consumable purchases,if you have enabled family sharingfor that in-app purchase in App Store Connect.Right now, we provide a field called inAppOwnershipTypeto indicate if a transaction is family shared or purchased,and we support a subset of notificationsfor family members: REVOKE, DID_RECOVER,and DID_FAIL_TO_RENEW.The in-app ownership type fieldand the existing supported notification typeswill remain with our new signed transactionsand App Store server notifications v2.However, coming later this year,we're adding more support for App Store server notificationsfor family members.For v1 notifications, we're addingDID_CHANGE_RENEWAL_STATUS,DID_CHANGE_RENEWAL_PREF,DID_RENEW, and INTERACTIVE_RENEWAL.For v2 notifications,we're adding even more support for family members.In addition to DID_CHANGE_RENEWAL_STATUS,DID_CHANGE_RENEWAL_PREF, and DID_RENEW,we're adding support for SUBSCRIBED, EXPIRED,GRACE_PERIOD_EXPIRED, and OFFER_REDEEMEDfor purchasers as well as for family members.This will make it even easier for you to track the statusof all your customers,both purchasers and family members,through App Store server notifications.So with the changes we have coming for notificationsfor family members this year,this should make managing family sharing for in-app purchaseseven easier for youwhen coupled with our existing family sharing functionality.Now I want to wrap up with one more thing:testing your server in sandbox.We want you to feel confident in your app and your server.So we want you to be ableto integrate with our new App Store Server APIsand App Store server notifications in sandboxbefore production.For the App Store Server APIs we discussed today,that means that they are fully testable in sandbox,and live, starting now!This includes the subscription status APIand the in-app purchase history API.In addition to this,we're adding a few other new features in sandbox.Coming later this year, you will be able to adda sandbox-specific notification URL in App Store Connect.With this addition, you can keep your productionand sandbox notifications completely separate.Additionally, you'll also be able to chooseyour sandbox notification versionso you can test v2 notifications in sandbox before production.Last year, we brought you some exciting sandbox improvements,like resetting trial eligibilityand providing a Manage Subscriptions page in sandbox.We want to continue making testing in sandbox easierand are adding a few new enhancements this year.These are clearing purchase history for a sandbox Apple ID,changing sandbox account region,and adjusting subscription renewal rate in sandbox.Additionally, as a security enhancement,we are returning an error from verifyReceiptfor TestFlight receiptswhen we detect the customer is no longer a TestFlight user.These new sandbox enhancements will be accessiblefrom the Sandbox Testers page in App Store Connect.To clear purchase history, select edit,then toggle a tester,and select the clear purchase history button.Once you confirm clearing purchase history for a tester,the action cannot be reversed.So remember the testers you've selected this option for.Clearing purchase historyis a powerful new testing tool for youthat enables you to purchase something againwithout creating a new account.It also allows you to have a fresh,empty receipt for testing.To change account regionor adjust subscription renewal rate,navigate back to the testers pageand select a tester row.In the tester settings,you will see the new options to change App Store regionand to adjust subscription renewal rate.You can change the account region for a testerby selecting the desired region.This makes it possible to test in 175 storefronts in sandbox,all with one tester account.Our final new sandbox featureis adjusting your subscription renewal rate in sandbox.To edit this, select your desired renewal ratefrom the drop-down.Right now, a month correlates to 5 minutes in sandbox.We'll give you some more optionsto adjust the renewal rate for your testers.Adjusting the subscription renewal rategives you more time to do things like cancel, upgrade,or downgrade a subscription,and it allows you to rapidly speed up renewalsto simulate longer-term customers.That is everything we have coming to sandbox this year.We hope you love testing with these new features.So we've covered a lot of new information today,and now I want you to be able to explore all of it.I hope you take some time to update your appsand servers to adopt our new JWS receipts.Make use of our new App Store Server APIs,especially in sandbox, where they are live right now.And enroll in App Store server notificationsif you haven't alreadyand get ready for the v2 update coming later this year.Our new sandbox enhancements are also coming later this year.Make use of these to enhance your sandbox testing experience.Finally, check out the other two sessionsfrom this year in this series,"Meet StoreKit 2" and "Support customers and handle refunds."For more background on App Store server notificationsand how you can set them up,check out "What's new with in-app purchase"from WWDC 2020and "In-app purchases and using server-to-server notifications"from WWDC 2019.Our receipts, APIs, and notificationsare three powerful tools you haveto manage your in-app purchases from your server.By taking advantage of these, you can make your serverand your app more powerful than ever.Please take advantage of all the new featureswe've gone over today,and we look forward to hearing your feedback.Thanks so much for listening today,and enjoy the rest of WWDC.[upbeat music]

Hello, and welcome to WWDC.I'm Tori, and I'm so excited to talk to youabout the new features we have coming for your serverand to help set some guidelines for running an effective serverto track the status of all of your in-app purchases.So, let's dive right in.

This session is part two of a three-session seriesfocusing on in-app purchases.If you've not already watched "Meet StoreKit 2"or "Support customers and handle refunds,"I recommend you take a look after this sessionso you can get the full story.

For this session, we're going to focus onthe server and how you can build your serverto manage your in-app purchases.To get us started in this session, let's first talk aboutsome of the reasons it's useful to have a server.Having a server is useful for several reasons,and, in the case of in-app purchase,most of them revolve around tracking status.When you have a server, we're able to notify you in real timewhen the status of one of your in-app purchases changesthrough App Store server notifications,and you can call us on-demandto check status at any time using server-to-server APIs.Having a server allows you to validatecustomer access to your content, even if their device is offlineor if the status changes outside the app,so you know if your customeris still subscribed after a renewalor if the coins they bought in your game have been refunded.If you already have a server, you may have set one upfor some of these reasons.If you don't have a server and are thinking of building one,these are strong reasons to consider,as they give you more control of your content.Even when you have a server,our story still begins on an iPhone, iPad,or other device with an in-app purchase.When you send information about that purchase to your server,including things like the transactionId,originalTransactionId, and the receipt,you're now able to track that purchase from your serverby communicating directly with our server.Today, this involves using APIs like verifyReceiptor frameworks like App Store server notifications.We only want to make integrating with our servereven better for you,which brings us to today's content.I'll review all of the changeswe have coming on the server sideand how you can integrate with theseto build a better, stronger server.To start with, I will go through validating accesswith App Store Receipts,tracking status with App Store Server APIs,then I will dive intohow you can track status passivelywith App Store server notifications.

I will also go over what this meansfor managing family sharingand how you can test your server in sandbox.

Let's get started with validating statususing receipts.Today, our receipts are in the unified app receipt format.To get the JSON version of the receipt,you either have to doan on-device receipt verification in your app or,since we're talking about the server,call our server-to-server verifyReceipt endpoint.When you call us server-to-server,you get this decoded receipt, plus any new transactionsin a latest_receipt_info section,upcoming renewal informationin a pending_renewal_info section,and a latest_receipt.This receipt can be huge, and it contains transactionfrom your entire app, whether they are non-consumables,consumables, subscriptions, or non-renewing subscriptions.This provides you with a ton of information,but we wonder if it can be too much.Additionally, with StoreKit 2,we're introducing new signed transactions in a JWS,or JSON web signature,format on the client side, and we want to providethe same thing to you on the server.Why did we decide to introduce signed transactions?At Apple, we care about security.Using JWS to sign these transactionswill increase securitythrough signing and signature verification.Additionally, the transactions are easyto decode and to verify, so much so that you can do iton your server without having to call us.Let's take a look at these signed transactions now.Our signed transactions consist of three stringsseparated by a period.The first string is a base64-encoded JSON header,then a base64-encoded JSON payload,followed by a signature.If you base64 decode the header,it contains the signing algorithm we used,as well as an x5C claim.This contains the certificate chain you needto verify the signature.We'll get back to verifying the signature in a bit.Next, if you base64 decode the payload,you'll see the receipt JSON.That means all you need to do to decode the transactionis base64 decode the payload,a simple operation that you can do on your ownon your server.Let's take a quick look at the decoded transaction.Just glancing at it, you may notice that somedata types have changed from strings in the previous receiptto more appropriate data types, like numbers or booleans.Also notice that we have reduced date formatsto only one, milliseconds since epoch.We've also added a few new fields.We've added a field called "type,"which tells you the content type the transaction applies to.We also added a field called "appAccountToken."When you provide this value to StoreKit at buy timein your StoreKit 2 app, we persist it on the serverto return it in each of your transactions.We will also return thisnot only in the new signed transactions,but also in our existing unified app receiptfor each transaction.The next two fields I want to call out herearen't really new, but rather renamed.We have renamed cancellation_dateand cancellation_reason to revocation_dateand revocation_reason to make it more clearthat the presence of these fields indicate that serviceshould be revoked, as of the revocation date.These last two fields may look newbut are really a simplificationof some information from our previous receipt.We've combined isTrialPeriod, isIntroOfferPeriod,promotionalOfferIdentifier, and offerCodeRefNameinto offerType and offerIdentifier.offerType tells you what type of offer your customerhas applied to this period, with 1 for an intro offer,2 for a subscription offer, and 3 for an offer code.If the offer type is 2 or 3, you'll also see a valuein the offer identifier fieldwith either the promotional offer IDor the offerCodeRefName.Now, I want to talk about verifyingthe signature portion of the signed transaction info.Verifying the signature is an option for you to validatethat the transaction came from Apple and is trustworthy.If you only want to see the contents of the transaction,this step is not required.However, to verify the signature,you will need to use the claims availablein the header portion of the signed transaction info.Use the alg claim to know what signing algorithm we used,and use the certificate chain in the array in the x5c claim.

Once you have these two things,you can use your favorite cryptographic libraryto verify the signature of the signed transaction info.So that covers our changes for App Store Receipts,or, as we call them now, signed transactions.

Now, let's move on to how you can check status with APIs.So while you don't need an API like today's verifyReceiptto verify the validity of your signed transactionsor to decode the transactions,we still wanted to build APIsthat would help you on your server.That is why we're introducing a brand-new libraryof App Store Server APIs this year at WWDCthat will provide you with some new featurespreviously unavailable to you on your serverand will also make use of our new signed transactions.So we're going to talk about two brand-new APIsright now: the subscription status API,and the in-app purchase history API.First, I wanna talk about the subscription status API.The subscription status API provides the latest statusof your auto-renewable subscriptions,indicated by an originalTransactionIdfrom your app.With this API, you'll get a quick answeras to your subscriber's status.You'll quickly know whether their subscriptionis active, expired, in a grace period,or other states, with one simple check.Let's take a look at it now.The request to this API is simple, requiring onlyan originalTransactionId in the URL.The response from this API contains a statusfor every subscription your customer is subscribed toin your app,grouped by a subscriptionGroupIdentifier.For each subscriptionGroupIdentifier,we provide a list of the latest transactions, with an entryfor each originalTransactionId in the subscription group.Each entry in this array contains a status,the originalTransactionId,the signedTransactionInfo,and a signedRenewalInfo,also signed in a JWS format.Let's take a closer look at that status field now.

The status field will give you a quick answeras to the status of your subscriptionso you can know whether tounlock service for your subscriber.We're starting with five possible values for status:1, meaning that the subscription is active;2, meaning that the subscription is expired;3, meaning that the subscription is in a billing retry period;4, meaning that the subscription is in a grace period;and 5, meaning that the subscription accesshas been revoked due to a cancellationor some other event.Looking at the status field gives you a quick answerabout your subscription.For more information on that status,you can look at the payload of the signed transaction infoand the payload of the signed renewal info.To decode the signedRenewalInfo, follow the same stepsas you would for the signed transaction infoby base64 decoding the payload portion.

You can additionally verify the signatureof the signedRenewalInfo in the same manner,using the header.Once decoded, you will see something like this.The renewal info contains the same fields we offerin the pending renewal info section of verifyReceipt todaywith some updates such as including only one date formatand making some fields booleans or numbers where applicable.We will also be adding our new fields offerTypeand offerIdentifier to the signedRenewalInfo.This will let you know if the customer plans toredeem an offer at their next renewal.In addition to the subscription status API,we want to provide a way for you to get all of the transactionsassociated with your app,much like we provide in the latest_receipt_info sectionof verifyReceipt today.For this reason, we're also addingan in-app purchase history API.The in-app purchase history API will provide the history of alltransactions for your app, much like you receivein the latest_receipt_info section of verifyReceipt today.The key difference here is each transactionwill be in the new signed transaction info format,and the API will be paginatedto control the size of the response you receivefrom the App Store.The initial request for this is,like the subscription status API, quite simple.We require only an originalTransactionIdfrom you to process your request.

In the response you'll receive app metadata,like your app's Apple ID and bundle ID,and an array of the latest 20 transactions for your appin our new signed transaction info format.We return 20 signed transaction infos to you per request.If you have more transactions, look to the hasMoreand revision values in the response.hasMore will be trueif there are more transactions remaining for your app.In this case, make another request,passing the revision token as a query parameter,to get the next 20 transactions.Repeat this until hasMore is false.Now let's pivot and talk abouthow all of the App Store Server APIswill be consistent with each other.They will all be behind JWT — or JSON web token — authentication,support our new signed transactions,and feature JSON request and response formats.And best of all, they all key off of an originalTransactionIdthat you provide in the request, rather than requiringa receipt and a shared secret in the request.Now, I want to cover JWT authentication.All of our new App Store Server APIswill make use of JSON Web Token, or JWT, authentication.We chose this to increase the securityof communication between our server and yours.To generate this JWT, you will need to downloada private key from App Store Connect.This process will automatically registerthe public key with our server.Then you must sign the token using the ES256 algorithmbefore calling our server.To generate your private key in App Store Connect,navigate to the Users and Access pageand visit the Keys tab.Select the in-app purchase keys option,and you'll see a page like this.Add a key and give it a name.Save the key in a safe place,as you can only download it once,and take note of the key ID.Now, let's take a look at what this JWT actually looks like.A JWT consists of three parts:a header, a payload, and a signature.In the header, you should include the key IDof your private keyand the algorithm used for signing.We require an elliptic curve signaturewith a SHA 256 hash, or ES256.You will also include the type of the token,which, in this case, is always JWT.The payload should include your issuer ID.You can find this value in App Store Connect.You will include the time the token was issuedand the time it should expire, in seconds since epoch.The difference between these two times should beno more than an hour.Include the audience, which is always appstoreconnect-v1.

You'll have to generate a nonce, or a one-time unique string.Finally, you'll have to include the bundle identifierof your app.Once you have all of this information,you have to implement the signing of this tokenusing the ES256 algorithm,or an elliptic curve signature with a SHA 256 hash.Before I move on, let's review the key takeawaysof our App Store Server APIs.First, we've separated determining statusfrom looking up the history of transactions,as these are separate functions.Next, these APIs requireonly the originalTransactionId in the request,meaning that you can take the signed transactions you receive,either from your app or from a response from our server,store the fields you're interested in,including originalTransactionId,and then get rid of the signed transaction info.There is no need to store signed transactions anymoreas we have guided you to do with receipts in the past.So that covers how you can check your customer statuswith our new App Store Server APIs.Now, I want to go over how we are makingour App Store server notifications consistentand how you can track status using notifications.Let's first start with a quick reviewof App Store server notifications.We've discussed App Store server notificationsfor a few years now, so let's review why they're useful.With App Store server notifications,you can receive notificationswhen the status of one of your transactions changesdirectly from the App Store.When you receive the notification,you can update your status immediately,without your customer having to open the app on their phone.With App Store server notifications,you also don't need to call us for status.We'll just tell you when something changes.They are one of the most powerful toolsyour server can take advantage of.Our goal for this yearis to make App Store server notificationseven more powerful by making use of our new,easy-to-use signed transactions.In addition to this, we will update the notificationsto make sure only one notification is sentfor one user action,we will update the payload,and the entire payload will be signedusing JWS to enhance security.We'll also allow you to opt in to the v2 notificationswhen you're ready and will continue sendingthe existing notifications for some time.This is our current notification offering for v1 notifications.There are 11 total types,including everything from INITIAL_BUY to REVOKE.With v2 notifications,we're deprecating four of our notification types:INITIAL_BUY, INTERACTIVE_RENEWAL,CANCEL, and PRICE_INCREASE_CONSENT.But we're adding five new types: SUBSCRIBED, OFFER_REDEEMED,EXPIRED, GRACE_PERIOD_EXPIRED, and PRICE_INCREASE.In addition to the new notification types,we're adding a new field called "substate" to the notification.This will help you narrow a more general notification typeto a specific user action.Currently, substates apply tosix of our v2 notification types:SUBSCRIBED, DID_CHANGE_RENEWAL_STATUS,DID_CHANGE_RENEWAL_PREFERENCES,OFFER_REDEEMED, EXPIRED,and PRICE_INCREASE.Let's take a look at some examplesof how substates apply to these notification types.First, I want to talk about the SUBSCRIBED notificationand its substates.When a customer makes a first-time purchase,you will receive SUBSCRIBED with a substate of INITIAL_BUY.When a customer resubscribes to the same SKUor a different SKU,you will receive SUBSCRIBED with a substate of RESUBSCRIBE,as long as the subscriptionis within the same subscription group.One of our new notification typeswithout an equivalent typein v1 App Store server notificationsis the OFFER_REDEEMED notification.So I want to take a look at this example.OFFER_REDEEMED is receivedwhenever a customer redeems a promotional offer.If the customer redeems an offer for a first-time purchase,you'll receive OFFER_REDEEMED with a substate of INITIAL_BUY.If the customer redeems an offer to resubscribeto the same inactive subscription,you'll receive OFFER_REDEEMED with a substate of RESUBSCRIBE.If the customer redeems an offerto upgrade their active subscription,you'll receive OFFER_REDEEMED with a substate of UPGRADE.If the customer redeems an offerto downgrade their active subscription,you'll receive OFFER_REDEEMED with a substate of DOWNGRADE.Additionally, if the customer redeems an offerto resubscribe to their active subscriptionafter canceling within the same period,you will receive OFFER_REDEEMEDwith a substate of AUTO_RENEW_ENABLED.

Now, let's look at EXPIRED.With the new EXPIRED notification type,you'll receive EXPIRED when the subscription expiresafter the customer has disabled auto renewwith a substate of VOLUNTARY.If a subscription expires because the billing retry periodhas ended without a successful recovery,you will receive EXPIRED with a substate of BILLING_RETRY.Additionally, if a subscription expires because the customerhas not consented to a price increase,you'll receive EXPIRED with a substate of PRICE_INCREASE.So combining the v2 notification types,plus their applicable substates,we now cover over 20 differentcustomer life cycle events.Just looking at the notification type should be enoughto get a general idea of what has changed in your purchase,but looking at the substatewill help you get a more specific stateif you want to go into more detail.Now let's take a quick look at the new payload.For v2 notifications we will always includethe same set of fields,regardless of the notification type.The notification type, the subtype,the notification version,which will be 2 if you subscribed to v2 notifications,the environment the notification applies to,some app metadata like bundle ID,the app Apple ID, and bundle version,the latest transaction for the affected in-appin our new signedTransactionInfo format,and the latest renewal info for the in-appin our new signedRenewalInfo format.These changes will make the notifications easier to parseand hopefully easier to adoptas they make use of our new signed transactionsand only contain informationabout the affected in-app purchase.As I mentioned earlier,the entire payload will be signedto increase the security and trustworthinessof our notifications.The payload we just saw is unsigned for readability,but the signing will be similarto how we are signing transactions and renewal infoin a JWS format.We want you to be able to opt in to v2 notificationswhen you're ready.For this reason, we're adding an optionto the notification URL in App Store Connectto allow you to selectyour App Store server notification version.To do this, go to your App's pageand scroll to the newApp Store Server Notifications section.If you select the production server URL,you now have the option to choose version 1or version 2 App Store server notifications.When these changes launch later this year,you'll be able to opt into version 2 App Store server notifications.So now, I want to go over some example scenariosusing our new App Store server notifications,starting with the first-time purchase of a subscription.For a first-time subscription purchase in your app,you'll receive a signed transaction infoas a result of the purchase.You can choose to verify this on your appand send the originalTransactionIdand other relevant fields to your serveror send the signed transaction infoto your server for verificationand choose which fields to store in your database at that time.Around the same time, you'll receivea SUBSCRIBED notification with a substate of INITIAL_BUY.Now that the signed transaction info in the notificationcontains the app account token,you can immediately link this notificationto your in-app user,even if communication is lost between your serverand your app after the purchase.There's no need to call our serverto verify the signed transaction info.You may call our server at any timeif you wish to check the status or in-app purchase history APIby sending us the originalTransactionId.Now I've covered purchasing a subscription.Let's move onto subscription renewal.Now we've reached the renewal of this subscription.If this subscription renews successfully,you will receive a notification type DID_RENEW.You can look at the signed transaction infoand the signed renewal info in the payloadto verify the next renewal date of your subscriptionand your customer's renewal preferencesfor their next renewal.You can also schedule a jobto call our subscription status APIto check the status of your subscriptionat its renewal time as a fail-over mechanism.Once again, there's no need to call usto verify the transaction you receive in the notification.Of course, auto-renew doesn't always go according to plan,especially if there is a billing issue.So now, I want to cover grace period and billing retry.Now let's suppose that your subscriptiondid not renew as expected.When this happens, we notify youwith a DID_FAIL_TO_RENEW notification.If you have grace period enabledand the subscription exits the grace periodwithout renewing successfully, we send youa GRACE_PERIOD_EXPIRED notification,and you can know that your customerhas entered the billing retry period.If the subscription still is not recoveredduring the billing retry period,we'll send you an EXPIRED notificationwith a substage of BILLING_RETRY.If we recover the billing of the subscriptionduring the grace period or the billing retry period,we'll send you a DID_RECOVER notification.No matter the outcome of the renewal,we notify you of the result with a v2 notification,containing a signed transaction info and signed renewal info.You can call the subscription status or history APIat any point in this processto double check your subscription status.Now, we realize subscriptionsare not the only thing customers will purchase in your app.So now let's pivot and cover what to expectduring a first-time purchase of a consumable.For a first-time purchase for a consumable on your app,you'll receive a signed transaction infoas a result of the purchase.You can choose to verify this on your appand send the originalTransactionIdand other relevant fields to your serveror send the signed transaction info to your serverfor verificationand choose which fields to store in your database at that time.Keep note of the originalTransactionId always,as you might need it later.For consumables and other content typeslike non-consumables and non-renewing subscriptions,not much changes over the life cycle of that purchaseunless the customer requests a refund.So I want to cover that case now.Now, suppose your customer requests a refundfor their consumable purchase.We'll send you a REFUND notification,containing the revocation date and revocation reasonin the signed transaction info.You can know to stop providing accessto the consumable purchase after the revocation date.Should you be concerned about the statusof your consumable purchase at any time,you can call the in-app history APIand look for it in the response.Canceled consumables will always be included,so you will know if the transaction status has changed.Now I want to talk about outages.Sometimes, despite best efforts,you may experience an outage on your server.Now I'll cover how you can help your serverrecover from an outage.If you experience an outage on your serverand you miss App Store server notifications,you'll want to know what has changed in the interim.The in-app history API is your solution here.Simply call the API for each customer,providing any originalTransactionIdfrom your app, and you'll getthe latest history of transactions for your appso you can update your server.You can then call the subscription status APIto get the latest subscription statusfor each of your subscriptions.Now I want to cover one final case--migrating to signed transactions on your server.This is especially importantif you'll be ready to update your server before your appor if you're still receiving the unified app receiptfrom older versions of your app.Migrating to signed transactions on your server is easy,as it only requires an originalTransactionId.You can easily convert the unified app receiptsyour server receives from your app to JWS receiptsso your server can be compatible with our App Store server APIsand App Store server notifications.To do this, first call verifyReceiptwith the unified app receiptand pull all of the unique originalTransactionIdsfrom the response.Call the in-app purchase history APIfor one of these originalTransactionIdsto get the history for your app in signed transactions.Then call the subscription status APIfor a subscription originalTransactionIdto get signed transactions and signedRenewalInformationfor all of your customer subscriptions.Write down any relevant datafrom the payload of the signed transaction,and you're all set to continue using these APIsand to receive v2 App Store server notifications.So now I've covered all of the changes we have comingfor App Store Server Notificationsand how you can use notificationsto check your customer status.

Now I want to talk about how we are making iteven easier for you to manage family sharingfor in-app purchases from your server.Family sharing for in-app purchases is currently supportedfor auto-renewable subscriptions and non-consumable purchases,if you have enabled family sharingfor that in-app purchase in App Store Connect.Right now, we provide a field called inAppOwnershipTypeto indicate if a transaction is family shared or purchased,and we support a subset of notificationsfor family members: REVOKE, DID_RECOVER,and DID_FAIL_TO_RENEW.The in-app ownership type fieldand the existing supported notification typeswill remain with our new signed transactionsand App Store server notifications v2.However, coming later this year,we're adding more support for App Store server notificationsfor family members.For v1 notifications, we're addingDID_CHANGE_RENEWAL_STATUS,DID_CHANGE_RENEWAL_PREF,DID_RENEW, and INTERACTIVE_RENEWAL.For v2 notifications,we're adding even more support for family members.In addition to DID_CHANGE_RENEWAL_STATUS,DID_CHANGE_RENEWAL_PREF, and DID_RENEW,we're adding support for SUBSCRIBED, EXPIRED,GRACE_PERIOD_EXPIRED, and OFFER_REDEEMEDfor purchasers as well as for family members.This will make it even easier for you to track the statusof all your customers,both purchasers and family members,through App Store server notifications.So with the changes we have coming for notificationsfor family members this year,this should make managing family sharing for in-app purchaseseven easier for youwhen coupled with our existing family sharing functionality.Now I want to wrap up with one more thing:testing your server in sandbox.We want you to feel confident in your app and your server.So we want you to be ableto integrate with our new App Store Server APIsand App Store server notifications in sandboxbefore production.For the App Store Server APIs we discussed today,that means that they are fully testable in sandbox,and live, starting now!This includes the subscription status APIand the in-app purchase history API.In addition to this,we're adding a few other new features in sandbox.Coming later this year, you will be able to adda sandbox-specific notification URL in App Store Connect.With this addition, you can keep your productionand sandbox notifications completely separate.Additionally, you'll also be able to chooseyour sandbox notification versionso you can test v2 notifications in sandbox before production.Last year, we brought you some exciting sandbox improvements,like resetting trial eligibilityand providing a Manage Subscriptions page in sandbox.We want to continue making testing in sandbox easierand are adding a few new enhancements this year.These are clearing purchase history for a sandbox Apple ID,changing sandbox account region,and adjusting subscription renewal rate in sandbox.Additionally, as a security enhancement,we are returning an error from verifyReceiptfor TestFlight receiptswhen we detect the customer is no longer a TestFlight user.These new sandbox enhancements will be accessiblefrom the Sandbox Testers page in App Store Connect.To clear purchase history, select edit,then toggle a tester,and select the clear purchase history button.Once you confirm clearing purchase history for a tester,the action cannot be reversed.So remember the testers you've selected this option for.Clearing purchase historyis a powerful new testing tool for youthat enables you to purchase something againwithout creating a new account.It also allows you to have a fresh,empty receipt for testing.To change account regionor adjust subscription renewal rate,navigate back to the testers pageand select a tester row.

In the tester settings,you will see the new options to change App Store regionand to adjust subscription renewal rate.

You can change the account region for a testerby selecting the desired region.This makes it possible to test in 175 storefronts in sandbox,all with one tester account.Our final new sandbox featureis adjusting your subscription renewal rate in sandbox.To edit this, select your desired renewal ratefrom the drop-down.Right now, a month correlates to 5 minutes in sandbox.We'll give you some more optionsto adjust the renewal rate for your testers.Adjusting the subscription renewal rategives you more time to do things like cancel, upgrade,or downgrade a subscription,and it allows you to rapidly speed up renewalsto simulate longer-term customers.That is everything we have coming to sandbox this year.We hope you love testing with these new features.So we've covered a lot of new information today,and now I want you to be able to explore all of it.I hope you take some time to update your appsand servers to adopt our new JWS receipts.Make use of our new App Store Server APIs,especially in sandbox, where they are live right now.And enroll in App Store server notificationsif you haven't alreadyand get ready for the v2 update coming later this year.Our new sandbox enhancements are also coming later this year.Make use of these to enhance your sandbox testing experience.Finally, check out the other two sessionsfrom this year in this series,"Meet StoreKit 2" and "Support customers and handle refunds."For more background on App Store server notificationsand how you can set them up,check out "What's new with in-app purchase"from WWDC 2020and "In-app purchases and using server-to-server notifications"from WWDC 2019.Our receipts, APIs, and notificationsare three powerful tools you haveto manage your in-app purchases from your server.By taking advantage of these, you can make your serverand your app more powerful than ever.Please take advantage of all the new featureswe've gone over today,and we look forward to hearing your feedback.Thanks so much for listening today,and enjoy the rest of WWDC.[upbeat music]

## Code Samples


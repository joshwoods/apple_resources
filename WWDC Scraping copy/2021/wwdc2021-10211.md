# Wwdc2021 10211

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Symbolication: Beyond the basicsDiscover how you can achieve maximum performance and insightful debugging with your app. Symbolication is at the center of tools such as Instruments and LLDB to help bridge the layers between your application's runtime and your source code. Learn how this process works and the steps you can take to gain the most insight into your app.ResourcesHD VideoSD VideoRelated VideosWWDC22Debug Swift debugging with LLDB

Discover how you can achieve maximum performance and insightful debugging with your app. Symbolication is at the center of tools such as Instruments and LLDB to help bridge the layers between your application's runtime and your source code. Learn how this process works and the steps you can take to gain the most insight into your app.

HD VideoSD Video

HD Video

SD Video

Debug Swift debugging with LLDB

Search this video…♪ Bass music playing ♪♪Alejandro Lucena: Hello, everyone.Thank you for attending this session on symbolication.While symbolication may seem like a vague term,we'll see the instrumental role it plays in helping youto quickly identify the root causes of bugs,crashes, and performance bottlenecks.We'll gain a deeper intuition as to how symbolication worksand cover several tools that you have at your disposalto follow along firsthand.Along the way, we'll discussthe various sources of debug informationthat are necessary for a rich symbolication experienceand how you can configure your appto best utilize this information.Let's get started by familiarizing ourselveswith a concrete definition and example of symbolication.Fundamentally, symbolication is a mechanismto convert or translatehow our devices see our apps at runtime —which is in terms of memory addresses and instructions —back to how we as developers see our apps —which is in terms of functions, names, and files.Without this bridging layer,it vastly complicates diagnosing a bugeven for a few lines of code.As an example, let's consider this Swift code.Here I have a function, `generateMagicNumber()`,that selects a particular numberfrom a list of candidate numbers.To do this, we first call into `numberChoices()`that returns an array of 10 randomly generated numbers.Then, we pass that array into `selectMagicNumber(choices:)`,which returns the number at a particular index.This seems like a reasonable program,but I encounter a crash when I first run it.My first recourse is to check the crash log,which is rather unfruitful.All I can tell from the thread backtraceis that my MagicNumbers app crashed somewhere.Thanks, but I already knew that.I have no ideawhat any of the registers are referring to either.I can try to step through the app with the debuggerand identify the crash, but what if this only happensin particular circumstances that I can't reproduce?Using the debugger won't necessarily pinpointthe problem for me in that case.Or I can try to look at the disassembly,but it's much more difficult to keep track of things.This clearly isn't a viable way to diagnose the problem,and more importantly, with the help of symbolication,we don't have to debug from this starting point.The Xcode Organizer tells me I can download the dSYMfor this app, which will reprocess the crash log.In doing so, Xcode applies the concepts of symbolicationso that I can diagnose the issue with a much nicer crash log,where I can not only see all of my functionsactually being called, but I can also determinethe file and line number to refer back to in my code.This updated crash log also tells me that we triedto access an index out of range.Alternatively, If I already have the dSYM,I can use the `atos` command to get the same information.Looking back at my code, I come to realizethat `MAGIC_CHOICE` is far outside the boundsof our 10-element array.Oops.In another instance, I'm interested in profiling my appto deliver the fastest user experience.Here, Instruments shows me that the app cycles throughperiods of high utilization and low utilization.If we focus on a period of low utilization,Instruments tells us that the appwas writing some content to a file.However, when I inspect a period of high utilization,I get the same exact backtrace.How is this possible?Isn't this executing the same exact code?As we'll see, this Instruments traceis only partially symbolicated.For instance, I don't see any file namesor line numbers in the backtraceas I did with the updated crash log.As a result, it's missing some information.With that in mind,I can similarly locate my dSYM in Instruments.After doing this, my new Instruments traceshows that the high-utilization regionswere indeed writing to a file,but they were specifically within a debug code paththat I left in the program.The low-utilization areas avoid thisand represent how my app behaves in production.Just as Xcode utilized the dSYM to symbolicatea rather uninformative crash log,Instruments also used the dSYMto enrich a partially symbolicated traceand tell me the exact cause of the performance issue.Now, while it's great that these tools leverage symbolicationto pinpoint problem areas in my code,it naturally begs a few questions.How does this all work?Where else can I apply this?And is this all about dSYMs?To answer these questionsand unlock symbolication's capabilities,we'll need to take a deeper dive into the details.This may seem a little overwhelming,but these are important concepts to understand.There are many tools to aid in debugging and profilingthat build upon symbolication.`atos` alone already gave us the exact root cause of a crash,and there are many more tools built into Xcode.Further, we specified flags like `o`, `l`, and `i` to `atos`,but what do they mean?Do we always use the same set of flags?What if we don't have one of the values available?You'll also gain a good foundationin understanding when and why your backtracesmay not be fully symbolicated and how to fix that,as we saw in the Instruments case.Lastly, there are a number of build settingsthat you're in control ofthat influence the richness of symbolication.We'll go through these build settingsso you have a solid intuition about how they're utilized.To that end, I'd like to introducethe two-step process for symbolication.Step number one is going back to the file,and step number two is to consult debug information.As we'll see, going back to the fileis all about converting or translatingruntime memory addresses into a more stable, usable form.This allows us to communicate with our debug informationto make a meaningful connectionbetween a raw memory address and the source code.Let's start off by discussing step number one,going back to the file.The ultimate goal in this step is to translatea runtime memory address,such as those we saw in the original crash log,to a corresponding address in your binary on disk.Just like we have runtime addresses,your apps and frameworkshave an address space on disk, too!The on disk address space differs from the address spacethat your app occupies at runtime,and we need a mechanism to figure out those differences.First, we should understandexactly what the on disk addresses are.These addresses are assigned by the linkerwhen you build your app.Specifically, the linker groups your binary into segments.Each segment contains related data and has propertiessuch as a name, a size,and their assigned addresses.For example, the `__TEXT` segment of your binarycontains all of the functions and methods you've written,and the `__DATA` segment contains program-wide statesuch as global variables.Each of these segments gets assigned a different addresssuch that they don't overlap.The linker records this informationat the very beginning of your executablesas part of the Mach-O header.Mach-O is the format used for all executable binariesand libraries, and the system knows thatit needs to read this header to run your apps.Looking a little more closely,the Mach-O header contains a number of load commandsthat hold the segment properties.The system uses these load commandsto load the segments into memory.Note that if your apps are Universal 2,then the app will have one headerand a set of segments for each architecture.We can see for ourselves by using the `otool -l` command,which prints the load commands for a specified file.Here, we're looking a segment load commandidentified with `LC_SEGMENT_64`.This load commands says that the `__TEXT` segmentstarts at the address in `vmaddr` and is `vmsize` bytes long.So if the kernel follows these load commandsto load the segments into memory,what exactly is the differencebetween the runtime and the linker addresses?Well, before the kernel actually loads the segments,it initializes a random value known as the ASLR slide.The kernel then adds the ASLR slideto the addresses in the load commands.So rather than loading the `__TEXT` segment at address Aand the `__DATA` segment at address B,the kernel instead loads them to A+S and B+S,where S is the ASLR slide.Since A+S and B+S are the true addresses that the system uses,they're also known as load addresses.With that in mind, we now know that the difference betweena runtime address and the linker addressis the ASLR slide.We can calculate the ASLR slide with the following equation:S = L-A, where S is the ASLR slide,L is the load address, and A is the linker address.We'll see examples of this equation shortly,but the key point is that we can always go backto the file address space once we know the ASLR slide.The ASLR slide equation required two addresses —the load address and the linker address —so where do we get them from?We already saw how we can query the load commandsto know the linker address using `otool`.To know the runtime address,the system queries your app either at the point of a crashor as its being profiled by Instrumentsfor its runtime address space.This information is reflectedin the Binary Images list in your crash logs.You can also see the load addresses interactivelywith the `vmmap` tool,which enumerates the active memory regions in your program.Let's compute the ASLR slide value ourselvesfrom the original crash log.In the Binary Images list,I have the load address of the `__TEXT` segment.I also have the linker address for the binary on diskwhen I looked at the load commands.Subtracting these two yields an ASLR slide valueof 0x45c000.This means that every addressin my program's runtime `__TEXT` segmentis 0x45c000 bytes away from the linker `__TEXT` segment address.So to see what a backtrace address from the crash logcorresponds to in the file,I can subtract 0x45c000 from itto get the address on disk.Since this address is now part of the on-disk address space,I can inspect my app to see what resides there.The crash log tells me that a thread crashedwhile executing whatever is at this address,so we can use `otool` again to see the problematic instruction.This time, I specified the `-tV` flags to `otool`,which will print the disassembly.Notice that I'm also specifying the architecture as arm64.This is so that otool knowswhich Mach-O header and segments to considersince the app is built as Universal 2.The output of `otool` reveals a `brk` instructionat the address.`brk` signals an exception or a problem in the app.Tools such as `atos` also calculate the ASLR slideusing the same technique we went through together.`atos` will read the load commands for the fileindicated by the `-o` flag, and we tell it aboutthe load address with the `-l` flag.As I mentioned, `vmmap` can also tell usabout the load addresses of a running app.Let's try this calculation again,but this time we'll use `vmmap` instead of the binary image listto determine the ASLR slide.I ran the MagicNumbers program againand got the `__TEXT` segment load addressbefore the program crashed.Using the previous formula, I can determine that this timethe ASLR slide value was 0x104d14000.Again, to go back to the file,I need to subtract the ASLR slide value.If I subtract 0x104d14000from the topmost entry in the new crash log,I get the same exact file address as before.And this is no coincidence;the kernel just picked a different ASLR valueso our load addresses changed between the crash logs.However, we can still determine the file addressthat was responsible for the crash.The important takeaway here is that we have a mechanismto understand exactly what our app was doingdown to the instruction level,regardless of its runtime address.And with that mapping, we can then consultour debug information for the source codethat was compiled to those instructions.Before we move on, I want to present a summaryof what we covered and the tools we used.App binaries and frameworks are Mach-O files.This means that they have related contentin their different segments.These segments are created by the linker.The Mach-O header load commandsdescribe the properties of those segments, including an address.We used `otool` with the `-l` flag to print out the load commands.Next, we learned that the kernel adds a random value,known as the ASLR slide, to the linker addresses.The addition of the ASLR slide and the linker addressis known as a load address.We can check the binary image list in a crash logto see the load addresses in the event of a crash,or we can use `vmmap` to see the load addressesfor a running app.Finally, we walked through some examplesof calculating the ASLR slideto get back to the file address space.Now we can discuss debug information,which contains the crucial linksbetween the file addresses and the source code.Xcode creates the debug informationwhen you build your appand will either embed it directly into your app binariesor store it as a separate file, such as a dSYM.There are a few categories or types of debug info.Each one offers a different level of detailfor a given file address.We'll look at three different types of debug info today.First, we'll cover the function starts,which by itself doesn't add too much value,but it is a common starting point.Next we'll see the nlist symbol tables,which add function and method names.Lastly, we'll look at DWARF,which comes from dSYMs and static libraries.DWARF adds the most detail, including file names,line numbers, and optimization records.Since DWARF offers the most detail,we really want to strive to have this type of debug infowhenever possible.We'll learn about each of these and how they can be usedto build up the fully symbolicated crash log.Let's begin with function starts.As we saw in the table,function starts offers the least source code detail.Also keeping true to its name,this type of debug information only tells us aboutthe first address — or the literal start —of our functions.For example, this would tell us that a functionbegins and exists at a certain address.However, it doesn't tell us which functionsbegin at those addresses, only that they exist.The function starts debug info does this by encodingthe list of addresses in your app's `__LINKEDIT` segment.Since this is embedded directly in your app,the Mach-O header also has a load commandto inform us where we can find it,which is `LC_FUNCTION_STARTS`.You can see these for yourself with the `symbols` commandand the `-onlyFuncStartsData` flag.Here we get back a list of addresses and null placeholders.These placeholders would ideally havefunction and method names instead of null,but the function starts data doesn't provide names.Again, this isn't the most descriptive data.However, it does allow for a slight update to the crash log.We can now view the file addressesas offsets from a function.For example, first we go back to the fileby subtracting the ASLR slide value.Then we find the function starts valuethat could contain the file address.In this case, only the first valuecould contain the addressbecause all of the other values are larger than the address.Finally we can claim that our file addressis actually 264 bytes into this function.This is primarily useful for debuggers,since they can understandthe details of how this function was set upand which registers were modified.What this means for you, however,is that if you ever encounter a crash logthat lacks function names, you're probably dealing withthis lowest level of debug information.This is good news because it means there areplenty of opportunities to enrich the crash logwith better debug information.Naturally, the next level of detail we'd like to seeare function names.This gives us our first real opportunityto take a crash log or an Instruments traceand use it to track down an issue in our source code.This leads us to nlist symbol tables.The symbol tables build on the idea of function startsand also encode a list of informationin the `__LINKEDIT` segment, and has its own load command too.However, rather than just encoding addresses,they encode C structs.This lets us add more details for any given entrycompared to function starts.Specifically, they encode the `nlist_64` struct.Here we have the definition of that struct.A cursory glance shows that we have accessto a name and several properties.The values of these struct fieldsare determined by the nlist's `n_type`.There are three primary n_types that we're interested in,but for now we'll only focus on two.The first is known as a direct symbol.These are functions and methods that you have fully definedwithin your apps and frameworks.Direct symbols have a name and an addressin the `nlist_64` struct.Additionally, they're representedby a particular bit pattern in the `n_type` field.Specifically, `n_type` will have the second, third, and fourthleast significant bits set.These bits are also known as `N_SECT`.We can see these with `nm` and specifyingthe `-defined-only` and `--numeric-sort` flags.Here, `nm` walked through the defined symbolsof the MagicNumbers programand listed them in address order.The names we get back appear cryptic.That's because the names that are actually storedin the symbol tables are mangled names.These mangled names help the compiler and linkerto uniquely identify a function,but they aren't easy to understandunless they're demangled.To get a friendlier version of these names,I passed the output to `swift-demangle`.Now we get some familiar names, such as `main` and `numberChoices`,because they're directly defined in my app.Similarly, the `symbols` tool has an optionto show the nlist data,and it also demangles the names automatically.Now that we can associate a function name to an address,this lets us update the crash log once again.Here we can observe that our offset expressionthat we got from the function starts dataalso matches an entry from the direct symbols,and that entry has a name.Putting these two together,we can now say that our crash happenedat 264 bytes into main.This still leaves some details to be desired,since we know for a factthat main isn't the only function involved.And it would also help to have an exact line number too.We encountered something similar to thisin the Instruments trace example —we had some function names available, but it missed others.One reason for this is that the symbol tableonly has direct symbol entriesfor functions that are involved in linking.These are functions that you use across modulesor functions that you export from your frameworks.This makes it useful for identifying API boundaries.And it also means that it has the necessary datato power dynamic loadingwith functions such as `dlsym()` and `dladdr()`.One downside though is that local or static functionsaren't represented in the symbol tablesince they aren't referenced outside of their module.This ends up omitting implementation functionswhere we may have a significant portion of the app logic.Further, it's common for binaries built in Release modeto have their symbol table stripped.This means that unnecessary entriesare removed from the symbol table,which helps reduce the size of your app.If we think about it, it's rather uncommonfor our app's primary driver to export functionality anywhere,so we'd be wasting spacekeeping those symbol table entries around.For our frameworks and libraries,we definitely have exported functionsthat clients should use, but there's no needto keep around the locally shared functionssince they can't be used anywhere else.Stripping our primary app executables will almost alwaysleave the symbol table practically empty.Stripping our frameworks and librariesleaves only the exported functions.You may have come across build settings in Xcodesuch as Strip Linked Product,Strip Style, and Strip Swift Symbols.These build settings control how your app is strippedduring the build.If Strip Linked Product is enabled,then the binary is stripped according to Strip Style.For example, All Symbols will performthe most invasive removaland leave behind only the bare essentials.Non Globals removes direct symbolsthat are used within different modules of your appbut are not exported for use in other apps.Debugging Symbols removes the third type of nlist typethat we'll discuss later when we get to DWARF.However, this strip style does preserve the direct symbols.For example, here I have a frameworkthat defines two public interfacesand one internal shared implementation function.Since all of these functions play a role in linking,they all have direct symbol entries.If I strip non globals,then I'm only left with my interfaces.The shared implementation function was only usedwithin my framework, so it isn't considered global.Similarly, stripping all symbols still leaves the interfacesince these are required for other appsto use the framework.You can also notice in the `symbols --onlyNListData` outputthat there are function starts addressesinterspersed between the direct symbols.These addresses represent functions that were eithernever in the direct symbols, or were stripped.You can tailor these strip settingsto your desired level of symbol table visibility.With this information, we can determinewhen we're working with direct symbols.Some telltale signs of this are having function namesbut no line numbers or file names;or having a mix of function namesand function starts addresses,as we have here with the framework example.The second type of nlist struct we'll analyzeis known as an indirect symbol,as opposed to direct symbol.This is when the `n_type` matches only the `N_EXT` bit pattern.These are functions and methods that you're usingfrom other frameworks or libraries, such as `print()`.You can see these with `nm`, only this time we'll specify`--undefined-only` instead of `--defined-only`.We'll also add the `-m` flag,which will show you which frameworks or librariesthe functions should be found in.For example, the MagicNumbers appdepends on a variety of Swift functionsthat are defined in libswiftCore.Now that we've covered two of the threedebug information categories,let's make sure we understand their properties.Function starts are a list of addresses,so they lack names,but do allow us to determine offsets.nlist symbol tables encode entire structs of informationand can associate a name to an address.They describe direct symbols — which are defined in your app —and indirect symbols,which are provided by dependencies.Direct symbols are generally reservedfor functions involved in linking,and the strip build settings influencewhich direct symbols are available.Finally, both the function startsand the nlist symbol tables are embedded directly in your app.What we haven't seen yet is the richer levels of detail,such as file names and line numbers.This is provided to us by DWARF.DWARF takes the concepts of nlist symbol tablesto a completely different level.Rather than keeping only a subset of functions,DWARF strives to describe everything.We saw that nlist symbol tables added vastly more informationversus the function starts.It accomplished that by adding a dimension.Remember, we started with just a single dimension,which were the addresses,when we looked at function starts.Then we upgraded to two dimensionsby encoding a struct full of informationin the nlist symbol table.DWARF adds a third dimension,which is about relationships.DWARF recognizes that functions aren't isolated.They call other functions, they have parameters,return meaningful data, and are defined in a particular file.Encoding these relationshipsunlocks the most powerful aspects of symbolication.When we're analyzing DWARF,we're primarily referring to a dSYM bundle.In addition to other metadata such as plists,the dSYM bundle contains a binary with DWARF.What makes this binary so special?The binary contains its data in a special `__DWARF` segment.The DWARF specification mentions three streams of datawithin the segment that we'll focus on.`debug_info` contains the raw data,`debug_abbrev` assigns structure to the data,and `debug_line` contains the file names and line numbers.DWARF also defines two vocabulary typesthat we'll study first:the compile unit and the subprogram.We'll introduce a third one later.A compile unit represents a single source filethat went into building the product.For example, we can expect to have one compile unitfor each Swift file in our project.DWARF assigns properties to a compile unit,such as the name of the file, the SDKs,the portion of the `__TEXT` segment its functions occupy,and much more.The main.swift compile unit contains these propertiesin the `debug_info` stream on the left,and it has a corresponding entry in the `debug _abbrev` streamon the right which tells us what the values represent.Here we see the file name, the language it's written in,and a low/high pair representing the `__TEXT` segment range.A subprogram represents a defined function.We saw defined functions in the nlist symbol table already,but the subprogram can describe static and local functions too.A subprogram also has a nameand its `__TEXT` segment address range.One fundamental relationshipbetween compile units and subprogramsis that subprograms are defined in a compile unit.DWARF represents this with a tree.The compile unit is at the root of the treeand it has subprogram entries as children.The children are searchable by following their address ranges.We can examine these in more detailwith the `dwarfdump` command.First we'll look at a compile unit.This matches some of the propertiesof a compile unit I mentioned earlier.`dwarfdump` helpfully combinesthe `debug_ info` and `debug _abbrev` contentsto show you the structure and contentof the data in your dSYMs.And if we scroll down the output,we'll encounter one subprogram child.The address range it occupiesis within the bounds of the compile unitand we can also see the name of the function.I mentioned that DWARF describes its data in extreme detail.While we won't spend much time on all of these details,I think it's fun to see details such as function parameters.They have their own vocabulary typethat describes the name and type of the parameter.Following the tree model,a parameter is a child of a subprogram.Here we come across the entry for the choices parameterthat we supply to a function.Next, file names and line numberscome from the `debug_line` stream.This stream doesn't have a tree structure.Instead, it defines a line table programwhere the individual file addressescan be mapped back to an exact line of code.This ends up generating a list of source code detailswhich we can search to find the file and line.If we parse the `debug_info` treeand generate the `debug_line` list,we end up with a structure like the following.So if want to match a file address,we can traverse the tree.First, we'll start at the compile unitand follow the branches.Then we'll pick up any of the `debug_line` entries that matched.We can automate this again with `atos`,only this time I'm specifically leaving out the `-i` flag.Notice anything slightly odd here?Yes, we have the function name and line number,so we're definitely using DWARF.Other than that though, this isn't all too differentfrom the nlist symbol table update.In fact, when we compare it to the first time we used `atos`,it still looks like we're missingso many valuable functions and details!What happened here?The only thing that changed was that we didn't specifythe `-i` to `atos` this time.That flag stands for "inlined functions."Inlining is a routine optimizationthat compilers perform.This involves substituting a function callwith the body of the function directly.One cool effect that it has is making code seemingly disappear.We can think of it as, rather than calling `numberChoices()`,the entirety of the code for `numberChoices()`was dropped in place.Suddenly there's no function call to `numberChoices()` anymore!DWARF represents this with an inlined subroutine.This is the third and final vocabulary type for DWARFthat we'll discuss today.An inlined subroutine is a subprogram —so it's a function —that was inlined into another subprogram.Since an inlined function is completely engulfedby another node in the relationship tree,the inlined subroutine is a child of that node.This definition applies recursively too,meaning that an inlined subroutinecan have other inlined children.Again, with `dwarfdump`,we can look for inlined subroutines.They're listed as children of other nodesand have similar properties to subprograms,such as names and addresses.However, in DWARF, these propertiesare frequently accessed through a common node,known as the abstract origin.If there are many inlined copies of a particular function,then their common, shared propertiesare kept in the abstract originso that they aren't duplicated everywhere.One unique property that inlined subroutines have is a call site.This is the location in our source codewhere we wrote the actual function call,but the optimizer replaced it.Here for instance, we made the call to `generateANumber`on line 36 of the main.swift file.This lets us update our tree with new child nodes.And now this is looking likea much more comprehensive view of our program.The optimization details for inlined functionswere the key details in getting usto the fully symbolicated crash log.The `-i` flag for `atos` instructs the toolto consider them during symbolication.They were also the missing detailsfrom our Instruments trace.The reason why we needed a dSYMboth for Instruments and for the crash logwas precisely so that we could extract all of this content.There is another source where you'll find DWARF,and that is from static libraries and object files.In the absence of a dSYM, you can still gather DWARFfor functions that you linkedfrom a static library or object file.In those cases, you'll find the Debugging Symbols nlist types.These were one of the symbol types that could be stripped.They don't hold the DWARF themselves though.Rather, they associate a functionback to the file they came from.If the library was built with debug information,then the nlist entry can point us to that DWARF.These types of nlist entries can be seen verboselywith `dsymutil -dump-debug-map`.Here we have the list of different functionsand where they were pulled from.Those locations can be scanned and processed for DWARF.To summarize,DWARF is a vital source of in-depth symbolication data.DWARF exposes important relationshipsbetween functions and files.Optimizations such as function inlininghave an enormous impact on the quality of symbolication,and DWARF can express it very well.We also saw that dSYMs and static libraries contain DWARF.However, please prefer dSYMs as you can easily transfer themto others and have built-in support from several tools.Finally, I want to share different tools and tipsyou can use to facilitate symbolication.For local development builds, you'll generally havea great deal of debug informationif you build in debug mode.For release mode, you can ensure that Xcode generates a dSYM bychecking the Debug Information Format build setting.Make sure Release is set to DWARF with dSYM File.For apps that were submitted to the App Store,you can download your dSYMs through App Store Connect.This also includes any apps with bitcode enabled.If you want to check that a certain dSYMis already on your device, you can use the `mdfind` command.The alphanumeric string here is your binary's UUID,which is a unique identifier defined in a load command.You can see the UUID for your dSYMs with `symbols -uuid`.Sometimes, a toolchain could generate invalid DWARF.You can check this with `dwarfdump -verify`.If you see any reported errors, please file a bug!DWARF data also has a cap of four gigabytes per binary.If you're running into issues with your dSYMsand see that they're exceeding four gigabytes,consider splitting the project into separate componentsso that each one has its own smaller dSYM.You can make sure that the dSYM you're usingmatches the specific build of your appthat you're interested in by comparing UUIDs.The app's UUID is in the Binary Images listsection of crash reportsand you can also see it with the `symbols` command.You should ensure that both your app and your dSYMhave the same UUIDs.The `symbols` tool also lets you checkthe types of debug information your app has available.We've already seen examples of this,but it's a helpful reminder that these tags in square bracketstell you the information source.It's useful if you aren't sure which debug informationyou might be dealing with.If you're certain that you have dSYMs availablebut still aren't getting names for your functionsin Instruments traces,please check your entitlements and code signing.Specifically, with the `codesign` command,you can verify that you have a proper code signature.You should also verify that locally built appsfor development have the `get-task-allow` entitlement.This entitlement grants permissions to toolssuch as Instruments to symbolicate your app.Xcode should set this entitlement automaticallywith the Profile action, but it's helpful to verify.If you don't have the `get-task-allow` entitlementenabled, you should checkyour Code Signing Inject Base Entitlements build settingand make sure that it's enabled as you're developing.Lastly, for Universal 2 apps,you should specify the architecturethat you're interested in to the tools.`symbols`, `otool`, and `dwarfdump` all have an `-arch` flagto only operate on a particular architecture slice.This concludes "Symbolication: Beyond the basics."If nothing else,I want to really emphasize a few key points.UUIDs and file addresses are a consistentand reliable way to identify what your app was doingsince they're independent of the ASLR slide.They're also our key to querying the debug info.You should also use dSYMs whenever possible.dSYMs contain the richest debug informationin the form of DWARF and are supportedby Xcode and Instruments.Lastly, we covered several tools.These tools are readily available to you in Xcodeand they offer powerful diagnostics and insights.You should strive to incorporate theminto your workflows for debugging and optimizing.If you're interested in learning more,I recommend these two sessions from WWDC18to learn how your apps spring to life upon launch:"Optimizing app startup time"and "App startup time: Past, present, and future".Thank you all very much for joining meto learn about symbolication!Have a wonderful rest of the week.♪

♪ Bass music playing ♪♪Alejandro Lucena: Hello, everyone.

Thank you for attending this session on symbolication.

While symbolication may seem like a vague term,we'll see the instrumental role it plays in helping youto quickly identify the root causes of bugs,crashes, and performance bottlenecks.

We'll gain a deeper intuition as to how symbolication worksand cover several tools that you have at your disposalto follow along firsthand.

Along the way, we'll discussthe various sources of debug informationthat are necessary for a rich symbolication experienceand how you can configure your appto best utilize this information.

Let's get started by familiarizing ourselveswith a concrete definition and example of symbolication.

Fundamentally, symbolication is a mechanismto convert or translatehow our devices see our apps at runtime —which is in terms of memory addresses and instructions —back to how we as developers see our apps —which is in terms of functions, names, and files.

Without this bridging layer,it vastly complicates diagnosing a bugeven for a few lines of code.

As an example, let's consider this Swift code.

Here I have a function, `generateMagicNumber()`,that selects a particular numberfrom a list of candidate numbers.

To do this, we first call into `numberChoices()`that returns an array of 10 randomly generated numbers.

Then, we pass that array into `selectMagicNumber(choices:)`,which returns the number at a particular index.

This seems like a reasonable program,but I encounter a crash when I first run it.

My first recourse is to check the crash log,which is rather unfruitful.

All I can tell from the thread backtraceis that my MagicNumbers app crashed somewhere.

Thanks, but I already knew that.

I have no ideawhat any of the registers are referring to either.

I can try to step through the app with the debuggerand identify the crash, but what if this only happensin particular circumstances that I can't reproduce?Using the debugger won't necessarily pinpointthe problem for me in that case.

Or I can try to look at the disassembly,but it's much more difficult to keep track of things.

This clearly isn't a viable way to diagnose the problem,and more importantly, with the help of symbolication,we don't have to debug from this starting point.

The Xcode Organizer tells me I can download the dSYMfor this app, which will reprocess the crash log.

In doing so, Xcode applies the concepts of symbolicationso that I can diagnose the issue with a much nicer crash log,where I can not only see all of my functionsactually being called, but I can also determinethe file and line number to refer back to in my code.

This updated crash log also tells me that we triedto access an index out of range.

Alternatively, If I already have the dSYM,I can use the `atos` command to get the same information.

Looking back at my code, I come to realizethat `MAGIC_CHOICE` is far outside the boundsof our 10-element array.

Oops.

In another instance, I'm interested in profiling my appto deliver the fastest user experience.

Here, Instruments shows me that the app cycles throughperiods of high utilization and low utilization.

If we focus on a period of low utilization,Instruments tells us that the appwas writing some content to a file.

However, when I inspect a period of high utilization,I get the same exact backtrace.

How is this possible?Isn't this executing the same exact code?As we'll see, this Instruments traceis only partially symbolicated.

For instance, I don't see any file namesor line numbers in the backtraceas I did with the updated crash log.

As a result, it's missing some information.

With that in mind,I can similarly locate my dSYM in Instruments.

After doing this, my new Instruments traceshows that the high-utilization regionswere indeed writing to a file,but they were specifically within a debug code paththat I left in the program.

The low-utilization areas avoid thisand represent how my app behaves in production.

Just as Xcode utilized the dSYM to symbolicatea rather uninformative crash log,Instruments also used the dSYMto enrich a partially symbolicated traceand tell me the exact cause of the performance issue.

Now, while it's great that these tools leverage symbolicationto pinpoint problem areas in my code,it naturally begs a few questions.

How does this all work?Where else can I apply this?And is this all about dSYMs?To answer these questionsand unlock symbolication's capabilities,we'll need to take a deeper dive into the details.

This may seem a little overwhelming,but these are important concepts to understand.

There are many tools to aid in debugging and profilingthat build upon symbolication.

`atos` alone already gave us the exact root cause of a crash,and there are many more tools built into Xcode.

Further, we specified flags like `o`, `l`, and `i` to `atos`,but what do they mean?Do we always use the same set of flags?What if we don't have one of the values available?You'll also gain a good foundationin understanding when and why your backtracesmay not be fully symbolicated and how to fix that,as we saw in the Instruments case.

Lastly, there are a number of build settingsthat you're in control ofthat influence the richness of symbolication.

We'll go through these build settingsso you have a solid intuition about how they're utilized.

To that end, I'd like to introducethe two-step process for symbolication.

Step number one is going back to the file,and step number two is to consult debug information.

As we'll see, going back to the fileis all about converting or translatingruntime memory addresses into a more stable, usable form.

This allows us to communicate with our debug informationto make a meaningful connectionbetween a raw memory address and the source code.

Let's start off by discussing step number one,going back to the file.

The ultimate goal in this step is to translatea runtime memory address,such as those we saw in the original crash log,to a corresponding address in your binary on disk.

Just like we have runtime addresses,your apps and frameworkshave an address space on disk, too!The on disk address space differs from the address spacethat your app occupies at runtime,and we need a mechanism to figure out those differences.

First, we should understandexactly what the on disk addresses are.

These addresses are assigned by the linkerwhen you build your app.

Specifically, the linker groups your binary into segments.

Each segment contains related data and has propertiessuch as a name, a size,and their assigned addresses.

For example, the `__TEXT` segment of your binarycontains all of the functions and methods you've written,and the `__DATA` segment contains program-wide statesuch as global variables.

Each of these segments gets assigned a different addresssuch that they don't overlap.

The linker records this informationat the very beginning of your executablesas part of the Mach-O header.

Mach-O is the format used for all executable binariesand libraries, and the system knows thatit needs to read this header to run your apps.

Looking a little more closely,the Mach-O header contains a number of load commandsthat hold the segment properties.

The system uses these load commandsto load the segments into memory.

Note that if your apps are Universal 2,then the app will have one headerand a set of segments for each architecture.

We can see for ourselves by using the `otool -l` command,which prints the load commands for a specified file.

Here, we're looking a segment load commandidentified with `LC_SEGMENT_64`.

This load commands says that the `__TEXT` segmentstarts at the address in `vmaddr` and is `vmsize` bytes long.

So if the kernel follows these load commandsto load the segments into memory,what exactly is the differencebetween the runtime and the linker addresses?Well, before the kernel actually loads the segments,it initializes a random value known as the ASLR slide.

The kernel then adds the ASLR slideto the addresses in the load commands.

So rather than loading the `__TEXT` segment at address Aand the `__DATA` segment at address B,the kernel instead loads them to A+S and B+S,where S is the ASLR slide.

Since A+S and B+S are the true addresses that the system uses,they're also known as load addresses.

With that in mind, we now know that the difference betweena runtime address and the linker addressis the ASLR slide.

We can calculate the ASLR slide with the following equation:S = L-A, where S is the ASLR slide,L is the load address, and A is the linker address.

We'll see examples of this equation shortly,but the key point is that we can always go backto the file address space once we know the ASLR slide.

The ASLR slide equation required two addresses —the load address and the linker address —so where do we get them from?We already saw how we can query the load commandsto know the linker address using `otool`.

To know the runtime address,the system queries your app either at the point of a crashor as its being profiled by Instrumentsfor its runtime address space.

This information is reflectedin the Binary Images list in your crash logs.

You can also see the load addresses interactivelywith the `vmmap` tool,which enumerates the active memory regions in your program.

Let's compute the ASLR slide value ourselvesfrom the original crash log.

In the Binary Images list,I have the load address of the `__TEXT` segment.

I also have the linker address for the binary on diskwhen I looked at the load commands.

Subtracting these two yields an ASLR slide valueof 0x45c000.

This means that every addressin my program's runtime `__TEXT` segmentis 0x45c000 bytes away from the linker `__TEXT` segment address.

So to see what a backtrace address from the crash logcorresponds to in the file,I can subtract 0x45c000 from itto get the address on disk.

Since this address is now part of the on-disk address space,I can inspect my app to see what resides there.

The crash log tells me that a thread crashedwhile executing whatever is at this address,so we can use `otool` again to see the problematic instruction.

This time, I specified the `-tV` flags to `otool`,which will print the disassembly.

Notice that I'm also specifying the architecture as arm64.

This is so that otool knowswhich Mach-O header and segments to considersince the app is built as Universal 2.

The output of `otool` reveals a `brk` instructionat the address.

`brk` signals an exception or a problem in the app.

Tools such as `atos` also calculate the ASLR slideusing the same technique we went through together.

`atos` will read the load commands for the fileindicated by the `-o` flag, and we tell it aboutthe load address with the `-l` flag.

As I mentioned, `vmmap` can also tell usabout the load addresses of a running app.

Let's try this calculation again,but this time we'll use `vmmap` instead of the binary image listto determine the ASLR slide.

I ran the MagicNumbers program againand got the `__TEXT` segment load addressbefore the program crashed.

Using the previous formula, I can determine that this timethe ASLR slide value was 0x104d14000.

Again, to go back to the file,I need to subtract the ASLR slide value.

If I subtract 0x104d14000from the topmost entry in the new crash log,I get the same exact file address as before.

And this is no coincidence;the kernel just picked a different ASLR valueso our load addresses changed between the crash logs.

However, we can still determine the file addressthat was responsible for the crash.

The important takeaway here is that we have a mechanismto understand exactly what our app was doingdown to the instruction level,regardless of its runtime address.

And with that mapping, we can then consultour debug information for the source codethat was compiled to those instructions.

Before we move on, I want to present a summaryof what we covered and the tools we used.

App binaries and frameworks are Mach-O files.

This means that they have related contentin their different segments.

These segments are created by the linker.

The Mach-O header load commandsdescribe the properties of those segments, including an address.

We used `otool` with the `-l` flag to print out the load commands.

Next, we learned that the kernel adds a random value,known as the ASLR slide, to the linker addresses.

The addition of the ASLR slide and the linker addressis known as a load address.

We can check the binary image list in a crash logto see the load addresses in the event of a crash,or we can use `vmmap` to see the load addressesfor a running app.

Finally, we walked through some examplesof calculating the ASLR slideto get back to the file address space.

Now we can discuss debug information,which contains the crucial linksbetween the file addresses and the source code.

Xcode creates the debug informationwhen you build your appand will either embed it directly into your app binariesor store it as a separate file, such as a dSYM.

There are a few categories or types of debug info.

Each one offers a different level of detailfor a given file address.

We'll look at three different types of debug info today.

First, we'll cover the function starts,which by itself doesn't add too much value,but it is a common starting point.

Next we'll see the nlist symbol tables,which add function and method names.

Lastly, we'll look at DWARF,which comes from dSYMs and static libraries.

DWARF adds the most detail, including file names,line numbers, and optimization records.

Since DWARF offers the most detail,we really want to strive to have this type of debug infowhenever possible.

We'll learn about each of these and how they can be usedto build up the fully symbolicated crash log.

Let's begin with function starts.

As we saw in the table,function starts offers the least source code detail.

Also keeping true to its name,this type of debug information only tells us aboutthe first address — or the literal start —of our functions.

For example, this would tell us that a functionbegins and exists at a certain address.

However, it doesn't tell us which functionsbegin at those addresses, only that they exist.

The function starts debug info does this by encodingthe list of addresses in your app's `__LINKEDIT` segment.

Since this is embedded directly in your app,the Mach-O header also has a load commandto inform us where we can find it,which is `LC_FUNCTION_STARTS`.

You can see these for yourself with the `symbols` commandand the `-onlyFuncStartsData` flag.

Here we get back a list of addresses and null placeholders.

These placeholders would ideally havefunction and method names instead of null,but the function starts data doesn't provide names.

Again, this isn't the most descriptive data.

However, it does allow for a slight update to the crash log.

We can now view the file addressesas offsets from a function.

For example, first we go back to the fileby subtracting the ASLR slide value.

Then we find the function starts valuethat could contain the file address.

In this case, only the first valuecould contain the addressbecause all of the other values are larger than the address.

Finally we can claim that our file addressis actually 264 bytes into this function.

This is primarily useful for debuggers,since they can understandthe details of how this function was set upand which registers were modified.

What this means for you, however,is that if you ever encounter a crash logthat lacks function names, you're probably dealing withthis lowest level of debug information.

This is good news because it means there areplenty of opportunities to enrich the crash logwith better debug information.

Naturally, the next level of detail we'd like to seeare function names.

This gives us our first real opportunityto take a crash log or an Instruments traceand use it to track down an issue in our source code.

This leads us to nlist symbol tables.

The symbol tables build on the idea of function startsand also encode a list of informationin the `__LINKEDIT` segment, and has its own load command too.

However, rather than just encoding addresses,they encode C structs.

This lets us add more details for any given entrycompared to function starts.

Specifically, they encode the `nlist_64` struct.

Here we have the definition of that struct.

A cursory glance shows that we have accessto a name and several properties.

The values of these struct fieldsare determined by the nlist's `n_type`.

There are three primary n_types that we're interested in,but for now we'll only focus on two.

The first is known as a direct symbol.

These are functions and methods that you have fully definedwithin your apps and frameworks.

Direct symbols have a name and an addressin the `nlist_64` struct.

Additionally, they're representedby a particular bit pattern in the `n_type` field.

Specifically, `n_type` will have the second, third, and fourthleast significant bits set.

These bits are also known as `N_SECT`.

We can see these with `nm` and specifyingthe `-defined-only` and `--numeric-sort` flags.

Here, `nm` walked through the defined symbolsof the MagicNumbers programand listed them in address order.

The names we get back appear cryptic.

That's because the names that are actually storedin the symbol tables are mangled names.

These mangled names help the compiler and linkerto uniquely identify a function,but they aren't easy to understandunless they're demangled.

To get a friendlier version of these names,I passed the output to `swift-demangle`.

Now we get some familiar names, such as `main` and `numberChoices`,because they're directly defined in my app.

Similarly, the `symbols` tool has an optionto show the nlist data,and it also demangles the names automatically.

Now that we can associate a function name to an address,this lets us update the crash log once again.

Here we can observe that our offset expressionthat we got from the function starts dataalso matches an entry from the direct symbols,and that entry has a name.

Putting these two together,we can now say that our crash happenedat 264 bytes into main.

This still leaves some details to be desired,since we know for a factthat main isn't the only function involved.

And it would also help to have an exact line number too.

We encountered something similar to thisin the Instruments trace example —we had some function names available, but it missed others.

One reason for this is that the symbol tableonly has direct symbol entriesfor functions that are involved in linking.

These are functions that you use across modulesor functions that you export from your frameworks.

This makes it useful for identifying API boundaries.

And it also means that it has the necessary datato power dynamic loadingwith functions such as `dlsym()` and `dladdr()`.

One downside though is that local or static functionsaren't represented in the symbol tablesince they aren't referenced outside of their module.

This ends up omitting implementation functionswhere we may have a significant portion of the app logic.

Further, it's common for binaries built in Release modeto have their symbol table stripped.

This means that unnecessary entriesare removed from the symbol table,which helps reduce the size of your app.

If we think about it, it's rather uncommonfor our app's primary driver to export functionality anywhere,so we'd be wasting spacekeeping those symbol table entries around.

For our frameworks and libraries,we definitely have exported functionsthat clients should use, but there's no needto keep around the locally shared functionssince they can't be used anywhere else.

Stripping our primary app executables will almost alwaysleave the symbol table practically empty.

Stripping our frameworks and librariesleaves only the exported functions.

You may have come across build settings in Xcodesuch as Strip Linked Product,Strip Style, and Strip Swift Symbols.

These build settings control how your app is strippedduring the build.

If Strip Linked Product is enabled,then the binary is stripped according to Strip Style.

For example, All Symbols will performthe most invasive removaland leave behind only the bare essentials.

Non Globals removes direct symbolsthat are used within different modules of your appbut are not exported for use in other apps.

Debugging Symbols removes the third type of nlist typethat we'll discuss later when we get to DWARF.

However, this strip style does preserve the direct symbols.

For example, here I have a frameworkthat defines two public interfacesand one internal shared implementation function.

Since all of these functions play a role in linking,they all have direct symbol entries.

If I strip non globals,then I'm only left with my interfaces.

The shared implementation function was only usedwithin my framework, so it isn't considered global.

Similarly, stripping all symbols still leaves the interfacesince these are required for other appsto use the framework.

You can also notice in the `symbols --onlyNListData` outputthat there are function starts addressesinterspersed between the direct symbols.

These addresses represent functions that were eithernever in the direct symbols, or were stripped.

You can tailor these strip settingsto your desired level of symbol table visibility.

With this information, we can determinewhen we're working with direct symbols.

Some telltale signs of this are having function namesbut no line numbers or file names;or having a mix of function namesand function starts addresses,as we have here with the framework example.

The second type of nlist struct we'll analyzeis known as an indirect symbol,as opposed to direct symbol.

This is when the `n_type` matches only the `N_EXT` bit pattern.

These are functions and methods that you're usingfrom other frameworks or libraries, such as `print()`.

You can see these with `nm`, only this time we'll specify`--undefined-only` instead of `--defined-only`.

We'll also add the `-m` flag,which will show you which frameworks or librariesthe functions should be found in.

For example, the MagicNumbers appdepends on a variety of Swift functionsthat are defined in libswiftCore.

Now that we've covered two of the threedebug information categories,let's make sure we understand their properties.

Function starts are a list of addresses,so they lack names,but do allow us to determine offsets.

nlist symbol tables encode entire structs of informationand can associate a name to an address.

They describe direct symbols — which are defined in your app —and indirect symbols,which are provided by dependencies.

Direct symbols are generally reservedfor functions involved in linking,and the strip build settings influencewhich direct symbols are available.

Finally, both the function startsand the nlist symbol tables are embedded directly in your app.

What we haven't seen yet is the richer levels of detail,such as file names and line numbers.

This is provided to us by DWARF.

DWARF takes the concepts of nlist symbol tablesto a completely different level.

Rather than keeping only a subset of functions,DWARF strives to describe everything.

We saw that nlist symbol tables added vastly more informationversus the function starts.

It accomplished that by adding a dimension.

Remember, we started with just a single dimension,which were the addresses,when we looked at function starts.

Then we upgraded to two dimensionsby encoding a struct full of informationin the nlist symbol table.

DWARF adds a third dimension,which is about relationships.

DWARF recognizes that functions aren't isolated.

They call other functions, they have parameters,return meaningful data, and are defined in a particular file.

Encoding these relationshipsunlocks the most powerful aspects of symbolication.

When we're analyzing DWARF,we're primarily referring to a dSYM bundle.

In addition to other metadata such as plists,the dSYM bundle contains a binary with DWARF.

What makes this binary so special?The binary contains its data in a special `__DWARF` segment.

The DWARF specification mentions three streams of datawithin the segment that we'll focus on.

`debug_info` contains the raw data,`debug_abbrev` assigns structure to the data,and `debug_line` contains the file names and line numbers.

DWARF also defines two vocabulary typesthat we'll study first:the compile unit and the subprogram.

We'll introduce a third one later.

A compile unit represents a single source filethat went into building the product.

For example, we can expect to have one compile unitfor each Swift file in our project.

DWARF assigns properties to a compile unit,such as the name of the file, the SDKs,the portion of the `__TEXT` segment its functions occupy,and much more.

The main.swift compile unit contains these propertiesin the `debug_info` stream on the left,and it has a corresponding entry in the `debug _abbrev` streamon the right which tells us what the values represent.

Here we see the file name, the language it's written in,and a low/high pair representing the `__TEXT` segment range.

A subprogram represents a defined function.

We saw defined functions in the nlist symbol table already,but the subprogram can describe static and local functions too.

A subprogram also has a nameand its `__TEXT` segment address range.

One fundamental relationshipbetween compile units and subprogramsis that subprograms are defined in a compile unit.

DWARF represents this with a tree.

The compile unit is at the root of the treeand it has subprogram entries as children.

The children are searchable by following their address ranges.

We can examine these in more detailwith the `dwarfdump` command.

First we'll look at a compile unit.

This matches some of the propertiesof a compile unit I mentioned earlier.

`dwarfdump` helpfully combinesthe `debug_ info` and `debug _abbrev` contentsto show you the structure and contentof the data in your dSYMs.

And if we scroll down the output,we'll encounter one subprogram child.

The address range it occupiesis within the bounds of the compile unitand we can also see the name of the function.

I mentioned that DWARF describes its data in extreme detail.

While we won't spend much time on all of these details,I think it's fun to see details such as function parameters.

They have their own vocabulary typethat describes the name and type of the parameter.

Following the tree model,a parameter is a child of a subprogram.

Here we come across the entry for the choices parameterthat we supply to a function.

Next, file names and line numberscome from the `debug_line` stream.

This stream doesn't have a tree structure.

Instead, it defines a line table programwhere the individual file addressescan be mapped back to an exact line of code.

This ends up generating a list of source code detailswhich we can search to find the file and line.

If we parse the `debug_info` treeand generate the `debug_line` list,we end up with a structure like the following.

So if want to match a file address,we can traverse the tree.

First, we'll start at the compile unitand follow the branches.

Then we'll pick up any of the `debug_line` entries that matched.

We can automate this again with `atos`,only this time I'm specifically leaving out the `-i` flag.

Notice anything slightly odd here?Yes, we have the function name and line number,so we're definitely using DWARF.

Other than that though, this isn't all too differentfrom the nlist symbol table update.

In fact, when we compare it to the first time we used `atos`,it still looks like we're missingso many valuable functions and details!What happened here?The only thing that changed was that we didn't specifythe `-i` to `atos` this time.

That flag stands for "inlined functions."Inlining is a routine optimizationthat compilers perform.

This involves substituting a function callwith the body of the function directly.

One cool effect that it has is making code seemingly disappear.

We can think of it as, rather than calling `numberChoices()`,the entirety of the code for `numberChoices()`was dropped in place.

Suddenly there's no function call to `numberChoices()` anymore!DWARF represents this with an inlined subroutine.

This is the third and final vocabulary type for DWARFthat we'll discuss today.

An inlined subroutine is a subprogram —so it's a function —that was inlined into another subprogram.

Since an inlined function is completely engulfedby another node in the relationship tree,the inlined subroutine is a child of that node.

This definition applies recursively too,meaning that an inlined subroutinecan have other inlined children.

Again, with `dwarfdump`,we can look for inlined subroutines.

They're listed as children of other nodesand have similar properties to subprograms,such as names and addresses.

However, in DWARF, these propertiesare frequently accessed through a common node,known as the abstract origin.

If there are many inlined copies of a particular function,then their common, shared propertiesare kept in the abstract originso that they aren't duplicated everywhere.

One unique property that inlined subroutines have is a call site.

This is the location in our source codewhere we wrote the actual function call,but the optimizer replaced it.

Here for instance, we made the call to `generateANumber`on line 36 of the main.swift file.

This lets us update our tree with new child nodes.

And now this is looking likea much more comprehensive view of our program.

The optimization details for inlined functionswere the key details in getting usto the fully symbolicated crash log.

The `-i` flag for `atos` instructs the toolto consider them during symbolication.

They were also the missing detailsfrom our Instruments trace.

The reason why we needed a dSYMboth for Instruments and for the crash logwas precisely so that we could extract all of this content.

There is another source where you'll find DWARF,and that is from static libraries and object files.

In the absence of a dSYM, you can still gather DWARFfor functions that you linkedfrom a static library or object file.

In those cases, you'll find the Debugging Symbols nlist types.

These were one of the symbol types that could be stripped.

They don't hold the DWARF themselves though.

Rather, they associate a functionback to the file they came from.

If the library was built with debug information,then the nlist entry can point us to that DWARF.

These types of nlist entries can be seen verboselywith `dsymutil -dump-debug-map`.

Here we have the list of different functionsand where they were pulled from.

Those locations can be scanned and processed for DWARF.

To summarize,DWARF is a vital source of in-depth symbolication data.

DWARF exposes important relationshipsbetween functions and files.

Optimizations such as function inlininghave an enormous impact on the quality of symbolication,and DWARF can express it very well.

We also saw that dSYMs and static libraries contain DWARF.

However, please prefer dSYMs as you can easily transfer themto others and have built-in support from several tools.

Finally, I want to share different tools and tipsyou can use to facilitate symbolication.

For local development builds, you'll generally havea great deal of debug informationif you build in debug mode.

For release mode, you can ensure that Xcode generates a dSYM bychecking the Debug Information Format build setting.

Make sure Release is set to DWARF with dSYM File.

For apps that were submitted to the App Store,you can download your dSYMs through App Store Connect.

This also includes any apps with bitcode enabled.

If you want to check that a certain dSYMis already on your device, you can use the `mdfind` command.

The alphanumeric string here is your binary's UUID,which is a unique identifier defined in a load command.

You can see the UUID for your dSYMs with `symbols -uuid`.

Sometimes, a toolchain could generate invalid DWARF.

You can check this with `dwarfdump -verify`.

If you see any reported errors, please file a bug!DWARF data also has a cap of four gigabytes per binary.

If you're running into issues with your dSYMsand see that they're exceeding four gigabytes,consider splitting the project into separate componentsso that each one has its own smaller dSYM.

You can make sure that the dSYM you're usingmatches the specific build of your appthat you're interested in by comparing UUIDs.

The app's UUID is in the Binary Images listsection of crash reportsand you can also see it with the `symbols` command.

You should ensure that both your app and your dSYMhave the same UUIDs.

The `symbols` tool also lets you checkthe types of debug information your app has available.

We've already seen examples of this,but it's a helpful reminder that these tags in square bracketstell you the information source.

It's useful if you aren't sure which debug informationyou might be dealing with.

If you're certain that you have dSYMs availablebut still aren't getting names for your functionsin Instruments traces,please check your entitlements and code signing.

Specifically, with the `codesign` command,you can verify that you have a proper code signature.

You should also verify that locally built appsfor development have the `get-task-allow` entitlement.

This entitlement grants permissions to toolssuch as Instruments to symbolicate your app.

Xcode should set this entitlement automaticallywith the Profile action, but it's helpful to verify.

If you don't have the `get-task-allow` entitlementenabled, you should checkyour Code Signing Inject Base Entitlements build settingand make sure that it's enabled as you're developing.

Lastly, for Universal 2 apps,you should specify the architecturethat you're interested in to the tools.

`symbols`, `otool`, and `dwarfdump` all have an `-arch` flagto only operate on a particular architecture slice.

This concludes "Symbolication: Beyond the basics."If nothing else,I want to really emphasize a few key points.

UUIDs and file addresses are a consistentand reliable way to identify what your app was doingsince they're independent of the ASLR slide.

They're also our key to querying the debug info.

You should also use dSYMs whenever possible.

dSYMs contain the richest debug informationin the form of DWARF and are supportedby Xcode and Instruments.

Lastly, we covered several tools.

These tools are readily available to you in Xcodeand they offer powerful diagnostics and insights.

You should strive to incorporate theminto your workflows for debugging and optimizing.

If you're interested in learning more,I recommend these two sessions from WWDC18to learn how your apps spring to life upon launch:"Optimizing app startup time"and "App startup time: Past, present, and future".

Thank you all very much for joining meto learn about symbolication!Have a wonderful rest of the week.

♪

1:11 -MagicNumbers

2:51 -atos symbolication

7:34 -Load commands

10:31 -Disassembly

11:32 -vmmap

15:09 -Function starts

17:06 -nlist_64

17:59 -Direct symbols with nm

18:30 -Demangled direct symbols with nm

18:43 -Demangled direct symbols with the symbols tool

23:06 -Indirect symbols with nm

27:16 -Examining dSYMs with dwarfdump

29:25 -atos symbolication without inlined functions

32:29 -Examining debugging symbols

33:59 -Examining dSYM UUIDs

34:03 -Verifying DWARF

35:09 -Verifying entitlements and codesigning

## Code Samples

```swift
func
 
selectMagicNumber
(
choices
: [
Int
])
 -> 
Int
 {
    
return
 choices[
MAGIC_CHOICE
]
}


func
 
randomValue
()
 -> 
Int
 {
    
return
 
Int
.random(in: 
1
...
100
)
}


func
 
numberChoices
()
 -> [
Int
] {
    
var
 choices 
=
 [
Int
]()
    
for
 
_
 
in
 
1
...
10
 {
        choices.append(randomValue())
    }
    
return
 choices
}


func
 
generateMagicNumber
()
 -> 
Int
 {
    
let
 numbers 
=
 numberChoices()
    
let
 magic 
=
 selectMagicNumber(choices: numbers)
    
return
 magic
}


print
(
"The magic number is: 
\(generateMagicNumber())
"
)
```

```swift
atos -o MagicNumbers.dSYM/Contents/Resources/DWARF/MagicNumbers -arch arm64 -l 0x10045c000 -i 0x10045fb70
```

```swift
otool -l MagicNumbers | grep LC_SEGMENT -A8
```

```swift
otool -tV MagicNumbers -arch arm64
```

```swift
vmmap MagicNumbers | grep __TEXT
```

```swift
symbols -onlyFuncStartsData -arch arm64 MagicNumbers
```

```swift
struct
 nlist_64 {
    
union
 {
        uint32_t  n_strx;
    } n_un;
    uint8_t n_type;
    uint8_t n_sect;
    uint16_t n_desc;
    uint64_t n_value; 
};
```

```swift
nm -arch arm64 —defined-only --numeric-sort MagicNumbers
```

```swift
nm -arch arm64 —defined-only --numeric-sort MagicNumbers | xcrun swift-demangle
```

```swift
symbols -arch arm64 -onlyNListData MagicNumbers
```

```swift
nm -m —arch arm64 --undefined-only --numeric-sort MagicNumbers
```

```swift
dwarfdump -v -debug-info -arch arm64 MagicNumbers.dSYM
```

```swift
atos -o MagicNumbers.dSYM/Contents/Resources/DWARF/MagicNumbers -arch arm64 —l 0x10045c000 0x10045fb70
```

```swift
dsymutil --dump-debug-map -arch arm64 MagicNumbers
```

```swift
symbols -uuid MagicNumbers.dSYM
```

```swift
dwarfdump —verify MagicNumbers.dSYM
```

```swift
codesign --display -v  --entitlements :- MagicApp.app
```


# Wwdc2021 10134

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Explore structured concurrency in SwiftWhen you have code that needs to run at the same time as other code, it's important to choose the right tool for the job. We'll take you through the different kinds of concurrent tasks you can create in Swift, show you how to create groups of tasks, and find out how to cancel tasks in progress. We'll also provide guidance on when you may want to use unstructured tasks.

To get the most out of this session, we first recommend watching “Meet async/await in Swift.”ResourcesSE-0304: Structured concurrencySE-0317: async letThe Swift Programming Language: ConcurrencyHD VideoSD VideoRelated VideosWWDC23Beyond the basics of structured concurrencyWWDC22Eliminate data races using Swift ConcurrencyVisualize and optimize Swift concurrencyWWDC21Discover concurrency in SwiftUIMeet async/await in SwiftMeet AsyncSequenceProtect mutable state with Swift actorsSwift concurrency: Behind the scenesSwift concurrency: Update a sample appWhat‘s new in Swift

When you have code that needs to run at the same time as other code, it's important to choose the right tool for the job. We'll take you through the different kinds of concurrent tasks you can create in Swift, show you how to create groups of tasks, and find out how to cancel tasks in progress. We'll also provide guidance on when you may want to use unstructured tasks.

To get the most out of this session, we first recommend watching “Meet async/await in Swift.”

SE-0304: Structured concurrency

SE-0317: async let

The Swift Programming Language: Concurrency

HD VideoSD Video

HD Video

SD Video

Beyond the basics of structured concurrency

Eliminate data races using Swift Concurrency

Visualize and optimize Swift concurrency

Discover concurrency in SwiftUI

Meet async/await in Swift

Meet AsyncSequence

Protect mutable state with Swift actors

Swift concurrency: Behind the scenes

Swift concurrency: Update a sample app

What‘s new in Swift

Search this video…♪ ♪Hi, I’m Kavon,and I’ll be joined by my colleague, Joe, later on.Swift 5.5 introduces a new way to write concurrent programs,using a concept called structured concurrency.The ideas behind structured concurrencyare based on structured programming,which so intuitive that you rarely think about it,but thinking about it will help you understand structured concurrency.So let’s dive in.In the early days of computing, programs were hard to readbecause they were written as a sequence of instructions,where control-flow was allowed to jump all over the place.You don’t see that today, because languages use structured programmingto make control-flow more uniform.For example, the if-then statementuses structured control-flow.It specifies that a nested block of codeis only conditionally executed while moving from top to bottom.In Swift, that block also respects static scoping,meaning that names are only visibleif they are defined in an enclosing block.This also means that the lifetimeof any variables defined in a blockwill end when leaving the block.So, structured programming with static scopemakes control-flow and variable lifetime easy to understand.More generally, structured control-flow can be sequencedand nested together naturally.This lets you read your entire program top to bottom.So, those are the fundamentals of structured programming.As you can imagine, it is easy to take for granted,because it is so intuitive for us today.But today’s programs feature asynchronous and concurrent code,and they have not been able to use structured programmingto make that code easier to write.First, let’s consider how structured programmingmakes asynchronous code simpler.Say that you need to fetch a bunch of images from the internetand resize them to be thumbnails sequentially.This code does that work asynchronously,taking in a collection of strings that identify the images.You’ll notice this function does not return a value when called.That’s because the function passes its result, or an error,to a completion handler it was given.This pattern allows the callerto receive an answer at a later time.As a consequence of that pattern, this function cannot usestructured control-flow for error handling.That’s because it only makes sense to handle errors thrownout of a function, not into one.Also, this pattern prevents youfrom using a loop to process each thumbnail.Recursion is required,because the code that runs after the function completesmust be nested within the handler.Now, let’s take a look at the previous codebut rewritten to use the new async/await syntax,which is based on structured programming.I’ve dropped the completion handler argument from the function.Instead, it is annotated with “async”and “throws” in its type signature.It also returns a value instead of nothing.In the body of the function, I use “await” to saythat an asynchronous action happens, and no nesting is requiredfor the code that runs after that action.This means that I can now loop over the thumbnailsto process them sequentially.I can also throw and catch errors,and the compiler will check that I didn’t forget.For an in-depth look at async/await,check out the session “Meet async/await in Swift.”So, this code is great,but what if you’re producing thumbnails for thousands of images?Processing each thumbnail one at a time is no longer ideal.Plus, what if each thumbnail’s dimensions must be downloadedfrom another URL, instead of being a fixed size?Now there is an opportunity to add some concurrency,so multiple downloads can happen in parallel.You can create additional tasks to add concurrency to a program.Tasks are a new feature in Swiftthat work hand-in-hand with async functions.A task provides a fresh execution contextto run asynchronous code.Each task runs concurrentlywith respect to other execution contexts.They will be automatically scheduled to run in parallelwhen it is safe and efficient to do so.Because tasks are deeply integrated into Swift,the compiler can help prevent some concurrency bugs.Also, keep in mind that calling an async functiondoes not create a new task for the call.You create tasks explicitly.There are a few different flavors of tasks in Swift,because structured concurrency is about the balancebetween flexibility and simplicity.So, for the remainder of this session,Joe and I will introduce and discuss each kind of taskto help you understand their trade-offs.Let’s start with the simplest of these tasks,which is created with a new syntactic formcalled an async-let binding.To help you understand this new syntactic form,I want to first break down the evaluationof an ordinary let binding.There are two parts:the initializer expression on the right side of the equalsand the variable’s name on the left.There may be other statements before or after the let,so I’ll include those here too.Once Swift reaches a let binding,its initializer will be evaluated to produce a value.In this example,that means downloading data from a URL,which could take a while.After the data has been downloaded,Swift will bind that value to the variable namebefore proceeding to the statements that follow.Notice that there is only one flow of execution here,as traced by the arrows through each step.Since the download could take a while,you want the program to start downloading the dataand keep doing other work until the data is actually needed.To achieve this, you can just add the word asyncin front of an existing let binding.This turns it into a concurrent bindingcalled an async-let.The evaluation of a concurrent binding is quite different from a sequential one,so let’s learn how it works.I will start just at the point before encountering the binding.To evaluate a concurrent binding,Swift will first create a new child task,which is a subtask of the one that created it.Because every task representsan execution context for your program,two arrows will simultaneously come out of this step.This first arrow is for the child task,which will immediately begin downloading the data.The second arrow is for the parent task,which will immediately bind the variable resultto a placeholder value.This parent task is the same onethat was executing the preceding statements.While the data is being downloaded concurrently by the child,the parent task continues to execute the statementsthat follow the concurrent binding.But upon reaching an expressionthat needs the actual value of the result,the parent will await the completion of the child task,which will fulfill the placeholder for result.In this example, our call to URLSessioncould also throw an error.This means that awaiting the result might give us an error.So I need to write “try” to take care of it.And don’t worry.Reading the value of result again will not recompute its value.Now that you’ve seen how async-let works,you can use it to add concurrency to the thumbnail fetching code.I have factored a piece of the previous codethat fetches a single image into its own function.This new function here is also downloading datafrom two different URLs: one for the full-sized image itselfand the other for metadata,which contains the optimal thumbnail size.Notice that with a sequential binding,you write “try await” on the right side of the let,because that’s where an error or suspension would be observed.To make both downloads happen concurrently,you write “async” in front of both of these lets.Since the downloads are now happening in child tasks,you no longer write “try await” on the right sideof the concurrent binding.Those effects are only observed by the parent taskwhen using the variables that are concurrently bound.So you write “try await”before the expression’s reading the metadata and the image data.Also, notice that using these concurrently bound variablesdoes not require a method call or any other changes.Those variables have the same typethat they did in a sequential binding.Now, these child tasks I’ve been talking aboutare actually part of a hierarchy called a task tree.This tree is not just an implementation detail.It’s an important part of structured concurrency.It influences the attributes of your taskslike cancellation, priority,and task-local variables.Whenever you make a call from one async function to another,the same task is used to execute the call.So, the function fetchOneThumbnailinherits all attributes of that task.When creating a new structured task like with async-let,it becomes the child of the taskthat the current function is running on.Tasks are not the child of a specific function,but their lifetime may be scoped to it.The tree is made up of linksbetween each parent and its child tasks.A link enforces a rulethat says a parent task can only finish its workif all of its child tasks have finished.This rule holds even in the face of abnormal control-flowwhich would prevent a child task from being awaited.For example, in this code,I first await the metadata taskbefore the image data task.If the first awaited task finishes by throwing an error,the fetchOneThumbnail function must immediately exitby throwing that error.But what will happen to the taskperforming the second download?During the abnormal exit,Swift will automatically mark the unawaited task as canceledand then await for it to finishbefore exiting the function.Marking a task as canceled does not stop the task.It simply informs the task that its results are no longer needed.In fact, when a task is canceled,all subtasks that are decedents of that taskwill be automatically canceled too.So if the implementation of URLSessioncreated its own structured tasks to download the image,those tasks will be marked for cancellation.The function fetchOneThumbnail finally exitsby throwing the error once all of the structured tasks it createddirectly or indirectly have finished.This guarantee is fundamental to structured concurrency.It prevents you from accidentally leaking tasksby helping you manage their lifetimes,much like how ARC automatically managesthe lifetime of memory.So far, I have given you an overviewof how cancellation propagates.But when does the task finally stop?If the task is in the middle of an important transactionor has open network connections,it would be incorrect to just halt the task.That’s why task cancellation in Swift is cooperative.Your code must check for cancellation explicitlyand wind down execution in whatever way is appropriate.You can check the cancellation status of the current taskfrom any function, whether it is async or not.This means that you should implement your APIswith cancellation in mind,especially if they involve long-running computations.Your users may call into your code from a task that can be canceled,and they will expect the computation to stopas soon as possible.To see how simple it is to use cooperative cancellation,let’s go back to the thumbnail fetching example.Here, I have rewritten the original functionthat was given all of the thumbnails to fetchso that it uses the fetchOneThumbnail function instead.If this function was called within a task that was canceled,we don’t want to hold up our applicationby creating useless thumbnails.So I can just add a call to checkCancellationat the start of each loop iteration.This call only throws an errorif the current task has been canceled.You can also obtain the cancellation status of the current taskas a Boolean value if that is more appropriate for your code.Notice that in this version of the function,I’m returning a partial result,a dictionary with only some of the thumbnails requested.When doing this, you must ensure that your APIclearly states that a partial result may be returned.Otherwise, task cancellationcould trigger a fatal error for your usersbecause their code requires a complete resulteven during cancellation.So far, you’ve seen that async-let providesa lightweight syntax for adding concurrency to your programwhile capturing the essence of structured programming.The next kind of task I want to tell you about is called a group task.They offer more flexibility than async-letwithout giving up all of the nice properties of structured concurrency.As we saw earlier, async-let works wellwhen there’s a fixed amount of concurrency available.Let’s consider both functions that I discussed earlier.For each thumbnail ID in the loop,we call fetchOneThumbnail to process it,which creates exactly two child tasks.Even if we in-lined the body of that function into this loop,the amount of concurrency will not change.Async-let is scoped like a variable binding.That means the two child tasks must completebefore the next loop iteration begins.But what if we want this loop to kick off tasks to fetchall of the thumbnails concurrently?Then, the amount of concurrency is not known staticallybecause it depends on the number of IDs in the array.The right tool for this situation is a task group.A task group is a form of structured concurrencythat is designed to provide a dynamic amount of concurrency.You can introduce a task groupby calling the withThrowingTaskGroup function.This function gives you a scoped group objectto create child tasks that are allowed to throw errors.Tasks added to a group cannot outlive the scopeof the block in which the group is defined.Since I have placed the entire for-loop inside of the block,I can now create a dynamic number of tasks using the group.You create child tasks in a groupby invoking its async method.Once added to a group,child tasks begin executing immediatelyand in any order.When the group object goes out of scope,the completion of all tasks within it will be implicitly awaited.This is a consequence of the task tree rule I described earlier,because group tasks are structured too.At this point, we’ve already achieved the concurrency that we wanted:one task for each call to fetchOneThumbnail,which itself will create two more tasks using async-let.That’s another nice property of structured concurrency.You can use async-let within group tasksor create task groups within async-let tasks,and the levels of concurrency in the tree compose naturally.Now, this code is not quite ready to run.If we tried to run it,the compiler would helpfully alert us to a data race issue.The problem is that we’re trying to insert a thumbnailinto a single dictionary from each child task.This is a common mistake when increasing the amount of concurrency in your program.Data races are accidentally created.This dictionary cannot handle more than one access at a time,and if two child tasks tried to insert thumbnails simultaneously,that could cause a crash or data corruption.In the past, you had to investigate those bugs yourself,but Swift provides static checkingto prevent those bugs from happening in the first place.Whenever you create a new task, the work that the task performsis within a new closure type called a @Sendable closure.The body of a @Sendable closure is restrictedfrom capturing mutable variables in its lexical context,because those variables could be modifiedafter the task is launched.This means that the values you capturein a task must be safe to share.For example, because they are value types,like Int and String,or because they are objects designed to be accessed from multiple threads,like actors, and classesthat implement their own synchronization.We have a whole session dedicated to this topic,called “Protect mutable state with Swift actors,”so I encourage you to check it out.To avoid the data race in our example,you can have each child task return a value.This design gives the parent taskthe sole responsibility of processing the results.In this case, I specified that each child taskmust return a tuple containing the String IDand UIImage for the thumbnail.Then, inside each child task,instead of writing to the dictionary directly,I have them return the key value tuplefor the parent to process.The parent task can iterate through the resultsfrom each child task using the new for-await loop.The for-await loop obtains the results from the child tasksin order of completion.Because this loop runs sequentially,the parent task can safely addeach key value pair to the dictionary.This is just one example of using the for-await loopto access an asynchronous sequence of values.If your own type conforms to the AsyncSequence protocol,then you can use for-await to iterate through them too.You can find out more in the “Meet AsyncSequence” session.While task groups are a form of structured concurrency,there is a small difference in how the task tree rule is implementedfor group tasks versus async-let tasks.Suppose when iterating through the results of this group,I encounter a child task that completed with an error.Because that error is thrown out of the group’s block,all tasks in the group will then be implicitly canceledand then awaited.This works just like async-let.The difference comes when your group goes out of scopethrough a normal exit from the block.Then, cancellation is not implicit.This behavior makes it easier for youto express the fork-join pattern using a task group,because the jobs will only be awaited,not canceled.You can also manually cancel all tasks before exiting the blockusing the group’s cancelAll method.Keep in mind that no matter how you cancel a task,cancellation automatically propagates down the tree.Async-let and group tasks are the two kind of tasksthat provide scoped structured tasks in Swift.Now, I’ll hand things off to Joe,who will tell you about unstructured tasks.Thanks, Kavon.Hi. I’m Joe.Kavon showed you how structured concurrency simplifies error propagation,cancellation, and other bookkeepingwhen you add concurrency to a programwith a clear hierarchy to the tasks.But we know that you don’t always have a hierarchywhen you’re adding tasks to your program.Swift also provides unstructured task APIs,which give you a lot more flexibilityat the expense of needing a lot more manual management.There are a lot of situations where a taskmight not fall into a clear hierarchy.Most obviously, you might not have a parent task at allif you’re trying to launch a task to do async computationfrom non-async code.Alternatively, the lifetime you want for a taskmight not fit the confines of a single scopeor even a single function.You may, for instance, want to start a taskin response to a method call that puts an object into an active stateand then cancel its executionin response to a different method call that deactivates the object.This comes up a lot when implementing delegate objectsin AppKit and UIKit.UI work has to happen on the main thread,and as the Swift actors session discusses,Swift ensures this by declaring UI classesthat belong to the main actor.Let’s say we have a collection view,and we can’t yet use the collection view data source APIs.Instead, we want to use our fetchThumbnails function we just wroteto grab thumbnails from the networkas the items in the collection view are displayed.However, the delegate method is not async,so we can’t just await a call to an async function.We need to start a task for that,but that task is really an extension of the work we startedin response to the delegate action.We want this new task to still runon the main actor with UI priority.We just don’t want to bound the lifetime of the taskto the scope of this single delegate method.For situations like this,Swift allows us to construct an unstructured task.Let’s move that asynchronous part of the code into a closureand pass that closure to construct an async task.Now here’s what happens at runtime.When we reach the point of creating the task,Swift will schedule it to run on the same actor as the originating scope,which is the main actor in this case.Meanwhile, control returns immediately to the caller.The thumbnail task will run on the main threadwhen there’s an opening to do sowithout immediately blocking the main thread on the delegate method.Constructing tasks this way gives us a halfway pointbetween structured and unstructured code.A directly constructed task still inherits the actor,if any, of its launched context,and it also inherits the priority and other traits of the origin task,just like a group task or an async-let would.However, the new task is unscoped.Its lifetime is not bound by the scope of where it was launched.The origin doesn’t even need to be async.We can create an unscoped task anywhere.In trade for all of this flexibility,we must also manually manage the thingsthat structured concurrency would have handled automatically.Cancellation and errors won’t automatically propagate,and the task’s result will not be implicitly awaitedunless we take explicit action to do so.So we kicked off a task to fetch thumbnailswhen a collection view item is displayed,and we should also cancel that task if the item is scrolled out of viewbefore the thumbnails are ready.Since we’re working with an unscoped task,that cancellation isn’t automatic.Let’s implement it now.After we construct the task, let’s save the value we get.We can put this value into a dictionarykeyed by the row index when we create the taskso that we can use it later to cancel that task.We should also remove it from the dictionary once the task finishesso we don’t try to cancel a task if it’s already finished.Note here that we can access the same dictionaryinside and outside of that async taskwithout getting a data race flagged by the compiler.Our delegate class is bound to the main actor,and the new task inherits that,so they’ll never run together in parallel.We can safely access the stored properties of main actor-bound classesinside this task without worrying about data races.Meanwhile, if our delegate is later told that the same table rowhas been removed from the display, then we can call the cancel methodon the value to cancel the task.So now we’ve seen how we can create unstructured tasksthat run independent of a scopewhile still inheriting traits from that task’s originating context.But sometimes you don’t want to inherit anythingfrom your originating context.For maximum flexibility,Swift provides detached tasks.Like the name suggests,detached tasks are independent from their context.They're still unstructured tasks.Their lifetimes are not bound to their originating scope.But detached tasks don’t pick anything else upfrom their originating scope either.By default, they aren’t constrained to the same actorand don’t have to run at the same priorityas where they were launched.Detached tasks run independentlywith generic defaults for things like priority,but they can also be launched with optional parametersto control how and where the new task gets executed.Let’s say that after we fetch thumbnails from the server,we want to write them to a local disk cacheso we don’t hit the network again if we try to fetch them later.The caching doesn’t need to happen on the main actor,and even if we cancel fetching all of the thumbnails,it’s still helpful to cache any thumbnails we did fetch.So let’s kick off caching by using a detached task.When we detach a task, we also get a lot more flexibilityin setting up how that new task executes.Caching should happen at a lower prioritythat doesn’t interfere with the main UI,and we can specify background prioritywhen we detach this new task.Let’s plan ahead for a moment now.What should we do in the future if we have multiple background taskswe want to perform on our thumbnails?We could detach more background tasks,but we could also utilize structured concurrencyinside of our detached task.We can combine all of the different kinds of tasks togetherto exploit each of their strengths.Instead of detaching an independent task for every background job,we can set up a task group and spawn each background jobas a child task into that group.There are a number of benefits of doing so.If we do need to cancel the background task in the future,using a task group means we can cancel all of the child tasksjust by canceling that top level detached task.That cancellation will then propagate to the child tasks automatically,and we don’t need to keep track of an array of handles.Furthermore, child tasks automatically inheritthe priority of their parent.To keep all of this work in the background,we only need to background the detached task,and that will automatically propagate to all of its child tasks,so we don’t need to worry about forgettingto transitively set background priorityand accidentally starving UI work.At this point, we’ve seen all of the primary formsof tasks there are in Swift.Async-let allows for a fixed number of child tasksto be spawned as variable bindings,with automatic management of cancellation and error propagationif the binding goes out of scope.When we need a dynamic number of child tasksthat are still bounded to a scope,we can move up to task groups.If we need to break off some work that isn’t well scopedbut which is still related to its originating task,we can construct unstructured tasks,but we need to manually manage those.And for maximum flexibility, we also have detached tasks,which are manually managed tasksthat don’t inherit anything from their origin.Tasks and structured concurrency are just one partof the suite of concurrency features Swift supports.Be sure to check out all these other great talksto see how it fits in with the rest of the language.“Meet async/await in Swift”gives you more details about async functions,which gives us the structured basisfor writing concurrent code.Actors provide data isolation to create concurrent systemsthat are safe from data races.See the “Protect mutable state with Swift actors” sessionto learn more about how.We saw “for await” loops on task groups,and those are just one example of AsyncSequence,which provides a standard interfacefor working with asynchronous streams of data.The “Meet AsyncSequence” session goes deeperinto the available APIs for working with sequences.Tasks integrate with the core OSto achieve low overhead and high scalability,and the “Swift concurrency: Behind the scenes” sessiongives more technical details about how that’s accomplished.All these features come togetherto make writing concurrent code in Swift easy and safe,letting you write code that gets the most out of your deviceswhile still focusing on the interesting parts of your app,thinking less about the mechanics of managing concurrent tasksor the worries of potential bugs caused by multithreading.Thank you for watching.I hope you enjoy the rest of the conference.[upbeat music]

♪ ♪Hi, I’m Kavon,and I’ll be joined by my colleague, Joe, later on.Swift 5.5 introduces a new way to write concurrent programs,using a concept called structured concurrency.The ideas behind structured concurrencyare based on structured programming,which so intuitive that you rarely think about it,but thinking about it will help you understand structured concurrency.So let’s dive in.

In the early days of computing, programs were hard to readbecause they were written as a sequence of instructions,where control-flow was allowed to jump all over the place.You don’t see that today, because languages use structured programmingto make control-flow more uniform.For example, the if-then statementuses structured control-flow.It specifies that a nested block of codeis only conditionally executed while moving from top to bottom.In Swift, that block also respects static scoping,meaning that names are only visibleif they are defined in an enclosing block.This also means that the lifetimeof any variables defined in a blockwill end when leaving the block.So, structured programming with static scopemakes control-flow and variable lifetime easy to understand.

More generally, structured control-flow can be sequencedand nested together naturally.This lets you read your entire program top to bottom.So, those are the fundamentals of structured programming.As you can imagine, it is easy to take for granted,because it is so intuitive for us today.But today’s programs feature asynchronous and concurrent code,and they have not been able to use structured programmingto make that code easier to write.First, let’s consider how structured programmingmakes asynchronous code simpler.Say that you need to fetch a bunch of images from the internetand resize them to be thumbnails sequentially.This code does that work asynchronously,taking in a collection of strings that identify the images.You’ll notice this function does not return a value when called.That’s because the function passes its result, or an error,to a completion handler it was given.This pattern allows the callerto receive an answer at a later time.As a consequence of that pattern, this function cannot usestructured control-flow for error handling.That’s because it only makes sense to handle errors thrownout of a function, not into one.Also, this pattern prevents youfrom using a loop to process each thumbnail.Recursion is required,because the code that runs after the function completesmust be nested within the handler.Now, let’s take a look at the previous codebut rewritten to use the new async/await syntax,which is based on structured programming.I’ve dropped the completion handler argument from the function.Instead, it is annotated with “async”and “throws” in its type signature.It also returns a value instead of nothing.In the body of the function, I use “await” to saythat an asynchronous action happens, and no nesting is requiredfor the code that runs after that action.This means that I can now loop over the thumbnailsto process them sequentially.I can also throw and catch errors,and the compiler will check that I didn’t forget.For an in-depth look at async/await,check out the session “Meet async/await in Swift.”So, this code is great,but what if you’re producing thumbnails for thousands of images?Processing each thumbnail one at a time is no longer ideal.Plus, what if each thumbnail’s dimensions must be downloadedfrom another URL, instead of being a fixed size?Now there is an opportunity to add some concurrency,so multiple downloads can happen in parallel.You can create additional tasks to add concurrency to a program.Tasks are a new feature in Swiftthat work hand-in-hand with async functions.A task provides a fresh execution contextto run asynchronous code.Each task runs concurrentlywith respect to other execution contexts.They will be automatically scheduled to run in parallelwhen it is safe and efficient to do so.Because tasks are deeply integrated into Swift,the compiler can help prevent some concurrency bugs.Also, keep in mind that calling an async functiondoes not create a new task for the call.You create tasks explicitly.There are a few different flavors of tasks in Swift,because structured concurrency is about the balancebetween flexibility and simplicity.So, for the remainder of this session,Joe and I will introduce and discuss each kind of taskto help you understand their trade-offs.Let’s start with the simplest of these tasks,which is created with a new syntactic formcalled an async-let binding.To help you understand this new syntactic form,I want to first break down the evaluationof an ordinary let binding.There are two parts:the initializer expression on the right side of the equalsand the variable’s name on the left.There may be other statements before or after the let,so I’ll include those here too.Once Swift reaches a let binding,its initializer will be evaluated to produce a value.In this example,that means downloading data from a URL,which could take a while.After the data has been downloaded,Swift will bind that value to the variable namebefore proceeding to the statements that follow.Notice that there is only one flow of execution here,as traced by the arrows through each step.Since the download could take a while,you want the program to start downloading the dataand keep doing other work until the data is actually needed.To achieve this, you can just add the word asyncin front of an existing let binding.This turns it into a concurrent bindingcalled an async-let.The evaluation of a concurrent binding is quite different from a sequential one,so let’s learn how it works.I will start just at the point before encountering the binding.To evaluate a concurrent binding,Swift will first create a new child task,which is a subtask of the one that created it.Because every task representsan execution context for your program,two arrows will simultaneously come out of this step.This first arrow is for the child task,which will immediately begin downloading the data.The second arrow is for the parent task,which will immediately bind the variable resultto a placeholder value.This parent task is the same onethat was executing the preceding statements.While the data is being downloaded concurrently by the child,the parent task continues to execute the statementsthat follow the concurrent binding.But upon reaching an expressionthat needs the actual value of the result,the parent will await the completion of the child task,which will fulfill the placeholder for result.In this example, our call to URLSessioncould also throw an error.This means that awaiting the result might give us an error.So I need to write “try” to take care of it.And don’t worry.Reading the value of result again will not recompute its value.Now that you’ve seen how async-let works,you can use it to add concurrency to the thumbnail fetching code.I have factored a piece of the previous codethat fetches a single image into its own function.This new function here is also downloading datafrom two different URLs: one for the full-sized image itselfand the other for metadata,which contains the optimal thumbnail size.Notice that with a sequential binding,you write “try await” on the right side of the let,because that’s where an error or suspension would be observed.To make both downloads happen concurrently,you write “async” in front of both of these lets.Since the downloads are now happening in child tasks,you no longer write “try await” on the right sideof the concurrent binding.Those effects are only observed by the parent taskwhen using the variables that are concurrently bound.So you write “try await”before the expression’s reading the metadata and the image data.Also, notice that using these concurrently bound variablesdoes not require a method call or any other changes.Those variables have the same typethat they did in a sequential binding.Now, these child tasks I’ve been talking aboutare actually part of a hierarchy called a task tree.This tree is not just an implementation detail.It’s an important part of structured concurrency.It influences the attributes of your taskslike cancellation, priority,and task-local variables.Whenever you make a call from one async function to another,the same task is used to execute the call.So, the function fetchOneThumbnailinherits all attributes of that task.When creating a new structured task like with async-let,it becomes the child of the taskthat the current function is running on.Tasks are not the child of a specific function,but their lifetime may be scoped to it.The tree is made up of linksbetween each parent and its child tasks.A link enforces a rulethat says a parent task can only finish its workif all of its child tasks have finished.This rule holds even in the face of abnormal control-flowwhich would prevent a child task from being awaited.For example, in this code,I first await the metadata taskbefore the image data task.If the first awaited task finishes by throwing an error,the fetchOneThumbnail function must immediately exitby throwing that error.But what will happen to the taskperforming the second download?During the abnormal exit,Swift will automatically mark the unawaited task as canceledand then await for it to finishbefore exiting the function.Marking a task as canceled does not stop the task.It simply informs the task that its results are no longer needed.In fact, when a task is canceled,all subtasks that are decedents of that taskwill be automatically canceled too.So if the implementation of URLSessioncreated its own structured tasks to download the image,those tasks will be marked for cancellation.The function fetchOneThumbnail finally exitsby throwing the error once all of the structured tasks it createddirectly or indirectly have finished.This guarantee is fundamental to structured concurrency.It prevents you from accidentally leaking tasksby helping you manage their lifetimes,much like how ARC automatically managesthe lifetime of memory.So far, I have given you an overviewof how cancellation propagates.But when does the task finally stop?If the task is in the middle of an important transactionor has open network connections,it would be incorrect to just halt the task.That’s why task cancellation in Swift is cooperative.Your code must check for cancellation explicitlyand wind down execution in whatever way is appropriate.You can check the cancellation status of the current taskfrom any function, whether it is async or not.This means that you should implement your APIswith cancellation in mind,especially if they involve long-running computations.Your users may call into your code from a task that can be canceled,and they will expect the computation to stopas soon as possible.To see how simple it is to use cooperative cancellation,let’s go back to the thumbnail fetching example.

Here, I have rewritten the original functionthat was given all of the thumbnails to fetchso that it uses the fetchOneThumbnail function instead.If this function was called within a task that was canceled,we don’t want to hold up our applicationby creating useless thumbnails.So I can just add a call to checkCancellationat the start of each loop iteration.This call only throws an errorif the current task has been canceled.You can also obtain the cancellation status of the current taskas a Boolean value if that is more appropriate for your code.Notice that in this version of the function,I’m returning a partial result,a dictionary with only some of the thumbnails requested.When doing this, you must ensure that your APIclearly states that a partial result may be returned.Otherwise, task cancellationcould trigger a fatal error for your usersbecause their code requires a complete resulteven during cancellation.So far, you’ve seen that async-let providesa lightweight syntax for adding concurrency to your programwhile capturing the essence of structured programming.The next kind of task I want to tell you about is called a group task.They offer more flexibility than async-letwithout giving up all of the nice properties of structured concurrency.As we saw earlier, async-let works wellwhen there’s a fixed amount of concurrency available.Let’s consider both functions that I discussed earlier.For each thumbnail ID in the loop,we call fetchOneThumbnail to process it,which creates exactly two child tasks.Even if we in-lined the body of that function into this loop,the amount of concurrency will not change.Async-let is scoped like a variable binding.That means the two child tasks must completebefore the next loop iteration begins.But what if we want this loop to kick off tasks to fetchall of the thumbnails concurrently?Then, the amount of concurrency is not known staticallybecause it depends on the number of IDs in the array.The right tool for this situation is a task group.A task group is a form of structured concurrencythat is designed to provide a dynamic amount of concurrency.You can introduce a task groupby calling the withThrowingTaskGroup function.This function gives you a scoped group objectto create child tasks that are allowed to throw errors.Tasks added to a group cannot outlive the scopeof the block in which the group is defined.Since I have placed the entire for-loop inside of the block,I can now create a dynamic number of tasks using the group.You create child tasks in a groupby invoking its async method.Once added to a group,child tasks begin executing immediatelyand in any order.When the group object goes out of scope,the completion of all tasks within it will be implicitly awaited.This is a consequence of the task tree rule I described earlier,because group tasks are structured too.At this point, we’ve already achieved the concurrency that we wanted:one task for each call to fetchOneThumbnail,which itself will create two more tasks using async-let.That’s another nice property of structured concurrency.You can use async-let within group tasksor create task groups within async-let tasks,and the levels of concurrency in the tree compose naturally.Now, this code is not quite ready to run.If we tried to run it,the compiler would helpfully alert us to a data race issue.The problem is that we’re trying to insert a thumbnailinto a single dictionary from each child task.This is a common mistake when increasing the amount of concurrency in your program.Data races are accidentally created.This dictionary cannot handle more than one access at a time,and if two child tasks tried to insert thumbnails simultaneously,that could cause a crash or data corruption.In the past, you had to investigate those bugs yourself,but Swift provides static checkingto prevent those bugs from happening in the first place.Whenever you create a new task, the work that the task performsis within a new closure type called a @Sendable closure.The body of a @Sendable closure is restrictedfrom capturing mutable variables in its lexical context,because those variables could be modifiedafter the task is launched.This means that the values you capturein a task must be safe to share.For example, because they are value types,like Int and String,or because they are objects designed to be accessed from multiple threads,like actors, and classesthat implement their own synchronization.We have a whole session dedicated to this topic,called “Protect mutable state with Swift actors,”so I encourage you to check it out.To avoid the data race in our example,you can have each child task return a value.This design gives the parent taskthe sole responsibility of processing the results.In this case, I specified that each child taskmust return a tuple containing the String IDand UIImage for the thumbnail.Then, inside each child task,instead of writing to the dictionary directly,I have them return the key value tuplefor the parent to process.The parent task can iterate through the resultsfrom each child task using the new for-await loop.The for-await loop obtains the results from the child tasksin order of completion.Because this loop runs sequentially,the parent task can safely addeach key value pair to the dictionary.This is just one example of using the for-await loopto access an asynchronous sequence of values.If your own type conforms to the AsyncSequence protocol,then you can use for-await to iterate through them too.You can find out more in the “Meet AsyncSequence” session.

While task groups are a form of structured concurrency,there is a small difference in how the task tree rule is implementedfor group tasks versus async-let tasks.Suppose when iterating through the results of this group,I encounter a child task that completed with an error.Because that error is thrown out of the group’s block,all tasks in the group will then be implicitly canceledand then awaited.This works just like async-let.The difference comes when your group goes out of scopethrough a normal exit from the block.Then, cancellation is not implicit.This behavior makes it easier for youto express the fork-join pattern using a task group,because the jobs will only be awaited,not canceled.You can also manually cancel all tasks before exiting the blockusing the group’s cancelAll method.Keep in mind that no matter how you cancel a task,cancellation automatically propagates down the tree.Async-let and group tasks are the two kind of tasksthat provide scoped structured tasks in Swift.Now, I’ll hand things off to Joe,who will tell you about unstructured tasks.Thanks, Kavon.Hi. I’m Joe.Kavon showed you how structured concurrency simplifies error propagation,cancellation, and other bookkeepingwhen you add concurrency to a programwith a clear hierarchy to the tasks.But we know that you don’t always have a hierarchywhen you’re adding tasks to your program.Swift also provides unstructured task APIs,which give you a lot more flexibilityat the expense of needing a lot more manual management.There are a lot of situations where a taskmight not fall into a clear hierarchy.Most obviously, you might not have a parent task at allif you’re trying to launch a task to do async computationfrom non-async code.Alternatively, the lifetime you want for a taskmight not fit the confines of a single scopeor even a single function.You may, for instance, want to start a taskin response to a method call that puts an object into an active stateand then cancel its executionin response to a different method call that deactivates the object.

This comes up a lot when implementing delegate objectsin AppKit and UIKit.UI work has to happen on the main thread,and as the Swift actors session discusses,Swift ensures this by declaring UI classesthat belong to the main actor.

Let’s say we have a collection view,and we can’t yet use the collection view data source APIs.Instead, we want to use our fetchThumbnails function we just wroteto grab thumbnails from the networkas the items in the collection view are displayed.However, the delegate method is not async,so we can’t just await a call to an async function.We need to start a task for that,but that task is really an extension of the work we startedin response to the delegate action.We want this new task to still runon the main actor with UI priority.We just don’t want to bound the lifetime of the taskto the scope of this single delegate method.For situations like this,Swift allows us to construct an unstructured task.Let’s move that asynchronous part of the code into a closureand pass that closure to construct an async task.Now here’s what happens at runtime.When we reach the point of creating the task,Swift will schedule it to run on the same actor as the originating scope,which is the main actor in this case.Meanwhile, control returns immediately to the caller.The thumbnail task will run on the main threadwhen there’s an opening to do sowithout immediately blocking the main thread on the delegate method.Constructing tasks this way gives us a halfway pointbetween structured and unstructured code.A directly constructed task still inherits the actor,if any, of its launched context,and it also inherits the priority and other traits of the origin task,just like a group task or an async-let would.However, the new task is unscoped.Its lifetime is not bound by the scope of where it was launched.The origin doesn’t even need to be async.We can create an unscoped task anywhere.In trade for all of this flexibility,we must also manually manage the thingsthat structured concurrency would have handled automatically.Cancellation and errors won’t automatically propagate,and the task’s result will not be implicitly awaitedunless we take explicit action to do so.

So we kicked off a task to fetch thumbnailswhen a collection view item is displayed,and we should also cancel that task if the item is scrolled out of viewbefore the thumbnails are ready.Since we’re working with an unscoped task,that cancellation isn’t automatic.Let’s implement it now.After we construct the task, let’s save the value we get.We can put this value into a dictionarykeyed by the row index when we create the taskso that we can use it later to cancel that task.We should also remove it from the dictionary once the task finishesso we don’t try to cancel a task if it’s already finished.Note here that we can access the same dictionaryinside and outside of that async taskwithout getting a data race flagged by the compiler.Our delegate class is bound to the main actor,and the new task inherits that,so they’ll never run together in parallel.We can safely access the stored properties of main actor-bound classesinside this task without worrying about data races.Meanwhile, if our delegate is later told that the same table rowhas been removed from the display, then we can call the cancel methodon the value to cancel the task.So now we’ve seen how we can create unstructured tasksthat run independent of a scopewhile still inheriting traits from that task’s originating context.But sometimes you don’t want to inherit anythingfrom your originating context.For maximum flexibility,Swift provides detached tasks.Like the name suggests,detached tasks are independent from their context.They're still unstructured tasks.Their lifetimes are not bound to their originating scope.But detached tasks don’t pick anything else upfrom their originating scope either.By default, they aren’t constrained to the same actorand don’t have to run at the same priorityas where they were launched.Detached tasks run independentlywith generic defaults for things like priority,but they can also be launched with optional parametersto control how and where the new task gets executed.

Let’s say that after we fetch thumbnails from the server,we want to write them to a local disk cacheso we don’t hit the network again if we try to fetch them later.The caching doesn’t need to happen on the main actor,and even if we cancel fetching all of the thumbnails,it’s still helpful to cache any thumbnails we did fetch.So let’s kick off caching by using a detached task.When we detach a task, we also get a lot more flexibilityin setting up how that new task executes.Caching should happen at a lower prioritythat doesn’t interfere with the main UI,and we can specify background prioritywhen we detach this new task.Let’s plan ahead for a moment now.What should we do in the future if we have multiple background taskswe want to perform on our thumbnails?We could detach more background tasks,but we could also utilize structured concurrencyinside of our detached task.We can combine all of the different kinds of tasks togetherto exploit each of their strengths.Instead of detaching an independent task for every background job,we can set up a task group and spawn each background jobas a child task into that group.There are a number of benefits of doing so.If we do need to cancel the background task in the future,using a task group means we can cancel all of the child tasksjust by canceling that top level detached task.That cancellation will then propagate to the child tasks automatically,and we don’t need to keep track of an array of handles.Furthermore, child tasks automatically inheritthe priority of their parent.To keep all of this work in the background,we only need to background the detached task,and that will automatically propagate to all of its child tasks,so we don’t need to worry about forgettingto transitively set background priorityand accidentally starving UI work.At this point, we’ve seen all of the primary formsof tasks there are in Swift.Async-let allows for a fixed number of child tasksto be spawned as variable bindings,with automatic management of cancellation and error propagationif the binding goes out of scope.When we need a dynamic number of child tasksthat are still bounded to a scope,we can move up to task groups.If we need to break off some work that isn’t well scopedbut which is still related to its originating task,we can construct unstructured tasks,but we need to manually manage those.And for maximum flexibility, we also have detached tasks,which are manually managed tasksthat don’t inherit anything from their origin.Tasks and structured concurrency are just one partof the suite of concurrency features Swift supports.Be sure to check out all these other great talksto see how it fits in with the rest of the language.“Meet async/await in Swift”gives you more details about async functions,which gives us the structured basisfor writing concurrent code.Actors provide data isolation to create concurrent systemsthat are safe from data races.See the “Protect mutable state with Swift actors” sessionto learn more about how.We saw “for await” loops on task groups,and those are just one example of AsyncSequence,which provides a standard interfacefor working with asynchronous streams of data.The “Meet AsyncSequence” session goes deeperinto the available APIs for working with sequences.Tasks integrate with the core OSto achieve low overhead and high scalability,and the “Swift concurrency: Behind the scenes” sessiongives more technical details about how that’s accomplished.All these features come togetherto make writing concurrent code in Swift easy and safe,letting you write code that gets the most out of your deviceswhile still focusing on the interesting parts of your app,thinking less about the mechanics of managing concurrent tasksor the worries of potential bugs caused by multithreading.Thank you for watching.I hope you enjoy the rest of the conference.[upbeat music]

1:57 -Asynchronous code with completion handlers is unstructured

2:56 -Asynchronous code with async/await is structured

7:59 -Structured concurrency with async-let

11:46 -Checking for cancellation by calling a method that throws

12:16 -Obtaining the cancellation status of the current task

13:13 -Async-let is for concurrency with static width

13:58 -A task group is for concurrency with dynamic width

16:32 -Accessing the results of tasks within a group

20:39 -Creating an unstructured task

22:11 -Cancelling unstructured tasks

24:09 -Detaching a task

24:57 -Creating a task group inside a detached task

## Code Samples

```swift
func
 
fetchThumbnails
(
    
for
 
ids
: [
String
],
    
completion
 
handler
: 
@escaping
 ([String: 
UIImage
]
?
, 
Error
?) -> 
Void

)
 {
    
guard
 
let
 id 
=
 ids.first 
else
 { 
return
 handler([:], 
nil
) }
    
let
 request 
=
 thumbnailURLRequest(for: id)
    
let
 dataTask 
=
 
URLSession
.shared.dataTask(with: request) { data, response, error 
in

        
guard
 
let
 response 
=
 response,
              
let
 data 
=
 data
        
else
 {
            
return
 handler(
nil
, error)
        }
        
// ... check response ...

        
UIImage
(data: data)
?
.prepareThumbnail(of: thumbSize) { image 
in

            
guard
 
let
 image 
=
 image 
else
 {
                
return
 handler(
nil
, 
ThumbnailFailedError
())
            }
            fetchThumbnails(for: 
Array
(ids.dropFirst())) { thumbnails, error 
in

                
// ... add image to thumbnails ...

            }
        }
    }
    dataTask.resume()
}
```

```swift
func
 
fetchThumbnails
(
for
 
ids
: [
String
])
 
async
 
throws
 -> [
String
: 
UIImage
] {
    
var
 thumbnails: [
String
: 
UIImage
] 
=
 [:]
    
for
 id 
in
 ids {
        
let
 request 
=
 thumbnailURLRequest(for: id)
        
let
 (data, response) 
=
 
try
 
await
 
URLSession
.shared.data(for: request)
        
try
 validateResponse(response)
        
guard
 
let
 image 
=
 
await
 
UIImage
(data: data)
?
.byPreparingThumbnail(ofSize: thumbSize) 
else
 {
            
throw
 
ThumbnailFailedError
()
        }
        thumbnails[id] 
=
 image
    }
    
return
 thumbnails
}
```

```swift
func
 
fetchOneThumbnail
(
withID
 
id
: 
String
)
 
async
 
throws
 -> 
UIImage
 {
    
let
 imageReq 
=
 imageRequest(for: id), metadataReq 
=
 metadataRequest(for: id)
    
async
 
let
 (data, 
_
) 
=
 
URLSession
.shared.data(for: imageReq)
    
async
 
let
 (metadata, 
_
) 
=
 
URLSession
.shared.data(for: metadataReq)
    
guard
 
let
 size 
=
 parseSize(from: 
try
 
await
 metadata),
          
let
 image 
=
 
try
 
await
 
UIImage
(data: data)
?
.byPreparingThumbnail(ofSize: size)
    
else
 {
        
throw
 
ThumbnailFailedError
()
    }
    
return
 image
}
```

```swift
func
 
fetchThumbnails
(
for
 
ids
: [
String
])
 
async
 
throws
 -> [
String
: 
UIImage
] {
    
var
 thumbnails: [
String
: 
UIImage
] 
=
 [:]
    
for
 id 
in
 ids {
        
try
 
Task
.checkCancellation()
        thumbnails[id] 
=
 
try
 
await
 fetchOneThumbnail(withID: id)
    }
    
return
 thumbnails
}
```

```swift
func
 
fetchThumbnails
(
for
 
ids
: [
String
])
 
async
 
throws
 -> [
String
: 
UIImage
] {
    
var
 thumbnails: [
String
: 
UIImage
] 
=
 [:]
    
for
 id 
in
 ids {
        
if
 
Task
.isCancelled { 
break
 }
        thumbnails[id] 
=
 
try
 
await
 fetchOneThumbnail(withID: id)
    }
    
return
 thumbnails
}
```

```swift
func
 
fetchThumbnails
(
for
 
ids
: [
String
])
 
async
 
throws
 -> [
String
: 
UIImage
] {
    
var
 thumbnails: [
String
: 
UIImage
] 
=
 [:]
    
for
 id 
in
 ids {
        thumbnails[id] 
=
 
try
 
await
 fetchOneThumbnail(withID: id)
    }
    
return
 thumbnails
}


func
 
fetchOneThumbnail
(
withID
 
id
: 
String
)
 
async
 
throws
 -> 
UIImage
 {
    
// ...


    
async
 
let
 (data, 
_
) 
=
 
URLSession
.shared.data(for: imageReq)
    
async
 
let
 (metadata, 
_
) 
=
 
URLSession
.shared.data(for: metadataReq)

    
// ...

}
```

```swift
func
 
fetchThumbnails
(
for
 
ids
: [
String
])
 
async
 
throws
 -> [
String
: 
UIImage
] {
    
var
 thumbnails: [
String
: 
UIImage
] 
=
 [:]
    
try
 
await
 withThrowingTaskGroup(of: 
Void
.
self
) { group 
in

        
for
 id 
in
 ids {
            group.async {
                
// Error: Mutation of captured var 'thumbnails' in concurrently executing code

                thumbnails[id] 
=
 
try
 
await
 fetchOneThumbnail(withID: id)
            }
        }
    }
    
return
 thumbnails
}
```

```swift
func
 
fetchThumbnails
(
for
 
ids
: [
String
])
 
async
 
throws
 -> [
String
: 
UIImage
] {
    
var
 thumbnails: [
String
: 
UIImage
] 
=
 [:]
    
try
 
await
 withThrowingTaskGroup(of: (
String
, 
UIImage
).
self
) { group 
in

        
for
 id 
in
 ids {
            group.async {
                
return
 (id, 
try
 
await
 fetchOneThumbnail(withID: id))
            }
        }
        
// Obtain results from the child tasks, sequentially, in order of completion.

        
for
 
try
 
await
 (id, thumbnail) 
in
 group {
            thumbnails[id] 
=
 thumbnail
        }
    }
    
return
 thumbnails
}
```

```swift
@MainActor


class
 
MyDelegate
: 
UICollectionViewDelegate
 
{
    
func
 
collectionView
(
_
 
view
: 
UICollectionView
, 
willDisplay
 
cell
: 
UICollectionViewCell
, 
forItemAt
 
item
: 
IndexPath
)
 {
        
let
 ids 
=
 getThumbnailIDs(for: item)
        
Task
 {
            
let
 thumbnails 
=
 
await
 fetchThumbnails(for: ids)
            display(thumbnails, in: cell)
        }
    }
}
```

```swift
@MainActor


class
 
MyDelegate
: 
UICollectionViewDelegate
 
{
    
var
 thumbnailTasks: [
IndexPath
: 
Task
<
Void
, 
Never
>] 
=
 [:]
    
    
func
 
collectionView
(
_
 
view
: 
UICollectionView
, 
willDisplay
 
cell
: 
UICollectionViewCell
, 
forItemAt
 
item
: 
IndexPath
)
 {
        
let
 ids 
=
 getThumbnailIDs(for: item)
        thumbnailTasks[item] 
=
 
Task
 {
            
defer
 { thumbnailTasks[item] 
=
 
nil
 }
            
let
 thumbnails 
=
 
await
 fetchThumbnails(for: ids)
            display(thumbnails, in: cell)
        }
    }
    
    
func
 
collectionView
(
_
 
view
: 
UICollectionView
, 
didEndDisplay
 
cell
: 
UICollectionViewCell
, 
forItemAt
 
item
: 
IndexPath
)
 {
        thumbnailTasks[item]
?
.cancel()
    }
}
```

```swift
@MainActor


class
 
MyDelegate
: 
UICollectionViewDelegate
 
{
    
var
 thumbnailTasks: [
IndexPath
: 
Task
<
Void
, 
Never
>] 
=
 [:]
    
    
func
 
collectionView
(
_
 
view
: 
UICollectionView
, 
willDisplay
 
cell
: 
UICollectionViewCell
, 
forItemAt
 
item
: 
IndexPath
)
 {
        
let
 ids 
=
 getThumbnailIDs(for: item)
        thumbnailTasks[item] 
=
 
Task
 {
            
defer
 { thumbnailTasks[item] 
=
 
nil
 }
            
let
 thumbnails 
=
 
await
 fetchThumbnails(for: ids)
            
Task
.detached(priority: .background) {
                writeToLocalCache(thumbnails)
            }
            display(thumbnails, in: cell)
        }
    }
}
```

```swift
@MainActor


class
 
MyDelegate
: 
UICollectionViewDelegate
 
{
    
var
 thumbnailTasks: [
IndexPath
: 
Task
<
Void
, 
Never
>] 
=
 [:]
    
    
func
 
collectionView
(
_
 
view
: 
UICollectionView
, 
willDisplay
 
cell
: 
UICollectionViewCell
, 
forItemAt
 
item
: 
IndexPath
)
 {
        
let
 ids 
=
 getThumbnailIDs(for: item)
        thumbnailTasks[item] 
=
 
Task
 {
            
defer
 { thumbnailTasks[item] 
=
 
nil
 }
            
let
 thumbnails 
=
 
await
 fetchThumbnails(for: ids)
            
Task
.detached(priority: .background) {
                withTaskGroup(of: 
Void
.
self
) { g 
in

                    g.async { writeToLocalCache(thumbnails) }
                    g.async { log(thumbnails) }
                    g.async { 
...
 }
                }
            }
            display(thumbnails, in: cell)
        }
    }
}
```


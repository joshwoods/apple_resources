# Wwdc2021 10015

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Build apps that share data through CloudKit and Core DataLearn how to easily build apps that share data between multiple iCloud users with NSPersistentCloudKitContainer. Discover how to create informative experiences around shared data and learn about the CloudKit technologies that support these features in Core Data.

To get the most out of this session, check out our previous videos on NSPersistentCloudKitContainer: "Using Core Data With CloudKit" from WWDC19 and "Sync a Core Data store with the CloudKit public database" from WWDC20.ResourcesSynchronizing a local store to the cloudHD VideoSD VideoRelated VideosWWDC22Optimize your use of Core Data and CloudKitWWDC21Bring Core Data concurrency to Swift and SwiftUIThere and back again: Data transfer on Apple WatchWhat's new in CloudKitTech TalksGet the most out of CloudKit Sharing

Learn how to easily build apps that share data between multiple iCloud users with NSPersistentCloudKitContainer. Discover how to create informative experiences around shared data and learn about the CloudKit technologies that support these features in Core Data.

To get the most out of this session, check out our previous videos on NSPersistentCloudKitContainer: "Using Core Data With CloudKit" from WWDC19 and "Sync a Core Data store with the CloudKit public database" from WWDC20.

Synchronizing a local store to the cloud

HD VideoSD Video

HD Video

SD Video

Optimize your use of Core Data and CloudKit

Bring Core Data concurrency to Swift and SwiftUI

There and back again: Data transfer on Apple Watch

What's new in CloudKit

Get the most out of CloudKit Sharing

Search this video…Hi.I'm Nick Gillett, an engineer here at Appleon the Core Data team.In this session,I'll show you how to easily build applicationsthat use NSPersistentCloudKitContainerto share datawith multiple iCloud users.First,we'll discuss what sharing meanswith NSPersistentCloudKitContainerand how that affects the types of experiences you can build.Next, we'll take a deep dive into the mechanics of sharing.And finally,we'll briefly discuss howNSPersistentCloudKitContainercan help you enable some additional protectionfor sensitive data stored in iCloud.Let's get started with sharing.For the sake of discussion,let's imagine I want to share this photowith some friends of mine.How might I do that?On Apple platforms, there are a number of wayswe can share the data our applications create.Photos implements a system controlhere in the lower leftthat allows me to call up an Action sheet.It has a wide variety of actions I can take,including a number of ways to share.For example,I can send it to my friends as an iMessage or email.But ideally, we would have a single placedirectly in the Photos appwhere my friends and I can share our photos with each other.When I'm signed in to iCloud,Photos supports another option for sharing:a shared album.Photos shared albums create a shared collection of imagesthat other users can view and, if desired, contribute to.I simply give the new album a titleand then tap Nextto choose the set of participants.Here I've chosen four friends to share the photo with.Heather, Jermaine, Percy, and Mary are all test accountsI regularly work with when I'm building sharing features.When I tap Next,I can see my new album with the photo I shared.Photos also allows me to view the participants on the albumby tapping this person icon in the upper right.Tapping that brings up the set of participants.Here I can see their invitation statusand some of the permissions on the shared album.How might we build an experience like this?And more importantly,how would such an experiencechange the applications we build?Well, let me show you.To demonstrate how sharing workswith NSPersistentCloudKitContainer,I'm going to be using our sample application,Syncing a Core Data Store with the Cloud.I've already modified it to support sharing postswith different iCloud users.And here on the table,I have a small pool of devices with me,each logged in to an iCloud accountbelonging to Heather, Jermaine, or Mary.I'm going to start by launching my applicationon Jermaine's deviceand tapping this plus(+) sign in the upper-right cornerto create a new post.I'll give it a simple title-- "Sharing demos are great"--and tap Done.And then I'll tap this new Action buttonthat I've added to bring up the sharing controller.I want to send each person an inviteto work on this post with me via email.So I'll tap Mail and then enter the information for my friends.I've already saved Heather and Mary in my address book,so they're easy to find.Finally, I'll tap Send to send the email.Now, on Heather's device,I'll open Mail and tap the link inside the email I sent,which opens up my application.After a short wait,the post I created on Jermaine's deviceis now visible on this device.On Mary's device,I'll open Mail and tap the link inside the email I sent,which opens up my application.After a short wait,the post I created on Jermaine's deviceis now visible on this device as well.But how does all of this work?And exactly how much did I have to changein the sample application?The answer is, "Not much."Sharing is by far the most complicated featurewe have built in to NSPersistentCloudKitContainer.It brings together a huge amount of domain knowledgeabout how CloudKit worksand how to operate on records and objects.Naturally,this domain knowledge is reflectedin the APIs we have builtfor NSPersistentCloudKitContainer.So let's take a look at exactly howNSPersistentCloudKitContainer shares objects.In my brief demo,I showed an application that makes useof two CloudKit databases,the .private and the .shared database.Each of these is mirrored to a persistent storein my application,one using the .private database scopeand the other using the .shared database scope.Using a single managed object context,my application can access data in both stores.Let's look at that change in a bit more detail.The first change I had to makewas to tell NSPersistentCloudKitContainerto mirror the .shared CloudKit databaseto a new persistent store.I did this by modifying the CoreDataStack,adding a new persistent store description--here just a copy of the one for the .private storewith a different URL.Then, I set its CloudKit container options’databaseScope property to .shared.This is new iOS 15and allows NSPersistentCloudKitContainerto be configured to mirror persistent storesto the .shared CloudKit database.To complete the demo,I had to make two other changes.I adopted a new method on NSPersistentCloudKitContainerto create the share.share(_ managedObjects: to share: completion:)is a new methoddesigned to pair directly with UICloudSharingController.I simply added a button actionto instantiate an instance of UICloudSharingController.share(_ managedObjects: to share: completion:)is meant to be invoked in the create-share phaseof UICloudSharingController's workflow.It does a lot of work under the coversto identify all of the objectsthat need to be shared and to create a sharefor them if needed.Finally,I invoke UICloudSharingController'scompletion block with the resultsprovided by NSPersistentCloudKitContainer,which tells it I'm ready to continue the sharing flow.This means that you can share objectsusing NSPersistentCloudKitContainerin just a few lines of code.The last change I had to makewas to be able to accept share invitations,which I do using this new methodon NSPersistentCloudKitContainer:acceptShareInvitations(from metadata: into persistentStore:I used this method in the AppDelegeate's applicationuserDidAcceptCloudKitShare( with metadata:) methodto simply pass the incoming share metadatadirectly to NSPersistentCloudKitContainer.This method accepts the sharewith the CloudKit server in the container associatedwith the persistent store I provide--here, the shared store for my application.After the share is accepted,NSPersistentCloudKitContainer automatically syncsall of the shared objects into the local store.So that's how we use NSPersistentCloudKitContainerto combine the .private and .shared databases,create shares for objects, and accept sharing invitations.But our applications are usually designedto manage large collections of data.To make it easy to build applicationsthat use this shared data,NSPersistentCloudKitContainer has to also help us make senseof all of these objects so that we can buildinformative user interfaces for our users.To understand these challenges a bit more clearly,we need to identify two crucial concepts for sharing.The first is the notion of a set of actors.We call them the owner and the participants.The owner is the iCloud account that actually owns an object.Owners create and share objects with a set of participants.A participant is any other iCloud accountthat is allowed to operate on those objects in some way.Participants can have different roles and permissionsthat constrain how they can act on a particular set of objects,which brings us to the second key concept:how NSPersistentCloudKitContainerand CloudKit structure these shared objects.In Core Data,we think of our objects in terms of NSManagedObject.NSPersistentCloudKitContainer turns those managed objectsinto instances of CKRecord that are stored in CloudKit.If you've worked with sharing before,you're probably familiar with hierarchical sharing,where these records are associatedwith a root record called the share.But this isn't howNSPersistentCloudKitContainer works.NSPersistentCloudKitContainer uses a new feature in CloudKitcalled Record Zone Sharing, covered in more detailin the session "What's New in CloudKit."But let's take a look at how NSPersistentCloudKitContaineruses Record Zone Sharing to share managed objects.In a CloudKit database--for example, the .private database--NSPersistentCloudKitContainer typically manages a private zoneto store the objects an application creates.In Record Zone Sharing,shared CKRecords are contained inside a shared CKRecordZone.Shared record zones are identified by the presenceof a single CKShare record.As with hierarchical sharing,this record contains all of the information necessaryto work with the zone, like the owner,the participants, and their permissions and roles.NSPersistentCloudKitContainer manages these zonesand automatically assigns records to them.Because there's no root record,NSPersistentCloudKitContainer also has to understandhow the concepts of owners and participants applyto the entire record zone.Let's imagine I have a collection of peopleI want to share with.Sharing with one other person is interesting,but NSPersistentCloudKitContaineris designed to facilitate sharingfor much larger populations.Each of these participants will be able to accessand operate on the objects I share with them.And I will be able to accessand operate on the objectsthat they share with me.Each participant will also have their own collectionof devices.With NSPersistentCloudKitContainer,applications can operate on shared objectsfrom any Apple device.For each participant,NSPersistentCloudKitContainermanages objects in two CloudKit databases,the .private and the .shared database.In my .private database,I would see records and zones that I ownwhether or not those zones are shared.For example,the zone thatNSPersistentCloudKitContainer manages.With sharing,NSPersistentCloudKitContainerwill also create shared zones for mewith a CKShare recordthat controls who can access these zones that I own.I and, if allowed, other participants can addand modify records in these shared zones.In my .shared database,I would see record zonesthat other users have shared with me.If I'm allowed to, I can add records that I ownto any of those zonesjust as they can in the zones that I own.Another user will see a different set of zonesin their .private and .shared databases,depending on whether or not they are the owner of those zones.For example, this user may have a private zoneand a shared zone that they own in their .private database.In addition,they would see my two zones that I share with themand any other zones they are a participant onin their .shared database.So how does NSPersistentCloudKitContainerknow where to keep your records?In many cases,it can infer where records belongbased on the relationship they have to other objects.But you can also tellshare(_ managedObjects: to share: completion:)to store objects in a specific shared zoneby passing it a non-nil CKShare.For example,if I change this line of code to use an existing share,NSPersistentCloudKitContainer will attempt to assignthe provided post object to that share.These are all the changes I had to make for my first demo,but my application also needs to effectively communicatewhat objects are shared, who they're shared with,and what those participants can do.Our users need all of that informationso that they can make good decisionsabout the objects they choose to share.So let's look at how I've changed my applicationto communicate these states and privileges.Returning to the sample application,I can see the datafrom the first demo is now displayedwith some new user interface decorationsto indicate that the post is shared.If I tap on it, I can also see the participantsdisplayed at the bottom of the detail view controllerwith their role, permissions, and acceptance state.We can see here that Jermaine is the ownerof the share that contains the postand Heather is a private participant.Now I'm going to add a new post, give it a title, and tap Done.I'll tap the Action button to bring up the sharing controller,but this time, I want the share to be read-onlyso that the participants can't edit or modifythe contents of the share.So I'll change the share options to mark the share as View Only.Next, I'll tap Mail and invite Jermaine and Mary.Finally, I'll send the email.On Mary's device,I'll accept the new share,and now I can see the new post.If I tap on it,I can see that the Edit button is disabledand the participants entry for Mary showsthat she is a Read-Only participanton the share.Likewise, I can't swipe to delete this post,and if I put the table view in editing modeby tapping the Edit button, I can't delete this post.On Jermaine's device now, I'll accept the new share.And now I can see the new post.If I tap on it,I can see that the Edit button is disabledand the participants entry for Jermaine showsthat he is a Read-Only participant on the share.Even in this humble sample application,I've had to make a number of changes to the user interfaceto present information about shared objects.I had to decorate the post table cellsto indicate which ones are shared.I also had to add logicto enable or disable editing controls,depending on the permissions assignedto the current user participant.And finally,I had to build new user interface elementsto display information about the participantson an individual share.All of this work required accessing some metadataabout the CKShare a specific post resides in.NSPersistentCloudKitContainer includesa number of API methods to align with each of these concerns.fetchShares(matching objectIDs:) is new in iOS 15and allows me to get the CKShare for a specific post.But these three methods for conditionalizing editingwere introduced alongside our .public database supportat WWDC in 2020.You can use these methods in your applicationswherever you need to customize your user interfaces.But in my application, I took a slightly different approach.Instead of invoking methods on NSPersistentCloudKitContainerdirectly,I built a protocol that exposesa specific method for each customization I needed.It's called the SharingProvider.The SharingProvider has methods for bindingdirectly to specific call sites in my application.For example,I might need to know whether or not an object is shared.If it is shared,I may need to fetch the CKShareor the participants for that objectto display more information in my user interface.Finally, an object may not always be mutableand individual participants can have different permissionson the same object.This protocol makes it easyto add specific logic to my application code.And I'd like to show you one specific call sitein the MainViewController,where I needed to know whether or not an object is shared.Here I used isShared to decidewhether or not to convert the title of a postto an attributed string and prefix itwith the person.circle symbolto show that the post is part of a share.Customizations like this necessarily requiremore complicated code than if I chose not to support sharing.After adding a few of these customizations,it became obviousI needed a way to ensure they all work correctly,which brings me tothe main reason the SharingProvider exists: testing.The SharingProvider protocol makes it easyto test these decision points by injection.This snippet of code is part of a test case I wrotefor the MainViewControllerto ensure that its table cells correctly indicateif a post is shared.I left off the scaffolding for creating the sample data,but the test crafts a mixed set of managed objectsthat it identifies as shared or not sharedby the presence of their objectID in this set.Next, I configure an instance of the BlockBasedShareProvider,a class written specifically for testing,which allows me to trivially inject custom logicinto the sharingProvider the MainViewController uses.Here I'm setting the isSharedBlockto call the contains method of the set I created.This is a cute trick in Swift that allows me to simply checkif the provided objectID is in sharedObjectIDs.Then,I set the BlockBasedProvider as the providerfor the view controller, completing the injection.Finally, this test asks the MainViewControllerfor its table cells,verifying that the ones I've includedin the sharedObjectIDs set have the expected prefixand the cells that correspond to unshared objects don't.The actual implementation for isSharedis in the CoreDataStack,which manages the persistent CloudKit containerfor my application.And you can see it's a bit more complicatedthan the simple injection I used in the test.Now, I could go through this implementationline by line,but that's not what's important here.What's important is that it's way more complicatedthan I can easily exerciseevery time I want to verify a change to the table view,and trying to do so would add a lot of frictionto the development process.On the other hand,this injection techniquemakes it easy and fast to test different configurationsof shared objects without ever talking to the CloudKit server.It's a little bit more code up frontto write all of these tests and structure the applicationin a way that facilitates this type of injection,but the resulting confidence and reliability are well worth it.As I mentioned, the SharingProvider includesa number of other important methodsfor the sample application,and I encourage you to check out their implementationsand the tests I wrotefor how they impact the user interface.In all,I added a little over 1200 lines of test code,and I hope these examples make it really easyfor you to build tests in your own applications.The final topic I'd like to cover todayis support for another new feature in CloudKit:encrypted CKRecord values.These values are stored in a new payload on CKRecordcalled encryptedValues,introduced in the "What's New in CloudKit" session.This new payload on CKRecord allows valuesto be encrypted using key materialfrom the user's keychain.These values are decrypted locally on deviceafter they're downloaded from the CloudKit server,and they're encrypted locally on devicebefore they are uploaded to the CloudKit server.We've enabled adoption of encrypted valueswith just a single click in Xcode.Let's see that in action.Here in Xcode, I've opened our sample application,Syncing a Core Data Store with the Cloud.I'll open the CoreDataCloudKitDemomanaged object model,and there's a specific property on the post entityI want to show you called location.If I select the location attribute,I can see its configuration in the data model inspectoron the right.I've configured itto be an optional Transformable attributeand checkedthis new Allows Cloud Encryption checkbox.This new checkbox tells NSPersistentCloudKitContainerthat the value for this attributeshould be stored in the encryptedValues payloadof the resulting CKRecord.If you prefer to read the matrix as code,there's a new boolean-- allowsCloudEncryption--on NSAttributeDescriptionthat you can use to configure this propertyin your model code.Now, encryption with CloudKitis an at-introduction time decision.That means we can't change our mind laterand choose to encrypt fieldsthat aren't already encrypted today in production.Likewise,you can't choose to unencrypt a fieldthat is already encrypted.Once the CloudKit schema is pushed to production,we can't change any of the field types.So be sure to use NSPersistentCloudKitContainer'sinitializeSchema methodto ensure that all your fields are presentand correctly typedbefore deploying your schema to production.It's been my pleasure to introducejust some of the changes we've madeto NSPersistentCloudKitContainer to support sharing.There's a lot of new API to learn about.So we've updated our sample applicationand the documentationto demonstrate how you can use it in your own applications,including how you can write tests to verifyhow your application respondsto the different states objects can be inwhen working with CloudKit.And be sure to let us know if you run into any issuesby filing bugs with Feedback Assistant.As always,I can't wait to see what you buildwith NSPersistentCloudKitContainer.Stay active, close your rings, and have a great WWDC 2021.[music]

Hi.I'm Nick Gillett, an engineer here at Appleon the Core Data team.In this session,I'll show you how to easily build applicationsthat use NSPersistentCloudKitContainerto share datawith multiple iCloud users.

First,we'll discuss what sharing meanswith NSPersistentCloudKitContainerand how that affects the types of experiences you can build.Next, we'll take a deep dive into the mechanics of sharing.And finally,we'll briefly discuss howNSPersistentCloudKitContainercan help you enable some additional protectionfor sensitive data stored in iCloud.Let's get started with sharing.

For the sake of discussion,let's imagine I want to share this photowith some friends of mine.How might I do that?On Apple platforms, there are a number of wayswe can share the data our applications create.Photos implements a system controlhere in the lower leftthat allows me to call up an Action sheet.It has a wide variety of actions I can take,including a number of ways to share.For example,I can send it to my friends as an iMessage or email.But ideally, we would have a single placedirectly in the Photos appwhere my friends and I can share our photos with each other.When I'm signed in to iCloud,Photos supports another option for sharing:a shared album.Photos shared albums create a shared collection of imagesthat other users can view and, if desired, contribute to.I simply give the new album a titleand then tap Nextto choose the set of participants.Here I've chosen four friends to share the photo with.Heather, Jermaine, Percy, and Mary are all test accountsI regularly work with when I'm building sharing features.When I tap Next,I can see my new album with the photo I shared.Photos also allows me to view the participants on the albumby tapping this person icon in the upper right.Tapping that brings up the set of participants.Here I can see their invitation statusand some of the permissions on the shared album.How might we build an experience like this?And more importantly,how would such an experiencechange the applications we build?Well, let me show you.To demonstrate how sharing workswith NSPersistentCloudKitContainer,I'm going to be using our sample application,Syncing a Core Data Store with the Cloud.I've already modified it to support sharing postswith different iCloud users.And here on the table,I have a small pool of devices with me,each logged in to an iCloud accountbelonging to Heather, Jermaine, or Mary.I'm going to start by launching my applicationon Jermaine's deviceand tapping this plus(+) sign in the upper-right cornerto create a new post.I'll give it a simple title-- "Sharing demos are great"--and tap Done.

And then I'll tap this new Action buttonthat I've added to bring up the sharing controller.I want to send each person an inviteto work on this post with me via email.So I'll tap Mail and then enter the information for my friends.I've already saved Heather and Mary in my address book,so they're easy to find.Finally, I'll tap Send to send the email.

Now, on Heather's device,I'll open Mail and tap the link inside the email I sent,which opens up my application.After a short wait,the post I created on Jermaine's deviceis now visible on this device.

On Mary's device,I'll open Mail and tap the link inside the email I sent,which opens up my application.

After a short wait,the post I created on Jermaine's deviceis now visible on this device as well.But how does all of this work?And exactly how much did I have to changein the sample application?The answer is, "Not much."Sharing is by far the most complicated featurewe have built in to NSPersistentCloudKitContainer.It brings together a huge amount of domain knowledgeabout how CloudKit worksand how to operate on records and objects.Naturally,this domain knowledge is reflectedin the APIs we have builtfor NSPersistentCloudKitContainer.So let's take a look at exactly howNSPersistentCloudKitContainer shares objects.

In my brief demo,I showed an application that makes useof two CloudKit databases,the .private and the .shared database.Each of these is mirrored to a persistent storein my application,one using the .private database scopeand the other using the .shared database scope.Using a single managed object context,my application can access data in both stores.Let's look at that change in a bit more detail.The first change I had to makewas to tell NSPersistentCloudKitContainerto mirror the .shared CloudKit databaseto a new persistent store.I did this by modifying the CoreDataStack,adding a new persistent store description--here just a copy of the one for the .private storewith a different URL.Then, I set its CloudKit container options’databaseScope property to .shared.This is new iOS 15and allows NSPersistentCloudKitContainerto be configured to mirror persistent storesto the .shared CloudKit database.To complete the demo,I had to make two other changes.

I adopted a new method on NSPersistentCloudKitContainerto create the share.share(_ managedObjects: to share: completion:)is a new methoddesigned to pair directly with UICloudSharingController.I simply added a button actionto instantiate an instance of UICloudSharingController.share(_ managedObjects: to share: completion:)is meant to be invoked in the create-share phaseof UICloudSharingController's workflow.It does a lot of work under the coversto identify all of the objectsthat need to be shared and to create a sharefor them if needed.Finally,I invoke UICloudSharingController'scompletion block with the resultsprovided by NSPersistentCloudKitContainer,which tells it I'm ready to continue the sharing flow.This means that you can share objectsusing NSPersistentCloudKitContainerin just a few lines of code.

The last change I had to makewas to be able to accept share invitations,which I do using this new methodon NSPersistentCloudKitContainer:acceptShareInvitations(from metadata: into persistentStore:I used this method in the AppDelegeate's applicationuserDidAcceptCloudKitShare( with metadata:) methodto simply pass the incoming share metadatadirectly to NSPersistentCloudKitContainer.This method accepts the sharewith the CloudKit server in the container associatedwith the persistent store I provide--here, the shared store for my application.After the share is accepted,NSPersistentCloudKitContainer automatically syncsall of the shared objects into the local store.So that's how we use NSPersistentCloudKitContainerto combine the .private and .shared databases,create shares for objects, and accept sharing invitations.But our applications are usually designedto manage large collections of data.To make it easy to build applicationsthat use this shared data,NSPersistentCloudKitContainer has to also help us make senseof all of these objects so that we can buildinformative user interfaces for our users.

To understand these challenges a bit more clearly,we need to identify two crucial concepts for sharing.

The first is the notion of a set of actors.We call them the owner and the participants.The owner is the iCloud account that actually owns an object.Owners create and share objects with a set of participants.A participant is any other iCloud accountthat is allowed to operate on those objects in some way.Participants can have different roles and permissionsthat constrain how they can act on a particular set of objects,which brings us to the second key concept:how NSPersistentCloudKitContainerand CloudKit structure these shared objects.

In Core Data,we think of our objects in terms of NSManagedObject.NSPersistentCloudKitContainer turns those managed objectsinto instances of CKRecord that are stored in CloudKit.If you've worked with sharing before,you're probably familiar with hierarchical sharing,where these records are associatedwith a root record called the share.But this isn't howNSPersistentCloudKitContainer works.NSPersistentCloudKitContainer uses a new feature in CloudKitcalled Record Zone Sharing, covered in more detailin the session "What's New in CloudKit."But let's take a look at how NSPersistentCloudKitContaineruses Record Zone Sharing to share managed objects.In a CloudKit database--for example, the .private database--NSPersistentCloudKitContainer typically manages a private zoneto store the objects an application creates.In Record Zone Sharing,shared CKRecords are contained inside a shared CKRecordZone.Shared record zones are identified by the presenceof a single CKShare record.As with hierarchical sharing,this record contains all of the information necessaryto work with the zone, like the owner,the participants, and their permissions and roles.NSPersistentCloudKitContainer manages these zonesand automatically assigns records to them.Because there's no root record,NSPersistentCloudKitContainer also has to understandhow the concepts of owners and participants applyto the entire record zone.

Let's imagine I have a collection of peopleI want to share with.Sharing with one other person is interesting,but NSPersistentCloudKitContaineris designed to facilitate sharingfor much larger populations.Each of these participants will be able to accessand operate on the objects I share with them.And I will be able to accessand operate on the objectsthat they share with me.Each participant will also have their own collectionof devices.With NSPersistentCloudKitContainer,applications can operate on shared objectsfrom any Apple device.For each participant,NSPersistentCloudKitContainermanages objects in two CloudKit databases,the .private and the .shared database.In my .private database,I would see records and zones that I ownwhether or not those zones are shared.For example,the zone thatNSPersistentCloudKitContainer manages.With sharing,NSPersistentCloudKitContainerwill also create shared zones for mewith a CKShare recordthat controls who can access these zones that I own.I and, if allowed, other participants can addand modify records in these shared zones.In my .shared database,I would see record zonesthat other users have shared with me.If I'm allowed to, I can add records that I ownto any of those zonesjust as they can in the zones that I own.

Another user will see a different set of zonesin their .private and .shared databases,depending on whether or not they are the owner of those zones.For example, this user may have a private zoneand a shared zone that they own in their .private database.In addition,they would see my two zones that I share with themand any other zones they are a participant onin their .shared database.So how does NSPersistentCloudKitContainerknow where to keep your records?In many cases,it can infer where records belongbased on the relationship they have to other objects.But you can also tellshare(_ managedObjects: to share: completion:)to store objects in a specific shared zoneby passing it a non-nil CKShare.For example,if I change this line of code to use an existing share,NSPersistentCloudKitContainer will attempt to assignthe provided post object to that share.These are all the changes I had to make for my first demo,but my application also needs to effectively communicatewhat objects are shared, who they're shared with,and what those participants can do.Our users need all of that informationso that they can make good decisionsabout the objects they choose to share.So let's look at how I've changed my applicationto communicate these states and privileges.Returning to the sample application,I can see the datafrom the first demo is now displayedwith some new user interface decorationsto indicate that the post is shared.If I tap on it, I can also see the participantsdisplayed at the bottom of the detail view controllerwith their role, permissions, and acceptance state.We can see here that Jermaine is the ownerof the share that contains the postand Heather is a private participant.Now I'm going to add a new post, give it a title, and tap Done.

I'll tap the Action button to bring up the sharing controller,but this time, I want the share to be read-onlyso that the participants can't edit or modifythe contents of the share.So I'll change the share options to mark the share as View Only.Next, I'll tap Mail and invite Jermaine and Mary.

Finally, I'll send the email.

On Mary's device,I'll accept the new share,and now I can see the new post.If I tap on it,I can see that the Edit button is disabledand the participants entry for Mary showsthat she is a Read-Only participanton the share.Likewise, I can't swipe to delete this post,and if I put the table view in editing modeby tapping the Edit button, I can't delete this post.

On Jermaine's device now, I'll accept the new share.

And now I can see the new post.If I tap on it,I can see that the Edit button is disabledand the participants entry for Jermaine showsthat he is a Read-Only participant on the share.

Even in this humble sample application,I've had to make a number of changes to the user interfaceto present information about shared objects.I had to decorate the post table cellsto indicate which ones are shared.I also had to add logicto enable or disable editing controls,depending on the permissions assignedto the current user participant.And finally,I had to build new user interface elementsto display information about the participantson an individual share.All of this work required accessing some metadataabout the CKShare a specific post resides in.NSPersistentCloudKitContainer includesa number of API methods to align with each of these concerns.fetchShares(matching objectIDs:) is new in iOS 15and allows me to get the CKShare for a specific post.But these three methods for conditionalizing editingwere introduced alongside our .public database supportat WWDC in 2020.You can use these methods in your applicationswherever you need to customize your user interfaces.But in my application, I took a slightly different approach.Instead of invoking methods on NSPersistentCloudKitContainerdirectly,I built a protocol that exposesa specific method for each customization I needed.It's called the SharingProvider.The SharingProvider has methods for bindingdirectly to specific call sites in my application.For example,I might need to know whether or not an object is shared.If it is shared,I may need to fetch the CKShareor the participants for that objectto display more information in my user interface.Finally, an object may not always be mutableand individual participants can have different permissionson the same object.This protocol makes it easyto add specific logic to my application code.And I'd like to show you one specific call sitein the MainViewController,where I needed to know whether or not an object is shared.Here I used isShared to decidewhether or not to convert the title of a postto an attributed string and prefix itwith the person.circle symbolto show that the post is part of a share.Customizations like this necessarily requiremore complicated code than if I chose not to support sharing.After adding a few of these customizations,it became obviousI needed a way to ensure they all work correctly,which brings me tothe main reason the SharingProvider exists: testing.The SharingProvider protocol makes it easyto test these decision points by injection.This snippet of code is part of a test case I wrotefor the MainViewControllerto ensure that its table cells correctly indicateif a post is shared.I left off the scaffolding for creating the sample data,but the test crafts a mixed set of managed objectsthat it identifies as shared or not sharedby the presence of their objectID in this set.Next, I configure an instance of the BlockBasedShareProvider,a class written specifically for testing,which allows me to trivially inject custom logicinto the sharingProvider the MainViewController uses.Here I'm setting the isSharedBlockto call the contains method of the set I created.This is a cute trick in Swift that allows me to simply checkif the provided objectID is in sharedObjectIDs.Then,I set the BlockBasedProvider as the providerfor the view controller, completing the injection.Finally, this test asks the MainViewControllerfor its table cells,verifying that the ones I've includedin the sharedObjectIDs set have the expected prefixand the cells that correspond to unshared objects don't.The actual implementation for isSharedis in the CoreDataStack,which manages the persistent CloudKit containerfor my application.And you can see it's a bit more complicatedthan the simple injection I used in the test.Now, I could go through this implementationline by line,but that's not what's important here.What's important is that it's way more complicatedthan I can easily exerciseevery time I want to verify a change to the table view,and trying to do so would add a lot of frictionto the development process.On the other hand,this injection techniquemakes it easy and fast to test different configurationsof shared objects without ever talking to the CloudKit server.It's a little bit more code up frontto write all of these tests and structure the applicationin a way that facilitates this type of injection,but the resulting confidence and reliability are well worth it.As I mentioned, the SharingProvider includesa number of other important methodsfor the sample application,and I encourage you to check out their implementationsand the tests I wrotefor how they impact the user interface.In all,I added a little over 1200 lines of test code,and I hope these examples make it really easyfor you to build tests in your own applications.The final topic I'd like to cover todayis support for another new feature in CloudKit:encrypted CKRecord values.

These values are stored in a new payload on CKRecordcalled encryptedValues,introduced in the "What's New in CloudKit" session.This new payload on CKRecord allows valuesto be encrypted using key materialfrom the user's keychain.These values are decrypted locally on deviceafter they're downloaded from the CloudKit server,and they're encrypted locally on devicebefore they are uploaded to the CloudKit server.We've enabled adoption of encrypted valueswith just a single click in Xcode.Let's see that in action.

Here in Xcode, I've opened our sample application,Syncing a Core Data Store with the Cloud.I'll open the CoreDataCloudKitDemomanaged object model,and there's a specific property on the post entityI want to show you called location.If I select the location attribute,I can see its configuration in the data model inspectoron the right.I've configured itto be an optional Transformable attributeand checkedthis new Allows Cloud Encryption checkbox.This new checkbox tells NSPersistentCloudKitContainerthat the value for this attributeshould be stored in the encryptedValues payloadof the resulting CKRecord.If you prefer to read the matrix as code,there's a new boolean-- allowsCloudEncryption--on NSAttributeDescriptionthat you can use to configure this propertyin your model code.Now, encryption with CloudKitis an at-introduction time decision.That means we can't change our mind laterand choose to encrypt fieldsthat aren't already encrypted today in production.Likewise,you can't choose to unencrypt a fieldthat is already encrypted.Once the CloudKit schema is pushed to production,we can't change any of the field types.So be sure to use NSPersistentCloudKitContainer'sinitializeSchema methodto ensure that all your fields are presentand correctly typedbefore deploying your schema to production.

It's been my pleasure to introducejust some of the changes we've madeto NSPersistentCloudKitContainer to support sharing.There's a lot of new API to learn about.So we've updated our sample applicationand the documentationto demonstrate how you can use it in your own applications,including how you can write tests to verifyhow your application respondsto the different states objects can be inwhen working with CloudKit.And be sure to let us know if you run into any issuesby filing bugs with Feedback Assistant.As always,I can't wait to see what you buildwith NSPersistentCloudKitContainer.Stay active, close your rings, and have a great WWDC 2021.[music]

5:20 -Add shared store description

6:00 -shareNoteAction, DetailViewController.swift

17:06 -SharingProvider

17:58 -Decorate table cells for shared posts, MainViewController.swift

18:44 -Testing the MainViewController's table view, TestMainViewController.swift

20:01 -CoreDataStack + Sharing, CoreDataStack.swift

## Code Samples

```swift
let
 privateStoreDescription 
=
 container.persistentStoreDescriptions.first
!


let
 storesURL 
=
 privateStoreDescription.url
!
.deletingLastPathComponent()
privateStoreDescription.url 
=
 storesURL.appendingPathComponent(
"private.sqlite"
)
privateStoreDescription.setOption(
true
 
as
 
NSNumber
, forKey: 
NSPersistentHistoryTrackingKey
)
privateStoreDescription.setOption(
true
 
as
 
NSNumber
, forKey: 
NSPersistentStoreRemoteChangeNotificationPostOptionKey
)


let
 sharedStoreURL 
=
 storesURL.appendingPathComponent(
"shared.sqlite"
)

let
 sharedStoreDescription 
=
 privateStoreDescription.copy()
sharedStoreDescription.url 
=
 sharedStoreURL


let
 containerIdentifier 
=
 privateStoreDescription.cloudKitContainerOptions
!
.containerIdentifier

let
 sharedStoreOptions 
=
 
NSPersistentCloudKitContainerOptions
(containerIdentifier: containerIdentifier)
sharedStoreOptions.databaseScope 
=
 .shared
sharedStoreDescription.cloudKitContainerOptions 
=
 sharedStoreOptions
container.persistentStoreDescriptions.append(sharedStoreDescription)
```

```swift
@IBAction
 
func
 
shareNoteAction
(
_
 
sender
: 
Any
)
 {
  
guard
 
let
 barButtonItem 
=
 sender 
as?
 
UIBarButtonItem
 
else
 {
    
fatalError
(
"Not a UI Bar Button item??"
)
  }

  
guard
 
let
 post 
=
 
self
.post 
else
 {
    
fatalError
(
"Can't share without a post"
)
  }

  
let
 container 
=
 
AppDelegate
.sharedAppDelegate.coreDataStack.persistentContainer
  
let
 cloudSharingController 
=
 
UICloudSharingController
 {
    (controller, completion: 
@escaping
 (
CKShare
?, 
CKContainer
?, 
Error
?) -> 
Void
) 
in

    container.share([post], to: 
nil
) { objectIDs, share, container, error 
in

			
if
 
let
 actualShare 
=
 share {
				post.managedObjectContext
?
.performAndWait {
					actualShare[
CKShare
.
SystemFieldKey
.title] 
=
 post.title
				}
			}
			completion(share, container, error)
		}
  }
  cloudSharingController.delegate 
=
 
self


  
if
 
let
 popover 
=
 cloudSharingController.popoverPresentationController {
    popover.barButtonItem 
=
 barButtonItem
  }
  present(cloudSharingController, animated: 
true
) {}
}
```

```swift
protocol
 
SharingProvider
 
{
  
func
 
isShared
(
object
: 
NSManagedObject
)
 -> 
Bool

  
func
 
isShared
(
objectID
: 
NSManagedObjectID
)
 -> 
Bool

  
func
 
participants
(
for
 
object
: 
NSManagedObject
)
 -> [
RenderableShareParticipant
]
  
func
 
shares
(
matching
 
objectIDs
: [
NSManagedObjectID
])
 
throws
 -> [
NSManagedObjectID
: 
RenderableShare
]
  
func
 
canEdit
(
object
: 
NSManagedObject
)
 -> 
Bool

  
func
 
canDelete
(
object
: 
NSManagedObject
)
 -> 
Bool

}
```

```swift
override
 
func
 
tableView
(
_
 
tableView
: 
UITableView
, 
cellForRowAt
 
indexPath
: 
IndexPath
)
 -> 
UITableViewCell
 {
    
guard
 
let
 cell 
=
 tableView.dequeueReusableCell(withIdentifier: 
"PostCell"
, for: indexPath) 
as?
 
PostCell
 
else
 {
        
fatalError
(
"###
\(#function)
: Failed to dequeue a PostCell. Check the cell reusable identifier in Main.storyboard."
)
    }
    
let
 post 
=
 dataProvider.fetchedResultsController.object(at: indexPath)
    cell.title.text 
=
 post.title
    cell.post 
=
 post
    cell.collectionView.reloadData()
    cell.collectionView.invalidateIntrinsicContentSize()
    
    
if
 
let
 attachments 
=
 post.attachments, attachments.allObjects.isEmpty {
        cell.hasAttachmentLabel.isHidden 
=
 
true

    } 
else
 {
        cell.hasAttachmentLabel.isHidden 
=
 
false

    }
    
    
if
 sharingProvider.isShared(object: post) {
        
let
 attachment 
=
 
NSTextAttachment
(image: 
UIImage
(systemName: 
"person.circle"
)
!
)
        
let
 attributedString 
=
 
NSMutableAttributedString
(attachment: attachment)
        attributedString.append(
NSAttributedString
(string: 
" "
 
+
 (post.title 
??
 
""
)))
        cell.title.text 
=
 
nil

        cell.title.attributedText 
=
 attributedString
    }
    
return
 cell
}
```

```swift
func
 
testSharedPostsGetDisclosure
()
 {
    
var
 sharedObjectIDs: 
Set
<
NSManagedObjectID
> 
=
 
Set
()
    
let
 context 
=
 coreDataStack.persistentContainer.viewContext
    
self
.generatePosts(in: context, postSaveBlock: { posts 
in

        
for
 (index, post) 
in
 posts.enumerated() 
where
 (index 
%
 
4
) 
==
 
0
 {
            sharedObjectIDs.insert(post.objectID)
        }
    })
    
    
let
 provider 
=
 
BlockBasedShareProvider
(stack: coreDataStack)
    provider.isSharedBlock 
=
 sharedObjectIDs.contains
    mainViewController.sharingProvider 
=
 provider
    
    
do
 {
        
try
 mainViewController.dataProvider.fetchedResultsController.performFetch()
    } 
catch
 
let
 error {
        
XCTFail
(
"Error while fetching 
\(error)
"
)
    }
    
    reloadTableView()
    
let
 rowCount 
=
 mainViewController.tableView(mainViewController.tableView,
                                                    numberOfRowsInSection: 
0
)
    
XCTAssertEqual
(
100
, rowCount)
    
guard
 
let
 expectedSharedImage 
=
 
UIImage
(systemName: 
"person.circle"
) 
else
 {
        
XCTFail
(
"Failed to get the person system image."
)
        
return

    }
    
    
for
 index 
in
 
0
..<
rowCount {
        
let
 indexPath 
=
 
IndexPath
(row: index, section: 
0
)
        
let
 post 
=
 mainViewController.dataProvider.fetchedResultsController.object(at: indexPath)
        
guard
 
let
 title 
=
 post.title 
else
 {
            
XCTFail
(
"All posts should have been given a title."
)
            
return

        }
        
        
guard
 
let
 cell 
=
 mainViewController.tableView(mainViewController.tableView,
                                                           cellForRowAt: indexPath) 
as?
 
PostCell
 
else
 {
            
XCTFail
(
"Encountered an unexpected cell type in the main view controller's table view."
)
            
return

        }
        
        
if
 sharedObjectIDs.contains(post.objectID) {
            
guard
 
let
 attributedText 
=
 cell.title.attributedText 
else
 {
                
XCTFail
(
"Failed to get the attributed text of 
\(cell)
. Was it not set?"
)
                
return

            }
            
            
guard
 
let
 attachment 
=
 attributedText.attributes(at: 
0
, effectiveRange: 
nil
)[.attachment] 
as?
 
NSTextAttachment
 
else
 {
                
XCTFail
(
"Expected an image attachment at the first character."
)
                
return

            }
            
            
XCTAssertEqual
(expectedSharedImage, attachment.image)
        } 
else
 {
            
XCTAssertEqual
(cell.title.text, title)
        }
    }
}


class
 
BlockBasedShareProvider
: 
SharingProvider
 
{
    
var
 coreDataStack: 
CoreDataStack

    
init
(
stack
: 
CoreDataStack
)
 {
        coreDataStack 
=
 stack
    }
    
    
func
 
isShared
(
object
: 
NSManagedObject
)
 -> 
Bool
 {
        
return
 isShared(objectID: object.objectID)
    }
    
    
public
 
var
 isSharedBlock: ((
_
 object: 
NSManagedObjectID
) -> 
Bool
)
?
 
=
 
nil

    
func
 
isShared
(
objectID
: 
NSManagedObjectID
)
 -> 
Bool
 {
        
guard
 
let
 block 
=
 isSharedBlock 
else
 {
            
return
 coreDataStack.isShared(objectID: objectID)
        }
        
return
 block(objectID)
    }
    
    
public
 
var
 participantsBlock: ((
_
 object: 
NSManagedObject
) -> [
RenderableShareParticipant
])
?
 
=
 
nil

    
func
 
participants
(
for
 
object
: 
NSManagedObject
)
 -> [
RenderableShareParticipant
] {
        
guard
 
let
 block 
=
 participantsBlock 
else
 {
            
return
 coreDataStack.participants(for: object)
        }
        
return
 block(object)
    }
    
    
public
 
var
 sharesBlock: ((
_
 objectIDs: [
NSManagedObjectID
]) -> [NSManagedObjectID: 
RenderableShare
])
?
 
=
 
nil

    
func
 
shares
(
matching
 
objectIDs
: [
NSManagedObjectID
])
 
throws
 -> [
NSManagedObjectID
: 
RenderableShare
] {
        
guard
 
let
 block 
=
 sharesBlock 
else
 {
            
return
 
try
 coreDataStack.shares(matching: objectIDs)
        }
        
return
 block(objectIDs)
    }
    
    
public
 
var
 canEditBlock: ((
_
 object: 
NSManagedObject
) -> 
Bool
)
?
 
=
 
nil

    
func
 
canEdit
(
object
: 
NSManagedObject
)
 -> 
Bool
 {
        
guard
 
let
 block 
=
 canEditBlock 
else
 {
            
return
 coreDataStack.canEdit(object: object)
        }
        
return
 block(object)
    }
    
    
public
 
var
 canDeleteBlock: ((
_
 object: 
NSManagedObject
) -> 
Bool
)
?
 
=
 
nil

    
func
 
canDelete
(
object
: 
NSManagedObject
)
 -> 
Bool
 {
        
guard
 
let
 block 
=
 canDeleteBlock 
else
 {
            
return
 coreDataStack.canDelete(object: object)
        }
        
return
 block(object)
    }
}
```

```swift
extension
 
CoreDataStack
: 
SharingProvider
 
{
    
func
 
isShared
(
object
: 
NSManagedObject
)
 -> 
Bool
 {
        
return
 isShared(objectID: object.objectID)
    }

    
func
 
isShared
(
objectID
: 
NSManagedObjectID
)
 -> 
Bool
 {
        
var
 isShared 
=
 
false

        
if
 
let
 persistentStore 
=
 objectID.persistentStore {
            
if
 persistentStore 
==
 sharedPersistentStore {
                isShared 
=
 
true

            } 
else
 {
                
let
 container 
=
 persistentContainer
                
do
 {
                    
let
 shares 
=
 
try
 container.fetchShares(matching: [objectID])
                    
if
 
nil
 
!=
 shares.first {
                        isShared 
=
 
true

                    }
                } 
catch
 
let
 error {
                    
print
(
"Failed to fetch share for 
\(objectID)
: 
\(error)
"
)
                }
            }
        }
        
return
 isShared
    }
    
    
func
 
participants
(
for
 
object
: 
NSManagedObject
)
 -> [
RenderableShareParticipant
] {
        
var
 participants 
=
 [
CKShare
.
Participant
]()
        
do
 {
            
let
 container 
=
 persistentContainer
            
let
 shares 
=
 
try
 container.fetchShares(matching: [object.objectID])
            
if
 
let
 share 
=
 shares[object.objectID] {
                participants 
=
 share.participants
            }
        } 
catch
 
let
 error {
            
print
(
"Failed to fetch share for 
\(object)
: 
\(error)
"
)
        }
        
return
 participants
    }
    
    
func
 
shares
(
matching
 
objectIDs
: [
NSManagedObjectID
])
 
throws
 -> [
NSManagedObjectID
: 
RenderableShare
] {
        
return
 
try
 persistentContainer.fetchShares(matching: objectIDs)
    }
    
    
func
 
canEdit
(
object
: 
NSManagedObject
)
 -> 
Bool
 {
        
return
 persistentContainer.canUpdateRecord(forManagedObjectWith: object.objectID)
    }
        
    
func
 
canDelete
(
object
: 
NSManagedObject
)
 -> 
Bool
 {
        
return
 persistentContainer.canDeleteRecord(forManagedObjectWith: object.objectID)
    }
}
```


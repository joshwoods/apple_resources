# Wwdc2021 10225

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Coordinate media experiences with Group ActivitiesDiscover how you can help people watch or listen to content all in sync with SharePlay and the Group Activities framework. We'll show you how to adapt a media app into a synchronized, SharePlay-enabled experience for multiple people. Learn how to add Group Activities to your app, explore the Picture in Picture layout, and find out how the playback coordinator object can help you fine-tune playback across multiple devices.ResourcesGroup ActivitiesSupporting Coordinated Media PlaybackHD VideoSD VideoRelated VideosWWDC22Make a great SharePlay experienceWWDC21Build custom experiences with Group ActivitiesCoordinate media playback in Safari with Group ActivitiesExplore dynamic pre-rolls and mid-rolls in HLSMeet Group Activities

Discover how you can help people watch or listen to content all in sync with SharePlay and the Group Activities framework. We'll show you how to adapt a media app into a synchronized, SharePlay-enabled experience for multiple people. Learn how to add Group Activities to your app, explore the Picture in Picture layout, and find out how the playback coordinator object can help you fine-tune playback across multiple devices.

Group Activities

Supporting Coordinated Media Playback

HD VideoSD Video

HD Video

SD Video

Make a great SharePlay experience

Build custom experiences with Group Activities

Coordinate media playback in Safari with Group Activities

Explore dynamic pre-rolls and mid-rolls in HLS

Meet Group Activities

Search this videoâ€¦G'day.Welcome to the session, "Coordinate media experienceswith Group Activities."My name is Hayden, and I'm an engineeron the Group Activities team here at Apple.Today, we will talk about how to create synchronized media appsthat give users the ability to watchand listen to content together across devices.The goal is for your users to feelas if they were physically together, wherever they may be.The GroupActivities API is a Swift frameworkfor creating shared experiences.It takes care of coordinating media for you, via APIsfor playback coordination and group session management.And it is supported across a wide range of Apple platforms,such as iOS, iPadOS, macOS, and tvOS.Let's start off with a demo of the GroupActivities API,by calling my colleague, Moritz, and sharing a videofrom the sample app attached to this talk.Let's see if Moritz is available.Hi, Moritz!Hey, Hayden!I'm gonna home out and open the sample app.You can see it's a list of drone footage from Apple Park.I'm gonna show the theater footage to Moritz.How does that look, Moritz? Do you wanna watch it?That looks great. I really love that one.But did you see the new one I uploadedlast week from the rings?Oh, it looks great!I'm gonna start playback,and our videos will be in sync across our devices.You can see if I pause, it'll also pause for Moritz.And if he moves ahead, it'll also move ahead for me.Looks awesome. OK, thanks, Moritz!Yeah, that was great. Bye, Hayden.There are three main pieces that you needto think about when creating a coordinated media playback app.First is implementing the new GroupActivities API.Second is how you can take advantage of picture-in-pictureto make sharing your experiences as seamless as possible.And third, my colleague, Moritz, will do a deep diveinto how playback coordination worksand the features of the new playback coordination object.Let's familiarize ourselves with the GroupActivities APIby looking at the life cycle of a GroupActivities app.Here, we have two iPhones in a FaceTime call,just like in the first demo.My device is on the left,and my colleague, Moritz's is on the right.On my device, I open the shared app.In the app, I then share an activity to the group.The GroupActivities framework creates a session objectfor the activity, and then delivers it to my app.Meanwhile, the session object is shared to Moritz, wherethe framework handles opening the same app on his device.Finally, the framework passes Moritz's app the GroupSession.Now, we have two apps able to communicateover the same GroupSession.Now, let's look at the steps you needto take in order to adopt the GroupActivities framework.The first step is creating a GroupActivityalong with its metadata.So, let's talk about what a GroupActivity isand how you define it.GroupActivity is a Swift protocol that representsthe item that your users are experiencing together.This will be a single piece of content,like a movie or a song.You should include any properties on this typethat you need to set up your experience.For example, you may want to include the URL to a video here,so you can load a video in preparation for the session.In order for the framework to send the dataover the network, it conforms to Codable.This means your properties must also conform to Codable.You'll notice there are two required properties.ActivityIdentifier is a unique type identifierso the system knows how to reference this activity.GroupActivityMetadata contains information to showthis activity in system UI on the remote device.You'll notice this is an example of the new async effectfulread-only properties feature that is being introducedwith Swift Concurrency this year.For more information see the session,"Meet async/await in Swift" at WWDC this year.So, you've defined a GroupActivity.Now, you wanna share it to the callby calling the activate method on your GroupActivity.When you activate a GroupActivity,the framework creates a GroupSession object,which is delivered to both the local and remote devices.The system is in charge of launching the app,and system UI will show the activity metadata.But first, there's something we glossed over.How does your app know that you're in a FaceTime call?And what if, when a user selects a pieceof content, they don't mean to share it to the group,and instead just wanna view it locally?The PrepareForActivation function solves these problemsfor you, by letting the system work out the user intent.Here's an example of the prepareForActivation API.In the switch statement, there are three caseswe need to handle.The first, activationDisabled, will be taken when the useris not in a FaceTime call, or the system has decidedthat they wish to consume it locally.The second, activationPreferred, will be takenwhen the user is in a FaceTime call,and they wish to share it to the group.Canceled is taken when the user cancels the share action.This is already enough knowledge to create a GroupActivities appthat shares an activity.So, let's jump over to Xcode,and I'll show you it in practice.Before we add GroupActivities support,I'll give a quick run through of the project.It's a simple movie-watching appthat lets you select a movie and watch it.It consists of a list of movies to watch,along with a movie detail page to show you the video player.Right now, the app only lets you watchmovies alone, so let's change that.You'll notice we have the Group Activity entitlement set.And then, we'll add a GroupActivity to Movie.swift.First thing to do is import GroupActivities.And then, we'll add the GroupActivity,MovieWatchingActivity.You'll notice it has a movie property,and it uses that property to fill in the metadata.Let's share this activity now.We'll go to the CoordinationManagerand find the prepareToPlay function.Currently, this function starts playbackimmediately by enqueueing the movie.Instead, we'll replace thiswith our prepareForActivation functionthat we showed in the slides.You can see we immediately enqueue the moviein the activationDisabled case.And activate() is called when the user wants to share itto their FaceTime call.Later in the talk, we'll enqueue the movie to start playback,but for now, let's see what happens if we run the app as-is.I've grabbed Moritz's device, and I've started a FaceTime callbetween the two iPhones.I'll home out and then launch the sample app on my phone.I'll share the rings video we watched earlierand launch the app on Moritz's device.You can see that it received the GroupActivity.However, it didn't load the correct video,and there's no playback synchronization.So, let's learn how to add that into the app now.The main thing to learn about receiving a Group Activityis the GroupSession objectand the way you receive a GroupSession,the GroupSessions async sequence.Here's a high-level diagramshowing the typical GroupSession life cycle.Both the local and remote devices receive a group session.The app should then set up in preparation for playback.And finally, when ready, join the group session.The GroupSession is the object that representsthe realtime session between devices of a group activity.It provides state about the session, suchas the latest group activity, the connection state, andthe set of active participants connected to the session.As we'll see in a moment,it's also used for synchronizing playback.The GroupSession AsyncSequencedelivers GroupSessions to your app.Your app never instantiates a GroupSession object directly,so this is the only way to receive GroupSessions.It's important to note that you shouldget the latest GroupSession from this sequence,on both the local and remote devices.AsyncSequence is covered in the Swift Concurrency talkmentioned earlier.Here's what awaiting on the GroupSessionsAsyncSequence looks like in code.When a GroupActivity is activated,the system will return a GroupSessionfrom the AsyncSequence into your await loop.Now that we've received a GroupSession, let's learnhow to use it to set up playback synchronization.This latest release of AVFoundationintroduces a new type called AVPlaybackCoordinator.Moritz will give more information on this objectlater in the talk, but for now, I'll show you howto attach a GroupSession to the playback coordinator,which will enable synchronized playback.The way to access the playback coordinator isby the playbackCoordinator property on AVPlayer.Then, to attach the groupSession to the coordinator,we call coordinateWithSession and pass in the GroupSession.And that's it.Under the hood, the framework handles all the intricaciesof playback coordination and realtime networking for you.There's one final step to session management,and that's finally joining the session.Initially, a GroupSession is not connectedand is instead in a "waiting" state.Calling "join()" connects the GroupSession to the groupand begins the realtime connection, allowing messagesto be sent and received from other devices in the group.Once the GroupSession has successfully joined,playback synchronization will begin.Let's add this session management codeto our sample app.In CoordinationManager,let's add the session's async sequence in an await loop.Remember, this gives your app GroupSessions when they've beenactivated from either the local or remote devices.Let's store this groupSession on the CoordinatorManager,which will propagate the changeover to our MoviePlayerViewController.Once set, we'll attach the session object to our AVPlayervia playbackCoordinator .coordinateWithSession.Then, back in our await loop,we'll get the movie from the session object.Since the activity can change throughout the session,we use a Combine publisher to get the activity.Then, we enqueue a movie to start playback.And finally, we join the session.Now that we've set up the code to receivea GroupSession and sync playback,let's run the app on our devices and see what happens.Again, the two devices are in a FaceTime call,and on the first device, I'll open the sample appand share the rings video.You can see Moritz's device receivedthe Group Activity, so we'll launch the app.And this time, both devices show the right video.Then, if I press "play,"we can see that playback synchronization works.And if I pause on one, it'll pause on the other.Or I can move ahead, and it'll move ahead on both.And playback is in perfect sync.One final thing to note about GroupSession ishow the session is finished.There are two ways to finish a GroupSession.The first is leave().This disconnects the local user from the session,but leaves the session activefor the remaining participants in the call.The second is end().This ends the session, not justfor the local participant, but for the entire call.For extra details on creating advanced GroupActivities apps,see the following WWDC session,"Build custom experiences with Group Activities."It covers how to change the activity of a GroupSession,observe state of a GroupSession, and how to use advancedfeatures, such as the GroupSessionMessenger,which lets you send arbitrary messages between the group.I highly recommend it.Let's switch gears and look at how you can take advantageof picture-in-picture to make sharing a video GroupActivityas seamless as possible.Why is picture-in-picture worth thinking aboutfor GroupActivities apps?Well, supporting picture-in-picture allowscontent to start playing instantly after being shared.Since it doesn't take a user out of their current context, thereis no need for an explicit user interaction to start playback.This saves your users an extra step and resultsin a frictionless experience to share content.For more information on setting up picture-in-picture,see the 2019 WWDC sessionon "Delivering Intuitive Media Playback with AVKit."However, there are some nuances in how picture-in-picture workswith GroupActivitities, so let's go over them now.The GroupActivities framework will deliver sessionsto your media app while in background,to give your app a chance to set up picture-in-picture.If the GroupSession indicates playback can startin the background, you should set uppicture-in-picture, and then go throughthe regular GroupActivities flow.The system will start playing the contentin picture-in-picture without launching the app in fullscreen,so users get that seamless experienceand aren't taken out of their current context.But in some cases, you won't be ableto set up picture-in-picture because you may need the userto sign in to your app, or the content might notbe available without some additional steps from the user.For these cases, GroupSession provides APIsfor your app to request to be foregrounded.Another handy thing we've built into picture-in-pictureis that it handles leaving and ending a GroupSession for you,via a system dialog, so there's no need to worry about leavingor ending a session when picture-in-picture is active.And now, I'll pass it over to my colleague,Moritz, to do a deep diveon the playback coordinator object.Hello, my name is Moritz Wittenhagen,and I am an engineer on the AVFoundation team.Hayden has introduced you to AVPlaybackCoordinatoras an object that automatically keeps playback on multipledevices in sync, and we've seen it working in the demo.In this part of the talk, I am going to demystifywhat the coordinator actually does under the hoodand how it interacts with your code.For the most part, I will focus on how the coordinator interactswith AVPlayer, how you should selectyour assets for coordinated playback, how individualparticipants can suspend coordination temporarily,and I will also give you a brief insight into howto implement coordination when not using AVPlayer.AVPlaybackCoordinator is an objectthat shares playback state across devices,and it coordinates playback start across those devices,with the goal of no one missing any content.There are two subclasses of the coordinator.An instance of AVPlayerPlaybackCoordinatoris always tied to a particular AVPlayer,and it handles all remote state management for you.This makes it the easiest way to jump into coordinatedplayback, and I highly recommend you start here.We are not going to talk muchabout AVDelegatingPlaybackCoordinator,but this subclass gives you the flexibility to controlany other playback objects that aren't an AVPlayer.Let's look at our device setup again.For the rest of the talk, we are going to representthe GroupActivities objects through the GroupSession.We also assume that your UI presents an AVPlayer playingsome AVPlayerItem, and this is where the newAVPlayerPlaybackCoordinator comes in.When you call coordinator coordinateWithSession,as Hayden showed earlier, we have effectively connectedthe two AVPlayers, and they start to affect each other.The basic rule is the coordinatorwill intercept any transport control API,so any API that changes rate or current time.It takes those commands, figures out if it needs to coordinatethem with someone else, and then, at the appropriate time,lets them take effect on the AVPlayer.Let's look at an example.Here, Hayden and I are in a GroupSession together,and because the GroupActivity told us which URL to load,have enqueued the same AVPlayerItem.Now, if my device changes the AVPlayer's rate property,the playback coordinator will intercept that commandand not immediately allow the player to start playback.Instead, it will ask the playerto enter a timeControlStatus of WaitingToPlayAtSpecifiedRate.UIs will typically represent this timeControlStatuswith a waiting spinner.The coordinator will then send the commandover to Hayden's iPad.The AVPlayerPlaybackCoordinator there receives the commandand similarly asks Hayden's AVPlayerto change rate and enter a waiting state.The coordinators give everyone some time to preparefor playback with the goal of everyone starting playbackat the same time without missing any content.When everyone is good to go, all devices begin playback together.All coordinators in the session are equal,meaning that Hayden can also initiate a command.Let's have him seek this time.Again, the seek API is intercepted,and the coordinator forces the AVPlayer to waitwhile it shares the command with connected coordinators.Everyone is given some time to complete the seek,and when all devices are ready to go again,playback resumes for everyone together.You may ask yourself, what happens when the AVPlayersare playing different items?And the answer is that the coordinatoronly applies state to the other playerwhen both players are playing identical content.I will elaborate on the concept of identity later.For now, think that content is identicalwhen you create the items from the same URL.What this means is that any command you send for item A willonly be applied if the receiver is also playing item A.And changing the item to B will ignore all state from item A.We do this because distinguishing commandsper-item allows for safe joining of participantsand transitions between items.Let me show you what I mean.Here's our example again, but this time,we start with Hayden already playing.As I join and connect my playback coordinatorto the same session, nothing happens to my AVPlayer,because I am not playing the same current item as Hayden.Even creating that same item has no impactbecause the item is not current in my player.This means that I can even seek the itemwithout consequences for anyone else.Only when the item becomes currentin the AVPlayer will the coordinator startdoing its work and try to apply the right state.The rule is that the coordinator always startswith the group state, if there is one.And since Hayden was already playing in the GroupSession,the coordinator prefers his stateover my own configuration from before enqeueuing the item.This means that my coordinator will override any configurationin the AVPlayer and AVPlayerItem to match Hayden's device.And with that, we are both in the same stateand can play together.Let's repeat this with an item transition.As we both approach the end of item A,my AVQueuePlayer is getting ready to play the next item.Usually, we would expect Hayden to get ready, as well,but for this example, let's assume Hayden's iPadis in a bad network and cannot load the next item yet.So, now that I'm at the end of item A,I already have item B enqueued, and it is ready to play.But because the item is not current,the coordinator is not doing anything yet.Only when my player transitions to the new item,will the coordinator do its job again.And this time, it does not find an existing statefor item B, so it just continueswith the state my player is proposing.Even though the coordinator sharesthis new state with Hayden, he is not affectedbecause he is still displaying item A.But when he eventually transitions to match my item,his coordinator will again apply the existing stateto his player.And with that, everyone is playing in sync again.After all this, here is my first call-to-action.Be careful about the order of your item changesand transport control commands.Let's say we have a function beginPlaybackthat enqueues an item and automatically starts playing.This code would be called whenever the userhas selected something to playor when our GroupSession informs us of a new activity.It is important that we seek to our start time first,and similarly, we should change player ratebefore the item is enqueued so that our initialconfiguration cannot affect anyone else.If we do it in this order, the playback coordinator candecide if we are first and our state should be sharedwith everyone else, or if another state alreadyexists, and that should override our state instead.Also, audit your transport control commands and considerif they should affect everyone in the group.Usually, an API call should affectthe group if it originates from playback UI.So if the user pauses, everyone else should pause, too.In that case, just call the AVPlayer API as usual.So, what should we dowith the other API calls not coming from playback UI?Usually, these are automated pausesbecause your app has encountered some system event.Automatic pauses like this shouldnot usually affect the other participants.In such a situation, where your users are playing togetherwith others, you should first consider not pausing at all.Since everyone else continues to play, users will often preferto stick with the group, even if it has some kind of drawback,like not being able to see the content temporarily.If you have no other choice but to pause, you have two options:remove the item first, or begin a coordinated playbacksuspension, which I will cover later in this talk.Now that you have an idea of how the playback coordinator works,let's talk about content for coordinated playback.As I stated previously, we consider two player itemson different devices to be the samewhen their assets were created from the same URL.While this default can work well, there are situationswhere you want to change this behavior.For example, your app may offer the usera choice to download and cache the content on device.So, if I have downloaded the asset to my local cache,and Hayden is still streaming the content from the cloud,we are no longer using the same URL, meaning the playbackcoordinator will not keep our playback states in sync.Similarly, some of you may have exciting use casesfor coordinating the state of AVMutableMovies orAVCompositions, which don't have a URL representation at all.Again, the playback coordinator does not know what to do here.To solve this problem, you can provide a custom stringas an identifier for an AVPlayerItem.If this string is present, the coordinator will use itto decide if two items represent the same content,and it will ignore the URL.You do this by implementing the AVPlayerPlaybackCoordinatorDelegate protocol and its playbackCoordinatoridentifierFor playerItem function.The coordinator will ask its delegate for an identifierwhenever you enqueue an item in the player.Whenever the playback coordinator considerstwo items equal, it is important that a timeon one device matches the same time on the others.This means that you need to be carefulwith content that is automatically injectedinto the playback stream by a server.So, if Hayden and I request the same URL,but the server decides to inject an ad into only my stream,the devices are now out of sync, as I play into the ad,and Hayden continues with the main content.The right way to approach this problem is to move adsand other interstitials into a separate player.That leaves the main asset unaffected.Now, as I play into the ad, my phone switchesto a different player for the duration of the ad.And when the ad is over, the coordinator can easilyrejoin everyone else's timing, and we are back in sync.If you are playing HLS content, AVPlayer will be able to helpyou with this through the new AVPlayerInterstitialEvent API.Check out the dynamic pre-roll and mid-rollsin HLS talk to learn more.In summary, use custom identifiers to matchcontent if the URL does not cover the right information.Make sure times are the same for everyone.And if you want to play personalized interstitials,play them through a different player,so that your main content is not affected.And finally, use date tags when coordinatinglive content so that the coordinatorcan share the correct timing with everyone else.So far, we have only dealt with the perfect playback cases,where everyone can stay in sync the whole time.Unfortunately, that is not always possible.Let's say Hayden and I are playing together,but an alarm goes off telling me to feed my cat, Zorro.By the rules of AVAudioSession, my app must now pause,and those rules still apply, even when playing in a group.Yet, we do not want my pause to affect everyone else.Forwarding everyone's little pauses to the whole groupwould just cause too many annoyances.So, instead, we want Hayden's iPad to continue playing.And when I dismiss my alarm, playback should catch up,and everyone should play in sync again.So, how can we implement behavior like this?You use a new objectcalled an AVCoordinatedPlaybackSuspension.Such a suspension represents a separationbetween one participant's coordinatorand the other participants' coordinators.The participant is separate from the group,and player rate changes or seeks no longer affect anyone else.Similarly, any rate change comingfrom the group will not change the AVPlayer's rate or time.In the example, this means that itis not possible for Hayden to startmy player while the alarm is still playing.There are two different kinds of suspensions:automatic suspensions and suspensions you add yourself.Automatic suspensions are added by AVPlayerPlaybackCoordinatorwhen the player pauses automatically.We already saw the example of the audiosession interruption, but this also appliesto network stalls or playing an interstitialthrough the new AVPlayer interstitial API.Suspensions added by the playback coordinatorend when the player resumes playback, and it causesthe player to match timing to the current group state.For our example, this means that I willautomatically rejoin the group when my player rate changes backto one after my app handled the end-interruptionnotification from dismissing the alarm.Let me show you two examples of how the system usescoordinated playback suspensions.Here is our sample app playing drone footage of the rings.Let's look at the interruption example we discussed before.I have set a timer to go off in a few seconds,so let's wait for that.Ah, here we go.This has paused the iPad on my left, but as you can see,the other device is still happily playing.And as I dismiss the timer, playback on the deviceon the left jumps forward to rejointhe other device and is perfectly in sync.This is not the only way the system makes useof suspensions.AVKit uses them to keep random video framesfrom flashing in front of everybody during scrubbing.You may have noticed already that scrubbing willshow intermediate frames only on the devicethat I'm interacting with.So, as I touch the scrubber,the device on the right continues playing,while the left device shows the scrubbing frames.Only when I let go of the scrubberwill the new time be shared with the other device,and playback resumes for everyone.These are examples of how the system uses suspensions.Now, let's look at how you would adopt one yourself.So, let's jump into Xcode and actually do that.Let's say you wantedto implement a feature that allows one participantto rewatch something they just missed.Maybe there was a particularly exciting momentin the drone footage we are watching.With all the coordinator behaviors we discussed so far,seeking back and playing again will affect everyone.And I want to emphasizethat this may very well be the right thing to do.Try to keep your users together as much as possible.But let's say seeking back for everyone is not an option.So, what we will build instead is a way to seek backby a few seconds and play the content at twice the speeduntil we join back up with everyone.I have already added a button in my UI that a usercan use to indicate that they missed something.It is hooked up with this functionin our MoviePlayerViewController.Let's fill that in.Here is just the player logic.We figure out what time to seek to,seek back, and set the player rate to 2.When we have caught up, we just resume playback at rate 1.So far, this would all happen to everyone becausethe playback coordinator will intercept those API calls.This is where the suspensions come in.Right before we seek back,I want to separate our player from everyone else.And we do that with the coordinator'sbeginSuspension function.It requires a reason, and to provide that reason,we just extend the Reason struct with a new string constant.In this case, what-happened.Now, we can use that in our beginSuspension call.Since the coordinator is now suspended, we can safely seekand set the rate, just for our player.Once we are ready to meet up with everyone else,we need to signal to the coordinator to listento the group again, so we callsuspension.end().Note that we don't actually need the player rate change anymore.Since ending the suspension will alwaysrejoin everyone else, our player rate change wouldalso change back to whatever the current group rate is.Now, let's try this out.Everyone plays together.I miss an exciting event, like the approach to the ring,and I tap our new what-happened button.So, you can see, the device I'm interacting withjumps back to repeat the content.It plays faster to catch up,while the other device is not affected.And now, we are already perfectly in sync again.So, when you begin a suspension on an AVPlaybackCoordinator,you separate its player from the group,and it is now safe to issue any rate changeor seek without affecting anyone else.Ending the suspension willrejoin the group's current time and rate.And, new on this slide, you can optionally proposea new time to the group when ending the suspension.This is how you can implement a scrubbing suspensionthat changes time for everyone onlywhen letting go of the playback control.Here is a summary of when AVPlayer transport controlcommands are actually shared with other participants.First, you have to connect the AVPlayerPlaybackCoordinatorto other participants through a group session,as Hayden showed you at the beginning of the talk.Second, the AVPlayer's current AVPlayerItem must havethe same URL as the other participants' player items.Or if you're providing your own identifiers,they must have the same custom identifier.Once an item is enqueued, all seeks and rate changesaffect everyone in the group,except when you begin a coordinated playback suspension.And to close out the discussion of AVPlayerPlaybackCoordinator,here's a quick tour of other API related to coordinated playback.If you want other participants to waitduring one user's suspension,you can configure this using the coordinator'ssuspensionReasons ThatTriggerWaiting property.This is how you could request that no one misses any contentif participants have different length ads.To learn more about the state of other participants,take a look at the coordinator's otherParticipants propertyand its corresponding notification.The AVCoordinatedPlaybackParticipantmost notably gives you the list of suspensionReasons,which may be useful to inform UI,especially if you use suspension ReasonsThatTriggerWaiting above.Whenever the coordinator requests its AVPlayer to wait,that is reflected in the players reasonForWaitingToPlay,with the new waiting ForCoordinatedPlayback reason.To override waiting and immediately start playback,regardless of the other participants' states,use the player's playImmediately atRate function.Note that this can cause other participants to miss content,so be aware of that when using this API.AVPlayer also has a new rateDidChangeNotification,which provides more information about the rate change,including when another participant caused it.And similarly,AVPlayerItem's TimeJumpedNotificationwill also tell you if a time jump originatesfrom another participant.There is some AVPlayer API you cannot usewith AVPlayerPlaybackCoordinator.The default time pitch algorithm on iOS used to below quality zero latency.This value is now deprecated in iOS 15.LowQualityZeroLatency is not supportedfor coordinated playback, and you should watch outfor code resetting to this now-deprecated value.Use one of the other algorithms instead.Also, do not useAVPlayer's setRate(time:atHostTime:)function with an AVPlayerPlaybackCoordinatorbecause it is vital that the playback coordinateris in charge of player timing,which is incompatible with external startup sync.After all this talk about AVPlayer,let's quickly dip into the second subclassof AVPlaybackCoordinator, AVDelegatingPlaybackCoordinator.A lot of the concepts that we discussed still applyfor delegating playback coordinator, but insteadof observing the player for you, the delegating coordinatorrequires you to provide information about playback stateand apply state to your playback objects yourself.A custom playback object setup will look something like this.Your UI controls the player, which uses one of the othersystem-rendering APIs underneath.The delegating playback coordinator fitsin between your UI and your player implementation.As the name suggests, AVDelegatingPlaybackCoordinatorrequires you to implement a delegate protocolthat receives playback commands for playing,pausing, seeking, and buffering.Instead of sending a play command to your player directly,your UI would tell the coordinator first.The coordinator will then decide if it needsto first negotiate with other connected players,before changing your playback object's time or rate.You also have to tell the coordinator wheneveryour player transitions to a new current item,so that the coordinator knows which commands to send to you.As before, items are identified by arbitrary strings.When the coordinator sends a command, it shouldaffect the originating UI, as well as the receiver UI.And when it is time to play,it should affect all players in the same way.It is your responsibility to make your playback objectfollow along and to update your UIfor commands appropriately.I want to specially call out that the delegating coordinatorwill often tell you to begin buffering,even if your device is already ready to go.This means the coordinator is still waiting for otherconnected participants, and your UI should reflect that,even if there is nothing to do on your end.Final words of warning.Be careful with events like route changesthat briefly pause and resume your player.It is your responsibility to stick to the requested timingand reapply the group timing as needed.If you cannot keep up for whatever reason,you should communicate that to the coordinatorusing a suspension.The delegating playback coordinatoralso does not add any automatic suspensions.This means you should begin and end suspensionsfor relevant system events yourself.Use the reasons provided by AVFoundationwhere appropriate.And it is possible to connect a delegating playbackcoordinator on one device to a player playback coordinatoron another, but you must use custom identifierson the player playback coordinator end.Let's wrap up.To build a coordinated media playback app,use a GroupActivity to define the content you areplaying and to propose it to the group.Start to keep track of GroupSessions as soonas your app launches to learn when your usersare in a FaceTime call and want to play together.And finally, connect the playback coordinatorto your GroupSession to keep your contentin sync for everyone.Thank you, and enjoy the rest of WWDC.[music]

G'day.Welcome to the session, "Coordinate media experienceswith Group Activities."My name is Hayden, and I'm an engineeron the Group Activities team here at Apple.Today, we will talk about how to create synchronized media appsthat give users the ability to watchand listen to content together across devices.The goal is for your users to feelas if they were physically together, wherever they may be.The GroupActivities API is a Swift frameworkfor creating shared experiences.It takes care of coordinating media for you, via APIsfor playback coordination and group session management.And it is supported across a wide range of Apple platforms,such as iOS, iPadOS, macOS, and tvOS.Let's start off with a demo of the GroupActivities API,by calling my colleague, Moritz, and sharing a videofrom the sample app attached to this talk.Let's see if Moritz is available.Hi, Moritz!Hey, Hayden!I'm gonna home out and open the sample app.You can see it's a list of drone footage from Apple Park.I'm gonna show the theater footage to Moritz.How does that look, Moritz? Do you wanna watch it?That looks great. I really love that one.But did you see the new one I uploadedlast week from the rings?Oh, it looks great!I'm gonna start playback,and our videos will be in sync across our devices.You can see if I pause, it'll also pause for Moritz.And if he moves ahead, it'll also move ahead for me.

Looks awesome. OK, thanks, Moritz!Yeah, that was great. Bye, Hayden.There are three main pieces that you needto think about when creating a coordinated media playback app.First is implementing the new GroupActivities API.Second is how you can take advantage of picture-in-pictureto make sharing your experiences as seamless as possible.And third, my colleague, Moritz, will do a deep diveinto how playback coordination worksand the features of the new playback coordination object.Let's familiarize ourselves with the GroupActivities APIby looking at the life cycle of a GroupActivities app.Here, we have two iPhones in a FaceTime call,just like in the first demo.My device is on the left,and my colleague, Moritz's is on the right.On my device, I open the shared app.In the app, I then share an activity to the group.The GroupActivities framework creates a session objectfor the activity, and then delivers it to my app.Meanwhile, the session object is shared to Moritz, wherethe framework handles opening the same app on his device.Finally, the framework passes Moritz's app the GroupSession.Now, we have two apps able to communicateover the same GroupSession.Now, let's look at the steps you needto take in order to adopt the GroupActivities framework.The first step is creating a GroupActivityalong with its metadata.So, let's talk about what a GroupActivity isand how you define it.GroupActivity is a Swift protocol that representsthe item that your users are experiencing together.This will be a single piece of content,like a movie or a song.You should include any properties on this typethat you need to set up your experience.For example, you may want to include the URL to a video here,so you can load a video in preparation for the session.In order for the framework to send the dataover the network, it conforms to Codable.This means your properties must also conform to Codable.You'll notice there are two required properties.ActivityIdentifier is a unique type identifierso the system knows how to reference this activity.GroupActivityMetadata contains information to showthis activity in system UI on the remote device.You'll notice this is an example of the new async effectfulread-only properties feature that is being introducedwith Swift Concurrency this year.For more information see the session,"Meet async/await in Swift" at WWDC this year.So, you've defined a GroupActivity.Now, you wanna share it to the callby calling the activate method on your GroupActivity.When you activate a GroupActivity,the framework creates a GroupSession object,which is delivered to both the local and remote devices.The system is in charge of launching the app,and system UI will show the activity metadata.But first, there's something we glossed over.How does your app know that you're in a FaceTime call?And what if, when a user selects a pieceof content, they don't mean to share it to the group,and instead just wanna view it locally?The PrepareForActivation function solves these problemsfor you, by letting the system work out the user intent.Here's an example of the prepareForActivation API.In the switch statement, there are three caseswe need to handle.The first, activationDisabled, will be taken when the useris not in a FaceTime call, or the system has decidedthat they wish to consume it locally.The second, activationPreferred, will be takenwhen the user is in a FaceTime call,and they wish to share it to the group.Canceled is taken when the user cancels the share action.This is already enough knowledge to create a GroupActivities appthat shares an activity.So, let's jump over to Xcode,and I'll show you it in practice.Before we add GroupActivities support,I'll give a quick run through of the project.It's a simple movie-watching appthat lets you select a movie and watch it.It consists of a list of movies to watch,along with a movie detail page to show you the video player.Right now, the app only lets you watchmovies alone, so let's change that.

You'll notice we have the Group Activity entitlement set.And then, we'll add a GroupActivity to Movie.swift.First thing to do is import GroupActivities.

And then, we'll add the GroupActivity,MovieWatchingActivity.You'll notice it has a movie property,and it uses that property to fill in the metadata.Let's share this activity now.We'll go to the CoordinationManagerand find the prepareToPlay function.Currently, this function starts playbackimmediately by enqueueing the movie.Instead, we'll replace thiswith our prepareForActivation functionthat we showed in the slides.

You can see we immediately enqueue the moviein the activationDisabled case.

And activate() is called when the user wants to share itto their FaceTime call.Later in the talk, we'll enqueue the movie to start playback,but for now, let's see what happens if we run the app as-is.I've grabbed Moritz's device, and I've started a FaceTime callbetween the two iPhones.I'll home out and then launch the sample app on my phone.I'll share the rings video we watched earlierand launch the app on Moritz's device.You can see that it received the GroupActivity.However, it didn't load the correct video,and there's no playback synchronization.So, let's learn how to add that into the app now.The main thing to learn about receiving a Group Activityis the GroupSession objectand the way you receive a GroupSession,the GroupSessions async sequence.Here's a high-level diagramshowing the typical GroupSession life cycle.Both the local and remote devices receive a group session.The app should then set up in preparation for playback.And finally, when ready, join the group session.The GroupSession is the object that representsthe realtime session between devices of a group activity.It provides state about the session, suchas the latest group activity, the connection state, andthe set of active participants connected to the session.As we'll see in a moment,it's also used for synchronizing playback.The GroupSession AsyncSequencedelivers GroupSessions to your app.Your app never instantiates a GroupSession object directly,so this is the only way to receive GroupSessions.It's important to note that you shouldget the latest GroupSession from this sequence,on both the local and remote devices.AsyncSequence is covered in the Swift Concurrency talkmentioned earlier.Here's what awaiting on the GroupSessionsAsyncSequence looks like in code.When a GroupActivity is activated,the system will return a GroupSessionfrom the AsyncSequence into your await loop.Now that we've received a GroupSession, let's learnhow to use it to set up playback synchronization.This latest release of AVFoundationintroduces a new type called AVPlaybackCoordinator.Moritz will give more information on this objectlater in the talk, but for now, I'll show you howto attach a GroupSession to the playback coordinator,which will enable synchronized playback.The way to access the playback coordinator isby the playbackCoordinator property on AVPlayer.Then, to attach the groupSession to the coordinator,we call coordinateWithSession and pass in the GroupSession.And that's it.Under the hood, the framework handles all the intricaciesof playback coordination and realtime networking for you.There's one final step to session management,and that's finally joining the session.Initially, a GroupSession is not connectedand is instead in a "waiting" state.Calling "join()" connects the GroupSession to the groupand begins the realtime connection, allowing messagesto be sent and received from other devices in the group.Once the GroupSession has successfully joined,playback synchronization will begin.Let's add this session management codeto our sample app.In CoordinationManager,let's add the session's async sequence in an await loop.

Remember, this gives your app GroupSessions when they've beenactivated from either the local or remote devices.Let's store this groupSession on the CoordinatorManager,which will propagate the changeover to our MoviePlayerViewController.

Once set, we'll attach the session object to our AVPlayervia playbackCoordinator .coordinateWithSession.

Then, back in our await loop,we'll get the movie from the session object.

Since the activity can change throughout the session,we use a Combine publisher to get the activity.Then, we enqueue a movie to start playback.And finally, we join the session.Now that we've set up the code to receivea GroupSession and sync playback,let's run the app on our devices and see what happens.Again, the two devices are in a FaceTime call,and on the first device, I'll open the sample appand share the rings video.

You can see Moritz's device receivedthe Group Activity, so we'll launch the app.And this time, both devices show the right video.

Then, if I press "play,"we can see that playback synchronization works.And if I pause on one, it'll pause on the other.

Or I can move ahead, and it'll move ahead on both.

And playback is in perfect sync.

One final thing to note about GroupSession ishow the session is finished.There are two ways to finish a GroupSession.The first is leave().This disconnects the local user from the session,but leaves the session activefor the remaining participants in the call.The second is end().This ends the session, not justfor the local participant, but for the entire call.For extra details on creating advanced GroupActivities apps,see the following WWDC session,"Build custom experiences with Group Activities."It covers how to change the activity of a GroupSession,observe state of a GroupSession, and how to use advancedfeatures, such as the GroupSessionMessenger,which lets you send arbitrary messages between the group.I highly recommend it.Let's switch gears and look at how you can take advantageof picture-in-picture to make sharing a video GroupActivityas seamless as possible.Why is picture-in-picture worth thinking aboutfor GroupActivities apps?Well, supporting picture-in-picture allowscontent to start playing instantly after being shared.Since it doesn't take a user out of their current context, thereis no need for an explicit user interaction to start playback.This saves your users an extra step and resultsin a frictionless experience to share content.For more information on setting up picture-in-picture,see the 2019 WWDC sessionon "Delivering Intuitive Media Playback with AVKit."However, there are some nuances in how picture-in-picture workswith GroupActivitities, so let's go over them now.The GroupActivities framework will deliver sessionsto your media app while in background,to give your app a chance to set up picture-in-picture.If the GroupSession indicates playback can startin the background, you should set uppicture-in-picture, and then go throughthe regular GroupActivities flow.The system will start playing the contentin picture-in-picture without launching the app in fullscreen,so users get that seamless experienceand aren't taken out of their current context.But in some cases, you won't be ableto set up picture-in-picture because you may need the userto sign in to your app, or the content might notbe available without some additional steps from the user.For these cases, GroupSession provides APIsfor your app to request to be foregrounded.Another handy thing we've built into picture-in-pictureis that it handles leaving and ending a GroupSession for you,via a system dialog, so there's no need to worry about leavingor ending a session when picture-in-picture is active.And now, I'll pass it over to my colleague,Moritz, to do a deep diveon the playback coordinator object.

Hello, my name is Moritz Wittenhagen,and I am an engineer on the AVFoundation team.Hayden has introduced you to AVPlaybackCoordinatoras an object that automatically keeps playback on multipledevices in sync, and we've seen it working in the demo.In this part of the talk, I am going to demystifywhat the coordinator actually does under the hoodand how it interacts with your code.For the most part, I will focus on how the coordinator interactswith AVPlayer, how you should selectyour assets for coordinated playback, how individualparticipants can suspend coordination temporarily,and I will also give you a brief insight into howto implement coordination when not using AVPlayer.AVPlaybackCoordinator is an objectthat shares playback state across devices,and it coordinates playback start across those devices,with the goal of no one missing any content.There are two subclasses of the coordinator.An instance of AVPlayerPlaybackCoordinatoris always tied to a particular AVPlayer,and it handles all remote state management for you.This makes it the easiest way to jump into coordinatedplayback, and I highly recommend you start here.We are not going to talk muchabout AVDelegatingPlaybackCoordinator,but this subclass gives you the flexibility to controlany other playback objects that aren't an AVPlayer.Let's look at our device setup again.For the rest of the talk, we are going to representthe GroupActivities objects through the GroupSession.We also assume that your UI presents an AVPlayer playingsome AVPlayerItem, and this is where the newAVPlayerPlaybackCoordinator comes in.When you call coordinator coordinateWithSession,as Hayden showed earlier, we have effectively connectedthe two AVPlayers, and they start to affect each other.The basic rule is the coordinatorwill intercept any transport control API,so any API that changes rate or current time.It takes those commands, figures out if it needs to coordinatethem with someone else, and then, at the appropriate time,lets them take effect on the AVPlayer.Let's look at an example.Here, Hayden and I are in a GroupSession together,and because the GroupActivity told us which URL to load,have enqueued the same AVPlayerItem.Now, if my device changes the AVPlayer's rate property,the playback coordinator will intercept that commandand not immediately allow the player to start playback.Instead, it will ask the playerto enter a timeControlStatus of WaitingToPlayAtSpecifiedRate.UIs will typically represent this timeControlStatuswith a waiting spinner.The coordinator will then send the commandover to Hayden's iPad.The AVPlayerPlaybackCoordinator there receives the commandand similarly asks Hayden's AVPlayerto change rate and enter a waiting state.The coordinators give everyone some time to preparefor playback with the goal of everyone starting playbackat the same time without missing any content.When everyone is good to go, all devices begin playback together.All coordinators in the session are equal,meaning that Hayden can also initiate a command.Let's have him seek this time.Again, the seek API is intercepted,and the coordinator forces the AVPlayer to waitwhile it shares the command with connected coordinators.Everyone is given some time to complete the seek,and when all devices are ready to go again,playback resumes for everyone together.You may ask yourself, what happens when the AVPlayersare playing different items?And the answer is that the coordinatoronly applies state to the other playerwhen both players are playing identical content.I will elaborate on the concept of identity later.For now, think that content is identicalwhen you create the items from the same URL.What this means is that any command you send for item A willonly be applied if the receiver is also playing item A.And changing the item to B will ignore all state from item A.We do this because distinguishing commandsper-item allows for safe joining of participantsand transitions between items.Let me show you what I mean.Here's our example again, but this time,we start with Hayden already playing.As I join and connect my playback coordinatorto the same session, nothing happens to my AVPlayer,because I am not playing the same current item as Hayden.Even creating that same item has no impactbecause the item is not current in my player.This means that I can even seek the itemwithout consequences for anyone else.Only when the item becomes currentin the AVPlayer will the coordinator startdoing its work and try to apply the right state.The rule is that the coordinator always startswith the group state, if there is one.And since Hayden was already playing in the GroupSession,the coordinator prefers his stateover my own configuration from before enqeueuing the item.This means that my coordinator will override any configurationin the AVPlayer and AVPlayerItem to match Hayden's device.And with that, we are both in the same stateand can play together.Let's repeat this with an item transition.As we both approach the end of item A,my AVQueuePlayer is getting ready to play the next item.Usually, we would expect Hayden to get ready, as well,but for this example, let's assume Hayden's iPadis in a bad network and cannot load the next item yet.So, now that I'm at the end of item A,I already have item B enqueued, and it is ready to play.But because the item is not current,the coordinator is not doing anything yet.Only when my player transitions to the new item,will the coordinator do its job again.And this time, it does not find an existing statefor item B, so it just continueswith the state my player is proposing.Even though the coordinator sharesthis new state with Hayden, he is not affectedbecause he is still displaying item A.But when he eventually transitions to match my item,his coordinator will again apply the existing stateto his player.And with that, everyone is playing in sync again.After all this, here is my first call-to-action.Be careful about the order of your item changesand transport control commands.Let's say we have a function beginPlaybackthat enqueues an item and automatically starts playing.This code would be called whenever the userhas selected something to playor when our GroupSession informs us of a new activity.It is important that we seek to our start time first,and similarly, we should change player ratebefore the item is enqueued so that our initialconfiguration cannot affect anyone else.If we do it in this order, the playback coordinator candecide if we are first and our state should be sharedwith everyone else, or if another state alreadyexists, and that should override our state instead.Also, audit your transport control commands and considerif they should affect everyone in the group.Usually, an API call should affectthe group if it originates from playback UI.So if the user pauses, everyone else should pause, too.In that case, just call the AVPlayer API as usual.So, what should we dowith the other API calls not coming from playback UI?Usually, these are automated pausesbecause your app has encountered some system event.Automatic pauses like this shouldnot usually affect the other participants.In such a situation, where your users are playing togetherwith others, you should first consider not pausing at all.Since everyone else continues to play, users will often preferto stick with the group, even if it has some kind of drawback,like not being able to see the content temporarily.If you have no other choice but to pause, you have two options:remove the item first, or begin a coordinated playbacksuspension, which I will cover later in this talk.Now that you have an idea of how the playback coordinator works,let's talk about content for coordinated playback.As I stated previously, we consider two player itemson different devices to be the samewhen their assets were created from the same URL.While this default can work well, there are situationswhere you want to change this behavior.For example, your app may offer the usera choice to download and cache the content on device.So, if I have downloaded the asset to my local cache,and Hayden is still streaming the content from the cloud,we are no longer using the same URL, meaning the playbackcoordinator will not keep our playback states in sync.Similarly, some of you may have exciting use casesfor coordinating the state of AVMutableMovies orAVCompositions, which don't have a URL representation at all.Again, the playback coordinator does not know what to do here.To solve this problem, you can provide a custom stringas an identifier for an AVPlayerItem.If this string is present, the coordinator will use itto decide if two items represent the same content,and it will ignore the URL.You do this by implementing the AVPlayerPlaybackCoordinatorDelegate protocol and its playbackCoordinatoridentifierFor playerItem function.The coordinator will ask its delegate for an identifierwhenever you enqueue an item in the player.Whenever the playback coordinator considerstwo items equal, it is important that a timeon one device matches the same time on the others.This means that you need to be carefulwith content that is automatically injectedinto the playback stream by a server.So, if Hayden and I request the same URL,but the server decides to inject an ad into only my stream,the devices are now out of sync, as I play into the ad,and Hayden continues with the main content.The right way to approach this problem is to move adsand other interstitials into a separate player.That leaves the main asset unaffected.Now, as I play into the ad, my phone switchesto a different player for the duration of the ad.And when the ad is over, the coordinator can easilyrejoin everyone else's timing, and we are back in sync.If you are playing HLS content, AVPlayer will be able to helpyou with this through the new AVPlayerInterstitialEvent API.Check out the dynamic pre-roll and mid-rollsin HLS talk to learn more.In summary, use custom identifiers to matchcontent if the URL does not cover the right information.Make sure times are the same for everyone.And if you want to play personalized interstitials,play them through a different player,so that your main content is not affected.And finally, use date tags when coordinatinglive content so that the coordinatorcan share the correct timing with everyone else.So far, we have only dealt with the perfect playback cases,where everyone can stay in sync the whole time.Unfortunately, that is not always possible.Let's say Hayden and I are playing together,but an alarm goes off telling me to feed my cat, Zorro.By the rules of AVAudioSession, my app must now pause,and those rules still apply, even when playing in a group.Yet, we do not want my pause to affect everyone else.Forwarding everyone's little pauses to the whole groupwould just cause too many annoyances.So, instead, we want Hayden's iPad to continue playing.And when I dismiss my alarm, playback should catch up,and everyone should play in sync again.So, how can we implement behavior like this?You use a new objectcalled an AVCoordinatedPlaybackSuspension.Such a suspension represents a separationbetween one participant's coordinatorand the other participants' coordinators.The participant is separate from the group,and player rate changes or seeks no longer affect anyone else.Similarly, any rate change comingfrom the group will not change the AVPlayer's rate or time.In the example, this means that itis not possible for Hayden to startmy player while the alarm is still playing.There are two different kinds of suspensions:automatic suspensions and suspensions you add yourself.Automatic suspensions are added by AVPlayerPlaybackCoordinatorwhen the player pauses automatically.We already saw the example of the audiosession interruption, but this also appliesto network stalls or playing an interstitialthrough the new AVPlayer interstitial API.Suspensions added by the playback coordinatorend when the player resumes playback, and it causesthe player to match timing to the current group state.For our example, this means that I willautomatically rejoin the group when my player rate changes backto one after my app handled the end-interruptionnotification from dismissing the alarm.Let me show you two examples of how the system usescoordinated playback suspensions.

Here is our sample app playing drone footage of the rings.Let's look at the interruption example we discussed before.I have set a timer to go off in a few seconds,so let's wait for that.

Ah, here we go.This has paused the iPad on my left, but as you can see,the other device is still happily playing.And as I dismiss the timer, playback on the deviceon the left jumps forward to rejointhe other device and is perfectly in sync.This is not the only way the system makes useof suspensions.AVKit uses them to keep random video framesfrom flashing in front of everybody during scrubbing.You may have noticed already that scrubbing willshow intermediate frames only on the devicethat I'm interacting with.So, as I touch the scrubber,the device on the right continues playing,while the left device shows the scrubbing frames.Only when I let go of the scrubberwill the new time be shared with the other device,and playback resumes for everyone.These are examples of how the system uses suspensions.Now, let's look at how you would adopt one yourself.So, let's jump into Xcode and actually do that.Let's say you wantedto implement a feature that allows one participantto rewatch something they just missed.Maybe there was a particularly exciting momentin the drone footage we are watching.With all the coordinator behaviors we discussed so far,seeking back and playing again will affect everyone.And I want to emphasizethat this may very well be the right thing to do.Try to keep your users together as much as possible.But let's say seeking back for everyone is not an option.So, what we will build instead is a way to seek backby a few seconds and play the content at twice the speeduntil we join back up with everyone.I have already added a button in my UI that a usercan use to indicate that they missed something.It is hooked up with this functionin our MoviePlayerViewController.Let's fill that in.

Here is just the player logic.We figure out what time to seek to,seek back, and set the player rate to 2.When we have caught up, we just resume playback at rate 1.So far, this would all happen to everyone becausethe playback coordinator will intercept those API calls.This is where the suspensions come in.Right before we seek back,I want to separate our player from everyone else.And we do that with the coordinator'sbeginSuspension function.It requires a reason, and to provide that reason,we just extend the Reason struct with a new string constant.

In this case, what-happened.Now, we can use that in our beginSuspension call.

Since the coordinator is now suspended, we can safely seekand set the rate, just for our player.Once we are ready to meet up with everyone else,we need to signal to the coordinator to listento the group again, so we callsuspension.end().Note that we don't actually need the player rate change anymore.Since ending the suspension will alwaysrejoin everyone else, our player rate change wouldalso change back to whatever the current group rate is.

Now, let's try this out.

Everyone plays together.I miss an exciting event, like the approach to the ring,and I tap our new what-happened button.So, you can see, the device I'm interacting withjumps back to repeat the content.It plays faster to catch up,while the other device is not affected.And now, we are already perfectly in sync again.So, when you begin a suspension on an AVPlaybackCoordinator,you separate its player from the group,and it is now safe to issue any rate changeor seek without affecting anyone else.Ending the suspension willrejoin the group's current time and rate.And, new on this slide, you can optionally proposea new time to the group when ending the suspension.This is how you can implement a scrubbing suspensionthat changes time for everyone onlywhen letting go of the playback control.Here is a summary of when AVPlayer transport controlcommands are actually shared with other participants.First, you have to connect the AVPlayerPlaybackCoordinatorto other participants through a group session,as Hayden showed you at the beginning of the talk.Second, the AVPlayer's current AVPlayerItem must havethe same URL as the other participants' player items.Or if you're providing your own identifiers,they must have the same custom identifier.Once an item is enqueued, all seeks and rate changesaffect everyone in the group,except when you begin a coordinated playback suspension.And to close out the discussion of AVPlayerPlaybackCoordinator,here's a quick tour of other API related to coordinated playback.If you want other participants to waitduring one user's suspension,you can configure this using the coordinator'ssuspensionReasons ThatTriggerWaiting property.This is how you could request that no one misses any contentif participants have different length ads.To learn more about the state of other participants,take a look at the coordinator's otherParticipants propertyand its corresponding notification.The AVCoordinatedPlaybackParticipantmost notably gives you the list of suspensionReasons,which may be useful to inform UI,especially if you use suspension ReasonsThatTriggerWaiting above.Whenever the coordinator requests its AVPlayer to wait,that is reflected in the players reasonForWaitingToPlay,with the new waiting ForCoordinatedPlayback reason.To override waiting and immediately start playback,regardless of the other participants' states,use the player's playImmediately atRate function.Note that this can cause other participants to miss content,so be aware of that when using this API.AVPlayer also has a new rateDidChangeNotification,which provides more information about the rate change,including when another participant caused it.And similarly,AVPlayerItem's TimeJumpedNotificationwill also tell you if a time jump originatesfrom another participant.There is some AVPlayer API you cannot usewith AVPlayerPlaybackCoordinator.The default time pitch algorithm on iOS used to below quality zero latency.This value is now deprecated in iOS 15.LowQualityZeroLatency is not supportedfor coordinated playback, and you should watch outfor code resetting to this now-deprecated value.Use one of the other algorithms instead.Also, do not useAVPlayer's setRate(time:atHostTime:)function with an AVPlayerPlaybackCoordinatorbecause it is vital that the playback coordinateris in charge of player timing,which is incompatible with external startup sync.After all this talk about AVPlayer,let's quickly dip into the second subclassof AVPlaybackCoordinator, AVDelegatingPlaybackCoordinator.A lot of the concepts that we discussed still applyfor delegating playback coordinator, but insteadof observing the player for you, the delegating coordinatorrequires you to provide information about playback stateand apply state to your playback objects yourself.A custom playback object setup will look something like this.Your UI controls the player, which uses one of the othersystem-rendering APIs underneath.The delegating playback coordinator fitsin between your UI and your player implementation.As the name suggests, AVDelegatingPlaybackCoordinatorrequires you to implement a delegate protocolthat receives playback commands for playing,pausing, seeking, and buffering.Instead of sending a play command to your player directly,your UI would tell the coordinator first.The coordinator will then decide if it needsto first negotiate with other connected players,before changing your playback object's time or rate.You also have to tell the coordinator wheneveryour player transitions to a new current item,so that the coordinator knows which commands to send to you.As before, items are identified by arbitrary strings.When the coordinator sends a command, it shouldaffect the originating UI, as well as the receiver UI.And when it is time to play,it should affect all players in the same way.It is your responsibility to make your playback objectfollow along and to update your UIfor commands appropriately.I want to specially call out that the delegating coordinatorwill often tell you to begin buffering,even if your device is already ready to go.This means the coordinator is still waiting for otherconnected participants, and your UI should reflect that,even if there is nothing to do on your end.Final words of warning.Be careful with events like route changesthat briefly pause and resume your player.It is your responsibility to stick to the requested timingand reapply the group timing as needed.If you cannot keep up for whatever reason,you should communicate that to the coordinatorusing a suspension.The delegating playback coordinatoralso does not add any automatic suspensions.This means you should begin and end suspensionsfor relevant system events yourself.Use the reasons provided by AVFoundationwhere appropriate.And it is possible to connect a delegating playbackcoordinator on one device to a player playback coordinatoron another, but you must use custom identifierson the player playback coordinator end.Let's wrap up.To build a coordinated media playback app,use a GroupActivity to define the content you areplaying and to propose it to the group.Start to keep track of GroupSessions as soonas your app launches to learn when your usersare in a FaceTime call and want to play together.And finally, connect the playback coordinatorto your GroupSession to keep your contentin sync for everyone.Thank you, and enjoy the rest of WWDC.[music]

3:06 -Define a GroupActivity

4:42 -Making your play buttons automatically start a group session when appropriate

8:31 -Receiving a GroupSession from the GroupSession AsyncSequence

9:03 -Attaching an AVPlayer to the GroupSession

31:26 -Custom suspensions

## Code Samples

```swift
protocol
 
GroupActivity
: 
Codable
 
{

    
/// An identifier so the system knows how to reference this activity

    
static
 
var
 activityIdentifier: 
String
 { 
get
 }

    
/// Information that the system uses to show this activity, such as title and a preview image

    
var
 metadata: 
GroupActivityMetadata
 { 
get
 
async
 }
}
```

```swift
func
 
playButtonTapped
()
 {
    
let
 activity 
=
 
MovieWatchingActivity
(movie: movie)
            
    
Task
 {
        
switch
 
await
 activity.prepareForActivation() {
        
case
 .activationDisabled:
            
// Playback coordination isn't active. Queue movie

            
// for local playback.

            
self
.enqueuedMovie 
=
 movie
        
case
 .activationPreferred:
            
// Activate the activity. The system enqueues the movie

            
// when the activity starts.

            activity.activate()
        
case
 .cancelled:
            
// The user cancelled the operation. Nothing to perform.

            
break

        
default
:
            
break

        }
    }
}
```

```swift
// Receiving a GroupSession from the GroupSession AsyncSequence



func
 
listenForGroupSession
()
 {
    
Task
 {
        
for
 
await
 session 
in
 
MovieWatchingActivity
.sessions() {
            
...

        }
    }
}
```

```swift
let
 player 
=
 
AVPlayer
()


...



func
 
listenForGroupSession
()
 {
    
Task
 {
        
for
 
await
 groupSession 
in
 
MovieWatchingActivity
.sessions() {
            
            
// Verify content is available, prepare for playback to begin


            player.playbackCoordinator.coordinateWithSession(groupSession)

            
...

        }
    }
}
```

```swift
class
 
AVPlaybackCoordinator
 
{
    
func
 
beginSuspension
(
for
 
reason
: 
AVCoordinatedPlaybackSuspension
.
Reason
)
 -> 
AVCoordinatedPlaybackSuspension

}


class
 
AVCoordinatedPlaybackSuspension
 
{ 	
    
func
 
end
()

    
func
 
end
(
proposingNewTime
 
newTime
: 
CMTime
)

}
```


# Wwdc2021 10131

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Meet declarative device managementThe future of device management is here: Learn how you can support mobile device management while allowing individual devices to be autonomous and proactive, bringing both increased performance and scalability. We'll show you how you can incorporate this declarative model in your MDM solution.ResourcesDevice ManagementHD VideoSD VideoRelated VideosWWDC23Explore advances in declarative device managementWWDC22Adopt declarative device managementWWDC21What’s new in managing Apple devices

The future of device management is here: Learn how you can support mobile device management while allowing individual devices to be autonomous and proactive, bringing both increased performance and scalability. We'll show you how you can incorporate this declarative model in your MDM solution.

Device Management

HD VideoSD Video

HD Video

SD Video

Explore advances in declarative device management

Adopt declarative device management

What’s new in managing Apple devices

Search this video…♪ Bass music playing ♪♪Melissa Nierle: I'm Melissa Nierle,a software engineeron the Enterprise and Education Technologies team.At Apple, we're always workingto create the best device management featuresand functionality to equip our enterprise partnersand education organizations with the tools they needto connect their team members and students.The backbone of all of these management featuresis the MDM protocol itself.The protocol is a well-established,heavily used solution provided directly within iOS,macOS, and tvOSand has become a standard across mobile device management.And while we add features to it each year,we also continually evaluate the protocolagainst our device management goalsand evolve it to meet the dynamic needsof MDM solution developers, admins, and users.Today, our MDM protocol can be describedas an imperative and reactive protocol.Each management workflow takes time and multiple round tripsbetween the device and server.Then any performance challenge is compoundedwhen you manage a large number of devicesacross an organization.This is an example of where we want to ensureour protocol is as performant and scalable as possible.And to achieve optimal performance and scalability,we've reenvisioned the MDM protocol itself.The future of device management is declarative management;a transformative update to the protocolwhich brings policy management to the device.Declarative management allows the device to be autonomousand proactive,freeing up the server to be lightweight, reactive,and subscribe to updates without constant polling.An autonomous device reacts to its own state changesand then applies management logic to itselfwithout prompting from the server.A proactive device has a status channelasynchronously reporting to the serverwhen important state changes occur,avoiding the need for servers to poll devices.Enabling devices to be both autonomous and proactiveis the foundation of declarative managementand allows for increased performance and scalability.And the best part is, while it's a new paradigm,it's not a new protocol.We've built this new declarative functionalityright into our existing MDM protocol,starting with iOS devices.We'll take a deep dive into the data modelthat powers the new declarative paradigm.Then later, we'll talk about integration with MDM.We'll go through a specific exampleand learn how to get yourself started.Let's begin with the declarative data model.There are three pillars to the declarative data model.Declarations, which are payloads that the server definesand sends to devices;the status channel, which is a new channel of communicationwhere the device proactively updates the serverwith new information about itself;and extensibility, so that,as Apple introduces new features to declarative management,your devices and servers handle it seamlessly.Understanding these three pillars will prepare youto incorporate declarative managementinto your MDM solution.Let's start with declarations.Declarations represent the policyan organization wants to enforce on devices --for example, accounts, settings, and restrictions.Declarations can be created for policythat is common to all users, as well as policythat is specific to a single user or device.Let's examine the makeup of declarations.The data representation for declarationsis similar to profiles, where a declaration is also a dictionarywith a set of keys and standard types for values.Declarations, however, are serialized as JSON objectswhen sent over the network, instead of plists.All declarations have three required properties:Type, Identifier and ServerToken.Type defines which policy a configuration represents.The Identifier key has a value that uniquely identifiesthe declaration within the set of all declarationssent to the device.Typically, this will be a UUID represented as a string.The device uses this value when synchronizing declarationswith the server.The ServerToken key represents a unique revisionof the declaration based on the Identifier key.This key is also used when synchronizing declarationswith the server.The value is a string that must be different for each revision.It could be a simple counter or a UUID string,as shown in the example.The payload is a data-specific piece of the declaration,containing the keys and valuespertinent to the declaration type.Just like with profile payloads, some keys may be required,and others may be optional.Values can be strings, numbers, booleans, arrays,or dictionaries and may be constrained in range --like numbers one through ten -- or to a specific set of valueslike a string enumeration.There are four types of declarations: configurations,assets, activations, and management.The first type of declaration is a configuration.Configurations represent the policiesto be applied to the device --for example, accounts, settings, and restrictions.Configurations are similar to MDM's existing profile payloads.Here is an example of a configuration declarationthat applies restrictions to the device passcode.The standard keys --Type, Identifier, and ServerToken --are present, as required for all declarations.The value of the Type identifies thisas a passcode configuration type of declaration.The Payload key contains the passcode policy datafor the configuration.The next type of declaration is an asset.Assets represent references to ancillary dataneeded by configurations.This can be a shared item of large dataor a personalized one.For large data items, the asset declaration contains a URLthat the device uses to fetch the actual asset datafrom a server.This server could be your MDM server,or it could be a separate content delivery network server.Serving assets from a separate content delivery networkshifts the burden of supporting large network bandwidthto a service better suited for it.Assets can also be used to represent dataspecific to a user, such as their name,email address, passwords for accounts, and certificates.This takes the per-user customized dataout of configurations and moves it into smaller,dedicated asset-type declarations.Assets have a one-to-many relationshipwith configurations.For example, one credential asset can be referencedby several account configurations,avoiding the need to replicate the same user informationin each account configuration.Then, if the user credential needs to be updated,only that asset needs to be updated.All the configurations referencing that assetremain unchanged,and the device updates the policy accordingly.The ability to do incremental updates like this,for many configurations at a time,will improve the overall responsivenessof the device management system.Let's examine the makeup of an asset declaration.Here is an example of an asset declarationthat defines a user identity --essentially the contact information for a user.The three required standard keys are present,and the value of Type defines thisas a user identity asset declaration.The Payload key contains the user identity propertiesof this asset.The next type of declaration is an activation.Activations represent sets of configurationsthat the device will atomically apply.This means all configurations in the set,along with any referenced assets,must be valid in order for all of them to be applied.If any are invalid,the activation will fail to apply the associated policy.Here is an example of a simple activationthat contains two configurations.The three required declaration keys are present,and the payload contains the set of configurationsto be atomically applied by the activation.Configurations are referenced by their identifier key.There is a many-to-many relationshipbetween activations and configurations.Activations can refer to multiple configurations,and a configuration can have multiple activationsreference it.This many-to-many relationshipallows for complex business logicto be handled autonomously by the device.Activations can include a predicatethat determines when the activation state is activeor inactive on a device.The device will only process the configurations referencedby an activation if the predicate evaluates to true.As an example, a predicate can declarethat the particular activation is only activeon a specific device type, such as an iPad.Another example is wanting a set of policiesto apply only to a particular version of the OS.This allows the server to send all the declarationsfor any device statesand lets the device itself determine which ones to apply,making the device even more autonomous.As the device state changes, the activation predicatesare reevaluated without intervention from the server.Policy associated with the new device state will be appliedand any outdated policy removed.The device here becomes increasingly proactive.In the absence of a predicate, the device will always processthe configurations referenced by the activation.Here we have the activation example from before,but now there's a predicate present,indicating that this activationshould only have its policy appliedwhen the device is an iPad.The last type of declaration is a management declaration.Management declarations are usedto convey overall management state to the device.This includes a declaration describing detailsabout the organization as well as a declarationthat describes the capabilities of the server.These declarations are helpfulfor conveying static information to the device.And those are the four types of declarationsfor applying organization policy to your devices.The second pillarof the new declarative management data modelis the status channel.Given the way that declarations work,the declared state of the device may not matchthe actual state of the device at any point in time.For instance, any declaration that requires user interactionwill not apply until that action is taken.A good example of this is a passcode policy,where the user has to take actionto create a new policy-compliant passcode for the device.To add visibility into this device state transition,we've created the status channel.Updates of the device state are sent in a status reportto the server.The server can subscribe to specific status items,so it only receives updates for the changes it cares about.Status items are identified by key-paths,which consist of period-separated string tokens.Status items can be used as expressionsin activation predicates,as shown in the earlier activation predicate example.The server subscribes to specific status itemsusing status subscription configurations.Upon receiving this configuration,the device will send an initial status reportfor the subscribed status items,and then send a report if a subscribed item changes.The status reports are incremental,so only the changed items are reported.The status of declarations --whether they are applied or not --is always reported to the server when changed,without the need for the server to subscribe.Let's inspect a configurationthat subscribes to specific status item updates.This configuration subscribes to three status itemsrepresenting the device's operating system version,type, and model.When this configuration is activated on the device,it will send the initial status reportfor each of the newly subscribed status items.Status items are represented as a JSON object,nested by the hierarchical componentsof that corresponding key-path.In this case, the device reports it is on iOS 14.5.When the user updates the softwareto the latest iOS version, the device will reportthe status change for the operating-system version item.The server now detectsthat the device has been upgraded to iOS 15.The third pillar of the declarative data modelis extensibility.Given the long life cycle of Apple products, it is essentialto maintain compatibility between different versionsof your MDM solution with Apple devices,especially as software updates and new hardware modelsare released.With declarative management, both the device and servernow advertise supported capabilities to each other.Each knows when it can start taking advantage of new featureswithout having to hardcode software versionor hardware dependencies.The capabilities that the server and client both advertiseincludes a list of supported featuresrepresenting both minor and major protocol updates.The client also advertises supported payloads,which lists the full set of declarations and status itemssupported by the client.The server's capabilities are sent to the devicevia a management declaration.When the server is upgraded,it synchronizes all new capabilities to the devicejust as it would any other type of declaration.The device is immediately able to take advantageof the server's new features.The client's capabilities are sent to the serveras a specific status item any time capabilities change.This way,the server can immediately start taking advantageof the device's new features and payloads.Building extensibility into the declarative data modelensures that declarative managementis built for the present and the future.Now that you understand the data model,let's dig into how declarative managementis seamlessly integrated within the MDM protocol.Existing MDM vendors can use declarative management featuresstarting today.Declarative management is integrated into the MDM protocoland utilizes it for managing the enrollmentand unenrollment process and for handling the HTTP transportand device and user authentication.Existing and mature MDM productscan smoothly transition to declarative managementwithout a disruptive change to adopt a new protocolor server infrastructure.Declarations and the status channel coexistwith your already in-use MDM commands and profilesin an extensible way.This allows you to gradually adopt the different featuresof declarative managementwithout having to update all of your MDM workflows at once.For example, a server could chooseto only implement status subscriptions,effectively adding a status channel to the MDM protocolwithout having to adopt all of declarative management.When the device is unenrolled from MDM,all declarations are removed,and the device state is adjusted accordingly.Importantly, declarative managementdoes not impact existing MDM behavior at all.Actually, declarative managementleverages existing MDM behaviors using an MDM commandfor activation and an MDM CheckIn requestfor synchronization and status reports.Let's zoom in on each of these next.A DeclarativeManagement command has been added to MDM.This command serves two purposes.First, it activates the declarative management featureson the device.Please note, once turned on,declarative management cannot be turned off.However, the server can remove all declarationsto effectively disable declarative management.Second, the command can include a payloadcontaining synchronization tokensthat will initiate a synchronization flow if needed.There is also a new DeclarativeManagement CheckIn request typeused by the device when synchronizing declarationsand to send status reports to the server.Here is an example of the new CheckIn request type.The MessageType key is setto the new DeclarativeManagement value.The endpoint key is set to a valueindicating that the client is making a requestto retrieve the declaration manifest data from the server.Some requests -- such as this status report --can also include Base64-encoded data.When using the CheckIn request to synchronize declarations,there will be a response from the server.There are two types of responses: a manifest,which lists the identifier and server token propertiesof all declarations that the server defines;and single declarations for the device to apply.Now that you've learned how to activate declarative managementand synchronize declarations with a CheckIn request,let's talk about how you can migrate your policies graduallyfrom profiles to declarations.There's a declaration type specifically for sendingand installing profiles as configurations.This enables you to utilize the full suite of MDM profilesto immediately take advantage of declarative managementby shifting profile-based policy logic to the device.Here is an example of a profile configuration.The profile is referenced via URL.When this configuration is activated,the profile is fetched from the URL and installed on the device.We've taken these steps to make declarative managementeasy to adopt today with the iOS 15 beta.Now let's go through an exampleof how declarative management interacts with the server.First, we activate declarative management.This starts with the device already enrolled in MDM.The server sends a push notification to the device.The device responds to the push in the usual way,by sending a ServerURL endpoint requestwith its status set to Idle.The server then respondswith the DeclarativeManagement command.Upon receipt,the device activates declarative management.After processing the DeclarativeManagement command,the device sends an Acknowledged status back to the server.Then if the server has no more commands,it will return an empty response.The device then startsits declarative management synchronization process;let's go through that next.The device first sends a CheckIn requestwith the endpoint key set to declaration-items.The server responds with a manifestcontaining declaration metadata.The device then compares the items in the manifestto the set of declarations it previously receivedfrom the server.Through this comparison, the device can tellwhich declarations are new, which have changed,and which have been removed.For each new or changed declaration,the device sends a CheckIn request.This request's EndPoint key is set to a pathuniquely identifying the declaration resource.The server then responds with the JSON objectrepresenting that declaration.Once all declarations have been fetched from the server,the device starts applying the policy changesrepresented by this updated state of declarations.Once the policy changes have been applied,the device will send a status report to the server,with the corresponding updated status items.To help get you started,let's go through what we are shipping in iOS 15.The declarative management feature is supported on deviceswith iOS 15 and iPadOS 15.It's also only available when the MDM enrollment typeis a user enrollment -- either the new onboarding flowintroduced with iOS 15, or the flow from iOS 13.For configurations, we have accountand passcode configurations that cover the equivalent setof MDM account and passcode profile payloads.We also support profile configurationsenabling you to start installing the full suiteof MDM-supported profiles to your devices declaratively.Status subscription configurationsare also available today and are used for the serverto declare the specific status item updatesit wants to receive.There is one type of activation available today.This simple activation defines a list of configurationsthat must be applied atomicallyand may include an optional predicate.For asset declarations, there are two types available:user identity assets,which represent a user's contact information;and user credential assets,which contain user IDs and passwords for user accounts.For management declarations, we are supporting two types:organization details and server capabilities.Next, here are the status items available today.Each declaration has its own status itemthat is automatically sent to the server from the device.Also available are a set of status itemsthat cover basic properties of the device,like details about a device's hardware modeland its operating system.For more detail on these declarations and status items,check out Apple's Device Managementdeveloper documentation.Today we covered the new paradigmof declarative management and its functionality,discovering how declarative management empowers youto make devices more autonomous and proactive.We learned how to integrate declarative managementinto your MDM solution.We went through an exampleshowing how declarative management worksand reviewed how declarative management is ready for youto start using today.We can't wait to find out how you'll reinvent MDM solutionswith declarative management.Thanks for joining me and have a great WWDC.♪

♪ Bass music playing ♪♪Melissa Nierle: I'm Melissa Nierle,a software engineeron the Enterprise and Education Technologies team.

At Apple, we're always workingto create the best device management featuresand functionality to equip our enterprise partnersand education organizations with the tools they needto connect their team members and students.

The backbone of all of these management featuresis the MDM protocol itself.

The protocol is a well-established,heavily used solution provided directly within iOS,macOS, and tvOSand has become a standard across mobile device management.

And while we add features to it each year,we also continually evaluate the protocolagainst our device management goalsand evolve it to meet the dynamic needsof MDM solution developers, admins, and users.

Today, our MDM protocol can be describedas an imperative and reactive protocol.

Each management workflow takes time and multiple round tripsbetween the device and server.

Then any performance challenge is compoundedwhen you manage a large number of devicesacross an organization.

This is an example of where we want to ensureour protocol is as performant and scalable as possible.

And to achieve optimal performance and scalability,we've reenvisioned the MDM protocol itself.

The future of device management is declarative management;a transformative update to the protocolwhich brings policy management to the device.

Declarative management allows the device to be autonomousand proactive,freeing up the server to be lightweight, reactive,and subscribe to updates without constant polling.

An autonomous device reacts to its own state changesand then applies management logic to itselfwithout prompting from the server.

A proactive device has a status channelasynchronously reporting to the serverwhen important state changes occur,avoiding the need for servers to poll devices.

Enabling devices to be both autonomous and proactiveis the foundation of declarative managementand allows for increased performance and scalability.

And the best part is, while it's a new paradigm,it's not a new protocol.

We've built this new declarative functionalityright into our existing MDM protocol,starting with iOS devices.

We'll take a deep dive into the data modelthat powers the new declarative paradigm.

Then later, we'll talk about integration with MDM.

We'll go through a specific exampleand learn how to get yourself started.

Let's begin with the declarative data model.

There are three pillars to the declarative data model.

Declarations, which are payloads that the server definesand sends to devices;the status channel, which is a new channel of communicationwhere the device proactively updates the serverwith new information about itself;and extensibility, so that,as Apple introduces new features to declarative management,your devices and servers handle it seamlessly.

Understanding these three pillars will prepare youto incorporate declarative managementinto your MDM solution.

Let's start with declarations.

Declarations represent the policyan organization wants to enforce on devices --for example, accounts, settings, and restrictions.

Declarations can be created for policythat is common to all users, as well as policythat is specific to a single user or device.

Let's examine the makeup of declarations.

The data representation for declarationsis similar to profiles, where a declaration is also a dictionarywith a set of keys and standard types for values.

Declarations, however, are serialized as JSON objectswhen sent over the network, instead of plists.

All declarations have three required properties:Type, Identifier and ServerToken.

Type defines which policy a configuration represents.

The Identifier key has a value that uniquely identifiesthe declaration within the set of all declarationssent to the device.

Typically, this will be a UUID represented as a string.

The device uses this value when synchronizing declarationswith the server.

The ServerToken key represents a unique revisionof the declaration based on the Identifier key.

This key is also used when synchronizing declarationswith the server.

The value is a string that must be different for each revision.

It could be a simple counter or a UUID string,as shown in the example.

The payload is a data-specific piece of the declaration,containing the keys and valuespertinent to the declaration type.

Just like with profile payloads, some keys may be required,and others may be optional.

Values can be strings, numbers, booleans, arrays,or dictionaries and may be constrained in range --like numbers one through ten -- or to a specific set of valueslike a string enumeration.

There are four types of declarations: configurations,assets, activations, and management.

The first type of declaration is a configuration.

Configurations represent the policiesto be applied to the device --for example, accounts, settings, and restrictions.

Configurations are similar to MDM's existing profile payloads.

Here is an example of a configuration declarationthat applies restrictions to the device passcode.

The standard keys --Type, Identifier, and ServerToken --are present, as required for all declarations.

The value of the Type identifies thisas a passcode configuration type of declaration.

The Payload key contains the passcode policy datafor the configuration.

The next type of declaration is an asset.

Assets represent references to ancillary dataneeded by configurations.

This can be a shared item of large dataor a personalized one.

For large data items, the asset declaration contains a URLthat the device uses to fetch the actual asset datafrom a server.

This server could be your MDM server,or it could be a separate content delivery network server.

Serving assets from a separate content delivery networkshifts the burden of supporting large network bandwidthto a service better suited for it.

Assets can also be used to represent dataspecific to a user, such as their name,email address, passwords for accounts, and certificates.

This takes the per-user customized dataout of configurations and moves it into smaller,dedicated asset-type declarations.

Assets have a one-to-many relationshipwith configurations.

For example, one credential asset can be referencedby several account configurations,avoiding the need to replicate the same user informationin each account configuration.

Then, if the user credential needs to be updated,only that asset needs to be updated.

All the configurations referencing that assetremain unchanged,and the device updates the policy accordingly.

The ability to do incremental updates like this,for many configurations at a time,will improve the overall responsivenessof the device management system.

Let's examine the makeup of an asset declaration.

Here is an example of an asset declarationthat defines a user identity --essentially the contact information for a user.

The three required standard keys are present,and the value of Type defines thisas a user identity asset declaration.

The Payload key contains the user identity propertiesof this asset.

The next type of declaration is an activation.

Activations represent sets of configurationsthat the device will atomically apply.

This means all configurations in the set,along with any referenced assets,must be valid in order for all of them to be applied.

If any are invalid,the activation will fail to apply the associated policy.

Here is an example of a simple activationthat contains two configurations.

The three required declaration keys are present,and the payload contains the set of configurationsto be atomically applied by the activation.

Configurations are referenced by their identifier key.

There is a many-to-many relationshipbetween activations and configurations.

Activations can refer to multiple configurations,and a configuration can have multiple activationsreference it.

This many-to-many relationshipallows for complex business logicto be handled autonomously by the device.

Activations can include a predicatethat determines when the activation state is activeor inactive on a device.

The device will only process the configurations referencedby an activation if the predicate evaluates to true.

As an example, a predicate can declarethat the particular activation is only activeon a specific device type, such as an iPad.

Another example is wanting a set of policiesto apply only to a particular version of the OS.

This allows the server to send all the declarationsfor any device statesand lets the device itself determine which ones to apply,making the device even more autonomous.

As the device state changes, the activation predicatesare reevaluated without intervention from the server.

Policy associated with the new device state will be appliedand any outdated policy removed.

The device here becomes increasingly proactive.

In the absence of a predicate, the device will always processthe configurations referenced by the activation.

Here we have the activation example from before,but now there's a predicate present,indicating that this activationshould only have its policy appliedwhen the device is an iPad.

The last type of declaration is a management declaration.

Management declarations are usedto convey overall management state to the device.

This includes a declaration describing detailsabout the organization as well as a declarationthat describes the capabilities of the server.

These declarations are helpfulfor conveying static information to the device.

And those are the four types of declarationsfor applying organization policy to your devices.

The second pillarof the new declarative management data modelis the status channel.

Given the way that declarations work,the declared state of the device may not matchthe actual state of the device at any point in time.

For instance, any declaration that requires user interactionwill not apply until that action is taken.

A good example of this is a passcode policy,where the user has to take actionto create a new policy-compliant passcode for the device.

To add visibility into this device state transition,we've created the status channel.

Updates of the device state are sent in a status reportto the server.

The server can subscribe to specific status items,so it only receives updates for the changes it cares about.

Status items are identified by key-paths,which consist of period-separated string tokens.

Status items can be used as expressionsin activation predicates,as shown in the earlier activation predicate example.

The server subscribes to specific status itemsusing status subscription configurations.

Upon receiving this configuration,the device will send an initial status reportfor the subscribed status items,and then send a report if a subscribed item changes.

The status reports are incremental,so only the changed items are reported.

The status of declarations --whether they are applied or not --is always reported to the server when changed,without the need for the server to subscribe.

Let's inspect a configurationthat subscribes to specific status item updates.

This configuration subscribes to three status itemsrepresenting the device's operating system version,type, and model.

When this configuration is activated on the device,it will send the initial status reportfor each of the newly subscribed status items.

Status items are represented as a JSON object,nested by the hierarchical componentsof that corresponding key-path.

In this case, the device reports it is on iOS 14.5.

When the user updates the softwareto the latest iOS version, the device will reportthe status change for the operating-system version item.

The server now detectsthat the device has been upgraded to iOS 15.

The third pillar of the declarative data modelis extensibility.

Given the long life cycle of Apple products, it is essentialto maintain compatibility between different versionsof your MDM solution with Apple devices,especially as software updates and new hardware modelsare released.

With declarative management, both the device and servernow advertise supported capabilities to each other.

Each knows when it can start taking advantage of new featureswithout having to hardcode software versionor hardware dependencies.

The capabilities that the server and client both advertiseincludes a list of supported featuresrepresenting both minor and major protocol updates.

The client also advertises supported payloads,which lists the full set of declarations and status itemssupported by the client.

The server's capabilities are sent to the devicevia a management declaration.

When the server is upgraded,it synchronizes all new capabilities to the devicejust as it would any other type of declaration.

The device is immediately able to take advantageof the server's new features.

The client's capabilities are sent to the serveras a specific status item any time capabilities change.

This way,the server can immediately start taking advantageof the device's new features and payloads.

Building extensibility into the declarative data modelensures that declarative managementis built for the present and the future.

Now that you understand the data model,let's dig into how declarative managementis seamlessly integrated within the MDM protocol.

Existing MDM vendors can use declarative management featuresstarting today.

Declarative management is integrated into the MDM protocoland utilizes it for managing the enrollmentand unenrollment process and for handling the HTTP transportand device and user authentication.

Existing and mature MDM productscan smoothly transition to declarative managementwithout a disruptive change to adopt a new protocolor server infrastructure.

Declarations and the status channel coexistwith your already in-use MDM commands and profilesin an extensible way.

This allows you to gradually adopt the different featuresof declarative managementwithout having to update all of your MDM workflows at once.

For example, a server could chooseto only implement status subscriptions,effectively adding a status channel to the MDM protocolwithout having to adopt all of declarative management.

When the device is unenrolled from MDM,all declarations are removed,and the device state is adjusted accordingly.

Importantly, declarative managementdoes not impact existing MDM behavior at all.

Actually, declarative managementleverages existing MDM behaviors using an MDM commandfor activation and an MDM CheckIn requestfor synchronization and status reports.

Let's zoom in on each of these next.

A DeclarativeManagement command has been added to MDM.

This command serves two purposes.

First, it activates the declarative management featureson the device.

Please note, once turned on,declarative management cannot be turned off.

However, the server can remove all declarationsto effectively disable declarative management.

Second, the command can include a payloadcontaining synchronization tokensthat will initiate a synchronization flow if needed.

There is also a new DeclarativeManagement CheckIn request typeused by the device when synchronizing declarationsand to send status reports to the server.

Here is an example of the new CheckIn request type.

The MessageType key is setto the new DeclarativeManagement value.

The endpoint key is set to a valueindicating that the client is making a requestto retrieve the declaration manifest data from the server.

Some requests -- such as this status report --can also include Base64-encoded data.

When using the CheckIn request to synchronize declarations,there will be a response from the server.

There are two types of responses: a manifest,which lists the identifier and server token propertiesof all declarations that the server defines;and single declarations for the device to apply.

Now that you've learned how to activate declarative managementand synchronize declarations with a CheckIn request,let's talk about how you can migrate your policies graduallyfrom profiles to declarations.

There's a declaration type specifically for sendingand installing profiles as configurations.

This enables you to utilize the full suite of MDM profilesto immediately take advantage of declarative managementby shifting profile-based policy logic to the device.

Here is an example of a profile configuration.

The profile is referenced via URL.

When this configuration is activated,the profile is fetched from the URL and installed on the device.

We've taken these steps to make declarative managementeasy to adopt today with the iOS 15 beta.

Now let's go through an exampleof how declarative management interacts with the server.

First, we activate declarative management.

This starts with the device already enrolled in MDM.

The server sends a push notification to the device.

The device responds to the push in the usual way,by sending a ServerURL endpoint requestwith its status set to Idle.

The server then respondswith the DeclarativeManagement command.

Upon receipt,the device activates declarative management.

After processing the DeclarativeManagement command,the device sends an Acknowledged status back to the server.

Then if the server has no more commands,it will return an empty response.

The device then startsits declarative management synchronization process;let's go through that next.

The device first sends a CheckIn requestwith the endpoint key set to declaration-items.

The server responds with a manifestcontaining declaration metadata.

The device then compares the items in the manifestto the set of declarations it previously receivedfrom the server.

Through this comparison, the device can tellwhich declarations are new, which have changed,and which have been removed.

For each new or changed declaration,the device sends a CheckIn request.

This request's EndPoint key is set to a pathuniquely identifying the declaration resource.

The server then responds with the JSON objectrepresenting that declaration.

Once all declarations have been fetched from the server,the device starts applying the policy changesrepresented by this updated state of declarations.

Once the policy changes have been applied,the device will send a status report to the server,with the corresponding updated status items.

To help get you started,let's go through what we are shipping in iOS 15.

The declarative management feature is supported on deviceswith iOS 15 and iPadOS 15.

It's also only available when the MDM enrollment typeis a user enrollment -- either the new onboarding flowintroduced with iOS 15, or the flow from iOS 13.

For configurations, we have accountand passcode configurations that cover the equivalent setof MDM account and passcode profile payloads.

We also support profile configurationsenabling you to start installing the full suiteof MDM-supported profiles to your devices declaratively.

Status subscription configurationsare also available today and are used for the serverto declare the specific status item updatesit wants to receive.

There is one type of activation available today.

This simple activation defines a list of configurationsthat must be applied atomicallyand may include an optional predicate.

For asset declarations, there are two types available:user identity assets,which represent a user's contact information;and user credential assets,which contain user IDs and passwords for user accounts.

For management declarations, we are supporting two types:organization details and server capabilities.

Next, here are the status items available today.

Each declaration has its own status itemthat is automatically sent to the server from the device.

Also available are a set of status itemsthat cover basic properties of the device,like details about a device's hardware modeland its operating system.

For more detail on these declarations and status items,check out Apple's Device Managementdeveloper documentation.

Today we covered the new paradigmof declarative management and its functionality,discovering how declarative management empowers youto make devices more autonomous and proactive.

We learned how to integrate declarative managementinto your MDM solution.

We went through an exampleshowing how declarative management worksand reviewed how declarative management is ready for youto start using today.

We can't wait to find out how you'll reinvent MDM solutionswith declarative management.

Thanks for joining me and have a great WWDC.

♪

## Code Samples


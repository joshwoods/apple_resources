# Wwdc2021 10252

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Make blazing fast lists and collection viewsBuild consistently smooth scrolling list and collection views: Explore the lifecycle of a cell and learn how to apply that knowledge to eliminate rough scrolling and missed frames. We'll also show you how to improve your overall scrolling experience and avoid costly hitches, with optimized image loading and automatic cell prefetching.

To get the most out of this video, we recommend a basic familiarity with diffable data sources and compositional layout.ResourcesBuilding high-performance lists and collection viewsUIKitHD VideoSD VideoRelated VideosWWDC21What's new in UIKitWWDC20Advances in diffable data sourcesAdvances in UICollectionViewTech TalksExplore UI animation hitches and the render loop

Build consistently smooth scrolling list and collection views: Explore the lifecycle of a cell and learn how to apply that knowledge to eliminate rough scrolling and missed frames. We'll also show you how to improve your overall scrolling experience and avoid costly hitches, with optimized image loading and automatic cell prefetching.

To get the most out of this video, we recommend a basic familiarity with diffable data sources and compositional layout.

Building high-performance lists and collection views

UIKit

HD VideoSD Video

HD Video

SD Video

What's new in UIKit

Advances in diffable data sources

Advances in UICollectionView

Explore UI animation hitches and the render loop

Search this video…♪ ♪Hello, I'm Aditya Krishnadevan,an engineer on the UIKit team.At the core of many apps are lists or collection views.Having super-smooth scrolling is a big partof making those apps feel great.This video will set you up for successwhen making blazing-fast lists and collection views.We'll build this app here that uses collection viewsto display a list of image posts of some great travel destinations.It's fairly simple at first glance,with a photo of the destination and a couple of text labels.Throughout this video, we'll talk about how it's set upand how it achieves the performance that people expect.First, we'll learn how to startfrom a strong foundation when using APIs,like diffable data source and cell registrations.We'll refresh our understanding of the life cycleof a collection view cell.We'll then talk about why you might not see perfectly-smooth scrolling,and some advances in prefetching that can help.Finally, Patrick will explain how to correctly update cellswhen their content comes in asynchronously,and how to use new UIImage APIto get the absolute best scrolling performance on all devices.Okay.Let's begin by talkingabout how the app structures its data.The sample app retrieves a list of posts for display,where each post is representedby this DestinationPost struct.DestinationPost conforms to identifiable,which means it has this ID propertythat stores its identifier.This is a unique identifier for each DestinationPostthat remains stable even if other properties change.Diffable data source is built to storeidentifiers of items in your model,and not the model objects themselves.So, in the sample app, the diffable data source is populatedusing the ID property here,and not the DestinationPost itself.Here's the diffable data source used in the app.Like we just discussed, it uses the DestinationPost.ID typefor its item identifiers.The Section type here is an enum with one case,as the app has only one section.To populate the data source,the app first creates an empty snapshotand appends the main section.Then, it fetches all the posts from its backing storeand appends their identifiers.This way, if one of the other propertiesof a DestinationPost changes,its representation in diffable data source remains stable,as the identifier does not change.The final step is to apply the snapshot to the data source.Before iOS 15, applying a snapshot without animationwould be translated to a reloadData internally.That wasn't great for performance,as the collection view had to discardand recreate all the cells on screen.From iOS 15 onwards, applying a snapshot without animationwill only apply the differencesand not perform any extra work.With iOS 15, diffable data source also gainsa new reconfigureItems method that makes it very easyto update the contents of visible cells.We'll go through how it works later in this video.First, let's get the data from our data sourceinto cells and onto the screen.Cell registrations are a great wayto keep all the configuration for each type of cell in one place,and they give us convenient accessto the identifiers from diffable data source.UICollectionView maintains a reuse queuefor each of instance of a registration,so ensure that you create registrationsonly once for each type of cell.Here's a simplified registration for cells in the app.The postID that's passed inis used to retrieve a DestinationPostand an asset object containing the image.The properties from the DestinationPost are usedto set the title and image in the cell.To use a registration,call dequeueConfiguredReusableCellinside the data source's cell provider.Note how the registration is created outside the cell providerand then used inside.This is important for performance,as creating a registration inside the provider would meanthat the collection view would never reuse any of its cells.Now that we understand how to configure a cell,we'll move on to when a cell is configuredand what its life cycle is like.The life of a cell is composed of two phases:preparation and display.The first step for preparationis fetching the cell to work on.Whenever UICollectionView needs a cell,it asks for one from its data source.If this is a diffable data source,it runs the cell provider and returns the result.When the cell provider runs, the collection view is askedto dequeue a new cell using a registration.If a cell exists in the reuse pool,UICollectionView will call prepareForReuse on it,and then dequeue the cell.If the reuse pool is empty,it will initialize a new cell.That cell is then passed into the configuration handler from the registration.This is where apps set up the cell for displayfor a given item identifier and index path.The configured cell is returned to the collection view for the next step.The collection view queries the cell for its preferred layout attributesand sizes the cell appropriately.At this point, the cell is fully preparedand ready for phase two: display.willDisplayCell is called on the delegate,and the cell is made visible inside the UICollectionView.The cell is now on screen.There are no more changes to its life cyclewhile it remains visible.When it is scrolled off screen,didEndDisplaying is called for the cell,and it ends up right back in the reuse pool.From the reuse pool, a cell can be dequeued again,repeating this process.Let's now check what the app feels like with these basics in place.The app is featuring Cusco in Peru,and Saint Lucia in the Caribbean.Let's scroll through the app and see some other destinations,but notice how it doesn't scroll smoothly.These interruptions during scrolling are called "hitches."To understand what causes a hitch,let's first learn how an app updates the display.For each frame,events such as touches are delivered to an app.In response, it updates the properties of its views and layers.For example, a scroll view's contentOffsetwill change during a pan gesture,changing the on-screen location of all the views it contains.As a result of those changes,the app's views and layers perform layout.This process is called a "commit."Then, the layer tree is sent to the render server.Each frame has a commit deadline.This is the time by which all commitsfor that frame need to finish.The amount of time an app has to commit for each framedepends on the refresh rate of the display.For example, on an iPad Pro runningat a higher refresh rate of 120 Hz,apps have less time to finish work for each framecompared to an iPhone running at 60 Hz.Here's a typical example of scrolling a list of cellsin a collection or table view.When a new cell becomes visible, there's a longer commit,during which the new cell is configured and performs layout.Then, there's a couple frames where it's just the existing cellsbeing moved around on screen.The commits for these frames are quickbecause no new cells are needed.Eventually, the scroll position changes enoughto cause a new cell to become visible,and this pattern repeats.So what causes hitches like in the demo earlier?When the commit for a frame takes too long and misses the deadline,those updates don't get incorporated into the intended frame.The display keeps the previous frame on screenuntil the commit finishes, and this delayed frame can render.This is a commit hitchand is perceived as a momentary interruption when scrolling.To learn more about this and other types of hitches,watch the "Explore UI animation hitches" video.To help avoid these hitches,UICollectionView and UITableViewboth have a brand-new cell prefetching mechanism in iOS 15.We're back here to the example of an expensive cellcausing a hitch during scrolling.A key takeaway from this isthat you typically don't need a cell every frame.We have a couple of frames with very short commitsdoing minimal work.Cell prefetching in iOS 15 takes advantage of this spare timeby preparing the next cell right after finishing a short commit.Then, when the cell is eventually needed,it's just a matter of making it visible.That's why the commit for the framewhere the prefetched cell becomes visible is very quick,because all of the work was done earlier.The amount of time spent prefetching the cell is the sameas when it causing a hitch.But because we're able to get a head-start,we're able to avoid a hitch.Let's understand why this worksby stepping through each commit.Before the prefetching happened,we performed the commit for this frame.Since no cells were needed, it was a quick commit,and it finished with lots of time left before the deadline.Instead of just waiting around until the next frame,in iOS 15, the system recognizes the situationand uses the spare timeto start prefetching the next cell.Now, the following frame is where things get interesting.Because the cell being prefetched is expensive,it actually causes the commit for that frameto start later than normal.However, even though that commit starts late,it still finishes well before its deadlinebecause it's quick.Compare this to the illustration we saw earlierwithout prefetching.Notice how there are no longer any commits missing deadlines,and so, there are no more hitches with cell prefetching.This means that your apps get up to twice the amount of timeto prepare each cell, without causing any hitches.What's more, all you need to doto get this great new functionality isto build your app with the iOS 15 SDK.When I last ran the demo,the app was built with the iOS 14 SDK.Let's check out scrolling in the appwhen built with the iOS 15 SDK.This is great!Looks like prefetching is doing exactly what we'd want.Scrolling is now perfectly smooth,and we didn't have to change a single line of code.Remember, all you need to do isto build your app using the iOS 15 SDK.For UICollectionView, this new prefetching expandson what was introduced in iOS 10.Cell prefetching is now supported for lists,as well as all other compositional layouts.This great new prefetching is noweven enabled in UITableView.Prefetching can improve scrolling performance by eliminating hitches,but it will also reduce power usage and increase battery life.If your cells are quick to prepare, the system can use the extra time to runin a more energy-efficient state and still avoid hitches.So, even if you don't notice any hitches,it's still very important to make your cell configurationand layout implementations as efficient as possible.Let's now talk about how prefetching affects cell life cycle.This is the life cycle we talked about earlier,without prefetching, with the two distinct phases.When a cell is prefetched, it is the preparation phasethat is executed ahead of the cell being required on-screen.To take full advantage of prefetching,a cell must be fully configured in this phase.Don't wait until a cell is visible to perform any heavy work.When a cell returns to the collection view,it is sized to get its preferred layout attributes,also as part of the prefetch.After being prefetched, there is now this in-between state,where a cell is waiting to be displayed.Given this new phase,there are two important considerations for apps.It is possible for a prepared cell to never be displayed,which could happen if the user suddenly changed the scroll direction.Then, once a cell is displayed,it can go right back into the waiting stateafter it goes off screen.The same cell can be displayed more than once for the same index path.It's no longer the case that a cell will be immediately addedto the reuse pool when it ends displaying.Prefetching helps us achieve smooth scrolling,but only because it gives us more time.On other devices with a higher frame rate,it's still possible that the app is going to have hitches during scrolling.Patrick will now give you more detailabout how the app configures its cells,and also talk about strategiesto reduce the amount of time per commitwhen displaying images.Thanks, Adi.Hi, I'm Patrick from the High-Level Performance team.Now, I'll guide us throughupdating existing cells in the sample app,and then how to display imageswith the best-possible performance,utilizing some new APIs in iOS 15.The sample app was built with local image files on disk.As we scroll the app, the cells are prepared off screen,and the images within them are loadedfrom the file system immediately.Now, we wan display images stored on a remote server.So, when cells scroll in,we may not have the image to show in the image view.When the image view is first visible, it will be blankand only filled in once the server request completes.Let's take a look at extendingour registration's configuration handlerto support this new approach.Here in the registration's configuration handler,we already fetched the asset from the asset store.The store will always return an image,but it may not be the full asset.It might need to be downloaded.The asset object indicates thiswith the isPlaceholder property.When this is true,we will ask the asset store to download the full image.When the load operation completes,it's time to update the cell's image view.Here, we take the existing cell objectand set the asset on its image view.This is a mistake.Cells are reused for different destinations,and by the time the asset store loads the final asset,the cell object we have capturedcould be configured for a different post.Instead of updating the cell directly,we must inform the collection view's data sourceof the needed update.iOS 15 introducesthe reconfigureItems snapshot method.Calling reconfigureItems on a prepared cellwill rerun its registration's configuration handler.Use this instead of reloadItemsbecause it reuses the item's existing cell,rather than dequeuing and configuring a new cell.In our sample app,we'll declare a setPostNeedsUpdate method,which calls reconfigureItems on the ID passed in.Now, back in our registration's configuration handler,when the image is a placeholder,we will download the full-size assetand call the new method.reconfigureItems will then call this handler again,but now, fetchByID will return the full assetand not the placeholder.This allows us to keep all our view-updating codein one place and asynchronously update our cellsonce we have data.To maximize prepare time,we can also use our downloadAsset methodinside our prefetchingDataSource.Data-source prefetching is a great placeto kick off network downloads for a collection-view item.It gives more time to download the asset and have it readybefore the cell is visible,reducing the time users see placeholder content.Let's take a look at how this looks in our app.It looks fine,but there are visible hitches while scrolling.They also appear to coincidewith when new images are displayed.When a new cell is prepared, there is no hitching.It's only when an image is updatedwith the full-resolution image that we hitch.That's because all images take time to decode for display,and some images,like the larger non-placeholder assets,are too large to be decoded in time for display.When the cell registration's configuration handleris first called and the asset is a placeholder,the code begins an async requestfor the full-size imageand completes its configuration.When the asset is finally downloaded later,the cell configuration handler is rerunwith the final image.When an image view tries to commit a new image,it must first prepare the image for displayon the main thread.This can take a long time, and there's a hitchwhen the app missed its commit deadline.Image preparation is a mandatory processthat all images must undergo to be displayed.The render servercan only display images that are bitmaps,which means they are raw pixel data.Images come in many different formats,like PNG, HEIC, and JPEG,which are compressed and must be processedand unpacked to be displayed.Image views do this processingwhen it commits a new image,and it happens on the main thread.Ideally, we could prepare the image in advanceand only update the UIwhen it's finally completed.That way, we never block the main threadand do not hitch.iOS 15 introducesthe image preparation APIs,giving you control over whereand when image preparation happens.These APIs produce a new UIImage,which only contains the pixel datathat the renderer needs.There is no additional work neededonce it's set on an image view.It comes in two forms: a synchronous one,which you can run on any thread,and asynchronous ones,which run on an internal UIKit serial queue.To use it, we take a UIImage we've createdand set a placeholder image on our image view.Then, calling the new APIkicks off the preparationin the background on the larger image.When it completes, we can just set it on the image view.Prepared images solve a large problemin any image-heavy app,but they also come with some considerations.The prepared images containthe raw pixel data from the original image.It will remain free to display in an image viewas long as it's retained in memory.But this also means it takes up a lot of memory,and they should be cached sparingly.Finally, because of their format,they are not ideal for disk storage.Instead, save the original asset to disk.One last consideration is howimage preparation can utilize prefetching.Prefetching gives extra timefor the image to be downloaded and prepared.Giving the process more timemeans the users will not see the placeholder for long,and probably not at all.In the sample app,we already have an asynchronous path for image retrieval.After the download completes,we can then prepare the assetbefore calling the completion handler.These assets are large, but also valuable,so once the image is prepared, we want to cache it.Our image cache uses the image's sizeto estimate the memory use of the prepared image.Now, when a cell asks for an asset,we check that cachebefore fetching it from our server.If we had smaller images,we would be able to cache more.Images can be large,and iOS 15 introduces a similar APIfor preparing thumbnails of images.These can scale and prepare an imageto a smaller size.It ensures that the image is read and processedwith its destination size in mind,saving a lot of CPU time and memory.You use it just like the Image Preparation APIs.First, take a UIImageand set a placeholder image on the image view.Then, call the new resizing API,with the view's size as the target size for the thumbnail.When its prepared, just update the image viewwith the new thumbnail.Along with the Image Preparation APIs,it's much easier to accelerate imagesand avoid hitchesin any app with iOS 15.When working with images,focus on having an asynchronous APIthat can update the UI when an image is ready.In the meantime, use a placeholder image,which is small or cheap enoughto display synchronously.When used with prefetching and reconfigureItems,showing asynchronous content in collection and list viewshas never been easier or more performant.To get started with fast collection and table views,first, build your app with the iOS 15 SDKto unlock many new optimizations.Particularly, ensure you validate the behaviorof your collection and table viewswith the new prefetching.All the new APIs demonstrated herecan be found in the sample code for this talk.Check it out and make sure to adopt the image preparationand resizing APIs across your app.This will ensure your collectionand table views are blazing fast.Thanks for watching.[upbeat music]

♪ ♪Hello, I'm Aditya Krishnadevan,an engineer on the UIKit team.At the core of many apps are lists or collection views.Having super-smooth scrolling is a big partof making those apps feel great.This video will set you up for successwhen making blazing-fast lists and collection views.We'll build this app here that uses collection viewsto display a list of image posts of some great travel destinations.It's fairly simple at first glance,with a photo of the destination and a couple of text labels.Throughout this video, we'll talk about how it's set upand how it achieves the performance that people expect.First, we'll learn how to startfrom a strong foundation when using APIs,like diffable data source and cell registrations.We'll refresh our understanding of the life cycleof a collection view cell.We'll then talk about why you might not see perfectly-smooth scrolling,and some advances in prefetching that can help.Finally, Patrick will explain how to correctly update cellswhen their content comes in asynchronously,and how to use new UIImage APIto get the absolute best scrolling performance on all devices.Okay.Let's begin by talkingabout how the app structures its data.The sample app retrieves a list of posts for display,where each post is representedby this DestinationPost struct.DestinationPost conforms to identifiable,which means it has this ID propertythat stores its identifier.This is a unique identifier for each DestinationPostthat remains stable even if other properties change.Diffable data source is built to storeidentifiers of items in your model,and not the model objects themselves.So, in the sample app, the diffable data source is populatedusing the ID property here,and not the DestinationPost itself.Here's the diffable data source used in the app.Like we just discussed, it uses the DestinationPost.ID typefor its item identifiers.The Section type here is an enum with one case,as the app has only one section.To populate the data source,the app first creates an empty snapshotand appends the main section.Then, it fetches all the posts from its backing storeand appends their identifiers.This way, if one of the other propertiesof a DestinationPost changes,its representation in diffable data source remains stable,as the identifier does not change.The final step is to apply the snapshot to the data source.Before iOS 15, applying a snapshot without animationwould be translated to a reloadData internally.That wasn't great for performance,as the collection view had to discardand recreate all the cells on screen.From iOS 15 onwards, applying a snapshot without animationwill only apply the differencesand not perform any extra work.With iOS 15, diffable data source also gainsa new reconfigureItems method that makes it very easyto update the contents of visible cells.We'll go through how it works later in this video.First, let's get the data from our data sourceinto cells and onto the screen.Cell registrations are a great wayto keep all the configuration for each type of cell in one place,and they give us convenient accessto the identifiers from diffable data source.UICollectionView maintains a reuse queuefor each of instance of a registration,so ensure that you create registrationsonly once for each type of cell.Here's a simplified registration for cells in the app.The postID that's passed inis used to retrieve a DestinationPostand an asset object containing the image.The properties from the DestinationPost are usedto set the title and image in the cell.To use a registration,call dequeueConfiguredReusableCellinside the data source's cell provider.Note how the registration is created outside the cell providerand then used inside.This is important for performance,as creating a registration inside the provider would meanthat the collection view would never reuse any of its cells.Now that we understand how to configure a cell,we'll move on to when a cell is configuredand what its life cycle is like.The life of a cell is composed of two phases:preparation and display.The first step for preparationis fetching the cell to work on.Whenever UICollectionView needs a cell,it asks for one from its data source.If this is a diffable data source,it runs the cell provider and returns the result.When the cell provider runs, the collection view is askedto dequeue a new cell using a registration.If a cell exists in the reuse pool,UICollectionView will call prepareForReuse on it,and then dequeue the cell.If the reuse pool is empty,it will initialize a new cell.That cell is then passed into the configuration handler from the registration.This is where apps set up the cell for displayfor a given item identifier and index path.The configured cell is returned to the collection view for the next step.

The collection view queries the cell for its preferred layout attributesand sizes the cell appropriately.At this point, the cell is fully preparedand ready for phase two: display.willDisplayCell is called on the delegate,and the cell is made visible inside the UICollectionView.The cell is now on screen.There are no more changes to its life cyclewhile it remains visible.When it is scrolled off screen,didEndDisplaying is called for the cell,and it ends up right back in the reuse pool.From the reuse pool, a cell can be dequeued again,repeating this process.Let's now check what the app feels like with these basics in place.The app is featuring Cusco in Peru,and Saint Lucia in the Caribbean.Let's scroll through the app and see some other destinations,but notice how it doesn't scroll smoothly.

These interruptions during scrolling are called "hitches."To understand what causes a hitch,let's first learn how an app updates the display.For each frame,events such as touches are delivered to an app.In response, it updates the properties of its views and layers.For example, a scroll view's contentOffsetwill change during a pan gesture,changing the on-screen location of all the views it contains.As a result of those changes,the app's views and layers perform layout.This process is called a "commit."Then, the layer tree is sent to the render server.Each frame has a commit deadline.This is the time by which all commitsfor that frame need to finish.The amount of time an app has to commit for each framedepends on the refresh rate of the display.For example, on an iPad Pro runningat a higher refresh rate of 120 Hz,apps have less time to finish work for each framecompared to an iPhone running at 60 Hz.Here's a typical example of scrolling a list of cellsin a collection or table view.When a new cell becomes visible, there's a longer commit,during which the new cell is configured and performs layout.Then, there's a couple frames where it's just the existing cellsbeing moved around on screen.The commits for these frames are quickbecause no new cells are needed.Eventually, the scroll position changes enoughto cause a new cell to become visible,and this pattern repeats.So what causes hitches like in the demo earlier?When the commit for a frame takes too long and misses the deadline,those updates don't get incorporated into the intended frame.The display keeps the previous frame on screenuntil the commit finishes, and this delayed frame can render.This is a commit hitchand is perceived as a momentary interruption when scrolling.

To learn more about this and other types of hitches,watch the "Explore UI animation hitches" video.To help avoid these hitches,UICollectionView and UITableViewboth have a brand-new cell prefetching mechanism in iOS 15.

We're back here to the example of an expensive cellcausing a hitch during scrolling.A key takeaway from this isthat you typically don't need a cell every frame.We have a couple of frames with very short commitsdoing minimal work.Cell prefetching in iOS 15 takes advantage of this spare timeby preparing the next cell right after finishing a short commit.

Then, when the cell is eventually needed,it's just a matter of making it visible.That's why the commit for the framewhere the prefetched cell becomes visible is very quick,because all of the work was done earlier.The amount of time spent prefetching the cell is the sameas when it causing a hitch.But because we're able to get a head-start,we're able to avoid a hitch.Let's understand why this worksby stepping through each commit.Before the prefetching happened,we performed the commit for this frame.Since no cells were needed, it was a quick commit,and it finished with lots of time left before the deadline.Instead of just waiting around until the next frame,in iOS 15, the system recognizes the situationand uses the spare timeto start prefetching the next cell.Now, the following frame is where things get interesting.Because the cell being prefetched is expensive,it actually causes the commit for that frameto start later than normal.However, even though that commit starts late,it still finishes well before its deadlinebecause it's quick.Compare this to the illustration we saw earlierwithout prefetching.Notice how there are no longer any commits missing deadlines,and so, there are no more hitches with cell prefetching.This means that your apps get up to twice the amount of timeto prepare each cell, without causing any hitches.What's more, all you need to doto get this great new functionality isto build your app with the iOS 15 SDK.When I last ran the demo,the app was built with the iOS 14 SDK.Let's check out scrolling in the appwhen built with the iOS 15 SDK.

This is great!Looks like prefetching is doing exactly what we'd want.Scrolling is now perfectly smooth,and we didn't have to change a single line of code.

Remember, all you need to do isto build your app using the iOS 15 SDK.For UICollectionView, this new prefetching expandson what was introduced in iOS 10.Cell prefetching is now supported for lists,as well as all other compositional layouts.This great new prefetching is noweven enabled in UITableView.Prefetching can improve scrolling performance by eliminating hitches,but it will also reduce power usage and increase battery life.If your cells are quick to prepare, the system can use the extra time to runin a more energy-efficient state and still avoid hitches.So, even if you don't notice any hitches,it's still very important to make your cell configurationand layout implementations as efficient as possible.Let's now talk about how prefetching affects cell life cycle.This is the life cycle we talked about earlier,without prefetching, with the two distinct phases.When a cell is prefetched, it is the preparation phasethat is executed ahead of the cell being required on-screen.To take full advantage of prefetching,a cell must be fully configured in this phase.Don't wait until a cell is visible to perform any heavy work.When a cell returns to the collection view,it is sized to get its preferred layout attributes,also as part of the prefetch.After being prefetched, there is now this in-between state,where a cell is waiting to be displayed.Given this new phase,there are two important considerations for apps.It is possible for a prepared cell to never be displayed,which could happen if the user suddenly changed the scroll direction.Then, once a cell is displayed,it can go right back into the waiting stateafter it goes off screen.The same cell can be displayed more than once for the same index path.It's no longer the case that a cell will be immediately addedto the reuse pool when it ends displaying.Prefetching helps us achieve smooth scrolling,but only because it gives us more time.On other devices with a higher frame rate,it's still possible that the app is going to have hitches during scrolling.Patrick will now give you more detailabout how the app configures its cells,and also talk about strategiesto reduce the amount of time per commitwhen displaying images.Thanks, Adi.Hi, I'm Patrick from the High-Level Performance team.Now, I'll guide us throughupdating existing cells in the sample app,and then how to display imageswith the best-possible performance,utilizing some new APIs in iOS 15.The sample app was built with local image files on disk.As we scroll the app, the cells are prepared off screen,and the images within them are loadedfrom the file system immediately.Now, we wan display images stored on a remote server.So, when cells scroll in,we may not have the image to show in the image view.When the image view is first visible, it will be blankand only filled in once the server request completes.Let's take a look at extendingour registration's configuration handlerto support this new approach.Here in the registration's configuration handler,we already fetched the asset from the asset store.The store will always return an image,but it may not be the full asset.It might need to be downloaded.The asset object indicates thiswith the isPlaceholder property.When this is true,we will ask the asset store to download the full image.When the load operation completes,it's time to update the cell's image view.Here, we take the existing cell objectand set the asset on its image view.This is a mistake.Cells are reused for different destinations,and by the time the asset store loads the final asset,the cell object we have capturedcould be configured for a different post.Instead of updating the cell directly,we must inform the collection view's data sourceof the needed update.

iOS 15 introducesthe reconfigureItems snapshot method.Calling reconfigureItems on a prepared cellwill rerun its registration's configuration handler.Use this instead of reloadItemsbecause it reuses the item's existing cell,rather than dequeuing and configuring a new cell.In our sample app,we'll declare a setPostNeedsUpdate method,which calls reconfigureItems on the ID passed in.

Now, back in our registration's configuration handler,when the image is a placeholder,we will download the full-size assetand call the new method.reconfigureItems will then call this handler again,but now, fetchByID will return the full assetand not the placeholder.This allows us to keep all our view-updating codein one place and asynchronously update our cellsonce we have data.To maximize prepare time,we can also use our downloadAsset methodinside our prefetchingDataSource.Data-source prefetching is a great placeto kick off network downloads for a collection-view item.It gives more time to download the asset and have it readybefore the cell is visible,reducing the time users see placeholder content.

Let's take a look at how this looks in our app.It looks fine,but there are visible hitches while scrolling.They also appear to coincidewith when new images are displayed.When a new cell is prepared, there is no hitching.It's only when an image is updatedwith the full-resolution image that we hitch.That's because all images take time to decode for display,and some images,like the larger non-placeholder assets,are too large to be decoded in time for display.When the cell registration's configuration handleris first called and the asset is a placeholder,the code begins an async requestfor the full-size imageand completes its configuration.When the asset is finally downloaded later,the cell configuration handler is rerunwith the final image.When an image view tries to commit a new image,it must first prepare the image for displayon the main thread.This can take a long time, and there's a hitchwhen the app missed its commit deadline.Image preparation is a mandatory processthat all images must undergo to be displayed.

The render servercan only display images that are bitmaps,which means they are raw pixel data.Images come in many different formats,like PNG, HEIC, and JPEG,which are compressed and must be processedand unpacked to be displayed.Image views do this processingwhen it commits a new image,and it happens on the main thread.Ideally, we could prepare the image in advanceand only update the UIwhen it's finally completed.That way, we never block the main threadand do not hitch.iOS 15 introducesthe image preparation APIs,giving you control over whereand when image preparation happens.These APIs produce a new UIImage,which only contains the pixel datathat the renderer needs.There is no additional work neededonce it's set on an image view.It comes in two forms: a synchronous one,which you can run on any thread,and asynchronous ones,which run on an internal UIKit serial queue.

To use it, we take a UIImage we've createdand set a placeholder image on our image view.Then, calling the new APIkicks off the preparationin the background on the larger image.When it completes, we can just set it on the image view.Prepared images solve a large problemin any image-heavy app,but they also come with some considerations.The prepared images containthe raw pixel data from the original image.It will remain free to display in an image viewas long as it's retained in memory.But this also means it takes up a lot of memory,and they should be cached sparingly.Finally, because of their format,they are not ideal for disk storage.Instead, save the original asset to disk.One last consideration is howimage preparation can utilize prefetching.Prefetching gives extra timefor the image to be downloaded and prepared.Giving the process more timemeans the users will not see the placeholder for long,and probably not at all.In the sample app,we already have an asynchronous path for image retrieval.After the download completes,we can then prepare the assetbefore calling the completion handler.These assets are large, but also valuable,so once the image is prepared, we want to cache it.Our image cache uses the image's sizeto estimate the memory use of the prepared image.Now, when a cell asks for an asset,we check that cachebefore fetching it from our server.If we had smaller images,we would be able to cache more.Images can be large,and iOS 15 introduces a similar APIfor preparing thumbnails of images.

These can scale and prepare an imageto a smaller size.It ensures that the image is read and processedwith its destination size in mind,saving a lot of CPU time and memory.

You use it just like the Image Preparation APIs.First, take a UIImageand set a placeholder image on the image view.Then, call the new resizing API,with the view's size as the target size for the thumbnail.

When its prepared, just update the image viewwith the new thumbnail.Along with the Image Preparation APIs,it's much easier to accelerate imagesand avoid hitchesin any app with iOS 15.When working with images,focus on having an asynchronous APIthat can update the UI when an image is ready.In the meantime, use a placeholder image,which is small or cheap enoughto display synchronously.When used with prefetching and reconfigureItems,showing asynchronous content in collection and list viewshas never been easier or more performant.

To get started with fast collection and table views,first, build your app with the iOS 15 SDKto unlock many new optimizations.Particularly, ensure you validate the behaviorof your collection and table viewswith the new prefetching.All the new APIs demonstrated herecan be found in the sample code for this talk.Check it out and make sure to adopt the image preparationand resizing APIs across your app.This will ensure your collectionand table views are blazing fast.Thanks for watching.[upbeat music]

1:25 -Structuring data

2:01 -Setting up diffable data source

3:47 -Creating cell registrations

4:03 -Using cell registrations

13:58 -Existing cell registration

14:17 -Updating cells asynchronously (wrong)

15:15 -Reconfiguring items

15:23 -Updating cells asynchronously (correct)

15:52 -Data source prefetching

18:43 -Using prepareForDisplay

19:51 -Asset downloading without image preparation

19:58 -Asset downloading with image preparation

20:50 -Using prepareThumbnail

## Code Samples

```swift
// Structuring data



struct
 
DestinationPost
: 
Identifiable
 
{
    
// Each post has a unique identifier

    
var
 id: 
String

    
    
var
 title: 
String

    
var
 numberOfLikes: 
Int

    
var
 assetID: 
Asset
.
ID

}
```

```swift
// Setting up diffable data source



class
 
DestinationGridViewController
: 
UIViewController
 
{
    
// Use DestinationPost.ID as the item identifier

    
var
 dataSource: 
UICollectionViewDiffableDataSource
<
Section
, 
DestinationPost
.
ID
>
    
    
private
 
func
 
setInitialData
()
 {
        
var
 snapshot 
=
 
NSDiffableDataSourceSnapshot
<
Section
, 
DestinationPost
.
ID
>()
        
        
// Only one section in this collection view, identified by Section.main

        snapshot.appendSections([.main])
        
        
// Get identifiers of all destination posts in our model and add to initial snapshot

        
let
 itemIdentifiers 
=
 postStore.allPosts.map { 
$0
.id }
        snapshot.appendItems(itemIdentifiers)
        
        dataSource.apply(snapshot, animatingDifferences: 
false
)
    }
}
```

```swift
// Cell registrations



let
 cellRegistration 
=
 
UICollectionView
.
CellRegistration
<
DestinationPostCell
,
                                                         
DestinationPost
.
ID
> {
    (cell, indexPath, postID) 
in


    
let
 post 
=
 
self
.postsStore.fetchByID(postID)
    
let
 asset 
=
 
self
.assetsStore.fetchByID(post.assetID)
    
    cell.titleView.text 
=
 post.region
    cell.imageView.image 
=
 asset.image
}
```

```swift
// Cell registrations



let
 cellRegistration 
=
 
UICollectionView
.
CellRegistration
<
DestinationPostCell
,
                                                         
DestinationPost
.
ID
> {
    (cell, indexPath, postID) 
in

    
...

}
   

let
 dataSource 
=
 
UICollectionViewDiffableDataSource
<
Section
.
ID
,
                                                    
DestinationPost
.
ID
>(collectionView: cv){
    (collectionView, indexPath, postID) 
in

  
     
return
 collectionView.dequeueConfiguredReusableCell(using: cellRegistration,
                                                           for: indexPath,
                                                          item: postID)
}
```

```swift
// Existing cell registration



let
 cellRegistration 
=
 
UICollectionView
.
CellRegistration
<
DestinationPostCell
,
                                                         
DestinationPost
.
ID
> {
    (cell, indexPath, postID) 
in


    
let
 post 
=
 
self
.postsStore.fetchByID(postID)
    
let
 asset 
=
 
self
.assetsStore.fetchByID(post.assetID)
    
    cell.titleView.text 
=
 post.region
    cell.imageView.image 
=
 asset.image
}
```

```swift
// Updating cells asynchronously 



let
 cellRegistration 
=
 
UICollectionView
.
CellRegistration
<
DestinationPostCell
,
                                                         
DestinationPost
.
ID
> {
    (cell, indexPath, postID) 
in


    
let
 post 
=
 
self
.postsStore.fetchByID(postID)
    
let
 asset 
=
 
self
.assetsStore.fetchByID(post.assetID)
    
    
if
 asset.isPlaceholder {
        
self
.assetsStore.downloadAsset(post.assetID) { asset 
in

            cell.imageView.image 
=
 asset.image
        }
    }
    
    cell.titleView.text 
=
 post.region
    cell.imageView.image 
=
 asset.image
}
```

```swift
private
 
func
 
setPostNeedsUpdate
(
id
: 
DestinationPost
.
ID
)
 {
    
var
 snapshot 
=
 dataSource.snapshot()
    snapshot.reconfigureItems([id])
    dataSource.apply(snapshot, animatingDifferences: 
true
)
}
```

```swift
// Updating cells asynchronously



let
 cellRegistration 
=
 
UICollectionView
.
CellRegistration
<
DestinationPostCell
,
                                                         
DestinationPost
.
ID
> {
    (cell, indexPath, postID) 
in


    
let
 post 
=
 
self
.postsStore.fetchByID(postID)
    
let
 asset 
=
 
self
.assetsStore.fetchByID(post.assetID)
    
    
if
 asset.isPlaceholder {
        
self
.assetsStore.downloadAsset(post.assetID) { 
_
 
in

            
self
.setPostNeedsUpdate(id: post.id)
        }
    }
    
    cell.titleView.text 
=
 post.region
    cell.imageView.image 
=
 asset.image
}
```

```swift
// Data source prefetching



var
 prefetchingIndexPaths: [
IndexPath
: 
Cancellable
]


func
 
collectionView
(
_
 
collectionView
: 
UICollectionView
,
                    prefetchItemsAt indexPaths [
IndexPath
])
 {
   
// Begin download work

    
for
 indexPath 
in
 indexPaths {
        
guard
 
let
 post 
=
 fetchPost(at: indexPath) 
else
 { 
continue
 }
        prefetchingIndexPaths[indexPath] 
=
 assetsStore.loadAssetByID(post.assetID)
    }
}


func
 
collectionView
(
_
 
collectionView
: 
UICollectionView
,
                    
cancelPrefetchingForItemsAt
 
indexPaths
: [
IndexPath
])
 {
    
// Stop fetching

    
for
 indexPath 
in
 indexPaths {
        prefetchingIndexPaths[indexPath]
?
.cancel()
    }
}
```

```swift
// Using prepareForDisplay



// Initialize the full image


let
 fullImage 
=
 
UIImage
()


// Set a placeholder before preparation

imageView.image 
=
 placeholderImage


// Prepare the full image

fullImage.prepareForDisplay { preparedImage 
in

    
DispatchQueue
.main.async {
       
self
.imageView.image 
=
 preparedImage
    }
}
```

```swift
// Asset downloading – before image preparation



func
 
downloadAsset
(
_
 
id
: 
Asset
.
ID
,
                   
completionHandler
: 
@escaping
 (
Asset
) -> 
Void
)
 -> 
Cancellable
 {
  
    
return
 fetchAssetFromServer(assetID: id) { asset 
in

        
DispatchQueue
.main.async {
            completionHandler(asset)
        }
    }
}
```

```swift
// Asset downloading – with image preparation



func
 
downloadAsset
(
_
 
id
: 
Asset
.
ID
,
                   
completionHandler
: 
@escaping
 (
Asset
) -> 
Void
)
 -> 
Cancellable
 {
    
// Check for an already prepared image

    
if
 
let
 preparedAsset 
=
 imageCache.fetchByID(id) {
        completionHandler(preparedAsset)
        
return
 
AnyCancellable
 {}
    }
    
return
 fetchAssetFromServer(assetID: id) { asset 
in

        asset.image.prepareForDisplay { preparedImage 
in

            
// Store the image in the cache.

            
self
.imageCache.add(asset: asset.withImage(preparedImage
!
))
            
DispatchQueue
.main.async {
                completionHandler(asset)
            }
        }
    }
}
```

```swift
// Using prepareThumbnail



// Initialize the full image


let
 profileImage 
=
 
UIImage
(
...
)


// Set a placeholder before preparation

posterAvatarView.image 
=
 placeholderImage


// Prepare the image

profileImage.prepareThumbnail(of: posterAvatarView.bounds.size) { thumbnailImage 
in

    
DispatchQueue
.main.async {
        
self
.posterAvatarView.image 
=
 thumbnailImage
    }
}
```


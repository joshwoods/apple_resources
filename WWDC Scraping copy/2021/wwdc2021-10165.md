# Wwdc2021 10165

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Explore Nearby Interaction with third-party accessoriesDiscover how your app can interact with Ultra Wideband (UWB) third-party accessories when running on a U1-equipped device. We'll show you how to use the Nearby Interaction framework's standards-based technology to implement precise and directionally-aware experiences with accessories. Learn about resources for getting started with accessory and app development such as development kits, sample code, and specification documents, along with supported technology providers.

To find out more about Nearby Interaction, check out the framework documentation linked as part of this session. And if you're an accessory manufacturer or considering becoming one, be sure to check out the Nearby Interaction accessory specification documents and Getting Started resources.ResourcesMFI ProgramNearby InteractionNearby Interactions with U1HD VideoSD VideoRelated VideosWWDC22What's new in Nearby InteractionWWDC21Design for spatial interactionTuesday@WWDC21WWDC20Meet Nearby Interaction

Discover how your app can interact with Ultra Wideband (UWB) third-party accessories when running on a U1-equipped device. We'll show you how to use the Nearby Interaction framework's standards-based technology to implement precise and directionally-aware experiences with accessories. Learn about resources for getting started with accessory and app development such as development kits, sample code, and specification documents, along with supported technology providers.

To find out more about Nearby Interaction, check out the framework documentation linked as part of this session. And if you're an accessory manufacturer or considering becoming one, be sure to check out the Nearby Interaction accessory specification documents and Getting Started resources.

MFI Program

Nearby Interaction

Nearby Interactions with U1

HD VideoSD Video

HD Video

SD Video

What's new in Nearby Interaction

Design for spatial interaction

Tuesday@WWDC21

Meet Nearby Interaction

Search this video…♪ ♪Hi, my name is Yagil Burowski,and I'm an engineer on the Location Technologies team at Apple.In this talk, I'll cover the latest advancements,as well as the new features that are comingto the Nearby Interaction framework this year.The Nearby Interaction framework makes it easyto take advantage of the unique capabilities of U1,Apple's chip for Ultra-Wideband technology,and enables creating preciseand spatially-aware interactionsbetween nearby devices.It's the same technology that powers"Precision Finding" with AirTagand the fluid handoff gesturesbetween iPhone and HomePod mini.This is what we'll cover in this session.We'll start with updatesto the user permission flow.After that, we'll introduce new APIsfor running Nearby Interaction with compatible third-party hardware.And we'll finish with talkingabout resources for app developers,as well as accessory manufacturers,for getting started with adopting these new APIsin apps and third-party accessories.Before we dive in, for those of you who are new to Nearby Interaction,or just need a refresher, let's quickly recaphow you use the framework in your app.You start with creating a session instance.That's the main object through which you'll configureand run your spatial interactionswith nearby devices.Next, you'll need to designate a part of your appto conform to the NISessionDelegate protocol.The delegate will receive updates from the framework.The next thing you need to do iscreate a configuration object,which will be a subclass of NIConfiguration.For example, you can createa NearbyPeerConfigurationwhen you want start a session between two iPhonesthat are running your app.Once you call run on the sessionwith the configuration you had created,Nearby Interaction will start providing your appa stream of NearbyObject updates,each containing distanceand, optionally, direction,to nearby devicesthat are actively participating in the session.If you're interested in a deeper diveinto the framework's APIs,please watch last year's WWDC talk,"Meet Nearby Interaction."To access data such as distanceor direction to a nearby device,your app needs to get the user's permission.So, let's talk about the improvementsto the user-permission flow we've made this year.This is the Nearby Interaction permission flow in iOS 14.The prompt will appear the first timeyour app runs a sessionin a new app lifetime.The options on the alert,"Don't Allow" or "Allow Once,"provide a very clear choice,but since this permission is one-time,it can also lead to additional promptsin certain situations.So, this year, there's a new way to grant apps permissionto use Nearby Interaction.This is the new "Nearby Interaction"permission prompt in iOS 15.It looks kind of similar, but it's differentin a couple of important ways.The system will automatically show the permission prompton the first time your app runs an NISession.So, it's really important for you to make surethat the timing of when you run your NISessioncoincides with a clear user intent,so it's easy for your users to understandwhy a particular feature in your apprequires access to Nearby Interaction.Let's take a closer lookat the new options on the prompt.The new "OK" option grants your app permissionwhile the app is in use.Whether the user accepts or deniesyour app's request to use Nearby Interaction,the permission prompt will not show again.Starting in iOS 15,apps that use Nearby Interactionwill appear in Settings.So, if users ever change their minds,they can head over to the Settings appand change your app's "Nearby Interaction" access.Make sure to test for this scenario when developing your app.Let's summarize the new Nearby Interaction user permission model.The new permission prompt, when accepted,gives your app persistent permissionto use Nearby Interaction while the app is in use.The alert will present a usage description string,provided by youin your app's Info.plist.In this purpose string, be clear and concise,and explain what are the awesome features in your appthat need access to Nearby Interaction.After the prompt shows for the first and final time,your app's name and icon will appear in the Settings app,which means that users can changeyour app's permission state at any time.When your app does not have sufficient permission to use Nearby Interaction,your NISessions will be invalidatedwith a permission-related error code.So, if a key functionality in your app relies on accessto Nearby Interaction, be sure to explain this clearlyto your users and guide themto the Settings app when appropriate.That was the new permission prompt in iOS 15.And now, we're excited to introduce some new APIsthat make it possible to use Nearby Interactionwith compatible third-party hardware.We wanted this API to workwith a wide range of accessories you may consider building.So, we based Nearby Interaction'sthird-party hardware supporton standards we've been working on with industry groups.And to help you get started on prototyping, experimenting,and building your accessories,we've worked with the chipset manufacturers,who are making available development kitscontaining hardware and firmwarethat is able to interoperatewith U1 in iPhone.So, alongside development kits,we're also making available sample app codethat works out-of-the-boxwith the hardware in the development kits.So, together, they can serveas an excellent starting point for your project.And if you're an accessory manufacturer,please check out the Nearby Interaction,Accessory Protocol Specification documentthat will be available to you in "Developer Preview"on the Apple developer website.Whether you just want to tinker with this exciting new technology,or you're ready to integrate Ultra Widebandinto your very own accessory,let's look at a simple examplethat illustrates how you usethe Nearby Interaction APIwith a third-party accessory.Enabling different functionalitybased on the user's precise distance to an accessorycan be a powerful wayto streamline interactions with that device.So, let's say that you're building an accessory,and you want to integrate Ultra Wideband into it,to enable a set of featuresthat will really make it stand out.And since Ultra Wideband can give you precise distance,you're planning to utilize it to keep trackof a couple of precise zonesor regions around the accessory.So, let's say that you define a regionaround the accessory that has a 1.5-meter radius,and another, larger one with a 3-meter radius.And let's say that you care about these specific distancesbecause, when the user entersthe larger region around the accessory,you want to enable some functionality A.And when the user enters the smaller region,you want to enable functionality B.So, how do you actually achieve this in your appusing the Nearby Interaction framework?First of all, Nearby Interaction expects your appand your accessory to have some sortof capability to exchange data between them.As for the particular technologyto use to exchange data,that is entirely up to you and what your accessory doesand does not need to do.Suppose your accessory already supports Bluetooth.This will put you in a great spotbecause you'll be able to utilize your existing Bluetooth capabilityfor your data exchange requirement.If your accessory is connected to the local networkor is securely connected to the internet,you're in great shape, too.That capability to send data back and forth between the appand the accessory will serve you for what you'll need to do next.Recall that when we wanted to start a sessionbetween two iPhones running your app,we created a NearbyPeerConfiguration.To start a session with an accessory,we'll create a NearbyAccessoryConfiguration.This is a new NIConfiguration typein iOS 15.To instantiate an Accessory Configuration,we need to provide it some configuration data,describing the accessorythat the framework expects to receivein a particular formatcalled Accessory Configuration Data.But how do we get this configuration data,and what is this particular format?U1-compatible Ultra-Wideband hardware,like the types you'll be able to getfrom certified technology providers,will know how to generate this configuration dataupon request.This means that code you're runningon the accessory itselfwill need to generate this dataand then send it over to your appon your data channel.Let's look at a code examplefor instantiating a NearbyAccessoryConfigurationwith data received from an accessory.Let's assume that setupAccessoryis a helper method I wrote in my app.Whenever I get the Accessory Configuration Datafrom an accessory, there's logic in my appthat routes it to this function,along with the accessory's name.At this point, I can createan NINearbyAccessoryConfigurationusing the data I received from the accessory.You'll notice that I create my configurationinside a do/catch statement.I do this because if the dataI received from the accessory is invalid in some way,the NIConfiguration init methodwill throw an exception.But if the configuration object is created successfully,it means that the data I received from the accessory isin the right format and can now be used.The ultimate reason for creating a configurationis for using it to run a session.But before I do that, there's a good opportunity for meto cache some useful data for later use.The new NearbyAccessoryConfiguration typehas a DiscoveryToken property for the accessorythat the framework automatically populates.In addition, in the setupAccessory function I defined,I also have the accessory's name.So, it could be really useful to save the discovery tokenalongside the accessory's name at this stagebecause, later on, when I start receivingNearbyObject updates about this accessory,I would be able to use the token and the nameto correlate the updates back to this accessory,and then display more relevant and rich UI.Okay.So, we have valid configuration data from the accessory,and we used it to createan accessory configuration object.Now, we can get ready to interact with this accessory.To manage the interaction,we'll need an NISession instance,and we'll need to set the session's delegate.To start the session, we simply callthe "run" function on the session,using the accessory configuration object we created.Just like Nearby Interaction needed configuration datafrom the accessory, the accessory also needsconfiguration data from Nearby Interactionin order to know how to configure itself.This data needs to be in a formatcalled "Shareable Configuration Data."When you run a session with an accessory configuration,Nearby Interaction will providethe Shareable Configuration Datato your app through a delegate callback.And just like we used the data channelto receive the accessory's configuration data,here, we'll use it againto send the shareable configuration databack to the accessory.To make things more concrete,let's look at a code example.Shareable Configuration Data is provided to your appthrough the didGenerate delegate callback,which is a new delegate callback in iOS 15.Here is a possible implementation of this callback in an app.The framework provides the Shareable Configuration Data,and also indicates which accessory it should go to,which is really useful in case you're interactingwith multiple accessories.You should plan to send the data to the accessoryas soon as possible over your data channel.On a general note, managing data connectionsto different accessories can take on many different forms,all depending on your use case.For simplicity,let's say that in my app's architecture,I chose to keep an independent data connectionfor each accessory I'm interacting with.And to keep my code nicely organized,I defined a helper functionthat gives me back a connectionbased on the NearbyObject I give it.Once I get a reference to the connection,I'll use it to send the Shareable Configuration Datato the accessory right away.It's important to optimize your appfor sending the shareable configuration datato the accessory with as little delay as possible.If the ShareableConfigurationData is not sent quickly enough,your session may timeout.A timeout in a session with an accessorywill be communicated to your appthrough the didRemove delegate callback.Let's look at how you might handle this scenario.When Nearby Interaction gives me the didRemove callback,shown on the screen,I'll first check the "reason" parameter.If the reason is .timeout,and I have high confidencethat the accessory may still be nearby,I can attempt to retry to interact with it.To decide whether or not I should gointo a "retry flow" with this accessory,I defined a helper functionthat contains specialized logicthat helps me make this decision.You can imagine that conditions like"How many times have I retried without being successful?"or "Has the accessory notified me it has stopped?"or other similar questions can be a part of decisions like this.If I do decide to retry,all I have to do is run the session againwith the same configuration.Keep in mind, that the cached configurationwill only remain valid as long as the sessionon the accessory was not terminated.If the session was terminated,I'll have to go through the same flowI used to create and run the session the first time.Keep in mind that sessions on the accessoryis something the code running on the accessory has to manage,and can be done in many different ways,all depending on your use case.Okay.You sent the Shareable Configuration Data to your accessory,and you even have logic to handle retries if needed.What's next?Just like with the Accessory Configuration DataU1-compatible hardware in the accessorywill automatically know what to dowith the Shareable Configuration Dataonce your accessory code provides it to it.So, once the code running on the accessory receives the data,it needs to provide it as-is,and as quickly as possible,to the Ultra-Wideband hardware on board.You might be wondering--how will the Ultra-Wideband hardware in the accessoryknow to generate or consume the configuration data?Both the Accessory Configuration Dataand the Shareable Configuration Dataare defined in a specification documentwe published earlier this spring.The document is intendedfor chipset and module manufactures,and it contains the necessary detailsfor creating Ultra-Wideband solutionsthat use industry standardsto interoperate with U1 in iPhone.On top of the interoperability specificationfor chipset manufacturers,we are also releasing a specificationtargeted at accessory manufacturers.So, if you're hoping to build an accessorythat contains Ultra-Wideband hardware,and you want to interact with itusing the Nearby Interaction framework in your app,this document is for you.You'll find it on the developer website,alongside additional resourcesfor getting started.This is where we left off.We had just sent the Shareable Configuration Datato the accessory over the data channel.Now, let's see what happensonce the code on the accessory receives it,and provides it to the Ultra-Wideband hardware.After receiving the shareable configuration data,the Ultra-Wideband hardware on the accessorywill immediately start runningin the appropriate configurationfor interacting with the NISession in your app.And if both the accessory and the iPhone running your appare nearby one another,the session will start providing your appa stream of NearbyObject updates,containing distance and, optionally,direction to the accessory.You can even interact with several accessories simultaneously,by creating and running a session for each one.Depending on the hardware features on the accessory,you may also be able to get equivalent proximity updatesin the code running on the accessory.Once you get NearbyObject updates from the framework,what do you do with them?As a reminder, we wanted to build an experiencein which the app and the accessoryenable functionality Awhen the user enters the larger region,and enable functionality Bwhen the user enters the smaller region around the accessory.Let's look at a code example that shows how you could do thisusing NearbyObject updates in your iOS app.When the session between the app and the accessory is running,updates about the accessory are delivered to the session's delegatethrough the didUpdate delegate callback.First, I'll grab a reference to the nearby objectfor which the framework is giving me an update.Next, I'll create a local variablewith the distance to this object,which the framework is providing in meters.The next thing I'll do is provide this datato a helper function I have in my appI called getSmoothedDistance.I defined this function in my appto help me guard against rapid changesin the distance.For example, in cases where the usermakes sudden movements,or they happen to be standingon the boundary between the zones.Lastly, I can check to seeif the user's distance from the accessorycrossed my predefined thresholds.Here, I can choose to enableFunctionalityAor FunctionalityB based on the current distance.If you're interested in learning more about designing experiencesbased on distance and direction between devices,check out the "Design for Spatial Interaction"WWDC talk from this year.So, let's summarize what we discussed in this session.We talked about how the new permission model allows your appto access Nearby Interaction while the app is in use.We took a deep dive into the brand-new worldof Nearby Interaction-enabled third-party accessories,and what APIs you can useto build spatial interactions with your very own accessory.We also discussed third-party development kits,available from supported technology providers,and iOS app code that you can use to get startedwith your project right away.So, go on ahead, give it a try,and start experimenting and prototyping your use cases.And when you're ready to adopt Ultra Wideband in your accessory,read the relevant specification documents,available on the Apple developer website.That's it for this year's Nearby Interaction updates.Thanks for tuning in.We hope this session was helpfuland contained all the information you needto get started with building some amazing apps and accessories.[upbeat music]

♪ ♪Hi, my name is Yagil Burowski,and I'm an engineer on the Location Technologies team at Apple.In this talk, I'll cover the latest advancements,as well as the new features that are comingto the Nearby Interaction framework this year.The Nearby Interaction framework makes it easyto take advantage of the unique capabilities of U1,Apple's chip for Ultra-Wideband technology,and enables creating preciseand spatially-aware interactionsbetween nearby devices.It's the same technology that powers"Precision Finding" with AirTagand the fluid handoff gesturesbetween iPhone and HomePod mini.This is what we'll cover in this session.We'll start with updatesto the user permission flow.After that, we'll introduce new APIsfor running Nearby Interaction with compatible third-party hardware.

And we'll finish with talkingabout resources for app developers,as well as accessory manufacturers,for getting started with adopting these new APIsin apps and third-party accessories.Before we dive in, for those of you who are new to Nearby Interaction,or just need a refresher, let's quickly recaphow you use the framework in your app.You start with creating a session instance.That's the main object through which you'll configureand run your spatial interactionswith nearby devices.Next, you'll need to designate a part of your appto conform to the NISessionDelegate protocol.The delegate will receive updates from the framework.

The next thing you need to do iscreate a configuration object,which will be a subclass of NIConfiguration.For example, you can createa NearbyPeerConfigurationwhen you want start a session between two iPhonesthat are running your app.Once you call run on the sessionwith the configuration you had created,Nearby Interaction will start providing your appa stream of NearbyObject updates,each containing distanceand, optionally, direction,to nearby devicesthat are actively participating in the session.

If you're interested in a deeper diveinto the framework's APIs,please watch last year's WWDC talk,"Meet Nearby Interaction."To access data such as distanceor direction to a nearby device,your app needs to get the user's permission.

So, let's talk about the improvementsto the user-permission flow we've made this year.This is the Nearby Interaction permission flow in iOS 14.The prompt will appear the first timeyour app runs a sessionin a new app lifetime.The options on the alert,"Don't Allow" or "Allow Once,"provide a very clear choice,but since this permission is one-time,it can also lead to additional promptsin certain situations.So, this year, there's a new way to grant apps permissionto use Nearby Interaction.This is the new "Nearby Interaction"permission prompt in iOS 15.It looks kind of similar, but it's differentin a couple of important ways.The system will automatically show the permission prompton the first time your app runs an NISession.So, it's really important for you to make surethat the timing of when you run your NISessioncoincides with a clear user intent,so it's easy for your users to understandwhy a particular feature in your apprequires access to Nearby Interaction.Let's take a closer lookat the new options on the prompt.The new "OK" option grants your app permissionwhile the app is in use.Whether the user accepts or deniesyour app's request to use Nearby Interaction,the permission prompt will not show again.

Starting in iOS 15,apps that use Nearby Interactionwill appear in Settings.So, if users ever change their minds,they can head over to the Settings appand change your app's "Nearby Interaction" access.Make sure to test for this scenario when developing your app.

Let's summarize the new Nearby Interaction user permission model.

The new permission prompt, when accepted,gives your app persistent permissionto use Nearby Interaction while the app is in use.

The alert will present a usage description string,provided by youin your app's Info.plist.In this purpose string, be clear and concise,and explain what are the awesome features in your appthat need access to Nearby Interaction.

After the prompt shows for the first and final time,your app's name and icon will appear in the Settings app,which means that users can changeyour app's permission state at any time.When your app does not have sufficient permission to use Nearby Interaction,your NISessions will be invalidatedwith a permission-related error code.So, if a key functionality in your app relies on accessto Nearby Interaction, be sure to explain this clearlyto your users and guide themto the Settings app when appropriate.That was the new permission prompt in iOS 15.

And now, we're excited to introduce some new APIsthat make it possible to use Nearby Interactionwith compatible third-party hardware.We wanted this API to workwith a wide range of accessories you may consider building.So, we based Nearby Interaction'sthird-party hardware supporton standards we've been working on with industry groups.

And to help you get started on prototyping, experimenting,and building your accessories,we've worked with the chipset manufacturers,who are making available development kitscontaining hardware and firmwarethat is able to interoperatewith U1 in iPhone.So, alongside development kits,we're also making available sample app codethat works out-of-the-boxwith the hardware in the development kits.So, together, they can serveas an excellent starting point for your project.

And if you're an accessory manufacturer,please check out the Nearby Interaction,Accessory Protocol Specification documentthat will be available to you in "Developer Preview"on the Apple developer website.Whether you just want to tinker with this exciting new technology,or you're ready to integrate Ultra Widebandinto your very own accessory,let's look at a simple examplethat illustrates how you usethe Nearby Interaction APIwith a third-party accessory.Enabling different functionalitybased on the user's precise distance to an accessorycan be a powerful wayto streamline interactions with that device.So, let's say that you're building an accessory,and you want to integrate Ultra Wideband into it,to enable a set of featuresthat will really make it stand out.And since Ultra Wideband can give you precise distance,you're planning to utilize it to keep trackof a couple of precise zonesor regions around the accessory.So, let's say that you define a regionaround the accessory that has a 1.5-meter radius,and another, larger one with a 3-meter radius.And let's say that you care about these specific distancesbecause, when the user entersthe larger region around the accessory,you want to enable some functionality A.And when the user enters the smaller region,you want to enable functionality B.

So, how do you actually achieve this in your appusing the Nearby Interaction framework?First of all, Nearby Interaction expects your appand your accessory to have some sortof capability to exchange data between them.

As for the particular technologyto use to exchange data,that is entirely up to you and what your accessory doesand does not need to do.Suppose your accessory already supports Bluetooth.This will put you in a great spotbecause you'll be able to utilize your existing Bluetooth capabilityfor your data exchange requirement.If your accessory is connected to the local networkor is securely connected to the internet,you're in great shape, too.That capability to send data back and forth between the appand the accessory will serve you for what you'll need to do next.

Recall that when we wanted to start a sessionbetween two iPhones running your app,we created a NearbyPeerConfiguration.To start a session with an accessory,we'll create a NearbyAccessoryConfiguration.

This is a new NIConfiguration typein iOS 15.To instantiate an Accessory Configuration,we need to provide it some configuration data,describing the accessorythat the framework expects to receivein a particular formatcalled Accessory Configuration Data.But how do we get this configuration data,and what is this particular format?U1-compatible Ultra-Wideband hardware,like the types you'll be able to getfrom certified technology providers,will know how to generate this configuration dataupon request.This means that code you're runningon the accessory itselfwill need to generate this dataand then send it over to your appon your data channel.Let's look at a code examplefor instantiating a NearbyAccessoryConfigurationwith data received from an accessory.Let's assume that setupAccessoryis a helper method I wrote in my app.Whenever I get the Accessory Configuration Datafrom an accessory, there's logic in my appthat routes it to this function,along with the accessory's name.At this point, I can createan NINearbyAccessoryConfigurationusing the data I received from the accessory.You'll notice that I create my configurationinside a do/catch statement.I do this because if the dataI received from the accessory is invalid in some way,the NIConfiguration init methodwill throw an exception.But if the configuration object is created successfully,it means that the data I received from the accessory isin the right format and can now be used.The ultimate reason for creating a configurationis for using it to run a session.But before I do that, there's a good opportunity for meto cache some useful data for later use.The new NearbyAccessoryConfiguration typehas a DiscoveryToken property for the accessorythat the framework automatically populates.In addition, in the setupAccessory function I defined,I also have the accessory's name.So, it could be really useful to save the discovery tokenalongside the accessory's name at this stagebecause, later on, when I start receivingNearbyObject updates about this accessory,I would be able to use the token and the nameto correlate the updates back to this accessory,and then display more relevant and rich UI.

Okay.So, we have valid configuration data from the accessory,and we used it to createan accessory configuration object.Now, we can get ready to interact with this accessory.

To manage the interaction,we'll need an NISession instance,and we'll need to set the session's delegate.To start the session, we simply callthe "run" function on the session,using the accessory configuration object we created.

Just like Nearby Interaction needed configuration datafrom the accessory, the accessory also needsconfiguration data from Nearby Interactionin order to know how to configure itself.This data needs to be in a formatcalled "Shareable Configuration Data."When you run a session with an accessory configuration,Nearby Interaction will providethe Shareable Configuration Datato your app through a delegate callback.And just like we used the data channelto receive the accessory's configuration data,here, we'll use it againto send the shareable configuration databack to the accessory.To make things more concrete,let's look at a code example.Shareable Configuration Data is provided to your appthrough the didGenerate delegate callback,which is a new delegate callback in iOS 15.

Here is a possible implementation of this callback in an app.The framework provides the Shareable Configuration Data,and also indicates which accessory it should go to,which is really useful in case you're interactingwith multiple accessories.You should plan to send the data to the accessoryas soon as possible over your data channel.On a general note, managing data connectionsto different accessories can take on many different forms,all depending on your use case.For simplicity,let's say that in my app's architecture,I chose to keep an independent data connectionfor each accessory I'm interacting with.And to keep my code nicely organized,I defined a helper functionthat gives me back a connectionbased on the NearbyObject I give it.Once I get a reference to the connection,I'll use it to send the Shareable Configuration Datato the accessory right away.It's important to optimize your appfor sending the shareable configuration datato the accessory with as little delay as possible.If the ShareableConfigurationData is not sent quickly enough,your session may timeout.A timeout in a session with an accessorywill be communicated to your appthrough the didRemove delegate callback.Let's look at how you might handle this scenario.

When Nearby Interaction gives me the didRemove callback,shown on the screen,I'll first check the "reason" parameter.If the reason is .timeout,and I have high confidencethat the accessory may still be nearby,I can attempt to retry to interact with it.

To decide whether or not I should gointo a "retry flow" with this accessory,I defined a helper functionthat contains specialized logicthat helps me make this decision.You can imagine that conditions like"How many times have I retried without being successful?"or "Has the accessory notified me it has stopped?"or other similar questions can be a part of decisions like this.

If I do decide to retry,all I have to do is run the session againwith the same configuration.Keep in mind, that the cached configurationwill only remain valid as long as the sessionon the accessory was not terminated.If the session was terminated,I'll have to go through the same flowI used to create and run the session the first time.Keep in mind that sessions on the accessoryis something the code running on the accessory has to manage,and can be done in many different ways,all depending on your use case.

Okay.You sent the Shareable Configuration Data to your accessory,and you even have logic to handle retries if needed.What's next?Just like with the Accessory Configuration DataU1-compatible hardware in the accessorywill automatically know what to dowith the Shareable Configuration Dataonce your accessory code provides it to it.

So, once the code running on the accessory receives the data,it needs to provide it as-is,and as quickly as possible,to the Ultra-Wideband hardware on board.You might be wondering--how will the Ultra-Wideband hardware in the accessoryknow to generate or consume the configuration data?Both the Accessory Configuration Dataand the Shareable Configuration Dataare defined in a specification documentwe published earlier this spring.The document is intendedfor chipset and module manufactures,and it contains the necessary detailsfor creating Ultra-Wideband solutionsthat use industry standardsto interoperate with U1 in iPhone.

On top of the interoperability specificationfor chipset manufacturers,we are also releasing a specificationtargeted at accessory manufacturers.So, if you're hoping to build an accessorythat contains Ultra-Wideband hardware,and you want to interact with itusing the Nearby Interaction framework in your app,this document is for you.You'll find it on the developer website,alongside additional resourcesfor getting started.This is where we left off.We had just sent the Shareable Configuration Datato the accessory over the data channel.Now, let's see what happensonce the code on the accessory receives it,and provides it to the Ultra-Wideband hardware.

After receiving the shareable configuration data,the Ultra-Wideband hardware on the accessorywill immediately start runningin the appropriate configurationfor interacting with the NISession in your app.And if both the accessory and the iPhone running your appare nearby one another,the session will start providing your appa stream of NearbyObject updates,containing distance and, optionally,direction to the accessory.You can even interact with several accessories simultaneously,by creating and running a session for each one.Depending on the hardware features on the accessory,you may also be able to get equivalent proximity updatesin the code running on the accessory.Once you get NearbyObject updates from the framework,what do you do with them?As a reminder, we wanted to build an experiencein which the app and the accessoryenable functionality Awhen the user enters the larger region,and enable functionality Bwhen the user enters the smaller region around the accessory.Let's look at a code example that shows how you could do thisusing NearbyObject updates in your iOS app.

When the session between the app and the accessory is running,updates about the accessory are delivered to the session's delegatethrough the didUpdate delegate callback.First, I'll grab a reference to the nearby objectfor which the framework is giving me an update.Next, I'll create a local variablewith the distance to this object,which the framework is providing in meters.The next thing I'll do is provide this datato a helper function I have in my appI called getSmoothedDistance.I defined this function in my appto help me guard against rapid changesin the distance.For example, in cases where the usermakes sudden movements,or they happen to be standingon the boundary between the zones.Lastly, I can check to seeif the user's distance from the accessorycrossed my predefined thresholds.Here, I can choose to enableFunctionalityAor FunctionalityB based on the current distance.

If you're interested in learning more about designing experiencesbased on distance and direction between devices,check out the "Design for Spatial Interaction"WWDC talk from this year.

So, let's summarize what we discussed in this session.

We talked about how the new permission model allows your appto access Nearby Interaction while the app is in use.

We took a deep dive into the brand-new worldof Nearby Interaction-enabled third-party accessories,and what APIs you can useto build spatial interactions with your very own accessory.We also discussed third-party development kits,available from supported technology providers,and iOS app code that you can use to get startedwith your project right away.So, go on ahead, give it a try,and start experimenting and prototyping your use cases.

And when you're ready to adopt Ultra Wideband in your accessory,read the relevant specification documents,available on the Apple developer website.That's it for this year's Nearby Interaction updates.Thanks for tuning in.We hope this session was helpfuland contained all the information you needto get started with building some amazing apps and accessories.[upbeat music]

## Code Samples


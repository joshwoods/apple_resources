# Wwdc2021 10119

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

SwiftUI Accessibility: Beyond the basicsGo beyond the basics to deliver an exceptional accessibility experience. Learn how to use the new SwiftUI Previews in Xcode to explore the latest accessibility APIs and create fantastic, accessible apps for everyone. Find out how you can customize the automatic accessibility built into SwiftUI to make your own custom controls accessible. Explore best practices and identify where to improve your app's navigation experience using grouping and focus. And help supercharge navigation for VoiceOver users with the addition of rotors.ResourcesAccessibilityCreating Accessible ViewsHD VideoSD VideoRelated VideosWWDC23Create accessible spatial experiencesWWDC21Add rich graphics to your SwiftUI appBring accessibility to charts in your appCreate accessible experiences for watchOSDemystify SwiftUIWhat's new in SwiftUIWWDC20VoiceOver efficiency with custom rotors

Go beyond the basics to deliver an exceptional accessibility experience. Learn how to use the new SwiftUI Previews in Xcode to explore the latest accessibility APIs and create fantastic, accessible apps for everyone. Find out how you can customize the automatic accessibility built into SwiftUI to make your own custom controls accessible. Explore best practices and identify where to improve your app's navigation experience using grouping and focus. And help supercharge navigation for VoiceOver users with the addition of rotors.

Accessibility

Creating Accessible Views

HD VideoSD Video

HD Video

SD Video

Create accessible spatial experiences

Add rich graphics to your SwiftUI app

Bring accessibility to charts in your app

Create accessible experiences for watchOS

Demystify SwiftUI

What's new in SwiftUI

VoiceOver efficiency with custom rotors

Search this video…♪ Bass music playing ♪♪Nathan Tannar: Hello, and welcome to WWDC!My name is Nathan, and I'm an engineeron the Accessibility team.Today we'll be going beyond the basics to learnhow to deliver exceptional and accessible SwiftUI apps.This year marks a huge leap forwardfor accessibility in SwiftUI.At Apple, accessibility is one of our core values.Our assistive technologies across all our platformsmake sure that anyone can use your appregardless of any physical, visual, audible,or motor impairment.My team and I work to make sure most of your app is accessibleby default,but there is always more you can do to enrich the experience.Today I'll show you the new tools and APIs for SwiftUIthat make enriching this experience easy.Let's begin with the tooling improvements in Xcode.SwiftUI Previews have changed how many of us develop apps.It dramatically improves your ability to iterateupon your views across multiple environments,all without the need of running your app.To make the most important accessibility modifiersjust a click away,we've added a curated list of accessibility editors.I hope this encourages everyoneto always make their views accessible.But there's more.Since accessibility modifiers don't have visual changesin the previews,a new tool was developed that allows youto inspect the accessibility of your view without leaving Xcode.Let's switch from the editor's panelto the new accessibility panel.Shipping in Xcode 13, SwiftUI Previewswill now also feature an Accessibility Preview.With it, you can inspect the accessibility elementsfor a preview in real time.And this is a game changer.Accessibility Preview will help you make accessible appseven if you don't have a deep understandingof each assistive technology.Let's take a closer look to see how changes are reflectedin the Accessibility Preview.This is a simplified version of the view we just saw.After running the preview, I can select the VStackand the Accessibility Preview will updateto display the elements in their sorted order.Notice that each elementwill always display its basic properties --such as a label and traits.For example, the Text view will create an accessibility elementwith the string as its label.It also gains the .isStaticText trait.The preview will update for any accessibility changes we make,such as adding the .isHeader trait.You will also be able to seesome of the automatic accessibility that takes placebehind the scenes, such as automatic SF Symbol labels.For example, the checkmark.seal.fill symbolis labeled "Verified" by default.If you're relying on a symbol's default label, it's importantto check that it accurately describes your interface.We'll continue to use the Accessibility Previewas we step through five importance areasthat'll help you deliver an exceptional experienceto all of your app's users.We'll start by examining the best wayto make custom controls accessible.Next, we'll discuss how to make a view accessible with children.I'll highlight how to audit your appfor common navigation problemsand how the Accessibility Preview can assist with this.Then I'll show youhow to supercharge your app's navigationwith VoiceOver rotors.And finally, we'll look at focusand how it relates to assistive technologies.I've been working to prototype a new finance appI call Wallet Pal.It's still in the early stages,but so far, I'm pretty happy with the initial design.I was pleased to hear that early beta testers are also loving it.Now that I've polished the UI, I should spend some timeto polish the accessibility interface.The accessibility interfacecompliments the visual experienceto make sure that it’s usable by everyone.I've asked some VoiceOver users to help test Wallet Paland I've heard that the app is hard to navigateand not fully accessible.If parts are not accessible to VoiceOver,then they are also not accessibleto other assistive technologies.It's important that anyone be able to use Wallet Pal,so let's investigateto see where we can improve the experience.We'll begin with reports of usersnot being able to edit their budgets,a critical feature in Wallet Pal.This is the Budget Planner viewwhich allows users to edit their food, entertainment,and savings budgets.To fit the design of Wallet Pal,I ended up needing to create custom sliders.I accomplished this by creating a budget sliderout of shapes and used a drag gesture for interaction.Shapes in SwiftUI make it easyto create stunning and unique views,but they are not accessible by default,and so neither is my budget slider.This must be why some users are not able to edit their budgets.We can confirm it's not accessibleby running a SwiftUI preview and selecting the SliderShape.The Accessibility Preview shows that there are no elements,so this control is not accessible.Ideally,we should have a single labeled accessibility elementwith a value that can be changed.In contrast, standard controls are accessible by default,meaning little to no extra effort is requiredto provide a great experience.SwiftUI uses the view type and its initialization parametersto automatically derive the accessibility element's label,value, traits, and actions.So what's the best way to makeour custom budget slider accessible?Since the standard slider is accessible by default,my team and I thought it would be great to have an APIthat allows the accessibility of one viewto be represented by another.This is what led us to us to createaccessibilityRepresentation(representation:).It's an API that allows the accessibility of one viewto be defined by another.Since I want this to be perceivedby assistive technologies as a slider,that's what I'll use for the accessibility representation.With accessibilityRepresentation(representation:),we're now well on the wayto making this budget slider accessible.The only change needed to improve the experienceof the slider is to describe the value in dollars.And great, just like that,now our budget slider is perfectly accessible.On macOS,the type of control will also be spoken to VoiceOver users.So by using the slider viewin our budget slider's representation,it will be announced as a slider.It's recommended to use accessibilityRepresentation(representation:)when possible, to make custom controls accessible.This is just one way to use accessibilityRepresentation(representation:).Its flexibility allows for many more creative uses.Let's see if we can use it to fix other accessibility bugsin our app.While we have now fixed the functional abilityto edit budgets,some users reported that they couldn't discoverhow to navigate to the Budget Planner view.When designing Wallet Pal, we decided to use SF Symbolsfor all of our buttons.While SF Symbols may have great default accessibility labels,they may not always fit the intended use case.Let's investigate if the problem is a poorly labeled button.The NavigationBarView contains the Edit Budgets button.Since we rely on SF Symbols for so many of our buttons,I created a custom buttonStyle called SymbolButtonStyle.But it appears that despite initializing the buttonwith the label "Edit Budgets",the label for the button is slider.vertical.3.So the accessibility label is being derivedfrom the SF Symbol.Let's take a closer look at the SymbolButtonStyle.The SymbolButtonStyle's makeBody(configuration:) methodreturns an Image view.The Edit Budgets string we initialize the button withwould create a Text view as the configuration's label.But this style completely ignoresthe configuration's label.This is why the button is not labeled "Edit Budgets".While we want an SF Symbol to appear visually,we want the accessibility of the buttonto be represented by the configuration's label.And so this seems like a great use casefor accessibilityRepresentation(representation:).Using accessibilityRepresentation(representation:),I can substitute the accessibility of the Image viewwith another view, in this case, the configuration's label.This way, we can preserve the labelwe used to create the button.accessibilityRepresentation(representation:) is not just the idealand recommended way to make custom controls accessible,it also opens up new creative possibilitiesto make views accessible.Next, let's discuss the relationshipbetween children and accessibility containers.As you may recall, accessibility elements can be wrapped togetherin a group as children of an accessibility container.This is done with the accessibilityElement(children:) modifierand the contain child behavior.In case you're unfamiliar, the contain child behaviorcan be used to create an accessibility container,which wraps existing accessibility elementsas children.But what if instead you have an accessibility elementand you want to set its children?I'm running into this casewhen trying to make the Budget History graph accessible.Users reported the graph is completely inaccessible.And so this means when assistive technologiesare focused on the Budget History headerand try to navigate to the next element,they end up at the Alerts header.VoiceOver users would not even know that this graph exists.I built the graph using the new Canvas view.Canvas makes it easier to draw a collection of shapes.For more on Canvas, please check out Jacob's presentationon how it can be used to add rich graphics to your app.The most important takeaway for accessibilityis that Canvas draws a collection of shapes.And just like we saw with BudgetSlider,shapes are not accessible by default.All users need to be able to view their budget history,so let's make this accessible for everyone.Starting with the basics, let's give our Canvas a label.This will automatically create a new accessibility elementfor the Canvas and assign its label.Now, I'd like each bar in the graphto be represented by their own accessibility element.This is a use case where we have an accessibility elementand want to provide its children.To do this, I'll use the new accessibilityChildren(children:) modifier.This will transform the accessibility elementinto an accessibility container,preserving other accessibility properties, such as the label.The modifier takes a ViewBuilder,which allows us to set new viewsas children of the accessibility container.Recall that our Budget History graphis drawing a horizontal bar graph, so we'll use an HStackand return a view for each budget.I'll use a Rectangle for each accessibility elementso that the frame will fill all available vertical space.This will make each accessibility element's framebigger than what's displayed visually, and that's OK.Having a large but consistent frame will make it easierto navigate on iOSwhen VoiceOver users drag their finger across the screento scan for accessibility elements.If I select the HStackfrom within the accessibilityChildren(children:) modifier,the Accessibility Preview confirmsthat an element has been created for each bar in the graph.These will all be accessible as childrenof the Canvas accessibility container.With these changes,the Budget History graph is now completely accessible,and assistive technologies can navigatethrough each bar in the graph.Notice that the frame for each element is the same,which is ideal.For more complex charts,we have other ways of making them accessible.For that, please check out Preston's presentationon bringing accessibility to charts.But with accessibility children, the accessibility elementsof a view can differ from what's presented visually,allowing you to tailor a great experience.But accessibility children can also be used to composethe accessibility with the help of the combine behavior.As a quick refresh, the combine child behaviorwill merge properties from multiple accessibility elementsinto a new or existing accessibility element.But with the addition of the accessibility children API,it can now also be used to compose accessibilityin a generic way.With accessibility representation,the original accessibility is completely replaced.This means no composition can take place;whereas accessibility children is additive.This means you could later combine the childrento merge their properties into the original element.This is a more advanced use caseof the accessibilityChildren(children:) modifier,but it's a functionality I wanted to highlight.Examples are featured in this presentation'sAccessibility Catalog Sample Project.I hope to see many of you explore what's possiblewith this kind of composition.accessibilityChildren(children:) gives you controlover the children of a container.And with that, complex graphs drawn with Canvascan be made accessible with modifiers and viewsyou're already familiar with.And with the combine child behavior,the accessibility of a single view can be composed of many.Now that we've learned how to make individual componentsof our app accessible, we can start putting things togetherto refine the navigation experience.I've heard that navigating Wallet Pal with VoiceOveris confusing and difficult.So we have some more work to doif we want to deliver a great accessible app.Let's take a closer look at the Friends carousel at the top.While I don't have this feature built yet,I plan to add some kind of gamification to Wallet Pal.So I've added a challenge buttonat the top left of each friend view.We already fixed the SymbolButtonStyle,so the challenge button will be properly labeled now.But since users are reporting that navigation is confusing,are there other issues?To answer that, we must first understandhow assistive technologies will navigate Wallet Pal.By default, accessibility elements are sortedbased off their geometric positionin relation to other elements, from top left to bottom right.This means that without accessibility containersto differentiate the content, VoiceOver would navigatethrough each of the challenge buttons,then the Image and Add Friend button,and finally, the text with the user's name.A great feature of the Accessibility Previewis that it shows accessibility elements in their sorted order.This makes it easy to visualize how assistive technologieswill navigate right from within Xcode.As expected, the sorted order matches what we previously saw.And this order would certainly be confusing to navigate.Now there are multiple wayswe could fix the sort order of the accessibility elements.One thing we could dois to introduce accessibility containers.I'll add the accessibilityElement(children:) modifierwith the contain behavior.This will wrap the accessibility elements of each FriendCellViewin an accessibility container.This fixes the navigation order,because children of an accessibility containerare navigated before moving to the next accessibility element.With this change, VoiceOver will navigate through the childrenof the accessibility containerbefore moving to the next accessibility element.And so we achieve a much more desirable navigation order.But could we do better to improve this experience?One problem is that the challenge buttonis navigated to before knowing who the user is.A VoiceOver user would want to know the name of the userbefore sending a challenge,so this button should really be sorted last.We can use the accessibilitySortPriority(_:) modifierto fix this.accessibilitySortPriority(_:) can be used to change the orderof elements within an accessibility container.An element with a higher priority will be sorted first,whereas a lower priority will be sorted last.Elements with equal priorities are then sortedbased off their geometric positioning.I'll add the accessibilitySortPriority(_:) modifierto the challenge button to improve the navigation order.I'll use a priority of -1 since the default is 0,to force the sort order of the challenge button to be last.Now the challenge button will be navigated to last.This is a good improvement, since there is less chancea VoiceOver user would be confusedas to who they are sending a challenge to,but it's still not great.Rather than wrapping each FriendCellViewin an accessibility container,we could combine the children into a single element.Recall that combine merges properties from childreninto an existing or new accessibility element.The combine behavior also curateswhich properties are merged for the best default result.For example, the challenge button has become an actionnamed "Send Challenge".This too fixes the navigation order and reduces the numberof accessibility elements.Now there's a single element for each user,and each element has a Send Challenge action.It is often ideal to combine the accessibility elementsof views that are represented in a ForEach.As you may have picked up on by now,combine is a super useful child behavior.Instead of children being individually navigable,it merges their properties into a single, navigable element.For when you need a single elementbut do not want it to inherit properties from the children,use the ignore behavior.And lastly, the contain child behavior wraps the childrenin an accessibility container and should be usedto express a groups of views that are related.This not only improves the default sort orderbut has other advantages to assistive technologies.With the new Accessibility Preview,discovering these navigation problems is easy.And with a few small changes,you can dramatically improve the experience.But to deliver a truly exceptionalnavigation experience to VoiceOver users,you'll will want to consider rotors.Now if you are new to accessibility,you might be thinking, "What are rotors?"In short, rotors are a powerful navigation tool.They can be thought of as bookmarksthat allow users to quickly navigate between them.System rotors, such as the headingsand containers rotor, provide the foundationfor this supercharged form of navigation.For example, users can quickly navigate through sectionsusing the headings rotor.This is because the Section viewautomatically adds the isHeader trait to the header viewIf you are not using the Section view,you can add the isHeader trait to your viewwith accessibilityAddTraits(_:).Similarly, accessibility containers are addedto the container's rotor, which as we saw earlier,are created with the accessibilityElement(children:) modifier.As you can see,supporting the headings rotor is incredibly easy,and the container's rotor further adds to the benefitof grouping your accessibility elementswith the contain child behavior.Now that the basic navigation experience of Wallet Palhas been refined,let's take it a step further with rotors.In Wallet Pal, alerts help keep users' spending habits in checkby providing motivation messages and warningswhen budgets near or exceed their limit.We've incorporated SF Symbolsfor the different types of alerts.These allow visual usersto quickly scan through the list.But this iconography will not help VoiceOver users.They would instead have to navigate through every alertjust to know if they have any warnings.To replicate a similar experiencethat sighted users have, VoiceOver users needto be able to exclusively navigate warnings,that way, in an instant,they can navigate to the next warning alert.To do this, we can use rotors.For more examples of custom rotorsand why they're so important to efficiency,please check out our "VoiceOver Efficiency for Custom Rotors"presentation from 2020.To add a warnings rotor to my AlertsView,the first thing I'll do is to make sure I'm adding my rotorto an accessibility container.Some views in SwiftUI are accessibility containersby default -- such as List or LazyVStack --but VStacks and HStacks are not,so I'll add the accessibilityElement(children:) modifierwith the contain child behavior.Next, I'll create my rotor with the accessibilityRotor(_:entries:) modifier,giving it the name "Warnings".And lastly, I'll declare which of my alertsI want included in the warnings rotor,in this case all of the warning alerts.And that's it!It's this easy to supercharge your app's navigation.Part of what makes rotors so easy for these simple use casesis that SwiftUI can automatically matchthe rotor entry to the accessibility elementbased off the ID.This is because the ID of our rotor entry will matchthe ID given to the AlertCellView by a ForEach.The identity of a view is important to understandfor accessibility rotors.So if view identity is unclear or you'd like a refresher,I strongly encourage you to check outthe "Demystifying SwiftUI" presentation to learn more.Now you might be thinking, "Hold on,my view isn't this simple.What about views that are not within a ForEach?"Don't worry, the accessibility rotor APIcan scale from simple to complex views.This simple case works elegantlybecause there is a single accessibility element --due to the combine -- for the AlertCellView.And the AlertCellView is identified by the IDof the alert.What if for every alert there was also an Actions view?In this case, the VStack is now the root view of our ForEach,and it's the VStack which will be given the identityof the alert.So to include the AlertCellView in our warnings rotor,we will need to explicitly mark it as a rotor entry.We can do that with the accessibilityRotorEntry modifier.This modifier requires a namespace and an ID,which could be anything as long as they match the IDand namespace used to create the AccessibilityRotorEntry.And lastly, we'll need to include this namespacefor each rotor entry.The ability to refer to an explicit namespaceis what enables the accessibility rotor APIto scale from simple to complex use cases,allowing accessibility elements that span across multiple viewsto be included in the same rotor.Accessibility rotors can also be added to enrich text navigation.To do that,use a different variant of the accessibilityRotor modifier,which allows you provide an array of text ranges.This modifier is great for giving VoiceOver usersquick and easy access to specific stringswithin a TextEditor, such as emails, links, or phone numbers.Accessibility rotors makes complex navigationeasy for VoiceOver users.And with the new SwiftUI rotors API, it's never been easierto deliver this exceptional navigation experience.The last topic for today is focus.The concept of element of focusis something you may already be familiar with,but what you may not knowis that many of our assistive technologieshave their own focus state.This is what we call "accessibility focus".It's the focused view you have been seeing changewhen I refer to assistive technologies navigating.The position of an assistive technology's cursoris critical to the user experience.When focus is changed in VoiceOver,the cursor moves to match the focused element's pathin addition to speaking a description of the element.So when does focus change?Focus can but may not always changewhen one of three events occur.The first and most common use caseis when a user drives a focus changewhen navigating to a different accessibility element.The second case is when the UI changes,and the previously focused view is no longer on screenor is covered by a modal view.When this happens, focus is often resetto the first sorted accessibility element.This covers many use cases automatically,such as moving to the first accessibility elementof a newly presented view.But that may not be the best behavior in your app,which is why focus can also be changedupon programmatic request.However, this should be handled with caution,because moving a VoiceOver user's focuscan be very disruptive.On that note, let's focus -- no pun intended --on the last case.This year we have a new API that will allow youto both request an assistive technology to move its focus,in addition to reading where an assistive technologyis currently focused.Here we have a simple view which tracks a notification,and if it exists, overlays a custom NotificationBanner.We want to use this view in Wallet Palto show alerts for push notificationsreceived while the app is in the foreground.When the NotificationBanner is added,assistive technologies will not automatically focus on it.But we can request they do sowith the new AccessibilityFocusState.AccessibilityFocusState is a property wrapper that providesboth a way of reading where an assistive technology is focusedand requesting a programmatic focus change.I'll add one to my view and bind it to the NotificationBannerwith the accessibilityFocused(_:) modifier.Next, I'll use the onChange(of:perform:) modifierto track when a new notification is received.Only when a high-priority notification is receiveddo we request accessibility focus to change.It's especially important to notethat moving focus programmaticallycan be very disruptive if no user interaction occurred.It takes the user out of whatever contextthey are currently focused on, so it must be handled with care.So for lower priority notifications,I'll post an accessibility notificationfor VoiceOver to announce.This way,VoiceOver users still know a new notification has appearedand can navigate to it if desired.Now let's step inside the NotificationBanner view.When the notification appears, a timer is started.Upon it completing, the notification is set to nil.Recall from before that when the notification is nil,the NotificationBanner will be hidden.This means if a VoiceOver user was focusedon the notification banner and the timer expired,their focus would be reset, since the view is removed;and this isn't a great user experience.To fix this, let's read if our NotificationBanneris focused by an assistive technology,and if it is, delay the notification dismissal.This is the ideal solution.A VoiceOver user's focus will no longer be reset,since the view is no longer removed while focused.Additionally, we have given assistive technology usersan unlimited number of time to digest the contentand interact if desired;two things that may take assistive technology usersmuch longer to do so.AccessibilityFocusState is the last piece you needto deliver exceptional and accessible SwiftUI appsthis year and beyond.With it, you can read and direct the focusof assistive technologies to create smooth transitionsbetween views.Wow, we've covered a lot today for SwiftUI accessibility.We were introduced to the new Accessibility Preview,which enhances the way you can developand debug SwiftUI accessibility;we covered how to make custom controlsand complex graphs accessible;and we took the time to learn how the navigation experiencecan be improved with grouping, rotors, and focus.Put everything together, and it truly has beena huge leap for accessibility this year.For some great simple and complex examplesof our Accessibility APIs, please checkoutthe Accessibility Catalog Sample Project.It features more examples that we couldn't cover todayand some of our recommended best practices.Thank you so much for joining me.We look forward to seeing how you make your app accessibleto everyone.♪

♪ Bass music playing ♪♪Nathan Tannar: Hello, and welcome to WWDC!My name is Nathan, and I'm an engineeron the Accessibility team.

Today we'll be going beyond the basics to learnhow to deliver exceptional and accessible SwiftUI apps.

This year marks a huge leap forwardfor accessibility in SwiftUI.

At Apple, accessibility is one of our core values.

Our assistive technologies across all our platformsmake sure that anyone can use your appregardless of any physical, visual, audible,or motor impairment.

My team and I work to make sure most of your app is accessibleby default,but there is always more you can do to enrich the experience.

Today I'll show you the new tools and APIs for SwiftUIthat make enriching this experience easy.

Let's begin with the tooling improvements in Xcode.

SwiftUI Previews have changed how many of us develop apps.

It dramatically improves your ability to iterateupon your views across multiple environments,all without the need of running your app.

To make the most important accessibility modifiersjust a click away,we've added a curated list of accessibility editors.

I hope this encourages everyoneto always make their views accessible.

But there's more.

Since accessibility modifiers don't have visual changesin the previews,a new tool was developed that allows youto inspect the accessibility of your view without leaving Xcode.

Let's switch from the editor's panelto the new accessibility panel.

Shipping in Xcode 13, SwiftUI Previewswill now also feature an Accessibility Preview.

With it, you can inspect the accessibility elementsfor a preview in real time.

And this is a game changer.

Accessibility Preview will help you make accessible appseven if you don't have a deep understandingof each assistive technology.

Let's take a closer look to see how changes are reflectedin the Accessibility Preview.

This is a simplified version of the view we just saw.

After running the preview, I can select the VStackand the Accessibility Preview will updateto display the elements in their sorted order.

Notice that each elementwill always display its basic properties --such as a label and traits.

For example, the Text view will create an accessibility elementwith the string as its label.

It also gains the .isStaticText trait.

The preview will update for any accessibility changes we make,such as adding the .isHeader trait.

You will also be able to seesome of the automatic accessibility that takes placebehind the scenes, such as automatic SF Symbol labels.

For example, the checkmark.seal.fill symbolis labeled "Verified" by default.

If you're relying on a symbol's default label, it's importantto check that it accurately describes your interface.

We'll continue to use the Accessibility Previewas we step through five importance areasthat'll help you deliver an exceptional experienceto all of your app's users.

We'll start by examining the best wayto make custom controls accessible.

Next, we'll discuss how to make a view accessible with children.

I'll highlight how to audit your appfor common navigation problemsand how the Accessibility Preview can assist with this.

Then I'll show youhow to supercharge your app's navigationwith VoiceOver rotors.

And finally, we'll look at focusand how it relates to assistive technologies.

I've been working to prototype a new finance appI call Wallet Pal.

It's still in the early stages,but so far, I'm pretty happy with the initial design.

I was pleased to hear that early beta testers are also loving it.

Now that I've polished the UI, I should spend some timeto polish the accessibility interface.

The accessibility interfacecompliments the visual experienceto make sure that it’s usable by everyone.

I've asked some VoiceOver users to help test Wallet Paland I've heard that the app is hard to navigateand not fully accessible.

If parts are not accessible to VoiceOver,then they are also not accessibleto other assistive technologies.

It's important that anyone be able to use Wallet Pal,so let's investigateto see where we can improve the experience.

We'll begin with reports of usersnot being able to edit their budgets,a critical feature in Wallet Pal.

This is the Budget Planner viewwhich allows users to edit their food, entertainment,and savings budgets.

To fit the design of Wallet Pal,I ended up needing to create custom sliders.

I accomplished this by creating a budget sliderout of shapes and used a drag gesture for interaction.

Shapes in SwiftUI make it easyto create stunning and unique views,but they are not accessible by default,and so neither is my budget slider.

This must be why some users are not able to edit their budgets.

We can confirm it's not accessibleby running a SwiftUI preview and selecting the SliderShape.

The Accessibility Preview shows that there are no elements,so this control is not accessible.

Ideally,we should have a single labeled accessibility elementwith a value that can be changed.

In contrast, standard controls are accessible by default,meaning little to no extra effort is requiredto provide a great experience.

SwiftUI uses the view type and its initialization parametersto automatically derive the accessibility element's label,value, traits, and actions.

So what's the best way to makeour custom budget slider accessible?Since the standard slider is accessible by default,my team and I thought it would be great to have an APIthat allows the accessibility of one viewto be represented by another.

This is what led us to us to createaccessibilityRepresentation(representation:).

It's an API that allows the accessibility of one viewto be defined by another.

Since I want this to be perceivedby assistive technologies as a slider,that's what I'll use for the accessibility representation.

With accessibilityRepresentation(representation:),we're now well on the wayto making this budget slider accessible.

The only change needed to improve the experienceof the slider is to describe the value in dollars.

And great, just like that,now our budget slider is perfectly accessible.

On macOS,the type of control will also be spoken to VoiceOver users.

So by using the slider viewin our budget slider's representation,it will be announced as a slider.

It's recommended to use accessibilityRepresentation(representation:)when possible, to make custom controls accessible.

This is just one way to use accessibilityRepresentation(representation:).

Its flexibility allows for many more creative uses.

Let's see if we can use it to fix other accessibility bugsin our app.

While we have now fixed the functional abilityto edit budgets,some users reported that they couldn't discoverhow to navigate to the Budget Planner view.

When designing Wallet Pal, we decided to use SF Symbolsfor all of our buttons.

While SF Symbols may have great default accessibility labels,they may not always fit the intended use case.

Let's investigate if the problem is a poorly labeled button.

The NavigationBarView contains the Edit Budgets button.

Since we rely on SF Symbols for so many of our buttons,I created a custom buttonStyle called SymbolButtonStyle.

But it appears that despite initializing the buttonwith the label "Edit Budgets",the label for the button is slider.vertical.3.

So the accessibility label is being derivedfrom the SF Symbol.

Let's take a closer look at the SymbolButtonStyle.

The SymbolButtonStyle's makeBody(configuration:) methodreturns an Image view.

The Edit Budgets string we initialize the button withwould create a Text view as the configuration's label.

But this style completely ignoresthe configuration's label.

This is why the button is not labeled "Edit Budgets".

While we want an SF Symbol to appear visually,we want the accessibility of the buttonto be represented by the configuration's label.

And so this seems like a great use casefor accessibilityRepresentation(representation:).

Using accessibilityRepresentation(representation:),I can substitute the accessibility of the Image viewwith another view, in this case, the configuration's label.

This way, we can preserve the labelwe used to create the button.

accessibilityRepresentation(representation:) is not just the idealand recommended way to make custom controls accessible,it also opens up new creative possibilitiesto make views accessible.

Next, let's discuss the relationshipbetween children and accessibility containers.

As you may recall, accessibility elements can be wrapped togetherin a group as children of an accessibility container.

This is done with the accessibilityElement(children:) modifierand the contain child behavior.

In case you're unfamiliar, the contain child behaviorcan be used to create an accessibility container,which wraps existing accessibility elementsas children.

But what if instead you have an accessibility elementand you want to set its children?I'm running into this casewhen trying to make the Budget History graph accessible.

Users reported the graph is completely inaccessible.

And so this means when assistive technologiesare focused on the Budget History headerand try to navigate to the next element,they end up at the Alerts header.

VoiceOver users would not even know that this graph exists.

I built the graph using the new Canvas view.

Canvas makes it easier to draw a collection of shapes.

For more on Canvas, please check out Jacob's presentationon how it can be used to add rich graphics to your app.

The most important takeaway for accessibilityis that Canvas draws a collection of shapes.

And just like we saw with BudgetSlider,shapes are not accessible by default.

All users need to be able to view their budget history,so let's make this accessible for everyone.

Starting with the basics, let's give our Canvas a label.

This will automatically create a new accessibility elementfor the Canvas and assign its label.

Now, I'd like each bar in the graphto be represented by their own accessibility element.

This is a use case where we have an accessibility elementand want to provide its children.

To do this, I'll use the new accessibilityChildren(children:) modifier.

This will transform the accessibility elementinto an accessibility container,preserving other accessibility properties, such as the label.

The modifier takes a ViewBuilder,which allows us to set new viewsas children of the accessibility container.

Recall that our Budget History graphis drawing a horizontal bar graph, so we'll use an HStackand return a view for each budget.

I'll use a Rectangle for each accessibility elementso that the frame will fill all available vertical space.

This will make each accessibility element's framebigger than what's displayed visually, and that's OK.

Having a large but consistent frame will make it easierto navigate on iOSwhen VoiceOver users drag their finger across the screento scan for accessibility elements.

If I select the HStackfrom within the accessibilityChildren(children:) modifier,the Accessibility Preview confirmsthat an element has been created for each bar in the graph.

These will all be accessible as childrenof the Canvas accessibility container.

With these changes,the Budget History graph is now completely accessible,and assistive technologies can navigatethrough each bar in the graph.

Notice that the frame for each element is the same,which is ideal.

For more complex charts,we have other ways of making them accessible.

For that, please check out Preston's presentationon bringing accessibility to charts.

But with accessibility children, the accessibility elementsof a view can differ from what's presented visually,allowing you to tailor a great experience.

But accessibility children can also be used to composethe accessibility with the help of the combine behavior.

As a quick refresh, the combine child behaviorwill merge properties from multiple accessibility elementsinto a new or existing accessibility element.

But with the addition of the accessibility children API,it can now also be used to compose accessibilityin a generic way.

With accessibility representation,the original accessibility is completely replaced.

This means no composition can take place;whereas accessibility children is additive.

This means you could later combine the childrento merge their properties into the original element.

This is a more advanced use caseof the accessibilityChildren(children:) modifier,but it's a functionality I wanted to highlight.

Examples are featured in this presentation'sAccessibility Catalog Sample Project.

I hope to see many of you explore what's possiblewith this kind of composition.

accessibilityChildren(children:) gives you controlover the children of a container.

And with that, complex graphs drawn with Canvascan be made accessible with modifiers and viewsyou're already familiar with.

And with the combine child behavior,the accessibility of a single view can be composed of many.

Now that we've learned how to make individual componentsof our app accessible, we can start putting things togetherto refine the navigation experience.

I've heard that navigating Wallet Pal with VoiceOveris confusing and difficult.

So we have some more work to doif we want to deliver a great accessible app.

Let's take a closer look at the Friends carousel at the top.

While I don't have this feature built yet,I plan to add some kind of gamification to Wallet Pal.

So I've added a challenge buttonat the top left of each friend view.

We already fixed the SymbolButtonStyle,so the challenge button will be properly labeled now.

But since users are reporting that navigation is confusing,are there other issues?To answer that, we must first understandhow assistive technologies will navigate Wallet Pal.

By default, accessibility elements are sortedbased off their geometric positionin relation to other elements, from top left to bottom right.

This means that without accessibility containersto differentiate the content, VoiceOver would navigatethrough each of the challenge buttons,then the Image and Add Friend button,and finally, the text with the user's name.

A great feature of the Accessibility Previewis that it shows accessibility elements in their sorted order.

This makes it easy to visualize how assistive technologieswill navigate right from within Xcode.

As expected, the sorted order matches what we previously saw.

And this order would certainly be confusing to navigate.

Now there are multiple wayswe could fix the sort order of the accessibility elements.

One thing we could dois to introduce accessibility containers.

I'll add the accessibilityElement(children:) modifierwith the contain behavior.

This will wrap the accessibility elements of each FriendCellViewin an accessibility container.

This fixes the navigation order,because children of an accessibility containerare navigated before moving to the next accessibility element.

With this change, VoiceOver will navigate through the childrenof the accessibility containerbefore moving to the next accessibility element.

And so we achieve a much more desirable navigation order.

But could we do better to improve this experience?One problem is that the challenge buttonis navigated to before knowing who the user is.

A VoiceOver user would want to know the name of the userbefore sending a challenge,so this button should really be sorted last.

We can use the accessibilitySortPriority(_:) modifierto fix this.

accessibilitySortPriority(_:) can be used to change the orderof elements within an accessibility container.

An element with a higher priority will be sorted first,whereas a lower priority will be sorted last.

Elements with equal priorities are then sortedbased off their geometric positioning.

I'll add the accessibilitySortPriority(_:) modifierto the challenge button to improve the navigation order.

I'll use a priority of -1 since the default is 0,to force the sort order of the challenge button to be last.

Now the challenge button will be navigated to last.

This is a good improvement, since there is less chancea VoiceOver user would be confusedas to who they are sending a challenge to,but it's still not great.

Rather than wrapping each FriendCellViewin an accessibility container,we could combine the children into a single element.

Recall that combine merges properties from childreninto an existing or new accessibility element.

The combine behavior also curateswhich properties are merged for the best default result.

For example, the challenge button has become an actionnamed "Send Challenge".

This too fixes the navigation order and reduces the numberof accessibility elements.

Now there's a single element for each user,and each element has a Send Challenge action.

It is often ideal to combine the accessibility elementsof views that are represented in a ForEach.

As you may have picked up on by now,combine is a super useful child behavior.

Instead of children being individually navigable,it merges their properties into a single, navigable element.

For when you need a single elementbut do not want it to inherit properties from the children,use the ignore behavior.

And lastly, the contain child behavior wraps the childrenin an accessibility container and should be usedto express a groups of views that are related.

This not only improves the default sort orderbut has other advantages to assistive technologies.

With the new Accessibility Preview,discovering these navigation problems is easy.

And with a few small changes,you can dramatically improve the experience.

But to deliver a truly exceptionalnavigation experience to VoiceOver users,you'll will want to consider rotors.

Now if you are new to accessibility,you might be thinking, "What are rotors?"In short, rotors are a powerful navigation tool.

They can be thought of as bookmarksthat allow users to quickly navigate between them.

System rotors, such as the headingsand containers rotor, provide the foundationfor this supercharged form of navigation.

For example, users can quickly navigate through sectionsusing the headings rotor.

This is because the Section viewautomatically adds the isHeader trait to the header viewIf you are not using the Section view,you can add the isHeader trait to your viewwith accessibilityAddTraits(_:).

Similarly, accessibility containers are addedto the container's rotor, which as we saw earlier,are created with the accessibilityElement(children:) modifier.

As you can see,supporting the headings rotor is incredibly easy,and the container's rotor further adds to the benefitof grouping your accessibility elementswith the contain child behavior.

Now that the basic navigation experience of Wallet Palhas been refined,let's take it a step further with rotors.

In Wallet Pal, alerts help keep users' spending habits in checkby providing motivation messages and warningswhen budgets near or exceed their limit.

We've incorporated SF Symbolsfor the different types of alerts.

These allow visual usersto quickly scan through the list.

But this iconography will not help VoiceOver users.

They would instead have to navigate through every alertjust to know if they have any warnings.

To replicate a similar experiencethat sighted users have, VoiceOver users needto be able to exclusively navigate warnings,that way, in an instant,they can navigate to the next warning alert.

To do this, we can use rotors.

For more examples of custom rotorsand why they're so important to efficiency,please check out our "VoiceOver Efficiency for Custom Rotors"presentation from 2020.

To add a warnings rotor to my AlertsView,the first thing I'll do is to make sure I'm adding my rotorto an accessibility container.

Some views in SwiftUI are accessibility containersby default -- such as List or LazyVStack --but VStacks and HStacks are not,so I'll add the accessibilityElement(children:) modifierwith the contain child behavior.

Next, I'll create my rotor with the accessibilityRotor(_:entries:) modifier,giving it the name "Warnings".

And lastly, I'll declare which of my alertsI want included in the warnings rotor,in this case all of the warning alerts.

And that's it!It's this easy to supercharge your app's navigation.

Part of what makes rotors so easy for these simple use casesis that SwiftUI can automatically matchthe rotor entry to the accessibility elementbased off the ID.

This is because the ID of our rotor entry will matchthe ID given to the AlertCellView by a ForEach.

The identity of a view is important to understandfor accessibility rotors.

So if view identity is unclear or you'd like a refresher,I strongly encourage you to check outthe "Demystifying SwiftUI" presentation to learn more.

Now you might be thinking, "Hold on,my view isn't this simple.

What about views that are not within a ForEach?"Don't worry, the accessibility rotor APIcan scale from simple to complex views.

This simple case works elegantlybecause there is a single accessibility element --due to the combine -- for the AlertCellView.

And the AlertCellView is identified by the IDof the alert.

What if for every alert there was also an Actions view?In this case, the VStack is now the root view of our ForEach,and it's the VStack which will be given the identityof the alert.

So to include the AlertCellView in our warnings rotor,we will need to explicitly mark it as a rotor entry.

We can do that with the accessibilityRotorEntry modifier.

This modifier requires a namespace and an ID,which could be anything as long as they match the IDand namespace used to create the AccessibilityRotorEntry.

And lastly, we'll need to include this namespacefor each rotor entry.

The ability to refer to an explicit namespaceis what enables the accessibility rotor APIto scale from simple to complex use cases,allowing accessibility elements that span across multiple viewsto be included in the same rotor.

Accessibility rotors can also be added to enrich text navigation.

To do that,use a different variant of the accessibilityRotor modifier,which allows you provide an array of text ranges.

This modifier is great for giving VoiceOver usersquick and easy access to specific stringswithin a TextEditor, such as emails, links, or phone numbers.

Accessibility rotors makes complex navigationeasy for VoiceOver users.

And with the new SwiftUI rotors API, it's never been easierto deliver this exceptional navigation experience.

The last topic for today is focus.

The concept of element of focusis something you may already be familiar with,but what you may not knowis that many of our assistive technologieshave their own focus state.

This is what we call "accessibility focus".

It's the focused view you have been seeing changewhen I refer to assistive technologies navigating.

The position of an assistive technology's cursoris critical to the user experience.

When focus is changed in VoiceOver,the cursor moves to match the focused element's pathin addition to speaking a description of the element.

So when does focus change?Focus can but may not always changewhen one of three events occur.

The first and most common use caseis when a user drives a focus changewhen navigating to a different accessibility element.

The second case is when the UI changes,and the previously focused view is no longer on screenor is covered by a modal view.

When this happens, focus is often resetto the first sorted accessibility element.

This covers many use cases automatically,such as moving to the first accessibility elementof a newly presented view.

But that may not be the best behavior in your app,which is why focus can also be changedupon programmatic request.

However, this should be handled with caution,because moving a VoiceOver user's focuscan be very disruptive.

On that note, let's focus -- no pun intended --on the last case.

This year we have a new API that will allow youto both request an assistive technology to move its focus,in addition to reading where an assistive technologyis currently focused.

Here we have a simple view which tracks a notification,and if it exists, overlays a custom NotificationBanner.

We want to use this view in Wallet Palto show alerts for push notificationsreceived while the app is in the foreground.

When the NotificationBanner is added,assistive technologies will not automatically focus on it.

But we can request they do sowith the new AccessibilityFocusState.

AccessibilityFocusState is a property wrapper that providesboth a way of reading where an assistive technology is focusedand requesting a programmatic focus change.

I'll add one to my view and bind it to the NotificationBannerwith the accessibilityFocused(_:) modifier.

Next, I'll use the onChange(of:perform:) modifierto track when a new notification is received.

Only when a high-priority notification is receiveddo we request accessibility focus to change.

It's especially important to notethat moving focus programmaticallycan be very disruptive if no user interaction occurred.

It takes the user out of whatever contextthey are currently focused on, so it must be handled with care.

So for lower priority notifications,I'll post an accessibility notificationfor VoiceOver to announce.

This way,VoiceOver users still know a new notification has appearedand can navigate to it if desired.

Now let's step inside the NotificationBanner view.

When the notification appears, a timer is started.

Upon it completing, the notification is set to nil.

Recall from before that when the notification is nil,the NotificationBanner will be hidden.

This means if a VoiceOver user was focusedon the notification banner and the timer expired,their focus would be reset, since the view is removed;and this isn't a great user experience.

To fix this, let's read if our NotificationBanneris focused by an assistive technology,and if it is, delay the notification dismissal.

This is the ideal solution.

A VoiceOver user's focus will no longer be reset,since the view is no longer removed while focused.

Additionally, we have given assistive technology usersan unlimited number of time to digest the contentand interact if desired;two things that may take assistive technology usersmuch longer to do so.

AccessibilityFocusState is the last piece you needto deliver exceptional and accessible SwiftUI appsthis year and beyond.

With it, you can read and direct the focusof assistive technologies to create smooth transitionsbetween views.

Wow, we've covered a lot today for SwiftUI accessibility.

We were introduced to the new Accessibility Preview,which enhances the way you can developand debug SwiftUI accessibility;we covered how to make custom controlsand complex graphs accessible;and we took the time to learn how the navigation experiencecan be improved with grouping, rotors, and focus.

Put everything together, and it truly has beena huge leap for accessibility this year.

For some great simple and complex examplesof our Accessibility APIs, please checkoutthe Accessibility Catalog Sample Project.

It features more examples that we couldn't cover todayand some of our recommended best practices.

Thank you so much for joining me.

We look forward to seeing how you make your app accessibleto everyone.

♪

2:00 -Welcome to the Accessibility Preview

4:30 -BudgetSlider

5:15 -Slider

5:50 -Accessible BudgetSlider

7:05 -NavigationBarView

9:40 -BudgetHistoryGraph

12:30 -Composition

13:50 -FriendCellView

14:50 -FriendsView

15:10 -FriendsView with Containers

16:20 -FriendCellView Sort Priority

16:55 -FriendsView with .combine

20:30 -AlertsView Implicit Rotor

21:50 -AlertsView Explicit Rotor

22:20 -TextEditor Rotors

24:45 -AlertNotificationView

## Code Samples

```swift
struct
 
ContentView
: 
View
 
{
    
var
 body: 
some
 
View
 {
        
VStack
 {
            
Text
(
"WWDC 2021"
)
                .accessibilityAddTraits(.isHeader)

            
Text
(
"SwiftUI Accessibility"
)
            
Text
(
"Beyond the Basics"
)

            
Image
(systemName: 
"checkmark.seal.fill"
)
        }
    }
}
```

```swift
struct
 
BudgetSlider
: 
View
 
{
    
@Binding
 
var
 value: 
Double

    
var
 label: 
String


    
var
 body: 
some
 
View
 {
        
VStack
(alignment: .leading) {
            
HStack
 {
                
Text
(label)
                
Text
(value.toDollars()).bold()
            }
            
SliderShape
(value: value)
                .gesture(
DragGesture
().onChanged(handle))
        }
    }
}


struct
 
SliderShape
: 
View
 
{
    
var
 value: 
Double


    
private
 
struct
 
BackgroundTrack
: 
View
 
{
        
var
 cornerRadius: 
CGFloat

        
var
 body: 
some
 
View
 {
            
RoundedRectangle
(
                cornerRadius: cornerRadius,
                style: .continuous
            )
            .foregroundColor(
Color
(white: 
0.2
))
        }
    }

    
private
 
struct
 
OverlayTrack
: 
View
 
{
        
var
 cornerRadius: 
CGFloat

        
var
 body: 
some
 
View
 {
            
RoundedRectangle
(
                cornerRadius: cornerRadius,
                style: .continuous
            )
            .foregroundColor(
Color
(white: 
0.95
))
        }
    }

    
private
 
struct
 
Knob
: 
View
 
{
        
var
 cornerRadius: 
CGFloat

        
var
 body: 
some
 
View
 {
            
RoundedRectangle
(
                cornerRadius: cornerRadius,
                style: .continuous
            )
            .strokeBorder(
Color
(white: 
0.7
), lineWidth: 
1
)
            .shadow(radius: 
3
)
        }
    }

    
var
 body: 
some
 
View
 {
        
GeometryReader
 { geometry 
in

            
ZStack
(alignment: .leading) {
                
BackgroundTrack
(cornerRadius: geometry.size.height 
/
 
2
)

                
OverlayTrack
(cornerRadius: geometry.size.height 
/
 
2
)
                    .frame(
                        width: 
max
(geometry.size.height, geometry.size.width 
*
 
CGFloat
(value) 
+
 geometry.size.height 
/
 
2
),
                        height: geometry.size.height)

                
Knob
(cornerRadius: geometry.size.height 
/
 
2
)
                    .frame(
                        width: geometry.size.height,
                        height: geometry.size.height)
                    .offset(x: 
max
(
0
, geometry.size.width 
*
 
CGFloat
(value) 
-
 geometry.size.height 
/
 
2
), y: 
0
)
            }
        }
    }
}


extension
 
Double
 
{
    
func
 
toDollars
()
 -> 
String
 {
        
return
 
"$
\(Int(
self
))
"

    }
}
```

```swift
struct
 
StandardSlider
: 
View
 
{
    
@Binding
 
var
 value: 
Double

    
var
 label: 
String


    
var
 body: 
some
 
View
 {
        
Slider
(value: 
$value
, in: 
0
...
1
) {
            
Text
(label) 
        }
    }
}
```

```swift
struct
 
BudgetSlider
: 
View
 
{
    
@Binding
 
var
 value: 
Double

    
var
 label: 
String


    
var
 body: 
some
 
View
 {
        
VStack
(alignment: .leading) {
            
HStack
 {
                
Text
(label)
                
Text
(value.toDollars()).bold()
            }
            
SliderShape
(value: value)
                .gesture(
DragGesture
().onChanged(handle))
                .accessibilityRepresentation {
                    
Slider
(value: 
$value
, in: 
0
...
1
) {
                        
Text
(label)
                    }
                    .accessibilityValue(value.toDollars())
                }
        }
    }
}


struct
 
SliderShape
: 
View
 
{
    
var
 value: 
Double


    
private
 
struct
 
BackgroundTrack
: 
View
 
{
        
var
 cornerRadius: 
CGFloat

        
var
 body: 
some
 
View
 {
            
RoundedRectangle
(
                cornerRadius: cornerRadius,
                style: .continuous
            )
            .foregroundColor(
Color
(white: 
0.2
))
        }
    }

    
private
 
struct
 
OverlayTrack
: 
View
 
{
        
var
 cornerRadius: 
CGFloat

        
var
 body: 
some
 
View
 {
            
RoundedRectangle
(
                cornerRadius: cornerRadius,
                style: .continuous
            )
            .foregroundColor(
Color
(white: 
0.95
))
        }
    }

    
private
 
struct
 
Knob
: 
View
 
{
        
var
 cornerRadius: 
CGFloat

        
var
 body: 
some
 
View
 {
            
RoundedRectangle
(
                cornerRadius: cornerRadius,
                style: .continuous
            )
            .strokeBorder(
Color
(white: 
0.7
), lineWidth: 
1
)
            .shadow(radius: 
3
)
        }
    }

    
var
 body: 
some
 
View
 {
        
GeometryReader
 { geometry 
in

            
ZStack
(alignment: .leading) {
                
BackgroundTrack
(cornerRadius: geometry.size.height 
/
 
2
)

                
OverlayTrack
(cornerRadius: geometry.size.height 
/
 
2
)
                    .frame(
                        width: 
max
(geometry.size.height, geometry.size.width 
*
 
CGFloat
(value) 
+
 geometry.size.height 
/
 
2
),
                        height: geometry.size.height)

                
Knob
(cornerRadius: geometry.size.height 
/
 
2
)
                    .frame(
                        width: geometry.size.height,
                        height: geometry.size.height)
                    .offset(x: 
max
(
0
, geometry.size.width 
*
 
CGFloat
(value) 
-
 geometry.size.height 
/
 
2
), y: 
0
)
            }
        }
    }
}


extension
 
Double
 
{
    
func
 
toDollars
()
 -> 
String
 {
        
return
 
"$
\(Int(
self
))
"

    }
}
```

```swift
struct
 
NavigationBarView
: 
View
 
{
    
var
 body: 
some
 
View
 {
        
HStack
 {
            
Text
(
"Wallet Pal"
)
                .font(.largeTitle)
                .bold()

            
Spacer
()

            
Button
(
"Edit Budgets"
, action: { 
...
 })
                .buttonStyle(
                    
SymbolButtonStyle
(
                        systemName: 
"slider.vertical.3"
))
        }
    }
}


struct
 
SymbolButtonStyle
: 
ButtonStyle
 
{
    
let
 systemName: 
String


    
func
 
makeBody
(
configuration
: 
Configuration
)
 -> 
some
 
View
 {
				
Image
(systemName: systemName)
            .accessibilityRepresentation { configuration.label }
    }
}
```

```swift
struct
 
Budget
: 
Identifiable
 
{
    
var
 month: 
String

    
var
 amount: 
Double


    
var
 id: 
String
 { month }
}


struct
 
BudgetHistoryGraph
: 
View
 
{
    
var
 budgets: [
Budget
]

    
var
 body: 
some
 
View
 {
        
GeometryReader
 { proxy 
in

            
VStack
 {
                
Canvas
 { ctx, size 
in

                    
let
 inset: 
CGFloat
 
=
 
25

                    
let
 insetSize 
=
 
CGSize
(width: size.width, height: size.height 
-
 inset 
*
 
2
)
                    
let
 width 
=
 insetSize.width 
/
 
CGFloat
(budgets.count)
                    
let
 max 
=
 budgets.map(\.amount).max() 
??
 
0

                    
for
 n 
in
 budgets.indices {
                        
let
 x 
=
 width 
*
 
CGFloat
(n)
                        
let
 height 
=
 (
CGFloat
(budgets[n].amount) 
/
 
CGFloat
(max)) 
*
 insetSize.height
                        
let
 y 
=
 insetSize.height 
-
 height
                        
let
 p 
=
 
Path
(
                            roundedRect: 
CGRect
(
                                x: x 
+
 
2.5
,
                                y: y 
+
 inset,
                                width: width 
-
 
5
,
                                height: height),
                            cornerRadius: 
4
)
                        ctx.fill(p, with: .color(
Color
.green))

                        ctx.draw(
Text
(budgets[n].amount.toDollars()), at: 
CGPoint
(x: x 
+
 width 
/
 
2
, y: y 
+
 inset 
/
 
2
))

                        ctx.draw(
Text
(budgets[n].month), at: 
CGPoint
(x: x 
+
 width 
/
 
2
, y: y 
+
 height 
+
 
1.5
*
inset))
                    }
                }
                .accessibilityLabel(
"Budget History Graph"
)
                .accessibilityChildren {
                    
HStack
 {
                        
ForEach
(budgets) { budget 
in

                            
Rectangle
()
                                .accessibilityLabel(budget.month)
                                .accessibilityValue(budget.amount.toDollars())

                        }
                    }
                }

            }
        }
        .padding()
        .background(
            
RoundedRectangle
(cornerRadius: 
16
)
                .foregroundColor(
Color
(white: 
0.9
)))
        .padding(.horizontal)
    }
}
```

```swift
// See CompositionExample.swift in the referenced sample project
```

```swift
struct
 
User
: 
Identifiable
 
{
    
var
 id: 
Int

    
var
 name: 
String

    
var
 photo: 
String

}


struct
 
FriendCellView
: 
View
 
{
    
var
 user: 
User


    
var
 body: 
some
 
View
 {
        
ZStack
(alignment: .topLeading) {
            
VStack
(alignment: .center) {
                
Image
(user.photo)
                
Text
(user.name)
            }

            
Button
(
"Send Challenge"
, action: { 
/* ... */
 })
                .buttonStyle(
                    
SymbolButtonStyle
(
                        systemName: 
"gamecontroller.fill"
))
        }
    }
}


struct
 
SymbolButtonStyle
: 
ButtonStyle
 
{
    
let
 systemName: 
String


    
func
 
makeBody
(
configuration
: 
Configuration
)
 -> 
some
 
View
 {
				
Image
(systemName: systemName)
            .accessibilityRepresentation { configuration.label }
    }
}
```

```swift
struct
 
User
: 
Identifiable
 
{
    
var
 id: 
Int

    
var
 name: 
String

    
var
 photo: 
String

}


struct
 
FriendCellView
: 
View
 
{
    
var
 user: 
User


    
var
 body: 
some
 
View
 {
        
ZStack
(alignment: .topLeading) {
            
VStack
(alignment: .center) {
                
Image
(user.photo)
                
Text
(user.name)
            }

            
Button
(
"Send Challenge"
, action: { 
/* ... */
 })
                .buttonStyle(
                    
SymbolButtonStyle
(
                        systemName: 
"gamecontroller.fill"
))
        }
    }
}
      

struct
 
FriendsView
: 
View
 
{
    
var
 users: [
User
]

    
var
 body: 
some
 
View
 {
        
ScrollView
(.horizontal, showsIndicators: 
false
) {
            
HStack
 {
                
ForEach
(users) { user 
in

                    
FriendCellView
(user: user)
                        .onTapGesture { 
/* ... */
 }
                }

                
AddFriendButton
()

                
Spacer
()
            }
        }
    }
}
  

struct
 
AddFriendButton
: 
View
 
{
    
var
 body: 
some
 
View
 {
        
Button
(action: { 
/* ... */
 }) {
            
Circle
()
                .foregroundColor(
Color
(white: 
0.9
))
                .frame(width: 
50
, height: 
50
)
                .overlay(
                    
Image
(systemName: 
"plus"
)
                        .resizable()
                        .foregroundColor(
Color
(white: 
0.5
))
                        .padding(
15
)
                )
        }
        .buttonStyle(
PlainButtonStyle
())
    }
}


struct
 
SymbolButtonStyle
: 
ButtonStyle
 
{
    
let
 systemName: 
String


    
func
 
makeBody
(
configuration
: 
Configuration
)
 -> 
some
 
View
 {
				
Image
(systemName: systemName)
            .accessibilityRepresentation { configuration.label }
    }
}
```

```swift
struct
 
User
: 
Identifiable
 
{
    
var
 id: 
Int

    
var
 name: 
String

    
var
 photo: 
String

}


struct
 
FriendCellView
: 
View
 
{
    
var
 user: 
User


    
var
 body: 
some
 
View
 {
        
ZStack
(alignment: .topLeading) {
            
VStack
(alignment: .center) {
                
Image
(user.photo)
                
Text
(user.name)
            }

            
Button
(
"Send Challenge"
, action: { 
/* ... */
 })
                .buttonStyle(
                    
SymbolButtonStyle
(
                        systemName: 
"gamecontroller.fill"
))
        }
    }
}
      

struct
 
FriendsView
: 
View
 
{
    
var
 users: [
User
]

    
var
 body: 
some
 
View
 {
        
ScrollView
(.horizontal, showsIndicators: 
false
) {
            
HStack
 {
                
ForEach
(users) { user 
in

                    
FriendCellView
(user: user)
                         .accessibilityElement(children: .contain)
                        .onTapGesture { 
/* ... */
 }
                }

                
AddFriendButton
()

                
Spacer
()
            }
        }
    }
}
  

struct
 
AddFriendButton
: 
View
 
{
    
var
 body: 
some
 
View
 {
        
Button
(action: { 
/* ... */
 }) {
            
Circle
()
                .foregroundColor(
Color
(white: 
0.9
))
                .frame(width: 
50
, height: 
50
)
                .overlay(
                    
Image
(systemName: 
"plus"
)
                        .resizable()
                        .foregroundColor(
Color
(white: 
0.5
))
                        .padding(
15
)
                )
        }
        .buttonStyle(
PlainButtonStyle
())
    }
}


struct
 
SymbolButtonStyle
: 
ButtonStyle
 
{
    
let
 systemName: 
String


    
func
 
makeBody
(
configuration
: 
Configuration
)
 -> 
some
 
View
 {
				
Image
(systemName: systemName)
            .accessibilityRepresentation { configuration.label }
    }
}
```

```swift
struct
 
User
: 
Identifiable
 
{
    
var
 id: 
Int

    
var
 name: 
String

    
var
 photo: 
String

}


struct
 
FriendCellView
: 
View
 
{
    
var
 user: 
User


    
var
 body: 
some
 
View
 {
        
ZStack
(alignment: .topLeading) {
            
VStack
(alignment: .center) {
                
Image
(user.photo)
                
Text
(user.name)
            }

            
Button
(
"Send Challenge"
, action: { 
/* ... */
 })
                .buttonStyle(
                    
SymbolButtonStyle
(
                        systemName: 
"gamecontroller.fill"
))
                .accessibilitySortPriority(
-
1
)
        }
    }
}
```

```swift
struct
 
User
: 
Identifiable
 
{
    
var
 id: 
Int

    
var
 name: 
String

    
var
 photo: 
String

}


struct
 
FriendCellView
: 
View
 
{
    
var
 user: 
User


    
var
 body: 
some
 
View
 {
        
ZStack
(alignment: .topLeading) {
            
VStack
(alignment: .center) {
                
Image
(user.photo)
                
Text
(user.name)
            }

            
Button
(
"Send Challenge"
, action: { 
/* ... */
 })
                .buttonStyle(
                    
SymbolButtonStyle
(
                        systemName: 
"gamecontroller.fill"
))
        }
    }
}
      

struct
 
FriendsView
: 
View
 
{
    
var
 users: [
User
]

    
var
 body: 
some
 
View
 {
        
ScrollView
(.horizontal, showsIndicators: 
false
) {
            
HStack
 {
                
ForEach
(users) { user 
in

                    
FriendCellView
(user: user)
                        .accessibilityElement(children: .combine)
                        .onTapGesture { 
/* ... */
 }
                }

                
AddFriendButton
()

                
Spacer
()
            }
        }
    }
}
  

struct
 
AddFriendButton
: 
View
 
{
    
var
 body: 
some
 
View
 {
        
Button
(action: { 
/* ... */
 }) {
            
Circle
()
                .foregroundColor(
Color
(white: 
0.9
))
                .frame(width: 
50
, height: 
50
)
                .overlay(
                    
Image
(systemName: 
"plus"
)
                        .resizable()
                        .foregroundColor(
Color
(white: 
0.5
))
                        .padding(
15
)
                )
        }
        .buttonStyle(
PlainButtonStyle
())
    }
}


struct
 
SymbolButtonStyle
: 
ButtonStyle
 
{
    
let
 systemName: 
String


    
func
 
makeBody
(
configuration
: 
Configuration
)
 -> 
some
 
View
 {
				
Image
(systemName: systemName)
            .accessibilityRepresentation { configuration.label }
    }
}
```

```swift
struct
 
Alert
: 
Identifiable
 
{
    
var
 id: 
Int

    
var
 isUnread: 
Bool

    
var
 isFlagged: 
Bool

    
var
 subject: 
String

    
var
 content: 
String

}


struct
 
AlertsView
: 
View
 
{
    
var
 alerts: [
Alert
]

    
var
 body: 
some
 
View
 {
        
VStack
 {
            
ForEach
(alerts) { alert 
in

                
AlertCellView
(alert: alert)
                    .accessibilityElement(children: .combine)
            }
        }
        .accessibilityElement(children: .contain)
        .accessibilityRotor(
"Warnings"
) {
            
ForEach
(alerts) { alert 
in

                
if
 alert.isWarning {
                    
AccessibilityRotorEntry
(alert.title, id: alert.id)
                }
            }
        }
    }
}


struct
 
AlertCell
: 
View
 
{
    
var
 alert: 
Alert


    
var
 body: 
some
 
View
 {
        
VStack
(alignment: .leading) {
            
HStack
 {
                
if
 alert.isUnread {
                    
Circle
()
                        .foregroundColor(.blue)
                        .frame(width: 
10
, height: 
10
)
                }
                
if
 alert.isFlagged {
                    
Image
(systemName: 
"exclamationmark.triangle.fill"
)
                        .foregroundColor(.orange)
                        .frame(width: 
10
, height: 
10
)
                }
                
Text
(alert.subject)
                    .font(.headline)
                    .fontWeight(.semibold)
                
Spacer
()
                
Text
(
"04/30/21"
)
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
            
Text
(alert.content)
                .lineLimit(
3
)
        }
        .padding(
10
)
        .background(
            
RoundedRectangle
(cornerRadius: 
8
)
                .foregroundColor(
Color
(white: 
0.9
))
        )
    }
}
```

```swift
struct
 
Alert
: 
Identifiable
 
{
    
var
 id: 
Int

    
var
 isUnread: 
Bool

    
var
 isFlagged: 
Bool

    
var
 subject: 
String

    
var
 content: 
String

}


struct
 
AlertsView
: 
View
 
{
    
var
 alerts: [
Alert
]
    
@Namespace
 
var
 namespace

    
var
 body: 
some
 
View
 {
        
VStack
 {
            
ForEach
(alerts) { alert 
in

                
VStack
 {
                    
AlertCellView
(alert: alert)
                        .accessibilityElement(children: .combine)
                        .accessibilityRotorEntry(id: alert.id, in: namespace)
                    
AlertActionsView
(alert: alert)
                }
            }
        }
        .accessibilityElement(children: .contain)
        .accessibilityRotor(
"Warnings"
) {
            
ForEach
(alerts) { alert 
in

                
if
 alert.isWarning {
                    
AccessibilityRotorEntry
(alert.title, id: alert.id, in: namespace)
                }
            }
        }
    }
}


struct
 
AlertCell
: 
View
 
{
    
var
 alert: 
Alert


    
var
 body: 
some
 
View
 {
        
VStack
(alignment: .leading) {
            
HStack
 {
                
if
 alert.isUnread {
                    
Circle
()
                        .foregroundColor(.blue)
                        .frame(width: 
10
, height: 
10
)
                }
                
if
 alert.isFlagged {
                    
Image
(systemName: 
"exclamationmark.triangle.fill"
)
                        .foregroundColor(.orange)
                        .frame(width: 
10
, height: 
10
)
                }
                
Text
(alert.subject)
                    .font(.headline)
                    .fontWeight(.semibold)
                
Spacer
()
                
Text
(
"04/30/21"
)
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
            
Text
(alert.content)
                .lineLimit(
3
)
        }
        .padding(
10
)
        .background(
            
RoundedRectangle
(cornerRadius: 
8
)
                .foregroundColor(
Color
(white: 
0.9
))
        )
    }
}
```

```swift
struct
 
ContentView
: 
View
 
{
    
@State
 
var
 note: 
Note


    
var
 body: 
some
 
View
 {
        
TextEditor
(
$text
.content)
            .accessibilityRotor(
"Email Addresses"
, textRanges: note.addressRanges)
            .accessibilityRotor(
"Links"
, textRanges: note.linkRanges)
            .accessibilityRotor(
"Phone Numbers"
, textRanges: note.phoneNumberRanges)
    }
}
```

```swift
struct
 
Notification
: 
Equatable
 
{
    
enum
 
Priority
 
{
        
case
 low, high
    }
    
var
 content: 
String

    
var
 priority: 
Priority

}


struct
 
AlertNotificationView
<
Content
: 
View
>: 
View
 
{
    
@ViewBuilder
 
var
 content: 
Content

    
@Binding
 
var
 notification: 
Notification
?
    
@AccessibilityFocusState
 
var
 isNotificationFocused: 
Bool


    
var
 body: 
some
 
View
 {
        
ZStack
(alignment: .top) {
            content

            
if
 
let
 notification 
=
 
$notification
 {
                
NotificationBanner
(notification: notification)
                    .accessibilityFocused(
$isNotificationFocused
)
            }
        }
        .onChange(of: notification) { notification 
in

            
if
 notification
?
.priority 
==
 .high {
                isNotificationFocused 
=
 
true

            } 
else
 {
                postAccessibilityNotification()
            }
        }
    }

    
func
 
postAccessibilityNotification
()
 {
        
guard
 
let
 announcement 
=
 notification
?
.content 
else
 {
            
return

        }
        
#if
 os(macOS)
        
NSAccessibility
.post(
            element: 
NSApp
.accessibilityWindow(),
            notification: .announcementRequested,
            userInfo: [.announcement: announcement])
        
#else

        
UIAccessibility
.post(notification: .announcement, argument: announcement)
        
#endif

    }
}


struct
 
NotificationBanner
: 
View
 
{
    
@Binding
 
var
 notification: 
Notification
?
    
@State
 
var
 timer: 
Timer
?
    
@AccessibilityFocusState
 
var
 isNotificationFocused: 
Bool


    
var
 body: 
some
 
View
 {
        
if
 
let
 notification 
=
 notification {
            
Text
(notification.content)
                .accessibilityFocused(
$isNotificationFocused
)
                .onAppear { startTimer() }
                .onDisappear { stopTimer() }
        } 
else
 {
            
EmptyView
()
        }
    }

    
func
 
startTimer
()
 {
        timer 
=
 
Timer
.scheduledTimer(
            withTimeInterval: 
3
,
            repeats: 
true
) { 
_
 
in

            
if
 
!
isNotificationFocused {
                notification 
=
 
nil

            }
        }
    }

    
func
 
stopTimer
()
 {
        timer
?
.invalidate()
    }
}
```


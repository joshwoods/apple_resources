# Wwdc2021 10210

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Explore advanced project configuration in XcodeWorking with more complex Xcode projects? You've come to the right place. Discover how you can configure your project to build for multiple Apple platforms, filter content per-platform, create custom build rules and file dependencies, and more. We'll take you through multi-platform framework targets, detail how to optimize your project and scheme configuration, and show you how to make effective use of configuration settings files. 

We'll explore configuring schemes for parallel builds and implicit dependencies, script phases, custom build rules, setting up input and output file dependencies, build phase file lists, and deduplicating work via aggregate targets. Lastly, find out more about the build settings editor, how levels work, and configuration settings file syntax.ResourcesHD VideoSD VideoRelated VideosWWDC21Qualities of great iPad and iPhone apps on Macs with M1

Working with more complex Xcode projects? You've come to the right place. Discover how you can configure your project to build for multiple Apple platforms, filter content per-platform, create custom build rules and file dependencies, and more. We'll take you through multi-platform framework targets, detail how to optimize your project and scheme configuration, and show you how to make effective use of configuration settings files. 

We'll explore configuring schemes for parallel builds and implicit dependencies, script phases, custom build rules, setting up input and output file dependencies, build phase file lists, and deduplicating work via aggregate targets. Lastly, find out more about the build settings editor, how levels work, and configuration settings file syntax.

HD VideoSD Video

HD Video

SD Video

Qualities of great iPad and iPhone apps on Macs with M1

Search this video…♪ Bass music playing ♪♪Jake Petroules: Hi, and welcome to"Explore advanced project configuration in Xcode".I'm Jake, and together with my colleague Prachi,I'll discuss strategies and techniques for makingthe most of your Xcode project's build configuration.We're going to cover three major topic areas.First, Prachi will discuss multiplatform projectsand Xcode 13's new support for multiplatform framework targets.Next, I'll cover best practices for modelingand configuring your project through schemes,target setup and dependency management,and build phases and rules.And finally, Prachi will take you on a deep diveinto build settings,where we'll cover their structure and behavior,the project editor UI,configuration settings files and their syntax,and a whole lot more!Throughout this talk, we'll be usinga multiplatform app project called Frutato show how these techniques apply to a real project.And now I'm going to hand it over to Prachi,who's going to talk about multiplatform frameworks.Prachi Pai Asnodkar: Thanks, Jake.One of the new features in Xcode 13is support for multiplatform frameworks.Multiplatform frameworks allow us to consolidatemultiple frameworks into one,providing us simplified target management,one set of build phases to manage,and one set of build settings to manage.Let's take a look at the Fruta appand update our project to take advantage of this feature.This is the Fruta app.It is a multiplatform app that builds for macOS,iOS, and watchOS.It also has three framework targets --one for each platform that contains a set of shared codeused by the apps.Maintaining three separate frameworkscan come with challenges,such as keeping build settings in sync,and ensuring all of your source files are properly addedto your compile sources build phases.To tackle these challenges,we'll start by converting one of our frameworksto a multiplatform framework.Here we have the three frameworks --one for each platform.All of these targets are identicalexcept that one has a file which only builds on macOS.First, let's navigate to the Build Settings tabin the project navigator for the macOS framework target.Next, we will configure the frameworkto build for all platforms by goingto the Supported Platforms build settingand choosing Any Platform.You can also see that Allow Multiplatform Buildshas been set to "Yes" automatically.This informs the build system to build this targetonce for each of its supported platforms,as necessary.Now that this is a multiplatform target,recall that the original macOS frameworkhad one additional file that should only buildwhen building for macOS.In order to configure our framework to do this,we can add a platform filter to specify that this fileshould only build for macOS.To do this, we will first go to the Build Phases tab.Next, expand the Compile Sources build phase.Finally, configure Ingredient+macOS.swiftto build only for macOS by clicking on the Filters itemand unchecking everything but macOS.Now that we have our new multiplatform target configured,we can delete the other two variants of our framework,as they are no longer needed.Additionally, because we have only one framework target,we will have to configure all of our appsto link and embed that new target.The macOS app is already configuredbecause we have set up our multiplatform targetstarting from the macOS one.We can add the new framework to the iOS and watchOS appsby going to the General tab for each of the app targets,and adding the frameworkto the Frameworks and Libraries build phase.To summarize: we took our macOS framework targetand enabled it to build for iOS and watchOS.We customized that framework with a platform filterfor our macOS-only source file.And finally, we configured our app targetsto link and embed the new single multiplatform framework target.And that's multiplatform targets in Xcode.Now back to Jake,who's going to dive deeper into project configuration.Jake: Thanks, Prachi.I'm going to discuss best practices for modelingand configuring your Xcode project,and show a few things you can do to improve the performanceand correctness of your builds.First, let's have a look at build options for the scheme.I'll click the scheme picker, Edit Scheme,then go to the Build section.There's a few simple things I can configure here.For Build Order,we recommend selecting Dependency Order,which will cause targets in your projectto build in parallel according to the dependency graph.This can greatly improve multicore build performanceand will also get you faster resultsfrom continuous integration.In contrast, choosing Manual Order is deprecatedand is not recommended.Using this option will slow down your buildand can cause cycle errorswhen the target order listed in the schemeis inconsistent with your project's dependencies.Another important setting in the scheme build optionsis Find Implicit Dependencies.Checking this option allows Xcodeto automatically add dependencies between targetsbased on the information in your project,such as linker flags in build settingsand the names of linked libraries in build phases.This can be especially usefulwhen the related targets are in different projectswhere you can't normally add an explicit target dependency.If you are using manual dependency orderto build targets in a specific order due to the inabilityto add explicit target dependenciesacross different projects,enabling Find Implicit Dependenciesin conjunction with choosing Dependency Orderis often a better solution.Now I'm going to talk about script phases and build rules.I'll select the SmoothieKit targetfrom the project's target list,and then select the Build Phases tab.Here we have a Process Recipes script phasethat contains some custom build logic.One of its responsibilities is generating codefrom a number of recipe fileswith one output per input, which we process in sequence.Now, you may realize that these computationsare completely independent of each other.This presents a performance optimization opportunitythat we can take advantage of by running them in parallel.Build rules allow us to do just that.Let's take a look at how we can extract this workinto a build rule.I'll go to the Build Rules tab in the project editorfor our framework and click the plus buttonto add a new build rule.Then enter the file pattern "*.recipe",which corresponds to the file extensionof the file type I want this rule to process.Next, I'll add dependencies to this rule.I don't need to add any additional inputsto the build rule, because it will automaticallyget each input file it processes as an input.However, I do need to tell the build systemthe path of the output file that the rule will producefor each file it processes.I'll click the plus buttonto add a new output file and enter in$(DERIVED_ FILE_ DIR)/$ (INPUT_ FILE _BASE).compiledrecipe.It's best practice to write generated filesunder DERIVED_FILE_DIRsince this will point to an appropriate locationmanaged by the build system.You should avoid generating output filesunder the source root.This can interfere with source controland lead to conflictswhen running multiple builds simultaneously.Now we, of course, have to copy our script phase codeover to the rule.I'll go back to the script phase,and copy out the code where we processed each of the files.Then I'll go back to the rule and paste that in.Remember that rules run once for each input they process.So I'll remove the for loop,replace $RECIPE with $SCRIPT_INPUT_FILE --which corresponds to the absolute file pathof the current input file being processed --and replace $DERIVED_FILE_DIR/ $RECIPE.compiledrecipewith $SCRIPT_OUTPUT_FILE_0,which refers to the output file path I've enteredin the Output Files section below.Don't forget to quote variables to make sure spacesand other special characters in file pathsare handled correctly.Great.Now there's one more thing to configure in the rule.I mentioned that rules run once for each input they process.By default, they also run once for each architecturethat the target is compiling for.For example, a rule in a Mac app target might run oncefor arm64 and once for x86_64 times each of its inputs.So if there are four inputs times two architectures,the rule would be invoked eight times.This is useful when the output of the ruleis architecture-dependent, such as object code.However, in this case, my rule produces outputwhich is independent of the underlying CPU architecture,so I'm going to uncheck “Run once per architecture”.Lastly, in order for the build system to propagatethe input files into the build rule,I'll need to add all of the .recipe filesinto the Compile Sources build phase of my framework target.I'll go back to Build Phases, expand Compile Sources,and use the plus button to add the recipe files.Now let's go back to the script phase.The remaining piece of work this doesis merge the contents of multiple text filesinto a single file we can load at runtimein our app more efficiently.And in order to have better source control experience,I'm keeping scripts external to the project fileand calling them from the inline script editor here.So let's follow the reference to package.sh to see the code.A build rule wouldn't be appropriate in this case,since we need to process all the inputs at onceto combine them into one.So there's no way to break it up into isolated unitswhich can be run in parallel and therefore it makes senseto keep this work in the script phase.But this brings us to one of the most important takeaways:the script has no input and output dependencies specified.This might cause build tasks to run in the wrong orderand slows down the buildbecause Xcode has to be more conservativewith respect to running other tasks in parallel,as it doesn't know what files the script phase may be using.So it's important to add input and output dependenciesto ensure the work performed by script phases is donein the correct order relative to other tasks in the build.For this particular script, I have a large number of inputs.Instead of entering these in the project file one by one,I can use an xcfilelist to manage this list of inputsvia an external file.I'll go ahead and add one to the project now.I'll go to File > New File,and choose Build Phase File List under the Other section.I'll paste the list of input files that will be processedby this script phase, one per line.If you want, you can even write commentsby beginning a line with the pound sign,which is great for adding additional context.Now I'll reference this xcfilelistfrom the script phase.I'll go back to the script phase and specify the pathto the xcfilelist in the Input File Lists.Lastly, I'll specify an output dependencyby providing the file pathat which the output contents will be written,just like I did for the build rule.There's one more thing to mention.Similar to the build rule,there are some crucial environment variablesprovided for you by the script phase.Let's navigate back to package.shto have a closer look.In the source, I reference SCRIPT_INPUT_FILE_LIST_COUNT;which refers to the total number of input file listspassed to our script phase,SCRIPT_INPUT_FILE_LIST_n;which refers to the resolved absolute file pathof the input file list at the nth index,and SCRIPT_OUTPUT_FILE_0;which refers to the resolved absolute file pathof the first -- and in this case, only --output file.Here is an overview of some of the key environment variablesprovided to script phases.The build settings of the target are also made availableto the script phase environment.Here is an overview of some environment variablesspecific to build rules,as well as some less common ones.Like script phases, the build settings of the targetare also made available to the build rule environment.OK. Now, if I try to build the project,I'll run into an issue.Let's go to the build log to take a closer look.Because SmoothieKit is a multiplatform target,it's building twice: once for iOS and once for watchOS,and this means each of these builds are trying to producethe output of the script phase at the same path.This is not allowed because the build systemrequires that only one task in the entire buildmay produce the output at a given path.There are a couple different ways I could solve this.One simple solution would be to change the output pathof the script phase so that it's uniqueeach time the target is built.In this case, I could consider using a different build settinglike DERIVED_FILE_DIR, which is platform-specific,and would make the path sufficiently uniqueand solve the conflict.However, if the actual work that the script phase is doingwould be identical within the context of each target,that would simply cause the same work to be done twice.In that case, it can be a better optionto move the script phase to a new aggregate targetwhich the shared framework target depends on.That's what I'm going to do for my project.To get started, I'll click the plus buttonat the bottom of the target list,select the Other tab, and choose Aggregate target.I'll call it Resources.Then I'll add a new script phase,and copy the name, script source, inputs,and outputs from the framework target.Finally, I'll delete the original script phasefrom the framework target and then add a target dependencyon the new aggregate target.This way, the work will only be done once,there will be no output file conflict,and both the iOS and watchOS variants of the frameworkwill build in the correct order relative to that script phase.Build successful.And now, back to Prachi,who's going to tell you all about build settings.Prachi: Thank you, Jake!So what is a build setting?It is a property you can apply to Xcode targetsto configure aspects of how they are built.Xcode provides two main mechanismsfor configuring build settings.The first is through the build settings editor.The second is through a configuration settings fileor an .xcconfig file.Let's start by seeing how the build settings editorcan be used to manage the settings within our project.In order to bring up the build settings editor,first you need to select your projectin the Project navigator.Next, make sure to select the target you wish to configure.And finally, click the Build Settings tabacross the tab bar.From here, you can add new build settingsor modify existing ones.You can also find out additional informationfor the selected build settingby opening the Quick Help inspector.Build settings are defined at multiple levels.You can think of this as a stack of definitions.In fact, these levels can be visualizedby clicking on the Levels filter.Each column represents a different levela build setting can be defined in,and they are evaluated from the right to the left.Starting from the lowest level there is the default value,which is defined by the currently selected SDK,the project level configuration settings file,the project level settings from the Xcode project file,target settings defined in a configuration settings file,the target level settings definedin your Xcode project file,and finally, the resolved value of the build setting.Note that if you see a bold settingthat denotes that the level has an explicit valuefor the build setting.The other mechanism Xcode providesfor managing build settings are configuration setting filesor .xcconfig files.Some of the benefits of an xcconfig file include:better source control management,sharing settings across targets or configurations,advanced composition of build settings,and the ability to include additional xcconfig filesbased on your development or test environment.Let's take a look at how you can author build settingsin an xcconfig file.At its most basic level,a build setting is made up of a name,an assignment operator, and a value.You can narrow the value of a build settingusing the conditional syntax.Conditional settings are defined using square brackets.Some of the supported conditions includeconfiguration, architecture, and SDK.As shown with the SDK condition,wildcards can be used for matching purposes.Comments can be added as wellusing the familiar double-slash syntax.A build setting can be set to the valueof another build setting by using the dollar-parens syntax.In the example here, MY_OTHER_BUILD_SETTINGhas been set to YES.The value of MY_BUILD_SETTING_NAMEuses the dollar-parens syntax to evaluateMY_OTHER_BUILD_SETTING.Multiple values can be evaluated here as well,like we see with MORE_SETTINGS.And finally, existing values for a build settingcan be used with the $(inherited) value.This allows you to append additional valuesto a build settingwhile retaining all of its existing values.This is a convenience form as you could also usethe build setting name, APPEND_TO_EXISTING_SETTINGS.Another use of the build setting evaluation syntaxis to compose build settings togetherfrom a set of other build settings.First, we start with a control setting:IS_BUILD_SETTING_ENABLED.We will use the value of this setting as a suffixfor two additional build settings,MY_BUILD_SETTING_NO and MY_BUILD_SETTING_YES.Lastly, we define MY_BUILD_SETTINGto have a value that is composed of both MY_BUILD_SETTINGand IS_BUILD_SETTING_ENABLED.Because build setting evaluation happens inside-out,the inner-most setting is evaluatedand returns NO, which is the value ofIS_BUILD_SETTING_ENABLED.Finally, the composed BUILD_SETTING_NOis evaluated to a value of -use_this_one.When evaluating a build setting,there are a set of operators you can use to providesome basic transformations of your value.The three classifications of operators are:string operators, path operators,and replacement operators.The supported string operators are quote,which escapes the characters within the string;lower and upper, which convert cases of characters;and identifiers, which convert strings to valid identifiersin various formats.We provide a set of path operators to get the directory,filename, base name, suffix, and standardized path.For each path operator, there is a replacement counterpartthat allows you to replace part of a value.There's also a default operator which providesthe replacement value if the build setting is empty,otherwise it uses the existing value of the build setting.The last item to look at is the ability to includexcconfig files within other xcconfig files.There are two mechanisms available to you.The first are required includes,which requires the xcconfig file to exist on disk.A compiler error will be producedif the file cannot be found.The second are optional includes,which allow for including an xconfig file if present on disk.This will not fail if the file does not exist.Note that the path is relativefrom the location of your Xcode project file.So let's take a look at how you might putall of this information together in a real-world scenario.In this example,we'll be taking a look at how to solve the following problem.On our development machines,the compiler should aggressively warn for expressionsthat take too long to type check.However, the CI machines are slower,so the time for expression checking should be increased.For our solution,there are three configuration setting files:debug, common, and ci.xcconfig.The debug xcconfig file is used for our debug builds,and passes some additional flags to the Swift compilervia the OTHER_SWIFT_FLAGS build setting.The common xcconfig fileoptionally includes the ci.xcconfig file.It also defines the OTHER_SWIFT_FLAGS settingto control the type expression warning.It makes use of $(inherited)to ensure that any of the other flag settings are included,such as from the debug.xcconfig fileand a build setting evaluation for MAX _EXPRESSION_TIMEthat has a default value of 200.The ci xcconfig file defines an override valuefor MAX_EXPRESSION _TIME.Finally, Xcode needs to be toldhow to apply these xcconfig filesto one of the supported configuration levels.This is done through the project editor,which is what we see here.From the Configuration section,you can apply any of the config filesfrom your project at either the project or target levels,for any defined build configuration.Here, you can see that the debug.xcconfig fileis being applied at the project levelfor the debug configuration of Fruta.Also, common.xcconfig fileis set for each of the targets within the project.To recap the solution, the default operator was usedto define a default value for MAX_EXPRESSION_TIME.The ci.xcconfig file was optionally includedbecause it will only exist on the CI system.And an override of the default valuefor MAX_EXPRESSION_TIME was used in the ci xcconfig file.This wraps up our practical example.Now let's go back to Jake to review everythingthat we have covered.Jake: Thanks, Prachi.Let's recap.You learned about multiplatform frameworksand how they provide an easier wayto manage build settings and build phasesin multiplatform projects.You saw how you can improve your project configurationand build performance by building targets in parallelaccording to dependency order,how to properly use build rules and build phases,and the importance of specifying dependencies.Finally, you took a deep dive into build settings,how you can use configuration settings filesto manage them more easily, and dived into their syntaxand all of the constructs it provides.We hope these lessons provide you with a set of useful toolsto help you make the most of your development experience.Thank you for watching!♪

♪ Bass music playing ♪♪Jake Petroules: Hi, and welcome to"Explore advanced project configuration in Xcode".I'm Jake, and together with my colleague Prachi,I'll discuss strategies and techniques for makingthe most of your Xcode project's build configuration.We're going to cover three major topic areas.First, Prachi will discuss multiplatform projectsand Xcode 13's new support for multiplatform framework targets.Next, I'll cover best practices for modelingand configuring your project through schemes,target setup and dependency management,and build phases and rules.And finally, Prachi will take you on a deep diveinto build settings,where we'll cover their structure and behavior,the project editor UI,configuration settings files and their syntax,and a whole lot more!Throughout this talk, we'll be usinga multiplatform app project called Frutato show how these techniques apply to a real project.And now I'm going to hand it over to Prachi,who's going to talk about multiplatform frameworks.Prachi Pai Asnodkar: Thanks, Jake.One of the new features in Xcode 13is support for multiplatform frameworks.Multiplatform frameworks allow us to consolidatemultiple frameworks into one,providing us simplified target management,one set of build phases to manage,and one set of build settings to manage.Let's take a look at the Fruta appand update our project to take advantage of this feature.This is the Fruta app.It is a multiplatform app that builds for macOS,iOS, and watchOS.It also has three framework targets --one for each platform that contains a set of shared codeused by the apps.Maintaining three separate frameworkscan come with challenges,such as keeping build settings in sync,and ensuring all of your source files are properly addedto your compile sources build phases.To tackle these challenges,we'll start by converting one of our frameworksto a multiplatform framework.Here we have the three frameworks --one for each platform.All of these targets are identicalexcept that one has a file which only builds on macOS.First, let's navigate to the Build Settings tabin the project navigator for the macOS framework target.Next, we will configure the frameworkto build for all platforms by goingto the Supported Platforms build settingand choosing Any Platform.You can also see that Allow Multiplatform Buildshas been set to "Yes" automatically.This informs the build system to build this targetonce for each of its supported platforms,as necessary.Now that this is a multiplatform target,recall that the original macOS frameworkhad one additional file that should only buildwhen building for macOS.In order to configure our framework to do this,we can add a platform filter to specify that this fileshould only build for macOS.To do this, we will first go to the Build Phases tab.Next, expand the Compile Sources build phase.Finally, configure Ingredient+macOS.swiftto build only for macOS by clicking on the Filters itemand unchecking everything but macOS.Now that we have our new multiplatform target configured,we can delete the other two variants of our framework,as they are no longer needed.Additionally, because we have only one framework target,we will have to configure all of our appsto link and embed that new target.The macOS app is already configuredbecause we have set up our multiplatform targetstarting from the macOS one.We can add the new framework to the iOS and watchOS appsby going to the General tab for each of the app targets,and adding the frameworkto the Frameworks and Libraries build phase.To summarize: we took our macOS framework targetand enabled it to build for iOS and watchOS.We customized that framework with a platform filterfor our macOS-only source file.And finally, we configured our app targetsto link and embed the new single multiplatform framework target.And that's multiplatform targets in Xcode.Now back to Jake,who's going to dive deeper into project configuration.Jake: Thanks, Prachi.I'm going to discuss best practices for modelingand configuring your Xcode project,and show a few things you can do to improve the performanceand correctness of your builds.First, let's have a look at build options for the scheme.I'll click the scheme picker, Edit Scheme,then go to the Build section.There's a few simple things I can configure here.For Build Order,we recommend selecting Dependency Order,which will cause targets in your projectto build in parallel according to the dependency graph.This can greatly improve multicore build performanceand will also get you faster resultsfrom continuous integration.In contrast, choosing Manual Order is deprecatedand is not recommended.Using this option will slow down your buildand can cause cycle errorswhen the target order listed in the schemeis inconsistent with your project's dependencies.Another important setting in the scheme build optionsis Find Implicit Dependencies.Checking this option allows Xcodeto automatically add dependencies between targetsbased on the information in your project,such as linker flags in build settingsand the names of linked libraries in build phases.This can be especially usefulwhen the related targets are in different projectswhere you can't normally add an explicit target dependency.If you are using manual dependency orderto build targets in a specific order due to the inabilityto add explicit target dependenciesacross different projects,enabling Find Implicit Dependenciesin conjunction with choosing Dependency Orderis often a better solution.Now I'm going to talk about script phases and build rules.I'll select the SmoothieKit targetfrom the project's target list,and then select the Build Phases tab.Here we have a Process Recipes script phasethat contains some custom build logic.One of its responsibilities is generating codefrom a number of recipe fileswith one output per input, which we process in sequence.Now, you may realize that these computationsare completely independent of each other.This presents a performance optimization opportunitythat we can take advantage of by running them in parallel.Build rules allow us to do just that.Let's take a look at how we can extract this workinto a build rule.I'll go to the Build Rules tab in the project editorfor our framework and click the plus buttonto add a new build rule.Then enter the file pattern "*.recipe",which corresponds to the file extensionof the file type I want this rule to process.Next, I'll add dependencies to this rule.I don't need to add any additional inputsto the build rule, because it will automaticallyget each input file it processes as an input.However, I do need to tell the build systemthe path of the output file that the rule will producefor each file it processes.I'll click the plus buttonto add a new output file and enter in$(DERIVED_ FILE_ DIR)/$ (INPUT_ FILE _BASE).compiledrecipe.It's best practice to write generated filesunder DERIVED_FILE_DIRsince this will point to an appropriate locationmanaged by the build system.You should avoid generating output filesunder the source root.This can interfere with source controland lead to conflictswhen running multiple builds simultaneously.Now we, of course, have to copy our script phase codeover to the rule.I'll go back to the script phase,and copy out the code where we processed each of the files.Then I'll go back to the rule and paste that in.Remember that rules run once for each input they process.So I'll remove the for loop,replace $RECIPE with $SCRIPT_INPUT_FILE --which corresponds to the absolute file pathof the current input file being processed --and replace $DERIVED_FILE_DIR/ $RECIPE.compiledrecipewith $SCRIPT_OUTPUT_FILE_0,which refers to the output file path I've enteredin the Output Files section below.Don't forget to quote variables to make sure spacesand other special characters in file pathsare handled correctly.Great.Now there's one more thing to configure in the rule.I mentioned that rules run once for each input they process.By default, they also run once for each architecturethat the target is compiling for.For example, a rule in a Mac app target might run oncefor arm64 and once for x86_64 times each of its inputs.So if there are four inputs times two architectures,the rule would be invoked eight times.This is useful when the output of the ruleis architecture-dependent, such as object code.However, in this case, my rule produces outputwhich is independent of the underlying CPU architecture,so I'm going to uncheck “Run once per architecture”.Lastly, in order for the build system to propagatethe input files into the build rule,I'll need to add all of the .recipe filesinto the Compile Sources build phase of my framework target.I'll go back to Build Phases, expand Compile Sources,and use the plus button to add the recipe files.

Now let's go back to the script phase.The remaining piece of work this doesis merge the contents of multiple text filesinto a single file we can load at runtimein our app more efficiently.And in order to have better source control experience,I'm keeping scripts external to the project fileand calling them from the inline script editor here.So let's follow the reference to package.sh to see the code.A build rule wouldn't be appropriate in this case,since we need to process all the inputs at onceto combine them into one.So there's no way to break it up into isolated unitswhich can be run in parallel and therefore it makes senseto keep this work in the script phase.But this brings us to one of the most important takeaways:the script has no input and output dependencies specified.This might cause build tasks to run in the wrong orderand slows down the buildbecause Xcode has to be more conservativewith respect to running other tasks in parallel,as it doesn't know what files the script phase may be using.So it's important to add input and output dependenciesto ensure the work performed by script phases is donein the correct order relative to other tasks in the build.For this particular script, I have a large number of inputs.Instead of entering these in the project file one by one,I can use an xcfilelist to manage this list of inputsvia an external file.I'll go ahead and add one to the project now.I'll go to File > New File,and choose Build Phase File List under the Other section.

I'll paste the list of input files that will be processedby this script phase, one per line.If you want, you can even write commentsby beginning a line with the pound sign,which is great for adding additional context.Now I'll reference this xcfilelistfrom the script phase.I'll go back to the script phase and specify the pathto the xcfilelist in the Input File Lists.Lastly, I'll specify an output dependencyby providing the file pathat which the output contents will be written,just like I did for the build rule.There's one more thing to mention.Similar to the build rule,there are some crucial environment variablesprovided for you by the script phase.Let's navigate back to package.shto have a closer look.In the source, I reference SCRIPT_INPUT_FILE_LIST_COUNT;which refers to the total number of input file listspassed to our script phase,SCRIPT_INPUT_FILE_LIST_n;which refers to the resolved absolute file pathof the input file list at the nth index,and SCRIPT_OUTPUT_FILE_0;which refers to the resolved absolute file pathof the first -- and in this case, only --output file.Here is an overview of some of the key environment variablesprovided to script phases.The build settings of the target are also made availableto the script phase environment.Here is an overview of some environment variablesspecific to build rules,as well as some less common ones.Like script phases, the build settings of the targetare also made available to the build rule environment.OK. Now, if I try to build the project,I'll run into an issue.

Let's go to the build log to take a closer look.Because SmoothieKit is a multiplatform target,it's building twice: once for iOS and once for watchOS,and this means each of these builds are trying to producethe output of the script phase at the same path.This is not allowed because the build systemrequires that only one task in the entire buildmay produce the output at a given path.There are a couple different ways I could solve this.One simple solution would be to change the output pathof the script phase so that it's uniqueeach time the target is built.In this case, I could consider using a different build settinglike DERIVED_FILE_DIR, which is platform-specific,and would make the path sufficiently uniqueand solve the conflict.However, if the actual work that the script phase is doingwould be identical within the context of each target,that would simply cause the same work to be done twice.In that case, it can be a better optionto move the script phase to a new aggregate targetwhich the shared framework target depends on.That's what I'm going to do for my project.To get started, I'll click the plus buttonat the bottom of the target list,select the Other tab, and choose Aggregate target.I'll call it Resources.Then I'll add a new script phase,and copy the name, script source, inputs,and outputs from the framework target.

Finally, I'll delete the original script phasefrom the framework target and then add a target dependencyon the new aggregate target.

This way, the work will only be done once,there will be no output file conflict,and both the iOS and watchOS variants of the frameworkwill build in the correct order relative to that script phase.Build successful.And now, back to Prachi,who's going to tell you all about build settings.Prachi: Thank you, Jake!So what is a build setting?It is a property you can apply to Xcode targetsto configure aspects of how they are built.Xcode provides two main mechanismsfor configuring build settings.The first is through the build settings editor.The second is through a configuration settings fileor an .xcconfig file.Let's start by seeing how the build settings editorcan be used to manage the settings within our project.In order to bring up the build settings editor,first you need to select your projectin the Project navigator.Next, make sure to select the target you wish to configure.And finally, click the Build Settings tabacross the tab bar.From here, you can add new build settingsor modify existing ones.You can also find out additional informationfor the selected build settingby opening the Quick Help inspector.Build settings are defined at multiple levels.You can think of this as a stack of definitions.In fact, these levels can be visualizedby clicking on the Levels filter.Each column represents a different levela build setting can be defined in,and they are evaluated from the right to the left.Starting from the lowest level there is the default value,which is defined by the currently selected SDK,the project level configuration settings file,the project level settings from the Xcode project file,target settings defined in a configuration settings file,the target level settings definedin your Xcode project file,and finally, the resolved value of the build setting.Note that if you see a bold settingthat denotes that the level has an explicit valuefor the build setting.The other mechanism Xcode providesfor managing build settings are configuration setting filesor .xcconfig files.Some of the benefits of an xcconfig file include:better source control management,sharing settings across targets or configurations,advanced composition of build settings,and the ability to include additional xcconfig filesbased on your development or test environment.Let's take a look at how you can author build settingsin an xcconfig file.At its most basic level,a build setting is made up of a name,an assignment operator, and a value.You can narrow the value of a build settingusing the conditional syntax.Conditional settings are defined using square brackets.Some of the supported conditions includeconfiguration, architecture, and SDK.As shown with the SDK condition,wildcards can be used for matching purposes.Comments can be added as wellusing the familiar double-slash syntax.A build setting can be set to the valueof another build setting by using the dollar-parens syntax.In the example here, MY_OTHER_BUILD_SETTINGhas been set to YES.The value of MY_BUILD_SETTING_NAMEuses the dollar-parens syntax to evaluateMY_OTHER_BUILD_SETTING.Multiple values can be evaluated here as well,like we see with MORE_SETTINGS.And finally, existing values for a build settingcan be used with the $(inherited) value.This allows you to append additional valuesto a build settingwhile retaining all of its existing values.This is a convenience form as you could also usethe build setting name, APPEND_TO_EXISTING_SETTINGS.Another use of the build setting evaluation syntaxis to compose build settings togetherfrom a set of other build settings.First, we start with a control setting:IS_BUILD_SETTING_ENABLED.We will use the value of this setting as a suffixfor two additional build settings,MY_BUILD_SETTING_NO and MY_BUILD_SETTING_YES.Lastly, we define MY_BUILD_SETTINGto have a value that is composed of both MY_BUILD_SETTINGand IS_BUILD_SETTING_ENABLED.Because build setting evaluation happens inside-out,the inner-most setting is evaluatedand returns NO, which is the value ofIS_BUILD_SETTING_ENABLED.Finally, the composed BUILD_SETTING_NOis evaluated to a value of -use_this_one.When evaluating a build setting,there are a set of operators you can use to providesome basic transformations of your value.The three classifications of operators are:string operators, path operators,and replacement operators.The supported string operators are quote,which escapes the characters within the string;lower and upper, which convert cases of characters;and identifiers, which convert strings to valid identifiersin various formats.We provide a set of path operators to get the directory,filename, base name, suffix, and standardized path.For each path operator, there is a replacement counterpartthat allows you to replace part of a value.There's also a default operator which providesthe replacement value if the build setting is empty,otherwise it uses the existing value of the build setting.The last item to look at is the ability to includexcconfig files within other xcconfig files.There are two mechanisms available to you.The first are required includes,which requires the xcconfig file to exist on disk.A compiler error will be producedif the file cannot be found.The second are optional includes,which allow for including an xconfig file if present on disk.This will not fail if the file does not exist.Note that the path is relativefrom the location of your Xcode project file.So let's take a look at how you might putall of this information together in a real-world scenario.In this example,we'll be taking a look at how to solve the following problem.On our development machines,the compiler should aggressively warn for expressionsthat take too long to type check.However, the CI machines are slower,so the time for expression checking should be increased.For our solution,there are three configuration setting files:debug, common, and ci.xcconfig.The debug xcconfig file is used for our debug builds,and passes some additional flags to the Swift compilervia the OTHER_SWIFT_FLAGS build setting.The common xcconfig fileoptionally includes the ci.xcconfig file.It also defines the OTHER_SWIFT_FLAGS settingto control the type expression warning.It makes use of $(inherited)to ensure that any of the other flag settings are included,such as from the debug.xcconfig fileand a build setting evaluation for MAX _EXPRESSION_TIMEthat has a default value of 200.The ci xcconfig file defines an override valuefor MAX_EXPRESSION _TIME.Finally, Xcode needs to be toldhow to apply these xcconfig filesto one of the supported configuration levels.This is done through the project editor,which is what we see here.From the Configuration section,you can apply any of the config filesfrom your project at either the project or target levels,for any defined build configuration.Here, you can see that the debug.xcconfig fileis being applied at the project levelfor the debug configuration of Fruta.Also, common.xcconfig fileis set for each of the targets within the project.To recap the solution, the default operator was usedto define a default value for MAX_EXPRESSION_TIME.The ci.xcconfig file was optionally includedbecause it will only exist on the CI system.And an override of the default valuefor MAX_EXPRESSION_TIME was used in the ci xcconfig file.This wraps up our practical example.Now let's go back to Jake to review everythingthat we have covered.Jake: Thanks, Prachi.Let's recap.You learned about multiplatform frameworksand how they provide an easier wayto manage build settings and build phasesin multiplatform projects.You saw how you can improve your project configurationand build performance by building targets in parallelaccording to dependency order,how to properly use build rules and build phases,and the importance of specifying dependencies.Finally, you took a deep dive into build settings,how you can use configuration settings filesto manage them more easily, and dived into their syntaxand all of the constructs it provides.We hope these lessons provide you with a set of useful toolsto help you make the most of your development experience.Thank you for watching!♪

7:38 -Shell Script - Output Files

8:22 -Build Rule - code

10:15 -Shell Script - code

11:34 -XCFileList

11:57 -Shell Script - Input File Lists

12:11 -Shell Script - Output Files

12:50 -Environment Variables - Script Phases

13:00 -Environment Variables - Build Rules

18:17 -Build setting definition

18:30 -Build setting definition with conditions

19:50 -Build setting composition

21:08 -Build setting evaluation operators (paths)

21:21 -Build setting evaluation operators (replacement)

## Code Samples

```swift
$(DERIVED_FILE_DIR)/$(INPUT_FILE_BASE).compiledrecipe
```

```swift
"
$SRCROOT
/Scripts/gen-code.sh"
 
"
$SCRIPT_INPUT_FILE
"
 
"
$SCRIPT_OUTPUT_FILE_0
"
```

```swift
# Package up the recipes.



echo
 
"packaging..."



for
 i 
in
 $(seq 0 $(expr 
${SCRIPT_INPUT_FILE_LIST_COUNT}
 - 1)) ; 
do

    infile_=
"SCRIPT_INPUT_FILE_LIST_
$i
"

    
eval
 infile=\$
$infile_


    
while
 IFS= 
read
 -r file; 
do

        cat 
"
$file
"
 >> 
"
$SCRIPT_OUTPUT_FILE_0
"

    
done
 < 
"
$infile
"


done
```

```swift
$(SRCROOT)/Recipes/Instructions/berry-blue.md
$(SRCROOT)/Recipes/Instructions/carrot-chops.md
$(SRCROOT)/Recipes/Instructions/hulking-lemonade.md
$(SRCROOT)/Recipes/Instructions/kiwi-cutie.md
$(SRCROOT)/Recipes/Instructions/lemonberry.md
$(SRCROOT)/Recipes/Instructions/love-you-berry-much.md
$(SRCROOT)/Recipes/Instructions/mango-jambo.md
$(SRCROOT)/Recipes/Instructions/one-in-a-melon.md
$(SRCROOT)/Recipes/Instructions/papas-papaya.md
$(SRCROOT)/Recipes/Instructions/pina-y-coco.md
```

```swift
$(SRCROOT)/FileList.xcfilelist
```

```swift
$(PROJECT_TEMP_DIR)/instructions.mdarchive
```

```swift
// These environment variables are available 
in
 script phases:

SCRIPT_INPUT_FILE_COUNT // This specifies the number of paths from the Input Files table.
SCRIPT_INPUT_FILE_n // This specifies the absolute path of the nth file from the Input Files table, with build settings expanded.

SCRIPT_INPUT_FILE_LIST_COUNT // This specifies the number of input file lists.
SCRIPT_INPUT_FILE_LIST_n // This specifies the absolute path of the nth 
"resolved"
 input file list with contained paths made absolute, build settings expanded, and comments removed.

SCRIPT_OUTPUT_FILE_COUNT // This specifies the number of paths from the Output Files table.
SCRIPT_OUTPUT_FILE_n // This specifies the absolute path of the nth file from the Output Files table, with build settings expanded.

SCRIPT_OUTPUT_FILE_LIST_COUNT // This specifies the number of output file lists.
SCRIPT_OUTPUT_FILE_LIST_n // This specifies the absolute path of the nth 
"resolved"
 output file list with contained paths made absolute, build settings expanded, and comments removed.

* n 
in
 the above examples refers to a 0-based index.
```

```swift
// These environment variables are available 
in
 build rules:

SCRIPT_INPUT_FILE // This specifies the absolute path of the main input file being processed by the rule.

OTHER_INPUT_FILE_FLAGS // This specifies custom 
command
 line flags defined 
for
 the input file 
in
 the Compile Sources build phase.

SCRIPT_INPUT_FILE_COUNT // This specifies the number of paths from the Input Files table.
SCRIPT_INPUT_FILE_n // This specifies the absolute path of the nth file from the Input Files table, with build settings expanded.

SCRIPT_OUTPUT_FILE_COUNT // This specifies the number of paths from the Output Files table.
SCRIPT_OUTPUT_FILE_n // This specifies the absolute path of the nth file from the Output Files table, with build settings expanded.

SCRIPT_HEADER_VISIBILITY // This is 
set
 to 
"public"
 or 
"private"
 
if
 the input file being processed is a header file 
in
 a Headers build phase, and its Header Visibility is 
set
 to one of those values.

HEADER_OUTPUT_DIR // This specifies the output directory to 
which
 the input file should be copied, 
if
 the input file being processed is a header file 
in
 a Headers build phase.

* n 
in
 the above examples refers to a 0-based index.
```

```swift
MY_BUILD_SETTING_NAME = 
"A build setting value"
```

```swift
MY_BUILD_SETTING_NAME = 
"A build setting value"

MY_BUILD_SETTING_NAME[config=Debug] = -debug_flag
MY_BUILD_SETTING_NAME[arch=arm64] = -arm64_only
MY_BUILD_SETTING_NAME[sdk=iphone*] = -ios_only
```

```swift
IS_BUILD_SETTING_ENABLED = NO
MY_BUILD_SETTING_NO = -use_this_one
MY_BUILD_SETTING_YES = -use_this_instead
MY_BUILD_SETTING = $(MY_BUILD_SETTING_$(IS_BUILD_SETTING_ENABLED))
```

```swift
$(MY_PATH:dir)
$(MY_PATH:file)
$(MY_PATH:base)
$(MY_PATH:suffix)
$(MY_PATH:standardizepath)
```

```swift
$(MY_PATH:dir=/tmp)
$(MY_PATH:file=/better.swift)
$(MY_PATH:base=another)
$(MY_PATH:suffix=m)
$(MY_PATH:default=YES)
```


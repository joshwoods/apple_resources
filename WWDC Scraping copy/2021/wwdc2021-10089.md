# Wwdc2021 10089

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Explore Verifiable Health RecordsFind out how you can securely request access to someone's verifiable health records and incorporate that data safely into your app. The Health app helps people download, view, and share their health records, including their COVID-19 immunization and test results — and iOS 15 brings support for the SMART Health Card, a verifiable health record that incorporates the FHIR health data standard. We'll show you how your app can go about requesting access to this record and how you can verify the signature of the file using CryptoKit and the issuer's public key.ResourcesAccessing a User’s Clinical RecordsAccessing Data from a SMART Health CardAccessing Health RecordsHKVerifiableClinicalRecordHKVerifiableClinicalRecordQueryHD VideoSD VideoRelated VideosWWDC20Handling FHIR without getting burned

Find out how you can securely request access to someone's verifiable health records and incorporate that data safely into your app. The Health app helps people download, view, and share their health records, including their COVID-19 immunization and test results — and iOS 15 brings support for the SMART Health Card, a verifiable health record that incorporates the FHIR health data standard. We'll show you how your app can go about requesting access to this record and how you can verify the signature of the file using CryptoKit and the issuer's public key.

Accessing a User’s Clinical Records

Accessing Data from a SMART Health Card

Accessing Health Records

HKVerifiableClinicalRecord

HKVerifiableClinicalRecordQuery

HD VideoSD Video

HD Video

SD Video

Handling FHIR without getting burned

Search this video…Hi.My name is Annie, and I'm a software engineeron the Health Records team.I'm joined today by my colleague Caryto show you how you can empower peopleto share their verifiable health records using HealthKit.Before we dive into verifiable health records,I want to briefly reintroduce the Health Records featurethat we launched back in 2018 for iOS 11.3.Health Records allows users to connect to their providersand securely download their clinical recordsto the Health app for easy storageand visualization.This is all built on top of industry standardslike HL7's Fast Healthcare Interoperability Resources,or FHIR.With user permission,your app can access these health recordsthat users have downloaded with HealthKit.For more details about the existing Health Records API,I encourage you to check out our WWDC 2018 video,"Accessing Health Records with HealthKit" to learn more.For iOS 15, we're leveraging our Health Records workto allow for the download, storage,and sharing of verifiable recordsin the Health appimplemented based on the SMART Health Cards specification.Let's explore what verifiable health records areand how they're different from the health records datayou can currently query for with HealthKit.First, a verifiable health record containsmultiple FHIR resources, including a patient resourceand one or more clinical resources.These resources are bundledin what we call a SMART Health Card.Issuers, or institutions that createverifiable health records, such as a labor healthcare provider, cryptographically signthis SMART Health Card as a JSON Web Signature, or JWS.Finally, issuers generate verifiable health recordssuch that they include only necessary informationabout the patient and their clinical data.To get a clearer picture of these points,let's look at an example.For this example,the record contains two FHIR immunization resources,one for each dose of a vaccine.It also includes a FHIR patient resourceto identify who received the vaccine.These resources are then combinedinto a SMART Health Card,which, in its raw form, looks like this.The SMART Health Card payload includes informationsuch as the type, which contains URLs that declarewhat types of data to expect in the health card,and the credential subject, which includes the FHIR versionand a Bundle resource that contains the immunizationand patient resources.The SMART Health Card is then signed as a JWS,which has two components: A header and a payload.The JWS header houses the algorithm usedto sign the JWS; the public key thumbprint,which specifies which of the issuer's public keys wasused to sign; and the algorithm used to compress the payload.The compressed JWS payload,along with the credential subject,contains other claims data, including the issuer URL,where the issuer's public keys are located,the issued date, and an optional expiration date.In its raw form,this is what a Verifiable Health Record looks like.For more information, we encourage youto visit the SMART Health Card specificationvia the link associated with this session.Now that we've reviewedwhat a verifiable health record looks like,let me show you how you can import these recordsinto the Health app.One option is to use the existing Health Records feature.Users can download verifiable health recordsto the Health app by connectingto a Health Records-enabled provider.Note that this option is only availablewhere the Health Records feature is available,which is currently in the US, UK, and Canada.Users also have the options of downloading a filewith a .smart-health-cards extension or scanninga smart-health-card file-embedded QR code.This will display the following sheetin the Health app, where users can view detailsand choose whether to download these records.These two options are available internationally.Finally, how can you request accessto this data with HealthKit?We are introducing a new HealthKit query,HKVerifiableClinicalRecordQuery, and a new HKSample subclass,HKVerifiableClinicalRecord for iOS 15.Unlike other HKQuery subclasses, in order to use this query,you must request for a HealthKit access entitlementfor Verifiable Health Records.While you will still have accessto the public headers in the SDK,the results handler will return an authorization denied errorwithout the entitlement.Please refer to the links associated with this sessionfor information on how to get started.Before we dive deeper into the query and sample classes,let's look at authorization for Verifiable Health Records,which is slightly different from what you might be used towith Health Records.First, Verifiable Health Recordsobserves a per-sample authorization pattern,where the user selects individual samples,not types, to share with your app.This type of authorization provides userswith more granular control over their dataand is important in protecting their privacy.The current HealthKit authorization patternconsists of two steps:First requesting user authorizationfor types to read and share,and then querying for samples once authorization is granted.With Verifiable Health Records, this first step is not needed.Instead, once an instance of HKVerifiableClinicalRecordQueryis created and executed,an authorization sheet will be presented,allowing the user to select which individual recordsto share with your app.After sharing,the chosen records are then returnedto the query's results handler.Furthermore, authorizationfor Verifiable Health Records is one-time only.Sharing these records with a third-party appdoes not set up long-term access authorization.Each execution of a HKVerifiableClinicalRecordQuerywill result in the presentationof the following authorization sheetand the return of user-selected recordsto the results handler.Now that we've gone over authorization,let's look at HKVerifiableClinicalRecordQueryin more detail.To initialize the HKVerifiableClinicalRecordQuery,you will first have to provide a string array of record types,which we defined earlier as the type of data presentin a verifiable health record.Only records with all provided record types presentwill be shown in the authorization sheet.Like other HealthKit queries,you also have the option to add a predicateto further filter the set of samples for authorization.We are providing a convenience constructorto create a predicate for recordswith relevant dates within a date interval.Once the query is executed and the user taps "Share Once,"the authorized HKVerifiableClinicalRecordsare then returned in the results handler.The record includes basic informationabout the subject and issuer,and, of course, the JWS property,which will contain the raw data that you will verify and decode.Now that we've gone through the Verifiable Health Recordsfeature and what its API looks like,I'm going to hand it off to Cary,who will walk you through how to import test data,use the API to request records, and verify a record's JWS.Thanks, Annie.Hi, everyone.My name is Cary, and I'm also an engineeron the Health Records team.Today, I'll be walking you through how to workwith Verifiable Health Records.So the best way to start working with this new featureis to load some test data into HealthKit.As Annie mentioned, there are three different methodsyou can use to get started.If you're in the United States, Canada, or the United Kingdom,you can simply connect to a provider using the existingHealth Records feature in the Health App.Another new way we've addedis by downloading a .smart-health-card file,an example of which you can findon the smarthealth.cards specification website.The third method is by scanning a QR code.So let's go get some data.For this demo,you can start by trying out the new QR code import.You'll start with a device running iOS 15and scanning this QR code.As soon as you scan it, you will receive a promptto open directly into the health app.Once you switch to the health app,it will immediately begin guiding youthrough importing this health card.After selecting the "Add to Health" option,the import process will complete.You can scroll over to the browse taband see the imported records under the immunizations section.If you go ahead and tap into this category,you can now see that you have a vaccineand that its signature has been verified by the Health app.Now that you have some signed records importedinto the Health app, you're ready to go aheadand request these records from your own app.Now, let's look at an exampleof how your app can access this new API.First, you'll start by importing HealthKit.Next, you'll create a HealthStore,which you may already be familiar with doingif you've used the standard HealthKit authorization API.You will also create a list of record types to specify the typeof data that you would like the user to share with you.When authorizing, you will be presented with a listof data to share that only match these record types.Next, you will create a predicate specifyingthe valid date range for samples to share.In this example, you can see labs conductedin the past seven days are being requested.Then you will create a queryusing the constructed recordTypes and predicate,using a completion to checkwhether the samples presented were shared with your app.Finally, executing the query willcause an authorization sheet to be presentedwhere results may be selected to share with your app.This dialogue will be presented every timethis method is executed.Now that you have retrieved a piece of signed clinical data,you can write some code to verify its signaturewithin your app.To review, digital signatures are a mathematical wayto verify the authenticity of digital information.This process may be performed by any device,such as a server or another mobile device,but let's go ahead and take a look at how to do itfrom within your app.You can accomplish this using four main steps.First, you will parse the clinical data using a Codable.Second,you will decompress the signed JSON Web Token payload.Third,you will download the issuer's public key from their website.And finally, you will use CryptoKitto verify the signature.Let's start by looking at how to define the data modelfor a signed record, which is formally definedin the JSON Web Signature specification.This struct is defined in three main parts:A header, payload, and signature.You could use Swift Codable to do the parsing for you,and you should keep an original representation of the headerand payload around for use during signature verification.Most importantly, you'll add an initializerto parse the JWS from its compact serialized form.Next, you'll create a structused to represent the JWS Header.You will need this during the initializationfrom compact serialization,as well as during the signature verification process.You can see here in the headerthat you can expect to find a specified signature algorithm,a key-ID field used to hold a public key thumbprint,and a compression algorithm.The public key thumbprint is used to identify whichof the issuer's keys was used to sign the JWS.This process requires the ES256 Signature Algorithmand the DEF compression algorithm,both of which are supported by first-party Swift libraries.Now let's look at the code needed to parse the JWSfrom its compact serialization.You'll start by splitting the serialized stringinto its constituent pieces,each of which is Base64URL encoded.After creating a JSONDecoder and Base64URL decoding the headerand payload, you can check to seeif the header indicates that the payload is compressed correctly.After checking the compression, you will use a utility methodthat you can find in the provided sample projectto decompress the payload.The next piece you'll need is a structto model the health card payload.The two most important pieces here are the issuer field,which will hold the issuer's web identifierthat you can use to fetch their keys,and the other is the VC field,which holds all the patient data.For more information on how to parse the VC fieldand analyze its contents,check out the "Handling FHIR without getting burned" talkfrom WWDC 2020.Now that you've seen how to parse a JWS,you are ready to verify its authenticity.Let's look at creating an extensionthat will add a verification method to your JWS struct.Since you'll be reaching out to the issuer's website directlyto retrieve their signing keys, you can use Combine to helpwith the asynchronous aspects of this process,and you can use CryptoKit to helpwith the signature verification.Inside the verification method,you'll begin by pulling out the issuer's identifier,which is always the issuer's web address.Here, you can add your own method to check if the URLis one that you personally trust and abort if it's onethat you don't want to accept results from.Next, you will create a URL to retrieve the issuer's keysby appending the standard .wellknown/jwks.json URL path.This path suffix is defined in the specificationand should be the same for all issuers.Now that you have constructed the well-known URL,you can connect to the issuer, download their keys,and finish verifying the signature.You'll finish writing this method by creatinga URLSession dataTaskPublisher that willconnect to the issuer's well-known jwk endpoint.You can then map it to data, decode it using a jsonDecoderto a set of JWKs, and finally map it to a boolean,indicating whether or not the signature is valid.Inside the final map block you will select the issuer's keybased on what the JWS header indicates.The final piece involves using CryptoKitto verify the signature.According to the JWS specification,the signed portion of data is formed by concatenatingthe Base64URL-encoded header and payload joined by a period.Next, you'll convert the downloaded JWK keysto CryptoKit P256 signing keys, using a utility methodthat you can find in the sample project accompanying this talk.Finally, you'll use CryptoKit's isValidSignature methodto do the verification of the signature.Now that your data model and all logic neededto verify its authenticity is defined,you can put everything together.Taking a look at the earlier exampleof how to call the new API, you can replace this commentwith a call to your new verification method.Since the API returns a list of all selected samples,you can select the first one from the list.Next, parse it from data to a String.Then parse it using your compact serialization initializer.Finally, call your new verification method,and listen for emitted boolean results.And just like that,we've seen how to take a signed piece of clinical datadownload the issuer's signing keys,and validate the signature of these records.Now, I'll hand things back to Annie to summarize.Thanks, Cary.Before we wrap up, I want to talkabout privacy with respect to Verifiable Health Records.Hopefully, I've made it clear throughout this sessionthat the Verifiable Health Records featureis built with user privacy in mind.First of all,the SMART Health Card specification uses data profilesthat minimize the information an issuer should includein each record.The Health app is designed to protect sensitive health data,so when a phone is locked,all health and fitness data in the Health app is encrypted,which includes verifiable health records.Access to verifiable health records requires an applicationto an entitlement that will come with additional obligationsto ensure that this sensitive health data is not misused.And finally, users will have additional control over howto share their verifiable health records with your app.Let's review what we've covered today.In iOS 15, building on top of Health Records,we are bringing the capability to import verifiable recordsinto the Health app and for developersto read this data with a new API.To wrap up, here's what you can do next.First, to learn moreabout the verifiable health data ecosystem,check out the SMART Health Cards specification.Import test records into the Health appto try it out yourself.Download the sample app, which showshow you can query for and verify those test records.And finally, when you're ready to ship your app,request the HealthKit access entitlementfor verifiable health records.Thank you for watching, and have a great WWDC.[music]

Hi.

My name is Annie, and I'm a software engineeron the Health Records team.

I'm joined today by my colleague Caryto show you how you can empower peopleto share their verifiable health records using HealthKit.Before we dive into verifiable health records,I want to briefly reintroduce the Health Records featurethat we launched back in 2018 for iOS 11.3.Health Records allows users to connect to their providersand securely download their clinical recordsto the Health app for easy storageand visualization.

This is all built on top of industry standardslike HL7's Fast Healthcare Interoperability Resources,or FHIR.With user permission,your app can access these health recordsthat users have downloaded with HealthKit.For more details about the existing Health Records API,I encourage you to check out our WWDC 2018 video,"Accessing Health Records with HealthKit" to learn more.For iOS 15, we're leveraging our Health Records workto allow for the download, storage,and sharing of verifiable recordsin the Health appimplemented based on the SMART Health Cards specification.

Let's explore what verifiable health records areand how they're different from the health records datayou can currently query for with HealthKit.First, a verifiable health record containsmultiple FHIR resources, including a patient resourceand one or more clinical resources.These resources are bundledin what we call a SMART Health Card.Issuers, or institutions that createverifiable health records, such as a labor healthcare provider, cryptographically signthis SMART Health Card as a JSON Web Signature, or JWS.Finally, issuers generate verifiable health recordssuch that they include only necessary informationabout the patient and their clinical data.

To get a clearer picture of these points,let's look at an example.For this example,the record contains two FHIR immunization resources,one for each dose of a vaccine.It also includes a FHIR patient resourceto identify who received the vaccine.These resources are then combinedinto a SMART Health Card,which, in its raw form, looks like this.The SMART Health Card payload includes informationsuch as the type, which contains URLs that declarewhat types of data to expect in the health card,and the credential subject, which includes the FHIR versionand a Bundle resource that contains the immunizationand patient resources.The SMART Health Card is then signed as a JWS,which has two components: A header and a payload.

The JWS header houses the algorithm usedto sign the JWS; the public key thumbprint,which specifies which of the issuer's public keys wasused to sign; and the algorithm used to compress the payload.The compressed JWS payload,along with the credential subject,contains other claims data, including the issuer URL,where the issuer's public keys are located,the issued date, and an optional expiration date.

In its raw form,this is what a Verifiable Health Record looks like.

For more information, we encourage youto visit the SMART Health Card specificationvia the link associated with this session.

Now that we've reviewedwhat a verifiable health record looks like,let me show you how you can import these recordsinto the Health app.

One option is to use the existing Health Records feature.Users can download verifiable health recordsto the Health app by connectingto a Health Records-enabled provider.

Note that this option is only availablewhere the Health Records feature is available,which is currently in the US, UK, and Canada.Users also have the options of downloading a filewith a .smart-health-cards extension or scanninga smart-health-card file-embedded QR code.This will display the following sheetin the Health app, where users can view detailsand choose whether to download these records.These two options are available internationally.

Finally, how can you request accessto this data with HealthKit?We are introducing a new HealthKit query,HKVerifiableClinicalRecordQuery, and a new HKSample subclass,HKVerifiableClinicalRecord for iOS 15.Unlike other HKQuery subclasses, in order to use this query,you must request for a HealthKit access entitlementfor Verifiable Health Records.While you will still have accessto the public headers in the SDK,the results handler will return an authorization denied errorwithout the entitlement.Please refer to the links associated with this sessionfor information on how to get started.Before we dive deeper into the query and sample classes,let's look at authorization for Verifiable Health Records,which is slightly different from what you might be used towith Health Records.

First, Verifiable Health Recordsobserves a per-sample authorization pattern,where the user selects individual samples,not types, to share with your app.This type of authorization provides userswith more granular control over their dataand is important in protecting their privacy.The current HealthKit authorization patternconsists of two steps:First requesting user authorizationfor types to read and share,and then querying for samples once authorization is granted.With Verifiable Health Records, this first step is not needed.Instead, once an instance of HKVerifiableClinicalRecordQueryis created and executed,an authorization sheet will be presented,allowing the user to select which individual recordsto share with your app.

After sharing,the chosen records are then returnedto the query's results handler.

Furthermore, authorizationfor Verifiable Health Records is one-time only.

Sharing these records with a third-party appdoes not set up long-term access authorization.Each execution of a HKVerifiableClinicalRecordQuerywill result in the presentationof the following authorization sheetand the return of user-selected recordsto the results handler.Now that we've gone over authorization,let's look at HKVerifiableClinicalRecordQueryin more detail.

To initialize the HKVerifiableClinicalRecordQuery,you will first have to provide a string array of record types,which we defined earlier as the type of data presentin a verifiable health record.

Only records with all provided record types presentwill be shown in the authorization sheet.Like other HealthKit queries,you also have the option to add a predicateto further filter the set of samples for authorization.We are providing a convenience constructorto create a predicate for recordswith relevant dates within a date interval.Once the query is executed and the user taps "Share Once,"the authorized HKVerifiableClinicalRecordsare then returned in the results handler.The record includes basic informationabout the subject and issuer,and, of course, the JWS property,which will contain the raw data that you will verify and decode.Now that we've gone through the Verifiable Health Recordsfeature and what its API looks like,I'm going to hand it off to Cary,who will walk you through how to import test data,use the API to request records, and verify a record's JWS.Thanks, Annie.Hi, everyone.My name is Cary, and I'm also an engineeron the Health Records team.Today, I'll be walking you through how to workwith Verifiable Health Records.So the best way to start working with this new featureis to load some test data into HealthKit.As Annie mentioned, there are three different methodsyou can use to get started.If you're in the United States, Canada, or the United Kingdom,you can simply connect to a provider using the existingHealth Records feature in the Health App.

Another new way we've addedis by downloading a .smart-health-card file,an example of which you can findon the smarthealth.cards specification website.The third method is by scanning a QR code.So let's go get some data.For this demo,you can start by trying out the new QR code import.You'll start with a device running iOS 15and scanning this QR code.As soon as you scan it, you will receive a promptto open directly into the health app.Once you switch to the health app,it will immediately begin guiding youthrough importing this health card.After selecting the "Add to Health" option,the import process will complete.

You can scroll over to the browse taband see the imported records under the immunizations section.If you go ahead and tap into this category,you can now see that you have a vaccineand that its signature has been verified by the Health app.Now that you have some signed records importedinto the Health app, you're ready to go aheadand request these records from your own app.Now, let's look at an exampleof how your app can access this new API.

First, you'll start by importing HealthKit.Next, you'll create a HealthStore,which you may already be familiar with doingif you've used the standard HealthKit authorization API.You will also create a list of record types to specify the typeof data that you would like the user to share with you.When authorizing, you will be presented with a listof data to share that only match these record types.Next, you will create a predicate specifyingthe valid date range for samples to share.In this example, you can see labs conductedin the past seven days are being requested.Then you will create a queryusing the constructed recordTypes and predicate,using a completion to checkwhether the samples presented were shared with your app.Finally, executing the query willcause an authorization sheet to be presentedwhere results may be selected to share with your app.

This dialogue will be presented every timethis method is executed.

Now that you have retrieved a piece of signed clinical data,you can write some code to verify its signaturewithin your app.

To review, digital signatures are a mathematical wayto verify the authenticity of digital information.This process may be performed by any device,such as a server or another mobile device,but let's go ahead and take a look at how to do itfrom within your app.You can accomplish this using four main steps.First, you will parse the clinical data using a Codable.Second,you will decompress the signed JSON Web Token payload.Third,you will download the issuer's public key from their website.

And finally, you will use CryptoKitto verify the signature.

Let's start by looking at how to define the data modelfor a signed record, which is formally definedin the JSON Web Signature specification.This struct is defined in three main parts:A header, payload, and signature.You could use Swift Codable to do the parsing for you,and you should keep an original representation of the headerand payload around for use during signature verification.

Most importantly, you'll add an initializerto parse the JWS from its compact serialized form.Next, you'll create a structused to represent the JWS Header.You will need this during the initializationfrom compact serialization,as well as during the signature verification process.You can see here in the headerthat you can expect to find a specified signature algorithm,a key-ID field used to hold a public key thumbprint,and a compression algorithm.The public key thumbprint is used to identify whichof the issuer's keys was used to sign the JWS.This process requires the ES256 Signature Algorithmand the DEF compression algorithm,both of which are supported by first-party Swift libraries.Now let's look at the code needed to parse the JWSfrom its compact serialization.

You'll start by splitting the serialized stringinto its constituent pieces,each of which is Base64URL encoded.After creating a JSONDecoder and Base64URL decoding the headerand payload, you can check to seeif the header indicates that the payload is compressed correctly.After checking the compression, you will use a utility methodthat you can find in the provided sample projectto decompress the payload.The next piece you'll need is a structto model the health card payload.

The two most important pieces here are the issuer field,which will hold the issuer's web identifierthat you can use to fetch their keys,and the other is the VC field,which holds all the patient data.For more information on how to parse the VC fieldand analyze its contents,check out the "Handling FHIR without getting burned" talkfrom WWDC 2020.Now that you've seen how to parse a JWS,you are ready to verify its authenticity.

Let's look at creating an extensionthat will add a verification method to your JWS struct.

Since you'll be reaching out to the issuer's website directlyto retrieve their signing keys, you can use Combine to helpwith the asynchronous aspects of this process,and you can use CryptoKit to helpwith the signature verification.Inside the verification method,you'll begin by pulling out the issuer's identifier,which is always the issuer's web address.Here, you can add your own method to check if the URLis one that you personally trust and abort if it's onethat you don't want to accept results from.Next, you will create a URL to retrieve the issuer's keysby appending the standard .wellknown/jwks.json URL path.

This path suffix is defined in the specificationand should be the same for all issuers.

Now that you have constructed the well-known URL,you can connect to the issuer, download their keys,and finish verifying the signature.You'll finish writing this method by creatinga URLSession dataTaskPublisher that willconnect to the issuer's well-known jwk endpoint.You can then map it to data, decode it using a jsonDecoderto a set of JWKs, and finally map it to a boolean,indicating whether or not the signature is valid.Inside the final map block you will select the issuer's keybased on what the JWS header indicates.

The final piece involves using CryptoKitto verify the signature.According to the JWS specification,the signed portion of data is formed by concatenatingthe Base64URL-encoded header and payload joined by a period.Next, you'll convert the downloaded JWK keysto CryptoKit P256 signing keys, using a utility methodthat you can find in the sample project accompanying this talk.Finally, you'll use CryptoKit's isValidSignature methodto do the verification of the signature.Now that your data model and all logic neededto verify its authenticity is defined,you can put everything together.Taking a look at the earlier exampleof how to call the new API, you can replace this commentwith a call to your new verification method.

Since the API returns a list of all selected samples,you can select the first one from the list.

Next, parse it from data to a String.Then parse it using your compact serialization initializer.Finally, call your new verification method,and listen for emitted boolean results.

And just like that,we've seen how to take a signed piece of clinical datadownload the issuer's signing keys,and validate the signature of these records.

Now, I'll hand things back to Annie to summarize.

Thanks, Cary.

Before we wrap up, I want to talkabout privacy with respect to Verifiable Health Records.Hopefully, I've made it clear throughout this sessionthat the Verifiable Health Records featureis built with user privacy in mind.First of all,the SMART Health Card specification uses data profilesthat minimize the information an issuer should includein each record.The Health app is designed to protect sensitive health data,so when a phone is locked,all health and fitness data in the Health app is encrypted,which includes verifiable health records.Access to verifiable health records requires an applicationto an entitlement that will come with additional obligationsto ensure that this sensitive health data is not misused.

And finally, users will have additional control over howto share their verifiable health records with your app.Let's review what we've covered today.

In iOS 15, building on top of Health Records,we are bringing the capability to import verifiable recordsinto the Health app and for developersto read this data with a new API.

To wrap up, here's what you can do next.First, to learn moreabout the verifiable health data ecosystem,check out the SMART Health Cards specification.

Import test records into the Health appto try it out yourself.

Download the sample app, which showshow you can query for and verify those test records.And finally, when you're ready to ship your app,request the HealthKit access entitlementfor verifiable health records.Thank you for watching, and have a great WWDC.

[music]

## Code Samples


# Wwdc2021 10133

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Protect mutable state with Swift actorsData races occur when two separate threads concurrently access the same mutable state. They are trivial to construct, but are notoriously hard to debug.

Discover how you can stop these data races in their tracks with Swift actors, which help synchronize access to data in your code. Discover how actors work and how to share values between them. Learn about how actor isolation affects protocol conformances. And finally, meet the main actor, a new way of ensuring that your code always runs on the main thread when needed.

To get the most out of this session, we recommend first watching “Meet async/await in Swift.”ResourcesSE-0302: Sendable and @Sendable closuresSE-0306: ActorsSE-0313: Improved control over actor isolationSE-0316: Global actorsThe Swift Programming Language: ConcurrencyHD VideoSD VideoRelated VideosWWDC22Eliminate data races using Swift ConcurrencyMeet distributed actors in SwiftUse Xcode for server-side developmentVisualize and optimize Swift concurrencyWWDC21Discover concurrency in SwiftUIExplore structured concurrency in SwiftMeet async/await in SwiftSwift concurrency: Behind the scenesSwift concurrency: Update a sample appWhat's new in AppKitWhat‘s new in Swift

Data races occur when two separate threads concurrently access the same mutable state. They are trivial to construct, but are notoriously hard to debug.

Discover how you can stop these data races in their tracks with Swift actors, which help synchronize access to data in your code. Discover how actors work and how to share values between them. Learn about how actor isolation affects protocol conformances. And finally, meet the main actor, a new way of ensuring that your code always runs on the main thread when needed.

To get the most out of this session, we recommend first watching “Meet async/await in Swift.”

SE-0302: Sendable and @Sendable closures

SE-0306: Actors

SE-0313: Improved control over actor isolation

SE-0316: Global actors

The Swift Programming Language: Concurrency

HD VideoSD Video

HD Video

SD Video

Eliminate data races using Swift Concurrency

Meet distributed actors in Swift

Use Xcode for server-side development

Visualize and optimize Swift concurrency

Discover concurrency in SwiftUI

Explore structured concurrency in Swift

Meet async/await in Swift

Swift concurrency: Behind the scenes

Swift concurrency: Update a sample app

What's new in AppKit

What‘s new in Swift

Search this video…♪ Bass music playing ♪♪Dario Rexin: Hi, my name is Dario Rexin,and I am an engineer on the Swift team here at Apple.Today, my colleague Doug and I will talk about actors in Swiftand how they are utilized to protect mutable statein concurrent Swift applications.One of the fundamentally hard problemswith writing concurrent programs is avoiding data races.Data races occur when two separate threadsconcurrently access the same dataand at least one of those accesses is a write.Data races are trivial to constructbut are notoriously hard to debug.Here's a simple counter class with one operationthat increments the counter and returns its new value.Let's say we go ahead and try to incrementfrom two concurrent tasks.This is a bad idea.Depending on the timing of the execution,we might get 1 and then 2, or 2 and then 1.This is expected, and in both cases,the counter would be left in a consistent state.But because we've introduced a data race,we could also get 1 and 1 if both tasks read a 0and write a 1.Or even 2 and 2 if the return statements happenafter both increment operations.Data races are notoriously hard to avoid and debug.They require nonlocal reasoning because the data accessescausing the race might be in different parts of the program.And they are nondeterministic because the operating system'sscheduler might interleave the concurrent tasksin different ways each time you run your program.Data races are caused by shared mutable state.If your data doesn't changeor it isn't shared across multiple concurrent tasks,you can't have a data race on it.One way to avoid data racesis to eliminate shared mutable stateby using value semantics.With a variable of a value type, all mutation is local.Moreover, "let" properties of value-semantic typesare truly immutable,so it's safe to access them from different concurrent tasks.Swift has been promoting value semantics since its inceptionbecause they make it easier to reason about our programand those same things also make them safeto use in concurrent programs.In this example, we create an array with some values.Next, we assign that array to a second variable.Now we append a different value to each copy of the array.When we print both arrays at the end,we see that both copies contain the valuesthat the array was initialized with,but each appended value is only presentin the respective copy we appended them to.The majority of types in Swift's standard libraryhave value semantics, including collection typeslike dictionary, or as in this example, array.Now that we have established that value semanticssolve all of our data races,let's go ahead and make our counter a value typeby turning it into a struct.We also have to mark the increment function as mutating,so it can modify the value property.When we are now trying to modify the counterwe will get a compiler error because the counter is a let,which prevents us from mutating it.Now, it seems very tempting to just change the counter variableto a var to make it mutable.But that would leave us, again, with a race conditionbecause the counter would be referencedby both concurrent tasks.Luckily, the compiler has us coveredand does not allow us to compile this unsafe code.We can instead assign the counterto a local mutable variable inside each concurrent task.When we execute our example now,it will always print 1 for both concurrent tasks.But even though our code is now race-free,the behavior is not what we want anymore.This goes to show that there are still caseswhere shared mutable state is required.When we have shared mutable state in a concurrent program,we need some form of synchronizationto ensure that concurrent use of our shared mutable statewon't cause data races.There are a number of primitives for synchronization,from low-level tools like atomics and locksto higher-level constructs like serial dispatch queues.Each of these primitives has its various strengths,but they all share the same critical weakness:they require careful discipline to use exactly correctly,every single time,or we'll end up with a data race.This is where actors come in.Actors are a synchronization mechanismfor shared mutable state.An actor has its own stateand that state is isolated from the rest of the program.The only way to access that stateis by going through the actor.And whenever you go through the actor,the actor's synchronization mechanism ensuresthat no other code is concurrentlyaccessing the actor's state.This gives us the same mutual exclusion propertythat we get from manually using locksor serial dispatch queues, but with actors,it is a fundamental guarantee provided by Swift.You can't forget to perform the synchronization,because Swift will produce a compiler error if you try.Actors are a new kind of type in Swift.They provide the same capabilitiesas all of the named types in Swift.They can have properties, methods, initializers,subscripts, and so on.They can conform to protocolsand be augmented with extensions.Like classes, they are reference types;because the purpose of actors is to express shared mutable state.In fact, the primary distinguishing characteristicof actor types is that they isolate their instance datafrom the rest of the programand ensure synchronized access to that data.All of their special behavior follows from those core ideas.Here, we've defined our counter as an actor type.We still have the instance property valuefor the counter,and the increment method to increment that valueand return the new value.The difference is that the actor will ensure the valueisn't accessed concurrently.In this case, that means the increment method,when called, will run to completionwithout any other code executing on the actor.That guarantee eliminates the potential for data raceson the actor's state.Let's bring back our data race example.We again have two concurrent tasksattempting to increment the same counter.The actor's internal synchronization mechanismensures that one increment call executes to completionbefore the other can start.So we can get 1 and 2 or 2 and 1because both are valid concurrent executions,but we cannot get the same count twiceor skip any values because the internal synchronizationof the actor has eliminated the potential for data raceson the actor state.Let's consider what actually happenswhen both concurrent tasks try to increment the counterat the same time.One will get there first,and the other will have to wait its turn.But how can we ensure that the second taskcan patiently await its turn on the actor?Swift has a mechanism for that.Whenever you interact with an actor from the outside,you do so asynchronously.If the actor is busy, then your code will suspendso that the CPU you're running on can do other useful work.When the actor becomes free again,it will wake up your code -- resuming execution --so the call can run on the actor.The await keyword in this example indicatesthat the asynchronous call to the actormight involve such a suspension.Let's stretch our counterexample just a bit furtherby adding an unnecessarily slow reset operation.This operation sets the value back to 0,then calls increment an appropriate number of timesto get the counter to the new value.This resetSlowly method is defined in an extensionof the counter actor type so it is inside the actor.That means it can directly access the actor's state,which it does to reset the counter value to 0.It can also synchronously call other methods on the actor,such as in the call to increment.There's no await required because we already knowwe're running on the actor.This is an important property of actors.Synchronous code on the actor always runs to completionwithout being interrupted.So we can reason about synchronous code sequentially,without needing to consider the effects of concurrencyon our actor state.We have stressed that our synchronous coderuns uninterrupted, but actors often interact with each otheror with other asynchronous code in the system.Let's take a few minutes to talk about asynchronous codeand actors.But first, we need a better example.Here we are building an image downloader actor.It is responsible for downloading an imagefrom another service.It also stores downloaded images in a cacheto avoid downloading the same image multiple times.The logical flow is straightforward:check the cache, download the image,then record the image in the cache before returning.Because we are in an actor,this code is free from low-level data races;any number of images can be downloaded concurrently.The actor's synchronization mechanisms guaranteethat only one task can execute codethat accesses the cache instance property at a time,so there is no way that the cache can be corrupted.That said, the await keyword hereis communicating something very important.Whenever an await occurs,it means that the function can be suspended at this point.It gives up its CPU so other code in the program can execute,which affects the overall program state.At the point where your function resumes,the overall program state will have changed.It is important to ensure that you haven't made assumptionsabout that state prior to the awaitthat may not hold after the await.Imagine we have two different concurrent taskstrying to fetch the same image at the same time.The first sees that there is no cache entry,proceeds to start downloading the image from the server,and then gets suspended because the download will take a while.While the first task is downloading the image,a new image might be deployed to the server under the same URL.Now, a second concurrent task tries to fetch the imageunder that URL.It also sees no cache entrybecause the first download has not finished yet,then starts a second download of the image.It also gets suspended while its download completes.After a while, one of the downloads --let's assume it's the first -- will completeand its task will resume execution on the actor.It populates the cacheand returns the resulting image of a cat.Now the second task has its download complete,so it wakes up.It overwrites the same entry in the cachewith the image of the sad cat that it got.So even though the cache was already populated with an image,we now get a different image for the same URL.That's a bit of a surprise.We expected that once we cache an image,we always get that same image back for the same URLso our user interface remains consistent,at least until we go and manually clear out of the cache.But here, the cached image changed unexpectedly.We don't have any low-level data races,but because we carried assumptions about stateacross an await,we ended up with a potential bug.The fix here is to check our assumptions after the await.If there's already an entry in the cache when we resume,we keep that original version and throw away the new one.A better solution would beto avoid redundant downloads entirely.We've put that solution in the codeassociated with this video.Actor reentrancy prevents deadlocksand guarantees forward progress,but it requires you to check your assumptionsacross each await.To design well for reentrancy,perform mutation of actor state within synchronous code.Ideally, do it within a synchronous functionso all state changes are well-encapsulated.State changes can involve temporarily putting our actorinto an inconsistent state.Make sure to restore consistency before an await.And remember that await is a potential suspension point.If your code gets suspended,the program and world will move onbefore your code gets resumed.Any assumptions you've made about global state,clocks, timers, or your actor will need to be checkedafter the await.And now my colleague Doug will tell you moreabout actor isolation. Doug?Doug Gregor: Thanks, Dario.Actor isolation is fundamental to the behavior of actor types.Dario discussed how actor isolation is guaranteedby the Swift language model,through asynchronous interactionsfrom outside the actor.In this section, we'll talk about how actor isolationinteracts with other language features,including protocol conformances, closures, and classes.Like other types, actors can conform to protocolsso long as they can satisfy the requirements of the protocol.For example, let's make this LibraryAccount actorconform to the Equatable protocol.The static equality method compares two library accountsbased on their ID numbers.Because the method is static, there is no self instanceand so it is not isolated to the actor.Instead, we have two parameters of actor type,and this static method is outside of both of them.That's OK because the implementation is only accessingimmutable state on the actor.Let's extend our example furtherto make our library account conformto the Hashable protocol.Doing so requires implementing the hash(into) operation,which we can do like this.However, the Swift compiler will complainthat this conformance isn't allowed.What happened?Well, conforming to Hashable this way means thatthis function could be called from outside the actor,but hash(into) is not async,so there is no way to maintain actor isolation.To fix this, we can make this method nonisolated.Nonisolated means that this method is treatedas being outside the actor,even though it is, syntactically,described on the actor.This means that it can satisfy the synchronous requirementfrom the Hashable protocol.Because nonisolated methodsare treated as being outside the actor,they cannot reference mutable state on the actor.This method is finebecause it's referring to the immutable ID number.If we were to try to hash based on something else,such as the array of books on loan, we will get an errorbecause access to mutable state from the outsidewould permit data races.That's enough of protocol conformances.Let's talk about closures.Closures are little functionsthat are defined within one function,that can then be passed to another functionto be called some time later.Like functions, a closure might be actor-isolatedor it might be nonisolated.In this example, we're going to read somefrom each book we have on loanand return the total number of pages we've read.The call to reduce involves a closurethat performs the reading.Note that there is no await in this call to readSome.That's because this closure,which is formed within the actor-isolated function "read",is itself actor-isolated.We know this is safe because the reduce operationis going to execute synchronously,and can't escape the closure out to some other threadwhere it could cause concurrent access.Now, let's do something a little different.I don't have time to read just now,so let's read later.Here, we create a detached task.A detached task executes the closure concurrentlywith other work that the actor is doing.Therefore, the closure cannot be on the actoror we would introduce data races.So this closure is not isolated to the actor.When it wants to call the read method,it must do so asynchronously, as indicated by the await.We've talked a bit about actor isolation of code,which is whether that code runs inside the actor or outside it.Now, let's talk about actor isolation and data.In our library account example,we've studiously avoided saying what the book type actually is.I've been assuming it's a value type,like a struct.That's a good choice because it means thatall the state for an instance of the library account actoris self-contained.If we go ahead and call this methodto select a random book to read,we'll get a copy of the book that we can read.Changes we make to our copy of the bookwon't affect the actor and vice versa.However, if the turn the book into a class,things are a little different.Our library account actor now references instancesof the book class.That's not a problem in itself.However, what happens when we call the methodto select a random book?Now we have a reference into the mutable state of the actor,which has been shared outside of the actor.We've created the potential for data races.Now, if we go and update the title of the book,the modification happens in state that is accessiblewithin the actor.Because the visit method is not on the actor,this modification could end up being a data race.Value types and actors are both safe to use concurrently,but classes can still pose problems.We have a name for types that are safe to use concurrently:Sendable.A Sendable type is one whose values can be sharedacross different actors.If you copy a value from one place to another,and both places can safely modify their own copiesof that value without interfering with each other,the type can be Sendable.Value types are Sendable because each copy is independent,as Dario talked about earlier.Actor types are Sendablebecause they synchronize access to their mutable state.Classes can be Sendable,but only if they are carefully implemented.For example, if a class and all of its subclassesonly hold immutable data,then it can be called Sendable.Or if the class internally performs synchronization,for example with a lock,to ensure safe concurrent access, it can be Sendable.But most classes are neither of these,and cannot be Sendable.Functions aren't necessarily Sendable,so there is a new kind of function typefor functions that are safe to pass across actors.We'll get back to those shortly.Your actors --in fact, all of your concurrent code --should primarily communicate in terms of Sendable types.Sendable types protect code from data races.This is a propertythat Swift will eventually start checking statically.At that point,it will become an error to pass a non-Sendable typeacross actor boundaries.How does one know that a type is Sendable?Well, Sendable is a protocol,and you state that your type conforms to Sendablethe same way you do with other protocols.Swift will then check to make sure your typemakes sense as a Sendable type.A Book struct can be Sendable if all of its stored propertiesare of Sendable type.Let's say Author is actually a class,which means it -- and therefore the array of authors --are not Sendable.Swift will produce a compiler errorindicating that Book cannot be Sendable.For generic types, whether they are Sendablecan depend on their generic arguments.We can use conditional conformanceto propagate Sendable when it's appropriate.For example, a pair type will be Sendableonly when both of its generic arguments are Sendable.The same approach is used to conclude that an arrayof Sendable types is itself Sendable.We encourage you introduce Sendable conformancesto the types whose values are safe to share concurrently.Use those types within your actors.Then when Swift begins to start enforcing Sendableacross actors, your code will be ready.Functions themselves can be Sendable,meaning that it is safe to pass the function valueacross actors.This is particularly important for closures where it restrictswhat the closure can do to help prevent data races.For example, a Sendable closurecannot capture a mutable local variable,because that would allow data raceson the local variable.Anything the closure does captureneeds to be Sendable,to make sure that the closure cannot be usedto move non-Sendable types across actor boundaries.And finally, a synchronous Sendable closurecannot be actor-isolated, because that would allow codeto be run on the actor from the outside.We've actually be relying on the idea of Sendable closuresin this talk.The operation that creates detached taskstakes a Sendable function,written here with the @Sendable in the function type.Remember our counterexample from the beginning of the talk?We were trying to build a value-typed counter.Then, we tried to go and modify itfrom two different closures at the same time.This would be a data race on the mutable local variable.However, because the closure for a detached task is Sendable,Swift will produce an error here.Sendable function types are usedto indicate where concurrent execution can occur,and therefore prevent data races.Here's another example we saw earlier.Because the closure for the detached task is Sendable,we know that it should not be isolated to the actor.Therefore, interactions with it will have to be asynchronous.Sendable types and closures help maintain actor isolationby checking that mutable state isn't shared across actors,and cannot be modified concurrently.We've been talking primarily about actor types,and how they interact with protocols, closures,and Sendable types.There is one more actor to discuss --a special one that we call the main actor.When you are building an app,you need to think about the main thread.It is where the core user interface rendering happens,as well as where user interaction eventsare processed.Operations that work with the UIgenerally need to be performed from the main thread.However, you don't want to do all of your workon the main thread.If you do too much work on the main thread, say,because you have some slow input/output operationor blocking interaction with a server,your UI will freeze.So, you need to be careful to do work on the main threadwhen it interacts with the UIbut get off the main thread quicklyfor computationally expensive or long-waiting operations.So, we do work off the main thread when we canand then call DispatchQueue.main.asyncin your code whenever you have a particular operationthat must be executed on the main thread.Stepping back from the details of the mechanism,the structure of this code looks vaguely familiar.In fact, interacting with the main threadis a whole lot like interacting with an actor.If you know you're already running on the main thread,you can safely access and update your UI state.If you aren't running on the main thread,you need to interact with it asynchronously.This is exactly how actors work.There's a special actor to describe the main thread,which we call the main actor.The main actor is an actorthat represents the main thread.It differs from a normal actor in two important ways.First, the main actor performs all of its synchronizationthrough the main dispatch queue.This means that, from a runtime perspective,the main actor is interchangeablewith using DispatchQueue.main.Second, the code and data that needs to be on the main threadis scattered everywhere.It's in SwiftUI, AppKit, UIKit, and other system frameworks.It's spread across your own views, view controllers,and the UI-facing parts of your data model.With Swift concurrency, you can mark a declarationwith the main actor attribute to say that it must be executedon the main actor.We've done that with the checked-out operation here,so it always runs on the main actor.If you call it from outside the main actor,you need to await, so that the call will be performedasynchronously on the main thread.By marking code that must run on the main threadas being on the main actor, there is no more guessworkabout when to use DispatchQueue.main.Swift ensures that this codeis always executed on the main thread.Types can be placed on the main actor as well,which makes all of their members and subclassesbe on the main actor.This is useful for the parts of your code basethat must interact with the UI,where most everything needs to run on the main thread.Individual methods can opt-out via the nonisolated keyword,with the same rules you're familiar withfrom normal actors.By using the main actor for your UI-facing typesand operations, and introducing your own actorsfor managing other program state,you can architect your app to ensure safe,correct use of concurrency.In this session, we've talked about how actorsprotect their mutable state from concurrent access,using actor isolation and by requiring asynchronous accessfrom outside the actor to serialize execution.Use actors to build safe, concurrent abstractionsin your Swift code.In implementing your actors, and in any asynchronous code,always design for reentrancy; an await in your codemeans the world can move on and invalidate your assumptions.Value types and actors work togetherto eliminate data races.Be aware of classes that don't handletheir own synchronization, and other non-Sendable typesthat reintroduce shared mutable state.Finally, use the main actor on your codethat interacts with the UI to ensure that the codethat must be on the main thread always runs on the main thread.To learn more about how to use actorswithin your own application, check out our sessionon updating an app for Swift concurrency.And to learn more about the implementationof Swift's concurrency model, including actors,check out our "Behind the scenes" session.Actors are a core part of the Swift concurrency model.They work together with async/awaitand structured concurrency to make it easier to buildcorrect and efficient concurrent programs.We can't wait to see what you build with them.♪

♪ Bass music playing ♪♪Dario Rexin: Hi, my name is Dario Rexin,and I am an engineer on the Swift team here at Apple.

Today, my colleague Doug and I will talk about actors in Swiftand how they are utilized to protect mutable statein concurrent Swift applications.

One of the fundamentally hard problemswith writing concurrent programs is avoiding data races.

Data races occur when two separate threadsconcurrently access the same dataand at least one of those accesses is a write.

Data races are trivial to constructbut are notoriously hard to debug.

Here's a simple counter class with one operationthat increments the counter and returns its new value.

Let's say we go ahead and try to incrementfrom two concurrent tasks.

This is a bad idea.

Depending on the timing of the execution,we might get 1 and then 2, or 2 and then 1.

This is expected, and in both cases,the counter would be left in a consistent state.

But because we've introduced a data race,we could also get 1 and 1 if both tasks read a 0and write a 1.

Or even 2 and 2 if the return statements happenafter both increment operations.

Data races are notoriously hard to avoid and debug.

They require nonlocal reasoning because the data accessescausing the race might be in different parts of the program.

And they are nondeterministic because the operating system'sscheduler might interleave the concurrent tasksin different ways each time you run your program.

Data races are caused by shared mutable state.

If your data doesn't changeor it isn't shared across multiple concurrent tasks,you can't have a data race on it.

One way to avoid data racesis to eliminate shared mutable stateby using value semantics.

With a variable of a value type, all mutation is local.

Moreover, "let" properties of value-semantic typesare truly immutable,so it's safe to access them from different concurrent tasks.

Swift has been promoting value semantics since its inceptionbecause they make it easier to reason about our programand those same things also make them safeto use in concurrent programs.

In this example, we create an array with some values.

Next, we assign that array to a second variable.

Now we append a different value to each copy of the array.

When we print both arrays at the end,we see that both copies contain the valuesthat the array was initialized with,but each appended value is only presentin the respective copy we appended them to.

The majority of types in Swift's standard libraryhave value semantics, including collection typeslike dictionary, or as in this example, array.

Now that we have established that value semanticssolve all of our data races,let's go ahead and make our counter a value typeby turning it into a struct.

We also have to mark the increment function as mutating,so it can modify the value property.

When we are now trying to modify the counterwe will get a compiler error because the counter is a let,which prevents us from mutating it.

Now, it seems very tempting to just change the counter variableto a var to make it mutable.

But that would leave us, again, with a race conditionbecause the counter would be referencedby both concurrent tasks.

Luckily, the compiler has us coveredand does not allow us to compile this unsafe code.

We can instead assign the counterto a local mutable variable inside each concurrent task.

When we execute our example now,it will always print 1 for both concurrent tasks.

But even though our code is now race-free,the behavior is not what we want anymore.

This goes to show that there are still caseswhere shared mutable state is required.

When we have shared mutable state in a concurrent program,we need some form of synchronizationto ensure that concurrent use of our shared mutable statewon't cause data races.

There are a number of primitives for synchronization,from low-level tools like atomics and locksto higher-level constructs like serial dispatch queues.

Each of these primitives has its various strengths,but they all share the same critical weakness:they require careful discipline to use exactly correctly,every single time,or we'll end up with a data race.

This is where actors come in.

Actors are a synchronization mechanismfor shared mutable state.

An actor has its own stateand that state is isolated from the rest of the program.

The only way to access that stateis by going through the actor.

And whenever you go through the actor,the actor's synchronization mechanism ensuresthat no other code is concurrentlyaccessing the actor's state.

This gives us the same mutual exclusion propertythat we get from manually using locksor serial dispatch queues, but with actors,it is a fundamental guarantee provided by Swift.

You can't forget to perform the synchronization,because Swift will produce a compiler error if you try.

Actors are a new kind of type in Swift.

They provide the same capabilitiesas all of the named types in Swift.

They can have properties, methods, initializers,subscripts, and so on.

They can conform to protocolsand be augmented with extensions.

Like classes, they are reference types;because the purpose of actors is to express shared mutable state.

In fact, the primary distinguishing characteristicof actor types is that they isolate their instance datafrom the rest of the programand ensure synchronized access to that data.

All of their special behavior follows from those core ideas.

Here, we've defined our counter as an actor type.

We still have the instance property valuefor the counter,and the increment method to increment that valueand return the new value.

The difference is that the actor will ensure the valueisn't accessed concurrently.

In this case, that means the increment method,when called, will run to completionwithout any other code executing on the actor.

That guarantee eliminates the potential for data raceson the actor's state.

Let's bring back our data race example.

We again have two concurrent tasksattempting to increment the same counter.

The actor's internal synchronization mechanismensures that one increment call executes to completionbefore the other can start.

So we can get 1 and 2 or 2 and 1because both are valid concurrent executions,but we cannot get the same count twiceor skip any values because the internal synchronizationof the actor has eliminated the potential for data raceson the actor state.

Let's consider what actually happenswhen both concurrent tasks try to increment the counterat the same time.

One will get there first,and the other will have to wait its turn.

But how can we ensure that the second taskcan patiently await its turn on the actor?Swift has a mechanism for that.

Whenever you interact with an actor from the outside,you do so asynchronously.

If the actor is busy, then your code will suspendso that the CPU you're running on can do other useful work.

When the actor becomes free again,it will wake up your code -- resuming execution --so the call can run on the actor.

The await keyword in this example indicatesthat the asynchronous call to the actormight involve such a suspension.

Let's stretch our counterexample just a bit furtherby adding an unnecessarily slow reset operation.

This operation sets the value back to 0,then calls increment an appropriate number of timesto get the counter to the new value.

This resetSlowly method is defined in an extensionof the counter actor type so it is inside the actor.

That means it can directly access the actor's state,which it does to reset the counter value to 0.

It can also synchronously call other methods on the actor,such as in the call to increment.

There's no await required because we already knowwe're running on the actor.

This is an important property of actors.

Synchronous code on the actor always runs to completionwithout being interrupted.

So we can reason about synchronous code sequentially,without needing to consider the effects of concurrencyon our actor state.

We have stressed that our synchronous coderuns uninterrupted, but actors often interact with each otheror with other asynchronous code in the system.

Let's take a few minutes to talk about asynchronous codeand actors.

But first, we need a better example.

Here we are building an image downloader actor.

It is responsible for downloading an imagefrom another service.

It also stores downloaded images in a cacheto avoid downloading the same image multiple times.

The logical flow is straightforward:check the cache, download the image,then record the image in the cache before returning.

Because we are in an actor,this code is free from low-level data races;any number of images can be downloaded concurrently.

The actor's synchronization mechanisms guaranteethat only one task can execute codethat accesses the cache instance property at a time,so there is no way that the cache can be corrupted.

That said, the await keyword hereis communicating something very important.

Whenever an await occurs,it means that the function can be suspended at this point.

It gives up its CPU so other code in the program can execute,which affects the overall program state.

At the point where your function resumes,the overall program state will have changed.

It is important to ensure that you haven't made assumptionsabout that state prior to the awaitthat may not hold after the await.

Imagine we have two different concurrent taskstrying to fetch the same image at the same time.

The first sees that there is no cache entry,proceeds to start downloading the image from the server,and then gets suspended because the download will take a while.

While the first task is downloading the image,a new image might be deployed to the server under the same URL.

Now, a second concurrent task tries to fetch the imageunder that URL.

It also sees no cache entrybecause the first download has not finished yet,then starts a second download of the image.

It also gets suspended while its download completes.

After a while, one of the downloads --let's assume it's the first -- will completeand its task will resume execution on the actor.

It populates the cacheand returns the resulting image of a cat.

Now the second task has its download complete,so it wakes up.

It overwrites the same entry in the cachewith the image of the sad cat that it got.

So even though the cache was already populated with an image,we now get a different image for the same URL.

That's a bit of a surprise.

We expected that once we cache an image,we always get that same image back for the same URLso our user interface remains consistent,at least until we go and manually clear out of the cache.

But here, the cached image changed unexpectedly.

We don't have any low-level data races,but because we carried assumptions about stateacross an await,we ended up with a potential bug.

The fix here is to check our assumptions after the await.

If there's already an entry in the cache when we resume,we keep that original version and throw away the new one.

A better solution would beto avoid redundant downloads entirely.

We've put that solution in the codeassociated with this video.

Actor reentrancy prevents deadlocksand guarantees forward progress,but it requires you to check your assumptionsacross each await.

To design well for reentrancy,perform mutation of actor state within synchronous code.

Ideally, do it within a synchronous functionso all state changes are well-encapsulated.

State changes can involve temporarily putting our actorinto an inconsistent state.

Make sure to restore consistency before an await.

And remember that await is a potential suspension point.

If your code gets suspended,the program and world will move onbefore your code gets resumed.

Any assumptions you've made about global state,clocks, timers, or your actor will need to be checkedafter the await.

And now my colleague Doug will tell you moreabout actor isolation. Doug?Doug Gregor: Thanks, Dario.

Actor isolation is fundamental to the behavior of actor types.

Dario discussed how actor isolation is guaranteedby the Swift language model,through asynchronous interactionsfrom outside the actor.

In this section, we'll talk about how actor isolationinteracts with other language features,including protocol conformances, closures, and classes.

Like other types, actors can conform to protocolsso long as they can satisfy the requirements of the protocol.

For example, let's make this LibraryAccount actorconform to the Equatable protocol.

The static equality method compares two library accountsbased on their ID numbers.

Because the method is static, there is no self instanceand so it is not isolated to the actor.

Instead, we have two parameters of actor type,and this static method is outside of both of them.

That's OK because the implementation is only accessingimmutable state on the actor.

Let's extend our example furtherto make our library account conformto the Hashable protocol.

Doing so requires implementing the hash(into) operation,which we can do like this.

However, the Swift compiler will complainthat this conformance isn't allowed.

What happened?Well, conforming to Hashable this way means thatthis function could be called from outside the actor,but hash(into) is not async,so there is no way to maintain actor isolation.

To fix this, we can make this method nonisolated.

Nonisolated means that this method is treatedas being outside the actor,even though it is, syntactically,described on the actor.

This means that it can satisfy the synchronous requirementfrom the Hashable protocol.

Because nonisolated methodsare treated as being outside the actor,they cannot reference mutable state on the actor.

This method is finebecause it's referring to the immutable ID number.

If we were to try to hash based on something else,such as the array of books on loan, we will get an errorbecause access to mutable state from the outsidewould permit data races.

That's enough of protocol conformances.

Let's talk about closures.

Closures are little functionsthat are defined within one function,that can then be passed to another functionto be called some time later.

Like functions, a closure might be actor-isolatedor it might be nonisolated.

In this example, we're going to read somefrom each book we have on loanand return the total number of pages we've read.

The call to reduce involves a closurethat performs the reading.

Note that there is no await in this call to readSome.

That's because this closure,which is formed within the actor-isolated function "read",is itself actor-isolated.

We know this is safe because the reduce operationis going to execute synchronously,and can't escape the closure out to some other threadwhere it could cause concurrent access.

Now, let's do something a little different.

I don't have time to read just now,so let's read later.

Here, we create a detached task.

A detached task executes the closure concurrentlywith other work that the actor is doing.

Therefore, the closure cannot be on the actoror we would introduce data races.

So this closure is not isolated to the actor.

When it wants to call the read method,it must do so asynchronously, as indicated by the await.

We've talked a bit about actor isolation of code,which is whether that code runs inside the actor or outside it.

Now, let's talk about actor isolation and data.

In our library account example,we've studiously avoided saying what the book type actually is.

I've been assuming it's a value type,like a struct.

That's a good choice because it means thatall the state for an instance of the library account actoris self-contained.

If we go ahead and call this methodto select a random book to read,we'll get a copy of the book that we can read.

Changes we make to our copy of the bookwon't affect the actor and vice versa.

However, if the turn the book into a class,things are a little different.

Our library account actor now references instancesof the book class.

That's not a problem in itself.

However, what happens when we call the methodto select a random book?Now we have a reference into the mutable state of the actor,which has been shared outside of the actor.

We've created the potential for data races.

Now, if we go and update the title of the book,the modification happens in state that is accessiblewithin the actor.

Because the visit method is not on the actor,this modification could end up being a data race.

Value types and actors are both safe to use concurrently,but classes can still pose problems.

We have a name for types that are safe to use concurrently:Sendable.

A Sendable type is one whose values can be sharedacross different actors.

If you copy a value from one place to another,and both places can safely modify their own copiesof that value without interfering with each other,the type can be Sendable.

Value types are Sendable because each copy is independent,as Dario talked about earlier.

Actor types are Sendablebecause they synchronize access to their mutable state.

Classes can be Sendable,but only if they are carefully implemented.

For example, if a class and all of its subclassesonly hold immutable data,then it can be called Sendable.

Or if the class internally performs synchronization,for example with a lock,to ensure safe concurrent access, it can be Sendable.

But most classes are neither of these,and cannot be Sendable.

Functions aren't necessarily Sendable,so there is a new kind of function typefor functions that are safe to pass across actors.

We'll get back to those shortly.

Your actors --in fact, all of your concurrent code --should primarily communicate in terms of Sendable types.

Sendable types protect code from data races.

This is a propertythat Swift will eventually start checking statically.

At that point,it will become an error to pass a non-Sendable typeacross actor boundaries.

How does one know that a type is Sendable?Well, Sendable is a protocol,and you state that your type conforms to Sendablethe same way you do with other protocols.

Swift will then check to make sure your typemakes sense as a Sendable type.

A Book struct can be Sendable if all of its stored propertiesare of Sendable type.

Let's say Author is actually a class,which means it -- and therefore the array of authors --are not Sendable.

Swift will produce a compiler errorindicating that Book cannot be Sendable.

For generic types, whether they are Sendablecan depend on their generic arguments.

We can use conditional conformanceto propagate Sendable when it's appropriate.

For example, a pair type will be Sendableonly when both of its generic arguments are Sendable.

The same approach is used to conclude that an arrayof Sendable types is itself Sendable.

We encourage you introduce Sendable conformancesto the types whose values are safe to share concurrently.

Use those types within your actors.

Then when Swift begins to start enforcing Sendableacross actors, your code will be ready.

Functions themselves can be Sendable,meaning that it is safe to pass the function valueacross actors.

This is particularly important for closures where it restrictswhat the closure can do to help prevent data races.

For example, a Sendable closurecannot capture a mutable local variable,because that would allow data raceson the local variable.

Anything the closure does captureneeds to be Sendable,to make sure that the closure cannot be usedto move non-Sendable types across actor boundaries.

And finally, a synchronous Sendable closurecannot be actor-isolated, because that would allow codeto be run on the actor from the outside.

We've actually be relying on the idea of Sendable closuresin this talk.

The operation that creates detached taskstakes a Sendable function,written here with the @Sendable in the function type.

Remember our counterexample from the beginning of the talk?We were trying to build a value-typed counter.

Then, we tried to go and modify itfrom two different closures at the same time.

This would be a data race on the mutable local variable.

However, because the closure for a detached task is Sendable,Swift will produce an error here.

Sendable function types are usedto indicate where concurrent execution can occur,and therefore prevent data races.

Here's another example we saw earlier.

Because the closure for the detached task is Sendable,we know that it should not be isolated to the actor.

Therefore, interactions with it will have to be asynchronous.

Sendable types and closures help maintain actor isolationby checking that mutable state isn't shared across actors,and cannot be modified concurrently.

We've been talking primarily about actor types,and how they interact with protocols, closures,and Sendable types.

There is one more actor to discuss --a special one that we call the main actor.

When you are building an app,you need to think about the main thread.

It is where the core user interface rendering happens,as well as where user interaction eventsare processed.

Operations that work with the UIgenerally need to be performed from the main thread.

However, you don't want to do all of your workon the main thread.

If you do too much work on the main thread, say,because you have some slow input/output operationor blocking interaction with a server,your UI will freeze.

So, you need to be careful to do work on the main threadwhen it interacts with the UIbut get off the main thread quicklyfor computationally expensive or long-waiting operations.

So, we do work off the main thread when we canand then call DispatchQueue.main.asyncin your code whenever you have a particular operationthat must be executed on the main thread.

Stepping back from the details of the mechanism,the structure of this code looks vaguely familiar.

In fact, interacting with the main threadis a whole lot like interacting with an actor.

If you know you're already running on the main thread,you can safely access and update your UI state.

If you aren't running on the main thread,you need to interact with it asynchronously.

This is exactly how actors work.

There's a special actor to describe the main thread,which we call the main actor.

The main actor is an actorthat represents the main thread.

It differs from a normal actor in two important ways.

First, the main actor performs all of its synchronizationthrough the main dispatch queue.

This means that, from a runtime perspective,the main actor is interchangeablewith using DispatchQueue.main.

Second, the code and data that needs to be on the main threadis scattered everywhere.

It's in SwiftUI, AppKit, UIKit, and other system frameworks.

It's spread across your own views, view controllers,and the UI-facing parts of your data model.

With Swift concurrency, you can mark a declarationwith the main actor attribute to say that it must be executedon the main actor.

We've done that with the checked-out operation here,so it always runs on the main actor.

If you call it from outside the main actor,you need to await, so that the call will be performedasynchronously on the main thread.

By marking code that must run on the main threadas being on the main actor, there is no more guessworkabout when to use DispatchQueue.main.

Swift ensures that this codeis always executed on the main thread.

Types can be placed on the main actor as well,which makes all of their members and subclassesbe on the main actor.

This is useful for the parts of your code basethat must interact with the UI,where most everything needs to run on the main thread.

Individual methods can opt-out via the nonisolated keyword,with the same rules you're familiar withfrom normal actors.

By using the main actor for your UI-facing typesand operations, and introducing your own actorsfor managing other program state,you can architect your app to ensure safe,correct use of concurrency.

In this session, we've talked about how actorsprotect their mutable state from concurrent access,using actor isolation and by requiring asynchronous accessfrom outside the actor to serialize execution.

Use actors to build safe, concurrent abstractionsin your Swift code.

In implementing your actors, and in any asynchronous code,always design for reentrancy; an await in your codemeans the world can move on and invalidate your assumptions.

Value types and actors work togetherto eliminate data races.

Be aware of classes that don't handletheir own synchronization, and other non-Sendable typesthat reintroduce shared mutable state.

Finally, use the main actor on your codethat interacts with the UI to ensure that the codethat must be on the main thread always runs on the main thread.

To learn more about how to use actorswithin your own application, check out our sessionon updating an app for Swift concurrency.

And to learn more about the implementationof Swift's concurrency model, including actors,check out our "Behind the scenes" session.

Actors are a core part of the Swift concurrency model.

They work together with async/awaitand structured concurrency to make it easier to buildcorrect and efficient concurrent programs.

We can't wait to see what you build with them.

♪

0:42 -Data races make concurrency hard

2:20 -Value semantics help eliminate data races

2:59 -Sometimes shared mutable state is required

5:23 -Actor isolation prevents unsynchronized access

7:51 -Synchronous interation within an actor

9:02 -Check your assumptions after an await: The sad cat

11:50 -Check your assumptions after an await: One solution

11:59 -Check your assumptions after an await: A better solution

13:30 -Protocol conformance: Static declarations are outside the actor

14:15 -Protocol conformance: Non-isolated declarations are outside the actor

15:32 -Closures can be isolated to the actor

16:29 -Closures executed in a detached task are not isolated to the actor

17:15 -Passing data into and out of actors: structs

17:39 -Passing data into and out of actors: classes

20:08 -Check Sendable by adding a conformance

20:43 -Propagate Sendable by adding a conditional conformance

24:19 -Interacting with the main thread: Using a DispatchQueue

25:01 -Interacting with the main thread: The main actor

26:21 -Main actor types

## Code Samples

```swift
class
 
Counter
 
{
    
var
 value 
=
 
0


    
func
 
increment
()
 -> 
Int
 {
        value 
=
 value 
+
 
1

        
return
 value
    }
}


let
 counter 
=
 
Counter
()


Task
.detached {
    
print
(counter.increment()) 
// data race

}


Task
.detached {
    
print
(counter.increment()) 
// data race

}
```

```swift
var
 array1 
=
 [
1
, 
2
]

var
 array2 
=
 array1

array1.append(
3
)
array2.append(
4
)


print
(array1)        
// [1, 2, 3]


print
(array2)        
// [1, 2, 4]
```

```swift
struct
 
Counter
 
{
    
var
 value 
=
 
0


    
mutating
 
func
 
increment
()
 -> 
Int
 {
        value 
=
 value 
+
 
1

        
return
 value
    }
}


let
 counter 
=
 
Counter
()


Task
.detached {
    
var
 counter 
=
 counter
    
print
(counter.increment()) 
// always prints 1

}


Task
.detached {
    
var
 counter 
=
 counter
    
print
(counter.increment()) 
// always prints 1

}
```

```swift
actor 
Counter
 {
    
var
 value 
=
 
0


    
func
 
increment
()
 -> 
Int
 {
        value 
=
 value 
+
 
1

        
return
 value
    }
}


let
 counter 
=
 
Counter
()


Task
.detached {
    
print
(
await
 counter.increment())
}


Task
.detached {
    
print
(
await
 counter.increment())
}
```

```swift
extension
 
Counter
 
{
    
func
 
resetSlowly
(
to
 
newValue
: 
Int
)
 {
        value 
=
 
0

        
for
 
_
 
in
 
0
..<
newValue {
            increment()
        }
        
assert
(value 
==
 newValue)
    }
}
```

```swift
actor 
ImageDownloader
 {
    
private
 
var
 cache: [
URL
: 
Image
] 
=
 [:]

    
func
 
image
(
from
 
url
: 
URL
)
 
async
 
throws
 -> 
Image
? {
        
if
 
let
 cached 
=
 cache[url] {
            
return
 cached
        }

        
let
 image 
=
 
try
 
await
 downloadImage(from: url)

        
// Potential bug: `cache` may have changed.

        cache[url] 
=
 image
        
return
 image
    }
}
```

```swift
actor 
ImageDownloader
 {
    
private
 
var
 cache: [
URL
: 
Image
] 
=
 [:]

    
func
 
image
(
from
 
url
: 
URL
)
 
async
 
throws
 -> 
Image
? {
        
if
 
let
 cached 
=
 cache[url] {
            
return
 cached
        }

        
let
 image 
=
 
try
 
await
 downloadImage(from: url)

        
// Replace the image only if it is still missing from the cache.

        cache[url] 
=
 cache[url, 
default
: image]
        
return
 cache[url]
    }
}
```

```swift
actor 
ImageDownloader
 {

    
private
 
enum
 
CacheEntry
 
{
        
case
 inProgress(
Task
<
Image
, 
Error
>)
        
case
 ready(
Image
)
    }

    
private
 
var
 cache: [
URL
: 
CacheEntry
] 
=
 [:]

    
func
 
image
(
from
 
url
: 
URL
)
 
async
 
throws
 -> 
Image
? {
        
if
 
let
 cached 
=
 cache[url] {
            
switch
 cached {
            
case
 .ready(
let
 image):
                
return
 image
            
case
 .inProgress(
let
 task):
                
return
 
try
 
await
 task.value
            }
        }

        
let
 task 
=
 
Task
 {
            
try
 
await
 downloadImage(from: url)
        }

        cache[url] 
=
 .inProgress(task)

        
do
 {
            
let
 image 
=
 
try
 
await
 task.value
            cache[url] 
=
 .ready(image)
            
return
 image
        } 
catch
 {
            cache[url] 
=
 
nil

            
throw
 error
        }
    }
}
```

```swift
actor 
LibraryAccount
 {
    
let
 idNumber: 
Int

    
var
 booksOnLoan: [
Book
] 
=
 []
}


extension
 
LibraryAccount
: 
Equatable
 
{
    
static
 
func
 
==
(
lhs
: 
LibraryAccount
, 
rhs
: 
LibraryAccount
)
 -> 
Bool
 {
        lhs.idNumber 
==
 rhs.idNumber
    }
}
```

```swift
actor 
LibraryAccount
 {
    
let
 idNumber: 
Int

    
var
 booksOnLoan: [
Book
] 
=
 []
}


extension
 
LibraryAccount
: 
Hashable
 
{
    nonisolated 
func
 
hash
(
into
 
hasher
: 
inout
 
Hasher
)
 {
        hasher.combine(idNumber)
    }
}
```

```swift
extension
 
LibraryAccount
 
{
    
func
 
readSome
(
_
 
book
: 
Book
)
 -> 
Int
 { 
...
 }
    
    
func
 
read
()
 -> 
Int
 {
        booksOnLoan.reduce(
0
) { book 
in

            readSome(book)
        }
    }
}
```

```swift
extension
 
LibraryAccount
 
{
    
func
 
readSome
(
_
 
book
: 
Book
)
 -> 
Int
 { 
...
 }
    
func
 
read
()
 -> 
Int
 { 
...
 }
    
    
func
 
readLater
()
 {
        
Task
.detached {
            
await
 read()
        }
    }
}
```

```swift
actor 
LibraryAccount
 {
    
let
 idNumber: 
Int

    
var
 booksOnLoan: [
Book
] 
=
 []
    
func
 
selectRandomBook
()
 -> 
Book
? { 
...
 }
}


struct
 
Book
 
{
    
var
 title: 
String

    
var
 authors: [
Author
]
}


func
 
visit
(
_
 
account
: 
LibraryAccount
)
 
async
 {
    
guard
 
var
 book 
=
 
await
 account.selectRandomBook() 
else
 {
        
return

    }
    book.title 
=
 
"
\(book.title)
!!!"
 
// OK: modifying a local copy

}
```

```swift
actor 
LibraryAccount
 {
    
let
 idNumber: 
Int

    
var
 booksOnLoan: [
Book
] 
=
 []
    
func
 
selectRandomBook
()
 -> 
Book
? { 
...
 }
}


class
 
Book
 
{
    
var
 title: 
String

    
var
 authors: [
Author
]
}


func
 
visit
(
_
 
account
: 
LibraryAccount
)
 
async
 {
    
guard
 
var
 book 
=
 
await
 account.selectRandomBook() 
else
 {
        
return

    }
    book.title 
=
 
"
\(book.title)
!!!"
 
// Not OK: potential data race

}
```

```swift
struct
 
Book
: 
Sendable
 
{
    
var
 title: 
String

    
var
 authors: [
Author
]
}
```

```swift
struct
 
Pair
<
T
, 
U
> 
{
    
var
 first: 
T

    
var
 second: 
U

}


extension
 
Pair
: 
Sendable
 
where
 
T
: 
Sendable
, 
U
: 
Sendable
 
{
}
```

```swift
func
 
checkedOut
(
_
 
booksOnLoan
: [
Book
])
 {
    booksView.checkedOutBooks 
=
 booksOnLoan
}


// Dispatching to the main queue is your responsibility.


DispatchQueue
.main.async {
    checkedOut(booksOnLoan)
}
```

```swift
@MainActor
 
func
 
checkedOut
(
_
 
booksOnLoan
: [
Book
])
 {
    booksView.checkedOutBooks 
=
 booksOnLoan
}


// Swift ensures that this code is always run on the main thread.


await
 checkedOut(booksOnLoan)
```

```swift
@MainActor
 
class
 
MyViewController
: 
UIViewController
 
{
    
func
 
onPress
(
...
)
 { 
...
 } 
// implicitly @MainActor


    nonisolated 
func
 
fetchLatestAndDisplay
()
 
async
 { 
...
 } 
}
```


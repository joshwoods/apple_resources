# Wwdc2021 10260

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Focus on iPad keyboard navigationImprove the keyboard experience in your iPad and Mac Catalyst app. Discover how you can accelerate access to key features with the hardware keyboard, and navigate through your views and view controllers. Learn how to customize which elements are keyboard navigable, as well as how to customize the tab loop.ResourcesAbout focus interactions for Apple TVAdding hardware keyboard support to your appAdding Menus and Shortcuts to the Menu Bar and User InterfaceAdjusting your layout with keyboard layout guideImplementing Advanced Text Input FeaturesNavigating an app’s user interface using a keyboardUIKitHD VideoSD VideoRelated VideosWWDC21Qualities of a great Mac Catalyst appQualities of great iPad and iPhone apps on Macs with M1Support Full Keyboard Access in your iOS appTake your iPad apps to the next levelWhat's new in UIKitWWDC20Modern cell configuration

Improve the keyboard experience in your iPad and Mac Catalyst app. Discover how you can accelerate access to key features with the hardware keyboard, and navigate through your views and view controllers. Learn how to customize which elements are keyboard navigable, as well as how to customize the tab loop.

About focus interactions for Apple TV

Adding hardware keyboard support to your app

Adding Menus and Shortcuts to the Menu Bar and User Interface

Adjusting your layout with keyboard layout guide

Implementing Advanced Text Input Features

Navigating an app’s user interface using a keyboard

UIKit

HD VideoSD Video

HD Video

SD Video

Qualities of a great Mac Catalyst app

Qualities of great iPad and iPhone apps on Macs with M1

Support Full Keyboard Access in your iOS app

Take your iPad apps to the next level

What's new in UIKit

Modern cell configuration

Search this video…Hi, I'm Michael Ochs.I'm a framework engineer on the UIKit team.Welcome to Focus on iPad keyboard navigation.People love using hardware keyboards with their iPads.Mac Catalyst and iPadOS 15 introduce powerful APIto support keyboard navigation in your app.Navigating any app with a keyboard on iPadOSwill feel very familiar.The tab key navigates between significant areas in an app.The arrow keys navigate within an area,and an item can be selected with the return keyon iPadOS or the space bar on Mac Catalyst.If your app already uses these key commands,your custom commands will no longer work.I'll show you how to resolve these conflicts later.First, let me show you keyboard navigation in action.In Photos, I can press the tab key to move the focusfrom the Library cell in the sidebarto the photos grid on the right.Now I can navigate between the photosin the grid using the arrow keys.Once I found the photo I'm looking for,I can select it by pressing return.Once you compile with the iOS 15 SDK,this behavior will be enabled automaticallyfor text fields, text views, and sidebars.You should also opt in other collection,table, and custom views for a great experience.I'll show you how to do this in a minute.I know this is an exciting feature,but don't make every element in your app keyboard navigable.Keyboard navigation is intendedto give users access to key features of your app,so focus on text input, lists, and collection views.Leave controls such as buttons,segmented controls, and switches aside.Full Keyboard access already allows these controlsto be keyboard navigable.To learn more about full Keyboard access,check out "Support Full Keyboard Access in your iOS app."Keyboard navigation on iPadOS uses the same focus systemas tvOSIf you have written tvOS apps before,many of the APIs will feel familiar.However, there are some new APIsand behavioral differences that you should be aware of.If you wanna learn more about the focus system in general,check out "Focus Interaction in tvOS."In this video,I'm going to show you how to make more content in your appfocusable and how to customize the appearanceof these focusable items.I'll show you some special behavior in sidebarsthat you should be aware of, and we are going to talkabout focus groups, a new way to define structure in your app.At the end, I'm going to show you some important changesin the responder chain that you should be familiar with.But now, let's take a look at howto make more elements in your UI focusable.canBecomeFocused is the single source of truth.It is a read-only property of UIFocusItem.Override it and return true to make an item focusable.Now, you might be wondering, what is a focus item?The backbone of the focus system are the two protocols:UIFocusItem and UIFocusEnvironment.FocusItems are simply that, items that can be focused.FocusEnvironments define the hierarchyof focusable items.UIView conforms to both of these protocols,since any view can be focused itself,but it can also contain subviews that can be focused.UIViewController, on the other hand,only conforms to UIFocusEnvironment,since it doesn't provide any visuals itself.You can also implement both protocols on your own objects.This allows you to adopt focus in content that is renderedwith other technologies, like Metal.The most likely candidates for keyboard navigationare cells in a table or collection view.UIKit offers some convenience APIs,so you don't have to subclass.Set allowsFocus to true on a table or collection viewto make all of its cells focusable.Note that in sidebars, allowsFocus is true by default.For more fine-grained control,you can use canFocusItemAt indexPath in your delegateto control focusability for each cell individually.Both of these methods will only have an effecton cells that don't override canBecomeFocused.If a focus item is not behaving as you would expect,there are some debugging tools available.In lldb you can callUIFocusDebugger. CheckFocusability(for item:)and pass in the item you want to debug.For example, a view that you are trying to make focusable.It will give you an explanation of why the focus systemdoes not consider this item to be focusable.So, we talked about how to make your UI focusable.Let's take a closer look at the appearanceof focused items.There are two styles you will commonly seethroughout the system.First, there is the Halo Effect,similar to the focus ring on macOS.In fact, this is the default effect on Mac Catalyst.On iPadOS, you can use this effectby assigning a UIFocusHaloEffect to the focusEffect property.If initialized with no arguments,the system will infer the shape of the halo.You can also customize the shape to better match the content.For example, if an image has rounded corners,the halo should match its appearanceby also having rounded corners.UIFocusHaloEffect has a number of initializersfor different shapes, including one for rounded rects.Use these initializers to make sure the halo's shapecreates an outline around your view's content.The Halo Effect also gives you control over its positionin the view hierarchy.Here the halo is rendering above the badge on the image,but it would look better if the halo wasbetween the image and the badge.By specifying the image view as the referenceView,UIKit will render the halo on top of the imageand below the badge.The reference view defines the relative orderof the halo in the view hierarchy.You can also specify a container view,which defines the superview of the halo effect.This is useful if the direct superviewof the focused item is clipping its content.Both of these are optional, and you should only provide themif the inferred appearance isn't what you expect.Cells in collection and table views shouldshow a halo around them only when they havefully-opaque content, like an image.In all other cases, when a cell becomes focused,it should look highlighted.This means the background should turn into the tint colorof your app, and the foreground colorfor text and icons should be adjusted for good contrast.This highlight appearance is not available as a UIFocusEffect.Instead, you will get this appearanceautomatically when using the backgroundand content configurations introduced in iOS 14.To learn more about these,take a look at "Modern cell configuration."If you're not using background and content configurations,the sample app shows you how to get the correct colorin all cases.Make sure to check that out.Now, if you want to apply a custom appearance,first set the focusEffect property to nil.This turns off any system styling.Next overridedidUpdateFocus (in: context withAnimationCoordinator :)on your focus item.If the next focused item is self,apply styling to indicate focus.If the previously-focused item is self,restore the nonfocused appearance.You should only make changes in didUpdateFocus(in: context)when the next or previously focused itemis relevant to this environment.This is because all ancestor environmentsof the previously focused item,as well as the next focused item,receive a call to didUpdateFocus(in: context).So every superview and view controller will get this call.This allows for very flexible implementations,where a parent can react to focus changes of a child.Now let's take a closer look at a feature specificto sidebars and similar context-changing UI.Selection and focus are two different concepts.However, in a sidebar,when I move focus, the selection follows.Likewise, if I select a new cell by tapping on it,focus also moves to this newly-selected cell.This is called "selection follows focus."Set this property on any table or collection viewto the behavior you want for most of the cells.If you want to change the behavior for individual cells,implement selectionFollowsFocus ForItemAtIndexPathin your delegate.Turning off selectionFollowsFocusis useful when selecting a cell causes a disruptive actionto occur, such as pushing a new view controllerin the same column or presenting an alert.For example, in Photos, selecting "new album"shows an alert asking for the album's name.When using the delegate,the value of the property still matters.Set selectionFollowsFocus to the overall intentof the collection view and then use the delegateto express special behavior for individual cells.The system will take both values into accountwhen choosing the right behavior.Now, let's take a look at focus groups,a new feature for keyboard navigationto express structure in your app.UIKit automatically infers focus groups from the hierarchy,but you can also declare them explicitly to customizehow the tab key moves focus through your app.tvOS only uses directional focus.You can reach every single element simply by swipingon the Siri Remote or using the arrow keys on a keyboard.iPadOS and Mac Catalyst, on the other hand,have two different methods of navigating with the keyboard:The arrow keys and the tab key.Unlike tvOS, the arrow keys only move focuswithin a defined area of your app.These areas are called focus groups.For example, I can navigate the listof reminders using the up and down arrow keys.To navigate the lists, I can press the tab keyto focus on the search fieldand then press tab again to move to the lists.If I press tab one more time,focus loops back to the reminders.The reminders, the search field, and the listsare each a focus group,and the tab key moves focus between them.When focus moves to a group,it chooses an item inside of that group to focus on.That item is called the group's primary item.A group's primary item can change.For example, here I focus on the second reminder.The focus system remembers thiswhen I switch away from this group,and when I come back to the reminders,focus moves to the second item againas this item is now the group's primary item.The tab key connects the primary items of each groupand moves focus between them.This is called the tab loop.Some environments define their own focus groupsby default.These include scroll views like collection and table view,as well as text input classes, like text fields and text views.If an environment does not define its own group,it inherits the group of the parent environment,commonly its superview or view controller.For example, by default, every cell automatically belongsto the group of its collection view.By being in the same group,you can navigate between cells with the arrow keys.To define a focus group yourself,assign a focus group identifier to any view or view controller.When two environments share the same identifier,either explicitly or by inheritance,they are part of the same group.To customize the primary item of a group,assign a focus group priority to that item.This defines how important an item is within the group.The visible item with the highest priorityis the group's primary item.By default, the system assigns oneof the predefined priorities: Ignored, the default priority;previously focused; prioritized,indicating an item is more important than others,like a selected cell; and currently focused,which is the highest priority possible.It's important to understandthat you can never lower the priorityof an item below its system-provided priority.Instead, you should raise the priorityof a different item.For example, if you assign a priority higherthan .previouslyFocused to a cell,that cell will become more importantthan the last-focused item of that group.So even if this customized cell and the previously focused cellare both visible, the customized cell would becomethe primary item because it has a higher priority.So, now you know how to group your items together.Next, let's focus on how these groups are sorted.Here, we see Reminders again.As mentioned before, each table and collection view,as well as each text field, define its own group.As seen before, when pressing the tab key continuously,focus goes from the search field to the lists in the sidebar,and then to the reminders on the right.This is what UIKit does by default.However, if you built this kind of container view yourself,focus would move from the search field straight to the remindersbecause all the groups are sorted in reading order,leading to trailing, top to bottom.The focus system does not know that the sidebaris a distinct column.To ensure the search field and lists are sortedin one continuous block,you can put them in a common parent group.This is done by defining a focus group identifieron the sidebar's container view.Even though this new group does not contain any focusable itemsdirectly, the tab loop will move from the search field groupto the lists group before moving on to the reminders list.Many standard UIKit presentations alreadyprovide these intermediate groups.For custom container views, declare your ownfocusGroupIdentifier on common ancestors.Focus groups are an easy wayto define the visual structure of your app.You don't have to define a fixed order for your tab loop.Instead, the system uses focus groupsto derive a tab loop order that takes into accountreading direction, layout, and visibilityto provide a consistent experience.When customizing focus groups in your app,UIFocusDebugger is your friend.If you call checkFocusGroupTree (for environment:)it'll print the focus group structure,starting at the passed-in environment.You can even pass in the focus system itselfto see all current groups.Now, this textual structure is helpful,but there's one more debugging tool.Remember the screenshot I showed youwith the focus groups and Reminders?You can actually get this live in your app.When enabled,the focus loop debugger visualizes the tab loop orderin your app when you press and hold the option key.And when pressing option and control,you get a visualization of the focus groups.In this mode, the primary item of a groupis indicated by a dotted line.To enable it, go to your scheme settingsin Xcode, select "run," and then "arguments."Then add the launch argument -UIFocusLoopDebuggerEnabled YES,and don't forget to put the dash in front of it.Now, whenever you run your app from Xcode,this debug overlay is available right in your app.This covers the basics of focus on iPadOS and Mac Catalyst.There's one more topic to cover for keyboard navigation,and that's the responder chain.Since both the responder chain and the focus system are dealingwith keyboard input, UIKit synchronizes these systemsas much as possible to make sure the focused item is alwaysinside the first responder or is the first responder itself.Let's look at a simplified view hierarchy with a text fieldand a collection view cell.Currently, the text field is focused,indicated by the solid ring,and it is also the first responder,indicated by the dashed ring.When focus moves to this collection view cell,UIKit also tries to move the first responderto this cell.If this cell returns false from canBecomeFirstResponder,the system iterates up the responder chainto find a responder that returns true.In this case, that responder is the cell's view controller.Note that the inverse is also true.When the first responder changes,the focus system will try to find a new focusable iteminside of that responder.With this relationship between the first responderand the focused item, key events will always be deliveredto the focused item and move up the responder chain from there.This allows for some interesting new behavior.For example,if a cell responds to a key command and becomes focused,the key command is delivered to that cell.For ways to use this, take a look at our sample app.When updating your app for iPadOS 15,be conscious about where you call becomeFirstResponder.Since the responder chain and focus are synchronized,changing the first responder will force focus to update.This might be very disruptive to your users.It is typically best to avoid calling becomeFirstResponder,especially in response to a focus update.The focus system provides a consistent experienceacross all apps.To do this, it needs priority for certain key commands.If your app is using a key command like tabor arrow down, that key command willno longer work when compiling with the iOS 15 SDK.If this key command is usedto build your own custom keyboard navigation,you can leave it untouched.It'll work on previous versions,and on iPadOS 15, the focus system will take over.Otherwise, remap this key command.If you really want to continue using this key command,make sure it doesn't break keyboard navigation,and then set wantsPriorityOverSystemBehaviorto true.If you want to learn moreabout improvements to keyboard shortcuts,check out "Take your iPad apps to the next level."If you handle presses manuallyby implementing pressesBegan, pressesChanged,pressesEnded, and pressesCancelled,make sure to implement all of these methodsand call super consistently for pressesthat you don't handle.Keyboard navigation in iPadOS 15 and Mac Catalystis a powerful tool for your users.Make collection and table views focusableto provide a great user experience.Update your key commands so they don't collidewith keyboard navigation.Also, check out the sample app,which illustrates a couple more features,such as building a great search experience,custom selections, focus guides, and much more.I can't wait to see what you're buildingwith keyboard navigation on iPadOS 15.Thank you for watching.[percussive music]

Hi, I'm Michael Ochs.I'm a framework engineer on the UIKit team.Welcome to Focus on iPad keyboard navigation.

People love using hardware keyboards with their iPads.Mac Catalyst and iPadOS 15 introduce powerful APIto support keyboard navigation in your app.

Navigating any app with a keyboard on iPadOSwill feel very familiar.The tab key navigates between significant areas in an app.The arrow keys navigate within an area,and an item can be selected with the return keyon iPadOS or the space bar on Mac Catalyst.If your app already uses these key commands,your custom commands will no longer work.I'll show you how to resolve these conflicts later.First, let me show you keyboard navigation in action.In Photos, I can press the tab key to move the focusfrom the Library cell in the sidebarto the photos grid on the right.Now I can navigate between the photosin the grid using the arrow keys.Once I found the photo I'm looking for,I can select it by pressing return.

Once you compile with the iOS 15 SDK,this behavior will be enabled automaticallyfor text fields, text views, and sidebars.You should also opt in other collection,table, and custom views for a great experience.I'll show you how to do this in a minute.

I know this is an exciting feature,but don't make every element in your app keyboard navigable.Keyboard navigation is intendedto give users access to key features of your app,so focus on text input, lists, and collection views.Leave controls such as buttons,segmented controls, and switches aside.Full Keyboard access already allows these controlsto be keyboard navigable.To learn more about full Keyboard access,check out "Support Full Keyboard Access in your iOS app."Keyboard navigation on iPadOS uses the same focus systemas tvOSIf you have written tvOS apps before,many of the APIs will feel familiar.However, there are some new APIsand behavioral differences that you should be aware of.If you wanna learn more about the focus system in general,check out "Focus Interaction in tvOS."In this video,I'm going to show you how to make more content in your appfocusable and how to customize the appearanceof these focusable items.I'll show you some special behavior in sidebarsthat you should be aware of, and we are going to talkabout focus groups, a new way to define structure in your app.At the end, I'm going to show you some important changesin the responder chain that you should be familiar with.But now, let's take a look at howto make more elements in your UI focusable.canBecomeFocused is the single source of truth.It is a read-only property of UIFocusItem.Override it and return true to make an item focusable.Now, you might be wondering, what is a focus item?The backbone of the focus system are the two protocols:UIFocusItem and UIFocusEnvironment.FocusItems are simply that, items that can be focused.FocusEnvironments define the hierarchyof focusable items.UIView conforms to both of these protocols,since any view can be focused itself,but it can also contain subviews that can be focused.UIViewController, on the other hand,only conforms to UIFocusEnvironment,since it doesn't provide any visuals itself.You can also implement both protocols on your own objects.This allows you to adopt focus in content that is renderedwith other technologies, like Metal.The most likely candidates for keyboard navigationare cells in a table or collection view.UIKit offers some convenience APIs,so you don't have to subclass.Set allowsFocus to true on a table or collection viewto make all of its cells focusable.Note that in sidebars, allowsFocus is true by default.

For more fine-grained control,you can use canFocusItemAt indexPath in your delegateto control focusability for each cell individually.Both of these methods will only have an effecton cells that don't override canBecomeFocused.

If a focus item is not behaving as you would expect,there are some debugging tools available.In lldb you can callUIFocusDebugger. CheckFocusability(for item:)and pass in the item you want to debug.For example, a view that you are trying to make focusable.It will give you an explanation of why the focus systemdoes not consider this item to be focusable.

So, we talked about how to make your UI focusable.Let's take a closer look at the appearanceof focused items.There are two styles you will commonly seethroughout the system.First, there is the Halo Effect,similar to the focus ring on macOS.In fact, this is the default effect on Mac Catalyst.On iPadOS, you can use this effectby assigning a UIFocusHaloEffect to the focusEffect property.If initialized with no arguments,the system will infer the shape of the halo.You can also customize the shape to better match the content.For example, if an image has rounded corners,the halo should match its appearanceby also having rounded corners.

UIFocusHaloEffect has a number of initializersfor different shapes, including one for rounded rects.Use these initializers to make sure the halo's shapecreates an outline around your view's content.The Halo Effect also gives you control over its positionin the view hierarchy.Here the halo is rendering above the badge on the image,but it would look better if the halo wasbetween the image and the badge.By specifying the image view as the referenceView,UIKit will render the halo on top of the imageand below the badge.The reference view defines the relative orderof the halo in the view hierarchy.You can also specify a container view,which defines the superview of the halo effect.This is useful if the direct superviewof the focused item is clipping its content.

Both of these are optional, and you should only provide themif the inferred appearance isn't what you expect.

Cells in collection and table views shouldshow a halo around them only when they havefully-opaque content, like an image.In all other cases, when a cell becomes focused,it should look highlighted.This means the background should turn into the tint colorof your app, and the foreground colorfor text and icons should be adjusted for good contrast.This highlight appearance is not available as a UIFocusEffect.Instead, you will get this appearanceautomatically when using the backgroundand content configurations introduced in iOS 14.To learn more about these,take a look at "Modern cell configuration."If you're not using background and content configurations,the sample app shows you how to get the correct colorin all cases.Make sure to check that out.

Now, if you want to apply a custom appearance,first set the focusEffect property to nil.This turns off any system styling.Next overridedidUpdateFocus (in: context withAnimationCoordinator :)on your focus item.If the next focused item is self,apply styling to indicate focus.If the previously-focused item is self,restore the nonfocused appearance.You should only make changes in didUpdateFocus(in: context)when the next or previously focused itemis relevant to this environment.This is because all ancestor environmentsof the previously focused item,as well as the next focused item,receive a call to didUpdateFocus(in: context).So every superview and view controller will get this call.This allows for very flexible implementations,where a parent can react to focus changes of a child.Now let's take a closer look at a feature specificto sidebars and similar context-changing UI.Selection and focus are two different concepts.However, in a sidebar,when I move focus, the selection follows.

Likewise, if I select a new cell by tapping on it,focus also moves to this newly-selected cell.

This is called "selection follows focus."Set this property on any table or collection viewto the behavior you want for most of the cells.If you want to change the behavior for individual cells,implement selectionFollowsFocus ForItemAtIndexPathin your delegate.Turning off selectionFollowsFocusis useful when selecting a cell causes a disruptive actionto occur, such as pushing a new view controllerin the same column or presenting an alert.

For example, in Photos, selecting "new album"shows an alert asking for the album's name.

When using the delegate,the value of the property still matters.Set selectionFollowsFocus to the overall intentof the collection view and then use the delegateto express special behavior for individual cells.The system will take both values into accountwhen choosing the right behavior.

Now, let's take a look at focus groups,a new feature for keyboard navigationto express structure in your app.UIKit automatically infers focus groups from the hierarchy,but you can also declare them explicitly to customizehow the tab key moves focus through your app.

tvOS only uses directional focus.You can reach every single element simply by swipingon the Siri Remote or using the arrow keys on a keyboard.iPadOS and Mac Catalyst, on the other hand,have two different methods of navigating with the keyboard:The arrow keys and the tab key.Unlike tvOS, the arrow keys only move focuswithin a defined area of your app.These areas are called focus groups.For example, I can navigate the listof reminders using the up and down arrow keys.

To navigate the lists, I can press the tab keyto focus on the search fieldand then press tab again to move to the lists.If I press tab one more time,focus loops back to the reminders.

The reminders, the search field, and the listsare each a focus group,and the tab key moves focus between them.

When focus moves to a group,it chooses an item inside of that group to focus on.That item is called the group's primary item.

A group's primary item can change.For example, here I focus on the second reminder.The focus system remembers thiswhen I switch away from this group,and when I come back to the reminders,focus moves to the second item againas this item is now the group's primary item.The tab key connects the primary items of each groupand moves focus between them.This is called the tab loop.

Some environments define their own focus groupsby default.These include scroll views like collection and table view,as well as text input classes, like text fields and text views.If an environment does not define its own group,it inherits the group of the parent environment,commonly its superview or view controller.For example, by default, every cell automatically belongsto the group of its collection view.By being in the same group,you can navigate between cells with the arrow keys.To define a focus group yourself,assign a focus group identifier to any view or view controller.When two environments share the same identifier,either explicitly or by inheritance,they are part of the same group.To customize the primary item of a group,assign a focus group priority to that item.This defines how important an item is within the group.The visible item with the highest priorityis the group's primary item.By default, the system assigns oneof the predefined priorities: Ignored, the default priority;previously focused; prioritized,indicating an item is more important than others,like a selected cell; and currently focused,which is the highest priority possible.It's important to understandthat you can never lower the priorityof an item below its system-provided priority.Instead, you should raise the priorityof a different item.

For example, if you assign a priority higherthan .previouslyFocused to a cell,that cell will become more importantthan the last-focused item of that group.So even if this customized cell and the previously focused cellare both visible, the customized cell would becomethe primary item because it has a higher priority.So, now you know how to group your items together.Next, let's focus on how these groups are sorted.Here, we see Reminders again.As mentioned before, each table and collection view,as well as each text field, define its own group.

As seen before, when pressing the tab key continuously,focus goes from the search field to the lists in the sidebar,and then to the reminders on the right.

This is what UIKit does by default.However, if you built this kind of container view yourself,focus would move from the search field straight to the remindersbecause all the groups are sorted in reading order,leading to trailing, top to bottom.The focus system does not know that the sidebaris a distinct column.

To ensure the search field and lists are sortedin one continuous block,you can put them in a common parent group.This is done by defining a focus group identifieron the sidebar's container view.Even though this new group does not contain any focusable itemsdirectly, the tab loop will move from the search field groupto the lists group before moving on to the reminders list.

Many standard UIKit presentations alreadyprovide these intermediate groups.For custom container views, declare your ownfocusGroupIdentifier on common ancestors.Focus groups are an easy wayto define the visual structure of your app.You don't have to define a fixed order for your tab loop.Instead, the system uses focus groupsto derive a tab loop order that takes into accountreading direction, layout, and visibilityto provide a consistent experience.When customizing focus groups in your app,UIFocusDebugger is your friend.If you call checkFocusGroupTree (for environment:)it'll print the focus group structure,starting at the passed-in environment.You can even pass in the focus system itselfto see all current groups.

Now, this textual structure is helpful,but there's one more debugging tool.Remember the screenshot I showed youwith the focus groups and Reminders?You can actually get this live in your app.When enabled,the focus loop debugger visualizes the tab loop orderin your app when you press and hold the option key.

And when pressing option and control,you get a visualization of the focus groups.In this mode, the primary item of a groupis indicated by a dotted line.

To enable it, go to your scheme settingsin Xcode, select "run," and then "arguments."Then add the launch argument -UIFocusLoopDebuggerEnabled YES,and don't forget to put the dash in front of it.Now, whenever you run your app from Xcode,this debug overlay is available right in your app.This covers the basics of focus on iPadOS and Mac Catalyst.There's one more topic to cover for keyboard navigation,and that's the responder chain.

Since both the responder chain and the focus system are dealingwith keyboard input, UIKit synchronizes these systemsas much as possible to make sure the focused item is alwaysinside the first responder or is the first responder itself.

Let's look at a simplified view hierarchy with a text fieldand a collection view cell.Currently, the text field is focused,indicated by the solid ring,and it is also the first responder,indicated by the dashed ring.When focus moves to this collection view cell,UIKit also tries to move the first responderto this cell.If this cell returns false from canBecomeFirstResponder,the system iterates up the responder chainto find a responder that returns true.In this case, that responder is the cell's view controller.

Note that the inverse is also true.When the first responder changes,the focus system will try to find a new focusable iteminside of that responder.With this relationship between the first responderand the focused item, key events will always be deliveredto the focused item and move up the responder chain from there.This allows for some interesting new behavior.For example,if a cell responds to a key command and becomes focused,the key command is delivered to that cell.For ways to use this, take a look at our sample app.

When updating your app for iPadOS 15,be conscious about where you call becomeFirstResponder.Since the responder chain and focus are synchronized,changing the first responder will force focus to update.This might be very disruptive to your users.It is typically best to avoid calling becomeFirstResponder,especially in response to a focus update.

The focus system provides a consistent experienceacross all apps.To do this, it needs priority for certain key commands.If your app is using a key command like tabor arrow down, that key command willno longer work when compiling with the iOS 15 SDK.If this key command is usedto build your own custom keyboard navigation,you can leave it untouched.It'll work on previous versions,and on iPadOS 15, the focus system will take over.Otherwise, remap this key command.If you really want to continue using this key command,make sure it doesn't break keyboard navigation,and then set wantsPriorityOverSystemBehaviorto true.If you want to learn moreabout improvements to keyboard shortcuts,check out "Take your iPad apps to the next level."If you handle presses manuallyby implementing pressesBegan, pressesChanged,pressesEnded, and pressesCancelled,make sure to implement all of these methodsand call super consistently for pressesthat you don't handle.Keyboard navigation in iPadOS 15 and Mac Catalystis a powerful tool for your users.Make collection and table views focusableto provide a great user experience.Update your key commands so they don't collidewith keyboard navigation.Also, check out the sample app,which illustrates a couple more features,such as building a great search experience,custom selections, focus guides, and much more.I can't wait to see what you're buildingwith keyboard navigation on iPadOS 15.Thank you for watching.[percussive music]

3:01 -canBecomeFocused

4:00 -allowsFocus

4:23 -canFocusItemAtIndexPath

4:40 -UIFocusDebugger checkFocusability(for:)

5:48 -UIFocusHaloEffect

6:03 -ReferenceView and ContainerView

7:43 -Custom focus effects

9:08 -Selection Follows Focus

9:16 -Selection Follows Focus for Item at Index Path

12:12 -Focus Group Identifier

12:52 -UIFocusGroupPriority

13:40 -Focus Group Priority on a cell

15:46 -UIFocusDebugger checkFocusGroupTree(for:)

19:16 -wantsPriorityOverSystemBehavior

19:36 -pressesBegan

## Code Samples

```swift
override
 
var
 canBecomeFocused: 
Bool
 { 
true
 }
```

```swift
class
 
MyViewController
: 
UICollectionViewController
 
{
    
override
 
func
 
viewDidLoad
()
 {
        
super
.viewDidLoad()
        
self
.collectionView.allowsFocus 
=
 
true

    }
}
```

```swift
class
 
MyCollectionViewDelegate
: 
NSObject
, 
UICollectionViewDelegate
 
{
    
func
 
collectionView
(
_
 
collectionView
: 
UICollectionView
,
                
canFocusItemAt
 
indexPath
: 
IndexPath
)
 -> 
Bool
 {
        
return
 
true

    }
}
```

```swift
po UIFocusDebugger.checkFocusability(
for
:)
```

```swift
let
 focusEffect 
=
 
UIFocusHaloEffect
(roundedRect: 
self
.bounds, cornerRadius: 
self
.layer.cornerRadius, curve: .continuous)

self
.focusEffect 
=
 focusEffect
```

```swift
let
 focusEffect 
=
 
UIFocusHaloEffect
(roundedRect: 
self
.bounds, cornerRadius: 
self
.layer.cornerRadius, curve: .continuous)


// make sure the effect is added right above the image view

focusEffect.referenceView 
=
 
self
.imageView


// make sure the effect is added to our scroll view

focusEffect.containerView 
=
 
self
.scrollView


self
.focusEffect 
=
 focusEffect
```

```swift
init
(
frame
: 
CGRect
)
 {
   
super
.
init
(frame: frame)
   
self
.focusEffect 
=
 
nil

}


func
 
didUpdateFocus
(
in
 
context
: 
UIFocusUpdateContext
, 
withAnimationCoordinator
 
coordinator
: 
UIFocusAnimationCoordinator
)
 {
    
if
 context.nextFocusedItem 
==
 
self
 {
        
// This view is focused. Customize its appearance.

    }
    
else
 
if
 context.previouslyFocusedItem 
==
 
self
 {
        
// This view was focused.

    }
}
```

```swift
var
 selectionFollowsFocus: 
Bool
```

```swift
func
 
collectionView
(
_
 
collectionView
: 
UICollectionView
, 
selectionFollowsFocusForItemAt
 
indexPath
: 
IndexPath
)
 -> 
Bool
 {
    
return
 
self
.action(for: indexPath).type 
!=
 .showAlert
}
```

```swift
self
.focusGroupIdentifier 
=
 
"com.myapp.groups.sidebar"
```

```swift
extension
 
UIFocusGroupPriority
 
{
    
public
 
static
 
let
 ignored: 
UIFocusGroupPriority
 
// 0

    
public
 
static
 
let
 previouslyFocused: 
UIFocusGroupPriority
 
// 1000

    
public
 
static
 
let
 prioritized: 
UIFocusGroupPriority
 
// 2000

    
public
 
static
 
let
 currentlyFocused: 
UIFocusGroupPriority
 
// NSIntegerMax

}
```

```swift
// Customizing an item’s focus group priority



func
 
collectionView
(
_
 
collectionView
: 
UICollectionView
, 
cellForItemAt
 
indexPath
: 
IndexPath
)
 -> 
UICollectionViewCell
 {
    
let
 cell 
=
 
...

    
if
 
self
.isCallToActionCell(at: indexPath) {
        
// This cell is not as important as a selected cell but should

        
// be chosen over the last focused cell in this group.

        cell.focusGroupPriority 
=
 .previouslyFocused 
+
 
10

    }
    
return
 cell
}
```

```swift
po UIFocusDebugger.checkFocusGroupTree(
for
:)
```

```swift
keyCommand.wantsPriorityOverSystemBehavior 
=
 
true
```

```swift
override
 
func
 
pressesBegan
(
_
 
presses
: 
Set
<
UIPress
>, 
with
 
event
: 
UIPressesEvent
?)
 {
    
if
 (
/* check presses of interest */
) {
        
// handle the press

    }
    
else
 {
        
super
.pressesBegan(presses, with: event)
    }
}
```


WEBVTT

00:00:12.669 --> 00:00:17.789
>> I'm David Myszewski and welcome to the talk on
optimizing performance on the iPhone applications.

00:00:17.789 --> 00:00:19.149
So I'm David Myszewski.

00:00:19.149 --> 00:00:24.059
I've been working on iPhone performance for over
3 years and I manage the iPhone performance team.

00:00:24.059 --> 00:00:25.929
And we have a lot of topics to cover.

00:00:25.929 --> 00:00:28.329
A lot about performance today.

00:00:28.329 --> 00:00:33.119
So to talk about performance we're going to
divide the talk into 5 different sections.

00:00:33.119 --> 00:00:36.439
First, we'll talk a little bit about drawing and scrolling.

00:00:36.439 --> 00:00:40.640
Second, we'll talk a lot about
Application Launch, then memory usage.

00:00:40.640 --> 00:00:42.030
A little bit about files and data.

00:00:42.030 --> 00:00:47.130
And then finally Peter Handel will help me out
and talk a lot about power and battery life

00:00:47.130 --> 00:00:51.480
to see how to get the best out of your iPhone.

00:00:51.479 --> 00:00:53.869
So why should we care about performance?

00:00:53.869 --> 00:00:59.109
Well, if you look at any sort of the tech
specs you know that iPhone is not quite a Mac.

00:00:59.109 --> 00:01:05.140
It's, you know, certainly, the RAM is a lot more
limited, and we've added to that with the iPhone 3GS.

00:01:05.140 --> 00:01:07.040
We have now doubled the RAM.

00:01:07.040 --> 00:01:12.500
But we still have a limited memory footprint and
40 million devices out there with 128 Megs of RAM.

00:01:12.500 --> 00:01:16.129
So utilizing memory is very, very important on iPhone.

00:01:16.129 --> 00:01:21.199
And of course, you have different characteristics of the
mass storage using Flash instead of a spinning media.

00:01:21.200 --> 00:01:23.070
And networking is very, very different.

00:01:23.069 --> 00:01:29.699
And of course, the processor is very, very great for
a Smart Phone, but it's not what you find in the Mac.

00:01:29.700 --> 00:01:32.859
So it's very important to keep in
mind as you're designing your apps

00:01:32.859 --> 00:01:38.420
and as you're testing your apps on
how to get the most out of your apps.

00:01:38.420 --> 00:01:42.650
And to start we'll talk a little
bit about drawing and scrolling.

00:01:42.650 --> 00:01:46.620
So the first demo that was ever done
on iPhone was scrolling the list.

00:01:46.620 --> 00:01:47.829
Lists are all over the place.

00:01:47.829 --> 00:01:49.560
Every iPhone app has them.

00:01:49.560 --> 00:01:55.049
And scrolling is very, very important to the iPhone
experience, and so we'll show you a little bit about how

00:01:55.049 --> 00:01:59.479
to get the best out of your app so
that you have great iPhone scrolling.

00:01:59.480 --> 00:02:02.219
So we'll switch over here to the demo.

00:02:03.340 --> 00:02:07.430
And say you've written an app and
you've only tested it in the simulator.

00:02:07.430 --> 00:02:09.670
You haven't tested it in the device yet.

00:02:09.669 --> 00:02:17.239
And you install it on your new
iPhone and this is the iPhone 3GS.

00:02:17.240 --> 00:02:21.580
And you run your little Movies app, so
this app just displays the latest movies.

00:02:21.580 --> 00:02:31.110
And you scroll the list and well, it's not quite great
on the iPhone 3GS even though it's really, really fast.

00:02:31.110 --> 00:02:33.330
And then you.

00:02:33.330 --> 00:02:33.780
Oh, sorry.

00:02:33.780 --> 00:02:35.270
This is the original iPhone.

00:02:35.270 --> 00:02:39.430
On the iPhone 3GS it's a little better,
but still you can see it's a bit chunky.

00:02:39.430 --> 00:02:44.870
So we're going to show you how to make this
list a lot faster on both of these platforms

00:02:44.870 --> 00:02:49.520
so that 40 million iPhone users out there
will have a great scrolling experience.

00:02:49.520 --> 00:02:54.710
And then the ones who buy the new iPhone
will have an even better experience.

00:02:54.710 --> 00:02:58.540
We go back to the slides.

00:02:58.539 --> 00:03:00.530
So we have a lot of drawing technologies on Mac OS.

00:03:00.530 --> 00:03:02.699
Or on OS X on iPhone.

00:03:02.699 --> 00:03:06.449
We have the great Core Animation
and Quartz 2D drawing systems.

00:03:06.449 --> 00:03:08.750
We have OpenGL ES for games.

00:03:08.750 --> 00:03:14.930
And of course we have all the UIKit APIs that give you
a very high level approach and a lot of built-in classes

00:03:14.930 --> 00:03:21.530
that help you draw images and labels and switches
and a lot of things very, very efficiently.

00:03:21.530 --> 00:03:27.289
Now we have a ton of APIs in the UIKit that
help you draw things as fast as possible.

00:03:27.289 --> 00:03:33.519
UI Image View, for example, allows you to take an
image, pass it to the view, and we have a very fast pass

00:03:33.520 --> 00:03:38.820
through Core Animation and all the way down through the
hardware to render the images quickly as possible and get it

00:03:38.819 --> 00:03:43.739
on screen so that your users will
see their pictures immediately.

00:03:43.740 --> 00:03:48.790
And of course we have other things like UI Label
and a number of other classes in the software

00:03:48.789 --> 00:03:56.489
that if you use you'll get very, very efficient drawing and
a lot of other capabilities that may be difficult to build.

00:03:56.490 --> 00:04:01.409
And for any views, you know everything
is based on views on the UIKit.

00:04:01.409 --> 00:04:02.969
And views are great to animate around.

00:04:02.969 --> 00:04:03.849
You can fade them out.

00:04:03.849 --> 00:04:05.699
You can move them across the screen.

00:04:05.699 --> 00:04:09.939
And so definitely take advantage of all the
animation facilities that views provide.

00:04:09.939 --> 00:04:14.909
If you have a view, it's very easy to move it around and
do all sorts of animations to make your app look better.

00:04:14.909 --> 00:04:23.079
Now there's a lot of techniques to making scrolling
performance fast, and we'll go through each of these.

00:04:23.079 --> 00:04:24.740
Scrolling performance.

00:04:24.740 --> 00:04:29.220
The first thing you should ever check is
whether or not you have translucent views.

00:04:29.220 --> 00:04:32.060
I'll show you a tool that allows us to do that in a moment.

00:04:32.060 --> 00:04:37.870
But translucent views are very, very costly to render
because if you have 2 views that overlap you have to look

00:04:37.870 --> 00:04:41.000
at both of the pixels to figure out
well, what should I draw on the screen?

00:04:41.000 --> 00:04:43.370
They're difficult to composite.

00:04:43.370 --> 00:04:46.970
So to make this a lot more efficient,
if you have views that don't need

00:04:46.970 --> 00:04:49.890
to be translucent, then you can mark them as opaque.

00:04:49.889 --> 00:04:55.060
And that's a lot more efficient for the graphics
system to be able to get that view that you gave it

00:04:55.060 --> 00:04:57.339
and get it on screen as quickly as possible.

00:04:57.339 --> 00:05:01.039
So if you ever have a scrolling list,
try to make all of your views opaque.

00:05:01.040 --> 00:05:06.610
The second tip that we give for any sort of drawing
is definitely draw as little as you need to.

00:05:06.610 --> 00:05:13.360
A check for rectangle intersection is always going
to be faster than drawing extra bits on the screen.

00:05:13.360 --> 00:05:19.530
So when it applies, definitely call
setNeedsDisplayInRect and pass it only to the dirty region.

00:05:19.529 --> 00:05:24.639
And then in drawRect you can check that dirty region to
make sure that you'd only draw what you need to draw.

00:05:24.639 --> 00:05:30.319
It works the same way as it does in AppKit.

00:05:30.319 --> 00:05:35.529
And occasionally it's really, really useful
to have objects that stick around a lot.

00:05:35.529 --> 00:05:37.939
And you may use them for every cell.

00:05:37.939 --> 00:05:42.990
If you have such an image you may want to cache them,
and sometimes you may even want to cache the bit.

00:05:42.990 --> 00:05:45.920
So for example, in the Movies app we have ratings.

00:05:45.920 --> 00:05:51.490
We have G, PG, etc. And all of those images are
going to be the same, and there's only 5 of them.

00:05:51.490 --> 00:05:57.240
So we keep around those images so that when the time comes
to draw them they're already ready and they're decompressed.

00:05:57.240 --> 00:06:00.060
And we can get them on screen as quickly as possible.

00:06:00.060 --> 00:06:04.769
So particularly in scrolling lists you may
want to cache certain parts of your views.

00:06:04.769 --> 00:06:12.459
And the last little drawing tip that we give, which is
mainly for OpenGL Games, is occasionally we have timers

00:06:12.459 --> 00:06:17.289
where say, you draw every 30th of a second
so that you get your nice smooth frame rate.

00:06:17.290 --> 00:06:21.580
And occasionally people will forget to
invalidate the timers after some action.

00:06:21.579 --> 00:06:22.810
Say the user locks the screen.

00:06:22.810 --> 00:06:26.310
They try to invalidate the timer, but
they don't actually invalidate it.

00:06:26.310 --> 00:06:29.810
So definitely if you have a situation
where say, the user locks a screen,

00:06:29.810 --> 00:06:33.230
and then when they unlock it things are very, very slow.

00:06:33.230 --> 00:06:37.110
You may have 2 timers around and you're trying
to do twice the work in the same amount of time.

00:06:37.110 --> 00:06:40.400
So if you encounter a bug like that,
certainly look at the number of timers

00:06:40.399 --> 00:06:44.089
that you have in the system and view sampler.

00:06:44.089 --> 00:06:49.169
And the last little hint that we
give is for any sort of UI artwork.

00:06:49.170 --> 00:06:53.189
Use PNG files because we optimize
them at build time to try to get them

00:06:53.189 --> 00:06:56.009
in a format that the iPhone can read really quickly.

00:06:56.009 --> 00:07:01.069
And we do some compression on the PNGs
so that they're as small as possible,

00:07:01.069 --> 00:07:03.829
and so that we can read them as quickly as possible.

00:07:03.829 --> 00:07:09.199
So for any sort of UI artwork we always recommend PNGs.

00:07:09.199 --> 00:07:12.259
So how did we improve that app that we just made?

00:07:12.259 --> 00:07:16.069
Well, we need to take all of this advice that I gave before.

00:07:16.069 --> 00:07:18.480
You need to use opaque views when possible.

00:07:18.480 --> 00:07:19.819
That's the first thing.

00:07:19.819 --> 00:07:24.610
The second step is always avoid
allocating views while you are scrolling.

00:07:24.610 --> 00:07:30.210
Because allocating them, then say drawing
the background, is very, very expensive.

00:07:30.209 --> 00:07:33.709
So if you're constantly creating
table cells and views as you scroll,

00:07:33.709 --> 00:07:39.310
one easy way to get better scrolling
performance is to make those views stick around.

00:07:40.519 --> 00:07:45.599
So if you look at this cell, what's a cell made up of?

00:07:45.600 --> 00:07:48.590
It's made up of a lot of different parts.

00:07:48.589 --> 00:07:54.029
And the example that I showed you was
actually made up of about 7 different views.

00:07:54.029 --> 00:07:57.919
So we had the UI image view for the movie poster.

00:07:57.920 --> 00:08:00.840
We have a label for the title.

00:08:00.839 --> 00:08:04.789
Another label because it was a
different font style for the cast.

00:08:04.790 --> 00:08:06.120
And another label for all the text.

00:08:06.120 --> 00:08:12.079
So we have a bunch of views around, and of
course a label or an image view for the rating.

00:08:12.079 --> 00:08:13.750
So we have a lot of views.

00:08:13.750 --> 00:08:18.930
And in addition to that you have the content view for
the TableViewCell, as you learned earlier in the week.

00:08:18.930 --> 00:08:20.870
And you have the cell itself.

00:08:20.870 --> 00:08:24.490
So when you count them all up that's actually 7 views.

00:08:24.490 --> 00:08:29.540
That's a lot of views to create and a lot
to draw as you are scrolling through a list.

00:08:29.540 --> 00:08:34.529
So we provide an optimization that
allows you to reuse table cells.

00:08:34.529 --> 00:08:37.939
So in the previous example we just had 7 views.

00:08:37.940 --> 00:08:39.370
And if you view.

00:08:39.370 --> 00:08:41.450
And for example, the rating may not change.

00:08:41.450 --> 00:08:44.100
The title and the cast is likely to.

00:08:44.100 --> 00:08:50.769
But you'll get really good performance if you keep
those views around and then just replace their contents.

00:08:50.769 --> 00:08:57.759
So you may change the name of the title, but the view itself
is still around, so you have a lot less drawing to do.

00:08:57.759 --> 00:09:00.870
And to do that you give a cell an identifier.

00:09:00.870 --> 00:09:05.240
And then we reuse them using the
TableView cellForRowAtIndexPath.

00:09:05.240 --> 00:09:08.779
And there's an API to DQ a cell.

00:09:08.779 --> 00:09:12.939
And once you DQ the cell, you update it
with whatever new content that you have.

00:09:12.940 --> 00:09:17.620
And if you didn't need to update the rating title,
well, then that's work that you don't have to do.

00:09:17.620 --> 00:09:19.009
So we try to reuse them.

00:09:19.009 --> 00:09:23.139
So to show you a little bit about
how this works conceptually,

00:09:23.139 --> 00:09:28.949
so before we use table cells we have some
table cells that are coming on screen.

00:09:28.950 --> 00:09:33.770
And when they go off the screen they go away.

00:09:33.769 --> 00:09:34.590
We don't want that.

00:09:34.590 --> 00:09:40.970
We want them to stick around after they go off the
screen so that when the next cell comes up we reuse that.

00:09:40.970 --> 00:09:45.680
So when we change our code to reuse table
cells it looks a lot more like this.

00:09:45.679 --> 00:09:53.120
The cells come through, and then when they go
offscreen we recycle them and use them again.

00:09:53.120 --> 00:09:56.240
So if the contents didn't change
we don't have to do any work.

00:09:56.240 --> 00:10:01.409
And we don't have to do any work to reallocate
the table cell, draw the background color,

00:10:01.409 --> 00:10:03.829
which is always going to be white and never going to change.

00:10:03.830 --> 00:10:09.110
We avoid a lot of work by reusing table cells.

00:10:09.110 --> 00:10:15.649
One final optimization that you can make, and this
particularly applies when you don't support editing

00:10:15.649 --> 00:10:20.600
or deletion and some of the other
complicated behavior of table cells.

00:10:20.600 --> 00:10:26.750
If you have one table cell in which you are only
going to view contents, like say, the iPod Album List

00:10:26.750 --> 00:10:32.519
or the iPod Songs List, or this MovieView
list, you can make an optimization

00:10:32.519 --> 00:10:35.939
to make the graphic software and hardware do even less work.

00:10:35.940 --> 00:10:39.560
And that's what we call collapsing the cell view hierarchy.

00:10:39.559 --> 00:10:43.129
So I mentioned we had 7 different views.

00:10:43.129 --> 00:10:46.850
And in the cell's content view we have the 5 in red.

00:10:46.850 --> 00:10:50.080
We have the 3 labels and 2 image views.

00:10:50.080 --> 00:10:53.259
And all of those are well and good.

00:10:53.259 --> 00:10:59.669
But we can get even better performance if rather than having
separate views and making the graphics software figure

00:10:59.669 --> 00:11:05.490
out what their relationship is to one another, and whether
or not they include one another, we can actually take all

00:11:05.490 --> 00:11:11.730
of those views and make one large view,
called a MovieView, and simply draw the bits

00:11:11.730 --> 00:11:17.379
to the rectangle inside the drawRect method
rather than having a bunch of separate views.

00:11:17.379 --> 00:11:22.809
And this actually can improve scrolling performance
quite a lot in the situations in which it applies.

00:11:22.809 --> 00:11:25.319
And I'll show you how to do that in just a moment.

00:11:25.320 --> 00:11:29.040
So to think about this conceptually
you have the UITableViewCell,

00:11:29.039 --> 00:11:33.679
which has a content view and has all these other views.

00:11:33.679 --> 00:11:40.609
And all we're going to do is collapse
all of those views into the one view.

00:11:40.610 --> 00:11:45.440
So you may not know right away why scrolling is poor.

00:11:45.440 --> 00:11:47.160
It may not be obvious.

00:11:47.159 --> 00:11:53.110
So we have a whole lot of instruments that will
help you with various performance optimizations.

00:11:53.110 --> 00:11:59.139
Memory management, graphics, checking for
leaks, and a whole lot of other things.

00:11:59.139 --> 00:12:04.289
We have a really great set of instruments that
just you, for whichever situation applies,

00:12:04.289 --> 00:12:08.480
you use a particular instrument, and you
can often find what's wrong fairly quickly.

00:12:08.480 --> 00:12:18.820
And we also have Shark, which is a time profiling
tool, which has very, very high resolution.

00:12:18.820 --> 00:12:23.920
And has some sophisticated data mining
technology that allows you to view

00:12:23.919 --> 00:12:28.269
where the time is going on the
CPU and what threads are doing.

00:12:28.269 --> 00:12:31.860
So we have a lot of performance
tools that will help you out.

00:12:31.860 --> 00:12:35.250
But it's important to use the tool in the right place.

00:12:35.250 --> 00:12:39.429
So for example, the simulator, as I
mentioned, maps it really, really fast.

00:12:39.429 --> 00:12:45.379
The simulator will execute code
way faster than the iPhone will,

00:12:45.379 --> 00:12:49.159
and possibly with a little bit
different performance characteristics.

00:12:49.159 --> 00:12:54.379
So for the simulator you can check
for things like memory usage, leaks.

00:12:54.379 --> 00:12:57.769
Because memory management isn't going to be
all that different on the simulator than it is

00:12:57.769 --> 00:13:01.179
on the device, whereas performance will be.

00:13:01.179 --> 00:13:06.399
So on the device you have your whole suite of tools
available to you, and that's where you should do a lot

00:13:06.399 --> 00:13:11.090
of your performance analysis for
anything that requires a lot of CPU time.

00:13:11.090 --> 00:13:14.269
So your scrolling optimizations and other things.

00:13:14.269 --> 00:13:18.090
So use the simulator for rapid
development and memory analysis,

00:13:18.090 --> 00:13:25.950
and use the device for basically any
of that and everything you want it to.

00:13:25.950 --> 00:13:29.890
So how do we improve scrolling
performance using these tools?

00:13:29.889 --> 00:13:33.319
And how do we translate what the
tools are telling us into code?

00:13:33.320 --> 00:13:36.730
Well, let's take a look at our app.

00:13:36.730 --> 00:13:39.350
So first of all, I've taken a Shark trace of this.

00:13:39.350 --> 00:13:47.779
So to take a Shark trace under the sampling menu
there's a Network/iPhone profiling menu item.

00:13:47.779 --> 00:13:52.569
And your iPhone appears if it was
connected to this computer.

00:13:52.570 --> 00:13:57.610
And then you click a button and you'll end up
with a trace that looks something like this.

00:13:57.610 --> 00:13:59.659
There are a couple of different types of views.

00:13:59.659 --> 00:14:03.449
One is the bottom up and.

00:14:03.450 --> 00:14:08.820
Sorry. One is heavy and the other is the top down view.

00:14:08.820 --> 00:14:11.770
I like the top down view for looking
at scrolling performance

00:14:11.769 --> 00:14:16.840
because I can fairly quickly find my TableView code.

00:14:16.840 --> 00:14:20.580
So you'll notice this is the code, the
CreateToPrepareCellForGlobal Row.

00:14:20.580 --> 00:14:25.910
This is the UIKit TableView code that
happens right before it asks us for a cell.

00:14:25.909 --> 00:14:31.879
And if you'll notice during scrolling a lot
of the time is spent just initializing cells,

00:14:31.879 --> 00:14:33.230
so that was what I mentioned before.

00:14:33.230 --> 00:14:35.730
That the cell has many different pieces to it.

00:14:35.730 --> 00:14:38.670
It has UI labels, which are taking up quite a lot of time.

00:14:38.669 --> 00:14:41.829
Seven percent over here.

00:14:41.830 --> 00:14:49.340
And of course we have the initialization of the cell
itself and all the other views that go along with it.

00:14:49.340 --> 00:14:56.340
So just initializing each cell takes about 20% of
the time, so we'd really like to cut that down.

00:14:56.340 --> 00:15:02.070
And the way that we cut that down is through
cell reuse, so let's take a look at that.

00:15:02.070 --> 00:15:04.080
Let's take a look at the code.

00:15:05.759 --> 00:15:13.750
So in our code we have a controller that creates a
TableViewCell, so let's look for the controller method.

00:15:13.750 --> 00:15:19.970
And when we go down to the cellForRowAtIndexPath
you'll notice

00:15:19.970 --> 00:15:28.320
that when we create the TableViewCell here we have a reuse
identifier API here, but we're not actually using it.

00:15:28.320 --> 00:15:36.270
So what we really want to do here is we want to
create the reuse identifier, and we'll just call it.

00:15:36.269 --> 00:15:42.720
We'll call it like Movies Reuse Identifier.

00:15:45.350 --> 00:15:52.029
So rather than creating one with a nil identifier
we actually want a user reuse identifier.

00:15:52.029 --> 00:15:54.209
But we don't want to create the cell all the time.

00:15:54.210 --> 00:16:00.290
So the first thing that we want to do really is
we want to see if there's a cell available to us.

00:16:00.289 --> 00:16:05.049
So to do that we use TableView
DQ reusable cell with identifier.

00:16:05.049 --> 00:16:09.689
And then we just pass the identifier to that method.

00:16:09.690 --> 00:16:14.940
Then we ask, did the cell exist?

00:16:14.940 --> 00:16:20.210
And if it doesn't then what we want
to do is we want to create a new cell.

00:16:20.210 --> 00:16:27.700
And for this particular cell that's
all there is for doing cell reuse.

00:16:27.700 --> 00:16:30.700
So that's cell reuse.

00:16:30.700 --> 00:16:38.970
And now the second thing that we want to look
at in our scrolling performance is opacity.

00:16:38.970 --> 00:16:41.970
So we have a Core Animation tool.

00:16:41.970 --> 00:16:46.710
If you choose RunWithPerformance tool
there's a Core Animation tool here.

00:16:46.710 --> 00:16:47.750
Core Animation instrument.

00:16:47.750 --> 00:16:53.539
That allows us to see if anything
is opaque in this TableView.

00:16:53.539 --> 00:17:00.620
So if we run with that you'll notice that the
first debug option here is color-blended layers.

00:17:00.620 --> 00:17:06.599
And this is a really useful option, because
if I click that and then go to the iPhone,

00:17:06.599 --> 00:17:12.579
you'll notice that everything that is opaque is in green.

00:17:12.579 --> 00:17:16.329
And everything that's translucent is in red.

00:17:16.329 --> 00:17:18.369
Red of course being very bad.

00:17:18.369 --> 00:17:21.809
So you'll notice here that we have
a number of things in red.

00:17:21.809 --> 00:17:24.889
In particular we have all of our labels are red.

00:17:24.890 --> 00:17:31.880
And labels are actually really, really easy to keep opaque.

00:17:31.880 --> 00:17:40.310
So to keep those labels opaque we have an optimization
in TableView and we'll take a look at this right now.

00:17:40.309 --> 00:17:44.720
So you may think that if you have some
sort of label in your TableViewCell,

00:17:44.720 --> 00:17:48.779
that when the user taps it, it needs to turn blue.

00:17:48.779 --> 00:17:54.599
And if the cell is going to highlight it in blue, well,
that means that the label sort of needs to be translucent.

00:17:54.599 --> 00:18:00.779
But UIKit actually has an optimization
that allows you to create labels

00:18:00.779 --> 00:18:04.470
and assign them background colors that aren't clear.

00:18:04.470 --> 00:18:07.700
And the TableView actually detects
when the user clicks on it.

00:18:07.700 --> 00:18:11.509
And when the user clicks on it
we swap out the background color.

00:18:11.509 --> 00:18:16.170
So you don't have to have a clear color for your UI labels.

00:18:16.170 --> 00:18:18.380
So let's look for the one instance of that here.

00:18:18.380 --> 00:18:19.010
Oops.

00:18:19.009 --> 00:18:25.539
[ Silence ]

00:18:25.539 --> 00:18:30.759
So we have a function that creates all of our
labels, and based on whether or not it's a big text

00:18:30.759 --> 00:18:33.549
or not it uses different fonts and metrics.

00:18:33.549 --> 00:18:36.879
And you'll notice that the background
color is currently a clear color.

00:18:36.880 --> 00:18:48.860
So we can actually make this a white color and that will
allow us to make everything there, all of the labels opaque.

00:18:48.859 --> 00:18:57.179
And so if we build that and install it we can
fire up the Core Animation instrument again,

00:18:57.180 --> 00:19:00.710
and actually it's still running so I'll just switch over.

00:19:02.119 --> 00:19:06.789
And you'll notice that all the labels are now opaque.

00:19:06.789 --> 00:19:13.009
And if I turn the color blend layers off
you'll notice that when I select the table cell

00:19:13.009 --> 00:19:17.609
that UIKit just does the right thing and shows the highlight

00:19:17.609 --> 00:19:21.169
without the background color of
the label occluding the highlight.

00:19:21.170 --> 00:19:22.930
So everything looks right.

00:19:22.930 --> 00:19:25.810
And now we're getting closer.

00:19:25.809 --> 00:19:28.970
You can see it's a lot better than what it was before.

00:19:28.970 --> 00:19:36.539
But there's still one more optimization that we can
do, and that's collapsing the cell view hierarchy.

00:19:36.539 --> 00:19:42.309
So to collapse the cell view hierarchy
you first look at your object model.

00:19:42.309 --> 00:19:50.399
So we have a Movie Summary cell, and that's a subclass
of UITableViewCell, that has several different views.

00:19:50.400 --> 00:19:53.070
So these are the 5 views that I talked about before.

00:19:53.069 --> 00:19:54.460
We have labels for.

00:19:54.460 --> 00:19:59.630
Oops. Sorry about that.

00:19:59.630 --> 00:20:04.950
So we have 5 labels, so notice this
is a subclass of UITableViewCell.

00:20:04.950 --> 00:20:07.710
And we have our 5 different views.

00:20:07.710 --> 00:20:15.420
So if you'll notice under the data models folder,
we actually have a data model for the Movie.

00:20:15.420 --> 00:20:20.090
And notice here that we have Title, Cast,
Synopsis, Rating and a couple of poster images.

00:20:20.089 --> 00:20:24.129
So we have all the data structures
that we need from this data model here.

00:20:24.130 --> 00:20:29.840
And so that means we can get rid of
all of these because rather than.

00:20:29.839 --> 00:20:33.909
So what we're going to do is create a
view that's just a subclass of UI View.

00:20:33.910 --> 00:20:36.190
And then draw everything within that single view.

00:20:36.190 --> 00:20:37.390
So that means.

00:20:37.390 --> 00:20:42.670
And because we have a movie in this particular
data structure, we can get rid of all of the views

00:20:42.670 --> 00:20:46.310
because we're just going to draw them ourselves.

00:20:46.309 --> 00:20:48.559
So those will all go away.

00:20:48.559 --> 00:20:53.309
Now of course, this isn't the UITableViewCell
anymore, so we'll call it a UI View.

00:20:53.309 --> 00:20:58.419
And it's not really a cell anymore,
so let's call it Movie Summary View.

00:20:58.420 --> 00:21:00.019
And now if we go.

00:21:00.019 --> 00:21:01.430
That's all we need to change in the header.

00:21:01.430 --> 00:21:08.029
And so if we go to the implementation now, you'll
find a few things that we'll need to change.

00:21:08.029 --> 00:21:10.190
Of course we'll change the title.

00:21:10.190 --> 00:21:12.009
There's an initializer.

00:21:12.009 --> 00:21:16.559
[ Silence ]

00:21:16.559 --> 00:21:22.129
And because this isn't a TableViewCell
anymore, we can actually get rid

00:21:22.130 --> 00:21:25.760
of all this View Creation and Adding
Things to the Content View.

00:21:25.759 --> 00:21:34.009
And this is just a UI View subclass, so we can
just make this on the KnitWithFrame method.

00:21:34.009 --> 00:21:39.920
[ Silence ]

00:21:39.920 --> 00:21:41.700
So that simplifies the initializer.

00:21:41.700 --> 00:21:44.500
And of course because we're not
creating all of these things anymore,

00:21:44.500 --> 00:21:48.640
we can get rid of everything but
the Movie Release in the alloc.

00:21:48.640 --> 00:21:50.910
So that's our initializers.

00:21:50.910 --> 00:21:53.310
Now we have a few more things that we can change.

00:21:53.309 --> 00:21:57.490
We're not using UI labels anymore, so we can get
rid of all this block of code that creates it.

00:21:57.490 --> 00:22:05.500
But we'll remember these text colors and font sizes for
later because we'll need to draw them in the same fonts.

00:22:05.500 --> 00:22:08.240
So let me move this back over.

00:22:08.240 --> 00:22:13.509
So we need to do a few things.

00:22:13.509 --> 00:22:19.319
In the View Controller to create this cell.

00:22:19.319 --> 00:22:25.539
Before we were creating a Movie
Summary cell and DQing an item.

00:22:25.539 --> 00:22:37.379
And now we actually need to change this so that we create
a standard TableViewCell, and you'll see this in a second.

00:22:37.380 --> 00:22:41.090
So rather than using our special UITableView
subclasss, we create a standard cell.

00:22:41.089 --> 00:22:43.849
DQ it like normal and create a new one if we need it.

00:22:43.849 --> 00:22:49.619
And in the code path where we have to create a
new one, we actually create a Movie Summary view.

00:22:49.619 --> 00:22:54.099
And then we give it a little tag
so that it's easy to find later.

00:22:54.099 --> 00:22:57.939
And then we set a couple of autoresizing
apps so that it behaves correctly.

00:22:57.940 --> 00:23:00.100
And then we add it to the content view.

00:23:00.099 --> 00:23:03.679
So that's our one view, and everything else is the same.

00:23:03.680 --> 00:23:08.759
So now we have a TableView cell that now has our main view.

00:23:08.759 --> 00:23:14.759
And now the only step that's left is
making our main view draw correctly.

00:23:14.759 --> 00:23:18.960
So to do that we need to change just a couple of things.

00:23:18.960 --> 00:23:22.600
You'll notice in the cell we have a set movie method.

00:23:22.599 --> 00:23:32.569
And in the old way, when it was subclass of UITableViewCell,
it actually had to set the content of each of the views.

00:23:32.569 --> 00:23:39.200
So we set a bunch of text labels, set the right
images, and set the right image for the rating.

00:23:39.200 --> 00:23:43.690
And because we're not dealing with views
anymore we can make all of that go away.

00:23:43.690 --> 00:23:47.049
We're going to display our content in drawRect.

00:23:47.049 --> 00:23:52.649
And of course, rather than trying to relay
up the cell, which we would need to do

00:23:52.650 --> 00:23:55.519
in the other world, we actually want to draw here.

00:23:55.519 --> 00:24:00.859
So we'll call SetNeedsDisplay, and for
now we'll just redisplay everything.

00:24:02.119 --> 00:24:07.500
And then there's one last step, and
that's the all-important drawing step.

00:24:07.500 --> 00:24:12.500
So to draw everything, of course
we don't lay out subviews anymore.

00:24:12.500 --> 00:24:14.569
We use the drawRect method.

00:24:14.569 --> 00:24:22.230
And we don't lay out subviews, and now our
content isn't really the content view bounds.

00:24:22.230 --> 00:24:24.769
We just can say it's our own bounds.

00:24:24.769 --> 00:24:30.529
Now you'll notice as I rewrite to this, as I change this
layout subview's method to a drawRect method, there really.

00:24:30.529 --> 00:24:32.579
Not a whole lot is changing.

00:24:32.579 --> 00:24:36.909
The geometry is all the same because
all of the images that are displayed,

00:24:36.910 --> 00:24:40.470
all the text that's displayed is still
in the same location in the cell.

00:24:40.470 --> 00:24:44.400
So we're actually not going to change
a whole lot of geometry code here.

00:24:44.400 --> 00:24:51.150
So if I change the title first, rather than figuring out
where I should place the label and placing it somewhere

00:24:51.150 --> 00:24:58.759
to lay it out, we're actually going to set the color
to black so that we can draw everything ourselves.

00:24:58.759 --> 00:25:02.579
We'll pick a font, which was the
same font that we had before.

00:25:02.579 --> 00:25:06.899
And then we'll just simply draw it at the
same point that we were drawing it before.

00:25:06.900 --> 00:25:14.360
So we have a utility method here to get all
of the geometry for this particular thing.

00:25:14.359 --> 00:25:20.009
And we use the line break mode tail truncation to
truncate the title if it doesn't fit on the screen.

00:25:20.009 --> 00:25:24.099
But the geometry was basically the same as it was before.

00:25:24.099 --> 00:25:27.939
Now the rating image is actually pretty easy too.

00:25:27.940 --> 00:25:33.870
Because we have a utility method that we've written
to get us the image based on what the rating was.

00:25:33.869 --> 00:25:38.729
And of course we have some long geometry
function to figure out where it should go.

00:25:38.730 --> 00:25:43.559
But the only thing we need to change is
rather than calling set for an UIImage view,

00:25:43.559 --> 00:25:47.139
we actually drawInRect here, so that was pretty easy.

00:25:47.140 --> 00:25:50.410
And in fact, the same thing holds
for all of the other tech cells.

00:25:50.410 --> 00:25:56.750
That rather than setting the frame
you'll simply use drawInRect, which is.

00:25:56.750 --> 00:25:57.500
Oh, sorry.

00:25:57.500 --> 00:26:04.730
We'll use the APIs here to draw text at a
point, which is the UIKit string editions.

00:26:04.730 --> 00:26:06.650
And so you'll notice we draw here.

00:26:06.650 --> 00:26:08.019
We draw here.

00:26:08.019 --> 00:26:12.839
And of course for the poster image
we don't change the geometry at all.

00:26:12.839 --> 00:26:14.519
We just draw it again.

00:26:14.519 --> 00:26:19.019
So what we've done is we've changed our geometry.

00:26:19.019 --> 00:26:23.700
Or kept our geometry the same but changed where we've drawn.

00:26:23.700 --> 00:26:26.009
And we're going to comment out
this for now.

00:26:26.009 --> 00:26:30.990
[ Silence ]

00:26:30.990 --> 00:26:36.200
And that was actually Movie.posterimage.

00:26:36.200 --> 00:26:45.490
And naturally I have a couple of errors, and that's because
I had this guy sitting around just in case I need it.

00:26:45.490 --> 00:26:54.630
And we called it MovieSummaryView.h, so get rid of that.

00:26:54.630 --> 00:26:57.500
And we have a couple errors.

00:26:57.500 --> 00:27:03.700
Oops. This is actually MovieSummaryView.

00:27:03.700 --> 00:27:04.799
Oops.

00:27:06.009 --> 00:27:12.710
[ Silence ]

00:27:12.710 --> 00:27:14.009
Oops. Sorry.

00:27:14.009 --> 00:27:22.329
[ Silence ]

00:27:22.329 --> 00:27:24.129
And I'm just going to.

00:27:24.130 --> 00:27:29.010
I missed a pound sign somewhere,
so don't do that at home.

00:27:29.009 --> 00:27:34.369
[ Laughter ]

00:27:34.369 --> 00:27:39.729
[ Silence ]

00:27:39.730 --> 00:27:46.089
And now if we switch back to our MovieView, you'll
notice it actually scrolls really, really smoothly now.

00:27:46.089 --> 00:27:47.220
So we made 3 changes.

00:27:47.220 --> 00:27:51.620
We changed the opacity so that everything was opaque.

00:27:51.619 --> 00:27:55.119
We reused table cells.

00:27:55.119 --> 00:28:00.879
And then we changed the view hierarchy
so that we only had 1 view.

00:28:00.880 --> 00:28:04.270
And with that you have pretty good scrolling performance.

00:28:04.269 --> 00:28:06.000
So that is TableView scrolling.

00:28:06.000 --> 00:28:11.589
[ Clapping ]

00:28:11.589 --> 00:28:17.179
[ Silence ]

00:28:17.180 --> 00:28:19.289
So to summarize, you draw as opaque.

00:28:19.289 --> 00:28:20.349
Draw as little as you can.

00:28:20.349 --> 00:28:21.990
Reuse table cells.

00:28:21.990 --> 00:28:23.710
Use things for your images.

00:28:23.710 --> 00:28:29.680
And all of this really gets back to making
as effective use of the software as you can.

00:28:29.680 --> 00:28:32.789
And next we'll talk just briefly about Application Launch.

00:28:32.789 --> 00:28:38.950
Application Launch is really, really important for
iPhone users because we are constantly going back

00:28:38.950 --> 00:28:43.319
and forth between our Mail app,
our SMS app, our Facebook app.

00:28:43.319 --> 00:28:45.379
One of the apps you all have written.

00:28:45.380 --> 00:28:47.940
We're going back and forth between apps constantly.

00:28:47.940 --> 00:28:54.450
And so it's really, really important to get your UI on
screen as fast as possible so that the user will feel

00:28:54.450 --> 00:28:58.170
that the overall system is really, really fast.

00:28:58.170 --> 00:29:00.840
And there's one more little bit here.

00:29:00.839 --> 00:29:06.539
Which is that if you take more than 20 seconds to
launch, then the iPhone will terminate your app.

00:29:06.539 --> 00:29:12.009
So please make it as fast as possible
and don't get your app terminated.

00:29:12.009 --> 00:29:14.720
So you need to design your apps
for a very, very quick launch.

00:29:14.720 --> 00:29:15.529
So what does that mean?

00:29:15.529 --> 00:29:19.809
Well, if you have a giant dataset
you want to load that dataset lazily.

00:29:19.809 --> 00:29:22.480
And you want to use a very small nib for the initial UI.

00:29:22.480 --> 00:29:28.759
If you use that nib file and have all sorts
of views that aren't really used right away,

00:29:28.759 --> 00:29:32.140
then you may want to break that
up into a lot of different pieces.

00:29:32.140 --> 00:29:37.920
And one thing that happens quite frequently is
a lot of times you load more images than we need

00:29:37.920 --> 00:29:40.519
to because it's easier to write the code that way.

00:29:40.519 --> 00:29:44.650
But try to only load the images that
you really, really need on launch.

00:29:44.650 --> 00:29:49.720
And of course, don't perform networking
operations in applicationDidFinishLaunching.

00:29:49.720 --> 00:29:51.069
It may work some of the time.

00:29:51.069 --> 00:29:52.700
For example, reachability checks.

00:29:52.700 --> 00:29:56.680
It may return quickly, or it may
not return for 10, 20 seconds.

00:29:56.680 --> 00:29:58.860
It's really dependent on the network conditions.

00:29:58.859 --> 00:30:03.729
So definitely don't perform synchronous networking
operations in applicationDidFinishLaunching

00:30:03.730 --> 00:30:06.920
If you're using asynchronous APIs then it's OK to do that.

00:30:06.920 --> 00:30:10.240
So just a couple of examples.

00:30:10.240 --> 00:30:15.440
In our software in the phone app and basically any app
that we have that has the button bar at the bottom,

00:30:15.440 --> 00:30:22.070
we can only load the visible UI so you don't go off and
load anything that's not going to be appearing on screen.

00:30:22.069 --> 00:30:25.809
And you wouldn't load all of these
images if you were on a different view.

00:30:25.809 --> 00:30:29.750
In the YouTube app we actually have
a lot of networking to do on launch.

00:30:29.750 --> 00:30:30.880
So what do we do?

00:30:30.880 --> 00:30:33.600
We display as much of the UI as possible.

00:30:33.599 --> 00:30:37.459
We display the separator and the bottom button bar.

00:30:37.460 --> 00:30:43.190
And then we display a little loading progress indicator so
that the user knows that we're actively working and trying

00:30:43.190 --> 00:30:47.039
to fetch the data that's required for YouTube.

00:30:47.039 --> 00:30:51.409
So that's a very, very brief overview of Application Launch.

00:30:51.410 --> 00:30:56.720
And now we go into one more topic which
is really, really important on iPhone.

00:30:56.720 --> 00:31:03.200
And probably the one that people have the
most difficulty with, and that's memory usage.

00:31:03.200 --> 00:31:05.600
So the iPhone OS is a modern OS.

00:31:05.599 --> 00:31:07.929
It has a virtual memory system.

00:31:07.930 --> 00:31:11.549
But the key difference between iPhone OS
and the Desktop OS's that many are used

00:31:11.549 --> 00:31:14.859
to developing for, is that there's no swap file.

00:31:14.859 --> 00:31:23.689
So you have access to all of the standard great C methods
like mmap, munmaps that allow you to have large data pieces

00:31:23.690 --> 00:31:26.600
in file, but the OS can swap out as it needs memory.

00:31:26.599 --> 00:31:27.750
But there's no swap file.

00:31:27.750 --> 00:31:31.930
So once you've allocated enough memory
and the system's running out of memory,

00:31:31.930 --> 00:31:34.759
we start giving you memory notifications.

00:31:34.759 --> 00:31:38.730
And eventually we may have to terminate
apps if memory usage keeps growing.

00:31:38.730 --> 00:31:42.559
So it's really important to keep
your memory footprint down on iPhone.

00:31:42.559 --> 00:31:47.179
And we'll go through a few things you can do here.

00:31:47.180 --> 00:31:54.039
One is of course iPhone OS has the standard
sort of APIs that you're used to on Mac OS X.

00:31:54.039 --> 00:31:57.960
We have Objective-C where we manage
everything through your contain accounts.

00:31:57.960 --> 00:32:04.490
We don't have garbage collection, but we have all
the standard C and C++ memory management functions.

00:32:04.490 --> 00:32:08.319
So we're going to go through just
a few areas of memory usage.

00:32:08.319 --> 00:32:12.359
Static memory, dynamic memory, application
footprints, and memory warnings.

00:32:12.359 --> 00:32:18.149
We'll start out with static memory, mainly
because it's a performance optimization.

00:32:18.150 --> 00:32:22.840
And so static memory is basically some of the.

00:32:22.839 --> 00:32:25.480
One example of that is the code that you've compiled.

00:32:25.480 --> 00:32:28.309
Where you want to the make that
you've compiled as small as possible.

00:32:28.309 --> 00:32:33.929
So if you have giant files that you're not using,
you don't want to compile those into your code.

00:32:33.930 --> 00:32:37.620
And one thing that's great about
ARM is that we have a couple

00:32:37.619 --> 00:32:41.849
of instruction sets that allow you to reduce your code size.

00:32:41.849 --> 00:32:48.579
So on the original iPhone and the iPhone 3G,
we have the choice between RNB6 and Thumb.

00:32:48.579 --> 00:32:54.299
RNB6 and RNB7 for the iPhone 3GS
are 32 bit instruction sets.

00:32:54.299 --> 00:32:59.619
Both of them allow access to the floating point registers,
and both of them you can use whenever you want them.

00:32:59.619 --> 00:33:05.039
But on the iPhone and iPhone 3G there are
some cases where you want to use Thumb.

00:33:05.039 --> 00:33:10.500
And in fact we turn it on by default,
as I turn the graphics apps.

00:33:10.500 --> 00:33:16.519
Thumb is a 16 bit instruction set, but doesn't provide
access to things like floating point registers.

00:33:16.519 --> 00:33:17.389
So in order to.

00:33:17.390 --> 00:33:23.300
So if you do any floating point operations we have to
Thumb back to ARM and then perform some instructions in ARM

00:33:23.299 --> 00:33:26.589
and then come back to Thumb mode, and
that has some overhead associated with it.

00:33:26.589 --> 00:33:32.079
So if you have really, really intensive floating
point apps like games, you may not want to use Thumb.

00:33:32.079 --> 00:33:37.759
But for all other apps, apps like the one that I just
showed you that simply move around views in places

00:33:37.759 --> 00:33:41.379
and show some basic UI, Thumb is perfectly great for that.

00:33:41.380 --> 00:33:44.540
So you don't want to use it all the time,
but a lot of times it's appropriate.

00:33:44.539 --> 00:33:48.990
Now the iPhone 3GS you have the choice between RNB6 and.

00:33:48.990 --> 00:33:49.359
Oh, sorry.

00:33:49.359 --> 00:33:51.399
RNB7 and Thumb2.

00:33:51.400 --> 00:33:57.650
Now Thumb2 is really, really great because
the instruction sizes are both 16 and 32 bit,

00:33:57.650 --> 00:34:00.960
and you have full access to the floating point registers.

00:34:00.960 --> 00:34:06.299
So if you need to use a 32 bit instruction to get
all the hardware capabilities, then we'll use it.

00:34:06.299 --> 00:34:10.199
And so because of this we actually
turn it on all of the time.

00:34:10.199 --> 00:34:12.689
It's what you get by default.

00:34:12.690 --> 00:34:15.710
And in fact, the entire OS is compiled in Thumb2.

00:34:15.710 --> 00:34:18.139
That allows us to keep our code size down.

00:34:18.139 --> 00:34:23.929
We see anywhere from a 20 to 35% reduction in code
size which, if you imagine if you have to read 20

00:34:23.929 --> 00:34:29.339
or 30% less code on App Launch, that's going
to be a nice performance win for App Launch

00:34:29.340 --> 00:34:32.559
and anything that you're doing in your app.

00:34:32.559 --> 00:34:37.440
Caches will have a lot more instructions
in them if your code size is small.

00:34:37.440 --> 00:34:40.900
So Thumb2 is really, really great.

00:34:40.900 --> 00:34:47.960
And in addition to that on the iPhone 3GS we actually
have one more thing that you can do, and that's Neon Code.

00:34:47.960 --> 00:34:50.280
So Neon is a vector floating point.

00:34:50.280 --> 00:34:53.840
Or a vector unit much like altavech in SSE.

00:34:53.840 --> 00:34:58.450
And Neon allows you to do some very, very fast vector math.

00:34:58.449 --> 00:35:05.069
And we have an assembly interface to that currently,
and we'll work on improving that a little bit.

00:35:05.070 --> 00:35:09.590
But it's very, very fast for the
applications that are appropriate for it.

00:35:09.590 --> 00:35:12.800
Not everybody will use that certainly,
and many of you in the room won't.

00:35:12.800 --> 00:35:18.880
But it is available if you have
really, really complicated math to do.

00:35:18.880 --> 00:35:20.890
One last bit on code size.

00:35:20.889 --> 00:35:25.409
We see this occasionally even in some of
our own software before we release it.

00:35:25.409 --> 00:35:31.819
And that's C++ exceptions and runtime type
identification which are features of the C++ language

00:35:31.820 --> 00:35:35.500
that have some overhead to them and set X code size.

00:35:35.500 --> 00:35:40.750
So if you don't need these features and don't know
that you need them, then you can turn them off.

00:35:40.750 --> 00:35:41.849
And they're off by default.

00:35:41.849 --> 00:35:44.659
So if your code size is large you
may just want to doublecheck

00:35:44.659 --> 00:35:49.699
that those checkboxes aren't checked,
if you don't use those features.

00:35:49.699 --> 00:35:57.469
One little bit that's sort of a memory
and a speed thing is properties.

00:35:57.469 --> 00:36:00.750
So properties can be declared atomic or nonatomic.

00:36:00.750 --> 00:36:07.380
Atomic gives you thread safe properties,
but it gives you autoreleased objects.

00:36:07.380 --> 00:36:10.440
So it's not quite as fast and you'll
use a little bit more memory usage.

00:36:10.440 --> 00:36:14.880
So it's sort of a best practices
and we use this in our APIs.

00:36:14.880 --> 00:36:17.660
We suggest using nonatomic when you can.

00:36:17.659 --> 00:36:21.779
But certainly if you're using threading
you should use the atomic properties.

00:36:21.780 --> 00:36:23.269
So that's static memory.

00:36:23.269 --> 00:36:25.170
On to dynamic memory.

00:36:25.170 --> 00:36:30.840
The main thing about dynamic memory is
you want to keep in memory what you need.

00:36:30.840 --> 00:36:32.059
Now memory optimize.

00:36:32.059 --> 00:36:35.799
Keeping your memory footprint down doesn't
mean that you never cache anything.

00:36:35.800 --> 00:36:37.539
It means that you cache the right object.

00:36:37.539 --> 00:36:44.940
So if you're using something frequently in a scrolling
list, you will probably want to cache some drawing objects.

00:36:44.940 --> 00:36:49.519
But you do need to architect your app in a way
that you can release those objects if you need to.

00:36:49.519 --> 00:36:51.969
So on memory warnings you may have an image cache.

00:36:51.969 --> 00:36:59.109
So for example, that application has a cache of thumbnails,
and those thumbnails go away if you get a memory warning.

00:36:59.110 --> 00:37:00.849
So we keep them around as long as we can.

00:37:00.849 --> 00:37:04.099
And when the OS decides we're running
out of memory, then we release them.

00:37:04.099 --> 00:37:06.239
So free the objects when you're done with them.

00:37:06.239 --> 00:37:11.459
And we have a couple of memory tools that
you can use to memory object allocations.

00:37:13.099 --> 00:37:17.259
Another little tip is try not to use
autorelease when you don't need to.

00:37:17.260 --> 00:37:23.030
So autorelease is really, really great when you have
an API boundary, and it doesn't really make sense

00:37:23.030 --> 00:37:30.810
to make whoever is calling the API own a particular
object or deal with the memory management of that object.

00:37:30.809 --> 00:37:33.230
You just want to provide something back to them.

00:37:33.230 --> 00:37:35.670
But there are a lot of cases, for example in tight loops

00:37:35.670 --> 00:37:39.380
where you may be allocating a string
with some sort of format.

00:37:39.380 --> 00:37:42.630
And then just stuffing it into
some data structure or dictionary.

00:37:42.630 --> 00:37:48.940
And so for those cases where you don't really need to
autorelease, we suggest writing the one extra line of code.

00:37:48.940 --> 00:37:53.159
And rather than using the convenience
methods that return autorelease methods,

00:37:53.159 --> 00:37:56.710
use the allocaknit
variant of the initializers.

00:37:56.710 --> 00:38:05.720
And there are times, say, if you're parsing XML
where you may have to use autoreleased objects.

00:38:05.719 --> 00:38:08.289
So some of our system APIs.

00:38:08.289 --> 00:38:12.279
And perhaps some of your APIs will sort of
by their nature return autoreleased objects.

00:38:12.280 --> 00:38:17.860
So for example, in a string as an API component separated
by a string, which is really, really handy for breaking

00:38:17.860 --> 00:38:22.010
up strings if you're doing certain kinds of
parsing, it returns autoreleased objects.

00:38:22.010 --> 00:38:26.610
And so for some of those cases where you want
to use the really, really convenient method,

00:38:26.610 --> 00:38:33.590
you can actually create an autorelease tool so that all
of that memory that you create will go away at the end.

00:38:33.590 --> 00:38:39.650
And the last thing that you definitely
want to do is eliminate memory links.

00:38:39.650 --> 00:38:43.780
So memory leaks are when you have a
reference to your object in your code or.

00:38:43.780 --> 00:38:49.990
Sorry, when you have an object lying around in your
heap that you don't actually have a reference to.

00:38:49.989 --> 00:38:53.750
So we have some tools and instruments that
allow you to check for leaks conservatively.

00:38:53.750 --> 00:38:56.469
So it will scan your process phase,
figure out what objects are

00:38:56.469 --> 00:39:00.119
around that don't have any references
to it, and report those to you.

00:39:00.119 --> 00:39:02.219
And it gives you the back trace of those.

00:39:02.219 --> 00:39:04.629
Memory leaks are usually pretty easy leaks.

00:39:04.630 --> 00:39:07.360
Pretty easy memory issues to fix.

00:39:07.360 --> 00:39:09.990
And so you should definitely run leaks and
make sure you don't have anything major.

00:39:09.989 --> 00:39:13.879
Because anything you leak is memory that your app can't use.

00:39:13.880 --> 00:39:18.680
And the one really, really important thing
for iPhone, and this is both app architecture

00:39:18.679 --> 00:39:23.339
and implementation, is low memory warnings.

00:39:23.340 --> 00:39:29.820
Everybody should respond to low memory warnings because
when the OS has gotten up to a point to where you're say 80

00:39:29.820 --> 00:39:35.470
or 90% full, it will send you a memory warning
and try to free up the memory that it can

00:39:35.469 --> 00:39:37.849
so that the rest of the OS can continue to run.

00:39:37.849 --> 00:39:41.089
Because the OS knows if you keep using
more and more memory there will be a point

00:39:41.090 --> 00:39:45.120
to where the OS itself can't run and
it will have to terminate an app.

00:39:45.119 --> 00:39:50.380
So definitely respond to low memory warnings,
and architect your apps so that you can.

00:39:50.380 --> 00:39:53.680
There are 3 APIs that we give you for this.

00:39:53.679 --> 00:39:57.989
The Application Delegate has an
applicationDidReceiveMemoryWarning method.

00:39:57.989 --> 00:40:04.239
UIView Controller subclasses have a DidReceiveMemoryWarning
and it will do a lot of work for you.

00:40:04.239 --> 00:40:06.199
It will purge some offscreen views.

00:40:06.199 --> 00:40:11.939
And there are direct notifications, so if you have your
image cache that doesn't really have a direct path from any

00:40:11.940 --> 00:40:18.889
of your app objects to this lower level data structure,
you can register for the direct notifications.

00:40:18.889 --> 00:40:23.879
So for low memory warnings, you want
to make sure that your app is set up so

00:40:23.880 --> 00:40:27.650
that you can purge any offscreen
views, most of which is done for you.

00:40:27.650 --> 00:40:33.630
Delete any cached objects that you have and
get rid of any expensive resource files.

00:40:33.630 --> 00:40:39.680
To summarize, always use the right
compiler settings for your app.

00:40:39.679 --> 00:40:42.349
Minimize your object lifetimes when you can.

00:40:42.349 --> 00:40:46.569
Eliminate any of the memory leaks that you
have because that's memory that you can't use.

00:40:46.570 --> 00:40:49.500
And architect your apps so that you
can respond to low memory warnings

00:40:49.500 --> 00:40:52.949
and free up memory when it's really, really important.

00:40:52.949 --> 00:40:56.149
And if you want a lot more detail we
actually have a session this afternoon

00:40:56.150 --> 00:40:58.930
that focuses exclusively on memory management.

00:40:58.929 --> 00:41:04.329
And we give you a whole lot of code examples that will
show you how to translate all of these best practices

00:41:04.329 --> 00:41:08.289
and give you a lot more data into actually code.

00:41:08.289 --> 00:41:12.159
So now let's move on to files and data.

00:41:13.329 --> 00:41:16.849
So we have just a couple of tips to
give you about general file usage.

00:41:16.849 --> 00:41:22.389
The first is we have some APIs that allow
you to load large resource files into memory,

00:41:22.389 --> 00:41:26.569
but without that memory sort of
costing against your app in memory.

00:41:26.570 --> 00:41:28.880
And that's mmap and munmap.

00:41:28.880 --> 00:41:32.700
And we have NSData APIs that allow you to access this.

00:41:32.699 --> 00:41:38.299
So NSdatainitWithContentsofMappedFile
creates a data with an mmapped backing.

00:41:38.300 --> 00:41:45.210
So if you have giant 50 Megabyte file, say it's
full of artwork or full of some other data,

00:41:45.210 --> 00:41:51.670
then when you use mmap for that the OS can decide
when it wants to evict some of that memory.

00:41:51.670 --> 00:41:56.820
So if you have enough memory and you can keep half
the file in memory, the OS will keep it in memory.

00:41:56.820 --> 00:42:02.010
But if your app uses more and more memory and the OS is
running out of memory, it will throw that memory away.

00:42:02.010 --> 00:42:08.060
So mmap is really great for large resource files, and we
use it a lot in our system for our large resource files.

00:42:08.059 --> 00:42:13.769
And Core Data is a great addition to iPhone OS 3.0.

00:42:13.769 --> 00:42:19.159
And it's great from the memory management
standpoint, and from the efficiency standpoint,

00:42:19.159 --> 00:42:20.739
and from how much code you have to write.

00:42:20.739 --> 00:42:24.609
So for large datasets definitely consider using Core Data.

00:42:24.610 --> 00:42:28.460
It has a few really nice features of it.

00:42:28.460 --> 00:42:31.119
It doesn't keep the entire dataset in memory.

00:42:31.119 --> 00:42:40.460
So if you have some giant 3000 person or 3000 entry
data file or database, it won't keep that in memory.

00:42:40.460 --> 00:42:44.539
You can specify well, I want to keep
200 in memory at any point in time.

00:42:44.539 --> 00:42:48.940
And it will just do a lot of work for you and do it on
background threads so you don't have to write a whole bunch

00:42:48.940 --> 00:42:52.579
of complicated threading objects and
threading code to get everything right.

00:42:52.579 --> 00:42:58.980
So it just handles a lot of the complexity for you,
and it helps you have better memory management.

00:43:00.210 --> 00:43:06.150
One thing that has come up in the last year
is download performance where you really want,

00:43:06.150 --> 00:43:14.550
when your user clicks the Buy button on the app store you
want the user to get that file as quickly as possible.

00:43:14.550 --> 00:43:16.730
And there are sort of 2 sides of this.

00:43:16.730 --> 00:43:20.389
One is anything over 10 Megs you can't download over 3G.

00:43:20.389 --> 00:43:23.769
So if you can keep your app below 10 Megs
or if you're just on the edge you may want

00:43:23.769 --> 00:43:26.099
to see if you can get that down a little bit.

00:43:26.099 --> 00:43:31.279
But one important thing is before you submit your
app to the app store, just go and double check

00:43:31.280 --> 00:43:34.100
that you don't have any unnecessary files.

00:43:34.099 --> 00:43:39.349
And one example here is subversion directories where
we actually had an app that was on the app store

00:43:39.349 --> 00:43:44.839
who had accidentally submitted some subversion
directories, and the app ended up being 100 Megs more

00:43:44.840 --> 00:43:51.890
than what it actually needed to
be, so avoid that if you can.

00:43:51.889 --> 00:43:55.569
One other thing that you can't do to improve performance,

00:43:55.570 --> 00:43:58.940
but you can do to make performance
worse is backup performance.

00:43:58.940 --> 00:44:02.470
All of our data in till the Documents is backed up.

00:44:02.469 --> 00:44:10.099
The idea is that users when they sync with iTunes
we want them to have the last snapshot of their app.

00:44:10.099 --> 00:44:12.960
And so we back up everything in Documents.

00:44:12.960 --> 00:44:18.220
So for anything that's user data that they won't, that
users won't want restored, if for whatever reason they need

00:44:18.219 --> 00:44:22.719
to restore their phone or they lose
their phone, put that data in Documents.

00:44:22.719 --> 00:44:27.919
Use Library caches for any data that
can't be required like downloaded images.

00:44:27.920 --> 00:44:32.139
And then of course there's all the
optimizations that we give you for free.

00:44:32.139 --> 00:44:37.190
The optimizing PNGs and we convert plist to
binary because it's faster and uses less memory.

00:44:37.190 --> 00:44:40.389
So we have those optimizations that are built in for you.

00:44:40.389 --> 00:44:42.250
So that's a lot about performance.

00:44:42.250 --> 00:44:46.239
And now another critical aspect of
performance is power and battery life,

00:44:46.239 --> 00:44:49.000
and to talk about that we have Peter
Handel from the iPhone Power Team.

00:44:49.000 --> 00:44:55.650
[ Clapping ]

00:44:55.650 --> 00:44:56.130
Hi, everyone.

00:44:56.130 --> 00:44:57.240
My name's Peter Handel.

00:44:57.239 --> 00:44:58.739
I'm an iPhone Power Engineer.

00:44:58.739 --> 00:45:01.969
I've been doing that for almost 3 years now.

00:45:01.969 --> 00:45:08.779
I'd like to share with you some tips and tricks on how to
improve the battery life of your application in 3 key areas.

00:45:08.780 --> 00:45:12.610
First off, when using the radio to send and receive data.

00:45:12.610 --> 00:45:16.320
Secondly, when using Core Locations
to figure out where the device is.

00:45:16.320 --> 00:45:24.470
And finally, when using the CPU and GPU to
get your work done and draw in the screen.

00:45:24.469 --> 00:45:26.659
First the radio.

00:45:26.659 --> 00:45:29.429
It's very expensive to send data over 3G.

00:45:29.429 --> 00:45:33.509
Sending data over 3G is one of the
most power intensive things you can do.

00:45:33.510 --> 00:45:41.650
This is exacerbated by the fact that the 3G networks keep
the 3G radios on for a few seconds after data transmission.

00:45:41.650 --> 00:45:48.019
Therefore, if you were to send and receive even
one byte of data every 5, 10 seconds or so,

00:45:48.019 --> 00:45:52.250
you'd be keeping those power hungry
3G radios on all the time.

00:45:52.250 --> 00:45:57.809
And that's one of the quickest ways I know of
how to drain your battery, so don't do that.

00:45:57.809 --> 00:46:05.599
So how can your application enjoy the wide availability
and high speed of 3G and still have excellent battery life?

00:46:05.599 --> 00:46:07.139
Well, here's a few tips.

00:46:07.139 --> 00:46:13.629
First off, coalesce your data transfers into large
chunks rather than transmitting a thin stream.

00:46:13.630 --> 00:46:17.369
This will allow those 3G radios to go idle more quickly.

00:46:17.369 --> 00:46:20.449
Also, minimize the amount of data that's transferred.

00:46:20.449 --> 00:46:22.509
Use a compact data format if you can.

00:46:22.510 --> 00:46:26.000
Maybe even compress your data before transmission.

00:46:26.000 --> 00:46:30.750
So for the 3G radio chip, an idle chip is a green chip.

00:46:30.750 --> 00:46:37.650
From a power perspective, there are 2
main differences between Wi-Fi and 3G.

00:46:37.650 --> 00:46:41.960
First off, Wi-Fi uses roughly half the power of 3G.

00:46:41.960 --> 00:46:46.510
And I mean this can definitely change with
network characteristics and stuff like that.

00:46:46.510 --> 00:46:53.820
Also the Wi-Fi network will allow the Wi-Fi radios to go
into a low power state immediately after transmitting data.

00:46:53.820 --> 00:46:57.880
Because of these differences your application
might want to know whether or not it's

00:46:57.880 --> 00:47:01.340
on a cell network versus when it's on Wi-Fi.

00:47:01.340 --> 00:47:08.000
The way that you do this is you check a system configuration
flag called KSE Network Reachability Flag as WM.

00:47:08.000 --> 00:47:13.059
[ Silence ]

00:47:13.059 --> 00:47:15.440
So where does 2G fit into this mix?

00:47:15.440 --> 00:47:21.849
Well, from a power perspective 2G falls
kind of halfway between 3G and Wi-Fi.

00:47:21.849 --> 00:47:26.869
And 2G, like Wi-Fi, will, the 2G
network will allow the 2G radios to go

00:47:26.869 --> 00:47:30.609
into that low power state immediately after data transfer.

00:47:33.360 --> 00:47:35.220
And that's the radios.

00:47:35.219 --> 00:47:37.439
Next, Core Location.

00:47:37.440 --> 00:47:43.230
Judging from the number of apps on
the app store that use Core Location,

00:47:43.230 --> 00:47:46.360
you guys love it and the customers love it too.

00:47:46.360 --> 00:47:49.820
If you haven't used it, Core Location
can, with just a few lines of code,

00:47:49.820 --> 00:47:52.510
which I have up here, it can tell your device.

00:47:52.510 --> 00:47:57.830
It can tell your application where your
device is to varying degrees of accuracy.

00:47:57.829 --> 00:48:02.719
However, be sure to only use the least amount of
accuracy that you need, because the higher levels

00:48:02.719 --> 00:48:07.250
of accuracy use more battery power, especially the GPS.

00:48:07.250 --> 00:48:11.940
For example, if you have an application that finds
coffee shops, if you can figure out that you're here

00:48:11.940 --> 00:48:16.710
as the Moscone Center, that's probably good enough to
know that there's a coffee shop right across the street.

00:48:16.710 --> 00:48:20.970
Next, the distance filter.

00:48:20.969 --> 00:48:24.589
This dictates how often you receive
location change notifications.

00:48:24.590 --> 00:48:28.350
In other words, they'll tell you when your device moves.

00:48:28.349 --> 00:48:34.829
Be sure to set it appropriately, however, because
the default is to tell you every single movement.

00:48:34.829 --> 00:48:39.519
You can imagine this will result in a lot of
unnecessary events which will use up a lot of CPU

00:48:39.519 --> 00:48:43.230
and therefore also battery life, so
be sure to set this appropriately.

00:48:43.230 --> 00:48:51.409
Be sure to call StopUpdatingLocation as soon as
you've reached your desired level of accuracy.

00:48:51.409 --> 00:48:55.619
Also, note that Core Location will
manage the GPS power for you.

00:48:55.619 --> 00:48:58.789
What this means is that it's OK
to call StopUpdatingLocation,

00:48:58.789 --> 00:49:02.349
and then a few seconds later call
StartUpdatingLocation again.

00:49:02.349 --> 00:49:07.869
For example, in your coffee shop finder application, if the
user is on his way to the coffee shop and he decides to go

00:49:07.869 --> 00:49:13.599
into for example the Preferences pane of your application,
it's OK at this point to call StopUpdatingLocation.

00:49:13.599 --> 00:49:17.639
And then when the user goes out of the
Preferences pane back to the Mac, for example,

00:49:17.639 --> 00:49:20.250
go ahead and call StartUpdatingLocation again.

00:49:20.250 --> 00:49:25.860
At this point Core Location will pick up right where it
left off as if you had never called StopUpdatingLocation.

00:49:25.860 --> 00:49:30.480
So for the GPS chip, an idle chip is a green chip.

00:49:30.480 --> 00:49:34.409
And that's Core Location.

00:49:34.409 --> 00:49:37.339
Finally, the CPU and GPU.

00:49:37.340 --> 00:49:41.829
Now, you might be wondering why are we talking about
power and performance in the same presentation?

00:49:41.829 --> 00:49:47.250
Well, it turns out that when you optimize the performance
you get better battery life thrown in for free.

00:49:47.250 --> 00:49:54.099
This is because fast code means less CPU
time, which means less battery life use.

00:49:54.099 --> 00:49:57.150
So for the CPU, I'm sure you can
guess what I'm going to say now.

00:49:57.150 --> 00:49:59.630
An idle chip is a green chip.

00:49:59.630 --> 00:50:04.910
Now iPhone OS is an event-based operating system.

00:50:04.909 --> 00:50:11.399
Now in certain conditions you might be tempted to poll
to check repeatedly to see when a condition has been met.

00:50:11.400 --> 00:50:13.710
Try to avoid this whenever possible.

00:50:13.710 --> 00:50:17.470
Instead, subscribe to an event whenever it's available.

00:50:17.469 --> 00:50:20.619
However sometimes there aren't events
for some things, and so you have to poll.

00:50:20.619 --> 00:50:24.389
So in this case use a timer with a low frequency.

00:50:24.389 --> 00:50:29.170
And instead of setting that frequency to something like
every 30th of a second0 so you're continuously checking,

00:50:29.170 --> 00:50:35.970
try setting it to every 10th of second or maybe even
every second to see if there's any user visible impact.

00:50:37.880 --> 00:50:41.970
For example, if you want to use the
accelerometer, you might be tempted to continually

00:50:41.969 --> 00:50:44.719
to check the accelerometer to see if it's being shook.

00:50:44.719 --> 00:50:49.599
Instead, use the shake API to subscribe
to the event so you get notified

00:50:49.599 --> 00:50:55.519
when the device is being shook, and
I have an example of that up here.

00:50:55.519 --> 00:50:59.219
For the CPU, try to be as bursty as possible.

00:50:59.219 --> 00:51:03.189
This will allow the CPU to enter an
idle state that I've been talking about.

00:51:03.190 --> 00:51:06.220
Note that this may require you to
completely restructure your code,

00:51:06.219 --> 00:51:08.919
or possibly even use a completely different algorithm.

00:51:08.920 --> 00:51:12.990
How can you figure out when your
code is being nice and bursty?

00:51:12.989 --> 00:51:19.269
Well, use the CPU Sampler Tool, which is part of
Instruments to check the CPU level graphically.

00:51:19.269 --> 00:51:21.449
I have an example of that right up here.

00:51:21.449 --> 00:51:23.909
This is actually of a music playback from the iPhone.

00:51:23.909 --> 00:51:30.909
What we discovered is that when we coalesced, when we
put together all of our decompression into large chunks.

00:51:30.909 --> 00:51:33.929
When we decompressed our audio into large
chunks rather than just doing it a little bit

00:51:33.929 --> 00:51:38.219
at a time, our battery life improved quite a bit.

00:51:38.219 --> 00:51:43.359
This allows the CPU to idle for long periods between work.

00:51:43.360 --> 00:51:45.559
So finally, procrastination.

00:51:45.559 --> 00:51:46.829
Who doesn't like to procrastinate?

00:51:46.829 --> 00:51:51.590
Because if you put it off long enough
you just might not have to do it at all.

00:51:51.590 --> 00:51:56.059
So for example, we came across this game
that saved its state every 30 seconds.

00:51:56.059 --> 00:52:01.570
You can imagine that's a lot of wasted CPU
time, and also a lot of wasted battery life.

00:52:01.570 --> 00:52:07.120
Instead, maybe you could save the game
state when the user exits the application.

00:52:07.119 --> 00:52:11.889
Or better yet, maybe your user's really into this
game and he finishes it completely in one sitting.

00:52:11.889 --> 00:52:13.799
In that case, there's no state to save at all.

00:52:13.800 --> 00:52:18.350
Oh, and there's just one more thing of course.

00:52:18.349 --> 00:52:25.639
When using the OpenGL ES or when using the GPU, be sure to
pick a fixed frame rate rather than varying it up and down.

00:52:25.639 --> 00:52:31.549
Because if you vary your frame rate too much,
it may give the appearance of dropped frames.

00:52:31.550 --> 00:52:35.340
We're recommending you guys stick
to about 30 frames per second.

00:52:35.340 --> 00:52:39.780
Also, if the frame hasn't changed, don't redraw the screen.

00:52:39.780 --> 00:52:44.740
For example, if you're writing a chess
application and no pieces on the screen have moved,

00:52:44.739 --> 00:52:52.379
don't be redrawing the frame every 30th of a second
because that can waste a lot of CPU and a lot of battery.

00:52:52.380 --> 00:52:53.650
So what have we learned today?

00:52:53.650 --> 00:52:58.260
Well, on the radios we know that
data transmission is very expensive.

00:52:58.260 --> 00:53:02.620
So we coalesce and compress our data as much as possible.

00:53:02.619 --> 00:53:08.159
And for Core Location we use the least amount of
accuracy we need and we call StopUpdatingLocation as soon

00:53:08.159 --> 00:53:11.339
as we've reached the level of accuracy that we want.

00:53:11.340 --> 00:53:17.230
And with the CPU and GPU, we optimize for performance
and get better battery life thrown in for free.

00:53:17.230 --> 00:53:18.019
We're bursty.

00:53:18.019 --> 00:53:20.519
We procrastinate as much as possible.

00:53:20.519 --> 00:53:27.949
And when using the GPU we use a fixed frame rate of 30
frames per second, and we don't unnecessarily redraw frames.

00:53:27.949 --> 00:53:31.559
So to summarize, an idle chip is a green chip.

00:53:31.559 --> 00:53:33.199
Thank you very much.

00:53:33.199 --> 00:53:34.000
Dave?

00:53:34.000 --> 00:53:39.780
[ Clapping ]

00:53:39.780 --> 00:53:43.550
>> So we've learned a lot today about
all sorts of aspects of performance.

00:53:43.550 --> 00:53:49.690
We learned about how to optimize your app to get the
best scrolling performance on everything that we ship.

00:53:49.690 --> 00:53:51.940
We have Application Launch.

00:53:51.940 --> 00:53:57.599
Always make sure that your Application Launches
loads as little as possible and launches quickly.

00:53:57.599 --> 00:54:00.250
Memory usage, which I'll talk a
little bit more in one second.

00:54:00.250 --> 00:54:04.989
Files and data, so always make sure that you use
the right APIs, the right data to the right places.

00:54:04.989 --> 00:54:08.559
And Peter just told you a lot about
how to optimize for battery life

00:54:08.559 --> 00:54:11.150
because you want the device to last as long as possible.
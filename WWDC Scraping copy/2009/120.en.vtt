WEBVTT

00:00:12.589 --> 00:00:16.559
>> Hi, I'm Chris Marcellino, an iPhone
Software Engineer and I'm here today to talk

00:00:16.559 --> 00:00:19.809
about the Apple Push Notification Service.

00:00:19.809 --> 00:00:22.739
But before we get started I'm curious,
how many of you are familiar

00:00:22.739 --> 00:00:26.629
with the new version of the Push Service by a show of hands?

00:00:26.629 --> 00:00:28.410
Oh wow, OK, great.

00:00:28.410 --> 00:00:31.870
Well, for those of you that raised your
hand, I'm going to cover some best practices

00:00:31.870 --> 00:00:33.539
and some advanced troubleshooting tips for you.

00:00:33.539 --> 00:00:37.670
But for the rest of you, before the end of this
hour you'll know everything that you need to know

00:00:37.670 --> 00:00:40.820
to start sending notifications across the service.

00:00:40.820 --> 00:00:45.200
So let's get started.

00:00:45.200 --> 00:00:50.109
So today we're going to talk about how you can make your
apps network connected even when they're not running.

00:00:50.109 --> 00:00:55.259
Now this is huge because this is going to give
your apps a whole new angle in the app store.

00:00:55.259 --> 00:01:00.019
We're also going to talk about how you can get
users the information they want when they want it

00:01:00.020 --> 00:01:02.880
and let them know that there is more waiting for them.

00:01:02.880 --> 00:01:06.980
And finally we're going to do all this
while minimizing the impact on battery life.

00:01:06.980 --> 00:01:15.130
So in this presentation we're going to cover the basics on
how to push sounds, badges, and alerts across the service,

00:01:15.129 --> 00:01:20.099
server protocols and certificates, as well as some best
practices and some advanced troubleshooting techniques.

00:01:20.099 --> 00:01:29.239
So on the logistical side this service works both
over cell and WiFi connections and it's available free

00:01:29.239 --> 00:01:31.949
to any member of the iPhone Development Program.

00:01:31.950 --> 00:01:36.850
Now this is huge, you don't need to deal with carriers,
you don't need to get any advanced certifications.

00:01:36.849 --> 00:01:40.439
Right out of the box you can start
sending notifications across the service.

00:01:40.439 --> 00:01:45.349
And finally, using this service is incredibly easy.

00:01:45.349 --> 00:01:48.640
All of you are going to be able
to send notifications to iPhones.

00:01:48.640 --> 00:01:50.900
So let's cover some background.

00:01:50.900 --> 00:01:59.230
iPhone OS 3.0 maintains one persisting connection
from the device to the Apple Push Notification Service

00:01:59.230 --> 00:02:06.390
and this single connection is used by all applications
on the iPhone to receive notifications from the service.

00:02:06.390 --> 00:02:10.080
This centralized design preserves battery life as well

00:02:10.080 --> 00:02:14.620
as maximizes the performance of the
Apple Push Notification Service.

00:02:14.620 --> 00:02:20.009
To start using this service you're
going to need a few things.

00:02:20.009 --> 00:02:21.849
First you're going to need a server.

00:02:21.849 --> 00:02:27.579
Now it's important to understand the notifications that
are sent from a service that is external to the service

00:02:27.580 --> 00:02:31.890
and is simply passed through the service down to the iPhone.

00:02:31.889 --> 00:02:37.319
Next, you're going to need a certificate that
uniquely identifies your application to the service.

00:02:37.319 --> 00:02:42.289
And finally you'll need a new provisioning
profile that test your applications on the iPhone

00:02:42.289 --> 00:02:46.229
when you're debugging them and developing them

00:02:46.229 --> 00:02:51.479
So once you have all these things, you can
start sending notifications across the service.

00:02:51.479 --> 00:02:54.560
Doing so involves four simple steps.

00:02:54.560 --> 00:03:01.229
So first your iPhone application on the
iPhone needs to tell iPhone OS that you wish

00:03:01.229 --> 00:03:04.289
to start receiving notifications from the service.

00:03:04.289 --> 00:03:10.530
It does this by using UIKit API that in turn tells the
Apple Push Notification Service that a given instance

00:03:10.530 --> 00:03:15.590
of your application on a specific
device wishes to receive notifications.

00:03:16.990 --> 00:03:23.590
Second, once you've successfully registered your application
receives something back that's called the device token

00:03:23.590 --> 00:03:26.719
which uniquely identifies your device to the service.

00:03:26.719 --> 00:03:32.280
You then communicate this token to your
server where your server associate this token

00:03:32.280 --> 00:03:35.069
with the unique user of your application.

00:03:35.069 --> 00:03:41.139
Later you'll use this token to start
sending notifications to the service.

00:03:41.139 --> 00:03:45.369
Step 3, your server sends those
notifications using that device token.

00:03:45.370 --> 00:03:54.270
And finally step 4, iPhone OS receives those notifications,
displays the sounds, badges, and alerts that you send

00:03:54.270 --> 00:03:56.740
in the notification payload on the iPhone OS.

00:03:56.740 --> 00:04:01.010
So let's look at step 1 in detail.

00:04:01.009 --> 00:04:05.719
[ Pause ]

00:04:05.719 --> 00:04:11.560
>> So step 1 is pretty simple, use the
UIKit API on the device in your application,

00:04:11.560 --> 00:04:14.740
tell iPhone OS that you want to register for notifications.

00:04:14.740 --> 00:04:22.250
To do this step all you need to do is call UIApplication
registerForRemoteNotificationTypes passing the types

00:04:22.250 --> 00:04:25.930
of notifications that you wish to receive on the device.

00:04:25.930 --> 00:04:31.009
Once you've done this step you will receive
one of two different delegate callbacks.

00:04:31.009 --> 00:04:34.699
The first if you succeed is UIApplicationDelegate
application

00:04:34.699 --> 00:04:38.550
didRegisterForRemoteNotificationsWithDeviceToken.

00:04:38.550 --> 00:04:40.740
Now you get back that opaque device token, an NS data

00:04:40.740 --> 00:04:46.750
that uniquely identifies the current device
to the Apple Push Notification Service.

00:04:46.750 --> 00:04:54.420
But if you fail you'll get UIApplicationDelegate application
didFailToRegisterForRemoteNotificationsWithError.

00:04:54.420 --> 00:04:59.319
In this case it will only happen if you have
provisioning profile troubles or bad entitlements,

00:04:59.319 --> 00:05:02.279
or if you're using the iPhone Simulator
because we don't have support

00:05:02.279 --> 00:05:05.119
for the Push Notification Service in the Simulator.

00:05:05.120 --> 00:05:08.220
So just fix whatever is wrong with
your provisioning profile entitlements,

00:05:08.220 --> 00:05:11.980
reregister and you'll get back the first callback.

00:05:13.230 --> 00:05:19.280
So once you've succeeded and got that device token, as
I mentioned this device token is a unique identifier

00:05:19.279 --> 00:05:24.129
which identifies the current device to
the Apple Push Notification Service.

00:05:24.129 --> 00:05:28.110
But one thing to note, if it is
distinct from UIDevice deviceIdentifier

00:05:28.110 --> 00:05:34.069
because unlike the deviceIdentifier the Apple Push
Notification Service device token gets erased whenever the

00:05:34.069 --> 00:05:36.399
device is wiped for security reasons.

00:05:36.399 --> 00:05:42.449
And finally if you don't have the token and memory
just use the registration API to get the token.

00:05:42.449 --> 00:05:44.729
There is no cost in calling the registration API.

00:05:44.730 --> 00:05:46.620
Call as many times as you want.

00:05:46.620 --> 00:05:49.850
Don't store it in your documents or preferences
because we don't want it getting out of date

00:05:49.850 --> 00:05:52.590
with what the iPhone OS has for the device token.

00:05:52.589 --> 00:05:59.679
There's a couple other optional delegates
and callbacks you might want to implement.

00:05:59.680 --> 00:06:05.689
The first is UIApplicationDelegate
application:didReceiveRemoteNotification.

00:06:05.689 --> 00:06:11.170
Now you'll use this notification if you want to receive
notifications when your application is already running

00:06:11.170 --> 00:06:16.280
since if your app is already running, iPhone
OS does nothing for these notifications.

00:06:16.279 --> 00:06:20.549
Instead use these callbacks to get that payload
that you sent and display some type of UI

00:06:20.550 --> 00:06:24.310
to let the users know that notification was received.

00:06:24.310 --> 00:06:32.290
Also we have a method as opposed to a delegate callback
called UIApplication enabledRemoteNotificationTypes

00:06:32.290 --> 00:06:39.600
which is a method to let you see what types of notifications
the user has elected to receive in the centralized settings.

00:06:39.600 --> 00:06:43.010
We'll talk about both of these more
in depth later in the presentation.

00:06:43.009 --> 00:06:48.620
[ Pause ]

00:06:48.620 --> 00:06:55.230
>> So at step 2, you take that device token that you
got after registering and you send it to your server

00:06:55.230 --> 00:07:00.629
where at your server, you associate it with a specific
user of your application because you'll later going to need

00:07:00.629 --> 00:07:03.480
that token to send notifications to the service.

00:07:03.480 --> 00:07:09.080
Now one very important thing about step
2 is that step 2 is completely up to you.

00:07:09.079 --> 00:07:15.620
iPhone OS does no part of this step for you so using
whatever means you want, send this token to your server.

00:07:15.620 --> 00:07:18.639
That's all there is for step 2.

00:07:18.639 --> 00:07:22.060
Now at step 3, this is where it gets interesting.

00:07:22.060 --> 00:07:28.480
Step 3 is where you start sending notifications from
your server to the Apple Push Notification Service.

00:07:28.480 --> 00:07:32.590
But before we talk about how to send notifications,

00:07:32.589 --> 00:07:36.949
I want to make sure that everyone
here is familiar with what JSON is.

00:07:36.949 --> 00:07:42.240
So JSON as many of you know is short for JavaScript
Object Notation but you don't need to know

00:07:42.240 --> 00:07:46.420
or write any JavaScript to use
the push notification service.

00:07:46.420 --> 00:07:51.270
So it's a Java-- it's an object notation that derives
from JavaScript but it's also a human readable,

00:07:51.269 --> 00:07:56.930
compact in architectural neutral way to
represent Cocoa property lists such as NSDatas,

00:07:56.930 --> 00:08:00.400
NSStrings, NSDictionaries, and NSNumbers.

00:08:00.399 --> 00:08:06.339
We're going to be using JSON payloads to represent the
payloads that we sent across the push notification service.

00:08:06.339 --> 00:08:12.269
So here is a typical JSON payload.

00:08:12.269 --> 00:08:20.859
As I mentioned it needs to be strict JSON but also Apple
Push Notification Service device tokens are limited

00:08:20.860 --> 00:08:23.310
to 256 bytes per notification.

00:08:23.310 --> 00:08:31.569
So at the top level of this dictionary
there is a dictionary called aps.

00:08:31.569 --> 00:08:36.220
This contains the alert, badge, and sounds
keys that iPhone OS displays on behalf

00:08:36.220 --> 00:08:40.360
of your application when your application is not running.

00:08:40.360 --> 00:08:44.360
Outside of this dictionary is reserved for your
app, put whatever keys you want in there as long

00:08:44.360 --> 00:08:48.279
as they are valid JSON and under the 256 byte limit.

00:08:48.279 --> 00:08:51.519
So let's look at these keys in depth.

00:08:54.149 --> 00:08:58.919
The badge key is an integer value
in the JSON APS dictionary.

00:08:58.919 --> 00:09:02.009
When you pass a badge you'll see on your applications icon

00:09:02.009 --> 00:09:06.379
on the home screen the red badge that
are used when getting unread mail.

00:09:06.379 --> 00:09:13.629
This is the same as the UIApplication application icon
badge number property that you've used in iPhone OS 2.0.

00:09:13.629 --> 00:09:17.939
So if you pass a positive number here, it will
display a badge on your applications icon.

00:09:17.940 --> 00:09:23.000
But if you pass any other type of value or
omit the value entirely from the dictionary,

00:09:23.000 --> 00:09:26.110
will remove the badge from your applications icon.

00:09:28.570 --> 00:09:32.740
The sound key is a string value which is one of two things.

00:09:32.740 --> 00:09:39.720
Either it's the name of the file in your applications
bundle or it's the system wide reserved key default

00:09:39.720 --> 00:09:42.980
which they're non-configurable default sound.

00:09:42.980 --> 00:09:48.259
If you choose to put a sound file in your applications
bundle it needs to be of a supported format.

00:09:48.259 --> 00:09:56.439
Those formats are only linear PCM, MA4, uLaw and aLaw
but not MP3, AAC or other perceptual encoding formats

00:09:56.440 --> 00:10:00.730
since we don't want to interrupt music playback
if the user is already listening to music.

00:10:00.730 --> 00:10:03.860
We also handle vibration automatically.

00:10:03.860 --> 00:10:08.950
If the ringer switch on the device is set to vibrate we'll
simply vibrate the device any time we see a sound key

00:10:08.950 --> 00:10:10.320
at all.

00:10:12.610 --> 00:10:19.279
>> So alerts can be either strings or dictionaries but
the most common format we expect to see are strings.

00:10:19.279 --> 00:10:23.579
We'll take the string you pass for alert and
use it to create the body of an alert message

00:10:23.580 --> 00:10:28.580
on the iPhone home screen, or if your phone
is locked in the slide to unlock screen.

00:10:28.580 --> 00:10:33.770
But as I mentioned there is also a
dictionary format which can be used

00:10:33.769 --> 00:10:37.159
to localize either the alert body or the View button.

00:10:37.159 --> 00:10:44.730
So if you pass the loc-key or loc-args keys in
your JSON payload, we'll look up the loc-key value

00:10:44.730 --> 00:10:49.430
in your applications Localizable.strings
file in your apps bundle.

00:10:49.429 --> 00:10:54.750
That way you can pass a value in a specific language for
each language that you support and we'll look at that key,

00:10:54.750 --> 00:10:59.789
substituting the loc-args key into that
string to display a localized alert.

00:10:59.789 --> 00:11:04.879
For example, if in your Spanish
Localizable.strings file you have this string,

00:11:04.879 --> 00:11:09.500
we'll substitute in "Jen" and "iPhone" to create this alert.

00:11:12.090 --> 00:11:17.379
So we do this substitution the same way that
you do it both on the Mac and on the rest

00:11:17.379 --> 00:11:22.389
of iPhone OS using NSLocalizedString
and NSString stringWithFormat.

00:11:22.389 --> 00:11:26.830
That is arguments can be ordered by localizers
using the same macros that you're used to

00:11:26.830 --> 00:11:34.230
and we use the current system language to choose the
right Localizable.strings file out of your apps bundle.

00:11:34.230 --> 00:11:37.600
If you're new to localizing strings, check out
the rest of our resources that we have online

00:11:37.600 --> 00:11:43.420
and the other sessions we have on localization
because a lot of these concepts are shared.

00:11:43.419 --> 00:11:49.179
Also, one thing to note is that since you're sending in
this case the localized string key as opposed to the value

00:11:49.179 --> 00:11:53.609
across the wire, you want to keep your localized
string key short 'cause that's what counts

00:11:53.610 --> 00:11:58.159
against your 256 byte per notiVfication size limit.

00:12:00.970 --> 00:12:06.550
As I mentioned you can also customize the View button
but we refer to the View button as the Action button

00:12:06.549 --> 00:12:11.889
because tapping that button takes some type
of action such as launching your application.

00:12:11.889 --> 00:12:18.750
So if you pass the key, action-loc-key in your
JSON dictionary inside the alert dictionary,

00:12:18.750 --> 00:12:22.549
will display whatever the value
that Localizable.string key is

00:12:22.549 --> 00:12:26.059
in your current language as the
View button on the iPhone OS.

00:12:26.059 --> 00:12:31.419
So say PLAY_KEY maps the Play in the current language
which is English, you will see this alert instead.

00:12:31.419 --> 00:12:38.099
But say you are sending notification alerts that are
strictly informative and there is no action to be taken

00:12:38.100 --> 00:12:40.580
at all, and you just want to remove the View button.

00:12:40.580 --> 00:12:45.259
You can do that by passing the JSON
primitive null, which looks like this,

00:12:45.259 --> 00:12:55.049
as the action-loc-key inside your alert
dictionary and you will get this as a result.

00:12:55.049 --> 00:13:01.839
So here's a typical JSON payload, it weighs at 150
bytes, pretty standard, all the keys you expect to see

00:13:01.840 --> 00:13:05.230
in a normal notification message, even some custom app data.

00:13:05.230 --> 00:13:11.289
But by changing our JSON emitter or by simply
stripping the whitespace after we've output the JSON,

00:13:11.289 --> 00:13:16.969
we can bring this payload down to 96 bytes, which
is over a 50 percent improvement in space savings.

00:13:16.970 --> 00:13:22.100
Now stripping the whitespace helps go a long way
towards avoiding those per notification size limits

00:13:22.100 --> 00:13:26.399
in almost every case so we really
recommend that you do this.

00:13:26.399 --> 00:13:29.949
So that concludes the device side
of step 3, sending notifications.

00:13:29.950 --> 00:13:34.070
Here to talk about the server side
is my partner in crime, Kris Bell.

00:13:34.070 --> 00:13:34.460
Thank you.

00:13:34.460 --> 00:13:35.930
[ Applause ]

00:13:35.929 --> 00:13:38.969
>> Good afternoon everybody my name is Kris Bell.

00:13:38.970 --> 00:13:45.370
And for the next 25 minutes I'm going to lead
you through the Apple Push Notification Service

00:13:45.370 --> 00:13:49.539
from the perspective of the server itself.

00:13:49.539 --> 00:13:56.459
So if you are wondering why SSL certificates are important
to the service or perhaps you are wondering if it's cool

00:13:56.460 --> 00:14:00.870
to have multiple concurrent connection
open to the service at the same time,

00:14:00.870 --> 00:14:03.730
great because that's what I'm going to talk about.

00:14:03.730 --> 00:14:10.129
There's a couple of assumptions that I'm going to make.

00:14:10.129 --> 00:14:16.409
First assumption is that as developers you guys
know how to get your application on to the iPhone.

00:14:16.409 --> 00:14:24.949
And based on the APIs that Chris Marcellino just talked
about, you know how to get the token from that device,

00:14:24.950 --> 00:14:29.840
send it to your content server to register the device.

00:14:29.840 --> 00:14:38.110
Now, making those assumptions there are two things you're
going to need in order to be able to talk to the service.

00:14:38.110 --> 00:14:44.610
The first one is you will need an X.509 SSL certificate.

00:14:44.610 --> 00:14:49.659
You get this from the iPhone Developer Program portal.

00:14:50.970 --> 00:14:56.870
If you have one application, you
will have one SSL certificate.

00:14:56.870 --> 00:15:02.370
If you have five applications, you
will have five SSL certificates.

00:15:02.370 --> 00:15:08.149
There is a one-to-one relationship between
an application and an SSL certificate.

00:15:08.149 --> 00:15:18.289
Chris Marcellino just described the message payload, it's a
JSON payload, and I'm going to talk a little bit about that

00:15:18.289 --> 00:15:23.349
as we go through and point out some highlights.

00:15:23.350 --> 00:15:26.090
So why is an SSL certificate important to the service?

00:15:26.090 --> 00:15:31.920
Well, it represents your service identity.

00:15:31.919 --> 00:15:35.659
It's unique to your application.

00:15:38.379 --> 00:15:45.439
It establishes trust between you as a
developer and Apple, so you should keep it safe.

00:15:45.440 --> 00:15:52.100
For example, let's suppose that I'm a developer and have
an application and I have myself a service identity.

00:15:52.100 --> 00:16:01.340
Perhaps it would be unwise of me to give my service
identity to my scheming and brooding 13-year-old nephew

00:16:01.340 --> 00:16:04.910
who has got an unhealthy appetite for hacking into systems.

00:16:04.909 --> 00:16:13.259
Probably it will be also unwise for me to take my SSL
certificate on a little memory stick here and take it

00:16:13.259 --> 00:16:17.879
down to the local pub with me, leave it
on the counter after a couple of drinks.

00:16:17.879 --> 00:16:22.559
The reason why it would be unwise to do so is the following.

00:16:22.559 --> 00:16:31.619
Apple reserves the right to revoke certificates that are
being used to abuse the service, so keep your own safe.

00:16:31.620 --> 00:16:43.279
Now as Chris described the message payloads
are JSON and there's a 256 byte maximum.

00:16:43.279 --> 00:16:49.569
I'm going to tell you in a moment or two what happens
when you go across, when you go above that limit.

00:16:49.570 --> 00:16:52.240
What I'd like to point out with this particular slide is

00:16:52.240 --> 00:16:58.830
that you should avoid embedding sensitive
user information in your payload.

00:16:58.830 --> 00:17:06.940
It seems obvious but don't put social security numbers
inside your message payloads and like this slide here,

00:17:06.940 --> 00:17:08.950
don't put credit card numbers in the payloads.

00:17:08.950 --> 00:17:11.009
It's just not a good idea.

00:17:11.009 --> 00:17:15.960
[ Pause ]

00:17:15.960 --> 00:17:18.529
>> So let's talk about how the service actually operates.

00:17:18.529 --> 00:17:26.000
To do so, I'd like to illustrate with what I
think is a killer application for the iPhone.

00:17:26.000 --> 00:17:28.519
Let me describe that to you.

00:17:28.519 --> 00:17:37.400
So you have an iPhone here and when you touch the screen
in various discreet points and at the same time you blow

00:17:37.400 --> 00:17:46.259
into the microphone, the iPhone emits a whole series
of yelps, yowls, yarrs, grunts, burps, belches.

00:17:46.259 --> 00:17:52.109
It's awesome, it's a great application
right, it's called iGrunt.

00:17:52.109 --> 00:17:54.359
All my friends love it, they think it's fantastic.

00:17:54.359 --> 00:17:59.119
Chris Marcellino has it installed
on his phone too, great stuff.

00:17:59.119 --> 00:18:06.089
My dilemma though is that I don't know
how to make it better for version 2?

00:18:06.089 --> 00:18:11.319
Well one thing I could do is to enable push notifications.

00:18:11.319 --> 00:18:17.779
And by doing so I could send a message to
Chris Marcellino, perhaps a really loud burp,

00:18:17.779 --> 00:18:24.859
when I know for a fact that he is in an important meeting
with Scott Forstall or perhaps he is having dinner

00:18:24.859 --> 00:18:27.079
with his girlfriend's parents or something like that.

00:18:27.079 --> 00:18:30.139
That will be great.

00:18:30.140 --> 00:18:39.730
I should point out that this is perhaps the most, perhaps
not the most valid use of this service but it's fun.

00:18:39.730 --> 00:18:45.420
OK, so the first thing that I would need to
do, I would need to update my application

00:18:45.420 --> 00:18:48.519
with the APIs that Chris Marcellino described.

00:18:48.519 --> 00:18:55.950
The second thing I need to do is to get an SSL
certificate from the iPhone Developer Program portal.

00:18:55.950 --> 00:19:02.840
And once I have my certificate from
the portal it is out of the picture,

00:19:02.839 --> 00:19:06.639
it's gone at that point, don't
have to worry about it anymore.

00:19:06.640 --> 00:19:18.600
So then I exchange my SSL certificate with the Apple Push
Notification Service and I establish a secure SSL connection

00:19:18.599 --> 00:19:23.519
between my server, my iGrunt server and
the Apple Push Notification Service.

00:19:23.519 --> 00:19:36.650
Now the phone, the iPhone OS 3.0 also has an appropriate
SSL certificate for the Push Notification Service.

00:19:36.650 --> 00:19:44.870
So that when Chris Marcellino turns his
phone on it also exchanges certificates

00:19:44.869 --> 00:19:51.429
with the Apple Push Notification Service
and establishes a secure SSL connection.

00:19:51.430 --> 00:19:58.370
Great, now at that point my iGrunt server
can start sending messages to Chris' phone.

00:19:58.369 --> 00:20:01.049
This is where the interesting thing happens.

00:20:01.049 --> 00:20:11.730
How does the phone now which application to associate
with the particular message that just came in?

00:20:11.730 --> 00:20:16.450
Well we talked a little bit earlier about
how there's a one-to-one relationship

00:20:16.450 --> 00:20:20.360
between an application and an SSL certificate.

00:20:20.359 --> 00:20:26.719
There's this little bit of information that's
shared between the application and the certificate

00:20:26.720 --> 00:20:29.360
and that information is called a bundle ID.

00:20:29.359 --> 00:20:34.009
There is a unique bundle ID for
every application on the phone.

00:20:34.009 --> 00:20:39.539
[ Pause ]

00:20:39.539 --> 00:20:42.289
>> So you have your certificate, what happens next?

00:20:42.289 --> 00:20:47.180
Well you need to open up an SSL connection
to the service as I just described.

00:20:47.180 --> 00:20:51.940
The easiest way to do that is to
get up on to the developer forums

00:20:51.940 --> 00:20:54.769
and check out all the example code
that those guys have written.

00:20:54.769 --> 00:20:56.490
It's fantastic.

00:20:56.490 --> 00:20:58.390
Developer forum has been just wonderful.

00:20:58.390 --> 00:21:04.130
The guys up there, they've been writing examples
of how to do this in all kinds of languages.

00:21:04.130 --> 00:21:10.480
There are examples in Ruby, in Python,
and Perl, in C#, Java, you name it.

00:21:10.480 --> 00:21:12.730
There are examples up there in all kinds of language.

00:21:12.730 --> 00:21:15.809
Get on-line, check it out, it's awesome.

00:21:19.049 --> 00:21:24.509
You can also establish multiple connections
to the service at the same time if you wish.

00:21:24.509 --> 00:21:26.680
Now, why would you want to do that?

00:21:26.680 --> 00:21:32.110
Well, let's suppose for a moment
you're a big content provider.

00:21:32.109 --> 00:21:36.839
You have a big cluster of machines, 30,
40, 50, 100 machines, whatever it is.

00:21:36.839 --> 00:21:44.419
It would be inconvenient if each of those machines in the
cluster had to share a single connection to the service.

00:21:44.420 --> 00:21:50.590
So if you have a service you have a content
provision in service like that, by all means,

00:21:50.589 --> 00:21:53.129
open up multiple connections to the service.

00:21:53.130 --> 00:21:54.930
It's not a problem.

00:21:54.930 --> 00:22:01.960
However, if you just have the one server,
you really only need one connection.

00:22:01.960 --> 00:22:11.360
And the reason for that is that a single connection is
more than capable of consuming all of your uplink bandwidth

00:22:11.359 --> 00:22:18.359
to the Apple Push Notification Service, it's very efficient.

00:22:18.359 --> 00:22:24.209
Whether you have one connection open to the service or
whether you have 50 connections open to the service,

00:22:24.210 --> 00:22:29.680
the important thing to do is make sure you
keep those connections open at all times.

00:22:29.680 --> 00:22:32.440
And we'll talk about that a little more in a moment.

00:22:32.440 --> 00:22:41.509
So then the next step is to construct your message in the
fashion that Chris described earlier and then you send it

00:22:41.509 --> 00:22:46.660
over your open connection, construct another
message and send it over to that connection.

00:22:46.660 --> 00:22:48.870
It's really straightforward.

00:22:48.869 --> 00:22:51.989
Let's talk about those persistent
connections and why you should keep them open.

00:22:51.990 --> 00:22:58.539
Well, the worst thing that you could do to
the service is to open up just one connection,

00:22:58.539 --> 00:23:01.599
send one message on it and then close the connection again.

00:23:01.599 --> 00:23:06.899
That would be bad and could be
mistaken for a denial of service type.

00:23:06.900 --> 00:23:10.820
So keep those connections open.

00:23:10.819 --> 00:23:20.049
Now it is possible that the Apple Push Notification
Service might actually sever your connection instead.

00:23:20.049 --> 00:23:22.730
When would that happen?

00:23:22.730 --> 00:23:28.319
Well let's suppose that you sent a
completely bogus token to the service.

00:23:28.319 --> 00:23:30.649
Well, it would cut your connection right at that point.

00:23:30.650 --> 00:23:36.410
It's a good indication to you that something went wrong.

00:23:36.410 --> 00:23:43.300
Also, if you send a message payload that
is greater than that 256 byte limit,

00:23:43.299 --> 00:23:46.839
Apple Push Notification Service will sever your connection.

00:23:46.839 --> 00:23:48.949
That's an indication that something is wrong.

00:23:48.950 --> 00:23:52.830
Now check that, fix it, and open up the connections again.

00:23:52.829 --> 00:23:54.740
There are a couple of exceptions here.

00:23:54.740 --> 00:24:01.859
Let's suppose that you're maintaining persistent
connections but you just haven't sent anything over the wire

00:24:01.859 --> 00:24:06.049
for an extended period of time, say 2 hours or whatever.

00:24:06.049 --> 00:24:13.769
It is possible you could get a TCP/IP timer
and that would also cut your connection.

00:24:13.769 --> 00:24:15.519
If that happens then don't worry about it.

00:24:15.519 --> 00:24:21.119
Just open up another connection as
necessary and keep the connection open.

00:24:23.930 --> 00:24:26.570
Let's talk for a minute about the protocol itself.

00:24:26.569 --> 00:24:29.639
It's a binary protocol.

00:24:29.640 --> 00:24:35.370
It's very, very high throughput and low overhead
which is great for your servers because it means

00:24:35.369 --> 00:24:38.459
that they're used most-- your uplink
is used most efficiently.

00:24:38.460 --> 00:24:41.029
There's also a streaming protocol.

00:24:41.029 --> 00:24:47.139
And what that means primarily is that
you do not get a response for every-

00:24:47.140 --> 00:24:49.730
and each message that you send to the service.

00:24:49.730 --> 00:24:55.400
It's very simple format so let's take a look at that now.

00:24:55.400 --> 00:24:58.090
It starts off with the 0 byte header.

00:24:58.089 --> 00:25:02.099
The next field of interest is the device token.

00:25:02.099 --> 00:25:06.069
That is the device that you are going to send a message to.

00:25:06.069 --> 00:25:10.990
And the last field up there is the actual JSON payload.

00:25:10.990 --> 00:25:13.130
It's a very short one we see up there.

00:25:13.130 --> 00:25:15.850
The second field and sorry, I beg your pardon.

00:25:15.849 --> 00:25:21.069
The third field and the fifth fields
are prefixed with a 2-byte length field.

00:25:21.069 --> 00:25:22.460
It's very straightforward.

00:25:22.460 --> 00:25:31.410
Now let's suppose for a minute that Chris Marcellino
really is having dinner with his girlfriend's parents

00:25:31.410 --> 00:25:36.630
and he's turned his phone off because he
doesn't want to get any messages from me.

00:25:36.630 --> 00:25:39.830
What happens when I send messages to him at that point?

00:25:39.829 --> 00:25:48.389
Well, the Apple Push Notification Service has the store
and forward redelivery mechanism and there are a couple

00:25:48.390 --> 00:25:52.650
of things that I'd like to press with regards to that.

00:25:52.650 --> 00:26:00.870
The first thing is the store and forward
mechanism stores just one message per application.

00:26:00.869 --> 00:26:08.709
So if my iGrunt application sends two messages
to Chris' phone and his phone is offline,

00:26:08.710 --> 00:26:14.970
only that second message will be retained and
subsequently sent to his phone when it comes back online.

00:26:14.970 --> 00:26:23.150
However, if Chris' phone is offline for an
extended period of time, it is possible that both

00:26:23.150 --> 00:26:25.509
of those messages that I sent to him will expire.

00:26:25.509 --> 00:26:35.759
Another thing that I'd like to press home about
redelivery service is that it is a best attempt delivery.

00:26:35.759 --> 00:26:37.490
It's just like SMS in that regard.

00:26:37.490 --> 00:26:45.440
And what that really means is that if there's a huge
earthquake and a bunch of hard drives are swallowed

00:26:45.440 --> 00:26:51.009
up into this great big hole in the ground then some
of those messages probably won't get delivered.

00:26:51.009 --> 00:26:56.750
[ Pause ]

00:26:56.750 --> 00:26:58.200
>> So let's just imagine for a moment

00:26:58.200 --> 00:27:05.809
that for some unfathomable reason Chris
Marcellino uninstalls my iGrunt application.

00:27:05.809 --> 00:27:10.000
What happens when I start to send messages to him?

00:27:10.000 --> 00:27:19.019
Well, sadly, I-- the application, my iGrunt
application can't call home and unregister at the time

00:27:19.019 --> 00:27:26.099
when it's actually uninstalled because the phone
may be in airplane mode or out of service range.

00:27:26.099 --> 00:27:29.089
So what do we do?

00:27:29.089 --> 00:27:38.609
The Apple Push Notification Service has
a feedback mechanism that records events

00:27:38.609 --> 00:27:42.329
when messages are sent to uninstalled applications.

00:27:42.329 --> 00:27:54.129
So you should call this on a regular basis, let's say
once a day or more often and it operates just like--

00:27:54.130 --> 00:27:59.120
it operates in the same fashion as when you're
going to-- as when you're going to send messages.

00:27:59.119 --> 00:28:05.129
So you connect to it with the same SSL certificate
as you do when you're going to send messages.

00:28:05.130 --> 00:28:09.190
The distinction is that you connect to a different host.

00:28:09.190 --> 00:28:14.200
Another distinction is that as soon
as you initiate the connection,

00:28:14.200 --> 00:28:20.140
the feedback service starts sending data
back to you in the form of binary records.

00:28:20.140 --> 00:28:23.960
When it's finished, it will sever the connection.

00:28:23.960 --> 00:28:28.269
That's an indication to you of
course that there is no more data.

00:28:28.269 --> 00:28:33.750
Let's take a look at that right now.

00:28:33.750 --> 00:28:36.829
The first 4 bytes represent a UNIX timestamp.

00:28:36.829 --> 00:28:40.449
That is the number of seconds since 1970.

00:28:40.450 --> 00:28:43.730
It is anchored to UTC time zone.

00:28:43.730 --> 00:28:49.160
The third field represents the device token.

00:28:49.160 --> 00:28:54.019
This is the device upon which your
application has been uninstalled.

00:28:54.019 --> 00:28:56.619
You should no longer send messages to that device.

00:28:56.619 --> 00:29:00.359
It's also prefixed with a 2-byte length field.

00:29:00.359 --> 00:29:06.609
Now it's quite possible that you query the service,
the feedback service, and you get no responses at all.

00:29:06.609 --> 00:29:07.939
Well, great.

00:29:07.940 --> 00:29:15.220
That means that nobody has uninstalled your
application since the last time you queried the service.

00:29:15.220 --> 00:29:21.549
OK, now I'm sure some of you in the audience probably
have some questions about the scalability of the service.

00:29:21.549 --> 00:29:26.919
Maybe you're wondering how many messages
you can send to it over a period of time.

00:29:26.920 --> 00:29:30.380
Well I'd like to try to address that with a short video.

00:29:32.119 --> 00:29:35.259
Now it's not necessarily easy to
demonstrate a backend server.

00:29:35.259 --> 00:29:43.049
So what we try to do is to get-- give it a face.

00:29:43.049 --> 00:29:47.669
And the face that we've given this backend service
is in the form of what you see on the screen.

00:29:47.670 --> 00:29:51.090
In fact, there are actually three applications running here.

00:29:51.089 --> 00:29:56.970
The first application represents
millions or sorry an emulation of millions

00:29:56.970 --> 00:29:59.920
and millions and millions of virtual devices.

00:29:59.920 --> 00:30:04.410
There's virtual iPhones, virtual iPod Touches.

00:30:04.410 --> 00:30:10.470
The second application represents thousands
of developers like yourselves sending hundreds

00:30:10.470 --> 00:30:14.970
and thousands of messages to the service.

00:30:14.970 --> 00:30:20.860
>> So let's play that and take a look at what it does.

00:30:20.859 --> 00:30:29.839
Now as a message is sent to a particular device, this
third application picks up that message and represents it

00:30:29.839 --> 00:30:34.319
as a different color on a particular cube
and then that cube fades away overtime.

00:30:34.319 --> 00:30:39.259
So what you're seeing is a bunch of blinking
devices as they're receiving messages.

00:30:39.259 --> 00:30:41.319
This is a zoomable application

00:30:41.319 --> 00:30:45.159
So as you see as we zoom out of it,
you can see more and more devices.

00:30:45.160 --> 00:30:52.769
In fact, if we zoom all the way out, this
rendering starts to take on a more solid form

00:30:52.769 --> 00:30:55.700
because there are just so many virtual devices in there.

00:30:55.700 --> 00:30:59.600
There's actually about 10 million
virtual devices represented there.

00:30:59.599 --> 00:31:04.859
And it's on the order of a million messages
per second being sent to the service.

00:31:04.859 --> 00:31:15.669
Now if you as a developer have been using the production
system to send messages for the last few weeks,

00:31:15.670 --> 00:31:22.470
then you've been competing with not just one of these
emulations but several of them running currently.

00:31:22.470 --> 00:31:27.579
So you've been competing for the attention
of the service with tens of millions

00:31:27.579 --> 00:31:31.539
of devices and millions of messages per second.

00:31:31.539 --> 00:31:43.420
Now demos are great but the important thing is not
necessarily the demo itself but this critical aspect.

00:31:43.420 --> 00:31:50.000
There are no bottlenecks in the
Apple Push Notification Service.

00:31:50.000 --> 00:31:59.609
It is-- it has the characteristics of linear scalability
and what that means to you as developers is that as more

00:31:59.609 --> 00:32:05.669
and more devices are added overtime as the service
matures, more and more people start using it and more

00:32:05.670 --> 00:32:09.380
and more messages are sent to the
system, you don't have to worry

00:32:09.380 --> 00:32:13.990
about the performance characteristics degrading overtime.

00:32:17.250 --> 00:32:24.099
So with that, I'd like to go through four things that I'd
like you to take away from this segment of the presentation.

00:32:24.099 --> 00:32:29.519
The first, of course, is please
maintain persistent connections.

00:32:29.519 --> 00:32:32.349
Don't open up a connection, send one message, and close it.

00:32:32.349 --> 00:32:35.879
That would be bad.

00:32:35.880 --> 00:32:41.570
At some point, somebody would probably
uninstall your application.

00:32:41.569 --> 00:32:50.200
Please check the feedback service on a regular basis
daily and check to see if there are any devices

00:32:50.200 --> 00:32:53.390
to which you should no longer send messages.

00:32:54.430 --> 00:32:59.430
Thirdly, don't send sensitive information,
sensitive user information in your payloads.

00:32:59.430 --> 00:33:03.519
Don't send social security numbers,
credit card numbers, and so on.

00:33:03.519 --> 00:33:07.990
Last but not least, protect your service identity.

00:33:07.990 --> 00:33:16.279
It is your responsibility to ensure that your
service identity is not abused by somebody else.

00:33:16.279 --> 00:33:19.990
That concludes the section of the presentation.

00:33:19.990 --> 00:33:22.250
I'd like now to hand you back to Chris Marcellino.

00:33:22.250 --> 00:33:23.009
Thank you.

00:33:23.009 --> 00:33:31.940
[ Applause ]

00:33:31.940 --> 00:33:35.720
>> So Kris just covered the server
half of step 3, sending notifications.

00:33:35.720 --> 00:33:38.200
So let's talk about step 4.

00:33:38.200 --> 00:33:43.289
Step 4 is where iPhone OS receives these notifications
from the service and displays the badges, alerts,

00:33:43.289 --> 00:33:46.720
and sounds that you send your notification payload.

00:33:46.720 --> 00:33:52.880
So the most important thing to note
here is that iPhone OS does nothing

00:33:52.880 --> 00:33:56.320
with the notification if your application
is already running.

00:33:56.319 --> 00:33:57.490
This is important.

00:33:57.490 --> 00:33:59.420
If your app is already running, you're just going

00:33:59.420 --> 00:34:06.320
to get the UIApplicationDelegate application
didReceiveRemoteNotification callback, you should handle--

00:34:06.319 --> 00:34:11.529
implement this callback and handle it when you
receive notification so that your UI gets updated

00:34:11.530 --> 00:34:15.620
and gives you some contacts of the
notification that was just received.

00:34:15.619 --> 00:34:21.239
If you need to update your badge, do so using the
UIApplication application:iconBadgeNumberProperty

00:34:21.239 --> 00:34:24.649
because iPhone OS isn't going to do this for you.

00:34:24.650 --> 00:34:32.389
Also, play new sounds if you need to 'cause again,
the notification is not processed by the OS

00:34:32.389 --> 00:34:37.849
But if your app isn't running and you send an alert in
your notification payload and then the user tabs view

00:34:37.849 --> 00:34:42.279
on that alert, iPhone OS will launch
your application and call one

00:34:42.280 --> 00:34:46.019
of these two delegate callbacks to
give your application the payload.

00:34:46.019 --> 00:34:50.829
But first, if you implement it, it's
application:didFinishLaunchingWithOptions,

00:34:50.829 --> 00:34:55.219
you'll get the notification payload in the options
dictionary where then you should use it to bring the user

00:34:55.219 --> 00:35:00.419
to the part of your application that corresponds with the
alert that they just tab viewed on since you really want

00:35:00.420 --> 00:35:04.389
to give them some continuity from the
alert all the way into your application.

00:35:04.389 --> 00:35:10.339
Second, if you don't implement that after
your application has finished launching,

00:35:10.340 --> 00:35:19.120
we'll call application:didReceiveRemoteNotification
just to give you the alert anyway we can.

00:35:19.119 --> 00:35:25.779
So as Kris mentioned the store and forward redelivery
system in the Apple Push Notification Service stores

00:35:25.780 --> 00:35:29.000
at most one notification per application.

00:35:29.000 --> 00:35:34.599
What this means to you when receiving notifications is that
all of your notification should have the complete state

00:35:34.599 --> 00:35:39.469
because earlier notifications that you send
in a series may be overwritten on the service.

00:35:39.469 --> 00:35:44.559
So don't send a badge then later send an alert
and expect the badge to always be received

00:35:44.559 --> 00:35:47.429
because it might have been overwritten
if the device was offline.

00:35:47.429 --> 00:35:51.799
In send, in every alert you send be sure to
send the current badge in every notification

00:35:51.800 --> 00:35:55.370
and any alert if you still want them to be displayed.

00:35:55.369 --> 00:35:59.049
Don't assume that iPhone OS will
keep your badges around in that case.

00:35:59.050 --> 00:36:05.050
For the same reason though, iPhone OS has to assume
that older messages are now obsolete so what it does

00:36:05.050 --> 00:36:10.840
to help you is it clears any badges and alerts any time
it receives a notification without an alert or badge key

00:36:10.840 --> 00:36:16.340
so it has to assume that notifications may have been
dropped in the meantime and that those are now stale.

00:36:16.340 --> 00:36:20.680
This is the same reason that you can't increment
and decrement badges 'cause we don't want to rely

00:36:20.679 --> 00:36:23.489
on every notification being received
and you being off by one.

00:36:23.489 --> 00:36:29.569
So the take home point here is just send in every
notification the complete state your app has.

00:36:29.570 --> 00:36:32.350
We also have some Centralized Settings
in the Settings application

00:36:32.349 --> 00:36:35.500
on the iPhone which helps you control a few things.

00:36:35.500 --> 00:36:39.760
The first is we have a master switch which
let you disable notifications system-wide

00:36:39.760 --> 00:36:41.970
to save battery power, for example.

00:36:41.969 --> 00:36:46.429
And secondly, we have per-applications
settings to control sounds, alerts,

00:36:46.429 --> 00:36:50.539
and badge occasions on-- and badges on ?FYI basis.

00:36:50.539 --> 00:36:56.389
So the switches that you see here though only reflect what
types of notifications that your app elected to receive

00:36:56.389 --> 00:36:59.190
at registration time using the UIKit API.

00:36:59.190 --> 00:37:02.480
So be sure to pass the right types when
you register 'cause we want the settings

00:37:02.480 --> 00:37:05.539
to reflect what your apps are actually capable of to a user.

00:37:05.539 --> 00:37:10.650
So let's spend some time to talk about user experience.

00:37:10.650 --> 00:37:14.300
I know this is going to be an important
issue with push notifications.

00:37:14.300 --> 00:37:19.530
It's key to note that alerts are perhaps the
most intrusive type of notification you can send,

00:37:19.530 --> 00:37:23.640
so whenever it's appropriate, please
send badges and sounds instead.

00:37:23.639 --> 00:37:28.139
So let's look at each of these types in detail.

00:37:28.139 --> 00:37:32.750
Badges, we expect to be the most popular type
of notification that's send across the service.

00:37:32.750 --> 00:37:39.320
We think you should use badges for any type of actionable
information that you have like new unread messages,

00:37:39.320 --> 00:37:45.500
new friend requests, maybe new status alerts or if you have
a business app, maybe business action items or something.

00:37:45.500 --> 00:37:53.769
And because you're doing all of these when your app isn't
running, you need to keep a server-side count of the types,

00:37:53.769 --> 00:37:56.500
the number of action items that you
want to display in the iPhone OS.

00:37:56.500 --> 00:37:59.849
Now this is where it gets interesting 'cause it's--

00:37:59.849 --> 00:38:03.460
generally speaking, you want your app to be able
to work offline if that's something you support,

00:38:03.460 --> 00:38:06.900
but you might also have external source
of information so you need a handle

00:38:06.900 --> 00:38:12.079
on your server synchronizing all these sources of
truth about the number of remaining action items.

00:38:12.079 --> 00:38:14.009
So be sure to test your logic here.

00:38:14.010 --> 00:38:20.390
[ Pause ]

00:38:20.389 --> 00:38:25.849
>> Sounds are also really important because they give the
user context of the notification that was just received

00:38:25.849 --> 00:38:27.789
without actually looking at their iPhone.

00:38:27.789 --> 00:38:33.570
It can be in their pocket or in their purse and they'll
know exactly what application just sent them a notification.

00:38:33.570 --> 00:38:37.660
Now, think of all the great applications that
have really specific sounds on either Mac

00:38:37.659 --> 00:38:42.029
or PC that let's you know exactly what
application that notification is from.

00:38:42.030 --> 00:38:43.720
That's the type of sound we want you to use

00:38:43.719 --> 00:38:49.469
in your push notification alerts 'cause it lets
users know what app just sent them that notification.

00:38:49.469 --> 00:38:54.759
And to be specific these are generally branded sounds,
not really long ringtones or other obnoxious sounds,

00:38:54.760 --> 00:39:01.050
something that's short and sweet
and uniquely identifies your app.

00:39:01.050 --> 00:39:07.210
Also, since users might be listening to the
iPhone or iPod via headphones or via car stereo,

00:39:07.210 --> 00:39:10.470
it's really important that you
use a CDI or quality sound file.

00:39:10.469 --> 00:39:12.919
Don't, you know, record in your
garage and have your kids running

00:39:12.920 --> 00:39:16.210
around the background screaming,
probably not a good sound file to use.

00:39:16.210 --> 00:39:20.500
And finally, alerts.

00:39:20.500 --> 00:39:22.750
There is definitely some times
where you do want to use alerts

00:39:22.750 --> 00:39:25.880
that are totally appropriate to use alert notifications.

00:39:25.880 --> 00:39:32.780
For example, alerts that are totally worth knowing like the
chess match that you are currently playing is now your turn

00:39:32.780 --> 00:39:38.900
because your opponent just made a move, or
information that you completely need to know

00:39:38.900 --> 00:39:42.420
like this WWDC presentation just changed rooms.

00:39:42.420 --> 00:39:48.470
But just the same there's times when you don't want to
use alerts, they're are really bad to be sending alerts

00:39:48.469 --> 00:39:55.980
to your users, namely, information that you just don't need
to know like high scores in video games or other gimmicks,

00:39:55.980 --> 00:40:00.769
and information that's just strictly
too much like spam, advertising,

00:40:00.769 --> 00:40:02.889
and other nuisances that users don't want to see at all.

00:40:02.889 --> 00:40:08.569
'Cause if you send these, users are just going to
disable your app, the push notifications for your app

00:40:08.570 --> 00:40:12.480
in the Centralized Settings or worse,
uninstall your application entirely.

00:40:12.480 --> 00:40:15.630
So don't bombard them with alerts.

00:40:16.889 --> 00:40:21.230
>> Couple more best practices before we finish up.

00:40:21.230 --> 00:40:26.659
Since the device might be offline or out of service when
you send a notification, and if you send more than one,

00:40:26.659 --> 00:40:30.449
earlier notifications might be overwritten
on the service or the user, worse,

00:40:30.449 --> 00:40:33.859
might disable notifications for your app and settings.

00:40:33.860 --> 00:40:37.930
You have to assume that notification service
won't deliver every message to your phone.

00:40:37.929 --> 00:40:42.960
So be sure to connect to your server and pull down whatever
information you need when your application launches.

00:40:42.960 --> 00:40:47.849
Don't depend on the service sending
you a reliable stream of data.

00:40:47.849 --> 00:40:53.269
Also, every time you connect to your server, be sure to
upload that device token so it doesn't get out of sync due

00:40:53.269 --> 00:40:57.259
to some edge cases involving syncing
and backups and restoring.

00:40:57.260 --> 00:41:01.750
Also, as I mentioned earlier, don't store that
device token in your preferences or documents.

00:41:01.750 --> 00:41:06.320
Get it from the registration API and send it all
the way to your server every time you connect.

00:41:10.019 --> 00:41:12.900
So I want to also cover some troubleshooting tips.

00:41:12.900 --> 00:41:20.380
We have a great resource for debugging push notification
applications on the iPhone in the iPhone Console.

00:41:20.380 --> 00:41:25.430
So in Xcode, if you go to Window menu, Organizer,
choose the current device that you're using,

00:41:25.429 --> 00:41:29.179
and then choose the Console tab,
you'll see the iPhone Console.

00:41:29.179 --> 00:41:36.269
Here's where we log all sorts of information, errors related
to push notifications like JSON format errors, invalid keys,

00:41:36.269 --> 00:41:38.880
keys we can't parse, sound format errors, et cetera.

00:41:38.880 --> 00:41:42.140
So this is a great resource for debugging your application.

00:41:42.139 --> 00:41:44.949
I want to give you a couple of
examples of errors you might see here.

00:41:44.949 --> 00:41:50.919
Here's a typical JSON payload,
has a badge key and a sound key,

00:41:50.920 --> 00:41:55.490
but when you send this notification,
nothing happens at all in the iPhone.

00:41:55.489 --> 00:41:59.009
Instead of seeing the badge and hearing the sound, nada.

00:41:59.010 --> 00:42:03.450
So, of course, you check the iPhone Console
and you see Object value expected for key:

00:42:03.449 --> 00:42:05.980
aps; Trailing comma disallowed in object.

00:42:05.980 --> 00:42:10.889
Now, what this means is this spurious
comma you left in your JSON payload

00:42:10.889 --> 00:42:13.869
which makes this invalid JSON syntaxically per the standard.

00:42:13.869 --> 00:42:15.619
iPhone OS can't parse it.

00:42:15.619 --> 00:42:20.190
So what I got to do is remove that comma, resend
your notification and it starts working again.

00:42:20.190 --> 00:42:23.349
You get your badge and your sound, problem solved.

00:42:23.349 --> 00:42:25.909
So let's look at one more example.

00:42:25.909 --> 00:42:31.379
Here's another typical JSON payload
but this time no trailing comma

00:42:31.380 --> 00:42:35.160
which give you a badge and branded sound this time.

00:42:35.159 --> 00:42:41.719
But when you send this notification, you see the
badge and you hear a sound but not your branded sound.

00:42:41.719 --> 00:42:44.549
Instead you hear the system-wide default sound

00:42:44.550 --> 00:42:48.760
So you look in the iPhone Console
and you see this error message.

00:42:48.760 --> 00:42:53.350
No remote notification alert sound
file found for 'soundfileA.aiff'.

00:42:53.349 --> 00:42:55.170
Playing default sound.

00:42:55.170 --> 00:42:59.800
So you look in your application's build directory in
your Xcode project, you see the sound file in there,

00:42:59.800 --> 00:43:03.590
everything looks fine but still no, you know, sound.

00:43:03.590 --> 00:43:08.890
What you might not know though is that
iPhone OS uses a case sensitive file system.

00:43:08.889 --> 00:43:14.299
So since the case in the notification payload is
different from the case of your sound filename

00:43:14.300 --> 00:43:18.260
in your applications bundle, iPhone
OS can't find the sound file.

00:43:18.260 --> 00:43:22.850
So simply by correcting the capitalization that matched,
your problem is solved and you hear your branded sound file.

00:43:22.849 --> 00:43:27.679
Couple more troubleshooting tips.

00:43:27.679 --> 00:43:34.119
So that first error that we looked at is completely
avoidable if you use a JSON to create your payload--

00:43:34.119 --> 00:43:36.759
sorry, JSON library to create your payloads.

00:43:36.760 --> 00:43:42.820
Don't try hard recording at JSON or writing your own JSON
emitter because there are so many libraries either free

00:43:42.820 --> 00:43:45.960
or built-in to the various languages that you
are going to use that can do this for you,

00:43:45.960 --> 00:43:52.110
and having a library to do it is much more future proof
and easier to code with and avoid debugging hassles.

00:43:52.110 --> 00:43:55.849
If you need resources for where to get
these JSON libraries, check out JSON.org.

00:43:55.849 --> 00:44:00.039
They have tons of information and
information about the specs.

00:44:00.039 --> 00:44:04.679
As I mentioned in the previous slide, use
the console for debugging your applications.

00:44:04.679 --> 00:44:09.079
And finally there's one more thing we have for you today.

00:44:09.079 --> 00:44:15.210
You may have noticed that when debugging your application
after launching it from a URL such as from a web browser

00:44:15.210 --> 00:44:20.570
from another application, you might have found it hard
to debug what happens right after application launch

00:44:20.570 --> 00:44:23.440
because you weren't the one launching your application.

00:44:23.440 --> 00:44:28.119
Well we have this same problem in
iPhone OS 3.0 with push notifications

00:44:28.119 --> 00:44:31.489
when you're launching your applications
from the View button and alert.

00:44:31.489 --> 00:44:37.359
The Xcode team has added a new feature to iPhone OS 3.0 to
help you debug these situations and here to demonstrate this

00:44:37.360 --> 00:44:41.670
as well as to show you how to create a simple remote
notification app, is my teammate Justin Santamaria.

00:44:41.670 --> 00:44:42.420
Thank you.

00:44:42.420 --> 00:44:44.760
[ Applause ]

00:44:44.760 --> 00:44:49.330
>> Thanks Chris.

00:44:49.329 --> 00:44:55.529
Hi, my name is Justin Santamaria and I'm an
iPhone Applications Engineer for the iPhone team.

00:44:55.530 --> 00:44:59.750
I get the honor today of giving
a demonstration about what Chris

00:44:59.750 --> 00:45:03.329
and Kris have been talking about for the past hour or so.

00:45:03.329 --> 00:45:08.750
So, when I found out I was going to do this demo I had
to think about what kind of service I was going to do.

00:45:08.750 --> 00:45:14.980
I think one of the great uses of the push notification
service is going to be chat style applications

00:45:14.980 --> 00:45:21.519
or status update services and I was-- decided
to write my own service but I kind of think

00:45:21.519 --> 00:45:23.219
that the general ones are kind of locked up.

00:45:23.219 --> 00:45:25.019
There are some big players already.

00:45:25.019 --> 00:45:28.880
So I thought, you know, what do I like to do?

00:45:28.880 --> 00:45:32.640
Well, I like to complain and I like to complain a lot.

00:45:32.639 --> 00:45:38.980
And I was talking to my friends and it turns out that
they like to complain too though they may not admit it.

00:45:38.980 --> 00:45:43.469
So what I did is I wrote an app called
Squawker and I like to show you that now.

00:45:43.469 --> 00:45:48.369
So I'm going to go ahead and launch
this app and give you a quick tour.

00:45:48.369 --> 00:45:54.279
So here we do, we have the main screen here and we
have what you'd expect from status update applications.

00:45:54.280 --> 00:45:59.050
We've got an icon, we've got a
name, the latest status, and a date.

00:45:59.050 --> 00:46:03.269
No one is in a good mood today, it
looks fine but that's the point.

00:46:03.269 --> 00:46:05.849
We can go ahead and select the name here.

00:46:05.849 --> 00:46:12.449
We're going to select Chris and we see a nice big icon
for him, some bold text there with his latest status

00:46:12.449 --> 00:46:17.319
and the date and some history down there
of things he's squawked about before.

00:46:17.320 --> 00:46:22.190
Was there potato salad at lunch here?

00:46:22.190 --> 00:46:25.940
All right, so very simple application.

00:46:25.940 --> 00:46:30.119
It's only a couple of view controllers and I'd
like to show you what's under the hood here.

00:46:30.119 --> 00:46:36.130
OK. So like I said, we have a couple of view controllers.

00:46:36.130 --> 00:46:41.910
We have the root view controller and the detail view
controller that showed these two panels of the application.

00:46:41.909 --> 00:46:43.980
Now I'm not going to go into the view controllers right now.

00:46:43.980 --> 00:46:48.880
You can go ahead and check it-- and check the labs
throughout the conference as that's a big part

00:46:48.880 --> 00:46:51.750
of the iPhone OS view controller structure.

00:46:51.750 --> 00:46:56.150
What I am going to do is go ahead and
quickly peruse this account object.

00:46:56.150 --> 00:47:00.930
Now this account object is a thing
that connects to my Squawker server

00:47:00.929 --> 00:47:03.960
and it has username and password information.

00:47:03.960 --> 00:47:08.720
It also can get updates free for an
account which means it gets the list

00:47:08.719 --> 00:47:12.149
of the people I'm listening to squawk and whatnot.

00:47:12.150 --> 00:47:15.000
So it's important to note that for the purpose of this demo,

00:47:15.000 --> 00:47:20.610
this is the code that your app currently
has when communicating to your service.

00:47:20.610 --> 00:47:25.000
And now what I'd like to do is to take this
app and enable push notifications for it.

00:47:25.000 --> 00:47:30.079
[ Pause ]

00:47:30.079 --> 00:47:33.190
>> So I'm going to go ahead and go
to the application delegate here.

00:47:33.190 --> 00:47:35.380
In this case it's the Squawker App Delegate.

00:47:35.380 --> 00:47:36.950
Get a bigger view here.

00:47:36.949 --> 00:47:40.809
And we're going to notice there are a couple of methods.

00:47:40.809 --> 00:47:45.610
The one in particular that I'm interested
in is application didFinishLoading.

00:47:45.610 --> 00:47:47.620
Right now, it's pretty basic stuff.

00:47:47.619 --> 00:47:52.989
It simply sets up the window and whatnot
and then instantiates my model object,

00:47:52.989 --> 00:47:59.089
the account, and goes ahead and updates the account.

00:47:59.090 --> 00:48:02.970
In order to enable push notifications here all

00:48:02.969 --> 00:48:07.429
the first thing I need to do is go ahead
and register for remote notification types.

00:48:07.429 --> 00:48:12.629
Now in my particular app I thought about it and I
definitely want to sound because I want you to be able

00:48:12.630 --> 00:48:15.980
to hear it if it's in your pocket or purse.

00:48:15.980 --> 00:48:23.340
I did a badge because it'd be nice to have an
unread count of squawks and you know what it's--

00:48:23.340 --> 00:48:27.820
if I'm complaining I want to know-- I want you to know
what I'm complaining about when I complain about it.

00:48:27.820 --> 00:48:30.010
So I went ahead and I put in an alert.

00:48:30.010 --> 00:48:33.830
So it's going to show right up there
whenever someone squawks in my list.

00:48:33.829 --> 00:48:39.880
Now as a result of this, I'm going
to get one of two callbacks.

00:48:39.880 --> 00:48:45.829
The first one is the application
didRegisterForRemoteNotificationsWithDeviceToken.

00:48:45.829 --> 00:48:48.880
And again the argument is in NSData structure.

00:48:48.880 --> 00:48:54.809
Now this is that opaque piece of data
that you need to send to your server.

00:48:54.809 --> 00:48:59.159
So the particular call here account send
not-- remote notifications to device--

00:48:59.159 --> 00:49:06.440
SendRemoteNotificationsDeviceToken is a piece of code
that you're going to have to write that you put--

00:49:06.440 --> 00:49:09.700
that it puts the device token up to your server.

00:49:09.699 --> 00:49:17.969
The second method is the failure case, application
didFailToRegisterForRemoteNotificationsWithError.

00:49:17.969 --> 00:49:23.669
Now again, you're app should still function perfectly well
if you're unable to register for remote notifications.

00:49:23.670 --> 00:49:26.730
So all I've done here is go ahead
and print a log so that I can go

00:49:26.730 --> 00:49:29.559
to the console and see what's wrong if I ever hit this.

00:49:29.559 --> 00:49:36.789
And just a reminder, you will hit this if you run it in the
Simulator since push notifications aren't supported there.

00:49:37.820 --> 00:49:40.570
Another application delegate callback
that I might be interested

00:49:40.570 --> 00:49:45.519
in is the application didReceiveRemoteNotification.

00:49:45.519 --> 00:49:52.639
Now as Chris mentioned earlier if your applications running
and we received a push notification for your application,

00:49:52.639 --> 00:49:58.440
the iPhone OS will not do anything with that
but pass it directly to your application.

00:49:58.440 --> 00:50:03.840
That means no badge is going to be updated, no sounds
going to be played and no alerts are going to be shown.

00:50:03.840 --> 00:50:07.940
Instead, this message is going to get
invoked on your application delegate.

00:50:07.940 --> 00:50:14.539
And in this case all I'm doing is telling my model object
to go ahead and hit the server and update the account.

00:50:14.539 --> 00:50:21.179
>> So, you need to think about what's appropriate
for your application and go ahead and do that.

00:50:21.179 --> 00:50:27.219
So we have the basic methods here that allow us to
receive and respond to remote notifications as well

00:50:27.219 --> 00:50:29.619
as register, but I want to get slightly fancy here.

00:50:29.619 --> 00:50:34.880
I think it would be great that when I
got a squawk from a given individual,

00:50:34.880 --> 00:50:40.849
if I could go straight to that person's detail view
and I could see their large icon and their history.

00:50:40.849 --> 00:50:45.630
So what I can do is instead of using
application didFinishLaunching,

00:50:45.630 --> 00:50:50.320
I can substitute that with application
didFinishLaunchingWithOptions.

00:50:50.320 --> 00:50:56.570
Now what this does is it provides an optional--
another dictionary called the Launch Options Dictionary

00:50:56.570 --> 00:51:04.250
and in there is a dictionary that represents the
payload directly from the push notification server.

00:51:04.250 --> 00:51:11.769
Now with that, I can go down here and after
I've done my usual registrations and whatnot.

00:51:11.769 --> 00:51:14.650
Oops that-- it scrolled up a little.

00:51:14.650 --> 00:51:15.809
That's good.

00:51:15.809 --> 00:51:20.409
We can go ahead and grab that push dictionary
out of the Launch Options Dictionary

00:51:20.409 --> 00:51:24.899
with the key UIApplication launch
options remote notification key.

00:51:24.900 --> 00:51:27.289
Now when is this dictionary here?

00:51:27.289 --> 00:51:31.300
This dictionary is present whenever
the user clicks on the action--

00:51:31.300 --> 00:51:36.510
not clicks, taps on the Action
button for a push notification alert.

00:51:36.510 --> 00:51:41.090
It's not going to be there if there's a badge there,
a sound played and the user tapped on the icon.

00:51:41.090 --> 00:51:43.300
It's only there from an alert.

00:51:43.300 --> 00:51:50.490
And what I've done here is I go ahead and set up my
view, detailed view controller, set up its internal state

00:51:50.489 --> 00:51:52.779
and go ahead and put it on the view controller stack

00:51:52.780 --> 00:51:58.269
and again that's just view controller
stuff that you can check out later.

00:51:58.269 --> 00:52:03.070
Finally, this particular method,
a launch application with options,

00:52:03.070 --> 00:52:08.620
application didLaunchWithOptions returns the bullets
as supposed to a void so I go ahead and return yes.

00:52:08.619 --> 00:52:20.559
So what I'm going to do now is save my
project, build it, try to install it here.

00:52:20.559 --> 00:52:31.309
OK, now I'm going to stop it because I actually
want a push to come through when it's time.

00:52:31.309 --> 00:52:39.119
OK, so I'm going to wait for a squawk.

00:52:39.119 --> 00:52:41.409
[Squawk] Now that's a branded sound.

00:52:41.409 --> 00:52:43.299
Let me tell you.

00:52:43.300 --> 00:52:48.250
Well Chris, it's a little late to be
regretting things and I'm sorry about that.

00:52:48.250 --> 00:52:53.760
But I'm going to go ahead and click Tab View here
and I'm going to launch my application oh, but wait.

00:52:53.760 --> 00:52:58.720
It didn't go to the detailed view controller.

00:52:58.719 --> 00:53:04.789
So, in the past it's been kind of tricky to
debug because you weren't able to attach Xcode

00:53:04.789 --> 00:53:06.529
to a process that was launched externally.

00:53:06.530 --> 00:53:10.960
You might have run into this if
you're using custom URLs in the past

00:53:10.960 --> 00:53:16.610
or if you just wanted the user
to tap and then start debugging.

00:53:16.610 --> 00:53:19.460
But Xcode actually has a new feature
that I'd like to show you now.

00:53:19.460 --> 00:53:27.400
So I'm going to go back to the main screen
of Xcode and I'm going to go these groups

00:53:27.400 --> 00:53:30.539
and files column and I'm going down to executables.

00:53:30.539 --> 00:53:34.880
And then I'm going to the executable
and question, in my case it's Squawker.

00:53:34.880 --> 00:53:39.740
I'm going to hit command "I" which allows me to get info.

00:53:39.739 --> 00:53:45.159
The third tab is the Debugging tab and
there are two interesting options here.

00:53:45.159 --> 00:53:49.289
The first one is start executable
after starting the debugger.

00:53:49.289 --> 00:53:54.719
Now this particular option is the behavior that
you and I are both familiar with with Xcode today.

00:53:54.719 --> 00:53:57.599
This means that when you click on Debug in Xcode,

00:53:57.599 --> 00:54:03.509
Xcode will launch the application and
immediately attach to the process.

00:54:03.510 --> 00:54:06.940
This second thing is what we're interested in today.

00:54:06.940 --> 00:54:10.710
Wait for next launch/push notification.

00:54:10.710 --> 00:54:17.329
Now what this does when you tap debug on
Xcode is Xcode does not launch the process.

00:54:17.329 --> 00:54:22.039
Instead Xcode waits for the next
particular launch of that process

00:54:22.039 --> 00:54:25.590
and then attaches once it sees that it's been launched.

00:54:25.590 --> 00:54:28.570
If you're familiar with DDB this is similar to wait for.

00:54:28.570 --> 00:54:32.680
So I'm going to go ahead and select that.

00:54:32.679 --> 00:54:39.179
I'm going to ahead and break where I think
I might be having a problem, which is here.

00:54:39.179 --> 00:54:41.829
I'm going to switch to this bigger view for you.

00:54:41.829 --> 00:54:42.889
So I've broken here.

00:54:42.889 --> 00:54:44.429
I want to see what's in that dictionary.

00:54:44.429 --> 00:54:48.109
And I'm going to go ahead and click Debug.

00:54:48.110 --> 00:54:55.780
And what's going to happen is instead of launching the
application we get a dialog waiting for Squawker to launch.

00:54:55.780 --> 00:55:01.670
The debugger will attach to the
process the next time it is launched.

00:55:01.670 --> 00:55:07.000
And so I'm going to go ahead and switch back to
the phone and we're going to wait for a squawk.

00:55:07.000 --> 00:55:14.500
[ Pause ]

00:55:14.500 --> 00:55:14.829
[ Squawk ]

00:55:14.829 --> 00:55:19.719
>> Now, I'm going to dignify that.

00:55:19.719 --> 00:55:25.669
So what I'm going to do here is I'm
going to switch back to the demo machine.

00:55:25.670 --> 00:55:29.170
So you can see what happens with Xcode when I tap view.

00:55:29.170 --> 00:55:33.070
So I'm going to do that right now.

00:55:33.070 --> 00:55:38.000
The dialog disappears and sure enough we
break right where we set that break point.

00:55:38.000 --> 00:55:44.530
[ Applause ]

00:55:44.530 --> 00:55:50.510
>> So I'm going to go ahead and bring up the Debugger
Console here and I'm printing out that push dictionary.

00:55:50.510 --> 00:55:55.170
And sure enough we have APS here with
the alert, the badge, and the sound

00:55:55.170 --> 00:55:59.369
and among the custom keys we have this
key value pair squawker equals Chris.

00:55:59.369 --> 00:56:06.500
But if we notice, the squawker in this case is lowercase
but in my code I have an uppercase S that I'm looking for.

00:56:06.500 --> 00:56:10.199
So in this particular case the fix is trivial.

00:56:10.199 --> 00:56:14.679
I'm going to go ahead and make that lowercase.

00:56:14.679 --> 00:56:16.009
Demo bugs are always easier.

00:56:16.010 --> 00:56:18.000
Go ahead and build it.

00:56:18.000 --> 00:56:23.550
[ Pause ]

00:56:23.550 --> 00:56:29.039
>> I'm going to go ahead and cancel 'cause
I'm feeling pretty good today and go back

00:56:29.039 --> 00:56:34.019
to the app and wait for last-- one last squawk.

00:56:34.019 --> 00:56:39.869
[Squawk] Well I'm finishing up, I promise and I'm
going to go ahead and tap view here and voila,

00:56:39.869 --> 00:56:41.559
we went straight for the detail view controller.

00:56:41.559 --> 00:56:43.000
[Applause] Thank you.

00:56:43.000 --> 00:56:49.760
[ Applause ]

00:56:49.760 --> 00:56:53.980
>> So this particular feature of Xcode
as well as push notification services--

00:56:53.980 --> 00:56:59.199
the push notification service really enables
a whole new type of application experience

00:56:59.199 --> 00:57:00.989
and I'm really excited to see what you guys come up with.

00:57:00.989 --> 00:57:02.000
Thank you very much.

00:57:02.000 --> 00:57:09.230
[ Applause ]

00:57:09.230 --> 00:57:10.280
>> Thanks Justin.

00:57:10.280 --> 00:57:18.370
So if you need more information, please contact our
Evangelist Matt Drance or check out the great documentation

00:57:18.369 --> 00:57:21.889
that we have on-line at developer.apple.com.

00:57:21.889 --> 00:57:26.759
We have a push notification service program and guide
which is awesome as well as human interface guidelines

00:57:26.760 --> 00:57:30.020
that have been updated for iPhone
OS 3.0 and the push service.
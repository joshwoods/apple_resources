WEBVTT

00:00:13.009 --> 00:00:14.169
>> My name is Ali Ozer.

00:00:14.169 --> 00:00:16.940
I'm the Manager of the Cocoa Frameworks team at Apple.

00:00:16.940 --> 00:00:21.650
And Kevin Perry, who's my colleague in
the team, will be joining us shortly.

00:00:23.510 --> 00:00:24.780
So what are we talking about today?

00:00:24.780 --> 00:00:27.220
We will cover changes in Cocoa since Leopard.

00:00:27.219 --> 00:00:33.899
And there's a lot of changes we've done since last WWDC,
so we're going to give special coverage to those as well.

00:00:33.899 --> 00:00:37.750
And we will also provide pointers to other sessions.

00:00:37.750 --> 00:00:39.469
There are a lot of topics.

00:00:39.469 --> 00:00:45.129
In addition to stuff we added to Cocoa, there's advancements
in Objective-C, Garbage Collection and other frameworks

00:00:45.130 --> 00:00:47.880
such as Core Data and Core Location and so on.

00:00:47.880 --> 00:00:51.450
We're not going to cover those, and just
give pointers to them whenever we can.

00:00:51.450 --> 00:00:54.980
And in addition I would like to point out
this is not what's new in Cocoa Touch.

00:00:54.979 --> 00:00:56.619
There is another session for that.

00:00:56.619 --> 00:00:59.259
This is primarily focused on Cocoa on the Desktop.

00:00:59.259 --> 00:01:03.280
There is a session at 10:30, What's New in Cocoa Touch.

00:01:03.280 --> 00:01:06.820
So here are the topics, sort of
the rough outlines of the talk.

00:01:06.819 --> 00:01:09.559
And this is just a very rough high-level outline.

00:01:09.560 --> 00:01:14.329
There a lot of individual topics,
we'll go into throughout the talk.

00:01:14.329 --> 00:01:17.429
So first I want to talk about 64-Bit.

00:01:17.430 --> 00:01:22.190
Now, we talked about 64-Bit before in many
sessions, so this is going to be fairly brief.

00:01:22.189 --> 00:01:28.649
As you know, we've been making good strides
towards 64-Bit over the last few releases.

00:01:28.650 --> 00:01:35.780
And in 10.6 almost all the applications
on the system are now 64-Bit.

00:01:35.780 --> 00:01:40.840
Now, back in 2006 in the 64-Bit
overview session, which I gave,

00:01:40.840 --> 00:01:46.920
here is we did some prophecy and
we said 64-Bit applications.

00:01:46.920 --> 00:01:49.000
We prophesied that they were not going to be.

00:01:49.000 --> 00:01:53.159
They were not here in Leopard, but
post-Leopard they would likely be here some day.

00:01:53.159 --> 00:01:56.640
And back then, we were looking forward,
thinking maybe, you know, five years, whatever.

00:01:56.640 --> 00:02:01.519
Well, it's now just three years
later and 64-Bit apps are here.

00:02:01.519 --> 00:02:06.129
The system, the center of gravity of the
system has shifted towards 64-Bit apps.

00:02:06.129 --> 00:02:09.599
Most of the time the users are
just running 64-Bit apps right now.

00:02:09.599 --> 00:02:15.319
What this means is if you have a 32-bit-only a2pplication
it's time to consider moving it to 64-Bit apps.

00:02:15.319 --> 00:02:17.319
Because just like we said back then, you know,

00:02:17.319 --> 00:02:21.009
you don't want to be the only one left
with a 16-bit app in a 32-bit world.2

00:02:21.009 --> 00:02:26.049
That's the same way it is really
with 64-Bit, so some day is here.

00:02:26.050 --> 00:02:27.830
Now, what does 64-Bit mean ford Cocoa?

00:02:27.830 --> 00:02:31.150
It's actually on the surface a very small change.

00:02:31.150 --> 00:02:33.310
We just introduced three new types.

00:02:33.310 --> 00:02:39.860
These are 64-Bit versions of the types commonly used in our
APIs, and their alternate definitions for them for 64-Bit.

00:02:39.860 --> 00:02:42.540
So if you're writing a brand new 64-Bit application,

00:02:42.539 --> 00:02:47.979
or if you're even writing an iPhone application,
just use these types and you'll be fine.

00:02:47.979 --> 00:02:53.979
If you have an existing application, we have
a script help you convert your application.

00:02:53.979 --> 00:02:55.609
You, here's the script.

00:02:55.610 --> 00:03:02.210
It's called ConvertCocoa64, and the one on Snow
Leopard is newer than the one on Leopard, by the way.

00:03:02.210 --> 00:03:04.920
To run it you'd make a copy of your sources.

00:03:04.919 --> 00:03:08.789
You just run the script on every
source file in your application.

00:03:08.789 --> 00:03:14.560
And then you go ahead and fire FileMerge or your favorite
diffing tool and basically confirm all the changes

00:03:14.560 --> 00:03:17.949
because there might be some that you don't like.

00:03:17.949 --> 00:03:21.229
Now, if you already run the script and
converted your application to 64-Bit,

00:03:21.229 --> 00:03:24.099
then you're wondering do I need to run this script as well?

00:03:24.099 --> 00:03:25.590
The answer is no.

00:03:25.590 --> 00:03:28.110
This script just does a few things a little better,

00:03:28.110 --> 00:03:31.510
but these are already things you
probably would have fixed or found.

00:03:31.509 --> 00:03:37.519
It basically generates far less warnings, for instance,
which makes the conversion process a lot easier.

00:03:37.520 --> 00:03:40.219
So that's about it as far as 64-Bit.

00:03:40.219 --> 00:03:44.099
There is a great document, the 64-Bit Transitidon Guide.

00:03:44.099 --> 00:03:49.430
You can type this into Google or just go to this URL
and it will tell you all about what 64-Bit means.

00:03:49.430 --> 00:03:55.099
What the conversion script does and various
other issues you need to watch out for.

00:03:55.099 --> 00:03:56.500
Now, as you know, Carbon.

00:03:56.500 --> 00:03:59.650
The high-level Carbon APIs are not available in 64-Bit.

00:03:59.650 --> 00:04:04.550
And one thing we've done in Cocoa is try to fill
in the various holes that we had in Cocoa APIs

00:04:04.550 --> 00:04:07.400
where you might have fallen to Carbon to get something done.

00:04:07.400 --> 00:04:13.159
In some cases, these new APIs are just one-to-one
replacements of functions with new methods.

00:04:13.159 --> 00:04:19.350
In other cases, we introduced brand new
extractions in Cocoa to satisfy this need.

00:04:19.350 --> 00:04:24.689
So I'll start off with NSApplication, which
now has a new API setPresentationOption

00:04:24.689 --> 00:04:28.360
that lets you control the system user interface elements.

00:04:28.360 --> 00:04:33.080
So this means if your application, for instance, wants to
run without the Dock Visible, or your application wants

00:04:33.079 --> 00:04:37.669
to disable the ForceQuit menu,
etc., you can do this with this API.

00:04:37.670 --> 00:04:42.460
Now, note that the PresentationOption's API
which returns your current presentation options,

00:04:42.459 --> 00:04:49.609
and currentSystemPresentationOptions which returns to
you what the current, no matter whatever app's set at,

00:04:49.610 --> 00:04:54.889
what the current setting is, these are key value
observable so you can actually find out even

00:04:54.889 --> 00:04:57.079
when another application changes the setting.

00:04:57.079 --> 00:05:00.509
Now, the options you might pass to this include these.

00:05:00.509 --> 00:05:06.480
You can, for instance, cause the Dock to be hidden
or cause it to be AutoHidden, the same with the menu.

00:05:06.480 --> 00:05:11.210
You can disable AppleMenu, ProcessSwitching,
ForceQuit, and etc. Elements like that.

00:05:11.209 --> 00:05:16.389
Now, there's a tech note 2062, which goes
into detail about how these options interact.

00:05:16.389 --> 00:05:21.829
It's in terms of the system UI mode API which is
the old Carbon API that's being replaced here.

00:05:21.829 --> 00:05:26.120
And we'll update the tech note at some
point to talk about this new API as well.

00:05:26.120 --> 00:05:32.780
We have some enhancements in NSWindow, again providing
API that was previously available through Carbon.

00:05:32.779 --> 00:05:37.929
You can now disable server-side dragging, so
basically this makes a window non-movable.

00:05:37.930 --> 00:05:40.939
And once you set this you can choose
to move the window yourself.

00:05:40.939 --> 00:05:45.370
Because as you know in Cocoa windows are typically moved
on the server, which means windows can be moved even

00:05:45.370 --> 00:05:49.230
if your application is busy or not responding.

00:05:49.230 --> 00:05:51.700
But this will prevent that and you can do whatever you want.

00:05:51.699 --> 00:05:56.769
You can now hit-test any screen location
to find out what window there is.

00:05:56.769 --> 00:06:00.419
Note that this API returns an NSInteger
rather than an NSWindow.

00:06:00.420 --> 00:06:05.900
And this way we can return any window, not
just windows belonging to your application.

00:06:05.899 --> 00:06:10.219
So this is a window number that can
track any window in any application.

00:06:10.220 --> 00:06:14.580
And finally, we can return to you the
window numbers of all visible windows,

00:06:14.579 --> 00:06:17.439
whether they are in your application or any application.

00:06:17.439 --> 00:06:20.399
And this returns an NSArray of NSNumbers.

00:06:20.399 --> 00:06:28.870
And the options you can provide are justYourApplication
or allApplications, and justThisSpace or allSpaces.

00:06:28.870 --> 00:06:34.449
NSRunningApplication is a brand new class,
which replaces the processes API from Carbon.

00:06:34.449 --> 00:06:36.459
This is a pretty straightforward API.

00:06:36.459 --> 00:06:40.639
It returns to you properties of applications
that are currently running on the system.

00:06:40.639 --> 00:06:43.930
You can find out things whether, like
whether the apps are hidden or active.

00:06:43.930 --> 00:06:45.329
What their localized name is.

00:06:45.329 --> 00:06:46.680
What their icon is and so on.

00:06:46.680 --> 00:06:50.579
And so you can do a lot of things that
involve running applications with this API.

00:06:50.579 --> 00:06:55.800
Note that some of the properties here are also
KVO-observable so you can observe them change.

00:06:55.800 --> 00:07:02.120
A running application, in addition to returning
properties of applications lets you hide, terminate,

00:07:02.120 --> 00:07:07.920
even forceTerminate if you wish, and activate
running applications with these APIs here.

00:07:07.920 --> 00:07:11.650
And there's ways to get back running applications.

00:07:11.649 --> 00:07:14.149
For instance, you can ask for your current application.

00:07:14.149 --> 00:07:18.009
You can ask for a running application,
which corresponds to a UNIX process ID.

00:07:18.009 --> 00:07:21.670
Or you can get back an array of running
applications that share a bundle identifier.

00:07:21.670 --> 00:07:23.030
And the reason for returns on the array here

00:07:23.029 --> 00:07:27.049
of course is you can have many applications
that share the same bundle identifier.

00:07:27.050 --> 00:07:32.090
There is also one more way to get running
applications, and that's to ask NSWorkSpace

00:07:32.089 --> 00:07:34.759
for the array of all running applications.

00:07:34.759 --> 00:07:40.810
And note that this array here is also
KVO-observable, so you can see this list change.

00:07:40.810 --> 00:07:44.930
Speaking of NSWorkspace, there's a
lot of new APIs on this Workspace.

00:07:44.930 --> 00:07:46.910
I'll just touch upon one now.

00:07:46.910 --> 00:07:49.700
You can display a Spotlight search results window.

00:07:49.699 --> 00:07:54.120
So this is equivalent to a user bringing up a
Finder window and typing in a search string.

00:07:54.120 --> 00:07:57.319
The search string you give will be
used to bring up this Finder window.

00:07:57.319 --> 00:08:00.759
The user can then go ahead and fine-tune the query.

00:08:00.759 --> 00:08:08.230
Note that this corresponds to the Carbon API
HISearchWindowShow if you might have used that before.

00:08:08.230 --> 00:08:13.410
Along the same lines, we have some NSView
API to bring up the Dictionary application.

00:08:13.410 --> 00:08:18.960
You can either use the first API here to bring up your
basic Dictionary application that uses the Dictionary

00:08:18.959 --> 00:08:22.719
or various other, you know, Thesaurus
and etc. for a given word.

00:08:22.720 --> 00:08:27.370
Or you can use the second API to bring up
a, customize the way the window is shown.

00:08:27.370 --> 00:08:31.250
For instance, it can be shown on
top of your document and so on.

00:08:31.250 --> 00:08:35.289
Now, note that the second argument here,
showDefinitionforAttributedString with four arguments,

00:08:35.289 --> 00:08:41.909
also takes a block as an argument which lets you fine
tune the positioning, and we'll talk about blocks shortly.

00:08:41.909 --> 00:08:46.610
Another area where we've made a
lot of changes is NSPasteboard.

00:08:46.610 --> 00:08:51.000
You might know that Carbon has this concept
of multiple items in its NSPasteboard APIs,

00:08:51.000 --> 00:08:58.139
while in Cocoa that feature has always been limited
to specialized cases like file names, keyboard type.

00:08:58.139 --> 00:09:01.149
Well, NSPasteboard now supports multiple items.

00:09:01.149 --> 00:09:05.689
In addition, there's a more, a new and more general API.

00:09:05.690 --> 00:09:11.450
It's in terms of UTIs, we have these two
protocols, PasteboardWriting and PasteboardReading,

00:09:11.450 --> 00:09:17.120
which many AppKit classes implement and
you can also implement them yourselves.

00:09:17.120 --> 00:09:20.299
We also have a Pasteboarditem class,
which is a generic container

00:09:20.299 --> 00:09:23.419
to let you participate in the new
Pasteboard APIs more easily.

00:09:23.419 --> 00:09:29.949
Now, I'm not going to say much more about Pasteboard
here because there is a half a session dedicated to it.

00:09:29.950 --> 00:09:33.870
And this session is Thursday afternoon at 2:00.

00:09:33.870 --> 00:09:38.539
The other half of this session is Services.

00:09:38.539 --> 00:09:40.490
You might know Services.

00:09:40.490 --> 00:09:46.500
It's always been in the first menu or the
second menu, in your Application Menu.

00:09:46.500 --> 00:09:52.690
It's been, the Services features has been
with us since 10.0, in fact, even before 10.0.

00:09:52.690 --> 00:09:56.870
What we've done to Services now is make them
more discoverable, make them context sensitive,

00:09:56.870 --> 00:09:59.580
and also allow the user to customize them.

00:09:59.580 --> 00:10:02.290
So here's what the Services menu looks like in 10.6.

00:10:02.289 --> 00:10:06.029
If you've seen the Services menu before
you'll notice that it's got icons.

00:10:06.029 --> 00:10:07.279
The capitalization's better.

00:10:07.279 --> 00:10:09.470
It no longer has nested sub-menus.

00:10:09.470 --> 00:10:12.810
And also note that there is an
item here, Services Preferences.

00:10:12.809 --> 00:10:20.369
If selected will let the user enable or disable individual
services that they wish to use, so it's fairly handy.

00:10:20.370 --> 00:10:27.379
Again, this is part of the Pasteboard
and Services talk Thursday at 2:00.

00:10:27.379 --> 00:10:28.840
Bunch of changes in NSMenu.

00:10:28.840 --> 00:10:30.000
There's actually a lot of changes.

00:10:30.000 --> 00:10:31.149
Just highlight three.

00:10:31.149 --> 00:10:35.220
You can now display a menu as a popup
without having to resort to Carbon APIs,

00:10:35.220 --> 00:10:39.830
which always involve some underhanded
dealing that I don't want to hear about.

00:10:39.830 --> 00:10:42.340
You can allow a delegate to control the menu location.

00:10:42.340 --> 00:10:45.399
Basically return a brand new rect where the menu appears.

00:10:45.399 --> 00:10:48.720
And finally, you can stop the menu
from tracking at any point.

00:10:48.720 --> 00:10:51.710
So if you are doing something special with the
menu and you want the menu to just go away.

00:10:51.710 --> 00:10:52.360
No animation.

00:10:52.360 --> 00:10:56.220
Nothing. You can call this method,
cancelTrackingWithoutAnimation.

00:10:56.220 --> 00:11:02.519
The last topic I'm going to cover
in this section is NSEvent.

00:11:02.519 --> 00:11:08.269
We now have methods to let you get user preference
settings, doubleClickInterval, keyRepeatDelay and so on.

00:11:08.269 --> 00:11:09.730
Pretty straightforward.

00:11:09.730 --> 00:11:13.970
And we have two other methods that let you
get the mouse state and the keyboard state.

00:11:13.970 --> 00:11:18.399
So basically, what modifier flags are
down or what mouse buttons are pressed.

00:11:18.399 --> 00:11:23.399
Now, note that these are class methods, not instance
methods, so you can ask these questions at any time

00:11:23.399 --> 00:11:25.090
in your application and get the current state.

00:11:25.090 --> 00:11:27.870
You don't have to have a current NSEvent.

00:11:27.870 --> 00:11:31.730
The other event enhancement is Event Monitoring.

00:11:31.730 --> 00:11:36.940
You now have the ability to monitor events coming
in to your application, or in fact any application.

00:11:36.940 --> 00:11:42.350
This first API here, addLocalMonitorForEventsMatchingMask,
lets you install a monitor

00:11:42.350 --> 00:11:45.409
that sees every event coming into your application.

00:11:45.409 --> 00:11:47.019
And you can also affect them.

00:11:47.019 --> 00:11:52.370
Meaning, you can either let the event
pass through or substitute a new event.

00:11:52.370 --> 00:11:55.600
Or in fact, just stop the event altogether by returning nil,

00:11:55.600 --> 00:11:58.879
and that's sort of the ultimate
form of censorship, if you wish.

00:11:58.879 --> 00:12:02.330
The other method is the global one, addGlobalMonitor.

00:12:02.330 --> 00:12:05.389
This one is similar, except it
doesn't let you affect events.

00:12:05.389 --> 00:12:07.539
You can only observe them.

00:12:07.539 --> 00:12:09.569
Now, note that these return IDs.

00:12:09.570 --> 00:12:10.590
When you are.

00:12:10.590 --> 00:12:15.460
When you do not want to monitor anymore, you just
call the removeMonitor and pass that ID in there.

00:12:15.460 --> 00:12:18.320
There is some limitations to the usage of these things.

00:12:18.320 --> 00:12:24.200
For instance, if your application's in the tracking loop,
the events won't be seen by this, by the local monitor.

00:12:24.200 --> 00:12:30.560
In addition, events going to, say, secureTextFields will
not be visible here, and that's probably a good thing.

00:12:30.559 --> 00:12:34.259
There is an events talk, which will
cover these and many other topics.

00:12:34.259 --> 00:12:38.059
That's tomorrow afternoon at 3:30, User Events in Cocoa.

00:12:38.059 --> 00:12:44.029
Now, note that here as well these two methods
have handlers, which take block arguments.

00:12:44.029 --> 00:12:48.620
And as you can see, we're using block
arguments more and more in Cocoa APIs.

00:12:48.620 --> 00:12:52.730
And I want to talk about blocks right
now and then I'll move on to concurrency.

00:12:54.409 --> 00:12:57.689
Blocks are snippets of code that capture lexical scope.

00:12:57.690 --> 00:13:00.390
If you were at the sessions yesterday,
you saw some examples of them.

00:13:00.389 --> 00:13:03.340
But I really want to make blocks
concrete for you so that, you know,

00:13:03.340 --> 00:13:06.470
when you see a block you can easily
read it and it becomes second nature.

00:13:06.470 --> 00:13:09.870
So let me just give you a few examples.

00:13:09.870 --> 00:13:11.220
Here's a block example.

00:13:11.220 --> 00:13:13.550
We're declaring a variable called myBlock,

00:13:13.549 --> 00:13:17.079
and you can recognize that this is a block
because there's a caret instead of a *.

00:13:17.080 --> 00:13:19.350
If it this was a function variable it would have been a *.

00:13:19.350 --> 00:13:21.500
So the variable's called myBlock.

00:13:21.500 --> 00:13:27.460
It's a block that returns an int, and it
takes a single argument, which is also an int.

00:13:27.460 --> 00:13:29.269
Now, note that this is the body of the block.

00:13:29.269 --> 00:13:33.980
Here we're actually creating a block, a literal
block, and assigning it to the new variable.

00:13:33.980 --> 00:13:35.399
This is the whole block.

00:13:35.399 --> 00:13:36.889
A literal block.

00:13:36.889 --> 00:13:42.110
The single argument we've given it a name
of num here, and here is that actual body

00:13:42.110 --> 00:13:44.500
of the block, which could be arbitrarily complicated.

00:13:44.500 --> 00:13:49.700
In this case, we're just using the incoming
parameter num, and we're multiplying it by multiplier,

00:13:49.700 --> 00:13:52.120
which is a value that's captured off the stack

00:13:52.120 --> 00:13:53.480
In this case 7.

00:13:53.480 --> 00:13:54.240
So that's captured.

00:13:54.240 --> 00:13:56.360
It's a constant in this case.

00:13:56.360 --> 00:14:01.779
And of course, if you were to run something like,
say, myBlock(3), you would get back the result of 21.

00:14:01.779 --> 00:14:06.750
Now we will cover blocks in good detail in a talk tomorrow.

00:14:06.750 --> 00:14:08.029
Yes, tomorrow afternoon at 5:00.

00:14:08.029 --> 00:14:10.289
Objective-C and Garbage Collection Advancements.

00:14:10.289 --> 00:14:12.990
But I do want to talk about them a bit more.

00:14:12.990 --> 00:14:17.090
Here is another place where you
might see blocks quite often.

00:14:17.090 --> 00:14:21.690
This method enumerates lines using
blocks, which is a new method on NSString.

00:14:21.690 --> 00:14:23.670
This is the method of taking a block argument.

00:14:23.669 --> 00:14:26.629
The block returns nothing, so it's void.

00:14:26.629 --> 00:14:29.549
It takes two arguments, an NSString and a Boolean *.

00:14:29.549 --> 00:14:33.459
And the name of the parameter is block.

00:14:33.460 --> 00:14:39.200
So this API basically enumerates NSString and
calls your block with every line in the string.

00:14:39.200 --> 00:14:43.700
And you can stop the enumeration by setting *stop=yes.

00:14:43.700 --> 00:14:48.050
There's a bunch of related APIs, and I'm
not going to talk about these right now.

00:14:48.049 --> 00:14:52.649
In NSString and that's an attributed string because we
do have a text processing talk, which is Friday morning

00:14:52.649 --> 00:14:57.039
at 9:00 a.m. That will go into more
details about this and plenty more.

00:14:57.039 --> 00:15:00.120
The last example of blocks is one
that's used in the typedef.

00:15:00.120 --> 00:15:05.000
Here we're creating a typedef called Comparator.

00:15:05.000 --> 00:15:10.019
It's a block that returns a comparison
result, so less than, greater then, equal to.

00:15:10.019 --> 00:15:12.980
And it takes two arguments, the objects being compared.

00:15:12.980 --> 00:15:16.060
Let me show you a concrete example of an API that uses this.

00:15:16.059 --> 00:15:20.369
NSArray has an API called sortedArrayUsingComparator.

00:15:20.370 --> 00:15:23.820
And as you can imagine it sorts
to array given the Comparator.

00:15:23.820 --> 00:15:26.370
And here is an actual usage.

00:15:26.370 --> 00:15:31.440
You might call, for instance, myArray
sortedArrayUsingComparator and pass a block,

00:15:31.440 --> 00:15:35.430
which in this case simply calls
localizedStandardCompare on the two arguments.

00:15:35.429 --> 00:15:37.289
This is also a new method we've added.

00:15:37.289 --> 00:15:39.839
Now, as I said the block here could
be arbitrarily complicated.

00:15:39.840 --> 00:15:40.980
It can do all sorts of stuff.

00:15:40.980 --> 00:15:45.470
In this case, it just happens to compare to
two arguments with this alternative method.

00:15:45.470 --> 00:15:49.170
Now, I'm going to talk at this
point a bit about block naming.

00:15:49.169 --> 00:15:53.809
As you know, in Cocoa getting APIs
right is very important to us.

00:15:53.809 --> 00:15:58.829
In addition, being able to communicate our conventions,
our guidelines so that our APIs are predictable,

00:15:58.830 --> 00:16:04.220
and you yourselves can also create APIs, which are
consistent, those are very important factors for us.

00:16:04.220 --> 00:16:06.790
Now block is a challenging name, because when used

00:16:06.789 --> 00:16:10.549
as a verb it means something totally
different than what we use as a noun.

00:16:10.549 --> 00:16:16.889
For instance, if you're a casual reader of some code and
you came across myArray block, instead of returning a block

00:16:16.889 --> 00:16:20.100
that might seem like something
that blocks execution of the array.

00:16:20.100 --> 00:16:22.350
Or similarly, window beginSheetblock:,

00:16:22.350 --> 00:16:26.720
while it was intending to take a block
argument you might think it's just an argument

00:16:26.720 --> 00:16:29.860
that takes yes or no to block the sheet.

00:16:29.860 --> 00:16:35.019
So instead of block, we want to use more descriptive names.

00:16:35.019 --> 00:16:37.419
More descriptive terms in our method names.

00:16:37.419 --> 00:16:41.029
And several that we've come up with include
Handler, Provider, Test, Comparator.

00:16:41.029 --> 00:16:44.500
Handler for something that just, like
a delegate almost handles something.

00:16:44.500 --> 00:16:48.649
Provider for something that takes some
arguments and returns another argument.

00:16:48.649 --> 00:16:52.529
Test is something that is a predicate, returns yes or no.

00:16:52.529 --> 00:16:54.589
And Comparator you've already seen.

00:16:54.590 --> 00:16:59.480
Now, we will still use block in
our APIs, but only in generic cases

00:16:59.480 --> 00:17:03.080
where it's not easy to describe what the block does.

00:17:03.080 --> 00:17:06.289
So let's go back to our collections example, NSArray.

00:17:06.289 --> 00:17:08.480
Here's the sorting method we already saw.

00:17:08.480 --> 00:17:12.140
We have two other categories of functionality
that use blocks in our collections.

00:17:12.140 --> 00:17:15.280
One is Enumeration, and the other one is Searching.

00:17:15.279 --> 00:17:19.410
Now, note in the Searching one
you're passing basically a test

00:17:19.410 --> 00:17:25.580
And for every, this enumerates to the array, and for every
item that returns yes from your test, it will go ahead

00:17:25.579 --> 00:17:30.409
and put in an index set and return
all the indexes that match this test.

00:17:30.410 --> 00:17:33.460
Now, in addition to these three methods
we have a lot of other variants.

00:17:33.460 --> 00:17:35.670
We have versions of these for the other collections.

00:17:35.670 --> 00:17:37.880
Dictionary, Set, and IndexSet.

00:17:37.880 --> 00:17:44.110
In addition, we have variance of these that take options,
and if appropriate a subset to work on so you can choose

00:17:44.109 --> 00:17:46.039
to integrate only a part of the array for instance.

00:17:46.039 --> 00:17:48.259
So there are many other methods along these lines.

00:17:48.259 --> 00:17:51.519
I'm not going to show you those now in detail.

00:17:51.519 --> 00:17:57.279
But I do want to talk about concurrency, so
let's move on to the topic of concurrency.

00:17:57.279 --> 00:18:03.009
So we saw Enumeration, Searching and Sorting
and you can now do those concurrently.

00:18:03.009 --> 00:18:06.369
The way you do that would be to provide an option.

00:18:06.369 --> 00:18:10.299
Either EnumerationConcurrent or SortConcurrent.

00:18:10.299 --> 00:18:13.289
And here's what the sort case might look like.

00:18:13.289 --> 00:18:20.730
You would call sortedArrayWithOptions and you would pass
SortConcurrent and you would pass in your Comparator.

00:18:20.730 --> 00:18:27.750
So what this means is that the provided block may be
invoked concurrently, so it should be thread-safe.

00:18:27.750 --> 00:18:33.079
The other thing to note here is that the
overall operation is still synchronous,

00:18:33.079 --> 00:18:35.349
meaning the method will not return until it's done.

00:18:35.349 --> 00:18:37.889
Let me give you an analogy for this.

00:18:37.890 --> 00:18:39.540
Imagine you go to the carwash.

00:18:39.539 --> 00:18:41.200
You drop off your car.

00:18:41.200 --> 00:18:46.220
Typically you would wait until your car is
washed, and that's a synchronous operation there.

00:18:46.220 --> 00:18:50.210
Now, you might take your car into the
carwash and one person might wash your car.

00:18:50.210 --> 00:18:54.950
Well, with this concurrent option it's as if you took
your car to the carwash and 12 people descend on your car

00:18:54.950 --> 00:18:58.340
and all wash it, and clearly your
car's going to be washed faster.

00:18:58.339 --> 00:19:02.279
Now, also note that if you took your car to
the carwash and 200 people descended on it,

00:19:02.279 --> 00:19:05.519
that'd be a big mess because they
probably would just wreck the car.

00:19:05.519 --> 00:19:10.849
And, of course, it's responsible given NSArray
and the Grand Central Dispatch that it uses

00:19:10.849 --> 00:19:12.990
to make sure that sort of disaster doesn't happen.

00:19:12.990 --> 00:19:14.680
But again, your car.

00:19:14.680 --> 00:19:20.110
You will wait there till your car is finished, except
the concurrency will let it happen much more quickly.

00:19:20.109 --> 00:19:25.389
The other thing to note here is that if you are enumerating
concurrently you are no longer enumerating in order.

00:19:25.390 --> 00:19:26.840
You're not going from 0 to end.

00:19:26.839 --> 00:19:32.259
You're going to be all over the map, and
that's obvious with something to keep in mind.

00:19:32.259 --> 00:19:36.660
The other concurrency topic is
NSOperation and NSOperationQueue.

00:19:36.660 --> 00:19:42.790
These are clearly important pieces
of the concurrency story in Cocoa.

00:19:42.789 --> 00:19:44.569
Simon talked about these yesterday.

00:19:44.569 --> 00:19:50.689
The big change here is that these classes have been
reimplemented to be on top of Grand Central Dispatch.

00:19:50.690 --> 00:19:53.740
Now, note here the sort of the power of Cocoa Extraction.

00:19:53.740 --> 00:19:58.049
These classes were available to you in
Leopard and a lot of people are using them.

00:19:58.049 --> 00:20:03.509
In Snow Leopard, we have reimplemented them on top
of this new facility, which means they are faster.

00:20:03.509 --> 00:20:06.259
They can handle a lot more load.

00:20:06.259 --> 00:20:11.819
In addition, they now share in the same pool of resources
that Grand Central Dispatch does, which of course is great

00:20:11.819 --> 00:20:15.909
because it gives the system a better
idea of how to balance things.

00:20:15.910 --> 00:20:19.170
However, for the most part your code is not affected at all.

00:20:19.170 --> 00:20:21.800
Your code, which works on 10.5, will work under 10.6.

00:20:21.799 --> 00:20:25.039
It's just faster, better, and so on.

00:20:25.039 --> 00:20:28.629
Now, we also took the advantage to add a bunch of new APIs.

00:20:28.630 --> 00:20:33.570
NSOperations can now have thread priorities,
and you can specify a completion block

00:20:33.569 --> 00:20:36.599
to be executed when the operation is done.

00:20:36.599 --> 00:20:41.789
NSOperationQueue now allows you add multiple
operations and optionally wait till they're done.

00:20:41.789 --> 00:20:47.470
You can also add a block as an operation, and we also
have an explicit class for this, NSBlockOperation,

00:20:47.470 --> 00:20:53.370
which lets you add a block in an operation
and tweak various other parameters for it.

00:20:53.369 --> 00:20:59.179
NSNotificationCenter has also one
new method to allow concurrency.

00:20:59.180 --> 00:21:03.519
This method here now allows observers
to get notifications concurrently.

00:21:03.519 --> 00:21:09.889
So just like before, you're adding an observer
specifying a notification name and object to filter on.

00:21:09.890 --> 00:21:12.570
Let me show you the Leopard version of this API.

00:21:12.569 --> 00:21:18.759
You are specifying the name and object, but in the Leopard
version you would provide an observer and a selector.

00:21:18.759 --> 00:21:21.329
So the selector to get called on you observer.

00:21:21.329 --> 00:21:26.980
In the Snow Leopard version these have been replaced
by a queue and a block to execute on that queue.

00:21:26.980 --> 00:21:31.690
If you provide nil as your queue, you
basically get the Leopard behavior for this.

00:21:31.690 --> 00:21:42.170
Now, the good thing about this API is that it's fairly,
it's very compatible from a posting point of view.

00:21:42.170 --> 00:21:45.039
There is no change to the notification posting code.

00:21:45.039 --> 00:21:52.690
Because what happens here is all the posting is done, but
all the observers have to be done until this method is done,

00:21:52.690 --> 00:21:54.950
I mean, until the notification posting is done.

00:21:54.950 --> 00:21:58.970
So in that way this is sort of analogous
to that carwash example I gave you before.

00:21:58.970 --> 00:22:03.269
Until, you know, everything might
happen concurrently but, you know,

00:22:03.269 --> 00:22:06.509
the execution will not continue until it's all done.

00:22:06.509 --> 00:22:09.150
Because if we did sort of open the
floodgates and make it asynchronous,

00:22:09.150 --> 00:22:14.130
you can imagine that a windowWillResize notification
would get delivered before window did resize

00:22:14.130 --> 00:22:18.220
and that would cause a lot of fun things.

00:22:18.220 --> 00:22:23.569
The last concurrency topic I want
to touch on is Concurrent Drawing.

00:22:23.569 --> 00:22:30.079
NSView subclasses can now opt-in to Concurrent
Drawing just by setting setCanDrawConcurrentlyYes.

00:22:30.079 --> 00:22:36.980
What this means is when a hierarchy of views
is being drawn in Display or displayAsNeeded,

00:22:36.980 --> 00:22:43.910
views that have specified this property
can be drawn concurrently with other views.

00:22:43.910 --> 00:22:48.060
Now again, Display or displayAsNeeded
is blocked until drawing is done.

00:22:48.059 --> 00:22:51.349
So again, this remains fairly compatible
to existing practices.

00:22:51.349 --> 00:22:54.299
You just have to make sure you've
used Drawing is thread-safe.

00:22:54.299 --> 00:23:01.250
Also note that because of this approach, in most cases
the thread-safety demands on your model are not changed.

00:23:01.250 --> 00:23:08.130
You know, if there was cases where you couldn't
change your model in other threads, those still apply.

00:23:08.130 --> 00:23:13.170
Now, these and the other topics I touched upon
will be covered in more depth tomorrow morning

00:23:13.170 --> 00:23:16.820
at 9:00 a.m. in Concurrent Programming in Cocoa.

00:23:16.819 --> 00:23:20.700
Now, there is one more concurrency topic to talk about,

00:23:20.700 --> 00:23:25.160
and that's Concurrent Document Opening,
which the TextSet application now does.

00:23:25.160 --> 00:23:30.019
And to talk about this and some other new
Snow Leopard features we are showcasing

00:23:30.019 --> 00:23:34.009
and TextEdit, I'd like to invite Kevin Perry on stage.

00:23:34.009 --> 00:23:39.440
[ Clapping ]

00:23:39.440 --> 00:23:40.289
Thank you, Ali.

00:23:40.289 --> 00:23:47.579
Concurrent Document Opening is just one of the
enhancements that we made for TextEdit in Snow Leopard.

00:23:47.579 --> 00:23:52.379
And I'd like to show you how valuable these various
enhancements are, and how simple they are to implement

00:23:52.380 --> 00:23:56.090
so you can extrapolate that to your own applications.

00:23:56.089 --> 00:24:02.929
So starting with Concurrent Document Opening, as
you're probably familiar if you open a ton of documents

00:24:02.930 --> 00:24:08.620
in TextEdit, or you're loading over a very slow
network, you're going to be prepared to see this guy.

00:24:08.619 --> 00:24:11.189
This mini pizza of death or the weight curse.

00:24:11.190 --> 00:24:19.840
Obviously because the loading process is blocking the main
thread, preventing it from processing any user events.

00:24:19.839 --> 00:24:26.289
Concurrent Document Opening allows us to push all of
these document-reading processes to background threads,

00:24:26.289 --> 00:24:28.579
allowing us to see a lot more of this guy.

00:24:28.579 --> 00:24:33.429
Less of this guy since we are no
longer blocking the main thread.

00:24:33.430 --> 00:24:37.230
And enabling Concurrent Document
Opening is fairly straightforward.

00:24:37.230 --> 00:24:43.069
You simply need to make sure, Step 1, that
your document creation process is thread-safe.

00:24:43.069 --> 00:24:48.149
There's several entry points in NSDocument,
including your init method and your reading method.

00:24:48.150 --> 00:24:51.940
First of all, you need to make sure
that you disable and do registration

00:24:51.940 --> 00:24:54.279
within those, for the duration of those methods.

00:24:54.279 --> 00:25:00.399
That's a good idea to do anyways, but it's especially
important in the context of Concurrent Document Opening.

00:25:00.400 --> 00:25:04.430
You also need to make sure that your
reading methods are thread-safe.

00:25:04.430 --> 00:25:10.640
That they can be run concurrently, open multiple
documents on background threads at the same time.

00:25:10.640 --> 00:25:16.360
The same goes for makeDocumentWithContentsOfURL
and openDocumentWithContentsOfURL display error.

00:25:16.359 --> 00:25:19.859
These overrides on NSDocumentController.

00:25:19.859 --> 00:25:27.289
Now chances are that your application overrides one or none
of these methods, in which case you need to do nothing.

00:25:27.289 --> 00:25:32.539
But TextEdit, for example, overrides
the openDocumentAsContentsOfURL

00:25:32.539 --> 00:25:38.139
to handle the transient document before
displaying either documents that are loaded.

00:25:38.140 --> 00:25:40.520
Just after doing that the second and final step is

00:25:40.519 --> 00:25:45.859
to override NSDocuments canConcurrentlyReadDocumentsOfType,
this class method.

00:25:45.859 --> 00:25:51.059
And ReturnYes for all the types that
you can safely read concurrently.

00:25:51.059 --> 00:25:55.909
And here we see the implementation for NS, for TextEdit.

00:25:55.910 --> 00:26:00.840
And we ReturnYes for any type that
is not HTML or web archived.

00:26:00.839 --> 00:26:05.509
That's because WebKit currently is unable to
read multiple HTML documents concurrently.

00:26:05.509 --> 00:26:09.150
So we ReturnNo for those types.

00:26:09.150 --> 00:26:11.509
So this is fairly straightforward and very worthwhile.

00:26:11.509 --> 00:26:19.660
Your users will really appreciate being able to do this and
not having the application spod while you're trying to load.

00:26:19.660 --> 00:26:27.240
Now, you're probably wondering what is this
type conformsToType and kuTTType constants?

00:26:27.240 --> 00:26:31.500
Hopefully you're familiar with them, but
if you're not we'll introduce them briefly.

00:26:31.500 --> 00:26:33.349
These are, deal with UTIs.

00:26:33.349 --> 00:26:36.109
They're Uniform Type Identifiers.

00:26:36.109 --> 00:26:44.069
UTIs extract all this various file type information that we
have the system including file extensions, HFS type codes,

00:26:44.069 --> 00:26:50.429
MIME types, NSPasteboard type names, and
your own custom NSDocument type names.

00:26:50.430 --> 00:26:56.850
They are organized in a unified hierarchical type system,
which allows you to reduce complexity when dealing

00:26:56.849 --> 00:27:01.299
with the interrelated types in your NSDocument applications.

00:27:01.299 --> 00:27:06.059
And in connection with this system.

00:27:06.059 --> 00:27:11.460
Snow Leopard recognizes over 400 UTIs out of
the box, and the UTI database is extensible

00:27:11.460 --> 00:27:14.819
with your own custom types and your own applications.

00:27:14.819 --> 00:27:21.589
So for adopting UTIs, in TextEdit
we first go to the Info.plist.

00:27:21.589 --> 00:27:31.859
Here we see the entry for the RTF type, and I've highlighted
the CFBundleType extensions, MIMETypes and OSTypes entries.

00:27:31.859 --> 00:27:36.759
Now, as I explained, all of these, all
this information is extracted away by UTIs,

00:27:36.759 --> 00:27:41.160
and we can actually completely get rid
of it and replace it with a single entry

00:27:41.160 --> 00:27:47.019
of LSItemContentTypes with the public .RTF UTI.

00:27:47.019 --> 00:27:51.769
Now, this is just a representative
sample of TextEdit's Info.plist.

00:27:51.769 --> 00:27:55.049
There are seven or eight types that TextEdit supports.

00:27:55.049 --> 00:28:01.409
And so you can imagine that this is a fairly,
this simplifies your Info.plist significantly.

00:28:01.410 --> 00:28:10.880
In the Info.plist we also switch from the NSPasteboard
type names to UTIs for the Services declarations.

00:28:10.880 --> 00:28:19.260
And in code wherever we were using the old custom
type names, we switched to the System Defined UTIs.

00:28:19.259 --> 00:28:25.750
Now, this carries with it an interesting implication,
because wherever we used to compare types with isEqual

00:28:25.750 --> 00:28:31.240
since they were just strings that we defined, that's
no longer strictly appropriate because that ignores all

00:28:31.240 --> 00:28:35.230
of the rich hierarchical information we have in UTIs.

00:28:35.230 --> 00:28:42.500
The proper thing to do is use this, as you saw before,
NSWorkspace API Type conformsToType which will ReturnYes

00:28:42.500 --> 00:28:48.470
if a type is the same as or a sub-type of another type.

00:28:48.470 --> 00:28:52.029
So this lets us access that information.

00:28:52.029 --> 00:28:58.269
Now, in TextEdit there are relatively few changes
that we needed to make to accommodate these things.

00:28:58.269 --> 00:29:02.639
Here you see five method overrides in
NSDocument and NSDocument Controller

00:29:02.640 --> 00:29:05.870
that either take types as arguments or return them.

00:29:05.869 --> 00:29:11.639
And so here we needed to make sure that we were
using the proper type names and using this new API.

00:29:11.640 --> 00:29:17.020
The same goes with the methods that
implement the services, the TextEdit events.

00:29:17.019 --> 00:29:24.480
Now, compare that with all of the various API and overrides
that are in TextEdit that didn't require any changes.

00:29:24.480 --> 00:29:27.000
And you can understand that this is a fairly simple change.

00:29:27.000 --> 00:29:34.170
The changes are well localized to a specific subset of
your code and it's not a very complicated thing to do.

00:29:34.170 --> 00:29:40.289
So hopefully you can extrapolate that to your own
applications, then participate in UTIs as well.

00:29:40.289 --> 00:29:43.690
The next enhancement is one that I really appreciate.

00:29:43.690 --> 00:29:45.759
It's Save As PDF.

00:29:45.759 --> 00:29:53.460
Now, if you're like me I have to remind
my wife and my mom fairly often how

00:29:53.460 --> 00:29:58.620
to save an arbitrary document as
a PDF in various applications.

00:29:58.619 --> 00:30:03.019
If you go to the Print panel, find
the Save As PDF button and do that.

00:30:03.019 --> 00:30:08.210
It's not a very discoverable UI,
especially for novice users.

00:30:08.210 --> 00:30:13.590
So we've provided in TextEdit this Save
As PDF menu item right under the Save

00:30:13.589 --> 00:30:15.809
As menu item, so it's much more discoverable.

00:30:15.809 --> 00:30:20.240
And you're probably thinking, well, in that case
I would have to do a lot of this work myself.

00:30:20.240 --> 00:30:22.809
That's a lot of additional code to maintain.

00:30:22.809 --> 00:30:29.649
And yes, we could have had you implement
dysfunctionality like so, taking care of the NSSavePanel.

00:30:29.650 --> 00:30:36.780
Bringing it up, setting it up, getting the response
and dealing with hidden file extensions and so forth.

00:30:36.779 --> 00:30:39.460
Not something we wanted to make you do.

00:30:39.460 --> 00:30:47.660
But here we see the NSPrintSave path entry in the
Dictionary that we passed to printDocumentWithSettings.

00:30:47.660 --> 00:30:53.779
If we actually can get rid of that, the
printDocumentWithSettings method will bring up the SavePanel

00:30:53.779 --> 00:30:57.359
for you and prompt the user, allowing
you to get rid of all this code.

00:30:57.359 --> 00:31:02.549
Making it a much simpler process it allows you to
maintain, and now you really have no excuse not

00:31:02.549 --> 00:31:04.559
to implement this in your own applications.

00:31:04.559 --> 00:31:08.599
Last but not least is Text Checking.

00:31:08.599 --> 00:31:14.799
There have been various types of text
checking that have existed in Mac OS X.

00:31:14.799 --> 00:31:17.009
It started in 10.0 and even earlier.

00:31:17.009 --> 00:31:18.180
Spell checking.

00:31:18.180 --> 00:31:19.049
And Leopard's.

00:31:19.049 --> 00:31:25.190
In Leopard we gained grammar checking,
automatic quote substitution, and link detection.

00:31:25.190 --> 00:31:31.650
In Snow Leopard we gained language and script
identification, data detectors, automatic dash substitution

00:31:31.650 --> 00:31:34.180
and text replacement and spelling correction.

00:31:34.180 --> 00:31:38.769
Some very powerful features, and we wanted
to adopt these in TextEdit to showcase them.

00:31:38.769 --> 00:31:44.029
And we'll see just how complicated this was to do.

00:31:44.029 --> 00:31:53.099
We simply added four preferences to the TextEdit
preferences pane and bound them to NSUserDevelopsController.

00:31:53.099 --> 00:31:58.109
And called for methods on NSTextView
to enable or disable them as requested.

00:31:58.109 --> 00:31:59.649
And that's it.

00:31:59.650 --> 00:32:01.330
Not very complicated in other words.

00:32:01.329 --> 00:32:08.000
And adopting that, if you use NSTextView should
be just as simple and we encourage you to do so.

00:32:08.000 --> 00:32:12.900
There's a lot more to the text
checking APIs in Snow Leopard.

00:32:12.900 --> 00:32:16.980
There are new APIs, both in NSTextView and in
the spell checker that are much more general

00:32:16.980 --> 00:32:20.089
and lets you do this text checking on arbitrary strings.

00:32:20.089 --> 00:32:27.230
There's API that lets you modify and do custom text
checking as well, and so we encourage you to find out more.

00:32:27.230 --> 00:32:32.650
Again, go to the Text Processing talk on Friday.

00:32:32.650 --> 00:32:34.860
So in summary, four enhancements.

00:32:34.859 --> 00:32:36.379
Concurrent Document Opening.

00:32:36.380 --> 00:32:41.600
Simply make sure that your document creation is
thread-safe and override one simple method on NSDocument.

00:32:41.599 --> 00:32:42.629
UTI Adoption.

00:32:42.630 --> 00:32:46.400
It really simplifies your code and your Info.plist.

00:32:46.400 --> 00:32:50.930
And involves fairly localized easy-to-understand changes.

00:32:50.930 --> 00:32:55.070
And Save As PDF UI plus one simple method implementation.

00:32:55.069 --> 00:32:56.129
And Text Checking.

00:32:56.130 --> 00:32:58.350
We added UI prefs and four method calls.

00:32:58.349 --> 00:32:59.849
All these things very simple.

00:32:59.849 --> 00:33:00.879
Very worthwhile.

00:33:00.880 --> 00:33:03.840
Please do the same in your own applications.

00:33:03.839 --> 00:33:07.209
Now, moving on to something completely different.

00:33:07.210 --> 00:33:08.579
NSCollectionView.

00:33:08.579 --> 00:33:11.529
Now, we've worked hard.

00:33:11.529 --> 00:33:15.599
Well, we introduced NSCollectionView in Leopard,
and there have been lots of improvements.

00:33:15.599 --> 00:33:18.000
We've worked really hard on it in Snow Leopard.

00:33:18.000 --> 00:33:24.380
And we've made sure to address all
of the, or as many of the bug reports

00:33:24.380 --> 00:33:29.840
that we could that you have so graciously filed on it.

00:33:29.839 --> 00:33:36.740
We've ensured smoother relayout animations, more
predictable layouts, and better auto-resizing behavior.

00:33:36.740 --> 00:33:42.839
The selection indexes method, propertyOnAsCollectionView
is now properly KVO-compliant

00:33:42.839 --> 00:33:46.399
as was advertised in the documentation for Leopard.

00:33:46.400 --> 00:33:47.509
And it's much more reliable.

00:33:47.509 --> 00:33:52.549
You shouldn't have to worry about any unexpected
crashes while using NSSelectionView in Snow Leopard.

00:33:52.549 --> 00:33:57.470
And there's much more that I think you will appreciate.

00:33:57.470 --> 00:34:03.009
One other big thing though, is that we noticed when
people were binding fairly complicated prototype views

00:34:03.009 --> 00:34:07.879
to their NSCollectionViewItem's
prototypes, sometimes during the replication

00:34:07.880 --> 00:34:12.860
of these prototype views, the bindings
would be inexplicably lost.

00:34:12.860 --> 00:34:15.800
And some people found various work-arounds for this,

00:34:15.800 --> 00:34:19.760
usually involving overriding NSCollectionViewItem's
copy with its own method.

00:34:19.760 --> 00:34:23.790
And there they would either set the bindings manually,

00:34:23.789 --> 00:34:29.150
or load a NIB that would provide the
view to the new collection view item.

00:34:29.150 --> 00:34:36.030
Now, we thought this was a really good idea, and we decided
to make some appropriate changes to do a similar thing.

00:34:36.030 --> 00:34:42.060
Here is the NSCollectionViewItem declaration in Leopard.

00:34:42.059 --> 00:34:44.960
In Snow Leopard we've made a significant change here.

00:34:44.960 --> 00:34:49.860
It's now no longer a subclass of
NSObject, but NSViewController.

00:34:49.860 --> 00:34:57.289
Thereby inheriting all of NSView Controller's NIB loading
behavior, making this a lot easier and a lot more reliable.

00:34:57.289 --> 00:35:02.500
Adopting this new NSCollectionViewItem
approach is very simple.

00:35:02.500 --> 00:35:06.199
You move your prototype view to a dedicated NIB.

00:35:06.199 --> 00:35:10.429
Connect the prototype view to the file's owner,
which is actually the NSCollectionViewItem,

00:35:10.429 --> 00:35:14.019
with your bindings and other connections.

00:35:14.019 --> 00:35:20.360
And in, where you instantiate your
NSCollectionViewItem in your NIB, you set the NIB name

00:35:20.360 --> 00:35:25.910
and bundle identifier there so it can find that NIB.

00:35:25.909 --> 00:35:33.539
This not only allows us to do exact replication of your
item views, but it also allows us to do more efficient

00:35:33.539 --> 00:35:37.000
and lazy loading of each of the item views.

00:35:37.000 --> 00:35:43.639
So it allows you to have collection views with many,
many more contents because all of that is done lazily.

00:35:43.639 --> 00:35:46.279
This is also completely backwards compatible with Leopard.

00:35:46.280 --> 00:35:49.830
If you make no changes to your
applications using NSCollectionView,

00:35:49.829 --> 00:35:54.440
it will still work fine just as it did in Leopard.

00:35:55.739 --> 00:36:01.649
So, but we really encourage you to make those
changes because it is so simple and very worthwhile.

00:36:01.650 --> 00:36:09.190
So we actually have a quick demo just
to show you how simple this is to do.

00:36:09.190 --> 00:36:12.700
So if you have used NSCollectionView
you've probably looked at this sample code.

00:36:12.699 --> 00:36:18.569
It's a really great sample icon
collection that shows you how this works.

00:36:18.570 --> 00:36:19.210
You can see.

00:36:19.210 --> 00:36:24.539
I'll demonstrate for you just how well
NSCollectionView is working in Snow Leopard.

00:36:24.539 --> 00:36:33.519
Things are very smooth looking, and this is even without
Layer Back Mode on, so that's just a demo for that.

00:36:33.519 --> 00:36:38.039
So now we'll do the work very quickly
in just a couple minutes

00:36:38.039 --> 00:36:42.889
to use the new NIB loading behavior for our prototype views.

00:36:42.889 --> 00:36:49.960
So here we see the NIB that contains our
NSCollectionView and the prototype view.

00:36:49.960 --> 00:36:58.070
We're actually going to cut this view out of
this NIB completely and create a new view NIB.

00:36:58.070 --> 00:37:01.970
Get rid of the one it gives us there and
paste in the one from the other NIB there.

00:37:01.969 --> 00:37:11.899
Now, the next step is to create, to make the
file's owner the NSCollectionViewItem and connect

00:37:11.900 --> 00:37:16.960
that to the view so it knows what view to load.

00:37:16.960 --> 00:37:23.199
Now, we need to rebind all of the bindings
from this view to the NSCollectionViewItem.

00:37:23.199 --> 00:37:34.439
So the first is we set the transparent property,
bind that to the filesOwnersRepresented.

00:37:34.440 --> 00:37:37.679
Oh, actually the selected property.

00:37:37.679 --> 00:37:39.989
And will NS negate Boolean.

00:37:39.989 --> 00:37:47.509
This will allow us to simulate the selection highlight
since this is a box drawing a background here.

00:37:47.510 --> 00:37:50.150
And here is our prototype view.

00:37:50.150 --> 00:37:58.920
We want to bind this image view to the
filesOwnersRepresentedObject.iconproperty.

00:37:58.920 --> 00:38:05.220
And we'll rebind this to the filesOwners,
this text view, RepresentedObject.name.

00:38:05.219 --> 00:38:08.709
Go ahead and save this.

00:38:08.710 --> 00:38:14.050
It's ViewPrototype, is what we'll call
it, and we'll add it to our project.

00:38:14.050 --> 00:38:20.600
And we come back here to our CollectionViewItem
we've instantiated here.

00:38:20.599 --> 00:38:22.219
And here it sets to.

00:38:22.219 --> 00:38:27.379
We've set it to load the ViewPrototype NIB,
and that's all the changes we need there.

00:38:27.380 --> 00:38:29.180
Make sure those are saved.

00:38:29.179 --> 00:38:30.730
Come back and run.

00:38:30.730 --> 00:38:33.789
And you see its working just as it did before.

00:38:33.789 --> 00:38:37.730
It's not a flashy demo, but it shows
you just how simple it is to do,

00:38:37.730 --> 00:38:42.300
and we have a CollectionView that's
working exactly as it did before.

00:38:42.300 --> 00:38:47.340
So we really encourage you to make that
transition in your NSCollectionViews.

00:38:47.340 --> 00:38:51.750
Now, there's one last feature that we added to
NSCollectionView that I'd like to demonstrate for you,

00:38:51.750 --> 00:38:56.159
so let's TextEdit here and select a few things

00:38:56.159 --> 00:39:00.859
And Drag and Drop.

00:39:00.860 --> 00:39:10.340
We have. Now, Drag and Drop support in NSCollectionView,
one of the most requested features in NSCollectionView, so.

00:39:10.340 --> 00:39:12.010
Yes.

00:39:12.010 --> 00:39:16.940
[ Clapping]

00:39:16.940 --> 00:39:19.269
That really, Drag and Drop really brings us up to par

00:39:19.269 --> 00:39:25.539
with the other Collection-type views,
NSTableView and NSBrowser and so forth.

00:39:25.539 --> 00:39:33.909
And you'll find that the APIs are very familiar
if you've used NSTableView's Drag and Drop APIs.

00:39:33.909 --> 00:39:39.789
The APIs use indexes for efficiency's sake,
so we're not shoveling around larger arrays

00:39:39.789 --> 00:39:43.440
of represented objects or NSCollectionView items.

00:39:43.440 --> 00:39:46.250
And we have new APIs to facilitate this.

00:39:46.250 --> 00:39:52.170
ItemAtIndex, which, which will return the
NSCollectionView item for a given index in the collection.

00:39:52.170 --> 00:39:59.599
And frameForItemAtIndex will return the frame that
a view will be displayed in on the CollectionView.

00:39:59.599 --> 00:40:06.110
This will return the result without
even loading the view from the NIB,

00:40:06.110 --> 00:40:10.110
so this allows us to continuously be loading our views.

00:40:10.110 --> 00:40:15.000
Of course, the Drag and Drop API allows
for local reordering as you'd expect.

00:40:15.000 --> 00:40:17.289
And is compatible with all NSDrag Pasteboard clients.

00:40:17.289 --> 00:40:24.309
Anything using the NSDrag Pasteboard will
work as you'd expect with NSCollectionView.

00:40:24.309 --> 00:40:29.059
The gesture to perform a Drag and Drop is a click-and-hold.

00:40:29.059 --> 00:40:37.340
We have to do this to differentiate
Drag Selection from Drag and Drop.

00:40:37.340 --> 00:40:41.420
But we encourage you to start using CollectionView.

00:40:41.420 --> 00:40:43.050
There's lots of new features there.

00:40:43.050 --> 00:40:48.720
Moving on to some of NSCollectionView's
distant cousins, NSTableView and NSBrowser,

00:40:48.719 --> 00:40:52.219
there's going to be a talk devoted to these two classes,

00:40:52.219 --> 00:40:55.539
Presenting User Data with TableViews
and Browsers on Thursday.

00:40:55.539 --> 00:40:59.269
We encourage you to see that if you
want more detail about the enhancements.

00:40:59.269 --> 00:41:01.320
The many enhancements in these classes.

00:41:01.320 --> 00:41:03.260
But here's a few highlights.

00:41:03.260 --> 00:41:07.270
NSTableView now has API to reload
specific rows and columns if you know

00:41:07.269 --> 00:41:09.920
that the data backing those rows and columns have changed.

00:41:09.920 --> 00:41:15.820
So you don't have to load the entire
view, which can be inefficient.

00:41:15.820 --> 00:41:23.539
We've allowed much more customization of the selection
highlight behavior and drag destination highlight behavior.

00:41:23.539 --> 00:41:30.210
And you can control which cells or columns can
receive focus as you tab through a TableView.

00:41:30.210 --> 00:41:31.909
You can configure a column.

00:41:31.909 --> 00:41:36.559
Each individual tableColumnSizetoFitBehavior
when you double-click on the column header.

00:41:36.559 --> 00:41:39.219
You can configure how that will resize.

00:41:39.219 --> 00:41:46.539
And you can control which columns and how it can be
ordered by the user and how those columns can be reordered

00:41:47.699 --> 00:41:50.069
NSBrowser has some significant new APIs.

00:41:50.070 --> 00:41:58.140
If you're familiar with NSBrowser the old way to do
it was the delegate was told to push a whole bunch

00:41:58.139 --> 00:42:05.730
of items themselves into an NSMatrix, and you'd
have to do that for each column of the browser.

00:42:05.730 --> 00:42:10.519
This wasn't very intuitive and made it somewhat
cumbersome for people to use NSBrowser.

00:42:10.519 --> 00:42:17.590
But we provided a new item-based API, which will pull
information from the delegate about a tree of items.

00:42:17.590 --> 00:42:23.620
It's much more intuitive and will make
NSBrowser a lot easier to use than Snow Leopard.

00:42:23.619 --> 00:42:30.289
There are several other APIs and enhancements, most
of which require using the new item-based delegate,

00:42:30.289 --> 00:42:34.059
so we really encourage you to switch as soon as possible.

00:42:34.059 --> 00:42:41.820
Some of these include variable row heights,
allowing the user to edit the contents of a browser.

00:42:41.820 --> 00:42:45.039
And custom preview columns and column headers.

00:42:45.039 --> 00:42:47.259
Now, what are those, you ask.

00:42:47.260 --> 00:42:50.130
Here's a screen shot of Finder.

00:42:50.130 --> 00:42:57.260
As you know, as you heard from the keynote, Finder
is now using Cocoa and indeed it does use NSBrowser.

00:42:57.260 --> 00:43:02.080
And here's a screen shot of, we've
connected to a server and selected a file.

00:43:02.079 --> 00:43:07.569
This part that shows the information about a server is
a column header, and this part that shows information

00:43:07.570 --> 00:43:09.519
about the selected file is a preview column.

00:43:09.519 --> 00:43:14.769
Using these new APIs you can replicate
all of this behavior exactly.

00:43:14.769 --> 00:43:17.539
So that's all for those topics.

00:43:17.539 --> 00:43:18.570
We'll move on.

00:43:18.570 --> 00:43:20.010
Back to Ali.

00:43:20.010 --> 00:43:26.190
[ Clapping ]

00:43:26.190 --> 00:43:30.159
So now I'd like to talk a bit about File System Efficiency.

00:43:30.159 --> 00:43:35.579
File System Efficiency is a large effort we undertook in
Snow Leopard to reduce the number of times we hit the disc.

00:43:35.579 --> 00:43:41.739
As you know, disc drives and especially
network drives, network servers, etc.,

00:43:41.739 --> 00:43:43.649
can be unpredictable as far as performance.

00:43:43.650 --> 00:43:47.910
And they often are an important piece
of the application performance puzzle.

00:43:47.909 --> 00:43:52.149
So to that end, we focused on developing
NSURL as a central API

00:43:52.150 --> 00:43:56.760
to reference files, and also to get information about them.

00:43:56.760 --> 00:44:00.890
So NSURL now provides much more complete
access to things you want to know about files.

00:44:00.889 --> 00:44:02.920
So file properties basically.

00:44:02.920 --> 00:44:08.490
And one thing this does is this eliminates the
need to convert between various representations.

00:44:08.489 --> 00:44:12.029
You no longer have to convert to an FSRef
to get this information or convert back

00:44:12.030 --> 00:44:15.050
to a POSIX path to get that information and so on.

00:44:15.050 --> 00:44:18.590
In addition, we now cache property values in NSURL.

00:44:18.590 --> 00:44:24.000
So that if two different parts of the program ask the
same NSURL for the same property in a very short time

00:44:24.000 --> 00:44:27.579
where it hasn't changed, NSURL can respond very quickly.

00:44:27.579 --> 00:44:32.940
We also took this opportunity to do some API
enhancements and improve and add more NS errors

00:44:32.940 --> 00:44:36.360
and provide better error reporting throughout.

00:44:36.360 --> 00:44:40.660
So the property access in NSURL is fairly straightforward.

00:44:40.659 --> 00:44:41.469
getProperty.

00:44:41.469 --> 00:44:41.919
Oh, I'm sorry.

00:44:41.920 --> 00:44:44.340
getResourceValue and setResourceValue.

00:44:44.340 --> 00:44:47.970
These two APIs get or set the value of one property.

00:44:47.969 --> 00:44:53.089
You can also use the bulk versions
resourceValuesforKeys, or setResourceValues.

00:44:53.090 --> 00:44:55.720
Now the properties you can use here, there's a lot.

00:44:55.719 --> 00:44:59.839
And I'm just going to give you a small sampling here.

00:44:59.840 --> 00:45:02.110
You can get or set the name, for instance.

00:45:02.110 --> 00:45:03.860
You can ask for the localized name.

00:45:03.860 --> 00:45:10.309
You can ask whether it's a package, etc. Now note that
some of these properties the values are actually NSImages

00:45:10.309 --> 00:45:14.690
or NSColors, and these are AppKit
objects while this is foundation API.

00:45:14.690 --> 00:45:20.050
So these APIs will return these answers
if AppKit is loaded into your application,

00:45:20.050 --> 00:45:24.360
which of course it almost always is for Cocoa applications.

00:45:24.360 --> 00:45:26.970
We also added NSURL Path Utilities.

00:45:26.969 --> 00:45:31.539
You might be familiar with NSString Path
Utilities where you can manipulate paths, you know.

00:45:31.539 --> 00:45:34.239
Add file extensions, remove components and so on.

00:45:34.239 --> 00:45:37.250
We now have the equivalent for NSURL.

00:45:37.250 --> 00:45:39.769
[Applause] Thank you.

00:45:42.300 --> 00:45:47.100
And we also have this one other notion,
this new concept of File Reference URL.

00:45:47.099 --> 00:45:56.389
Many of you may be familiar with FSRefs which basically are
file references that can actually track a file by reference,

00:45:56.389 --> 00:46:02.000
by ID so that the reference is valid even
if the file is renamed or its parent

00:46:02.000 --> 00:46:04.199
Any of its parent directories have been renamed.

00:46:04.199 --> 00:46:06.489
This is useful in some specialized cases.

00:46:06.489 --> 00:46:09.039
So NSURL now also features this.

00:46:09.039 --> 00:46:13.150
Basically you create one with the
method called File Reference URL.

00:46:13.150 --> 00:46:14.340
Here's an example.

00:46:14.340 --> 00:46:16.850
I'm creating one URL, a filePath URL.

00:46:16.849 --> 00:46:22.139
And then I'm creating another, a second URL
which is a fileReference version of that URL.

00:46:22.139 --> 00:46:24.199
Here's what the two URLs would look like.

00:46:24.199 --> 00:46:25.679
Now, they reference the same file.

00:46:25.679 --> 00:46:30.769
However, the first one has a path in it
while the second one has this ID in it.

00:46:30.769 --> 00:46:37.610
But note that the second one is still an RFC
compliant file: URL, so it's still a very valid URL.

00:46:37.610 --> 00:46:40.880
Now, this is transparent for most uses.

00:46:40.880 --> 00:46:42.930
Meaning you can still access resource values.

00:46:42.929 --> 00:46:45.960
You can extract the path and so on.

00:46:45.960 --> 00:46:48.409
However, it is really for specialized uses.

00:46:48.409 --> 00:46:54.549
For instance, in the context of a regular application
you probably only want to use this for the files

00:46:54.550 --> 00:46:59.560
that the user might manipulate and move around,
and that often involves documents, for instance.

00:46:59.559 --> 00:47:05.019
And since NSDocument already uses this facility
you might not actually need to yourself.

00:47:05.019 --> 00:47:09.849
Another thing to note here is that although this looks like
it might be a good solution, this is actually not a good--

00:47:09.849 --> 00:47:15.089
this is not meant for persistent, because
the ID you get there might be different

00:47:15.090 --> 00:47:17.079
between different reboots of the machine.

00:47:17.079 --> 00:47:22.529
So this might not continue referencing
the same file correctly after a reboot.

00:47:22.530 --> 00:47:25.080
For persistence you actually want to use bookmarks.

00:47:25.079 --> 00:47:29.549
We have this new concept of URL
Bookmarks, which is basically an NSData

00:47:29.550 --> 00:47:32.730
that contains a persistent form of NSURL.

00:47:32.730 --> 00:47:37.900
You create one with this API here,
bookmarkDataWithOptions, and it returns NSData for you.

00:47:37.900 --> 00:47:43.360
Now the options here include the ability to ask for
a fairly minimal piece of bookmark data for instance.

00:47:43.360 --> 00:47:49.530
Or you can even choose to ask for bookmark data,
which is the same as an alias data file from 10.5.

00:47:49.530 --> 00:47:55.580
So you can actually save these away and read
them back as alias files on previous releases.

00:47:55.579 --> 00:48:01.799
To recreate an NSURL back from a bookmark you
would use this API, URLByReservingBookmarkData.

00:48:01.800 --> 00:48:03.990
There are two options here I believe.

00:48:03.989 --> 00:48:09.919
The first option says whether this API should
mount volumes, if volumes need to be mounted.

00:48:09.920 --> 00:48:16.730
And the second API says where this API should put
up UI if authentication or any other UI is needed.

00:48:16.730 --> 00:48:20.969
And of course if you don't provide those options
and those are needed, then this API will fail

00:48:20.969 --> 00:48:24.299
and return an error into NSErrorArgument.

00:48:24.300 --> 00:48:30.370
NSFileManager has a lot of changes again,
to support this new NSURL direction.

00:48:30.369 --> 00:48:34.819
NSURL versions of existing functionality
in here are just three samples.

00:48:34.820 --> 00:48:39.530
Copy, move and removeItem now have URL versions.

00:48:39.530 --> 00:48:43.080
We also can now do Directory Enumeration with URLs.

00:48:43.079 --> 00:48:47.049
This new API returns a Directory enumerator like before.

00:48:47.050 --> 00:48:50.170
Now, note that there are some extra
arguments here for enumeration.

00:48:50.170 --> 00:48:51.250
One of the arguments is keys.

00:48:51.250 --> 00:48:55.940
You can provide as a hint the list
of properties you're going to fetch.

00:48:55.940 --> 00:49:00.289
This is just a hint, but if you provide this
list this API might pre-fetch these properties

00:49:00.289 --> 00:49:03.489
for you making it faster to enumerate through the items.

00:49:03.489 --> 00:49:05.979
You would provide nil if you just want the default behavior.

00:49:05.980 --> 00:49:08.820
You can always of course ask for other properties as well.

00:49:08.820 --> 00:49:10.750
It's just this might speed things up a bit.

00:49:10.750 --> 00:49:17.710
The options argument allows you to skip subdirectories
or skip package contents, which is actually quite nice.

00:49:17.710 --> 00:49:19.909
And skip hidden files if you want.

00:49:19.909 --> 00:49:23.589
And finally note that this API takes an error handler.

00:49:23.590 --> 00:49:25.329
It will be invoked on every error.

00:49:25.329 --> 00:49:30.349
If you ReturnNo from this on any
error then the enumeration stops.

00:49:30.349 --> 00:49:33.269
NSFileManager also has a Safe Saving API.

00:49:33.269 --> 00:49:38.989
This is equivalent to the FSExchangeObject
API that we have in Carbon.

00:49:38.989 --> 00:49:41.209
Most of the time you do not need to use this.

00:49:41.210 --> 00:49:44.220
You can get away with just saving files
atomically and that's good enough.

00:49:44.219 --> 00:49:50.849
But this is what you really need to do
document level saving totally correctly.

00:49:50.849 --> 00:49:54.960
And since NSDocument uses this, you may never need to.

00:49:54.960 --> 00:49:58.500
But of course, if you're writing your own
document-based application not using NSDocument,

00:49:58.500 --> 00:50:02.769
this is a good API to look at.

00:50:02.769 --> 00:50:08.409
Now, FileWrapper may get the award for one
of the most improved classes in Snow Leopard.

00:50:08.409 --> 00:50:12.329
And of course, many of you might be
thinking FileWrapper, what's that?

00:50:12.329 --> 00:50:14.179
What does it do for me?

00:50:14.179 --> 00:50:15.710
It's an often-ignored class.

00:50:15.710 --> 00:50:19.389
What FileWrapper does it's a representation
of File Packages.

00:50:19.389 --> 00:50:22.460
It can represent flat files, symbolic links.

00:50:22.460 --> 00:50:27.920
But more commonly it represents a folder full
of other files, which represents a document.

00:50:27.920 --> 00:50:29.809
What we call a File Package.

00:50:29.809 --> 00:50:32.380
In Snow Leopard there's a lot of API cleanup.

00:50:32.380 --> 00:50:35.019
We now use NSURLs, return NSErrors.

00:50:35.019 --> 00:50:37.860
And we've also given control over
lazy and mapping behaviors,

00:50:37.860 --> 00:50:40.789
and implementation was just pretty
much overhauled throughout.

00:50:40.789 --> 00:50:43.800
FileWrapper also has more complete support for metadata.

00:50:43.800 --> 00:50:50.170
It will now preserve extended attributes,
for instance, of the files you put into it.

00:50:50.170 --> 00:50:51.409
[Applause] Thank you.

00:50:51.409 --> 00:50:53.819
Some FileWrapper fans out there.

00:50:53.820 --> 00:50:55.230
Now, here's the Reading APIs.

00:50:55.230 --> 00:50:58.449
initWithURL, readFromURL.

00:50:58.449 --> 00:51:03.159
Now, NSFileWrapper typically tries to do the right thing.

00:51:03.159 --> 00:51:07.420
What this means is if you have a pretty
large folder with a lot of files in it,

00:51:07.420 --> 00:51:12.289
FileWrapper will not read the whole thing into memory,
for instance, because, you know, it doesn't need to.

00:51:12.289 --> 00:51:13.630
That's a default behavior.

00:51:13.630 --> 00:51:18.289
However, note this scenario where the user
drags a, say, a folder into your application

00:51:18.289 --> 00:51:21.769
and the next thing they do is they'll
go and delete that folder.

00:51:21.769 --> 00:51:25.400
So to accommodate those kinds of
scenarios we do have various options.

00:51:25.400 --> 00:51:30.309
The immediate option means do copy everything into
memory, and this is something you might want to use

00:51:30.309 --> 00:51:35.880
when the first time an attachment or a
document is brought into your application.

00:51:35.880 --> 00:51:40.740
Of course, after that when you create FileWrappers
for places you know you might not need this.

00:51:40.739 --> 00:51:43.239
The other option is the do it without mapping option.

00:51:43.239 --> 00:51:47.429
FileWrapper might often use File System
Mapping as a way to optimize its behavior.

00:51:47.429 --> 00:51:51.589
And it will avoid File System Mapping when it knows
the files are coming from a network directory.

00:51:51.590 --> 00:51:56.829
But there are times when you might know better, so
you can provide this option to say don'tMapAtAll.

00:51:56.829 --> 00:51:59.460
For writing there's this writeToURL API.

00:51:59.460 --> 00:52:05.470
This also has some options, but I actually want to talk
about the third argument here, the original argument.

00:52:05.469 --> 00:52:08.759
This method now does a very good job of incremental saving.

00:52:08.760 --> 00:52:13.280
What this means is if you already have
your FileWrapper saved on disc somewhere

00:52:13.280 --> 00:52:16.950
and you're saving it elsewhere with
a little, did some modifications.

00:52:16.949 --> 00:52:21.789
If you provide the location of the original one,
FileWrapper will actually use hard linking as a way

00:52:21.789 --> 00:52:25.550
to very efficiently copy the items
that have not changed in between.

00:52:25.550 --> 00:52:31.500
So it enables incremental saving
and does a very good job of it.

00:52:31.500 --> 00:52:37.000
And I mean, notice like even something like a
keynote document, this presentation we have here.

00:52:37.000 --> 00:52:41.750
Or let's actually talk about presentations you saw
yesterday which have multi-megabyte movies in them.

00:52:41.750 --> 00:52:45.929
Most of the time when the user hits Save, all
they're changing is the text in the slides.

00:52:45.929 --> 00:52:49.460
They're not changing the movies, the sounds, the pictures.

00:52:49.460 --> 00:52:54.449
So FileWrapper can just hard link those, so it's a good win.

00:52:54.449 --> 00:52:56.529
NSWorkspace we talked about before.

00:52:56.530 --> 00:52:58.160
Here's a few other changes.

00:52:58.159 --> 00:53:00.569
The NSURL changes, I just want to highlight these.

00:53:00.570 --> 00:53:04.530
It now has asynchronous file copy and recycle methods.

00:53:04.530 --> 00:53:11.010
Now, these are truly asynchronous, meaning you call
these, the file copy or recycle starts to happen

00:53:11.010 --> 00:53:13.250
and these methods return while still going on.

00:53:13.250 --> 00:53:15.219
So this is analogous.

00:53:15.219 --> 00:53:17.059
Earlier we used a carwash analogy.

00:53:17.059 --> 00:53:21.940
This is analogous to you going to the carwash,
giving them your keys, going back home

00:53:21.940 --> 00:53:25.820
and then they call you later you tell you your
car is ready, so that's what this one does.

00:53:25.820 --> 00:53:31.070
And the callback here is the completion
handler block that both of these take.

00:53:31.070 --> 00:53:34.000
And I want to give you an example of how these work.

00:53:34.000 --> 00:53:35.809
Let's say you want to duplicate three files.

00:53:35.809 --> 00:53:39.929
One of these files has already been copied before.

00:53:39.929 --> 00:53:41.940
Another one of these has not been copied before.

00:53:41.940 --> 00:53:44.320
And the third one actually does not exist.

00:53:44.320 --> 00:53:51.760
So when you call the duplicateURL's API the results you get
back are you're going to get back this Dictionary, newURLs.

00:53:51.760 --> 00:53:57.480
It's going to tell you that the item that was not
yet copied has been copied as NotYetCopied copy.

00:53:57.480 --> 00:54:02.840
But note that the one that was already copied
is going to be copied as AlreadyCopied copy 2,

00:54:02.840 --> 00:54:04.559
because that's what the Finder would have done of course.

00:54:04.559 --> 00:54:07.099
So it actually tells you what the name of the copy is.

00:54:07.099 --> 00:54:09.489
And finally, note that you'll get back an error,

00:54:09.489 --> 00:54:13.859
which tells you that the file Nonexistent could
not be duplicated because it was not found.

00:54:13.860 --> 00:54:20.160
And again, these error messages will adjust themselves if
there are multiple files that cannot be copied and so on.

00:54:20.159 --> 00:54:24.809
Now, at this point I just want
to pause and talk about NSErrors.

00:54:24.809 --> 00:54:28.309
You're seeing a lot of NSError
arguments in these APIs we're adding.

00:54:28.309 --> 00:54:36.719
But note that we're adding NSError API, NSError
arguments to APIs where having NSError matters.

00:54:36.719 --> 00:54:39.179
We don't add NSError arguments to every single API.

00:54:39.179 --> 00:54:41.139
In fact, we add it to a small subset of new APIs.

00:54:41.139 --> 00:54:47.069
But we add it in cases where it matters, because
where the error is going to be bubbled up to the user.

00:54:47.070 --> 00:54:53.400
And we want you and your applications to be able to
present these errors without having to parse them apart,

00:54:53.400 --> 00:54:55.139
tell what the kind of error it is, you know.

00:54:55.139 --> 00:54:56.639
Have a big switch statement and so on.

00:54:56.639 --> 00:54:58.980
You just want to take this as-is and present it to the user

00:54:58.980 --> 00:55:03.309
and have the appropriate warnings,
recovery options and so on displayed.

00:55:03.309 --> 00:55:06.690
And so that's what we really encourage you to do as well.

00:55:06.690 --> 00:55:11.869
You know, if you add NSErrors in your program, choose the
places where they will really matter and do a great job

00:55:11.869 --> 00:55:15.279
of making sure the user never gets
some, you know, horrible error message.

00:55:15.280 --> 00:55:19.950
That they're always clear and concise,
and tell the user how to recover from it.

00:55:19.949 --> 00:55:25.409
OK. So at this point I just want to
touch upon a few remaining topics.

00:55:25.409 --> 00:55:27.949
Shorter topics.

00:55:27.949 --> 00:55:30.019
So one is NSSavePanel.

00:55:30.019 --> 00:55:32.710
There's a bunch of changes in NSSavePanel.

00:55:32.710 --> 00:55:39.070
One of the tuning methods we've added are to do sheets
using blocks, which is actually a very natural step.

00:55:39.070 --> 00:55:39.769
So here are the two APIs.

00:55:39.769 --> 00:55:46.800
And I want to show you how these APIs,
how these work compared to Leopard.

00:55:46.800 --> 00:55:50.519
So here is how you brought up a save sheet in Leopard.

00:55:50.519 --> 00:55:53.019
You would basically create a savePanel,
and then you would go out

00:55:53.019 --> 00:55:56.360
and call beginSheetForDirectory
and provide it six arguments.

00:55:56.360 --> 00:56:01.769
Two of the arguments were an object
to invoke, and a Selector to invoke

00:56:01.769 --> 00:56:04.579
on that object when the user dismissed the SavePanel.

00:56:04.579 --> 00:56:07.789
And then you would implement that method, of course.

00:56:07.789 --> 00:56:10.869
Here is the saveDone:returnCode:context: method.

00:56:10.869 --> 00:56:14.670
The context allow you to pass some context
in, because sometimes you need to do that.

00:56:14.670 --> 00:56:18.320
And in that method you can look at the
result and do whatever you need to do.

00:56:18.320 --> 00:56:21.490
In Snow Leopard this has been reduced to just this.

00:56:21.489 --> 00:56:23.289
It's pretty much equivalent.

00:56:23.289 --> 00:56:27.029
You now call this method beginSheetModalForWindow
and it takes two arguments.

00:56:27.030 --> 00:56:32.519
And the second argument it the blockToExecute
when the Save Panel is dismissed.

00:56:32.519 --> 00:56:38.360
Note that the work you do here in Leopard is the same as
the work you do here, so it's exactly the same code as far

00:56:38.360 --> 00:56:41.829
as the amount of the work that's been done.

00:56:41.829 --> 00:56:45.179
Now, also note that in the Leopard
case here there are three arguments.

00:56:45.179 --> 00:56:47.669
The panel, the return code, and the context.

00:56:47.670 --> 00:56:52.159
While in the block version there's only
one argument, and that's the result.

00:56:52.159 --> 00:56:58.849
That's because anything else that needs to be passed into
this block can actually be captured as a part of the block.

00:56:58.849 --> 00:57:04.969
For instance, note here that the panel, which we
created here, is actually captured by the block,

00:57:04.969 --> 00:57:06.929
so we don't need to pass it as an argument.

00:57:06.929 --> 00:57:08.859
And the same of course goes for the context.

00:57:08.860 --> 00:57:15.690
Blocks are a great way to eliminate all these context
arguments that we need to add in a few places.

00:57:15.690 --> 00:57:22.710
Now, while speaking of NSSavePanel, there's actually
a few nifty openSavePanel user level features

00:57:22.710 --> 00:57:25.010
that I'd like to highlight for you.

00:57:25.010 --> 00:57:30.330
[ Silence ]

00:57:30.329 --> 00:57:36.469
So one of them is that you can now right-click on the
column header in ListView and add additional columns.

00:57:36.469 --> 00:57:38.419
So here is your OpenPanel for instance.

00:57:38.420 --> 00:57:39.269
Just right-click.

00:57:39.269 --> 00:57:42.230
There's a bunch of columns to select from and bingo.

00:57:42.230 --> 00:57:45.949
You now have your kind and your
size columns in your OpenPanel.

00:57:48.070 --> 00:57:52.570
You can now hit cmd-shift-period
to temporarily view hidden files.

00:57:52.570 --> 00:57:54.190
There you go.

00:57:55.860 --> 00:57:57.360
Oops. Let me show that again.

00:57:57.360 --> 00:57:58.650
Sorry. OK.

00:57:58.650 --> 00:57:59.680
Slow motion.

00:57:59.679 --> 00:58:00.429
Bam. There you go.

00:58:00.429 --> 00:58:05.750
OK. And note that the user can do this
in the context of any application.

00:58:05.750 --> 00:58:08.090
There's also API that lets you control this better.

00:58:08.090 --> 00:58:13.230
So if you decide your application needs to edit that
command, these .files or hidden files on a regular basis,

00:58:13.230 --> 00:58:17.179
you can actually control this by
providing UI for the user if you wish.

00:58:17.179 --> 00:58:19.190
Here's another option.

00:58:19.190 --> 00:58:20.409
Kevin touched upon this earlier.

00:58:20.409 --> 00:58:21.980
But you can now double-click.

00:58:21.980 --> 00:58:26.250
In the case of OpenPanel you hit right edge of
the header to automatically resize a column.

00:58:26.250 --> 00:58:30.360
So here is the Kind column, which is a bit truncated.

00:58:30.360 --> 00:58:33.450
You go ahead and double-click right
there and it will autosize

00:58:33.449 --> 00:58:36.389
to show the contents, and that
of course works on any column.

00:58:36.389 --> 00:58:42.299
And last but not least you can now hit Space
in the OpenPanel to Quick Look selected files.

00:58:42.300 --> 00:58:43.920
So here we have a selected item.

00:58:43.920 --> 00:58:46.889
Hit Space, and you will be able to Quick Look the files.

00:58:46.889 --> 00:58:52.069
And if you have.,.if you have multiple
items you can go back and forth

00:58:52.070 --> 00:59:00.240
and still this way more carefully select
exactly what file it is that you want to open.

00:59:00.239 --> 00:59:06.589
Now, NSImage also probably gets an award for
most improved overhauled class in Snow Leopard.

00:59:06.590 --> 00:59:13.630
And NSImage, by the way, is also another example of the
benefits of Cocoa Extraction where we have done a ton

00:59:13.630 --> 00:59:19.289
of implementation changes under the hood and, but in
a binder compatible way for most clients and the way

00:59:19.289 --> 00:59:21.750
which gets you a lot of performance benefits.

00:59:21.750 --> 00:59:24.949
So performance benefits is a big part here.

00:59:24.949 --> 00:59:31.379
One way to achieve this with better
impedence, match with the Quartz-type CGImage.

00:59:31.380 --> 00:59:34.220
And we also no longer cache images in windows.

00:59:34.219 --> 00:59:39.349
We actually cache them in other ways, which are
much more compatible with Quartz and much faster.

00:59:39.349 --> 00:59:44.500
We also took this opportunity to introduce
some APIs and deprecate some APIs as well.

00:59:44.500 --> 00:59:49.940
Now, I'm just going to enumerate these APIs very quickly
but, and give a pointer to a session where this is covered.

00:59:49.940 --> 00:59:56.039
You can now create NSIMage directly from CGImage
and you can also very efficiently extra a CGImage.

00:59:56.039 --> 00:59:58.170
You now have.

00:59:58.170 --> 00:59:59.099
[Applause] Thank you.

00:59:59.099 --> 01:00:03.150
You now have better control over
drawing parameters of NSImages.

01:00:03.150 --> 01:00:05.840
You can now hit-test a point or a rectangle in an image.

01:00:05.840 --> 01:00:10.440
And what I mean by that is you can check a
point or a rectangle to see if it's transparent.

01:00:10.440 --> 01:00:14.460
This is, for instance, one thing, which
previously required you to extract pixels.

01:00:14.460 --> 01:00:19.269
Rummage through the pixels, figure out the bitmap
format just to see whether it was transparent.

01:00:19.269 --> 01:00:20.679
You can now do this with one API.

01:00:20.679 --> 01:00:25.940
You can now automatically interpret, this
is actually automatically done for you,

01:00:25.940 --> 01:00:31.610
orientation info of pictures coming from
cameras so they will appear correctly.

01:00:32.940 --> 01:00:38.710
And you can set accessibility in the description, which
means when the image is displayed in various contexts,

01:00:38.710 --> 01:00:42.440
VoiceOver will be able to read the description to users.

01:00:42.440 --> 01:00:46.789
And you can pass NSImage directly into
Core Animation setContentsMethodNow,

01:00:46.789 --> 01:00:50.269
while before you had to extra a CGImage.

01:00:50.269 --> 01:00:52.659
And we now have many new standard images.

01:00:52.659 --> 01:00:55.029
As you know in 10.5 we started this.

01:00:55.030 --> 01:01:00.780
We started creating brand new high-resolution standard
images, and we've added many new images to that set.

01:01:00.780 --> 01:01:02.700
So collect them all.

01:01:04.019 --> 01:01:08.519
OK. And the talk to go to to hear more about
NSImage and a lot of other fascinating facts

01:01:08.519 --> 01:01:12.119
about NSImage is, this is Session 111 I think.

01:01:12.119 --> 01:01:13.639
It's Thursday at 3:30.

01:01:13.639 --> 01:01:16.589
NSImage in Snow Leopard.

01:01:16.590 --> 01:01:22.220
Along those lines I just want to talk
quickly about NSView Layer Redrawing.

01:01:22.219 --> 01:01:26.709
If you use NSViews with layer backing,
one thing you might have noticed that is

01:01:26.710 --> 01:01:34.800
when NSViews are using AppKit generated
layers, when that view is being animated,

01:01:34.800 --> 01:01:38.090
larger or smaller, the layer is redrawn at every step.

01:01:38.090 --> 01:01:41.640
And that's to give you the highest fidelity presentation.

01:01:41.639 --> 01:01:46.889
But now in Snow Leopard we have this
API, setLayerContentsRedrawPolicy,

01:01:46.889 --> 01:01:50.799
which lets you stop that from happening
and control it better.

01:01:50.800 --> 01:01:52.910
In Leopard, the behavior was basically this.

01:01:52.909 --> 01:01:58.349
NSViewLayerViewContentsRedrawDuringLiveResize,
which redraws every step.

01:01:58.349 --> 01:02:02.480
You can now choose one of these other
options, including neverRedrawIt

01:02:02.480 --> 01:02:06.119
or drawItOnlyONceBeforeTheResizeStarts and so on.

01:02:06.119 --> 01:02:08.130
Now, in addition to this API we have this other API

01:02:08.130 --> 01:02:12.340
that lets you control how the layer
should be displayed if it's not redrawn.

01:02:12.340 --> 01:02:17.500
You can for instance have the layer scaled in various ways.

01:02:17.500 --> 01:02:20.710
Or you can have the layer pinned to an edge or corner.

01:02:20.710 --> 01:02:29.190
So if you're using NSViews with layer backing, and you're
having them resized, this is definitely an API to consider.

01:02:29.190 --> 01:02:30.740
Multi-Touch.

01:02:30.739 --> 01:02:32.989
You might have heard about Multi-Touch at the last WWDC.

01:02:32.989 --> 01:02:37.269
We now have support for standard gestures on the trackpad.

01:02:37.269 --> 01:02:39.170
So Magnify, Swipe and Rotate.

01:02:39.170 --> 01:02:45.099
And although we exposed this in Snow
Leopard, this actually works back to 10.5.2.

01:02:45.099 --> 01:02:52.469
However, now we've also gone ahead and added support for
arbitrary touch events and these work on Snow Leopard only.

01:02:52.469 --> 01:02:55.869
This is an opt-in at the NSView level.

01:02:55.869 --> 01:03:01.269
So your view would call setAcceptsTouchEvents
and will start getting touch events.

01:03:01.269 --> 01:03:05.849
Now, until any view in an application calls
this, no touch events will be delivered

01:03:05.849 --> 01:03:09.809
to the application, or no individual touch events.

01:03:09.809 --> 01:03:13.509
And our newest responder methods, which is
of course what we always do with events,

01:03:13.510 --> 01:03:17.400
touchHasBegun, touchHasMoved, touchHasEnded and so on.

01:03:17.400 --> 01:03:19.180
These are fairly straightforward.

01:03:19.179 --> 01:03:22.169
We've also added a new class called NSTouch.

01:03:22.170 --> 01:03:28.579
This is analogous to the UI touch class from the
iPhone, but also different in some important ways.

01:03:28.579 --> 01:03:33.519
Now, to hear more about Multi-Touch
and any of these events topics,

01:03:33.519 --> 01:03:38.969
go to User Events in Cocoa, which
is tomorrow afternoon at 3:30.

01:03:38.969 --> 01:03:41.579
Another API we've added is DockTilePlugin.

01:03:41.579 --> 01:03:43.500
This is actually a new protocol.

01:03:43.500 --> 01:03:49.320
Now, you've seen iCal and how spiffy it is being able
to show you the date, even when it's not running.

01:03:49.320 --> 01:03:55.240
And you might have wondered how you do the same thing
without hackery, and you can now do it with this protocol.

01:03:55.239 --> 01:03:59.029
And I was going to show you, I was thinking I
shouldn't show you the whole API codes, you know.

01:03:59.030 --> 01:04:00.550
We're not showing whole APIs.

01:04:00.550 --> 01:04:06.420
But in this case it turned out it's so
embarrassingly simple I'll just show you the whole API.

01:04:06.420 --> 01:04:09.430
There's two methods and you only
have to implement one of them.

01:04:09.429 --> 01:04:15.389
So basically what happens is you create
a plug-in inside your application.

01:04:15.389 --> 01:04:22.549
You put the name of your plug-in inside your Info.plist as
NSDockTilePlugin equals whatever the plug-in you created is.

01:04:22.550 --> 01:04:24.690
And you go and implement this protocol.

01:04:24.690 --> 01:04:27.769
And by that, I mean you implement setDockTile.

01:04:27.769 --> 01:04:33.679
The dock will call you with the DockTile at the
appropriate time, and you can go ahead and fill it

01:04:33.679 --> 01:04:35.480
in and do whatever drawing you need to do.

01:04:35.480 --> 01:04:37.559
And you can update it whenever you wish.

01:04:37.559 --> 01:04:42.500
And, you know, you can update your DockTile
even when your application's not running.

01:04:42.500 --> 01:04:45.010
It's very, very simple.

01:04:45.010 --> 01:04:52.400
So I think at this stage we are running short
on time, so it's time for Sudden Termination.

01:04:52.400 --> 01:04:58.160
Now, what Sudden Termination does is it enables
your applications to be quit very quickly.

01:04:58.159 --> 01:05:01.149
And by quit I mean killed very quickly.

01:05:01.150 --> 01:05:03.400
They don't even get a chance to quit.

01:05:03.400 --> 01:05:06.990
It turns out that whenever you tell
an application hey, it's time to quit.

01:05:06.989 --> 01:05:12.229
Quit. Even if the application has got
nothing to do, it still fiddles around a bit.

01:05:12.230 --> 01:05:13.719
Takes its sweet time.

01:05:13.719 --> 01:05:18.029
Sometimes it even goes into page your stuff in before
it decides it can quit, and that's just not good.

01:05:18.030 --> 01:05:21.690
You know, you want the applications to
go away as soon as possible if they can.

01:05:21.690 --> 01:05:26.470
So for this we have this notion of if you're
clean, which means if you can be killed

01:05:26.469 --> 01:05:30.079
without any loss of data, we'll just kill you.

01:05:30.079 --> 01:05:36.239
Now, there's API where of course an
application can say hey, I'm not clean.

01:05:36.239 --> 01:05:37.189
I'm dirty.

01:05:37.190 --> 01:05:42.440
And the way it does that is it calls
disableSuddenTermination and enableSuddenTermination.

01:05:42.440 --> 01:05:47.670
You can either call this around a small block of code,
which, where you have some critical activity going on.

01:05:47.670 --> 01:05:51.840
Or more likely you might call it for
instance, when the user dirties a document,

01:05:51.840 --> 01:05:54.570
types something into a document, you would call Disable.

01:05:54.570 --> 01:05:57.960
And later when the document is saved you would call Enable.

01:05:57.960 --> 01:06:04.400
So basically during that time, since the document is
edited but not saved, the app would be unkillable.

01:06:04.400 --> 01:06:08.690
Now, note that AppKit marks an app
as dirty during event dispatching.

01:06:08.690 --> 01:06:11.909
So this actually takes care of a lot
of little cases so that you don't have

01:06:11.909 --> 01:06:14.269
to worry about all these individual little cases.

01:06:14.269 --> 01:06:19.889
Whenever the AppKit sends out an event during
the processing, the app is considered dirty.

01:06:19.889 --> 01:06:21.210
This requires opt-in of course.

01:06:21.210 --> 01:06:24.010
We can't just go start killing apps left and right.

01:06:24.010 --> 01:06:25.210
It's very easy to opt-in, though.

01:06:25.210 --> 01:06:29.490
You either call enableSuddenTermination when
you're launched, or else you go put a key

01:06:29.489 --> 01:06:34.279
in your Info.plist saying that
yes, you can start life off clean.

01:06:35.809 --> 01:06:40.150
So Sudden Termination we have added
some tool support for it.

01:06:40.150 --> 01:06:41.190
Activity Monitor.

01:06:41.190 --> 01:06:43.440
The Activity Monitor application has some support.

01:06:43.440 --> 01:06:49.030
If you right-click on the column headers in
Activity Monitor, you can choose a bunch of other,

01:06:49.030 --> 01:06:51.780
I don't know if you knew this, but you can
add additional columns to be displayed.

01:06:51.780 --> 01:06:55.490
And one of them is the Sudden Termination
column, which is right here.

01:06:55.489 --> 01:06:59.289
Now, note that here it says Yes for
apps that are actually killable,

01:06:59.289 --> 01:07:02.539
and No for apps that are not killable at this instant.

01:07:02.539 --> 01:07:07.699
So of course, if they are not killable, what that means
is they'll just go through the regular Quit Negotiation

01:07:07.699 --> 01:07:10.719
and regular Quit Path, so it's not like, you know,

01:07:10.719 --> 01:07:13.059
just because they're not killable it
doesn't mean it's the end of the world.

01:07:13.059 --> 01:07:14.750
It'll just take a little longer to quit.

01:07:14.750 --> 01:07:20.510
But the more apps that are killable,
the faster log-out or shut-down will be.

01:07:20.510 --> 01:07:25.870
Another place where we added support is Instruments where
you can find out why an application is not killable.

01:07:27.210 --> 01:07:29.550
So let's focus in on this middle section here.

01:07:29.550 --> 01:07:33.980
Note that the count, the disable count
is alternating between 0 and 1, 0 and 1.

01:07:33.980 --> 01:07:39.889
Well, that basically indicates the AppKit
event is enabling and disabling it for you.

01:07:39.889 --> 01:07:44.219
But note that suddenly the count goes up to 2
and 3 and starts alternating between 2 and 3,

01:07:44.219 --> 01:07:47.609
which means the app is no longer
killable because the count is not 0.

01:07:47.610 --> 01:07:49.269
That's where the 3 is.

01:07:49.269 --> 01:07:54.920
So by clicking around in these events where things look
fishy, you can note from the back trace on the side here,

01:07:54.920 --> 01:07:58.230
you can note that NSDocumentsUpdateChangeCount was called.

01:07:58.230 --> 01:08:03.420
And in fact, this corresponded to a time in TextEdit
where I typed a character into the new window.

01:08:03.420 --> 01:08:09.099
And since the document is not dirty and not saved, TextEdit
is now unkillable, and that just basically reflects that.

01:08:09.099 --> 01:08:15.420
So this is a great little tool to find out why your
application may not be killable and you're trying

01:08:15.420 --> 01:08:19.039
to make it killable, so definitely look into it.

01:08:19.039 --> 01:08:25.159
Now, we are relatively short on time so, and
we have a ton of other important changes,

01:08:25.159 --> 01:08:28.199
so I'm just going to show them to you all now.

01:08:28.199 --> 01:08:30.010
And actually this is just a part of them.

01:08:30.010 --> 01:08:32.000
And I'm really going to not give you much time to read

01:08:32.000 --> 01:08:35.430
through this stuff but, so I'll
just leave it up a few seconds.

01:08:35.430 --> 01:08:35.990
Read quickly.

01:08:35.989 --> 01:08:37.130
Come on. You too.

01:08:37.130 --> 01:08:41.940
And but one thing I'm going to do is point out
where to go for much more details on all this stuff.

01:08:41.939 --> 01:08:45.079
And of course, one answer that we
always like to say is release notes.

01:08:45.079 --> 01:08:47.729
Release notes might not be the
best-written prose in the world.

01:08:47.729 --> 01:08:53.599
It's basically from engineers, you know,
typing on the keyword right to your eyes.

01:08:53.600 --> 01:08:58.270
But it does communicate a lot of the changes that we
have done, so it's a good thing to browse through.

01:08:58.270 --> 01:09:00.220
We them for AppKit and Foundation.

01:09:00.220 --> 01:09:02.590
We also publish these things called Changes docs.

01:09:02.590 --> 01:09:06.130
If you look through your Snow Leopard
documentation you might have noticed AppKit Changes,

01:09:06.130 --> 01:09:08.000
Foundation Changes and so on.

01:09:08.000 --> 01:09:09.630
In fact, for a lot of other frameworks as well.

01:09:09.630 --> 01:09:15.310
And those actually enumerate every single
change that is in the appropriate APIs.

01:09:15.310 --> 01:09:17.140
You can also just open up a header file.

01:09:17.140 --> 01:09:19.970
Like let's say you're interested
in NSCollectionView or NSTableView.

01:09:19.970 --> 01:09:22.890
Go and open the header file, search for 10_6.

01:09:22.890 --> 01:09:27.200
That's a great way to see what got added, what
got removed, what's marked for deprecation.

01:09:27.199 --> 01:09:32.729
And of course, finally to get the official story on
a lot of these changes refer to the documentation.

01:09:32.729 --> 01:09:35.500
The Doc folks have been working
feverishly to keep up with these changes,

01:09:35.500 --> 01:09:39.920
and a lot of good things have been
documented so you can find out the real truth.

01:09:39.920 --> 01:09:42.659
What the engineers meant to say
but couldn't in the release notes.

01:09:42.659 --> 01:09:44.960
You can find it out there.

01:09:44.960 --> 01:09:49.710
Now, typically at this point in the
talk is when there is one more thing.

01:09:49.710 --> 01:09:51.760
Well, I have a few more things slide.

01:09:51.760 --> 01:09:57.409
Woohoo. And this is basically a teaser for release notes
so I can go get you to take a look at the release notes.

01:09:57.409 --> 01:10:02.119
So I'll just tell you a few things you can do in
10.6, but not necessarily tell you how to do them.

01:10:02.119 --> 01:10:06.170
You can, for instance, now put
URLs directly into Preferences.

01:10:06.170 --> 01:10:09.510
And this will do the right thing with regards
to your abbreviating your home directory.

01:10:09.510 --> 01:10:14.630
It will also write it in a way where you can
read it back on 10.5 without support of this API.

01:10:14.630 --> 01:10:17.579
This is something that we got a lot of questions about.

01:10:17.579 --> 01:10:22.210
You can now source file names or in
fact any strings like the Finder does.

01:10:22.210 --> 01:10:26.859
So it would be exactly like compatible
with Finder as far as sorting your strings,

01:10:26.859 --> 01:10:29.630
which of course is important in different localizations.

01:10:29.630 --> 01:10:33.659
You can now change the Desktop image fairly
easily without having to resort to hackery.

01:10:33.659 --> 01:10:37.510
You can get a compiler warning for this.

01:10:37.510 --> 01:10:39.310
NSLog(Message).

01:10:39.310 --> 01:10:44.000
And here the message argument here is a variable.

01:10:44.000 --> 01:10:47.500
Now, if you're wondering why should
I get a compiler warning for this,

01:10:47.500 --> 01:10:50.010
it's a good thing that you'll get
a compiler warning for this.

01:10:50.010 --> 01:10:52.900
But basically it involves potential security considerations

01:10:52.899 --> 01:10:56.539
where you might provide a format string
that could cause a malicious activity.

01:10:56.539 --> 01:11:01.769
So the compiler will now warn you for this
and other related usages, which are fishy.

01:11:01.770 --> 01:11:06.210
You can now have NSErrors display a Help button in alerts.

01:11:06.210 --> 01:11:11.899
As you know, NSErrors have the ability to return
recovery options where additional buttons will appear

01:11:11.899 --> 01:11:15.829
in alert panels, letting the user do recovery steps.

01:11:15.829 --> 01:11:21.210
You can now have a purple button up here on the alert
panel, which will bring up Help documentation if you wish.

01:11:21.210 --> 01:11:23.090
So this is all part of NSError.

01:11:23.090 --> 01:11:27.020
And again, this is all along the lines
of making NSErrors even more useful.

01:11:27.020 --> 01:11:30.390
You can now animate integer and
color-valued properties in NSView.

01:11:30.390 --> 01:11:33.610
Color-valued properties were actually animatable before.

01:11:33.609 --> 01:11:34.759
We document them as such.

01:11:34.760 --> 01:11:37.210
But it turned out they were only animatable in some cases.

01:11:37.210 --> 01:11:40.689
You can read the release notes and find out
when, but now both of these actually work.

01:11:40.689 --> 01:11:44.819
And of course integer valued property
also includes BOOL valued property.

01:11:44.819 --> 01:11:51.960
And last but not least, in your Garbage Collected
application KVO observers will now be automatically removed

01:11:51.960 --> 01:11:53.189
when finalized.

01:11:53.189 --> 01:11:57.509
What this means is if you have finalize methods
where all you're doing is removing KVO observers,

01:11:57.510 --> 01:12:02.650
you can now get rid of those finalize methods which
is of course very good for Garbage Collection.
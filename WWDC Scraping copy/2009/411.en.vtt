WEBVTT

00:00:13.050 --> 00:00:14.390
>>Good afternoon everyone.

00:00:14.390 --> 00:00:18.010
My name is Lynne Salameh and I'd like to
welcome you to What's New in Instruments.

00:00:18.010 --> 00:00:23.929
[ Applause ]

00:00:23.929 --> 00:00:26.250
>>All right here's today's agenda.

00:00:26.250 --> 00:00:29.109
Now there's a lot of ground to
cover and a lot of new features

00:00:29.109 --> 00:00:31.149
that we've introduced in Instruments and Snow Leopard.

00:00:31.149 --> 00:00:37.659
But really all-- our goal was to give you the best
user experience you've had with Instruments to date.

00:00:37.659 --> 00:00:42.509
We want to make it very easy for you to
find the data that you're looking for,

00:00:42.509 --> 00:00:45.739
data mine it and display it in Instruments.

00:00:45.740 --> 00:00:49.530
We've introduced a whole set of
new instrumentation in Snow Leopard

00:00:49.530 --> 00:00:52.740
and we've improved the overall performance of Instruments.

00:00:52.740 --> 00:00:59.170
And without further ado let's go ahead and jump right in
and begin with a demo of Instruments and Snow Leopard.

00:00:59.170 --> 00:01:05.730
My demo application is an application called
ImageWare, which I just brought up in Xcode.

00:01:05.730 --> 00:01:12.400
And this application takes PDF pages and
renders them into thumbnails onto a screen.

00:01:12.400 --> 00:01:20.100
It also goes through each PDF page's metadata and tries to
determine the number of images that each PDF page contains

00:01:20.099 --> 00:01:22.919
and displays it as the subtitle of each thumbnail.

00:01:22.920 --> 00:01:30.140
So I'm going to go ahead, build it
and run it and see how it behaves.

00:01:30.140 --> 00:01:38.090
So if I just click start, my application is going to
start reading in PDF thumbnails and suddenly it slows down

00:01:38.090 --> 00:01:40.170
and I've got this big spinning beach ball.

00:01:40.170 --> 00:01:44.320
So this is obviously an area that
we'd like to investigate in terms of,

00:01:44.319 --> 00:01:48.059
in order to improve the performance, and now it's done.

00:01:48.060 --> 00:01:55.920
So in Snow Leopard, if I bring up Instruments over here,
we've introduced a new instrument called Time Profiler

00:01:55.920 --> 00:02:02.329
which will allow you to do very strict, statistical sampling
of your target applications and interferes minimally

00:02:02.329 --> 00:02:07.629
with their execution so all the timing
data that you get back is very precise.

00:02:07.629 --> 00:02:15.030
Here in my new target chooser in Instruments, I'm going
to select the CPU category from the left and double click

00:02:15.030 --> 00:02:21.169
on Time Profiler to bring up the Time Profiler
instrument and let me just enlarge this.

00:02:21.169 --> 00:02:26.129
And over here from the executables I'm
going to launch ImageWare and hit record.

00:02:26.129 --> 00:02:37.939
All right, if I bring up my app, hit start and you can
see over here in Time Profiler we saw a spike in CPU usage

00:02:37.939 --> 00:02:46.639
as we began rendering these PDF thumbnails onto the
screen and my application is actually hung right now.

00:02:46.639 --> 00:02:55.099
When it completes the rendering onto the
screen, the CPU usage drops right back down.

00:02:55.099 --> 00:02:57.409
So we've collected all the information we want.

00:02:57.409 --> 00:03:02.240
Let's stop recording and take a look at this
data that we've just collected and try to see

00:03:02.240 --> 00:03:05.650
where we can find areas where we can optimize.

00:03:05.650 --> 00:03:14.330
All right so the data that I'm seeing over here
in my Call Tree View is frames from stack traces

00:03:14.330 --> 00:03:18.950
that I've collected in my Time Profiler sample.

00:03:18.949 --> 00:03:27.449
Right now it's displayed in inverted order which is
a setting that I can set over here on my left corner,

00:03:27.449 --> 00:03:32.339
so invert Call Tree, which means that my
deepest stack frame is displayed first

00:03:32.340 --> 00:03:35.420
and I can view my call history in reverse.

00:03:35.419 --> 00:03:42.319
What I'm going to do is I'm going to bring up the extended
detail view to look at what each of these stack frames,

00:03:42.319 --> 00:03:47.969
which back traces each of these stack frames
came from and to do that I'm going to go up here

00:03:47.969 --> 00:03:51.870
to the right corner and bring in my extended detail view.

00:03:51.870 --> 00:04:00.620
All right, so if you look at these, and I'm not sure if you
can read them, let me just zoom in a little more, all right,

00:04:00.620 --> 00:04:08.980
so if you look at these frames, a couple of them seem
to be occurring in libraries that I don't control.

00:04:08.979 --> 00:04:15.299
For example this frame, PDF lecture scan,
is getting called from CoreGraphics library

00:04:15.300 --> 00:04:26.230
and InflateFastAdler32 is getting called from libz.l.dylib
and if we take a look at the extended detail view for one

00:04:26.230 --> 00:04:34.370
of these frames, let me just, and zoom in a little bit,
you can see that these frames are getting called somewhere

00:04:34.370 --> 00:04:41.750
in our code over here in ImageWare, calling
these frames in libraries and frameworks

00:04:41.750 --> 00:04:44.649
that are system frameworks that I don't control.

00:04:44.649 --> 00:04:49.919
Well, in Snow Leopard we've introduced this
new concept of data mining that will allow you

00:04:49.920 --> 00:04:58.129
to manipulate your call trees in order to let you
focus in on areas in your code that you can optimize.

00:04:58.129 --> 00:05:06.120
So to show you how that works I'm going to control click
on this symbol, PDF lexer scan and it brings up a bunch

00:05:06.120 --> 00:05:08.610
of options that I can perform on my Call Tree.

00:05:08.610 --> 00:05:14.590
I'm going to charge the symbol to its caller, meaning that
I'm going to take the time that I spent in the symbol,

00:05:14.589 --> 00:05:21.679
currently around 4 seconds, and charge it to its caller.

00:05:21.680 --> 00:05:32.110
As we can see, now CGPDFScanner appears to be the heaviest
or the symbol that we're spending the most time in.

00:05:32.110 --> 00:05:37.379
Well, I'm going to go ahead and charge all of
CoreGraphics, the entire library, to its callers.

00:05:37.379 --> 00:05:46.139
So I'm going to hit Charge Library to Callers and with
these two simple steps I can now see that I'm spending 36%

00:05:46.139 --> 00:05:53.539
of my time, let me zoom in again so you guys can see
better, 36% of my time, about 5 seconds, in this function,

00:05:53.540 --> 00:06:00.490
image item, images and page, which is available,
it's in my code, it's in ImageWare itself.

00:06:00.490 --> 00:06:03.060
So what's going on here?

00:06:04.430 --> 00:06:11.170
From the extended detail view I can
actually double click on my code

00:06:11.170 --> 00:06:16.050
and it will take me directly to
my source code within Instruments.

00:06:16.050 --> 00:06:23.300
I just saw imagesInPage over here and the
Time Profiler provides with annotations,

00:06:23.300 --> 00:06:26.720
performance annotations about where
I'm spending the most time.

00:06:26.720 --> 00:06:33.480
So within imagesInPage I'm spending about
99 percent of my time in CGPDFScanner scan.

00:06:33.480 --> 00:06:36.480
So what does this function do really?

00:06:36.480 --> 00:06:44.370
This function is reading through the PDF page
metadata and creating the scanner which goes through

00:06:44.370 --> 00:06:48.040
and determines the number of images in this page.

00:06:48.040 --> 00:06:50.680
Now who's calling this function?

00:06:50.680 --> 00:06:59.079
Well, if I hit the info button over here, scroll down,
I can see that image subtitle is actually calling this

00:06:59.079 --> 00:07:03.009
and if I double click on that it will
take me directly to that function call.

00:07:03.009 --> 00:07:09.670
[ Applause ]

00:07:09.670 --> 00:07:11.500
>>So what's happening over here?

00:07:11.500 --> 00:07:18.110
Every single time we're trying to display the image
subtitles we're going through creating a new PDF scanner

00:07:18.110 --> 00:07:21.759
and trying to determine the number of images in that page.

00:07:21.759 --> 00:07:26.899
Now this seems rather wasteful so let
me just go back to Xcode over here,

00:07:26.899 --> 00:07:35.870
and I can do that by clicking this little Xcode icon
in the top, well the lower right and here we go.

00:07:35.870 --> 00:07:44.560
Xcode brings up my code and, let me just double
click on the Xcode icon, one second, right.

00:07:44.560 --> 00:07:51.509
So instead of recalculating the number of images in my
page every single time I'm trying to find the subtitle,

00:07:51.509 --> 00:07:56.610
why don't I go ahead and cash this value so that when
I find the subtitle the first time I can just look

00:07:56.610 --> 00:08:00.170
up that number later on and I don't have
to do all this work every single time.

00:08:00.170 --> 00:08:06.890
So to do that I'm going to add this new
instance variable into my image items

00:08:06.889 --> 00:08:11.889
and this instance variable I'm
going to aptly call numb images

00:08:11.889 --> 00:08:20.560
Save that, go to my image item, when
I initialize my image items I'm going

00:08:20.560 --> 00:08:25.509
to initialize the value of numb images to NSNotFound.

00:08:27.209 --> 00:08:40.460
Over here, all right and down where I'm trying to calculate
the imagesInPage, I'm going to check whether the number

00:08:40.460 --> 00:08:44.840
of images is NSNotFound first, meaning
it hasn't been calculated yet over here

00:08:44.840 --> 00:08:54.360
And then if it hasn't been calculated I will go ahead and
find the number of images in those pages and then return it.

00:08:54.360 --> 00:09:01.680
Later on when I'm trying to look up my subtitle,
I can read the cached number of imagesInPage

00:09:01.679 --> 00:09:03.509
and I don't have to recalculate it every time.

00:09:03.509 --> 00:09:11.909
So let me save this, build and
go back to Instruments and verify

00:09:11.909 --> 00:09:16.659
that this change has actually achieved
the performance one that I'm looking for.

00:09:16.659 --> 00:09:19.639
So let me just go back to my Call Tree review.

00:09:19.639 --> 00:09:24.669
[inaudible background talking] I didn't build it?

00:09:24.669 --> 00:09:27.870
Oh, sorry, never mind, here we go.

00:09:27.870 --> 00:09:29.019
Delete the old method.

00:09:29.019 --> 00:09:30.669
That is key.

00:09:30.669 --> 00:09:35.659
[laughter] Save it, build it, all right.

00:09:35.659 --> 00:09:43.439
Go back to Instruments [laughter] well
thanks for that and launch it again.

00:09:43.440 --> 00:09:57.120
All right so you know bring up my app, hit start and now I
don't see the hanging anymore and it's actually much faster.

00:09:57.120 --> 00:09:59.799
[applause] So I can go back to
Instruments and stop recording.

00:09:59.799 --> 00:10:06.829
And performance optimization is really an iterative process
so we just, you know, eliminated the lowest hanging fruit,

00:10:06.830 --> 00:10:12.470
but really, what you should do is continue
to iterate through your performance analysis

00:10:12.470 --> 00:10:15.310
and find more areas where you can optimize.

00:10:15.309 --> 00:10:24.250
And in this case we're going to go right ahead and in the
configuration view on the left, hide our system libraries

00:10:24.250 --> 00:10:31.190
which is really going to charge all our system libraries
to functions or calls that we make in our code.

00:10:31.190 --> 00:10:40.810
And after we do that you can see that now I'm
only spending 355 milliseconds in Image item,

00:10:40.809 --> 00:10:50.839
imagesInPage but now my heaviest or my hot spot is actually
occurring in ImageWare controller create image from PDF page

00:10:50.840 --> 00:10:57.460
which is you know I'm taking about 3 seconds or so
in that code, which is the code that is going through

00:10:57.460 --> 00:11:00.139
and rendering the PDF pages as thumbnails.

00:11:00.139 --> 00:11:02.419
Well we're going to go come back to this later.

00:11:02.419 --> 00:11:06.429
So to recap what we saw in the demo, what is Time Profiler?

00:11:06.429 --> 00:11:11.159
Well it's the next-generation statistical time
sampler that we've incorporated into Instruments.

00:11:11.159 --> 00:11:17.199
You can use it in Instruments or you can use it
standalone whenever your Instruments icon is in the dock,

00:11:17.200 --> 00:11:19.720
regardless of whether Instruments is running or not.

00:11:19.720 --> 00:11:25.240
All you need to do is click on the Instruments
icon and launch either one process, or sorry,

00:11:25.240 --> 00:11:29.690
profile either one process or all
the processes on your system.

00:11:29.690 --> 00:11:33.470
There are two other ways that you
can launch Instruments, sorry,

00:11:33.470 --> 00:11:37.379
there are two other ways in which
you can launch Time Profiler.

00:11:37.379 --> 00:11:43.939
You can set it up so that it automatically detects
spins on your system or you can use a set of hot keys

00:11:43.940 --> 00:11:48.350
that you can trigger whenever, you know, a
certain application is exhibiting slowness

00:11:48.350 --> 00:11:51.670
or is hanging, in order to begin profiling it.

00:11:51.669 --> 00:11:59.740
Finally, Time Profiler saves its documents in a special
file format that is compact and it doesn't symbolicate

00:11:59.740 --> 00:12:05.289
in this file format, stack traces aren't
symbolicated until the document is opened.

00:12:05.289 --> 00:12:08.169
So unopened documents have a short shelf life

00:12:08.169 --> 00:12:16.169
and if you change your binaries the actual symbol addresses
are not going to be valid anymore, so keep that in mind.

00:12:16.169 --> 00:12:20.839
All right, so why would you use Time Profiler?

00:12:20.840 --> 00:12:27.860
Well, Time Profiler has very low impact in terms of CPU and
memory usage which means that it interferes very minimally

00:12:27.860 --> 00:12:32.590
in your target application and the timing
data that you get back is very precise.

00:12:32.590 --> 00:12:39.080
It performs stricter, more precise time sampling from
within the kernel and this is new in Snow Leopard.

00:12:39.080 --> 00:12:46.590
You can use it to profile all thread states or
only thread states that are running on your CPU.

00:12:46.590 --> 00:12:52.560
And finally you can use it to profile all
your system processes that are running.

00:12:52.559 --> 00:12:56.659
So how does Time Profiler work?

00:12:56.659 --> 00:13:00.559
We kind of glossed over that in the demo
but let's go into that in more detail.

00:13:00.559 --> 00:13:07.209
Time Profiler collects stack traces from your
running threads at regular time intervals.

00:13:07.210 --> 00:13:11.820
Here we have a bunch of example stack traces
that are very similar to the ones we saw

00:13:11.820 --> 00:13:13.850
in the demo but they're slightly simplified.

00:13:13.850 --> 00:13:20.590
And Instruments is going to take these stack traces and
aggregate them into a more readable form that will allow you

00:13:20.590 --> 00:13:23.590
to pinpoint the areas that you need to optimize.

00:13:23.590 --> 00:13:25.870
So how does it do that?

00:13:25.870 --> 00:13:31.259
So if I assume every single one of these
stack traces took 1 millisecond to execute,

00:13:31.259 --> 00:13:36.299
I'm going to build something called an inverted
Call Tree which, as we saw in the demo,

00:13:36.299 --> 00:13:42.500
displays the deepest stacked frame first as the
roots of the trees and then it builds it backwards

00:13:42.500 --> 00:13:44.870
so that I can view my call history in reverse.

00:13:44.870 --> 00:13:52.429
So for example, let's start off here, you can see
that I spent 2 milliseconds in the symbol inflate,

00:13:52.429 --> 00:13:58.519
4 milliseconds in lexer but 2 of these milliseconds
went ahead and called symbol inflate and so forth

00:13:58.519 --> 00:14:07.990
with CGPDFScanner, imagesInPage and then finally main,
which was the entry into my code, the entry point.

00:14:07.990 --> 00:14:11.919
All right, so how does Instruments display these Call Trees?

00:14:11.919 --> 00:14:18.679
If we focus on the middle Call Tree over here,
Instruments actually displays it in the form

00:14:18.679 --> 00:14:24.509
of an outline view as you can see on the right.

00:14:24.509 --> 00:14:32.649
Now Call Trees can get very complicated and a lot of
times you see stack frames from libraries and frameworks

00:14:32.649 --> 00:14:38.620
that are not your code but what you really are looking
for is areas in your code that you want to optimize

00:14:38.620 --> 00:14:44.450
and you want to be able to simplify your call trees.

00:14:44.450 --> 00:14:48.800
So in Instruments and Snow Leopard we've
introduced the very powerful concept

00:14:48.799 --> 00:14:51.459
of data mining that will allow you to do just that.

00:14:51.460 --> 00:14:55.540
It will allow you to prune your call trees,
simplify them so that you can find areas

00:14:55.539 --> 00:14:58.079
of your code that you can change and optimize.

00:14:58.080 --> 00:15:02.410
Now in Snow Leopard we have two
types of data mining operations.

00:15:02.409 --> 00:15:06.429
We have Library and Symbol Operations and let's just step

00:15:06.429 --> 00:15:09.559
through them really fast and, you
know, show you how they work.

00:15:09.559 --> 00:15:14.039
So the first of these that we saw
was charging a symbol to its caller.

00:15:14.039 --> 00:15:17.899
What this means is that you take a symbol
and attribute the time that is spent

00:15:17.899 --> 00:15:21.309
in that symbol to the frames that called it.

00:15:21.309 --> 00:15:26.629
Like for example if you take lexer over here and
attribute it to its callers we can then go ahead

00:15:26.629 --> 00:15:34.850
and aggregate those two stack frames and you can see
that now I see 105 milliseconds spent in CGPDFScanner.

00:15:34.850 --> 00:15:42.009
You can go ahead and charge an
entire library to its callers.

00:15:42.009 --> 00:15:47.289
For example if I charge CoreGraphics to its
callers I would take the time spent in CoreGraphics

00:15:47.289 --> 00:15:49.860
and attribute that to its calling frames.

00:15:49.860 --> 00:15:58.430
And once again I can take this two stack frames in
the far right and the far left and aggregate them.

00:15:58.429 --> 00:16:05.699
A lot of times you'd like to discard the amount of time
spent in a certain symbol from the rest of your Call Tree.

00:16:05.700 --> 00:16:11.520
You want to say, I want to ignore this symbol and not look
at what time it contributes to the rest of my Call Tree.

00:16:11.519 --> 00:16:15.019
And to do that you prune the symbol and its Call Tree.

00:16:15.019 --> 00:16:24.149
So for example if I actually decide to prune createImage,
I can discard its entire weight in my Call Tree

00:16:24.149 --> 00:16:31.929
and you can see that inflate, I'm spending now 76
millisecondsv in inflate whereas before I was spending 98.

00:16:31.929 --> 00:16:38.159
And finally, a lot of times you see your
code call into a lot of stack frames

00:16:38.159 --> 00:16:41.889
and system libraries and then call into some other code.

00:16:41.889 --> 00:16:46.879
And what you really care about is where that
library called into the rest of the code.

00:16:46.879 --> 00:16:50.120
So what you can do is flatten your
library to its boundaries.

00:16:50.120 --> 00:16:55.970
And in this case if we flatten CoreGraphics
to its boundaries we're just left

00:16:55.970 --> 00:16:59.509
with the boundary frames that call
in to the rest of the code.

00:16:59.509 --> 00:17:04.299
So there you have it, data mining in a nutshell,
simplifies the way you view your Call Trees

00:17:04.299 --> 00:17:08.639
and helps you find areas in your code that you can optimize.

00:17:08.640 --> 00:17:22.410
Now moving on, [applause] in Leopard you've seen
Instruments display their data in one of three typical views

00:17:22.410 --> 00:17:28.650
that are shown here and that you can access from
the lower left corner of your Trace Documents.

00:17:28.650 --> 00:17:35.190
And for example, in Time Profiler it really had two
views that it used, it used the sample list view

00:17:35.190 --> 00:17:37.940
and then the Call Tree view which we see over here.

00:17:37.940 --> 00:17:45.970
Now in Snow Leopard we've introduced two new
views that will help you improve your workflow

00:17:45.970 --> 00:17:48.910
and these views are actually available for all Instruments.

00:17:48.910 --> 00:17:55.870
The first of these is the console view which will display
standard in and standard out, writeWithinInstruments.

00:17:55.869 --> 00:18:01.409
You can correlate it in time with the data that
you're getting in your track and in your other views

00:18:01.410 --> 00:18:09.870
and Instruments will save these console outputs
per run per document so you can access it later.

00:18:14.859 --> 00:18:19.549
[applause] And as we've seen in the demo
we've also introduced the source view,

00:18:19.549 --> 00:18:23.169
which will allow you to view your
source code directly in Instruments

00:18:23.170 --> 00:18:27.450
and Instruments will annotate your source
code with performance data that they collect.

00:18:27.450 --> 00:18:34.910
Like for example, in Time Profiler we saw that we
were spending 99% of our time in CDPDFScanner Scan

00:18:34.910 --> 00:18:40.170
and this greatly improves your workflow in Snow Leopard.

00:18:40.170 --> 00:18:46.340
So let's go back to our ImageAware application.

00:18:46.339 --> 00:18:59.089
At the end of our previous demo, we saw that we were
spending most of our time in createImages from PDF page

00:18:59.089 --> 00:19:07.069
which was really calling a bunch of system API
that was rendering the thumbnails onto the screen.

00:19:07.069 --> 00:19:11.109
Now in order to improve the performance
of rendering the thumbnails,

00:19:11.109 --> 00:19:15.709
we're going to follow a different
approach this time around and instead of --

00:19:15.710 --> 00:19:24.049
we're going to make use of the fact that we have about 16,
I believe, logical cores on this machine that I'm running in

00:19:24.049 --> 00:19:30.509
and you know we can leverage concurrency on our devices
and leverage the API that we've introduced in Snow Leopard

00:19:30.509 --> 00:19:36.500
in order to be able to paralyze the process
of rendering these PDFs as thumbnails.

00:19:36.500 --> 00:19:42.819
So in this part of the demo, we've actually changed
the way we rendered the thumbnails so that each --

00:19:42.819 --> 00:19:48.839
we've created an arbitrary amount of queues, dispatch
queues that will be performing the rendering operation.

00:19:48.839 --> 00:19:52.429
So let's see how that runs and see
whether, you know, we can improve that.

00:19:52.430 --> 00:19:56.120
I'm just going to select to run this from
Dispatch, using Dispatch, and hit start.

00:19:56.119 --> 00:20:06.259
All right, so it seems to me that, you know, I'm not seeing
the speed up that I'm expecting on such a powerful device.

00:20:06.259 --> 00:20:10.190
And really I must be misusing the API in some way,

00:20:10.190 --> 00:20:18.210
so in Snow Leopard we've introduced a new instrument
called the Dispatch Instrument that will allow you

00:20:18.210 --> 00:20:23.319
to analyze the behavior and the performance of
your target applications that are running Dispatch.

00:20:23.319 --> 00:20:28.079
So back in Instruments I just brought
up a new template chooser

00:20:28.079 --> 00:20:32.179
and I've already selected the CPU
category over here on the left.

00:20:32.180 --> 00:20:34.860
I'm going to go ahead and select the Dispatch Instrument.

00:20:34.859 --> 00:20:43.179
All right, I'm going to launch my executable
and just go through the same process of trying

00:20:43.180 --> 00:20:47.549
to render my PDF thumbnails off of the screen.

00:20:47.549 --> 00:20:52.509
Just remember to select Dispatch and here we go.

00:20:52.509 --> 00:21:02.490
All right, so as it's collecting the data back
in Instruments I'm going to stop my recording

00:21:02.490 --> 00:21:09.630
because I've collected all the data that I needed and down
in the left corner I'm going to switch to my queues view.

00:21:09.630 --> 00:21:19.260
Let me zoom in a little bit, actually let me
just resize these for a second and zoom in.

00:21:19.259 --> 00:21:21.589
There we go.

00:21:21.589 --> 00:21:28.730
So the queues view shows you all the queues
that your target application is using.

00:21:28.730 --> 00:21:36.259
Some of these queues, as you can see over here, like
com.Apple.rootlowPriority, are the global concurrent queues

00:21:36.259 --> 00:21:41.430
that lib-Dispatch provides you and you have another
global queue which is the main thread queue,

00:21:41.430 --> 00:21:45.080
and this queue is the queue serviced by the main thread.

00:21:45.079 --> 00:21:49.949
And down here you can see a whole bunch of queues
called imageBrowser queues, and these are the queues

00:21:49.950 --> 00:21:56.610
that I had created in ImageWare
to process my PDF thumbnails.

00:21:56.609 --> 00:22:00.399
Now there's a bunch of statistics that
the queues view shows you as well.

00:22:00.400 --> 00:22:06.600
For example, it shows you the total number of blocks
processed by these queues over here and you can see

00:22:06.599 --> 00:22:13.459
that you know on average the imageBrowser
queues process about you know 34, 32 blocks.

00:22:13.460 --> 00:22:18.670
It also tells me about the latency and the
total CPU time that I'm spending on each queue.

00:22:18.670 --> 00:22:26.769
There are two things to note over here and one is the
latency, which is really the average amount of time

00:22:26.769 --> 00:22:31.650
between when a block is inqueued, propagates
across the queue, and then invoked.

00:22:31.650 --> 00:22:32.980
It's actually quite large.

00:22:32.980 --> 00:22:36.599
It's about, you know, 3 seconds in general.

00:22:36.599 --> 00:22:43.929
And that's one thing to note and maybe, you know, the fact
that my queues have this high latency might be the fact

00:22:43.930 --> 00:22:47.549
that I'm not seeing this speed-up in my target application.

00:22:47.549 --> 00:22:55.099
And another thing to note is that if we look at the
main queue over here, it seems that I'm inqueuing

00:22:55.099 --> 00:23:00.730
about 526 blocks synchronously on the main thread.

00:23:00.730 --> 00:23:06.980
So let's, you know, take a look and see what sort
of blocks I'm inqueuing there and what's going on.

00:23:06.980 --> 00:23:15.019
So if I zoom out and I'm going to hit the focus button
for the queue and I'm going to focus on the main queue.

00:23:15.019 --> 00:23:21.269
It's going to take me to the blocks focus view which
shows me all the blocks that I've explicitly inqueued

00:23:21.269 --> 00:23:24.879
on my main queue and it sorts them
by when they've been executed

00:23:24.880 --> 00:23:31.930
and tells me how long they've -- how
long they took executing on the CPU.

00:23:31.930 --> 00:23:38.009
Right. Let me just, you know, select one of these blocks
because it seems that I'm inqueuing a lot of the same block

00:23:38.009 --> 00:23:46.319
on the main queue, and bring up the extended detail
view by clicking the icon in the lower left corner.

00:23:46.319 --> 00:23:52.149
For each of the blocks that I have inqueued on the main
queue, that as you can see I'm inqueuing synchronously,

00:23:52.150 --> 00:23:56.720
the extended detail view is going to show me stack traces

00:23:56.720 --> 00:24:01.210
for when the block has been inqueued
and for when the block has been invoked.

00:24:01.210 --> 00:24:06.990
So you can see that I'm inqueuing my block in
ImageAware controller and port files in GCD

00:24:06.990 --> 00:24:12.400
and executing my block somewhere from
within the lib-Dispatch mechanisms.

00:24:12.400 --> 00:24:16.380
So let me see what sort of block I'm
actually, you know, inqueueing and executing.

00:24:16.380 --> 00:24:23.440
I'm going to double click at my, the frame in my invoke
stack trace, and it will take me directly into my code

00:24:23.440 --> 00:24:26.630
and I can see the blocks that I've created and inqueued.

00:24:26.630 --> 00:24:33.490
So the first block I create over here is really
the block that goes ahead and calls createImage

00:24:33.490 --> 00:24:37.039
from PDF page that's rendering the thumbnails.

00:24:37.039 --> 00:24:44.940
And later on this block is synchronously dispatching
something onto the main queue and if we take a look

00:24:44.940 --> 00:24:50.910
at what it's doing it's actually, let me just
go back, I didn't mean to click that, all right,

00:24:50.910 --> 00:25:04.170
so it's actually refreshing the UI and asking the runloop
to redraw the screen to refresh the UI in that case.

00:25:04.170 --> 00:25:08.900
So really I don't need to do this operation
synchronously because I don't really need to wait

00:25:08.900 --> 00:25:13.860
on the main thread to complete its UI rendering.

00:25:13.859 --> 00:25:22.869
So very easily, back in Xcode, if I bring up ImageAware
controller and go down to the code which is calling,

00:25:22.869 --> 00:25:29.539
refreshing the UI synchronously, it's just one character
change, I'm just going to change that to Dispatch Async

00:25:29.539 --> 00:25:34.730
because you know I'm telling the main
queue to update the UI in its own time.

00:25:34.730 --> 00:25:37.529
I don't have to wait on it to complete.

00:25:37.529 --> 00:25:47.849
So I'm going to build, save all and back in
Instruments let me run the dispatch instruments again

00:25:47.849 --> 00:25:51.079
and verify the change that I've
done actually made an effect.

00:25:51.079 --> 00:26:01.569
So I'm going to hit record, bring up
ImageAware, select dispatch and hit start.

00:26:01.569 --> 00:26:10.539
I don't know about you but I didn't see that much of an
improvement by changing, you know, the call from dispatch,

00:26:10.539 --> 00:26:14.980
Async to Dispatch, sorry, Dispatch sync to Dispatch Async.

00:26:14.980 --> 00:26:18.420
So let's investigate this further and
see what Instruments tells us about this.

00:26:18.420 --> 00:26:21.890
Let me go back to Instruments and stop recording.

00:26:21.890 --> 00:26:28.060
All right, well the first thing
to note actually, if we zoom in,

00:26:28.059 --> 00:26:33.250
is that for my imageBrowser queues the
latency has gone down dramatically.

00:26:33.250 --> 00:26:40.670
Whereas before I was spending about, you know about 3 to
4 seconds between when a block is inqueued and executed,

00:26:40.670 --> 00:26:46.960
ow it's down to around you know 800
to, yeah, about 800 milliseconds.

00:26:46.960 --> 00:26:54.519
You can also see that for my main queue I'm no
longer dispatching synchronously onto the main queue.

00:26:54.519 --> 00:26:57.279
But really, what's going on here?

00:26:57.279 --> 00:27:05.289
If I scroll out, and let me select too a bunch of
my imageBrowser queues to plot in my track view,

00:27:05.289 --> 00:27:10.399
let's select these two, and deselect
some of the global queues

00:27:10.400 --> 00:27:16.050
so that we can see what's going on,
and zoom in, pull this up a little bit.

00:27:16.049 --> 00:27:22.389
OK. So my image browser queues are the
ones over here at the bottom and what I see

00:27:22.390 --> 00:27:26.160
in my track view is the number of
blocks processed on those queues.

00:27:26.160 --> 00:27:33.900
So my imageBrowser queues are completing their
rendering the thumbnails all the way over here.

00:27:33.900 --> 00:27:41.509
And my main queue is actually continuing to, you know,
process the blocks that are asking for the UI updates,

00:27:41.509 --> 00:27:46.509
even long after my PDF rendering has completed.

00:27:46.509 --> 00:27:50.200
So this seems like, you know, it's an area to optimize.

00:27:50.200 --> 00:27:53.170
Another thing to point out is I'm spending about, you know,

00:27:53.170 --> 00:28:01.539
1 second over here on my main queue executing
the blocks that are performing the UI update.

00:28:01.539 --> 00:28:08.099
So let's step back for a second and take a look
at this information from a different perspective.

00:28:08.099 --> 00:28:14.279
If you go down to the bottom left
corner and select the blocks view,

00:28:14.279 --> 00:28:21.160
the dispatch instrument will show you all the
blocks that have been executed in a queue context.

00:28:21.160 --> 00:28:26.830
Now in this case I only care about blocks that
I've created explicitly so I'm going to go

00:28:26.829 --> 00:28:30.519
down into the right corner and filter by ImageWare.

00:28:30.519 --> 00:28:37.440
Oops, all right and the block that I care
about is the block that has been dispatched

00:28:37.440 --> 00:28:41.140
on the main thread which is import files in GCD block 2.

00:28:41.140 --> 00:28:43.560
Let me just also select that to plot it on the screen.

00:28:43.559 --> 00:28:55.710
So you can see that I've executed, I've invoked 526
blocks of block 2, of the block that I'm executing

00:28:55.710 --> 00:29:02.100
on the main thread and on average each of these
blocks took about 1 millisecond to execute.

00:29:02.099 --> 00:29:08.079
And if I look at the extended detail view, it
shows me that invoked stack trace for this block.

00:29:08.079 --> 00:29:13.579
Let me go ahead and double click on it and see
why I'm spending so much time in this block.

00:29:13.579 --> 00:29:17.240
Well, what is it doing over here?

00:29:17.240 --> 00:29:28.140
It's asking the image to refresh, the view to refresh itself
and then it's asking runloop to explicitly redraw the view.

00:29:28.140 --> 00:29:34.440
So as an improvement here it seems that we can
reduce the amount of UI update that we're doing.

00:29:34.440 --> 00:29:44.990
And what we could do is if we go back to Xcode, instead
of asking the view to redraw itself after every thumbnail

00:29:44.990 --> 00:29:57.250
that we've rendered, let's instead
delete these two and bring in this code.

00:29:57.250 --> 00:30:10.160
So we're going to ask the runloop to refresh the ImageView
at the end of its runloop and we're going to cancel,

00:30:10.160 --> 00:30:17.880
you know, any pending previous requests over here to
refresh the runloop, I'm sorry, to refresh the ImageView.

00:30:17.880 --> 00:30:26.590
Save, rebuild and run and see whether we've
improved the performance of our application.

00:30:26.589 --> 00:30:32.299
So let's select dispatch, hit start and it's done.

00:30:32.299 --> 00:30:34.430
So there you have it.

00:30:39.049 --> 00:30:45.950
[applause] What we've seen is part of the
multi-core template that we've added into Instruments

00:30:45.950 --> 00:30:52.490
to help you understand the performance and
the behavioral aspects of your applications

00:30:52.490 --> 00:30:57.779
that are running using lib-Dispatch
and applications that are concurrent.

00:30:57.779 --> 00:31:03.849
So as part of the multi-core application we've
introduced new in Snow Leopard the Threads Instrument,

00:31:03.849 --> 00:31:08.709
which we haven't seen in demo but we'll show
you the thread states of all the threads

00:31:08.710 --> 00:31:12.130
that have been created in your target application.

00:31:12.130 --> 00:31:20.730
It will show you state transitions between when a thread
was running, waiting, suspended or idle, etcetera.

00:31:20.730 --> 00:31:25.930
We'll also tell you what type of threads
are running in your target application,

00:31:25.930 --> 00:31:30.009
whether they're BSD threads, Dispatch
threads or your main thread.

00:31:30.009 --> 00:31:36.740
And it will tell you things about the parent
and child relationships between these threads,

00:31:36.740 --> 00:31:42.009
whether each thread is living or terminated, the
number of context switches each thread performs

00:31:42.009 --> 00:31:47.859
and finally the total number of CPU time a thread consumes.

00:31:47.859 --> 00:31:51.789
Because really the question you're trying to
answer is how many threads do you want to create

00:31:51.789 --> 00:31:57.480
in your target application to achieve
concurrency and not create a large overhead.

00:31:57.480 --> 00:32:01.660
So let's suppose that these are
the number of runnable threads

00:32:01.660 --> 00:32:07.110
that our target application is using, plotted against time.

00:32:07.109 --> 00:32:12.419
And let's suppose that my machine that
I'm running on has four logical cores.

00:32:12.420 --> 00:32:20.690
Now the first area over here where I have two threads
running on my 4-core machine I'm underutilizing my machine.

00:32:20.690 --> 00:32:28.789
I have two idle cores that could be doing more work but
aren't doing any work so really I can be doing better.

00:32:28.789 --> 00:32:35.909
In the case of four runnable threads on a 4-core machine,
that's really the optimal that I'm trying to achieve.

00:32:35.910 --> 00:32:43.790
And then finally if I have 6 threads running on a machine
with four logical cores I'm actually overcommitted.

00:32:43.789 --> 00:32:50.480
At any one time two of these threads are going to be
waiting while the other threads are executing on the cores.

00:32:50.480 --> 00:32:56.410
So usually there's a tendency to try to create the
same number of threads as you have units of work.

00:32:56.410 --> 00:33:01.370
But the rule of thumb here is try to make the
number of threads closer to the number of cores

00:33:01.369 --> 00:33:04.529
on your machine rather than the units of work.

00:33:04.529 --> 00:33:09.889
And using a lib-Dispatch actually makes that
very simple for you and you don't have to care

00:33:09.890 --> 00:33:13.420
about the hardware that's running, that you're running on.

00:33:13.420 --> 00:33:21.050
All right so the second of the Instruments in the multi-core
template is the Dispatch Instrument and this allows you

00:33:21.049 --> 00:33:24.669
to analyze your blocks of queues
that are in your target applications.

00:33:24.670 --> 00:33:32.100
We saw that there were two ways of representing this data
from a queues perspective and from a blocks perspective

00:33:32.099 --> 00:33:38.609
and if we start off with the queues perspective, over
here you can see that the dispatch instrument detects

00:33:38.609 --> 00:33:46.879
when blocks are inqueued asynchronously onto a
queue and when they're inqueued synchronously

00:33:46.880 --> 00:33:51.520
and it also detects when they're invoked.

00:33:51.519 --> 00:33:57.650
So here we invoke a block off of queueA and then we
go ahead and invoke a bunch of blocks over queueB.

00:33:57.650 --> 00:34:01.620
And you can see that, you know, my statistics are updated.

00:34:01.619 --> 00:34:05.819
I can see that you know I invoked,
I inqueued one block synchronously

00:34:05.819 --> 00:34:10.710
onto queueB and the latency has changed as well.

00:34:10.710 --> 00:34:13.340
And you can also see this from a blocks view.

00:34:13.340 --> 00:34:23.380
In this case I see my block queue bar I've inqueued
about, I've executed, invoked about one type of block

00:34:23.380 --> 00:34:27.269
from block foo and four from block
bar but there's this extra block, baz,

00:34:27.269 --> 00:34:29.500
and I don't really know where it came from.

00:34:29.500 --> 00:34:34.610
But if you take a closer look, block
baz is actually next to the block.

00:34:34.610 --> 00:34:43.420
It's been invoked in, within block bar and block
bar has been inqueued directly onto queueB.

00:34:43.420 --> 00:34:50.369
And because block baz is nested within block
bar, we actually see it as executing on queueB

00:34:50.369 --> 00:34:53.509
and that's why it's going to appear
in your blocks view as well.

00:34:53.510 --> 00:35:00.650
So to recap, you can optimize the performance of your target
applications running with Dispatch by looking at the blocks

00:35:00.650 --> 00:35:04.070
with the longest duration and the
blocks that are executed the most

00:35:04.070 --> 00:35:09.559
and you can also understand the analysis
of applications running lib-Dispatch.

00:35:09.559 --> 00:35:15.349
All right let's switch gears and talk about some
memory analysis that you can do in Snow Leopard.

00:35:15.349 --> 00:35:23.009
I'm going to bring up Daniel Delwood to tell you about how
you can optimize memory and performance in Snow Leopard.

00:35:23.010 --> 00:35:30.330
[ Applause ]

00:35:30.329 --> 00:35:30.980
>>Daniel: So howdy.

00:35:30.980 --> 00:35:34.789
I'm Daniel Delwood, performance tools engineer and I'm here

00:35:34.789 --> 00:35:38.769
to change your perspective a little
bit, to talk about memory.

00:35:38.769 --> 00:35:44.259
And we're going to start out by talking about retain/release
which should be very familiar to you as Cocoa developers.

00:35:44.260 --> 00:35:50.460
So retain/release mechanics are very simple to
understand the rules, but they're hard to follow perfectly

00:35:50.460 --> 00:35:58.309
and when you over-retain something it leads to leaks and
we've presented a leaks template for you in Instruments

00:35:58.309 --> 00:36:04.210
since Leopard, but over-releases are also
another type of retain/release problem

00:36:04.210 --> 00:36:07.340
and these have been historically a lot harder to track down.

00:36:07.340 --> 00:36:10.940
Well now there's an instrument for that.

00:36:10.940 --> 00:36:15.990
[laughter] So over-released objects, what
are they and how does that work into a crash?

00:36:15.989 --> 00:36:20.919
Well, let's say I have my object
and two other objects, A and B.

00:36:20.920 --> 00:36:29.200
Well, when the last release gets sent to my objects
it's then freed and any subsequent messages sent

00:36:29.199 --> 00:36:32.919
to it cause the crash because that
memory's freed, it's no longer an object,

00:36:32.920 --> 00:36:36.430
and the runtime doesn't know what to do with the message.

00:36:36.429 --> 00:36:42.169
So what the Zombies template does is it turns --

00:36:42.170 --> 00:36:48.409
it changes behavior of that last release into
making that object a Zombie instead of freeing it.

00:36:48.409 --> 00:36:52.859
So the object just stays around in the
lifetime a year process right up to the end

00:36:52.860 --> 00:36:58.960
and that way any future errant messages that
get sent to it just cause the Zombie object

00:36:58.960 --> 00:37:03.349
to emit a message that we can then record in Instruments.

00:37:03.349 --> 00:37:10.089
So the Zombies template then is for detecting those
messages and then also for presenting the retain/release

00:37:10.090 --> 00:37:14.190
and autorelease histories of those Zombie objects.

00:37:14.190 --> 00:37:20.309
Now to show you what I mean why don't we go
ahead and see a demo of this and show you Sketch.

00:37:20.309 --> 00:37:24.019
This is probably everybody's favorite
drawing program, I'm sure.

00:37:24.019 --> 00:37:28.849
So I can draw some shapes, you know,
perhaps add a color to one of these

00:37:28.849 --> 00:37:31.339
but what I want to do is add a feature to Sketch.

00:37:31.340 --> 00:37:39.190
And while I like resizing the canvas, I wish my
graphics inside Sketch would resize with them.

00:37:39.190 --> 00:37:43.400
Of course during the real life resize, if
I change the bounds on them constantly,

00:37:43.400 --> 00:37:48.519
they get a little bit performance intensive
and so what I've done is I've implemented this

00:37:48.519 --> 00:37:56.630
so that every time I do a live resize it creates a renderer
for the view and that renderer just cashes in NSImage

00:37:56.630 --> 00:38:01.800
and stretches the image and then does
the balance calculation when I let go.

00:38:01.800 --> 00:38:04.840
And so as you can see on that last, what?

00:38:04.840 --> 00:38:06.690
Oh, I've got a crash.

00:38:06.690 --> 00:38:12.630
So I go back to GBD and take a look and it looks
like I'm crashing in Objective-C message send.

00:38:12.630 --> 00:38:21.329
So this is probably an over-release and let me
go ahead and try finding this in Instruments.

00:38:21.329 --> 00:38:28.239
So you go to the run menu, run
the performance tools, Zombies,

00:38:28.239 --> 00:38:34.709
and Instrument starts up and Sketch
starts in the background.

00:38:34.710 --> 00:38:39.949
Now you'll notice this is ObjectAlloc which
is our tool for recording all of the malloc --

00:38:39.949 --> 00:38:43.829
free events and all the objects
created in your process lifetime

00:38:43.829 --> 00:38:49.319
and if I hit the inspector button there are some additional
options here including the reference count recording

00:38:49.320 --> 00:38:55.059
that we have on and our Zombie detection, which
changes the behavior of the last released objects.

00:38:55.059 --> 00:39:00.840
So I'll go back to my application and exercise
my feature and try to get it to crash.

00:39:00.840 --> 00:39:04.050
And there it goes, it crashed just right on cue.

00:39:05.559 --> 00:39:12.179
Well, Instruments provides a flag, a message to
me saying that a Zombie was messaged and if I zoom

00:39:12.179 --> 00:39:18.279
in here you'll notice that it says an Objective-C
message was sent to a deallocated object

00:39:18.280 --> 00:39:21.530
at this address and what point in time that happened.

00:39:21.530 --> 00:39:26.820
And if I click the focus button it transforms my detail view

00:39:26.820 --> 00:39:33.180
into the retain/release history for
the object that was messaged last.

00:39:33.179 --> 00:39:39.109
Well, it turns out we've got an NSBitmapImage
route and it was malloced at a certain point

00:39:39.110 --> 00:39:41.200
and then it was autoreleased and retained and released.

00:39:41.199 --> 00:39:48.079
There's quite a history here, in fact I can bring in the
extended detail view to see each of the stack traces.

00:39:48.079 --> 00:39:51.329
I'll just scroll all the way down, it was 51 events

00:39:51.329 --> 00:39:57.090
and the last one was the Zombie event
after it was supposedly deallocated.

00:39:57.090 --> 00:40:00.769
OK, so our job is to track down what the problem is.

00:40:00.769 --> 00:40:04.630
How does Instruments help you with that?

00:40:04.630 --> 00:40:11.000
Well there's a responsible library column which makes
an intelligent guess at what library was responsible

00:40:11.000 --> 00:40:15.440
for calling a certain reference counting point.

00:40:15.440 --> 00:40:20.760
So for this, this is our first release that it attributes
to Sketch and you'll notice it's called directly

00:40:20.760 --> 00:40:27.130
from our code NSketchSKTliveResizeRenderer snapshot view.

00:40:27.130 --> 00:40:31.170
Well, let's go there and take a
look and see if that's our problem.

00:40:31.170 --> 00:40:34.950
Go back to our code and here's our snapshot view code.

00:40:34.949 --> 00:40:37.210
Well, what do we know?

00:40:37.210 --> 00:40:41.610
We know it's an NSBitMap Image Wrap and
here's our Image Wrap getting created.

00:40:41.610 --> 00:40:50.860
We've got an alloc, init and we scroll over and yes, there's
an autorelease there, so our net retain count is zero

00:40:50.860 --> 00:40:54.800
and this will go away once the autorelease pull pops.

00:40:54.800 --> 00:41:00.820
So go down to the only other place it's used are draw
an image add representation, which itself if it wants

00:41:00.820 --> 00:41:05.630
to keep ownership will retain the image
wrap and then I release the image wrap.

00:41:05.630 --> 00:41:06.559
Wait a second.

00:41:06.559 --> 00:41:13.110
I already had a retain count of zero so this is
actually at fault, this shouldn't be happening.

00:41:13.110 --> 00:41:21.140
So I can go ahead and delete that, build and while on many
projects it will require a little bit more investigation,

00:41:21.139 --> 00:41:26.920
that first hint was correct in this one because
when we started up, draw a couple shapes

00:41:26.920 --> 00:41:30.789
and start resizing them, they resize fine.

00:41:30.789 --> 00:41:37.219
There we go, tracked it down.

00:41:37.219 --> 00:41:42.819
[applause] So that was tracking down some
retain/release problems and introduced

00:41:42.820 --> 00:41:45.910
in Leopard was the technology of Garbage Collection.

00:41:45.909 --> 00:41:52.710
It's a very, very powerful technology and one of the best
parts about it is that makes retain/release unnecessary.

00:41:52.710 --> 00:42:00.099
Your lifecycles of your objects are managed by
references and these references mean that as long

00:42:00.099 --> 00:42:05.610
as you are using an object or it's
referenced from a place in your code,

00:42:05.610 --> 00:42:11.420
it won't get collected by the Garbage Collector but
you still don't have to worry about retain/release.

00:42:11.420 --> 00:42:14.940
It's not a magic bullet, though,
and any unnecessary references

00:42:14.940 --> 00:42:19.309
in your code can actually lead to unnecessary memory usage.

00:42:19.309 --> 00:42:21.779
Now how is that?

00:42:21.780 --> 00:42:29.820
Well, we have an Instrument called the Object Graph
instrument and this is to help you manage those references

00:42:29.820 --> 00:42:32.920
and understand the behavior of your application.

00:42:32.920 --> 00:42:35.030
Well, first of all you have to understand roots.

00:42:35.030 --> 00:42:41.240
And roots are objects in your application
that the Garbage Collector will not collect

00:42:41.239 --> 00:42:45.959
because they're considered global
or they're considered top level.

00:42:45.960 --> 00:42:52.099
Well, the causes of a root are three things:
first of all you can have a global that points

00:42:52.099 --> 00:42:55.880
to an object and that will make it a root.

00:42:55.880 --> 00:43:03.960
Second it can be referenced by your stack, by the current
function on the stack in use by your code at the time

00:43:03.960 --> 00:43:07.869
and third, CF retains and CF releases are still respected

00:43:07.869 --> 00:43:14.409
under the Garbage Collection mechanism while
you can opt in for CF types if you wish.

00:43:14.409 --> 00:43:20.639
So the goal of Object Graph is to help you
understand what the roots are and, more importantly,

00:43:20.639 --> 00:43:23.779
what the path to your objects are from those roots.

00:43:23.780 --> 00:43:31.680
So for example the NSApplication root has a
delegate, which is the SKT App delegate in this case,

00:43:31.679 --> 00:43:39.259
and that actually has references to window controllers
for the panels that are used in the background.

00:43:39.260 --> 00:43:47.690
So I'm going to go ahead and show you a demo of using
the Object Graph instrument and how you can use it

00:43:47.690 --> 00:43:52.409
to understand the behavior of your app
while running under Garbage Collection.

00:43:52.409 --> 00:43:57.539
So same project, I'm just going to
switch it to using my GC configuration.

00:43:57.539 --> 00:44:06.949
And go ahead and build and start this directly
from Instruments, let me close the other document.

00:44:06.949 --> 00:44:14.509
So run, run with performance tool
and I'll use the GC monitor template.

00:44:14.510 --> 00:44:19.350
Now this template has three instruments, but for the
purpose of this demo I'm just going to focus on the first,

00:44:19.349 --> 00:44:25.819
the Object Graph instrument and what this is does is that
it periodically takes snapshots of my target application

00:44:25.820 --> 00:44:29.750
and all of the heap objects in that application.

00:44:29.750 --> 00:44:35.000
I'm going to turn that off for now because I'm going
to be talking a little bit more than doing analysis.

00:44:35.000 --> 00:44:42.059
And in the detail view here you'll notice it took a
snapshot of all of the objects and this is showing me all

00:44:42.059 --> 00:44:47.579
of the objects in my target application
filtered by the block filters on the left here.

00:44:47.579 --> 00:44:53.569
So currently I'm looking at just the user-defined
types which is what I usually am caring about most.

00:44:53.570 --> 00:45:01.890
In this case you'll notice I have a NSKBO notifying SKT
document as my GraphicView and even my app delegate here.

00:45:01.889 --> 00:45:08.809
And this view is for helping you understand the
strong references that Garbage Collection tracks,

00:45:08.809 --> 00:45:15.190
so if I turn down this SKTGraphicView, you'll
notice that its next responder is an NSClipView,

00:45:15.190 --> 00:45:19.450
its Window is this Window and I
can even turn down this Window

00:45:19.449 --> 00:45:24.019
and follow its graph even further
to its delegate or its border view.

00:45:24.019 --> 00:45:30.670
Now to top level, you also notice there's
some other statistics such as the thumb size,

00:45:30.670 --> 00:45:37.500
so for instance with this GraphicView, it's
referencing a total of about 33 kilobytes.

00:45:37.500 --> 00:45:43.349
So I'll go over to my Sketch window
here and I'll exercise my own function

00:45:43.349 --> 00:45:49.789
and now that I've done the live resize I'll close the
document and I expect that my document would be gone,

00:45:49.789 --> 00:45:54.099
my GraphicView would be gone and well,
most other objects would be gone.

00:45:54.099 --> 00:46:00.980
So I take a snapshot of my graph or
my process and it updates this view.

00:46:00.980 --> 00:46:05.860
If we look through here we'll notice
that the document isn't there, it's gone.

00:46:05.860 --> 00:46:11.920
But the GraphicView is still around in
my application holding on to that 30K.

00:46:11.920 --> 00:46:15.920
But why didn't Garbage Collection reclaim GraphicView?

00:46:15.920 --> 00:46:20.909
Well, to understand that, we have to
look for the roots of the GraphicView.

00:46:20.909 --> 00:46:28.549
So I'm going to select this GraphicViews
focus button and take a look at the roots.

00:46:28.550 --> 00:46:32.310
So this GraphicView only has one root and it's a MapTable.

00:46:32.309 --> 00:46:37.679
If I bring in the extended detail
view it will tell me why it's root.

00:46:37.679 --> 00:46:41.219
Now in this case its one of those three, it's a Global.

00:46:41.219 --> 00:46:45.989
The Global is called SKT_cachedRendererForView
and it gives me the address even.

00:46:45.989 --> 00:46:51.579
But more important to me is the pass
from this root to my GraphicView,

00:46:51.579 --> 00:46:55.940
why is it being kept alive and
this is really the shortest path.

00:46:55.940 --> 00:47:03.400
So my MapTable has keys and these keys are
GraphicViews, in this case my GraphicView.

00:47:03.400 --> 00:47:12.889
And if I go back to my code I can look for that
global and that global is defined right here,

00:47:12.889 --> 00:47:17.799
it's the static NSMap Table SKT_cachedRendererForView.

00:47:17.800 --> 00:47:22.830
So what this MapTable is doing and we'll take a
look at the creation point, it's creating a MapTable

00:47:22.829 --> 00:47:29.889
with standard key options and standard value options and
then the usage of this is that views get a RendererForView

00:47:29.889 --> 00:47:42.029
and so they're created lazily and then added to the key
value pair there as ViewToRenderer and then the contract is

00:47:42.030 --> 00:47:47.070
that View destroyed will be called when the
view goes away and we can go ahead and remove

00:47:47.070 --> 00:47:50.570
that key value pair from the table, releasing memory.

00:47:52.309 --> 00:47:58.900
However, this doesn't look like it's being called,
so if I search for it in the project I can see

00:47:58.900 --> 00:48:05.210
that it should have been called in one place
and I go there and whoa, it's in a dealloc.

00:48:05.210 --> 00:48:08.389
Well, deallocs aren't called under
Garbage Collection so this is a source

00:48:08.389 --> 00:48:11.480
of the difference in behavior between the two modes.

00:48:11.480 --> 00:48:13.610
Well there's a couple of ways we can fix this.

00:48:13.610 --> 00:48:16.280
The simplest is which to be to
just write a finalize and call it

00:48:16.280 --> 00:48:19.800
in the finalize, but finalizers really are a last resort.

00:48:19.800 --> 00:48:23.470
There's usually a better way to
do it, and in this case there is.

00:48:23.469 --> 00:48:29.439
I'll go back to the creation of that
table and what the problem was is

00:48:29.440 --> 00:48:36.039
that the keys were strongly referencing
my views, were strongly referencing.

00:48:36.039 --> 00:48:46.259
I can change this MapTable though so that the key
options only weakly reference it, oops, there we go.

00:48:46.260 --> 00:48:54.690
So I'm going to change the personality
of my MapTable and here we go.

00:48:54.690 --> 00:48:58.840
The key options are NSPointerFunctionsZeroingWeakMemory.

00:48:58.840 --> 00:49:06.190
So I'll save that, build it and go ahead
and run it right back in Instruments

00:49:06.190 --> 00:49:11.610
and see if my view goes away as I expect.

00:49:11.610 --> 00:49:19.010
So draw a couple images, create the renderer
and do the resize, close the document,

00:49:19.010 --> 00:49:23.550
take a snapshot and go back to the top level.

00:49:23.550 --> 00:49:26.750
So nope, we didn't quite fix it.

00:49:26.750 --> 00:49:30.710
So the document again is gone but
the SKTGraphicView is still here.

00:49:30.710 --> 00:49:37.659
This is because we looked at the shortest path
to a root but we didn't quite get everything.

00:49:37.659 --> 00:49:45.250
So if I again focus on this GraphicView and look
at the path to this, well again the same MapTable,

00:49:45.250 --> 00:49:50.570
I'll notice that it's no longer being referenced
by the keys, it's being referenced by the values.

00:49:50.570 --> 00:49:55.180
Now the MapTable again map the
views to the corresponding renderers

00:49:55.179 --> 00:50:00.409
but the renderers each have a delegate
view which is again that view.

00:50:00.409 --> 00:50:07.019
Well this is another one of the behavior changes
between Garbage Collected code and retain/release.

00:50:07.019 --> 00:50:11.940
Delegate view references are strong by default.

00:50:11.940 --> 00:50:17.440
So I go back to my code and I'll even take a
look at the interface and you'll notice here

00:50:17.440 --> 00:50:24.670
that I just declared an NSViewDelegateView and my comment
is not retained in typical delegate fashion for Cocoa.

00:50:24.670 --> 00:50:34.630
Well, all I need to do is add the
keyword under weak, save the document,

00:50:34.630 --> 00:50:40.500
build it and I will test it again in Instruments.

00:50:40.500 --> 00:50:49.050
Let me go ahead and stop this last race and we'll just
run it through here and again exercise my function

00:50:49.050 --> 00:50:55.019
and see if I expect that the memory behavior or see
if the memory behavior is what I expect it to be.

00:50:55.019 --> 00:50:59.380
So I go ahead and take a snapshot,
go back up to the top level

00:50:59.380 --> 00:51:05.190
and now the only two Sketch objects are the
tool palette controller and App Delegate.

00:51:05.190 --> 00:51:13.010
So I've correctly gotten rid of the roots to that view
and the GraphicView is collected by the collector.

00:51:13.010 --> 00:51:21.730
[ Applause ]

00:51:21.730 --> 00:51:31.510
>>OK, so it's a little bit complex there but our problem was
initially at looking at what was in our applications heap

00:51:31.510 --> 00:51:35.320
and then asking ourselves, why
did the SKTGraphicView never die?

00:51:35.320 --> 00:51:40.330
Well it was because of that one root, which is the
MapTable, and the MapTable was rooted by Global.

00:51:40.329 --> 00:51:45.909
It had keys and values and those keys initially
had strong references to the graphic views

00:51:45.909 --> 00:51:50.210
and the values were the renderers which
themselves had the images that they were caching

00:51:50.210 --> 00:51:54.429
and the delegate view strong reference
to our graphic view as well.

00:51:54.429 --> 00:52:05.449
Well, the first thing we did was go to the MapTable and by
putting in that key, that zeroingWeakMemory key personality,

00:52:05.449 --> 00:52:09.639
we changed the key's strong reference to be weak.

00:52:09.639 --> 00:52:15.650
And then we went over to the interface of
the renderer and by making that part weak

00:52:15.650 --> 00:52:24.599
as well we made the delegate view reference weak, which
meant that when the last strong reference externally

00:52:24.599 --> 00:52:29.889
to that GraphicView went away, our GraphicView
could be collected, and when it was collected,

00:52:29.889 --> 00:52:33.549
those weak references were nilled out by deflector

00:52:33.550 --> 00:52:39.710
and then the MapTable removed the value
pair since the key was no longer there.

00:52:39.710 --> 00:52:46.949
So the whole goal of all of this was to
understand our GCObject relationships

00:52:46.949 --> 00:52:52.279
and you can really use the ObjectGraphs
powerfully to understand those.

00:52:52.280 --> 00:53:00.820
You need to use it to understand the unnecessary
dependencies for your objects and try to eliminate

00:53:00.820 --> 00:53:06.080
that over-rootedness in your application that leads to
memory growth over time where you would have expected it

00:53:06.079 --> 00:53:09.000
to remain steady or to even go back down.

00:53:09.000 --> 00:53:14.010
So with that I'll like to invite Lynne back up.

00:53:14.010 --> 00:53:20.610
[ Applause ]

00:53:20.610 --> 00:53:22.050
>>All right, thank you, Daniel.

00:53:22.050 --> 00:53:27.030
So in Snow Leopard we've introduced
a couple of other features.

00:53:27.030 --> 00:53:35.700
In Snow Leopard you can now launch Agent and daemon
targets and you can do that by selecting launch executable,

00:53:35.699 --> 00:53:41.980
choosing your executable, which will bring up the
target chooser and in the last column you can see,

00:53:41.980 --> 00:53:49.730
under the category of launchd the options
of launching Agent and daemon targets.

00:53:49.730 --> 00:53:53.869
And for example you know I'm going to
go ahead and launch the dock agent.

00:53:53.869 --> 00:54:02.469
So after I select that, Instruments is going
to defer to launchd to launch the dock agent

00:54:02.469 --> 00:54:09.719
and when you hit the record button, instead of beginning
the recording process you're actually going to see a panel

00:54:09.719 --> 00:54:15.019
that asks you to take the appropriate action
in order to start this agent or daemon.

00:54:15.019 --> 00:54:18.489
So in the case of the dock you know
you just move your mouse all the way

00:54:18.489 --> 00:54:21.599
to the bottom of the screen to launch the dock daemon.

00:54:21.599 --> 00:54:29.860
All right, so ObjectAlloc collects a lot of
data and it might incur a certain overhead.

00:54:29.860 --> 00:54:37.690
In Snow Leopard we've added ObjectAlloc filtering
so that you can choose to exclude certain types

00:54:37.690 --> 00:54:40.820
of objects from the data that ObjectAlloc collects.

00:54:40.820 --> 00:54:47.820
So in this case you can actually set this up by clicking
the info button on the ObjectAlloc Instruments and choosing,

00:54:47.820 --> 00:54:52.400
for example, to ignore types with
prefix NS, with prefix CF, et cetera,

00:54:52.400 --> 00:54:55.940
so that you can minimize the amount
of data that ObjectAlloc collects.

00:54:55.940 --> 00:55:01.070
And just focus on the objects that you care
about that are not created by the system.

00:55:01.070 --> 00:55:11.500
All right, and also leaks, you can set it up so that it
throws away lifecycle complete objects meaning you only care

00:55:11.500 --> 00:55:16.170
about objects that are malloced and
you know are still in your memory.

00:55:16.170 --> 00:55:20.450
Not objects that are malloced and
then released and have gone away.

00:55:20.449 --> 00:55:28.079
All right so in Snow Leopard we've introduced flags that
are really bookmarks that allow you to pinpoint areas

00:55:28.079 --> 00:55:32.809
in your track or in your execution time
where interesting things have happened.

00:55:32.809 --> 00:55:39.299
So we've seen this flags in action in Zombies Instrument
and really they're also user flags that you can add

00:55:39.300 --> 00:55:44.950
into your documents and in this case, you know,
you can add a little comment saying for example,

00:55:44.949 --> 00:55:53.849
this is the point where I've clicked Safari
in my dock and I'd like to bookmark that.

00:55:53.849 --> 00:56:00.889
In Snow Leopard we have faster symbolication of stack
traces and we have symbols for lazily loaded libraries.

00:56:00.889 --> 00:56:06.690
So that will make you and your stack
traces much faster and much more efficient.

00:56:06.690 --> 00:56:10.990
So Instruments is a very powerful analysis tool.

00:56:10.989 --> 00:56:16.789
We've seen a whole set of new instrumentation that we've
introduced in Snow Leopard that will allow you to leverage,

00:56:16.789 --> 00:56:20.070
use Snow Leopard technologies and understand it.

00:56:20.070 --> 00:56:26.370
And also instrumentation that deals with memory
analysis such as Garbage Collection and Zombies.

00:56:27.380 --> 00:56:34.079
In Snow Leopard we've made it very easy for you to pinpoint
and locate the data that you care about very easily

00:56:34.079 --> 00:56:38.000
and finally we've improved the
overall performance of Instruments.

00:56:38.000 --> 00:56:44.699
So I'd like you to go home and whether you've,
you know, used Instruments before in Leopard

00:56:44.699 --> 00:56:47.399
or this is the first time you've
used Instruments, give it a spin.

00:56:47.400 --> 00:56:52.039
Try out all our new features in Snow
Leopard and if you have any questions,

00:56:52.039 --> 00:56:56.250
please feel free to email Michael
Jurewitz, our Developer Tools Evangelist.

00:56:56.250 --> 00:57:01.210
There's some Instrument documentation and
Concurrency Programming documentation available

00:57:01.210 --> 00:57:03.960
in the Xcode documentation on your Macs.
WEBVTT

00:00:13.720 --> 00:00:17.750
>> My name is Dan Keen, I'm an iPhone
applications engineer and I'm here to talk

00:00:17.750 --> 00:00:21.490
to you today about iPhone views and animations.

00:00:21.489 --> 00:00:29.519
But before we start, I just want to give you a demo of
what we'll be able to do at the end of this session.

00:00:29.519 --> 00:00:35.009
So what we have here is something that
I sort of like to Call System Emulator.

00:00:35.009 --> 00:00:45.170
It is an emulator for an old 1950s IBM 1401
computer, a good use of modern hardware.

00:00:45.170 --> 00:00:50.300
The Computer History Museum down in Mountain
View is actually restoring one of these

00:00:50.299 --> 00:00:54.569
and I spent a little time volunteering there and I
figured what better way to get to know the machine

00:00:54.570 --> 00:00:58.289
that to write an emulator for it and I thought
it would actually be a pretty cool demo

00:00:58.289 --> 00:01:01.119
for WWDC 'cause it does a bunch of things.

00:01:01.119 --> 00:01:04.189
Up here we have a print view basically.

00:01:04.189 --> 00:01:10.599
It's an old green and white with you know the
dots on the aside and it's actually fairly white

00:01:10.599 --> 00:01:15.989
as you can see here 'cause it prints a 132 characters.

00:01:15.989 --> 00:01:20.500
Here we have the address field which is
the next program instruction counter.

00:01:20.500 --> 00:01:31.569
It's actually in binary-coded decimal with a check pit here
for the parity, so 8, 4, 2, and 1 for each actual 10s digit.

00:01:31.569 --> 00:01:34.709
We have the A&B location registers.

00:01:34.709 --> 00:01:37.049
This machine actually has no registers at all.

00:01:37.049 --> 00:01:44.759
Instruction length, op codes, and we have these bunch
of lights just like you'd see on the front of a real IBM

00:01:44.760 --> 00:01:48.740
and then we have three buttons here that are made
to look like the buttons on the front of the IBM,

00:01:48.739 --> 00:01:51.679
the "Start," "Check Reset" and the "Stop" button.

00:01:51.680 --> 00:01:55.340
So if you were to actually hit the "Start" button,
you'll see the lights are going to blink a bunch

00:01:55.340 --> 00:01:58.340
and then it's going to go off and
start calculating powers of 2.

00:01:58.340 --> 00:02:00.100
The 1401 was a business machine.

00:02:00.099 --> 00:02:06.059
It actually has an unlimited word length,
it will calculate as long as you want,

00:02:06.060 --> 00:02:10.650
this will go until it fills up the
print view, and you can stop it.

00:02:10.650 --> 00:02:14.780
You can decide, oh I want to tear off this
page of paper and hand it down to accounting.

00:02:14.780 --> 00:02:21.099
So you know you tear off the page, then you
start it up again, it picks up where it left off

00:02:21.099 --> 00:02:27.370
and well clearly this run off our space so we can drag
it over here and it's running while we're dragging.

00:02:27.370 --> 00:02:32.610
And then you can decide, oh you know actually, I kind
of want to go on the instruction at a time so you pull

00:02:32.610 --> 00:02:39.850
out the little sheet here and you say, all right let's
run at a single cycle and so then it goes one instruction

00:02:39.849 --> 00:02:49.039
at a time and likewise we can actually
set up an address to stop at here.

00:02:49.039 --> 00:02:53.229
This is much easier on the phone
itself to spin those wheels.

00:02:53.229 --> 00:03:01.399
So if we set that breakpoint then we'll see that it prints
one line each time so we're using supports breakpoint mode.

00:03:01.400 --> 00:03:06.099
So that's my cute little demo and what I'm going to
show you at the end of the day, there's a lot here.

00:03:06.099 --> 00:03:07.460
I clearly can't cover all of these.

00:03:07.460 --> 00:03:12.000
I'm definitely not going to cover any of the
emulation itself because that's not really pertinent

00:03:12.000 --> 00:03:17.520
but what I will cover is how to do this light panel in
the middle which is probably the flashiest part of it.

00:03:17.520 --> 00:03:21.480
You know, it's blinking lights on and off constantly.

00:03:21.479 --> 00:03:27.069
So, but we need to go through some things
before we can get to the point where we do that.

00:03:27.069 --> 00:03:31.310
So let's start off by saying, well
OK this was Views and Animations,

00:03:31.310 --> 00:03:34.259
so first we need to talk about views and what are views.

00:03:34.259 --> 00:03:39.459
So this is an example from the Address
Book, this is an NavBar at the top,

00:03:39.460 --> 00:03:43.370
and you'll see that there are actually
three subviews in this view.

00:03:43.370 --> 00:03:50.170
We have the Groups View, the All Contacts TXT
and actually the "+" button on the other side.

00:03:50.169 --> 00:03:55.519
We're also going to talk about controls because,
you know, with not being able to interact

00:03:55.520 --> 00:04:01.100
with your software it's really just going to
be a pretty seam demo so in the same example,

00:04:01.099 --> 00:04:03.930
we have two controls, the Groups and the "+" button.

00:04:03.930 --> 00:04:09.939
So we're going to talk a bit about them and then
finally we're going to talk about animations.

00:04:09.939 --> 00:04:13.990
Animations are very pretty, everyone loves
animations but we're also going to you know,

00:04:13.990 --> 00:04:17.069
say they provide a lot of context to the user.

00:04:17.069 --> 00:04:20.750
So in this example, what happens when
you actually click the "Groups" button,

00:04:20.750 --> 00:04:24.709
a bunch of animations kick off that
you might not have ever realized.

00:04:24.709 --> 00:04:29.639
The Groups is going to slide over
and cross fade into the Groups TXT.

00:04:29.639 --> 00:04:33.849
All Contacts itself is going to slide
over and fade out while it's doing that.

00:04:33.850 --> 00:04:37.790
And the "+" button is actually going
to remain stationary and just fade out.

00:04:37.790 --> 00:04:41.430
So we actually have three, well four different
animations if you count the Groups TXT that's coming

00:04:41.430 --> 00:04:44.959
in across fading with the "Groups" button.

00:04:44.959 --> 00:04:48.680
So in slow mo you can see all those
animations happening at once

00:04:48.680 --> 00:04:51.879
and the reason we do all these is
to provide context to the user.

00:04:51.879 --> 00:04:59.029
The views are sliding, so you'll actually see the view--
the content below the sliding but the bar is going to remain

00:04:59.029 --> 00:05:04.919
in the same place so in order to provide contacts there,
we're doing this nice animation and then when you click

00:05:04.920 --> 00:05:10.090
on Group, we'll do the exact reverse animation
to bring you right back to where you were.

00:05:10.089 --> 00:05:12.969
So those are pretty much the three kinds
of things we're going to cover today.

00:05:12.970 --> 00:05:15.320
So we'll start off with a view.

00:05:15.319 --> 00:05:16.339
What is a view?

00:05:16.339 --> 00:05:22.129
So a view inherits from our pseudobase class NSObject.

00:05:22.129 --> 00:05:25.110
From there we have UIResponder.

00:05:25.110 --> 00:05:31.069
A UIResponder is responsible for handling events
and forwarding them up the responder chain.

00:05:31.069 --> 00:05:34.610
I'm not really going to talk much about
UIResponder or the responder chain,

00:05:34.610 --> 00:05:37.470
stuff like that, or events that much in detail here.

00:05:37.470 --> 00:05:44.200
If you want to know more information about that, on Thursday
morning at 9, in this room is processing multi-touch events

00:05:44.199 --> 00:05:46.370
on iPhone and I would highly recommend going to that.

00:05:46.370 --> 00:05:49.319
It will be a very interesting lecture.

00:05:49.319 --> 00:05:50.490
From there we get UIView.

00:05:50.490 --> 00:05:55.980
So you can see it's actually a very simple
inheritance hierarchy here just NSObject, UIResponder,

00:05:55.980 --> 00:06:00.140
UIView and the UIView is responsible
for actually drawing the content

00:06:00.139 --> 00:06:03.149
on the screen, making the pretty actually happen.

00:06:03.149 --> 00:06:06.569
So we know that UIView is responsible for that.

00:06:06.569 --> 00:06:09.540
We need to define some things in
order to make them work properly.

00:06:09.540 --> 00:06:12.920
The first thing we need to do is we need to have a
coordinate system so we know where we're drawing.

00:06:12.920 --> 00:06:20.500
If you're familiar with other API design, for
instance App Kit, the origin is in the bottom left.

00:06:20.500 --> 00:06:26.189
On the iPhone, the origin is actually in the top
left and as Y increases, it moves down the phone,

00:06:26.189 --> 00:06:29.079
as X increases it goes from left to right.

00:06:29.079 --> 00:06:32.060
So we have a coordinate system that's
actually pretty straightforward.

00:06:32.060 --> 00:06:35.670
Then we need to define what the views themselves are.

00:06:35.670 --> 00:06:38.610
So Views are actually just rectangles.

00:06:38.610 --> 00:06:43.939
Easiest way to remember, the view is always
a rectangle and you define it with its frame.

00:06:43.939 --> 00:06:51.040
So a frame will have an origin, in this case we
have an origin of 140, 30 so we are over 140 pixels

00:06:51.040 --> 00:06:59.680
from the top left and down 30 pixels and the frame also
has a size parameter and in this case will be 200, 100.

00:06:59.680 --> 00:07:02.519
So this view is 200 pixels wide, 100 pixels tall.

00:07:02.519 --> 00:07:09.199
We're not defining where the lower left-- lower point
there is in coordinates, we're actually defining

00:07:09.199 --> 00:07:11.719
as a size so based off of where the origin is.

00:07:11.720 --> 00:07:16.610
So this defines in the superview, so you can take
a view and you can stack it inside of other views

00:07:16.610 --> 00:07:20.480
and the frame will give you the coordinate
system in the superviews coordinates.

00:07:20.480 --> 00:07:25.140
There is also Bounds which gives you the
coordinate system in the view's own coordinates.

00:07:25.139 --> 00:07:33.019
So in that case, the size is going to remain exactly
the same, at 200, 100 but the origin actually uses 0,

00:07:33.019 --> 00:07:38.819
0 because remember we've now translated the
coordinate system to the NSViews coordinate system.

00:07:38.819 --> 00:07:42.839
That's pretty straightforward, it's you know, you
sometimes have to wrap your head around it a bit

00:07:42.839 --> 00:07:45.849
but it's relatively easy to do translations in that respect.

00:07:45.850 --> 00:07:49.360
It becomes more complex when you have transforms on views.

00:07:49.360 --> 00:07:53.750
So a view has a property transform
which you can give a CGFI transform.

00:07:53.750 --> 00:07:59.050
So let's say we took a 45-degree counterclockwise
rotation and applied it to this view.

00:07:59.050 --> 00:08:04.199
In this case, the bounds is going to
remain exactly the same 'cause remember

00:08:04.199 --> 00:08:06.649
that the bounds is in the views' coordinate system.

00:08:06.649 --> 00:08:09.349
So it doesn't care what transform is applied to it.

00:08:09.350 --> 00:08:12.050
It's always going to be consistent with the view itself.

00:08:12.050 --> 00:08:17.949
So the origin is still going to be 0,
0 and the size is going to be 200, 100.

00:08:17.949 --> 00:08:19.209
That's relatively straightforward.

00:08:19.209 --> 00:08:22.259
What happens to the frame though when we have a transform?

00:08:22.259 --> 00:08:23.719
Frame is a lot more complex.

00:08:23.720 --> 00:08:25.360
Because we said views are rectangles.

00:08:25.360 --> 00:08:30.030
So you can say OK it's a rectangle that's
rotated, it should still be the same thing.

00:08:30.029 --> 00:08:33.019
But the rectangles in the parent's
coordinate system, the parent doesn't care

00:08:33.019 --> 00:08:35.539
that the view is rotated, it just
cares that it's a rectangle.

00:08:35.539 --> 00:08:41.179
So the frame is actually the bounding box around this view.

00:08:41.179 --> 00:08:51.559
In that case the origin becomes a 133.9, negative
26.0, and the size becomes a square at 212.1, 212.1.

00:08:51.559 --> 00:08:55.609
There's no way you're going to ever be
able to calculate this properly yourself,

00:08:55.610 --> 00:09:01.100
so generally if you're dealing anything with
transforms which either you could be doing yourself

00:09:01.100 --> 00:09:07.019
or during a rotation animation or something like
that, it's much easier to rely on the bounds.

00:09:07.019 --> 00:09:14.389
However, the bounds as we saw, the origin is in its own
coordinate system so we can't position views with bounds.

00:09:14.389 --> 00:09:16.279
So how do we actually position the view?

00:09:16.279 --> 00:09:18.689
There's also a center property

00:09:18.690 --> 00:09:22.140
The center defines the exact center of the view.

00:09:22.139 --> 00:09:28.610
So this will remain the same no matter what transform
you imply, if you rotate the view, if you scale the view,

00:09:28.610 --> 00:09:34.639
it's always going to be scaled by the center, so it's easy
to always rely on the center property as being an easy way

00:09:34.639 --> 00:09:37.149
to position the view and the bounds
as a way to change its size.

00:09:37.149 --> 00:09:43.949
So you could say you know, OK always use bounds and center
but the thing is, it's a lot easier to just use frame

00:09:43.950 --> 00:09:47.470
and so you'll find that myself and many
other people just use frame most of the time

00:09:47.470 --> 00:09:50.940
and only worry bounds and center when we need to.

00:09:50.940 --> 00:09:53.260
All right, so how about combining views.

00:09:53.259 --> 00:09:59.779
We know that we can stack views within each other,
so let's say that you had a wide superview and inside

00:09:59.779 --> 00:10:03.740
of there you wanted to put another view, so
you have a subview but this view is going

00:10:03.740 --> 00:10:05.740
to be tall and skinny and you would add it to it.

00:10:05.740 --> 00:10:10.350
It would actually end up looking like
this on the screen and why is this?

00:10:10.350 --> 00:10:14.700
This is because we actually do not
clip to bounds in the superview.

00:10:14.700 --> 00:10:19.520
>> If you have a subview that extends beyond the
bounds of the view, it's not going to be clipped.

00:10:19.519 --> 00:10:20.470
This can be useful.

00:10:20.470 --> 00:10:21.360
This can also be bad.

00:10:21.360 --> 00:10:24.970
Most of the times you're probably not
expecting this to be what happens.

00:10:24.970 --> 00:10:30.970
So if you want to change UIView setClipsToBounds:YES.

00:10:30.970 --> 00:10:33.139
Now, why is this off by default?

00:10:33.139 --> 00:10:35.730
Well, first of all this is the result we get.

00:10:35.730 --> 00:10:38.850
It's very expensive to calculate.

00:10:38.850 --> 00:10:42.820
In this case it's pretty easy because you can
blit to a point and then we can say OK this is

00:10:42.820 --> 00:10:45.320
where the end of it and so we can stop blitting.

00:10:45.320 --> 00:10:50.690
If we rotate 90 degrees then we can blit in columns and
that's still pretty decent but if you're ever rotated

00:10:50.690 --> 00:10:55.350
at 45 degrees or anything like that, then you have
to do a stride and that becomes much more expensive,

00:10:55.350 --> 00:11:00.680
drawing becomes much more expensive, it's generally
bad and so because of that, this off by default.

00:11:00.679 --> 00:11:04.789
You're welcome to turn it on as you need it but
realize that there is a drawing penalty here.

00:11:04.789 --> 00:11:10.829
So now you have your views, you have your subviews,
you can decide whether you're going to clip or not.

00:11:10.830 --> 00:11:12.620
Now you want to actually position them.

00:11:12.620 --> 00:11:19.570
So you can position them really at anytime you want and I'm
here to say always position your views in layoutSubviews.

00:11:19.570 --> 00:11:26.270
So let's say we're adding a bunch of views, so we have
a green view, a blue view, a red view, a silver view,

00:11:26.269 --> 00:11:31.210
a light blue view, throw them only
into the origin when you start.

00:11:31.210 --> 00:11:34.139
And then in the layoutSubviews call, you're going to want

00:11:34.139 --> 00:11:38.909
to actually position them properly
so then you can have a nice view.

00:11:38.909 --> 00:11:42.789
We'll get a little bit more into that in
a second but first, why layoutSubviews?

00:11:42.789 --> 00:11:45.949
Well for one thing it's fast.

00:11:45.950 --> 00:11:50.570
Let's say you have a view and you're application is running.

00:11:50.570 --> 00:11:51.750
So the NSRunLoop is running.

00:11:51.750 --> 00:11:55.200
I'm not really going to get into event processing
here or the run loop or anything like that

00:11:55.200 --> 00:11:59.440
but eventually something is going to kick off
either your code or the systems code running.

00:11:59.440 --> 00:12:03.610
Say an event comes in or a source fires and NSTimer fires.

00:12:03.610 --> 00:12:07.259
At that point you may decide that your view needs change.

00:12:07.259 --> 00:12:09.500
So how do you change the layout of your view?

00:12:09.500 --> 00:12:14.340
You actually want to call UIView setNeedsLayout.

00:12:14.340 --> 00:12:20.100
And you'll call that on the view that needs the layout
and then you'll return to your code and you may decide,

00:12:20.100 --> 00:12:24.290
oh actually something else has changed because now you've
checked something else either on the server somewhere

00:12:24.289 --> 00:12:30.219
or whatever, so you need to do it again
and so you'll UIView setNeedsLayout.

00:12:30.220 --> 00:12:34.460
This is awesome because setNeedsLayout
is just basically a flag change.

00:12:34.460 --> 00:12:37.810
It's very lightweight, there's a very
little performance head to calling it.

00:12:37.809 --> 00:12:39.959
It's a good idea.

00:12:39.960 --> 00:12:42.650
Then eventually your code will return to the run loop.

00:12:42.649 --> 00:12:47.840
At this point, at the end of the run loop, it
will actually call UIView layoutSubviews for you.

00:12:47.840 --> 00:12:52.240
So it'll collate all of this setNeedsLayout
that will happen during this run loop cycle

00:12:52.240 --> 00:12:55.889
and it will call layoutSubviews just once for them.

00:12:55.889 --> 00:13:00.100
So this makes it vary performing in order
to be able to lay out things properly

00:13:00.100 --> 00:13:03.830
so you don't lay out many times in between.

00:13:03.830 --> 00:13:08.250
Some tips and tricks about positioning your views.

00:13:08.250 --> 00:13:15.450
First of all, like I said before, don't position
views in either loadView or initWithFrame.

00:13:15.450 --> 00:13:19.890
It's really easy to that because you go, oh well this
is when I'm actually adding my views to my hierarchy,

00:13:19.889 --> 00:13:22.679
I know where they're supposed to
go, I'm just going to do that.

00:13:22.679 --> 00:13:26.169
Every time I personally have done
that, I've ended up regarding it later.

00:13:26.169 --> 00:13:30.929
Because if some thing comes up, you decide, oh
I need to just support landscape orientation

00:13:30.929 --> 00:13:35.339
or something somewhere has changed and the
views have just shift a little bit and if all

00:13:35.340 --> 00:13:40.280
of your logic is an initWithFrame, you then
have to duplicate that logic elsewhere.

00:13:40.279 --> 00:13:43.319
So just put all into layoutSubviews.

00:13:43.320 --> 00:13:46.940
Second thing is don't ever call layoutSubviews directly.

00:13:46.940 --> 00:13:53.330
Like I said earlier we call setNeedsLayout and then the
system itself will call layoutSubviews when it needs to.

00:13:54.559 --> 00:14:00.679
Of course, you will need to call super layoutSubviews on
occasion when you're subclassing something and it needs

00:14:00.679 --> 00:14:05.809
to pass that call back up to its super in
order for things to be laid out properly.

00:14:05.809 --> 00:14:12.169
If you really, really need to have a
layout done, use UIView layoutIfNeeded.

00:14:12.169 --> 00:14:15.009
Now why would you use this instead
of calling layoutSubviews?

00:14:15.009 --> 00:14:19.149
So remember we had this setNeedsLayout that
gets called whenever something actually changes

00:14:19.149 --> 00:14:20.879
that your view needs to handle.

00:14:20.879 --> 00:14:26.740
So if you use layoutIfNeeded, it will return early
if that hasn't been called yet and you can assume

00:14:26.740 --> 00:14:30.180
that the view is laid out to how you want it.

00:14:30.179 --> 00:14:34.409
Finally, you actually don't need to call
setNeedsLayout yourself most of the time.

00:14:34.409 --> 00:14:39.490
Sometimes you do if you know that a model change has
happened that you're going to want to reflect in the view.

00:14:39.490 --> 00:14:44.649
But for instance, if just the size of your view has
changed, the system itself will call setNeedsLayout

00:14:44.649 --> 00:14:49.549
and it will automatically then
call layoutSubviews as needed.

00:14:49.549 --> 00:15:00.629
So here comes the first demo where we decide that we need to
lay out the lights on the front of the panel for this thing.

00:15:00.629 --> 00:15:06.639
So for those who have come in later, this is going
to be what we're going to end up designing at the end

00:15:06.639 --> 00:15:10.129
and what we're going to actually
lay out are these lights here.

00:15:10.129 --> 00:15:17.399
So if we get rid of the final version and go to here,

00:15:17.399 --> 00:15:23.019
you'll see we started out with what's basically a
blank light panel here, we have no views at all.

00:15:23.019 --> 00:15:30.579
The first we're going to want to do
is actually add the views themselves.

00:15:30.580 --> 00:15:36.970
Now I'm going to add a comment here just to kind of
drag this home, set up the different light views,

00:15:36.970 --> 00:15:39.620
size them to fit now, they won't
change later and we need to--

00:15:39.620 --> 00:15:43.070
so we don't need to update the
size every time in layoutSubviews.

00:15:43.070 --> 00:15:48.129
Don't position things here, just add it.

00:15:48.129 --> 00:15:51.990
So we have this light view which is going to have
four digits, this is going to be the program address.

00:15:51.990 --> 00:15:55.960
We're going to set its title to be address
and we're then going to call size to fit,

00:15:55.960 --> 00:15:59.060
so the light views themselves are actually relatively smart.

00:15:59.059 --> 00:16:04.529
They know that if they are four digits, they are
B, C, D, they just need a C, an 8, a 4, 2 and a 1.

00:16:04.529 --> 00:16:09.089
They know exactly how wide and how tall they need
to be and so they will set their size properly

00:16:09.090 --> 00:16:12.480
and then we add the subview to ourselves.

00:16:12.480 --> 00:16:21.560
So if we're going to run this now, we'll see that
we have a nice ugly gray box up in the corner here.

00:16:21.559 --> 00:16:24.299
It has no positioning information.

00:16:24.299 --> 00:16:31.149
All right, well let's add the views just so we can have
a bunch of ugly gray boxes all on top of each other.

00:16:31.149 --> 00:16:39.519
So we add the other views and now as
expected, we have a bunch of ugly gray boxes.

00:16:39.519 --> 00:16:40.730
They're all just on top of each other.

00:16:40.730 --> 00:16:44.889
We haven't given any position information but you'll
see that they all have slightly different sizes

00:16:44.889 --> 00:16:49.659
because they're relatively smart and
they know that they need to size to fit.

00:16:49.659 --> 00:16:55.309
So the light panel itself and where we're adding this,
it's in initWithFrame the light panel itself inherits

00:16:55.309 --> 00:17:05.779
from UIView, so because it's a UIView subclass we can just
actually create a layoutSubviews implementation, like so.

00:17:05.779 --> 00:17:09.670
And the first thing we're going to do is we're
going to go back to that original program address

00:17:09.670 --> 00:17:12.860
that we did and we're going to lay it out.

00:17:12.859 --> 00:17:19.729
So remember that we did this size to fit earlier,
so the size for this view is already correct,

00:17:19.730 --> 00:17:23.769
we don't want to wipe that, so we don't want to
actually change the size parameter on the frame at all.

00:17:23.769 --> 00:17:29.170
So the best way to do that is to just pull out the
full frame initially and then just change it's origin

00:17:29.170 --> 00:17:31.519
to this point which you know we've calculated earlier.

00:17:31.519 --> 00:17:40.210
Our HI designer decided to spec that this is exactly
where it should be and then we say set frame on it.

00:17:40.210 --> 00:17:46.240
And you'll see that now we have a nice ugly
little gray box that's in its proper location.

00:17:46.240 --> 00:17:49.440
Note that we never called setNeedsLayout
here or anything like that.

00:17:49.440 --> 00:17:51.470
We never called layoutSubviews directly.

00:17:51.470 --> 00:17:53.269
We never called layoutIfNeeded.

00:17:53.269 --> 00:17:56.410
This just automatically got called for us.

00:17:56.410 --> 00:18:04.130
So let's make sure the other gray views also go into
the right place by adding the rest of the code here.

00:18:04.130 --> 00:18:08.530
They're all basically exactly the same thing and
now they're all laid out to their right positions.

00:18:08.529 --> 00:18:13.139
They don't look that great yet but
at least they're in the right places.

00:18:13.140 --> 00:18:18.690
So as you can see that the rest of them is just a
copy of the code above with different orgin points.

00:18:18.690 --> 00:18:21.740
So we'll get to actually drawing them in a second.

00:18:21.740 --> 00:18:26.240
But first we need to know how do you actually do that.

00:18:26.240 --> 00:18:27.319
So what is UIView?

00:18:27.319 --> 00:18:32.769
We know that it, you know, inherits from UIResponder
and from the NSObject, but what does it actually do?

00:18:32.769 --> 00:18:36.529
It's actually just a thin wrapper around a CALayer.

00:18:36.529 --> 00:18:41.250
A lot of folks end up going directly to CALayer
because it's something that they're familiar with.

00:18:41.250 --> 00:18:47.049
Either they're coming from the desktop or they've seen
all the really cool CA demo, you know demonstrations.

00:18:47.049 --> 00:18:51.759
The UIView itself is actually a relatively thin
layer that gives you a bunch of added functionality

00:18:51.759 --> 00:18:57.849
so I'd recommend unless you absolutely need
to move to CALayer to just use UIViews.

00:18:57.849 --> 00:19:02.109
The CALayer instance itself that is
generated is a read-only instance.

00:19:02.109 --> 00:19:04.490
You are not allowed to change the CALayer.

00:19:04.490 --> 00:19:07.930
However, you can change the type that gets instantiated.

00:19:07.930 --> 00:19:12.289
So if you have a UIView subclass and
then you then override layer class,

00:19:12.289 --> 00:19:19.200
it will then instantiate whatever layer type
you want, for instance a CA tile player as seen.

00:19:19.200 --> 00:19:23.180
The delegate for the CALayer is the view.

00:19:23.180 --> 00:19:25.640
A lot of folks have tried to change this and it ends

00:19:25.640 --> 00:19:30.090
up having disastrous effects especially
as we read the software.

00:19:30.089 --> 00:19:33.589
Let's say that CALayer gets a new delegate call.

00:19:33.589 --> 00:19:38.569
If you change the delegate to yourself, then suddenly the
UIView isn't getting that new delegate call and you may--

00:19:38.569 --> 00:19:42.509
we, you know, we maybe depending on that
delegate call being passed to UIView.

00:19:42.509 --> 00:19:48.400
So if you do want to override down the
delegate stuff, in your UIView subclass,

00:19:48.400 --> 00:19:52.340
just override those actual delegate
calls that you care about.

00:19:52.339 --> 00:19:59.349
And because CA-- the UIView is a very thin wrapper around
CALayer, it's a one-to-one relationship, things like frames,

00:19:59.349 --> 00:20:06.819
bounds, center, background color, all kinds of stuff
like that are directly mapped between UIView and CALayer.

00:20:06.819 --> 00:20:10.359
So how do we actually draw?

00:20:10.359 --> 00:20:17.159
Well drawRect is called for a UISystem
just like layoutSubviews gets called.

00:20:17.160 --> 00:20:23.259
>> So don't ever call it yourself expect
again to super drawRect as needed.

00:20:23.259 --> 00:20:28.500
LayoutSubviews you can call for yourself,
you know, call by yourself if you want to.

00:20:28.500 --> 00:20:33.690
It's expensive, it's wrong, you should be calling layout
if needed but it's not really going to break anything.

00:20:33.690 --> 00:20:36.049
DrawRect, you really do not want to call by yourself.

00:20:36.049 --> 00:20:39.399
There's a bunch of context that needs
to be set up before drawRect gets called

00:20:39.400 --> 00:20:43.280
and by just calling it yourself,
that's not going to work properly.

00:20:43.279 --> 00:20:50.029
Use UIView setNeeds Display just like UIView setNeedsLayout.

00:20:50.029 --> 00:20:55.190
Just like that one, it's a very simple
call, it's quick, it just sets a flags,

00:20:55.190 --> 00:20:57.620
you can call it multiple times, there's no penalty.

00:20:57.619 --> 00:21:03.059
DrawRect is only going to be called
once at the end of the run loop.

00:21:03.059 --> 00:21:06.099
Unlike layoutSubviews, there is
no corollary for layoutIfNeeded.

00:21:06.099 --> 00:21:09.079
There is no drawIfNeeded.

00:21:10.410 --> 00:21:14.019
During your drawRect, only draw.

00:21:14.019 --> 00:21:20.000
That's kind of you know simple, well duh, but it's
actually very tempting to say oh OK, we'll I'm doing this,

00:21:20.000 --> 00:21:24.690
I shall actually calculate what I need to draw now and
that's expensive and maybe I need to layout something.

00:21:24.690 --> 00:21:29.480
So don't layouts in drawRect because it's
just not a great time to be doing it.

00:21:29.480 --> 00:21:33.329
You should be doing your layout in
layoutSubviews and don't do calculations,

00:21:33.329 --> 00:21:36.359
don't do expensive operations,
drawRect just draw and return.

00:21:36.359 --> 00:21:39.649
If you need to do anything, do it
in advance or do it afterwards.

00:21:39.650 --> 00:21:42.740
Don't do it while drawRect is actually happening.

00:21:42.740 --> 00:21:46.650
So you can actually do very complex drawing in a UIView.

00:21:46.650 --> 00:21:50.840
So UIView is a rectangle and you're welcome
to draw whatever you want in that rectangle.

00:21:50.839 --> 00:21:56.049
You can say, all right I want a red box up here and I'm
going to put some text in it and I want a purple box

00:21:56.049 --> 00:21:59.919
down here and I want some text in it and
I want this nice little picture frame

00:21:59.920 --> 00:22:02.870
and in the picture frame I'm going
to have five suns all popping in.

00:22:02.869 --> 00:22:05.549
You can do all of that inside of one UIView.

00:22:05.549 --> 00:22:10.829
The times when you'd want to split that up between
multiple views or if any of these has to animate,

00:22:10.829 --> 00:22:16.519
if any of these has to, you know, reflect a layout
orientation, like if you rotate to landscape,

00:22:16.519 --> 00:22:19.099
if things need to stretch or shrink and stuff like that.

00:22:19.099 --> 00:22:23.359
But if you know that your view is static, it's
perfectly fine to just draw it all yourself.

00:22:23.359 --> 00:22:27.289
It's going to be much faster than
having multiple views compositing.

00:22:27.289 --> 00:22:31.529
That being said, once you draw,
the contents are cached eternally.

00:22:31.529 --> 00:22:38.579
So if for instance we were to draw some text like
this drawn text and it animates on the screen like--

00:22:38.579 --> 00:22:42.819
nicely like that, it does not redraw during this time.

00:22:42.819 --> 00:22:44.019
The contents have been cached.

00:22:44.019 --> 00:22:48.829
Once you've drawn once, we save that and that's
actually what we blit to the screen at all times.

00:22:48.829 --> 00:22:51.029
So you're never needing to draw again.

00:22:51.029 --> 00:22:55.849
If you dirty a subrect of this, we
setNeedsDisplayInRect which we'll get to a little bit more.

00:22:55.849 --> 00:23:01.899
You can actually respect that in drawRect and
then draw within what you've drawn already.

00:23:01.900 --> 00:23:05.810
So in this case we would not have to draw drawn text again.

00:23:05.809 --> 00:23:08.789
We could just draw subtitle.

00:23:08.789 --> 00:23:14.049
When you get drawRect you're going to get a parameter
which is the rect that you're supposed to be drawing in.

00:23:14.049 --> 00:23:18.990
On an opaque view, this will be field by
whatever background color the view has.

00:23:18.990 --> 00:23:24.309
If you have a transparent view, it's
actually filled with transparent pixels.

00:23:24.309 --> 00:23:25.519
That may not be what you want.

00:23:25.519 --> 00:23:30.539
You may want to do a bunch of complex drawing
and tile things on top of each other overtime.

00:23:30.539 --> 00:23:37.889
If that's the case, call setClearsContextBeforeDrawing:NO
and we will not fill it with the transparent pixels,

00:23:37.890 --> 00:23:42.670
it will just be presented to you as the
way it was when you last drew in it.

00:23:42.670 --> 00:23:44.590
This is only true for a transparent stuff.

00:23:44.589 --> 00:23:48.869
For opaque stuff, it will automatically
be filled with the background color.

00:23:48.869 --> 00:23:52.319
So hints and tricks for drawing in UIViews.

00:23:52.319 --> 00:23:56.909
The UITableViewCell subclasses cannot use UIViewDrawRect.

00:23:56.910 --> 00:23:58.590
Don't use it directly there.

00:23:58.589 --> 00:24:00.789
They have a content view.

00:24:00.789 --> 00:24:06.440
If you want to do drawing like that, add a custom
subview to the content view and draw there.

00:24:06.440 --> 00:24:11.750
For more in formation on this and a bunch of other table
view stuff, hopefully you were here just a few hours--

00:24:11.750 --> 00:24:16.299
an hour ago for the Perfecting Your iPhone
Table View Session which was in this room.

00:24:16.299 --> 00:24:20.309
If you haven't the slide should be available
soon and the videos will be available.

00:24:20.309 --> 00:24:23.639
I highly recommend seeing this talk.

00:24:23.640 --> 00:24:27.520
Use setNeedsDisplayInRect to dirty particular regions.

00:24:27.519 --> 00:24:29.950
So we were saying setNeedsDisplay earlier.

00:24:29.950 --> 00:24:34.529
Let's say you had a huge UIView like that
complex drawing view that we had earlier.

00:24:34.529 --> 00:24:38.869
Well if you really just care about one of the suns,
you want to make that sun brighter or make it a moon

00:24:38.869 --> 00:24:41.789
or whatever, just dirty that particular region.

00:24:41.789 --> 00:24:46.809
What this will do will save a lot of time because
you won't have to redraw all of that stuff

00:24:46.809 --> 00:24:49.399
and you can just redraw that little snippet.

00:24:49.400 --> 00:24:59.360
And like a corollary to that, drawRect passes a parameter so
you should respect the rect parameter that gets passed in.

00:24:59.359 --> 00:25:03.589
That really is telling you what has
been dirtied, what you need to redraw.

00:25:03.589 --> 00:25:09.490
Most of the time if you're not doing, you know dirty
drawing of certain just rects, you can pretty much ignore it

00:25:09.490 --> 00:25:14.059
and say well the whole view has been
changed so just draw the whole view.

00:25:14.059 --> 00:25:20.849
But it's better to, if you need the performance,
to just draw the parts that draw rect gives you.

00:25:20.849 --> 00:25:25.189
And so now we're going to actually
make the lights have some content.

00:25:31.549 --> 00:25:36.309
So if we come back here we'll see that the
lights are just these nice little gray boxes,

00:25:36.309 --> 00:25:38.089
they're not really showing us much.

00:25:38.089 --> 00:25:40.990
But we need to actually make them draw.

00:25:40.990 --> 00:25:47.000
So we're working with light panel class before which
was this whole big slightly bluish gray background here.

00:25:47.000 --> 00:25:51.250
Now we'll work with the gray scales
themselves which are the light views.

00:25:54.450 --> 00:26:06.190
So the first I'm going to do is in our initWithFrame,
I'm actually going to schedule the timer.

00:26:06.190 --> 00:26:08.910
So this is a little heavy handed.

00:26:08.910 --> 00:26:10.240
It works in this example.

00:26:10.240 --> 00:26:13.970
If we would have a bunch of light views, it kind of
doesn't make sense for each of them to have their own timer

00:26:13.970 --> 00:26:17.809
but for this example, it's relatively
simple to just have a timer per light view.

00:26:17.809 --> 00:26:27.109
We're going to have it update about thirty frames, it's
going to call dirty rects which we will make smart in a bit

00:26:27.109 --> 00:26:31.019
and we're actually going to add
it to the UITrackingRunLoop mode.

00:26:31.019 --> 00:26:32.289
What's the point of this?

00:26:32.289 --> 00:26:37.170
If you saw earlier when I was dragging the print
view, everything was still updating nicely.

00:26:37.170 --> 00:26:42.300
The reason that was happening was because our timers
were actually firing during the tracking run loop mode.

00:26:42.299 --> 00:26:48.879
When a user has a finger actually down on the screen,
the run loop switches modes to UITrackingRunLoop mode.

00:26:48.880 --> 00:26:54.090
Most of the time this is great because you don't want to
have expensive timers going off and interrupting stuff

00:26:54.089 --> 00:26:57.589
when the user is dragging, you want
the dragging to be as fast as possible.

00:26:57.589 --> 00:27:01.919
In my example, it makes a lot more sense that the machine
keeps running while you're dragging the print view,

00:27:01.920 --> 00:27:07.640
so I have it actually update during that time
by adding the timer to that run loop mode.

00:27:07.640 --> 00:27:17.180
So then we're going to actually going to have a
drawRect which we're just going to put at the end here.

00:27:17.180 --> 00:27:23.610
So our drawRect is going to start out by taking the
value that has been assigned to this light view.

00:27:23.609 --> 00:27:25.279
So this app is actually multithreaded.

00:27:25.279 --> 00:27:29.519
The emulator is running on a background thread
and it's constantly putting out updates.

00:27:29.519 --> 00:27:31.639
We're only going to be updating
every thirty frames a second,

00:27:31.640 --> 00:27:34.190
so every time we draw we're going
to try to pull out that view.

00:27:34.190 --> 00:27:38.950
In order to that, we need to do a little
locking, pull out the value and unlock.

00:27:38.950 --> 00:27:41.279
We're then going to do our nice little border.

00:27:41.279 --> 00:27:49.619
So we're going to do that by setting a color into
our drawing context and then calling UIRectFrame.

00:27:49.619 --> 00:27:53.579
What this does is it draws a one
pixel border around this rect.

00:27:53.579 --> 00:28:00.819
So the rect that passed in, we're just going to assume for
now that the rect that gets passed in is our full view.

00:28:00.819 --> 00:28:07.679
If we have a title, so if it needs to say address
or op code or whatever, then we also want to draw

00:28:07.680 --> 00:28:12.870
that light gray background behind the address text.

00:28:12.869 --> 00:28:18.189
So what we do is we create our title bar frame which
is sort of that rectangle and we call UIRectFill.

00:28:18.190 --> 00:28:21.640
Just like UIRectFrame this actually
creates a rectangle and fills it.

00:28:21.640 --> 00:28:23.920
We're going to be using the same color that we set before.

00:28:23.920 --> 00:28:25.240
We don't need to set it again or anything.

00:28:25.240 --> 00:28:31.400
It's set until we set a different color which
we'll do next by calling UIColor blackColor set

00:28:31.400 --> 00:28:37.840
and then we'll call titleDrawnRectWithFont, lime
brick mode, tilt truncation, alignment center.

00:28:37.839 --> 00:28:43.289
Tilt truncation really isn't needed here because all of our
labels fit within their views but text alignment center,

00:28:43.289 --> 00:28:49.450
we're actually giving it the full title bar frame
rect and by calling it with a text alignment center,

00:28:49.450 --> 00:28:51.750
it will actually center the text in the rect.

00:28:51.750 --> 00:29:00.279
So if we were to run this like it is now,
we'll see that we now have these nice frames

00:29:00.279 --> 00:29:02.609
around so the UIRect frames are the nice frame.

00:29:02.609 --> 00:29:07.179
We have the title bar frame here
and we have the text as well.

00:29:07.180 --> 00:29:09.120
That was really pretty easy.

00:29:09.119 --> 00:29:11.750
But there is no lights yet.

00:29:11.750 --> 00:29:15.839
So the lights are you know, they're
a little hard to calculate.

00:29:15.839 --> 00:29:20.609
We have this draw number here and what this is going to
do is it's going to go through a bunch of code, that goes,

00:29:20.609 --> 00:29:25.469
oh you know, is this bit side, is this bit side,
does my light need to be on and all those stuff.

00:29:25.470 --> 00:29:27.839
Really you don't need to worry about all that.

00:29:27.839 --> 00:29:33.959
What you do need to know is that eventually it
will call draw highlighted string, string with font

00:29:33.960 --> 00:29:35.850
and color at point, just my own little code.

00:29:35.849 --> 00:29:38.189
And this is a little trick.

00:29:38.190 --> 00:29:42.860
To give the text that we're going to draw on the screen
at some depth, what we're going to do is we're going

00:29:42.859 --> 00:29:45.299
to draw a highlight color right above it.

00:29:45.299 --> 00:29:51.589
The highlight color is going to be white and
so we'll take whatever point was passed in.

00:29:51.589 --> 00:29:55.759
We'll just subtract one and we'll draw
the string at that point with that color.

00:29:55.759 --> 00:29:57.990
And then we're going to take the color that was passed in.

00:29:57.990 --> 00:30:03.230
This color is basically whether the light should
be on or off and we're going to set that color,

00:30:03.230 --> 00:30:09.019
we're going to move back down a point to what
was originally passed in and we'll draw again.

00:30:09.019 --> 00:30:11.950
So how does this look now?

00:30:13.390 --> 00:30:13.880
>> Awesome.

00:30:13.880 --> 00:30:18.760
So you can see that like white highlight
color there behind the 8, for instance.

00:30:18.759 --> 00:30:23.509
I don't know if the zooming might help,
it's all pixelated now but you can see

00:30:23.509 --> 00:30:28.500
that the white sort of gives it this depth look to it.

00:30:28.500 --> 00:30:30.269
So now we have this timer running.

00:30:30.269 --> 00:30:35.950
We're actually drawing the lights, we're drawing the
title, we're drawing the frame and if we were to run,

00:30:35.950 --> 00:30:43.529
you can't really tell because this is not an iPhone but it
actually doesn't run that well right now and why is that?

00:30:43.529 --> 00:30:48.069
So every 30th of a second, we're
actually drawing this title again.

00:30:48.069 --> 00:30:50.210
We're drawing the frame again.

00:30:50.210 --> 00:30:53.200
We're drawing a bunch of things that are never changing.

00:30:53.200 --> 00:30:55.430
So we need to make that a bit smarter.

00:30:55.430 --> 00:31:01.420
So we come to our dirty rects, you'll see that all we
are calling was setNeedsDisplay and that's, you know,

00:31:01.420 --> 00:31:08.890
that's true, we need a display but we really need
it to update just the sections that we need to.

00:31:08.890 --> 00:31:12.670
So what we can do here is we can
say do we have a title or not?

00:31:12.670 --> 00:31:14.110
All these things have titles.

00:31:14.109 --> 00:31:19.179
If we don't, we'll just call setNeedsDisplay
because all we have is a frame.

00:31:19.180 --> 00:31:21.060
But let's say we have a title.

00:31:21.059 --> 00:31:23.829
Then we get our rect, we're going
to get our rect from self bounds.

00:31:23.829 --> 00:31:26.689
Remember bounds is coordinates in our coordinate system.

00:31:26.690 --> 00:31:34.019
So that will give us an easy way to say this 0, 0 is the
top left of our view and the size is the bottom right.

00:31:34.019 --> 00:31:39.629
We're going to crop out the header label which we know is
going to be this height because that what gets set up later.

00:31:39.630 --> 00:31:47.840
We're going to crop out the borders by insetting ourselves
by two pixels, you know as shrinking the width by two pixels

00:31:47.839 --> 00:31:50.299
and insetting each side by a pixel basically.

00:31:50.299 --> 00:31:53.750
And then we're just going to call
setNeedsDisplay and rect our rect.

00:31:53.750 --> 00:31:58.549
So now we're never going to forcibly
redraw the title or the size.

00:31:58.549 --> 00:32:03.629
We could be much smarter here and dirty individual
lights as needed but that becomes much more complex

00:32:03.630 --> 00:32:05.960
and is not really worth time for this demo.

00:32:05.960 --> 00:32:12.850
Now for you to run this again, you'll
see that it's actually kind of ugly.

00:32:12.849 --> 00:32:19.509
There's a second line going on here
and we never updated our drawRect.

00:32:19.509 --> 00:32:23.099
Remember our drawRect had this assumption
earlier that the rect that gets passed

00:32:23.099 --> 00:32:25.269
in is our full bounds and we were just framing that.

00:32:25.269 --> 00:32:30.940
So even though we made our dirty rect smarter,
we actually haven't improved performance at all,

00:32:30.940 --> 00:32:36.029
in fact we've decreased it because we're doing these
calculations now every time we need to call this

00:32:36.029 --> 00:32:37.789
and we're not really doing anything better.

00:32:37.789 --> 00:32:42.089
What we need to do is we need to
change how our drawRect works.

00:32:42.089 --> 00:32:45.509
So here is where we're doing the frame.

00:32:45.509 --> 00:32:54.519
And what we'll just do is say if we've got a
rect around zero, we should outline our frame.

00:32:54.519 --> 00:32:59.779
That means that we know that whenever
we're going to be dirtying a region,

00:32:59.779 --> 00:33:03.480
we're going to be dirtying a regions
that's not starting out at 0, 0.

00:33:03.480 --> 00:33:12.279
So this is just a little cheat trick to say well OK if we
get to 0, 0, then draw the full frame, otherwise, ignore it.

00:33:12.279 --> 00:33:15.379
Likewise for the title, we can draw that conditionally.

00:33:15.380 --> 00:33:20.170
Unfortunately, we don't really know where the title
is unless we've already created a title bar frame

00:33:20.170 --> 00:33:27.080
so we can't say that until after a title bar frame
here, at which point we will call CGRect contains rect

00:33:27.079 --> 00:33:35.019
which is just an easy way to say does the rect that
were being passed in contain the title bar frame rect?

00:33:35.019 --> 00:33:41.750
And now for you to run it again, you'll see
that there is no extra or additional line here

00:33:41.750 --> 00:33:46.950
and that when the system is actually running, you
can't see this but you have to take my word for it,

00:33:46.950 --> 00:33:51.509
it is no longer drawing the titles and the frames.

00:33:51.509 --> 00:33:55.759
So very easy to actually do this, it
gains a lot of performance benefit.

00:33:55.759 --> 00:34:02.980
This makes it actually work much better
on the phone and that's that demo.

00:34:02.980 --> 00:34:05.039
But not everything is implemented here.

00:34:05.039 --> 00:34:07.639
What happens if we hit the "Check Reset" button.

00:34:07.640 --> 00:34:10.940
Remember that really awesome page
curl animation we did earlier?

00:34:10.940 --> 00:34:12.099
That's not there yet.

00:34:12.099 --> 00:34:19.529
So let's figure out how to do that.

00:34:19.530 --> 00:34:23.960
So first we need to talk how do you
actually interact with the system.

00:34:23.960 --> 00:34:29.530
So if you want to use controls, use the built-in
controls that we provide to you if you can.

00:34:29.530 --> 00:34:30.550
There are lots of them.

00:34:30.550 --> 00:34:36.210
The "Groups" button, the "+" button, the Slide
Wheels, the SegmentedControl, the "Toolbar" buttons,

00:34:36.210 --> 00:34:41.400
there are tons of these and we
provide them to you so use them.

00:34:41.400 --> 00:34:43.820
Don't subclass standard controls.

00:34:43.820 --> 00:34:51.230
So don't go, UISegmentedControl, it's awesome and it
would be so much more awesome if it just did this.

00:34:51.230 --> 00:34:54.710
Don't do that because it's actually
very hard to get that right.

00:34:54.710 --> 00:34:59.980
Chances are that however you subclass it,
isn't how we ever expected anyone to do

00:34:59.980 --> 00:35:02.679
that and then will break in a future release.

00:35:02.679 --> 00:35:06.519
Don't do it because the user sees a
SegmentedControl, they expect it to behave

00:35:06.519 --> 00:35:09.079
like a SegmentedControl across the system.

00:35:09.079 --> 00:35:14.019
I know it's really tempting because it's sort of the way
that you go, oh I really like the way it behaves here.

00:35:14.019 --> 00:35:18.500
Try to redesign you app to be more cohesive not
just with our apps and not just because we say it

00:35:18.500 --> 00:35:23.030
but because all your other fellow developers will
also hopefully not be subclassing it themselves

00:35:23.030 --> 00:35:28.040
and so in that way you'll have cohesive
behavior across all of the apps.

00:35:28.039 --> 00:35:31.960
That doesn't mean that you can't have your own custom look.

00:35:31.960 --> 00:35:36.800
As you saw earlier, I was using a
SegmentedControl for the actual run state thing here.

00:35:36.800 --> 00:35:41.780
Now by default, the SegmentedControl has a
nice little blue look which looks awesome

00:35:41.780 --> 00:35:45.070
but really does not fit the panel on this machine.

00:35:45.070 --> 00:35:48.950
So what's provided here is a tint color.

00:35:48.949 --> 00:35:55.569
It's provided on Toolbar, on Navigation Bar, on Search Bar,
and on UISegmentedControl although on UISegmentedControl,

00:35:55.570 --> 00:35:59.800
it only works when the SegmentedControl is in toolbar style.

00:35:59.800 --> 00:36:05.030
So if you set the tint color, you can also clear it so
that if you wanted to like use it to switch between states

00:36:05.030 --> 00:36:09.190
like red alert, red alert, you can set
it and clear it by just passing nil

00:36:09.190 --> 00:36:12.599
and in this case I have this nice blue SegmentedControl.

00:36:12.599 --> 00:36:20.279
If I pass to the light gray color, I got something like this
which matches much better with the look and feel of my app.

00:36:20.280 --> 00:36:27.170
Use UIToolbars built in buttons, UIBar
button system item provides a wealth

00:36:27.170 --> 00:36:30.570
of buttons that are already defined for you.

00:36:30.570 --> 00:36:34.200
Use them based on the text, based
on their names not on the graphics.

00:36:34.199 --> 00:36:40.019
It could easily be the case that in a future system
update, we decide this graphic would look much cooler

00:36:40.019 --> 00:36:46.989
for this button and much better fits the organized fill
here and if by organize you really meant this is a folder,

00:36:46.989 --> 00:36:50.949
that will break for you in the future update.

00:36:50.949 --> 00:36:57.539
Using built-in graphics is also awesome because it lets
you save time, it let's you be consistent with other apps

00:36:57.539 --> 00:37:00.739
and because we all know that time equals
money, it let's you save money too.

00:37:00.739 --> 00:37:06.019
So we've already created a bunch of nice
graphics for you, feel free to use them.

00:37:06.019 --> 00:37:08.099
A bit about controls and how they actually interact.

00:37:08.099 --> 00:37:13.269
This isn't really going to be an event
processing session but just in brief,

00:37:13.269 --> 00:37:19.300
control has an addTarget action
for controlEvents selector on it.

00:37:19.300 --> 00:37:26.850
So if you had a "Dismiss" button like we do here and a
target that you wanted the action to actually be done on,

00:37:26.849 --> 00:37:33.409
then given the controlEvents, now controlEvents is a must
but let's just say we only care about UITouchUpInside.

00:37:33.409 --> 00:37:39.369
If you called addTarget action for
controlEvents and let's say the action is dismiss,

00:37:39.369 --> 00:37:43.799
then whenever a UITouchUpInside
actually happens on this control,

00:37:43.800 --> 00:37:46.780
you will automatically get the dismiss call to your target.

00:37:46.780 --> 00:37:53.360
So controls are very easy to use if you want to
write your custom controls for stuff like this.

00:37:53.360 --> 00:37:58.460
A lot of people then decide, OK, controls are really
easy to use, I know how to do this, that's really--

00:37:58.460 --> 00:38:03.000
that's a simple slide, how do I make
my own really cool looking button?

00:38:03.000 --> 00:38:07.480
So let's say we wanted to have this
nice little glowy speech bubble button.

00:38:07.480 --> 00:38:11.190
Well you know that you can have like a UIImageView.

00:38:11.190 --> 00:38:16.409
That's a great way to display an image so maybe you'll
subclass that with my button and then you'd say,

00:38:16.409 --> 00:38:22.239
OK well now I'll base this all on touches, 'cause a
UIImageView is not in control and so you go all right,

00:38:22.239 --> 00:38:28.609
well how about a TouchDown or a TouchUp, then you'll
realize, well what happens when the user touches down on it

00:38:28.610 --> 00:38:30.610
but then drags out because they really want to cancel that.

00:38:30.610 --> 00:38:31.730
Well you got to handle that.

00:38:31.730 --> 00:38:34.170
What happens when they drag back in?

00:38:34.170 --> 00:38:37.769
What happens when a second finger
goes down, do I start ignoring it?

00:38:37.769 --> 00:38:39.259
What happens when that second finger lifts?

00:38:39.260 --> 00:38:41.540
What happens when just the finger lifts?

00:38:41.539 --> 00:38:46.509
What if the finger drags off screen but that's
not really far enough for my hysteresis to cancel.

00:38:46.510 --> 00:38:49.820
You really don't want to solve all these things.

00:38:49.820 --> 00:38:51.910
We've already had to solve it for you.

00:38:51.909 --> 00:38:54.099
So just use UIButton.

00:38:54.099 --> 00:38:57.710
UIButton has a very easy call, setImage:forState.

00:38:57.710 --> 00:39:02.670
This is was how I made those "Start," "Check
Reset," and "Stop" buttons that you saw earlier.

00:39:02.670 --> 00:39:07.090
You just pass in an image for the
state and it's very easy to use.

00:39:07.090 --> 00:39:13.320
All right, so views, they're pretty boring, you know they
are static things and control is OK, buttons on the screen.

00:39:13.320 --> 00:39:18.130
We-- what you really want to care about
is animation, so how do animations work?

00:39:18.130 --> 00:39:23.490
Animations are done by a category on
UIView called the UIViewAnimation category.

00:39:23.489 --> 00:39:25.769
They are done without animators, what does this mean?

00:39:25.769 --> 00:39:32.139
If you're familiar with other, you know, styles of coding,
you may be getting callback every single frame or as often

00:39:32.139 --> 00:39:35.139
as we can call you and say all
right, where should this view be now,

00:39:35.139 --> 00:39:37.039
where should this view be now,
where should this view be now?

00:39:37.039 --> 00:39:40.409
That allows you to do very complex
animations but it also means that you have

00:39:40.409 --> 00:39:44.710
to do the calculations yourself every time and this is slow.

00:39:44.710 --> 00:39:48.409
So because of this we actually don't use animators.

00:39:48.409 --> 00:39:51.889
The animations are actually handled by Core Animation.

00:39:51.889 --> 00:40:00.559
And because of that, Core Animation uses the hardware
acceleration so the animations are very fast.

00:40:00.559 --> 00:40:02.809
Now, animations are pretty easy to do.

00:40:02.809 --> 00:40:06.599
You do a Begin, Commit and everything, right?

00:40:06.599 --> 00:40:11.599
There's something that often trips out a lot of people
and I want to give a couple of slides here about this.

00:40:11.599 --> 00:40:13.579
The state is stacked.

00:40:13.579 --> 00:40:20.769
>> So let's say you have a view and you call Set Frame on
it, so you get your initial frame here, just like that.

00:40:20.769 --> 00:40:24.619
You then say begin animation, I'm going to be
starting some animations now because you know

00:40:24.619 --> 00:40:26.190
that you need to move to a different state.

00:40:26.190 --> 00:40:31.960
And then you call Set Frame call so now you're
at a different place but then something happens,

00:40:31.960 --> 00:40:37.119
either the model changes or because you call that Set
Frame something else jumps and you need to do it again

00:40:37.119 --> 00:40:42.190
and suddenly you have another Set Frame call and that
leads to another Set Frame call and another Set Frame call.

00:40:42.190 --> 00:40:46.179
This actually happens far more often than you might think.

00:40:46.179 --> 00:40:47.929
And then, all right, cool you're done.

00:40:47.929 --> 00:40:52.440
That actually is the final frame that you
really, really wanted, not the initial one.

00:40:52.440 --> 00:40:55.539
And so you call commitAnimations.

00:40:55.539 --> 00:40:57.300
What happens at this point?

00:40:57.300 --> 00:41:02.620
The way that the animation system works
is it just does a simple spanned animation

00:41:02.619 --> 00:41:05.779
between the previous state and the current state.

00:41:05.780 --> 00:41:11.500
So although you may want it to go from the first frame that
you set to the last one, what actually happens as it goes

00:41:11.500 --> 00:41:14.210
from the next to the last to the last one.

00:41:14.210 --> 00:41:18.789
And what actually does the user see, they
see at the very beginning of your animation,

00:41:18.789 --> 00:41:24.659
your view jumps to wherever it was right before the end
and then it animates very nicely from there to the end.

00:41:24.659 --> 00:41:27.269
And that's probably not what you want.

00:41:27.269 --> 00:41:30.710
So if you do need to have this case where
you're setting frame multiple times,

00:41:30.710 --> 00:41:33.420
there is an easy way to work around that.

00:41:33.420 --> 00:41:37.860
After begin animation, call
setAnimationBeginsFromCurrentState.

00:41:37.860 --> 00:41:43.700
What this basically does is that it locks the stack
so that the previous state or the state that it's

00:41:43.699 --> 00:41:47.659
in right now is what will be considered previous states.

00:41:47.659 --> 00:41:52.059
So when you call commit animation, it will
actually animate nicely from your beginning

00:41:52.059 --> 00:41:55.000
to your end which is probably what you expected.

00:41:55.000 --> 00:41:58.489
Note that this does not mean that it
animates between each of these positions.

00:41:58.489 --> 00:42:03.219
It's just going to animate from the beginning to
the end now, it's not going to go between stages.

00:42:03.219 --> 00:42:05.829
If you need to do that, you're going
to need to either stack your animations

00:42:05.829 --> 00:42:09.119
with delegate callbacks or use Core Animation.

00:42:09.119 --> 00:42:13.789
So that's sort of like basic animation stuff.

00:42:13.789 --> 00:42:16.630
We also provide some very nice looking animations for you.

00:42:16.630 --> 00:42:22.210
We provide the page curl animation, and we provide the
flip animation so this was how the print view that I showed

00:42:22.210 --> 00:42:26.360
in the demo earlier actually works
and it's very easy to use.

00:42:26.360 --> 00:42:29.620
You say UIView beginAnimations and I'm
going to call this Curl Away My View.

00:42:29.619 --> 00:42:33.429
So in this example let's say that I'm just
yanking this view completely off the screen

00:42:33.429 --> 00:42:36.129
and I want to reveal whatever is behind it.

00:42:36.130 --> 00:42:38.990
We're not going to pass the context
because we don't really need it.

00:42:38.989 --> 00:42:43.879
We're then going to call UIView
setAnimationTran UIView animationTransitionCurlUp

00:42:43.880 --> 00:42:47.829
which is the definition for the page curl away animation.

00:42:47.829 --> 00:42:53.610
We're going to specify which view this is supposed
to animate on and we're going to say yes to cache.

00:42:53.610 --> 00:42:56.000
We're going to set this duration to be 1 second.

00:42:56.000 --> 00:43:00.730
We're going to set the delegate to ourselves
and we're then going to commit the animations.

00:43:00.730 --> 00:43:04.789
Now outside of these animations box, so
animation transitions are a little different.

00:43:04.789 --> 00:43:08.840
You don't really want to set the end
state inside of the animation box.

00:43:08.840 --> 00:43:11.660
For other animation you're going to want
to say beginAnimations and then move

00:43:11.659 --> 00:43:13.440
to the final state and then commitAnimations.

00:43:13.440 --> 00:43:18.519
For animationTransitions, you really want
to say just do this animation transition,

00:43:18.519 --> 00:43:24.539
don't do anything else while you're doing that, commit
animation transition and then before the run loop returns

00:43:24.539 --> 00:43:27.809
so before the animation actually fires,
that's when you're actually going

00:43:27.809 --> 00:43:30.119
to want to do whatever changes you need to do.

00:43:30.119 --> 00:43:34.599
So because we're yanking this view away, we're
actually going to set this alpha to zero.

00:43:34.599 --> 00:43:39.029
Now why do we not just yank it to view, you know,
completely out of the hierarchy at his point?

00:43:39.030 --> 00:43:44.340
If we do that then basically the
animation itself won't actually run.

00:43:44.340 --> 00:43:49.140
The animation will just be pulled
out and the view will just disappear.

00:43:49.139 --> 00:43:53.779
So what we need to do is in the delegate, we're
going to say myView removeFromSuperview so that's

00:43:53.780 --> 00:44:00.390
when we actually yank it out and we'll get
something that looks very nice like this.

00:44:00.389 --> 00:44:06.730
So we provide this base, you know this built in
pretty fancy animations, the page curls and the flips,

00:44:06.730 --> 00:44:10.690
but what if you wanted to do something a little
bit crazier, like what if you wanted view

00:44:10.690 --> 00:44:13.099
to actually move along a nice little path.

00:44:13.099 --> 00:44:18.769
So you can do that using Core Animation with your UIViews.

00:44:18.769 --> 00:44:25.039
So let's say we were given a CG path and we have a
view that we know we're going to want to animate.

00:44:25.039 --> 00:44:30.029
The first thing we need to do is we need
to generate a CA key frame animation.

00:44:30.030 --> 00:44:35.300
We're going to say this is a position animation,
we're going to set its path to be the path,

00:44:35.300 --> 00:44:40.070
we're going to set its delegate to be ourselves so
that we know when it's done, some fill mode to frozen,

00:44:40.070 --> 00:44:45.360
removed on completion no because we want that state
to remain in the system, and then finally we're going

00:44:45.360 --> 00:44:49.730
to call view layer addAnimation:keyFrame forKey position.

00:44:49.730 --> 00:44:53.670
Now remember earlier I was saying CALayer, don't
go to CALayers, use UIViews for everything.

00:44:53.670 --> 00:44:58.820
This one case where you actually do need to
know that UIViews are backed by a CALayer

00:44:58.820 --> 00:45:04.590
because you're actually applying this animation
to the CALayer itself not to the UIView.

00:45:04.590 --> 00:45:07.900
So this will provide a nice little pathway to animation.

00:45:07.900 --> 00:45:14.880
Another thing about UIViewAnimations is because of
the way they're done without animator callbacks,

00:45:14.880 --> 00:45:18.410
what's going to happen is that you set up a
delegate and you know your final callback, what--

00:45:18.409 --> 00:45:21.940
you can change it or you can use
the basic animationDidStop callback.

00:45:21.940 --> 00:45:27.039
So you set up your animation, you commit your animation
and then the hardware goes off and renders the animation

00:45:27.039 --> 00:45:29.900
and then eventually it returns back to you.

00:45:29.900 --> 00:45:34.539
So during this time, you're not going to be getting
animator callbacks and so you may think, awesome,

00:45:34.539 --> 00:45:41.369
this is a great time to do a very heavy update
on my model or calculate pi to 5000 digitssPtylY

00:45:41.369 --> 00:45:46.750
or in my case run the emulator a bunch because an animation
is running and now I have time to run the emulator.

00:45:46.750 --> 00:45:50.550
The case is this really doesn't work out well for you.

00:45:50.550 --> 00:45:56.010
Although, yes we're using the hardware to do all
the rendering, it's a shared system bus, the--

00:45:56.010 --> 00:45:59.140
you know, we need to shuttle things around.

00:45:59.139 --> 00:46:04.279
It still will slow down the animation if you're
doing any work during the animation itself.

00:46:04.280 --> 00:46:10.269
So the simplest thing is to say, don't do stuff here, I
know this is really hard not to do, I am myself very guilty

00:46:10.269 --> 00:46:16.409
of constantly doing stuff here but just try
not to do any stuff during an animation.

00:46:16.409 --> 00:46:24.460
So, in lieu of you know-- or sort of like on the
same line as not doing stuff during animation,

00:46:24.460 --> 00:46:29.570
well the user might want to do stuff during the animation
so going back to our first example of the Address Book

00:46:29.570 --> 00:46:34.380
where we have this "Groups" button
and you click it and it slides over,

00:46:34.380 --> 00:46:38.420
what happens if the user clicks the button a second time?

00:46:38.420 --> 00:46:41.159
Are we supposed to move two groups back?

00:46:41.159 --> 00:46:43.029
Does your app handle that?

00:46:43.030 --> 00:46:46.310
Is it something that you expect at all, probably not.

00:46:46.309 --> 00:46:51.289
And so during an animation, you want to
stop handling all user interaction as well.

00:46:51.289 --> 00:46:56.349
So you can turn it off by calling
UIApplication beginIgnoringInteractionEvents.

00:46:56.349 --> 00:47:00.960
Turn it back on in your delegate because there's
nothing worse than seeing a really beautiful animation

00:47:00.960 --> 00:47:04.539
and then being stuck with an app
that doesn't respond to your input.

00:47:04.539 --> 00:47:07.949
So now from here we'll have another demo.

00:47:07.949 --> 00:47:10.909
This is how to actually do the printer curl.

00:47:17.070 --> 00:47:22.039
So as I showed you earlier, this "Check
Reset" button really isn't doing anything.

00:47:22.039 --> 00:47:25.750
Awesome. So how do we make it actually do something?

00:47:25.750 --> 00:47:37.679
The first thing we need to do is we
need to wire up the "Reset" button.

00:47:37.679 --> 00:47:44.069
[Murmuring] So, this app is fairly simply written,
everything is actually done in the app delegate,

00:47:44.070 --> 00:47:45.480
a real app would have much more structure.

00:47:45.480 --> 00:47:50.030
But let's just say in the app delegate that we
actually want to do something on the "Reset" button.

00:47:50.030 --> 00:47:54.500
So the "Reset" button will automatically
call reset pressed on the app delegate,

00:47:54.500 --> 00:47:59.750
and what we're going to do is we're going
to call begin animations tear sheet,

00:47:59.750 --> 00:48:05.940
we're going to do the setAnimationTransition, UIView
TransitionCurlUp, for view the printer view, superview.

00:48:05.940 --> 00:48:08.519
Why are we calling it on the superview?

00:48:08.519 --> 00:48:13.730
The printer view itself is actually that full
width of paper, that 132 character width paper.

00:48:13.730 --> 00:48:16.760
You don't really want to curl that out.

00:48:16.760 --> 00:48:21.500
What you're actually trying to curl out is what the user
is currently seeing 'cause it makes no sense for the user

00:48:21.500 --> 00:48:26.179
to see a curl come, you know, already half
completed as it-- by the time it comes on screen.

00:48:26.179 --> 00:48:28.730
We're going to set its duration to be 0.8.

00:48:28.730 --> 00:48:32.159
By default, the duration is going to be much
faster than this and the page curl will look

00:48:32.159 --> 00:48:34.799
like you're really pissed off the printer
so you want to slow it down a bit.

00:48:34.800 --> 00:48:38.880
You're going to commit the animation and then
you're actually going to clear the contents.

00:48:38.880 --> 00:48:41.400
This is what I said earlier about transition animations.

00:48:41.400 --> 00:48:43.930
They are a little bit different than your normal ones.

00:48:43.929 --> 00:48:46.659
And then we're actually going to reset
the scroll point to the far right.

00:48:46.659 --> 00:48:51.109
This is just a nice [inaudible], a nice, you
know, side to move anything over to the other side

00:48:51.110 --> 00:48:53.550
so that you're back at the first column of printing.

00:48:53.550 --> 00:48:58.150
So clear content currently doesn't do anything.

00:48:58.150 --> 00:49:00.210
So we need to actually wire that up as well.

00:49:00.210 --> 00:49:08.079
The first thing we need to do is we need
to add the actual call in our header file.

00:49:08.079 --> 00:49:11.139
Now the printer, the print view is really pretty simple.

00:49:11.139 --> 00:49:16.829
Basically it just stores the last eight lines because that's
how much actually fits on screen and all we need to do

00:49:16.829 --> 00:49:21.039
when we need to clear it is we need
to clear off those eight lines.

00:49:21.039 --> 00:49:28.300
So we do that by calling clear content and then
going through those eight lines and releasing them

00:49:28.300 --> 00:49:31.910
and setting them to nil, and then calling setNeedsDisplay.

00:49:31.909 --> 00:49:34.339
The printer will have to fully update.

00:49:34.340 --> 00:49:42.390
It cannot just update small dirty rect because for all
you know, the lines cover the full width of the printer.

00:49:42.389 --> 00:49:46.409
But we're just going to call setNeedsDisplay, we're
not actually going to be calling drawRect here

00:49:46.409 --> 00:49:50.899
at all even though you know, I said earlier well you
want to do everything that the animation needs to look

00:49:50.900 --> 00:49:53.490
like at the end now, you really don't need to.

00:49:53.489 --> 00:49:59.319
You need to call setNeedsDisplay and then drawRect
will be called for you at the end of the run loop.

00:49:59.320 --> 00:50:09.710
So for you to run this now and we get some content
on the screen, and now you'll see it nicely tears off

00:50:09.710 --> 00:50:14.240
and continues printing and you can't it's clearing
'cause I'm running it but I were to stop it,

00:50:14.239 --> 00:50:15.599
you'll see it clears to a nice sheet of paper.

00:50:15.599 --> 00:50:19.440
>> And because the emulator is actually
still running during this animation,

00:50:19.440 --> 00:50:26.059
by the time that animation finishes running it's
showing you the piece of paper that was underneath it.

00:50:27.260 --> 00:50:31.840
So as you can see that's really easy to do.

00:50:31.840 --> 00:50:37.660
So that was sort of a whirlwind tour of all these things.

00:50:37.659 --> 00:50:43.009
For more information, contact Matt Drance
our Application Frameworks Evangelist.

00:50:43.010 --> 00:50:46.540
Documentation, go to the iPhone
Application Programming Guide.

00:50:46.539 --> 00:50:48.880
It covers this and many, many other topics.
WEBVTT

00:00:13.009 --> 00:00:15.740
>> Welcome to the effective iPhone app architecture session.

00:00:15.740 --> 00:00:19.679
My name is Matt Drance, I'm the
Application Frameworks Evangelist at Apple,

00:00:19.679 --> 00:00:22.300
and I'm going to be joined later by Alex Aybes.

00:00:22.300 --> 00:00:25.980
He's one of our illustrious iPhone software engineers.

00:00:25.980 --> 00:00:29.980
And you guys have learned a lot over
the last couple of days here at WWDC.

00:00:29.980 --> 00:00:35.380
You've learned a lot about specific technologies and
how to use them, the right ways and the wrong ways are

00:00:35.380 --> 00:00:38.340
for that particular API, how to be most efficient.

00:00:38.340 --> 00:00:45.490
Before everybody starts throwing them back, I want to
take a little while to talk about all the best practices

00:00:45.490 --> 00:00:51.240
all the thought processes, all the principles that
apply to your daily activity as an iPhone developer.

00:00:51.240 --> 00:00:58.270
Regardless of which of these APIs, which
of these frameworks you happen to be using.

00:00:58.270 --> 00:01:01.930
Now you're all here because you want the same thing.

00:01:01.929 --> 00:01:07.890
Wherever you came from, whether you're here to fix a
couple of bugs or adopt some new features in iPhone OS 3.0,

00:01:07.890 --> 00:01:15.420
or add new features to your own application - you're all
at WWDC because you want to make the best apps possible.

00:01:15.420 --> 00:01:20.730
And there are a lot of things that go into that, and
we're going to be talking about that over the next hour,

00:01:20.730 --> 00:01:27.120
but you want apps that are responsive and stable, and
maintainable; so that when the time comes to fix a bug

00:01:27.120 --> 00:01:31.880
or add a feature, take advantage of new
technologies, you can do that quickly and easily.

00:01:31.879 --> 00:01:34.179
You want an app that can go months without updates.

00:01:34.180 --> 00:01:38.670
I think we all agree this icon looks a
lot better without a badge next to it.

00:01:38.670 --> 00:01:42.620
And so we're going to talk about the things that you can do

00:01:42.620 --> 00:01:46.660
to keep those things going throughout
the lifespan of your application.

00:01:46.659 --> 00:01:54.200
Now we've spent the better part of a decade
building these technologies, these frameworks,

00:01:54.200 --> 00:01:56.480
that you guys are now using to build your apps.

00:01:56.480 --> 00:02:05.560
Starting in 2001 with the original release of Mac
OS X, all the way to today with iPhone OS 3.0.

00:02:05.560 --> 00:02:08.170
And we've learned a lot ourselves over that time.

00:02:08.169 --> 00:02:10.189
We've learned what works and what doesn't.

00:02:10.189 --> 00:02:15.060
We've learned what the patterns are and
the principles, and the practices that go

00:02:15.060 --> 00:02:18.500
into good app and framework architecture.

00:02:18.500 --> 00:02:21.710
And so we're going to talk about those
things and how you can apply those best.

00:02:21.710 --> 00:02:28.180
Whether you're writing a library yourself, or just an
application that needs to be maintained down the road.

00:02:28.180 --> 00:02:32.860
Now we all know that real life
doesn't always follow the manual,

00:02:32.860 --> 00:02:37.510
and a lot of times things just
kind of take a life of their own.

00:02:37.509 --> 00:02:40.560
So you're working overnight, you're working on the weekend,

00:02:40.560 --> 00:02:43.979
you throw something together, you
bring it in, your boss loves it.

00:02:43.979 --> 00:02:47.639
He says, well I'll add a couple of things;
we're going to do a demo this afternoon.

00:02:47.639 --> 00:02:53.539
And then the demo gets approved, and the designer
comes in and says - OK let's add some features,

00:02:53.539 --> 00:02:56.189
we're going to put a screen over here or over there.

00:02:56.189 --> 00:03:01.009
And before you know it, you've shipped the product.

00:03:01.009 --> 00:03:06.649
[ Applause ]

00:03:06.650 --> 00:03:10.180
And you're proud of it, it's a good product,
it's selling well, your users love it,

00:03:10.180 --> 00:03:14.750
it does everything you wanted it to, but
there's that one piece of code in there.

00:03:14.750 --> 00:03:21.409
Maybe more than one, that you wish you had time to
take care of, and you think it's going to come back

00:03:21.409 --> 00:03:24.659
to say hello in the next couple of weeks or months.

00:03:24.659 --> 00:03:30.329
So we're going to talk about those little pieces and how you
find those, and how to address them, and how to avoid them,

00:03:30.330 --> 00:03:34.480
so that you can concentrate on what matters
most; which is working on your next great idea.

00:03:34.479 --> 00:03:41.829
And your users can concentrate on actually using the
applications, and not just re-downloading them all the time.

00:03:41.830 --> 00:03:44.950
So there are 4 main areas we're going to cover today.

00:03:44.949 --> 00:03:52.239
The first is data persistence, how you process information
in your app, and the decisions you make from the beginning,

00:03:52.240 --> 00:03:55.219
and how those decisions affect
the rest of your app development.

00:03:55.219 --> 00:03:59.409
We're going to talk about the design
decisions, both at a high level in terms

00:03:59.409 --> 00:04:02.020
of user interface, as well as your class design.

00:04:02.020 --> 00:04:07.159
And we'll talk about memory management,
can't talk enough about memory management.

00:04:07.159 --> 00:04:12.049
You've -probably heard a lot about it this
week, and you're going to continue to.

00:04:12.050 --> 00:04:16.189
And finally we'll talk about all the other things in
the application lifecycle, things around the system

00:04:16.189 --> 00:04:20.699
that affect your app, and how you can
respond to those and work well with them.

00:04:20.699 --> 00:04:23.009
Let's get started with data persistence.

00:04:23.009 --> 00:04:28.870
[ Silence ]

00:04:28.870 --> 00:04:31.899
Every iPhone application processes information of some kind.

00:04:31.899 --> 00:04:37.000
And there are different types of information
that you will be handing on a daily basis.

00:04:37.000 --> 00:04:41.170
There's user data - things like documents, downloads, media.

00:04:41.170 --> 00:04:49.610
Preferences - like settings, sensitive data, passwords,
private keys - and of course cache or temporary data.

00:04:49.610 --> 00:04:59.639
When it comes to storing this stuff in memory at run
time, we start to think about what we do on that weekend

00:04:59.639 --> 00:05:01.689
when we start to throw together that proof of concept.

00:05:01.689 --> 00:05:06.149
Alright I've got a bunch of stuff to put on screen,
just throw it in the dictionary, no problem.

00:05:06.149 --> 00:05:12.159
There's my work in the short term, but all of the sudden
you've got all these string literals all over the place,

00:05:12.160 --> 00:05:16.760
you're using them in 1 place, you're
using them in another, you decide well...

00:05:16.759 --> 00:05:17.949
what was the name of that key?

00:05:17.949 --> 00:05:18.639
I don't remember.

00:05:18.639 --> 00:05:22.339
You decide to change something down below, you've
got to find all the places you did it before.

00:05:22.339 --> 00:05:24.039
This quickly spirals out of control.

00:05:24.040 --> 00:05:30.050
You can define constants if you want, but this really
isn't scalable, and there's no contract in place

00:05:30.050 --> 00:05:34.770
to really explain what the data is
that's flowing around the application.

00:05:34.769 --> 00:05:39.689
So really take the time from the beginning to
define proper data objects with properties,

00:05:39.689 --> 00:05:42.649
read write, atomic, nonatomic, retained, whatever.

00:05:42.649 --> 00:05:46.179
But take the moment to define that
contract so every part of your application

00:05:46.180 --> 00:05:49.490
that actually uses this data understands
and knows what happens.

00:05:49.490 --> 00:05:53.730
This is not only more readable, but property
access is faster than dictionary look ups.

00:05:53.730 --> 00:05:59.500
Both are constant time, but properties are faster
and they're much easier to re-factor of course.

00:05:59.500 --> 00:06:04.870
This is much more clean, so this
is madness and this is Sparta.

00:06:04.870 --> 00:06:07.040
Thank you.

00:06:08.290 --> 00:06:14.040
So we've got data in memory, we've thought about the
sort of things that our apps are going to do and use,

00:06:14.040 --> 00:06:16.550
and when it comes to saving that
data you've got a bunch of options.

00:06:16.550 --> 00:06:22.270
You can put things in a binary property list, you can
use XML, you can archive or encode those objects straight

00:06:22.269 --> 00:06:27.159
to disk with Objective-C, you could use SQLite
for more complicated relational databases.

00:06:27.160 --> 00:06:32.610
And now in 3.0 we have Core Data, which pretty much
gives you all the power of SQLite with much less code

00:06:32.610 --> 00:06:34.580
to write, and much less stuff to worry about.

00:06:34.579 --> 00:06:38.319
So you've got a lot of options,
and how do you choose which one?

00:06:38.319 --> 00:06:44.339
So first thing you need to ask yourself
is, is this a user controlled dataset?

00:06:44.339 --> 00:06:50.579
And by user controlled I mean, is it a list
of 5 that could easily be grown to 5,000?

00:06:50.579 --> 00:06:51.609
Can the user do that?

00:06:51.610 --> 00:06:54.290
And have you prepared for that?

00:06:54.290 --> 00:06:59.810
So if the answer to that question is yes, if it can
grow indefinitely, you really want to take a hard look

00:06:59.810 --> 00:07:01.750
at Core Data; especially for a new project.

00:07:01.750 --> 00:07:09.480
If the answer to that question is no, if it's a relatively
fixed dataset like an XML feed, a top 20 list or something

00:07:09.480 --> 00:07:12.080
like that, you just need to store it locally.

00:07:12.079 --> 00:07:18.009
You can start looking at XML if it
originated as XML, or binary property lists

00:07:18.009 --> 00:07:21.000
which is much faster, much more
efficient, and lighter weight.

00:07:21.000 --> 00:07:25.670
But if the answer to that question
is no, if it's not a small dataset,

00:07:25.670 --> 00:07:31.379
if despite the absence of user control
it can still grow indefinitely,

00:07:31.379 --> 00:07:33.750
you really need to take another look at Core Data.

00:07:33.750 --> 00:07:39.120
Core Data does all of the database work for
you, it manages the object graph efficiently,

00:07:39.120 --> 00:07:44.280
as Alex will explain to you later, saves you a ton of work
and gives you all the performance and memory management

00:07:44.279 --> 00:07:48.369
that you're going to want out of a mobile app.

00:07:48.370 --> 00:07:50.459
So that's the user data.

00:07:50.459 --> 00:07:51.799
Preferences are another story.

00:07:51.800 --> 00:07:56.600
Preferences are managed by a single class called
NSUserDefaults, and this is basically just a dictionary

00:07:56.600 --> 00:07:59.420
with a saved method, or a synchronized method.

00:07:59.420 --> 00:08:02.910
Preferences are for lightweight settings.

00:08:02.910 --> 00:08:06.610
And by lightweight we mean things like the cities
that you enter into the weather application,

00:08:06.610 --> 00:08:08.580
or the stock symbols that you enter into stocks.

00:08:08.579 --> 00:08:12.909
It's also for things like navigation
state, so those of you who have used built

00:08:12.910 --> 00:08:17.010
in apps, you'll notice if I change cities...

00:08:17.009 --> 00:08:23.509
if you change cities in the weather app and then quit
out, sometime later you re-launch the application,

00:08:23.509 --> 00:08:26.240
weather remembers what city you had selected.

00:08:26.240 --> 00:08:32.490
And that's just a simple integer index that's written out to
the user defaults, but navigation state is a perfect example

00:08:32.490 --> 00:08:38.039
of something that belongs in the user defaults; because
you don't want that necessarily preserved across,

00:08:38.039 --> 00:08:44.599
well you do want that preserved across restores.

00:08:44.600 --> 00:08:46.210
Now this is a really convenient API.

00:08:46.210 --> 00:08:49.780
Like I said, it's just a dictionary with
a save method, and it might be tempting

00:08:49.779 --> 00:08:52.899
to just throw a bunch of stuff into the user defaults.

00:08:52.899 --> 00:08:58.399
So it's important to remember that the user defaults are
not meant for heavyweight data, and we've seen this a lot

00:08:58.399 --> 00:09:05.289
so we need to just say, you don't want to put
things like images, or movie files, or sound files,

00:09:05.289 --> 00:09:09.480
or massive archived objects, that's user data.

00:09:09.480 --> 00:09:12.399
User defaults are just for preferences,
lightweight settings,

00:09:12.399 --> 00:09:15.639
navigation state, things like user names for example.

00:09:15.639 --> 00:09:20.460
But you don't want to put things
like passwords in the user defaults.

00:09:20.460 --> 00:09:22.820
That's what the Keychain is for.

00:09:22.820 --> 00:09:29.740
The Keychain is an API that lets you store sensitive
data - things like passwords, certificates, private keys.

00:09:29.740 --> 00:09:35.980
And your app can carve out a special section of the
Keychain where you can store this data and leave it secure.

00:09:35.980 --> 00:09:43.440
And in 3.0 you can actually carve out a shared space of the
Keychain that all of your applications can have access to.

00:09:43.440 --> 00:09:50.440
So if you have multiple apps that sign into the same social
networking service, for example, the first app asks the user

00:09:50.440 --> 00:09:53.900
to login, they do so, saves the password to the...

00:09:53.899 --> 00:09:55.959
user name and password to the Keychain.

00:09:55.960 --> 00:10:00.000
And the second app when it launches can just pull
those credentials right out of the shared space,

00:10:00.000 --> 00:10:02.139
and the user doesn't have to login to get them.

00:10:02.139 --> 00:10:08.669
So that's a great user experience, all
while keeping the sensitive data secure.

00:10:08.669 --> 00:10:11.089
And finally I want to talk about cached data.

00:10:11.090 --> 00:10:14.519
Everybody knows what a cache is; I
don't think I need to explain that.

00:10:14.519 --> 00:10:15.409
Save some stuff down...

00:10:15.409 --> 00:10:16.600
I'll explain it anyway.

00:10:16.600 --> 00:10:21.370
Save some stuff to disk, and it's
important on a device like iPhone because...

00:10:21.370 --> 00:10:24.629
especially when battery life is
a concern, you don't want to have

00:10:24.629 --> 00:10:27.480
to re-download things like buddy list, avatars, and stuff...

00:10:27.480 --> 00:10:30.610
image thumbnails, things like that.

00:10:30.610 --> 00:10:36.659
Caching becomes important on iPhone because
iTunes is constantly backing up all of that data.

00:10:36.659 --> 00:10:42.019
So we have a special designated caches directory that
you can find the constant, is called NS caches directory.

00:10:42.019 --> 00:10:45.350
If anybody's not using that, go ahead and jot that down.

00:10:45.350 --> 00:10:50.139
If any data that's saved to the caches
directory is not backed up by iTunes,

00:10:50.139 --> 00:10:53.870
so those 500 image thumbnails are
suddenly left on the device,

00:10:53.870 --> 00:11:01.649
so everybody uses the caches directory effectively then
we can all dramatically reduce the amount of time it takes

00:11:01.649 --> 00:11:03.720
for a user to back their phone up to iTunes.

00:11:03.720 --> 00:11:08.600
And that's you guys contributing to a good user
experience, even when the user's not using your app,

00:11:08.600 --> 00:11:10.950
even when they're not thinking about your app.

00:11:10.950 --> 00:11:14.550
So when you go home after this week, take a good
look at the stuff that you're writing to disk

00:11:14.549 --> 00:11:20.829
and think about the caches directory,
and how you can make better use of that.

00:11:20.830 --> 00:11:24.600
That's it for the data part of the talk,
now I'd like to bring Alex up to talk

00:11:24.600 --> 00:11:27.889
about the design decisions you guys will be facing.

00:11:27.889 --> 00:11:29.569
>> Thank you Matt.

00:11:29.570 --> 00:11:34.430
My name is Alex Aybes, I'm a software
engineer on the iPhone team.

00:11:34.429 --> 00:11:37.949
And before I get started, I want to ask you a question.

00:11:37.950 --> 00:11:43.259
How many of you have been in this situation
where it's Thursday afternoon, it's about 4,

00:11:43.259 --> 00:11:47.720
you're pretty excited because that product
that's due by the end of the week - tomorrow...

00:11:47.720 --> 00:11:51.110
well it's pretty much done.

00:11:51.110 --> 00:11:51.509
You're excited.

00:11:51.509 --> 00:11:57.110
You're going to be on time and you have those great
plans for a fantastic weekend in the wine country,

00:11:57.110 --> 00:11:59.950
that's where the sun's been hiding all week.

00:11:59.950 --> 00:12:01.220
So that's good.

00:12:01.220 --> 00:12:05.009
But then suddenly your manager walks into your office

00:12:05.009 --> 00:12:08.549
[ Laughter ]

00:12:08.549 --> 00:12:11.889
... and goes, we need to change everything.

00:12:11.889 --> 00:12:17.100
All those panels you have, that last one,
well it needs to come to the beginning.

00:12:17.100 --> 00:12:21.600
This other one needs to be presented
modally, and all those things.

00:12:21.600 --> 00:12:25.320
At that point you are thinking, oh...

00:12:25.320 --> 00:12:30.379
no more weekend in the wine country, this
is going to be the office all weekend.

00:12:30.379 --> 00:12:36.059
So today I want to talk to you about a few techniques,
and a few things you can do from the get go,

00:12:36.059 --> 00:12:42.549
from the very beginning to make those massive changes,
those last minute changes because we all know they happen,

00:12:42.549 --> 00:12:46.389
make them take less time so you
can still enjoy your nice weekend

00:12:46.389 --> 00:12:49.120
in the wine country or wherever you want to go this weekend.

00:12:49.120 --> 00:12:50.679
Let's talk about that.

00:12:50.679 --> 00:12:52.819
How are we going to talk about that?

00:12:52.820 --> 00:13:00.660
Well 2 things I'm going to cover: the first one is going
to be a quick recap of how you build your application.

00:13:00.659 --> 00:13:04.379
Most of you are probably familiar with
this, I won't spend too much time on it,

00:13:04.379 --> 00:13:07.429
but I just want to make sure we're
all talking about the same thing.

00:13:07.429 --> 00:13:14.039
The second point is going to be about how you sort
of make the information, the data flow into your app,

00:13:14.039 --> 00:13:17.039
and through all those screens we're going to get.

00:13:17.039 --> 00:13:23.579
Let's take a look at an existing app on the
phone, in this case the Contacts application.

00:13:23.580 --> 00:13:26.440
The Contacts application.

00:13:26.440 --> 00:13:31.330
So you're probably all familiar with it,
it's in the Contacts, it's in the phone app.

00:13:31.330 --> 00:13:37.330
And a lot of the apps on the phone are doing this,
and because the phone is a pretty small device it fits

00:13:37.330 --> 00:13:41.370
in the palm of your hand, you really need
to focus what you're showing to the user.

00:13:41.370 --> 00:13:47.500
And if it's Contacts, you've probably seen it, we show
the groups first then we move over to the list of contacts

00:13:47.500 --> 00:13:51.159
in that group, and to an individual
contact, you can navigate back.

00:13:51.159 --> 00:13:58.990
So it's a really focused set of data and we're
displaying 1 at a time, and switching screens as we go.

00:13:58.990 --> 00:14:02.460
The user can drill down to see more detail.

00:14:02.460 --> 00:14:05.129
So it's good, that's the Contacts application.

00:14:05.129 --> 00:14:10.779
Let's take a look at another app that I
particularly enjoy, because it talks about food.

00:14:10.779 --> 00:14:13.319
So it's a Recipes application.

00:14:13.320 --> 00:14:16.629
You might remember this from last year or
from the samples that I actually published

00:14:16.629 --> 00:14:20.429
on the website, this year we made it better.

00:14:20.429 --> 00:14:23.939
We actually rewrote it using Core Data.

00:14:23.940 --> 00:14:26.700
But it's the same basic principle.

00:14:26.700 --> 00:14:30.790
On the right side, left side, whichever one it is for you...

00:14:30.789 --> 00:14:37.549
on that side you have the list of recipes, in the middle
you have the detail, so the actual detail of that recipe

00:14:37.549 --> 00:14:41.829
and then you have the photo of the
final delicious looking product.

00:14:41.830 --> 00:14:44.180
That was really good.

00:14:44.179 --> 00:14:45.959
So this is a pretty simple app.

00:14:45.960 --> 00:14:51.530
We have 3 screens, we'll end up with 3 controllers
for those 3 screens - a List Controller,

00:14:51.529 --> 00:14:54.839
a Detail Controller, and a Photo Controller.

00:14:54.840 --> 00:14:55.480
Fairly straightforward.

00:14:55.480 --> 00:14:56.930
How do we implement those controllers?

00:14:56.929 --> 00:15:01.739
Like I said, probably most of you are familiar
with it if you've started developing on the iPhone,

00:15:01.740 --> 00:15:04.240
or if you've been doing it for a while...

00:15:04.240 --> 00:15:06.899
use UIKit's UIViewController class.

00:15:06.899 --> 00:15:10.919
It's a pretty simple class; you use
it, each screen you're going to get one

00:15:10.919 --> 00:15:14.000
of those UIKit View controllers, or UIViewControllers.

00:15:14.000 --> 00:15:17.279
You're going to subclass it, add
your own application logic in there,

00:15:17.279 --> 00:15:22.019
and then use that as the basic
building block for your application.

00:15:22.019 --> 00:15:24.990
So what's the role of that view controller?

00:15:24.990 --> 00:15:34.509
At the minimum it's going to load views, that's what
actually is going to make those views appear on screen.

00:15:34.509 --> 00:15:35.569
That's good.

00:15:35.570 --> 00:15:38.350
Then it's going to also connect your model, your data.

00:15:38.350 --> 00:15:39.480
In this case, those recipes.

00:15:39.480 --> 00:15:43.330
It's going to connect them to the views
that you're displaying to the user,

00:15:43.330 --> 00:15:46.660
to bring all that data and show it to user.

00:15:46.659 --> 00:15:51.879
Probably most importantly it's going
to manage the flow of your application.

00:15:51.879 --> 00:15:56.299
What I mean by that, it's sort
of like the chef in the kitchen.

00:15:56.299 --> 00:16:01.599
It's taking all these ingredients, making
dishes out of it, and making an entire meal

00:16:01.600 --> 00:16:05.240
out of it to present to the diner in that case.

00:16:05.240 --> 00:16:09.279
So good, it's making me hungry.

00:16:09.279 --> 00:16:11.480
So View Controller's role, great.

00:16:11.480 --> 00:16:17.840
So now we have all those basic view
controllers we can build and show to user.

00:16:17.840 --> 00:16:24.240
We still need to assemble them, and for that there's another
class that UIKit provides, the UINavigationController.

00:16:24.240 --> 00:16:30.419
That's a pretty standard class, it's used in a lot of
the apps, and it measures the stack of view controllers.

00:16:30.419 --> 00:16:35.639
It will manage a lot of the animation throughout
the application, as well as the updating

00:16:35.639 --> 00:16:38.460
of the Navigation bar, and does a lot of things for you.

00:16:38.460 --> 00:16:42.759
So if you haven't actually used it, take a look, it's good.

00:16:42.759 --> 00:16:46.559
And that about covers all I wanted
to say about application flow.

00:16:46.559 --> 00:16:50.319
So let's take a look at the really interesting stuff.

00:16:50.320 --> 00:16:55.140
How do you, now that you have all those screens and all...

00:16:55.139 --> 00:16:57.139
this application built.

00:16:57.139 --> 00:17:00.120
How do you actually put the data in there?

00:17:00.120 --> 00:17:05.170
So we're going to take a look at the
model, and the Recipes application.

00:17:05.170 --> 00:17:06.490
What is it?

00:17:06.490 --> 00:17:13.670
We have a bunch of recipes, each of those recipes
has a bunch of ingredients, a set of ingredients.

00:17:13.670 --> 00:17:20.070
It has a set of instructions, has an
image, and also has a larger image.

00:17:20.069 --> 00:17:25.649
So OK, you see that matches nicely
to the 3 view controllers we have.

00:17:25.650 --> 00:17:29.640
So now we have these 3 view controllers, we have this model.

00:17:29.640 --> 00:17:33.630
How do we make them talk to one another?

00:17:33.630 --> 00:17:39.340
Well view controllers, model, we can just
go each and every view controller goes there

00:17:39.339 --> 00:17:43.009
and grabs whatever they need, and looks something like...

00:17:43.009 --> 00:17:44.930
whoa, like this.

00:17:44.930 --> 00:17:47.269
It's not so great.

00:17:47.269 --> 00:17:50.099
It's a lot of hands in the same little cookie jar.

00:17:50.099 --> 00:17:57.179
And if you've ever done this at home, little dinner
party, invite 5, 6 friends who love to cook...

00:17:57.180 --> 00:17:58.850
it's usually a disaster.

00:17:58.849 --> 00:17:59.480
Everyone's...

00:17:59.480 --> 00:18:05.160
needs the oven at the same time, and you
end up not eating until 3 in the morning.

00:18:05.160 --> 00:18:12.910
Instead the only way I've found it to work is when I tell
each of them, OK you're doing this, you're doing that.

00:18:12.910 --> 00:18:19.500
Malcolm is doing the salad, Evan is doing the
meat, I'm doing the dessert - strawberry torte.

00:18:19.500 --> 00:18:24.710
And Matt, well Matt's really good at
tasting so that's what he's going to do.

00:18:24.710 --> 00:18:29.920
So we're going to try to apply the same idea to our
application, and it's going to look hopefully more

00:18:29.920 --> 00:18:34.630
like this; where we're actually going to tell each of
those view controllers what they're supposed to do,

00:18:34.630 --> 00:18:40.580
and what they are supposed to look at in
our model, hopefully making less of a mess.

00:18:40.579 --> 00:18:43.039
So how is that going to flow through our application?

00:18:43.039 --> 00:18:50.700
The first thing that gets invoked in your
application, that's the Application Delegate.

00:18:50.700 --> 00:18:55.930
That's the first thing that gets loaded, so makes sense

00:18:55.930 --> 00:18:59.539
to have it load the actual model,
and that's what it's going to do.

00:18:59.539 --> 00:19:01.700
It's going to load the recipes.

00:19:01.700 --> 00:19:05.380
It's also, since it's the first thing it's
actually going to create the first view controller,

00:19:05.380 --> 00:19:13.030
in this case the list controller,
and give it the set of recipes.

00:19:13.029 --> 00:19:20.670
Now when the user actually wants to drill down and see an
actual recipe, this list view controller is going to get

00:19:20.670 --> 00:19:25.070
that recipe, create the next view
controller, and pass the recipe along.

00:19:25.069 --> 00:19:30.089
Same thing when you want to view a photo, it's actually...

00:19:30.089 --> 00:19:36.849
the detail view controller is going to take the photo
and pass it to the next view controller that it creates.

00:19:36.849 --> 00:19:38.259
Alright, fairly straightforward.

00:19:38.259 --> 00:19:42.049
Let's take a look at what's in the
code in the Recipes application.

00:19:42.049 --> 00:19:46.139
By the way that sample is available for you to download.

00:19:46.140 --> 00:19:49.850
And the application did finish
launching, we create the view controller,

00:19:49.849 --> 00:19:54.029
and set up that first view controller
by assigning the managed object context.

00:19:54.029 --> 00:19:58.970
The managed object context is sort of the entry
point in Core Data, when you're loading objects

00:19:58.970 --> 00:20:03.009
from Core Data that's the basic starting point.

00:20:03.009 --> 00:20:05.369
That's where you're going to get all the objects.

00:20:05.369 --> 00:20:08.739
And self managed object context is
where we actually instantiate it.

00:20:08.740 --> 00:20:12.289
If you want to look closer at the
code, it's available for download.

00:20:12.289 --> 00:20:14.000
Alright, that's pretty good.

00:20:14.000 --> 00:20:21.130
So let's take a look now at the next step, when
these are actually launched just like the recipe.

00:20:21.130 --> 00:20:25.440
So it all starts with a user action,
the user selects something...

00:20:25.440 --> 00:20:27.410
again that strawberry torte.

00:20:27.410 --> 00:20:34.610
So when you get when the user selects it, as table view,
sends a message to the delegate, select, roll it in....

00:20:34.609 --> 00:20:41.189
so the first thing we're going to get, we're going
to do, is actually figure out what recipe it is.

00:20:41.190 --> 00:20:46.660
For that we have this interesting fetched results
controller that's new in Core Data for the iPhone,

00:20:46.660 --> 00:20:51.330
and I'm going to talk a little bit more about it later,
but it's a really nice class you really want to check

00:20:51.329 --> 00:20:54.649
out if you're doing Table Views in Core Data.

00:20:54.650 --> 00:21:01.300
So we get that recipe and then we're
going to create the next view controller.

00:21:01.299 --> 00:21:07.440
And once we have that view controller created
by simply allocating and initializing it,

00:21:07.440 --> 00:21:10.049
we set it up, in this case just passing the recipe.

00:21:10.049 --> 00:21:13.029
Again, the recipe is the only thing
it really needs to know about.

00:21:13.029 --> 00:21:15.470
It's the only thing it really cares about.

00:21:15.470 --> 00:21:22.440
So we send that recipe, push the next view
controller on the stack, and forget it, release it.

00:21:22.440 --> 00:21:26.870
You don't really need to hold onto it, it's pretty good.

00:21:26.869 --> 00:21:36.099
So you don't need to hold onto it, but in some cases you
actually do need to not have quite forgotten about it.

00:21:36.099 --> 00:21:40.299
What happens when the user tries to edit that recipe?

00:21:40.299 --> 00:21:43.789
Let's take a look in what it would look like in the UI.

00:21:43.789 --> 00:21:50.009
You have the list, in this case we're going to get
the chocolate cake, so I had the chocolate cake,

00:21:50.009 --> 00:21:55.420
he had the chocolate cake, he decided that it's not really
the chocolate cake, that name is not quite doing it justice.

00:21:55.420 --> 00:22:01.630
So instead we're going to rename it to triple chocolate
cake, because triple is better than single in something.

00:22:01.630 --> 00:22:02.910
So we edit it.

00:22:02.910 --> 00:22:08.330
At that point we need to update that
original view controller with the list,

00:22:08.329 --> 00:22:10.599
because it needs to reflect the new title.

00:22:10.599 --> 00:22:11.909
So how are we going to do this?

00:22:11.910 --> 00:22:19.470
Well the list view controller needs to be told that
something needs to happen so that it can go ahead

00:22:19.470 --> 00:22:25.789
and reorganize the list, now that triple
chocolate cake is at the bottom of the list.

00:22:25.789 --> 00:22:32.700
One easy way to do it, have a pointer from
the detail back to the list controller,

00:22:32.700 --> 00:22:35.980
and at that point just go reload the data.

00:22:35.980 --> 00:22:40.809
That's great until 4 p.m. Thursday evening
when your boss walked in and went - oh,

00:22:40.809 --> 00:22:45.829
actually we're going to add something in between,
and it's not quite going to look like that.

00:22:45.829 --> 00:22:53.389
But at that point all those 2 view controllers are linked
to one another, and you don't know how to separate them.

00:22:53.390 --> 00:22:58.920
So instead of pointing directly back to
the parent, we're going to use delegation.

00:22:58.920 --> 00:23:04.259
Delegation's a pattern you're probably familiar
with if you've been developing on Cocoa

00:23:04.259 --> 00:23:08.579
on the Mac OS X desktop, or Cocoa Touch on the iPhone OS.

00:23:08.579 --> 00:23:11.730
It's used throughout, and it's a very simple way

00:23:11.730 --> 00:23:17.789
to communicate while still preserving
a certain amount of decoupling.

00:23:17.789 --> 00:23:21.569
Let's take a look at how you implement it.

00:23:21.569 --> 00:23:26.269
Delegating, that's going to be the
side of the detail view controller.

00:23:26.269 --> 00:23:28.960
That's the one that's going to be doing the delegation.

00:23:28.960 --> 00:23:32.299
And the first thing it needs to do is declare a protocol.

00:23:32.299 --> 00:23:38.470
To declare a protocol in the header you just declare
the protocol, so in that case we're just going

00:23:38.470 --> 00:23:45.680
to need a single method that just says, hey the recipe
detail view controller actually changed the recipe;

00:23:45.680 --> 00:23:47.279
fairly straightforward.

00:23:47.279 --> 00:23:52.509
The next thing you need is it to actually have
a property for it, so a delegate property.

00:23:52.509 --> 00:23:57.920
In this case, we created the property,
the recipe detail delegate property.

00:23:57.920 --> 00:24:04.930
2 things I want to point out here: the type
of that property, it's just a generic object,

00:24:04.930 --> 00:24:09.549
any generic object that conforms to the recipe
detail view controller delegate protocol.

00:24:09.549 --> 00:24:12.569
And this is how we are doing the separation between the 2.

00:24:12.569 --> 00:24:16.259
At that point they don't know, they
don't need to know what type the parent

00:24:16.259 --> 00:24:18.410
or the delegate in that case, what type the delegate is.

00:24:18.410 --> 00:24:20.950
It just needs to...

00:24:20.950 --> 00:24:24.559
all it cares about is that it implements
that 1method in the protocol.

00:24:24.559 --> 00:24:28.089
The other thing, typically delegates do not retain...

00:24:28.089 --> 00:24:33.529
are not a retaining property, so
it's just an assign in this case,

00:24:33.529 --> 00:24:43.019
and that's important because typically you'll have the
parent of the delegating object will be the one listening.

00:24:43.019 --> 00:24:46.379
So it will be the delegate, and
since the parent owns the child,

00:24:46.380 --> 00:24:50.890
if now the child owns the parent
through delegation relationship...

00:24:50.890 --> 00:24:55.290
retain cycles, memory leaks, bad.

00:24:55.289 --> 00:25:03.210
Alright so we have the recipe detail view
controller side, now to the recipe list controller.

00:25:03.210 --> 00:25:05.850
Bring a delegate.

00:25:05.849 --> 00:25:06.730
What do you need to do?

00:25:06.730 --> 00:25:07.579
Implement the protocol.

00:25:07.579 --> 00:25:13.149
So you need to declare that you conform to the
protocol first in the header, it's pretty simple.

00:25:13.150 --> 00:25:17.140
And next you need to actually implement
that single method in there.

00:25:17.140 --> 00:25:24.490
In this case all we really need to do for the Recipes
app is to just reload the data, it's straightforward.

00:25:24.490 --> 00:25:27.930
You might have more to do in your actual application.

00:25:27.930 --> 00:25:29.600
So we're almost there.

00:25:29.599 --> 00:25:34.089
The last thing we need to do is actually
tell the detail view controller that we care.

00:25:34.089 --> 00:25:37.059
So we need to set the delegate property we got there.

00:25:37.059 --> 00:25:43.299
That's just an extra line when we're setting it up,
detail view controller, right after we assign the recipe;

00:25:43.299 --> 00:25:47.069
we're actually going to set ourselves
as the recipe detail delegate.

00:25:47.069 --> 00:25:51.470
With all that done, we should be good.

00:25:51.470 --> 00:25:55.150
There's 1 thing to note though about delegates

00:25:55.150 --> 00:26:04.120
Sometimes you'll get random crashes in your delegates, and
that's usually because since they don't retain the delegate,

00:26:04.119 --> 00:26:08.419
the delegate might go away before the one delegating.

00:26:08.420 --> 00:26:16.950
So in this case if the recipe list controller somehow
got deallocated before the recipe detail view controller,

00:26:16.950 --> 00:26:19.460
you might have a problem if the
recipe detail view controller wants

00:26:19.460 --> 00:26:22.350
to message it through the delegate property.

00:26:22.349 --> 00:26:28.439
So to avoid that, because that's a very
common crash, I've had it a few times...

00:26:28.440 --> 00:26:35.059
just remove yourself from the delegate
chain in that case dealloc.

00:26:35.059 --> 00:26:40.089
So in this case in dealloc detail view
controller, recipeDetailDelegate equals nil,

00:26:40.089 --> 00:26:44.799
just tell the detail view controller
you don't care anymore - you're gone.

00:26:44.799 --> 00:26:48.930
Good, so that's one way to do this
messaging and still decoupling.

00:26:48.930 --> 00:26:52.470
There are a few other ways you can do this.

00:26:52.470 --> 00:26:55.490
The first one is through notifications.

00:26:55.490 --> 00:26:58.730
Pretty simple, we have NS notification center.

00:26:58.730 --> 00:27:01.579
You can add and remove observers through this.

00:27:01.579 --> 00:27:12.049
And the typical use case for this is when you have 1
object that wants to tell many other objects about changes.

00:27:12.049 --> 00:27:18.180
Typically maybe you're downloading data in the
background in the background thread, and you go OK,

00:27:18.180 --> 00:27:21.360
I got all my new data I want to tell everybody.

00:27:21.359 --> 00:27:24.169
So notifications are good for that.

00:27:24.170 --> 00:27:32.529
One little thing to worry about with notifications,
just like delegates, observers are not retained so...

00:27:32.529 --> 00:27:40.149
in your dealloc again, remove yourself as an observer so
that you don't crash again when something you're trying...

00:27:40.150 --> 00:27:42.400
to post communications to things that have been deallocated.

00:27:42.400 --> 00:27:45.060
So that's notifications.

00:27:45.059 --> 00:27:51.079
The last method for doing this
communication is Key-Value Observing, or KVO.

00:27:51.079 --> 00:27:58.309
This has been available in Foundation
for a while now, and it's very handy,

00:27:58.309 --> 00:28:02.549
it's a really handy little way
to observe particular properties.

00:28:02.549 --> 00:28:07.009
For example your model object, if you want
to know when the list of ingredients changes

00:28:07.009 --> 00:28:11.500
in that recipe, or when the name changes.

00:28:11.500 --> 00:28:17.000
You can say that you want to observe that particular
property in the recipe object, and you'll get messages

00:28:17.000 --> 00:28:20.920
when that property is changed, and
just when that property is changed.

00:28:20.920 --> 00:28:22.539
So it's very handy.

00:28:22.539 --> 00:28:25.680
So that's good, 3 different ways of doing communication.

00:28:25.680 --> 00:28:32.900
Now let's take a look at how this is actually done in the
Recipes app, because I presented the delegate approach

00:28:32.900 --> 00:28:36.580
to it, but it's not quite what we're
using in the end in the Recipes app.

00:28:36.579 --> 00:28:40.470
So let's take a look at how we did it.

00:28:40.470 --> 00:28:44.240
So we have the list controller.

00:28:44.240 --> 00:28:51.529
That list controller got the managed object
context from the app delegate at the beginning,

00:28:51.529 --> 00:28:55.879
and it also creates an NSFetchedResultsController.

00:28:55.880 --> 00:29:00.670
That's what I'd mentioned earlier, it's this
class that's available now in iPhone OS 3.0

00:29:00.670 --> 00:29:03.310
in Core Data that does a lot of work for you.

00:29:03.309 --> 00:29:07.720
So if you have a table view, if you have
objects in Core Data, take a look at this.

00:29:07.720 --> 00:29:14.960
It will do a lot of caching, a lot of pre-fetching, a lot of
really nice stuff that you don't need to worry about that.

00:29:14.960 --> 00:29:20.019
That fetched results controller points back to the managed
object context to actually load the object from somewhere.

00:29:20.019 --> 00:29:29.339
And that managed object context, well, loads
the objects - the recipes in this case.

00:29:29.339 --> 00:29:35.339
Alright, so that's how it works, in the app, display
objects, how do we actually get the communication

00:29:35.339 --> 00:29:39.959
from the recipes back to the list controller?

00:29:39.960 --> 00:29:46.789
Well when the name of the recipe is changed,
the managed object context hears about it.

00:29:46.789 --> 00:29:48.129
How does it hear about it?

00:29:48.130 --> 00:29:50.390
Through KVO, through Key Value Observing.

00:29:50.390 --> 00:29:55.450
The managed object context automatically, when it
loads the object, registers for notifications from them

00:29:55.450 --> 00:29:59.350
or starts observing these objects through KVO.

00:29:59.349 --> 00:30:03.309
So if we change the name, the managed
object context hears about it.

00:30:03.309 --> 00:30:06.859
Next we need to actually tell fetched results controller.

00:30:06.859 --> 00:30:07.969
And how does that happen?

00:30:07.970 --> 00:30:09.819
Well through notifications.

00:30:09.819 --> 00:30:12.789
Why through notifications?

00:30:12.789 --> 00:30:18.149
Well mostly because typically you'll have 1
managed object context that gets passed along

00:30:18.150 --> 00:30:20.310
through your different view controllers,

00:30:20.309 --> 00:30:25.750
and you have possibly 1 fetched results
controller for each of those view controllers.

00:30:25.750 --> 00:30:33.549
So 1 managed object context, many fetched results
controller, it's a good use of notifications in that case.

00:30:33.549 --> 00:30:42.259
And finally we need to tell the list that something's
changed, and we do that through delegation.

00:30:42.259 --> 00:30:47.930
Voila. All 3 of the methods I was describing
are actually being used in the Recipes app,

00:30:47.930 --> 00:30:52.700
and while 2 of those you don't really need
to worry about, notifications and KVO,

00:30:52.700 --> 00:30:56.789
because they are actually done under
the hood by Core Data for you...

00:30:56.789 --> 00:31:05.269
you can still have similar techniques and that really
illustrates well use cases for all those 3 methods.

00:31:05.269 --> 00:31:09.900
So it's good, now you have use cases and
you know about 3 different ways to sort

00:31:09.900 --> 00:31:15.710
of separate those view controllers,
but really why should you bother?

00:31:15.710 --> 00:31:19.529
It's so much easier to just go reload data on your parent.

00:31:19.529 --> 00:31:23.420
Well the first thing you're going
to get out of this is, reusability.

00:31:23.420 --> 00:31:29.750
You're going to be able to take those
view controllers and put them anywhere.

00:31:29.750 --> 00:31:35.509
That also allows us to provide you with view
controllers that you can just reuse out of the box,

00:31:35.509 --> 00:31:40.259
like the Person View Controller, or
the People Picker, or the Photo Picker.

00:31:40.259 --> 00:31:48.069
All those view controllers and many more that are
available now in 3.0, are there for you to use and make use

00:31:48.069 --> 00:31:54.210
of notifications, of delegation, so that you can
just insert them in your view controller stack

00:31:54.210 --> 00:31:56.779
and then no need to worry about what's going on.

00:31:56.779 --> 00:32:03.099
When they need to tell you something, they'll use delegation
or notifications, and that way you can act appropriately.

00:32:03.099 --> 00:32:05.579
So that's great.

00:32:05.579 --> 00:32:08.990
We can give you some view controllers to reuse.

00:32:08.990 --> 00:32:12.329
But it's also really important
for you, because I imagine most

00:32:12.329 --> 00:32:14.949
of you probably want to write more than just 1 application.

00:32:14.950 --> 00:32:23.210
You probably want to write multiple ones, keep pushing
more apps in the store, seeing those revenues grow.

00:32:23.210 --> 00:32:28.590
So reusability will actually allow
you to write your view controller

00:32:28.589 --> 00:32:32.059
for the first app, and then reuse it in the second app.

00:32:32.059 --> 00:32:37.269
And if they don't know about the previous view
controller, the chain of view controllers, all the better.

00:32:37.269 --> 00:32:40.769
You're actually going to be able to just put them in there.

00:32:40.769 --> 00:32:45.009
So that's great, that's 1 thing you get - reusability.

00:32:45.009 --> 00:32:51.930
You're also going to get reorganization, the
ability to move those view controllers around.

00:32:51.930 --> 00:32:57.120
That means mostly because the view
controllers don't know about their parent.

00:32:57.119 --> 00:33:03.059
That means you don't have this really
tight chain of view controllers.

00:33:03.059 --> 00:33:07.139
Instead you can actually just grab the delegate
implementation, move it to another fav,

00:33:07.140 --> 00:33:12.420
or re-implement the delegate and now you
can just reorganize your view controllers.

00:33:12.420 --> 00:33:19.460
What that really means is that on Thursday when
your boss comes in, you can go yeah, that's fine.

00:33:19.460 --> 00:33:21.220
I'll do that tomorrow.

00:33:21.220 --> 00:33:28.319
And Saturday, Sunday you still get to go to the wine
country - enjoy the sun that you've been missing all week,

00:33:28.319 --> 00:33:31.480
do whatever else people do in the wine country.

00:33:31.480 --> 00:33:33.549
So it's good, good thing.

00:33:33.549 --> 00:33:39.230
It's a great weekend, nice, sunny, and everything.

00:33:39.230 --> 00:33:42.099
Now it's Monday...

00:33:42.099 --> 00:33:44.859
need to talk about memory.

00:33:44.859 --> 00:33:51.189
No one really wants to talk about memory, but
everyone's going to have to talk about memory.

00:33:51.190 --> 00:33:56.259
It's an important subject, especially on such
a small device as the iPhone, the iPod Touch.

00:33:56.259 --> 00:34:00.410
So what are we going to cover?

00:34:00.410 --> 00:34:01.840
Can I remember what we're going to...

00:34:01.839 --> 00:34:03.269
yes, memory problems!

00:34:03.269 --> 00:34:06.049
That's right, memory problems.

00:34:06.049 --> 00:34:07.960
Sometimes it happens.

00:34:07.960 --> 00:34:10.449
If you can't remember your slides,
that's a memory problem...

00:34:10.449 --> 00:34:12.599
but it's unrelated to your application.

00:34:12.599 --> 00:34:17.039
So 3 things we're going to cover: the
first one, how do you identify the problem?

00:34:17.039 --> 00:34:19.730
How do you figure out, oh this could be a memory problem?

00:34:19.730 --> 00:34:24.750
Then I'm going to talk to you about a few
tools that we provide to help you with those,

00:34:24.750 --> 00:34:27.909
solve the memory problems when you figure out you have some.

00:34:27.909 --> 00:34:33.159
And finally we're going to talk about some techniques
you can use with regards to your model, your views,

00:34:33.159 --> 00:34:38.269
your controllers, and to help you
reduce the memory footprint.

00:34:38.269 --> 00:34:39.489
So let's get started.

00:34:39.489 --> 00:34:43.649
How do you figure out you have a problem?

00:34:43.650 --> 00:34:49.160
Well a good hint is your user is calling you or
emailing you, or however they're reporting bugs,

00:34:49.159 --> 00:34:54.289
and complaining that the app just
quits all the time in random places.

00:34:54.289 --> 00:34:56.980
You can't quite track down...

00:34:56.980 --> 00:35:00.000
it's not that particular download,
it's not that particular account,

00:35:00.000 --> 00:35:04.179
it's not that particular screen,
it seems to be all over the place.

00:35:04.179 --> 00:35:09.549
That could be a good hint that the system is running
out of memory, and actually quitting your app,

00:35:09.550 --> 00:35:12.330
and to the user it's exactly the same as a crash.

00:35:12.329 --> 00:35:14.900
As a matter of fact, it will actually produce a crash log,

00:35:14.900 --> 00:35:19.930
and now we're giving you the crash
logs so you can look through them.

00:35:19.929 --> 00:35:22.829
And 2 things to look out for in the crash logs...

00:35:22.829 --> 00:35:30.599
no backtraces, a good hint that we actually just
quit your app because we didn't have any more memory.

00:35:30.599 --> 00:35:35.900
And the other one, messages in the
console talking about memory warnings.

00:35:35.900 --> 00:35:39.730
That's a good hint, that's a memory warning.

00:35:39.730 --> 00:35:46.570
So now that you know you have a
memory problem, how do you fix it?

00:35:46.570 --> 00:35:48.710
We have a few tools.

00:35:50.610 --> 00:35:55.640
So those tools, the first one I
want to talk about is Instruments.

00:35:55.639 --> 00:36:03.190
2 things in Instruments that are a great help, 2
instruments in Instruments that are a great help.

00:36:03.190 --> 00:36:04.829
The first one is Leaks.

00:36:04.829 --> 00:36:12.829
Leaks are what happens when you allocate
memory, retain it, stop using it,

00:36:12.829 --> 00:36:16.819
but yet forget to release it, to free it, to deallocate it.

00:36:16.820 --> 00:36:24.470
It's bad. The system doesn't know you're done with it,
and it can't reallocate it, reuse it for anything else.

00:36:24.469 --> 00:36:31.980
So the Leaks instrument, well it actually helps you
track down exactly where this object was retained,

00:36:31.980 --> 00:36:37.300
where it was released, who is still
holding onto it, etc. It's a very nice tool

00:36:37.300 --> 00:36:41.130
to actually track down leaks in your application.

00:36:41.130 --> 00:36:47.079
The second one, ObjectAlloc, is
more for the lifetime of your app.

00:36:47.079 --> 00:36:52.929
It will help you graph your memory
usage, how it goes and how it increases

00:36:52.929 --> 00:36:57.759
and hopefully decreases sometimes,
throughout the lifespan of your app.

00:36:57.760 --> 00:36:59.050
So it's a really, really nice tool.

00:36:59.050 --> 00:37:03.710
It will really tell you with great
detail where you're using memory.

00:37:03.710 --> 00:37:07.070
I'm not going to talk too much about
those, there are great sessions.

00:37:07.070 --> 00:37:11.570
One right now in mission, don't leave please.

00:37:11.570 --> 00:37:13.950
You can check it out in the video later.

00:37:13.949 --> 00:37:22.039
And another one, which is today actually at 5 p.m.
which you will also be able to check on video,

00:37:22.039 --> 00:37:24.829
so you should just stay here for the next session.

00:37:24.829 --> 00:37:27.360
So great tool, Instruments.

00:37:27.360 --> 00:37:29.070
Check it out.

00:37:29.070 --> 00:37:31.980
The other tool I want to talk about is the Simulator.

00:37:31.980 --> 00:37:33.559
Why the Simulator?

00:37:33.559 --> 00:37:41.070
Well it simulates things, and I've been talking about memory
warnings and that's one of the things you can simulate.

00:37:41.070 --> 00:37:47.559
It's quite difficult to actually reproduce a memory
warning on the phone itself while you're debugging it,

00:37:47.559 --> 00:37:51.489
because you don't have control over
what's going on in the background.

00:37:51.489 --> 00:37:59.259
You could try to load 16 million pages in Safari and
check your mail 14 times, it can be quite difficult.

00:37:59.260 --> 00:38:05.050
Instead you can just use a simulator and simulate, good.

00:38:05.050 --> 00:38:06.710
What do you do once you simulate a memory warning?

00:38:06.710 --> 00:38:09.260
Well use Instruments.

00:38:09.260 --> 00:38:10.660
It's really good.

00:38:10.659 --> 00:38:17.129
The ObjectAlloc in particular will help you track down how
you're using memory, and hopefully how you're releasing

00:38:17.130 --> 00:38:19.490
that memory once you get a memory warning.

00:38:19.489 --> 00:38:20.899
How the system...

00:38:20.900 --> 00:38:23.990
to prevent it from quitting you.

00:38:23.989 --> 00:38:25.809
So that'd be good.

00:38:25.809 --> 00:38:31.340
And if you're not releasing that memory, again
ObjectAlloc will tell you who's still holding onto it.

00:38:31.340 --> 00:38:32.440
So it's quite handy.

00:38:32.440 --> 00:38:40.889
The last tool I wanted to talk about is new
in Snow Leopard, it's really, really nice.

00:38:40.889 --> 00:38:43.730
It's the Xcode Static Analysis tool.

00:38:43.730 --> 00:38:47.619
If you haven't checked out Snow Leopard
and Xcode, I recommend you do it.

00:38:47.619 --> 00:38:53.559
It will actually point out a lot of potential
mistakes in your code, potential errors,

00:38:53.559 --> 00:38:55.380
and in particular retain-release problems.

00:38:55.380 --> 00:39:01.130
It will actually tell you - oh this
object doesn't seem to have been released.

00:39:01.130 --> 00:39:09.880
So once you see that, you can go inspect your code, because
in the end it's a tool that will tell you what it thinks,

00:39:09.880 --> 00:39:16.019
but you are the ones who know your code best
hopefully, and you can actually go in and fix it.

00:39:16.019 --> 00:39:20.920
I found out about the Xcode Static Analysis tool
fairly recently and actually I got so excited I wanted

00:39:20.920 --> 00:39:26.539
to do a demo, so I'm going to do just that.

00:39:26.539 --> 00:39:27.630
Beautiful.

00:39:27.630 --> 00:39:30.950
Alright, so this is the Recipes application.

00:39:30.949 --> 00:39:32.980
If I run it...

00:39:32.980 --> 00:39:37.429
looks like all the screen shots that I showed you,
and I'm going to go check out the strawberry torte.

00:39:37.429 --> 00:39:41.039
I made that a couple weeks ago, it was really good...

00:39:41.039 --> 00:39:42.969
still remember it.

00:39:42.969 --> 00:39:47.250
So you see, it kind of looks like last
year except it's Core Data, so it's better.

00:39:47.250 --> 00:39:53.130
Now we're going to go to Xcode since I heard
about this great new tool, I want to check it out.

00:39:53.130 --> 00:39:57.320
And to check it out we're going
to go click on the Build menu.

00:39:57.320 --> 00:40:01.630
Under the Build menu you have Build
and Analyze, I'm going to run that...

00:40:01.630 --> 00:40:07.869
and now, you probably can't see this, but in
the lower corner here there's a little icon,

00:40:07.869 --> 00:40:12.529
blue icon with 1 thing and it says...

00:40:12.530 --> 00:40:18.550
potential leak of an object allocated
on line 137 and stored in 2 types.

00:40:18.550 --> 00:40:26.500
If you drill down into it, it will actually show you the
path the static analysis tool took to determine that leak.

00:40:26.500 --> 00:40:33.769
So it'll tell you oh, it went there and then
continued on and on, and then on and then on...

00:40:33.769 --> 00:40:39.130
Oh and here, an object was allocated
- the NS Array, alloc init.

00:40:39.130 --> 00:40:43.460
And here returns an object with a plus 1 retain count.

00:40:43.460 --> 00:40:44.210
So far so good.

00:40:44.210 --> 00:40:49.170
And at the end, well that object has never been released.

00:40:49.170 --> 00:40:56.190
Object allocated line 137 and stored in 2 types
is no longer a reference after this point.

00:40:56.190 --> 00:40:59.990
When you examine the code you go oh yeah,
I'm just forgetting to release it am I not?

00:40:59.989 --> 00:41:03.839
So we're going to fix that.

00:41:03.840 --> 00:41:06.420
And then, still running...

00:41:06.420 --> 00:41:10.200
anyway, actually just going to
go ahead and rebuild and analyze.

00:41:10.199 --> 00:41:13.619
And now we're good, so green.

00:41:13.619 --> 00:41:19.940
Alright, so that's the very quick overview of some of
the things the Xcode Static Analysis tool can do for you.

00:41:19.940 --> 00:41:21.530
I highly recommend you go check it out.

00:41:21.530 --> 00:41:26.300
So the last thing I wanted to cover is a
few tips and hints on some things to do

00:41:26.300 --> 00:41:29.190
with your model and your view controllers.

00:41:29.190 --> 00:41:32.619
First of all the view controllers.

00:41:32.619 --> 00:41:35.579
You don't really need to cache them.

00:41:35.579 --> 00:41:41.119
They should be pretty lightweight, and the time to
load them in your application really very small.

00:41:41.119 --> 00:41:44.569
So I'd highly recommend you don't cache them.

00:41:44.570 --> 00:41:49.480
This is where the system, and typically the
Navigation Controller, when you're not dealing

00:41:49.480 --> 00:41:55.090
with that view controller anymore, can release it
and you're done, you don't need to worry about when

00:41:55.090 --> 00:41:58.510
to release your cache, when to unload
things, when to refresh things,

00:41:58.510 --> 00:42:02.430
etc. So I'd highly recommend you consider not caching them.

00:42:02.429 --> 00:42:06.129
If they take a long time to load,
maybe there's another problem.

00:42:06.130 --> 00:42:09.410
So investigate that, Instruments again, really good

00:42:09.409 --> 00:42:15.559
to investigate what's actually taking all
that time to load the view controllers.

00:42:15.559 --> 00:42:16.509
Respond to memory warnings.

00:42:16.510 --> 00:42:19.990
I repeated memory warnings quite a few times now?

00:42:19.989 --> 00:42:23.779
So don't forget to respond to those memory warnings.

00:42:23.780 --> 00:42:29.790
It's a good hint that you have very little time to
actually do something about memory before your app quits,

00:42:29.789 --> 00:42:32.500
and to the user essentially just crashes.

00:42:32.500 --> 00:42:34.539
So respond to them, and that's pretty easy.

00:42:34.539 --> 00:42:39.000
You have a method in view controller,
did receive memory warning.

00:42:39.000 --> 00:42:45.090
One thing I need to emphasize here, when you
implement that method, do not forget to call super.

00:42:45.090 --> 00:42:50.150
Super, the default implementation in
this case of did receive memory warning

00:42:50.150 --> 00:42:54.329
in UIView controller, will unload your view.

00:42:54.329 --> 00:42:58.420
And that's actually quite a fair amount of memory if you
have a deep view hierarchy, if you have a lot of images

00:42:58.420 --> 00:43:01.450
in there; it'll unload your view
and let go of all that memory.

00:43:01.449 --> 00:43:03.789
That happens when that view controller is not on the screen.

00:43:03.789 --> 00:43:09.199
We're not actually going to go ahead and remove all the
views from the screen, and to the user that would be bad.

00:43:09.199 --> 00:43:12.879
So all the view controllers are not on
the screen, get their views unloaded.

00:43:12.880 --> 00:43:17.690
And once that's done you can actually
do additional clean up.

00:43:17.690 --> 00:43:26.679
For example, if we are viewing the detail view
controller, the list controller could actually just let go

00:43:26.679 --> 00:43:32.269
of the entire manage objects, in this case all the
recipes it's viewing, doesn't really need them,

00:43:32.269 --> 00:43:35.389
when it comes back just re-fetch from the database.

00:43:35.389 --> 00:43:37.900
Nice way to clean out the memory.

00:43:37.900 --> 00:43:42.570
So if you receive memory warning, as I
said UIViewController, unloads the view.

00:43:42.570 --> 00:43:46.809
What this means for you, very important,
is that the view's gone

00:43:46.809 --> 00:43:52.559
and now in 3.0 you can actually implement
viewDidUnload, it will tell you that it's gone.

00:43:52.559 --> 00:43:54.940
That means that if you are...

00:43:54.940 --> 00:44:02.470
if you have outlets, if you have pointers, to any
of the subviews of that main view controller view...

00:44:02.469 --> 00:44:07.519
let go, get rid of them, A, it's
probably good for memory at that point.

00:44:07.519 --> 00:44:14.489
But B, they're probably not valid anymore since they're
not in the view hierarchy, since their parent is gone.

00:44:14.489 --> 00:44:16.559
So get viewDidUnload.

00:44:16.559 --> 00:44:18.829
Important to implement.

00:44:18.829 --> 00:44:22.559
So that's view controllers, now the model.

00:44:22.559 --> 00:44:27.549
Spread that model thinly throughout your view controllers.

00:44:27.550 --> 00:44:32.289
If every one of the view controllers in the
Recipes app is holding to the entire model,

00:44:32.289 --> 00:44:39.070
when the memory warning comes in, can't really do
anything because everyone's holding onto everything.

00:44:39.070 --> 00:44:45.750
So instead, if the recipe detail is just holding
onto the 1 recipe it has, the photo is just holding

00:44:45.750 --> 00:44:51.030
onto the 1 photo it has, then you can get rid of the
previous view controllers, the ones that are not onscreen,

00:44:51.030 --> 00:44:56.940
can actually let go and release all the
model objects that we're holding onto.

00:44:56.940 --> 00:45:02.530
And you're good, you're saving memory, and
hopefully you won't get quit after that.

00:45:02.530 --> 00:45:03.940
The next thing is Core Data.

00:45:03.940 --> 00:45:14.019
Another great advantage of Core Data with memory,
the first thing it can do partial object graphs.

00:45:14.019 --> 00:45:22.590
What that means is that in your first list view
controller, you can ask for all the recipes.

00:45:22.590 --> 00:45:26.600
It'll give you an array that actually
doesn't actually contain all the recipes.

00:45:26.599 --> 00:45:31.900
The other thing, it will give you recipes and if you
tell it, well I'm really only interested for now,

00:45:31.900 --> 00:45:38.240
I'm really only interested in the name,
the description, and the thumbnail.

00:45:38.239 --> 00:45:47.389
That means the gigantic 12,000 by 20,000
pixel image is not already loaded in memory.

00:45:47.389 --> 00:45:53.940
Instead Core Data will nicely load it for you
later when you ask for that particular image.

00:45:53.940 --> 00:45:59.300
I would not necessarily recommend 12,000
by 20,000 pixel images, not a good idea.

00:45:59.300 --> 00:46:04.900
So it will do automatic defaulting of all
these properties it didn't fetch at first.

00:46:04.900 --> 00:46:10.110
And last but not least, it will respond to memory warnings.

00:46:10.110 --> 00:46:11.700
It's a good citizen.

00:46:11.699 --> 00:46:19.289
So the response to memory warnings gets rid of a lot of
the cache that it maintains for you to accelerate things,

00:46:19.289 --> 00:46:22.309
and will automatically reload a
lot of those objects as well.

00:46:22.309 --> 00:46:23.699
So it's very nice.

00:46:23.699 --> 00:46:28.089
So if you haven't already used it, check out Core Data.

00:46:28.090 --> 00:46:37.329
Just to summarize, as much as we all hate to be figuring
out what memory leaks I have, and why my application's using

00:46:37.329 --> 00:46:40.980
so much memory and gets quit half
of the time, it's important.

00:46:40.980 --> 00:46:42.740
So it's...

00:46:42.739 --> 00:46:48.509
small devices again, and every time you run
out of memory your app's going to get quit.

00:46:48.510 --> 00:46:54.610
To the user it's just another crash, it's
a bad review on the App Store, bad things.

00:46:54.610 --> 00:46:59.530
We have a lot of great tools and new tools in Snow
Leopard, so if you haven't already used them...

00:46:59.530 --> 00:47:03.820
Xcode Static Analysis is awesome, Instruments, really cool.

00:47:03.820 --> 00:47:05.360
So check them out.

00:47:05.360 --> 00:47:12.260
And finally that can be overlooked fairly often, but
the way you actually structure your code and structure

00:47:12.260 --> 00:47:18.810
which view controllers really get what parts of
data, makes a huge difference with regards to memory.

00:47:18.809 --> 00:47:20.650
So don't forget that.

00:47:20.650 --> 00:47:24.539
And on that, I'll hand it back over to Matt.

00:47:24.539 --> 00:47:28.579
>> So these 2 bits, the memory management and the
design decisions, are really, really important.

00:47:28.579 --> 00:47:32.019
I mean everybody understands that you don't
manage memory properly, you're going to crash.

00:47:32.019 --> 00:47:32.809
That one's easy.

00:47:32.809 --> 00:47:35.980
But these design decisions are really important.

00:47:35.980 --> 00:47:39.760
I hope Alex has explained the importance
of that coupling and the proper separation.

00:47:39.760 --> 00:47:45.440
A lot of it sounds text-booky, but you really want to take
the time to define delegates in places where there's going

00:47:45.440 --> 00:47:47.950
to be transmission and flow of information.

00:47:47.949 --> 00:47:51.799
It's going to help you cope with
those re-designs that will happen.

00:47:51.800 --> 00:47:56.880
A design is an iterative process; we've said that,
you heard Eric say that in the UI design talk,

00:47:56.880 --> 00:48:01.240
you heard Brett say it in the prototyping session yesterday.

00:48:01.239 --> 00:48:06.589
So taking these steps, taking that little extra time
in the beginning, will help you adapt to changes,

00:48:06.590 --> 00:48:10.660
and it will also help you do things like use
the same view controller in multiple places,

00:48:10.659 --> 00:48:13.799
some more flexible code is going to be reusable.

00:48:13.800 --> 00:48:18.039
The WWDC app certainly went through a bunch
of changes before it ended up in your hands.

00:48:18.039 --> 00:48:25.469
I can promise you that it would not have ended up
the same way if we weren't following these practices.

00:48:25.469 --> 00:48:29.989
So I'd like to finish up by talking about all the other
things that happen during the lifespan of your app,

00:48:29.989 --> 00:48:34.799
both inside it and coming from other areas in
the system and how you can work with those,

00:48:34.800 --> 00:48:37.780
and adapt and respond to them appropriately.

00:48:37.780 --> 00:48:43.910
So 3 things we'll talk about: interruptions,
which are pretty straightforward,

00:48:43.909 --> 00:48:47.230
concurrency threading, and compatibility.

00:48:47.230 --> 00:48:53.740
Compatibility's been a huge topic since iPhone OS 3.0
came about, and it's going to continue to be important

00:48:53.739 --> 00:48:59.059
as it ships and as the next release
makes its way into the world.

00:48:59.059 --> 00:49:03.130
So starting with interruptions...

00:49:03.130 --> 00:49:04.880
Interruptions can come from anywhere.

00:49:04.880 --> 00:49:08.599
There are all kinds of things that can happen
that can steal focus from your application.

00:49:08.599 --> 00:49:15.819
The phone could ring, you could get a calendar reminder,
you get an SMS or an MMS message depending on your carrier.

00:49:15.820 --> 00:49:19.010
You could get an alarm from the clock application.

00:49:19.010 --> 00:49:23.540
[ Laughter and applause ]

00:49:23.539 --> 00:49:27.150
And now in 3.0 you can get a dialogue
from the push notification service.

00:49:27.150 --> 00:49:32.579
These things all come from applications
from contexts that you have no idea about.

00:49:32.579 --> 00:49:37.539
And not only can they steal focus from your
app, but if the user takes the according action,

00:49:37.539 --> 00:49:39.670
they can actually terminate your application.

00:49:39.670 --> 00:49:45.039
So understanding these interruptions - where they come
from and how to deal with them, is very important.

00:49:45.039 --> 00:49:48.909
So there are 3 delegate methods that
your application delegate receives.

00:49:48.909 --> 00:49:51.629
Most of you have probably seen this
before, but I want to revisit it

00:49:51.630 --> 00:49:55.230
because we've seen a lot of apps that aren't doing this.

00:49:55.230 --> 00:50:00.730
The first one you get when an interruption occurs, your
app delegate receives "application will resign active".

00:50:00.730 --> 00:50:04.710
And this means that the phone is ringing
or one of those dialogues has come up.

00:50:04.710 --> 00:50:09.380
As soon as you get this message, you want to pause
whatever you're doing, especially in the case of a game -

00:50:09.380 --> 00:50:13.900
I'm fighting the boss, I don't want to
die by the time I've rejected the call -

00:50:13.900 --> 00:50:17.340
and you want to save any information that was important.

00:50:17.340 --> 00:50:18.829
This is where you want to do that.

00:50:18.829 --> 00:50:22.920
Preserve all your state, save all the user data,
anything that was important, take care of it here.

00:50:22.920 --> 00:50:26.360
Because there are 2 things that can happen from here.

00:50:26.360 --> 00:50:30.519
The first is the user could dismiss the
application, excuse me, dismiss the interruption.

00:50:30.519 --> 00:50:37.059
In that case you'll receive "application did resume active",
which means everything's back to normal and you can proceed.

00:50:37.059 --> 00:50:40.349
In the case of a game where it was
paused, we recommend you keep it paused

00:50:40.349 --> 00:50:43.420
and just let the user decide when
he wants to start playing again.

00:50:43.420 --> 00:50:51.260
And if the user accepts the interruption, you receive
"application will terminate", and this is the same message

00:50:51.260 --> 00:50:53.750
that you receive when the user presses the Home button.

00:50:53.750 --> 00:50:55.710
And this means it's over.

00:50:55.710 --> 00:50:57.559
Notice it's "application will terminate".

00:50:57.559 --> 00:51:01.650
It's not "application might terminate",
it's not "application will terminate later",

00:51:01.650 --> 00:51:03.930
it's not "application may I please terminate".

00:51:03.929 --> 00:51:08.629
It's "application will terminate", and there's
no time span associated with this either.

00:51:08.630 --> 00:51:10.760
This message is really just a courtesy.

00:51:10.760 --> 00:51:16.150
You don't want to do anything important here,
because you will not have the time to get it done.

00:51:16.150 --> 00:51:19.019
Anything important needs to be
done when that interruption occurs.

00:51:19.019 --> 00:51:23.009
It's very important to understand that.

00:51:23.010 --> 00:51:25.230
So let's move on to concurrency.

00:51:25.230 --> 00:51:30.539
As these devices get more powerful, and your apps
get more sophisticated, you start doing more work

00:51:30.539 --> 00:51:34.590
and you start thinking about how you can
offload that work, or postpone and delay it

00:51:34.590 --> 00:51:37.280
so you can have a more responsive user interface.

00:51:37.280 --> 00:51:43.940
And when we say concurrency, when we say
offload, we start to think about threads.

00:51:43.940 --> 00:51:50.000
Now luckily there's a lot of API in Cocoa Touch that
can allow you to perform these asynchronous tasks

00:51:50.000 --> 00:51:55.380
or offload busy operations, without having to worry
about threads manually - things like NSOperation,

00:51:55.380 --> 00:52:01.550
NSOperationQueue, you just pass it an object and
a selector and it goes ahead and does the work.

00:52:01.550 --> 00:52:06.690
NSURLConnection has an asynchronous mode where
you set a delegate and you just receive callbacks

00:52:06.690 --> 00:52:09.159
as data becomes available, as the download completes.

00:52:09.159 --> 00:52:12.539
That's done in a background thread, but
you don't need to worry or even think

00:52:12.539 --> 00:52:15.199
about the threads that are associated with it.

00:52:15.199 --> 00:52:19.710
And there's a lot more available in Cocoa
Touch, so before you go ahead and start diving

00:52:19.710 --> 00:52:23.750
down into manual synchronization and thread
management, take a look at all the high level APIs.

00:52:23.750 --> 00:52:29.440
I like to think that we make a lot of things easy in Cocoa
Touch, so if you find yourself writing hundreds of lines

00:52:29.440 --> 00:52:33.269
of code to perform a relatively trivial
task, you should stop and say hmmm...

00:52:33.269 --> 00:52:34.570
maybe I'm missing something.

00:52:34.570 --> 00:52:40.300
We've got the developer forums now where you
can ask your peers and Apple experts questions.

00:52:40.300 --> 00:52:44.519
Take the time to figure out what
the right way to do things is.

00:52:44.519 --> 00:52:50.900
And regardless of whether you're using these
asynchronous APIs, managing threads manually,

00:52:50.900 --> 00:52:56.099
or just doing it all in the main thread, make
sure you illustrate that activity to the user.

00:52:56.099 --> 00:53:01.069
Constantly keep the user informed of what's going on,
and there are a couple of APIs that make that easy.

00:53:01.070 --> 00:53:13.019
UI Application has the network activity indicator Boolean,
which activates that status spinner in the status bar.

00:53:13.019 --> 00:53:15.639
We've also got the generic UIActivityIndicatorView,

00:53:15.639 --> 00:53:18.859
which is the spinner that you see
in places like mail and the toolbar.

00:53:18.860 --> 00:53:22.660
And we've got the UIProgressView
which lets you do that progressive...

00:53:22.659 --> 00:53:29.629
download progress or anything else that
has a deterministic start and finish.

00:53:29.630 --> 00:53:33.059
When we're talking about concurrency
we're talking about threading.

00:53:33.059 --> 00:53:37.900
Eventually this work that you're doing will
probably be reflected in the user interface.

00:53:37.900 --> 00:53:44.930
So when it comes to updating the UI, you have to
remember that UIKit is a single-threaded environment.

00:53:44.929 --> 00:53:49.019
Everything that UIKit does happens on the
main thread, and it's your responsibility

00:53:49.019 --> 00:53:51.840
to make sure that that contract is fulfilled.

00:53:51.840 --> 00:53:59.140
And the delegate messages that you receive from
UIKit are always called on the main thread as well.

00:53:59.139 --> 00:54:02.759
Now for you, if you're doing something in a
background thread, you've got an operation

00:54:02.760 --> 00:54:05.970
and an operation queue, you need to update your UI.

00:54:05.969 --> 00:54:10.569
You need to make sure anything you do there is
wrapped in a call to performSelectorOnMainThread.

00:54:10.570 --> 00:54:13.580
This will bump you onto the main thread's run loop.

00:54:13.579 --> 00:54:18.849
And if you're not sure where you are, you can just
ask NSThread, am I currently on the main thread?

00:54:18.849 --> 00:54:24.029
So 2 very easy APIs, not a lot of work, that can
ensure that you're going to do the right thing.

00:54:24.030 --> 00:54:28.200
Anything with a UI prefix in it needs
to be called on the main thread.

00:54:28.199 --> 00:54:33.710
So go home, take a look and make sure that there's not a
potential for you to be calling stuff on the main thread.

00:54:33.710 --> 00:54:38.039
If you're getting away with it right
now, don't take that for granted.

00:54:38.039 --> 00:54:44.889
Go back and take the time to do the right thing,
otherwise you may end up with some crashes down the road.

00:54:44.889 --> 00:54:49.089
So we've been talking about threading,
we're obviously concerned about performance.

00:54:49.090 --> 00:54:53.769
And when it comes to UIKit and
proper performance and drawing speed,

00:54:53.769 --> 00:54:55.739
there are a couple of things that you can do to...

00:54:55.739 --> 00:55:01.279
that are very simple, that you can do to make sure that your
UI is performing and operating the way you would expect.

00:55:01.280 --> 00:55:06.400
The first thing is you don't want to call
the loadView method on UIViewController.

00:55:06.400 --> 00:55:08.570
And most of you probably know this, but we've seen it.

00:55:08.570 --> 00:55:12.809
If you need to get to the view controller's
view, just access the view property.

00:55:12.809 --> 00:55:15.929
If the view is not in memory, it will call loadView for you.

00:55:15.929 --> 00:55:18.619
load View is something you implement;
it's not something you call.

00:55:18.619 --> 00:55:22.460
If you call loadView and the view's
already loaded, then you basically,

00:55:22.460 --> 00:55:25.960
you could potentially blow away a whole
bunch of state that's already there.

00:55:25.960 --> 00:55:28.909
So always use the view property.

00:55:28.909 --> 00:55:33.519
Similarly when you're drawing, if you have a custom
view, you subclassed UIView or something else,

00:55:33.519 --> 00:55:37.849
drawRect is a method that you would
implement to do your custom drawing.

00:55:37.849 --> 00:55:39.849
You would never want to call drawRect directly.

00:55:39.849 --> 00:55:41.380
I'll tell you why.

00:55:41.380 --> 00:55:45.329
Let's say you've got a delegate method, you've got
a delegate message that you received and you need

00:55:45.329 --> 00:55:48.509
to update a bunch of items in a specific view.

00:55:48.510 --> 00:55:52.800
If every one of those updates, let's say in the
same run loop iteration, you call drawRect 3 times.

00:55:52.800 --> 00:55:56.150
We will draw 3 times in that same iteration.

00:55:56.150 --> 00:56:01.670
The user probably won't even see the difference,
but we've executed 3 drawing operations.

00:56:01.670 --> 00:56:06.090
What you really want to do is call
setNeedsDisplay, which is effectively a dirty bit.

00:56:06.090 --> 00:56:08.550
It requests that the view redraw itself.

00:56:08.550 --> 00:56:13.200
So you can call setNeedsDisplay once, you can
call it 10 times, and basically what that means is

00:56:13.199 --> 00:56:19.059
in the next iteration of the run loop we will draw the
view once with all the new state that you may have set.

00:56:19.059 --> 00:56:24.059
So go ahead and look through, make sure you're
calling setNeedsDisplay everywhere you should be -

00:56:24.059 --> 00:56:25.289
same thing with layout.

00:56:25.289 --> 00:56:28.130
You want to call setNeedsLayout, not layoutSubviews.

00:56:28.130 --> 00:56:33.160
layoutSubviews is what you would implement,
setNeedsLayout is what you would call.

00:56:34.199 --> 00:56:38.879
So these are simple things that can help really boost
the frame rate of your application, so take a look

00:56:38.880 --> 00:56:44.539
and make sure you're not doing a lot
of unnecessary drawing or layout.

00:56:44.539 --> 00:56:49.869
And with these sort of best practices about
do's and don'ts, we come to compatibility.

00:56:49.869 --> 00:56:55.130
And we've seen a lot of compatibility
stuff as we transition to iPhone OS 3.0.

00:56:55.130 --> 00:57:00.079
It's been a big topic, you've seen it in email, you've
seen it on the Dev Center, seen it on the forums.

00:57:00.079 --> 00:57:04.009
There are a lot of things that you can do to
make sure that your app remains compatible,

00:57:04.010 --> 00:57:06.900
not just now but for the foreseeable future.

00:57:06.900 --> 00:57:11.000
And the first one of those is using class name prefixes.

00:57:11.000 --> 00:57:14.619
You've seen this in all of our APIs and all of
our frameworks, and a lot of you might be...

00:57:14.619 --> 00:57:18.920
a lot of people seem to think that
prefixes are just for APIs.

00:57:18.920 --> 00:57:21.400
Nobody's using my code, I don't need to add a prefix.

00:57:21.400 --> 00:57:22.559
But there's still a problem here.

00:57:22.559 --> 00:57:25.519
Namespace collisions are a fact...

00:57:25.519 --> 00:57:28.429
are a reality in any environment, any programming language.

00:57:28.429 --> 00:57:30.919
Objective-C and Cocoa Touch are no different.

00:57:30.920 --> 00:57:34.460
So let's say I have a session class
that's in my application.

00:57:34.460 --> 00:57:38.650
I'm using this third party framework that
also happens to have a class called Session.

00:57:38.650 --> 00:57:43.309
Once I build that, I load that binary and
there's all this code asking for session objects.

00:57:43.309 --> 00:57:46.860
The run time has no idea which
session object we're referring to.

00:57:46.860 --> 00:57:48.180
The fix to this is very easy.

00:57:48.179 --> 00:57:54.629
You just add a prefix to your class, and you've immediately
differentiated your session class from the other guys.

00:57:54.630 --> 00:57:56.140
This is a must.

00:57:56.139 --> 00:58:01.509
Anybody who's not doing this right now, especially
with a generic name like Session, go back home...

00:58:01.510 --> 00:58:05.570
and change your class names to have prefixes.

00:58:05.570 --> 00:58:11.000
Whether you intend to release the code
or not, this prefixing is very important.

00:58:11.000 --> 00:58:15.199
Same goes for method names, particularly
the use of underscores.

00:58:15.199 --> 00:58:21.869
Underscores are reserved by Apple for private method
names, and some of you may have seen sample code out there

00:58:21.869 --> 00:58:24.889
on websites or something that uses underscores.

00:58:24.889 --> 00:58:27.920
They think they're following convention;
you don't want to use underscores.

00:58:27.920 --> 00:58:29.190
I'll tell you why.

00:58:29.190 --> 00:58:36.260
Let's say you subclassed UITableViewCell, and happened
to have declared a method with an underbar prefix.

00:58:36.260 --> 00:58:43.970
You have no way of knowing whether or not UITableViewCell
itself has a method with the same underbar prefix.

00:58:43.969 --> 00:58:45.029
And so what happens now?

00:58:45.030 --> 00:58:51.130
Now we've got some internal UIKit code that calls this
underbar method, expecting that nobody's overwridden it.

00:58:51.130 --> 00:58:55.640
But instead of the UITableViewCell
method, it's going to call yours.

00:58:55.639 --> 00:59:00.369
And this is going to result in a whole bunch
of unpredictable and unexpected behavior.

00:59:00.369 --> 00:59:02.329
So stay away from underscores.

00:59:02.329 --> 00:59:06.480
And if any of this stuff is affecting you, if
you've forgotten to prefix your class names,

00:59:06.480 --> 00:59:10.860
if you're using underscores, got
a wonderful tool named Xcode.

00:59:10.860 --> 00:59:16.340
It's got refactoring support, so it should be
fairly easy for you to adapt to this guidance.

00:59:16.340 --> 00:59:19.680
But that's one of the things you want to go home
and take a look at for compatibility reasons,

00:59:19.679 --> 00:59:24.399
not just for 3.0, but for everything else down the road.

00:59:24.400 --> 00:59:28.869
And supporting new features in certain
situations is very easy as well.

00:59:28.869 --> 00:59:35.029
There are a lot of classes in 3.0 that have new
methods in them, and finding out if an existing class

00:59:35.030 --> 00:59:42.330
like UITableViewCell has that new method in the new version,
is very easy because of the dynamic run time of Objective-C,

00:59:42.329 --> 00:59:45.539
you could just ask the object if
it responds to a given selector.

00:59:45.539 --> 00:59:48.619
If it does, send it the message or perform the selector.

00:59:48.619 --> 00:59:51.579
If not, just proceed as you would have in previous versions.

00:59:51.579 --> 00:59:55.989
You don't need to do any kind of crazy pound
defines or version checking, or anything like that.

00:59:55.989 --> 01:00:01.969
Just ask the object what it's capable of doing

01:00:01.969 --> 01:00:03.959
We're just about out of time.

01:00:03.960 --> 01:00:09.039
For more information, Matt Drance is
our Application Frameworks Evangelist.

01:00:09.039 --> 01:00:14.199
We've got a lot of documentation that
talks about all of these principles,

01:00:14.199 --> 01:00:19.269
and I would really encourage you regardless of your
skill level, to really take another look because a lot

01:00:19.269 --> 01:00:21.340
of these documents are long and they're pretty specific.

01:00:21.340 --> 01:00:24.350
And you go over them multiple times
and you find something...

01:00:24.349 --> 01:00:26.779
that you may have missed the first time.

01:00:26.780 --> 01:00:31.910
So the iPhone Application Programming Guide talks
about all of these fundamentals, and it's a real gem.

01:00:31.909 --> 01:00:35.869
So please take the time to look at the guidance in there.

01:00:35.869 --> 01:00:40.619
The Memory Management Programming Guide for Cocoa talks
about all the stuff that Alex had mentioned earlier,

01:00:40.619 --> 01:00:47.859
and most importantly with 3.0 just around the corner, and
really it's basically here, go to the iPhone Dev Center

01:00:47.860 --> 01:00:50.780
and look at the iPhone OS 3.0 readiness checklist.

01:00:50.780 --> 01:00:55.269
Make sure you've got everything you need, everything's
lined up for those submissions so that your apps

01:00:55.269 --> 01:00:57.829
in the store will be ready for iPhone OS 3.0.
WEBVTT

00:00:12.800 --> 00:00:18.289
>> This is session 303, Core Animation
Techniques for iPhone and Mac.

00:00:18.289 --> 00:00:19.640
My name is John Harper.

00:00:19.640 --> 00:00:24.190
I'm one of the-- is this actually working?

00:00:24.190 --> 00:00:26.100
That's annoying.

00:00:26.100 --> 00:00:28.400
How do we do these things?

00:00:28.399 --> 00:00:28.739
[ Laughter ]

00:00:28.739 --> 00:00:30.250
>> This one.

00:00:30.250 --> 00:00:34.859
>> Oh, the Back button.

00:00:34.859 --> 00:00:38.339
OK. [Laughter] Right, I got it.

00:00:38.340 --> 00:00:39.130
OK. Sorry about that.

00:00:39.130 --> 00:00:41.150
So, my name is John Harper.

00:00:41.149 --> 00:00:43.390
I'm a member of the Quartz Engineering Team.

00:00:43.390 --> 00:00:46.850
I work on Core Animation most of the time.

00:00:46.850 --> 00:00:49.660
So we're going to talk about a number of things today.

00:00:49.659 --> 00:00:51.089
So let's see what they are.

00:00:51.090 --> 00:00:56.359
First of all, I'm going to talk a bit about the background
of Core Animation and why you'd want to use it, what it is,

00:00:56.359 --> 00:00:59.539
what can it do for you, that kind of thing.

00:00:59.539 --> 00:01:05.709
Then the bulk of the session is going to be about
different ways to use it, how to use little bits of code,

00:01:05.709 --> 00:01:07.919
just kind of practical things and tips hopefully.

00:01:07.920 --> 00:01:12.040
And then finally we'll wrap up with a
little bit about performance at the end.

00:01:12.040 --> 00:01:15.020
So let's get started.

00:01:15.019 --> 00:01:18.530
So, Core Animation is really a 2D compositing -framework.

00:01:18.530 --> 00:01:22.200
Despite the name of a-- it being
Core Animation, it's really,

00:01:22.200 --> 00:01:28.879
the bulk of it is layer compositing
and then animation of those layers.

00:01:28.879 --> 00:01:35.310
And layer compositing is really a very kind of well-used
and well-known technology where you have a bunch

00:01:35.310 --> 00:01:40.000
of graphic elements and you composite them together
somehow with a bunch of effects, and so you often see these

00:01:40.000 --> 00:01:46.719
in things like After Effects and Photoshop
Motion, all those kind of graphic design apps.

00:01:46.719 --> 00:01:52.849
And so when we came to look at how to design the next
generation user interface software, we really decided that,

00:01:52.849 --> 00:01:57.429
you know, we wanted to marry the kind of hardware
compositing of the, of course, desktop compositor with kind

00:01:57.430 --> 00:02:02.220
of a nice extra level of expressibility
of those kind of graphic apps.

00:02:02.219 --> 00:02:04.920
So, that's kind of what Core Animation is I guess.

00:02:04.920 --> 00:02:10.300
At least that's where it aims to be -- we
have some constraints that those don't.

00:02:10.300 --> 00:02:13.900
And so really the way it works out is that your user
interface, instead of just being a bunch of drawing commands

00:02:13.900 --> 00:02:18.480
and really now is a tree of layers, and the
layers can have drawing commands applied to them.

00:02:18.479 --> 00:02:23.159
Subsequent layers can have positions and
content and extra special effects and things.

00:02:23.159 --> 00:02:27.289
And then once we have a layer tree, it becomes very
natural that you know, we can now move things around

00:02:27.289 --> 00:02:31.659
and animate them because we have this
nice kind of declarative structure.

00:02:31.659 --> 00:02:35.930
So, first I just want to show you a kind of
a concrete example of what I'm talking about.

00:02:35.930 --> 00:02:38.460
So let's hope that switches.

00:02:38.460 --> 00:02:47.920
So, we have this little demo of something you've probably
seen before, which is the kind of iPhone lock screen.

00:02:47.919 --> 00:02:52.859
And obviously on the iPhone this is using Core
Animation composite, and this one is here as well.

00:02:52.860 --> 00:02:57.070
And you kind of see, you have this
kind of nice UI, a lot of graphics.

00:02:57.069 --> 00:02:59.609
And then when I start to kind of
bring out what the layers are,

00:02:59.610 --> 00:03:03.010
you can kind of see that this is really,
you know, not one element drawn at once.

00:03:03.009 --> 00:03:07.139
It's a lot of different pieces and then that kind
of composites together as layers, with you know,

00:03:07.139 --> 00:03:11.199
different bits of text over other text,
the 2 copies of the battery for reflection.

00:03:11.199 --> 00:03:12.239
A gradient to give you the rim.

00:03:12.240 --> 00:03:18.379
And then at the bottom, you can see that
there's this kind of slides on lock thing

00:03:18.379 --> 00:03:21.650
and it has this nice posing text animation.

00:03:21.650 --> 00:03:26.010
And so, the way that is configured is
really there are 2 layers there as well,

00:03:26.009 --> 00:03:28.069
and one of them is kind of a gradient, one of them is text.

00:03:28.069 --> 00:03:33.949
And then when we move, you know, we animate one on top
of the other and mass them together, we get back to the,

00:03:33.949 --> 00:03:37.009
you know, this animation you've probably seen before.

00:03:37.009 --> 00:03:43.209
And obviously, when you kind of re-- put it all back
together, we end up how we worked for the different layers.

00:03:43.210 --> 00:03:45.500
So that's really what I mean by layer compositing.

00:03:45.500 --> 00:03:53.060
And so that's, you know, that's what CA
is, it's a compositor and an animator.

00:03:53.060 --> 00:03:54.930
And so, where does it live in the system?

00:03:54.930 --> 00:03:58.030
So, you know, you've probably seen there's
something like this diagram before,

00:03:58.030 --> 00:04:03.330
but basically we have your applications sitting
on top of some kind of Cocoa UI framework,

00:04:03.330 --> 00:04:07.500
sitting on top of some more kind of hardware
specific graphics APIs and sound APIs.

00:04:07.500 --> 00:04:12.219
And then that sits on top of the hardware in Core
OS in the low level kind of systems.

00:04:12.219 --> 00:04:18.829
So that piece we're talking today obviously is the
Core Animation block which sits kind of, you know,

00:04:18.829 --> 00:04:24.689
below Cocoa below-- above the hardware, but often your
applications will need to call in to Core Animation directly

00:04:24.689 --> 00:04:30.139
to get the benefits when the UI
frameworks don't quite do what you need.

00:04:30.139 --> 00:04:33.120
And obviously, this is just one OS, we now have two.

00:04:33.120 --> 00:04:36.780
So we look at the iPhone version, this is very
similar and we basically have the same kind of stack

00:04:36.779 --> 00:04:39.889
which is pieces, kind of removed the other pieces added.

00:04:39.889 --> 00:04:45.279
But they're very, very similar, so
you can think of them in the same way.

00:04:45.279 --> 00:04:49.839
So as I kind of hinted, we believe that most
of the time, we should be able to get away

00:04:49.839 --> 00:04:54.219
without using Core Animation directly and that
kind of goes for lots of the graphic APIs.

00:04:54.220 --> 00:04:58.880
Really, we have all these kind of high level
frameworks and they're there for your benefit.

00:04:58.879 --> 00:05:02.620
You know, most of the time, you're dealing with UI
widgets and TableViews and those kinds of things,

00:05:02.620 --> 00:05:07.110
so there's no real point, you know, going down to the
low level APIs to try and reinvent all that stuff.

00:05:07.110 --> 00:05:11.040
It just doesn't really make good use of your time.

00:05:11.040 --> 00:05:16.370
And so the really nice thing about those frameworks
though is that they will be using Core Animation for you.

00:05:16.370 --> 00:05:20.240
So every time you create a view, you'll
create a layer as well implicitly.

00:05:20.240 --> 00:05:22.680
At least that's always true on the iPhone.

00:05:22.680 --> 00:05:26.689
I guess I should say you have to opt into that
mode on the Mac but it's pretty easy to do so.

00:05:26.689 --> 00:05:32.329
And then the great thing about that is that when you do
have layers behind all your views, then when you get--

00:05:32.329 --> 00:05:35.639
you run up against the limits of the UI
frameworks, you can really, you know, get--

00:05:35.639 --> 00:05:40.329
kind of drop down very cleanly into CALayer
and then start adding custom animations,

00:05:40.329 --> 00:05:44.599
custom kind of layer effects right
into your existing view tree.

00:05:44.600 --> 00:05:47.370
And I guess the one exception to this, these
kind of rules is when you really have a--

00:05:47.370 --> 00:05:51.579
an application that doesn't fit the standard UI paradigms.

00:05:51.579 --> 00:05:56.250
And if you had, think of something like Front Row on the
Mac where really it doesn't have a lot of standard buttons,

00:05:56.250 --> 00:06:00.209
you probably might want to consider just using
Core Animation as the entire composited UI.

00:06:00.209 --> 00:06:06.979
And that's kind of a gray area because if you think
about something like the iPhone coverflow implementation,

00:06:06.980 --> 00:06:12.700
obviously it's a very kind of semi-immersive type
UI in that you have these kind of album covers.

00:06:12.699 --> 00:06:16.000
But really, it's sitting inside the normal UIKit view tree.

00:06:16.000 --> 00:06:19.620
And even when you flip over the covers, you see
that we have the UIKit TableViews on the back.

00:06:19.620 --> 00:06:26.899
So you know the best use of these things is trying to marry
them together in the best possible way to their strengths.

00:06:26.899 --> 00:06:29.539
So hopefully that's enough about
why you should use this stuff.

00:06:29.540 --> 00:06:34.910
So now we're going to move on to how to use it I guess.

00:06:34.910 --> 00:06:37.980
And we're going to start off very,
very easily, very basically.

00:06:37.980 --> 00:06:41.700
So this idea here is we-- you know
every layer has some position in space,

00:06:41.699 --> 00:06:45.939
so we're going to start by creating
ourselves a layer object.

00:06:45.939 --> 00:06:49.490
Then we'll give it a rectangle and
we'll basically add it to a parent layer

00:06:49.490 --> 00:06:51.699
so that we have some way of being visible on the screen.

00:06:51.699 --> 00:06:57.589
So what you're seeing on the left here is the dotted
outline which represents where this layer would be.

00:06:57.589 --> 00:07:01.379
Obviously, we have not actually done a thing to give
it any content yet so we don't actually see anything.

00:07:01.379 --> 00:07:05.129
So, next thing we might want to
do is give it a background color.

00:07:05.129 --> 00:07:08.449
In this case, we're going to set it
to red and we're using the UIKit kind

00:07:08.449 --> 00:07:10.930
of color creation syntax just because it's shorter.

00:07:10.930 --> 00:07:14.250
But you can see, we just-- all we had
to do was set that property to be red

00:07:14.250 --> 00:07:18.439
and now we have the layer drawing
itself on screen as a red rectangle.

00:07:18.439 --> 00:07:24.110
Also, we could design an image and pretty much this
happens the same way with the same amount of code,

00:07:24.110 --> 00:07:26.730
and we're actually loading an image off disk here as well.

00:07:26.730 --> 00:07:32.590
And then, you know, we can start to get fancy and
just kind of do things like modify the corner radius

00:07:32.589 --> 00:07:38.229
so we have a round rect instead of a rect, or we could set
the opacity to 50 percent just to kind of fade it out a bit.

00:07:38.230 --> 00:07:41.060
And you kind of see that this is a--
basically, this is the bulk of our API.

00:07:41.060 --> 00:07:47.430
We have objects, you know, layers and animations and you set
properties on those objects and somewhere in the background,

00:07:47.430 --> 00:07:52.480
the compositor goes off and kind of updates
the screen to do what you asked it to.

00:07:52.480 --> 00:07:55.879
OK, so a little bit more deep now.

00:07:55.879 --> 00:08:00.319
You know that was providing an image which
we loaded off disk, but a lot of times,

00:08:00.319 --> 00:08:06.319
that's not good enough because your content obviously
mostly depends on the user behavior or, you know, whatever.

00:08:06.319 --> 00:08:08.430
Something is not predictable.

00:08:08.430 --> 00:08:12.350
So you really need to be able to draw
into the layers as well, and we--

00:08:12.350 --> 00:08:17.220
the basic way to do that is you have to give us a
method which will do your drawing into some CGContext.

00:08:17.220 --> 00:08:18.640
And so there's 2 ways of doing that.

00:08:18.639 --> 00:08:22.279
You can either provide a subclass of
the layer with a drawInContext method.

00:08:22.279 --> 00:08:26.719
This is kind of almost exactly the
same as the UIView drawRect method.

00:08:26.720 --> 00:08:30.400
Or what's often easier is to basically
just give the layer a delegate object

00:08:30.399 --> 00:08:32.769
and then implement the delegate version of the same method.

00:08:32.769 --> 00:08:39.350
Either way, it ends up kind of doing the same thing in that
you will have some method which can do your drawing for you.

00:08:39.350 --> 00:08:43.560
Now when you've given us that method, you
then need to tell the layer that it needs

00:08:43.559 --> 00:08:46.139
to redraw, which is the setNeedsDisplay method.

00:08:46.139 --> 00:08:50.870
And what happens then is that once you told the layer
I need to update and I have a way of doing that,

00:08:50.870 --> 00:08:56.039
then at some point before the layer is next put on screen,
next composited, we will call your method with some kind

00:08:56.039 --> 00:09:02.500
of rendering context in which you can you know, draw your
drawing commands such that they will end up on the screen

00:09:02.500 --> 00:09:05.279
at the right point, you know, as soon as possible.

00:09:05.279 --> 00:09:08.709
So let's talk a little about how to optimize this.

00:09:08.710 --> 00:09:11.800
So, you know, typically you draw the
first time you redraw the entire layer.

00:09:11.799 --> 00:09:16.819
Second time you draw, you may know that only this piece
changed, so I only really need to draw that rectangle.

00:09:16.820 --> 00:09:20.710
So obviously, that will be a good thing to
optimize is not redrawing the entire layer.

00:09:20.710 --> 00:09:26.180
So using the setNeedsDisplayInRect method instead
of setNeedsDisplay is just a way to say, you know,

00:09:26.179 --> 00:09:29.799
I know I need to redraw but I also
know which part of the screen.

00:09:29.799 --> 00:09:34.209
Now, we can take that a little further in that, you
know, now we know which rectangle we're drawing.

00:09:34.210 --> 00:09:39.860
When you get us to draw, you can also ask the
CGContext which rectangle are you letting me draw into,

00:09:39.860 --> 00:09:44.389
because obviously if you'd say I only want to
draw this region, then we will only let you do

00:09:44.389 --> 00:09:47.949
that because we don't want to let
you, you know, waste memory bandwidth.

00:09:47.950 --> 00:09:53.259
So that's a good thing if you have a lot of complex kind
of drawing state, you may have to be generating images

00:09:53.259 --> 00:09:58.159
to do your drawing, then you can kind of do your own calling
up front and say, well, I know that this region is not

00:09:58.159 --> 00:10:03.069
on the clip rect so therefore I don't have to generate
any of the state to update that part of the screen.

00:10:03.070 --> 00:10:08.480
And finally one of the things we keep harping
on about is that if you have opaque content,

00:10:08.480 --> 00:10:12.200
you really must tell the layer that
because we can't work it out for you.

00:10:12.200 --> 00:10:17.009
> And if you have an opaque content in the layer,
it really means a lot to us because we can,

00:10:17.009 --> 00:10:18.909
you know, avoid drawing everything beneath it.

00:10:18.909 --> 00:10:24.299
We can avoid compositing that object and
it makes the performance a lot better

00:10:24.299 --> 00:10:28.000
if you do that across the application.

00:10:28.000 --> 00:10:33.460
So, moving back to images, we're going
to hop around a bit, but back to images,

00:10:33.460 --> 00:10:38.820
we have this idea of often your UI
would draw kind of 3 or 9-part images.

00:10:38.820 --> 00:10:41.340
I hope probably some of you know what that means.

00:10:41.340 --> 00:10:44.009
And what that really is, is that
you know when you have an image,

00:10:44.009 --> 00:10:46.189
it represents some part of your
UI like a button or something.

00:10:46.190 --> 00:10:51.030
And then if you need to scale the button, you
would not want the image to scale uniformly,

00:10:51.029 --> 00:10:56.079
you want it to scale along linearly
with the edge gaps remaining static.

00:10:56.080 --> 00:11:00.790
And so, you know, you could do this in the
previous versions of CA by creating multiple layers

00:11:00.789 --> 00:11:06.149
or rendering the image using CG or you
can, I don't know, I guess that's about it.

00:11:06.149 --> 00:11:09.939
But-- but now, we have a way of doing this kind of
built-in to the framework and this works a lot better.

00:11:09.940 --> 00:11:15.580
So what you can do is if you look at the top image on
the left here, you can see we have this button artwork

00:11:15.580 --> 00:11:18.300
and we want to stretch it across
the layer as the bottom image looks.

00:11:18.299 --> 00:11:23.549
So what we're doing in the code example here is saying,
"OK, so I'm going to tell the framework that the center

00:11:23.549 --> 00:11:29.909
of this image which is the part we actually will scale
starts 20 percent from  left hand side and it extends

00:11:29.909 --> 00:11:33.209
for 60 percent on the width, which is this 2.2.6 thing.

00:11:33.210 --> 00:11:36.100
And obviously it's the full height of the image.

00:11:36.100 --> 00:11:40.420
And then when we actually scale and resize the layer,
what happens is, you know, we resize only the center part,

00:11:40.419 --> 00:11:44.620
and you preserve the kind of the look of the button artwork.

00:11:44.620 --> 00:11:48.899
And the reason that's really nice is because, obviously
now we know about this, we can animate it really well.

00:11:48.899 --> 00:11:54.909
We can, you know, stretch it as the layer is animating,
we don't ever get any cracks or seams or, you know,

00:11:54.909 --> 00:11:58.949
little artifacts, and it just works out a lot better.

00:11:58.950 --> 00:12:04.100
It's also higher performance than creating,
you know, 9 layers to represent the same thing.

00:12:04.100 --> 00:12:09.870
So finally, there is one other property we'll mention
briefly, which is you may also want to have, you know,

00:12:09.870 --> 00:12:13.990
one art work image and then put it in multiple layers
and reps and pull the different pieces out of it,

00:12:13.990 --> 00:12:19.620
'cause that's another way to gain efficiency, and the way
you can do that is by using this contentsRect property

00:12:19.620 --> 00:12:23.070
which you can find more about in the documentation.

00:12:23.070 --> 00:12:26.210
So, one more slide about images.

00:12:27.620 --> 00:12:33.600
So, in the past, large images have been kind of a problem
in that you know, that the GPU gives us some size limits.

00:12:33.600 --> 00:12:36.889
The images, your apps give us are large
and that we basically just drop them

00:12:36.889 --> 00:12:38.610
on the floor, which was kind of unfortunate.

00:12:38.610 --> 00:12:44.840
So what we're doing now in the next, the-- current releases
of both platforms is we'll actually do all that tidying work

00:12:44.840 --> 00:12:49.930
for you, so you can give us kind of 8K by 8K images if you
have enough memory, and the framework will basically deal

00:12:49.929 --> 00:12:52.399
with the little problems of drawing that to the screen.

00:12:52.399 --> 00:12:56.159
The caveat here is this clause
about if you have enough memory.

00:12:56.159 --> 00:12:59.579
And the problem obviously with 8K by 8K
images, they're an awful lot of memory.

00:12:59.580 --> 00:13:04.370
That's probably more memory than your iPhone
actually has, so it's not really going

00:13:04.370 --> 00:13:07.320
to work, except for you know, certain cases.

00:13:07.320 --> 00:13:13.240
So for very large images like this, we still
recommend that you use the TiledLayer mechanism.

00:13:13.240 --> 00:13:18.570
And the TiledLayer is really just another type of layer,
but instead of asking you to draw the entire thing at once,

00:13:18.570 --> 00:13:23.640
it would really ask you to draw in lots of little tiles
as they're needed, and that's great for memory usage

00:13:23.639 --> 00:13:25.789
because obviously if you're only
looking at part of the image on screen,

00:13:25.789 --> 00:13:28.399
we don't need to ask you for the pieces that are off screen.

00:13:28.399 --> 00:13:33.819
Similarly, we can do a lot of good stuff with
multiresolution data so that, you know, if we're--

00:13:33.820 --> 00:13:37.510
if your image is, you know, 8K by 8K again and it's scaled

00:13:37.509 --> 00:13:41.240
down so you're only seeing the screen
size, you know, so the entire thing fits.

00:13:41.240 --> 00:13:45.210
Then you could have a res-- a resolution
level which matches the screen size,

00:13:45.210 --> 00:13:47.220
then we could draw that a lot more efficiently.

00:13:47.220 --> 00:13:54.090
So that really means that we can ask you to provide
data at like 50 percent and 25 percent and% so on.

00:13:54.090 --> 00:13:58.670
And then finally, the one kind of thing you have
to be aware of here is that, you know, if you are--

00:13:58.669 --> 00:14:04.120
if you use the TiledLayers, your apps will look
different because the kind of tradeoff is that, you know,

00:14:04.120 --> 00:14:09.120
we ask you for the data after we know it's been
used, and it may take you a few bit of seconds

00:14:09.120 --> 00:14:14.029
to actually provide the data so there will be a brief kind
of pause as your apps provide the tiles and the tiles kind

00:14:14.029 --> 00:14:15.799
of fade on when they're-- as soon as they're provided.

00:14:15.799 --> 00:14:22.779
So one last performance step here is
that if you do have lots of large images,

00:14:22.779 --> 00:14:25.379
and we're talking really large,
and you want to display them.

00:14:25.379 --> 00:14:30.350
That's the problem-- you know, the bottleneck becomes
when you start using the TiledLayer, but you will be--

00:14:30.350 --> 00:14:33.940
still be decoding images out of
the JPEG compression or whatever.

00:14:33.940 --> 00:14:36.680
So the trick there is the-- if you
know you're going to be using tiles,

00:14:36.679 --> 00:14:41.299
then you should pre-tile your image files
into like 256 square tiles or something.

00:14:41.299 --> 00:14:48.370
Because that way, you can load them off disk really
fast and then everything will look-- work a lot better.

00:14:48.370 --> 00:14:50.210
OK, so enough about images.

00:14:50.210 --> 00:14:53.410
So, next piece of talk is really about animating.

00:14:53.409 --> 00:14:56.969
And so again we're going to start off kind of simple.

00:14:56.970 --> 00:15:03.149
And as you probably heard, most of the animations--
excuse me, you can do with Core Animation are implicit.

00:15:03.149 --> 00:15:06.529
And that really means that when
you change a property, by default,

00:15:06.529 --> 00:15:09.379
most of these properties will animate
in the background somehow.

00:15:09.379 --> 00:15:12.480
So in this case, we're going to change the
opacity and we're going to set it to 50 percent.

00:15:12.480 --> 00:15:16.220
And assuming that, you know, originally it was 100
percent, and then we're going to make-- get a--

00:15:16.220 --> 00:15:20.730
just automatically, we'll get an animation
to change the opacity of that object from 100

00:15:20.730 --> 00:15:24.610
to 50 percent over a quarter of a second.

00:15:24.610 --> 00:15:25.110
And that's great.

00:15:25.110 --> 00:15:28.759
I mean a lot of the time you can get a lot of mileage
out of just, you know, programming the properties

00:15:28.759 --> 00:15:31.289
of the layers and just watching things animate.

00:15:31.289 --> 00:15:34.599
But you often want to, you know, modify
those implicit animations somehow.

00:15:34.600 --> 00:15:40.200
So we give you a bunch of ways to do that basing
on this CATransaction kind of a thread object.

00:15:40.200 --> 00:15:45.379
And so first, you can just disable them entirely by,
you know, just calling the setDisableActions method.

00:15:45.379 --> 00:15:48.679
Then other things, you can do a lot of things
like change the duration of the animations.

00:15:48.679 --> 00:15:51.349
Like I said, the default is quarter second.

00:15:51.350 --> 00:15:57.050
Or you can also change the timing curve which is really
the ease function of the acceleration of the animation.

00:15:57.049 --> 00:15:58.459
Here, we're using one of the built-in curves,

00:15:58.460 --> 00:16:05.070
but you can also kind of define your own using
this kind of Bezier layer technique.

00:16:05.070 --> 00:16:09.560
So, that was a quick look at inputs of animation.

00:16:09.559 --> 00:16:12.329
So often, that-- that's great, but it
really would work for the state changes.

00:16:12.330 --> 00:16:16.550
So you know, if you're changing something-- a particular
property from X to Y, then that's-- that works.

00:16:16.549 --> 00:16:21.559
But if you just want some property to kind of animate
on the background, then there is no state changing,

00:16:21.559 --> 00:16:24.929
so implicit animations aren't really the right thing.

00:16:24.929 --> 00:16:28.750
So in these cases, you really want to use kind
of explicitly programming of the animation model.

00:16:28.750 --> 00:16:32.860
So here's an example of the people I
often run into, they want to have a--

00:16:32.860 --> 00:16:34.620
an image kind of flipping through a bunch of frames.

00:16:34.620 --> 00:16:37.820
For example a spinner animation or, you know whatever.

00:16:37.820 --> 00:16:40.030
So, this code block is basically doing that.

00:16:40.029 --> 00:16:44.259
We're going to create a bunch of images, upload them off
disk probably, and use, say N frames is the animation

00:16:44.259 --> 00:16:47.669
that would create a KeyframeAnimation
which is going to be the object

00:16:47.669 --> 00:16:50.279
which represents the spinner, so
that's what we're creating here.

00:16:50.279 --> 00:16:55.079
And obviously, since we are animating the images,
we need to say the key path to this animation,

00:16:55.080 --> 00:16:59.320
the thing the animation targets is
the contents property of the layer.

00:16:59.320 --> 00:17:02.320
That's, you know, as we saw in a previous
slide, that's where the image is stored.

00:17:02.320 --> 00:17:06.559
And so the timing, we're going to say the animation is
going to, you know, loop, last for a second then it's going

00:17:06.559 --> 00:17:09.970
to loop repeatedly by sending a
repeatCount to basically to infinity.

00:17:09.970 --> 00:17:15.360
And then the next-- kind of the line in between the
calculation mode, it's really only used in this case.

00:17:15.359 --> 00:17:20.669
And all that's saying is that, you know, because I have
this flip-book and I have a lot of frames and they're going

00:17:20.670 --> 00:17:26.289
to be spinning pretty quickly, I don't want to bother trying
to interpolate between images in the kind of the progress,

00:17:26.289 --> 00:17:28.500
I just want to pick whichever one
is closest and that's what kind

00:17:28.500 --> 00:17:32.170
of discrete interpolation means, it means no interpolation.

00:17:32.170 --> 00:17:35.910
And then finally we're going to, you know, we
have the images so we can now set them as an array

00:17:35.910 --> 00:17:39.180
on the animation just to provide the keyFrame values.

00:17:39.180 --> 00:17:44.650
So at this point, we have this animation object and it
basic-- exactly describes the spinner that we want to see,

00:17:44.650 --> 00:17:47.740
so the next thing then is we're
going to add it to the layer.

00:17:47.740 --> 00:17:51.130
We use some kind of keyPath mechanism here
just so we can remove it later if necessary.

00:17:51.130 --> 00:17:54.960
But once it's been added, then it will
just sit in the layer, spinning around,

00:17:54.960 --> 00:17:58.160
doing its thing, and just live there until you remove it.

00:17:58.160 --> 00:18:01.690
So that's, you know, it's more code than the implicit
animations, but you can see you get a lot of control here

00:18:01.690 --> 00:18:05.080
and you can really do whatever you want to some extent.

00:18:05.079 --> 00:18:08.210
So there are a bunch of other cases where
you may want to do things like this.

00:18:08.210 --> 00:18:13.190
One of the examples I could think of is if you-- if
you had a cursor flashing, you know a text cursor.

00:18:13.190 --> 00:18:16.769
Then one way you can do that is just by redrawing
every second, but a better way would probably be

00:18:16.769 --> 00:18:19.200
to have a layer and, you know, ramp the opacity at a--

00:18:19.200 --> 00:18:23.170
on a repeating loop, 'cause that way there
will be no kind of class drawing happening.

00:18:23.170 --> 00:18:28.789
And as I said, this is really just where
there is no natural state transition.

00:18:28.789 --> 00:18:32.009
So, another kind of animation,
the previous two slides, you know,

00:18:32.009 --> 00:18:35.230
implicit and explicit animations are both
really dealing with properties of the layers.

00:18:35.230 --> 00:18:40.730
And more explicitly, they're dealing with properties
that can be kind of numerically interpolated.

00:18:40.730 --> 00:18:45.920
So we have something like opacity or color even,
these little things that are represented as numbers

00:18:45.920 --> 00:18:49.640
and therefore we can interpolate,
you know, from 1 to 0 or whatever.

00:18:49.640 --> 00:18:54.970
But we also have properties that are, you know, nonnumeric
and therefore really-- not really interpolatable.

00:18:54.970 --> 00:19:01.039
So with these cases, we have something called the
CATransition class, and the transition is really kind

00:19:01.039 --> 00:19:05.819
of a catch-all animator which will take the previous state
of your layers and image into, you know, the current state

00:19:05.819 --> 00:19:08.929
and do some kind of image processing
effect to kind of blend the two together.

00:19:08.930 --> 00:19:14.500
So the default transition we use is a crossbreed
because that's, you know, the very basic one,

00:19:14.500 --> 00:19:16.339
but there are several other types as well.

00:19:16.339 --> 00:19:21.019
And if you're on the Mac and basically you use
Core Image to provide any kind of transition code

00:19:21.019 --> 00:19:26.539
to really be able to write your own
transitions to get some kind of nice effects.

00:19:26.539 --> 00:19:32.190
But again, these are things you might want to disable at
times and we're going to show you a different way of doing

00:19:32.190 --> 00:19:34.450
that here because often, you know, in some cases,

00:19:34.450 --> 00:19:38.420
you just want to disable an animation
for a particular instance of a property.

00:19:38.420 --> 00:19:43.140
But in other cases, you may want to say, "I never want
sublayers properties to cause an animation to happen

00:19:43.140 --> 00:19:47.140
because you know, it's-- it looks
too heavyweight or whatever."

00:19:47.140 --> 00:19:50.950
So you can also use the subclassing
delegation style coding here.

00:19:50.950 --> 00:19:56.120
And in this case, we're going to subclass a layer and just
add this actionForKey method and see if the keyword given

00:19:56.119 --> 00:20:01.739
which means, you know, this property has been changed
recently, then the animation we're going to return to kind

00:20:01.740 --> 00:20:05.299
of animate that state change is going to be
nil, which means no animation in this case.

00:20:05.299 --> 00:20:11.720
If it's anything else, we just delegate
the super layer-- superclass, sorry.

00:20:11.720 --> 00:20:14.420
OK, yeah.

00:20:14.420 --> 00:20:18.650
>> So another aspect of animations is
you often want to know when they're done.

00:20:18.650 --> 00:20:24.220
You know, you want to be at a-- trigger
another animation or do something

00:20:24.220 --> 00:20:27.190
to your layer tree or run some other code, whatever.

00:20:27.190 --> 00:20:31.130
And so if you have an explicit animation like the spinner
example we saw, then you can set a delegate property

00:20:31.130 --> 00:20:36.510
on the animation, and then your delegate will be
messaged whenever it starts or stops animating.

00:20:36.509 --> 00:20:42.710
But something we've added recently--
currently it's only available on Snow Leopard.

00:20:42.710 --> 00:20:45.910
It's a way to use kind of a block based
approach which in some ways can be a lot nicer.

00:20:45.910 --> 00:20:51.800
So what we're doing here in this example is we're creating
a transaction block which is CA's way of kind of wrapping

00:20:51.799 --> 00:20:55.379
up state changes just to make it--
so they don't leak out at all.

00:20:55.380 --> 00:21:00.770
And then we're going to set completion block property to a
block of code because we now have this nice new block syntax

00:21:00.769 --> 00:21:04.029
where we can reference code as closure type objects.

00:21:04.029 --> 00:21:10.009
So our block here is going to basically do this thing we'll
come back to in a minute, but so once we've set the block,

00:21:10.009 --> 00:21:16.960
we know that any animations we create in this
transaction, right, kind of bracketed statement will--

00:21:16.960 --> 00:21:19.970
the animations will trigger the block
to run as soon as they complete.

00:21:19.970 --> 00:21:25.100
So in this case, we're obviously doing some kind of
animate this layer, removing itself from the screen.

00:21:25.099 --> 00:21:28.899
So we're going to set its opacity to 0 and its
position to somewhere way off on the right.

00:21:28.900 --> 00:21:31.800
And what that will do obviously
is trigger implicit animations.

00:21:31.799 --> 00:21:36.909
And once we've committed them and the animations have
run, the code, this kind of engine will know that as soon

00:21:36.910 --> 00:21:40.000
as they've stopped, both of them have
stopped, then the block would run once.

00:21:40.000 --> 00:21:43.930
In this case we're going to say, OK let's just
remove that layer, now we know it's fully off screen.

00:21:43.930 --> 00:21:47.610
So the nice thing about this is, you know, it's a
lot cleaner in coding style because you don't have

00:21:47.609 --> 00:21:54.209
to have another object, you don't have to deal with a lot of
extra state and it just makes things a lot more localized.

00:21:55.960 --> 00:22:04.769
OK. So, another point about animations is that they
only really animate on the render side which means

00:22:04.769 --> 00:22:09.240
that the objects you see on which side
is what we call the client side objects.

00:22:09.240 --> 00:22:14.160
The Objective-C objects really don't reflect
animations that are happening at the current time.

00:22:14.160 --> 00:22:21.170
So for example if we had an opacity animation, animating
from 1 to 0.5, then if you query the opacity property

00:22:21.170 --> 00:22:25.509
at the layer, you will never see anything but 1 or 0.5,

00:22:25.509 --> 00:22:31.000
and that's because only the compositor is actually
evaluating these animations when it's drawing the scene.

00:22:31.000 --> 00:22:37.009
So we have a way to query these values though on
the Objective-C side, and the way you do that is

00:22:37.009 --> 00:22:42.309
to call the presentationLayer method on your
layer, and that will actually create another copy

00:22:42.309 --> 00:22:44.119
of your layer with all the kind of properties applied.

00:22:44.119 --> 00:22:48.599
And then any animations that are running on the
layer, at the current time will get evaluated

00:22:48.599 --> 00:22:51.609
and their value is also pushed into the copy of the layer.

00:22:51.609 --> 00:22:58.259
So that means that you can then query any properties on
the presentation layer and get back a good approximation

00:22:58.259 --> 00:23:00.549
of where the things actually are on screen.

00:23:00.549 --> 00:23:05.869
So you know, you can find out where is the object
which is animating from A to B or whatever.

00:23:05.869 --> 00:23:12.899
And so a couple of places we've found this to be very
useful, just to give you an idea why it is important.

00:23:12.900 --> 00:23:17.680
Firstly, you know when we create an animation, we
simply want to animate the thing from where it is

00:23:17.680 --> 00:23:22.680
to where it's going to be, which means we have
to look at the screen value of the property.

00:23:22.680 --> 00:23:27.009
You know, if the object is already animating, we don't
want to stop a new animation from where it used to be,

00:23:27.009 --> 00:23:30.440
we want to have exactly where it
is on screen at the current time.

00:23:30.440 --> 00:23:35.940
So obviously we would set the form value there, you know,
of the animation to that presentation layer property.

00:23:35.940 --> 00:23:44.650
And secondly, the presentation layer really forms a tree
because when you create a sublayer of a presentation layer,

00:23:44.650 --> 00:23:47.790
then you don't get back the regular layers,
you get back the presentation version side,

00:23:47.789 --> 00:23:49.839
the versions with all the animations applied.

00:23:49.839 --> 00:23:53.949
So this means we can do things like hit testing
across the tree as it exist on screen just

00:23:53.950 --> 00:23:59.569
by asking the presentation layer and asking it to hit test
on this point and then asking for the model layer back

00:23:59.569 --> 00:24:05.359
so we actually kind of know where
about in our object tree we ended up.

00:24:05.359 --> 00:24:11.389
The model layer just goes back from the presentation to
the original version, so this is kind of like the inverse.

00:24:11.390 --> 00:24:13.430
So this thing is very useful.

00:24:13.430 --> 00:24:17.970
OK, so here's another new thing for the current releases.

00:24:17.970 --> 00:24:23.769
We now give you a way to use our animation system
to animate your own properties in your own drawing.

00:24:23.769 --> 00:24:28.430
So we're going to run through a quick
example and hopefully explain it that way.

00:24:28.430 --> 00:24:34.370
So basically-- if you have a layer subclass you can
obviously define your own properties in the subclass.

00:24:34.369 --> 00:24:36.919
So here we're going to define this
lineWidth property which is just a float.

00:24:36.920 --> 00:24:39.850
And then in the implementation,
we're going to declare it dynamic

00:24:39.849 --> 00:24:42.269
so the Core Animation will implement
it, this is nothing new.

00:24:42.269 --> 00:24:45.750
And that really means that we don't have
to bother writing any accessor methods,

00:24:45.750 --> 00:24:47.130
everything will just get taken care of.

00:24:47.130 --> 00:24:52.330
And then the new part is that if we
marked the property as needing display

00:24:52.329 --> 00:24:58.109
by implementing this needsDisplayForKey method, then what
that is telling us is that the contents of the layer,

00:24:58.109 --> 00:25:03.639
the stuff you draw is now kind of dependent on the
lineWidth property because we now have this kind

00:25:03.640 --> 00:25:09.880
of dependence relationship, and so that really
means that it gives us the ability to say

00:25:09.880 --> 00:25:12.590
that when we see this lineWidth
property animating, we know now that we--

00:25:12.589 --> 00:25:16.230
that your layer has to redraw with
that effect taken into account,

00:25:16.230 --> 00:25:20.490
and so obviously your drawRect method will just
do the normal thing and query the property.

00:25:20.490 --> 00:25:25.730
So let's look at an example of this.

00:25:25.730 --> 00:25:31.049
This will be very quick.

00:25:31.049 --> 00:25:37.849
So, that's wrong but...I'm-- so
we have this Bezier layer class, and you could see we--

00:25:37.849 --> 00:25:41.559
we actually have the lineWidth property which is on
the slide but we also have a bunch of other properties.

00:25:41.559 --> 00:25:46.139
We have 4 points because we're going to draw a Bezier curve
and we need 4 control points, and we have a line width

00:25:46.140 --> 00:25:49.670
and a color so we're just going
to draw a line along the curves.

00:25:49.670 --> 00:25:51.440
So we look at the implementation file.

00:25:51.440 --> 00:25:58.789
We have the same kind of dynamic thing on the slide, and the
first thing we're going to do is we're going to create a set

00:25:58.789 --> 00:26:02.879
of our keys just so we can refer to
them more concisely in the future,

00:26:02.880 --> 00:26:05.320
and these are all the properties that we implement.

00:26:05.319 --> 00:26:07.089
Then we will implement some default values.

00:26:07.089 --> 00:26:10.459
This is all old stuff.

00:26:10.460 --> 00:26:13.759
The default value is just the way to provide
a kind of a default value for your class.

00:26:13.759 --> 00:26:17.049
You don't need to set them every
time you create an instance.

00:26:17.049 --> 00:26:22.279
Then we'll implement this needsDisplayForKey
method just using the Bezier keys set.

00:26:22.279 --> 00:26:26.619
We'll do this which is implementing
implicit animations for our class.

00:26:26.619 --> 00:26:31.769
This looks like a lot of code but it's
really not that bad.

00:26:31.769 --> 00:26:34.480
But what this is doing is you know every time one

00:26:34.480 --> 00:26:37.950
of these properties is changing, we
want to set up an implicit animation.

00:26:37.950 --> 00:26:42.340
And then finally, and the most interesting part is in
our draw method, we're not going to really do anything,

00:26:42.339 --> 00:26:48.319
particularly interesting, we're just going
to draw the spline with the parameters.

00:26:48.319 --> 00:26:57.000
So when we run this, I have a little controller app around
this class and you can see that we're drawing the spline,

00:26:57.000 --> 00:27:00.309
we have some extra handles which
were drawn using CA compositing.

00:27:00.309 --> 00:27:03.419
But the-- all this spline stuff is drawn using a CG drawing.

00:27:03.420 --> 00:27:09.050
And so the interesting thing now is when I click the
flip button, we can animate that in the background,

00:27:09.049 --> 00:27:14.629
this layer is being asked to draw as the animation runs
and it just kind of works like a regular CA animation.

00:27:14.630 --> 00:27:22.980
We can, you know, animate multiple things at once,
different speeds and it just kind of works naturally.

00:27:22.980 --> 00:27:24.299
So it's really what I wanted to show about that.

00:27:24.299 --> 00:27:25.019
Let's quit this.

00:27:25.019 --> 00:27:25.139
[Applause] OK.

00:27:25.140 --> 00:27:39.830
So that is kind of useful, but to get the best out of
it, you need to kind of know exactly, well not exactly

00:27:39.829 --> 00:27:43.669
but you know a few details about how
it works so you know what to expect.

00:27:43.670 --> 00:27:48.470
Obviously normally when we run animations,
we run them on a background thread.

00:27:48.470 --> 00:27:51.360
In this case because it's your code, we can't
really do that so we're running the animation

00:27:51.359 --> 00:27:55.349
on the main thread off the timer once we
see that the animations are happening.

00:27:55.349 --> 00:28:00.169
And again like the presentation layer the way we're
doing this is we-- before we draw into your layer,

00:28:00.170 --> 00:28:05.990
we basically create a copy of the layer, apply all the
animations for the time we think we should be drawing for

00:28:05.990 --> 00:28:11.490
and then call your draw method on the copy so that you know
when you get the animating values kind of already installed

00:28:11.490 --> 00:28:13.490
and you don't have to do anything special.

00:28:13.490 --> 00:28:19.660
So, you know, we can basically animate all the
existing types we can animate before, you know,

00:28:19.660 --> 00:28:22.240
numbers, rects, points, colors, et cetera.

00:28:22.240 --> 00:28:27.579
And as I said earlier, it only works on,
you know, formal property declarations.

00:28:27.579 --> 00:28:29.699
It doesn't work for KBC properties.

00:28:29.700 --> 00:28:36.809
And again, because we don't really know exactly when the
frame will-- frame sync will happen, we're trying to--

00:28:36.809 --> 00:28:38.609
we're basically guessing the animation times.

00:28:38.609 --> 00:28:43.829
And if it works out, well you saw in the example that
looked pretty smooth and the things tracked pretty nicely,

00:28:43.829 --> 00:28:52.179
but again this could be blocked by your main thread
for example so, you know, there are some caveats there.

00:28:52.180 --> 00:28:53.769
Anyway, so that's enough for animations.

00:28:53.769 --> 00:28:59.500
So one of the things we've added in the next release
is a bunch of new classes to draw different types

00:28:59.500 --> 00:29:03.819
of text content, and so we want to go over some
of those and some of the old classes as well.

00:29:03.819 --> 00:29:07.669
So, first of all, one of the things we added
is a way to draw your gradients natively.

00:29:07.670 --> 00:29:12.759
So before you would have to, you know, draw the gradient
into the CGContext, which obviously takes a lot of memory

00:29:12.759 --> 00:29:16.230
or create your own kind of gradient and ramp image somehow.

00:29:16.230 --> 00:29:22.039
And now we just have a gradient layer and you can set the
gradient access and the gradient color stuff and locations

00:29:22.039 --> 00:29:27.279
as we're doing in this code and, you know,
you end up with a gradient drawn in the layer.

00:29:27.279 --> 00:29:30.970
Obviously all these properties can be animated
so you can animate your colors, animate the--

00:29:30.970 --> 00:29:35.400
the kind of the axis of the gradient and
hopefully you should be able to see that, you know,

00:29:35.400 --> 00:29:40.110
the orange numbers on the right correspond
to the orange numbers on the left.

00:29:40.109 --> 00:29:43.579
We have this, you know, black,
blue, white gradient going on here.

00:29:43.579 --> 00:29:49.449
Right now we only support axial gradients, but it
is still -kind of a nice usual feature especially

00:29:49.450 --> 00:29:53.049
if you want something like a full screen
gradient background because you really don't want

00:29:53.049 --> 00:29:59.169
to burn the image off the entire screen just to
draw a gradient, so it's pretty short and sweet.

00:29:59.170 --> 00:30:02.350
One of the things we've had to do from
the start is a way to draw a text,

00:30:02.349 --> 00:30:05.519
but it's only on the Mac unfortunately right now.

00:30:05.519 --> 00:30:10.420
And so if you want to draw a simple string, this
probably isn't useful for a very complex text use

00:30:10.420 --> 00:30:13.630
but for just drawing labels, it's pretty useful.

00:30:13.630 --> 00:30:19.220
>> So you can create a text layer, give it a string and
a font, and a font size, and any of its other properties.

00:30:19.220 --> 00:30:23.620
You know, the string can actually be NSString or
NSAttributedString, you can have various font types.

00:30:23.619 --> 00:30:28.239
Then you can do things like change the justification
or the centering or the wrapping or the--

00:30:28.240 --> 00:30:33.250
and you basically get end up with the string drawn in
the layer using Core Text in the regular Mac text APIs.

00:30:33.250 --> 00:30:40.220
One of the new things about this in the current
release is that you can now animate the properties.

00:30:40.220 --> 00:30:43.650
So for example I could animate the font size from 36 to 12.

00:30:43.650 --> 00:30:45.540
And the way that works is basically using the same kind

00:30:45.539 --> 00:30:48.509
of client-side drawing mechanism we were
just talking about a couple of slides ago.

00:30:48.509 --> 00:30:53.509
So let's take a look at this in a little more detail.

00:30:53.509 --> 00:30:58.879
One of the things people often want to do with
the text layer is somehow modify the way it draws.

00:30:58.880 --> 00:31:04.580
And so if you realize that the text layer is really just
another layer with the sub-- with a drawing context method,

00:31:04.579 --> 00:31:07.960
then you can really work out how to subclass this thing.

00:31:07.960 --> 00:31:11.620
So we're just going to create a very basic
subclass here just to illustrate this.

00:31:11.619 --> 00:31:15.469
So well you create a layer called MyTextLayer
and then we're going to implement a single method

00:31:15.470 --> 00:31:19.730
which is just the draw method and then we're
really just racking the superclass here.

00:31:19.730 --> 00:31:22.710
So but then we can start to add
things before we call the super--

00:31:22.710 --> 00:31:28.870
and obviously anything we do the CGContext will be
reflected in the text of the superLayer drawers.

00:31:28.869 --> 00:31:33.449
So one of the things people often run into is
that LCD text is not enabled for this layer.

00:31:33.450 --> 00:31:36.180
And the reason that is really because
it's drawing into a transparent bitmap

00:31:36.180 --> 00:31:38.920
and LCD text does not work in those cases.

00:31:38.920 --> 00:31:46.170
So the thing you have to do here if you want to get real LCD
text is have a solid background color then fill a rectangle

00:31:46.170 --> 00:31:49.960
of it into your layer, so the first few lines,
and then just tell the Core Graphics, you know,

00:31:49.960 --> 00:31:56.549
I want font smoothing which is what we
call LCD text rendering for some reason.

00:31:56.549 --> 00:32:00.339
And then again, we call super and then super now has
the context setup with those, with the right property

00:32:00.339 --> 00:32:02.730
such that we will get text-- LCD text rendering.

00:32:02.730 --> 00:32:08.769
And if you can see the difference, you can see the color
fringes rather than the grayscale fringes on the text.

00:32:08.769 --> 00:32:13.819
So, one final thing which is often useful is CG
also support shadows in everything it renders.

00:32:13.819 --> 00:32:20.339
So if you want to have shadow text, I don't know if you can
even see it, yeah, maybe, the way you just turn CG shadowing

00:32:20.339 --> 00:32:23.720
and then when the super draws the text,
that gets the nice shadow underneath it.

00:32:23.720 --> 00:32:30.890
And this is by far the most performed way to draw
shadow text on the platform, on the layer anyway.

00:32:30.890 --> 00:32:33.670
OK. So enough with the text.

00:32:33.670 --> 00:32:41.730
So the next thing or the next class we want to look
at is a way to draw Bezier Paths, Bezier splines.

00:32:41.730 --> 00:32:46.089
And so these are basically just some
examples of what we're talking about.

00:32:46.089 --> 00:32:48.189
Really these are kind of the line based vector art

00:32:48.190 --> 00:32:53.690
where we have basically solid colors
and fills and stroke lines and things.

00:32:53.690 --> 00:32:58.870
And so you kind of see that all these things
are basically defined by a path, a line.

00:32:58.869 --> 00:33:04.309
And the path is really made up of bunch of
segments, you know, Bezier spline stuff.

00:33:04.309 --> 00:33:06.190
And Core Graphics has a lot of built-in support for this.

00:33:06.190 --> 00:33:07.110
You can create paths.

00:33:07.109 --> 00:33:07.809
You can render them.

00:33:07.809 --> 00:33:11.909
But until this point, Core Animation
has really not dealt with them too much.

00:33:11.910 --> 00:33:16.570
Obviously one of the really nice features about rendering
paths rather than images is that you can scale them in

00:33:16.569 --> 00:33:22.980
and out and they stay perfectly crisp because you know
the image information is described geometrically rather

00:33:22.980 --> 00:33:26.269
than as a raster image.

00:33:26.269 --> 00:33:32.670
So we now have this thing called the shape layer and
let's look at the little example of that, excuse me.

00:33:32.670 --> 00:33:34.930
So in this case we're going to draw an ellipse.

00:33:34.930 --> 00:33:39.130
So we will create a rectangle, create
a path, add the ellipse to the path

00:33:39.130 --> 00:33:41.700
and now we have a CGPath which represents the ellipse shape.

00:33:41.700 --> 00:33:44.420
So once we have the path, we can create a shape layer.

00:33:44.420 --> 00:33:48.390
The shape layer will then have its path
property set to the path we created

00:33:48.390 --> 00:33:50.820
and then we will tell it how to draw that path.

00:33:50.819 --> 00:33:58.789
So in this case we want a white stroked line around the
perimeter of the path and we want it to be10 pixels wide,

00:33:58.789 --> 00:34:01.859
and we also want the path to be filled red.

00:34:01.859 --> 00:34:03.039
So that's what those 3 lines do.

00:34:03.039 --> 00:34:07.220
And finally we'll release the path because
obviously we don't want to leak any memory.

00:34:07.220 --> 00:34:11.500
And you can see we've set up this path and now we're going
to be-- set up the flare rather, and it will just draw

00:34:11.500 --> 00:34:18.139
and we can scale it in and out, and hopefully the
anti-aliasing will stay crisp and everything like that.

00:34:18.139 --> 00:34:20.559
OK. So we can have a number of possible uses for this.

00:34:20.559 --> 00:34:21.900
We're just going to touch on a few of them.

00:34:21.900 --> 00:34:27.579
For example if you had something like a drawing app or
charting app you could use this for arrows and various bits

00:34:27.579 --> 00:34:32.750
of vector art that you can animate around
the screen and composite pretty fast.

00:34:32.750 --> 00:34:35.579
You can also do things like the marching
ants selection effect you often see.

00:34:35.579 --> 00:34:40.679
You have 2 shape layers, the one on the top give them
both the same path and then make one of them dashed,

00:34:40.679 --> 00:34:45.409
and then you obviously see because you can animate these
shape layer properties, you can then animate the dash phase

00:34:45.409 --> 00:34:49.170
and the kind of the ants will move
around the perimeter of the path.

00:34:49.170 --> 00:34:55.670
You can also use this to draw text because, you
know, most fonts describe their glyphs as splines.

00:34:55.670 --> 00:34:59.680
And this is really, you know, it's kind of a judgment
call whether you'd use this version of drawing text

00:34:59.679 --> 00:35:06.529
or the other version because obviously if you have lots,
you know, a thousand glyphs on the page then using a layer

00:35:06.530 --> 00:35:08.160
for each one of them is going to get kind of heavy weight.

00:35:08.159 --> 00:35:12.559
But if you have just have a few glyphs, you want
to be able to animate them around, flip them in 3D,

00:35:12.559 --> 00:35:17.539
then this kind of drawing might work a lot better because,
you know, they will be rasterized at the right resolution.

00:35:17.539 --> 00:35:23.190
And one key tip for you is that if you are going to do
this, then really you should try to reuse the path objects

00:35:23.190 --> 00:35:28.119
because now that will allow us to do some level
of caching if the path objects are reused.

00:35:28.119 --> 00:35:31.089
For example if you have two eglyphs from the same font,

00:35:31.090 --> 00:35:35.550
don't create the path twice, just
create it once and use two layers.

00:35:35.550 --> 00:35:40.470
And obviously there are a couple of other
uses which you can probably work out.

00:35:40.469 --> 00:35:46.049
So one interesting point is you know given that we have
this support for rendering paths then can we animate them

00:35:46.050 --> 00:35:48.870
because obviously animation is one of the things we also do.

00:35:48.869 --> 00:35:55.309
And the answer is yes, but morphing paths or
morphing shapes is kind of a hard problem,

00:35:55.309 --> 00:35:58.460
so we really only handle a couple of cases well.

00:35:58.460 --> 00:36:00.690
And you really need to know about this.

00:36:00.690 --> 00:36:05.559
So the case is basically, you know, the 2 paths we're trying
to blend together, must have the same number of subpaths.

00:36:05.559 --> 00:36:08.380
And each subpath must have the same number of points.

00:36:08.380 --> 00:36:12.570
If that is true we can basically do a pretty good job
of, you know, blending the control points together

00:36:12.570 --> 00:36:18.050
and making sure the curves stay continuous and
making it look pretty decent in most cases.

00:36:18.050 --> 00:36:21.240
The other case of course is where the path structure
differs, then we really don't have any way to kind

00:36:21.239 --> 00:36:28.269
of register the correlation between the two paths, so we
basically do something, but it often looks kind of weird.

00:36:28.269 --> 00:36:32.059
Because of this, you know, we don't let the
path property implicitly animate this thing,

00:36:32.059 --> 00:36:37.980
you have to basically enable this animation explicitly
because you know it may or may not do the right thing.

00:36:37.980 --> 00:36:39.829
So let's see an example of this.

00:36:39.829 --> 00:36:46.289
So here we have this kind of mouth glyph and you can kind
of see it has 2 states and in the second state, you know,

00:36:46.289 --> 00:36:49.289
the control points have been basically pulled out a bit.

00:36:49.289 --> 00:36:53.340
But I hope that you can realize from the graphic that,
you know, there really is no change of structure here,

00:36:53.340 --> 00:37:00.309
it's really just kind of pulling the points around
and changing the angles of the control splines.

00:37:00.309 --> 00:37:06.619
Some-- something that doesn't work, if you imagine changing
to animating between 2 glyphs, then you can kind of see the,

00:37:06.619 --> 00:37:12.369
because the A and the B have no real correlation,
then, you know, something happens, but, you know,

00:37:12.369 --> 00:37:17.119
some of you may like it, but I don't know.

00:37:17.119 --> 00:37:24.920
So anyway, so lets-- we're going to show a demo of
this a little later, but let's keep moving for now.

00:37:24.920 --> 00:37:29.099
So there are few other content layer types
which we're not going to cover in any detail

00:37:29.099 --> 00:37:31.619
but just kind of let you know what they are.

00:37:31.619 --> 00:37:35.029
So obviously we deal with OpenGL content pretty well.

00:37:35.030 --> 00:37:39.400
We have on the Mac there's an OpenGLLayer
and on the iPhone, there's kind an EAGLLayer

00:37:39.400 --> 00:37:43.280
because the EAGL is the iPhone OpenGL system layer.

00:37:43.280 --> 00:37:49.000
And so these kind of do the same thing in that they
both let you put OpenGL content into your layer tree

00:37:49.000 --> 00:37:52.860
but they are pretty different in the way they
do that, so it's worth touching on that briefly.

00:37:52.860 --> 00:37:59.140
So basically, the OpenGL on the Mac is really designed
for using kind of OpenGL in a UI kind of setting,

00:37:59.139 --> 00:38:01.489
so we try to tie it into the regular layer drawing model.

00:38:01.489 --> 00:38:07.439
And that means that SetNeedsDisplay
works as normal, and yeah.

00:38:07.440 --> 00:38:12.070
On the EAGLLayer, sorry, on the iPhone
rather, the EAGLLayer is really just trying

00:38:12.070 --> 00:38:15.000
to be the most lightweight way possible
to get OpenGL content to the screen

00:38:15.000 --> 00:38:18.510
because we really thought the most
common use of that would be for gaming.

00:38:18.510 --> 00:38:23.500
So it really has a different model where you basically
have the standard OpenGL kind of draw and swap model,

00:38:23.500 --> 00:38:27.179
rather than getting any of this Objective-C stuff involved.

00:38:27.179 --> 00:38:32.309
Also on the Mac, we have ways to provide
QuickTime content into your layer tree.

00:38:32.309 --> 00:38:37.230
So you can use the QTMovieLayer to display
movies, that's kind of what QuickTime player uses.

00:38:37.230 --> 00:38:40.710
You can also use the CaptureLayer to display camera content.

00:38:40.710 --> 00:38:46.019
And then finally, if you have Quartz Composer
compositions, you can create a QCCompositionLayer

00:38:46.019 --> 00:38:48.809
and give it the composition and put that in your layer tree.

00:38:48.809 --> 00:38:52.250
This works out kind of nice because you know
Quartz Composer is a great way to create kind

00:38:52.250 --> 00:38:56.190
of free-flowing graphic elements, and while
the CA is more for structured compositing.

00:38:56.190 --> 00:39:02.639
So you can kind of create the more free-flowing ones in
QC, expose a bunch of their properties into the top level

00:39:02.639 --> 00:39:07.329
and then when you put the Quartz Composer composition
into the layer, you can then animate those properties

00:39:07.329 --> 00:39:10.730
in the Quartz Composer patch, I think they call it,

00:39:10.730 --> 00:39:17.090
and everything kind of works nicely
when the 2 systems play together.

00:39:17.090 --> 00:39:19.320
OK, so enough of that content.

00:39:19.320 --> 00:39:21.100
Let's look at some other features of CA.

00:39:21.099 --> 00:39:27.339
Well, these things we're going to be talking right now
are really not, you know, they're not individual layers

00:39:27.340 --> 00:39:32.910
or individual ways of drawing things, they're
really ways to affect all different types of layers.

00:39:32.909 --> 00:39:34.659
So, again.

00:39:34.659 --> 00:39:37.369
OK. So firstly we want to talk about masking.

00:39:37.369 --> 00:39:43.549
And so we have this example here
of a pink logo of Rye green grass.

00:39:43.550 --> 00:39:48.050
And you can see initially we've started off
with the foreground element just posited

00:39:48.050 --> 00:39:49.460
over the background elements as a sublayer.

00:39:49.460 --> 00:39:53.860
But what we can do is we can say, "OK, that's great,
but we really want the masking operation here".

00:39:53.860 --> 00:39:57.570
So we're going to say instead of doing a
sublayer, it'd be a mask for the background.

00:39:57.570 --> 00:39:59.510
And when we do that, you get a different effect.

00:39:59.510 --> 00:40:06.010
We get the basically the background is masked through
the alpha channel of the foreground element of the ball.

00:40:06.010 --> 00:40:09.700
And so then, that's kind of nice.

00:40:09.699 --> 00:40:13.259
It works pretty orthogonally every layer can have a mask.

00:40:13.260 --> 00:40:16.530
>> All mask layers act basically like any
other sublayer the geometry is the same.

00:40:16.530 --> 00:40:17.010
They can animate.

00:40:17.010 --> 00:40:19.830
They can have movies in them whenever you want.

00:40:19.829 --> 00:40:25.519
And the mask really takes the 2 versions of the
backdrop, you know, the initial background of this stuff

00:40:25.519 --> 00:40:28.110
with the layer composer and just kind
of masks them together through the mask.

00:40:28.110 --> 00:40:31.010
But, well, we'll talk a little bit more about that later.

00:40:31.010 --> 00:40:36.470
But one key point here is that, you know, this mask
operation is a more kind of complex compositing operation

00:40:36.469 --> 00:40:39.649
than just compositing the source over the destination.

00:40:39.650 --> 00:40:43.940
And so it does often cost more in
terms of GPU required performance.

00:40:43.940 --> 00:40:48.240
So, I mean, you might be able to get away with doing
this a few times but if you have a thousand layers

00:40:48.239 --> 00:40:52.899
with a thousand masks, you probably will get bogged down.

00:40:52.900 --> 00:40:56.710
But, luckily, we can often get around
these limitations just by knowing our data.

00:40:56.710 --> 00:41:02.320
So in this case, or in the previous case, we know that
the background is black and so that means we can kind

00:41:02.320 --> 00:41:06.340
of create a cheating masking operation
by saying instead of masking,

00:41:06.340 --> 00:41:08.370
we just kind of composite the inverse
of the mask over the top.

00:41:08.369 --> 00:41:15.359
So, obviously, the reason we need to know the color is
because we need to multiply the color into the inverse

00:41:15.360 --> 00:41:20.740
of the mask here and that's this foreground layer, and
then just kind of composite that over the background.

00:41:20.739 --> 00:41:25.750
Because we're just using over compositing,
this works a lot more quickly.

00:41:25.750 --> 00:41:30.429
And so if you look at the iPhone UI they have
a lot of instances of where this is used,

00:41:30.429 --> 00:41:34.679
it's a key trick that's been developed there--
well, I'm sure it wasn't developed there but.

00:41:34.679 --> 00:41:40.819
So, obviously, one case where this is very common
is you often want to have the scroller where the top

00:41:40.820 --> 00:41:44.620
and bottom edges aren't kind of a sharp clip
but they're actually kind of a feathered edge.

00:41:44.619 --> 00:41:47.630
And so, obviously, you can do that with a mask there.

00:41:47.630 --> 00:41:52.210
But if you know the background, you can really just
put 2 gradient layers at the top and blend from opaque

00:41:52.210 --> 00:41:57.369
to non-opaque and that will be again a lot faster.

00:41:57.369 --> 00:42:04.420
So another Mac only feature is, obviously, we have Core
Image on the Mac, so we can provide a list of filters

00:42:04.420 --> 00:42:08.309
to any layer and then the contents of the
layer will be put through those filters

00:42:08.309 --> 00:42:11.369
when it's rendered, when it's composited.

00:42:11.369 --> 00:42:15.469
So in this case we're going to create a single CIFilter
called the Bloom Filter which is just kind of a glow effect.

00:42:15.469 --> 00:42:19.089
We're going to tell it, you know, give me
your default values and then we're going

00:42:19.090 --> 00:42:20.579
to give it a name which we'll come to in a bit.

00:42:20.579 --> 00:42:23.590
But then once you created a filter,
we will just set the filter as one

00:42:23.590 --> 00:42:26.630
of the layer's filter objects in the filter's array.

00:42:26.630 --> 00:42:29.579
And now every time the layer updates,
it will be put through the filters.

00:42:29.579 --> 00:42:36.319
And, obviously, you can write your own CIFilters and
define your own image processing effects this way.

00:42:36.320 --> 00:42:40.440
So the reason why you name the filter though is because
now we have a name, we have a key path because we can refer

00:42:40.440 --> 00:42:45.360
to this filter as, you know, filters.something.input
something which means, you know,

00:42:45.360 --> 00:42:48.550
now we have a way of actually referencing
all the inputs of those filters.

00:42:48.550 --> 00:42:53.760
And since we can reference them, we can now set them
through the regular layer set by these key path mechanisms.

00:42:53.760 --> 00:42:58.280
And the reason we want to do that is
because, firstly, it means that layer knows

00:42:58.280 --> 00:43:00.330
that the filter changed and, therefore,
it will update correctly.

00:43:00.329 --> 00:43:05.269
But secondly, it means we can also get the benefits
of the implicit animations here because, you know,

00:43:05.269 --> 00:43:09.199
the properties are being set by the layer and,
therefore, can create the right animations.

00:43:09.199 --> 00:43:13.899
And, obviously, we can animate these explicitly
as well because we now have the key path.

00:43:13.900 --> 00:43:19.670
But again, any of these kind of complex rendering
methods are expensive so if you know they're both,

00:43:19.670 --> 00:43:25.599
the content and the filter are static, you know, are
not changing, then you may be able to just, you know,

00:43:25.599 --> 00:43:29.929
render everything into the CGContext at
once and have the filter applied once rather

00:43:29.929 --> 00:43:35.579
than every time the screen updates which,
obviously, is going to be a lot cheaper.

00:43:35.579 --> 00:43:42.469
So another type of compositing
effect are background filters.

00:43:42.469 --> 00:43:50.529
So just in the same way we can filter the foreground, either
the content of the layer, we can also filter the background,

00:43:50.530 --> 00:43:52.150
and that's kind of what we're going
to be talking about here.

00:43:52.150 --> 00:43:57.720
But, you know, firstly, we set off
with the same composited 2 image graph.

00:43:57.719 --> 00:43:58.959
And this time we will do something different.

00:43:58.960 --> 00:44:03.300
We're going to create a crystallized filter
which is a kind of a brown ray effect type thing.

00:44:03.300 --> 00:44:07.240
And then we're going to set the filter's defaults
again, but this time we're going to add it as one

00:44:07.239 --> 00:44:09.969
of the background filters of the
layer not the foreground filters.

00:44:09.969 --> 00:44:13.599
And so when we do that, you can see that everything
under the layer with the filter everything

00:44:13.599 --> 00:44:18.059
under the pink thing has now been filtered and crystallized.

00:44:18.059 --> 00:44:26.259
We can also set the compositing filter which is a way
to give us other blend modes so CI provides a bunch

00:44:26.260 --> 00:44:28.030
of different blend modes most of these standard ones.

00:44:28.030 --> 00:44:30.510
So in this case, we're going to
choose the hard light filter.

00:44:30.510 --> 00:44:33.810
And then when we apply that, we
get a different compositing effect.

00:44:33.809 --> 00:44:37.840
So now you can see that we're replacing the
source of the compositing by something custom.

00:44:37.840 --> 00:44:41.890
And again, we could rewrite right around the filters here.

00:44:41.889 --> 00:44:46.809
But one final point is that, you know, these things
also interact with the mask as we saw earlier.

00:44:46.809 --> 00:44:48.400
So if we apply mask.

00:44:48.400 --> 00:44:51.630
In this case we're going to take
another copy of the Core Image--

00:44:51.630 --> 00:44:55.630
sorry, the Core Animation logo layer and
basically use its alpha channel as the mask

00:44:55.630 --> 00:44:58.980
because that would basically match
what we already have on screen.

00:44:58.980 --> 00:45:03.139
So when we apply that, you can see that
now we're restricting the filtering

00:45:03.139 --> 00:45:05.609
and compositing operations within the mask.

00:45:05.610 --> 00:45:13.500
So you can use this for a bunch of
effects like blurring of the objects.

00:45:13.500 --> 00:45:16.719
It works pretty usefully.

00:45:16.719 --> 00:45:18.599
OK, enough about filters.

00:45:18.599 --> 00:45:27.190
Let's look a little bit to the-- I forgot a drink of water.

00:45:27.190 --> 00:45:31.570
OK, so, obviously, as you probably
heard what we talked about,

00:45:31.570 --> 00:45:35.019
CA is really not just a 2D framework, it's kind of 2-1/2D.

00:45:35.019 --> 00:45:37.780
And what we mean by that is we have
lots of 2D elements but they really live

00:45:37.780 --> 00:45:43.050
in a 3D space so, you know, somewhere between 2 and 3D.

00:45:43.050 --> 00:45:46.539
So the way you deal with this is
you can control the Z access.

00:45:46.539 --> 00:45:48.670
And so in this example we have 2 layers, A and B.

00:45:48.670 --> 00:45:52.950
We're going to set the zPositions to be
negative 100 and plus 100, so obviously,

00:45:52.949 --> 00:45:55.199
one is further back and one is further forward.

00:45:55.199 --> 00:46:00.629
And so the obvious question here is why
do these things not look in perspective?

00:46:00.630 --> 00:46:03.599
'Cause we assume that they're the same size and they are.

00:46:03.599 --> 00:46:08.949
The answer is because we haven't set up any
way to project the objects into a superlayer.

00:46:08.949 --> 00:46:15.859
And so the way CA works is that every step in the graph of
the tree of element is always a 2D compositing operation.

00:46:15.860 --> 00:46:21.120
So basically, every parent looks at the sublayers
and it somehow projects them into its plane,

00:46:21.119 --> 00:46:24.509
it's kind of postcard in space if you like.

00:46:24.510 --> 00:46:28.710
So what we can do here is we can say basically set
up some kind of projection for shortening matrix.

00:46:28.710 --> 00:46:35.059
So we created a transform, the matrix, and then we're
going to set the Z component on the perspective column

00:46:35.059 --> 00:46:39.449
to be minus 1 over EYE_Z, and this is
just a kind of trick you have to learn.

00:46:39.449 --> 00:46:45.029
But EYE_Z really means is the distance from the,
kind of the eye point to the projection plane.

00:46:45.030 --> 00:46:49.110
So if you make that bigger, you get lesser
perspective effects and make it shorter

00:46:49.110 --> 00:46:51.470
that you get these very weird kinds of fisheye things.

00:46:51.469 --> 00:46:55.089
And when we apply that to the layer,
then you can see that the sub--

00:46:55.090 --> 00:46:58.160
sorry, when we apply that to the superlayer
of these objects, then, obviously,

00:46:58.159 --> 00:47:04.149
that projection matrix is now being used to
project the two sublayers into the parent

00:47:04.150 --> 00:47:08.139
and giving you the correct foreshortening
that you probably would have expected.

00:47:08.139 --> 00:47:14.279
And so really what this is doing it's-- if any of you
know OpenGL this is really trying to mimic the OpenGL kind

00:47:14.280 --> 00:47:18.560
of projection matrix which is the
way of defining the viewing system.

00:47:18.559 --> 00:47:22.759
And so similarly again, we can also
start adding more kind of camera effects.

00:47:22.760 --> 00:47:27.650
So if we want to rotate a viewpoint on the load
or basically move the camera position away,

00:47:27.650 --> 00:47:31.389
we can have this kind of rotation
translation portions of the matrix.

00:47:31.389 --> 00:47:35.599
And then when we apply that, we
get, you know, another kind of wall.

00:47:35.599 --> 00:47:43.329
So really this is kind of an analogous to a camera in most
3D systems but it's just expressed a little differently

00:47:43.329 --> 00:47:49.610
because it fits better with our 2D model, 2-1/2D model.sty-l7

00:47:49.610 --> 00:47:55.200
So one other part about 2-1/2D is,
as I said, everything gets flattened.

00:47:55.199 --> 00:48:02.079
So if you think about how you define a cube, then
your cube would probably be 6 layers, 6 square layers,

00:48:02.079 --> 00:48:05.170
oriented around with different
rotations so they map to a cube.

00:48:05.170 --> 00:48:08.519
And then probably what you want to do then
is going to rotate the cube as a whole.

00:48:08.519 --> 00:48:14.679
But, unfortunately, you can't because, as I said,
everything gets flattened so there's no way to put a kind

00:48:14.679 --> 00:48:18.960
of a common matrix through those things
if you have more than one of them.

00:48:18.960 --> 00:48:24.710
So what we've done here is we've added basically
a way to create 3D layer groups, I guess.

00:48:24.710 --> 00:48:27.150
And so that's what this transform layer class does.

00:48:27.150 --> 00:48:33.550
And it's really acts pretty similarly to a regular layer
but except that only really its geometry is considered.

00:48:33.550 --> 00:48:41.340
And explicitly, its geometry is used to basically construct
the matrix in a normal way and then add that to the,

00:48:41.340 --> 00:48:46.700
its sublayers, and then the sublayers basically
are just rendered as they were any other sublayer

00:48:46.699 --> 00:48:49.719
of the transform layer's parent, not its parent.

00:48:49.719 --> 00:48:54.849
And so it's basically a way of kind of collapsing
the graph but inserting new matrixes so you can--

00:48:54.849 --> 00:49:00.699
so back to our cube example, if you create a cube
as 6 layers as children of the transform layer,

00:49:00.699 --> 00:49:04.739
you can then attach the transform layer into
some other layer of defining your 3D spacesty=lW

00:49:04.739 --> 00:49:08.989
and then rotate the transform layer and all the
sublayers will rotate correctly because, you know,

00:49:08.989 --> 00:49:11.729
the transform layer is really not a flattening operator.

00:49:11.730 --> 00:49:17.250
But, you know, because they are the special
type of thing with no 2D space of their own,

00:49:17.250 --> 00:49:20.710
we really can't have an image, any
color, any filters because, you know,

00:49:20.710 --> 00:49:23.820
they never render, they have no real space in our 2D model.

00:49:23.820 --> 00:49:25.740
They're just the construct.

00:49:27.010 --> 00:49:33.860
So, the final point I want to talk
about 2-1/2D, obviously, we don't--

00:49:33.860 --> 00:49:37.800
we have to deal somehow with layers that intersect.

00:49:37.800 --> 00:49:44.480
And so you're going to obviously see the example here of
2 layers A and B which are split down the middle because,

00:49:44.480 --> 00:49:48.050
you know, part of A is in front of
B and part of B is in front of A.

00:49:48.050 --> 00:49:51.690
And so, traditionally with 3D, you would
render this with a depth filter and, obviously,

00:49:51.690 --> 00:49:54.079
we can't do that because we have
to deal with that 2D model again.

00:49:54.079 --> 00:49:58.250
It's, you know, opacity and filters
and all these kind of download things.

00:49:58.250 --> 00:50:02.559
And so what we end up having to do here is basically
take these 2 elements and somehow arrange it

00:50:02.559 --> 00:50:06.599
so that standard painter's model in a
back to front rendering will just work.

00:50:06.599 --> 00:50:12.650
And so, you know, what we could have done here is basically
cut B into 2 pieces and then render the back half of B,

00:50:12.650 --> 00:50:16.559
and then all of A and then the
front-half of it-- of B again.

00:50:16.559 --> 00:50:21.460
>> And the reason you need to know this is because you
need to understand that if you set up things like this,

00:50:21.460 --> 00:50:25.530
it really does causes a bunch of extra
of work, so your apps will run slower.

00:50:25.530 --> 00:50:29.050
And so if it all possible you should
avoid doing these kind of things.

00:50:29.050 --> 00:50:33.660
For example if my A layer here had a
filter applied and the filter is expensive,

00:50:33.659 --> 00:50:38.529
then now if we split A into 2 pieces then we may end
up rendering the filter twice and the frames just once

00:50:38.530 --> 00:50:41.790
and you kind of see we have lots of these and
things intersecting them we may end up with lots

00:50:41.789 --> 00:50:44.869
and lots of little cut fragments rather than just one.

00:50:44.869 --> 00:50:50.829
One other important point here is that
depth sorting is kind of a simple--

00:50:50.829 --> 00:50:54.090
has a fairly simple view of the world of the layers.

00:50:54.090 --> 00:50:59.160
And so, it really assumes that if the layers
it steps only have sublayers then it assumes

00:50:59.159 --> 00:51:02.799
that those layers live entirely within
the bounds of the layers being sorted.

00:51:02.800 --> 00:51:04.930
So I'll give you an example of what I mean.

00:51:04.929 --> 00:51:09.469
If these things actually look like this, A and
B were the sublayers of the red and blue layers,

00:51:09.469 --> 00:51:14.699
then at this point the depth sorter is not going to
see that these things actually extend past the bounds

00:51:14.699 --> 00:51:17.509
and we may end up with an incorrect result.

00:51:17.510 --> 00:51:22.630
See you just have to be aware of this because you
know it may cause issues and really the only work--

00:51:22.630 --> 00:51:26.730
the only way to avoid this problem
is either clip to the layer bounds

00:51:26.730 --> 00:51:31.139
or just don't create this kind
of geometry in the first place.

00:51:31.139 --> 00:51:38.539
OK, so, let's talk briefly about drop shadows
'cause they're a fairly important kind of UI effect.

00:51:38.539 --> 00:51:41.539
So you really have 3 ways at least
on the Mac to draw in drop shadows

00:51:41.539 --> 00:51:45.309
and these obviously are 2D drop shadows not 3D shadows.

00:51:45.309 --> 00:51:48.630
So first, you can just ask the layer to draw its
shadow for you, at least if you're on the Mac

00:51:48.630 --> 00:51:51.980
and that works pretty well it can shadow basically anything.

00:51:51.980 --> 00:51:56.469
It'll, you know, you can shadow a movie with an
alpha channel but because of this generality,

00:51:56.469 --> 00:52:01.239
it really can be expensive again because it has
to assume that the layer is changing every frame

00:52:01.239 --> 00:52:03.689
that for every frame we'll take the
alpha channel of whatever you rendered

00:52:03.690 --> 00:52:07.110
and blur it and use that to create a shadow.

00:52:07.110 --> 00:52:11.519
So if it's at all possible, then it's
good to try and avoid using this.

00:52:11.519 --> 00:52:16.309
So one way you can do that is as we saw with the
text you can just draw the shadow using Core Graphics

00:52:16.309 --> 00:52:22.049
and then the shadow will be cached along with the
object and you can just composite it very cheaply.

00:52:22.050 --> 00:52:25.880
The other way you can kind of figure out doing this
sometimes if you know the geometry of your layer,

00:52:25.880 --> 00:52:31.360
for example, you have an opaque rectangle, then you can also
often just create another layer which represents a shadow

00:52:31.360 --> 00:52:36.450
and often you can do that very cheaply for example
if you have a Gaussian blob image like a little kind

00:52:36.449 --> 00:52:43.399
of round thing, but you can stretch that across to match
the layer bounds by using the 9-part image we have now

00:52:43.400 --> 00:52:46.630
so then you end up with one layer which
represents the shadow of the other layer.

00:52:46.630 --> 00:52:51.250
And again, it's much cheaper to
composite because everything is static.

00:52:51.250 --> 00:52:53.110
So it's really all I want to talk about shadow.

00:52:53.110 --> 00:52:57.430
So another common UI effect are reflections.

00:52:57.429 --> 00:53:00.389
It's kind of like shadows.

00:53:00.389 --> 00:53:05.389
But in the past the way we've had of doing reflections
is basically you got to do everything yourself

00:53:05.389 --> 00:53:09.589
and that really means that you have to take
everything you want to reflect, create a copy of it,

00:53:09.590 --> 00:53:14.329
flip it upside down somehow, and add some kind
of darkening effect either gradient or whatever.

00:53:14.329 --> 00:53:20.389
And obviously that's kind of a pain because, you know,
if the things you're copying and moving or animating,

00:53:20.389 --> 00:53:25.469
you also have to copy the motion, you
have to apply the animations to both sets.

00:53:25.469 --> 00:53:28.669
So now we're trying to give you a
way to do that a lot more easily.

00:53:28.670 --> 00:53:31.460
So we have now something called the ReplicatorLayer.

00:53:31.460 --> 00:53:38.289
The ReplicatorLayer is a little more useful from
this but let's just talk about this one instance.

00:53:38.289 --> 00:53:42.409
So really the ReplicatorLayer is
a way of replicating sublayers.

00:53:42.409 --> 00:53:47.199
So in this case we're going to create a ReplicatorLayer,
we're going to set the sublayers of the replicator

00:53:47.199 --> 00:53:48.730
to be these-- whatever we want to reflect.

00:53:48.730 --> 00:53:53.400
In this example here we have another image
logo and a bunch of shape layers for our text,

00:53:53.400 --> 00:53:58.119
and then we're going to say I want 2 instances
of the stuff I put in that ReplicatorLayer.

00:53:58.119 --> 00:54:03.750
So there should be one, one instance for the normal
version and one instance for the reflected version.

00:54:03.750 --> 00:54:08.010
And the next thing we're going to do is
we're going to say to our replicator OK.

00:54:08.010 --> 00:54:11.700
Every instance you create will be transformed somehow.

00:54:11.699 --> 00:54:13.879
So the matrix we construct is pretty simple.

00:54:13.880 --> 00:54:19.090
We're going to flip the Y-axis just to reflect it
upside down and then we're going to offset on Y as well.

00:54:19.090 --> 00:54:25.710
This H minus 2ry is basically saying height of the element
minus twice the reflection frame gives us basically

00:54:25.710 --> 00:54:27.480
transform-- lining these things up correctly.

00:54:27.480 --> 00:54:30.119
Well that's pretty easy trial and error.

00:54:30.119 --> 00:54:33.739
And then when we set the instanceTransform on
the ReplicatorLayer, basically what happens is

00:54:33.739 --> 00:54:39.209
that every replicated instance of the layer
will have that transform concatenated into it.

00:54:39.210 --> 00:54:45.420
So in this case we just have one instance so it gives us
the thing we want which is the upside down reflection.

00:54:45.420 --> 00:54:48.860
And then finally we want to darken the things so as well

00:54:48.860 --> 00:54:52.740
as having a geometric transform the
replicator also provides a color transform.

00:54:52.739 --> 00:54:56.729
And in this case we know that the--
every instance is multiplied

00:54:56.730 --> 00:55:00.789
by white minus some offset which adds up all the instances.

00:55:00.789 --> 00:55:09.230
So basically what we're going to do is set the instance RGB
offsets to be minus 3/4 just so that when we subtract 3/4

00:55:09.230 --> 00:55:14.250
from 1 for our first replicated instance, we
end with a color which is 25 percent black

00:55:14.250 --> 00:55:18.380
which is the other thing we want
to multiply the reflection by.

00:55:18.380 --> 00:55:22.809
So that when that all goes and runs,
we basically get this nice reflection.

00:55:22.809 --> 00:55:28.070
And obviously the good thing about this is because
all this replication happens at render composite time,

00:55:28.070 --> 00:55:34.920
then you can reflect movies and particles and, you know,
basically anything in the tree and all the animations will,

00:55:34.920 --> 00:55:39.909
excuse me replicate as well and
things will just work as you'd expect.

00:55:39.909 --> 00:55:49.449
OK. So finally and again this is on the Mac only right now,
we also added a way to do particle effects which, you know,

00:55:49.449 --> 00:55:55.659
is kind of finally here because it's not always the
most useful thing but kind of looks nice sometimes.

00:55:55.659 --> 00:56:01.379
But the particle system is basically a
way to emit images and then have them kind

00:56:01.380 --> 00:56:03.450
of composite together and kind of animate.

00:56:03.449 --> 00:56:10.239
And so the emission glare really just has an
emission shape and then a ray of emitter cells.

00:56:10.239 --> 00:56:15.199
And each cell then defines how this
particles are emitted over time.

00:56:15.199 --> 00:56:17.909
So the cell have things like an image which was drawn.

00:56:17.909 --> 00:56:18.739
They have colors.

00:56:18.739 --> 00:56:21.500
They have, you know, direction vectors.

00:56:21.500 --> 00:56:24.510
Velocity acceleration, these kind of properties.

00:56:24.510 --> 00:56:27.510
And one interesting thing is that
cells can also have subcells.

00:56:27.510 --> 00:56:31.700
So what that means is you can have particle,
that your particle system can emit particles

00:56:31.699 --> 00:56:33.659
and then these particles can also emit particles.

00:56:33.659 --> 00:56:42.639
So you can kind of create this very nice,
fairly organic looking effects sometimes.

00:56:42.639 --> 00:56:47.429
So and, yeah, that's all I want to say about
particle system, so then we'll have a demo.

00:56:47.429 --> 00:56:55.909
So any ways, so that's been a lot of talking,
so let's look at couple of demos, so.

00:56:55.909 --> 00:57:00.839
OK. I'll show you this one.

00:57:00.840 --> 00:57:04.990
So first thing I want to show is
an example of the shape rendering.

00:57:04.989 --> 00:57:08.619
So you can see here we have a bunch of different,
well, you can't see but I'm going to tell you.

00:57:08.619 --> 00:57:11.199
We have a bunch of different shape layers one per glyph.

00:57:11.199 --> 00:57:15.699
And then, you know, rendering these paths in real time.

00:57:15.699 --> 00:57:23.119
And so I-- the great thing is because this is shape layer
rather than text, we can zoom this thing and you can see

00:57:23.119 --> 00:57:26.889
that we're not doing anything other than
setting the scale transform on the layer and

00:57:26.889 --> 00:57:31.319
yet the rendering stays pretty nice
and crisp, and fairly reactive as well.

00:57:31.320 --> 00:57:36.680
So, you know, we can animate this thing
and it kind of does what we would expect.

00:57:36.679 --> 00:57:43.919
We can also do a different font obviously so I can change
from Helvetica to Times which is slightly more ornate

00:57:43.920 --> 00:57:50.320
and you can see that the renderer is still doing
a pretty decent job of rasterizing the glyphs.

00:57:50.320 --> 00:57:56.710
And then with just with one last thing we can
use a pretty more, a way more complex font.

00:57:56.710 --> 00:58:03.039
Well you can see here that again, as you can see, we're
basically have the same thing going on but the thing

00:58:03.039 --> 00:58:05.480
to note is that you know these
glyphs are really, really complex.

00:58:05.480 --> 00:58:07.699
There are lots and lots of path segments.

00:58:07.699 --> 00:58:14.500
So this is just a really a demonstration that,
you know, this is working fairly efficiently.

00:58:14.500 --> 00:58:24.219
So OK, so that's about all of that.

00:58:24.219 --> 00:58:28.679
So the other demo I have is a particle system effect.

00:58:28.679 --> 00:58:31.869
And so this is actually combining
a bunch of different pieces

00:58:31.869 --> 00:58:35.719
of the things I've been talking about,
so obviously we have some particles.

00:58:35.719 --> 00:58:40.739
We have this kind of text write on effect where we have the
particle emission shaping animated along the row

00:58:40.739 --> 00:58:42.709
of the text.

00:58:42.710 --> 00:58:48.409
We also have a mass glare which is a shape where we're
animating the shape to basically reveal the text,

00:58:48.409 --> 00:58:53.329
and kind of link those to animations up so you can see
the text, appearing as the particles move over them.

00:58:53.329 --> 00:58:58.799
In the background obviously we have a gradient
layer just to give us this kind of horizon effect.

00:58:58.800 --> 00:59:06.660
And then of course at the end we have some 3D CI effects
where we basically ramp the Z position of the text

00:59:06.659 --> 00:59:12.949
and then add a zoom blur just to give us something
else, some kind of fake motion blur effect.

00:59:12.949 --> 00:59:18.009
OK. So that's basically done.

00:59:18.010 --> 00:59:22.510
[ Pause ]

00:59:22.510 --> 00:59:30.680
[ Applause ]

00:59:30.679 --> 00:59:36.299
>> OK, so that's basically the end of techniques now,
so we just kind of have a few slides on performance,

00:59:36.300 --> 00:59:41.620
just to give you a few ideas of what you
should do and what you really shouldn't do.

00:59:41.619 --> 00:59:47.599
So firstly, this really applies more to the Mac that the
iPhone because we have more ways to do this on the Mac.

00:59:47.599 --> 00:59:51.339
But first thing you should try to do is avoid
as much offscreen rendering as possible.

00:59:51.340 --> 00:59:55.900
And what I mean by that is, you know, this kind of complex
compositing effects where you can't just take an image

00:59:55.900 --> 00:59:58.180
and render it into the drawing destination we have.

00:59:58.179 --> 01:00:03.679
You have to do something more complex like apply
a bunch of filters, apply shadowing apply masks.

01:00:03.679 --> 01:00:07.899
All these things involve kind of extra passes
to the GPU and that's the kind of thing

01:00:07.900 --> 01:00:11.440
that if you do it enough times will
start to kill your performance.

01:00:11.440 --> 01:00:18.470
>> And I guess one of the most common cases where
you would run into this probably without realizing is

01:00:18.469 --> 01:00:24.750
if you have a layer with a bunch of sublayers, a bunch of
images and then you change the opacity of that layer then

01:00:24.750 --> 01:00:29.829
to get the correct mathematical result you really have
to you know render everything in that group off screen

01:00:29.829 --> 01:00:33.880
and apply it-- and then apply opacity as
a single object when we render it back

01:00:33.880 --> 01:00:39.450
on screen, so that can be a good source of this.

01:00:39.449 --> 01:00:43.969
So the next rule is as we mentioned earlier we're going

01:00:43.969 --> 01:00:47.750
to mention multiple times is really
try to minimize the amount of blending.

01:00:47.750 --> 01:00:52.349
This again is not so important on the
Mac although it is still an issue.

01:00:52.349 --> 01:01:00.400
But really on the iPhone we have limited graphics bandwidth
for blending so if you want your application to run close

01:01:00.400 --> 01:01:06.829
to the right frame rate which consists of 60 frames a
second then you need to minimize the amount of opaque--

01:01:06.829 --> 01:01:09.949
sorry, not opaque, of translucent data that you have.

01:01:09.949 --> 01:01:14.939
And so as I said earlier, one way to do this is just
to make sure the layer knows that it's opaque if it is.

01:01:14.940 --> 01:01:21.150
And you know sometimes the layers aren't opaque because they
can't be opaque but you know I mentioned if you have a tree

01:01:21.150 --> 01:01:25.389
of views and you know these things are composing
together so they probably have alpha channels,

01:01:25.389 --> 01:01:30.949
and so they can't be marked opaque because
then you get the wrong compositing result.

01:01:30.949 --> 01:01:36.309
And so one thing you can consider then if your frame rate
still isn't fast enough is you can basically reduce this

01:01:36.309 --> 01:01:41.909
tree of views into a single view which you
render as one using Core Graphics or Quartz.

01:01:41.909 --> 01:01:47.730
The nice thing about that is that then you can do your
compositing once into this bitmap which then gets cached

01:01:47.730 --> 01:01:49.480
and composited as an opaque object hopefully.

01:01:49.480 --> 01:01:56.230
So that means it's just all removing things
we have to do at composite frame rate.

01:01:56.230 --> 01:02:00.590
Again if you have, if you know, there's
an easy way to do this for layers

01:02:00.590 --> 01:02:02.890
but if you have images, it's a little more subtle.

01:02:02.889 --> 01:02:07.819
You need to make sure that the ImageRef, the
CGImage object doesn't have an alpha channel.

01:02:07.820 --> 01:02:13.330
So you can either make sure the image file you load
to create that image doesn't have an alpha channel.

01:02:13.329 --> 01:02:18.750
For example, you could try using a JPEG instead of PNG
if that's acceptable, or if you create the image directly

01:02:18.750 --> 01:02:27.579
from memory then you have to, you can just mark it opaque
by using one of these CGImage alpha types correctly.

01:02:27.579 --> 01:02:29.139
And we do have ways for you to debug this.

01:02:29.139 --> 01:02:34.549
On a Mac you can set the environment variable
CA_COLOR_OPAQUE and that will give you a hint

01:02:34.550 --> 01:02:39.800
and we'll see it in a second, but on the iPhone you
can't really set environment variables but you can turn

01:02:39.800 --> 01:02:42.789
on the same option via Instruments and get the same effect.

01:02:42.789 --> 01:02:48.329
So if we look at that you can see this Instruments
option and when we turn that on, what we see is that all

01:02:48.329 --> 01:02:55.159
of our layers are either tinted red or green and so
green means that the content was opaque which is good

01:02:55.159 --> 01:02:57.980
because we don't have to draw what's underneath it.

01:02:57.980 --> 01:03:03.199
And the red is really the tip that there's something
going on here because red is non-opaque, translucent.

01:03:03.199 --> 01:03:08.939
So anything that's red was drawn over whatever
was behind it which means you use more kind

01:03:08.940 --> 01:03:12.190
of rendering level, rendering passes to do that.

01:03:12.190 --> 01:03:15.740
So the key here is try and remove the red regions.

01:03:15.739 --> 01:03:19.619
OK. So that's basically about it.

01:03:19.619 --> 01:03:26.429
So I guess the things to take away from this are that
firstly you don't need to use Core Animation directly.

01:03:26.429 --> 01:03:30.669
Every time you use UIKit or AppKit, if you
turn on the right option you get the benefits

01:03:30.670 --> 01:03:34.079
of the CA hardware compositing, for free basically.

01:03:34.079 --> 01:03:36.579
So that's kind of great.

01:03:36.579 --> 01:03:41.400
And obviously then when you do need to
go through the levels because you know

01:03:41.400 --> 01:03:44.860
if you can't quite get the effect
you need to just jump in to CA then.

01:03:44.860 --> 01:03:49.700
And then finally again, can't say this enough
times, really try to minimize the amount

01:03:49.699 --> 01:03:51.509
of translucency you have in iPhone applications.

01:03:51.510 --> 01:03:57.060
It's really the-- It is the key
thing to get a good frame rate.

01:03:57.059 --> 01:03:59.820
And so basically that's it.

01:03:59.820 --> 01:04:08.570
We'll be in the graphics lab this afternoon, I think
12 'til I don't know, midnight or 1 or 6 or something.

01:04:08.570 --> 01:04:15.340
And Allan is our evangelist, so you can email him with
issues or you can find us on these mail lists, typically.
WEBVTT

00:00:13.019 --> 00:00:15.009
>> Howdy. I'm Daniel Delwood.

00:00:15.009 --> 00:00:17.280
And I'm a Performance Tools Engineer.

00:00:17.280 --> 00:00:21.240
And I'm here to tell you about iPhone
Performance Optimization with Instruments.

00:00:21.239 --> 00:00:24.570
So first of all, why are we here?

00:00:24.570 --> 00:00:28.730
Well, performance is so critical on the iPhone.

00:00:28.730 --> 00:00:33.759
It's such a versatile device, whether you're a
seasoned iPhone developer and you have many apps

00:00:33.759 --> 00:00:36.839
in the app store already, or you're just
starting out with iPhone development.

00:00:36.840 --> 00:00:43.580
Performance is critical from day one for developing a great
app with a little bit more limited resource than a Mac.

00:00:43.579 --> 00:00:51.960
So today we're going to cover the tools and teach you how to
be both proactive from day one in analyzing your application

00:00:51.960 --> 00:00:59.960
and incorporating this into your workflow, and reactive
when problems arise in the field your user support things.

00:00:59.960 --> 00:01:06.070
How do you use instruments to identify and
solve those iPhone app performance problems?

00:01:06.069 --> 00:01:09.839
So we're going to cover this in really three sections.

00:01:09.840 --> 00:01:13.100
First of all, we're going to cover
the Simulator versus device.

00:01:13.099 --> 00:01:17.429
And what are the differences, which do
you use each for performance analysis?

00:01:17.430 --> 00:01:22.750
And we'll go on to talk about instrumentation
for common iPhone issues

00:01:22.750 --> 00:01:25.269
and show you some demos of actually using these instruments.

00:01:25.269 --> 00:01:32.049
And finally, we're going to talk about reacting to
crashes and hangs and other problems that can be caused

00:01:32.049 --> 00:01:39.549
by performance issues and how will
it affect you on the iPhone.

00:01:39.549 --> 00:01:45.129
So first of all, the Simulator versus device,
what's the difference, and why do you care?

00:01:45.129 --> 00:01:47.390
Well, the Simulator is an API simulation.

00:01:47.390 --> 00:01:50.489
It's not instruction for instruction emulation.

00:01:50.489 --> 00:01:56.959
And this means that it really behaves like an
iPhone because you're calling the same APIs,

00:01:56.959 --> 00:02:02.549
you're allocating the same memory,
and the screen is the same size.

00:02:02.549 --> 00:02:07.140
I mean, the idea is to emulate, or--
sorry, to simulate the experience.

00:02:07.140 --> 00:02:10.460
However, it has the performance characteristics of your Mac.

00:02:10.460 --> 00:02:14.969
It has your Mac's cores, your Mac's network
card, and even your Mac's graphics card.

00:02:14.969 --> 00:02:19.509
And so there are definitely differences there.

00:02:19.509 --> 00:02:26.289
The run time environment of this Simulator is much
like the actual device, in that apps get installed,

00:02:26.289 --> 00:02:30.419
and they launch and quit in the same way.

00:02:30.419 --> 00:02:34.879
So when should you use a Simulator?

00:02:34.879 --> 00:02:39.590
Well, for many of the memory usage patterns in
your application, nothing is going to change.

00:02:39.590 --> 00:02:43.170
You're going to allocate objects, you're
going to deallocate them at the same points.

00:02:43.169 --> 00:02:49.869
And you can really use the Simulator to great effect
for memory analysis because you can just launch

00:02:49.870 --> 00:02:53.300
from Xcode, make a change, quickly rebuild and go.

00:02:53.300 --> 00:02:57.900
In the same way, file access is a
great characteristic to measure.

00:02:57.900 --> 00:03:00.180
But like I said, it's definitely too fast.

00:03:00.180 --> 00:03:02.310
It's much faster than an iPhone.

00:03:02.310 --> 00:03:06.729
And you get virtually unlimited
memory, unlike a small device.

00:03:06.729 --> 00:03:13.619
So a take-home point here is, remember that
behavior and memory are the same on the Simulator,

00:03:13.620 --> 00:03:17.090
and go ahead and use it to great, great effect.

00:03:17.090 --> 00:03:19.030
So what about the iPhone?

00:03:19.030 --> 00:03:20.969
Well, this is the real performance.

00:03:20.969 --> 00:03:25.419
This is where you're going to get that
accurate timing for your application.

00:03:25.419 --> 00:03:29.879
It's got the process figure you'll actually
be running on and the limited resources.

00:03:29.879 --> 00:03:35.549
And finally, this is really important because your
users are going to experience your app on the iPhone.

00:03:35.550 --> 00:03:40.600
And when you ship, you need to know that
your performance is going to be up to par,

00:03:40.599 --> 00:03:45.069
it's going to be that great scrolling
experience, that great usage experience.

00:03:45.069 --> 00:03:49.500
So when you're looking for the
speed and responsiveness qualities

00:03:49.500 --> 00:03:54.389
of your application, definitely,
definitely aim at an iPhone.

00:03:54.389 --> 00:03:57.809
Well, why do you care when it comes to profiling?

00:03:57.810 --> 00:04:00.050
Well, we have some available instrumentation on the device.

00:04:00.050 --> 00:04:03.310
And most of the same that you're used to on the Mac.

00:04:03.310 --> 00:04:07.900
So, for instance, we have object alloc,
the activity monitor, our CPU Sampler

00:04:07.900 --> 00:04:11.120
and Leaks Instruments all able to the device.

00:04:11.120 --> 00:04:18.709
However, we even have some that are specific to iPhone,
such as the Core Animation Instrument, the I/O Activity,

00:04:18.709 --> 00:04:27.469
which we're going to go ahead and demo, and the OpenGL
ES Instrument for profiling that specific code to iPhone.

00:04:27.470 --> 00:04:31.230
In the Simulator, we even have more than the device.

00:04:31.230 --> 00:04:36.060
You can make use of DTrace and the
built-in instruments that come with as well

00:04:36.060 --> 00:04:41.269
as building your own custom scripts and custom instruments.

00:04:41.269 --> 00:04:44.240
There's a lot of power there.

00:04:44.240 --> 00:04:49.460
Also, in the Simulator, you can use the new
Time Profiler introduced in Snow Leopard.

00:04:49.459 --> 00:04:55.359
As well as the new Zombies template,
which I'll also demo later on in the talk.

00:04:55.360 --> 00:04:58.350
So what does Instruments look like with the SDK?

00:04:58.350 --> 00:05:00.850
Well, it's the same thing you're used to.

00:05:00.850 --> 00:05:04.189
It's got the Template Chooser, when you launch it.

00:05:04.189 --> 00:05:09.500
And if you'll notice on the left, the
categories are slightly redesigned from Leopard.

00:05:09.500 --> 00:05:14.490
And there's the Mac OS X device, there's
the iPhone and the iPhone Simulator.

00:05:14.490 --> 00:05:17.920
So you don't have to remember everything I
just told you about what's available where.

00:05:17.920 --> 00:05:24.000
You can go right here and click through and see
what instruments are available on each device.

00:05:24.000 --> 00:05:30.019
So without further ado, let's go ahead
and jump into a demo right at the top,

00:05:30.019 --> 00:05:34.149
which is the first thing your user sees,
the launch time of your application.

00:05:34.149 --> 00:05:41.269
So I'd like to invite Lynne Salameh to show
us a demo of profiling our app to improve launch times.

00:05:41.269 --> 00:05:43.120
>> Thank you, Daniel.

00:05:43.120 --> 00:05:48.209
Well, the demo we have for today is called Breadcrumbs.

00:05:48.209 --> 00:05:51.129
And let me just unlock my phone over here.

00:05:51.129 --> 00:05:57.449
And Breadcrumbs is an application that
records trails of places you've been to

00:05:57.449 --> 00:06:01.170
and that are annotated with the latitude and longitude.

00:06:01.170 --> 00:06:06.210
You can leave these trails of notes at these places
you've been to and maybe add a photo to that.

00:06:06.209 --> 00:06:11.289
So to launch it, I'm just going to click
this Breadcrumbs light, and my app comes up.

00:06:11.290 --> 00:06:15.100
And to add a new breadcrumb, I'll
just hit the Plus button over here.

00:06:15.100 --> 00:06:18.870
And, you know, type in "on stage."

00:06:18.870 --> 00:06:24.420
You know, I can even add a photo
by taking a photo over here,

00:06:24.420 --> 00:06:26.990
which I'm not going to do right now, and then hit done.

00:06:26.990 --> 00:06:30.579
And there I've added my breadcrumb.

00:06:30.579 --> 00:06:37.389
So if you guys will notice, the launch times for my
Breadcrumbs app was pretty snappy on first launch.

00:06:37.389 --> 00:06:43.069
But when you're running and when you're testing
for performance of your target applications,

00:06:43.069 --> 00:06:46.050
you'd like to run with several user scenarios.

00:06:46.050 --> 00:06:51.389
And in this case, a more realistic user
scenario would be a Breadcrumbs application

00:06:51.389 --> 00:06:55.709
with breadcrumbs already stored on your Breadcrumbs app.

00:06:55.709 --> 00:06:59.719
So a whole bunch of photos and
notes that you've saved already.

00:06:59.720 --> 00:07:03.140
So I'm going to launch Breadcrumbs with a bunch of data.

00:07:03.139 --> 00:07:07.269
And let's take a look at the launch time.

00:07:07.269 --> 00:07:08.939
Well, it's still launching.

00:07:08.939 --> 00:07:10.029
And now it's done.

00:07:10.029 --> 00:07:12.619
So the launch time over there, you
know, took a couple of seconds.

00:07:12.620 --> 00:07:15.090
It wasn't as snappy as I expected it to be.

00:07:15.089 --> 00:07:19.189
And, you know, you can see that I
have a bunch of breadcrumbs over here

00:07:19.189 --> 00:07:23.360
with photos, latitudes and longitudes and some notes.

00:07:23.360 --> 00:07:28.949
So let me just quit this application
and switch back to Instruments.

00:07:28.949 --> 00:07:32.579
So this is my application in Xcode.

00:07:32.579 --> 00:07:35.349
And I'm just going to bring it up in Instruments over here.

00:07:35.350 --> 00:07:42.379
So as we said, as Daniel just showed you, the template
chooser in Snow Leopard has now grouped your templates

00:07:42.379 --> 00:07:46.389
by category and the column to the left over here.

00:07:46.389 --> 00:07:51.810
And right now, I'm looking at the iPhone category,
and I've selected CPU usage or CPU type templates

00:07:51.810 --> 00:07:54.959
because I'm interested in seeing my launch times.

00:07:54.959 --> 00:07:58.680
And I'm going to click on the CPU
Sampler template, hit Choose.

00:07:58.680 --> 00:08:02.560
Let me just enlarge this for a second.

00:08:02.560 --> 00:08:03.100
All right.

00:08:03.100 --> 00:08:07.920
So the CPU sampler template has two instruments;
the Sampler instrument and the CPU monitor.

00:08:07.920 --> 00:08:13.319
And I'm going to go ahead, and in my target chooser, you
can see that I've already selected the device as a target.

00:08:13.319 --> 00:08:19.279
I'm going to launch the executable
Breadcrumbs and hit Record.

00:08:19.279 --> 00:08:24.009
Now, it's collecting its data.

00:08:24.009 --> 00:08:28.269
And as you can see, it's already launched my device.

00:08:28.269 --> 00:08:32.220
So I can stop recording and take
a look at the data it's collected.

00:08:32.220 --> 00:08:37.509
Now, Sampler collects stack traces at
regular intervals from the target process.

00:08:37.509 --> 00:08:40.840
And it aggregates these stack traces and call trees.

00:08:40.840 --> 00:08:47.320
And right now, I'm looking at these call trees in adverted
mode, which means my deepest stack trace is shown first.

00:08:47.320 --> 00:08:50.510
And then I build my stack traces in reverse order.

00:08:50.509 --> 00:08:55.350
So what I'm going to do is, if I zoom
in over here-- oh, I can't even zoom in.

00:08:55.350 --> 00:08:56.759
I haven't set up the zoom.

00:08:56.759 --> 00:09:04.700
Anyway, over here, I don't know if you guys can see it
on the right, I'm going to uncheck Invert Call Tree.

00:09:04.700 --> 00:09:08.820
And now I'm looking at my stack traces in top, down view.

00:09:08.820 --> 00:09:12.930
So you can see that I have two threads running my
phone, the main thread and then another thread.

00:09:12.929 --> 00:09:18.919
And then I'm going to bring in my extended detail view by
going to the top right corner, hitting Extended Detail.

00:09:18.919 --> 00:09:22.360
I'm going to select my main thread.

00:09:22.360 --> 00:09:26.909
So my extended detail view shows me the
heaviest stack traces of each of these threads.

00:09:26.909 --> 00:09:32.959
And I actually want to time scope my data so
that I can look precisely at launch times.

00:09:32.960 --> 00:09:39.889
So I'm going to drag the inspection head in
the track over here and select that time range.

00:09:39.889 --> 00:09:42.590
And let's bring up the stack trace.

00:09:42.590 --> 00:09:45.350
All right, so what's happening over here?

00:09:45.350 --> 00:09:53.070
My code is calling into RootViewController
TableView HeightForRowAtIndex,

00:09:53.070 --> 00:09:56.310
which is calling into BreadcrumbEntry thumbnail.

00:09:56.309 --> 00:10:00.389
And that, in turn, calls
BreadcrumbStoreThumbnailForBreadcrumb.

00:10:00.389 --> 00:10:07.080
After I time scoped, and from the stock trace,
I can see that I'm spending most of my time

00:10:07.080 --> 00:10:10.889
in trying to get thumbnails for my breadcrumbs.

00:10:10.889 --> 00:10:16.879
So the question here that you want to ask yourself
is, How many thumbnails am I loading on launch time?

00:10:16.879 --> 00:10:21.070
Well, let me just remove the time scope.

00:10:21.070 --> 00:10:28.340
And from my library icon in the top right, I'm going to
add the I/O Activity Instrument by double-clicking on it.

00:10:28.340 --> 00:10:34.440
And I've just added the I/O Activity Instrument that
will tell me about my file opens, closes, reads.

00:10:34.440 --> 00:10:38.630
And I can figure out how many thumbnails
I'm reading in to my app launch time.

00:10:38.629 --> 00:10:42.950
So I'm just going to hit Record again and start this over.

00:10:42.950 --> 00:10:45.370
Actually, let's click on the I/O Instruments.

00:10:45.370 --> 00:10:46.399
There we go.

00:10:46.399 --> 00:10:52.559
And as you can see, the I/O Instruments
is reading in a whole bunch of files.

00:10:52.559 --> 00:10:56.469
And it's still launching the app.

00:10:56.470 --> 00:11:02.300
And I'm getting all of these thumbnails read in.

00:11:02.299 --> 00:11:03.889
And we're done now.

00:11:03.889 --> 00:11:07.240
So we can stop the trace.

00:11:07.240 --> 00:11:16.930
And if you can see the TableView over here, I am
opening and reading in a whole bunch of thumbnails.

00:11:16.929 --> 00:11:20.989
All of these over here are thumbnail JPEGs.

00:11:20.990 --> 00:11:30.009
And from their labels, I can see that I have
160 JPEGs that I'`m reading in at launch time.

00:11:30.009 --> 00:11:32.740
Now, this is a very-- I/O is extensive.

00:11:32.740 --> 00:11:38.200
And really, we don't need to be
loading with thumbnails at launch time.

00:11:38.200 --> 00:11:42.420
So if I close my library, and once
again, you can see the stack traces

00:11:42.419 --> 00:11:45.879
for where these thumbnails are getting launches, loaded.

00:11:45.879 --> 00:11:51.929
And the stack trace is, once again,
RootViewController TableView HeightForRowAtIndex,

00:11:51.929 --> 00:11:56.519
which is calling into the code that
is reading the thumbnails from disk.

00:11:56.519 --> 00:12:03.970
So why am I trying to read in the thumbnails when I
am calculating the height of my rows for my TableView?

00:12:03.970 --> 00:12:12.649
Well, if I go back to Xcode, and here I
have the function, heightForRowInIndexPath.

00:12:12.649 --> 00:12:16.009
It seems when I originally designed this application,

00:12:16.009 --> 00:12:20.330
I had assumed that my thumbnails
are going to have variable heights.

00:12:20.330 --> 00:12:26.450
So when I am trying to figure out the height of the
row in my TableView, I am reading in the thumbnails,

00:12:26.450 --> 00:12:34.300
I'm calling entry.thumbnail, getting its
height, and using that as my content's height.

00:12:34.299 --> 00:12:39.679
Now, my thumbnails, they're all the default row heights.

00:12:39.679 --> 00:12:42.809
So on launch time, when I'm launching,
I don't really need to read

00:12:42.809 --> 00:12:45.729
in all the thumbnails just to calculate
the height of my rows.

00:12:45.730 --> 00:12:54.320
So instead, I am just going to delete this
code over here and bring in some new code.

00:12:54.320 --> 00:12:58.720
That, instead, returns the default row content's height.

00:12:58.720 --> 00:13:01.000
Let me just save that.

00:13:01.000 --> 00:13:07.419
Now, we're not done yet because we still need to read
in our thumbnails because we want smooth scrolling.

00:13:07.419 --> 00:13:11.199
We don't want the user to be scrolling
through the rows of our TableView

00:13:11.200 --> 00:13:14.520
and have the thumbnails getting
loaded in a very choppy manner.

00:13:14.519 --> 00:13:20.360
So we're going to be loading our thumbnails in a background
thread that doesn't really interfere with launch time.

00:13:20.360 --> 00:13:23.389
So we're going to go ahead, and
in the Breadcrumbs app delegates.

00:13:23.389 --> 00:13:30.830
When we're showing the Breadcrumbs content view,
I'm going to add in another line of code over here.

00:13:30.830 --> 00:13:40.340
And what I'm doing is I am warming
the thumbnails on a different thread.

00:13:40.340 --> 00:13:43.129
So I'm detaching a different thread
that warms these thumbnails.

00:13:43.129 --> 00:13:49.939
And what that means is I am loading in the thumbnails,
but I'm doing it on a background thread later on.

00:13:49.940 --> 00:13:55.900
So I don't really have to load in
all my thumbnails at launch time.

00:13:55.899 --> 00:14:00.100
All right, so let's verify that
this does what I expect it to do.

00:14:00.100 --> 00:14:07.450
Back at Instruments, I am going to launch an
app on the phone that already has this fix in.

00:14:07.450 --> 00:14:12.259
So select that and hit Record.

00:14:12.259 --> 00:14:16.480
And if you can see-- well, I can tell
because I'm looking at the phone over there.

00:14:16.480 --> 00:14:19.649
My launch-- I've just completed launch time.

00:14:19.649 --> 00:14:22.939
But in the TableView, I'm still reading in the thumbnails.

00:14:22.940 --> 00:14:25.760
So I'm doing that lazily and loading them later.

00:14:25.759 --> 00:14:28.559
So now I'm at 118.

00:14:28.559 --> 00:14:31.929
And now I just finished loading the thumbnails.

00:14:31.929 --> 00:14:43.449
And if we actually switch back to the phone
and take a look at the load time on the phone,

00:14:43.450 --> 00:14:46.790
you can see it's much shorter than
what we originally started with.

00:14:46.789 --> 00:14:51.329
All right, so now let's take a
look at scrolling performance.

00:14:51.330 --> 00:14:54.080
I have my app, my Breadcrumbs app.

00:14:54.080 --> 00:14:57.240
And let's try to scroll through it.

00:14:57.240 --> 00:15:00.200
It seems pretty choppy.

00:15:00.200 --> 00:15:06.200
In fact, I'd like to investigate this further, because
I bet you can improve the scrolling performance

00:15:06.200 --> 00:15:09.230
so that it doesn't-- the frame rate is much higher.

00:15:09.230 --> 00:15:15.690
So let me just quit my app and switch back to Instruments.

00:15:15.690 --> 00:15:16.420
There we go.

00:15:16.419 --> 00:15:22.719
I'm going to launch a new trace
document by hitting Command-n.

00:15:22.720 --> 00:15:27.540
And instead of selecting the CPU
category, I'm going to select Graphics.

00:15:27.539 --> 00:15:31.879
And in the Graphics category, you see a bunch of
instruments that relate to graphics on the iPhone.

00:15:31.879 --> 00:15:37.500
And I'm going to select the Core Animation Instruments
because I am interested in the frame rate of my scrolling.

00:15:37.500 --> 00:15:41.590
And I also would like some debug
options to play around with.

00:15:42.690 --> 00:15:47.630
And once again, I'm going to launch
the executable Breadcrumbs

00:15:47.629 --> 00:15:54.240
And the Core Animation Instruments
is reading frame rate over here.

00:15:54.240 --> 00:15:57.299
And now it's not really doing anything
because I'm not playing around with my app.

00:15:57.299 --> 00:16:00.740
But let me just walk over here and start scrolling.

00:16:00.740 --> 00:16:05.960
So the frame rate isn't doing very well.

00:16:05.960 --> 00:16:11.470
You know, on average, it's about 8 to 6 frames per second.

00:16:11.470 --> 00:16:21.800
And if I switch back to-- and so if I actually take
a look at-- I'm going to stop recording right now.

00:16:21.799 --> 00:16:25.549
Or no, actually, let's continue recording.

00:16:25.549 --> 00:16:28.740
If you take a look at the lower left corner over here,

00:16:28.740 --> 00:16:32.269
you can see that you have some debug
options that-- I can read some out to you.

00:16:32.269 --> 00:16:35.049
There's color blended layers.

00:16:35.049 --> 00:16:38.039
There's color immediately or flash updated regions.

00:16:38.039 --> 00:16:42.639
These debug options are very similar to the
options you might have seen in ports debug.

00:16:42.639 --> 00:16:49.080
And what I'd really like to do is, I'd like to
see whether I have blended layers on my phone,

00:16:49.080 --> 00:16:54.080
which means that layers aren't opaque, and
they're composited on top of each other.

00:16:54.080 --> 00:16:58.080
And this is a, you know, compositing is a costly operation.

00:16:58.080 --> 00:17:00.850
And it might be the reason why my scrolling is slow.

00:17:00.850 --> 00:17:06.180
So I'm going to select Color Blended
Layers and switch back to my iPhone.

00:17:06.180 --> 00:17:14.420
And what we see here is that opaque layers are shown in
green, whereas the blended ones, the ones that aren't opaque

00:17:14.420 --> 00:17:20.009
and that are composited on top of the
background layer, are shown in red.

00:17:20.009 --> 00:17:24.990
So all my cells that are displaying these
labels are composited, which might explain--

00:17:24.990 --> 00:17:29.349
which is probably the reason why I
have this choppiness in scrolling.

00:17:29.349 --> 00:17:40.819
So let's quit this application, switch back to
Xcode, and take look at what I'm doing, precisely.

00:17:40.819 --> 00:17:47.659
So back in Xcode, I'm going to take
a look at my BreadcrumbCell view.

00:17:47.660 --> 00:17:51.430
And this is going to launch up Interface Builder.

00:17:51.430 --> 00:17:56.870
And I want to verify, I mean, I want
to see why my cells aren't opaque.

00:17:56.869 --> 00:18:03.689
So over here, I'm just going to select Label,
which I saw was, you know, being blended.

00:18:03.690 --> 00:18:05.940
It was displayed in red.

00:18:05.940 --> 00:18:10.600
And in the options, you can see that opaque isn't checked.

00:18:10.599 --> 00:18:13.559
So my cell isn't opaque.

00:18:13.559 --> 00:18:17.129
It's getting composited over the background view.

00:18:17.130 --> 00:18:24.220
And that's why I'm exhibiting slowness in scrolling
because compositing is an expensive operation.

00:18:24.220 --> 00:18:27.500
So one way you can change that is,
you know, make your view opaque.

00:18:27.500 --> 00:18:34.160
But another way is to-- because I'm actually,
in this case, creating my own custom cells,

00:18:34.160 --> 00:18:40.029
I could just use the cell API that iPhone 3.0 provides me.

00:18:40.029 --> 00:18:49.359
So back in my Root View Controller, if
I navigate to CellForRowAtIndexPath,

00:18:49.359 --> 00:18:53.240
you can see that I'm creating my
own BreadcrumbCell instance,

00:18:53.240 --> 00:18:59.140
which is my style that has the image and subtitle text.

00:18:59.140 --> 00:19:04.620
So why don't I use the iPhone API
instead to use a default cell?

00:19:04.619 --> 00:19:08.769
So I'm going to bring in a replacement for this method.

00:19:08.769 --> 00:19:14.389
I'll drag it in here.

00:19:14.390 --> 00:19:23.890
So in TableView CellForRowAtIndexPath, instead of creating
my own custom cell, I am using a UI TableView cell

00:19:23.890 --> 00:19:28.759
that in iPhone 3.0 has the option
to init with certain style.

00:19:28.759 --> 00:19:33.980
And I'm going to init, I'm going to instantiate
it with a cell style that has subtitles.

00:19:33.980 --> 00:19:38.079
And by defaults, the UI TableView cells are opaque.

00:19:38.079 --> 00:19:47.839
So let me go ahead and delete the old method
over here and save it and go back to Instruments.

00:19:47.839 --> 00:19:55.149
And I'm going to launch the version of the app
that has the fix in it on the phone and hit Record.

00:19:55.150 --> 00:20:07.570
All right, I can-- oh, let me just remove the debug
option over here, and go back to my phone and scroll.

00:20:07.569 --> 00:20:12.319
And my frame rate has improved.

00:20:12.319 --> 00:20:17.329
And let's just verify that we have no blending anymore.

00:20:17.329 --> 00:20:26.490
So I'm going to hit Color Blended
Layers again, go back to my iPhone.

00:20:26.490 --> 00:20:31.690
And now, none of my cells are blended, and my
entire-- well, nearly my entire screen is green.

00:20:31.690 --> 00:20:34.220
So there you have it.

00:20:34.220 --> 00:20:40.420
All right, so now we've seen how
we've used Instruments to, you know,

00:20:40.420 --> 00:20:42.930
figure out why our launch times is taking too long.

00:20:42.930 --> 00:20:48.190
And we've also used iInstruments to determine
whether we have blending layers or not.

00:20:48.190 --> 00:20:55.900
So back to Daniel.

00:20:55.900 --> 00:20:57.310
[ Applause ]

00:20:57.309 --> 00:20:58.730
>> Thank you.

00:20:58.730 --> 00:21:05.620
So let's go through a couple of tools that Lynne just
covered and talk about them in a little bit more depth.

00:21:05.619 --> 00:21:08.539
So first of all, the Sampler instrument.

00:21:08.539 --> 00:21:13.359
Now, as Lynne said, this takes back traces of
your application at a certain time interval.

00:21:13.359 --> 00:21:15.109
By default, 10 milliseconds.

00:21:15.109 --> 00:21:18.500
And it gets all of the thread states in your application.

00:21:18.500 --> 00:21:22.539
And the idea is that it's statistical,
not function profiling.

00:21:22.539 --> 00:21:27.659
So if you have 100 calls to a very, very,
very short method, you may not see those.

00:21:27.660 --> 00:21:30.610
What you're looking for is the calls to a long method.

00:21:30.609 --> 00:21:33.419
And we sample it during that long method.

00:21:33.420 --> 00:21:39.529
And so this allows you to find hotspots in your
code that you can go back and really optimize.

00:21:39.529 --> 00:21:44.950
Now, on the left-hand side were a lot
of configuration options for Sampler.

00:21:44.950 --> 00:21:48.200
And let's cover those in a little bit more detail.

00:21:48.200 --> 00:21:50.650
So first of all, sample perspective.

00:21:50.650 --> 00:21:52.380
Now, there's two ways to look at this.

00:21:52.380 --> 00:21:55.120
First of all, you can look at it
in the all-sample counts way.

00:21:55.119 --> 00:22:00.089
And this is just what it records by default,
showing all thread states and accounts

00:22:00.089 --> 00:22:03.009
of number of samples you take for those threads.

00:22:03.009 --> 00:22:08.650
This allows you to see block threads or running threads.

00:22:08.650 --> 00:22:13.330
Now, when you switch that to running sample
times, that shows you the executing threads,

00:22:13.329 --> 00:22:18.379
and the executing threads only, and allows you to
find out how much time you are spending on CPU.

00:22:18.380 --> 00:22:22.460
So the difference here really is blocked versus running.

00:22:22.460 --> 00:22:28.170
Now, to understand this more fully, let's take an example.

00:22:28.170 --> 00:22:33.120
So in this example here, the first
thing to note is we have 151 samples.

00:22:33.119 --> 00:22:37.409
At a 10 millisecond interval, that's a second and a half.

00:22:37.410 --> 00:22:46.519
So we look at the Call Tree, and the most
expensive one is mach_msg_trap at 102 samples.

00:22:46.519 --> 00:22:52.220
Well, mach_msg_trap is actually sitting there
waiting for input and not doing anything.

00:22:52.220 --> 00:22:54.059
And we'll see that later.

00:22:54.059 --> 00:22:57.980
Now, looking at our code in Breadcrumbs, we have 26 samples.

00:22:57.980 --> 00:23:00.809
And these are divided up into 11, 9 and 6.

00:23:00.809 --> 00:23:05.599
And to really focus in for this, I
want to call out BreadcrumbCell init

00:23:05.599 --> 00:23:09.369
with frame reuse identifier, as
well as BreadcrumbEntry thumbnail.

00:23:09.369 --> 00:23:12.419
And they have really corresponding numbers and samples.

00:23:12.420 --> 00:23:17.090
So they take about the same amount of wall clock time, OK?

00:23:17.089 --> 00:23:22.199
Well, what happens when we switch
this to running sample times?

00:23:22.200 --> 00:23:28.259
Well, first of all, we notice that we're
using only 380 milliseconds on the CPU.

00:23:28.259 --> 00:23:36.500
And second of all, that mach_msg_trap, like I said, it was
waiting, and it really took no running time on our CPU.

00:23:36.500 --> 00:23:41.079
So going back to our code, what
about those two frames from earlier?

00:23:41.079 --> 00:23:45.669
What behavioral difference can
we see between these two views?

00:23:45.670 --> 00:23:49.090
Well, the BreadcrumbCell, init
with frame, took 100 milliseconds.

00:23:49.089 --> 00:23:49.949
It was actually running.

00:23:49.950 --> 00:23:53.769
There was some work to be done,
allocations, views to set up.

00:23:53.769 --> 00:24:00.079
But the thumbnail, the BreadcrumbEntry actually
gathering the thumbnail wasn't spending its time running.

00:24:00.079 --> 00:24:07.359
It was actually spending its time drawing in that
thumbnail from the database and doing blocking I/O.

00:24:07.359 --> 00:24:14.399
So that's what the difference in
the sample perspective can show you.

00:24:14.400 --> 00:24:17.750
Now, as far as call tree
inversion, Lynne this off.

00:24:17.750 --> 00:24:22.609
And that was to identify the costs
in the application launch.

00:24:22.609 --> 00:24:31.149
So, for example, when we click on the button to create a
new BreadcrumbEntry, let's say that takes 800 milliseconds,

00:24:31.150 --> 00:24:34.360
and Breadcrumb's app delegate composed entry.

00:24:34.359 --> 00:24:37.419
Well, that's broken up into different calls.

00:24:37.420 --> 00:24:42.210
For example, the app delegate can show the composed
view, and that has to create a nib.

00:24:42.210 --> 00:24:47.549
And then it has to commit a new breadcrumb, and
then it has to make a thumbnail for that entry,

00:24:47.549 --> 00:24:51.769
which has to do even more work in drawing
and even committing the breadcrumb again.

00:24:51.769 --> 00:24:56.940
And so what you see is the breakdown of
how your time is spent in different calls.

00:24:56.940 --> 00:24:59.890
Now, some of those, maybe all of
them, even, you will control.

00:24:59.890 --> 00:25:04.480
Or some of them may be beyond your
control in APIs that you're calling in to.

00:25:04.480 --> 00:25:10.039
And so you can really see how expensive they
are and maybe learn how to call them less.

00:25:10.039 --> 00:25:13.700
And finally, to fill out this Call
Tree, we also commit the breadcrumb

00:25:13.700 --> 00:25:17.700
at the very end when we're done composing the entry.

00:25:17.700 --> 00:25:22.950
So taking a look at the Call Tree, it looks like
that CommitBreadcrumb is taking a lot of time.

00:25:22.950 --> 00:25:26.650
But we can't tell this just from looking at it at first.

00:25:26.650 --> 00:25:29.850
That's why we can turn Call Tree Inversion on.

00:25:29.849 --> 00:25:32.509
And this is for showing the hotspots in the code.

00:25:32.509 --> 00:25:40.789
So what it does is, it takes delete frames, moves those
to the top of the Call Tree and aggregates the numbers

00:25:40.789 --> 00:25:47.490
and then generates a new Call Tree from
there, going back up the call stack.

00:25:47.490 --> 00:25:54.339
So this immediately allows you to see that
BreadcrumbStore CommitBreadcrumb took 440 milliseconds

00:25:54.339 --> 00:25:58.539
and is our first place if we want that one spot to optimize.

00:25:58.539 --> 00:26:00.799
And we could even find out where it was called from.

00:26:00.799 --> 00:26:06.509
So the next tool that Lynne showed
was the I/O Activity Instrument.

00:26:06.509 --> 00:26:10.710
And I should mention, this records all the I/O events.

00:26:10.710 --> 00:26:14.130
Now, this is, you know, the opens, the stats, the closes.

00:26:14.130 --> 00:26:20.250
And the reason you really need to pay attention
to this is because I/O takes a long time.

00:26:20.250 --> 00:26:24.730
On the iPhone, all of the applications are sand-boxed.

00:26:24.730 --> 00:26:31.700
And that means that you can only access
files within your application bundle

00:26:31.700 --> 00:26:34.509
and within your documents and caches folder.

00:26:34.509 --> 00:26:39.640
So what happens when you try to
access files outside of your sand-box?

00:26:39.640 --> 00:26:46.570
You fail. And the I/O Activity Instrument will show you the
return codes for failing I/0 operations and let you track

00:26:46.569 --> 00:26:52.659
down those calls that you didn't actually mean
to make or perhaps you have the paths wrong.

00:26:52.660 --> 00:27:01.190
And for those of you who are familiar with Instruments,
this is much like the File Activity Instrument for Mac OS X.

00:27:01.190 --> 00:27:03.940
So also let's talk about drawing.

00:27:03.940 --> 00:27:07.900
The Core Animation Instrument used is
to provide those graphical annotations,

00:27:07.900 --> 00:27:10.500
the ones that are kind of fun to look at.

00:27:10.500 --> 00:27:15.930
The blending is to help you out with
seeing where your views aren't opaque

00:27:15.930 --> 00:27:23.490
and where you could actually improve your performance by
making them opaque or perhaps decomposing your interface.

00:27:23.490 --> 00:27:28.880
It will allow you to flash updates so you
can see if you're making unnecessary draws.

00:27:28.880 --> 00:27:32.430
And even see which images are copied unnecessarily.

00:27:32.430 --> 00:27:38.049
Finally, it tracks the overall frame rate so that
as you make changes, you can go back and forth

00:27:38.049 --> 00:27:43.819
and see if you are really actually
improving performance on things.

00:27:43.819 --> 00:27:50.009
All right, so let's switch topics
a bit and talk about memory.

00:27:50.009 --> 00:27:52.190
Now, this is absolutely vital on iPhone.

00:27:52.190 --> 00:27:57.940
And hopefully you have heard from the other
memory sessions we've had how vital it is.

00:27:57.940 --> 00:28:01.259
But you need to be very effective about management.

00:28:01.259 --> 00:28:03.000
So we've got a suite of tools for this.

00:28:03.000 --> 00:28:10.809
And I'd like to introduce them before jumping into a demo
so that you understand their purpose and their technology.

00:28:10.809 --> 00:28:13.669
So first is the ObjectAlloc Instrument.

00:28:13.670 --> 00:28:14.720
It's really a heavy lifter.

00:28:14.720 --> 00:28:17.279
It tracks all of the 'Malloc' type memory.

00:28:17.279 --> 00:28:22.450
And this includes your Objective-C
objects, created with alloc init.

00:28:22.450 --> 00:28:29.430
It tracks your C calls, created with Malloc, your
C++ objects created with New, all of those types.

00:28:29.430 --> 00:28:36.000
And for Objective-C, it can provide you with
retained release histories for those objects as well.

00:28:36.000 --> 00:28:43.420
Another benefit of using this is it gives you
statistics on how many objects of each type you created,

00:28:43.420 --> 00:28:48.840
so that you can track whether the numbers line up
with what you thought they were supposed to be.

00:28:48.839 --> 00:28:51.449
And then you can put them in Call
Trees and find out what parts

00:28:51.450 --> 00:28:55.230
of your code were responsible for allocating that memory.

00:28:55.230 --> 00:29:01.910
Finally, there's a little bit of overhead with collecting
on this data, which is why we recommend doing a good portion

00:29:01.910 --> 00:29:05.519
of your memory analysis in the Simulator.

00:29:05.519 --> 00:29:10.500
Set for the next tool, Leaks.

00:29:10.500 --> 00:29:13.259
This is a very powerful static memory analysis tool.

00:29:13.259 --> 00:29:17.960
And what it does is it runs through your
process looking for unreferenced memory blocks.

00:29:17.960 --> 00:29:23.289
These are blocks that you allocated that aren't in use
anymore and that are really just causing you troubles

00:29:23.289 --> 00:29:25.819
because they're upping your resident memory.

00:29:25.819 --> 00:29:31.210
Now, it works alongside ObjectAlloc
to provide you those back traces for Leaks.

00:29:31.210 --> 00:29:36.319
And what do I mean exactly by an
unreferenced memory block, a leak?

00:29:36.319 --> 00:29:37.579
Well, let's say you have MyObject.

00:29:37.579 --> 00:29:40.949
It's just an object with a name and some variable.

00:29:40.950 --> 00:29:44.059
In your init, you do the standard.

00:29:44.059 --> 00:29:48.029
I'll set the name to an NSString alloc initWithFormat.

00:29:48.029 --> 00:29:49.250
And you use it for a while.

00:29:49.250 --> 00:29:56.240
And in the dealloc, you forget one thing, the name release.

00:29:56.240 --> 00:30:01.799
Well, this means that when your object goes away and that
last reference goes away, you're NSString is still left

00:30:01.799 --> 00:30:05.149
around with a retain kind of one and isn't deallocated.

00:30:05.150 --> 00:30:08.110
So your string is leaked.

00:30:08.109 --> 00:30:10.949
Well, how do we track down the leaks?

00:30:10.950 --> 00:30:14.370
What we do is we start with all of
the Heap Objects in your application.

00:30:14.369 --> 00:30:19.069
And then we scan all of your stacks in Global Data.

00:30:19.069 --> 00:30:22.889
And we scan these for things that look like pointers.

00:30:22.890 --> 00:30:29.600
So regardless of whether they're actually flags or
whatever, if they look like a pointer to a Heap Object,

00:30:29.599 --> 00:30:32.329
we need to consider them that for being conservative.

00:30:32.329 --> 00:30:34.839
And I'll talk about that a little bit later.

00:30:34.839 --> 00:30:35.730
Also scan your data.

00:30:35.730 --> 00:30:42.910
And once we find these pointers that reference
those Heap Objects, we then follow them,

00:30:42.910 --> 00:30:46.440
scan the Heap Objects, and then
follow the pointers from there.

00:30:46.440 --> 00:30:47.809
And you get the idea.

00:30:47.809 --> 00:30:53.369
We scan all of the objects until
we can't find any more references.

00:30:53.369 --> 00:30:56.509
Anything that's left are the leaked blocks.

00:30:56.509 --> 00:31:08.049
So let's go ahead and see a demo of Leaks and
memory growth and how to track it down on iPhone.

00:31:08.049 --> 00:31:11.629
OK, so I'm going to do most of
this analysis in the Simulator.

00:31:11.630 --> 00:31:20.880
So I'll just build-- you'll have to excuse me-- and
run the Performance tool from my menu and select Leaks.

00:31:20.880 --> 00:31:26.450
So my app launches in the Simulator.

00:31:26.450 --> 00:31:30.460
And Instruments starts recording data
in the background as it comes up.

00:31:30.460 --> 00:31:36.220
So what I'm going to do is, I'm just
going to try to exercise some of my code.

00:31:36.220 --> 00:31:39.170
In fact, as much as I can, as many code paths.

00:31:39.170 --> 00:31:49.890
And I'll select one of those, select an image, and
go back, just really work out my application, OK?

00:31:49.890 --> 00:31:55.070
In Leaks, what it's doing is, it's
periodically scanning my application's heap

00:31:55.069 --> 00:31:57.509
and checking for those unreferenced memory blocks.

00:31:57.509 --> 00:32:04.819
And you'll notice in the track view here that the red marks
are when I discovered Leaks and the number I discovered.

00:32:04.819 --> 00:32:11.149
And the blue is just a total overall
amount of Leaks memory that I have.

00:32:11.150 --> 00:32:13.360
So I've collected my data.

00:32:13.359 --> 00:32:14.619
I'm pretty happy.

00:32:14.619 --> 00:32:18.129
I'm going to go ahead and stop.

00:32:18.130 --> 00:32:20.700
And we're going to take a look at the detail view here.

00:32:20.700 --> 00:32:23.600
Now, this is a little bit different from Leopard.

00:32:23.599 --> 00:32:24.839
It's new in Snow Leopard.

00:32:24.839 --> 00:32:27.750
The aggregation of our leaked objects.

00:32:27.750 --> 00:32:32.980
Now, what this is doing is, this is finding all
of the leaks with the same allocation back trace.

00:32:32.980 --> 00:32:37.789
And I can show that by bringing in the extended detail view.

00:32:39.160 --> 00:32:41.630
And I'll enlarge my window a bit.

00:32:41.630 --> 00:32:45.670
And so they're all allocated at the same point.

00:32:45.670 --> 00:32:53.370
And we can even turn this down and see that there's
a whole bunch of NSStrings with different addresses.

00:32:53.369 --> 00:32:55.049
So each of these are leaked.

00:32:55.049 --> 00:32:58.409
Now, I could just look at the allocation stack trace.

00:32:58.410 --> 00:33:05.470
But from tracking down most leaks, it's important to look
at the whole retained release history for the object.

00:33:05.470 --> 00:33:11.569
It's possible that it wasn't leaked at the point of its
creation, but later on, because someone over-retained it.

00:33:11.569 --> 00:33:18.139
So there I selected the Focus button
next to the address of one of the leaks.

00:33:18.140 --> 00:33:23.270
And I'm presented with the full retain
release event lifecycle for that string.

00:33:23.269 --> 00:33:28.639
And so you can see at the beginning here,
we've got a Malloc with a rough count of one.

00:33:28.640 --> 00:33:30.800
See if retain increments the rough count.

00:33:30.799 --> 00:33:37.230
Auto release has no effect until
the release pool is popped later on.

00:33:37.230 --> 00:33:43.880
And you'll notice that the CFString has a
final reference count of one when it's leaked,

00:33:43.880 --> 00:33:49.130
which means that we've probably missed a
release somewhere, or have an extra retain.

00:33:49.130 --> 00:33:51.710
So how do we track this down?

00:33:51.710 --> 00:33:55.430
Well, it's usually true that near
the beginning and near the end

00:33:55.430 --> 00:33:59.860
of the lifecycle are the points
that you want to look for errors.

00:33:59.859 --> 00:34:04.679
And the lifecycle management rules for
Cocoa are pretty simple and straightforward.

00:34:04.680 --> 00:34:05.990
But they're easy to get wrong.

00:34:05.990 --> 00:34:08.409
And they're easy to just make that little mistake.

00:34:08.409 --> 00:34:11.170
Sort of like missing a semicolon.

00:34:11.170 --> 00:34:14.980
So what I'm going to do is I'm
going to select the Malloc point

00:34:14.980 --> 00:34:19.659
and go to the extended detail view
and just double click on MyFrame.

00:34:19.659 --> 00:34:23.710
Well, in Snow Leopard, this brings
it up right in Instruments.

00:34:23.710 --> 00:34:24.929
I can take a look at my source code.

00:34:24.929 --> 00:34:29.659
And you'll notice that the string
that was leaked was the subtitle text.

00:34:29.659 --> 00:34:33.969
So it was alloced initWithFormat.

00:34:33.969 --> 00:34:37.779
And so now my subtitle text has a retain count of one.

00:34:37.780 --> 00:34:42.640
And then I assign it to cell.detailtextlabel.txt.

00:34:42.639 --> 00:34:44.730
So hmm, that's interesting.

00:34:44.730 --> 00:34:51.050
Let's go ahead and jump into Xcode
with the button in the top right here.

00:34:51.050 --> 00:34:58.850
And I'm going to Command double-click on .txt here to
take a look at the property declaration for UI label.

00:35:02.170 --> 00:35:07.159
So this text label here is declared as non-atomic copy,

00:35:07.159 --> 00:35:11.539
which means that it will copy the
string and take ownership of it.

00:35:11.539 --> 00:35:13.489
That's great.

00:35:13.489 --> 00:35:15.459
But what am I left with?

00:35:15.460 --> 00:35:20.170
I'm left with a subtitle text which I have
a retain count on and I need to release it.

00:35:20.170 --> 00:35:28.880
And so the simple fix, just like I forgot a semicolon,
is just to put in subtitle text release here.

00:35:28.880 --> 00:35:35.420
So I save, I build, and now I am going
to go ahead and run this in Instruments.

00:35:35.420 --> 00:35:42.250
So I've got to run the Performance
tools, Leaks, and my app starts up.

00:35:42.250 --> 00:35:48.699
And I'll go back to the main view here and exercise
my application again and see if the leak reproduces.

00:35:48.699 --> 00:35:55.639
So I put it through its paces.

00:35:55.639 --> 00:36:01.269
And our result, the NSString leaks are gone.

00:36:01.269 --> 00:36:04.199
So now we have a couple other leaks
that we need to track down

00:36:04.199 --> 00:36:05.939
But it's an innovative process.

00:36:05.940 --> 00:36:11.190
You should make a fix, see how the
improvement works, and go from there.

00:36:11.190 --> 00:36:14.000
So all right, that was Leaks.

00:36:14.000 --> 00:36:16.539
And those were on reference memory blocks.

00:36:16.539 --> 00:36:20.739
But we need to actually be a little bit more
proactive about tracking down our memory usage.

00:36:20.739 --> 00:36:26.159
What about memory that we still
reference, but we don't still need?

00:36:26.159 --> 00:36:35.289
Well, for this, what I am going to do is I am going to
bring up, under the Memory section, just Object Allocations.

00:36:36.369 --> 00:36:38.739
Now, again, this lets me track all of my Malloc memory.

00:36:38.739 --> 00:36:43.689
And if I select my application
in the Simulator and hit Launch.

00:36:43.690 --> 00:36:50.980
By default, this graph is going to show me, and I'll
enlarge it a bit, this graph is going to show me the amount

00:36:50.980 --> 00:36:53.110
of memory that I currently have allocated.

00:36:53.110 --> 00:36:58.890
And that sudden spike after a couple seconds was
that delayed thumbnail loading that Lynne mentioned.

00:36:58.889 --> 00:37:04.029
So now my app is up and running and I can scroll around.

00:37:04.030 --> 00:37:05.840
And there isn't much memory growth.

00:37:05.840 --> 00:37:12.559
When I select an item, you can see live in the
Instruments trace that there was a little bit

00:37:12.559 --> 00:37:14.079
of memory growth from loading all of this text.

00:37:14.079 --> 00:37:18.299
And when I select my image, there's
quite a bit of memory growth.

00:37:18.300 --> 00:37:21.460
And then I go back to my main view.

00:37:21.460 --> 00:37:23.190
But that image doesn't get released.

00:37:23.190 --> 00:37:24.909
I was hoping it would.

00:37:24.909 --> 00:37:28.469
In fact, I really don't need that image
around, because I've got the thumbnail.

00:37:28.469 --> 00:37:30.759
So I'll go ahead and stop that

00:37:30.760 --> 00:37:35.730
And I'm going to take a look at why that
image didn't go away like I expected.

00:37:35.730 --> 00:37:47.380
So if I time scope to this area and type in my category
here, Image, you can take a look at the image types I have.

00:37:47.380 --> 00:37:54.200
And so I have a UI image here, I have two images I have
created in that time period, both that are living at the end

00:37:54.199 --> 00:37:59.429
of the time period, and I'll go ahead and
select the category to see which ones.

00:37:59.429 --> 00:38:07.460
And so if I bring in the extended detail view, this
first image was created when I clicked the photo.

00:38:07.460 --> 00:38:14.099
And it was calling the image method of the BreadcrumbEntry,
which was then calling into my Breadcrumb store,

00:38:14.099 --> 00:38:19.509
which is a database, and asking it to
load an image with the contents of file.

00:38:19.510 --> 00:38:22.110
OK, great, that's probably the image I'm looking for.

00:38:22.110 --> 00:38:27.680
So why don't I jump directly to
this code and see what's going on?

00:38:27.679 --> 00:38:29.119
So here I go.

00:38:29.119 --> 00:38:33.170
The image is initWithContentsOfFile, the
image file name for Row ID.

00:38:33.170 --> 00:38:35.389
Great. But where does this get returned to?

00:38:35.389 --> 00:38:39.409
Well, I'll just use the extended
detail view to jump directly there.

00:38:39.409 --> 00:38:44.179
So the image is getting stored in
an ivar named m_image.

00:38:44.179 --> 00:38:45.859
And that's great.

00:38:45.860 --> 00:38:48.829
And that's being stored in the BreadcrumbEntry.

00:38:48.829 --> 00:38:52.809
Well, why is that ivar not going away?

00:38:52.809 --> 00:39:00.170
Well, if we go back to Xcode, you'll notice that I have to
go to the point at which I expected the image to go away.

00:39:00.170 --> 00:39:03.380
And that was when my composed view controller left.

00:39:03.380 --> 00:39:06.200
That was when it disappeared.

00:39:06.199 --> 00:39:12.689
So when the view disappears, I asked if I needed
to save, and I saved it out to the database.

00:39:12.690 --> 00:39:14.159
But then my entry is still around.

00:39:14.159 --> 00:39:17.579
That entry object is still holding onto the object.

00:39:17.579 --> 00:39:22.489
And you can see in the definition for
entry that it has a bunch of properties.

00:39:22.489 --> 00:39:25.709
Most of these would load from the
database, including m_image.

00:39:25.710 --> 00:39:33.920
So what I'm going to do, let's go back to that
point, and I'm going to ask it to dehydrate.

00:39:33.920 --> 00:39:37.400
And I will show you what this method does in a second.

00:39:37.400 --> 00:39:41.240
Let me go ahead and load this code.

00:39:41.239 --> 00:39:51.569
So I'm going to ask that BreadcrumbEntry to dehydrate.

00:39:51.570 --> 00:39:57.250
And what this does is this is just going to
release most of the resources that I can load

00:39:57.250 --> 00:39:59.079
from the database because I don't need them.

00:39:59.079 --> 00:40:01.739
I'm just showing the brief summary description.

00:40:01.739 --> 00:40:04.869
And I can load the thumbnail at will.

00:40:04.869 --> 00:40:10.009
And so by getting rid of these resources,
I reduce my active memory footprint.

00:40:10.010 --> 00:40:14.420
And the other thing I need to do here is
add this dehydrate call to viewedItUnload

00:40:14.420 --> 00:40:18.159
because viewedItUnload is what's going
to be called during memory warning.

00:40:18.159 --> 00:40:22.509
And I want this also to happen then.

00:40:22.510 --> 00:40:23.350
So I build.

00:40:23.349 --> 00:40:28.759
I'm going to run with Performance tool, Object Allocations.

00:40:28.760 --> 00:40:33.010
App goes ahead and starts up.

00:40:33.010 --> 00:40:38.640
And after a few seconds, we should see
that all of the thumbnails getting loaded.

00:40:38.639 --> 00:40:40.779
And I scroll around.

00:40:40.780 --> 00:40:44.320
And now I'm going to see if my image gets unloaded promptly.

00:40:44.320 --> 00:40:46.730
So there's the image being loaded.

00:40:46.730 --> 00:40:51.849
And as I leave the composed view, it's immediately unloaded.

00:40:51.849 --> 00:41:02.569
So just to watch that again, it's really quick and
responsive in getting rid of my resources that I don't need.

00:41:02.570 --> 00:41:04.910
So again, be proactive.

00:41:04.909 --> 00:41:10.549
Make sure that the behavior is exactly what you
expect and what you hope for in your memory usage.

00:41:14.469 --> 00:41:18.139
OK, so, I mentioned earlier that Leaks was conservative.

00:41:18.139 --> 00:41:23.409
And what I mean by this is that it works
very, very hard to avoid false positives.

00:41:23.409 --> 00:41:27.079
This means that when it reports a leak
to you, you can believe that it's leaked,

00:41:27.079 --> 00:41:30.880
and you need to really investigate what's causing that leak.

00:41:30.880 --> 00:41:35.960
Now, this also means that it doesn't catch
everything because you need to make sure.

00:41:35.960 --> 00:41:40.579
And if you're leaking just one
object, well, you should probably test

00:41:40.579 --> 00:41:44.069
out your application a bit more
so that you leak 5 or 10 objects.

00:41:44.070 --> 00:41:46.550
And you'll catch most of those with Leaks.

00:41:46.550 --> 00:41:54.880
It's a very, very powerful tool, and it also should be used
alongside other tools, such as the Xcode Static Analyzer.

00:41:56.610 --> 00:42:03.410
So as far as memory, growth over time is
something you need to very actively avoid.

00:42:03.409 --> 00:42:10.480
And this is what we showed in the demo of that
image memory not being released immediately.

00:42:10.480 --> 00:42:13.059
So be conscious of your memory usage.

00:42:13.059 --> 00:42:15.960
Be actively investigating those problems.

00:42:15.960 --> 00:42:19.980
And prepare for the memory warning case
so that you can release those caches

00:42:19.980 --> 00:42:22.380
and get rid of that memory very quickly.

00:42:22.380 --> 00:42:28.450
So for more information on the memory
management guidelines for retain release,

00:42:28.449 --> 00:42:31.019
definitely go to the Memory Management Programming Guide.

00:42:31.019 --> 00:42:33.210
I would bookmark this, post this on your wall.

00:42:33.210 --> 00:42:37.590
It's a great guide and something that you
really need to make sure you understand fully.

00:42:37.590 --> 00:42:44.420
So let's go and talk about one more memory issue.

00:42:44.420 --> 00:42:45.800
It's very iPhone-specific.

00:42:45.800 --> 00:42:47.370
And that's cell reuse.

00:42:47.369 --> 00:42:49.929
Now, this is something that's a little bit different.

00:42:49.929 --> 00:42:53.599
Because as you use cells, normally
you would create them, they get used.

00:42:53.599 --> 00:42:57.559
As they go off-screen, they just get destroyed.

00:42:57.559 --> 00:43:01.759
And so this has you creating a lot of
objects and then deallocating them.

00:43:01.760 --> 00:43:06.830
Well, there's a bit of a cost involved with both
the allocation of the object and the allocation

00:43:06.829 --> 00:43:09.549
of the layers in the setting up of the view hierarchy.

00:43:09.550 --> 00:43:17.910
And so what cell reuse in iPhone is about is taking
those cells as they go off-screen and taking them back

00:43:17.909 --> 00:43:24.420
around to the bottom and reusing them to avoid the
costs and penalties of allocating these objects.

00:43:24.420 --> 00:43:30.119
So let's go ahead and take a look at making sure
our application is implementing cell reuse properly.

00:43:30.119 --> 00:43:41.980
OK, so again, from Instruments, I'm going to start with
the Object Allocations template in the Memory section.

00:43:41.980 --> 00:43:48.929
And I'm going to launch my Breadcrumbs application.

00:43:48.929 --> 00:43:52.949
So Breadcrumbs launches.

00:43:52.949 --> 00:43:58.199
And for this, I want to view something
different than just the overall bytes I'm using.

00:43:58.199 --> 00:44:01.009
I want to see how many objects
I'm creating and deallocating.

00:44:01.010 --> 00:44:06.310
So if I hit the Inspector button, I can change
my track display style from current bytes

00:44:06.309 --> 00:44:09.049
to things like allocation density and stack depth.

00:44:09.050 --> 00:44:12.750
And allocation density is what I want for this
because that's going to show me the number

00:44:12.750 --> 00:44:15.380
of allocations I make in a given time period.

00:44:15.380 --> 00:44:23.769
So if I mouse over, I can see that early on, I
did about, oh, 97 allocations in a millisecond.

00:44:23.769 --> 00:44:27.420
So I'll go ahead and watch this as I scroll.

00:44:27.420 --> 00:44:32.409
And you'll notice live that it's doing a bit of allocation.

00:44:32.409 --> 00:44:34.889
So interesting.

00:44:34.889 --> 00:44:35.980
I wonder if that's correct.

00:44:35.980 --> 00:44:44.670
So to find out if I'm using the cells correctly, I'll
go ahead and go on the bottom right and type in "cell."

00:44:44.670 --> 00:44:48.200
So what I have here are my UI TableView cells.

00:44:48.199 --> 00:44:53.859
And the numbers show me that I have 6
living cells, 6 cells that are still in use,

00:44:53.860 --> 00:44:57.110
and 150 poor cells that I've created and destroyed.

00:44:57.110 --> 00:45:04.120
Well, as I scroll, I'll go back up, the
number of living cells goes between 7 and 6.

00:45:04.119 --> 00:45:08.559
But the number that I created and
destroyed is just going up without bound.

00:45:08.559 --> 00:45:12.130
In fact, it's at about 275 now.

00:45:12.130 --> 00:45:14.640
So I'm probably doing something wrong.

00:45:14.639 --> 00:45:21.250
Now, to watch the cells in particular, I can just
select the Focus button on UI TableView cell.

00:45:21.250 --> 00:45:25.789
And it presents me with all of the
TableView cells in my application.

00:45:25.789 --> 00:45:29.420
Now, you'll notice for this that
the live column is important.

00:45:29.420 --> 00:45:35.980
Because if I scroll to the very bottom, all of
the live cells are still marked with a bullet.

00:45:35.980 --> 00:45:40.360
So I'm interested in the ones that were deallocated.

00:45:40.360 --> 00:45:51.490
And if I bring in the extended detail, I'll notice
that this is in my TableView CellForRowAtIndexPath.

00:45:51.489 --> 00:45:56.079
So all right, I'll go to that code.

00:45:56.079 --> 00:45:58.889
And it's a little bit big text.

00:45:58.889 --> 00:46:00.099
So I'll go ahead and show it here.

00:46:00.099 --> 00:46:05.150
And here is my TableView CellForRowAtIndexPath
implementation.

00:46:05.150 --> 00:46:08.280
So I'm using my initWithStyle method.

00:46:08.280 --> 00:46:13.220
But most importantly, every single time I'm
coming through here, I'm calling alloc init.

00:46:13.219 --> 00:46:17.019
So this reuse identifier is not being used.

00:46:17.019 --> 00:46:22.570
And again, every single time I come
through, it's allocating the cell.

00:46:22.570 --> 00:46:24.769
So how do I fix this?

00:46:24.769 --> 00:46:26.280
Well, it's pretty easy.

00:46:26.280 --> 00:46:31.140
What I'm going to do is I'm going
to define a cell identifier.

00:46:31.139 --> 00:46:32.170
In this case, it's just cell.

00:46:32.170 --> 00:46:38.019
And the first thing I need to do before
allocating anything is ask my TableView, Hey,

00:46:38.019 --> 00:46:40.780
is there any reasonable cell with that identifier around?

00:46:40.780 --> 00:46:44.210
If there is, then I can just go ahead and use it.

00:46:44.210 --> 00:46:46.760
I'll remove these two lines.

00:46:46.760 --> 00:46:51.190
So if there isn't any cell, then
I need to go ahead and create one.

00:46:51.190 --> 00:46:54.619
And I'll create it with that reuse
identifier that I just declared above.

00:46:54.619 --> 00:46:56.690
Very simple, very straightforward.

00:46:56.690 --> 00:46:57.490
Let's make sure it works.

00:46:57.489 --> 00:47:01.629
So I'll go ahead and build.

00:47:01.630 --> 00:47:03.300
Go back to Instruments.

00:47:03.300 --> 00:47:05.640
And I will stop and rerun.

00:47:05.639 --> 00:47:13.629
So I'll go ahead and go back to the main
TableView to we can watch this live.

00:47:13.630 --> 00:47:18.840
And again, we have 6 living cells from the beginning.

00:47:18.840 --> 00:47:24.850
So it starts growing, the number
goes up to 7, and that's it, just 7.

00:47:24.849 --> 00:47:28.369
There aren't any more transitory
objects being created and destroyed.

00:47:28.369 --> 00:47:35.199
And you'll also notice that the number of allocations
is actually significantly lower, as we scroll.

00:47:36.269 --> 00:47:39.400
So again, another example of being proactive and making sure

00:47:39.400 --> 00:47:42.420
that the behavior is what you would
expect when it comes to memory.

00:47:42.420 --> 00:47:47.880
So finally, it's good to be proactive.

00:47:47.880 --> 00:47:50.070
But sometimes things just go wrong.

00:47:50.070 --> 00:47:55.860
So what happens when you find performance
problems and how do you deal with them?

00:47:55.860 --> 00:47:58.210
Well, you need to be responsive with your application.

00:47:58.210 --> 00:48:01.030
And if your app isn't, users are really going to notice.

00:48:01.030 --> 00:48:04.420
And then they're going to hit the Home button,
and they're going to wish your application quit.

00:48:04.420 --> 00:48:12.300
And when your app doesn't, because it's saving its state
and taking a long time, your app is going to get terminated.

00:48:12.300 --> 00:48:16.430
To preserve that good user experience on the iPhone.

00:48:16.429 --> 00:48:20.579
Well, this means that you need to work very,
very hard to not block the main thread.

00:48:20.579 --> 00:48:22.449
What do I mean by that?

00:48:22.449 --> 00:48:29.839
I mean deadlocks, I mean network activity,
synchronous network activity on the main thread,

00:48:29.840 --> 00:48:35.730
infinite loops in your code, anything that
causes the main thread to stop being responsive.

00:48:35.730 --> 00:48:38.309
Now, you can use Sampler to track this down.

00:48:38.309 --> 00:48:45.369
And I would highly suggest that you profile the device
because, again, that's where your application is

00:48:45.369 --> 00:48:50.859
under the most constraint and the users
will experience your app's responsiveness.

00:48:50.860 --> 00:48:53.789
Well, what about memory?

00:48:53.789 --> 00:48:55.619
Why do you need to use that wisely?

00:48:55.619 --> 00:48:59.579
Well, the system has to protect itself
if it's about to run out of memory.

00:48:59.579 --> 00:49:04.569
And that will result in your app getting terminated again.

00:49:04.570 --> 00:49:07.330
So what do you need to do?

00:49:07.329 --> 00:49:09.190
Definitely fix leaks.

00:49:09.190 --> 00:49:13.639
Definitely work very proactively to
reduce your memory growth over time.

00:49:13.639 --> 00:49:18.529
And then you need to respond to those memory warnings.

00:49:18.530 --> 00:49:20.550
There was an earlier session about that.

00:49:20.550 --> 00:49:23.350
And you can come find us in the labs
if you need to talk about that more.

00:49:23.349 --> 00:49:26.929
But there are three simple places to respond.

00:49:26.929 --> 00:49:31.289
And it's very, very necessary that
you do this and you plan ahead.

00:49:31.289 --> 00:49:35.150
And finally, the Simulator provides a lot
of convenience when dealing with memory,

00:49:35.150 --> 00:49:40.420
in both the fact that you can analyze the same behavior,
you can integrate it into your workflow even faster,

00:49:40.420 --> 00:49:44.440
and you can simulate those memory warnings,
just to make sure you're responding properly.

00:49:44.440 --> 00:49:48.909
Well, this could also happen, too.

00:49:48.909 --> 00:49:52.519
And when it crashes, what do you do?

00:49:52.519 --> 00:49:55.300
Well, you need to take a look at the crash trace.

00:49:55.300 --> 00:49:57.660
And the one I really want to call out here is this one.

00:49:57.659 --> 00:50:01.569
Because you crashed apparently in Objective-C Message Send.

00:50:01.570 --> 00:50:04.150
Now, Objective-C Message Send isn't at fault.

00:50:04.150 --> 00:50:07.860
What's really happening here is that you
sent a message to a deallocated object.

00:50:07.860 --> 00:50:13.070
So as we've been harping a little bit on,
over-release objects are quite a problem.

00:50:13.070 --> 00:50:16.990
And while leaks are over-retains,
over-releases lead to crashes.

00:50:16.989 --> 00:50:18.639
So this happens.

00:50:18.639 --> 00:50:21.529
You create a string with Alloc initWithFormat.

00:50:21.530 --> 00:50:24.220
It has a retain count of one.

00:50:24.219 --> 00:50:26.059
You go on to release it.

00:50:26.059 --> 00:50:27.299
Retain count goes to zero.

00:50:27.300 --> 00:50:29.300
And then the object gets deallocated.

00:50:29.300 --> 00:50:32.330
It's just a block of freed memory.

00:50:32.329 --> 00:50:38.329
Well, when you try to send a message, that's what's
going to get you your crash in Objective-C Message Send.

00:50:38.329 --> 00:50:42.630
Where a nice new Zombies template is
going to change the behavior there.

00:50:42.630 --> 00:50:47.519
And that last release will decrement the retain count.

00:50:47.519 --> 00:50:51.230
And instead of freeing the object, it
turns it into a Zombie and leaves it

00:50:51.230 --> 00:50:57.789
in your process's address space
for the rest of its execution.

00:50:58.809 --> 00:51:02.730
Now, when you send that extra message,
then the Zombie responds.

00:51:02.730 --> 00:51:09.969
And we can track its response in
Instruments and present that event to you.

00:51:09.969 --> 00:51:15.079
So anyway, let's go ahead and see a demo of
just using that and tracking down of releases,

00:51:15.079 --> 00:51:20.699
which has historically been a hard thing to do.

00:51:20.699 --> 00:51:31.899
OK, so as I was developing my application, I found that
there was a point at which I was crashing pretty hard.

00:51:31.900 --> 00:51:34.150
And here is my application.

00:51:34.150 --> 00:51:38.539
I'm going to go ahead and build and debug it.

00:51:39.869 --> 00:51:43.170
The app comes up.

00:51:43.170 --> 00:51:49.030
And it was scrolling fine and it was displaying
these fine, and it was displaying the images fine.

00:51:49.030 --> 00:51:53.070
But when I backed out to the main
TableView, I was getting this crash.

00:51:53.070 --> 00:51:55.539
And you'll notice it was in Objective-C Message Send.

00:51:55.539 --> 00:51:57.699
And it even corrupted the stack.

00:51:57.699 --> 00:52:01.149
So this is a bit hard to track down.

00:52:01.150 --> 00:52:06.660
So let's go ahead and see how we can use
the template to identify this over-release.

00:52:06.659 --> 00:52:09.809
So go into Instruments.

00:52:09.809 --> 00:52:13.779
Under the Simulator memory area, also in Zombies,

00:52:13.780 --> 00:52:21.570
and you'll notice this is again the ObjectAlloc
instrument we're working with for a long time.

00:52:21.570 --> 00:52:27.330
But it's got the record reference counts option on in its
inspector as well as the enables in a Zombie detection.

00:52:27.329 --> 00:52:31.210
Now, again, this will alter the
behavior of every last release.

00:52:31.210 --> 00:52:34.210
So be aware of that.

00:52:34.210 --> 00:52:45.230
So I launch my application in the
Simulator and try to reproduce my crash.

00:52:45.230 --> 00:52:48.590
So nice picture.

00:52:48.590 --> 00:52:51.289
Oh, there it goes.

00:52:51.289 --> 00:52:55.039
So immediately Instruments tells me that I messaged

00:52:55.039 --> 00:52:58.320
to Zombie saying an Objective-C message
was sent to a deallocated object.

00:52:58.320 --> 00:53:01.990
It gives me the address and it gives me a Focus button.

00:53:01.989 --> 00:53:05.099
So I'll use it and jump directly there.

00:53:05.099 --> 00:53:10.099
And my detail view here shows me some
information that I immediately wanted to know,

00:53:10.099 --> 00:53:15.699
such as the fact that it's a UI image,
and the retain release history for it.

00:53:15.699 --> 00:53:23.169
So I've got a Malloc, an auto release, a couple retains,
releases, and that last message was sent to the Zombie.

00:53:23.170 --> 00:53:27.409
So my goal here is to determine
which release was extraneous.

00:53:27.409 --> 00:53:30.079
And I'll use the guess that it was probably in my code.

00:53:30.079 --> 00:53:34.159
So here is my responsible library column.

00:53:34.159 --> 00:53:40.460
And this makes a guess at finding out
which library, which binary was responsible

00:53:40.460 --> 00:53:43.440
for making these reference counting calls.

00:53:43.440 --> 00:53:46.460
It's a good first estimate.

00:53:46.460 --> 00:53:50.949
So I'll look through here and look for
any releases that are in Breadcrumbs.

00:53:50.949 --> 00:53:52.519
And here we go.

00:53:52.519 --> 00:53:56.039
And I'll go ahead and double-click to jump there.

00:53:56.039 --> 00:53:58.210
And you'll see that it's in my viewDidLoad.

00:53:58.210 --> 00:54:03.079
And so I've got my m_imageview.image
equals m.image,

00:54:03.079 --> 00:54:08.349
which is setting the image property on the image view.

00:54:08.349 --> 00:54:17.150
So that view will retain the object, which is
why it's fine for me to release my ivar, OK?

00:54:17.150 --> 00:54:18.400
So I'll go back.

00:54:18.400 --> 00:54:23.940
The second one is this release here and also on Breadcrumbs.

00:54:23.940 --> 00:54:26.869
That's where I double-click.

00:54:26.869 --> 00:54:28.119
We're in the dealloc now.

00:54:28.119 --> 00:54:32.809
And you'll notice that I am releasing my M image.

00:54:32.809 --> 00:54:38.299
Well, when I go back to Xcode here,
you see these right beside each other.

00:54:38.300 --> 00:54:42.940
Neither of these is wrong, but both of them is.

00:54:42.940 --> 00:54:46.300
And which one is right?

00:54:46.300 --> 00:54:52.990
Well, just to make this simple, I'm going to go
with the standard pattern of retaining my image

00:54:52.989 --> 00:54:55.849
in the init and releasing it in the dealloc.

00:54:55.849 --> 00:54:59.719
In my viewDidLoad, I am not going to release this.

00:54:59.719 --> 00:55:03.189
So I'm going with the standard pattern there.

00:55:03.190 --> 00:55:05.329
I've removed that extraneous release.

00:55:05.329 --> 00:55:11.079
I build. And I'll go ahead and debug
it again and see if it crashes.

00:55:11.079 --> 00:55:14.719
So here we go.

00:55:14.719 --> 00:55:18.889
Select an image and go back to the main view.

00:55:18.889 --> 00:55:20.769
It hasn't crashed yet.

00:55:20.769 --> 00:55:22.710
One more. And we're good.

00:55:22.710 --> 00:55:27.130
So there we go, tracking down an over-release.

00:55:28.849 --> 00:55:33.409
So in summary, I want to encourage
you to use Instruments for the iPhone.

00:55:33.409 --> 00:55:37.289
It's got a lot of powerful tools,
a lot of great instrumentation.

00:55:37.289 --> 00:55:43.869
And it's really important for you to be proactive
in tracking down the problems that you may face.

00:55:43.869 --> 00:55:46.019
Know the difference between the Simulator and the device.

00:55:46.019 --> 00:55:48.079
When do you use the Simulator?

00:55:48.079 --> 00:55:50.739
Mainly for behavior and memory analysis.

00:55:50.739 --> 00:55:53.029
And when do you use the device?

00:55:53.030 --> 00:55:59.280
For that really speed and responsiveness and the
final test before you submit it to the app store.

00:55:59.280 --> 00:56:02.070
And again, I can't stress this enough, but be proactive.

00:56:02.070 --> 00:56:07.809
Don't wait until you get crash reports to start
up Instruments and to profile your application.

00:56:07.809 --> 00:56:10.900
Now, for more information, you can talk to Michael Jurewitz.

00:56:10.900 --> 00:56:12.599
And there's his e-mail.

00:56:12.599 --> 00:56:16.110
And we've got some Instruments
documentation in the user guide in Xcode.

00:56:16.110 --> 00:56:16.200
1
WEBVTT

00:00:12.910 --> 00:00:17.390
>> Hello, and welcome to the OpenGL ES Overview for iPhone.

00:00:17.390 --> 00:00:22.830
My name is Michael Swift and Alex Kan will be joining
us part of the way through today's presentation.

00:00:23.870 --> 00:00:30.000
We're both members of the Embedded Graphics Acceleration
Team in Apple and work on the OpenGL ES implementation.

00:00:30.000 --> 00:00:36.060
As you heard in the keynote, the new iPhone
3G S introduces support for OpenGL ES 2.0.

00:00:36.060 --> 00:00:39.980
So let's take a look at how this affects today's agenda.

00:00:43.009 --> 00:00:49.479
We'll start off today with an overview of
OpenGL ES 1.1, OpenGL ES 2.0, their similarities

00:00:49.479 --> 00:00:53.459
and some of the reasons why we'd use
one version of the API versus the other.

00:00:54.909 --> 00:00:56.979
Oh, shoot, wrong one.

00:00:56.979 --> 00:01:00.709
Following that, we will talk about how
you create an OpenGL ES application,

00:01:00.710 --> 00:01:04.460
specifically using the OpenGL ES template provided by Xcode.

00:01:04.459 --> 00:01:08.979
And then talk about how the template
works and how your content gets onscreen.

00:01:08.980 --> 00:01:17.260
The third part of this is once your
content is rendered and presented to UIKit,

00:01:17.260 --> 00:01:21.359
it needs to get composited with
the rest of the iPhone OS UI.

00:01:21.359 --> 00:01:23.640
And so we'll talk about some of the best practices to ensure

00:01:23.640 --> 00:01:27.750
that your OpenGL ES content gets
onscreen in an efficient manner.

00:01:27.750 --> 00:01:32.459
And then the last section before Q&A
is all about the new device specifics.

00:01:32.459 --> 00:01:37.399
So the iPhone 3G S introduces a whole bunch
of new support, both API and extension-wise.

00:01:37.400 --> 00:01:40.109
And so, we'll talk about that there.

00:01:40.109 --> 00:01:47.349
So before we jump into the Overview, there are two other
OpenGL ES section-- or sessions that are in this room today.

00:01:47.349 --> 00:01:51.419
The first of these is the OpenGL ES
Shading and Advanced Rendering Topic.

00:01:51.420 --> 00:01:55.890
This covers OpenGL ES 2.0 Shaders,
Programmability, and we'll also go into a bunch

00:01:55.890 --> 00:01:58.870
of advanced 3D and 2D Image Processing Effects.

00:01:58.870 --> 00:02:03.200
It can do both in ES 1.1 and ES 2.0.

00:02:03.200 --> 00:02:05.829
The third session is all about performance.

00:02:05.829 --> 00:02:10.000
So here, you're going to learn how to
identify and optimize pipeline bottlenecks

00:02:10.000 --> 00:02:15.449
and also how to tune your OpenGL ES 2.0 shaders.

00:02:15.449 --> 00:02:18.399
So with that, let's jump into the overview.

00:02:18.400 --> 00:02:22.879
What is OpenGL ES?

00:02:22.879 --> 00:02:27.400
Well, it's an open industry standard
that's for a 3D graphics API.

00:02:27.400 --> 00:02:31.849
And this is modeled after the OpenGL API from
the desktop that's been around for many years.

00:02:31.849 --> 00:02:35.569
It's been simplified and streamlined
such that it works on imbedded devices.

00:02:35.569 --> 00:02:40.139
The desktop version of this API has a lot
of different ways of doing the same thing.

00:02:40.139 --> 00:02:42.629
So the ES version slims it down and makes it more efficient.

00:02:42.629 --> 00:02:48.590
And probably the most important thing here is that
it implements a specific 3D graphics pipeline.

00:02:48.590 --> 00:02:52.140
So let's talk some more about this.

00:02:52.139 --> 00:02:59.709
Important thing to know about OpenGL ES 1.1 and OpenGL ES
2.0 is that the underlying pipeline or how do they move

00:02:59.710 --> 00:03:03.530
through the system to generate
your content onscreen is the same.

00:03:03.530 --> 00:03:08.909
The only thing that's different is the
vertex and the fragment processing stages.

00:03:08.909 --> 00:03:17.269
And we call this the OpenGL ES 1.1 fixed-function
pipeline and the OpenGL ES 2.0 programmable pipeline.

00:03:17.270 --> 00:03:19.420
So let's take a look at this in the diagram.

00:03:19.419 --> 00:03:26.349
So what you see here is your application
provides a bunch of input data.

00:03:26.349 --> 00:03:32.629
It flows through the pipeline and eventually
creates fragments onscreen as your content is drawn.

00:03:32.629 --> 00:03:37.329
So let's zoom in on the first part
of this, the vertex processing stage.

00:03:40.849 --> 00:03:45.099
So the first thing that I said before
is that the API provides a bunch

00:03:45.099 --> 00:03:48.669
of inputs; position, color, texcoords, and normals.

00:03:48.669 --> 00:03:53.689
These are all used and go through what we call
Transform and Lighting in the fixed-function pipeline.

00:03:53.689 --> 00:03:58.530
More specifically, your position data is
transformed by a modelview projection matrix

00:03:58.530 --> 00:04:01.819
to create the resulting coordinates onscreen.

00:04:01.819 --> 00:04:07.769
And similarly, your texture coordinates go through another
matrix and the normals and your color have lighting applied

00:04:07.770 --> 00:04:12.939
to them based on the fixed-function state, so a
little bit more about the fixed-function state.

00:04:12.939 --> 00:04:20.100
This basically is your matrices, your
lighting information and all your enables.

00:04:20.100 --> 00:04:23.879
And the output of this is position,
color, fog, and texture coordinates.

00:04:23.879 --> 00:04:30.370
And this flows through-- or, since this is per vertex, this
will flow through and go into primitive assembly which is

00:04:30.370 --> 00:04:33.180
where you have your points, lines and triangles.

00:04:33.180 --> 00:04:34.629
That's the first part of the pipeline.

00:04:34.629 --> 00:04:40.579
Next part of the pipeline we're going to
talk about is the Fragment Processing Stage.

00:04:42.389 --> 00:04:49.899
So once you have your points, lines, and triangles
assembled, they're actually broken down into small fragments

00:04:49.899 --> 00:04:54.109
so that they can be textured, fogged and alpha tested.

00:04:54.110 --> 00:04:59.120
So the fixed-function fragment
pipeline specifically does that.

00:04:59.120 --> 00:05:01.240
So it has a bunch of fixed function inputs as well.

00:05:01.240 --> 00:05:09.329
These are your texture-- your texture units, your texture
environment state, we'll talk about that in a moment,

00:05:09.329 --> 00:05:13.849
and the output of all of this is just
color, because it will be depth tested,

00:05:13.850 --> 00:05:17.060
stencil tested, and blended into your frame buffer.

00:05:17.060 --> 00:05:20.639
So, just like we said before, all
the outlets of your vertex shader--

00:05:20.639 --> 00:05:25.599
or sorry, all the outlets of your vertex
stage go into your fragment stage and get--

00:05:25.600 --> 00:05:29.590
had your texturing applied, there's some math
that happens in the texture environment stage.

00:05:29.589 --> 00:05:35.659
You can add, subtract, multiply and do some dot products,
and the result of all of that gets fog and alpha tested.

00:05:35.660 --> 00:05:38.200
Let's go back to the pipeline.

00:05:38.199 --> 00:05:43.829
So as the summary of this, the vertex stage
will do your transformations and your lighting.

00:05:43.829 --> 00:05:46.609
The fragment stage will texture, fog, alpha test.

00:05:46.610 --> 00:05:52.600
And since this is a fixed-function pipeline, it's configured
through a set of parameters and a bunch of enables.

00:05:52.600 --> 00:05:58.670
So you can enable depth or enable
lighting or specify what your matrices are.

00:05:58.670 --> 00:06:03.689
And the API will provide you with a lot of
functionality to help manage that state,

00:06:03.689 --> 00:06:08.610
so API such as glRotate, glTranslate, glScale.

00:06:08.610 --> 00:06:12.400
These are all APIs that will manipulate
your matrices for you.

00:06:12.399 --> 00:06:17.989
So how does this change with the
Programmable Graphics Pipeline?

00:06:17.990 --> 00:06:21.100
It's pretty much the same.

00:06:21.100 --> 00:06:27.830
Your Vertex Processing Stage turns into a Vertex Shader, and
your Fragment Processing Stage turns into a Fragment Shader.

00:06:27.829 --> 00:06:31.969
So let's take a little closer look at this.

00:06:31.970 --> 00:06:36.530
Important thing to note here is this
is actually your code that you create.

00:06:36.529 --> 00:06:39.119
You can specify all the inputs and all the outputs.

00:06:39.120 --> 00:06:43.550
But there are some key ones you need to
have because this is a 3D Graphics API=.

00:06:43.550 --> 00:06:47.280
So as you can see, the vertex shader
needs to output glPosition.

00:06:47.279 --> 00:06:52.539
This is because the subsequent stage
is all about taking the per vertex data

00:06:52.540 --> 00:06:55.280
and turning it into points, lines, and triangles.

00:06:55.279 --> 00:07:02.559
And similarly, just like you saw in the
fixed-function fragment stage, the output is color.

00:07:02.560 --> 00:07:09.110
And what you see up here is a vertex shader and a
fragment shader that are paired together as a program.

00:07:09.110 --> 00:07:14.020
This program is-- pretty much correlates
to the programmable graphics pipeline.

00:07:14.019 --> 00:07:18.909
And by setting the program, you're
enabling the whole pipeline to work.

00:07:18.910 --> 00:07:20.620
So, what is a Shader?

00:07:20.620 --> 00:07:24.040
A Shader is, as I said before, application code.

00:07:24.040 --> 00:07:29.520
And you could specify all the inputs, all the outputs,
and it works on each vertex and each fragment.

00:07:29.519 --> 00:07:36.009
And it's written a nice high-level, C-like language called
"GLSL" and there's some naming conventions that you'll need

00:07:36.009 --> 00:07:41.469
to learn and that will be talked some
more about in the second session today.

00:07:41.470 --> 00:07:48.410
So just as an overview of the OpenGL ES 2.0 Programmable
Graphics Pipeline, Vertex Shader needs to output position,

00:07:48.410 --> 00:07:52.030
and there are other things you can
output is completely up to you.

00:07:52.029 --> 00:07:57.429
The fragment shader needs to output color or
optionally discard just like alpha test does in ES 1.1.

00:07:57.430 --> 00:08:03.000
Another important thing to know is everything
you can do on ES 1.1, you can also do in ES 2.0.

00:08:03.000 --> 00:08:06.740
And as I mentioned before, the
pipeline is configured by these pairing

00:08:06.740 --> 00:08:11.079
of vertex and fragment shaders called a "program."

00:08:11.079 --> 00:08:13.879
And also like I was talking about previously,

00:08:13.879 --> 00:08:17.759
the whole pipeline is fundamentally the
same with exception of these two blocks.

00:08:17.759 --> 00:08:24.099
So the depth testing, stencil testing, blending,
those are all still driven through the API

00:08:24.100 --> 00:08:26.570
with enables just like you saw on ES 1.1.

00:08:26.569 --> 00:08:30.319
So they're very similar.

00:08:30.319 --> 00:08:37.009
So as an overview, we should first talk about some
reasons why you'd want to use ES 1.1 or ES 2.0.

00:08:37.009 --> 00:08:38.409
First of these is programmability.

00:08:38.409 --> 00:08:45.829
OpenGL ES 1.1 is really good for doing a lot of things,
but there are some things it simply cannot express.

00:08:45.830 --> 00:08:50.200
And part of that boils down to the texture
environment stage I was talking about previously.

00:08:50.200 --> 00:08:54.950
This is only able to do multiplication,
addition, subtraction, dot products.

00:08:54.950 --> 00:09:00.670
There are a lot of things in ES 2.0 that you suddenly are
able to do because it's a much more complete language.

00:09:00.669 --> 00:09:06.229
You can do refraction, you can do normalization, all
those-- all those things that can happen on the hardware.

00:09:06.230 --> 00:09:11.190
And so you have a bunch-- or you have a much more
flexibility in what you can do, and you can also,

00:09:11.190 --> 00:09:14.040
you also have so much more flexibility
on what all the inputs are,

00:09:14.039 --> 00:09:16.980
and all the outputs that flow through the pipeline.

00:09:16.980 --> 00:09:25.730
So if you need to do really, really creative
things they may need to be done in OpenGL ES 2.0.

00:09:25.730 --> 00:09:27.850
Next reason, hardware support.

00:09:27.850 --> 00:09:30.139
OpenGL ES 1.1 is supported on all devices.

00:09:30.139 --> 00:09:36.399
OpenGL ES 2.0 is only supported on the iPhone 3G S.

00:09:36.399 --> 00:09:39.740
So this is a big factor for a lot of developers here.

00:09:39.740 --> 00:09:44.480
Another reason for using OpenGL ES 1.1 is ease of use.

00:09:44.480 --> 00:09:53.620
So as I mentioned before, the OpenGL ES 1.1 API has a lot
of helper APIs, more specifically as mentioned; glTranslate,

00:09:53.620 --> 00:09:59.539
glRotate, glScale met-- the management
of matrices and management of state,

00:09:59.539 --> 00:10:03.059
a lot of that is built into the ES 1.1 API.

00:10:03.059 --> 00:10:07.559
And it's not a part of the ES 2.0 API.

00:10:07.559 --> 00:10:11.919
So you may-- or if you use the ES 2.0, there's a
little bit more of a learning curve because you have

00:10:11.919 --> 00:10:15.329
to implement some of the stuff in your application code.

00:10:15.330 --> 00:10:20.300
>> And so, it takes a little bit more work to compile
your shaders and link them before you can start drawing.

00:10:20.299 --> 00:10:24.069
ES 1.1, you can pretty much use out of the box.

00:10:24.070 --> 00:10:26.460
You set up your arrays and you just call draw arrays.

00:10:26.460 --> 00:10:28.629
And stuff shows up on your screen.

00:10:28.629 --> 00:10:38.870
So three main reasons why you want to use ES 1 versus
ES 2, programmability, hardware support and easy use.

00:10:38.870 --> 00:10:44.350
So as an overview of all of these,
things to take away are OpenGL ES 1.1

00:10:44.350 --> 00:10:49.310
and OpenGL ES 2.0 are fundamentally the same architecture.

00:10:49.309 --> 00:10:52.529
The major difference is what happens in these--

00:10:52.529 --> 00:10:58.529
the two stages, the vertex stage and the fragment
stage, and also how the data flows through.

00:10:58.529 --> 00:11:03.850
And a nomenclature for this is the
fixed-function graphics pipeline for OpenGL ES 1.1

00:11:03.850 --> 00:11:09.180
and the programmable graphics pipeline for OpenGL ES 2.0.

00:11:09.179 --> 00:11:14.409
So now, I've given you a brief overview
of OpenGL ES and the various versions.

00:11:14.409 --> 00:11:19.079
And now we want to talk about, how do
you create an OpenGL ES application.

00:11:19.080 --> 00:11:22.320
So let's jump into that.

00:11:22.320 --> 00:11:25.330
First thing is, you need two things.

00:11:25.330 --> 00:11:30.050
You need a place to draw into, and
you need a way to talk to OpenGL.

00:11:30.049 --> 00:11:34.329
And these are your displayable rendering
destination and your OpenGL ES context.

00:11:34.330 --> 00:11:38.550
All these are provided for you by the template.

00:11:38.549 --> 00:11:41.659
So, I'll start off with how do
you use the OpenGL ES template,

00:11:41.659 --> 00:11:45.009
and I'm going to have Alex Kan come up and speak to that.

00:11:45.009 --> 00:11:51.539
[ Pause ]

00:11:51.539 --> 00:11:53.399
>> Thanks, Michael.

00:11:53.399 --> 00:12:02.610
So if you've created an iPhone projects in Xcode,
you've probably seen the OpenGL ES Application Option

00:12:02.610 --> 00:12:06.940
in the new Project Selection for, you
know, under iPhone OS Applications.

00:12:06.940 --> 00:12:13.950
And so, Michael pointed out that this [coughs] or
that there are two things that you need in order

00:12:13.950 --> 00:12:19.940
to create an OpenGL ES application on iPhone and
the template sets up all of these things for you.

00:12:19.940 --> 00:12:22.980
And so let's take a look in particular at what it does.

00:12:22.980 --> 00:12:30.330
So, for displayable buffer, it sets up a single full
screen view which OpenGL ES will then be able to draw into.

00:12:30.330 --> 00:12:38.820
Next, it creates an OpenGL ES context configured
to use ES 1.1 and it sets up the rendering state

00:12:38.820 --> 00:12:43.600
such that any rendering commands that you issue
through OpenGL will go into this displayable buffer.

00:12:43.600 --> 00:12:48.759
And the last thing it does for you is it sets up
a function that you can use as a drawing callback.

00:12:48.759 --> 00:12:56.100
Now, by default, the template will set up an NSTimer that
will call this drawing function for you 60 times per second,

00:12:56.100 --> 00:12:57.990
but you can customize this to fit your needs.

00:12:57.990 --> 00:13:02.340
So on that note, what can you do
with this template once you have it?

00:13:02.340 --> 00:13:08.639
Well, the first thing you can do is change what it
draws, I mean, you can add your own textures, models,

00:13:08.639 --> 00:13:14.909
and drawing code to the [coughs]-- and change
the initialization code to load these things

00:13:14.909 --> 00:13:17.169
for you when the application is launched.

00:13:17.169 --> 00:13:22.579
And the second thing that you can do is you can customize
how this application interacts with UIKit, like you know,

00:13:22.580 --> 00:13:31.040
how it deals with the user's finger on the screen,
or accelerometer events, or if any alerts come up.

00:13:31.039 --> 00:13:38.379
If a phone call comes in, or you get
an SMS from a friend or something.

00:13:38.379 --> 00:13:40.590
So let's take a look at the template.

00:13:40.590 --> 00:13:46.009
We'll take a look at what it does, and we'll
also spend some time making a few changes.

00:13:46.009 --> 00:13:53.899
[ Pause ]

00:13:53.899 --> 00:13:58.059
>> OK, so let's start by creating
a new template from the new--

00:13:58.059 --> 00:14:04.079
a new app using the OpenGL ES template
from the new project screen on Xcode.

00:14:04.080 --> 00:14:07.320
So as you can see, I've selected OpenGL ES Application.

00:14:07.320 --> 00:14:16.020
And if I-- well, let's just name this.

00:14:16.019 --> 00:14:22.009
So if we compile this and run it, what you'll see
is that by default, the drawing callback is set

00:14:22.009 --> 00:14:27.639
up to draw something simple for you, this
spinning-- the spinning colored square.

00:14:27.639 --> 00:14:30.669
So now, now that we've seen what
the template looks like initially,

00:14:30.669 --> 00:14:35.669
let's take a look at what-- how this is actually set up.

00:14:35.669 --> 00:14:40.689
So there are two relevant files here, the EAGLView which
is that full screen drawable that I mentioned earlier,

00:14:40.690 --> 00:14:46.060
and the Demo App-- or the App Delegate
which is responsible for handling some

00:14:46.059 --> 00:14:50.269
of the application events that
you might get from the system.

00:14:50.269 --> 00:14:55.799
So first, if we take a look at EAGLView,
there are a couple of relevant functions here,

00:14:55.799 --> 00:15:00.759
the first of which is just the
initialization of the view itself.

00:15:00.759 --> 00:15:07.360
And Michael will go into more detail about what this
is doing specifically, but what this particular piece

00:15:07.360 --> 00:15:12.090
of code does is it sets up your OpenGL ES context.

00:15:12.090 --> 00:15:16.050
[coughs] There's an additional piece of context
initialization that goes on create framebuffer

00:15:16.049 --> 00:15:19.579
And this in particular, is what
wires up the context to that view.

00:15:19.580 --> 00:15:26.120
And Michael will also explain this in greater detail.

00:15:26.120 --> 00:15:26.850
[ Audience Remark: Chaneg the font size! ]

00:15:26.850 --> 00:15:29.009
>> OK, 1 second.

00:15:29.009 --> 00:15:40.970
[ Pause ]

00:15:40.970 --> 00:15:41.250
>> Better?

00:15:41.250 --> 00:15:49.659
[Applause] OK, and so here we have the drawing callback.

00:15:49.659 --> 00:15:53.189
This is what was responsible for drawing
that colored square that you saw earlier.

00:15:53.190 --> 00:16:00.510
So, let's try making some changes to-- or actually
hold on, let's also take a look at the App Delegate.

00:16:00.509 --> 00:16:03.200
And so what this does is it responds
to a couple simple events.

00:16:03.200 --> 00:16:09.710
It response to the application finishing its launching,
at which point, it will start the timer to call the--

00:16:09.710 --> 00:16:15.420
your drawing callback, and it will also change the framerate
in response to alerts coming up over the screen but,

00:16:15.419 --> 00:16:18.889
you know, you may want to do something different
if your application involves user input,

00:16:18.889 --> 00:16:23.000
because you'll probably want to pause
the game or something like that.

00:16:23.000 --> 00:16:26.639
So let's try making a couple of
change-- simple changes to this template.

00:16:26.639 --> 00:16:28.230
So I already have some changes on the side.

00:16:28.230 --> 00:16:33.009
So if you don't mind, I'm just going
to drop them into the EAGLView here.

00:16:33.009 --> 00:16:38.929
[ Pause ]

00:16:38.929 --> 00:16:48.069
>> So what I've done in this case is that I've added
a new different model that just draws at the screen,

00:16:48.070 --> 00:16:57.290
and I've also added a little bit of touch handling
which if we take a look at the touch ended events,

00:16:57.289 --> 00:16:59.629
all I do is change the color of what I'm drawing.

00:16:59.629 --> 00:17:05.430
So if I compile this and run it, you can see that
the app is now changed to drawing this torus here.

00:17:05.430 --> 00:17:10.230
And if I click the screen, you'll
see that this torus changes color.

00:17:10.230 --> 00:17:13.940
So that's a quick look at the template
and how you go about making changes to it.

00:17:13.940 --> 00:17:19.920
Now let's pass things back to Mike to
really dig into what's going on here.

00:17:19.920 --> 00:17:20.880
>> Thank you, Alex.

00:17:20.880 --> 00:17:27.260
So Alex just gave you a brief overview
of how you use your OpenGL ES template.

00:17:27.259 --> 00:17:31.710
So a few key points here are, it's very easy
to use, you just drop in your drawing code

00:17:31.710 --> 00:17:38.230
at the draw function and out of the box, it supports ES 1.1.

00:17:38.230 --> 00:17:44.140
So, I was mentioning there's a bunch more steps that you
need to go through or that the template does for you.

00:17:44.140 --> 00:17:50.070
So now, we're going to take a look at what those
steps are and how your content gets onscreen.

00:17:50.069 --> 00:17:56.189
So first off, we need to ask the question, "How
does the iPhone OS display regular content?"

00:17:56.190 --> 00:18:01.890
Well, you have your application here, and
it's rooted in what's called a UIWindow.

00:18:01.890 --> 00:18:11.340
Everything that is a sublayer of the UI-- or of the
UIWindow such as other UIViews is displayed onscreen.

00:18:11.339 --> 00:18:17.579
So here, I'm just going to explode out the UIWindow
into a UIView, and as you can see, it's a subview.

00:18:17.579 --> 00:18:28.629
So if you want your stuff to show up, it has to be a part
of this UI interaction but the UIViews contain other UIViews

00:18:28.630 --> 00:18:34.120
because it's a layer hierarchy or it actually
contains what we call a Core Animation Layer.

00:18:34.119 --> 00:18:38.659
The Core Animation Layer actually
provides the hooks to the content.

00:18:38.660 --> 00:18:40.160
In this specific case, it's a CGImage.

00:18:40.160 --> 00:18:49.519
You can also use a CGContext to draw your own
content, draw fonts, all that kind of fun stuff.

00:18:49.519 --> 00:18:56.589
So this is generally the flow of how
regular content shows up on the iPhone OS.

00:18:56.589 --> 00:18:59.509
So how does this change with OpenGL ES?

00:18:59.509 --> 00:19:02.490
It's very similar actually.

00:19:02.490 --> 00:19:11.029
Everything is rooted, once again, in the
UIWindow, and then it has a UIView as a subview.

00:19:11.029 --> 00:19:14.089
And as you saw on the template, we call this an "EAGLView."

00:19:14.089 --> 00:19:21.000
And we call it an EAGLView because just like-- 'cause
all the views are backed by Core Animation Layers.

00:19:21.000 --> 00:19:27.039
We need to actually have this backed by a special Core
Animation Layer called the Core Animation EAGLLayer.

00:19:27.039 --> 00:19:34.859
And this EAGLLayer is what provides the
connection between OpenGL ES and the rest of UIKit.

00:19:34.859 --> 00:19:37.529
So this is how-- how it all fits together.

00:19:37.529 --> 00:19:41.930
So this is a brief summary, pretty
much everything is the same.

00:19:41.930 --> 00:19:48.539
Going from left to right, you have you UIWindow,
you have your UIView and then the only key change

00:19:48.539 --> 00:19:55.480
that makes the EAGLView the EAGLView is it's backed by
the CAEAGLLayer which allows OpenGL ES to render into it.

00:19:55.480 --> 00:19:57.799
So that's the only difference.

00:19:57.799 --> 00:20:00.509
That's how your content gets onscreen.

00:20:00.509 --> 00:20:04.210
So there are five steps that you need
to take in order to make this happen.

00:20:04.210 --> 00:20:06.720
First one is to customize your UIView.

00:20:06.720 --> 00:20:11.769
Second one is to initialize OpenGL ES, just
create in your context, and then we need to set

00:20:11.769 --> 00:20:16.940
up your frame buffer and connect to your UIView to OpenGL.

00:20:16.940 --> 00:20:23.759
>> And then you insert your drawing code and you
present your contents from OpenGL to your UIView.

00:20:23.759 --> 00:20:26.789
So let's jump into the first of these steps.

00:20:26.789 --> 00:20:29.950
Step 1, customizing the UIView.

00:20:29.950 --> 00:20:37.610
This is, the-- so the connection between
OpenGL ES and your UIView is a CAEAGLLayer,

00:20:37.609 --> 00:20:43.039
and we do this by overwriting the
layer class of this-- of the UIView.

00:20:43.039 --> 00:20:45.259
And that code looks like this.

00:20:45.259 --> 00:20:51.690
It's very small, all you need to do is stick this at the
top of your code and I'll show you momentarily when we go

00:20:51.690 --> 00:20:58.410
to the next demo, this is what's at the top of
the EAGLView file that's created by the template.

00:20:58.410 --> 00:21:01.550
So this allows OpenGL to render into this view.

00:21:01.549 --> 00:21:06.289
So what is the CAEAGLLayer?

00:21:06.289 --> 00:21:10.710
It's your displayable color destination
for all of your OpenGL ES rendering.

00:21:10.710 --> 00:21:13.620
And it has a couple of properties that are useful for you.

00:21:13.619 --> 00:21:15.959
The first of these is color format.

00:21:15.960 --> 00:21:25.890
This allows you to choose if you want, RGB565,
RGBA8, or RGBA888, which is a 32-bit color format,

00:21:25.890 --> 00:21:28.840
and there's another property here called "retained backing."

00:21:28.839 --> 00:21:32.019
So the majority of you set this
to No and don't think about it.

00:21:32.019 --> 00:21:34.779
If you do think you might need
to use this, please come see us

00:21:34.779 --> 00:21:38.410
in the lab 'cause there are a lot
of nuances with this topic.

00:21:38.410 --> 00:21:44.230
So that brings us to step 2, initializing OpenGL ES.

00:21:44.230 --> 00:21:51.269
So we mentioned that this EAGLContext is this object, but
what it really is is it contains the connection to OpenGL.

00:21:51.269 --> 00:21:55.879
It contains all your state and contains your--
the command string that's sent to the GPU.

00:21:55.880 --> 00:22:04.660
It also allows you to select what version of the API
you want to use, if it's OpenGL ES 1.1 or OpenGL ES 2.0.

00:22:04.660 --> 00:22:12.360
And by default, the results of OpenGL ES rendering
don't go anywhere until you've set up your frame buffer.

00:22:12.359 --> 00:22:15.899
But you can start issuing API calls as
soon as you've created your context.

00:22:15.900 --> 00:22:19.900
So let's take a look at what this might look like in code.

00:22:19.900 --> 00:22:24.670
So, what you see up here is an
OpenGL ES 1.1 Context Initialization.

00:22:24.670 --> 00:22:28.390
This is exactly what's in the OpenGL ES template.

00:22:28.390 --> 00:22:34.060
First step here is to allocate your context and
then you initialize it with the API you want to use.

00:22:34.059 --> 00:22:37.269
In this case, OpenGL ES 1.1.

00:22:37.269 --> 00:22:39.579
Second step is to bind your context.

00:22:39.579 --> 00:22:47.220
This allows you to start issuing OpenGL ES Commands that
are associated with the version of the API you chose.

00:22:47.220 --> 00:22:52.880
And third part is the example function you can
call which is to query the renderer string.

00:22:52.880 --> 00:22:56.810
That brings us to step 3.

00:22:56.809 --> 00:23:01.970
You want to be able to connect
your UIView and OpenGL together.

00:23:01.970 --> 00:23:05.539
And we do this by configuring the framebuffer.

00:23:05.539 --> 00:23:09.799
So, this allows us to specify where OpenGL ES will render.

00:23:09.799 --> 00:23:13.379
And so there are a few key things here.

00:23:13.380 --> 00:23:18.130
OpenGL ES renders into what we call
renderbuffers and into textures.

00:23:18.130 --> 00:23:24.480
And then well, there are objects called framebuffer objects
that group the renderbuffers and the textures into color,

00:23:24.480 --> 00:23:28.630
depth and stencil groups so that the
OpenGL ES API can draw into them.

00:23:28.630 --> 00:23:36.400
And this is all a part of the OES_framebuffer_object
API that is available in ES 1.1 and 2.0.

00:23:36.400 --> 00:23:38.200
So let's take a closer look at renderbuffers.

00:23:38.200 --> 00:23:45.350
As I said before, renderbuffers are
where OpenGL ES draws its contents.

00:23:45.349 --> 00:23:48.339
And the APIs allow you to specify the format.

00:23:48.339 --> 00:23:54.859
So if you're using RGB or RGBA or depth or
stencil, you specify what you want to use

00:23:54.859 --> 00:23:57.939
and you also specify the width
and the height of the allocation.

00:23:57.940 --> 00:24:02.150
So that's how the-- that's what the renderbuffers are.

00:24:02.150 --> 00:24:05.610
But then there are also the framebuffer objects.

00:24:05.609 --> 00:24:09.269
These determine where OpenGL ES renders.

00:24:09.269 --> 00:24:12.000
And they're just groupings of renderbuffers.

00:24:12.000 --> 00:24:16.500
So think of it as you have one encapsulating
object called your framebuffer object

00:24:16.500 --> 00:24:21.690
that just groups your renderbuffers together
and it tells OpenGL ES where to draw.

00:24:21.690 --> 00:24:23.900
And it supports color depth and stencil.

00:24:23.900 --> 00:24:28.650
And the important thing to note about all
these is since there's a lot of flexibility

00:24:28.650 --> 00:24:33.150
of determining what your attachments are for the color,
depth, and stencil, you always need to check to make sure

00:24:33.150 --> 00:24:36.220
that it's supported and we'll talk about that momentarily.

00:24:36.220 --> 00:24:39.519
So, how do we fit this all together?

00:24:39.519 --> 00:24:44.849
We have our framebuffer objects, we have our
renderbuffers, and we have the Core Animation EAGLLayer.

00:24:44.849 --> 00:24:48.169
Well, first off, we want to create a color renderbuffer.

00:24:48.170 --> 00:24:49.259
So how do we do this?

00:24:49.259 --> 00:24:51.980
We generate a name for it.

00:24:51.980 --> 00:24:56.309
So glGenRenderbuffer, we bind the renderbuffer.

00:24:56.309 --> 00:25:04.659
And then there's a function on the EAGLContext that allows
us to connect the CAEAGLLayer to this color renderbuffer.

00:25:04.660 --> 00:25:08.980
This is done through renderbuffer storage from drawable.

00:25:08.980 --> 00:25:14.420
This is how you get an externally
visible color buffer bound into OpenGL.

00:25:14.420 --> 00:25:19.140
So that when you draw, your color
results end up in that layer.

00:25:19.140 --> 00:25:21.740
And it's subsequently visible onscreen.

00:25:21.740 --> 00:25:27.029
So that's how you attach the CAEAGLLayer
to your renderbuffer.

00:25:27.029 --> 00:25:33.490
Similarly, you have a depth renderbuffer, you
generate a name for it and you bind it, and then you--

00:25:33.490 --> 00:25:39.950
instead of having external buffer, you have-- you're
creating an internal private to OpenGL ES depth attachment

00:25:39.950 --> 00:25:43.690
so that you can draw your depth information.

00:25:43.690 --> 00:25:46.160
These two renderbuffers, we then want to connect together

00:25:46.160 --> 00:25:51.110
into a framebuffer object and this
follows a similar pattern.

00:25:51.109 --> 00:25:52.899
We generate a framebuffer object.

00:25:52.900 --> 00:25:54.080
We bind it.

00:25:54.079 --> 00:26:00.740
And then what we want to do is attach the color renderbuffer
to the color attachment point of the framebuffer object.

00:26:00.740 --> 00:26:04.650
This is done through glFramebufferRenderbuffer.

00:26:04.650 --> 00:26:06.550
Confusing name but it works.

00:26:06.549 --> 00:26:10.039
And you want to do the same thing for your depth buffer.

00:26:10.039 --> 00:26:13.109
And you bind it to the depth attachment.

00:26:13.109 --> 00:26:18.609
And as I mentioned earlier, you need to check to make sure
that the permutation of state that you chose for your color

00:26:18.609 --> 00:26:24.659
and depth and that all the renderbuffers are
at the same size with glTechFramebuffer status.

00:26:24.660 --> 00:26:27.920
As long as this succeeds, everything
is good and you can start drawing.

00:26:27.920 --> 00:26:32.320
So as I mentioned, there are some supported configurations.

00:26:32.319 --> 00:26:40.809
The iPhone, the iPhone 3G and all the iPods which are
PowerVR MBX Lite based, all support color and depth.

00:26:40.809 --> 00:26:46.839
The iPhone 3G S which is a PowerVR SGX
chip supports color, depth, and stencil.

00:26:46.839 --> 00:26:52.039
And that brings us to step 4, drawing your content.

00:26:52.039 --> 00:26:57.829
This is entirely up to you, as you can see, we
have some nice environment mapped photos here or--

00:26:57.829 --> 00:27:03.039
and other post-processing effects,
and some raytracing stuff.

00:27:03.039 --> 00:27:09.339
All this is possible in ES 2.0 and many of these things
are possible in ES 1.1 as you'll see in the second session.

00:27:09.339 --> 00:27:13.829
That brings us to step 5, presenting your content.

00:27:13.829 --> 00:27:15.980
So you've created your context.

00:27:15.980 --> 00:27:21.279
You've bound your CAEAGLLayer to
OpenGL, you've drawn into it.

00:27:21.279 --> 00:27:26.569
Now you need to present it to the
UIVIew and the rest of UIKit.

00:27:26.569 --> 00:27:30.189
You do this by binding the color renderbuffer

00:27:30.190 --> 00:27:34.870
and then calling present renderbuffer,
which is a method on the EAGLContext.

00:27:34.869 --> 00:27:40.699
That's all you need to do, and then it
shows up in the layer tree and onscreen.

00:27:40.700 --> 00:27:45.660
So as a summary, the first thing you
need to do is customize your UIView.

00:27:45.660 --> 00:27:50.110
This boils down to those two things I showed
you; specifying the layer class, and optionally,

00:27:50.109 --> 00:27:54.229
adding some drawable properties to
determine the initial color format.

00:27:54.230 --> 00:27:57.470
The second step is to create your OpenGL ES Context.

00:27:57.470 --> 00:28:01.700
Choose the version of the API you
want to use, and then start going.

00:28:01.700 --> 00:28:04.759
The third step was configuring your framebuffer.

00:28:04.759 --> 00:28:10.869
This is creating your framebuffer object
and attaching your CAEAGLLayer to OpenGL.

00:28:10.869 --> 00:28:13.989
Fourth step is drawing the content, pretty self-explanatory.

00:28:13.990 --> 00:28:19.180
And fifth step is presenting your
content from OpenGL to the UIView.

00:28:19.180 --> 00:28:24.170
That's great but I have-- or told
you how to do this in ES 2.

00:28:24.170 --> 00:28:26.830
The good news is it's basically the same.

00:28:26.829 --> 00:28:32.829
The only difference is the second step, and that's
because you need to choose a different version of to API

00:28:32.829 --> 00:28:35.039
to initialize your EAGLcontext with.

00:28:35.039 --> 00:28:39.490
So show you some code of what this looks like.

00:28:39.490 --> 00:28:44.900
Just like you saw before, you need to allocate
your EAGLContext and then you initialize it

00:28:44.900 --> 00:28:51.110
with the rendering API OpenGL ES 2 as
supposed to the rendering API OpenGL ES 1.

00:28:51.109 --> 00:28:57.679
So the important thing to note is that this can fail
if the underlying hardware doesn't support ES 2.

00:28:57.680 --> 00:29:03.289
So that brings us to the second part of this
which is if 2.0 isn't supported, 1.1 is supported.

00:29:03.289 --> 00:29:07.589
And you can allocate and then initialize
your context to support ES 1.1.

00:29:07.589 --> 00:29:15.029
So let's take a look at how you build an
OpenGL ES 1.1 and 2.0 compatible application.

00:29:15.029 --> 00:29:18.299
So first off, I'm just going to run the application.

00:29:18.299 --> 00:29:20.960
So you have an idea of what it actually does.

00:29:20.960 --> 00:29:24.230
So what you see here is the Stanford Rabbit.

00:29:24.230 --> 00:29:32.579
This is an OpenGL ES 1.1 and it's doing per
vertex lighting, both diffused and specular.

00:29:32.579 --> 00:29:39.099
Now I'm going to have it switch on the
fly to OpenGL ES 2.0 by just clicking.

00:29:39.099 --> 00:29:47.559
So as I mentioned before, OpenGL ES 2.0 can
do everything OpenGL ES 1.1 can and more.

00:29:47.559 --> 00:29:49.309
So this is the exact same thing.

00:29:49.309 --> 00:29:53.829
But since it's OpenGL ES 2.0, we did
make some kind-- a few changes to it.

00:29:53.829 --> 00:29:57.869
First of these is added deformation of the model.

00:29:57.869 --> 00:30:03.879
So I'm clicking and holding and now the rabbit
is inflating, and he'll bounce back and forth.

00:30:03.880 --> 00:30:06.180
So this is happening in the vertex shader.

00:30:06.180 --> 00:30:12.100
So this was not possible on ES 1.1 running on the hardware.

00:30:12.099 --> 00:30:17.509
>> You could always do it on the CPU, but then that's a
lot of wasted work and a lot of power that you've consumed.

00:30:17.509 --> 00:30:22.829
ES 2.0 allows you to do this in
real time on the actual hardware.

00:30:22.829 --> 00:30:28.669
So that's great, and I'm going to inflate
it again and we can see as we zoom in,

00:30:28.670 --> 00:30:30.590
the specular highlights look kind of funny.

00:30:30.589 --> 00:30:34.639
So-- 'cause there's all the-- because our per
vertex see-- see [phonetic] all the triangles.

00:30:34.640 --> 00:30:38.610
So now I'm going to switch to a
different mode, which is per pixel.

00:30:38.609 --> 00:30:45.619
This is something that you can only really do in ES
2.0, and you can see that it's not quite as sharp as--

00:30:45.619 --> 00:30:51.250
or as jagged as the ES 1.1 version, and the
version that I just showed you, it was per vertex.

00:30:51.250 --> 00:30:52.730
It's much smoother and much nicer.

00:30:52.730 --> 00:31:00.539
So let's go to another fact that you can only
do in ES 2 which is refraction and reflection.

00:31:00.539 --> 00:31:05.009
So what we here is an environment map,
and we're treating the bunny like glass.

00:31:05.009 --> 00:31:14.029
So we have everything in the scene being shown
through the rabbit and it too can be deformed

00:31:14.029 --> 00:31:17.240
as you can see, and so you have all these cool effects.

00:31:17.240 --> 00:31:23.430
And you can see that there's-- it pretty much
matches to the environment, it's nice and pretty.

00:31:23.430 --> 00:31:25.240
And we can go one step further with this.

00:31:25.240 --> 00:31:32.569
We can actually do refraction on a per vertex
basis, or sorry, on a per RGB component basis.

00:31:32.569 --> 00:31:35.879
So you get kind of like a prismatic effect.

00:31:35.880 --> 00:31:37.940
It's really quite interesting.

00:31:37.940 --> 00:31:42.420
So these are some of the things that you can do
in ES 2 that you just couldn't do in ES 1.1--

00:31:42.420 --> 00:31:46.620
or ES 1.1 because the hardware
couldn't-- or was not capable of it.

00:31:46.619 --> 00:31:52.149
So, now that I've shown you that, let's go
and see how the five steps that I talked

00:31:52.150 --> 00:31:55.000
about earlier are mapped out in the template.

00:31:55.000 --> 00:32:00.279
So I'm going to start with the EAGLView
and the first thing you can see is step 1,

00:32:00.279 --> 00:32:08.089
which is specifying that the layerClass that
backs the UIView that you created is a CAEAGLLayer

00:32:08.089 --> 00:32:12.169
and in order to allow OpenGL ES to render into it.

00:32:12.170 --> 00:32:19.890
The second part of this is actually setting up
those drawable properties that we mentioned.

00:32:19.890 --> 00:32:27.280
So how you do this is you get the layer that backs
the UIView, that's the self.layer and then you--

00:32:27.279 --> 00:32:30.819
on that layer, you mark it as opaque,
which because you always want to do this

00:32:30.819 --> 00:32:33.899
for performance reasons, and then
you want to set the properties.

00:32:33.900 --> 00:32:43.269
So in this specific case, set it as RGBA888, so it's a
32-bit color format and turns off the retained backing flag.

00:32:43.269 --> 00:32:49.639
Following that, we then initialize an
ES 1.1 renderer and we start drawing.

00:32:49.640 --> 00:32:53.380
So let's take a look at the ES 1.1 renderer code.

00:32:53.380 --> 00:32:58.190
And that brings us to step 2.

00:32:58.190 --> 00:33:02.000
So just like you saw in the EAGL
template, you need to allocate

00:33:02.000 --> 00:33:06.160
and initialize your EAGLContext with a specific API.

00:33:06.160 --> 00:33:09.960
This object manages the ES 1 API.

00:33:09.960 --> 00:33:17.950
And allocates it, binds it, and sets up some
initial state in order to start drawing.

00:33:17.950 --> 00:33:24.350
And just like Alex had shown you previously, the
template also supports configuring the framebuffer.

00:33:24.349 --> 00:33:28.539
So this section needs to be zoomed out just a bit.

00:33:28.539 --> 00:33:35.700
But how this works is you generate the framebuffer object,
you bind it, and then you create a renderbuffer object

00:33:35.700 --> 00:33:41.000
for your color attachment, you bind it, and then
there's that function I was talking about earlier

00:33:41.000 --> 00:33:45.089
which is the EAGLContext renderbufferStorage from drawable.

00:33:45.089 --> 00:33:51.759
And as you can see, you pass in the renderbuffer enum to
specify where it's going to bind on the OpenGL ES Context

00:33:51.759 --> 00:33:55.230
and the layer which is the Core Animation EAGLLayer.

00:33:55.230 --> 00:34:01.599
This connects the two objects and then you can bind
that renderbuffer to the framebuffer object using this.

00:34:01.599 --> 00:34:06.349
So the other thing to note is that since your layer
is going to animate, you also want to make sure

00:34:06.349 --> 00:34:09.639
that you query the right dimensions out of the object.

00:34:09.639 --> 00:34:15.500
So this function gets called whenever
your layer or-- and your view resizes.

00:34:15.500 --> 00:34:20.150
So you can query out the width and the height into
local variables and this is important because you need

00:34:20.150 --> 00:34:26.220
to have your depth allocation via the same dimensions
in order for it to successfully pair with the color

00:34:26.219 --> 00:34:28.699
and the depth attachment into a framebuffer object.

00:34:28.699 --> 00:34:33.519
And then finally at the end, we check to make sure

00:34:33.519 --> 00:34:37.039
that everything succeeded happily and
this allows us to start rendering.

00:34:37.039 --> 00:34:41.559
So let's take a look at the drawing code.

00:34:41.559 --> 00:34:46.500
So just like Alex said before, there's a function
that allows you to render, it gets called back,

00:34:46.500 --> 00:34:52.269
you bind your context to make sure that you can issue
drawing commands, and you bind your framebuffer object.

00:34:52.269 --> 00:34:57.509
You set the view port, and then you render
your scene and then you get to what was step 5,

00:34:57.510 --> 00:35:00.930
which is presenting what you just rendered.

00:35:00.929 --> 00:35:04.119
So usually, step 4 and step 5 go in hand in hand like this.

00:35:04.119 --> 00:35:10.609
You draw your content, and if your drew content,
you then present the new changes to your UIView.

00:35:10.610 --> 00:35:15.960
So that's how the OpenGL ES 1.1 Render object works.

00:35:15.960 --> 00:35:19.500
So let's take a look at how things
change for the ES 2.0 renderer.

00:35:19.500 --> 00:35:23.820
So it's very similar.

00:35:23.820 --> 00:35:31.590
We just initialize our EAGLContext with OpenGL ES 2
instead of OpenGL ES 1, and as long as this succeeds,

00:35:31.590 --> 00:35:36.400
then we go through the whole initialization
sequence and start drawing our stuff.

00:35:36.400 --> 00:35:42.039
And once again, the framebuffer setup is nearly identical.

00:35:42.039 --> 00:35:48.650
Exact same sequence, you can actually use the exact
same functions with the OES suffix if you so desire.

00:35:48.650 --> 00:35:53.250
But the framebuffer object API was
pulled into the OpenGL ES 2.0 Core.

00:35:53.250 --> 00:35:55.340
So you don't have to use the suffix if you don't want to.

00:35:55.340 --> 00:35:57.250
You can have both of them, doesn't matter.

00:35:57.250 --> 00:36:01.650
But for simplicity, we dropped it
in the ES 2.0 version of the code.

00:36:01.650 --> 00:36:06.019
It's doing the exact same sequence and operations
however, creating a framebuffer, creating the colorbuffer,

00:36:06.019 --> 00:36:14.469
binding the renderbuffer from the
EAGLLayer, and exact same steps.

00:36:14.469 --> 00:36:18.309
And drawing once again is pretty much
the same sequence, bind your context,

00:36:18.309 --> 00:36:21.549
bind your framebuffer, draw and then present.

00:36:21.550 --> 00:36:25.970
So there's a bunch of similarities
between the 1.1 and 2.0 APIs.

00:36:25.969 --> 00:36:32.909
And the only real difference is what version of
the API you chose to initialize your context with.

00:36:32.909 --> 00:36:35.309
So if we could go back to the slides.

00:36:35.309 --> 00:36:38.940
So we just showed you how to use the OpenGL ES template,

00:36:38.940 --> 00:36:42.780
how to create your application,
and how will pieces fit together.

00:36:42.780 --> 00:36:46.110
The latter part of it is a little more complicated.

00:36:46.110 --> 00:36:51.590
So if all you-- all you have to
know is just open up the OpenGL ES--

00:36:51.590 --> 00:36:57.110
OpenGL ES template and then if you want to
use 2.0, just add that one-line change from--

00:36:57.110 --> 00:37:00.340
to select the ES 2.0 rendering API instead.

00:37:00.340 --> 00:37:02.890
At this point, I'd like to bring up Alex Kan to talk

00:37:02.889 --> 00:37:09.009
about how your content gets composited
with the rest of the iPhone OS.

00:37:09.010 --> 00:37:15.780
[ Applause ]

00:37:15.780 --> 00:37:22.980
>> OK, so, as Michael mentioned early in the presentation,
there are a lot of similarities between how 2D content gets

00:37:22.980 --> 00:37:25.619
to the screen and how 3D content gets to the screen.

00:37:25.619 --> 00:37:31.190
And namely, the only difference is that the
UIViews that you used for 3D rendering are backed

00:37:31.190 --> 00:37:35.070
by CAEAGLLayers instead of regular CALayers.

00:37:35.070 --> 00:37:42.220
So let's take a look at what that actually means
for you in terms of using UIKit with GL Content.

00:37:42.219 --> 00:37:46.639
And so, what you'll find is that most
things behave exactly the way that they did

00:37:46.639 --> 00:37:51.039
when you were using UIKit for 2D content.s-tyl

00:37:51.039 --> 00:37:54.889
So namely, when you call present
renderbuffer to update your content,

00:37:54.889 --> 00:37:58.679
what you'll find is that the contents
basically stay in that state

00:37:58.679 --> 00:38:02.349
until you call present renderbuffer
to update that content again.

00:38:02.349 --> 00:38:08.989
In addition, any UIView properties that you are used
to applying, such as transforms, positions, alphas,

00:38:08.989 --> 00:38:14.019
all these things continue to apply to
UIViews that are backed by CAEAGLLayers.

00:38:14.019 --> 00:38:20.889
And also, in addition to being able to fade these layers
in and out, CA will obey the same compositing model

00:38:20.889 --> 00:38:25.589
that it uses to blend 2D content
when it blends your 3D content.

00:38:25.590 --> 00:38:32.019
So there is one difference that you need to be aware
of, which is that if you create a CAEAGLLayer explicitly

00:38:32.019 --> 00:38:38.900
by you know, setting up a UIView subclass
that uses CAEAGLLayer instead of CALayer,

00:38:38.900 --> 00:38:45.099
or by allocating a CAEAGLLayer at yourself, what you'll
find is that the layer is marked opaque by default,

00:38:45.099 --> 00:38:47.429
which is a slight difference from what you'll find

00:38:47.429 --> 00:38:50.849
if you just use a regular UIView
'cause these are not opaque by default.

00:38:50.849 --> 00:38:53.789
But what do all these similarities mean for you?

00:38:53.789 --> 00:39:00.460
It means that when you use GL Content and
UIKit, those views that you draw GL Content

00:39:00.460 --> 00:39:03.599
into are basically first-class
citizens in your view hierarchy.

00:39:03.599 --> 00:39:08.400
It means that you can do anything
that you could to 2D content.

00:39:08.400 --> 00:39:14.610
But of course, if you're working on a game that's
just mainly 3D and you're no=t really dealing or-- in--

00:39:14.610 --> 00:39:18.140
you're not intending to deal with the
window system, you maybe wondering, "Well,

00:39:18.139 --> 00:39:20.900
how do I know that this is going to be fast?"

00:39:20.900 --> 00:39:25.369
And so, it is true that some compositing
operations are faster than others.

00:39:25.369 --> 00:39:30.690
And there are a couple simple rules that you can
keep in mind to make sure that things stay fast.

00:39:30.690 --> 00:39:36.190
And what you'll actually find is that
if you have played with performances,

00:39:36.190 --> 00:39:41.829
many of the rules that applied there also apply
here but on some level, they're even more important.

00:39:41.829 --> 00:39:46.389
So let's-- let's take a look.

00:39:46.389 --> 00:39:51.369
So what you'll generally find is
if you have a view with GL Content,

00:39:51.369 --> 00:39:55.469
you'll be able to update the screen
faster if that view remains untransformed.

00:39:55.469 --> 00:39:59.629
I.e.-- like, meaning you don't rotate it or scale it.

00:39:59.630 --> 00:40:07.130
And things are generally fastest if the rectangle
defining your GLView stays aligned to pixel boundaries.

00:40:07.130 --> 00:40:10.130
So the nice thing about this is that
this is something that you can check,

00:40:10.130 --> 00:40:14.250
I mean that you can already check using the
Core Animation Instrument and Instruments just

00:40:14.250 --> 00:40:21.130
by checking the color misaligned images checkbox
if you're running your app through instruments.

00:40:21.130 --> 00:40:27.289
>> So next, let's take a look at what you need
to think about when you're blending GL Content.

00:40:27.289 --> 00:40:33.570
And what we actually recommend is that you should keep
your views or your GLViews opaque whenever possible.

00:40:33.570 --> 00:40:39.680
So now, this has two aspects to it, the
first of which is that the Core Animation,

00:40:39.679 --> 00:40:43.710
or you must signal the Core Animation that
the actual Contents of your view are opaque.

00:40:43.710 --> 00:40:45.349
There are two ways that you can do this.

00:40:45.349 --> 00:40:50.989
Michael mentioned the drawable properties
for the CAEAGLLayer earlier in the talk.

00:40:50.989 --> 00:40:57.329
And so what you can do is you can pick a color format
for your CAEAGLLayer that has no alpha channel.

00:40:57.329 --> 00:41:01.480
Now you can also explicitly hint to Core Animation
that even for an image with alpha channel for--

00:41:01.480 --> 00:41:06.980
or even for an image with an alpha channel that
you want Core Animation to treat that as opaque

00:41:06.980 --> 00:41:14.869
by just simply setting the opaque property on
that layer or on the view that that layer backs.

00:41:14.869 --> 00:41:21.159
And so I said that there's a second aspect to this, which is
that even if Core Animation knows that your layer is opaque,

00:41:21.159 --> 00:41:25.869
you need to make sure that your view is being drawn at
full opacity and that's just a matter of making sure

00:41:25.869 --> 00:41:31.269
that your views opacity is set to
1.0 whenever your view is onscreen.

00:41:31.269 --> 00:41:36.389
So the nice thing about this is that it doesn't
preclude you from using other UIKit elements or--

00:41:36.389 --> 00:41:41.569
and it also doesn't preclude the system from putting
up other UIKit elements on your behalf, such as alerts,

00:41:41.570 --> 00:41:47.050
or more interestingly, the system keyboard, which
you can basically bring up over your GL Content

00:41:47.050 --> 00:41:50.010
if you ever need to get text input from the user.

00:41:50.010 --> 00:41:54.490
So that saves you the trouble of
having to implement your own keyboard.

00:41:54.489 --> 00:42:00.379
So a small note about OpenGL ES Content that
you actually want to blend over other content.

00:42:00.380 --> 00:42:04.380
Even though we don't recommend this, there's one
important thing that you need to keep in mind,

00:42:04.380 --> 00:42:09.130
which is that Core Animation uses premultiplied
alpha everywhere in the UI for blending

00:42:09.130 --> 00:42:12.079
and your app will need to obey the same rules as well.

00:42:12.079 --> 00:42:17.880
And so because this is kind of an in-depth topic, we
recommend that if you need to do anything like this, come--

00:42:17.880 --> 00:42:23.550
to come to talk to us in one of the labs.

00:42:23.550 --> 00:42:28.870
And so one other thing that you may have done to
regular 2D content, which you may want to apply

00:42:28.869 --> 00:42:32.130
to your 3D content, are animations and view effects.

00:42:32.130 --> 00:42:39.030
And there's a simple thing to keep in mind here, which
is that these animations and transitions will run faster

00:42:39.030 --> 00:42:45.300
if you're not updating your GL Content at the same time by
you know, with your render callback or something like that.

00:42:45.300 --> 00:42:52.470
So what you want to do in this situation is pause that timer
or whatever mechanism you're using to update the contents

00:42:52.469 --> 00:42:57.519
of your GLView whenever you also want
to run a transition or animation.

00:42:57.519 --> 00:43:06.009
So what I have for you is an example app that
demonstrates these particular principles in action.

00:43:06.010 --> 00:43:14.540
[ Pause ]

00:43:14.539 --> 00:43:16.009
>> OK.

00:43:16.010 --> 00:43:22.770
[ Pause ]

00:43:22.769 --> 00:43:24.789
>> So let me run the app for you.

00:43:24.789 --> 00:43:29.679
We won't take a look at the source core in
particular but I'll show you what this app is doing.

00:43:29.679 --> 00:43:38.559
So here, we have a torus rendering in a window with
what looks like rounded corners, and what we can do,

00:43:38.559 --> 00:43:45.880
is we can actually flip this around and we can
apply vignetting effect to the entire screen.

00:43:45.880 --> 00:43:49.890
And so now, you can see that we've
darkened the edges of the screen, you know,

00:43:49.889 --> 00:43:55.400
and an additional thing you can do is you can drag
the slider back and forth to change the alpha.

00:43:55.400 --> 00:44:02.389
So now that I've shown you the demo, let's
take a look at how it's actually constructed.

00:44:02.389 --> 00:44:06.009
Can we go back to the slides please?

00:44:06.010 --> 00:44:10.540
[ Pause ]

00:44:10.539 --> 00:44:12.539
>> So what you saw in screen probably looks a lot like this.

00:44:12.539 --> 00:44:15.440
And so I'm going to break it out
into its component layers now.

00:44:15.440 --> 00:44:20.280
So the vignetting effect is actually
achieved by having a separate image

00:44:20.280 --> 00:44:23.540
that we just faded in and out over our GL Content.

00:44:23.539 --> 00:44:28.210
And so, let's pull out another layer, which
is the rounded corners and we actually do this

00:44:28.210 --> 00:44:31.449
by drawing a rounded rectangle of black over the content.

00:44:31.449 --> 00:44:34.359
And so the important thing to note here is

00:44:34.360 --> 00:44:39.260
that we've achieved this effect even
while keeping our GL Content opaque

00:44:39.260 --> 00:44:41.650
because all we need to do is draw these effects over it.

00:44:41.650 --> 00:44:48.380
And the nice thing about this is that because you're
doing this via UIKit, laying out things like Complex UI,

00:44:48.380 --> 00:44:54.539
you can do just using the regular UIKit view
hierarchy and you don't have to go through the trouble

00:44:54.539 --> 00:44:59.279
of repeatedly drawing this every single frame
whenever you're updating your GL Content.

00:44:59.280 --> 00:45:07.090
And so to summarize, basically, this is like repeating
the sorts of rules that you would need to keep

00:45:07.090 --> 00:45:10.920
in mind whenever you're doing 2D content in UI-Kit.

00:45:10.920 --> 00:45:16.309
And, but first of all, I mean everything that
you're used to should continue to work even

00:45:16.309 --> 00:45:19.079
if you're dealing with 3D content instead of 2D.

00:45:19.079 --> 00:45:23.739
But a couple simple rules to follow are that you
need to keep your views screen-aligned and opaque.

00:45:23.739 --> 00:45:28.239
And that's really all there is to it to
make sure that your compositing stays fast.

00:45:29.929 --> 00:45:37.109
So let's talk a little bit about what the release
of the iPhone 3G S means for you in terms of dealing

00:45:37.110 --> 00:45:40.120
with this new piece of hardware and this new GPU.

00:45:40.119 --> 00:45:47.029
So this manifests itself in three ways,
the first of which is the API support.

00:45:47.030 --> 00:45:53.280
Michael has already mentioned that open--
that the iPhone 3G S adds support for ES 2.0.

00:45:53.280 --> 00:45:57.340
And an important thing for you to
remember is that it also supports ES 1.1.

00:45:57.340 --> 00:46:03.210
So if you wanted-- if you want to target
an app to all phones and all iPod Touches,

00:46:03.210 --> 00:46:06.360
you can continue to do that through ES 1.1.

00:46:06.360 --> 00:46:12.090
So digging down into more specifics, [clears
throat] or actually, I'm sorry, one more thing.

00:46:12.090 --> 00:46:18.590
Now if you do decide to target iPhone 3G S
in particular, it's important that you hint

00:46:18.590 --> 00:46:24.760
that your application requires ES 2.0 by editing
the Info.plist for your application in Xcode.

00:46:24.760 --> 00:46:30.150
And so the important thing to keep in mind or the important
thing to put in is this line that I've highlighted in blue.

00:46:30.150 --> 00:46:35.200
So you'll need to add the required device
capabilities called "OpenGL ES 2.0."

00:46:35.199 --> 00:46:39.969
Hopefully, that's readable to you guys.

00:46:39.969 --> 00:46:48.939
So second, even in ES 1.1, implementations may
differ in functionality from device to device.

00:46:48.940 --> 00:46:52.159
And so how this typically manifests itself is extensions.

00:46:52.159 --> 00:46:56.329
And so what extensions allow piece--
particular pieces of hardware or implemented--

00:46:56.329 --> 00:47:03.679
or drive implementations to do is to provide additional
functionality beyond what ES 1.1 already provides.

00:47:03.679 --> 00:47:09.079
And so the caveat to using this functionality
is that you need to query for its existence.

00:47:09.079 --> 00:47:13.480
And so, this can-- like I said,
this can vary from device to device.

00:47:13.480 --> 00:47:18.400
So it's important that you query whenever
you intend to use this functionality.

00:47:18.400 --> 00:47:29.579
So let's take a look at the set of extensions that are--
that you might see on iPhone OS devices, running ES 1.1.

00:47:29.579 --> 00:47:34.000
And so if you've seen this list before last year,
you'll notice that there are actually three new entries

00:47:34.000 --> 00:47:40.699
and these are extensions that were
recently added for-- with iPhone 3G S.

00:47:40.699 --> 00:47:44.939
OK, so let's take a look at the
list of extensions for ES 2.0.

00:47:44.940 --> 00:47:50.079
What you'll notice is that this list is a
lot shorter because ES 2.0 is a newer API,

00:47:50.079 --> 00:47:53.349
what has happened is that a lot of
functionality that used to be optional

00:47:53.349 --> 00:48:01.269
in ES 1.1 has now been absorbed into
the core functionality of ES 2.0.

00:48:01.269 --> 00:48:07.219
So the third thing that you need to keep in mind,
is that because iPhone 3G S is a more powerful GPU--

00:48:07.219 --> 00:48:14.769
or has a more powerful GPU than the GPU found
in previous iPhones is that some of the--

00:48:14.769 --> 00:48:20.289
some of things that it can do-- well, it
can-- well, yeah, it can do more things.

00:48:20.289 --> 00:48:22.340
It can support larger texture sizes.

00:48:22.340 --> 00:48:27.250
It can support more texture units for more
complicated effects using texture combiners

00:48:27.250 --> 00:48:29.719
in ES 1.1, and of course it supports shaders.

00:48:29.719 --> 00:48:35.189
And the important thing to keep in mind is here, as with the
other things, is that if you intend to use functionality,

00:48:35.190 --> 00:48:38.769
you need to make sure that the hardware
that you're running on supports that.

00:48:38.769 --> 00:48:41.679
So you need to query the limits to
make sure that you're using a number

00:48:41.679 --> 00:48:45.219
of texture units that's actually available
on the system that you're running.

00:48:45.219 --> 00:48:57.349
So in summary, I mean, the general thing to take away from
the addition of iPhone 3G S to the set of iPhone OS devices,

00:48:57.349 --> 00:49:00.860
is that you generally can't assume that
functionality is going to be there.

00:49:00.860 --> 00:49:06.420
So, and of course, OpenGL provides a mechanism
for you to ensure that this is the case.

00:49:06.420 --> 00:49:09.110
And so what you need to do is you
need to query your extension limits.

00:49:09.110 --> 00:49:14.690
You need to-- or you need to query you extensions,
you need to query your implementation limits,

00:49:14.690 --> 00:49:22.679
and as Michael showed you before with ES 2.0, you know,
attempting to create an ES 2.0 Context may return nil,

00:49:22.679 --> 00:49:27.719
in which case, you need to prepare to fall back
if you're not creating a 2.0-specific application.

00:49:27.719 --> 00:49:35.519
So that basically should hopefully cover everything
you need to do, I mean everything you need

00:49:35.519 --> 00:49:38.909
to know to get started with OpenGL ES on iPhone.

00:49:38.909 --> 00:49:42.859
So if you have any more questions,
you know, feel free to contact our,

00:49:42.860 --> 00:49:45.280
where's he at, our Technology Evangelist, Allan.
WEBVTT

00:00:13.529 --> 00:00:14.129
>> All right.

00:00:14.130 --> 00:00:16.170
Good morning, everyone.

00:00:16.170 --> 00:00:19.900
I hope you all had a good time at the bash last night.

00:00:19.899 --> 00:00:24.969
But not too good a time, so I want you all to be
alert and awake for our presentation this morning.

00:00:24.969 --> 00:00:28.210
We're going to be talking about text processing in Cocoa.

00:00:28.210 --> 00:00:34.399
Now, in previous years, we spent quite a
bit of time talking about display of text

00:00:34.399 --> 00:00:38.359
and the editing of text and various UI aspects of text.

00:00:38.359 --> 00:00:43.079
This time around, we're going to be talking
about lower level non-UI processing of text,

00:00:43.079 --> 00:00:45.659
and we're going to do this the Cocoa way,

00:00:45.659 --> 00:00:50.859
which means thoroughly Unicode-based
with NSString as the fundamental object.

00:00:50.859 --> 00:00:55.369
And I mean a little bit more by that than
just that you're going to be using NSString.

00:00:55.369 --> 00:01:01.349
I mean, we always say that conceptually, an
NSString is a sequence of Unicode characters.

00:01:01.350 --> 00:01:08.810
But what we wanted you to do is to deal with
strings and the substrings and with ranges

00:01:08.810 --> 00:01:11.960
of strings and not with the individual characters.

00:01:11.959 --> 00:01:17.589
Because time after time in Unicode context, it
happens that where you might expect to be dealing

00:01:17.590 --> 00:01:23.270
with a single character, in certain circumstances you're
going to have to deal potentially with more than one.

00:01:23.269 --> 00:01:30.119
And when I talk about all the framework APIs
that make it really easy and quick to do this.

00:01:30.120 --> 00:01:32.270
And I've divided the talk into 3 parts.

00:01:32.269 --> 00:01:37.959
In the first part, I'll talk about getting
the text into and out of your application.

00:01:37.959 --> 00:01:41.669
In the second part, we'll talk about
processing it once it's in your application.

00:01:41.670 --> 00:01:46.920
And in the third part, we're going to talk
about some new functionality in Snow Leopard.

00:01:46.920 --> 00:01:54.349
Now, I should mention that except for that last part,
a lot of this talk is applicable to both Mac OS X

00:01:54.349 --> 00:02:01.890
and the iPhone OS, except for a few methods that are
maybe specific to Snow Leopard or specific to the AppKit,

00:02:01.890 --> 00:02:07.640
and we'll try to call those out from
time to time as we run across them.

00:02:07.640 --> 00:02:09.669
So first part.

00:02:09.669 --> 00:02:16.399
Now, before your text gets in to your NSString, it's
probably stored somewhere else, and after you deal with it

00:02:16.400 --> 00:02:21.090
and process it, you may want to store
it off some place else more permanent.

00:02:21.090 --> 00:02:23.759
So we'll talk about how to do that in Cocoa.

00:02:23.759 --> 00:02:27.569
Cocoa philosophy is to make simple things simple.

00:02:27.569 --> 00:02:31.949
So in keeping with that, in the very
simplest situations, for example,

00:02:31.949 --> 00:02:35.869
where you want to read an entire
plain text file with a known encoding

00:02:35.870 --> 00:02:39.159
or want to write an entire plain
text file with a known encoding.

00:02:39.159 --> 00:02:46.560
We'll make that very simple, just one line of code,
one method on NSString to do either one or the other.

00:02:46.560 --> 00:02:48.810
All right, that's very straightforward.

00:02:48.810 --> 00:02:53.819
But at this point, I suppose I
should say something about encodings.

00:02:53.819 --> 00:03:01.479
Your string is conceptually a sequence of Unicode characters
that-- in order to store it in some persistent format--

00:03:01.479 --> 00:03:09.079
that needs to be converted into a very concrete sequence
of bytes, and the recipe for doing that is in encoding.

00:03:09.080 --> 00:03:14.730
Now, the situation with regard to encodings now
is much better than it has been historically.

00:03:14.729 --> 00:03:17.149
We have the universal encoding, it's called UTF-8.

00:03:17.150 --> 00:03:19.640
You should use it wherever possible.

00:03:19.639 --> 00:03:24.629
Occasionally, you may wish to use
UTF-16 with the byte ordering mark

00:03:24.629 --> 00:03:28.979
to specify the NDNS, maybe UTF-32, but probably not.

00:03:28.979 --> 00:03:31.340
But these are all Unicode encodings.

00:03:31.340 --> 00:03:35.719
They can all represent any string
that you're going to run across.

00:03:35.719 --> 00:03:37.750
They're all good.

00:03:37.750 --> 00:03:45.270
Unfortunately, there are still quite a bit of legacy
data in other encodings that you may need to import

00:03:45.270 --> 00:03:50.770
and NSString will take care of all these for you,
just specify the encoding and it will convert it.

00:03:50.770 --> 00:03:53.150
Of course, you should know the encoding.

00:03:53.150 --> 00:03:56.890
That should be part of your specification,
and I'll talk a little bit later

00:03:56.889 --> 00:04:02.139
about what to do if you don't know the encoding.

00:04:02.139 --> 00:04:08.500
But one thing the previous NSString writing
method does as part of encoding handling,

00:04:08.500 --> 00:04:13.789
is that when you write out a plain text
file, it will add an extended attribute to it

00:04:13.789 --> 00:04:16.699
that specifies the encoding that you use to write it out.

00:04:16.699 --> 00:04:23.319
And so another method on NSString that you can use to read
back one of those files, and it will take the encoding

00:04:23.319 --> 00:04:27.750
from that extended attribute that was written to it.

00:04:27.750 --> 00:04:32.730
Now, one thing we all can ask in Cocoa text processing is.

00:04:32.730 --> 00:04:34.100
What is it that TextEdit does?

00:04:34.100 --> 00:04:38.770
Now TextEdit doesn't actually use this method
although it does use this functionality.

00:04:38.769 --> 00:04:46.099
What TextEdit uses is a similar method on, actually
on NSAttributedString you find in the AppKit.

00:04:46.100 --> 00:04:51.080
And this does what that other method
does, but it does a whole lot more.

00:04:51.079 --> 00:04:54.779
So this AttributedString method
can read not only plain text files,

00:04:54.779 --> 00:05:00.669
but also rich text documents in a wide variety of formats.

00:05:00.670 --> 00:05:07.740
Again, very simply, a single line of code, now
one possible-All right, this is written in terms

00:05:07.740 --> 00:05:11.310
of attributed strings rather than strings,
but it's really simple to convert back

00:05:11.310 --> 00:05:13.649
and forth between strings and attributed strings.

00:05:13.649 --> 00:05:16.449
A reattributed string has an underlying
string you can get quickly.

00:05:16.449 --> 00:05:20.379
It's easy to create an attributed
string from a string and so on.

00:05:20.379 --> 00:05:27.620
One possible complicating factor is that
this method involves 2 dictionaries.

00:05:27.620 --> 00:05:31.459
There is one dictionary that you pass
in, that's the Options Dictionary,

00:05:31.459 --> 00:05:35.180
and then there's one that you get back
out, that's the Attributes Dictionary.

00:05:35.180 --> 00:05:37.490
So with the Options Dictionary can pass in things

00:05:37.490 --> 00:05:42.970
like what document formats you think the
document is in, what encoding you think it is in.

00:05:42.970 --> 00:05:47.210
And when the attributes that get back
out tell you what form it was actually in

00:05:47.209 --> 00:05:50.609
and what encoding it was actually read as.

00:05:50.610 --> 00:05:58.240
And similarly, you can write using attributed
strings, and the most general way to do this is

00:05:58.240 --> 00:06:02.480
with this AttributedString method
that produces a fileWrapper.

00:06:02.480 --> 00:06:04.050
Well, fileWrapper.

00:06:04.050 --> 00:06:07.759
Well, NSFileWrapper is a great class,
it's much improved in Snow Leopard.

00:06:07.759 --> 00:06:11.310
It's probably heard at the What's New on Cocoa talk.

00:06:11.310 --> 00:06:19.240
But the reason we're using it here is because the
fileWrapper can represent not only a simple single file,

00:06:19.240 --> 00:06:23.230
but also a document that makes a system
more than one file package for example.

00:06:23.230 --> 00:06:29.100
Also, a fileWrapper can now represent that
extended attribute that we mentioned before.

00:06:29.100 --> 00:06:32.790
So writing it out like this, getting
a fileWrapper and then writing

00:06:32.790 --> 00:06:39.180
out the fileWrapper can support the
extended attribute that I mentioned before.

00:06:39.180 --> 00:06:45.400
Now, if you're not dealing with a single
file or a single plain text document,

00:06:45.399 --> 00:06:49.929
or you get the text from somewhere
else, there are ways to handle that too.

00:06:49.930 --> 00:06:56.439
We have parallel methods that do all the
same sorts of things with the text data

00:06:56.439 --> 00:07:00.319
as data, or maybe it's just a sequence of bytes.

00:07:00.319 --> 00:07:05.750
We have similar methods for reading and
also very similar methods for writing.

00:07:05.750 --> 00:07:10.470
Just do exactly the same thing.

00:07:10.470 --> 00:07:17.200
Now at this point, I want to say something about
the case where you don't know the encoding.

00:07:17.199 --> 00:07:23.370
Now, this is an unfortunate situation,
but we do run into it from time to time.

00:07:23.370 --> 00:07:30.040
You know, perhaps the specification for the format you're
working with was written down on a back of a napkin in 1989,

00:07:30.040 --> 00:07:36.610
it says nothing whatsoever about encodings, your
Russian users are getting angry, it happens.

00:07:36.610 --> 00:07:39.139
There are a couple of things I want to say about this.

00:07:39.139 --> 00:07:45.089
The first is that if you have some text data, if you don't
know what encoding it's in, you have a significant problem.

00:07:45.089 --> 00:07:48.549
There are ways of trying to infer
the encoding from the data.

00:07:48.550 --> 00:07:51.850
But they're not perfect, they can all fail.

00:07:51.850 --> 00:07:57.330
It may be necessary to provide a means for the user
to go back and try again with a different encoding

00:07:57.329 --> 00:08:00.939
in case the first one produced some nonsense.

00:08:00.939 --> 00:08:04.339
It's difficult to do this automatically
because in some cases,

00:08:04.339 --> 00:08:07.929
the difference between sense and
nonsense is a little subtle.

00:08:07.930 --> 00:08:13.730
Also, there are some documents that is nonsense
to start with no matter what encoding you use.

00:08:13.730 --> 00:08:18.189
The other thing I want to say is that
this is very much domain dependent.

00:08:18.189 --> 00:08:19.910
Let me give you an example.

00:08:19.910 --> 00:08:25.380
Consider XHTML, that's a way of
writing HTML as a dialect of XML.

00:08:25.379 --> 00:08:28.430
Because it's XML, it has a default encoding.

00:08:28.430 --> 00:08:33.690
Default encoding, if none is specified for XML, it's UTF-8.

00:08:33.690 --> 00:08:37.400
That's a right answer.

00:08:37.399 --> 00:08:42.240
Then consider HTML, it's very similar, but HTML is not XML.

00:08:42.240 --> 00:08:45.759
In fact, HTML has no default encoding.

00:08:45.759 --> 00:08:54.350
If you don't specify an encoding for HTML, browser is
likely to interpret it maybe as Windows code page 1252,

00:08:54.350 --> 00:08:59.980
unless maybe you're in Russia, or China, or Japan,
maybe something else there, it's kind of a mess.

00:08:59.980 --> 00:09:05.779
There's in fact a discussion about this
going on right now with regard to HTML 5.

00:09:05.779 --> 00:09:11.379
People would like to try to improve this
situation, but I think there's a general feeling

00:09:11.379 --> 00:09:16.490
that it may not be possible for compatibility reasons.

00:09:16.490 --> 00:09:20.110
So I think we had enough slides for now.

00:09:20.110 --> 00:09:26.129
I'd like to go over to the demo
machine and take a look at some code.

00:09:26.129 --> 00:09:28.029
So I wrote a little sample here.

00:09:28.029 --> 00:09:30.100
It's not yet available on the developer site.

00:09:30.100 --> 00:09:32.040
I hope it will be in the next few weeks.

00:09:32.039 --> 00:09:37.789
And what I tried to do in this was go to a
situation where maybe things aren't so simple.

00:09:37.789 --> 00:09:41.589
In fact, maybe you've got about as little as possible.

00:09:41.590 --> 00:09:45.210
So say you have nothing but an NSFile handle.

00:09:45.210 --> 00:09:50.480
Maybe you know an encoding, maybe you don't,
and you want to read in plain text from it.

00:09:50.480 --> 00:09:54.690
But you're not wanting to read in the whole document at
once, you only want to read in little chunks at a time.

00:09:54.690 --> 00:10:00.350
So I wrote a little class to do that, file
reader here, create it with a file handle.

00:10:00.350 --> 00:10:03.759
You can pass an encoding if you
have and a zero if you don't,

00:10:03.759 --> 00:10:09.309
and then it passes back the text a paragraph at a time.

00:10:09.309 --> 00:10:15.939
A little note on terminology, traditionally in text
processing, people often talk about lines of text.

00:10:15.940 --> 00:10:19.550
>> Well, in the Cocoa text system,
we're often dealing with text layout.

00:10:19.549 --> 00:10:23.019
In the context of layout, a line
of text means something different.

00:10:23.019 --> 00:10:27.000
So we usually talk about paragraphs,
where a paragraph is unambiguously a chunk

00:10:27.000 --> 00:10:31.049
of text separated by some paragraph terminator.

00:10:31.049 --> 00:10:34.339
And in Cocoa, we do this generally.

00:10:34.340 --> 00:10:39.710
We don't deal just with UNIX terminators and Mac
terminators and Window terminators, but all of those,

00:10:39.710 --> 00:10:43.690
and also, the Unicode paragraph separator as well.

00:10:43.690 --> 00:10:52.680
And so what this class does is just to
return the text to you a paragraph at a time

00:10:52.679 --> 00:10:56.139
until it runs out of text or until it hits an error.

00:10:56.139 --> 00:10:58.100
So how does that work?

00:10:58.100 --> 00:11:01.420
Let's take a look at the code.

00:11:01.419 --> 00:11:08.759
So we have, first of all, a little method here that reads
the chunk of data, reads in, just reads in a chunk of data

00:11:08.759 --> 00:11:13.330
from the file handle 512 bytes at a time.

00:11:13.330 --> 00:11:17.920
And then, the next paragraph method
just calls that repeatedly and then goes

00:11:17.919 --> 00:11:22.990
through the data looking for a suitable paragraph separator.

00:11:22.990 --> 00:11:27.440
Fortunately, these paragraph separators
are fairly easy to recognize

00:11:27.440 --> 00:11:31.250
in almost any encoding that you are likely to encounter.

00:11:31.250 --> 00:11:39.480
And they also make very natural points at which to
split the data and try to convert it to a string.

00:11:39.480 --> 00:11:47.259
And so once we've encountered one, then we use one of
those methods that I exhibited before to take the bytes

00:11:47.259 --> 00:11:50.759
of the paragraph and convert them
into a string and then pass it back.

00:11:50.759 --> 00:11:54.139
It's pretty simple.

00:11:54.139 --> 00:12:01.250
So then the question is what do we
do if the encoding is not known?

00:12:01.250 --> 00:12:06.350
Well, what this would do is it will
take the first chunk, first 512 bytes,

00:12:06.350 --> 00:12:10.259
and pass it over to this function
I wrote called YES encoding.

00:12:10.259 --> 00:12:11.750
Now, let's take a look at that.

00:12:11.750 --> 00:12:16.149
As I mentioned, determining the
encoding is very much domain specific.

00:12:16.149 --> 00:12:18.199
So this is not intended to be a universal solution.

00:12:18.200 --> 00:12:19.629
I don't think there is a universal solution.

00:12:19.629 --> 00:12:23.220
This is just exhibiting some techniques you can try.

00:12:23.220 --> 00:12:28.639
So first technique is to look for Unicode
byte ordering mark of various kinds,

00:12:28.639 --> 00:12:32.259
which pretty much on an ambiguous side
identifies various Unicode encodings.

00:12:32.259 --> 00:12:34.740
OK, at that, we're good.

00:12:34.740 --> 00:12:37.470
Usually we don't, so here's another technique.

00:12:37.470 --> 00:12:38.889
It is to see if they started a file.

00:12:38.889 --> 00:12:40.549
It looks like it's XML.

00:12:40.549 --> 00:12:47.649
If it is, we can scan through it looking for
an XML style encoding declaration and use that.

00:12:47.649 --> 00:12:50.069
That's one possibility.

00:12:50.070 --> 00:12:53.700
Or maybe the file looks like it's HTML.

00:12:53.700 --> 00:12:56.170
There's so much different HTML,
it's kind of hard to recognize.

00:12:56.169 --> 00:13:03.000
But if it is, then maybe we scan through it looking
for an HTML style char set declaration and use that.

00:13:03.000 --> 00:13:05.789
Now if you don't have that, well, then what can we do?

00:13:05.789 --> 00:13:07.959
Well, we can try some encodings.

00:13:07.960 --> 00:13:11.170
UTF-8 is a good one to try first
because it's very distinctive.

00:13:11.169 --> 00:13:17.120
It's unlikely that text and some other
encoding will be properly recognized as UTF-8.

00:13:17.120 --> 00:13:22.049
If not that, well, depending on what kind of document it is,

00:13:22.049 --> 00:13:25.219
we might fall back to something
else, maybe a Windows encoding.

00:13:25.220 --> 00:13:35.649
And as a very final fallback, we're trying Mac Roman because
any sequence of bytes can be interpreted in Mac Roman,

00:13:35.649 --> 00:13:38.110
although the results may not be terribly intelligible.

00:13:38.110 --> 00:13:42.139
Now, we'll see this in action a little later on.

00:13:42.139 --> 00:13:47.299
But let's go back to the slides.

00:13:47.299 --> 00:13:51.909
And now, I'd like to turn the stage
over to my colleague, Aki Inoue,

00:13:51.909 --> 00:13:57.019
who will talk about processing text once you have it.

00:13:57.019 --> 00:13:59.970
[ Applause ]

00:13:59.970 --> 00:14:01.870
>> Thank you, Doug.

00:14:01.870 --> 00:14:02.870
Good morning.

00:14:02.870 --> 00:14:08.330
Hi. I'm Aki Inoue, Cocoa Software Engineer.

00:14:08.330 --> 00:14:14.030
In this part of the session, I'd like
to discuss string contents handling,

00:14:14.029 --> 00:14:19.459
especially focusing on tips and
tricks that you may feel useful.

00:14:19.460 --> 00:14:28.639
Also, after this session, I hope you're going to have the
information presented here that should build confidence

00:14:28.639 --> 00:14:34.240
in manipulating NSStrings efficiently and properly.

00:14:34.240 --> 00:14:40.930
Much of the information presented here are
inspired by questions and comments I've seen

00:14:40.929 --> 00:14:47.609
on various demo for forums and mailing lists.

00:14:47.610 --> 00:14:56.300
Those are the classes I'm covering today,
NSString and the two formatter classes.

00:14:56.299 --> 00:15:00.099
Let's review the basics of NSString first.

00:15:00.100 --> 00:15:08.930
NSString is the standard string object used
everywhere, on both Mac OS X and iPhone.

00:15:08.929 --> 00:15:19.719
The APIs are full-fledged covering from string
encoding conversion as you saw to collation,

00:15:19.720 --> 00:15:25.190
and we tried very hard to keep the API simple.

00:15:25.190 --> 00:15:34.430
Yet, we try to retain the full string
handling power at your disposal.

00:15:34.429 --> 00:15:38.789
Finally, it encapsulates Unicode.

00:15:38.789 --> 00:15:49.579
Now Unicode, that's one of the keywords I've seen many
times accompanying the questions about string handlings.

00:15:49.580 --> 00:15:51.820
What is Unicode then?

00:15:51.820 --> 00:15:55.200
It is the universal character set standard.

00:15:55.200 --> 00:16:00.570
It is why many technology leaders and standards.

00:16:00.570 --> 00:16:12.170
It is right now at version 5.1 and covering
more than 100,000 imported characters.

00:16:12.169 --> 00:16:15.789
The printed document is about this thick.

00:16:15.789 --> 00:16:27.709
It contains 1,472 pages, with dozens of auxiliary
specifications like the Unicode by their algorithm

00:16:27.710 --> 00:16:37.920
or common locale data repository, making it
one of the largest technology standards today.

00:16:37.919 --> 00:16:43.549
But, our design goal of NSString
is to insulate the applications

00:16:43.549 --> 00:16:47.959
from the growing details of this gigantic standard.

00:16:47.960 --> 00:16:53.330
So by following a few simple rules, I'm going

00:16:53.330 --> 00:17:01.070
to be discussing your application,
should let NSString do its own magic.

00:17:01.070 --> 00:17:08.370
I divided my presentation into 4 subtasks.

00:17:08.369 --> 00:17:12.039
First, let's take a look at search and comparing.

00:17:15.269 --> 00:17:18.059
These are the questions I've seen.

00:17:18.059 --> 00:17:21.019
What do you sort like Apple applications?

00:17:21.019 --> 00:17:30.799
Or how do you satisfy your customers
from the other side of the world?

00:17:30.799 --> 00:17:34.940
Or simply, how do you sort strings numerically?

00:17:34.940 --> 00:17:49.140
When you try to answer these questions and try to
consider search compare string values manually,

00:17:49.140 --> 00:18:00.740
please take a look first at higher-level APIs, find panel,
spotlight, Core Data, and other data management frameworks

00:18:00.740 --> 00:18:08.180
in a system that has a built in facility
for sorting, searching, filtering.

00:18:08.180 --> 00:18:25.930
By using those, they provide higher abstraction, excuse me,
and possibly can protect you from any future OS changes.

00:18:25.930 --> 00:18:37.490
One of the questions concerning
comparing sorting is localized sorting.

00:18:39.119 --> 00:18:47.049
NSString has 2 sets of APIs.

00:18:47.049 --> 00:18:56.690
The first group is compare and its variants, taking
much more arguments for specifying custom behavior.

00:18:56.690 --> 00:19:05.950
The other set is method taking one
argument, the other string to compare

00:19:05.950 --> 00:19:14.630
and how it's pre-selected the behavior was
pretty self-explanatory of the signatures.

00:19:14.630 --> 00:19:22.130
So you might think when you want a localized sorting,

00:19:22.130 --> 00:19:26.870
probably localizing application system
compare is the method you want to use.

00:19:26.869 --> 00:19:34.109
But we recommend to use the most generic
one, compare:options:range:locale.

00:19:34.109 --> 00:19:36.609
Let's take a look.

00:19:36.609 --> 00:19:43.269
This is a sample of string compare function.

00:19:43.269 --> 00:19:48.639
It takes 2 string arguments and
returns the result, pretty simple.

00:19:48.640 --> 00:19:56.610
The first step you should do is
identify the locale you want to use.

00:19:56.609 --> 00:20:03.039
Without specifying locale, NSString
does generic and localized collation.

00:20:03.039 --> 00:20:08.389
So obviously, when you're doing that
localized sorting, you want to specify locale.

00:20:08.390 --> 00:20:15.759
And generally, if you want to follow the user setting,
you want to specify the current locale like this.

00:20:17.720 --> 00:20:23.519
>> After that, next step is to specify a series of options.

00:20:23.519 --> 00:20:27.420
This is a set of the option we would want for you to follow.

00:20:27.420 --> 00:20:30.120
Let's take a look at each of the options.

00:20:30.119 --> 00:20:41.359
Case insensitive search, it maps simple one to one
case like this or a complex case like ligatures

00:20:41.359 --> 00:20:51.429
that have different lengths, or it can support
locale sensitive mapping like this too.

00:20:51.430 --> 00:20:54.220
Next one, numeric search.

00:20:56.349 --> 00:21:03.299
By default, NSString treats all
the digits just as other letters.

00:21:03.299 --> 00:21:13.730
By specifying this option, the numbers are
sorted according to their numeric values.

00:21:13.730 --> 00:21:24.360
Diacritic insensitivity, by specifying these options,
NSString ignores the difference in accents like those.

00:21:24.359 --> 00:21:34.229
But, it's not enough to know to know to ignore
accents that have semantic significance like this.

00:21:34.230 --> 00:21:42.750
And width insensitivity, in Unicode,
there are many variant characters,

00:21:42.750 --> 00:21:47.940
some of those just simply wider or narrower versions.

00:21:47.940 --> 00:21:58.940
For example, there is a full set of ASCII
character set copy that's just wider.

00:21:58.940 --> 00:22:09.259
And by specifying these options, those variations
of the best characters are treated the same.

00:22:09.259 --> 00:22:11.920
Finally, forced ordering.

00:22:11.920 --> 00:22:18.950
This option could be pretty important if you
could have multiple instances of the same word.

00:22:21.049 --> 00:22:25.180
For example, options like CaseInsensitivity.

00:22:25.180 --> 00:22:31.500
Those visually different characters are
considered the same with these options.

00:22:34.410 --> 00:22:41.160
Very useful, but the comparison results
for those strings are always the same.

00:22:41.160 --> 00:22:52.509
So the sorting result could be at random because A,
B, C presented here are all from the same NSString.

00:22:52.509 --> 00:23:01.980
By specifying NSForcedOrdering options, after
NSString determines strings are equal due to one

00:23:01.980 --> 00:23:08.860
of the insensitivity options, it
will try to get the forced ordering.

00:23:08.859 --> 00:23:17.459
So this comparison becomes ordered
and the result is always stable.

00:23:21.779 --> 00:23:31.910
So after specifying those options, you can use
compare:options:range:locale: method to return the result.

00:23:31.910 --> 00:23:41.220
And we provide convenient functions, convenient
method like sortedArray using function like this,

00:23:41.220 --> 00:23:46.380
so that you could have nice sorted array of strings.

00:23:46.380 --> 00:23:53.160
But new in Snow Leopard, you can
forget all about the options.

00:23:53.160 --> 00:23:59.900
We now have localizedStandardCompare
designed specifically for local sorting,

00:23:59.900 --> 00:24:05.660
and it packages all the options by adopting it.

00:24:05.660 --> 00:24:15.720
Even when we provide a new OS enhancement insensitivity,
the applications get those enhancements for free.

00:24:15.720 --> 00:24:17.710
Next, filtering.

00:24:17.710 --> 00:24:22.309
How do you do prefix matching?

00:24:22.309 --> 00:24:23.389
Pretty simple question.

00:24:23.390 --> 00:24:32.730
You wanted-- tend to think it's a simple task and doing--

00:24:32.730 --> 00:24:41.230
just limiting the number of characters compared
should suffice in this case, but it's not recommended.

00:24:44.089 --> 00:24:55.529
Being equal doesn't necessarily mean the lengths are
also the same, due to the fact that case insensitivity

00:24:55.529 --> 00:25:05.839
or the different completion of the action could
result in different length of strings to be matched.

00:25:05.839 --> 00:25:12.970
So in fact, prefix matching is not comparing operations.

00:25:12.970 --> 00:25:16.870
It's a searching operation of a special kind.

00:25:16.869 --> 00:25:27.699
And by specifying NSAnchoredSearch options, the
searching can be pinned at the beginning of the string,

00:25:27.700 --> 00:25:38.340
and using the option, you can search to do the prefix
matching, rangeOfString, options, range, locale.

00:25:38.339 --> 00:25:44.399
And if there is a match, you can
determine if the prefix is matched.

00:25:44.400 --> 00:25:50.360
Of course, NSString has the nice method for prefix matching.

00:25:50.359 --> 00:25:56.939
So whatever you need to do, you can
use the method provided by NSString.

00:25:56.940 --> 00:26:00.940
Next, parsing.

00:26:04.430 --> 00:26:09.490
NSString contents of black box.

00:26:09.490 --> 00:26:24.670
Yeah. And you might feel, you know, system processing is
more efficient or you might have to parse some other data.

00:26:26.269 --> 00:26:32.170
In text data processing, there are 2 kinds of,

00:26:32.170 --> 00:26:39.410
roughly 2 kinds of data processing you might
encounter, structured and unstructured.

00:26:39.410 --> 00:26:48.310
Structured text data processing is mainly processing the
data designed for the machine to process, and other kind,

00:26:48.309 --> 00:26:53.839
unstructured, is essentially natural
language documents from the user.

00:26:53.839 --> 00:27:08.139
Those are the probably commonly used structures
text data today, HTML, XML, and so on and so forth.

00:27:08.140 --> 00:27:18.220
But, we provide a nice higher level API such as
WebKit to process HTML, or NSXMLParser to process XML.

00:27:18.220 --> 00:27:33.930
But, you know, still there are some other structures of text
data like HTML/XML fragments or some legacy file formats.

00:27:33.930 --> 00:27:40.279
And you might have to actually parse the user input.

00:27:40.279 --> 00:27:50.519
But if you want to try parsing user inputs by yourself,
first consider control such as NSTokenField, DatePicker,

00:27:50.519 --> 00:27:57.139
or fields with formatting, so that you
can have the system processed for you.

00:27:57.140 --> 00:28:09.430
And if you still want to parse
structured data, NSScanner and NS--

00:28:09.430 --> 00:28:15.789
some of the NSString methods components
separated by string can help you there.

00:28:15.789 --> 00:28:23.579
This is a sample code that totalizes
such strings inserted in the searchField.

00:28:23.579 --> 00:28:28.740
Simply just displaying of whitespace,
you can have tokens of search words.

00:28:28.740 --> 00:28:36.440
Since searchField takes usually structured
text data, that's in the search string,

00:28:36.440 --> 00:28:43.049
specifying whitespace is usually safe for you.

00:28:43.049 --> 00:28:47.990
Now, you want to process natural language in your document.

00:28:47.990 --> 00:28:50.359
There is one golden rule.

00:28:50.359 --> 00:28:58.929
That is to identify the appropriate
basic text processing unit for your task.

00:28:58.930 --> 00:29:08.980
Those are grapheme clusters, words, paragraphs, and try
to never, never use this per character processing.

00:29:08.980 --> 00:29:15.059
Let's take a look at a grapheme cluster.

00:29:15.059 --> 00:29:21.509
This is the smallest unit of NSString you want to process.

00:29:21.509 --> 00:29:29.970
You can let the range of grapheme cluster at specified
index using rangeOfComposedCharacterSequenceAtIndex,

00:29:29.970 --> 00:29:37.440
and this is example grapheme cluster
with composed character sequence.

00:29:37.440 --> 00:29:48.180
E, accented e could be represented as base
e plus an accent, two NSString characters.

00:29:48.180 --> 00:29:54.880
Or, if you stick to grapheme-cluster-based
processing, you get a much better support.

00:29:54.880 --> 00:30:04.730
Characters outside the 16-bit range, usually are
represented by 2 Unicode characters like this

00:30:04.730 --> 00:30:10.329
This is the standard idiom in NSString processing.

00:30:10.329 --> 00:30:15.539
It identifies the range you want to process.

00:30:15.539 --> 00:30:19.359
>> Process the range and go to the next range.

00:30:19.359 --> 00:30:23.729
In this case, we can use
rangeOfComposedCharacterSequenceAtIndex

00:30:23.730 --> 00:30:31.569
to identify the current grapheme cluster range.

00:30:31.569 --> 00:30:38.069
Words, words are often the most
appropriate unit you can use for tasks

00:30:38.069 --> 00:30:45.559
such as manipulations or transformation like case mapping.

00:30:45.559 --> 00:30:51.319
You want uppercase, lowercase,
capitalized, or spell checking.

00:30:51.319 --> 00:30:59.589
And you can query the range of words using
NSAttributedStringDoubleClickAtIndex.

00:30:59.589 --> 00:31:08.349
Naturally, double-click is the user action,
you select a word, so we use the method name.

00:31:08.349 --> 00:31:17.240
But be aware, whitespace is not the
only way to have the word's boundary.

00:31:17.240 --> 00:31:24.299
For example, with Chinese and Japanese,
there might not be whitespace at all.

00:31:24.299 --> 00:31:34.950
And the notion of word is pretty
much local and context sensitive.

00:31:34.950 --> 00:31:48.309
Again, the same idiom, use the doubleClickAtIndex
and do the same range-based processing.

00:31:48.309 --> 00:32:00.139
Paragraphs, as Doug mentioned before, probably you should
consider using a paragraph as a maximum unit instead

00:32:00.140 --> 00:32:04.570
of blasting through the entire document at once.

00:32:04.569 --> 00:32:16.250
It is important especially for languages like
Arabic and Hebrew that have multiple directionality.

00:32:16.250 --> 00:32:20.779
Each paragraph has its own direction.

00:32:20.779 --> 00:32:30.299
So if you try to process multiple paragraphs with most
direction, for example if you're in a contact name,

00:32:30.299 --> 00:32:38.009
those paragraphs, you might lose the original
semantics of the user's documentation, user's document.

00:32:38.009 --> 00:32:43.690
[ Pause ]

00:32:43.690 --> 00:32:47.960
>> This is the same idiom for paragraphs.

00:32:50.680 --> 00:33:00.480
New in Snow Leopard, we're introducing a block-based
API for enumerating these basic text units,

00:33:00.480 --> 00:33:06.370
enumerateSubstringsInRange options usingBlock.

00:33:06.369 --> 00:33:14.529
It can enumerate the 3 basic units,
as well as lines and synthesis.

00:33:14.529 --> 00:33:23.519
We provide line-specific convenient
space of line enumerateLinesUsingBlock,

00:33:23.519 --> 00:33:30.389
and also added NSAttributedString
method for enumerating attribute runs.

00:33:30.390 --> 00:33:36.840
So this code can become this.

00:33:36.839 --> 00:33:42.009
Let's take a look at a sample in a demo.

00:33:42.009 --> 00:33:48.619
[ Pause ]

00:33:48.619 --> 00:33:51.699
>> OK, what is this application?

00:33:51.700 --> 00:34:01.400
It copies the contents of the upper text view to
the text view in the bottom and inserts spaces

00:34:01.400 --> 00:34:10.010
after each character, and the result is pretty disastrous.

00:34:10.010 --> 00:34:19.910
Accents are detached, ligatures corrupt, and some
characters are flat out garbled and unreadable.

00:34:19.909 --> 00:34:28.239
By processing based on grapheme
clusters, the visual units are retained.

00:34:28.239 --> 00:34:35.009
So take a look at, let's take a look at the code--

00:34:35.010 --> 00:34:42.810
[ Pause ]

00:34:42.809 --> 00:34:43.840
>> Processing the cluster.

00:34:43.840 --> 00:34:58.820
You get the range and specify the options in this
case, because we're mutating the contents of the text.

00:34:58.820 --> 00:35:03.710
We are processing from the back.

00:35:03.710 --> 00:35:12.240
So as you can see, the animation method
can work with mutation operations.

00:35:14.989 --> 00:35:17.339
Let's go back to the slide please.

00:35:17.340 --> 00:35:24.260
Slide, please.

00:35:28.599 --> 00:35:32.289
Next, I'm going to be talking about transforming.

00:35:32.289 --> 00:35:42.500
How do you s-print-f with NSString
or NSCalendarDate is deprecated.

00:35:42.500 --> 00:35:48.329
How do you want to format your dates?

00:35:48.329 --> 00:35:57.460
NSString has many transformation APIs
from case mapping to normalization.

00:35:57.460 --> 00:36:05.500
But today, I'd like to focus to formatting text
using NSDateFormatter and NSNumberFormatter.

00:36:05.500 --> 00:36:07.320
First, number formatting.

00:36:07.320 --> 00:36:20.559
With the dozens of locales we support and demanded by
the user, it's totally impossible to support the notion

00:36:20.559 --> 00:36:26.469
of the variations we support using the
traditional print-f-style formatting.

00:36:27.730 --> 00:36:36.690
This small sign could be different or the
digits may not be the ones you're familiar with.

00:36:36.690 --> 00:36:43.920
Or the NSNumberFormatter provides
convenient access to those common formats

00:36:43.920 --> 00:36:51.840
like percentage, monitoring units, so on and so forth.

00:36:51.840 --> 00:36:56.910
New in Snow Leopard, it gets more convenient.

00:36:56.909 --> 00:37:02.089
We added a class method for formatting NSNumber

00:37:02.090 --> 00:37:10.500
into a format string using localized
string for number, number style.

00:37:10.500 --> 00:37:18.500
You can get the formatter string without
even creating the NSNumberFormatter instance.

00:37:18.500 --> 00:37:20.539
Let's take a look.

00:37:22.809 --> 00:37:25.179
[Applause] Take a look at date formatting now.

00:37:25.179 --> 00:37:27.309
It gets more interesting.

00:37:27.309 --> 00:37:37.809
We deprecated NSCalendarDate, changed the default
formatting behavior and we've been recommended

00:37:37.809 --> 00:37:45.940
to use the predefined 4 formats,
short, medium, long, and full.

00:37:45.940 --> 00:37:53.929
And the recommendation is for protecting
the applications from the sheer complexity

00:37:53.929 --> 00:38:01.779
of supporting gazillions of locales and calendar variations.

00:38:01.780 --> 00:38:07.660
And we're adding more locales and calendars each release.

00:38:07.659 --> 00:38:12.750
And user could have non-Gregorian calendars now.

00:38:12.750 --> 00:38:27.179
For example, the year might not be 2009 for him or her, or
even the month, the number of month might be 12 per year.

00:38:27.179 --> 00:38:34.469
So it's important to stick to the 4 basic formats.

00:38:34.469 --> 00:38:43.509
Just as the NumberFormatter, NSDateFormatter has
the class method to get the formatted string easily,

00:38:43.510 --> 00:38:48.740
localizedStringFromDate dateStyle timeStyle.

00:38:48.739 --> 00:38:58.539
And under that enhancement, we now
support localized RelativeDateFormatting.

00:38:58.539 --> 00:39:10.659
For example if today is June 12, 2009, instead of
displaying the format string, with this option,

00:39:10.659 --> 00:39:19.879
that formatter can return today or yesterday,
just like mails receive date calendars.

00:39:19.880 --> 00:39:32.110
[Applause] Yet, you still want
to do custom formatting, right?

00:39:32.110 --> 00:39:34.630
But we deprecated NSCalendarDate.

00:39:34.630 --> 00:39:37.300
So what do we do?

00:39:37.300 --> 00:39:47.210
Starting with Snow Leopard, we are
adding a custom date formatting.

00:39:47.210 --> 00:39:57.940
With dateFormatFromTemplate options locale,
you specify a generic formatting template

00:39:57.940 --> 00:40:12.829
and the method returns customized format suitable for
the locale so that you can safely use a custom formatting

00:40:12.829 --> 00:40:19.329
with "exotic" locales of calendar confirmations.

00:40:19.329 --> 00:40:24.190
>> And let's take a look at this code here.

00:40:24.190 --> 00:40:32.789
In this example, we're using MMM/Y as a template format.

00:40:32.789 --> 00:40:36.809
This should show abbreviated month names and year.

00:40:36.809 --> 00:40:43.590
In US format, it should display June 2009.

00:40:43.590 --> 00:40:51.850
You can pass the template's format and a locale in this
example where you're using traditional Chinese locale

00:40:51.849 --> 00:41:00.190
and it should return a transform format
suitable for traditional Chinese,

00:41:00.190 --> 00:41:04.789
and it should contain the right
Chinese character suffix for you.

00:41:04.789 --> 00:41:11.340
You put the return custom format to the
NSDateFormatter and you're ready to go.

00:41:11.340 --> 00:41:15.010
Let's take a look at the power.

00:41:15.010 --> 00:41:20.590
[ Pause ]

00:41:20.590 --> 00:41:37.530
>> So these applications show the 4 basic
units and user could change the formatting

00:41:37.530 --> 00:41:43.200
like this and specify any calendar combination.

00:41:45.429 --> 00:41:52.190
These are just a small portion of the
locale in calendar we support on OS.

00:41:53.449 --> 00:41:59.469
Now, you know, you want to stick to the 4 combinations here.

00:42:03.230 --> 00:42:16.019
With Snow Leopard specifying the locale date
option, it can display today, yesterday, tomorrow,

00:42:16.019 --> 00:42:24.780
and provide some other localization, works properly.

00:42:24.780 --> 00:42:31.990
Next, you want to display custom format.

00:42:31.989 --> 00:42:39.619
The title here shows the custom
format used by the field next to it.

00:42:39.619 --> 00:42:45.259
You want to display week of day but
use the shorter date formatting,

00:42:45.260 --> 00:42:51.740
or you just want to show the week of day and month date.

00:42:51.739 --> 00:42:59.229
OK, but those custom formats are
usually specific to one locale.

00:42:59.230 --> 00:43:06.090
You might have to specify multiple formatting
strings depending on the use of the locale.

00:43:06.090 --> 00:43:10.410
For example, if you search French locale, their--

00:43:10.409 --> 00:43:17.069
always their formatting is not good anymore
because month should come after day.

00:43:17.070 --> 00:43:23.150
But since we are specifying custom
specific format, we cannot do it.

00:43:23.150 --> 00:43:33.630
Using the template, it transforms the original custom
format template to the one suitable for the locale.

00:43:33.630 --> 00:43:44.079
For example, if you specify Chinese, it
contains the right Chinese character suffixes.

00:43:44.079 --> 00:44:03.989
Or specify Japanese and Japanese calendar, it
correctly asks the era required for the calendar.

00:44:03.989 --> 00:44:10.009
[Applause] Now, the power of the user template
can be used to configure user interface.

00:44:10.010 --> 00:44:22.160
One example is you want to show your credit card's
expiration date, and list the name of the month and year.

00:44:22.159 --> 00:44:27.190
But if you select French, that's fine.

00:44:27.190 --> 00:44:35.530
But for example, Japanese, usually you
should display the year before the month

00:44:35.530 --> 00:44:42.610
and have the Chinese character
suffix after year, but you cannot.

00:44:42.610 --> 00:44:49.510
By using a template, you can know the
final configuration of the formats,

00:44:49.510 --> 00:44:54.030
so that you can modify your user interface accordingly.

00:44:57.570 --> 00:45:01.730
Let's go back to that slide please.

00:45:01.730 --> 00:45:06.369
Finally, I'd like to touch performance.

00:45:06.369 --> 00:45:13.529
I tried NSString method and it has a performance problem.

00:45:13.530 --> 00:45:17.730
What should we do next?

00:45:17.730 --> 00:45:26.590
Or do we want to really, really
touch the contents of an NSString?

00:45:26.590 --> 00:45:35.410
The first step you should do is
always to sample the hotspot.

00:45:35.409 --> 00:45:45.859
With Shark instruments and other performance tools,
we should be able to identify what's taking time.

00:45:45.860 --> 00:45:50.099
You will be surprised that most of the performance programs

00:45:50.099 --> 00:45:56.969
with string operations are coming from
memory allocation or deallocation.

00:45:56.969 --> 00:46:06.089
It may be spending time allocating
alter use object in a tight loop,

00:46:06.090 --> 00:46:11.769
or simply try to deallocate object
created inside autoreleased pool.

00:46:11.769 --> 00:46:26.090
So by using MutableString API, you can try
to avoid this temporary object created.

00:46:26.090 --> 00:46:36.340
Or if you want to transform many strings, you can
try to use and take a look at CFMutableString API

00:46:36.340 --> 00:46:39.019
if you want to do in place transformation.

00:46:39.019 --> 00:46:48.449
Or you can pre-allocate initial buffer
by yourself and initialize NSString

00:46:48.449 --> 00:46:57.500
at the end using no copy version of the initializer.

00:46:57.500 --> 00:47:01.000
Let's review what I told.

00:47:01.000 --> 00:47:06.429
Unicode is not a mystic monster, you can tame him.

00:47:06.429 --> 00:47:11.879
And it is easy to do by following the simple rules.

00:47:11.880 --> 00:47:25.220
You can use the framework API, and by knowing the
basic units, grapheme clusters, words, paragraphs,

00:47:25.219 --> 00:47:30.569
you can be confident you were processing the text properly.

00:47:30.570 --> 00:47:38.480
And finally, by knowing that performance
semantics are mutable and immutable methods,

00:47:38.480 --> 00:47:48.820
you should be able to get the best
performance out of NSString API.

00:47:48.820 --> 00:47:57.309
And now, I'm giving back the stage to Doug, who's
going to be discussing brand new exciting features.

00:47:57.309 --> 00:47:58.259
Thank you.

00:47:58.260 --> 00:47:58.490
[ Applause ]

00:47:58.489 --> 00:48:00.469
>> Thank you, Aki.

00:48:00.469 --> 00:48:03.439
[ Applause ]

00:48:03.440 --> 00:48:09.269
>> So what I'm going to talk about now is something
that's new in Snow Leopard that we call text checking,

00:48:09.269 --> 00:48:15.599
and what we've done here is taking some existing
functionality, things like spell checking and smart quotes

00:48:15.599 --> 00:48:18.440
and smart links, and we added some new functionality.

00:48:18.440 --> 00:48:23.960
Things like spelling correction, data detectors,
automatic text replacement, smart links,

00:48:23.960 --> 00:48:28.090
and made them all available in one easy to use set of APIs.

00:48:28.090 --> 00:48:31.550
And when I say easy to use, I mean really easy to use.

00:48:31.550 --> 00:48:35.800
If you're just using a TextView or
WebView, it's simply a matter of turning

00:48:35.800 --> 00:48:40.230
on whichever ones of these you want to have active.

00:48:40.230 --> 00:48:42.010
And I'd like to demo that.

00:48:42.010 --> 00:48:51.840
[ Pause ]

00:48:51.840 --> 00:48:54.519
>> So I'm going to demo that in TextEdit.

00:48:54.519 --> 00:49:01.480
And what we did in TextEdit was to just add various
preferences to turn all these things on or off,

00:49:01.480 --> 00:49:04.440
and on this machine I've turned everything on.

00:49:04.440 --> 00:49:06.030
So we can see it all in action.

00:49:06.030 --> 00:49:12.600
So for example, if we have an address data, detectors
will identify it and give us some interesting options.

00:49:12.599 --> 00:49:15.949
We click on it to create a contact
or show a map or what have you.

00:49:15.949 --> 00:49:26.250
When I'm typing, it will do things
like simple spelling correction for me,

00:49:26.250 --> 00:49:43.949
and I've added some shortcut substitutions for phrases I
frequently use, and you have smart dashes and smart links.

00:49:43.949 --> 00:49:52.419
And actually, I have also set this up so that it will
automatically identify what language I'm typing in.

00:49:52.420 --> 00:50:01.240
[Applause] So it's really very simple.

00:50:01.239 --> 00:50:07.989
Let's go back to the slides.

00:50:07.989 --> 00:50:13.009
Well, I'm not really here to talk
about the UI level aspects of this.

00:50:13.010 --> 00:50:19.040
>> What I want to do here primarily is to talk
about the underlying APIs for this that you can use

00:50:19.039 --> 00:50:23.150
to get similar functionality and
do whatever you want with it.

00:50:23.150 --> 00:50:33.950
So what we've done is to make these sorts of checking
available with one very simple API on a spell checker.

00:50:33.949 --> 00:50:36.509
Well, OK, maybe this doesn't look so simple.

00:50:36.510 --> 00:50:38.020
Let's go through it.

00:50:38.019 --> 00:50:42.389
So the first thing you do is you pass in a string, OK?

00:50:42.389 --> 00:50:44.809
The string you want to check, that's pretty obvious.

00:50:44.809 --> 00:50:52.779
And you pass in a range in a string that you wanted to
look at, that's fairly obvious as well, and the types.

00:50:52.780 --> 00:51:01.560
Well, that's just a bit wise-- or of any of the types
from that list of items that you want to have used.

00:51:01.559 --> 00:51:04.779
And then options, well, you can
usually ignore that, just pass in nil.

00:51:04.780 --> 00:51:08.500
The options allow for advanced
things like if you want to specify,

00:51:08.500 --> 00:51:13.250
if you want to override the user's
default which kind of smart quotes to use.

00:51:13.250 --> 00:51:18.519
SpellDocumentWithTag, this is something
that a spell checker has used all along.

00:51:18.519 --> 00:51:23.440
They use a tag to identify text that belongs to
the same document for things like ignored words.

00:51:23.440 --> 00:51:27.170
If you don't have a spell checking document, just pass in 0.

00:51:27.170 --> 00:51:29.400
And then there are a couple of out-parameters.

00:51:29.400 --> 00:51:37.250
Orthography, which I'll discuss later on, allows
it to identify the language of the text as a whole.

00:51:37.250 --> 00:51:41.260
And the wordCount, it will give back a
count of the number of words in a text.

00:51:41.260 --> 00:51:45.200
If you don't want either of those, just pass in nil.

00:51:45.199 --> 00:51:46.269
And then what do you get back?

00:51:46.269 --> 00:51:52.429
You get back an array of text checking results that you
can go through and analyze and do whatever you want with.

00:51:52.429 --> 00:51:53.460
I'll discuss that in a minute.

00:51:53.460 --> 00:52:01.130
First, I want to say is that this is the simple
version, the synchronous version of this API.

00:52:01.130 --> 00:52:06.610
And we have an advanced version which does
exactly the same thing but asynchronously.

00:52:06.610 --> 00:52:11.510
So it does the same thing, it just
does it in the background.

00:52:11.510 --> 00:52:15.370
And it doesn't return the results as a return value.

00:52:15.369 --> 00:52:21.900
Instead, you get them in in a block that you supply,
if you passed in as a parameter of that block.

00:52:21.900 --> 00:52:26.809
Now, doing things in the background, you're
probably concerned about thread safety.

00:52:26.809 --> 00:52:31.039
So you don't have to worry about the thread
safety of the text checking operations itself.

00:52:31.039 --> 00:52:35.150
It will copy out whatever it needs before it does that.

00:52:35.150 --> 00:52:39.940
The block that you just passed in, you should be
aware this is being run using an operation queue.

00:52:39.940 --> 00:52:43.170
So it's not going to be run in any particular context.

00:52:43.170 --> 00:52:49.190
If you need the work to be done on some particular
thread or queue, then you need to pass it over to

00:52:49.190 --> 00:52:53.000
that thread or queue from within a block.

00:52:53.000 --> 00:53:00.960
Also, alternatively, if you need some particular form of
locking for whatever it is you're doing in your block,

00:53:00.960 --> 00:53:04.039
then you have to buy that yourself, of course.

00:53:04.039 --> 00:53:10.570
The other thing you might need to keep in mind
is that if the text you're working on is mutable,

00:53:10.570 --> 00:53:14.880
it might have changed between the time that you sent it out
for text checking and the time you get the results back.

00:53:14.880 --> 00:53:20.300
So the results might be out of date, and there is
a sequence number to help you keep track of that.

00:53:20.300 --> 00:53:22.310
So what are these results that you get back?

00:53:22.309 --> 00:53:26.869
There are instances in the new class,
NSTextCheckingResult, you get an array of these

00:53:26.869 --> 00:53:32.759
and each one just represents some interesting
item that text checking has found in your text.

00:53:32.760 --> 00:53:39.230
That might be a misspelled word, it might be
a URL, a date and address from data detectors.

00:53:39.230 --> 00:53:44.469
It might be some piece of text for which we
have a suggested replacement like a curly quote

00:53:44.469 --> 00:53:49.309
for a straight quote, or something of that sort.

00:53:49.309 --> 00:53:56.719
These objects always have first of all, a type,
the type of a checking that they are result for,

00:53:56.719 --> 00:53:59.989
and a range, the range in a text to which they apply.

00:53:59.989 --> 00:54:07.429
Depending on the type, they may have other
information, a URL, a date, address, as a dictionary,

00:54:07.429 --> 00:54:12.219
or a string that's suggested as a replacement for that text.

00:54:12.219 --> 00:54:18.359
And then you just go through the list of
these and do whatever you feel is appropriate.

00:54:18.360 --> 00:54:19.630
So here's an example.

00:54:19.630 --> 00:54:24.329
If you passed in this sentence to text checking and
drive you to turn on all the text checking types,

00:54:24.329 --> 00:54:27.000
you'd get back quite a variety of results.

00:54:27.000 --> 00:54:34.349
You would get back one overall result saying that this
whole string has been detected as being in English.

00:54:34.349 --> 00:54:38.699
Then you would get back some more specific
results about specific pieces of the text.

00:54:38.699 --> 00:54:45.119
So you might get back a spell checking result
saying that the second word M-O-E-R, is misspelled.

00:54:45.119 --> 00:54:53.659
And if you'd ask for correction, you may get back another
result suggesting that it be corrected to M-O-R-E.

00:54:53.659 --> 00:55:02.079
And you might get back a link checking result for that
www.apple.com, suggesting that this looks like a URL

00:55:02.079 --> 00:55:06.650
with a full form, that fully formed URL, http: etc..

00:55:06.650 --> 00:55:11.920
And then for the phone number there,
phone numbers are actually detected

00:55:11.920 --> 00:55:15.360
as address results that have a phone number.

00:55:15.360 --> 00:55:21.530
So you get back an address result for this phone
number specifying that it is a particular phone number.

00:55:21.530 --> 00:55:29.180
One of the class, new class that I need to
mention is NSOrthography which is what we use

00:55:29.179 --> 00:55:32.730
for specifying the language that
had been detected, the text.

00:55:32.730 --> 00:55:38.269
The complication here is that a particular of a
piece of text might include more than one language.

00:55:38.269 --> 00:55:41.059
In fact, it might include more than one script.

00:55:41.059 --> 00:55:44.400
So NSOrthography is a class that encapsulates this.

00:55:44.400 --> 00:55:50.889
It specifies what scripts were found in your
text using standard 4 character script codes,

00:55:50.889 --> 00:55:54.849
things like that in Greek, somewhere
like Japanese and so forth.

00:55:54.849 --> 00:56:02.610
And for each script, what languages were detected
as being there using again standard, in this case,

00:56:02.610 --> 00:56:07.090
2-character codes, say EN, FR, and so forth.

00:56:07.090 --> 00:56:09.950
There are a couple other things I want to mention.

00:56:09.949 --> 00:56:12.839
We've done a lot to spell checking in Snow Leopard.

00:56:12.840 --> 00:56:19.870
One thing that we've done, we've always had files in
which we saved the words that the user has learned.

00:56:19.869 --> 00:56:22.529
We never actually documented the format for those files.

00:56:22.530 --> 00:56:23.480
We have now documented.

00:56:23.480 --> 00:56:24.429
It's a very simple format.

00:56:24.429 --> 00:56:29.609
Look at the release notes, it will
tell you how you can interpret these.

00:56:29.610 --> 00:56:38.390
Also, we've added a feature for Snow Leopard where users can
add new spell checking dictionaries in a standard format.

00:56:38.389 --> 00:56:42.629
This is actually a format that Open
Office and a number of other things use.

00:56:42.630 --> 00:56:48.860
It uses 2 different files, so we can add spell checking
for a new language just by dropping these into one

00:56:48.860 --> 00:56:52.920
of your library spelling directories
and the system will recognize it.

00:56:52.920 --> 00:57:00.720
As always, as before, developers can write their own custom
code for spell checking and have that added to the system,

00:57:00.719 --> 00:57:04.809
and a number of developers have done that.

00:57:04.809 --> 00:57:11.009
Now, let's go back over to the demo machine, and I
want to show some of this text checking in action.

00:57:11.010 --> 00:57:20.090
[ Pause ]

00:57:20.090 --> 00:57:22.760
>> We can go back to our sample.

00:57:22.760 --> 00:57:28.720
I decided that I wanted to take this file reader and
actually do something with it, and what I decided to do

00:57:28.719 --> 00:57:35.839
with it is to have it go through a
file and take a look at each one,

00:57:35.840 --> 00:57:46.630
and use text checking to have data detectors detect
any dates or phone numbers that occur in that file.

00:57:46.630 --> 00:57:52.500
So what we're going to do is, for each file
specified, we go through and process it.

00:57:52.500 --> 00:58:00.550
And to process it, we create one of these file
reader objects and iterate through it by paragraphs.

00:58:00.550 --> 00:58:08.780
And for each paragraph, we call the text checking API with
the types, date and address, and allow the data detectors

00:58:08.780 --> 00:58:14.390
to check it, and then we iterate through
to the results looking for dates,

00:58:14.389 --> 00:58:19.029
and addresses, and creating some output for those.

00:58:19.030 --> 00:58:23.120
What we're going to do is print out
any date or address that we find.

00:58:23.119 --> 00:58:26.829
I mean, sorry-- for addresses, we're
actually only looking for phone numbers,

00:58:26.829 --> 00:58:31.269
so we'll print out any date or phone number that we find.

00:58:31.269 --> 00:58:38.070
And we're especially looking for paragraphs that
might have both a date and a phone number in them.

00:58:38.070 --> 00:58:41.200
And for those, we do something
special, we print out the whole thing.

00:58:41.199 --> 00:58:44.929
So let's see this in action.

00:58:44.929 --> 00:58:54.769
And what I've done is, I have a file here that has
all sorts of dates, addresses, phone numbers, etc.,

00:58:54.769 --> 00:59:02.829
in many different languages, and I want to apply this to
that file, and we'll see what kind of app would we get.

00:59:02.829 --> 00:59:09.489
Boom! it has detected all the different things that look
like phone numbers or dates in that file, printed them out,

00:59:09.489 --> 00:59:13.809
and finally, here's a single paragraph
that contains both of them.

00:59:13.809 --> 00:59:17.590
Give me a call at this date and phone number.

00:59:17.590 --> 00:59:20.170
So that is text checking [applause] in action.

00:59:22.739 --> 00:59:25.469
Let's go back to the slides.

00:59:25.469 --> 00:59:31.809
For more information about this, I want to urge
you very much to take a close look at the AppKit

00:59:31.809 --> 00:59:37.219
and Foundation Release Notes for Snow Leopard which
contains lots and lots of detail about these things.

00:59:37.219 --> 00:59:42.239
There is also more information
in various programming guides.

00:59:42.239 --> 00:59:44.819
So let me summarize.

00:59:44.820 --> 00:59:51.220
You should use the framework methods for dealing with
NSStrings, dealing with strings and substrings and ranges

00:59:51.219 --> 00:59:54.239
of strings rather than individual characters.

00:59:54.239 --> 00:59:58.250
You should use Unicode, use Unicode
encodings wherever possible,

00:59:58.250 --> 01:00:01.949
and take advantage of some of these
new methods in Snow Leopard.

01:00:01.949 --> 01:00:02.230
23
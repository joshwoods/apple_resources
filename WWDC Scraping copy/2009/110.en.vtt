WEBVTT

00:00:13.220 --> 00:00:17.130
>> Welcome to Presenting User Data
with Table Views and Browsers.

00:00:17.129 --> 00:00:20.809
My name is Corbin Dunn and I'm a Cocoa Software Engineer.

00:00:22.350 --> 00:00:24.600
So what is this talk about?

00:00:24.600 --> 00:00:30.770
Well, it's an advanced talk focused on a sample code
application that we created called the AnimatedTableView.

00:00:30.769 --> 00:00:36.509
And we expect you to have a firm knowledge of Cocoa
and an understanding of how to work with typical things

00:00:36.509 --> 00:00:41.939
like data sources, delegates, work with
NSWindow, OutlineViews, TableViews.

00:00:41.939 --> 00:00:45.939
Hopefully, you know how to create
custom cells, do drawing, and whatnot.

00:00:45.939 --> 00:00:51.509
Most of this code is geared towards Snow Leopard,
but a lot of the concepts will work on Leopard

00:00:51.509 --> 00:00:58.219
and although it is an advanced talk, a lot of the concepts
you can take and just kind of run with and extract stuff

00:00:58.219 --> 00:01:01.229
from the demo and figure it out
yourselves so it is good for beginners too.

00:01:01.229 --> 00:01:06.060
So what are we going to talk about?

00:01:06.060 --> 00:01:12.750
Well, we're going to say how to subclass and enhance
NSTableView, how to batch load a whole bunch of information

00:01:12.750 --> 00:01:16.810
like images, dynamically as is shown in the table view.

00:01:16.810 --> 00:01:20.870
How to add subviews to table view rows to do
things which you normally can't do in a cell.

00:01:20.870 --> 00:01:26.240
How to do a custom cell editor that edits
outside the normal tracking view loop.

00:01:26.239 --> 00:01:30.759
We're going to talk about how to do some custom
animations such as animating from a table view

00:01:30.760 --> 00:01:35.490
over to another image view inside of the same
window, also, how to do a pop-up window type

00:01:35.489 --> 00:01:39.299
of animation in the custom cell field editor.

00:01:39.299 --> 00:01:44.789
Finally, we're going to discuss some new Snow
Leopard-only API working with NSBrowsers,

00:01:44.790 --> 00:01:48.330
and discussing column previews
and header previews with them.

00:01:48.329 --> 00:01:55.400
So, the focus of the talk is around
this AnimatedTableView sample code.

00:01:55.400 --> 00:01:57.290
I encourage you to download it.

00:01:57.290 --> 00:01:59.850
It will be available on developer.apple.com.

00:01:59.849 --> 00:02:03.019
You can go on the attendee website and find Session 110.

00:02:03.019 --> 00:02:04.539
You can see it associated with it.

00:02:04.540 --> 00:02:10.629
I encourage you to download it after the
session, play with it, modify it, reuse the code.

00:02:10.629 --> 00:02:14.819
So let's take a look at that demo app so we
can kind of know what we're talking about.

00:02:14.819 --> 00:02:17.599
So I'm going to launch the application.

00:02:17.599 --> 00:02:25.919
And what we see here is, on the left we have a regular
table view or subclass table view, have some group rows.

00:02:25.919 --> 00:02:29.669
It has an image, little color in it, and a title.

00:02:29.669 --> 00:02:38.889
And as we scroll through, we're batch loading images
and using NSView to do the animation while it's loading.

00:02:38.889 --> 00:02:47.859
If I click on a particular row, we do an animation from the
row in the table view over to another regular NSImageView.

00:02:47.860 --> 00:02:53.300
We also animate some other properties like the
opacity fades out and the background color fades.

00:02:53.300 --> 00:02:57.439
You can click on a particular color
and we do a little pop-up,

00:02:57.439 --> 00:03:02.069
allowing you to select the particular
color for the background color.

00:03:02.069 --> 00:03:08.849
So we're going to display or talk about how to create
that and how to create an editor for your complex cell.

00:03:08.849 --> 00:03:13.810
You can also double-click on a
particular image and we're going

00:03:13.810 --> 00:03:19.180
to pop-up another window which shows a custom NSBrowser.

00:03:19.180 --> 00:03:26.390
We can modify properties of this by applying core
image filters such as sepia tone and pixelate.

00:03:26.389 --> 00:03:34.269
And up at the top are our little previews such
as a column preview and also a regular preview.

00:03:34.270 --> 00:03:39.060
We're going to talk about how to use
new Snow Leopard API to create that.

00:03:39.060 --> 00:03:44.920
Finally, once you actually have a resulting image,
we're going to show how you can go ahead and set it

00:03:44.919 --> 00:03:49.509
as the desktop wallpaper, so you
can easily change the wallpaper.

00:03:50.530 --> 00:03:54.870
So, let's understand how this demo
application is created and take a quick look

00:03:54.870 --> 00:03:59.129
at the class hierarchy of our model for the application.

00:03:59.129 --> 00:04:03.669
What we have is we have a base subclass
in NSObject called an ATDesktopEntity.

00:04:03.669 --> 00:04:05.909
It has a file URL and a title.

00:04:05.909 --> 00:04:09.069
But the real work is done in a subclass of it.

00:04:09.069 --> 00:04:13.579
We have a subclass that's going to hold an
array of the children for a particular folder.

00:04:13.580 --> 00:04:19.420
So, we have ATDesktopFolderEntity and
that represents the whole folder in a--

00:04:19.420 --> 00:04:22.000
everything in a particular group of images.

00:04:22.000 --> 00:04:27.970
Each particular item in the row is going to
be represented by an ATDesktopImageEntity.

00:04:27.970 --> 00:04:33.610
This has additional other properties like a thumbnail
image, the regular image, whether there's loading or not

00:04:33.610 --> 00:04:38.069
and the fill color that we're going
to use for the desktop background.

00:04:38.069 --> 00:04:42.670
Now, for our views, here's a screenshot
of that sample application.

00:04:42.670 --> 00:04:48.300
So we have a custom in this table view subclass
and it's called the ATDynamicTableView.

00:04:48.300 --> 00:04:53.770
Notice that I use a custom prefix here because we want to
make it sort of like a framework where we can easily reuse

00:04:53.769 --> 00:05:01.089
that code and we recommend using custom prefixes for your
frameworks and in this one I chose a two-letter prefix AT.

00:05:01.089 --> 00:05:06.379
In that way it won't conflict with any
of our standard Apple-provided ones.

00:05:06.379 --> 00:05:09.709
A three-letter prefix is also good to use too.

00:05:09.709 --> 00:05:17.189
So inside that table view, it's going to keep track
of other subviews for things like this little spinner.

00:05:18.290 --> 00:05:23.760
The actual other rows are going to just be a regular cell.

00:05:23.759 --> 00:05:28.550
It's a custom NSTextField subclass
called the ATImageTextCell

00:05:28.550 --> 00:05:34.000
and that normal text field cell is
going to do the normal type of drawing.

00:05:34.000 --> 00:05:37.430
The rest, the bits, we're actually
going to delegate out to other cells.

00:05:37.430 --> 00:05:43.959
So inside this cell, we're going to use subcells to
draw the image within NSImageCell and we're going

00:05:43.959 --> 00:05:49.319
to have another custom cell subclass called
the ATColorCell that draws the color.

00:05:49.319 --> 00:05:52.019
So it's got little color swatch in the color name.

00:05:52.019 --> 00:05:55.699
All these color names are really just
standard things I got from the NS color list.

00:05:55.699 --> 00:05:59.069
I'm just printing them out directly, so
it's something that we provide an app kit

00:05:59.069 --> 00:06:02.240
that you can iterate through for finding standard colors.

00:06:02.240 --> 00:06:08.569
Now, this pop-up window is going
to be a custom NSWindow subclass.

00:06:08.569 --> 00:06:11.490
We're going to call it the ATPopupWindow.

00:06:11.490 --> 00:06:17.139
The reason we subclass in this window mainly is
because we want to overwrite it can become key windows

00:06:17.139 --> 00:06:22.949
so you can interact with the keyboard and have the focus
go in the table view for selecting a particular row.

00:06:22.949 --> 00:06:28.479
But since we're also subclassing there, it's another
good place to put that pop-up code animation.

00:06:28.480 --> 00:06:30.660
So we'll show how to add that type of code in.

00:06:30.660 --> 00:06:37.220
Inside of it we're using that same cell, the
ATColorCell, to do the actual drawing of the color.

00:06:37.220 --> 00:06:41.610
Of course, in model view controller design,

00:06:41.610 --> 00:06:46.220
we have a controller that hooks everything
together, so we'll have an ATContentController.

00:06:46.220 --> 00:06:48.440
This is the main controller for the application.

00:06:48.439 --> 00:06:52.949
And it links that model over to the views.

00:06:52.949 --> 00:06:57.939
In addition, when I double-click on the image on
the right, that's how the browser window came up.

00:06:57.939 --> 00:07:04.699
We're going to use another controller, an
ATFilterBrowserController that controls that browser,

00:07:04.699 --> 00:07:12.149
and what it does is we provide a sourceImage for it
and let the user choose particular pass in the browser

00:07:12.149 --> 00:07:17.579
and it generates a target image called the filteredImage
with a whole bunch of core image filters applied to it

00:07:17.579 --> 00:07:20.649
that we can then get back out of this controller.

00:07:21.750 --> 00:07:25.839
Finally, the purpose of the demo app is
just to change your desktop wallpaper,

00:07:25.839 --> 00:07:30.009
so down there at the bottom we have
that little change of wallpaper button.

00:07:30.009 --> 00:07:32.159
So, how do you do this?

00:07:32.160 --> 00:07:34.400
Well, it's really easy to do on Snow Leopard.

00:07:34.399 --> 00:07:40.739
We have this new Snow Leopard NSWorkspace
API, setDestkopImageURL,

00:07:40.740 --> 00:07:44.000
forScreen with some options, and an error.

00:07:44.000 --> 00:07:49.470
And we're going to pass in a few options or really one
option, like here are some of the ones you can provide.

00:07:49.470 --> 00:07:54.090
You can change things like the
ImageScaling allow it to clip or not.

00:07:54.089 --> 00:07:59.449
And the one that we fill in and care about
is the NSWorkspaceDesktopImageFillColorKey

00:07:59.449 --> 00:08:04.529
so we can set the fill color behind the image.

00:08:04.529 --> 00:08:09.229
Subclassing NSTableView, so the first thing
we're going to talk about is how to go ahead

00:08:09.230 --> 00:08:13.950
and batch load your cell contents for
everything that you see in the table view

00:08:13.949 --> 00:08:18.620
and only in that visibleRect of the table view.

00:08:18.620 --> 00:08:22.379
Now, maybe you're thinking, well, why
don't we just use tableViewWillDisplayCell?

00:08:22.379 --> 00:08:26.350
Isn't it the place where you're going
to be using for the cell drawing?

00:08:26.350 --> 00:08:32.830
And that's a good idea but it's not a great place
to do the way voting of images and other things,

00:08:32.830 --> 00:08:36.750
because that method is called more
times than you may normally expect.

00:08:36.750 --> 00:08:42.929
We have to call it so we can get a fully prepared
cell to do multiple operations, not just drawing

00:08:42.929 --> 00:08:45.120
but for other things too in a table view.

00:08:45.120 --> 00:08:46.620
For instance, type selection.

00:08:46.620 --> 00:08:49.289
What if you type that character Z in your table view?

00:08:49.289 --> 00:08:54.110
We're going to have to try and find a match for that
particular row and the way that the table view does this,

00:08:54.110 --> 00:08:58.029
it gets a fully prepared cell using
the preparedCellAtColumn:row.

00:08:58.029 --> 00:09:01.289
Now, that has to call your willDisplayCell method.

00:09:01.289 --> 00:09:06.649
So it may not actually be displaying that cell at that
time, so it's not really a good place to load images.

00:09:06.649 --> 00:09:11.740
In addition, we also use it in other places like if you
double-click on a column, it will auto resize it to fit

00:09:11.740 --> 00:09:16.460
and there's some other ones that we use it for too.

00:09:16.460 --> 00:09:20.000
So batch loading of cell contents,
how are we going to do that?

00:09:20.000 --> 00:09:23.330
We want to preload everything in
the visibleRect of a table view.

00:09:23.330 --> 00:09:28.840
As you may be aware, there's actually a clip view that's
clipping out other contents that you can't see there.

00:09:28.840 --> 00:09:34.980
What we want to do is we want to cache
an NSRange of just those visible rows.

00:09:34.980 --> 00:09:40.190
So the range will have the range allocation
indicating where it starts at and arrange that length

00:09:40.190 --> 00:09:42.200
for how many rows are actually there in the visibleRect.

00:09:42.200 --> 00:09:47.160
We want to make this code really easy to reuse.

00:09:47.159 --> 00:09:54.089
So we're going to subclass a table view and subclass its
delegate and provide more extensions to the delegate.

00:09:54.090 --> 00:10:01.660
On Snow Leopard, we use formal protocols so we subclass the
NSTableView delegate and create ATDynamicTableViewDelegate.

00:10:01.659 --> 00:10:06.569
That adds a new method, DynamicTableView,
changedVisibleRowsFromRange, toRange,

00:10:06.570 --> 00:10:12.030
so that way things can be loaded dynamically as
they're needed for a particular visible range.

00:10:12.029 --> 00:10:14.980
Notice here that I used the prefix DynamicTableView.

00:10:14.980 --> 00:10:22.070
>> Again, you don't wanna conflict with standard app kit or
Apple-provided classes or delegate methods that we provide,

00:10:22.070 --> 00:10:27.350
so you don't wanna use the standard prefix TableView,
because what if we introduced it later and it conflicts

00:10:27.350 --> 00:10:31.590
with one that you happen to have the same name with?

00:10:31.590 --> 00:10:34.310
So, how do we actually implement this in the cable view?

00:10:34.309 --> 00:10:39.649
Well, we're gonna subclass that table view at an
NSRange ivar to keep track of the visibleRows.

00:10:39.649 --> 00:10:45.679
And you can also see here in this little snippet
of the ATDynamicTableViewDelegate provide

00:10:45.679 --> 00:10:49.089
as an override declaration of the one in NSTableView.

00:10:49.090 --> 00:10:56.080
The best place do this batch loading
of cell contents as lazily as you can,

00:10:56.080 --> 00:11:00.440
is to use a new Leopard API called viewWillDraw.

00:11:00.440 --> 00:11:05.510
So, what you're going to do in viewWillDraw is you want
the superclass to do whatever work it was going to do.

00:11:05.509 --> 00:11:08.240
And in this case, table view actually
doesn't-- delayed layout.

00:11:08.240 --> 00:11:13.269
So, it's always important to call super
viewWillDraw whenever you override that method.

00:11:13.269 --> 00:11:18.509
Now, we just grab the visibleRows and the visibleRect.

00:11:18.509 --> 00:11:24.319
We figure out if the visibleRect is actually changing--
or sorry, if the visibleRows are actually changing.

00:11:24.320 --> 00:11:29.240
So, if that row range is different,
then we can just tell a delegate,

00:11:29.240 --> 00:11:36.430
a delegate the dynamicTableView change the visible rows
from some old range to a new range, really easy to do.

00:11:36.429 --> 00:11:42.239
I'm glossing over some facts here which are actually
included in the demo such as you normally do a response

00:11:42.240 --> 00:11:49.680
to a selector to make sure that the application delegate
response have a particular selector before calling it

00:11:49.679 --> 00:11:53.599
See the app for the details of that.

00:11:53.600 --> 00:11:59.710
So, what does our demo app do in this method, in
this changedVisibleRowsFrom a range to a range?

00:11:59.710 --> 00:12:04.650
Well, we have our table contents,
array of everything in that table,

00:12:04.649 --> 00:12:08.230
so we want to create a subarray of just what you're seeing.

00:12:08.230 --> 00:12:11.529
So, we're going to store that in the observedVisibleItems.

00:12:11.529 --> 00:12:16.220
So given that subarray, we can just
iterate through it and tell each

00:12:16.220 --> 00:12:20.129
of our model objects that we want them to load their images.

00:12:20.129 --> 00:12:25.240
In addition, if they haven't actually loaded
it yet, they're going to change at some point.

00:12:25.240 --> 00:12:33.419
So, we're going to use KVO to add an observer for the
thumbnail image path on that particular model object.

00:12:33.419 --> 00:12:39.269
Now if you're familiar with KVO, then looking at the outline
you may think, oh, you're going to be observing those items,

00:12:39.269 --> 00:12:45.529
you have to stop observing them at some time, and
that's why we have the old visible items stored off.

00:12:45.529 --> 00:12:51.559
So really, the first thing you would do here is you'll
iterate through and remove observer for that key path

00:12:51.559 --> 00:12:56.729
of the thumbnail image first and then you'll do the
work on the previous slide that I just showed you.

00:12:56.730 --> 00:13:01.870
So, the model is going to do all of the work
to actually do this loading of the image.

00:13:01.870 --> 00:13:04.960
So, here is the loadImage method in our model objects.

00:13:04.960 --> 00:13:12.750
What we're going to do here is we're going to use a
shared NSOperationQueue to do all the heavy lifting,

00:13:12.750 --> 00:13:18.509
so all the work of asynchronously loading the images in
the background thread, and we're going to use blocks.

00:13:18.509 --> 00:13:24.279
So the specific code highlighted here is the actual block
callback that will get called in the background thread.

00:13:24.279 --> 00:13:26.519
Now, why are we using a background thread?

00:13:26.519 --> 00:13:33.909
Well, we have this helper method, ATThumbnailImageFromImage
which actually takes your regular image and converts it--

00:13:33.909 --> 00:13:37.399
creates a thumbnail image from it which
will potentially slow it can block,

00:13:37.399 --> 00:13:40.519
and you don't want to stall your
UI to do that on the main thread.

00:13:40.519 --> 00:13:42.779
So, that's why we do it in the background thread.

00:13:42.779 --> 00:13:47.259
If you're doing it on a background
thread, you want to synchronize things.

00:13:47.259 --> 00:13:53.360
So, we want to synchronize the accessing of the image in
the image loading variable so that they're always in sync

00:13:53.360 --> 00:13:56.060
and that we don't do this twice and overstep things.

00:13:56.059 --> 00:14:00.259
So, that's why we use @synchronized only in this method.

00:14:00.259 --> 00:14:05.189
We also use it when we're actually going to assign the
variables, because remember this bit of code's helping

00:14:05.190 --> 00:14:11.270
in the background thread during a
callback when the thread is doing its work.

00:14:11.269 --> 00:14:15.230
The last thing this does is it assigns the thumbnail image.

00:14:15.230 --> 00:14:20.899
Now, we're just using KVOs, so that's going to
send out a KVO notification when it changes.

00:14:20.899 --> 00:14:27.250
As you remember from before, the controller's
watching for those KVO notifications,

00:14:27.250 --> 00:14:31.950
so it's going to get an observed value
for key path of object with a context.

00:14:31.950 --> 00:14:36.750
Now, these KVO notifications sent from the
background thread because that's where it was changed.

00:14:36.750 --> 00:14:40.720
So, we only want to modify the UI on the main thread.

00:14:40.720 --> 00:14:47.649
So, we will do a performSelectorOnMainThread
with the object of the model object that changed.

00:14:47.649 --> 00:14:50.250
We don't care about waiting until it's finished.

00:14:50.250 --> 00:14:52.700
But one thing we do care about is the modes.

00:14:52.700 --> 00:14:56.060
We're going to pass in an array with the RunLoopCommonModes.

00:14:56.059 --> 00:15:03.619
That way that updating the UI happen when normal run loop
operations are happening or a model run loop happens.

00:15:03.620 --> 00:15:09.889
It's also good to use the modes of-- common run
loop modes may do a performSelectorOnMainThread

00:15:09.889 --> 00:15:12.370
or just a regular performSelector on delay.

00:15:12.370 --> 00:15:16.710
The actual work that will happen on
the main thread is what's really easy.

00:15:16.710 --> 00:15:22.940
We just grab the row from our model or go from
our array to figure out what row it's going to be.

00:15:22.940 --> 00:15:29.730
We call a new Snow Leopard API reloadDataForRowIndexes,
columnIndexes to just reload the contents of that cell.

00:15:29.730 --> 00:15:32.259
Really, all it's doing is redisplaying it at this time.

00:15:32.259 --> 00:15:36.779
So, if you're targeting Leopard, you
could easily do a setNeedsDisplayInRect

00:15:36.779 --> 00:15:39.209
on just that cell that needs to redraw.

00:15:39.210 --> 00:15:45.710
Let's move on and talk more about
how to add subviews to a table view,

00:15:45.710 --> 00:15:49.820
now that we've talked about batch loading of cell contents.

00:15:49.820 --> 00:15:55.920
Let's go back to the demo and take a look at that
again so we know exactly what we're talking about.

00:15:57.429 --> 00:16:02.129
So again in the demo application, we
have a normal cell that does our--

00:16:02.129 --> 00:16:05.809
or normal complex cell that does our
drawing of the image and everything else.

00:16:05.809 --> 00:16:10.539
Cells are great because they're very fast for
performance, but you can't do certain things

00:16:10.539 --> 00:16:13.599
like maintain certain state for animations.

00:16:13.600 --> 00:16:20.659
So, we want to use an NSProgressIndicator to do this
animation on the left as the thumbnail images are loading.

00:16:20.659 --> 00:16:28.529
So as I said, some problems that you have in table view,
well, no easy way to do animations and things that you want

00:16:28.529 --> 00:16:31.339
that have animations that you can't
use because we don't have a cell

00:16:31.340 --> 00:16:34.899
that does it, NSProgressIndicator, NSPathControl.

00:16:34.899 --> 00:16:38.309
Path control has the cell but no way to do the animation

00:16:38.309 --> 00:16:42.079
because the animation scored in the
view which maintains that state.

00:16:42.080 --> 00:16:43.580
So, how are we going to do this?

00:16:43.580 --> 00:16:47.230
Well, we want to have some really easy to use reusable code.

00:16:47.230 --> 00:16:49.960
So, we're going to have a delegate method to do it.

00:16:49.960 --> 00:16:55.560
We only want to show views in those visible
rects that we're actually are displaying.

00:16:55.559 --> 00:17:01.369
It doesn't make sense to have views on screen
that you can't see or can't interact with.

00:17:01.370 --> 00:17:05.680
We also want the table to manage everything
for us so that we don't have to do that work.

00:17:05.680 --> 00:17:12.310
So, let's go ahead and extend that delegate
method or extend the delegate protocol

00:17:12.309 --> 00:17:16.759
that we showed earlier will add a
method, dynamicTableView, viewForRow.

00:17:16.759 --> 00:17:22.879
Now here, we're just going to have for the
demo purposes a simple one view per one row.

00:17:22.880 --> 00:17:29.360
You could easily take this application and extend it
to have multiple views per column on multiple columns

00:17:29.359 --> 00:17:34.829
for each individual row, or for simplicity
sake, the demo just has one view per one row.

00:17:37.009 --> 00:17:43.329
The ATDynamicTableView subclass is going to
keep track of the views with a dictionary.

00:17:43.329 --> 00:17:49.369
So we're going to add some more ivars on
MutableDictionary views in visibleRows,

00:17:49.369 --> 00:17:52.289
and also Boolean to keep track of
when we have to update them or not.

00:17:52.289 --> 00:17:57.529
Here is an example what the dictionary looks like.

00:17:57.529 --> 00:17:59.740
So inside of it, there are going to be keys.

00:17:59.740 --> 00:18:07.920
The keys are just NSNumbers where the number is
the row that maps over to the view for that row.

00:18:07.920 --> 00:18:13.190
These first three rows don't actually have a view
so we're going to put NSNull null in the dictionary

00:18:13.190 --> 00:18:16.870
to indicate that there is no view for it.

00:18:16.869 --> 00:18:20.929
The other ones are going to have the view stored there.

00:18:22.390 --> 00:18:27.540
Again, a great place to do this
lazy view edition is viewWillDraw.

00:18:27.539 --> 00:18:33.730
This is the place that you want to add subviews, do
setNeedsDisplayInRects and other last minute work.

00:18:33.730 --> 00:18:38.039
You don't want to do it in drawRect
or draw interior frame of a cell.

00:18:38.039 --> 00:18:39.670
That's too late to do it.

00:18:39.670 --> 00:18:43.019
The appropriate place is viewWillDraw.

00:18:43.019 --> 00:18:48.859
So as before, the first thing that we would
do is we're going to update the visibleRows.

00:18:48.859 --> 00:18:52.949
In addition, we'll also set a Boolean
whether or not the views need update.

00:18:52.950 --> 00:18:57.850
So, obviously we need to update the views
whenever those visibleRows are changing.

00:18:57.849 --> 00:19:04.069
So, once they do need updating, but we want to
remove visibleRows which are no longer visible.

00:19:04.069 --> 00:19:06.109
So, it's really easy to do that.

00:19:06.109 --> 00:19:11.059
We create index set with the old
visibleRows, subtract any that are still visible

00:19:11.059 --> 00:19:17.299
and that gives us the resulting index
set of what's no longer on screen.

00:19:17.299 --> 00:19:19.250
We can just iterate through that index set.

00:19:19.250 --> 00:19:24.130
So, we'll just iterate through each
row in index set and create an NSNumber

00:19:24.130 --> 00:19:27.070
for that row, see if it's in our dictionary.

00:19:27.069 --> 00:19:33.169
If it is, we remove it from the super view and remove it
from our dictionary, so that view storage is just gone.

00:19:33.170 --> 00:19:38.550
Now, the code to actually add in the views is really easy.

00:19:38.549 --> 00:19:42.430
We iterate through all the visibleRows,
create a key for, again,

00:19:42.430 --> 00:19:47.460
that row and access it to see if a view is already there.

00:19:47.460 --> 00:19:49.350
If it's not, we ask the delegate.

00:19:49.349 --> 00:19:54.740
Hey, dynamicTableView or viewForRow, give me a row
back, or sorry, give me a view back for that row.

00:19:54.740 --> 00:20:00.849
And if it did give me a view back, we're going to
add as a subview and store it on our dictionary.

00:20:00.849 --> 00:20:06.959
If it didn't, we don't want to call the delegate back
again and again, so we're just going to use an NSNull

00:20:06.960 --> 00:20:10.509
and null place holder so we don't
call it back again and again.

00:20:10.509 --> 00:20:16.569
And of course, you can't put nil into a dictionary, so
that's one of the reasons why we use null as a place holder.

00:20:19.000 --> 00:20:27.190
>> So, other key places that you actually want to
do some updating of the viewsNeedUpdate variable.

00:20:27.190 --> 00:20:31.840
Things like reloadData, noteHeightOfRowsWithIndexesChanged,

00:20:31.839 --> 00:20:36.759
and another in new Snow Leopard API,
reloadDataForRowIndexes, columnIndexes.

00:20:36.759 --> 00:20:40.890
That way, you know when it needs to be updated.

00:20:40.890 --> 00:20:43.710
So, what does the actual delegate do for this?

00:20:43.710 --> 00:20:49.769
Well back to that sample application, it's going to
implement in its controller, dynamicTableView, viewForRow.

00:20:49.769 --> 00:20:54.650
And what it wants to create is a progress
indicator for all its model objects

00:20:54.650 --> 00:20:58.290
which don't have an image or a thumbnail image loaded yet.

00:20:58.289 --> 00:21:04.879
So we grab the model object for that row, see if we
actually don't have the thumbnail image created yet.

00:21:04.880 --> 00:21:10.850
If we don't, we're going to alloc init a progress indictor
for it, and I'm going to snip out and ignore some code

00:21:10.849 --> 00:21:14.869
where it's actually going to set the
properties for the progress indicator.

00:21:14.869 --> 00:21:18.779
Now, we want to place it at the
right location within that cell.

00:21:18.779 --> 00:21:22.279
So, we're going to grab the frame
for the cell of that column row

00:21:22.279 --> 00:21:27.369
and just place the progress indicator's
frame right in the center of that.

00:21:27.369 --> 00:21:34.809
You could place it wherever you want if it's some other type
of view or some position that you want that's not centered.

00:21:34.809 --> 00:21:38.629
This is just left up to the delegate for
that purpose because the table doesn't know

00:21:38.630 --> 00:21:45.230
where you'd want that view inside the cell.

00:21:45.230 --> 00:21:48.860
So, we just talked about adding subviews to a table view.

00:21:48.859 --> 00:21:53.859
Let's move on a little bit and talk about
creating custom cell editors for our table view.

00:21:53.859 --> 00:22:01.119
Again, let's take a look at the demo so we
can understand fully what we're talking about.

00:22:03.549 --> 00:22:12.839
So in the demo application, when you click on one of
these particular colors, we do a neat little pop-up window

00:22:12.839 --> 00:22:19.419
and it allows you to select a particular
color, and it changes that color in the cell.

00:22:19.420 --> 00:22:24.779
Of course, the cell has multiple values in it.

00:22:24.779 --> 00:22:31.710
You could potentially edit the value here and you could
potentially change a different color in the same cell.

00:22:31.710 --> 00:22:40.670
So, we have multiple values that
we want to edit in one single cell.

00:22:40.670 --> 00:22:47.539
So, that begs the question, how do you change
those multiple values in one particular cell?

00:22:47.539 --> 00:22:52.869
The normal object value is just going to be
the title that you see there for the cell,

00:22:52.869 --> 00:22:55.929
but this particular cell has multiple
values like the fill color.

00:22:55.930 --> 00:22:59.080
You could also imagine making the image changeable too.

00:22:59.079 --> 00:23:04.389
How do we change that value and somehow
tell the delegate or data source

00:23:04.390 --> 00:23:09.370
that this cell had one particular different
value than normal object value that changed?

00:23:09.369 --> 00:23:16.429
And, how do you actually edit that cell outside
of normal tracking, but what is normal tracking?

00:23:16.430 --> 00:23:21.570
Normally when you're editing a cell like a button
or a slider or something else in a table view,

00:23:21.569 --> 00:23:23.990
you click and you hold your mouse down in it.

00:23:23.990 --> 00:23:27.539
The cell tracks completely as you
are holding down that mouse

00:23:27.539 --> 00:23:30.859
until you let it go, and then the object value changes.

00:23:30.859 --> 00:23:36.799
But what we're doing here is we're going to actually
change that value outside that normal mouse tracking loop.

00:23:36.799 --> 00:23:40.809
So how do we do that and what's a good way to do it?

00:23:40.809 --> 00:23:42.990
So how do we solve these problems?

00:23:42.990 --> 00:23:48.759
Well, we want the cell to just talk to the
table and tell it when it needs to do things.

00:23:48.759 --> 00:23:54.730
So we'll extend our ATDynamicTableView and add
a couple more methods for the cell to call.

00:23:54.730 --> 00:23:59.990
This property or these methods here
are willStartEditingProperty forCell,

00:23:59.990 --> 00:24:05.870
didEndEditingProperty forCell successfully, but
the key thing here is that the cell is going

00:24:05.869 --> 00:24:09.429
to tell the table view what property
it's going to be editing.

00:24:09.430 --> 00:24:12.670
That way, the table view can deal with
multiple properties from a single cell.

00:24:12.670 --> 00:24:17.990
So, how is this going to work?

00:24:17.990 --> 00:24:20.490
We have this one cell here.

00:24:20.490 --> 00:24:26.120
You click on it and it is going to say to the
table view, hey, we're editing the fill color.

00:24:26.119 --> 00:24:32.269
And it's going to do it by saying, tableView
willStartEditingProperty:@"fillColor" forCell:self.

00:24:32.269 --> 00:24:34.549
What does the table have to do in this case?

00:24:34.549 --> 00:24:42.269
Well, the table view needs to save off the editing
cell, save off the editing row, and column.

00:24:42.269 --> 00:24:44.879
Now, why is it going to do that?

00:24:44.880 --> 00:24:50.290
Here is a snippet of the header where it's got the
extra ivars for the row and the column and the cell.

00:24:50.289 --> 00:24:55.339
We override preparedCellAtRow column--
or sorry, preparedCellAtColumn row.

00:24:55.339 --> 00:25:00.240
And if that editing row is the
one that we are actually editing,

00:25:00.240 --> 00:25:03.620
we want to return that same cell as being edited right then.

00:25:03.619 --> 00:25:07.839
That way, you could have something which is dynamically
changing the properties of that single cell outside

00:25:07.839 --> 00:25:14.429
of its normal tracking loop and it's constantly
reflecting and updating the values right then live.

00:25:14.430 --> 00:25:18.690
So if that is the particular row column
that we want to know, we just return

00:25:18.690 --> 00:25:24.140
or retain auto-release version of that cell.

00:25:24.140 --> 00:25:29.490
The cell is actually going to do its editing
of its property with its own controller.

00:25:29.490 --> 00:25:37.299
So we created an AT color table controller inside
the demo app that edits cell color properties.

00:25:37.299 --> 00:25:43.740
So, all the controller does is it completely
abstractly pops up a particular color picker thing

00:25:43.740 --> 00:25:46.650
around custom one at a particular location.

00:25:46.650 --> 00:25:52.430
The user can then go ahead and change
the actual selected color to something.

00:25:52.430 --> 00:25:55.430
The controller is watching for that color to change.

00:25:55.430 --> 00:26:00.690
After that color does change, the controller
can then go ahead and tell whose watching

00:26:00.690 --> 00:26:04.210
or using the controller, in this case it's the cell.

00:26:04.210 --> 00:26:08.470
So the cell knows that its color went and changed.

00:26:08.470 --> 00:26:14.910
So, now the cell can just tell the table view, "Hey,
I'm done editing the fill color with a tableView--

00:26:14.910 --> 00:26:19.279
didEndEditingProperty:@"fillColor"
forCell:self successfully:YES.

00:26:19.279 --> 00:26:22.460
So, you can imagine other places in the demo code.

00:26:22.460 --> 00:26:29.329
We tell it successfully no when you hit Escape
or clicked away from that particular pop-up.

00:26:29.329 --> 00:26:34.019
The table view itself now needs to update the data source.

00:26:34.019 --> 00:26:42.049
So normally you have a delegate method,
tableView:setObjectValue:forTableColumn:row.

00:26:42.049 --> 00:26:46.940
We're going to extend that delegate method and
have an implementation that's very similar,

00:26:46.940 --> 00:26:52.039
dynamic tableView:setObjectValue:forTableColumn:row
property.

00:26:52.039 --> 00:26:57.440
So, we can tell the table view when its updating
one particular property in a multi-valued cell,

00:26:57.440 --> 00:27:04.700
Now the controller, here's the implementation of
that method, and what it's going to do is it's going

00:27:04.700 --> 00:27:08.779
to grab its model object and see what's property changed.

00:27:08.779 --> 00:27:14.819
So, if the fill color changed, it's going to go ahead
and update its fill color model object property.

00:27:17.970 --> 00:27:22.660
So, we just talked about some custom
cell editors inside table view.

00:27:22.660 --> 00:27:25.050
Now, let's go ahead and talk about
some cool custom animations

00:27:25.049 --> 00:27:29.389
that you can do and how to actually go and do them.

00:27:29.390 --> 00:27:31.560
So, how do you actually animate from a table view?

00:27:31.559 --> 00:27:41.889
Again, let's take a look at the
demo to see exactly how it's done.

00:27:41.890 --> 00:27:48.060
So inside of the demo application, the animation we're
talking about is when you click on a particular row,

00:27:48.059 --> 00:27:51.329
we're animating several things at the same time here.

00:27:51.329 --> 00:27:56.750
I can slow down with the Shift key, and first
of all, we're animating clearly the image

00:27:56.750 --> 00:28:00.000
from the table view to the image on the right.

00:28:00.000 --> 00:28:02.660
But also look at the background color above.

00:28:02.660 --> 00:28:11.450
We're fading from one background color to another and at
the same time, the image that was there has an opacity fade

00:28:11.450 --> 00:28:15.809
or an alpha-value fade that's going out at the same time.

00:28:15.809 --> 00:28:23.730
So, those are the animations we're going to talk about.

00:28:23.730 --> 00:28:26.490
So, how are we going to do this?

00:28:26.490 --> 00:28:30.720
We're going to use an overlay window that
starts at that location in the table view

00:28:30.720 --> 00:28:34.190
with an image-- the same image as what we're displaying.

00:28:34.190 --> 00:28:40.279
We're then going to just use the animator or proxy object to
animate that windows frame from one location to the other,

00:28:40.279 --> 00:28:47.319
and at the same time, we can animate the
opacity or the alpha-value out of the image

00:28:47.319 --> 00:28:54.329
and also animate the background
color from one color to another.

00:28:54.329 --> 00:28:58.220
So, that begs the question why
are you using an overlay window?

00:28:58.220 --> 00:29:04.009
On Leopard, we support views where you can have
one sibling view that overlaps another sibling view

00:29:04.009 --> 00:29:07.390
if it's got a higher Z-order in the view hierarchy.

00:29:07.390 --> 00:29:12.550
So, you could have just have one view that overlaps and
moves around from one to the other and that's a great way

00:29:12.549 --> 00:29:15.750
to do it and it works really well in those cases.

00:29:15.750 --> 00:29:22.920
But in this case here, we want to do that opacity and
fade and background color animation and it's really easy

00:29:22.920 --> 00:29:26.769
to do those animations on that
side view with core animation,

00:29:26.769 --> 00:29:30.119
we can just animate the alpha-value really easily.

00:29:30.119 --> 00:29:33.959
So, we want to do setWantsLayer:YES, so that
we can actually do that type of animation.

00:29:33.960 --> 00:29:39.120
Now the table view on the other side, well,
it's not gonna be a layer back table view

00:29:39.119 --> 00:29:42.279
because it doesn't need to be and then there's a problem.

00:29:42.279 --> 00:29:50.579
How do you have a nonlayer back table view work with a layer
back view and have one sibling view that overlaps them.

00:29:50.579 --> 00:29:55.240
That actually won't work because the
view layers aren't quite the same.

00:29:55.240 --> 00:29:59.440
So, that's a problem which we're trying to solve
and why we're using overlay window to do it.

00:29:59.440 --> 00:30:04.900
So, how do we actually go ahead and
create an overlay window that does it?

00:30:04.900 --> 00:30:07.190
Well, it's really easy to do.

00:30:07.190 --> 00:30:13.080
We're just creating using alloc init
with a-- to create a simple NSWindow.

00:30:13.079 --> 00:30:17.069
>> The key things I'm highlighting here,
we want the window to not have a border.

00:30:17.069 --> 00:30:21.119
So NSBorderLessWindowMask is passed to the styleMask.

00:30:21.119 --> 00:30:26.079
We don't want it to be opaque and we want
to have a background color of a clear color,

00:30:26.079 --> 00:30:31.589
so that way anything beyond the window's
contents are just completely invisible

00:30:31.589 --> 00:30:34.319
and you can't see them or click on them.

00:30:34.319 --> 00:30:37.490
The main contents for the window is just regular image view

00:30:37.490 --> 00:30:42.990
that has the same contents as the
starting image of the thumbnail.

00:30:42.990 --> 00:30:48.150
So really, the work is just figuring out how to
move this window from one location to another.

00:30:48.150 --> 00:30:52.400
We have that custom cell there and we're
going to create a special method to figure

00:30:52.400 --> 00:30:54.970
out where we're going to start the animation from.

00:30:54.970 --> 00:30:58.850
And we're going to call it screenImageRect
for a particular row.

00:30:58.849 --> 00:31:03.539
We can create a completely prepared
cell for the particular row column

00:31:03.539 --> 00:31:06.970
and given that, we can find the frame of the whole cell.

00:31:06.970 --> 00:31:13.870
Once we know the frame of the whole cell, we can have
the cell tell us the imageRect for particular bounds

00:31:13.869 --> 00:31:18.889
and that gives us the cellImageFrame
within that overall cell frame.

00:31:18.890 --> 00:31:23.610
We can then just convert to the rect
coordinate system for the window.

00:31:23.609 --> 00:31:29.669
So we do a convertRect to the View and convertBaseToScreen
to get the screen coordinates for a particular rect,

00:31:29.670 --> 00:31:31.170
which is the appropriate rect for the window.

00:31:31.170 --> 00:31:35.250
Now how do we set up the animation?

00:31:35.250 --> 00:31:39.259
Well the main thing is that we want
the animations to remain in sync.

00:31:39.259 --> 00:31:43.930
So we bring that window forward and we
create a grouping for animation context.

00:31:43.930 --> 00:31:47.470
We set properties that we want in animation

00:31:47.470 --> 00:31:53.950
like the duration then we just use the animator
proxy object to do the animation for us.

00:31:53.950 --> 00:31:58.160
So we do things like the frame window
animation, the alpha-value fadeout,

00:31:58.160 --> 00:32:01.350
and the background color changing from one color to another.

00:32:01.349 --> 00:32:05.929
Now there's a problem here is if
you are using a normal NSAnimation,

00:32:05.930 --> 00:32:08.230
there's a delegate method to know when things finished.

00:32:08.230 --> 00:32:12.670
Or if you're using CoreAnimation animation
similarly, there's a delegate to know when it's done.

00:32:12.670 --> 00:32:16.220
So how do we know when these animator proxy ones are done?

00:32:16.220 --> 00:32:22.309
Well there are a couple of ways to do it, one easy way is
to use an NSTimer to figure out after that work is done

00:32:22.309 --> 00:32:26.319
to actually do a particular cleanup work
like remove that window from things.

00:32:26.319 --> 00:32:31.349
You could also do a performSelector after delay
with an appropriate delay, but for this purposes,

00:32:31.349 --> 00:32:38.419
in the demo app it was easy to use a timer so we could
actually cancel, rewind it and control it a little better.

00:32:38.420 --> 00:32:46.890
So when the timer is finished, meaning the animation is
done, we can do some cleanup like we can set the final image

00:32:46.890 --> 00:32:51.480
in that big image view, set the alpha back to 1.0.

00:32:51.480 --> 00:32:58.920
And then we can force the window to display so that way it's
completely displayed before we remove our animation window

00:32:58.920 --> 00:33:01.140
actually out and disappear.

00:33:01.140 --> 00:33:05.210
This way everything moves and it's
smooth and you don't get any flicker.

00:33:07.089 --> 00:33:13.019
So custom animations, how do you do
the pop-up window-type animation?

00:33:13.019 --> 00:33:20.349
We just finished talking about the animating
from a table view to another image view.

00:33:20.349 --> 00:33:27.559
And let's take a look at that pop-up animation again so we
are all on the same page and know what we're talking about.

00:33:28.950 --> 00:33:34.390
So now the thing we want to talk
about is this little pop-up animation.

00:33:34.390 --> 00:33:39.009
So how do we create, oops, a pop-up window like that?

00:33:39.009 --> 00:33:45.980
[ Pause ]

00:33:45.980 --> 00:33:51.079
>> So the first thing we are going to do is we are
going to cache the contentView as an NSBitmapImageRep.

00:33:51.079 --> 00:33:57.029
So given that content view there we are
going to, again this is an NSWindow subclass,

00:33:57.029 --> 00:34:00.789
we are going to grab the content
view, save it off for later.

00:34:00.789 --> 00:34:07.339
And then take our visible rect, what we're seeing
and create a BitmapImageRep for that display rect

00:34:07.339 --> 00:34:14.500
and then cache the contents of the view, the table
view that we're seeing there, into an NSBitmapImageRep.

00:34:14.500 --> 00:34:19.619
After we have that we can replace the
contentView with a layer-backed view,

00:34:19.619 --> 00:34:22.739
so it's just going to have no contents at that point.

00:34:22.739 --> 00:34:29.119
The way we are doing that is just a regular NSView
which has setWantsLayer:YES as the content view.

00:34:29.119 --> 00:34:34.389
Inside of that we can add a child
layer to actually do the animation,

00:34:34.389 --> 00:34:40.129
so we are just going to add a regular
CALayer that's a sublayer of it.

00:34:40.130 --> 00:34:44.140
That's going to be the thing that actually
is animated within that content view.

00:34:44.139 --> 00:34:51.849
So the code for that is we just create a regular CALayer
layer, set a bunch of properties that we want on it.

00:34:51.849 --> 00:34:57.110
But the key property for these purposes
is we're taking that BitmapImageRep,

00:34:57.110 --> 00:35:00.630
grabbing the CGImage from it and
saying that as the contents.

00:35:00.630 --> 00:35:08.630
So that way that layer has an image for the
view, which we want to actually see and animate.

00:35:08.630 --> 00:35:12.180
We take it and we shrink the view down with a transform.

00:35:12.179 --> 00:35:16.279
So there's a helper method we wrote that
creates the transform for a particular scale.

00:35:16.280 --> 00:35:21.019
So we start at a really small scale
and then we just add as a sublayer.

00:35:21.019 --> 00:35:26.300
So we are starting at a really small scale
and we want to use CoreAnimation to animate.

00:35:26.300 --> 00:35:29.500
That layer is transformed to the bigger size.

00:35:31.090 --> 00:35:34.370
So again, it's great to have a helper method that does this,

00:35:34.369 --> 00:35:39.839
so we have a method called addAnimationToScale
for a particular duration.

00:35:39.840 --> 00:35:45.400
So we create a basic CAAnimation
animation to do this for us.

00:35:45.400 --> 00:35:51.430
We set the fromValue to be our current transform, so it's
going to be that current small transform that we created.

00:35:51.429 --> 00:35:58.669
Set some properties like the duration and delegate, and
I'll explain why we set ourselves to delegate in a second.

00:35:58.670 --> 00:36:03.630
Then on the layer itself, we set its final
size to the final scale for that animation.

00:36:03.630 --> 00:36:10.990
In that way if you end an animation, the layer
size is the ending size that we want it to be.

00:36:10.989 --> 00:36:16.609
Then we go ahead and add that animation to the layer,
so the layer is going to do the animation for us.

00:36:16.610 --> 00:36:22.440
Now we want to create that pop-up effect, so
how can we make a particular pop-up effect?

00:36:22.440 --> 00:36:28.139
Well we can take those animations and
chain from one animation to another.

00:36:28.139 --> 00:36:34.529
So inside of animationDidStop finished, we're going
to get this callback when the animation is done,

00:36:34.530 --> 00:36:38.480
because we are the CAAnimation's delegate.

00:36:38.480 --> 00:36:42.960
So we can just keep track, well if we are
actually doing a growing we can go ahead

00:36:42.960 --> 00:36:45.460
and say well we're not growing
anymore, we're going to be shrinking.

00:36:45.460 --> 00:36:52.920
And then we can add an animation to the particular shrink
scale that we want with a particular shrink duration.

00:36:52.920 --> 00:36:58.070
Then when that animation is done we can say
well if we were shrinking we are going grow back

00:36:58.070 --> 00:37:01.930
to our original 1.0
scale and add an animation for that.

00:37:01.929 --> 00:37:09.519
Finally, after they're all done we want to do some
cleanup, so we'll have a cleanup and restore views method.

00:37:09.519 --> 00:37:16.480
So in the cleanup method we want to
restore that original content view

00:37:16.480 --> 00:37:19.960
so you have the original table to actually interact with.

00:37:19.960 --> 00:37:21.820
It's really easy to do cleanup.

00:37:21.820 --> 00:37:28.440
So inside the cleanup we're going to disable some screen
updates and restore things like the original content view,

00:37:28.440 --> 00:37:31.619
release some of the animation views
and remove it from the super view.

00:37:31.619 --> 00:37:35.779
And some other minor details which you can
look at the demo app to see what we do.

00:37:35.780 --> 00:37:39.769
But this makes it restore it without any flicker.

00:37:40.889 --> 00:37:43.989
So now that I've discussed a bunch
of things about table views,

00:37:43.989 --> 00:37:47.889
I'm going to hand it over to my colleague
Raleigh Ledet to talk about Custom NSBrowser API.

00:37:47.889 --> 00:37:50.069
>> That was great.

00:37:50.070 --> 00:37:56.370
So we have some new API in Snow Leopard for NSBrowsers that
will hopefully make your life a lot easier and allow you

00:37:56.369 --> 00:37:59.809
to do some really nice nifty neat new things.

00:37:59.809 --> 00:38:02.119
So Corbin showed you a whole bunch of stuff with table views

00:38:02.119 --> 00:38:05.639
and how to add some custom cell
editors and do some animations.

00:38:05.639 --> 00:38:09.739
And we're going to focus on NSBrowser and we're
going to focus on some new Snow Leopard API.

00:38:09.739 --> 00:38:12.199
Let's get a refresher.

00:38:12.199 --> 00:38:17.730
We're going to go back to the demo station
and show you that portion, here we are.

00:38:17.730 --> 00:38:29.740
So here's our sample application and we'll
find us a nice image here, let's see,

00:38:29.739 --> 00:38:34.209
here we go, wait for the fish to come up.

00:38:34.210 --> 00:38:43.019
We double-click on the fish and we'll bring up our browser
and we'll pull up three columns so we can see that.

00:38:43.019 --> 00:38:48.369
So we have here a header column, so this is
our sourceImage so these controls are disabled.

00:38:48.369 --> 00:38:54.429
And we'll go ahead and do a hue adjust so we can
change the color because I like blue, here we go.

00:38:54.429 --> 00:38:59.929
And then we'll go ahead and add a blur onto
this and soften it up just a little bit.

00:38:59.929 --> 00:39:07.879
And now you see over here a preview column, and we
can hit the Apply Filter button, and it goes back

00:39:07.880 --> 00:39:12.010
and we can now set this as our wallpaper and that all works.

00:39:12.010 --> 00:39:14.310
So we're going to show you how to
do those header columns in browser

00:39:14.309 --> 00:39:18.009
and how to do those preview columns
using some of the new API.

00:39:18.010 --> 00:39:22.590
[ Pause ]

00:39:22.590 --> 00:39:26.510
>> So the new API is item based,
so we are going to cover that

00:39:26.510 --> 00:39:28.830
and we'll cover the custom headers and the preview headers.

00:39:28.829 --> 00:39:34.759
So the new API is very similar to the
API that already exists in NSOutlineView.

00:39:34.760 --> 00:39:37.620
It's an item-based API as well.

00:39:37.619 --> 00:39:42.420
We've made one enhancement in that the items
don't have to be unique for the new NSBrowser.

00:39:42.420 --> 00:39:46.710
They still have to be unique for
NSOutlineView but they don't have to be unique,

00:39:46.710 --> 00:39:48.579
so you can have the same item in multiple columns.

00:39:48.579 --> 00:39:51.429
That works out really nicely.

00:39:51.429 --> 00:39:56.219
The implementation no longer uses NSMatrix, so if you--

00:39:56.219 --> 00:40:06.459
in the old version you would have to push the content you
wanted onto the matrix, matrices or override willDisplayCell

00:40:06.460 --> 00:40:08.619
and put all the content there and keep track of all that.

00:40:08.619 --> 00:40:13.099
So now it's set up more like a data source
and we'll just query for the information,

00:40:13.099 --> 00:40:19.949
which means that the old matrix API will
no longer work unless you are continuing

00:40:19.949 --> 00:40:21.539
to use that old code and that old method.

00:40:21.539 --> 00:40:24.500
>> So you can't mix and match the new API and the old API.

00:40:24.500 --> 00:40:29.300
The old API is still there for backwards binary
compatibility and the header view in the preview columns

00:40:29.300 --> 00:40:32.039
that we're going to talk about only work with the new API.

00:40:32.039 --> 00:40:41.849
So there's some existing API that still works no matter
which mode you're using, the matrix or the item-based mode,

00:40:41.849 --> 00:40:47.299
so you can still set your class cells, you can have a
custom cell and you could still override willDisplayCell

00:40:47.300 --> 00:40:53.170
and you can make custom additions to your cell that way.

00:40:53.170 --> 00:40:58.070
So, we're going to talk about the new API in relation
to how we implemented it for this demo application.

00:40:58.070 --> 00:41:02.580
So we're going to look at our class
hierarchy of application.

00:41:02.579 --> 00:41:07.069
That whole table view is controlled by a
window controller that loads that from a NIB

00:41:07.070 --> 00:41:10.150
and that's our custom ATFilterBrowserController.

00:41:10.150 --> 00:41:17.750
It has a sourceImage and the filteredImage that
Corbin had mentioned earlier and it contains an AT,

00:41:17.750 --> 00:41:21.449
a root AT filter item and an AT filter
item has each children and that's all

00:41:21.449 --> 00:41:25.210
of your different children for your columns as you go along.

00:41:25.210 --> 00:41:28.639
Each filter item has an input source
and some various other properties

00:41:28.639 --> 00:41:36.599
like the resulting image and the localized filter name.

00:41:36.599 --> 00:41:41.469
So for NSBrowser, you have a parent
item for the next column.

00:41:41.469 --> 00:41:47.779
So, and in that column has, however many children are
associated with that parent item and this continues

00:41:47.780 --> 00:41:50.920
on down the line, just like when you
turn out a triangle in outline view.

00:41:50.920 --> 00:41:55.420
So, your next selected item becomes the
parent for the next columns, children.

00:41:55.420 --> 00:42:02.210
And this is a new API that you actually have to implement
and this is the API that we have in our controller class.

00:42:02.210 --> 00:42:08.490
So once you implement browser numberOfChildrenOfItem
in your delegate for NSBrowser,

00:42:08.489 --> 00:42:10.539
we'll switch over to using that item based API.

00:42:10.539 --> 00:42:13.329
We expect you to have all three
of these methods implemented.

00:42:13.329 --> 00:42:21.269
So we asked for the number of children of a particular
parent item and in this case we'll just return the count

00:42:21.269 --> 00:42:28.329
for the child items then we'll ask for a particular
child of that parent item, a particular child index.

00:42:28.329 --> 00:42:29.130
Again, it's real simple.

00:42:29.130 --> 00:42:37.200
We just take that item and we get the child items from
it and return back that item, that index in that array.

00:42:37.199 --> 00:42:41.569
And then we'll ask for the object value
for that item to put into the cell

00:42:41.570 --> 00:42:47.480
and here we'll just use the localized
filter name for that property.

00:42:47.480 --> 00:42:52.130
So again, you just hand it back the items that
you've already given to us as we go down the chain.

00:42:52.130 --> 00:42:54.000
You can grab your properties out of there.

00:42:54.000 --> 00:42:55.360
It works really nicely.

00:42:55.360 --> 00:43:00.380
You also notice that these methods are
really, really simple and unlike outline view

00:43:00.380 --> 00:43:04.710
that we're not worrying about nil
as some of you might remember.

00:43:04.710 --> 00:43:10.670
Because by default, just like outline
view, the initial parent item is nil.

00:43:10.670 --> 00:43:16.940
And you can have extra code in your
delegate methods to compensate for that.

00:43:16.940 --> 00:43:20.570
So if the parent item is nil, you
know you're on your zero-width column.

00:43:20.570 --> 00:43:26.519
Well, in browser we've added an optional delegate method
that you can implement that we will actually ask you

00:43:26.519 --> 00:43:29.380
for that root item and that's what
we did in our controllers.

00:43:29.380 --> 00:43:32.130
We've implemented this so we've
created our first child item.

00:43:32.130 --> 00:43:42.289
We supply that as the route browser, the route, excuse
me, the root item for the browser using this delegate API.

00:43:42.289 --> 00:43:48.710
And, so we know that we're never going to be given a nil
to start off with and it cleaned up all that extra code

00:43:48.710 --> 00:43:52.559
that we would have had it do to make special case for nil.

00:43:52.559 --> 00:43:57.799
We load our root item lazily so we
wait until the controller is loaded

00:43:57.800 --> 00:44:00.030
and the browser is actually trying to display something.

00:44:00.030 --> 00:44:04.680
So if we don't already have one, we'll
go ahead and create our filter item.

00:44:04.679 --> 00:44:10.819
Once we have a filter item, we'll
just return our root item from there.

00:44:10.820 --> 00:44:17.800
You may also be asked if an item is a leaf item and
what a leaf item means is it doesn't have any children

00:44:17.800 --> 00:44:24.870
and it can't have any children and you may
potentially wanted to show a preview column.

00:44:24.869 --> 00:44:26.579
This is our implementation.

00:44:26.579 --> 00:44:33.679
The method is browser isLeaf of Item, I'm sorry
is browser isLeafItem item and we just return

00:44:33.679 --> 00:44:37.469
if the child items for our item are counted zero.

00:44:37.469 --> 00:44:42.579
Now, it works great for this sample application
because there's only one item, the non-filter

00:44:42.579 --> 00:44:46.480
and it doesn't have any children
obviously, so it's the leaf item.

00:44:46.480 --> 00:44:52.119
If you're doing a directory hierarchy, for example,
you might have an empty folder that can have children.

00:44:52.119 --> 00:44:56.119
It just happens to have no children, so you need to
have the right kind of logic for your application here.

00:44:56.119 --> 00:45:06.039
And so along with these new delegate APIs,
we have some new APIs on NSBrowser itself

00:45:06.039 --> 00:45:09.509
to help you get it some different
things and here is one of them.

00:45:09.510 --> 00:45:11.920
Parent for items in column.

00:45:11.920 --> 00:45:20.519
So when the columns are changing, we needed to
hook up the sourceImage from one column to--

00:45:20.519 --> 00:45:24.889
the resulting image from one column to the sourceImage of
the next column so we could chain our filters together,

00:45:24.889 --> 00:45:29.170
and so we do that by getting the
parent item for that particular column.

00:45:29.170 --> 00:45:33.090
So we know which columns are changing, we
can get the parent item for that column

00:45:33.090 --> 00:45:38.809
and we have been using the item-based API to do this,
and we can get the parent item for the previous column

00:45:38.809 --> 00:45:47.409
and we can go ahead and bind the resulting image from
the previous to the sourceImage of the current column.

00:45:47.409 --> 00:45:51.329
So you have some column and for example
column 1 and there was the parent item

00:45:51.329 --> 00:45:52.569
and that is what I was talking about earlier.

00:45:52.570 --> 00:45:55.500
So you can always get the parent
item for a particular column number

00:45:55.500 --> 00:46:02.920
and there is the short version of
the API parent for item and column.

00:46:02.920 --> 00:46:11.059
So we're going to move on to the custom header
views and they turn out to be really easy to use.

00:46:11.059 --> 00:46:12.329
This is incredibly simple.

00:46:12.329 --> 00:46:13.380
This is great, I love this.

00:46:13.380 --> 00:46:19.130
And it's all based on the view controller and then you
have your view controller and your view controller is going

00:46:19.130 --> 00:46:25.950
to load a NIB and that NIB defines what
goes into the header for that column.

00:46:25.949 --> 00:46:31.039
So, view controllers have a represented object and
we'll automatically going to set the represented object

00:46:31.039 --> 00:46:38.369
to the parent for that column and in this case, our
represented object has all sorts of nice nifty properties

00:46:38.369 --> 00:46:45.109
because it's the AT filter item such as the input
values and the resultingImage and the sourceImage.

00:46:45.110 --> 00:46:49.030
So, all you have to do is you go into Interface Builder
when you're setting up your NIB for your view controller

00:46:49.030 --> 00:46:54.730
and you could bind all your various properties to your
represented object, in case we're binding the image there

00:46:54.730 --> 00:46:58.179
to the representatedobject.resultingNSIimage.

00:46:58.179 --> 00:47:03.449
And so now, the sliders are going to work and
because they're bound to the input min and max values

00:47:03.449 --> 00:47:07.500
so they get the right range for the particular
filter and they have the current value

00:47:07.500 --> 00:47:11.239
and they'll automatically enable and disable themselves.

00:47:11.239 --> 00:47:16.159
And that's all you have to do and here's our implementation

00:47:16.159 --> 00:47:21.649
and the delegate method is browser
headerViewControllerForItem.

00:47:21.650 --> 00:47:26.170
We just go ahead and create a standard view
controller, that's all we needed in this case,

00:47:26.170 --> 00:47:29.809
and we need it with our NIB that
we wanted for our header column

00:47:29.809 --> 00:47:34.139
and we return that for each column that is not a leaf.

00:47:34.139 --> 00:47:39.109
We return that for every time we're asked for a
header view column and we wanted them to be the same.

00:47:39.110 --> 00:47:43.000
If you don't want a header view in a
particular column, you can just return nil.

00:47:43.000 --> 00:47:48.710
If you want different header columns for different items
where you're given the item, you can inspect the item

00:47:48.710 --> 00:47:53.210
and decide to return a different view
controller or just load in a different NIB

00:47:53.210 --> 00:47:54.559
if you're using the standard view controller.

00:47:54.559 --> 00:47:55.779
And that's it.

00:47:55.780 --> 00:48:00.350
That's all you have to do and preview
works exactly the same way.

00:48:00.349 --> 00:48:05.259
If it's a leaf item, we might go ahead ask
you for the previewViewControllerForLeafItem.

00:48:05.260 --> 00:48:10.470
So if you implement this delegate method,
you can return your own view controller there

00:48:10.469 --> 00:48:14.469
and you can have your different NIBS
for different items or you return nil

00:48:14.469 --> 00:48:20.289
if an item doesn't have a preview column associated with it.

00:48:20.289 --> 00:48:25.090
So, that was the end of our implementation of
the things that we've done with the sample code

00:48:25.090 --> 00:48:32.680
and here's a few more additional APIs
that I want to go ahead and cover.

00:48:32.679 --> 00:48:36.169
We don't allow any setting of the object
values but this is one of the new things

00:48:36.170 --> 00:48:37.750
that you can do with the item-based APIs.

00:48:37.750 --> 00:48:43.070
You can actually do in-cell editing, so if you
have it turned on, you can double-click the item,

00:48:43.070 --> 00:48:49.130
the cell and modify the change there and so browser will
call back your delegate items, setObjectValue:ForItem

00:48:49.130 --> 00:48:56.010
and you can also modify the height
of each row in each column.

00:48:56.010 --> 00:49:00.910
So, here's a delegate method for that where
we will ask you for the height of each row.

00:49:00.909 --> 00:49:06.750
And finally, we want to look at
how you can get your selection.

00:49:06.750 --> 00:49:12.929
It turns out that, you know, in column 0 you might have item
4 selected and in the next column, you have row 1 selected

00:49:12.929 --> 00:49:20.389
and in the final column you have row 0 selected, and this
looks a lot like an NSIndexPath and well, so we go ahead

00:49:20.389 --> 00:49:24.730
and we allow you to get and set the selection
based on the index path, create an index path

00:49:24.730 --> 00:49:28.980
and you could set the selection that
way and we'll fill out all the columns,

00:49:28.980 --> 00:49:33.240
or you can get what the current selection index path is.

00:49:33.239 --> 00:49:38.979
Of course, you might have more than one item
selected in your last column and if that's the case,

00:49:38.980 --> 00:49:46.039
you can get an array selection index paths or you can even
set an array of index paths with setSelectionIndexPaths.

00:49:46.039 --> 00:49:53.630
Its important that on the array of index paths that only
the last item in the index path changes for each item--

00:49:53.630 --> 00:49:57.150
for each index path in the array and we check for that

00:49:57.150 --> 00:50:01.880
because you can only have a multiple
selection in the last column.

00:50:04.329 --> 00:50:10.719
So sometimes it gets-- you'll need to know what a particular
item is in a particular row in a particular column

00:50:10.719 --> 00:50:14.099
and so there's a couple of different
ways of determining that.

00:50:14.099 --> 00:50:19.819
>> The first way is you might just say, "Well, I know
the index path, so give me the item at that index path."

00:50:19.820 --> 00:50:27.680
And so, you can really ask for that item at index path or
you might know the particular row and the particular column

00:50:27.679 --> 00:50:32.379
which some of the other API that were always-- we've
already given you back, you can just simply ask item

00:50:32.380 --> 00:50:35.010
at row and column and we will hand that to you.

00:50:35.010 --> 00:50:42.590
[ Pause ]

00:50:42.590 --> 00:50:50.380
>> So, if you want to reload the children of a particular
column, we made it real simple for you to do that

00:50:50.380 --> 00:50:56.079
and you can just call reloadItem if you already
know the item and we'll reload just that items

00:50:56.079 --> 00:51:01.239
and we prepare the cell and we put the values
there or you can reload a whole particular column,

00:51:01.239 --> 00:51:06.639
you just provide us with the column number and if you
try maintain selection and if you reload columns there

00:51:06.639 --> 00:51:10.279
on the selection changes, we will go ahead do the
right thing and wipe out all the other columns for you.

00:51:10.280 --> 00:51:18.010
And that's pretty much the end of the new API browsers,
real simple to use and it's pretty straightforward.

00:51:18.010 --> 00:51:26.500
If you know NSOutlineView you'll be a step ahead in using
this API because they're very similar and I just want

00:51:26.500 --> 00:51:31.739
to point out that finder as you know is now Cocoa
based and so this gives you the power to do everything

00:51:31.739 --> 00:51:36.719
that they're doing in the browser view
mode and finder with the header columns

00:51:36.719 --> 00:51:39.959
and the preview columns and it works really great.

00:51:39.960 --> 00:51:44.010
So, we're going to bring Corbin back
up to go ahead and close this out.

00:51:44.010 --> 00:51:50.190
[ Applause ]

00:51:50.190 --> 00:51:57.440
>> So, we had a good talk about subclassing, enhancing
table view, talking about the batch load with cell contents,

00:51:57.440 --> 00:52:05.570
add subviews, doing custom cell editors, creating custom
animations from one table view location to an image view,

00:52:05.570 --> 00:52:14.400
creating the pop-up animation and Raleigh just finished
talking about the new NSBrowser Snow Leopard APIs.

00:52:14.400 --> 00:52:20.829
What we encourage you to do is to take that sample code,
download it, play with it, reuse it, figure it out...
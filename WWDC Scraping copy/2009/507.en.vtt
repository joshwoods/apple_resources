WEBVTT

00:00:12.750 --> 00:00:14.529
>> All right, good afternoon everybody.

00:00:14.529 --> 00:00:15.769
My name is Paul Holden.

00:00:15.769 --> 00:00:18.669
I'm an iPhone Application engineer at Apple.

00:00:18.670 --> 00:00:22.120
And I am really, really excited to
be here to talk to you folks today

00:00:22.120 --> 00:00:26.380
about creating iPhone applications
that communicate with accessories.

00:00:26.379 --> 00:00:29.519
So why am I excited about it?

00:00:29.519 --> 00:00:32.950
Well, this was a really, really highly requested feature.

00:00:32.950 --> 00:00:38.160
A lot of people asked for it even around the office,
people stopping by thinking you know telling me what

00:00:38.159 --> 00:00:42.519
if third party people could do this and
developers could actually come through

00:00:42.520 --> 00:00:45.080
and make these great applications
for their custom accessories?

00:00:45.079 --> 00:00:45.780
Wouldn't that be great?

00:00:45.780 --> 00:00:47.390
Well, it would.

00:00:47.390 --> 00:00:50.740
Next, the second reason I'm really
excited to be here today is

00:00:50.740 --> 00:00:54.210
because personally I can't wait
to see what you guys come up with.

00:00:54.210 --> 00:01:01.740
So, with iPod, iPod Touches and iPhones, a lot of
accessory manufacturers have come up with great, fantastic,

00:01:01.740 --> 00:01:06.840
thousands of accessories that work great with our
products and customers love them, great experience.

00:01:06.840 --> 00:01:12.880
And I think this will really let you guys come up to the
next level and really make the next level of accessories

00:01:12.879 --> 00:01:14.969
and applications that work with them really great.

00:01:14.969 --> 00:01:21.429
So as with all the other presentations you guys have
hopefully gone to, there's a, there's a demo here,

00:01:21.430 --> 00:01:25.320
you guys can go to the attendee site and
pick up the EA Framework demo project.

00:01:25.319 --> 00:01:29.119
You can follow along as we go through.

00:01:29.120 --> 00:01:37.000
So I just like to take a minute and talk about you, the
developers, and what I hope to help you guys out with.

00:01:37.000 --> 00:01:43.469
So, with there's probably three groups of you here that I
think this presentation will really, really be good for.

00:01:43.469 --> 00:01:49.780
So one is the MFi and the WWi people that are in the crowd.

00:01:49.780 --> 00:01:56.150
So, MFi made for iPod and WWi works with iPhone, so if you
go into any electronic stores, you're seeing the thousands

00:01:56.150 --> 00:02:00.730
of great iPod accessories, iPhone accessories
and iPod Touch accessories out there today.

00:02:00.730 --> 00:02:08.960
So we really want to go through and show you guys
exactly what we've added to the iPhone 3.0 SDK.

00:02:08.960 --> 00:02:16.140
And what you can do to make great applications that work
with either those types of accessories or even the new types

00:02:16.139 --> 00:02:20.769
of accessories that this will unlock and let you develop.

00:02:20.770 --> 00:02:25.240
Next, I'd like to talk about iPhone,
iPhone application engineers.

00:02:25.240 --> 00:02:27.010
So iPhone application designers.

00:02:27.009 --> 00:02:33.329
So people who have already used the SDK, possibly already
have an application on the store, and have this great idea

00:02:33.330 --> 00:02:39.680
for this piece of hardware that they want to develop and are
not really sure what steps to take or you know where to go

00:02:39.680 --> 00:02:42.569
about doing that to actually get something to market.

00:02:42.569 --> 00:02:45.629
So, we'll help you guys out, we'll talk about that as well.

00:02:45.629 --> 00:02:49.680
Next, I envision that there's also people
in the crowd that are hardware people.

00:02:49.680 --> 00:02:55.170
So perhaps you guys have just played with the SDK,
maybe you've, you've never even used it at all.

00:02:55.169 --> 00:03:01.139
So, in our demos and as we go through, I hope to
give you guys the ground works of what you need

00:03:01.139 --> 00:03:06.489
to actually go through, take your hardware
concept and make a great application for it.

00:03:06.490 --> 00:03:10.810
So let's get started.

00:03:10.810 --> 00:03:14.300
So very, very high level, this is
what we're talking about right?

00:03:14.300 --> 00:03:18.270
You have an accessory, a piece of
hardware that's external to your phone.

00:03:18.270 --> 00:03:23.189
And you've got, and you've got an application
that you've developed for your iPhone.

00:03:23.189 --> 00:03:28.359
In the 3.0 SDK, what we've done is we've
let you communicate from your accessory

00:03:28.360 --> 00:03:31.950
and to your application using one of three transports.

00:03:31.949 --> 00:03:33.369
So the first one is Bluetooth.

00:03:33.370 --> 00:03:37.409
So you can communicate with your application
wirelessly using Bluetooth, which is great.

00:03:37.409 --> 00:03:41.509
The second is, well the second and
third, you use through the dot connector.

00:03:41.509 --> 00:03:46.590
So USB and you are through an actual connector that
will connect to the physical 30 pin on the bottom.

00:03:46.590 --> 00:03:52.259
So let's take a closer look at this.

00:03:52.259 --> 00:03:57.239
So the goal of this feature is to take raw
bytes that you've got in your application

00:03:57.240 --> 00:04:01.159
or in your accessory and transfer
them back and forth, right?

00:04:01.159 --> 00:04:06.900
So you've got raw bytes that you want to send from
your accessory to your application and vice versa.

00:04:06.900 --> 00:04:10.800
How we allow you to do that on your
application side is we provide you

00:04:10.800 --> 00:04:14.230
with an extra framework called
the ExternalAccessory Framework.

00:04:14.229 --> 00:04:20.240
So your application with link against this and you'll be
able to at runtime find out what accessories are connected

00:04:20.240 --> 00:04:25.259
to your iPhone or your iPod Touch and
also how to communicate with them.

00:04:25.259 --> 00:04:27.819
From the hardware side when you've got an actual accessory,

00:04:27.819 --> 00:04:33.120
what'll happen is this will be presented
to your accessory as an IAP accessory.

00:04:33.120 --> 00:04:36.939
So IAP stands for the iPod Accessory
Protocol that we have here.

00:04:36.939 --> 00:04:38.430
So what is this?

00:04:38.430 --> 00:04:39.530
What is this protocol?

00:04:39.529 --> 00:04:41.299
The IAP has been around for a long time.

00:04:41.300 --> 00:04:47.829
All of you have owned or played with in the stores
with accessories that today communicate with iPods

00:04:47.829 --> 00:04:53.279
or iPod Touches or iPhones they use this protocol
to send low-level information back and forth.

00:04:53.279 --> 00:04:59.729
Well we use it as a wrapper for the raw bytes
that'll go through from your accessory to your iPhone

00:04:59.730 --> 00:05:05.150
and in your application, you see those
bytes in the ExternalAccessory Framework.

00:05:05.149 --> 00:05:10.329
Specifically though today, we'll spend most of the
presentation talking about the ExternalAccessory Framework

00:05:10.329 --> 00:05:13.060
and how you'll use it to communicate to your accessories.

00:05:13.060 --> 00:05:17.410
So you've probably seen this diagram a few
times in the last, in the last couple of days.

00:05:17.410 --> 00:05:22.250
But like all the other frameworks, like Core
Location, UIKit, it sits on the Cocoa Touch layer.

00:05:22.250 --> 00:05:30.089
Ok, so specifically, what we'll talk
about today is the EA Architecture.

00:05:30.089 --> 00:05:33.829
So throughout the presentation I'll use
that as a short form for ExternalAccessory.

00:05:33.829 --> 00:05:38.699
We'll look at how we set it up to make
it very, very easy for you to go through

00:05:38.699 --> 00:05:42.819
and at runtime discover and communicate
with your accessories.

00:05:42.819 --> 00:05:48.349
So while providing you with a flexible architecture
that you can you know that wasn't limiting,

00:05:48.350 --> 00:05:51.170
you could actually go out and make
the applications that you want.

00:05:51.170 --> 00:05:57.920
Next we'll also talk to you about how you're going to
associate your, you accessories with your applications.

00:05:57.920 --> 00:06:03.420
So when someone plugs in an accessory, you want to make
sure that the application that goes with that accessory

00:06:03.420 --> 00:06:05.080
that they can go get it from the App Store.

00:06:05.079 --> 00:06:07.769
So we'll show you how, how to set that up.

00:06:07.769 --> 00:06:11.939
Next, we spent a lot of time over the
years working with accessory manufacturers.

00:06:11.939 --> 00:06:15.740
And we'll try to give you a few design
guideline, a few design guidelines

00:06:15.740 --> 00:06:19.740
that we feel will really help you guys make the
most out of using the ExternalAccessory Framework.

00:06:19.740 --> 00:06:25.829
So just to take a quick second to talk about hardware.

00:06:25.829 --> 00:06:28.680
So when you're developing hardware, what's required?

00:06:28.680 --> 00:06:34.829
Well, first we talk about these programs a few
slides ago, the Made for iPod and Works With iPhone.

00:06:34.829 --> 00:06:39.409
It's a requirement that your accessory
is part of this, is part of this program.

00:06:39.410 --> 00:06:43.400
So there's already thousands and thousands of
accessories that are out there that are part of it.

00:06:43.399 --> 00:06:47.909
It because there's hardware involved, obviously
you, you're going to need hardware connectors

00:06:47.910 --> 00:06:50.260
to actually go through and connect to an iPhone.

00:06:50.259 --> 00:06:51.539
That's part of the program as well.

00:06:51.540 --> 00:06:52.650
Documentation support.

00:06:52.649 --> 00:06:56.479
It's a very, very good program, a lot of great
experience that we had with people working with them.

00:06:56.480 --> 00:06:57.220
It's been great.

00:06:57.220 --> 00:07:04.830
So, you'll want to go check out the developer.apple.com/iPod
and you'll get most of the information from there.

00:07:04.829 --> 00:07:06.899
Alright, so we've gone high level.

00:07:06.899 --> 00:07:12.349
Let's dig into this feature and actually
look at what we're talking about here.

00:07:12.350 --> 00:07:12.660
[ Background noise ]

00:07:12.660 --> 00:07:17.830
So the diagram we showed a few minutes ago, you've
got an accessory, you've got your iPhone application

00:07:17.829 --> 00:07:25.180
and if you link against the ExternalAccessory
Framework, what will happen is essentially, when you,

00:07:25.180 --> 00:07:27.680
before you've connected an accessory
you won't see anything, right?

00:07:27.680 --> 00:07:30.519
You'll ask the ExternalAccessory Framework,
alright what's connected to my system.

00:07:30.519 --> 00:07:33.199
And obviously, it'll say nothing is connected right away.

00:07:33.199 --> 00:07:38.939
When you do connect, you're accessory
will be responsible using the IP Protocol

00:07:38.939 --> 00:07:42.319
to send all of the EA protocols that it supports.

00:07:42.319 --> 00:07:46.389
So EA Protocol will go through, will
dive into the terms in a few slides,

00:07:46.389 --> 00:07:51.519
but basically it's a logical communication
path for you guys to package your information

00:07:51.519 --> 00:07:56.240
and send it to the iPhone or the iPod Touch.

00:07:56.240 --> 00:08:03.060
So once that happens, the EA Protocol, the EA Framework
will show your accessory as an EAAccessory object.

00:08:03.060 --> 00:08:07.889
So you can go through, you can query it, you can
ask it what protocols it supports and you can open,

00:08:07.889 --> 00:08:11.120
you can open sessions to communicate with it.

00:08:11.120 --> 00:08:15.490
So when you have a protocol, that's not enough to
actually go through and communicate through it.

00:08:15.490 --> 00:08:21.079
In the architecture that we've come up with, once
you've, once your accessory is enumerated the protocol,

00:08:21.079 --> 00:08:23.620
it's the responsibility of the application to say alright,

00:08:23.620 --> 00:08:27.090
I want to speak to this protocol,
I'm going to form an EASession to it.

00:08:27.089 --> 00:08:31.299
Once you do that, you're able to freely
communicate to and from your accessory.

00:08:31.300 --> 00:08:37.180
So we went through a lot of terminology
in that, in that last slide.

00:08:37.179 --> 00:08:41.299
Let's take every single piece of it
and dissect it and examine every one.

00:08:41.299 --> 00:08:44.829
So the first one we discussed was
this concept of EAAccessory.

00:08:44.830 --> 00:08:46.320
So what is that?

00:08:46.320 --> 00:08:53.030
It's an accessory that conforms to the Made for
iPod, so it's part of the MFi licensing program.

00:08:53.029 --> 00:08:56.110
So again, throughout the website there
you definitely want to go check that out.

00:08:56.110 --> 00:09:07.519
Next, it has to be either a Bluetooth accessory or
connect through USB or UR through the doc connector.

00:09:07.519 --> 00:09:08.720
[ Period of silence ]

00:09:08.720 --> 00:09:11.340
Next, we also threw out this term EA Protocol.

00:09:11.340 --> 00:09:12.480
So what does that mean?

00:09:12.480 --> 00:09:16.860
If someone was to ask me what EA Protocol
is, that would be difficult for me to do.

00:09:16.860 --> 00:09:20.570
Because essentially all it is is
a logical communication path.

00:09:20.570 --> 00:09:23.780
And you will decide what this EA Protocol does

00:09:23.779 --> 00:09:29.699
So we just wanted to give you a flexible architecture so you
guys could decide how you'll actually package up your data,

00:09:29.700 --> 00:09:32.090
how you'll split it up, and how
you'll set it to your accessory.

00:09:32.090 --> 00:09:41.670
So you'll use these EA Protocols to send your, to define
what communication you want to send back and forth.

00:09:41.669 --> 00:09:46.689
Next, obviously it's not related to the App Protocol for
those of you who have worked with Objective-C a bunch

00:09:46.690 --> 00:09:50.960
and not only does your accessory
have to enumerate the protocols

00:09:50.960 --> 00:09:53.250
that it supports, but your application must as well.

00:09:53.250 --> 00:09:56.919
And we'll talk about that in a few slides.

00:09:56.919 --> 00:10:00.789
So as I mentioned, we really didn't want
to put a lot of restrictions on this right?

00:10:00.789 --> 00:10:05.639
You really wanted to give you guys the freedom to develop
applications and accessories that you want and get them

00:10:05.639 --> 00:10:08.019
to communicate in the fashion that you guys want to do that.

00:10:08.019 --> 00:10:13.639
So the only two rules we have, one is all
communication must happen on an EA protocol.

00:10:13.639 --> 00:10:17.689
So if you just want to send bytes to your
accessory or receive bytes from your accessory,

00:10:17.690 --> 00:10:21.240
you can't do that until you've
formed a session with an EA protocol.

00:10:21.240 --> 00:10:25.250
Next, we ask that the name of your
protocol be in reverse DNS format.

00:10:25.250 --> 00:10:30.059
So something that most of you are already pretty
familiar with, shouldn't be a big problem.

00:10:30.059 --> 00:10:36.209
Next, let's dive into something a little bit more,
more interesting which is kind of the visibility

00:10:36.210 --> 00:10:39.620
of how your EA protocol will be seen by developers.

00:10:39.620 --> 00:10:44.620
So again, we didn't want to put a lot of limitations
on this, so let's say you have an accessory

00:10:44.620 --> 00:10:47.460
that supports a certain number of EA protocols.

00:10:47.460 --> 00:10:51.400
When you connect it to your iPhone,
another developer who also connects it

00:10:51.399 --> 00:10:54.639
to your iPhone will be able to see your EA protocols.

00:10:54.639 --> 00:11:00.699
Now, obviously they won't have the specs for them, but if
it's something that can either be easily reverse engineered

00:11:00.700 --> 00:11:05.009
or it's something that for you having someone
else or having another developer be able

00:11:05.009 --> 00:11:09.639
to communicate using your accessories is a problem,
you'll want to bring in your own security, right?

00:11:09.639 --> 00:11:16.519
So you're going to be responsible for enforcing the security
of your EA protocols that you have for you accessories.

00:11:16.519 --> 00:11:19.929
Alright, now EASessions.

00:11:19.929 --> 00:11:25.299
So this is where most of you will spend 95
you know percent of your time when developing

00:11:25.299 --> 00:11:29.959
for EAAccessories is you'll spend your time with EASessions.

00:11:29.960 --> 00:11:36.139
So again, if we look at it high level, it's a
container object for all of the streaming objects

00:11:36.139 --> 00:11:37.870
that are going to be used for your accessories.

00:11:37.870 --> 00:11:41.669
So the input streams and the output streams.

00:11:41.669 --> 00:11:47.479
And now this is obviously if you look at the architecture
of the phone, but only apps can create EASessions.

00:11:47.480 --> 00:11:51.909
So at runtime you can't have your,
your accessories go and form a session.

00:11:51.909 --> 00:11:56.240
It has to be your app that does that.

00:11:56.240 --> 00:12:04.110
Alright, so we discussed having your accessory enumerate
the protocol, the EA protocols that it supports.

00:12:04.110 --> 00:12:08.480
Let's talk about your application
enumerating the EA protocols that it supports.

00:12:08.480 --> 00:12:14.330
So that'll happen through the info.plist which
if any of you have created an iPhone application

00:12:14.330 --> 00:12:16.629
or even a desktop application are
pretty familiar with, right?

00:12:16.629 --> 00:12:19.669
It's the plist that goes with inside
the bundle of all your applications.

00:12:19.669 --> 00:12:21.259
So we've added a key.

00:12:21.259 --> 00:12:27.850
UI supported ExternalAccessory Protocol, kind of
a mouthful, but when you use that in an array,

00:12:27.850 --> 00:12:32.790
you add a string that enumerates every single
protocol that your application supports.

00:12:32.789 --> 00:12:42.149
Now this was pretty long key so the folks at in XCode
hooked us up and you can just add it through the UI

00:12:42.149 --> 00:12:51.079
and when you do that, every item you add will
show up as, as an array item in your info.plist.

00:12:51.080 --> 00:12:58.060
Alright, why would you want to associate
your applications with EA Protocols?

00:12:58.059 --> 00:13:03.829
So the reason for that is we wanted to
give you guys a method to help the user

00:13:03.830 --> 00:13:09.830
that for the first time connects an
EAAccessory to their iPhone or their iPod Touch.

00:13:09.830 --> 00:13:15.670
So how we've done that is if you have an accessory
that connects to your iPhone or your iPod Touch

00:13:15.669 --> 00:13:23.349
and it supports EA Protocols for which there is not a
single application on your phone that also supports one

00:13:23.350 --> 00:13:26.580
of those EA Protocols, then this alert will go out.

00:13:26.580 --> 00:13:32.410
So kind of a mouthful but basically if there's
no apps for your accessory we'll throw this up.

00:13:32.409 --> 00:13:39.480
If the user presses yes, then they'll be sent to the App
Store and we'll use the information in those protocols to go

00:13:39.480 --> 00:13:44.930
through and say alright, these are the applications that
you probably want to download to use your accessory.

00:13:44.929 --> 00:13:45.739
[ Period of silence ]

00:13:45.740 --> 00:13:55.070
So the second way that we try to help you guys and help
you out when actually associating your applications with,

00:13:55.070 --> 00:14:03.010
with accessories is if you navigate through settings
and you go through, you go to the About table view,

00:14:03.009 --> 00:14:06.860
you'll see that we've added an extra field
there for the accessory that you've connected.

00:14:06.860 --> 00:14:11.919
So if you go here and you press the find app for accessory,
you'll get the same query on the App store that happens

00:14:11.919 --> 00:14:17.009
if you press yes in that alert
that we saw just a minute ago.

00:14:17.009 --> 00:14:17.230
[ Period of silence ]

00:14:17.230 --> 00:14:25.550
Alright, so we dove in, we defined all the terms that are
important when working with the ExternalAccessory Framework.

00:14:25.549 --> 00:14:30.679
Now let's actually look at the
framework and its API in detail.

00:14:30.679 --> 00:14:31.469
So it's really simple.

00:14:31.470 --> 00:14:37.290
There's only three classes and one protocol that
you'll use when communicating with your accessories.

00:14:37.289 --> 00:14:43.599
The first one is the EAAccessoryManager, which
will be responsible for managing the connections

00:14:43.600 --> 00:14:47.899
of all the accessories that are connected
to your iPhone or your iPod Touch.

00:14:47.899 --> 00:14:56.840
Next is the EA Accessory Class, which you'll use to
represent a single ExternalAccessory in the framework.

00:14:56.840 --> 00:15:02.110
Finally that has also got a protocol, which is
the EAAccessoryDelegate protocol which you'll use

00:15:02.110 --> 00:15:06.340
to see disconnects of a single ExternalAccessory.

00:15:06.340 --> 00:15:10.680
And finally, the really important one that you'll
spend most of your time with is the EASession.

00:15:10.679 --> 00:15:13.689
So what you'll use to communicate
to and from your accessory.

00:15:13.690 --> 00:15:17.920
So let's look at the API a little bit.

00:15:17.919 --> 00:15:24.110
So in the EAAccessoryManager API, you've got two
notifications, connect, and disconnect, pretty normal.

00:15:24.110 --> 00:15:30.500
Anyone who's familiar with Cocoa Notifications knows that
when you receive these you'll have a user info dictionary

00:15:30.500 --> 00:15:35.840
and in your user info dictionary, we'll
actually give you a reference to the EA,

00:15:35.840 --> 00:15:40.070
the EAAccessory for which that event was triggered.

00:15:40.070 --> 00:15:42.760
Next, it's a singleton so there's only one per application.

00:15:42.759 --> 00:15:46.269
So you'll use the shared accessory
manager to get a hold of it.

00:15:46.269 --> 00:15:53.169
So also to receive the did disconnect and did connect
notifications, we ask that, that you register for them.

00:15:53.169 --> 00:15:55.629
So when you want to start receiving them, you'll register.

00:15:55.629 --> 00:16:00.299
When you don't want to start receiving them, you'll
use the unregister for local notifications to do that.

00:16:00.299 --> 00:16:06.359
Finally, the connected accessories property
is what you'll use at runtime to get a list

00:16:06.360 --> 00:16:12.019
of the currently connected accessories
to your iPhone or your iPod Touch.

00:16:12.019 --> 00:16:18.759
So when your application launches, we won't send you a
notification for every accessory that's already connected.

00:16:18.759 --> 00:16:23.019
All we'll send, all we'll send you is
notifications for when new accessories are connected.

00:16:23.019 --> 00:16:27.799
So when you start up, you use the connected accessories
so you'll get an array of everything that's connected.

00:16:27.799 --> 00:16:35.289
Now, I want to mention that in the 3.0
SDK, only one EAAccessory is permitted

00:16:35.289 --> 00:16:37.740
on your iPhone or your iPod Touch at a time.

00:16:37.740 --> 00:16:42.000
So when you go and use the connected
accessories NSArray, you'll only,

00:16:42.000 --> 00:16:45.690
you'll always receive one accessory, that'll be the maximum.

00:16:45.690 --> 00:16:47.770
So you'll get no accessories and nothing is connected.

00:16:47.769 --> 00:16:49.360
Or you'll get one if something is there.

00:16:49.360 --> 00:16:53.220
But obviously, this is something we
hope to perhaps enhance in the future.

00:16:53.220 --> 00:16:55.420
So we ask that you treat this as an array.

00:16:55.419 --> 00:16:58.199
So don't go using index at object 0.

00:16:58.200 --> 00:17:01.080
You know actually go through it and
make sure that the EAAccessory that's

00:17:01.080 --> 00:17:02.900
in there is the one that you're looking for.

00:17:02.899 --> 00:17:06.819
Alright, so we talked about the manager.

00:17:06.819 --> 00:17:12.399
Now let's talk about EAAccessory, which is the
object that'll represent a single accessory connected

00:17:12.400 --> 00:17:14.420
to your iPhone or iPod Touch.

00:17:14.420 --> 00:17:22.240
So again, a few properties that aren't listed
here are things like name, serial number, version,

00:17:22.240 --> 00:17:24.460
sorry hardware version, firmware version.

00:17:24.460 --> 00:17:30.289
So there's a few strings to help you identify it,
but the real, the real property that you want to look

00:17:30.289 --> 00:17:33.259
at is the second one in the list
here, which is protocol strings.

00:17:33.259 --> 00:17:42.329
So we talked before that an EAAccessory on connect has
to enumerate all of the EA protocols that it supports.

00:17:42.329 --> 00:17:43.609
Well this is where you'll go get them.

00:17:43.609 --> 00:17:50.579
So you'll read this and it'll hold every single
EA protocol that your accessory supported.

00:17:50.579 --> 00:17:54.549
So you can take those and you can form sessions
to them so you can start communicating with them.

00:17:54.549 --> 00:17:59.990
Next you'll use the connection ID, so just we
assign a, a new number to every single connection

00:17:59.990 --> 00:18:03.569
when an accessory gets connected to the system

00:18:03.569 --> 00:18:05.329
And finally the delegate method.

00:18:05.329 --> 00:18:07.189
So, finally, sorry the delegate.

00:18:07.190 --> 00:18:12.380
So while you use the delegate, what you'll
use it for is the EAAccessoryDelegate.

00:18:12.380 --> 00:18:18.980
So as we mentioned a few minutes ago, accessory did
disconnect you'll want to set that if all you care

00:18:18.980 --> 00:18:21.329
about is the disconnect of one single accessory.

00:18:21.329 --> 00:18:24.710
So the notification in the EAAccessoryManager is

00:18:24.710 --> 00:18:29.150
for when any EAAccessory is connected
or disconnected from your system.

00:18:29.150 --> 00:18:32.820
But if there's only one that you really care about
or if there's only a few that you've got connections,

00:18:32.819 --> 00:18:37.029
that you've got references to and you care about
them, then you want to use this delegate to make sure

00:18:37.029 --> 00:18:43.950
that you only get the notification, you only get
delegate callbacks for when that one disconnects.

00:18:43.950 --> 00:18:49.819
Alright, now again the one we're going
to spend the most time is this EAsession.

00:18:49.819 --> 00:18:53.339
And if you look at little bit at the API,
again it's very, very straightforward.

00:18:53.339 --> 00:18:56.019
So you have init with accessory for protocol.

00:18:56.019 --> 00:19:03.289
So how session works is when you know that you want to
communicate to an EAAccessory, over a certain EA protocol,

00:19:03.289 --> 00:19:07.149
you form an EASession with that accessory for that protocol.

00:19:07.150 --> 00:19:13.140
Now if your accessory supports 20 EAProtocols,
then to communicate over all of them,

00:19:13.140 --> 00:19:16.060
you'll actually have to form 20 EASessions.

00:19:16.059 --> 00:19:20.970
OK? So it's basically one session
per protocol per accessory.

00:19:20.970 --> 00:19:23.240
So as you can see by the init method here.

00:19:23.240 --> 00:19:25.200
Next, how are you going to transfer them?

00:19:25.200 --> 00:19:32.900
So those of you who may have used NSStream on the desktop
or on the phone will be very familiar with this API.

00:19:32.900 --> 00:19:38.180
So we give you two objects, two properties
here which is InputStream and OutputStream

00:19:38.180 --> 00:19:42.360
that are NSInputStream and NSOutputStream classes.

00:19:42.359 --> 00:19:48.529
So let's look into those in a little bit more detail.

00:19:48.529 --> 00:19:51.299
So NSInputStream and NSOutputStream aren't new.

00:19:51.299 --> 00:19:53.649
They've been around in foundation for a long time.

00:19:53.650 --> 00:19:56.480
They're both subclasses of NSStream.

00:19:56.480 --> 00:20:00.720
And if you haven't looked at it before, I
definitely, even if you have looked at it before,

00:20:00.720 --> 00:20:05.160
I definitely suggest that you go check out the
Introduction to Stream Programming Guide for Cocoa.

00:20:05.160 --> 00:20:07.650
It's on ADC, it's fantastic.

00:20:07.650 --> 00:20:12.240
It definitely gives you the you know from
one end the entire view of how you'll want

00:20:12.240 --> 00:20:14.349
to use NSStream Objects and how they behave.

00:20:14.349 --> 00:20:19.759
So but of course, we want to give you demos
and we want to dive into them right now.

00:20:19.759 --> 00:20:25.200
So if I had to explain to a, if I had to show
one method which will explain how these work,

00:20:25.200 --> 00:20:27.850
how NSStreams work, it would be this one.

00:20:27.849 --> 00:20:31.889
So NSStream works very heavily using delegates.

00:20:31.890 --> 00:20:37.190
So when you've got a stream anyone who's communicated
to or from some kind of object or streamed stuff

00:20:37.190 --> 00:20:40.000
over the Internet, you can, you
can definitely use poling right?

00:20:40.000 --> 00:20:42.460
So you can say are there bytes available now?

00:20:42.460 --> 00:20:46.930
Or can I send bytes to my, to my output?

00:20:46.930 --> 00:20:51.259
But NSStream definitely encourages you and we
definitely encourage people when doing this

00:20:51.259 --> 00:20:54.299
to work asynchronously and to use a delegate callbacks.

00:20:54.299 --> 00:20:55.629
So here the handle event.

00:20:55.630 --> 00:21:00.940
Types of events that you'll get back for you InputStream
and your OutputStream are things like open completed.

00:21:00.940 --> 00:21:02.529
So did my stream open?

00:21:02.529 --> 00:21:04.430
And you'll also get end encountered.

00:21:04.430 --> 00:21:06.259
So was the end of my stream encountered?

00:21:06.259 --> 00:21:09.930
So in this case you'll get that
when you unplug your accessory.

00:21:09.930 --> 00:21:14.440
So when you disconnect it, you'll
get an endstream notification.

00:21:14.440 --> 00:21:19.730
Next for the inputstream, you'll get a has bytes available.

00:21:19.730 --> 00:21:24.579
So the delegate will get called with that when
bytes are available for your system to use.

00:21:24.579 --> 00:21:30.289
And finally, if you're using your outputstream, you want
to wait for the event that's called has space available.

00:21:30.289 --> 00:21:34.329
So just like most streams, you can't
just assume that you can write to it.

00:21:34.329 --> 00:21:38.679
You know you have to make sure that the stream
has space available for you to send data to it.

00:21:38.680 --> 00:21:41.360
And once that, once that happens, you can
go ahead and you can send your data to it.

00:21:41.359 --> 00:21:45.219
And we'll go through that in a
little bit more detail in the demo.

00:21:45.220 --> 00:21:51.390
So I have an application and I guess for you guys
it's in the top right corner, which is EADemo.

00:21:51.390 --> 00:21:56.620
So if we click on that, this is the demo that
you can go pick up from the attendee site.

00:21:56.619 --> 00:21:59.489
We have a simple table view.

00:21:59.490 --> 00:22:02.380
And every time I connect an accessory, so I've got a very,

00:22:02.380 --> 00:22:08.080
very simple board here which is just a test
accessory that, that we've created for this.

00:22:08.079 --> 00:22:14.449
When I plug it in, our Test App
will go through and it'll list it.

00:22:14.450 --> 00:22:19.299
So it's listening to the didconnect notification
through the EAAccessoryManager and putting

00:22:19.299 --> 00:22:22.659
up every single accessory that, that it sees come in.

00:22:22.660 --> 00:22:27.590
If you press the.

00:22:27.589 --> 00:22:27.829
[ Period of silence ]

00:22:27.829 --> 00:22:28.409
There you go.

00:22:28.410 --> 00:22:33.950
If you press the, the information button,
what you'll get, this is a little bit fuzzy,

00:22:33.950 --> 00:22:40.769
but basically we override the NSObject Description Method,
so when you press that, if ever you decide just to print

00:22:40.769 --> 00:22:43.559
out your object, you'll get all of the
important properties that are there.

00:22:43.559 --> 00:22:45.509
So that's kind of interesting.

00:22:45.509 --> 00:22:53.180
And if we press on it, what we do is I go through and I
actually read the protocol strings object that's connected

00:22:53.180 --> 00:22:56.430
to your, that is part of your EAAccessory Object.

00:22:56.430 --> 00:23:04.400
So here, I'm showing a UI alert sheet that posts every
single EA protocol that this accessory has enumerated.

00:23:04.400 --> 00:23:07.509
So let's go and press on one of them so the com.apple.p1.

00:23:07.509 --> 00:23:07.569
[ Period of silence ]

00:23:07.569 --> 00:23:10.829
That looks pretty good.

00:23:10.829 --> 00:23:12.589
OK, so we've got three buttons.

00:23:12.589 --> 00:23:18.879
Again, this is just a basic custom view that
has LED on, LED off, and send 10K of data.

00:23:18.880 --> 00:23:24.550
So if I press the on, I press the off,
it'll just send a very small packet

00:23:24.549 --> 00:23:28.480
to that accessory to light and unlight the LED.

00:23:28.480 --> 00:23:31.019
So very, very simple demo.

00:23:31.019 --> 00:23:33.200
Let's go through and step by step look at the code

00:23:33.200 --> 00:23:37.960
and show you guys how you can add the
same functionality to your application.

00:23:37.960 --> 00:23:45.640
Perfect. So, we've got, actually, before I do that.

00:23:45.640 --> 00:23:50.850
I want to show you guys a slide first.

00:23:50.849 --> 00:23:56.269
So before I go through and actually look at this code, I'll
bring up, I'll show you guys the flow of this application

00:23:56.269 --> 00:23:58.720
and the different files that were involved in creating it.

00:23:58.720 --> 00:24:04.160
And then we'll focus in on one of those files
that, that's an accessory controller that does all

00:24:04.160 --> 00:24:08.230
of the communication with the EA Framework.

00:24:08.230 --> 00:24:12.589
So first of all, we saw had, we have a root
controller object that's just responsible

00:24:12.589 --> 00:24:13.980
for bringing up the table view.

00:24:13.980 --> 00:24:19.170
And once you press on an object, bring up the UI
alert sheet that lists all of the EA protocols

00:24:19.170 --> 00:24:22.259
that your accessory enumerated, that it supports.

00:24:22.259 --> 00:24:26.430
Next, when you press on one, you bring up our custom view.

00:24:26.430 --> 00:24:29.440
That just has three buttons, LED on, LED off.

00:24:29.440 --> 00:24:33.340
And we also create this object
called the EADAccessory Controller.

00:24:33.339 --> 00:24:39.329
Now the EADAccessoryController came from when we were
first developing this, we kind of wanted something

00:24:39.329 --> 00:24:43.990
to inspire everyone who was actually going
to try to use the ExternalAccessory Protocol

00:24:43.990 --> 00:24:49.220
who maybe hadn't use NSStream before,
NSInputStream or NSOutputStream.

00:24:49.220 --> 00:24:53.740
So NSController which we'll look at very,
very precisely when we look at the code,

00:24:53.740 --> 00:24:58.460
it holds all the logic to use the
streams for those EAAccessories.

00:24:58.460 --> 00:25:00.110
So what happens when you press a button?

00:25:00.109 --> 00:25:04.669
We go and we call right data with
an NSData Object and there you go.

00:25:04.670 --> 00:25:08.050
It's the controller handles everything
and it goes right to your accessory.

00:25:08.049 --> 00:25:08.109
[ Period of silence ]

00:25:08.109 --> 00:25:12.549
Alright, now let's look at the code.

00:25:12.549 --> 00:25:20.990
So we saw two view controllers, so the, the root view
controller which was just the table view that brought

00:25:20.990 --> 00:25:23.420
up every single accessory that was currently connected.

00:25:23.420 --> 00:25:28.620
And then also watched for did connect
and disconnect notifications.

00:25:28.619 --> 00:25:33.139
Next, we had the EAAccessory details view
controller which had those three buttons,

00:25:33.140 --> 00:25:37.330
the LED on, LED off and send 10K of data.

00:25:37.329 --> 00:25:40.659
Finally, we had the EADAccessoryController.

00:25:40.660 --> 00:25:45.820
So this is what the views communicate with
whenever they actually want to use the inputstream

00:25:45.819 --> 00:25:49.789
and outputstream that are associated to your EAAccessory.

00:25:49.789 --> 00:25:52.069
So let's dive into those in detail.

00:25:52.069 --> 00:25:57.529
[ Period of silence ]

00:25:57.529 --> 00:26:00.649
So the API for this is very, very basic.

00:26:00.650 --> 00:26:07.759
The first thing you do is when you have this controller,
you set it up with an accessory and a protocol string.

00:26:07.759 --> 00:26:11.970
So, obviously this looks like we're
going to set up a session with it, right?

00:26:11.970 --> 00:26:15.870
So we're getting an accessory, we're getting
a protocol that we want this to handle.

00:26:15.869 --> 00:26:20.179
And next, we have two methods,
open session and close session.

00:26:20.180 --> 00:26:28.769
So we'll use those methods to actually open up the
input stream and the output stream of this EAAccessory.

00:26:28.769 --> 00:26:29.039
[ Period of silence ]

00:26:29.039 --> 00:26:35.079
Finally, here we've got the write data which is what
we'll use to actually use those streams and take that data

00:26:35.079 --> 00:26:37.409
and asynchronously send it to your accessory.

00:26:37.410 --> 00:26:38.009
[ Period of silence ]

00:26:38.009 --> 00:26:48.920
OK, so let's look at that in a little bit more detail.

00:26:48.920 --> 00:26:49.289
[ Period of silence ]

00:26:49.289 --> 00:26:52.899
So if I go here and I pick up the setup controller,

00:26:52.900 --> 00:26:56.100
all we're doing is just keeping a
reference to the accessory and the protocol.

00:26:56.099 --> 00:26:57.679
So pretty basic.

00:26:57.680 --> 00:27:03.980
Next when you want to go and open the session.

00:27:03.980 --> 00:27:07.110
Let's go here.

00:27:07.109 --> 00:27:07.369
[ Period of silence ]

00:27:07.369 --> 00:27:08.979
We'll use the open session method.

00:27:08.980 --> 00:27:11.500
So what does this do?

00:27:11.500 --> 00:27:13.890
First thing is it sets the delegate of the accessory.

00:27:13.890 --> 00:27:19.920
So we want this object to receive disconnect notification
or disconnect delegate methods for this accessory.

00:27:19.920 --> 00:27:21.500
So we go and we set that up.

00:27:21.500 --> 00:27:24.940
Next, we set up, we set up a session for that accessory.

00:27:24.940 --> 00:27:29.150
So we call the InitAccessoryForProtocol.

00:27:29.150 --> 00:27:33.840
Now, the next line right here, we
actually check to see if it's nil.

00:27:33.839 --> 00:27:35.089
So why do we do that?

00:27:35.089 --> 00:27:44.129
Well in the 3.0 SDK, you're permitted only one
session per protocol per EA protocol per accessory.

00:27:44.130 --> 00:27:46.240
So let's say you tried to do that twice.

00:27:46.240 --> 00:27:50.630
Let's say you tried to open two sessions
for the same EAProtocol for one EAAccessory.

00:27:50.630 --> 00:27:53.810
This would come back as nil and you
wouldn't, it wouldn't permit you to do that.

00:27:53.809 --> 00:27:56.819
So let's say your application did everything right.

00:27:56.819 --> 00:27:58.669
It, it set up a session.

00:27:58.670 --> 00:27:59.600
You're ready to go.

00:27:59.599 --> 00:28:01.629
The next thing you do is we set up the inputstream.

00:28:01.630 --> 00:28:07.910
So again, those who are familiar with NSStream on a desktop
or on, or on the phone will be really familiar with this.

00:28:07.910 --> 00:28:09.060
We set the delegate.

00:28:09.059 --> 00:28:13.259
So we talked about NSInputStream and
NSOutputStream are very delegate driven, right?

00:28:13.259 --> 00:28:18.970
So they get events for when data comes in and when you
have space available to write data to your accessory.

00:28:18.970 --> 00:28:24.069
So here, we set the delegate to receive
those call, those, those delegate methods.

00:28:24.069 --> 00:28:30.429
Next, we want to make sure that we're getting those
delegates in the right, in the right run loop, right?

00:28:30.430 --> 00:28:37.350
So obviously if we're working in the main run loop and
we have of UI, happening and we set this up to happen

00:28:37.349 --> 00:28:40.219
in another thread in another run loop,
then we want to schedule it there.

00:28:40.220 --> 00:28:46.420
So what happens here, we schedule it in
the run loop that called this, this method.

00:28:46.420 --> 00:28:48.009
So we just use the current run loop.

00:28:48.009 --> 00:28:49.890
And finally we go ahead and we open the stream.

00:28:49.890 --> 00:28:53.560
We do the same thing for the input and for the output.

00:28:53.559 --> 00:28:55.639
Next, we look at the close session.

00:28:55.640 --> 00:28:57.230
This one again very simple.

00:28:57.230 --> 00:29:00.720
We just basically do what we did in the
open session but in the reverse order.

00:29:00.720 --> 00:29:06.539
So we go, we close the session, we unregister
its delegate events from the run loop

00:29:06.539 --> 00:29:09.129
and then we go ahead and we set the delegate to nil.

00:29:09.130 --> 00:29:10.710
So very straightforward.

00:29:10.710 --> 00:29:15.850
Now where things get very interesting
is here in the write data.

00:29:15.849 --> 00:29:18.240
So in write data, what do we do?

00:29:18.240 --> 00:29:21.000
We have a buffer called _writedata.

00:29:21.000 --> 00:29:25.190
And if that buffer wasn't created,
we go ahead and we create it.

00:29:25.190 --> 00:29:28.430
We take the data that you wanted to put
onto it and we add it to the buffer.

00:29:28.430 --> 00:29:31.980
So let's say you called write data with a 1K buffer.

00:29:31.980 --> 00:29:40.410
We go ahead and we add that to our NSMuteableData
data and then which is right here where we append.

00:29:40.410 --> 00:29:42.830
And finally, we call this write_data.

00:29:42.829 --> 00:29:47.379
So someone external to this controller will call a writedata

00:29:47.380 --> 00:29:52.900
and we have an internal method that'll actually be
responsible for writing that data onto the stream.

00:29:52.900 --> 00:30:02.790
So before I look at _writedata, I want to take a little
bit of time to have a look at this switch statement

00:30:02.789 --> 00:30:05.230
that I've put in the stream handle event.

00:30:05.230 --> 00:30:09.690
So stream handle event comes from
NSStream delegate event extensions.

00:30:09.690 --> 00:30:15.740
So this is the delegate that'll get called whenever
an event happens on an inputstream or an outputstream.

00:30:15.740 --> 00:30:20.620
Because remember we set up the same class
to be the delegate for both those streams.

00:30:20.619 --> 00:30:26.349
So we've got open completed, you'll get that both
for the inputstream and for the outputstream.

00:30:26.349 --> 00:30:29.919
And at the bottom we've got error
occurred and end encountered.

00:30:29.920 --> 00:30:36.390
So you'll get this and the error
occurred and end encountered.

00:30:36.390 --> 00:30:40.000
You could get that for both streams,
both the input and the output.

00:30:40.000 --> 00:30:41.109
So you should handle those accordingly.

00:30:41.109 --> 00:30:43.769
Obviously, we just print them out here for the demo.

00:30:43.769 --> 00:30:49.900
But the really, really interesting ones come in
the has bytes available and has space available.

00:30:49.900 --> 00:30:55.990
So in our write data example, when it's
very important that you don't just assume

00:30:55.990 --> 00:30:58.690
that you can take your data and
you can write it to the stream.

00:30:58.690 --> 00:31:02.789
Because NSStream works like any stream
and so does this, so does the EAAccessory.

00:31:02.789 --> 00:31:04.619
You've got a piece of hardware that can accept data.

00:31:04.619 --> 00:31:08.299
So it's important that you can't just
say hey, here's my 1K of data, right?

00:31:08.299 --> 00:31:09.539
You can't just send it to it.

00:31:09.539 --> 00:31:11.420
You have to do a little bit more work.

00:31:11.420 --> 00:31:15.930
So what you want to do is you want to ask
it and say are you able to accept data.

00:31:15.930 --> 00:31:18.380
So you want to ask it are you able to accept data.

00:31:18.380 --> 00:31:23.000
If it can, you say alright, try, try to
write my 1K of data and it'll come back

00:31:23.000 --> 00:31:25.390
and tell you how much data it actually wrote.

00:31:25.390 --> 00:31:31.170
So let's say it says you can write to me, you try to
write a K, it could come back and tell you OK look,

00:31:31.170 --> 00:31:37.529
I was only able to write 256 bytes so later on
when this delegate gets called, you can go through

00:31:37.529 --> 00:31:39.710
and you can write the rest of the three quarters of the K.

00:31:39.710 --> 00:31:46.440
So let's look at this writedata here.

00:31:46.440 --> 00:31:50.710
So this goes through, this goes through
what we talked about a little bit.

00:31:50.710 --> 00:31:55.120
The first thing is we go through and we make
sure that the stream has space available.

00:31:55.119 --> 00:32:01.669
Also, we make sure that the buffer that we want to
write the data from also has, also has data in it.

00:32:01.670 --> 00:32:03.769
Obviously, you don't want to write
just nothing to the buffer.

00:32:03.769 --> 00:32:11.000
And when that happens, next loop here, we
call the outputstream for our writedata.

00:32:11.000 --> 00:32:16.400
So here we sent it the bytes and the max length
we're saying, OK let's say someone put a K

00:32:16.400 --> 00:32:18.680
or something, put 10K, we say write the whole thing.

00:32:18.680 --> 00:32:22.400
Now, as a return value, it'll return the bytes available.

00:32:22.400 --> 00:32:25.390
So that'll be the number of bytes
that were actually written.

00:32:25.390 --> 00:32:31.000
Now obviously when you get the callback that says that you
have space available, it's not saying like we talked about,

00:32:31.000 --> 00:32:33.559
it's not saying how much space you have available.

00:32:33.559 --> 00:32:37.519
So and also, as you progress through
your program, that will change right,

00:32:37.519 --> 00:32:42.299
so this will just return how much
data was actually able to get written.

00:32:42.299 --> 00:32:49.599
So if you get - 1, just like most strings for
people who have used the, the NSStream API before.

00:32:49.599 --> 00:32:52.169
If you get - 1, an error occurred.

00:32:52.170 --> 00:32:58.000
But you know when you're using this in normal operation,
you'll get either bytes written was 0, so it was,

00:32:58.000 --> 00:32:59.430
it was full it couldn't write anything to it.

00:32:59.430 --> 00:33:03.029
Or your bytes was greater than 0 and it was
actually able to write a chunk of your data.

00:33:03.029 --> 00:33:06.649
And then this will just loop through
until you've got no space available.

00:33:06.650 --> 00:33:12.690
And once that's finished all you have
to do is in your delegate you just wait

00:33:12.690 --> 00:33:15.650
for that has space available and
you call the exact same method.

00:33:15.650 --> 00:33:19.470
So this is definitely, what we hope that you
guys will use to get inspired to find out how

00:33:19.470 --> 00:33:25.100
to actually use the outputstream when
working with the ExternalAccessory framework.

00:33:25.099 --> 00:33:28.959
Now when you want to read data from
your stream, it's very, very similar.

00:33:28.960 --> 00:33:34.180
So obviously you can work in a poling fashion
but what the, what the specs recommend,

00:33:34.180 --> 00:33:36.580
definitely what we recommend is working asynchronously.

00:33:36.579 --> 00:33:43.109
So you'll want to have your system just wait for
this has bytes available which is right here.

00:33:43.109 --> 00:33:44.529
Until your delegate gets called with that.

00:33:44.529 --> 00:33:48.720
That'll only get called for your
NSInputStream object in your EASession.

00:33:48.720 --> 00:33:53.130
And when that happens then you'll call
a function, here we call _readdata.

00:33:53.130 --> 00:33:57.120
So let's go have a look at that.

00:33:57.119 --> 00:33:57.799
[ Period of silence ]

00:33:57.799 --> 00:34:03.019
So NSReadData goes to make sure that there
is data available in your input stream.

00:34:03.019 --> 00:34:05.789
And then goes through and, and reads them.

00:34:05.789 --> 00:34:12.969
So we have a buffer here, 128 bytes and we read it and
then we just print out the number of bytes that were read.

00:34:12.969 --> 00:34:14.799
Obviously, this will tell you what's there.

00:34:14.800 --> 00:34:20.710
You'll probably want to do something more interesting
such as post a notification locally to your system saying,

00:34:20.710 --> 00:34:24.960
OK I put these bytes in the buffer, whoever
wants them, go through, and use them.

00:34:24.960 --> 00:34:30.030
Now it's important to notice that we don't
make any assumptions here about the size

00:34:30.030 --> 00:34:32.350
of the buffer or of the data that was sent.

00:34:32.349 --> 00:34:34.119
And definitely, you shouldn't either.

00:34:34.119 --> 00:34:39.940
If you have an accessory that for example
is trying to send a K of data and it does

00:34:39.940 --> 00:34:45.420
so by sending four packets of 256 bytes of data, right?

00:34:45.420 --> 00:34:51.880
From your application layer, you can't assume that you'll
get four delegate callbacks, each of them indicating

00:34:51.880 --> 00:34:56.720
that you have one quarter of K data or they have 256 bytes.

00:34:56.719 --> 00:34:59.549
You can't do that because you have
to treat it just like a stream.

00:34:59.550 --> 00:35:03.340
So when you get it, you just read,
it'll tell you how much data is there.

00:35:03.340 --> 00:35:06.289
And you'll just want to keep reading
from it until it's empty.

00:35:06.289 --> 00:35:09.309
OK? So definitely, definitely it works like a normal stream.

00:35:09.309 --> 00:35:11.829
Anyone that's used NSStream before, very, very similar.

00:35:11.829 --> 00:35:13.440
Don't make any assumptions about it.

00:35:13.440 --> 00:35:19.130
Just read the data and you could get for example if you
were sending a K of data, you could get one callback

00:35:19.130 --> 00:35:21.490
for when you've gotten this 512 bytes in it.

00:35:21.489 --> 00:35:26.139
And then you can get it again with 256
bytes and then another one with 256, right?

00:35:26.139 --> 00:35:29.150
Or they could even be broken up further
depending on when the data was put

00:35:29.150 --> 00:35:31.599
in the stream, what the load on the system is, right?

00:35:31.599 --> 00:35:32.849
So that, that could change.

00:35:32.849 --> 00:35:36.219
So definitely don't make any assumptions about it.

00:35:36.219 --> 00:35:36.480
[ Period of silence ]

00:35:36.480 --> 00:35:40.990
And that's it for this part of the demo.

00:35:40.989 --> 00:35:46.709
Let me switch back to my slides.

00:35:46.710 --> 00:35:47.929
[ Period of silence ]

00:35:47.929 --> 00:35:49.289
Did that already.

00:35:49.289 --> 00:35:56.130
OK, OK. So now, when you guys go to use this
in the simulator, you'll notice something.

00:35:56.130 --> 00:35:58.329
You'll notice that the simulator actually,

00:35:58.329 --> 00:36:04.029
it actually indicates that two accessories are
already connected to your iPhone simulator.

00:36:04.030 --> 00:36:08.680
Now this is because it's a simulator we can't
take real accessories and we can't show them.

00:36:08.679 --> 00:36:15.250
But we do, we do bring up two and if
you do try to form a session with one,

00:36:15.250 --> 00:36:17.469
you won't be able to because they don't have protocols.

00:36:17.469 --> 00:36:22.619
So we just put, we tried to put as much information there as
we could to try and help you guys out and give you examples.

00:36:22.619 --> 00:36:27.569
But it does have, they do contain name
and fake serial numbers and all this.

00:36:27.570 --> 00:36:30.980
So you guys can have fun with that.

00:36:30.980 --> 00:36:31.389
Did, perfect.

00:36:31.389 --> 00:36:34.909
OK, now, I'll switch back to my demo.

00:36:34.909 --> 00:36:40.980
Now when debugging with external accessories, you're
going to run into this very unique sort of situation

00:36:40.980 --> 00:36:42.980
that most of you haven't run into before.

00:36:42.980 --> 00:36:48.409
Which is it'll become difficult to debug
with XCode unless you take a few measures.

00:36:48.409 --> 00:36:53.599
So if you're developing a Bluetooth
accessory you're fine, right?

00:36:53.599 --> 00:36:59.480
Because you can use that cable that came with your iPhone
or your iPod Touch to connect your iPhone to your Mac

00:36:59.480 --> 00:37:03.599
and you'll be able to run XCode and you'll be able to run
GDB and you'll be able to connect and set break points

00:37:03.599 --> 00:37:05.279
and set through your code and debug, right?

00:37:05.280 --> 00:37:06.110
You'll be fine.

00:37:06.110 --> 00:37:10.140
But the accessory that I'm using here
is just a very simple UART accessory.

00:37:10.139 --> 00:37:13.329
And unfortunately, it's connected to the 30 pin.

00:37:13.329 --> 00:37:17.400
So I can no longer connect that cable that
came with my iPhone and my iPod Touch.

00:37:17.400 --> 00:37:24.570
So what you'll want to do is if possible in your hardware
design, definitely have something near the 30 pin

00:37:24.570 --> 00:37:28.530
where you can fly out USB wires and
that you can connect them to your PC.

00:37:28.530 --> 00:37:32.480
So if you've got some pads that are
laid down on your PCB that you can use

00:37:32.480 --> 00:37:35.079
and in some debug hardware you'll fly out a cable.

00:37:35.079 --> 00:37:36.500
You'll find that'll be a lot easier.

00:37:36.500 --> 00:37:41.210
And while your accessory is connected, you'll
actually be able to run GDB and debug fix code.

00:37:41.210 --> 00:37:43.010
It'll be very, very convenient.

00:37:43.010 --> 00:37:44.230
So we talked about the UART case.

00:37:44.230 --> 00:37:45.320
[ Applause ]

00:37:45.320 --> 00:37:47.620
We had talked about the Bluetooth case.

00:37:47.619 --> 00:37:53.730
Next, if you're developing a USB accessory then
this will be a little bit more complicated.

00:37:53.730 --> 00:37:59.400
So when we use, when we communicate over
USB, we use a different USB configuration

00:37:59.400 --> 00:38:02.849
than when you're you know synched to your
machine or when you're connected through XCode.

00:38:02.849 --> 00:38:09.929
So you'll no longer be able to use XCode directly
with your, with your, with your application.

00:38:09.929 --> 00:38:12.219
So again, there's other techniques you can use.

00:38:12.219 --> 00:38:18.129
You can do logging through WiFi or you can
go through and actually you know save data

00:38:18.130 --> 00:38:20.710
to disk or you can check out syslog there.

00:38:20.710 --> 00:38:23.380
There's a few things that you can do to get around this.

00:38:23.380 --> 00:38:29.130
But if you are developing a USB accessory and you're not
sure how to go about it or really not sure how you're going

00:38:29.130 --> 00:38:32.030
to debug, we suggest that you come
to the lab and we can help you out

00:38:32.030 --> 00:38:36.150
and give you a few tricks that,
that we use internally to do that.

00:38:38.420 --> 00:38:45.309
Alright. So that's debugging your
hardware when using real EAAccessories.

00:38:45.309 --> 00:38:52.630
So finally at the start we, we promised that we would talk
a little bit about designing your own EA protocol just based

00:38:52.630 --> 00:38:56.800
on our experience working with accessory
manufacturers and accessory developers.

00:38:56.800 --> 00:38:59.710
So one is data integrity.

00:38:59.710 --> 00:39:02.349
This is a very, very important concept.

00:39:02.349 --> 00:39:09.250
Obviously you're working with hardware you can, you can
lose bytes and also in an application it does happen

00:39:09.250 --> 00:39:11.829
that you, there's some kind of erase condition.

00:39:11.829 --> 00:39:18.199
And like we talked about, you won't get the bytes
necessarily formed in the same way that you expect them.

00:39:18.199 --> 00:39:25.559
So for example if someone is sending a K of
data as four separate 256 you know packets of,

00:39:25.559 --> 00:39:30.929
four 256 byte of data packets, you
might get those in two 512s, right?

00:39:30.929 --> 00:39:33.989
So it's important that on your
application you actually check.

00:39:33.989 --> 00:39:37.779
So either through a CRC or a checksum or
some type of you know data integrity method,

00:39:37.780 --> 00:39:41.880
that you make sure that when you form your
packet, when you reform your information

00:39:41.880 --> 00:39:43.940
in your application, that it's what you expected.

00:39:43.940 --> 00:39:47.889
That the bytes are what your actual
hardware accessory expected to send.

00:39:47.889 --> 00:39:49.279
Next is security.

00:39:49.280 --> 00:39:56.620
So we put up that slide where we said the EA protocols any
developer that connects your accessory to it is going to see

00:39:56.619 --> 00:39:59.949
that you've got an accessory connected
to the system and it'll be able

00:39:59.949 --> 00:40:02.439
to see the protocols that that accessory supports.

00:40:02.440 --> 00:40:07.889
So it's important that if that is a concern to you
that you go through and you build in some security,

00:40:07.889 --> 00:40:13.170
so identification authorization, authentication,
some kind of way so that you can make sure

00:40:13.170 --> 00:40:18.059
that if you don't want people using your
accessory that they won't be able to.

00:40:18.059 --> 00:40:21.400
Next is this concept of framing.

00:40:21.400 --> 00:40:24.230
So this, these all kind of tie together.

00:40:24.230 --> 00:40:28.119
So when you work with data integrity let's
say something on the wire does disappear.

00:40:28.119 --> 00:40:31.170
And you end up with the bytes that you don't expect.

00:40:31.170 --> 00:40:34.519
Well all of a sudden, your stream can
go completely out of synch, right?

00:40:34.519 --> 00:40:38.519
And your application layer you're looking at
it and you don't know you know where the start

00:40:38.519 --> 00:40:41.179
of your data is again because some of it was lost.

00:40:41.179 --> 00:40:44.559
Well when that happens, we definitely
suggest that you use some kind of framing.

00:40:44.559 --> 00:40:48.679
So we'll go through, we'll have another example in a
few minutes that'll give you a good example of this,

00:40:48.679 --> 00:40:54.000
but people that are familiar with Bluetooth and
USB, they have their own synchronization methods.

00:40:54.000 --> 00:40:58.650
We definitely suggest that you implement something
similar to that in your own protocols just to make sure

00:40:58.650 --> 00:41:01.740
that if something does happen, you
can go, and you can recover from it.

00:41:01.739 --> 00:41:05.769
You can, your application can just continue seamlessly.

00:41:05.769 --> 00:41:13.610
Finally, the last design protocol we'd like to talk about
is this kind of hand waving idea of future proofing right?

00:41:13.610 --> 00:41:17.860
This is kind of difficult because it's so
specific to what you guys are trying to do.

00:41:17.860 --> 00:41:25.250
But basically, we want you to think about how EA Protocols
are going to be seen in, when you actually say OK,

00:41:25.250 --> 00:41:31.530
my accessory is going to work with these applications and
the App Store is going to connect some of these protocols

00:41:31.530 --> 00:41:34.560
to the application that's there to query them for me.

00:41:34.559 --> 00:41:40.269
Also, in my protocols I might know where my product line is
going in a few years, so I want to make sure to leave room

00:41:40.269 --> 00:41:45.039
for expansion so that I can keep the same
queries going and you know not have them break

00:41:45.039 --> 00:41:47.009
down depending on what my business model is.

00:41:47.010 --> 00:41:51.160
So we definitely encourage people to take this into
account and think about this when designing this

00:41:51.159 --> 00:41:55.759
and it'll hopefully save you any
haste that'll be in the future.

00:41:55.760 --> 00:41:57.910
So now performance.

00:41:57.909 --> 00:42:03.829
This is a question that we get quite a bit and it's, it's
very difficult to go through and characterize performance

00:42:03.829 --> 00:42:09.409
because it depends so much on how your
accessory is using the EA Framework

00:42:09.409 --> 00:42:12.769
and also how your accessory responds to commands, right?

00:42:12.769 --> 00:42:16.800
So there's, there's a whole part of
the stack that is in your control.

00:42:16.800 --> 00:42:20.030
And we need to work together right to find
out how this protocol is going to work.

00:42:20.030 --> 00:42:27.610
So on our side, we've done everything we can to ensure
speedy transfer across the, the different transports.

00:42:27.610 --> 00:42:31.730
So but obviously, because of this, it's difficult for
us to go through and actually guarantee something.

00:42:31.730 --> 00:42:35.219
But we can give you the, the specs on
some of the transports that we use.

00:42:35.219 --> 00:42:41.599
So on UART, we permit you to do 19.2 or
57.6 Kbps, so very, very standard rates,

00:42:41.599 --> 00:42:46.239
so people out there using [inaudible] controllers can
probably very easily find something that'll be able

00:42:46.239 --> 00:42:47.879
to divide to these clocks.

00:42:47.880 --> 00:42:52.980
And next over USB, you're free to
use full speed or high speed USB.

00:42:52.980 --> 00:42:55.280
And over BT, we use RFCOMM.

00:42:55.280 --> 00:43:00.010
So that's should give you an idea of what the,
what the performance you should be able to go.

00:43:00.010 --> 00:43:04.770
And goals, another thing that we are asked quite
a bit is you know Paul, what are the goals?

00:43:04.769 --> 00:43:06.829
Can I do this with EA Framework?

00:43:06.829 --> 00:43:07.779
Can I do that?

00:43:07.780 --> 00:43:10.480
Again, it really depends on what you guys are trying to do.

00:43:10.480 --> 00:43:15.889
But I'd like to give you three of the goals that we really
wanted to make sure that this framework could accomplish

00:43:15.889 --> 00:43:20.039
with everything we could think of for external accessories.

00:43:20.039 --> 00:43:21.670
So one is command and control.

00:43:21.670 --> 00:43:25.059
So this idea of handheld devices
that will go through and send

00:43:25.059 --> 00:43:29.610
and you know human time information
to and from your accessory.

00:43:29.610 --> 00:43:32.180
Next is some kind of real time data exchange.

00:43:32.179 --> 00:43:37.839
We definitely wanted to make sure that continuous real time
data exchange was definitely possible with this framework.

00:43:37.840 --> 00:43:42.320
And that's just file transfer, so that you know,
reasonable sized files could definitely go through

00:43:42.320 --> 00:43:48.530
and easily be transferred to and from
your accessories and your applications.

00:43:48.530 --> 00:43:58.769
So as a little bit of a treat, the, John Ananny, good friend
of mine from the iPod and iPhone accessory team that'll come

00:43:58.769 --> 00:44:02.820
up and show you an example of what he
did with the ExternalAccessory framework.

00:44:02.820 --> 00:44:03.090
John?

00:44:03.090 --> 00:44:03.420
[ Applause ]

00:44:03.420 --> 00:44:05.079
>> Thanks Paul.

00:44:05.079 --> 00:44:12.099
So as mentioned my name is John Ananny, I'm one of
the engineers on the iPod and iPhone accessories team.

00:44:12.099 --> 00:44:19.230
So Paul has gone through some specific examples of the
code on the app side and he's also talked about some

00:44:19.230 --> 00:44:23.619
of the general principles on how
and why you design a protocol.

00:44:23.619 --> 00:44:29.449
And we thought the next logical step would be to go through
a specific example of what one particular protocol looks

00:44:29.449 --> 00:44:33.299
like in the hopes that this would
inspire you to design your own.

00:44:33.300 --> 00:44:37.140
So actually have a dark secret, I'm a diehard Pong fan.

00:44:37.139 --> 00:44:42.349
And it's not always possible to find a local
Pong game, so one of the first things I did

00:44:42.349 --> 00:44:46.019
with the ExternalAccessory framework
after it became available was

00:44:46.019 --> 00:44:50.079
to make a simple one person Pong
practice game called Wall Ball.

00:44:50.079 --> 00:44:52.380
And that's it up there on the right.

00:44:52.380 --> 00:44:57.130
There's not a whole heck of a lot going on, but there's
a paddle down at the bottom that you control and the game

00:44:57.130 --> 00:45:02.500
of course as anybody that's played Pong knows is to keep
the ball from falling through the bottom of the screen.

00:45:02.500 --> 00:45:08.550
Turns out there's a protocol underpinning this and the,
the amount of data moving back and forth is pretty simple

00:45:08.550 --> 00:45:12.240
and it seemed like we could go through
that example in its entirety for you.

00:45:12.239 --> 00:45:14.209
So Wall Ball, a couple things going on.

00:45:14.210 --> 00:45:17.139
We've got a physical accessory and
I'm going to show that in a moment.

00:45:17.139 --> 00:45:19.650
The physical accessory moves the paddle.

00:45:19.650 --> 00:45:24.480
There's a push button on the accessory, I have days when I
feel like playing with an orange paddle and days that I feel

00:45:24.480 --> 00:45:29.010
like playing with a blue paddle, so we can use
the push button to change the paddle color.

00:45:29.010 --> 00:45:32.920
And every single the time the ball this the LED,
we send a command down to the physical hardware

00:45:32.920 --> 00:45:37.019
to say flash the LED when the ball hits the paddle.

00:45:37.019 --> 00:45:43.349
So the data that's actually moving from the EAAccessory
down to the physical, sorry from the EAAccessory

00:45:43.349 --> 00:45:49.259
up to the application we have regular updates on the
position of the controler that drives the paddle.

00:45:49.260 --> 00:45:55.540
And every single time the push button gets pressed, we
have those events that make it up to the app as well.

00:45:55.539 --> 00:46:01.429
And the other direction, the app needs to tell
the accessory what the state of the LED should be.

00:46:01.429 --> 00:46:03.609
So enough talking, let's look at it.

00:46:03.610 --> 00:46:09.990
So what I have is a physical accessory connected to.

00:46:09.989 --> 00:46:13.909
[ Period of silence ]

00:46:13.909 --> 00:46:17.829
[ Applause ]

00:46:17.829 --> 00:46:20.130
So for the hardware hackers in the room, that is

00:46:20.130 --> 00:46:23.360
in fact a one turn potentiometer,
there's nothing too fancy going on here.

00:46:23.360 --> 00:46:25.090
[ Laughter ]

00:46:25.090 --> 00:46:29.390
And the same simple demo board
that Paul used for his example,

00:46:29.389 --> 00:46:34.349
we have little expansion header here that's
monitoring the position of that potentiometer.

00:46:34.349 --> 00:46:36.559
And we have our app.

00:46:36.559 --> 00:46:41.440
So let's see if I can play looking over my shoulder here.

00:46:41.440 --> 00:46:49.070
Alright so this feels like, this doesn't really
feel like a green paddle day, so let's blue, yes.

00:46:49.070 --> 00:46:51.720
This definitely is a blue paddle day.

00:46:51.719 --> 00:46:57.989
So it looks like my Pong skills are
about as mediocre as they've ever been.

00:46:57.989 --> 00:46:59.599
So I'm going to need a little bit more practice.

00:46:59.599 --> 00:47:02.319
But maybe not just now.

00:47:02.320 --> 00:47:06.340
So this is a UART accessory.

00:47:06.340 --> 00:47:09.519
There's not a whole heck of a lot
of data going back and forth.

00:47:09.519 --> 00:47:16.300
But there's certainly some structure to how we send
the bytes back and forth between app and accessory.

00:47:16.300 --> 00:47:20.269
So the protocol itself.

00:47:20.269 --> 00:47:25.679
It's fundamentally a protocol is just
what's the structure to this stream

00:47:25.679 --> 00:47:28.509
of bytes that's going back and
forth between the two end points.

00:47:28.510 --> 00:47:32.720
And Wall Ball is organized around the notion of frames.

00:47:32.719 --> 00:47:38.679
So frames are always 4 bytes in length and any
one particular frame is a self contained object

00:47:38.679 --> 00:47:44.169
that contains some particular piece of information
either from the app to the accessory or vice versa.

00:47:44.170 --> 00:47:52.190
So column 7 there, bit 7 frames are
identified on the wire by the presence

00:47:52.190 --> 00:47:56.909
of a high bit on the 0 byte of the 4 byte frame.

00:47:56.909 --> 00:48:01.319
So if you think about it from the receiver's point
of view, it just sees bytes going by and it needs

00:48:01.320 --> 00:48:05.200
to somehow achieve frame synchronization to
the byte stream and figure out, you know what,

00:48:05.199 --> 00:48:08.099
what to make of this stream of bytes that's going by.

00:48:08.099 --> 00:48:14.250
Every single time the receiver sees a byte with its bit 7
set, it can say ah, OK, regardless of where I think I am,

00:48:14.250 --> 00:48:18.219
I now know for sure that I'm at the
start of a, the reception of a frame.

00:48:18.219 --> 00:48:22.859
And that tells the receiver to receive
three more bytes, now you have four bytes

00:48:22.860 --> 00:48:25.360
and you can parse and use that information.

00:48:25.360 --> 00:48:33.470
The actual fields in a frame I've got a 5 bit command field
and 16 bits of arbitrary payload and then a 7 bit CRC.

00:48:33.469 --> 00:48:37.149
We won't talk about the details of the CRC but
you can imagine there's plenty of algorithms

00:48:37.150 --> 00:48:42.380
for detecting whether a byte or multiple bits
has been corrupted somewhere in that frame.

00:48:42.380 --> 00:48:46.780
So if we have a CRC mismatch, we'll
just throw the frame away and move on.

00:48:46.780 --> 00:48:53.610
So the interesting parts of the frame
are the command and the payload.

00:48:53.610 --> 00:48:57.030
So right now, we just have three commands to find.

00:48:57.030 --> 00:49:01.230
Two of them that are sent by the accessory
and one of them which is sent by the app.

00:49:01.230 --> 00:49:09.269
The first so command, command value 0 would, would mean
OK the payload contains an absolute controller position.

00:49:09.269 --> 00:49:14.599
So anything from fully counterclockwise to
fully clockwise for the rotary controller.

00:49:14.599 --> 00:49:19.089
Command 1 would mean a bitmask of
the states of a the push buttons.

00:49:19.090 --> 00:49:22.170
Right now, we just have one push
button, so we just use the 0th bit.

00:49:22.170 --> 00:49:28.340
Those are sent on a frequent schedule so that as the push
button is pressed and released, the app is able to see that.

00:49:28.340 --> 00:49:37.269
And the command value 2 is sent down from the app to the
accessory and this would be a bit mask of the desired state

00:49:37.269 --> 00:49:42.780
of the various LEDs on the board and again in this case
we only use the 0th bit for the one particular LED.

00:49:42.780 --> 00:49:47.590
And those again can be sent down on a regular
schedule or they can be sent on change only.

00:49:47.590 --> 00:49:51.860
Those are, those are details and you can do a little
bit of tuning and optimization is you care to.

00:49:51.860 --> 00:49:57.570
But the simplest scheme would just be to send
updates on a regular, on a regular clock.

00:49:57.570 --> 00:49:59.860
So commands 3 and above I haven't defined.

00:49:59.860 --> 00:50:01.370
They're reserved for future use.

00:50:01.369 --> 00:50:05.349
I'm not sure, when Wall Ball 2.0 will
be, but there has to be one so we'll,

00:50:05.349 --> 00:50:07.630
we'll keep, we'll keep room for future growth.

00:50:07.630 --> 00:50:14.200
So the protocol name itself, probably not
that many Wall Ball engineers within Apple,

00:50:14.199 --> 00:50:17.679
but I've tried to keep the namespace fairly tight.

00:50:17.679 --> 00:50:20.059
So com.Apple.WallBallletpaddle.

00:50:20.059 --> 00:50:23.900
If someone else is using this, we'll have
to figure out how to resolve the contention.

00:50:23.900 --> 00:50:27.510
But you'll want to within your organization
figure out how to use reverse DNS

00:50:27.510 --> 00:50:31.220
to manage you know different product
lines, different business units.

00:50:31.219 --> 00:50:35.199
You've got sort of the arbitrary depth
of reverse DNS at your disposal here.

00:50:35.199 --> 00:50:38.279
So what have we actually achieved?

00:50:38.280 --> 00:50:44.930
Well frame syncs, so via that bit 7 mechanism,
we're very confident that at start up,

00:50:44.929 --> 00:50:48.879
in response to you know whatever conditions
may arise, we're always going to be able

00:50:48.880 --> 00:50:52.090
to very quickly reachieve frame sync to the byte stream.

00:50:52.090 --> 00:50:57.820
Data integrity as I said you know 7, 7
bit CRC is plenty powerful to detect.

00:50:57.820 --> 00:51:01.200
You know you won't do much correction, but you'll
certainly detect that there's something wrong

00:51:01.199 --> 00:51:03.879
with any particular frame and you can discard it.

00:51:03.880 --> 00:51:07.700
Future expansion, as mentioned, I don't
know what Wall Ball 2.0 looks like,

00:51:07.699 --> 00:51:10.359
but we've got room for more commands as needs.

00:51:10.360 --> 00:51:13.380
And this 4 byte frame is pretty low overhead.

00:51:13.380 --> 00:51:16.740
You could, you could get fancy and you
could imagine variable frame lengths

00:51:16.739 --> 00:51:19.279
as a function of the command and other complications.

00:51:19.280 --> 00:51:21.980
But those are, those are details.

00:51:21.980 --> 00:51:24.990
One thing that we haven't achieved here.

00:51:24.989 --> 00:51:31.269
In this particular case, the built in security I'm pretty
comfortable if someone wants to watch the bytes go by

00:51:31.269 --> 00:51:35.280
and reverse engineer the Wall Ball control
protocol in this particular case, I don't care.

00:51:35.280 --> 00:51:41.019
But you know you should, you shouldn't, you shouldn't, you
shouldn't accidentally forget about issues of security.

00:51:41.019 --> 00:51:45.019
You should decide whether you do or
don't care and engineer accordingly.

00:51:45.019 --> 00:51:48.780
So, at this point, I'm going to
hand back to Paul and he'll talk

00:51:48.780 --> 00:51:52.600
about how you can get more information
and what the next steps would be.

00:51:52.599 --> 00:51:58.400
[ Applause ]

00:51:58.400 --> 00:51:59.590
>> Alright, thanks John.

00:51:59.590 --> 00:52:05.680
So we have obviously tried to put together everything
we could in this presentation to help you guys

00:52:05.679 --> 00:52:09.739
out to get you started and have a great
experience with the ExternalAccessory framework.

00:52:09.739 --> 00:52:16.559
But if you do need more information associated with
this feature are few evangelists so send them an email,

00:52:16.559 --> 00:52:19.159
they somehow seem to know everything which is great.

00:52:19.159 --> 00:52:23.230
And I've put up a few documentations,
a few pieces of documentation there

00:52:23.230 --> 00:52:24.849
that you'll definitely want to check out.

00:52:24.849 --> 00:52:28.019
So the second one again is the
Introduction to Stream Programming Guide

00:52:28.019 --> 00:52:29.690
which I definitely suggest that you look at.

00:52:29.690 --> 00:52:31.630
I think we tried to give you a good introduction to it.

00:52:31.630 --> 00:52:36.180
So for people who haven't used it before, but you'll
definitely want to go and have a look at that.

00:52:36.179 --> 00:52:38.879
Next is the iPhone OS Accessories Page.

00:52:38.880 --> 00:52:43.809
So if you go to
developer.apple.com/iPhone/program/accessories,

00:52:43.809 --> 00:52:45.449
check it out, a lot of good information there.
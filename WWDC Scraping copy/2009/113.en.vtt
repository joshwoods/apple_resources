WEBVTT

00:00:12.679 --> 00:00:16.870
>> Chris: My name is Chris Parker I work
actually on the iPhone Frameworks Team right now

00:00:16.870 --> 00:00:22.280
and we'll be talking a little bit about taking all of
the skills that you've learned as an iPhone developer

00:00:22.280 --> 00:00:24.820
and applying them to programming on the Mac for the desktop.

00:00:24.820 --> 00:00:29.129
How many of you have actually done some
Mac programming on the desktop before?

00:00:29.129 --> 00:00:34.140
Cool, so like 25% or so that's% a great
number thanks for getting started.

00:00:34.140 --> 00:00:40.200
We're going to talk a little bit, you know, basically you
spend a bunch of time trying to get your application to fit

00:00:40.200 --> 00:00:47.050
on an iPhone, a little tiny device, memory constrained,
it has some UI constraints based on the screen shape

00:00:47.049 --> 00:00:52.019
and the screen size and you're going to move up
to programming on the Macintosh and Mac, you know,

00:00:52.020 --> 00:00:57.400
has up to 8 cores, it's got 30 inch displays hooked
up to it and there are a lot of different things

00:00:57.399 --> 00:01:03.000
that inform the UI framework about dealing
with larger screens and things like that.

00:01:03.000 --> 00:01:08.260
And just, also, the event models are different and there
are some gotchas and we're going to cover a lot of those.

00:01:08.260 --> 00:01:13.780
Some of the things that should be very, very familiar to you
already, for instance, these guys the square brackets right,

00:01:13.780 --> 00:01:16.480
if you're new to programming for the
iPhone you suddenly realize these weren't

00:01:16.480 --> 00:01:19.260
for array dereferencing anymore
these are the square brackets

00:01:19.260 --> 00:01:23.770
for Objective-C message sense it's
the same language on both platforms.

00:01:23.769 --> 00:01:29.750
All of the tools that you already use to build your iPhone
applications, so Xcode for managing your projects resources

00:01:29.750 --> 00:01:34.750
and all of its code and building and debugging
within Xcode, all of that's pretty much the same.

00:01:34.750 --> 00:01:41.349
Interface Builder has -- not only does it have all the
iPhone UI elements built into it and all the UI smarts

00:01:41.349 --> 00:01:46.809
to be able to build interfaces via drag and drop
it has all of that stuff for the AppKit as well

00:01:46.810 --> 00:01:48.560
on the Cocoa side of things on a desktop.

00:01:48.560 --> 00:01:53.519
And Instruments, basically, the same program,
you know, so the workflow for building your code

00:01:53.519 --> 00:01:57.920
and developing your interface and instrumenting your
code and figuring out how everything works and seeing

00:01:57.920 --> 00:02:04.540
where your performance problems are all of that workflow
is basically all the same, so you're already very familiar

00:02:04.540 --> 00:02:08.219
with how to build up an application on the Macintosh.

00:02:08.219 --> 00:02:14.900
You heard Bertrand talk about sort of
the core layering that we use and, you know, there's Core OS

00:02:14.900 --> 00:02:21.520
and Core Services and the Media Frameworks and things like
that and on the iPhone Cocoa Touch is made up of UIKit

00:02:21.520 --> 00:02:26.710
in the Foundation and a number of other frameworks
and pretty much that diagram stays the same for Cocoa.

00:02:26.710 --> 00:02:30.890
There's a Cocoa umbrella framework that your
applications will link against for the most part

00:02:30.889 --> 00:02:36.789
that by default contains AppKit, Foundation and Core Data
and, you know, if you're using Core Data on both the iPhone

00:02:36.789 --> 00:02:40.269
and desktop that's a great opportunity here now in 3.0.

00:02:40.270 --> 00:02:45.000
Some common things that are frameworks to both the desktop

00:02:45.000 --> 00:02:51.000
and the iPhone the Address Book framework is pretty much
the same so that API is available in both places for dealing

00:02:51.000 --> 00:02:57.050
with your user's contact information that they have for all
the people that they've met and put into their address book.

00:02:57.050 --> 00:03:02.950
The Security framework is the same so just like on the
iPhone if you're handling user's passwords and things

00:03:02.949 --> 00:03:05.259
like that you want to store those securely in the Keychain

00:03:05.259 --> 00:03:10.129
so they're encrypted the Macintosh has
the Security APIs available to you.

00:03:10.129 --> 00:03:15.120
Core Foundation and Foundation are both
available in both places so if your model objects

00:03:15.120 --> 00:03:21.330
and a lot of your business logic are going to be written
as Foundation based objects, NSObject descended classes all

00:03:21.330 --> 00:03:24.830
of that code you'll be able to largely
reuse probably without modification.

00:03:24.830 --> 00:03:34.470
CFNetwork is also available so if you've been doing
custom network loading with, you know, the CF HTTP,

00:03:34.469 --> 00:03:38.659
APIs things like that, that API
is also available on the desktop.

00:03:38.659 --> 00:03:44.099
The System Configuration on the desktop, the framework there
is a little bit different than the one that's on the iPhone.

00:03:44.099 --> 00:03:49.719
The iPhone has a very small set of APIs the System
Configuration framework on the desktop contains many

00:03:49.719 --> 00:03:52.830
of the things that you would normally find in
a UI device and it also contains information

00:03:52.830 --> 00:03:58.360
about how many network interfaces the computer has and all
the things that can be plugged into the machine as they come

00:03:58.360 --> 00:04:04.260
and go there are rich APIs for determining the
state of a computer in System Configuration.

00:04:04.259 --> 00:04:08.239
All of the Core Audio APIs are there
for the most part they're all available

00:04:08.240 --> 00:04:13.640
so if you're doing custom Core Audio filters or
writing your own audio processing code you'll be able

00:04:13.639 --> 00:04:15.979
to use a lot of that on the desktop as well.

00:04:15.979 --> 00:04:18.889
Quartz is available in both places
so if you're familiar with using some

00:04:18.889 --> 00:04:24.000
of the Core Graphics APIs you'll be
able to use those in both places.

00:04:24.000 --> 00:04:30.399
New in iPhone OS 3.0 Core Data is
available on the phone so if you're going

00:04:30.399 --> 00:04:35.959
to be using a framework Core Data's been available for a
long time on the desktop and now it's available on the phone

00:04:35.959 --> 00:04:41.529
so if you're going to be running your app on 3.0 and Snow
Leopard you'll be able to share a lot of code there as well.

00:04:41.529 --> 00:04:46.739
And moving from the phone the other way to the
desktop is Core Location so if you have an application

00:04:46.740 --> 00:04:53.180
that uses some location-based services on the iPhone, Snow
Leopard contains a version of the Core Location framework

00:04:53.180 --> 00:04:59.189
so you'll be able to use some of that code as well so you
can have a location aware desktop Macintosh application.

00:04:59.189 --> 00:05:04.339
It doesn't just say your desk is here, by the
way, you know, if you have a laptop it tracks you.

00:05:04.339 --> 00:05:10.750
Mac feature availabilities some things are
available only on the desktop or only on the iPhone

00:05:10.750 --> 00:05:15.290
but some of the big hitters here the
Macintosh supports Garbage Collection,

00:05:15.290 --> 00:05:19.629
so we have an automated Garbage Collector on the
desktop it's an optional thing you can choose

00:05:19.629 --> 00:05:24.709
to compile your application with Garbage Collection
turned on and for those when Garbage Collection is

00:05:24.709 --> 00:05:27.739
on retain, release and autorelease become no-ops.

00:05:27.740 --> 00:05:31.360
Alright, so we basically sort of swallow those and
we track the lifetime of the object by tracking

00:05:31.360 --> 00:05:34.879
where it gets assigned and we keep track
of all those write barriers and make sure

00:05:34.879 --> 00:05:37.870
that there's a reference to all of those pointers.

00:05:37.870 --> 00:05:43.370
And then a collector thread comes along and it cleans up
any unreferenced memory so you can use Garbage Collection

00:05:43.370 --> 00:05:47.910
on the desktop if you want but
it's not available on the iPhone.

00:05:47.910 --> 00:05:53.050
And the Blocks Language Construct, you know, you
heard Bertrand and Bud and some of those guys talk

00:05:53.050 --> 00:05:56.829
about Grand Central Dispatch and blocks and this
new language construct those aren't available

00:05:56.829 --> 00:05:59.659
on the iPhone but they are available on the desktop.

00:05:59.660 --> 00:06:04.710
Some of the API that only takes blocks on the desktop
won't be available on the iPhone those are all guarded

00:06:04.709 --> 00:06:12.549
by these availability macros and so you'll see things
like Foundation uses the IF NS blocks available,

00:06:12.550 --> 00:06:20.790
# IF to be able to keep that code from appearing and you'll
frequently see IF Target OS Mac and not Target OS iPhone

00:06:20.790 --> 00:06:25.439
and that's your guide to be able to read the
headers and figure out what API is available

00:06:25.439 --> 00:06:28.579
on the desktop only and what APIs available in both places.

00:06:28.579 --> 00:06:33.659
Generally if something's not decorated
it's available in both places.

00:06:33.660 --> 00:06:39.610
We make a big deal in all of our documentation and
in a lot of our sample code and things like that

00:06:39.610 --> 00:06:45.420
of writing the Model View Controller paradigm, so if
you've been writing your UIViews and you've got a lot

00:06:45.420 --> 00:06:50.730
of Model code underneath and the Controllers mediate
between those 2 a lot of your Model code is really going

00:06:50.730 --> 00:06:55.860
to be completely reusable so you should be able
to take most of that View code and rewrite that

00:06:55.860 --> 00:06:58.810
but keep all of your Model logic the same.

00:06:59.949 --> 00:07:09.250
So let's talk a little bit about
Views and Windows and Events.

00:07:09.250 --> 00:07:19.139
In the AppKit on the desktop NSView is the base class for
views and UIView is the base class for all UIViews in UIKit.

00:07:19.139 --> 00:07:25.000
They both are responsible for receiving and handling
events so when you construct your subview tree,

00:07:25.000 --> 00:07:31.839
the views take care of figuring out where the event happened
and sending the events up the responder chain appropriately

00:07:31.839 --> 00:07:35.679
but this is where a lot of that machinery starts.

00:07:35.680 --> 00:07:39.939
They're both responsible for drawing so
there's a draw rect method and you can draw

00:07:39.939 --> 00:07:44.889
when you get the draw rect message
but they're both set up for drawing.

00:07:44.889 --> 00:07:49.769
There are some differences though one of them
is UIView's origin is 00 in the upper left

00:07:49.769 --> 00:07:53.959
so when you're holding the device the origin
is up here in the upper left-hand corner.

00:07:53.959 --> 00:08:00.479
NSView's origin is actually in the lower
left and that's just a heritage of the AppKit

00:08:00.480 --> 00:08:05.189
but it has some rendering benefits
depending on which direction you're drawing.

00:08:05.189 --> 00:08:08.850
UIViews always have layers so if you've been doing
iPhone programming for a while you're familiar

00:08:08.850 --> 00:08:11.250
with the idea of how the layer-backed drawing works.

00:08:11.250 --> 00:08:17.800
UIViews always have a layer NSViews opt into a layer so the
drawing model in the AppKit is a little bit different due

00:08:17.800 --> 00:08:23.030
to where the backing store is owned for drawing.

00:08:23.029 --> 00:08:30.329
And in UIView subviews can draw outside the view bounds
optionally a UIView you can put subviews into a view

00:08:30.329 --> 00:08:35.360
and the bounds of those views extend outside of
the superview's bounds and they'll actually draw

00:08:35.360 --> 00:08:39.120
out there unless you say Set Clips to Bounds, Yes.

00:08:39.120 --> 00:08:44.700
NSView's subviews always get clipped to the view bounds,
so if you've been taking advantage of that feature

00:08:44.700 --> 00:08:49.250
in UIView you won't be able to do that in NSView.

00:08:49.250 --> 00:08:55.059
So here's the example of the origin, the origin in the
UIView is in the upper left, NSView is in the lower left

00:08:55.059 --> 00:08:59.689
but there are times where that may
not necessarily be what you want.

00:08:59.690 --> 00:09:05.470
On the desktop the View class has this
idea of whether or not it's flipped

00:09:05.470 --> 00:09:10.009
so this is the default implementation
for isFlipped for NSView.

00:09:10.009 --> 00:09:15.460
If you override this in your custom
NSView subclass to say isFlipped, Yes,

00:09:15.460 --> 00:09:18.330
the origin slides up to the upper left, right?

00:09:18.330 --> 00:09:25.420
Some views in the AppKit are flipped by default
some views are not but the base class is flipped,

00:09:25.419 --> 00:09:29.549
is returning No so the origin is in the lower left.

00:09:29.549 --> 00:09:36.419
A bunch of NSView classes so NSButton, ScrollView,
SplitView, TabView and TableView are all flipped by default

00:09:36.419 --> 00:09:39.269
so their origins are all in the upper left
and that has to do with being, you know,

00:09:39.269 --> 00:09:42.629
a table view generally draws from the upper left down.

00:09:42.629 --> 00:09:48.189
Some views will actually allow control over this
flipped concept based on what the current context is

00:09:48.190 --> 00:09:52.400
or they have API for it so NSImage, for
instance, will figure out whether it's drawing

00:09:52.399 --> 00:09:54.399
into a flipped view and draw appropriately.

00:09:54.399 --> 00:09:59.269
NSTextView and NSFont the text system figures
out whether or not you're in a flipped view

00:09:59.269 --> 00:10:04.169
and draws also appropriately and, you know, ClipView
and things like that also take this into account.

00:10:04.169 --> 00:10:08.759
So there's a lot of documentation over what's flipped and
what isn't, so sometimes you'll see something and you'll go,

00:10:08.759 --> 00:10:13.450
oh, it's drawing down here and I want it to draw up
here, oh, well, it's a flipped view so I have to take

00:10:13.450 --> 00:10:19.220
that into account so you can find out whether
or not views are flipped with the UseFlip API.

00:10:19.220 --> 00:10:23.509
Oh look it's this session.

00:10:23.509 --> 00:10:32.269
Here's basically a Keynote window and we could kind of
explode this to think about how the views are laid out,

00:10:32.269 --> 00:10:38.230
and we collapsed the actual Keynote decorations into one
view but notionally that's a whole lot of views there.

00:10:38.230 --> 00:10:44.430
But the idea here is for a set of NSViews
is that we render those NSViews in Z order

00:10:44.429 --> 00:10:46.459
to a backing store that's owned by the window.

00:10:46.460 --> 00:10:53.360
Right, so remember when I was talking earlier about UIViews
each having a layer and, you know, you've got a whole bunch

00:10:53.360 --> 00:10:59.180
of views in there and if you update a view in
the middle of that just that view gets updated,

00:10:59.179 --> 00:11:05.469
none of the other UIViews get updated because the
rendering tree just composites all of that together.

00:11:05.470 --> 00:11:10.029
In the AppKit when you add something to a scene like
say, for instance, we Photoshopped this person in there

00:11:10.029 --> 00:11:16.230
and we want to draw that into an already existing view
sub-hierarchy, basically, what we have to do is figure

00:11:16.230 --> 00:11:23.200
out where that rectangle appears and for every view that's
in the hierarchy, basically, tell that view that it has

00:11:23.200 --> 00:11:27.820
to invalidate itself in that rectangle and then
render that whole backing store to the back again.

00:11:27.820 --> 00:11:32.370
The AppKit is very fast at this, there's a lot
of horsepower to throw at this kind of rendering

00:11:32.370 --> 00:11:35.310
so we can render all the way back to a backing
store that's owned by the window and this works

00:11:35.309 --> 00:11:38.829
out to be a big memory performance win for us.

00:11:38.830 --> 00:11:46.060
You can, however, opt NSViews into what's called
Layer-Backed Mode, so rather than having this backing store

00:11:46.059 --> 00:11:53.579
that renders all the way back to the NSWindow if you
call setWantsLayer and pass it Yes what happens is all

00:11:53.580 --> 00:11:58.820
of the subviews get layers and now the invalidation model

00:11:58.820 --> 00:12:02.220
and the rendering model is pretty
much the same as UIView, right?

00:12:02.220 --> 00:12:06.490
Rather than rendering all the way back to a
backing store each view draws into its layer

00:12:06.490 --> 00:12:12.240
and then those layers are composited and when you move those
around none of those views are getting redraw commands.

00:12:13.269 --> 00:12:14.439
When should you opt in?

00:12:14.440 --> 00:12:18.180
You want to opt in really if you want to
reduce redraw to make your animation smoother,

00:12:18.179 --> 00:12:23.929
so every time 2 views would intersect in the NSView
drawing model, you know, there's an increasing number

00:12:23.929 --> 00:12:29.370
of pixels you have to draw and then it
decreases when the views stop overlapping.

00:12:29.370 --> 00:12:32.629
You can opt into it in order to
reduce some of that draw noise

00:12:32.629 --> 00:12:35.409
because the compositing engine takes care of it for you.

00:12:35.409 --> 00:12:39.759
You also need to opt in if you're going to use
CAFilters to basically decorate your views,

00:12:39.759 --> 00:12:44.970
so if you're going to put shadows on the views or
do any of those other neat effects that you see

00:12:44.970 --> 00:12:48.300
in the Core Image Funhouse app or something like that.

00:12:48.299 --> 00:12:53.599
The CAFilters are all -- you'll need to use
Layer-Backed views in order to use CAFilters.

00:12:53.600 --> 00:12:58.810
The flip side to when do you opt in is when don't
you opt in and the answer's most of the time,

00:12:58.809 --> 00:13:02.049
most of your drawing is gonna happen
in your NSView subclasses.

00:13:02.049 --> 00:13:07.229
Draw methods and the AppKit is very fast at pushing
all of those bits all the way back to the backing store

00:13:07.230 --> 00:13:13.230
for the window so you're not really gonna need
Layer-Backed NSViews all the time and it does amount

00:13:13.230 --> 00:13:16.460
to somewhat of a performance win to not use it.

00:13:16.460 --> 00:13:21.320
So what we recommend is if you are going to
use it turn it on, use it, do your animation,

00:13:21.320 --> 00:13:24.320
schedule all of your behaviors and then turn it off again.

00:13:24.320 --> 00:13:31.170
Right, so you can dynamically opt views in and out of
the Layer-Backed views but this makes it a lot easier

00:13:31.169 --> 00:13:36.079
to do some of your drawing a lot faster too.

00:13:36.080 --> 00:13:41.139
UIWindow and NSWindow, so, again, there's
another set of parallel classes here and UIKit,

00:13:41.139 --> 00:13:45.309
UIWindow is basically a container for views.

00:13:45.309 --> 00:13:50.209
In the AppKit NSWindow is the container
for views that's very similar.

00:13:50.210 --> 00:13:59.320
In UIKit, UIWindow inherits from UIView, but in the AppKit
NSWindow inherits directly from NSResponder so NSWindow

00:13:59.320 --> 00:14:04.810
and NSView are actually peer classes in terms of their
hierarchies; this changes a little bit the things

00:14:04.809 --> 00:14:09.039
that you can do with an NSWindow versus with a UIWindow.

00:14:09.039 --> 00:14:17.509
With the UIWindow there's no user manipulation, there are
no controls on the UIWindow when UIKit creates one for you

00:14:17.509 --> 00:14:21.110
to resize the window or to close it or anything like that.

00:14:21.110 --> 00:14:24.200
In NSWindow we allow user manipulation
of the window directly,

00:14:24.200 --> 00:14:30.379
so NSWindows can be resized we have the Resize control
on the lower right or they can be closed or minimized

00:14:30.379 --> 00:14:37.200
or maximized via the controls in the upper left, so all
of those things are things that you can do in NSWindow

00:14:37.200 --> 00:14:42.180
that you can't do with the UIWindow and it changes
a little bit some of the things about drawing.

00:14:42.179 --> 00:14:48.750
UIWindows are always screen sized, when UIWindow comes up
out of a NIB when we create one for you it's always 320

00:14:48.750 --> 00:14:52.259
by 480, it's always the same size it's always full screen.

00:14:52.259 --> 00:14:55.600
When you create one programmatically
all of our documentation tells you,

00:14:55.600 --> 00:14:58.920
you make it full screen, so that's 320 by 480.

00:14:58.919 --> 00:15:05.599
NSWindows can be any size programmatically or if the user
resizes them and the users resize windows all the time,

00:15:05.600 --> 00:15:08.920
you've got 15 windows you're probably doing it on Xcode
all the time too, you know, you've got a whole bunch

00:15:08.919 --> 00:15:11.929
of windows open, you're moving things around,
you're shrinking things, you're expanding things,

00:15:11.929 --> 00:15:18.229
you're trying to make your work environment more comfortable
and that also informs how we do NSWindow work in the AppKit.

00:15:18.230 --> 00:15:21.840
Also, UIWindow you pretty much get 1 in most UIKit apps.

00:15:21.840 --> 00:15:25.100
I mean, you can use UIWindows as containers
for other things and shift them back and forth

00:15:25.100 --> 00:15:27.389
but usually there's pretty much 1 window.

00:15:27.389 --> 00:15:30.799
In NSWindow you can have many windows
in a single application.

00:15:32.399 --> 00:15:38.500
Also, for event handling, there are some
similarities between the 2 event mechanisms as well.

00:15:38.500 --> 00:15:42.820
There we go.

00:15:42.820 --> 00:15:48.940
UIEvents and NSEvents both contain information about
input actions so they're both going to tell you everything

00:15:48.940 --> 00:15:52.980
about what happens as the user
interacts with your application.

00:15:52.980 --> 00:16:00.639
UIEvents contain UITouch objects pretty much or in actually
iPhone OS 3.0 they might tell you about a motion event

00:16:00.639 --> 00:16:07.379
that happened as well but those pretty much are just about
all of the events that happen as the user touches the glass

00:16:07.379 --> 00:16:09.840
and puts their fingers on the glass to do gestures.

00:16:09.840 --> 00:16:16.480
And NSEvents encapsulates all kinds of different events,
there, you know, not only does your user have a track pad

00:16:16.480 --> 00:16:22.789
on their laptop but they'll have keyboards and
mice hooked up they'll have tablets with a pen

00:16:22.789 --> 00:16:27.959
and the pen might produce proximity events as it gets
close to the tablet, so all of those events are things

00:16:27.960 --> 00:16:33.379
that you can find out about from NSEvent and it covers
all of those input devices that basically can be plugged

00:16:33.379 --> 00:16:37.360
into the user's computer; so this is a far richer
set of events that you have access to the NSEvent.

00:16:37.360 --> 00:16:44.649
UIEvents are persistent through a sequence so, you
know, as an event happens and as the user touches

00:16:44.649 --> 00:16:51.889
on the screen those touches build up into a single UIEvent
and that UIEvent is the same event object the whole time.

00:16:51.889 --> 00:16:57.319
In NSEvent in the AppKit every time you get one of these
new things happening like a proximity event or a touch

00:16:57.320 --> 00:17:02.760
or a key down or any of those things that's a new object
for each event and those new objects are immutable,

00:17:02.759 --> 00:17:08.990
you cannot edit those objects they are just
stand-alone value objects that tell you what happened.

00:17:08.990 --> 00:17:14.400
And UIEvents, you know, you can cancel UIEvents,
things happen and the state changes or the phone rings

00:17:14.400 --> 00:17:20.330
or something happens and those touches can be cancelled
and in the AppKit pretty much you don't get interrupted

00:17:20.329 --> 00:17:25.480
by phone calls on your computer very much those mouse
events and those other events can't be cancelled

00:17:25.480 --> 00:17:29.940
so you can choose not to handle them
but you're not going to get API access

00:17:29.940 --> 00:17:33.210
to just say OK, we'll pretend this never happened.

00:17:33.210 --> 00:17:38.039
There's also some touch support in the AppKit.

00:17:38.039 --> 00:17:43.859
Alright, UITouch and NSTouch both track information about
touch events so everything that's happening on the track pad

00:17:43.859 --> 00:17:50.740
on recent MacBook Pro models the AppKit can
find out about those via the NSTouch class.

00:17:50.740 --> 00:17:56.279
UITouch deals with an integrated sensor; the
phone has an integrated glass sensor on the front

00:17:56.279 --> 00:18:01.240
that when the user touches it the place that they're
touching is the actual coordinates in the screen.

00:18:01.240 --> 00:18:07.809
NSTouch you're sort of one step removed from it it
deals with opaque sensors so the track-pad, you know,

00:18:07.809 --> 00:18:11.659
you make a gesture here but you're not actually
touching anything on the screen so the focus goes

00:18:11.660 --> 00:18:16.380
to either the responder or it may
go to where the mouse cursor is,

00:18:16.380 --> 00:18:20.210
so there's a little sort of step
removed in dealing with that.

00:18:20.210 --> 00:18:28.289
Raleigh Ledet who is the Mr. Events
Wizard for the AppKit will be giving the User Events

00:18:28.289 --> 00:18:32.359
in Cocoa talk tomorrow -- wait
-- I hope tomorrow's Wednesday --

00:18:32.359 --> 00:18:37.759
tomorrow in Knob Hill at 3:30 so if you do want
to learn more about handling events directly

00:18:37.759 --> 00:18:43.019
on the desktop definitely go see Rolly
he'll give a great talk on user events.

00:18:43.019 --> 00:18:47.420
So let's talk a little bit about controls now.

00:18:47.420 --> 00:18:52.830
I promise this isn't all just me droning on up here about
the differences it gets a little more interesting later.

00:18:52.829 --> 00:18:56.879
UIControl and NSControl, these are
both the base class for control.

00:18:56.880 --> 00:19:01.430
So remember a control is something you tap on it
or something happens and it sends an action, right?

00:19:01.430 --> 00:19:08.230
They both send actions when directed but UIControls
you can have many actions each of which has a target

00:19:08.230 --> 00:19:13.319
and in NSControl you pretty much have 1 action and 1 target.

00:19:13.319 --> 00:19:18.279
And there are basically 3 forms of
the action selector you can have.

00:19:18.279 --> 00:19:23.869
In UIKit there's 1 that's just an action that gets
sent, there's 1 that tells you the sender of the action

00:19:23.869 --> 00:19:27.489
and then there's action forEvent
which is the sender and the UIEvent

00:19:27.490 --> 00:19:30.690
so you can do some multiplexing
based on what events came in.

00:19:30.690 --> 00:19:35.799
And in Interface Builder when you click
on a control, in this case a UI button

00:19:35.799 --> 00:19:41.710
there are all these different events having to do with
touch-drag and touch-entered and exited and things like that

00:19:41.710 --> 00:19:44.569
where you can find out about all these
things, and not only do you find out about all

00:19:44.569 --> 00:19:52.470
of these things you can send each one of those actions
to a different receiver, so many actions, many receivers.

00:19:52.470 --> 00:19:59.440
NSControl, this is the only action selector you get so
you get one that says, this is the action and who sent it.

00:19:59.440 --> 00:20:01.730
That action can be key-down, key-up, things like that.

00:20:01.730 --> 00:20:04.220
This is what it looks like in Interface Builder.

00:20:04.220 --> 00:20:11.140
The one exception to this in terms of getting more
than one action, NSTableView has a double action

00:20:11.140 --> 00:20:15.920
so when the user double-clicks on a non-editable
portion of a table view like a non-editable table cell

00:20:15.920 --> 00:20:21.769
or table column you'll get a double action and you'll
get an opportunity to handle that event as well

00:20:21.769 --> 00:20:24.930
so you can double-click on something
and it will tell you whether or not,

00:20:24.930 --> 00:20:27.310
you know, you'll get an action for a double-click.

00:20:29.579 --> 00:20:33.649
So when you're writing a Macintosh application
typically, you know, remember what happens in the UIKit,

00:20:33.650 --> 00:20:37.990
a lot of your applications are database driven or
table-driven the table view looks like this you tap

00:20:37.990 --> 00:20:45.579
on the table view and you get basically a zoomed in or
a detailed view of the data that represents that row

00:20:45.579 --> 00:20:48.789
that you've clicked on or that you tapped on -- I'm sorry.

00:20:48.789 --> 00:20:53.690
On a Macintosh, you know, there are a lot of
document-based applications and the user creates things

00:20:53.690 --> 00:20:59.130
with Text Edit they create things with Keynote they have
pictures that they've created with different applications

00:20:59.130 --> 00:21:06.110
or that they've pulled off of their phones or their cameras
and they can save these documents anyplace and there's a lot

00:21:06.109 --> 00:21:11.859
of support directly in the AppKit for document-based
applications, and the main class that takes care of a lot

00:21:11.859 --> 00:21:15.599
of this is the NSDocument class and then
the NSDocument controller mechanisms.

00:21:15.599 --> 00:21:19.759
And document-based apps basically the NSDocument
helps you out with the reading and writing of data,

00:21:19.759 --> 00:21:26.609
it helps you out with atomic saves and some simple
scripting stuff that's built into the AppKit and OS X.

00:21:26.609 --> 00:21:28.759
The atomic saves thing is really a big deal.

00:21:28.759 --> 00:21:35.500
When you're handling user's data you don't ever want
to lose the user's work, so when we save what we tend

00:21:35.500 --> 00:21:42.279
to do is we save in a location and then rename that save
over the old location and NSDocument takes care of a lot

00:21:42.279 --> 00:21:46.509
of the mechanics of that atomic saving for
you so that if something does go wrong.

00:21:46.509 --> 00:21:50.900
If everything goes right you save the document, the
user's happy, you're happy, everything works great.

00:21:50.900 --> 00:21:55.100
If something goes wrong like the user doesn't have write
access someplace or the file system's gone south on them

00:21:55.099 --> 00:21:57.309
or they've lost contact with a file server.

00:21:57.309 --> 00:22:03.299
If we save -- if something goes wrong there we want either
the old version or the new version to appear on disk

00:22:03.299 --> 00:22:07.639
but we still want the user to be able to save someplace
else with the version that they have in memory,

00:22:07.640 --> 00:22:10.960
and NSDocument helps out a lot
with those mechanisms as well.

00:22:10.960 --> 00:22:14.009
To show us a little bit about how all this
works I'm going to ask Kevin Perry to come up.

00:22:14.009 --> 00:22:20.379
Kevin works on the Cocoa Frameworks Team and he has some
demos on just creating a document-based app right in Xcode.

00:22:20.380 --> 00:22:27.660
>> Kevin: Thank you, so here we are in Xcode and we're
just going to start off by creating a new Cocoa application

00:22:27.660 --> 00:22:37.930
that is document-based and we will just call it Demo App
for this demo and we're just going to start off building

00:22:37.930 --> 00:22:45.080
and running it to show you just how much and how
quickly you can build your own applications in Cocoa.

00:22:45.079 --> 00:22:53.079
Cocoa really makes the simple things and common things
that you do in your applications very simple to do

00:22:53.079 --> 00:22:58.379
and you can focus on the more complicated
and more interesting things in your own work.

00:22:58.380 --> 00:23:06.840
So here we have our demo app running and we see an empty
document window up here, there's not really much there but,

00:23:06.839 --> 00:23:15.199
you know, hey, we have a document window and we can create
more document windows and close them and we can bring

00:23:15.200 --> 00:23:22.750
up a Save Panel here and attempt to save,
you know, we haven't implemented saving yet

00:23:22.750 --> 00:23:30.920
but not only do we have the Save Panel we have proper
error reporting when the save does not work properly

00:23:30.920 --> 00:23:39.720
and we have Open Panel as well and we properly can't open
anything here because we haven't implemented that yet.

00:23:39.720 --> 00:23:45.069
So that's a lot of behaviors that you can
get for free right out of the box with Cocoa.

00:23:45.069 --> 00:23:50.669
All these behaviors, for the most part, are
handled by NSDocuments, NSDocument Controller

00:23:50.670 --> 00:23:57.769
and NSWindow Controller various classes in AppKit and
for the most part you'll just use these classes straight

00:23:57.769 --> 00:24:01.789
out of the box they will work for you
and do what you need for the most part.

00:24:01.789 --> 00:24:06.670
But in those rare cases where you need to
have custom behaviors you can, of course,

00:24:06.670 --> 00:24:11.810
subclass those classes and provide your own implementation.

00:24:11.809 --> 00:24:15.589
So we'll go back to Chris for a little
bit more about NSDocument we'll build off

00:24:15.589 --> 00:24:19.289
of this in later demos but for now back to him.

00:24:20.359 --> 00:24:21.500
>> Chris: Thank you sir.

00:24:21.500 --> 00:24:28.730
So, absolutely no code in that, go to Xcode,
Create a New, document-based application

00:24:28.730 --> 00:24:32.950
and pretty much you're already getting a number of default
behaviors out of it, you know, so the windows get staggered,

00:24:32.950 --> 00:24:38.920
the untitled stuff appears, Cocoa really helps you out with
a lot of the basic stuff so you can concentrate on your app.

00:24:38.920 --> 00:24:45.100
If you're going to override things you need to actually get
data in and out of the disk, so NSDocument has some APIs

00:24:45.099 --> 00:24:50.949
for reading your document, read from URL of type
error and this is a pattern that you see a lot

00:24:50.950 --> 00:24:54.200
in Cocoa you saw it in CocoaTouch probably a little bit.

00:24:54.200 --> 00:24:59.420
The NSError contains anything where we think that something
can go wrong we'll try to give you an NSError return

00:24:59.420 --> 00:25:02.080
and that NSError will always contain basically if it's

00:25:02.079 --> 00:25:06.279
in the Cocoa domain it'll always contain something
that's suitable for presentation to the user,

00:25:06.279 --> 00:25:12.079
and if we've done our job right that means that you'd
probably never have to see Error-43 again or anything

00:25:12.079 --> 00:25:15.779
like that, really obscure error
messages that don't help the user out.

00:25:15.779 --> 00:25:18.799
The other one is Read From File Wrapper of Type Error.

00:25:18.799 --> 00:25:24.470
An NSFile wrapper is a class that basically
encapsulates it abstracts out a hierarchy of objects

00:25:24.470 --> 00:25:30.069
and that hierarchy can wind up being written out
to disk as a directory structure or you can flatten

00:25:30.069 --> 00:25:33.629
in NSData there's a lot of flexibility
with an NSFile wrapper for editing documents

00:25:33.630 --> 00:25:35.310
and we'll take advantage of that in a minute.

00:25:35.309 --> 00:25:40.649
And a Read From Data of Type Error, if for somehow in
your application you got an NSData that you want to turn

00:25:40.650 --> 00:25:45.210
into a full NSDocument in an instance
you can do that with this method here.

00:25:45.210 --> 00:25:49.590
The other half is writing stuff out,
being able to write to URL of Type Error.

00:25:49.589 --> 00:25:52.899
You can get a file wrapper of the types of the NSDocument

00:25:52.900 --> 00:25:58.140
if you produce an NSFile wrapper this is how you'd
get the NSFile Wrapper Instance out of that document

00:25:58.140 --> 00:26:00.850
and Data of Type Error so there are a symmetric set of APIs.

00:26:00.849 --> 00:26:04.289
There are some other things that Kevin's
going to show you now in actually filling

00:26:04.289 --> 00:26:11.309
in that document-based application
to actually save things out.

00:26:11.309 --> 00:26:19.299
>> Kevin: Alright, so we are going to now build off of
this empty project and build a very basic RTFD Editor.

00:26:19.299 --> 00:26:26.409
RTFD is a file type related to RTF
or Rich Text Format that also allows

00:26:26.410 --> 00:26:31.460
for embedding various arbitrary files such as images.

00:26:31.460 --> 00:26:38.819
So at the end of this demo we're going to have a simple
but powerful rich text editor that supports image embedding

00:26:38.819 --> 00:26:42.299
and will have full save and load behavior.

00:26:42.299 --> 00:26:52.079
So we'll start off we'll show you how easy it is to
enable Garbage Collection we'll use that for this demo

00:26:53.299 --> 00:26:57.589
because that will just simplify things for our purposes.

00:26:57.589 --> 00:27:04.029
So here we find the Garbage Collection setting
and we just set that to Required -- close that --

00:27:04.029 --> 00:27:10.279
and now we're going to go in and
start developing our interface.

00:27:10.279 --> 00:27:17.759
Here we see this familiar empty window that represents
our document contents, so we're going to come over here

00:27:17.759 --> 00:27:25.559
to the Interface Builder Library, which you should be
familiar with if you've made applications for the iPhone,

00:27:25.559 --> 00:27:32.889
of course, and we're dragging in here in NSTextView
and you see here that we've got a scroll-view already

00:27:32.890 --> 00:27:39.850
that this text-view is embedded in so that's something
that Interface Builder sets up for you automatically.

00:27:39.849 --> 00:27:43.189
We're going to set this to size to fit to the window.

00:27:43.190 --> 00:27:51.640
Now, we want to make sure that this text-view remains
the same size as the window so we come in here

00:27:51.640 --> 00:27:57.930
to the Size Inspector and enable these auto-resizing flags.

00:27:57.930 --> 00:28:04.029
You see here a little preview of that and we can
Command-click here in Interface Builder and see that live.

00:28:04.029 --> 00:28:12.019
So now we're going to click here, drill down to
our NSTextView and go to its Attributes Inspector.

00:28:12.019 --> 00:28:16.129
And you see there are a lot of various
features that you can enable or disable

00:28:16.130 --> 00:28:19.240
on NSTextView with the click of a check box.

00:28:19.240 --> 00:28:24.559
NSTextView is really one of the gems of
Cocoa you'll find it in most applications.

00:28:24.559 --> 00:28:35.159
Just because there are so many features that you can get for
free that are common and expected now on Mac applications.

00:28:35.160 --> 00:28:43.360
There's things like Rich Text, Undo, Redo, Graphics, Image
Editing, Non-Contiguous Layout which lets you display large,

00:28:43.359 --> 00:28:50.479
very large documents very efficiently, Find
Panel, Font Panel, Rulers, and so forth,

00:28:50.480 --> 00:28:56.680
but we're just going to enable graphics
here for now so we click this check box.

00:28:56.680 --> 00:29:04.450
Now we need some way to let our documents talk to our
text-view and we need some interaction there so we're going

00:29:04.450 --> 00:29:07.390
to come in here to the My Document header.

00:29:07.390 --> 00:29:09.550
Make this monitor big.

00:29:09.549 --> 00:29:15.139
And just as a disclaimer we're going
to take a little shortcut here,

00:29:15.140 --> 00:29:21.830
normally you'd have a proper model view controller set
up for this but we're just going to connect our model,

00:29:21.829 --> 00:29:26.309
which here is, in this case it's the document's
subclass straight up to our view, the text-view.

00:29:26.309 --> 00:29:36.490
So we're going to create an IV outlet in NSTextView
like so, we'll come back here to Interface Builder

00:29:36.490 --> 00:29:44.390
and here in the NIB the file's owner is what represents
our NSDocument Instance so we Control-drag here

00:29:44.390 --> 00:29:48.900
from the files owner to the outlet and we
see here that there's our text-view outlet

00:29:48.900 --> 00:29:53.800
that we just added so we connect it like so and we save.

00:29:55.339 --> 00:30:00.559
Come back here to Xcode and go to the
implementation of our document class

00:30:00.559 --> 00:30:07.259
and we'll implement saving and loading of our document now.

00:30:07.259 --> 00:30:13.609
Here we see the data of type and read from
data methods that Chris pointed out earlier

00:30:13.609 --> 00:30:23.119
and for most cases this would be a sufficient place to
implement this but since RTFD is actually a package type

00:30:23.119 --> 00:30:31.729
or a bundle type we can't easily represent it
with just NSData we want to use an NSFile wrapper

00:30:31.730 --> 00:30:39.589
so we're actually going to instead of overriding
these we're going to override write ToURL

00:30:39.589 --> 00:30:45.730
of Type Error and here we'll implement this like so.

00:30:45.730 --> 00:30:50.140
Here's our text-view we're grabbing its
text-storage and building an Attributes Dictionary

00:30:50.140 --> 00:30:55.259
with the RTFD Text Document type
as the document type attribute.

00:30:55.259 --> 00:30:59.359
Then we're asking the Text Storage to create
a file wrapper for us with the entire contents

00:30:59.359 --> 00:31:02.809
of the file and the attributes that we have here.

00:31:02.809 --> 00:31:11.319
And so that gives us back an RTFD file wrapper which we can
then tell it to write to disk and we're telling it to do

00:31:11.319 --> 00:31:13.939
that atomically as well so we have some safe behavior there.

00:31:13.940 --> 00:31:17.320
And we just return whether or not it succeeded.

00:31:17.319 --> 00:31:25.210
Implementing document loading is just
as simple we override Companion Read

00:31:25.210 --> 00:31:31.630
from URL Type of Error and we implement it like so.

00:31:31.630 --> 00:31:37.770
Again, we're building a dictionary with the RTFD document
type and we're using NSAttributedString here instead

00:31:37.769 --> 00:31:45.990
of NSFile Wrapper directly because NSAttributedString
already recognizes and understands when it sees an RTFD file

00:31:45.990 --> 00:31:53.019
on disk it knows how to use NSFileWrapper
to load that document.

00:31:53.019 --> 00:31:57.879
So here we've created the attributed string
and we return whether or not that succeeded.

00:31:57.880 --> 00:32:03.340
At the point of document loading our interface
hasn't been instantiated and displayed to the user

00:32:03.339 --> 00:32:08.039
yet that happens here in Window Controller Did Load NIB.

00:32:08.039 --> 00:32:12.339
We get this notification after the NIB has loaded.

00:32:12.339 --> 00:32:16.279
So we need somewhere to push this
attributed string into our text-view.

00:32:16.279 --> 00:32:20.690
We need just a simple instance variable to hold on to that,

00:32:20.690 --> 00:32:25.240
so here we call this NSAttributed
String an Attributed String.

00:32:25.240 --> 00:32:30.390
And here in Window Controller Did Load NIB

00:32:30.390 --> 00:32:37.990
if we have successfully created one we just take the
text-storage and set the attributed string on it.

00:32:37.990 --> 00:32:42.640
Now that's all the code we need to write
for this application just 10 or 15 lines

00:32:42.640 --> 00:32:47.560
of code here not very complicated, but there's one
more thing that we need to do to tell NSDocument

00:32:47.559 --> 00:32:51.700
about the file types that we want
our application to understand.

00:32:51.700 --> 00:32:57.340
So here we open up the application's
target window and go to the Properties tab.

00:32:57.339 --> 00:33:06.679
Here we see a table of all the various document types that
our application understands and we're going to set the UTI

00:33:06.680 --> 00:33:13.370
or the Uniform Type Identifier
to the proper con.apple.rtfd UTI.

00:33:13.369 --> 00:33:18.500
Now the Uniform Type Identifier abstracts all
this information about file type extensions,

00:33:18.500 --> 00:33:23.990
Mime types and OS types so we can actually delete all
those entries, but the last thing we need to do is tell it

00:33:23.990 --> 00:33:29.210
that it has actually a package format not a flat file there.

00:33:29.210 --> 00:33:35.809
So we'll go ahead and build and run again
and we will demonstrate this working.

00:33:35.809 --> 00:33:40.009
So I'll start typing something here.

00:33:40.009 --> 00:33:44.589
[ Silence ]

00:33:44.589 --> 00:33:51.709
>> Kevin: And you see here the Close button as I've
typed now has this dot in the middle of it indicating

00:33:51.710 --> 00:34:01.210
that the document's dirty and that there are unsafe changes
in there, and so when I try to click on that it informs me

00:34:01.210 --> 00:34:07.579
of these unsafe changes and asks me if I want
to save them or not because they'll have undo,

00:34:07.579 --> 00:34:15.029
redo as you saw that was one of the things that we left
enabled in our NSTextView and we also have, of course,

00:34:15.030 --> 00:34:17.980
Rich Text Editing so we can change the font.

00:34:17.980 --> 00:34:24.800
And you see, also, I have a little typo here and
this text-view has automatically found this typo

00:34:24.800 --> 00:34:30.990
for me and I can correct it just like that.

00:34:30.989 --> 00:34:38.409
All of this -- we haven't dealt with any of this code on
other platforms this could include a lot of extra work.

00:34:38.409 --> 00:34:49.569
So now let's see Saving and Loading working we will
go to our documents here and save a document off.

00:34:49.570 --> 00:34:57.539
It seems like it works let's -- it's the moment of truth
here we'll try and open it back up and there you go saving

00:34:57.539 --> 00:35:03.130
and loading works just fine just 10 or 15
lines of code and you see how simple it is

00:35:03.130 --> 00:35:07.490
to get started right away with
your own applications in Cocoa.

00:35:07.489 --> 00:35:10.239
Back to Chris we'll find out more
about NSDocument a little bit

00:35:10.239 --> 00:35:15.009
and other features that we'll add to this application next.

00:35:15.010 --> 00:35:22.160
[ Applause ]

00:35:22.159 --> 00:35:27.429
>> Chris: So, yeah, 10 lines of code and a whole bunch
of built-in behavior that's already provided for you

00:35:27.429 --> 00:35:31.039
by the AppKit so there's a lot of features
there that you don't have to even worry about.

00:35:31.039 --> 00:35:37.529
NSDocument also supplies a lot of other behaviors
as well, Autosaving, so if you're like me

00:35:37.530 --> 00:35:44.140
and you're saving you have the Command S twitch on the
keyboard, you know, every few seconds you're always saving.

00:35:44.139 --> 00:35:49.739
If you don't have that twitch you can configure your
documents to autosave automatically on an interval you set.

00:35:49.739 --> 00:35:54.879
Alright, so you can save your users some trouble
if, you know, the power goes out or if, you know,

00:35:54.880 --> 00:36:01.420
heaven forbid your app crashes something like they'll have
an autosave version of a fairly recent version of that data.

00:36:01.420 --> 00:36:06.380
There's also some features in there that help
you print, so, you can have printers hooked

00:36:06.380 --> 00:36:09.420
up to your computer as well NSDocument helps support that.

00:36:09.420 --> 00:36:14.090
The Change Management with the little dot
and tracking whether or not it's dirty

00:36:14.090 --> 00:36:16.390
or things like that and Error Presentation, right?

00:36:16.389 --> 00:36:23.219
All of the sheets and things when something went wrong or
all of that is all built-in to the AppKit so you'll be able

00:36:23.219 --> 00:36:28.230
to do some very rich behaviors
with pretty much no code at all.

00:36:28.230 --> 00:36:33.630
One of the most intuitive ways to be able to interact with
things on the Macintosh, you know, you've been dragging,

00:36:33.630 --> 00:36:38.980
dropping files to copy them in the Finder probably
since the day you opened up your Macintosh.

00:36:38.980 --> 00:36:44.570
Drag and Drop is supported in the AppKit you generally
have a source-view and a destination-view right,

00:36:44.570 --> 00:36:50.500
so you're dragging from one place to another and there's
an operation involved in the middle there alright

00:36:50.500 --> 00:36:55.260
so the operation has to do with what it
means to drag from point A to point B.

00:36:55.260 --> 00:36:58.190
The operations are pretty straightforward.

00:36:58.190 --> 00:37:03.300
There are operations for Copy, Link, Move and, basically,

00:37:03.300 --> 00:37:07.490
what you're doing here is telling
us exactly what will happen

00:37:07.489 --> 00:37:14.969
when a drop occurs is it a copy is it a move what
do you support from the source side of the drag?

00:37:14.969 --> 00:37:20.000
The only method you really have to implement in order
to get this is Dragging Source Operation Mask for Local

00:37:20.000 --> 00:37:23.760
and the dragging source API here gives you an opportunity

00:37:23.760 --> 00:37:28.320
for your custom view subclass to
return what operations you support.

00:37:28.320 --> 00:37:33.730
The ForLocal part tells you whether or not this is a
drag within your application or whether it's a drag

00:37:33.730 --> 00:37:40.280
to another application, so you find out whether or
not this is an intra or an inter-application drag.

00:37:40.280 --> 00:37:44.790
The destination API there are a few other source
APIs about updating the images as they're dragged

00:37:44.789 --> 00:37:48.630
and you can customize what all of that
looks like but these are the basics.

00:37:48.630 --> 00:37:55.150
The destination API is interesting it's draggingEntered,
draggingUpdated, draggingExited, prepareForDragOperation,

00:37:55.150 --> 00:38:00.619
perform and conclude and these are where in your destination
you can handle all the different events associated

00:38:00.619 --> 00:38:01.690
with the drag.

00:38:01.690 --> 00:38:07.639
And that sender's how you find out, you know, you can find
out what operations the sender supports and things like that

00:38:07.639 --> 00:38:10.779
by querying that via the NSDragging Info protocol.

00:38:10.780 --> 00:38:16.220
All of this stuff is pretty straightforward but there are
a lot of classes in the kit that implement higher-level API

00:38:16.219 --> 00:38:20.649
to make it easier to deal with Drag and
Drop and we'll see that in a minute.

00:38:20.650 --> 00:38:26.460
One of the things I didn't talk about in the earlier section
was table views and there are actually 2 classes UITableView

00:38:26.460 --> 00:38:29.970
in the UIKit and NSTableView in the AppKit.

00:38:29.969 --> 00:38:34.649
They both have very similar APIs one of them has a
delegate, they both, actually they both have delegates;

00:38:34.650 --> 00:38:38.260
they both have datasources so that
API should be very familiar to you.

00:38:38.260 --> 00:38:45.430
UITableView mainly because of the constraint of the size
of the screen, has many rows and pretty much 1 column

00:38:45.429 --> 00:38:48.699
where you're just going through a
single column of information right?

00:38:48.699 --> 00:38:52.230
NSTableView -- hey, you know, we have 30 inch
monitors hooked up to some of our computers

00:38:52.230 --> 00:38:58.300
or 24 inch monitors it's a very wide experience and
so you can actually display many rows and many columns

00:38:58.300 --> 00:39:02.430
so you get much more -- an actual
tabular interface in an NSTableView.

00:39:02.429 --> 00:39:08.149
If you want you can set it to 1, you know many
rows in 1 column but it doesn't happen often.

00:39:08.150 --> 00:39:16.950
UITableView deals in UITableView cells for individual items,
and NSTableView deals with objects and it fills in NSCells

00:39:16.949 --> 00:39:22.639
for individual items so that the model for
what you're asked to provide as a datasource

00:39:22.639 --> 00:39:26.859
of an NSTableView is a little different
than what we see with UITableView.

00:39:26.860 --> 00:39:30.320
So remember what happens with UITableView,
you know, you've got your data model

00:39:30.320 --> 00:39:34.700
and the first thing we'll do is we'll ask Number of
Sections in TableView, how many things are in there.

00:39:34.699 --> 00:39:39.149
And then we'll turn around and we'll ask
for the number of rows in each section,

00:39:39.150 --> 00:39:41.510
so for each of those sections we'll
find out how many rows they're in.

00:39:41.510 --> 00:39:48.630
And then eventually you get asked to provide
as a return type its UITableView Cell,

00:39:48.630 --> 00:39:55.579
TableView cell for Row at Index Path and you're actually
creating a view and filling that view in with the data

00:39:55.579 --> 00:39:59.829
and then that view gets around it put
into the view sub-tree so if you look

00:39:59.829 --> 00:40:02.519
at this you'll actually see views in there right?

00:40:02.519 --> 00:40:05.550
UITableView cells are a full UIView subclass.

00:40:05.550 --> 00:40:10.740
The AppKit does things a little bit differently partly
because you've just got so much data that you could do

00:40:10.739 --> 00:40:14.479
if you wind up with 600,000 views that
kind of slows things down a little bit.

00:40:14.480 --> 00:40:20.550
So instead NSTableView uses an approach
that involves a class called an NSCell

00:40:20.550 --> 00:40:25.560
So the first thing we're going to do is we'll ask you number
of rows in table view, how many rows are in this table.

00:40:25.559 --> 00:40:29.860
In this case what I have here is a datasource
of restaurants that I like and I'm going to try

00:40:29.860 --> 00:40:32.519
and display them here in this table view.

00:40:32.519 --> 00:40:37.769
The next think we do is we go to the table column
the table view goes to the table column and asks it

00:40:37.769 --> 00:40:41.360
for a cell that's appropriate for the
type of data it's going to be displaying.

00:40:41.360 --> 00:40:50.710
In this case we have an NSTextField cell and this cell,
basically, gets filled in when we call your datasource.

00:40:50.710 --> 00:40:56.400
You'll get table view object value for table
column row and you'll notice that returns an ID,

00:40:56.400 --> 00:41:02.630
that ID is the actual object that represents
that entry in the table column and row.

00:41:02.630 --> 00:41:09.130
And the idea here is in this case it's an NSString
and we're going to fill out that cell in the NSString

00:41:09.130 --> 00:41:13.950
and then we're going to take a snapshot of that cell
with the NSString in it and we're going to display that,

00:41:13.949 --> 00:41:17.239
we're going to stamp it into the
position into the NSTableView.

00:41:17.239 --> 00:41:24.369
And then we're going to do that for
every single item in that column, right?

00:41:24.369 --> 00:41:26.789
It happens a lot faster than this.

00:41:26.789 --> 00:41:31.420
So the next thing we do is now we're going to
go, in this case, the table column parameter

00:41:31.420 --> 00:41:36.250
that you were getting called with for each of those
things was the Restaurant column now what we're going

00:41:36.250 --> 00:41:40.000
to do is we're going to go and get a cell for
the next column which is the Rating column.

00:41:40.000 --> 00:41:44.000
And in this case what I did at Interface Builder
was dragged out what's called a Level Indicator cell

00:41:44.000 --> 00:41:47.630
and we provide a number of these
cells built-in to the AppKit.

00:41:47.630 --> 00:41:56.829
The Level Indicator is a thing that's basically a discrete
or continuous display for either levels or capacity,

00:41:56.829 --> 00:41:59.139
things like that and you can set a
bunch of different parameters on.

00:41:59.139 --> 00:42:02.559
In this case I had it set to what's
called Rating Mode and that's a fancy name

00:42:02.559 --> 00:42:05.029
for drawing how many stars appears in here.

00:42:05.030 --> 00:42:12.060
So I've assigned ratings to each of these
restaurants and now what happens is we'll return the 3

00:42:12.059 --> 00:42:14.199
or the 4, the NS number that represents it.

00:42:14.199 --> 00:42:19.539
When that hits that cell it's going to get
reformatted every time table view object value

00:42:19.539 --> 00:42:26.960
for table column row gets called and that's going to
get filled in with the various pictures of the stars.

00:42:26.960 --> 00:42:29.409
Alright, and if I don't give my work cafeteria

00:42:29.409 --> 00:42:33.230
and my mother's cooking the same rating
I'm in a lot of trouble in both places.

00:42:33.230 --> 00:42:39.480
So this is what it looks like when it's all filled in
right, and this use of NS cells allows us to be able

00:42:39.480 --> 00:42:45.199
to display just really wide, really large amounts of data
very, very quickly because what we don't have are a lot

00:42:45.199 --> 00:42:48.269
of heavyweight NSViews sitting in that table.

00:42:48.269 --> 00:42:53.659
So here are a bunch of the different cells there
are, you know, comma box cells, check boxes,

00:42:53.659 --> 00:42:59.039
pop-ups so a lot of the common things that you would put
in tables, you know, Boolean values might be represented

00:42:59.039 --> 00:43:01.619
by check boxes, things like that, these are all built-in.

00:43:01.619 --> 00:43:04.569
There's a custom cell class so if you
write your own you can still drag them

00:43:04.570 --> 00:43:09.190
out in Interface Builder to assign them in the table view.

00:43:09.190 --> 00:43:15.500
Kevin's going to show you just how easy it is
to use NSTableView as part of this RTFD Editor.

00:43:18.460 --> 00:43:24.349
>> Kevin: So we're going to return to our RTFD
Editor application here we're going to enhance it

00:43:24.349 --> 00:43:30.949
with an Image Library so that we can put our images
directly from our application into our documents,

00:43:30.949 --> 00:43:37.339
and so we're going to use NSTableView
to demonstrate how to do this.

00:43:37.340 --> 00:43:44.930
So let's start off by creating a new controller class
subclass of NSObject we'll call it Image Library Controller

00:43:44.929 --> 00:43:51.649
and it will be responsible for populating our table view.

00:43:51.650 --> 00:44:03.170
So we have it implement here the NSTableView DataSource
Protocol and we will now go over to our main menu --

00:44:03.170 --> 00:44:12.369
close this NIB here -- our main menu NIB and we'll
instantiate the Image Library Controller here.

00:44:12.369 --> 00:44:21.730
So we find a custom object, drag that out and
change its class to Image Library Controller.

00:44:21.730 --> 00:44:32.639
And now we need some place to put our table view that we'll
have so we grab a panel, which is a special type of window.

00:44:32.639 --> 00:44:40.319
Now, since this is a garbage collected application we need
to make sure that there are references to these objects

00:44:40.320 --> 00:44:45.720
so that they don't -- they're not collected
by the background collector thread.

00:44:45.719 --> 00:45:01.959
So what we'll do here is we'll just add an NSPanel IB outlet
called Panel and connect that -- semi-colon -- thank you --

00:45:01.960 --> 00:45:07.179
connect that like so and we'll make the Image
Library Controller the delegate of our application.

00:45:07.179 --> 00:45:13.989
Another disclaimer this is just a shortcut for demo purposes
you'll have in your own applications window controllers

00:45:13.989 --> 00:45:17.649
and view controllers and so forth to
manage the lifetime of these objects.

00:45:17.650 --> 00:45:25.840
So now that we have our window here
we will finally create our table view.

00:45:25.840 --> 00:45:34.090
We will do the same thing we did before with the text-view,
again, it's already embedded in a scroll-view and we want

00:45:34.090 --> 00:45:41.380
that to auto-resize like so in the window and
we'll click the Drill Down to our table view.

00:45:41.380 --> 00:45:47.200
Now since this is going to be an image library we're
going to be containing displaying images a row height

00:45:47.199 --> 00:45:52.359
of 17 isn't going to be sufficient so
we'll go ahead and bump that up to say 100.

00:45:52.360 --> 00:45:58.470
And in the attributes we will make
this a single column with no headers.

00:45:58.469 --> 00:46:02.730
We also need to connect this to our Image Library Controller

00:46:02.730 --> 00:46:10.130
and now here you see the datasource outlet
which is what we want to connect to.

00:46:10.130 --> 00:46:16.460
So by default you see Interface Builder
creates an NSTableView with a text-cell.

00:46:16.460 --> 00:46:20.909
We want an image cell, obviously,
so we just drag that right in

00:46:20.909 --> 00:46:24.730
and here you see a good representative example
of what our table view would look like.

00:46:24.730 --> 00:46:30.869
So now we have dropped an NSImage Cell in this column.

00:46:30.869 --> 00:46:39.730
The datasource methods are going to expect an NSImage
to be returned instead of, for example, an NSString.

00:46:40.900 --> 00:46:42.460
So now we'll go ahead and save that.

00:46:42.460 --> 00:46:46.019
That's all we need to do for our interface.

00:46:46.019 --> 00:46:52.469
So now we have our controller object here,
we have our view set-up, we need now a model.

00:46:52.469 --> 00:47:00.279
We're just going to have a simple NSMutable Array for now
and call it Images, and now we'll come to the implementation

00:47:00.280 --> 00:47:06.720
of our Image Library Controller and in the init method
we will populate that array, here we're creating it

00:47:06.719 --> 00:47:12.819
and we're enumerating the contents of a particular
directory here on our desktop and for each file

00:47:12.820 --> 00:47:16.930
in that directory we're attempting
to create an NSImage with it.

00:47:16.929 --> 00:47:22.359
If that's succeeded we'll add it
to our array, pretty simple.

00:47:22.360 --> 00:47:26.190
But now we need to give these images to the table view

00:47:26.190 --> 00:47:31.539
and we do that by implementing the 2 NSTableView
datasource methods that Chris already talked about.

00:47:31.539 --> 00:47:40.079
So the first is number of rows in table view, well this is
really simple we just return images count we have X number

00:47:40.079 --> 00:47:43.949
of images we want X number of rows in our table view.

00:47:43.949 --> 00:47:57.919
And the next one is TableView ObjectValue for Table
Column and Row and we return just images objects at index

00:47:59.199 --> 00:48:06.029
with the given row we just have a single table
column so we can ignore that parameter there.

00:48:06.030 --> 00:48:12.730
So let's go ahead and run and here you see
a bunch of images in our library already.

00:48:12.730 --> 00:48:20.440
Just, again, a few lines of code and we have
created a fully working table view datasource.

00:48:20.440 --> 00:48:26.280
But currently we can't really make it do
anything we need some way to get these images

00:48:26.280 --> 00:48:29.060
from the table view into our document here.

00:48:29.059 --> 00:48:34.690
Chris also talked about drag and drop that's
probably the most intuitive user interface for this

00:48:34.690 --> 00:48:41.440
so we'll show you just how easy this is to implement with
NSTableView, which abstracts a lot of the dragging source

00:48:41.440 --> 00:48:47.320
and destination -- or the dragging
source API that you have to implement.

00:48:47.320 --> 00:49:00.039
So back here in our Image Library Controller we will
override table view write rows with indexes to Pasteboard.

00:49:00.039 --> 00:49:05.360
So here we have to -- we're supposed
to write our selected image

00:49:05.360 --> 00:49:08.970
to the pasteboard so it can be read at the destination.

00:49:08.969 --> 00:49:14.779
And so the first thing we do is we take the keyboard,
the NSPasteboard parameter that we're given here

00:49:14.780 --> 00:49:19.440
and clear its contents so we have
a clean slate to start out at.

00:49:19.440 --> 00:49:31.110
And then we tell it to write objects and give it NSArray
with a single object which is the image at the first

00:49:31.110 --> 00:49:38.250
and only index in this row indexes index set like so.

00:49:38.250 --> 00:49:44.869
Now write objects returns Yes or No for success
and we need to do the same, as you can see here,

00:49:44.869 --> 00:49:50.109
from this datasource method so we return what it returns.

00:49:50.110 --> 00:50:00.720
We build and run, once again, and you can see that drag and
drop is just that simple it's a 2 line implementation here

00:50:00.719 --> 00:50:07.069
in our datasource and we have fully
working drag and drop into our NSTextView.

00:50:07.070 --> 00:50:12.059
So another testament to the power
of Cocoa and ease of use there.

00:50:12.059 --> 00:50:15.009
Back to Chris for more.

00:50:15.010 --> 00:50:20.590
[ Applause ]

00:50:20.590 --> 00:50:26.079
>> Chris: So, you know, both table view and the text-view
implement a lot of the dragging methods for you so,

00:50:26.079 --> 00:50:31.299
you know, you notice when you drag on the table and in the
text-view the insertion point moves around to represent

00:50:31.300 --> 00:50:36.640
where in the text those images are going to be dragged
-- dropped rather, so there's a lot of built-in behavior,

00:50:36.639 --> 00:50:41.989
again, that you're getting for the
kit absolutely free at no cost to you.

00:50:41.989 --> 00:50:47.269
Another interface that we use a lot is in the Finder this
is just a search window there's nothing in it right now

00:50:47.269 --> 00:50:51.179
but when you type up in that search
field, you know, Spotlight goes through

00:50:51.179 --> 00:50:57.519
and it uses the indexing information that's stored on your
hard drive, on your user's hard drives and returns results

00:50:57.519 --> 00:51:03.259
in there it puts the document icons into the search window
to find out what meets that criteria and that's all based

00:51:03.260 --> 00:51:08.410
on the Spotlight APIs that are in
Foundation and in MetaDataQuery Framework.

00:51:08.409 --> 00:51:13.460
But the Foundation versions of these classes
are NSMetaDataQuery and NSMetaDataItem,

00:51:13.460 --> 00:51:20.090
so these are basically the way that you can programmatically
be a client of the search APIs in your application right?

00:51:20.090 --> 00:51:25.480
Remember you user can save stuff any place in the file
system so they may have trouble finding things occasionally

00:51:25.480 --> 00:51:30.039
or you may have trouble finding things or you may want to
find things for them and Kevin's going to show you this

00:51:30.039 --> 00:51:33.019
in a minute but the main class is NSMetaDataQuery.

00:51:33.019 --> 00:51:36.860
You program a query by giving it a predicate
basically as something that evaluates to true

00:51:36.860 --> 00:51:41.440
or false that defines the criteria that you want
to use for the search and it supports grouping,

00:51:41.440 --> 00:51:44.329
which is really interesting, so you can group by type.

00:51:44.329 --> 00:51:49.380
It's an asynchronous API right because, you know,,
you've got 320G hard drives, 500G hard drives,

00:51:49.380 --> 00:51:51.910
terabytes worth of information in places.

00:51:51.909 --> 00:51:55.779
So the search starts and then it has to crawl through
the index and find out where all that stuff is.

00:51:55.780 --> 00:51:59.370
There's a delegate API that calls
back and says, hey, I have results.

00:51:59.369 --> 00:52:05.319
What those results are NSMetaDataItems and those
items are not actually the files themselves

00:52:05.320 --> 00:52:07.380
but there's a lot of information about those files.

00:52:07.380 --> 00:52:13.809
Things like when it was last opened, when it was
last moved, the contents changed, the, you know,

00:52:13.809 --> 00:52:19.340
where it came from that kind of things, a lot of
information in there including the path to the file itself.

00:52:19.340 --> 00:52:21.650
But, again, it's not the file itself.

00:52:21.650 --> 00:52:26.519
There are also some nifty features about
NSMetaDataQuery that make it very easy to program with

00:52:26.519 --> 00:52:33.070
and it'll actually let us get rid of some code,
so Kevin's got an example of that as well.

00:52:35.000 --> 00:52:42.960
>> Kevin: Alright, so we'll return here to this init
method where we have populated our array of images.

00:52:42.960 --> 00:52:51.440
Now, if your user wants to be able to find images
in, for example, various locations on the file system

00:52:51.440 --> 00:53:00.929
or images with particular properties or other meta-data
about the images you would have to do a lot of work

00:53:00.929 --> 00:53:07.480
on this it would get a lot more complicated
very quickly but we can use NSMetaDataQuery,

00:53:07.480 --> 00:53:13.010
use Spotlight to make that a very simple thing to implement.

00:53:13.010 --> 00:53:19.470
So we're going to come back here to the header
or our Image Library Controller and we're going

00:53:19.469 --> 00:53:27.049
to swap out the array for an MSMetaDataQuery.

00:53:27.050 --> 00:53:34.470
We're actually going to add, right now, over here,
a property for it for reasons you'll see shortly.

00:53:38.880 --> 00:53:41.010
And we'll need to synthesize that here as well.

00:53:41.010 --> 00:53:45.980
[ Silence ]

00:53:45.980 --> 00:53:53.400
>> Kevin: Alright, so now we can actually delete
all of this code and we'll replace it with this.

00:53:53.400 --> 00:53:59.269
We're simply instantiating an NSMetaDataQuery
and we just set a predicate

00:53:59.269 --> 00:54:03.880
which will tell the query which
kinds of files we want to match.

00:54:03.880 --> 00:54:10.490
In this case we are finding any files
whose content type matches image,

00:54:10.489 --> 00:54:16.639
so any image types that the system recognizes will match.

00:54:16.639 --> 00:54:22.969
But we'll limit the search scopes to the single
directory that we were searching before for this demo,

00:54:22.969 --> 00:54:28.750
and then we start the query to start getting the results.

00:54:28.750 --> 00:54:38.389
So NSMetaDataQuery has a results method that you can
call to get an array of all of the files that it finds.

00:54:38.389 --> 00:54:45.789
But this results array actually contains instances
of NSMetaDataItem which is a wrapper class around all

00:54:45.789 --> 00:54:49.829
of the meta-data that you might be interested
in about the files that Spotlight finds.

00:54:49.829 --> 00:54:59.210
For this we want not the meta-data on the files
we want the actual data so we actually want a way

00:54:59.210 --> 00:55:07.420
to replace the contents of this results array which we can
do fairly simply with NSMetaDataQuery and its delegate API.

00:55:07.420 --> 00:55:19.010
So we will here declare conformance to the
NSMetaDataQuery delegate protocol and set ourselves here

00:55:19.010 --> 00:55:27.010
as the delegate of the query and then we implement --

00:55:27.010 --> 00:55:31.800
[ Background noise ]

00:55:31.800 --> 00:55:33.450
>> Kevin: Did I not save that?

00:55:33.449 --> 00:55:41.359
There we go -- MetaDataQuery Replacement Object for
Result Object, so the parameter here is the NSMetaDataItem

00:55:41.360 --> 00:55:49.620
and we want to instead return an NSImage which
we initialize with the contents of the file

00:55:49.619 --> 00:55:58.449
that that NSMetaDataItem represents and you can
get that file path by calling Value for Attributes

00:55:58.449 --> 00:56:09.159
and passing KMD Item Path, which is the
Spotlight's constant for that meta-data information.

00:56:09.159 --> 00:56:13.179
And there we go we've created an
NSImage and now that will be put

00:56:13.179 --> 00:56:18.589
into the queries results array
instead of the NSMetaDataItem.

00:56:19.900 --> 00:56:27.769
So one of the great things that Chris was alluding
to about NSMetaDataItem is that it supports bindings.

00:56:27.769 --> 00:56:35.170
The Results Array will be updated automatically when the
file system changes or when Spotlight finds additional files

00:56:35.170 --> 00:56:44.700
that match the predicate and the Results Array is
specially designed for binding so that when connected

00:56:44.699 --> 00:56:49.739
with the proper bindings-aware controller all
that information can be pushed very easily

00:56:49.739 --> 00:56:52.069
to your views without any additional code.

00:56:52.070 --> 00:56:59.970
And we can actually replace bindings, we
can replace the NSTableView datasource code

00:56:59.969 --> 00:57:03.199
with bindings here so we can actually delete all of this.

00:57:03.199 --> 00:57:05.659
We did reference the old images array right here

00:57:05.659 --> 00:57:12.980
so we'll just very quickly replace
that with the results of the query.

00:57:12.980 --> 00:57:17.530
But now we'll go to Interface Builder
again where we can set up the bindings.

00:57:20.699 --> 00:57:27.919
Here we see the multitude of Cocoa bindings-aware
controllers that you can use in Cocoa.

00:57:27.920 --> 00:57:32.710
There's Object Controllers and Tree Controllers
and Dictionary Controllers and so forth.

00:57:32.710 --> 00:57:39.230
We want an Array Controller since our results
property is an array, so here we've instantiated it

00:57:39.230 --> 00:57:47.610
and we bind it its contents array here, we find the
Image Library Controller there and since we've made it

00:57:47.610 --> 00:57:59.079
as the MetaDataQuery and app property we can very easily
access it with a key-path such as this query.results.

00:57:59.079 --> 00:58:08.289
And now we come over here to the table column
and we see here we will want to bind its value

00:58:08.289 --> 00:58:14.219
to the Array Controller and its Arranged Objects Key.

00:58:14.219 --> 00:58:16.509
So go ahead and save that and run.

00:58:16.510 --> 00:58:24.990
Now here you see, you know, it's exactly the same as it was
before but that's a very good result, that's what we want.

00:58:24.989 --> 00:58:30.309
We have eliminated code instead of just some simple
bindings in Interface Builder and this is working exactly

00:58:30.309 --> 00:58:34.880
as it did before, but there's a
hidden benefit to this as well.

00:58:34.880 --> 00:58:42.800
Here we'll come to where we have these images
stored and we'll drop some more images in here,

00:58:42.800 --> 00:58:49.280
and we'll come back to our application and we
see the table view has been automatically updated

00:58:49.280 --> 00:58:52.260
with the contents of that directory.

00:58:52.260 --> 00:58:59.540
Spotlight is watching for notification of file
system changes, updates the NSMetaDataQuery results,

00:58:59.539 --> 00:59:06.250
the NSArray Controller then takes that and pushes
that up to the table view all dynamically for us.

00:59:06.250 --> 00:59:13.489
Cocoa bindings and Spotlight are some great features
we hope that you use them in your own applications.

00:59:13.489 --> 00:59:14.979
Back to Chris now.

00:59:14.980 --> 00:59:18.969
>> Chris: So an interesting thing there, there's a lot
of similar API for table views and dealing with that

00:59:18.969 --> 00:59:23.750
but the Cocoa Bindings technology allows you to eliminate
a lot of glue code that would exist between your controller

00:59:23.750 --> 00:59:30.309
and your model objects and you can basically stop writing
some of that boilerplate code, it's actually a very nifty

00:59:30.309 --> 00:59:33.880
and very interesting way to be able to program

00:59:33.880 --> 00:59:38.840
Once you've got all of this stuff hooked up you'll really
sometimes want to be able to integrate with the Mac.

00:59:38.840 --> 00:59:43.360
Some developers write an iPhone app and you're
going to write a companion app for the Macintosh

00:59:43.360 --> 00:59:50.079
and a lot of this applies both to just being able
to find both iPhones and Macintoshes on the network.

00:59:50.079 --> 00:59:54.750
But Bonjour is a network service discovery protocol
you heard Simon Patience talk

00:59:54.750 --> 00:59:59.809
about it a little bit at his keynote presentation yesterday.

00:59:59.809 --> 01:00:04.170
You publish a service on the network and then you
can find those services and the Foundation API

01:00:04.170 --> 01:00:07.059
for this is NSNetService known as NetService Browser.

01:00:07.059 --> 01:00:11.940
It works the same way it does on the iPhone so if
you've been discovering other iPhones via Bonjour

01:00:11.940 --> 01:00:18.369
on Wi-Fi you'll be able to discover other desktop computers
as well in the same network so a lot of the same code

01:00:18.369 --> 01:00:22.579
that you're using there will come across as well.

01:00:22.579 --> 01:00:26.179
Keyed archiving a very simple way to be
able to exchange data between the desktop

01:00:26.179 --> 01:00:29.529
and the iPhone is the Keyed Archiver
and using the Keyed Archiver.

01:00:29.530 --> 01:00:35.900
It's compatible between the phone and the desktop Macintosh
so that the data that you create the NSData that come

01:00:35.900 --> 01:00:40.599
out of the Archiver you can just shoot right
down to the phone and it'll unpack on the phone.

01:00:40.599 --> 01:00:44.110
You can customize the objects that come in and out
of it so if your model is a little bit different

01:00:44.110 --> 01:00:45.809
in both places you'll be able to tweak that.

01:00:45.809 --> 01:00:48.190
The nice thing about this is that
it's a very simple straightforward way

01:00:48.190 --> 01:00:51.760
to be able to exchange smaller amounts of data.

01:00:51.760 --> 01:00:54.380
Another higher level thing is Core Data.

01:00:54.380 --> 01:00:58.050
If you've only been doing iPhone programming
Core Data's a very interesting technology.

01:00:58.050 --> 01:01:01.310
It's basically an object persistence management framework.

01:01:01.309 --> 01:01:05.259
Right, so you've got a whole bunch of objects they
have relationships to each other and you add something

01:01:05.260 --> 01:01:10.030
to an array or you remove something from an array
those represent relationships between objects

01:01:10.030 --> 01:01:16.470
and this manages the entire object graph and the persistence
of that object graph and it does just a fantastic job

01:01:16.469 --> 01:01:21.209
of dealing with high volumes of objects,
hundreds of thousands of objects at a time.

01:01:21.210 --> 01:01:27.030
It includes versioning of datastore so as you
make your data-set richer and you enhance objects

01:01:27.030 --> 01:01:33.140
with attributes you'll be able to migrate that information
forward and it takes the same predicate format, basically,

01:01:33.139 --> 01:01:38.699
you saw with NSMetaDataQuery and it uses those predicates
to do searches on the database and it abstracts a lot

01:01:38.699 --> 01:01:45.129
of the SQL Light object relationship management stuff that
you've been doing by hand directly against the database

01:01:45.130 --> 01:01:47.090
and it puts it right into a framework for you.

01:01:47.090 --> 01:01:48.490
There are 2 talks about that this year.

01:01:48.489 --> 01:01:53.239
Introduction to Core Data on the iPhone and if you haven't
used Core Data before this would be a fantastic talk for you

01:01:53.239 --> 01:01:59.369
to go to and that's in the Marina, Tuesday at 5.

01:01:59.369 --> 01:02:03.949
And What's New in Core Data talks about what's new
in Core Data for both the phone and the desktop

01:02:03.949 --> 01:02:06.859
and that's in North Beach Wednesday at 10:30.

01:02:06.860 --> 01:02:13.710
So once you've got all of this stuff together you're
not done yet there are a lot of things you can do

01:02:13.710 --> 01:02:16.070
to be a really fantastic Macintosh application.

01:02:16.070 --> 01:02:20.900
There are many, many frameworks that
enhance the user's experience in working

01:02:20.900 --> 01:02:23.710
with your documents and working with the computer.

01:02:23.710 --> 01:02:29.869
One of them is Spotlight, so we were a client of Spotlight
in Kevin's demo to be able to search the hard drives

01:02:29.869 --> 01:02:35.650
that are connected to the machine in order to
determine what files meet the criteria for the search.

01:02:35.650 --> 01:02:41.599
Your documents can participate in Spotlight as well, so in
a document-based application you'd write a Spotlight plug-in

01:02:41.599 --> 01:02:47.079
that indexes your content and adds that to the
Spotlight database so when the user types something in

01:02:47.079 --> 01:02:53.009
and your app is installed and its index document's written
by your app the user will see those documents appear

01:02:53.010 --> 01:02:58.160
in the search results, so you can
participate in Spotlight as well.

01:02:58.159 --> 01:03:05.219
Similarly, Quick Look, on your computers right now if you
hit the Spacebar on a JPG or and image or a Keynote doc

01:03:05.219 --> 01:03:10.980
and anything like that that HUD window pops up and it has a
preview of the document and in that preview you can interact

01:03:10.980 --> 01:03:15.360
with you can scroll through a PDF, you can look at
multiple images, you can scroll through a presentation

01:03:15.360 --> 01:03:19.210
or look at all the sheets in a numbers document.

01:03:19.210 --> 01:03:25.340
This is the Quick Look technology you would write a
plug-in for that and actually participate in the same thing

01:03:25.340 --> 01:03:26.880
so when the user hits the Spacebar when one

01:03:26.880 --> 01:03:29.640
of your documents is selected in
the Finder you get the same preview.

01:03:29.639 --> 01:03:36.289
Boy that just looks like the Eye of Sauron that's just going
to bore you to death with his vacation pictures, doesn't it?

01:03:36.289 --> 01:03:40.579
Here we were running through Mordor, right?

01:03:40.579 --> 01:03:44.420
AppleScript, AppleScript is an absolutely
incredible technology on Mac OS X

01:03:44.420 --> 01:03:47.150
and it has some really interesting characteristics.

01:03:47.150 --> 01:03:51.389
You can publish your Object Graph and
commands that you can do to your Object Graph,

01:03:51.389 --> 01:04:01.069
your model basically as an AppleScript Dictionary, nsDef
and that allows the user to write scripts against your app,

01:04:01.070 --> 01:04:08.539
you know, create new window in front and add text to
that window or add an object to that window or an image,

01:04:08.539 --> 01:04:13.009
things like that, and this allows you also to participate
with Automator and a number of other technologies

01:04:13.010 --> 01:04:18.440
to have your application participate
in workflows that your users write.

01:04:18.440 --> 01:04:20.099
So even applications that never knew anything

01:04:20.099 --> 01:04:25.940
about each other you can actually string together workflows
using AppleScript and it's a great boon to your users

01:04:25.940 --> 01:04:30.720
and if you participate in AppleScript it's
another big bonus for your Macintosh application.

01:04:30.719 --> 01:04:38.339
Another big, big technology that we like to make a big deal
of, Mac OS X has some of the best accessibility behaviors

01:04:38.340 --> 01:04:42.760
in an operating system so for users that are
visually impaired or who have other difficulties

01:04:42.760 --> 01:04:49.910
in using a machine the accessibility frameworks allow
you to annotate your application with everything

01:04:49.909 --> 01:04:55.279
that those users would need to be able to effectively
use the computer even if they can't see the screen.

01:04:55.280 --> 01:04:58.750
On Mac Os X this means being able to
plug in an arbitrary Braille reader

01:04:58.750 --> 01:05:02.920
and have that give it all the information
to the user right at their fingertips.

01:05:02.920 --> 01:05:06.619
So accessibility is another thing that if
you're going to be writing a Mac application

01:05:06.619 --> 01:05:11.339
or even your iPhone applications now on iPhone 3.0
you really shouldn't ignore because this is a big,

01:05:11.340 --> 01:05:18.360
big feature that -- the kit does a lot for you free
but you can also enhance it with that experience.

01:05:18.360 --> 01:05:25.250
So, please go out write your application, you know, use the
model code that you already have or write a new application

01:05:25.250 --> 01:05:29.309
for the Macintosh using all of the
skills that you already know in order

01:05:29.309 --> 01:05:31.619
to drive, you know, Xcode and all of those things.

01:05:31.619 --> 01:05:38.529
So, Matt Drance is our iPhone and Mac
Application Frameworks Evangelist.

01:05:38.530 --> 01:05:42.510
I got that wrong in my last talk so I had to say
that very carefully to make sure that I got it right.

01:05:42.510 --> 01:05:46.800
His email address is MDrance@Apple.com
and there's a lot of documentation

01:05:46.800 --> 01:05:49.460
at the Mac Dev Center, Developer@apple.com/mac.
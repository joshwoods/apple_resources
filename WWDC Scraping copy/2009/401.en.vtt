WEBVTT

00:00:12.960 --> 00:00:14.370
>> So, good afternoon everyone.

00:00:14.369 --> 00:00:18.850
Welcome to improving your application
with the Xcode Static Analyzer.

00:00:18.850 --> 00:00:20.040
My name is Ted Kremenek.

00:00:20.039 --> 00:00:27.140
I'm a member of the compiler team at Apple, and I'm very
excited to be talking to about the Xcode Static Analyzer.

00:00:27.140 --> 00:00:32.990
The Static Analyzer is a new feature in Snow
Leopard's developer tools that quite simply it's going

00:00:32.990 --> 00:00:38.850
to provide you the means to find a wide variety
of a list of software bugs both in your iPhone

00:00:38.850 --> 00:00:45.260
and Mac applications far more quickly
and easily than you were able to before.

00:00:45.259 --> 00:00:49.619
And all this is based on the use
of static source code analysis.

00:00:49.619 --> 00:00:54.239
Now static analysis is something that many
of you have probably not heard of before.

00:00:54.240 --> 00:00:56.100
The premise is very simple.

00:00:56.100 --> 00:01:01.679
We essentially just want to automatically find bugs
in your programs by analyzing your source code.

00:01:01.679 --> 00:01:03.229
Now here are the keywords.

00:01:03.229 --> 00:01:08.259
Static simply means we're going to
do this without running the program.

00:01:08.260 --> 00:01:12.680
So static analysis is based essentially
on deep compiler analysis.

00:01:12.680 --> 00:01:18.960
So it mean the same ideas we use to built compilers to
make your code run fast, we retarget to instead reason

00:01:18.959 --> 00:01:21.750
about what your code is doing to find bugs.

00:01:21.750 --> 00:01:28.739
And so the usage model for static analysis is could be
thought of as the form of advance compiler warnings.

00:01:28.739 --> 00:01:34.849
So we're used to feedback from compilers concluding like
errors, like things that tell us why our code can't build,

00:01:34.849 --> 00:01:40.000
but also warnings to tell us about
issues, you know, potentially suspect code

00:01:40.000 --> 00:01:44.140
that when actually run could do
something that we did not anticipate.

00:01:44.140 --> 00:01:49.650
Static analysis tries to take this idea a lot further
by finding very deep kind of programming mistakes,

00:01:49.650 --> 00:01:53.190
mistakes that you could typically only find with testing.

00:01:53.189 --> 00:01:59.810
So as a basic example of something that we can find
frequently with static analysis are null dereference checks.

00:01:59.810 --> 00:02:04.329
Null dereferences are bad, you know,
they can cause our programs to crash.

00:02:04.329 --> 00:02:07.819
And here is an example code fragment
that exhibits a null dereference.

00:02:07.819 --> 00:02:12.629
And the basic premise of static analysis is that we
could feed this to a static source code analysis engine.

00:02:12.629 --> 00:02:18.689
And then it would spit out a warning telling us that there's
a null dereference on a particular line of code in our app.

00:02:18.689 --> 00:02:23.289
And this is really powerful because it's just very
advanced feedback about the intricate behavior

00:02:23.289 --> 00:02:26.099
of our program and what could be going wrong.

00:02:26.099 --> 00:02:33.269
Now static analysis is not meant to be replacement for
any of the other ways you find bugs, whether it be testing

00:02:33.270 --> 00:02:36.240
or using your debugger or using instruments.

00:02:36.240 --> 00:02:41.659
Instead it's meant to compliment these
techniques with three particular strengths.

00:02:41.659 --> 00:02:45.479
The first is the early detection of bugs.

00:02:45.479 --> 00:02:50.819
If you think about it, static analysis can be
applied very early in development workflow.

00:02:50.819 --> 00:02:54.569
Before you can actually build an entire
program, before you can actually run it,

00:02:54.569 --> 00:02:59.169
as long as pieces of it can be
compiled, you can analyze it for bugs.

00:02:59.169 --> 00:03:02.869
And this means like as you're actively
editing your code, you're hacking away,

00:03:02.870 --> 00:03:06.920
you have the potential to find bugs close
to the moment that they were introduced.

00:03:06.919 --> 00:03:12.089
And bugs that are fixed earlier often much,
much fixer, much, much cheaper to fix.

00:03:12.090 --> 00:03:16.569
Second, static analysis is very comprehensive.

00:03:16.569 --> 00:03:19.659
It can find deep bugs without test cases.

00:03:19.659 --> 00:03:25.620
Now testing is really great, but its strength
really relies on how good your test suite is.

00:03:25.620 --> 00:03:31.330
And so if you think about all the corner cases
in your app that you have to actually test,

00:03:31.330 --> 00:03:35.020
if your test suite does not exercise
it, you're not going to find those bugs.

00:03:35.020 --> 00:03:39.600
Static analysis tries to reason out all the
different ways that your code could be exercised,

00:03:39.599 --> 00:03:43.939
and so it's good in complimenting
testing in those harder reach cases.

00:03:43.939 --> 00:03:49.829
Now the third real strength of static analysis is
that we can often get very detailed error reports.

00:03:49.830 --> 00:03:52.910
Sometimes it's not just good enough
that we know that an error is present,

00:03:52.909 --> 00:03:56.530
but we want a full diagnosis of
how the bug actually occurred.

00:03:56.530 --> 00:04:02.310
And when you can see the precise lines and expressions
involved in an issue, it makes it much easier to fix it

00:04:02.310 --> 00:04:10.039
So we've taken the strength of static analysis and work
very hard to put it right at your fingertips in Xcode.

00:04:10.039 --> 00:04:17.060
This is a new feature in Snow Leopard that's going to allow
you to analyze both iPhone and Mac applications for bugs.

00:04:17.060 --> 00:04:19.259
And when you're analyzing for the iPhone, it works either

00:04:19.259 --> 00:04:24.829
for when you're targeting the simulator
or the device, it works seamlessly.

00:04:24.829 --> 00:04:29.740
Now we focus on a few key areas for--
initial key areas for bug finding.

00:04:29.740 --> 00:04:35.139
The first is basic Cocoa API checks, and I'll
talk about that a little bit more in this session.

00:04:35.139 --> 00:04:40.110
And within that theme, we've done a lot
of work on Cocoa memory management rules.

00:04:40.110 --> 00:04:45.819
Cocoa memory management is key to developing
both good iPhone and Mac applications.

00:04:45.819 --> 00:04:49.259
And third, we've looked at the
general sense of logic errors.

00:04:49.259 --> 00:04:53.939
So things like null dereferences, uses
uninitialized values and so forth.

00:04:53.939 --> 00:04:58.819
These are things that benefit any kind of
app regardless of whether it uses Cocoa.

00:04:58.819 --> 00:05:03.689
Now all this is based on the Open Source Clang static
analysis engine which is part of the larger clang

00:05:03.689 --> 00:05:08.250
and LVM projects, and I'll talk about that briefly later.

00:05:08.250 --> 00:05:15.910
And finally, we have really worked hard to create a fluid
workflow experience within Xcode so that you never have

00:05:15.910 --> 00:05:20.020
to leave your editor to actually go and find and fix bugs.

00:05:20.019 --> 00:05:24.819
So that said, why should you actually care?

00:05:24.819 --> 00:05:32.040
We got a ton of features that you can-- you can learn to
use, what benefit with learning a new feature brings to you?

00:05:32.040 --> 00:05:34.590
Well, there are three reasons.

00:05:34.589 --> 00:05:38.859
The first is that we at Apple found it extremely valuable.

00:05:38.860 --> 00:05:45.660
While they'll bring it up on Snow Leopard and the
iPhone 3.0 OS, we found and fixed thousands of bugs.

00:05:45.660 --> 00:05:50.160
And the key thing here is that some
of these are major, others were minor,

00:05:50.160 --> 00:05:55.050
but once they were spotted using static
analysis, they were often trivial to fix.

00:05:55.050 --> 00:05:59.050
And this is the real value of a feature like this.

00:05:59.050 --> 00:06:05.720
The second thing is static analysis will
help you be a better Cocoa programmer.

00:06:05.720 --> 00:06:09.960
If you're just learning Cocoa, it will
help you understand just the, you know,

00:06:09.959 --> 00:06:13.639
the basic rules of Cocoa, how should
you go about using memory.

00:06:13.639 --> 00:06:19.550
And it will give you-- get you over the common
mistakes that beginning Cocoa programmers have.

00:06:19.550 --> 00:06:22.400
And even if you're a veteran, there is still benefit to you.

00:06:22.399 --> 00:06:24.589
None of us write perfect code.

00:06:24.589 --> 00:06:30.310
And there are always corner cases that we never thought
about, static analysis will help look over your shoulder

00:06:30.310 --> 00:06:34.350
and essentially do a form of automated code review.

00:06:34.350 --> 00:06:40.050
Now the third thing and this is what I think
is really a key, is that there is real value

00:06:40.050 --> 00:06:44.879
in fixing your bugs before users see
them, and static analysis gives you a way

00:06:44.879 --> 00:06:50.670
to more proactively find bugs before you get some
kind of bug report saying, "Hey, your app crashed".

00:06:50.670 --> 00:06:55.550
And so if you think about the growing
ecosystem of apps on the apps store

00:06:55.550 --> 00:06:59.910
or even on growing set of apps
on the Mac, users notice polish.

00:06:59.910 --> 00:07:06.560
They notice apps that have good UI polish, but they also
notice apps that have behavioral polish and apps that crash

00:07:06.560 --> 00:07:14.649
or sluggish 'cause they leak memory, users will notice this,
and it translates directly into ratings on the App Store.

00:07:14.649 --> 00:07:17.799
So we think this is going to be a tremendous value to you.

00:07:17.800 --> 00:07:22.800
So that said, let's show you static analysis in Xcode.

00:07:22.800 --> 00:07:25.530
And driving it is going to be Yuji Akimoto.

00:07:25.529 --> 00:07:29.819
He is a Senior Xcode UI Engineer, and he is
one of the great members of the Xcode team,

00:07:29.819 --> 00:07:31.849
I have the great pleasure to work with on this feature.

00:07:31.850 --> 00:07:34.720
So we're going to show you three examples.

00:07:34.720 --> 00:07:37.820
We're going to warm up with something
very simple similar to what we showed

00:07:37.819 --> 00:07:40.500
in the Developer State of the Union and then go from there.

00:07:40.500 --> 00:07:44.569
So we got basic Xcode project, Hello World.

00:07:44.569 --> 00:07:46.149
We're going to open up one of the files.

00:07:46.149 --> 00:07:52.879
And here is this contrive function that all it does is
allocates a Cocoa NSString object and then print it up.

00:07:52.879 --> 00:07:54.540
And it's very simple.

00:07:54.540 --> 00:07:58.530
So for those of you who aren't familiar with Cocoa,

00:07:58.529 --> 00:08:04.279
Cocoa traditionally uses a retained account
mechanism to manage the lifetime of objects.

00:08:04.279 --> 00:08:09.909
And so here sending the alloc to NSString
returns an object as the caller's responsibility

00:08:09.910 --> 00:08:13.120
to release by sending the release message.

00:08:13.120 --> 00:08:17.829
Now, you might think well there's also garbage
collection available for Mac development.

00:08:17.829 --> 00:08:23.839
I'm going to show later in this talk how static analysis can
help you find memory leaks in your garbage collected apps.

00:08:23.839 --> 00:08:29.750
So, well, this seems like a fairly
innocuous example of what's going wrong.

00:08:29.750 --> 00:08:32.409
Well there's actually a memory leak
here because we allocated the object,

00:08:32.409 --> 00:08:34.919
we used it, and then we just forgot about it.

00:08:34.919 --> 00:08:40.049
And traditionally finding this bug would require you to
actually be able to run the app, maybe ran a bunch of times

00:08:40.049 --> 00:08:43.219
through instruments and hopefully identify the leak.

00:08:43.220 --> 00:08:47.190
But now with static analysis you can
find it with the click of a mouse.

00:08:47.190 --> 00:08:53.300
So we have this new Build and Analyze option in the
Build menu, and the Static Analyzer is integrated

00:08:53.299 --> 00:08:59.370
into the Build system because the Build system basically
knows how your code integrates together, how it's built,

00:08:59.370 --> 00:09:01.960
what the dependencies are, so it's
a natural place to put it.

00:09:01.960 --> 00:09:04.879
So we're going to run Build and Analyze.

00:09:04.879 --> 00:09:11.200
And what's happening here is your code is being
both compiled and analyzed by the Static Analyzer.

00:09:11.200 --> 00:09:17.940
So, the output of the Static Analyzer is just like any
other, initially like any other compiler error warning.

00:09:17.940 --> 00:09:19.820
We get this nice message bubble.

00:09:19.820 --> 00:09:23.530
Notice it's actually tinted blue to
distinguish it from other compiler errors

00:09:23.529 --> 00:09:26.439
and warnings and it's got the static analysis icon.

00:09:26.440 --> 00:09:31.450
Now if this was a compiler warning,
this would be the end of the story.

00:09:31.450 --> 00:09:34.100
This is all the information that you would have.

00:09:34.100 --> 00:09:39.120
But the Static Analyzer actually has a rich
amount of information to show you full diagnosis

00:09:39.120 --> 00:09:45.799
of how this bug occurred, and you can activate
that by clicking on the message bubble.

00:09:45.799 --> 00:09:48.250
So this is very cool.

00:09:48.250 --> 00:09:50.100
So suddenly a bunch of things change.

00:09:50.100 --> 00:09:53.920
The first thing that happened is the message
bubble that we clicked on disappeared.

00:09:53.919 --> 00:09:59.479
And if there were other compiler errors and warnings that
were in this one, that they would also disappeared as well.

00:09:59.480 --> 00:10:01.450
And I'll show example later on.

00:10:01.450 --> 00:10:05.680
This is a transient change in your Editor Window.

00:10:05.679 --> 00:10:08.219
Now couple of things appeared instead.

00:10:08.220 --> 00:10:10.399
First is we have these two new message bubbles.

00:10:10.399 --> 00:10:12.539
These are what I call Analyzer events.

00:10:12.539 --> 00:10:18.189
>> They are essentially things that happened, it could have
happened in the function in order for this bug to occur,

00:10:18.190 --> 00:10:21.180
and there's essentially a temporal ordering between them.

00:10:21.179 --> 00:10:24.129
There are also these blue arrows
which are overlaid over your code.

00:10:24.129 --> 00:10:28.370
These illustrate the control flow for
your code in order for the bug to occur.

00:10:28.370 --> 00:10:31.210
This is straight line code so it's
not very interesting right now,

00:10:31.210 --> 00:10:34.000
but the next example will really show how they shine.

00:10:34.000 --> 00:10:40.490
And then lastly, there's this new tool
bar at the very top of the Editor Window

00:10:40.490 --> 00:10:43.680
that lets you to navigate through the Analyzer events.

00:10:43.679 --> 00:10:46.870
If we go and click on the event, we
can see, you know, it pulls down.

00:10:46.870 --> 00:10:49.409
You can slide between them, you can jump between them.

00:10:49.409 --> 00:10:52.129
There are also these arrows on the
right side of the tool bar that lets you

00:10:52.129 --> 00:10:54.399
to navigate them in a forward and backward.

00:10:54.399 --> 00:11:00.470
So you have both random access and forward
and backward and flow through the bug.

00:11:00.470 --> 00:11:03.860
So it quickly lets you go through
the bug and see what's going on.

00:11:03.860 --> 00:11:07.500
And when you're done actually inspecting
the bug, you can just click the Done button

00:11:07.500 --> 00:11:09.889
and it returns us back to the original editor.

00:11:09.889 --> 00:11:16.500
So this is a very, you know, simple way to find out more
about the bug and then when you're done, leave them.

00:11:16.500 --> 00:11:19.129
So let's go and actually fix this issue.

00:11:19.129 --> 00:11:25.490
And as I mentioned before there's a leak and what we
need to do to fix this is send a release to the object.

00:11:25.490 --> 00:11:31.009
So we're going to say message release and
now we're going to Build and Analyze again.

00:11:31.009 --> 00:11:36.139
[ Pause ]

00:11:36.139 --> 00:11:39.009
>> And voila the bug disappears.

00:11:39.009 --> 00:11:44.710
[ Audience Remark: Can you enlarge your font?]

00:11:44.710 --> 00:11:47.590
>> They can't read the screen, it's too--

00:11:47.590 --> 00:11:48.160
[ Audience Remark ]

00:11:48.159 --> 00:11:48.980
>> OK.

00:11:48.980 --> 00:11:50.310
[ Audience Remark ]

00:11:50.309 --> 00:11:52.009
>> Sure, we'll be quick and make it bigger.

00:11:52.009 --> 00:12:01.730
[ Pause ]

00:12:01.730 --> 00:12:03.029
>> Yeah, I guess so.

00:12:03.029 --> 00:12:04.610
Is that better?

00:12:04.610 --> 00:12:05.409
[ Applause ]

00:12:05.409 --> 00:12:06.209
[ Laughter ]

00:12:06.210 --> 00:12:09.600
>> OK, sorry about that.

00:12:09.600 --> 00:12:11.320
Thank you for pointing that out.

00:12:11.320 --> 00:12:15.740
The rest of the code can be a lot more
complicated, so it is good to point that out now.

00:12:15.740 --> 00:12:19.279
So, so that's a simple bug, contrive example.

00:12:19.279 --> 00:12:24.779
And the point of this was that you were able
to just within the editor, find the bug,

00:12:24.779 --> 00:12:27.379
fix it, and quickly verify that was gone.

00:12:27.379 --> 00:12:30.429
And so this is a really powerful quick workflow.

00:12:30.429 --> 00:12:34.959
Let's go ahead and move on to a
slightly more complicated example.

00:12:34.960 --> 00:12:36.540
And well, that's interview quiz.

00:12:36.539 --> 00:12:42.049
Now let me give you a moment to look at this
code and try to figure out what's wrong.

00:12:42.049 --> 00:12:45.709
To give you some context, this isn't a contrived example.

00:12:45.710 --> 00:12:52.300
It was a real bug found in some large unanimous
Open Source, not Open Source, code base.

00:12:52.299 --> 00:12:57.509
And I've removed extraneous logic from this bug.

00:12:57.509 --> 00:13:06.049
So if you haven't seen it yet, let's see what the
Analyzer can tell us by running Build and Analyze.

00:13:06.049 --> 00:13:09.029
And what-- OK, so we don't have a leak in this case.

00:13:09.029 --> 00:13:11.610
We actually have something far more serious.

00:13:11.610 --> 00:13:15.389
And here we actually have an object
that's been over released.

00:13:15.389 --> 00:13:17.750
And so how could this actually have occurred?

00:13:17.750 --> 00:13:22.279
So we're going to go and click on that
message bubble again to disclose the bug.

00:13:22.279 --> 00:13:26.519
And we've got a lot more information
than we did from the previous example.

00:13:26.519 --> 00:13:30.929
Now notice because this bug involves a
for loop and two nested loop statements,

00:13:30.929 --> 00:13:35.199
the arrows illustrate the control
flow through these structures.

00:13:35.200 --> 00:13:40.730
And so and actually not all of the-- some of
the arrows are more bold than the other ones.

00:13:40.730 --> 00:13:46.529
The first set of arrows that are bold are the ones showing
essentially the sequence of branches taken from the entrance

00:13:46.529 --> 00:13:52.129
of the function to the first event which
is the place for the object is allocated.

00:13:52.129 --> 00:13:59.809
If we go ahead and click to the second event, you'll notice
that the set of arrows that are highlighted actually change.

00:13:59.809 --> 00:14:03.889
And what we're doing is we're showing you basically
between what you just looked at and what you're looking

00:14:03.889 --> 00:14:08.240
at now what was the flow through the--
through their code for that to occur.

00:14:08.240 --> 00:14:13.539
And so what we see now is that there's this path from
this allocation to the place where the object is released.

00:14:13.539 --> 00:14:14.860
And here you actually see an example.

00:14:14.860 --> 00:14:18.050
There are two Static Analyzer Events on the same line.

00:14:18.049 --> 00:14:23.479
You can see in the navigation tool bar that's
indicating the one where the object is released.

00:14:23.480 --> 00:14:30.960
So if we click to the next event, we see that what happens
is we leave to the loop iteration and then we go back

00:14:30.960 --> 00:14:36.860
to the head of the loop, and then we click-- again click to
the next step that shows that we entered the loop, you know,

00:14:36.860 --> 00:14:40.649
the second time, but this time
the set of errors are different.

00:14:40.649 --> 00:14:46.590
It shows us the case where the first branch isn't
actually taking it and then we go to the second one.

00:14:46.590 --> 00:14:49.580
And because object ID still refers
to the object that we release

00:14:49.580 --> 00:14:53.600
on the previous iteration, the object is over released.

00:14:53.600 --> 00:14:58.300
So this is actually a very, and if you think
about it, this is actually a fairly complex kind

00:14:58.299 --> 00:15:00.719
of bug, there's a lot of information here.

00:15:00.720 --> 00:15:07.600
But you can easily digest it by just stepping
through it in a very consistent and logical way.

00:15:07.600 --> 00:15:09.960
So let's go and fix this bug too.

00:15:09.960 --> 00:15:16.290
So the problem is that at the beginning of the
first loop iteration, object ID was nil, right?

00:15:16.289 --> 00:15:22.740
And so it looks like this code basically expects that to
be the invariant at the beginning of every loop iteration.

00:15:22.740 --> 00:15:27.409
So we can solve this problem just by nuking
the value of object ID after we release it.

00:15:27.409 --> 00:15:30.329
So we're going to set object ID equals nil.

00:15:30.330 --> 00:15:34.940
Just ran Build and Analyze.

00:15:34.940 --> 00:15:40.090
And the bug disappears.

00:15:40.090 --> 00:15:45.009
OK, so you-- again, this whole very quick
workflow of finding and fixing bugs.

00:15:45.009 --> 00:15:50.549
[ Applause ]

00:15:50.549 --> 00:15:53.059
>> So those are toy examples, right?

00:15:53.059 --> 00:15:57.779
I mean the real value of this tool is they
can find bugs in a real mature code basis,

00:15:57.779 --> 00:16:01.970
code basis that are used, code basis that people care about.

00:16:01.970 --> 00:16:10.100
So, to illustrate that, I want to run the Analyzer
on the real Open Source project and that's Growl.

00:16:10.100 --> 00:16:15.540
And my choice of illustrative on Growl is
not because I'm trying to pick on Growl.

00:16:15.539 --> 00:16:17.809
It's actually a well written code base.

00:16:17.809 --> 00:16:18.679
It's mature.

00:16:18.679 --> 00:16:19.559
It's well used.

00:16:19.559 --> 00:16:21.899
There are developers who are actively working on it.

00:16:21.899 --> 00:16:24.000
They care about the code being correct.

00:16:24.000 --> 00:16:26.779
And let's the value of actually
running the Analyzer on that.

00:16:26.779 --> 00:16:29.429
So here's the Xcode project for Growl.

00:16:29.429 --> 00:16:32.939
We're going to actually pull up the Build
results window to kind of illustrate

00:16:32.940 --> 00:16:36.460
where the analyzers falls in with
the rest of your built task.

00:16:36.460 --> 00:16:40.139
So let's go ahead and run Build and Analyze.

00:16:43.269 --> 00:16:46.500
And you can see there's actually, you
know, you can see the actual steps

00:16:46.500 --> 00:16:51.110
that the Build system does to both
compile and analyze your code.

00:16:51.110 --> 00:16:57.080
And it actually groups the compiler warnings and errors and
the Analyzer, she's right under the individual build phases,

00:16:57.080 --> 00:17:00.540
so you can-- you can actually use
this to navigate through your issues.

00:17:00.539 --> 00:17:04.149
And we're going to talk about this in
a lot more detail later in the session.

00:17:04.150 --> 00:17:13.240
Let's go ahead and look at one of the real bugs
here, go to CFURL editions, that yes, that final.

00:17:13.240 --> 00:17:16.630
So you see it's lot of real code.

00:17:16.630 --> 00:17:19.590
This is an actually-- this is a C file.

00:17:19.589 --> 00:17:24.839
And on-- in this example you can see that there are
2 Static Analyzer issues and the compiler warning.

00:17:24.839 --> 00:17:28.970
So this is a real example of how all
those would coexist in the editor.

00:17:28.970 --> 00:17:34.600
So the first Analyzer issue is something called the dead
store, I'm going to talk about that later in the session.

00:17:34.599 --> 00:17:41.759
The second one is actually a very serious bug and it says
passed-by-value argument and function call is undefined.

00:17:41.759 --> 00:17:44.279
And so what that basically means
is you're calling a function

00:17:44.279 --> 00:17:46.829
and one of the arguments are passing through it is garbage.

00:17:46.829 --> 00:17:54.210
So this would result in a really kind of weird bug that the
caller, I mean that the callee would get this garbage value

00:17:54.210 --> 00:17:56.600
and then do something really awful with it.

00:17:56.599 --> 00:18:00.369
And the real-- the nastiness about
this bug is that it occurs long

00:18:00.369 --> 00:18:03.819
after the point where the bug actually is introduced.

00:18:03.819 --> 00:18:07.339
So let's go and disclose that information.

00:18:07.339 --> 00:18:10.230
And so this is, you know, it illustrates on real code.

00:18:10.230 --> 00:18:13.610
We can see the precise inter branches that are taken.

00:18:13.609 --> 00:18:18.459
We say the bug occurs because there's this
variable that's declared without initial value.

00:18:18.460 --> 00:18:23.440
And what I want to point is that Clang has full
range information for all these expressions.

00:18:23.440 --> 00:18:29.660
So notice for the Analyzer event, we completely highlight
the actual declaration where the variable was undeclared.

00:18:29.660 --> 00:18:33.980
So there's no guessing about what
we're actually talking about here.

00:18:33.980 --> 00:18:39.509
And if we click to the second event, what happens
is the set of, you know, branches that are taken

00:18:39.509 --> 00:18:43.339
to reach the actual call are highlighted
so you can go and follow them.

00:18:43.339 --> 00:18:47.980
And we see this actual function call where
the argument is passed uninitialized.

00:18:47.980 --> 00:18:52.920
We see that past style is also highlighted, so
you see the actual argument that is uninitialized.

00:18:52.920 --> 00:18:57.300
So it's again, trying to give you some very
precise information of what exactly went wrong.

00:18:57.299 --> 00:19:02.750
And we think this is just really tremendously
valuable for finding and fixing your bugs.

00:19:02.750 --> 00:19:04.789
So there you have it.

00:19:04.789 --> 00:19:11.490
Static analysis in Xcode, find and fix
bugs quickly with the click of the mouse.

00:19:13.009 --> 00:19:18.950
[ Applause ]

00:19:18.950 --> 00:19:26.009
>> So before we move on, I just want to ask you a question,
don't you think you did a great job on these arrows?

00:19:26.009 --> 00:19:29.390
[ Applause ]

00:19:29.390 --> 00:19:32.770
[ Laughter ]

00:19:32.769 --> 00:19:33.049
>> Excellent.

00:19:33.049 --> 00:19:36.309
So let's go ahead and set back to the slides.

00:19:36.309 --> 00:19:39.799
So that's a feature in-- that's the feature in a nutshell.

00:19:39.799 --> 00:19:46.529
So but what I want to talk about for the rest of the session
is how do you go about making the most out of this feature.

00:19:46.529 --> 00:19:48.289
And I want to cover three things.

00:19:48.289 --> 00:19:52.500
First is how is it basically working under the hood.

00:19:52.500 --> 00:19:55.529
This is important so that you can
understand its strengths and limitations.

00:19:55.529 --> 00:19:59.480
We don't want this feature to seem like its magic.

00:19:59.480 --> 00:20:01.759
The second is workflow.

00:20:01.759 --> 00:20:07.250
How do you go about best using this tool, I mean your,
you have a way, if you go back developing software,

00:20:07.250 --> 00:20:10.390
where does it best fit in to your processes.

00:20:10.390 --> 00:20:14.530
The third thing I want to talk about are bugs, right?

00:20:14.529 --> 00:20:16.119
>> This is all about bugs.

00:20:16.119 --> 00:20:22.149
How is the Analyzer relaying informing to you,
what kind of bugs does it actually tell you about.

00:20:22.150 --> 00:20:28.640
And because the Analyzer actually is not perfect, it's
going to have some noise which we call false positives.

00:20:28.640 --> 00:20:35.790
I'll talk about different categories of false
positives and how you can go best dealing with them.

00:20:35.789 --> 00:20:39.920
So how does the Analyzer actually work?

00:20:39.920 --> 00:20:42.670
Well as I mentioned before, it's all built on top of Clang.

00:20:42.670 --> 00:20:48.320
Now Clang is this overloaded term but here I mean
the actual Open Source C and Objective-C front end

00:20:48.319 --> 00:20:51.819
that we're building to build great compiler technologies.

00:20:51.819 --> 00:20:55.829
Clang and the Analyzer are 100 percent Open Source, right?

00:20:55.829 --> 00:21:00.159
You can go and check it out, look at the code,
use it, and this has been really valuable for us.

00:21:00.160 --> 00:21:05.190
People have contributed both to Clang and
the analyzers to make it a better future.

00:21:05.190 --> 00:21:12.500
The Analyzer currently handles C and Objective-C
code, so you can use it freely on just plain C apps.

00:21:12.500 --> 00:21:19.549
Now we've really too did more for Objective-C code but
still very valuable at this point for analyzing straight C.

00:21:19.549 --> 00:21:23.649
We previewed this technology at last year's WWDC.

00:21:23.650 --> 00:21:29.190
And I just want to mention this because the feedback that
we've gotten from you, from using the Open Source release

00:21:29.190 --> 00:21:34.360
of the Analyzer has been invaluable and we really
appreciate that feedback and we hope you will continue

00:21:34.359 --> 00:21:38.199
to give us your thoughts and insights
on how we can make this better.

00:21:38.200 --> 00:21:43.539
You can find out more about the Open
Source project by going to clang.llvm.org.

00:21:43.539 --> 00:21:48.779
We really encourage people to get
involve if they're excited about this.

00:21:48.779 --> 00:21:50.819
So how is the Static Analyzer actually built?

00:21:50.819 --> 00:21:56.269
So in the Compiler State of the
Union we flashed a diagram like this

00:21:56.269 --> 00:21:59.400
where we talked about how the Clang compiler is built.

00:21:59.400 --> 00:22:06.920
It consist of this thing called the Clang Front End which
is the-- which is an LVM library which handles the parsing

00:22:06.920 --> 00:22:10.740
and lexing and preprocessing of C and Objective-C code.

00:22:10.740 --> 00:22:17.029
It then builds an in-memory representation of your program
that has been fed to a compiler back end which consist

00:22:17.029 --> 00:22:21.369
of this Optimizer and Code Generator
which generates a compiled code.

00:22:21.369 --> 00:22:27.209
The Static Analyzer uses the same
exact front end as the Clang compiler,

00:22:27.210 --> 00:22:33.200
and then instead of the in-memory representation
being thrown over the wall to a code generator,

00:22:33.200 --> 00:22:39.519
it's fed to a source code analysis engine which
feeds its results up to the Xcode user interface.

00:22:39.519 --> 00:22:44.160
Now the hive that I want you to get
out this diagram is that the compiler

00:22:44.160 --> 00:22:48.410
and the Analyzer are seeing your
code and exactly the same way.

00:22:48.410 --> 00:22:53.440
So we have a region of representation of
your program to serve both of these tasks.

00:22:53.440 --> 00:22:58.279
And so we're really excited about the kind of tools
that we're going to be able to build using Clang.

00:22:59.339 --> 00:23:04.490
So when your code is analyzed what actually happens?

00:23:04.490 --> 00:23:11.359
Well, each file or method-- each file is handed
to the Analyzer engine, and within each file,

00:23:11.359 --> 00:23:16.099
each function or method is analyzed one at a time.

00:23:16.099 --> 00:23:20.599
And within a function, the Analyzer
reasons about what we call paths.

00:23:20.599 --> 00:23:25.329
And a path is simply just the sequence
of branches taken through your code.

00:23:25.329 --> 00:23:29.319
So, you know, you have different ifs and in
for statements what are the different ways

00:23:29.319 --> 00:23:31.740
in which you could run through that code.

00:23:31.740 --> 00:23:35.349
And if you think about a test case
where you actually running the program,

00:23:35.349 --> 00:23:38.000
only one path will be triggered through that code.

00:23:38.000 --> 00:23:41.000
What the Analyzer tries to do is reason about all the ways

00:23:41.000 --> 00:23:45.069
that your code could be exercised
and this is how it achieves coverage.

00:23:45.069 --> 00:23:48.750
Now in order to get this coverage,
it's not doing a perfect--

00:23:48.750 --> 00:23:50.539
essentially not doing an execution of your program.

00:23:50.539 --> 00:23:56.559
It's an abstract in a way details in order to
basically collapsed redundant behavior and just look

00:23:56.559 --> 00:24:00.599
for the salient features that are needed to identify bugs.

00:24:00.599 --> 00:24:03.529
And you might think that this is expensive.

00:24:03.529 --> 00:24:04.619
Well, it is.

00:24:04.619 --> 00:24:11.159
So essentially using static analysis is about
trading CPU time for improving your code.

00:24:11.160 --> 00:24:13.570
And that's essentially the tradeoff we're trying to make.

00:24:13.569 --> 00:24:17.450
It's a different goal than making the compiler fast.

00:24:17.450 --> 00:24:22.819
And static analysis essentially uses worst-case exponential
algorithms or exponential in the number of paths.

00:24:22.819 --> 00:24:24.109
We do a lot of clever things.

00:24:24.109 --> 00:24:29.629
So it typically isn't like that, but at the end of
the day, the Analyzer's best effort which is trying

00:24:29.630 --> 00:24:34.250
to do a very good job of analyzing your code, but if
your code is too complicated, we bound the amount of work

00:24:34.250 --> 00:24:36.750
so that you get results in a reasonable amount of time.

00:24:36.750 --> 00:24:38.160
So that's the expectation.

00:24:38.160 --> 00:24:40.040
It's a best effort tool.

00:24:40.039 --> 00:24:43.970
So how is a bug actually found?

00:24:43.970 --> 00:24:46.569
Now this is a real code fragment.

00:24:46.569 --> 00:24:47.759
I actually didn't make this up.

00:24:47.759 --> 00:24:52.059
And the great thing about this talk is that
it's not hard to come up with examples.

00:24:53.640 --> 00:24:59.170
[Laughter] So I'm going to-- this is actually
shown to me as the bug find by the Analyzer.

00:24:59.170 --> 00:25:01.370
When you feed up the code, it doesn't matter.

00:25:01.369 --> 00:25:04.279
And let's walk through what the Analyzer actually does.

00:25:04.279 --> 00:25:08.490
It starts analyzing paths from
the beginning of the function.

00:25:08.490 --> 00:25:11.509
So here we see that it looks at--
well, the first statement here is

00:25:11.509 --> 00:25:15.089
that result is declared and it's declared uninitialized, OK.

00:25:15.089 --> 00:25:19.649
So well, alright, we're going to record
that fact, result points to garbage.

00:25:19.650 --> 00:25:24.920
And then starts tracing the path through
this code until we hit the switch statement.

00:25:24.920 --> 00:25:30.060
And then we can see that the switch
dispatches on the value of the field sa_family.

00:25:30.059 --> 00:25:36.710
Now sa_family is a field of essentially value
that was pathed in as a function parameter.

00:25:36.710 --> 00:25:41.269
And so the Analyzer, because it's really just looking
at your code you know one function at time goes, "Well,

00:25:41.269 --> 00:25:44.369
I'm not going to make, I don't
have any assumptions about this--

00:25:44.369 --> 00:25:49.979
the value of this field, so I'm going to
assume it's what we call unconstraint,

00:25:49.980 --> 00:25:52.390
it could be any of the possible
values in the switch statement."

00:25:52.390 --> 00:25:59.180
So I'm going to consider each of those cases one by one, and
look at each of those paths that's spawned from this point.

00:25:59.180 --> 00:26:02.470
So let's look at the case where we go to case AF_INET6.

00:26:02.470 --> 00:26:06.870
In this case sa_family would have to have that value.

00:26:06.869 --> 00:26:12.619
And so at this point along this path we have
the constraint that sa_family has that value.

00:26:12.619 --> 00:26:17.489
If we go inside the case statement,
we then see this call to inet_ntop.

00:26:17.490 --> 00:26:20.890
Now the Analyzer doesn't have any
special knowledge about this function.

00:26:20.890 --> 00:26:26.060
But it sees that returns a point or
value is actually compared against null.

00:26:26.059 --> 00:26:32.159
Alright, so we'll the analyzers well goes well this value is
unconstrained but I know that you're comparing against null,

00:26:32.160 --> 00:26:35.430
so I'm going to assume that it
can either be null or not null.

00:26:35.430 --> 00:26:39.200
And we're going to look at those two
possibilities from this point on.

00:26:39.200 --> 00:26:47.269
For the case where it's null, if statement of
value is a false, jump to the break, and then we go

00:26:47.269 --> 00:26:51.490
and hit the return statement where return
result uninitialized to the caller.

00:26:51.490 --> 00:26:57.569
So this is a very systematic reasoning about what your
code is doing and exploring each one of these branches.

00:26:57.569 --> 00:26:59.359
And this is what you would see on Xcode.

00:26:59.359 --> 00:27:06.609
The Xcode has a much better job of drawing the arrows than
I do, and it actually tells you the relevant information.

00:27:06.609 --> 00:27:10.359
It shows you the point where the variable
was declared and where it was returned.

00:27:10.359 --> 00:27:16.969
So it gives you that full diagnosis
right there in the editor.

00:27:16.970 --> 00:27:19.470
So the Analyzer is awesome.

00:27:19.470 --> 00:27:23.809
I'm really proud of what we've done
but there are some limitations.

00:27:23.809 --> 00:27:26.929
First I want to talk about inherent limitations.

00:27:26.930 --> 00:27:34.390
Because the Analyzer abstracts way pieces information about
your program in order to reason about all these paths,

00:27:34.390 --> 00:27:38.200
because sometimes being precise
and we can have false positives.

00:27:38.200 --> 00:27:43.950
Sometimes the false positives are due to false paths, so
paths through your code that just couldn't actually occur.

00:27:43.950 --> 00:27:47.700
And I'll talk a little bit more later
about how you could go about fixing them.

00:27:47.700 --> 00:27:53.049
Second false positive occur because the
Analyzer doesn't know something that you know.

00:27:53.049 --> 00:27:56.750
You've got some assumption in your
head that's not reflected in the code,

00:27:56.750 --> 00:28:03.210
and those can often be addressed using
assertions, and I'll talk about that later as well.

00:28:03.210 --> 00:28:09.519
The second thing I want to talk about is that the
Static Analyzer is not going to find all of your bugs.

00:28:09.519 --> 00:28:15.250
I've talked-- mentioned earlier that it's not replacement
for testing or using a debugger, but more importantly,

00:28:15.250 --> 00:28:18.769
we have not designed it to be a program verifier.

00:28:18.769 --> 00:28:22.700
Static analysis tools that try
to verify that code is perfect.

00:28:22.700 --> 00:28:27.529
It tends to have a high number of false positives
since our goal is to make the tool useful, right?

00:28:27.529 --> 00:28:30.359
You don't want to go and look at a bunch of garbage results.

00:28:30.359 --> 00:28:37.459
So we're perfectly willing to miss some bugs as long as
we give you a high signal to noise ratio from the tool.

00:28:37.460 --> 00:28:39.829
And further, the static analysis tool is not magic.

00:28:39.829 --> 00:28:42.470
It's just a piece of software in itself.

00:28:42.470 --> 00:28:48.180
It won't find a bug unless it's been specifically
engineered to look for certain kinds of issues.

00:28:48.180 --> 00:28:53.500
If there are things that you would like it
to try and find, please just let us know.

00:28:53.500 --> 00:28:57.920
Now, some important current limitations with
the Analyzer and I've mentioned this before.

00:28:57.920 --> 00:29:03.380
Because the Analyzer only analyzes one
function at a time, it really loses information

00:29:03.380 --> 00:29:06.210
that spans across function call boundaries.

00:29:06.210 --> 00:29:09.960
This can lead to some false positives
and it can lead to some false negatives.

00:29:09.960 --> 00:29:15.190
This is something to keep in mind and it's
just a current limitation of the Analyzer.

00:29:15.190 --> 00:29:21.039
Second, many static analysis tools have been
engineered to try and go after buffer overflow checking.

00:29:21.039 --> 00:29:26.119
It's an interesting problem but
just one that we haven't focused on.

00:29:26.119 --> 00:29:28.059
So let's talk about workflow.

00:29:28.059 --> 00:29:32.299
Now that you understand a little bit more
about what the tool is doing underneath,

00:29:32.299 --> 00:29:37.519
how do you actually go about finding and fixing the bugs?

00:29:37.519 --> 00:29:43.809
So there were a few important goals that we
had in mind when engineering the Analyzer.

00:29:43.809 --> 00:29:48.149
The first is that we wanted you to use it very actively.

00:29:48.150 --> 00:29:51.130
As you're editing your code, we want you to feel

00:29:51.130 --> 00:29:55.290
that you can proactively run the
Analyzer and have it tell about issues.

00:29:55.289 --> 00:30:01.829
And the whole idea is that issues that are introduced
just recently can be fixed quickly and much more cheaply.

00:30:01.829 --> 00:30:06.240
And to do this, we want to experience where
you never had to actually leave your code.

00:30:06.240 --> 00:30:11.859
The worse thing that we could have done is that run
the Analyzer, it's looking at your code, and well,

00:30:11.859 --> 00:30:14.569
you suddenly get taken away, highjacked
into a separate user interface.

00:30:14.569 --> 00:30:16.539
>> This is horrible, right?

00:30:16.539 --> 00:30:19.379
This is just not an optimal experience
because you have to switch back

00:30:19.380 --> 00:30:25.000
and forth between editing your code
and seeing what the Analyzer tells you.

00:30:25.000 --> 00:30:30.019
Second, we wanted you to treat, looking
at Analyzer issues just the same

00:30:30.019 --> 00:30:32.170
as you look at regular compiler errors and warnings.

00:30:32.170 --> 00:30:36.200
If you think about all the things that the
Build system does, all the tools that it runs,

00:30:36.200 --> 00:30:40.930
it's basically giving you a whole bunch of feedback about
the current state of your code, about the current state

00:30:40.930 --> 00:30:44.900
of your program and it seems very
logical to centralize that in all

00:30:44.900 --> 00:30:49.980
in one place you get this wholistic view of what's going on.

00:30:49.980 --> 00:30:54.769
Third, we wanted to give you the
flexibility of when you run the Analyzer.

00:30:54.769 --> 00:30:59.639
We want to give you the ability to do both an on-demand
analysis of your code like I've illustrated already

00:30:59.640 --> 00:31:04.300
or just automatic analysis that every time
I hit Build I want my code to be analyzed.

00:31:04.299 --> 00:31:06.069
You now have this option.

00:31:06.069 --> 00:31:13.990
And we wanted all these to combine together to
create what I call the Analyze-fix-Analyze workflow,

00:31:13.990 --> 00:31:19.779
that is you're looking at your code, you
analyze it, you find bugs, you try and fix them,

00:31:19.779 --> 00:31:23.039
you analyze it again to see if you actually fix the issue.

00:31:23.039 --> 00:31:27.789
And if you want a quick turn-around time to
see if the issue actually has been addressed,

00:31:27.789 --> 00:31:30.839
and if it isn't, you can try and go and fix it again.

00:31:30.839 --> 00:31:37.159
And this is-- this-- it's really a key that you can do this
very rapidly in order to make the most out of the tool.

00:31:37.160 --> 00:31:42.080
And I think we have done a great job at accomplishing this.

00:31:42.079 --> 00:31:45.009
So let's review on-demand analysis.

00:31:45.009 --> 00:31:48.359
We have this new Build and Analyze option in the Build menu.

00:31:48.359 --> 00:31:51.439
It's actually has a keyword shortcut as well.

00:31:51.440 --> 00:31:57.559
And essentially what happens is that
your code is compiled and analyzed.

00:31:57.559 --> 00:32:03.259
Now the Build system knows your code
and knows what's actually been modified

00:32:03.259 --> 00:32:06.900
since the last time you compiled it
and the last time you analyzed it.

00:32:06.900 --> 00:32:12.009
So doing Build and Analyze is only going to
reanalyze the files that have been modified

00:32:12.009 --> 00:32:15.289
since the last time you ran the Analyzer.

00:32:15.289 --> 00:32:18.170
And this means you get incremental analysis.

00:32:18.170 --> 00:32:22.800
And so it means this enables the whole
Analyze-Fix-Analyze workflow that I mentioned

00:32:22.799 --> 00:32:26.039
that you could just be editing
your code and fix it, reanalyze it,

00:32:26.039 --> 00:32:30.069
and your entire project is not reanalyzed,
that would be the worst thing ever.

00:32:30.069 --> 00:32:33.179
You might have to wait a really
long time, it's a big project.

00:32:33.180 --> 00:32:35.490
You don't have that kind of latency.

00:32:35.490 --> 00:32:40.210
Now what about automatic analysis?

00:32:40.210 --> 00:32:41.480
Well you can now do automatic.

00:32:41.480 --> 00:32:44.049
You can do automatic analysis using a Build Option.

00:32:44.049 --> 00:32:47.970
So here's the Project Settings window.

00:32:47.970 --> 00:32:52.529
And under Build Options you now have
this Run Static Analyzer check box.

00:32:52.529 --> 00:33:00.049
And what this does is it basically makes
Build to be synonymous with Build and Analyze.

00:33:00.049 --> 00:33:04.950
And so it means every time your files
are compiled, they are also analyzed.

00:33:04.950 --> 00:33:10.200
And it's important to know that this isn't a transient
setting, it's persistent in your Xcode project.

00:33:10.200 --> 00:33:14.720
If you quite Xcode, bring it back up, this
setting is still persistent, you will still--

00:33:14.720 --> 00:33:17.509
you will still do an analysis every time you run a Build.

00:33:17.509 --> 00:33:20.769
Well what's cool about this is that
you can tailor this to your workflow.

00:33:20.769 --> 00:33:23.059
You can have this on a per-configuration basis.

00:33:23.059 --> 00:33:27.369
And I'll talk a little bit more in a
moment about how that can be useful.

00:33:27.369 --> 00:33:33.939
Now some important side effects about this
is that this is also picked up by xcodebuild.

00:33:33.940 --> 00:33:37.070
If you try and build your Xcode project from the terminal,

00:33:37.069 --> 00:33:41.929
you will actually see the Analyzer
emit diagnostics to the terminal.

00:33:41.930 --> 00:33:45.670
And so if that's of interest to
you, that's something you can do.

00:33:45.670 --> 00:33:50.019
If it's not of interest to you,
that's just something to be aware of.

00:33:50.019 --> 00:33:55.000
And the final point that people sometimes forget
is while we're trying them have the Analyzer run

00:33:55.000 --> 00:33:58.549
in a reasonable amount of time, if
your goal is to have a fast build time,

00:33:58.549 --> 00:34:04.309
you just keep in mind that it can either double
or triple easily when you run the Analyzer.

00:34:04.309 --> 00:34:07.509
And really the mileage-- your mileage
can be very just depending on your code.

00:34:07.509 --> 00:34:12.130
So it's something you can try out, see
what happens, and see what works for you.

00:34:12.130 --> 00:34:18.130
So how can you use that per-configuration
setting of the static--

00:34:18.130 --> 00:34:21.690
of Run Static Analyzer, how could
that actually going to benefit you?

00:34:21.690 --> 00:34:26.190
Well an Xcode project defaults of having
a debug and release configuration.

00:34:26.190 --> 00:34:28.679
Debug Build doesn't have any compiler.

00:34:28.679 --> 00:34:33.469
It doesn't really have any compiler optimizations
plus the compiler quick have faster round.

00:34:33.469 --> 00:34:38.169
Release, you want this to go mad and optimizer code.

00:34:38.170 --> 00:34:40.470
What if you want something that's somewhere in between?

00:34:40.469 --> 00:34:46.379
Well you have this option by creating a new
configuration which you can easily do just

00:34:46.380 --> 00:34:51.230
by duplicating the debug configuration,
renaming it to something like analyze,

00:34:51.230 --> 00:34:58.219
and then just setting the Run Static
Analyzer Build option for that configuration.

00:34:58.219 --> 00:35:03.959
Now what I-- this is useful is that you could enable a
whole set of other compiler warnings in this configurations.

00:35:03.960 --> 00:35:07.289
So now you can have the configuration
where I want to do extra checking

00:35:07.289 --> 00:35:10.179
or I want to run extra unit test and ran the Analyzer.

00:35:10.179 --> 00:35:14.559
So it's kind of like your progression kind of configuration.

00:35:14.559 --> 00:35:18.869
I think it's an interesting aspect of the
workflow that might really benefit you.

00:35:18.869 --> 00:35:28.059
So let's go and talk a little bit more of how do you
actually navigate results within the-- within Xcode.

00:35:28.059 --> 00:35:34.909
And for that, we're going to jump back to the demo.

00:35:34.909 --> 00:35:41.420
So we're going to look at the Build results for
Growl, so I can go ahead and minimize the Editor.

00:35:41.420 --> 00:35:43.090
And well, I've shown this before.

00:35:43.090 --> 00:35:44.480
This is actually only part of Growl.

00:35:44.480 --> 00:35:47.990
This is just one of the targets and
it says a lot of information here.

00:35:47.989 --> 00:35:51.759
And this is way too much for me to process.

00:35:51.760 --> 00:35:56.740
Well, the new Build Results window is really cool because
it allows you to look at varying levels of information.

00:35:56.739 --> 00:36:00.319
So if we go the top, there is this new filtration pull down.

00:36:00.320 --> 00:36:06.970
So right now it says all messages so that would include
the build steps and their warnings and errors produced.

00:36:06.969 --> 00:36:09.549
We can select issues only.

00:36:09.550 --> 00:36:15.730
And what you're going to see is only the actual
compiler warnings and the Analyzer issues.

00:36:15.730 --> 00:36:19.420
Now let's say I just wanted to look
at issues found by the Analyzer.

00:36:19.420 --> 00:36:26.260
I can further reduce this down just
by selecting Analyzer Results Only.

00:36:26.260 --> 00:36:33.520
And so it's a much more concise view of the
information that I get from the Build system.

00:36:33.519 --> 00:36:35.659
Now we're looking at it.

00:36:35.659 --> 00:36:38.480
Issues are now grouped by the file that they occurred in.

00:36:38.480 --> 00:36:41.900
Let's say I just wanted to look at particular kinds of bugs.

00:36:41.900 --> 00:36:50.700
We have now have this new By-Issue tab which
reorganizes the issue, reorganizes the compiler warnings

00:36:50.699 --> 00:36:54.909
and errors and Analyzer issues into logical groups.

00:36:54.909 --> 00:37:01.500
Analyze issues or groups by categories such as
memory managements, logic errors, dead stores.

00:37:01.500 --> 00:37:03.619
There are a lot of other categories in this Growl.

00:37:03.619 --> 00:37:07.759
This example only exhibits these 3.

00:37:07.760 --> 00:37:10.760
And this is great.

00:37:10.760 --> 00:37:15.760
But let's say I want to look at
only very specific kind of bug.

00:37:15.760 --> 00:37:19.450
Well now you can prune that down using Search.

00:37:19.449 --> 00:37:20.849
So let's go to the Search tool bar.

00:37:20.849 --> 00:37:25.179
Let's go ahead and just type the work
"leak", I just want to look at memory leaks.

00:37:25.179 --> 00:37:31.869
You'll notice that Xcode does a live filtration on-- textual
filtration on each of the rows in your Builder Results menu.

00:37:31.869 --> 00:37:35.539
So you can quickly go through the results of your build.

00:37:35.539 --> 00:37:37.559
And this includes searching for files.

00:37:37.559 --> 00:37:39.400
This includes searching for particular issues.

00:37:39.400 --> 00:37:43.059
So very quick way to get down to
the information that you want.

00:37:43.059 --> 00:37:46.529
So let's look at one of those, one of those bugs.

00:37:46.530 --> 00:37:51.170
We're going to take a look at New
Parent, so the leak involving New Parent.

00:37:51.170 --> 00:37:56.420
Let's go ahead and expand this disclosure
triangle over the top in the Build Results menu.

00:37:56.420 --> 00:38:04.289
Now what you notice is actually the complete set of events
within that bug, so you can not only navigate through

00:38:04.289 --> 00:38:06.809
and look at the different issues within the Build Results,

00:38:06.809 --> 00:38:11.529
but you can actually navigate specific
bug from the Build Results menu.

00:38:11.530 --> 00:38:14.210
So let's go ahead and click on one of those.

00:38:14.210 --> 00:38:19.769
And you see that it immediately takes us
into the editor right into the Analyzer mode.

00:38:19.769 --> 00:38:22.509
And it takes us at a particular
event that we were interested in.

00:38:22.510 --> 00:38:29.740
We could go ahead and navigate through this bug just in that
disclosed several events at the top or use the new tool,

00:38:29.739 --> 00:38:32.359
Navigation tool bar within the Editor, you can do both.

00:38:32.360 --> 00:38:36.870
And what's great about this is you can actually
quickly use just the keyboard to navigate

00:38:36.869 --> 00:38:40.389
through the individual Analyzer issues
and then within an individual bug.

00:38:40.389 --> 00:38:49.819
So I want to look at this bug just to show you one other
feature of the integration of the Analyzer into the Editor.

00:38:49.820 --> 00:38:54.920
This is a memory leak, and what kind of sucks
about this example is that it spends a lot

00:38:54.920 --> 00:38:57.920
of more code than I can view on the screen, right?

00:38:57.920 --> 00:39:04.530
So, we see this is the actual allocation site which is at
the first event and then laying down below, we register,

00:39:04.530 --> 00:39:07.360
we get this report that the object has been leaked.

00:39:07.360 --> 00:39:08.420
So this kind of sucks.

00:39:08.420 --> 00:39:16.190
But as we see that from after the allocation site, there's
this logic on Line 312 where name has compared against null

00:39:16.190 --> 00:39:20.059
and then we actually skip this big long else branch.

00:39:20.059 --> 00:39:23.250
Well what's cool is that Xcode's
called folding option work--

00:39:23.250 --> 00:39:25.670
feature works completely seamlessly with the Analyzer mode.

00:39:25.670 --> 00:39:28.570
So we just can go ahead and collapse that else block.

00:39:28.570 --> 00:39:36.990
And you see the errors draw read, draw alive, and we
can see just within a few line of code the actual bug.

00:39:36.989 --> 00:39:41.969
We can see where it was allocated and the set of
branches that were taken to actually release it.

00:39:41.969 --> 00:39:43.539
I mean for it to leave.

00:39:43.539 --> 00:39:45.009
This is really powerful.

00:39:45.010 --> 00:39:49.490
It allows you to just drill down to the
parts of the bug that mattered to you.

00:39:49.489 --> 00:39:53.919
So let's go ahead and fix this, what's happening here?

00:39:53.920 --> 00:39:56.119
There's a leak of parent.

00:39:56.119 --> 00:40:08.159
OK. Well, let's add a call to CFRelease of parent
right at the leak side, which is the parent.

00:40:08.159 --> 00:40:19.170
Now once again we're going to run Build
and Analyze and the leak should go away.

00:40:19.170 --> 00:40:22.159
>> OK, somehow I screwed up.

00:40:22.159 --> 00:40:27.379
Alright, I did something wrong, I didn't actually
fix the bug, instead I introduced a new one.

00:40:27.380 --> 00:40:28.730
And it's a much worse bug.

00:40:28.730 --> 00:40:32.199
It looks like I've over released the object.

00:40:32.199 --> 00:40:34.339
So well OK, let's see what I did wrong.

00:40:34.340 --> 00:40:39.329
Let's go ahead and click on that issue and
we can click through this just as before.

00:40:39.329 --> 00:40:42.259
As we see it's the same allocation site as before.

00:40:42.260 --> 00:40:46.730
It says involving the same object, but we
can-- with using the Navigation toolbar,

00:40:46.730 --> 00:40:50.530
let's just click through to see what happens.

00:40:50.530 --> 00:40:57.140
Notice that the block of code that I've previously
folded automatically expands because the issue, the bug,

00:40:57.139 --> 00:41:01.400
now occurs on that else branch that
I've previously thought was irrelevant.

00:41:01.400 --> 00:41:07.110
And we can see these pointless days that there's
now 2 CFRelease calls where we path parent.

00:41:07.110 --> 00:41:09.559
So this is the over release.

00:41:09.559 --> 00:41:17.070
So the nature of the bug here is that CFRelease, the call
CFRelease was buried too far in within the conditional,

00:41:17.070 --> 00:41:20.960
so that the fix is just to remove the
original one, we're going to just comment it

00:41:20.960 --> 00:41:24.019
out to you don't forget that it was there.

00:41:24.019 --> 00:41:29.900
We'll Build and Analyze again, and the bug disappears.

00:41:29.900 --> 00:41:35.400
So once again, you have this fast tight
workflow within Xcode to find and fix bugs.

00:41:35.400 --> 00:41:40.220
And if you screw up and don't fix it correctly,
the Analyzer will give you quick feedback.

00:41:40.219 --> 00:41:43.989
Now notice that we didn't rebuild all of Growl, right?

00:41:43.989 --> 00:41:50.209
The only thing that happened was that this file was
reanalyzed so we got a very quick turn-around time

00:41:50.210 --> 00:41:53.710
and this is really what makes this feature just shine.

00:41:53.710 --> 00:41:57.380
And I haven't seen this in any
commercially available static analysis tool.

00:41:57.380 --> 00:42:00.180
And you get if for free.

00:42:00.179 --> 00:42:07.879
So let's go ahead and switch back to the slides?

00:42:07.880 --> 00:42:13.670
So lets talk about my favorite
part for the talk and that's bugs.

00:42:13.670 --> 00:42:19.559
This is all about bugs that house what kind
of issues does the Analyzer actually find?

00:42:19.559 --> 00:42:22.670
Well, we care a lot about Cocoa and Core Foundation.

00:42:22.670 --> 00:42:27.130
These are the cornerstone APIs for
doing iPhone and Mac development.

00:42:27.130 --> 00:42:32.990
And so naturally, we're interested in finding
bugs related to the use of these APIs.

00:42:32.989 --> 00:42:37.599
We've engineered a growing set of API checks and I'm
going to illustrate one of them on the next slide.

00:42:37.599 --> 00:42:40.849
And then we've also done a tremendous
amount of work on trying

00:42:40.849 --> 00:42:44.059
to do memory management checking using static analysis.

00:42:44.059 --> 00:42:47.869
And you might think that memory
management, that's kind of hard.

00:42:47.869 --> 00:42:49.319
The Cocoa is engineered.

00:42:49.320 --> 00:42:53.720
It's designed to have very strong
interfaces with how you use these objects.

00:42:53.719 --> 00:42:59.539
And the Analyzer is designed to check that you're using
these objects in conformance with the Cocoa conventions.

00:42:59.539 --> 00:43:06.809
And the idea is if you follow conventions pretty strictly,
your code is practically guaranteed to be leak-free.

00:43:06.809 --> 00:43:12.110
I'm also going to talk about this
general language -evel or logic errors.

00:43:12.110 --> 00:43:14.190
We showed the uses of uninitialized values.

00:43:14.190 --> 00:43:17.730
This is also going to include things like null dereferences.

00:43:17.730 --> 00:43:21.980
And then a real pearl that people
often overlook is dead stores.

00:43:21.980 --> 00:43:26.389
It's a form of dead code checking that
could find some truly hideous bugs.

00:43:26.389 --> 00:43:30.119
And then in this discussion, I
want to talk about false positives.

00:43:30.119 --> 00:43:35.039
It's something that we work-- continually work
hard to make the Analyzer better at having lower

00:43:35.039 --> 00:43:38.599
and lower false positives, but it's
something that you will likely encounter.

00:43:38.599 --> 00:43:42.319
And we want to talk about the different
ways in which you can deal with them.

00:43:42.320 --> 00:43:47.080
In some cases, it's more about your code
not really documenting its assumptions

00:43:47.079 --> 00:43:49.509
and the Analyzer doing something wrong.

00:43:49.510 --> 00:43:54.160
So here is a Core Foundation API check.

00:43:54.159 --> 00:44:01.929
There is this function called CFNumberCreate
which returns CFNumber objects.

00:44:01.929 --> 00:44:06.919
And CFNnumber objects can totally free bridge
over via casting to Cocoa and its number objects.

00:44:06.920 --> 00:44:13.869
So you-- it's not uncommon for this
function to appear in Objective-C code.

00:44:13.869 --> 00:44:16.589
Now it's interesting the way this function is designed.

00:44:16.590 --> 00:44:23.390
Essentially what you do is you pass in a
pointer, a void* reference to some integer.

00:44:23.389 --> 00:44:28.579
And then you tell CFNumberCreate what is the
type of that integer by passing the second--

00:44:28.579 --> 00:44:33.340
the second parameter which is this i num value.

00:44:33.340 --> 00:44:38.740
Now in this case, the function is being called
by specifying-- you should expect a long.

00:44:38.739 --> 00:44:45.309
And sure enough when you're compiling for a 32-bit
architecture both unsigned and long have the same size.

00:44:45.309 --> 00:44:54.900
Now if you suddenly decide to move over to 64-bit which
we're encouraging you to do, this is not totally awesome.

00:44:54.900 --> 00:44:58.380
What happens is long is now 8 bytes long.

00:44:58.380 --> 00:45:05.840
And so CFNumberCreate when it's trying to create the
CFNumber object, it's going to read 4 bytes after the end

00:45:05.840 --> 00:45:12.519
of i, so it's reading essentially garbage and the
results can be completely not what you expected.

00:45:12.519 --> 00:45:18.420
This is actually a real bug that's occurred several
times since just partially is due to this API,

00:45:18.420 --> 00:45:25.480
but the Analyzer can now check it for you and try
to ensure that your-- code is more 64-bit friendly.

00:45:25.480 --> 00:45:29.269
So there are just little things
like this where it'll be very hard

00:45:29.269 --> 00:45:31.380
to catch this bug even you could you actually run it.

00:45:31.380 --> 00:45:35.950
But the Analyzer pinpoints to you
exactly where the error occurred.

00:45:35.949 --> 00:45:39.029
And here is how it appears in Xcode.

00:45:39.030 --> 00:45:44.160
There's actually this tremendously verbose
message, telling you exactly what went wrong

00:45:44.159 --> 00:45:48.079
and it's basically saying the size
of these-- of your objects--

00:45:48.079 --> 00:45:53.650
the size of CFNumberCreate expected was
64 bits and you fed it a 32-bit number2.

00:45:53.650 --> 00:45:59.150
So Cocoa Memory Management.

00:45:59.150 --> 00:46:03.000
This is really where we try to make the Analyzer shine.

00:46:03.000 --> 00:46:08.949
The Analyzer is basically trying to enforce
the Cocoa object ownership conventions

00:46:08.949 --> 00:46:12.750
and these are documented into these 2 ADC documentation.

00:46:12.750 --> 00:46:18.750
These are freely available and if you haven't
read it yet, you're strongly encouraged to do so.

00:46:18.750 --> 00:46:22.539
Now I mentioned before about garbage collection.

00:46:22.539 --> 00:46:28.610
Ejector C 2.0 supports garbage collection when
you're targeting Leopard or later and the conventions

00:46:28.610 --> 00:46:33.019
for using garbage collection are also documented
in the garbage collection programming guide.

00:46:33.019 --> 00:46:36.440
The Analyzer's garbage collection-aware.

00:46:36.440 --> 00:46:40.990
There's these different flags that get passed to the
compiler basically to tell you, tell it whether the code is

00:46:40.989 --> 00:46:45.039
to be compiled to either run with either garbage collection

00:46:45.039 --> 00:46:50.099
or traditional ran retain counts,
that's the fobjc-gc option.

00:46:50.099 --> 00:46:55.699
The second is if you're compiling code that
only should run with garbage collection.

00:46:55.699 --> 00:46:58.169
And the last case is if there's no flag.

00:46:58.170 --> 00:47:01.170
This is just the traditional-- the traditional model.

00:47:01.170 --> 00:47:05.530
If you're doing iPhone development,
you're not going to use garbage collection

00:47:05.530 --> 00:47:09.530
and so you have the option to use
garbage collection on the Mac.

00:47:09.530 --> 00:47:13.610
Again the garbage collection flags are
only specific to Leopard or higher.

00:47:13.610 --> 00:47:19.620
And what I want to emphasize is the Analyzer sees
these flag and will analyze your code accordingly.

00:47:19.619 --> 00:47:22.799
It will see-- if you intended it to
either be used for garbage collection

00:47:22.800 --> 00:47:25.750
or not in garbage collection, it
will analyze it for both cases.

00:47:25.750 --> 00:47:30.880
If it's only intended to be used for garbage
collection, it will just analyze it for that scenario.

00:47:30.880 --> 00:47:35.800
So what about naming conventions?

00:47:35.800 --> 00:47:40.960
How does the Analyzer actually infer
that objects are allocated and released?

00:47:40.960 --> 00:47:43.909
Well Cocoa is actually very simple.

00:47:43.909 --> 00:47:49.529
In the Cocoa programming memory management guide,
we talked about this naming conventions or methods.

00:47:49.530 --> 00:47:54.100
So methods that start with alloc
or new or contain copy are expected

00:47:54.099 --> 00:47:57.299
to return a known objects, specific
contract on these methods.

00:47:57.300 --> 00:48:02.130
If people don't necessarily understand
it, these are guidelines not only just

00:48:02.130 --> 00:48:06.539
for our own APIs, but we really encourage you to use this.

00:48:06.539 --> 00:48:10.159
It's basically what programming in Cocoa means.

00:48:11.420 --> 00:48:17.680
Core Foundation which is a CAPI has
a similar, has similar conventions.

00:48:17.679 --> 00:48:21.940
You can use the-- if you have the keywords
create or copy and the Core Foundation function

00:48:21.940 --> 00:48:24.309
in the case that it returns a known object.

00:48:24.309 --> 00:48:30.059
And the key thing to note here is
that create is not a Cocoa convention.

00:48:30.059 --> 00:48:38.059
And this is something that's been really
emphasized to me by the Cocoa framework's curators.

00:48:38.059 --> 00:48:41.789
This is something they don't want to actually
enforce, so they've could explicitly ask

00:48:41.789 --> 00:48:44.610
that it's not support any outlines there.

00:48:44.610 --> 00:48:50.370
But you have-- you have a way out or you have other options.

00:48:50.369 --> 00:48:52.190
I'll talk about that later.

00:48:52.190 --> 00:48:56.980
So I've always showed you some examples with leaks.

00:48:56.980 --> 00:49:01.380
The main thing I want to show is just how
much information the Analyzer gives you.

00:49:01.380 --> 00:49:08.030
So this is an example of using NSMutableDictionary and
calling dictionary with capacity which returns you an object

00:49:08.030 --> 00:49:10.610
that is not the caller's responsibility to release.

00:49:10.610 --> 00:49:14.000
It's going to be autoreleased or
whatever, it's not your responsibility.

00:49:14.000 --> 00:49:18.989
And then we go ahead and mess around with the
retain counts by sending retain or release.

00:49:18.989 --> 00:49:23.899
So this is contrive bit of code and there's a leak here
and the Analyzer is going to give you a lot of information.

00:49:23.900 --> 00:49:27.860
It's going to tell you each time that you
retain that particular object and where it was--

00:49:27.860 --> 00:49:31.809
where it was actually send a release message.

00:49:31.809 --> 00:49:35.090
Now if you imagine the code, it's
much spread over a lot more code.

00:49:35.090 --> 00:49:40.610
This is actually really useful, you know it's buddying
exactly where the retainer release has occurred.

00:49:40.610 --> 00:49:45.220
So what about leaks, under garbage collection?

00:49:45.219 --> 00:49:49.429
Garbage collection is a great technology
available on Leopard

00:49:49.429 --> 00:49:55.589
that will make programming many Objective-C apps much
easier, but you need to use it correctly in order

00:49:55.590 --> 00:49:58.019
to make sure that your code is leak-free.

00:49:58.019 --> 00:50:03.590
The main thing to keep in mind is that Core Foundation
objects are not automatically garbage collected.

00:50:03.590 --> 00:50:10.530
And because this can be toll-free bridge over to
Cocoa objects, it's very easy to lose track of this.

00:50:10.530 --> 00:50:16.680
>> So here is a real example of code that is leak free
when using traditional retain counts but then leaks

00:50:16.679 --> 00:50:20.069
like a sieve when you use garbage collection.

00:50:20.070 --> 00:50:26.530
The problem here is that we create a Core Foundation
object which then is returned at the very end casted

00:50:26.530 --> 00:50:29.730
to an NSString, so it's returned as a Cocoa object.

00:50:29.730 --> 00:50:34.480
And because we're using garbage collection, the
caller is not going to expect it to actually--

00:50:34.480 --> 00:50:38.559
have to manually release it using CF release.

00:50:38.559 --> 00:50:43.920
And so the Analyzer actually tells you about this
and these are very verbose because people tend not

00:50:43.920 --> 00:50:48.889
to understand how they can leak objects
when they're using garbage collection.

00:50:48.889 --> 00:50:53.329
The first diagnostic tells you you're returning a Core
Foundation object and if you floated your mouse over,

00:50:53.329 --> 00:50:59.199
you will get a tool tip saying these are not
automatically collected when using garbage collection.

00:50:59.199 --> 00:51:04.219
Then you get a reminder message that when you're
using garbage collection, auto release does nothing.

00:51:04.219 --> 00:51:11.419
Just in case that you forgot that this was what--
this was your safety mechanism for freeing your memory

00:51:11.420 --> 00:51:20.300
and then finally there is this warrantees diagnostic that
tells you what you did wrong and I try to trim this down

00:51:20.300 --> 00:51:25.390
but whenever I did, people didn't
really understand what was going on.

00:51:25.389 --> 00:51:29.949
Basically, you're returning object that the
caller expects is going to be garbage collector,

00:51:29.949 --> 00:51:33.409
but it still has this positive 1 retain count.

00:51:33.409 --> 00:51:38.009
And so, it's never going to get released
and so every time this method is called,

00:51:38.010 --> 00:51:42.780
it's going to leak memory and these are very hard to catch.

00:51:42.780 --> 00:51:48.120
But because, we have strong interfaces in Cocoa
we can check for them with static analysis.

00:51:48.119 --> 00:51:54.049
And so the solution here is to use of CF made collectible
which registers the object with garbage collector.

00:51:54.050 --> 00:52:03.650
So, Cocoa conventions, the Analyzer finds
memory leaks by enforcing Cocoa conventions.

00:52:03.650 --> 00:52:09.110
What if your own code does not
strictly follow Cocoa conventions?

00:52:09.110 --> 00:52:10.539
This can cause false positives

00:52:10.539 --> 00:52:13.949
The Analyzer would tell you that you
are leaking in places where you're not.

00:52:13.949 --> 00:52:19.710
They can also tell you places where you are
overall releasing an object where you're not.

00:52:19.710 --> 00:52:26.630
The reason it does this is because the Analyzer is
just trying to follow what it thinks is the right way

00:52:26.630 --> 00:52:32.130
to do Cocoa programming and if there is some other
structure in your code that deviates from that

00:52:32.130 --> 00:52:39.140
which isn't necessarily bad, it just doesn't
know what's the right way for things to be done.

00:52:39.139 --> 00:52:42.690
Now, what we suggest you do is we actually really want you

00:52:42.690 --> 00:52:46.880
to rename your methods just so
that they follow Cocoa conventions.

00:52:46.880 --> 00:52:52.450
This is somewhat draconian but it's going to
make your code much easier to read by others

00:52:52.449 --> 00:52:58.349
and if you can use Xcode's core refactoring
feature to rename your methods across your project.

00:52:58.349 --> 00:53:05.009
Now, if you're really recalcitrant against
doing that, you have another option.

00:53:05.010 --> 00:53:08.390
We used to pride these new ownership
annotations which allow you

00:53:08.389 --> 00:53:13.009
to specifically document that a
method returns an owned object.

00:53:13.010 --> 00:53:18.390
So, this is a code fragment from Vienna
which is an open source RSS reader.

00:53:18.389 --> 00:53:22.989
And what you see here is these two methods
perform query and perform query with format

00:53:22.989 --> 00:53:27.559
which returned essentially this
SQL result object that's owned

00:53:27.559 --> 00:53:33.739
So, it's a result of a query but it doesn't
contain the keywords alloc, or new, or copy.

00:53:33.739 --> 00:53:39.399
There's no way for the Analyzer-- Well, the Analyzer
actually can analyze the implementation of these functions,

00:53:39.400 --> 00:53:47.240
but in general just by looking at the names of these
methods, they can't tell is this object going to be owned

00:53:47.239 --> 00:53:51.529
or is it not going to be owned and honestly, anybody
else looking at this code is not going to either.

00:53:51.530 --> 00:53:55.140
It's just an implementation detail of the code base.

00:53:56.590 --> 00:54:02.980
Now, you can add the NS_RETURNS_RETAINED annotations at
the end of your method declarations to educate the Analyzer

00:54:02.980 --> 00:54:05.300
that this is the contract for this method.

00:54:05.300 --> 00:54:08.990
It will then assume that returns an owned object.

00:54:08.989 --> 00:54:15.479
So for all the callers that will use this new, this
convention, and when analyzing the implementation

00:54:15.480 --> 00:54:20.240
of these methods it will assume that the
method is supposed to return an owned object.

00:54:20.239 --> 00:54:26.599
Now these macros are only currently
available when you're targeting Snow Leopard.

00:54:26.599 --> 00:54:31.529
You get them just by including the standard
foundation and Core Foundation headers.

00:54:31.530 --> 00:54:38.019
We also provide a CF_RETURNS_RETAINED macro which does
essentially the same thing except that it indicates

00:54:38.019 --> 00:54:42.380
that it return a Core Foundation object and
this is really important when you're dealing

00:54:42.380 --> 00:54:46.240
with garbage collection as I illustrated previously.

00:54:46.239 --> 00:54:52.519
Now, if you are targeting the iPhone or a previous
version of Mac OS X you're not out of luck.

00:54:52.519 --> 00:55:02.619
It'd been actually defined in these macros in yourself and
it's using essentially this if def free processor logic.

00:55:02.619 --> 00:55:09.960
And so essentially, these macros expand to claim specific
attributes that are added to these method declarations.

00:55:09.960 --> 00:55:16.360
Now you don't need to memorize this 'cause actually
they've provided it on the clang.llvm.org website.

00:55:16.360 --> 00:55:20.539
So there you have it, structured
annotations annotating your code

00:55:20.539 --> 00:55:24.699
that explicitly says whether or
not you return owned objects.

00:55:24.699 --> 00:55:30.009
And for those of you who do not want to rename your methods,
you now have an option to clearly document your assumptions

00:55:30.010 --> 00:55:36.870
within help of the Analyzer as well as other
people understand what your code is doing.

00:55:36.869 --> 00:55:40.719
So what other checks does the Analyzer perform?

00:55:40.719 --> 00:55:47.609
I'm not going to go into all of these in real detail but
it's a variety of checks that are done simply by reading

00:55:47.610 --> 00:55:53.789
about the semantics of your code, null
dereferences, uses of initialized values,

00:55:53.789 --> 00:55:55.579
returning the address of a stack variable.

00:55:55.579 --> 00:55:59.630
Obviously, really bad because it doesn't right-- when
you're returning an address of the stack variable,

00:55:59.630 --> 00:56:02.230
you're no longer referencing a valid object.

00:56:02.230 --> 00:56:06.820
It's also illegal in some cases
to send nil, send a message to nil

00:56:06.820 --> 00:56:11.090
because the returned value will be
garbage, and so on and so forth.

00:56:11.090 --> 00:56:16.559
There is many little checks that the
Analyzer does just by analyzing your code.

00:56:16.559 --> 00:56:18.559
So let's talk about null dereferences.

00:56:18.559 --> 00:56:27.579
This is a real bug in Wolfenstein3D for iPhone and
it happens to deal with using the ogg vorbis API.

00:56:27.579 --> 00:56:34.299
And what I want to illustrate about this is that we see
that the pointer VI which basically is passed

00:56:34.300 --> 00:56:37.970
in from a caller is checked against
null in the ternary operator

00:56:37.969 --> 00:56:42.489
and you see the arrows actually show the
control flow within the ternary operator.

00:56:42.489 --> 00:56:47.259
And you're going to see this also for using
short circuit operators like && or ||.

00:56:47.260 --> 00:56:54.620
So logical operation, you're going to see exactly
what is the reasoning of the Analyzer performed.

00:56:54.619 --> 00:56:58.509
And then what happens after these null
check works is well, you check it for null

00:56:58.510 --> 00:57:01.220
and I am going to assume that the pointer is null.

00:57:01.219 --> 00:57:05.779
Down below it's dereferenced in
the condition for the for loop.

00:57:05.780 --> 00:57:10.480
So can this actually occur?

00:57:10.480 --> 00:57:14.780
The Analyzer is just looking at
this function in isolation, alright.

00:57:14.780 --> 00:57:20.560
This value has been passed in through one of the arguments.

00:57:20.559 --> 00:57:28.699
The Analyzer does not have any prior assumptions about the
value of this pointer, but because the code itself checks it

00:57:28.699 --> 00:57:32.739
for null, it assumes that it could
be null, and therefore it's going

00:57:32.739 --> 00:57:36.729
to flag an instance later on where
you go and dereference it.

00:57:36.730 --> 00:57:42.460
And so even if the coded-- if all
the callers, this function,

00:57:42.460 --> 00:57:47.090
never pass in the case where it could be
null, this is actually going to be flagged.

00:57:47.090 --> 00:57:49.240
So should you interpret it?

00:57:49.239 --> 00:57:50.799
We have 2 responses.

00:57:50.800 --> 00:57:53.210
The Analyzer is wrong.

00:57:53.210 --> 00:57:57.130
It is reporting the above that
can-- that doesn't actually occur.

00:57:57.130 --> 00:58:03.640
Well, that's one way to interpret it, but there's--
I think there's a better way to look at it.

00:58:03.639 --> 00:58:08.379
Second, if you're checking for null, why are you
checking for a null if it never could be null?

00:58:08.380 --> 00:58:14.680
If it really could be null, there should probably be an
assertion in here or if later on, well it could be null.

00:58:14.679 --> 00:58:17.069
Well, it looks like you have a null dereference.

00:58:17.070 --> 00:58:19.710
In either case, the code is confused, right?

00:58:19.710 --> 00:58:26.380
It either it should clearly document its assumption that the
pointer can't be null or should handle the case where it is.

00:58:26.380 --> 00:58:29.900
And so in either way, the Analyzer
is providing useful feedback,

00:58:29.900 --> 00:58:32.660
telling you that there's something
potentially wrong in your code.

00:58:32.659 --> 00:58:37.049
And many of the other logic errors that
the Analyzer reports are like this.

00:58:37.050 --> 00:58:41.560
They just follow from looking at the
assumptions that the code itself documents,

00:58:41.559 --> 00:58:45.299
and it's just telling you a feedback
based on those assumptions.

00:58:45.300 --> 00:58:49.910
And I wanted you to keep this in mind as we talk
about how do you handle false positives later.

00:58:49.909 --> 00:58:53.759
So dead stores.

00:58:53.760 --> 00:58:55.080
What are they?

00:58:55.079 --> 00:58:59.699
It is a simple kind of dead code check.

00:58:59.699 --> 00:59:04.089
The basic idea is that you do some kind
of computation and then you store that--

00:59:04.090 --> 00:59:09.150
that the result of that computation to
a variable and then you forget about it.

00:59:09.150 --> 00:59:17.090
So this can easily indicate broken logic in a code
like dead code or just you're doing something wrong

00:59:17.090 --> 00:59:20.710
or just missed the optimization opportunities.

00:59:20.710 --> 00:59:23.000
So we'll show you a few examples.

00:59:23.000 --> 00:59:26.199
This is something that people tend not to really appreciate.

00:59:26.199 --> 00:59:28.879
This is a real code example.

00:59:28.880 --> 00:59:32.670
I've renamed some of the methods here and
really the-- a little bit of the extra logic.

00:59:32.670 --> 00:59:34.950
But this is-- this is a real bug.

00:59:34.949 --> 00:59:38.989
We see 2 dead * warnings reported by Xcode.

00:59:38.989 --> 00:59:43.469
And what you see here is there are these 2 methods
that do some work and are basically recording

00:59:43.469 --> 00:59:47.549
in this pool whether or not something bad happened.

00:59:47.550 --> 00:59:52.039
But the problem is that whether or not something
bad happened gets completely obliterated.

00:59:52.039 --> 00:59:56.710
On the last line when we just unconditionally
overwrite every thing as fine.

00:59:56.710 --> 01:00:01.550
This is really not what the code intended to do.

01:00:01.550 --> 01:00:06.230
I mean, it looks like it was written to
handle failure and it's actually not.

01:00:06.230 --> 01:00:07.869
So this is an actual real logic bug.

01:00:07.869 --> 01:00:15.529
And it's very simple but it's clearly indicating that
the code is just-- isn't doing what it expected to.

01:00:15.530 --> 01:00:19.650
>> There's a real dead store in Growl and
this is just-- this is a really simple bug.

01:00:19.650 --> 01:00:26.230
Here we see that's the variable
second is assigned a string constant.

01:00:26.230 --> 01:00:32.360
There's a missing break statement, so it just falls through
to default where then it gets overwritten with the value NO.

01:00:32.360 --> 01:00:38.349
It's a kind of a cosmetic bug but it's still
a real logic issue and this code is dead.

01:00:38.349 --> 01:00:40.679
It's not doing anything.

01:00:40.679 --> 01:00:45.339
And the problem here is have-- not having
a break statement is not a crime in itself.

01:00:45.340 --> 01:00:49.930
The problem is that the code is just
not doing what the developer expected.

01:00:49.929 --> 01:00:52.710
And so this is easily fixed just by adding break.

01:00:52.710 --> 01:01:02.300
Here's a dead store in Word Press for iPhone and this
is probably, mainly just an optimization opportunity.

01:01:02.300 --> 01:01:08.060
What you see here is there's this method called
to get the string and the string is never used.

01:01:08.059 --> 01:01:13.039
So well, that means either the string
was supposed to be used, and it--

01:01:13.039 --> 01:01:21.690
it's not being used so that's badness
or this is not needed anymore.

01:01:21.690 --> 01:01:25.909
And I think, well, if it's not needed anymore,
will the compiler will just optimize this away.

01:01:25.909 --> 01:01:30.109
That's actually not the case because
Objective-C is such a dynamic language.

01:01:30.110 --> 01:01:35.530
It cannot remove these message calls,
these message sends for Objective-C.

01:01:35.530 --> 01:01:38.820
I mean this method could do anything.

01:01:38.820 --> 01:01:44.180
And so the Analyzer is telling you this
is either a dead code or a potential--

01:01:44.179 --> 01:01:47.889
a logic bug or a potential optimization opportunity.

01:01:47.889 --> 01:01:55.219
And if it's really not doing anything,
it's just slowing the app down.

01:01:55.219 --> 01:02:01.169
Now, dead store, the check itself is actually very
accurate, but it can produce a lot of warnings for things

01:02:01.170 --> 01:02:06.430
that you know are dead stores but
you don't really care about them.

01:02:06.429 --> 01:02:09.139
You can handle that in two ways.

01:02:09.139 --> 01:02:16.549
You can file to dead store warning by saying that the
variable itself is unused and if you use pragma unused

01:02:16.550 --> 01:02:21.450
or you can use the GCC attribute unused
which goes on the variables declaration.

01:02:21.449 --> 01:02:27.000
Sometimes people introduce dead store because they're doing
some kind of programming for debugging so that it can run

01:02:27.000 --> 01:02:29.159
through the debugger and print out values.

01:02:29.159 --> 01:02:30.299
That's fine.

01:02:30.300 --> 01:02:35.340
You can tell the Analyzer to be quiet
by analyzing-- adding these attributes.

01:02:35.340 --> 01:02:40.250
And because both of these are standard annotations
provided by GCC, you can use them in either for iPhone

01:02:40.250 --> 01:02:43.329
or Mac development without doing anything special.

01:02:43.329 --> 01:02:47.179
Now, how about suppressing false paths?

01:02:47.179 --> 01:02:50.909
These are just bogus paths to your
code that just couldn't really occur.

01:02:50.909 --> 01:03:00.000
So consider this example where we are initializing this
pointer because we're going to go through this loop

01:03:00.000 --> 01:03:04.320
and we expect that the loop is
going to be executed at least once.

01:03:04.320 --> 01:03:06.650
Well, the Analyzer doesn't necessary have that knowledge.

01:03:06.650 --> 01:03:11.750
So if you run it on this code, it would print
this path out where you actually didn't--

01:03:11.750 --> 01:03:17.380
the loop condition will validate the false and you never
went inside the loop unless you have an older reference.

01:03:17.380 --> 01:03:23.950
The problem here is the Analyzer doesn't know your
assumptions and the code doesn't reflect it either.

01:03:23.949 --> 01:03:28.809
You can easily silence this issue by just
adding assertion after the loop saying

01:03:28.809 --> 01:03:31.909
that I expect that the pointer is not null.

01:03:31.909 --> 01:03:33.250
Now this has two benefits.

01:03:33.250 --> 01:03:37.550
One is shuts the Analyzer up, but the documents
are assumptions so that other people can look

01:03:37.550 --> 01:03:40.140
at your code and understand what's going on.

01:03:40.139 --> 01:03:46.339
And in the off chance that you're assumption
is wrong, you can now catch it at run time.

01:03:46.340 --> 01:03:49.490
So instead of just having, you
know, silently missing an error.

01:03:49.489 --> 01:03:59.689
Now this is a code fragment that I see over and over
again and it's kind of interesting 'cause it's kind

01:03:59.690 --> 01:04:03.889
of inefficient and it's also kind of buggy.

01:04:03.889 --> 01:04:09.659
So if you run the Analyzer over it, it sees
all these necessary if else statements.

01:04:09.659 --> 01:04:15.009
It doesn't know that tag might return
the values just between 0 and 2.

01:04:15.010 --> 01:04:16.240
It actually might not.

01:04:16.239 --> 01:04:17.209
It doesn't know.

01:04:17.210 --> 01:04:19.380
And code doesn't reflect it either.

01:04:19.380 --> 01:04:24.970
And so we'll actually flag a warning in this
case if you use this value on initialized.

01:04:24.969 --> 01:04:28.449
This is easily solved by just rewriting the code.

01:04:28.449 --> 01:04:33.889
We're going to replace the last else if
with an else that just has an assertion

01:04:33.889 --> 01:04:35.809
and there you're just documenting your assumptions.

01:04:35.809 --> 01:04:39.920
You're saying what I expect the code to do.

01:04:39.920 --> 01:04:44.119
Now, a better way to write this is with a switch
statement which actually just calls, you know

01:04:44.119 --> 01:04:50.119
sense the tag message "wants" which is much cheaper
and it's much cleaner and you can just add an assertion

01:04:50.119 --> 01:04:57.730
for the default case that says this is not fit, this is not
possible and there will be no waring in this case as well.

01:04:57.730 --> 01:05:04.230
So the moral of story is you should always
analyze your code when you use assertions,

01:05:04.230 --> 01:05:09.550
'cause assertions document your assumptions
and the Analyzer can learn from them.

01:05:09.550 --> 01:05:12.180
Assertions are always disabled when you do a release bill.

01:05:12.179 --> 01:05:19.469
There are these macros that are pound to find out when
you actually want to compile your code to run fast.

01:05:19.469 --> 01:05:26.209
So it means you should analyze your code only in
the debug configuration or something similar to it.

01:05:26.210 --> 01:05:31.550
Now, if you happen to write your
own accustom assertion handlers,

01:05:31.550 --> 01:05:34.950
the Analyzer doesn't necessarily know about these functions.

01:05:34.949 --> 01:05:41.629
You can easily educate it by using the GCC attributes
noreturn or the Clang specific attribute Analyzer_noreturn.

01:05:41.630 --> 01:05:46.150
They're very similar to the attributes I talked
about earlier and I'm not going to go into them

01:05:46.150 --> 01:05:48.309
but they're documented on the Clang website.

01:05:48.309 --> 01:05:52.980
So the Analyzer is steadily improving.

01:05:52.980 --> 01:05:55.090
It's brand new in Xcode.

01:05:55.090 --> 01:05:58.740
We've done a lot of work on it but
there's so much more we can do.

01:05:58.739 --> 01:06:02.809
I want to remind you that it's 100 percent open source.

01:06:02.809 --> 01:06:10.690
This has just been really great for getting a lot of testing
over the Analyzer and feedback from developers like you.

01:06:10.690 --> 01:06:16.970
It's really important that if you see the Analyzer
doing something done, that you tell us about it.

01:06:16.969 --> 01:06:19.199
It's the only way we can fix this.

01:06:19.199 --> 01:06:22.189
So please tell us about false positives.

01:06:22.190 --> 01:06:26.329
Now, I look at blogs and I look at Twitter, the best way,

01:06:26.329 --> 01:06:30.829
you make sure that information gets
to us is by filing blog reports.

01:06:32.110 --> 01:06:38.970
Also, if you're excited about this feature, please
tell us about what bugs are important to you.

01:06:38.969 --> 01:06:43.799
This is the only way we can prioritize to
get the maximum yield out of this feature.

01:06:43.800 --> 01:06:49.000
And you can report bugs using the typical
Apple interface, bugreporter.apple.com.

01:06:49.000 --> 01:06:54.400
And this is also a great place for suggestions on how you
want to improve the Xcode workflow and your experience,

01:06:54.400 --> 01:06:57.510
the Analyzer itself, or just feature suggestions.

01:06:57.510 --> 01:07:00.330
That's a great way to tell us what you think.

01:07:00.329 --> 01:07:04.599
You can also file blog reports
for the Clang, Bugzilla website.

01:07:04.599 --> 01:07:09.819
This is for things that-- this is the open source avenue.

01:07:09.820 --> 01:07:14.280
Note that this is out in the open so
you shouldn't really mention anything

01:07:14.280 --> 01:07:16.740
that would-- you wouldn't mind being public.

01:07:16.739 --> 01:07:18.859
But also it's a great way to get that information

01:07:18.860 --> 01:07:23.349
to the entire open source community
working on Clang and the Analyzer.

01:07:23.349 --> 01:07:32.989
So today, we talked about an exciting new feature in Xcode
that's going to allow you to find bugs faster and easier

01:07:32.989 --> 01:07:39.359
with the click of a mouse within Xcode and this is
all based on the use of static source code analysis.

01:07:39.360 --> 01:07:44.360
You can analyze both iPhone and Mac
applications easily with no extra work.

01:07:44.360 --> 01:07:51.320
We have a tight integrated workflow within Xcode
so that you can analyze your code, fix your bugs,

01:07:51.320 --> 01:07:57.050
and analyze to verify that your-- the fixes
have actually done what you intended them to do.

01:07:57.050 --> 01:08:01.170
And lastly, the Analyzer, as I've
said, is a 100 percent open source.

01:08:01.170 --> 01:08:07.460
You are free to contribute and make it better and we
really encourage you to join us if you're excited about it.

01:08:07.460 --> 01:08:12.329
So for information you can contact our
Developer Tools Evangelist, Michael Jurewitz.

01:08:12.329 --> 01:08:16.460
He'd be more than happy to answer your questions
and forward us, turns you in the right direction.
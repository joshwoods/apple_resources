WEBVTT

00:00:12.550 --> 00:00:16.380
>> Good afternoon and welcome to
the Developer Tools State of Union.

00:00:16.379 --> 00:00:24.099
Over the last year, the Apple Developer Community
has grown tremendously and that's of course

00:00:24.100 --> 00:00:29.090
because we now have two major development
platforms, the Mac, and iPhone.

00:00:29.089 --> 00:00:35.000
As you heard earlier this morning, the iPhone SDK
has been downloaded more than 1 million times.

00:00:35.000 --> 00:00:39.929
It has been truly fantastic to welcome so
many new developers to the Apple community.

00:00:39.929 --> 00:00:43.490
And it's great to see so many new faces here at WWDC.

00:00:43.490 --> 00:00:48.020
So in this session, we're going to
take a look at what's new in tools.

00:00:48.020 --> 00:00:55.070
And what's new is that along with Snow Leopard, we
are shipping the 3.2 release of our Xcode Tools Suite.

00:00:55.070 --> 00:00:58.899
3.2 contains updates to all our applications.

00:00:58.899 --> 00:01:05.280
Starting with Xcode, our primary IDE for
developing native Mac, and iPhone applications.

00:01:05.280 --> 00:01:11.730
Interface Builder, our graphic user interface design tool.

00:01:11.730 --> 00:01:15.990
Instruments, our powerful performance analysis tool.

00:01:15.989 --> 00:01:19.559
Dashcode, our IDE for developing web applications.

00:01:19.560 --> 00:01:21.290
And of course the iPhone simulator.

00:01:21.290 --> 00:01:26.640
Now today we are actually making two
distinct releases available to you.

00:01:26.640 --> 00:01:30.120
Snow Leopard preview and the iPhone SDK 3.0.

00:01:30.120 --> 00:01:32.910
And both of these work very great together.

00:01:32.909 --> 00:01:38.869
If you want to try that out, you install Snow Leopard
along with it, the tools from the DVD we handed out.

00:01:38.870 --> 00:01:43.030
And you download the iPhone SDK
from the WWDC Attendee portal.

00:01:43.030 --> 00:01:47.760
Make sure that you're downloading the
iPhone SDK for Snow Leopard only package.

00:01:47.760 --> 00:01:51.410
So 3.2 is a great release.

00:01:51.409 --> 00:01:57.629
It has a lot of new, powerful features and to get us
started, I'd like to ask Matt Firlik to come on stage

00:01:57.629 --> 00:02:03.879
and give you a demo of some of the new features in Xcode
and Interface Builder while building an iPhone application.

00:02:03.879 --> 00:02:04.560
Matt?

00:02:04.560 --> 00:02:09.310
[ Applause ]

00:02:09.310 --> 00:02:09.890
>> Thank you Andreas.

00:02:09.889 --> 00:02:11.929
So everyone enjoying the conference so far?

00:02:11.930 --> 00:02:12.580
[ Cheering ]

00:02:12.580 --> 00:02:16.480
OK, this is actually a check to make sure you're awake.

00:02:16.479 --> 00:02:17.829
Is everyone enjoying the conference so far?

00:02:17.830 --> 00:02:18.380
[ Cheering ]

00:02:18.379 --> 00:02:21.159
Thank you.

00:02:21.159 --> 00:02:22.919
It's only going to get better with tools.

00:02:22.919 --> 00:02:23.439
[ Laughter ]

00:02:23.439 --> 00:02:25.759
You don't believe me?

00:02:25.759 --> 00:02:26.199
[ Laughter ]

00:02:26.199 --> 00:02:28.569
All right, show of hands.

00:02:28.569 --> 00:02:33.060
How many of you have built an application
using one of the iPhone SDK 2.0 releases?

00:02:33.060 --> 00:02:34.640
That's awesome.

00:02:34.639 --> 00:02:38.969
How many of you have played with the 3.X SDK beta releases?

00:02:38.969 --> 00:02:40.550
All right, you don't need me to be up here at all.

00:02:40.550 --> 00:02:46.760
So I'm going to take a little brief journey through some of
the new features of the iPhone SDK 3.0 and some of the tools

00:02:46.759 --> 00:02:48.489
to show you exactly what you're going to be able to get.

00:02:48.490 --> 00:02:53.400
So if we're going to look up here on screen here,
we'll see a device that's running an application.

00:02:53.400 --> 00:02:54.810
I like to view it in application.

00:02:54.810 --> 00:02:56.080
It's called World Jam.

00:02:56.080 --> 00:02:58.210
And it's a Garage Band like application.

00:02:58.210 --> 00:03:01.430
And it's built using the iPhone SDK 2.2.1.

00:03:01.430 --> 00:03:04.819
This application allows you to pick
tracks and layer them to create music.

00:03:04.819 --> 00:03:08.819
But unlike picking tracks by instrument,
we pick them by geography.

00:03:08.819 --> 00:03:11.569
So on the device here, I'm going
to select the guitar instrument,

00:03:11.569 --> 00:03:15.030
and we'll see it goes to a table view of geographies.

00:03:15.030 --> 00:03:18.060
I can pick Japan and we can hit the play button.

00:03:18.060 --> 00:03:18.650
[ Music ]

00:03:18.650 --> 00:03:21.120
Play a little bit for us.

00:03:21.120 --> 00:03:24.400
Let's pick a rhythm track something like South Africa.

00:03:24.400 --> 00:03:26.000
And see what happens.

00:03:26.000 --> 00:03:26.729
[ Music ]

00:03:26.729 --> 00:03:28.929
Just like demo with a soundtrack.

00:03:28.930 --> 00:03:29.300
[ Music ]

00:03:29.300 --> 00:03:32.080
You can feel free to dance in the isles if you want.

00:03:32.080 --> 00:03:32.660
[ Music ]

00:03:32.659 --> 00:03:40.949
All right, so let's take an experiment and see what it
takes to take this from the 2.2.1 SDK to the 3.0 SDK.

00:03:40.949 --> 00:03:43.319
So to do that, we'll switch to the demo machine.

00:03:43.319 --> 00:03:46.549
And you'll see the project I have for this application.

00:03:46.550 --> 00:03:49.070
Now the project is just a standard Xcode project.

00:03:49.069 --> 00:03:50.879
Here is the, we're looking at a source file.

00:03:50.879 --> 00:03:54.659
This is the TableView controller, you're
just seeing a list of geographies.

00:03:54.659 --> 00:03:57.359
So let's take this and move it to the 3.0 SDK.

00:03:57.360 --> 00:04:00.660
To that, I'm going to stop the application
that's running on the device currently.

00:04:00.659 --> 00:04:04.699
And I'll go into the project menu
and select edit project settings.

00:04:04.699 --> 00:04:09.349
That's going to bring up the project inspector
and I'll just use the base SDK down here pop up

00:04:09.349 --> 00:04:13.250
and change that from the 2.2.1 to 3.0 SDK.

00:04:13.250 --> 00:04:14.939
That's it, we're done.

00:04:14.939 --> 00:04:19.490
Now, actually, while I'm here, I'm going to
edit the project settings and edit the target.

00:04:19.490 --> 00:04:22.280
What I want to do is take advantage
of some of the new functionality

00:04:22.279 --> 00:04:25.809
of the iPhone 3 SDK, specifically the map view framework.

00:04:25.810 --> 00:04:27.439
So I'll keep a plus sign here.

00:04:27.439 --> 00:04:30.160
And just select MapKit and add that to my project.

00:04:30.160 --> 00:04:32.330
We'll get to that in a little bit.

00:04:32.329 --> 00:04:37.359
So now that I've switched to the 3.0 SDK, we have our
choice between running on the simulator or on the device.

00:04:37.360 --> 00:04:39.310
We'll pick running on the simulator first.

00:04:39.310 --> 00:04:42.129
And let's hit build and run and see what happens.

00:04:42.129 --> 00:04:44.899
So we build and well we see we actually didn't build.

00:04:44.899 --> 00:04:45.370
We failed to build.

00:04:45.370 --> 00:04:49.610
I actually have my project pedantically
configured to treat warnings as errors.

00:04:49.610 --> 00:04:55.020
In this case, you're seeing the new
warning bubbles in Xcode 3.2, which is,

00:04:55.019 --> 00:04:56.439
they're very streamlined on the right hand side.

00:04:56.439 --> 00:05:00.230
You can see they show you very,
very precise, but terse information.

00:05:00.230 --> 00:05:02.460
If I hover over them, they show
you a tool tip which you know

00:05:02.459 --> 00:05:05.209
that they don't reflow your code
and they stay out of your way.

00:05:05.209 --> 00:05:10.239
[ Applause ]

00:05:10.240 --> 00:05:13.069
I told you you're going to like it.

00:05:13.069 --> 00:05:17.149
You'll also start to see that there's user experience
that goes along with them as I start working with my code.

00:05:17.149 --> 00:05:18.589
So pay attention.

00:05:18.589 --> 00:05:21.109
Now in this case, it's telling me I have some deprecations.

00:05:21.110 --> 00:05:24.410
Happens sometimes when we move from
2.0 to 3.0 SDKs and other releases.

00:05:24.410 --> 00:05:28.260
In this case, I know that the table
view cell had some modifications.

00:05:28.259 --> 00:05:29.949
But I don't quite remember what they were.

00:05:29.949 --> 00:05:32.189
I'm going to show you another new
feature of the Xcode release.

00:05:32.189 --> 00:05:37.240
I'm going to hold down the option key with this
hand and double click on selected text color.

00:05:37.240 --> 00:05:39.460
And up pops, what we call Quick Help.

00:05:39.459 --> 00:05:43.569
And Quick Help is contextually
based on demand assistance for APIs.

00:05:43.569 --> 00:05:48.829
In this case, it's showing me an abstract, but it's
also helpfully showing me that this API is deprecated

00:05:48.829 --> 00:05:50.310
and tells me what I'm supposed to be using.

00:05:50.310 --> 00:05:54.129
In this case, I should be using
the label attributes on this cell.

00:05:54.129 --> 00:05:56.000
So let's go ahead and fix that.

00:05:56.000 --> 00:05:58.930
I'll just delete that API and start typing.

00:05:58.930 --> 00:06:02.269
You'll see that code completion pops
up and I can select the text label.

00:06:02.269 --> 00:06:06.069
And I'll start typing selected, no that's not the right one.

00:06:06.069 --> 00:06:07.399
I think they've renamed it.

00:06:07.399 --> 00:06:11.989
But that's OK, I can just back up here, the code
completion gives me a list of all the available APIs

00:06:11.990 --> 00:06:16.110
and I see that they've actually
renamed it to highlighted text color.

00:06:16.110 --> 00:06:17.400
So I'll select that one.

00:06:17.399 --> 00:06:22.310
We'll make the same modifications for the other ones,
we need to use the text label, and in this case,

00:06:22.310 --> 00:06:26.240
we're supposed to be using the image
view instead of the image itself.

00:06:26.240 --> 00:06:29.210
So you'll note when I save, the message bubbles went away.

00:06:29.209 --> 00:06:32.009
It's giving me contextual information
to tell me I made changes to my code,

00:06:32.009 --> 00:06:35.689
to allow me to see what I still may need to work on.

00:06:35.689 --> 00:06:40.139
So, I realize one of the things that would've helped
me was if my API was a little more expressive.

00:06:40.139 --> 00:06:42.389
In this case, my, my variable here is cell.

00:06:42.389 --> 00:06:45.769
If it had been TableView cell, it
would've been much more helpful.

00:06:45.769 --> 00:06:48.490
What I'm going to do is take advantage of
another great Xcode features with this,

00:06:48.490 --> 00:06:50.949
which is integrated find much like Safari.

00:06:50.949 --> 00:06:55.240
I'll just hit command-F and you'll see up
pops an integrated find bar at the top.

00:06:55.240 --> 00:07:00.460
I'll start typing in cell and it immediately
highlights all the instances of cell right here.

00:07:00.459 --> 00:07:02.389
I could also use the find and replace.

00:07:02.389 --> 00:07:04.159
[ Applause ]

00:07:04.160 --> 00:07:05.990
And I could replace them if I wanted to.

00:07:05.990 --> 00:07:07.850
However, I note here there's too many cells.

00:07:07.850 --> 00:07:09.660
You'll see that it's in comments
and it's in the middle of API.

00:07:09.660 --> 00:07:13.080
I want something a little more fine grained.

00:07:13.079 --> 00:07:16.529
So I'm going to cancel that and you'll see
that if I hover over my instance variable here,

00:07:16.529 --> 00:07:20.929
there's a little pop up that comes
up and I could select all and scope.

00:07:20.930 --> 00:07:24.660
By selecting this, the editor is going to
allow me to change all of the instances.

00:07:24.660 --> 00:07:24.800
[ Applause ]

00:07:24.800 --> 00:07:29.199
All right at once.

00:07:29.199 --> 00:07:32.769
[ Applause ]

00:07:32.769 --> 00:07:35.419
So, impressed yet?

00:07:35.420 --> 00:07:37.730
Let's see, let's see if we can build and run now.

00:07:37.730 --> 00:07:40.710
So it build and run, up comes my
application in the simulator.

00:07:40.709 --> 00:07:42.149
We could go ahead and interact with it too.

00:07:42.149 --> 00:07:44.359
We can select all of our tracks.

00:07:44.360 --> 00:07:47.410
Now I'm sure I'm like every single one of you in this room.

00:07:47.410 --> 00:07:49.170
I write perfect code.

00:07:49.170 --> 00:07:51.910
My code works every single time, no problems whatsoever.

00:07:51.910 --> 00:07:54.680
So I literally do not have a problem
to debug in front of you here.

00:07:54.680 --> 00:07:58.449
What I want to do though is use the
debugger to be more playful with my code.

00:07:58.449 --> 00:08:00.920
The integrated debugger is a really great experience.

00:08:00.920 --> 00:08:06.030
It allows you to be more playful or especially a little
more investigative with code you haven't seen before.

00:08:06.029 --> 00:08:08.559
So let's pretend for a moment I've
never seen this before and I want

00:08:08.560 --> 00:08:12.149
to debug what happens when I select a geography here.

00:08:12.149 --> 00:08:15.129
I'll go back to my code and I'll
just scroll down a little bit.

00:08:15.129 --> 00:08:19.219
You'll see here this implementation of a
delegate method which handles selection.

00:08:19.220 --> 00:08:20.840
What happens when I select a role in the table view?

00:08:20.839 --> 00:08:24.759
If you watch, I'll click in the
gutter here and set a break point.

00:08:24.759 --> 00:08:26.279
Now I just started running my application.

00:08:26.279 --> 00:08:27.539
I wasn't debugging before.

00:08:27.540 --> 00:08:29.040
But Xcode handles that seamlessly.

00:08:29.040 --> 00:08:30.540
We've now connected with the debugger.

00:08:30.540 --> 00:08:35.509
And we'll see that when I go back to my
application and select a different item,

00:08:35.509 --> 00:08:38.379
we now break right in the editor where we're supposed to be.

00:08:38.379 --> 00:08:41.490
At the top of the editor, you'll see
some streamlined debugger controls.

00:08:41.490 --> 00:08:44.740
I can start clicking and stepping
over to get to where I want.

00:08:44.740 --> 00:08:48.500
But we've made some other improvements in the
editor in the debugging experience in the new tools

00:08:48.500 --> 00:08:50.309
to allow you to just be very, very focused.

00:08:50.309 --> 00:08:53.079
In this particular case, I want to
be at the bottom of this method.

00:08:53.080 --> 00:08:56.639
I want to be at the place where we get
the index for the current geography.

00:08:56.639 --> 00:09:01.990
I could step all the way down, but if you watch
the cursor as I go across the gutter here,

00:09:01.990 --> 00:09:06.840
you'll see that I get a very contextually
sensitive continue button that when I click that,

00:09:06.840 --> 00:09:11.350
so we'll go down right to where I want to be and click
that, the debugger jumps right to where I want to be.

00:09:11.350 --> 00:09:12.310
In fact, it's even better.

00:09:12.309 --> 00:09:15.509
It will give a step control to step over.

00:09:15.509 --> 00:09:17.269
So I don't even need to go back to the top of the editor.

00:09:17.269 --> 00:09:19.389
I can stay very, very focused.

00:09:19.389 --> 00:09:21.429
Now in this case, we just got the selected row.

00:09:21.429 --> 00:09:23.149
And I would like to see what that value is.

00:09:23.149 --> 00:09:30.029
So if I hover over the instance variable, we see that
the index is 3 by the data tips that we're seeing.

00:09:30.029 --> 00:09:34.339
If I step over again, we'll see that it's
going to get the corresponding geography.

00:09:34.340 --> 00:09:39.050
And I can use the fact that the data tips will
allow me to drill down and see more information.

00:09:39.049 --> 00:09:41.439
So you can see here, we're going
to select the geography of France

00:09:41.440 --> 00:09:45.090
and the music is French Industrial, if we were to play this.

00:09:45.090 --> 00:09:48.129
Now, while my code is perfect, maybe my fingers are not.

00:09:48.129 --> 00:09:49.309
You guys might make me nervous.

00:09:49.309 --> 00:09:50.469
So maybe I picked the wrong one.

00:09:50.470 --> 00:09:52.490
Maybe I really wanted the one above it.

00:09:52.490 --> 00:09:59.690
The debugger and the integrated assistance here allows us
to just grab the program counter and just move it back up.

00:09:59.690 --> 00:10:04.300
And let's see, I'm still on the
selected row of 3, but if I wanted Chile,

00:10:04.299 --> 00:10:07.939
I could just come over here and
just, let's just change the value.

00:10:07.940 --> 00:10:09.770
We'll go back and now step over.

00:10:09.769 --> 00:10:12.360
And take a look at the geography again.

00:10:12.360 --> 00:10:13.950
And you'll see that now we're on Chile.

00:10:13.950 --> 00:10:17.090
So I just go ahead and start modifying
my application as I'm working with it.

00:10:17.090 --> 00:10:17.389
[ Applause ]

00:10:17.389 --> 00:10:18.399
Without a problem.

00:10:18.399 --> 00:10:23.069
[ Applause ]

00:10:23.070 --> 00:10:26.629
Now, I think it's really important to point
out that all the stuff you've seen recently,

00:10:26.629 --> 00:10:30.009
all the new features in the Xcode 3
tools, I haven't left the editor at all.

00:10:30.009 --> 00:10:31.750
No extra windows, no nothing going on.

00:10:31.750 --> 00:10:34.909
We wanted, really wanted to make sure that
you stay focused on what's important to you.

00:10:34.909 --> 00:10:36.879
And we'd like to bring all these features to the editor.

00:10:36.879 --> 00:10:38.009
So I hope you like those.

00:10:38.009 --> 00:10:43.039
What I want to do is to actually change my focus for a
second and show you some modifications to Interface Builder

00:10:43.039 --> 00:10:46.139
and take advantage of the 3.0 SDK features.

00:10:46.139 --> 00:10:50.710
I'm going to stop my running application for a second
here and I'm going to open up the geography do.

00:10:50.710 --> 00:10:53.300
This is the list of the all the geographies you saw before.

00:10:53.299 --> 00:10:55.659
You see it's implemented here with a TableView.

00:10:55.659 --> 00:10:57.120
I want to change this to a MapView.

00:10:57.120 --> 00:11:00.440
So I'm just going to delete it out of my interface here.

00:11:00.440 --> 00:11:03.770
And I'll drag the MapView which is now
in the library over here on the left,

00:11:03.769 --> 00:11:07.379
I'll just drag that out and drop it right in my interface.

00:11:07.379 --> 00:11:08.519
That's it.

00:11:08.519 --> 00:11:09.879
OK, I may have cheated before.

00:11:09.879 --> 00:11:12.139
There is some code that I need to make work with this.

00:11:12.139 --> 00:11:17.230
There's a delegate class that's already in my project
and I want to put that now in my interface file.

00:11:17.230 --> 00:11:19.250
To do that I'm going to take advantage
of one of the new features

00:11:19.250 --> 00:11:23.100
of Interface Builder, which is
showing classes in the library.

00:11:23.100 --> 00:11:25.960
So now, you can see here a list
of all my classes up on the left.

00:11:25.960 --> 00:11:30.889
I'm going to filter down to Map and here's
my controller that's already in my project.

00:11:30.889 --> 00:11:34.909
I'll just drag that in and we'll just connect
it up in standard Interface Builder fashion,

00:11:34.909 --> 00:11:38.709
connect the controller up to the
MapView so I can place the annotations,

00:11:38.710 --> 00:11:41.730
connect the map to the controller as a delegate.

00:11:41.730 --> 00:11:45.039
And we'll just connect up the controller
in my interface here.

00:11:45.039 --> 00:11:46.319
And that's it, we're done.

00:11:46.320 --> 00:11:48.620
Now when we run, we should see a map.

00:11:48.620 --> 00:11:51.870
Now before I quit here, there's actually
one other thing I want to show you.

00:11:51.870 --> 00:11:56.730
Which is this morning you guys heard about the new
VoiceOver technology that's available on the iPhone SDK.

00:11:56.730 --> 00:12:02.259
This is a tremendous revolution for bringing such
level of accessibility to a handheld touch device.

00:12:02.259 --> 00:12:05.830
So what I would like to do is edit the root view,

00:12:05.830 --> 00:12:08.889
which is the top view of my application
here, with all the instruments.

00:12:08.889 --> 00:12:11.250
And I'd like to add some accessibility
to some of these buttons.

00:12:11.250 --> 00:12:14.120
They have some default accessibility, but
I want to make them a little more specific.

00:12:14.120 --> 00:12:18.840
So I'm going to select the button in
the lower right by my guitar here.

00:12:18.840 --> 00:12:23.360
And if I change the inspector, which is on the right
side of your screen, to the identity inspector,

00:12:23.360 --> 00:12:25.610
you'll see that there's a new accessibility section.

00:12:25.610 --> 00:12:26.600
And I'm going to give this a label.

00:12:26.600 --> 00:12:29.040
We'll call this melody.

00:12:29.039 --> 00:12:34.079
And for the saxophone, I'm going to give
it something a little more interesting.

00:12:34.080 --> 00:12:36.490
Let's do.

00:12:36.490 --> 00:12:36.860
[ Period of silence ]

00:12:36.860 --> 00:12:38.879
If I can spell.

00:12:38.879 --> 00:12:41.299
And we'll see what that sounds like.

00:12:41.299 --> 00:12:42.539
So we'll save this.

00:12:42.539 --> 00:12:47.019
Now we can quit and let's run our application
but let's now run it on the device.

00:12:47.019 --> 00:12:48.069
So we'll click build and debug.

00:12:48.070 --> 00:12:53.300
Now if we can switch to the device view, you'll see that
our application is now going to build for the 3.0 SDK,

00:12:53.299 --> 00:12:58.870
it's going to be installed on the
device, and in just a second,

00:12:58.870 --> 00:13:01.669
here comes the application, just as we knew it before.

00:13:01.669 --> 00:13:05.339
Now when I pick an instrument,
and see that now we have a map.

00:13:05.340 --> 00:13:07.460
It's the standard MapView that I can interact with.

00:13:07.460 --> 00:13:09.750
We can zoom in and drill in.

00:13:09.750 --> 00:13:11.179
We see we have some flags placed.

00:13:11.179 --> 00:13:12.859
There's a flag in Texas.

00:13:12.860 --> 00:13:15.350
Any Kelly Clarkson fans in the audience?

00:13:15.350 --> 00:13:15.409
[ Cheering ]

00:13:15.409 --> 00:13:17.860
It is very lonely up here.

00:13:17.860 --> 00:13:20.250
OK, so we're going to.

00:13:20.250 --> 00:13:20.309
[ Laughter ]

00:13:20.309 --> 00:13:22.399
We're going to scroll over, something
maybe a little more appropriate.

00:13:22.399 --> 00:13:23.929
We could pick Germany.

00:13:23.929 --> 00:13:25.419
I think Andreas will appreciate that.

00:13:25.419 --> 00:13:30.529
So we could pick that and get a
little bit of music for us here.

00:13:30.529 --> 00:13:30.589
[ Music ]

00:13:30.590 --> 00:13:36.129
OK, so we're going to go back to the
top level view and what I'm going

00:13:36.129 --> 00:13:38.779
to do is enable VoiceOver so we
can see what this looks like.

00:13:38.779 --> 00:13:43.990
I'm going to enable this through iTunes for a second
so I don't have to switch out of the application.

00:13:43.990 --> 00:13:46.440
But in a second, you'll hear.

00:13:46.440 --> 00:13:47.470
>> VoiceOver on.

00:13:47.470 --> 00:13:48.540
>> VoiceOver is on.

00:13:48.539 --> 00:13:49.659
>> Jam session.

00:13:49.659 --> 00:13:50.889
>> It starts speaking to me.

00:13:50.889 --> 00:13:56.580
I can actually select one of the buttons and the ones
I haven't configured will just have a default label.

00:13:56.580 --> 00:13:58.310
>> Button.

00:13:58.309 --> 00:13:58.959
Button.

00:13:58.960 --> 00:14:01.300
>> If I pick the guitar, you'll
start to hear the configuration.

00:14:01.299 --> 00:14:02.240
>> Melody button.

00:14:02.240 --> 00:14:05.879
>> And of course if I pick the saxophone.

00:14:05.879 --> 00:14:08.070
>> Let's get this party started button.

00:14:08.070 --> 00:14:10.170
[ Laughter ]

00:14:10.169 --> 00:14:15.049
>> So you see, just like that, it's very, very easy to
configure your applications both with MapKit, with VoiceOver

00:14:15.049 --> 00:14:19.359
and other functionality and take advantage of a lot
of the great features in the SDK and the new tools.

00:14:19.360 --> 00:14:31.820
So I hope you have as much fun as we do and rock the house.

00:14:31.820 --> 00:14:32.310
Thank you.

00:14:32.309 --> 00:14:32.519
[ Applause ]

00:14:32.519 --> 00:14:34.929
>> Thank you Matt.

00:14:34.929 --> 00:14:39.419
So the two applications you saw most in
this demo were Xcode and Interface Builder.

00:14:39.419 --> 00:14:43.299
And the new versions of both of these
applications contain a ton of improvements.

00:14:43.299 --> 00:14:47.859
We've really tried to listen to your feedback and
implement the most commonly requested enhancements.

00:14:47.860 --> 00:14:55.080
To give you just some examples, Project, project by
define time in Xcode is now up to 2 1/2 times faster.

00:14:55.080 --> 00:14:58.650
And we've editor command to rename entire projects.

00:14:58.649 --> 00:14:59.720
Interface Builder.

00:14:59.720 --> 00:15:00.590
[ Applause ]

00:15:00.590 --> 00:15:08.009
Interface Builder can now copy and paste
connections and bindings and of course as you saw,

00:15:08.009 --> 00:15:12.569
it supports all the new iPhone SDK 3.0
features like MapKit and accessibility.

00:15:12.570 --> 00:15:15.520
And there's a ton of features just like
that in both of these applications.

00:15:15.519 --> 00:15:24.319
There's just one area I want to touch on explicitly and
that is the source editor in Xcode because that's of course

00:15:24.320 --> 00:15:26.780
where you spend most of your time during development.

00:15:26.779 --> 00:15:29.339
In the Xcode Source Editor has really come a long way.

00:15:29.340 --> 00:15:32.030
It offers everything that you would expect from a great IDE.

00:15:32.029 --> 00:15:37.990
And in Snow Leopard, we've even added a new font that
is specifically tuned for the purposes of coding.

00:15:37.990 --> 00:15:42.779
It's called Menlo and it makes your source look great.

00:15:42.779 --> 00:15:47.740
Now one thing I feel very strong about is that the
source editor needs to be the focus point of your work.

00:15:47.740 --> 00:15:52.240
And so we designed a number of workflows that
make sure that you never have to leave the context

00:15:52.240 --> 00:15:55.710
of your editor while performing
most of your development tasks.

00:15:55.710 --> 00:16:00.889
You saw an example of that in the demo when Matt was
able to do all of his debugging right in the editor just

00:16:00.889 --> 00:16:04.120
with the aid of the small debugger bar
that comes down from the top of the editor.

00:16:04.120 --> 00:16:11.549
And the data tips that show you variable use just by
hovering with your mouse pointer over your source code.

00:16:11.549 --> 00:16:15.479
So in Xcode 3.2, we've added find
and replace in a similar fashion.

00:16:15.480 --> 00:16:17.730
So the new find works just like Safari's.

00:16:17.730 --> 00:16:23.659
It shows you all occurrences of the search string at once
and it calls of course in Xcode we went a step further

00:16:23.659 --> 00:16:28.159
in the editor case and the define bar as well.

00:16:28.159 --> 00:16:31.469
New message bubbles are also a vast
improvement over the earlier releases.

00:16:31.470 --> 00:16:33.720
They are now much more compact and less intrusive.

00:16:33.720 --> 00:16:36.690
They don't reflow your code anymore if they can avoid it.

00:16:36.690 --> 00:16:42.100
And they even dim out if you edit a line of code to indicate
that you've already addressed the problem that was reported.

00:16:42.100 --> 00:16:48.909
[ Applause ]

00:16:48.909 --> 00:16:54.000
The new Quick Help pops up right in the editor
with answers to the most common API questions.

00:16:54.000 --> 00:16:58.399
And if you want to know more, you can use of the
many links the Quick Help window to jump right

00:16:58.399 --> 00:17:01.459
to the new documentation window, which
has also been completely reworked.

00:17:01.460 --> 00:17:12.009
It's now much cleaner, it's faster and it's easier to use.

00:17:12.009 --> 00:17:12.069
[ Applause ]

00:17:12.069 --> 00:17:14.950
So those were just some of the
improvements in Xcode and Interface Builder,

00:17:14.950 --> 00:17:18.880
our tools for developing Native,
Mac and iPhone applications.

00:17:18.880 --> 00:17:25.650
Let's now take a quick look at developing web
applications for which you of course use Dashcode.

00:17:25.650 --> 00:17:28.930
Dashcode started out as a tool to develop dashboard widgets.

00:17:28.930 --> 00:17:34.660
And last year, we added support to
develop iPhone web applications as well.

00:17:34.660 --> 00:17:40.330
This year, we are taking it a huge step further
by expanding Dashcode in multiple directions.

00:17:40.329 --> 00:17:45.349
First of all, you're now going to be able to not only
develop applications running in Safari and the iPhone,

00:17:45.349 --> 00:17:50.769
but also applications that run in Safari on the Mac and PC.

00:17:50.769 --> 00:17:54.509
Secondly, Dashcode now supports
the new HTML5 and CSS3 standards.

00:17:54.509 --> 00:17:59.789
Which means that the Dashcode JavaScript
parts can make views of CSS animations

00:17:59.789 --> 00:18:02.809
and effects, media texts and offline storage APIs.

00:18:02.809 --> 00:18:11.480
Third, and this is a big one, we are adding support
for automated data sources and data bindings.

00:18:11.480 --> 00:18:16.210
Similar to the Cocoa bindings mechanism that some
of you Mac developers might be familiar with

00:18:16.210 --> 00:18:21.350
So far, what you had to do if you wanted to get data from
a data source into the user interface of your application,

00:18:21.349 --> 00:18:23.809
you had to write a bunch of JavaScript glue code.

00:18:23.809 --> 00:18:29.269
By going forward with Dashcode, developing
programming user interfaces is going to be a lot easier

00:18:29.269 --> 00:18:35.720
because we will be able to replace all this JavaScript glue
code with the use of automated controllers and data bindings

00:18:35.720 --> 00:18:38.769
that manage the content of your UI for you.

00:18:38.769 --> 00:18:40.279
So here's how that works.

00:18:40.279 --> 00:18:43.599
You just enter the URL of a data source in Dashcode.

00:18:43.599 --> 00:18:47.589
Dashcode will then go and parse the data
source and show you the structure of the data

00:18:47.589 --> 00:18:52.759
so that you can graphically wire it up,
right to the elements you use in interface.

00:18:52.759 --> 00:18:58.920
So using data bindings is very quick, makes it very
quick to pull together a user interface in Dashcode.

00:18:58.920 --> 00:19:03.470
And it's especially useful in another
new feature which is that applications

00:19:03.470 --> 00:19:07.529
in Dashcode going forward can contain
multiple versions of their user interface.

00:19:07.529 --> 00:19:15.009
So you can develop out of a single application that runs
on Safari in the iPhone and Safari on the Mac and PC,

00:19:15.009 --> 00:19:17.819
just one application for all target platforms.

00:19:17.819 --> 00:19:23.589
And to show you all of this I'd like to ask Max Drukman
to come up on stage and give you the second demo.

00:19:23.589 --> 00:19:28.000
[ Applause ]

00:19:28.000 --> 00:19:28.609
>> Thank you Andreas.

00:19:28.609 --> 00:19:33.359
Good afternoon developers, developers,
developers, developers.

00:19:33.359 --> 00:19:35.379
[ Laughter ]

00:19:35.380 --> 00:19:40.840
Now, some of you may be wondering why you
should build a web app in the first place.

00:19:40.839 --> 00:19:42.439
Well, it's pretty simple.

00:19:42.440 --> 00:19:47.809
Web apps are a great choice if you have constantly
updating content that you want to deliver to your users

00:19:47.809 --> 00:19:53.899
in a way that's quick and easy to build, easy to
maintain and can be updated at a moment's notice.

00:19:53.900 --> 00:19:56.390
That's where Dashcode comes in.

00:19:56.390 --> 00:20:00.110
Let's have a look.

00:20:00.109 --> 00:20:03.719
Now before we have a look at Dashcode,
I just want to show you my content.

00:20:03.720 --> 00:20:08.240
It's a RSS feed of recent Mac hardware.

00:20:08.240 --> 00:20:15.519
Each item in the feed is one piece of
hardware and each item has an image.

00:20:15.519 --> 00:20:19.819
Pretty simple stuff, but that's exactly
what I want to deliver to my users.

00:20:19.819 --> 00:20:24.869
Now, that's my content, but this
look isn't what I'm going for.

00:20:24.869 --> 00:20:27.549
That's why I designed a custom interface.

00:20:27.549 --> 00:20:32.069
Now this is what I want my users to see
when they come looking for my content.

00:20:32.069 --> 00:20:39.740
So the question is how do I get
this content into this interface?

00:20:39.740 --> 00:20:43.690
There's an app for that.

00:20:43.690 --> 00:20:43.750
[ Laughter ]

00:20:43.750 --> 00:20:44.880
It's Dashcode.

00:20:44.880 --> 00:20:46.950
Let's have a look.

00:20:46.950 --> 00:20:51.590
So here is that very same interface
in Dashcode where I designed it.

00:20:51.589 --> 00:20:53.109
It took me just a few minutes.

00:20:53.109 --> 00:20:54.649
I built it out of Dashcode parts.

00:20:54.650 --> 00:20:56.950
It was very easy to do.

00:20:56.950 --> 00:20:59.640
The only thing missing now is my content.

00:20:59.640 --> 00:21:05.770
And I'm going to show you just how easy it is to
get your content into your interface in Dashcode.

00:21:05.769 --> 00:21:08.859
I'm going to bring up the data sources view.

00:21:08.859 --> 00:21:11.759
And select the data source that's already there.

00:21:11.759 --> 00:21:17.059
There's nothing in this data source right now
because I haven't pointed it at my feed yet.

00:21:17.059 --> 00:21:21.369
All I need is a URL, have one right here.

00:21:21.369 --> 00:21:25.619
And go ahead, thank you.

00:21:25.619 --> 00:21:27.469
Now what just happened?

00:21:27.470 --> 00:21:34.049
Well, Dashcode went out, it fetched my feed,
validated it, parsed it and now it's showing it to me.

00:21:34.049 --> 00:21:36.950
Both the structure and the content.

00:21:36.950 --> 00:21:39.650
Let's look a little closer.

00:21:39.650 --> 00:21:48.250
The channel that's RSS speak for the feed,
contains items, each item is one piece of hardware

00:21:48.250 --> 00:21:53.980
and each item has an enclosure that
includes URL of the image for that item.

00:21:53.980 --> 00:22:02.230
So because Dashcode presents me both structure and
content together, I can actually cycle through the items

00:22:02.230 --> 00:22:10.360
and look at every single bit of data in this feed so I know
exactly what I have a hold of before I ever start binding.

00:22:10.359 --> 00:22:13.359
But let's go ahead and start binding.

00:22:13.359 --> 00:22:15.189
And this couldn't be easier.

00:22:15.190 --> 00:22:22.220
First thing I want to do is I want to bind the
title of my feed to the title of my web app.

00:22:22.220 --> 00:22:27.519
And that's as simple as drag and drop.

00:22:27.519 --> 00:22:31.879
Now Dashcode is presenting me a number of
choices for which attribute I want to bind.

00:22:31.880 --> 00:22:35.340
In this case, the text attribute, that's it.

00:22:35.339 --> 00:22:36.779
I've made my binding.

00:22:36.779 --> 00:22:41.819
The UI is updated to show me that
the binding has been created.

00:22:41.819 --> 00:22:45.829
So that was kind of fun, let's do some more.

00:22:45.829 --> 00:22:51.029
I want to take the title of each item
and I want to bind it into the list.

00:22:51.029 --> 00:22:55.450
So that each row of the list represents
one piece of hardware in my feed.

00:22:55.450 --> 00:22:58.500
And again, I drag and drop.

00:22:58.500 --> 00:23:03.980
Now this time, as I make the binding, I want
you to keep your eye on the data sources view.

00:23:03.980 --> 00:23:07.089
What just happened?

00:23:07.089 --> 00:23:11.049
Dashcode created a new data source for me, but why?

00:23:11.049 --> 00:23:17.329
Well the reason is that lists in Dashcode
manage their own content and most importantly,

00:23:17.329 --> 00:23:19.689
they manage a selection within that content.

00:23:19.690 --> 00:23:27.549
So that means that the list itself can act as a data source
so that when the user makes a selection in that list,

00:23:27.549 --> 00:23:31.629
that selection can be used to drive
content into other parts of my UI.

00:23:31.630 --> 00:23:34.550
And that's exactly what I want to do.

00:23:34.549 --> 00:23:41.609
So if I go to the list data source now and start binding
from it, that means that a selection in the list is going

00:23:41.609 --> 00:23:47.949
to drive that content into the
detail area to the right of my list.

00:23:47.950 --> 00:23:51.470
So again, I'm going to bind the title.

00:23:51.470 --> 00:23:52.750
Easy enough.

00:23:52.750 --> 00:23:58.339
I'm going to bind the image, this
time to the image source attribute.

00:23:58.339 --> 00:24:03.189
And now all I need to do is bind the description.

00:24:03.190 --> 00:24:11.029
Now because Dashcode is showing me content along with the
structure, I can see that there are HTML tags in there.

00:24:11.029 --> 00:24:18.529
So that tells me that I want to bind instead of to the text
attribute, to the HTML attribute so those tags get honored

00:24:18.529 --> 00:24:21.750
as formatting and don't show up as plain text.

00:24:21.750 --> 00:24:25.789
So now what else do I need to do?

00:24:25.789 --> 00:24:28.909
Nothing. There's no step three.

00:24:28.910 --> 00:24:33.630
I hit run and here comes my interface with its content.

00:24:33.630 --> 00:24:36.570
All in place just because of Dashcode bindings.

00:24:36.569 --> 00:24:41.659
Now I make a selection in my list and
you can see the detail view updates.

00:24:41.660 --> 00:24:45.740
Everything's working beautifully, it's all in a split view.

00:24:45.740 --> 00:24:48.390
[ Applause ]

00:24:48.390 --> 00:24:49.270
Thank you.

00:24:49.269 --> 00:24:52.680
[ Applause ]

00:24:52.680 --> 00:24:59.960
And I even get a nice sexy CSS3
reflection on my images thanks to Dashcode.

00:24:59.960 --> 00:25:04.440
But of course, there's one more thing.

00:25:04.440 --> 00:25:05.490
Sorry Steve.

00:25:05.490 --> 00:25:08.259
[ Laughter ]

00:25:08.259 --> 00:25:14.990
As Andreas mentioned, Dashcode also supports the
ability to have interfaces for Mobile Safari.

00:25:14.990 --> 00:25:21.450
And I went ahead and I created an interface
for this web app for Mobile Safari as well.

00:25:21.450 --> 00:25:26.319
Now it started the same way that
the Safari version did, with a list.

00:25:26.319 --> 00:25:29.960
But I, I'm making this one a little bit different.

00:25:29.960 --> 00:25:33.990
Inside the list is a part called a stack layout.

00:25:33.990 --> 00:25:39.250
Now stack layout is a really cool part from
Dashcode that manages multiple subviews

00:25:39.250 --> 00:25:43.029
and flips between them with nice animated transitions.

00:25:43.029 --> 00:25:48.269
That's exactly what I'm going to set
up right now in the Dashcode Inspector.

00:25:48.269 --> 00:25:57.839
So Dashcode allows me to have both 2D and 3D transitions
and in fact, I'm going to choice the flip transition.

00:25:57.839 --> 00:26:05.759
Now the flip transition is the exact same transition
that Dashboard Widgets use to flip from front to back.

00:26:05.759 --> 00:26:10.549
So I'm going to have that style now in my web app.

00:26:10.549 --> 00:26:14.599
So just as before, we need to do a little bit of binding.

00:26:14.599 --> 00:26:16.909
Now you've already seen me do this.

00:26:16.910 --> 00:26:22.450
So let's see how quick it is to do if
I don't have to stop and talk about it.

00:26:22.450 --> 00:26:25.319
So let's do that.

00:26:25.319 --> 00:26:26.679
Get my enclosure.

00:26:26.680 --> 00:26:29.779
I guess I am talking about it.

00:26:29.779 --> 00:26:32.930
Now I'm going to flip to the other view.

00:26:32.930 --> 00:26:34.920
And bind here.

00:26:34.920 --> 00:26:38.890
Now once again, is there a step three?

00:26:38.890 --> 00:26:43.780
Nope. Hit run and this time, the
simulator is going to launch.

00:26:43.779 --> 00:26:46.849
Mobile Safari, here comes my content.

00:26:46.849 --> 00:26:49.129
All thanks to Dashcode bindings.

00:26:49.130 --> 00:26:51.530
Here's my list.

00:26:51.529 --> 00:26:59.089
If I click on an item, it flips
over now to show me the detail view.

00:26:59.089 --> 00:26:59.149
[ Applause ]

00:26:59.150 --> 00:27:05.570
Flip it back.

00:27:05.569 --> 00:27:06.009
There it is.

00:27:06.009 --> 00:27:06.069
[ Applause ]

00:27:06.069 --> 00:27:06.240
Pretty cool.

00:27:06.240 --> 00:27:06.299
[ Applause ]

00:27:06.299 --> 00:27:15.529
So there you have it, two interfaces, one for each platform
inside one project all, both linking to one data source.

00:27:15.529 --> 00:27:23.299
So you saw in just minutes I created a web app that
works for both Safari and Mobile Safari in Dashcode.

00:27:23.299 --> 00:27:30.919
You should give it a try yourself, you'd be amazed at how
easy it is to make beautiful, powerful web apps in Dashcode.

00:27:30.920 --> 00:27:32.670
Thanks, enjoy the rest of the show.

00:27:32.670 --> 00:27:39.960
[ Applause ]

00:27:39.960 --> 00:27:42.500
>> Thank you Max.

00:27:42.500 --> 00:27:47.220
So now that we are familiar with the basic workflows
for creating both Native and web applications for Mac

00:27:47.220 --> 00:27:52.259
and iPhone, we're going to use the remainder of the
session today to look at how to get the most of our tools

00:27:52.259 --> 00:27:54.599
and how to build really optimized applications.

00:27:54.599 --> 00:27:59.059
And we're going to start by just taking
a look at processor architectures.

00:27:59.059 --> 00:28:04.629
One of the things that is unique about our tool chain is
that it makes it really easy to create single application

00:28:04.630 --> 00:28:08.360
that runs on multiple different processor architectures.

00:28:08.359 --> 00:28:12.779
What you see here on the slide is a simplified
file system layout of a typical Mac application.

00:28:12.779 --> 00:28:18.299
The executable in there contains the machine code of
the processor architecture that you choose to support.

00:28:18.299 --> 00:28:22.839
If there's more than one, Xcode
will simply build them independently

00:28:22.839 --> 00:28:26.179
but then merge them together into the same executable.

00:28:26.180 --> 00:28:29.289
So of course, this makes your application
a little bit larger.

00:28:29.289 --> 00:28:32.059
But notice that none of the resources had to be duplicated.

00:28:32.059 --> 00:28:36.539
So in practice we find that most
applications only grow by about 25%.

00:28:36.539 --> 00:28:42.470
That makes it ideal to make sure that end users
have the best possible experience because you

00:28:42.470 --> 00:28:48.299
as application developers can distribute one single package,
not multiple packages, one for each processor architecture,

00:28:48.299 --> 00:28:51.589
and end users don't have to worry
about where to install which package.

00:28:51.589 --> 00:28:56.199
The same application runs on all their systems.

00:28:56.200 --> 00:28:59.660
So if you've been a Mac developer
for the last several years,

00:28:59.660 --> 00:29:02.210
you're of course already familiar with this technology.

00:29:02.210 --> 00:29:04.190
Because we've been using it for years now

00:29:04.190 --> 00:29:09.970
to support universal applications that
run on all Intel and PowerPC Macs.

00:29:09.970 --> 00:29:14.640
But going forward with Snow Leopard, which we
often run in 64 bit mode to make the best use

00:29:14.640 --> 00:29:20.390
of the modern processor capabilities, you will
want to include an Intel 64 bit binary as well

00:29:20.390 --> 00:29:26.360
so that your application too can make the
best use of the modern hardware capabilities.

00:29:26.359 --> 00:29:32.500
And the same technology is now going to become
important for iPhone developers as well.

00:29:32.500 --> 00:29:36.329
We are now shipping the third generation of the iPhone.

00:29:36.329 --> 00:29:41.710
And while the first two generations used a
processor that was built on the RD6 instruction set,

00:29:41.710 --> 00:29:49.910
the new iPhone 3G S has a processor that supports
both the RD6 and the RD7 instruction set.

00:29:49.910 --> 00:29:53.769
So why applications that are build for the
RD6 instruction set which should be run

00:29:53.769 --> 00:29:56.889
on all iPhones and all iPod Touches out there.

00:29:56.890 --> 00:30:02.610
If you have an application that is performance sensitive,
you will want to start including an RD7 version of it

00:30:02.609 --> 00:30:08.689
as well so that it runs most optimal on the iPhone 3G S.

00:30:08.690 --> 00:30:13.670
So to build your applications, you need a compiler.

00:30:13.670 --> 00:30:21.400
And the new default compiler for both Snow
Leopard and the iPhone OS 3.0 is GCC 4.2.

00:30:21.400 --> 00:30:25.220
4.2 supports all the new features
that the new OS has introduced.

00:30:25.220 --> 00:30:30.529
So on the Macintosh side, GCC 4.2 has
support for the new blocks technology.

00:30:30.529 --> 00:30:35.009
And on the iPhone side GCC 4.2
supports code generation for ARM v7.

00:30:35.009 --> 00:30:43.079
And generally GCC 4.2 creates better
optimized code than its predecessor GCC 4.0.

00:30:43.079 --> 00:30:51.429
And GCC is the very mature compiler, everyday it's used to
build millions of lines of code for both Mac and iPhone.

00:30:51.430 --> 00:30:55.900
But we've also been working on a much,
much more exciting compiler technology.

00:30:55.900 --> 00:31:02.210
Of course I believe I know what you think if I
use the term exciting new compiler technology.

00:31:02.210 --> 00:31:05.440
You probably think we are crazy.

00:31:05.440 --> 00:31:07.380
But I think today I can change that perception.

00:31:07.380 --> 00:31:10.350
Because we have some fantastic announcements around LLVM.

00:31:10.349 --> 00:31:15.809
LLVM stands for Low Level Virtual Machine
and it's a new compiler technology

00:31:15.809 --> 00:31:18.849
that we've been working on for several years now.

00:31:18.849 --> 00:31:21.609
Here's what we've been doing with it.

00:31:21.609 --> 00:31:26.859
If you look at the architectural volume of a compiler it's
typically distinguished between the so called front end,

00:31:26.859 --> 00:31:32.649
which is essentially the parse of the compiler and the so
called back end, which is essentially the code generator.

00:31:32.650 --> 00:31:39.840
What we've done last year is that we've given you an
alternative back end for the Mac in the form of LLVM.

00:31:39.839 --> 00:31:45.879
And this year we're taking the next step and
we're introducing our new front end as well.

00:31:45.880 --> 00:31:52.330
It's called Clang and at this point in
time it supports Objective-C and plain C.

00:31:52.329 --> 00:31:54.889
And we've seen some stunning results with this new compiler.

00:31:54.890 --> 00:32:00.380
And to tell you more about why it is such a promising
technology, I'm going to hand over the stage for a moment

00:32:00.380 --> 00:32:03.920
to Chris Lattner who is the principal
architect of this technology.

00:32:03.920 --> 00:32:11.529
[ Applause ]

00:32:11.529 --> 00:32:12.359
>> Thank you everyone.

00:32:12.359 --> 00:32:15.219
I'm thrilled to be here.

00:32:15.220 --> 00:32:18.250
Compilers are really exciting despite what some people say

00:32:18.250 --> 00:32:21.869
and you know it is a very exciting
time for compilers here at Apple.

00:32:21.869 --> 00:32:28.169
So I want to tell you a little bit about what LLVM is, why
we're so excited about it, and what we're doing with it.

00:32:28.170 --> 00:32:32.170
So you may be wondering why do
we need new compiler technology?

00:32:32.170 --> 00:32:36.140
And in particular, why are we investing in compilers?

00:32:36.140 --> 00:32:38.759
Well compilers are really interesting for two reasons.

00:32:38.759 --> 00:32:41.509
Alright? They're often unappreciated, right?

00:32:41.509 --> 00:32:47.849
The thing that gets in between you writing your code and
you running your code, but they're also really important.

00:32:47.849 --> 00:32:51.209
A compiler sees all the code going through the system.

00:32:51.210 --> 00:32:54.789
That means that if we can make an improvement
to the compiler, if the compiler can get better

00:32:54.789 --> 00:32:58.389
and produce faster running code, that
means that all the applications that go

00:32:58.390 --> 00:33:00.580
through it can potentially be faster running.

00:33:00.579 --> 00:33:01.849
This is great.

00:33:01.849 --> 00:33:06.079
The compiler also has a huge amount
of information about your program.

00:33:06.079 --> 00:33:09.470
This is information like data flow
information, control flow information.

00:33:09.470 --> 00:33:15.190
It means the compiler has a really good idea of what
your program is doing and this is really powerful

00:33:15.190 --> 00:33:17.850
if we can use this information to make our tools better.

00:33:17.849 --> 00:33:22.279
So as many of you know we've been
using GCC for many years now.

00:33:22.279 --> 00:33:24.629
Well GCC is a great compiler.

00:33:24.630 --> 00:33:30.090
I mean, we've shipped many applications
using code compiled with GCC.

00:33:30.089 --> 00:33:34.809
However GCC really isn't able to
accomplish the things that we need to do.

00:33:34.809 --> 00:33:39.569
We can get nice evolutionary improvements,
you know 5 percent here, 10 percent there.

00:33:39.569 --> 00:33:43.289
But we're at the point in our tool story where we're ready

00:33:43.289 --> 00:33:47.269
for something really revolutionary
and time to start pushing for it.

00:33:47.269 --> 00:33:50.319
And that's really what LLVM is all about.

00:33:50.319 --> 00:33:54.299
So LLVM like GCC is an open source project.

00:33:54.299 --> 00:33:59.869
In fact it's been a very popular open source project with a
lot of contributors and we're really excited to see it grow.

00:33:59.869 --> 00:34:03.599
You can go to the LLVM.org website and
read all about it if you're interested.

00:34:03.599 --> 00:34:07.629
But more than just picking up an open
source project and contributing to it,

00:34:07.630 --> 00:34:14.430
I'm happy to say that at Apple we've picked up
an open source project and started driving it.

00:34:14.429 --> 00:34:19.500
We're really setting the stage for an amazing
new set of compiler technologies here.

00:34:19.500 --> 00:34:22.000
This is not just the boring, you
know, compilers they've been using

00:34:22.000 --> 00:34:26.239
for 30 years now, this is some really great stuff.

00:34:26.239 --> 00:34:31.989
So why is it different than these previous
compilers or really any other compiler out there?

00:34:31.989 --> 00:34:35.369
Because there are many other compilers, more than just GCC.

00:34:35.369 --> 00:34:37.819
Well LLVM is all about performance.

00:34:37.820 --> 00:34:44.010
So performance is really crucial both for code
generation but also for things like parsing code

00:34:44.010 --> 00:34:49.810
because compilers really do get in the way between
you writing your code and you running the code.

00:34:49.809 --> 00:34:53.320
And if it takes a long time to
compile your application, that sucks.

00:34:53.320 --> 00:34:56.470
We want fast compilers, we don't want slow compilers, right?

00:34:56.469 --> 00:34:58.679
So beyond that.

00:34:58.679 --> 00:35:00.500
Thank you.

00:35:00.500 --> 00:35:05.400
Woo! Beyond that we also want really great
performance coming out of your applications, right?

00:35:05.400 --> 00:35:07.869
We all want really fast apps.

00:35:07.869 --> 00:35:12.799
And fast apps can be helped and can be made
possible through a compiler technology.

00:35:12.800 --> 00:35:17.480
Well LLVM is very different than a lot of
compilers that have existed for decades, right?

00:35:17.480 --> 00:35:18.510
There's no baggage.

00:35:18.510 --> 00:35:21.700
That means we can use the best
algorithms, we can use the best design,

00:35:21.699 --> 00:35:27.000
we can take the best technology that's been developed
over the last, you know, one or two years much less 5, 10,

00:35:27.000 --> 00:35:30.579
15, 20 years and apply it to the problem.

00:35:30.579 --> 00:35:36.699
Beyond just building it well and using the right techniques
and tools and all that geeky compiler stuff in there,

00:35:36.699 --> 00:35:40.259
the one thing that makes LLVM really different
than any other compiler that I'm aware

00:35:40.260 --> 00:35:43.550
of is that it's built as a set of libraries.

00:35:43.550 --> 00:35:45.010
Well what does this mean?

00:35:45.010 --> 00:35:47.490
I mean, you know what library based design is, right?

00:35:47.489 --> 00:35:51.119
The entire Apple framework stack
is built as a set of libraries.

00:35:51.119 --> 00:35:52.219
This is not something new.

00:35:52.219 --> 00:35:56.169
Well for some reason, compiler people
throughout the world seem to think

00:35:56.170 --> 00:36:00.110
that a compiler is your application as one executable.

00:36:00.110 --> 00:36:03.599
It's not something that you can take and
reuse and do different things with, right?

00:36:03.599 --> 00:36:07.329
The compiler is something that you put
code in and you get machine code out.

00:36:07.329 --> 00:36:09.690
Right? I think that's garbage.

00:36:09.690 --> 00:36:14.250
We want to be able to use compilers to do great things.

00:36:14.250 --> 00:36:18.800
That means we want the compilers to be modular, we
want to be low memory profile, we want it to work just

00:36:18.800 --> 00:36:23.160
like the Apple framework so that we have,
that do everything else on the system.

00:36:23.159 --> 00:36:26.359
Because as compilers we want them
to be language independent.

00:36:26.360 --> 00:36:33.099
We love C and Objective-C and C++ but who knows what
language might come down the pike in 5, 10 years.

00:36:33.099 --> 00:36:36.089
Also Apple supports many architectures.

00:36:36.090 --> 00:36:39.590
We support, you know, PowerPC and
Intel and all kinds of different things

00:36:39.590 --> 00:36:42.079
and there's more architectures that
are becoming interesting over time.

00:36:42.079 --> 00:36:44.319
So we need to support all these different things.

00:36:44.320 --> 00:36:47.580
Well I'm very happy to say that
all the pieces are coming together.

00:36:47.579 --> 00:36:53.279
LLVM has really matured over the last year and
we have some exciting things to tell you about.

00:36:53.280 --> 00:36:56.710
So what can we do with raw technology?

00:36:56.710 --> 00:37:00.829
Well the first perhaps the best example is OpenCL.

00:37:00.829 --> 00:37:05.230
You've heard a lot about OpenCL today and maybe in the past.

00:37:05.230 --> 00:37:09.449
OpenCL is a great new way to compile and run your code.

00:37:09.449 --> 00:37:11.679
But it's more than just that of course.

00:37:11.679 --> 00:37:17.469
OpenCL is really about building kernels of
computation that run both on CPUs and GPUs.

00:37:17.469 --> 00:37:24.809
These kernels are then load balanced and executed
on all the compute cores you have at your disposal.

00:37:24.809 --> 00:37:28.159
This is ground breaking stuff, right?

00:37:28.159 --> 00:37:35.009
This means I can write one piece of code and have
it be executed on many different compute devices.

00:37:35.010 --> 00:37:36.920
Well there's lots of processors out there, right?

00:37:36.920 --> 00:37:40.710
Some have SC2, SSC3, there's many different GPUs out there.

00:37:40.710 --> 00:37:43.860
And these all have different capabilities,
how are we going to take advantage of that?

00:37:43.860 --> 00:37:46.269
The answer is LLVM.

00:37:46.269 --> 00:37:51.719
LLVM works at runtime, it works on CPUs and
GPUs, it supports fully general languages

00:37:51.719 --> 00:37:55.409
like OpenCL which is basically C with enhancements.

00:37:55.409 --> 00:37:58.980
Not some watered down graphics language
that you might be familiar with in the past.

00:37:58.980 --> 00:38:02.429
And beyond everything else, OpenCL is all about performance.

00:38:02.429 --> 00:38:06.349
If the code coming out of the compiler isn't as
fast as possible, then it's not going to work.

00:38:06.349 --> 00:38:09.739
Because you're using OpenCL to get performance.

00:38:09.739 --> 00:38:16.500
Alright? So LLVM is really the thing that makes OpenCL
possible and it's really exciting to bring this to the world

00:38:16.500 --> 00:38:21.570
because we think it's going to have a
groundbreaking affect on the whole rest of the OS.

00:38:21.570 --> 00:38:27.050
Now you may also know that OpenCL is not the
first place that Apple's been using LLVM.

00:38:27.050 --> 00:38:31.620
OpenGL is an API, it's a very popular
API for doing graphics programming.

00:38:31.619 --> 00:38:34.289
OpenGL has been using LLVM for many years now.

00:38:34.289 --> 00:38:40.519
And this is not something that you yourself can use
like OpenCL, its hidden implementation detail, right?

00:38:40.519 --> 00:38:46.710
But the OpenGL library stack uses LLVM in ways
that accelerated its own internal processing.

00:38:46.710 --> 00:38:54.829
So when you go to upload a texture to the GPU, it uses
LLVM to runtime generate code that handles the conversion

00:38:54.829 --> 00:38:59.210
of that to, the texture that you give
the GPU to a format that GPU recognizes.

00:38:59.210 --> 00:39:02.889
Alright, so JITs, Just in Time compiles
a little bit of code that handles

00:39:02.889 --> 00:39:05.500
that conversion to make it execute as fast as possible.

00:39:05.500 --> 00:39:09.809
Well it does more than just that, it handles pixel
shaders and vortex shaders and vortex submission

00:39:09.809 --> 00:39:11.759
and all kinds of different things in OpenGL.

00:39:11.760 --> 00:39:15.780
And the great thing about it is
that LLVM makes it really fast.

00:39:15.780 --> 00:39:19.440
So OpenGL, our implementation has existed for many years

00:39:19.440 --> 00:39:23.440
that had a previous Just In Time
compiler that LLVM replaced.

00:39:23.440 --> 00:39:31.789
Well, by switching to LLVM the OpenGL stack was faster,
better performance, the architecture was more flexible

00:39:31.789 --> 00:39:37.259
because they had a better design they could build and use in
different ways, and they got support for new architectures.

00:39:37.260 --> 00:39:39.140
One in particular was Intel 64.

00:39:39.139 --> 00:39:42.099
I hear its popular today.

00:39:42.099 --> 00:39:47.130
So LLVM is a great set of compiler technologies and
as a set of pure technology there's a lot of things

00:39:47.130 --> 00:39:49.570
that we're doing internally at Apple with it.

00:39:49.570 --> 00:39:55.350
But the things, potentially the most interesting
to you as developers is its use in compilers.

00:39:55.349 --> 00:39:59.150
And so to talk about compilers in
Xcode I'd like Andreas to come back up

00:39:59.150 --> 00:40:01.869
and tell you a little bit about what we're doing.

00:40:01.869 --> 00:40:02.639
>> Thank you.

00:40:02.639 --> 00:40:07.699
[ applause ]

00:40:07.699 --> 00:40:13.119
So LLVM and Clang are going to allow us
to innovate in a lot of technology areas.

00:40:13.119 --> 00:40:18.599
And the way it's going to affect you the most directly
is by building your own projects with them in Xcode.

00:40:18.599 --> 00:40:20.819
So let's see what they bring to the table.

00:40:20.820 --> 00:40:25.539
The three things that make a compiler great
are first of all that they generate fast code,

00:40:25.539 --> 00:40:31.329
secondly that they build projects very quickly
and third that they give good diagnostic messages.

00:40:31.329 --> 00:40:35.880
Let's take a look at how LLVM and Clang hold out.

00:40:35.880 --> 00:40:40.410
This chart shows a comparison of code
generated with LLVM and code generated with GCC

00:40:40.409 --> 00:40:43.349
and running a number of performance benchmarks.

00:40:43.349 --> 00:40:50.699
What you can see here is that LLVM generated code runs
between 5 and 25 % faster than GCC generated code.

00:40:50.699 --> 00:40:52.769
25 % is huge.

00:40:52.769 --> 00:40:56.509
Keep in mind that many of these
benchmarks have been hand tuned for years,

00:40:56.510 --> 00:41:01.330
so getting 25 % simply by switching
the compiler is simply fantastic.

00:41:01.329 --> 00:41:04.679
So we're very happy with the speed
of generated code from LLVM.

00:41:04.679 --> 00:41:08.889
Let's take a look at build times.

00:41:08.889 --> 00:41:10.710
This is a chart that shows the last year.

00:41:10.710 --> 00:41:15.980
It shows how project build time decreased over
the last several years through a combination,

00:41:15.980 --> 00:41:19.380
through improvements in both hardware and in software.

00:41:19.380 --> 00:41:24.829
What you can see from this graph is first of all that
they really care a lot about build times because we know

00:41:24.829 --> 00:41:28.500
that build times have an immediate
impact on your productivity.

00:41:28.500 --> 00:41:35.300
The other thing is, that we have, what you can see from
this graph is that is has become increasingly hard for us

00:41:35.300 --> 00:41:38.019
to have breaks of improvements in build times,

00:41:38.019 --> 00:41:44.630
something like a 10 % improvement per year has
become a hard step for us to take on top of GCC.

00:41:44.630 --> 00:41:49.119
So let's take a look at what 10 % do to
the build time of a project like Xcode.

00:41:49.119 --> 00:41:52.949
Xcode is a fairly large Objective-C
code core application and our latest

00:41:52.949 --> 00:41:55.859
and greatest hardware is built in
a little less than seven minutes.

00:41:55.860 --> 00:42:03.280
If you would only get the normal 10 % building
Xcode would still take more than 6 minutes.

00:42:03.280 --> 00:42:08.800
Well if you built the same project now with
Clang, this is what happens to build time.

00:42:08.800 --> 00:42:13.940
Building Xcode with Clang is more than twice as
fast than building it with GCC and this holds

00:42:13.940 --> 00:42:16.420
up for pretty much every project we try it on.

00:42:16.420 --> 00:42:19.369
Here's just a sample of several projects in Snow Leopard.

00:42:19.369 --> 00:42:25.219
Very consistently we see that Clang
is more than twice as fast than GCC.

00:42:25.219 --> 00:42:26.629
So we have fast code.

00:42:26.630 --> 00:42:26.690
[ applause ]

00:42:26.690 --> 00:42:36.039
So we have fast code and we have fast builds.

00:42:36.039 --> 00:42:39.349
Let's take a look at help and diagnostic messages.

00:42:39.349 --> 00:42:46.000
Here's an admittedly very senseless piece of
code, but conveniently it contains two errors.

00:42:46.000 --> 00:42:50.320
If we run this code through GCC, it
will correctly find these two errors

00:42:50.320 --> 00:42:53.850
and this is how it would be reported to you in Xcode.

00:42:53.849 --> 00:42:56.920
Well these error messages are certainly correct.

00:42:56.920 --> 00:43:00.010
But I think in this case they are also remarkably unhelpful.

00:43:00.010 --> 00:43:04.690
I don't know about you, but I can never remember
whether I have to start counting at zero or at 1 to get

00:43:04.690 --> 00:43:07.950
to the argument that caused me a problem.

00:43:07.949 --> 00:43:12.389
And the other case, just by glancing at
this line, I see at least four plus signs.

00:43:12.389 --> 00:43:17.179
So I can still design all day long, this error message
does not tell me where I have to start fixing my problem.

00:43:17.179 --> 00:43:22.679
So this has been bugging us for years and we've
tried to greatly improve on this with Clang

00:43:22.679 --> 00:43:25.139
by integrating it much more closely with the Xcode ID.

00:43:25.139 --> 00:43:32.829
So when you build the same piece of code with Clang and
Xcode, this is how error messages are reported to you.

00:43:32.829 --> 00:43:35.699
Let me zoom this up for you.

00:43:35.699 --> 00:43:40.429
Xcode and Clang point you right to the
expression that caused the problem.

00:43:40.429 --> 00:43:57.879
There's no more guessing around and no
more counting when you build with Clang.

00:43:57.880 --> 00:43:58.269
[ Applause ]

00:43:58.269 --> 00:44:03.880
So you have fast builds, you have fast
code, and we have better error messages.

00:44:05.019 --> 00:44:08.030
Quite an attractive package for you
to switch your compiler from GCC.

00:44:08.030 --> 00:44:12.430
And if you want to try it out,
we've made it really easy for you.

00:44:12.429 --> 00:44:18.099
All you have to do is go to Xcode, find the Build
Settings Inspector, and the Compiler Version Base Setting.

00:44:18.099 --> 00:44:21.440
And then switch the popup to the compiler of your choice.

00:44:21.440 --> 00:44:26.349
The first thing you should know about all our compilers
is they're fully binary compatible so you can now return,

00:44:26.349 --> 00:44:31.509
you mix and match code with the
GCC and code with LLVM and Clang.

00:44:32.550 --> 00:44:40.950
The first thing you should do if you have an Objective-C
or C project, should switch to the Clang LLVM base setting.

00:44:40.949 --> 00:44:44.359
Now one thing to know is that Clang
is still a fairly new front end.

00:44:44.360 --> 00:44:49.910
So it does not yet implement all the little features that
GCC has piled up over the many years of its existence.

00:44:49.909 --> 00:44:52.079
There's a chance that Clang might not build your code.

00:44:52.079 --> 00:44:56.759
But if it does, this is really the best choice
because it gives you the fastest page times

00:44:56.760 --> 00:45:00.460
and the best code because it uses LLVM as the back end.

00:45:00.460 --> 00:45:08.460
Now if you run any of these edge cases I just described or
you have a C++ project, you command that you still switch

00:45:08.460 --> 00:45:12.690
to the LLVM GCC Compiler which gives you
full source code compatibility with GCC

00:45:12.690 --> 00:45:17.570
but it gives you a better code
generator in the form of LLVM.

00:45:17.570 --> 00:45:23.730
So this is all the story on LLVM and Clang and I used
the term new compiler technologies several times now,

00:45:23.730 --> 00:45:27.159
so I'm sure you're wondering is this
technology really ready for you.

00:45:27.159 --> 00:45:30.009
Well I wouldn't ask you to do anything
that I wouldn't do myself.

00:45:30.010 --> 00:45:33.920
And so let's take a look at which applications
in Snow Leopard on the DVD that you hold

00:45:33.920 --> 00:45:39.010
in your hands are already built with LLVM and Clang.

00:45:39.010 --> 00:45:42.270
We started out switching projects
internally just a few months ago.

00:45:42.269 --> 00:45:45.449
And we started with a fairly small
project, Property List Editor.

00:45:45.449 --> 00:45:53.169
It went very smoothly and so we took more and more
aggressive steps and picked larger and larger applications,

00:45:53.170 --> 00:45:57.519
AppleScript Editor, Automator,
Dashcode, and Interface Builder.

00:45:57.519 --> 00:46:00.380
And I'm pleased to tell you that we didn't stop there.

00:46:00.380 --> 00:46:04.640
Even the Xcode that you hold in your
hands is built with LLVM and Clang.

00:46:04.639 --> 00:46:08.400
So if we can build all these applications,
I bet you, you can build yours as well.

00:46:08.400 --> 00:46:11.860
And I think you should give it a
good try if you have a quiet moment.

00:46:16.349 --> 00:46:19.360
So once you've compiled your application
you typically want to debug it.

00:46:19.360 --> 00:46:21.950
Let's take a look at our debugger.

00:46:21.949 --> 00:46:26.719
With a powerful debugger integrated right into
the Xcode IBE, you saw the Editor Center Workflow

00:46:26.719 --> 00:46:33.919
in the demo earlier today, and from advanced cases, there's
specific debugger and console windows which can bring up.

00:46:33.920 --> 00:46:37.230
One of the best things about our debugger
is it can work as a remote debugger.

00:46:37.230 --> 00:46:40.329
And that's of course what all you
iPhone developers use on a daily basis

00:46:40.329 --> 00:46:44.139
to debug your applications natively on an iPhone or an iPod.

00:46:44.139 --> 00:46:51.199
Now we also added the feature to support on
demand processes, debugging on demand processes.

00:46:51.199 --> 00:46:55.329
They're more and more types of processes that go
through different kind of code paths when they launch,

00:46:55.329 --> 00:46:57.969
depending on the type of signal that caused the launch.

00:46:57.969 --> 00:47:00.899
iPhone push notifications are a great example for that.

00:47:00.900 --> 00:47:05.039
Depending on the type of notification that
arrived, there are different kind of code paths

00:47:05.039 --> 00:47:08.519
that executed when your application launches.

00:47:08.519 --> 00:47:13.250
Xcode can now launch your application in a
special suspended state which allows the debugger

00:47:13.250 --> 00:47:15.630
to attach early on before any code is executed.

00:47:15.630 --> 00:47:21.630
You can set break points, and then cause the right
signal to go through the code path of your choice.

00:47:21.630 --> 00:47:26.099
If you want to try it out, just go to the
Executable Inspector and click on the Wait

00:47:26.099 --> 00:47:29.269
for next launch checkbox, it's that easy.

00:47:29.269 --> 00:47:32.679
Next performance tools.

00:47:32.679 --> 00:47:35.509
The flagship application of our
performance tools is instruments.

00:47:35.510 --> 00:47:42.780
Instruments is a very powerful performance tool that
allows you to collect data from multiple different kind

00:47:42.780 --> 00:47:49.900
of data sources at the same time and to display the
status side by side, in a GarageBand-like timeline view.

00:47:49.900 --> 00:47:53.630
So seeing it there side by side
allows you to spot interactions

00:47:53.630 --> 00:47:55.910
between different subsystems in your application.

00:47:55.909 --> 00:47:59.519
They will be hidden if you would
just look at the data in isolation.

00:47:59.519 --> 00:48:04.739
And best of all, there is no need to prepare your
application in any special way to use it with instruments.

00:48:04.739 --> 00:48:09.109
You can run instruments against
any application in your system.

00:48:09.110 --> 00:48:14.440
So we support a number of different kind of data
collectors ranging from CPU usage to graphics,

00:48:14.440 --> 00:48:17.030
memory, network and file system activities.

00:48:17.030 --> 00:48:21.530
Even proofed on many of the instruments that you're
already familiar with from the last releases,

00:48:21.530 --> 00:48:25.980
we've added a few new ones specifically for Snow Leopard
so that you can work with Grand Central Dispatch,

00:48:25.980 --> 00:48:31.940
and so that you can monitor threads, the instant
off state, and zombies in your applications.

00:48:31.940 --> 00:48:38.820
Now there's another performance tool that
many of you like to use and that is Shark.

00:48:38.820 --> 00:48:41.970
Shark is a very powerful low level performance tool.

00:48:41.969 --> 00:48:48.989
It's a CPU profiling tool that has very low overhead
and so it's ideal for very fine grade sampling.

00:48:48.989 --> 00:48:53.959
For the last year we've been working very hard
to bring these two technologies closer together.

00:48:53.960 --> 00:48:57.769
And we're doing that in the context
of the Instruments application.

00:48:57.769 --> 00:49:00.150
So in the new world of Instruments, you will find a number

00:49:00.150 --> 00:49:03.210
of advanced analysis features that
you might already know from Shark.

00:49:03.210 --> 00:49:10.230
For example, annotated source code viewing or call tree
charging, or best of all, we've taken the core of Shark

00:49:10.230 --> 00:49:14.280
and refactored it so that it could
be used with Instruments as well.

00:49:14.280 --> 00:49:21.310
And in that process we made it even better so that the new
time profiler instrument gives you the lowest overhead ever.

00:49:21.309 --> 00:49:23.789
To show you, here's Steve Lewallen.

00:49:23.789 --> 00:49:24.389
>> Thank you Andreas.

00:49:24.389 --> 00:49:25.210
[ Applause ]

00:49:25.210 --> 00:49:29.530
Good afternoon.

00:49:29.530 --> 00:49:36.280
Just let me get this straight, Matthew was happy to be here
because apparently he writes perfect code and Max was happy

00:49:36.280 --> 00:49:42.070
to be here with Dashcode because he didn't have to
write any code, I think that means I just got stuck

00:49:42.070 --> 00:49:45.750
with the buggy, whooped, bad performing demo code.

00:49:45.750 --> 00:49:52.849
Shoot. Well luckily I have Instruments, and Instruments in
Snow Leopard has a lot of great new features that are going

00:49:52.849 --> 00:49:58.400
to help us diagnose the issues in this demo code and
have them running just as good as the other apps.

00:49:58.400 --> 00:50:07.539
Let's go ahead and look at the demo application now and
I open it up in Xcode and I'm going to build and run it.

00:50:07.539 --> 00:50:13.380
Now what this app should do is, when I hit the enhance
button at the bottom of the window, begin to enhance

00:50:13.380 --> 00:50:16.340
or brighten up the images you see before you now.

00:50:16.340 --> 00:50:18.750
This is happening excruciatingly slowly.

00:50:18.750 --> 00:50:21.760
This application has a severe performance problem.

00:50:21.760 --> 00:50:27.700
Well here I am, I've run the app from Xcode,
I'm face to face with my performance issue.

00:50:27.699 --> 00:50:30.889
And I'd like to know what's going on inside of that app.

00:50:30.889 --> 00:50:35.719
Well I can do that using that time profiling
technology that Andreas mentioned earlier.

00:50:35.719 --> 00:50:38.289
Now pay attention to the center of the screen.

00:50:38.289 --> 00:50:44.829
I'm going to point my mouse cursor at my app and
hit the global hot keys control option tilde.

00:50:44.829 --> 00:50:46.639
Now what just happened?

00:50:46.639 --> 00:50:50.089
And equally as importantly what didn't just happen?

00:50:50.090 --> 00:50:55.940
Well because I have instruments on my doc, not
running, just in my doc, I'm afforded a minimal UI,

00:50:55.940 --> 00:51:01.940
a set of global hot keys and a few menu items
to trigger that time profiler in the kernel.

00:51:01.940 --> 00:51:05.990
When it's done the data's extracted
from the kernel and saved to disk.

00:51:05.989 --> 00:51:11.639
So put another way, I just used the next generation
of what was already a low overhead time profiler,

00:51:11.639 --> 00:51:19.309
and then we took it the next step by not even requiring you
to have a performance application running while you use it.

00:51:19.309 --> 00:51:24.500
Now the Shark Instruments was running
before, during or after that time profile?

00:51:24.500 --> 00:51:27.960
You asked for low overhead time profiling and you got it.

00:51:27.960 --> 00:51:34.110
So let's go back to the application and let's stop it.

00:51:34.110 --> 00:51:38.820
And now let me direct your attention to
Instruments running inside of the doc.

00:51:38.820 --> 00:51:42.309
It's not running, but it does have a red attention bubble.

00:51:42.309 --> 00:51:47.719
Let me click on that and I can see
that I have a recent time profile.

00:51:47.719 --> 00:51:53.629
So I'm going to select that now, now Onstruments
finally starts and what is Instruments telling us?

00:51:53.630 --> 00:51:59.160
Well it's saying that we're spending about
27.4 percent of our time in OBJC message send.

00:51:59.159 --> 00:52:04.899
Now that's part of the Objective-C runtime that's
responsible for dispatching the method calls that you make.

00:52:04.900 --> 00:52:12.269
And the only way to get that kind of a number in that
API is to dispatch a heck of a lot of method calls.

00:52:12.269 --> 00:52:17.460
Well let's keep that in mind, put it in the back of our
head for a second and in the meantime let's go ahead

00:52:17.460 --> 00:52:24.059
and use another new feature of Instruments in Snow
Leopard, library data mining, in order to remove this noise

00:52:24.059 --> 00:52:27.559
from what will be the problem in our own code.

00:52:27.559 --> 00:52:32.190
So I'm going to right click on our, or control
click on that and say charge symbol to color.

00:52:32.190 --> 00:52:32.809
So what's happened?

00:52:32.809 --> 00:52:38.960
Well I've taken the time I was spending in OBJC
message send and I've attributed it to all the colors

00:52:38.960 --> 00:52:41.750
and then I've removed it from the call tree itself.

00:52:41.750 --> 00:52:46.320
But I want to accelerate this process, so
I'm going to click on hide system libraries,

00:52:46.320 --> 00:52:48.370
and now I'm getting the right to my own code.

00:52:48.369 --> 00:52:53.609
And I can see of my own code that was executing at
the time, 98 and a half percent of the time was spent

00:52:53.610 --> 00:52:57.440
in enhance image rep using histogram mend value.

00:52:57.440 --> 00:53:03.679
Well this is basically where instruments before Snow
Leopard, instruments and before, would've left us.

00:53:03.679 --> 00:53:07.789
We'd know what the hot call frame was but we
wouldn't know why it's the hot call frame.

00:53:07.789 --> 00:53:13.730
What exactly could be going on inside of
that API to make it take up so much time?

00:53:13.730 --> 00:53:15.869
Well that's no longer a problem in Snow Leopard.

00:53:15.869 --> 00:53:18.079
Now we can go right to the source of the issue literally.

00:53:18.079 --> 00:53:25.289
So let me just make some more room here,
double click on my symbol, and great.

00:53:25.289 --> 00:53:29.400
Now I see line by line where I'm
spending my time in this function call.

00:53:29.400 --> 00:53:29.460
[ Applause ]

00:53:29.460 --> 00:53:41.340
And we can see for example that we're spending
almost 8 % of our time creating a new color

00:53:41.340 --> 00:53:45.600
and doing some other miscellaneous
things but we can see that almost 50 %

00:53:45.599 --> 00:53:51.380
of our time is spent fetching NSColors
pixel by pixel out of these images.

00:53:51.380 --> 00:53:54.869
Well I have hundreds of megabytes of image data in my demo.

00:53:54.869 --> 00:53:59.920
So this explains why we're sending such
a large number for OBJC message send.

00:53:59.920 --> 00:54:01.930
Well I have a better way to write this.

00:54:01.929 --> 00:54:10.469
So I'm going to go to Xcode and I'm going to replace
the API we saw along with its sibling API that operate

00:54:10.469 --> 00:54:20.089
on this image data at a high level, I'm going to delete
that, and I'm going to bring in a more efficient version.

00:54:20.090 --> 00:54:26.970
Now this new version of the code still goes over the
data pixel by pixel but it gets at the raw bitmap data

00:54:26.969 --> 00:54:29.929
and then use low level operations to modify it.

00:54:29.929 --> 00:54:32.109
So I'm going to save and build that.

00:54:32.110 --> 00:54:37.519
Now let's go back to instruments for a
moment and let's look at the threads user.

00:54:37.519 --> 00:54:42.849
Well this shows that we only encountered
one thread during our time profile.

00:54:42.849 --> 00:54:48.619
We already know that this is a compute bound task, we
optimized it but it's still going to be compute bound.

00:54:48.619 --> 00:54:53.599
And we know we have these discreet
units of work images to process.

00:54:53.599 --> 00:54:59.289
Well I have this powerful Mac Pro on stage that
has 8 cores, 1, 2, 3, 4, 5, 6, 7, 8, 8 cores on it.

00:54:59.289 --> 00:55:04.679
And I'd love to be able to distribute my
work concurrently across all of those cores.

00:55:04.679 --> 00:55:07.629
Well this case screams for using Grand Central Dispatch.

00:55:07.630 --> 00:55:09.400
So let's go back to Xcode and do that now.

00:55:09.400 --> 00:55:13.320
I'm going to close that file and
open up my enhanced controller.

00:55:13.320 --> 00:55:16.550
Now at the bottom of that, I have
this little API called Enhance.

00:55:16.550 --> 00:55:19.539
And this is what's called obviously when
I hit that enhance button on the screen.

00:55:19.539 --> 00:55:21.269
So I'm going to go and delete that.

00:55:21.269 --> 00:55:27.820
And I'm going to bring in a new version
that uses Grand Central Dispatch.

00:55:27.820 --> 00:55:30.450
Now, what's this new API going to do?

00:55:30.449 --> 00:55:35.189
Well it's still going to go over the images one
by one, but it's going to dispatch asynchronously

00:55:35.190 --> 00:55:41.220
to the concurrent queue an operation to enhance
my image on a thread of the kernel's choosing.

00:55:41.219 --> 00:55:44.069
And then it's going to asynchronously
dispatch to the main queue

00:55:44.070 --> 00:55:48.450
which will be the main thread a
small bit of code to update the UI.

00:55:48.449 --> 00:55:51.339
Great, let me save and build that.

00:55:51.340 --> 00:55:55.850
So whenever you take some code and you're trying
to break it up into concurrent operations,

00:55:55.849 --> 00:55:58.079
you should do as they say and trust but verify.

00:55:58.079 --> 00:56:02.460
Because it may be the case that you're using
a framework for example that has a global lock

00:56:02.460 --> 00:56:08.019
or maybe your operations are somewhat I/O bound or
there's some other condition that's precluding you

00:56:08.019 --> 00:56:11.539
from achieving the concurrency that you were seeking.

00:56:11.539 --> 00:56:16.659
Well another thing that's great about Instruments in Snow
Leopard is that simultaneously with this great technology

00:56:16.659 --> 00:56:22.670
such as Grand Central Dispatch we released Instrumental to
help you analyze how you're going to use that technology.

00:56:22.670 --> 00:56:27.750
In this case we call it the multicore
instrumentation and we can use it now to see

00:56:27.750 --> 00:56:30.099
if we've achieved concurrency with these changes.

00:56:30.099 --> 00:56:36.889
So what I'm going to do is go up to the run
menu and say run the performance tool multicore.

00:56:36.889 --> 00:56:42.379
So all the instrumentation is starting up and
my app is going to start up here in a second.

00:56:42.380 --> 00:56:45.070
And now let me hit the enhance button again.

00:56:45.070 --> 00:56:48.510
Wow. Those things really moved a lot more quickly.

00:56:48.510 --> 00:56:50.950
And they were enhanced out of order.

00:56:50.949 --> 00:56:54.649
I don't know if you noticed that, but that enhance
that we've achieved some bit of concurrency,

00:56:54.650 --> 00:56:57.070
but let's go back to instruments now and verify.

00:56:57.070 --> 00:57:01.880
So I'm going to find the detail view
in Instruments just for a moment.

00:57:01.880 --> 00:57:03.960
And I'm going to explain to you what we're seeing.

00:57:03.960 --> 00:57:10.829
This is the first instrument thread states, and it shows
many threads were created approximately simultaneously

00:57:10.829 --> 00:57:16.139
and what I want to do is see several
things running at the same time.

00:57:16.139 --> 00:57:16.619
Well, great.

00:57:16.619 --> 00:57:20.089
We saw that and that says that we
did have things running concurrently.

00:57:20.090 --> 00:57:23.700
Now let me go to the dispatch instrument
and go to the blocks view, this third view.

00:57:23.699 --> 00:57:28.589
I'm going to search for enhance
which will be part of my block name.

00:57:28.590 --> 00:57:32.710
Great, so I see two groups of 20
blocks each,  20 images, 20 bl ocks.

00:57:32.710 --> 00:57:39.119
The first group was processing the image, enhancing it on
some other thread and the second group was updating the UI.

00:57:39.119 --> 00:57:43.150
Super, so we did achieve concurrency
and all of our blocks are processed.

00:57:43.150 --> 00:57:44.360
Excellent.

00:57:44.360 --> 00:57:51.059
So, let's go back to the app and let's look at the third
and final issue I want to diagnose with Instruments.

00:57:51.059 --> 00:57:56.199
The problem is that if I click on an image
and I try to put it back, it crashes.

00:57:56.199 --> 00:58:00.750
Well if we look at the crash report, I
have this somewhat unhelpful message saying

00:58:00.750 --> 00:58:04.550
that I sent something to a read object.

00:58:04.550 --> 00:58:08.720
Well, what this is saying is that I
have messaged an over released object.

00:58:08.719 --> 00:58:11.099
And the jargon we use for that is zombies.

00:58:11.099 --> 00:58:16.980
In this case, we have sort of a half live, half dead state.

00:58:16.980 --> 00:58:19.690
Our objects have been deallocated,
but we have a live pointer to it.

00:58:19.690 --> 00:58:22.170
We use it, we crash.

00:58:22.170 --> 00:58:29.380
Well the vital data to track down with this is the pointer
and that retain release auto release history so we can see

00:58:29.380 --> 00:58:33.050
where that imbalance was that caused it to be over released.

00:58:33.050 --> 00:58:37.160
Now I could diagnose this pre Snow
Leopard, but it was a very tedious process.

00:58:37.159 --> 00:58:43.170
I had to go back and set an environment variable, run it
in a debugger, look for a little hex number to get spit out

00:58:43.170 --> 00:58:46.889
and basically go through a process that was
similar to looking for a needle in a haystack.

00:58:46.889 --> 00:58:49.219
Tedious. It was doable, but it was tedious.

00:58:49.219 --> 00:58:52.279
Now it's about as easy in Snow
Leopard as pushing a few buttons.

00:58:52.280 --> 00:58:53.980
So let's take a look at that.

00:58:53.980 --> 00:58:55.949
I'm going to go back to Xcode again.

00:58:55.949 --> 00:58:59.919
And I'm going to say run, run with performance tool Zombies.

00:58:59.920 --> 00:59:00.559
[ Period of silence ]

00:59:00.559 --> 00:59:07.940
Our App will start up again and
it'll put it through its paces.

00:59:07.940 --> 00:59:12.420
And now I'll go through the workflow
that generates the crash.

00:59:12.420 --> 00:59:14.659
Well, what's instruments tell us?

00:59:14.659 --> 00:59:16.059
Well it's saying, bam!

00:59:16.059 --> 00:59:19.539
Right here our zombie was messaged
and here's the pointer at this time.

00:59:19.539 --> 00:59:20.960
And it has a little pointer history button.

00:59:20.960 --> 00:59:25.619
And if I click it, I get that entire
vital pointer history that I needed.

00:59:25.619 --> 00:59:26.400
Now.

00:59:26.400 --> 00:59:31.950
[ Applause ]

00:59:31.949 --> 00:59:35.939
Now I'm going to assume that the problem is in my
own code, so I'm going to search on events in it.

00:59:35.940 --> 00:59:38.210
And I see two events.

00:59:38.210 --> 00:59:42.420
A malloc event, now that was responsible
for creating the memory of the image,

00:59:42.420 --> 00:59:45.470
that can't possibly be responsible for over releasing it.

00:59:45.469 --> 00:59:46.989
And then I have a second event.

00:59:46.989 --> 00:59:47.939
An auto release event.

00:59:47.940 --> 00:59:48.889
Well, let's look at that.

00:59:48.889 --> 00:59:49.699
I'll double click on it.

00:59:49.699 --> 00:59:52.599
And then the source instruments is saying bam!

00:59:52.599 --> 00:59:55.159
Here's our over released right at this line.

00:59:55.159 --> 00:59:58.409
Well, I know how to fix this, let me go back to Xcode.

00:59:58.409 --> 01:00:04.159
What I had done in this get error for selected images
was try to follow Apple's guidelines of returning

01:00:04.159 --> 01:00:08.679
and retained auto released object to keep it valid
in the calling scope, but I forgot to retain.

01:00:08.679 --> 01:00:12.119
So I'm going to save that and rerun once again.

01:00:12.119 --> 01:00:15.190
Put the app through its paces.

01:00:15.190 --> 01:00:18.380
And look at an image.

01:00:18.380 --> 01:00:21.190
Put it back, look at another image, put it back.

01:00:21.190 --> 01:00:25.280
Great. So there you have it.

01:00:25.280 --> 01:00:31.280
The lowest overhead, the lowest overhead time profiler ever.

01:00:31.280 --> 01:00:37.200
Performance annotations right in your own source code,
library data mining and push button zombie detection.

01:00:37.199 --> 01:00:40.210
This is Instruments in Snow Leopard.

01:00:48.389 --> 01:00:48.920
Thank you.

01:00:48.920 --> 01:00:49.599
[ Applause ]

01:00:49.599 --> 01:00:50.829
>> Thank you Steve.

01:00:50.829 --> 01:00:56.599
Instruments is a really powerful tool and it's invaluable
for finding memory issues and performance bottlenecks,

01:00:56.599 --> 01:00:58.869
performance bottlenecks in your applications.

01:00:58.869 --> 01:01:07.349
But wouldn't it be nice if Xcode could actually
find your bugs before you ever saw them?

01:01:07.349 --> 01:01:11.829
Well in Snow Leopard, we are adding
a technology that does exactly that.

01:01:11.829 --> 01:01:14.199
It's called the Static Analyzer.

01:01:14.199 --> 01:01:18.609
The Static Analyzer is another huge innovation
on top of our new compiler technology.

01:01:18.610 --> 01:01:20.620
It's based on Clang.

01:01:20.619 --> 01:01:25.069
Clang is not only able to pass your source code
and hand it off to the editor on the backend,

01:01:25.070 --> 01:01:30.320
it's also able to really understand your code and to
dive deep into all the different possible code pass.

01:01:30.320 --> 01:01:34.519
And sniff for common coding errors.

01:01:34.519 --> 01:01:38.509
This slide is just some of many check
the Static Analyzer is performing.

01:01:38.510 --> 01:01:44.540
As you can see, it's ranging from memory
leaks to unused code, uninitialized variables,

01:01:44.539 --> 01:01:50.699
can even check that you're using the calling conventions
defined by our system frameworks like foundation correctly.

01:01:50.699 --> 01:01:56.449
I want to point out that tools like this
are often out of reach for most developers

01:01:56.449 --> 01:01:59.250
because usually they cost thousands of dollars.

01:01:59.250 --> 01:02:01.539
With Xcode 3.2, it's included for free.

01:02:01.539 --> 01:02:05.789
And it works great all your Mac and iPhone applications.

01:02:05.789 --> 01:02:10.940
And so we designed a new workflow around this
new technology and I'd like to ask Todd Fernandez

01:02:10.940 --> 01:02:12.679
to come up on stage and give you another demo.

01:02:12.679 --> 01:02:12.739
[ Applause ]

01:02:12.739 --> 01:02:21.949
>> Thank you Andreas and good afternoon developers.

01:02:21.949 --> 01:02:27.329
Now, there's been a lot of loose talk up
here about buggy code, no code, perfect code.

01:02:27.329 --> 01:02:29.670
So I'd like to start with a show of hands.

01:02:29.670 --> 01:02:31.539
How many of you write perfect code?

01:02:31.539 --> 01:02:31.739
[ Laughter ]

01:02:31.739 --> 01:02:35.019
Put your hand down Matthew.

01:02:35.019 --> 01:02:36.670
[ Laughter ]

01:02:36.670 --> 01:02:41.200
Well, for the rest of us, Xcode
includes a number of different tools

01:02:41.199 --> 01:02:45.379
to help you find, diagnose and fix problems in your code.

01:02:45.380 --> 01:02:51.269
Specifically compiler errors and warnings,
unit tests and now the Static Analyzer.

01:02:51.269 --> 01:02:56.889
Each tool finds different types of problems and
we made them all much easier to use in Xcode 3.2.

01:02:56.889 --> 01:03:06.829
[ Period of silence ]

01:03:06.829 --> 01:03:10.619
So I'd like to start introducing them to
you using a simple Mac OS X application

01:03:10.619 --> 01:03:14.759
which I'll open using the new Xcode 3.2 Welcome Screen.

01:03:14.760 --> 01:03:21.750
My application consists of a framework as well
as an application and unit test which use it.

01:03:21.750 --> 01:03:23.409
I'll bring up the new build results window.

01:03:23.409 --> 01:03:26.719
And the first thing you'll notice
is by golly that was a fast build.

01:03:26.719 --> 01:03:28.829
I must be building with Clang.

01:03:28.829 --> 01:03:32.670
Well, in fact I am building with Clang,
but that's not why that was fast.

01:03:32.670 --> 01:03:37.530
Xcode 3.2 persists your build results and
reloads them when you reopen the project.

01:03:37.530 --> 01:03:44.470
So you can get right back to work where you left off.

01:03:44.469 --> 01:03:44.919
[ Applause ]

01:03:44.920 --> 01:03:49.889
The second thing you'll notice is there's some new
controls underneath the toolbar to control the information

01:03:49.889 --> 01:03:52.069
that the new build results window presents to me.

01:03:52.070 --> 01:03:55.850
And I'll be using those throughout this demo.

01:03:55.849 --> 01:04:00.659
The first thing I'd like to show you is the enhanced
support for unit tests in the new build results new.

01:04:00.659 --> 01:04:08.190
We've made it really easy for you to see not
only each individual test case result, oops.

01:04:08.190 --> 01:04:12.369
But also helpful summaries at each
level of your test sweep hierarchy.

01:04:14.019 --> 01:04:19.989
I'm also extremely pleased to announce that
with iPhone SDK 3.0 you can now run unit tests

01:04:19.989 --> 01:04:22.859
against your application running on a device.

01:04:22.860 --> 01:04:28.599
[ Applause ]

01:04:28.599 --> 01:04:33.029
Now as some of you sharp eyed audience
members noticed, I have some errors

01:04:33.030 --> 01:04:35.120
and a warning here and I really want to clean those up.

01:04:35.119 --> 01:04:37.089
It's kind of embarrassing.

01:04:37.090 --> 01:04:43.269
So let's start with my unit test failure which is epic.

01:04:43.269 --> 01:04:44.900
That's easy enough to fix.

01:04:44.900 --> 01:04:47.090
[ Laughter ]

01:04:47.090 --> 01:04:48.900
Shh, don't tell my boss.

01:04:48.900 --> 01:04:50.869
Oh, he's over there.

01:04:50.869 --> 01:04:53.150
The next thing I see is I've got a compilation error.

01:04:53.150 --> 01:04:56.059
And well sure enough, sometimes I forget a semicolon.

01:04:56.059 --> 01:04:57.029
But I'm really glad I did.

01:04:57.030 --> 01:05:01.130
Because this is another example of
those more precise Clang diagnostics.

01:05:01.130 --> 01:05:06.840
No more of that indicating the missing
semicolon in the next line business.

01:05:06.840 --> 01:05:10.120
[ Applause ]

01:05:10.119 --> 01:05:15.000
Now, I believe and I'm sure you're with
me here, that I fixed both of my errors.

01:05:15.000 --> 01:05:19.909
But as Steve pointed out, trust but
verify, especially don't trust yourself.

01:05:19.909 --> 01:05:23.829
So I want to go ahead and rebuild to make
sure that I fixed both of those errors.

01:05:23.829 --> 01:05:27.739
But before I do, I'm going to switch my
display to just see the latest results.

01:05:27.739 --> 01:05:32.139
And I don't have any yet because I have not
yet rebuilt my project since I opened it.

01:05:32.139 --> 01:05:38.179
But when I do, I should see just
recompiling the source file that I fixed

01:05:38.179 --> 01:05:42.369
that missing semicolon as well as running all my unit tests.

01:05:42.369 --> 01:05:45.469
And whew, it looks like I fixed all my issues.

01:05:45.469 --> 01:05:48.449
However I seem to remember something about a warning.

01:05:48.449 --> 01:05:52.039
And in the old Xcode, this is all the
information I would have at this point.

01:05:52.039 --> 01:05:55.409
I would have lost that information about my warning.

01:05:55.409 --> 01:06:01.629
But in Xcode 3.2, I can simply switch back to
all results, which shows me not only my warning,

01:06:01.630 --> 01:06:05.809
but the latest output from each build command in my project.

01:06:05.809 --> 01:06:07.480
I don't lose information by building.

01:06:07.480 --> 01:06:16.579
So it's easy to build, fix, build.

01:06:16.579 --> 01:06:16.639
[ Applause ]

01:06:16.639 --> 01:06:19.889
So let's make this a little bit easier to
look at and let's just look at the issues

01:06:19.889 --> 01:06:23.909
in my project, not all the successful build command.

01:06:23.909 --> 01:06:28.619
And I can see that this warning is just as hard
to fix as the unit test and the missing semicolon.

01:06:28.619 --> 01:06:29.190
[ Period of silence ]

01:06:29.190 --> 01:06:34.809
So that's a really quick introduction to the
enhancements in the build results window to help you

01:06:34.809 --> 01:06:37.789
with your compiler errors and warnings and your unit tests.

01:06:37.789 --> 01:06:40.079
But I know you're anxious to see
what the Static Analyzer can do.

01:06:40.079 --> 01:06:44.340
Well we've made it really easy to use.

01:06:44.340 --> 01:06:49.090
We've added a new command to the
build menu called build and analyze.

01:06:49.090 --> 01:06:54.260
And it will go ahead and analyze my
project, which has yet another issue.

01:06:54.260 --> 01:06:57.440
It looks like the Analyzer believes
I have a leak in my project.

01:06:57.440 --> 01:06:59.050
So let's take a closer look.

01:06:59.050 --> 01:07:00.840
[ Period of silence ]

01:07:00.840 --> 01:07:06.309
Now just as compiler errors and warnings are
presented in message bubbles, so are Analyzer results.

01:07:06.309 --> 01:07:12.110
But the great thing about the Static Analyzer is it
knows a lot more about each issue and the great thing

01:07:12.110 --> 01:07:17.110
about how we've integrated it at Xcode is we
brought that information right into the editor.

01:07:17.110 --> 01:07:22.880
I access all that additional information
simply by clicking the message bubble.

01:07:22.880 --> 01:07:28.090
[ Period of silence ]

01:07:28.090 --> 01:07:33.300
[ Applause ]

01:07:33.300 --> 01:07:35.990
Now the first thing you've no doubt
noticed are those arrows.

01:07:35.989 --> 01:07:41.039
And they indicate the control flow from the previous
significant event in this issue to the next.

01:07:41.039 --> 01:07:45.529
Each issue, each event gets its own message bubble.

01:07:45.530 --> 01:07:52.100
I also get a new navigator bar at the top of the editor
which lists all of the significant events in this issue

01:07:52.099 --> 01:07:56.089
as well as provides controls for stepping
through them to understand the issue

01:07:56.090 --> 01:07:58.850
and what might be going wrong in my code.

01:07:58.849 --> 01:08:01.759
So let's, let's look at this particular issue.

01:08:01.760 --> 01:08:05.730
I'm allocating an NSMutable array
and the Analyzer is telling me

01:08:05.730 --> 01:08:09.000
that returns an object with a plus 1 retain count.

01:08:09.000 --> 01:08:11.179
Straightforward enough.

01:08:11.179 --> 01:08:12.969
Let's take a look at the next step and you can see

01:08:12.969 --> 01:08:16.449
that the control flow arrows highlight
to show that I'm on the next one.

01:08:16.449 --> 01:08:20.619
I see control flowing from the beginning of my
method, my allocation down to the end of my method

01:08:20.619 --> 01:08:25.510
where the Static Analyzer tells me that I
will no longer have a reference to that array

01:08:25.510 --> 01:08:27.280
but it still has a retain count of plus 1.

01:08:27.279 --> 01:08:30.059
This is a classic leak.

01:08:30.060 --> 01:08:34.670
Fortunately, it's very easy to fix.

01:08:34.670 --> 01:08:39.399
I simply need to release the object
to decrement the retain count.

01:08:39.399 --> 01:08:42.250
But again, trust but verify.

01:08:42.250 --> 01:08:44.500
We'll rebuild and analyze.

01:08:44.500 --> 01:08:46.779
And verify that I've cleaned up my project.

01:08:46.779 --> 01:08:49.469
So, that's a great start.

01:08:49.470 --> 01:08:51.820
But this is a sample application.

01:08:51.819 --> 01:08:55.819
I'm sure you're wondering what does this
really do for a real world application?

01:08:55.819 --> 01:09:01.529
So to show you, I'm going to switch gears to
a shifting, Open Source iPhone application

01:09:01.529 --> 01:09:04.550
for accessing the Word Press Blogging software.

01:09:04.550 --> 01:09:08.739
Now, in gratitude to the Word Press
community for being good sports about this,

01:09:08.739 --> 01:09:11.399
I'll be sure to file bug reports for
each issue I'm about to show you.

01:09:11.399 --> 01:09:12.849
[ Laughter ]

01:09:12.850 --> 01:09:17.250
I'm sure they would also really
appreciate new volunteers to help fix them.

01:09:17.250 --> 01:09:17.439
[ Laughter ]

01:09:17.439 --> 01:09:22.869
I'd also suggest that all of you build and analyze
your own projects before you feel too smug.

01:09:22.869 --> 01:09:26.630
[ Laughter ]

01:09:26.630 --> 01:09:30.390
[ Period of silence ]

01:09:30.390 --> 01:09:32.270
So this is the Word Press project.

01:09:32.270 --> 01:09:35.050
I simply checked it out from their Open Source repository.

01:09:35.050 --> 01:09:40.420
The only change I made was to make
it build against the iPhone SDK 3.0.

01:09:40.420 --> 01:09:46.149
Just as I did earlier with my sample
project, I'll build and analyze.

01:09:46.149 --> 01:09:51.039
And now I'll filter down what I see in my build
results window to just look at the Analyzer results.

01:09:51.039 --> 01:09:55.750
As you can see, there are a number
of warnings and 20 Analyzer results.

01:09:55.750 --> 01:10:00.289
In the old Xcode, this is the only way
that you could look at this information,

01:10:00.289 --> 01:10:05.239
organized by each individual build
command, typically each file being compiled

01:10:05.239 --> 01:10:11.439
But in Xcode 3.2, we've added a new by
issue view which groups them in categories.

01:10:11.439 --> 01:10:12.960
This is, yes please!

01:10:12.960 --> 01:10:14.869
Don't, don't hold your applause!

01:10:14.869 --> 01:10:20.099
[ Applause ]

01:10:20.100 --> 01:10:32.650
The team has been working really hard on
these features and they're not above flattery.

01:10:32.649 --> 01:10:32.710
[ Laughter ]

01:10:32.710 --> 01:10:33.109
Oh thank you sir.

01:10:33.109 --> 01:10:33.500
[ Laughter ]

01:10:33.500 --> 01:10:33.890
[ Applause ]

01:10:33.890 --> 01:10:34.960
Well, let me regather myself.

01:10:34.960 --> 01:10:35.500
[ Laughter ]

01:10:35.500 --> 01:10:41.340
So this is really great for the Static Analyzer which
returns in a number of different categories as you saw

01:10:41.340 --> 01:10:43.659
on the slide that Andreas presented earlier.

01:10:43.659 --> 01:10:48.239
It allows you to triage the issues you might
want to deal with in your code and perhaps work

01:10:48.239 --> 01:10:51.149
through all of your memory usage issues at once.

01:10:51.149 --> 01:10:55.750
And in fact, I'd like to start by
showing you a leak in Word Press.

01:10:55.750 --> 01:11:02.590
And those of you who may have thought my earlier example
was a bit contrived, this is exactly the same problem

01:11:02.590 --> 01:11:07.000
where the UI or alert view is allocated
at the beginning of the method,

01:11:07.000 --> 01:11:10.229
but is not released before the end of the method.

01:11:10.229 --> 01:11:11.859
And it's fixed in the same way.

01:11:11.859 --> 01:11:17.809
[ Period of silence ]

01:11:17.810 --> 01:11:23.410
Alright the next, the next issue I'd
like to show you is the logic error.

01:11:24.939 --> 01:11:30.669
We'll reenter the mode and we'll see that control
flow proceeds from the beginning of the method,

01:11:30.670 --> 01:11:34.159
down to the declaration of this bool variable named result.

01:11:34.159 --> 01:11:38.409
And there, the Analyzer tells me that
I haven't given it an initial value.

01:11:38.409 --> 01:11:42.680
OK. Let's see what happens next.

01:11:42.680 --> 01:11:49.350
Control flow proceeds through a set of IFTHENELSE statements
and then the Analyzer tells me that if in fact all of those

01:11:49.350 --> 01:11:55.690
if statement evaluate to false, I will then try to read
that variable's value and it still hasn't been initialized.

01:11:55.689 --> 01:11:59.909
Now, I know what you perfect coders are thinking out there.

01:11:59.909 --> 01:12:00.630
This isn't a bug.

01:12:00.630 --> 01:12:03.720
There are only four buttons in that alert view.

01:12:03.720 --> 01:12:08.199
So alert view tag will never return
anything outside the range of 1 to 4.

01:12:08.199 --> 01:12:12.909
And moreover you would never, ever forget to
adjust this logic if you added a fifth button.

01:12:12.909 --> 01:12:13.210
[ Laughter ]

01:12:13.210 --> 01:12:19.869
At the end of a release cycle, while
you're frantically fixing bugs,

01:12:19.869 --> 01:12:24.029
or if say an intern were helping
you out or even worse your manager.

01:12:24.029 --> 01:12:25.609
Yikes.

01:12:25.609 --> 01:12:26.420
[ Laughter ]

01:12:26.420 --> 01:12:31.359
While we've seen a number of examples where the
Static Analyzer points out a clear bug in your code,

01:12:31.359 --> 01:12:33.899
this is a really good example of
where the Analyzer indicates

01:12:33.899 --> 01:12:38.939
where your code is making an undocumented assumption
and really should be written more defensively.

01:12:38.939 --> 01:12:42.599
This is also something testing can't find.

01:12:42.600 --> 01:12:44.670
There are a number of ways we could address this issue.

01:12:44.670 --> 01:12:48.010
We could of course initialize this
variable when we declare it.

01:12:48.010 --> 01:12:53.150
We could rewrite this code to use a switch statement
with a default case that initializes the variable.

01:12:53.149 --> 01:13:01.099
Or we could make that undocumented assumption explicit
by converting this final IF statement into an assertion.

01:13:01.100 --> 01:13:02.870
Let's not forget that semicolon.

01:13:02.869 --> 01:13:07.739
[ Period of silence ]

01:13:07.739 --> 01:13:12.649
Alright, now the final issue I'd like
to show you today is another leak.

01:13:12.649 --> 01:13:16.159
[ Period of silence ]

01:13:16.159 --> 01:13:22.159
Now as you'll see, the control flow
here is a bit more complicated.

01:13:22.159 --> 01:13:25.569
But this is where the Static Analyzer really shines.

01:13:25.569 --> 01:13:30.969
With unit testing, you need to write a specific
unit test for each particular code path.

01:13:30.970 --> 01:13:35.199
Where the, the Static Analyzer can look at every
path through your code and find problems like this.

01:13:35.199 --> 01:13:38.829
So again, let's take a closer look.

01:13:38.829 --> 01:13:44.559
As we saw with the earlier leak examples, we first
allocate an object which gives it a plus one retain count.

01:13:44.560 --> 01:13:48.860
And then we start cycling through this loop.

01:13:48.859 --> 01:13:53.199
And you know it'd be a lot easier to find out
what's going on here if we could take advantage

01:13:53.199 --> 01:13:58.809
of Xcode's new Safari style find to indicate
every usage of this variable in my method.

01:13:58.810 --> 01:14:02.260
So again we start off by allocating the object.

01:14:02.260 --> 01:14:07.100
In the four loop, we're adding a series of
dictionaries which means that if this array is leaked,

01:14:07.100 --> 01:14:11.440
it's going to be a significant leak because we're
going to leak all of those dictionaries as well.

01:14:12.659 --> 01:14:16.519
Then we pass the array into this other method, postrec.

01:14:16.520 --> 01:14:22.400
And finally, well we release it before we leave the method.

01:14:22.399 --> 01:14:26.159
Doesn't look like a leak, but let's see what
else the Static Analyzer has to tell us.

01:14:26.159 --> 01:14:26.239
[ Period of silence ]

01:14:26.239 --> 01:14:31.059
Let's step to the next event.

01:14:31.060 --> 01:14:36.830
We exit the four loop, we, if that IF
statement is true we enter that block of code.

01:14:36.829 --> 01:14:39.380
We get to another IF statement.

01:14:39.380 --> 01:14:44.659
And if that is true, that's where the Analyzer is telling
me that I will no longer have a reference to that object,

01:14:44.659 --> 01:14:46.539
but it still has a retain count of plus 1.

01:14:46.539 --> 01:14:49.039
So let's have a little audience participation.

01:14:49.039 --> 01:14:51.909
Who can spot the bug?

01:14:51.909 --> 01:14:52.939
Not you Matthew.

01:14:52.939 --> 01:14:54.129
You, right in the back.

01:14:54.130 --> 01:14:57.000
That's right.

01:14:57.000 --> 01:15:01.920
We're, we're actually returning from this method.

01:15:01.920 --> 01:15:07.560
So this is again a good example that only in
this particular code path is the object leaked.

01:15:07.560 --> 01:15:12.910
And we can fix it by adding an auto release up here.

01:15:12.909 --> 01:15:16.960
If I can manage to type it and take
advantage of a great new Xcode feature,

01:15:16.960 --> 01:15:20.859
if you saw it entering the open embrace for me.

01:15:20.859 --> 01:15:26.529
[ Applause ]

01:15:26.529 --> 01:15:32.349
And of course I also need to remove that release, otherwise
we'll over release the object for certain code paths

01:15:32.350 --> 01:15:35.970
and get one of those scary zombies Steve was talking about.

01:15:35.970 --> 01:15:40.159
[ Period of silence ]

01:15:40.159 --> 01:15:42.869
So again, let's trust but verify.

01:15:42.869 --> 01:15:46.319
Now, again you see that we started
off with 20 Analyzer results.

01:15:46.319 --> 01:15:50.039
And I believe I fixed three of them,
so let's see, another pop quiz.

01:15:50.039 --> 01:15:51.479
How many should I have?

01:15:51.479 --> 01:15:52.199
>> 22.

01:15:52.199 --> 01:15:52.329
[ Laughter ]

01:15:52.329 --> 01:15:56.760
>> So hard to find good help these days.

01:15:56.760 --> 01:16:00.039
Alright, 17, that's right.

01:16:00.039 --> 01:16:02.659
And we have 17.

01:16:02.659 --> 01:16:04.859
I don't mind applause either.

01:16:04.859 --> 01:16:11.349
[ Applause ]

01:16:11.350 --> 01:16:14.480
So this is just scratching the surface
of what the Static Analyzer can do.

01:16:14.479 --> 01:16:23.349
And we think that making it this easy to use and even
fun in Xcode makes it a clear win for every developer.

01:16:23.350 --> 01:16:29.720
We've been working really hard to make great tools to help
you make the best possible Mac OS X and iPhone applications

01:16:29.720 --> 01:16:32.140
and we can't wait to see what you come up with next.

01:16:32.140 --> 01:16:33.860
Thank you very much.

01:16:33.859 --> 01:16:40.679
[ Applause ]

01:16:40.680 --> 01:16:42.210
>> Thank you Todd.

01:16:42.210 --> 01:16:44.220
So the Static Analyzer is really fantastic.

01:16:44.220 --> 01:16:49.270
And it's already had a profound impact on
the Apple internal development process.

01:16:49.270 --> 01:16:52.340
We just wrapped up our work on this a few months ago.

01:16:52.340 --> 01:16:57.130
And then we started running it over several
projects in Snow Leopard, iLife and the iPhone OS.

01:16:57.130 --> 01:17:04.319
And within just a couple of months, we
found and fixed more than 1000 bugs.

01:17:04.319 --> 01:17:09.139
It's very quickly turning the tool that we are going
to use on a daily basis to ensure high code quality.

01:17:09.140 --> 01:17:14.190
And I'm convinced that if you try it in your own
project, it's going to have the same profound impact.

01:17:14.189 --> 01:17:15.989
So with that, we are at the end of the session.

01:17:15.989 --> 01:17:19.939
Xcode 3.2 contains updates to all our major applications.

01:17:19.939 --> 01:17:26.009
And I especially encourage you to try out our new compiler
technologies, LAVM, Clang and the Static Analyzer.
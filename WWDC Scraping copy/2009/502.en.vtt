WEBVTT

00:00:12.779 --> 00:00:19.429
>> Welcome to Creating I/O Kit Drivers for
Multiple Architectures and OS Versions.

00:00:19.429 --> 00:00:26.480
My name is Ethan Bold, I'm an engineer on the I/O
Kit team, and my co-worker Jay Towslee is going

00:00:26.480 --> 00:00:29.010
to come up on stage in a little bit and join me.

00:00:29.010 --> 00:00:37.000
So today we're here to talk about some things you need to
know, and some tools that you need to build your drivers

00:00:37.000 --> 00:00:42.950
to run on as many versions and
architectures of OS X as you need to.

00:00:42.950 --> 00:00:54.370
For example, you might be releasing a driver that you want
to support as far back as OS X 10.4 for 32-bit PowerPC

00:00:54.369 --> 00:00:59.619
and 32-bit Intel architectures;
but that you also need to support

00:00:59.619 --> 00:01:06.179
on 10.6 Snow Leopard for your 64-bit Intel arcdhitecture.

00:01:06.180 --> 00:01:12.050
So one of the things that you would
do to do that, would be to...

00:01:12.049 --> 00:01:24.620
to go into X code and define a, let's see, for your
32-bit PowerPC architecture you would target the 10.4 SDK

00:01:24.620 --> 00:01:27.310
for your Intel 32-bit architec2ture.

00:01:27.310 --> 00:01:36.810
You target the 10.4u SDK and for your 64-bit
Intel architecture you target the 10.6 SDK.

00:01:36.810 --> 00:01:44.170
Now an SDK is a software development kit, and
basically that's a snapshot of all the API's

00:01:44.170 --> 00:01:48.900
that we publish with a given major release of OS X.

00:01:48.900 --> 00:01:59.630
We release a new SDK with every release of OS X,
every major release, and each new SDK is likely

00:01:59.629 --> 00:02:08.310
to contain deprecated API's, are likely
to replace API's, and to add new API's.

00:02:08.310 --> 00:02:13.300
And since you'll be developing
drivers against different SDK's,

00:02:13.300 --> 00:02:20.360
you need to know some of the big differences
in those SDK's and how to handle them.

00:02:20.360 --> 00:02:22.490
So let's get started.

00:02:22.490 --> 00:02:26.170
First off this is not an introduction to I/O Kit.

00:02:26.169 --> 00:02:33.849
I'd recommend you check out the I/O
Kit fundamentals talk from WWDC 2008.

00:02:33.849 --> 00:02:36.159
I think that's available for download on-line.

00:02:36.159 --> 00:02:38.439
It's a good intro level talk.

00:02:38.439 --> 00:02:41.329
Also this is not an iPhone talk.

00:02:41.330 --> 00:02:48.230
We're talking about kernel extensions, and kernel
extensions are not supported in the iPhone SDK.

00:02:48.229 --> 00:02:53.159
So we are talking about kernel
architectures, different architectures

00:02:53.159 --> 00:03:00.229
of user processes, and K64 and 64-bit address dspaces.

00:03:00.229 --> 00:03:10.009
So by kernel architectures I mean 32-bit
PowerPC, 32-bit Intel, and 64-bit Intel.

00:03:10.009 --> 00:03:21.569
User process possible architectures include 32-bit
PowerPC, 64-bit PowerPC, 32-bit Intel, and 64-bit Intel.d

00:03:22.590 --> 00:03:31.930
And we're gonna talk about K64, we're gonna talk about
some of the differences between K32 and 10.5 and earlier,

00:03:31.930 --> 00:03:36.840
and K64 in Snow Leopard, and then Jay's
going to come up on stage and give a demo

00:03:36.840 --> 00:03:42.000
of how to implement some of this in Xcode.

00:03:42.000 --> 00:03:49.879
So let's talk about building drivers for multiple kernel
architectures, and let's start with a little history lesson.

00:03:49.879 --> 00:03:58.129
In the beginning from 10.0 to 10.4, PowerPC was the only...

00:03:58.129 --> 00:04:02.639
32-bit PowerPC was the only supported kernel architecture.

00:04:02.639 --> 00:04:08.919
So for you as a developer, things were a little easier
because you only had one architecture to develop for.

00:04:08.919 --> 00:04:22.930
And then in 10.4, 10.4.4, and 10.4.7 we introduced some
new Intel hardware with a 32-bit Intel kernel architecture.

00:04:22.930 --> 00:04:29.160
Starting from that point, if you wanted to release
drivers that targeted both kernel architectures,

00:04:29.160 --> 00:04:40.060
you needed to release a FAT driver with
binaries for both PowerPC and i386.

00:04:40.060 --> 00:04:45.459
So coming in in Snow Leopard, we
have new 64-bit kernel support

00:04:45.459 --> 00:04:54.579
and we have dropped 32-bit PowerPC
support in the Snow Leopard kernel.

00:04:54.579 --> 00:05:08.609
So with each of these new architectures came changes
that we had to make and accommodate in the API.

00:05:08.610 --> 00:05:17.720
So we're going to talk about some of the API
changes that accompanied these architecture changes.

00:05:17.720 --> 00:05:23.300
And first we're going to talk about...

00:05:23.300 --> 00:05:31.930
before we get into the actual changes between OS X SDK's,
we're going to talk about tools you can use to write code

00:05:31.930 --> 00:05:37.540
against multiple SDK's and a single source space.

00:05:37.540 --> 00:05:46.020
So first off we're going to talk about AvailabilityMacros.h.
This is a header file, you can include.

00:05:46.019 --> 00:05:56.789
It's defined in 10.5 and 10.6 and it defines a few
constants - two important ones that we're going to talk

00:05:56.790 --> 00:06:03.270
about today are MAC_OS_X_VERSION_MIN_REQUIRED,
and MAC_OS_X_VERSION_MAX_ALLOWED.

00:06:03.269 --> 00:06:09.589
These are pre-processor constants you can
use to conditionally compile your code.

00:06:09.589 --> 00:06:15.589
MIN_REQUIRED let's you say, run this code against...

00:06:15.589 --> 00:06:18.879
when we're building against 10.4 SDK's and higher.

00:06:18.879 --> 00:06:26.759
Like I said, this is only available in 10.5 and 10.6.

00:06:26.759 --> 00:06:37.689
We do have an alternative that you can include, I'm
sorry, we have a header in our AppleSamplePCI project.

00:06:37.689 --> 00:06:44.370
It's a project associated with this session, and
you can copy it and include it into your target

00:06:44.370 --> 00:06:51.790
to provide similar constants when
you're building against a 10.4 SDK.

00:06:51.790 --> 00:06:53.800
And the one thing I haven't mentioned is

00:06:53.800 --> 00:07:01.160
that MAC_OS_X VERSION_MIN_REQUIRED is
specified by your Mac OS X deployment target.

00:07:01.160 --> 00:07:08.980
That's a setting that Jay's gonna talk
about in your Xcode build settings.

00:07:08.980 --> 00:07:14.830
So here's an example of how you might
use MAC_OS_X VERSION_MIN_REQUIRED

00:07:14.829 --> 00:07:21.579
to conditionally compile some code
against 10.4 and against later OS's.

00:07:21.579 --> 00:07:27.300
So in this top block of code...

00:07:28.810 --> 00:07:36.629
First I should say that this code implements
a virtual method from the I/OUserClientClass.

00:07:36.629 --> 00:07:42.719
So if you're implementing an IOUserClientClass, prior to...

00:07:42.720 --> 00:07:49.270
let's see, in 10.4 and earlier you would have implemented
the method IOUserClient get target and method for index,

00:07:49.269 --> 00:07:55.549
to provide user client access to
processes attaching to your driver.

00:07:55.550 --> 00:07:58.250
And from...

00:07:58.250 --> 00:08:06.180
that API was deprecated and replaced in 10.5 and
later by the method IOUserClient external method.

00:08:06.180 --> 00:08:13.459
So this code at compile time says if we're
building for an SDK that's 10.4 or earlier,

00:08:13.459 --> 00:08:18.129
we're going to use the old deprecated
get target method for index.

00:08:18.129 --> 00:08:22.480
Otherwise for building against a 10.5 or 10.6 or later,

00:08:22.480 --> 00:08:27.460
we're going to implement IOUserClient
external method instead.

00:08:27.459 --> 00:08:36.779
So like I said, MAC_OS_X VERSION_MIN_REQUIRED is
one of the big tools we can use to deal with SDK

00:08:36.779 --> 00:08:43.149
and OS version differences, so let's move
on and look at a few actual differences.

00:08:45.350 --> 00:08:47.259
First up...

00:08:47.259 --> 00:09:00.460
when we added i386 support in 10.4.7 we also added Rosetta.

00:09:00.460 --> 00:09:09.320
Rosetta lets you run PowerPC, 32-bit
PowerPC b2ased applications in user space

00:09:09.320 --> 00:09:16.330
over your driver sitting at 32-bit Intel kernel.

00:09:16.330 --> 00:09:22.530
The big consequence of this is that if you communicate
and share data between your driver and the kernel,

00:09:22.529 --> 00:09:30.100
and this PowerPC process and user space, is that
PowerPC and Intel have different bit orders.

00:09:30.100 --> 00:09:35.700
They represent bytes differently internally, and
this is something that you need to be aware of,

00:09:35.700 --> 00:09:45.560
and we're going to later on talk about
some ways that you might cope with that.

00:09:45.559 --> 00:09:47.119
Next

00:09:47.120 --> 00:09:55.289
... in the 10.4u SDK for the Intel architecture,
we introduced a class called IODMACommand.

00:09:55.289 --> 00:10:02.429
This replaced IOMemoryCursor for any DMA
that you might be doing in your text, and...

00:10:02.429 --> 00:10:14.719
yeah, just need to know about it if you're
working with any pre 10.4 code that does DMA.

00:10:14.720 --> 00:10:27.410
Let's see, so moving on to the 10.5 SDK, one of
the big pushes in the 10.5 SDK was to add support

00:10:27.409 --> 00:10:34.409
for 64-bit addressing within the kernel, which
will help your driver when you adopt these API's -

00:10:34.409 --> 00:10:40.129
will help your driver communicate
with 64-bit processes in user space.

00:10:40.129 --> 00:10:44.259
But to be clear, this was not K64 yet.

00:10:44.259 --> 00:10:47.939
K64 arrived in 10.6.

00:10:47.940 --> 00:10:56.960
This changes the support 64-bit addressing, so
the two big API changes that we're going to look

00:10:56.960 --> 00:11:03.490
at now are IOUserClient, and IOMemoryDescriptor.

00:11:03.490 --> 00:11:16.519
IOUserClient is a class that you can implement
to share data between your driver and user space.

00:11:17.539 --> 00:11:22.309
And we replaced the, we deprecated the
method "getTarget" and method for index

00:11:22.309 --> 00:11:29.739
because it did not support 64-bit data types,
and replaced it with the method "externalMethod".

00:11:29.740 --> 00:11:41.519
And with IOMemoryDescriptor we deprecated several
API's for similar reasons, and replaced them.

00:11:41.519 --> 00:11:45.809
Let's look at examples of each of those.

00:11:45.809 --> 00:11:50.389
So this is the same code sample that we just discussed.

00:11:50.389 --> 00:11:58.120
On the top we're running, on the top we're
building against an SDK 10.4 or earlier.

00:11:58.120 --> 00:12:04.940
And on the bottom we're building
against an SDK for 10.5 or later.

00:12:04.940 --> 00:12:08.310
So it's as simple as that.

00:12:08.309 --> 00:12:20.239
We've got an API that we know isn't supported after
10.4, and we're easily able to split it up like this

00:12:20.240 --> 00:12:28.649
such that we can build against a 10.4 SDK to the
architectures that we want to support our driver on,

00:12:28.649 --> 00:12:34.970
which would be 32-bit PowerPC 2and 32-bit
Intel, and the example I gave earlier.

00:12:34.970 --> 00:12:40.040
And we can support K64 in 10.6 as well.

00:12:40.039 --> 00:12:48.049
So we have for IOMemoryDescriptor,
we have this enormous chart

00:12:48.049 --> 00:12:54.029
which we usually do a quiz on after
the talk - so pay attention.

00:12:54.029 --> 00:13:06.169
And again these are just changes we made in the
10.4 SDK and earlier, versus the 10.5 SDK and later.

00:13:06.169 --> 00:13:13.039
And here's another little code snippet showing
how we use Mac OS X version min required

00:13:13.039 --> 00:13:21.419
to conditionally compile for the
10.4 SDK versus the 10.5 SDK.

00:13:21.419 --> 00:13:30.029
There's one other interesting little tidbit I have to point
out about this code, which is that we're not only checking

00:13:30.029 --> 00:13:38.379
if MAC_OS_X VERSION_MIN_REQUIRED is less than or equal
to Mac OS X version 10.4, but we are also checking

00:13:38.379 --> 00:13:46.269
if we are building for a 32-bit PowerPC
architecture; and that's because...

00:13:46.269 --> 00:13:59.649
in the 10.4 build frame, in 10.4 when we released
Intel, we maintained two different SDK's.

00:13:59.649 --> 00:14:07.809
So while we only released one SDK for 10.6 and one
SDK for 10.5 there are two SDK's out there for 10.4.

00:14:07.809 --> 00:14:18.719
PowerPC builds against the 10.4 SDK, and Intel,
32-bit Intel, builds against the 10.4u SDK.

00:14:18.720 --> 00:14:30.430
So this code is using a method that's defined in the 10.4u
SDK on the ?Elxsi interview statement, that's Intel code.

00:14:30.429 --> 00:14:39.639
And on the top that is using the
previous method to implement that.

00:14:39.639 --> 00:14:50.110
OK, so we just talked about some kernel architectures in
OS X, and some of the changes that you need to be aware of,

00:14:50.110 --> 00:14:58.269
and SDK changes that you need to be aware of in your drivers
to build against multiple architectures and OS versions.

00:14:58.269 --> 00:15:03.350
So let's jump ahead and look at user process architectures.

00:15:03.350 --> 00:15:09.509
And really we're talking about how your
driver communicates with user processes.

00:15:09.509 --> 00:15:17.039
So your drivers in the kernel, executing
in the architecture of the hardware,

00:15:17.039 --> 00:15:19.990
or executing in the kernel's architecture...

00:15:19.990 --> 00:15:29.879
processes are in their own address spaces, and executing
in their own architectures, and sometimes you need to talk.

00:15:29.879 --> 00:15:33.799
So that problem arises when...

00:15:33.799 --> 00:15:43.909
like I mentioned before, when you are a 32-bit Intel
or a 64-bit Intel process running in the kernel,

00:15:43.909 --> 00:15:49.659
and you need to communicate with a
32-bit PowerPC process in user space.

00:15:49.659 --> 00:15:52.299
We're going to talk about that in just a second.

00:15:52.299 --> 00:15:58.809
First let's run through the history
of user space architectures on OS X.

00:15:58.809 --> 00:16:04.409
First everything was PowerPC, it was 32-bit PowerPC.

00:16:04.409 --> 00:16:15.860
In 10.4 we introduced 64-bit PowerPC user process
architectures, but we're not going to talk about that a lot

00:16:15.860 --> 00:16:25.769
for two reasons: one it was never
very widely supported by OS X, and 2 -

00:16:25.769 --> 00:16:30.720
Rosetta does not support 64-bit PowerPC processes.

00:16:30.720 --> 00:16:38.870
So from now on when I talk about
PowerPC user space processes,

00:16:38.870 --> 00:16:45.480
I'm generally talking about 32-bit
user space PowerPC processes.

00:16:45.480 --> 00:16:55.500
So with our adoption of Intel we got 32-bit
Intel processes and 64-bit Intel pdrocesses.

00:16:57.690 --> 00:17:02.100
That's where we are today.

00:17:02.100 --> 00:17:12.940
So... let's first talk about whether you need to do
any work to make sure that the data you are sharing

00:17:12.940 --> 00:17:16.570
between your driver and user space is correct.

00:17:16.569 --> 00:17:22.429
If you don't communicate any data with
user space at all, then you're fine.

00:17:22.430 --> 00:17:24.460
There's nothing for you to do.

00:17:24.460 --> 00:17:28.329
But don't leave yet because we're still
going to talk about K64 in a little bit.

00:17:28.329 --> 00:17:39.539
If your device communicates with user space through an I/O
Kit family, then there is probably nothing special for you

00:17:39.539 --> 00:17:47.920
to do in your driver, because the
family will take care of byte swapping.

00:17:49.089 --> 00:17:51.759
Otherwise...

00:17:51.759 --> 00:18:00.559
otherwise you may have to worry about byte
swapping and making sure your data is accessible

00:18:00.559 --> 00:18:04.159
to user processes that you're talking to.

00:18:04.160 --> 00:18:15.259
So the two easiest, most common bridges to share
data between user space and the I/O Kit kernel

00:18:15.259 --> 00:18:21.410
in your driver are the I/O Registry, and the IOUserClient.

00:18:21.410 --> 00:18:25.560
The IORegistry is...

00:18:25.559 --> 00:18:29.500
it's pretty lightweight and it's very easy to use.

00:18:29.500 --> 00:18:37.500
It's just a few lines of coding user space, and just a few
lines of code in your driver to share data back and forth.

00:18:37.500 --> 00:18:46.059
The up side is that you get free byte ordering,
byte ordering switching if you would need

00:18:46.059 --> 00:18:49.089
to switch byte ordering for your user process.

00:18:49.089 --> 00:18:55.829
The downside is that it's not suitable
for large quantities of data.

00:18:55.829 --> 00:19:02.669
If you have lots of data to share between
user space and kernel space in your driver,

00:19:02.670 --> 00:19:06.590
you should look into using an IOUserClient instead.

00:19:06.589 --> 00:19:16.189
It provides much more flexibility and control, and it
let's you define arbitrary entry points from user space

00:19:16.190 --> 00:19:27.940
into the kernel so that you can define calls, and your
user process can pass arbitrary chunks of data to you

00:19:27.940 --> 00:19:32.549
from user space, and get arbitrary chunks of data back.

00:19:32.549 --> 00:19:39.700
Unlike IORegistry, you do need to be aware of the
endianness of the process that you're talking to.

00:19:39.700 --> 00:19:47.370
And in just a second we're going
to talk about how you can do that.

00:19:47.369 --> 00:19:53.759
So let's start with a code snippet of some IORegistry code.

00:19:53.759 --> 00:20:04.589
Like I said, it's fairly simple to share data
between a user space process and your I/O Kit driver.

00:20:04.589 --> 00:20:15.589
This sample on top shows this single line of code from
user land that passes a dictionary of key value pairs

00:20:15.589 --> 00:20:28.119
into your driver, and as long as your driver implements
the IORegistry method, IORegistryEntryMethodSetProperties,

00:20:28.119 --> 00:20:40.429
your driver can then get that dictionary and investigate all
of the strings and numbers and arrays that it might contain.

00:20:40.430 --> 00:20:46.460
So next up is a considerably scarier
example of using the IORegistry.

00:20:46.460 --> 00:20:55.529
So you don't need to read this code
very closely, this is mostly up here...

00:20:55.529 --> 00:21:04.970
to provide an example of the fact that it is
unsafe to modify a collection in the IORegistry.

00:21:04.970 --> 00:21:15.220
If you have code in your driver that does a "get" on a
property, and the IORegistry gets a dictionary or an array,

00:21:15.220 --> 00:21:22.650
and then modifies that dictionary or an array that
is unsafe code which could lead to a kernel panic,

00:21:22.650 --> 00:21:30.890
due to the fact that those collection modifications are
not atomic and if another thread should come along and try

00:21:30.890 --> 00:21:40.720
and read that property, either in user space or
kernel space, you are at risk for a kernel panic.

00:21:40.720 --> 00:21:44.490
So that's just something to be aware of.

00:21:44.490 --> 00:21:52.620
We also have some boot-r's that you can set
via NVRAM that will kernel panic the second

00:21:52.619 --> 00:21:59.969
that you actually modify a collection, and
that's great for tracking down this kind of bugs.

00:21:59.970 --> 00:22:07.710
If you're ever tracking down a very sporadic crash in
your driver, I'd recommend you dig up that boot-r again,

00:22:07.710 --> 00:22:11.480
make sure you're not modifying any collections live.

00:22:11.480 --> 00:22:16.549
So that was a brief look at the IORegistry.

00:22:16.549 --> 00:22:29.889
Here is the code that you would use in a user space process
to share data with your driver through an IOUserClient.

00:22:29.890 --> 00:22:37.100
Now if you'll recall, a couple of times
we've looked at a slide with example code,

00:22:37.099 --> 00:22:48.740
showing how you would conditionally compile your
IOUserClient implementation for 10.4 versus 10.5 or 10.6.

00:22:48.740 --> 00:22:53.690
And just like IOUserClient changed between 10.4 and 10.5,

00:22:53.690 --> 00:23:00.580
the UserClient methods to send data
to an IOUserClient also changed.

00:23:00.579 --> 00:23:05.139
So this just demonstrates the same
idea that we looked at in the kernel

00:23:05.140 --> 00:23:10.440
of conditionally compiling your code for a 10.4 SDK...

00:23:10.440 --> 00:23:20.779
when necessary, or a 10.5 or 10.6 SDK otherwise.

00:23:20.779 --> 00:23:26.139
So here's the slide I've been alluding to.

00:23:26.140 --> 00:23:35.480
This is where we actually can check in our IOUserClient
code whether the user process that we're communicating

00:23:35.480 --> 00:23:46.049
with is the same endianness of us, and if not make sure that
we byte swap any data that we share with that user process.

00:23:46.049 --> 00:23:57.289
So... so this top block of code, this first block
of code is run in the AppleSamplePCI User Client.

00:23:57.289 --> 00:24:05.589
Again, this code is all from the AppleSamplePCI
project, sample code you can download.

00:24:05.589 --> 00:24:07.980
This is from the init routine.

00:24:07.980 --> 00:24:14.470
So if you're not familiar with an
IOUserClient, each IOUserClient attached

00:24:14.470 --> 00:24:20.220
to your driver is attached to exactly
one process in user space.

00:24:20.220 --> 00:24:28.400
If you had five or six or a dozen user
processes, user process clients of your driver,

00:24:28.400 --> 00:24:36.660
each one of them would have its own I/O User Client
in the kernel; its own instantiation of this class.

00:24:36.660 --> 00:24:46.940
So this is in the init routine of
AppleSamplePCI's IOUserClient implementation.

00:24:46.940 --> 00:24:54.330
The first thing it does is it checks for
the property User Client CrossEndian key.

00:24:54.329 --> 00:25:00.730
If CrossEndian key exists, that means that
the client is of an opposite endianness,

00:25:00.730 --> 00:25:06.559
and we've have to swap data before
sharing data with that client.

00:25:06.559 --> 00:25:18.710
So what we do is we set a CrossEndian compatible key to
true, and we remember that this is a CrossEndian client

00:25:18.710 --> 00:25:26.650
by setting a local member variable, fCrossEndian to true.

00:25:26.650 --> 00:25:35.019
And then later on, this is a snippet from when
we're publishing data up to our user space client,

00:25:35.019 --> 00:25:41.259
how we just check that local member variable, and it's set.

00:25:41.259 --> 00:25:52.089
Then we're going to run OSSwapInt64 on this 64-bit
data type, to individually swap the bytes to make it

00:25:52.089 --> 00:25:56.839
so that this data is readable by
the process that we're targeting.

00:25:56.839 --> 00:26:02.909
So I also want to point out that this code detects
that it is attached to a CrossEndian client

00:26:02.910 --> 00:26:06.550
and it says OK that's great, I'm compatible.

00:26:06.549 --> 00:26:07.849
But you don't have to do that.

00:26:07.849 --> 00:26:12.959
You can, like this code could have
just as well de-allocated all of its,

00:26:12.960 --> 00:26:18.279
all the resources that it had previously
allocated, and returned null...

00:26:18.279 --> 00:26:23.720
and that user process simply wouldn't
get a user client into your driver.

00:26:23.720 --> 00:26:27.730
So you don't have to support CrossEndian clients.

00:26:29.920 --> 00:26:35.960
Alright, that's everything I have for
managing different user space architectures.

00:26:35.960 --> 00:26:38.640
We're talk for just a little bit about K64.

00:26:38.640 --> 00:26:52.410
K64 is the new 64-bit Intel kedrnel in Snow Leopard, and
we're going to talk about some of the big differences

00:26:52.410 --> 00:27:01.900
between K64 and K32, which was the 32-bit kernel
- kernel architecture in 10.5 and earlier.

00:27:01.900 --> 00:27:14.290
So the first thing to know about K64 is that
pointers are twice as wide as they used to be.

00:27:14.289 --> 00:27:25.799
K64 has a 64-bit address space, so to represent that we have
to use 8 bytes to represent a pointer instead of as in K32

00:27:25.799 --> 00:27:28.440
when we only needed 4 bytes to represent that pointer.

00:27:28.440 --> 00:27:44.320
One consequence of that is that if you have any code that
assumes, like on our prior 32-bit kernels, that integers

00:27:44.319 --> 00:27:47.069
and pointers were the same size because they used to be.

00:27:47.069 --> 00:27:51.980
Integers used to be 4 bytes, integers
were 4 bytes and pointers were 4 bytes.

00:27:51.980 --> 00:27:57.339
However in Snow Leopard, integers are
still 4 bytes but pointers are 8 bytes.

00:27:57.339 --> 00:28:07.619
So one consequence of that might be that you have code
that stores a pointer into an integer data type, which...

00:28:07.619 --> 00:28:21.309
which probably would have worked just fine in a 32-bit
kernel,2 but in a 64-bit kernel that 8 byte pointer stored

00:28:21.309 --> 00:28:33.960
into a 4 byte integer would truncate the top 4 bytes of
that, and you would be left with a meaningless pointer.

00:28:33.960 --> 00:28:44.240
So if you're ever debugging an issue like this in GDB,
one thing you can look for is that in Snow Leopard,

00:28:44.240 --> 00:28:51.509
in 10.6, the top few bytes of each address...

00:28:51.509 --> 00:28:57.970
of every pointer you have, should begin with 0x7ffff...

00:28:57.970 --> 00:29:01.289
and maybe a few more f's.

00:29:01.289 --> 00:29:09.139
So that's a good safety check if you're ever
investigating a pointer, or looking at a pointer

00:29:09.140 --> 00:29:12.700
and it doesn't look like that, it's wrong.

00:29:12.700 --> 00:29:21.940
Another thing to be aware of in K64 is structure alignment.

00:29:21.940 --> 00:29:31.360
Since longs and pointers have doubled
in size from 4 bytes to 8 bytes...

00:29:31.359 --> 00:29:41.969
if you're passing any structures of integers and longs
and pointers from a 64-bit process, or a 64-bit driver,d

00:29:41.970 --> 00:29:48.069
to a 32-bit process, then you need to just be aware

00:29:48.069 --> 00:29:54.659
that the compiler may very well have
laid out that structure differently.

00:29:54.660 --> 00:29:59.860
And I should also point out that if you're
interested in learning more about K64,

00:29:59.859 --> 00:30:05.859
there's a couple of really good references that are
much more detailed than what I'm talking about today.

00:30:05.859 --> 00:30:12.569
The first is the K64 talk at WWDC in 2008.

00:30:12.569 --> 00:30:15.599
It's a really, really information-packed talk.

00:30:15.599 --> 00:30:26.549
The second is there is a document published by Developer
Relations called the, I think it's the K64 Transition Guide.

00:30:26.549 --> 00:30:33.720
And we have a link to that at the end of this talk.

00:30:33.720 --> 00:30:37.420
So I'm sorry, I was talking about structure alignment.

00:30:37.420 --> 00:30:49.740
The compiler, usually the compiler likes to align
data types along boundaries equal to their size.

00:30:49.740 --> 00:31:03.039
So... so an 8 byte pointer is likely to be
aligned at a multiple of 8 bytes in the structure.

00:31:03.039 --> 00:31:09.619
So because of that, the compiler's
likely to insert a lot of empty space.

00:31:09.619 --> 00:31:19.149
If your structures aren't optimally arranged, if
it needs to put a 4 byte next to a 4 byte pointer,

00:31:19.150 --> 00:31:24.970
it could very likely just drop 4
bytes of empty space in between.

00:31:24.970 --> 00:31:31.430
So not only is that a waste of space, but
it might not be the same struct format

00:31:31.430 --> 00:31:36.360
that maybe your file formats were
expecting, or other clients were expecting.

00:31:36.359 --> 00:31:43.229
We should also mention that...

00:31:43.230 --> 00:31:54.490
that with 64-bit addressing and K64, we started
paying a lot more attention to address data types.

00:31:54.490 --> 00:32:02.980
A lot of the data types we were using in the kernel and in
user space were really only suitable for 32-bit addresses,

00:32:02.980 --> 00:32:10.490
so you'll see a lot of change, a lot of code
moving to use these new bigger data types

00:32:10.490 --> 00:32:16.799
that store 64-bit addresses like mach_vm_address_t.

00:32:16.799 --> 00:32:27.659
And of course we already talked about some of the API
changes in the 10.5 SDK that you need to pay attention to,

00:32:27.660 --> 00:32:32.550
as you're moving on to 10.6 and to support K64.

00:32:32.549 --> 00:32:44.450
So... I've got a quick code snippet to show some of the
different addressing data types that I just talked about.

00:32:44.450 --> 00:32:51.380
Up top this is some kernel code that used
to use the data type IOVirtualAddress.

00:32:51.380 --> 00:33:01.330
It still does, when building against the SDK for
10.4 and earlier, and that is replaced by the...

00:33:01.329 --> 00:33:07.609
the more 64-bit friendly address
data type mach_vm_address_t.

00:33:08.799 --> 00:33:14.250
And here in user land, we have a similar sort of thing.

00:33:14.250 --> 00:33:19.029
This is a user space process and it's checking the seed...

00:33:19.029 --> 00:33:25.279
to find constant LP64, if it's building against a...

00:33:25.279 --> 00:33:32.579
a 64-bit architecture, in this struct, the
middle of the struct that it's defining

00:33:32.579 --> 00:33:38.339
that will use the 64-bit address
data type mach_vm_address_t.

00:33:38.339 --> 00:33:44.139
Otherwise it will use the 32-bit
address data type vm_address_t.

00:33:44.140 --> 00:33:48.070
And that's my very, very quick summary of K64.

00:33:48.069 --> 00:33:56.569
I'm really not doing it justice, so I recommend
you check out that K64 talk from WWDC 2008.

00:33:56.569 --> 00:34:00.730
And with that I'm going to hand things over to Jay Tasley.

00:34:00.730 --> 00:34:06.089
Jay is going to walk through some Xcode settings.

00:34:06.089 --> 00:34:15.190
>> Okay before we get started, quick sort of summary of the
K64 development tools that you're going to need to look for.

00:34:15.190 --> 00:34:20.730
In the move to Snow Leopard we've changed
GCC to 4.2 as the system compiler.

00:34:20.730 --> 00:34:27.079
There's a lot of calls that might have been
deprecated in K32, or the PowerPC kernel.

00:34:27.079 --> 00:34:32.329
Not only are they deprecated, they're not there in K64.

00:34:32.329 --> 00:34:35.259
So deprecation is for real.

00:34:35.260 --> 00:34:39.280
So we cleaned up a bunch of things, and
you're going to need to watch for that.

00:34:39.280 --> 00:34:45.700
In terms of moving your KEXT over, the simplest
piece of advice I can give you is enable...

00:34:45.699 --> 00:34:47.960
let the compiler do a lot of work for you.

00:34:47.960 --> 00:34:54.360
Enable all the warnings, ironically Wall
doesn't actually enable all the warnings,

00:34:54.360 --> 00:35:01.840
so you might also want to enable Wshorten-64-to-32, which
is the one that will probably cause you the most trouble;

00:35:01.840 --> 00:35:04.880
particularly if you're dealing with an old code base.

00:35:04.880 --> 00:35:10.619
And finally, and Ethan's been alluding
to it, architecture specific SDK's

00:35:10.619 --> 00:35:17.920
and OS version specific SDK's are something I'm going to
show you how to use to target in your code the changes.

00:35:17.920 --> 00:35:27.230
And finally, if you're doing new development, all
KEXTs are both 32 and 64 bit what we call universal.

00:35:27.230 --> 00:35:34.769
Three-way FAT if you're going to support back to
PowerPC code on even as early as 10.3.9, 10.4.

00:35:34.769 --> 00:35:39.400
And certainly two-way FAT if you're
going forward from 10.6 on.

00:35:39.400 --> 00:35:47.760
So with that, I'm going to switch over to the demos.

00:35:48.849 --> 00:35:50.909
Do I need to...

00:35:55.019 --> 00:36:00.690
I switched my selector up here and I'm not getting video.

00:36:02.250 --> 00:36:04.010
Sorry.

00:36:04.010 --> 00:36:07.920
[ Silence ]

00:36:07.920 --> 00:36:10.480
What did I do wrong?

00:36:10.480 --> 00:36:12.010
This one...

00:36:12.010 --> 00:36:28.590
[ Silence ]

00:36:28.590 --> 00:36:31.100
Victim of my own success.

00:36:31.099 --> 00:36:37.380
Okay, this is the general settings for
the project, the AppleSamplePCI project,

00:36:37.380 --> 00:36:43.700
and you're looking at setting a base SDK of
10.6 and this is pretty much the normal deal.

00:36:43.699 --> 00:36:50.889
Here also setting overall the gcc warning
flags, those flags that I mentioned earlier.

00:36:50.889 --> 00:36:54.359
It's also important to note that
this is probably the kind of place

00:36:54.360 --> 00:36:56.849
where you're gonna see some architecture specific settings.

00:36:56.849 --> 00:37:04.199
For those of you that haven't played in Xcode in here in a
while, remember that that's down in the little gear setting

00:37:04.199 --> 00:37:10.909
where I can add basically any new setting I want;
specifically if I'm going to add to an SDK, I can do this...

00:37:10.909 --> 00:37:12.829
oops, sorry.

00:37:16.929 --> 00:37:25.659
And basically choose, based on the architecture
type, which SDK I might want to use.

00:37:25.659 --> 00:37:30.159
And theoretically you could take this
example all the way back to 10.3.9.

00:37:30.159 --> 00:37:36.779
The reality is there is one piece of code that is
not in the 10.3.9 SDK, which is a collections piece,

00:37:36.780 --> 00:37:41.410
which deals with that live registry piece
that Ethan was talking about earlier.

00:37:41.409 --> 00:37:46.639
But it certainly compiles and runs 10.4, 10.5, and 10.6.

00:37:46.639 --> 00:37:52.889
So looking at the settings for an actual
KEXT itself, this is the setting for the KEXT

00:37:52.889 --> 00:37:57.239
that we're going to run on all 10.5 and all 10.6 systems.

00:37:57.239 --> 00:38:03.389
So we talked earlier about shedding both the
SDK, so specifically we're setting the SDK's

00:38:03.389 --> 00:38:08.650
for 10.5 for Intel 32-bit and PowerPC 32-bit.

00:38:08.650 --> 00:38:15.280
We're also setting the compiler versions appropriately, and
we're also setting the deployment targets appropriately.

00:38:15.280 --> 00:38:21.900
So you need to get all three of those in alignment to
make the availability macros do what you want them to do.

00:38:21.900 --> 00:38:27.780
Get that wrong, and it's a world of hurt to
figure out which one you didn't do correctly,

00:38:27.780 --> 00:38:32.300
because numbers will not make sense -
not that I've ever done that or anything.

00:38:32.300 --> 00:38:38.240
Anyway here's also where you're going to choose, if you're
doing that new development this buys you a lot of things,

00:38:38.239 --> 00:38:44.359
just to say standard 32-bit, 64-bit
Intel or 32-bit, 64-bit Universal.

00:38:44.360 --> 00:38:49.930
Now if we look at the specific sub-KEXT that we'll
talk about in a couple of minutes in this project,

00:38:49.929 --> 00:38:55.149
this is a KEXT that is built primarily to support 10.4.

00:38:55.150 --> 00:39:02.440
This is directly targeted with the base SDK, and
you notice I've got the PowerPC SDK specified here,

00:39:02.440 --> 00:39:07.280
that's actually not necessary - you could take
that out because it'll just pick up the 10.4 basic.

00:39:07.280 --> 00:39:10.860
And you'll also notice that we changed the compiler version.

00:39:10.860 --> 00:39:17.400
So that is going to, when I build this, the
flags that are set by this SDK are what's going

00:39:17.400 --> 00:39:21.690
to conditionally compile base in the availability macros.

00:39:21.690 --> 00:39:28.840
Anyway... so let's zoom back out so we can
see a little bit more of what we're doing.

00:39:28.840 --> 00:39:31.010
The KEXT itself...

00:39:31.010 --> 00:39:43.480
[ Silence ]

00:39:43.480 --> 00:39:50.539
... loads and it should be pointed
out that this is a K64 system.

00:39:50.539 --> 00:39:55.769
And Ethan talked earlier about the addresses
and the types of addressing you're going to see,

00:39:55.769 --> 00:39:58.690
and it looks like we got it a little bit backwards.

00:39:58.690 --> 00:40:02.800
So ignore that 7, it should actually be all f's and an 8.

00:40:02.800 --> 00:40:03.780
Sorry about that.

00:40:03.780 --> 00:40:06.880
That says we didn't edit well enough, apologize.

00:40:06.880 --> 00:40:09.500
Anyhow, this is the magic number that you're going to see.

00:40:09.500 --> 00:40:15.510
If you're not seeing in your debugging on a K64
system, if you're not seeing this in your pointers,

00:40:15.510 --> 00:40:19.330
you've probably got a truncation issue and that's
the time to go back, if you haven't already,

00:40:19.329 --> 00:40:24.920
and enable that shorten 64 to 32 and
look for 2where that's biting you.

00:40:24.920 --> 00:40:32.970
So now that the KEXT is loaded, let's try
a couple of sample clients against it.

00:40:32.969 --> 00:40:35.219
So we'll start with PowerPC.

00:40:35.219 --> 00:40:42.119
PowerPC support, or Rosetta support, in the developer seed
is enabled as an option so if you try this when you get home

00:40:42.119 --> 00:40:46.819
and it doesn't, or if you've tried it here at
the show, it's because you'll need to reinstall

00:40:46.820 --> 00:40:51.170
or go into the installer and specify
the option Rosetta setting.

00:40:51.170 --> 00:40:56.570
But you'll see that Rosetta has loaded, and you can
tell that Rosetta is loaded if we look over here,

00:40:56.570 --> 00:41:02.559
we can see that we have the CrossEndian flag
set - this is my kernel log by the way -

00:41:02.559 --> 00:41:08.049
and you can also see where I've actually been able to
use that set properties piece that Ethan was talking

00:41:08.050 --> 00:41:11.640
about earlier, and I've set a value
in the registry here of 24.

00:41:11.639 --> 00:41:16.900
For those of you that were paying attention to the
source code sample Ethan showed a little earlier,

00:41:16.900 --> 00:41:20.349
remember that we had 8, 7, 6, 5, 4, 3, 2, 1.

00:41:20.349 --> 00:41:26.269
You'll notice that in this PowerPC version, we've swapped
those bytes because this would not be 8, 7, 6, 5, 4, 3, 2,

00:41:26.269 --> 00:41:30.289
1 if we hadn't handled that using the Rosetta support.

00:41:33.369 --> 00:41:41.359
So just to prove that we have everything
working, let's quickly go through and check 386.

00:41:41.360 --> 00:41:46.620
You'll notice that you have slightly different
buffers, and that's because as Ethan alluded to,

00:41:46.619 --> 00:41:51.670
every user client gets its own
instantiation of the different user methods,

00:41:51.670 --> 00:41:55.670
and the buffers are allocated local to the process.

00:41:55.670 --> 00:42:00.519
You'll notice that we're still getting our
correct answer here, and you'll notice over here

00:42:00.519 --> 00:42:08.210
that we no longer see the CrossEndian flag, but we
do still see that our set properties got the 24.

00:42:11.059 --> 00:42:13.199
And finally...

00:42:15.630 --> 00:42:17.820
well almost finally.

00:42:20.650 --> 00:42:26.849
You'll notice we get a much larger buffer address,
which makes sense because this is now a 64-bit process.

00:42:26.849 --> 00:42:28.730
And again, the same things.

00:42:28.730 --> 00:42:31.690
It's not CrossEndian, and the 24 gets set.$

00:42:31.690 --> 00:42:38.470
So everything's working as we expect, again the 8,
7, 6, 5, 4, 3, 2, 1 is coming through as we expect.

00:42:38.469 --> 00:42:42.149
And just to prove that...

00:42:42.150 --> 00:42:46.010
Rosetta is not 64-bit

00:42:46.010 --> 00:42:50.790
[ Silence ]

00:42:50.789 --> 00:42:52.489
... that's what you're going to get.

00:42:52.489 --> 00:42:55.169
So that's kind of the way it works.

00:42:55.170 --> 00:43:02.829
So what's important also is that we, you had to know
how the magic works that I can run two different KEXTs

00:43:02.829 --> 00:43:05.279
and sub-KEXT types to get all this to work.

00:43:05.280 --> 00:43:07.950
So I'm going to switch back to the project itself...

00:43:07.949 --> 00:43:11.919
and talk about a couple of things.

00:43:11.920 --> 00:43:13.150
Here are two targets.

00:43:13.150 --> 00:43:21.849
The source code files for the 2 targets, for
AppleSamplePCI and AppleSamplePCI 10.4, are identical.

00:43:21.849 --> 00:43:27.259
They're ifdef like we talked about earlier, but this actual
source code that is compiled is the same source code.

00:43:27.260 --> 00:43:32.890
We're just targeting with the SDK
selection, and the deployment targets

00:43:32.889 --> 00:43:35.309
to get the proper conditional compilation.

00:43:35.309 --> 00:43:42.840
What we do to make all of this work so that the right
KEXT tries to load on the right system, is two things: 1 -

00:43:42.840 --> 00:43:53.760
we copy the sample PCI 10.4 KEXT into the plug in directory
of the one that we would normally load on 10.5 and 10.6.

00:43:53.760 --> 00:43:58.500
And so the kernel only grabs that at boot time.

00:43:58.500 --> 00:44:03.360
You can't play with this by doing KEXT load,
that doesn't work because it doesn't search

00:44:03.360 --> 00:44:07.380
into the actual plug in directory with KEXT load.

00:44:07.380 --> 00:44:12.079
So you'll have to actually install it in the
system library extensions to test this function.

00:44:12.079 --> 00:44:20.549
Having said that, what we do do
is the individual KEXT plist...

00:44:20.550 --> 00:44:25.760
will use the bundle library property to
load the right thing on the right system.

00:44:25.760 --> 00:44:29.930
So for those of you that are familiar with
all these numbers, you know that if it's 8.0

00:44:29.929 --> 00:44:32.819
that means it is going to be a Tiger system.

00:44:32.820 --> 00:44:38.690
And so this is only going to try to
load on a Tiger system, or later.

00:44:38.690 --> 00:44:50.269
However, you'll note that on the one that we've got built
for 10.5 and 10.6 support, that has for all architectures,

00:44:50.269 --> 00:44:58.579
it's going to try and load on a 10.5 system - that's the
9.0 kernel - and this is the first example you may have seen

00:44:58.579 --> 00:45:03.869
of using the bundle library specific,
architecture specific flags

00:45:03.869 --> 00:45:09.150
which the talk earlier today about
KEXT management, was using.

00:45:09.150 --> 00:45:17.930
And this is where, if it's a 64-bit kernel, we're going to
then only load it if it's 64-bit and Snow Leopard or later.

00:45:17.929 --> 00:45:20.559
That's how all that works.

00:45:20.559 --> 00:45:30.389
And just so you don't think we're yanking your
chain, I'm switching over to a x86 32-bit system.

00:45:30.389 --> 00:45:34.519
So this is a normal 10.5, 10.6 system.

00:45:34.519 --> 00:45:36.989
In this particular case it happens to be Snow Leopard.

00:45:36.989 --> 00:45:43.009
We're loading that same kernel, or that same KEXT, and...

00:45:43.010 --> 00:45:48.180
[ Silence ]

00:45:48.179 --> 00:45:50.460
... see that we get the same results.

00:45:50.460 --> 00:45:55.510
So the same code, conditionally
compiled, loaded onto 2 different systems.

00:45:55.510 --> 00:46:01.390
If I had a 10.4 system, I'd be able to show that too.

00:46:01.389 --> 00:46:06.799
Anyway, back to our slides.

00:46:06.800 --> 00:46:11.070
Summary - what is it we'd like you to take home?

00:46:11.070 --> 00:46:17.570
Well there's new API's and in particular if you're going to
support 64-bit, which by the way you have to support even

00:46:17.570 --> 00:46:24.910
if you don't have user land interaction, if you expect
your device or service or "fill in the blank" to function

00:46:24.909 --> 00:46:32.319
in a K64 world, you at least need to recompile,
resolve the warnings, resolve any deprecated API's.

00:46:32.320 --> 00:46:39.980
You need to have a 64-bit and a
32-bit Intel KEXT, or slices,

00:46:39.980 --> 00:46:46.480
in your blob for it to load and work on a K64 system.

00:46:46.480 --> 00:46:53.010
You're going to target appropriate SDK's in your code
in order to conditionally compile in the right stuff,

00:46:53.010 --> 00:46:56.030
and availability macros is your friend here.

00:46:56.030 --> 00:46:59.640
You want to match the SDK and deployment targets.

00:46:59.639 --> 00:47:04.960
You need to do both things, otherwise it won't
work correctly and it's not a lot of fun.

00:47:04.960 --> 00:47:10.150
It's kind of embarrassing to actually be caught
out doing that, again not from personal experience.

00:47:10.150 --> 00:47:15.780
And finally you're going to need to test and ship,
which we all know is on the list of things to do.

00:47:15.780 --> 00:47:22.320
So with that, a couple of more pieces of information,
Craig Keithley is your evangelist, contact.

00:47:22.320 --> 00:47:24.559
Documentation - we've talked about today.

00:47:24.559 --> 00:47:29.049
The AppleSamplePCI, which is available
today on the developer website.

00:47:29.050 --> 00:47:35.830
The SimpleUserClient, which has a lot more
detail about IOUserClient information.

00:47:35.829 --> 00:47:40.949
The 64-bit Transition Guide and Universal Binary
Programming Guidelines, those are all important.
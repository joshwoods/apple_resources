WEBVTT

00:00:12.849 --> 00:00:16.640
>> Joar: Good afternoon everyone,
and welcome to this session on State

00:00:16.640 --> 00:00:19.850
of the Art Cocoa, user interface development.

00:00:19.850 --> 00:00:26.290
My name is Joar Wingfors, and I'll be giving this
session together with my colleague Ron Lue-Sang.

00:00:26.289 --> 00:00:31.129
And I also want to get a quick shout out to
Scott Stevenson of Apple who has helped us

00:00:31.129 --> 00:00:36.210
to prepare these slides and the sample code.

00:00:36.210 --> 00:00:44.350
The Mac platform has always been defined, at least in part
by its attention to usability and user interface design.

00:00:44.350 --> 00:00:51.240
And as a result we have a lot of fantastic
applications on this platform for,

00:00:51.240 --> 00:00:54.890
from Apple and from View, [phonetic]
our third party developers.

00:00:56.170 --> 00:01:03.579
For many of these applications the user experience is
one of the most, one of the most important features

00:01:03.579 --> 00:01:08.189
that these applications are recognized
by or, or compete with.

00:01:08.189 --> 00:01:16.299
And Apple provides a rich set of tools and technologies
that helps us write these fantastic graphical applications.

00:01:16.299 --> 00:01:22.909
But if you're new to the platform, or if you're new to user
interface development in general, it can be a bit difficult

00:01:22.909 --> 00:01:28.009
to know where to get started, and
that's what this session is all about.

00:01:28.010 --> 00:01:36.150
I also want to mention that this session we are going
to expect that you have a certain level of familiarity

00:01:36.150 --> 00:01:45.439
with Xcode, Objective-C, and Interface Builder,
and not go in too much of detail on those topics.

00:01:45.439 --> 00:01:50.890
So Ron and I will take you on this journey
through the world of Cocoa UI development.

00:01:50.890 --> 00:01:55.359
And while we won't be able to cover all of
it, we hope to cover enough that by the end

00:01:55.359 --> 00:01:59.349
of this session you know enough to
be able to get around on your own.

00:01:59.349 --> 00:02:03.049
And on this journey we're going to make 4 stops.

00:02:03.049 --> 00:02:10.120
I'm going to start out by talk about how
to get started using Interface Builder.

00:02:10.120 --> 00:02:20.159
On the second stop I will talk about the
fundamentals of using Cocoa for drawing.

00:02:20.159 --> 00:02:26.810
After that Ron will come on stage and
talk about how to create custom controls

00:02:26.810 --> 00:02:32.300
and how to integrate your custom
controls in the Cocoa UI libraries.

00:02:32.300 --> 00:02:41.330
And last, Ron will talk a bit about how to use behaviors
and animations to make your user interfaces come alive.

00:02:41.330 --> 00:02:51.189
So while this session will be mostly be about the more
hands on part of creating, or viewing UI development,

00:02:51.189 --> 00:02:58.639
the successful outcome of that, of those efforts will,
to a large degree, be determined by a lot of things

00:02:58.639 --> 00:03:02.629
that have come before you actually
end up in your implementation phase.

00:03:02.629 --> 00:03:11.400
And to, to achieve really outstanding results, like
the examples on the, one of the earlier slides,

00:03:11.400 --> 00:03:18.670
you need to allow for your UI designers to affect
both the requirements and all of the input parameters

00:03:18.669 --> 00:03:23.889
for your project, as well as the output
parameters of your projects, the vision and the,

00:03:23.889 --> 00:03:26.029
and the, and the look and the functionality.

00:03:26.030 --> 00:03:36.039
You need to have, allow your user interface designers
to play like, play, have an equal part to say

00:03:36.039 --> 00:03:39.530
as your software designers for that final result.

00:03:39.530 --> 00:03:50.319
Apple provides a set of human interface guidelines
that can support and guide your UI development efforts.

00:03:50.319 --> 00:03:57.150
But it's important to note that these are not a set of
rules, these are a set of guidelines, and should not be,

00:03:57.150 --> 00:04:06.319
and you shouldn't think of them as something that limits
the, the creativity of your UI designers on the Mac.

00:04:08.210 --> 00:04:15.390
So when you do user interface developments
on the Mac you have two things to help you.

00:04:15.389 --> 00:04:19.339
You have the Cocoa UL libraries on the
one hand, and you have Interface Builder,

00:04:19.339 --> 00:04:23.359
our visual design tool, tool on the other.

00:04:23.360 --> 00:04:28.030
From time to time I hear developers who
are new to our platform they ask about how

00:04:28.029 --> 00:04:33.559
to sidestep Interface Builder entirely and how
to build all of your user interfaces in code.

00:04:33.560 --> 00:04:37.649
And while this is certainly absolutely
possible, and you know,

00:04:37.649 --> 00:04:45.889
to some extent it could be an interesting intellectual
exercise and learning experience possibly, we here at Apple,

00:04:45.889 --> 00:04:49.229
and Mac developers in general, we don't do this.

00:04:49.230 --> 00:04:52.530
Instead we're relying on user Interface Builder.

00:04:52.529 --> 00:04:54.039
And why do we do that?

00:04:54.040 --> 00:04:58.470
You've probably heard the saying that
a good developer is a lazy developer.

00:04:58.470 --> 00:05:06.220
And what we mean by that is that good developers know that
the code that you don't have to write for yourself is code

00:05:06.220 --> 00:05:11.150
that you don't have to debug or
maintain, probably for years to come.

00:05:11.149 --> 00:05:13.120
And this is where Interface Builder really excels.

00:05:13.120 --> 00:05:19.959
If you use Interface Builder to create the, the
bulk of your UI, all of the parts that make sense,

00:05:19.959 --> 00:05:26.109
you end up being so very much more productive in the end.

00:05:26.110 --> 00:05:32.930
So let's say we have a company and we've set up
to, set up to create a light table application

00:05:32.930 --> 00:05:38.199
And the light table is an application allows,
that allows users to drag in photos and images,

00:05:38.199 --> 00:05:42.449
and arrange them together to see how they work out.

00:05:42.449 --> 00:05:47.310
We have arrived at a point where
we have some design documents

00:05:47.310 --> 00:05:53.370
and art resources, and, and where do we go from there?

00:05:53.370 --> 00:05:58.740
So what I was, would do is that it would start out by trying
to identify the major components of, of the application,

00:05:58.740 --> 00:06:01.759
or in this case the application main window.

00:06:03.149 --> 00:06:07.399
So over here on the far left we
have what we call a source list.

00:06:07.399 --> 00:06:12.879
And the source list lists all of the projects that
the user has created in our light table application.

00:06:12.879 --> 00:06:19.750
You can see that for the project we have
a nice, a nice thumbnail, and a title,

00:06:19.750 --> 00:06:22.560
and a count for the number of images in the project.

00:06:22.560 --> 00:06:29.660
Beneath the source list we have a utility
bar that groups a number of controls.

00:06:29.660 --> 00:06:36.110
Over here it's the light table itself,
the main canvas of our application.

00:06:36.110 --> 00:06:41.009
And finally there is a split view that
divides the source list from the light table.

00:06:41.009 --> 00:06:46.610
[ silence ]

00:06:46.610 --> 00:06:53.970
>> Joar: In addition to being allowed to reposition
and resize the photos on the canvas, the users,

00:06:53.970 --> 00:06:58.460
our design document also calls for
allowing the users to flip over the photos

00:06:58.459 --> 00:07:05.139
and configure some display characteristics for the
photos by using a special set of controls in the back.

00:07:05.139 --> 00:07:11.620
And you can, and you might notice that just like with some
of the other controls in this, and some of the other UI

00:07:11.620 --> 00:07:18.120
in this application, the controls have a bit of a
custom theme here on the backside of our photos.

00:07:18.120 --> 00:07:25.259
So now that we have a basic understanding of the
functionality and the UI for our, our application,

00:07:25.259 --> 00:07:32.680
lets jump into our first demo and look a bit at how
you would bring this up using Interface Builder,

00:07:32.680 --> 00:07:36.009
and just how far we could get using Interface,
Interface Builder in standard controls.

00:07:36.009 --> 00:07:43.000
[ silence ]

00:07:43.000 --> 00:07:47.639
>> Joar: So just like in a good cooking show
I've cheated a bit here, and but I'm started.

00:07:47.639 --> 00:07:54.169
I created a simple Cocoa application with a single window
controller, and I've spent a couple of minutes just dragging

00:07:54.170 --> 00:08:01.240
in standard controls from the Interface Builder
library to create the basic shape of the window.

00:08:01.240 --> 00:08:04.019
You can see that it is recognizable.

00:08:04.019 --> 00:08:20.799
And if I run this application just from IB I have some
buttons down here, I have my slider, split view works.

00:08:20.800 --> 00:08:23.250
Not everything is working perfectly.

00:08:23.250 --> 00:08:31.740
For example, you know this background
behind this slider shouldn't be clickable.

00:08:31.740 --> 00:08:37.379
I sort of tried to make something that looked like a
utility bar by putting gradient button behind here,

00:08:37.379 --> 00:08:40.049
but that isn't really working out perfectly.

00:08:40.049 --> 00:08:44.009
If I were to spend just a little bit
more time using Interface Builder

00:08:44.009 --> 00:08:58.330
[ silence ]

00:08:58.330 --> 00:09:03.840
>> Joar: This is still just using the standard stuff
from Interface Builder I, I could get this far.

00:09:03.840 --> 00:09:07.000
I, I have the basic shape of the window up.

00:09:07.000 --> 00:09:09.730
I've cheated a bit and I've added
this very simple custom view

00:09:09.730 --> 00:09:12.970
to draw the background of, of the
light table, but that's about it.

00:09:12.970 --> 00:09:16.440
You have the source list appearance
with the special selection colors.

00:09:16.440 --> 00:09:23.600
I even have some basic data from my application provided
by data bindings that I can set up in Interface Builder.

00:09:23.600 --> 00:09:25.540
But it's clear that we still have some ways to go.

00:09:25.539 --> 00:09:29.639
I don't have the, sort of the darker
theme that we wanted for the glass bar,

00:09:29.639 --> 00:09:32.730
the utility bar at the bottom of the source list.

00:09:32.730 --> 00:09:37.610
We don't have all of the photos,
because the photos would have

00:09:37.610 --> 00:09:42.789
to be created problematically, so I can't set them up in IB.

00:09:42.789 --> 00:09:47.629
So all of that would have to be added
by customizations in our application.

00:09:47.629 --> 00:09:55.009
And Ron will pick up where I left off, where I left off
this demo application, and make all of those customizations

00:09:55.009 --> 00:09:59.009
to make this demo app reach the final design
that we saw from our design documents.

00:09:59.009 --> 00:10:03.710
[ silence ]

00:10:03.710 --> 00:10:11.160
>> Joar: But before Ron does that I'm going to switch
back to slides and talk to you a little bit about the,

00:10:11.159 --> 00:10:15.409
talk to you about Cocoa and Mac OS X as a drawing
platform, so that you have the understanding

00:10:15.409 --> 00:10:19.500
of the drawing technologies that we
need to create these custom controls.

00:10:19.500 --> 00:10:26.610
This will be a, a overview of the technologies that Cocoa
provides for a drawing, but it will be reasonably complete.

00:10:26.610 --> 00:10:33.100
And I am going to try to focus in on some
specific concepts that we use in Cocoa for drawing

00:10:33.100 --> 00:10:37.440
to make sure that we cover them in a good way.

00:10:37.440 --> 00:10:41.770
Now everything that we see on screen lives in a window.

00:10:41.769 --> 00:10:46.039
The tic tac toe game up here, you know,
that application window is clearly a window,

00:10:46.039 --> 00:10:52.049
but so is the menu bar, the dock,
and even the desktop picture

00:10:52.049 --> 00:10:59.500
Similarly, everything that you see in your application
windows, your buttons, your text fields, your scrollers,

00:10:59.500 --> 00:11:02.990
all of that is of a type of object called views.

00:11:04.929 --> 00:11:11.659
Views provide event handling and drawing for a
particular rectangular area inside of the window.

00:11:11.659 --> 00:11:17.139
In this case we have the background view here that
draws the checkered background for this, for this game.

00:11:17.139 --> 00:11:19.740
You can add subviews to views.

00:11:19.740 --> 00:11:25.669
And subviews added to a superview, they assume some of
those responsibilities, the drawing and event handling

00:11:25.669 --> 00:11:30.399
for the area that they cover in their
superview, the game piece in this example.

00:11:30.399 --> 00:11:37.009
In this day, in this way views are arranged to
perform a single view hierarchy inside of the window.

00:11:37.009 --> 00:11:42.429
[ silence ]

00:11:42.429 --> 00:11:47.169
>> Joar: In order for views to do their drawing
and event handling, they need to be able to refer

00:11:47.169 --> 00:11:52.819
to the casians [phonetic] inside of their canvas,
to do that they need to have a coordinate system.

00:11:52.820 --> 00:12:02.740
And the coordinate system for views are, have their origin
in the lower left corner of the view, like in this example.

00:12:02.740 --> 00:12:06.019
Some views have what is called a flip coordinate system,

00:12:06.019 --> 00:12:10.179
where the origin of the coordinate
systems in the top left corner.

00:12:10.179 --> 00:12:17.029
And we do that when the contents of the view
naturally flows from the top left corner and down.

00:12:17.029 --> 00:12:19.289
That makes it easier to lay out the contents.

00:12:19.289 --> 00:12:27.289
An, an example of that would be for
views that manages to lay out a text.

00:12:27.289 --> 00:12:33.289
The position and size of a subview inside
of its superview is called the frame

00:12:33.289 --> 00:12:42.429
The data type for the frame is a simple C structure called
NSRect, which is in turn composed by an NSPoint C structure

00:12:42.429 --> 00:12:46.849
that contains the X and Y positions,
and an NSSize C structure

00:12:46.850 --> 00:12:49.009
that contains the widths and the height of the subview.

00:12:49.009 --> 00:12:55.600
[ silence ]

00:12:55.600 --> 00:13:05.009
>> Joar: And to complete this picture just like
the superview had an internal coordinate system,

00:13:05.009 --> 00:13:07.009
so does all of the subviews in turn, of course.

00:13:07.009 --> 00:13:11.860
[ silence ]

00:13:11.860 --> 00:13:18.039
>> Joar: So while Cocoa is an object oriented
framework, not everything in Cocoa is an object.

00:13:18.039 --> 00:13:27.980
The data types and functions used to, to work with and
describe the geometry for views is an example of that.

00:13:27.980 --> 00:13:33.990
There, there are a number of convenience,
convenient that you can use to work these data types.

00:13:33.990 --> 00:13:38.019
And they might be somewhat easy to overlook
in the documentation, but you should make sure

00:13:38.019 --> 00:13:43.549
to familiarize yourself with these functions,
because they make it much, much less error prone

00:13:43.549 --> 00:13:46.629
and much more convenient to work with these data types.

00:13:46.629 --> 00:13:49.850
And among those functions there
are also a number of functions

00:13:49.850 --> 00:13:54.540
that provide basic drawing; I'm
going to call out two of those.

00:13:54.539 --> 00:14:05.679
NSFrameRect and NSRectFill, they both take an NSRect
parameter and they either, they either outline the shape

00:14:05.679 --> 00:14:08.419
of that Rect or fill that Rect
with a single color respectively.

00:14:08.419 --> 00:14:20.159
Moving on to the object oriented parts of the API,
starting out with gradient, paths, images, and text.

00:14:20.159 --> 00:14:24.789
NSGradient is a relatively new addition to the Cocoa APIs.

00:14:24.789 --> 00:14:34.159
You can create linear gradients or radial gradients
using two, as in this case, or more color stops.

00:14:35.580 --> 00:14:46.900
NSBezierPath provides for the supports
creating simple or, or very complex shapes.

00:14:46.899 --> 00:14:52.990
And we describe these shapes, or we create these
shapes using path segments that can be either straight,

00:14:52.990 --> 00:14:56.560
as in these, as in this example, or curved.

00:14:57.720 --> 00:15:05.210
And besides allowing you to describe your, your
shapes or objects, NSBezierPath also supports drawing.

00:15:05.210 --> 00:15:12.600
And you can use the path class to both stroke the
outline of a path or to fill it with single colors.

00:15:12.600 --> 00:15:23.060
What is more interesting though is that BezierPath supports
flipping other drawing operations, or masking them.

00:15:23.059 --> 00:15:27.609
If I were to use this star-shaped
path as a clip path, and then draw a,

00:15:27.610 --> 00:15:33.330
a standard rectangular image, I would
end up with something like this.

00:15:33.330 --> 00:15:43.900
And this is a very useful capability that you
should all think about; we use it all the time.

00:15:43.899 --> 00:15:51.259
Images in turn, you can create images from files or
from data in your application, and besides the obvious,

00:15:51.259 --> 00:15:58.740
the ability to draw an image to a window where the window
is the, the drawing destination, you can also use images

00:15:58.740 --> 00:16:06.460
as drawing destinations on their own, where subsequent
drawing operations get rendered into that image.

00:16:07.779 --> 00:16:15.850
NSImage provides API for loading images, and
drawing images, and other, and other things too.

00:16:15.850 --> 00:16:19.470
But they don't actually handle the image data themselves.

00:16:19.470 --> 00:16:26.800
When an image is asked to load some image data, it
turns around and creates an instance of NSImageRep.

00:16:26.799 --> 00:16:34.839
The particular subclass of ImageRep created depends on
the type of image data that you ask NSImage to load.

00:16:34.840 --> 00:16:41.350
If you were to ask NSImage to load a PNG or
JPEG file, some type of bitmap image format,

00:16:41.350 --> 00:16:45.180
NSImage would create an NSBitmapImageRep internally.

00:16:45.179 --> 00:16:51.659
Similarly if you were to try to load a
PDF image it would create an NSPFImageRep.

00:16:54.210 --> 00:17:02.300
When you do custom drawing for a view,
you can take this to 1 of 2 approaches.

00:17:02.299 --> 00:17:08.619
You could either use all of the technologies that I'm
outlining now using colors, and paths, and gradients,

00:17:08.619 --> 00:17:15.769
and you can do all of the drawing problematically
at one time, or you could have your designers do all

00:17:15.769 --> 00:17:19.819
of that hard work for you and supply you with
images that you ship with your application

00:17:19.819 --> 00:17:23.639
that you load at one time and, and draw at one time.

00:17:23.640 --> 00:17:25.700
I guess you could do a bit of both as well, right?

00:17:25.700 --> 00:17:28.360
But two approaches.

00:17:28.359 --> 00:17:35.319
If you have something like the button that we have on
this screen here where the button, button needs to be able

00:17:35.319 --> 00:17:40.349
to resize horizontally, for example it will fit, you
know, the contents of the button, like the title.

00:17:40.349 --> 00:17:45.369
This requirement doesn't preclude
you from using prerendered images.

00:17:45.369 --> 00:17:54.500
You can slice up your images, and if you were to use
the 3 and 9 part drawing functions that Cocoa provides,

00:17:54.500 --> 00:18:01.180
it's very easy to then, at one time draw
these images at the appropriate width.

00:18:01.180 --> 00:18:06.070
Using these functions take away a lot of
the positioning problems and sizing problems

00:18:06.069 --> 00:18:11.539
that would otherwise be involved by trying to
draw something like this by doing it manually.

00:18:14.500 --> 00:18:19.589
It's very easy to draw simple strings of text
in Cocoa using the attributed string class.

00:18:19.589 --> 00:18:24.099
NSAttributedString provides you with control over
all of the properties that you would typically

00:18:24.099 --> 00:18:28.009
like to manipulate or control when drawing text.

00:18:28.009 --> 00:18:34.960
You can set the font to use, you can set the
alignment of the text, you can even specify the type

00:18:34.960 --> 00:18:42.400
of truncation markers to automatically get inserted in your
text when the text is too wide to fit the allotted space.

00:18:45.490 --> 00:18:51.870
NSAttributedString also provides you with a
measurement, with the measurements that you need on,

00:18:51.869 --> 00:19:01.019
of your string in order to be able to position it before
you draw it, so the width and the height of the string.

00:19:01.019 --> 00:19:06.109
Moving on to colors and shadows, and the
reason that I separated out these two object,

00:19:06.109 --> 00:19:11.709
objects is that they work rather different,
differently from the previous four.

00:19:11.710 --> 00:19:18.360
And I want to talk a bit extra about those why them,
why they work differently and how they work differently.

00:19:18.359 --> 00:19:27.039
Here I create a red color by specify the red, green,
and blue components, and the opacity for the color.

00:19:27.039 --> 00:19:33.980
But unlike the earlier examples we don't draw colors
directly, and neither do we typically pass colors

00:19:33.980 --> 00:19:42.480
as parameters that are drawing functions, instead,
instead we sect the colors in a shared context.

00:19:42.480 --> 00:19:47.049
I'll get back to this shared context in a minute.

00:19:47.049 --> 00:19:51.149
This is how you would create a shadow
by specifying the color of the shadow

00:19:51.150 --> 00:19:54.850
and the offset from the object casting the shadow.

00:19:54.849 --> 00:20:02.189
And just like for colors we don't draw the shadows
ourselves or explicitly, instead we, again we set the shadow

00:20:02.190 --> 00:20:07.590
and its shared context where it
affects subsequent drawing operations.

00:20:07.589 --> 00:20:12.659
Even something as complex as this text
drawing here would get the shadow applied.

00:20:12.660 --> 00:20:19.650
So the shape context is represented in
Cocoa by the NSGraphicsContext class.

00:20:19.650 --> 00:20:26.990
And the graphics context is a fundamental part of the
drawing infrastructure, not only in Cocoa, but on Mac OS X.

00:20:26.990 --> 00:20:33.230
The graphics context describes the drawing
destination; it could be the window,

00:20:33.230 --> 00:20:36.309
or the bitmap image that you are drawing to.

00:20:36.309 --> 00:20:41.929
But it also provides a multitude of
configuration options that affect your drawing.

00:20:41.930 --> 00:20:47.610
We already talked about the colors and
the shadows that are set in the context.

00:20:47.609 --> 00:20:53.740
The example of using a NSBezierPath to
clip your drawing, that functionality,

00:20:53.740 --> 00:20:59.470
is also supported by the clipping radiant
support provided by the graphics context.

00:20:59.470 --> 00:21:06.170
In addition to those examples there are font
attributes, and path attributes, and the list goes on.

00:21:06.170 --> 00:21:17.330
Since this is a shared context, like a global thing,
NSGraphicsContext provide for a push and pop model

00:21:17.329 --> 00:21:20.649
to scope your local configuration changes.

00:21:20.650 --> 00:21:27.790
You access this push and pop model by using the save
and restore methods available on the graphics context.

00:21:27.789 --> 00:21:34.079
Note though that for the most part when you provide, when
you do your custom drawing in Cocoa in a subclass of NSView

00:21:34.079 --> 00:21:38.970
or something like that, for the most part you don't have to
manage the context yourself; you don't have to create it,

00:21:38.970 --> 00:21:44.740
you don't have to customize it for the most part, you
don't have to, for the most part, call, save, and restore.

00:21:44.740 --> 00:21:46.650
All of that is done for you.

00:21:46.650 --> 00:21:54.480
If you need, if you need to do those things you can,
but for many simple cases you wouldn't even have to.

00:21:54.480 --> 00:21:58.430
Now that you know a bit more about how to do drawings,

00:21:58.430 --> 00:22:01.769
we need to think a little bit about
when it is appropriate to draw.

00:22:01.769 --> 00:22:12.730
The first half of the answer to that question
is easy, we need to, we need to draw whenever,

00:22:12.730 --> 00:22:16.680
whenever state that affects our visual appearance changes.

00:22:16.680 --> 00:22:20.100
But the, there is a catch here.

00:22:20.099 --> 00:22:27.480
And that is that when the state of our application changes
oftentimes many views would be updated at the same time.

00:22:27.480 --> 00:22:32.529
And not, not only many, many views,
but also many properties per view.

00:22:32.529 --> 00:22:37.920
And there are, it is for many reason
inefficient and undesirable to try to push all

00:22:37.920 --> 00:22:46.769
of those individual display updates to screen individually
as soon as you get the, the, the, the change in the state.

00:22:46.769 --> 00:22:52.470
So to take care of that Cocoa provides
a drawing model that is coalesced.

00:22:52.470 --> 00:22:56.200
Where all of these drawing updates
are done at the same time.

00:22:56.200 --> 00:23:02.160
So this is the basic, the basic sequence
of events for how this takes place.

00:23:02.160 --> 00:23:06.950
So your view is handling some event
that changes its state in a way

00:23:06.950 --> 00:23:09.580
that that affects the visual appearance of the view.

00:23:09.579 --> 00:23:14.730
At this point the view will flag
itself as needing redisplay.

00:23:14.730 --> 00:23:22.039
Sometime later, typically at the end of the event
loop, Cocoa will call back to the view all of,

00:23:22.039 --> 00:23:28.259
all of the views that have marked themselves with
needing redisplay, and ask the views to draw.

00:23:30.529 --> 00:23:38.740
The guides that are provided on NSView to
support this is setNeedsDisplay and drawRect.

00:23:38.740 --> 00:23:44.390
Again, if you're only using standard
controls and standard properties

00:23:44.390 --> 00:23:47.759
in these controls you don't have to do this for yourself.

00:23:47.759 --> 00:23:52.200
If you have a standard NS button and change
the title, the button will mark itself

00:23:52.200 --> 00:23:55.789
as needing redisplayed, so it happens automatically.

00:23:55.789 --> 00:24:01.730
But if you create a subclass of NSView or one of
the controls, and if you add additional properties

00:24:01.730 --> 00:24:06.710
that affects your visual appearance, you're
on the hook for calling setNeedsDisplay

00:24:06.710 --> 00:24:09.529
when the state of those properties changes.

00:24:11.589 --> 00:24:18.779
drawRect, so, setNeedsDisplay is something
that you need to call at the appropriate time,

00:24:18.779 --> 00:24:25.730
drawRect on the other hand is a call back method that
you provide an implementation for in your subclass,

00:24:25.730 --> 00:24:29.400
and that Cocoa calls, but that
you never have to call directly.

00:24:29.400 --> 00:24:34.360
Remember this part of our design document.

00:24:34.359 --> 00:24:39.649
Take a closer look at this custom button
here on the back of one of our photo tiles.

00:24:39.650 --> 00:24:45.840
For my second demo I'm going to take a look at how
we provided the custom drawing for this button.

00:24:45.839 --> 00:24:52.879
And in the interest of saving on time I'm not going to
show you the code for this, but the code is about yea big,

00:24:52.880 --> 00:25:00.050
it's less than a page, and it's done all using the
techniques about, talked about earlier in this session.

00:25:00.049 --> 00:25:08.700
So whenever I start to do some kind of new custom
control, the first thing that I would typically do is

00:25:08.700 --> 00:25:14.150
that I would throw in a call to NSFrameRect and
ask it to draw just a red border on my view.

00:25:14.150 --> 00:25:18.360
And this is for just an early and quick and dirty
standard to check to make sure that, you know,

00:25:18.359 --> 00:25:23.549
I have the view set up, it, it's roughly, you
know, in the UI where it's expected to be.

00:25:23.549 --> 00:25:27.480
It's sort of similar to printer-style
debugging and code, right?

00:25:27.480 --> 00:25:32.769
And it's also somewhat useful troubleshooting
and debugging functionality

00:25:32.769 --> 00:25:36.690
for its system custom controls, if
you want to see what, what's wrong.

00:25:37.730 --> 00:25:43.890
The first thing I would do for when
creating this button is to create a path

00:25:43.890 --> 00:25:47.540
that describes the rounded rectangular
outline of the button.

00:25:47.539 --> 00:25:53.990
And I, then I would set this path to be a clipping
path for all of my subsequent drawing operations.

00:25:53.990 --> 00:26:00.490
You can't see me doing that, but as soon
as I draw the first gradient background

00:26:00.490 --> 00:26:04.539
of the button you can see the clipping path taking effect.

00:26:04.539 --> 00:26:10.299
So when I, when I draw my gradient, this
dark to darker gradient for my background,

00:26:10.299 --> 00:26:13.000
this is, I'm drawing into your rectangular area.

00:26:13.000 --> 00:26:17.849
But since I'm using the clipping path I get
this now, nice rounded rectangular outline.

00:26:17.849 --> 00:26:25.500
And there's a very convenient method NSBezierPath
for creating these rounded rectangular paths

00:26:25.500 --> 00:26:34.309
My second drawing path is to draw the
highlight sheen on the top half of the button.

00:26:34.309 --> 00:26:39.679
And I'm drawing that using a second
gradient that is much lighter.

00:26:39.680 --> 00:26:46.850
Now that I have all of, all of the background for
my button I can draw the border around the button.

00:26:46.849 --> 00:26:52.909
And that'll be very easy, since I already
have a path for the outline of the button.

00:26:52.910 --> 00:27:00.960
And I can reuse the same path that I'm using to clip
drawings to, to, to, and stroke that path to try the border.

00:27:00.960 --> 00:27:07.579
So the final thing I need to do here is just to
create an attributed string and to draw the text.

00:27:07.579 --> 00:27:15.929
And while the text here, the title says done, I'm not quite
done yet, seeing the design calls for adding a shadow.

00:27:15.930 --> 00:27:23.480
So I add the call to creating the shadow and here we are.

00:27:23.480 --> 00:27:31.880
So while this, while this mostly looks like the button
that we have in our design, since I just created this

00:27:31.880 --> 00:27:35.470
as a standard NSView subclass it doesn't
actually have any of the behavior

00:27:35.470 --> 00:27:38.769
that we would expect from buttons, from a button.

00:27:38.769 --> 00:27:39.269
I can't click it.

00:27:39.269 --> 00:27:47.730
It also doesn't have any of the important accessibility
properties that a button subclass would have.

00:27:47.730 --> 00:27:53.210
A blind user couldn't interact with this, because
this new subclass doesn't expose a title property

00:27:53.210 --> 00:27:55.840
that they could interact with.

00:27:55.839 --> 00:28:04.029
So in order for you to learn more about how to integrate
your custom drawing into Cocoa, and to do, actually,

00:28:04.029 --> 00:28:09.259
talk more about how to creating custom controls
I'm going to ask Ron to come onstage and take over.

00:28:09.259 --> 00:28:10.339
Thank you.

00:28:10.339 --> 00:28:14.889
>> Ron: Hello everyone, my name is Ron
Lue-Sang, and I'm going to talk a little bit

00:28:14.890 --> 00:28:21.620
about how we can create custom controls
that will fit the design of our application.

00:28:21.619 --> 00:28:27.729
And then go on to talking about adding custom behaviors,
and even a little animation to really breathe life

00:28:27.730 --> 00:28:31.910
into the application and make it fun for our users to use.

00:28:31.910 --> 00:28:36.990
Now the place where I want to start out
is actually where Joar finished off,

00:28:36.990 --> 00:28:40.039
which is with a basic skeleton application.

00:28:40.039 --> 00:28:46.670
A good prototype with all the pieces mostly
laid out, but not completely functional yet.

00:28:46.670 --> 00:28:48.490
Now there are a few things that are left.

00:28:48.490 --> 00:28:54.190
We have to actually implement this canvas
where the user can draw, drag photos into.

00:28:54.190 --> 00:28:58.590
There's the source list area where you can pick projects.

00:28:58.589 --> 00:29:00.779
And then there's the utility bar at the bottom.

00:29:00.779 --> 00:29:04.680
Those still have to be finished, even
though we have pieces stubbed out.

00:29:04.680 --> 00:29:12.190
Now this is just a basic process that we
use in order to get from start to finish.

00:29:12.190 --> 00:29:19.750
And it's all about making these controls and making
sure that they fit the design that we started out with.

00:29:19.750 --> 00:29:25.740
That's really the focus here, is having a
process for making our controls fit our design.

00:29:25.740 --> 00:29:29.150
Now we've already broken down the pieces.

00:29:29.150 --> 00:29:33.680
I want to focus first on the utility
bar that we have at the bottom.

00:29:33.680 --> 00:29:38.500
You know, what approach should we
take for making that utility bar real?

00:29:39.789 --> 00:29:45.889
Well we, we saw that if we were to take just a
gradient bar, a gradient button as our background

00:29:45.890 --> 00:29:49.380
and slap some pieces on top, it doesn't' work quite right.

00:29:49.380 --> 00:29:54.620
You know, if we were to just try to take a
gradient button and, and fake something in.

00:29:54.619 --> 00:30:03.799
The same would be true if we were to try and snag a
segmented control, try and piece some parts in like that.

00:30:03.799 --> 00:30:06.099
You're looking at the options that we have.

00:30:06.099 --> 00:30:09.929
There's no built, prebuilt utility bar available in Cocoa.

00:30:09.930 --> 00:30:11.600
Nothing we can just drag out of IB.

00:30:11.599 --> 00:30:19.089
So our options really come down to
building our own, and that's fine.

00:30:19.089 --> 00:30:23.759
All we have to do is take out the
placeholder pieces we have in our Nib

00:30:23.759 --> 00:30:27.039
and replace them all with just one simple custom view.

00:30:27.039 --> 00:30:33.839
And then in IB we can set the class
name for our custom view.

00:30:33.839 --> 00:30:37.949
And that will ensure that when this Nib gets loaded

00:30:37.950 --> 00:30:44.150
that custom view will be replaced by
an instance of our utility bar class.

00:30:44.150 --> 00:30:50.620
So it makes it really easy to add our custom controls
to the Nib and not have to add any fiddly code.

00:30:50.619 --> 00:30:58.349
Back to the actual implementation
of our utility bar class though,

00:30:58.349 --> 00:31:01.639
the way I would approach this is to just use composition.

00:31:01.640 --> 00:31:05.190
I mean Cocoa is an object oriented language framework.

00:31:05.190 --> 00:31:11.420
And, you know, composition is a very
object oriented thing, approach.

00:31:11.420 --> 00:31:17.350
We have just, you know, our segmented
our slider, a few buttons,

00:31:17.349 --> 00:31:22.219
an image over on the far right,
and this gradient background.

00:31:22.220 --> 00:31:28.500
We could implement this utility bar just by
subclassing NSView like Joar did for his custom button,

00:31:28.500 --> 00:31:33.700
and implement drawRect to draw this
gradient background using NSGradient.

00:31:33.700 --> 00:31:38.100
Use an NSImage to composite a little
grabber image area out on the right,

00:31:38.099 --> 00:31:44.799
and then add a couple of subviews
for the buttons and the slider.

00:31:44.799 --> 00:31:51.609
And using composition, just using this approach, we could
implement this utility bar in a pretty straightforward way.

00:31:51.609 --> 00:31:53.689
The code here isn't really that interesting.

00:31:53.690 --> 00:32:00.529
What I want to focus on is the approach
for making controls fit your design.

00:32:00.529 --> 00:32:05.379
Start out with something that's
prebuilt and see if you can tweak it.

00:32:05.380 --> 00:32:11.260
If, if there's not enough, if there isn't
anything you can do to tweak this control,

00:32:11.259 --> 00:32:19.480
then certainly look at using delegate methods that might
be available on this control to customize it further.

00:32:19.480 --> 00:32:27.210
And barring that, take a look at overriding some,
some existing methods on an existing control.

00:32:27.210 --> 00:32:32.490
So it's really just a process of starting out with
something that's prebuilt, and customizing as you go.

00:32:32.490 --> 00:32:38.339
And only if all that isn't sufficient,
take a look at making a new one.

00:32:38.339 --> 00:32:44.230
And don't be afraid to make a new one, but don't
jump in too early assuming that you'll have

00:32:44.230 --> 00:32:47.740
to go back up to subclassing NSView for everything.

00:32:47.740 --> 00:32:55.670
So with this approach in mind let's take a look
at another control that we still have to work on.

00:32:55.670 --> 00:33:04.340
We have our outline view, and it has some of the
right colors that we want, but it's still far away

00:33:04.339 --> 00:33:07.389
from being finished, from being a real source list.

00:33:07.390 --> 00:33:10.650
You know, for example, we want to
hide the disclosure triangle next

00:33:10.650 --> 00:33:13.870
to that little project group in that first row.

00:33:13.869 --> 00:33:22.469
We have to draw the custom image, and text, and photo
count all in one row in our, in our outline view.

00:33:22.470 --> 00:33:26.900
And there are actually some selection rules
for making something a real source list.

00:33:26.900 --> 00:33:29.810
For instance, that group at the top shouldn't be selectable.

00:33:29.809 --> 00:33:33.759
And you're only supposed to be able to
select one thing at a time, no more, no less.

00:33:33.759 --> 00:33:36.579
So there's a, a bunch of things we have left to do.

00:33:36.579 --> 00:33:41.579
And we could get all of this done by
using OutlineView delegate methods.

00:33:41.579 --> 00:33:48.159
So this is another one of those places where
after we've tweaked some setting in IB or in code,

00:33:48.160 --> 00:33:54.660
we can use delegation to get a lot farther
customizing these existing controls.

00:33:54.660 --> 00:33:59.690
An example here, something that's new in Snow Leopard
by the way, is being able to hid the expansion triangle

00:33:59.690 --> 00:34:05.440
for a given row in the OutlineView
just using a delegate call back.

00:34:07.349 --> 00:34:10.089
From there though we still have
some other things we need to do.

00:34:10.090 --> 00:34:17.370
We haven't touched on the custom drawing in each of
these rows, like drawing the text and the icon together

00:34:17.369 --> 00:34:25.809
and having custom editing rules, tooltip
placement, a lot of these things, it turns out,

00:34:25.809 --> 00:34:28.539
aren't customizable directly from OutlineView.

00:34:28.539 --> 00:34:34.889
But don't be disheartened, it's not
something that we, we now have to go back up

00:34:34.889 --> 00:34:37.980
and subclass NSView and rebuild everything from scratch.

00:34:37.980 --> 00:34:40.679
We wouldn't want to do that.

00:34:40.679 --> 00:34:47.879
In order to, to get the rest of this work
done, I want to talk first about cells.

00:34:47.880 --> 00:34:52.030
Now if we were to take a much simpler
control, stepping away from OutlineView,

00:34:52.030 --> 00:34:55.580
take a very simple control, the text field.

00:34:55.579 --> 00:35:03.639
NSTextField and the way it draws, if you were to
look at it, NSTextField is simply an NS control

00:35:03.639 --> 00:35:11.029
that uses an NSTextField cell for all of its drawing.

00:35:11.030 --> 00:35:17.720
TextField is just a control that uses a
TextFieldCell for all of its drawings.

00:35:17.719 --> 00:35:21.259
But if you were to look at where
TextField and TextFieldCell are

00:35:21.260 --> 00:35:25.550
in the class inheritance hierarchy,
it would be worlds apart.

00:35:25.550 --> 00:35:30.890
Right? We'd start off at NSObject,
and below that we have NSResponder.

00:35:30.889 --> 00:35:38.239
Now NSResponder is our base class for everything in
Cocoa that responds to user events, things like Windows,

00:35:38.239 --> 00:35:47.359
actually Window Controller, the NS application
itself, and views, and from NSViews to send NSControl.

00:35:47.360 --> 00:35:55.030
NSControl is the base class for everything that
we're used to manipulating in our application UI.

00:35:55.030 --> 00:35:59.060
Things like, buttons, and sliders, and text fields.

00:35:59.059 --> 00:36:05.039
So this is where TextField lives
in the class inheritance hierarchy.

00:36:05.039 --> 00:36:05.989
That's two.

00:36:05.989 --> 00:36:12.529
But if you were to look for NSCell it's all the way
out here on its own, just directly from NSObject.

00:36:12.530 --> 00:36:19.519
It's a very lightweight class that's really just
interested in drawing and some user event handling support.

00:36:19.519 --> 00:36:24.570
And I said that TextField's use
TextFieldCells for their drawing.

00:36:24.570 --> 00:36:29.940
Well, every TextField has a very close
relationship with the TextFieldCell.

00:36:29.940 --> 00:36:34.710
And that's because every control has a NSCell.

00:36:34.710 --> 00:36:37.320
That's just the built in relationship.

00:36:37.320 --> 00:36:40.309
All controls have a cell.

00:36:40.309 --> 00:36:50.719
If we were to take a look at another control,
first remember now that NSControl is an NSView.

00:36:50.719 --> 00:36:56.159
And most controls implement their
drawRect method from NSView.

00:36:56.159 --> 00:37:03.589
We implement drawRect simply by forwarding
over to the control cell, telling the cell,

00:37:03.590 --> 00:37:08.059
draw in frame in view, draw with frame in view.

00:37:08.059 --> 00:37:13.210
And we pass the area of the control
that needs to be drawn using the cell,

00:37:13.210 --> 00:37:17.070
and pass the control itself as
the view that's being drawn into.

00:37:17.070 --> 00:37:19.650
And that's how the cell draws.

00:37:19.650 --> 00:37:23.950
So the cell doesn't have to worry
itself about its place in the window.

00:37:23.949 --> 00:37:26.219
It's the view that is placed in the window.

00:37:26.219 --> 00:37:31.079
It's the view that has the hierarchy of, of subviews.

00:37:31.079 --> 00:37:33.130
The cell is just about drawing.

00:37:33.130 --> 00:37:40.200
And if we took a look at another
control, NSButton, it's the same story.

00:37:40.199 --> 00:37:47.419
We have an NSButton control and an NSButton
cell, which is responsible for the drawing.

00:37:47.420 --> 00:37:55.119
And there wouldn't be much sense to this
separation if it was always a 1 to 1 mapping.

00:37:55.119 --> 00:37:56.250
And it's not the case.

00:37:56.250 --> 00:37:57.469
It's not always 1 to 1.

00:37:57.469 --> 00:38:01.509
We have other controls, like NSMatrix.

00:38:01.510 --> 00:38:09.220
So here NSButton using an NSButton cell to do its drawing,
and NSMatrix using button cells to draw its content.

00:38:09.219 --> 00:38:16.219
And remember it can, an NSMatrix can use an arbitrary
number of cells, and there's no one matrix cell,

00:38:16.219 --> 00:38:19.349
it's just whatever cell it's handed to draw.

00:38:19.349 --> 00:38:25.329
So it could be text, text field cells, button cells,
image cells, anything that's a cell the matrix can draw

00:38:25.329 --> 00:38:30.360
and stamp out the contents of each cell area very cheaply.

00:38:30.360 --> 00:38:35.930
So that's controls and cells, and their relationships.

00:38:35.929 --> 00:38:39.769
And if we step away from matrix for
a moment and look at another control

00:38:39.769 --> 00:38:44.739
that uses multiple cells we come back
to our old friend, NSOutlineView.

00:38:44.739 --> 00:38:53.329
So for NSOutlineView, which is a control, it implements
its drawRect, basically, by drawing its bordered area

00:38:53.329 --> 00:39:01.759
and its background, and then forwarding on for each
row of data that needs to be displayed to a data cell.

00:39:01.760 --> 00:39:07.410
In this case here we have just simple text field cells.

00:39:07.409 --> 00:39:14.210
So knowing that, we know that we can get the
rest of our work done showing those custom view,

00:39:14.210 --> 00:39:19.920
those custom rows with images, and
text, and photo count information.

00:39:19.920 --> 00:39:23.769
All that all in one row, by using the OutlineView delegate,

00:39:23.769 --> 00:39:29.440
OutlineView table cell for table
column, data cell for table column item.

00:39:29.440 --> 00:39:34.429
Using this delegate method to hand
back a custom cell that we'll interpose

00:39:34.429 --> 00:39:39.569
in this, in each row, to do the custom drawing.

00:39:39.570 --> 00:39:47.170
So just by using OutlineView Cell Delegation, we can
get a lot farther in, in implementing our designs.

00:39:47.170 --> 00:39:52.010
I'm going to show a quick demo
here of what we ended up with.

00:39:52.010 --> 00:40:02.950
[ silence ]

00:40:02.949 --> 00:40:10.009
>> Ron: So just for reference, here we have the original
mock up, the original prototype that Joar had shown off.

00:40:10.010 --> 00:40:17.880
[ silence ]

00:40:17.880 --> 00:40:22.760
>> Ron: And with a bit of work and some custom controls
this is where we end up, something that looks just

00:40:22.760 --> 00:40:27.660
like our user interface design pattern,
our, our user interface designs.

00:40:27.659 --> 00:40:34.029
We can select our projects, and they flip between
the photos that are on, in those projects.

00:40:34.030 --> 00:40:43.650
We have our canvas over here that we've gone ahead
and implemented, so we can add photos to them.

00:40:43.650 --> 00:40:45.559
Click around and drag.

00:40:45.559 --> 00:40:52.059
You'll notice that we also have our split view
set up so that we, we're using delegation here

00:40:52.059 --> 00:40:56.549
to prevent the source list from getting too small.

00:40:56.550 --> 00:40:59.990
We also have live previews in our source list.

00:40:59.989 --> 00:41:04.089
So using our custom cell drawing, we redraw the, the,

00:41:04.090 --> 00:41:08.010
the cell of the project that's been
updated, just by dragging around the photo.

00:41:08.010 --> 00:41:11.820
[ silence ]

00:41:11.820 --> 00:41:16.010
>> Ron: And we have our custom utility
bar with active little slider thing.

00:41:16.010 --> 00:41:21.040
[ silence ]

00:41:21.039 --> 00:41:26.329
>> Ron: So I don't have enough time, unfortunately,
to go into all of the details in the project itself,

00:41:26.329 --> 00:41:28.789
I just wanted to show you that with a little bit

00:41:28.789 --> 00:41:35.309
of code we can get pretty far using
custom controls to match our design.

00:41:35.309 --> 00:41:38.079
So we're most of the way through our little journey.

00:41:38.079 --> 00:41:47.739
We've touched on the basics of Cocoa drawing, and the
basic, the fundamentals of how to draw using Cocoa API's.

00:41:47.739 --> 00:41:52.459
Looked at an approach of how to
create custom controls that will fit

00:41:52.460 --> 00:41:55.280
with the design that we've been, that we've been using.

00:41:55.280 --> 00:42:04.920
Now I want to touch on adding custom behaviors
to our application to really bring it to life,

00:42:04.920 --> 00:42:08.010
including adding animation as feedback for our users.

00:42:08.010 --> 00:42:13.270
[ silence ]

00:42:13.269 --> 00:42:17.099
>> Ron: When I talk about behaviors
I'm really talking about responding

00:42:17.099 --> 00:42:21.960
to user events, responding to what the user is doing.

00:42:21.960 --> 00:42:27.599
And after talking about some of event-based API's, I
want to talk a little bit about supporting drag and drop,

00:42:27.599 --> 00:42:31.000
which I think is an important thing
for every Mac application.

00:42:31.000 --> 00:42:37.920
I don't know if you were able to see it during the demo.

00:42:37.920 --> 00:42:43.950
If you saw when I moved the mouse
over our individual photos,

00:42:43.949 --> 00:42:49.639
the icon for our cursor changes as
it enters and exits the photo area.

00:42:49.639 --> 00:42:54.369
The way that works is, we have
a view hierarchy in that canvas.

00:42:54.369 --> 00:42:57.710
And each photo has its own, is in its own view.

00:42:57.710 --> 00:43:06.740
And those views, the view class that we used to hold the
photos implements the methods, mouseEntered and mouseExited

00:43:06.739 --> 00:43:12.139
to adjust the, the, to show this
little info icon at the bottom right,

00:43:12.139 --> 00:43:18.239
as well as to switch the cursor
for the, the icon for the cursor.

00:43:19.550 --> 00:43:23.400
This is a good pair of methods to know about.

00:43:23.400 --> 00:43:31.970
It's really easy to add some event-based feedback for
the user just by keying off of these two callbacks,

00:43:31.969 --> 00:43:36.959
but you have to ask for these events
to be delivered to your view.

00:43:36.960 --> 00:43:42.369
And the way you ask for them is usually by
implementing update tracking areas in your views.

00:43:42.369 --> 00:43:50.599
Update tracking areas gets called whenever your
views, for example, when the view's bounds change.

00:43:50.599 --> 00:43:55.429
The area of the view is no longer the same as it was before.

00:43:55.429 --> 00:43:59.710
The area that's interesting for the
user is now smaller in this case.

00:43:59.710 --> 00:44:08.159
Or if the contents, for example, we, we
wanted to show this little info button.

00:44:08.159 --> 00:44:14.809
If the area that that info button is supposed to
show up in changes, we're given the opportunity

00:44:14.809 --> 00:44:19.219
to update where the interesting rectangles are.

00:44:19.219 --> 00:44:24.929
And the way we do that, inside of our
implementation of update tracking areas is just

00:44:24.929 --> 00:44:30.269
to remove the old tracking areas that
we were watching before, the old frames,

00:44:30.269 --> 00:44:32.929
and add new frames that we want to watch.

00:44:32.929 --> 00:44:38.119
And we can say which, which events we
want to hear about for those frames.

00:44:38.119 --> 00:44:45.359
So when we go to create new tracking areas
to add, using add, add up, add tracking area,

00:44:45.360 --> 00:44:52.329
we make sure to add this option during creating the
tracking area, NSTracking, mouseEntered and exited.

00:44:52.329 --> 00:44:58.069
By creating tracking areas with this option and
adding them, then our view will get the mouseEntered

00:44:58.070 --> 00:45:04.519
and mouseExited callbacks that we were talking about, so we
can add that custom behavior, like showing extra adornments

00:45:04.519 --> 00:45:06.009
to our view when the mouse enters or exits.

00:45:06.010 --> 00:45:10.820
[ silence ]

00:45:10.820 --> 00:45:14.610
>> Ron: There are a lot of other
events that the view can respond to.

00:45:14.610 --> 00:45:18.870
These are all callbacks that we inherit from NSResponder.

00:45:18.869 --> 00:45:25.420
Things like mouseDown, mouseUp, events that tell
us which of the mouse buttons was depressed,

00:45:25.420 --> 00:45:29.039
mouseDragged events during the click and drag of the mouse.

00:45:29.039 --> 00:45:34.009
I want to talk about two of these
specifically, mouseDown and mouseDragged.

00:45:34.010 --> 00:45:39.520
[ silence ]

00:45:39.519 --> 00:45:41.940
>> Ron: MouseDown events are pretty important.

00:45:41.940 --> 00:45:47.619
You can imagine that we implemented our
canvas with the individual photo views

00:45:47.619 --> 00:45:53.609
by implementing mouseDown inside of
our canvas or the photo views, right?

00:45:53.610 --> 00:45:57.099
Whenever the user clicks within a
photo view, we want to be able to,

00:45:57.099 --> 00:46:00.009
to show that information about the photo size underneath.

00:46:00.010 --> 00:46:05.700
[ silence ]

00:46:05.699 --> 00:46:08.189
>> Ron: And the same thing for the little info window.

00:46:08.190 --> 00:46:14.090
Hypothetically when the user clicks
just in that little info I badge,

00:46:14.090 --> 00:46:19.240
we want to be able to show some info about the photo.

00:46:19.239 --> 00:46:24.489
Now the mouseDown method gets past an event.

00:46:24.489 --> 00:46:25.559
And this is a user event.

00:46:25.559 --> 00:46:32.259
This is an NS event that represents what
happened, what the user did at that moment

00:46:32.260 --> 00:46:35.410
that melts down the path, got invoked on our view.

00:46:35.409 --> 00:46:40.210
And you can find out things like, was
it a mouse event, was it a key event.

00:46:40.210 --> 00:46:45.090
And for mouse events you can ask for where
was the mouse at the time the event happened?

00:46:45.090 --> 00:46:48.450
And you get the location of the mouse in the entire window.

00:46:49.949 --> 00:46:56.449
That's great, but usually you're interested in figuring
out where the mouse was in the view in the window.

00:46:56.449 --> 00:46:59.359
You want it in view, in the views coordinate space.

00:46:59.360 --> 00:47:04.660
And there's a simple way of getting that information
as well, taking the base location in the window

00:47:04.659 --> 00:47:09.079
and using the method convertPoint:fromView:inPathNil.

00:47:09.079 --> 00:47:15.860
And then you can convert the location from the window
into the views coordinate system and get an idea

00:47:15.860 --> 00:47:21.010
of where these are clicked, whether they clicked on the
little I badge or just on the, the general photo itself.

00:47:21.010 --> 00:47:25.950
[ silence ]

00:47:25.949 --> 00:47:31.509
>> Ron: Now this is a really common method to implement,
if for no other reason than to keep track of what was

00:47:31.510 --> 00:47:40.730
under the mouse at the time that the click happened, so that
then you can go and implement this method, mouseDragged.

00:47:40.730 --> 00:47:45.320
Pretty common thing is to start off
mouseDragged by looking at, well,

00:47:45.320 --> 00:47:49.420
what was under the mouse at the
time that mouseDown happened.

00:47:49.420 --> 00:47:53.320
This gives you a good clue of, in
our example, in our application,

00:47:53.320 --> 00:47:56.010
figuring out which photo the user is trying to drag.

00:47:56.010 --> 00:48:01.630
[ silence ]

00:48:01.630 --> 00:48:05.210
>> Ron: From there I want to talk
briefly about drag and drop.

00:48:05.210 --> 00:48:10.769
You saw that I could drag photos from the desktop
into our canvas to add them to our project.

00:48:10.769 --> 00:48:13.469
Don't be fooled though.

00:48:13.469 --> 00:48:17.569
Just because I was talking about mouseDragged
events, handling mouseDragged events,

00:48:17.570 --> 00:48:22.350
that doesn't mean that we've implemented drag and drop.

00:48:22.349 --> 00:48:26.920
Those mouse events are about the
location of the mouse within the window.

00:48:26.920 --> 00:48:30.970
Those, those are callbacks about the
mouse moving around within your view.

00:48:30.969 --> 00:48:38.149
Drag and drop is a data exchange
operation, from one view to another,

00:48:38.150 --> 00:48:42.460
or from a window to another view,
from another application to your view.

00:48:42.460 --> 00:48:47.179
It's data exchange in the same way that cut,
copy, and paste from another application

00:48:47.179 --> 00:48:50.869
to your app is a data exchange operation.

00:48:50.869 --> 00:48:58.199
In order to support that in our
application we simply use a pair of methods.

00:48:58.199 --> 00:49:02.239
Our canvas is registered as a drop target.

00:49:02.239 --> 00:49:07.769
We do this by calling registerForDraggedTypes in our canvas.

00:49:07.769 --> 00:49:16.150
It registers itself as accepting certain
data types for drag and drop operations.

00:49:16.150 --> 00:49:22.309
This sort of thing is usually called really early, like
in awake from Nib, or from init, inside of our canvas.

00:49:22.309 --> 00:49:30.610
Definitely before the user has any opportunity
to start dragging something into the view.

00:49:30.610 --> 00:49:37.720
Once the view is registered for these dragged types, there
will be some conversation between the view and the drag

00:49:37.719 --> 00:49:41.529
and drop machinery, asking is it
OK to drop this piece of data?

00:49:41.530 --> 00:49:43.850
Is it OK to put it here?

00:49:43.849 --> 00:49:52.799
There's a certain dialog that goes on, and it culminates
in asking our, our view to perform this drag operation.

00:49:52.800 --> 00:50:02.390
And that's really where the view is meant to pull the data
from the drag and drop machinery and add it to the view.

00:50:02.389 --> 00:50:09.829
PerformDragOperation, passes a dragging info object
that has info like, what was the source of this drag?

00:50:09.829 --> 00:50:12.179
Where was this coming from?

00:50:12.179 --> 00:50:16.449
Information like where was the mouse at
the time that the drag operation concluded?

00:50:16.449 --> 00:50:26.399
And the draggingPasteboard, which will be where the data for
the drag and drop operation current, was put by the source.

00:50:26.400 --> 00:50:33.039
Again, this is like cut, copy, and paste, where the
contents of cut or copy gets put onto a pasteboard.

00:50:33.039 --> 00:50:37.009
And now our receiving view is able to
pull that data off of the pasteboard.

00:50:37.010 --> 00:50:41.730
[ silence ]

00:50:41.730 --> 00:50:49.780
>> Ron: So those are a few important topics, event handling
in general, and supporting drag and drop as a, as a concept.

00:50:49.780 --> 00:50:54.420
I want to talk now about adding
animations for our application.

00:50:54.420 --> 00:50:59.420
And for an application like this,
especially something that handles photos,

00:50:59.420 --> 00:51:03.490
well you can see here it'd be pretty easy to, as a user,

00:51:03.489 --> 00:51:08.000
drag in a ton of photos and then
end up with just a big jumble.

00:51:08.000 --> 00:51:11.190
It'd be nice if we could clean this up for the user.

00:51:11.190 --> 00:51:18.289
So we could do that by taking all the views
and moving them into some cleaned up place.

00:51:18.289 --> 00:51:24.639
That would work, but it would be nice if we could
do this with a nice transition, a nice animation,

00:51:24.639 --> 00:51:28.960
to give the user some context, so
that they know what's going on.

00:51:28.960 --> 00:51:31.670
They can see what's happening better.

00:51:31.670 --> 00:51:37.740
Animation is just a great way of giving
the user the feeling that you care.

00:51:37.739 --> 00:51:44.939
Now before I talk about exactly how we go ahead
and implement animations in our application,

00:51:44.940 --> 00:51:50.329
I want to cover one thing, how we draw with views normally.

00:51:50.329 --> 00:51:56.329
When I say normally I'm talking about all of the, the
drawing topics that we've covered so far in the talk.

00:51:56.329 --> 00:51:59.319
This is the way that views draw.

00:51:59.320 --> 00:52:04.250
They have one shared buffer that's
owned by the window that they're in.

00:52:04.250 --> 00:52:09.010
And all of the views live in a stack;
they're ordered in Z-order close,

00:52:09.010 --> 00:52:14.740
the closer to the user, the higher the, the Z-order number.

00:52:14.739 --> 00:52:17.969
And the bottommost views draw first.

00:52:17.969 --> 00:52:22.699
And they just draw one after another, drawing on
top of each other into the same shared buffer.

00:52:22.699 --> 00:52:24.009
So they overwrite each other's pixels.

00:52:24.010 --> 00:52:29.030
[ silence ]

00:52:29.030 --> 00:52:34.610
>> Ron: This is bad, because, well, if you were
to reorder any of these views you have to go

00:52:34.610 --> 00:52:41.740
and redraw the overlapping areas so that
you get the new overlapping contents.

00:52:41.739 --> 00:52:43.119
Order matters in the drawing.

00:52:43.119 --> 00:52:46.539
So reordering means you have to
redraw the overlapping areas.

00:52:46.539 --> 00:52:51.329
And the same is true if you were to
change the contents of any of these views.

00:52:51.329 --> 00:52:55.059
You'd have to go back and redraw
the overlapping area for that view.

00:52:55.059 --> 00:53:00.960
Now remember that views can be in a view hierarchy.

00:53:00.960 --> 00:53:02.760
They can have a list of subviews.

00:53:02.760 --> 00:53:08.630
And the drawRect method for any of those views could have
an arbitrary, have arbitrary performance characteristics.

00:53:08.630 --> 00:53:11.360
We don't know how long every view takes to draw.

00:53:11.360 --> 00:53:13.610
Ideally, they all draw very quickly.

00:53:13.610 --> 00:53:18.500
But even at that it's expensive to have
to redraw all of the overlapping areas,

00:53:18.500 --> 00:53:25.539
all of the overlapping views here every time one
were to change its content or position or ordering.

00:53:27.170 --> 00:53:34.780
Well with Mac OS X Leopard, with 10.5, we
got a technology called Core Animation,

00:53:34.780 --> 00:53:38.560
which allowed us to add layer backed views.

00:53:38.559 --> 00:53:48.699
Layer backed views are just NS views that have
had their set once layer properties set to yes.

00:53:48.699 --> 00:53:51.519
That's all a layer backed view is.

00:53:51.519 --> 00:54:00.750
Core Animation and Cocoa has been able to add layer
backed views, NS views that have set one layer set to yes.

00:54:00.750 --> 00:54:07.739
The difference this makes is, instead of
drawing into one shared window buffer now,

00:54:07.739 --> 00:54:13.759
all of our views get their own little layer
backed view, layer backed buffer to draw into.

00:54:13.760 --> 00:54:22.600
This is powerful, because once a view has drawn
into their layer backed buffer storage area,

00:54:22.599 --> 00:54:25.849
if their contents don't change,
then they don't need to redraw.

00:54:25.849 --> 00:54:28.369
Draw once and that's it.

00:54:28.369 --> 00:54:31.529
This is great for static images, static content.

00:54:31.530 --> 00:54:36.420
You just draw once into this buffer,
and all of the positioning and layering

00:54:36.420 --> 00:54:39.010
that happens later is performed by the very fast GPU.

00:54:39.010 --> 00:54:44.070
[ silence ]

00:54:44.070 --> 00:54:48.500
>> Ron: Again, this is all made
possible with Core Animation.

00:54:48.500 --> 00:54:56.550
Along with Core Animation we got a few classes, CA
Layer, which is the layer in layer backed views.

00:54:56.550 --> 00:55:03.050
And Core Animation, CA Animations,
these are objects that represent the,

00:55:03.050 --> 00:55:07.840
the animations that we want to use in our applications.

00:55:07.840 --> 00:55:13.240
They're, they're containers for
specifications of how to animate our views.

00:55:13.239 --> 00:55:23.129
And something that's subtle, but is still good to know
about, is the protocol, NS Animateable Property Container.

00:55:23.130 --> 00:55:31.740
This is a protocol for all objects that have an animator
proxy, and NSView happens to be one of those objects.

00:55:31.739 --> 00:55:40.679
So what we can do with a layer backed view, instead of
telling a view to move by setting its frame, frame origin,

00:55:40.679 --> 00:55:49.230
or to resize by setting its frame bounds, its bounds,
we can tell the view animator to do the same thing.

00:55:49.230 --> 00:55:55.780
We access the view animator as, as we
have here just by doing view animator,

00:55:55.780 --> 00:55:58.370
and pretend that the animator is the view itself.

00:55:58.369 --> 00:56:06.199
For all intents and purposes, as far as resizing,
rotating, repositioning, setting the opacity,

00:56:06.199 --> 00:56:11.839
we can treat the view animator as if it's the view itself.

00:56:11.840 --> 00:56:18.300
This is great, because all of our NSViews, all of our
NSControls, our custom controls, our basic Cocoa controls,

00:56:18.300 --> 00:56:21.820
everything that's in NSView has an animator.

00:56:21.820 --> 00:56:26.980
So now repositioning them, fading
them in and out, resizing them,

00:56:26.980 --> 00:56:32.150
we can animate all those properties
just by messaging the view animator.

00:56:32.150 --> 00:56:38.970
And we can put them together, changing the
frame, changing the opacity at the same time.

00:56:38.969 --> 00:56:42.279
And it's really hard to talk about this sort of stuff.

00:56:42.280 --> 00:56:45.370
I'd like to jump to the demo.

00:56:45.369 --> 00:56:50.049
Let's see, go close the older model of this app.

00:56:50.050 --> 00:56:54.750
Here's, again, this is the same
version that I demoed just a bit ago.

00:56:54.750 --> 00:57:02.000
I wanted to show one thing, so if you didn't
notice the little I before, there it is.

00:57:02.000 --> 00:57:09.579
If we were to get info for the object, for
this photo, we have this nice flip animation.

00:57:09.579 --> 00:57:17.150
The cool done button that Joar had
drawn earlier, we have those as well.

00:57:17.150 --> 00:57:28.450
So one thing we've also added the clean up
action, so we can get this nice motion effect.

00:57:28.449 --> 00:57:35.319
All we did is calculate where we wanted to
move the photos to, and instead of doing view,

00:57:35.320 --> 00:57:39.690
set frame, we do view animator set frame.

00:57:39.690 --> 00:57:43.880
And they animate there to their locations and sizes.

00:57:43.880 --> 00:57:55.250
One thing you might notice if we were to
switch between projects, you guys see that?

00:57:55.250 --> 00:57:57.579
There's a subtle transition.

00:57:57.579 --> 00:58:06.710
They don't just pop in and out, there's a very subtle
like short fade in and out when we switched projects.

00:58:06.710 --> 00:58:10.269
Now that's, that's an animation
that's happening for us automatically.

00:58:10.269 --> 00:58:14.820
We, the timing for it is automatic; we don't
have to set any parameters or anything.

00:58:14.820 --> 00:58:21.280
We get this subtle animation for free just by
telling a view animator remove from superview,

00:58:21.280 --> 00:58:26.260
and then adding new views by doing
view animator, add subview.

00:58:26.260 --> 00:58:31.400
We, we don't have to change anything else in
our code to get this nice subtle animation.

00:58:31.400 --> 00:58:35.010
I do want to add one thing though, I...

00:58:35.010 --> 00:58:39.840
[ silence ]

00:58:39.840 --> 00:58:41.010
>> Ron: If we go back to our project.

00:58:41.010 --> 00:58:48.310
[ silence ]

00:58:48.309 --> 00:58:55.329
>> Ron: So here's the method that currently switches between
the old photos and the new photos when we switch projects.

00:58:55.329 --> 00:58:58.989
We're told to switch to showing these photo items.

00:58:58.989 --> 00:59:06.279
Right now all it does is this, and it's a basic swap
out the old ones, pop in the new views, that's it.

00:59:06.280 --> 00:59:14.950
I'm going to delete this right now, and swap
in this implementation I have precanned.

00:59:14.949 --> 00:59:21.879
To walk you through it this is the, a CA Animation.

00:59:21.880 --> 00:59:27.240
This is a subclass of CA Animation, CA Basic Animation.

00:59:27.239 --> 00:59:34.489
What it defines is a property; it's associated
with a property of an object that's changing.

00:59:34.489 --> 00:59:38.589
So in our case the frame origin or its frame size.

00:59:38.590 --> 00:59:43.910
And we can set the duration that we
want for the animation if we don't,

00:59:43.909 --> 00:59:48.589
don't want to use the default animation settings.

00:59:48.590 --> 00:59:55.309
We can adjust the timing function, there are a couple of
prebuilt ones, ease in, ease out, linear, ease in and out.

00:59:55.309 --> 01:00:01.409
We can even substitute our own
fancy one with more stop points.

01:00:01.409 --> 01:00:05.199
And we can set ourselves as the delegates of an animation.

01:00:05.199 --> 01:00:10.980
So that when the animation is done
we can go back and do some clean up.

01:00:10.980 --> 01:00:19.490
Now we do some work here figuring out where the old views
are, and we do, we make a little, we do a little trick here

01:00:19.489 --> 01:00:26.369
where we add an overlay view where the photos are
currently, and pop those photos into the overlay.

01:00:26.369 --> 01:00:28.759
And that's invisible.

01:00:28.760 --> 01:00:32.660
So we have an old overlay for all the old photos.

01:00:32.659 --> 01:00:37.839
And we create a new overlay for all the new
photos, and position that overlay off screen.

01:00:37.840 --> 01:00:44.829
So now we have two views holding a bunch of photos, one
view for the old photos and one view for the new photos.

01:00:44.829 --> 01:00:53.019
With this simple trick after setting
up the overlays we can go ahead

01:00:53.019 --> 01:00:56.500
and set the animation for both overlays to be the same.

01:00:56.500 --> 01:01:03.030
And the animation is simply a transition
moving downwards or upwards.

01:01:03.030 --> 01:01:05.970
It's a frame move.

01:01:05.969 --> 01:01:13.219
And when we, when we change the frame for both of the
overlays we make sure to message the overlays animator.

01:01:13.219 --> 01:01:15.659
And that's the only difference.

01:01:15.659 --> 01:01:21.179
Instead of setting the frame on the overlay
themselves we, we change the frame for the animator.

01:01:21.179 --> 01:01:30.559
And what our delegate callback gets is
the animation itself that just finished.

01:01:30.559 --> 01:01:38.019
So when the animation is done our delegate, which is our
cells in this case, will be told that the animation is done.

01:01:38.019 --> 01:01:41.389
And we can pick information out of the animation itself.

01:01:41.389 --> 01:01:47.259
We can, we can use it as a generic key value
coding bucket, so we can put information into it

01:01:47.260 --> 01:01:50.070
at the time that we create the animation.

01:01:50.070 --> 01:01:56.110
So that when the animation is done our delegate callback
knows, ah, these are the two overlay views that I have

01:01:56.110 --> 01:02:04.400
to fix up, and throw away the old one, and pop the new
photo item out of the new overlay and into the canvas.

01:02:04.400 --> 01:02:08.619
It's a pretty simple pattern.

01:02:08.619 --> 01:02:14.739
And it's just easier to show you
what, what you get from this.

01:02:14.739 --> 01:02:23.729
So for those maybe like 20 lines of code we get
this nice up and down transition that gives you the,

01:02:23.730 --> 01:02:27.670
the impression that you're on an infinite canvas.

01:02:27.670 --> 01:02:31.480
Right? Still adding photos, we still get our live previews.

01:02:31.480 --> 01:02:40.240
And, actually one neat thing we can do, if
I hold down the Shift key we can slip these

01:02:40.239 --> 01:02:46.149
and we can still switch as it's animating.

01:02:46.150 --> 01:02:48.980
It's actually kind of fun to do.

01:02:48.980 --> 01:02:51.360
I forgot to hold down the Shift key.

01:02:51.360 --> 01:03:00.970
So just an example of some of the things that you
can do with CA Animation and Layer Backed Views.

01:03:00.969 --> 01:03:10.609
Oh, one other thing I forgot to mention, now with Layer
Backed Views, the whole point of not having to draw

01:03:10.610 --> 01:03:14.630
into that, that buffer every time some content changes

01:03:14.630 --> 01:03:20.269
or the position changes, that means
that we can draw really fast.

01:03:20.269 --> 01:03:24.769
When we don't have to redraw all of the
overlapping views, we can draw really fast.

01:03:24.769 --> 01:03:28.630
That's one of the great advantages of
Core Animation and Layer Backed Views.

01:03:28.630 --> 01:03:36.710
And to, to show you that I have a simple application
that has two image views overlapping each other,

01:03:36.710 --> 01:03:42.230
one that's a big tic tac toe board, and one
that's a simple tic tac toe little piece.

01:03:42.230 --> 01:03:49.300
And all I do is I move the frame of
the tic tac toe piece up and down.

01:03:49.300 --> 01:03:57.310
Now you can still message the animator of these views
without turning on layer backing for those views.

01:03:57.309 --> 01:04:06.750
It's important to note, you don't have to have the
views set to wants layer yes, but it certainly helps.

01:04:06.750 --> 01:04:09.050
I'll show you why.

01:04:09.050 --> 01:04:17.950
So if we, you'll notice that there's this yellow
flashing whenever I kind of switch between apps here.

01:04:17.949 --> 01:04:30.409
Well that's because in our project I've turned on this
argument, added this argument, NS show all drawing, yes.

01:04:30.409 --> 01:04:31.480
Feel free to write this one down.

01:04:31.480 --> 01:04:35.469
This is a great debugging tool when you're
implementing custom drawings to make sure

01:04:35.469 --> 01:04:40.909
that you're not being called to
draw your views contents too often.

01:04:40.909 --> 01:04:46.289
This is great even if you're not implementing your own
custom controls, just using some standard controls,

01:04:46.289 --> 01:04:49.860
making sure you're not dirtying areas of the view too often.

01:04:49.860 --> 01:04:56.059
So with that on we see this flashing
every time our views have to redraw.

01:04:56.059 --> 01:05:02.920
Now I'm going to go ahead and hit the go button,
and you'll see the animation of our piece.

01:05:02.920 --> 01:05:08.670
So that's a lot of drawing just for
moving the view 120 pixels, right?

01:05:08.670 --> 01:05:14.280
Now if we turn on wants layer for all of these,
we turned it on for our background image,

01:05:14.280 --> 01:05:17.850
as well as the foreground image view with the X piece in it.

01:05:17.849 --> 01:05:21.579
We hit reverse; it's a big difference.

01:05:21.579 --> 01:05:25.000
This is what a layer backed view
is supposed to, performed like.

01:05:25.000 --> 01:05:31.429
So this is a reason for you to consider using layer
backed views in your custom controls in your applications.

01:05:31.429 --> 01:05:35.789
With that, let's go back to slides really briefly.

01:05:35.789 --> 01:05:41.289
For more information please contact
Developer Tools Evangelist Michael Jurewitz.

01:05:41.289 --> 01:05:42.750
Hey Michael!

01:05:42.750 --> 01:05:46.510
Lots of documentation for all the
stuff we've touched on so far

01:05:46.510 --> 01:05:50.860
for the Cocoa drawing, the basics
of drawing with Cocoa API's.

01:05:50.860 --> 01:05:54.289
The View Programming Guide is a great source of information.

01:05:54.289 --> 01:05:57.699
The Human Interface Guidelines,
which we talked about earlier.
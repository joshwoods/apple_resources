WEBVTT

00:00:12.550 --> 00:00:13.440
>> My name is Chris Parker.

00:00:13.439 --> 00:00:19.429
I work on the iPhone Frameworks Team; and today I'm going to
be spending about the next hour telling you about everything

00:00:19.429 --> 00:00:23.530
that we've put into UIKit and some other
frameworks to help you guys write better Apps.

00:00:23.530 --> 00:00:26.929
So it's a lot of API.

00:00:26.929 --> 00:00:36.240
Starting out just on UIApplication canOpenURL is a
companion API to OpenURL and this just checks to see whether

00:00:36.240 --> 00:00:41.690
or not the URL that you're passing us-- remember
when you're installing a bunch of applications

00:00:41.689 --> 00:00:44.489
on the device you can register for different URL schemes.

00:00:44.490 --> 00:00:52.160
This tells you whether or not an application has registered
for the scheme for that URL so this will allow you

00:00:52.159 --> 00:00:58.309
to be able to control the UI for when
you're launching other applications via URL.

00:00:58.310 --> 00:01:01.630
There are some new delegate methods on UIApplication.

00:01:01.630 --> 00:01:07.420
Application didFinishLaunchingWithOptions
is the new delegate method for finding

00:01:07.420 --> 00:01:09.650
out when you got launched and how you got launched.

00:01:09.650 --> 00:01:13.940
So this dictionary will contain a
number of different key value pairs.

00:01:13.939 --> 00:01:16.700
One of them will be LaunchOptionsRemoteNotification

00:01:16.700 --> 00:01:23.400
if you were launched via the PushNotification
service which is now in iPhone OS 3.0.

00:01:23.400 --> 00:01:26.620
You'll get a small dictionary as the value of this--

00:01:26.620 --> 00:01:31.480
it contains information about the
RemoteNotification that launched you.

00:01:31.480 --> 00:01:36.020
And LaunchOptionsURLKey and
LaunchOptionsSourceApplicationKey-- these indicate--

00:01:36.019 --> 00:01:42.799
you've got launched via OpenURL and the URL
will be the value of URLKey and the Bundle ID

00:01:42.799 --> 00:01:47.039
of the launching application will be the
SourceApplicationKey; so now you can find out a little bit

00:01:47.040 --> 00:01:49.840
about how you got launched and who launched you.

00:01:49.840 --> 00:01:56.500
And if you got launched via the new Spotlight screen on
the home screen, this will contain a URL for that also;

00:01:56.500 --> 00:02:00.409
so we've actually seen a couple of Apps that get a little
flummoxed by this, so you may want to check and make sure

00:02:00.409 --> 00:02:05.149
that your App is working correctly in the
face of getting launched via Spotlight.

00:02:05.150 --> 00:02:10.250
So the Push notification API-- I'm sure
everybody is psyched to see this appear

00:02:10.250 --> 00:02:17.960
in iPhone OS 3.0 via the basic API involves registering
for RemoteNotificationTypes and you can unregister

00:02:17.960 --> 00:02:22.020
for RemoteNotifications and you can also find
out which ones you've actually registered for.

00:02:22.020 --> 00:02:29.219
And the types are Badge, Sound and Alert, and these
methods control what you've registered for, right?

00:02:29.219 --> 00:02:33.359
So you might register your App for Badge,
Sound and Alert but the user may have set it

00:02:33.360 --> 00:02:36.270
so that they're never going to receive a SoundNotification.

00:02:36.270 --> 00:02:40.010
So you'll register for certain kinds of
alerts and the user will control exactly

00:02:40.009 --> 00:02:43.649
which ones they're going to allow to interrupt them.

00:02:43.650 --> 00:02:48.789
Associated with this, the Push notification
delegate methods tell you whether

00:02:48.789 --> 00:02:51.780
or not the notifications were you
actually successfully registered

00:02:51.780 --> 00:02:55.629
for those notifications, and whether
or not you received one.

00:02:55.629 --> 00:03:00.150
So didRegisterForRemoteNotificationsWithDeviceToken
this gives you a little cookie that tells you

00:03:00.150 --> 00:03:03.439
that you actually checked in with
the RemoteNotificationServer.

00:03:03.439 --> 00:03:07.750
DidFailtoRegister, this one tells
you whether something went wrong.

00:03:07.750 --> 00:03:13.689
And that NSError should contain an entire set of
localized recovery suggestions and things like that

00:03:13.689 --> 00:03:19.240
that will give you an error dialogue
suitable for presentation to the user.

00:03:19.240 --> 00:03:24.080
And didReceiveRemoteNotification, if you're
already running and you get a RemoteNotification

00:03:24.080 --> 00:03:27.610
from the Push notification service, we don't
want to have to go through the whole UI

00:03:27.610 --> 00:03:33.290
so this actually gives you an opportunity to look at that
dictionary and handle that RemoteNotification yourself.

00:03:33.289 --> 00:03:38.109
Chris Marcellino and one of the
engineers from the service side of this are going

00:03:38.110 --> 00:03:44.350
to be giving the Apple Push notification service
talk Thursday at 5 p.m. I think that's right here

00:03:44.349 --> 00:03:47.139
in Pacific Heights so you don't
have to stay here the whole time.

00:03:47.139 --> 00:03:50.879
You can go and see other talks and come back
for that one; but they'll be here talking

00:03:50.879 --> 00:03:58.139
about the Push notification service
so you can get more information there.

00:03:58.139 --> 00:04:00.959
Tuesday, well you can stay here all day if you want then.

00:04:00.960 --> 00:04:02.260
Knock yourself out.

00:04:02.259 --> 00:04:08.359
Proximity monitoring-- we now have public API for
getting it to Proximity sensor that's in the Device right

00:04:08.360 --> 00:04:13.100
so when you move the Device up to your ear and the screen
goes out, that's controlled by the proximityMonitor.

00:04:13.099 --> 00:04:19.219
There's a non-autonomic property here for is
proximityMonitoringEnabled, so that allows you to find

00:04:19.220 --> 00:04:23.230
out whether or not it's enabled and to
turn it on and off, and the proximityState.

00:04:23.230 --> 00:04:25.110
So if you get back a yes from this it means

00:04:25.110 --> 00:04:28.080
that the proximity sensor is telling you
that something's close to the device.

00:04:28.079 --> 00:04:35.870
You can also register with the local notification
center for the ProximityStateDidChangeNotification;

00:04:35.870 --> 00:04:42.639
this tells you as the State changes so you can
go back and check that ProximityState value

00:04:42.639 --> 00:04:46.649
to find out the value after the notification.

00:04:46.649 --> 00:04:50.719
Also we have battery monitoring on the
UIDevice now so you'll be able to find

00:04:50.720 --> 00:04:53.220
out exactly what the state of the battery is.

00:04:53.220 --> 00:04:57.660
There are a couple of different uses for this-- one
might be to present UI that matches your UI in your game

00:04:57.660 --> 00:05:01.510
if you're doing something specific, but
also just finding out what the state is.

00:05:01.509 --> 00:05:06.480
So there two properties associated with
this-- the batteryState and the batteryLevel.

00:05:06.480 --> 00:05:08.180
And the States are these things here.

00:05:08.180 --> 00:05:10.139
Whether it's unknown, so we might not be able to tell you

00:05:10.139 --> 00:05:14.259
at all times exactly what the State
is, Unplugged, Charging and Full.

00:05:14.259 --> 00:05:19.069
If the user has unplugged it, you're probably
drawing power, you're on battery power at that point.

00:05:19.069 --> 00:05:23.629
Whether it's charging, it's plugged in and actually
pulling power into the battery and when it goes full.

00:05:23.629 --> 00:05:28.490
And you'll also be able to just query that batteryLevel
property which is a unit so it goes from zero to one

00:05:28.490 --> 00:05:32.180
as a float, and that will tell you
what percentage the battery is.

00:05:32.180 --> 00:05:36.709
There are also notifications for both of these so
if you register with the local notification center,

00:05:36.709 --> 00:05:44.889
you can find out when the batteryState changed,
so as the user plugs and unplugs the cable,

00:05:44.889 --> 00:05:48.019
when the batteryState changed and
the Level; so as the Level decreases

00:05:48.019 --> 00:05:51.439
or increases while it's charging you'll
get notifications for those as well.

00:05:51.439 --> 00:06:00.040
And at that time you can go back
and check those other properties.

00:06:00.040 --> 00:06:04.439
UIImageView gets a couple of new
methods now and with highlightedImage.

00:06:04.439 --> 00:06:10.759
So highlightedImage is the Image that gets displayed when
the UIImageView has a highlight, and this just lets you set

00:06:10.759 --> 00:06:13.389
up both the Image and the highlightedImage at the same time.

00:06:13.389 --> 00:06:16.750
You have a property for getting at the
highlightedImage and a property for finding out whether

00:06:16.750 --> 00:06:19.800
or not the UIImageView is in the highlighted state.

00:06:19.800 --> 00:06:24.060
This third one here, highlightedAnimationImages
is kind of new.

00:06:24.060 --> 00:06:27.610
When the UIImageView is highlighted,
you can actually provide an NSArray

00:06:27.610 --> 00:06:31.170
of UIImages to use for your highlighted animation.

00:06:31.170 --> 00:06:35.740
So if you want to have a whole series of things
playing while the UIImageView is highlighted,

00:06:35.740 --> 00:06:39.240
you can use this thing and it will
play the images in sequence.

00:06:39.240 --> 00:06:41.569
There are some recommendations about using this.

00:06:41.569 --> 00:06:48.920
It's recommended that your UIImages are all the same size
and have roughly the same color balance and stuff like that.

00:06:48.920 --> 00:06:52.180
The key thing here is that the content mode
will govern how this stuff gets scaled.

00:06:52.180 --> 00:06:56.620
So if they're not the same size, some images will
be scaled up or down to fit in the UIImageView.

00:06:56.620 --> 00:07:01.300
If you set this property, it overrides
the highlightedImage property.

00:07:01.300 --> 00:07:04.389
So it's one or the other; you're either
using the single highlightedImage

00:07:04.389 --> 00:07:08.819
or you're using an entire NSArray of highlightedImages.

00:07:09.920 --> 00:07:14.129
So UINavController-- we have a bunch of
new methods on UINavController and this is

00:07:14.129 --> 00:07:17.939
to help give some better UI as
well as to do some bulk operations.

00:07:17.939 --> 00:07:24.949
So setViewControllers animated is a way to be able to set a
whole series of ViewControllers-- a whole stack at one time.

00:07:24.949 --> 00:07:31.699
And the animated property tells us whether or not to
animate the top one in that stack up over in the place.

00:07:31.699 --> 00:07:35.979
And we've also given some control over the
toolbar, so you'll be able to find out whether

00:07:35.980 --> 00:07:43.270
or not the toolbar is hidden and set the toolbar in place in
an animated fashion or not; and the toolbar property itself,

00:07:43.269 --> 00:07:47.409
you'll be able to get at the toolbar
directly given UINavigation Controller.

00:07:47.410 --> 00:07:53.160
And you'll be able to access those toolbarItems and the
Controller that they come in in an animated fashion.

00:07:54.819 --> 00:08:00.339
And we've also built into UIResponder
the Motion detection API's.

00:08:00.339 --> 00:08:05.379
So the methods that you'll get as a Responder, so remember
you're in the Responder chain you're going to be able

00:08:05.379 --> 00:08:09.089
to trap a whole bunch of different events that
happened on the way up the Responder chain.

00:08:09.089 --> 00:08:13.179
motionBegan withEvent; motionEnded
withEvent and motionCancelled withEvent.

00:08:13.180 --> 00:08:18.680
And those are just the indications about the user
doing something with a motion that we recognize.

00:08:18.680 --> 00:08:24.430
Right now we recognize pretty much one motion, a
ShakeMotion, so you're going to be able to pull a type

00:08:24.430 --> 00:08:28.000
and a subtype out of a UIEvent; and
these are new methods in iPhone OS 3.0.

00:08:28.000 --> 00:08:31.519
And they're just going to allow a little bit more
control over what kinds of things are happening,

00:08:31.519 --> 00:08:35.240
so as we increase the number of motions that we recognize,

00:08:35.240 --> 00:08:37.799
you'll be able to find out more
about it here in the future as well.

00:08:37.799 --> 00:08:44.169
There are two different types-- Touches or
Motion, so obviously the type for the events

00:08:44.169 --> 00:08:48.399
that you've been getting recently
are all UIEvent TypeTouches.

00:08:48.399 --> 00:08:54.279
UIEvent TypeMotion is for the motion events;
and the subtype is where you're going

00:08:54.279 --> 00:08:55.949
to find out exactly what kind of motion it was.

00:08:55.950 --> 00:08:59.080
And right now again the only one
that we support is the ShakeMotion.

00:08:59.080 --> 00:09:09.139
So we also now have cut, copy, and paste and these also
are on UIResponder; so as you implement the cut, copy,

00:09:09.139 --> 00:09:15.309
and paste methods and select and selectAll on your
classes that are participating in the Responder chain,

00:09:15.309 --> 00:09:23.159
that's part of how we determine what UI to show the user
when they actually go for the cut, copy, and paste UI.

00:09:23.159 --> 00:09:27.679
And on UIApplication related to this we also have
applicationSupportsShakeToEdit which is going

00:09:27.679 --> 00:09:34.449
to tell us whether or not to trigger the undo
motion and things like that on shaking the device.

00:09:34.450 --> 00:09:42.340
Also canPerformAction withSender-- this is your opportunity
to do some additional customization so even if objects

00:09:42.340 --> 00:09:46.790
in your responder chain respond to cut, copy,
and paste, but there's some reason that some

00:09:46.789 --> 00:09:51.089
of those actions aren't appropriate, you
can implement canPerformAction withSender.

00:09:51.090 --> 00:09:55.590
The action here will be one of those selectors,
either cut or copy, paste, select, selectAll.

00:09:55.590 --> 00:10:02.410
And if you return no from here, that's your opportunity
to say well, we do normally, but not right now.

00:10:02.409 --> 00:10:08.319
And then the action will be removed from the
menu when the menu actually gets displayed.

00:10:08.320 --> 00:10:11.820
And also on UIResponder is a new NSUndoManager.

00:10:11.820 --> 00:10:17.270
So if you've been using NSUndoManager on the
desktop, this is NSUndoManager on the iPhone.

00:10:17.269 --> 00:10:18.889
It's the same class.

00:10:18.889 --> 00:10:20.340
It actually works the same way.

00:10:20.340 --> 00:10:27.080
If you haven't, it basically allows you to provide
a stack of invocations that you can either play back

00:10:27.080 --> 00:10:31.070
or rewind depending on what actions
the user is taking to do undos.

00:10:31.070 --> 00:10:39.500
So if you were to, for instance, do an insert Event, when
the user does the insert, you might register the undo action

00:10:39.500 --> 00:10:43.730
as being a delete for that range of text for instance.

00:10:43.730 --> 00:10:47.879
There's some ways you can group things with an
undoManager, so you can begin and endUndoGrouping,

00:10:47.879 --> 00:10:53.039
you can find out what groupingLevel you're in,
and the undo stack is managed by these groups.

00:10:53.039 --> 00:11:02.209
And when the user does an undo, you can tell the UndoManager
to actually trigger that undo and it will rewind everything

00:11:02.210 --> 00:11:04.920
to the undoGroup, to the current undoGroup.

00:11:04.919 --> 00:11:06.370
Undo and redo work the same way.

00:11:06.370 --> 00:11:09.340
There's also some control for groupsbyEvent.

00:11:09.340 --> 00:11:14.450
So you get a UIEvent in, you're
actually going to handle that UIEvent.

00:11:14.450 --> 00:11:17.180
Any of the undo actions that you register during

00:11:17.179 --> 00:11:21.179
that UIEvent are automatically
grouped into a single undoGrouping.

00:11:21.179 --> 00:11:26.120
And these methods allow you to be able to
control whether or not that behavior is in force.

00:11:26.120 --> 00:11:30.500
So this is the default, groupsByEvent is yes by default.

00:11:30.500 --> 00:11:34.080
If for some reason you need finer
grained control over the undo works,

00:11:34.080 --> 00:11:40.250
you can use setGroupsByEvent no and
that gets you out of that mechanism.

00:11:40.250 --> 00:11:46.809
So you can't do any of this stuff without a
Pasteboard so we do have a UIPasteboard class.

00:11:46.809 --> 00:11:49.769
And there are a few methods on that--
this is just a smattering of them;

00:11:49.769 --> 00:11:53.850
but the big hitters are generalPasteboard
so this gets the general cut, copy, paste,

00:11:53.850 --> 00:11:56.970
Pasteboard right from the UIPasteboard class.

00:11:56.970 --> 00:12:02.050
And this is the one that you're going to probably use
the most; PasteboardWithName create allows you to set

00:12:02.049 --> 00:12:03.919
up your own Pasteboards with your own name.

00:12:03.919 --> 00:12:10.199
If you pass no to create and it's not there, you'll get
back nil; if it is there you'll get back the Pasteboard.

00:12:10.200 --> 00:12:14.250
And PasteboardWithUniqueName gives you an
opportunity to be able to get Pasteboards

00:12:14.250 --> 00:12:17.730
that will not collide with other Pasteboards on the system.

00:12:17.730 --> 00:12:20.889
So we're assuming that there are going to be
a lot of Apps taking advantage of cut, copy,

00:12:20.889 --> 00:12:27.350
paste whether it's implicitly-- just by using our controls
or whether it's having a custom Pasteboard to do some

00:12:27.350 --> 00:12:32.220
of their own behaviors with Pasteboards so this
is a good way to be able to get a Pasteboard

00:12:32.220 --> 00:12:34.670
that isn't going to collide with anybody else.

00:12:34.669 --> 00:12:39.750
If you register with the Default Notification
Center, you can find out Notifications

00:12:39.750 --> 00:12:46.740
about when the UIPasteboard changes, and those will
include things like types were added to the Pasteboard

00:12:46.740 --> 00:12:48.409
or types were removed from the Pasteboard.

00:12:48.409 --> 00:12:52.039
And you can also get Notifications about the
Pasteboards being removed so as Pasteboards come

00:12:52.039 --> 00:12:55.730
and go you can find out about that as well.

00:12:55.730 --> 00:13:02.620
The items that are placed in the Pasteboard are
based entirely on Universal Type identifiers,

00:13:02.620 --> 00:13:07.639
so if you've been working with Pasteboards on Mac
OS 10 on the desktop, this is all stuff that's

00:13:07.639 --> 00:13:11.159
in the core services framework in UIKit or in Cocoa Touch.

00:13:11.159 --> 00:13:13.829
It's in the mobile core services framework.

00:13:13.830 --> 00:13:20.500
We support single and multiple items on the Pasteboard
as well as we provide a number of convenience API's

00:13:20.500 --> 00:13:25.789
for the data extensions for common things;
so Strings, URLs, Images and Colors.

00:13:25.789 --> 00:13:31.919
So a lot of things you're going to want to put on the
Pasteboard to either move to other Apps or in your own App,

00:13:31.919 --> 00:13:34.370
there's already API for doing all of that stuff.

00:13:34.370 --> 00:13:40.610
You can put your own data on the Pasteboard
just by producing NS data for that as well.

00:13:40.610 --> 00:13:46.990
And as part of this the UIMenuController is the
thing that actually puts up the cut, copy, paste UI--

00:13:46.990 --> 00:13:52.009
that nice little bubble that shows
up where the cursor is selected.

00:13:52.009 --> 00:13:56.990
So the sharedMenuController, there's only one, you
can get it from this method, sharedMenuController,

00:13:56.990 --> 00:14:03.200
and it has a number of different configuration
API's whether or not it's visible and whether

00:14:03.200 --> 00:14:05.160
to set it visible in an animated fashion.

00:14:05.159 --> 00:14:13.110
If you're using the property raw, it's just going to come
in; if you use the animated version you can control that.

00:14:13.110 --> 00:14:17.440
setTargetRect inView-- this is your opportunity
to be able to actually position it in the view.

00:14:17.440 --> 00:14:21.370
So if you're using standard controls like
UITextView and things like that we'll take care

00:14:21.370 --> 00:14:23.810
of positioning it correctly relative to the text.

00:14:23.809 --> 00:14:28.479
But if you've got a custom view and you've got your own data
that's involved in this, this is your opportunity to be able

00:14:28.480 --> 00:14:34.000
to position that menu right where you're drawing or
where the thing is that's being copied or pasted.

00:14:34.000 --> 00:14:38.120
And you can also tell it to update, so for whatever
reason the State's changed in your application

00:14:38.120 --> 00:14:41.750
and if you call update, we'll walk
through and figure out what responds

00:14:41.750 --> 00:14:47.350
to what and the canPerformAction withSender API.

00:14:47.350 --> 00:14:50.580
And we'll actually update the menu automatically.

00:14:50.580 --> 00:14:55.930
Our very own Andrew Platzer will be
giving the cut, copy, paste on iPhone talk in Russian Hill

00:14:55.929 --> 00:14:59.939
on Wednesday at 3:30, so if you're
going to be doing a lot of cut, copy,

00:14:59.940 --> 00:15:02.280
paste or if you want to know more
about it, please go to that talk.

00:15:02.279 --> 00:15:06.159
It will be really informative on this new feature.

00:15:06.159 --> 00:15:11.879
Wow, there are still more slides.

00:15:11.879 --> 00:15:17.309
UIScrollView-- there's new methods on ScrollView that
allow you to control how fast the deceleration rate happens

00:15:17.309 --> 00:15:23.469
so when the user flicks the ScrollView
and the rate starts to decay on the flick,

00:15:23.470 --> 00:15:30.779
you can set this to UIScrollViewDecelerationRateNormal
or RateFast; and the property's decelerationRate.

00:15:30.779 --> 00:15:38.319
We did catch a few applications trying to get
their own values in here, please don't do that.

00:15:38.320 --> 00:15:44.060
Use these methods and if you pass us any
value, if you just pass us something crazy,

00:15:44.059 --> 00:15:46.809
we are going to clamp it to one of the normal or fast.

00:15:46.809 --> 00:15:51.229
So we're trying to give the user a consistent
user experience here using ScrollViews,

00:15:51.230 --> 00:15:56.820
and if everybody has their own version of this where
it decelerates at different rates, it's very confusing.

00:15:56.820 --> 00:15:59.770
So we'd like you to use these.

00:15:59.769 --> 00:16:02.990
We also have ZoomScale so now you can control the zooming.

00:16:02.990 --> 00:16:06.360
In the UIScrollView programmatically
you can set the ZoomScale directly

00:16:06.360 --> 00:16:10.080
in both an animated fashion and you can zoomToRect.

00:16:10.080 --> 00:16:15.350
So if you just set the scale, we'll just go ahead and scale
that up and down and if you set a rectangle we'll go ahead

00:16:15.350 --> 00:16:18.200
and zoom right directly to that rectangle.

00:16:18.200 --> 00:16:19.590
So those are pretty straightforward.

00:16:19.590 --> 00:16:25.440
There's a bunch of API new UITableView as well

00:16:25.440 --> 00:16:32.950
One of the things that with the advent of the search
API's that we have is now this UITableViewIndexSearch.

00:16:32.950 --> 00:16:39.240
So remember we ask you for what index titles to
put down the right hand side of that TableView.

00:16:39.240 --> 00:16:42.320
If you return this as part of that
array, UITableViewIndexSearch,

00:16:42.320 --> 00:16:46.280
we'll put the magnifying glass right
there in the slot that you tell us to.

00:16:46.279 --> 00:16:52.519
We do recommend that you make this the first item in that
array, so that when the user taps on it and they wind

00:16:52.519 --> 00:16:55.899
up scrolling all the way to the top the
search bar actually appears right there.

00:16:55.899 --> 00:17:00.769
Don't put it at the end or something insane like that.

00:17:00.769 --> 00:17:03.039
reroadSectionIndexTitles-- really basic API.

00:17:03.039 --> 00:17:07.829
It just lets you tell us to go ahead and pull
new index titles so if something is updated,

00:17:07.829 --> 00:17:10.579
you can tell us to refresh that information.

00:17:10.579 --> 00:17:16.720
So some additional convenience API on TableView,
new methods for reloadSections withRowAnimation,

00:17:16.720 --> 00:17:24.750
and reloadRowsAtIndexPaths withRowAnimation, and these guys
just tell us to go through and reload the appropriate data.

00:17:24.750 --> 00:17:29.500
Now you used to have to either do a delete and an
insert or go through some other machinations for this.

00:17:29.500 --> 00:17:32.799
This just tells us reload the whole
section and the RowAnimations are things

00:17:32.799 --> 00:17:36.589
that you can pass to us from the RowAnimation [inaudible].

00:17:36.589 --> 00:17:42.599
And allowsSelection is going to actually allow you to
determine whether or not the TableView is going to go ahead

00:17:42.599 --> 00:17:49.740
and highlight rows when the user taps on them;
so now we've given you control over that as well.

00:17:49.740 --> 00:17:53.529
Some additional new delegate methods-boy,
there are a lot of new delegate methods.

00:17:53.529 --> 00:17:58.089
TableView willDeselectRowAtIndex
and didDeselectRowAtIndexPath

00:17:58.089 --> 00:18:03.629
so now you actually can get involved in the
deselection machinery and find out when that highlight's

00:18:03.630 --> 00:18:10.720
about to go away so you can do additional work or additional
animations and things like that in your TableViewCells.

00:18:10.720 --> 00:18:17.390
And TableView
titleforDeleteConfirmationButtonForRowAtIndexPath.

00:18:17.390 --> 00:18:23.880
I don't know if you guys have seen the Cocoa talks
but there's a much, much longer selector than this

00:18:23.880 --> 00:18:28.900
on NSBitmap Image Rep so this is
positively short by those standards.

00:18:28.900 --> 00:18:33.590
But for such a long method, this gives you the
ability to customize that button right there.

00:18:33.589 --> 00:18:47.000
So for everybody who's been saying, "I want something
other than delete there," here's your method.

00:18:47.000 --> 00:18:50.609
UITableViewCell-- initWithStyle reuseIdentifier.

00:18:50.609 --> 00:18:57.240
This is a new method on UITableViewCell and
it replaces initWithFrame reuseIdentifier.

00:18:57.240 --> 00:19:03.670
So everybody was, "We can give you a frame but we're just
going to resize it when we get it into TableViewCell."

00:19:03.670 --> 00:19:08.680
So initWithStyle reuseIdentifier is the
new initializer for UITableViewCells--

00:19:08.680 --> 00:19:13.900
again please also use the reuseIdentifier because that
really helps us out with performance and scrolling.

00:19:13.900 --> 00:19:18.450
You have a bunch of styles available to you and
these are things that we use in our own applications

00:19:18.450 --> 00:19:27.230
so UITableViewStyleDefault, TableViewCellStyleValue1,
Value2, and Subtitle-- those aren't terribly descriptive.

00:19:27.230 --> 00:19:29.559
This is what they look like.

00:19:29.559 --> 00:19:37.309
So by default, the UITableViewCellDefault has an image
view and the main text, just the text of the TableViewCell.

00:19:37.309 --> 00:19:46.220
The TableViewCellValue1, this has the text and a
subtitle; and Value2 has a different format for that.

00:19:46.220 --> 00:19:49.180
One is right justified; the other one
is left justified and you can tinker

00:19:49.180 --> 00:19:51.440
around with the metrics for this and things like that.

00:19:51.440 --> 00:19:56.440
And the subtitle actually is back to
having the imageView and the main text

00:19:56.440 --> 00:19:58.759
and the subtitle text directly underneath that main text.

00:19:58.759 --> 00:20:02.549
So again these are things that we use in our own
applications and if you're using these styles you're going

00:20:02.549 --> 00:20:11.490
to fit in very well with the rest
of the field with the iPhone.

00:20:11.490 --> 00:20:18.880
UITableViewCell new methods and properties
here-- if you look closely at the old API,

00:20:18.880 --> 00:20:24.510
you had direct access to the image and text and
things like that right on the TableViewCell.

00:20:24.509 --> 00:20:28.879
And we've actually deprecated all of those
methods in 3.0 and we're giving you direct access

00:20:28.880 --> 00:20:32.020
to the views that we use to put those things in.

00:20:32.019 --> 00:20:33.690
So it's a little bit of a subtle distinction.

00:20:33.690 --> 00:20:39.539
Rather than assigning an image to a TableViewCell, we're
going to go ahead and give you access to the ImageView;

00:20:39.539 --> 00:20:45.690
so if you call for an imageView on a TableViewCell,
and there isn't one we'll go ahead and create it

00:20:45.690 --> 00:20:47.900
and ven that out to you
and then you can set the image on that.

00:20:47.900 --> 00:20:51.509
And the same thing with the textLabel
and the detailTextLabels

00:20:51.509 --> 00:20:58.329
So when you're going to be modifying your
TableViewCells in iPhone OS 3.0, please use these methods.

00:20:58.329 --> 00:21:00.659
It also gives us some opportunities to do some optimization

00:21:00.660 --> 00:21:03.850
where if there isn't an imageView,
we're not going to actually create one.

00:21:03.849 --> 00:21:06.000
It lets us save a little memory.

00:21:06.000 --> 00:21:11.150
We also now have hooks to be able to find
out when the TableViewState is changing,

00:21:11.150 --> 00:21:18.380
so when the user taps on the edit button and gets all that
nice UI fades in to find out when things are changing,

00:21:18.380 --> 00:21:23.570
you can override these methods in
your UITableViewCell subclasses.

00:21:23.569 --> 00:21:28.659
So willTransitionToState and didTransitionToState
this is how you find out exactly just before

00:21:28.660 --> 00:21:35.220
and just after those transitions occur, and the
States are these DefaultMask, ShowingEditControlMask

00:21:35.220 --> 00:21:41.390
and ShowingDeleteConfirmationMask, and this is
your opportunity to basically animate any views

00:21:41.390 --> 00:21:43.700
that you've put into the UITableViewCells.

00:21:43.700 --> 00:21:48.180
So if you grab the content view and you've put some
of your own views in there, this is your opportunity

00:21:48.180 --> 00:21:57.450
to animate those views to provide additional feedback
for the edit and delete confirmation behaviors.

00:21:57.450 --> 00:22:01.500
So you get a crack at being able to do those for your views.

00:22:01.500 --> 00:22:09.769
You heard Phil talk about just how many countries
the Phone is showing up in yesterday morning.

00:22:09.769 --> 00:22:16.799
UILocalizedIndexedCollation is a class that we've introduced
in iPhone OS 3.0 to make it easier on you guys to be able

00:22:16.799 --> 00:22:22.200
to take your applications and move with
the user's change of their language.

00:22:22.200 --> 00:22:29.210
So when the user goes and selects a new language in
the general preferences, this class is actually going

00:22:29.210 --> 00:22:35.059
to help you provide new sorting
behaviors for your data and tableviews.

00:22:35.059 --> 00:22:37.210
So the current Collation is an object.

00:22:37.210 --> 00:22:43.049
You're going to get it from this factory method and you're
going to ask it for various things like the sectionTitles.

00:22:43.049 --> 00:22:46.899
So in English this is the A to Z
column with a number at the bottom,

00:22:46.900 --> 00:22:50.030
but in other languages it's going
to have different things there.

00:22:50.029 --> 00:22:53.359
So we're going to feed you the
sectionTitles that are appropriate

00:22:53.359 --> 00:22:57.199
for the localization that the users set their phone to.

00:22:57.200 --> 00:23:05.569
And SectionIndexTitles, these are basically the same
thing for the right hand side of the index there.

00:23:05.569 --> 00:23:09.079
sectionforSectionIndexTitleAtIndex.

00:23:09.079 --> 00:23:10.679
I had to read this three or four times too.

00:23:10.680 --> 00:23:11.810
Don't feel bad.

00:23:11.809 --> 00:23:17.349
A lot of times when you're working with Tableviews and
you've got far more sectionTitles and things like that

00:23:17.349 --> 00:23:22.529
than you do space in the index on the right hand
side, this is your opportunity to make between the two

00:23:22.529 --> 00:23:26.839
if there isn't a one to one correspondence between
the titles that are available and your section;

00:23:26.839 --> 00:23:33.189
so you basically get to tell us which section to scroll to
if the user has typed on a particular indexTitle some place

00:23:33.190 --> 00:23:35.450
in that index bar on the right hand side.

00:23:35.450 --> 00:23:42.400
So if you cross your eyes a little bit it makes a little
bit of sense; sectionForObject collationStringSelector

00:23:42.400 --> 00:23:45.590
and sortedArrayFromArray collationStringSelector.

00:23:45.589 --> 00:23:46.740
These are very similar.

00:23:46.740 --> 00:23:51.660
For both of these API's the collationStringSelector
is going to be a Selector

00:23:51.660 --> 00:23:56.210
that takes no arguments and returns an NSString.

00:23:56.210 --> 00:24:03.390
And when we call sectionforObject with the
collationStringSelector-well, you can call it--

00:24:03.390 --> 00:24:09.140
what will happen is we'll figure out, we'll call
that selector on your object and that's going

00:24:09.140 --> 00:24:12.960
to return an NSString and then we'll use
that string to figure out which section

00:24:12.960 --> 00:24:16.500
of the localization that object would belong in.

00:24:16.500 --> 00:24:20.940
So this is your opportunity basically to reorganize
all your objects into sections that are appropriate

00:24:20.940 --> 00:24:23.700
for the localization that the user is currently in.

00:24:23.700 --> 00:24:30.200
And sortedArrayFromArray, once you've got all of those
sections set up, well they might not be in the right order,

00:24:30.200 --> 00:24:34.590
so sortedArrayFromArray will give us the
Array, again the collationStringSelector,

00:24:34.589 --> 00:24:38.579
we'll sort that Array as appropriate for
the sorting rules and the collation rules

00:24:38.579 --> 00:24:41.470
for the localization that's currently in force.

00:24:41.470 --> 00:24:48.319
So if you use these, you'll be able to
participate in the user's localization much better.

00:24:48.319 --> 00:24:53.909
And it will be a much cleaner user experience no
matter what language the user sets their phone to.

00:24:55.390 --> 00:24:56.920
Thanks Mom.

00:24:56.920 --> 00:25:02.210
So UISearchBarScopes.

00:25:02.210 --> 00:25:07.690
When you tap on the SearchBar now in mail and in
other applications, you're going to get that ScopeBar.

00:25:07.690 --> 00:25:13.690
Mac OS X on the desktop has had one of these for a while
in the finder's search window and things like that.

00:25:13.690 --> 00:25:18.299
So now we have one here in iPhone OS
and you'll be able to control this.

00:25:18.299 --> 00:25:26.099
This particular example is from some sample code that's
out on the Web for searching but again it's the same one

00:25:26.099 --> 00:25:28.159
that we're using in mail and other applications.

00:25:28.160 --> 00:25:32.040
So you can find out whether the
SearchBar shows the ScopeBar.

00:25:32.039 --> 00:25:35.769
You can set that with the showsScopeBar API.

00:25:35.769 --> 00:25:37.400
ScopeButtonTitles is the Array.

00:25:37.400 --> 00:25:42.230
It's going to have the titles for the
buttons in that segmented control there;

00:25:42.230 --> 00:25:45.930
and selectiveScopeButtonIndex just tells
you which one is currently highlighted.

00:25:45.930 --> 00:25:54.039
The ScopeBar will only appear though if that
ScopeButtonTitles Array has two or more things in it.

00:25:54.039 --> 00:25:58.470
So we're not going to show it if
there's just no real scope there.

00:25:58.470 --> 00:26:04.500
And SearchBar selectedScopeButton Index did change--
another long method for a very simple thing.

00:26:04.500 --> 00:26:12.559
This just tells you when the user taps on the
ScopeBar and the new item becomes highlighted.

00:26:12.559 --> 00:26:17.419
It's a verbose language but we love it.

00:26:17.420 --> 00:26:24.200
We also now have a SearchDisplayController so with all this
search API being available, actually setting up the search

00:26:24.200 --> 00:26:28.200
and having an easy way to be able to
control the search is a little tricky.

00:26:28.200 --> 00:26:32.410
The SearchDisplayController is a way
to be able to make that a lot easier.

00:26:32.410 --> 00:26:37.810
So you'll initialize a SearchDisplayController
with a SearchBar and a contents Controller.

00:26:37.809 --> 00:26:43.869
And 99 times out of 100, your contents Controller
probably is going to be a UITableView Controller.

00:26:43.869 --> 00:26:50.000
You've already got the TableViewController set up probably
for your data, and it's got a delegate and DataSource

00:26:50.000 --> 00:26:55.190
and it has all that stuff hooked up to be able to
display the data directly out of that DataSource.

00:26:55.190 --> 00:26:59.900
So this is going to work in conjunction with the
UITableViewController that you're probably already using.

00:26:59.900 --> 00:27:04.550
The SearchDisplayController can have its
own delegate, so you'll be able to find

00:27:04.549 --> 00:27:05.950
out some things that are happening there.

00:27:05.950 --> 00:27:10.360
And whether or not it's active and in order
to set it active in an animated fashion.

00:27:10.359 --> 00:27:16.149
You can get the SearchBar from it, you can get the
searchContents Controller that was it was initialized with,

00:27:16.150 --> 00:27:22.060
and you can find out what searchResultsTableView
the searchResultsDisplayController is going to use.

00:27:22.059 --> 00:27:23.250
All right so this is pretty significant.

00:27:23.250 --> 00:27:28.680
It's going to create a TableView for
you to display your searchResults in.

00:27:28.680 --> 00:27:33.450
And the searchResults data source
and searchResults delegate--

00:27:33.450 --> 00:27:38.970
these guys actually wind up being
probably the UITableView Controller

00:27:38.970 --> 00:27:41.950
that you passed us to initialize one of these things.

00:27:41.950 --> 00:27:48.650
And that actually lets you do something pretty slick
which is in your TableViewController's delegate methods,

00:27:48.650 --> 00:27:54.410
TableView, number of rows and sections, things like
that; if you're getting TableView from the ViewController

00:27:54.410 --> 00:27:58.200
that incoming TableView on that method is
going to be the one from the ViewController.

00:27:58.200 --> 00:28:01.250
But if you're getting it from the
SearchDisplayController, it's going to be the one

00:28:01.250 --> 00:28:04.920
from this method that you initialized here.

00:28:04.920 --> 00:28:10.310
So you can actually multiplex in your delegate method
that you're using in your UITableViewController right now

00:28:10.309 --> 00:28:14.980
to be able to distinguish whether you're in view all the
data mode or whether you're in view some of the data mode;

00:28:14.980 --> 00:28:20.240
and this is how you can participate directly
with the SearchDisplayController API's.

00:28:20.240 --> 00:28:27.210
A bunch of delegate methods on this, so we've got some
fairly sophisticated notifications on the delegate

00:28:27.210 --> 00:28:29.819
to tell you when all this stuff is happening.

00:28:29.819 --> 00:28:35.779
So WillBeginSearch and DidBeginSearch, these
are your opportunities to set up your DataSource

00:28:35.779 --> 00:28:39.230
or do whatever work you need to
do just before the search begins.

00:28:39.230 --> 00:28:44.539
WillEndSearch and DidEndSearch, you'll
also get PNG's for that on your delegate.

00:28:44.539 --> 00:28:51.059
SearchDisplayController did load SearchResultsTableView--
this is where it's actually going to bring in its TableView

00:28:51.059 --> 00:28:53.980
to do its work so you can find out when that happens.

00:28:53.980 --> 00:29:00.880
And all of these methods for willShow, didShow, willHide,
didHide the TableView and these are just opportunities

00:29:00.880 --> 00:29:02.940
for you to find out when all that stuff is happening.

00:29:02.940 --> 00:29:07.350
You may want to be able to change
some of the UI or stuff like that.

00:29:07.349 --> 00:29:10.129
SearchDisplayController shouldReloadTableRorSearchString,

00:29:10.130 --> 00:29:13.040
this is your chance to tell us
whether or not there's any work to do.

00:29:13.039 --> 00:29:17.329
All right so if the user types in a SearchString
and if it's the same SearchString that's before,

00:29:17.329 --> 00:29:20.699
you might get an opportunity to say no from this,
and we're not going to go through and ask you

00:29:20.700 --> 00:29:24.539
for all the search results data and things like that.

00:29:24.539 --> 00:29:29.579
And the SearchDisplayController
shouldReloadTableforSearchScope-- same thing.

00:29:29.579 --> 00:29:35.619
Let's say you've got your SearchScope up there
and if there's no reason to reload the data,

00:29:35.619 --> 00:29:38.509
this is your opportunity to tell
us, "Yeah there's no work to do.

00:29:38.509 --> 00:29:40.230
Don't worry about it.

00:29:40.230 --> 00:29:44.360
Pay no attention to that man behind the curtain."

00:29:44.359 --> 00:29:45.699
UITabBarController.

00:29:45.700 --> 00:29:50.450
We've had a bunch of requests for some more
access to the UITabBarController behaviors.

00:29:50.450 --> 00:29:56.740
The first one is you can get the TabBar directly from
the TabBarController so just like UINavigationController,

00:29:56.740 --> 00:30:01.990
we've given you access to the ToolBar it's using, this gives
you access to the TabBar the UITabBarController is using.

00:30:01.990 --> 00:30:04.120
It is read only, please don't modify this.

00:30:04.119 --> 00:30:07.129
This is just for state checking.

00:30:07.130 --> 00:30:11.790
TabBarController shouldSelectViewController;
willBeginCustomizingViewController;

00:30:11.789 --> 00:30:15.240
shouldSelectViewController gives you the
opportunity to say no so that when the user taps

00:30:15.240 --> 00:30:19.059
on a different TabBar item you don't switch.

00:30:19.059 --> 00:30:24.099
So this is a way maybe to help the user not
lose some of their work, things like that.

00:30:24.099 --> 00:30:30.619
TabBarController willBeginCustomizingViewControllers,
willEndCustomizingViewControllers changed

00:30:30.619 --> 00:30:33.069
and didEndCustomizingViewControllers changed.

00:30:33.069 --> 00:30:38.460
This is how you find out how the users customize their
TabBar and when they've customized it and whether

00:30:38.460 --> 00:30:42.549
or not at the end of all that operation
they actually changed anything.

00:30:42.549 --> 00:30:47.480
They might have moved stuff around and then wound up
with the same TabBar configuration that they had before.

00:30:47.480 --> 00:30:56.349
So these are your opportunities to find
out when all of those things happen.

00:30:56.349 --> 00:31:02.129
UIViewController has some new methods for viewDidUnload and
isViewLoaded and these are really just opportunities for you

00:31:02.130 --> 00:31:04.320
to be able to find out-- oh somebody likes those.

00:31:04.319 --> 00:31:09.149
These are your opportunities to find out
just the State of the UIViewController.

00:31:09.150 --> 00:31:15.440
viewDidUnload is just simply yes it jettisoned
the view, and isViewLoaded you get to check

00:31:15.440 --> 00:31:19.850
to see whether or not the view is loaded
without actually causing the view to load.

00:31:24.210 --> 00:31:26.930
One little method but very handy.

00:31:26.930 --> 00:31:32.700
And there's now also some new API and UIViewController
that allows you to do a one part animation,

00:31:32.700 --> 00:31:39.460
and I found OS 2.0 on the rotation there are two parts to
the animation-- there's a first part and a second part.

00:31:39.460 --> 00:31:42.630
And this is actually just an opportunity
to do a faster one part animation.

00:31:42.630 --> 00:31:49.720
So willAnimateRotationToInterfaceOrientation duration-- this
is where we're telling you okay users switched orientations

00:31:49.720 --> 00:31:53.860
and you're about to go through
for an animation of this duration.

00:31:53.859 --> 00:31:58.250
And you can find out when that happens here.

00:31:58.250 --> 00:32:00.130
Also wantsFullScreenLayout.

00:32:00.130 --> 00:32:05.800
Well unfortunately I don't have a
screenshot for this but it's pretty simple.

00:32:05.799 --> 00:32:10.819
UIViewController when it sets up your views,
automatically resizes them to compensate for the status bar

00:32:10.819 --> 00:32:14.259
across the top-- the little thing that tells
you that you either don't have wireless

00:32:14.259 --> 00:32:16.200
or you don't have 3G depending on where you are.

00:32:16.200 --> 00:32:19.920
In Mountain View I never have 3G.

00:32:19.920 --> 00:32:27.789
wantsFullScreenLayout says if you return yes from there, if
you set this to return yes this tells us to resize the view

00:32:27.789 --> 00:32:32.970
so that it fits underneath the status bar
there, and if the status bar is translucent,

00:32:32.970 --> 00:32:36.400
you'll be able to see your view underneath
it as things scroll and move around.

00:32:36.400 --> 00:32:41.280
I had no idea I had so many relatives in the audience.

00:32:41.279 --> 00:32:43.980
This is great.

00:32:43.980 --> 00:32:48.680
UIViewControllers also now have some
new behaviors from ModalTransitions.

00:32:48.680 --> 00:32:53.039
So now I have a bunch of stuff that allows you to
control exactly how these ModalTransitions occur.

00:32:53.039 --> 00:32:58.490
There's a ModalTransitionStyle; CoverVertical
is simply the slide-in that we already do;

00:32:58.490 --> 00:33:03.299
FlipHorizontal is just taking the view and
flipping it to the other side and it looks

00:33:03.299 --> 00:33:08.700
like you've flipped the thing over; and
CrossDissolve is a straight up cross fade.

00:33:08.700 --> 00:33:13.880
If you've been watching Evan Doll on
iTunes U with the Stanford University Class that he teaches,

00:33:13.880 --> 00:33:20.640
you can see him live in the Presidio Thursday
at 5 p.m. That does say Thursday, yes.

00:33:20.640 --> 00:33:22.370
I want to get it right for the rest of the slides.

00:33:22.369 --> 00:33:28.479
iPhone ViewController techniques and he's going to
spend a lot of time going over all of this stuff.

00:33:28.480 --> 00:33:34.460
It will be a great talk especially if you're very heavily
ViewController based which you all should be right?

00:33:34.460 --> 00:33:44.519
Good. We have a number of new features
also which I'll talk about here.

00:33:44.519 --> 00:33:51.420
One of them are some Info plist Keys that we would
like to turn on in a future version of the OS.

00:33:51.420 --> 00:33:54.410
They're not on right now but you
can play with them in the simulator.

00:33:54.410 --> 00:34:05.300
The first one is UIViewGroupOpacity and this has to do
with how we deal with opacity in a tree of subviews.

00:34:05.299 --> 00:34:11.570
So if you set the opacity on a top level view, and you don't
set it everywhere else, this has to do with how we wind

00:34:11.570 --> 00:34:19.309
up rendering those subviews into the render tree
and Edge Anti-aliasing, UIViewAntialiasing--

00:34:19.309 --> 00:34:25.440
this is going to control exactly how the edges of the
views are drawn; if they appear on half pixel boundaries

00:34:25.440 --> 00:34:32.309
or if they're rotated and things like that
and I have actually a brief demo of these.

00:34:32.309 --> 00:34:43.630
The first one we'll do is-- let's take a look at the
ViewOpacity demo and this is just a very simple application.

00:34:43.630 --> 00:34:50.230
We have a bunch of people at work who are big space
shuttle fans so I figured I'd do something here with that.

00:34:50.230 --> 00:34:59.320
What I've got here is each of those patches up there;
those are the STS mission patches for 124 and 125.

00:34:59.320 --> 00:35:07.720
125 is the Hubble servicing mission, and I've
just badged those with a really big number 6.

00:35:07.719 --> 00:35:15.139
And this slider down here at the bottom controls
the GroupOpacity so each of those is a single UIView

00:35:15.139 --> 00:35:19.190
that has two image views inside
of it-- the patch and the badge.

00:35:19.190 --> 00:35:24.659
And what I'm doing here is I'm just setting the opacity on
the top level UIView, it's actually the view you can't see,

00:35:24.659 --> 00:35:31.299
but when I cause the opacity to slide down here--
let me get this down to something like 20% or so.

00:35:31.300 --> 00:35:45.210
If I zoom in on this, you see that where those
views draw, you can see the patch through the badge

00:35:45.210 --> 00:35:48.050
which is probably not the effect you want.

00:35:48.050 --> 00:35:50.260
What we're doing there is everybody
is getting their own opacity

00:35:50.260 --> 00:35:53.740
and we're just letting you see through all of those views.

00:35:53.739 --> 00:36:01.789
When you turn on this UIViewGroupOpacity you can kind
of see it a little better here on the STS125 patch here.

00:36:01.789 --> 00:36:05.269
You can see the red line through here
and the names and the little galaxy.

00:36:05.269 --> 00:36:19.659
When I set the UIViewGroupOpacity
key in the Info plist, oh here it is.

00:36:19.659 --> 00:36:23.929
Xcode actually recognizes this-- let
me add this key here in the Info plist.

00:36:23.929 --> 00:36:28.449
This is UIViewGroupOpacity.

00:36:28.449 --> 00:36:34.559
Xcode translates it into this nice
rendersWithGroupOpacityString.

00:36:34.559 --> 00:36:40.139
If I turn that on and just rebuild
this App; I haven't changed any code.

00:36:40.139 --> 00:36:44.039
I just changed the behavior of
how we're rendering these views.

00:36:44.039 --> 00:36:53.039
Now if I make this roughly 20% transparent and zoom
in on this guy-- I love that accessibility zoom.

00:36:53.039 --> 00:36:57.190
Now you see that the patch doesn't show through the badge.

00:36:57.190 --> 00:37:07.039
What we're doing there is basically rendering everything
to an offscreen buffer individually at the opacity,

00:37:07.039 --> 00:37:09.750
and then bringing that buffer back
onscreen and rendering it in.

00:37:09.750 --> 00:37:14.630
So this gives you probably a little closer to the
behavior you were expecting with Group opacity.

00:37:14.630 --> 00:37:20.309
Again, we're going to turn this on by default in a future
version of the OS, what we'd like you guys to do is go back

00:37:20.309 --> 00:37:27.449
and try your Apps out in the simulator with this key
set; and that will tell you how your drawing is working

00:37:27.449 --> 00:37:30.409
and whether or not there's any work to do there.

00:37:30.409 --> 00:37:39.690
And the other one is EdgeAntialiasing and I
have an admittedly very cheesy demo for this.

00:37:39.690 --> 00:37:48.740
But this is just a view that-- it's a square view and
I've got a transform on it that rotates at 45 degrees.

00:37:48.739 --> 00:37:59.149
And if we zoom in on this, well it's not terribly indicative
because I'm getting hosed by the scaling that's going

00:37:59.150 --> 00:38:07.590
on here; but you can see that stepladder effect
there that is basically, it's an aliased thing.

00:38:07.590 --> 00:38:11.140
There's a gray background here and
all you see is a black pixel of square

00:38:11.139 --> 00:38:14.589
that steps up and the gray background behind it.

00:38:14.590 --> 00:38:31.970
So if I go ahead and edit this Info
plist for UIViewEdgeAntialiasing.

00:38:31.969 --> 00:38:43.519
Again, it translates it into something readable and
run it; hopefully we'll see-- hey look, it's blurrier.

00:38:43.519 --> 00:38:49.670
What's actually happening here is the
edge is actually being anti-aliased.

00:38:49.670 --> 00:38:52.619
And in the darker parts of the square there's a darker gray;

00:38:52.619 --> 00:38:56.739
and in the gray section there's
sort of a darker gray from that.

00:38:56.739 --> 00:39:01.589
So basically that edge is automatically
getting anti-aliased by UIKit when it renders.

00:39:01.590 --> 00:39:06.269
And the idea here is that we're going to try and
make this situation work a lot better for you.

00:39:06.269 --> 00:39:16.570
So please try both of those keys in your applications
anytime you like but sooner would be better than later.

00:39:16.570 --> 00:39:23.019
So let's see-- Data Detectors.

00:39:23.019 --> 00:39:34.710
Data Detectors have been present in Mac OS X on the desktop
for a release or so now and they're pretty sophisticated.

00:39:34.710 --> 00:39:42.309
Data Detectors in UIKit are going to happen on UITextView
and UIWebViews and if you set the DataDetectorTypes--

00:39:42.309 --> 00:39:48.909
you can set PhoneNumber and Link so we recognize things that
look like URL's and things that look like phone numbers.

00:39:48.909 --> 00:39:55.190
There's also a UIDataDetectorTypeAll here; and if
you're going to set Data Detectors on your UITableViews,

00:39:55.190 --> 00:39:59.639
we'd like you to set UIDataDetectorTypeAll
as much as possible.

00:39:59.639 --> 00:40:03.789
And the reason for that is as we update
the Data Detectors that become available;

00:40:03.789 --> 00:40:11.500
for instance if we add an address Data Detector, we want
your views to be able to get those behaviors automatically.

00:40:11.500 --> 00:40:15.889
If you just set PhoneNumber, if you just set Link, and
we add some new things, you're not going to get all

00:40:15.889 --> 00:40:19.889
of that neat new functionality without
having to resubmit your App to the store.

00:40:19.889 --> 00:40:25.359
So if you use TypeAll you're going to be a little bit
more future proof as new Data Detectors come online.

00:40:25.360 --> 00:40:30.160
And we now have In-application email Message Sending.

00:40:30.159 --> 00:40:43.420
You get to include the Message UIframework, pick up
data include and you get a brand new MailController,

00:40:43.420 --> 00:40:46.710
the mail framework MFMailComposeViewController.

00:40:46.710 --> 00:40:52.440
And it gives you the exact same Mail
UI that we use in our own applications.

00:40:52.440 --> 00:40:57.789
So you'll get the ViewController comes up, it's
the new message, it has all of the bits there

00:40:57.789 --> 00:41:02.420
for filling in to and from and things like that.

00:41:02.420 --> 00:41:06.470
You also can find out whether or not
the user is actually able to send mail.

00:41:06.469 --> 00:41:12.949
If canSendMail returns no, this is your opportunity
to either disable UI that would allow them to SendMail

00:41:12.949 --> 00:41:17.049
and not show certain buttons, things like that,
and you might not be able to send mail for a bunch

00:41:17.050 --> 00:41:19.480
of different reasons, like the user
hasn't configured a mail account.

00:41:19.480 --> 00:41:23.760
It makes it hard to send mail, things like that.

00:41:23.760 --> 00:41:31.920
You also have complete control over the SubjectRecipients,
the Cc, To, Cc, and Bcc, and you also get an opportunity

00:41:31.920 --> 00:41:37.090
to tell us to set the MessageBody for a particular
message, and whether or not that MessageBody is HTML.

00:41:37.090 --> 00:41:44.800
So if you have a String and it's just a plain text email,
pass node is HTML here, if it's a string that has HTML tags

00:41:44.800 --> 00:41:50.519
in it and you tell us yes it is HTML, we'll go
ahead and render it as HTML in the mail window.

00:41:50.519 --> 00:41:56.409
And you also get control over adding attachments;
addAttachmentData, mimeType, fileName.

00:41:56.409 --> 00:42:03.829
Give us the NSData, tell us what the
mimeType is, you know application,

00:42:03.829 --> 00:42:05.519
NSString and that kind of thing and the filename.

00:42:05.519 --> 00:42:06.940
The filename's actually pretty important.

00:42:06.940 --> 00:42:11.240
Choose it carefully because that's what the
user sees in the mailController right there;

00:42:11.239 --> 00:42:15.769
and it will give him a much better
idea of what that file is.

00:42:15.769 --> 00:42:21.820
There are some methods on this that allow you to find out
exactly what's either gone wrong or hasn't gone wrong.

00:42:21.820 --> 00:42:26.830
Hopefully nothing goes wrong; mailComposeController
didFinishWithResult error.

00:42:26.829 --> 00:42:32.389
The mailComposeController will tell you how it's ending.

00:42:32.389 --> 00:42:36.940
When it goes away you'll get a PNG back
on your delegate that says we finished.

00:42:36.940 --> 00:42:39.079
The results are a whole bunch of different things.

00:42:39.079 --> 00:42:44.670
One of them is MFMailComposeResultCancelled;
ComposeResultSaved;

00:42:44.670 --> 00:42:49.309
ComposeResultSent; and ComposeResultFailed.

00:42:49.309 --> 00:42:57.139
And the Saved means that we made it to the
outbox but it didn't get off the device.

00:42:57.139 --> 00:43:00.480
Sent means hey, you actually managed
to get the mail sent off the device.

00:43:00.480 --> 00:43:05.769
Failed means yes something went really wrong
and we couldn't get it off the device at all.

00:43:05.769 --> 00:43:10.380
And the errors that you get back, again,
these NSErrors are all populated with things

00:43:10.380 --> 00:43:13.099
that are suitable for display to the user.

00:43:13.099 --> 00:43:18.799
So you may not have to do any modifications of
this if you're just doing straight up mail sending.

00:43:18.800 --> 00:43:21.500
So the ErrorDomain has two codes.

00:43:21.500 --> 00:43:26.260
SaveFailed means we couldn't even get it
in the outbox, and SendFailed means it was

00:43:26.260 --> 00:43:28.780
in the outbox, it didn't make it off the device.

00:43:28.780 --> 00:43:33.700
But if the user were to go check
they'd still see mail in their outbox.

00:43:33.699 --> 00:43:37.759
Matt Drance is our developer
evangelist for iPhone and Mac Applications Frameworks.

00:43:37.760 --> 00:43:38.730
That's his e-mail address.

00:43:38.730 --> 00:43:41.070
There's a lot of documentation on the iPhone Dev Center.
WEBVTT

00:00:13.009 --> 00:00:18.640
>> I'm Adam Swift, I'm an Engineer in the
Core Data Team and I want to talk to you

00:00:18.640 --> 00:00:22.199
about the new features in Core Data and Snow Leopard.

00:00:22.199 --> 00:00:27.789
Now I was joking that I was going to come
out here and just say "It is on the phone,"

00:00:27.789 --> 00:00:29.859
which is great and we're really excited about that.

00:00:29.859 --> 00:00:34.210
But really we've got a lot of new features
in Snow Leopard that we think are going

00:00:34.210 --> 00:00:38.450
to help you accelerate your development,
optimize your performance,

00:00:38.450 --> 00:00:41.820
and really get the most out of
Core Data in your application.

00:00:41.820 --> 00:00:50.269
So in this session, we're going to talk
about data migration, Spotlight integration,

00:00:50.270 --> 00:00:55.900
best practices for using Core Data
with Grand Central Dispatch

00:00:55.899 --> 00:00:59.359
fetch performance and a variety of tips and tricks.

00:00:59.359 --> 00:01:06.859
So at the end of the session, what I'm hoping you'll walk
away with is an understanding of how to take advantage

00:01:06.859 --> 00:01:14.120
of these new features, to reduce and simply the amount of
code you need to maintain, and improve your performance

00:01:14.120 --> 00:01:20.230
to use less memory with Core Data
and achieve faster performance.

00:01:20.230 --> 00:01:25.040
So the first thing I'd like to go
through is lightweight migration.

00:01:25.040 --> 00:01:31.010
And the general philosophy here is
you start out with an application.

00:01:31.010 --> 00:01:36.230
And when you're first doing your data model design,
you think about the needs of your application,

00:01:36.230 --> 00:01:40.409
you design your entities, the attributes,
to store all the data that you need,

00:01:40.409 --> 00:01:43.280
and you have some considerations for performance.

00:01:43.280 --> 00:01:49.549
But as soon-- as soon as you start building an application
and testing it, you realize that as your data set grows,

00:01:49.549 --> 00:01:53.159
there are some places where your
performance starts to suffer.

00:01:53.159 --> 00:01:57.649
And also, when users start to get access to your
application, you are going to get some feedback

00:01:57.650 --> 00:02:01.240
about missing features or some
other things you'd like to change.

00:02:01.239 --> 00:02:05.899
And this is the right time to start thinking
about changing your data model to adjust

00:02:05.900 --> 00:02:07.630
for what these changes are going to require.

00:02:07.629 --> 00:02:13.379
And we want you to do that, this is the
right time to be changing your data model.

00:02:13.379 --> 00:02:18.439
So in Leopard, we introduced scheme
and migration and I want to walk you

00:02:18.439 --> 00:02:22.930
through that process really quickly just to review.

00:02:22.930 --> 00:02:27.290
So you start out with the version 1.0 of your data
model and you build up some data and you can see

00:02:27.289 --> 00:02:31.849
that in the store file there, that's
the box with blocks in it.

00:02:31.849 --> 00:02:36.509
And when you realize, you need to change your
data model, you can build a mapping model

00:02:36.509 --> 00:02:42.340
to describe those data transformations to convert the
data that you've got in version 1.0 of your data model

00:02:42.340 --> 00:02:48.650
to the version that's compatible with
version 1.1 or 2 or whatever it is.

00:02:48.650 --> 00:02:55.129
So you create a map on migration manager and you
set the mapping model on the migration manager,

00:02:55.129 --> 00:02:59.549
feed in your source data store and out the
other side comes a data store that's compatible

00:02:59.550 --> 00:03:01.030
with the next version of your data model.

00:03:01.030 --> 00:03:04.000
And that's the Leopard schema and migration process.

00:03:04.000 --> 00:03:10.979
And let's look through the basic steps or
the basic rules of Leopard schema migration.

00:03:10.979 --> 00:03:17.239
You need a compatible data model
to open-- to access your data

00:03:17.240 --> 00:03:21.920
And you can create a mapping model to migrate that data.

00:03:21.919 --> 00:03:29.419
Now Xcode provides an assistant, but creating a
mapping model does require a little bit of hand tuning

00:03:29.419 --> 00:03:34.169
and if you have truly complex changes
in your data model between versions,

00:03:34.169 --> 00:03:37.859
you'll need to write some code to
deal with those transformations.

00:03:37.860 --> 00:03:44.560
And all of these things are described in the Core Data
Model Versioning And Data Migration Programming Guide.

00:03:44.560 --> 00:03:51.000
So if you haven't worked with a mapping model
before, I want to show you what it looks like

00:03:51.000 --> 00:03:55.270
and this is the standard Xcode editor for a mapping model.

00:03:55.270 --> 00:04:01.960
And you create it in the assistant with a
source data model and a destination data model.

00:04:01.960 --> 00:04:08.820
And then for each of the entities in your data
models, you need to provide entity mappings.

00:04:08.819 --> 00:04:13.430
You need to define entity mappings to describe
each of the properties of those entities

00:04:13.430 --> 00:04:16.810
and how they should be transformed
from version 1 to version 2.

00:04:16.810 --> 00:04:24.360
And during the development process, you're going to repeat
the cycle over and over again as you test, change your code,

00:04:24.360 --> 00:04:30.920
change your model, you'll discover new performance
bottlenecks, or you may find more features you want to add.

00:04:30.920 --> 00:04:35.680
And this change is good and we wanted
to facilitate this is much as possible.

00:04:35.680 --> 00:04:41.600
So this is one of the things we focus on for Snow Leopard
was adding a new automatic migration technology we call

00:04:41.600 --> 00:04:43.330
"lightweight migration."

00:04:43.329 --> 00:04:48.310
And it's simple data migration, it's easy
to set up, and you can do it with zero code.

00:04:48.310 --> 00:04:51.560
We think this is a huge win and really
encourage everyone to try it out.

00:04:51.560 --> 00:04:53.060
So what is it?

00:04:53.060 --> 00:04:55.160
It's inferred data migration.

00:04:55.160 --> 00:05:00.100
Core Data will automatically infer
the mapping model for you.

00:05:00.100 --> 00:05:03.360
It only handles unambiguous changes
but that covers a lot of territory.

00:05:03.360 --> 00:05:10.480
So I'm going to walk you through a few examples of
what is considered unambiguous or inferable changes.

00:05:10.480 --> 00:05:16.439
So in version 1 of your data model, you have
defined a song entity, and it has an attribute,

00:05:16.439 --> 00:05:20.920
name attribute and album and lyrics relationships.

00:05:20.920 --> 00:05:25.720
Well, when you go to make an update your
data model, you want to make some changes.

00:05:25.720 --> 00:05:33.740
You decide that name really isn't expressing the right-- the
song title the right way, it better expresses this title.

00:05:33.740 --> 00:05:39.960
So you replace name with title and your
users are saying they want to know--

00:05:39.959 --> 00:05:41.750
they want to keep track of how long the songs are.

00:05:41.750 --> 00:05:43.860
They want to be able to see that in the interface.

00:05:43.860 --> 00:05:49.170
So you can add a length attribute to your song entity.

00:05:49.170 --> 00:05:54.020
Also, you got feedback that nobody is really
interested in keeping track of the lyrics

00:05:54.019 --> 00:05:57.250
and really it's just causing your
performance to get bogged down.

00:05:57.250 --> 00:05:59.790
So you get rid of that relationship entirely.

00:05:59.790 --> 00:06:04.410
All of these changes can be inferred
automatically and the data can be migrated

00:06:04.410 --> 00:06:06.370
with lightweight migration without any code.

00:06:06.370 --> 00:06:10.110
So let's look at another example.

00:06:10.110 --> 00:06:12.910
You can add, remove, or rename entities as well.

00:06:12.910 --> 00:06:16.720
So going back to the data model, you've got, say

00:06:16.720 --> 00:06:23.610
in version 1 you've named your entity--
two other entities, musician and lyrics.

00:06:23.610 --> 00:06:28.910
Well, you just got rid off the lyrics relationship
so you might as well get rid of the entity entirely.

00:06:28.910 --> 00:06:31.860
And you can do that.

00:06:31.860 --> 00:06:38.400
Musician really isn't expressing that entity
name correctly, it could be better called artist.

00:06:38.399 --> 00:06:42.829
And maybe you are starting to build a relationship
with some of the record labels so you want to be able

00:06:42.829 --> 00:06:44.699
to represent that in your application as well.

00:06:44.699 --> 00:06:51.209
So you can add the label entity and create
a relationship from your artist to label.

00:06:51.209 --> 00:06:56.359
Again, these are all inferable changes and
the data can be migrated without any code.

00:06:56.360 --> 00:07:07.680
Let's take a deeper look at what kinds of changes you
can make with your entities in lightweight migration.

00:07:07.680 --> 00:07:14.540
So in version 1, we've got a song and a video
and they share a lot of the same properties.

00:07:14.540 --> 00:07:19.580
They both have name attributes and
they both have data relationships.

00:07:19.579 --> 00:07:24.779
But you can't have a relationship that
goes to either one of them, to both--

00:07:24.779 --> 00:07:29.879
you can't have a relationship that goes to objects of both
of those types because they don't share a common parent.

00:07:29.879 --> 00:07:34.649
Well, you can add a common parent and have that--
have both of those entities inherit from it

00:07:34.649 --> 00:07:39.959
and even move those properties up to the parent entity.

00:07:39.959 --> 00:07:44.789
And this again, can be handled with lightweight migration.

00:07:44.790 --> 00:07:46.460
So how do you do it?

00:07:46.459 --> 00:07:48.549
What do you need to do to use it?

00:07:48.550 --> 00:07:52.189
It's got really easy set up, there
are just two things you need to do.

00:07:52.189 --> 00:07:56.410
One, you need to keep the old version of your data model.

00:07:56.410 --> 00:08:02.980
When-- in order for Core Data to open up
your original data model for the migration,

00:08:02.980 --> 00:08:05.100
it needs to have a copy of that source data model.

00:08:05.100 --> 00:08:10.710
So use the Xcode design menu to add a new model
version when you're getting ready to make changes.

00:08:10.709 --> 00:08:12.889
Don't just go changing your old data model.

00:08:12.889 --> 00:08:17.729
Second, you need to enable the migration objects.

00:08:17.730 --> 00:08:23.590
You need to infer mapping models at them at the option
to infer mapping models automatically and the option

00:08:23.589 --> 00:08:26.159
to migrate persistent stores automatically.

00:08:26.160 --> 00:08:35.120
Now there's a detail I glossed over
with renaming entities and properties.

00:08:35.120 --> 00:08:41.929
For-- the inferred mapping model to understand what
your intention is when you're deleting an old attribute

00:08:41.929 --> 00:08:45.779
and adding a new one versus renaming an attribute.

00:08:45.779 --> 00:08:52.139
We've added a new piece of API to
specify the renaming identifier.

00:08:52.139 --> 00:09:01.870
And you can specify this directly in Xcode design-- model
design tool and you can see here the field is shown in the--

00:09:01.870 --> 00:09:10.740
this is the attribute configuration inspector and I've
got the song entity selected here, the title property,

00:09:10.740 --> 00:09:12.500
and this is the version 2 of my data model.

00:09:12.500 --> 00:09:19.409
So in order to rename and-- in order to rename the
name property to title and be able to migrate that data

00:09:19.409 --> 00:09:26.879
from my source, data storage to the destination, I just need
to put in the old name right and renaming identifier field.

00:09:26.879 --> 00:09:32.419
And inferred migration or lightweight migration will
take care of inferring that change automatically.

00:09:35.110 --> 00:09:40.480
So this already provides you a huge value
in terms of workflow efficiency, it makes--

00:09:40.480 --> 00:09:47.370
making model changes a lot less stressful, it's easier,
you don't need to worry about adding an attribute

00:09:47.370 --> 00:09:53.610
or replacing the name of a value, but
there's a huge other benefit to it.

00:09:53.610 --> 00:10:03.980
Because of the changes can be-- are unambiguous and
relatively simple, the entire migration process can be done

00:10:03.980 --> 00:10:07.820
in the database without fetching any rows into memory.

00:10:07.820 --> 00:10:12.830
It uses SQL to transform tables and update rows.

00:10:12.830 --> 00:10:17.580
>> And it's really the fastest, least
amount of memory way to do data migration.

00:10:17.580 --> 00:10:24.910
Now if you get unexpected results or you run
into problems with using lightweight migration,

00:10:24.909 --> 00:10:31.579
there are a number of default that-- defaults you can
set to enable logging during the migration process.

00:10:31.580 --> 00:10:37.790
And these defaults work on the desktop only.

00:10:37.789 --> 00:10:45.529
To enable migration logs, you want to enable-- oh, I'm
sorry I meant to say, I've displayed the syntax here

00:10:45.529 --> 00:10:48.230
for passing these defaults as arguments to your executable.

00:10:48.230 --> 00:10:51.820
So you can do that right in the Xcode executable inspector.

00:10:51.820 --> 00:10:55.270
But you can enable migration logging and SQL logging.

00:10:55.269 --> 00:11:02.029
And since the migration, if you're using a SQLite store
it's being performed entirely with SQL statements.

00:11:02.029 --> 00:11:08.610
You can see a lot of what's going on
by just enabling the SQL logs for that.

00:11:08.610 --> 00:11:15.250
So to sum up with lightweight migration gives
you, it's simple migration for simple changes,

00:11:15.250 --> 00:11:18.039
it's very easy to set up, and it's exceedingly fast.

00:11:18.039 --> 00:11:22.429
So especially on the phone, you get a
huge benefit for using this when you can.

00:11:22.429 --> 00:11:27.459
And for those cases where you're-- making
a data model change that's too complex

00:11:27.460 --> 00:11:29.800
or it can't be handled with lightweight migration.

00:11:29.799 --> 00:11:35.370
You can provide your own custom
mapping model for those steps.

00:11:38.629 --> 00:11:44.769
So now I'd like to turn my attention
to Spotlight search integration.

00:11:44.769 --> 00:11:48.120
And you're maybe wondering, what's new about that?

00:11:48.120 --> 00:11:55.429
We have offered Spotlight search integration since our
first release-- since Core Data was first released in Tiger.

00:11:55.429 --> 00:12:04.059
We've provided a document-based Spotlight importer
and it works great for finding Core Data documents.

00:12:04.059 --> 00:12:13.709
But what about non-document-based applications
where all the records live in a single file?

00:12:13.710 --> 00:12:19.480
Let's look at an example of what Spotlight
does when you're dealing with documents

00:12:19.480 --> 00:12:24.730
versus non-documents-- non-document-based apps.

00:12:24.730 --> 00:12:30.470
So if I search for barbeque, something I'm
fond of, I'll get all of the documents,

00:12:30.470 --> 00:12:35.440
Spotlight correctly gives me all the
documents that reference that term.

00:12:35.440 --> 00:12:39.770
But with a non-document like non-document-based
app like dictionary,

00:12:39.769 --> 00:12:45.500
it is actually giving me the matching records inside.

00:12:45.500 --> 00:12:50.200
And this is something-- well let's
take a look at another example.

00:12:50.200 --> 00:12:52.310
So if I do a Spotlight search for Malcolm,

00:12:52.309 --> 00:12:59.569
I want the results to match individual records,
and they should open up an Address Book.

00:12:59.570 --> 00:13:03.530
But it's-- it's got it to go one step further.

00:13:03.529 --> 00:13:06.139
It needs to display the matching contact.

00:13:06.139 --> 00:13:10.679
And this is what we've added in Snow Leopard with Core Data.

00:13:10.679 --> 00:13:18.389
It's a new Spotlight search integration template and it's
a better user experience for non-document-based apps.

00:13:18.389 --> 00:13:22.960
And it gives you a way to integrate
Spotlight search in way in your application

00:13:22.960 --> 00:13:26.700
that you can find and open individual records.

00:13:26.700 --> 00:13:33.320
And this is all documented in the Core Data
Spotlight Integration Programming Guide.

00:13:34.740 --> 00:13:41.000
It uses standard Spotlight APIs, you're
still doing all the same kinds of things

00:13:41.000 --> 00:13:44.340
that you would do with a document base Spotlight importer.

00:13:44.340 --> 00:13:48.759
The importer creates the index but we have
added a new Spotlight importer template

00:13:48.759 --> 00:13:51.289
for non-document-based applications.

00:13:51.289 --> 00:13:58.289
And here's another difference, this importer imports
from external record files instead of your store file.

00:13:58.289 --> 00:14:00.899
Well, what are external record files?

00:14:00.899 --> 00:14:03.039
Well this is something new that we have added.

00:14:03.039 --> 00:14:06.149
And these are managed by Core Data.

00:14:06.149 --> 00:14:09.809
Each file identifies a managed object uniquely.

00:14:09.809 --> 00:14:16.199
The property data still lives in the persistence store but
by giving this-- but by presenting external record files,

00:14:16.200 --> 00:14:21.490
it gives the Spotlight a way to track
individual records in your application.

00:14:23.149 --> 00:14:27.959
So you can create external record files in your application.

00:14:27.960 --> 00:14:30.600
To create external record files in your application,

00:14:30.600 --> 00:14:34.639
you need to specify a file extension
for the external record files.

00:14:34.639 --> 00:14:38.000
And you also need to mark properties
to be indexed in Spotlight.

00:14:38.000 --> 00:14:44.909
And this is another new thing we've added to
the Xcode design tool for your data model.

00:14:44.909 --> 00:14:49.669
There's a new checkbox you'll see,
there is also API to support this.

00:14:49.669 --> 00:14:56.909
But the easiest way's right in the Xcode design
tool, to use the checkbox, to index in Spotlight.

00:14:56.909 --> 00:15:04.309
And the part that we take care for you, I
said we managed the external record files.

00:15:04.309 --> 00:15:09.579
One, every time you save changes in your
context, we synchronize the external record files

00:15:09.580 --> 00:15:14.259
on disc with the state of your Data Store.

00:15:14.259 --> 00:15:20.049
So when you update a record, we
touch the external record file.

00:15:20.049 --> 00:15:24.629
And when you delete a record, we
delete the external record file.

00:15:24.629 --> 00:15:31.149
And this file system activity triggers the Spotlight
importer and lets the Spotlight index stay up to date

00:15:31.149 --> 00:15:34.039
and in sync with the state of your data store.

00:15:34.039 --> 00:15:40.009
So there's a new project template called
the Core Data Spotlight integration template

00:15:40.009 --> 00:15:45.639
that includes a template for non-document-based
Core Data apps.

00:15:45.639 --> 00:15:53.419
And in the new project assistant, you can see there's a
new checkbox, I selected Cocoa application to use Core Data

00:15:53.419 --> 00:15:58.110
for storage, but now I can also specify,
"I want to include the Spotlight importer."

00:15:58.110 --> 00:16:05.399
And you can see that the document-based
application is not checked.

00:16:07.669 --> 00:16:09.229
So what do you need to do?

00:16:09.230 --> 00:16:11.300
You need to customize the template code.

00:16:11.299 --> 00:16:15.149
It's just like the document-based
Spotlight importer in that way.

00:16:15.149 --> 00:16:21.220
In your importer, you want to look up their properties that
you marked in your model to index in Spotlight and then add

00:16:21.220 --> 00:16:24.660
that property data to the Spotlight index.

00:16:24.659 --> 00:16:29.620
And when you do that, you want to use the
proper metadata tags for Spotlight to be able

00:16:29.620 --> 00:16:33.679
to provide the results in the best way possible.

00:16:33.679 --> 00:16:38.769
But here's the thing, since you have accessed to the
entire store deck, external record file just tells you how

00:16:38.769 --> 00:16:44.110
to find the store file and the managed object that
you're interested in, everything is accessible.

00:16:44.110 --> 00:16:47.690
So you can pull in related data from
other objects and you're not restricted

00:16:47.690 --> 00:16:50.850
to just working with the managed object you're indexing.

00:16:50.850 --> 00:16:56.320
The other thing you need to do is take
care of displaying those search results.

00:16:56.320 --> 00:16:59.250
In a document based application, it is sort of automatic.

00:16:59.250 --> 00:17:03.799
When you open a document, your applications
are already designed to display that.

00:17:03.799 --> 00:17:08.279
But in a non-document-based application,
you're going to open external record files.

00:17:08.279 --> 00:17:15.910
So you need to register your app to open external-- the
file extension for those external record files as Core Data

00:17:15.910 --> 00:17:22.180
for the object ID from the file, and then fetch and
display the record appropriately in your interface.

00:17:22.180 --> 00:17:31.750
So this is-- we're really excited to give you a way
to achieve the same level of quality of integration

00:17:31.750 --> 00:17:35.990
with Spotlight in your non-document-based applications now.

00:17:35.990 --> 00:17:39.799
We take care of managing the tricky part
of keeping the records in sync on disc

00:17:39.799 --> 00:17:47.279
and you do basically the same job you had in
the past with the document-based application

00:17:47.279 --> 00:17:51.299
or you customize the importer and
display the records that match.

00:17:51.299 --> 00:17:58.990
Now I'd like to shift gears and
talk about fetch performance.

00:17:58.990 --> 00:18:04.839
So what are the fundamental ideas of fetch performance?

00:18:04.839 --> 00:18:08.839
You want to fetch as little as
you can, fetch only what you need.

00:18:08.839 --> 00:18:12.500
How much can you really put on screen?

00:18:12.500 --> 00:18:14.480
Think about your working set.

00:18:14.480 --> 00:18:16.500
On the iPhone, it is pretty obvious.

00:18:16.500 --> 00:18:20.200
You only have got a few records on screen at a time.

00:18:20.200 --> 00:18:26.019
And even on the desktop, it's hard to imagine the
user interface that can meaningfully show more

00:18:26.019 --> 00:18:29.019
than a few hundred records to the user at once.

00:18:29.019 --> 00:18:34.670
So the guiding philosophy here is to keep in mind
what is the size of your working set and to try

00:18:34.670 --> 00:18:37.980
and keep things trimmed down to that as much as possible.

00:18:37.980 --> 00:18:46.360
And Core Data already provides a lot of
options for dealing with a large data set.

00:18:46.359 --> 00:18:51.169
Letting you fetch less data when you're working with it.

00:18:51.170 --> 00:18:55.910
You can fetch managed objects for records
that you're actively working with.

00:18:55.910 --> 00:18:57.779
But for records, you just need a reference to.

00:18:57.779 --> 00:19:01.230
You can fetch object IDs or faults.

00:19:01.230 --> 00:19:08.269
And you can even just fetch the count when all you
need to know is the number of records that match.

00:19:08.269 --> 00:19:22.009
But what about when you're dealing with interface or UI
that wants your entire data set provided as an array?

00:19:22.009 --> 00:19:26.079
Since the user is driving the access
to that data, the access can be random

00:19:26.079 --> 00:19:29.889
and many records may not be displayed at all.

00:19:29.890 --> 00:19:36.540
So if you fetch an array of managed objects and you hand
that over, you're using up way more memory than you want to.

00:19:36.539 --> 00:19:43.930
And if you hand over an array of faults, then every record
that you access, that view accesses will trigger a fetch

00:19:43.930 --> 00:19:47.400
and a round trip to the database to fetch that data.

00:19:47.400 --> 00:19:51.840
So, on the one hand, you're using
up way more memory than you want to.

00:19:51.839 --> 00:19:57.319
On the other hand, you're incurring an awful
lot of I/O and you'll see sluggish performance.

00:19:57.319 --> 00:20:04.960
To address this, we've added a new option
to fetch request to fetch in batches

00:20:04.960 --> 00:20:13.029
And it provides random access to your data set so you're
not fetching all of your records at once and it limits--

00:20:13.029 --> 00:20:21.230
and it allows you to amortize the cost of the I/O because
every fetch to the database fetches a batch of records.

00:20:21.230 --> 00:20:33.400
>> Additionally, when you're-- when you're not
actively holding on to records in that data set,

00:20:33.400 --> 00:20:39.700
the batch fetching array can release
those records and free up those resources.

00:20:41.099 --> 00:20:48.149
And all you need to do to use it is call "setFetchBatchSize"
on your NSFetchRequest and it will return to you

00:20:48.150 --> 00:20:54.160
in auto-batching array of proxy when you do your fetch.

00:20:54.160 --> 00:21:01.670
Sometimes you need to display a large table of data but
only show a few properties like in a master/detail view.

00:21:01.670 --> 00:21:08.990
If your master view is only showing one or two
properties but your records define a lot of properties

00:21:08.990 --> 00:21:20.009
that get displayed in the detail view--
well let's take a look at an example, sorry.

00:21:20.009 --> 00:21:28.660
So you've defined your song entity here and it defines
all of the attributes that you need to keep track of.

00:21:28.660 --> 00:21:35.540
And in your master table you're only really interested
in showing two of them, the title and the rating.

00:21:35.539 --> 00:21:37.920
So to populate all of the values in that table,

00:21:37.920 --> 00:21:43.440
all you really need to do is access
those two properties off of your songs.

00:21:43.440 --> 00:21:48.490
And now you've got a way to choose
exactly the properties you want to fetch,

00:21:48.490 --> 00:21:52.120
call setPropertiesToFetch on NSFetchRequest.

00:21:52.119 --> 00:21:58.659
And when you fetch your objects, the managed objects
will be pre-populated with only those objects--

00:21:58.660 --> 00:22:02.029
only those properties that you specified.

00:22:02.029 --> 00:22:06.160
But these are full managed objects and you
get all of your business logic included.

00:22:06.160 --> 00:22:13.710
If you access properties that aren't
pre-fetched, it'll cause a fetch to go

00:22:13.710 --> 00:22:17.329
to the database to populate the remaining values.

00:22:17.329 --> 00:22:24.869
Also if you change any values on your managed object
that'll cause a fetch to fill in those values too.

00:22:24.869 --> 00:22:26.169
So that is something to be aware of.

00:22:26.170 --> 00:22:31.680
If you are using partial fetches, you
want to avoid accidentally tripping a lot

00:22:31.680 --> 00:22:37.460
of faults one after the other and burning I/O.

00:22:37.460 --> 00:22:45.430
We've also added the option in Snow Leopard
to include or bypass pending changes.

00:22:45.430 --> 00:22:48.090
This is a new fetch request option and you can--

00:22:48.089 --> 00:22:54.459
it's enabled by default, pending changes are
enabled-- are included by default when you fetch.

00:22:54.460 --> 00:22:59.220
But you can bypass them by calling
setIncludesPendingChanges no.

00:23:01.029 --> 00:23:04.750
So why would we want to include pending changes?

00:23:04.750 --> 00:23:06.440
Why would you want them?

00:23:06.440 --> 00:23:13.220
Because it gives the user a consistent view of their
unsaved data-- of the state of their unsaved data.

00:23:13.220 --> 00:23:21.660
Deleted objects will be omitted from the fetch-- from a
fetch from the database and updates an inserted object,

00:23:21.660 --> 00:23:27.470
will be reconciled, will affect of
search results when you do a search.

00:23:28.549 --> 00:23:31.690
Well, why would you want to bypass pending changes?

00:23:31.690 --> 00:23:33.470
Well, sometimes you do not want them.

00:23:33.470 --> 00:23:36.579
Maybe you just want the state of your saved data.

00:23:36.579 --> 00:23:38.679
You just want to fetch against the state of your saved data.

00:23:38.680 --> 00:23:45.120
And there are other times where you got a query that
really is tuned specifically to be executed in the database

00:23:45.119 --> 00:23:48.209
and you don't want to evaluate it in run time, in memory.

00:23:48.210 --> 00:23:54.170
Another case to be aware of is, if
you have a lot of pending changes,

00:23:54.170 --> 00:23:58.070
in-memory evaluation of a predicate can be expensive.

00:24:01.509 --> 00:24:06.519
So I've covered a few of the new fetch
options and these are advance fetch options

00:24:06.519 --> 00:24:10.829
that we've added in Snow Leopard to NSFetchRequest.

00:24:10.829 --> 00:24:22.359
And we can, you know, a couple of ways to deal with UIs and
APIs that want an entire-- your large data set all at once,

00:24:22.359 --> 00:24:30.879
and also giving you the option to bypass
unsaved changes when you do not need them.

00:24:30.880 --> 00:24:34.930
And now I would like to invite Melissa to
talk about some advance fetch techniques.

00:24:34.930 --> 00:24:35.240
[ Applause ]

00:24:35.240 --> 00:24:42.460
>> Adam's talked a lot about the new features
we have added to fetching that allow you

00:24:42.460 --> 00:24:45.210
to control the managed objects that come back.

00:24:45.210 --> 00:24:50.930
But sometimes a managed object isn't the answer
to the question you're interested in asking.

00:24:50.930 --> 00:24:53.660
Sometimes you actually want different data back.

00:24:53.660 --> 00:24:56.750
Sometimes you want an aggregate value.

00:24:56.750 --> 00:24:59.099
Sometimes you want a collection of distinct values.

00:24:59.099 --> 00:25:00.879
These aren't managed objects.

00:25:00.880 --> 00:25:06.350
What you really want is something that will
let simple queries return simple values.

00:25:06.349 --> 00:25:09.969
For those of you who've tried to do
this in previous versions of Core Data,

00:25:09.970 --> 00:25:15.940
you know that the way you get an aggregate is to load
all of the objects that have a value that is part

00:25:15.940 --> 00:25:18.250
of the aggregate value you're interested in.

00:25:18.250 --> 00:25:23.049
Iterate it through each of those objects,
retrieve the piece of data you want,

00:25:23.049 --> 00:25:26.659
do whatever calculations you need, and then use the results.

00:25:26.660 --> 00:25:32.050
Similarly, if you want distinct values you would
load all of the objects, iterate through them,

00:25:32.049 --> 00:25:37.490
pull out the piece of value-- the piece of data
you want, drop it into a set, return the set,

00:25:37.490 --> 00:25:41.700
and release the managed object collection.

00:25:41.700 --> 00:25:50.860
Now we've given you a way to load only the specific
data you want to do data aggregation in the database

00:25:50.859 --> 00:25:53.250
to just get distinct values back from the database.

00:25:53.250 --> 00:25:57.180
And to get those results back as
dictionaries instead of managed objects.

00:25:57.180 --> 00:26:00.799
What can you get back?

00:26:00.799 --> 00:26:03.909
Well, we were trying to flat [phonetic] dictionary.

00:26:03.910 --> 00:26:08.029
A key value pair allows you to
specify what you want whatever you--

00:26:08.029 --> 00:26:12.379
are getting back to be called and a value and its value.

00:26:12.380 --> 00:26:20.240
An NS value, a number, a string, a date, an
NS data, and get back object IDs, if you want.

00:26:20.240 --> 00:26:24.819
But you can't get back our collections,
no too many relationships.

00:26:24.819 --> 00:26:28.419
How do you do it?

00:26:28.420 --> 00:26:30.279
It's actually pretty simple.

00:26:30.279 --> 00:26:33.339
We've added a new class, NSExpressionDescription.

00:26:33.339 --> 00:26:40.919
As you might guess, it's part of the model description
classes and what this does is encapsulate description

00:26:40.920 --> 00:26:43.769
of the data you want back from the database.

00:26:43.769 --> 00:26:46.639
You create an NSExpressionDescription, you give it a name,

00:26:46.640 --> 00:26:49.790
that is the key we will use in
the dictionary we're returning.

00:26:49.789 --> 00:26:55.129
We give an expression-- an expression resultType
which describes the data type that's coming back

00:26:55.130 --> 00:26:58.950
from the database, so we know what
we're expecting to pull out of SQLite.

00:26:58.950 --> 00:27:03.240
And you give it an expression describing
the data you want back.

00:27:03.240 --> 00:27:08.809
We support most of the same NSExpression types that
are supported in predicates passed to the store.

00:27:08.809 --> 00:27:15.099
And I should say at this point that this-- the read-only
oata feature is primarily centered on the SQL store

00:27:15.099 --> 00:27:18.730
because all of our other stores
do not really know how to do--

00:27:18.730 --> 00:27:24.349
quickly do distinct or aggregate
type calculations in the database.

00:27:24.349 --> 00:27:27.169
Once you go out NSExpressionDescription,
what do you with it?

00:27:27.170 --> 00:27:30.779
Well that again is pretty simple,
you pass it to NSFetchRequest.

00:27:30.779 --> 00:27:41.889
Adam talked earlier about the propertiesToFetch API that
we've added to fetch request and that's reused here.

00:27:41.890 --> 00:27:48.770
You take your NSExpressionDescriptions, collect them
all up and pass them as an array to propertiesToFetch.

00:27:48.769 --> 00:27:54.099
We have added new resultType and NSdictionary
resultType that says, you want whatever is coming back

00:27:54.099 --> 00:27:56.669
as dictionaries instead of managed objects.

00:27:56.670 --> 00:28:01.519
And optionally, we have added an API,
returnsDistinctResults, which will tell--

00:28:01.519 --> 00:28:06.049
which will specify whether what you want back
is a collection of distinct results or not.

00:28:06.049 --> 00:28:14.369
And because everything seems hard until you see it in code,

00:28:14.369 --> 00:28:18.239
except sometimes the code itself
looks hard, we've added an example.

00:28:18.240 --> 00:28:21.539
Here you can see us doing aggregate fetch.

00:28:21.539 --> 00:28:31.289
We create up top an NSExpression and it is an
expression that says, "I want the sum of the values

00:28:31.289 --> 00:28:33.500
in the key-- at the key path of duration."

00:28:33.500 --> 00:28:38.019
Using that expression we can create
an ExpressionDescription.

00:28:38.019 --> 00:28:41.539
We set its name to total time.

00:28:41.539 --> 00:28:48.190
We set it-- the expressions the one we created in
the first step, and we set the expression resultType

00:28:48.190 --> 00:28:53.200
to NSDecimalAttributeType, 'cause well,
we expect the duration to come back

00:28:53.200 --> 00:28:58.450
as some number of minutes plus some number of seconds.

00:28:58.450 --> 00:29:08.029
Then we take the ExpressionDescription we created, pass
it to NSFetchRequest that created somewhere off screen.

00:29:08.029 --> 00:29:13.099
Set its propertiesToFetch to that array and
set the resultType to NSDictionaryResultType.

00:29:13.099 --> 00:29:19.219
We then call ExecuteFetchRequest on a ManagedObjectContext
and we get back something that looks likes this.

00:29:19.220 --> 00:29:25.120
It's a dictionary with one value in it, a total time.

00:29:25.119 --> 00:29:29.989
Similarly-- oh, and to save you having to scribble
that down or reverse engineer it yourself,

00:29:29.990 --> 00:29:34.970
we've actually associated a sample with this
particular session, it is called "Read-Only Core Data."

00:29:34.970 --> 00:29:41.880
If you go look at it, it'll give you examples of how
to use the various features of the read-only fetching.

00:29:41.880 --> 00:29:46.170
Another example that is also in there is distinct values.

00:29:46.170 --> 00:29:49.789
This is how you create or fetch, returns distinct values.

00:29:49.789 --> 00:29:56.569
In this case, we want distinct values, a title and
create an expression, keep out the expression for title.

00:29:56.569 --> 00:30:03.059
We create an ExpressionDescription, in this case, we're
just going to use title as the name, set the expression,

00:30:03.059 --> 00:30:08.279
set the resultType to NSStringAttributeType
because titles are strings.

00:30:08.279 --> 00:30:14.649
Create our array and set the propertiesToFetch,
set the resultType and say,

00:30:14.650 --> 00:30:19.150
we want distinct results, distinct results yes.

00:30:19.150 --> 00:30:26.380
>> And again, there's an example of how to
do this in the read-only Core Data sample.

00:30:26.380 --> 00:30:34.560
We've also expanded the variety of predicates
that supported in Core Data in Snow Leopard.

00:30:34.559 --> 00:30:40.359
That it supports for KVC operators, or at least
the ones that makes sense in an SQL database.

00:30:40.359 --> 00:30:44.939
Min, max, sum, count, average those are all there now.

00:30:44.940 --> 00:30:51.110
We have added support for functions, do you
need to do math in the database for some reason?

00:30:51.109 --> 00:30:52.750
Do you need min, max, average, sum?

00:30:52.750 --> 00:30:57.460
Do you want upper case or lower case
strings as you're doing comparisons?

00:30:57.460 --> 00:31:04.500
There is more function as well, see
the NSExpression.h header for that.

00:31:04.500 --> 00:31:07.369
We've added a couple new string
comparison flags in the parser.

00:31:07.369 --> 00:31:11.659
We've added an "n" for normalized, what does this mean?

00:31:11.660 --> 00:31:16.630
Well, if you're familiar with doing string
searching and string comparisons in the database,

00:31:16.630 --> 00:31:19.390
you'll know that well, string comparison is expensive.

00:31:19.390 --> 00:31:24.530
And the common technique that we've talked about
in previous years, and it's common on the web,

00:31:24.529 --> 00:31:29.450
is that you want to normalize or pre-process all
of your strings before you pass them into database.

00:31:29.450 --> 00:31:36.650
Strip out diacritics, strip out any case, stuff,
do whatever you want to get it into canonical form.

00:31:36.650 --> 00:31:40.920
If you use the "n" string flag when you're doing--

00:31:40.920 --> 00:31:45.240
creating a predicate that specifies that
whatever you've got is canonicalized

00:31:45.240 --> 00:31:47.539
and that we do not need to do any string processing on it.

00:31:47.539 --> 00:31:50.889
We can treat it as a large bag of
bytes and just compare the bytes.

00:31:50.890 --> 00:31:53.400
It is much faster to do this.

00:31:53.400 --> 00:31:58.160
We do not have to do any of the calculations
and computations that come along with Unicode.

00:31:58.160 --> 00:32:04.790
We have also added a flag "l" for doing
well locale-sensitive comparisons.

00:32:04.789 --> 00:32:10.649
And in addition, we've added support
for the various string-comparison flags

00:32:10.650 --> 00:32:13.530
to the equality and inequality operators.

00:32:16.509 --> 00:32:20.039
And this is stuff-- all the stuff
we've done make a difference?

00:32:20.039 --> 00:32:25.740
Well, it's easy to say it, so we'll also going to show it.

00:32:25.740 --> 00:32:32.309
Like I said, we've got a pretty simple
demo application, has a table view up top

00:32:32.309 --> 00:32:36.139
that has bunch of songs and their ratings.

00:32:36.140 --> 00:32:43.340
Under that, it's got some aggregate information about
the songs, the song account min/max ratings, average.

00:32:43.339 --> 00:32:49.069
All the average really tells me is that my random number
generator did a good job of generating random numbers.

00:32:49.069 --> 00:32:54.159
And down here we've got a detail view that shows
information about the song that's selected.

00:32:54.160 --> 00:33:01.779
So I'm going to have a look at that in
instruments and see what there is to see.

00:33:01.779 --> 00:33:07.750
You know, once a very long time ago, we had to do stuff
like this using FS usage and that was kind of a pain.

00:33:07.750 --> 00:33:13.440
And then we added logging code and this-- the
logging debug features Adam talked about earlier

00:33:13.440 --> 00:33:18.380
And now, we have instruments which really rocks and I
highly suggest you use it because it is the best way

00:33:18.380 --> 00:33:20.460
to discover what your application is doing.

00:33:20.460 --> 00:33:25.180
So I'm going to create an instrument, a new
document using the object alloc instrument.

00:33:25.180 --> 00:33:31.360
I'm going to add in Core Data fetches
and Core Data cache misses instruments,

00:33:31.359 --> 00:33:36.079
because this is what we're interested in looking at.

00:33:36.079 --> 00:33:40.169
I'm going to say that we should launch
my demo executable, I'm going to run it,

00:33:40.170 --> 00:33:43.310
and for some reasons it's going
to pop out behind the instrument.

00:33:43.309 --> 00:33:50.450
I'm going to scroll down and click on that-click
on a row and click on a row and click on row.

00:33:50.450 --> 00:33:51.650
That should be all we really need to do.

00:33:51.650 --> 00:34:00.720
And down here, I have another instrument that I got preset
up that's the same application running with the same values.

00:34:00.720 --> 00:34:04.140
Only it has a command line parameter
saying, "Use the Snow Leopard features."

00:34:04.140 --> 00:34:10.250
And the same-- I'm going to do the same thing here, I
am going to scroll down, click on a row, scroll down,

00:34:10.250 --> 00:34:15.829
click on arrow, scroll down, click on a row and click.

00:34:15.829 --> 00:34:18.069
Well, what can we see here?

00:34:18.070 --> 00:34:19.800
Let's go have a look.

00:34:25.110 --> 00:34:32.320
If we first look at the object alloc instrument,
we can see down here that the number of live bytes,

00:34:32.320 --> 00:34:35.550
well, we got-- how about 5 meg of live memory.

00:34:35.550 --> 00:34:37.380
So what do we have over here?

00:34:37.380 --> 00:34:40.450
Oh, darn it.

00:34:40.449 --> 00:34:44.009
I think I messed something up.

00:34:44.010 --> 00:34:49.780
[ Pause ]

00:34:49.780 --> 00:34:51.490
>> Well, that did not quite work.

00:34:51.489 --> 00:34:54.849
But we can see is we turn through a lot less overall memory.

00:34:54.849 --> 00:34:57.239
Demos, they're evil.

00:34:57.239 --> 00:35:01.059
You can see that we did the same number of fetches.

00:35:01.059 --> 00:35:04.659
Wait a second.

00:35:04.659 --> 00:35:09.440
That would be what's wrong.

00:35:09.440 --> 00:35:14.480
Instrument is helping me when I don't want help.

00:35:14.480 --> 00:35:18.010
Let's try that again.

00:35:18.010 --> 00:35:25.810
[ Pause ]

00:35:25.809 --> 00:35:26.739
>> Ah-hah!

00:35:26.739 --> 00:35:30.149
That looks better.

00:35:30.150 --> 00:35:39.329
So, here we can see the application without the Snow Leopard
features is using 8.5 megabytes worth of live memory.

00:35:39.329 --> 00:35:45.369
Well with partial faulting and using aggregates to get
our values come back, we can see it's only using 5 meg.

00:35:45.369 --> 00:35:49.329
So that's a pretty significant and hefty
chunk of memory that you're saving there.

00:35:49.329 --> 00:35:52.809
And that's really important especially in a
device, there's resource constrains of the iPhone.

00:35:52.809 --> 00:35:57.920
You can also see that the overall bytes we've
used in the original application running

00:35:57.920 --> 00:36:00.930
without the Snow Leopard features is close to 40 meg.

00:36:00.929 --> 00:36:03.230
We've used 25 percent less.

00:36:03.230 --> 00:36:04.829
Again, that's kind of important.

00:36:04.829 --> 00:36:06.389
That means, less banging on mallet blocks [phonetic].

00:36:06.389 --> 00:36:16.469
If we look at the fetch instrument, we can see that
in the original application, I did four fetches,

00:36:16.469 --> 00:36:19.649
each one of which ended up bringing back
a whole lot of objects from the database

00:36:19.650 --> 00:36:22.789
that I had to iterate through and pull values from.

00:36:22.789 --> 00:36:25.019
If we go look at the fetch instruments over here, well,

00:36:25.019 --> 00:36:29.039
I only have one of those mass [phonetic]
fetches and that was to populate the table.

00:36:29.039 --> 00:36:34.340
The other ones only brought one
back-- only brought one value back.

00:36:35.730 --> 00:36:44.539
Conversely, if I look at the cache misses instrument, I
can see that the types of objects that were brought back

00:36:44.539 --> 00:36:50.860
in the first, I was only having to go to the
database to get albums, artists and genres.

00:36:50.860 --> 00:36:56.920
That's because those are relationships of the
tracks that are being displayed in the table view.

00:36:56.920 --> 00:37:01.780
And-- but if I go over here and
look at what I was fetching here,

00:37:01.780 --> 00:37:05.019
I can see I'm also fetching albums and artist and genre.

00:37:05.019 --> 00:37:10.000
But I am also fetching tracks and that's
because I was using partial faulting.

00:37:10.000 --> 00:37:15.789
And when ever I clicked on a row in the database, whenever
a row became selected, I had to go to the database

00:37:15.789 --> 00:37:19.400
to get the information that was not
being displayed in the table view,

00:37:19.400 --> 00:37:26.960
so the balance there between memory
performance, CPU performance, I/O performance.

00:37:31.010 --> 00:37:36.470
And that's a balance that everybody is going to have
to decide what's best for their particular application.

00:37:36.469 --> 00:37:37.809
We can't give you an answer.

00:37:37.809 --> 00:37:45.269
We hope we can give you tools to help you more easily
configure your application in the ways that are best

00:37:45.269 --> 00:37:48.239
for your application and for your dataset.

00:37:48.239 --> 00:37:52.129
And this is where I show for bugreporter.apple.com.

00:37:52.130 --> 00:37:58.240
We gathered some miscellaneous APIs in Snow Leopard
and this is all been stuff that people have asked for.

00:37:58.239 --> 00:38:00.469
You ask. We achieve.

00:38:00.469 --> 00:38:03.909
We've added a new method prepareForDeletion
to NSManagedObject,

00:38:03.909 --> 00:38:09.089
this is called "front lead object" immediately
before an object is going to be deleted.

00:38:09.090 --> 00:38:14.620
This allows you to nuke caches, do any clean up that
you want to do before an object becomes deleted.

00:38:14.619 --> 00:38:17.279
We've also added awakeFromSnapshotEvents.

00:38:17.280 --> 00:38:22.350
A Snapshot event is essentially an undo or redo
and this notifies your object, it's a call back,

00:38:22.349 --> 00:38:28.199
it notifies your object that it's been--
it's participated in an undo or redo.

00:38:28.199 --> 00:38:33.299
And that if you've got caches that were calculated
those caches and it may now be out of date, or you know,

00:38:33.300 --> 00:38:38.480
you may want to grab resources that you released as
a result of something else that you now need again.

00:38:38.480 --> 00:38:38.829
[ Applause ]

00:38:38.829 --> 00:38:45.099
>> We have added a couple of new
features to NSManageObjectContext.

00:38:45.099 --> 00:38:48.130
Context should ignore un-modeled property changes.

00:38:48.130 --> 00:38:52.410
My, that's an awful long method name but it does
pretty much exactly what it says it's going to do.

00:38:52.409 --> 00:39:00.940
It tells the context that if a property is not in the
managed object model, don't mark the context as dirty

00:39:00.940 --> 00:39:04.700
as a result of any changes made to that property.

00:39:05.860 --> 00:39:09.289
[Applause] See, like I said people asked for it.

00:39:09.289 --> 00:39:16.650
This allows you in a document-based application to set
up caches and transient relationships or what have you

00:39:16.650 --> 00:39:22.119
at document open time without having
the document mark itself as dirty.

00:39:22.119 --> 00:39:25.549
We've also added an existing object with ID API.

00:39:25.550 --> 00:39:29.630
You pass this to Managed Object ID and
it will return an object to a fault

00:39:29.630 --> 00:39:31.369
if one exists in the Managed Object Context.

00:39:31.369 --> 00:39:35.420
And it was-- return nothing if it hasn't yet been loaded.

00:39:35.420 --> 00:39:37.260
There may still be an object in the database.

00:39:37.260 --> 00:39:42.320
You just won't get a pointer to it back because
you asked if there was one existing in the context.

00:39:42.320 --> 00:39:51.590
And that's pretty much it for what I'm going to
talk to-- talk about for Core Data and Snow Leopard.

00:39:51.590 --> 00:39:55.610
But other people have also been doing a lot of interesting
stuff in Snow Leopard and we'd want to talk a little bit

00:39:55.610 --> 00:40:00.760
about how to integrate Core Data with some of
the things other people would have done in 10.6.

00:40:00.760 --> 00:40:04.930
And first thing we're going to talk
about is Grand Central Dispatch.

00:40:04.929 --> 00:40:12.599
This is a really cool technology, makes
threading a lot easier, 'cause threading is kind

00:40:12.599 --> 00:40:16.819
of a pain as anybody who's ever done it knows.

00:40:16.820 --> 00:40:21.390
>> Techniques we're going to talk about also apply to
Leopard if you're using NSOperation because NSOperation

00:40:21.389 --> 00:40:24.589
and NSOperationQueue first appeared in Leopard

00:40:24.590 --> 00:40:31.309
And actually, I believe we're the inspiration
for libdispatch which showed up in Snow Leopard.

00:40:31.309 --> 00:40:38.980
It allows you to pass tasks off to work queues that handle
all the nasty details of threading behind your back

00:40:38.980 --> 00:40:43.869
It supports serial or concurrent queues
and what you do is you submit a block,

00:40:43.869 --> 00:40:47.650
new objective C2.0 feature, blocks for execution.

00:40:47.650 --> 00:40:52.849
And at some future point, that block will be executed.

00:40:55.269 --> 00:41:01.590
There is one and only one Core Data approved
technique for doing this and that's thread confinement.

00:41:01.590 --> 00:41:06.440
In threaded code, that means that every
thread gets its own Managed Object Context.

00:41:06.440 --> 00:41:11.579
In GCD, it means anything that might execute
concurrently gets its own Managed Object Context.

00:41:11.579 --> 00:41:14.739
And if you need to communicate between threads of operation,

00:41:14.739 --> 00:41:19.809
you need to pass object IDs back
and forth between the threads.

00:41:19.809 --> 00:41:22.119
Visually, it looks a lot like this.

00:41:22.119 --> 00:41:27.389
You can see here, we have a couple of serial
queues and all the tasks blocks that are

00:41:27.389 --> 00:41:31.960
on queue 1 are using Managed Object Context 1.

00:41:31.960 --> 00:41:38.579
But a block that is on queue 2, since it offer-- can be
evaluated concurrently with any of the blocks that are

00:41:38.579 --> 00:41:43.610
on queue 1 has its own Managed Object
Context, Manage Object Context 2.

00:41:43.610 --> 00:41:52.160
Going further, if we have a concurrent queue to this,
you can see that all blocks on a concurrent queue need

00:41:52.159 --> 00:41:59.799
to have their own Managed Object Context because those could
be evaluated concurrently with each other or concurrently

00:41:59.800 --> 00:42:03.480
with whatever is on one of the serial queues.

00:42:04.670 --> 00:42:11.650
Everybody's life gets easier if anything that connects
queue concurrently is in its own-- has its own context.

00:42:11.650 --> 00:42:17.650
And you don't need to lock, it means you do
not get bizarre threading errors, just do this.

00:42:17.650 --> 00:42:24.970
And because it's tricky, and because everybody makes
mistakes and that includes us, we have a set of assertions

00:42:24.969 --> 00:42:29.189
that can be enabled using com.apple.CoreData.ThreadingDebug
3.

00:42:29.190 --> 00:42:35.740
This will bring your application to an immediate and abrupt
halt if any of the threading assumptions are violated.

00:42:35.739 --> 00:42:39.699
It will be usable in a debug version of
the framework which should be downloadable

00:42:39.699 --> 00:42:44.079
from ADC shortly after Snow Leopard goes jammed.

00:42:46.670 --> 00:42:52.130
And if you want to integrate with Instant Off,
which is another new feature that's been added

00:42:52.130 --> 00:42:59.619
in Snow Leopard hasChanges on NSManagedObjectContext is
now observable for the specific purposes of Instant Off.

00:42:59.619 --> 00:43:04.359
It is very important that you not change the object
graph if you are observing it for the purpose

00:43:04.360 --> 00:43:06.710
of Instant Off, or if you're just cheating.

00:43:06.710 --> 00:43:12.490
Because who knows what's going to happen if you try and
notify your object graph while handing a notification

00:43:12.489 --> 00:43:15.719
that resulted from the object graph being notified.

00:43:15.719 --> 00:43:17.829
We make no guarantees.

00:43:17.829 --> 00:43:18.549
You may succeed.

00:43:18.550 --> 00:43:20.289
You may hurt yourself.

00:43:20.289 --> 00:43:26.230
If you need to change the object graph, you need to save or
something like that, you can call performSelectorAfterDelay

00:43:26.230 --> 00:43:31.670
or one of its associated methods
and sending a delay of zero.

00:43:31.670 --> 00:43:39.360
This is a special number used to indicate that it
needs to happen during the Instant Off context.

00:43:39.360 --> 00:43:44.670
So we're hoping you'll take away from this session
is knowledge of the new features that we've added

00:43:44.670 --> 00:43:46.889
to Snow Leopard and sort of a sense
of how you might use them

00:43:46.889 --> 00:43:50.460
in your application, what problems
they're intended to solve.

00:43:50.460 --> 00:43:55.530
Some best practices for using Core
Data and for interacting with--

00:43:55.530 --> 00:43:58.530
having Core Data interact with some of
the other technologies in Snow Leopard.

00:43:58.530 --> 00:44:04.140
And some techniques like the Spotlight
integration and the migration--

00:44:04.139 --> 00:44:07.289
the lightweight migration that will help
you accelerate your development cycle.

00:44:07.289 --> 00:44:10.880
Make it easier for you to get your
apps out to your customers earlier.

00:44:10.880 --> 00:44:14.980
If you got any comments, compliments,
questions you can ask Michael Jurewitz

00:44:14.980 --> 00:44:17.809
who is our Evangelist, whose email is up on the screen.

00:44:17.809 --> 00:44:21.480
We have lots and lots of documentation for you.

00:44:21.480 --> 00:44:26.889
Starting point-- my favorite starting point
is the framework overview page, that's a URL.

00:44:26.889 --> 00:44:31.449
I'm sure you can find it by googling for Core Data.

00:44:31.449 --> 00:44:32.169
Let's see.

00:44:32.170 --> 00:44:38.119
If you have an issue bugreport.apple.com, this is the
only way you can know-- we can know what we think.

00:44:38.119 --> 00:44:44.250
As I said, we added the new-- 11 of the new features as
a result of customer demand and it came through this.

00:44:44.250 --> 00:44:49.030
So if there's something you want to see, there
is something you think we are doing wrong,

00:44:49.030 --> 00:44:53.260
just a new feature that you think would make your
life and everybody else's life easier, let us know.

00:44:53.260 --> 00:44:53.380
1
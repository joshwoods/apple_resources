WEBVTT

00:00:12.830 --> 00:00:15.720
>>Well, good afternoon everybody and welcome back.

00:00:15.720 --> 00:00:19.179
My name is Allan Schaffer, I'm Apple's Graphics Evangelist.

00:00:19.179 --> 00:00:24.899
I'm going to continue on with Part 2 of our
discussion of Game Development for iPhone.

00:00:24.899 --> 00:00:27.039
How many of you were here for the morning sessions?

00:00:27.039 --> 00:00:28.669
Just show of hands.

00:00:28.670 --> 00:00:31.560
Wow! OK, so just about everybody.

00:00:31.559 --> 00:00:32.909
I can just kind of recap.

00:00:32.909 --> 00:00:40.689
In the morning session I talked about OpenGL for graphics
and we went through several of the I/O APIs, OpenAL,

00:00:40.689 --> 00:00:45.030
iPod Library Access, and a brief
mention of the Audio Session API.

00:00:45.030 --> 00:00:48.710
So here for Part 2, I'm actually
just going to dive straight in.

00:00:48.710 --> 00:00:50.630
We're covering 3 topics here.

00:00:50.630 --> 00:00:56.590
The first is peer to peer connectivity then I'm going
to go into some material that is very important for you

00:00:56.590 --> 00:01:00.609
to get right if you're using the
accelerometer, so we'll take about 20 minutes

00:01:00.609 --> 00:01:03.159
for that, and then finally in-app purchase.

00:01:03.159 --> 00:01:05.280
So let's just dive straight in.

00:01:05.280 --> 00:01:06.599
Welcome back.

00:01:06.599 --> 00:01:10.169
So first with peer-to-peer connectivity.

00:01:10.170 --> 00:01:16.760
So the Game Kit framework is a high-level API to
help you support network gaming in your application.

00:01:16.760 --> 00:01:18.910
And there are 3 components to this API.

00:01:18.909 --> 00:01:26.269
The first is the Session part of the API, and this handles
data communication over Bluetooth with another device,

00:01:26.269 --> 00:01:31.420
with no pairing needed, which is great because if you
think about having to pair with another device just

00:01:31.420 --> 00:01:37.260
to play a game, that would really complicate some
of the initiation of the game play experience.

00:01:37.260 --> 00:01:39.690
And the second part is a Peer Picker.

00:01:39.689 --> 00:01:46.939
So we provide you with some built-in user interface to
help you discover other players on the Bluetooth network

00:01:46.939 --> 00:01:49.620
and look or-- on the online network as well.

00:01:49.620 --> 00:01:51.990
And so, and help you to connect with them.

00:01:51.989 --> 00:01:55.149
Pick a player who you're going
to play with and begin the game

00:01:55.150 --> 00:02:03.320
And then the third component is In-Game Voice for voice
chat over the online network, so over the Internet.

00:02:03.319 --> 00:02:10.289
And you will use your own connection to set this up and
then I'll show you some of the details about how this works.

00:02:10.289 --> 00:02:16.639
So for the beginning part of this talk, I'm going to
focus on using the Session API along with the Peer Picker

00:02:16.639 --> 00:02:19.479
for a fairly specific idea that we want

00:02:19.479 --> 00:02:25.199
to initiate a head-to-head communication
with one other device using these APIs.

00:02:25.199 --> 00:02:29.669
So let's dive in and just first a
brief mention about the session API.

00:02:29.669 --> 00:02:35.289
So the GKSession object is what provides you with
the connection and handles the data communication

00:02:35.289 --> 00:02:38.859
between the 2 instances of your
app running on these 2 devices.

00:02:38.860 --> 00:02:40.970
It handles sending and receiving the data.

00:02:40.969 --> 00:02:45.750
It can be set up in either a topology
of client/server or peer-to-peer.

00:02:45.750 --> 00:02:52.500
The session object is going to be tracking the state
of the connection during the lifetime of the game.

00:02:52.500 --> 00:02:57.849
And the entire implementation is
actually an Objective-C encapsulation

00:02:57.849 --> 00:03:02.449
of the networking functionality
provided by Bonjour over Bluetooth.

00:03:02.449 --> 00:03:09.599
And so, some really robust functionality, and this is
how you're able to very easily discover other players

00:03:09.599 --> 00:03:15.189
because of the Bluetooth functional-- or
excuse me, the Bonjour functionality built in.

00:03:15.189 --> 00:03:19.329
So, we're going to use the Session
API in this instance along

00:03:19.330 --> 00:03:23.010
with the PeerPickerController to initiate the game play.

00:03:23.009 --> 00:03:27.449
And so these are just a few of the screens that
you'll see as you're going through that process.

00:03:27.449 --> 00:03:31.829
But let me walk through just an example scenario here.

00:03:31.830 --> 00:03:38.430
So we have, say, a dungeon-themed game and you
have your Single Player Mode with the play,

00:03:38.430 --> 00:03:41.879
you also have a Challenge Mode where
you can connect with another player

00:03:41.879 --> 00:03:46.039
and play head-to-head as you go
through this dungeon campaign.

00:03:46.039 --> 00:03:50.729
Now, there are a couple of different options
that the Peer Picker can support for you.

00:03:50.729 --> 00:03:54.849
The first is whether you want to
have this game happen online,

00:03:54.849 --> 00:03:58.789
over the Internet, or locally, nearby over Bluetooth.

00:03:58.789 --> 00:04:05.789
If you select online, then actually you take over the
connection and the networking code from that point.

00:04:05.789 --> 00:04:13.840
You'll dismiss this Picker API and, excuse me, this user
interface and handle all the progression from there.

00:04:13.840 --> 00:04:20.319
But let's say that you picked the Nearby
Option for Bluetooth functionality.

00:04:20.319 --> 00:04:25.519
OK, so the first thing that might happen is that if
you don't have Bluetooth turned on in your phone,

00:04:25.519 --> 00:04:31.839
it will actually present to you a dialogue
here which will allow you to enable Bluetooth.

00:04:31.839 --> 00:04:32.979
So, this is great.

00:04:32.980 --> 00:04:38.100
Just think about the fact that you're able to stay in
your game, you don't have to pop back out of your game,

00:04:38.100 --> 00:04:44.570
go to the Settings, go through that and enable Bluetooth
to-- and then come back into the game to restart again.

00:04:44.569 --> 00:04:49.040
You can handle all of that directly
through the Peer Picker UI.

00:04:49.040 --> 00:04:56.590
So then once we have or assuming we have Bluetooth turned
on or after you've turned it on with that interface,

00:04:56.589 --> 00:05:03.649
now the device is going to use the Bonjour stack to
start discovering other devices that are nearby you.

00:05:03.649 --> 00:05:08.199
And if we have another player who is
also running a copy of your application,

00:05:08.199 --> 00:05:10.009
they might-- they'll be doing the same thing.

00:05:10.009 --> 00:05:15.599
And now these 2 devices can discover each other
and you'll be presented with a control here

00:05:15.600 --> 00:05:17.629
that lets you choose a player to play with.

00:05:17.629 --> 00:05:22.089
So on the left that person John
is going to see Jane's iPhone.

00:05:22.089 --> 00:05:25.629
Over here on the right, Jane is going to see John's iPhone.

00:05:25.629 --> 00:05:29.310
And let's say that John over there selects Jane.

00:05:29.310 --> 00:05:34.750
OK. So he will be waiting now for
Jane to respond and Jane is going--

00:05:34.750 --> 00:05:41.379
Jane's instance of the application is going to show this
dialogue saying that John's iPhone would like to connect

00:05:41.379 --> 00:05:45.209
and she can either accept or decline that connection.

00:05:45.209 --> 00:05:54.310
If she accepts then great, you're connected, and you can now
start the head-to-head game play within your application.

00:05:54.310 --> 00:05:59.780
So now, let's walk through a bit of the actual
code, the steps that you'll use and the code

00:05:59.779 --> 00:06:02.250
that you'll write to actually make this happen.

00:06:02.250 --> 00:06:06.970
There are 5 major steps that you need
to go through to set up this connection.

00:06:06.970 --> 00:06:12.420
And the first is to just configure and present
that UI control that I just showed you.

00:06:12.420 --> 00:06:20.220
Then secondly, the Peer Picker actually depends on you
to provide to it a Session Object which it will use then

00:06:20.220 --> 00:06:25.120
to discover the other players and initiate the game play.

00:06:25.120 --> 00:06:33.120
And the method that you'll implement there is
peerPickerController:sessionForConnectionType:.

00:06:33.120 --> 00:06:38.879
The third part here, all right, so now we have
to handle the cases where the user actually wants

00:06:38.879 --> 00:06:41.199
to either connect or when they cancel out.

00:06:41.199 --> 00:06:43.979
And so there are 2 delegate methods
here that you'll implement.

00:06:43.980 --> 00:06:48.870
peerPickerController:didConnectPeer:toSession:
or peerPickerController:didCancel:.

00:06:48.870 --> 00:06:53.720
OK. So now we're connected and we
have to actually exchange data.

00:06:53.720 --> 00:06:59.760
So we'll implement the methods on the
Session Object to send and receive data.

00:06:59.759 --> 00:07:04.560
So that's, you'll write a method to send data
and then you'll also have a delegate method

00:07:04.560 --> 00:07:08.670
that will be invoked when you receive data from the network.

00:07:08.670 --> 00:07:14.490
And then finally, you'll have to handle GKSession state
changes for when, for example, the other player disconnects

00:07:14.490 --> 00:07:18.730
from you, and so you'll implement
session:peer:didChangeState:.

00:07:18.730 --> 00:07:23.819
Now, I'm going to walk through some code here, but before
I do and just like I mentioned in the first session,

00:07:23.819 --> 00:07:30.709
all of this code is available to you in samples that are
online either on the main iPhone Dev Center or associated

00:07:30.709 --> 00:07:35.849
with sessions here at-- on the attendee
website for WWC, so don't worry about trying

00:07:35.850 --> 00:07:38.550
to write all these code down, you
can just go and download it later.

00:07:38.550 --> 00:07:42.430
But watch the progression that we walked through here.

00:07:42.430 --> 00:07:45.900
So OK, so first we're going to
present that PeerPickerController.

00:07:45.899 --> 00:07:54.209
So it's a simple alloc init and we set a delegate that
is going to then receive those other delegate methods

00:07:54.209 --> 00:07:57.009
like to ask for a session object and so on.

00:07:57.009 --> 00:08:01.610
Now in this instance, I'm requesting
to only support nearby connections.

00:08:01.610 --> 00:08:05.840
So in this particular scenario that I'm
showing you is just for that case again

00:08:05.839 --> 00:08:08.719
of a head-to-head game being played over Bluetooth.

00:08:08.720 --> 00:08:10.620
And then we show the picker to the user.

00:08:10.620 --> 00:08:12.730
All right.

00:08:12.730 --> 00:08:22.080
The second part now, as I mentioned, the picker actually
requires for you to provide it with a session to handle all

00:08:22.079 --> 00:08:29.430
of the discovery, and it'll use that later also
for all of the different state for the connection.

00:08:29.430 --> 00:08:33.649
So here we implement
peerPickerController:sessionForConnectionType:

00:08:33.649 --> 00:08:36.250
and we'll create a Session Object.

00:08:36.250 --> 00:08:40.159
So creating the Session Object, there
are a few different parts of this.

00:08:40.159 --> 00:08:47.350
The first is the SessionID and this can be an
arbitrary string that's specific to your application

00:08:47.350 --> 00:08:54.129
or what we actually recommend is that that be a registered
Bonjour service type; and if you want to set that up,

00:08:54.129 --> 00:08:59.960
you can just visit this website here
down below to register your protocol.

00:08:59.960 --> 00:09:02.009
The second element here, display name.

00:09:02.009 --> 00:09:07.840
So by default, the Session API would
just use the name of your device:

00:09:07.840 --> 00:09:11.040
Allan's iPhone, Jane's iPhone, John's iPhone, and so on.

00:09:11.039 --> 00:09:13.860
But if you have some kind of in-game handle,

00:09:13.860 --> 00:09:18.840
you can actually have that be what's presented
to the other user by specifying it here.

00:09:18.840 --> 00:09:23.519
And then third, the Session Mode.

00:09:23.519 --> 00:09:28.740
So the PeerPickerController only
supports the peer-to-peer connections,

00:09:28.740 --> 00:09:33.980
like if you were using the Session API directly,
there would be other options for you here as well.

00:09:33.980 --> 00:09:37.920
Then we release the session and
now it's-- we're ready to go.

00:09:37.919 --> 00:09:44.129
So at that point in that-- remember the earlier
sequence, at that point now the session is going

00:09:44.129 --> 00:09:47.090
to be used to begin discovering other players.

00:09:47.090 --> 00:09:54.019
So you'll see looking for other players in the net dialog
come up showing Jane's iPhone and John's iPhone, and so on.

00:09:54.019 --> 00:09:58.429
Now when those 2 people connect, this
method is going to be-- is going to fire.

00:09:58.429 --> 00:10:02.019
So this is peerPickerController:didConnectPeer:toSession.

00:10:02.019 --> 00:10:05.319
Now there are a few different steps
that we're going to go through here.

00:10:05.320 --> 00:10:07.910
First is just some memory bookkeeping, we're going to keep--

00:10:07.909 --> 00:10:13.429
we're going to retain a reference to our session
for later instead of delegate method which is going

00:10:13.429 --> 00:10:17.870
to receive the next series of notifications.

00:10:17.870 --> 00:10:23.750
>> We also set a delegate now that is going
to actually be the method that receives data.

00:10:23.750 --> 00:10:31.240
So when we receive data from the session over the
Bluetooth connection, this method will be invoked

00:10:31.240 --> 00:10:40.460
or a data receive handler will be invoked, and that will be
where you actually extract the data and use it in your game.

00:10:40.460 --> 00:10:48.200
And finally, since now in this method we have now connected,
and so we can dismiss the picker, release the delegate--

00:10:48.200 --> 00:10:52.860
or set the delegate to NULL and release the picker memory.

00:10:52.860 --> 00:10:59.310
So at this point, the connection is
made and you can begin your game, OK?

00:10:59.309 --> 00:11:02.379
So that was step 3, and remember, there are 2 more.

00:11:02.379 --> 00:11:07.409
We need to now cover actually transferring
some data back and forth.

00:11:07.409 --> 00:11:14.339
So to do that, we-- oh I apologize, I forgot
one case here, that was if the session was--

00:11:14.340 --> 00:11:19.720
or excuse me the picker did connect, you also should
cover the case if you-- the user canceled out.

00:11:19.720 --> 00:11:26.269
So the basic steps here are just tear down the picker, tear
down the session that was created, and probably return back

00:11:26.269 --> 00:11:32.319
to the main menu in your game, back to left and
go, and go back into Challenge Mode if they want.

00:11:32.320 --> 00:11:36.390
But all right, so now back to where I was.

00:11:36.389 --> 00:11:43.980
We need to exchange data between these 2 participants
and you'll use the Session API directly to do this.

00:11:43.980 --> 00:11:48.629
So this first method is just one that you
might write, mySendData:usingDataMode:.

00:11:48.629 --> 00:11:53.659
And within that method, to send data now,
you'll call method on to Session Object

00:11:53.659 --> 00:12:00.309
which is sendDataToAllPeers:withDataMode
and you can get an error value back.

00:12:00.309 --> 00:12:07.869
So the data that you'll send over the connection is just
an NSData object which makes it very easy for you to wrap

00:12:07.870 --> 00:12:13.840
up a number of different objects and have
them transfer over-- over the connection.

00:12:13.840 --> 00:12:15.920
The Mode is actually very interesting.

00:12:15.919 --> 00:12:21.949
We support-- there are 2 different Modes that you
might send data, either reliable or unreliable.

00:12:21.950 --> 00:12:27.770
With reliable, what that means is that we'll
actually attempt to retransmit any data

00:12:27.769 --> 00:12:31.620
that doesn't-- that isn't delivered to the other side.

00:12:31.620 --> 00:12:36.620
With unreliable, we won't worry about
it, we'll just keep on-- keep on going.

00:12:36.620 --> 00:12:39.769
So unreliable might be appropriate, for example,

00:12:39.769 --> 00:12:44.840
if you are just continually sending
say your position to the other player.

00:12:44.840 --> 00:12:48.120
If that data doesn't make it, you just don't worry about it.

00:12:48.120 --> 00:12:53.230
You can just send them another position
update rather than sending them an old one.

00:12:53.230 --> 00:12:56.120
Well, OK, so that's how you send the data.

00:12:56.120 --> 00:12:59.460
Now the companion to that of course is receiving data.

00:12:59.460 --> 00:13:03.850
So to receive data, this is a session
delegate method that will be--

00:13:03.850 --> 00:13:07.680
will fire when data comes to your
application from the network.

00:13:07.679 --> 00:13:11.529
It's receiveData:fromPeer:inSession with context.

00:13:11.529 --> 00:13:19.009
And so within this routine then, you will unpack
that data which is your application-specific data set

00:13:19.009 --> 00:13:27.200
and use that to update your game state, do whatever
application-specific coding you need to do there.

00:13:27.200 --> 00:13:34.259
But OK. So now we've initiated the connection, we're
sending data back and forth and the final thing that we need

00:13:34.259 --> 00:13:37.929
to handle there are Session state changes.

00:13:37.929 --> 00:13:41.959
So in this case, it's, well so all of
the Session state changes will come

00:13:41.960 --> 00:13:45.430
in through this delegate method,
session:peer:didChangeState:.

00:13:45.429 --> 00:13:50.629
And there are a number of different states
that a session can go through in its lifetime.

00:13:50.629 --> 00:13:55.230
But one that I really want to highlight
here is PeerStateDisconnected:.

00:13:55.230 --> 00:14:01.870
So this is where you would have to write some code to
handle the case where the remote player dropped off,

00:14:01.870 --> 00:14:07.149
they either quit the game or maybe they got a phone call or
something else happened, and so they're no longer playing

00:14:07.149 --> 00:14:12.419
with you, and you would have some
application-specific behavior to handle that case.

00:14:12.419 --> 00:14:23.110
All right, so that was a quick walkthrough using
the Session API along with the PeerPickerController.

00:14:23.110 --> 00:14:26.269
These are the 5 steps, so it's just to recite them again.

00:14:26.269 --> 00:14:28.529
We're going to configure and present the controller.

00:14:28.529 --> 00:14:30.319
We provide it with a session.

00:14:30.320 --> 00:14:31.879
We handle connecting.

00:14:31.879 --> 00:14:33.960
We handle data transfer back and forth.

00:14:33.960 --> 00:14:36.950
And then we handle basically disconnecting.

00:14:36.950 --> 00:14:48.020
OK. So then where I want to go next is that third element
of the Game Kit framework, which is In-Game Voice.

00:14:49.110 --> 00:14:57.129
So the GKVoiceChatService lets you add voice
chat within your application between devices.

00:14:57.129 --> 00:15:02.799
And so this is-- this API, what it's going to
do is sample your microphone and send your voice

00:15:02.799 --> 00:15:07.490
to the remote participant, and meanwhile,
the remote participant might be talking,

00:15:07.490 --> 00:15:12.519
and so it will play on your device
the audio that it received from them.

00:15:12.519 --> 00:15:18.539
And what's great about this API is that it
actually supports all of that going on while mixing

00:15:18.539 --> 00:15:23.159
with audio that's being generated from your game.

00:15:23.159 --> 00:15:26.939
We're going to be covering the
low-level functionality that handles

00:15:26.940 --> 00:15:31.130
that in the audio session that's
happening at 5 o'clock today.

00:15:31.129 --> 00:15:39.059
And of course, we'll be covering voice chat in a lot
of detail in the 9 a.m. Game Kit Session tomorrow.

00:15:39.059 --> 00:15:41.769
But let's dive into this just a little bit.

00:15:41.769 --> 00:15:51.809
So, with this API, your application actually provides the
code to handle the initial handshake between the 2 instances

00:15:51.809 --> 00:15:54.419
of your application running over the network.

00:15:54.419 --> 00:16:00.599
So, there's a configuration-- some configuration data
that we need for you to send to the remote participant

00:16:00.600 --> 00:16:06.450
and then for them to make a couple
of calls to set up the connection.

00:16:06.450 --> 00:16:08.320
I'll show you that in just a second.

00:16:08.320 --> 00:16:14.580
And then also while this is running or once the connection
is made, you have a number of controls over things

00:16:14.580 --> 00:16:18.460
like audio monitoring and making
adjustments to what you hear.

00:16:18.460 --> 00:16:21.450
So you can mute your own microphone.

00:16:21.450 --> 00:16:27.800
You can change how you-- the volume that you're hearing,
the remote participant, and you can enable metering

00:16:27.799 --> 00:16:37.319
which might allow you to do something, for example, where
you present some interface that lets you see when another--

00:16:37.320 --> 00:16:40.300
when the other participant is talking, for example.

00:16:40.299 --> 00:16:48.859
But so, I want to run you through the sequence of events
that happen when you actually are initiating this API.

00:16:48.860 --> 00:16:55.169
So both sides, to start, have to
define a unique participant ID.

00:16:55.169 --> 00:16:58.620
And this can be just an arbitrary string that you define.

00:16:58.620 --> 00:17:04.099
It's how other people will identify you
and their IDs how you will identify them.

00:17:04.099 --> 00:17:08.980
Now there are some things that are going to happen
on your side and some things that are going to happen

00:17:08.980 --> 00:17:12.589
on the remote side, so I've broken
those out here and on the next line.

00:17:12.589 --> 00:17:19.659
So on the local side, you initiate
the chat by evoking an object

00:17:19.660 --> 00:17:25.120
or the GKVoiceChatService object method
called startVoiceChatWithParticipantID,

00:17:25.119 --> 00:17:31.209
and you pass the participantID
of that remote participant, OK?

00:17:31.210 --> 00:17:38.190
Now on your side, a delegate method for the
GKVoiceChatClient object is going to fire,

00:17:38.190 --> 00:17:42.700
and that's called voiceChatService:sendData:toParticipantID.

00:17:42.700 --> 00:17:47.340
So this is the configuration data
packet that I was talking about.

00:17:47.339 --> 00:17:52.149
And it's your responsibility now over the
network connection that you may have already set

00:17:52.150 --> 00:17:57.530
up with some remote participant to
send this control data over to them

00:17:57.529 --> 00:18:01.079
so they can make some calls and
finish setting up the connection.

00:18:01.079 --> 00:18:05.179
So let's look at that.

00:18:05.180 --> 00:18:10.570
So now on the remote side, the remote
instance of your application is going

00:18:10.569 --> 00:18:13.619
to receive that data packet from the network.

00:18:13.619 --> 00:18:23.129
And it's going to unpack that data, realize, "Ah, this isn't
just some game state information being passed back and forth

00:18:23.130 --> 00:18:31.120
or something else, this is actually voice chat configuration
data", and so I need to invoke this routine here on my--

00:18:31.119 --> 00:18:36.929
on their side, they will invoke their
VoiceChatClient receivedData:fromParticipantID,

00:18:36.930 --> 00:18:42.470
that's your participantID and the
data that you sent to them, OK?

00:18:42.470 --> 00:18:48.640
Now, on their side, the GKVoiceChatService
delegate method will fire a

00:18:48.640 --> 00:18:53.250
voiceChatService:didReceiveInvitationFromParticipantID
with the callID.

00:18:53.250 --> 00:19:00.339
And at this point now, you're at a
stage where they know that you have--

00:19:00.339 --> 00:19:07.419
that you have invited them into a voice chat, and so on
their side they might pop up some user interface controls

00:19:07.420 --> 00:19:13.870
to allow them to either, allow, to
accept or decline that chat invitation.

00:19:13.869 --> 00:19:18.209
And assuming that they do accept it then we call--

00:19:18.210 --> 00:19:24.759
on their side they will call their
VoiceChatService object acceptCallID, OK.

00:19:24.759 --> 00:19:27.500
So now everything has been accepted.

00:19:27.500 --> 00:19:32.890
The configuration data has been exchanged,
and the connection gets negotiated

00:19:32.890 --> 00:19:36.570
under the hood by the VoiceChatService object.

00:19:36.569 --> 00:19:41.839
Both sides now can receive a notification
that the voice chat started.

00:19:41.839 --> 00:19:42.949
It's an optional method.

00:19:42.950 --> 00:19:48.920
You don't have to implement this, but it could be helpful
so now you can know that you're in voice chat mode,

00:19:48.920 --> 00:19:53.070
and so both sides can receive
voiceChatService:didStartWithParticipantID

00:19:53.069 --> 00:19:59.349
and that will be the participant
ID of the guy on the other side.

00:19:59.349 --> 00:20:00.679
Well, all right.

00:20:00.680 --> 00:20:08.130
So that is just the quick look through the peer-to-peer
connectivity that's provided now in iPhone OS 3.0.

00:20:08.130 --> 00:20:12.950
Now I just want to remind you, obviously this was
a very fast run through of that functionality.

00:20:12.950 --> 00:20:18.360
>> We'll have a session that goes into this in
depth tomorrow morning in this room at 9 a.m.

00:20:18.359 --> 00:20:22.839
Where I want to go next is with the accelerometer.

00:20:22.839 --> 00:20:27.889
So, the accelerometer has obviously captured
people's imagination on this platform.

00:20:27.890 --> 00:20:32.830
People use-- we see all kinds of games in the
App Store that are using the accelerometer

00:20:32.829 --> 00:20:36.089
to make their phone into a game controller.

00:20:36.089 --> 00:20:40.139
And so, the accelerometer itself
actually reports for simplex.

00:20:40.140 --> 00:20:45.930
So, it's constantly reporting the forces that are
felt on the device and most frequently the force

00:20:45.930 --> 00:20:49.049
that it's feeling is the force of gravity.

00:20:49.049 --> 00:20:57.389
And by knowing the force or by seeing which
direction the vector of the force of gravity is in,

00:20:57.390 --> 00:21:02.890
you're able to calculate the orientation
of the device as you're holding on to it.

00:21:02.890 --> 00:21:07.540
And the accelerometer gives you obviously
instantaneous knowledge as this is going on.

00:21:07.539 --> 00:21:15.569
You can be receiving accelerometer data at a rate of
up to 100 updates per second, so it's very fine grain.

00:21:15.569 --> 00:21:18.319
And we see this being used in all sorts of games.

00:21:18.319 --> 00:21:23.859
So, perhaps some games are using, are rolling
the phones to steer as you move around.

00:21:23.859 --> 00:21:29.740
Others are doing-- changing the pitch to, or
looking at the pitch to control the throttle

00:21:29.740 --> 00:21:32.670
or brake as in, say, a driving simulation.

00:21:32.670 --> 00:21:38.050
And still other games using the accelerometer in
different gestures or interpreting it differently to swing

00:21:38.049 --> 00:21:41.649
or punch or throw or flip or reload, right.

00:21:41.650 --> 00:21:49.380
So, there's all kinds of different game play
functionality that you can create using the accelerometer

00:21:49.380 --> 00:21:52.350
and so you know go out, use your imagination.

00:21:52.349 --> 00:21:55.359
But so the reason why I actually
want to present this section is

00:21:55.359 --> 00:21:58.729
to make sure that everybody gets this exactly right.

00:21:58.730 --> 00:22:02.900
So, I'm going to show you a little bit
about the interface itself which is just

00:22:02.900 --> 00:22:07.019
that simple, and how you receive accelerometer data.

00:22:07.019 --> 00:22:12.549
But then the really interesting part is actually about
smoothing the data that you receive from the accelerometer

00:22:12.549 --> 00:22:18.889
and I'll give you some tips for
your user experience in your game.

00:22:18.890 --> 00:22:23.640
One note before I start, of course there's
no accelerometer support in your Mac.

00:22:23.640 --> 00:22:28.980
I've said before, don't shake your Mac,
it's not going to work in your game.

00:22:28.980 --> 00:22:35.860
Something actually though that some game developers had
done that's very clever here just to be able to test is

00:22:35.859 --> 00:22:42.319
that sometimes they will play the game live
on the device and have a special code path

00:22:42.319 --> 00:22:46.349
that is actually recording the
values coming off the accelerometer.

00:22:46.349 --> 00:22:51.439
They bring that back over onto their Mac and when
they run in the simulator, they just use that--

00:22:51.440 --> 00:22:57.870
those prerecorded accelerometer values
as, you know, input into their routines.

00:22:57.869 --> 00:23:02.289
It's a very effective way of managing to
use the accelerometer and still be able

00:23:02.289 --> 00:23:06.579
to get the fast turnaround you get with using the simulator.

00:23:06.579 --> 00:23:09.919
But, all right, so let's just dive into this.

00:23:09.920 --> 00:23:14.430
So accelerometer, part of the UIKit
framework, it's reporting values back to you

00:23:14.430 --> 00:23:18.420
on 3 axes within a 3-dimensional space in X, Y, Z.

00:23:18.420 --> 00:23:22.460
If you're holding the phone in
portrait mode out towards you guys,

00:23:22.460 --> 00:23:26.710
then the X-axis is going to run
horizontally from left to right.

00:23:26.710 --> 00:23:30.190
The Y-axis runs vertically from bottom to top,

00:23:30.190 --> 00:23:34.710
and the Z-axis runs through the
device from backstage out towards you.

00:23:34.710 --> 00:23:40.509
OK, the code for this actually
really couldn't be much simpler

00:23:40.509 --> 00:23:47.220
You just get a handle to the accelerometer instance
which is, you know, there's one accelerometer

00:23:47.220 --> 00:23:49.680
on the device and so you just get a handle to it.

00:23:49.680 --> 00:23:53.549
You don't need to initialize, you
know, anything along those lines.

00:23:53.549 --> 00:23:59.879
You set an updateInterval which can be anything
up to a maximum of 100 updates per second.

00:23:59.880 --> 00:24:05.630
And then you set a delegate, and that delegate
is going to immediately start sending updates

00:24:05.630 --> 00:24:10.890
of the accelerometer values to your
method accelerometer:didAccelerate.

00:24:10.890 --> 00:24:12.770
And I want to note something here.

00:24:12.769 --> 00:24:18.970
So this will, as it says, it will start sending the
updates immediately and it will just keep sending

00:24:18.970 --> 00:24:22.990
and keep sending until you set the delegate back to nil.

00:24:22.990 --> 00:24:29.910
So, if you want to go, for example, in your game and go
into pause mode or something else is happening in your game,

00:24:29.910 --> 00:24:32.610
you don't need to be currently reading the accelerometer,

00:24:32.609 --> 00:24:37.109
set that back to nil so that you don't
keep getting accelerometer updates.

00:24:37.109 --> 00:24:39.429
'Cause there's probably other things that you're doing

00:24:39.430 --> 00:24:45.730
when you receive those updates that
would just be wasting CPU time.

00:24:45.730 --> 00:24:46.700
All right.

00:24:46.700 --> 00:24:52.620
So, now to extract the data out of the
information that comes to that delegate,

00:24:52.619 --> 00:24:54.549
OK, it couldn't really be too much simpler.

00:24:54.549 --> 00:25:00.299
You get an acceleration object here, UIAcceleration
object, and these values are really just floats.

00:25:00.299 --> 00:25:04.299
You can get the direct X, Y, and Z values out of them.

00:25:04.299 --> 00:25:12.899
So then, what you'll do now is process the data itself
so-- and that's where it gets really interesting, right?

00:25:12.900 --> 00:25:19.830
And the thing to understand here is that actually
the accelerometer is extraordinarily sensitive.

00:25:19.829 --> 00:25:24.519
I've taken the AccelerometerGraph example
that's up on the iPhone Dev Center here.

00:25:24.519 --> 00:25:29.119
And for the X values coming in, I multiplied them by 50X

00:25:29.119 --> 00:25:33.539
to see you could really see the variance
in those values that are coming in.

00:25:33.539 --> 00:25:40.759
And I took this snapshot as I was trying to hold
perfectly still, and yet you know you can see

00:25:40.759 --> 00:25:46.240
that there are some slight ticks up and down in
that, in those values that are reported back.

00:25:46.240 --> 00:25:54.000
And if you're using the accelerometer at a sensitivity level
where it's controlling the camera location or the rotation

00:25:54.000 --> 00:25:59.259
of some object in your scene, then
actually you'll want to smooth out this data

00:25:59.259 --> 00:26:03.339
so that the object appears to be presented smoothly to you.

00:26:03.339 --> 00:26:10.959
So, the activity of smoothing out that
data, you know, comes from signal analysis.

00:26:10.960 --> 00:26:15.720
And so, we're basically taking this problem moving the--

00:26:15.720 --> 00:26:22.329
you know, moving it from the time domain over here to the
frequency domain and just thinking about different ways

00:26:22.329 --> 00:26:27.639
that we can isolate different frequencies of
data that are coming off of the accelerometer.

00:26:27.640 --> 00:26:34.230
And now to simplify this, of course, a low-pass
filter is something that you might apply then

00:26:34.230 --> 00:26:41.289
to isolate the gravity component, the low
frequencies, because those are going to be constant.

00:26:41.289 --> 00:26:47.829
Whereas a high-pass filter is something that you might
apply to the incoming data to isolate the so-called "shake"

00:26:47.829 --> 00:26:51.559
of the device if you wanted to
get at that data but didn't care

00:26:51.559 --> 00:26:57.809
of the original orientation of the device as it's in space.

00:26:57.809 --> 00:27:01.220
So, let's look at a couple of filters.

00:27:01.220 --> 00:27:08.140
This one is actually a trivial low-pass example
that we provide in our programming guide.

00:27:08.140 --> 00:27:14.590
And the thing to know about this though is that
actually it's too simple for most game controllers.

00:27:14.589 --> 00:27:18.179
So, this is going to be fine if all that you need to do

00:27:18.180 --> 00:27:24.000
and when you're using the accelerometer
is kind of know recently where it is.

00:27:24.000 --> 00:27:29.400
You know, and so for user interface type
gestures where you're going from landscape

00:27:29.400 --> 00:27:32.680
into portrait, that sort of thing, this would be fine.

00:27:32.680 --> 00:27:39.210
But, if you're actually going to be using the
accelerometer as a real-time game controller in your game,

00:27:39.210 --> 00:27:45.539
then certainly this trivial example here is not going to
be good enough, single-pole filter not working very well.

00:27:45.539 --> 00:27:48.170
And if we look at the reason why, let me just factor it out.

00:27:48.170 --> 00:27:53.660
What we're doing each time through this
calculation and these are happening

00:27:53.660 --> 00:27:58.600
at whatever update rate we set, say 30 times per second.

00:27:58.599 --> 00:28:04.109
We're going to be taking 10 percent of the
original values and adding that to 90 percent

00:28:04.109 --> 00:28:07.179
of the value from the previous iteration.

00:28:07.180 --> 00:28:16.160
And that's just not going to be a big enough contribution
of these incoming values to really have the, you know,

00:28:16.160 --> 00:28:20.320
have the data be-- appear to be responsive.

00:28:20.319 --> 00:28:24.059
And you think, well you could just
bump up those values, couldn't you?

00:28:24.059 --> 00:28:26.929
And you know like you can make
them 50/50 or something like that.

00:28:26.930 --> 00:28:31.779
And the issue with that then is that you
sort of, you don't ever reach a point

00:28:31.779 --> 00:28:34.690
of perfection with a simple filter like this.

00:28:34.690 --> 00:28:41.090
It will always either have too much
lag or it will be too much jitter.

00:28:41.089 --> 00:28:47.220
And so, you need to do something that's
just a little bit more intricate than this.

00:28:47.220 --> 00:28:53.470
So, let's look at the values that you
would get from that sort of a filter here.

00:28:53.470 --> 00:28:55.789
You know, look at the details here.

00:28:55.789 --> 00:29:01.490
Over here we have, we reached the 90
percent point at about 22 iterations in.

00:29:01.490 --> 00:29:08.839
And the given here is that we started perfectly flat for
example and instantaneously moved to perfectly upright,

00:29:08.839 --> 00:29:13.679
and we want to see how long does it take for
those values to kind of catch up with reality.

00:29:13.680 --> 00:29:17.799
So, 22 frames or 22 iterations in, we're at 90 percent.

00:29:17.799 --> 00:29:22.819
Even after 30 iterations, we're at
96 percent of the actual value there.

00:29:22.819 --> 00:29:28.409
And so that's a lot of latency because a lot of games
are going to be running at 30 frames per second.

00:29:28.410 --> 00:29:32.300
If it takes that long, then you've got, you
know, kind of a second of lag in your game.

00:29:32.299 --> 00:29:37.250
It's going to make it really hard to steer your guy around.

00:29:37.250 --> 00:29:44.880
So, instead we recommend that you really fine tune this, and
this is an example, I realized, is kind of a cloud of code

00:29:44.880 --> 00:29:52.880
up here, but it's an example of just doing--
taking a few more steps along the way as you are,

00:29:52.880 --> 00:29:55.350
as you're calculating those incoming values.

00:29:55.349 --> 00:29:59.349
And I want to point out, so this
code now, we are making a new version

00:29:59.349 --> 00:30:03.809
of the AccelerometerGraph example
available to all of you guys.

00:30:03.809 --> 00:30:06.409
It just didn't make the drop for today's session.

00:30:06.410 --> 00:30:11.870
It should be on the website tomorrow,
so go take a look at that.

00:30:11.869 --> 00:30:14.449
>> But OK, so there's a couple of
different things that we're doing here.

00:30:14.450 --> 00:30:19.650
We start with kind of the same calculation
that we had in the previous trivial filter,

00:30:19.650 --> 00:30:22.540
but then there is two more things that we're adding to this.

00:30:22.539 --> 00:30:24.720
First is a step function.

00:30:24.720 --> 00:30:31.279
So we observe that values that are kind of within a really
tight band, even though there might be a lot variants

00:30:31.279 --> 00:30:37.859
within that band, those values can essentially
be smoothed out to all the constant.

00:30:37.859 --> 00:30:43.649
And so with this-- by adding in some calculations to
calculate a step function, we're able to achieve that.

00:30:43.650 --> 00:30:47.710
And then the second observation that we make here is just

00:30:47.710 --> 00:30:52.500
about calculating a so-called proportional
factor to all of these.

00:30:52.500 --> 00:30:58.440
And so, here's the observation that
we want to take the accelerometer

00:30:58.440 --> 00:31:03.730
and consider how much change there
was in this current frame.

00:31:03.730 --> 00:31:08.779
So if there was a lot of change, then
proportionally speaking we want to take more

00:31:08.779 --> 00:31:12.210
of the new value compared to what was there before.

00:31:12.210 --> 00:31:17.549
We assume that this lots of change mean an
intentional gesture on the part of the user.

00:31:17.549 --> 00:31:27.049
But if the amount of change is really low, then we take kind
of a smaller amount of that proportionally and work our way

00:31:27.049 --> 00:31:31.950
through this, and that way, those small changes
will kind of end up getting smoothed out.

00:31:31.950 --> 00:31:37.990
So, I want to show you the results
of this, the red line here.

00:31:37.990 --> 00:31:43.259
So you can see, obviously it converges
up to 1.0 much faster than before.

00:31:43.259 --> 00:31:51.119
That after 11 iterations through this loop, you get to 90
percent and certainly after you're at 30 iterations here,

00:31:51.119 --> 00:31:53.929
you're all the way up to the actual value of 1.0.

00:31:53.930 --> 00:32:01.600
The step function helps you try to kind of snap to that
final version of 1.0, and the proportional change helps us

00:32:01.599 --> 00:32:05.969
to get this sudden rise in the beginning of this.

00:32:05.970 --> 00:32:12.180
And of course, on that code that I just showed you, you're
able to adjust some of the parameters for the step function

00:32:12.180 --> 00:32:18.240
or other things there to really fine tune this if you
want to push that red line even further over to the left.

00:32:18.240 --> 00:32:19.620
So, go wild with that.

00:32:19.619 --> 00:32:23.269
It's going to be in the AccelerometerGraph
example that you can see, get tomorrow.

00:32:23.269 --> 00:32:26.009
Now I want to show you a quick demo of that now.

00:32:26.009 --> 00:32:34.670
[ Pause ]

00:32:34.670 --> 00:32:39.210
>> So here I am, I am running the
GLTeapot, GLGravity example here.

00:32:39.210 --> 00:32:42.410
And what you see, you see it's shaking actually quite a bit.

00:32:42.410 --> 00:32:46.310
This is with absolutely no smoothing
coming into the incoming values.

00:32:46.309 --> 00:32:50.629
And we're using those values to
just set the rotation on the Teapot.

00:32:50.630 --> 00:32:54.890
And so it's setting here flat on the surface
and there are even some variants then.

00:32:54.890 --> 00:33:00.530
But if I move around, you can see
it's actually pretty shaky.

00:33:00.529 --> 00:33:04.609
And now, as I do this, I observe of
course the response is instantaneous.

00:33:04.609 --> 00:33:12.639
But it's too jittery, I think, to be able
to use productively as a game controller.

00:33:12.640 --> 00:33:14.710
So you do need to smooth this out.

00:33:14.710 --> 00:33:20.950
Now if I tap once, now I'm in the mode
with the trivial low-pass filter example

00:33:20.950 --> 00:33:23.259
that came out of our programming guide.

00:33:23.259 --> 00:33:30.450
And so now you can see, OK, the shake is
gone and it's very smooth as we move around.

00:33:30.450 --> 00:33:35.059
But, and I don't know if you guys can
tell so much, but there is some lag.

00:33:35.059 --> 00:33:41.559
And as I move around the device here, you can see
that there's about, you know, half second to a second

00:33:41.559 --> 00:33:45.819
of lag depending on how sensitive I really think about.

00:33:45.819 --> 00:33:53.169
One more tap and now I'm using the code that I
just showed you with that improved low-pass filter.

00:33:53.170 --> 00:34:00.400
And so now the response-- well, again we've gotten rid of
the shake but the response now, it's very responsive and

00:34:00.400 --> 00:34:04.019
yet it's still very smooth as I move around.

00:34:04.019 --> 00:34:09.780
And so this would be just fine to go driving
around and using as a game controller.

00:34:09.780 --> 00:34:14.010
So all right, and back to slides.

00:34:14.010 --> 00:34:21.800
[ Pause ]

00:34:21.800 --> 00:34:28.340
>> So there's a couple now of expert tips that I want
to talk about with relation to the accelerometer.

00:34:28.340 --> 00:34:34.780
So, the first thing to realize if you're doing the
smoothing calculations is that the calculations

00:34:34.780 --> 00:34:38.260
and the callback are actually occurring on your main thread.

00:34:38.260 --> 00:34:42.230
And there might be other work happening
on your main thread at the same time,

00:34:42.230 --> 00:34:47.309
in particular OpenGL might be rendering
its frame on your main thread as well.

00:34:47.309 --> 00:34:53.690
And something to-- a subtlety to be aware of there
is that, you know, OpenGL rendering can be variable.

00:34:53.690 --> 00:34:58.269
The amount of time it takes can be variable
from one frame to the next as the load

00:34:58.269 --> 00:35:01.989
of what you need to render increases and decreases.

00:35:01.989 --> 00:35:04.429
You know, different objects come into view.

00:35:04.429 --> 00:35:06.569
It might take longer to render a frame.

00:35:06.570 --> 00:35:09.920
You end up looking out into space, maybe it takes shorter.

00:35:09.920 --> 00:35:16.400
And so, the processing frequency of
receiving these callbacks can be irregular

00:35:16.400 --> 00:35:19.389
and you just, you need to take action to correct that.

00:35:19.389 --> 00:35:24.869
And in particular, if you're using the timestamp
values coming in off the accelerometer to figure

00:35:24.869 --> 00:35:31.259
out like what the value was at a particular time, you're
going to get misled because the events are going to stack up

00:35:31.260 --> 00:35:38.320
and only be received by you after you're out
of that GL rendering part of your processing.

00:35:38.320 --> 00:35:44.570
So what we recommend here is actually rather than
performing the smoothing every time you get an update

00:35:44.570 --> 00:35:49.789
from the accelerometer, to instead perform
the smoothing in a rendering callback.

00:35:49.789 --> 00:35:56.880
So-- or in some other callback that more closely
relates to the frame rate of your game experience.

00:35:56.880 --> 00:36:01.019
So, do that there instead of in your accelerometer callback.

00:36:01.019 --> 00:36:08.860
And in the example that we show you,
this is a, this is how we did that.

00:36:08.860 --> 00:36:15.539
Another thing about using the accelerometer, now this
is more on the user interface or user experience side.

00:36:15.539 --> 00:36:19.789
You need to choose some home position for the accelerometer,

00:36:19.789 --> 00:36:24.769
something that kind of is the origin
or means I'm at zero right now.

00:36:24.769 --> 00:36:28.539
And you can either do this by just making a choice.

00:36:28.539 --> 00:36:33.889
Some people notice that, oh, at around
30-degree incline, it kind of feels natural

00:36:33.889 --> 00:36:37.460
for a lot of users, so I could just choose that.

00:36:37.460 --> 00:36:42.220
Something that's even better though would
be to calibrate when your game starts up.

00:36:42.219 --> 00:36:47.879
So, just be aware that the people who are playing your
game, sometimes they might be sitting at their desk

00:36:47.880 --> 00:36:52.019
or in a meeting and or listening to a conference.

00:36:52.019 --> 00:36:55.650
So, but other times, you know they
might be lying on their couch.

00:36:55.650 --> 00:36:59.780
The device might have a different orientation
when they started, and so having them,

00:36:59.780 --> 00:37:07.530
making them go to a 30-degree incline wouldn't
be natural for their game or for them.

00:37:07.530 --> 00:37:12.160
So, a couple of different things that you could do
here, you could calibrate this when the game starts,

00:37:12.159 --> 00:37:17.819
and then also recalibrate each time
the game is resumed after a pause.

00:37:17.820 --> 00:37:23.190
And that would just simply take that value,
make that be the new origin so to speak,

00:37:23.190 --> 00:37:28.079
and all of your subsequent updates
would be relative to that origin.

00:37:28.079 --> 00:37:34.690
Something else that we did in one of the demos that
we showed you last year was that if we get out in--

00:37:34.690 --> 00:37:37.349
was that actually we would dynamically calibrate.

00:37:37.349 --> 00:37:44.139
And what we would do is if we noticed that the
accelerometer values coming in were way off, say,

00:37:44.139 --> 00:37:50.579
in the corner for more than a couple of seconds, we
would assume the user has changed their, you know,

00:37:50.579 --> 00:37:56.230
they're not sitting down anymore or, you know,
they've decide to play at some other angle,

00:37:56.230 --> 00:38:01.909
and we would recalibrate with that
new position being the origin.

00:38:01.909 --> 00:38:03.940
There is no universal answer for this.

00:38:03.940 --> 00:38:09.289
This is just something that you'll have to
think about and implement in your own code.

00:38:09.289 --> 00:38:18.809
And the last tip that I want to give you with regards to the
accelerometer is just to talk about screen dimming behavior.

00:38:18.809 --> 00:38:25.400
So, something to remember, or you've probably been
playing some games where it's fully accelerometer based,

00:38:25.400 --> 00:38:28.570
you're playing the game and then suddenly what happened?

00:38:28.570 --> 00:38:34.980
The screen kind of dimmed, and it's because
the timer elapsed that no input had been taken

00:38:34.980 --> 00:38:37.289
on the screen for some number of seconds.

00:38:37.289 --> 00:38:41.880
And so, the operating system dimmed the
display for you to save the battery.

00:38:41.880 --> 00:38:48.710
So, well that's good behavior normally, but if your game
is one where you're not normally tapping the screen,

00:38:48.710 --> 00:38:51.440
then that's just not what you want to set up.

00:38:51.440 --> 00:38:54.869
And you can instead disable that behavior.

00:38:54.869 --> 00:39:00.619
You do that by changing this property on that
UIApplication object called idleTimerDisabled.

00:39:00.619 --> 00:39:05.369
You set that to Yes, and now you're
disabling the screen from dimming.

00:39:05.369 --> 00:39:11.319
But it's very important to note this, that you
have to get this exactly right as developers.

00:39:11.320 --> 00:39:15.870
You should only do this while your game is being played.

00:39:15.869 --> 00:39:20.440
It's not something for you to just set when
you start up your app and just leave it set.

00:39:20.440 --> 00:39:23.119
It shouldn't be used while you're browsing menus.

00:39:23.119 --> 00:39:29.480
It shouldn't be bro-- used while you're looking at
info screens or other activities in your application.

00:39:29.480 --> 00:39:34.650
It should just only be during game play, and
it's something that really only applies to games

00:39:34.650 --> 00:39:39.519
that are using the accelerometer for all of their input.

00:39:39.519 --> 00:39:44.099
All right, so folks, that takes me through what
I wanted to tell you about the accelerometer.

00:39:44.099 --> 00:39:49.019
And the final portion here now is In-App Purchase.

00:39:49.019 --> 00:39:56.579
So you saw this yesterday of course, and the Store
Kit framework provides you with the capability

00:39:56.579 --> 00:40:02.579
of having a payment collection engine that
runs directly from inside of your application.

00:40:02.579 --> 00:40:05.429
This is something that is specific to iPhone OS 3.0.

00:40:05.429 --> 00:40:11.509
And as you heard yesterday it's for
paid apps only, free apps remain free.

00:40:11.510 --> 00:40:18.560
So the API itself is going-- has a number of different
scenarios that can be set up, things like subscription model

00:40:18.559 --> 00:40:27.190
or downloading content into your game or just
unlocking functionality that is already compiled in.

00:40:27.190 --> 00:40:30.869
>> So, that last one is the case
that we're going to look at today.

00:40:30.869 --> 00:40:33.710
And it uses the App Store to collect the payment.

00:40:33.710 --> 00:40:38.289
So it connects back up with the App Store,
presents the user with some familiar--

00:40:38.289 --> 00:40:43.429
with a familiar experience that they would already
be accustomed to if they have, for example,

00:40:43.429 --> 00:40:47.669
purchased apps on their phone, or
downloaded music onto their phone.

00:40:47.670 --> 00:40:53.559
From the developer point of view, also it
provides to use a very familiar experience.

00:40:53.559 --> 00:40:58.559
If you have paid apps, you'll just get some
updated information to your iTunes Connect reports.

00:40:58.559 --> 00:41:03.150
So, here is our scenario, we're back in our dungeon game.

00:41:03.150 --> 00:41:07.539
The user has decided, you know
what I'm done with this campaign,

00:41:07.539 --> 00:41:11.590
I want to see what other campaigns
are available in this game.

00:41:11.590 --> 00:41:18.600
And so, in this particular case, we have a couple
of campaigns that are already compiled into the app.

00:41:18.599 --> 00:41:20.929
They're just not unlocked.

00:41:20.929 --> 00:41:27.339
So we are going to provide the user with the option
to look at those, maybe select one and purchase it

00:41:27.340 --> 00:41:31.260
and if they purchase it, then we'll unlock it.

00:41:31.260 --> 00:41:36.550
So you handle the first stage of this where you might want

00:41:36.550 --> 00:41:44.760
to show your user what different dungeon campaigns are
available for them to purchase or something more specific

00:41:44.760 --> 00:41:47.550
of course to the genre of your own application.

00:41:47.550 --> 00:41:54.090
You also present to them now kind of a products
catalog and product-specific information.

00:41:54.090 --> 00:41:56.450
I've kept it really simple on this slide.

00:41:56.449 --> 00:42:00.139
Just, this would be here a dialog that you
would pop-up maybe with some more information

00:42:00.139 --> 00:42:02.429
about the level that they are going to purchase.

00:42:02.429 --> 00:42:07.409
You would present that to them, so that they can
make the decision about whether or not to buy it.

00:42:07.409 --> 00:42:13.250
Now if the user clicks Buy here, this is
now when it connects up with the App Store.

00:42:13.250 --> 00:42:20.710
And so, the user will be presented with
a standard iTunes connection dialog,

00:42:20.710 --> 00:42:28.039
they'll enter their account credentials here, and if-- if
the purchase is successful, well, then now you go through,

00:42:28.039 --> 00:42:31.800
and now that level is unlocked in your game.

00:42:31.800 --> 00:42:37.680
OK? So, let's walk through the steps here that
are involved with actually setting this up.

00:42:37.679 --> 00:42:44.929
And again, I'm focusing on this specific instance
for unlocking levels that are already provided

00:42:44.929 --> 00:42:49.069
in the application they've just not enabled it first.

00:42:49.070 --> 00:42:55.140
There is other examples, you can have-- subscriptions
that can be enabled through in-app purchase,

00:42:55.139 --> 00:43:01.409
you can be downloading content that's-- or get access to
downloading content through the in-app purchase and so on.

00:43:01.409 --> 00:43:04.829
But many of those other things are
going to be covered in more detail

00:43:04.829 --> 00:43:08.929
in the in-app purchase session
that's happening later this week.

00:43:08.929 --> 00:43:12.179
But OK. So, up front, you defined some metadata.

00:43:12.179 --> 00:43:15.859
These are the products that you're
offering for sale in your app.

00:43:15.860 --> 00:43:19.260
And you enter that metadata into iTunes Connect.

00:43:19.260 --> 00:43:24.430
Oops, I didn't mean to go forward there, go back.

00:43:24.429 --> 00:43:29.739
Then the second stage is you will build
in your application the purchase workflow.

00:43:29.739 --> 00:43:36.949
So this is going to be all of the code that you write
to present the items for sale, let the user choose one,

00:43:36.949 --> 00:43:42.849
then connect up to the store to actually confirm
the purchase, get a transaction back to--

00:43:42.849 --> 00:43:49.049
look into that transaction, deliver the
goods to the user, and also support the case

00:43:49.050 --> 00:43:54.140
where perhaps the user has a new device and
they're loading your app onto this new device,

00:43:54.139 --> 00:43:59.239
you have to be able to restore the
purchases that the user has made.

00:43:59.239 --> 00:44:02.519
So, let's walk through starting up with the metadata.

00:44:02.519 --> 00:44:09.559
So the metadata, this is a data that you're going to
enter into iTunes Connect and the first thing you're going

00:44:09.559 --> 00:44:14.840
to identify is-- are things like a SKU
for each of the products that you wish

00:44:14.840 --> 00:44:18.519
to offer, items you wish to offer for sale.

00:44:18.519 --> 00:44:24.300
You'll give each one a title, you'll give it a
description and both of these things can be localized in--

00:44:24.300 --> 00:44:29.870
for the different locals that your application
supports, and you'll choose a price here.

00:44:29.869 --> 00:44:39.069
Now, you might actually enter a whole bunch of different
items into iTunes Connect and have some of them be available

00:44:39.070 --> 00:44:43.480
for purchase now, maybe some of them
you're going to get to later, and so on.

00:44:43.480 --> 00:44:52.099
But, you go log into iTunes Connect, enter in all of
these data and now a copy of that is living in the cloud.

00:44:52.099 --> 00:44:57.699
OK. So then we go to your application and
there is a number of steps that you have--

00:44:57.699 --> 00:45:03.989
that you need to implement within your
application to get through the flow

00:45:03.989 --> 00:45:08.949
to where the users actually purchase an item.

00:45:08.949 --> 00:45:12.349
So, before the purchase there is a few steps there.

00:45:12.349 --> 00:45:18.529
So this is the case where or this is the part of the
process where the user is just browsing your catalog,

00:45:18.530 --> 00:45:21.830
what dungeons are available for me to go and purchase?

00:45:21.829 --> 00:45:28.429
And you actually need to connect up to iTunes or excuse
me, connect to the App Store, give it your product catalog

00:45:28.429 --> 00:45:35.059
and it will return to you the localized details about
those products localized to that particular user.

00:45:35.059 --> 00:45:42.639
The user then, or your application then can
present those items to be selected by the user,

00:45:42.639 --> 00:45:45.190
and you're responsible to present how they're displayed.

00:45:45.190 --> 00:45:52.769
So it can be something that is kept within the theme
of other user interface elements in your application.

00:45:52.769 --> 00:46:00.009
This part, you don't have any particular
built-in UI that you are forced to use.

00:46:00.010 --> 00:46:05.560
Then, once the user has selected something that
they want to purchase, you'll connect again,

00:46:05.559 --> 00:46:10.750
again back up to the App Store
to request the payment for that.

00:46:10.750 --> 00:46:17.039
The user will be presented with that dialog to
enter their account credentials and the payment

00:46:17.039 --> 00:46:20.789
or the transaction will either go through or not.

00:46:20.789 --> 00:46:25.659
Then after that happens now, you have to
look at the result of that transaction.

00:46:25.659 --> 00:46:29.089
You'll unlock-- if it was successful you will unlock those,

00:46:29.090 --> 00:46:33.410
the feature or the built-in items
that you're trying to enable here.

00:46:33.409 --> 00:46:39.679
And then only at that point actually do you remove
the transaction from a persistent queue that we keep

00:46:39.679 --> 00:46:42.699
of the different transactions that are happening.

00:46:42.699 --> 00:46:48.269
And then finally, we go through
the process of restoring items.

00:46:48.269 --> 00:46:52.570
So, let me now walk you through this step by step.

00:46:52.570 --> 00:46:55.700
All right, so that first step was to load the catalog.

00:46:55.699 --> 00:47:01.250
Now, in many cases, your product catalog might be
something that you have already compiled into your app.

00:47:01.250 --> 00:47:05.920
You know what dungeon levels are
going to be available to your users.

00:47:05.920 --> 00:47:11.990
So you may have hardcoded it or you may have that sitting
in a plist somewhere in your document bundle.

00:47:11.989 --> 00:47:18.679
The other option of course is that that data
could be living in the cloud and is something

00:47:18.679 --> 00:47:22.859
that you could retrieve dynamically to
find out, OK, have I updated anything,

00:47:22.860 --> 00:47:26.890
are there new products that I could enable for this user?

00:47:26.889 --> 00:47:30.829
And so that would be how you would handle the dynamic case.

00:47:30.829 --> 00:47:37.509
But, again in this, in today's scenario I'm focusing on
unlocking levels that are already compiled into your app.

00:47:37.510 --> 00:47:46.090
So, what we're doing now is just finding out the
localized information that we should present to the user.

00:47:46.090 --> 00:47:53.420
So, the first thing to do is that we construct something
called a products request and we provide to it all of these

00:47:53.420 --> 00:47:56.740
of the SKUs that were available for our product.

00:47:56.739 --> 00:48:05.139
Create the request, initialize it with that set of SKUs,
set a delegate, and then finally when we call, invoke start,

00:48:05.139 --> 00:48:08.569
that information is going to be send out to the App Store.

00:48:08.570 --> 00:48:12.950
And the App Store will respond now with a products response.

00:48:12.949 --> 00:48:18.099
OK. So this delegate method will fire
productsRequest:didReceiveResponse:.

00:48:18.099 --> 00:48:23.730
And what you will receive there is two things.

00:48:23.730 --> 00:48:27.920
You'll get a response and it will contain
the products that were successfully--

00:48:27.920 --> 00:48:35.570
that there was information available for up on-- in iTunes
Connect and then it's possible you might have made a mistake

00:48:35.570 --> 00:48:42.530
or something could have not been finished on our side and so
you also get a list of the product IDs that were not valid.

00:48:42.530 --> 00:48:50.690
OK, so that was the response back from the App Store and
now you take, you start unpacking the data here that's

00:48:50.690 --> 00:48:58.110
in that response looking for the localized title, localized
description, and the price of these items that are for sale.

00:48:58.110 --> 00:49:01.970
And you will now, within your own user
interface, present those to the user

00:49:01.969 --> 00:49:04.429
so they can make a choice of what to purchase.

00:49:04.429 --> 00:49:10.319
The next or here is now-- Here is where we are so far.

00:49:10.320 --> 00:49:14.380
All that we've done now is present
the items for sale to the user.

00:49:14.380 --> 00:49:17.260
The user hasn't made a choice yet.

00:49:17.260 --> 00:49:20.740
So, let's take a look at that.

00:49:20.739 --> 00:49:28.059
So the next stage here is to actually request the
payment once the user taps on and makes their selection.

00:49:28.059 --> 00:49:32.570
So the code stages that are involved
with this, pretty simple.

00:49:32.570 --> 00:49:39.320
We're creating first a payment object and we
initialize that with the product that the user selected

00:49:39.320 --> 00:49:43.970
or we can also initialize it with just the
idea of that product that the user selected.

00:49:43.969 --> 00:49:52.489
We take that now or so now we have a payment object,
we're going to set up something called a payment queue.

00:49:52.489 --> 00:49:59.679
This queue is going to be managing, excuse me, is
going to be managing the payments that you're sending

00:49:59.679 --> 00:50:03.679
up to the App Store and then when the App
Store responds, you'll be taking items off

00:50:03.679 --> 00:50:06.779
of this queue to handle the transactions.

00:50:06.780 --> 00:50:10.000
So here we create the payment queue, a default queue.

00:50:10.000 --> 00:50:13.170
We add something called the transaction
observer, that's where you're going

00:50:13.170 --> 00:50:17.039
to get notified of the result of this payment.

00:50:17.039 --> 00:50:21.099
>> And then the third step here, there's a
couple of little magic pieces that happened.

00:50:21.099 --> 00:50:28.589
We add the payment into the queue and the API
constructs the transaction and puts that payment inside

00:50:28.590 --> 00:50:33.070
that transaction and sends it up to the App Store.

00:50:33.070 --> 00:50:39.450
OK. So that's how we get a payment, a
request for a payment over to the App Store.

00:50:39.449 --> 00:50:44.149
The user now will be presented
with that iTunes password dialog.

00:50:44.150 --> 00:50:46.329
They enter their account credentials.

00:50:46.329 --> 00:50:48.219
And then there are two possibilities.

00:50:48.219 --> 00:50:52.329
Either it all goes through or it doesn't, right?

00:50:52.329 --> 00:50:56.309
And we need to be able to cover
both of those cases, obviously

00:50:56.309 --> 00:51:02.539
Your transaction observer will then get a
notification back and this delegate method will fire

00:51:02.539 --> 00:51:09.289
that the payment queue updated some transactions and
you'll get an NSArray of the different transactions

00:51:09.289 --> 00:51:15.190
because it's actually possible for you to send more
than one request for payment at a time and then for it

00:51:15.190 --> 00:51:20.190
to send back multiple transactions for you to handle.

00:51:20.190 --> 00:51:25.170
All right, so now we've finished requesting
payment and we move now to the things

00:51:25.170 --> 00:51:30.260
that you need to do to actually deliver the goods.

00:51:30.260 --> 00:51:36.260
So the first thing we'll do is inspect the payment
transaction within that delegate method that just fired.

00:51:36.260 --> 00:51:40.170
There's a number of different states
the payment transactions can be in.

00:51:40.170 --> 00:51:44.079
The first is that OK, this item is in the
state of being purchased, that's fine.

00:51:44.079 --> 00:51:47.880
The one that I real-- that ones I
want to focus on are these latter 3.

00:51:47.880 --> 00:51:51.519
So, TransactionStateFailed, this
means that for whatever reason--

00:51:51.519 --> 00:51:55.639
the user canceled out, they didn't enter
the right password, just whatever happened.

00:51:55.639 --> 00:52:02.289
This transaction did not go through and so you would
probably just return back in your user interface maybe

00:52:02.289 --> 00:52:08.329
to let them go and look at other products that
you have for sale or, you know, act accordingly

00:52:08.329 --> 00:52:17.670
The other 2, OK, so if the payment state is that it
was purchased then this is now for real, they bought it

00:52:17.670 --> 00:52:26.930
and you need to unlock whatever functionality was previously
locked up and deliver that product item to the user.

00:52:26.929 --> 00:52:32.269
OK, so if this is code within your app
that you need to enable, then, you know,

00:52:32.269 --> 00:52:38.000
flip that bit so now this code pack is active.

00:52:38.000 --> 00:52:45.559
Final one here is that we also help you to cover the case
where the user may need, maybe restoring purchases from--

00:52:45.559 --> 00:52:51.250
onto a new device or onto a device that
they've done a clean and reload on.

00:52:51.250 --> 00:52:54.880
So, that's this last item here, TransactionStateRestored.

00:52:54.880 --> 00:53:01.920
This is just so you'll know, oh, OK, the user already
purchased this and I'm going to go and unlock it.

00:53:01.920 --> 00:53:06.750
And this is just as real as a real--
as a TransactionStatePurchased.

00:53:06.750 --> 00:53:15.539
OK. The final part here, after you've
unlocked whatever functionality it is

00:53:15.539 --> 00:53:20.039
that the user is purchasing is now
you need to finish the transaction.

00:53:20.039 --> 00:53:26.159
The reason why this is a separate step is actually because
the user might quit out of your application at any time.

00:53:26.159 --> 00:53:32.759
It could be that they entered their password and boom,
phone call and you know they don't know necessarily oh,

00:53:32.760 --> 00:53:35.130
what state was this thing that I just purchased.

00:53:35.130 --> 00:53:37.849
Well, we help you with this quite a bit.

00:53:37.849 --> 00:53:41.849
So, the payment queue is persistent,
the transactions are persistent.

00:53:41.849 --> 00:53:44.210
They'll stay with your app.

00:53:44.210 --> 00:53:52.449
I mean you can go back into them and get back to them until
you've actually removed that transaction from the queue, OK.

00:53:52.449 --> 00:53:58.399
And so you obviously need to make sure that you have
delivered the item to the user before you remove

00:53:58.400 --> 00:54:04.990
that transaction from the queue, but this is to help
you with that case where you're dealing with mobility.

00:54:04.989 --> 00:54:08.689
All right.

00:54:08.690 --> 00:54:14.190
So, at this point now, the user is playing
your game, they have their new levels.

00:54:14.190 --> 00:54:19.050
And there's only this one more case that
we need to cover and that's restoration.

00:54:19.050 --> 00:54:25.780
And we provide you with some great functionality here
but the policy issues to remember here are that just

00:54:25.780 --> 00:54:32.250
like applications, purchased items, the user only
needs to pay for them once and then they can,

00:54:32.250 --> 00:54:39.150
if they decide to restore their phone, they
get to reload your app and they also get

00:54:39.150 --> 00:54:42.930
to reload whatever in-app purchases they have made.

00:54:42.929 --> 00:54:49.369
Also remember that a particular user may
have both an iPhone and an iPod Touch.

00:54:49.369 --> 00:54:57.839
And it's perfectly valid for both of those
devices to have your purchase or the result

00:54:57.840 --> 00:54:59.760
of your in-app purchase from one purchase.

00:54:59.760 --> 00:55:07.250
OK. And of course this covers the case where
to make purchases available to the user when--

00:55:07.250 --> 00:55:10.519
if your, if they delete your app from
their phone, why would they do that,

00:55:10.519 --> 00:55:15.679
of course, but-- and then reinstall it later, OK.

00:55:15.679 --> 00:55:17.710
So, there's code to handle this.

00:55:17.710 --> 00:55:20.909
Just a reminder, we're back in our case statement here.

00:55:20.909 --> 00:55:28.019
This is where this-- you'll receive notice of this,
but there's an issue like, how do you get there?

00:55:28.019 --> 00:55:36.670
You know if I-- if the user has just restored their
device from scratch, they loaded my app, how did they know

00:55:36.670 --> 00:55:39.539
or how do I know to even check the queue?

00:55:39.539 --> 00:55:48.099
Well, you should probably add some interface elements
in your application that allow the user to go

00:55:48.099 --> 00:55:52.000
and restore all purchases that they have made.

00:55:52.000 --> 00:55:57.489
So, if you do that then what you would do when
they, after they select that option would be

00:55:57.489 --> 00:56:04.599
to reconstruct the payment queue and ask the
payment queue, so ask the App Store to restore all

00:56:04.599 --> 00:56:08.139
of the completed transactions that this user has made.

00:56:08.139 --> 00:56:14.489
And once they do that now, that same
delegate method is going to be firing.

00:56:14.489 --> 00:56:19.269
You will back running through this case
statement for each of the transactions

00:56:19.269 --> 00:56:24.280
that that user had previously made on their account.

00:56:24.280 --> 00:56:24.680
All right.

00:56:24.679 --> 00:56:29.139
So, that's how you can restore transactions
to users and it's critically important

00:56:29.139 --> 00:56:33.949
that you support that functionality in your app.

00:56:33.949 --> 00:56:36.109
But, all right, so that's the whole process.

00:56:36.110 --> 00:56:38.070
There are 8 steps that I listed here.

00:56:38.070 --> 00:56:42.800
There are, as I've been mentioning, other
scenarios that you might be interested in

00:56:42.800 --> 00:56:46.940
and we'll be covering these steps
here and those other scenarios

00:56:46.940 --> 00:56:51.309
in the in-app purchase session which
is happening later in the week.

00:56:51.309 --> 00:56:53.639
But that is StoreKit Integration.

00:56:53.639 --> 00:56:55.670
This my contact information--
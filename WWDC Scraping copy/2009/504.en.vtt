WEBVTT

00:00:13.859 --> 00:00:15.660
>> I'm Perry the Cynic.

00:00:15.660 --> 00:00:19.780
I am an architect in the OS Security Group.

00:00:19.780 --> 00:00:21.720
I invented code signing.

00:00:21.719 --> 00:00:23.739
So I should know.

00:00:24.960 --> 00:00:28.990
So why do you care?

00:00:28.989 --> 00:00:36.960
Code signing lets you identify code and recognize code.

00:00:36.960 --> 00:00:39.020
That's what it really does.

00:00:39.020 --> 00:00:46.930
A lot of people think it's a security feature and
there is security in there, but the primary purpose

00:00:46.929 --> 00:00:55.420
of code signing is to stamp a reliable identity on a piece
of code, Apple's code, your code, anybody else's code,

00:00:55.420 --> 00:01:01.740
and then have the means to actually
recognize whether it's still the same.

00:01:01.740 --> 00:01:09.240
And so recognize, filter, and organize
groups of code, that's fine.

00:01:09.239 --> 00:01:15.979
Almost incidentally by having a way of recognizing
code, we solved the software update problem like,

00:01:15.980 --> 00:01:19.219
"Is this really an update for that,
or did somebody spoof me?

00:01:19.219 --> 00:01:20.170
did somebody screw it up?

00:01:20.170 --> 00:01:21.760
this is not really the same."

00:01:21.760 --> 00:01:28.250
And the security part is simply there
to make sure that information we get

00:01:28.250 --> 00:01:32.890
about code identities is reliable,
that somebody can just fool you easily.

00:01:32.890 --> 00:01:45.230
And I don't know anyway of saying this really
nicely but you're supposed to sign your code.

00:01:45.230 --> 00:01:52.390
If you're shipping code into Mac OS either way, you're
supposed to sign your code, if you don't, you're not--

00:01:52.390 --> 00:01:57.960
the code you're making, the code you're shipping to
your customers these days is not first class code,

00:01:57.959 --> 00:02:01.679
your shipping legacy code whether you know it or not.

00:02:01.680 --> 00:02:05.530
So you need to sign your code to be up with it.

00:02:05.530 --> 00:02:11.419
And I will explain in some detail down the
road what will happen to you if you don't.

00:02:12.449 --> 00:02:19.530
So identity, this is really about giving
an identity to code, to your application.

00:02:19.530 --> 00:02:24.550
I'm going to use Apple's Mail program because it's
such a hapless victim and I like to beat up on it.

00:02:24.550 --> 00:02:27.890
So Apple's Mail program, that's a code identity.

00:02:27.889 --> 00:02:34.359
It was made by Apple and it's Apple's Mail,
not Apple's iChat, Apple's, you know, Safari.

00:02:34.360 --> 00:02:37.640
So we define code identities.

00:02:37.639 --> 00:02:39.329
We secure code identities.

00:02:39.330 --> 00:02:41.360
We put a cryptographic seal on them.

00:02:41.360 --> 00:02:44.980
So if somebody hacks around with
the code, we can recognize it

00:02:44.979 --> 00:02:49.889
and we know that it no longer has the
identity that it was supposed to having.

00:02:49.889 --> 00:02:55.599
We provide a small but useful language,
almost like a little programming language

00:02:55.599 --> 00:02:58.650
to discuss identity, to form, define identities.

00:02:58.650 --> 00:03:00.930
We'll talk about that in a while.

00:03:00.930 --> 00:03:03.430
And this is really important.

00:03:03.430 --> 00:03:05.500
We are identifying code as it's running.

00:03:05.500 --> 00:03:10.069
This isn't just about looking at the hard drive
and going, "Oh, look it's an application."

00:03:10.069 --> 00:03:14.370
It's about a running application and going,
"Where did that come from and what is it doing?

00:03:14.370 --> 00:03:16.500
Is it still doing what we think it was supposed to do?"

00:03:16.500 --> 00:03:23.169
Now, just as importantly, what
does code signing not do for you?

00:03:23.169 --> 00:03:28.459
Signing of code no matter how you sign it does not
get you program privileges it does not already have.

00:03:28.460 --> 00:03:30.320
You're not-- you don't get a different user ID.

00:03:30.319 --> 00:03:38.639
You can't suddenly read files you couldn't read before,
but you can ask system daemons or APIs for stuff

00:03:38.639 --> 00:03:42.879
and they may look to get you an identity
and decide whether to give you stuff.

00:03:42.879 --> 00:03:47.620
Code signing does not protect against
bugs, so be very clear about this.

00:03:47.620 --> 00:03:50.670
It's, again, about identity.

00:03:50.669 --> 00:03:56.000
If you write a program with a bug that erases the
hard drive and you sign it and say, "This is mine.

00:03:56.000 --> 00:03:56.419
I made it.

00:03:56.419 --> 00:04:01.629
I'm proud of this", and you ship it to customers
and the customers go, "Yeah, I know Joe Developer.

00:04:01.629 --> 00:04:02.289
He's a good guy."

00:04:02.289 --> 00:04:04.919
If they run it and you're right, it's
a hard drive that is not a failure

00:04:04.919 --> 00:04:09.079
of code signing, that is a failure of your coding skill.

00:04:10.969 --> 00:04:16.439
And conversely from the engineer's point of view,
code signing doesn't also automatically protect

00:04:16.439 --> 00:04:19.009
against placing trust where it should belong.

00:04:19.009 --> 00:04:22.409
If instead of downloading your excellent
program with the unfortunate bug,

00:04:22.410 --> 00:04:29.430
they download Hacker Inc.'s hard drive eraser tool and they
run it, it will erase the hard drive or do worse things

00:04:29.430 --> 00:04:33.569
for them because they trusted somebody's
code that they shouldn't have.

00:04:33.569 --> 00:04:40.189
Code signing can tell you whether this is really
Hacker Inc.'s hard drive destruction tool,

00:04:40.189 --> 00:04:45.490
but it doesn't tell you inherently
whether that's a good thing.

00:04:45.490 --> 00:04:49.019
So code signing in a single slide.

00:04:49.019 --> 00:04:53.240
If you just want to get over with it, I scared
you, you know you need to sign your code

00:04:53.240 --> 00:04:58.139
and you're really sorry you aren't already doing
it, what's the minimum you can get away with?

00:04:58.139 --> 00:05:04.819
Well, you need a digital signing identity, a
cryptographic signing identity in your keychain.

00:05:04.819 --> 00:05:06.639
I'll tell you later how to get them.

00:05:06.639 --> 00:05:09.769
It's really quite straightforward, but you know,

00:05:09.769 --> 00:05:15.019
I give you the picture of Keychain Access
with the-- a signing identity made.

00:05:15.019 --> 00:05:20.949
Now all you need to do is get that name and
stick it into your Xcode project right there

00:05:20.949 --> 00:05:25.389
where it says code signing identity,
who would have thought, and then build.

00:05:25.389 --> 00:05:29.250
And that's it, you're done.

00:05:29.250 --> 00:05:32.069
At least if you have a simple project.

00:05:32.069 --> 00:05:34.810
I mean, this is really simple.

00:05:34.810 --> 00:05:39.819
The hardest part is actually setting up the signing
identity which you do exactly once and then you think

00:05:39.819 --> 00:05:44.099
about it maybe once a year, and other
than that, you just run your Xcode builds,

00:05:44.100 --> 00:05:47.879
get signs to program for you, you ship it, you're happy.

00:05:47.879 --> 00:05:52.540
If for some reason you don't use Xcode, there
is a command line tool called the codesign.

00:05:52.540 --> 00:05:57.700
Same thing, you put that string into the --
argument of codesign, stick that on your make file

00:05:57.699 --> 00:06:01.620
or whatever other third party build
tool you've got, you're done.

00:06:01.620 --> 00:06:08.550
So, there's really very little excuse for not doing
that, except for a couple of reasons we'll talk

00:06:08.550 --> 00:06:15.069
about that are really more having something to
do with how you organize your build process.

00:06:15.069 --> 00:06:20.110
Code signing is meant to be a pervasive
feature of the operating system.

00:06:20.110 --> 00:06:21.860
It's everywhere.

00:06:21.860 --> 00:06:23.520
It's meant to be everywhere.

00:06:23.519 --> 00:06:28.079
We're not just signing Mach-O applications
which is what you'd expect.

00:06:28.079 --> 00:06:29.479
We're signing libraries.

00:06:29.480 --> 00:06:30.990
We're signing plug-ins.

00:06:30.990 --> 00:06:33.889
We're signing bundles containing any of these.

00:06:33.889 --> 00:06:36.039
We're signing scripts.

00:06:36.040 --> 00:06:42.010
And because it's not really all that clear what's a
script, the whole thing is extensible so if you happen

00:06:42.009 --> 00:06:45.849
to be writing a script interpreter, you
have the means to explain to the system

00:06:45.850 --> 00:06:49.420
that your scripts are actually code and they can be signed.

00:06:50.670 --> 00:06:56.480
Code signing applies to everything we
ship essentially: Leopards, Snow Leopard,

00:06:56.480 --> 00:07:01.250
and the various versions of the iPhone OS, it's on there.

00:07:01.250 --> 00:07:07.949
And our long term goal is to get
everything, all code on the system signed.

00:07:07.949 --> 00:07:11.219
Now on the iPhone that's already true because we made it so.

00:07:11.220 --> 00:07:15.890
We started from scratch so we said,
"OK, nothing unsigned runs here."

00:07:15.889 --> 00:07:21.639
For Mac OS X, it's not true, not as of
Leopard or Snow Leopard, but it is a goal.

00:07:21.639 --> 00:07:26.699
And you'll find that as time passes and
we're now going boldly into the future,

00:07:26.699 --> 00:07:31.899
it's going to become less and less
convenient not to be signed.

00:07:31.899 --> 00:07:38.569
And again because this is really important, primarily,
code signing is meant to be a runtime feature.

00:07:38.569 --> 00:07:45.230
It's really about the security of running code, your running
code, Apple's running code, daemons talking to clients.

00:07:45.230 --> 00:07:52.090
So the code signing feature is focused on running
processes, running scripts, talking to each other,

00:07:52.089 --> 00:07:58.049
establishing each other's identities,
and then making decisions based on that.

00:07:58.050 --> 00:08:02.810
There is some dynamic state that
goes with your running program.

00:08:02.810 --> 00:08:06.699
As a matter, one of the more interesting
things you can do is say,

00:08:06.699 --> 00:08:10.829
"I'm not sure I'm valid anymore,
just, you know, mark me invalid."

00:08:10.829 --> 00:08:12.879
You can do that to yourself at anytime.

00:08:12.879 --> 00:08:13.649
This is irrevocable.

00:08:13.649 --> 00:08:17.569
Once you are marked invalid, you can't ever
be valid again as long as you're running.

00:08:17.569 --> 00:08:25.599
And there is a means that I'll touch on very briefly
called code hosting that allows code to manage other code,

00:08:25.600 --> 00:08:30.160
like you know, if you do it with an interpreter
then you want to manage your scripts.

00:08:30.160 --> 00:08:34.629
And static validation, the thing that
looks at the hard drive and decides whether

00:08:34.629 --> 00:08:37.309
that something it sees there is
valid, that's just a subfunction.

00:08:37.309 --> 00:08:39.639
I mean we need to do it anyway
as part of the implementation.

00:08:39.639 --> 00:08:41.759
So it's exposed, you can use it.

00:08:41.759 --> 00:08:48.720
It's useful for things like disk integrity checkers
but it's not the main feature, so keep that in mind.

00:08:48.720 --> 00:09:00.040
OK, let me just give you a brief show
for those who haven't seen it yet.

00:09:00.039 --> 00:09:04.879
So I have a really simple test program here.

00:09:04.879 --> 00:09:10.480
It's just a little Cocoa apps made
straight from the Xcode template.

00:09:10.480 --> 00:09:14.629
All it does is display a couple of parameters.

00:09:14.629 --> 00:09:16.710
Let's just build it the way it is.

00:09:16.710 --> 00:09:23.100
It displays a couple of code signing latent
parameters and its one redeeming feature is

00:09:23.100 --> 00:09:26.980
that it can actually try to access a keychain item.

00:09:26.980 --> 00:09:30.470
So, yes we build, thank you.

00:09:30.470 --> 00:09:39.230
So here's a little CSTest which asks
itself, "Gee, I wonder if I'm signed

00:09:39.230 --> 00:09:43.090
and what's my status is and of
course right now it's unsigned."

00:09:43.090 --> 00:09:47.920
And yeah well, wake up.

00:09:47.919 --> 00:09:54.659
Let's make a keychain item for it.

00:09:57.720 --> 00:10:11.190
Very creatively called test and you've probably
all seen this dialog before, it's the--

00:10:11.190 --> 00:10:14.500
do you actually want this program
to access this keychain item

00:10:14.500 --> 00:10:18.220
because we haven't said anything
beforehand so the system doesn't know.

00:10:18.220 --> 00:10:23.060
>> So it asks you, you're the user, whether
you want the CSTest program to access test,

00:10:23.059 --> 00:10:29.029
and when you click on Always Allow you get to retrieve
the item and the system remembers that you said,

00:10:29.029 --> 00:10:35.110
"Yes," and so you can get it again, which is all very nice.

00:10:35.110 --> 00:10:40.779
And one of the things that you've probably figured out by
yourself is if you make a change to the program, you know,

00:10:40.779 --> 00:10:46.370
a corporate lawyer comes along and says,
"You really need to put a disclaimer in here.

00:10:46.370 --> 00:10:49.529
You can't ship that without a disclaimer."

00:10:49.529 --> 00:11:00.870
So we rebuild it and we relaunch
it and we hit that button again.

00:11:00.870 --> 00:11:04.139
And here's the dialog again because
the system in the essence

00:11:04.139 --> 00:11:08.319
of code signing has no idea whether this CSTest
has anything to do with the previous CSTest,

00:11:08.320 --> 00:11:11.580
they are 2 different programs,
there's different bytes in them.

00:11:11.580 --> 00:11:17.009
They may have some similarity like they're both
called CSTest and their info.plist sort look similar,

00:11:17.009 --> 00:11:20.110
maybe even the same, but any hacker could do this.

00:11:20.110 --> 00:11:21.899
So, we just don't know, we have to ask.

00:11:21.899 --> 00:11:26.799
And if you click on the Always Allow button again, then
well we'll remember this new one and now we'll have a list

00:11:26.799 --> 00:11:31.459
of 2 different CSTests that can access the item,
and every time you make an update it happens again,

00:11:31.460 --> 00:11:37.100
and you get dialogs and that's not
good, so let's say "No" for a change.

00:11:37.100 --> 00:11:43.470
So, that's a situation you're in if you
haven't started signing your code yet.

00:11:43.470 --> 00:11:46.160
So let me show you where you go from here.

00:11:50.049 --> 00:11:57.370
Keychain Access has this neat little
subfunction called the Certificate Assistant,

00:11:57.370 --> 00:12:00.090
which does certificate-related things.

00:12:00.090 --> 00:12:05.500
And one of the things it does is it can create
an identity for you, a cryptographic identity.

00:12:05.500 --> 00:12:09.980
It's really quite straightforward,
I mean let's name it Demo, why not?

00:12:09.980 --> 00:12:12.529
And the only thing you really have
to set is that you want to use it

00:12:12.529 --> 00:12:16.269
for code signing instead of, you
know, SSL or email or something.

00:12:16.269 --> 00:12:21.299
And it gives you a nice warning saying that what
you're doing here is not the most secure thing

00:12:21.299 --> 00:12:24.559
in the universe, but for testing purposes, it's fine.

00:12:24.559 --> 00:12:29.819
So we've just made a cryptographic identity
called Demo and it's a new keychain.

00:12:29.820 --> 00:12:34.240
And if you remember the picture from before,
all we have to do now is, we have to go in here

00:12:34.240 --> 00:12:38.409
and look at the built parameters for CSTest.

00:12:38.409 --> 00:12:44.360
And in here where we have code signing
identity, it actually finds them all for you.

00:12:44.360 --> 00:12:53.139
So it just looks through all of your keychains and finds all
of the eligible signing identities, so let's name it Demo.

00:12:53.139 --> 00:13:00.470
That-- that's the same dialog this time because Xcode
is trying to sign your program and it's trying to use

00:13:00.470 --> 00:13:04.240
that keychain item that is your cryptographic identity,

00:13:04.240 --> 00:13:06.480
and the same logic applies, you
know, we haven't done this before.

00:13:06.480 --> 00:13:13.370
So, if you say "Always Allow," this will be the last time
you see that dialog for your signing identity because,

00:13:13.370 --> 00:13:16.879
you know, Xcode, codesign is trying to sign it, so we build.

00:13:16.879 --> 00:13:22.100
And we still have a CSTest here and if you
are wondering how the hell you can find

00:13:22.100 --> 00:13:29.110
out that this is actually signed there
is codesign-v, the command line command.

00:13:29.110 --> 00:13:35.470
Like most beginning commands, it just doesn't say anything
if things are OK, it only yells at you when things look bad.

00:13:35.470 --> 00:13:44.040
If that bothers you, then you can dial up the verbosity
by giving it another v-flag and we're valid, cool.

00:13:44.039 --> 00:13:45.740
So, what does this mean?

00:13:45.740 --> 00:13:52.899
Well let's launch it and now we're valid, of course.

00:13:52.899 --> 00:13:58.429
But at first nothing much changes, we're trying to get
the keychain item, it's a new program, the system goes,

00:13:58.429 --> 00:14:02.370
"Do you really want this new CSTest
to access this keychain item?"

00:14:02.370 --> 00:14:04.720
And we say "Always Allow" and that's cool.

00:14:04.720 --> 00:14:08.430
But now let's do that change thing again.

00:14:08.429 --> 00:14:12.539
A new lawyer got hired and now we need a strict disclaimer.

00:14:13.659 --> 00:14:22.319
OK. And we're opening the thing
again, and we don't get a dialog.

00:14:22.320 --> 00:14:24.980
Yay, happy users!

00:14:24.980 --> 00:14:28.379
I want you to think about what just happened.

00:14:28.379 --> 00:14:30.350
I mean why is there no dialog.

00:14:30.350 --> 00:14:36.750
We don't omit the dialog because we set a flag saying don't
put up dialogs and nobody cares about security anyway.

00:14:36.750 --> 00:14:40.019
We did not put up a dialog.

00:14:40.019 --> 00:14:43.939
The system did not put up a dialog
because we don't need it anymore.

00:14:43.940 --> 00:14:50.700
Because when we hit the Always Allow button the last time,
and it will be the last time for this program if you keep

00:14:50.700 --> 00:14:53.990
on signing it, when we hit that button this time,

00:14:53.990 --> 00:15:00.019
the thing remembered in the Keychain Access control
is a code identity, a code signing code identity.

00:15:00.019 --> 00:15:05.189
And when you resigned the program after putting
this strict disclaimer and by signing it,

00:15:05.190 --> 00:15:07.660
you said, "I'm saying this is the same program.

00:15:07.659 --> 00:15:11.949
I'm the guy who made the previous version, same
signing identity, and it's the same program,

00:15:11.950 --> 00:15:15.280
so I'm telling you it's the same,
it's OK, just treat them the same."

00:15:15.279 --> 00:15:19.289
And the system looks at this and goes,
"OK, you're the guy who made the program.

00:15:19.289 --> 00:15:21.099
If you don't know, who should?

00:15:21.100 --> 00:15:22.580
So, I'll take your word."

00:15:22.580 --> 00:15:25.990
It's the same program, and so we
do not have to put up the dialogue.

00:15:25.990 --> 00:15:29.399
The new version gets access to the keychain item.

00:15:29.399 --> 00:15:32.629
So that's basically the idea here.

00:15:32.629 --> 00:15:37.980
There's a lot more to it and let me just
draw you through a couple of examples.

00:15:37.980 --> 00:15:41.899
We are not just looking at the main executable.

00:15:41.899 --> 00:15:44.559
I could show you, you know, opening
up a Hex Editor and futzing

00:15:44.559 --> 00:15:49.099
around with the program's bytes and
you'll see that it goes invalid.

00:15:49.100 --> 00:15:59.800
But to get to the point, if you go into the bundle and
you try to add some kind of interesting new resource,

00:16:01.370 --> 00:16:08.769
you see that suddenly the program has lost its
validity because we're actually inventorying all

00:16:08.769 --> 00:16:11.829
of the resources that belonged to the bundle.

00:16:11.830 --> 00:16:16.620
And we keep a memory of what they were, which
ones where there, and where they belong.

00:16:16.620 --> 00:16:23.769
If you remove a resource, you add a resource, you hack
around with the contents, code signing will figure it out.

00:16:23.769 --> 00:16:31.799
And as a matter of fact, if you remove it,
it goes back because we know it's still OK.

00:16:31.799 --> 00:16:33.709
Alright, enough demo.

00:16:33.710 --> 00:16:37.009
I don't have time for more demos sadly.

00:16:37.009 --> 00:16:42.819
[ Pause ]

00:16:42.820 --> 00:16:49.200
>> OK, so let's look a little bit in more detail
on what happened when Xcode built that program

00:16:49.200 --> 00:16:51.590
after you said, "Here's my signing identity."

00:16:51.590 --> 00:16:57.160
You've got your program and typically
in addition to the main executable,

00:16:57.159 --> 00:17:00.269
you've got info.plists and you've got resources.

00:17:00.269 --> 00:17:05.230
And if you did what we told you about doing privileged
operations, you'll probably have a Helper tool in there

00:17:05.230 --> 00:17:08.809
that does all of the dangerous stuff
and it's really small and really tight

00:17:08.809 --> 00:17:12.720
and you really read every line of code in it.

00:17:12.720 --> 00:17:17.630
And by the way, if you are writing a tool,
then you'll just have the executable,

00:17:17.630 --> 00:17:20.140
but everything else still works the same.

00:17:20.140 --> 00:17:25.600
OK. So we'll take those files and
we'll give them an identifier.

00:17:25.599 --> 00:17:29.789
Every code signature has a string identifier in it.

00:17:29.789 --> 00:17:32.409
Typically, we take that from the main, from the info.plist,

00:17:32.410 --> 00:17:38.180
so it will be out something like
com.yourcompany.mysuperprogram.

00:17:38.180 --> 00:17:42.400
So we seek the identifier and then
we put a cryptographic seal

00:17:42.400 --> 00:17:45.950
on it that's simply there so we
can detect if something changed.

00:17:45.950 --> 00:17:54.390
And I would take the code signing identify from a
keychain and we put a digital signature on the seal.

00:17:54.390 --> 00:18:00.360
So that together makes sure that somebody can't change
the program, recalculate the seal, and just go there,

00:18:00.359 --> 00:18:06.939
see nothing changed because you're the only one
who's supposed to have this signing identity.

00:18:06.940 --> 00:18:09.269
You don't give it to anybody else.

00:18:09.269 --> 00:18:14.500
And so anybody who isn't you can't
actually recreate that signature.

00:18:14.500 --> 00:18:20.269
So these new things-- the identity actually gets
embedded in the signatures so we can talk about it later.

00:18:20.269 --> 00:18:27.369
So anytime you'll see a signed binary, you can
figure out what digital identity was used to sign it.

00:18:27.369 --> 00:18:29.659
So these things we add it, the identifier, the seal,

00:18:29.660 --> 00:18:33.850
the signature with the embedded
identity, we call that a code signature.

00:18:33.849 --> 00:18:39.519
If you're wondering what gets added to your program
when you sign, that's it, all of these things.

00:18:39.519 --> 00:18:44.490
And if you're wondering why we didn't include
this Helper code that's because the logic

00:18:44.490 --> 00:18:47.859
of code signing says that Helpers get signed separately.

00:18:47.859 --> 00:18:49.359
This is important.

00:18:49.359 --> 00:18:55.089
So if you have Helpers, you need to
sign them in a separate signing step.

00:18:55.089 --> 00:18:59.899
Of course you know if you set the build
variables in Xcode, it'll just happen for you.

00:18:59.900 --> 00:19:06.019
OK, so now that we've built it, What
do we do with it, how does this work?

00:19:06.019 --> 00:19:15.079
So you build your program just like you always do and using
Xcode as a last step because it sees that Build variable.

00:19:15.079 --> 00:19:21.829
If you're using some other Build tool because you
wrote shell scripts or shell commands that do it,

00:19:21.829 --> 00:19:28.139
you take that signing identity from the
keychain, feed it into the codesign or an Xcode,

00:19:28.140 --> 00:19:33.210
and what comes out is a modified version
of your program with that signature added.

00:19:33.210 --> 00:19:37.170
Remember the thing in the box, we
add all of that to your program.

00:19:37.170 --> 00:19:41.680
If it's a Mach-O program, it actually
goes directly into the Mach-O executable

00:19:41.680 --> 00:19:44.820
And that's what you ship.

00:19:44.819 --> 00:19:46.309
You send that out to the user.

00:19:46.309 --> 00:19:47.139
You put it on a DVD.

00:19:47.140 --> 00:19:49.220
You put it on your website.

00:19:49.220 --> 00:19:56.900
You have some intricate binary patching protocol or you
just tell users to drag and install from a USB drive.

00:19:56.900 --> 00:20:00.019
We do not care how you do this.

00:20:00.019 --> 00:20:05.400
Seriously, the dotted line here doesn't matter to us.

00:20:05.400 --> 00:20:11.180
What matters to us is that the sign code that ends up
on the end-user system is exactly what you started with.

00:20:11.180 --> 00:20:13.470
It's the thing that got signed.

00:20:13.470 --> 00:20:20.809
And we mean exactly, same bytes, same files, no files
missing, no files edit, no special markers or anything.

00:20:20.809 --> 00:20:25.919
>> As long as it's the same files
with the same contents, we're happy.

00:20:25.920 --> 00:20:27.019
That same code gets run.

00:20:27.019 --> 00:20:30.089
Remember this is a runtime feature.

00:20:30.089 --> 00:20:35.839
And somebody eventually cares about whether that
program is actually valid and what its identity is,

00:20:35.839 --> 00:20:41.949
and so they pointed it and feed it into the
validation API which is API now and it's delivered.

00:20:41.950 --> 00:20:46.710
And up pops essentially a "Yes, it's
fine" or "Here is why it's not fine".

00:20:46.710 --> 00:20:50.529
That's the basic validation logic of code signing.

00:20:50.529 --> 00:20:57.769
Except of course up to here all we've validated is that
the program that we fed into the API is well-signed.

00:20:57.769 --> 00:21:01.710
If somebody replaced your program
with somebody else's program

00:21:01.710 --> 00:21:04.730
that is well-signed, we couldn't tell the difference.

00:21:04.730 --> 00:21:11.160
So there is one more input to the validation
API and that is what we call a Code Requirement.

00:21:11.160 --> 00:21:17.680
It's essentially a set of conditions that are placed
on the program in addition to being well-signed.

00:21:17.680 --> 00:21:20.130
If there is something wrong with the
signature, we always fail the validation.

00:21:20.130 --> 00:21:21.810
I mean this has been an edit.

00:21:21.809 --> 00:21:25.799
In addition game, everything must
be right for things to proceed.

00:21:25.799 --> 00:21:30.009
If anything is wrong we stop and yell, "It's not no good."

00:21:30.009 --> 00:21:33.500
So, a code requirement, well, where do you get that from?

00:21:33.500 --> 00:21:41.150
Well typically, you either have a hard coded
configuration that you built into your program or you store

00:21:41.150 --> 00:21:47.450
that in some kind of database, somewhere, where it
depends on, you know, who's doing the validation.

00:21:47.450 --> 00:21:51.799
OK, so where do you get the code requirements
from that you store in the database?

00:21:51.799 --> 00:21:56.369
As a matter of fact, there is an API for
getting that directly from the signed code.

00:21:56.369 --> 00:21:58.119
We call that the Designated Requirement.

00:21:58.119 --> 00:21:59.779
We'll talk about it in a little bit.

00:21:59.779 --> 00:22:04.289
But it's essentially a requirement that
answers the question, "Who are you?"

00:22:04.289 --> 00:22:07.409
OK, code requirements.

00:22:07.410 --> 00:22:12.340
Now I've tantalized you and titillated
you with what that is.

00:22:12.339 --> 00:22:20.899
So, it's a little programming language of sorts that
lets you write conditions about a piece of signed code.

00:22:20.900 --> 00:22:26.880
You can place conditions on the code itself, typically
things like, you know, is there a particular key

00:22:26.880 --> 00:22:32.180
in the info.plist or you can place conditions
on the actual cryptographic signature

00:22:32.180 --> 00:22:36.070
that secures it like, you know, was designed by Apple.

00:22:36.069 --> 00:22:39.579
Yeah, that's a popular one or was designed by me.

00:22:39.579 --> 00:22:42.230
That's probably a popular one for you.

00:22:42.230 --> 00:22:46.480
Or you can get a lot more elaborate than that.

00:22:46.480 --> 00:22:54.900
Code requirements essentially define code identity because
it's the requirement that you're feeding into the validation

00:22:54.900 --> 00:22:59.710
that determines what code you're looking for.

00:22:59.710 --> 00:23:01.110
Is it Apple's Mail?

00:23:01.109 --> 00:23:04.979
Is it your hard disk eraser?

00:23:04.980 --> 00:23:08.000
Is it anything written by your company?

00:23:09.119 --> 00:23:14.419
You can express code requirements
either in a text or binary form.

00:23:14.420 --> 00:23:16.810
There's API for converting between the two.

00:23:16.809 --> 00:23:22.990
The text form is there so you can show it to a user, not
any user, but a user who knows what he's doing, of course.

00:23:22.990 --> 00:23:24.529
They're also good for editing.

00:23:24.529 --> 00:23:29.180
If you need to take an existing code requirement
make a change to it, put it in text form,

00:23:29.180 --> 00:23:32.460
you just change the text and then
you convert it back to binary.

00:23:32.460 --> 00:23:37.480
The binary form is there so you can
store it in a database of your choice.

00:23:37.480 --> 00:23:38.680
And it's just a binary blob.

00:23:38.680 --> 00:23:42.210
It's a self-contained binary blob
with no pointers or funny business.

00:23:42.210 --> 00:23:50.190
So, you know, store it in a file, store it in a database,
store it in an XML file as a binary, we don't care.

00:23:50.190 --> 00:23:55.820
As long as you get the binary back with
all the bytes intact, that's fine with us.

00:23:55.819 --> 00:24:03.119
And there's this specific kind of code requirement
that actually gets embedded in the code signature.

00:24:03.119 --> 00:24:05.500
We call those internal requirements.

00:24:05.500 --> 00:24:11.450
They are conditions that a program itself places
on other programs it wants to interact with.

00:24:11.450 --> 00:24:17.720
Like for example this is the rules for which libraries
I'm willing to be linked against or if you happen

00:24:17.720 --> 00:24:22.950
to be a script, this is the kind of interpreter
I'm willing to let me run 'cause obviously

00:24:22.950 --> 00:24:27.819
if a hack interpreter runs your script, it can
do-- make your script do anything it wants.

00:24:27.819 --> 00:24:34.980
And then there are these very special
requirements called Designated Requirements.

00:24:34.980 --> 00:24:40.779
So there's an API that you can point at any signed
piece of code and essentially say, "Who are you?

00:24:40.779 --> 00:24:42.990
Would you get back as a code requirement?"

00:24:42.990 --> 00:24:49.890
And it's the way for the application or library or anything
else, any piece of code to say, "If you see another piece

00:24:49.890 --> 00:24:52.040
of code and you ever were wondering if it's me?"

00:24:52.039 --> 00:24:54.009
This is where you check for it.

00:24:54.009 --> 00:24:57.509
So for example, if you point at
Apple's Mail, there we go again,

00:24:57.509 --> 00:25:04.849
it will send you back through this API a code
requirement that says, "I was signed by Apple

00:25:04.849 --> 00:25:10.599
and my name is com.apple.mail", which if you think about
it is the best definition of Apple's Mail you can come

00:25:10.599 --> 00:25:18.969
up with 'cause it's made by Apple and Apple said it's Mail,
it's not Safari, it's, you know, not iChat, it's Mail.

00:25:18.970 --> 00:25:22.110
Most of the time, that is completely automatic.

00:25:22.109 --> 00:25:26.399
The API, if there's nothing special embedded
in the code, will simply make one up for you.

00:25:26.400 --> 00:25:32.580
It'll make up pretty much the right one for you, a
combination of who signed this and what is it called.

00:25:32.579 --> 00:25:39.559
If for some reason you wanna get fancy, you can explicitly
put a Designated Requirement into the code when you sign it

00:25:39.559 --> 00:25:44.399
and make it say anything you want, which is
occasionally useful if you know what you're doing.

00:25:44.400 --> 00:25:53.620
So the Designated Requirement is the definition
of what an application's "myself" means.

00:25:53.619 --> 00:25:58.189
This is what the application says
is the meaning of "itself".

00:25:58.190 --> 00:26:04.330
And of course since we try to make software
updates, maintain the identity of a piece of code,

00:26:04.329 --> 00:26:08.809
be the same piece of code just better and
with fewer bouts or at least different ones,

00:26:08.809 --> 00:26:15.929
so we expect that a software update satisfies the
designated requirement of the thing it's updating.

00:26:15.930 --> 00:26:20.890
So almost incidentally, we're defining
what a valid software update means.

00:26:20.890 --> 00:26:27.200
OK. So let's-- let's go back over this
because it's really the most important concept

00:26:27.200 --> 00:26:31.779
in code signing and simply back and do it again.

00:26:31.779 --> 00:26:37.519
The identity, code identity is defined by requirements.

00:26:37.519 --> 00:26:40.900
It's not defined by the code signature itself.

00:26:40.900 --> 00:26:44.650
If you find yourself seeing things like
"And then I'll compare this code signature

00:26:44.650 --> 00:26:47.920
to something else", you're thinking wrong.

00:26:47.920 --> 00:26:52.470
What you do is you are validating the
code signature against a requirement.

00:26:52.470 --> 00:26:54.769
That's what you do with code signatures.

00:26:54.769 --> 00:26:59.980
The code identity is not usually a single piece of code.

00:26:59.980 --> 00:27:01.200
It's a class of code.

00:27:01.200 --> 00:27:07.420
It's all possible pieces of signed code, well-signed
code that satisfy a particular requirement.

00:27:07.420 --> 00:27:12.120
All the codes that, you know, was made by
Apple and just called Mail for example.

00:27:12.119 --> 00:27:18.500
In particular, the designated requirement of a piece of code
is typically like an entire class of code because you want

00:27:18.500 --> 00:27:23.480
to capture not just the program you're just looking
at, you want to capture all the updates in the future

00:27:23.480 --> 00:27:26.529
and you probably also want to capture
all the older versions of that program

00:27:26.529 --> 00:27:29.589
because they're all supposed to be treated the same.

00:27:29.589 --> 00:27:35.899
So the Designated Requirement is
the way for a signed application

00:27:35.900 --> 00:27:39.560
to identify itself to the system saying, "This is me.

00:27:39.559 --> 00:27:42.099
If you want to recognize me, this is what you'll use.

00:27:42.099 --> 00:27:43.599
This is what you remember about me."

00:27:43.599 --> 00:27:47.389
And as a matter of fact, this is all you
have to remember about an application.

00:27:47.390 --> 00:27:53.660
If you're ever in a situation where you're writing a daemon
or a server or something else that gates access based

00:27:53.660 --> 00:27:58.290
on code identity and you have decided that, you know,

00:27:58.289 --> 00:28:02.960
this particular program here, Apple's
Mail, is allowed to do this.

00:28:02.960 --> 00:28:07.840
Get a keychain item, you know, open in
bundle network connections, I hope not.

00:28:07.839 --> 00:28:16.129
Then-and you want to remember this-- you want to put in some
database of yours, some configurations somewhere, you know,

00:28:16.130 --> 00:28:21.500
the one piece of information that allows
you to recognize this program again.

00:28:21.500 --> 00:28:22.230
This is what you do.

00:28:22.230 --> 00:28:24.220
You take the designated requirement from the code.

00:28:24.220 --> 00:28:25.870
You stick it in your database.

00:28:25.869 --> 00:28:27.099
You feed it to the validation API.

00:28:27.099 --> 00:28:29.279
You're done.

00:28:29.279 --> 00:28:34.789
No other piece of information required
for the code signing part to work.

00:28:34.789 --> 00:28:37.420
Now the converse is also true.

00:28:37.420 --> 00:28:41.539
Let's think about this for a moment.

00:28:41.539 --> 00:28:45.710
Any one piece of code as it's running or
as it's sitting on the hard drive tends

00:28:45.710 --> 00:28:48.960
to satisfy a number of different identities.

00:28:48.960 --> 00:28:54.640
I mean obviously Apple's Mail program satisfies
the use of Apple's Mail program identity,

00:28:54.640 --> 00:28:58.530
but it also satisfies the much
loser "Was Made by Apple" identity.

00:28:58.529 --> 00:28:59.700
That's another code requirement.

00:28:59.700 --> 00:29:02.880
You basically just drop the name
part and get signed by Apple.

00:29:02.880 --> 00:29:12.080
And of course you can make up more interesting identities
that this particular program happens to also satisfy.

00:29:12.079 --> 00:29:19.549
So just like a single code identity defines an
open-ended set of applications it satisfied,

00:29:19.549 --> 00:29:25.500
so any one application can satisfy
a number of code identities.

00:29:25.500 --> 00:29:27.160
I already told you that one.

00:29:27.160 --> 00:29:33.310
In particular, if you're ever tempted to compare 2
applications by fishing out some part of the signature

00:29:33.309 --> 00:29:37.500
and just comparing them for equality,
you're doing it wrong, don't go there.

00:29:37.500 --> 00:29:44.859
And just as a little warning marker,
the word "identity" is awfully,

00:29:44.859 --> 00:29:48.759
awfully overloaded because it's
such a popular word out there.

00:29:48.759 --> 00:29:53.359
Cryptographic signing identities which
are the things that you feed to Xcode

00:29:53.359 --> 00:29:57.479
in the code signing identity field,
those are cryptographic identities.

00:29:57.480 --> 00:30:01.170
You use them to make signatures,
but they're not code identities.

00:30:01.170 --> 00:30:02.890
They used to make code identities.

00:30:02.890 --> 00:30:08.370
I'm sorry for that, but we ran out of words.

00:30:08.369 --> 00:30:12.239
Well somebody told me yet again that
a picture is worth a thousand words,

00:30:12.240 --> 00:30:15.829
so let's see if we can cram a thousand words in one slide.

00:30:15.829 --> 00:30:21.899
>> Imagine that this entire screen is all the
possible well-signed applications you can imagine.

00:30:21.900 --> 00:30:26.519
And that's really "that you can imagine," not just
the ones that exist but the ones that could exist,

00:30:26.519 --> 00:30:31.389
the ones you make tomorrow, next year,
the ones that Joe Hacker makes next year.

00:30:31.390 --> 00:30:37.220
Some subset of that is the designated
requirement of Apple's Mail.

00:30:37.220 --> 00:30:44.350
These are all the applications that satisfy the code
requirement made by Apple and it is called Mail.

00:30:44.349 --> 00:30:48.139
That, of course, includes the Mail.app
that we just started from.

00:30:48.140 --> 00:30:52.300
It would be very bad if a program didn't
satisfy its own designated requirement.

00:30:52.299 --> 00:30:58.450
We all hope that it also includes some update to Mail even
one that hasn't been made yet, even one that, you know,

00:30:58.450 --> 00:31:01.120
Apple won't actually master and ship until next year.

00:31:01.119 --> 00:31:08.159
It doesn't include, we hope, some hacked version of Mail
that some hacker took in to change and then resigned

00:31:08.160 --> 00:31:12.170
with their own identity because,
well, it's not made by Apple.

00:31:12.170 --> 00:31:15.259
But there is a bigger code identity.

00:31:15.259 --> 00:31:20.279
Everything made by Apple is a rather large
subset of made by Apple and it's called Mail.

00:31:20.279 --> 00:31:25.589
It includes iChat, for example, which clearly is not Mail.

00:31:25.589 --> 00:31:32.129
So the system, as you can sort of see, can keep
these things apart by simply forming these subsets

00:31:32.130 --> 00:31:34.220
of applications which are not enumerated.

00:31:34.220 --> 00:31:36.210
There's no list of these applications anywhere

00:31:36.210 --> 00:31:40.410
There are simply conditions that
are being checked as you need them.

00:31:40.410 --> 00:31:42.009
Now, you can go in the other direction too.

00:31:42.009 --> 00:31:48.490
You can make a code identity for Apple's Mail but only
Version 3, which just looks in the info.plist which is fine

00:31:48.490 --> 00:31:51.400
because the info.plist is secured
by the code seal which is secured

00:31:51.400 --> 00:31:55.590
by the code signature, so we know that they're not lying.

00:31:55.589 --> 00:31:58.179
So that's the subset of Apple's Mail.

00:31:58.180 --> 00:32:01.160
And you're not restricted to subsets and supersets either.

00:32:01.160 --> 00:32:04.460
For example, there is a code identity
for anybody who's allowed

00:32:04.460 --> 00:32:09.769
to access your me.com password, what
used to be the mac.com password.

00:32:09.769 --> 00:32:12.740
That's actually what we call an application group.

00:32:12.740 --> 00:32:20.849
It's a marker in the info.plist that says it's in the
group of programs allowed to access the me.com password.

00:32:20.849 --> 00:32:23.500
And contemporary Mail is in that certainly.

00:32:23.500 --> 00:32:24.779
iChat is in that.

00:32:24.779 --> 00:32:31.139
On the other hand, some really old version of Apple's Mail
may not be, so these are overlapping but not hierarchical.

00:32:31.140 --> 00:32:35.970
And you can imagine how from here
you can go to anything you like.

00:32:35.970 --> 00:32:42.410
If you are stepping outside of the space of what Apple
can sign, you can make up code identities that include,

00:32:42.410 --> 00:32:46.840
you know, hacked mail, if you happen
to be the hacker who makes mail.

00:32:46.839 --> 00:32:50.750
And if you want, you can have your
own code identities overlap Apple's.

00:32:50.750 --> 00:32:56.240
You could make one for Apple's Mail of
MyMail, but that makes practical sense depends

00:32:56.240 --> 00:32:59.349
on your situation, but the system can do it.

00:32:59.349 --> 00:33:03.279
So that's a thousand words of the previous slide.

00:33:03.279 --> 00:33:13.170
This is kind of hard 'cause I-- there's
a lot of depth to this feature here,

00:33:13.170 --> 00:33:18.509
but I only have about 2 or 3 slides worth to talk about it.

00:33:18.509 --> 00:33:24.129
The system knows how to deal with code that
supervises or controls or manages other code.

00:33:24.130 --> 00:33:27.880
In the trivial case where you're
just riding a Mach-O binary,

00:33:27.880 --> 00:33:32.220
that's just the kernel managing your
program, it's not really very interesting.

00:33:32.220 --> 00:33:36.799
But let's say you still have a PowerPC
application sitting around somewhere, you know,

00:33:36.799 --> 00:33:39.629
one of those old games that they never update.

00:33:39.630 --> 00:33:44.570
What really happens the way it runs
is that there is Rosetta, which you--

00:33:44.569 --> 00:33:49.720
we all love, which is really the Unix process
that's being run and Rosetta, in turn,

00:33:49.720 --> 00:33:54.490
controls the PowerPC binary by translating it incrementally.

00:33:54.490 --> 00:34:00.890
And so the system just implicitly without you having
to notice builds this chain of code being responsible

00:34:00.890 --> 00:34:04.980
for other code and the chain can get longer.

00:34:04.980 --> 00:34:12.289
If you're calling the client APIs,
you don't even have to know.

00:34:12.289 --> 00:34:18.889
That also applies to scripts, things like, you know,
script interpreters like Ruby should be doing this.

00:34:18.889 --> 00:34:22.019
Sadly, Ruby right now doesn't do it on our system.

00:34:22.019 --> 00:34:27.599
That's our fault or somebody else's,
whoever you think should be doing that work.

00:34:27.599 --> 00:34:31.329
But Ruby should be and Python should be and many

00:34:31.329 --> 00:34:36.360
of the other interpreters should be calling
API to declare themselves code hosts.

00:34:36.360 --> 00:34:39.220
And why do you care about this

00:34:39.219 --> 00:34:44.879
Well, for one, of course, if your program, the thing
that you ship is an interpreter or a code manager,

00:34:44.880 --> 00:34:51.360
then this is your program and you should be
reading up on the hosting, code hosting APIs.

00:34:51.360 --> 00:34:53.820
It's not that terrifyingly complicated.

00:34:53.820 --> 00:35:01.500
In the simplest case, if you're a simple script interpreter,
then there are really only 2 API calls you need to make.

00:35:01.500 --> 00:35:08.840
But the more important reason why you care is
because this could be your customer script.

00:35:08.840 --> 00:35:13.850
If you are actually selling interpreters, then
your customers to a large extent are the people

00:35:13.849 --> 00:35:16.869
who write scripts that your interpreter runs.

00:35:16.869 --> 00:35:22.509
And these things, being code, need to be code signed
and in order for the system to sort this all out

00:35:22.510 --> 00:35:28.120
and know that myscript is actually
a separate piece of code rather

00:35:28.119 --> 00:35:32.769
than the Ruby interpreter being dragged,
you need to explain it to the system.

00:35:32.769 --> 00:35:36.929
So that's why you care if you're an
interpreter or if you're a code manager.

00:35:36.929 --> 00:35:44.409
If you run applets, scriptlets, scripts, or
anything else that you honestly think of as code,

00:35:44.409 --> 00:35:47.549
you need to dig down into code hosting and get up to speed.

00:35:47.550 --> 00:35:52.010
That's all I have time to talk about.

00:35:52.010 --> 00:36:00.120
OK, so what happens if you completely ignore
me and just keep shipping unsigned code?

00:36:00.119 --> 00:36:02.000
Well, you know the answer about the phone.

00:36:02.000 --> 00:36:06.460
It will politely tell you that,
no, sorry, they can't do that.

00:36:06.460 --> 00:36:12.809
But Mac OS X will still run it because
we're tolerant and besides we don't

00:36:12.809 --> 00:36:17.289
like knifing our developers in the back, for a while.

00:36:19.400 --> 00:36:22.630
[Laughter] So unsigned code for
the most part will still run.

00:36:22.630 --> 00:36:24.030
The kernel will still execute it.

00:36:24.030 --> 00:36:26.240
You know, the Windows will come up.

00:36:26.239 --> 00:36:32.789
You know, everything will look more or less OK and unchanged
which, of course, leads to a lot of developers going,

00:36:32.789 --> 00:36:36.529
"See I don't need this stuff, you know,
nothing changed", yeah, except, of course,

00:36:36.530 --> 00:36:38.840
when you hit a subsystem that actually
cares about code signing.

00:36:38.840 --> 00:36:45.610
If you hit the keychain, if you actually try to create or
fetch a keychain item, then the system does suddenly care

00:36:45.610 --> 00:36:51.470
and it will say things like "The authenticity
of your program cannot be verified",

00:36:51.469 --> 00:36:59.509
which is a very politically correct way of saying,
"I don't know who this guy is and I don't trust him".

00:36:59.510 --> 00:37:06.750
If you are accepting inbound network connections and the
user happens to have turned on the application Firewall,

00:37:06.750 --> 00:37:13.360
then the system cares and you may get a
dialogue that you wouldn't otherwise see.

00:37:13.360 --> 00:37:18.930
If you're running under parental controls, if the
user is a managed account, then it definitely cares

00:37:18.929 --> 00:37:24.779
because we're using code signing to decide
whether a particular program is allowed to run.

00:37:24.780 --> 00:37:31.769
So depending which subsystem you happen to be
touching on, you'll see different kinds of behaviors,

00:37:31.769 --> 00:37:36.820
anything from on the one end, "Yeah, we don't
care, we'll just fake it", to on the other end,

00:37:36.820 --> 00:37:39.390
"I'm not going to deal with you and you can't have it".

00:37:39.389 --> 00:37:45.500
If you're writing a debugger, I know, who does, but
if you were writing a debugger or performance tool

00:37:45.500 --> 00:37:49.269
or something along those lines, you will find
that some of the system calls just won't work

00:37:49.269 --> 00:37:53.889
for you anymore unless you're code
signed in a particular way.

00:37:53.889 --> 00:37:56.869
And you get it all all the way in between.

00:37:56.869 --> 00:38:02.960
The keychain actually bends over backwards to still
sort of kind of try to work with unsigned programs,

00:38:02.960 --> 00:38:07.030
which is kind of cheap because all we
do is we left the Tiger code in there.

00:38:07.030 --> 00:38:13.019
So, seriously, if you're unsigned and you work
with the keychain, you are running Tiger code.

00:38:13.019 --> 00:38:16.210
How much testing do you think that's getting these days?

00:38:16.210 --> 00:38:23.980
So if you want to be first class code, if you
want to run with the big boys, sign your code.

00:38:23.980 --> 00:38:27.889
And, of course, you know, you're shipping updates,
the system goes "I don't know who that is",

00:38:27.889 --> 00:38:32.889
so software updates won't be recognized
by any of these subsystems.

00:38:32.889 --> 00:38:34.819
Parental controls will go, "I don't know what that is".

00:38:34.820 --> 00:38:37.260
The Firewall will go, "Are you sure you want this?"

00:38:37.260 --> 00:38:39.170
Keychain will say, "Do you want to allow access?"

00:38:39.170 --> 00:38:40.590
Dialogs, dialogs.

00:38:40.590 --> 00:38:43.600
Everybody hates dialogs.

00:38:43.599 --> 00:38:44.880
Now, here's a flip side to this.

00:38:44.880 --> 00:38:46.510
You did everything right.

00:38:46.510 --> 00:38:47.730
You signed your code.

00:38:47.730 --> 00:38:48.579
You shipped it.

00:38:48.579 --> 00:38:55.400
You were really careful with your software updates, but
something went wrong, usually, by your update mechanism.

00:38:55.400 --> 00:38:57.639
And now the signature's broken.

00:38:57.639 --> 00:38:59.289
So what happens then?

00:38:59.289 --> 00:39:03.500
What happens to your poor defenseless code?

00:39:03.500 --> 00:39:07.070
Unsigned code is considered to have no reliable identity.

00:39:07.070 --> 00:39:11.300
It says it's your program, but who knows.

00:39:11.300 --> 00:39:17.220
Code that is signed that looks signed
but has a broken signature is considered

00:39:17.219 --> 00:39:19.859
to have no identity at all, not even a tentative one.

00:39:19.860 --> 00:39:25.960
Anytime the system has 2 incidents, the answer is,
"We don't know, mystery anonymous, don't know."

00:39:25.960 --> 00:39:30.869
So that means that anytime you're
making an API call that's--

00:39:30.869 --> 00:39:34.789
has access controls based on who
you are, you just won't get it.

00:39:34.789 --> 00:39:42.570
And that's considerably more strict than for unsigned
code because you're not on the legacy path anymore,

00:39:42.570 --> 00:39:45.019
you're on a "something went wrong here" path.

00:39:45.019 --> 00:39:48.719
In particular, you won't be able
to get access to keychain items.

00:39:48.719 --> 00:39:50.519
The system will not even put up a dialog.

00:39:50.519 --> 00:39:56.309
There is, by default, no dialog that says this
application of yours that has a broken signature wants

00:39:56.309 --> 00:39:59.590
to get a keychain item, do you want to allow this anyway.

00:39:59.590 --> 00:40:04.970
You-- the call just fails because clearly there's something
wrong with your program and we don't want your program

00:40:04.969 --> 00:40:11.059
to get anywhere near its secrets if
clearly its identity has been messed up.

00:40:11.059 --> 00:40:14.860
Something that's not so obvious is if
your-- if you've lost your identity,

00:40:14.860 --> 00:40:17.690
you also can't create keychain items, why is that?

00:40:17.690 --> 00:40:22.429
>> Well, there's access control
lists attached to each keychain item

00:40:22.429 --> 00:40:25.500
that says who's allowed to access it, which applications.

00:40:25.500 --> 00:40:30.650
So when we make a new keychain item by default, we put
in an access control list entry that says the creator,

00:40:30.650 --> 00:40:35.849
the application that made the creation call, is allowed to
have access to this item, what do you think is in there?

00:40:35.849 --> 00:40:36.670
Code signing identity.

00:40:36.670 --> 00:40:43.559
If you don't have an identity, we can't
make that ACL entry and so it fails.

00:40:43.559 --> 00:40:47.659
Once a code signature is broken, it's broken.

00:40:47.659 --> 00:40:51.349
The system does not try to fix code signatures.

00:40:51.349 --> 00:40:52.949
This is really important.

00:40:52.949 --> 00:40:56.799
We can't because we have no idea what went wrong.

00:40:56.800 --> 00:40:59.840
It could just be that, you know, you got a file wrong,

00:40:59.840 --> 00:41:05.110
it could be that some over zealous disk cleaning
program went over and removed one file to many.

00:41:05.110 --> 00:41:10.099
It could be that, you know, you've got a
virus running around or some worm hacking

00:41:10.099 --> 00:41:13.619
around in your programs making your user really unhappy.

00:41:13.619 --> 00:41:14.859
We can't distinguish these.

00:41:14.860 --> 00:41:20.780
All we know is, you know, something is wrong with your
program, so the situation will simply stay that way

00:41:20.780 --> 00:41:26.560
and if the thing that's wrong is a static problem,
something on the hard drive got messed up, you know,

00:41:26.559 --> 00:41:31.409
the user needs to recover by restoring a
backup or by reinstalling your application.

00:41:31.409 --> 00:41:36.029
You know, do some things that make
the situations on disk be OK again.

00:41:36.030 --> 00:41:41.780
If the problem is that the program got
dynamically invalidated, remember I told you,

00:41:41.780 --> 00:41:46.400
you can always say make me invalid right
now and it sticks, because if you don't,

00:41:46.400 --> 00:41:49.130
you're about to do something that makes you untrustworthy.

00:41:49.130 --> 00:41:54.450
So, if that happens, then the program will stay invalid
until it quits so you can tell the user to quit it,

00:41:54.449 --> 00:41:58.460
relaunch it, and not do that thing again,
whatever that was that caused the invalidity.

00:41:58.460 --> 00:42:06.990
Now that was all really abstract, so let
me give you a couple of practical examples.

00:42:06.989 --> 00:42:12.129
These area all Apple applications 'cause,
you know, we started using this first,

00:42:12.130 --> 00:42:14.890
but there's nothing Apple magic about it.

00:42:14.889 --> 00:42:19.389
Remember the picture I showed you earlier
on how to solve flaws together starting

00:42:19.389 --> 00:42:21.659
with you building the application and shipping it?

00:42:21.659 --> 00:42:28.329
the part that we're interested in is where the sign code
actually gets run and then we feed a code requirement

00:42:28.329 --> 00:42:34.949
to the validation API and the code requirement needs to
be stored in some database or configuration somewhere.

00:42:34.949 --> 00:42:41.349
It's really the nature of a code requirement and the way it
gets stored that's different in the different applications.

00:42:41.349 --> 00:42:44.679
The rest of the machinery is very standard.

00:42:44.679 --> 00:42:45.819
There's very little change there.

00:42:45.820 --> 00:42:51.820
You've got a couple of flags you can pass
in for making things faster or slower.

00:42:51.820 --> 00:42:58.980
But it's the code requirement and how it gets
stored that distinguishes the interesting cases.

00:42:58.980 --> 00:43:03.460
Let's start with the application
Firewall which was new in Leopard.

00:43:03.460 --> 00:43:10.210
The application Firewall is trying to restrict
who can accept inbound network connections,

00:43:10.210 --> 00:43:16.230
and remember it's all by default these days so if
you want to test this out, you need to turn it on.

00:43:16.230 --> 00:43:26.570
Its policy is to look at the code identity of the caller
to accept certain system trusted code signatures as is

00:43:26.570 --> 00:43:29.740
without dialog and anything-- anybody else who asked

00:43:29.739 --> 00:43:35.079
for inbound network connection gets a
dialog, I showed it here on the right.

00:43:35.079 --> 00:43:40.449
And if you click-- if the user clicks on the Allow
button, we remember the Designated Requirement

00:43:40.449 --> 00:43:43.789
of the callers so next time we can recognize it.

00:43:43.789 --> 00:43:49.779
The application Firewall stores these code
requirements in a system database that's secured just

00:43:49.780 --> 00:43:53.580
by route privileges because this is per system facility.

00:43:56.010 --> 00:44:02.380
Keychains, keychain's access control list, I've already
told you, contain a list of applications that are allowed

00:44:02.380 --> 00:44:11.210
to access a particular keychain item and this is
the dialog that you get when you're not on the list.

00:44:11.210 --> 00:44:15.710
The policy that the keychain machinery
uses is completely explicit.

00:44:15.710 --> 00:44:18.769
Whatever is in that list that's what we allow.

00:44:18.769 --> 00:44:26.329
And each of the application entries in the access control
list is a code requirement, that's how we remember it,

00:44:26.329 --> 00:44:29.909
that's how the keychain machinery remembers applications.

00:44:29.909 --> 00:44:32.869
So in this particular case, there is no system database.

00:44:32.869 --> 00:44:35.949
There is no global file anywhere
in the system that says, "You know,

00:44:35.949 --> 00:44:39.309
Mail is allowed to access you're me.com password."

00:44:39.309 --> 00:44:44.469
There are code requirements stored right there
with the keychain item in the keychain and secured

00:44:44.469 --> 00:44:46.819
by the keychain's proprietary of course,

00:44:46.820 --> 00:44:52.090
and the verification happens whenever
somebody asks for access to a keychain item.

00:44:52.090 --> 00:45:00.700
There is a new feature in Snow Leopard called Service
Manager which is kind of an interesting example

00:45:00.699 --> 00:45:05.149
of how easily you can get certain things
done with code signing that were kind

00:45:05.150 --> 00:45:08.599
of almost impossible to get right before.

00:45:08.599 --> 00:45:15.099
And when a program has a privileged Helper,
you know, we keep telling you, you know,

00:45:15.099 --> 00:45:21.420
factor out your privilege operations, put them in the
little Helper, you know, yeah, there's sample code

00:45:21.420 --> 00:45:26.480
and there's many-- lines of sample code,
but the problem keeps coming up, you know.

00:45:26.480 --> 00:45:28.670
OK, factor your program, you have a little Helper now.

00:45:28.670 --> 00:45:29.880
How do you install the Helper?

00:45:29.880 --> 00:45:36.190
We tell you to use launchd to launch the Helper which
means you need to install a launchd configuration

00:45:36.190 --> 00:45:40.760
and the privileges for that so we are back
to I need privilege string installation.

00:45:40.760 --> 00:45:47.570
Well, the Service Manager is trying to make it a lot
easier in Snow Leopard, it doesn't exist in Leopard.

00:45:47.570 --> 00:45:54.250
What it does is you've got your application and
you've got the Helper that you've factored out.

00:45:54.250 --> 00:46:01.590
And instead of using things like authorization or
UID checks or whatever it is that you'd normally use

00:46:01.590 --> 00:46:08.340
to authorize the installation of the Helper in
launch-d and then the launching of the Helper,

00:46:08.340 --> 00:46:14.809
what you is the applications info.plists simply contains
the code requirement for the Helper identifying the Helper

00:46:14.809 --> 00:46:18.299
and the Helper gets an info.plist
that identifies the application

00:46:18.300 --> 00:46:22.019
so that the 2 essentially point at
each other and say, "This one's mine.

00:46:22.019 --> 00:46:24.480
I'm happy to work with this guy".

00:46:24.480 --> 00:46:28.190
And remember that info.plists are
secured for the code signatures.

00:46:28.190 --> 00:46:32.550
So this is, you know, the classic worm biting its tail.

00:46:32.550 --> 00:46:38.620
It's secured because they are both referring to each
other and securing each other's identities this way.

00:46:38.619 --> 00:46:44.710
So again, there's no global database anywhere that
says which Helpers belong to which application.

00:46:44.710 --> 00:46:49.220
It's distributed in the applications
in the Helpers in the info.plists

00:46:49.219 --> 00:46:53.969
and what code signing does is it
secures these relationships.

00:46:53.969 --> 00:47:00.569
So it's a pretty straightforward application of code
signing, but it's an interesting one nonetheless.

00:47:00.570 --> 00:47:08.190
And of course, it's API now and you
can come up with your own ideas.

00:47:08.190 --> 00:47:13.889
Let me just go through a couple
of points that need to be said.

00:47:13.889 --> 00:47:18.949
The cryptographic signing identities in your
keychains have an industry-standard format.

00:47:18.949 --> 00:47:27.539
It's, you know, RFC 2459 and the dozens of RFCs
that are mended and modified and make changes to it.

00:47:27.539 --> 00:47:28.449
You can make your own.

00:47:28.449 --> 00:47:32.799
I showed you how to do that in the simplest
case with the Certificate Assistant.

00:47:32.800 --> 00:47:40.380
The Certificate Assistant can also make interesting
CAs that can actually build certificate chains to you,

00:47:40.380 --> 00:47:43.680
so instead of 2 minutes, that takes
10 minutes but it can be done.

00:47:43.679 --> 00:47:49.059
If you'd rather you can buy your signing identities
from a commercial CA, that's fine too, we don't care.

00:47:49.059 --> 00:47:49.969
We don't tell you to do it.

00:47:49.969 --> 00:47:51.809
We don't tell you not to do it.

00:47:51.809 --> 00:47:57.880
And of course on the iPhone, you get it as
part of the page developer iPhone program.

00:47:57.880 --> 00:48:01.880
No matter how you get them, you store them
in keychains, you don't get a choice there,

00:48:01.880 --> 00:48:05.070
there is no "But what if I don't
want to use keychains," you do.

00:48:05.070 --> 00:48:09.070
If you got it from somebody else, say in
some other form, it's probably in PKCS12

00:48:09.070 --> 00:48:14.610
which is the industry-standard exchange format for
cryptographic identities, so just input that in a keychain.

00:48:14.610 --> 00:48:20.840
You may want to make a separate keychain and put it
just in there if you're paranoid but keychains it is.

00:48:20.840 --> 00:48:22.430
No choice there.

00:48:23.849 --> 00:48:30.579
There is a particular mode of signing that
you may run into called ad-hoc signing.

00:48:30.579 --> 00:48:35.219
In some situations, a subsystem just
can't deal with unsigned code anymore,

00:48:35.219 --> 00:48:39.230
application Firewall, parental controls are examples.

00:48:39.230 --> 00:48:43.679
And what they do when they run into unsigned
code like yours is, they simply write there

00:48:43.679 --> 00:48:45.599
on the spot the first time they see it,

00:48:45.599 --> 00:48:51.699
they apply a signature that's called an ad-hoc
signature and no, that's not a good thing.

00:48:51.699 --> 00:48:52.960
That's actually a pretty bad thing.

00:48:52.960 --> 00:48:56.240
It's sort of a last ditch emergency
measure because otherwise,

00:48:56.239 --> 00:49:00.519
we just have to kick you out, and
we're just too nice for that.

00:49:00.519 --> 00:49:05.809
So, an ad-hoc signature doesn't know who signed the stuff.

00:49:05.809 --> 00:49:09.619
It can't place the cryptographic
identity to secure this so it doesn't--

00:49:09.619 --> 00:49:15.589
the last best thing and it just takes
the narrowest possible code identity,

00:49:15.590 --> 00:49:20.730
the one that only satisfies this very one program that's
sitting there on disk that we're staring at right now

00:49:20.730 --> 00:49:28.130
and it forms an identity for just that, which
is good enough to get, say the Firewall going

00:49:28.130 --> 00:49:31.960
but well, there's a couple of problems with it.

00:49:31.960 --> 00:49:35.179
Obviously, we can't track updates
because if you change it, it's different,

00:49:35.179 --> 00:49:38.109
we have no idea that it's meant to be an update.

00:49:38.110 --> 00:49:41.809
But more to the point, this changes your program.

00:49:41.809 --> 00:49:50.179
We've had some game developers who thought they were being
really, really paranoid, applying their own integrity checks

00:49:50.179 --> 00:49:56.159
on their programs and the first time they hit the
application Firewall, they failed their own integrity check

00:49:56.159 --> 00:50:01.649
because we signed them and that changed
it and that failed their integrity check.

00:50:01.650 --> 00:50:04.289
So ad-hoc signing is not your friend.

00:50:04.289 --> 00:50:06.960
It's not even your buddy.

00:50:06.960 --> 00:50:09.190
Also, ad-hoc signing is architecture specific.

00:50:09.190 --> 00:50:12.539
It's whichever architecture happens
to be running at the time.

00:50:12.539 --> 00:50:21.599
>> If you run on a 32-bit laptop say, guess this, it'll run
out there, and then you transfer the program or you migrate

00:50:21.599 --> 00:50:27.539
to a 64-bit machine, the ad-hoc signatures
will not be same, so emergency measure.

00:50:27.539 --> 00:50:31.340
OK, I don't have time to talk very much about the API.

00:50:31.340 --> 00:50:32.280
It's in the Snow Leopard.

00:50:32.280 --> 00:50:33.570
You've got your seat.

00:50:33.570 --> 00:50:37.490
The head of files have had a DOC in them and
that's pretty much the primary documentation

00:50:37.489 --> 00:50:40.799
in addition to the stuff on the developer website.

00:50:40.800 --> 00:50:42.590
So rode around and play around with it.

00:50:42.590 --> 00:50:45.670
It's, you know, I think it's great fun.

00:50:45.670 --> 00:50:47.070
The API is new in Snow Leopard.

00:50:47.070 --> 00:50:49.480
It wasn't public in Leopard.

00:50:49.480 --> 00:50:57.809
There's a client API that essentially lets you
validate identities, built references to running code

00:50:57.809 --> 00:51:02.009
and static code, and manipulate code requirements.

00:51:02.010 --> 00:51:08.020
There is a separate hosting API that you only need to
touch if you are writing a code host, an interpreter,

00:51:08.019 --> 00:51:13.869
a code manager, something running,
lets of some sort, applets, you know.

00:51:13.869 --> 00:51:17.769
There is no API, no public API
for actually signing code yet.

00:51:17.769 --> 00:51:23.849
So as of Snow Leopard, you still get to run the code
sign command if you need to programatically sign code.

00:51:23.849 --> 00:51:29.360
The underlying API objects are CoreFoundation
objects and I mean that, they actually are.

00:51:29.360 --> 00:51:30.140
They don't look alike.

00:51:30.139 --> 00:51:31.029
They don't smell alike.

00:51:31.030 --> 00:51:37.550
They actually are CoreFoundation objects so you can do
anything with them that you do with the CF something,

00:51:37.550 --> 00:51:43.280
you know, CFRetain it, CFRelease it, whatever
in the CF dictionary, you know, all that stuff.

00:51:43.280 --> 00:51:48.780
There is a secCodeRef that are referred to running
codes, secStaticCodeRefs referring to code on disk.

00:51:48.780 --> 00:51:52.560
When you do that, you want to think about
whether that's really what you want,

00:51:52.559 --> 00:51:57.869
and secRequirementRefs for the internal
representation form of code requirements.

00:51:57.869 --> 00:52:01.519
These objects are local write--
they are in your address space.

00:52:01.519 --> 00:52:04.559
They refer to things out there in the system.

00:52:04.559 --> 00:52:09.570
So if you have like secCodeRef, it refers to a
particular piece of code out here, a process running,

00:52:09.570 --> 00:52:12.500
a script being run by some other program.

00:52:12.500 --> 00:52:19.710
But if you have 3 processes doing validation on the same
piece of code, they each get the separate secCodeRefs.

00:52:19.710 --> 00:52:27.449
It's an important architectural feature of code
signing that validation happens in the client space.

00:52:27.449 --> 00:52:33.819
So whoever is interested in the identity of a
program and its integrity gets to do the validation.

00:52:33.820 --> 00:52:40.150
So there's no server or daemon out there that keeps that for
you and just tells you it's blessed, it's good, trust me.

00:52:40.150 --> 00:52:42.360
Everybody gets to do their own validation.

00:52:42.360 --> 00:52:49.220
This is the top list of things that go wrong in practice.

00:52:49.219 --> 00:52:53.649
It's a much-- there's a much longer list of what could go
wrong but this is what people actually run into often enough

00:52:53.650 --> 00:52:55.550
to keep asking about it on the mailing list.

00:52:55.550 --> 00:52:58.640
So I'll just try to save you in trouble and tell you.

00:52:58.639 --> 00:53:02.309
Code does not go into the Resources directory.

00:53:02.309 --> 00:53:08.179
I know that Xcode makes it really easy to stick stuff into
the Resources directory of a bundle, just don't do it.

00:53:08.179 --> 00:53:13.399
Resources directory contains resources,
code, Helpers, don't go there.

00:53:13.400 --> 00:53:19.340
Put them in the Mac OS directory or put them in the
contents directory or put them in a Helper's directory,

00:53:19.340 --> 00:53:21.570
that's something people out there are trying to get started.

00:53:21.570 --> 00:53:26.350
Code signing does not care as long as
it's not in the Resources directory.

00:53:26.349 --> 00:53:29.219
Don't change your code after you sign it.

00:53:29.219 --> 00:53:34.459
I mean that seems pretty obvious but there is
many ways you can accidentally do it anyway.

00:53:34.460 --> 00:53:42.220
If your workflow calls for building the program and then
sending it over to some different department to master it,

00:53:42.219 --> 00:53:45.919
then finding as part of the building
is probably not what you want.

00:53:45.920 --> 00:53:53.050
You want to build-- you want to sign after mastering
because mastering tends to change the files in your bundle.

00:53:53.050 --> 00:53:59.390
If you are outsourcing localization, keep in mind that
you need to have the full bundle when you sign it,

00:53:59.389 --> 00:54:02.250
all the localizations that you want to be valid.

00:54:02.250 --> 00:54:10.110
So you can't sign a program, ship it, and then have somebody
else provide localizations later that weren't there before.

00:54:10.110 --> 00:54:13.610
Localizations can be removed after signing.

00:54:13.610 --> 00:54:23.570
There is an understanding in the machinery by default that
it's OK to remove localization files but not add them.

00:54:23.570 --> 00:54:30.360
If you're having one of those nice installers with
the, you know, special options to say which parts

00:54:30.360 --> 00:54:34.920
of the bundle you want to install and which
ones not, that's probably not going to work

00:54:34.920 --> 00:54:37.829
because the code signature is an all or nothing thing.

00:54:37.829 --> 00:54:40.250
Either all the files are here or not.

00:54:40.250 --> 00:54:41.820
So optional installs.

00:54:41.820 --> 00:54:45.590
You probably better off restructuring
to put them into separate bundles.

00:54:45.590 --> 00:54:53.289
If you absolutely can't, you do have access to what we call
resource specification lists which is essentially a list

00:54:53.289 --> 00:54:59.559
of regular expressions determining what resources are
really resources and which ones should be ignored.

00:54:59.559 --> 00:55:07.920
That lets you point that particular resource files and
say those are optional, just like the localizations.

00:55:07.920 --> 00:55:13.680
If you think it's really cool to make up a bundle
with symbolic links pointing somewhere else,

00:55:13.679 --> 00:55:18.649
"Oh look I made a bundle from pieces,"
don't, don't go there, bad idea.

00:55:18.650 --> 00:55:22.539
But of course if your code is self-modifying,
you know, you're not even getting

00:55:22.539 --> 00:55:27.519
to the starting block here, self-modifying
code is just that.

00:55:27.519 --> 00:55:28.829
More information.

00:55:28.829 --> 00:55:32.460
Craig Keithley, the Omnibus Technology Evangelist.

00:55:32.460 --> 00:55:33.210
He's over there.

00:55:33.210 --> 00:55:35.139
He will be on the stage in a moment.

00:55:35.139 --> 00:55:38.049
He would love to answer more questions.

00:55:38.050 --> 00:55:44.920
The main pages for code signing are pretty good, probably
not complete but if you don't find something there

00:55:44.920 --> 00:55:46.619
that you think should be there, file a Radar.

00:55:46.619 --> 00:55:53.469
There is a little utility called CSreq that
lets you manipulate code signing requirements in files,

00:55:53.469 --> 00:55:57.059
convert them between text and binary and
backwards and verify them, stuff like that.

00:55:57.059 --> 00:56:02.289
And there is an increasing set of
documentation on the Apple developer website.

00:56:02.289 --> 00:56:07.969
The API reference, you still need to log in as a
registered developer because it's a Snow Leopard feature.

00:56:07.969 --> 00:56:09.629
The other ones are already publicly there.
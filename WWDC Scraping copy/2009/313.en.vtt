WEBVTT

00:00:12.550 --> 00:00:13.980
>> Good morning.

00:00:13.980 --> 00:00:20.390
My name is Roger Pantos and I work on the
QuickTime engineering team here at Apple.

00:00:20.390 --> 00:00:27.429
And today what I'd like to talk to you about
is how with iPhone OS 3.0 or Snow Leopard,

00:00:27.429 --> 00:00:33.710
you can watch live streams on your devices using HTTP.

00:00:33.710 --> 00:00:40.899
Now for some of you, that whole notion is like coming
out of nowhere, so let me set that up a little bit

00:00:40.899 --> 00:00:43.909
for you by looking at some recent history.

00:00:43.909 --> 00:00:50.000
The iPhone has always been able to
play back movies over the network.

00:00:50.000 --> 00:00:58.350
Using HTTP content requests, we were able to provide
a really high quality user experience essentially

00:00:58.350 --> 00:01:05.400
by playing static movie files off of HTTP servers,
and we call that technique progressive download.

00:01:05.400 --> 00:01:09.620
It works extremely well for content
that's already been produced

00:01:09.620 --> 00:01:14.030
such as podcasts or video podcasts, or even YouTube.

00:01:14.030 --> 00:01:18.049
And it has been extremely popular on the iPhone.

00:01:18.049 --> 00:01:25.229
In fact, YouTube is one of the most
popular applications we ship on the iPhone.

00:01:25.230 --> 00:01:32.340
But the moment we supported it, we immediately
started getting another feature request.

00:01:32.340 --> 00:01:34.240
What about live content?

00:01:34.239 --> 00:01:39.659
People wanted to be able to watch events
as they were occurring on their phones.

00:01:39.659 --> 00:01:44.649
They wanted to be able to watch newscasts;
they wanted to be able to watch baseball games.

00:01:44.650 --> 00:01:52.930
And so when we decided to address this, we
started by figuring out what our goals would be.

00:01:52.930 --> 00:02:00.580
The first thing we decided was we wanted
to build something that would be tuned

00:02:00.579 --> 00:02:05.539
for large-scale broadcast-style content delivery.

00:02:05.540 --> 00:02:11.280
We wanted something that would scale
up to millions of simultaneous viewers.

00:02:11.280 --> 00:02:18.810
Now one of the things we have learned from our previous
experience with streaming is that if you have to build

00:02:18.810 --> 00:02:24.990
up your own infrastructure to scale to that
level of demand, it can be extremely expensive.

00:02:24.990 --> 00:02:29.659
And for a lot of companies, that
expense is cost prohibitive.

00:02:29.659 --> 00:02:37.349
So in addition to being scalable, we also wanted to build
something that would scale in a way that was cost effective.

00:02:37.349 --> 00:02:44.199
Another thing we learned from our streaming experience was
that we wanted something that would negotiate firewalls

00:02:44.199 --> 00:02:49.009
and NATs, network address translation
boxes, fairly effectively.

00:02:49.009 --> 00:02:57.590
This improves the user experience and it reduces our
customer support cost, and it also reduces yours.

00:02:57.590 --> 00:03:00.740
Finally, we wanted to build something that was easy.

00:03:00.740 --> 00:03:09.580
We wanted it to be easy to adopt, and we wanted it to be
easy to interoperate with the existing production systems

00:03:09.580 --> 00:03:13.670
that content producers have for producing live streams.

00:03:13.669 --> 00:03:18.309
One of the keys to doing this was
to leverage existing standards.

00:03:18.310 --> 00:03:23.770
So we sat down with these goals, and
when we started thinking about them,

00:03:23.770 --> 00:03:29.460
we concluded pretty quickly that we wanted to use HTTP.

00:03:29.460 --> 00:03:32.240
We have a lot of experience with HTTP and we like it a lot.

00:03:32.240 --> 00:03:36.310
It is extremely widely deployed and well supported.

00:03:36.310 --> 00:03:40.729
Just about every company in the world now has
a website, and there are a lot of companies

00:03:40.729 --> 00:03:44.840
that have really highly-skilled people
who can make those websites sing.

00:03:44.840 --> 00:03:54.670
The other thing about HTTP is that it has demonstrated
the ability to deliver massive amounts of data.

00:03:54.669 --> 00:04:01.409
Just at Apple, we deliver hundreds of
gigabytes everyday just in software updates.

00:04:01.409 --> 00:04:08.030
There are a number of proven techniques that
you can use to scale HTTP to high demand.

00:04:08.030 --> 00:04:12.469
You can offload a single server
by using server load balancing.

00:04:12.469 --> 00:04:18.490
You can create caching proxies that will
help you scale your demand geographically.

00:04:18.490 --> 00:04:24.910
And finally, there is an entire industry of companies,
the so-called content delivery networks, CDNs,

00:04:24.910 --> 00:04:28.010
Akamais, Limelights, people like that,

00:04:28.009 --> 00:04:36.129
that is set up to essentially rent you
the capacity to scale HTTP on-demand.

00:04:36.129 --> 00:04:41.790
And so it's an extremely cost effective way of delivering
massive amounts of information over the internet.

00:04:41.790 --> 00:04:50.950
Finally, HTTP is extremely adept at passing through
firewalls, and because it's so popular on the internet,

00:04:50.949 --> 00:04:57.870
just about every network address translation
box is preconfigured to support out of the box.

00:04:57.870 --> 00:05:02.730
This is extremely important particularly for iPhone users,

00:05:04.189 --> 00:05:10.889
because iPhones will often access a
network through a NATed Wi-Fi hotspot.

00:05:10.889 --> 00:05:17.250
And some of these hotspots are in places like airports and
coffee shops where even if the user was knowledgeable enough

00:05:17.250 --> 00:05:21.129
to reconfigure the NAT, they have
no administrative access to it.

00:05:21.129 --> 00:05:28.980
So it was really important to find a solution
that would work well with firewalls and NATs.

00:05:28.980 --> 00:05:36.810
The thing about HTTP though, is that it's really
tuned, it's really optimized, it's really prioritized

00:05:36.810 --> 00:05:42.990
to delivering static files, that's what all the
third-party supported products are designed for,

00:05:42.990 --> 00:05:48.900
that's what all the infrastructure
has really been set up for.

00:05:48.899 --> 00:05:54.219
And so, but you have to ask yourself,
OK, how do we take something like HTTP

00:05:54.220 --> 00:05:59.860
that really delivers those static
files and deliver live streams over it?

00:05:59.860 --> 00:06:07.230
Well, the first approach you can think of is
probably not too far from what we're actually doing.

00:06:07.230 --> 00:06:11.350
Let's take a look.

00:06:11.350 --> 00:06:17.950
What we do is up there on the left, we
start with a live audio/video signal.

00:06:17.949 --> 00:06:22.479
This signal could be coming directly from a
camera, it could be coming off a satellite feed,

00:06:22.480 --> 00:06:25.420
it could even be coming off a tape deck, whatever.

00:06:25.420 --> 00:06:30.009
We take that audio/video signal and
we feed it into a media encoder.

00:06:30.009 --> 00:06:39.990
Now what this media encoder will do is, digitize the signal,
encode it, and produce a continuous stream of digital media.

00:06:39.990 --> 00:06:44.180
That stream of digital media is
then sent to the segmenter step.

00:06:44.180 --> 00:06:50.449
What we do in the segmenter is, we divide
that continuous stream of digital media

00:06:50.449 --> 00:06:54.319
into a series of individual segment files.

00:06:54.319 --> 00:06:58.969
And typically each segment file has
about the same duration of media,

00:06:58.970 --> 00:07:03.650
so for instance each segment file
might be ten seconds of media.

00:07:03.649 --> 00:07:08.199
Once we have these individual segment files, we
have something that we can place on a web server

00:07:08.199 --> 00:07:13.039
and that can then use the native
capabilities of HTTP to distribute

00:07:13.040 --> 00:07:17.010
through the cloud to our clients on the other end.

00:07:17.009 --> 00:07:21.579
So now what I'd like to do is take a look at this in action,

00:07:21.579 --> 00:07:26.039
and so I'm going to invite my colleague,
Bill May, come up on stage.

00:07:26.040 --> 00:07:31.430
And what we're going to show you is
a third-party application from CNN,

00:07:31.430 --> 00:07:35.759
I think we showed it to you a little
earlier in the week as well.

00:07:35.759 --> 00:07:40.839
It's the cnn.com application, so Bill is going
to click it here and it's going to come up.

00:07:40.839 --> 00:07:43.889
The first thing it's going to do is, it's
going to go off the network and it's going

00:07:43.889 --> 00:07:46.050
to populate itself with some news of the day.

00:07:46.050 --> 00:07:49.150
There's a live tab down at the bottom, Bill has clicked it.

00:07:49.149 --> 00:07:53.209
And so now you can see the live
features of the CNN application.

00:07:53.209 --> 00:07:59.739
So if you tap on that large picture at
the top, that will launch the live feed.

00:07:59.740 --> 00:08:01.610
And so it's launching here now.

00:08:01.610 --> 00:08:04.230
>> And [phoen audio] accuracy is very important -

00:08:04.230 --> 00:08:04.950
>> And here we are.

00:08:04.949 --> 00:08:05.509
There we go, OK.

00:08:05.509 --> 00:08:08.300
>> She's a record holder now, she holds three now -

00:08:08.300 --> 00:08:08.699
>> Wow.

00:08:08.699 --> 00:08:11.009
>> -- world records.

00:08:11.009 --> 00:08:17.089
[ Applause ]

00:08:17.089 --> 00:08:20.469
>> And it looks great, it's really fantastic.

00:08:20.470 --> 00:08:23.520
And the cnn.com developers were able to add this capability

00:08:23.519 --> 00:08:27.139
to their application really with
just a couple of lines of code.

00:08:27.139 --> 00:08:33.509
And so it's very simple to watch CNN on
your phone, but it's also very awesome.

00:08:33.509 --> 00:08:36.250
And so we're really excited about that.

00:08:36.250 --> 00:08:41.220
What we're going to do next is take you a little bit behind
the scenes and show you the equipment we were actually using

00:08:41.220 --> 00:08:45.410
to demonstrate, to put together that demo.

00:08:45.409 --> 00:08:52.199
In this case, the audio/video input that we were starting
from was originating at the CNN broadcast center in Atlanta.

00:08:52.200 --> 00:08:57.050
The audio/video signal was being sent
into an Inlet Technologies Spinnaker 7000.

00:08:57.049 --> 00:09:03.229
Now this is a box that can consume an analog
signal and produce an MPEG2 transport stream.

00:09:03.230 --> 00:09:10.840
So we take that MPEG2 transport stream and we
send it via multi-cast UDP across a local network

00:09:10.840 --> 00:09:14.440
to a segmenter program that's running on an XServe.

00:09:14.440 --> 00:09:21.180
The segmenter program consumes the transport stream,
divides it up into a series of segment files,

00:09:21.179 --> 00:09:27.149
and places it onto a web server which then
acts as an origin to the Akamai network.

00:09:27.149 --> 00:09:29.250
The iPhone we have up here on the stage was able

00:09:29.250 --> 00:09:33.950
to pull those files off a local edge
server from Akamai here in San Francisco.

00:09:33.950 --> 00:09:38.570
That's kind of the marketing level overview.

00:09:38.570 --> 00:09:44.890
What I'd like to do next talk a little bit
more about how the actual protocol works.

00:09:44.889 --> 00:09:54.029
So as I said, we start by having a server that converts
a continuous stream of media into segment files.

00:09:54.029 --> 00:09:58.129
As it's writing these segment files to
disc, it's also maintaining a playlist file.

00:09:58.129 --> 00:10:02.879
And now a playlist file is essentially
just a file that has a list of all

00:10:02.879 --> 00:10:05.769
of the segment files that are available on the server.

00:10:05.769 --> 00:10:12.350
So when we want to play, the way it works is, the
client starts by downloading the playlist file,

00:10:12.350 --> 00:10:17.960
now it has a list of all the available segments, it
downloads each segment in turn and then plays them.

00:10:17.960 --> 00:10:24.680
In the case of a live stream, after it's done that, it will
then go back to the server, redownload the playlist file,

00:10:24.679 --> 00:10:28.329
and see what's changed, see if there are new segments.

00:10:28.330 --> 00:10:37.860
So clearly the key to all of this is this notion of
a playlist file that is continuously being updated.

00:10:37.860 --> 00:10:40.370
So I want to show you how that looks.

00:10:40.370 --> 00:10:48.360
What we have up here is a diagram of a series of
segment files that have been produced by our segmenter.

00:10:48.360 --> 00:10:54.970
Those blue segment files in the box are the
files that actually appeared in the playlist.

00:10:54.970 --> 00:10:58.860
You'll notice off to the right we have segment number six.

00:10:58.860 --> 00:11:02.840
It's not in the playlist yet because
it's actually currently being written.

00:11:02.840 --> 00:11:10.210
Remember that we were going to write about ten seconds of
media into each file, and so we always have a current file

00:11:10.210 --> 00:11:15.050
that we're writing the media into, and maybe it's only two
or three seconds in, so it's not part of the playlist yet.

00:11:15.049 --> 00:11:23.769
But if we wait ten seconds and then down load that playlist
again, you'll see that now we have still three segments

00:11:23.769 --> 00:11:30.210
in the playlist file, but now segment six has
become the last segment in the playlist file.

00:11:30.210 --> 00:11:35.820
You'll also note that segment three is no longer in
a playlist file because we have a live playlist here,

00:11:35.820 --> 00:11:40.340
we have a fixed number of segment files
in the playlist at any given time.

00:11:40.340 --> 00:11:48.330
So as a new segment file is added to the
playlist, the old segment file rolls off the top.

00:11:48.330 --> 00:11:52.210
So let me show what a playlist file actually looks like.

00:11:52.210 --> 00:11:55.940
Here we go.

00:11:55.940 --> 00:12:01.740
When we went looking at the different playlist
file formats that had already been defined,

00:12:01.740 --> 00:12:06.029
we ended up choosing the M3U playlist file format.

00:12:06.029 --> 00:12:11.189
It's extremely popular on the internet
largely because it is extremely simple.

00:12:11.190 --> 00:12:19.650
An M3U file is essentially just a text file that contains
a list of URLs, each URL being a byte of media to play.

00:12:19.649 --> 00:12:25.740
The other thing an M3U file has in it are tags, these
are these things that are prefixed by hash mark.

00:12:25.740 --> 00:12:30.240
So that first tag you see up there, EXTM3U simply indicates

00:12:30.240 --> 00:12:35.379
that this text file is an extended
M3U playlist, that's thay guy there.

00:12:35.379 --> 00:12:41.100
The next tags, the ones that have the X in
them, are tags that we added to the M3U format

00:12:41.100 --> 00:12:43.590
to support this notion of a dynamic playlist.

00:12:43.590 --> 00:12:52.610
So this one here, TARGETDURATION, indicates to the client
that when new segments are added to the playlist file,

00:12:52.610 --> 00:12:58.580
the likely duration of each segment, the new segment
that will be added next, is probably going to be

00:12:58.580 --> 00:13:05.190
about ten seconds, and that is used as a hint to
the client when it's refreshing that playlist file.

00:13:05.190 --> 00:13:11.190
The next tag, the media sequence number,
indicates the media sequence number

00:13:11.190 --> 00:13:14.710
of the first URL that appears in the playlist.

00:13:14.710 --> 00:13:21.400
And what the client uses this for is to resync itself
inside the playlist when it refreshes the playlist,

00:13:21.399 --> 00:13:25.959
because it may not be refreshing a playlist
in sync with how the server is recreating it.

00:13:25.960 --> 00:13:32.980
And so right now the media sequence is one
and the first segment in the playlist is one.

00:13:32.980 --> 00:13:36.370
If we were to wait ten seconds and download it again,

00:13:36.370 --> 00:13:40.899
then you'll see segment one rolls off the
top, the media sequence number is two.

00:13:40.899 --> 00:13:47.340
And in fact, the first segment in the
playlist file is two, and so on and so forth.

00:13:47.340 --> 00:13:53.470
So those are the media sequence tags.

00:13:53.470 --> 00:13:58.320
That's essentially how the live playlist works.

00:13:58.320 --> 00:14:02.430
As new segments are added to the
bottom, all segments roll off the top.

00:14:02.429 --> 00:14:07.370
So now let's take a closer look at one of those
individual segments and see what kind of animals they are.

00:14:07.370 --> 00:14:15.990
The primary file format for segment
files is an MPEG2 transport stream.

00:14:15.990 --> 00:14:26.019
Now an MPEG2 transport stream is an industry
standard for the representation of continuous media.

00:14:26.019 --> 00:14:29.579
It is extremely popular in the broadcast industry.

00:14:29.580 --> 00:14:32.040
It is used by cable providers.

00:14:32.039 --> 00:14:36.099
It is used by over-the-air digital TV transmission.

00:14:36.100 --> 00:14:38.570
It is used by satellite providers.

00:14:38.570 --> 00:14:40.690
And in fact now it's also being used by Blu-ray.

00:14:40.690 --> 00:14:49.440
One of the advantages of the ubiquity of this standard
in the industry is that there are already a large number

00:14:49.440 --> 00:14:56.790
of third-party products, both hardware and software,
and also people who understand MPEG2 transport streams.

00:14:56.789 --> 00:15:01.099
One of the things about MPEG2 transport streams however,

00:15:01.100 --> 00:15:04.800
is that there is a certain amount
of overhead associated with them.

00:15:04.799 --> 00:15:10.039
Now this overhead is not such a big
deal when you have both audio and video,

00:15:10.039 --> 00:15:14.039
but it really starts to show up
when you have audio-only streams.

00:15:14.039 --> 00:15:21.959
So for this reason, we also support as a
supplementary format, MPEG elementary audio streams.

00:15:21.960 --> 00:15:28.220
And what these guys are, is essentially just a series
of audio packets catenated together into a file.

00:15:28.220 --> 00:15:38.470
And they're extremely well suited for delivering
high-quality audio at extremely low byte rates.

00:15:38.470 --> 00:15:43.730
Speaking of which, what kind of codecs
are we using inside these containers?

00:15:43.730 --> 00:15:46.310
Well there's no surprise here.

00:15:46.309 --> 00:15:50.659
MPEG2 transport streams contain audio and video.

00:15:50.659 --> 00:15:55.129
For the video, it's H.264.

00:15:55.129 --> 00:16:01.399
That means on the iPhone H.264 baseline profile, level 3.0.

00:16:01.399 --> 00:16:07.220
On a desktop machine where you've got
larger displays and some faster processors,

00:16:07.220 --> 00:16:13.509
we'll support currently up to H.264 high profile level 4.0.

00:16:13.509 --> 00:16:18.649
For audio, our recommendation is to use HE-AAC version one.

00:16:18.649 --> 00:16:24.389
And the reason we recommend it is because it
produces the highest audio quality at the sort

00:16:24.389 --> 00:16:26.740
of byte rates that we typically use for streaming.

00:16:26.740 --> 00:16:32.450
These byte rates typically for audio are between
32 kilobytes and 80 kilobytes per second.

00:16:32.450 --> 00:16:39.420
We also support the traditional low
complexity AAC as well as our old standby MP3.

00:16:39.419 --> 00:16:48.229
So if you have some media which is encoded with H.264
video, AAC audio, you put it into a transport stream,

00:16:48.230 --> 00:16:53.550
you chop it up into segments and stick it on
the web, you can play it in your application.

00:16:53.549 --> 00:16:54.409
How do you do it?

00:16:54.409 --> 00:16:56.289
Well it's easy.

00:16:56.289 --> 00:17:05.579
On the iPhone we play live HTTP streams using the
same API that we play for progressive download.

00:17:05.579 --> 00:17:10.859
The only difference is that the URL you feed
to the MPMoviePlayerController is the URL

00:17:10.859 --> 00:17:14.979
to the playlist file rather than to a static MP4 file.

00:17:14.980 --> 00:17:17.539
You can also play live streams in mobile Safari.

00:17:17.539 --> 00:17:26.690
And to do that, you'll use the HTML 5 video
tag, and you'll provide the URL of the M3U file

00:17:26.690 --> 00:17:30.150
as the source attribute of the video tag.

00:17:30.150 --> 00:17:39.370
On the desktop we can play HTTP live streams through QTKit.

00:17:39.369 --> 00:17:44.799
HTTP live streaming is one of the new
features of the QuickTime X support in QTKit,

00:17:44.799 --> 00:17:49.430
it's one of the benefits you get from
adopting QuickTime X in your application.

00:17:49.430 --> 00:17:54.890
And so the way you get it is use
the QTMovie initWithAttributes call,

00:17:54.890 --> 00:18:01.000
you set the QTMovieOpenForPlaybackAttribute
to yes to activate the QuickTime X support.

00:18:01.000 --> 00:18:07.480
And then you provide again the URL to the
playlist file as the QTMovie URL attribute.

00:18:09.109 --> 00:18:16.449
So that is essentially all you need to know to play live
streams on your applications, it's very straightforward.

00:18:16.450 --> 00:18:20.019
But I'm standing up here, I've got some
time, so I'd like to talk to you about a few

00:18:20.019 --> 00:18:22.990
of the more advanced features that
we offer in HTTP streaming.

00:18:22.990 --> 00:18:26.559
The first one is media encryption.

00:18:26.559 --> 00:18:32.710
A number of content owners care a
lot about protecting their assets,

00:18:32.710 --> 00:18:39.470
and so we provide the ability to
encrypt the segment files in transit.

00:18:39.470 --> 00:18:46.640
Another thing we have is the ability to
capture a live stream as it's being streamed,

00:18:46.640 --> 00:18:51.840
capture a live event for later playback, and
we refer to that as on-demand presentations.

00:18:51.839 --> 00:18:59.159
And finally, perhaps one of the most exciting features
in HTTP live streaming is the ability for the player

00:18:59.160 --> 00:19:05.360
to switch dynamically between streams of different
byte rates to adapt to the current network quality.

00:19:05.359 --> 00:19:08.449
So let's talk about encryption first.

00:19:08.450 --> 00:19:14.250
When we encrypt segment files,
we use 128 byte AAS encryption.

00:19:14.250 --> 00:19:24.289
While inside the segment file, we use Cipher Block
Chaining, and on the edges, we pad them with PKCS7 padding.

00:19:24.289 --> 00:19:27.440
Encryption is typically done at the segmentation phase.

00:19:27.440 --> 00:19:31.490
So we'll encrypt the segment files
before we distribute them off the web.

00:19:31.490 --> 00:19:39.140
After you've encrypted the segment files, the next
step is to deliver the encryption keys to your clients.

00:19:39.140 --> 00:19:47.490
Now the encryption keys are delivered over HTTP, and so it's
up to you to set up some means of access control to ensure

00:19:47.490 --> 00:19:51.230
that only authorized clients are
able to retrieve those keys.

00:19:51.230 --> 00:19:56.970
And to do this you can use any of a set of
well-known, well-established HTTP techniques

00:19:56.970 --> 00:20:04.640
such as creating a secure realm that requires HTTP
authentication, or establishing a secure session cookie

00:20:04.640 --> 00:20:14.540
and requiring the presence of that
cookie in order to release the key.

00:20:14.539 --> 00:20:21.519
And so let's take a look at how encryption
is represented in the playlist file.

00:20:21.519 --> 00:20:27.190
You'll see that we have a new tag
up here, it's the X key tag.

00:20:27.190 --> 00:20:33.480
And what it's telling us is that for all
subsequent media files that appear in the playlist,

00:20:33.480 --> 00:20:37.309
they will be encrypted using AES-128 encryption,

00:20:37.309 --> 00:20:42.470
and that the key to decrypting those files
can be obtained from this URL here.

00:20:42.470 --> 00:20:51.160
If you want to, you can switch the key you're using
once you've decided you've encrypted enough files

00:20:51.160 --> 00:20:52.460
with it, you can rotate the keys.

00:20:52.460 --> 00:20:57.049
And the way you do this is you just add a
new instance of the tag into the playlist.

00:20:57.049 --> 00:21:03.259
So what this playlist is now saying is that segment
39 is encrypted with the first key, and now segment 40

00:21:03.259 --> 00:21:09.379
and all subsequent segments will be encrypted by it
with the second key, at least until it changes again.

00:21:09.380 --> 00:21:14.930
So using this technique, you can encrypt your media,

00:21:14.930 --> 00:21:18.990
but you can still deliver your media
over HTTP which is fast and cheap.

00:21:18.990 --> 00:21:26.579
The next thing I'd like to talk about
is live versus on-demand presentations.

00:21:26.579 --> 00:21:32.569
Now essentially the only difference here
in our terminology of live presentations is

00:21:32.569 --> 00:21:39.169
that when you're adding new segments
onto the end of a playlist file,

00:21:39.170 --> 00:21:43.029
the old ones disappear off the top, they do that.

00:21:43.029 --> 00:21:46.059
But what if they didn't disappear off the top?

00:21:46.059 --> 00:21:53.009
What if while you were adding new segments to your
playlist file you simply kept the old the ones.

00:21:53.009 --> 00:21:55.599
Well that's an on-demand presentation.

00:21:55.599 --> 00:21:59.829
And they're really focused at two different usage models.

00:21:59.829 --> 00:22:04.710
The first is, well let's say you're CNN,
let's say you're a 24-hour news station.

00:22:04.710 --> 00:22:12.880
You're broadcasting continuously, you don't want to keep all
of your segment files on your website going back 50 days.

00:22:12.880 --> 00:22:16.540
You don't want to have your playlist
file expanding indefinitely.

00:22:16.539 --> 00:22:20.559
And so you'd use a live presentation, the guy on top.

00:22:20.559 --> 00:22:25.379
On the other hand, let's say that you're
broadcasting a baseball game for instance.

00:22:25.380 --> 00:22:31.820
Something that has a well-defined beginning and
a well-defined end is actually really well suited

00:22:31.819 --> 00:22:40.849
for on-demand playback, because I as a viewer could tune
into the baseball game half an hour after it started,

00:22:40.849 --> 00:22:43.149
but I could still watch it from the beginning.

00:22:43.150 --> 00:22:49.830
I could also seek around it a little bit, or
even jump to live and start watching it live.

00:22:49.829 --> 00:22:54.329
And so there are some benefits of having all
the segments remain available on the server.

00:22:54.329 --> 00:23:01.309
And so we offer a choice there.

00:23:01.309 --> 00:23:08.539
When the game ends, in the example of the
baseball game, the last segment file is added

00:23:08.539 --> 00:23:11.210
to the playlist and the playlist is marked as complete.

00:23:11.210 --> 00:23:14.940
This tells the client they can stop
refreshing the playlist for changes.

00:23:14.940 --> 00:23:22.150
So now let's compare the actual playlist
files of live streams versus on-demand steams.

00:23:22.150 --> 00:23:28.860
The first on the left here is a live playlist and as I
said earlier, what happens is every time a segment is added

00:23:28.859 --> 00:23:33.659
to the end of the playlist file
an old segment rolls off the top.

00:23:33.660 --> 00:23:36.759
Well contrast that with an on-demand playlist file.

00:23:36.759 --> 00:23:44.160
So segments start coming in here at the beginning when
the game begins and they'll remain in the playlist

00:23:44.160 --> 00:23:48.060
as new segments are added until the game ends.

00:23:48.059 --> 00:23:51.259
And this might end at segment 1130 for instanc0e.

00:23:51.259 --> 00:23:56.470
The last thing the server is going to do
is place an endless tag into the playlist,

00:23:56.470 --> 00:24:00.430
and this informs the client that
the playlist is now complete.

00:24:00.430 --> 00:24:07.150
What you have at this point is something that is
kind of akin to a progressive download situation

00:24:07.150 --> 00:24:10.900
where you have a bunch of media up on your
web server, the client can go back to it

00:24:10.900 --> 00:24:14.450
at any point they want and watch it in its entirety.

00:24:14.450 --> 00:24:22.230
The only difference between HTTP live streaming on-demand
playlist and the more traditional sticking MPEG4 files

00:24:22.230 --> 00:24:29.789
up on the HTTP server is that today our players give
you a little less control in terms of the granularity

00:24:29.789 --> 00:24:32.690
of seeking around in an on-demand playlist.

00:24:32.690 --> 00:24:37.660
But you still get the benefits of
encryption and stream switching,

00:24:37.660 --> 00:24:40.590
so you kind of have to decide which one makes more sense.

00:24:40.589 --> 00:24:46.240
But one of the nice things about on-demand is
that it's almost instantaneous to transition

00:24:46.240 --> 00:24:50.750
from broadcasting a live event to having an
archive available as on-demand on your server.

00:24:50.750 --> 00:24:58.250
Speaking of stream switching, let's talk
about the problems of network variability.

00:24:58.250 --> 00:25:03.630
So when I say network variability, what I'm
essentially saying is that you've got your iPhone,

00:25:03.630 --> 00:25:07.440
you've got your Macintosh, and you're
downloading information from the network.

00:25:07.440 --> 00:25:11.230
The network bandwith that is available to
you through whatever connection you have,

00:25:11.230 --> 00:25:14.779
is going to vary, and sometimes it's going to vary a lot.

00:25:14.779 --> 00:25:20.629
This has always been a problem for anyone
who wants to stream video over the internet.

00:25:20.630 --> 00:25:25.140
But the iPhone particularly has this problem in spades.

00:25:25.140 --> 00:25:29.740
Versus let's say you're starting at home and
your iPhone is associated with your Wi-Fi hotspot

00:25:29.740 --> 00:25:31.670
at home, it's backed up by your cable modem.

00:25:31.670 --> 00:25:35.380
You've got tons of great bandwith available to you.

00:25:35.380 --> 00:25:36.510
But then you leave.

00:25:36.509 --> 00:25:42.009
You walk out of your house, you take your iPhone with
you, you drop off your Wi-Fi network onto 3G today,

00:25:42.009 --> 00:25:45.819
that drop off in bandwith is considerable.

00:25:45.819 --> 00:25:47.809
And the variations don't stop there.

00:25:47.809 --> 00:25:53.730
As you walk around with your iPhone, as you pass buildings,
as you go under trees, as you get closer to cells,

00:25:53.730 --> 00:25:58.640
as you get further away from cell towers,
your bandwith will change considerably.

00:25:58.640 --> 00:26:00.630
You don't even have to move in fact.

00:26:00.630 --> 00:26:05.610
With 3G the bandwith will change depending
on how many people are in your cell

00:26:05.609 --> 00:26:10.240
and how many people are using the
network in your cell to the back hall.

00:26:10.240 --> 00:26:17.769
And so the iPhone particularly needs to deal with a
network bandwith that is fluctuating continuously.

00:26:17.769 --> 00:26:23.730
Now if all you had was a single stream at a single
byte rate and you wanted to deliver that to your users,

00:26:23.730 --> 00:26:26.769
you've got this kind of ugly choice you have to make.

00:26:26.769 --> 00:26:32.299
On the one hand, you could encode a low
byte rate stream that everyone could watch.

00:26:32.299 --> 00:26:35.220
Great, but it's not going to look very good.

00:26:35.220 --> 00:26:39.350
On the other hand, you could encode a
higher byte rate stream that looks great,

00:26:39.349 --> 00:26:44.819
but most of your users will not be able to
sustain that bandwidth as they're downloading it.

00:26:44.819 --> 00:26:49.169
And sustaining the bandwith is
particularly important for live streams.

00:26:49.170 --> 00:26:56.759
The reason being that if you have to stop and buffer for 20
or 30 seconds beca0use your network connection can't keep up,

00:26:56.759 --> 00:27:00.819
well you have live content that's
expiring on the server as you're waiting.

00:27:00.819 --> 00:27:05.659
When you finally get back to playing, your
users are going to notice a discontinuity

00:27:05.660 --> 00:27:11.980
because the next content you are planning on playing
is no longer there and they have to skip ahead.

00:27:11.980 --> 00:27:17.410
So it's key to the user experience
to be able to sustain playback.

00:27:17.410 --> 00:27:25.170
So the best approach to delivering this kind of user
experience on the internet, the wide open internet,

00:27:25.170 --> 00:27:33.120
is to encode multiple versions of your stream and to
have the client switch between them dynamically based

00:27:33.119 --> 00:27:35.819
on its view of the current bandwith available to it.

00:27:35.819 --> 00:27:38.619
That's what we do in HTTP live streaming.

00:27:38.619 --> 00:27:43.669
And the way we express it is through
something called variant playlist.

00:27:43.670 --> 00:27:51.580
Now a variant playlist is an M3U file like our
other playlists, the difference is that instead

00:27:51.579 --> 00:27:58.990
of the URLs being media segment files, the URLs
are actually pointing to individual streams.

00:27:58.990 --> 00:28:06.329
Each URL is prefixed by a tag that indicates information
about the stream such as the overall byte rate required

00:28:06.329 --> 00:28:13.689
to sustain viewing it, to keep up with it, and
optionally some information about the codecs.

00:28:13.690 --> 00:28:19.440
So the way this works on the client end is the
client starts by downloading the variant playlist,

00:28:19.440 --> 00:28:27.330
this gives it a sense of which variants are available,
what kind of alternatives it has to viewing a stream.

00:28:27.329 --> 00:28:34.109
It will then decide if and when to switch
based on current network conditions.

00:28:34.109 --> 00:28:41.629
Now our current player algorithms have been tuned to
minimize the risk of creating that kind of network stall

00:28:41.630 --> 00:28:44.990
that is so disruptive to a live streaming experience.

00:28:44.990 --> 00:28:50.970
I think that this is pretty clear,
but the graphics guys got together

00:28:50.970 --> 00:28:55.940
and created this really great slide,
so I have to show you this slide.

00:28:55.940 --> 00:28:59.789
So let's say that you set up a live
playlist, you've got some content,

00:28:59.789 --> 00:29:03.599
it's kind of a medium resolution, medium byte rate.

00:29:03.599 --> 00:29:09.779
And you've got your playlist up there and segments
are appearing and disappearing through that playlist.

00:29:09.779 --> 00:29:16.859
What if at the same time you put
those files up on your web server,

00:29:16.859 --> 00:29:20.829
you also put two other streams up on your web server.

00:29:20.829 --> 00:29:26.210
These are all peer streams, your client
could chose any one of them and play them

00:29:26.210 --> 00:29:31.480
and get the regular streaming experience, it could play
the very low resolution one, the very low byte rate,

00:29:31.480 --> 00:29:36.890
the medium resolution one, or the very high
resolution one at the highest byte rate.

00:29:36.890 --> 00:29:48.030
Or you could put all three URLs for each variant stream
into a variant playlist file and give that to the client.

00:29:48.029 --> 00:29:52.000
Now the client knows about the
existence of all three of these streams

00:29:52.000 --> 00:29:56.220
and it can go back and forth between them as it chooses.

00:29:56.220 --> 00:30:01.140
So let's see how that actually looks in a playlist file.

00:30:01.140 --> 00:30:07.040
So again we have an extended M3U playlist
up here, it's got three URLs in it;

00:30:07.039 --> 00:30:10.000
one for low, one for mid, and one for high.

00:30:10.000 --> 00:30:16.140
Each URL is prefixed by that stream info tag, and
what each stream info tag is saying, first of all,

00:30:16.140 --> 00:30:20.990
that all three streams are program ID1,
so they all refer to the same content.

00:30:20.990 --> 00:30:23.670
The difference is that each one has a different bandwith.

00:30:23.670 --> 00:30:31.110
The first one has a bandwith of 128 kilobytes per
second, the second has 256, and the third has 768.

00:30:31.109 --> 00:30:35.449
So with this information, the client
can choose which one it wishes to play

00:30:35.450 --> 00:30:39.130
and then switch between them as its network changes.

00:30:39.130 --> 00:30:45.160
In our current implementation, the players will
actually start with the first URL in that playlist,

00:30:45.160 --> 00:30:49.900
but that may change in subsequent release.

00:30:49.900 --> 00:30:56.950
Another thing you can express with a variant playlist
is the set of codecs that are required to play a stream.

00:30:56.950 --> 00:31:00.259
And this can come in useful in cases like this

00:31:00.259 --> 00:31:05.539
Let's say that you decided that in addition to these three
streams, which you would expect pretty much any client

00:31:05.539 --> 00:31:08.909
of your services to be able to play, you also wanted

00:31:08.910 --> 00:31:13.360
to provide a higher byte rate stream
that had a much higher resolution.

00:31:13.359 --> 00:31:20.619
And in order to achieve that resolution, you needed
to use some more advanced tools from the H.264 codec.

00:31:20.619 --> 00:31:25.259
In that case, you could add something
like this to your playlist.

00:31:25.259 --> 00:31:33.730
Now this fourth stream here in addition to having a
byte rate of 1.5 megabytes per second, has a codecs tag.

00:31:33.730 --> 00:31:39.579
The codecs tag is formatted according
to the rules of RFC 4281.

00:31:39.579 --> 00:31:43.799
I'll translate it for you.

00:31:43.799 --> 00:31:53.240
That first element, AVC 177.40 indicates that
the stream requires an H.264 codec level four

00:31:53.240 --> 00:31:56.809
or main profile level 4.0.

00:31:56.809 --> 00:32:05.440
That second entry, MP4A.40.5 indicates that it
needs an audio codec which is HE-AAC version one.

00:32:05.440 --> 00:32:10.320
So a Macintosh downloading this variant
playlist might well attempt to switch up to

00:32:10.319 --> 00:32:13.859
that 1.5 megabyte stream because it knows it can play it.

00:32:13.859 --> 00:32:20.740
Today's iPhones on the other hand will not because they
know that they don't have a main profile level for a codec.

00:32:20.740 --> 00:32:26.650
Another thing that you can express with a
codecs tag is the fact that it's audio only.

00:32:26.650 --> 00:32:32.690
The codecs tag when it's present
indicates the complete set of codecs

00:32:32.690 --> 00:32:36.480
that must be installed in order to play the stream.

00:32:36.480 --> 00:32:41.980
What that means is if you have something like this
you've got a fairly low byte rate stream at 64 kilobytes,d

00:32:41.980 --> 00:32:46.049
you have a codecs tag that has only the HE-AAC entry.

00:32:46.049 --> 00:32:51.690
Because there's no AVC in there, there's no video codec
in there, you can conclude that that stream is audio only.

00:32:51.690 --> 00:32:58.630
And so you can add something like this so that your users
will switch down to an audio only version of your stream

00:32:58.630 --> 00:33:01.320
in the case of an extremely low bandwith connection.

00:33:01.319 --> 00:33:07.230
So what I'd like to show you now is what this
looks like when we put everything together,

00:33:07.230 --> 00:33:11.599
and so I'd like to bring Bill up on stage again.

00:33:11.599 --> 00:33:16.009
What we're going to start with
here is streaming on Snow Leopard.

00:33:16.009 --> 00:33:22.920
So we're going to go into Safari in the browser, and
before we start playing, what we're going to start

00:33:22.920 --> 00:33:26.380
with is an extremely low byte rate stream.

00:33:26.380 --> 00:33:32.400
And if you watch it carefully, you'll see it switch up to
a higher byte rate once we decide we have enough bandwith.

00:33:32.400 --> 00:33:35.019
So Bill can go ahead and play it.

00:33:35.019 --> 00:33:36.529
>> At Accuweather.com through the afternoon and evening.

00:33:36.529 --> 00:33:38.889
>> So it's opening in Snow Leopard here.

00:33:38.890 --> 00:33:40.800
>>meteorologist, Dr. Joe Sobol.

00:33:40.799 --> 00:33:42.509
>> And -

00:33:42.509 --> 00:33:43.579
[ Music ]

00:33:43.579 --> 00:33:44.059
>> And can we switch?

00:33:44.059 --> 00:33:48.869
>> Here's positively the best place to start your day.

00:33:48.869 --> 00:33:50.659
>> Let's run it again.

00:33:50.660 --> 00:33:53.740
>> Here's where night lights up in the most unexpected way.

00:33:53.740 --> 00:33:59.029
>> We'll close that and start it again.

00:33:59.029 --> 00:33:59.889
>> Here's positively the best -

00:33:59.890 --> 00:34:02.240
>> So you can see it's rally pixelated, it's a low frame rate.

00:34:02.240 --> 00:34:03.120
>> Here's where your night -

00:34:03.119 --> 00:34:05.119
>> This is about 200 kilobytes stream here.

00:34:05.119 --> 00:34:06.859
>> -- in unexpected ways.

00:34:06.859 --> 00:34:11.519
>> I think the previous time we went it switched
almost instantly, so we weren't able to see it.

00:34:11.519 --> 00:34:17.099
But the point at which we switch is going to depend on a
number of things such as the cadence of the input file -

00:34:17.099 --> 00:34:18.159
>> such as the cadence of the input file

00:34:18.159 --> 00:34:20.250
>> -- and of the I frames that come in.

00:34:20.250 --> 00:34:22.670
I can switch now, you can see the higher frame rate.

00:34:22.670 --> 00:34:26.000
And so this is about a one megabyte
stream, it looks a lot better.

00:34:26.000 --> 00:34:31.889
The other thing about HTTP live streaming
is that we have new transport controls.

00:34:31.889 --> 00:34:34.579
And so if we can bring those up here.

00:34:34.579 --> 00:34:39.239
So what we have on the left-hand
side is a back-30-seconds button.

00:34:39.239 --> 00:34:42.809
And so if you click that, you'll drop
back 30 seconds into the stream so long

00:34:42.809 --> 00:34:44.900
as there is enough media in the playlist file.

00:34:44.900 --> 00:34:50.079
There has to be enough media in the playlist
file for us to seek backward 30 seconds.

00:34:50.079 --> 00:34:53.420
So I want you to do that Bill.

00:34:53.420 --> 00:34:55.289
And so we're going to jump back 30 seconds here,

00:34:55.289 --> 00:34:59.309
we'll see this fellow we saw earlier,
and so he's talking about the weather.

00:34:59.309 --> 00:35:02.809
I think I don't want to hear about
damaging storm threat on a Wednesday night,

00:35:02.809 --> 00:35:07.210
so we're going to click the button the
right which is jumping back to live.

00:35:07.210 --> 00:35:13.420
So we'll click that and now we're back to the live stream.

00:35:13.420 --> 00:35:16.409
So those are how the transport controls work.

00:35:16.409 --> 00:35:20.069
I'd like to show you the same thing running on an iPhone.

00:35:20.070 --> 00:35:25.890
And so what Bill is going to do now is move away
from his Macintosh and go over to his iPhone.

00:35:25.889 --> 00:35:28.679
So we have an iPhone up here.

00:35:28.679 --> 00:35:36.779
We're going to tap our little web link, we go to the
same web page, and we're going to play the stream.

00:35:36.780 --> 00:35:37.890
So we start playback here.

00:35:37.889 --> 00:35:39.319
Chug, chug, chug.

00:35:39.320 --> 00:35:39.380
>> The Big Book of Parenting Solutions

00:35:39.380 --> 00:35:42.280
>> There we are.

00:35:42.280 --> 00:35:42.840
>> The Big Book of Parenting Solutions

00:35:42.840 --> 00:35:49.010
>> Again we're starting with the low byte
rate stream here, it's low frame rate

00:35:49.010 --> 00:35:51.370
and fairly pixilated, and I believe we just switched.

00:35:51.369 --> 00:35:55.190
And so now we're at the full resolution
and the full byte rate.

00:35:55.190 --> 00:35:58.579
We have the same transport controls
on the iPhone, so we tap that.

00:35:58.579 --> 00:36:02.250
You can see the back-30 and the jump to live.

00:36:02.250 --> 00:36:08.150
And so we can go back 30 even though
we didn't start watching

00:36:08.150 --> 00:36:11.039
at the 30 second point, at least I trust that we can.

00:36:11.039 --> 00:36:12.650
Here we are.

00:36:12.650 --> 00:36:13.329
Um, how are we doing?

00:36:13.329 --> 00:36:19.449
>> >>ABC News medical editor, Dr. Tim Johnson.

00:36:19.449 --> 00:36:21.029
Dr. Tim.

00:36:21.030 --> 00:36:21.780
>> Thank you, Tanya.

00:36:21.780 --> 00:36:24.550
>> OK, so we've got the same transport
controls as we have on the iPhone.

00:36:24.550 --> 00:36:25.630
>> -- is Dr. Michelle Borba

00:36:25.630 --> 00:36:26.369
>> Great. Thanks, Bill.

00:36:26.369 --> 00:36:28.670
>> -- who is an educational psychologist

00:36:28.670 --> 00:36:30.000
>> OK. Thank you.

00:36:30.000 --> 00:36:33.750
[ Applause ]

00:36:33.750 --> 00:36:35.559
>> Thank you very much.

00:36:35.559 --> 00:36:40.110
So now let's take a look again behind
the scenes at what was going on there.

00:36:40.110 --> 00:36:42.750
Again we started with an audio/video signal.

00:36:42.750 --> 00:36:47.329
In this case, the AVC news feed was being fed by a satellite

00:36:47.329 --> 00:36:50.150
to the Yahoo broadcast center
which is in Dallas, Texas.

00:36:50.150 --> 00:36:56.570
The audio/video signal was then transferred
again to an Inlet Technologies Spinnaker 7000.

00:36:56.570 --> 00:37:02.410
This time however, this Spinnaker instead of producing
a single MPEG2 transport stream and feeding it

00:37:02.409 --> 00:37:05.009
to our segmenter on the Xserve, was producing two.

00:37:05.010 --> 00:37:11.000
The Spinnaker 7000 has the cappability
to encode up to four real-time streams

00:37:11.000 --> 00:37:14.260
at different resolutions and byte rates at the same time.

00:37:14.260 --> 00:37:23.770
So for our demo, we set it up to encode two, one
at 200 kilobytes and one about 900 kilobytes.

00:37:23.769 --> 00:37:31.340
And both of those transport streams are then fed over
multi-cast UDP across the local network to our XServe

00:37:31.340 --> 00:37:34.809
which is running two instances of the segmenter application.

00:37:34.809 --> 00:37:41.920
And each of which is producing its own list of segments,
its own playlist file, and placing them on a web server.

00:37:41.920 --> 00:37:46.200
Now from there it's the same thing, the
web server axis and origin into Akamai,

00:37:46.199 --> 00:37:54.859
the clients can then download those segment files
over a local edge server here in San Francisco.

00:37:54.860 --> 00:38:02.070
So one thing you'll notice about that demo there was that
I didn't use a custom application, all I had was a browser.

00:38:02.070 --> 00:38:09.620
It's not actually necessary to have an application to
deliver a great live streaming experience to your users.

00:38:09.619 --> 00:38:14.429
It's great to have an application,
you can add new additional features

00:38:14.429 --> 00:38:16.519
to it, and I'll show you one in a second.

00:38:16.519 --> 00:38:21.679
But if all you want to do is deliver your live
stream and you don't want to get into the business

00:38:21.679 --> 00:38:27.250
of running an iPhone application, we'd love for you
write an iPhone application, but you don't have to.

00:38:27.250 --> 00:38:28.820
All you need is the server.

00:38:28.820 --> 00:38:31.660
So let's take a look at what's necessary to do that.

00:38:31.659 --> 00:38:36.789
The content deployment story from a server
for HTTP live streaming is pretty simple.

00:38:36.789 --> 00:38:39.519
It breaks down into three steps.

00:38:39.519 --> 00:38:44.750
The first step is you need to create
a continuous MPEG2 transport stream.

00:38:44.750 --> 00:38:52.239
The second step is you need to divide that MPEG2 transport
stream into individual segments and create a playlist file.

00:38:52.239 --> 00:38:57.569
Once you have those segments in that playlist file, the
third step is to simply serve them out over the web.

00:38:57.570 --> 00:39:02.720
So let's look at each one of those.

00:39:02.719 --> 00:39:10.189
To create your MPEG2 transport stream, you need an MPEG2
transport stream that contains H.264 video and AAC audio.

00:39:10.190 --> 00:39:18.269
One of the benefits of using industry standards like
MPEG2 transport streams and H.264 and AAC is that hardware

00:39:18.269 --> 00:39:22.320
and software, to produce these streams, already exist.

00:39:22.320 --> 00:39:30.559
And we've been working with the leading vendors of encoding
hardware to tune their support for HTTP live streaming.

00:39:30.559 --> 00:39:37.079
Now these boxes work really, really
well, but they're not cheap.

00:39:38.260 --> 00:39:44.120
So an alternative is you can use software
to create your MPEG2 transport stream.

00:39:44.119 --> 00:39:48.389
And in fact, there are some Open
Source packages that are capable

00:39:48.389 --> 00:39:52.589
of producing transport streams that contain H.264 and AAC.

00:39:52.590 --> 00:39:56.970
Less than a week after we publish the
specification for HTTP live streaming,

00:39:56.969 --> 00:40:00.429
some folks in the Open Source community
got together to tweaking these packages

00:40:00.429 --> 00:40:03.239
to work correctly with HTTP live streaming.

00:40:03.239 --> 00:40:05.599
So this is fantastic.

00:40:05.599 --> 00:40:13.759
So there are a number of tools that exist
today to produce these MPEG2 transport streams,

00:40:13.760 --> 00:40:17.730
and we're confident that there
will be even more coming soon.

00:40:17.730 --> 00:40:25.199
In any case, you've got your MPEG2 transport
stream, the next step is to segment it.

00:40:25.199 --> 00:40:29.529
When you decide to segment, you have to make some choices.

00:40:29.530 --> 00:40:35.070
The first choice you have to make is, are you going
to hold on to all your segments on your server forever

00:40:35.070 --> 00:40:40.110
or for as long as the event lasts, or are you going
to throw them away as new segments are generated?

00:40:40.110 --> 00:40:44.800
In other words, will your presentation be live or on-demand.

00:40:44.800 --> 00:40:48.320
The second choice is, you have
to choose the target duration.

00:40:48.320 --> 00:40:51.940
And remember, we had that target-duration
tag in the playlist file.

00:40:51.940 --> 00:40:57.460
The target duration specifies the average duration
of each segment that you intend to generate.

00:40:57.460 --> 00:41:01.039
Now there's a tradeoff here.

00:41:01.039 --> 00:41:11.719
A long target duration, or any target duration really,
creates an inherent delay between the point at which you

00:41:11.719 --> 00:41:17.799
on the encoding side receive your AV signal,
and the point where your user who is watching

00:41:17.800 --> 00:41:21.250
at home, is able to see that event occur.

00:41:21.250 --> 00:41:28.039
And the reason for this is because we can only
distribute segment files over HTTP once they're complete.

00:41:28.039 --> 00:41:34.239
So let's say you chose a target duration of 20 seconds,
that means when you're dealing with a live stream,

00:41:34.239 --> 00:41:40.309
you're going to have to sit there on the encoding end and
accumulate 20 seconds of media before you can place it

00:41:40.309 --> 00:41:42.219
on your web server and make it available to users.

00:41:42.219 --> 00:41:46.779
So they're going to have to wait at least
20 seconds before they can see those events.

00:41:46.780 --> 00:41:49.590
So long target duration is good.

00:41:49.590 --> 00:41:51.559
No, long target duration is bad.

00:41:51.559 --> 00:41:53.630
Short target duration is good.

00:41:53.630 --> 00:41:58.640
Unfortunately the flip side of this is
that the shorter your target durations,

00:41:58.639 --> 00:42:03.940
the more often the clients will be requesting
playlist file updates from your servers,

00:42:03.940 --> 00:42:06.690
and the more files you'll have in the pipe.

00:42:06.690 --> 00:42:13.650
This isn't as much of a big deal when you're talking about
a few servers playing something off of a local HTTP server.

00:42:13.650 --> 00:42:20.010
But once you're talking about distributing your stream
across the country and you've got a million users,

00:42:20.010 --> 00:42:23.010
all those little requests really start to add up.

00:42:23.010 --> 00:42:27.550
So we've done a lot of testing and we've
spoken to some large content delivery networks,

00:42:27.550 --> 00:42:35.260
and we've ended up with a recommendation that ten seconds
produces a kind of nice balance between having kind

00:42:35.260 --> 00:42:39.850
of a taped delay on the one hand that's
not too extreme, it's about 30 seconds

00:42:39.849 --> 00:42:47.210
it's sort of akin to the delay you would see when
watching digital television broadcast over the air,

00:42:47.210 --> 00:42:50.659
and having a network load that's not too outrageous.

00:42:50.659 --> 00:42:56.239
So we recommend about ten seconds, but you can play around
with it in your own applications and see how it feels.

00:42:56.239 --> 00:43:02.529
The next decision you need to make is the number of segments
that you'll have in your playlist at any given time.

00:43:02.530 --> 00:43:06.610
This obviously applies only to a live playlist, for
an on-demand playlist you'll have as many segments

00:43:06.610 --> 00:43:09.990
as there are, as you have duration of event.

00:43:09.989 --> 00:43:14.969
But for a live playlist file, you
need to choose the number of segments.

00:43:14.969 --> 00:43:21.319
Now you need to have at least three segments in your
playlist file at any given time, but you can have more.

00:43:21.320 --> 00:43:25.559
And one of the advantages of having more
is it allows your clients to seek around.

00:43:25.559 --> 00:43:29.250
It also allows them to pause for
a period of time and resume,

00:43:29.250 --> 00:43:32.860
and still watch the live presentation and not miss anything.

00:43:32.860 --> 00:43:36.960
Obviously if they pause for too long, then when
they resume they're going to go back to live.

00:43:36.960 --> 00:43:42.510
But if you give them a nice long window in which they
can seek, then we will also pause for that period of time

00:43:42.510 --> 00:43:44.630
and they won't lose any of their presentation.

00:43:44.630 --> 00:43:51.000
So we think that's a pretty nice user experience, and so
we recommend that when you create your playlist files,

00:43:51.000 --> 00:43:55.130
when you set them up, that you set them
up to have at least 60 seconds of media

00:43:55.130 --> 00:43:58.559
in each playlist file and more if you choose.

00:43:58.559 --> 00:44:07.469
In any case, once you've decided how you want your
playlist file to look, the next step is to create it.

00:44:07.469 --> 00:44:10.259
And here we have a couple of choices.

00:44:10.260 --> 00:44:13.900
The first choice is you can use our media stream segmenter.

00:44:13.900 --> 00:44:17.500
This is a tool that you can download
from the iPhone developer center,

00:44:17.500 --> 00:44:21.510
it's also available on the Snow Leopard seed [phonetic],
so there's a couple of different ways to get it.

00:44:21.510 --> 00:44:27.140
The way it works is it's a command line tool,
it will consume an MPEG2 transport stream either

00:44:27.139 --> 00:44:30.730
from a Unix pipe or from a UDP socket.

00:44:30.730 --> 00:44:36.440
And as it consumes the MPEG2 transport stream,
it writes out these individual segment files.

00:44:36.440 --> 00:44:42.460
It will also in the case of a live stream,
delete all segment files as they roll off the top

00:44:42.460 --> 00:44:45.550
of the playlist so your hard disc doesn't fill up.

00:44:45.550 --> 00:44:51.410
It can also encrypt the segment files as it
writes them out to disc, and finally has an option

00:44:51.409 --> 00:44:58.539
to produce an audio only stream and one of the MPEG
elementary streams from and MPEG2 transport file.

00:44:58.539 --> 00:45:06.559
So you can use this to provide a low byte rate audio only
stream of your stream switch to varying presentation.

00:45:06.559 --> 00:45:12.929
So this media stream segmenter tool runs on any Macintosh
that can run Snow Leopard, so it's pretty flexible.

00:45:12.929 --> 00:45:20.690
But we recognize that there are a lot of situations in which
you can't run Snow Leopard, you may not even have Macintosh,

00:45:20.690 --> 00:45:27.119
particularly in a lot of the dedicated
live video production workflows.

00:45:27.119 --> 00:45:34.309
And so the second option is that we have written
a complete specification for HTTP live streaming,

00:45:34.309 --> 00:45:38.869
and we have published it through
the IETF as in internet draft.

00:45:38.869 --> 00:45:45.219
Now this specification has all you need to
know to write your own segmenting tools,

00:45:45.219 --> 00:45:49.239
and it's not actually that complicated of a job.

00:45:49.239 --> 00:45:55.139
We've already worked with several folks who've been able
to build their own segmenters and they're working great.

00:45:55.139 --> 00:46:03.980
So this is definitely an option for you if you decide
that you don't want to use our segmenter for any reason.

00:46:03.980 --> 00:46:10.039
Once you have your segments and your playlist
file, the final step is to serve them over the web.

00:46:10.039 --> 00:46:14.719
In some respects this is the most
straightforward part of it.

00:46:14.719 --> 00:46:17.899
You can use any standard web server,
you don't have to add any kind

00:46:17.900 --> 00:46:20.710
of additional mods or plug-ins or anything like that.

00:46:20.710 --> 00:46:26.530
The only configuration you have to do is you have
to configure the delivery of those playlist files.

00:46:26.530 --> 00:46:33.140
And there are two things that we recommend you do; the
first is to set them up to deliver a MIME type.

00:46:33.139 --> 00:46:39.469
We recommend that you use application/x-mpeg/url,
you can also use audio/mpeg/url instead.

00:46:39.469 --> 00:46:46.730
You also need to configure the time to deliver
those playlist files, and that should be the same

00:46:46.730 --> 00:46:51.590
as that value that you chose for the target duration.

00:46:51.590 --> 00:46:57.780
If you're encrypting your segment files, then you
also have to set up some sort of access control system

00:46:57.780 --> 00:47:02.690
so that only authorized users are
able to retrieve those keys over HTTP.

00:47:02.690 --> 00:47:12.460
And if you're employing a CDN, then you need to
transfer those files to your CDN and you can use any

00:47:12.460 --> 00:47:17.320
of a variety methods for this, you can use something
like Akamai's net storage system, you can use FTP,

00:47:17.320 --> 00:47:20.440
you can use Rsync, whatever your CDN supports.

00:47:20.440 --> 00:47:22.710
They're just like any other file at that point.

00:47:22.710 --> 00:47:32.170
And in fact, one of the advantages we have of using
vanilla HTTP to deliver these live streams is

00:47:32.170 --> 00:47:39.700
that you can use some of the techniques that you
already know around HTTP to do some really cool things.

00:47:39.699 --> 00:47:43.559
Now I'd like to show you an example of
one that a vendor that we were working

00:47:43.559 --> 00:47:46.809
with came up with that we thought was really cool.

00:47:46.809 --> 00:47:52.349
So imagine for a moment that you have a
server and it's streaming say a hockey game,

00:47:52.349 --> 00:47:56.000
and it's accumulating the stream as
an on-demand presentation playlist.

00:47:56.000 --> 00:48:00.960
So as segmenter generator being added to a
playlist it's growing and growing and growing.

00:48:00.960 --> 00:48:06.519
You can use server-side scripting
to add a feature to your application

00:48:06.519 --> 00:48:09.210
of being able to watch a highlight clip of that game.

00:48:09.210 --> 00:48:15.420
And the way it would work would be this: let's say
that in addition to producing this on-demand playlist,

00:48:15.420 --> 00:48:22.250
every time a goal was scored, the server used the new push
notification services that are available on iPhone OS 3.0

00:48:22.250 --> 00:48:25.440
to send a notification to your application on the iPhone.

00:48:25.440 --> 00:48:33.500
If your application wanted to display this highlight to the
user, it could package up the event ID and the notification

00:48:33.500 --> 00:48:39.750
into a query parameter of a URL, and then send
that to your server with a request to play it.

00:48:39.750 --> 00:48:45.369
The server could parse out that query parameter, recognize
the event idea as, Oh, this is highlight number three,

00:48:45.369 --> 00:48:50.670
this is the third goal in the game, it happened
13 minutes and 12 seconds into the game.

00:48:50.670 --> 00:48:54.869
And it could then dynamically using a
server side scripting tool like PHP,

00:48:54.869 --> 00:49:03.380
it could dynamically assemble the relevant sections from
the on-demand playlist and create a highlight playlist

00:49:03.380 --> 00:49:07.590
that contained only those segments that
contained the action around the goal,

00:49:07.590 --> 00:49:10.720
deliver it back to your application,
you could then play that.

00:49:10.719 --> 00:49:16.480
And so that's really kind of a clever technique to adding
a nice feature like highlight clips to your application

00:49:16.480 --> 00:49:18.750
with just a little bit of server-side scripting.

00:49:18.750 --> 00:49:31.320
So to recap content deployment, you first have to create
your MPEG2 transport stream, H.264 video, AAC audio.

00:49:31.320 --> 00:49:36.160
You have to break it up into segments
and produce that playlist file,

00:49:36.159 --> 00:49:39.759
and then you just have to serve it over to the web.

00:49:39.760 --> 00:49:42.330
So it's pretty straightforward.

00:49:42.329 --> 00:49:51.690
And we've seen folks get this kind of streaming
deployment running in just a small matter of days,

00:49:51.690 --> 00:49:54.289
and so it's actually pretty straightforward to do.

00:49:54.289 --> 00:49:58.710
We're at the end.

00:49:58.710 --> 00:50:03.019
OK, let me summarize.

00:50:03.019 --> 00:50:10.509
So using HTTP live streaming, you can now deliver live
content to your users on iPhone and on Snow Leopard.

00:50:10.510 --> 00:50:14.990
You can create multiple byte rates of
your streams and multiple qualities

00:50:14.989 --> 00:50:21.359
so that your users get a good user experience even
if they're on a mobile device like the iPhone.

00:50:21.360 --> 00:50:28.920
We use standard movie formats or standard media formats
so that you can use existing hardware and software

00:50:28.920 --> 00:50:34.320
to produce those streams, some of
which you may find you already own.

00:50:34.320 --> 00:50:41.400
Because we're using Vanilla [phonetic] HTTP, we
can use existing internet infrastructure to scale

00:50:41.400 --> 00:50:46.910
to extremely high demand and you can do it
without breaking the bank, which is important.

00:50:46.909 --> 00:50:54.529
And finally, we have created this public specification for
HTTP live streaming, and it's available through the IETF.

00:50:54.530 --> 00:51:03.250
And in fact, we've just uploaded a new version of
that to the ietf.org, and so if you haven't read

00:51:03.250 --> 00:51:07.360
or even if you've read it before, I encourage
you to download it again and check that out.

00:51:07.360 --> 00:51:07.769
1
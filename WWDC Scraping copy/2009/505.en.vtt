WEBVTT

00:00:13.359 --> 00:00:17.919
>> I'm Disco Vince Giffin, and today we're
talking about managing user privileges

00:00:17.920 --> 00:00:21.360
and operations with authorization services.

00:00:24.879 --> 00:00:29.820
While developing for Mac OS X, your
application may have to do something special.

00:00:29.820 --> 00:00:34.659
You may have to change the system time, you
may have to load or unload a kernel extension,

00:00:34.659 --> 00:00:39.619
you may have to modify a restricted part of the file system.

00:00:39.619 --> 00:00:44.039
These operations require more privilege
than your application normally has.

00:00:44.039 --> 00:00:46.070
So we call these privileged operations.

00:00:46.070 --> 00:00:52.579
Today we're talking about how we can
perform privileged operations securely.

00:00:52.579 --> 00:00:58.250
But first let's look at why this is so important.

00:00:58.250 --> 00:01:06.420
So let's imagine this blue pie here is your application,
and let's say this application may be a GUI tool for...

00:01:06.420 --> 00:01:10.510
editing Unix configuration files.

00:01:10.510 --> 00:01:16.250
If you're not familiar with Unix, a lot
of the configuration files or in /etc/,

00:01:16.250 --> 00:01:20.409
and of course these files are only writeable
by root; they're only writeable by the system,

00:01:20.409 --> 00:01:24.439
because you don't want users modifying
configuration files for the whole system.

00:01:24.439 --> 00:01:29.019
So if our GUI tool is going to be able
to modify these files and save them,

00:01:29.019 --> 00:01:32.500
some part of it has to be privileged;
maybe this little part over here.

00:01:32.500 --> 00:01:35.340
And that's the part that will actually
save the files and write to /etc/.

00:01:35.340 --> 00:01:41.520
Well in order for our application to actually
work then, we're going to need to run it as root,

00:01:41.519 --> 00:01:47.109
so that our privileged part will work also and
we'll be able to save these files that we've edited.

00:01:47.109 --> 00:01:49.549
But what if there's a bug in our application?

00:01:49.549 --> 00:01:52.879
Maybe in some plist parts or code...

00:01:52.879 --> 00:01:55.189
maybe over here somewhere.

00:01:55.189 --> 00:02:01.929
Well our application is running as root, so we have the
privileges we need to modify these configuration files.

00:02:01.930 --> 00:02:06.110
So if an attacker's able to exploit
this bug, turn it into a vulnerability,

00:02:06.109 --> 00:02:08.870
we have a root access vulnerability on the system.

00:02:08.870 --> 00:02:13.409
This is obviously very undesirable for your
application, but of course it's undesirable

00:02:13.409 --> 00:02:15.770
for every system that your application is installed on.

00:02:15.770 --> 00:02:20.460
And this is something we would like to avoid.

00:02:20.460 --> 00:02:23.629
But what if it's a really small application?

00:02:23.629 --> 00:02:26.689
And what if you are a really careful programmer?

00:02:26.689 --> 00:02:30.590
So this time you'll just write an
application that doesn't have any bugs in it.

00:02:30.590 --> 00:02:32.569
Well let's imagine...

00:02:32.569 --> 00:02:37.370
the blue portion here represents the code you've
written, both the privileged part for writing

00:02:37.370 --> 00:02:39.870
to /etc/ and the rest of your application.

00:02:39.870 --> 00:02:43.550
And the green part represents the
code that is in the various libraries

00:02:43.550 --> 00:02:47.340
and frameworks that you're using for you application.

00:02:47.340 --> 00:02:52.210
Now this of course is code you didn't write, and
its code you may not be terribly familiar with.

00:02:52.210 --> 00:02:57.250
It's code that may have bugs of its own, and of
course we have to run this application as root

00:02:57.250 --> 00:03:02.039
so it has the privileges we need,
so we can save into the /etc/.

00:03:02.039 --> 00:03:09.189
Well these bugs that are in code that you didn't even write
could be root access vulnerabilities in your application.

00:03:09.189 --> 00:03:15.849
There's gotta be a better way to do this, and in fact
there is and we have some wise words to guide us.

00:03:15.849 --> 00:03:17.659
This is the principle of this privilege,

00:03:17.659 --> 00:03:22.189
it's a very important design principle
that we have in software security.

00:03:22.189 --> 00:03:27.719
It states that every program and every user of
the system should operate using the least set

00:03:27.719 --> 00:03:31.550
of privileges necessary to complete the job.

00:03:31.550 --> 00:03:36.650
So from that, it sounds like we want
something a little more like this.

00:03:36.650 --> 00:03:41.810
Now of course we can't have the privilege code and the
regular non privilege code running in the same memory space,

00:03:41.810 --> 00:03:44.629
so we really want something a little more like this.

00:03:44.629 --> 00:03:52.740
And that's what we're going to be talking about today.

00:03:52.740 --> 00:03:57.370
We're going to be covering managing
user privileges in four parts.

00:03:57.370 --> 00:04:03.450
In the first parts, we're going to look at how we can use a
privileged helper to keep all of the functionality we want

00:04:03.449 --> 00:04:07.369
in our application, but without
making huge security compromises.

00:04:07.370 --> 00:04:13.960
That will look at how we can use authorization
services to restrict the use of our privileged helper.

00:04:13.960 --> 00:04:20.509
We'll look at code identity, and we'll see how we
can use code identity to restrict the functionality

00:04:20.509 --> 00:04:24.730
of our privileged helper, and in doing so restrict
the danger that it presents to the system.

00:04:24.730 --> 00:04:28.890
And then we'll use authorization plug-ins,
a feature of authorization services,

00:04:28.889 --> 00:04:31.800
to customize the authorization experience for our user.

00:04:31.800 --> 00:04:38.250
So to explain all of this, starting with privilege
helpers, we're going to have a little example.

00:04:38.250 --> 00:04:42.149
And we'll call our example application Spackle.

00:04:42.149 --> 00:04:47.659
And Spackle has a feature that a lot of
applications have, it has a self-updating feature.

00:04:47.660 --> 00:04:49.750
The self-updating feature is pretty straightforward,

00:04:49.750 --> 00:04:52.589
when a new version's available it
wants to be able to update itself.

00:04:52.589 --> 00:04:57.769
And of course it does this by checking for a new version
to see if one's available, will download the new version

00:04:57.769 --> 00:05:03.169
if it is available, will alert the user of course to
say, hey user - the new version's out, don't you want it?

00:05:03.170 --> 00:05:03.830
Click the button.

00:05:03.829 --> 00:05:09.789
And of course we'll replace the existing
version with the new version we just downloaded,

00:05:09.790 --> 00:05:13.020
and it will relaunch the application,
suddenly the user has a new version.

00:05:13.019 --> 00:05:13.699
It's going to be great.

00:05:13.699 --> 00:05:19.129
Well of course there's a hitch, and that
is that this is a privileged operation.

00:05:19.129 --> 00:05:23.709
And the reason this is a privileged
operation is pretty straightforward.

00:05:25.189 --> 00:05:31.370
When you have an application running on the system the
code is executing as the user who's using the application.

00:05:31.370 --> 00:05:33.500
You know - the user who double-clicks the icon.

00:05:33.500 --> 00:05:41.420
But a properly installed application on
the system is only writable by the system,

00:05:41.420 --> 00:05:46.650
because if an application is writable by a user, and
this application is used by all the users of the system,

00:05:46.649 --> 00:05:50.439
then that user can change it out from under users.

00:05:50.439 --> 00:05:54.949
So we only want the application
to be writable by the system.

00:05:54.949 --> 00:06:00.079
Well of course then the code is executing
as a user that can't overwrite itself.

00:06:00.079 --> 00:06:05.550
So how are we going to handle this "replace the
existing version", overwriting the application?

00:06:05.550 --> 00:06:08.740
There are a lot of bad ways to do this.

00:06:08.740 --> 00:06:12.939
One way is we could popup a dialogue
and say, hey user open terminal,

00:06:12.939 --> 00:06:15.839
it's in utilities, type in sudo-whatever, whatever.

00:06:15.839 --> 00:06:19.329
Of course there's obviously security implications.

00:06:19.329 --> 00:06:22.709
If the user were to typo, this could be catastrophic.

00:06:22.709 --> 00:06:27.709
And it's a terrible user experience,
so we're not going to do that.

00:06:27.709 --> 00:06:30.229
Another option might be to set user ID application.

00:06:30.230 --> 00:06:37.689
Set user ID is a feature of the Unix security model
that allows you to set a binary or an executable,

00:06:37.689 --> 00:06:41.920
to execute as a set user regardless
of which user's using it.

00:06:41.920 --> 00:06:45.449
Now in our case we'd have to do this, this
is root so we have all the privilege we need.

00:06:45.449 --> 00:06:49.439
But unfortunately this comes with a whole
host of problems stemming from the fact

00:06:49.439 --> 00:06:53.449
that the execution is actually
done in the user's environment.

00:06:53.449 --> 00:06:57.729
So that means that file descriptors, the
argument vector, environmental variables,

00:06:57.730 --> 00:07:01.240
these could all possibly be manipulated by an attacker.

00:07:01.240 --> 00:07:04.569
And that makes set user ID very dangerous.

00:07:04.569 --> 00:07:10.089
Additionally we cannot have set user
ID GUI applications on Snow Leopard.

00:07:10.089 --> 00:07:17.539
New in Snow Leopard, you can't have a set
user ID application present user interface.

00:07:17.540 --> 00:07:21.210
So not even an option for us.

00:07:21.209 --> 00:07:26.310
Another option might be to use
authorization execute with privilege.

00:07:26.310 --> 00:07:31.209
This is actually a feature of authorization
services, and was originally added to this system

00:07:31.209 --> 00:07:35.769
so that an application could install its
own privileged helper, which is great,

00:07:35.769 --> 00:07:39.839
but it is unfortunately a very
general purpose facility and because

00:07:39.839 --> 00:07:43.179
of that it has all the problems of set user ID and more.

00:07:43.180 --> 00:07:47.230
So we really don't want to do this
for our privileged operations.

00:07:47.230 --> 00:07:50.980
Finally we could have a privileged helper tool.

00:07:50.980 --> 00:07:56.920
This is our prescribed method;
this is what we're talking about.

00:07:57.990 --> 00:08:03.150
So if you remember, our goal, like we saw
with the principal of least privilege,

00:08:03.149 --> 00:08:07.549
is to isolate our privilege operations;
to run them separately.

00:08:07.550 --> 00:08:11.819
And the way we'll do this, is we'll
have a separate helper executable.

00:08:11.819 --> 00:08:17.159
We'll take our code that actually has to perform
the privileged operation, and we'll put that code

00:08:17.160 --> 00:08:19.880
in a separate binary, separate executable.

00:08:19.879 --> 00:08:31.709
So we'll use interprocess communication to communicate
between our application proper, and our privileged helper.

00:08:31.709 --> 00:08:35.019
This could be a CF message port or Unix domain socket.

00:08:35.019 --> 00:08:41.639
And now only our helper has to actually
operate with any level of privilege,

00:08:41.639 --> 00:08:43.720
because the rest of the application does what it always did,

00:08:43.720 --> 00:08:46.570
and the privileged operations are
performed by our privileged helper.

00:08:46.570 --> 00:08:52.970
And our privileged helper will only do one designated task.

00:08:52.970 --> 00:08:56.009
At first it may see like well, if I'm going
to have to make these privileged helpers,

00:08:56.009 --> 00:08:59.340
I'll just make one that takes a string and runs it as root.

00:08:59.340 --> 00:09:02.870
But unfortunately that has a lot of
really terrible security implications.

00:09:02.870 --> 00:09:07.580
And in order to really try to get to
this least privilege we're talking about,

00:09:07.580 --> 00:09:12.000
we want this to only do one specific thing.

00:09:12.000 --> 00:09:16.080
So for our Spackle application, our Spackle
application will have its privileged helper,

00:09:16.080 --> 00:09:21.430
and of course that privilege helper, keeping with
least privilege, has one task and one task only.

00:09:21.429 --> 00:09:25.029
And that's overwriting the existing version.

00:09:25.029 --> 00:09:29.220
Now if we're looking at our project and we're
looking at this feature that does the self-updating,

00:09:29.220 --> 00:09:33.710
it might make sense to us as a developer,
to take out the entire self-update feature

00:09:33.710 --> 00:09:36.440
and put that in a separate binary, and
that will be our privileged helper.

00:09:36.440 --> 00:09:41.100
And that might be a great place to divide the
code, but it is a violation of least privilege

00:09:41.100 --> 00:09:44.920
because now we have the code that checks for
the new version, downloads the new version,

00:09:44.919 --> 00:09:49.649
and links to get all those things, to use that
functionality, that will also be running with privilege.

00:09:49.649 --> 00:09:53.449
So we really only want the part
that does the actual overwriting

00:09:53.450 --> 00:09:55.980
of the application to be in this separate helper.

00:09:55.980 --> 00:10:01.539
And our protocol over our Unix domain
socket maybe, will be very simple.

00:10:01.539 --> 00:10:08.029
We'll have a source path, a destination path, and you
get back some result; probably 0 if there's no error.

00:10:08.029 --> 00:10:14.120
So it'll look something like this: we have the current
version of the Spackle application in /applications.

00:10:14.120 --> 00:10:20.139
And we have a newly downloaded version with a great new
icon, it's got a red handle on it, that's a huge feature.

00:10:20.139 --> 00:10:24.250
And that's in the downloads folder
where we've just downloaded it to.

00:10:24.250 --> 00:10:30.159
So Spackle called this cocoa API, move
item at path, to copy over the new version.

00:10:30.159 --> 00:10:37.689
And of course that is denied, because Spackle is not
privileged, cannot overwrite anything in /applications.

00:10:37.690 --> 00:10:39.200
So Spackle's got a little helper tool.

00:10:39.200 --> 00:10:52.340
We call out to our little helper tool, and we say hey, can
you please copy what I've downloaded into my /applications?

00:10:52.340 --> 00:10:59.259
And the helper tool then calls that same API, and of
course it succeeds because this is running with privilege.

00:10:59.259 --> 00:11:03.299
So now we've got a new version of Spackle.

00:11:03.299 --> 00:11:08.409
We've glossed over a very important detail
here, and I'd like to call it out explicitly.

00:11:08.409 --> 00:11:13.539
We're using launchd to get our
helper the privileges that it needs.

00:11:13.539 --> 00:11:17.000
If you're not familiar with launchd, there's
a whole another presentation on Friday,

00:11:17.000 --> 00:11:19.539
you should definitely check it out,
familiar yourself with launchd.

00:11:19.539 --> 00:11:22.500
It's a really great feature of Mac OS X.

00:11:22.500 --> 00:11:32.009
And we're using launchd for our privileged helper
by registering as a launchd job at install time.

00:11:32.009 --> 00:11:37.330
Our application installer that installs the Spackle
application, and installs our privileged helper,

00:11:37.330 --> 00:11:41.180
is also going to install a launchd.plist.

00:11:41.179 --> 00:11:49.009
And this launchd.plist will specify that
we want our helper tool launched as root

00:11:49.009 --> 00:11:52.860
in its own execution environment when we ask for it.

00:11:52.860 --> 00:11:55.259
And this is all triggered off of our IPC mechanism.

00:11:55.259 --> 00:12:01.389
So when we use our Unix domain socket, launchd will
magically make our helper available as root for us.

00:12:01.389 --> 00:12:06.539
It's really great, you should definitely
familiarize yourself with launchd.

00:12:06.539 --> 00:12:14.089
Now let's look at how we can use authorization services
to restrict the use of our privileged helper tool.

00:12:17.379 --> 00:12:22.360
And so let's imagine we have our
privileged helper sitting where it sits,

00:12:22.360 --> 00:12:25.730
and elsewhere on our system we
have a Trojan version of mail.

00:12:25.730 --> 00:12:30.720
Now of course mail lives in /applications,
and we all use mail, everybody uses mail.

00:12:30.720 --> 00:12:35.500
And let's say we're sharing this system with
a malicious user, maybe our little sister.

00:12:35.500 --> 00:12:40.289
And maybe our little sister is
a computer hacker evil genius.

00:12:40.289 --> 00:12:43.319
So she's written this Grout application
that lives in her home folder,

00:12:43.320 --> 00:12:46.010
and the Grout application is going to message the helper.

00:12:46.009 --> 00:12:52.470
And the Grout application's going to say - hey
helper, how about you take this Trojan mail

00:12:52.470 --> 00:12:53.899
that I have and you write over mail with it?

00:12:53.899 --> 00:12:56.250
Now the helper's not malicious.

00:12:56.250 --> 00:12:59.789
The helper's part of our Spackle
app, but the helper is naive.

00:12:59.789 --> 00:13:03.299
So the helper helps, and says sure no problem sis.

00:13:03.299 --> 00:13:08.079
And now we got a Trojan version of
mail on the system, unbeknownst to me.

00:13:08.080 --> 00:13:11.870
And my little sister's reading my
mail, tattling to Mom, headaches.

00:13:11.870 --> 00:13:15.080
I'd like to avoid this.

00:13:15.080 --> 00:13:17.759
So we can use authorization services.

00:13:17.759 --> 00:13:20.689
Authorization services acts as a gatekeeper.

00:13:20.690 --> 00:13:25.190
It's important to note that authorization services
isn't going to give us any additional privilege.

00:13:25.190 --> 00:13:30.800
We still want to launch our privileged helper using launchd
to get the actual privileges necessary to complete the job,

00:13:30.799 --> 00:13:38.000
but authorization services will act as a gatekeeper
so that we can restrict use of our privileged helper.

00:13:38.000 --> 00:13:43.629
And one great feature of authorization services
is that policy is separate from the code.

00:13:43.629 --> 00:13:49.629
So an application using authorization services
only has to say, hey system can I do operation X?

00:13:49.629 --> 00:13:55.659
And the policy for who can do X when
is elsewhere, and it's configurable.

00:13:55.659 --> 00:14:00.639
So if at a certain site they say well, we only
want this to be done after an admin authentication,

00:14:00.639 --> 00:14:04.129
or this operation can only be done after noon in the day.

00:14:04.129 --> 00:14:08.240
That's configurable by the admin at that
site, and the code doesn't have to be changed

00:14:08.240 --> 00:14:11.950
for those policies to be set by an admin.

00:14:11.950 --> 00:14:17.879
In our policy we'll say we want some user interaction,
and then in general it's not really nice to the user

00:14:17.879 --> 00:14:24.629
to perform any privileged operation without
at least letting them know what's going on.

00:14:24.629 --> 00:14:26.210
So the way this works is pretty simple.

00:14:26.210 --> 00:14:31.170
The application that wants to perform the
privileged operation requests an authorization right

00:14:31.169 --> 00:14:33.870
from the authorization subsystem.

00:14:33.870 --> 00:14:40.149
The authorization subsystem that evaluates the
policy for that specific right, and returns a result.

00:14:40.149 --> 00:14:45.110
If successful it returns the authorization
right that has been requested.

00:14:45.110 --> 00:14:48.659
That authorization right is then handed
over to the privileged helper tool,

00:14:48.659 --> 00:14:52.730
and the privileged helper tool
validated independently to make sure

00:14:52.730 --> 00:14:56.539
that the authorization right was properly obtained.

00:14:59.029 --> 00:15:01.319
So we have the Spackle application....

00:15:01.320 --> 00:15:05.930
and there's a lot of code here we're
cover in a little detail in a minute,

00:15:05.929 --> 00:15:10.219
but I want to point the API we
call is AuthorizationCopyrights.

00:15:10.220 --> 00:15:15.710
Authorization copyrights requests a specific
right from the authorization subsystem.

00:15:15.710 --> 00:15:19.800
The authorization subsystem will prompt the user.

00:15:19.799 --> 00:15:23.779
Now our little sister is not an administrator, we are.

00:15:23.779 --> 00:15:28.250
So we can go ahead and authorize this action.

00:15:28.250 --> 00:15:35.269
But before doing so, like any good administrator,
we always click the disclosure triangle.

00:15:35.269 --> 00:15:39.850
The disclosure triangle will tell us,
oh it's the spackle application trying

00:15:39.850 --> 00:15:42.450
to request the com.example.spackle.update right.

00:15:42.450 --> 00:15:46.000
And that seems perfectly reasonable
because Spackle's trying to update.

00:15:46.000 --> 00:15:50.730
Cool. We'll go ahead and put in a password...

00:15:50.730 --> 00:15:57.580
dismiss the dialogue, and the right is
sent back to the Spackle application.

00:15:57.580 --> 00:15:58.540
Excellent.

00:15:58.539 --> 00:16:05.240
Now when we message our helper, you could
see we've augmented our protocol slightly.

00:16:05.240 --> 00:16:09.250
Not only do we provide a source and destination
for the helper to do it's copy operation,

00:16:09.250 --> 00:16:13.519
but we're also providing an authorization right.

00:16:13.519 --> 00:16:21.039
So the helper gets the right, the helper makes
a AuthorizationCopyrights call of its own

00:16:21.039 --> 00:16:24.250
to validate the right, to make sure it's legit.

00:16:24.250 --> 00:16:29.789
Everything checks out, so it calls its API

00:16:29.789 --> 00:16:31.929
... and we get a new Spackle.

00:16:34.740 --> 00:16:42.909
But now what happens when little sis comes along
again and tries to copy the Trojan mail over mail?

00:16:42.909 --> 00:16:48.740
Grout messages the helper, but Grout
doesn't provide an authorization right

00:16:48.740 --> 00:16:57.539
because Grout doesn't have an authorization right,
because Grout hasn't been authorized by the user.

00:16:57.539 --> 00:16:58.939
The helper's not willing to help Grout anymore.

00:16:58.940 --> 00:17:04.940
Now let's look at code identity.

00:17:04.940 --> 00:17:16.140
We'll see how we can use code identity to further
restrict the functionality of our privileged helper.

00:17:16.140 --> 00:17:22.350
We know that we call AuthorizationCopyrights to
request a right from authorization subsystem,

00:17:22.349 --> 00:17:29.019
and the authorization subsystem only gives
the right back if an admin authenticates.

00:17:29.019 --> 00:17:38.369
And this makes sense because our helper
app actually just overwrites A with B.

00:17:38.369 --> 00:17:46.089
Right? Essentially our helper app takes a source at a
destination, and arbitrarily copies whatever is passed

00:17:46.089 --> 00:17:50.259
over whatever it's supposed to copy to, and it does
this as root, so it could do this in one other system.

00:17:50.259 --> 00:17:52.210
It's in fact a very, very dangerous facility.

00:17:52.210 --> 00:17:57.850
So we like to narrow down the privilege,
get a little closer to least privilege,

00:17:57.849 --> 00:18:01.879
and make it so it can really only
update because that's the goal here.

00:18:01.880 --> 00:18:05.580
We only want a helper that updates Spackle,
not one that arbitrarily copies as root.

00:18:05.579 --> 00:18:09.599
In order to get there, we're going to have
to narrow our privileges a little further.

00:18:09.599 --> 00:18:15.389
So the way we'll do this is we'll assign an identity.

00:18:15.390 --> 00:18:19.320
So we'll use it here by assigning an
identity to our Spackle application.

00:18:19.319 --> 00:18:22.039
We do this in Xcode when we build the application.

00:18:22.039 --> 00:18:29.190
And now our privileged helper can validate the
identity, because it won't just arbitrarily copy A to B,

00:18:29.190 --> 00:18:37.029
it'll only copy A to B if A is in fact a newer
version of the same application from the same vendor.

00:18:37.029 --> 00:18:43.839
And that's the only time it'll actually do this copying
for us, which for us using it for Spackle is great.

00:18:43.839 --> 00:18:46.939
And it also narrows down what a
malicious user could do with it.

00:18:46.940 --> 00:18:56.539
So now that there's no arbitrarily overwriting,
it's probably OK to relax our policy a little bit.

00:18:56.539 --> 00:19:00.799
Previously our policy said only an admin
can use this, requires admin authentication.

00:19:00.799 --> 00:19:07.049
But now it's not as dangerous as it once was, it's
probably OK to not require admin authentication.

00:19:07.049 --> 00:19:13.009
So one less authentication dialogue on
the system, and of course this is great

00:19:13.009 --> 00:19:16.140
for the user because users hate dialogues.

00:19:16.140 --> 00:19:23.590
Now let's look at authorization plug-ins and see
if we can customize the authorization experience.

00:19:25.740 --> 00:19:27.509
We mentioned we're going to relax the policy

00:19:27.509 --> 00:19:32.849
to no longer require admin authentication,
which is great, people hate dialogues.

00:19:32.849 --> 00:19:38.339
But we should require some user interaction,
and ideally this will be a helpful message.

00:19:38.339 --> 00:19:43.089
We'll provide a helpful dialogue to the user
instead of just a generic authenticate now.

00:19:43.089 --> 00:19:46.889
This dialogue would say hey, you currently
have this version, this is the new version,

00:19:46.890 --> 00:19:49.500
but here are the features, whatever we want.

00:19:49.500 --> 00:19:54.220
And authorization plug-ins is going to help us do this.

00:19:54.220 --> 00:19:59.430
So the plug-in will be installed at install time, the
same install that installs our application and our helper

00:19:59.430 --> 00:20:02.850
and launchd.plist can also install our plug-in for us.

00:20:02.849 --> 00:20:11.059
And we set the policy for the
com.example.spackle.updateright that will be requested.

00:20:11.059 --> 00:20:14.259
We'll specify in that policy that
we want to use our plug-in.

00:20:14.259 --> 00:20:20.009
So the plug-in will be invoked when the
Spackle application requests the right

00:20:20.009 --> 00:20:23.740
for updating Spackle from authorization subsystem.

00:20:23.740 --> 00:20:26.450
Looks a little bit like this.

00:20:26.450 --> 00:20:32.580
We call AuthorizationCopyrights to request
the com.example.spackle.updateright.

00:20:32.579 --> 00:20:40.199
And instead of getting a generic authenticate now you admin,
we get this dialogue that tells us there's a new version,

00:20:40.200 --> 00:20:42.539
and it tells us some details about the new version.

00:20:42.539 --> 00:20:45.920
It's kind of nice.

00:20:45.920 --> 00:20:48.880
So let's review what we've seen so far.

00:20:50.609 --> 00:20:59.219
We're using launchd to launch our helper tool with
privileges in it's own execution environment on demand.

00:20:59.220 --> 00:21:05.279
We're using authorization services to
control access to our privileged helper tool.

00:21:05.279 --> 00:21:09.829
We're using code identity to greatly restrict
the functionality of our privileged helper,

00:21:09.829 --> 00:21:14.179
though it runs with privilege it does a whole lot less now.

00:21:14.180 --> 00:21:17.170
And we're using authorization plug-ins
to customize the experience for the user.

00:21:17.170 --> 00:21:20.009
Now let's give a quick demo.

00:21:20.009 --> 00:21:27.839
[ Silence ]

00:21:27.839 --> 00:21:33.240
I'd like to start by looking at the
actual Spackle project here, launch Xcode.

00:21:33.240 --> 00:21:43.000
Now you can see that in the project we have an application,
and of course we have our privileged helper code,

00:21:43.000 --> 00:21:48.279
and we have our plug-in that presents our UI.

00:21:50.029 --> 00:21:56.950
If we look at some of the target settings for our
application, we can see in this code signing section here

00:21:56.950 --> 00:22:00.160
that we've assigned a code signing identity.

00:22:00.160 --> 00:22:07.130
And that is the identity that the helper tool is going
to use to verify that a new version we're trying to copy

00:22:07.130 --> 00:22:09.750
over is in fact a new version of the same application.

00:22:09.750 --> 00:22:14.009
It knows this because it has the same code signing identity.

00:22:14.009 --> 00:22:18.539
[ Silence ]

00:22:18.539 --> 00:22:20.799
We'll look at our helper tool.

00:22:20.799 --> 00:22:23.919
Of course I mentioned our helper tool
is going to be launched by launchd.

00:22:23.920 --> 00:22:28.680
And that's defined by this launchd.plist
that we will install.

00:22:30.549 --> 00:22:36.789
We could see here essentially what this plist says
to launchd, is please launch our helper which lives

00:22:36.789 --> 00:22:42.369
at this path, that's where we install
it, when we use this Unix domain socket.

00:22:42.369 --> 00:22:48.049
So when we send a message over our IPC mechanism,
launchd will automatically launch our helper for us.

00:22:48.049 --> 00:22:48.599
It's pretty great.

00:22:48.599 --> 00:22:54.990
And finally I want to take a look at our plug-in here.

00:22:54.990 --> 00:22:57.839
Our plug-in has a name of course to present our UI.

00:22:57.839 --> 00:23:04.539
I just want to point out that this is very generic,
there isn't a whole lot of information field out here,

00:23:04.539 --> 00:23:09.589
and that's because our plug-in is going to be used for all
the various update versions that come along of Spackle.

00:23:09.589 --> 00:23:15.589
So the Spackle application actually populates this
information by putting in what's called a security context.

00:23:15.589 --> 00:23:21.679
And then the plug-in can take the information that was
provided from the application, and display to the user.

00:23:22.690 --> 00:23:27.320
So now let's take a second to see
how our Spackle application works.

00:23:27.319 --> 00:23:33.990
We can see that we have the Spackle 1.0
version, because this handsome UI tells us that.

00:23:33.990 --> 00:23:36.390
And we have a button here that says "check for updates".

00:23:36.390 --> 00:23:41.400
Now of course normally when you have a self-updating
feature in your application, you don't have a button,

00:23:41.400 --> 00:23:44.400
it just does it when it launches
or a minute after launch, whatever.

00:23:44.400 --> 00:23:47.400
But for demonstration purposes we put a button here.

00:23:47.400 --> 00:23:49.220
So we'll pretend it's just launching.

00:23:49.220 --> 00:23:52.910
We'll accept for updates, and this is
before we've installed our custom plug-in.

00:23:52.910 --> 00:24:00.170
So this is the typical experience if you don't have any
custom UI, it says oh, Spackle wants to change things.

00:24:00.170 --> 00:24:06.410
I look, it is in fact Spackle, it does in fact want
to update, so I'll go ahead and I'll authenticate.

00:24:06.410 --> 00:24:08.440
And now we have the new version.

00:24:08.440 --> 00:24:11.420
It downloads very fast because
of our super fast internet here.

00:24:11.420 --> 00:24:13.500
Now let's reset that real quick.

00:24:13.500 --> 00:24:18.819
And just for contrast we'll see what happens
when we have the code signing implemented,

00:24:18.819 --> 00:24:23.970
so we don't require admin authentication,
and we also want to use our custom plug-in

00:24:23.970 --> 00:24:26.700
to provide a little more information to the user.

00:24:26.700 --> 00:24:33.640
Now we check for updates and we get this plug-in that says
a new version is available, it says the new version's 2,

00:24:33.640 --> 00:24:37.009
you currently have 1, it's compatible, there's features...

00:24:37.009 --> 00:24:37.450
it's great.

00:24:37.450 --> 00:24:42.140
It's a helpful dialogue, so we install the update.

00:24:43.890 --> 00:24:48.310
So we've seen this a couple of times now, where
Spackle gets the right and passes the right,

00:24:48.309 --> 00:24:51.659
and helper validates the right, and we update Spackle.

00:24:51.660 --> 00:24:55.480
But I want to take a look at a couple of
parts of this in a little more detail.

00:24:55.480 --> 00:25:00.019
And we'll start with this authorization exchange,

00:25:00.019 --> 00:25:04.029
the exchange between the Spackle
application authorization subsystem,

00:25:04.029 --> 00:25:07.269
and of course the helper in authorization subsystem.

00:25:07.269 --> 00:25:11.269
And this starts with a Spackle
application calling authorization

00:25:11.269 --> 00:25:14.200
to create, to create an authorization reference.

00:25:14.200 --> 00:25:20.950
And this reference is a handle to a set of 0 or more
rights, and upon creation there's no rights there,

00:25:20.950 --> 00:25:29.750
but then we'll call AuthorizationCopyrights to populate
our reference with the right that we're requesting.

00:25:29.750 --> 00:25:35.549
We'll have to call AuthorizationMakeExternalForm to
externalize our authorization reference into a form

00:25:35.549 --> 00:25:40.589
that we can pass over our IPC to our helper.

00:25:42.609 --> 00:25:47.559
So of course the first thing is well I've got
to define exactly what right we're requesting,

00:25:47.559 --> 00:25:51.279
and we're requesting com.example.spackle.update.

00:25:51.279 --> 00:25:55.329
We call AuthorizationCreate to create
an authorization reference for us.

00:25:55.329 --> 00:26:02.889
We set some flags here, and specifically we're
specifying authorization flag, interaction allowed.

00:26:02.890 --> 00:26:06.930
And what that means to the authorization
subsystem is it's OK to interact

00:26:06.930 --> 00:26:09.250
with the user, I'm trying to acquire a new right.

00:26:09.250 --> 00:26:14.509
I don't already have one, so do what you
have to do to acquire me this new right.

00:26:14.509 --> 00:26:20.559
Then we call AuthorizationCopyrights, and
we get back the right we've requested.

00:26:23.029 --> 00:26:35.539
We call AuthorizationMakeExternalForm, and that transforms
our right into an external form we can send over IPC.

00:26:35.539 --> 00:26:40.069
So we send it over to the helper.

00:26:40.069 --> 00:26:45.950
Now the helper calls AuthorizationCreateFromExternalForm,
to internalize the auth ref.

00:26:45.950 --> 00:26:52.519
It then calls AuthorizationCopyrights
to validate it by saying,

00:26:52.519 --> 00:26:58.210
hey authorization subsystem I have
this right in my auth ref, is it valid?

00:27:01.809 --> 00:27:07.809
So we see CreateFromExternalForm to
internalize the auth ref we've been passed,

00:27:07.809 --> 00:27:10.399
and we call AuthorizationCopyrights this time.

00:27:10.400 --> 00:27:16.150
We don't have an interaction flag because we don't want to
interact the user, we're not trying to acquire a new right,

00:27:16.150 --> 00:27:21.450
we're just trying to make sure that the
right we're checking on is here and is valid.

00:27:21.450 --> 00:27:27.539
The reply back from authorization subsystem says it's great.

00:27:27.539 --> 00:27:30.309
Now I want to talk a little bit about our policy database.

00:27:30.309 --> 00:27:37.879
We know we call AuthorizationCopyrights to
request a right from the authorization subsystem.

00:27:37.880 --> 00:27:41.100
But of course the authorization
subsystem doesn't just flip a coin,

00:27:41.099 --> 00:27:44.129
it doesn't say like oh, now's a
good time to get a right out.

00:27:44.130 --> 00:27:50.940
It checks on the specific policy in the
authorization subsystem's policy database.

00:27:50.940 --> 00:27:54.440
And it checks the policy for that specific right.

00:27:54.440 --> 00:28:01.930
There are many different privilege operations; each of
them has a different right defined with a different policy.

00:28:01.930 --> 00:28:05.500
So we're getting the policy for that specific right.

00:28:07.119 --> 00:28:11.569
And then of course authorization
subsystem evaluates that policy.

00:28:11.569 --> 00:28:17.279
So the policy database is composed of these rights and
rules, and the rights are of course what we request,

00:28:17.279 --> 00:28:20.029
and the rules are used to make up the policy for each right.

00:28:20.029 --> 00:28:25.970
And the developers who add a privileged
operation to the system add a right.

00:28:25.970 --> 00:28:31.089
When we add our Spackle application to the system,
we add the com.example.spackle.updateright.

00:28:31.089 --> 00:28:36.929
That's a new privilege operation using our privileged
helper, and so we add a right to the system.

00:28:36.930 --> 00:28:41.070
Of course we define a default policy, and
that may say "require admin authentication".

00:28:41.069 --> 00:28:44.319
Or in our case it may say, you
don't need admin authentication,

00:28:44.319 --> 00:28:47.309
but you do you need to use our plug-in
that presents a UI to the user.

00:28:47.309 --> 00:28:52.429
But the administrator at the site can configure this policy.

00:28:52.430 --> 00:28:55.750
There may be a site where they say, well
any application that installs or updates

00:28:55.750 --> 00:28:58.539
or any of that business, has to do admin authentication.

00:28:58.539 --> 00:29:00.639
That's perfectly reasonable, that's very simple.

00:29:00.640 --> 00:29:05.509
They just modify the policy for the Spackle
update right to require admin authentication.

00:29:05.509 --> 00:29:13.410
The policy database is currently an XML
plist, it lives in /etc/authorization.

00:29:13.410 --> 00:29:17.110
If you're curious, I definitely encourage you to take
a look at it, there's some rights, there's some rules.

00:29:17.109 --> 00:29:18.789
But it is format...

00:29:18.789 --> 00:29:23.299
the format of this is subject to
change, that you not modify it manually.

00:29:23.299 --> 00:29:26.069
We'll show you some API for that.

00:29:26.069 --> 00:29:28.889
It's a plist, it's pretty straightforward.

00:29:28.890 --> 00:29:34.530
Got some rights, got some rules,
we'll talk about both of them.

00:29:34.529 --> 00:29:40.759
So when our installer installs our application, and installs
our privileged helper, and installs our launchd.plist,

00:29:40.759 --> 00:29:45.779
and installs our plug-in, we also
need to call AuthorizationRightSet.

00:29:45.779 --> 00:29:51.210
So we have an installer helper tool that will
call AuthorizationRightSet to add the right

00:29:51.210 --> 00:29:56.819
to the policy database with our default
policy, and that way it can be requested

00:29:56.819 --> 00:30:00.279
by our Spackle application when it needs to update.

00:30:01.690 --> 00:30:11.289
The installer helper tool calls AuthorizationRightSet, and
then the authorization subsystem takes the default policy

00:30:11.289 --> 00:30:16.609
and adds the right to the policy database.

00:30:16.609 --> 00:30:19.389
The rights are defined in the policy database.

00:30:19.390 --> 00:30:24.370
There are many rights that are on the system by default for
all the various privilege operations that the system does,

00:30:24.369 --> 00:30:29.299
and of course there are many rights that are added
by applications that perform privileged operations.

00:30:29.299 --> 00:30:34.319
Ideally we'll have a different right for each operation.

00:30:34.319 --> 00:30:40.759
If your application performs multiple different privileged
operations, even if your default policy is the same,

00:30:40.759 --> 00:30:44.619
you should add a different right for
each different privileged operation

00:30:44.619 --> 00:30:49.659
because they may be configured differently at certain sites.

00:30:50.829 --> 00:30:55.689
A right is simply the right name, and then a set
of rules that make up the policy for that right.

00:30:55.690 --> 00:31:00.130
These are the rules that must succeed
for the right to be granted.

00:31:00.130 --> 00:31:02.180
It's pretty straightforward.

00:31:02.180 --> 00:31:06.670
There's a name, it's a dictionary of rules.

00:31:06.670 --> 00:31:14.140
There is a naming convention, looks a little like
this - com.mycompany.myapplication.whatthisrightdoes.

00:31:14.140 --> 00:31:18.680
In our example it was com.example.spackle.update.

00:31:18.680 --> 00:31:20.920
There are wild cards in the naming.

00:31:20.920 --> 00:31:24.029
If you look at the [inaudible]
authorization, the policy database,

00:31:24.029 --> 00:31:27.139
you'll probably see some rights that end in a period.

00:31:27.140 --> 00:31:33.430
And anything that ends in a dot or a period implies a set
of identical rights, meaning it implies a set of rights

00:31:33.430 --> 00:31:37.670
that all have the same policy, because
they have the same set of rules in there.

00:31:37.670 --> 00:31:39.190
There are some reserved names.

00:31:39.190 --> 00:31:40.320
You may see a system.

00:31:40.319 --> 00:31:42.769
or config.

00:31:42.769 --> 00:31:44.629
rights in there.

00:31:44.630 --> 00:31:46.850
Those are like for the system by the system.

00:31:46.849 --> 00:31:54.169
Any rights you add to the system you definitely
want to use a com.whatever, reverse DNS naming.

00:31:54.170 --> 00:31:59.580
And let's look at these authorization rules.

00:31:59.579 --> 00:32:05.509
So Spackle calls AuthorizationCopyrights
to request the right,

00:32:05.509 --> 00:32:11.750
and the authorization subsystem consults
the policy database for that specific right.

00:32:11.750 --> 00:32:19.160
And what it expects back from the policy database is the
set of rules that must be satisfied; that is the policy.

00:32:19.160 --> 00:32:22.550
So it gets back a set of rules.

00:32:22.549 --> 00:32:29.309
Of course the rules are defined in the policy
database, and each right is composed of rules.

00:32:29.309 --> 00:32:36.009
A right is a policy, a right has a policy that is made
up of these various rules, all which must succeed.

00:32:36.009 --> 00:32:43.549
Rules have both properties and
classes, which we'll explain now.

00:32:43.549 --> 00:32:49.680
The three properties we want to look at
- authenticate-user, timeout, and shared.

00:32:49.680 --> 00:32:52.090
So this is our example right.

00:32:52.089 --> 00:32:55.970
You can see the authenticate-user property.

00:32:55.970 --> 00:32:59.809
Authenticate-user is a bullion, true is
a default, you could set it to false.

00:32:59.809 --> 00:33:08.730
And what this says is this tells the authorization
subsystem while trying to satisfy this policy,

00:33:08.730 --> 00:33:16.000
so you can grant this right, it's OK to present the
user with some UI and allow them to authenticate.

00:33:16.000 --> 00:33:21.640
Of course the default is true and that's often the case, but
there may be times when it's not appropriate to present UI.

00:33:21.640 --> 00:33:25.620
And if that is the case, you definitely
want to explicitly set this to false.

00:33:25.619 --> 00:33:32.159
There's a timeout, the timeout is
an integer specified in seconds,

00:33:32.160 --> 00:33:38.029
and that tells authorization services how long
it should cache the result of this evaluation.

00:33:38.029 --> 00:33:43.109
If you have an application that performs a
privileged operation, and maybe in your GUI it's

00:33:43.109 --> 00:33:45.859
when the user clicks whatever, a little button or something.

00:33:45.859 --> 00:33:51.689
That may happen many times successively, and if the
policy requires authentication you don't want that popping

00:33:51.690 --> 00:33:54.990
up every time so you might put a
timeout of a couple of minutes in there,

00:33:54.990 --> 00:33:59.329
so successive attempts will just
get back the previous evaluation.

00:34:00.930 --> 00:34:07.490
And shared says whether this evaluation, the result
of this evaluation, can be shared with other rights.

00:34:07.490 --> 00:34:11.659
You may have many rights to have the
same policy, the same set of rules.

00:34:11.659 --> 00:34:18.989
And if you share the result of one, any equivalent
right, meaning having the same set of rules,

00:34:18.989 --> 00:34:26.969
can share the evaluation result for within that timeout.

00:34:26.969 --> 00:34:28.859
Rules have classes.

00:34:28.860 --> 00:34:31.590
There are six here.

00:34:31.590 --> 00:34:35.890
The first two are lame, because they
just allow and deny, so we'll skip those.

00:34:35.889 --> 00:34:40.170
But let's look at these other four in some detail.

00:34:40.170 --> 00:34:45.269
The user class comes in two forms -
user and group, and session owner.

00:34:45.269 --> 00:34:48.429
Let's look at this in context.

00:34:48.429 --> 00:34:50.099
This is an actual right on the system.

00:34:50.099 --> 00:34:54.809
I don't know if you use activity monitor,
it's in /utilities, /application/utilities.

00:34:54.809 --> 00:34:57.849
But this is the right that is used when
you want to kill something that's running.

00:34:57.849 --> 00:35:06.730
And this uses the user class to specify that the
user trying to perform this operation has to be

00:35:06.730 --> 00:35:09.590
in the admin group, they have to be an admin on the system.

00:35:09.590 --> 00:35:12.800
That makes sense, and this is of
course used in a lot of places.

00:35:12.800 --> 00:35:17.130
So another actual right on the system, and
this one specifies that the user trying

00:35:17.130 --> 00:35:20.329
to obtain this authorization right
has to be currently logged in.

00:35:20.329 --> 00:35:23.159
They have to be a session owner.

00:35:25.210 --> 00:35:28.970
The evaluate mechanisms class.

00:35:28.969 --> 00:35:36.389
In our example we used a plug-in to present some custom
user interface, but plug-ins can have multiple mechanisms.

00:35:36.389 --> 00:35:42.929
A plug-in has one or more mechanisms, and these
mechanisms can acquire, operate, on authorization data.

00:35:42.929 --> 00:35:48.089
We'll cover plug-ins in a little more detail
in just a minute, but I also want to specify

00:35:48.090 --> 00:35:56.170
that they can be specified to run as root, or
to run as a special security agent rule account.

00:35:56.170 --> 00:36:01.880
So we'll look at an actual example on the system,
and this right is used when you try to restart

00:36:01.880 --> 00:36:06.510
or shut down the system, when there's another user
who's logged in but like fast user switched away...

00:36:06.510 --> 00:36:15.400
presents this UI that says hey, somebody else logged
in, you're really sure you want to screw them over?

00:36:15.400 --> 00:36:23.539
So it requires admin authentication

00:36:23.539 --> 00:36:27.349
... and this right uses the evaluate mechanisms.

00:36:27.349 --> 00:36:32.250
You can see here that there's four
mechanisms to be evaluated.

00:36:32.250 --> 00:36:39.360
The first part specifies the plug-in, built in isn't an
actual plug-in, it's a set of mechanisms that are built

00:36:39.360 --> 00:36:43.500
into the authorization subsystem, but the
restart authorization is an actual plug-in.

00:36:43.500 --> 00:36:49.889
It's a .bundle that was on the system, and it provides two
mechanisms we're using here on the second and fourth lines.

00:36:49.889 --> 00:36:53.549
The part after the colon specifies the
specific mechanism you want to use.

00:36:53.550 --> 00:36:58.519
And all of these mechanisms are evaluated in order,
and each has to succeed for the next to be invoked.

00:36:58.519 --> 00:37:01.929
And finally on the end, there's an optional [inaudible],

00:37:01.929 --> 00:37:05.579
which specifies whether this mechanism
has to be run as root.

00:37:05.579 --> 00:37:09.460
Now this is not true for our restart
authorization plug-in because there's no need to run

00:37:09.460 --> 00:37:15.349
that with any special privilege, but of course on the third
line you can see the built in authenticate is privileged,

00:37:15.349 --> 00:37:17.529
and that makes sense, that's a privileged operation.

00:37:17.530 --> 00:37:21.850
Otherwise we could have users on the
system just checking passwords all day.

00:37:23.809 --> 00:37:27.070
There is a rule class for rules.

00:37:27.070 --> 00:37:29.070
We sometimes call that delegation because it's a mouthful.

00:37:29.070 --> 00:37:34.140
And that allows us to compose a rule of other rules.

00:37:34.139 --> 00:37:41.039
It uses logical ending, meaning all the rules have
to succeed, but you can also specify as subsets.

00:37:41.039 --> 00:37:47.400
You could say I have this set of rules, and if any
three of these five succeed, then that's sufficient.

00:37:50.150 --> 00:37:55.880
This is an actual right on the system, and
it's using the k-of-nsubset with an integer 1;

00:37:55.880 --> 00:38:03.800
meaning if any one of these three rules
succeed, that it's OK to grant this right.

00:38:03.800 --> 00:38:05.190
So that's ORing right?

00:38:05.190 --> 00:38:11.250
Because if any 1 of a subset, so we set
up logical ORing there with a k-of-n1.

00:38:11.250 --> 00:38:13.409
And finally the default rule.

00:38:13.409 --> 00:38:19.909
The default rule is used if no other rule is specified
for a right, requires the user to be an admin,

00:38:19.909 --> 00:38:24.489
of course they can authenticate as an admin if need be.

00:38:24.489 --> 00:38:30.199
There is a 5 minute timeout because
it's used in a few places, it's shared.

00:38:30.199 --> 00:38:33.389
It's a default so it's used all over.

00:38:33.389 --> 00:38:38.440
This is a right on the system that actually
calls out the default rule explicitly,

00:38:38.440 --> 00:38:43.280
but of course if no rule is specified
the default rule is implied.

00:38:43.280 --> 00:38:48.430
And this is the actual definition for our default rule.

00:38:49.690 --> 00:38:56.019
You can see we're using the user class to specify the
user has to be in the admin group, it's shared of course.

00:38:56.019 --> 00:39:01.199
We've a 300 second or 5 minute timeout on the default rule.

00:39:01.199 --> 00:39:05.009
And finally I'd like to look at authorization plug-ins.

00:39:05.010 --> 00:39:11.750
[ Silence ]

00:39:11.750 --> 00:39:17.570
We call AuthorizationCopyrights to obtain
the right from the authorization subsystem,

00:39:17.570 --> 00:39:21.160
and the policy comes from the policy database.

00:39:21.159 --> 00:39:26.059
And this policy may require admin
authentication, or may require some other UI,

00:39:26.059 --> 00:39:29.509
like in our example we're using a plug-in.

00:39:29.510 --> 00:39:33.190
So the authorization subsystem
calls on SecurityAgent for this.

00:39:33.190 --> 00:39:37.809
SecurityAgent is actually what on the
system provides us with this dialogue.

00:39:37.809 --> 00:39:44.980
Now of course as in our example we're using a
plug-in, Security Agent also presents the UI for that,

00:39:44.980 --> 00:39:49.610
dynamically loading the plug-in, and
presenting the UI from that plug-in instead.

00:39:49.610 --> 00:39:55.110
So let's take a look at the anatomy of these plug-ins here.

00:39:55.110 --> 00:39:59.160
We mentioned that each plug-in has one or more mechanisms.

00:39:59.159 --> 00:40:06.170
And the mechanisms extend authorization
functionality by having some kind of UI

00:40:06.170 --> 00:40:10.869
that acquires authorization information from the user...

00:40:10.869 --> 00:40:18.880
or operating on data that has been obtained
from the system, or from the UI you presented.

00:40:18.880 --> 00:40:25.710
So you can imagine an authorization plug-in that
does authentication based on retina scanning.

00:40:25.710 --> 00:40:28.940
You could have a single plug-in with two mechanisms.

00:40:28.940 --> 00:40:33.010
The first mechanism presents a UI that says
please place your retina on the track pad.

00:40:33.010 --> 00:40:35.570
[ Laughter ]

00:40:35.570 --> 00:40:42.140
And you could have another mechanism in the same plug-in
that analyzes the multi-touch data of your retina

00:40:42.139 --> 00:40:48.679
to verify it's in fact you, with your retina on a track pad.

00:40:48.679 --> 00:40:51.149
Three more points we want to cover on plug-ins.

00:40:51.150 --> 00:40:52.849
The first is the location.

00:40:52.849 --> 00:40:59.670
Any plug-ins you add to the system should definitely go in
/library/security/SecurityAgentPlugins /pluginName.bundle

00:40:59.670 --> 00:41:02.650
where of course the plug-in name
is the name of your plug-in.

00:41:02.650 --> 00:41:08.160
You may see plug-ins elsewhere on the system if you
look around, those are for the system by the system.

00:41:08.159 --> 00:41:13.589
Any plug-ins you add should definitely be
in /library/security/SecurityAgentPlugins.

00:41:13.590 --> 00:41:18.890
And Security Agent does not look into the
library, so don't put any plug-ins in there.

00:41:18.889 --> 00:41:24.269
They have to be in /library/security/SecurityAgentPlugins.

00:41:24.269 --> 00:41:29.900
The life cycle of a plug-in, I just want to
call this out to be clear about this part here.

00:41:29.900 --> 00:41:39.700
We call plug-in instantiation when a plug-in is used in the
evaluation for a right, we call plug-in clean up at the end.

00:41:39.699 --> 00:41:44.069
And we iterate through four mechanism
steps for each mechanism we're using.

00:41:44.070 --> 00:41:49.370
So for our retina scan, we call plug-in instantiation
and then iterate through the mechanisms twice -

00:41:49.369 --> 00:41:54.039
once for each step of the retina scan - and
then for each mechanism of the retina scan,

00:41:54.039 --> 00:41:58.559
and then we call plug-in clean up at the end.

00:41:58.559 --> 00:42:03.500
If you are making your own plug-ins
that do present UI for the user,

00:42:03.500 --> 00:42:08.489
you should definitely take a look
at SFAuthorizationPluginView.

00:42:08.489 --> 00:42:17.299
It's an objective C class, it's provided by the Security
Interface Framework, and it's just a base for adding a view

00:42:17.300 --> 00:42:20.350
to the standard off dialogues that we put up.

00:42:20.349 --> 00:42:25.230
So if you need to acquire some information, you
need to say please put your retina on the track pad,

00:42:25.230 --> 00:42:28.760
or put your thumb on the eyesight, whatever you're doing...

00:42:28.760 --> 00:42:32.910
you definitely should take a look
at SFAuthorizationPluginView.

00:42:35.070 --> 00:42:37.130
So let's review what we've seen.

00:42:37.130 --> 00:42:42.829
We have our Spackle application in
/applications, properly installed application.

00:42:42.829 --> 00:42:47.509
We have a new version that Spackle's just
downloaded for us in the downloads folder.

00:42:47.510 --> 00:42:55.940
Spackle's going to call AuthorizationCopyrights to
obtain the rights to update itself from the system.

00:42:55.940 --> 00:43:01.240
Authorization subsystem's going to consult with
the policy database on that specific right.

00:43:01.239 --> 00:43:07.669
The policy requires that we present the user with
some user interface, specifically our plug-in.

00:43:07.670 --> 00:43:14.590
So the authorization subsystem uses Security Agent which
dynamically loads our plug-in to present the user interface.

00:43:14.590 --> 00:43:21.990
The right is returned to the Spackle application.

00:43:21.989 --> 00:43:25.869
We're using launchd to launch our helper on demand.

00:43:25.869 --> 00:43:27.539
We send the right over to the helper.

00:43:27.539 --> 00:43:33.460
The helper does an AuthorizationCopyrights
call of its2a own to validate the right.

00:43:33.460 --> 00:43:37.880
And we have a new version of Spackle.

00:43:40.570 --> 00:43:45.910
For more information, you can contact Craig
Keithley, he would love to hear from you.

00:43:45.909 --> 00:43:52.879
We have some sample code, both for
Authorization Services proper and plug-ins.

00:43:52.880 --> 00:43:57.019
If you're going to create plug-ins there's
a couple of great examples for that.

00:43:59.090 --> 00:44:04.309
There's header files of course for
authorization proper and plug-ins.

00:44:08.829 --> 00:44:18.179
We have some documentation here for authorization
and for getting you started with launchd.

00:44:18.179 --> 00:44:23.599
In summary, we encourage you to take any
privileged operations your application needs

00:44:23.599 --> 00:44:27.489
to perform, and put them in a separate executable.

00:44:27.489 --> 00:44:34.519
Use launchd to launch this executable,
with the privilege level it needs.

00:44:34.519 --> 00:44:40.509
You should use Authorization Services to gate
the access and use of your privileged helper.

00:44:40.510 --> 00:44:48.380
You can implement code identity, in our case to eliminate
redundant authorization authentication dialogue.

00:44:48.380 --> 00:44:58.460
And you can customize the user experience, and extend
authorization in general with authorization plug-ins.
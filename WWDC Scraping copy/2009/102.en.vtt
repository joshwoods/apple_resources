WEBVTT

00:00:12.800 --> 00:00:17.990
>> Good afternoon, my name's Josh and I'm
an engineer on the iPhone Frameworks Team.

00:00:17.989 --> 00:00:22.750
And I'll be joined shortly by Eliza, who's an engineer on
the iPhone Apps Team and she'll be doing some great demos

00:00:22.750 --> 00:00:25.259
of all kinds of things that you can do in UIScrollView.

00:00:25.260 --> 00:00:28.240
And all the demos that she's doing
actually are going to be available

00:00:28.239 --> 00:00:30.539
as sample code, in fact, I believe they're already up.

00:00:30.539 --> 00:00:31.160
So...

00:00:31.160 --> 00:00:33.009
[ Laughter ]

00:00:33.009 --> 00:00:34.859
[ Applause ]

00:00:34.859 --> 00:00:38.079
...you'll actually want to give her
many hands over the course of this time.

00:00:38.079 --> 00:00:39.390
She's spent a lot of time on these demos.

00:00:39.390 --> 00:00:41.020
There's a lot of great stuff in there.

00:00:41.020 --> 00:00:43.359
I think it's going to help everyone out, hopefully.

00:00:43.359 --> 00:00:46.359
So do check that out.

00:00:46.359 --> 00:00:50.329
So we're going to talk about UIScrollView.

00:00:50.329 --> 00:00:53.170
When you have a lot of content and you're starting
out, trying to figure out what to do with it,

00:00:53.170 --> 00:00:55.390
you're looking through the docs,
seeing what you've got and you like it.

00:00:55.390 --> 00:00:59.480
The first thing you're probably going to come
across is UIScrollView, and that's great.

00:00:59.479 --> 00:01:01.719
And it may be exactly what you want.

00:01:01.719 --> 00:01:06.129
But you may also be interested in looking at
some of the other options that are available.

00:01:06.129 --> 00:01:10.399
If you missed the session yesterday, there was a whole
session on UITableView, you can check that out later.

00:01:10.400 --> 00:01:16.090
There's also UITextView, if you have
just a lot of text, and UIWebView,

00:01:16.090 --> 00:01:20.030
if you've got HTML content or certain
other types of documentsts.

00:01:20.030 --> 00:01:21.030
You can display it in those.

00:01:21.030 --> 00:01:25.230
Anybody not need to deal with UIScrollView
directly, but for the purposes of this session,

00:01:25.230 --> 00:01:27.340
we're going to assume that that's
not what you want and you need

00:01:27.340 --> 00:01:31.810
to display different content and
do it with UIScrollView itself.

00:01:31.810 --> 00:01:36.519
So you might need to do this if you've got more
content that will fit on any one screen, obviously,

00:01:36.519 --> 00:01:40.239
or more content than you can fit in memory at any one time.

00:01:40.239 --> 00:01:42.519
So we're going to go over a few things today.

00:01:42.519 --> 00:01:45.140
We'll start out with configuring your UIScrollView.

00:01:45.140 --> 00:01:48.790
We'll talk about how you can get the
default scrolling and zooming behaviors.

00:01:48.790 --> 00:01:50.150
This is pretty basic stuff.

00:01:50.150 --> 00:01:54.390
We're not going to spend a ton of time on it, but I want to
make sure that we're all on the same page on how this works.

00:01:54.390 --> 00:01:57.980
There's been a bit of confusion about some of
the properties on ScrollView and some things

00:01:57.980 --> 00:02:02.780
that are not necessarily incredibly obvious, just from
looking at the headers in the docs, right off the bat.

00:02:02.780 --> 00:02:03.620
So we'll talk about that.

00:02:03.620 --> 00:02:05.910
Then we're going to talk about interaction.

00:02:05.909 --> 00:02:10.740
You've got touches that you want to handle in subviews
of your ScrollView and you may or may not want them

00:02:10.740 --> 00:02:14.200
to scroll the ScrollView, depending on what
the user's doing or what they're touching.

00:02:14.199 --> 00:02:16.629
We'll talk about how you can control that.

00:02:16.629 --> 00:02:19.259
And finally, we'll talk about optimizing your content.

00:02:19.259 --> 00:02:25.319
You've got a lot of content that you want to display in
your ScrollView and maybe it doesn't all fit in memory,

00:02:25.319 --> 00:02:29.500
maybe it doesn't even all fit on the
device, there's limited flash available.

00:02:29.500 --> 00:02:33.409
We'll talk about what you can do to
optimize the display, speed up load times,

00:02:33.409 --> 00:02:37.490
everything to make the content
display efficiently for your users.

00:02:37.490 --> 00:02:40.250
So first off, let's take a look
at a few examples, real quickly,

00:02:40.250 --> 00:02:43.389
of what UIScrollView is used for on iPhone OS already.

00:02:43.389 --> 00:02:49.509
So first off, on the left here, we've got a UITableView,
actually, which is used to display the bookmarks in Safari.

00:02:49.509 --> 00:02:51.269
And this is a pretty simple example.

00:02:51.270 --> 00:02:55.360
It's just some text, a textual
list with some icons on the left.

00:02:55.360 --> 00:02:56.770
If you missed the session, you can check it out.

00:02:56.770 --> 00:02:59.240
I'm sure a lot of you have already worked with UITableViews.

00:02:59.240 --> 00:03:02.960
You can do some pretty complicated
UIs just using UITableView.

00:03:02.960 --> 00:03:06.740
But now if we take a look at something a little
more complicated, we've got the Maps application.

00:03:06.740 --> 00:03:12.469
This is also a UIScrollView, although it's actually
basically letting your user pan over a nearly infinite plane

00:03:12.469 --> 00:03:15.129
of data and not-- that data is not even stored on the phone.

00:03:15.129 --> 00:03:18.319
It's pulled down over the network from the Google servers.

00:03:18.319 --> 00:03:24.229
And UIScrollView, it's just a subclass of that, that
does some tiling in order to get this content displayed.

00:03:24.229 --> 00:03:29.500
And we'll talk about tiling content later on
and we've got a big, good demo of that as well.

00:03:29.500 --> 00:03:36.000
And finally, we've got the stocks application which
in iPhone OS 3.0 now has even more ScrollViews in it.

00:03:36.000 --> 00:03:40.719
So at the top you've got a table view, which
is just some customized table view cells

00:03:40.719 --> 00:03:42.669
to display all the individual stocks.

00:03:42.669 --> 00:03:45.579
And then at the bottom, there's
a horizontal paging ScrollView

00:03:45.580 --> 00:03:49.680
that has an embedded vertically
scrolling UITableView on one of the pages.

00:03:49.680 --> 00:03:52.409
Now over the course of the last year, we've
heard from a lot of people that they'd

00:03:52.409 --> 00:03:55.319
like to do embedded ScrollViews, one inside of another.

00:03:55.319 --> 00:04:00.789
And the answer has thus far pretty much been, Yeah that's
either not possible or incredibly difficult to do right.

00:04:00.789 --> 00:04:05.150
So in iPhone OS 3.0 embedding one
ScrollView within another is now supported.

00:04:05.150 --> 00:04:07.340
And we'll talk about that later on as well.

00:04:07.340 --> 00:04:12.340
[ Applause ]

00:04:12.340 --> 00:04:15.150
So first off, configuring your ScrollViews.

00:04:15.150 --> 00:04:18.449
So you've got some content and you want to
allow your users to scroll around in it.

00:04:18.449 --> 00:04:19.139
So what are we going to do?

00:04:19.139 --> 00:04:21.159
First off, we've got our content obviously.

00:04:21.160 --> 00:04:22.080
We have to have that.

00:04:22.079 --> 00:04:27.439
And in this case we've got one big UI view with a bunch of
images that are subviews in it, and we're going to set it

00:04:27.439 --> 00:04:29.480
up so that just right off the bat users can scroll.

00:04:29.480 --> 00:04:32.939
And there's actually only one thing you
need to do in order to get that working.

00:04:32.939 --> 00:04:36.699
After-- while-- after you've added this content
as a subview of your ScrollView, one thing to do,

00:04:36.699 --> 00:04:39.629
and that's set the content size property.

00:04:39.629 --> 00:04:42.129
And content size is just the width
and height of your content.

00:04:42.129 --> 00:04:45.829
And with that one thing set, that tells
the ScrollView how much to scroll over,

00:04:45.829 --> 00:04:49.589
and right off the bat users can
pan around within your content.

00:04:49.589 --> 00:04:52.819
Now you might also want to add some
extra padding around the edges of this,

00:04:52.819 --> 00:04:55.040
maybe at the top and bottom or the left and right.

00:04:55.040 --> 00:04:56.910
And we'll talk about why in just a second.

00:04:56.910 --> 00:04:59.950
But there's a property that lets you
do that and that's the content inset.

00:04:59.949 --> 00:05:04.329
And that basically just defines some-- an
extra amount of area around your content

00:05:04.329 --> 00:05:06.639
that can be scrolled into the ScrollView's frame.

00:05:06.639 --> 00:05:09.039
So if we set some content inset at the top and bottom,

00:05:09.040 --> 00:05:12.650
that basically just adds some padding
above and below the content.

00:05:12.649 --> 00:05:15.129
So it, it's a little easier to
understand why you'd want to do this

00:05:15.129 --> 00:05:17.589
if we actually put this in an iPhone and take a look at it.

00:05:17.589 --> 00:05:21.829
So let's overlay an iPhone on top here and
now we've got a full screen UIScrollView.

00:05:21.829 --> 00:05:26.870
It's taking up the entire screen to maximize the amount
of space that the user can use to look at your content.

00:05:26.870 --> 00:05:30.780
But you probably also want some kind of
controls to be visible at some point.

00:05:30.779 --> 00:05:34.329
So we're going to add at the top
a navigation bar and a status bar.

00:05:34.329 --> 00:05:36.979
But now the content's behind that
and you know that's not so good.

00:05:36.980 --> 00:05:40.830
You really want your users to be able to see all the
content even when it's scrolled all the way down.

00:05:40.829 --> 00:05:45.079
So setting content inset on the top will give them
some extra padding that they can scroll down in

00:05:45.079 --> 00:05:48.300
to allow the content to flow below
these other user interface elements.

00:05:48.300 --> 00:05:52.430
But allow them to scroll it up so it's still
visible behind the transparent elements.

00:05:52.430 --> 00:05:54.310
And we can do the same thing on the bottom with the toolbar.

00:05:54.310 --> 00:05:58.790
And just set content inset on the bottom, which gives
some more area on the bottom that can be scrolled up.

00:05:58.790 --> 00:06:04.200
Now this can also be useful in cases like when you get a
notification that the keyboard has become visible on screen.

00:06:04.199 --> 00:06:08.329
It's a common first choice to think that
you need to actually resize your ScrollView

00:06:08.329 --> 00:06:11.069
in order to push it up above the keyboard.

00:06:11.069 --> 00:06:15.730
But if you actually just set a content inset on the bottom,
you don't need to change the ScrollView's frame at all.

00:06:15.730 --> 00:06:17.960
It actually animates better and there's-- you tend

00:06:17.959 --> 00:06:20.889
to have less glitches during the
animation of the keyboard coming up.

00:06:20.889 --> 00:06:22.849
And it's easier to synchronize with the keyboard.

00:06:22.850 --> 00:06:27.990
So you can just animatedly set a content inset on the bottom
and that'll get some extra space for the content to scroll

00:06:27.990 --> 00:06:30.019
up above the keyboard so it stays visible.

00:06:30.019 --> 00:06:38.750
If you use UITableView Controller, it actually does this
for you if the subview of a TableView is a text field.

00:06:38.750 --> 00:06:41.850
So now we've got our content and
it's fully visible, it's scrolled,

00:06:41.850 --> 00:06:45.300
can scroll underneath and above our User Interface elements.

00:06:45.300 --> 00:06:47.100
But there's one other piece that's left.

00:06:47.100 --> 00:06:51.860
So there are no-- there are no scroll
controls visible in a UIScrollView.

00:06:51.860 --> 00:06:54.220
The entire ScrollView itself is the-- is the control.

00:06:54.220 --> 00:06:56.150
These are just-- moves their finger in it.

00:06:56.149 --> 00:07:00.529
But when the user is scrolling, there are scroll
indicators on the right side and the bottom.

00:07:00.529 --> 00:07:05.729
And right now as things stand, even though we've set
our content inset to allow the content to be below it,

00:07:05.730 --> 00:07:13.660
the scroll indicators, they still take up at most the
entire ScrollView frame, vertically and horizontally.

00:07:13.660 --> 00:07:18.070
So we really want that to get pushed down to
never be underneath these controls either.

00:07:18.069 --> 00:07:20.969
And that's what the scroll indicator insets property is for.

00:07:20.970 --> 00:07:27.580
So that just defines the starting point in your
ScrollView's frame that the scroll indicator will go at.

00:07:27.579 --> 00:07:30.240
So it'll never go above that point.

00:07:30.240 --> 00:07:35.230
So we'll set the scroll indicator inset on the top there
and that'll push the maximum scroll indicator down.

00:07:35.230 --> 00:07:41.810
So even when the content is fully scrolled down, the scroll
indicator will be below our UI at the top of the screen.

00:07:41.810 --> 00:07:45.300
So now we've got our content and
we-- the user can scroll it.

00:07:45.300 --> 00:07:50.050
They've scrolled it up above part of our iPhone so it's
sticking out the top there, that really does happen.

00:07:50.050 --> 00:07:57.300
But at some point in your application you may want to know
programmatically where the user is at in their content.

00:07:57.300 --> 00:08:00.379
And that's what the content offset property does for you.

00:08:00.379 --> 00:08:07.170
Now the content offset is the point in your content that's
currently visible at the top left of the ScrollView's frame.

00:08:07.170 --> 00:08:11.580
This can be a little confusing at first and it's not
entirely obvious, but that's basically what it is.

00:08:11.579 --> 00:08:14.949
If you saw Dan's session yesterday
on iPhone Views and Animations,

00:08:14.949 --> 00:08:18.870
he talked about the difference
between bounds and frame on a view.

00:08:18.870 --> 00:08:24.600
This is just kind of a quick aside, but content offset is
actually just the bounds origin of the ScrollView's frame.

00:08:24.600 --> 00:08:30.760
If you didn't, he always-- Dan kind of mentioned that the
bounds origin is always 00, and generally that's true.

00:08:30.759 --> 00:08:36.059
But bounds is just actually a view into some part of
that-- sorry, a window into some part of the view.

00:08:36.059 --> 00:08:41.049
So in order to scroll, ScrollView just changes the
bounds origin, which is also the content offset.

00:08:41.049 --> 00:08:45.979
So anyway, in this case here, we've only got
vertically scrolling content, nothing horizontal.

00:08:45.980 --> 00:08:48.490
So we only have a Y component of our content offset.

00:08:48.490 --> 00:08:54.990
And as you can see there, that is the point in the
content visible at the top left of the ScrollView's frame.

00:08:54.990 --> 00:08:58.169
So let's put all this together and
look at it in a bigger example here.

00:08:58.169 --> 00:09:02.219
We've got some content, it's a big-- just
a big image and we've got content inset set

00:09:02.220 --> 00:09:04.830
to give us some extra borders around the edge.

00:09:04.830 --> 00:09:07.560
Now if we overlay our ScrollView
frame on top of that just by graying

00:09:07.559 --> 00:09:10.849
out the part that's not visible now,
we can take a look at content offset.

00:09:10.850 --> 00:09:16.320
And as I just said, that's the point in the content
currently visible at the top left of the ScrollView's frame.

00:09:16.320 --> 00:09:23.420
Now if we scroll that content so that it's actually inset
as far as it can possibly scroll to the left and the top,

00:09:23.419 --> 00:09:26.839
we've now got our content insets
visible in the frame as well.

00:09:26.840 --> 00:09:32.680
So at this point there is no point in, in the content
itself visible at the top left of the ScrollView frame.

00:09:32.679 --> 00:09:37.549
So an important detail here is that at that, at
that time the content offset is actually negative.

00:09:37.549 --> 00:09:39.579
So you should be prepared to expect that at some points

00:09:39.580 --> 00:09:43.000
if you're using content inset, a
negative content offset may be valid.

00:09:43.000 --> 00:09:46.049
And in this case, we're scrolled
all the way as far as we can

00:09:46.049 --> 00:09:52.069
so the content offset is just the negative
content inset left and negative content inset top.

00:09:52.070 --> 00:09:56.980
All right, so now we've got our scrolling set up, users
can scroll around in our content and pan and that's great.

00:09:56.980 --> 00:10:00.210
But ScrollView also provides support
for zooming in on that content.

00:10:00.210 --> 00:10:03.450
And with all this already done, there's
actually only two things that you need to do

00:10:03.450 --> 00:10:05.700
to add support for zooming in your ScrollView.

00:10:05.700 --> 00:10:10.140
So there's two properties and you'll
need to change at least one of them.

00:10:10.139 --> 00:10:13.090
And one delegate method that you'll have to implement.

00:10:13.090 --> 00:10:15.750
So the properties are minimum and maximum zoom scale.

00:10:15.750 --> 00:10:21.470
Now, by default both of these are 1, so that defines
the range over which the user can zoom your content.

00:10:21.470 --> 00:10:22.779
So by default there is no range.

00:10:22.779 --> 00:10:26.459
They're always at the 1.0 zoom scale.

00:10:26.460 --> 00:10:31.610
So in order to enable zooming, you have to at least set
the minimum to less than 1 or the maximum to greater than 1

00:10:31.610 --> 00:10:35.680
or some other combination that defines some
sort of range over which the user can zoom.

00:10:35.679 --> 00:10:38.009
And then once that's set, there's one last thing.

00:10:38.009 --> 00:10:41.919
You have to implement the view for
zooming and ScrollView delegate method.

00:10:41.919 --> 00:10:45.009
And this-- with this method you'll just
return some subview of your ScrollView

00:10:45.009 --> 00:10:48.230
that you'd like to be zoomed when the user pinches.

00:10:48.230 --> 00:10:52.860
Now when the ScrollView zooms this view,
it just sets a transform on that view.

00:10:52.860 --> 00:10:56.600
So the view has a transform property and
ScrollView sets the transform on there

00:10:56.600 --> 00:10:59.480
to transform appropriate for the current zoom scale.

00:10:59.480 --> 00:11:04.700
Additionally it also changes the content size property
on the ScrollView itself to compensate for the fact

00:11:04.700 --> 00:11:07.800
that the content size having been
zoomed is now either larger or smaller.

00:11:07.799 --> 00:11:14.529
So over the course of the last year, we've also
been hearing that you guys would like to be able

00:11:14.529 --> 00:11:17.159
to programmatically set and get the zoom scale.

00:11:17.159 --> 00:11:27.600
And so in iPhone OS 3.0, we've added one new property
and two new methods to programmatically get and set this.

00:11:27.600 --> 00:11:27.970
[ Applause ]

00:11:27.970 --> 00:11:28.340
[ Laughter ]

00:11:28.340 --> 00:11:28.990
Thank you.

00:11:28.990 --> 00:11:34.500
So the, the property is just the zoom scale property and
it's a floating point value that is the current zoom scale

00:11:34.500 --> 00:11:37.389
within the minimum and maximum range that you've defined.

00:11:37.389 --> 00:11:39.299
And you can both set and get that property.

00:11:39.299 --> 00:11:43.189
If you want to add animation, then there's actually
these two new methods that we're going to talk about.

00:11:43.190 --> 00:11:45.190
The first is set zoomScaleAnimated.

00:11:45.190 --> 00:11:49.960
And this just takes a floating-point value and
a Boolean animated property and it will zoom in

00:11:49.960 --> 00:11:54.110
and out on the center point of what's currently
visible within a ScrollView's frame right now.

00:11:54.110 --> 00:11:56.419
So as you can see here, as we set the zoomScaleAnimated,

00:11:56.419 --> 00:11:59.879
we're just zooming around the center
of what we can currently see.

00:11:59.879 --> 00:12:03.919
But you might want some more control over
what becomes visible as a result of this zoom.

00:12:03.919 --> 00:12:09.139
And for that we've added a second
method, which is the zoomToRectAnimated.

00:12:09.139 --> 00:12:13.000
So with this you can specify some rectangle
in your content that will be zoomed

00:12:13.000 --> 00:12:15.940
to best fit within the ScrollView's frame.

00:12:15.940 --> 00:12:20.800
So if you specify this rectangle around the dragon's
mouth here, and then call zoomToRectAnimated,

00:12:20.799 --> 00:12:24.179
we're going to zoom that up to fit as
best we can within the ScrollView's frame,

00:12:24.179 --> 00:12:26.609
taking into account the minimum and maximum zoom scale.

00:12:26.610 --> 00:12:32.980
So we won't let you scroll outside or zoom rather outside of
the bounds that you've told us that you want zooming within.

00:12:32.980 --> 00:12:36.980
Similarly if you've got larger content here
and you specify a rectangle that's bigger,

00:12:36.980 --> 00:12:42.310
we'll zoom down in order to fit that in as best we can.

00:12:42.309 --> 00:12:45.259
So there's one last thing I want to
talk about that's not really related

00:12:45.259 --> 00:12:47.539
to this before I ask Eliza to come up to do a demo.

00:12:47.539 --> 00:12:50.719
But it's also new in 3.0 so we're
going to mention it real quick,

00:12:50.720 --> 00:12:54.480
and that is the new deceleration
rate property on UIScrollView.

00:12:54.480 --> 00:13:00.930
So this controls how quickly the content comes to rest
after your user flicks the scroll within the ScrollView.

00:13:00.929 --> 00:13:03.629
So by default we've got the UIScrollView
deceleration rate normal.

00:13:03.629 --> 00:13:07.019
And this is the same as the behavior in iPhone OS 2.0.

00:13:07.019 --> 00:13:10.899
So on the left you can see the user
scrolls and it actually takes a while

00:13:10.899 --> 00:13:12.990
for that content to slow down and come to rest.

00:13:12.990 --> 00:13:18.330
So on iPhone OS 3.0 now you can also
specify UIScrollView deceleration rate fast.

00:13:18.330 --> 00:13:21.610
And that will cause the ScrollView
to come to rest much more quickly.

00:13:21.610 --> 00:13:28.050
So as you can see here, the user flicks to scroll and
the, the content comes to rest almost immediately.

00:13:28.049 --> 00:13:30.919
So with that, I'd like to ask Eliza
to come up and give us a demo of some

00:13:30.919 --> 00:13:36.429
of the programmatic zooming features in iPhone OS 3.0.

00:13:36.429 --> 00:13:40.089
[ Applause ]

00:13:40.090 --> 00:13:40.889
>> Thanks.

00:13:40.889 --> 00:13:45.590
Hi I'm Eliza and I'm an engineer
on the iPhone Applications team.

00:13:45.590 --> 00:13:51.080
I'm going to show you how to use some of the new zooming
API that we've just added to UIScrollView in OS 3.0.

00:13:51.080 --> 00:13:55.330
So what you see here is a really simple application.

00:13:55.330 --> 00:13:59.420
It has a single view controller,
which is managing a UIScrollView.

00:13:59.419 --> 00:14:01.909
And you can't do much with this yet.

00:14:01.909 --> 00:14:04.199
I'll show you what you can do.

00:14:04.200 --> 00:14:06.830
We can scroll around in the content.

00:14:06.830 --> 00:14:10.970
And we can pinch to zoom in and out.

00:14:10.970 --> 00:14:16.980
So what I'd like to do in this demo is
add two features to this application.

00:14:16.980 --> 00:14:21.170
First we're going to arrange it so
that when the application launches,

00:14:21.169 --> 00:14:25.349
we zoom all the way out on the image
so that the entire content is visible.

00:14:25.350 --> 00:14:32.980
Second we're going to add sensitivity to taps for zooming
in and out on the content much like in the Maps application.

00:14:32.980 --> 00:14:39.460
So let me show you the code.

00:14:39.460 --> 00:14:39.660
[ Period of silence ]

00:14:39.659 --> 00:14:44.789
Almost all of the work here is being done in the
load view method of our root view controller.

00:14:44.789 --> 00:14:51.299
So we create our ScrollView, we give it
some content in the form of a UIImageView.

00:14:51.299 --> 00:14:54.609
We set the content size property as Josh mentioned.

00:14:54.610 --> 00:15:01.620
And then I'm setting some properties here that allow us to
do the scrolling by pinch-- the zooming rather, by pinching.

00:15:01.620 --> 00:15:04.649
In particular the minimum zoom scale property.

00:15:04.649 --> 00:15:11.090
And finally we have implemented the one delegate
method that's required to allow the pinching to zoom

00:15:11.090 --> 00:15:16.129
and in that method we return the image view that we created.

00:15:16.129 --> 00:15:22.980
So if we want to change this so that when
it launches, you see the entire image,

00:15:22.980 --> 00:15:25.570
we actually only need to add a single line of code.

00:15:25.570 --> 00:15:30.140
We're going to use the new zoom scale property
that's-- that we've added to UIScrollView.

00:15:30.139 --> 00:15:35.699
And here I've calculated a minimum scale so
that the image will fit perfectly width wise

00:15:35.700 --> 00:15:37.400
in the frame of the ScrollView.

00:15:37.399 --> 00:15:45.500
So I'm just going to set the zoom scale to
be that size and I'm going to build it again.

00:15:45.500 --> 00:15:47.100
And let's see what happens.

00:15:47.100 --> 00:15:50.370
So now when it launches the entire image is visible.

00:15:50.370 --> 00:15:53.970
OK, so next let's add sensitivity to taps.

00:15:53.970 --> 00:15:58.830
So the Maps application, when you
double-tap, you zoom in by one step.

00:15:58.830 --> 00:16:02.310
And when you use a two-fingered tap, you zoom out.

00:16:02.309 --> 00:16:08.529
So we need to have a way to detect the taps and
UIImageView doesn't actually know how to detect taps.

00:16:08.529 --> 00:16:14.949
So what I've done is, I've added a subclass of
UIImageView called a tap detecting image view,

00:16:14.950 --> 00:16:17.690
which has built into it the ability to listen for taps.

00:16:17.690 --> 00:16:22.440
So I'm going to replace our image
view by a tap detecting image view.

00:16:22.440 --> 00:16:27.810
And then the tap detecting image view sends a
message to its delegate when it detects a tap.

00:16:27.809 --> 00:16:33.099
So we'll set our root view controller to be
the delegate of the tap detecting image view.

00:16:33.100 --> 00:16:33.560
[ Period of silence ]

00:16:33.559 --> 00:16:34.759
All right.

00:16:36.870 --> 00:16:44.669
Last thing we need to do is implement the delegate methods
that are going to actually cause the zooming to take place.

00:16:44.669 --> 00:16:48.309
So right here I'll make a section for our delegate methods.

00:16:48.309 --> 00:16:54.849
The first one we're going to implement is
the-- gets called when a double-tap occurs.

00:16:54.850 --> 00:17:00.360
And in response to a double-tap,
we're going to zoom in on the content.

00:17:00.360 --> 00:17:05.829
We'll also implement the, the method that
will be called when a two-fingered tap occurs.

00:17:05.829 --> 00:17:09.109
And in response to that we'll zoom out.

00:17:09.109 --> 00:17:14.000
All right, how do we figure out what
new scale we're going to zoom to?

00:17:14.000 --> 00:17:19.359
We'll need to-- we're going to calculate the scale we
want and again we're going to use the zoom scale property

00:17:19.359 --> 00:17:23.000
in order to get the current scale
that we're zoomed to at the moment.

00:17:23.000 --> 00:17:28.319
So and then we'll multiply that by some constant, say 1.5.

00:17:28.319 --> 00:17:33.609
We'll do the same thing in the case of the
zooming out, but here we'll divide by 1.5.

00:17:33.609 --> 00:17:40.309
And all that remains is to tell the ScrollView
to change its scale to that new value.

00:17:40.309 --> 00:17:47.210
So the simplest way to do this is to use the set
zoomScaleAnimated method rather that Josh just mentioned.

00:17:47.210 --> 00:17:48.920
So let's do that.

00:17:48.920 --> 00:17:53.190
We'll set the zoom scale to our new
scale and we'll animate the transition.

00:17:53.190 --> 00:17:56.970
And now I'm going to build this again and see how it works.

00:17:56.970 --> 00:18:01.529
[ Period of silence ]

00:18:01.529 --> 00:18:07.160
OK. So I'm going to tap on the image and as
you can see as I double-tap, we get zooming

00:18:07.160 --> 00:18:11.290
and as I two fingered tap, we get zooming back out.

00:18:11.289 --> 00:18:16.980
There's still something a little wrong with this,
which is that we're ignoring the location of my tap.

00:18:16.980 --> 00:18:20.839
So I'm tapping all over the image but we
always zoom in around the center point,

00:18:20.839 --> 00:18:26.289
and that's because we're using the set zoomScaleAnimated
method and that method zooms in in such a way

00:18:26.289 --> 00:18:29.109
as to preserve the center point in the visible region.

00:18:29.109 --> 00:18:36.709
If we want to make it so that it zooms around the point
where the user tapped, we're going to need to use a method

00:18:36.710 --> 00:18:41.630
that gives us more control over what region of
the image becomes visible as the zooming occurs.

00:18:41.630 --> 00:18:46.510
So the zoomToRectAnimated method is the best way to do that.

00:18:46.509 --> 00:18:51.400
So let's change this code to use the
zoomToRectAnimated method instead.

00:18:51.400 --> 00:18:56.030
First we're going to need to calculate
the rectangle that we want.

00:18:56.029 --> 00:19:04.750
And so we're going to want to figure out a rectangle
in our image that perfectly centers the top point

00:19:04.750 --> 00:19:09.779
which has been passed to us by our, by our image view.

00:19:09.779 --> 00:19:13.619
I've written a utility method to do
this, which I'm going to show you here.

00:19:13.619 --> 00:19:19.209
It just calculates the zoom rect in the image for
a particular scale with a particular center point.

00:19:19.210 --> 00:19:23.299
One thing to note about this, don't worry about
understanding exactly how it works right now.

00:19:23.299 --> 00:19:29.980
But one thing to notice about it is that if we
want the maximum control over exactly what region

00:19:29.980 --> 00:19:34.079
of the image becomes visible after the
zooming, you want to choose a rectangle

00:19:34.079 --> 00:19:38.179
that is the same aspect ratio as the ScrollView itself.

00:19:38.180 --> 00:19:43.610
If you choose a rectangle that's a different shape, we'll
make it so that whole rectangle is visible in the view,

00:19:43.609 --> 00:19:47.949
but we might put it at the top or the bottom or the
middle, depending on where you're currently scrolled to.

00:19:47.950 --> 00:19:52.380
So what I've done is calculated a rectangle
that's the same shape as the ScrollView

00:19:52.380 --> 00:19:54.620
and that has that center point that we want.

00:19:54.619 --> 00:19:57.899
So we'll call that method here.

00:19:57.900 --> 00:20:05.250
And then we'll ask the ScrollView to zoom to
that rectangle and to animate the transition.

00:20:05.250 --> 00:20:12.819
We'll do the same thing in the zooming out case.

00:20:12.819 --> 00:20:13.029
[ Period of silence ]

00:20:13.029 --> 00:20:15.180
And let's go ahead and build.

00:20:15.180 --> 00:20:15.240
[ Period of silence ]

00:20:15.240 --> 00:20:22.920
All right, this time when I double-tap here, I'll
double-tap on her, I don't know if the mouse is visible.

00:20:22.920 --> 00:20:24.890
I'm double-tapping on her badge on her collar.

00:20:24.890 --> 00:20:27.100
Now I'm double-tapping on her nose.

00:20:27.099 --> 00:20:29.179
And then again on her badge.

00:20:29.180 --> 00:20:33.120
So as you can see, we're actually zooming
right around the point of the double-tap.

00:20:33.119 --> 00:20:33.849
Thanks.

00:20:33.849 --> 00:20:36.119
[ Applause ]

00:20:36.119 --> 00:20:37.069
>> Thanks Eliza.

00:20:37.069 --> 00:20:41.789
So now you've got your content in your ScrollView
and you've got your default interaction behaviors.

00:20:41.789 --> 00:20:45.250
Your users can zoom around, zoom in
on it, they can pan around on it.

00:20:45.250 --> 00:20:46.710
Everything's working great.

00:20:46.710 --> 00:20:50.430
Now you might want to add some custom
interactions with subviews of your ScrollView.

00:20:50.430 --> 00:20:56.590
So we'll talk about now how you can determine what view
gets to handle the touches that are in the ScrollView.

00:20:56.589 --> 00:20:59.129
So this has been an area that's had
some confusion over the last year.

00:20:59.130 --> 00:21:05.240
So hopefully we will clarify some of that with the two
properties and two methods that are provided on UIScrollView

00:21:05.240 --> 00:21:07.809
to give you some control over how this works.

00:21:07.809 --> 00:21:10.480
So the first property we'll talk
about is Delays Content Touches.

00:21:10.480 --> 00:21:14.670
Now the default value here is Yes, so everything
we're going to say is the default behavior

00:21:14.670 --> 00:21:17.480
that you get out of the box unless you change this.

00:21:17.480 --> 00:21:22.910
So normally when a finger comes down in a subview
of a ScrollView, touchesBegan is not delivered

00:21:22.910 --> 00:21:25.380
to that subview until after a brief delay.

00:21:25.380 --> 00:21:29.080
Now the idea here is that as a
result of receiving this touch,

00:21:29.079 --> 00:21:31.750
you're going to provide some visual
feedback that the touch has come down.

00:21:31.750 --> 00:21:35.059
We don't want to do that if the user is
immediately going to begin scrolling.

00:21:35.059 --> 00:21:39.569
And we don't really know when the finger first comes down
whether it's going to be an attempt to touch something

00:21:39.569 --> 00:21:41.609
in the ScrollView or an attempt to scroll.

00:21:41.609 --> 00:21:47.069
So by delaying this delivery, we give the user a chance
to start scrolling and not see a quick flash of content.

00:21:47.069 --> 00:21:48.549
So we see that here in TableView.

00:21:48.549 --> 00:21:52.430
There's a brief delay before the
table cell becomes selected.

00:21:52.430 --> 00:21:56.970
But if the user scrolls the table really
fast, there's no selection at all.

00:21:56.970 --> 00:22:02.600
But as you notice, once the user started moving
their finger in the table view, and scrolling began,

00:22:02.599 --> 00:22:05.549
even though the selection was already
visible, it immediately went away.

00:22:05.549 --> 00:22:10.529
Now the reason that happens is because the table view
sends touchesCanceled to the-- to its subview after the--

00:22:10.529 --> 00:22:16.440
after it detects that the user is trying to
scroll if it's already delivered the touchesBegan.

00:22:16.440 --> 00:22:21.150
So you can actually get control over this with the
second property, which is canCancelContentTouches.

00:22:21.150 --> 00:22:24.810
Now there's a quick video here that shows
what's happening in the default case.

00:22:24.809 --> 00:22:29.000
When the user-- when touchesBegan is delivered
to this image view, it's going to get larger.

00:22:29.000 --> 00:22:33.200
And then as the user moves their finger around, when
touchesCanceled gets delivered, it's going to get dropped

00:22:33.200 --> 00:22:34.660
and you'll see the ScrollView begin scrolling.

00:22:34.660 --> 00:22:40.460
Now if we want to change this behavior,
we can set canCancelContentTouches to No.

00:22:40.460 --> 00:22:43.990
And if that's the case, once the
ScrollView has begun delivering the touches

00:22:43.990 --> 00:22:47.059
to its subview, it will not try and cancel that touch.

00:22:47.059 --> 00:22:49.970
However, if the user begins moving
before the touch was actually delivered

00:22:49.970 --> 00:22:52.789
as touchesBegan, the ScrollView will begin scrolling.

00:22:52.789 --> 00:22:58.740
So we can see now if we've set this to No, we pick up
this image view and we can begin dragging it around.

00:22:58.740 --> 00:23:00.339
But the ScrollView won't start scrolling

00:23:00.339 --> 00:23:03.970
and Touches Canceled isn't delivered
until we lift the mouse then we drop it.

00:23:03.970 --> 00:23:07.250
However if the user moves quickly, we begin scrolling.

00:23:07.250 --> 00:23:12.039
So just these two properties actually give you quite a bit
of control over what's going to happen in the subviews.

00:23:12.039 --> 00:23:13.799
But you might want a little bit more control,

00:23:13.799 --> 00:23:17.289
especially depending on what subview
of your ScrollView was actually hit.

00:23:17.289 --> 00:23:21.480
So there's two methods that you can implement in
order to give slightly more control over this.

00:23:21.480 --> 00:23:25.019
Now these are actually methods on
UIScrollView itself, not on the delegate.

00:23:25.019 --> 00:23:27.940
So if you want to implement these,
you'll have to subclass UIScrollView

00:23:27.940 --> 00:23:31.269
and implement them in your ScrollView subclass directly.

00:23:31.269 --> 00:23:35.460
So the first method is
touchesShouldBeginWithEventInContentView.

00:23:35.460 --> 00:23:41.380
Now I already mentioned that ScrollView delays delivery
of touchesBegan to its subviews, but what I didn't say is

00:23:41.380 --> 00:23:47.150
that immediately before sending touchesBegan to a subview,
it first calls touchesShouldBeginWithEventInContentView

00:23:47.150 --> 00:23:50.600
on itself to give you a chance
to override this and return No.

00:23:50.599 --> 00:23:56.579
And if you do return No, then touchesBegan and the rest
of the touch sequence will not be delivered to the subview

00:23:56.579 --> 00:24:02.299
and instead it will be interpreted as an attempt to
scroll the subview-- scroll the ScrollView rather.

00:24:02.299 --> 00:24:08.419
Now on the other side is the second delegate-- or the
second method, which is touchesShouldCancelInContentView

00:24:08.420 --> 00:24:14.610
Now as I mentioned if canCancelContentTouches is Yes,
even if touchesBegan was already delivered to the subview,

00:24:14.609 --> 00:24:18.299
if the ScrollView notices that you've moved your
finger far enough, it's going to cancel the touch

00:24:18.299 --> 00:24:21.000
on that subview and instead begin scrolling.

00:24:21.000 --> 00:24:26.440
So you can, even if touchesShouldCancel--
sorry, even if canCancelContentTouches is Yes,

00:24:26.440 --> 00:24:32.420
before it sends touchesCancel to the subview, it will
first call touchesShouldCancelInContentView on itself

00:24:32.420 --> 00:24:38.550
and if you return no, it will not send touchesCanceled,
it'll continue delivering the entire touch stream

00:24:38.549 --> 00:24:42.399
to that subview and it will not begin scrolling.

00:24:42.400 --> 00:24:45.660
Now if canCancelContentTouches is No,
obviously this isn't going to get called

00:24:45.660 --> 00:24:49.370
because it won't try and cancel the touch anyway.

00:24:49.369 --> 00:24:52.619
So with those things in mind, I'd like to
invite Eliza back up to give us another demo

00:24:52.619 --> 00:24:56.439
of some custom interactions using this-- these new methods.

00:24:56.440 --> 00:25:01.630
>> Josh has explained how you can customize the
delivery of touches to subviews of your UIScrollView.

00:25:01.630 --> 00:25:08.060
I want to show you what that looks like in practice by
adding to my app a ScrollView where there are subviews

00:25:08.059 --> 00:25:10.549
that we might want to drag around to reorder.

00:25:10.549 --> 00:25:13.419
So here's the same app from the previous demo.

00:25:13.420 --> 00:25:19.009
But I've added to it a drawer that slides up and down.

00:25:19.009 --> 00:25:22.980
And is itself a ScrollView that scrolls to
the right and left that contains thumbnails

00:25:22.980 --> 00:25:26.029
of other images that you might want to view.

00:25:26.029 --> 00:25:31.129
So these images are already responsive to touches.

00:25:31.130 --> 00:25:37.120
So you can actually tap one to
switch which image you're looking at.

00:25:37.119 --> 00:25:41.729
If we want to make it so that you can drag
them around in the ScrollView to reorder them,

00:25:41.730 --> 00:25:49.360
we're going to have to have a way to convince the ScrollView
that touches that are moving in its bounds are intended

00:25:49.359 --> 00:25:54.459
for one of its subviews rather than as request to scroll.

00:25:54.460 --> 00:26:01.870
So by default the ScrollView is going to try to scroll as
soon as a touch moves in a direction that it can scroll.

00:26:01.869 --> 00:26:04.359
So here we have a right/left moving ScrollView.

00:26:04.359 --> 00:26:09.019
You can see that I can actually pick up one
of these images as long as I move it only up.

00:26:09.019 --> 00:26:11.210
I can drag it around.

00:26:11.210 --> 00:26:15.059
But the moment that I start moving it in a
direction that the ScrollView can scroll,

00:26:15.059 --> 00:26:19.269
my touch is canceled in the subview
and the ScrollView begins to scroll.

00:26:19.269 --> 00:26:22.549
So if I want to make it so that I
can drag them to the right and left,

00:26:22.549 --> 00:26:25.819
I'm going to need to change the
canCancelContentTouches property.

00:26:25.819 --> 00:26:30.269
So let me show you the code that's
creating this some ScrollView.

00:26:30.269 --> 00:26:34.990
So to make it so that I can drag them to
the right and left as well as up and down,

00:26:34.990 --> 00:26:40.049
I'm just going to add a single line
setting canCancelContentTouches to No.

00:26:40.049 --> 00:26:44.569
And when I now build this, we'll see what the result is.

00:26:44.569 --> 00:26:48.339
[ Period of silence ]

00:26:48.339 --> 00:26:54.819
This time I can grab one of my images and I can move it
back and forth and reorder the thumbnails in the drawer.

00:26:54.819 --> 00:26:58.089
So that's good.

00:26:58.089 --> 00:27:05.079
But there's still something a little sad about this which
is that I can reorder among the thumbnails that are visible,

00:27:05.079 --> 00:27:07.449
but if I want to actually drag this guy that I'm,

00:27:07.450 --> 00:27:13.370
that I'm dragging around past the visible
area, I'm pretty much out of luck.

00:27:13.369 --> 00:27:19.159
It'll be nice if the ScrollView would automatically
start scrolling as I got close to the edge to make room

00:27:19.160 --> 00:27:21.519
to drag the thumbnail that I'm dragging further over.

00:27:21.519 --> 00:27:27.299
If you've ever interacted with UITableVeiw and reordered
rows, you'll notice that after you start reordering rows,

00:27:27.299 --> 00:27:31.599
if you get the row close to the top or the bottom
of the table, it will automatically start scrolling

00:27:31.599 --> 00:27:34.679
so that you can reach the area above what you were seeing.

00:27:34.680 --> 00:27:39.120
So I'm going to show you now, how you can
add auto scrolling to your application.

00:27:39.119 --> 00:27:41.379
And it's actually a lot easier than you might expect.

00:27:41.380 --> 00:27:45.760
We don't need to subclass UIScrollView we're just
going to add control for auto scrolling directly

00:27:45.759 --> 00:27:50.299
to our Root View Controller so back to the code here.

00:27:50.299 --> 00:27:54.809
I'm going to implement this method maybeAutoScrollForThumb.

00:27:54.809 --> 00:28:00.740
And what this is going to do, is it's going to check whether
a particular thumbnail that's being dragged has been dragged

00:28:00.740 --> 00:28:05.680
close enough to an edge to be a signal
that we should start auto scrolling.

00:28:05.680 --> 00:28:11.769
And I'm going to call this application
every time that the dragToThumbnail moves.

00:28:11.769 --> 00:28:18.240
So up here we have the delegate that these thumb
image views-- that these thumbnail views are sending.

00:28:18.240 --> 00:28:21.279
When the thumb image view moves, we're going

00:28:21.279 --> 00:28:26.379
to say check whether we should start auto
scrolling or maybe whether we should stop.

00:28:26.380 --> 00:28:28.840
All right, so let's see what happens here.

00:28:28.839 --> 00:28:37.419
To find out if we should auto scroll we need to, we need
to check whether we're close to the edge and we also need

00:28:37.420 --> 00:28:41.800
to keep track of which direction we would be
auto scrolling if we're going to right, we--

00:28:41.799 --> 00:28:45.019
if you get close to the left edge we'll
auto scroll in the negative direction,

00:28:45.019 --> 00:28:49.359
and if we get close to the right edge we'll
auto scroll in the positive direction.

00:28:49.359 --> 00:28:53.209
So that's the first thing that we're
going to need to do in this method.

00:28:53.210 --> 00:28:56.730
Now if we are close enough to an
edge to start auto scrolling,

00:28:56.730 --> 00:29:02.910
we're going to accomplish the auto scrolling itself
by setting up a timer that's going to fire repeatedly.

00:29:02.910 --> 00:29:06.370
Every time it fires we'll move the
ScrollView by a very small amount.

00:29:06.369 --> 00:29:10.899
So that's going to be our second step, if
in fact we do want to be auto scrolling.

00:29:10.900 --> 00:29:14.610
So to do this we're going to need 2 new instance variables.

00:29:14.609 --> 00:29:17.409
So I'm going to switch to the header
file here for just a moment.

00:29:17.410 --> 00:29:22.900
And I'm going to add instance variables to keep track of the
auto scroll direction that we want and the auto scroll timer

00:29:22.900 --> 00:29:25.940
that we're using to cause the auto scrolling to happen.

00:29:25.940 --> 00:29:29.559
All right, back to the implementation file.

00:29:29.559 --> 00:29:36.659
So it's pretty easy to check if you're close, if your
thumbnail is close to the right edge or the left edge.

00:29:36.660 --> 00:29:41.170
I've written some utility methods to do it so
that this code will look simpler right now.

00:29:41.170 --> 00:29:45.150
So if it's near the right edge we're going
to auto scroll in the positive direction.

00:29:45.150 --> 00:29:50.870
If it's near the left edge we're going
to auto scroll in the negative direction.

00:29:50.869 --> 00:29:54.659
And if it's not near either edge,
then we won't auto scroll at all.

00:29:54.660 --> 00:29:58.580
And we'll set the direction to 0 to signal that.

00:29:58.579 --> 00:30:02.339
All right, so now supposed we in
fact are near one of the edges.

00:30:02.339 --> 00:30:05.240
So we need to actually start the auto scrolling.

00:30:05.240 --> 00:30:10.890
In that case we're going to create a
timer if we don't already have one.

00:30:10.890 --> 00:30:13.730
And I'm going to show you what that looks like.

00:30:13.730 --> 00:30:18.390
So this timer will fire repeatedly.

00:30:18.390 --> 00:30:19.680
Every time it fires it's going

00:30:19.680 --> 00:30:24.279
to call this autoScrollTimerFire method,
which I'll write in just a second.

00:30:24.279 --> 00:30:27.279
And we need to give it a time interval.

00:30:27.279 --> 00:30:30.240
So we want the scrolling to appear as smooth as possible.

00:30:30.240 --> 00:30:33.680
So I'm going choose as my time
interval the refresh rate of the screen

00:30:33.680 --> 00:30:38.340
so that every time the screen refreshes the
ScrollView will scroll by another few pixels.

00:30:38.339 --> 00:30:42.609
So 1/60th of a second is the maximum frame rate we can get.

00:30:42.609 --> 00:30:47.779
All right, let's write this autoScrollTimerFire method now.

00:30:49.700 --> 00:30:55.309
The first thing to do when the timer fires
is figure out how far you want to scroll.

00:30:55.309 --> 00:30:57.679
Now, there's a bunch of ways you can do this.

00:30:57.680 --> 00:31:01.019
For the purpose of this demo I'm keeping
it really simple and I'm just going

00:31:01.019 --> 00:31:04.139
to scroll a constant 6 pixels in the appropriate directions.

00:31:04.140 --> 00:31:09.370
So now in your own code you might actually
want to be a little bit more clever about this.

00:31:09.369 --> 00:31:13.449
You could make it that the close the thumb
is to the edge the faster you scroll.

00:31:13.450 --> 00:31:18.590
Or you could even set up something that it actually
accelerates as it's been scrolling for longer.

00:31:18.589 --> 00:31:23.159
So I'll leave that to-- actually in the
sample code I do the first of those 2 things.

00:31:23.160 --> 00:31:25.470
I make it so that it scrolls faster
as you get closer to the edge.

00:31:25.470 --> 00:31:29.660
So you can check that out if you're interested.

00:31:29.660 --> 00:31:34.440
Now, so, we're going to scroll by that distance.

00:31:34.440 --> 00:31:40.259
So actually to accomplish the scrolling all we need to do
is to change the content offset property of our ScrollView.

00:31:40.259 --> 00:31:42.769
We need to change its X value by that distance.

00:31:42.769 --> 00:31:52.000
So I'm going to set, I'm going to grab the content offset,
adjust it by the amount we've computed and then reset it.

00:31:52.000 --> 00:31:53.789
We're almost done.

00:31:53.789 --> 00:31:58.609
The one thing which we haven't yet done is arrange
it so that the auto scrolling will ever stop.

00:31:58.609 --> 00:31:59.419
So we started it.

00:31:59.420 --> 00:32:04.470
But as it stands, if I were to build this right
now once it starts it would keep going forever.

00:32:04.470 --> 00:32:09.220
So to make it stop what we want to do
is to have it stop in 2 conditions.

00:32:09.220 --> 00:32:13.490
So in the first case we want it to stop if the
user has dragged the thumbnail close to the edge

00:32:13.490 --> 00:32:18.470
and then drags it back away towards the
middle we want to stop the scrolling.

00:32:18.470 --> 00:32:23.529
We also want to stop if it the user lifts their finger from
the screen and drops the thumbnail that we're dragging.

00:32:23.529 --> 00:32:25.170
So let me show you where that is.

00:32:25.170 --> 00:32:30.250
The first of those cases we can handle
in this maybeAutoScrollForThumb method.

00:32:30.250 --> 00:32:34.180
So we've told, we've decided what
happens if we should be auto scrolling.

00:32:34.180 --> 00:32:39.590
If, in fact, we've decided that we shouldn't
be, then we'll stop the timer from firing

00:32:39.589 --> 00:32:42.549
by invalidating it, and we'll nail it out as well.

00:32:42.549 --> 00:32:48.990
To handle the case where the user lifts their finger,
we're going to need to listen for a delegate method

00:32:48.990 --> 00:32:53.650
that the thumbImageView is going to send
telling us that it's stopped tracking.

00:32:53.650 --> 00:32:55.080
So I haven't implemented that one yet.

00:32:55.079 --> 00:32:56.740
I'll do that right now.

00:32:56.740 --> 00:32:59.170
When the thumb image stops tracking we'll do the same thing.

00:32:59.170 --> 00:33:01.910
We'll invalidate the timer and nail it out.

00:33:01.910 --> 00:33:06.620
All right, I'm going to go ahead and
build this and we'll see how it works.

00:33:06.619 --> 00:33:13.179
All right, bring up my thumbnail and I'll
grab one of these images and pull it over.

00:33:13.180 --> 00:33:18.970
So we're scrolling but the image
is skittering all over the place.

00:33:18.970 --> 00:33:22.670
Not good, also it's letting us scroll
way past the bounds what was visible.

00:33:22.670 --> 00:33:25.470
All right, we definitely don't want that.

00:33:25.470 --> 00:33:26.700
What's going wrong?

00:33:26.700 --> 00:33:28.980
Let me address the second problem first.

00:33:28.980 --> 00:33:37.170
So here where our auto scroll timer fires, let me get
to that point in the code, we calculated a distance

00:33:37.170 --> 00:33:39.920
that we want to scroll and we changed the content offset.

00:33:39.920 --> 00:33:45.450
We didn't put any check whatsoever to make sure
that the new content offset was a legal one.

00:33:45.450 --> 00:33:49.980
We just blindly fed it to 6 pixels
further over than it had been before.

00:33:49.980 --> 00:33:56.349
Now, when the user scrolls with their finger, you'll notice
that the content will come to a halt at the end when it gets

00:33:56.349 --> 00:34:01.899
to the edge of what's visible-- or of what
it-- of what the size of the image is, right.

00:34:01.900 --> 00:34:05.110
It will stop scrolling and it might even
rubber band if you have that setting on.

00:34:05.109 --> 00:34:09.039
When you change the content offset programmatically
though there's no such check in place,

00:34:09.039 --> 00:34:11.550
so we're going to have to add one ourselves.

00:34:11.550 --> 00:34:16.500
We're going to have to check that this auto scroll distance
is a legal value before we change the content offset

00:34:16.500 --> 00:34:17.210
by that amount.

00:34:17.210 --> 00:34:23.240
So I've made another utility method that just adjusts the
auto scroll distance to make sure that it's not too large

00:34:23.239 --> 00:34:26.119
or too small before we change the content offset.

00:34:26.119 --> 00:34:30.940
All right, so that should fix the scrolling
past the bounds of what's visible problem.

00:34:30.940 --> 00:34:34.750
To fix the thumb image skittering all over
as the auto scrolling occurs we would need

00:34:34.750 --> 00:34:36.889
to first understand why that's happening.

00:34:36.889 --> 00:34:42.750
The problem is that the thumb image that
we're dragging is a subview of our ScrollView.

00:34:42.750 --> 00:34:48.250
So like all the other subviews it gets scrolled
off the screen as the content offset changes.

00:34:48.250 --> 00:34:52.440
Now that explains why it zooms off the
screen as the auto scrolling happens.

00:34:52.440 --> 00:34:58.599
The reason it skitters back periodically, as you might have
seen, is that we're also trying to drag that thumbnail.

00:34:58.599 --> 00:35:03.539
So every time I move the mouse slightly or rather move my
finger slightly it would jump back to where the mouse was.

00:35:03.539 --> 00:35:08.110
And that had to have caused the
appearance of skittering back and forth.

00:35:08.110 --> 00:35:13.059
So to fix that what we're actually going
to do is adjust the frame of the thumbnail

00:35:13.059 --> 00:35:15.739
that we're dragging to compensate for the scrolling.

00:35:15.739 --> 00:35:20.719
So every time the timer fires we
change the content offset by 6 pixels.

00:35:20.719 --> 00:35:27.349
We'll also have the thumbnail move by 6 pixels in
the same direction so that it appears to stand still.

00:35:27.349 --> 00:35:32.699
All right, to do that we just need a couple
new things; first we need to have access

00:35:32.699 --> 00:35:35.189
to the thumbnail that we're dragging in this method.

00:35:35.190 --> 00:35:40.789
So the easiest way to do that is just to add it
to the user info of the timer that I created.

00:35:40.789 --> 00:35:43.380
So I'm going to pass the thumbnail along.

00:35:43.380 --> 00:35:50.829
And that way when the timer fires I can pull that
thumbnail out of the user info and then I can tell it

00:35:50.829 --> 00:35:56.779
to change its content off, its own location
by a particular offset which is equal

00:35:56.780 --> 00:35:59.890
to the change we're making to the
content offset of the ScrollView.

00:35:59.889 --> 00:36:03.409
So these thumbs know how to move
themselves by a particular offset.

00:36:03.409 --> 00:36:10.489
So I've chosen to change its X coordinate by the
same amount and leave its Y coordinate alone.

00:36:10.489 --> 00:36:15.159
So build that and see if it fixed the problem.

00:36:15.159 --> 00:36:22.420
Bring up the View, grab one of these thumbnails,
start scrolling, and this time it stays nice

00:36:22.420 --> 00:36:28.530
and still as we scroll and as we get to
the end of the visible content we stop.

00:36:28.530 --> 00:36:29.980
All fixed thanks.

00:36:29.980 --> 00:36:35.440
[ Applause ]

00:36:35.440 --> 00:36:41.019
>> Well first let's talk about now that you've got
your content in your ScrollView your users are panning

00:36:41.019 --> 00:36:45.170
around they're zooming in on it, you've got some
custom interactions for some of your subviews.

00:36:45.170 --> 00:36:49.289
Now that you've been testing it, it works great on
the iPhone simulator, you copy it down to the device

00:36:49.289 --> 00:36:52.230
and immediately it crashes because you've run out of memory.

00:36:52.230 --> 00:36:56.119
So how are we going to adjust, deal with that problem?

00:36:56.119 --> 00:36:57.949
Well, there's a few approaches that you could take.

00:36:57.949 --> 00:37:02.369
But what we're going to talk to you about today is
tiling your content, breaking it into smaller pieces

00:37:02.369 --> 00:37:05.569
and just displaying and loading
the parts that you actually need

00:37:05.570 --> 00:37:08.930
to show the user what's visible in
the ScrollView screen right now.

00:37:08.929 --> 00:37:13.429
So as we said, you might want to do this if you have
more content than you can actually fit in memory.

00:37:13.429 --> 00:37:16.179
You might also want to do it just to improve load times.

00:37:16.179 --> 00:37:21.049
If you've got even large images that will already fit
in memory, it takes a while to load them off the flash.

00:37:21.050 --> 00:37:25.560
You may be able to reduce that time by tiling it
or breaking it, breaking it into smaller pieces.

00:37:25.559 --> 00:37:28.969
You might also want to do this if you
have to download content as needed.

00:37:28.969 --> 00:37:33.569
For instance the Google Maps application-- there's
no way we could fit all of the map data on the phone.

00:37:33.570 --> 00:37:37.010
So we pull pieces down and just
tile it and just load only the parts

00:37:37.010 --> 00:37:39.110
that are needed to display what the user is seeing.

00:37:39.110 --> 00:37:46.630
So there's actually an example of this on the iPhone
already in the form of UIScrollView, UITableView.

00:37:46.630 --> 00:37:50.660
And for those of you that have used this, I'm
sure you're already familiar with cell reuse.

00:37:50.659 --> 00:37:55.649
So once a cell scrolls off the top of the
visible area of the TableView it gets pulled out

00:37:55.650 --> 00:38:00.369
and put into the reuse queue and then when the
TableView asks you for a new cell you can pull it

00:38:00.369 --> 00:38:04.109
out of the reuse queue, fill out new content
and it will scroll it back on the other side.

00:38:04.110 --> 00:38:10.430
So you can see that here, the ScrollView scrolls and we
reuse those cells as they're scrolled off and they come back

00:38:10.429 --> 00:38:15.609
in on the other side, which is a lot less
expensive than allocating new cells every time.

00:38:15.610 --> 00:38:18.820
So that's great and it's in-- well
it's only really in 2 dimensions.

00:38:18.820 --> 00:38:20.780
We might want something a little more complicated.

00:38:20.780 --> 00:38:23.590
So let's take a look at one of the
photos that Eliza was working with.

00:38:23.590 --> 00:38:29.350
Now if we take that and break it into tiles we've
got some squares that we can use as individual pieces

00:38:29.349 --> 00:38:32.329
that as they're scrolled around we can reuse them.

00:38:32.329 --> 00:38:35.000
So we'll overlay our ScrollView Frame on top of this again.

00:38:35.000 --> 00:38:39.639
And now, as you can see, some of these tiles are
currently fully visible, some of them are partly visible.

00:38:39.639 --> 00:38:43.500
And there's actually a row at the top that
aren't in the ScrollView's frame at all.

00:38:43.500 --> 00:38:49.400
So those are the ones that we can use to reuse
with new content as the user scrolls around.

00:38:49.400 --> 00:38:53.090
Now, obviously what you're going to want to do
is just animate these tiles as these are flicks

00:38:53.090 --> 00:38:54.240
and they're going to fly all over the place.

00:38:54.239 --> 00:38:55.799
It's going to be pretty awesome.

00:38:55.800 --> 00:38:56.210
[ Laughter ]

00:38:56.210 --> 00:39:04.920
All right, well maybe not, so, I actually just
really like my demo and I wanted to play with my app.

00:39:04.920 --> 00:39:08.250
OK, so let's take a look at what is actually happening.

00:39:08.250 --> 00:39:11.820
User scrolls, some of those tiles go off,
we fill out new content and move them back

00:39:11.820 --> 00:39:14.800
to the other side with the new content in them.

00:39:14.800 --> 00:39:17.019
And the same thing works if we do it in 2 dimensions.

00:39:17.019 --> 00:39:20.570
The user scrolls diagonally, we pull
some of these tiles out and fill them

00:39:20.570 --> 00:39:23.900
out with new content and put them in on the other side.

00:39:23.900 --> 00:39:25.700
So conceptionally it's actually very easy.

00:39:25.699 --> 00:39:29.859
And this is basically exactly what your
TableView does except only in one dimension.

00:39:29.860 --> 00:39:31.579
But where am I going to do this?

00:39:31.579 --> 00:39:34.960
So in this case you're actually going to
have to start sub-classing UIScrollView.

00:39:34.960 --> 00:39:39.190
And you'll want to subclass ScrollView
and override the layoutSubviews Method.

00:39:39.190 --> 00:39:43.010
Now, the one thing to keep in mind if you do
this is that you absolutely want to call super.

00:39:43.010 --> 00:39:47.240
A UIScrollView does do work in its labSubviews
method, and if you don't call super things

00:39:47.239 --> 00:39:50.409
like the scroll indicators may end up in the wrong spot.

00:39:50.409 --> 00:39:53.139
So do subclass but yeah, call super.

00:39:53.139 --> 00:39:59.089
Once you've implemented your labSubviews, you need to figure
out which tiles are currently visible so you can figure

00:39:59.090 --> 00:40:02.780
out which ones you can pull out and
reuse in a new area of the ScrollView.

00:40:02.780 --> 00:40:05.760
Now, that's actually a lot easier than it might sound.

00:40:05.760 --> 00:40:10.880
You can just intersect the subview, the
tiles frame with the ScrollView's bounds.

00:40:10.880 --> 00:40:15.860
So the ScrollView's bounds define the area in the
ScrollView that's currently visible and the frame

00:40:15.860 --> 00:40:18.980
of the tile obviously is its frame
within its ScrollView's bounds.

00:40:18.980 --> 00:40:24.789
So any time that those things intersect,
then that tile is currently visible.

00:40:24.789 --> 00:40:30.119
If they don't intersect, then it's outside; you
can pull it out and reuse it with new content

00:40:30.119 --> 00:40:33.029
where you need it in another part of the ScrollView.

00:40:33.030 --> 00:40:38.750
So that's the basic idea, let's get Eliza back up one more
time to give us a demo of tiling content in UIScrollView.

00:40:38.750 --> 00:40:46.869
>> I've written a subclass of UIScrollView that
tiles its content just as Josh was describing.

00:40:46.869 --> 00:40:52.219
I'm going to show you some pieces of this subclass,
particular the layoutSubviews method which is

00:40:52.219 --> 00:40:55.039
where the bulk of the tiling work gets done.

00:40:55.039 --> 00:40:59.550
But first, let me just tell you a little bit
about the overall architecture of this subclass.

00:40:59.550 --> 00:41:03.330
And for that I'm going to look at
the header file of my subclass.

00:41:03.329 --> 00:41:10.340
So here we have the header file
of my tiled ScrollView subclass.

00:41:10.340 --> 00:41:13.829
I want to bring to your attention
three aspects of this class.

00:41:13.829 --> 00:41:19.529
First, we have this instance variable
called a tile container view.

00:41:19.530 --> 00:41:26.590
What this is, is one big view that is
actually a direct subview of the UIScrollView.

00:41:26.590 --> 00:41:30.360
And we're going to add the tiles of
subviews of it, rather than adding them

00:41:30.360 --> 00:41:33.610
as direct subviews of the UIScrollView itself.

00:41:33.610 --> 00:41:40.130
The reason for this is that if we want to enable zooming
on our content at all the pinch; the pinching only works

00:41:40.130 --> 00:41:45.269
if you return a view from the delegate
method viewForZoomingAnd ScrollView.

00:41:45.269 --> 00:41:50.329
So we can't return one of the tiles because then
only that tile would be scaled as the user pinches.

00:41:50.329 --> 00:41:55.610
So we're going to embed all of our tiles in
this container view in order to enable zooming.

00:41:55.610 --> 00:41:59.260
It also has the added advantage of allowing
you to detect taps all in one place.

00:41:59.260 --> 00:42:05.190
So I've made this a tap detecting view so that we'll be
able to detect all the same taps that we could before.

00:42:05.190 --> 00:42:10.220
All right, the second thing I wanted to draw your
attention to is something that Josh mentioned.

00:42:10.219 --> 00:42:13.469
We're going to use a data source model for this subclass.

00:42:13.469 --> 00:42:18.329
So the subclass is going to be responsible
for laying out all of its tiles just

00:42:18.329 --> 00:42:21.079
as the TableView is responsible for laying out its cells.

00:42:21.079 --> 00:42:23.250
But it won't create the tiles itself.

00:42:23.250 --> 00:42:26.210
It will ask its data source to create the tiles for it

00:42:26.210 --> 00:42:30.309
and it will also ask the data source
to provide the content of the tiles.

00:42:30.309 --> 00:42:37.369
And it will ask the data source for the tiles using
this one data source method titleForRowAndColumn.

00:42:37.369 --> 00:42:41.049
I'm going to ignore this resolution piece of this for now.

00:42:41.050 --> 00:42:43.320
I'll talk more about that in a little while.

00:42:43.320 --> 00:42:49.460
So the last thing I wanted to point out is that
we're going to use recycling as Josh mentioned.

00:42:49.460 --> 00:42:51.940
So we've got a set here of reusable tiles.

00:42:51.940 --> 00:42:56.929
Every time that a tile gets scrolled off of the
visible area we're going to take it out of the view,

00:42:56.929 --> 00:43:02.509
stick it in our reusable tile set and then have it
ready to provide the data source with it if the data,

00:43:02.510 --> 00:43:06.650
so that the data source can avoid
repeatedly creating new tiles.

00:43:06.650 --> 00:43:09.980
All right, so let's switch to the
implementation file and I'm going

00:43:09.980 --> 00:43:13.909
to show you how the layoutSubviews method is going to work.

00:43:13.909 --> 00:43:17.969
The first step is to call super as Josh mentioned.

00:43:17.969 --> 00:43:24.109
The second step is to just grab the visible bounds of the
ScrollView because all of our computations here are going

00:43:24.110 --> 00:43:30.780
to require knowing exactly which
part of the ScrollView is visible.

00:43:30.780 --> 00:43:33.430
So now, we've got our visible bounds.

00:43:33.429 --> 00:43:35.989
We need to figure out which tiles are currently visible.

00:43:35.989 --> 00:43:41.479
And for all the ones that aren't
we're going to recycle them.

00:43:41.480 --> 00:43:46.860
So we'll do that by just iterating through all of the
tiles that are subviews of our tile container view.

00:43:46.860 --> 00:43:51.250
So for each tile that's a subview of the tile
container view we're going to check if it,

00:43:51.250 --> 00:43:55.920
if its frame intercepts the ScrollView's bounds.

00:43:55.920 --> 00:43:59.809
But, there's a bit of a hitch, which
is that the tile container view

00:43:59.809 --> 00:44:04.299
that contains these tiles may have
a transform applied to it.

00:44:04.300 --> 00:44:10.010
If the user has zoomed it all then the coordinate
system of the tile container view will not be the same

00:44:10.010 --> 00:44:11.670
as the coordinate system of the ScrollView.

00:44:11.670 --> 00:44:15.450
So we first need to convert the tiles
frame into the coordinate system

00:44:15.449 --> 00:44:18.460
of the ScrollView before we check whether they intersect.

00:44:18.460 --> 00:44:19.869
So I'll do that here.

00:44:19.869 --> 00:44:27.819
We ask the tile container view to convert the tiles frame
to our own coordinate system where we are the ScrollView.

00:44:27.820 --> 00:44:37.250
Now, if the converted tile frame does not intersect our
visible bounds we're going to recycle the tile by adding it

00:44:37.250 --> 00:44:41.940
to our reusable tiles set and then we're
going to remove it from the superview.

00:44:41.940 --> 00:44:46.630
All right, so that's, so now, we've basically taken all
of the tiles that we're there and we've pruned away all

00:44:46.630 --> 00:44:52.010
of the ones that are no longer visible so
that we can reuse them in what comes up next.

00:44:52.010 --> 00:44:58.260
So next, we are going to figure out
what tiles we actually need to provide.

00:44:58.260 --> 00:45:03.560
We may have scrolled into a region that has some
tiles that are missing so we may need to provide all

00:45:03.559 --> 00:45:06.900
of the missing tiles so that the image appears complete.

00:45:06.900 --> 00:45:12.070
So we have to figure out which ones are missing.

00:45:12.070 --> 00:45:14.480
So first I'm going to actually
figure out which ones are needed.

00:45:14.480 --> 00:45:22.179
I'm going to figure out what rows and columns of our big
tiled image are actually needed based on the visible bounds.

00:45:22.179 --> 00:45:24.799
So I'm going to paste a bunch of math here.

00:45:24.800 --> 00:45:25.750
Don't be alarmed.

00:45:25.750 --> 00:45:29.780
The things-- the point to pay attention
here are just these 4 lines.

00:45:29.780 --> 00:45:32.700
I've computed the first and last needed row and the first

00:45:32.699 --> 00:45:37.839
and last needed column based on the
visible bounds of the ScrollView.

00:45:37.840 --> 00:45:40.200
So this is all going to be available by sample code.

00:45:40.199 --> 00:45:42.289
So you can look at it in more depth there.

00:45:42.289 --> 00:45:42.500
[ Applause ]

00:45:42.500 --> 00:45:50.159
So next, we're going to just iterate
through all of the tiles that we figured

00:45:50.159 --> 00:45:53.009
out that we need and make sure that we've got them.

00:45:53.010 --> 00:45:58.600
So I'm going to go through all the needed rows and
I'm going to go through all the needed columns.

00:45:58.599 --> 00:46:04.219
And for each row and column pair I'm going to check
whether I already have a tile at that row and column.

00:46:04.219 --> 00:46:08.819
Now there's a lot of ways that
you could do the bookkeeping here.

00:46:08.820 --> 00:46:12.850
You might, depending on your purposes,
want to do this in a more complicated way.

00:46:12.849 --> 00:46:16.219
For now, I'm doing it in an incredibly simple way.

00:46:16.219 --> 00:46:19.329
I'm going to switch back to the header
file to show you how it's going to work.

00:46:19.329 --> 00:46:25.599
I've got 4 instance variables here which just keep track
at all times of which rows and columns are visible.

00:46:25.599 --> 00:46:28.940
So I've got first and last visible
row and first and last visible column.

00:46:28.940 --> 00:46:35.400
So assuming that those instance variables contain the
correct information, we can find out if we need a tile

00:46:35.400 --> 00:46:41.950
at this location by just checking whether the row and
column that we're at is within the range that's specified

00:46:41.949 --> 00:46:47.019
by those visible rows and columns
that we've been keeping track of.

00:46:47.019 --> 00:46:49.969
So if the row is too low or too
high then the tile is missing,

00:46:49.969 --> 00:46:53.359
and if the column is too low or
too high then the tile is missing.

00:46:53.360 --> 00:46:57.930
All right so, if the tile is missing then we're
going to need to create a tile and put it there.

00:46:57.929 --> 00:47:00.679
And for that we'll ask our data source.

00:47:00.679 --> 00:47:08.269
So we'll call data source, ask for the
tile of the row and column that we're at.

00:47:08.269 --> 00:47:14.460
And once we've got the tile we're going to set its frame so
that it fits in the right place in our tile container view.

00:47:14.460 --> 00:47:21.119
So we'll figure out the frame we need which is based on
the tile size and the row and column that we're filling.

00:47:21.119 --> 00:47:22.509
We'll set the frame.

00:47:22.510 --> 00:47:26.750
And then, we'll add the tile to our tile container view.

00:47:27.860 --> 00:47:29.960
Pretty much, that's all you'll need to do.

00:47:29.960 --> 00:47:33.099
I'm going to add one more line here
just for demonstration purposes.

00:47:33.099 --> 00:47:37.319
I'm going to draw all over the tile so that you can
see the boarders when I run this, and that you can--

00:47:37.320 --> 00:47:38.789
and so that you can see which tile is which.

00:47:38.789 --> 00:47:40.659
So I'm going to annotate the tile.

00:47:40.659 --> 00:47:46.250
You obviously would not want to do that in your
own code if you were trying to present an image.

00:47:46.250 --> 00:47:48.260
So that's filled in all the needed tiles.

00:47:48.260 --> 00:47:53.390
And the last step is just to update the values
of our first and last visible rows and columns

00:47:53.389 --> 00:47:58.239
so that they contain the correct information
for the next time through layouts and views.

00:47:58.239 --> 00:48:00.539
All right, so we're almost ready to run this.

00:48:00.539 --> 00:48:07.400
Let me just switch to the root view controller for a second
and show you how you would write the method that actually,

00:48:07.400 --> 00:48:12.280
this is not-- there we go, write the
method that actually returns the tile.

00:48:12.280 --> 00:48:18.940
So we're going to first ask the ScrollView
to give us a recycled tile if possible.

00:48:18.940 --> 00:48:22.380
So we'll DQ a reusable tile if there's one available.

00:48:22.380 --> 00:48:26.119
If there isn't then we're going to need to create one.

00:48:26.119 --> 00:48:28.250
I mean I initialized; it was a 0 frame

00:48:28.250 --> 00:48:33.369
because the ScrollView itself is actually
doing the work of sizing the tiles.

00:48:33.369 --> 00:48:36.599
Then, I'm going to provide the tile with content.

00:48:36.599 --> 00:48:38.190
Now, there's lots of different ways you could do this.

00:48:38.190 --> 00:48:42.220
You could be getting your content from online,
you could be drawing your content directly.

00:48:42.219 --> 00:48:46.669
In my case I've actually cut up these images in
advance and added them as resources to my project,

00:48:46.670 --> 00:48:49.380
so I'm just going to grab the appropriate piece.

00:48:49.380 --> 00:48:50.930
And I'm going to return it.

00:48:50.929 --> 00:48:55.269
All right, so let's build this and see what happens.

00:48:55.269 --> 00:49:01.219
All right, so we've got our image and you can
see that I've drawn boarders on the tiles.

00:49:01.219 --> 00:49:04.679
I've given each tile a unique number
so we can track which one is which.

00:49:04.679 --> 00:49:09.169
As I scroll around you can see that
we're using a bunch of different tiles.

00:49:09.170 --> 00:49:11.670
There's a total of 9 of them actually.

00:49:11.670 --> 00:49:17.099
And the reason that there's 9 is that you might be
seeing 9 tiles at once or pieces of 9 tiles at once.

00:49:17.099 --> 00:49:19.940
We're actually not going to create
any other tiles besides these 9.

00:49:19.940 --> 00:49:23.090
We're just going to keep reusing the
very same tiles over and over again.

00:49:23.090 --> 00:49:25.320
There's number 9 again and so on.

00:49:25.320 --> 00:49:30.370
So now, I've added one more feature
with this application which has to do

00:49:30.369 --> 00:49:33.440
with this resolution business that
I kept ignoring in the code.

00:49:33.440 --> 00:49:39.639
So you might want, if you're writing a maps-like application
or even just an application that shows a very large image.

00:49:39.639 --> 00:49:45.629
You might actually want to have the ability as the
user zooms in the image to change the resolution

00:49:45.630 --> 00:49:48.349
of the image pieces that you're displaying.

00:49:48.349 --> 00:49:55.460
So here as the user zooms out, what's going to happen
is first the tiles will get scaled, so they're just--

00:49:55.460 --> 00:49:59.720
the transform is being applied to the tile
container view and the tiles are getting shrunk down.

00:49:59.719 --> 00:50:07.459
But, after I pass the half way mark they get replaced
by tiles that are showing twice as much of the image

00:50:07.460 --> 00:50:12.000
or actually 4 times as much, twice as much in
each direction, but at half the resolution.

00:50:12.000 --> 00:50:17.429
So I can now scroll around and you can see that
there's fewer tiles making up the entire image.

00:50:17.429 --> 00:50:21.940
And I'm going to do it again because
we also support a 25% resolution.

00:50:21.940 --> 00:50:27.300
So as I get to the halfway point
now I get my tiles replaced again.

00:50:27.300 --> 00:50:33.380
And this time they're at the minimum resolution and in
fact the entire image is being made up with only 6 tiles.

00:50:33.380 --> 00:50:39.480
So this has one really good advantage,
which is that loading an image to begin

00:50:39.480 --> 00:50:43.309
with when we're zooming all the way
out on an image, it's really fast now.

00:50:43.309 --> 00:50:47.199
I don't know if it was apparent on this
computer (which is a pretty fast computer)

00:50:47.199 --> 00:50:50.669
when I was showing you the earlier
versions of this application,

00:50:50.670 --> 00:50:55.519
but when I switched images there was a
perceptible delay in the new image loading

00:50:55.519 --> 00:50:59.610
because it was actually opening an 8
megabyte file and loading it into memory.

00:50:59.610 --> 00:51:05.990
Now, if I bring up my drawer and I switch images
to say this one, it loads instantaneously,

00:51:05.989 --> 00:51:12.259
because it's actually only reading about 300K of
data that comprises those 6 files that you see there.

00:51:12.260 --> 00:51:17.800
So now, if I zoom in on this, on
this image what will happen is,

00:51:17.800 --> 00:51:23.170
I'll start replacing my low resolution
tiles by higher resolution tiles.

00:51:23.170 --> 00:51:28.880
And now, I've gotten to the highest resolution possible
and you can see that there's really quite a lot of them.

00:51:28.880 --> 00:51:33.510
All right, so if you want more information about how
this works, the resolution swapping in particular

00:51:33.510 --> 00:51:37.740
which I didn't show you the code for, take
a look at the sample code which is available

00:51:37.739 --> 00:51:40.589
for download, and also feel free to come to the labs.

00:51:40.590 --> 00:51:44.010
There's one right after this session
and then there's another one tomorrow.

00:51:44.010 --> 00:51:48.830
Both Josh and I will be there and we'd be happy to
explain how you do this resolution swapping for tiling.

00:51:48.829 --> 00:51:49.980
Thanks a lot.

00:51:49.980 --> 00:51:57.940
[ Applause ]

00:51:57.940 --> 00:51:59.200
>> Thanks again Eliza.

00:51:59.199 --> 00:52:03.529
So as I mentioned and as Eliza mentioned
all this code is available as samples.

00:52:03.530 --> 00:52:05.820
And Eliza's put a lot of work into this.

00:52:05.820 --> 00:52:07.309
I think it's really going to be great.

00:52:07.309 --> 00:52:08.699
There's a lot of good information there.

00:52:08.699 --> 00:52:12.659
Please download it, make use of
it, do some cool things with it.

00:52:12.659 --> 00:52:14.569
So now you've got all your content.

00:52:14.570 --> 00:52:20.240
You're scrolling it, zooming it, interacting with
it, and not crashing when you put it on your iPhone.

00:52:20.239 --> 00:52:20.959
So everything's great.

00:52:20.960 --> 00:52:24.679
There is this one last bit that I mentioned
early on that I'd like to cover quickly,

00:52:24.679 --> 00:52:27.789
and that's nesting ScrollViews within ScrollViews.

00:52:27.789 --> 00:52:30.529
So I've got a quick video here that shows the places that--

00:52:30.530 --> 00:52:32.990
some of the places we're using
this in iPhone LS 3.0 already.

00:52:32.989 --> 00:52:35.239
So I'm going to kind of talk through it real quick.

00:52:35.239 --> 00:52:39.569
So you can actually now on your home screen,
you know, swipe left to get to the Spotlight.

00:52:39.570 --> 00:52:43.780
And within Spotlight there's a vertical
ScrollView that you can scroll up and down.

00:52:43.780 --> 00:52:46.460
And let's page back to your home screen.

00:52:46.460 --> 00:52:51.389
Within Socks you can page the horizontal
ScrollView at the bottom and then scroll vertically

00:52:51.389 --> 00:52:53.739
within that TableVeiw and then back again.

00:52:53.739 --> 00:52:58.589
Now both of these examples have a horizontal
outer ScrollView with a vertical inner ScrollView.

00:52:58.590 --> 00:53:01.280
Obviously the inverse also works just as well.

00:53:01.280 --> 00:53:08.330
UIKit actually takes care of all of the-- all of the work
of figuring out which ScrollView is intended to be scrolled.

00:53:08.329 --> 00:53:11.960
It figures out whether the user's moving
horizontally or vertically and picks the right one.

00:53:11.960 --> 00:53:15.730
You don't have to do any craziness with trying
to forward touches between views or anything.

00:53:15.730 --> 00:53:18.559
All of that just happens.

00:53:18.559 --> 00:53:29.500
We, we fully support cross-axis nesting, vertical views and
horizontal, horizontal and vertical-- that all works great.

00:53:29.500 --> 00:53:33.340
We use it all over the place ourselves and
definitely encourage you guys to do it.

00:53:33.340 --> 00:53:38.430
Same axis nesting, a vertical ScrollView
and a vertical ScrollView, it will work.

00:53:38.429 --> 00:53:43.219
The interaction and the user experience
is still subject to change.

00:53:43.219 --> 00:53:46.929
We haven't really settled on exactly what
the experience is that we want in that case

00:53:46.929 --> 00:53:49.369
so we really discourage that kind of a nesting.

00:53:49.369 --> 00:53:54.219
It will work and there is a behavior that is
defined, but that defined behavior may change.

00:53:54.219 --> 00:54:01.619
So yeah, please do the horizontal and vertical
in each-- in one another-- that's pretty great.

00:54:01.619 --> 00:54:05.609
So looking back at what we've covered
there are alternatives.

00:54:05.610 --> 00:54:12.309
If you can make use of UITableView and UITextView or
UIWebView you may not have to use a UIScrollView directly.

00:54:12.309 --> 00:54:15.269
But it's there if these things don't meet your needs.

00:54:15.269 --> 00:54:22.500
Also, custom interactions-- do these in subviews of your
UIScrollView, not in a subclass of UIScrollView itself.

00:54:22.500 --> 00:54:27.849
We haven't really been clear on this over the past but
we really-- the intention is that custom interactions--

00:54:27.849 --> 00:54:33.929
touch detection, tap detection-- this is intended to
happen in subviews of the ScrollView and the 2 properties

00:54:33.929 --> 00:54:40.349
and 2 methods that I mentioned-- 2 control touches are all
designed to work with touches in subviews of the ScrollView.

00:54:40.349 --> 00:54:45.299
And both of those properties and both of those
methods have existed since iPhone OS 2.0.

00:54:45.300 --> 00:54:48.990
So they're not new in 3.0 despite the fact that
when I was walking off I said these new properties.

00:54:48.989 --> 00:54:56.750
And finally saved memory-- load only what you need
to display what the user is currently viewing.

00:54:56.750 --> 00:54:59.019
Try and improve your user experience that way.

00:54:59.019 --> 00:55:03.860
So if you have more questions after the session,
Matt Drance is our Application Frameworks Evangelist.

00:55:03.860 --> 00:55:06.329
I'm sure you've all been seeing his name a lot this week.

00:55:06.329 --> 00:55:08.299
And you'll see his face in just a minute again.

00:55:08.300 --> 00:55:14.910
And UIScrollView Class Reference on developer.apple.com
is also a great resource for information on UIScrollView.

00:55:14.909 --> 00:55:16.579
There are 2 related sessions.

00:55:16.579 --> 00:55:16.679
1
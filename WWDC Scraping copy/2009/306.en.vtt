WEBVTT

00:00:13.039 --> 00:00:15.379
>> Hello everyone, my name is Troy Koelling.

00:00:15.380 --> 00:00:16.710
I'm an Engineer in Quartz Composer.

00:00:16.710 --> 00:00:20.850
And welcome to Quartz Composer Advances in Snow Leopard.

00:00:20.850 --> 00:00:26.270
Today we're going to talk about Quartz
Composer advances in Snow Leopard.

00:00:26.269 --> 00:00:35.259
But first, I'd like to talk about Quartz Composer
advances as they've come in the other releases of OS X.

00:00:35.259 --> 00:00:43.229
So Quartz Composer was introduced
with OS X Tiger 10.4 and what was--

00:00:43.229 --> 00:00:48.390
what Quartz Composer is, is a framework
which allows you to do graphic visualizations

00:00:48.390 --> 00:00:50.270
which is embedded into the operating system.

00:00:50.270 --> 00:00:57.070
So you don't have ship any plug-ins or any special
applications for your users to use with your applications

00:00:57.070 --> 00:01:03.659
or if you want to just ship the compositions, the
users will be able to open those in QuickTime.

00:01:03.659 --> 00:01:10.659
Quartz Composer is also an editor which also ships with the
developer tools and that ship with Tiger and it allows you

00:01:10.659 --> 00:01:13.469
to create these files which we call compositions.

00:01:13.469 --> 00:01:19.120
And compositions are a set of patches
or notes that are connected together

00:01:19.120 --> 00:01:26.250
to define how your graphic visualization is going to work.

00:01:26.250 --> 00:01:31.150
In Leopard we really matured the
technology and we introduced a whole slew

00:01:31.150 --> 00:01:35.740
of new user interface elements such as the QC pick review.

00:01:35.739 --> 00:01:39.280
We have the parameter view.

00:01:39.280 --> 00:01:46.359
We also introduced a way to share compositions among the
entire operating system with the QC composition repository.

00:01:46.359 --> 00:01:50.030
And what this allows you to do is to create
a composition which will work not only

00:01:50.030 --> 00:01:53.420
for Photo Booth, iChat and your own application.

00:01:53.420 --> 00:02:02.159
And it allows people to really have an open community
and really utilizes compositions in a powerful way.

00:02:02.159 --> 00:02:07.929
Of course you also have been making a lot of
really great plug-ins with the QC plug-in API

00:02:07.930 --> 00:02:10.590
which were introduced in Leopard as well.

00:02:10.590 --> 00:02:14.219
And we're really proud of all the work you guys are doing

00:02:14.219 --> 00:02:18.020
and it's really great work that
we're seeing out of you guys.

00:02:18.020 --> 00:02:21.630
So today, we're going to talk about the
advances that we're making in Snow Leopard.

00:02:21.629 --> 00:02:25.019
'Cause as I said, Leopard was really
the maturity of Quartz Composer,

00:02:25.020 --> 00:02:30.500
now we're going to take you a couple steps
further in some very specific applications.

00:02:30.500 --> 00:02:37.090
And also we're strengthening the baseline with
performance improvements and workflow improvements as well.

00:02:37.090 --> 00:02:40.200
So what are you going to learn today?

00:02:40.199 --> 00:02:44.780
You're going to learn about the editor, the
performance, improvements that we've been making,

00:02:44.780 --> 00:02:47.939
and then we're going to talk about
OpenCL and the geometry pipeline.

00:02:47.939 --> 00:02:50.930
And it's important to note that the things we're talking

00:02:50.930 --> 00:02:54.960
about today are really passive
instructions that we've been working on.

00:02:54.960 --> 00:03:01.409
And I want to challenge each of you to kind of take a
call to action to think about what we're talking about,

00:03:01.409 --> 00:03:06.439
how that can apply to you and how you are going to
go out and use this in your application right away.

00:03:06.439 --> 00:03:11.300
Because I can talk about how we've made the editor
better but what that's going to mean to you is,

00:03:11.300 --> 00:03:16.400
now you can make your compositions faster, you
can create them and develop, deploy them faster.

00:03:16.400 --> 00:03:21.409
Or I'm going to talk about performance improvements
and that's going to really impact your application

00:03:21.409 --> 00:03:25.460
and allow users to use your application
on lower range computers

00:03:25.460 --> 00:03:29.960
or you can integrate more complexity into your compositions.

00:03:29.960 --> 00:03:32.659
So let's get started with the editor.

00:03:32.659 --> 00:03:35.759
We have a brand new user interface in Snow Leopard.

00:03:35.759 --> 00:03:37.349
We've been working really hard on this.

00:03:37.349 --> 00:03:38.479
We're really proud of it.

00:03:38.479 --> 00:03:44.909
It's supposed to both help you work faster and more--

00:03:44.909 --> 00:03:50.490
get you down to business quicker and also supposed
to look a little more professional so that you know

00:03:50.490 --> 00:03:56.070
that you're not working on a toy, this thing that's
been taking you a week or a month to develop.

00:03:56.069 --> 00:03:59.719
It's not just some kind of bubbly
little user interface application.

00:03:59.719 --> 00:04:06.840
So what you're seeing here on the left hand sign, I
believe that's your left hand, yes, is the editor.

00:04:06.840 --> 00:04:08.450
This is where the nodes are lined up.

00:04:08.449 --> 00:04:15.149
For those of you that are new users, Quartz Composer is a
technology which takes nodes and puts them on a workspace

00:04:15.150 --> 00:04:18.660
and you connect little wires which
we call connections between them

00:04:18.660 --> 00:04:22.130
to define how the data flows through your composition.

00:04:22.129 --> 00:04:30.040
So for example, this might be a macro patch
which is taking in a list of items and those--

00:04:30.040 --> 00:04:33.390
each of those items is a point with an XYZ position.

00:04:33.389 --> 00:04:44.610
So for example, this composition, it takes the-- an item at
an index member which is that structure index member patch

00:04:44.610 --> 00:04:48.400
and it splits it out into three different numbers.

00:04:48.399 --> 00:04:54.009
And you can see those three different patches in
my gray box which actually do the splitting out.

00:04:54.009 --> 00:04:57.829
Each of those will have a different
index number for each of those patches.

00:04:57.829 --> 00:05:03.120
So you get the XYZ position and then
you were setting that on a sprite.

00:05:05.610 --> 00:05:09.069
So what have we improved in the Quartz Composer Editor?

00:05:09.069 --> 00:05:12.740
Well the big thing, one of the big things
we've been working on is the new patch library.

00:05:12.740 --> 00:05:19.629
This patch library shares some user interface elements
with some other applications on the system you're not use,

00:05:19.629 --> 00:05:22.990
used to, such as the interface builder and Dashcode.

00:05:22.990 --> 00:05:28.879
But it retains a lot of the same behaviors
that we had in Leopard that were really great.

00:05:28.879 --> 00:05:33.019
So for example, you can still search
and filter these patches

00:05:33.019 --> 00:05:36.509
by just typing out a couple letters in the search bar.

00:05:36.509 --> 00:05:37.870
We actually improve the search as well.

00:05:37.870 --> 00:05:40.860
We've added alias terms to some of the patches.

00:05:40.860 --> 00:05:50.040
So for example, you may not understand if you're coming
from a DSP background that in Quartz Composer nomenclature,

00:05:50.040 --> 00:05:53.360
multiplexer is what you might think of as a switch.

00:05:53.360 --> 00:05:55.300
So if you type switch now, you're gonna get multiplexer.

00:05:55.300 --> 00:06:01.009
And that should make it easier for you to discover
which patches you need to be using in your compositions.

00:06:01.009 --> 00:06:10.569
[ Pause ]

00:06:10.569 --> 00:06:12.730
>> Next thing that's the same as Leopard is inserting.

00:06:12.730 --> 00:06:18.670
You can still just hit Return when you have a patch
selected in the list or you can drag and drop from the list.

00:06:18.670 --> 00:06:20.800
That's no different than was in Leopard.

00:06:20.800 --> 00:06:23.410
We've also added custom groups

00:06:23.410 --> 00:06:27.300
Now this is a-- could be a really powerful paradigm.

00:06:27.300 --> 00:06:30.230
We're not sure 'cause we haven't
seen anybody actually use it.

00:06:30.230 --> 00:06:32.610
I haven't seen you guys, what you're going to do with it.

00:06:32.610 --> 00:06:38.509
But basically, what you can do is pop-up the
dialogue like this, create a filter, a search term

00:06:38.509 --> 00:06:41.649
or there's other properties that you can filter on there.

00:06:41.649 --> 00:06:46.859
You can name it and it's going to create
that folder icon there in the Patch Library.

00:06:46.860 --> 00:06:50.710
And then you can quickly get to those patches easily.

00:06:50.709 --> 00:06:55.019
We've also added examples, it's going to be really
powerful but for those of you who are new users,

00:06:55.019 --> 00:06:59.810
because you can just click a link in the patch
description, open up a composition which uses that patch

00:06:59.810 --> 00:07:02.009
and find out how it's supposed to be used.

00:07:02.009 --> 00:07:08.500
And the Patch Library is the place
to go to manage your Virtual Macros.

00:07:08.500 --> 00:07:10.920
And Virtual Macros are very important.

00:07:10.920 --> 00:07:15.400
I use them all the time and I don't get to do
that much playing around with Quartz Composer,

00:07:15.399 --> 00:07:19.589
only the Fridays that I kind of
take off and work on my own stuff.

00:07:19.589 --> 00:07:25.929
So if I can use them in my daily work, then I know you guys
can use them in the cool compositions that you're creating.

00:07:25.930 --> 00:07:31.290
So I'm going to talk a bit about that
today and go into detail on how that works.

00:07:31.290 --> 00:07:34.069
Virtual Macros, what is a Virtual Macro?

00:07:34.069 --> 00:07:37.889
Whenever I say Virtual Macro, you can
just think of an external composition.

00:07:37.889 --> 00:07:45.729
A composition which has the functionality of a certain
macro, a certain subsection of your composition,

00:07:45.730 --> 00:07:48.560
and it's saved externally on the
disc and loaded at run time.

00:07:48.560 --> 00:07:51.500
So what does that mean?

00:07:51.500 --> 00:07:58.850
That means you can modulize your compositions, you can reuse
aspects of them, and you can share them with your coworkers,

00:07:58.850 --> 00:08:02.480
or you can deploy them on the web, that kind of thing.

00:08:02.480 --> 00:08:05.400
The Quartz Composer Editor has one
button to create Virtual Macros.

00:08:05.399 --> 00:08:07.589
There is one button to edit them.

00:08:07.589 --> 00:08:11.959
There is one button to share a Virtual
Macro and one button to install them.

00:08:11.959 --> 00:08:17.389
It's one button for-- one composition to
bring them all and in the darkness rule them.

00:08:17.389 --> 00:08:19.310
[ Laughter ]

00:08:19.310 --> 00:08:21.180
>> So, here's the Quartz Composer Editor.

00:08:21.180 --> 00:08:23.480
There's the Patch Library as I mentioned.

00:08:23.480 --> 00:08:26.780
What we're going to do is select the patches.

00:08:26.779 --> 00:08:31.469
The new UI represents selected patches
with an orange band around them

00:08:31.470 --> 00:08:34.399
and I hope you can see there-- that up there on the screen.

00:08:34.399 --> 00:08:37.360
All three of the patches in the gray square are selected.

00:08:37.360 --> 00:08:42.250
Now, what we're going to do is click the
Add to Library button in the toolbar.

00:08:42.250 --> 00:08:49.570
And this is going to present for you a dialogue where
you're going to be able to name your Virtual Macro.

00:08:49.570 --> 00:08:53.550
And really important, it's going to also allow you
to create a description, this is really important

00:08:53.549 --> 00:08:57.879
because this is how your users are going to know what
to do with your Virtual Macro and also for yourself

00:08:57.879 --> 00:09:02.509
in the future whenever you're going to use this.

00:09:02.509 --> 00:09:09.009
When you click Done, those three patches are going to
be wrapped up into a Virtual Macro and saved to disc.

00:09:09.009 --> 00:09:14.689
And then you're going to get this new
patch which is inserted into the library,

00:09:14.690 --> 00:09:17.650
into the workspace for you with
all the connections recreated.

00:09:17.649 --> 00:09:24.039
And as you can see here, the name of the patch is added to
your Patch Library and you could begin using it right away.

00:09:24.039 --> 00:09:28.889
This is a really powerful thing, for let's
say you have a bunch of different components

00:09:28.889 --> 00:09:32.159
in your composition but you have repeated functionality.

00:09:32.159 --> 00:09:38.759
This way you can have one place to edit that functionality
and have it affect all the different places where it's used.

00:09:38.759 --> 00:09:46.049
Now it's in the Patch Library and we can
continue to manage them with the action menu,

00:09:46.049 --> 00:09:51.959
that's the little gear on the lower left hand
corner, or you can right-click on the patch.

00:09:51.960 --> 00:09:53.639
So you can edit a Virtual Macro.

00:09:53.639 --> 00:09:57.399
What this does is open up the Virtual
Macro as a composition,

00:09:57.399 --> 00:09:59.590
you can make all the changes you
want and you can press Save.

00:09:59.590 --> 00:10:07.120
Then the edited Virtual Macro, the edited
composition that is, will be saved to disc, of course,

00:10:07.120 --> 00:10:09.690
and then repopulate all your open compositions that use it.

00:10:09.690 --> 00:10:17.320
>> That's make it really easy to streamline your workflow
because you can make a small tweak and you don't have

00:10:17.320 --> 00:10:22.110
to close down Quartz Composer as you did in
Leopard, reopen it in order to reload these patches.

00:10:22.110 --> 00:10:27.850
We also have the ability to export a Virtual Macro.

00:10:27.850 --> 00:10:33.730
This means that you can take the Virtual
Macro which is on disc and save it off

00:10:33.730 --> 00:10:36.519
to say your desktop and then you can email it to somebody.

00:10:36.519 --> 00:10:39.980
What's important to note that you don't
have to do this to deploy your compositions.

00:10:39.980 --> 00:10:45.639
In Snow Leopard, we've implemented a feature which
will serialize all your Virtual Macros that you use

00:10:45.639 --> 00:10:48.889
and add them as metadata in your composition.

00:10:48.889 --> 00:10:49.759
So it's really important.

00:10:49.759 --> 00:10:53.850
Let me say it again, the Virtual Macros are
going to be serialized in your composition,

00:10:53.850 --> 00:11:01.250
meaning that you're not going to have these
nasty dependencies as if you were using, like,

00:11:01.250 --> 00:11:07.519
real QC plug-ins because the Virtual
Macros are installed with your composition

00:11:07.519 --> 00:11:10.870
and they can be used in a read-only fashion.

00:11:10.870 --> 00:11:13.220
So exporting, what use does exporting have?

00:11:13.220 --> 00:11:18.759
Well that's how you get them to your coworkers so that they
can have read-write functionality over those Virtual Macros.

00:11:18.759 --> 00:11:23.460
And that's how can you really collaborate
on these modular components.

00:11:24.970 --> 00:11:28.580
When you export a Virtual Macro, it's
going to be saved to disc as a composition

00:11:28.580 --> 00:11:32.340
because these Virtual Macros, as I
mentioned, are just compositions.

00:11:32.340 --> 00:11:35.700
But we do have some metadata on there
to know that they are compositions.

00:11:35.700 --> 00:11:40.960
So that when you double-click on one, it's going to open
up this dialogue that says, "Do you want to install this?

00:11:40.960 --> 00:11:42.269
Because it's a Virtual Micro."

00:11:42.269 --> 00:11:45.549
Otherwise, you're going to open up a composition
and it's going to have nothing rendering.

00:11:45.549 --> 00:11:49.120
It's not going to seem like a complete thing.

00:11:49.120 --> 00:11:57.340
So we also put some logic in there to make
sure that if you already have a Virtual Macro,

00:11:57.340 --> 00:11:58.600
it's going to upgrade it and all that stuff.

00:11:58.600 --> 00:12:00.670
So we take care of all the heavy lifting.

00:12:00.669 --> 00:12:06.079
You never really need to go to the finder, into the library,
and figure out that silly directory where they're saved.

00:12:06.080 --> 00:12:09.280
You just can do everything you need
to do from within Quartz Composer.

00:12:09.279 --> 00:12:16.500
So now let's stop messing around the slides and actually go
to a demo and see the new Quartz Composer Editor in action.

00:12:16.500 --> 00:12:20.720
So let's go ahead and open up the Quartz Composer Editor.

00:12:20.720 --> 00:12:24.000
First thing you're going to notice
is our brand-new welcome sheet.

00:12:24.000 --> 00:12:28.669
When you first open up Quartz Composer, it's going
to be on this getting started pane which is going

00:12:28.669 --> 00:12:32.219
to provide an introduction to Quartz
Composer and also these four links

00:12:32.220 --> 00:12:39.040
to the very important documentation and
link to the external developer list.

00:12:39.039 --> 00:12:40.879
Also examples, as they are on the web.

00:12:40.879 --> 00:12:46.679
And this will be your jumping-off point for learning how
to use Quartz Composer for those of you who are new users.

00:12:46.679 --> 00:12:51.459
All these are live links and they'll open up in Safari.

00:12:51.460 --> 00:12:53.820
We also have this new tips panel.

00:12:53.820 --> 00:12:57.480
These are the tips that the Quartz
Composer team have collected

00:12:57.480 --> 00:13:02.409
and decided these are the really important things we want
to share with you, that don't really fit in a release note

00:13:02.409 --> 00:13:03.829
and they don't really fit in a tech note.

00:13:03.830 --> 00:13:07.320
These are just short little things that
will help you get your work done faster.

00:13:07.320 --> 00:13:11.220
And finally, we have the templates view.

00:13:11.220 --> 00:13:13.580
This is similar to how it was in Leopard.

00:13:13.580 --> 00:13:18.750
All of these templates are live updating.

00:13:18.750 --> 00:13:24.710
This is actually using a composition loader to load
the composition into this sheet that comes down

00:13:24.710 --> 00:13:27.340
and show you what you're going to get when you click Choose.

00:13:27.340 --> 00:13:35.290
We also have examples linked from here so you can
have an idea of what that template is going to do.

00:13:35.289 --> 00:13:40.620
You know, go ahead and close this for now and
open up an example that will help us learn

00:13:40.620 --> 00:13:44.159
about Virtual Macros a little bit better.

00:13:44.159 --> 00:13:49.679
So not only do we provide the feature of Virtual
Macros, we also provided a bunch a of Virtual Macros

00:13:49.679 --> 00:13:53.209
that we use every day that seemed
to be useful in most compositions.

00:13:53.210 --> 00:13:57.639
This is like us introducing a whole bunch
of new patches but these Virtual Macros,

00:13:57.639 --> 00:14:00.870
these patches you can go in and edit if you need to.

00:14:00.870 --> 00:14:08.060
So what I've done here, is created a
composition which is a small movie player.

00:14:08.059 --> 00:14:16.079
[Noise] And as you can see, I've created a little hud
floating controller on this composition and it floats

00:14:16.080 --> 00:14:23.690
over the movie and allows you to play and pause
using our new interaction model in Quartz Composer.

00:14:23.690 --> 00:14:29.100
And although these buttons aren't very complicated,
you could imagine that they were created in Photoshop

00:14:29.100 --> 00:14:33.460
and they have they have specific sizes and
I always want them to display at that size

00:14:33.460 --> 00:14:35.920
so they don't get stretched out or anything.

00:14:35.919 --> 00:14:41.209
So I've done everything right with-- I've
used the anchor patch to pin it to the side,

00:14:41.210 --> 00:14:46.950
I've used the billboard's actual pixel size to make
sure that the image never stretches or shrinks.

00:14:46.950 --> 00:14:50.810
And these are all things that you can find
out about by viewing previous years' demos.

00:14:50.809 --> 00:14:56.529
Unfortunately, we don't have time to go into those in-depth
but I do invite you to check those out if you have time.

00:14:56.529 --> 00:15:04.299
But there's one thing that a lot of people have trouble
with and that is, if I want to make this bigger,

00:15:04.299 --> 00:15:07.679
I want the hud to stay to the same
size and the same aspect ratios.

00:15:07.679 --> 00:15:12.809
But because it's using Quartz Composer units and
I've intermixed Quartz Composer units and units

00:15:12.809 --> 00:15:16.719
and pixels, these buttons tend to move around.

00:15:16.720 --> 00:15:18.600
And that's no good.

00:15:18.600 --> 00:15:22.450
So what we need to do is also position
the user interface elements,

00:15:22.450 --> 00:15:26.840
using the same methods that we
use to size them and place them.

00:15:26.840 --> 00:15:33.080
And so for that you need to convert from Quartz Composer
units to pixels, actually the other way round 'cause we want

00:15:33.080 --> 00:15:37.270
to set pixel values and translate
that to Quartz Composer units.

00:15:37.269 --> 00:15:41.389
So Quartz Composer now provides that for you.

00:15:41.389 --> 00:15:47.059
We have the units-to-pixels patch and the pixels-to-units.

00:15:47.059 --> 00:15:53.349
So for example, I can just drop this pixels-to-units patch
in here and I can type in a number of pixels, say 100,

00:15:53.350 --> 00:15:57.940
and it's going to output the Quartz
Composer conversion of that.

00:15:57.940 --> 00:16:00.010
And this is a really easy conversion to do.

00:16:00.009 --> 00:16:03.009
It's totally trivial, it's just two patches.

00:16:03.009 --> 00:16:05.179
Actually, let's go ahead and show that.

00:16:05.179 --> 00:16:07.569
It's just the rendering destination dimensions.

00:16:07.570 --> 00:16:09.870
So I'm going to edit this pixel-to-units patch.

00:16:09.870 --> 00:16:18.330
And you can see it's this rendering destination dimensions
and we just get the ratio of the width to the pixels wide.

00:16:18.330 --> 00:16:21.480
So the pixels wide is the number of pixels on the screen.

00:16:21.480 --> 00:16:24.629
So in this case, I'm guessing that's 800.

00:16:24.629 --> 00:16:29.990
And in this case, the width is always going
to be 2 because Quartz Composer units are two.

00:16:29.990 --> 00:16:38.180
So, there are two and let's see how close
I was, 512, I guess I was little off.

00:16:38.179 --> 00:16:44.729
So these two patches can now be
used inside this Virtual Macro.

00:16:44.730 --> 00:16:51.870
Now setting up all those pixel values for each
of these offset values is kind of tedious.

00:16:51.870 --> 00:16:54.879
So I went ahead and prepared that before the show.

00:16:54.879 --> 00:17:01.009
But let's go ahead and see what happens
when I connect each of these up.

00:17:01.009 --> 00:17:15.789
[ Pause ]

00:17:15.789 --> 00:17:18.909
>> And that's all there is to it.

00:17:18.910 --> 00:17:24.240
[Noise] You see the interaction is still tied to the sprite
in question or the billboard in question in this case.

00:17:24.240 --> 00:17:30.140
And [noise] my little movie player is now
properly resizing just as I wanted it to.

00:17:30.140 --> 00:17:32.200
I can go all the way to full screen.

00:17:32.200 --> 00:17:35.620
I can drag this anywhere I want.

00:17:35.619 --> 00:17:41.699
And so that's a brief demonstration of how
Quartz Composer now uses Virtual Macros.

00:17:41.700 --> 00:17:46.620
So that concludes our editor session.

00:17:46.619 --> 00:17:49.649
If you have any other questions, please
feel free to visit us in the lab tomorrow.

00:17:49.650 --> 00:17:56.009
Now I'd like to talk about performance and what we've been
doing to make Quartz Composer even faster in Snow Leopard.

00:17:56.009 --> 00:18:00.599
[ Pause ]

00:18:00.599 --> 00:18:08.699
>> So Quartz Composer is a node-based graphics
language and what that means is there's a graph.

00:18:08.700 --> 00:18:12.600
Now I'm not talking about a spreadsheet graph
like you'd see in, numbers or something.

00:18:12.599 --> 00:18:17.730
I'm talking about your CS 101,
a tree is a graph kind of graph.

00:18:17.730 --> 00:18:24.279
And so here's an example of a graph, because we
have an image node it connects to the billboard

00:18:24.279 --> 00:18:29.049
and we also have a separate kind of
entity which is this interaction patch

00:18:29.049 --> 00:18:32.099
which moves around a mesh which has been imported.

00:18:32.099 --> 00:18:33.389
This is a 3D model.

00:18:33.390 --> 00:18:39.210
So because this is a graph, we know certain things about it.

00:18:39.210 --> 00:18:45.680
We know, for example, how to find a sub-graph
and when a sub-graph needs to be executed.

00:18:45.680 --> 00:18:50.150
We can find that corresponding region onscreen
and we can skip rendering whenever possible.

00:18:50.150 --> 00:18:59.870
And this is really great for performance because
the best-- the best performance is doing nothing.

00:18:59.869 --> 00:19:06.379
In fact, with new idle state optimization,
if your composition doesn't have any changes

00:19:06.380 --> 00:19:09.160
and the animation is going on, we're
going to stop rendering completely.

00:19:09.160 --> 00:19:13.160
So you have a perfectly idle composition.

00:19:13.160 --> 00:19:19.850
That's really great for all sorts
of practice-- all sorts of--

00:19:19.849 --> 00:19:27.289
all sorts of implementations because
especially for interaction you do something,

00:19:27.289 --> 00:19:29.639
your composition reacts, and then
it goes back to a known state.

00:19:29.640 --> 00:19:38.110
So let's talk about the performance--
let's go back to a demo of a performance.

00:19:38.109 --> 00:19:43.409
I mentioned earlier that when you open up
Quartz Composer you get this template sheet.

00:19:43.410 --> 00:19:48.810
What I didn't mention is that this template
sheet is actually implemented in Quartz Composer,

00:19:48.809 --> 00:19:51.940
just to prove that we could do something so complicated.

00:19:51.940 --> 00:19:56.259
It's not something we recommend that everybody
do, obviously, 'cause there are much better ways

00:19:56.259 --> 00:20:02.079
to display a view like, let's say,
WebKit or even Interface Builder.

00:20:02.079 --> 00:20:06.359
But because we want you guys to have the most
freedom possible, we had to prove to ourselves

00:20:06.359 --> 00:20:13.639
that we could create a composition that
could be used as a interactive interface.

00:20:13.640 --> 00:20:16.780
>> So all these things are being
done through Quartz Composer.

00:20:16.779 --> 00:20:24.480
So to prove that, I can go ahead and open up the
composition which you can find in the resources

00:20:24.480 --> 00:20:26.549
of the editor if you want to muck around with that.

00:20:26.549 --> 00:20:32.049
And you can see how this welcome sheet was created.

00:20:32.049 --> 00:20:35.109
It's not a simple composition obviously.

00:20:35.109 --> 00:20:37.199
There are a lot of patches going on, a lot of things.

00:20:37.200 --> 00:20:40.340
It's not something I expect new
users to understand right away.

00:20:40.339 --> 00:20:42.419
But for those of you who've been around for a while,

00:20:42.420 --> 00:20:47.130
you probably can get a gist of
what's going just by opening it up.

00:20:47.130 --> 00:20:52.760
And you can see that it's live--
it's completely live in the editor.

00:20:52.759 --> 00:20:57.980
That means that when we are prototyping this welcome
sheet, we were able to play with it and all of that stuff.

00:20:57.980 --> 00:21:02.960
And then we skip the phase between prototyping and
deployment because the prototype is the deployment.

00:21:02.960 --> 00:21:10.029
So one of the things you do when
you're prototyping is you try to figure

00:21:10.029 --> 00:21:12.470
out the performance in the performance bottlenecks.

00:21:12.470 --> 00:21:18.029
And we wanted to make sure that what was
rendering onscreen is as small as possible.

00:21:18.029 --> 00:21:24.930
So in the debug feature of this
viewer, there's a little bug here

00:21:24.930 --> 00:21:29.330
and that will turn on the performance painting attribute.

00:21:29.329 --> 00:21:36.490
And that will allow us to paint a red square, not
only on these patches and see when they're executing

00:21:36.490 --> 00:21:41.349
in the workspace but also in this viewer.

00:21:41.349 --> 00:21:45.039
Now you notice that these patches are executing every frame,

00:21:45.039 --> 00:21:47.500
that's only because it's checking
whether it needs to execute.

00:21:47.500 --> 00:21:49.250
It's not actually doing anything.

00:21:49.250 --> 00:21:53.490
So patches down here like this, they're not
executing because they've already discovered

00:21:53.490 --> 00:22:01.349
that this renderer is-- has declined
an update for this frame.

00:22:01.349 --> 00:22:04.579
Let's go ahead and close that so you guys don't get sick.

00:22:04.579 --> 00:22:08.460
And I said that we're going to paint
red squares over the areas in the viewer

00:22:08.460 --> 00:22:11.470
that have been updated but there's
nothing in red squares here.

00:22:11.470 --> 00:22:14.360
That's because we have 0 FES.

00:22:14.359 --> 00:22:15.619
Nothing is updating.

00:22:15.619 --> 00:22:18.309
And this composition is completely idle.

00:22:18.309 --> 00:22:27.740
But if we go to an animating composite-- animating template,
you can see the red square painted over these clouds.

00:22:27.740 --> 00:22:31.500
So that's how we know that all
the buttons don't need to change,

00:22:31.500 --> 00:22:35.950
only this little square needs to change in the viewer.

00:22:35.950 --> 00:22:43.480
We're also using this implementation of finding what
needs to update on a screen for our interaction model.

00:22:43.480 --> 00:22:47.630
So we know when-- what area the renderers on screen take up.

00:22:47.630 --> 00:22:53.180
So this allows us to do interaction with
3D objects, interaction with 2D objects,

00:22:53.180 --> 00:22:56.009
and pretty much anything that renders on screen.

00:22:56.009 --> 00:23:00.819
[ Noise ]

00:23:00.819 --> 00:23:03.109
>> We also worked on a bunch of other performance things.

00:23:03.109 --> 00:23:12.009
This is Snow Leopard, so it's a better, faster, lighter cat
and we have a whole bunch of other performance improvements.

00:23:12.009 --> 00:23:16.190
Movie playback is faster because
we're using the latest QT APIs.

00:23:16.190 --> 00:23:18.710
QT, meaning QuickTime, obviously.

00:23:18.710 --> 00:23:25.670
Iteration is much faster because we're minimizing
state changes between each iteration of the iterator.

00:23:25.670 --> 00:23:28.460
We are much faster under garbage collection.

00:23:28.460 --> 00:23:33.390
And I know many of you graphics
programmers may cringe at the thought

00:23:33.390 --> 00:23:35.650
of garbage collection in a rendering application.

00:23:35.650 --> 00:23:38.420
But this is important for your screensavers, for example.

00:23:38.420 --> 00:23:44.210
Because they switched over to garbage collection in
screensavers, so your compositions are going to run,

00:23:44.210 --> 00:23:49.509
actually, faster than they did on Leopard even
though garbage collection has been turned on.

00:23:49.509 --> 00:23:51.869
We have better support for multiple GPUs.

00:23:51.869 --> 00:23:58.129
This is the common scenario where you drag
a composition from one display to another.

00:23:58.130 --> 00:24:00.790
And we're using FBOs all over the place.

00:24:00.789 --> 00:24:02.579
And FBOs means Frame Buffer Object.

00:24:02.579 --> 00:24:09.210
And these are vastly superior to Pixel Buffer
Objects because Frame Buffer Objects are on the GPU.

00:24:09.210 --> 00:24:14.829
This is especially important for your render an image
compositions because those will run much faster.

00:24:14.829 --> 00:24:21.589
And JavaScript has been made faster by us in
addition to the WebKit performance improvements

00:24:21.589 --> 00:24:23.779
that have been made in the Snow Leopard timeframe.

00:24:23.779 --> 00:24:29.009
So that concludes my section of the Quartz Composer talk.

00:24:29.009 --> 00:24:34.629
I want to challenge you again to go out there and open up
the editor, play around with it, and have a lot of fun.

00:24:34.630 --> 00:24:40.310
But now I'm going to invite Alessandro up to talk
about some of the great new improvements we've made

00:24:40.309 --> 00:24:43.009
on these two very important technologies.

00:24:43.009 --> 00:24:48.539
[ Applause ]

00:24:48.539 --> 00:24:49.529
>> Alright, thank you Troy.

00:24:49.529 --> 00:24:52.750
Again, my name is Alessandro Sabatelli,
and I'm an Artist here at Apple.

00:24:52.750 --> 00:24:59.720
And it is both an honor and a privilege to get to
talk you about OpenCL on the geometry pipeline.

00:24:59.720 --> 00:25:04.589
So OpenCL, many of you are probably
familiar with OpenCL at this point.

00:25:04.589 --> 00:25:10.019
But if you're not, it's a technology which is really
suited towards processing large amounts of data.

00:25:10.019 --> 00:25:14.279
So being that we are a graphics technology, this
is going to be things like geometry components.

00:25:14.279 --> 00:25:20.389
So vertices, normals, indices, colors, et cetera.

00:25:20.390 --> 00:25:22.530
This also means components of images.

00:25:22.529 --> 00:25:24.849
So things like pixels.

00:25:24.849 --> 00:25:28.750
Though where it really starts to shine,
particularly inside of Quartz Composer,

00:25:28.750 --> 00:25:33.549
is for the processing of arbitrary types of data.

00:25:33.549 --> 00:25:39.710
So previously within Quartz Composer, if you wanted to
process generic data, this would be done using JavaScript.

00:25:39.710 --> 00:25:45.610
Or if you were writing Objective-C plug-ins, they'd be
using your plug-ins, or of course you can process them

00:25:45.609 --> 00:25:50.109
within your applications and then
pipe that into Quartz Composer.

00:25:50.109 --> 00:25:56.219
But if you're processing, say, 2 million items
per frame, none of these would have suited.

00:25:56.220 --> 00:25:59.000
And that's again where OpenCL really starts to shine.

00:25:59.000 --> 00:26:08.789
So as a practical example of arbitrary data processing
within Quartz Composer using OpenCL, we have the app wall.

00:26:08.789 --> 00:26:13.809
So I'm sure many of you have already
seen it, downstairs on the second floor.

00:26:13.809 --> 00:26:17.849
So in this case we're using Quartz
Composer to render out all of the apps.

00:26:17.849 --> 00:26:21.369
But we're using OpenCL to do all
of our generic data processing.

00:26:21.369 --> 00:26:27.049
So OpenCL is doing the heavy lifting in this
composition by generating an animation time or literally

00:26:27.049 --> 00:26:29.799
for each of one of these 20,000 elements.

00:26:29.799 --> 00:26:34.409
And then of course, we use traditional
or typical Quartz Composer methodologies

00:26:34.410 --> 00:26:38.769
or paradigms for drawing the actual icons.

00:26:38.769 --> 00:26:45.849
And that really allowed us to split up the work and
leverage everybody's talents that worked on the project.

00:26:45.849 --> 00:26:52.309
So being that this is the last session of the day,
we figured we'd show you guys a bunch of demos.

00:26:52.309 --> 00:26:54.089
And these demos are going to show
you some of the other things

00:26:54.089 --> 00:26:58.009
that you can do with OpenCL inside of Quartz Composer.

00:26:58.009 --> 00:27:12.650
[ Pause ]

00:27:12.650 --> 00:27:14.700
>> All right.

00:27:14.700 --> 00:27:19.870
So this first example, you can clearly say, says
Quartz Composer and OpenCL, oops, [laughter] or not.

00:27:19.869 --> 00:27:22.669
How 'bout now?

00:27:22.670 --> 00:27:26.810
OK. So perhaps it's a little bit clearer this time.

00:27:26.809 --> 00:27:31.500
But there's also a little note that I left
for myself at the bottom, says press Space.

00:27:31.500 --> 00:27:36.440
And this is an example of a Virtual Macro that we've
included in the patch library, it's called "Instructions."

00:27:36.440 --> 00:27:41.340
And you'll see it time and time again within
many of the examples that we've included.

00:27:41.339 --> 00:27:45.500
And it's just nice and we're starting
to homogenize these things

00:27:45.500 --> 00:27:48.910
and we encourage you to use it within your own examples.

00:27:48.910 --> 00:27:53.240
So in this case, if I do press Space, you'll start

00:27:53.240 --> 00:27:58.170
to see some crazy psychedelic smoke
[laughs] up here all over the screen.

00:27:58.170 --> 00:28:05.160
And this is using OpenCL to do a computational fluid
dynamics simulation employing the Navier-Stokes equations.

00:28:05.160 --> 00:28:15.340
So what's happening here is we have the text, Quartz
Composer OpenCL which is overlaid on top of some other text

00:28:15.339 --> 00:28:21.539
where when I hold down the Space button,
the alpha becomes 1 and the text is seeded

00:28:21.539 --> 00:28:26.049
into a set of kernels that are doing this CFD.

00:28:26.049 --> 00:28:28.940
The color is random per frame.

00:28:28.940 --> 00:28:33.910
And we're interpreting the color as the
direction in which to push the smoke over time.

00:28:33.910 --> 00:28:35.370
So if it's red, it's going to right.

00:28:35.369 --> 00:28:39.239
If it's greenish blue, it's going to go down.

00:28:39.240 --> 00:28:44.259
So the best part about this demo, for me
in particular, besides all the crazy colors

00:28:44.259 --> 00:28:51.119
and the fun you can have just holding down the spacebar
[laughter], is the fact that you don't even have to care

00:28:51.119 --> 00:28:55.899
about the fact that these are Navier-Stokes
equations or this is computational fluid dynamics.

00:28:55.900 --> 00:28:59.470
We've included this as a Virtual Macro, it's
called 2D Smoke, within the patch library.

00:28:59.470 --> 00:29:03.829
So if you want to add smoke to your compositions
it's pretty much as easy as searching for it

00:29:03.829 --> 00:29:07.169
in the patch library and adding it to your composition.

00:29:07.170 --> 00:29:14.420
Although we of course encourage you to then go in and
edit if you are so inclined and play around with the CFD.

00:29:14.420 --> 00:29:18.009
Perhaps you can make it even cooler
and share it with the rest.

00:29:18.009 --> 00:29:26.629
[ Pause ]

00:29:26.630 --> 00:29:31.010
>> So this next example clearly says "snow."

00:29:31.009 --> 00:29:34.269
[ Pause ]

00:29:34.269 --> 00:29:37.529
[ Applause ]

00:29:37.529 --> 00:29:42.920
>> So, we're doing here is we're using OpenCL to
process, again, these arbitrary types of data.

00:29:42.920 --> 00:29:44.810
In this case, these are particle positions.

00:29:44.809 --> 00:29:47.029
It's a very simple particle simulation.

00:29:47.029 --> 00:29:51.799
What we're doing here is we're generating a bunch of
random points at the top of the screen and we're doing

00:29:51.799 --> 00:29:54.509
that using JavaScript, because
JavaScript does this awesome function

00:29:54.509 --> 00:29:57.000
that you guys have probably heard of, called "Random."

00:29:57.000 --> 00:30:03.220
[Laughter] And basically, every frame, we have the
snow kind of just drifting down little by little.

00:30:03.220 --> 00:30:07.670
What's really nice here aside from the fact that we
can use JavaScript and all these other technologies,

00:30:07.670 --> 00:30:12.539
is that I'm also integrating an
image into the OpenCL calculation.

00:30:12.539 --> 00:30:21.720
>> So at every frame, I check to see if the pixel underneath
the snow happens to have an alpha of 0, in this case.

00:30:21.720 --> 00:30:24.220
So you'll see it's black and we're drawing the word snow.

00:30:24.220 --> 00:30:28.160
And if its does-- and literarily
just 0 out that velocity vector

00:30:28.160 --> 00:30:31.980
so that the next time it comes back
through the simulation, it won't move.

00:30:31.980 --> 00:30:34.779
And as a result, it accumulates on the top of the letters.

00:30:34.779 --> 00:30:39.819
So I'm sure you can imagine the wind blowing, maybe the snow
moving, but again, this is just a really simple example.

00:30:39.819 --> 00:30:41.029
It's been posted online.

00:30:41.029 --> 00:30:46.000
You guys can start playing with particle
systems inside of OpenCL and Quartz Composer.

00:30:46.000 --> 00:31:01.609
[ Pause ]

00:31:01.609 --> 00:31:08.449
>> All right, so this next example shows us
some procedural geometry creation using OpenCL.

00:31:08.450 --> 00:31:14.740
You'll see on your left, at the top left
hand corner of the screen, it says "bonjour."

00:31:14.740 --> 00:31:18.690
And what we were doing is we're taking that
image, feeding that into an OpenCL kernel.

00:31:18.690 --> 00:31:27.600
For each pixel, we're generating a vertex, and the vertices'
color is based on the pixel color of that input image.

00:31:27.599 --> 00:31:32.629
So for instance, in the image at the top
left, it's black, so that's an alpha of 0.

00:31:32.630 --> 00:31:37.750
And where it's white, we're also
adjusting, say, the Z-depth.

00:31:37.750 --> 00:31:41.059
So you get this 3D text that kind of sticks out.

00:31:41.059 --> 00:31:46.089
So generally, this is probably not how you'd
want to create 3D text because it's overkill.

00:31:46.089 --> 00:31:53.109
I don't know-- I don't even know how many vertices we have
here, but it's probably 200,000 or something like that.

00:31:53.109 --> 00:31:54.779
Of course, this is all live.

00:31:54.779 --> 00:32:00.910
So we can type, say "hello," you'll see it's pretty fast.

00:32:02.240 --> 00:32:08.680
The best part about this is, because the source is an
image, we can actually go in and use the typical, say,

00:32:08.680 --> 00:32:14.710
image processing using Core Image to affect that
input image and have the result be interpreted

00:32:14.710 --> 00:32:18.309
by the OpenCL kernel to create our geometry.

00:32:18.309 --> 00:32:22.730
So here we have a crystallize filter.

00:32:22.730 --> 00:32:29.000
I can blur that out to kind of melt it.

00:32:29.000 --> 00:32:32.359
[ Pause ]

00:32:32.359 --> 00:32:35.719
[ Applause ]

00:32:35.720 --> 00:32:38.549
>> This is actually quite a bit of fun [laughter].

00:32:38.549 --> 00:32:42.289
Here we have a kaleidoscope filter.

00:32:42.289 --> 00:32:53.609
If we can blur that out, and of course, you know, I mean you
can just chain together your Core Image filters, whatever.

00:32:53.609 --> 00:32:55.990
I mean, really the point here of this demo is the fact

00:32:55.990 --> 00:32:59.690
that Quartz Composer brings together all
these different technologies and allows you

00:32:59.690 --> 00:33:03.360
to play with them and work with them together.

00:33:03.359 --> 00:33:07.829
So here, we have-- here's a zoom blur.

00:33:07.829 --> 00:33:14.599
So it can actually move the zoom blur overtime.

00:33:14.599 --> 00:33:23.789
This one's pretty cool, this is the up tile.

00:33:23.789 --> 00:33:28.930
So again, the point here is that we're bringing
together all these different technologies.

00:33:31.289 --> 00:33:37.579
All right, so how do you actually go about
working with OpenCL inside a Quartz Composer?

00:33:39.089 --> 00:33:46.250
We showed you a little bit of that last year, but this
time I'm going to show you through the mesh filter.

00:33:47.660 --> 00:33:49.810
So create a new composition.

00:33:49.809 --> 00:33:52.679
And here you have the mesh filter template.

00:33:52.680 --> 00:33:55.779
It's a new protocol within Snow Leopard.

00:33:55.779 --> 00:34:00.509
Again, the protocol is just really being a contract
between your composition and whoever is using it.

00:34:00.509 --> 00:34:04.819
So in this case, the mesh filter says
I take a mesh in and I output a mesh.

00:34:04.819 --> 00:34:07.829
Of course, you can have any other inputs and
either outputs, but as long as you have a mesh

00:34:07.829 --> 00:34:10.849
in and a mesh out, you have a mesh filter.

00:34:10.849 --> 00:34:20.339
And you can see here, we have this kind of sphere
and it's being undulated in a sinusoidal fashion.

00:34:20.340 --> 00:34:26.910
So here we have our sphere.

00:34:26.909 --> 00:34:33.179
Here is our OpenCL kernel, which is
dynamically named "sine-wave," it's in quotes.

00:34:33.179 --> 00:34:37.419
Of course you have the typical Quartz Composer interaction.

00:34:37.420 --> 00:34:39.900
So I can-- I have a bunch of published parameters.

00:34:39.900 --> 00:34:41.809
I can change those live.

00:34:41.809 --> 00:34:46.989
We take a look at the actual kernel.

00:34:46.989 --> 00:34:52.519
[ Pause ]

00:34:52.519 --> 00:34:54.809
>> It's pretty straightforward.

00:34:54.809 --> 00:35:01.769
We're getting the index, which happens to
be the vertex, or the ID of the vertex.

00:35:01.769 --> 00:35:03.130
So here, we actually get the vertex.

00:35:03.130 --> 00:35:11.260
And then we're affecting the vertex's Y position
based on the sign of the vertex's X position.

00:35:11.260 --> 00:35:15.730
So as it goes across an X, you'll
get the sinusoidal motion in Y.

00:35:15.730 --> 00:35:21.119
And again, the thing that's really cool about this
is that you can go ahead and change the function,

00:35:21.119 --> 00:35:22.469
you can change whatever you want in the kernel.

00:35:22.469 --> 00:35:28.489
We'll go ahead and compile that in the
background and update it live for you.

00:35:28.489 --> 00:35:30.979
So does anybody have a favorite trig function?

00:35:30.980 --> 00:35:31.050
[ Laughs ]

00:35:31.050 --> 00:35:31.120
[ Inaudible Remark ]

00:35:31.119 --> 00:35:31.409
>> Yeah, 10?

00:35:31.409 --> 00:35:31.649
[ Laughs ]

00:35:31.650 --> 00:35:31.889
[ Inaudible Remark ]

00:35:31.889 --> 00:35:41.000
>> So here's the 10 function [laughter],
notice the infinity [laughter].

00:35:41.000 --> 00:35:46.380
So you get the idea.

00:35:46.380 --> 00:35:52.980
So it makes it really to just focus on your kernel
and not really have to worry about anything else.

00:35:52.980 --> 00:36:04.039
[ Pause ]

00:36:04.039 --> 00:36:07.090
>> So we took a look at the OpenCL kernel.

00:36:07.090 --> 00:36:08.059
It's really easy.

00:36:08.059 --> 00:36:09.929
You just drop it into your composition.

00:36:09.929 --> 00:36:13.949
And again, it allows you to focus on writing the kernel.

00:36:13.949 --> 00:36:15.869
We do a bunch of things for you automatically.

00:36:15.869 --> 00:36:20.489
So we deal with things like resource management, o you
don't have to worry about memory and stuff like that.

00:36:20.489 --> 00:36:23.979
We also do a bunch of caching, so you
don't have to worry about any of that.

00:36:23.980 --> 00:36:29.730
[ Pause ]

00:36:29.730 --> 00:36:34.010
>> We also have a bunch of heuristics that
are built into the OpenCL kernel patch

00:36:34.010 --> 00:36:40.450
which automatically configure the kernel based
on the data coming in and the kernel itself.

00:36:40.449 --> 00:36:42.799
So typically, you'd have to do these things manually.

00:36:42.800 --> 00:36:47.530
And we actually allow you to override
these automatic settings.

00:36:47.530 --> 00:36:50.630
There's an advanced settings within the kernel patch.

00:36:50.630 --> 00:36:55.269
And also worth noting within the advanced settings,
we have some metrics, so you can sample the time

00:36:55.269 --> 00:36:57.659
that the kernel is actually taking to execute.

00:36:57.659 --> 00:37:00.250
So you can evaluate performance and things like that.

00:37:00.250 --> 00:37:03.550
And the times when you'd want to
override this and set these manually are

00:37:03.550 --> 00:37:07.090
when the data coming into your kernel is of different sizes.

00:37:07.090 --> 00:37:10.130
So if you had, say, a bunch of different
arrays, one of them is half the size

00:37:10.130 --> 00:37:12.570
of the other one, you'd want to configure this manually.

00:37:12.570 --> 00:37:17.019
We also deal with outline transformations, color
space if you have images coming into your kernel,

00:37:17.019 --> 00:37:20.250
you don't have to worry about any of that.

00:37:20.250 --> 00:37:24.809
So if you wanted to integrate OpenCL into your application,
there's a couple of different ways you can do that.

00:37:24.809 --> 00:37:27.809
So of course, you can do it from scratch.

00:37:27.809 --> 00:37:30.659
And there's quite a bit of things
that you're going to need to do that.

00:37:30.659 --> 00:37:36.059
I encourage you to go to the OpenCL sessions tomorrow
if you're interested in doing that from scratch.

00:37:36.059 --> 00:37:41.039
But as an alternative, if you built your kernel within
Quartz Composer, it's a great first to prototype it.

00:37:41.039 --> 00:37:46.949
You can actually also deploy your composition
within your application simply by--

00:37:46.949 --> 00:37:49.449
you have it wrapping your kernel within a composition.

00:37:49.449 --> 00:37:51.809
So you have a kernel, it's in a composition.

00:37:51.809 --> 00:37:58.150
You have a published input, a published output, you
use the QC render API to execute that, say, once.

00:37:58.150 --> 00:38:00.820
Get the data from the output port,
and you're pretty much good to go.

00:38:00.820 --> 00:38:04.570
And of course, you can keep it on
whatever device you're working on.

00:38:04.570 --> 00:38:10.059
So if you're on a GPU, you can keep it there.

00:38:10.059 --> 00:38:13.909
All right, so next, I will talk a
little bit about the geometry pipeline.

00:38:13.909 --> 00:38:16.549
And for me, this is something I'm really excited about.

00:38:16.550 --> 00:38:19.420
This is in many ways why I came to work at Apple.

00:38:19.420 --> 00:38:22.820
And finally, we have a geometry
pipeline within Quartz Composer.

00:38:22.820 --> 00:38:29.610
And the geometry pipeline allows you to import
3D geometry, create procedural geometry,

00:38:29.610 --> 00:38:32.180
it also give you accessors to the components.

00:38:32.179 --> 00:38:35.440
So again, the components being things
like vertices, indices, et cetera.

00:38:35.440 --> 00:38:45.639
We also do things to say, make working with geometry in
Quartz Composer expect-- or behave as you just expect it to.

00:38:45.639 --> 00:38:54.519
So for instance, if you were to transform your geometry, if
you had an OpenCL kernel that was processing that geometry,

00:38:54.519 --> 00:38:59.809
if you were transforming your geometry on the consumer,
that mesh renderer, which is one of these new patches,

00:38:59.809 --> 00:39:05.539
we would update the vertices going into your
kernel such that it reflects that transformation.

00:39:05.539 --> 00:39:07.719
So these are things that you just kind of expect to happen.

00:39:07.719 --> 00:39:12.230
And these are really what makes it a
pipeline and not just, say, geometry import.

00:39:12.230 --> 00:39:18.409
Also if you were to hover over a mesh port, you're going
to see a quick little preview of what that mesh looks like.

00:39:18.409 --> 00:39:23.420
So here's our wind tunnel, and we're using
again the 2D smoke that we showed you before.

00:39:23.420 --> 00:39:25.440
But in this case, we've enhanced it a little bit.

00:39:25.440 --> 00:39:27.420
We've added some different advection at the end.

00:39:27.420 --> 00:39:34.369
So you can see it kind of swirling around back
behind the car there, and the car is fully 3D.

00:39:34.369 --> 00:39:36.980
So we can transform the camera, et cetera.

00:39:36.980 --> 00:39:41.099
[ Pause ]

00:39:41.099 --> 00:39:45.219
[ Applause ]

00:39:45.219 --> 00:39:49.980
>> But for me, what's really nice is that the
geometry fully integrates into Quartz Composer.

00:39:49.980 --> 00:40:00.760
In this case, we can use, oops [laughter], we can
use OpenCL to actually transform that geometry

00:40:00.760 --> 00:40:09.980
and we can see those changes updated live, hopefully.

00:40:09.980 --> 00:40:17.760
[ Pause ]

00:40:17.760 --> 00:40:19.980
>> Let's try that again.

00:40:19.980 --> 00:40:30.679
[ Pause ]

00:40:30.679 --> 00:40:35.539
>> So maybe not as fast on this machine but
you'll notice that we're running on a laptop.

00:40:35.539 --> 00:40:37.210
It's pretty impressive.

00:40:38.500 --> 00:40:46.460
And so I can do things like deform the car, and
you'll see that the smoke adjusts automatically.

00:40:46.460 --> 00:40:50.980
So maybe not prettier than the
original design, but you get the idea.

00:40:50.980 --> 00:40:58.480
[ Applause ]

00:40:58.480 --> 00:41:20.889
[ Pause ]

00:41:20.889 --> 00:41:26.969
>> So this next example we're showing you a bunch of mesh
filters that we've included in the composition repository

00:41:26.969 --> 00:41:30.079
for you guys to use and leverage
within your own applications.

00:41:30.079 --> 00:41:37.969
So in this case, we have a mesh twist so we're taking that
3D imported geometry and twisting it along the X axis.

00:41:39.190 --> 00:41:42.170
One thing I failed to mention was
that we've also included shadows.

00:41:42.170 --> 00:41:49.800
So our lighting patch now has a toggle per light so you can
have multiple lights and you can enable or disable shadows

00:41:49.800 --> 00:41:54.830
on a per light basis, you can control the
colors of the shadows, the quality, et cetera.

00:41:54.829 --> 00:41:59.549
And this is really important for 3D geometry because
it allows you to see the relief of the geometry

00:41:59.550 --> 00:42:02.740
and actually get a sense of the fact that it is 3D.

00:42:02.739 --> 00:42:05.119
So in this case I have shadows.

00:42:05.119 --> 00:42:08.829
I also have just a very simple GLSL
shader to do per pixel lighting.

00:42:08.829 --> 00:42:13.989
Here, we have a bend filter.

00:42:15.780 --> 00:42:18.240
So you can imagine text bending around objects.

00:42:18.239 --> 00:42:18.979
Or--

00:42:18.980 --> 00:42:24.320
[ Pause ]

00:42:24.320 --> 00:42:30.630
>> -- in this case, here we have
a wave, wave is kind of fun.

00:42:30.630 --> 00:42:36.980
So if you wanted to do 3D ripples, the bulge.

00:42:36.980 --> 00:42:44.990
[ Pause ]

00:42:44.989 --> 00:42:46.069
>> Oh, this one is great.

00:42:46.070 --> 00:42:47.269
This is a jiggle.

00:42:47.269 --> 00:42:49.940
So the jiggle is a temporal filter.

00:42:49.940 --> 00:42:56.490
We showed you a little bit about how the
geometry, or actually how OpenCL worked last year.

00:42:56.489 --> 00:43:04.559
So in this case, we are taking the geometry and we're using
literally our queue p atch in queuing that geometry overtime

00:43:04.559 --> 00:43:11.779
and then selecting from that queue based on the distance
from, say, the point on screen that I'm grabbing on.

00:43:11.780 --> 00:43:15.590
So you get this kind of jiggly text.

00:43:15.590 --> 00:43:19.980
So you can imagine text kind of
flying in or bouncing on the ground.

00:43:19.980 --> 00:43:23.730
[ Laughter ]

00:43:23.730 --> 00:43:27.480
[ Applause ]

00:43:27.480 --> 00:43:35.139
[ Pause ]

00:43:35.139 --> 00:43:39.679
>> And then we've also included Perlin noise, which many
of you are probably familiar with in some form or another.

00:43:39.679 --> 00:43:45.460
It's just a basic graphic primitive that allows you
then build more complicated and interesting effects.

00:43:45.460 --> 00:43:51.690
So here, we're just looking at the
raw output of the Perlin noise filter.

00:43:51.690 --> 00:43:56.420
So another thing that makes this a pipeline is the fact

00:43:56.420 --> 00:44:01.329
that you can take these OpenCL
kernels and, say, chain them together.

00:44:01.329 --> 00:44:04.599
And this is very similar to our image processing pipeline.

00:44:04.599 --> 00:44:08.789
So typically, if you're working in Core
Image you building up complicated effects

00:44:08.789 --> 00:44:11.980
by chaining together different Core
Image filters or writing your own.

00:44:11.980 --> 00:44:15.980
And you can do the same thing using
OpenCL within the geometry pipeline.

00:44:15.980 --> 00:44:23.380
[ Pause ]

00:44:23.380 --> 00:44:28.500
>> So here I have my set of mesh filters
and we're looking at the mesh twist.

00:44:28.500 --> 00:44:34.909
So I can, say, plug the output of
the mesh bend into the mesh twist.

00:44:34.909 --> 00:44:38.980
And now we have a mesh bend and twist.

00:44:38.980 --> 00:44:45.740
[ Pause ]

00:44:45.739 --> 00:44:47.209
>> And you can do this all day.

00:44:47.210 --> 00:44:49.840
You can, say, [laughter ]

00:44:49.840 --> 00:44:53.500
plug the wave into the bend.

00:44:53.500 --> 00:44:57.550
Wave, bend, twist, or twist, bend, wave [laughter].

00:44:57.550 --> 00:45:06.140
How about a bulge, bulge, wave, twist, bend, bulge.

00:45:06.139 --> 00:45:11.619
You get the idea and it's still pretty performing.

00:45:11.619 --> 00:45:12.849
And again, this is the laptop.

00:45:12.849 --> 00:45:14.110
[ Applause ]

00:45:14.110 --> 00:45:22.670
>> All right, this next example I'll say more
practical application of applying mesh filters.

00:45:22.670 --> 00:45:26.590
So here we have a PDF document.

00:45:26.590 --> 00:45:35.550
I have a 3D spine on the left hand side, and this is,
I think it's the image filter tutorial for Core Image,

00:45:35.550 --> 00:45:40.539
and I've added some-- some shadowing on the
ground and also some interaction which allows me

00:45:40.539 --> 00:45:44.610
to grab the individual pages and turn them.

00:45:44.610 --> 00:45:45.480
[ Laughter ]

00:45:45.480 --> 00:45:51.980
[ Applause ]

00:45:51.980 --> 00:45:58.250
[ Pause ]

00:45:58.250 --> 00:46:01.730
>> And so what you're seeing here is 2 mesh filters.

00:46:01.730 --> 00:46:06.449
This is the mesh bend which is giving us the
page curl and that's coupled with the mesh jiggle

00:46:06.449 --> 00:46:10.980
so that gives us that kind of nice physical reaction.

00:46:10.980 --> 00:46:25.119
[ Pause ]

00:46:25.119 --> 00:46:26.980
>> Let's see maybe one more time.

00:46:26.980 --> 00:46:34.190
[ Pause ]

00:46:34.190 --> 00:46:34.420
>> Oh, well.

00:46:34.420 --> 00:46:37.570
All right.

00:46:38.980 --> 00:46:52.059
[ Pause ]

00:46:52.059 --> 00:46:52.440
>> OK.

00:46:52.440 --> 00:46:52.730
[ Laughter ]

00:46:52.730 --> 00:46:54.409
>> All right.

00:46:56.980 --> 00:47:06.210
[ Pause ]

00:47:06.210 --> 00:47:12.389
>> So we took a look a little bit, a look at
OpenCL and the geometry pipeline that you can see

00:47:12.389 --> 00:47:16.029
that they work really well together
and they work hand-in-hand.

00:47:16.030 --> 00:47:21.740
We took a little look at geometry import and
creation, so you saw some geometry there,

00:47:21.739 --> 00:47:25.319
and some procedurally generated geometry.

00:47:25.320 --> 00:47:32.680
We took a look at what's it like to work inside the OpenCL
Kernel Patch and that's used for geometry processing,

00:47:32.679 --> 00:47:35.639
image processing, so for instance,
when we're looking at the snow image,

00:47:35.639 --> 00:47:39.889
determining that the alpha was zero
and killing our velocity vectors.

00:47:39.889 --> 00:47:46.159
We took a look at generic data processing as
well for our particle system, rendering geometry,

00:47:46.159 --> 00:47:48.969
so in this case you can render your geometry.

00:47:48.969 --> 00:47:55.929
We also have the ability to display that geometry
in wire frame point sprites, also volume rendering.

00:47:55.929 --> 00:48:00.569
Also worth noting is that we do automatic
conversions for you, and this again is something

00:48:00.570 --> 00:48:04.059
that makes it really a full-fledged pipeline.

00:48:04.059 --> 00:48:10.769
So what this means is, for instance, if you had an array of
float 3s, we would automatically convert that to an array

00:48:10.769 --> 00:48:13.920
of float 4s if your kernel required an array of float 4s.

00:48:13.920 --> 00:48:20.380
And we actually do this using Quartz Composer in the way
that I described earlier with regards to the QCRender API.

00:48:20.380 --> 00:48:23.260
So we have literally a composition that contains a kernel.

00:48:23.260 --> 00:48:30.470
The input to the kernel is these float
arrays and then we output the float 4 arrays.

00:48:30.469 --> 00:48:33.109
We also do that for, say, color.

00:48:33.110 --> 00:48:38.120
So for instance if you were to change the color on the
mesh render, you'd expect the mesh to change color.

00:48:38.119 --> 00:48:43.170
And the way that we do that is again we literally
have the composition which contains a kernel

00:48:43.170 --> 00:48:47.059
and in that kernel we've literally just
multiplied the color for each vector--

00:48:47.059 --> 00:48:49.759
for each vertex by the color that you've specified.

00:48:49.760 --> 00:48:52.470
As a result, the mesh changes color.

00:48:52.469 --> 00:48:56.769
So you'd expect this maybe this wouldn't be
fast, but in reality it's quite performing.

00:48:56.769 --> 00:49:02.969
So of course we have other things that we've added.

00:49:02.969 --> 00:49:06.879
I've mentioned interaction which we
showed you a little bit last year.

00:49:06.880 --> 00:49:09.720
And again, you saw it in the page curl demo.

00:49:09.719 --> 00:49:17.829
The inertia and force physics, which is key to that jiggle
mesh filter, I encourage you to go in and check it out.

00:49:17.829 --> 00:49:25.539
We've added Multi-Touch trackpad supports so you can do
things like pinch, to zoom, swipe, rotate, et cetera.

00:49:25.539 --> 00:49:30.529
We also now have a new 3D Sound Player patch which
is pretty awesome, so you can add little sounds

00:49:30.530 --> 00:49:34.050
to your compositions and really start bringing them to life.

00:49:34.050 --> 00:49:38.470
This of course works within the iterator as
well so you can make all kinds of crazy things.

00:49:38.469 --> 00:49:43.759
We have new controls for the Movie Player patch, so
Troy talked a little bit about performance enhancements

00:49:43.760 --> 00:49:47.450
of the Movie Player patch, but in this case,
we've made it a little bit more livable

00:49:47.449 --> 00:49:49.769
so you could do things like loop, et cetera.

00:49:49.769 --> 00:49:53.710
And then we've made a bunch of patches iterator aware.

00:49:53.710 --> 00:49:56.340
So, for instance, your smooth patch, your counter patch,

00:49:56.340 --> 00:50:03.150
anything that has stayed now will
work properly within the iterator.

00:50:03.150 --> 00:50:06.150
So for more information, you can
of course contact Allan Schaffer.
WEBVTT

00:00:13.179 --> 00:00:14.800
>> My name is Alison Hughes.

00:00:14.800 --> 00:00:20.339
I work in the Multimedia group here at
Apple, and today we're going to be talking

00:00:20.339 --> 00:00:25.089
about designing USB audio devices for the Mac platform.

00:00:25.089 --> 00:00:34.570
All right, so I'm going to start out giving you a high
level summary of what I'm going to be going over today.

00:00:34.570 --> 00:00:40.509
I'm going to start with an introduction, give
you an idea of what our class driver does

00:00:40.509 --> 00:00:44.030
and where it sits in the system architecture.

00:00:44.030 --> 00:00:48.390
Then I'm going to talk about class compliance.

00:00:48.390 --> 00:00:53.670
Now I'm sure you've heard this message before, but for
those of you that are still on the fence of whether

00:00:53.670 --> 00:00:57.090
or not you should go class compliant with
your device, I'm going give you a lot

00:00:57.090 --> 00:00:59.840
of good reasons why you should go that way.

00:00:59.840 --> 00:01:07.840
Then, for the bulk of my talk, I'm going to be giving
you some tips for -- tips and tricks -- to get --

00:01:07.840 --> 00:01:13.700
so you can design your device to
work seamlessly with Snow Leopard.

00:01:13.700 --> 00:01:22.620
Then I'm going to finish up with the new 2.0 USB audio
features that we've included in Snow Leopard for all of you

00:01:22.620 --> 00:01:26.579
who are interested in designing
a high speed USB audio device,

00:01:26.579 --> 00:01:33.079
and then we'll finish up with the
conclusion, and I'll open it up to questions.

00:01:33.079 --> 00:01:38.090
So first. What does the driver do?

00:01:38.090 --> 00:01:43.939
Well, our driver, it's called AppleUSBAudio,
we like to call it AUA for short.

00:01:43.939 --> 00:01:51.649
It -- in summary, it represents your device
and its features to the application layer.

00:01:51.650 --> 00:01:58.710
So if you plug in your device, and you launch
AM S, that's Audio MIDI Setup, you'll see it.

00:01:58.709 --> 00:01:59.939
Here is an example.

00:01:59.939 --> 00:02:05.349
It is our Apple display, that is a USB audio device.

00:02:05.349 --> 00:02:09.329
And you can see the volume controls and the mute controls.

00:02:09.330 --> 00:02:19.480
And right now as we always have supported, we've always
supported USB Audio, 1.0 class compliant devices.

00:02:19.479 --> 00:02:25.579
And recently, we've greatly enhanced
our support of USB 2.0 devices.

00:02:25.580 --> 00:02:33.689
Now when I say USB Audio 2.0, I'm referring
to the USB Audio class device specification.

00:02:33.689 --> 00:02:39.389
I'm not talking about the USB 2.0 class specification.

00:02:39.389 --> 00:02:45.349
And I just want to say that up front, because even
among some Apple folks we have some confusion sometimes

00:02:45.349 --> 00:02:47.030
when we're talking.

00:02:47.030 --> 00:02:49.289
So what does our driver not support?

00:02:49.289 --> 00:02:54.639
It does not support what we call Frankenstein devices.

00:02:54.639 --> 00:03:01.459
So if you've been a previous conference, you've
heard my predecessor refer to high speed devices

00:03:01.460 --> 00:03:06.510
with 1.0 USB Audio descriptors as Frankenstein.

00:03:06.509 --> 00:03:08.090
Now we don't support these.

00:03:08.090 --> 00:03:14.090
You might plug in your Frankenstein device, it
might work now, but that's just a coincidence, okay?

00:03:14.090 --> 00:03:20.979
So for the long term you want to make sure that you go
ahead and write 2.0 descriptors for your high speed devices.

00:03:20.979 --> 00:03:26.079
So, those are the basics.

00:03:26.080 --> 00:03:27.250
What our driver does.

00:03:27.250 --> 00:03:32.430
Now how does AUA fit in the larger system architecture.

00:03:32.430 --> 00:03:39.270
I provided a diagram for you here of what
the audio stack looks like in Mac OS X.

00:03:39.270 --> 00:03:47.640
Our driver is an I/O Kit device driver, it sits in
the kernel, and it talks to your USB Audio device

00:03:47.639 --> 00:03:53.059
over USB via the facilities provided by the USB family.

00:03:53.060 --> 00:04:02.800
Also, the high level generic audio device
features are provided by the I/O audio family.

00:04:02.800 --> 00:04:08.820
Those features include support for
maintaining your sample mixed buffers.

00:04:08.819 --> 00:04:17.709
It also includes user clients for
communication between the user space and kernel.

00:04:17.709 --> 00:04:26.209
It also -- above that, you have the Audio HAL, that's
Core Audio, and it represents the device that controls

00:04:26.209 --> 00:04:28.849
and the streams to the application layer.

00:04:28.850 --> 00:04:33.830
Now I have another picture here for you to go
into more detail about what those entities are.

00:04:33.829 --> 00:04:39.889
You have your audio device, and it
may contain one or more engines.

00:04:39.889 --> 00:04:44.039
And each of these engines contain one or more streams.

00:04:44.040 --> 00:04:48.550
Now these are actually not containers,
they're more of associations.

00:04:48.550 --> 00:04:56.920
So just to clarify, the way Core Audio works, it
kind of represents the engines more like devices.

00:04:56.920 --> 00:05:02.900
So when I get into details about naming, I'll let
you know, you know, that you'll name your engine,

00:05:02.899 --> 00:05:06.729
and then in the UI, you'll see the engine name is a device.

00:05:06.730 --> 00:05:08.060
So just to clarify that.

00:05:08.060 --> 00:05:12.850
That can be a little bit confusing.

00:05:12.850 --> 00:05:15.340
So why would you want to go class compliant.

00:05:15.339 --> 00:05:17.099
Now you've heard the message before.

00:05:17.100 --> 00:05:22.939
I know some of you developers out there, you're
worried, you know, if I rely on the class driver,

00:05:22.939 --> 00:05:28.290
what's going to happen when I find a bug and
my device isn't functioning the way it should.

00:05:28.290 --> 00:05:34.879
You also may be concerned about the
overhead in designing the 2.0 descriptors.

00:05:34.879 --> 00:05:37.110
Well, I'm going to address your concerns.

00:05:37.110 --> 00:05:46.420
First of all, I think the most compelling reason to go
class compliant is the reduction in your development costs.

00:05:46.420 --> 00:05:54.740
So consider if you do not go class compliant,
then you're going be maintaining two code bases.

00:05:54.740 --> 00:06:00.460
One code base is your Firmware code
base, the other one will be the driver.

00:06:00.459 --> 00:06:04.839
Now you're going to write a driver
for the current operating system.

00:06:04.839 --> 00:06:12.319
And then when we do a software update, you're going to
have to test that driver, and it may have some issues,

00:06:12.319 --> 00:06:16.000
you'll have to fix them, and then redistribute your driver.

00:06:16.000 --> 00:06:23.660
Now every time we make a change and release a new
OS you'll have to go through the same procedure.

00:06:23.660 --> 00:06:30.439
So as you know, we have a very aggressive release
schedule, so you may be doing this over and over and over.

00:06:30.439 --> 00:06:34.730
And we really think that you should just leave that to us

00:06:34.730 --> 00:06:38.439
and then all you have to worry
about is your device Firmware.

00:06:38.439 --> 00:06:43.660
And anywhere, this is where you should be
focusing, because this is where your expertise is.

00:06:43.660 --> 00:06:48.689
Now what I also would like you to
consider is your total development cost.

00:06:48.689 --> 00:06:52.620
Not just the cost incurred up the to
point where you ship your product,

00:06:52.620 --> 00:06:56.189
but the costs that are incurred after you ship your product.

00:06:56.189 --> 00:06:57.939
Because your product about still be out on the market,

00:06:57.939 --> 00:07:01.290
you'll have customers using it, and
you will still need to support them.

00:07:01.290 --> 00:07:05.080
So you need to factor that in when you make those decisions.

00:07:05.079 --> 00:07:12.289
Additionally, as you know, you know, we
had devices that have been 1.0 devices

00:07:12.290 --> 00:07:14.830
that were working back in the Power PC days.

00:07:14.829 --> 00:07:18.789
Well, when we switched to Intel,
those devices continued to work.

00:07:18.790 --> 00:07:25.560
And now we're making our transition
from 32-bit to 64-bit in Snow Leopard.

00:07:25.560 --> 00:07:27.689
Those companies have to do nothing.

00:07:27.689 --> 00:07:29.829
Their devices continue to work.

00:07:29.829 --> 00:07:34.019
So I think that's a pretty compelling argument right there.

00:07:34.019 --> 00:07:41.870
Secondly, if you use -- if you're a class compliant
device you get to take advantage of plug and play.

00:07:41.870 --> 00:07:47.639
That means when your customers buy your device
they just plug it into the Mac and it just works.

00:07:47.639 --> 00:07:53.199
Now many people who own a Mac, the reason
why they use one is because of this ease

00:07:53.199 --> 00:07:56.289
of use, this very high quality user experience.

00:07:56.290 --> 00:08:00.910
Well, plug and play fits right into that.

00:08:00.910 --> 00:08:04.750
Thirdly, free driver testing.

00:08:04.750 --> 00:08:12.430
So when we maintain the driver, this is what I do every
day, we fix bugs and we test these, we test our driver.

00:08:12.430 --> 00:08:17.959
And every time we do a software update
at least once we'll do a device sweep.

00:08:17.959 --> 00:08:22.639
Now a small device sweep could be
anywhere from 20 to 30 devices,

00:08:22.639 --> 00:08:27.279
and I think our last sweep, we did up to 80 devices.

00:08:27.279 --> 00:08:29.769
So that's a lot of testing.

00:08:29.769 --> 00:08:35.049
We have an excellent test team in my
group, and you know, that's a lot --

00:08:35.049 --> 00:08:42.219
that's a lot of work to test all those features, but we take
a very wide sampling of devices that cover all the features,

00:08:42.220 --> 00:08:45.600
including the more exotic ones, so we get good coverage.

00:08:45.600 --> 00:08:50.139
So I want to take this opportunity to invite
you, especially those that are chip vendors,

00:08:50.139 --> 00:08:53.149
if you have a new device, please send it to us.

00:08:53.149 --> 00:08:54.819
We'd like to take a look at it.

00:08:54.820 --> 00:08:58.100
I'm going to be introducing Michael
Wong at the end of the talk.

00:08:58.100 --> 00:09:05.540
He is our audio relations person, and you know,
just get in contact with us and we'll take a look.

00:09:05.539 --> 00:09:10.289
Now I can't guarantee if you send
us the device that we will test it.

00:09:10.289 --> 00:09:12.279
But I can guarantee you this.

00:09:12.279 --> 00:09:15.449
We are more likely to test it if you send it to us.

00:09:15.450 --> 00:09:20.190
So please do that.

00:09:20.190 --> 00:09:26.020
And also, when you go to write your class
compliant descriptors we have support for you.

00:09:26.019 --> 00:09:28.389
We have a lot of resources.

00:09:28.389 --> 00:09:30.649
First off, USB Prober.

00:09:30.649 --> 00:09:32.709
This is in the developer package.

00:09:32.710 --> 00:09:38.680
This is -- the first thing I do when I get a device that's
been behaving badly, I plug it in and I launch USB Prober.

00:09:38.679 --> 00:09:44.179
We have audio-specific parsing built in so
you can check out your devices in probe --

00:09:44.179 --> 00:09:48.429
check out your descriptors in prober
and see how your descriptors are parsed.

00:09:48.429 --> 00:09:50.549
And that's going to be your first clue.

00:09:50.549 --> 00:09:54.500
The second thing I do is I build
a logging version of our driver.

00:09:54.500 --> 00:09:59.850
Now you can download it, it's open source,
and you can build a USB logging version

00:09:59.850 --> 00:10:04.420
or possibly a fire logging version and look at log messages.

00:10:04.419 --> 00:10:08.360
This is a great way to debug descriptors and other problems.

00:10:08.360 --> 00:10:14.050
Another great resource we have
is Apple Developer Connection,

00:10:14.049 --> 00:10:17.899
and I know that most of you are
already members, so that's great.

00:10:17.899 --> 00:10:23.959
But I highly encourage you to consider upgrading
your membership to the select level or higher.

00:10:23.960 --> 00:10:28.030
Now if you do this then you'll have access to Seeds.

00:10:28.029 --> 00:10:29.689
Very important.

00:10:29.690 --> 00:10:32.730
Because if you have your device and you test it

00:10:32.730 --> 00:10:38.539
with the Seed before we actually release the software
then you can find out if something is going wrong.

00:10:38.539 --> 00:10:44.329
And if there are problems then you
can let us know using Bug Reporter.

00:10:44.330 --> 00:10:51.340
Now internally, we refer to this as radar,
and this is our primary communication tool

00:10:51.340 --> 00:10:54.460
when it comes to fixing problems with the driver.

00:10:54.460 --> 00:11:01.769
So this is your direct line, use it, and make sure
that you include as much information as possible.

00:11:01.769 --> 00:11:08.730
And there's a very good help document on the ADC web
site to explain what are good things to put into a bug,

00:11:08.730 --> 00:11:12.360
and the better the bug is written,
the more likely we are to fix it.

00:11:12.360 --> 00:11:14.419
So help us out with that.

00:11:14.419 --> 00:11:22.099
One last note, for ADC members, if you're a select
member you do get access to our compatibility lab,

00:11:22.100 --> 00:11:25.360
and this is a resource that I feel is underused.

00:11:25.360 --> 00:11:31.269
What it is, is a lab that has tons
of hardware configurations, many,

00:11:31.269 --> 00:11:34.379
many hardware configurations that we've shipped.

00:11:34.379 --> 00:11:40.350
You can also call ahead and have specific software
loaded on those machines, then you bring your device

00:11:40.350 --> 00:11:44.550
and you can test it on all of those
hardware and software configurations.

00:11:44.549 --> 00:11:49.899
Now if you try to build a test lab on
your own it would be very expensive.

00:11:49.899 --> 00:11:55.049
So it's a steal, so please, take advantage of that.

00:11:55.049 --> 00:12:01.870
And lastly, if you're still saying to yourself I can't use
your class driver because I have these advanced features

00:12:01.870 --> 00:12:07.909
that you do not support, and I have this very
fancy device, and I need to write my own driver.

00:12:07.909 --> 00:12:15.480
Well , what I say to you is why don't you rely on the
class driver for streaming, and then you can enhance

00:12:15.480 --> 00:12:19.620
that driver by adding your own custom plug-ins.

00:12:19.620 --> 00:12:24.970
So if you want to do some special DSP
on the input or output you can do that,

00:12:24.970 --> 00:12:28.740
you can add on, you can make a USB Audio plug-in.

00:12:28.740 --> 00:12:33.289
Or if you are worried that your
controls aren't exposed the way you would

00:12:33.289 --> 00:12:38.279
like in AMS you can write your own
custom control panel application,

00:12:38.279 --> 00:12:43.449
which can be launched straight from
AMS with the click of a button.

00:12:43.450 --> 00:12:49.920
Now currently our sample code that we
have on the web is a little out dated.

00:12:49.919 --> 00:12:56.019
It only supports doing DSP on output
streams at the engine level.

00:12:56.019 --> 00:13:03.980
We have recently revamped that sample code, and
expanded it to include doing DSP on both input

00:13:03.980 --> 00:13:10.960
and output streams independently, and we're in the review
process right now and we're going post that shortly.

00:13:10.960 --> 00:13:17.490
Now when it's posted I will let you know I'm going
post to the USB mailing list, the Apple mailing list,

00:13:17.490 --> 00:13:21.980
so we'll keep you updated, so stay tuned.

00:13:21.980 --> 00:13:29.830
Now in this section I'm going give you
four ways to improve your device design

00:13:29.830 --> 00:13:32.600
so that it works seamlessly in Snow Leopard.

00:13:32.600 --> 00:13:39.250
I'm going talk about controls and I'm going talk
about how to achieve artifact-free streaming.

00:13:39.250 --> 00:13:44.330
And I'm going to specifically focus on
areas that we have recently enhanced.

00:13:44.330 --> 00:13:50.070
So I'm going focus on the advances
that we've made over the past year.

00:13:50.070 --> 00:13:53.810
So if you're looking for what's
new pay attention to this section.

00:13:53.809 --> 00:13:59.579
The first tip, I want to talk about controls.

00:13:59.580 --> 00:14:07.970
So when your user is looking at your device in the operating
system the main point of interaction is around the controls.

00:14:07.970 --> 00:14:15.779
So I'm going to show you our parsing algorithm, how we
examine your audio topology and how we find controls

00:14:15.779 --> 00:14:24.139
for input, output streams, and also for play
through, for those of you that are not familiar,

00:14:24.139 --> 00:14:30.830
we're talking about hardware play through where for
instance you can route audio coming in an input port,

00:14:30.830 --> 00:14:33.950
out in output port directly in the hardware.

00:14:33.950 --> 00:14:36.710
So it's essentially zero latency.

00:14:36.710 --> 00:14:40.080
So in the audio world this is something
that's highly desirable.

00:14:40.080 --> 00:14:46.670
And the last thing I want to talk about
is if there's a change in a control

00:14:46.669 --> 00:14:55.799
on a device how you can send an interrupt to the host and
our driver will take notice, and update the user interface.

00:14:55.799 --> 00:14:59.089
So first, a review for you.

00:14:59.090 --> 00:15:06.670
Those of you that are not fresh on the USB
Audio spec, I want to go over audio topology.

00:15:06.669 --> 00:15:16.329
Now here is a diagram showing you -- this is an
example that I came up with, a very simple topology.

00:15:16.330 --> 00:15:22.170
It has S/PDIF In, and Line In, and speaker output.

00:15:22.169 --> 00:15:27.329
On the outer edges you'll see the Terminals.

00:15:27.330 --> 00:15:33.460
On the left-hand side you have the input
Terminals, so S/PDIF In, Line In, and USB streaming.

00:15:33.460 --> 00:15:37.060
That's coming -- audio is coming
into the device on this side.

00:15:37.059 --> 00:15:39.529
And on the right-hand side we have the output Terminals.

00:15:39.529 --> 00:15:42.569
That's where audio is leaving the device.

00:15:42.570 --> 00:15:47.840
In the center are various units.

00:15:47.840 --> 00:15:51.040
The ones you're probably most familiar
with are the feature units.

00:15:51.039 --> 00:15:56.549
This is where we -- where usually you'll
call out your volume and mute controls.

00:15:56.549 --> 00:15:58.459
We have a selector unit.

00:15:58.460 --> 00:16:07.000
This unit switches between one or more input
pinsand routes that to the output pinunaltered.

00:16:07.000 --> 00:16:14.620
And then finally we have a mixer unit, and
this unit takes multiple -- one or more --

00:16:14.620 --> 00:16:19.379
input pins, routes it to the output
pin, but unlike the selector unit,

00:16:19.379 --> 00:16:23.490
it actually combines the channels and mixes them together.

00:16:23.490 --> 00:16:31.019
Here is a -- I took this diagram straight from the
audio spec showing you what a mixer unit could do.

00:16:31.019 --> 00:16:36.929
And as you see there's this matrix in the center, around
at every intersection point between the incoming channels

00:16:36.929 --> 00:16:40.500
and the out going channels, you can control the volume.

00:16:40.500 --> 00:16:42.440
So it's very flexible unit.

00:16:42.440 --> 00:16:47.360
We don't see a lot of devices implementing
it, but I think it's a great tool.

00:16:47.360 --> 00:16:50.669
So you should definitely consider that.

00:16:50.669 --> 00:16:53.240
So first I want to talk about input paths.

00:16:53.240 --> 00:16:57.840
How do we find the volume and mute
controls for your input path?

00:16:57.840 --> 00:16:59.420
Let's look at Line In.

00:16:59.419 --> 00:17:01.229
That's my first example.

00:17:01.230 --> 00:17:09.380
The algorithm we use is we start at the selector unit
and we find the first feature unit on the input side.

00:17:09.380 --> 00:17:11.880
So in this case, it's this feature unit.

00:17:11.880 --> 00:17:17.180
Now this is a very simple diagram, but
it sometimes gets more complicated.

00:17:17.180 --> 00:17:23.580
If you don't have a selector unit, you know, some devices
don't have this complicated of a configuration, well,

00:17:23.579 --> 00:17:26.899
we'll just start at the output side
and move toward the input side.

00:17:26.900 --> 00:17:33.320
The first feature unit we find with volume
controls, those are the ones we're going to use.

00:17:33.319 --> 00:17:35.740
Now output is similar.

00:17:35.740 --> 00:17:39.059
We start at the -- let's -- here we go.

00:17:39.059 --> 00:17:41.919
Let's look at the speaker path.

00:17:41.920 --> 00:17:48.580
So the way -- our algorithm works by starting by
the output side, and the first feature we find

00:17:48.579 --> 00:17:52.809
with the volume and mute control that's the one we use.

00:17:52.809 --> 00:17:53.819
It's very simple.

00:17:53.819 --> 00:17:58.149
I mean, our algorithm is just, you
know, what the user would expect.

00:17:58.150 --> 00:18:02.019
We want to control the volume and
mute at the last moment possible,

00:18:02.019 --> 00:18:06.680
before the audio leaves the device, if that makes sense.

00:18:06.680 --> 00:18:08.620
Now how about play through.

00:18:08.619 --> 00:18:11.339
It's a little more complicated here.

00:18:11.339 --> 00:18:17.000
Let's consider the play through path
going from line input to the speaker.

00:18:17.000 --> 00:18:21.750
Now as you can see, there's a few
feature units on this path.

00:18:21.750 --> 00:18:28.410
We are going to start from the input
side and the first feature unit we find

00:18:28.410 --> 00:18:31.460
with volume and mute controls we're going to use.

00:18:31.460 --> 00:18:40.009
Now the one caveat here is that that -- those
controls cannot be shared with any other audio path.

00:18:40.009 --> 00:18:42.230
It's very important that they are independent.

00:18:42.230 --> 00:18:44.610
Now if we find a mixer units, we stop looking.

00:18:44.609 --> 00:18:47.259
It gets too complicated.

00:18:47.259 --> 00:18:50.269
So note, you have to have independent controls.

00:18:50.269 --> 00:18:58.029
And one thing to note here, so you don't get confused,
this confused me at first, when we publish those controls,

00:18:58.029 --> 00:19:01.160
we do publish volume and mute for play through,

00:19:01.160 --> 00:19:06.110
it's just that the volume controls are
not exposed in Audio MIDI Setup, okay?

00:19:06.109 --> 00:19:07.500
Only the mute control.

00:19:07.500 --> 00:19:12.849
The mute control shows up as the
On/Off toggle for through, all right?

00:19:12.849 --> 00:19:17.980
So if you really want to see your volume controls
you're going to have to go into another application

00:19:17.980 --> 00:19:20.450
like HALLab, and then you can see them.

00:19:20.450 --> 00:19:26.370
So your typical user isn't going to see those,
so my suggestion to you is set your volume levels

00:19:26.369 --> 00:19:35.189
at something reasonable, i.e., ON, because otherwise
it will seem like the play through doesn't work.

00:19:35.190 --> 00:19:39.380
So what I think is helpful since I've had
a lot of vendors get confused about this,

00:19:39.380 --> 00:19:43.400
I'm going show you what not to do for play through, okay?

00:19:43.400 --> 00:19:46.230
So look at this -- I have a different diagram up here.

00:19:46.230 --> 00:19:49.230
You can see I've removed one of the feature units.

00:19:49.230 --> 00:19:54.759
And here's our play through path again,
coming from the Line In, going to speaker.

00:19:54.759 --> 00:20:00.180
And if we were -- as you can see, that
feature unit that we used before is now shared

00:20:00.180 --> 00:20:04.080
with the Line In record path, as you can see.

00:20:04.079 --> 00:20:05.720
And that will be a problem.

00:20:05.720 --> 00:20:08.870
And let me give you an example as to why this is a problem.

00:20:08.869 --> 00:20:12.159
So let's say that I'm recording through Line In.

00:20:12.160 --> 00:20:15.800
And I'm using the play through to monitor, okay?

00:20:15.799 --> 00:20:20.879
So I've got that going, I'm listening to my
Line In, and I'm recording, and now I say hey,

00:20:20.880 --> 00:20:23.800
I don't want to listen to that monitored audio any more.

00:20:23.799 --> 00:20:25.589
So I turn off the play through.

00:20:25.589 --> 00:20:26.990
What happens?

00:20:26.990 --> 00:20:31.529
Your Line In record path is now muted,
which isn't what the user expects.

00:20:31.529 --> 00:20:40.079
So be careful, don't share controls, and you will be fine
and you will be able to expose your play through path.

00:20:40.079 --> 00:20:45.980
Lastly , in the area of controls, I want
to talk about status interrupt endpoints.

00:20:45.980 --> 00:20:50.509
Now this is a 1.0 feature, it's also in 2.0.

00:20:50.509 --> 00:20:53.009
We finally implemented this, and it's really cool.

00:20:53.009 --> 00:20:54.890
Let me give you an example.

00:20:54.890 --> 00:21:03.110
So if you have a device and there's a volume knob,
okay, so you turn the volume up, and via an interrupt,

00:21:03.109 --> 00:21:08.819
can let us know about it, and we will update
the controls in the application layer.

00:21:08.819 --> 00:21:09.879
So they're informed.

00:21:09.880 --> 00:21:12.760
So now your volume sliders are updated.

00:21:12.759 --> 00:21:16.549
So it's very seamless, the user turns
the volume knob and instantly AMS,

00:21:16.549 --> 00:21:18.930
you can see the volume slider going back and forth.

00:21:18.930 --> 00:21:19.970
It's great.

00:21:19.970 --> 00:21:23.600
So we really encourage you to take
advantage of this feature,

00:21:23.599 --> 00:21:28.639
because I think that it really
provides for a great user experience.

00:21:28.640 --> 00:21:34.480
We implemented -- by the way, we implemented that exactly
to the spec. So you can use that for your documentation.

00:21:34.480 --> 00:21:38.259
Tip two is descriptive naming.

00:21:38.259 --> 00:21:45.539
We have now given you a lot of control in the way
your devices are represented name-wise in the OS.

00:21:45.539 --> 00:21:49.899
And we've also added support for channel names.

00:21:49.900 --> 00:21:54.230
And you can either use the predefined channel
names that are called out in the spec,

00:21:54.230 --> 00:21:57.009
or you can come up with your own custom names.

00:21:57.009 --> 00:21:58.809
So I'll show you how to do that.

00:21:58.809 --> 00:22:02.059
First, engine and device names.

00:22:02.059 --> 00:22:08.069
Now I mentioned earlier that sometimes there's a
little bit of confusion in the OS, what's the device,

00:22:08.069 --> 00:22:10.619
what's an engine, where do I get the device names.

00:22:10.619 --> 00:22:12.349
Well, this is how it works.

00:22:12.349 --> 00:22:19.699
If we provide an engine name using an algorithm that
I've shown here, then that will be used by the device

00:22:19.700 --> 00:22:22.880
as it's represented in the application layer.

00:22:22.880 --> 00:22:27.360
If there is no engine name, then we'll
go ahead and use that device name, okay?

00:22:27.359 --> 00:22:28.759
So that's how it works.

00:22:28.759 --> 00:22:34.509
And here is the algorithm we use
to figure out what the name is.

00:22:34.509 --> 00:22:38.319
Now it's a little boring, but I'll go
through it with you really briefly.

00:22:38.319 --> 00:22:42.359
For the engine, we're going to see
if you have a stream interface name.

00:22:42.359 --> 00:22:44.049
If you have one, we'll use that.

00:22:44.049 --> 00:22:47.399
If not, then we'll look to see if
there's a control interface name.

00:22:47.400 --> 00:22:49.410
And we'll use that.

00:22:49.410 --> 00:22:56.960
For the devices, we start with the control interface, if
there's no name there then we move on the USB product name.

00:22:56.960 --> 00:23:02.960
And if there's no name there, then we're going
to just give you unknown USB Audio device.

00:23:02.960 --> 00:23:04.190
You don't want this to be you.

00:23:04.190 --> 00:23:05.980
That doesn't look very good.

00:23:05.980 --> 00:23:08.700
So try not to have that happen.

00:23:08.700 --> 00:23:09.460
That's very rare.

00:23:09.460 --> 00:23:13.289
We rarely see that.

00:23:13.289 --> 00:23:14.920
Now channel names.

00:23:14.920 --> 00:23:19.410
So we use -- you have a choice.

00:23:19.410 --> 00:23:22.500
You can use the predefined channel
names, like I said before.

00:23:22.500 --> 00:23:28.650
Like front left, front right, front center, low
frequency effects, all of the standard names.

00:23:28.650 --> 00:23:35.080
Or you can call out your own names for your
channels to really customize your device.

00:23:35.079 --> 00:23:38.629
Now this is how it might look in an
application to give you an example.

00:23:38.630 --> 00:23:40.780
This is Logic I have up here.

00:23:40.779 --> 00:23:42.200
And I'm going zoom in here.

00:23:42.200 --> 00:23:46.769
And you can see on the input channel
one, it's called External Mic.

00:23:46.769 --> 00:23:50.129
So this actually came from the device descriptors.

00:23:50.130 --> 00:23:53.760
This did not require installing any software.

00:23:53.759 --> 00:23:57.430
Now here's a little bit of code for you.

00:23:57.430 --> 00:24:04.340
This is the struct that we
use to call out an audio cluster descriptor.

00:24:04.339 --> 00:24:09.019
Now an audio cluster descriptor is where
you're going specify your channel names.

00:24:09.019 --> 00:24:14.299
The first element is the number
of channels in your audio cluster.

00:24:14.299 --> 00:24:16.289
B and R channels.

00:24:16.289 --> 00:24:19.259
The second element is channel config.

00:24:19.259 --> 00:24:27.250
This is actually a bit mask, and when the bit is set is
means that you are using the predefined channel name.

00:24:27.250 --> 00:24:31.119
If the bit is not set it means that
we're going to use a custom name.

00:24:31.119 --> 00:24:36.159
Now the iChannelNames is an index
into the string descriptor array.

00:24:36.160 --> 00:24:41.690
And it calls out the first custom
name, and then they go sequentially.

00:24:41.690 --> 00:24:48.880
So if you want to know how many non-predefined channel
names you have, you just take the total number of channels

00:24:48.880 --> 00:24:55.490
and subtract the number of bits that
are set in the bitmask channel config.

00:24:55.490 --> 00:24:59.859
So where do we find your audio cluster descriptor.

00:24:59.859 --> 00:25:01.649
Well, this is the algorithm that we use.

00:25:01.650 --> 00:25:06.190
Let's take a look at the speaker path again.

00:25:06.190 --> 00:25:14.320
The audio cluster descriptor, according to the
specification, can only be defined in four entities.

00:25:14.319 --> 00:25:20.909
The input terminal, the mixer unit, the
processor unit, or the extension unit.

00:25:20.910 --> 00:25:30.050
So we start looking, starting from the output terminal side,
and we find the first unit that contains the descriptor.

00:25:30.049 --> 00:25:31.960
In this case, it's the mixer.

00:25:31.960 --> 00:25:33.180
That's pretty common.

00:25:33.180 --> 00:25:39.570
But it could also be called out in your
input terminal, the USB streaming one.

00:25:39.569 --> 00:25:42.329
So onto the third tip.

00:25:42.329 --> 00:25:44.149
This is a big one.

00:25:44.150 --> 00:25:49.240
How can you design your device such
that you have artifact-free streaming.

00:25:49.240 --> 00:25:56.710
Now I don't know about you, but to me, streaming audio
flawlessly, that is the primary purpose of your device.

00:25:56.710 --> 00:25:58.680
That's what the customer is expecting.

00:25:58.680 --> 00:26:03.920
And you would be shocked how many devices
actually don't stream free of artifacts.

00:26:03.920 --> 00:26:09.289
So I'm going to give you some tips and
areas to focus on to prevent artifacts.

00:26:09.289 --> 00:26:14.170
Number one, the sync types that you
use for your end points are crucial.

00:26:14.170 --> 00:26:19.009
I'm going to give you some guidance
on how to pick these appropriately

00:26:19.009 --> 00:26:22.379
to guarantee that your device is going work right.

00:26:22.380 --> 00:26:26.080
Secondly, I want to talk about max packet size.

00:26:26.079 --> 00:26:29.699
Many times descriptors are incorrect in this area.

00:26:29.700 --> 00:26:34.319
And I'm going show you how we determine how
much bandwidth we're going to reserve for you,

00:26:34.319 --> 00:26:39.309
which will help you to decide what
your max packet size should be.

00:26:39.309 --> 00:26:43.539
All right, end point synchronization types.

00:26:43.539 --> 00:26:46.779
I'm going to give you a quick overview, this is straight

00:26:46.779 --> 00:26:52.139
from the USB spec. Now I'm talking
about USB, plain USB, vanilla.

00:26:52.140 --> 00:26:58.400
But I'm going to give it a little bit of
an audio slant, so first, synchronous.

00:26:58.400 --> 00:26:59.910
This is the most basic.

00:26:59.910 --> 00:27:01.550
It's very easy to implement.

00:27:01.549 --> 00:27:08.009
This means that your endpoint is synced
to the host using starter frame tokens.

00:27:08.009 --> 00:27:10.809
The second type we see is asynchronous.

00:27:10.809 --> 00:27:14.349
This means that the endpoint is not synced to the host.

00:27:14.349 --> 00:27:21.549
Possibly, it's synced to an external source
or the crystal on the device, perhaps.

00:27:21.549 --> 00:27:23.899
The third type is adaptive.

00:27:23.900 --> 00:27:29.240
Now I'm not going to talk about input adaptive
end points, because we just don't see those.

00:27:29.240 --> 00:27:33.210
We mostly see output adaptive end points.

00:27:33.210 --> 00:27:40.529
And this would mean that the endpoint is synchronized
to the host using that output stream rate.

00:27:40.529 --> 00:27:42.299
So that's how they're going to sync the clock.

00:27:42.299 --> 00:27:52.609
Now I'm going to give you some typical combinations we see
between input and output endpoint synchronization types.

00:27:52.609 --> 00:27:54.209
These work very well.

00:27:54.210 --> 00:27:55.250
And they're very common.

00:27:55.250 --> 00:27:59.069
So if you stick to these you're going to be fine.

00:27:59.069 --> 00:28:00.000
So let's start out.

00:28:00.000 --> 00:28:04.700
I have input on the left -- yeah,
input on the left, output on the right.

00:28:04.700 --> 00:28:07.529
First, synchronous, and synchronous.

00:28:07.529 --> 00:28:10.289
This is the easiest, this is the most straight forward.

00:28:10.289 --> 00:28:14.470
We get it, your clock is synced to
the host using starter frame tokens.

00:28:14.470 --> 00:28:15.799
There's no guess work here.

00:28:15.799 --> 00:28:20.069
We know exactly how your synchronization works.

00:28:20.069 --> 00:28:26.869
The second type we see a lot is asynchronous
input combined with adaptive output.

00:28:26.869 --> 00:28:33.339
Again, very easy for us from the driver perspective
to know how your clocks are synchronized,

00:28:33.339 --> 00:28:39.709
we know that your clock is being derived from
the output rate coming back from the host.

00:28:39.710 --> 00:28:44.110
And on the input side you don't have a feed
back-end point, so you're asynchronous.

00:28:44.109 --> 00:28:52.129
The last combination we see, especially in pro
audio devices where you need a very accurate clock,

00:28:52.130 --> 00:28:56.360
we see asynchronous on the way
in, and asynchronous on the out.

00:28:56.359 --> 00:29:03.029
And you know, typically you'll see them using a
very accurate crystal, you know, on the device,

00:29:03.029 --> 00:29:07.240
or possibly they're syncing to
S/PDIF In, like an external source.

00:29:07.240 --> 00:29:08.480
So we see that a lot.

00:29:08.480 --> 00:29:11.680
Stick to these, you're in business.

00:29:11.680 --> 00:29:13.450
We highly recommend that you do.

00:29:13.450 --> 00:29:17.309
Now I want to talk about max packet size.

00:29:17.309 --> 00:29:19.329
It's an area of a lot of confusion.

00:29:19.329 --> 00:29:24.309
So I want to take this opportunity to clarify.

00:29:24.309 --> 00:29:27.899
First off, we follow the spec exactly.

00:29:27.900 --> 00:29:34.060
The spec reads you cannot vary your packet size
by more than plus or minus one sample frame.

00:29:34.059 --> 00:29:36.740
It's very clear.

00:29:36.740 --> 00:29:42.980
Secondly, the way our driver works we're
only going to reserve enough bandwidth,

00:29:42.980 --> 00:29:47.819
just enough bandwidth that you need to the bus,
because we want to leave room for other things, right?

00:29:47.819 --> 00:29:54.730
So we follow the spec. We're only going to give you
the average USB frame size plus one sample frame.

00:29:54.730 --> 00:30:00.059
Now this is best illustrated with an
example for you to understand it clearly.

00:30:00.059 --> 00:30:08.690
I'm going take a full speed example, this stream
is at 44.1 kilohertz, two channel, 24-bit.

00:30:08.690 --> 00:30:10.150
Very basic.

00:30:10.150 --> 00:30:15.860
So we know that if we're a full speed device
that there are a thousand USB frames a second.

00:30:15.859 --> 00:30:21.959
Now if you have -- if your sample
rate is 44,100 sample frames a second,

00:30:21.960 --> 00:30:28.910
that gives you an average of 44.1
sample frames per USB frame.

00:30:28.910 --> 00:30:38.730
Now we know that we cannot straddle two USB frames with
one audio sample frame, so we have to use this cadence.

00:30:38.730 --> 00:30:43.079
So let me give you an example of the
exact packets and how they're constructed.

00:30:43.079 --> 00:30:48.109
So here we've got USB frames in terms of sample frames.

00:30:48.109 --> 00:30:52.089
So the first USB packet will have 44 sample frames.

00:30:52.089 --> 00:30:54.829
The next one, 44 sample framesD.

00:30:54.829 --> 00:31:00.250
We do that over and over till we get to the
tenth frame, and then we send 45 sample frames.

00:31:00.250 --> 00:31:06.099
That's how we get the 0.1 without straddling two USB frames.

00:31:06.099 --> 00:31:11.619
Now we know that for each sample frame
we've got two channels, 3 bytes of sample,

00:31:11.619 --> 00:31:16.049
we're 24 bit, so that's 6 bytes per sample frame.

00:31:16.049 --> 00:31:20.369
So we do the math, and now we can
see the USB frames in terms of bytes.

00:31:20.369 --> 00:31:23.509
So 44 times 6 is 264.

00:31:23.509 --> 00:31:25.599
So that's the average size.

00:31:25.599 --> 00:31:34.429
So we send 264 bytes, 264 bytes, all the way up to the tenth
frame, then we add on that extra sample frame, which is 270.

00:31:34.430 --> 00:31:36.019
So that's what you're going to get reserved for you.

00:31:36.019 --> 00:31:40.629
270. It's very important on input.

00:31:40.630 --> 00:31:42.930
Make sure that you set these appropriately.

00:31:42.930 --> 00:31:46.060
If you specify this huge max packet size, it doesn't matter.

00:31:46.059 --> 00:31:48.819
We're going to reserve for you what you need.

00:31:48.819 --> 00:31:51.069
So be cognizant of that.

00:31:51.069 --> 00:31:53.929
And don't make your max packet size too small.

00:31:53.930 --> 00:31:59.730
Because we've seen that, where you don't allow for
that cadence, that extra sample frame occasionally.

00:31:59.730 --> 00:32:04.490
So go ahead and, you know, set that
properly, and you won't have artifacts.

00:32:04.490 --> 00:32:11.670
Now the reason why there's artifacts is because we need
to use this to generate the time stamps for Core Audio.

00:32:11.670 --> 00:32:17.289
And if this gets messed up then we don't generate accurate
time stamps, and that's where the problem happens.

00:32:17.289 --> 00:32:21.500
Now also we can lose data, because if
we're not expecting the packet size

00:32:21.500 --> 00:32:24.869
that you send it will get dropped on the floor.

00:32:24.869 --> 00:32:26.839
So there's your artifact.

00:32:26.839 --> 00:32:35.949
So the fourth tip I want to talk about today is this
great new feature that we've added to the driver.

00:32:35.950 --> 00:32:38.970
We added this in 10.5.7.

00:32:38.970 --> 00:32:45.809
And previously -- well, the feature is you
can have multiple streams on a single engine.

00:32:45.809 --> 00:32:49.730
Now up to this point we always
put streams on their own engine.

00:32:49.730 --> 00:32:51.710
So every stream had an engine.

00:32:51.710 --> 00:32:56.940
Well, we've changed that, and we now give
you the ability to combine those streams.

00:32:56.940 --> 00:33:01.279
And what's good about it is that since
the streams are on the same engine they're

00:33:01.279 --> 00:33:05.609
on the same I/O clock cycles, which
means they are synchronized.

00:33:05.609 --> 00:33:07.819
And of course they'll have the same sample rate.

00:33:07.819 --> 00:33:12.009
So this is a great benefit to the user, and in addition,

00:33:12.009 --> 00:33:16.890
the user will also experience consistent
latency between hot-plugs.

00:33:16.890 --> 00:33:21.400
Every time they plug-in that device they're
going to see the same kind of latency.

00:33:21.400 --> 00:33:24.950
So that's -- that's great, because
now you can actually measure latency.

00:33:24.950 --> 00:33:28.440
That works out great for us to, so you can test it.

00:33:28.440 --> 00:33:32.480
So how -- you're probably asking yourself,
well, how can I take advantage of this.

00:33:32.480 --> 00:33:35.779
Well, most devices already kind of
work that we tested, many of them do.

00:33:35.779 --> 00:33:43.629
But let me give you the criteria that we use to figure
out if streams can indeed be put on the same engine.

00:33:43.630 --> 00:33:52.020
First, we have to check to see that the sync type is the
same for all of the alternate settings on the interface.

00:33:52.019 --> 00:33:56.430
Now if we didn't have this rule it
would get very confusing very fast.

00:33:56.430 --> 00:34:02.070
The second thing we look for is we need to know
that the endpoint sync types are compatible.

00:34:02.069 --> 00:34:05.329
So remember back a few slides when
I was talking about combos

00:34:05.329 --> 00:34:09.239
that work well together, use those and you're in business.

00:34:09.239 --> 00:34:10.569
It will work.

00:34:10.570 --> 00:34:15.140
The third thing we look for is matching sample rates.

00:34:15.139 --> 00:34:17.819
So like I said, if the streams are on the same engine

00:34:17.820 --> 00:34:22.590
and we're using the same clock cycles,
then the sample rates have to match.

00:34:22.590 --> 00:34:28.190
So we need to be able to select -- if you change the sample
rate on input, we have to change the output to match.

00:34:28.190 --> 00:34:31.460
So they need to have the same set of sample rates.

00:34:31.460 --> 00:34:39.659
And lastly, for those of you designing 2.0 USB Audio
devices, the streams need to be in the same clock domain.

00:34:39.659 --> 00:34:43.670
And I will go into more detail about 2.0 in a moment.

00:34:43.670 --> 00:34:47.090
And it's right now.

00:34:47.090 --> 00:34:50.380
2.0 USB Audio in Snow Leopard.

00:34:50.380 --> 00:34:55.039
We've been working really hard
on this portion of the driver.

00:34:55.039 --> 00:34:59.730
So a lot of vendors have been asking
us, well, what features do you support?

00:34:59.730 --> 00:35:02.869
Well the most obvious one is high speed streaming.

00:35:02.869 --> 00:35:05.849
A lot of you want to do high channel count devices.

00:35:05.849 --> 00:35:08.509
Well, you can now.

00:35:08.510 --> 00:35:16.820
Previously with full speed, you were only able
at 96K/24bit , you could only do three channels.

00:35:16.820 --> 00:35:23.950
But with high speed, you can do 24 channels of 96 K/24 bit.

00:35:23.949 --> 00:35:26.289
So that's a huge improvement.

00:35:26.289 --> 00:35:32.550
Basically, we can now -- we can
do 1,024 bytes per micro frame.

00:35:32.550 --> 00:35:34.840
There's 8 microframes per millisecond.

00:35:34.840 --> 00:35:36.780
So that's a lot of band width.

00:35:36.780 --> 00:35:42.290
One of the things we don't support at
the moment is high bandwidth end points.

00:35:42.289 --> 00:35:44.259
Now this part of the spec is a little tricky.

00:35:44.260 --> 00:35:46.180
So let me clarify.

00:35:46.179 --> 00:35:51.190
So we do high speed -- that's 1,024 bytes every microframe.

00:35:51.190 --> 00:35:55.650
But we can't do multiple transactions
at the moment per microframe.

00:35:55.650 --> 00:36:01.420
The spec allows you to do three transactions,
up to three transactions a microframe.

00:36:01.420 --> 00:36:03.170
So that's 3K.

00:36:03.170 --> 00:36:08.340
So we haven't gotten to that point yet,
but we are highly interested in this.

00:36:08.340 --> 00:36:12.740
We have not yet seen a device that does anything
like this, so if you are considering that,

00:36:12.739 --> 00:36:15.750
please come and talk to me after the session today.

00:36:15.750 --> 00:36:20.590
Because we're really looking for devices that do this.

00:36:20.590 --> 00:36:27.990
The second big improvement with USB
Audio 2.0 is the clock domain support.

00:36:27.989 --> 00:36:33.389
So now you can use the descriptors to really
describe accurately your clock domains.

00:36:33.389 --> 00:36:37.319
You know, the guessing game I was talking about
before with the different endpoint combinations?

00:36:37.320 --> 00:36:40.130
Well, with 2.0 we don't have to guess.

00:36:40.130 --> 00:36:42.329
It's clearly called out in the descriptors.

00:36:42.329 --> 00:36:45.019
We really like this part of 2.0.

00:36:45.019 --> 00:36:46.559
So back to the diagram.

00:36:46.559 --> 00:36:49.259
Here's your audio topology again.

00:36:49.260 --> 00:36:50.790
Now we have some new descriptors.

00:36:50.789 --> 00:36:52.500
They're the ones in green.

00:36:52.500 --> 00:36:55.329
We have implemented clock sources.

00:36:55.329 --> 00:36:56.779
So we have two in this example.

00:36:56.780 --> 00:37:01.690
We have an external source and an
internal programmable clock source.

00:37:01.690 --> 00:37:04.840
We have also implemented clock selectors.

00:37:04.840 --> 00:37:11.289
And a good illustration of this is how
it might be exposed in Audio MIDI Setup.

00:37:11.289 --> 00:37:15.789
So as you can see with this example,
this device has a selector

00:37:15.789 --> 00:37:20.230
and you can choose between external clock or device.

00:37:20.230 --> 00:37:22.960
So that's really nice.

00:37:22.960 --> 00:37:31.340
And thirdly, we implemented the
interface association descriptor.

00:37:31.340 --> 00:37:38.220
And this is there to describe an audio interface collection.

00:37:38.219 --> 00:37:43.379
And you have to make sure that you put that
descriptor in, and then also another requirement is

00:37:43.380 --> 00:37:46.700
that your interfaces come in a specific order.

00:37:46.699 --> 00:37:52.589
So you start with your control interface,
then your audio streaming interfaces,

00:37:52.590 --> 00:37:55.620
and then finally your MIDI streaming interfaces.

00:37:55.619 --> 00:37:58.909
And the interface numbers need to be contiguous.

00:37:58.909 --> 00:38:06.049
And lastly, we again implemented the
status interrupt endpoint for 2.0.

00:38:06.050 --> 00:38:11.450
And this allows us to do some fancy
things, like maintain a valid clock source.

00:38:11.449 --> 00:38:13.230
Let me show you how that might work.

00:38:13.230 --> 00:38:20.429
So let's say you have your S/PDIF In coming in, and that's
what you're using for -- you're syncing your clock to that.

00:38:20.429 --> 00:38:23.359
As you can see in the diagram, I have that selected.

00:38:23.360 --> 00:38:28.930
But if you're like me and you kind of
have a messy studio, sometimes it --

00:38:28.929 --> 00:38:31.919
it happens where I accidentally pull a cable.

00:38:31.920 --> 00:38:35.630
It's dark, it's late, I accidentally,
oops, pulled the cable.

00:38:35.630 --> 00:38:40.960
So if you have this interrupt endpoint
there then you can let the driver know

00:38:40.960 --> 00:38:44.269
and we will switch it to a valid clock source.

00:38:44.269 --> 00:38:49.369
So that's a nice feature that you can do in 2.0.

00:38:49.369 --> 00:38:55.529
So to wrap up, the main message I
would like you to take home today is

00:38:55.530 --> 00:39:00.880
that class compliant devices work best on Mac OS X.

00:39:00.880 --> 00:39:04.190
This is really the best choice for so many reasons.

00:39:04.190 --> 00:39:07.720
It's been a good choice for a long
time, but it's a really good choice now.

00:39:07.719 --> 00:39:14.009
Because you really take advantage of what, you
know, the best that Mac OS X platform has to offer.

00:39:14.010 --> 00:39:18.370
And that is plug and play, ease of use, seamlessness.

00:39:18.369 --> 00:39:21.710
You know, when your device is class
compliant, you get that for free.

00:39:21.710 --> 00:39:27.490
And I feel like now we have a lot of resources available
for you and a lot of support and a way, you know,

00:39:27.489 --> 00:39:30.279
to get you there and help you with your descriptors.

00:39:30.280 --> 00:39:32.680
So it really is the best choice.

00:39:32.679 --> 00:39:40.769
Another thing I want to add here is that because we're on
the inside, we have a unique perspective to take advantage

00:39:40.769 --> 00:39:44.530
of low-level improvements in the operating system.

00:39:44.530 --> 00:39:49.880
You know, we have that inside information,
so we optimize our driver to work the best.

00:39:49.880 --> 00:39:55.190
And this is information on the -- as for you
on the outside that you don't have access to.

00:39:55.190 --> 00:39:58.260
So it makes sense to leave it to us, and let us, you know,

00:39:58.260 --> 00:40:02.370
make streaming work the best it can
work, even when things change underneath.

00:40:02.369 --> 00:40:05.409
I just think it's a great opportunity.

00:40:05.409 --> 00:40:06.940
So just take advantage of it.

00:40:06.940 --> 00:40:09.659
And you'll save yourself some money.

00:40:09.659 --> 00:40:14.179
Secondly, if I haven't convinced you already, we really feel

00:40:14.179 --> 00:40:20.819
that the 2.0 USB Audio specification
is superior to 1.0 in many regards.

00:40:20.820 --> 00:40:27.820
Now this isn't just for high channel count, high
bandwidth, okay, that's a very compelling reason to go 2.0.

00:40:27.820 --> 00:40:32.309
But there are other reasons to be 2.0 class compliant.

00:40:32.309 --> 00:40:37.070
For one, the get the benefit of those clock descriptors.

00:40:37.070 --> 00:40:43.180
And I can't describe -- we've -- I can't tell you
how many times we've tripped over this in the driver

00:40:43.179 --> 00:40:46.789
when we're trying to figure out how
devices synchronize, it's such a problem.

00:40:46.789 --> 00:40:49.259
People get so confused with those endpoints.

00:40:49.260 --> 00:40:53.200
It's just when we have those clock
descriptors it's really clear.

00:40:53.199 --> 00:40:59.779
And then that opens it up for us in the future, now I'm not
making any promises here, but there are a lot of features

00:40:59.780 --> 00:41:02.310
that we could potentially implement here.

00:41:02.309 --> 00:41:07.739
Like let's say having multiple use
audio devices synchronize together.

00:41:07.739 --> 00:41:09.129
That would be pretty cool.

00:41:09.130 --> 00:41:12.769
Much, much cleaner, we can only do this in 2.0.

00:41:12.769 --> 00:41:17.880
Really. So if you want to take
advantage of those future features

00:41:17.880 --> 00:41:21.530
that we may add, you know, we're concentrating on 2.0.

00:41:21.530 --> 00:41:26.260
So let's all move forward together
and embrace that new specification.

00:41:26.260 --> 00:41:34.940
And also, again, I want to remind you, if you are
designing a 2.0 or a 1.0 device, feel free to contact us,

00:41:34.940 --> 00:41:41.360
talk to me after the session, come to the
lab, call -- send an e-mail to Michael Wong,

00:41:41.360 --> 00:41:43.610
I'm going to have his e-mail address up here in a moment.

00:41:43.610 --> 00:41:45.870
Send us the device.

00:41:45.869 --> 00:41:47.210
Let us know what you're doing.

00:41:47.210 --> 00:41:49.309
Tell us what features you want

00:41:49.309 --> 00:41:51.980
You know, we're open to listening to what you need.

00:41:51.980 --> 00:41:55.440
We want to make the most devices
work the best on our platform.

00:41:55.440 --> 00:42:00.490
So we're really interested in what you're
looking to do, what are your plans.

00:42:00.489 --> 00:42:01.429
So talk to us.

00:42:01.429 --> 00:42:04.259
So that's all I have today.

00:42:04.260 --> 00:42:07.910
If you want more information you can talk to Craig Keithley.

00:42:07.909 --> 00:42:10.949
He's an I/O technology evangelist here at Apple.

00:42:10.949 --> 00:42:14.179
You've probably seen his name on quite a few slides.

00:42:14.179 --> 00:42:18.980
Again, Michael Wong, he's going to be coming up in
a moment during Q and A, so you can see his face.

00:42:18.980 --> 00:42:26.130
He is our audio partnership manager, and definitely
send him an e-mail if you have a device or questions.

00:42:26.130 --> 00:42:28.710
And you can always contact DTS, of course.

00:42:28.710 --> 00:42:34.329
And then lastly, our documentation
is the same as your documentation.

00:42:34.329 --> 00:42:40.569
The spec. I know it's kind of heavy and
boring and long, it actually isn't that bad.

00:42:40.570 --> 00:42:42.630
You just have to get in there.

00:42:42.630 --> 00:42:47.940
After the second or third read it starts making some sense.

00:42:47.940 --> 00:42:51.349
Or 10, 30 -- 23 -- how many times I've read it.

00:42:51.349 --> 00:42:55.619
In addition to that, I just want
to let you know that I am planning

00:42:55.619 --> 00:42:59.809
on releasing some tech notes with this information in it.

00:42:59.809 --> 00:43:05.599
Of course, you have access to the QuickTime
Movies, but I plan on releasing a tech note.

00:43:05.599 --> 00:43:10.679
I can't make -- I don't have the title or,
you know, the exact content ready today,

00:43:10.679 --> 00:43:13.419
but keep an eye on that USB mailing list.

00:43:13.420 --> 00:43:18.269
I will let you know when we're ready,
and you will have that in document form.
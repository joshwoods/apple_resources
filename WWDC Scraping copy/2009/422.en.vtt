WEBVTT

00:00:12.910 --> 00:00:14.089
>> Good morning.

00:00:14.089 --> 00:00:17.570
My name is John Hess and today I'm going
to be joined by my colleague Mike Ferris.

00:00:17.570 --> 00:00:23.570
And the two of us are going to tell you about state
of the art Cocoa application development on Mac OS X.

00:00:23.570 --> 00:00:29.089
Mac OS X has a whole host of technologies that
are available for you to use in your applications.

00:00:29.089 --> 00:00:34.189
And it's our aim today to take you on a tour of each of
these technologies so that you can see what's applicable

00:00:34.189 --> 00:00:39.839
to your application and help most effectively plan
your session attendance for the remainder of the week.

00:00:39.840 --> 00:00:44.170
I'm going to start today by telling you
about some code clarifying technologies.

00:00:44.170 --> 00:00:48.490
These are technologies that you can use to help
your application focus on what it does best.

00:00:48.490 --> 00:00:52.440
You can eliminate the code that's common to
all sorts of applications and really just focus

00:00:52.439 --> 00:00:55.659
on the features that you deliver to your users.

00:00:55.659 --> 00:00:59.169
First, I'd like to talk about garbage
collection and Objective-C properties.

00:00:59.170 --> 00:01:05.870
These are two technologies that you can use to
help manage object life cycles in your application.

00:01:05.870 --> 00:01:11.160
Now, if you've written a manually memory managed application
on Mac OS X before, there are a couple of problems

00:01:11.159 --> 00:01:15.019
that you need to, that you've been
aware of or potentially had to debug.

00:01:15.019 --> 00:01:21.159
For example, if you over release an object or free it
too aggressively, you've probably run into a problem

00:01:21.159 --> 00:01:24.390
with your application crashing,
perhaps due to memory corruption.

00:01:24.390 --> 00:01:29.680
These bugs are typically very difficult
to diagnose and correct.

00:01:29.680 --> 00:01:34.040
Additionally you may have forgot
to release an object or to free it.

00:01:34.040 --> 00:01:37.840
Doing this typically results in a memory leak
in your application, which could range anywhere

00:01:37.840 --> 00:01:42.680
from being a small performance
problem to a major show stopping bug.

00:01:42.680 --> 00:01:46.360
Additionally you've had to worry
about the problem of retain cycles.

00:01:46.359 --> 00:01:50.400
A retain cycle is where you have one object
that has a strong reference to a second object

00:01:50.400 --> 00:01:54.050
and that second object has a strong
reference back to the first.

00:01:54.049 --> 00:01:59.859
This is a specialized form of leak and these two objects
retaining each other causes them both to stay alive.

00:01:59.859 --> 00:02:04.359
Now, you may have even become good at
diagnosing these problems and fixing them,

00:02:04.359 --> 00:02:09.180
but you're having to devote mental capacity in
order to keep your application functioning properly

00:02:09.180 --> 00:02:12.530
and to not commit these sort of
problems in your application.

00:02:12.530 --> 00:02:19.960
Garbage collection that comes to us on Mac OS X, 10.5
Leopard with Objective-C helps you just eliminate worrying

00:02:19.960 --> 00:02:22.500
about these type of problems in your application.

00:02:22.500 --> 00:02:26.099
Garbage collection can also give you a bit
of concurrency for free in your application.

00:02:26.099 --> 00:02:32.169
If you have one thread in your application that's
busy computing results for some important user task,

00:02:32.169 --> 00:02:35.339
the objects that you're generating while
doing this computation can be collected

00:02:35.340 --> 00:02:37.370
in the background by the garbage collector.

00:02:37.370 --> 00:02:39.379
This gives you some immediate concurrency.

00:02:39.379 --> 00:02:43.539
There are a couple of things you need to
know when migrating to garbage collection.

00:02:43.539 --> 00:02:46.090
One of them is that there are many
APIs that you might interact

00:02:46.090 --> 00:02:49.000
with that aren't themselves dealing
with garbage detective memory.

00:02:49.000 --> 00:02:52.960
For example, if you're using core
foundation types in your application,

00:02:52.960 --> 00:02:56.490
you'll still need to call CF release
and CF retain on them manually.

00:02:56.490 --> 00:03:02.120
Optionally you can opt those CF type objects into
garbage collection with the CF make collectible call.

00:03:02.120 --> 00:03:07.969
A second technique that's available to us
through Objective-C 2.0 are properties.

00:03:07.969 --> 00:03:15.169
Properties are all about simplifying the way that we
declare, define and use the attributes of our object.

00:03:15.169 --> 00:03:18.189
The best way to talk about properties
is with an illustration.

00:03:18.189 --> 00:03:22.650
Here we have a hypothetical My Person class and
we're looking at the header file for that class.

00:03:22.650 --> 00:03:25.700
In that header file, we have a number
of accessors declared to control things

00:03:25.699 --> 00:03:28.729
such as the first name, the last name, and the full name.

00:03:28.729 --> 00:03:38.039
If we were to flip to the implementation file for
this source file, we'd see code similar to this.

00:03:38.039 --> 00:03:42.259
This code isn't interesting, it's kind of
long, and it's exactly the kind of code

00:03:42.259 --> 00:03:44.919
that you're going to gloss right over during code review.

00:03:44.919 --> 00:03:48.039
This makes it susceptible to problems
like copy and paste bugs

00:03:48.039 --> 00:03:53.269
where you have one property that's inadvertently
controlling the wrong instance variable.

00:03:53.270 --> 00:03:58.530
Objective-C properties help us eliminate
these problems in our source code.

00:03:58.530 --> 00:04:02.960
So here's an example of the same class
implemented with Objective-C properties.

00:04:02.960 --> 00:04:06.830
The first thing you'll probably notice
is that in the interface for this class,

00:04:06.830 --> 00:04:09.750
we've used this new Ap Property compiler directive.

00:04:09.750 --> 00:04:15.060
The Ap Property compiler directive tells the
compiler this class is going to have an accessor pair

00:04:15.060 --> 00:04:18.860
for in this case a first name property
that's of type string.

00:04:18.860 --> 00:04:24.449
And that copy indicates that when setting the string
for the first name, we're going to use copy semantics.

00:04:24.449 --> 00:04:29.269
We've done the same thing for last name and then
declared an additional read only property full name.

00:04:29.269 --> 00:04:32.959
That full name property is declared read only because
it's actually a derived property that we're going

00:04:32.959 --> 00:04:35.909
to base off of the first name and last name.

00:04:35.910 --> 00:04:40.780
If we flip to the implementation file, the first thing
you'll probably notice is that it fits all here on one page.

00:04:40.779 --> 00:04:42.009
It's very short.

00:04:42.009 --> 00:04:45.139
All the redundancy of getters and setters is eliminated.

00:04:45.139 --> 00:04:50.899
We're able to use the At Synthesize compiler directive
to ask the compiler to automatically generate getters

00:04:50.899 --> 00:04:56.959
and setters for our first name and last name properties
that correspond to the properties in our interface file.

00:04:56.959 --> 00:05:01.239
We're also able to go ahead and
implement the full name accessor our self.

00:05:01.240 --> 00:05:05.050
This allows us to have full control over the
implementation of properties if we'd like them.

00:05:05.050 --> 00:05:11.650
And it's a great place for us to add custom logic for
properties that are based on the values of other properties.

00:05:11.649 --> 00:05:19.349
In addition to helping you declare and implement
accessors for your attributes, properties also give you,

00:05:19.350 --> 00:05:23.310
give clients a new way to access state of objects.

00:05:23.310 --> 00:05:25.040
And that's with the dot syntax.

00:05:25.040 --> 00:05:33.250
The dot syntax is syntactic sugar that still translates
to the familiar getter and setter messages at runtime.

00:05:33.250 --> 00:05:36.279
But by using the dot syntax, you
can be more clear in your code.

00:05:36.279 --> 00:05:41.899
It's clear when you see person.firstname = Bill
that you're just configuring the person object.

00:05:41.899 --> 00:05:47.319
Another benefit of using the dot
syntax is better code completion.

00:05:47.319 --> 00:05:51.819
If you were to type [person codecomplete] in X Code,

00:05:51.819 --> 00:05:55.860
you'd get a list of all selector messages
which are valid to send to this person.

00:05:55.860 --> 00:06:00.050
That's going to include lots of messages
that are valid for every NS object.

00:06:00.050 --> 00:06:04.150
With properties, you get exactly the set of
properties that are available to this object,

00:06:04.149 --> 00:06:06.979
which gives you a much more precise code completion list.

00:06:06.980 --> 00:06:14.020
So properties help you clarify your API
and give you a nice concise expression.

00:06:14.019 --> 00:06:17.669
In your header file, it's really clear what
method you use to configure the state of an object

00:06:17.670 --> 00:06:20.280
when you use the At Property compiler directive.

00:06:20.279 --> 00:06:24.719
And it lets you clearly differentiate between state and
behavior because if you adopt properties everywhere,

00:06:24.720 --> 00:06:28.500
all of the property methods are used to configure
state and all of the other messages are used

00:06:28.500 --> 00:06:32.600
to make the object do things that control its behavior.

00:06:33.670 --> 00:06:37.750
If you'd like to learn more about garbage
collection in Objective-C properties,

00:06:37.750 --> 00:06:45.089
tomorrow at 5 PM in Russian Hill the Objective-C and
garbage collection advancement session will take place.

00:06:45.089 --> 00:06:48.779
The next set of technology that I'd like
to look at are things that you can use

00:06:48.779 --> 00:06:53.629
to help eliminate model view controller
glue code in your applications.

00:06:53.629 --> 00:06:56.189
The first of these is key-value observing.

00:06:56.189 --> 00:07:02.689
Key-value observing is all about eliminating the
direct coupling of your controllers from your models.

00:07:02.689 --> 00:07:07.939
In a model view controller application, it's the model's
job to notify the controller when changes take place.

00:07:07.939 --> 00:07:12.680
And that typically means that you have to have
a manual notification code in your models.

00:07:12.680 --> 00:07:16.620
Now where that code is and how it
gets posted is typically really driven

00:07:16.620 --> 00:07:19.379
by how your controllers want to interpret those messages.

00:07:19.379 --> 00:07:23.639
And so you really do have sort of the design of
the controllers driving the design of the model.

00:07:23.639 --> 00:07:29.149
You can help break that down and have two more
independent set of classes by using key-value observation.

00:07:29.149 --> 00:07:35.229
Key-value observation is a way for a controller object
or really any object to register that it's interested

00:07:35.230 --> 00:07:37.629
in change notifications for a second object.

00:07:37.629 --> 00:07:42.350
So a key in key-value coding is just a
short string like first name, or last name,

00:07:42.350 --> 00:07:45.170
or full name if we were to consider
our people example earlier.

00:07:45.170 --> 00:07:51.920
And a controller object that's managing people can register
for change notifications whenever a person object changes.

00:07:51.920 --> 00:07:55.879
Now all a person object needs to do to
cooperate with key-value observation

00:07:55.879 --> 00:08:02.719
and be observable is really just use its
own setters in order to mutate its state.

00:08:02.720 --> 00:08:05.440
Key-value observation is really a foundational technology.

00:08:05.439 --> 00:08:06.740
Lots of things are built on top of it.

00:08:06.740 --> 00:08:13.560
An example of something that's built on top
of key-value observation is Cocoa Bindings.

00:08:13.560 --> 00:08:19.230
Cocoa Bindings really let you eliminate the
whole swaths of model view controller glue code.

00:08:19.230 --> 00:08:25.189
So for example, in a typical model view controller
application, you might have a window with a text field on it

00:08:25.189 --> 00:08:30.310
and when the text field has a value entered in it
by the user, the text field notifies a controller.

00:08:30.310 --> 00:08:35.259
And the controller reacts to that value being
entered and decides to modify a model object.

00:08:35.259 --> 00:08:41.350
The model object might have cascading changes that
are caused by this change and after the changes,

00:08:41.350 --> 00:08:44.220
while all the changes occur the
model notifies the controller.

00:08:44.220 --> 00:08:48.300
Which in turn captures those notifications
of changes to reupdate the view.

00:08:48.299 --> 00:08:53.399
This is exactly the kind of code that
Cocoa Bindings eliminate for you.

00:08:53.399 --> 00:08:59.439
They help do that data passing all the way from your
view to your model and back again without you having

00:08:59.440 --> 00:09:02.340
to write code to shuttle it at each stage.

00:09:02.340 --> 00:09:08.170
So the way you use Cocoa Bindings are you can go into for
example Interface Builder and select some element that's

00:09:08.169 --> 00:09:15.029
in your user interface and you can tell that
element that it is bound to a specific attribute.

00:09:15.029 --> 00:09:19.860
For example first name on a controller where
that controller manages a list of people.

00:09:19.860 --> 00:09:24.200
And now you'll have a text field that's able
to control the first name attribute of people.

00:09:24.200 --> 00:09:30.120
Cocoa Bindings make it really easy to deal with things
like multiple selection or single selection of course

00:09:30.120 --> 00:09:32.700
or not applicable selection or an empty selection.

00:09:32.700 --> 00:09:35.890
They really make it as easy as handling
the standard single selection case.

00:09:35.889 --> 00:09:39.519
So using Cocoa Bindings is a great way
to eliminate model view controller code

00:09:39.519 --> 00:09:44.000
from your application while still
keeping a model view controller design.

00:09:44.000 --> 00:09:49.590
You can learn more about Cocoa Bindings
in Exploring Cocoa Bindings tutorial lab.

00:09:49.590 --> 00:09:55.720
That's today at 330 PM in Mac OS X lab B.

00:09:55.720 --> 00:09:58.700
Next I'd like to look at some refactoring
opportunities that are available to you

00:09:58.700 --> 00:10:02.430
with new classes in the AppKit and new language features.

00:10:02.429 --> 00:10:06.149
The first of these are view controllers.

00:10:06.149 --> 00:10:12.480
View controllers are all about dividing up the discrete
areas of responsibility inside of multi -component windows.

00:10:12.480 --> 00:10:18.009
So here's an example of a common interface lay
out that we'll see in applications on Mac OS X.

00:10:18.009 --> 00:10:21.659
I like to call it the master master detail interface.

00:10:21.659 --> 00:10:26.259
So in this application, we might have a source list
where a selection in the source list drives what appears

00:10:26.259 --> 00:10:28.710
in the content area, which is probably another list.

00:10:28.710 --> 00:10:32.070
And selection in the content area
drives what appears in the detail area.

00:10:32.070 --> 00:10:37.800
An application that uses this pattern might be mail
where you have your mailboxes in the source section,

00:10:37.799 --> 00:10:42.559
your messages in the content section, and the
content of each message in the detail section.

00:10:42.559 --> 00:10:48.619
RSS readers and X Code are another example of
applications, which typically follow this pattern.

00:10:48.620 --> 00:10:53.860
So view controllers are available to you in Mac
OS 10.5, Leopard through the application kit

00:10:53.860 --> 00:10:58.990
and are really a formalized way for you to break
down this sort of application in your source code.

00:10:58.990 --> 00:11:05.139
Before view controllers, you might have implemented
such a window with just one monolithic window controller

00:11:05.139 --> 00:11:09.850
where the window controller is responsible for managing
the source list, the content list, and the detail area.

00:11:09.850 --> 00:11:12.750
Or you might have written your own set
of classes to break this functionality

00:11:12.750 --> 00:11:15.070
down into its different discrete components.

00:11:15.070 --> 00:11:17.300
But that would've been something you rolled yourself.

00:11:17.299 --> 00:11:19.669
You might not have followed that pattern consistently.

00:11:19.669 --> 00:11:23.529
By using view controllers in your application,
you can use the same sort of pattern everywhere

00:11:23.529 --> 00:11:25.769
and really cleanly factor your source code.

00:11:25.769 --> 00:11:30.500
That'll help make it more malleable in the future should
you decide to change the way your application works.

00:11:30.500 --> 00:11:36.269
Another exciting technology that's
available on Snow Leopard are blocks.

00:11:36.269 --> 00:11:39.379
Blocks are really changing the
way we do all sorts of things.

00:11:39.379 --> 00:11:42.370
Blocks are all about making callbacks dead simple.

00:11:42.370 --> 00:11:47.490
One of the complicated parts of doing
callbacks before blocks is context management.

00:11:47.490 --> 00:11:53.060
Typically the callback function that you'd like to have
invoked by some service needs some data to be passed to it.

00:11:53.059 --> 00:11:57.939
Blocks eliminate out of band data passing
between context functions and the person

00:11:57.940 --> 00:12:02.820
that invoked the operation that
was going to involve a callback.

00:12:04.299 --> 00:12:06.990
I'd like to illustrate blocks with an example.

00:12:06.990 --> 00:12:13.399
We have the people object we talked about
earlier and this is going to be a method

00:12:13.399 --> 00:12:17.149
that sorts those people objects by a particular key.

00:12:17.149 --> 00:12:20.350
Where key is something like the first name or the last name.

00:12:20.350 --> 00:12:23.519
It's the same kind of key that we
would use in key-value observation.

00:12:23.519 --> 00:12:24.879
And we want to do a stable sort.

00:12:24.879 --> 00:12:29.419
And if you're not familiar with a stable sort, a
stable sort doesn't mean that it's not a buggy sort.

00:12:29.419 --> 00:12:32.199
It means a sort that's going to sort in a specific order.

00:12:32.200 --> 00:12:37.940
For example, if you have two objects in the input array
that would be tied in terms of the comparison function,

00:12:37.940 --> 00:12:41.330
they'll appear in the output array in the
order they appeared in the original array.

00:12:41.330 --> 00:12:47.350
So for example, if our original array had two people
Matt Gamble and Matt Furlick appearing in this order,

00:12:47.350 --> 00:12:51.790
and they were sorted based on the first name, there
would be a tie because they're both named Matt.

00:12:51.789 --> 00:12:58.629
With a stable sort, Matt Gamble who appeared first in the
original array would appear first in the output array.

00:12:58.629 --> 00:13:00.389
Many sort routines are not stable.

00:13:00.389 --> 00:13:03.949
And so they don't give you the same variant.

00:13:03.950 --> 00:13:09.280
But you can always build a stable sort on top of an
unstable sort by taking the original order of your objects

00:13:09.279 --> 00:13:11.279
into account in your comparison function.

00:13:11.279 --> 00:13:13.100
That's what I'm going to do in this example.

00:13:13.100 --> 00:13:18.330
So to do this we're going to build a map table.

00:13:18.330 --> 00:13:22.550
The map table is going to hold an entry
for every person that we're sorting.

00:13:22.549 --> 00:13:26.139
We're going to populate that by iterating all
the people in order and putting an integer

00:13:26.139 --> 00:13:30.129
into the map table that's the index at which
that person appeared in the people array.

00:13:30.129 --> 00:13:33.210
Then we're going to ask the array to sort itself.

00:13:33.210 --> 00:13:37.050
And to sort the array, we're going to
pass in a my compare people function.

00:13:37.049 --> 00:13:38.579
Now that's a function pointer.

00:13:38.580 --> 00:13:41.900
And our my compare people function
needs to know how we're sorting.

00:13:41.899 --> 00:13:44.250
For example by first name or by last name.

00:13:44.250 --> 00:13:50.779
And it needs some, and it also needs to know the original
order of the object so that it can do a stable sort.

00:13:50.779 --> 00:13:55.059
To do this, we use this context parameter
that we're needing to pass out of line.

00:13:55.059 --> 00:13:57.159
Now we'll scroll up.

00:13:57.159 --> 00:14:00.069
You'll see some other code that I have
to write in order to make this happen.

00:14:00.070 --> 00:14:02.240
I've got to declare a structure to hold this context.

00:14:02.240 --> 00:14:09.039
These are the arguments that I want to pass
out of line to my compare people function.

00:14:09.039 --> 00:14:11.549
And additionally I've got my function.

00:14:11.549 --> 00:14:13.419
Now this is the meat of my whole routine.

00:14:13.419 --> 00:14:14.860
This is what's actually doing the sorting.

00:14:14.860 --> 00:14:16.509
It's the most interesting part.

00:14:16.509 --> 00:14:19.679
But it's not, it's not in there with the rest of my code.

00:14:19.679 --> 00:14:23.409
I'm having to spread everything out across an entire file.

00:14:23.409 --> 00:14:24.909
Let's look at how we do this with blocks.

00:14:24.909 --> 00:14:29.459
Here I'm going to use exactly the same techniques, but
it's going to take a lot less code and I'm going to get

00:14:29.460 --> 00:14:32.860
to write my code in the order I think
about performing the operations.

00:14:32.860 --> 00:14:38.169
So I'll declare the order table just as
before, but then I'm going to use a new method

00:14:38.169 --> 00:14:41.240
on NS array called enumerate objects using block.

00:14:41.240 --> 00:14:45.129
This method takes a block and the
block takes three parameters.

00:14:45.129 --> 00:14:49.419
The object that's being countered during the
enumeration, the index that that object occurred at,

00:14:49.419 --> 00:14:52.189
and an out parameter that I can
use to terminate iteration early.

00:14:52.190 --> 00:14:56.610
We're going to visit all the objects
and build up our table just like before.

00:14:56.610 --> 00:15:00.769
Then we're going to ask the people
array for a sorted version of itself.

00:15:00.769 --> 00:15:05.860
And we're going to use the new NS array method
from Snow Leopard, sorted array using comparator.

00:15:05.860 --> 00:15:08.730
This method also takes a block and
that block takes two arguments.

00:15:08.730 --> 00:15:15.320
A person A and a person B and it's our job to declare
through the return value of this block what the order is

00:15:15.320 --> 00:15:17.310
that those two people should appear in the output array.

00:15:17.309 --> 00:15:19.589
We're going to sort them exactly as we did before.

00:15:19.590 --> 00:15:23.430
You'll notice here that it didn't have to have any
structure to declare the arguments that I wanted to pass

00:15:23.429 --> 00:15:26.729
into my callback function because in this
case the callback function is a block.

00:15:26.730 --> 00:15:32.310
And the block is able to close over the lexical scope
of where it's created and access all those variables.

00:15:32.309 --> 00:15:37.500
So here in my block callback I'm able to just
access our order table and our key argument

00:15:37.500 --> 00:15:40.289
without having to have any out of line data.

00:15:40.289 --> 00:15:44.699
This really helps me write the code
in the order that I think about it.

00:15:44.700 --> 00:15:47.170
It just flows much more naturally.

00:15:47.169 --> 00:15:49.909
It also helps me keep my file name space tidy.

00:15:49.909 --> 00:15:54.500
I don't have to have these pieces of functionality
that are exactly interesting to one function living

00:15:54.500 --> 00:15:59.360
at file name space and sort of being available
for example in the X Code, function pop up

00:15:59.360 --> 00:16:05.360
or just you know being potentially interesting to people
when really they're particular to my one function.

00:16:05.360 --> 00:16:11.100
So you can learn more about blocks in
Programming with Blocks in Grand Central Dispatch.

00:16:11.100 --> 00:16:13.610
That's tomorrow at 2 PM in the Marina.

00:16:13.610 --> 00:16:19.500
That concludes the code clarifying technologies
that I wanted to take you through today.

00:16:19.500 --> 00:16:21.870
Now I'd like to look at some performance opportunities.

00:16:21.870 --> 00:16:27.820
Everything is 64-bit.

00:16:27.820 --> 00:16:32.120
You should absolutely be making your
application 64-bit for Mac OS X Snow Leopard.

00:16:32.120 --> 00:16:35.810
One of the main features that you're going to
get by migrating to 64-bit are there are twice

00:16:35.809 --> 00:16:41.569
as many registers available in X8664 architecture
versus the previous I386X architecture.

00:16:41.570 --> 00:16:45.190
This is going to mean that the code that
your application, that the compiler generates

00:16:45.190 --> 00:16:48.660
for your application is going to be able to run faster.

00:16:48.659 --> 00:16:53.159
When we added Objective-C 2.0 to
Leopard, there were some features

00:16:53.159 --> 00:16:55.360
that we couldn't add without breaking binary compatibility.

00:16:55.360 --> 00:16:58.300
And we never want to break binary compatibility.

00:16:58.299 --> 00:17:03.579
So in order to add these features, we
only added them to the new 64-bit runtime.

00:17:03.580 --> 00:17:08.059
While not having a history, we could, we could
change things there and give you some new features.

00:17:08.059 --> 00:17:11.429
An example of some of those are
no fragile base class problem.

00:17:11.430 --> 00:17:17.660
So you can redeclare instance variables in a
framework class that's sub classed in other binaries

00:17:17.660 --> 00:17:20.670
without having to recompile the other classes.

00:17:20.670 --> 00:17:25.539
You also get instance variable synthesis, which means that
you don't have to declare instance variables to match each

00:17:25.539 --> 00:17:28.279
of the properties that you're using
with ApProperty and ApSynthesize.

00:17:28.279 --> 00:17:31.399
And finally you get zero cost unified exceptions.

00:17:31.400 --> 00:17:35.810
This means that the same exception
mechanism is used for C++ and Objective-C.

00:17:35.809 --> 00:17:38.460
And it means that entering a try block is cheap.

00:17:38.460 --> 00:17:43.610
Before entering a try block was
expensive and now it's really inexpensive.

00:17:43.609 --> 00:17:47.129
All apps should be 64-bit on Sdnow Leopard.

00:17:47.130 --> 00:17:52.290
We're increasingly shipping more
and more of our content as 64-bit.

00:17:52.289 --> 00:17:56.319
We have, today I'm telling you all about
frameworks and technologies and all these frameworks

00:17:56.319 --> 00:18:02.000
and technologies you get to leverage really cheaply in your
application because we've written lots of code for you.

00:18:02.000 --> 00:18:05.730
All of that code that we've written is compiled two ways.

00:18:05.730 --> 00:18:08.890
It's compiled for 32-bit and it's compiled for 64-bit.

00:18:08.890 --> 00:18:14.270
And when you run your application as either
a 64-bit process odr a 32-bit process,

00:18:14.269 --> 00:18:16.629
you automatically use the right set of this code.

00:18:16.630 --> 00:18:22.760
Now at the point where we get to having no 32-bit processes,
none of that 32-bit framework stack will need to be loaded.

00:18:22.759 --> 00:18:26.950
And if you're the last application on
the user's machine that's running 32-bit,

00:18:26.950 --> 00:18:30.350
it's going to mean that your application is
going to fault in all of those frameworks.

00:18:30.349 --> 00:18:33.719
And that's going to be expensive both
in terms of I/O time and memory usage

00:18:33.720 --> 00:18:37.360
because all those 32-bit frameworks aren't
going to be amortized across multiple processes.

00:18:37.359 --> 00:18:39.539
They'll only be used by yours.

00:18:39.539 --> 00:18:43.559
So don't be the last 32-bit application on a user's machine.

00:18:43.559 --> 00:18:50.179
Finally, you should absolutely use the 64-bit transition
guide when transitioning your application to 64-bit.

00:18:50.180 --> 00:18:55.120
It's a guide that points out lots of things that you need to
be aware of when transitioning to 64-bit and it adlso comes

00:18:55.119 --> 00:19:00.989
with a helpful conversion script that does
much of brunt work of translation for you.

00:19:00.990 --> 00:19:04.839
The next technology that I'd like to discuss
with you today is Grand Central Dispatch.

00:19:04.839 --> 00:19:08.679
Concurrency is a unifying theme in Snow Leopard.

00:19:08.680 --> 00:19:15.060
As our machines have more and more CPU cores, we have
to leverage parallelism to make our applications faster.

00:19:15.059 --> 00:19:20.690
Now, I like to start thinking about Grand Central
Dispatch by thinking of a technique called thread pooling.

00:19:20.690 --> 00:19:26.740
If you have an application with lots of units of work
that you'd like to do, for example an application

00:19:26.740 --> 00:19:32.210
like X Code you might want to index dozens,
hundreds, or thousands of source files.

00:19:32.210 --> 00:19:35.769
You could do this by just creating one thread
for each source file you wanted to index.

00:19:35.769 --> 00:19:38.240
But if you had 1000 source files,
that would be very expensive.

00:19:38.240 --> 00:19:46.210
It would be expensive because scheduling threads takes
time and threads all require data in order to operate.

00:19:46.210 --> 00:19:48.400
They all have large stack space, hundreds of kilobytes.

00:19:48.400 --> 00:19:52.259
So you don't want to create a huge number of
threads proportional to your number of jobs.

00:19:52.259 --> 00:19:56.960
Instead you want to create a number of threads proportional
to the execution resources that are actually available

00:19:56.960 --> 00:20:00.420
on your machine and then have your
jobs run on those threads.

00:20:00.420 --> 00:20:06.570
A problem with this technique in many times is
that lots of libraries implement this internally.

00:20:06.569 --> 00:20:12.119
And then rather than each library creating just the right
number of threads, you wind up with N times as many threads

00:20:12.119 --> 00:20:16.259
as you should have given that where N is the
number of libraries that implement this technique.

00:20:16.259 --> 00:20:20.230
Grand Central Dispatch comes in and implements
this technique at a low level in the system

00:20:20.230 --> 00:20:24.920
so that everyone can be built on top of it
and we can get better system utilization

00:20:24.920 --> 00:20:28.230
by creating just the right number
of threads on each machine.

00:20:28.230 --> 00:20:30.900
So Grand Central Dispatch works in terms of blocks.

00:20:30.900 --> 00:20:35.810
It uses blocks as the currency of concurrency.

00:20:35.809 --> 00:20:39.480
Each block is one unit of work or
one task that you might want to do.

00:20:39.480 --> 00:20:42.610
And with Grand Central Dispatch,
you schedule those blocks on queues.

00:20:42.609 --> 00:20:44.479
You can schedule them on two kinds of queues.

00:20:44.480 --> 00:20:46.849
The first kind a serial queue.

00:20:46.849 --> 00:20:50.619
You schedule blocks on a serial queue and they'll
run in the order they were added to the queue.

00:20:50.619 --> 00:20:56.089
But you have lots of queues that are serial queues
and each queue runs independently and concurrently

00:20:56.089 --> 00:20:59.859
with respect to the rest, but serially internally.

00:20:59.859 --> 00:21:01.639
You also have concurrent queues.

00:21:01.640 --> 00:21:05.430
A concurrent queue is a place where you can place
a block and just have it execute concurrently

00:21:05.430 --> 00:21:08.140
with respect to all of your other queues and blocks.

00:21:08.140 --> 00:21:11.690
So Grand Central Dispatch gives
you new synchronization concepts.

00:21:11.690 --> 00:21:17.269
Rather than perhaps having a mutual exclusion law
that you use to protect shared data and you run code

00:21:17.269 --> 00:21:21.589
for multiple threads and use the block for
exclusion, you can actually run all of your code

00:21:21.589 --> 00:21:26.889
that accesses the shared data on the same thread by
guarding it with one Grand Central Dispatch queue

00:21:26.890 --> 00:21:30.390
and placing blocks that access that data on the queue.

00:21:30.390 --> 00:21:35.670
So because of blocks, this type of callback
mechanism to do concurrency becomes really easy.

00:21:35.670 --> 00:21:39.860
You get to capture the state you want and execute it
on the right time on the right thread without having

00:21:39.859 --> 00:21:43.750
to write a bunch of P Thread code to put that all together.

00:21:43.750 --> 00:21:48.319
Besides just raw concurrency, Grand Central
Dispatch also gives you event monitoring.

00:21:48.319 --> 00:21:53.129
You can use Grand Central Dispatch to
for example ask for a notification.

00:21:53.130 --> 00:21:57.480
And the way you'll get a notification is by providing
a block and a queue that you'd like to be executed on.

00:21:57.480 --> 00:21:59.630
And an example of such a notification would be

00:21:59.630 --> 00:22:05.300
to have your block executed whenever file I/O becomes
available, perhaps on a socket that you're reading.

00:22:05.299 --> 00:22:11.339
You can also monitor files moving on
disks, processes dying and UNIX signals.

00:22:12.890 --> 00:22:18.440
Built on top of Grand Central Dispatch in Snow
Leopard is NSOperation and NSOperationQueue.

00:22:18.440 --> 00:22:23.950
Now NSOperation and NSOperationQueue also predate
Grand Central Dispatch and exist on Leopard.

00:22:23.950 --> 00:22:27.650
These are the Cocoa abstractions to
these parallel programming techniques.

00:22:27.650 --> 00:22:32.990
By programming at this higher level, you can be
abstracted from how system changes happen underneath you.

00:22:32.990 --> 00:22:39.410
Additionally you can target Leopard where NSOperation
and NSOperationQueue are also fully supported.

00:22:39.410 --> 00:22:45.490
One feature that these classes offer above what you get
with Grand Central Dispatch is dependency management.

00:22:45.490 --> 00:22:48.789
You can declare that some operation,
which is a unit of work just like a block

00:22:48.789 --> 00:22:52.049
in Grand Central Dispatch, is dependent
on some other operations.

00:22:52.049 --> 00:22:57.379
And you can queue them all together and the operation
system will figure out how to execute your operations

00:22:57.380 --> 00:23:00.400
in the right order so that all
the dependencies are satisfied.

00:23:00.400 --> 00:23:07.360
So I told you that concurrency was an important
theme for all of Snow Leopard and everywhere today.

00:23:07.359 --> 00:23:09.359
We're backing that up with all these sessions.

00:23:09.359 --> 00:23:12.250
You can get started learning about
concurrency in your Cocoa applications

00:23:12.250 --> 00:23:14.900
in Designing your Cocoa Application for Concurrency.

00:23:14.900 --> 00:23:22.440
And that's going to take place in
this same room today at 330 PM.

00:23:22.440 --> 00:23:28.559
So Grand Central Dispatch and NSOperation I told you about
how to take advantage of your CPU and its multiple cores.

00:23:28.559 --> 00:23:33.450
But if you really want to get maximum parallelism in
your application, you need to take advantage of all

00:23:33.450 --> 00:23:36.190
of the execution cores that are available on your machine.

00:23:36.190 --> 00:23:43.549
Your machine also has a GPU and it has dozens and dozens
of cores that are able to execute code extremely quickly.

00:23:43.549 --> 00:23:48.759
Typically taking advantage of your GPU for general
purpose programming tasks has been difficult.

00:23:48.759 --> 00:23:54.089
You've had to write vendor specific code and
only operate on machines that have hardware

00:23:54.089 --> 00:23:59.099
that matches your vendor specific code that you used.

00:23:59.099 --> 00:24:06.389
With OpenCL you get to program in a familiar C99-like
language that's cross-platform and an open standard.

00:24:06.390 --> 00:24:10.660
By targeting the GPU you can get huge performance
increases by having lots of parallelism.

00:24:10.660 --> 00:24:13.830
And these GPUs are great at executing
a specific kind of task.

00:24:13.829 --> 00:24:15.970
And that's a data parallel task.

00:24:15.970 --> 00:24:19.490
What I mean by data parallel, is that you have
the same block of code that you want to run over

00:24:19.490 --> 00:24:23.589
and over again on different segments of data.

00:24:23.589 --> 00:24:26.619
Your GPU is great at executing that.

00:24:26.619 --> 00:24:31.459
Another benefit of targeting OpenCL
is OpenCL uses dynamic compilation.

00:24:31.460 --> 00:24:36.990
That means that when you write your program in source form
and when it's time to run it, OpenCL compiles that program

00:24:36.990 --> 00:24:40.460
down to the best instructions that
run on the GPU that's in your machine.

00:24:40.460 --> 00:24:47.180
Additionally OpenCL can target the CPU and the CPU might run
a different set of instructions, well it's obviously going

00:24:47.180 --> 00:24:49.810
to run a different set of instructions, than your GPU.

00:24:49.809 --> 00:24:53.639
But where this gets interesting is when
your application is deployed on a machine

00:24:53.640 --> 00:24:57.460
that doesn't have a fully programmable
GPU that can run your OpenCL program.

00:24:57.460 --> 00:24:59.700
OpenCL lets you run that program on the CPU.

00:24:59.700 --> 00:25:04.410
Thursday is the day for OpenCL

00:25:04.410 --> 00:25:07.400
On Thursday in the Marina all day
you can learn about OpenCL.

00:25:07.400 --> 00:25:15.180
At 9 AM, 1030 AM and 200 PM and then again in the
Graphics and Media Lab B at 330 PM are OpenCL sessions.

00:25:15.180 --> 00:25:20.830
Now I'd like to talk to you about some
media technologies that are in Mac OS X

00:25:20.829 --> 00:25:23.819
that you can use to really just dazzle your users.

00:25:23.819 --> 00:25:28.829
The first of these is QT Kit.

00:25:28.829 --> 00:25:36.139
QT Kit is the Cocoa interface to QuickTime and
QuickTime is the media framework for Mac OS X.

00:25:36.140 --> 00:25:43.100
With QT Kit, you can leverage QuickTime to do media
playback, editing, capture, import, and export.

00:25:43.099 --> 00:25:47.859
And what's exciting about QT Kit is that in
Snow Leopard, it's built on top of QuickTime 10.

00:25:47.859 --> 00:25:51.779
QuickTime 10 is a lightweight media playback
framework with improved thread safety.

00:25:51.779 --> 00:25:55.970
It's fully 64-bit and it supports modern codecs.

00:25:55.970 --> 00:26:02.440
You can learn more about QT Kit and
QuickTime in Transitioning to QuickTime 10,

00:26:02.440 --> 00:26:09.370
which takes place in the Marina today at 200 PM.

00:26:09.369 --> 00:26:10.859
Next is OpenGL.

00:26:10.859 --> 00:26:16.799
I told you all about how you can leverage your
GPU with OpenCL to do concurrent programming.

00:26:16.799 --> 00:26:20.789
You can also use it for its original
task, which is great 2D and 3D graphics.

00:26:20.789 --> 00:26:24.809
So on Mac OS X, OpenGL is the primary interface for the GPU.

00:26:24.809 --> 00:26:29.569
And lots of the other media technologies that I'm
talking about today are built on top of OpenGL.

00:26:29.569 --> 00:26:32.169
It's a really exciting time for OpenGL right now.

00:26:32.170 --> 00:26:35.769
OpenGL 3.0 is improving and expanding rapidly.

00:26:35.769 --> 00:26:40.690
OpenGL is available on all of our platforms so
you can do OpenGL programming on the iPhone.

00:26:40.690 --> 00:26:46.230
We saw yesterday that OpenGL ES 2.0
is now available on the iPhone 3GS.

00:26:46.230 --> 00:26:51.490
So it's a really great time for
OpenGL with lots of movement.

00:26:51.490 --> 00:26:55.690
OpenGL Techniques for Snow Leopard is
taking place tomorrow in the Marina

00:26:55.690 --> 00:26:59.160
at 1030 AM where you can learn more about OpenGL.

00:26:59.160 --> 00:27:03.480
Next is Core Animation.

00:27:03.480 --> 00:27:06.500
Core Animation is one of my favorite
of the media technologies.

00:27:06.500 --> 00:27:10.430
Core Animation sits at a high level and
gives you a familiar object abstraction

00:27:10.430 --> 00:27:14.330
for manipulating what they, what
Core Animation refers to as layers.

00:27:14.329 --> 00:27:18.299
And layers are 2D pieces of co-ntent that live in a 3D space.

00:27:18.299 --> 00:27:22.159
With Core Animation you get to define
implicit and explicit animations.

00:27:22.160 --> 00:27:26.360
Explicit animations are the type of animations
you might expect where you say, take this object

00:27:26.359 --> 00:27:30.309
and modify these properties and make
it take place over this amount of time.

00:27:30.309 --> 00:27:32.609
Implicit animations are much more interesting.

00:27:32.609 --> 00:27:38.899
With an implicit animation, you can go to some object and
configure it such that for example when the X parameter

00:27:38.900 --> 00:27:42.840
of this object changes, it should be animated in this way.

00:27:42.839 --> 00:27:46.579
Then later in your program you simply
change the X parameter of your objects

00:27:46.579 --> 00:27:49.109
and they animate in the way you specified earlier.

00:27:49.109 --> 00:27:53.979
Implicit animations make doing
animation with Core Animation great.

00:27:53.980 --> 00:27:57.460
Core Animation also integrates with
all of our other media technologies.

00:27:57.460 --> 00:28:02.170
So you can have custom OpenGL content
in your Core Animation layers,

00:28:02.170 --> 00:28:07.670
you can have custom QuickTime content
and Quartz Composer compositions.

00:28:07.670 --> 00:28:11.880
Finally Core Animation integrates
directly with Cocoa and Cocoa Touch.

00:28:11.880 --> 00:28:20.920
So you can host a Core Animation layer
hierarchy right in an NS view or UI view.

00:28:20.920 --> 00:28:27.920
Core Animation Techniques for iPhone and the Mac
is taking place tomorrow in the Mission at 900 AM.

00:28:27.920 --> 00:28:30.269
You can go there to learn all about Core Animation.

00:28:30.269 --> 00:28:37.089
The next application that I'd like to talk to
you about in media technology is Quartz Composer.

00:28:37.089 --> 00:28:43.509
Quartz Composer ships with the development tools and
it's like a graphics IDE that you can use on Mac OS X.

00:28:43.509 --> 00:28:47.779
You can use it for defining data
driven transitions and effects.

00:28:47.779 --> 00:28:52.359
When you launch Quartz Composer, what
you work with is a network of patches.

00:28:52.359 --> 00:28:55.629
Each patch is a computation unit
that has inputs and outputs.

00:28:55.630 --> 00:29:01.050
And you bring lots of patches together into one document
and wire their inputs and outputs to each other in order

00:29:01.049 --> 00:29:04.960
to form a data flow that describes
a transition or animation.

00:29:04.960 --> 00:29:09.519
Quartz Composer comes with a library filled with
just dozens and dozens and dozens of patches.

00:29:09.519 --> 00:29:13.410
One of the patches is an OpenCL
patch where you can write a custom,

00:29:13.410 --> 00:29:18.700
where you can write custom OpenCL code
for your Quartz Composer compositions.

00:29:18.700 --> 00:29:22.660
When you're working with Quartz
Composer, one of the great features is

00:29:22.660 --> 00:29:25.240
that you get live previews of what
you're doing all the time.

00:29:25.240 --> 00:29:28.470
So while you're in here working in a patch
editor, wiring your patches together,

00:29:28.470 --> 00:29:32.190
you'll have a window on the screen that's
showing you exactly how your changes

00:29:32.190 --> 00:29:36.090
to the patch configuration are going to
affect the transition that you're building.

00:29:36.089 --> 00:29:42.929
You can use the Quartz Composer composition that you
build directly in a Quartz Composer view that's available

00:29:42.930 --> 00:29:45.340
to Cocoa applications through Interface Builder.

00:29:45.339 --> 00:29:54.769
You can also host your Quartz Composer content
directly in a Core Animation application via CLAR.

00:29:54.769 --> 00:30:00.720
Quartz Composer Advances in Snow Leopard is
taking place tomorrow in the Marina at 500 PM.

00:30:00.720 --> 00:30:06.980
There's also a follow on lab on Thursday
at 330 PM in the Graphics and Media Lab A.

00:30:09.950 --> 00:30:14.309
Multi-Touch is really changing the way
that we think about user interfaces.

00:30:14.309 --> 00:30:18.950
Ever since the iPhone brought Multi-Touch
to the foreground it's just been a great way

00:30:18.950 --> 00:30:22.390
for the users to interact with your applications.

00:30:22.390 --> 00:30:29.350
And on Mac OS X Snow Leopard the Application Kit is bringing
Multi-Touch and gesture support to your applications.

00:30:29.349 --> 00:30:34.490
Now, Multi-Touch is the idea that you get to put two
fingers down on the track pad or maybe three fingers

00:30:34.490 --> 00:30:41.660
or any amount really and do some gesture with them and
track all of those fingers moving in space independently.

00:30:41.660 --> 00:30:45.210
Now on top of Multi-Touch, you
get to build things like gestures.

00:30:45.210 --> 00:30:48.259
Where a gesture is an abstraction
of Multi-Touch that is something

00:30:48.259 --> 00:30:51.509
like putting two fingers down and twisting, means to rotate.

00:30:51.509 --> 00:30:58.049
Now rotate is a much more direct way by doing a gesture
like that for the user to interact with your application.

00:30:58.049 --> 00:31:03.970
I find putting two fingers down and rotating
much more intuitive than selecting a text field

00:31:03.970 --> 00:31:05.819
in an inspector and inputting an angle value.

00:31:05.819 --> 00:31:13.109
So with the application kit on Snow Leopard, you
can leverage Multi-Touch directly through NS event

00:31:13.109 --> 00:31:16.959
and you can leverage gestures through NS responder.

00:31:16.960 --> 00:31:20.400
Gestures are actually available on Mac OS 10.5 and later.

00:31:20.400 --> 00:31:24.230
And all of our current laptops have
Multi-Touch capable track pads.

00:31:24.230 --> 00:31:28.500
So there's no reason not for you to start
adopting Multi-Touch in your applications today.

00:31:28.500 --> 00:31:36.460
In this same room tomorrow at 330 PM,
you can learn about User Events in Cocoa

00:31:36.460 --> 00:31:40.610
which will include information
about gestures and Multi-Touch.

00:31:42.430 --> 00:31:46.580
The last technology that I'd like to
talk to you about today is Core Location.

00:31:46.579 --> 00:31:50.309
Core Location is all about building location based services.

00:31:50.309 --> 00:31:54.909
We saw in the keynote yesterday an example of
a Zip Car application that allowed the user

00:31:54.910 --> 00:31:58.320
to find available cars that were near where they were at.

00:31:58.319 --> 00:31:59.789
These kind of applications are great.

00:31:59.789 --> 00:32:02.399
They make using them just a breeze.

00:32:02.400 --> 00:32:08.880
You don't have to do awkward things like enter zip codes to
find out what information is relevant to where you're at.

00:32:08.880 --> 00:32:14.710
I'm always impressed by the different Core Location and
location based service applications that I see on the iPhone

00:32:14.710 --> 00:32:18.009
and I would like all of you to
consider adding location based services

00:32:18.009 --> 00:32:20.750
to your applications and impressing me on Mac OS X.

00:32:20.750 --> 00:32:23.140
You can do that now in the same
way that you do it on the iPhone.

00:32:23.140 --> 00:32:24.300
It's really simple.

00:32:24.299 --> 00:32:27.649
You just link the Core Location
framework into your application,

00:32:27.650 --> 00:32:31.860
create an incidence of the CL Location
manager class, and attach a delegate to it.

00:32:31.859 --> 00:32:37.619
And that delegate will get live notifications
of changes that occur in the user's location.

00:32:37.619 --> 00:32:40.159
And you use that to build location based services.

00:32:40.160 --> 00:32:45.230
So I'm really looking forward to how all of you can impress
me with location based services in your applications.

00:32:45.230 --> 00:32:51.839
You can learn a little bit more about Core Location tomorrow
in the Presidio at 200 PM and with that I'd like to turn it

00:32:51.839 --> 00:32:56.980
over to my colleague Mike Ferris to talk to
you about how you can handle data on Mac OS X.

00:32:56.980 --> 00:33:05.029
>> Hi. I'm Mike Ferris and I work on XCode but today I'm
actually really happy to be able to be here to talk to you

00:33:05.029 --> 00:33:11.339
about some cool Mac OS X technologies that you can
use in your applications to make them really great.

00:33:11.339 --> 00:33:20.609
Now John talked a bit about some of the Objective-C language
features that are really useful to make great applications

00:33:20.609 --> 00:33:25.229
as well as about some important new
foundational technologies and finally about some

00:33:25.230 --> 00:33:29.860
of the presentation technologies to help
you to make your interface really great.

00:33:29.859 --> 00:33:38.029
I'm going to concentrate on the data that your application
produces, what the user authors in your application.

00:33:39.599 --> 00:33:43.539
Almost all applications let the user author data.

00:33:44.589 --> 00:33:47.549
Data of lots of different types and so forth.

00:33:47.549 --> 00:33:52.039
And mostly these applications break
down into one of two categories.

00:33:52.039 --> 00:33:57.730
They can be document-based applications or they
can be what I like to call Shoebox applications.

00:33:58.950 --> 00:34:03.519
In a document-based application, the user
is thinking about creating documents

00:34:03.519 --> 00:34:08.980
They create separate documents for different purposes,
these documents aren't necessarily related to each other,

00:34:08.980 --> 00:34:14.980
and the fact that the user is thinking about the
documents is key to a document-based application.

00:34:14.980 --> 00:34:21.070
You can see examples of some document-based
applications from the icons up on the screen.

00:34:22.280 --> 00:34:27.280
A Shoebox application on the other
hand, the user thinks about working

00:34:27.280 --> 00:34:29.400
with their data altogether in your application.

00:34:29.400 --> 00:34:34.039
Your application is actually the user's focus of attention.

00:34:34.039 --> 00:34:37.309
And all of the data is in there being
organized within the application.

00:34:37.309 --> 00:34:40.500
They're not thinking about authoring separate documents.

00:34:40.500 --> 00:34:47.739
Examples of Shoebox applications include
things like iPhoto, Mail, Address Book.

00:34:47.739 --> 00:34:49.839
People don't think about where they're saving these things.

00:34:49.840 --> 00:34:53.180
They just know that all their stuff is in there.

00:34:53.179 --> 00:34:58.210
Now regardless of which of these
types of applications you're creating,

00:34:58.210 --> 00:35:01.970
there's a couple of decisions that
you should really make up front.

00:35:01.969 --> 00:35:05.799
You want to decide whether to use
NSDocument and then you should decide whether

00:35:05.800 --> 00:35:08.800
or not Core Data is an interesting technology for you.

00:35:08.800 --> 00:35:17.120
Now these are actually independent questions that are not
mutually exclusive and let's tackle them one at a time.

00:35:17.119 --> 00:35:19.579
Whether to use NSDocument, well that's an easy one.

00:35:19.579 --> 00:35:23.900
If you're building a document-based
application, you should use NSDocument.

00:35:23.900 --> 00:35:29.490
If you do, you'll get a lot of advantages.

00:35:29.489 --> 00:35:33.409
You'll write a lot less code for
handling standard document functionality.

00:35:33.409 --> 00:35:38.349
NSDocument deals with running Open and Save panels,
with tracking the dirty state of your document,

00:35:38.349 --> 00:35:41.929
making sure that's coordinated
with per document Undo managers.

00:35:41.929 --> 00:35:48.429
And with associating your documents with the windows
that contain the interfaces that present them.

00:35:48.429 --> 00:35:52.690
Because of this, your document-based
app will get consistent behavior

00:35:52.690 --> 00:35:55.130
with all the other document-based apps on the system.

00:35:55.130 --> 00:36:03.160
They'll be more familiar to the user and the user will know
what to expect when it comes to how to deal with documents.

00:36:04.190 --> 00:36:11.010
It's also worth considering that a lot of these
standard behaviors have complex subtleties

00:36:11.010 --> 00:36:17.680
that are not necessarily really simple
to get right if you're doing it yourself.

00:36:17.679 --> 00:36:26.210
So for example, NSDocument when it goes to save things
it makes sure to handle replacement warning dialogs,

00:36:26.210 --> 00:36:30.720
it saves things atomically to provide better data safety.

00:36:30.719 --> 00:36:34.709
It makes sure that the Recent Documents
menu tracks properly with changes

00:36:34.710 --> 00:36:37.360
that you're making to where documents are stored.

00:36:37.360 --> 00:36:41.410
And it has really good error handling
and presentation built right in.

00:36:41.409 --> 00:36:44.369
You don't have to worry about that stuff.

00:36:44.369 --> 00:36:54.049
Now, also NSDocument has integration with
a number of other important Cocoa features.

00:36:54.050 --> 00:37:00.890
NSDocument works directly with the auto saving functionality
in Cocoa as well as with the new sudden termination APIs

00:37:00.889 --> 00:37:06.489
to make sure that sudden termination gets
turned off when you have unsaved changes

00:37:06.489 --> 00:37:08.179
in any of the documents in your application.

00:37:08.179 --> 00:37:14.210
And then finally, if you're also using Core
Data, NSDocument integrates well with Core Data

00:37:14.210 --> 00:37:18.269
through the NS persistent documents subclass.

00:37:18.269 --> 00:37:24.119
You can go to either of the two Cocoa
Open Labs to learn more about NSDocument

00:37:24.119 --> 00:37:26.279
and ask any questions that you might have.

00:37:26.280 --> 00:37:30.400
And for documentation, you should start
with the Document-based Application Overview

00:37:30.400 --> 00:37:32.829
and the Application Architecture Overview.

00:37:32.829 --> 00:37:38.759
The second question is whether to use Core Data.

00:37:38.760 --> 00:37:41.400
This one's actually a little bit more complicated.

00:37:41.400 --> 00:37:46.570
It really depends what kind of
data your application works with.

00:37:46.570 --> 00:37:51.430
Core Data is really good at managing
interconnected graphs of objects.

00:37:51.429 --> 00:37:56.710
And if you have data that looks like that,
then Core Data may be a great fit for your app.

00:37:56.710 --> 00:37:59.170
There are a couple of caveats.

00:37:59.170 --> 00:38:04.970
First to use Core Data, you really have to be
able to define a fixed schema for your data.

00:38:04.969 --> 00:38:12.199
If the structure of your data is too malleable or if
the user gets to change it and modify it on the fly,

00:38:12.199 --> 00:38:16.929
the structure of your data, then
Core Data may not be the best fit.

00:38:16.929 --> 00:38:20.179
Also Core Data isn't a client-server database solution.

00:38:20.179 --> 00:38:25.960
So if you need to deal with database servers,
Core Data doesn't help you to solve that problem.

00:38:25.960 --> 00:38:29.809
Now it may be that Core Data is a
really great fit for some of the data

00:38:29.809 --> 00:38:33.989
that your application works with but not for other data.

00:38:33.989 --> 00:38:40.279
That's fine, you can use Core Data for whatever
makes sense and then handle the rest of it yourself.

00:38:41.969 --> 00:38:46.209
If you can use Core Data, it brings a lot of advantages.

00:38:46.210 --> 00:38:48.750
Core Data has really great object graph management.

00:38:48.750 --> 00:38:52.389
In fact, I'm going to talk about
that a little bit more in a moment.

00:38:52.389 --> 00:38:58.279
It also has automatic support for
persistence, for data persistence in a number

00:38:58.280 --> 00:39:01.480
of different file formats including SQL Light and XML.

00:39:01.480 --> 00:39:07.579
And if you're using SQL Light, you actually
also get incremental loading and saving

00:39:07.579 --> 00:39:11.539
which can be a huge win if you're
dealing with a lot of data.

00:39:12.739 --> 00:39:19.099
Core Data is directly integrated, in fact it's written
to work well with other technologies like bindings

00:39:19.099 --> 00:39:26.750
and the Cocoa Controller objects, which makes it that much
easier for you to get your data into the user's interface,

00:39:26.750 --> 00:39:32.420
into the user interface where the
user can actually see it and edit it.

00:39:33.760 --> 00:39:42.220
As we heard yesterday or possibly before, Core
Data is now also available in iPhone OS 3.0.

00:39:42.219 --> 00:39:47.199
So that gives you an opportunity if you're using Core
Data to share code between your desktop applications

00:39:47.199 --> 00:39:51.109
and your iPhone applications at the model layer.

00:39:51.110 --> 00:39:58.380
And finally Core Data has direct integration with a
number of other Mac OS X technologies that I'll be talking

00:39:58.380 --> 00:40:01.210
about in a moment such as Sync Services and Spotlight.

00:40:01.210 --> 00:40:11.260
Before we wrap up with Core Data here, I wanted to talk a
little bit more about this object graph management business.

00:40:11.260 --> 00:40:15.720
Everything you do with Core Data takes
place within a managed object context.

00:40:15.719 --> 00:40:22.439
And this managed object context provides a
lot of functionality for you automatically.

00:40:23.489 --> 00:40:30.479
It has Undo support, so any changes that's being made
to your model objects automatically support Undo.

00:40:30.480 --> 00:40:36.159
It has well defined hooks for validation
and for conflict resolution.

00:40:36.159 --> 00:40:45.250
It provides KVO notification as well as Course
or Grain Change notification automatically.

00:40:45.250 --> 00:40:47.820
And it has bidirectional relationship management.

00:40:47.820 --> 00:40:53.130
So if you have you know some of your objects point to
another kind of object and then those objects point back

00:40:53.130 --> 00:40:57.420
to the ones that pointed them, both ends
of that relationship are managed together

00:40:57.420 --> 00:41:01.039
to maintain integrity of your object model.

00:41:01.039 --> 00:41:09.809
And finally it supports delete rules that allow you to
properly propagate delete behavior across relationships.

00:41:12.000 --> 00:41:15.340
We've really, we've just scratched the surface on Core Data.

00:41:15.340 --> 00:41:22.470
And to learn more you can go to the session
this week as well as to the Core Data Lab.

00:41:22.469 --> 00:41:28.049
For documentation you should start with the Core
Data Overview or the Core Data Programming Guide.

00:41:29.829 --> 00:41:35.559
OK before I move on to some of the cool system
integration technologies, I wanted to take a moment to talk

00:41:35.559 --> 00:41:44.019
about where your application and the data that
it creates should fit into the user's system.

00:41:44.019 --> 00:41:50.159
We'll talk about where your application goes, where
the data that the user authors in your application goes

00:41:50.159 --> 00:41:53.940
and where anything else that your
application might need goes.

00:41:55.500 --> 00:41:59.579
Your application should be self contained and relocatable.

00:41:59.579 --> 00:42:06.130
Ideally it should just be a single app bundle that the
user can put wherever you want, wherever they want.

00:42:06.130 --> 00:42:11.650
If that's not possible, if you have a more complex
application, maybe it's a suite of applications that need

00:42:11.650 --> 00:42:17.170
to share frameworks or something, the next best thing
would be to have a folder that contains all of those things

00:42:17.170 --> 00:42:19.980
and make the folder self contained and relocatable.

00:42:19.980 --> 00:42:24.840
This gives the user the greatest flexibility in
terms of where they want to install your application.

00:42:24.840 --> 00:42:36.480
For the data that the user authors within your
application, well in a document-based application,

00:42:36.480 --> 00:42:42.820
the user is thinking about that data as documents
and they should be the one who decides where it goes.

00:42:42.820 --> 00:42:45.730
Your Save panels can default to
the user's documents directory

00:42:45.730 --> 00:42:48.110
but ultimately it's up to them where the stuff gets put.

00:42:48.110 --> 00:42:53.579
But that's not quite the case for Shoebox applications.

00:42:53.579 --> 00:42:58.500
In a Shoebox application, the user really
isn't thinking about where their data goes.

00:42:58.500 --> 00:43:01.219
It's in the app.

00:43:01.219 --> 00:43:05.469
So you need to decide as the app
developer where this data gets stored.

00:43:05.469 --> 00:43:08.230
And generally it should go into the user's library.

00:43:08.230 --> 00:43:12.869
And what you want to do is create a folder in
there that's named for your application identifier

00:43:12.869 --> 00:43:16.799
so that it won't collide with any other application.

00:43:16.800 --> 00:43:21.980
And if you want to be nice about it, you should put a
display name on that folder that's your application's name

00:43:21.980 --> 00:43:29.090
in case the user goes browsing around in
the library, they won't be so confused.

00:43:29.090 --> 00:43:32.370
Finally there's other stuff.

00:43:32.369 --> 00:43:37.250
Sort of optional data that may be accumulated
along the way as the user uses your application.

00:43:37.250 --> 00:43:42.030
This is the sort of thing that you can put
into the user's application support folder.

00:43:42.030 --> 00:43:48.940
Application preferences should just be managed through
NSUserDefaults, let it worry about where to put it.

00:43:48.940 --> 00:43:53.690
If you're generating cache data, there's a
special folder for that, the user's Caches folder.

00:43:53.690 --> 00:44:00.909
And then finally if you have the need to create
temporary data, you should use a temp folder for that.

00:44:00.909 --> 00:44:05.739
Now I've talked about a bunch of locations
and sort of mentioned them by name.

00:44:05.739 --> 00:44:11.519
There are APIs on the system that will help you
to find out where these specific places are.

00:44:11.519 --> 00:44:16.059
The main one is NSSearchPathforDirectoriesandDomain.

00:44:16.059 --> 00:44:22.860
This API you basically give it a constant that identifies
a special place and it'll return to you the path

00:44:22.860 --> 00:44:26.670
where you should put the path for that folder.

00:44:26.670 --> 00:44:31.010
So the application folder or the document folder, et cetera.

00:44:31.010 --> 00:44:35.700
For temporary directories, there's actually a
specific API and its temporary directory can be used

00:44:35.699 --> 00:44:39.909
to find a secure location to store temporary files.

00:44:39.909 --> 00:44:43.730
OK, enough about disk drives.

00:44:43.730 --> 00:44:46.900
Just to review for a second.

00:44:46.900 --> 00:44:50.150
We've decided whether we're using NSDocument.

00:44:50.150 --> 00:44:53.349
We've decided whether we're using Core Data.

00:44:53.349 --> 00:44:57.809
Now let's talk about how your application can
make sure that the data that the user authors

00:44:57.809 --> 00:45:03.250
with it fits really well into the
user's overall environment.

00:45:03.250 --> 00:45:08.429
The user creates things with your application
and it may be the primary place where they work

00:45:08.429 --> 00:45:11.449
with the things that they create in your application.

00:45:11.449 --> 00:45:13.719
But that's not all they do.

00:45:13.719 --> 00:45:17.489
Sometimes when they're not in your
application, they may want to find things.

00:45:17.489 --> 00:45:19.759
They want to preview things.

00:45:19.760 --> 00:45:22.240
They want to show things to other people.

00:45:22.239 --> 00:45:26.889
Maybe they want to synchronize data
between multiple different devices.

00:45:26.889 --> 00:45:33.009
Your application can make it possible for them to
do that with the data from your application as well.

00:45:35.409 --> 00:45:40.190
Before we get into the individual technology
though, a lot of these things are predicated

00:45:40.190 --> 00:45:46.360
on understanding how Mac OS X deals with file types.

00:45:46.360 --> 00:45:51.870
And this is actually a key concept that you
should be sure to familiarize yourself with.

00:45:51.869 --> 00:45:55.079
Data comes in lots of different flavors or types.

00:45:55.079 --> 00:46:04.009
And on Mac OS X we use UTI, uniform type
identifiers to specify what the type of a file is.

00:46:04.010 --> 00:46:09.350
UTIs can also be used to map back and forth
between MIME types or path extensions,

00:46:09.349 --> 00:46:16.069
but it's the UTI that's the primary
means of identification for file types.

00:46:16.070 --> 00:46:18.150
They're used all over the system.

00:46:18.150 --> 00:46:23.960
Launch services uses these to associate documents
with the applications that can open them.

00:46:23.960 --> 00:46:33.019
NSDocument is based on UTIs, NApps -- sorry, technologies
such as Spotlight and Quick Look are also based on UTIs.

00:46:33.019 --> 00:46:36.570
So it's really important to understand how these work.

00:46:36.570 --> 00:46:41.430
To learn more about UTIs, you should check
out the Uniform Type Identifiers Overview.

00:46:41.429 --> 00:46:47.190
Alright, let's get into some of these cool technologies.

00:46:47.190 --> 00:46:50.280
The first one I want to talk about is Spotlight.

00:46:50.280 --> 00:46:53.070
Spotlight is about system-wide searching.

00:46:53.070 --> 00:46:57.850
It allows the users to find anything
throughout their system.

00:46:57.849 --> 00:47:04.199
And it works on an index that's built up
of metadata about each file on the system.

00:47:04.199 --> 00:47:06.279
Plug-ins do the indexing.

00:47:06.280 --> 00:47:14.090
So when it comes to needing to understand
the metadata about a particular type of file,

00:47:14.090 --> 00:47:17.079
Spotlight looks for a plug-in that can do that.

00:47:17.079 --> 00:47:23.049
Now your application can provide
Spotlighter, Spotlight importer plug-ins

00:47:23.050 --> 00:47:26.760
for any custom data types that your application defines.

00:47:26.760 --> 00:47:28.980
And it can also make use of Spotlight internally.

00:47:28.980 --> 00:47:39.030
The first thing that a Spotlight importer plug-in does
is it declares the UTIs that it knows how to index.

00:47:39.030 --> 00:47:46.700
This is again how Spotlight finds the
appropriate plug-in to use for any given file.

00:47:46.699 --> 00:47:52.079
They also need to define a metadata schema that
basically declares the different kinds of metadata

00:47:52.079 --> 00:47:57.590
that the importer will be able to
find about the files that it indexes.

00:47:57.590 --> 00:48:00.850
Apple defines a whole bunch of standard metadata attributes.

00:48:00.849 --> 00:48:05.989
There's a couple of them listed on the slide
as examples, but there are many, many more.

00:48:05.989 --> 00:48:13.019
And when you're writing an importer, you should be sure to
support as many of the standard attributes as makes sense

00:48:13.019 --> 00:48:16.800
for the kind of documents or data that you're indexing.

00:48:17.809 --> 00:48:21.670
You can also define custom attributes if
you have information that you want to index

00:48:21.670 --> 00:48:24.700
that isn't covered by the standard attributes.

00:48:25.710 --> 00:48:32.530
It's important to keep in mind that
Spotlight works on separate files.

00:48:34.079 --> 00:48:38.590
These are the documents in the document-based
applications, so great, that's easy.

00:48:39.789 --> 00:48:43.769
But for Shoebox applications, this requires some thought.

00:48:43.769 --> 00:48:48.170
If you want to support Spotlight
for your Shoebox applications,

00:48:48.170 --> 00:48:52.349
you need to think about what the individual
things are that should be able to be found.

00:48:52.349 --> 00:48:55.860
Because those things need to be written as separate files.

00:48:55.860 --> 00:49:00.920
So for example in Address Book, Address
Book saves out each of your contacts

00:49:00.920 --> 00:49:04.470
as a separate file so that Spotlight can find contacts.

00:49:04.469 --> 00:49:13.449
Core Data can help you to do this if you're
using Core Data to implement your application.

00:49:13.449 --> 00:49:18.529
It has support for writing out
external record files automatically.

00:49:18.530 --> 00:49:25.040
So you may keep your data, you know mostly in an SQL Light
database, but Core Data can also automatically make sure

00:49:25.039 --> 00:49:27.509
to write out separate files for each record.

00:49:27.510 --> 00:49:33.800
And then it provides an API so that Spotlight
index importers can access the data that's

00:49:33.800 --> 00:49:37.700
in those external records for the purpose of indexing.

00:49:37.699 --> 00:49:48.000
Now in addition to providing importers for your custom
data types, you can use Spotlight within your application.

00:49:48.000 --> 00:49:54.690
Now this might be as simple as supplying you
know a UI that the user can use to do searches.

00:49:54.690 --> 00:49:57.940
But you can be more subtle than that too if you want.

00:49:57.940 --> 00:50:03.079
Maybe you can sort of keep track of what the user is
doing, look at the data that they're looking at right now,

00:50:03.079 --> 00:50:11.210
and sort of automatically kick off Spotlight searches in
the background to find related information across the system

00:50:11.210 --> 00:50:17.519
and bring relevant information to the user's
current context directly to them in your app.

00:50:19.030 --> 00:50:24.100
There's a Spotlight lab happening tomorrow.

00:50:24.099 --> 00:50:27.589
You can go and talk to the Spotlight
guys and ask them any questions.

00:50:27.590 --> 00:50:30.950
And for documentation, you should start with
the Spotlight Importer Programming Guide

00:50:30.949 --> 00:50:33.769
and the Spotlight Query Programming Guide.

00:50:35.199 --> 00:50:38.569
The next technology that I wanted
to talk about is Quick Look.

00:50:40.130 --> 00:50:44.410
Quick Look provides system-wide previews and thumbnails.

00:50:44.409 --> 00:50:46.319
And it's used in a number of places.

00:50:46.320 --> 00:50:52.870
So Finder uses it to provide system icons, it
uses it for the cover flow view, and both Finder

00:50:52.869 --> 00:51:03.000
and Mail for example let you preview content
directly within the applications using Quick Look.

00:51:03.000 --> 00:51:07.530
Like Spotlight, Quick Look support is provided by plug-ins.

00:51:07.530 --> 00:51:13.750
So your application can provide Quick Look plug-ins for the
custom data types that it defines and you can use Quick Look

00:51:13.750 --> 00:51:24.110
in your application to bring nonnative data
into your app and display it to the user.

00:51:24.110 --> 00:51:28.440
To implement a Quick Look plug-in,
you basically, like the Spotlight,

00:51:28.440 --> 00:51:32.720
you declare the UTIs that your Quick Look plug-in supports.

00:51:32.719 --> 00:51:37.779
And then you implement two callbacks, one to
generate thumbnails, and one to generate previews.

00:51:37.780 --> 00:51:43.290
For the thumbnail callback, you need to supply an image.

00:51:43.289 --> 00:51:47.909
This can be a precomputed image or it
can be one that you generate on the fly.

00:51:49.349 --> 00:51:51.309
For previews you have a few other options.

00:51:51.309 --> 00:51:55.619
You can supply an image or you can draw it
directly into a dedicated graphics context

00:51:55.619 --> 00:51:59.420
if that makes more sense for your application.

00:51:59.420 --> 00:52:06.010
Or you can provide your data in a common
format like text, HTML, RTF or PDF.

00:52:06.010 --> 00:52:11.690
These formats are ones that QuickTime knows how to
display natively and so it'll handle the presentation

00:52:11.690 --> 00:52:19.980
if you just return your data in that form.

00:52:19.980 --> 00:52:24.789
In addition to providing a plug-in, you
can use Quick Look in your application.

00:52:24.789 --> 00:52:28.880
You can use it to get thumbnails for any file on the system

00:52:28.880 --> 00:52:32.559
and then present those directly to
the user within your application.

00:52:32.559 --> 00:52:43.110
You can also use it to let the user dive into a full preview
of any content directly from within your application.

00:52:43.110 --> 00:52:47.980
So think about how these might, you know these
things might benefit the users of your app.

00:52:47.980 --> 00:52:51.780
And especially in concert with the Spotlight
integration that we talked about earlier.

00:52:51.780 --> 00:52:57.110
You know, you can figure out a bunch of stuff
that's relevant to what the user is doing,

00:52:57.110 --> 00:53:03.160
you know bring relevant information from across the
system to the user, show it to them as, you know,

00:53:03.159 --> 00:53:06.369
embedded thumbnails and then maybe let the user dive

00:53:06.369 --> 00:53:11.329
into a more full preview experience
directly all within your application.

00:53:14.110 --> 00:53:21.880
Go talk to the Quick Look guys in the lab this week and for
documentation start with the Quick Look Programming Guide.

00:53:21.880 --> 00:53:27.240
Next up is iChat Theater.

00:53:27.239 --> 00:53:33.429
iChat Theater is about presenting data
to other people through video chat.

00:53:33.429 --> 00:53:37.710
And you can do this with documents or
really any content in your application.

00:53:41.199 --> 00:53:48.079
If your document-based app supports Quick Look,
then you actually get a lot of this for free.

00:53:48.079 --> 00:53:55.110
If you'd like to just have the Quick Look preview
presented through iChat Theater, then that just works.

00:53:55.110 --> 00:54:00.550
You can also support more advanced
use cases through a session based API.

00:54:00.550 --> 00:54:09.710
And that allows you to present any NSView or
a Core Video pixel buffer or an OpenGL buffer

00:54:09.710 --> 00:54:15.420
as well as audio content through iChat Theater.

00:54:15.420 --> 00:54:19.400
There's an iChat lab this week, so
you could go and check that out.

00:54:19.400 --> 00:54:23.530
And for documentation you can start with
the Instant Message Programming Guide.

00:54:23.530 --> 00:54:30.350
OK, the last of these integration technologies
that I want to talk about is Sync Services.

00:54:30.349 --> 00:54:35.920
Sync Services is about keeping multiple copies of
the same data synchronized in different places.

00:54:35.920 --> 00:54:42.090
Now most typically this is between your
Mac and an iPhone or an iPod using iTunes.

00:54:42.090 --> 00:54:50.470
It can also be between multiple Macintoshes using .Me or you
can synch with other devices using the iSync application.

00:54:52.010 --> 00:54:58.390
To support synching the data of your
application you need to define a synch schema.

00:54:58.389 --> 00:55:05.150
And this works best for Shoebox applications where all the
data is together and then you know it's usually record based

00:55:05.150 --> 00:55:13.260
and so you know the user may want to synchronize the
contents of their you know libraries across multiple places.

00:55:14.619 --> 00:55:17.609
You need to identify what data
gets synched and you also need

00:55:17.610 --> 00:55:25.400
to identify how synch identity is defined for your records.

00:55:25.400 --> 00:55:31.130
Sync identity is especially important because it
allows Sync Services to determine when it's looking

00:55:31.130 --> 00:55:35.480
at two different records, whether
they actually refer to the same thing

00:55:35.480 --> 00:55:38.269
and that these two records should be merged together.

00:55:39.409 --> 00:55:45.009
Sync Services has a session-based API
that's far too complicated to go into here.

00:55:45.010 --> 00:55:47.850
But you can read the documentation to learn more about it.

00:55:47.849 --> 00:55:56.460
Although I will say that if you're using Core Data,
you have a huge head start implementing Sync Services.

00:55:56.460 --> 00:55:59.369
Core Data has direct integration
with Sync Services and allows you

00:55:59.369 --> 00:56:03.960
to define your synch schema purely
by annotating your core data model.

00:56:03.960 --> 00:56:10.250
It of course handles local storage of your data for you
and it tracks all the changes that are made to the data

00:56:10.250 --> 00:56:16.190
in between synch sessions so that Sync Services
can perform efficient incremental synchs.

00:56:16.190 --> 00:56:28.210
You can learn more about Sync Services in the lab this week.

00:56:28.210 --> 00:56:28.269
[ Cough ]

00:56:28.269 --> 00:56:33.199
And for documentation, you can start with the Sync
Services Tutorial and the Sync Services Programming Guide.

00:56:33.199 --> 00:56:38.619
And the Programming Guide is also where you'll
find information about the Core Data integration.

00:56:40.289 --> 00:56:41.800
Alright, let's review here.

00:56:41.800 --> 00:56:47.010
We've looked at a number of technologies that can
help you make sure that the data the user creates

00:56:47.010 --> 00:56:51.700
in your application fits into their
overall working environment.

00:56:51.699 --> 00:56:57.849
I urge you to consider how adopting any of these
technologies would make sense for your applications

00:56:57.849 --> 00:57:03.860
and to do so to make sure that you have the
best experience possible for your users.

00:57:03.860 --> 00:57:07.740
Now I'd like to talk a little bit
about how you can make sure

00:57:07.739 --> 00:57:11.549
that your application has the broadest possible audience.

00:57:13.699 --> 00:57:18.939
The people who might want to use your
application, they come from all over the place.

00:57:18.940 --> 00:57:24.659
They may speak different languages
and have different cultures.

00:57:24.659 --> 00:57:28.719
Other people who may want to use your
application may have disabilities.

00:57:28.719 --> 00:57:33.949
And still others may look to your application
to be part of the solution to a larger problem

00:57:33.949 --> 00:57:36.839
that they couldn't solve with your application alone.

00:57:36.840 --> 00:57:40.640
If you keep all of these folks in mind
when you're creating your application,

00:57:40.639 --> 00:57:49.049
you can make sure that your application
may become useful for all of them.

00:57:49.050 --> 00:57:53.420
We'll talk about a number of technologies
that are related to this.

00:57:53.420 --> 00:57:56.150
And let's just dive right in.

00:57:56.150 --> 00:57:59.030
The first one is internationalization.

00:57:59.030 --> 00:58:01.410
Internationalization is all about making sure

00:58:01.409 --> 00:58:06.329
that your application can be used by
people from anywhere in the world.

00:58:07.449 --> 00:58:10.809
There are two main facets to internationalization.

00:58:10.809 --> 00:58:14.900
One of them is localizability and the other
one is handling international content.

00:58:14.900 --> 00:58:17.900
And we'll tackle them one at a time.

00:58:17.900 --> 00:58:24.940
Localizability is about making sure that your application's
interface can be translated into multiple languages.

00:58:24.940 --> 00:58:26.420
Mac OS X makes this really easy.

00:58:26.420 --> 00:58:30.849
And if you just sort of pay attention
a little bit to this from the beginning

00:58:30.849 --> 00:58:35.440
of your app development, then it's almost no effort.

00:58:36.769 --> 00:58:41.780
Interface specifications can be per region
and in fact they typically are by default.

00:58:41.780 --> 00:58:46.880
And NSBundle and its APIs make sure
that when you look up resources,

00:58:46.880 --> 00:58:53.550
you'll automatically get region specific
resources when they exist for your app.

00:58:53.550 --> 00:59:00.450
Finally, Cocoa has some tools to help you make sure
that any text that's in your source code that will end

00:59:00.449 --> 00:59:04.230
up being presented to the user can also be translated.

00:59:07.210 --> 00:59:10.980
Now once you've made your application
localizable, of course then you need to decide

00:59:10.980 --> 00:59:14.139
which languages you actually want to translate it into.

00:59:14.139 --> 00:59:15.799
And that's a different story.

00:59:15.800 --> 00:59:21.420
But in order to be in the position to
even do that, you have to be localizable.

00:59:21.420 --> 00:59:27.079
The other aspect of internationalization
is handling international content.

00:59:27.079 --> 00:59:29.889
And in fact this one is even more
important than localizability.

00:59:29.889 --> 00:59:36.489
There are differences between the
different regions of the world.

00:59:36.489 --> 00:59:39.829
They speak different languages and
have different writing systems.

00:59:39.829 --> 00:59:46.599
People handle time and numbers
and currencies in different ways.

00:59:46.599 --> 00:59:52.110
Now, if the user is able to type text into
your application, can they type German?

00:59:52.110 --> 00:59:53.240
Can they type Japanese?

00:59:53.239 --> 00:59:55.059
Can they type Arabic?

00:59:55.059 --> 00:59:59.039
Will you be able to save it properly if they do?

00:59:59.039 --> 01:00:01.710
Does your application work with dates at all?

01:00:01.710 --> 01:00:04.400
Does it handle non-Gregorian calendars?

01:00:04.400 --> 01:00:06.510
You want to think about all of these things.

01:00:06.510 --> 01:00:10.580
Now, luckily Cocoa actually makes it
pretty easy to deal with this stuff

01:00:10.579 --> 01:00:13.819
if you just use the technologies that it provides.

01:00:13.820 --> 01:00:17.500
So all text handling in Cocoa is based on Unicode.

01:00:17.500 --> 01:00:22.219
And Cocoa has a sophisticated text system that
can handle pretty much any language in the world.

01:00:22.219 --> 01:00:25.639
If you're using all that stuff, then you know it's easy.

01:00:25.639 --> 01:00:27.480
It'll just work.

01:00:27.480 --> 01:00:32.500
Similarly there are classes for
dealing with dates, different calendars

01:00:32.500 --> 01:00:37.349
and formatting of numbers and, and other data types.

01:00:38.809 --> 01:00:49.179
Use these things and they'll automatically function
correctly for the locale that the user is in.

01:00:49.179 --> 01:00:53.730
Internationalization on the Mac and on the
iPhone are actually pretty much the same.

01:00:53.730 --> 01:00:56.240
And you can see that from the sessions and labs we have.

01:00:56.239 --> 01:01:00.269
They combine both Mac and iPhone together.

01:01:00.269 --> 01:01:03.530
You can go to these and learn more about it.

01:01:03.530 --> 01:01:09.830
And for documentation you should start with the
Internationalization Programming Topics Document.

01:01:09.829 --> 01:01:14.199
Next up is accessibility.

01:01:14.199 --> 01:01:21.059
Accessibility is about making sure that your application
is usable by people with various disabilities.

01:01:21.059 --> 01:01:28.590
Now, over a number of years, a lot of research has gone
on in the computer industry to help make sure that people

01:01:28.590 --> 01:01:32.760
with various disabilities can effectively use computers.

01:01:32.760 --> 01:01:40.180
And Cocoa has a lot of support for this built right in.

01:01:40.179 --> 01:01:44.009
To make sure that your application is accessible,
there's a few things that you can do that'll be

01:01:44.010 --> 01:01:47.870
of benefit to anybody who uses your application.

01:01:47.869 --> 01:01:51.920
Support full keyboard access, this is really important.

01:01:51.920 --> 01:01:57.700
Don't override system key equivalents especially the ones
that are associated with accessibility functionality.

01:01:57.699 --> 01:02:03.509
Always provide alternatives for drag and drop work flows.

01:02:03.510 --> 01:02:10.450
And finally in multiple step work flows, if at all
possible allow back tracking or canceling out of them.

01:02:10.449 --> 01:02:14.429
Again, these things will help anybody
to use your application.

01:02:14.429 --> 01:02:18.719
In addition to that though, you want
to keep in mind a few specific things.

01:02:18.719 --> 01:02:23.489
There are lots of different color blindnesses out
there and some of them are actually quite common.

01:02:23.489 --> 01:02:28.019
So you want to avoid having UI elements
that are distinguished only by their color.

01:02:29.349 --> 01:02:36.440
Never use an audio cue in your application as
the only way to alert the user to some state.

01:02:36.440 --> 01:02:41.039
And finally when you're designing
interactions in your application,

01:02:41.039 --> 01:02:45.809
avoid ones that require multiple gestures in rapid sequence.

01:02:48.500 --> 01:02:52.219
Cocoa provides a model for accessibility.

01:02:52.219 --> 01:02:56.129
And all of the standard UI elements work with that model.

01:02:56.130 --> 01:03:00.840
In a lot of cases, all you need to do in your
application is provide accessibility descriptions for all

01:03:00.840 --> 01:03:06.380
of your interface elements that explain exactly
what their purpose is within your interface.

01:03:06.380 --> 01:03:09.329
You can also link related user interface elements together

01:03:09.329 --> 01:03:14.500
so that accessibility can make those
relationships known to the user.

01:03:14.500 --> 01:03:19.769
If you write custom user interface, you
may have some additional work to do.

01:03:19.769 --> 01:03:25.239
You may have to expose substructure and other
accessibility information about your custom views in order

01:03:25.239 --> 01:03:27.509
for them to work well with accessibility.

01:03:27.510 --> 01:03:31.860
And you may need to support relevant
accessibility attributes and actions.

01:03:31.860 --> 01:03:36.579
You can use the accessibility inspector
application and voice over to check

01:03:36.579 --> 01:03:38.679
to make sure that your application is accessible.

01:03:38.679 --> 01:03:45.000
There's a ton of content this week about accessibility.

01:03:45.000 --> 01:03:48.579
So you can, you can go and learn a lot more about it.

01:03:48.579 --> 01:03:54.650
For documentation, start with the Accessibility Overview
and the Accessibility Programming Guidelines for Cocoa.

01:03:54.650 --> 01:03:59.800
Alright, next up is Scripting.

01:03:59.800 --> 01:04:05.130
If your application is scriptable, it may
be interesting to whole groups of users

01:04:05.130 --> 01:04:08.380
who wouldn't otherwise be able to use it.

01:04:08.380 --> 01:04:13.200
They might use it to construct larger
workflows that involve other applications.

01:04:13.199 --> 01:04:17.379
By using automater or by just writing scripts.

01:04:17.380 --> 01:04:22.740
They may be able to automate repetitive tasks
within your application through scripting

01:04:22.739 --> 01:04:29.229
and in some cases you might even allow for people to write
scripts that extend the functionality of your application.

01:04:29.230 --> 01:04:35.789
When it comes to scripting, you want to start early.

01:04:35.789 --> 01:04:41.440
It's easier to make your application scriptable if you
do it from the beginning than it is to try to do it

01:04:41.440 --> 01:04:44.730
to an already written application at the end.

01:04:44.730 --> 01:04:50.320
The primary thing that you need to do to make your
application scriptable is define a terminology.

01:04:50.320 --> 01:04:59.289
The scripting terminology basically describes the way that
users talk to your application through scripts, the nouns,

01:04:59.289 --> 01:05:02.949
and the verbs that are available to them.

01:05:02.949 --> 01:05:08.349
The terminology should match the user's
conceptual model of your application.

01:05:08.349 --> 01:05:11.259
Scripting an application isn't
about scripting the user interface,

01:05:11.260 --> 01:05:14.540
about writing scripts that click
buttons or choose menu items.

01:05:14.539 --> 01:05:20.409
It's about driving the core concepts of your application.

01:05:20.409 --> 01:05:26.690
Now if your internal application model matches
up with the way that you want users to think

01:05:26.690 --> 01:05:31.420
about using your application, then
actually this becomes pretty easy.

01:05:31.420 --> 01:05:33.769
In fact there's a lot of things
that will become a lot easier

01:05:33.769 --> 01:05:39.090
if you can keep those two things
consistent with one another.

01:05:39.090 --> 01:05:42.000
In that case, all you really need to
do to support scripting is to make sure

01:05:42.000 --> 01:05:45.590
that your model objects are key-value coding compliant.

01:05:45.590 --> 01:05:55.070
And then implement any custom scripting command
handlers for the various classes where they make sense.

01:05:55.070 --> 01:05:58.070
Again, lots of information about
scripting at the conference.

01:05:58.070 --> 01:05:59.510
Go and check it out.

01:05:59.510 --> 01:06:05.270
And for documentation start with the Cocoa Scripting Guide.

01:06:05.269 --> 01:06:10.309
Alright, the last of these technologies
I want to talk about is services.

01:06:10.309 --> 01:06:17.279
Services are all about making certain features of your
application available in the context of other applications.

01:06:19.969 --> 01:06:22.289
Services can transform data.

01:06:22.289 --> 01:06:26.529
For example, you might have a service
that takes text as input, summarizes it,

01:06:26.530 --> 01:06:29.940
and then returns a textual summary as output.

01:06:29.940 --> 01:06:32.700
Or maybe you have one that takes an image as input,

01:06:32.699 --> 01:06:37.559
runs optical character recognition over
it, and returns the text as output.

01:06:37.559 --> 01:06:41.099
You can also have services that simply produce data.

01:06:41.099 --> 01:06:46.719
Maybe a service that takes a screenshot
and returns the image as its result.

01:06:46.719 --> 01:06:50.169
And finally you can have services
that simply trigger behavior

01:06:50.170 --> 01:06:55.099
in your application based on data in other applications.

01:06:55.099 --> 01:07:03.279
So for example, Safari's Open URL service or Mail's
Send Selection service are examples of these.

01:07:03.280 --> 01:07:06.330
Services are really great for common data types.

01:07:06.329 --> 01:07:12.710
Because lots of different applications understand them and
so if you can provide a service that works in terms of text

01:07:12.710 --> 01:07:17.280
and images and files and other things that
lots of other applications understand,

01:07:17.280 --> 01:07:23.519
then you make your application useful
in these other contexts as well.

01:07:23.519 --> 01:07:25.500
Providing services is pretty easy.

01:07:25.500 --> 01:07:28.860
You need to identify your candidate behaviors.

01:07:28.860 --> 01:07:33.910
Mostly you should look to things that your
application does that are fairly self contained

01:07:33.909 --> 01:07:40.230
and that act on input data and/or return output data.

01:07:40.230 --> 01:07:45.380
Once you've got these, you implement a single object
to be the service provider for your application

01:07:45.380 --> 01:07:49.480
and each service you want to provide
will be a method on that object.

01:07:49.480 --> 01:07:56.139
NSPasteboard is used to communicate data,
the input and output data for services.

01:07:56.139 --> 01:08:01.569
There's a fair amount of content this week about services

01:08:01.570 --> 01:08:05.910
and in fact there's been some really exciting
developments in services in Snow Leopard.

01:08:05.909 --> 01:08:09.039
So you should go and check these out.

01:08:09.039 --> 01:08:14.210
For documentation you can start with the Cocoa,
sorry with the Services Implementation Guide.

01:08:14.210 --> 01:08:17.930
Alright, there's a few other sessions that didn't really fit

01:08:17.930 --> 01:08:22.369
into the other you know specific
topics that I wanted to point out.

01:08:22.369 --> 01:08:30.659
What's New in Cocoa actually happened earlier this morning,
but if you missed it you can catch it on iTunes later.

01:08:30.659 --> 01:08:34.729
The companion session to this one which is
all about user interface design is going

01:08:34.729 --> 01:08:37.609
to happen in this room right after lunch.

01:08:37.609 --> 01:08:40.139
That one I really recommend.

01:08:40.140 --> 01:08:45.060
And then there's the Cocoa Tips and Tricks session,
which happens a little bit later this week.

01:08:47.350 --> 01:08:55.780
Alright, so we've kind of had a fast, you know fast paced
overview of a lot of technologies in Mac OS X today.

01:08:55.779 --> 01:08:58.630
And we haven't even hit all of them.

01:08:58.630 --> 01:09:04.909
It's actually a challenge to know all of the things that
are available for your application to take advantage

01:09:04.909 --> 01:09:10.289
of in Mac OS X so that you can know which ones
are appropriate for your application to use.

01:09:10.289 --> 01:09:14.890
We hope we've given you a bit of a help
today in knowing what those things are.

01:09:14.890 --> 01:09:19.450
And we hope that we may have given you some ideas
for how you can use them in your application.

01:09:19.449 --> 01:09:21.649
But most of all we hope that you all go out

01:09:21.649 --> 01:09:26.109
and you write really great Mac OS X applications
using these technologies so that we can use them.

01:09:26.109 --> 01:09:28.849
All right, that's it.
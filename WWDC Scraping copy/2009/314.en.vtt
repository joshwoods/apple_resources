WEBVTT

00:00:14.730 --> 00:00:16.629
>> Welcome to session 314.

00:00:16.629 --> 00:00:19.359
This is Transitioning to QuickTime X.

00:00:19.359 --> 00:00:22.980
My name is Tim Monroe and I will
be joined shortly by Kevin Calhoun.

00:00:22.980 --> 00:00:27.000
And we're going to talk to you today about
QuickTime X and some of the other changes

00:00:27.000 --> 00:00:29.250
that we have made in QTKit for Snow Leopard.

00:00:29.250 --> 00:00:35.350
So I'm just going to make a wild guess that most of
you went to the graphics and media state of the unions.

00:00:35.350 --> 00:00:43.650
So you have a good understanding already of what QuickTime X
is and where it fits in to the media architecture on Mac OS.

00:00:43.649 --> 00:00:48.000
You already know that it's a new
technology for displaying time-based media.

00:00:48.000 --> 00:00:51.000
It is one of the technologies that
has actually migrated back

00:00:51.000 --> 00:00:56.509
to the desktop form our devices
such as iPhone, Apple TV, iPod.

00:00:56.509 --> 00:01:00.710
It was implemented independent of QuickTime 7.

00:01:00.710 --> 00:01:03.990
And you'll see today that it provides some very interesting

00:01:03.990 --> 00:01:08.100
and significant improvements over
the current media architecture.

00:01:08.099 --> 00:01:14.519
And you also learn that to get the playback
advantages of QuickTime X, you must be using QTKit.

00:01:14.519 --> 00:01:18.439
So what are we going to talk about here today?

00:01:18.439 --> 00:01:21.929
We're going to spend most of our
time talking about QuickTime X.

00:01:21.930 --> 00:01:29.990
So we'll show how to open media so that you can play it
back with QuickTime X, when it makes sense for you to do so,

00:01:29.989 --> 00:01:36.819
and also what you give up, what restrictions apply
when you open a movie on the QuickTime X path.

00:01:36.819 --> 00:01:40.309
We'll also talk about some issues that
are unrelated to QuickTime X and the one

00:01:40.310 --> 00:01:43.320
that is worth mentioning is asynchronous loading.

00:01:43.319 --> 00:01:48.259
We've made some very interesting
improvements in QTKit for opening movies

00:01:48.260 --> 00:01:50.880
in such a way that you don't block your main thread.

00:01:50.879 --> 00:01:56.719
And again, we have some very nice demos that will show
you why you'd be interested in adopting that technology.

00:01:56.719 --> 00:02:03.739
Now there are some other API changes in QTKit that
I don't want to spend a lot of time talking about.

00:02:03.739 --> 00:02:06.079
So I'll mention them upfront here.

00:02:06.079 --> 00:02:13.849
One thing it's possible to do now is to take a single
QTMovie object and display it in more than one view

00:02:13.849 --> 00:02:17.729
or more than one layer or some layers and some views.

00:02:17.729 --> 00:02:21.099
So the tight connection between a QTMovie object

00:02:21.099 --> 00:02:27.079
and its rendering destination has been broken you
could now have a single QTMovie object displayed

00:02:27.080 --> 00:02:29.250
in more than one view.

00:02:29.250 --> 00:02:35.460
Now because of that, it no longer makes
sense to ask for the current size of a movie.

00:02:35.460 --> 00:02:40.370
Why? Because the single movie could
be in different size views.

00:02:40.370 --> 00:02:45.509
So we have deprecated the attribute,
QTMovieCurrentSizeAttribute.

00:02:45.509 --> 00:02:52.739
What you want to move to is either querying the size
of your rendering destination, the view, or the layer,

00:02:52.740 --> 00:02:56.120
or you want to ask for the natural size of the movie.

00:02:56.120 --> 00:02:59.219
That is the size at which the movie was authored.

00:02:59.219 --> 00:03:07.240
So if you're using current size attribute, move to
natural size attribute or ask the view what it size is.

00:03:07.240 --> 00:03:13.680
Now because of that change, we have also
deprecated the QTMovieSizeDidChangeNotification.

00:03:13.680 --> 00:03:20.830
And we have replaced that with a new notification,
QTMovieNaturalSizeDidChangeNotification.

00:03:20.830 --> 00:03:24.390
Now, you may be wondering how could
be the natural size change.

00:03:24.389 --> 00:03:28.739
And one way this could happen is if you have
a streaming movie coming in through the net.

00:03:28.740 --> 00:03:35.590
And halfway through it, a new track appears that is larger
than existing tracks or smaller or in anyway different.

00:03:35.590 --> 00:03:40.490
And if that happens, you will get this
QTMovieNaturalSizeDidChangeNotification

00:03:40.490 --> 00:03:43.070
and you could react to it accordingly.

00:03:43.069 --> 00:03:46.389
So let's talk about QuickTime X.

00:03:46.389 --> 00:03:52.039
This is what the documentation says
about QTMovie prior to Snow Leopard.

00:03:52.039 --> 00:03:57.090
A QTMovie object represents both a
QuickTime movie and a movie controller.

00:03:57.090 --> 00:04:05.090
Now you already know that this is no longer true because
you already know that you can play back movies using QTKit

00:04:05.090 --> 00:04:09.700
and not accessing the existing QuickTime technologies.

00:04:09.699 --> 00:04:12.259
That is to say you'll be accessing QuickTime X.

00:04:12.259 --> 00:04:16.800
So if you look at the new documentation for
Snow Leopard, we say something more general,

00:04:16.800 --> 00:04:23.009
namely a QTMovie object represents
a playable collection of media data.

00:04:23.009 --> 00:04:26.480
This is the pre-Snow Leopard architecture.

00:04:26.480 --> 00:04:29.030
You've seen these kind of diagrams before.

00:04:29.029 --> 00:04:35.519
QTKit as we just saw, sits right on top
of QuickTime or QuickTime 7 as we now say.

00:04:35.519 --> 00:04:41.969
QuickTime 7 consists of a whole bunch of APIs
that are divided into tool boxes and components.

00:04:41.970 --> 00:04:46.070
So you have the Movie Toolbox, you
have Movie Controller components.

00:04:46.069 --> 00:04:51.389
A little bit lower down, you have Media Handlers
that handle the media in a particular track,

00:04:51.389 --> 00:04:57.379
you have some Data Handlers who's responsibility is
to load data from disk or from the net or wherever.

00:04:57.379 --> 00:05:05.029
And those QuickTime services, themselves that upon
lower level system services such as the Sound Manager

00:05:05.029 --> 00:05:07.569
or more recently we have moved to Core Audio.

00:05:07.569 --> 00:05:09.230
It may sit on QuickDraw.

00:05:09.230 --> 00:05:11.990
Or again, more recently we're doing things with Core Video.

00:05:11.990 --> 00:05:14.759
And originally we use a lot of Carbon.

00:05:14.759 --> 00:05:17.060
And now we have moved to Core Foundation.

00:05:17.060 --> 00:05:22.829
But they're still in the QuickTime 7 stack,
a mixture of these lower level technologies.

00:05:22.829 --> 00:05:30.289
Now when we move to QuickTime X, we have QTKit seating
either on top of QuickTime 7 or on top of QuickTime X.

00:05:30.290 --> 00:05:37.330
Now we're not telling you much more about QuickTime
X other than it is a new set of media services

00:05:37.329 --> 00:05:42.509
and that those media services are sitting
solely on top of this more modern foundation

00:05:42.509 --> 00:05:47.000
such as Core Foundation, Core Video,
Core Audio, Core Animation.

00:05:47.000 --> 00:05:52.329
So it's a completely modern stack underneath QuickTime X.

00:05:52.329 --> 00:05:59.729
So, new set of media services, it was designed for extremely
efficient playback which I think you can understand

00:05:59.730 --> 00:06:06.140
by remembering that it's developed
for the iPhone, Apple TV, and iPod.

00:06:06.139 --> 00:06:08.740
It is aggressively multithreaded.

00:06:08.740 --> 00:06:12.560
So it will try to fork off threads
whenever it sees that there is something

00:06:12.560 --> 00:06:16.000
that deserves happening on a background thread

00:06:16.000 --> 00:06:19.910
It is completely 64-bit native when running in 64-bits.stydl7

00:06:19.910 --> 00:06:27.950
It is based again, on core Foundation and it
has ColorSync matching throughout the stack.

00:06:27.949 --> 00:06:35.129
Now the current set of formats that it supports
are what we call modern linear media formats,

00:06:35.129 --> 00:06:39.189
that's stuff like H264 video, AAC audio.

00:06:39.189 --> 00:06:43.230
We're not going to give you an exact list
because of course that list will change over time

00:06:43.230 --> 00:06:47.300
as QuickTime X learns how to handle
more and more media formats.

00:06:47.300 --> 00:06:52.889
And there's a very, very, very simple
API for you to access QuickTime X

00:06:52.889 --> 00:06:56.629
in Snow Leopard that I'll talk about in just a minute.

00:06:56.629 --> 00:06:59.250
Now there are also some other benefits.

00:06:59.250 --> 00:07:03.149
And again, you got a taste of this in
the graphics and media state of the union

00:07:03.149 --> 00:07:06.489
where there were four components of QuickTime X.

00:07:06.490 --> 00:07:12.220
And QTKit actually automatically takes
advantage of some of those components.

00:07:12.220 --> 00:07:18.050
So you don't have to do anything for instance
if your using the existing QTKit capture APIs.

00:07:18.050 --> 00:07:23.600
We now use QuickTime X services to
process movies that are captured.

00:07:23.600 --> 00:07:29.020
And we also use QuickTime X to do the
color tagging of those captured movies.

00:07:29.019 --> 00:07:37.319
Similarly, if you use existing QTKit APIs to
transcode a file, to export it in a new format,

00:07:37.319 --> 00:07:43.680
you will automatically take advantage of new
QuickTime X technology if you're exporting

00:07:43.680 --> 00:07:48.009
to the various device formats that it supports.

00:07:48.009 --> 00:07:54.589
[ Pause ]

00:07:54.589 --> 00:08:00.159
>> So, how do you get to use QuickTime X?

00:08:00.160 --> 00:08:03.280
Well, you have to ask very nicely when you open a file.

00:08:03.279 --> 00:08:08.399
So let's talk for a second about opening a movie file.

00:08:08.399 --> 00:08:11.709
Prior to Snow Leopard, the designated initializer

00:08:11.709 --> 00:08:19.839
of the QTMovie class was this long winded method
initWithQuickTimeMovie:disposeWhenDone:error:.

00:08:19.839 --> 00:08:28.310
Now again, if you realize that we have sort of bifurcated
QTKit so that it stands upon QuickTime 7 or QuickTime X,

00:08:28.310 --> 00:08:32.299
you know that this is now a bad
choice as a designated initializer.

00:08:32.299 --> 00:08:37.659
Why? For the simple reason that on the QuickTime
X path, you don't have a QuickTime movie.

00:08:37.659 --> 00:08:43.929
So there is not one of these capital M movies that
you can pass into this designated initializer.

00:08:43.929 --> 00:08:49.299
This was actually already a problem in
Leopard when you are running in 64-bits

00:08:49.299 --> 00:08:54.419
because there also the QuickTime
framework is not available in 64-bits.stydlG

00:08:54.419 --> 00:09:00.370
So there you couldn't have had a capital M
movie to pass into your designated initializer.

00:09:00.370 --> 00:09:03.810
So there was a little bit of a
disconnect there already in Leopard.

00:09:03.809 --> 00:09:12.149
So in Snow Leopard, we now we have a new designated
initializer for QTMovie and it is initWithAttributes:error:.

00:09:12.149 --> 00:09:17.319
That's an existing method which we have now
promoted to be the designated initializer.

00:09:17.320 --> 00:09:21.860
And here I have the instance method
and the class method listed.

00:09:21.860 --> 00:09:28.649
Now if you have code that already subclasses
QTMovie by calling initWithMmovie:error:,

00:09:28.649 --> 00:09:32.419
initWithMovie:disposeWhenDone:error:, don't worry about it.

00:09:32.419 --> 00:09:37.849
We have taken care of it so that your
initializer gets called at the proper time.

00:09:37.850 --> 00:09:41.790
But if you are writing new code
and you want to subclass QTMovie,

00:09:41.789 --> 00:09:45.939
you should move over to subclassing
initWithAttributes:error:.

00:09:45.940 --> 00:09:49.770
So what's the idea with initWithAttributes:error:?

00:09:49.769 --> 00:09:51.079
It's very simple.

00:09:51.080 --> 00:09:58.350
You pass in a dictionary of key value pairs which
specify attributes that you want this movie to have.

00:09:58.350 --> 00:10:04.320
Now there are three general classes of
attributes that you can put in to this dictionary.

00:10:04.320 --> 00:10:07.250
The fist class I called data locator attributes.

00:10:07.250 --> 00:10:10.149
You got to tell us where the movie data is.

00:10:10.149 --> 00:10:12.649
So one of these, is essential.

00:10:12.649 --> 00:10:18.959
>> Typically, you'll use the first two,
QTMovieFileNameAttribute or QTMovieURLAttribute.

00:10:18.960 --> 00:10:24.290
There are also some other data locator
attributes for more specialized purposes.

00:10:24.289 --> 00:10:27.649
There are also movie configuration attributes.

00:10:27.649 --> 00:10:31.779
So, if you want the movie to open, say set to be looping,

00:10:31.779 --> 00:10:36.919
you could put in a key value pair
that says, QTMovieLoopsAttribute, YES.

00:10:36.919 --> 00:10:40.759
You could also open it with a nonstandard
volume if you wanted to.

00:10:40.759 --> 00:10:43.259
Or you could make it editable at the time it's opened.

00:10:43.259 --> 00:10:46.330
Or you could assign a delegate to it.

00:10:46.330 --> 00:10:51.190
Now, what kinds of things can you put
in as movie configuration attributes?

00:10:51.190 --> 00:10:57.390
Basically, you can put in any settable
attribute in the QTMovie class.

00:10:57.389 --> 00:11:04.449
Now sometimes people send us code and I see that
they put in attributes like QTMovieDurationAttribute.

00:11:04.450 --> 00:11:05.870
And this has always puzzled me.

00:11:05.870 --> 00:11:11.669
For the simple reason that duration is not
a settable attribute of a QTMovie object.

00:11:11.669 --> 00:11:16.809
It's like you went down to your Toyota dealer and
sell I want a Prius with a 120 inch wheel ba se.

00:11:16.809 --> 00:11:18.159
Well they don't make them.

00:11:18.159 --> 00:11:20.779
The factory makes them at 106 inches.

00:11:20.779 --> 00:11:25.909
So that's not a settable configurable
option when you're buying a car.

00:11:25.909 --> 00:11:33.389
Similarly when you're opening a QTMovie, you
cannot set the duration to some nonstandard value.

00:11:33.389 --> 00:11:36.850
Well how do you know this?

00:11:36.850 --> 00:11:43.810
Partly, this is our fault because we haven't been good about
telling you which attributes are settable and which are not.

00:11:43.809 --> 00:11:49.339
So we've taken some trouble and we've gone
through and we've header-docked QTMovie.h.

00:11:49.340 --> 00:11:54.240
And in particular we've made it very clear
whether a given attribute can be read

00:11:54.240 --> 00:11:57.879
and written or read but not written, and so forth.

00:11:57.879 --> 00:12:04.639
So here for instance, if you look in QTMovie.h and you
look at the QTMovieDurationAttribute, it says very clearly,

00:12:04.639 --> 00:12:08.429
this attribute can be read but it cannot be written.

00:12:08.429 --> 00:12:14.750
So that's a clue to you that you don't want to put it
into the dictionary that you pass to initWithAttributes.

00:12:14.750 --> 00:12:23.960
The third class of attributes that you could put in to
this dictionary, I call special initialization attributes.

00:12:23.960 --> 00:12:29.940
And I won't discus these in detail because we have all that
great header dock which now explains to you what these do.

00:12:29.940 --> 00:12:32.980
The one I want to highlight is the
last one which I will come back

00:12:32.980 --> 00:12:36.899
and talk about later namely, the OpenAsyncOKAttribute.

00:12:36.899 --> 00:12:42.959
Now, how do you get QuickTime X playback capability?

00:12:42.960 --> 00:12:49.320
As I said, you ask us nicely and you ask nicely by
passing in a new special initialization attribute

00:12:49.320 --> 00:12:53.980
and this is it, QTMovieOpenForPlaybackAttribute.

00:12:53.980 --> 00:12:57.700
So you say, and the value of course,
you would pass them would be YES.

00:12:57.700 --> 00:13:01.259
So you'll say I want this MovieOpenedForPlayback.

00:13:01.259 --> 00:13:07.679
And that is a clue to us, as QTKit, that
you want to go down the QuickTime X path.

00:13:07.679 --> 00:13:09.519
So what does that look like in code?

00:13:09.519 --> 00:13:14.370
Very simple, you setup an NSDictionary
with the key value pairs that you want.

00:13:14.370 --> 00:13:23.009
And in this case, we have specified open for playback,
YES, and this is a clue that we want the QuickTime X path.

00:13:23.009 --> 00:13:30.649
[ Pause ]

00:13:30.649 --> 00:13:35.429
>> Now, again you heard yesterday that not
all media files can be handled by QuickTime X.

00:13:35.429 --> 00:13:39.779
So what happens when you ask us nicely
to play it with QuickTime X and we can't,

00:13:39.779 --> 00:13:45.230
we silently fall back to the existing QuickTime 7 path.

00:13:45.230 --> 00:13:51.180
You cannot tell whether we are taking the
QuickTime X path or the QuickTime 7 path.

00:13:51.179 --> 00:13:54.009
It's not something really that you need to know.

00:13:54.009 --> 00:14:01.769
Because you have requested to open a movie for
playback, you are therefore restricted to certain APIs

00:14:01.769 --> 00:14:07.350
and certain attributes that apply to playback only.

00:14:07.350 --> 00:14:10.279
Again, how do you know which APIs those are?

00:14:10.279 --> 00:14:17.250
We signal this in the header dock comments and
QTMovie.h and in particular you get something like this.

00:14:17.250 --> 00:14:24.450
This method cannot be called when the movie has been
initialized with QTMovieOpenForPlaybackAttribute set to YES.

00:14:24.450 --> 00:14:28.390
And in this case, this is the QuickTime movie method.

00:14:28.389 --> 00:14:33.519
So if you say, "well what's the QuickTime
movie associated with this QTMovie?"

00:14:33.519 --> 00:14:37.590
If you open this for playback, you
might be going down the QuickTime X path

00:14:37.590 --> 00:14:42.710
and so there is no QuickTime movie associated with it.

00:14:42.710 --> 00:14:48.920
Similarly, some attributes which you
could otherwise have set are not settable

00:14:48.919 --> 00:14:51.139
when you open them on the OpenForPlayback.

00:14:51.139 --> 00:14:54.970
And a good example is QTMovieEditableAttribute.

00:14:54.970 --> 00:15:02.240
And again, we mark that here by saying, "This attribute
can be read and written but it can be read and not written

00:15:02.240 --> 00:15:07.810
when the movie has bee initialized with
QTMovieOpenForPlayback set to YES."

00:15:07.809 --> 00:15:13.319
So when you request playback, you are restricted
to certain methods and you're restricted

00:15:13.320 --> 00:15:16.850
to not being able to set certain attributes.

00:15:16.850 --> 00:15:25.470
So now, let's get a demo of using
QuickTime X to open and playback movies.

00:15:25.470 --> 00:15:32.230
>> Alright Tim, we've got an app
here, did you say it was beautiful?

00:15:32.230 --> 00:15:34.180
Let's just say, it's conceptually beautiful.

00:15:34.179 --> 00:15:39.919
And the concept is to demonstrate the efficiency
of playing back media with QuickTime X.

00:15:39.919 --> 00:15:44.309
This application is capable of opening
initializing instances of QTMovie with

00:15:44.309 --> 00:15:48.209
or without QTMovieOpenForPlaybackAttributes set to YES.

00:15:48.210 --> 00:15:51.769
So let me open a media resource without setting it to YES.

00:15:51.769 --> 00:15:56.429
So I will get in this case, the QuickTime 7 behavior.

00:15:56.429 --> 00:16:02.389
I've got 720P content here and I've
also got activity monitor running.

00:16:04.110 --> 00:16:08.940
[Background music] And when I play this movie which is
not only beautiful conceptually, but beautiful in itself,

00:16:08.940 --> 00:16:14.200
you can see at this particular video and audio
requires, well I don't know, between 40 and 50 percent

00:16:14.200 --> 00:16:19.259
of the CPU when it is being decoded and played.

00:16:19.259 --> 00:16:26.639
Note also, this 64-bit application requires the services
of a 32-bit daemon ap2plication, the QuickTime kit--

00:16:26.639 --> 00:16:33.360
the QTKit server application, I'm sorry, process in
order to perform playback on the QuickTime 7 path.

00:16:35.029 --> 00:16:39.389
Let's see what the same video looks like
and how much CPU it requires when I,

00:16:39.389 --> 00:16:44.759
this time initialize the QTMovie--
setting QTMovieOpenForPlayback to YES.

00:16:44.759 --> 00:16:50.620
So open the same media resource, different
instance of QTMovie, this one open for playback.

00:16:50.620 --> 00:16:55.110
Also one of the things that I want to note is
that when I open the movie the movie for playback,

00:16:55.110 --> 00:17:00.330
this 64-bit application no longer requires
the services of QTKit server, so it goes away.

00:17:00.330 --> 00:17:09.309
[Background music] And I can play the very
same media resource on the QuickTime X path,

00:17:09.309 --> 00:17:12.349
who's doing the calculation with your iPhone even now,

00:17:12.349 --> 00:17:17.629
to determine the improvement in the
number of CPU cycles we require?

00:17:17.630 --> 00:17:18.990
So that's it, playback time.

00:17:18.990 --> 00:17:20.400
We have a more efficient media stack.

00:17:20.400 --> 00:17:24.490
It's available to you and you're
applications when you opt in, its better.

00:17:24.490 --> 00:17:27.779
But it's not only better and more
efficient at playback time.

00:17:27.779 --> 00:17:32.299
It's also more efficient at other times as well,
for reasons that we're going to be exploring

00:17:32.299 --> 00:17:35.180
in quite a bit more depth later in this session.

00:17:35.180 --> 00:17:41.890
Other periods at which QuickTime 7 has required
to do some work are not required for QuickTime X.

00:17:41.890 --> 00:17:44.250
Let me give you an example of that.

00:17:44.250 --> 00:17:48.710
In this case, I'm going to open an
MP3 file, quite a long one actually,

00:17:48.710 --> 00:17:51.299
as you can see it's about half a gigabyte of music.

00:17:51.299 --> 00:17:54.220
And there's work going on.

00:17:54.220 --> 00:17:56.299
I am not playing the content.

00:17:56.299 --> 00:17:57.710
I merely just opened it.

00:17:57.710 --> 00:17:58.850
But something is going on.

00:17:58.849 --> 00:18:03.859
You can see the controller bar filling in
saying, "Now, I've got more media available."

00:18:03.859 --> 00:18:06.189
You can see an activity monitor, some amount

00:18:06.190 --> 00:18:10.299
of CPU is required even though I haven't
begun a media operation on it yet.

00:18:10.299 --> 00:18:15.470
And of course, that amount of CPU will increase
[background music] when I actually play it.

00:18:15.470 --> 00:18:17.480
Well what work is going on?

00:18:17.480 --> 00:18:19.329
Is it necessary?

00:18:19.329 --> 00:18:21.629
I'll say more in a minute.

00:18:21.630 --> 00:18:26.610
All I want to mention now is that if I set
QTMovieOpenForPlaybackAttribute to YES,

00:18:26.609 --> 00:18:35.449
and the media resource can be opened by
QuickTime X, that kind of work is not necessary.

00:18:35.450 --> 00:18:41.539
You can see first of all that the app that I'm running,
the QuickTime X playback demos, requiring no CPU cycles

00:18:41.539 --> 00:18:46.079
since I'm not actually doing anything
and you also see QTKit server has quit.

00:18:46.079 --> 00:18:52.359
Only when I play back [background music]
are any cycles actually required and fewer.

00:18:52.359 --> 00:18:57.379
So there you go, quick idea of the increased
efficiency of the new playback step.

00:18:57.380 --> 00:18:58.010
Tim.

00:18:58.009 --> 00:19:01.559
[ Applause ]

00:19:01.559 --> 00:19:05.109
[ Pause ]

00:19:05.109 --> 00:19:10.799
>> Always put the seat down when you're done

00:19:10.799 --> 00:19:11.740
[ Laughter ]

00:19:11.740 --> 00:19:12.680
[ Inaudible Remark ]

00:19:12.680 --> 00:19:16.630
>> So there, certain movies open much faster with less CPU.

00:19:16.630 --> 00:19:21.810
And virtually all movies, when they take the
QuickTime X path take less CPU to play back.

00:19:21.809 --> 00:19:28.470
So that should be enticing enough as a
reason to be interested in QuickTime X.

00:19:28.470 --> 00:19:31.940
So let's talk about asynchronous loading now.

00:19:31.940 --> 00:19:38.200
We have documented fairly clearly that when you open
a QTMovie object you want to do it on the main thread.

00:19:38.200 --> 00:19:43.200
This is really a limitation that derives
from QuickTime but it's something

00:19:43.200 --> 00:19:45.549
that we've documented and talked about here at WWDC.

00:19:45.549 --> 00:19:51.799
Now it turns out that lots of things
need to go on to open some movies

00:19:51.799 --> 00:19:54.399
and you don't want then blocking the main thread.

00:19:54.400 --> 00:19:59.880
Well QuickTime already has some capabilities
of being able to background some of that work.

00:19:59.880 --> 00:20:06.130
For instance, some data handlers are smart enough to fork
off a thread and load their data on a background thread.

00:20:06.130 --> 00:20:11.140
So even without the new capabilities
we've added in Snow Leopard,

00:20:11.140 --> 00:20:16.520
there is some asynchronous work
being done in certain circumstances.

00:20:16.519 --> 00:20:23.879
>> What we have done QuickTime or in Snow Leopard is add
new services that allow us to be even more aggressive

00:20:23.880 --> 00:20:27.900
at moving things off of the main
thread onto background threads.

00:20:27.900 --> 00:20:31.370
So it's a new service provided by QTKit in Snow Leopard.

00:20:31.369 --> 00:20:39.439
And basically, it is your way of telling us, do
everything possible to avoid blocking the main thread.

00:20:39.440 --> 00:20:44.070
So that means that we should try to load
movie data on a background thread if possible.

00:20:44.069 --> 00:20:47.659
And if that isn't possible, I want you to fail.

00:20:47.660 --> 00:20:54.790
I want you to return an error letting me know as
the developer that my request was not honored.

00:20:54.789 --> 00:20:57.180
How do we do this?

00:20:57.180 --> 00:21:00.420
Again, there's a special initialization
attribute that you put

00:21:00.420 --> 00:21:03.190
in to the dictionary when you call initWithAttributes:error.

00:21:03.190 --> 00:21:09.380
And this particular attribute is called
QTMovieOpenAsyncRequiredAttribute.

00:21:09.380 --> 00:21:13.790
So you're saying, "I require you
to open this asynchronously."

00:21:13.789 --> 00:21:19.349
And again, the code that you would write in order
to use that is identical to what we showed before.

00:21:19.349 --> 00:21:21.990
It's just a different attribute that we're passing in.

00:21:21.990 --> 00:21:26.579
[ Pause ]

00:21:26.579 --> 00:21:35.899
>> Now when you open a movie asynchronously, you will get
back a non-nil QTMovie instance, virtually immediately.

00:21:35.900 --> 00:21:42.290
However, there could be a lot of work that needs to happen
in order to load that movie to the point that you can ask

00:21:42.289 --> 00:21:48.869
about its properties or start playing it back
or export it or whatever you want to do with it.

00:21:48.869 --> 00:21:53.649
So you must monitor what we call movie load states.

00:21:55.210 --> 00:21:57.769
These are movie load states.

00:21:57.769 --> 00:22:04.789
They're just integers that indicate that a certain
level in the loading of movie data has occurred.

00:22:04.789 --> 00:22:08.190
And the very top one is interesting,
it says, LoadStateError.

00:22:08.190 --> 00:22:12.259
So that way you know something
went wrong in loading the movie.

00:22:12.259 --> 00:22:13.960
It couldn't be loaded.

00:22:13.960 --> 00:22:16.400
You should just toss the movie away.

00:22:16.400 --> 00:22:19.590
And the other ones we'll talk about in more detail later,

00:22:19.589 --> 00:22:24.449
but they indicate various levels
in the loading of movie data.

00:22:24.450 --> 00:22:27.390
How do you monitor a movie load state?

00:22:27.390 --> 00:22:34.450
The absolute easiest way is to register for
the QTMovieLoadStateDidChangeNotification.

00:22:34.450 --> 00:22:42.160
And in this case, I'm using normal NSNotificationCenter
method to install a notification handler.

00:22:42.160 --> 00:22:44.779
In this case, it's called "LoadStateChanged."

00:22:44.779 --> 00:22:54.079
So when QTKit signals my application at the
LoadStateChanged, it will call my LoadStateChanged method.

00:22:54.079 --> 00:22:57.460
And in this case, I have a very
simple LoadStateChanged method.

00:22:57.460 --> 00:23:03.220
All I'm doing is grabbing the movie from the
notification object and passing that movie

00:23:03.220 --> 00:23:07.180
to another method that my application has defined.

00:23:07.180 --> 00:23:10.940
And the reason I'm dong this will be clear in just a second.

00:23:10.940 --> 00:23:16.200
And here's what the real guts of my
monitoring movie load states might look like.

00:23:16.200 --> 00:23:24.470
At the very top, I call the attribute for key
to find the QTMovieLoadstateAttribute to sort

00:23:24.470 --> 00:23:26.940
of find out what the current load state is.

00:23:26.940 --> 00:23:32.570
And then I just want to go through the various
possibilities that are of interest to my application.

00:23:32.569 --> 00:23:37.079
So here, I'm handling the LoadStateError,
actually I just have some dots there.

00:23:37.079 --> 00:23:39.549
We'll fill that in a second.

00:23:39.549 --> 00:23:42.769
And the second clause is more interesting.

00:23:42.769 --> 00:23:49.180
If I get to LoadStateLoaded, I know that it's now
safe to query movie properties and to do things

00:23:49.180 --> 00:23:54.990
like attach the movie to a view so that
it can be displayed and played back.

00:23:54.990 --> 00:24:01.529
[ Pause ]

00:24:01.529 --> 00:24:04.629
>> Now it turns out to that when
you call initWithAttributes:error:,

00:24:04.630 --> 00:24:08.530
it's possible that you never receive
a LoadStatechanged notification.

00:24:08.529 --> 00:24:15.220
That's because the movie could immediately go to
the top load state that it's ever going to achieve.

00:24:15.220 --> 00:24:21.730
So immediately after I call initWithAttributes:error:,
I probably want to make a call to my own method

00:24:21.730 --> 00:24:29.420
with that movie just so that any work is done when I've
achieved a certain load state and then I can still register

00:24:29.420 --> 00:24:34.140
to listen for the notification if I want to.

00:24:34.140 --> 00:24:36.520
So what about Asynchronous Loading?

00:24:36.519 --> 00:24:39.889
Not all media files can be loaded asynchronously.

00:24:39.890 --> 00:24:44.610
There could be media handlers involved in
the movie that are not marked as thread-safe.

00:24:44.609 --> 00:24:49.399
And they cannot therefore, be used on a background thread.

00:24:49.400 --> 00:24:53.380
Now you can determine if async loading has failed.

00:24:53.380 --> 00:24:55.000
And if it fails, what do you do?

00:24:55.000 --> 00:24:57.980
Well it really depends on the needs of your application.

00:24:57.980 --> 00:25:05.569
For instance, if you were just opening the movie
to grab a frame of it, to make a thumbnail image,

00:25:05.569 --> 00:25:09.849
it may not be that important to you that you
want to tie up your main thread to do that.

00:25:09.849 --> 00:25:13.429
So you may just put in some icon that you have stored away.

00:25:13.430 --> 00:25:16.470
Or it really might be important for you to open that movie.

00:25:16.470 --> 00:25:21.370
In which case, what you want to do
is retry initWithAttributes:error

00:25:21.369 --> 00:25:27.129
but without the async required flag set.

00:25:27.130 --> 00:25:34.630
So when async loading fails, you will
receive this QTMovieLoadStateError

00:25:34.630 --> 00:25:39.520
as the load state in your notification handler.

00:25:39.519 --> 00:25:40.670
And what do you do with that?

00:25:40.670 --> 00:25:46.580
Well, we've added a new API in Snow
Leopard, the QTMovieLoadStateErrorAttribute,

00:25:46.579 --> 00:25:49.869
that allows you to ask the movie what went wrong.

00:25:49.869 --> 00:25:53.000
Previously, prior to Snow Leopard, you couldn't do that.

00:25:53.000 --> 00:25:54.980
It was just a mystery why it failed.

00:25:54.980 --> 00:25:58.360
Now you can actually ask the movie what caused you to fail.

00:25:58.359 --> 00:26:05.279
And then you can look at that NSError, get the
domain, get the code, and perhaps react accordingly.

00:26:05.279 --> 00:26:10.859
Or again, you may just want to retry it
without setting the open async required to YES.

00:26:10.859 --> 00:26:13.929
So let's have a demo of this.

00:26:13.930 --> 00:26:19.840
And again, I'll have Kevin come back up and
demonstrate why async loading is interesting.

00:26:19.839 --> 00:26:26.579
>> This demo, I claim is the most
conceptually beautiful demo of all.

00:26:26.579 --> 00:26:30.849
Because it's main feature is a call to sleep for 5 seconds.

00:26:30.849 --> 00:26:35.759
I'm doing that in this demo in order to
simulate very sluggish loading of a movie.

00:26:35.759 --> 00:26:41.269
For example, if you have a media resource in
the file system but it resides on a file server,

00:26:41.269 --> 00:26:45.369
the access to which is very slow-- it
takes a while just to get a few bytes--

00:26:45.369 --> 00:26:52.059
those are the cases on the QuickTime 7 path when loading
can be so sluggish that you risk blocking the main thread.

00:26:52.059 --> 00:26:56.289
And it's specifically for those cases
that you want to use the attribute

00:26:56.289 --> 00:27:00.129
that Tim has just been describing
QTMovieOpenAsyncRequiredAttribute,

00:27:00.130 --> 00:27:05.550
set that to YES that cause all the work that
needs to be done even if it's extremely sluggish,

00:27:05.549 --> 00:27:09.809
they pushed off into the background
and allows your UI to main responses.

00:27:09.809 --> 00:27:13.849
So let us demonstrate what a non-responsive UI looks like.

00:27:13.849 --> 00:27:22.250
I'll click the button and I can't pull down my menus and
the beach ball spins, this sends a message to our server

00:27:22.250 --> 00:27:24.549
in Cupertino to register beach ball spinning.

00:27:24.549 --> 00:27:27.470
No, it doesn't do that.

00:27:27.470 --> 00:27:28.839
Imagine that it did though.

00:27:28.839 --> 00:27:31.970
If you are a programmer, you want
to avoid that in your application.

00:27:31.970 --> 00:27:33.559
How do you avoid the beach ball spinning?

00:27:33.559 --> 00:27:38.119
Well you set async open required
when you initialize the QTMovie.

00:27:38.119 --> 00:27:45.149
All the work will be pushed off to the background and
even if that work comprises a call to sleep for 5 seconds,

00:27:45.150 --> 00:27:50.640
the UI will be able to responsive, the user
pulled down menus, progress indicators will run,

00:27:50.640 --> 00:27:54.170
and then after 5 seconds you will
still get the movie to load.

00:27:54.170 --> 00:27:55.150
So that's a good thing.

00:27:55.150 --> 00:27:59.690
Remember though, when you use OpenAsyncRequired,
for some legacy cases,

00:27:59.690 --> 00:28:02.809
it may fail for reasons that we'll
go in to a more depth later.

00:28:02.809 --> 00:28:05.990
So have a fallback ready, thanks.

00:28:05.990 --> 00:28:10.519
[ Applause ]

00:28:10.519 --> 00:28:11.129
>> Thank you.

00:28:11.130 --> 00:28:12.800
He learns.

00:28:15.200 --> 00:28:19.430
Alright, so we've said that you must
monitor load states when you open a movie.

00:28:19.430 --> 00:28:23.230
There is actually one case, to be
honest, where you don't really need to.

00:28:23.230 --> 00:28:27.970
And that is when you don't care that
the movie is loaded asynchronously.

00:28:27.970 --> 00:28:32.730
And a good example of this would be if you
have a command line tool, where there is no UI.

00:28:32.730 --> 00:28:34.950
So there's no UI to block, you just don't care.

00:28:34.950 --> 00:28:41.269
What you really want is a movie in its fullest
load state before you go on and work on it.

00:28:41.269 --> 00:28:42.359
And this is what you would do.

00:28:42.359 --> 00:28:46.659
You would set the OpenAsyncOKAttribute to NO.

00:28:46.660 --> 00:28:52.279
Telling QTKit, "No, it isn't OK to load
this movie asynchronously in any way.

00:28:52.279 --> 00:28:55.619
I just want to wait until it's loaded completely."

00:28:55.619 --> 00:29:03.250
So now let's start of compare and contrast
this two similar sounding attributes.

00:29:03.250 --> 00:29:11.980
To say OpenAsyncOK, that says "I want you to avoid blocking
the main thread, the thread I'm initializing this movie on."

00:29:11.980 --> 00:29:14.160
By default, the value is YES.

00:29:14.160 --> 00:29:17.920
That's the default behavior of QTMovie movie.

00:29:17.920 --> 00:29:24.970
Now, work may or may not be actually done in a
background thread, if the media is not thread-safe,

00:29:24.970 --> 00:29:28.519
then it will have to happen on
the foreground-- the main thread.

00:29:28.519 --> 00:29:33.339
And it will not result in a failure to load
the movie if backgrounding is not possible.

00:29:33.339 --> 00:29:35.679
It will just tie up your main thread more.

00:29:35.680 --> 00:29:42.620
The new attribute that we're adding in Snow Leopard
will avoid blocking the initialization thread.

00:29:42.619 --> 00:29:43.939
It's NO by default.

00:29:43.940 --> 00:29:46.559
You have to opt in to this new behavior.

00:29:46.559 --> 00:29:49.639
Work will be done in a background thread if it all possible.

00:29:49.640 --> 00:29:56.050
And if it's not possible, we will fail and return the
error to you in the ways that I've already described.

00:29:56.049 --> 00:30:01.000
So now, I'd like to have Kevin come back
up and actually drill down into some

00:30:01.000 --> 00:30:06.690
of the suffix a little bit more
to perhaps clear up some issues.

00:30:06.690 --> 00:30:08.779
>> Or to create issues if I may.

00:30:08.779 --> 00:30:11.529
I didn't know what to call this part of a talk.

00:30:11.529 --> 00:30:18.569
I'm going to drill down on a lot of things that Tim said,
so I just use the word usage notes but disregard that.

00:30:18.569 --> 00:30:25.529
>> Let's instead use this fancier title, "A taxonomy of
Media Operations", that's the way to start your talk.

00:30:25.529 --> 00:30:28.519
This in fact is not a complete taxonomy of media operations.

00:30:28.519 --> 00:30:34.400
It's really just those media operations that we support
in QTKit, and make available to you as QTKit clients.

00:30:34.400 --> 00:30:37.630
Obviously, you can playback media resources with QTKit.

00:30:37.630 --> 00:30:39.340
We've talked mostly about that.

00:30:39.339 --> 00:30:40.970
You can export media resources.

00:30:40.970 --> 00:30:46.700
You can re-encode their audio and video and write
them to container formats using the export features.

00:30:46.700 --> 00:30:53.420
You can edit them in place in QTKit, cut, copy, and
paste editing, insertions, deletions all supported.

00:30:53.420 --> 00:30:58.789
You can also capture media from external
devices, cameras and what have you.

00:30:58.789 --> 00:31:05.420
Now, Tim's already mentioned that some of these operations
are enhanced using QuickTime X technology in Snow Leopard.

00:31:05.420 --> 00:31:06.779
Let me highlight those.

00:31:06.779 --> 00:31:08.740
Playback is the one we've talked about most.

00:31:08.740 --> 00:31:11.789
For enhanced playback in Snow Leopard, you want to opt

00:31:11.789 --> 00:31:16.720
in via QTMovieOpenAsyncRequiredAttribute
as we've already discussed.

00:31:16.720 --> 00:31:20.900
For enhanced export functionality in QTKit, there is nothing

00:31:20.900 --> 00:31:24.490
that your application needs to do
beyond what it is already doing.

00:31:24.490 --> 00:31:30.039
If you are calling QTMovieWriteToFile:attributes
and the attributes dictionary

00:31:30.039 --> 00:31:37.259
that you provide specifies can export operation to
an Apple device format, that export will be enhanced

00:31:37.259 --> 00:31:43.390
with QuickTime X technology and the primary benefit there
is greater efficiency, but there are others as well.

00:31:43.390 --> 00:31:49.950
The media will be as often as possible and virtually
universally for these devices color tag appropriately

00:31:49.950 --> 00:31:56.190
so that your color fidelity and accuracy regardless
of the destination will be the best possible.

00:31:56.190 --> 00:32:00.840
Tim also mentioned that the capture
functionality of QTKit known cleverly

00:32:00.839 --> 00:32:04.079
as QTKitCapture has also been enhanced with QuickTime X.

00:32:04.079 --> 00:32:08.099
There is nothing that you need to do in your
application if you're capturing via QTKit.

00:32:08.099 --> 00:32:11.669
To take advantage of this, it just
comes for free on Snow Leopard.

00:32:11.670 --> 00:32:16.640
One of the advantages is that for 64-bit
applications that you're deploying on Snow Leopard,

00:32:16.640 --> 00:32:20.650
you will get 64-bit native capture services.

00:32:20.650 --> 00:32:26.140
Also, as often possible, the media that you
capture from devices will be appropriately tagged

00:32:26.140 --> 00:32:32.590
with color profiling information, so again, you
get the best fidelity and accuracy we can offer.

00:32:32.589 --> 00:32:38.549
The editing box is not enhanced with
QuickTime X technology in Snow Leopard.

00:32:38.549 --> 00:32:41.609
So why did we do it the way we do it?

00:32:41.609 --> 00:32:45.529
And why did we present these enhancements
to you in the form that we did?

00:32:45.529 --> 00:32:48.339
Well, in order to explain that, let
me give you a little background.

00:32:48.339 --> 00:32:51.179
Let me give you a little conceptual history.

00:32:51.180 --> 00:32:56.789
Going back to the beginning of QuickTime, what
does QuickTime actually do with media resources?

00:32:56.789 --> 00:33:03.819
You may know that all media resources would open with
QuickTime from 1.0 up through QuickTime 7 are represented

00:33:03.819 --> 00:33:09.819
as a movie, a uniform representation of all media resources.

00:33:09.819 --> 00:33:15.419
You might be aware of some of the constituent parts
of a movie, the tracks, the media of the tracks,

00:33:15.420 --> 00:33:18.779
the sample descriptions, and the sample tables of the media.

00:33:18.779 --> 00:33:26.819
For QuickTime 7 and the earlier releases, to operate
on media resources regardless of the operation

00:33:26.819 --> 00:33:33.460
that it performs, any of those that I mentioned on my
previous slide, this movie representation must be created.

00:33:33.460 --> 00:33:39.210
It can either be loaded from a file if it's a
QuickTime movie file or it must be created on the fly

00:33:39.210 --> 00:33:42.680
when importing media from a different
format such as an MP3 file.

00:33:42.680 --> 00:33:48.029
And in fact, when I was showing you earlier the
demo of opening an MP3 file with QuickTime 7,

00:33:48.029 --> 00:33:52.899
all that work that was going on before any
operation was performed was the work required

00:33:52.900 --> 00:33:56.630
to create the movie representation of the MP3 file.

00:33:56.630 --> 00:34:04.340
MP3 was chosen for that demo because in fact that container
format contains just about the least information possible

00:34:04.339 --> 00:34:07.789
in order for us to create a movie representation from it.

00:34:07.789 --> 00:34:11.699
There's no information there about,
well there's seldom information there

00:34:11.699 --> 00:34:14.289
about the number, the extent of the audio packets.

00:34:14.289 --> 00:34:17.409
It's usually just a stream of audio packets in an MP3 file.

00:34:17.409 --> 00:34:20.789
So we've gotta do some parsing
to create that representation.

00:34:20.789 --> 00:34:26.929
That work is what we do implicitly in QuickTime 7
if you call the movie toolbox API, NewMovieFromFile

00:34:26.929 --> 00:34:33.489
or NewMovieFromProperties or the QTKit method,
QTMovie initWithFile, QTMovie initWithURL.

00:34:33.489 --> 00:34:43.209
By default, by creating that movie representation, we
are implicitly preparing that media resource for all

00:34:43.210 --> 00:34:45.639
of the operations that you can perform on it.

00:34:45.639 --> 00:34:47.029
You can play it back.

00:34:47.030 --> 00:34:48.640
You can edit it in place.

00:34:48.639 --> 00:34:52.619
You can export it because we have
this representation with all

00:34:52.619 --> 00:34:56.000
of the powerful things that we can do with it implicitly.

00:34:56.000 --> 00:35:00.880
However as you've seen, it's expensive
in some cases to prepare for all that.

00:35:00.880 --> 00:35:07.900
So all these years when you've been opening MP3 files
with QuickTime, we have been laboriously preparing for you

00:35:07.900 --> 00:35:10.950
to export those MP3 files to other formats.

00:35:10.949 --> 00:35:13.349
Then you turn around and you just play them.

00:35:13.349 --> 00:35:16.969
And we're left there thinking why did we do all that work?

00:35:16.969 --> 00:35:21.279
We could have waited to parse those audio
packets until it's actually time to play them.

00:35:21.280 --> 00:35:26.130
Well the good news is, with QuickTime
X, we have altered the design,

00:35:26.130 --> 00:35:30.890
we've introduced into the model the declaration of intent.

00:35:30.889 --> 00:35:33.989
What purpose are you opening this media resource for?

00:35:33.989 --> 00:35:41.159
If you, the client, tell us the framework why you're
opening this thing, we can tailor the work that we do

00:35:41.159 --> 00:35:43.869
to prepare it for the purpose that you declare.

00:35:43.869 --> 00:35:49.759
And that's why, as Tim explained to you
earlier, QTMovieOpenForPlaybackAttribute.

00:35:49.760 --> 00:35:51.530
You're declaring your intent.

00:35:51.530 --> 00:35:58.810
You're leaving us off the hook for preparing that media
resource for operations beyond the scope of playback.

00:35:58.809 --> 00:36:02.509
Now for backward compatibility, if
you say nothing about your intention,

00:36:02.510 --> 00:36:08.070
about the purpose for which you're initializing a
QTMovie instance, we will do what we've done in the past

00:36:08.070 --> 00:36:10.910
and implicitly prepare it for everything that we can do.

00:36:10.909 --> 00:36:14.869
All the things that I mentioned at
the top of this portion of the talk.

00:36:14.869 --> 00:36:18.659
But regardless, whether you declare your intention or not,

00:36:18.659 --> 00:36:23.909
recall that time-based media has
fundamental operation that's progressive.

00:36:23.909 --> 00:36:25.210
It's incremental.

00:36:25.210 --> 00:36:30.490
These pieces of time-based media are
authored to be consumed overtime.

00:36:30.489 --> 00:36:34.539
The video frame we're displaying
now is going to be replaced soon.

00:36:34.539 --> 00:36:40.420
This is not the type of object as would be
the case with many other objects in Cocoa

00:36:40.420 --> 00:36:44.740
for which we internalize all the
data at initialization time.

00:36:44.739 --> 00:36:48.529
Operate on the data in memory and
then if something's changed,

00:36:48.530 --> 00:36:52.060
write everything out, externalize it when you're done.

00:36:52.059 --> 00:36:54.730
That's not what time-based media does.

00:36:54.730 --> 00:36:56.420
We read incrementally.

00:36:56.420 --> 00:37:00.340
We load incrementally, and that's
why as Tim described earlier,

00:37:00.340 --> 00:37:04.650
these load states are fundamental to
the operation of time-based media.

00:37:04.650 --> 00:37:08.980
And why? We introduced them with
QTKit when initially shipped on Tiger,

00:37:08.980 --> 00:37:12.670
and we're still relying on the same loading model now.

00:37:12.670 --> 00:37:16.960
So, for QuickTime X, something new at initialization time.

00:37:16.960 --> 00:37:18.769
You declare your intent.

00:37:18.769 --> 00:37:26.130
Subsequently, the incremental operation of the QTMovie
instance is the same that you remember from before.

00:37:26.130 --> 00:37:30.539
The load states are exactly the same as
we've presented to you on Tiger and Leopard.

00:37:30.539 --> 00:37:36.340
So I don't need to review all these since Tim
has done a good job of explaining what these are.

00:37:36.340 --> 00:37:43.230
QTMovieLoadStatePlaythroughOK deserves special mention
because that particular state is unique for 2 reasons.

00:37:43.230 --> 00:37:47.039
One, you can enter and also regress from that state.

00:37:47.039 --> 00:37:53.840
What it essentially means is that when we
reach QTMovieLoadStatePlaythroughOK that means

00:37:53.840 --> 00:38:00.570
that we're projecting through our finely tuned
algorithms that you can start playback and have it proceed

00:38:00.570 --> 00:38:04.590
through the duration of the media
resource without having to wait,

00:38:04.590 --> 00:38:07.980
having to pause for more data to arrive before proceeding.

00:38:07.980 --> 00:38:12.920
However, if network conditions change
or it's just a bad day, there--

00:38:12.920 --> 00:38:18.119
it might happen that data starts loading
more slowly than it had been up to that point

00:38:18.119 --> 00:38:22.869
and the QTMovie instance may regress
to QTMovieLoadStatePlayable.

00:38:22.869 --> 00:38:28.469
If that happens and if the playback has to stall
because more media needs to load before we can proceed,

00:38:28.469 --> 00:38:31.969
that will just happen automatically
and playback will resume automatically

00:38:31.969 --> 00:38:34.799
at the same rate without any intervention on your part.

00:38:34.800 --> 00:38:39.730
You can derail that process if you like by
setting the rate of that instance of QTMovie to 0

00:38:39.730 --> 00:38:42.289
and then automatic playback won't resume.

00:38:42.289 --> 00:38:47.210
But the behavior for resumption is automatic,
if you don't otherwise change things.

00:38:47.210 --> 00:38:53.519
QTMovieLoadStateComplete also has very specific,
very special meaning that's directly relevant

00:38:53.519 --> 00:38:58.889
to our QuickTime X story, so we'll
get back to that in a minute.

00:38:58.889 --> 00:39:03.099
But suppose you're an application
that just wants to play media.

00:39:03.099 --> 00:39:08.019
Tim talked about load states, and if that didn't
go on long enough, Kevin talked about load states.

00:39:08.019 --> 00:39:12.130
Why do I need to know these load
states, I just fill out tax forms.

00:39:12.130 --> 00:39:20.130
I was going to say, I just showed how
to use the track pad but I don't know.

00:39:20.130 --> 00:39:26.309
Anyway, there is a method on QTMovie that you can use
that doesn't require that you monitor all these progress.

00:39:26.309 --> 00:39:29.070
You can get QTKit to do that monitoring for you.

00:39:29.070 --> 00:39:31.480
The method is called autoplay.

00:39:31.480 --> 00:39:37.829
So you would set up your code like this if you just want to
play when it-- the movie reaches the playthrough OK state.

00:39:37.829 --> 00:39:43.940
Initialize the movie, you can immediately put it into a view
regardless of its state if you like and then say autoplay.

00:39:43.940 --> 00:39:48.289
And the result of that is that the movie will
play as soon as it's ready and that will work

00:39:48.289 --> 00:39:52.349
on the QuickTime 7 path or the
QuickTime X path equally well.

00:39:52.349 --> 00:39:55.630
I should note, however, that if you do choose to put a movie

00:39:55.630 --> 00:40:02.230
into a view before it has reached the loaded
state, that QTMovie view will draw nothing.

00:40:02.230 --> 00:40:08.050
So if you want to avoid big holes in your UI such
as what I demonstrated when I first came up here

00:40:08.050 --> 00:40:14.100
with my first demo application, you can wait until the
movie reaches the loaded state before showing your view,

00:40:14.099 --> 00:40:19.009
or alternately before setting the movie on to the view.

00:40:19.010 --> 00:40:23.580
>> Alright, QTMovieLoadStateComplete, it's special.

00:40:23.579 --> 00:40:25.619
What does it mean?

00:40:25.619 --> 00:40:33.440
And what happens to it when I opt in for QuickTime X
playback by setting QTMovieOpenForPlaybackAttribute.

00:40:33.440 --> 00:40:37.920
Let's say what-- let's just describe what this thing is.

00:40:37.920 --> 00:40:44.820
Essentially, when a movie reaches
QTMovieLoadStateComplete, we have what I described earlier

00:40:44.820 --> 00:40:50.450
as the uniform representation that QuickTime
7 uses for all media resources, the movie.

00:40:50.449 --> 00:40:56.819
The MP3 file that I opened earlier when that, the
controller bar filled in all the way to the right

00:40:56.820 --> 00:41:01.630
and we reached load state complete, well we've
got the compete movie that will locate all

00:41:01.630 --> 00:41:05.400
of the audio packets within that
half a gigabyte of MP3 data.

00:41:05.400 --> 00:41:11.119
So at that stage, it's safe for your
application to call movie format representation.

00:41:11.119 --> 00:41:15.420
The method on QTMovie that allows
you to fetch the externalizable form

00:41:15.420 --> 00:41:19.909
of this uniform movie representation,
then you can write back to storage.

00:41:19.909 --> 00:41:25.469
But QTMovieLoadStateCompete also implies
that all of the media data required

00:41:25.469 --> 00:41:29.569
by that movie is either immediately
available because it's in the file system

00:41:29.570 --> 00:41:33.740
or some other immediately accessible storage.

00:41:33.739 --> 00:41:39.379
Or it has been transferred via a
network protocol and completely cached,

00:41:39.380 --> 00:41:42.410
so it's all available at that point as well.

00:41:42.409 --> 00:41:47.679
So since all the media data is completely
available as well, at that point you can call method

00:41:47.679 --> 00:41:52.029
such as writeToFile in order to perform an export operation.

00:41:52.030 --> 00:41:58.820
All the media data is there for you to re-encode or whatever
you're trying to do via your right to file operation.

00:41:58.820 --> 00:42:07.440
Now, note that both the use of the movie representation
and the caching behavior are unique to QuickTime 7.

00:42:07.440 --> 00:42:16.990
In other words, QTMovieLoadStateComplete implies
behavior that is very QuickTime 7 like and does not apply

00:42:16.989 --> 00:42:23.719
to QuickTime X for which we don't always have a movie
representation and which does not sign a contract

00:42:23.719 --> 00:42:26.879
that requires it to cache all of
the media data and retain it

00:42:26.880 --> 00:42:30.730
in it's cache throughout the duration
of that instance of QTMovie.

00:42:30.730 --> 00:42:38.900
So, what happens to QTMovieLoadStateComplete when
you say QTMovieOpenForPlaybackAttribute is YES?

00:42:38.900 --> 00:42:43.010
Essentially what we're going to do is
not signal that we've reached that state

00:42:43.010 --> 00:42:49.800
And there's no need for us to signal it because you've
already declared my intention is only to play this instance

00:42:49.800 --> 00:42:54.830
of QTMovie, we will tell you when it's playable,
we will tell you when playthrough is OK.

00:42:54.829 --> 00:42:58.000
We'll even do that work for you if you say autoplay.

00:42:58.000 --> 00:43:04.099
There's no need for it to enter any state beyond
that because your intention is only playback.

00:43:04.099 --> 00:43:07.509
Well, that's a restriction, that's a change of behavior.

00:43:07.510 --> 00:43:11.900
I opted in to this new-- this new
feature, QuickTime X playback,

00:43:11.900 --> 00:43:16.030
and something is unavailable, QTMovieLoadStateComplete.

00:43:16.030 --> 00:43:23.800
I would be remiss if I didn't list all of those things
that are not available when you opt in for this feature

00:43:23.800 --> 00:43:26.940
that enables the more efficient playback of QuickTime X.

00:43:26.940 --> 00:43:29.500
So let's go through all of the usage restrictions.

00:43:29.500 --> 00:43:36.219
When you say playback, we help you to
enforce the contract that you have signed.

00:43:36.219 --> 00:43:43.009
The instance of QTMovie that's intended
for playback is allowed only to play back.

00:43:43.010 --> 00:43:47.880
No editing will be available, nor is it required
since you declared your intention of playback.

00:43:47.880 --> 00:43:50.510
Saving is not available, write to file.

00:43:50.510 --> 00:43:52.030
Archiving is not available.

00:43:52.030 --> 00:43:58.730
Instead of archiving in the QTMovie instance, we recommend
that you archive either the dictionary attributes

00:43:58.730 --> 00:44:04.480
that you initialize a QTMovie with or selected attributes of
the QTMovie instance at the time of archiving that you want

00:44:04.480 --> 00:44:09.510
to have on archive when you want to create another
QTMovie instance from the same media resource.

00:44:09.510 --> 00:44:15.640
Export is not available when you opt in for playback,
and there is no access to the QuickTime 7 primitive

00:44:15.639 --> 00:44:19.129
such as capital M Movie or capital T Track.

00:44:19.130 --> 00:44:22.500
How do we enforce these restrictions?

00:44:22.500 --> 00:44:29.690
Very simply, if you attempt to call any of the methods that
are not allowed, when you opt in for playback or if you try

00:44:29.690 --> 00:44:35.980
to access the attributes that are not available, in
that case, we raise a very particular NSException,

00:44:35.980 --> 00:44:41.659
with a name that's so long, you can't miss it.

00:44:41.659 --> 00:44:47.109
QTDisallowedForInitializationPurposeException,
you declared your intent it's for playback.

00:44:47.110 --> 00:44:50.820
Then you try to do something beyond the
scope of playback, we raise the exception.

00:44:50.820 --> 00:44:55.519
And we do that in order to help you to
find those places in your application

00:44:55.519 --> 00:45:00.820
where your usage might move beyond
the contract that you've entered.

00:45:00.820 --> 00:45:05.950
So in order to demonstrate a case like this, I took
an application, a sample application that we have

00:45:05.949 --> 00:45:10.750
on the Apple developer connection site called QTKit Player.

00:45:10.750 --> 00:45:16.489
And this is an application that we've been
providing since 2004 that demonstrates basic usage

00:45:16.489 --> 00:45:19.219
of QTKit for playing back media resources.

00:45:19.219 --> 00:45:23.459
So I've started with this and only
made some very small changes here.

00:45:23.460 --> 00:45:26.740
For one thing, I took Tim's recommendation
from earlier in this talk.

00:45:26.739 --> 00:45:32.899
I actually heard this talk sooner than you
did, so I was able to apply what Tim said.

00:45:32.900 --> 00:45:37.960
And I have moved from using movieWithFile which is
what the source, if you download it from the web,

00:45:37.960 --> 00:45:40.780
will use and I'm using movieWithAttributes instead.

00:45:40.780 --> 00:45:45.340
And in the attributes dictionary,
I am setting the path of the file

00:45:45.340 --> 00:45:51.620
that I want open using the key QTMovieFilenameAttribute
and I'm also setting open for playback to be YES,

00:45:51.619 --> 00:45:56.150
because I want my playback to be enhanced with QuickTime X.

00:45:56.150 --> 00:45:58.840
There's one other thing I did to this application as well.

00:45:58.840 --> 00:46:07.510
I took the advice of an O'Reilly article that demonstrates
the methodology for catching uncaught NSExceptions.

00:46:07.510 --> 00:46:08.730
And why did I do this?

00:46:08.730 --> 00:46:16.380
Because I want to break in the debugger whenever anything
is attempted by this application that goes beyond the scope

00:46:16.380 --> 00:46:21.220
of the APIs that are available when you
say that the movies open for playback.

00:46:21.219 --> 00:46:26.689
So I wrote this little, following the O'Reilly advice,
I wrote a little function called catch some exceptions

00:46:26.690 --> 00:46:33.240
and I'm looking for my lengthily named
QTDisallowedInitializationPurposeException

00:46:33.239 --> 00:46:34.909
because I want to know why that happened.

00:46:34.909 --> 00:46:41.409
And I'm also going to log to the console the
reason that this happened because we provide,

00:46:41.409 --> 00:46:45.149
when we raised these exceptions, some very
particular information that will be useful to you

00:46:45.150 --> 00:46:48.210
for debugging why did this exception get raised.

00:46:48.210 --> 00:46:55.340
So, let me build and debug this application,
QTKit player with these modest improvements,

00:46:55.340 --> 00:47:01.500
and let me attempt to open a media
resource for playback in that application.

00:47:01.500 --> 00:47:04.420
Well, I hit my breakpoint.

00:47:04.420 --> 00:47:07.619
I had the
QTMovieDisallowedForInitializationPurposeException.

00:47:07.619 --> 00:47:12.019
Let me show the debugger and the console.

00:47:12.019 --> 00:47:13.800
I'll clear the console.

00:47:13.800 --> 00:47:22.450
Let me step over this line that will log what happen and it
says to me, well, I tried to query the QTMovie attribute,

00:47:22.449 --> 00:47:28.819
QTMovieCurrentSizeAttribute which is not allowed
when I set QTMovieOpenForPlayback to YES.

00:47:28.820 --> 00:47:31.300
Tim mentioned earlier that this particular attribute,

00:47:31.300 --> 00:47:35.830
QTMovieCurrentSizeAttribute is deprecated
in Snow Leopard, and that's true.

00:47:35.829 --> 00:47:39.929
If your application is using it,
it will still function as defined.

00:47:39.929 --> 00:47:44.750
But when you opt in via the QTMovieOpenForPlaybackAttribute

00:47:44.750 --> 00:47:49.190
for the new playback set, we don't
allow this attribute at all.

00:47:49.190 --> 00:47:54.900
We're going to encourage you as you make the modifications
to your application to adopt the different attribute

00:47:54.900 --> 00:47:58.740
that we're recommending that you
use, QTMovieNaturalSizeAttribute.

00:47:58.739 --> 00:48:10.439
So, I will look for preview of coming attraction,
QTMovieCurrentSizeAttribute, and I will simply change

00:48:10.440 --> 00:48:15.150
that to QTMovieNaturalSizeAttribute
where it occurs, alright.

00:48:15.150 --> 00:48:23.420
Is it possible to edit source code
live on stage in San Francisco?

00:48:23.420 --> 00:48:28.920
I will rebuild and relaunch the
application now with that modification.

00:48:28.920 --> 00:48:37.280
I'll try to open a media resource again, see what trouble
I run into, and I hit the breakpoint another time.

00:48:37.280 --> 00:48:45.380
Let me display the console and the debugger, step
over that line that logs the reason to the console.

00:48:45.380 --> 00:48:49.329
This time it says "oh, I tried
to set the editable attribute."

00:48:49.329 --> 00:48:53.159
Well the person writing this application
actually was very ambitious.

00:48:53.159 --> 00:48:59.369
He not only wanted to display the use-- to provide
an exemplar, the use of QTKit for playback,

00:48:59.369 --> 00:49:01.980
he moved beyond it and added some editing features as well.

00:49:01.980 --> 00:49:05.119
He wanted to set the QTMovies to be editable.

00:49:05.119 --> 00:49:09.699
Well, that's not allowed when I
say QTMovieOpenForPlayback is yes.

00:49:09.699 --> 00:49:20.679
So I'll look for where that occurs, and just for the
purpose of demos, I will simply comment that out,

00:49:20.679 --> 00:49:30.969
build a debug again, relaunch the application
and with those two changes I'm now able

00:49:30.969 --> 00:49:37.019
to open media resources [applause]
and take advantage of QuickTime X.

00:49:37.019 --> 00:49:42.090
Now I realize that hitting breakpoints in debugger
is not the most interesting demo in the world.

00:49:42.090 --> 00:49:47.380
But since you have code, you have code
that might be as long as 5 years old now.

00:49:47.380 --> 00:49:50.450
That might have been worked on
by other developers in the past.

00:49:50.449 --> 00:49:54.849
You might be interested in the methodology
like this for finding those places in your code

00:49:54.849 --> 00:49:59.909
that you might need to modify as you opt in for QuickTime X.

00:49:59.909 --> 00:50:02.089
So, let's summarize your transition.

00:50:02.090 --> 00:50:07.460
If you have code like that and you want to take
advantage of QuickTime X on Snow Leopard, what do you do?

00:50:07.460 --> 00:50:15.789
Well first thing, tell us what you want to
do and we'll help you help us to help you.

00:50:15.789 --> 00:50:19.039
>> Tell us that you want to open
something else for something for playback

00:50:19.039 --> 00:50:21.900
and we will tell you the work we do for your intention.

00:50:21.900 --> 00:50:24.090
It will be more efficient in a lot of cases.

00:50:24.090 --> 00:50:29.039
And you do that by means of the attribute that
Tim described, QTMovieOpenForPlaybackAttribute.

00:50:29.039 --> 00:50:35.849
If the media resource that you're opening is openable
by QuickTime X, you will get QuickTime X in support

00:50:35.849 --> 00:50:39.429
of that instance of QTMovie for playback.

00:50:39.429 --> 00:50:45.139
Then, another thing that you must do before you ship your
application that you're modifying for this purpose is

00:50:45.139 --> 00:50:50.000
to uncover any possible usage in
that app that goes beyond playback,

00:50:50.000 --> 00:50:55.590
that enters into this restricted areas
when you declare open for playback.

00:50:55.590 --> 00:51:01.120
You can find those by reviewing the documentation, the
Snow Leopard documentation that we provided to you along

00:51:01.119 --> 00:51:04.299
with the version of Snow Leopard
you have calls out which methods

00:51:04.300 --> 00:51:07.780
and attributes are restricted when you open for playback.

00:51:07.780 --> 00:51:15.000
As Tim showed you earlier, the QTKit headers, QTMovie.h
and the others will also call out the restrictions.

00:51:15.000 --> 00:51:17.920
So take a look at those, you can watch where the--

00:51:17.920 --> 00:51:22.289
this particular exception which gives you
some diagnostic information when it's raised

00:51:22.289 --> 00:51:26.880
about what it is the app was trying
to do when this exception was raised.

00:51:26.880 --> 00:51:34.700
And by the way, one of my colleagues asked me for the demo,
why didn't I just break on Objective-C exception throw?

00:51:34.699 --> 00:51:36.629
Well, I didn't think of it.

00:51:36.630 --> 00:51:42.079
No, actually what I wanted to do is to demonstrate a
methodology that will allow you to run your own custom code

00:51:42.079 --> 00:51:47.409
when this particular exception is raised so that you
can log a bug automatically or send yourself emails,

00:51:47.409 --> 00:51:49.960
and you better look at this particular part of the app.

00:51:49.960 --> 00:51:54.619
But of course, just breaking on
that other thing will work too.

00:51:54.619 --> 00:52:01.210
Now, if you happen to uncover any usage of this sort
that goes beyond playback, you have a choice to make.

00:52:01.210 --> 00:52:07.610
You can decide to modify your application not to require
the additional behavior that goes beyond playback.

00:52:07.610 --> 00:52:12.769
That instance of QTMovie, well it's fine if it
only plays back whatever it happened to be doing

00:52:12.769 --> 00:52:18.820
that goes beyond playback or perhaps that feature
isn't actually needed, or perhaps what I can do

00:52:18.820 --> 00:52:25.400
in my application is to create a different instance
of QTMovie from the same media resource and perform

00:52:25.400 --> 00:52:29.900
that nonplayback operation on that
other instance, your choice.

00:52:29.900 --> 00:52:34.710
However, you may have an application
which simply requires a broader set

00:52:34.710 --> 00:52:38.460
of features then just playback for an instance of QTMovie.

00:52:38.460 --> 00:52:45.090
In that case, you simply wouldn't declare that that instance
is open for playback and you would enjoy the same support

00:52:45.090 --> 00:52:51.010
that we've given you in prior releases of Mac OS X.

00:52:51.010 --> 00:52:56.670
Now, we've told you some of the benefits,
now we've outlined the entire cost,

00:52:56.670 --> 00:52:58.970
work that you will need to do to
transition your application.

00:52:58.969 --> 00:53:02.159
Let's close this whole section of
the talk with additional benefits.

00:53:02.159 --> 00:53:07.250
What do you get when you do this work to opt
in using QTMovieOpenForPlaybackAttribute?

00:53:07.250 --> 00:53:12.760
Well, to review some of the things Tim mentioned
earlier, the QuickTime X services are 64-bit native.

00:53:12.760 --> 00:53:18.740
So when you deploy your 64-bit application that
plays media you want 64-bit native playback services,

00:53:18.739 --> 00:53:22.489
that's how you get them in QTKit file, this attribute.

00:53:22.489 --> 00:53:26.579
Further, QuickTime X takes advantage of
multicore so you want things to make,

00:53:26.579 --> 00:53:29.279
take advantage of the cores that
are available on the hardware.

00:53:29.280 --> 00:53:31.430
That happens too when you opt in.

00:53:31.429 --> 00:53:36.279
Color fidelity is improved when you opt in for QuickTime X.

00:53:36.280 --> 00:53:42.670
More details about color management on Snow Leopard
in general are in Session 301 which occurs on Friday.

00:53:42.670 --> 00:53:45.960
The particulars of color management
for video will be covered there.

00:53:45.960 --> 00:53:48.900
So go to that session for more details about color fidelity.

00:53:48.900 --> 00:53:57.530
You will also get, in your application, the services of the
hardware code that Tim Bens [phonetic] mentioned yesterday

00:53:57.530 --> 00:54:00.250
in the Graphics and Media State of the Union.

00:54:00.250 --> 00:54:06.559
You want hardware accelerated H.264 decode,
tell me how to get it, we already have.

00:54:06.559 --> 00:54:10.590
You opt in using QTKit via QTMovieOpenForPlayback.

00:54:10.590 --> 00:54:13.390
Now some notes about the hardware decoder.

00:54:13.389 --> 00:54:19.299
This is available in various recent
models of hardware that Apple has shipped.

00:54:19.300 --> 00:54:26.080
The hardware decoder has a limited number of sessions,
video session that can support simultaneously.

00:54:26.079 --> 00:54:29.500
The number is not always one but it's small.

00:54:29.500 --> 00:54:35.329
If you want to guarantee or if you want to improve your
chances of getting the services of the hardware decoder

00:54:35.329 --> 00:54:42.690
for the H.264 video content that you are playing your
applications, you can use the QTMovie methods setActive.

00:54:42.690 --> 00:54:48.789
If you set a movie to be inactive via setActive:
NO what you've essentially done is to say,

00:54:48.789 --> 00:54:54.259
I don't need this to be prepared for rendering right now, I
wanted to initialize it because it will eventually be used

00:54:54.260 --> 00:54:56.560
by my document or whatever it is that you're doing.

00:54:56.559 --> 00:55:01.980
But I don't need to render it now, it's not on screen,
it's not on the current slide, for example, in keynote,

00:55:01.980 --> 00:55:08.030
I'll set it to be active later and only when I need to
render it will I do that by having just a small number

00:55:08.030 --> 00:55:12.920
of QTMovie instances active at a time, only those that
you happen to be rendering, you increase the chances

00:55:12.920 --> 00:55:16.559
of getting the services of the hardware decoder.

00:55:16.559 --> 00:55:21.750
Also, you may have gone to the Graphics and Media
State of the Union and seen some iPhone apps

00:55:21.750 --> 00:55:27.480
for iPhone OS 3.0 that are displaying HTTP Live Streams.

00:55:27.480 --> 00:55:33.539
They look great and this whole story for
setting up these streams is really good.

00:55:33.539 --> 00:55:37.170
More details about that in Session
313 and that's tomorrow morning.

00:55:37.170 --> 00:55:43.010
But suppose you have a desktop application and
you want it to be able to play HTTP Live Streams,

00:55:43.010 --> 00:55:47.870
that's available to you also in Snow Leopard
via the same means that we've already described.

00:55:47.869 --> 00:55:54.529
You present the URL for one of these HTTP Live
Streams to QTMovie in the attributes dictionary.

00:55:54.530 --> 00:55:58.720
You say QTMovie URL attribute, and you
give it the URL for an HTTP Live Stream,

00:55:58.719 --> 00:56:05.319
and you also say QTMovieOpenForPlayback attribute is
YES and the Live Stream will play in your application.

00:56:05.320 --> 00:56:12.380
Alright. So that goes over in detail
enhancements of QTKit in Snow Leopard.

00:56:12.380 --> 00:56:19.559
But suppose your application is already a media-rich
application and you're performing a number of operations,

00:56:19.559 --> 00:56:24.349
for example you're performing exports on
background threads, you're doing a lot of stuff,

00:56:24.349 --> 00:56:30.210
and you want to know how these new features
and these new recommendations pertain to you.

00:56:30.210 --> 00:56:37.300
Well, the answer is that all of the existing
recommendations for use of QTKit in rich-media applications

00:56:37.300 --> 00:56:42.070
that perform operations such as export on
background threads, those are still pertinent.

00:56:42.070 --> 00:56:48.630
Everything that we've told you still applies and
it's not changed in anyway by these new features.

00:56:48.630 --> 00:56:55.369
The tech note 2125, I'll wait !%while you
look that up and read the previous 2124,

00:56:55.369 --> 00:57:00.369
but probably not, I've done it, just a few minutes left.

00:57:00.369 --> 00:57:04.409
Thread-safe Programming in QuickTime,
that tech note has a section that talks

00:57:04.409 --> 00:57:09.529
about QTKit usage for multithreaded applications.

00:57:09.530 --> 00:57:15.730
Those recommendations include something that Tim
mentioned earlier, QTMovie should always be initialized

00:57:15.730 --> 00:57:20.099
on the main thread, allocate and
initialize QTMovie on the main thread.

00:57:20.099 --> 00:57:23.139
In Snow Leopard, you can also improve the responsiveness

00:57:23.139 --> 00:57:29.429
of your application via the attribute
Tim mentioned earlier OpenAsyncRequired.

00:57:29.429 --> 00:57:36.230
Then if you need to perform an operation on that instance of
QTMovie on the background thread, you can migrate that movie

00:57:36.230 --> 00:57:41.490
on a background thread which essentially means that you
intend to message that movie and you expect notifications

00:57:41.489 --> 00:57:44.619
from that movie to be posted on the background thread.

00:57:44.619 --> 00:57:49.389
There are several steps that need
to be performed in order to do that.

00:57:49.389 --> 00:57:54.190
On the background thread on which you want to operate
on the QTMovie, the first thing you must do is

00:57:54.190 --> 00:57:58.349
to invoke the class method enterQTKitOnThread.

00:57:58.349 --> 00:58:00.099
What does this do?

00:58:00.099 --> 00:58:07.210
This tells the underlying media stack that you intend
to operate on media on this preemptive background thread

00:58:07.210 --> 00:58:14.260
and you're signaling the media stack to maintain
independent state for that thread and not to interact

00:58:14.260 --> 00:58:17.530
with its state for the main thread or other threads.

00:58:17.530 --> 00:58:22.080
In other words, you're telling the media
stack to operate in a thread-safe manner.

00:58:22.079 --> 00:58:23.579
This is essential.

00:58:23.579 --> 00:58:30.019
Some of the components that are required
for certain media resources, image decoders,

00:58:30.019 --> 00:58:32.820
audio decoders are not marked as thread-safe.

00:58:32.820 --> 00:58:38.180
Many of third party ones over the years have
been marked as thread-safe, some are still not.

00:58:38.179 --> 00:58:42.619
You must do this in order to ensure that
only those that are prepared to operate

00:58:42.619 --> 00:58:46.509
on background preemptive threads are allowed to operate.

00:58:46.510 --> 00:58:52.110
Then once you've prepared your thread for media
operation via the class method I've mentioned,

00:58:52.110 --> 00:58:59.220
detach the instance of QTMoive from its initialization
thread by calling -detachFromCurrentThread on that thread,

00:58:59.219 --> 00:59:03.480
then with that same instances of
QTMovie, call -attachToCurrentThread

00:59:03.480 --> 00:59:07.619
on the thread on which you intend to operate on it.

00:59:07.619 --> 00:59:12.819
Now note that some components are not marked
as thread-safe especially some legacy ones,

00:59:12.820 --> 00:59:16.900
so you need to be prepared for
-detachFromCurrentThread to fail.

00:59:16.900 --> 00:59:24.809
This is similar in many ways to the cases that Tim
mentioned earlier when QTMovieOpenAsyncRequired may fail

00:59:24.809 --> 00:59:29.679
because the components required for the movie are
not prepared to operate on a background thread.

00:59:29.679 --> 00:59:33.169
So if that happens, you need to have a fallback ready.

00:59:33.170 --> 00:59:37.220
Either you need to perform the operation on
the main thread or you need to signal the user

00:59:37.219 --> 00:59:42.439
that this operation is not available
for that particular instance of QTMovie.

00:59:42.440 --> 00:59:47.980
The tech note I mentioned covers all this in
detail, so review that for more information.

00:59:47.980 --> 00:59:53.309
A particular point that is not brought up by the
tech notes is this about multithreaded operations.

00:59:53.309 --> 00:59:56.489
Well what about if I just want to play the movie back?

00:59:56.489 --> 01:00:01.889
Something that you may not know that we'll call it
explicitly here is that only QTMovies that are initialized

01:00:01.889 --> 01:00:06.920
on the main thread and remain attached to
the main thread are eligible for playback.

01:00:06.920 --> 01:00:11.950
So you would not perform any of these
thread migration if you wish just to play.

01:00:11.949 --> 01:00:19.099
>> Now this restriction that only QTMovies attached to the
main thread can play is not new, it's been true since day 1.

01:00:19.099 --> 01:00:25.289
And it's appropriate as well because the playback
of the QTMovie involves user presentation.

01:00:25.289 --> 01:00:30.739
And often occurs together with UI state changes.

01:00:30.739 --> 01:00:36.109
So it's appropriate for you to message the movie about
things you want to do, change its rate, for example,

01:00:36.110 --> 01:00:44.410
and for it to notify you of state changes on the main thread
where your code is going to interact with other UI elements.

01:00:44.409 --> 01:00:52.059
This restriction is true regardless of whether
QuickTime 7 or QuickTime X is used for playback.

01:00:52.059 --> 01:00:56.090
Now several times we've mentioned
multithreaded applications and components

01:00:56.090 --> 01:00:59.910
that are not thread-safe, we want to make this better.

01:00:59.909 --> 01:01:04.409
We want to make the experience of media
types that are supported by third parties

01:01:04.409 --> 01:01:07.440
as rich and safe as possible on Mac OS X.

01:01:07.440 --> 01:01:12.340
So let me go through some notes for component developers
for those of you out there who implement support

01:01:12.340 --> 01:01:17.420
for media formats on QuickTime X
that it doesn't support natively.

01:01:17.420 --> 01:01:24.200
You say I want to be part of the media system, and many
of you already know that QuickTime 7 has published APIs

01:01:24.199 --> 01:01:29.139
and has described component types that allow
you to add support for new types of media

01:01:29.139 --> 01:01:32.869
to the system, these come in various flavors.

01:01:32.869 --> 01:01:38.920
If you want to add support for new video types, you can
write an image decoder, an image encoder if you want

01:01:38.920 --> 01:01:41.700
to encode that video format on the system.

01:01:41.699 --> 01:01:46.919
Similarly for audio, there are encoding
components and decoding components you can provide.

01:01:46.920 --> 01:01:53.250
Also if you have a media container format
that you want to add support for to Mac OS X,

01:01:53.250 --> 01:01:55.840
you would write what's known as a movie import component.

01:01:55.840 --> 01:02:01.400
And the job of that movie import component, by the
way, to harken back to an earlier part of our talk,

01:02:01.400 --> 01:02:07.789
is to create a movie representation of the media
resource in that container format that you support.

01:02:07.789 --> 01:02:16.480
You can, beyond that, add additional support for new
container format by allowing applications to write media

01:02:16.480 --> 01:02:21.030
to that container format, in order to do that, you
would write what's known as a movie export component.

01:02:21.030 --> 01:02:27.930
But the question is, in our history, how
quickly, how immediately do we provide support

01:02:27.929 --> 01:02:30.569
for all of this extensibility to QuickTime 7?

01:02:30.570 --> 01:02:36.970
And the answer is, and this surprised actually someone a
long time member of the QuickTime team just the other day,

01:02:36.969 --> 01:02:43.159
only image encoders and decoders were actually
available to the public, to third party developers,

01:02:43.159 --> 01:02:49.089
when QuickTime 1.0 shipped in 1991, and the
reason for this is that extensibility is something

01:02:49.090 --> 01:02:51.579
that needs to be worked out in great detail.

01:02:51.579 --> 01:02:56.360
How do we support add-on modules, how do we make
them work well when they're added to the system.

01:02:56.360 --> 01:03:04.460
What do we want to do in the future now that we're
facing this same set of requirements for QuickTime X?

01:03:04.460 --> 01:03:07.570
We do want that system to be extensible.

01:03:07.570 --> 01:03:14.080
And further since 1991 the first time that we did this,
we've gained a tremendous amount of respect for the need

01:03:14.079 --> 01:03:17.909
of security when code modules are added to the system.

01:03:17.909 --> 01:03:21.909
But how do we do that for QuickTime
X and make that extensible?

01:03:21.909 --> 01:03:23.529
We're working on it.

01:03:23.530 --> 01:03:27.910
QuickTime X and Snow Leopard is
the start of this new media stack,

01:03:27.909 --> 01:03:31.730
this start of this new set of service
with greater efficiency.

01:03:31.730 --> 01:03:35.750
For Snow Leopard, we, we're not saying
anything now about plug-in modules,

01:03:35.750 --> 01:03:37.539
it's something to look forward to in the future.

01:03:37.539 --> 01:03:43.349
In the mean time, we are very interested in your feedback
for what kinds of things you want to do in QuickTime X.

01:03:43.349 --> 01:03:50.449
So for now, the extensibility API remains the QuickTime 7
API and the component types that we've mentioned earlier.

01:03:50.449 --> 01:03:56.599
But that's the way to extend the media system with new
types for Snow Leopard as well as for earlier releases

01:03:56.599 --> 01:04:00.409
of Mac OS X, let's make them as good as possible.

01:04:00.409 --> 01:04:04.460
Let's make them as thread-safe as they can possibly be.

01:04:04.460 --> 01:04:09.429
The thread-safety of these components is now going
to be exercised as never before on Snow Leopard

01:04:09.429 --> 01:04:13.859
as QTKit clients opt in to use openAsyncRequired.

01:04:13.860 --> 01:04:18.920
Because what's going on under the hood when
an application such as your says I want to--

01:04:18.920 --> 01:04:24.829
I want to require asynchronous loading for this
instance of QTMovie, is that QTKit when it's

01:04:24.829 --> 01:04:30.009
on the QuickTime 7 path is going to call
NewMovieFromProperties on a background thread

01:04:30.010 --> 01:04:36.400
which will require that all of the components
needed for that movie be marked as thread-safe.

01:04:37.489 --> 01:04:43.489
Therefore if you're supplying components for
QuickTime 7, media import components and so forth,

01:04:43.489 --> 01:04:46.649
their thread-safety is going to be
tested as never before in Snow Leopard.

01:04:46.650 --> 01:04:54.860
Now if you wish to make your components thread-safe, the
tech note that I mentioned earlier, 2125, it's kind of long,

01:04:54.860 --> 01:05:01.039
it's got a lot of information in it, also has tips for
QuickTime 7 component developers, some general information

01:05:01.039 --> 01:05:05.139
about how to make those add-on modules
thread-safe, how to mark them as such,

01:05:05.139 --> 01:05:09.239
and how to ensure that they are in fact safe.

01:05:09.239 --> 01:05:15.259
But there are particular guidelines for movie
import components that I want to highlight

01:05:15.260 --> 01:05:17.770
that are not called out in the tech note.

01:05:17.769 --> 01:05:23.119
Over the years and in fact recently since we've
implemented QTMovieOpenAsyncRequiredAttribute,

01:05:23.119 --> 01:05:26.989
we have found that third parties have
marked some components as thread-safe

01:05:26.989 --> 01:05:29.309
but are doing some things that are actually dangerous.

01:05:29.309 --> 01:05:34.099
A very strong recommendation, I can't make it more
strongly, is that if your component is operating

01:05:34.099 --> 01:05:38.329
on a background thread, please
do not display user interface.

01:05:38.329 --> 01:05:43.579
Some movie import components want to display
a loading progress or something like that.

01:05:43.579 --> 01:05:50.259
Any display of UI when attempted from a background
thread can crash and that's a poor user experience.

01:05:50.260 --> 01:05:51.470
So don't do that.

01:05:51.469 --> 01:05:58.089
When your movie import component is open, note the thread on
which it's running, if it's Cocoa-based you can use NSThread

01:05:58.090 --> 01:06:02.680
or you can use the pthreads package and call pthreadMain
to find out if you're running on the main thread,

01:06:02.679 --> 01:06:07.829
and if that's the case, it's safe
for you to display UI, otherwise no.

01:06:07.829 --> 01:06:15.349
Further if you're writing a movie import component, you are
responsible for ensuring that all of the components required

01:06:15.349 --> 01:06:19.380
for the movie that you're building, the
movie representation that we discuss earlier

01:06:19.380 --> 01:06:24.599
that the movie import component builds, all the
components, the media handlers, the video decoders,

01:06:24.599 --> 01:06:29.039
the audio decoders, they must be thread-safe also.

01:06:29.039 --> 01:06:36.509
If not, you must fail in a particular way in
order to signal the client to retry the operation

01:06:36.510 --> 01:06:41.310
without requiring operation on a background thread.

01:06:41.309 --> 01:06:46.400
Note that as you're doing a survey of the components that
are required for the media formats that are contained

01:06:46.400 --> 01:06:52.840
in the media resource that you're attempting to load,
that Sound Manager components are never thread-safe.

01:06:52.840 --> 01:07:00.470
So if the only decoder available for sound format is
a Sound Manager sdec component, it's not thread-safe.

01:07:00.469 --> 01:07:03.230
And you must fail if you're trying to
create this on the background thread.

01:07:03.230 --> 01:07:06.940
Instead in order to provide thread-safety
for audio decoding,

01:07:06.940 --> 01:07:12.369
you must provide a core audio compliant
audio decoder and that can be thread-safe.

01:07:12.369 --> 01:07:15.299
And in fact, the ones supplied by Apple all are.

01:07:15.300 --> 01:07:20.430
Now I mentioned earlier that you must fail in a
particular way to signal the client of what went wrong.

01:07:20.429 --> 01:07:27.079
What you want to do when trying to import a media
resource, return the result from say NewMovieFromDataRef,

01:07:27.079 --> 01:07:33.119
you want to set the error to the OS status to
componentNotThreadSafeError and this will signal

01:07:33.119 --> 01:07:37.869
that the whole thing ought to be retried
without reliance on the thread-safety

01:07:37.869 --> 01:07:40.289
which is not available for this media resource.

01:07:40.289 --> 01:07:44.719
OK. So that covers the enhancements to QTKit.

01:07:44.719 --> 01:07:49.709
It also covers some of the things that you can do in
your code to gain the benefit of these enhancements

01:07:49.710 --> 01:07:54.750
and even some things that third parties can do to
make experience of media even better on QuickTime X.

01:07:54.750 --> 01:07:59.059
Tim has some summary of all this for you, even now.

01:07:59.059 --> 01:07:59.559
[ Applause ]

01:07:59.559 --> 01:08:10.570
>> Well there really isn't much of a summary
If you want to opt in to QuickTime X path,

01:08:10.570 --> 01:08:14.990
use special initialization attributes
to request these new features.

01:08:14.989 --> 01:08:21.010
There are really just 2 of them, there's the
OpenForPlaybackAttribute and the OpenAsyncRequiredAttribute.

01:08:21.010 --> 01:08:25.079
Let me point you to some other sessions
that should be of interest to you,

01:08:25.079 --> 01:08:27.079
Kevin has already pointed to several of these.

01:08:27.079 --> 01:08:33.640
For Color Management, Friday morning in this room,
they will discuss color management in Snow Leopard.

01:08:33.640 --> 01:08:38.780
The HTTP Live Streaming will be tomorrow in the morning.

01:08:38.779 --> 01:08:43.559
And also the Sophisticated Media Playback through
Open Web Standards should be interesting to you

01:08:43.560 --> 01:08:46.180
and that will also be tomorrow in the afternoon.

01:08:46.180 --> 01:08:48.789
We will also be available in the Labs.

01:08:48.789 --> 01:08:53.800
The QTKit Lab will be this afternoon and
there should be a good number of QTKit

01:08:53.800 --> 01:08:57.350
and QuickTime engineers there who can answer your questions.

01:08:57.350 --> 01:09:00.780
And if you have particular questions
about HTTP Live Streaming,

01:09:00.779 --> 01:09:04.809
then that Lab will be Wednesday afternoon also at 3:30.

01:09:04.810 --> 01:09:05.860
So thanks for coming.

01:09:05.859 --> 01:09:11.099
If you have particular questions, you contact our
Evangelist, Allan Schaffer, and I certainly want you

01:09:11.100 --> 01:09:13.460
to look at the documentation and sample code.

01:09:13.460 --> 01:09:15.640
So thanks for coming and I hoped you enjoyed it.
WEBVTT

00:00:12.560 --> 00:00:16.310
>> [Chad] This is advanced debugging performance analysis.

00:00:17.809 --> 00:00:20.969
My name is Chad Woolf, I'm a Performance Tools Engineer.

00:00:20.969 --> 00:00:23.429
I work on DTrace and instruments.

00:00:23.429 --> 00:00:25.850
We've got a two-part session for you guys today.

00:00:25.850 --> 00:00:31.710
The first half we're going to be talking about performance
analysis using DTrace and a little bit about instruments.

00:00:31.710 --> 00:00:35.600
And then for the second half, Jim Ingham from
the debugger team is going to come up here

00:00:35.600 --> 00:00:39.210
and talk about some advanced debugging with Xcode and GDB.

00:00:39.210 --> 00:00:47.289
So for the first half we're going to talk about performance
analysis, and we're going to talk specifically about DTrace.

00:00:47.289 --> 00:00:51.519
DTrace is a tracing technology built into the OS X kernel.

00:00:51.520 --> 00:00:54.340
It'll allow you to trace anything from the
kernel all the way down to your application.

00:00:54.340 --> 00:00:55.940
We'll get into that.

00:00:55.939 --> 00:00:58.030
We're going to learn DTrace by example.

00:00:58.030 --> 00:01:00.660
So I'm going to show you a series of
examples, and hopefully by the end

00:01:00.659 --> 00:01:04.250
of these we'll have a pretty good working knowledge
of the language and what it can do for you.

00:01:04.250 --> 00:01:09.109
Then we're going to take a walk over here to one of our
demo machines, and we're going to demo the technology live.

00:01:09.109 --> 00:01:15.840
So if you guys have a laptop and you want to follow along
all you need to do is be logged in as an administrative user

00:01:15.840 --> 00:01:20.070
and have a terminal ready, and when we get to the demos you
can hopefully follow along, play with it as we play with it.

00:01:20.069 --> 00:01:25.579
And then finally when we come back from the demos
we're going to talk about how you can use DTrace

00:01:25.579 --> 00:01:28.689
to extend the power of instruments like
creating your own instruments using DTrace.

00:01:28.689 --> 00:01:32.750
So let's start with an example here.

00:01:32.750 --> 00:01:38.590
So your an app developer and then some, one of your
customers or someone in the office comes to you says,

00:01:38.590 --> 00:01:43.150
Your app's working a little slower than usual,
so I'm getting some sluggishness here, and,

00:01:43.150 --> 00:01:44.940
and can you come over to my desk and take a look?

00:01:44.939 --> 00:01:46.090
So you do.

00:01:46.090 --> 00:01:46.490
You go over.

00:01:46.489 --> 00:01:48.959
You confirm, Yes, it's definitely sluggish.

00:01:48.959 --> 00:01:53.569
So you call up Instruments, you attach the
running process, and you take a time profile.

00:01:53.569 --> 00:02:00.659
And what you see is that 75% of your time is now being
consumed by a function that you're calling called blackBox.

00:02:00.659 --> 00:02:03.539
Right? Now of course there's no
function called blackBox, I made it up.

00:02:03.540 --> 00:02:08.840
But the point is that eventually when you guys are doing
your performance analysis, you're probably going to hit a,

00:02:08.840 --> 00:02:14.210
a point in your, in your debugging process that
you're going to find that you hit a function

00:02:14.210 --> 00:02:19.320
and you've optimized all your code around it, and you
really don't know what this thing is doing, right?

00:02:19.319 --> 00:02:22.769
And from, for our example here, 75% is high.

00:02:22.770 --> 00:02:24.909
This thing has never taken that amount of time before.

00:02:24.909 --> 00:02:28.659
So before we write a bug against blackBox
let's, let's go off and see if we can figure

00:02:28.659 --> 00:02:30.759
out a little bit more information about it.

00:02:30.759 --> 00:02:34.759
Now typically what you might want to do is find your code

00:02:34.759 --> 00:02:39.719
where you're calling blackBox, and
then insert some logging around it.

00:02:39.719 --> 00:02:43.009
So here you can see we're going to take
the value of the key being passed in,

00:02:43.009 --> 00:02:45.489
and we're going to record the return value from blackBox.

00:02:45.490 --> 00:02:48.610
Right? And then maybe inside your
start you can record the time stamp,

00:02:48.610 --> 00:02:52.460
and on your end you can record a time stamp
and see how long the calls are taking.

00:02:52.460 --> 00:02:56.590
You would send it maybe out to a file, or
standard out, or maybe put it in shared memory.

00:02:56.590 --> 00:03:01.180
Right? All these different types of things are
things that we, we do when we're doing tracing.

00:03:01.180 --> 00:03:03.629
And that's really what this is.

00:03:03.629 --> 00:03:07.289
Now the problem with our scenario
is that the app is running,

00:03:07.289 --> 00:03:10.389
and the user doesn't know how to reproduce this problem.

00:03:10.389 --> 00:03:12.989
Right? It just all of a sudden it started doing this.

00:03:12.990 --> 00:03:14.680
So we can't take the app down.

00:03:14.680 --> 00:03:16.319
We can't do this type of insertion.

00:03:16.319 --> 00:03:22.680
What we'd love to be able to do though is insert code, you
know dynamically, as this things running without having

00:03:22.680 --> 00:03:24.939
to take it down, or at least get that same affect.

00:03:24.939 --> 00:03:29.430
And the way we do that is with DTrace.

00:03:29.430 --> 00:03:34.860
So you can think about DTrace as a hardware
logic analyzer, except for software.

00:03:34.860 --> 00:03:40.200
So when we're trying to debug a circuit board or
something like that, we, you know, we don't take a new run

00:03:40.199 --> 00:03:43.739
at the circuit board and add circuits
to it to try to record what's going on.

00:03:43.740 --> 00:03:45.070
Instead we use a logic analyzer.

00:03:45.069 --> 00:03:51.120
And so if you've seen this picture here on the
right you'll see that there's a probe being placed

00:03:51.120 --> 00:03:52.789
against the metal pins of the circuit board.

00:03:52.789 --> 00:03:58.969
And when those pins fire, a signal goes up that probe into a
logic analyzer, and then after the run an engineer can look

00:03:58.969 --> 00:04:01.000
through the trace and figure out what happened.

00:04:01.000 --> 00:04:05.750
Right? So with DTrace we can actually
do the same thing with code.

00:04:05.750 --> 00:04:14.349
You can place a probe on a piece of code, and then you don't
have to worry about writing your custom logging into it.

00:04:14.349 --> 00:04:17.019
So how does this work?

00:04:17.019 --> 00:04:26.699
Basically, DTrace can find any instruction in your
application as long as it has a symbol table or a dSYM file.

00:04:26.699 --> 00:04:29.029
So once you have those two pieces
of information, DTrace sees--

00:04:29.029 --> 00:04:33.699
as you can see here we don't have the code for
black box, but because we have the symbol table

00:04:33.699 --> 00:04:38.240
in dSYM we can find the entry point and then the exit point.

00:04:38.240 --> 00:04:43.699
Now you can put a probe on any arbitrary
instruction, in case you want to open up the blackBox

00:04:43.699 --> 00:04:50.019
and you know what you're looking for, just like giving
DTrace an offset from the beginning of the function.

00:04:50.019 --> 00:04:52.379
So let's talk about DTrace scripts for a minute.

00:04:52.379 --> 00:04:58.659
Because basically what happens when a probe fires is that
it runs a DTrace script or a set of action statements.

00:04:58.660 --> 00:05:02.170
So in general, DTrace scripts are composed of probe clauses.

00:05:02.170 --> 00:05:07.060
A probe clause has a probe descriptor,
that's the actual description of how

00:05:07.060 --> 00:05:10.860
to find the probe that you are interested in.

00:05:10.860 --> 00:05:14.800
A predicate, which will actually limit
the firing of the action statements

00:05:14.800 --> 00:05:17.030
to a set of conditions when they become true.

00:05:17.029 --> 00:05:19.339
And then the action statements.

00:05:19.339 --> 00:05:24.019
Now inside our action statements we can do a
couple of the things that we would normally do.

00:05:24.019 --> 00:05:30.409
Like I was giving you the example of blackBox, we can
say print out to the console, we can record a user stack.

00:05:30.410 --> 00:05:35.950
And we can do a little bit more along
the lines of statistical analysis

00:05:35.949 --> 00:05:39.670
by using these thread safe accumulators, called aggregates.

00:05:39.670 --> 00:05:44.009
So if you want to keep track of how many times something
happens, or how often it happens, or how long it took,

00:05:44.009 --> 00:05:47.329
you can keep them in these thread safe accumulators.

00:05:47.329 --> 00:05:52.009
And we have associative arrays, as
long as, as well as normal variables,

00:05:52.009 --> 00:05:55.699
associative arrays are like a dictionary,
you can imagine Cocoa.

00:05:55.699 --> 00:06:02.509
So here's an example of blackBox placed
with probes and action statements.

00:06:02.509 --> 00:06:07.789
And then we're going to go over that script
and explain to you roughly what it's doing.

00:06:07.790 --> 00:06:11.000
But before we do that I want to
mention that when you place a probe

00:06:11.000 --> 00:06:13.980
in an application it's very similar
to sending a break point.

00:06:13.980 --> 00:06:20.210
A, when your, when your apps, threading application
hits a break point it suspends that thread.

00:06:20.209 --> 00:06:25.180
And then it transfers control over to the
DTrace interpreter running in the kernel.

00:06:25.180 --> 00:06:29.569
And DTrace will then run all of the
action statements that are associated

00:06:29.569 --> 00:06:32.430
with that address, and that resumes your thread.

00:06:32.430 --> 00:06:36.780
OK? And now since this works very similar to the way
that debuggers work, they're actually not compatible.

00:06:36.779 --> 00:06:42.259
If you have DTrace and you're using it on an
application, you can't attach the debugger and vice versa.

00:06:42.259 --> 00:06:46.789
So let's go over the probe descriptor
a little bit in detail.

00:06:46.790 --> 00:06:50.850
It's a, it's basically a string that's separated by colons.

00:06:50.850 --> 00:06:52.100
It's built into 4 pieces.

00:06:52.100 --> 00:06:53.520
The first part is a provider.

00:06:53.519 --> 00:06:59.209
And probe descriptors describe the, the probe itself.

00:06:59.209 --> 00:07:05.089
And the module function and name that follow the provider
name are really determined by the provider itself.

00:07:05.089 --> 00:07:11.139
So a system call provider will have a different
module function and name semantic then, let's say,

00:07:11.139 --> 00:07:13.539
the pid provider, which is used to look at your application.

00:07:13.540 --> 00:07:15.870
We'll go over those in a, in a, in a minute here.

00:07:15.870 --> 00:07:19.930
You can actually use wild cards
here or you can completely omit it.

00:07:19.930 --> 00:07:23.959
And that will give you basically everything that matches.

00:07:23.959 --> 00:07:26.539
This is the only required part of a probe.

00:07:26.540 --> 00:07:32.629
If you want to just simply record trace, the
default action is to log it out to the console.

00:07:32.629 --> 00:07:37.040
And you can get a list of the probes
if you execute the DTrace -l command.

00:07:37.040 --> 00:07:39.530
That'll give you the list of every
probe that's registered in the system.

00:07:39.529 --> 00:07:44.089
And let's, it's just going to be the system wide probes.

00:07:44.089 --> 00:07:49.599
And if you want to just limit it to a specific
provider you can say DTrace -l and give a -n command,

00:07:49.600 --> 00:07:51.890
that'll actually type a script at the command line.

00:07:51.889 --> 00:07:57.079
And with the -l it'll just simply enumerate all
the probes that follow that specific pattern.

00:07:57.079 --> 00:08:00.389
Let's go over a couple of examples before we continue.

00:08:00.389 --> 00:08:02.389
This is an example of a syscall provider.

00:08:02.389 --> 00:08:11.149
And what it's going to do here is place a probe on the entry
and exit point of every system call in the Darwin layer,

00:08:11.149 --> 00:08:15.750
the, the, sorry, the BSD portion of the Darwin kernel.

00:08:15.750 --> 00:08:21.980
The next one is a, it's the pid provider.

00:08:21.980 --> 00:08:24.069
And specially its pid1017.

00:08:24.069 --> 00:08:30.659
And it's going to look at the return from the printf
in libSystem and that's going to place a probe on that.

00:08:30.660 --> 00:08:34.230
So every time you return from printf, it's
going to execute that action statement.

00:08:34.230 --> 00:08:40.670
And then next one, we also have an Objective-C provider,
which in that same pid we're going to instrument all

00:08:40.669 --> 00:08:44.939
of the draw methods, you can see the wild card there,

00:08:44.940 --> 00:08:48.030
and we've left the library blank,
which ends up being the class name.

00:08:48.029 --> 00:08:53.039
So it's all classes, all draw methods on
the entry point, that probe would fire.

00:08:53.039 --> 00:08:56.219
All right, so let's talk about providers here for a second.

00:08:56.220 --> 00:08:59.529
There's a bunch of them here, and
I've listed them on the slide.

00:08:59.529 --> 00:09:01.500
Let me cover a few.

00:09:01.500 --> 00:09:08.669
Syscall is the BSD system calls, and you have mach_trap,
which is going to be the mach family of system calls.

00:09:08.669 --> 00:09:10.409
You have an fbt provider.

00:09:10.409 --> 00:09:18.289
Inside the kernel you can trace all of the exposed symbols
in the kernel through the fbt, the function boundary trace.

00:09:18.289 --> 00:09:24.459
You have a proc provider, so any time that the
kernel creates a process, or destroys a process,

00:09:24.460 --> 00:09:27.509
or creates a thread you, you'll have
probes that will fire for those.

00:09:27.509 --> 00:09:32.549
We have statistics for locking, virtual memory, and I/O.

00:09:32.549 --> 00:09:36.759
Now when you go and look at this slide, maybe afterward,
you'll see that the second column here is the name

00:09:36.759 --> 00:09:41.960
in the instrument builder, and we'll talk
a little bit about that when we get to it.

00:09:41.960 --> 00:09:45.440
Now along with this, this static providers,
we, these providers have the names

00:09:45.440 --> 00:09:47.560
like syscall, we have these meta providers.

00:09:47.559 --> 00:09:53.709
And the meta providers are not create-- well the
probes aren't created until you specify them.

00:09:53.710 --> 00:09:58.430
So when I say pid and then followed
immediately by the process id,

00:09:58.429 --> 00:10:01.759
that actually creates the provider and creates the probes.

00:10:01.759 --> 00:10:06.519
There's the pid in Objective-C, which ones we saw,
and then there's the profile and pid providers,

00:10:06.519 --> 00:10:11.449
which can be used to place action
statements that fire periodically.

00:10:11.450 --> 00:10:12.640
So you can see some examples.

00:10:12.639 --> 00:10:18.279
So for example if you wanted to say, I want to fire a
probe or an action statement every hundred milliseconds,

00:10:18.279 --> 00:10:22.819
you can say tick -100ms as your provider name.

00:10:22.820 --> 00:10:26.950
And then you can associate an action script with that.

00:10:26.950 --> 00:10:29.860
So let's take a look at exploring our blackBox function.

00:10:29.860 --> 00:10:33.350
Let's get back into our example, see what we can do with it.

00:10:33.350 --> 00:10:37.950
So I'm going to say my process id number is 123.

00:10:37.950 --> 00:10:41.759
So I'm going to say pid123 inside
the black, blackBox, the entry point.

00:10:41.759 --> 00:10:42.909
So I'm placing a probe there.

00:10:42.909 --> 00:10:44.889
And my default action is simply to record everything.

00:10:44.889 --> 00:10:50.819
Let's start there and see if blackBox is even still being
called now that we've been sitting here talking for a while.

00:10:50.820 --> 00:10:55.060
So I'd go to DTrace, I'd go to the, the console;

00:10:55.059 --> 00:10:59.759
I type in DTrace -s with my script name,
which is myscript.d. And I'd run it.

00:10:59.759 --> 00:11:02.909
And then I get all these traces out to the console.

00:11:02.909 --> 00:11:06.059
So clearly blackBox is still running.

00:11:06.059 --> 00:11:10.729
But when I hit control-c to stop
the trace, I get this message.

00:11:10.730 --> 00:11:15.810
DTrace has dropped 53,686 events on CPU 3.

00:11:15.809 --> 00:11:20.019
So what DTrace is here is telling us
is that blackBox is being called a lot.

00:11:20.019 --> 00:11:23.039
And logging this out to the console is taking a long time.

00:11:23.039 --> 00:11:27.889
And in order to catch up DTrace had to
actually drop 53,000 plus of these events.

00:11:27.889 --> 00:11:34.120
Now this can happen, because the kernel is not going
to simply wait for a user safe process to catch up.

00:11:34.120 --> 00:11:37.360
It, it goes about its thing and won't
lock up the system or anything like that.

00:11:37.360 --> 00:11:43.279
So you can try using these probes
blank just to see what's going on.

00:11:43.279 --> 00:11:45.799
But obviously that's way too much data.

00:11:45.799 --> 00:11:51.279
So let's look at the statistical analysis things
that I was telling you about in the beginning.

00:11:51.279 --> 00:11:53.209
So let's try this script.

00:11:53.210 --> 00:11:55.170
Now when you see an "at" sign in front of a variable,

00:11:55.169 --> 00:11:58.019
this is going to be a global variable
called hits, it's called an aggregate.

00:11:58.019 --> 00:12:01.240
An aggregate's that thread safe
accumulator I was telling you about.

00:12:01.240 --> 00:12:03.560
So if, if blackBox is being called for multiple threads,

00:12:03.559 --> 00:12:07.079
or for multiple processes even,
and it won't confuse the hit count.

00:12:07.080 --> 00:12:10.150
What we are doing is, we're simply be recording the count.

00:12:10.149 --> 00:12:14.149
Now since we're not doing anything else with this aggregate,
whenever I stop the script it'll print out the results.

00:12:14.149 --> 00:12:17.110
So you'll, you'll see the number
of hits being accumulated here.

00:12:17.110 --> 00:12:18.779
So let's take a look.

00:12:18.779 --> 00:12:21.970
Again, I'll run the script, and we'll wait here.

00:12:21.970 --> 00:12:23.720
And we'll hit Control-c.

00:12:23.720 --> 00:12:27.850
And then out comes a number, 580,209 times.

00:12:27.850 --> 00:12:28.570
Oh, my God!

00:12:28.570 --> 00:12:30.220
Right? That's a lot of times.

00:12:30.220 --> 00:12:33.649
So blackBox is being called a lot more than I, I expected.

00:12:33.649 --> 00:12:38.379
A lot more than, than it's ever been
called, and that's probably why it's 75%.

00:12:38.379 --> 00:12:40.080
But let's find out a little bit more.

00:12:40.080 --> 00:12:45.210
So I'm going to use another aggregate,
I'm going to call it keys.

00:12:45.210 --> 00:12:50.710
And that's going to be arg0, which is the
first argument of the blackBox function.

00:12:50.710 --> 00:12:56.110
Every probe has these implied variables
being passed in, arg0 through whatever.

00:12:56.110 --> 00:13:00.669
And they will, they represent in the pid
provider then arguments are being passed

00:13:00.669 --> 00:13:02.469
into the function on the entry probe.

00:13:02.470 --> 00:13:09.279
OK? So now what we're doing is we're using the quantize
function here on, on this aggregate, which is actually going

00:13:09.279 --> 00:13:13.439
to create a histogram for us of
all the incoming values of key.

00:13:13.440 --> 00:13:16.720
So let's take another look at it, we'll run our script.

00:13:16.720 --> 00:13:18.580
We'll take a look.

00:13:18.580 --> 00:13:20.800
Control-c, and there's our counts.

00:13:20.799 --> 00:13:23.159
This time was 466,000 counts.

00:13:23.159 --> 00:13:26.059
And here's the distribution of the value of key.

00:13:26.059 --> 00:13:29.049
Right? So keys and addresses of void *.

00:13:29.049 --> 00:13:34.449
And we see that there's now some, some distribution
around that really large number on the bottom.

00:13:34.450 --> 00:13:39.830
But there's also a huge distribution around zero, so
apparently I'm passing in a lot of null values here,

00:13:39.830 --> 00:13:45.350
about 380,000 of the time out of 466,000
hits total I was passing in a null.

00:13:45.350 --> 00:13:47.120
So that might not be good.

00:13:47.120 --> 00:13:52.639
So let's see if we can find out a little bit more.

00:13:52.639 --> 00:13:59.100
We want to see now, maybe passing
in the value's OK, maybe it's not.

00:13:59.100 --> 00:14:05.279
Let's take a look at if black box is failing or succeeding,
and we want to see the ref, the ref relationship there.

00:14:05.279 --> 00:14:09.429
So what we can do is we can place an exit probe.

00:14:09.429 --> 00:14:12.519
And it's a single probe that will catch both exit points.

00:14:12.519 --> 00:14:16.220
And you can tell the difference between the exit
points, because it's being passed in at arg0.

00:14:16.220 --> 00:14:21.000
So the offset from the beginning of the function, the way
the return statement is, it'll actually pass in an arg0.

00:14:21.000 --> 00:14:25.909
It's one of the most common mistakes here
with return providers-- return probes.

00:14:25.909 --> 00:14:30.789
Arg1 is actually the return value,
so that's the one we're going to use.

00:14:30.789 --> 00:14:34.709
And I'm going to create another global
aggregate called argC for return code.

00:14:34.710 --> 00:14:38.030
And we're going to key it by the
return value of the function.

00:14:38.029 --> 00:14:43.509
So if it returns by zero versus negative 1,
we're going to see the difference immediately.

00:14:43.509 --> 00:14:46.149
And it's going to separate the, the counts out for us.

00:14:46.149 --> 00:14:49.230
Let's just run that here.

00:14:49.230 --> 00:14:52.899
Same thing, run a script, Control-c,, get our results.

00:14:52.899 --> 00:14:59.929
And you see at the bottom there we have zero hit,
returns zero 85,000 times, 86,000 times almost.

00:14:59.929 --> 00:15:03.519
And it returned negative 1 380,000 times.

00:15:03.519 --> 00:15:05.169
Let me blow that up for you.

00:15:05.169 --> 00:15:10.569
That's the exact same number of times that we've
actually are passing in zero as returning negative 1.

00:15:10.570 --> 00:15:15.030
So there's a high chance here that what
we're doing is we're passing in a bad value.

00:15:15.029 --> 00:15:17.769
Doesn't look like zero's a bad-- a valid value for this.

00:15:17.769 --> 00:15:22.629
Maybe it's our sentinel value, or whatever,
but we're clearly doing something wrong here.

00:15:22.629 --> 00:15:28.889
So let's take a look now at if passing
in a bad value is taking too long.

00:15:28.889 --> 00:15:32.860
Maybe that's slow, maybe that's OK, maybe
there's a fast check that you can do

00:15:32.860 --> 00:15:34.889
and that it's-- you don't have to call it at all.

00:15:34.889 --> 00:15:35.750
Maybe it does it itself.

00:15:35.750 --> 00:15:36.230
I don't know.

00:15:36.230 --> 00:15:38.409
We're going to find out.

00:15:38.409 --> 00:15:44.529
Now to do this, what we need to do is keep track of
the time we come into a function and the time we leave.

00:15:44.529 --> 00:15:46.079
So we're going to use a global variable.

00:15:46.080 --> 00:15:48.560
But there's a couple of caveats here.

00:15:48.559 --> 00:15:53.839
And that is if, if our app is multithreaded, you know,
these globals are going to become very confusing.

00:15:53.840 --> 00:15:57.360
So in DTrace what you can do is
you can scope these variables.

00:15:57.360 --> 00:16:02.860
If you have a prefix of self on there, what does
that is we'll create a thread scoped variable,

00:16:02.860 --> 00:16:12.120
so that you can write, so it, basically DTrace keeps track
of the value for each thread, basically is what's going on.

00:16:12.120 --> 00:16:17.320
And also there's a prefix that you can add, called this,
which is essentially how you create a local variable.

00:16:17.320 --> 00:16:18.520
So we don't have to worry about that at all.

00:16:18.519 --> 00:16:20.879
So let's see how we would use these in our code.

00:16:20.879 --> 00:16:27.129
So I'm going to create a self-variable here, which is
a local-- a thread scoped variable for the entry time.

00:16:27.129 --> 00:16:30.049
And I'm going to save off the time
stamp when we enter blackBox.

00:16:30.049 --> 00:16:35.419
And on the return I'm going to calculate the duration of
a local variable, which is the time stamp at the point

00:16:35.419 --> 00:16:39.019
of return versus the time stamp we recorded.

00:16:39.019 --> 00:16:42.949
And then we're going to use an aggregate,
and I'm going to store the duration.

00:16:42.950 --> 00:16:47.970
I'm going to store a histogram of the duration
that we computed for every return code.

00:16:47.970 --> 00:16:51.350
So let's take a look and see if calling-- getting a return

00:16:51.350 --> 00:16:54.850
of negative 1 is actually slower
than getting a return of zero.

00:16:54.850 --> 00:16:57.840
So we'll run our script.

00:16:57.840 --> 00:16:59.019
Control-c.

00:16:59.019 --> 00:17:01.169
All right, and here's the distribution that we got.

00:17:01.169 --> 00:17:07.159
We see that negative 1, which is our return
value, is centered roughly around 43,000.

00:17:07.160 --> 00:17:12.430
Now the time stamp's measured in nanoseconds, so
that's 43 microseconds is the central tendency

00:17:12.430 --> 00:17:14.460
for when we get a negative 1 return code.

00:17:14.460 --> 00:17:18.670
And if we compare that to the lower line here,
we get a zero, which is a successful return.

00:17:18.670 --> 00:17:20.789
It's roughly about 21 microseconds.

00:17:20.789 --> 00:17:25.269
So it takes significantly longer to fail than
it does to succeed with this blackBox function.

00:17:25.269 --> 00:17:30.089
So what did we learn about this?

00:17:30.089 --> 00:17:32.169
Well blackBox is being called a lot.

00:17:32.170 --> 00:17:36.460
It, it's being called actually too much for us
to trace, but if we wanted to trace it we could.

00:17:36.460 --> 00:17:38.250
It's being called with mostly zeros as an input.

00:17:38.250 --> 00:17:40.779
We found that out from the distributions in quantize.

00:17:40.779 --> 00:17:43.649
And we found out that zero was probably causing it to fail.

00:17:43.650 --> 00:17:46.970
And we also found out that failing
is actually slower than succeeding.

00:17:46.970 --> 00:17:51.579
So a potential fix for this would be to find
out, well first why we're calling it so much,

00:17:51.579 --> 00:17:55.929
but then maybe to check simply before we
go to call this function, if it's zero,

00:17:55.930 --> 00:17:59.580
just don't call it and save ourselves a lot of time.

00:17:59.579 --> 00:18:03.740
So all right, so let me move over here to the
demo machine and we're going to talk about,

00:18:03.740 --> 00:18:07.259
we're going to talk about-- take a look at a running system.

00:18:07.259 --> 00:18:09.629
So you're going to need a root show to access DTrace.

00:18:09.630 --> 00:18:13.960
And the best way to get that is sudo-F,
and then type in your admin password.

00:18:13.960 --> 00:18:19.110
So now that first command I showed you was DTrace -l.

00:18:19.109 --> 00:18:24.329
I'm going to pipe that some more and show you
all the probes that are right in the system now.

00:18:24.329 --> 00:18:29.419
So you'll see here we have a few of the
standard probes under DTrace, begin and end.

00:18:29.420 --> 00:18:34.060
So if you want a set of actions when the script starts,
or when it ends, or when it gets an error you can do that.

00:18:34.059 --> 00:18:36.119
Lock Stack is, is one of the providers here.

00:18:36.119 --> 00:18:38.599
Profile, there's you fbt provider.

00:18:38.599 --> 00:18:46.039
You can see a BP search record entry, for example,
is one, is an interesting probe in the kernel.

00:18:46.039 --> 00:18:48.940
Now let's show you how to limit
that down a little bit further.

00:18:48.940 --> 00:18:51.769
So we'll say DTrace -l and I'm going to give it a -n.

00:18:51.769 --> 00:18:54.730
And then I'm going to say syscall.

00:18:54.730 --> 00:19:00.390
We'll look at all of the entry
probes in the syscall provider.

00:19:00.390 --> 00:19:06.970
And so here you see we have syscall itself,
exit, forward, read, write, open, close.

00:19:06.970 --> 00:19:10.670
We have number 8 at the syscall
that's actually not implemented.

00:19:10.670 --> 00:19:14.180
But you can actually take a look at
the, the value of 8, or whatever.

00:19:14.180 --> 00:19:15.460
And that's this one here.

00:19:15.460 --> 00:19:16.610
So if you see those don't worry about it.

00:19:16.609 --> 00:19:18.809
That's not a glitch, that's actually
an unimplemented system call.

00:19:18.809 --> 00:19:25.669
All right, now let's take a look at all of the
system calls going on in our system right now.

00:19:25.670 --> 00:19:35.210
Now the way we do that is DTrace, let me clear the screen
here for me, is DTrace -n, and then put a single quote.

00:19:35.210 --> 00:19:38.569
I'm going to look at syscall.

00:19:38.569 --> 00:19:40.089
And we're going to check all of them out.

00:19:40.089 --> 00:19:42.559
We're going to look at just the
entry-- just the entry probes.

00:19:42.559 --> 00:19:45.159
Let's take a look at that.

00:19:45.160 --> 00:19:49.029
So as you see now we're looking at the whole,
the running system, all these things are firing,

00:19:49.029 --> 00:19:51.559
they're printing out information in the console.

00:19:51.559 --> 00:19:55.519
It's interesting, but you really
can't do a heck of a lot with it.

00:19:55.519 --> 00:20:02.139
So let's take a look at every system call going on,
and we'll see-- and we'll break it down by process.

00:20:02.140 --> 00:20:07.180
So let's create a script here, and we'll
say; we'll use an aggregate called hits.

00:20:07.180 --> 00:20:12.170
And it'll be an associative array that will
be keyed by the executable name of the process

00:20:12.170 --> 00:20:14.490
that is actually tripped that system call.

00:20:14.490 --> 00:20:16.009
And we're going to count them.

00:20:16.009 --> 00:20:22.490
[ silence ]

00:20:22.490 --> 00:20:26.900
>> So we matched 430 probes, 430
system calls 0being instrumented here.

00:20:26.900 --> 00:20:29.590
Hit Control-c, and there's our list.

00:20:29.589 --> 00:20:35.319
So MD workers 2 terminal
10, window server about 27.

00:20:35.319 --> 00:20:39.200
So now let's see if the predicates will
limit this to just the windows server.

00:20:39.200 --> 00:20:45.289
So after my entry and before my, my curly brackets
here for the script I'm going to do a forward slash,

00:20:45.289 --> 00:20:51.500
I'm going to say only when the exact
name is equal to Windows server.

00:20:51.500 --> 00:20:53.769
That's interesting, hold on.

00:20:53.769 --> 00:21:03.400
See if I can get this wider here so the; there we go.

00:21:03.400 --> 00:21:06.660
And then we're going to end that with a forward slash.

00:21:06.660 --> 00:21:14.460
And then instead of tracking the number of-- the executable,
we're going to track the actual function that's being fired.

00:21:14.460 --> 00:21:16.160
So that's in a variable called probe funk.

00:21:16.160 --> 00:21:22.630
All right, let's count those up in the Windows server.

00:21:22.630 --> 00:21:25.110
We've got a little activity here.

00:21:25.109 --> 00:21:30.669
All right, so we see map, mmap, m on map,
madvise, alt stack, and sig proc mask.

00:21:30.670 --> 00:21:33.910
And we'll see those, rough number of
times each one of those is being called.

00:21:33.910 --> 00:21:37.220
All right, now let's take a look at sig proc mask.

00:21:37.220 --> 00:21:43.440
So what I'm going to do is I'm actually going
to use that name inside the probe descriptor,

00:21:43.440 --> 00:21:49.460
so I'm going to go right before entry
here and say sig proc mask, as my,

00:21:49.460 --> 00:21:53.220
as my probe specification, still inside the windows server.

00:21:53.220 --> 00:22:03.730
But when sig proc mask gets fired, what I want to do is I
want to record the user stack, see where it's coming from.

00:22:03.730 --> 00:22:08.279
So I'll use ustack, with two parenthesis
for function in DTrace.

00:22:08.279 --> 00:22:10.519
Take a look.

00:22:10.519 --> 00:22:16.500
And there the user stacks, every
time sig proc mask is being called.

00:22:16.500 --> 00:22:20.950
Now that's interesting, but again, it's
going to be a lot of data to go through.

00:22:20.950 --> 00:22:25.620
But what, what will be really interesting
to find out is, Are there 2, or 3, or 4,

00:22:25.619 --> 00:22:29.439
or 5 unique call stacks that sig
proc mask is being called from?

00:22:29.440 --> 00:22:34.559
So are there separate points on the code where it's
being called, or is it only being called from one spot?

00:22:34.559 --> 00:22:40.619
Well, if we go and create another aggregate
here we can create a, another hit counter here.

00:22:40.619 --> 00:22:44.000
And in the associative array we're going
to use the call stack as the unique key.

00:22:44.000 --> 00:22:47.009
And we're going to say, Please count those up for me.

00:22:47.009 --> 00:22:51.569
[ silence ]

00:22:51.569 --> 00:22:54.740
>> So let's do a little activity here on the windows server.

00:22:54.740 --> 00:22:57.370
Wait. Control-c.

00:22:57.369 --> 00:22:59.139
All right here's our results.

00:22:59.140 --> 00:23:07.610
So it looks like here's a unique stack for sig
proc mask, and see here, down here is a count of 2.

00:23:07.609 --> 00:23:12.449
Looks like a post data port is calling it 167 times.

00:23:12.450 --> 00:23:15.340
And we have some driver calls here that are calling it.

00:23:15.339 --> 00:23:20.379
So we can actually find out quite a bit of information
just by playing around a little bit from the command line.

00:23:20.380 --> 00:23:23.400
And hopefully that will get you guys
started, if you guys are following along,

00:23:23.400 --> 00:23:27.360
or if you want to follow along later,
and just kind of explore DTrace.

00:23:27.359 --> 00:23:28.659
It's a very safe language.

00:23:28.660 --> 00:23:33.009
It will not disrupt the kernel or
crash the-- or panic the kernel.

00:23:33.009 --> 00:23:35.009
All right, so let's, let's move on.

00:23:35.009 --> 00:23:37.879
Cause I want to talk about instruments.

00:23:37.880 --> 00:23:42.220
And I mentioned that originally that you could
extend the power of instruments with DTrace.

00:23:42.220 --> 00:23:46.860
As it turns out about half of the instruments today
actually use DTrace in order to get their data.

00:23:46.859 --> 00:23:50.479
So DTrace is a powerful and very pervasive tracing system.

00:23:50.480 --> 00:23:55.610
It's everywhere in the kernel, and you can use it
to get a lot of information about your processes.

00:23:55.609 --> 00:23:59.250
Let's, so if you take a look at the file
activity monitor, you simply drag it out

00:23:59.250 --> 00:24:01.240
and then double click it, you get
this panel that comes down.

00:24:01.240 --> 00:24:04.349
And it's the DTrace instrument builder window.

00:24:04.349 --> 00:24:08.559
Also if you go to the instrument pull down
you can create a new instrument of your own.

00:24:08.559 --> 00:24:12.470
And you'll see, you'll see what's going
on here now that we described DTrace.

00:24:12.470 --> 00:24:18.539
First off the type here, syscall, the system
call, and when it hits the entry point of open,

00:24:18.539 --> 00:24:21.129
we're actually going to see that action script.

00:24:21.130 --> 00:24:23.880
Now we were using aggregates a
lot in our, in our demonstration,

00:24:23.880 --> 00:24:28.760
but aggregates don't really work well
with the workflow of instruments.

00:24:28.759 --> 00:24:32.670
Right? Aggregates are something that you
total up and, and then print out at the end.

00:24:32.670 --> 00:24:35.490
Where instruments actually create the time
line of what's going on in your system.

00:24:35.490 --> 00:24:40.500
So what you can do instead of using aggregates
is to use DTrace to aggregate the data--

00:24:40.500 --> 00:24:43.170
I'm sorry, use instruments to aggregative the data for you.

00:24:43.170 --> 00:24:46.980
And then that way you get all the neat features
you that you would expect in instruments.

00:24:46.980 --> 00:24:51.430
So the way you do that is on this bottom section
of the panel, you can add a recoding action.

00:24:51.430 --> 00:24:57.210
So every time this probe fires, aside from
executing your script, it'll record, in this example,

00:24:57.210 --> 00:25:01.450
this is the example for open on the
return probe of the open system call.

00:25:01.450 --> 00:25:07.350
It's going to record executable, the function, the path
that was being passed in, and the return value, the FD,

00:25:07.349 --> 00:25:10.799
the file descriptor, that all gets sent to instruments.

00:25:10.799 --> 00:25:16.869
If you want to record a user stack you have an option on
the bottom where you can set, you can set the user stack

00:25:16.869 --> 00:25:21.909
to be recorded on every probe firing
that gets sent data to instruments.

00:25:21.910 --> 00:25:25.060
Now if you make a mistake in your script,
instruments will tell you about it.

00:25:25.059 --> 00:25:29.490
The one in red will be the one with the error, and there'll
be some diagnostic text for you to fix the problem.

00:25:29.490 --> 00:25:33.460
And once you fix it you get basically what you would expect.

00:25:33.460 --> 00:25:39.090
The instrument will record all of the data
that's being passed in from the probe firings.

00:25:39.089 --> 00:25:43.359
Your sorting works, your searching works,
all of your data mining stuff just works.

00:25:43.359 --> 00:25:50.659
If you want to find out more writing custom instruments,
if you type in DTrace instruments in the search panel

00:25:50.660 --> 00:25:54.610
for Xcodes help you'll get the, a list
of documents, you want to find the one

00:25:54.609 --> 00:25:56.409
that says creating custom instruments with DTrace.

00:25:56.410 --> 00:26:02.160
It's got a very comprehensive set of examples and
a description of how the instrument builder works.

00:26:02.160 --> 00:26:05.930
All right, so that's the, that's the conclusion
for the first half of the session today.

00:26:05.930 --> 00:26:08.519
So let's go over what we talked about.

00:26:08.519 --> 00:26:12.400
First DTrace allows you to add tracing
into your applications dynamically.

00:26:12.400 --> 00:26:15.430
So you don't have to bring down your application.

00:26:15.430 --> 00:26:19.170
And the up side is when you're not using it
there's not cost, because it's just not there.

00:26:19.170 --> 00:26:21.360
It's not in your app.

00:26:21.359 --> 00:26:28.479
So you can use DTrace to trace stuff with commands to the
console, which is also a very powerful set of aggregates,

00:26:28.480 --> 00:26:33.819
and histograms, and counters, and variables, and all
that stuff that you can use to gather data that's above

00:26:33.819 --> 00:26:36.589
and beyond what tracing can normally do for you.

00:26:36.589 --> 00:26:39.159
Now you can trace more than one app,
which is what I was showing in the demo.

00:26:39.160 --> 00:26:43.740
You can actually look across all of the different
probes regardless of what the application is.

00:26:43.740 --> 00:26:45.960
And you can look at a single app.

00:26:45.960 --> 00:26:52.279
Now in the examples I was hard coding pid 1, 2, 3, but you
can, there's a macro, I think dollar target, I believe,

00:26:52.279 --> 00:26:56.859
which allows you to substitute that, so
you can create reusable DTrace scripts.

00:26:56.859 --> 00:27:02.019
And then finally we talked about instruments and how
you could use DTrace to extend the power of instruments.

00:27:02.019 --> 00:27:06.910
Now if you're interested in documentation,
there's a couple of docs on the slide.

00:27:06.910 --> 00:27:07.769
They all come from Sun.

00:27:07.769 --> 00:27:12.859
And it describes the, how to use
DTrace, a couple of DTrace examples.

00:27:12.859 --> 00:27:18.459
Also of note is the DTrace Toolkit, which is
a set of pre-canned scripts that you can use,

00:27:18.460 --> 00:27:25.509
and there's one that actually emulates the, the truss tool,
you guys are familiar with doing some debugging on Unix.

00:27:25.509 --> 00:27:27.450
And that's a great one to take apart and, and play with.

00:27:27.450 --> 00:27:30.100
So dtruss is what it would be called.

00:27:30.099 --> 00:27:34.369
And that's actually in solaris systems if you want
to play with that, dtruss would be the commander run.

00:27:34.369 --> 00:27:35.849
All right, that's it.

00:27:35.849 --> 00:27:39.399
I'm going to invite Jim up here to
talk to you about advanced debugging.

00:27:39.400 --> 00:27:47.460
>> [Jim] So as you saw with the DTrace examples and, and
instruments the-- basically once you get to advanced,

00:27:47.460 --> 00:27:50.400
so in other words, you know, you
know how to like run the sampler

00:27:50.400 --> 00:27:53.480
or in the debugger you know how
to step in X, and stuff like that.

00:27:53.480 --> 00:27:56.860
Then basically everything that you're
doing after that is you just trying

00:27:56.859 --> 00:28:02.169
to like accumulate some nice little toolkit bag of
tricks that's specific to your application that knows how

00:28:02.170 --> 00:28:07.610
to find the data structures, and you know, the
common problems that you have and stuff like that.

00:28:07.609 --> 00:28:11.469
So debugging is basically in all of
these kind of investigative tools.

00:28:11.470 --> 00:28:15.120
What you really want to do is get
underneath the tool and figure

00:28:15.119 --> 00:28:18.739
out how you can customize it for
your own particular problems.

00:28:18.740 --> 00:28:21.690
So that's what we want to talk about today.

00:28:21.690 --> 00:28:28.490
So partly I'll talk about a couple of the
flexible tools that underlie the Xcode debugger,

00:28:28.490 --> 00:28:31.480
and that you can take advantage of yourself.

00:28:31.480 --> 00:28:34.250
And then I'll also talk about a little assortment of,

00:28:34.250 --> 00:28:39.039
of stuff that we've put together
for a few little specific problems.

00:28:39.039 --> 00:28:44.889
So in particular, I'm going to just show you also a
couple of little new features in the Xcode debugger,

00:28:44.890 --> 00:28:47.000
which are nice, so that people have been asking for.

00:28:47.000 --> 00:28:50.990
And some that are appropriate to these
little individual specific cases.

00:28:50.990 --> 00:28:56.799
I'm going to talk about the data formatters feature
in the Xcode debugger, which maybe you haven't played

00:28:56.799 --> 00:28:59.940
around with, but actually is, is pretty powerful.

00:28:59.940 --> 00:29:03.610
I'm going to-- because threads are just a big thing,

00:29:03.609 --> 00:29:06.649
we've added a few little features
to make debugging threads easier.

00:29:06.650 --> 00:29:08.230
So I'm going to talk about that.

00:29:08.230 --> 00:29:12.559
And then finally I'll, I'll dig a little
bit into the GDB command language.

00:29:12.559 --> 00:29:19.649
GDB is the debugger that underlies the Xcode
debugger in the same way that DTrace is the power

00:29:19.650 --> 00:29:22.500
that underlies a bunch of the instruments, instruments.

00:29:22.500 --> 00:29:24.549
So I'll tell you a little bit about that.

00:29:24.549 --> 00:29:28.299
So first of all the new features in Xcode 3.2.

00:29:28.299 --> 00:29:31.029
Some of them are enhancements of stuff we've already had.

00:29:31.029 --> 00:29:34.670
So, for instance, you know, Xcode
forever has had this memory window.

00:29:34.670 --> 00:29:36.870
And there's always been this memory window.

00:29:36.869 --> 00:29:40.659
And so, now you actually have more
than one, which is like Yay!, whatever.

00:29:40.660 --> 00:29:43.080
[ applause ]

00:29:43.079 --> 00:29:47.779
The other one that, that, the next
thing is attaching the program.

00:29:47.779 --> 00:29:53.559
So again, since like Xcode 2.5 or something like that,
there's been an attach menu that you could go and attach

00:29:53.559 --> 00:30:00.109
to a program, but there's a certain class of
programs, which are still pretty hard to attach to.

00:30:00.109 --> 00:30:04.559
And it's basically all the worker programs
that you aren't controlling the launch of.

00:30:04.559 --> 00:30:07.220
So how do you get the debugger to
grab something when it starts up?

00:30:07.220 --> 00:30:12.170
Like if you're writing a launchd daemon, launchd
is going to launch it whenever, and you know,

00:30:12.170 --> 00:30:14.960
you can't launch it outside launchd, How do you get that?

00:30:14.960 --> 00:30:18.549
Or again, if your program spawns off
little worker programs to do things, like,

00:30:18.549 --> 00:30:20.589
you know, to raise the security level or whatever.

00:30:20.589 --> 00:30:25.549
And on the iPhone there, you can launch
programs in response to push notifications.

00:30:25.549 --> 00:30:28.730
Again, you know, that's just going
to show up and you need to grab it.

00:30:28.730 --> 00:30:32.289
So the way we've added some functionality to do this.

00:30:32.289 --> 00:30:41.379
In Xcode if you have a project in the-- an Xcode
project, then you can open the active Executable Editor,

00:30:41.380 --> 00:30:47.900
and then you'll see there's a new checkbox, which is,
you know, wait for next launch or push notification.

00:30:47.900 --> 00:30:51.240
So what you would do is you would take
your project, you would set this check box

00:30:51.240 --> 00:30:54.069
in the Executable Editor, you'd launch the debugger.

00:30:54.069 --> 00:30:57.609
But instead of launching your projects,
what it would do is--

00:30:57.609 --> 00:31:01.209
or your executable, what it would do
is just sit around and poll the system.

00:31:01.210 --> 00:31:06.140
And then when that executable shows up
it'll grab it by the throat and stop it.

00:31:06.140 --> 00:31:09.600
The process that-- the polling we do pretty frequently.

00:31:09.599 --> 00:31:15.099
So if your machine's not heavily
loaded we'll get to the process

00:31:15.099 --> 00:31:18.189
and stop it pretty much before any of your code gets run.

00:31:18.190 --> 00:31:22.000
Usually it's some very scary part
of DUILD that it stops in.

00:31:22.000 --> 00:31:26.140
But, but then you could just continue
on and get it to the part that you want.

00:31:26.140 --> 00:31:27.200
You won't miss anything.

00:31:27.200 --> 00:31:32.590
In GDB if you use the command line
GDB, the same facility is available.

00:31:32.589 --> 00:31:36.809
There's this wait for flag that we've added to
the attach command, so you would use it like this.

00:31:36.809 --> 00:31:39.730
You would say attached -waitforMyProcess.

00:31:39.730 --> 00:31:46.309
The one thing to note, by the way, just so you don't
get confused, we actually filter the process list

00:31:46.309 --> 00:31:52.159
and throw away all the processes named whatever
the process is, which are already running.

00:31:52.160 --> 00:31:56.670
So we'll catch the next process of that name that shows up.

00:31:56.670 --> 00:31:59.039
So like if you use attach -waitfor, and we sit there,

00:31:59.039 --> 00:32:01.279
but your process is running, and
you're like, What are you doing?

00:32:01.279 --> 00:32:03.639
We're waiting for the next one.

00:32:03.640 --> 00:32:07.370
OK, soon as he just-- so another one,
this is just silly, but, you know,

00:32:07.369 --> 00:32:12.789
when you started debugging Objective-C
code somebody took this stone tablet

00:32:12.789 --> 00:32:14.740
or it was carved in race memory, or whatever.

00:32:14.740 --> 00:32:17.740
And they told you, you know, N is exception
rate, is you know-- put a break point there.

00:32:17.740 --> 00:32:19.650
You don't know why, but just put it there.

00:32:19.650 --> 00:32:22.900
And then when an Objective-C exception is drawn.

00:32:22.900 --> 00:32:26.110
But then in, in the 2.0 run time it changed.

00:32:26.109 --> 00:32:29.179
It was no longer NS exception rate;
now it was Objective-C exception throw.

00:32:29.180 --> 00:32:33.490
So somebody had to hand you another stone tablet
and, you know, you put it in your desk or whatever.

00:32:33.490 --> 00:32:36.839
So we've actually added a, a menu item for that, though.

00:32:36.839 --> 00:32:38.399
Now we'll track with the, yeah...

00:32:38.400 --> 00:32:39.820
[ applause ]

00:32:39.819 --> 00:32:47.200
So, so the next time the crafty Objective-C guys
change it to something else, provided they tell us,

00:32:47.200 --> 00:32:51.470
you know, or whatever, then we'll fix it.

00:32:51.470 --> 00:32:51.740
[ laughter ]

00:32:51.740 --> 00:32:54.819
OK, so this one's kind of sad in a certain sense.

00:32:54.819 --> 00:33:00.139
We actually spent a lot of time working on getting
inline code to work correctly in the debugger.

00:33:00.140 --> 00:33:04.940
But it's one of those ones where in the end what
happens is like kind of one of these duh things, right?

00:33:04.940 --> 00:33:10.200
So, I mean if you have inline code, and, and this
actually shows up even in your normal debugging sessions,

00:33:10.200 --> 00:33:14.360
because there are things like NSMakeRect and
so on and so forth, which are always in line,

00:33:14.359 --> 00:33:18.189
even in -O code that you're using for debugging.

00:33:18.190 --> 00:33:21.309
And before you like step into it, even
if you didn't intend to and stuff.

00:33:21.309 --> 00:33:25.960
So now with the 3.2, if you're building with the dwarf,

00:33:25.960 --> 00:33:29.340
which everybody hopefully is building
with dwarf debug information now.

00:33:29.339 --> 00:33:32.809
Then like step, and next, and finish,
it just looks like an ordinary function.

00:33:32.809 --> 00:33:33.759
So that's kind of cool.

00:33:33.759 --> 00:33:38.269
I mean, inline frames show, up in the
backtraces, so those slides are out of order.

00:33:38.269 --> 00:33:45.109
So here I'm just showing that the, the inline
frame, NSMakeRect shows ups, we mark it as inline.

00:33:45.109 --> 00:33:49.809
So, you know, if you wanted to know did this
get inlined or not, you can figure that out.

00:33:49.809 --> 00:33:58.079
And the, the one little caveat is the, the way that we know
about the inlining is in the little table of information

00:33:58.079 --> 00:34:00.449
that tells us about files and line numbers.

00:34:00.450 --> 00:34:06.299
So if you want to break on all the instances of where
an inline function got inlined all over in your code,

00:34:06.299 --> 00:34:09.219
don't try to set the breakpoint on NSMakeRect.

00:34:09.219 --> 00:34:11.759
That'll get some of them, but it won't get all of them.

00:34:11.760 --> 00:34:16.700
But if you go to the header file that defines
NSMakeRect and break on, you know, whatever it is, :12,

00:34:16.699 --> 00:34:23.049
or wherever NSMakeRect is, then we'll find
actually all the instances in the program.

00:34:23.050 --> 00:34:26.700
So that's inline code support.

00:34:26.699 --> 00:34:34.059
I told you there's some features that we added for threads,
but we'll get to that when we, when we get to threads.

00:34:34.059 --> 00:34:38.570
There are a couple of other little
tools for common problems, both memory.

00:34:38.570 --> 00:34:45.380
One is if you're in the modern world of, of
the garbage collected Objective-C two run time,

00:34:45.380 --> 00:34:47.700
then we have a little bit of help
for those sorts of problems.

00:34:47.699 --> 00:34:50.419
Again, because you're in the brand new, shiny world

00:34:50.420 --> 00:34:53.730
of garbage collection you'll never have
the standard memory problems, you know,

00:34:53.730 --> 00:34:57.159
you never access the freed point
or anything like that any more.

00:34:57.159 --> 00:35:02.769
The main thing that happens is you have, your
program is just increasing in memory size, you know.

00:35:02.769 --> 00:35:05.639
And somehow your objects are never going away.

00:35:05.639 --> 00:35:07.139
So that's what you want to do.

00:35:07.139 --> 00:35:09.889
You want to say, OK, well this object,
you know, who's holding onto it?

00:35:09.889 --> 00:35:13.529
Why, why hasn't its memory been reclaimed?

00:35:13.530 --> 00:35:19.110
So it's obviously some other object has a
reference to it and you have to just find that out.

00:35:19.110 --> 00:35:25.090
So in Xcode when you are looking either in the local
variables view, or if you're looking in your source view,

00:35:25.090 --> 00:35:28.970
and you find the variable that's bad, that's not going away,

00:35:28.969 --> 00:35:32.489
then you can bring up the little
pop-up, you know, control-click.

00:35:32.489 --> 00:35:35.189
And you'll get something that looks
like the pop-up like this.

00:35:35.190 --> 00:35:43.170
And now you have 2 new commands, 1 will print the
root object, which eventually trace down to the,

00:35:43.170 --> 00:35:45.960
the variable you're pointing to-the
object you're pointing to.

00:35:45.960 --> 00:35:49.849
And the other will show you all the
immediate refers to that object.

00:35:49.849 --> 00:35:55.029
And then you can use that to figure out who
you should have gotten rid of, or you know,

00:35:55.030 --> 00:35:58.560
why that person has a reference to
the thing and it's not going away.

00:35:58.559 --> 00:36:02.110
In the GDB console you can also do the same thing.

00:36:02.110 --> 00:36:06.510
The commands are info gc roots, and info gc references.

00:36:06.510 --> 00:36:12.500
And then for the people who are still back in the stone
age and using poor Malloc, you know, carving free,

00:36:12.500 --> 00:36:16.829
and Malloc and having to do it themselves, and
all that hard work that our forefathers had to do.

00:36:16.829 --> 00:36:18.969
We have a little help for you.

00:36:18.969 --> 00:36:23.079
So there was always a program in
command line GDB called Malloc history.

00:36:23.079 --> 00:36:28.610
And what we've done is just moved that same functionality
into the debugger, so you can immediately say,

00:36:28.610 --> 00:36:31.550
you know, What's the Malloc history of a variable?

00:36:31.550 --> 00:36:31.920
or whatever.

00:36:31.920 --> 00:36:34.740
So the way that that worked with
Malloc history and the way it works

00:36:34.739 --> 00:36:41.179
with the debugger is there's this Malloc stacklogging
no compact environment variable, which you set to Yes.

00:36:41.179 --> 00:36:48.009
And then the Malloc library will then record
all the, all the Malloc events, basically.

00:36:48.010 --> 00:36:53.020
There's no UI for this next code, but you
can go to the console window and you type

00:36:53.019 --> 00:36:55.909
in info Malloc history and give it an expression.

00:36:55.909 --> 00:36:59.259
That expression could be anything, but
it's going to resolve down to an address.

00:36:59.260 --> 00:37:04.620
And then basically what this is going to return to is,
all the times that that address was either returned

00:37:04.619 --> 00:37:07.829
from a Malloc call or passed to a free call.

00:37:07.829 --> 00:37:10.090
And will show you a user stack and all that sort of stuff.

00:37:10.090 --> 00:37:13.539
And since we're the debugger we're smart, we can
give you line numbers and all that kind of stuff.

00:37:13.539 --> 00:37:18.989
The one caveat there, this is the exact address.

00:37:18.989 --> 00:37:21.519
Sometimes what happens is, you know,
you're accessing a freed pointer.

00:37:21.519 --> 00:37:27.460
But the freed pointer was allocated inside a
block, and so it's not the beginning address.

00:37:27.460 --> 00:37:33.730
And you would just want to know, tell me all
the, the history events where this address--

00:37:33.730 --> 00:37:38.500
that this expression resolves down
to, was contained in the block.

00:37:38.500 --> 00:37:41.929
So you can pass the dash range
argument and, and it will do that.

00:37:41.929 --> 00:37:45.019
Of course, that's going to potentially
give you a lot more hits,

00:37:45.019 --> 00:37:47.079
and you're going to have to figure
out which ones are relevant.

00:37:47.079 --> 00:37:50.079
So if you know the address, the first one's better.

00:37:50.079 --> 00:37:54.630
OK, so the next topic I want to
talk about is, is data formatters.

00:37:54.630 --> 00:37:59.300
We talked about these and introduced them a couple
of years ago, but it's worth going over them again.

00:37:59.300 --> 00:38:04.100
Because they're one of those things that they either
sit there statically, and you kind of don't touch them,

00:38:04.099 --> 00:38:08.829
or you just get used to playing with them all the time,
and then you'll, you'll really grow to like them I think.

00:38:08.829 --> 00:38:12.789
So the deal is, you know, you've
had this local variables view

00:38:12.789 --> 00:38:15.820
or the expressions view in Xcode, you've got used to it.

00:38:15.820 --> 00:38:19.590
But there's one column, the summary
column, that's over on the right hand side.

00:38:19.590 --> 00:38:23.809
And that's always had kind of magically cool
information if you don't know how it comes about.

00:38:23.809 --> 00:38:28.309
Like that notification is a, is a NSNotification thingy.

00:38:28.309 --> 00:38:34.929
And but instead of showing you just the pointer value, we're
actually displaying what the name of the notification was.

00:38:34.929 --> 00:38:40.710
Or in the case of this NSRect that's sitting here, I mean,
we have all the relevant information that's interesting

00:38:40.710 --> 00:38:45.179
about it, you know, sitting up there in the
summary column, so you don't have to turn it down

00:38:45.179 --> 00:38:47.539
and look among its fields and stuff like that.

00:38:47.539 --> 00:38:51.559
The point is that that's not just something,
which the gods of Xcode have blessed you

00:38:51.559 --> 00:38:55.019
with for a few special shining instances.

00:38:55.019 --> 00:38:58.429
But it's actually something that you
can mess around with and do yourself.

00:38:58.429 --> 00:39:00.440
And that's what data formatters are for.

00:39:00.440 --> 00:39:05.730
So basically their job is that they fill the
summary column of the local variables view.

00:39:05.730 --> 00:39:11.090
And it's helpful, because now you know if you have a huge
number of ivars, but you only care about 2

00:39:11.090 --> 00:39:15.250
for your particular debugging session, you don't have to
go, you know, like turn it down, scroll, scroll, scroll,

00:39:15.250 --> 00:39:17.000
find the next one, turn it down, scroll, scroll, scroll.

00:39:17.000 --> 00:39:19.900
You can just look at it right there
without turning the thing down.

00:39:19.900 --> 00:39:27.180
Also sometimes you need to do some special formatting to
make the-- one of the variables look like you like it,

00:39:27.179 --> 00:39:29.289
like you want to cast it, or something like that.

00:39:29.289 --> 00:39:31.329
You can even filter a value through an expression.

00:39:31.329 --> 00:39:36.920
So if all you care about is whether something's greater than
11, you know, you can say, Show me just greater than 11,

00:39:36.920 --> 00:39:39.519
and then you don't have to go 12
is that greater than 11, you know,

00:39:39.519 --> 00:39:42.809
which is hard some nights at 3 o'clock in the morning.

00:39:42.809 --> 00:39:50.360
And then, and then finally sometimes you have formatting
that you want to do that's special to an object you have,

00:39:50.360 --> 00:39:54.269
but you don't want to ship it with your code,
because it's, I don't know, it's just useless,

00:39:54.269 --> 00:39:56.780
but it, it does some nice formatting job.

00:39:56.780 --> 00:40:01.350
There's a way to write little bundles
that have custom formatting functions.

00:40:01.349 --> 00:40:04.549
And tell the debugger about them, and the
debugger will insert them into your program.

00:40:04.550 --> 00:40:10.070
We're not going to talk about that this
time, but there's a sample in the sample code

00:40:10.070 --> 00:40:12.730
on developer.apple.com, the WcharDataFormatter.

00:40:12.730 --> 00:40:15.320
You can go download that and it shows you all how to do it.

00:40:15.320 --> 00:40:17.769
It has a header file, which describes everything.

00:40:17.769 --> 00:40:22.139
And finally there is some documentation on this.

00:40:22.139 --> 00:40:27.099
If you look at the Xcode help and go to the
Xcode debugging guide in the viewing variables

00:40:27.099 --> 00:40:29.789
and memory, there's a using data formatters section.

00:40:29.789 --> 00:40:34.070
So the general rules, How, how does this work?

00:40:34.070 --> 00:40:37.930
Again, the results are displayed in the summary
column, I said that a couple of times now.

00:40:37.929 --> 00:40:39.529
They key off the variables types.

00:40:39.530 --> 00:40:46.660
So you write one data formatter for a given type, and then
every variable of that type, regardless of whether it's,

00:40:46.659 --> 00:40:53.719
you know, sub-structure element or the primary
element, will use that data formatter, but of course,

00:40:53.719 --> 00:40:57.329
with the values of the particular
variable in the summary column.

00:40:57.329 --> 00:41:02.509
If, if you have a typedef you can write
another formatter with the typedef name

00:41:02.510 --> 00:41:07.260
and the typedef will get used--
typedef formatter will get used.

00:41:07.260 --> 00:41:09.850
You can also enter these in the summary column.

00:41:09.849 --> 00:41:14.889
So if you double-click in the summary column,
then you'll see the formatter string there,

00:41:14.889 --> 00:41:17.159
and then you can put your own in or do whatever you want.

00:41:17.159 --> 00:41:21.319
And then you have to click off
that row to see the summary update.

00:41:21.320 --> 00:41:25.490
And then finally the ones you enter that
way by, by clicking in the summary column--

00:41:25.489 --> 00:41:27.679
double-clicking in the editing stuff, and clicking off.

00:41:27.679 --> 00:41:33.879
They get saved in a user file, which is
this horrible long path, whatever it is.

00:41:33.880 --> 00:41:38.460
So here's an example of what a formatter string would look
like, and let's just kind of take it apart piece by piece.

00:41:38.460 --> 00:41:44.380
So the first thing is you can have just random
text, whatever you want, you can put it in.

00:41:44.380 --> 00:41:46.480
The second part of it is more interesting.

00:41:46.480 --> 00:41:52.619
That's the part where you are taking the
values of the variable that is of the type

00:41:52.619 --> 00:41:54.750
that the formatter is-- the formatter for.

00:41:54.750 --> 00:41:58.989
And, and, and sticking them into the, the formatter string.

00:41:58.989 --> 00:42:06.189
So there's two kinds, one is a simple,
just structure reference string.

00:42:06.190 --> 00:42:13.420
So here for instance, this variable is an NSRect,
for instance, and it has an origin element.

00:42:13.420 --> 00:42:15.840
And then the origin element has an X field in it.

00:42:15.840 --> 00:42:21.260
So here we're just saying, I want the X
field of the origin element, or whatever.

00:42:21.260 --> 00:42:25.180
And those have a little percent delimiter around them.

00:42:25.179 --> 00:42:29.239
And then the other kind is more
general; it's just any random expression.

00:42:29.239 --> 00:42:37.029
This is basically anything you could type in a C language
in your program, or anything you would type as an expression

00:42:37.030 --> 00:42:41.140
of the print command in the GDB debugger, you can put here.

00:42:41.139 --> 00:42:42.909
Note that you could put anything you want.

00:42:42.909 --> 00:42:48.829
This is a particularly bad example, because here I'm
actually taking the variable and incrementing its value,

00:42:48.829 --> 00:42:51.529
which is going to get done every time
you step when the formatter updates.

00:42:51.530 --> 00:42:54.060
So it's probably not something
you want to put in your own code,

00:42:54.059 --> 00:42:58.139
but on the other hand if your office mate
leaves his desk it might be a nice thing to do.

00:42:58.139 --> 00:42:58.629
[ laughter ]

00:42:58.630 --> 00:43:02.849
And, you, you put the, you put the curly brackets around it.

00:43:02.849 --> 00:43:09.869
And the dollar bar little token you see there stands for
the variable, which is the variable that this format--

00:43:09.869 --> 00:43:14.480
has the type that this formatter string
is, the summary string of that type for.

00:43:14.480 --> 00:43:21.740
Whatever. Then the, the last thing is there's a little
bit of freedom you have in what in particular you want

00:43:21.739 --> 00:43:26.199
to display out of the element that
you pulled out of that variable.

00:43:26.199 --> 00:43:33.429
The simplest one-- oh, so, note that, you know, whenever
I write one of these sub expressions like %, origin, .x%,

00:43:33.429 --> 00:43:41.039
that is both a value, but it also has a type, because
that's like the ends that, that is the X value or whatever.

00:43:41.039 --> 00:43:45.340
So I can choose to just pull the value out if I want,

00:43:45.340 --> 00:43:51.710
in which case I would put this little :v
there, and that's the default, by the way.

00:43:51.710 --> 00:43:58.980
But a more cool possibility is to actually pull
the result of the summary of that sub-element out

00:43:58.980 --> 00:44:01.900
and stick it in the summary of the containing object.

00:44:01.900 --> 00:44:07.619
And that way you can sort of hoist summaries
up through chain of types without having

00:44:07.619 --> 00:44:09.679
to repeat this summary over and over again.

00:44:09.679 --> 00:44:13.210
And you can actually get some really
nice summaries built up that way.

00:44:13.210 --> 00:44:17.480
And finally if you want to know the dynamic
type of something, you can use the :t.

00:44:17.480 --> 00:44:23.309
And they show up, you just appended them to the
value sub-element like this shown on the slide there.

00:44:23.309 --> 00:44:29.119
So this is a little abstract, but it, once you see it
as you play around with it, I think it'll become clear.

00:44:29.119 --> 00:44:30.849
So we're going to do a little demo with Greg here.

00:44:30.849 --> 00:44:35.380
The first thing is, see he has, you know, some, he's
stopped somewhere and, and he's looking at his code.

00:44:35.380 --> 00:44:40.530
The first thing is that, you know, there is some that
are provided for you, and you can actually look at those

00:44:40.530 --> 00:44:42.590
and play around with those, and get some examples.

00:44:42.590 --> 00:44:47.740
So again, you know, there we see he's
double-clicking to see what the elements are.

00:44:47.739 --> 00:44:51.559
But maybe you, you don't like the ones that we provided.

00:44:51.559 --> 00:44:55.099
For instance, this width and this height,
I mean you know their width and height,

00:44:55.099 --> 00:44:57.069
they're too long, they take up too much space.

00:44:57.070 --> 00:44:58.550
You might want to get rid of that.

00:44:58.550 --> 00:45:02.080
So again, you can edit the ones that we
have, and maybe you want to just make

00:45:02.079 --> 00:45:04.500
that shorter, because it looks better to you.

00:45:04.500 --> 00:45:05.739
And then you click off it.

00:45:05.739 --> 00:45:10.679
So notice two things happen there, one the size changed.

00:45:10.679 --> 00:45:16.969
But also notice that in the frame,
that NSRect, that one changed as well.

00:45:16.969 --> 00:45:18.889
So let's look at that summary formatter.

00:45:18.889 --> 00:45:22.309
That's an example of using this :s
formatter that I told you about.

00:45:22.309 --> 00:45:28.799
So in the case of the second part of the NSRect
formatter there, you know, we've put in the size,

00:45:28.800 --> 00:45:34.300
and then the :s form, which says, take
the summary value of the size field,

00:45:34.300 --> 00:45:36.730
and stick it up in my summary for the NSRect.

00:45:36.730 --> 00:45:39.940
So that's why both of them changed at the same time.

00:45:39.940 --> 00:45:43.150
The one thing that might be a little
curious to you is that, the, the--

00:45:43.150 --> 00:45:46.599
we have an NSRect sitting there and it didn't change.

00:45:46.599 --> 00:45:47.409
So why is that?

00:45:47.409 --> 00:45:49.609
Well whenever you get into this
problem you're changing something,

00:45:49.610 --> 00:45:52.120
you think you've got it right,
but it's actually not showing up.

00:45:52.119 --> 00:45:56.460
Often it's because things are typedef'd to
different types than you would expected them to be.

00:45:56.460 --> 00:45:58.480
So you can just show the type column.

00:45:58.480 --> 00:46:04.210
And yes, low and behold, the NSRect does
not have an NSSize, it has a CG size.

00:46:04.210 --> 00:46:05.409
No idea why.

00:46:05.409 --> 00:46:09.549
And so if you wanted to change the
CG-the NSRect one, you'd have to go

00:46:09.550 --> 00:46:12.600
and edit it separately, because they are separate types.

00:46:12.599 --> 00:46:18.329
Show another little example, suppose for
whatever your problem is you're not interested

00:46:18.329 --> 00:46:23.659
in the upper left hand corner and the,
the, the size of the, of the NSRect,

00:46:23.659 --> 00:46:27.920
but suppose you want the upper left hand
corner and the lower right hand corner,

00:46:27.920 --> 00:46:30.650
then you'd have to do a little calculation to get that.

00:46:30.650 --> 00:46:34.039
So this is showing you the, the curly bracket one.

00:46:34.039 --> 00:46:41.250
We're doing a little calculation for the second half where
we get the X2 and the Y2 points by taking the origin.X

00:46:41.250 --> 00:46:46.869
and adding it to-- adding the width to it, and the
origin.Y and adding the, the width, a height to that.

00:46:46.869 --> 00:46:51.380
And again, that just shows you how to use the
dollar bar and the computational side of things.

00:46:51.380 --> 00:46:57.740
So then the next thing about this-- of course,
play around freely with the ones we've provided,

00:46:57.739 --> 00:47:00.299
because you don't actually ever get rid of them.

00:47:00.300 --> 00:47:04.910
If you have changed them, and changed them, and changed
them, and you don't like them anymore, you can just go

00:47:04.909 --> 00:47:08.889
and delete what you added, and the
ones that we have will come back.

00:47:08.889 --> 00:47:11.759
So you can freely play around with
them, you won't loose anything.

00:47:11.760 --> 00:47:14.390
So that's kind of one reason why these are useful.

00:47:14.389 --> 00:47:20.859
But I want to show you the second one, which is the--
where, where you have just a complicated object,

00:47:20.860 --> 00:47:23.900
and so here's an NSWindow, for instance, we have here.

00:47:23.900 --> 00:47:25.630
And it's got like all these elements.

00:47:25.630 --> 00:47:28.789
And never in your debugging problem
do you care about all of them.

00:47:28.789 --> 00:47:32.599
So you're going through one particular path
of debugging, you only care about a couple.

00:47:32.599 --> 00:47:37.960
So maybe in this case the window's not coming out the
right size, so I care about the size of the window.

00:47:37.960 --> 00:47:40.630
But I don't care about all those other
fields and having to turn it down

00:47:40.630 --> 00:47:43.869
and find the bounds every time is really bumming me out.

00:47:43.869 --> 00:47:48.009
So what I can do is I can just make a little
data formatter which stores the, the frame.

00:47:48.010 --> 00:47:51.610
OK, so that was nice, except that
wasn't particularly helpful, because,

00:47:51.610 --> 00:47:53.880
you know, curly bracket, that wasn't helpful.

00:47:53.880 --> 00:47:55.860
And that was because I used the value of the thing.

00:47:55.860 --> 00:47:58.570
I didn't really want the value, I wanted its summary.

00:47:58.570 --> 00:48:03.320
So if I change it to the summary then, then
I'll actually get the display I wanted.

00:48:03.320 --> 00:48:08.970
The, the point really to take home is,
this is for your debugging session.

00:48:08.969 --> 00:48:12.679
So you got the size right, and that,
you don't care about that any more.

00:48:12.679 --> 00:48:13.219
That's right.

00:48:13.219 --> 00:48:17.399
But now something else is wrong, like I don't
know, the delegate's wrong, and so, you know,

00:48:17.400 --> 00:48:19.559
it's not, who, whatever that's supposed to do.

00:48:19.559 --> 00:48:19.869
I don't know.

00:48:19.869 --> 00:48:21.299
I don't do this Objective-C stuff.

00:48:21.300 --> 00:48:22.769
But anyway that's wrong some how.

00:48:22.769 --> 00:48:25.509
And, so you, you want to fix it.

00:48:25.510 --> 00:48:27.670
And, and so now you can put that one there.

00:48:27.670 --> 00:48:31.849
And so now every time that you're stepping
through this function, you're tracing that thing.

00:48:31.849 --> 00:48:38.429
So it's basically your little playground where
you can focus your attention on what aspects

00:48:38.429 --> 00:48:42.789
of a complicated large object you care
about at any particular point in time.

00:48:42.789 --> 00:48:45.259
That's, that's the example, thanks Greg.

00:48:45.260 --> 00:48:49.270
So it's one of those things that it kind of sits there and
if you don't remember its percent in its curly bracket,

00:48:49.269 --> 00:48:51.889
and it's dollar bar, and you'll never use it.

00:48:51.889 --> 00:48:55.829
But then if you just do it a couple of times then it just
becomes this little thing that you just change all the time.

00:48:55.829 --> 00:48:58.440
And it, it's a really nice little feature.

00:48:58.440 --> 00:49:06.780
OK, so the next topic I wanted to talk a little bit
about, you know, in the new world, in Snow Leopard,

00:49:06.780 --> 00:49:10.430
and our desire to take advantage of
all the cores that are now existing

00:49:10.429 --> 00:49:12.659
on our more modern systems, and so on and so forth.

00:49:12.659 --> 00:49:20.089
And not only your desire, by the way, but the desire on
the part of Apple, is going to mean that your programs

00:49:20.090 --> 00:49:24.789
as you move along will start having more, and
more, and more, and more threads showing up.

00:49:24.789 --> 00:49:32.809
And, again, not just the ones that you make, because a
lot of the kit underneath you is doing a lot threading

00:49:32.809 --> 00:49:39.489
to do its tasks, so you would ask it to do something,
which on Leopard would be just a concurrent call

00:49:39.489 --> 00:49:41.909
that would run in the thread that you did it on.

00:49:41.909 --> 00:49:46.899
But you'll see in Snow Leopard all of a sudden all
these threads are spawned off and they're doing stuff.

00:49:46.900 --> 00:49:50.769
So just understanding what your program is doing now,

00:49:50.769 --> 00:49:54.159
you're going to see many more threads
and have to figure out what they do.

00:49:54.159 --> 00:49:58.219
So the first task then it just, What the heck are they all?

00:49:58.219 --> 00:50:02.349
And so we gave a little help for that, I'll show you.

00:50:02.349 --> 00:50:05.940
And then there's also ways to get
some accounting information

00:50:05.940 --> 00:50:08.110
and stuff like that, which might be useful to you.

00:50:08.110 --> 00:50:17.220
More importantly, particularly as you generate more threaded
and concurrent running of code that you're interested in,

00:50:17.219 --> 00:50:22.589
what could end up happening is that, you know, you
are trying to follow a logic problem in a function

00:50:22.590 --> 00:50:26.680
that you've called, but, so you put a
break point there, so you stopped there.

00:50:26.679 --> 00:50:30.559
And then you start running along and you hit that
break point, which is great, and then you're stepping

00:50:30.559 --> 00:50:32.849
through to follow the logic, but the
break point's still sitting there.

00:50:32.849 --> 00:50:37.019
And the other threads area also going to run that code and
they're going to hit that break point, and now, you know,

00:50:37.019 --> 00:50:39.429
you're switching back and forth
between one thread and another.

00:50:39.429 --> 00:50:43.059
And you loose the context of the logic you're
trying to follow, and you get all confused.

00:50:43.059 --> 00:50:47.070
And then, then you say bad things about
me, so I'd rather you didn't do that.

00:50:47.070 --> 00:50:49.730
So we'll, we'll give you a little help for that.

00:50:49.730 --> 00:50:51.760
So first of all, identifying threads.

00:50:51.760 --> 00:50:58.460
Basically Snow Leopard added an
API to set a name for a pthread.

00:50:58.460 --> 00:51:02.889
And here's what the API looks like, it's
pthread set name and the np means nonportable.

00:51:02.889 --> 00:51:06.529
Just it's not a required part of the
POSIX standard for pthreads.

00:51:06.530 --> 00:51:13.530
And the way that the Mac OS X implementation works is you
just call it in the thread you are setting the name for,

00:51:13.530 --> 00:51:17.810
and you pass the, a string, which is going to be the name.

00:51:17.809 --> 00:51:22.130
So choose some unique name, by the way, because,
you know, I mean, you're getting some library

00:51:22.130 --> 00:51:25.130
and they call all their threads thread
1, thread 2, thread 3, thread 4.

00:51:25.130 --> 00:51:27.930
You call yours thread 1, thread 2,
that's not going to help very much.

00:51:27.929 --> 00:51:31.319
So if you just, I mean just choose
something that you'll recognize.

00:51:31.320 --> 00:51:38.680
Note by the way, there's this old API and
NSThread, so the NSThread's not an old class,

00:51:38.679 --> 00:51:40.690
I mean it's been around, but it's useful.

00:51:40.690 --> 00:51:42.909
But it has a set name API.

00:51:42.909 --> 00:51:46.779
But apparently they, they didn't
remember that they had a set name API,

00:51:46.780 --> 00:51:49.930
because they didn't set the pthread
name in the set name API.

00:51:49.929 --> 00:51:55.779
So if you have an NSThread and you've been calling
NSThread set name, that's not going to help us at all,

00:51:55.780 --> 00:52:01.340
so you still have to call this
pthread set name np call, whatever.

00:52:01.340 --> 00:52:06.600
And by the way this is useful, not just for the debugger,
you'll notice that if you name your threads this way,

00:52:06.599 --> 00:52:11.089
sample, and all the other tools like
that will also show your thread names.

00:52:11.090 --> 00:52:14.039
So it's, it's something that's worth doing.

00:52:14.039 --> 00:52:22.159
The other kind of named entity in the new world of, of
Snow Leopard's multithreading is the GCD queue label.

00:52:22.159 --> 00:52:29.219
So when you make a queue in GCD saying, I have a bunch of
work, Oh, queue would you please go do it for me, you ge--

00:52:29.219 --> 00:52:34.689
what you do by this dispatch queue
create, you pass it a name.

00:52:34.690 --> 00:52:40.700
And then if there's a thread that's, that's
performing work elements for a particular queue,

00:52:40.699 --> 00:52:45.359
that thread actually gets the name of the
queue that it's performing work elements for.

00:52:45.360 --> 00:52:50.130
They suggest you use a reverse DNS form,
by the way, for, for GCD queue labels.

00:52:50.130 --> 00:52:52.380
That's not me, that's the GCD guys.

00:52:52.380 --> 00:52:58.920
But in any case when you look in the thread pop-up in
the debugger, you'll now see in, in Snow Leopard 3.2,

00:52:58.920 --> 00:53:03.220
you'll see both the GCD queue name if
a thread's doing work for that queue,

00:53:03.219 --> 00:53:06.059
and you'll see the pthread name if you set the pthread name.

00:53:06.059 --> 00:53:10.210
So now you're no longer faced with this list
of, you know, thread 1 through thread 8 million.

00:53:10.210 --> 00:53:11.170
You know, but there's names.

00:53:11.170 --> 00:53:12.490
Yeah, so that really helps.

00:53:12.489 --> 00:53:14.659
[ applause ]

00:53:14.659 --> 00:53:17.789
But you have to go name your threads for it to work.

00:53:17.789 --> 00:53:20.250
And by the way, this is another one that, that's useful.

00:53:20.250 --> 00:53:23.250
The, people have been asking for some, yeah, right.

00:53:23.250 --> 00:53:26.619
So it's the whole bottom row plus
up arrow and down arrow basically.

00:53:26.619 --> 00:53:28.579
[ laughter ]

00:53:28.579 --> 00:53:30.179
Not the spacebar fortunately.

00:53:30.179 --> 00:53:34.109
There's a little more information you can get.

00:53:34.110 --> 00:53:38.940
So, so again sometimes, and this
is sort of another meta-element.

00:53:38.940 --> 00:53:44.849
I mean the console is available at all times in the
Xcode debugger, there's sometimes where you want

00:53:44.849 --> 00:53:48.349
to see a static list of information that you
can scroll around and look at in leisure.

00:53:48.349 --> 00:53:52.159
You don't have to hold the pop-up, for
instance, to see the threads and stuff like that.

00:53:52.159 --> 00:53:55.089
So, for instance, you can look at
your threads in the console as well,

00:53:55.090 --> 00:53:58.350
and sometimes that's a more convenient
way to look at things.

00:53:58.349 --> 00:54:01.809
The, the basic command in the console is info threads.

00:54:01.809 --> 00:54:04.730
And here I only have one thread,
but here's listing the threads.

00:54:04.730 --> 00:54:08.969
The first-- the star, by the way,
means that's the thread that stopped.

00:54:08.969 --> 00:54:11.909
The first element after that is the GDB thread ID.

00:54:11.909 --> 00:54:17.039
So any later commands you would do in the
console, you would pass this ID to it.

00:54:17.039 --> 00:54:18.759
That's the mach port; don't worry about that.

00:54:18.760 --> 00:54:25.720
Then you will see your name-- thread name if you, if you
name the thread, and the last element is current function,

00:54:25.719 --> 00:54:28.529
or it'll be the address if we don't have debug information.

00:54:28.530 --> 00:54:31.430
So that's the way to see the whole list of your threads.

00:54:31.429 --> 00:54:37.460
And then if you want to get more information about a
specific thread there's an info thread command, with no S.

00:54:37.460 --> 00:54:39.300
This one's not so great, the other one you clapped about.

00:54:39.300 --> 00:54:41.050
This one, no S, you didn't clap about.

00:54:41.050 --> 00:54:43.980
But anyway, and, and then you pass the number.

00:54:43.980 --> 00:54:46.710
And there's a whole bunch of stuff
that's new in Snow Leopard.

00:54:46.710 --> 00:54:52.420
There's, we dug out the accounting information,
scheduling policies, which you might be interested in.

00:54:52.420 --> 00:54:57.490
The one I want to call out is that the dispatch
queue name in the console is shown here.

00:54:57.489 --> 00:55:03.339
And then one other thing, which is often
really useful in the, in the console,

00:55:03.340 --> 00:55:06.450
is to perform like a report operation over all threads.

00:55:06.449 --> 00:55:10.500
And then you can look at it in leisure
and compare, and, and, and see things.

00:55:10.500 --> 00:55:14.949
So there's a command in the console called
thread apply, which you would use for that.

00:55:14.949 --> 00:55:21.439
So for instance, if I wanted to look at all my threads and
just get the top five frames in the stack, and then I can,

00:55:21.440 --> 00:55:26.530
you know, run around and compare them and not have to go
keep switching back and forth in the, in the debugger UI.

00:55:26.530 --> 00:55:31.820
Then I would say like backtrace
and 5 is the, is the back 5 frame.

00:55:31.820 --> 00:55:35.390
So then I see, you know, da, da, da, da, dah,
and all the threads would come out like that.

00:55:35.389 --> 00:55:38.019
So then the only thing, so that, that's useful.

00:55:38.019 --> 00:55:43.480
Basically, any command you can run just it
switches to that thread and runs the command.

00:55:43.480 --> 00:55:46.900
And instead of all, you can say
like 1 through 5 or whatever.

00:55:46.900 --> 00:55:53.300
And then after you've typed this awhile, typing thread
apply all will start getting really, really old.

00:55:53.300 --> 00:55:55.970
I actually do this, because for some
reason I like typing complete commands.

00:55:55.969 --> 00:55:59.869
And then my office mate always comes over, he's
actually across the hall, but he comes and laughs at me.

00:55:59.869 --> 00:56:06.630
So you don't need to do this, basically GDB will-- I
recognize commands by their shortest unique string.

00:56:06.630 --> 00:56:09.990
So you don't do that, but you would do this instead.

00:56:09.989 --> 00:56:12.349
Whatever. And then Jason won't laugh at you.

00:56:12.349 --> 00:56:17.159
So if you go to the lab don't type thread
apply all or Jason will laugh at you.

00:56:17.159 --> 00:56:21.250
The last part I wanted to talk about with respect
to threads is hand-scheduling the threads.

00:56:21.250 --> 00:56:27.630
So basically the debugger can't really do this for you,
because if you just freeze all the other threads in one--

00:56:27.630 --> 00:56:29.800
run one thread that's going to cause deadlock.

00:56:29.800 --> 00:56:34.039
Artificially debugger induced deadlocks, and
so we can't really can't do that for you.

00:56:34.039 --> 00:56:36.840
There's really not enough system
support for us to figure that out.

00:56:36.840 --> 00:56:39.090
So we always let all the threads run.

00:56:39.090 --> 00:56:43.670
You know, when you step over a function, do anything
continue where we don't really know what's going to go on,

00:56:43.670 --> 00:56:45.940
we really have to let all the threads run.

00:56:45.940 --> 00:56:48.940
But as I said, that can cause you to break
in another thread, and then you're like ah,

00:56:48.940 --> 00:56:51.349
and you're switching back and forth,
and it's very confusing.

00:56:51.349 --> 00:56:55.150
So sometimes you would like to
just stop and only run one thread.

00:56:55.150 --> 00:56:56.090
And there's a way to do that.

00:56:56.090 --> 00:56:59.410
There's a command in the console called scheduler locking.

00:56:59.409 --> 00:57:02.409
It's actually a variable that you would set.

00:57:02.409 --> 00:57:08.929
So the syntax looks like this, you'd say, set
scheduler locking, and it has the values on or off.

00:57:08.929 --> 00:57:11.509
On causes only the current thread to run.

00:57:11.510 --> 00:57:15.930
So all the other threads will get
stopped, and the current thread will run.

00:57:15.929 --> 00:57:21.589
It, you can actually switch around from thread to thread
with the thread pop-up or there's a thread command

00:57:21.590 --> 00:57:23.370
in GDB you can use to switch the threads.

00:57:23.369 --> 00:57:27.309
And then that will become the current
thread for these purposes.

00:57:27.309 --> 00:57:30.619
And then off causes all the threads to run again.

00:57:30.619 --> 00:57:35.219
There's no UI in Xcode for doing this, because we
really, I mean as you can see with the Provisos,

00:57:35.219 --> 00:57:37.730
there's not a really good way to
figure out when things go wrong.

00:57:37.730 --> 00:57:44.789
Things going wrong is basically the thread that you decided
to be the only thread that runs tries to take a lock,

00:57:44.789 --> 00:57:49.650
which is held by another thread, and that other
thread isn't running, because you told it not to run.

00:57:49.650 --> 00:57:51.389
So that lock will never get released.

00:57:51.389 --> 00:57:53.579
And so your thread will never acquire it.

00:57:53.579 --> 00:57:56.849
So the symptom is you know you said
next and then nothing happened.

00:57:56.849 --> 00:57:58.420
And it was just sitting there.

00:57:58.420 --> 00:58:01.860
The programs not in any weird state,
it's just waiting on a lock.

00:58:01.860 --> 00:58:07.329
So you could just interrupt it with Control-c or with
pause, and then turn the schedule locking off and continue.

00:58:07.329 --> 00:58:12.480
But that's not so good, because of course you've lost
your thread of executions through the one program.

00:58:12.480 --> 00:58:18.019
If you are smart enough yourself to know,
Oh, that lock is, you know, blah, blah, blah,

00:58:18.019 --> 00:58:20.789
and this other thread 5 is the thread that holds it.

00:58:20.789 --> 00:58:26.469
And when it gets out of this function that thread will be
released, then you can switch the current thread, you know,

00:58:26.469 --> 00:58:31.329
get out of that function, switch back to the one that
you want, and now you're back in your debugging session.

00:58:31.329 --> 00:58:38.860
But just, there's not enough information for us to do that
for you, so that's why this is the advanced debugging talk.

00:58:38.860 --> 00:58:45.460
Whatever. So the last little bit is, that I want
to tell you about is some command line tricks.

00:58:45.460 --> 00:58:52.349
Because the GDB command language, while if you use it
long enough, you'll hate it, but love it at the same time.

00:58:52.349 --> 00:58:55.429
But it has some really powerful
features that you can take advantage of.

00:58:55.429 --> 00:59:02.879
If you want to learn more about it, by the way, when you're
in the console you can type help and it'll give you a list

00:59:02.880 --> 00:59:04.519
of things you might type more help about.

00:59:04.519 --> 00:59:06.280
You can type help about a command name.

00:59:06.280 --> 00:59:09.210
There's an apropos command, which you can use.

00:59:09.210 --> 00:59:12.369
You say apropos and some word and
it'll find all the commands that have

00:59:12.369 --> 00:59:15.889
that in their little help strings and tell you about them.

00:59:15.889 --> 00:59:18.549
So the ones I want to tell you about are a printf command,

00:59:18.550 --> 00:59:21.519
which is a little report record
formatter that's useful often.

00:59:21.519 --> 00:59:27.219
I want to tell you about convenience variables, because
they're a little subtle, but actually quite useful.

00:59:27.219 --> 00:59:29.179
Some of the logic constructs.

00:59:29.179 --> 00:59:36.119
And finally the define command you can use to take some
sequence of commands you like and can them for reuse.

00:59:36.119 --> 00:59:37.769
There are docks for the GDB.

00:59:37.769 --> 00:59:39.480
You can find them online.

00:59:39.480 --> 00:59:42.119
But they're also part of the Xcode help.

00:59:42.119 --> 00:59:45.619
They're a little hard to find in the Xcode
help, and they keep moving them around.

00:59:45.619 --> 00:59:50.539
So the best way to find them is basically to
go to the Xcode help menu, search for GDB,

00:59:50.539 --> 00:59:53.840
and then you want the document called "Debugging with GDB."

00:59:53.840 --> 00:59:57.410
So the printf command, this is just simple.

00:59:57.409 --> 01:00:00.119
It's just basically the C printf
command without parenthesis.

01:00:00.119 --> 01:00:02.380
It's the same format as the C printf.

01:00:02.380 --> 01:00:06.930
The only thing about it is that it's done by GDB,
so we're not allocating memory in your program,

01:00:06.929 --> 01:00:09.759
we're not writing to your program
standard out or anything like that.

01:00:09.760 --> 01:00:13.460
As I say, it just looks exactly like
the C printf, except no parenthesis.

01:00:13.460 --> 01:00:15.730
And the parenthesis out, but just you'd expect.

01:00:15.730 --> 01:00:20.240
That's just useful, because as you make your own commands
sometimes you want to make a little report record.

01:00:20.239 --> 01:00:22.339
And this is the way that you do that.

01:00:22.340 --> 01:00:24.320
More importantly are these convenience variables.

01:00:24.320 --> 01:00:26.900
So they're the variables that begin with a dollar sign.

01:00:26.900 --> 01:00:32.119
You define them with the set command, so I would
say for instance, set dollar temp is something,

01:00:32.119 --> 01:00:38.069
so here I have an integer, but I want to see what it
looks like as a long long, so I cast it as a long long.

01:00:38.070 --> 01:00:45.220
The value and the type of the variable you've made
actually do come from the expression that you assign it to.

01:00:45.219 --> 01:00:48.769
So for instance say the ptype command in
GDB that prints the type of the command,

01:00:48.769 --> 01:00:51.139
and it really is a long long, I didn't lie to you.

01:00:51.139 --> 01:00:57.009
And finally, once you've made them they work
everywhere in GDB the same way as program variables,

01:00:57.010 --> 01:01:01.120
so I can pass it to my printf, or I can,
you know, do addition, or subtraction,

01:01:01.119 --> 01:01:03.039
or do referencing, or whatever with them.

01:01:03.039 --> 01:01:05.070
So that's the result of that, whatever.

01:01:05.070 --> 01:01:08.220
GDB makes some for you, and this is
where it gets kind of interesting,

01:01:08.219 --> 01:01:10.239
actually going back it's kind of boring at first.

01:01:10.239 --> 01:01:16.169
But GDB uses convenience variables for the registers, so
you've seen that if you want to type the machine registers.

01:01:16.170 --> 01:01:18.650
They're dollar and then the name of the register.

01:01:18.650 --> 01:01:24.030
And there's some synthetic ones, like $pc
will always be the program counter and so on.

01:01:24.030 --> 01:01:29.620
But more interestingly when you do the print command
in GDB, which is your general way of printing the value

01:01:29.619 --> 01:01:32.739
of something, it makes a convenience
variable for the result,

01:01:32.739 --> 01:01:35.669
which is called dollar sign and
then some incrementing number.

01:01:35.670 --> 01:01:39.039
So maybe you've done this before, you
say print something in the console,

01:01:39.039 --> 01:01:43.130
and you get this noise over on the left hand side,
and then the thing you're really looking for.

01:01:43.130 --> 01:01:46.500
But what I want to say is, that's not quite
noise, because you can actually use that.

01:01:46.500 --> 01:01:49.539
So for instance if I printed my struct
and then I wanted to deference it,

01:01:49.539 --> 01:01:53.800
I don't have to print my struct again,
I can just say print $1 goes to pointer.

01:01:53.800 --> 01:01:57.300
And as you're digging down further and
further that can save you a lot of typing.

01:01:57.300 --> 01:02:01.690
Because, for instance now when I went
$1 goes to point of that made $2.

01:02:01.690 --> 01:02:04.750
So I could then say print $2 goes to something else.

01:02:04.750 --> 01:02:08.469
Or if I wanted to deference it, say
print *$2 or something like that.

01:02:08.469 --> 01:02:15.029
But it's even easier than that, because I can say the
dollar sign itself is the last variable that was made.

01:02:15.030 --> 01:02:16.720
So I could just say print *$.

01:02:16.719 --> 01:02:19.629
So you can just save yourself a lot of typing that way.

01:02:19.630 --> 01:02:22.070
OK, so the last thing is the define command.

01:02:22.070 --> 01:02:25.539
So this defines procedures for reuse.

01:02:25.539 --> 01:02:32.590
The arguments, it does take arguments, they're passing
$arg1, $arg2, such, so on and so forth-- zero, 1, 2, rather.

01:02:32.590 --> 01:02:34.769
And the number is passed in $argC.

01:02:34.769 --> 01:02:38.409
With the document command you can use to
document them so you don't forget what they do.

01:02:38.409 --> 01:02:44.670
Help user will show you all the ones that you've defined
when you actually do forget them, which you probably will.

01:02:44.670 --> 01:02:49.500
And then finally-- and the first line of
your documentation also shows up there.

01:02:49.500 --> 01:02:53.610
And finally, help command name for the command
you define will show you this whole documentation.

01:02:53.610 --> 01:03:00.160
If you put a command in your-- a file called .GDBinit
in your home directory it gets loaded at startup.

01:03:00.159 --> 01:03:04.309
Or you can say source and that
will source in a file of commands.

01:03:04.309 --> 01:03:06.690
So let me finish up with a little example.

01:03:06.690 --> 01:03:12.800
So here's, you know, one of these typical jobs,
which is a real pain in the neck and a GUI debugger.

01:03:12.800 --> 01:03:16.000
And suppose I have a link list, this is the
standard link list, right I have a structure

01:03:16.000 --> 01:03:17.769
that has a pointer to itself and then some data.

01:03:17.769 --> 01:03:19.759
And I have 500 of them.

01:03:19.760 --> 01:03:21.880
And I want to find some of the elements out of them.

01:03:21.880 --> 01:03:25.450
Now in a GUI debugger what you're going to do is turn
down, turn down, turn down, scroll to the right, turn down,

01:03:25.449 --> 01:03:28.500
turn down turn down, scroll to the
right, and you'll end up going crazy.

01:03:28.500 --> 01:03:32.369
But this is the type of task that's perfect for the console.

01:03:32.369 --> 01:03:37.009
So our task is to dump the elements matching
some input value, make it into a user command.

01:03:37.010 --> 01:03:42.280
The first argument will be the list head,
so this is my list head in this example.

01:03:42.280 --> 01:03:45.370
And the second example is the match value.

01:03:45.369 --> 01:03:47.019
So here's how it works.

01:03:47.019 --> 01:03:52.570
Define, you say, define; you say the name of the
command you're defining, and then you end it with end.

01:03:52.570 --> 01:03:54.660
So that's the bits in yellow.

01:03:54.659 --> 01:03:59.589
Then I have my arguments, as I
said they come in in $arg0, $arg1.

01:03:59.590 --> 01:04:03.300
There's a while, which is just a simple,
you know, it takes an expression,

01:04:03.300 --> 01:04:06.350
it keeps going as long as the expression's
true kind of things.

01:04:06.349 --> 01:04:08.929
So here's, that I'm using to iterate through the elements.

01:04:08.929 --> 01:04:11.980
And the only thing is you got to remember
to increment your element counter.

01:04:11.980 --> 01:04:16.139
You'll do-- you forget to do this like the first
five times, and then it won't do anything to print

01:04:16.139 --> 01:04:18.849
out the first element over and over again.

01:04:18.849 --> 01:04:19.730
And like ugh!

01:04:19.730 --> 01:04:20.809
So, anyway, whatever.

01:04:20.809 --> 01:04:24.460
And then finally there's a simple if, again,
it's basically if and then some predicate.

01:04:24.460 --> 01:04:29.990
And if the predicates true, there's an else, but
there's no else because we're not C after all.

01:04:29.989 --> 01:04:32.819
And then finally I get to the meat
of it what I'm going to do.

01:04:32.820 --> 01:04:35.760
I told you there's this nice little
report printer, the printf thing.

01:04:35.760 --> 01:04:37.640
So I'm using my little report printer.

01:04:37.639 --> 01:04:43.989
But then it's also really useful to print the actual
element when you're going through a structure,

01:04:43.989 --> 01:04:48.759
because that print command is going to contain--
is going to create a convenience variable for you.

01:04:48.760 --> 01:04:54.580
And then as you look through your report, when the report
shows you that the one 500 elements down is the one

01:04:54.579 --> 01:04:58.170
that you're actually interested in, you don't have
to go back up and go next, next, next, next, next,

01:04:58.170 --> 01:04:59.369
next, next, next to get down to it, right?

01:04:59.369 --> 01:05:01.900
You just print the convenience variable.

01:05:01.900 --> 01:05:06.070
Remember to document it, because I assure
you you'll will forget what they do.

01:05:06.070 --> 01:05:08.140
And so here's just an example of running it.

01:05:08.139 --> 01:05:11.750
First of all I asked for the help, because
otherwise I'd forget how to use it.

01:05:11.750 --> 01:05:15.610
And then actually use it, and it's going to print stuff out.

01:05:15.610 --> 01:05:22.510
And then like if the second one's the one I'm interested
in, now I can say print *$22 and that prints me that stuff.

01:05:22.510 --> 01:05:25.690
So, that's just how to use that example.

01:05:25.690 --> 01:05:32.230
So in summary what we did was, we showed you some wonderful
new Xcode features, learned how to use the data formatters,

01:05:32.230 --> 01:05:36.889
which again, just go play with them, because you need to
get them under your fingers, but then they're really useful.

01:05:36.889 --> 01:05:41.799
Showed you a little bit how to handle the forest
of threads, which you're going to be facing.

01:05:41.800 --> 01:05:45.160
And finally a little brief intro
into the GDB command language.

01:05:45.159 --> 01:05:50.989
If you want more information, Michael
Jurewitz is the, the Dev Tools Evangelist.

01:05:50.989 --> 01:05:53.729
So email him and he'll get it to us.

01:05:53.730 --> 01:05:59.130
There is this debugging with GDB documentation, and then
there's a whole debugging section in the Xcode help.

01:05:59.130 --> 01:05:59.250
1
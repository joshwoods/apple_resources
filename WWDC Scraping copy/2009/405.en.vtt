WEBVTT

00:00:12.689 --> 00:00:15.239
>> Tom: Welcome to Java in Snow Leopard.

00:00:15.240 --> 00:00:22.120
I'm Tom O'Brien, the Manager of Java Engineering at Apple
and this is the only session between you and the party,

00:00:22.120 --> 00:00:24.429
but stick around until the end
because I know you're going to want

00:00:24.429 --> 00:00:29.550
to hear the great things we have to
tell you about Java in Snow Leopard.

00:00:29.550 --> 00:00:34.759
If you've chosen to be in the room today you're
probably already an experienced Java developer

00:00:34.759 --> 00:00:40.809
and you may have been developing your code on other
platforms or deploying it to customers who run

00:00:40.810 --> 00:00:46.310
on other platforms and you're not really familiar
with Mac OS X and you want to know what Snow Leopard

00:00:46.310 --> 00:00:52.500
and Mac OS X brings to you as Java developers
and what it means for your customers.

00:00:52.500 --> 00:00:59.189
Or you may have been developing in Java on Mac OS X for
a while now and you really want to hear about what's new

00:00:59.189 --> 00:01:04.700
in Snow Leopard that'll give you even
more power in your development process

00:01:04.700 --> 00:01:07.630
and more power for your customers' applications.

00:01:07.629 --> 00:01:13.509
You could be bringing your code to
your customers in 1 of at least 3 ways.

00:01:13.510 --> 00:01:21.550
You could be shipping double clickable applications for
mathematical modeling, for graphical sequence analysis,

00:01:21.549 --> 00:01:27.969
for other custom-tailored solutions for research
communities or for in-house applications.

00:01:27.969 --> 00:01:35.840
Or you might be getting your code out over the Web as an
applet in the Web browser or as a Web Start application

00:01:35.840 --> 00:01:47.230
or some other kind of downloadable content for financial
analysis for online communities or for great online games.

00:01:47.230 --> 00:01:54.290
Or maybe you spend your day writing server-side code,
crafting thousands of lines of code to deploy on clusters

00:01:54.290 --> 00:02:00.940
of hundreds of servers processing hundreds of thousands of
transactions a minute where the performance and reliability

00:02:00.939 --> 00:02:04.039
of your code is essential to your business.

00:02:04.040 --> 00:02:10.430
No matter how you get your code out there you're
probably using one of the great development tools,

00:02:10.430 --> 00:02:18.250
IDE's and other development tools for Java that run
on Mac OS X and allow you to build, test, debug,

00:02:18.250 --> 00:02:23.210
package and deploy your application
and get it out to your customers.

00:02:25.210 --> 00:02:29.280
The great news for you as Java developers on Mac OS X is

00:02:29.280 --> 00:02:33.219
that you can harness the power
of all of those processor cores.

00:02:33.219 --> 00:02:41.969
You can leverage the great advances you've been hearing
about in 64-bit Snow Leopard from your Java code.

00:02:41.969 --> 00:02:49.719
In fact, the Java frameworks on Mac OS X were some of the
first frameworks that were 64-bit enabled in Mac OS X back

00:02:49.719 --> 00:02:56.849
in Leopard, so we've been bringing you the power
of the 64-bit address space and 64-bit performance

00:02:56.849 --> 00:03:02.739
for some time now, but in Snow Leopard
we're making things even better.

00:03:02.740 --> 00:03:09.030
We on the Java Team have been working for over a year and a
half to bring you an even better Java implementation for you

00:03:09.030 --> 00:03:15.229
and your customers, higher performance, more
compatibility and more stability for your applications,

00:03:15.229 --> 00:03:17.679
and we're going to be telling you more about that today.

00:03:17.680 --> 00:03:21.069
Here's the things we're going to be covering in this talk.

00:03:21.069 --> 00:03:26.840
First, especially for those of you who are new to the
platform, we're going to give you a quick overview

00:03:26.840 --> 00:03:34.450
of how Java fits into Mac OS X and then we're going to
move on to some of the new features in Snow Leopard.

00:03:34.449 --> 00:03:39.049
We'll bring you up to date on performance advances
for Java in Snow Leopard and give you some tips

00:03:39.050 --> 00:03:42.790
for getting even more performance out of your applications.

00:03:42.789 --> 00:03:49.250
We'll also give you more tips for bundling your
applications to take advantage of 64-bit and enhancing them

00:03:49.250 --> 00:03:52.360
to take advantage of other features in the operating system.

00:03:52.360 --> 00:03:55.730
And we'll also give an update on the SWT/Cocoa initiative

00:03:55.729 --> 00:04:03.679
as the Eclipse Foundation moves SWT
forward into the future of Mac OS X.

00:04:03.680 --> 00:04:07.840
Let's start with our overview of Java on Mac OS X.

00:04:07.840 --> 00:04:12.719
There are 2 main things you need to know
about Java on Mac OS X and the first is

00:04:12.719 --> 00:04:14.949
that Java is part of the operating system.

00:04:14.949 --> 00:04:19.539
Since the very first version of Mac OS
X, Java has been bundled with the OS

00:04:19.540 --> 00:04:22.730
and ships with every copy of the operating system.

00:04:22.730 --> 00:04:25.610
This is different from some other platforms.

00:04:25.610 --> 00:04:31.819
And as Java developers it's important because you don't need
to ship your own copy of the JRE along with your application

00:04:31.819 --> 00:04:37.019
because your customers already have a JRE on their
system because it's built into the operating system.

00:04:37.019 --> 00:04:42.359
As a core feature of Mac OS X it's
available in all the deployment modes

00:04:42.360 --> 00:04:45.810
that you're expecting out of a Java framework.

00:04:45.810 --> 00:04:53.139
It's available for the Web browser, for Web Start
applications, as double-clickable applications

00:04:53.139 --> 00:04:57.370
on the desktop and for command line and server code.

00:04:57.370 --> 00:05:03.530
But beyond just integrating into the OS and taking
care of the essentials like making sure the Aqua look

00:05:03.529 --> 00:05:09.789
and feel is applied to your Java code so that it
looks like the other applications on the platform.

00:05:09.790 --> 00:05:11.970
We also let you go beyond that.

00:05:11.970 --> 00:05:17.060
For example, using things like custom Swing
client properties, you can add extra polish

00:05:17.060 --> 00:05:23.069
to your user interface elements and still keep
your code cross-platform so the same code runs

00:05:23.069 --> 00:05:27.509
on all platforms you deploy to but
it looks especially good on Mac OS X

00:05:27.509 --> 00:05:32.579
and really looks like it's part of the operating system.

00:05:32.579 --> 00:05:38.519
You also get the power of the Mac OS X font
system in addition to the built-in font support.

00:05:38.519 --> 00:05:45.699
We give you more tools for letting you build
double-clickable applications for your application

00:05:45.699 --> 00:05:51.009
so your applications can sit side by side
with other apps on your customers' desktops.

00:05:51.009 --> 00:05:55.219
And even more features like dock
integration, menu bar integration

00:05:55.220 --> 00:06:01.240
and AppleScript support lets your applications interact
with the other applications on your customers' systems

00:06:01.240 --> 00:06:07.430
so that they really bring them what
they expect out of an app on Mac OS X.

00:06:07.430 --> 00:06:12.480
The second thing you need to know about
Java on Mac OS X is that at any time

00:06:12.480 --> 00:06:18.180
in any one era there's one preferred
version of Java on a version of Mac OS X.

00:06:18.180 --> 00:06:24.829
We refocused our efforts for the best compatibility
and the enhancements for Java and the operating system

00:06:24.829 --> 00:06:30.759
to make it the best experience for your
customers and the focus of your development.

00:06:30.759 --> 00:06:36.120
There may be multiple versions of Java present
on a particular Mac OS X version at some times

00:06:36.120 --> 00:06:41.600
but we really focus our attention on one as the
preferred version that we expect the vast majority

00:06:41.600 --> 00:06:45.970
of the customer base to be running on that operating system.

00:06:45.970 --> 00:06:53.220
As advances in Java and advances in the OS move
forward, this preferred version has changed

00:06:53.220 --> 00:06:55.960
with each successive version of Mac OS X.

00:06:55.959 --> 00:07:02.789
But let's take a closer look at the versions
that are available on Mac OS X 10.5 Leopard.

00:07:02.790 --> 00:07:11.540
First, there's Java 1.42, which is present solely as a
legacy transition strategy for any remaining applications

00:07:11.540 --> 00:07:17.740
that you might have that depended on 1.42 but
needed to move forward to newer versions of Java,

00:07:17.740 --> 00:07:22.040
and we expected it to go away as a
deprecated version, we expected it to go away

00:07:22.040 --> 00:07:25.240
in the next version of the operating system.

00:07:25.240 --> 00:07:35.079
Second, we have Java 1.5, which is the preferred Java
version on Leopard and is the one that we focused most

00:07:35.079 --> 00:07:40.529
of our attention on for Leopard to make
it the best for you and your customers.

00:07:40.529 --> 00:07:49.449
We also had a version of Java 1.6 which was available for
Intel 64-bit but was essentially for you as developers

00:07:49.449 --> 00:07:55.579
to move forward to the new versions of Java
and start testing your applications with 1.6.

00:07:55.579 --> 00:08:01.169
But, again, we were focusing on Java
1.5 on Leopard as the preferred version,

00:08:01.170 --> 00:08:05.520
as the most compatible version for the customer base.

00:08:05.519 --> 00:08:08.859
Let's see how this landscape changes
as we move forward to Snow Leopard.

00:08:08.860 --> 00:08:15.860
First, as I suggested before, Java 1.42 goes away
on Snow Leopard because it was deprecated in Leopard

00:08:15.860 --> 00:08:18.569
and it's no longer present in Snow Leopard.

00:08:18.569 --> 00:08:23.659
Second, we're also removing Java 1.5
because we've been focusing our attention

00:08:23.660 --> 00:08:30.930
on making Java 6 a great high-performance VM
for you on Snow Leopard and for your customers

00:08:30.930 --> 00:08:39.480
and we're making it the preferred Java version on 10.6 in
Snow Leopard and we're making it available for both Intel 32

00:08:39.480 --> 00:08:45.019
and 64-bit hardware to match the
hardware supported for Snow Leopard.

00:08:45.019 --> 00:08:49.370
We think it's a great implementation and we're going
to be telling you a lot more about it in a few minutes.

00:08:49.370 --> 00:08:54.429
Here's a couple of the highlights
of Java in Snow Leopard beyond that.

00:08:54.429 --> 00:09:00.689
First we've got this great Java implementation, we've
got a new high-performance Java 6 virtual machine

00:09:00.690 --> 00:09:08.100
and we have new tools for you to profile and debug your
applications so that you can get the best out of the power

00:09:08.100 --> 00:09:12.610
that Snow Leopard brings you and that we're
bringing you through Java 6 in Snow Leopard.

00:09:12.610 --> 00:09:17.879
But there's a whole lot more and I'd like to bring
up Mike Swingler who's the Lead Java Runtime Engineer

00:09:17.879 --> 00:09:21.080
to start telling you about what's
new for Java in Snow Leopard.

00:09:21.080 --> 00:09:27.250
>> Mike: So, today there's actually 3 very exciting things
that we want to tell you today about what's in Snow Leopard

00:09:27.250 --> 00:09:30.360
that we think you're going to be real excited about.

00:09:30.360 --> 00:09:39.409
First of all is a change in how we choose the
architecture for your bundled applications,

00:09:39.409 --> 00:09:43.209
which will be very important for
you to take advantage of 64-bit.

00:09:43.210 --> 00:09:48.330
Second, we're going to show you a developer
preview that we have of the out of process plug-in

00:09:48.330 --> 00:09:51.590
that you actually have on your Snow Leopard disk here today.

00:09:51.590 --> 00:09:56.740
And third, we're going to show you a great tool
that we've integrated from Sun called Visual VM

00:09:56.740 --> 00:10:02.840
which actually allows you to introspect inside your
application and really see in-depth of what's going on

00:10:02.840 --> 00:10:07.490
and will really help you debug and
analyze the performance of your app,

00:10:07.490 --> 00:10:09.830
and so we're going to show you that later today.

00:10:09.830 --> 00:10:13.259
So let's get started.

00:10:13.259 --> 00:10:20.490
So, first of all, the JavaApplicationStub is actually
the heart of a bundled Java application on Mac OS X.

00:10:20.490 --> 00:10:25.200
It's a little piece of MoCo binary that links
to the Java application launching framework

00:10:25.200 --> 00:10:30.129
and it actually kicks off Java and
instantiates the VM for your app.

00:10:30.129 --> 00:10:39.129
And the policy that we've had on Snow Leopard so far has
been if you go into Java Preferences and you drag, say,

00:10:39.129 --> 00:10:43.210
Java 6 up to the top or 1.5 64-bit, we're actually --

00:10:43.210 --> 00:10:49.990
we took all bundled applications and launched them in
that 64-bit VM, and when we were developing Snow Leopard

00:10:49.990 --> 00:10:57.070
and we moved 64-bit Java 6 up to the top of that list
because Snow Leopard is a 64-bit OS throdugh and through,

00:10:57.070 --> 00:11:01.350
we realized that there were some applications
that were actually not ready for that transition,

00:11:01.350 --> 00:11:06.580
so what we did was we actually decided to change
the policy for how applications are launched

00:11:06.580 --> 00:11:11.670
and we actually already had a pre-existing
model for how this should work.

00:11:11.669 --> 00:11:18.649
What we're doing now is we're taking whatever
architecture you have present in your JavaApplicationStub

00:11:18.649 --> 00:11:20.769
and if it's there we'll launch you in it.

00:11:20.769 --> 00:11:24.329
If you don't have an architecture present
in the stub we won't launch you in it.

00:11:24.330 --> 00:11:32.470
And so this is actually a policy that we're even
back-porting to Leopard with Java for Mac OS X Update 4.

00:11:32.470 --> 00:11:40.100
So if you need to have a specific architecture or you
require a specific architecture like x86_64 you should,

00:11:40.100 --> 00:11:46.440
you know, or if you can't launch in 64-bit
you should lipo out that architecture

00:11:46.440 --> 00:11:48.720
in your stub when you bundle your application.

00:11:48.720 --> 00:11:55.550
And, also, if you prefer a particular architecture
you should use the LSArchitecturePriority bit so that

00:11:55.549 --> 00:12:03.990
in the Get Info window now when you check the Open in
32-bit Mode check-box it will actually do something

00:12:03.990 --> 00:12:11.379
or it'll be checked for you by default if you set the
LSArchitecturePriority to Bias i386 up to the top.

00:12:11.379 --> 00:12:15.189
So why do you want to bundle an
application in the first place?

00:12:15.190 --> 00:12:23.090
Well, bundling your app gives you a lot of really native
behaviors that users come to expect out of Mac OS X apps.

00:12:23.090 --> 00:12:29.430
If you launch your Java application from a shell script
and then it kicks the AWT and then a dock icon materializes

00:12:29.429 --> 00:12:36.339
after that and the user takes that dock icon and
drags it to a more permanent location in their dock,

00:12:36.340 --> 00:12:44.620
it's not going to persist around for them, but if you
have an actual bundle for your app, what it will do --

00:12:44.620 --> 00:12:50.570
if it has a real CFBundleIdentifier the dock will actually
be able to persist that there and reference on disk

00:12:50.570 --> 00:12:56.430
where your application is actually residing, so
there's a lot of things that actually key off

00:12:56.429 --> 00:13:02.299
of having a CFBundleIdentifier
associated with your bundled application.

00:13:02.299 --> 00:13:09.299
Things like spaces and the firewall and the Run at
32-bit check-box all depend on having this identifier

00:13:09.299 --> 00:13:14.439
for your applications so that the rest of Mac OS
X, the way, you know, how Apple events are sent

00:13:14.440 --> 00:13:18.550
and all of this, they know how to refer to your app.

00:13:18.549 --> 00:13:24.049
And, also, if you deploy your application with Web Start
and you create a desktop shortcut we'll actually create one

00:13:24.049 --> 00:13:26.729
of these bundled apps for you automatically.

00:13:28.009 --> 00:13:33.450
So the second thing we'd like to talk to you
about today is the Java Out of Process Plug-in;

00:13:33.450 --> 00:13:38.129
this is something we've been working very
hard with on Sun and last year if you came

00:13:38.129 --> 00:13:41.179
to the session you saw a great demo of it.

00:13:41.179 --> 00:13:47.379
This plug-in is really at the cutting edge of technology
and is really pushing the limits of browser technology

00:13:47.379 --> 00:13:54.610
so you need to install Safari 4 on Leopard if you want to
be able to use this or use the latest betas of Firefox 3.5

00:13:54.610 --> 00:13:59.100
with the Java embedding plug-in
actually disabled from Firefox.

00:13:59.100 --> 00:14:05.830
So running Java applets in a separate process
not only gives you great stability and security

00:14:05.830 --> 00:14:11.190
and keeps the 2 processes isolated so, you know, if
something goes wrong in one it doesn't impact the other.

00:14:11.190 --> 00:14:18.680
But we think this really offers a great new model
for whole new kinds of applications to be developed,

00:14:18.679 --> 00:14:21.829
like a sort of try-as-you-buy feature almost.

00:14:21.830 --> 00:14:25.690
If you have an applet running in a browser --

00:14:25.690 --> 00:14:32.240
since the applet is actually running in a separate process
you can actually take the applet and pull it outside

00:14:32.240 --> 00:14:38.860
of the browser and since it's a separate process you can
close the browser window or even quit the browser entirely

00:14:38.860 --> 00:14:45.350
and your applet will still keep running, and this way your
applet is really not all that different from an application.

00:14:45.350 --> 00:14:51.139
And so the model kind of moving forward
using the Out of Process Plug-in is

00:14:51.139 --> 00:14:57.269
to deploy your application or deploy your applet as a JNLP.

00:14:57.269 --> 00:15:04.850
So for right now the Out of Process Plug-in is still a
developer feature but we hope to enable it fairly soon.

00:15:04.850 --> 00:15:10.810
So JNLP's are the basic building
block that applets and applications

00:15:10.809 --> 00:15:14.939
and the shared libraries that they
all depend on are built on.

00:15:14.940 --> 00:15:19.360
The JNLP has a great way to describe
all of the subdependencies

00:15:19.360 --> 00:15:22.509
and download all the components that you need on demand.

00:15:22.509 --> 00:15:27.159
So if you're deploying an application
that actually needs to escape

00:15:27.159 --> 00:15:32.219
out of the standard Java sandbox you should
also sign your JNLP's as well; this is --

00:15:32.220 --> 00:15:40.240
when you have your JNLP hosted on your Web server you need
a copy of that also inside of your jar and then you have

00:15:40.240 --> 00:15:46.320
to sign the jar and so the actual byte for byte
representation of the JNLP's inside the jar and outside have

00:15:46.320 --> 00:15:51.470
to match exactly, so that's something you'd want
to keep in mind if you deploy using Web Start

00:15:51.470 --> 00:15:55.340
or the Out of Process Plug-in and
you need to sign your JNLP's.

00:15:55.340 --> 00:16:04.639
So the third thing that we'd like to show you today is
the visual VM tool which we think is really exciting

00:16:04.639 --> 00:16:13.100
and it does a lot of very interesting performance
analysis and both take stack dumps and heap dumps

00:16:13.100 --> 00:16:17.320
and I'd like to invite Bino George
on stage to show it to us.

00:16:17.320 --> 00:16:21.870
>> Bino: So I've written a photoview
application and my users are complaining

00:16:21.870 --> 00:16:24.090
that there's a memory leak in my application.

00:16:24.090 --> 00:16:27.800
So, basically, what I can do -- let me
try to produce a [inaudible] right now.

00:16:27.799 --> 00:16:34.379
So I can open an image by clicking
on it and look at it in detail.

00:16:34.379 --> 00:16:41.269
And, basically, at the bottom of this application
there's a little information bar and if I click

00:16:41.269 --> 00:16:49.029
on it I get more information about the image, so as I move
around I can get more information about the image's sizes

00:16:49.029 --> 00:16:55.389
and their part and everything else, and,
voila, there's my Auto Memory exception.

00:16:55.389 --> 00:17:01.669
So we know that we replace the problem
and let's try to debug this in VisualVM.

00:17:01.669 --> 00:17:07.190
So I'm going to quit that, go back
into -- so how do you start VisualVM?

00:17:07.190 --> 00:17:09.920
So you open up the terminal and you type JVisualVM.

00:17:09.920 --> 00:17:16.009
So I'm going to restart my application in Eclipse and --

00:17:16.009 --> 00:17:21.049
[ Background noise ]

00:17:21.049 --> 00:17:29.419
>> Bino: Connect to -- so I'm going to connect to it
from JVisualVM and one thing you notice in this list

00:17:29.420 --> 00:17:34.650
of applications, you see 3 applications here, you
see the VisualVM itself because it's a Java app

00:17:34.650 --> 00:17:40.040
and then you see this unknown application that
is actually Eclipse and you see my photoview.

00:17:40.039 --> 00:17:46.740
So I've now connected to the application and since
I need more space I'll close this application panel

00:17:46.740 --> 00:17:53.009
and go into the monitor window and I'm going to -- there's
a lot of information here so let me just hide some of this

00:17:53.009 --> 00:17:57.529
and focus on the thing that we need to
know most importantly and that's the heap.

00:17:57.529 --> 00:18:03.230
So as you -- so let's look at the heap,
how it behaves as we use the application.

00:18:03.230 --> 00:18:13.829
So if I open an image you can see that the heap goes up
and as I close it it should go down ideally and it looks

00:18:13.829 --> 00:18:21.119
like it does change as I -- it does go back
down so that doesn't seem to be a leak.

00:18:21.119 --> 00:18:29.000
So let's look at the information about the image and
notice my heap is growing, so there's something funny going

00:18:29.000 --> 00:18:31.490
on there, and suddenly I hit my Auto Memory exception.

00:18:31.490 --> 00:18:38.009
So let's take a heap dump; this is
something very useful in VisualVM and --

00:18:38.009 --> 00:18:42.730
[ Background noise ]

00:18:42.730 --> 00:18:45.380
>> Bino: So once it comes up you can see the list of --

00:18:45.380 --> 00:18:54.330
there's a list of objects and you can sort it
by size to find out what's the big culprit.

00:18:54.329 --> 00:19:00.179
And notice I have a lot of byte areas here so
I can double-click on it and go into detail

00:19:00.180 --> 00:19:06.740
and look at the references who is referring to
these areas and I'm going to expand this out

00:19:06.740 --> 00:19:12.819
and notice it's being referred to by my code called
My Image Detail and this is kind of suspicious

00:19:12.819 --> 00:19:18.939
because I didn't really expect there to be a
reference from My Image Detail and it looks

00:19:18.940 --> 00:19:22.880
like the instance field is called My
Image so let's see if this is really true.

00:19:22.880 --> 00:19:26.730
We'll go back in the ID and look at My Image Detail

00:19:26.730 --> 00:19:32.009
and surely enough there's an instance field here
called My Image and let's see who is using this.

00:19:32.009 --> 00:19:37.539
[ Background noise ]

00:19:37.539 --> 00:19:44.599
>> Bino: Find references and it looks like
I have 2 instances where it's getting used.

00:19:44.599 --> 00:19:48.089
The first instance is here and it looks
like I'm using the Instance Field here

00:19:48.089 --> 00:19:50.000
and I didn't really mean to use Instance Field.

00:19:50.000 --> 00:19:53.009
This should be a local variable here so I'm
going to change this to a local variable.

00:19:53.009 --> 00:19:57.609
[ Background noise ]

00:19:57.609 --> 00:20:03.959
>> Bino: And I'm going to change the second instance
usage also here and comment this out, I don't need this.

00:20:03.960 --> 00:20:07.490
It's probably because I'm using Eclipse's
Auto-Completion and it just, you know,

00:20:07.490 --> 00:20:10.950
I had this Instance Field lying around so it used it.

00:20:10.950 --> 00:20:13.910
So let's see if this fixed the problem.

00:20:13.910 --> 00:20:25.850
We'll restart this, I'm going to close the old
connection, go back in here and reconnect to it

00:20:25.849 --> 00:20:28.980
and in this case I was able to produce
the problem myself but there are times

00:20:28.980 --> 00:20:33.620
when you can't reproduce the problem your customers can
reproduce it but you can't, your users can produce it.

00:20:33.619 --> 00:20:36.079
And so what you can do is you can ask them to do --

00:20:36.079 --> 00:20:40.490
they can run VisualVM themself and
they can do an application snapshot

00:20:40.490 --> 00:20:46.470
and what that does is it basically packages up everything
that VisualVM knows about the application and into a file.

00:20:46.470 --> 00:20:53.370
He can then email it to you and then you can look at it
in detail just like you would do -- just like I just did.

00:20:53.369 --> 00:20:58.759
So let's look at the -- let's connect to it again --

00:20:58.759 --> 00:21:05.099
I forgot to connect to it -- and
let's see if my leak is gone now.

00:21:08.910 --> 00:21:11.009
I didn't click properly.

00:21:11.009 --> 00:21:16.690
[ Background noise ]

00:21:16.690 --> 00:21:21.059
>> Bino: So as I mentioned, there are more
debugging features and basically being able

00:21:21.059 --> 00:21:24.089
to get snapshots from customers is very useful.

00:21:24.089 --> 00:21:33.619
So I'm going to go back to the Monitor tab and close this
and let's look at the heap again as I use the application.

00:21:33.619 --> 00:21:39.769
And now as I click around I can see the heap is moving

00:21:39.769 --> 00:21:43.440
but basically the memory usage is
going back down and that's a good sign.

00:21:43.440 --> 00:21:47.519
It's not growing and I don't see the leak.

00:21:50.859 --> 00:21:54.490
So it looks like I fixed the problem.

00:21:54.490 --> 00:21:58.710
There's a lot more things that you can
do with VisualVM so one of the things

00:21:58.710 --> 00:22:04.009
that you can do with VisualVM is live -- actually --

00:22:04.009 --> 00:22:10.269
[ Background noise ]

00:22:10.269 --> 00:22:14.700
>> Bino: Live CPU and memory profiling
and so you can actually --

00:22:14.700 --> 00:22:21.730
VisualVM will instrument the application and at one
time basically give you CPU and memory profiling.

00:22:21.730 --> 00:22:26.110
Also, VisualVM is very extensible so you can -- there are a
lot of plug-ins out there that people have written for it.

00:22:26.109 --> 00:22:32.559
For example, you can use VisualGC to find more information
about garbage collectors in detail and how they behave.

00:22:32.559 --> 00:22:39.539
Also, there's more information, you know, there are plug-ins
that target certain servers like GlassFish and to talk more

00:22:39.539 --> 00:22:42.960
about performance here's Pratik
Solanki who works on the Java VM.

00:22:42.960 --> 00:22:44.620
>> Pratik: Thank you Bino.

00:22:44.619 --> 00:22:45.469
Good afternoon everyone.

00:22:45.470 --> 00:22:46.600
My name is Pratik Solanki.

00:22:46.599 --> 00:22:51.409
I work on the Hotspot Team here at Apple and
today I'm going to talk to you about performance.

00:22:51.410 --> 00:22:56.070
Specifically we're going to discuss performance
of Mac OS X Server and Mac OS X Client.

00:22:56.069 --> 00:22:58.950
We're going to look at how performance
changes through in Leopard and Snow Leopard.

00:22:58.950 --> 00:23:05.140
I'm going to call up some of the new VM flags that we've
introduced in Snow Leopard and look over some of the changes

00:23:05.140 --> 00:23:09.220
that we've made in Hotspot, so let's look at them.

00:23:09.220 --> 00:23:12.539
First, let's take a look at Mac OS X's server.

00:23:12.539 --> 00:23:16.680
If you're a Java developer deploying your
server app on our, you know, new --

00:23:16.680 --> 00:23:23.700
on our Intel Xeon X serves and you deeply care about
performance then you're likely already using Java 6,

00:23:23.700 --> 00:23:27.240
because Java 6 on Leopard gives
you the best performance right now.

00:23:27.240 --> 00:23:31.620
So what can you expect when you
move from Leopard to Snow Leopard?

00:23:31.619 --> 00:23:34.209
Well, we'll take a look at SPECjbb2005.

00:23:34.210 --> 00:23:42.870
SPECjbb is a great, you know, it's a very popular benchmark
for Java Business Logic Measurement and when we looked at it

00:23:42.869 --> 00:23:47.519
and looked at Leopard versus Snow Leopard
we saw that on Snow Leopard you could get

00:23:47.519 --> 00:23:53.829
up to a 19% performance boost just by moving
from 64-bit Java on Leopard to Snow Leopard.

00:23:53.829 --> 00:23:56.589
So how did we get this?

00:23:56.589 --> 00:24:05.750
Well, we get this by -- well, one of the facts that we
use in order to get this high performance is Large Pages.

00:24:05.750 --> 00:24:10.750
You enable Large Pages by passing -XX:+UseLargePages.

00:24:10.750 --> 00:24:15.440
We also have a Large Page Size in Bytes
option which is currently not supported.

00:24:15.440 --> 00:24:25.980
But what this does is it increases the -- it
allocates memory from the kernel using a 2MB page size.

00:24:25.980 --> 00:24:31.650
The default page size, the default virtual
memory page size on Mac OS X is 4KB

00:24:31.650 --> 00:24:35.970
and by passing this option you're
asking Java to allocate your heap

00:24:35.970 --> 00:24:40.140
and other VM structures using a much larger 2MB page size.

00:24:40.140 --> 00:24:48.080
And what that gives you, really, is that it results in -- a
bigger page size results in fewer TLB misses and, you know,

00:24:48.079 --> 00:24:53.970
higher cache hits and for a memory band with
hungry application this can be a great win.

00:24:53.970 --> 00:25:03.559
In fact, we've seen up to a 10% win using this flag on some
of the benchmarks, which is great, so that's UseLargePages.

00:25:03.559 --> 00:25:05.829
Now before you go start enabling it on your, you know,

00:25:05.829 --> 00:25:09.679
Java server application there's some
caveats that you've got to be aware of.

00:25:09.680 --> 00:25:13.100
Well, first of all, UseLargePages only works on K64.

00:25:13.099 --> 00:25:16.429
It only works on the 64-bit kernel.

00:25:16.430 --> 00:25:23.750
Luckily Snow Leopard's server will actually boot into
the 64-bit kernel by default on many of our Mac Pro's

00:25:23.750 --> 00:25:29.180
and Xserves but, you know, when in doubt just
run uname -m on the command line and confirm

00:25:29.180 --> 00:25:33.920
that you're running the 64-bit kernel before you
start, you know, passing the slide down to Java.

00:25:33.920 --> 00:25:40.100
And another thing you've got to be
aware of is it uses wired memory.

00:25:40.099 --> 00:25:47.909
What that means is that the kernel needs
to find a free contiguous physical memory

00:25:47.910 --> 00:25:50.580
to satisfy your allocation request.

00:25:50.579 --> 00:25:56.579
So, you know, our Xserves can go up to like
96GB now so you need to really, you know,

00:25:56.579 --> 00:26:02.539
add a lot of memory to your machines
if you want to start using this flag.

00:26:02.539 --> 00:26:10.279
By default if Java cannot allocate using Large Pages
it'll fall back to a default 4K page allocation.

00:26:10.279 --> 00:26:14.660
And if it's really important that you
get the Large Page feature than you need

00:26:14.660 --> 00:26:20.330
to pass ExitOnLargePageFailure to, you know, fail fast.

00:26:20.329 --> 00:26:26.519
So that was Large Pages in Mac OS X server,
now let's take a look at Mac Os X Client.

00:26:26.519 --> 00:26:29.639
Now, millions of Mac users who are running Leopard

00:26:29.640 --> 00:26:37.100
on the 64-bit-capable machines have their
default Java as Java5 -- as 32-bit Java 1.5.

00:26:37.099 --> 00:26:45.079
So we tried to look at what happens to them when they move
from Leopard to Snow Leopard because they'll be moving

00:26:45.079 --> 00:26:49.159
from a 32-bit Java 1.5 to a 64-bit Java 6.

00:26:49.160 --> 00:26:56.340
And for this we took a look at a popular JVM benchmark and
what we see is across the board we see a massive improvement

00:26:56.339 --> 00:27:03.009
in performance, you know, whether it be image processing
or XML passing or database access or, you know,

00:27:03.009 --> 00:27:10.529
scientific applications, the performance has just
improved dramatically within Leopard and Snow Leopard.

00:27:10.529 --> 00:27:15.099
In fact, even, you know, playing virtual machine's
Start-Up Timer, Java's start-up time has improved.

00:27:15.099 --> 00:27:22.009
And overall we see about a 65% performance
boost within Leopard and Snow Leopard.

00:27:22.009 --> 00:27:26.259
[ Applause ]

00:27:26.259 --> 00:27:30.039
>> Pratik: So let's dig a little into what happened here.

00:27:30.039 --> 00:27:34.970
Well, there are 4 things that changed or 4
transitions that we have made, so to speak.

00:27:34.970 --> 00:27:39.430
You know, first of all, we went from
Leopard to Snow Leopard so, you know,

00:27:39.430 --> 00:27:44.490
all of the work that the Apple engineers have
put into improving the kernel, the frameworks,

00:27:44.490 --> 00:27:48.059
everything we're getting since Java
sits on top of it, we're getting that.

00:27:48.059 --> 00:27:54.210
In fact, you might have heard about LLVM GC at this
conference and, you know, Java is being an earlier adopter

00:27:54.210 --> 00:27:58.700
is actually being compiled with LLVM
GC so that we get that benefit as well.

00:27:58.700 --> 00:28:03.220
The second most important thing
is we moved from Java 5 to Java 6.

00:28:03.220 --> 00:28:05.660
You know Java 6 is the latest VM from Sun.

00:28:05.660 --> 00:28:08.680
You know it's got a lot of performance
improvements, a lot of changes

00:28:08.680 --> 00:28:11.830
and we're bringing all of those
changes to you on Snow Leopard.

00:28:11.829 --> 00:28:18.149
The third important thing is we went from 32-bit to 64-bit.

00:28:18.150 --> 00:28:22.300
The Intel 64-bit architecture actually
has like double the registers

00:28:22.299 --> 00:28:29.200
and so the HotPort VM can actually
create more optimal and much faster code

00:28:29.200 --> 00:28:33.850
when compiling your Java programs
and give you a performance boost.

00:28:33.849 --> 00:28:38.689
And the fourth and final thing is
because of this move from 32-bit

00:28:38.690 --> 00:28:44.340
to 64-bit we are actually moving
from the Client VM to the Server VM.

00:28:44.339 --> 00:28:54.029
Now, we only have the Server VM available in 64-bit and
the Server VM is a much more optimizing and a much --

00:28:54.029 --> 00:29:02.399
it just applies, you know, more optimizing techniques
in order to generate even much faster code for you.

00:29:02.400 --> 00:29:06.700
So let's take a look at this Client VM and Server VM.

00:29:06.700 --> 00:29:13.529
Now, I said that the default is Server VM and Server VM
is great, it's amazing for long-running server processes.

00:29:13.529 --> 00:29:19.609
But then what if you're running a graphical application, a,
you know, simple GUI Java app, what happens, you know, what?

00:29:19.609 --> 00:29:27.919
Well, you don't want the server characteristics and what we
have done is we have tweaked that Server VM to behave more

00:29:27.920 --> 00:29:32.200
like a Client VM so that your GUI
apps launch faster and run faster.

00:29:32.200 --> 00:29:40.610
And one of the things we did was we tweaked the compile
threshold, you know, we tweaked it to be lower when --

00:29:40.609 --> 00:29:47.849
we tweaked it to be lower out of the box and if you are
running, you know, if you're not running graphical apps

00:29:47.849 --> 00:29:53.019
and you're actually running your server applications then
be sure to pass -server so you disable all of those tweaks

00:29:53.019 --> 00:29:58.119
that we made for your Client apps and
you get the server's server defaults.

00:30:00.019 --> 00:30:06.839
Another important change we have done in
Java 6 is we have enabled GC Ergonomics.

00:30:08.009 --> 00:30:14.029
What that means is HotSpot will now pick up
Garbage Collector by default for you based

00:30:14.029 --> 00:30:17.379
on the machine that you're running Java on.

00:30:17.380 --> 00:30:24.490
So on any machine, on any Mac that has at least
2 cores and at least 2GB Ram we will switch

00:30:24.490 --> 00:30:26.450
to the Concurrent Mark and Sweep Garbage Collector.

00:30:26.450 --> 00:30:28.080
We'll enable that by default.

00:30:28.079 --> 00:30:35.439
And we've done that because the Concurrent Mark and Sweep
Garbage Collector gives you better UI responsiveness and,

00:30:35.440 --> 00:30:43.350
you know, smaller GC pass times and we think it
could be great for the attractiveness of your GUI app.

00:30:43.349 --> 00:30:48.669
Again, if your server application pass -server
because in that case we will enable the parallel GC

00:30:48.670 --> 00:30:53.180
because we believe that that's much
better suited for the server applications.

00:30:53.180 --> 00:31:02.230
So, you know, to summarize the performance of 64-bit Java 6
ond Snow Leopard is great, it's amazing and we would really

00:31:02.230 --> 00:31:08.059
like you guys to move your applications to 64-bit and
make sure that your app can take advantage of, you know,

00:31:08.059 --> 00:31:09.899
these wonderful performance improvements.

00:31:09.900 --> 00:31:15.730
And to show you how to move your app to 64-bit,
I'd like to bring back on stage Mike Swingler.

00:31:15.730 --> 00:31:16.950
>> Mike: Thank you Pratik.

00:31:16.950 --> 00:31:26.039
So, to show you how your applications can take advantage of
this great 64-bit performance that Pratik just showed us,

00:31:26.039 --> 00:31:34.619
I'd like to show you a couple of things that you can do with
a variety of IDE's and tools and a number of profiling tools

00:31:34.619 --> 00:31:41.139
that we've made available on Mac OS X for you to actually
inspect your applications and bring them up to 64-bit

00:31:41.140 --> 00:31:45.580
and actually understand their performance
characteristics when you move up there.

00:31:45.579 --> 00:31:53.129
Also, I'd like to show you a number of great debugging
tools that we've added into the operating system itself,

00:31:53.130 --> 00:31:59.750
and for JNI developers who will take
particular interest in transitioning to 64-bit,

00:31:59.750 --> 00:32:01.910
we have a number of great things for you as well.

00:32:01.910 --> 00:32:10.330
And also we're going to hear an update about the SWT
Eclipse project and what they've done in their transition

00:32:10.329 --> 00:32:15.619
from Carbon to Cocoa in order for them to
start to take advantage of 64-bit as well.

00:32:15.619 --> 00:32:19.709
So, if you're new to the platform you
might be asking yourself what sort

00:32:19.710 --> 00:32:22.350
of IDE's do we have available on Mac OS X.

00:32:22.349 --> 00:32:27.179
Well, the answer is all of the standard IDE's
that you use on other platforms as well:

00:32:27.180 --> 00:32:29.269
Eclipse and Netbeans and IDEA and all that.

00:32:29.269 --> 00:32:35.119
We also have Xcode that's available if you're
also writing applications that require JNI.

00:32:35.119 --> 00:32:41.669
We also have a variety of tools to help you
once you have your application built as a series

00:32:41.670 --> 00:32:43.960
of JAR files in your Build Output Directory.

00:32:43.960 --> 00:32:49.650
You can use Jar Bundler to take those and wrap
them inside of a double-clickable app container.

00:32:49.650 --> 00:32:52.960
You would use Icon Composer to
take art from your graphic designer

00:32:52.960 --> 00:32:56.840
and put that into Jar Bundler and
create an icon for your app.

00:32:56.839 --> 00:33:04.019
And you'll probably use Property List Editor as well
to modify any sort of VM options or various arguments

00:33:04.019 --> 00:33:08.000
that you need to pass after your application
has already been built by Jar Bundler.

00:33:08.000 --> 00:33:11.710
We also have VisualVM as Pratik showed earlier.

00:33:11.710 --> 00:33:16.150
And we also have a great tool that was
introduced in Leopard called Instruments.

00:33:16.150 --> 00:33:23.210
Instruments allows you to see what your Java
application does in a kind of holistic view

00:33:23.210 --> 00:33:27.710
of how it affects the entire performance
of the machine that you're on.

00:33:27.710 --> 00:33:34.710
So the file system access that you see inside of Instruments
isn't necessarily always just file operations you do

00:33:34.710 --> 00:33:42.000
with java.IO.File opening up input and output streams,
but it will actually show all of the side effects of, say,

00:33:42.000 --> 00:33:49.710
calling a security code in Java that might load a bunch of
native frameworks in Mac OS X and page them all onto disk.

00:33:49.710 --> 00:33:57.420
It will also show you your network access and even show
you how the power usage of your application reflects

00:33:57.420 --> 00:34:00.130
on a portable machine that you might be running on.

00:34:00.130 --> 00:34:03.680
And, of course, Instruments is also
very handy for JNI developers as it is

00:34:03.680 --> 00:34:06.789
for developers of ordinary Cocoa applications.

00:34:08.099 --> 00:34:11.860
So if you're profiling your application you
actually find that you're spending a lot

00:34:11.860 --> 00:34:15.690
of time inside of your component paint routines.

00:34:15.690 --> 00:34:22.070
One of the options that we allow you to change
is the default graphics renderer for Java.

00:34:22.070 --> 00:34:25.519
And so we have 2 renderers available,
the Sun 2D Renderer is t-he default

00:34:25.519 --> 00:34:35.610
because it has the most pixel-perfect
cross-platform representation that you can see

00:34:35.610 --> 00:34:39.849
across platforms that the output matches almost exactly.

00:34:39.849 --> 00:34:44.099
Quartz, on the other hand, has slightly
different pixel coverage in different areas

00:34:44.099 --> 00:34:46.969
because they're fundamentally different software loops.

00:34:46.969 --> 00:34:53.509
Sun 2D Renderer in 1.6 also has radically
increased in performance compared

00:34:53.510 --> 00:34:56.530
to the Sun 2D Renderer that was present in 1.5, so.

00:34:56.530 --> 00:35:03.290
But if you find that you're using things like image
types that are optimized on Mac OS X like ARGB Pre

00:35:03.289 --> 00:35:07.989
or you're doing a variety of anti-aliased
drawing operations you might find

00:35:07.989 --> 00:35:10.109
that the Quartz Renderer actually faster for you.

00:35:10.110 --> 00:35:15.920
So if you benchmark your app and flipping to the
Quartz Renderer is something that works well for you,

00:35:15.920 --> 00:35:18.860
this is a great thing that you should try out.

00:35:18.860 --> 00:35:23.710
The Quartz Renderer will continue to be supported
for a very long time since it's the foundation

00:35:23.710 --> 00:35:35.010
of scaleable graphics printing in Mac OS X for things
like, well, the print routines and for high DPI.

00:35:35.010 --> 00:35:41.660
So another great debugging tool
that we have in Mac OS X is DTrace.

00:35:41.659 --> 00:35:48.779
And so, DTrace is probably the most powerful and flexible
way that you can call from the command line or using scripts

00:35:48.780 --> 00:35:54.010
to actually introspect what's going on inside
of HotSpot and its interactions with libc

00:35:54.010 --> 00:35:56.790
and all of its interactions with the kernel.

00:35:56.789 --> 00:36:01.119
And it has great support from Instruments.

00:36:01.119 --> 00:36:08.119
If you plug in your script into Instruments and output
your data in such a way that Instruments can visualize it,

00:36:08.119 --> 00:36:13.359
we have the ability to take a lot of
scripts that are available on the Web,

00:36:13.360 --> 00:36:18.210
a lot of them even that might have been written
for Solaris will work out of the box on Mac OS X.

00:36:18.210 --> 00:36:25.840
HotSpot has over 500 DTrace probes and you can turn
them all on by passing the -XX:+ExtendedDTraceProbes

00:36:25.840 --> 00:36:34.880
to see the fullest extent of what's going on inside your
application but that will have some sort of performance hit.

00:36:34.880 --> 00:36:41.369
Another option that we've added for -- another great feature
that we've actually added in Snow Leopard is the ability

00:36:41.369 --> 00:36:46.339
to have POSIX thread names set in native.

00:36:46.340 --> 00:36:51.190
While you might not think this is terribly interesting
for a Java programmer what we've actually done

00:36:51.190 --> 00:36:56.619
in the VM is we actually take the name that you set
on a thread in JavaLangThreadSetName and we'll push

00:36:56.619 --> 00:37:03.909
that name all the way down to the POSIX thread and
so you can see that name in tools like GDB and Sample

00:37:03.909 --> 00:37:09.379
and Instruments and, God forbid, if the
application actually crashes, even Crash Reporter;

00:37:09.380 --> 00:37:15.079
this will allow you to very clearly see what
native thread corresponds with which Java thread

00:37:15.079 --> 00:37:17.750
in something like Crash Reporter or Sample.

00:37:17.750 --> 00:37:23.659
The one caveat to this, of course, is that if a thread has
already been named in ,ative, likely because it's owned

00:37:23.659 --> 00:37:28.409
by another sub-system like libdispatch, things
like ConAppleMainThread are not going to be renamed

00:37:28.409 --> 00:37:34.730
in the AWT-AppKit thread, and so you can see that
here in a sample that I took of a bundled version

00:37:34.730 --> 00:37:37.539
of SwingSet that I took with Activity Monitor.

00:37:37.539 --> 00:37:42.750
But you can see the rest of the Java threads are
all prefixed with Java: and then the name of, like,

00:37:42.750 --> 00:37:46.000
the Garbage Collector thread or the AWT-EventQueue.

00:37:48.070 --> 00:37:56.350
So another great feature that we've added to Java
6 is more understandable unsatisfied link errors.

00:37:56.349 --> 00:38:02.759
And so we found that when moving from 32-bit to
64-bit a lot of developers had a lot of problems

00:38:02.760 --> 00:38:07.220
with not necessarily JNI code that they wrote
but if they depended on a third party library

00:38:07.219 --> 00:38:12.750
that contained some JNI they would get an unsatisfied
link error and they would have no idea where it came from,

00:38:12.750 --> 00:38:21.849
so to show you an example of what I mean here are
2 errors that look identical on Leopard in Java 5

00:38:21.849 --> 00:38:30.059
and Java 6 before update 4 and they don't look any
different but they have radically different causes

00:38:30.059 --> 00:38:35.659
so what we've actually done in Java 6 is we take the error
message that comes out of DYLD and we've actually taken that

00:38:35.659 --> 00:38:40.960
and patched that into the unsatisfied link error
that's thrown in your application at runtime,

00:38:40.960 --> 00:38:47.659
so you can actually see the real reason for
different kinds of unsatisfied link errors.

00:38:47.659 --> 00:39:00.549
And so, finally, for developers of JNI we found
that there was a template that we shipped with Xcode

00:39:00.550 --> 00:39:08.320
that really wasn't a very good representative
example of how people would use JNI on Mac OS X.

00:39:08.320 --> 00:39:17.220
It called a native routine, it returned at 42 as an INT and
didn't even touch a J object and it returned it up to Java

00:39:17.219 --> 00:39:21.049
and returned back to the command
line and was actually pretty boring.

00:39:21.050 --> 00:39:28.210
So in Snow Leopard we took the opportunity to actually
redesign the entire example to be a full-swing application

00:39:28.210 --> 00:39:34.869
that talks to the Mac OS X Address Book and actually takes
all of your contacts in your address book and converts all

00:39:34.869 --> 00:39:40.210
of those Foundation data structures into Java
data structures and passes them back up to Java.

00:39:40.210 --> 00:39:42.539
And so we've done that with the assistance

00:39:42.539 --> 00:39:47.369
of a new framework we've added called the Java Native
Foundation Framework I'll talk a little bit about more

00:39:47.369 --> 00:39:54.440
in a moment, but if you want to check out this example for
yourself in the Xcode New Project Window in Snow Leopard,

00:39:54.440 --> 00:39:59.159
you just choose Framework in Library and
JNI Library's right there, hit Build and Go

00:39:59.159 --> 00:40:03.259
and you should see your full address
book come up after that.

00:40:03.260 --> 00:40:13.510
So the JavaNativeFoundation framework is actually something
that we've used internally to build the Java VM framework

00:40:13.510 --> 00:40:19.070
on Mac OS X and implement Java 5 and Java 6
in Mac OS X over the course of many years.

00:40:19.070 --> 00:40:26.490
We've taken these routines and macros and classes and
coalesced them together in a framework for JNI developers.

00:40:26.489 --> 00:40:32.059
For example, JNF Cocoa Enter and Exit are wrappers
that you put at the beginning and at the end

00:40:32.059 --> 00:40:39.029
of your native C functions that will actually catch NS
exceptions that are thrown inside of foundation code,

00:40:39.030 --> 00:40:45.700
wrap them inside Java Exceptions and re-throw them at
the boundary to Java as runtime exceptions in your code.

00:40:45.699 --> 00:40:53.119
Likewise, if you, in JNI, make a call using
JNF back into the VM and that call results

00:40:53.119 --> 00:41:00.909
in a Java Exception being thrown, once it hits the JNF
Boundary we'll take that, rewrap it as an NS Exception,

00:41:00.909 --> 00:41:05.139
and re-throw that in your Objective-C code.

00:41:05.139 --> 00:41:10.929
And, of course, this all works recursively
so that can get very interesting.

00:41:10.929 --> 00:41:19.299
We also include a wrapper object that you can use to take
JNIGlobalRefs and put them inside of Foundation Objects

00:41:19.300 --> 00:41:27.010
and then when the Foundation Collection or whoever's
retaining a reference removes the last reference

00:41:27.010 --> 00:41:33.660
and the ref count gets to 0 we actually
release the JNIGlobalRef automatically for you.

00:41:33.659 --> 00:41:40.399
And then, finally, and most powerfully, is the
JNFTypeCoercer; this is a really cool piece of technology

00:41:40.400 --> 00:41:46.170
that you can configure and plug in your own types
and we actually provide default implementations

00:41:46.170 --> 00:41:55.240
that will walk a non-cyclic object graph in Objective-C,
for example, and walk every single object inside of it

00:41:55.239 --> 00:42:04.029
and convert it into a Java object if it has a
coercer for it, and then it will return a JNIRef

00:42:04.030 --> 00:42:06.000
to you that you can pass back up to Java.

00:42:06.000 --> 00:42:14.309
Likewise, it'll also take a Java object graph and convert
that into an equivalent graph in foundation objects.

00:42:14.309 --> 00:42:19.250
And so we provide default implementations
for strings, numbers, lists, maps and sets.

00:42:19.250 --> 00:42:29.690
The new JNI example actually shows how to convert ABPersons
and ABRecords into an equivalent Java object as well.

00:42:29.690 --> 00:42:33.950
So that's something that's really powerful
and we think you'll be really excited

00:42:33.949 --> 00:42:38.359
to use that if you are so inclined to use JNI.

00:42:38.360 --> 00:42:46.650
So, with that I'd like to bring up Scott Kovatch who
actually writes a lot of JNI for the SWT Project for Eclipse

00:42:46.650 --> 00:42:49.920
to show us some exciting new stuff
that they've been working on.

00:42:49.920 --> 00:42:56.300
>> Scott: OK, so, who in here, first
of all, does not know what Eclipse is?

00:42:57.449 --> 00:43:07.349
Anybody, anybody, OK, so the SWT is, basically,
the GUI toolkit that's part of the Eclipse Project,

00:43:07.349 --> 00:43:11.309
so when you run Eclipse you're running
the SWT that shows you all of your buttons

00:43:11.309 --> 00:43:12.759
and your controls and everything in the window.

00:43:12.760 --> 00:43:24.340
It's also the foundation for RCP apps which are, basically,
applications that you build for your custom application

00:43:24.340 --> 00:43:30.990
that take advantage of all the Eclipse Project frameworks.

00:43:30.989 --> 00:43:42.209
It began many, oh, many years ago now as a 32-bit
Carbon implementation and it's been maintained

00:43:42.210 --> 00:43:54.130
and it's been heavily used over the years but, you know, as
you heard last year, Cocoa 64-bit is the future of Mac OS X,

00:43:54.130 --> 00:43:58.980
so if you have a Carbon application, well,
you've got to do something about that.

00:43:58.980 --> 00:44:06.670
So last year an effort to move the SWT over to
Cocoa got underway from the IBM Ottawa Group

00:44:06.670 --> 00:44:13.220
and then late last summer I got involved
from Adobe and contributed some work to that.

00:44:13.219 --> 00:44:23.480
And because of all this effort the Cocoa SWT in Eclipse 3.5
is now -- not only is it an officially supported platform

00:44:23.480 --> 00:44:30.610
but when you go to download Eclipse 3.5 for Mac
OS X you will get the Cocoa version by default,

00:44:30.610 --> 00:44:33.010
so the Carbon version is going to be officially deprecated.

00:44:33.010 --> 00:44:36.890
[ Applause ]

00:44:36.889 --> 00:44:38.829
>> Scott: Thank you.

00:44:38.829 --> 00:44:43.159
The Carbon version is going to be
considered deprecated when 3.5 ships.

00:44:43.159 --> 00:44:54.440
So that means that we'd really like you to move your code
off of the Carbon version and onto Cocoa as best you can.

00:44:54.440 --> 00:45:01.519
If you find any new bugs in the Carbon 3.5, not
much is going to happen with it at this point.

00:45:01.519 --> 00:45:08.360
We really want to get people onto Cocoa so we can start
flushing out any remaining problems that are there.

00:45:08.360 --> 00:45:13.250
So if you've ever moved from Carbon
to Cocoa you know that, you know,

00:45:13.250 --> 00:45:19.190
thanks to the fidelity between the 2
frameworks you're not going to see a whole lot

00:45:19.190 --> 00:45:23.460
of difference unless you're looking in very specific places.

00:45:23.460 --> 00:45:31.490
And I've written a, because of that, when you go to the
Cocoa SWT you're going to wonder, well, you know, OK,

00:45:31.489 --> 00:45:36.419
what's new other than, you know, it looks
like Eclipse when I run Eclipse and, you know,

00:45:36.420 --> 00:45:39.480
what's new and what's new in the Cocoa SWT?

00:45:39.480 --> 00:45:43.769
So I've written a little application that I'm
calling "8 New Features in Under 8 Minutes"

00:45:43.769 --> 00:45:46.800
where I'm going to show you what's new in the Cocoa SWT.

00:45:46.800 --> 00:45:53.030
So on the left here I've written -- OK, both --
first of all, both of these are using the 3.5 SWT

00:45:53.030 --> 00:45:57.060
and on the left I wrote these are the identical application.

00:45:57.059 --> 00:46:02.049
The application on the right has a little clock
I've added but otherwise the code is identical

00:46:02.050 --> 00:46:06.390
for presenting what I want to show
you in this next little session here.

00:46:06.389 --> 00:46:13.589
And on the left is the Carbon SWT
and on the right is the Cocoa SWT.

00:46:13.590 --> 00:46:18.400
So the clock is running, let's
get going with Feature Number 1.

00:46:18.400 --> 00:46:26.210
So these first couple of features are in both the
3.5 SWT's and so I'm going to zip through them

00:46:26.210 --> 00:46:30.920
but they're worth knowing about because
they're actually nice additions.

00:46:30.920 --> 00:46:38.389
So in Swing it is possible to set a Client
Property on a window or on a J Frame

00:46:38.389 --> 00:46:44.230
and we'll set the Window Modified flag
up in the Close button for the window.

00:46:44.230 --> 00:46:46.780
Well the SWT now has that as well.

00:46:46.780 --> 00:46:57.180
It's a new API and you can set that, unset it, and if you
run Eclipse 3.5 you'll notice that when you start typing

00:46:57.179 --> 00:47:02.329
in the window it takes advantage of
this, so that's Feature Number 1.

00:47:02.329 --> 00:47:11.110
Feature number 2; OK, what I have here is a standard
text widget and over here on the Carbon I'm going

00:47:11.110 --> 00:47:17.380
to Control-click on some text here and as you
can see, well, nothing's really happening.

00:47:17.380 --> 00:47:22.170
I've got a misspelling here but
Control-clicking, nothing goes on.

00:47:22.170 --> 00:47:27.789
And because we're using Cocoa now if you
do that same thing in the Cocoa SWT you see

00:47:27.789 --> 00:47:31.480
that we get the standard Context Menu in a Text Object.

00:47:33.650 --> 00:47:37.500
And, of course, I can turn on, you know,
Spelling and Grammar, Check the Document.

00:47:37.500 --> 00:47:42.010
You see, oh, look there I've got a
misspelling and I'm going to fix that.

00:47:42.010 --> 00:47:46.990
[ Background noise ]

00:47:46.989 --> 00:47:52.119
>> Scott: Yeah, all the normal things you expect out
of a Text field in Cocoa and that's Feature Number 2.

00:47:52.119 --> 00:47:53.949
That comes for free, you don't have to do anything.

00:47:53.949 --> 00:47:59.549
If you make a multi-line or a single-line
Text field that's just going to work.

00:47:59.550 --> 00:48:08.570
All right, Feature Number 3; again, this is something
that was in Swing that Mike added the last year.

00:48:08.570 --> 00:48:17.460
We've now taken advantage of the Native Search
Field that's available in both Carbon and Cocoa

00:48:17.460 --> 00:48:23.590
These are extra bits that you put onto
an SWT Text, on a single-line Text.

00:48:23.590 --> 00:48:30.550
If you look into the Text Java Dock you'll see the bits.

00:48:30.550 --> 00:48:38.470
You can add one for the Search icon and the Cancel icon,
so if we go over here, and "What Do You Want to Find?"

00:48:38.469 --> 00:48:44.559
Stuff. And I can cancel that with the
X and it clears it out and, you know,

00:48:44.559 --> 00:48:53.679
if you add 2 bits to your Text Field Constructor now
you've got a Search Field, so that's Feature Number 3.

00:48:53.679 --> 00:49:02.159
OK, in Feature Number 4 here, look on the left you have;
this is a Date/Time Widget and in Carbon there really wasn't

00:49:02.159 --> 00:49:09.119
like a system-provided control you could use so what they
ended up doing is writing in their own custom version.

00:49:09.119 --> 00:49:17.710
And it, you know, it's not bad but it doesn't
look like a -- it looks like a home-grown thing.

00:49:17.710 --> 00:49:24.400
Well, in Cocoa now we use NSDate Time or NSDate Picker
rather and, basically, you get the same behavior.

00:49:24.400 --> 00:49:30.710
But the nice part is you get all the
standard behavior out of the Cocoa widget.

00:49:30.710 --> 00:49:37.889
So I can, you know, click here, move
around and jump back to where I was.

00:49:37.889 --> 00:49:46.170
You know if you've ever written an NSDate Picker you know
you're going to get all of those behaviors for free as well.

00:49:46.170 --> 00:49:47.630
That's Feature Number 4.

00:49:47.630 --> 00:49:53.019
OK, now we're getting into some of the interesting stuff.

00:49:53.019 --> 00:49:58.150
In Carbon if I want to put up a File
dialogue here's what I'm going to get, just,

00:49:58.150 --> 00:50:02.240
you know, plain old standard File dialogue.

00:50:02.239 --> 00:50:09.539
And I'm going to pick a file here and I'm going to
get an alert saying we're going to try and delete it.

00:50:09.539 --> 00:50:14.009
Well, in Cocoa I can now add a bit
to my Constructor and I get a sheet.

00:50:14.010 --> 00:50:18.540
[ Applause ]

00:50:18.539 --> 00:50:24.619
>> Scott: Pick a file and the Message Box
also has -- can be created as a sheet.

00:50:24.619 --> 00:50:30.739
Anything that drives from dialogue you can
add a bit that says SWT.sheet, order that in

00:50:30.739 --> 00:50:34.209
and we're going to make a sheet appear on Cocoa.

00:50:36.329 --> 00:50:42.549
That is Feature Number 5, and when did that show up?

00:50:42.550 --> 00:50:50.340
All right, now, Feature Number 6; this one's kind of sneaky
and dishonest because I'm showing you work in progress.

00:50:50.340 --> 00:50:57.059
In Cocoa -- I'm sorry -- in Carbon if you want to
put a Toolbar into your window it's going to be stuck

00:50:57.059 --> 00:51:02.909
into the window as a sub-view of a
composite or of the shell itself.

00:51:02.909 --> 00:51:09.239
Now if you grab a patch, which we're going to make
available to you through the Eclipse Bugzilla,

00:51:09.239 --> 00:51:15.649
and you apply it to your SWT you
can make a toolbar that looks this.

00:51:15.650 --> 00:51:21.740
And, basically, what we've done is
we've hooked into with a separate bit,

00:51:21.739 --> 00:51:30.089
we've hooked into the standard Window Toolbar
API's and, basically, you can create the equivalent

00:51:30.090 --> 00:51:37.539
of an Eclipse Toolbar and Tool Items and it'll get
stuck up into the standard place for a toolbar.

00:51:37.539 --> 00:51:44.559
Now, this is work in progress because we need to come up
with new API in which we are really pushing to have happen

00:51:44.559 --> 00:51:50.480
in 3.6 because there's a lot of implications here
because the toolbar is not considered part of the content

00:51:50.480 --> 00:51:55.159
of the window, so, you know, we've
got to do some thinking about it.

00:51:55.159 --> 00:52:02.639
But if you really, really want this today you can
do this and, you know, we'll let you know how to --

00:52:02.639 --> 00:52:06.750
we'll have a link available for you to
figure out how to get it if you want

00:52:06.750 --> 00:52:10.750
to do it right now, and that's Feature Number 6.

00:52:10.750 --> 00:52:17.420
All right, Feature Number 7 is
actually my feature but I'm going

00:52:17.420 --> 00:52:22.170
to show you changes in how we do Drag and Drop Feedback.

00:52:22.170 --> 00:52:27.789
So if you look over here on the left in Carbon I'm going
to select a bunch of files and we'll start dragging things

00:52:27.789 --> 00:52:35.940
around and we'll zoom in here and you can see
that we have this sort of generic-looking square.

00:52:35.940 --> 00:52:40.639
If you do any drag in Carbon this
is what you're going to get.

00:52:40.639 --> 00:52:51.250
So in Cocoa we now have normal-looking drag feedback so
if you start dragging out of a tree or a table or anything

00:52:51.250 --> 00:52:55.369
like that we'll get an actual ghost of the
things that you're dragging and if you drag

00:52:55.369 --> 00:53:01.819
over some place it can be dropped, you know,
if you look in the Finder or if you look

00:53:01.820 --> 00:53:09.210
in Xcode you'll have the exact same looking
feedback on -- now in an Eclipse or RCP app.

00:53:09.210 --> 00:53:11.010
That all comes for free.

00:53:11.010 --> 00:53:18.960
[ Applause ]

00:53:18.960 --> 00:53:25.039
>> Scott: And last of all you see I've
been running these examples in Java 6

00:53:25.039 --> 00:53:31.139
and you'll see that in Carbon it's only x86 or i386.

00:53:31.139 --> 00:53:35.500
In Cocoa I've been running this on the 64-bit SWT.

00:53:35.500 --> 00:53:40.039
And for those of you who say, well, yeah anybody
can put strings into their hard-coded strings

00:53:40.039 --> 00:53:44.050
if you don't believe me, here's Activity
Monitor and we'll look at SWT and see,

00:53:44.050 --> 00:53:47.930
yes, indeed, I have a 64-bit process running.

00:53:51.110 --> 00:53:59.610
[applause] So, and I actually did
it with 37 seconds to spare.

00:53:59.610 --> 00:54:03.740
So just a quick summary of what I just showed
you, here's the 8 new features that I showed you.

00:54:03.739 --> 00:54:06.729
The biggest are towards the end.

00:54:06.730 --> 00:54:10.289
64-bit support is available as a separate download.

00:54:10.289 --> 00:54:14.289
You would basically grab the 64-bit drop of Cocoa SWT.

00:54:14.289 --> 00:54:22.739
We are working to make a universal build of the SWT.

00:54:22.739 --> 00:54:29.039
I'm hoping that can happen in the near future
because that's actually very important to us

00:54:29.039 --> 00:54:33.170
at Adobe, but, you know, you can get this today.

00:54:33.170 --> 00:54:40.960
It's available at like Release Candidate 4
Status and you can go to download.eclipse.org

00:54:40.960 --> 00:54:45.809
and that'll show you all the available versions.

00:54:45.809 --> 00:54:55.949
Eclipse 3.5 ships in 2 weeks from yesterday which
is June 24, and so now is the time to start thinking

00:54:55.949 --> 00:55:02.129
about how you're going to move your application to
Galileo, which is the code name for Eclipse 3.5.

00:55:02.130 --> 00:55:07.990
And with that I'm going to take
you back to Mike to finish up.

00:55:07.989 --> 00:55:10.500
>> Mike: So SWT looks fantastic.

00:55:10.500 --> 00:55:16.320
And so just to recap briefly what we've seen today.

00:55:16.320 --> 00:55:23.990
We've seen that Java is a Core Framework of Mac OS X and
it's actually built into the OS and it's something that you

00:55:23.989 --> 00:55:30.649
and your customers can count on as always
being there and Apple will keep it up to date

00:55:30.650 --> 00:55:35.309
and give you the best version for your customers.

00:55:35.309 --> 00:55:43.380
We also showed you a couple of exciting new features in Snow
Leopard and the great Java 6 performance in Snow Leopard,

00:55:43.380 --> 00:55:46.710
especially if you can move your application up to 64-bit.

00:55:46.710 --> 00:55:52.730
We showed you how you can tune your application using
VisualVM and Instruments and showed you a number

00:55:52.730 --> 00:55:57.590
of little tips and tricks to debugging
to help get your app up to 64-bit.

00:55:57.590 --> 00:56:05.539
And then, finally, we saw fantastic work that Scott and
the SWT Team have been doing to bring their applications

00:56:05.539 --> 00:56:09.420
to Cocoa so they can take advantage of 64-bit as well.

00:56:09.420 --> 00:56:16.680
So if you want to see more information about all you've
heard about today I'd actually highly encourage you to check

00:56:16.679 --> 00:56:21.449
out the Java Development Guide for Mac OS X
which has been recently revised for Snow Leopard.

00:56:21.449 --> 00:56:26.769
A lot of what we talked about today is actually contained in
that document and it's actually associated with the session

00:56:26.769 --> 00:56:30.030
so you can check that out on WWDC Connect or you can --

00:56:30.030 --> 00:56:35.870
well, it'll be published publicly once
Snow Leopard is generally available.

00:56:35.869 --> 00:56:42.779
We also encourage you to subscribe to the
Java Dev Mailing List on list.apple.com.

00:56:42.780 --> 00:56:48.070
It's a place where seasoned Java
developers and the members of the Java Team

00:56:48.070 --> 00:56:52.110
at Apple actually help solve technical
problems that you might be having

00:56:52.110 --> 00:56:57.900
and it's fairly medium traffic so
we would like to see you there.

00:56:57.900 --> 00:57:01.240
Also, please check out the Snow Leopard Developer Forums.

00:57:01.239 --> 00:57:07.589
But most importantly, if you encounter a bug,
please send us your bugs at bugreport.apple.com;

00:57:07.590 --> 00:57:11.820
this is your way to communicate directly with the team.

00:57:11.820 --> 00:57:20.180
We screen your bugs every -- many times a week in
order to, you know, see everything that's coming in,

00:57:20.179 --> 00:57:25.460
so if you have a feature request or if there's a
problem please let us know at bugreport.apple.com.